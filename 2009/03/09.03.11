00:00:08 <wli> It presumes similar speech organs, though. Aliens with multiple analogues of larynxes/syrinxes might have speech involving harmony, aquatic aliens might use speech patterns/mechanisms more oriented toward the transmission of sound through water, and it's conceivable others might use visual (like sign language) or tactile (touch, like squeezing in Morse code and Braille for writing) communication.
00:01:23 <wli> (Or maybe even olfactory with pheromone emission -like affairs.)
00:02:32 <harblcat> "The alien hums in low c while motioning randomly in the air. It is hungry."
00:02:48 <harblcat> That would be weird.
00:03:39 <wli> harblcat: On the musical front it would probably have more to do with the combination of notes struck by its multiple vocal organs.
00:03:54 <wli> So a chord vs. a note.
00:04:21 <harblcat> If they talk in chords, I wonder what the music would sound like...
00:04:27 <harblcat> chords of chords?
00:05:03 <wli> Too far out to speculate. Note that there are tonal human languages (Vietnamese, Chinese, others?).
00:05:43 <harblcat> But, afaik, Chinese only has four different intonations.
00:05:55 <koala_man> they might not even have music. their idea of pleasurable sounds might be those made by mating partners. or maybe a dead silence.
00:06:03 <pumpkin> harblcat: mandarin, at least
00:06:11 <pumpkin> plus a sort of "neutral" tone
00:06:13 <wli> And has the human limitation of a single simultaneous tone.
00:07:11 <harblcat> I'd hate to happen across a species of alien that communicated by either consumption or regurgitation.
00:07:49 <wli> harblcat: There are also some linguistics affairs that give one a sort of idea of the characteristics of human language grammar and writing systems. Going "alien" might involve using linguistic or writing system constructs not found in any human language.
00:08:32 <dancor> can't like tibetan throat singers do like two or three notes at once
00:08:36 <wli> harblcat: They could make sound like crickets, by mechanically rubbing/striking/etc. body parts against each other.
00:08:39 <koala_man> I thought all aliens spoke english and were distinguished by the different bumps on their heads
00:08:46 <harblcat> Well, the whole idea of an undetermined alien physiology sparks a few creative thoughts, surely.
00:08:49 <harblcat> koala_man: lol
00:09:10 <jml> dancor: yes.
00:09:56 <harblcat> There's always the possibility of Cthulhian aliens, ones that communicate by making your head explode.
00:10:13 <jml> I've also met a man who could whistle two notes at once -- very alienating.
00:10:45 <SubStack> was he a phreaker?
00:11:19 <jml> no, just a plain old arts students
00:11:26 <jml> s/s$//
00:11:29 <dancor> we need more freaky cults that do things like all wear mouthpieces and communicate in a higher bandwidth chordlang
00:11:55 <harblcat> Thinking about all these different possibilities, though, brings me to question how I would transliterate an alien language into latin characters...
00:12:04 <wli> I guess the thing I was trying to pass along to harblcat was that the goal of simulating alien speech and/or writing (I didn't get very far into writing, I guess) might be better approached by a different method from generating strings of human vowels and consonants.
00:12:54 <jml> harblcat: avoid the example set by the Welsh.
00:12:54 <SubStack> harblcat: obviously by prefacing common words with "astro" and "star"
00:12:59 <lament> ocmln. orngycrbS yfl. cb "<>PYF ,d.b frgp t.fxrape nafrgy co ajygannf Ekrpat
00:13:06 <dancor> well you might consider it pretty likely there would be a grammatical structure of some base units
00:13:25 <lament> Ph’nglui mglw’nafh Cthulhu R’lyeh wgah’nagl fhtagn!
00:13:36 <dancor> and you could call those base units xenophonemes even if they are head-explosions
00:13:59 <harblcat> dancor: good idea
00:14:42 <harblcat> Different xenophonemes would combine into different combinations of human sounds, which could then be placed into latin characters.
00:14:44 <wli> SUre; however, the grammars are plausibly quite different from anything occurring in human contexts, e.g. involving simultaneity, discretely quantifiable intensity, etc.
00:15:40 <SubStack> or you could just take names from doctor who
00:15:45 <harblcat> wli, I begin to suspect you have already placed some thought into this or a similar concept...
00:15:49 <dancor> but at its informatic core it should have some simple grammar description right?
00:16:10 <dancor> unless the aliens can do like infinite parsing in a finite time or something insane
00:16:21 <wli> harblcat: Actually I'm very literally winging this as we speak.
00:16:28 <SubStack> base 4 encoding!
00:16:47 <harblcat> 023101203?
00:17:08 <wli> dancor: It might not fit into the sorts of grammars we have around but there are probably ways to conceptualize them by sufficiently generalizing grammars.
00:17:34 <harblcat> Well, it would be pretty mind-bending to come across aliens with no concept of life or death.
00:17:51 <harblcat> That is sort of a fundamental concept to most human cultures.
00:18:05 <SubStack> or the aliens could speak with an approximately optimal encoding scheme
00:18:24 <SubStack> and do the various transformations necessary subconsciously
00:18:26 <lament> harblcat: we would totally kick their asses at Go
00:19:08 <harblcat> lament: 'What does it mean that you took my stones?'
00:19:39 <dancor> harblcat: if they are advanced the must have some idea of the heat death of the universe..
00:19:41 <wli> SubStack: Their grammatical connectives could have innate branching factors high enough to defy human limitations of comprehension (which top out at something like 5 or 6, relying on compositionality to simulate others).
00:19:56 <lament> "I ripped your head off, how come you are no longer speaking?"
00:20:14 <lament> a common diplomatic blunder
00:20:39 <SubStack> perhaps such a species could arise that communicated biologically by radio waves where necessary long-range transmissions required large amounts of energy
00:20:48 <harblcat> dancor: Perhaps they are temporally constant..
00:21:03 <SubStack> so natural selection just added more raw processing power
00:22:01 <harblcat> wli: Those aliens would laugh at lojban
00:22:01 <dancor> well.. my existence is four-dimensional, it's just that my consciousness is 3d and changes over time
00:22:04 <wli> harblcat: There are quasi-immortal species, such as the hydra (a colony organism?). Regeneration and otherwise lack of such limitations as telomere length vs. mitosis are also possible.
00:22:15 <dancor> so really we'll have a lot in common ;)
00:22:32 <harblcat> wli: not immortal. Existing in all time at once.
00:22:46 <SubStack> markov systems are somewhat limited at simulating languages for these sorts of beings
00:23:01 <wli> I'm not imaginative enough for that sort of consideration.
00:23:43 <harblcat> SubStack: You'd merely have to factor in whether a species has appendages, windpipes, eyes, etc...
00:23:58 <dancor> the thing is that everything in the universe proceeds forward thru time
00:24:05 <lament> don't forget intelligent shades of the colour blue.
00:24:20 <dancor> if the aliens don't then they won't really ever be observable to us it seems like
00:25:00 <harblcat> dancor: as you move forward, you move along a 4d path. I was talking about the aliens being aware of every moment on that path.
00:25:12 <hiredman> in troll lore it is believe that living beings are really going backwars through time
00:25:40 <harblcat> But, does anyone really know what time it is?
00:25:56 <dancor> harblcat: ok.  to me it seems like you could just call them prescient and eternal and call it a day
00:26:21 <wli> harblcat: There are practical solutions to the multiple larynx/syrinx problem: represent the speech in musical notation, which has chords to represent simultaneous sounds.
00:26:47 <dancor> (instead of worrying about "how exactly" they exist in spacetime)
00:27:51 <harblcat> my brain hurts, now. Thanks for the input!
00:28:01 <harblcat> \quit sleep
00:28:09 <ImInYourMonad> anyone good with happstack? why is it using so many monads?
00:28:14 <harblcat> er...
00:28:14 <wli> harblcat: The non-auditory methods such as sign language analogues also have diagrammatic methods of representing sequences of signs.
00:28:25 <pumpkin> ImInYourMonad: you jealous because it's in more monads than you?
00:28:42 <wli> harblcat: (In fact, sign language has such as it stands.)
00:29:00 <dancor> at least happstack seems to be on a less insane use-every-monad-and-extension track than happs was
00:29:12 <lament> just use C++ with threads to denote speech.
00:31:36 <dancor> that sounds like a recipe for schizophasia
00:31:47 <wli> harbcat: There are issues when things exist on (primarily longer) timescales, such as plant-like aliens communicating via pheromones such as plants on earth already do, but in intelligent fashions. Tactile communication can be represented with systems for representing areas touched, intensity of touch or method of touch (how many and/or which parts are used to strike), duration of the strikes, etc. with some accommodations for simultaneity.
00:32:53 <wli> harblcat: So you can get real alien real fast generating pure gibberish in formats sufficiently different from those with which people are familiar.
00:34:00 <dancor> harblcat existed on a brief timescale
00:34:04 <wli> harblcat: Probably the most difficult here is visual/sign since you're instantly into rendering etc. problems trying to represent body/limb/digit configurations.
00:34:49 <wli> Does all this seem like common sense to anyone more than just me?
00:35:26 * dancor hadn't thought too much about intelligence-limiting-possible-timescales
00:35:59 <wli> I've never thought of much of any of this before tonight.
00:36:28 <dancor> if all life on earth was twice as slow couldn't humans be just as intelligent
00:36:37 <dancor> seasons would seem twice as fast etc
00:37:48 <wli> There isn't a straightforward answer to that. Metabolic rates don't exist in a vacuum nor are the chemical systems really all that flexible.
00:38:30 <dancor> anyway that's the kind of thought experiment that makes me class intelligence-vs-timescale outside the realm of "common sense"
00:40:50 <wli> It was an assumption for the purposes of the conversation that life was intelligent but radically different in structure. The extent to which reality gets in the way of intelligence occurring in combination with the alternative structures was punted on.
00:42:17 <raxas> considering number of quantum states of the star, does the sun have enough capacity for combinatoric computation which emulates whole earth with all of us?
00:43:41 <kiris> intelligent meat?
00:43:44 <kiris> meat.
00:43:49 <SubStack> something like the sun doesn't seem capable of maintaining much collected information for very long
00:44:28 <wli> I was trying to limit the extent to which I was delving into science fiction to what was necessary for the domain-specific problem of generating simulated alien language with the performance metric of "how alien it looks."
00:45:19 <SubStack> optimality is pretty universal
00:45:50 <dancor> nonoptimality more so ;)
00:46:01 <wli> Not sure what you guys are on about.
00:46:28 <pumpkin> > arr (+1) >>> arr (+2) $ 5
00:46:30 <lambdabot>   8
00:46:36 <pumpkin> > (+1) >>> (+2) $ 5
00:46:37 <lambdabot>   8
00:46:43 <pumpkin> is the explicit arr ever necessary?
00:46:48 <pumpkin> it makes me feel like a pirate
00:46:55 <Stephan202> :P
00:47:13 <wli> I think I should try to reduce things to sums of products with one big denominator in binary operator form.
00:47:23 <pumpkin> > (+1) >>^ (+2) $ 5
00:47:24 <lambdabot>   8
00:47:28 <pumpkin> > (+1) ^>> (+2) $ 5
00:47:29 <lambdabot>   8
00:47:39 <pumpkin> hrmm
00:48:07 <pumpkin> > (+1) <+> (+2) $ 5
00:48:08 <lambdabot>       Ambiguous occurrence `<+>'
00:48:08 <lambdabot>      It could refer to either `Control.Arrow...
00:48:17 <QtPlaty[hireme]> :t (>>)
00:48:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
00:48:26 <dancor> pumpkin: it's only necessary to pull functions into arrows-which-are-not-the-function-arrow
00:48:29 <dancor> right
00:48:37 <pumpkin> dancor: like what?
00:48:44 <pumpkin> ah <+> is only for Kleisli
00:49:05 <wli> I'm still clueless about arrows which are not the function arrow.
00:49:06 <pumpkin> but doesn't Kleisli encompass the (->) Monad instance?
00:49:30 <pumpkin> oh, it wants a MonadPlus
00:49:35 <dancor> pumpkin: are you asking what are other arrows beside the arrows of functions?  there are some listed at http://www.haskell.org/arrows/
00:49:41 <wli> What arrows are there which are not the function arrow?
00:50:39 <wli> Okay, the only example there I can even begin to approach is the automata example.
00:50:42 <kiris> did you guys hear about Drushek? a completely voiceless language conlang which consists of clicks and noises like a chipmunk. google video presentation of it here: http://video.google.com/videoplay?docid=7329529495190435592 pretty interesting
00:51:43 <wli> kiris: conlang?
00:51:52 <kiris> wli: constructed language (as opposed to natural)
00:51:56 <Pip> hello, why GHC is so huge package ?
00:52:06 <dancor> Yampa used arrow.. but now reactive is kwlr i guess
00:52:10 <kiris> Pip: infinite precision requires infinite verbosity
00:52:42 <dancor> it built up a stream transformer i guess
00:52:48 <Pip> kiris, Is it a philosophy channel ?
00:53:08 <dancor> how does ghc compare to like gcc
00:53:13 <dancor> in size
00:53:40 <Pip> GCC is only about 70M
00:54:02 <Pip> But GHC would be more than 300M after installation
00:54:10 <kiris> wli: I only pasted it because you were talking about alien languages, thought it might be interesting as *one* fresh look at a non-human language
00:54:16 <wli> On the parsing front, I'm still stumped as to how to construct table-driven parsers, but anyway.
00:54:29 <Pip> dancor, Er... unless you meant the complete GCC distribution
00:54:40 <wli> It seems so obvious until you actually try it.
00:54:58 <dancor> Pip: i think you get quite a few libraries in the ghc install
00:55:17 <pumpkin> plus a whole build system
00:55:46 <dancor> also i could see ghc executables (including ghc itself..)
00:55:57 <dancor> being bigger from things like the runtime-system stuff
00:56:18 <pumpkin> yeah, static linkage doesn't help
00:56:25 <Pip> It's from the repository of my linux distribution
00:57:19 <pumpkin> also, haskell is a more sophisticated language than c, so the compiler has more work :P
00:58:17 <wli> data UnOp = NegOp ; data BiOp = AddOp | SubOp | MulOp | DivOp | PowOp ; data Expr = LitExpr Integer | VarExpr Char | UnOpExpr UnOp Expr | BiOpExpr BiOp Expr Expr
00:58:29 <dancor> and ghc has a lot less development man-hours in it and the ppl doing it probably care less about resulting size than other things
00:59:05 <dancor> it's always amazed me that ghc is results in such fast code despite development man-hours constraint
00:59:14 <dancor> haskellers have a lot to prove ;2
00:59:27 <pumpkin> :D
01:00:55 <wli> So I guess I want to reduce that to sums of products with one big denominator, constant rational exponents, and rational denominators.
01:01:38 <wli> And hand back errors when exponents aren't constant and/or rational.
01:02:52 <pumpkin> @instances Category
01:02:52 <lambdabot> Couldn't find class `Category'. Try @instances-importing
01:02:57 <wli> (In fact, Z[x] denominators, and Z[x][y]/(p(x,y)) with p monic in y numerators, but maybe that's best left for later.)
01:04:35 <Pip> So how did you guys install ghc ?
01:04:45 <jml> sudo apt-get install ghc
01:04:45 <Pip> from source or binary package ?
01:04:53 <pumpkin> I grabbed me a binary package
01:04:55 <Pip> jml, How large is it on your disk ?
01:05:07 <jml> Pip: not a clue.
01:05:20 <pumpkin> 421 MB on mine
01:05:29 <pumpkin> mac os version
01:05:42 <Pip> Okay, I'm going to compile it without libraries
01:05:50 <pumpkin> :o
01:05:51 <pumpkin> why?
01:06:12 <Pip> Make it smaller
01:06:33 <pumpkin> you need base
01:06:38 <Pip> The source package of ghc is only 9.1M of 6.10.1
01:07:32 <pumpkin> it gets large quite quickly
01:09:16 <pumpkin> the profiling version of libHSghc-6.10.1 alone is 63 MB on my computer
01:12:20 <Pip> Then abort mission
01:12:43 <pumpkin> are you really that short on space?
01:12:47 <pumpkin> you can probably avoid the profiling lib
01:15:55 <dolio> You can get hard drives for 10 cents/GB these days.
01:16:06 <dolio> So GHC costs, like, 5 cents.
01:16:07 <bremner> dolio: for my iphone?
01:16:22 <dolio> You're going to compile things with your iphone?
01:16:35 <augustss> bremner: If you strap your iPhone to a big disk. ;)
01:16:59 <bremner> dolio: well, I wouldn't mind having ghci on my phone
01:17:07 <pumpkin> the issue with the iphone is RAM, not drive space
01:17:13 <pumpkin> I'd expect
01:17:18 <pumpkin> unless you have a lot of music/porn on it :)
01:17:25 <augustss> It works fine to compile C on the iPhone.
01:17:38 <bremner> yeah, maybe I should learn to use hugs, which runs fine on the iphone
01:17:40 <pumpkin> yup, but gcc tends to use less ram than ghc
01:17:56 <pumpkin> and we have tried to have gcc compile itself on the iphone, and it eventually gave up :)
01:18:03 <pumpkin> large source files = no
01:18:13 <augustss> i believe you
01:18:17 <wli> Okay, SubOp can be eliminated with BiOpExpr SubOp x y -> BiOpExpr AddOp x $ BiOpExpr MulOp (Literal $ -1) y
01:18:35 <wli> There's probably a way to write these rules down...
01:18:52 <wli> (mathematical notation that is)
01:19:27 <augustss> wli: you can also rewrite it with NegOp
01:20:17 <wli> augustss: For the purposes of representing algebraic functions in some canonical form, eliminating NegOp must also be done.
01:21:56 <wli> I'm trying to get it down to one big denominator in Z[x] and a numerator that's a sum of surds with coefficients in Z[x]
01:22:47 <Axman6> argh! i can;t think imperatively anymore!
01:23:05 <Axman6> trying to write something in C, and i just can't figure out how i can do it :'(
01:23:18 <wli> augustss: This should be simple, but I'm choking on it anyway.
01:23:35 <wli> Axman6: What are you trying to write in C?
01:23:50 <augustss> wli: Isn't it just a rewrite function with a bunch of cases?
01:23:51 <vegai> Axman6: oh come on, you're not an ant :)
01:23:53 <pumpkin> Axman6: there, there
01:23:53 <Axman6> something that'll take a number, and give you the nth prime number
01:24:05 <Axman6> and i just can't figure out the loops
01:24:11 <pumpkin> aw
01:24:12 <Axman6> it's rediculous
01:24:14 <pumpkin> trial division ftw
01:24:18 <augustss> wli: and you have to decide what your canonical form is
01:24:20 <vegai> you're into the prime number business too?
01:24:23 <vegai> there's good money there.
01:24:27 <Axman6> heh
01:24:32 <pumpkin> break RSA and I'll be your best friend
01:24:34 <Axman6> won't be very efficient
01:24:35 <wli> augustss: Yeah, which is why it's so frustrating that I'm failing.
01:24:43 <augustss> wli: why do you want a canonical form?
01:25:55 <wli> augustss: So I can do conal's automatic differentiation on algebraic functions with the "testing for zero" problem solved.
01:26:18 <wli> Or demonstrate that there is a solution for such a limited class of functions.
01:26:41 <augustss> Is this related to testing if two expressions are equal?
01:26:48 <wli> Yes.
01:27:36 <augustss> I didn't think that was possible
01:27:51 <augustss> Not with +, *, and ^
01:28:15 <wli> I think it might be for sufficiently restricted classes of functions.
01:29:28 <augustss> I think it is if you get rid of ^, but it was more than 15 years ago I heard a collegue talk about it, so I could be wrong.
01:29:59 <wli> I think it works with ^ so long as the exponents are rational constants.
01:31:03 <augustss> Ah, yes, something like that could do the trick.
01:31:31 <wli> The math is hurting me though.
01:32:03 <augustss> wli: so make a new data type that only allows you to construct things on canonical form, and then write a function between the full one and the canonical one.
01:32:23 <wli> I'm having too much trouble with that.
01:32:51 * aleator manages to submit his first cabal package to hackage.
01:32:52 <augustss> But that way the type checker will help you
01:32:59 <wli> augustss: I think writing each elimination rule as a separate function might help.
01:34:39 <augustss> do you know what the cnonical form should be?
01:35:43 <wli> Yeah, one big denominator and one big numerator. The denominator should be in Z[x] and the numerator a sum of radicals with coefficients of the radicals in Z[x].
01:36:10 <augustss> You will get an exponential explosion in size in the worst case, right?
01:36:51 <wli> Possibly. I'm not too concerned about that so long as the reliable testing for 0 holds.
01:38:40 <osfameron> lambdabot: DPH?
01:38:49 <osfameron> ah, lambda doesn't do infobot
01:39:23 <kaol> @where DPH
01:39:23 <lambdabot> http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
01:39:33 <osfameron> ah!
01:39:41 <osfameron> how does it know that?
01:39:47 <kaol> someone used @where+
01:39:54 <osfameron> I thought 'where' was an index search, but that's an acronym expansion
01:40:12 <kaol> @where haskell
01:40:12 <lambdabot> http://haskell.org
01:40:28 <pumpkin> osfameron: it's just a key/value binding
01:40:32 <osfameron> ah I see
01:40:44 <osfameron> so someone's manually told it about DPH.  How do you do that?
01:40:57 <pumpkin> @where+ pumpkin http://pumpkinpat.ch
01:40:57 <lambdabot> It is stored.
01:41:18 <kaol> @help where+
01:41:18 <lambdabot> where+ <key> <elem>. Define an association
01:41:19 <osfameron> ah sorry, I saw the reference to '@where+' but misparsed it
01:41:25 <osfameron> thanks
01:48:11 <wli> This is where row types for variants would really come in handy.
01:49:46 <Axman6> whoot, finally figured it out!
01:50:52 <Axman6> malloc question: does the OS actuall allocate the memory requested when malloc is called? this program should run in constant space (slightly larger than an array of n long long int elements), but it keeps going up in size
01:52:13 <pumpkin> hmm? malloc allocates memory
01:52:17 <pumpkin> you free it when you're done
01:53:04 <Axman6> well, i'm only doing one malloc in the whole program, but the ram usage is increasing
01:53:14 <trofi^w> some OSes allocate only virtual address spaces for large chunks and load phys pages on demand (memory commit)
01:53:17 <pumpkin> hmm
01:53:29 <Axman6> trofi^w: yeah, i thought i'd heard that before
01:53:46 <trofi^w> are you using linux?
01:53:56 <trofi^w> it is configurable BTW
01:54:10 <Axman6> OS X
01:54:12 <trofi^w> man malloc /proc/sys/vm/overcommit_memory
01:54:18 <trofi^w> ah
01:54:30 <trofi^w> there should be other commit strategies
01:55:34 <wli> Okay, I've got transformation functions to eliminate NegOp and SubOp.
01:57:42 <wli> http://pastebin.com/m300a3c
01:59:27 <wli> I guess the remaining issues are getting it into "one big denominator" forms and verifying that the exponents are constant rational numbers.
01:59:57 <wli> After that, rationalizing denominators.
02:21:37 <wli> Maybe I should eliminate exponents sooner.
02:23:29 <wli> http://pastebin.com/m68e7ba05
02:23:41 <aleator> Is there any easy way to parse general haskell expressions for TH? I have a string and need an ExpQ.
02:26:05 <mxc> ?seen ndm
02:26:05 <lambdabot> I haven't seen ndm.
02:27:09 <pumpkin> does haskell-src-exts include all of haskell-src? or do I need them both
02:31:24 <Nicolasff> hello. Does someone know how to match a Just <somevariable> in a case .. of ? I'm having this problem: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1836
02:31:52 <Nicolasff> should I just add an if test after the matching Just line?
02:32:09 <wli> There's a problem with the exponent vs. division case, which is that (p(x)/q(x))^(n/d) with n, d in Z, n, d > 0, (n, d) = 1 is not necessariliy equivalent to p(x)^(n/d)/q(x)^(n/d)
02:34:27 * wli retains quotients on the interior of surds.
02:34:30 <jpcooper> Nicolasff, you may want to check your indentation
02:34:47 <Nicolasff> where?
02:34:48 <jpcooper> also, that case statement can be replaced by using the "maybe" function
02:35:04 <jpcooper> one the past, the case expression seems not to be indented properly
02:35:41 <Nicolasff> will that change anything?
02:35:58 <jpcooper> indentation is important in Haskell
02:38:48 <cizra> .. but unlike Python it can be replaced with {, }, ; and possibly something else.
02:38:59 <Nicolasff> i don't think that's the problem, but i may have found it by checking RWH
02:39:02 <Nicolasff> “We refer to a pattern that always succeeds as irrefutable. Plain variable names and the wild card _ are examples of irrefutable patterns.”
02:39:22 <Nicolasff> so Just x matches the constructor Just and puts the value in x
02:39:28 <jpcooper> it does
02:39:36 <Nicolasff> i can add a guard, such as this: Just m | x == m
02:39:53 <jpcooper> you can do that in a case expression
02:40:03 <jpcooper> your case expression should work if properly indented
02:40:08 <jpcooper> also, why are you doing that in a do block?
02:40:13 <jpcooper> you aren't doing anything that is monadic\
02:40:35 <jpcooper> apart from the final putStrLn. But you can still return that from a normal function
02:41:04 <Nicolasff> there, now working: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1836#a1837
02:41:09 <cizra> jpcooper: Aren't you confusing a newb with too much information?
02:41:24 <Nicolasff> oh that's fine i know what he means
02:41:32 <cizra> OK
02:41:43 <Nicolasff> as i said this is part of a larger program, i was just trying to isolate the problem
02:41:51 <jpcooper> Nicolasff, have a look at normal let and where expressions
02:42:31 <porges> dons: is there a way to note a package as double-plus-experimental? :P that package you uploaded on my behalf obviously has known bugs :)
02:42:31 <lambdabot> porges: You have 1 new message. '/msg lambdabot @messages' to read it.
02:42:54 <porges> thx don :P
02:43:41 <Nicolasff> jpcooper, how would you use a let or where here? i use these constructions all the time but i don't see how it applies here :/
02:45:05 <ImInYourMonad> i have done some webapps but i dont really know how the server itself works. basically it handles requests from browsers? so it needs to implement http. but how can one server program handle so many requests, every time a user requests soemthing thta cant spawn a new thread right, that would be insane for something just of a small siz
02:45:11 <ImInYourMonad> e
02:48:09 <ImInYourMonad> i dont egt how to just display a simple template
02:48:13 <ImInYourMonad> in happstack
02:48:59 <ImInYourMonad> i can do hello world with simpleHTTP
02:49:21 <Nicolasff> well ok anyway, thanks
02:50:23 <jpcooper> Nicolasff, you don't need a do block there
02:50:25 <cizra> Nicolasff: main :: IO (); main = let foo = "bar"; blah = "baz" in putStrLn foo + blah
02:50:43 <jpcooper> but a do block goes at the end of any function
02:50:54 <Nicolasff> yes i know
02:51:07 <Nicolasff> i extracted this part from a pure function actually
02:51:29 <cizra> main :: IO (); main = let foo = "bar"; blah = "baz" in putStrLn (foo ++ blah)
02:51:56 <Nicolasff> the problem was simply how to match (Just someVariable) in a case block, the solution being that you have to use a temp variable and a guard. or ifs
02:52:20 <quicksilver> ImInYourMonad: typical http servers manage pools of threads and use various methods to share the incoming requests among their thread pools.
02:52:30 <quicksilver> ImInYourMonad: in haskell you don't need to worry - one thread per request is fine
02:52:35 <quicksilver> ImInYourMonad: because haskell threads are cheap.
02:54:54 <ImInYourMonad> are they like erlang threads
02:54:54 <ImInYourMonad> or wait erlang only uses processes right.
02:54:54 <ImInYourMonad> but i mean they are not OS processes or threads but some sort of abstraction in the runtime?
02:55:20 <quicksilver> right.
02:55:31 <quicksilver> they're cheaply implemented soft threads.
02:55:43 <quicksilver> they're especially cheap when they're blocking on IO
02:55:48 <quicksilver> which is a common case in a server.
02:56:40 <Nicolasff> speaking about do blocks, is it considered good style to use a do block for a pure function, instead of cascading lets and wheres? in case of more than 4 or 5 transformations, it does help with readability.
02:57:06 <ImInYourMonad> ok
02:57:06 <ImInYourMonad> where is mzero?
02:57:07 <ImInYourMonad> how can i ask lambdabot where stuff is?
02:57:19 <pumpkin> @index mzero
02:57:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
02:57:32 <ivanm> @hoogle mzero
02:57:32 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
02:57:44 <ivanm> @instances MonadPlus
02:57:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
02:57:53 <quicksilver> Nicolasff: you almost never need to cascade lets and where
02:57:59 <quicksilver> Nicolasff: you just put it all in one let (or one where)
02:58:23 <ivanm> the only time I've had cascaded where is when I have a sub-function/variable for a sub-function
02:58:28 <quicksilver> Nicolasff: I would say it was terrible stle to use a do block unless you're using a monad.
02:58:37 <ivanm> but that's rather rare, normally I split it off to a top-level function of its own
02:58:38 <Nicolasff> well, parsec uses it.
02:58:38 <quicksilver> (of course, you can certainly use a monad and still be a pure function)
02:58:49 <quicksilver> Nicolasff: example?
02:59:08 <ivanm> quicksilver: how about using a do-block for "pure" monads such as Maybe or []?
02:59:18 <quicksilver> of course, that's fine.
02:59:30 <quicksilver> do block is a sugar for the monadic combinators.
02:59:42 <quicksilver> it's fine to use a do block whenever you are using >> and >>=
02:59:49 <quicksilver> which looks nicer is a question of taste + style.
02:59:54 <PHO_> I sometimes use Arrows extension for pure function combining :)
03:00:01 <pumpkin> :o
03:00:07 <quicksilver> but if you're not using >> and >>= I certainly wouldn't use a do block.
03:00:19 <Nicolasff> quicksilver, http://book.realworldhaskell.org/read/using-parsec.html#csv1.hs:all
03:00:20 <pumpkin> > (+1) +++ (+5) $ Left 2
03:00:22 <lambdabot>   Left 3
03:00:47 <quicksilver> Nicolasff: OK. That's not using do notation as an alternative to cascading lets and wheres
03:00:55 <Nicolasff> ok thanks
03:00:58 <quicksilver> Nicolasff: that's using do notation because Parsec is a monad!
03:01:02 <quicksilver> which is a good reason :)
03:01:10 <Nicolasff> :)
03:01:55 <quicksilver> although in fact I would probably write csvFile, for example, as "csvFile = many line <* eof"
03:02:10 <HugoDaniel> hmm, i left ghci doing some calculations yesterday, and today i found it frozen
03:02:16 <quicksilver> but that's a question of taste (do you like those combinators?) and knowledge (will your readers understand those combinators?)
03:02:22 <ivanm> HugoDaniel: heh
03:02:32 <ivanm> any particular reason for not compiling?
03:04:01 <HugoDaniel> ivanm: just testing :)
03:04:52 <PHO_> > (proc a -> (+1) -< a) 2
03:04:53 <lambdabot>   <no location info>: parse error on input `->'
03:07:22 <pumpkin> oh, that syntax
03:07:31 <pumpkin> isn't that just a preprocessor? or is it supported directly by ghc?
03:07:32 <ImInYourMonad> someone have a good example of how to write a very simple app in happstack. with liek one mainpage which links to another page and back?
03:07:45 <pumpkin> ImInYourMonad: there's a happstack-tutorial isn't there?
03:07:53 <PHO_> pumpkin: directly by ghc but you need -XArrows
03:07:57 <pumpkin> ah ok
03:08:20 <pumpkin> that's just desugared into regular Control.Arrow stuff though, isn't it?
03:08:28 <PHO_> pumkin: right
03:08:33 <PHO_> pumpkin, sorry
03:08:44 <pumpkin> I see :)
03:08:53 <pumpkin> np, people spell it as pumkin all the time :P
03:08:59 <PHO_> haha
03:09:15 <quicksilver> pumpkin: do notation is "just a preprocessor" which gets desugared into regular Prelude stuff, too.
03:09:21 <pumpkin> yeah
03:09:26 <quicksilver> actually it isn't, but it could be.
03:09:31 <pumpkin> I remember seeing .as files though
03:09:34 <pumpkin> or something
03:09:40 <pumpkin> that had a separate preprocessor, for that syntax
03:09:48 <pumpkin> but that may be old stuff
03:09:50 <quicksilver> that's probably before -XArrows was implemented
03:09:52 <quicksilver> I would guess
03:10:01 <pumpkin> makes sense
03:13:25 <PeakerWork> @type (+++)
03:13:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
03:18:46 <wli> Okay, I can get it into one big denominator, though product-of-sums needs work.
03:19:06 <wli> ergh, sum-of-products
03:22:35 <wli> I didn't expect divElim to go through so nicely.
03:26:46 <pozic> Is there a website where I can find which papers cite a certain other paper?
03:26:59 <Japsu> pozic, scholar.google.com
03:27:00 <pumpkin> google scholar
03:28:38 <pozic> Japsu: I do not see a field for exactly what I asked in the "Advanced search options".
03:29:25 <pozic> I got it.
03:29:56 <wli> I'm envisioning an addElim function that distributes multiplication over addition and sprays out summands.
03:30:00 <pumpkin> http://citeseerx.ist.psu.edu/advanced_search;jsessionid=B5A5D64209D2295D81CC7904626251BD for CS, too
03:30:12 <Japsu> pozic, was it cite: or something, I can't find it in the help right now
03:31:23 <pozic> Japsu: yes, by "I got it", I meant to say that I ahd find the feature.\
03:32:06 <Japsu> pozic, yeah, and what I was asking was that where did you find it in google scholar, as now _I_ can't find it :P
03:33:58 <pozic> Japsu: oh, just search for a paper and then you see it immediately.
03:34:07 <Japsu> oh, right.
03:41:28 <viraptor> is there any nice math (vector/matrix) library for haskell? I'm interested in fast normal, vector normalisation and in/out of triangle tests mostly
03:43:43 <Baughn> viraptor: There's hmatrix. It does quite a lot of things.. don't know if that includes normalization.
03:44:46 <pumpkin> there's also a blas package on hackage
03:45:02 <pumpkin> not sure if that does anything you need, but it might help :)
03:45:35 <wli> Product of sums accomplished.
03:45:46 <viraptor> cool, thanks - I'll have a look
03:45:54 <wli> Argh, sum of products accomplished.
03:48:40 <wli> I guess the next step is to collect things into monomials and barf if it's multivariate.
03:50:32 <wli> Have I mentioned that extensible variants would really help here? Elimination of cases is not representible in a convenient fashion; I have to copy basically the whole data structure definition.
03:51:53 <wli> Maybe the usual suspects can comment on ways to refactor it more nicely.
03:54:57 <wli> http://pastebin.com/m355d7b10
03:57:44 <arjanb> i would just do all the rewriting on a single data type and in end convert it to another data type
03:58:50 <wli> But then the type system doesn't enforce the invariants and dumb bunnies like me get confused.
04:03:30 <HugoDaniel> i find myself using explicit recursion a lot :/
04:07:25 <osfameron> HugoDaniel: nothing wrong with that
04:07:34 <osfameron> HugoDaniel: sometimes you can abstract once you've done that, which is good too
04:08:06 <osfameron> I sometimes find explicit recursion easier, sometimes map/fold/etc. are easier straight off
04:09:15 <wli> Too many constructors with too many operands put you instantly back into explicit recursion most of the time.
04:09:36 <Botje_> Expr'''''? O_o
04:09:38 <wli> I think there's some extension to define things by structural induction on types, though.
04:09:57 <wli> Botje: I should probably have switched to numbers already.
04:10:18 <Botje_> yes please :)
04:10:27 <daf> HugoDaniel: I think folding gets easier with practice
04:10:50 <daf> HugoDaniel: I often write explcit recursion first, and see how to make it into a fold afterwards
04:11:03 <daf> of course, not every recursion is a fold
04:16:11 <wli> When the smoke clears I should get a constant times a monomial possibly times some surd.
04:18:07 <HugoDaniel> yes, i should read about folding and all that
04:31:39 <Axman6> http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer/424936#424936 wow...
04:31:56 <Axman6> efficiency sucks in C++ :P
04:32:06 <Axman6> (note: not the efficiency of C++)
04:32:58 <Saizan> which examples would you use to explain recursion? especially how you don't need to use mutable variables but you can just pass updated values to the recursive call
04:33:39 <Axman6> factorial is the obvious one
04:34:03 <porges> has anyone got code that, given a Parsec parser, will generate a random string that matches it?
04:34:10 <porges> it would be ... totally sweet
04:34:44 <Axman6> fac n = go n 1 where go 1 m = n; go n m = go (n-1) (m*n)
04:35:00 <Axman6> porges: anti parsing?
04:35:07 <porges> :P
04:36:18 <Botje_> Saizan: labeling the levels of a tree?
04:37:48 <Saizan> those are both good, thanks :)  but maybe one is too simple and the other a bit complex..
04:38:45 <pejo> Axman, useful for quickcheck.
04:39:06 <Axman6> well sure
04:39:21 <Axman6> but that's slightly different to what was asked for i thik
04:39:24 <Axman6> n*
04:40:09 <kiris> porges: maybe you could get the parsec parser, but don't import Parsec, instead, redine the parser monad such that you can make random productions somehow
04:40:44 <porges> pejo: yes, quickcheck was the original use case I had in mind
04:40:54 <porges> but it would have other applications
04:41:42 <quicksilver> porges: it can't be done, I don't think
04:41:48 <quicksilver> parsec parsers are not introspectable.
04:41:59 <quicksilver> you could easily built a parsec-a-like library which had this property, though
04:42:05 <quicksilver> (automatic witness generation)
04:42:11 <kiris> can't you do what I said above?
04:42:12 <sior|oifig> dcoutts, ping?
04:42:30 <quicksilver> kiris: sure. That is building a parsec-a-like library ;0
04:42:52 <porges> quicksilver: surely they're internally introspectable?
04:42:58 <quicksilver> nope.
04:42:58 <kiris> quicksilver: oh. I wasn't sure if you meant having to rewrite your parsers or keep your parsec parsers as-is
04:43:03 <quicksilver> functions aren't introspectable.
04:43:09 <quicksilver> kiris: technically, you are rewriting it.
04:43:17 <quicksilver> kiris: you're redefining all the names involved.
04:43:20 <kiris> quicksilver: you're rewriting the library, but not all your parsers
04:43:23 <quicksilver> and changing the type.
04:43:56 <porges> quicksilver: I thought it built them up as data structures, as it does some sanity tests on them like seeing if you call "many" on something that matches empty inputs etc
04:44:28 <quicksilver> I don't think so.
04:44:41 <quicksilver> If you're right, and I'm wrong, then you absolutely, yes.
04:46:03 <wli> I really don't like the top-down/LL parsing affairs. I'd love for there to be a lib that did LR/etc. grammar, table, etc. construction and worked from there.
04:46:18 <quicksilver> I wrong something a bit like parsec in lua
04:46:23 <quicksilver> which did table construction
04:46:27 <quicksilver> and left-recursion removal
04:46:29 <quicksilver> was quite fun.
04:47:35 <quicksilver> porges: newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))
04:47:45 <porges> :(
04:47:49 <quicksilver> porges: so, it's not introspectable because it's a (->) at the top level
04:47:51 <quicksilver> as I suspected.
04:48:08 <quicksilver> well it's for efficiency I imagine.
04:48:30 <porges> wli: a packrat library would be nice, but afaict you can't do it in pure haskell because the datatype needs to be generated. probably doable in TH
04:48:30 <ketil> What's a simple way to remove consequtive duplicates from a bytestring?
04:48:30 <lambdabot> ketil: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:48:53 <quicksilver> the 'build up as data structures approach' is cool, but I guess it's slower.
04:49:07 <ketil> (and why does \bot keep delirvering old - really old - messages to me?)
04:49:25 <porges> lambdabot is stuck in a time loop?
04:49:50 <wli> porges: I don't know what packrat is.
04:50:08 <dolio> Does anyone have code that, given a Turing machine, generates a random input upon which it halts? :)
04:51:07 <porges> dolio: I was thinking of just at each choice point it will choose a random one
04:51:16 <porges> dolio: and bork at "satisfy"
04:51:18 <porges> and its ilk
04:51:25 <wli> Nondeterministic LBA?
04:52:00 <quicksilver> yes, in quickcheck terminology, for each primitive way of building up a Parser a, you'd also build up a Gen a
04:52:01 <kiris> ketil: I knew I wasn't the only one to spell "consecutive" with a 'q', except I wrote "consequitive" :-P
04:52:08 <quicksilver> except for those ones where you can't do it.
04:52:13 <quicksilver> and then you'd just cry, but that's OK
04:52:14 <porges> wli: http://en.wikipedia.org/wiki/Packrat_parser#Implementing_parsers_from_parsing_expression_grammars
04:52:16 <quicksilver> it would still be useful.
04:52:21 <porges> :D
04:53:36 <Axman6> dolio: i wrote one of those for funsies a few months ago
04:53:39 <Axman6> >_>
04:53:40 <ketil> kiris, whoops.  Anyway: here's one answer to my question.
04:53:59 <kiris> concat . map head . group?
04:54:01 <ketil> > unfoldr (\x -> case x of [] -> Nothing; (x:xs) -> Just (x,dropWhile (==x) xs)) "foobarrrrxxx"
04:54:02 <lambdabot>   "fobarx"
04:54:09 <dolio> porges: It's actually trivially undoable, because there's a parser that always fails. :)
04:54:11 <kiris> > concat . map head . group $ "hello"
04:54:11 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
04:54:22 <kiris> > map head . group $ "hello"
04:54:23 <lambdabot>   "helo"
04:54:23 <wli> porges: I'm very snobbish about lack of support for left recursion.
04:54:25 <kiris> oh
04:54:27 <dolio> But if you rule out stuff like that, I still don't know if you could do it.
04:54:32 <porges> wli: it's implementable
04:54:35 <ketil> kiris, I worry that will be inefficient?  Esp. on bytestrings.
04:54:37 <kiris> ketil: that is a nice solution
04:54:43 <ketil> kiris, but elegant, of course.
04:54:50 <kiris> ketil: yeah, I expect inefficient. the unfoldr one is nice
04:54:53 <porges> wli: the rats! java one does it , e.g.
04:55:03 <kiris> :t bool
04:55:04 <lambdabot> Not in scope: `bool'
04:55:14 <wli> porges: So is LR/LALR on the fly based on grammar description data structures.
04:55:23 <quicksilver> yes, my lua parser generator eliminated left recursion
04:55:48 <kiris> @let bool false true p v = if p v then true v else false v
04:55:49 <lambdabot>  Defined.
04:55:53 <porges> wli: I guess so, the main thing is it works *really* nicely with laziness
04:56:00 <wli> porges: GLR on the fly, even.
04:56:20 <porges> wli: the paper it is developed in basically walks through doing it in haskell
04:57:25 <wli> porges: Well, the less expressive the grammar, the easier it is to do things with it, which is why PEG's don't interest me.
04:57:46 <porges> fine. be like that
04:57:49 <porges> ;)
04:58:07 <wli> Well, the easier it is for the implementor; it's harder for users, of course.
04:59:41 <porges> in other news, email validation works completely once I rewrote the grammar to be without need for backtracking
05:00:10 <porges> i feel... i have done something pointless
05:01:36 <kiris> > unfoldr (bool $ \(x:xs) -> Just (x,dropWhile (==x) xs)) (const Nothing) null $ "foobarrrrxxx"
05:01:36 <lambdabot>   Couldn't match expected type `Maybe (a, [a1] -> Maybe (a1, [a1]))'
05:01:50 <kiris> > unfoldr (bool (\(x:xs) -> Just (x,dropWhile (==x) xs)) (const Nothing) null) "foobarrrrxxx"
05:01:51 <lambdabot>   "fobarx"
05:01:56 <kiris> can this be written entirely pointlessly?
05:02:28 <Axman6> @pl \(x:xs) -> Just (x,dropWhile (==x) xs)
05:02:28 <lambdabot> ap ((Just .) . liftM2 (.) (,) (dropWhile . (==)) . head) tail
05:02:39 <kiris> EewewewewewEWEWEW
05:02:45 <Axman6> yup
05:02:49 <Axman6> @pl ftl
05:02:49 <lambdabot> ftl
05:03:08 <kiris> :i (&&&)
05:03:11 <kiris> @i (&&&)
05:03:11 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
05:03:20 <kiris> what's its fixity?
05:03:29 <porges> @let uncons (x:xs) = (x,xs)
05:03:29 <lambdabot>  Defined.
05:03:45 <kiris> uncons = head &&& tail
05:04:01 <porges> good point :)
05:04:04 <kiris> :p
05:04:46 <porges> Just . (id *** dropWhile (==???)) . (head &&& tail)
05:04:55 <kiris> heh
05:05:28 <wli> I remember having a lot of trouble with implementing on-the-fly table-driven parsing a few years ago. I doubt I could touch the topic anymore given how bad the deterioration is.
05:06:48 <wli> @type let unCons [] = Nothing ; unCons (x : xs) = Just (x, xs) in unCons
05:06:49 <lambdabot> forall t. [t] -> Maybe (t, [t])
05:07:22 <beelsebob> Just . ((id . head) &&& (dropWhile (==???) . tail)) is rather nicer IMHO
05:07:28 <Axman6> @pl , typ "show"
05:07:29 <lambdabot> (line 1, column 1):
05:07:29 <lambdabot> unexpected ","
05:07:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:07:32 <Axman6> lame
05:07:38 * wli much prefers accuracy in data type representations and exhaustive pattern matches.
05:08:39 <kerlo> , typ "show"
05:08:44 <lunabot>  "forall a. (GHC.Show.Show a) => a -> GHC.Base.String"
05:08:49 <kerlo> Cool, it make roconnor quit.
05:08:52 <porges> @pl (\(x,xs) -> dropWhile (==x) xs)
05:08:52 <lambdabot> uncurry (dropWhile . (==))
05:08:55 <ivanm> why does lunabot quote its response?
05:08:59 <kerlo> (Made, even.)
05:09:09 <ivanm> oh, wait, because show was in quotes?
05:09:11 <ivanm> , type show
05:09:12 <lunabot>  luna: parse error on input `type'
05:09:14 <opqdonut> because that was , typ
05:09:15 <porges> Just . (id *** uncurry (dropWhile . (==))) (head &&& (head &&& tail))
05:09:16 <opqdonut> and not :t
05:09:22 <porges> @let f = Just . (id *** uncurry (dropWhile . (==))) (head &&& (head &&& tail))
05:09:23 <lambdabot>  Couldn't match expected type `a -> b'
05:09:25 <ivanm> , typ show
05:09:26 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
05:09:34 <kerlo> , typ "typ"
05:09:37 <lunabot>  "GHC.Base.String -> GHC.Base.String"
05:09:38 <Axman6> porges: don't @let f please
05:09:56 <ivanm> opqdonut: ummmm..... so it can find the typ of things, but not the type? :s
05:09:58 <ivanm> @forget f
05:09:58 <lambdabot> Incorrect arguments to quote
05:10:01 <ivanm> grrr....
05:10:04 <porges> @let temporaryF = Just . (id *** uncurry (dropWhile . (==))) . (head &&& (head &&& tail))
05:10:05 <lambdabot>  Defined.
05:10:13 <Axman6> > foldl f z [a,b,c]
05:10:15 <lambdabot>   f (f (f z a) b) c
05:10:21 <Axman6> s'all good
05:10:32 <ivanm> porges: why not just have the let in your > statement?
05:10:34 <porges> > unfoldr (bool $ temporaryF) (const Nothing) null
05:10:35 <lambdabot>   Couldn't match expected type `Maybe (a, [a1] -> Maybe (a1, [a1]))'
05:10:47 <wli> This is part of why I'm still screaming about the lack of an arbitrary-precision unsigned integer type (i.e. Natural).
05:10:56 <porges> I'm handing it to kiris
05:11:02 <ivanm> ahhh
05:11:03 <kiris> :t unfoldr (bool temporaryF (const Nothing) null)
05:11:04 <lambdabot> forall a. (Eq a) => [a] -> [a]
05:11:11 <kiris> > unfoldr (bool temporaryF (const Nothing) null) "wassup"
05:11:12 <lambdabot>   "wasup"
05:11:19 <ivanm> wli: ummm.... why is unsigned so important?
05:11:19 <Axman6> anyone got any harpy experience?
05:11:32 <porges> it's ... UNIQ!
05:11:36 <kerlo> I've come to like "newtype Natural = Natural Integer".
05:11:38 <kiris> :t uniq
05:11:39 <lambdabot> Not in scope: `uniq'
05:11:40 <wli> ivanm: For when negative numbers are inadmissible.
05:11:48 * ivanm wonders if its possible to do so by newtype'ing Integer, with a minbound of 0 and a maxbound of undefined
05:11:58 <kiris> > unfoldr (bool temporaryF (const Nothing) null) "wassups"
05:11:59 <lambdabot>   "wasups"
05:12:02 <Axman6> wli: yah i've felt the same a few times
05:12:08 <ivanm> use GeneralisedNewtypeDeriving, etc. on it...
05:12:23 <Badger> kiris: o_O
05:12:30 <kiris> Badger: what?
05:12:47 <ivanm> porges: so your temporaryF acts as the identity to unfoldr? :s
05:13:02 <Badger> > unfoldr (bool temporaryF (const Nothing) null) "utter madness"
05:13:04 <lambdabot>   "uter madnes"
05:13:04 <wli> A lot of the data structure h0rkage etc. is precisely so that invalid states are unrepresentable in the type. The "use somethning with invalid states all over the place and pray" bullcrap just infuriates me.
05:13:07 <Badger> oh
05:13:19 <Badger> hah.
05:13:26 <ivanm> ahhh, gets rid of dups
05:13:26 <porges> I was merely implementing Kiris' function :)
05:14:08 <porges> and I should have (second ..) instead of (id *** ...)
05:14:51 <kiris> > unfoldr (bool (Just . (second $ uncurry (dropWhile . (==))) . (head &&& (head &&& tail))) (const Nothing) null) "do smurfs lay eggs?"
05:14:53 <lambdabot>   "do smurfs lay egs?"
05:15:01 <kiris> it's pretty ugly compared to the case expression
05:15:19 <kiris> PATTERN MATCHING IS LUDICROUSLY USEFUL
05:15:19 <porges> using proper bimaps is nicer :)
05:15:46 <wli> Sadly I'm too much of a moron anymore to be able to crank out the [Word32] -based Naturals like I used to.
05:15:52 <ivanm> kiris: so is letting go of the shift key whilst typing :p
05:16:03 <kiris> ivanm: cruise control for cool
05:28:32 <bastl1> can someone help me understanding how to use Statemonad? Ive already read alot about monads, dont dont get it to work ...
05:29:01 <bastl1> i want to write a function that attaches a unique id to every node of a tree.
05:29:40 <bastl1> in the type ST s v, s are the states, v are the values, right. what would that be in my example?
05:29:42 <blackh> Try this...
05:29:46 <blackh> > flip execState 5 $ modify (+1)
05:29:48 <lambdabot>   6
05:31:54 <Axman6> bastl1: State and ST are two quite different things
05:32:05 <Axman6> (ST is much much cooler though)
05:32:39 <bastl1> well, id like to understand and get my problem done at the same time ...
05:33:11 <bastl1> waht is ST for ?
05:34:17 <bastl1> and still, what would my type for states be? A Tree (like the node i reside in) ? Int (like the last number i attached to a node)?
05:34:30 <ImInYourMonad> anyone know where renderTemplateGroup is in happstack?
05:34:54 <kiris> ImInYourHappStack
05:34:56 <Axman6> ST lets you write basically imperative code, with mutable variables etc, in a safe and pure way
05:35:19 <bastl1> k, then that was the wrong route.
05:35:35 <Axman6> probably
05:35:45 <kiris> Axman6: "pure"
05:36:02 <Axman6> kiris: well, from outside of runST, it is pure
05:36:09 <Axman6> it has to be
05:36:59 <kiris> could you replace the underneath implementation of ST with StateT and an array?
05:37:12 <kiris> er, State
05:37:12 <blackh> bastl1: State Int <something> is your state type... <something> being whatever the return type is for whichever function you happen to be implementing. Your Node type would be likely here.
05:38:03 <bastl1> blackh thanks.
05:38:08 <Axman6> kiris: probably. but the thing is, (a lot of) the IO monad is implemented using ST. it's a quite low level thing really
05:39:30 <blackh> > flip evalState 0 $ forM ["cheese","sausage","cornflakes"] $ \food -> do {idx <- get; modify (+1) ; return (food, idx)}
05:39:31 <lambdabot>   [("cheese",0),("sausage",1),("cornflakes",2)]
05:40:22 <blackh> bastl1: The type of this would be State Int [(String,Int)]
05:40:27 <quicksilver> Axman6: actually, the ST monad is implemented using IO :)
05:40:38 <Axman6> eh?
05:41:14 <Axman6> i've seen lots of code using somethingIO = (somethingST :: ST RealWorld a)
05:41:19 <Axman6> or something there abouts
05:41:24 <EvilTerran> ?src ST
05:41:24 <lambdabot> newtype ST s a = ST (STRep s a)
05:41:28 <EvilTerran> ?src STRep
05:41:28 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
05:41:34 <Axman6> @src IO
05:41:35 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:41:35 <ImInYourMonad> anyone know where renderTemplateGroup is in happstack?
05:41:44 <EvilTerran> ah, they're both State#
05:41:51 <EvilTerran> ?src State#
05:41:51 <lambdabot> Source not found. My mind is going. I can feel it.
05:41:59 <Axman6> well yeah.
05:42:04 * Gracenotes pets lambdabot
05:42:04 <beelsebob> > zip ["cheese", "sausage", "cornflakes"] $ unfoldr (Just . (id &&& id) . (+1)) (-1)
05:42:06 <lambdabot>   [("cheese",0),("sausage",1),("cornflakes",2)]
05:42:07 <wli> I've got it down to quotients of integer linear combinations of monomials times surds.
05:42:41 <wli> This is a much bigger struggle than I anticipated.
05:42:58 <Gracenotes> > unfoldr (Just . (id &&& id) . (+1)) (-1) -- enumFrom...? ;)
05:43:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:43:15 <beelsebob> Gracenotes: mebeh...
05:43:21 <byorgey> a rather complicated way to compute [1..] ... =)
05:43:22 <beelsebob> just looks a bit more stateful
05:43:26 <Gracenotes> :3
05:43:34 <beelsebob> halfway between the ST vesion and [1..]
05:43:40 <beelsebob> kinda trying to point that out
05:43:53 <Gracenotes> oh, I see, *scrolls up*
05:43:54 <wli> Shall I break out my monadic primes?
05:44:51 <wli> > let primeStep n = let cmpStep ((k, ps), m) | n /= k = tell [n] >> modify (Map.insertWith (++) (n*n) [n]) | otherwise = put . Map.unionWith (++) m . Map.fromListWith (++) $ [(k + p, [p]) | p <- ps] in gets Map.minViewWithKey >>= maybe (tell [n] >> put (Map.singleton (n*n) [n])) cmpStep in flip evalState Map.empty . execWriterT $ mapM_ primeStep [2..]
05:44:52 <Gracenotes> you could write a naive primes-generator with Writer and some of its introspection methods
05:44:53 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:45:02 <Gracenotes> oic :3
05:45:23 <beelsebob> wli: that looks aplicative to me
05:45:30 <Gracenotes> well, that does use State
05:45:35 <beelsebob> the only use of >>= is really a fmap
05:45:39 <beelsebob> and mapM is really mapA
05:45:57 <beelsebob> oh, wait, tell and put
05:46:00 <beelsebob> o.O
05:46:08 <beelsebob> not sure :/
05:46:27 <EvilTerran> tell and put don't break the applicative-ness of it
05:46:33 <wli> beelsebob: Yeah, I don't see an obvious way to make it use Control.Applicative
05:46:57 <beelsebob> EvilTerran: no, but they make the applicative one less pleasant
05:47:01 <beelsebob> possibly
05:49:06 <blackh> dcoutts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hexpat
05:49:20 <blackh> dcoutts: Not sure if this is the first package that depends on 'text' but hopefully it's one of the first!
05:49:39 <wli> I'm down to a pair of lists of these as summands in the numerator and denominator: data Expr6  =  Expr6 Integer (Map Char Integer) [([Expr6], [Expr6], Integer, Integer)]
05:49:41 <HugoDaniel> when i saw this: http://carfree.free.fr/images/we_believe_anything.gif  i thought "hmm, haskell is lazy"
05:49:59 <wli> (Here, Char represents indeterminate names.)
05:53:56 <wli> I guess the next thing to do is pull out the indeterminate name.
05:54:19 <wli> And throw an error in the case multiple indeterminates are used.
06:28:13 <ImInYourMonad> so these fakkin mathematicians pretty much killed cryptography and codebreakign with RSA right? unless P is in NP or whatever there  isn't a way to break these things with anything but superduperextreme luck?
06:28:41 <opqdonut> ImInYourMonad: nah, it's not that straightforward
06:28:41 <Workybob> ImInYourMonad: who knows
06:28:49 <opqdonut> there are lots of robust attacks againsta RSA
06:28:58 <Workybob> remember – the germans thought they'd killed cryptography with enigma
06:29:00 <Spark> P=NP has nothing to do with it really
06:29:05 <opqdonut> that too
06:29:06 <Spark> that's talking about scalability
06:29:36 <Workybob> Spark: indeed – which is what cryptography is about, whether or not you can crack it in polynomial time
06:29:39 <Ferdirand> cryptography is way more than that, there is symmetric crypto, prngs, secure hash fuctions...
06:29:42 <ImInYourMonad> prime factorization hasnt anything to do with P Np?
06:29:53 <ImInYourMonad> what is the square?
06:31:07 <koeien> ImInYourMonad: prime factorisation is in NP, but is not NPC
06:31:28 <koeien> it is not known whether it's in P
06:31:42 <opqdonut> and prime factorisation is in BQP
06:31:45 <opqdonut> which is interesting
06:32:08 <koeien> yes, there is a fast quantum algorithm for it
06:33:18 <koeien> also, discrete log can be solved fast by a quantum computer
06:35:16 <koeien> ImInYourMonad: so to answer your question, even if you can solve the factorisation problem in polynomial time using a regular Turing machine, you have not proved that P = NP
06:35:46 <ImInYourMonad> fakk turing then
06:35:59 <Cale> huh?
06:36:24 * Cale wonders how long ImInYourMonad has been awake...
06:37:33 <ImInYourMonad> just kiddin
06:39:27 <lukasser> is there a function that rounds for example 5.43242 to 5.43?
06:40:22 <tromp_> (/100) . round . (*100) ?
06:41:10 <quicksilver> missing a fromIntegral, I suspect.
06:41:33 <LeoD> :t round
06:41:36 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
06:42:27 <trofi^w> :t printf
06:42:28 <lambdabot> forall r. (PrintfType r) => String -> r
06:42:53 <Cale> ImInYourMonad: Basically, everyone assumes for the most part that integer factorisation is hard. We don't have a polynomial time classical algorithm, and quantum computers of the sizes needed for cryptography problems still seem quite a ways off. But that doesn't mean that it necessarily is that difficult. Some big new results in number theory could certainly change things.
06:42:59 <trofi^w> printf "%2.3f" (0.1111111111111111 :: Double)
06:43:05 <trofi^w> > printf "%2.3f" (0.1111111111111111 :: Double)
06:43:07 <lambdabot>   Add a type signature
06:43:19 <trofi^w> > printf "%2.3f" (0.1111111111111111 :: Double) :: String
06:43:21 <lambdabot>   "0.111"
06:43:34 <lukasser> or, more simply put, rounds a Double number with n decimal digits to a Double number with 2 decimal digits
06:44:06 <quicksilver> lukasser: tromp_ gave you the answer.
06:44:32 <LeoD> > (/100) . round . (*100) $ (0.1111111 :: Double)
06:44:34 <lambdabot>   Add a type signature
06:44:47 <lukasser> whops, didn't see that, thanks
06:44:50 <tromp_> > (/100) . fromIntegral . round . (*100) $ 45.454
06:44:51 <lambdabot>   45.45
06:44:54 <Cale> With regards to P = NP, my hope is that P = NP, but that the best general purpose polynomial time algorithm for solving NP problems has a combinatorially large exponent. ;)
06:45:21 <Cale> (Just because it would be funny.)
06:45:27 <tromp_> my hope is that P != NP
06:45:33 <koeien> Cale: my hope also is that P = NP. solving problems is good
06:45:40 <koeien> even though we should invent other cryptography
06:45:54 <Cale> Oh yeah, it's polynomial time, but the best you can do is O(n^G) where G is Graham's number.
06:46:13 <idnar> I don't care one way or another, I just want it settled so that I don't have to hear people going on about P = NP ;)
06:46:27 <quicksilver> my hope is that P=NP precisely when there is an R in the month.
06:46:27 <idnar> Cale: hahaha
06:46:32 <koeien> idnar: then they'll start about the Riemann hypothesis
06:47:11 <koeien> idnar: mathematicians never stop ;)
06:47:27 <idnar> koeien: that's fine, I'll die eventually :P
06:47:47 <Cale> and *maybe* after that, the Collatz problem, but perhaps we need another 1000 years for that one
06:48:34 <koeien> Cale: hailstone numbers?
06:48:37 <Cale> yes
06:48:52 <Cale> Also known as the 3n+1 problem.
06:48:57 <ImInYourMonad> im gonna take the claymath problems one per week for the coming 6 weeks. 1*6millions =im the rich sheik
06:49:13 <ImInYourMonad> will you be my eigenvector?
06:50:02 <koeien> Cale: my hope is that something in th eorder ~10^1000 doesn't terminate and everybody was fooled
06:50:30 <Cale> hehe
06:51:25 <Cale> Then the problem would be to figure out a convincing explanation for why there are no small counterexamples, I suppose.
06:52:46 <Cale> But generally, iterated discrete functions of that sort are troublesome. We have very few tools at present which actually usefully apply to them.
06:53:15 <koeien> yes, in some sense things over the real numbers are easier
06:53:46 <Cale> Yeah, at least for the real numbers you can restrict your view to continuous or differentiable functions, say.
06:57:22 <skorpan> what is the dolphin-like animal with the "sword nose" called?
06:57:46 <nlogax> narwhal?
06:57:48 <skorpan> thanks
06:58:01 <ImInYourMonad> gah how do I dump intendation?
06:58:24 <nlogax> skorpan: first thing i could answer in #haskell
06:58:29 <nlogax> :(
06:58:41 <Nafai> nlogax: Gotta start somewhere! :)
06:58:55 <Cale> ImInYourMonad: Which editor?
06:58:58 <skorpan> nlogax: quite helpful though
06:59:03 <nlogax> :)
06:59:05 <skorpan> i was sitting around googling for "dolphin with sword nose"
06:59:12 <ImInYourMonad> emacs
06:59:31 <ImInYourMonad> but i mean haskell intendation, i can never get how the intendation works
06:59:35 <ImInYourMonad> anyway
06:59:46 <ImInYourMonad> and it doesnt work liek iw atn anyway
07:01:32 <Cale> The important things to remember: 1) Don't use hard tabs. 2) If something is part of something else, it should be indented more. 3) If two things are at the same level, they should be indented to the same column.
07:02:10 <Workybob> Cale: uh?
07:02:13 <Workybob> don't use hard tabs?
07:02:18 <Workybob> don't you mean don't use soft tabs?
07:02:35 <Cale> Er, I mean, don't use actual tab characters.
07:02:35 <Cale> Use spaces.
07:02:48 <Workybob> right :)
07:03:28 <byorgey> "Haskell: keep tabs on your tabs."
07:04:32 <idnar> Workybob: aren't soft tabs spaces?
07:04:33 <Cale> ImInYourMonad: For emacs, I believe you set the indent-tabs-mode to nil.
07:05:36 <Cale> Hmm, maybe using haskell-mode alone will fix that setting anyway.
07:05:45 <leimy> I think it does
07:05:49 <leimy> Or just use Yi :-)
07:08:58 <Workybob> idnar: no
07:09:08 <Workybob> soft tabs are tabs that are encoded in a "soft" way
07:09:14 <Workybob> not hard coded in as a bunch of spaces
07:09:25 <Workybob> soft tabs still have the capacity to adjust themselves
07:09:27 <Workybob> hard tabs dont
07:09:36 <Workybob> same as soft wrap/hard wrap
07:09:42 <idnar> hmm, that's not what it means in vim
07:09:51 <Workybob> o.O
07:10:13 <byorgey> that's not what it means in Albanian either.
07:12:14 <athos> softtabs in vim = tab is replaced by <tabwith> spaces
07:12:15 <athos> IIRC
07:13:05 <maxote> > sum (reverse [1..1000000])
07:13:07 <lambdabot>   * Exception: stack overflow
07:13:25 <maxote> > sum (reverse [1..400000])
07:13:27 <lambdabot>   * Exception: stack overflow
07:13:36 <maxote> > sum (reverse [1..100000])
07:13:38 <lambdabot>   5000050000
07:13:55 <Cale> > foldl' (+) 0 (reverse [1..1000000])
07:13:57 <lambdabot>   500000500000
07:14:14 <athos> > let sum = foldl' (+) 0 in sum (reverse [1..1000000])
07:14:15 <lambdabot>   500000500000
07:14:18 <athos> oh
07:14:22 <athos> Cale was faster
07:21:36 <Cale> > let square n = round (sqrt (fromIntegral n))^2 == n in filter (\n -> square (5*n^2 + 4) || square (5*n^2 - 4)) [0..]
07:21:51 <lambdabot>   thread killed
07:22:04 <ImInYourMonad> is there  a methodlogy to math at all as far as coming up with theorems? or is it just seeing? each person thinks a littler further? also, if smart aliens came here, do you think they could show soem of our theorems wrong? i mean do you think math is universally applicable always or something we made up. and our proofs are verified by other humans who could also have made mistakes. so how do you know when a proof is really a proof. 
07:22:17 <Cale> > let square n = round (sqrt (fromIntegral n))^2 == n in take 20 $ filter (\n -> square (5*n^2 + 4) || square (5*n^2 - 4)) [0..]
07:22:20 <lambdabot>   [0,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
07:22:47 <Cale> ImInYourMonad: Mathematics is a game which we play with rules we choose.
07:23:10 <tromp_> it doesn't take aliens to point out problems in proofs:)
07:23:27 <Cale> ImInYourMonad: While it's possible to have a computer enumerate the theorems of most formal systems, finding the *interesting* theorems is an altogether different matter.
07:23:52 <ImInYourMonad> and the choosing of axioms is "if it works it works..." ?
07:24:03 <Cale> It's a matter of taste more than anything.
07:25:06 <Cale> We generally agree on one of very few, but very general systems as a sort of baseline so that everyone can communicate nicely.
07:25:10 <Saizan> what are good options to graphviz to get a nice looking graph?
07:25:19 <Cale> But if you want to change the rules, there's nothing stopping you.
07:25:59 <Cale> Saizan: I suspect that has a lot to do with the sort of graph that it is ;)
07:27:42 <Cale> ImInYourMonad: Quite a lot can be formulated inside of systems like ZFC (which is the most popular system) though, so it's usually not even necessary to change things at that level. You just invent new structures in terms of sets, and it makes it easier for people to know what you're talking about.
07:27:53 <Saizan> heh, i bet, it's actually the graph of modules of the Cabal lib
07:29:21 <Cale> How well does the default dot fare?
07:31:05 <ImInYourMonad> and category theory is an alternative to zfc right? or does it encompass zfc? what can you do with category theory that you cant with zfc?
07:31:42 <Cale> ImInYourMonad: mm... there are formulations of category theory which can act as a foundation like ZFC, but usually categories are defined in terms of sets (and classes)
07:33:10 <Cale> The only reason why for category theory you might consider replacing your foundations is that many of the interesting categories are very very large, so that their collection of objects doesn't even fit into a single set. (For example, the collection of all sets.)
07:34:02 <Cale> Using classes (which are just predicates on sets) can avoid this problem somewhat, but if you want to deal with things like the (meta-)category of all categories, you need something more.
07:34:08 <b_jonas> Cale: isn't the reason actually that you get a finite axiom system or something like that?
07:34:18 <Cale> hm?
07:34:21 <ImInYourMonad> renderTemplateGroup anyone know where this fella is?
07:34:32 <Cale> Are you referring to the fact that ZFC has infinitely many axioms?
07:34:33 <dolio> There are set theories with finite axiom systems.
07:34:38 <b_jonas> Cale: yes
07:34:46 <Cale> You can use NBG instead if that bothers you.
07:35:20 <b_jonas> actually what bothers me now is this program I'm writing
07:35:26 <Cale> It's a conservative extension of ZFC in the sense that the theorems of NBG which only talk about sets are exactly the theorems of ZFC.
07:35:46 <Cale> (but NBG properly formalises classes)
07:36:10 <Saizan> Cale: http://code.haskell.org/~Saizan/cabal.png , using http://code.haskell.org/~Saizan/cabal.dot generated by graphmod
07:36:20 <Cale> You can get away with treating classes as an informal syntax sugar for predicates on sets though.
07:37:03 <Cale> Saizan: maybe you want to take the transitive hull or something first...
07:38:06 <Saizan> being? removing the arcs implied by transitivity?
07:38:09 <Cale> yeah
07:38:21 <noufnouf> Hi. Is it possible to cross-compile with ghc ?
07:39:45 <gwern> not really
07:40:49 <noufnouf> My case is : I have ghc 6.10 on my machine, and I want to compile something for a machine that has ghc 6.6, but I'm not root there and my disk quota is too small to compile ghc in my home. What are the options ?
07:41:43 <b_jonas> noufnouf: could you install a ghc 6.6 at home just for this?
07:41:45 <Zao> noufnouf: Install a 6.6 locally?
07:42:11 <noufnouf> no, the problem is I want ghc 6.10 for performance reasons
07:42:12 <Cale> If you're on a binary compatible platform, it might be okay just to send a binary over.
07:42:24 <noufnouf> my program runs 4 times faster with 6.10 than with 6.6
07:42:27 <b_jonas> noufnouf: or install haskell 6.10 to an unquotaed temp dir to the target machine,
07:43:00 <b_jonas> possibly automating that so when you start your program a shell script downloads a binary image with the necessary libraries from 6.10 in a temp dir
07:43:11 <Cale> (just remember that you don't actually have to compile GHC itself under normal circumstances ;)
07:43:17 <noufnouf> b_jonas : tried it, there is no such thing on the machine :-) they smelled it probably
07:43:29 <gwern> noufnouf: if your machines are the same arch, just copying over the binary is probably the best strategy
07:43:30 <b_jonas> noufnouf: not even /var/cache/fonts?
07:43:36 <b_jonas> pity
07:43:37 <gwern> although it can break if eg you use the ghc api
07:43:38 <noufnouf> maybe
07:43:51 <b_jonas> would just the runtime libraries fit?
07:43:59 <noufnouf> yes
07:44:17 <b_jonas> noufnouf: or could you try asking the administrators to install ghc 6.10 (or give you more quota) explaining your cause?
07:45:02 <noufnouf> b_jonas : I wouldn't need that if they agreed...
07:45:46 <b_jonas> noufnouf: check if ghc 6.8.2 would work in case they can install that from package?
07:46:00 <noufnouf> ok I'll try. thanks
07:46:30 <pejo> b_jonas, if you abuse /var/cache/fonts you're going to get a very angry administrator down your neck eventually.
07:46:34 <b_jonas> or just try running the program on another machine and copying the input and output over the network or something
07:47:12 <noufnouf> there is no mean to use the C output of ghc for that ?
07:48:07 <quicksilver> noufnouf: GHC doesn't have C output
07:48:09 <quicksilver> it's a lie.
07:48:31 <b_jonas> noufnouf: you'd need the runtime libraries anyway
07:48:37 <quicksilver> GHC produces something which looks a little bit like C (enough like it for GCC to parse it) but actually relies on a bunch of weird hacks to work.
07:48:40 <ImInYourMonad> the happstack tutorial is terrible, how do I just render a html-file?
07:48:56 <opqdonut> quicksilver: what kind of hacks?
07:49:17 <quicksilver> opqdonut: a perl script which post-processes the gcc output into something which actually runs.
07:50:27 <opqdonut> oh
07:51:17 <b_jonas> noufnouf: so wouldn't just the executable (with haskell libraries statically compiled in it) fit?
07:52:02 <trofi^w> > map succ "styx_mp"
07:52:03 <lambdabot>   "tuzy`nq"
07:52:09 <Gracenotes> tuzy
07:52:14 <Gracenotes> nos wais
07:52:44 <jotik> hello, I installed some Cabal thingy into $HOME/.cabal, how do I make ghc link to it properly?
07:52:50 <gwern> --user?
07:53:08 * gwern guesses
07:53:23 <jotik> gwern: was that for me? ghc has no --user flag.
07:53:25 <vegai> if the thing you're building builds through Cabal, then --user in configure phase
07:54:02 <jotik> well, i already did "runhaskell configure --user --prefix=blablabla" and build and install
07:54:09 <Cale> jotik: just to check, ensure that you're compiling with --make
07:54:10 <jotik> now i want to compile a program using that stuff
07:54:32 <vegai> hmm, my ghc takes stuff from ~/.cabal automagically
07:54:44 <Cale> jotik: or else the appropriate -package flag(s), or use cabal to build it
07:54:45 <jotik> ghc haskellfile.hs --make?
07:55:05 <ImInYourMonad> the happstack tutorial is terrible, how do I just render a html-file?
07:55:42 <ImInYourMonad> how much of a job is it to implement a production quality webserver? just making one for testing?
07:55:54 <ImInYourMonad> do i pnly need to implement http?
07:55:58 <jotik> hmm... that ghc haskellfile.hs --make appears to work, at least it created some .o file.
07:56:23 <wchogg> ImInYourMonad : You can render an html file in a few different ways.
07:57:00 <quicksilver> ImInYourMonad: you did the "Hello world" example?
07:57:06 <wchogg> ImInYourMonad : also, I'm not sure what you mean by "do i only need to implement http"?
07:57:25 <quicksilver> ImInYourMonad: just change that to "<HTML><BODY><P>Hello World</P></BODY></HTML>"
07:57:31 <quicksilver> ImInYourMonad: and that's your first html page
07:57:35 <quicksilver> it's no different.
07:59:15 <wchogg> quicksilver : well, it depends on the code really.  The content type will be "text/plain" if you end up with a ServerPartT m String
08:00:02 <ImInYourMonad> yeah i did hello world bit. from where do i import the tags? Text.html?
08:00:12 <quicksilver> there were no tags there
08:00:16 <quicksilver> that was just a literal string.
08:00:29 <wchogg> ImInYourMonad : So you're looking at the html rendering section of tutorial.happstack.com?
08:00:30 <ImInYourMonad> but then i just get the tags a sa string
08:00:33 <ImInYourMonad> yes
08:00:38 <ImInYourMonad> SH.simpleHTTP (Server.Conf 8080 Nothing) (return <HTML><BODY><P>Hello World</P></BODY></HTML>)
08:00:39 <quicksilver> "<you>can<write>what<you>want" although that doesn't make it valid html, of course.
08:00:43 <ImInYourMonad> SH.simpleHTTP (Server.Conf 8080 Nothing) (return "Movie recommendations")
08:01:12 <wchogg> ImInYourMonad : I apologize I wasn't clear enough.  You just need to wrap up the string with the HtmlString constructor in order to change the content type to html.
08:01:36 <ImInYourMonad> where is HtmlString?
08:02:17 <wchogg> :m + Happstack.Helpers
08:02:27 <eu-prleu-peupeu> :P
08:02:37 <ImInYourMonad> could not find module
08:03:06 <jpcooper> does anyone know about anyone who has tried to implement the BEEP protocol in Haskell?
08:03:24 <wchogg> Ah, so you didn't cabal install the tutorial?  Then just cabal install happstack-helpers
08:03:27 <MyCatVerbs> Is ghc-pkg still used by Cabalized projects please, anyone?
08:04:15 <Saizan> surely
08:04:49 <Saizan> Cabal inspects the package dbs via ghc-pkg
08:06:10 <MyCatVerbs> Oh... balls.
08:07:40 <v0|d> hi
08:08:05 <v0|d> is there an easy way to use hasktags alogn with cabal?
08:08:34 <v0|d> my ~/.cabal haev packages packed, hasktags cant walk.
08:11:08 <ImInYourMonad> why doesnt cabal ask if it is the right package since it soemtimes installs something completly differetn?
08:13:37 <Saizan> completely different?
08:14:01 <ImInYourMonad> awesome find lib after lib until requires unix
08:14:12 <ImInYourMonad> happstack-helpers -> crypto
08:14:16 <ImInYourMonad> and other examples
08:14:34 <ImInYourMonad> ok happstack sucks
08:14:50 <ImInYourMonad> which si ther easiest way besides happstack to run a site with haskell?
08:15:34 <wchogg> Wait, what sucks about happstack?
08:15:48 <evident> hello everybody
08:16:01 <evident> can anybody help me with my problem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2299#a2299 ?
08:16:02 <Lemmih> Are you trying to run it on Windows?
08:16:03 <ImInYourMonad> i cant install everything on windows and it uses a lot of weird monad stuff unnecessarily
08:16:25 <wchogg> What's not installing on Windows?
08:17:04 <wchogg> Also, what do you mean by "weird monad stuff" and it being unnecessary?
08:17:24 <Petrosian> Afternoon
08:17:42 <Petrosian> Does anyone know of a decent resource/paper about hindley-milner type inference?
08:17:55 <Petrosian> Possibly with some examples.
08:18:17 <pejo> Petrosian, Typing Haskell in Haskell
08:18:30 <dolio> There's the one written by Milner.
08:18:38 <Lemmih> evident: Look at line two.
08:18:48 <Petrosian> pejo: I'm actually reading that exact paper, and it assumes knowledge of hindley-milner
08:19:31 <Nicolasff> > Data.List.transpose [[1,2,3],[4,5,6],[7,8,9]]
08:19:32 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
08:20:14 <evident> Lemmih: yeah but how can I fix it there?
08:20:23 <evident> I dont the the mistake
08:21:06 <evident> -the + get :D
08:21:14 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2299#a2302 <- transpose
08:21:48 <Lemmih> evident: Try 'transpMat [[],[],[]]'.
08:23:17 <evident> you mean for the pattern matching?
08:23:27 <ImInYourMonad> evident you need a case for [] in first
08:23:32 <ImInYourMonad> and that doesnt make sense
08:23:42 <ImInYourMonad> see my revision for a much simpler transpsoe fucntion
08:23:51 <ImInYourMonad> @src Data.List.transpose
08:23:51 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:23:53 <evident> ok i will thanks
08:23:53 <centrinia> ImInYourMonad, head should work in place of first.
08:24:01 <Lemmih> evident: Try to run it in the Haskell interpreter.
08:24:01 <b_jonas> Petrosian: there's some tee-shirt about it I think that compsci people wear like phisicists wear Maxwell equation tees… oh wait, you wanted examples?
08:24:19 <evident> well I know there is a function that does it, but i wanted to solve it the long way
08:24:21 <evident> i'll try
08:25:11 <v0|d> dons: hi, around?
08:25:17 <gwern> @seen dons
08:25:17 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 8h 53m 5s ago.
08:25:20 <Lemmih> evident: If you understand why 'transpMat [[],[],[]]' fails then you'll see your problem.
08:25:43 <v0|d> gwern: thnx.
08:26:20 <wchogg> ImInYourMonad : could you share the cabal install problem you had related to happstack?
08:27:01 <evident> well I guess I know where the problem is, but I dont know how to fix it
08:27:07 <dolio> Petrosian: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.67.5276
08:27:14 <ImInYourMonad> wchogg: well i needed Happstack.helpers but then i needed htstingte,platehelper sand then i needed filemanip but then i needed unix
08:27:21 <ImInYourMonad> i use windows+msys
08:27:51 <Petrosian> dolio: Excellent, thanks.
08:27:58 <Lemmih> evident: Do you see why 'transpMat [[]]' works and 'transpMat [[],[]]' doesn't?
08:28:01 <temoto> Hello. Are there libevent (preferrably libev) bindings exist?
08:28:54 <sbahra> temoto, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlibev
08:29:04 <temoto> sbahra: thank you very much.
08:29:46 <wchogg> ImInYourMonad :  Thanks.  I wasn't aware of the unix dep on FileManip.
08:30:19 <centrinia> @let transMat2 as = if all (not . null) as then (map head as):transMat (map tail as) else []
08:30:20 <lambdabot>  <local>:6:57: Not in scope: `transMat'
08:30:29 <centrinia> @let transMat2 as = if all (not . null) as then (map head as):transMat2 (map tail as) else []
08:30:31 <lambdabot>  Defined.
08:30:56 <centrinia> > transMat2 [[1,2,3],[4,5,6],[7,8,9]]
08:30:58 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
08:34:53 <ImInYourMonad> wchogg: are you the done doing happstack? sorry or my harsh words then, it doesnt suck, i ahvent realy used it for real obv, i just get frustrated like a 4-year-old easily  when things doesnt work :)
08:35:55 <LordOfMyPants> [Char] -> [a]
08:35:59 <LordOfMyPants> What does that mean?
08:36:08 <LordOfMyPants> the [a] part that is
08:36:21 <leimy> Function of  Lists of Char to lists of Something else :-)
08:36:24 <wchogg> ImInYourMonad : I'm the current author of the tutorial and a dev on happstack itself.  No need to apologize though.
08:36:25 <chowmeined> LordOfMyPants, takes a list of Char and returns a list of a for all types a
08:36:29 <koeien> LordOfMyPants: the a is a type variable.
08:36:48 <leimy> @hoogle [Char] -> [a]
08:36:49 <lambdabot> Prelude cycle :: [a] -> [a]
08:36:49 <lambdabot> Prelude init :: [a] -> [a]
08:36:49 <lambdabot> Prelude reverse :: [a] -> [a]
08:37:04 <LeoD> map read?
08:37:09 <koeien> ImInYourMonad: most happstack developers are on OSX and gnu/linux. If you have problems building, you can also go to #happs
08:37:14 <leimy> :t map . read
08:37:16 <lambdabot> forall a b. (Read (a -> b)) => String -> [a] -> [b]
08:37:27 <leimy> oops
08:37:29 <leimy> not  .
08:37:33 <leimy> :t map read
08:37:35 <lambdabot> forall a. (Read a) => [String] -> [a]
08:37:36 <koeien> :t const [] -- probably the only sensible implementation of [Char] -> [a]
08:37:37 <lambdabot> forall a b. b -> [a]
08:37:38 <wchogg> koeien : he was actually having trouble with happs-tutorial specific code, so it's really my problem to deal with.
08:37:40 <leimy> There we go :-)
08:37:47 <koeien> wchogg: ok. didn't follow it
08:38:09 <wchogg> koeien : Yeah, just didn't want you to think there was a problem you had to worry about.
08:38:44 <centrinia> @djinn [Char] -> [a]
08:38:45 <lambdabot> Error: Undefined type []
08:39:00 <centrinia> Weird.
08:39:48 <leimy> RWH is in its second printing... wonder if I should buy it again :-)
08:39:59 <sw17ch> i should buy it for the first time
08:39:59 <lambdabot> sw17ch: You have 1 new message. '/msg lambdabot @messages' to read it.
08:40:04 <coco`> how can I make a section with the "-" function (i.e. a function that subtracts 1)?
08:40:11 <coco`> (-1) is just an int
08:40:16 <koeien> coco`: (subtract 1)
08:40:24 <leimy> :t (- 1)
08:40:24 <coco`> :)
08:40:26 <koeien> coco`: i hate the unary minus
08:40:26 <lambdabot> forall a. (Num a) => a
08:40:36 <leimy> :t (+ -1)
08:40:38 <lambdabot>     The operator `+' [infixl 6] of a section
08:40:38 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
08:40:38 <lambdabot>         in the section: `(+ - 1)'
08:40:47 <leimy> :t (+ (-1))
08:40:48 <lambdabot> forall a. (Num a) => a -> a
08:40:51 <leimy> Voila
08:41:09 <leimy> (+ (-1)) 9
08:41:12 <koeien> leimy: yeah (+ (-1)) is ok for sensible implementations of Num, but (subtract 1) is better readable imo
08:41:22 <leimy> : (+ (-1)) 9
08:41:29 <koeien> > (+ (-1)) 9
08:41:30 <lambdabot>   8
08:41:33 <leimy> oops
08:41:41 <leimy> :t subtract
08:41:41 <coco`> :t (`(-)` 1)
08:41:42 <lambdabot> forall a. (Num a) => a -> a -> a
08:41:43 <lambdabot> parse error on input `('
08:42:05 <leimy> :t (-)
08:42:06 <lambdabot> forall a. (Num a) => a -> a -> a
08:42:14 <coco`> what's wrong with `(-)` ?
08:42:24 <centrinia> > let minusminus = subtract 1 in minusminus 9
08:42:26 <lambdabot>   8
08:42:27 <leimy> :t `(-)`
08:42:28 <lambdabot> parse error on input ``'
08:42:42 <quicksilver> coco`: the thing inside `` can only be a single identifier
08:42:45 <quicksilver> not an expression.
08:42:45 <leimy> :t (-)
08:42:47 <lambdabot> forall a. (Num a) => a -> a -> a
08:42:57 <coco`> ah, o
08:42:57 <leimy> :t (-) 1
08:42:59 <lambdabot> forall t. (Num t) => t -> t
08:42:59 <coco`> ok
08:43:20 <centrinia> Are there any other unary operators besides the hyphen?
08:43:21 <coco`> (-) 1 puts the 1 on the wrong side
08:43:39 <centrinia> > flip (-) 1
08:43:41 <lambdabot>       Overlapping instances for Show (a -> a)
08:43:41 <lambdabot>        arising from a use of `s...
08:43:43 <quicksilver> centrinia: no. the hyphen is horrid thing.
08:44:00 <sw17ch> @seen TomMD
08:44:01 <lambdabot> I saw TomMD leaving #haskell, #xmonad, #ghc and #haskell-blah 10h 55m 20s ago, and .
08:44:15 <LordOfMyPants> Is there a good tutorial on ParseLib?
08:44:16 <coco`> what's the best way to get rid of (n+k) patterns?
08:44:31 <wjt> move the +k to the rhs, surely
08:44:49 <quicksilver> possibly replace them with a guard
08:44:51 * centrinia proposes that Haskell 2010 have the bitwise negation symbol ~, the boolean negation symbol !, and the pointer reference symbol &.
08:44:53 <quicksilver> depending what you were trying to do.
08:45:22 <quicksilver> centrinia: pointer reference symbol?!
08:45:22 <coco`> wjt: when used several times you would need to do -k several times
08:45:28 <coco`> how would a guard work?
08:45:50 <centrinia> quicksilver, yes. You need to know the addresses of your expressions.
08:45:58 <quicksilver> well, for example f (n+1) requires the argument to be >= 1
08:46:12 <wjt> and Haskell 90210 should define (¥) = zip ?
08:46:17 <coco`> ...and it subtracts 1 from the argument
08:46:18 <quicksilver> you could replace that with f m | m >= 1 = let n = m-1 in ...
08:46:36 <coco`> i find the additional variable too verbous
08:46:58 <coco`> no better way?
08:47:09 <quicksilver> in most practical example thre is a better way, yes.
08:47:15 <quicksilver> can you give a real case?
08:47:20 <coco`> no :)
08:47:28 <quicksilver> there is a reason for that.
08:47:30 <coco`> I was thinking in the abstract...
08:47:35 <quicksilver> there has never been useful application of n+k patterns.
08:47:40 <ImInYourMonad> can I use just cgi for displaying html?
08:47:42 <quicksilver> they actually have no purpose.
08:47:56 <coco`> that seems hard to decide :)
08:48:08 <centrinia> @let natPred (n+1) = n
08:48:08 <lambdabot>   Parse error in pattern:
08:48:19 <coco`> I find them more readable often
08:48:33 <ImInYourMonad> what is n+k patterns?
08:48:41 * sw17ch absolutely does not like n+k patterns
08:48:55 <quicksilver> coco`: but you have no examples?
08:49:11 <quicksilver> so your "often" is a degenerate "often" equivalent to "never".
08:49:13 * centrinia thinks that one should be able to define custom patterns.
08:49:26 <Philonous> Is it a good idea to enforce a static property of variables by newtyping the type in questions, not exporting the new constructors and only allow the type to be generated by functions that make sure to return values with the property?
08:49:38 <coco`> fibonacci?
08:49:46 <quicksilver> "I have carefully perused precisely zero examples of code which use n+k patterns, and I find they are often more readable"
08:49:59 <quicksilver> Philonous: yes.
08:50:12 <quicksilver> centrinia: something like ViewPatterns?
08:50:39 * centrinia looks that up.
08:51:09 <quicksilver> I think they're a nice idea but a bit clunky in practice.
08:51:14 <ImInYourMonad> example?
08:51:19 <quicksilver> I think quasiquotation is closer to what I really want in this case.
08:51:24 <quicksilver> if I ever want it.
08:51:48 <coco`> "the fact that you don't have an xample in mind proves that they are useless"
08:52:16 <quicksilver> coco`: indeed. That's rhetoric for you.
08:52:35 <Philonous> quicksilver: Ah thanks. That gets rid of the ubiquitous sanity checks :D
08:52:38 <quicksilver> coco`: but the burden of truth is on you. If you're objecting to them being removed, you should provide cases where you think they are best ;)
08:52:53 <quicksilver> Philonous: we call this property an invariant, by the way.
08:53:07 <quicksilver> Philonous: proving your code is well behaved is often about checking that all functions maintain invariants.
08:53:09 <coco`> quicksilver: well, it could be just me (what if I was unable to think of a use for monads?)
08:53:12 <quicksilver> it's a useful way to think.
08:53:19 <coco`> quicksilver: I actually think they should be removed
08:53:32 <coco`> quicksilver: just wondering how to best replace them
08:53:52 <centrinia> coco`, Arrows!
08:53:54 <coco`> view patterns seem to give a general way to do this
08:54:00 <coco`> Arrows?!
08:54:08 <quicksilver> yes, view patterns are more general and quasiquotation is even more general.
08:55:23 <coco`> centrinia: how can Arraws help here?
08:56:09 <Philonous> quicksilver: That sounds reasonable. It surely eliminates a whole class of errors.
08:57:02 <centrinia> Oh, arrows can be used in place of monads.
08:57:43 <quicksilver> Philonous: of course, this is what a type system does, too. But type systems can't express everything. The stronger your type system, the fewer "other" invariants you have to maintain.
08:58:59 <pejo> And the more you need to employ a guy with a PhD in CS to write the program for you.
09:01:39 <sw17ch> pejo: i don't have a PhD (though, i'd like one) and i'll write it for you :)
09:02:43 <lifelover> hey guys
09:03:07 <lifelover> Is it okay to ask a not very haskell specific question here? (I'm not sure where I should ask it)
09:03:22 <quicksilver> any attempt to employ a programmer without a PhD in CS is foolhardy, dangerous and frankly immoral, anyway.
09:03:31 <Philonous> Is there a smart way to ignore the invariant encapsulation when it is not needed? Always peeling it out of the newtype introduces a lot of cruft
09:04:03 <wchogg> quicksilver : I think that might be going a _little_ bit far. :p
09:04:05 <quicksilver> derive or lift the operations through the newtype.
09:04:07 <sw17ch> quicksilver: i'm hurt :(
09:04:25 <quicksilver> GHC's newtype deriving may help
09:04:33 <quicksilver> if it as class operations you were trying to peel through.
09:04:37 <quicksilver> s/as/was/
09:04:48 <lifelover> eh, I take that as a yes. My question is that I don't really understand/grasp what the difference between horizontal and vertical distribution is (in distributed systems)?
09:05:50 <ImInYourMonad> is their some limit to digital compression that means they cant have the ame quality as old tapes? or is it just thta hey need to fit more into less space and thus sacrifice soundquality?
09:06:45 <Philonous> Unfortunately it is not. but maybe I'll introduce a type class and put all the functions that might return a encapsulated value in there. then I can have an instance for the base type and the newtype.
09:07:03 <Gracenotes> "<-- augustss has left freenode ()", obviously an IO () action
09:07:20 <Gracenotes> .-.
09:07:34 <quicksilver> "augustss has quit []"; nope, it was just an empty list.
09:07:44 <quicksilver> what a terrible idea, to put augustss in the IO monad.
09:08:26 <Philonous> unsafeRescueAugustssFromIO will save the day.
09:08:27 <Gracenotes> *phew*
09:10:28 <ImInYourMonad> hes in my monad
09:10:36 <ImInYourMonad> forkAugust
09:10:38 <lifelover> hmm, can anyone recommend some general CS channel here on irc?
09:10:45 <Eridius> lifelover: you should try out #haskell
09:11:02 <Eridius> lots of fun stuff about functional programming there
09:11:03 <Eridius> :P
09:11:04 <lifelover> heh, I tried, but no one seemed to answer
09:12:42 <lifelover> to rephrase it; what is the difference between horizontal and vertical distribution (in distributed computer systems)
09:12:46 <lifelover> ?
09:13:26 <Gracenotes> well, Haskell seems a tad bit more theoretical CS-y
09:13:53 <lifelover> yea, I guess so
09:14:21 <doserj> lifelover: isn't it simply horizontal = distribute the same work on several systems, vertical = divide the work in different parts and distribute the parts?
09:14:43 <lifelover> it might be that simple yea
09:14:51 <kiris> ENTERPRISE QUALITY SCALABLE FUNCTIONAL SOLUTIONS
09:15:25 <ImInYourMonad> anyone installed GLUT on windows?
09:15:30 <pejo> @quote yoneda
09:15:30 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
09:15:30 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
09:16:09 <Gracenotes> lifelover: it seems that http://cs.acadiau.ca/~dbenoit/4343/slides/ppt/Week13.1_Distributed_Systems_Intro.ppt (CS department URL, looks like) covers this at slide 31
09:16:21 <Gracenotes> or something like it, at least. Via brief Google search.
09:16:41 <Gracenotes> 34: The multitiered examples that we have seen are referred to as vertical distribution because the work is split up across “vertical” machines. We can distribute work across multiple servers as well, and this is known as horizontal distribution.
09:19:33 <lifelover> thanks Gracenotes, I get it now :)
09:20:31 <lifelover> So, a follow-up question. Is bittorrent horizontal or vertical?
09:20:51 <c_wraith> both.  just like most systems
09:21:34 <ImInYourMonad> how can I open a port on 8080 and redirect output there?
09:21:43 <lifelover> c_wraith: ah, that's true
09:26:30 <leimy> @src cycle
09:26:30 <lambdabot> cycle [] = undefined
09:26:30 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:27:33 <leimy> > cycle []
09:27:35 <lambdabot>   * Exception: Prelude.cycle: empty list
09:27:37 <leimy> neato
09:28:13 <opqdonut> why not cycle []=[]
09:28:40 <c_wraith> because cycle should always return an infinite list
09:28:50 <ddarius> opqdonut: Take the second case and apply it to [].
09:29:13 <Philonous> If I have something like newtype MyInt = My Int then a function  fromMyInt (My x) = x should get compiled to a noop, right?
09:29:17 <c_wraith> it's hard to make an infinite list out of 0 elements.
09:29:24 <bitcirkel> Hello, I just installed GHC and the Yi editor. How do I start the editor? It doesn't seem to have an executable
09:29:44 <Saizan> bitcirkel: simply "yi"
09:29:45 <bitcirkel> Installed it via Cabal
09:29:57 <Saizan> you probably have it under ~/.cabal/bin
09:30:11 <Eridius> Philonous: basically yeah, but to make it even easier, newtype MyInt = My { fromMyInt :: Int }
09:31:13 <pchiusano> I noticed something kind of interesting - suppose I have a type m a for which extract :: m a -> a is defined
09:31:18 <centrinia> Is the contrapositive valid in intuitionistic logic?
09:31:34 <sw17ch> @seen dons
09:31:34 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 9h 59m 22s ago.
09:32:10 <pchiusano> then the monad for m will have map f = f . extract and join = extract . extract
09:32:20 <Saizan> centrinia: you can ask djinn, i think :)
09:32:30 <pchiusano> is this just a coincidence?
09:32:47 <centrinia> @djinn (a -> b) -> (Not b -> Not a)
09:32:47 <lambdabot> f a b c = b (a c)
09:32:59 <dons> heya sw17ch
09:32:59 <lambdabot> dons: You have 10 new messages. '/msg lambdabot @messages' to read them.
09:33:06 <Badger> heh.
09:33:08 <dons> threadscope looks pretty cool.
09:33:10 <dons> http://www.reddit.com/r/programming/comments/83unc/threadscope_a_graphical_view_into_ghcs_runtime/
09:33:12 <quicksilver> pchiusano: extract.extract would have type m m a -> a, not m m a -> m a
09:33:16 <dons> dcoutts: have you seen it?
09:33:17 <sw17ch> Thread scope *does* look cool!
09:33:34 <ddarius> centrinia: That's just precomposition.
09:34:23 <pchiusano> quicksilver: right... so join = extract
09:34:32 <pchiusano> er...
09:34:33 <Philonous> Eridius: Is see that this way  fromMyInt automatically becomes the accessor function. But how would I construct a MyInt Value?
09:34:48 <Eridius> Philonous: you can construct it the normal way
09:34:57 <Eridius> you can ignore the field names if you want when constructing
09:34:59 <opqdonut> ddarius: yeah of course it doesn't work, but cycle [] = [] would be a sane definition imo
09:35:05 <ddarius> pchiusano: That won't satisfy the laws.
09:35:05 <centrinia> ddarius, What would contrapositive look like?
09:35:11 <Eridius> opqdonut: except it breaks the invariant that cycle returns an infinite list
09:35:32 <quicksilver> pchiusano: if join = extract, you'd have something pretty trivial.
09:35:33 <opqdonut> Eridius: well so does undefined ;)
09:35:52 <ddarius> opqdonut: cycle [] is probably an error.
09:35:57 <Philonous> Ah nifty. Though it seems a little bit like abusing the syntax.
09:35:59 <Eridius> opqdonut: undefined means it's an error to call it with that
09:36:02 <pejo> dons, is it available?
09:36:10 <Eridius> Philonous: it's a fairly common way of doing newtypes, from what I've seen
09:36:17 <quicksilver> pchiusano: I suspect you have (m a) isomorphic to (a) in fact.
09:36:22 <Philonous> I see. Thanks.
09:37:25 <pchiusano> quicksilver: you are right
09:37:59 <pchiusano> quicksilver: I am experimenting with a Future a type, representing a lazily computed value of type a
09:38:21 <pchiusano> er, not lazily computed - but computed in possibly a separate thread
09:38:43 <quicksilver> I'm familiar with the notion.
09:40:22 <pchiusano> ddarius: can you explain why it won't satisfy the laws
09:43:17 <ddarius> pchiusano: Well it might, but it doesn't inherently satisfy the laws.  For Identity it obviously will, for Streams the natural thing to call extract does actually do the right thing kind of by accident, but not every function Stream a -> a does the right thing.
09:44:18 <Valodim> > cycle []
09:44:19 <lambdabot>   * Exception: Prelude.cycle: empty list
09:45:00 <Valodim> huh. I wonder why, wouldn't a cycled empty list just be an empty list?
09:45:22 <ddarius> Why should it be?
09:45:29 <Eridius> Valodim: because cycle returns an infinite list
09:45:39 <Eridius> and you can't construct an infinite list from an empty one
09:45:46 <idnar> Valodim: it's an /infinitely/ empty list
09:45:49 <quicksilver> I don't think that's a good answer, eridius.
09:46:02 <quicksilver> where is the specification of cycle which says cycle returns and infinite list?
09:46:05 <Philonous> Are ViewPattern present in ghc 6.8.3 ?
09:46:13 <Eridius> quicksilver: I don't see why not. The whole point of cycle is it returns an infinite list. There's no way to do that when it's given an empty one, so it errors
09:46:15 <ddarius> quicksilver: It can be made into a good answer, e.g. there are nice properties that cycle has.
09:46:29 <quicksilver> I think the real answer is something more like "for the same reason that sum [0,0...] is _|_"
09:46:40 <ddarius> quicksilver: I agree.
09:46:49 <ddarius> cycle = fix . (++)
09:46:59 <ddarius> cycle [] = fix ([] ++) = fix id
09:47:10 <skorpan> @pl \m a s -> s a m
09:47:10 <lambdabot> flip (flip . flip id)
09:47:16 <Valodim> > cycle [1..]
09:47:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:47:24 <quicksilver> which is to say that there are mathematical models in which sum [0,0..] = 0, but haskell's evaluation model isn't one of them.
09:47:32 <Valodim> hm. so an infinite list is unchanged
09:47:36 <quicksilver> smilarly, there are mathematical models in which "cycle []" is [].
09:47:41 <quicksilver> but haskell's evaluation model isn't one.
09:48:02 <quicksilver> it's a different notion of convergence.
09:48:05 <ddarius> Valodim: Appending anything to the end of an infinite list just produces the same list (which is why join = extract in pchiusano's question)
09:48:09 <ddarius> (for Streams)
09:48:52 <Valodim> so basically it's the dividing zero by zero problem
09:49:15 <ddarius> Valodim: No, just the dividing by zero problem.
09:49:42 <ddarius> One property cycle currently has is: cycle xs ++ ys = cycle xs
09:50:16 <Valodim> huh? what cycle usually does is "dividing by zero", basically. take a value and make it infinite
09:50:31 <Eridius> dividing by zero does not make something infinite
09:50:35 <Eridius> dividing by zero is literally undefined
09:50:40 <skorpan> i read somewhere that you can have a "puts" for the state monad, but i can't figure out how that would work.  is it possible?  (puts is to put what gets is to get)
09:50:55 * centrinia defines "dividing by zero" to be "nullity" :)
09:51:00 <Eridius> har
09:51:06 <Eridius> *har har har
09:51:58 <Valodim> @let a / 0 = 0
09:52:00 <lambdabot>  <local>:7:0:
09:52:00 <lambdabot>      Warning: Pattern match(es) are overlapped
09:52:00 <lambdabot>               In...
09:52:00 <centrinia> Too bad (reverse . reverse . cycle) is not equivalent to cycle. :(
09:52:20 <skorpan> let a / 0 = 0 in 5000 / 0
09:52:25 <skorpan> > let a / 0 = 0 in 5000 / 0
09:52:26 <lambdabot>   0
09:52:29 <dolio> puts f x = put (f x)?
09:52:34 <skorpan> > let a / 0 = nullity in 5000 / 0
09:52:35 <lambdabot>   Not in scope: `nullity'
09:52:43 <skorpan> > let a / 0 = "nullity" in 5000 / 0
09:52:44 <lambdabot>   "nullity"
09:53:08 <Eridius> > let a / 0 = "nullity" in 5000 / 1
09:53:09 <lambdabot>   "* Exception: /tmp/8136505958126501146:71:60-76: Non-exhaustive patterns in...
09:53:47 <Valodim> @let a / 0 = "nullity"
09:53:47 <skorpan> dolio: but the problem is that the functions you pass as the "f" in "puts f x" aren't really possible to pass on their own.  they can only be used in applications, afaict!
09:53:48 <lambdabot>  Defined.
09:53:50 <Valodim> > 5 / 0
09:53:51 <lambdabot>       Ambiguous occurrence `/'
09:53:51 <lambdabot>      It could refer to either `Prelude./', imp...
09:53:57 <Valodim> aw :P
09:54:17 <Valodim> what's the module those are defined in? H, isn't it?
09:54:29 <ddarius> > 5 L./ 0
09:54:30 <lambdabot>   "nullity"
09:54:44 <Valodim> ah, L
09:54:52 <Valodim> well, close
09:54:54 <dolio> skorpan: I don't really understand that sentence.
09:55:11 <dolio> Obviously my definition of puts is pretty useless, but I can't think of a better one.
09:55:29 <ddarius> gets f = f <$> get
09:56:10 <Badger> @src (<$>)
09:56:11 <lambdabot> f <$> a = fmap f a
09:56:59 <dolio> @type let puts f = f <$> put in puts
09:57:00 <lambdabot> forall (m :: * -> *) b s. (MonadState s m) => (m () -> b) -> s -> b
09:59:02 <dolio> @type let puts f = f `local` put in puts
09:59:03 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> s -> m ()
09:59:17 <skorpan> let's say we have a state which is: data X = X { hello :: String, world :: String }... to get the "hello" string, you could use "gets hello". but suppose i would want to set the "hello" to something, i'd like to do 'puts hello "yo"'.  how would i implement puts?
09:59:29 <bitcirkel> Saizan:  thanks! I had somehow managed to compile Yi as a library before. Now it's where you said.
09:59:55 <skorpan> :t local
09:59:56 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
10:01:03 <Eridius> skorpan: you'd have to first define a method (setHello :: X -> String -> X) before what you're asking for would make any sense
10:02:43 <skorpan> Eridius: what about it doesn't make sense?
10:03:35 <Valodim> difficult question indeed. I suppose the "hello" thing is only the getter function, can't really think of a way to /set/ the value it points to
10:03:44 <skorpan> exactly
10:04:20 <dolio> Well, then.
10:04:22 <Gracenotes> well, to modify a specific item, putBlah s = modify $ \x -> x { blah = s }
10:04:30 <dolio> @type let puts f x = modify (f x) in puts
10:04:31 <lambdabot> forall t s (m :: * -> *). (MonadState s m) => (t -> s -> s) -> t -> m ()
10:04:36 <Gracenotes> not sure if blah can be variable though
10:04:42 <ddarius> It can't.
10:04:46 <Valodim> so no, I don't think there's a good way to do it by reference of the getter
10:07:19 <Eridius> it doesn't really even make sense to try and do it by reference of the getter, since the getter is just a function, not some magical token
10:07:49 <Gracenotes> hm. On a related note, GADTs are also probably more inclined towards getters than setters
10:08:27 <Gracenotes> blah :: X -> String, I don't see many with X -> String -> X
10:09:46 <ddarius> @hackage data-accessor
10:09:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
10:10:03 <skorpan> what does this mean?
10:10:03 <skorpan> Could not find module `Control.Monad.State':
10:10:03 <skorpan>       it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2
10:11:00 <Eridius> skorpan: you need to hide one of those packages
10:11:10 <Eridius> monads-fd reimplements many of the mtl monads using functional dependencies
10:11:17 <Saizan> or pass a -package flag
10:11:29 <skorpan> i'm trying to use this in ghci, btw
10:12:33 <skorpan> can i hide packages in an already running ghci?
10:12:43 <Saizan> no
10:12:50 <Eridius> actually yes
10:12:54 <Saizan> try :set -package mtl (or monads-fd)
10:12:55 <Eridius> let me find out, I did it just the other day
10:13:22 <Eridius> Saizan: doesn't work. it links the package, but doesn't hide mtl
10:13:35 <skorpan> yep, didn't work
10:13:48 <Eridius> here we go. :set -hide-package monads-fd
10:14:03 <skorpan> thanks a lot Eridius!
10:14:06 <bremner> import FooBar ()
10:14:09 <Eridius> np
10:14:10 <skorpan> i'll M-x remember that
10:14:10 <bremner> ?
10:14:32 <Saizan> nice
10:14:43 <Eridius> I just looked up the user manual, packages flags
10:14:48 <Eridius> any of those flags you can pass to :set
10:15:21 * quicksilver is curious what monads-fd uses fundeps for that mtl doesn't already.
10:15:40 <quicksilver> (mtl already has fundeps for MonadState, MonadError, MonadReader etc)
10:15:56 <Saizan> i think it's just a reimplementation using "transformers"
10:16:35 <quicksilver> in fact, sometimes I wish the fundep on MonadState wasn't there.
10:16:43 <quicksilver> and then sometimes I wish I wasn't using type classes at all
10:16:50 <quicksilver> and I rewrite all my code to use lenses instead :)
10:17:07 <Eridius> lenses?
10:17:08 <wchogg> quicksilver : Well, I think I've seen a paper that suggested fundeps shouldn't have been used in MonadState
10:17:29 <quicksilver> it's easy to suggest.
10:17:32 <quicksilver> heck, I just did it.
10:17:53 <quicksilver> but even if you remove the fundep, you still can't be an instance of MonadState Int in two different ways
10:18:00 <quicksilver> so you can't have two different Int states.
10:18:03 <Saizan> however i'm a bit worried about having multiple monad libraries, expecially since most are based on writing loads of boilerplate instances
10:18:03 * ddarius suggests that we add the fundep s -> m to MonadState
10:18:22 <wchogg> quicksilver : Well, it was from the author of the original fundeps paper though which is what I found amusing.
10:18:25 <quicksilver> which makes you realise that type-based selection isn't what you want.
10:18:26 <quicksilver> :)
10:18:30 <Saizan> so it's even harder to bridge between two libraries using different ones
10:19:02 <quicksilver> Saizan: if only we had modules with signatures :)
10:19:27 <Saizan> heh
10:20:30 <dolio> Why would you want two different instances for MonadState Int whatever?
10:20:55 <quicksilver> because you might have two different parcels of Int state.
10:20:57 <Saizan> StateT Int (StateT Int m) a
10:21:02 <quicksilver> right.
10:22:17 <dolio> Clearly there you want an instance MonadState (Int,Int) (StateT Int (StateT Int m)).
10:22:44 <quicksilver> perhaps you do.
10:22:55 <quicksilver> but you might want to pass it to other polymorphic combinators you have
10:22:56 <quicksilver> which have the type
10:23:03 <quicksilver> MonadState Int m => m a
10:23:11 <quicksilver> and you need some way to choose which int.
10:23:22 <quicksilver> like I say, this is just an example of abusing classes.
10:23:29 <quicksilver> lenses would be more explicit, and better.
10:25:02 <Saizan> lenses for tranformer stacks?
10:25:10 <dolio> Well, there already is a way to select.
10:25:20 <ImInYourMonad> how do I tell ghci to gc?
10:25:28 <quicksilver> System.Mem.performGC
10:25:30 <dolio> If foo :: MonadState Int m => m a, then "foo" uses the outer and "lift foo" uses the inner.
10:25:58 <quicksilver> sure, but that relies on ugly overlapping instances.
10:26:05 <quicksilver> or does it?
10:26:09 <dolio> No.
10:26:14 <quicksilver> ok, better example is
10:26:47 <quicksilver> FooT (BarT (BazT (StateT Int (FooT (BarT (IceT (StateT Int (BiscuitT (Identity...
10:27:12 <quicksilver> the problem that MonadState is supposed to solve is having to remember where in the stack you have to lift to.
10:27:42 <quicksilver> if you have two StateTs in the stack, it's no longer really fit for purpose.
10:27:44 <dolio> I don't believe that example. :)
10:28:18 <Saizan> well, MonadState also offer you the ability to use a totally different implementation
10:28:46 <quicksilver> yes, that's true.
10:28:59 <FunctorSalad> cabal claims that it supports haddock syntax for the description field, but I can't get bulleted lists to work
10:31:31 <Eridius> what's RWS? The haddock documentation leaves much to be desired
10:31:31 <DubaiGirl> HI to every body
10:31:46 <FunctorSalad> (do I have to quote the description field somehow?)
10:31:52 <dons> Read Write State
10:31:56 <Eridius> ahh
10:32:05 * Eridius was wondering if that's what it was
10:32:20 <Eridius> I'm surprised that it doesn't even say that much
10:33:43 <DubaiGirl> :O
10:34:44 <DubaiGirl> hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
10:35:15 <Saizan> hi
10:35:15 <Philippa_> 'lo
10:36:46 <DubaiGirl> Saizan , where r u from ?
10:37:02 <ImInYourMonad> lol
10:44:38 <tacotaco> iminyourmonad: are you causing side effects?
10:44:58 <ImInYourMonad> forking your ios left and right
10:45:10 <tacotaco> :D
10:45:36 <FunctorSalad> I solved it; cabal ignores empty lines unless you put "." on the line
10:51:37 <dany> hi
10:56:20 <augustss> yo!
11:16:42 <wli> @type foldr ((first . (:)) ||| (second . (:))) ([], [])
11:16:44 <lambdabot> forall b c. [Either b c] -> ([b], [c])
11:17:24 <rabideejit> Parsec is cool.  For the first time I've used it to parse something other than strings.  My cherry is popped.
11:18:12 --- mode: ChanServ set +o glguy
11:18:15 --- mode: glguy set -b *!*@94-171-216-52.cable.ubr15.wolv.blueyonder.co.uk
11:18:18 --- mode: glguy set -o glguy
11:22:40 <quicksilver> it annoys me that it is not easy for me to make changes to the libraries which came with GHC
11:22:43 <quicksilver> (e.g. to debug them)
11:22:55 <leimy> I can't remember if there's already a function that can do this...
11:22:59 <leimy> > ((++) . (++ ",")) "1" "2"
11:23:00 <lambdabot>   "1,2"
11:23:06 <leimy> basically insert commas.
11:23:08 <sw17ch> :t intercalate
11:23:09 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:23:13 <leimy> thanks!
11:23:15 <sw17ch> i think
11:23:27 <sw17ch> > intercalate "," ["1","2"]
11:23:28 <lambdabot>   "1,2"
11:23:30 <sw17ch> tada!
11:23:31 <leimy> yep
11:23:34 <leimy> that's it :-)
11:24:44 <leimy> I was going to foldl on ((++) . (++ ","))
11:24:55 <leimy> intercalate seems nicer :-)
11:25:18 <sw17ch> @src intercalate
11:25:19 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
11:25:27 <sw17ch> @src intersperse
11:25:27 <lambdabot> intersperse _   []     = []
11:25:27 <lambdabot> intersperse _   [x]    = [x]
11:25:27 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
11:25:37 <ziman> and foldl would be O(n^2) in this case, i think :)
11:25:43 <sw17ch> > intercalate a [b,c,d]
11:25:44 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
11:25:46 <leimy> foldl ((++) . (++ ",")) "this,is,cool" ["1","2","3"]
11:25:48 <leimy> oops
11:25:49 <leimy> > foldl ((++) . (++ ",")) "this,is,cool" ["1","2","3"]
11:25:51 <lambdabot>   "this,is,cool,1,2,3"
11:26:23 <ziman> @unpl (++) . (++ ",")
11:26:23 <lambdabot> (\ d -> (++) (d ++ ","))
11:26:38 <leimy> neat
11:26:51 <leimy> too much ++ :-)
11:27:45 <quicksilver> @pl \f -> f . (\y -> f y ",")
11:27:46 <lambdabot> ap (.) (flip flip ",")
11:28:19 <ImInYourMonad> does number theory exite you
11:28:23 <ImInYourMonad> ?
11:28:25 <opqdonut> yep
11:29:02 <quicksilver> > foldl (ap (.) (flip flip ",") (++)) "" ["1","2","3"]
11:29:03 <lambdabot>   ",1,2,3"
11:29:22 <quicksilver> leimy: eliminated that redundant deuplication of (++)
11:29:22 <quicksilver> ;)
11:29:41 <leimy> yeah but does that do what I want ? :-)
11:29:47 <leimy> oh I see using ap (.)
11:29:48 <leimy> yeah
11:29:59 <leimy> And no it doesn't seem to do what I'm thinking of :-)
11:30:10 <leimy> also, this isn't a piece of high performance code, so readability for the win here. :-)
11:30:15 <quicksilver> > foldl (ap (.) (flip flip ",") (++)) "this,is,cool" ["1","2","3"]
11:30:16 <lambdabot>   "this,is,cool,1,2,3"
11:30:19 <leimy> if it responds within a second I'm done :-)
11:30:22 <quicksilver> well it does the same as your code.
11:30:27 <quicksilver> it has the same bad complexity.
11:30:30 <ImInYourMonad> isnt studying only number theory a bit like numerology?
11:30:32 <leimy> does the same vs someone else can read it :-)
11:30:38 <ImInYourMonad> why did gauss find it so exciting?
11:31:10 <leimy> > foldl (ap (.) (flip flip ",") (++)) "this,is,cool" ["1","2","3"]
11:31:12 <lambdabot>   "this,is,cool,1,2,3"
11:31:29 <leimy> > foldl (ap (.) (",") (++)) "this,is,cool" ["1","2","3"]
11:31:31 <lambdabot>   Couldn't match expected type `(b -> b1 -> a) -> a -> b'
11:31:34 <leimy> Ah
11:31:38 <leimy> flip flip for the win? :-)
11:31:49 <leimy> :t lip
11:31:50 <lambdabot> Not in scope: `lip'
11:31:52 <leimy> :t flip
11:31:54 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:32:03 <quicksilver> apparently so.
11:32:10 <quicksilver> :t flip flip
11:32:11 <leimy> :t  flip flip
11:32:11 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:32:13 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:32:15 <byorgey> ImInYourMonad: number theory is to numerology as the mandelbrot set is to the scribblings of a two-year-old.
11:32:28 <leimy> it's like flip/shift
11:32:33 <quicksilver> byorgey: YHBT. HTH. HAND>
11:32:55 <leimy> :t flip flip flip
11:32:57 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
11:33:04 <leimy> starts getting ugly :-)
11:33:18 <leimy> :t flip . flip flip
11:33:19 <lambdabot> forall a b c. b -> a -> (a -> b -> c) -> c
11:33:53 <byorgey> quicksilver: I'm not familiar with those acronyms...
11:33:56 <leimy> ok I've established for myself that "flip is pretty cool"
11:34:33 <opqdonut> :t flip flip flip
11:34:34 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
11:34:41 <leimy> :t flip flip . flip flip
11:34:43 <lambdabot> forall a c a1 b c1. b -> (a -> ((a1 -> b -> c1) -> a1 -> c1) -> c) -> a -> c
11:35:20 <leimy> :t flip . flip . flip flip
11:35:21 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:35:52 <leimy> :t flip . flip . flip . flip flip
11:35:53 <lambdabot> forall a b c. b -> a -> (a -> b -> c) -> c
11:36:32 <quicksilver> Gah. Hidden modules too.
11:38:49 <quicksilver> for the first time I wish I could just monkeypatch a system module like they do in trendy languages.
11:38:53 <skorpan> would someone care to look at this piece of code?  i'm trying to figure out if it's possible at all to do this.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2310#a2310
11:39:31 <quicksilver> I think I have a bug in HOpenGL, but to investigate properly I'm going to have to get a working hopengl source tree which I can build a new version of the pacakge.
11:40:21 <opqdonut> skorpan: why not "gets hello >>= \h -> gets world >>= \w -> put (Hello w h)" ?
11:40:38 <skorpan> opqdonut: oh, so the "put" would have access to the "h"?
11:41:14 <quicksilver> yes, the lambdas are nested.
11:41:18 <opqdonut> yes
11:41:20 <opqdonut> that's the point
11:41:21 <quicksilver> that is the key, in a sense.
11:41:25 <skorpan> oh, thanks!
11:41:35 <opqdonut> lambdas extend as far to the right as they can
11:41:35 <skorpan> i knew this exercise would prove useful for something :)
11:41:44 <quicksilver> "get >>= \hw -> put (Hello (world hw) (hello hw))"
11:41:48 <quicksilver> also suggests itself.
11:41:54 <quicksilver> but maybe you knew taht and it wasn't your point.
11:42:04 <skorpan> i knew that, but didn't come to think of it :)
11:47:18 * byorgey sets up a pot of chocolate fondue with lots of little marshmallow, pound cake, and strawberry lambdas on little toothpicks
11:48:37 <sw17ch> byorgey: i must have lost my invitation
11:49:04 <byorgey> but you're already here!
11:52:19 <sw17ch> byorgey: i'm quite curious how you managed to grow strawberry lambdas
11:52:36 <byorgey> sw17ch: genetic engineering
11:52:50 <byorgey> you just insert some genes from a lambda into a strawberry
11:53:08 * jmcarthur suddenly falls in love with XMonad.Layout.IM
11:53:09 <sw17ch> i thought the genetic material of lambdas was not carbon based... how does one manage that?
11:53:45 <byorgey> sw17ch: well, that's the tricky part.  I've managed to get around it by using virtual strawberries.
11:54:13 <sw17ch> ah yes, some combinator wrappers around the carbon bits would do it
11:54:13 <rio> no carbon gene transformation?
11:55:27 <sw17ch> argh, i need to step out for a bit. back later!
12:02:30 <leimy> what is non-monadic "ap" called?
12:02:45 <leimy> I'm having one of those days
12:03:34 <byorgey> leimy: (<*>)
12:03:35 <BONUS> leimy: <*>
12:03:39 <leimy> Ah
12:03:40 <byorgey> in Control.Applicative
12:03:40 <leimy> thank you
12:04:44 <leimy> I'm trying to write something like this but without feeling like I'm re-inventing the wheel
12:05:01 <leimy> foldl (\x y -> y x) z [insert "1" 1, insert "2" 2]
12:05:11 <leimy> Where z is a Data.Map
12:06:06 <leimy> foldl (\x y -> y x) Data.Map.empty [Data.Map.insert "1" 1, Data.Map.insert "2" 2]
12:06:52 <Eridius> leimy: maybe you should make it a list of [("1", 1), ("2", 2)] and shove the Data.Map.insert into the lambda?
12:06:55 <leimy> :t flip (<*>)
12:06:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:07:20 <leimy> Eridius: While that would do it... it's not so satisfying :-)
12:07:58 <aleator> Or just fromList and union?
12:08:04 <Eridius> leimy: fromList
12:08:09 <leimy> fromList probably gets me there :-)
12:08:11 <Eridius> @type Data.Map.fromList
12:08:12 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
12:08:21 <leimy> however... I'm still interested in the answer to the question :-)
12:08:25 <leimy> whether it's practical or not.
12:08:38 <Eridius> what's the question now? we just solved the reinventing-the-wheel part
12:08:39 <leimy> :t (\x y -> y x)
12:08:40 <lambdabot> forall t t1. t -> (t -> t1) -> t1
12:08:45 <Eridius> ooh
12:08:48 <leimy> does that lambda exist? :-)
12:08:51 <leimy> as another name
12:09:01 <dolio> @type flip id
12:09:02 <lambdabot> forall b c. b -> (b -> c) -> c
12:09:05 <leimy> :t flip (<*>)
12:09:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:09:07 <Eridius> @hoogle (a -> b) -> a -> b
12:09:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:09:07 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
12:09:07 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
12:09:09 <leimy> is almost it :-)
12:09:26 <Eridius> oh wait, I had the type backwards
12:09:32 <leimy> :t flip ($)
12:09:33 <lambdabot> forall a b. a -> (a -> b) -> b
12:09:33 <Eridius> but still, (flip.$)
12:09:37 <leimy> aha
12:09:39 <leimy> that's what I thought.
12:09:55 <leimy> well that it existed.
12:10:04 <leimy> not that I could remember what it was called :-)
12:10:36 <Eridius> heh
12:11:06 <leimy> > foldl (flip ($)) Data.Map.empty [Data.Map.insert "1" 1, Data.Map.insert "2" 2]
12:11:08 <lambdabot>   /tmp/4543350367002003254:70:65: Not in scope: `Data.Map.empty'/tmp/45433503...
12:11:12 <leimy> DOH!
12:11:21 <leimy> > Data.Map.empty
12:11:22 <lambdabot>   /tmp/5581424518779315982:70:32: Not in scope: `Data.Map.empty'
12:11:37 <leimy> :t Data.Map.empty
12:11:37 <dolio> 'flip id' is one character shorter.
12:11:37 <lambdabot> forall k a. M.Map k a
12:11:39 <dolio> Booyah!
12:11:47 <leimy> dolio: but it doesn't apply the function does it?
12:11:54 <dolio> Yes.
12:11:59 <dolio> ($) = id.
12:12:07 <dolio> It's just that the type is restricted to functions.
12:12:11 <leimy> hmmm
12:12:47 <dolio> f $ x = f x ==> ($) f x = f x =eta=> ($) f = f
12:13:01 <leimy> oh i see
12:13:03 <leimy> good ole lc :-)
12:14:27 <Eridius> dolio: interesting, I hadn't realized that before
12:14:49 <Eridius> > foldl (flip id) M.empty [M.insert "1" 1, M.insert "2", 2]
12:14:50 <lambdabot>   Couldn't match expected type `M.Map [Char] a'
12:14:56 <jmcarthur> in other news, f `id` x introduces a new level of precedence...
12:15:13 <Eridius> hah
12:15:22 <Eridius> what's that, infixl 5?
12:15:40 <paper_cc1> Eridius: ($) is infixr 0
12:15:49 <Eridius> paper_cc1: right. I was asking about `id`
12:15:57 <koeien> Eridius: it says it's a left-associative operator with precedence 5
12:15:57 <Eridius> infix operators without a defined fixity default to infixl 5, right?
12:16:10 <Eridius> koeien: I didn't ask what infixl 5 meant
12:16:27 <koeien> Eridius: ahw, i just got into the discussion
12:16:38 <paper_cc1> I'd say they should default to infixr
12:17:07 <leimy> > foldl (flip ($)) M.empty [M.insert "1" 1, M.insert "2", 2]
12:17:09 <lambdabot>   Couldn't match expected type `M.Map [Char] a'
12:17:15 <Eridius> ah, infixl 9 is actually the default
12:17:19 <Eridius> Any operator lacking a fixity declaration is assumed to be infixl 9
12:17:24 <leimy> > foldl (flip id) M.empty [M.insert "1" 1, M.insert "2" 2]
12:17:25 <lambdabot>   /tmp/1981957038418869639:70:64: Not in scope: `M.empty'/tmp/198195703841886...
12:17:32 <paper_cc1> Eridius: it's easy to check though
12:17:39 <paper_cc1> > (`id` f `id` g)
12:17:40 <Eridius> :kind M
12:17:40 <lambdabot>       The operator `id' [infixl 9] of a section
12:17:40 <lambdabot>          must have lower prec...
12:17:49 <Eridius> paper_cc1: ooh, never knew about that trick
12:17:50 <Eridius> @kind M
12:17:51 <lambdabot> Not in scope: type constructor or class `M'
12:17:54 <Eridius> @kind Data.Map
12:17:55 <lambdabot> Couldn't find qualified module.
12:17:57 <Eridius> ack
12:17:59 <Eridius> @kind M.Map
12:17:59 <lambdabot> * -> * -> *
12:18:05 <Eridius> :i M.empty
12:18:09 <Eridius> @t M.empty
12:18:09 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:18:15 <Eridius> @type M.empty
12:18:15 <lambdabot> forall k a. M.Map k a
12:18:20 <Eridius> huh, wonder what the issue is then?
12:19:56 <idnar> > M.empty
12:19:57 <lambdabot>   /tmp/4274075434421713869:70:32: Not in scope: `M.empty'
12:19:59 <idnar> > Map.empty
12:20:00 <lambdabot>   fromList []
12:20:19 <idnar> > Map.insert
12:20:19 <lambdabot>       Overlapping instances for Show (k -> a -> M.Map k a -> M.Map k a)
12:20:19 <lambdabot>      ...
12:20:28 <idnar> > foldl (flip id) Map.empty [Map.insert "1" 1, Map.insert "2" 2]
12:20:29 <lambdabot>   fromList [("1",1),("2",2)]
12:21:24 <Eridius> huh
12:21:33 <Eridius> so apparently eval uses Map, but the other commands use M
12:21:47 <Eridius> > foldl (flip id) Map.empty [Map.insert "1" 1, Map.insert "2" 2]
12:21:48 <lambdabot>   fromList [("1",1),("2",2)]
12:23:05 <idnar> yeah, it's a mess
12:23:12 <idnar> I don't really know the details
12:36:37 <rovar> why does ($) work in place of () ?  is it purely because of precedence?
12:37:05 <rovar> i.e  f x g b doesn't work but  f x (g b) or f x $ g b does,.
12:37:47 <pumpkin> f x g b will read as (f x g) b, if f takes two arguments
12:37:58 <pumpkin> $ has very low precedence
12:38:06 <pumpkin> so it makes sure that g b gets evaluated
12:38:18 <pumpkin> then f x (g b)
12:39:37 <rovar> so why doesn't it evaluate   f x $ g b as  (f x $) g b ?
12:40:07 <rovar> wouldn't that evaluate as such first because it would have a higher precedence than $ ?
12:41:20 <byorgey> rovar: that isn't how infix operators work
12:41:43 <FunctorSalad> think of $ of extending as far to the right as possible... so: f x $ g b = f x $ (g b) = (f x) (g b)
12:42:00 <FunctorSalad> whereas (f x $) g b = ((f x) g) b
12:42:01 <ehamberg> [["1", "2", "3"], ["4", "5", "6"]] ← how can i convert a matrix of strings like this to a matrix of integers?
12:42:07 <rovar> i know what it does, I'm just concerned about how the parser does it :)
12:42:12 <MyCatVerbs> ehamberg: map (map read).
12:42:19 <MyCatVerbs> ehamberg: you can nest these things. :)
12:42:56 <FunctorSalad> rovar: it's not magic, it's just declared infixr $ 0 (IIRC)
12:43:05 <pumpkin> rovar: no infix operator ever gets taken alone, unless you put it in parentheses
12:43:17 <FunctorSalad> err infixe 0 $
12:43:21 <FunctorSalad> infixr 0 $
12:43:32 <rovar> byorgey: so basically it won't attempt to eval f x $  because $ is an infix operator, not a function
12:43:39 <ManateeLazyCat> How to insert character self if eventKeyName is character (like 'a' 'b' 'c')?
12:43:49 <ManateeLazyCat> I use gtk2hs
12:43:49 <byorgey> rovar: right.
12:44:25 * ManateeLazyCat pasted "source code" at http://paste2.org/get/162675
12:44:31 <ManateeLazyCat> Above is my source code.
12:44:55 <ManateeLazyCat> I don't know how to insert character self if input event is character.
12:45:18 <ManateeLazyCat> I use function `keyPressHandler' handle key press event.
12:45:24 <ManateeLazyCat> Any help? Thanks!
12:45:44 <rovar> insert char into where?
12:45:51 <FunctorSalad> meh associated type synonyms require type annotations everywhere :)
12:45:54 <ManateeLazyCat> rovar: source view buffer
12:46:01 <ManateeLazyCat> sourceView buffer.
12:46:02 <ehamberg> MyCatVerbs: problem is that I get Ambiguous type variable `a' and i don't know how i should specify that i want integers.
12:46:51 <ManateeLazyCat> rovar: In my source code, i want to insert char into sourceView
12:47:17 <ManateeLazyCat> rovar: I want to know have function that insert event value into sourceView buffer.
12:47:41 <rovar> ehamberg:  :: Int
12:48:17 <ehamberg> ooh, :: [[Int]] of course
12:48:19 <ehamberg> d'oh
12:48:25 <FunctorSalad> I have: f :: forall a. Bar a -> Property, then: f ... = (lhs :: a) == (rhs :: a), yet it still invents a fresh type variable a1 for the left hand side? :(
12:48:45 <FunctorSalad> (I have -fglasgow-exts, hence ScopedTypeVariables)
12:49:32 <FunctorSalad> (the actual example is more messy, maybe I minimalized that too much)
12:49:42 <MyCatVerbs> ehamberg: you can usually stick type declarations on almost any term in the expression, since they'll propogate. You can even write map (map (read :: String -> Int)) :)
12:50:08 <ehamberg> MyCatVerbs: oh, very cool.
12:51:55 <MyCatVerbs> In general, it's best to put explicit type declarations on top-level functions. Usually in practice they'll end up propogating well enough to fully determine the types everywhere. Quite handy if you want to make use of type-system hackery that relies on context to work out what behavoir you're after.
12:53:00 <FunctorSalad> MyCatVerbs: I added annotations to nearly every single subterm of my function and I still don't understand this error ;)
12:53:58 <loop0> hello
12:55:06 <FunctorSalad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2312#a2312
12:55:28 <Cale> hello!
12:56:15 <dons> ?yow
12:56:15 <lambdabot> A shapely CATHOLIC SCHOOLGIRL is FIDGETING inside my costume..
12:59:23 <seliopou> FunctorSalad, try getting rid of all the annotations
12:59:34 <seliopou> (even the top-level one)
12:59:56 <vcolin> I'm looking for a Haskell LZW decoder - I found a teasing message at http://www.haskell.org/pipermail/haskell-cafe/2008-July/045108.html but so far have been able to find a package on hackage.  Any ideas?
12:59:57 <paper_cc1> FunctorSalad: maybe it thinks that the types of (dom ..) and (cod ..) are different
13:00:19 <Eridius> yeah, it's probably converting one of the Ob m types to Ob m1 internally
13:00:35 <Eridius> when it joins two subexpressions and says "hey, they're using the same type variable but for different types"
13:01:02 <paper_cc1> FunctorSalad: also you may try adding {-# LANGUAGE ScopedTypeVariables #-}
13:01:26 <paper_cc1> (so that it knows that the 'm' is from the argument)
13:02:16 <Cale> vcolin: Is it important that it be written directly in Haskell? That seems like the sort of thing for which binding to an existing C library would not be so hard.
13:02:37 <FunctorSalad> seliopou: tried it, "ambiguous type variable" error (it can't deduce the types of intermediate values)
13:02:52 <FunctorSalad> paper_cc1:  I have -fglasgow-exts, hence ScopedTypeVariables I think
13:02:54 <MyCatVerbs> FunctorSalad: yes, but you're doing something too clever for your own good. :P
13:03:15 <seliopou> I've come across stuff like this before... I forgot how to get around it...
13:03:22 <Eridius> FunctorSalad: what are the types of cod and dom?
13:03:23 <FunctorSalad> MyCatVerbs: I already dumbed it down by doing category theory without static composeability checking ;)
13:03:39 <FunctorSalad> (that seems to be a lost cause)
13:04:24 <FunctorSalad> Eridius: one second
13:04:45 * paper_cc1 rereads the specification for ScopedTypeVariables
13:05:07 <vcolin> Cale: I guess not, just that I have never tried creating such a binding :)
13:07:35 <FunctorSalad> Eridius: ok, think I added all the relevant items now http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2312#a2314
13:08:09 <Eridius> what's the definition of ===?
13:08:30 <FunctorSalad> Eridius: it's sort of my own Eq class
13:08:50 <FunctorSalad> (so it's a class method of type a -> a -> Bool)
13:10:30 <Eridius> hrm, looks like I can't help. sorry
13:10:36 * Eridius doesn't know enough about all this type wankery ;)
13:11:02 <Eridius> though I do think the explicit type annotations are lying to you (i.e. I think ghc is converting the type variables when it thinks various expressions don't actually share the same type)
13:12:28 <Eridius> for example, I don't think know anything about type families
13:13:44 <FunctorSalad> Eridius: it's not really wankery, formalising category theory tends to break every typing scheme I tried at some point ;)
13:14:03 <Eridius> heh
13:14:11 <FunctorSalad> so I'm just trying to get it to work somehow
13:14:20 <FunctorSalad> (like I said I already weakened the static stuff)
13:14:29 <bastl1> hi im learning to use the state monad to do tree-calculations. I want to add an int-id to every node of a tree. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2315 is my first attempt. recursion works, but how can i feed the outcome of the recursive call on one child to its neighbor? Ot clearer, how can i recover the Int-State im in at an arbitraty depth of recursion?
13:14:41 <bastl1> oops much text ...
13:15:22 <paper_cc1> bastl1: use a fold instead of a map
13:15:41 <bastl1> paper_cc1: ah, that makes sense ...
13:16:07 <bastl1> so the general approach is ok?
13:18:27 <paper_cc1> (oh, sorry... you'd use mapAccumL for a non-monadic version)
13:18:50 <paper_cc1> bastl1: but where the state is actually used?
13:20:12 <paper_cc1> @ty mapM
13:20:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:20:17 <bastl1> atm never, i thought i use the (last state)+1 to put it in the tuple of the current node. thats why i was confused
13:20:53 <bastl1> so with mapAccumL i could do it without the state-monad ?
13:21:08 <paper_cc1> yes
13:21:36 <paper_cc1> but the State-ful code (with the least unallocated index) would do it too
13:22:36 <FunctorSalad> bastl1: posted a suggestion :)
13:22:53 <paper_cc1> (I don't know how to do a BFS-style numbering cleanly though)
13:23:25 <FunctorSalad> bastl1: (and a correction of my suggestion now)
13:23:32 <paper_cc1> @ty mapAccumL
13:23:34 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
13:23:49 <bastl1> Functor: thanks, that looks like from a good tutor. (it's on my level :-) )
13:23:55 <wli> paper_cc1: Use Data.Sequence instead of a stack.
13:24:06 <bastl1> so get and put set/recover the current Int-State, right?
13:24:13 <FunctorSalad> bastl1: the nice thing about using State here is that you don't need to compute the sum manually
13:24:17 <paper_cc1> @ty get
13:24:19 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:24:20 <FunctorSalad> bastl1: yes
13:24:23 <paper_cc1> @ty set
13:24:24 <lambdabot> Not in scope: `set'
13:24:27 <paper_cc1> oh
13:24:29 <paper_cc1> @ty put
13:24:31 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
13:24:49 <paper_cc1> wli: Data.Sequence is a queue?
13:25:02 <wli> paper_cc1: Of sorts, yes.
13:26:49 * paper_cc1 read the docs
13:26:58 <paper_cc1> maybe more like a deque
13:28:20 <bastl1> FunctorSalad: My hero of the day. exactly what i was imagining, just didnt know about get and put.
13:30:39 <wli> paper_cc1: You can use it with MonadWriter, too, if needed elsewhere.
13:30:55 <pumpkin> we need a MonadTwitter
13:31:03 <paper_cc1> > let numberList' = mapAccumL (\n xs -> let ns = numberList' xs in ((n, snd ns), fst ns)); numberList = numberList' 0 in numberList [['a', 'b', 'c'], 'd', ['e', ['f', 'g'], 'h']]
13:31:05 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
13:31:15 <FunctorSalad> bastl1: always happy to hear that I actually teached something understandably ;)
13:31:33 <leimy> A twitter monad?
13:31:41 <leimy> Isn't that just like a Writer?
13:31:48 <FunctorSalad> hmm
13:31:59 <leimy> Or a ReaderT Writer? :-)
13:32:06 <leimy> for the Socket to the Twitter service?
13:32:27 <FunctorSalad> isn't every monad a Writer [AnyIO]?
13:32:43 <leimy> I don't think the identity monad is a Writer
13:33:14 <FunctorSalad> I mean that should be strong enough to encode every monad in it?
13:33:33 <leimy> I don't know that I'd be willing to say that :-)
13:34:10 <paper_cc1> IO is just as powerful as to encode the CPU inside it =)
13:35:11 <paper_cc1> pumpkin: what's a twitter&
13:35:15 <paper_cc1> s/&/?/
13:35:26 <pumpkin> http://twitter.com/home just being silly :P
13:35:35 <leimy> I'm not sure why I can say "flip id"
13:35:55 <leimy> since flip takes a function of 2 parameters and id is a function of 1
13:36:02 <leimy> perhaps I'm not really getting this after all :-)
13:36:15 <leimy> :t flip id
13:36:16 <conal> leimy: hint: sometimes id has two arguments.
13:36:16 <lambdabot> forall b c. b -> (b -> c) -> c
13:36:26 <FunctorSalad> > id f x
13:36:27 <lambdabot>   Add a type signature
13:36:27 <leimy> :t id
13:36:28 <lambdabot> forall a. a -> a
13:36:37 <FunctorSalad> > id f x :: Expr
13:36:38 <lambdabot>   f x
13:36:41 <leimy> > id (\x -> x + 1) 1
13:36:42 <lambdabot>   2
13:36:46 <leimy> argh
13:36:47 <leimy> got it :-)
13:36:54 <conal> :)
13:37:21 <leimy> :t id (\x -> x + 1)
13:37:22 <lambdabot> forall a. (Num a) => a -> a
13:37:33 <leimy> :t flip
13:37:35 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:37:38 <leimy> :t flip id
13:37:39 <lambdabot> forall b c. b -> (b -> c) -> c
13:38:03 <leimy> :t flip ($)
13:38:04 <lambdabot> forall a b. a -> (a -> b) -> b
13:38:18 <leimy> :t  ($)
13:38:19 <lambdabot> forall a b. (a -> b) -> a -> b
13:41:29 <leimy> :t (<**>
13:41:31 <lambdabot> parse error (possibly incorrect indentation)
13:41:35 <leimy> :t (<**>)
13:41:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:41:45 <leimy> ;t flip (<*>)
13:41:47 <pumpkin> ManateeLazyCat: where are you from?
13:41:58 <leimy> :t flip (<*>)
13:41:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:42:03 <ManateeLazyCat> pumpkin: Interesting?
13:42:13 <pumpkin> just curious :)
13:42:25 <ManateeLazyCat> pumpkin: China. :)
13:42:30 <J-roen> Hi. I have an assignment to make. One sentence is: "Assemble a monad from the Reader and SplitReader monads or monad transformers." How can this actually be done, since Reader and SplitReader are no classes? Thanks.
13:42:42 <pumpkin> ah, cool
13:42:49 * ManateeLazyCat pasted "my fix" at http://paste2.org/get/162714
13:43:02 <paper_cc1> @index SplitReader
13:43:03 <lambdabot> bzzt
13:43:04 <ManateeLazyCat> Answer my problem, just modified keyPressHandler, now fix.
13:46:19 <waern_> http://www.nabble.com/-scala--URGENT%3A-Please-read-if-you-have-any-information-about-Tony-Morris-td22462911.html
13:46:22 <paper_cc1> J-roen: SplitReader?
13:46:49 <pumpkin> ???
13:46:56 <pumpkin> oh no
13:47:09 <J-roen> paper_cc1: Yes, I'm sorry, that's a custom variant of Reader.
13:48:02 <paper_cc1> then, (ReaderT (SplitReader foo) bar) is a monad, isn't it? (if SplitReader :: * -> * -> *)
13:48:16 <mattyp> can anyone help me with a bit od haskell i need to write for uni?
13:48:28 <pumpkin> waern_: I really hope it's a prank of some sort :/
13:48:51 <J-roen> paper_cc1: I will take a look. Thanks.
13:49:13 <waern_> pumpkin: probably not
13:49:17 <mattyp> i need to write a recursive listMarks function
13:49:18 <pumpkin> :(
13:50:23 <waern_> it's very recent also, so australian people who live near Tony might want to help out
13:50:33 <pumpkin> yeah
13:50:52 <pumpkin> maybe post on cafe?
13:51:59 <waern_> oh, the police is on their way to his place now, it says in the last mail
13:52:04 <BONUS> what do you mean by listMarks
13:52:15 <pumpkin> :/
13:52:19 <BONUS> re: that guy ... hope everything turns out ok
13:52:25 <pumpkin> yeah
13:53:04 <FunctorSalad> sounds like he's doing it out of physical pain rather than depression?
13:53:56 <pumpkin> it's hard to say
13:57:08 <Fredrik_> @pl \(i, r) -> r == max
13:57:08 <lambdabot> (max ==) . snd
14:00:19 <solidsnack> This happened at 18:42 UTC ?
14:00:49 <Heffalump> I think so
14:03:05 <Eridius> wow
14:03:11 <intractable> so I have newtype HM a = HM { unHM :: StateT MyState IO a } and am trying to write a MonadState instance for it, but failing miserably :P anyone feel like helping me out?
14:03:52 <solidsnack> intractable: Please pastebin what you have.
14:04:07 <travisbrady> is there some way when defining an instance of Show for me to only define it for one case and let the compiler derive the rest?
14:04:13 <Heffalump> you don't want to just use generalized newtype deriving?
14:04:56 <intractable> Heffalump: I do, but want the practice.
14:04:57 <Heffalump> travisbrady: well, you could use overlapping instances
14:04:57 <intractable> solidsnack: i have nothing for get nor put, because everything i've tried fails. ;)
14:04:57 <centrinia> Wow, Tony Morris' site is not responding. :(
14:04:57 <Eridius> centrinia: probably being DDOS'd
14:04:57 <solidsnack> centrinia: Could you move to #haskell-blah ?
14:05:25 <centrinia> Sorry.
14:05:37 <solidsnack> intractable: It's been awhile since I've written one of those things.
14:05:50 <solidsnack> centrinia: A yes would be enough -- nothing to be sorry about.
14:06:05 <intractable> solidsnack: -roen (n=user@62.234.140.52) has quit:
14:06:05 <intractable> ERC> solidsnack: whoops, http://haskell.pastebin.com/d16ba0366
14:06:17 <solidsnack> hahaha
14:06:19 <intractable> hehe
14:06:27 <intractable> stupid emacs. :)
14:06:42 <Eridius> intractable: shouldn't it just be as simple as composing get/put on unHM?
14:06:53 <Eridius> get = get . unHM
14:07:27 <Eridius> oh wait, no, I'm thinking about it wrong (won't work on put)
14:08:02 <intractable> Eridius: won't work on get either (type error)
14:08:19 <intractable> Eridius: but that's the first thing i'd tried (I think)
14:08:51 <intractable> and since this is not itself a transformer i can't lift...maybe that's the solution?
14:09:05 <intractable> the question is...how does generalized newtype deriving do it for this guy, and how would I found out? because that works somehow ;)
14:09:49 <Fredrik_> @pl \(_, w) (_, v) -> compare w v
14:09:50 <lambdabot> (. snd) . compare . snd
14:10:07 <Eridius> what's St?
14:10:07 <Heffalump> intractable: it cheats
14:10:18 <intractable> Eridius: just some random state datatype
14:10:28 <Fredrik_> @pl \(_, w) (_, v) -> w `compare` v
14:10:28 <lambdabot> (. snd) . compare . snd
14:10:29 <Heffalump> intractable: it just applies coercions to the existing instance
14:10:34 <intractable> Heffalump: Oh...
14:11:07 <intractable> Heffalump: so maybe there's not a way I can do this without having HM be parameterized by an inner monad so I can lift get/put
14:11:34 <Heffalump> my immediate reaction is that there shouldn't be any reason you can't write it
14:11:39 <Heffalump> I'll look at your pastebin
14:11:43 <wli> Hmm. I can enumerate values in tree nodes in bfs order but not tag the nodes.
14:11:46 <FunctorSalad> meh, even asTypeOf doesn't properly fix types
14:12:00 <solidsnack> Heffalump: Can you explain what you mean by, "it just applies coercions" ?
14:12:02 <wli> That is, retaining tree structure.
14:12:10 <intractable> Heffalump: thanks; i'm hoping i'm missing something silly and obvious, i'm still not very great with monad transformers
14:12:23 <wli> e.g. bfs :: BinaryTree t -> BinaryTree (Integer, t)
14:12:24 <Heffalump> solidsnack: it does something internal that's equivalent to dumping unsafeCoerce everywhere (AIUI)
14:12:34 <solidsnack> ah
14:12:37 <FunctorSalad> let x :: Ob m; x = ... in ... foo `asTypeOf` x ...               Error: Couldn't match expected type `Ob m' against inferred type `Ob m1'
14:12:39 <Heffalump> oh, there's not much in your paste :-)
14:12:44 <bastl1> my executable says "Maybe.fromJust: Nothing" how can i track the error down?
14:12:45 <intractable> Heffalump: right :)
14:12:47 <Heffalump> you should follow the types.
14:12:51 <Heffalump> What's the type of get?
14:13:19 <FunctorSalad> (the error is "in second argument of asTypeOf", directly contradicting the type sig of x.)
14:13:20 <intractable> get :: (MonadState s m) => m s
14:13:31 <Heffalump> ok, so the first thing is that your instance declaration is wrong
14:13:41 <wli> I can only smoke out bfs :: BinaryTree t -> [t]
14:13:45 <intractable> oh =)
14:13:47 <Heffalump> because it says MonadState s, but HM can only be a MonadState St
14:14:20 <Heffalump> coming back to get, what's its type, specialised for HM?
14:14:39 <Eridius> hrm, with that definition of HM you can't even have a derived MonadState
14:14:42 <Fredrik_> @unpl (. snd) . compare . snd
14:14:42 <lambdabot> (\ d j -> compare (snd d) (snd j))
14:14:43 <jenner> guys, does uncurry only produce functions for pairs?
14:14:48 <intractable> get :: HM St
14:14:54 <Eridius> Can't make a derived instance of `MonadState HM' (even with cunning newtype deriving: `MonadState' does not have arity 1)
14:15:03 <Heffalump> ok. Does that give you any ideas about how to write it?
14:15:09 <Eridius> oh wait, I should type MonadState a, I guess
14:15:09 <intractable> Eridius: hrm, worked for me when I tried it (deriving MonadState St)
14:15:15 <Heffalump> Eridius: deriving (MonadState St)
14:15:17 <Eridius> yeah I dropped the St bit
14:15:18 <FunctorSalad> Eridius: I like that error message :)
14:15:20 <Eridius> that works
14:15:22 <Eridius> FunctorSalad: I did too
14:15:25 <Eridius> but I didn't understand it ;)
14:15:31 <intractable> Heffalump: hmm, maybe, let me think about it for a sec
14:15:34 <Heffalump> arity 1 = takes one argument
14:15:51 <Eridius> Heffalump: yeah I understand it in retrospect
14:16:15 <Eridius> I wonder how GeneralizedNewtypeDeriving works when you can't declare an instance for (MonadState St) HM by hand? Does the derived (MonadState St) instance cause any problems?
14:16:17 <FunctorSalad> almost as good as the {-# RULES "hammeredLookup" lookup = intLookup #-} or so in the user's guide
14:16:23 <intractable> Heffalump: will I have to provide a type context in the instance?
14:16:37 <Heffalump> Eridius: if you really couldn't write it by hand, then the derived one would be bad
14:16:43 <Heffalump> but I'm not sure that there are any cases where that's true
14:16:54 <Eridius> you can't declare an instance for (MonadState St) HM, but you can derive one
14:18:10 <Heffalump> who says you can't declare it?
14:18:37 <Eridius> oh hrm, maybe it's because I declared St as a type synonym instead of a separate datatype
14:18:49 <Eridius> ah hah, that's it
14:18:53 <intractable> Heffalump: yeah, I now have instance (MonadState St) HM where ... but honestly, I'm still not seeing the trick here.
14:19:02 <Eridius> changing it from type St = () to data St = St fixes the illegality
14:19:07 <Eridius> however, that means the derived instance was bogus ;)
14:19:19 <Eridius> well, maybe it actually derived an instance for MonadState ()
14:19:42 <Heffalump> Eridius: only "bogus" in the sense that it gave it to you without you turning on the extensions you'd need to write it by hand.
14:19:46 <Heffalump> and yes, it probably did
14:19:51 <intractable> Heffalump: the only way I have to get at the StateT is via unHM
14:20:23 <Heffalump> intractable: you know the type of get. It's of type HM St. What form must a value of type HM a take, syntactically?
14:21:16 <wli> Hmm. Not sure how to suspend the computation of the updated parent until its children are done, or how to return its children to it.
14:21:38 <intractable> Heffalump: do s <- get ; return s ?
14:21:56 <Heffalump> you're jumping ahead of me, and incorrectly :-)
14:21:59 <Eridius> heh
14:22:03 <intractable> Heffalump: heh.
14:22:08 <Heffalump> how do you construct a value of type HM?
14:22:15 <Heffalump> HM a for some a, that is
14:22:24 <Heffalump> ignore the whole monad thing
14:22:30 <jeffwheeler> Is there any way to see what packages depend on a specific package, on Hackage?
14:22:46 <intractable> Heffalump: I write a function that takes no arguments that yields that type
14:22:49 <intractable> aka return a
14:22:58 <Heffalump> ignore the whole monad thing
14:23:30 <intractable> use the HM constructor
14:23:35 <Heffalump> right.
14:23:54 <Heffalump> ok, so lets suppose we do use the HM constructor.
14:24:12 <Heffalump> What type should its argument have, to get an HM St as the result?
14:24:34 <intractable> StateT St m a
14:24:52 <Heffalump> more precisely
14:25:17 <Heffalump> there aren't any type variables in HM St, so you wouldn't expect any in its argument since there are no existentials involved here
14:26:20 <intractable> hmm, i'm not sure, are you saying to unwrap the definition of StateT?
14:26:35 <Heffalump> no, you can answer this just from the definition of the HM type
14:26:37 <intractable> StateT St IO St
14:26:40 <Heffalump> right.
14:26:53 <Heffalump> Now, can you think of some value of that type?
14:27:44 <intractable> ok, i think i'm getting there now. i was thinking there was something odd going on with the way I was declaring the instance and/or thinking about the transformer. gimme a sec ;)
14:28:55 <intractable> Heffalump: StateT St IO St is equivalent to St -> IO (St, St)?
14:29:20 <Heffalump> don't go that far
14:29:25 <intractable> hmm, ok.
14:29:33 <Heffalump> consider that the StateT representation is hidden from you, even if it's not
14:30:29 <intractable> so to think of a value of StateT St IO St ... but without looking at the type constructor params for StateT?
14:31:54 <intractable> Heffalump: well unHM applied to something of HM St gets me one of those, but that doesn't really help :P
14:32:36 <Heffalump> don't use anything to do with HM :-)
14:32:50 <intractable> :t return
14:32:51 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:33:21 <intractable> Heffalump: not sure how to create a value of StateT St IO St without at least looking at the type constructor definition
14:33:41 <Heffalump> I've run out of subtle hints, so I'll just give you the answer :-): get
14:33:56 <intractable> ugh
14:36:05 <intractable> Heffalump: and get does what for constructing a value of StateT St IO St? :(
14:36:56 <Heffalump> you don't need to know
14:37:31 <Heffalump> [the answer is something like StateT (\st -> return (st, st)) ]
14:38:24 <intractable> Heffalump: yeah, i understand that part. I just mean...how do I apply get in this context?
14:38:30 <Heffalump> intractable: you just use it.
14:38:49 <Heffalump> get :: StateT St IO St, so HM get :: HM St
14:38:57 <Heffalump> so get = HM get
14:39:28 <Heffalump> looks confusing because it seems like ill-founded recursion
14:39:38 <intractable> yeah, *groan*
14:39:40 <Heffalump> but it's not because the two 'get's are different types
14:39:41 <intractable> i get it now, I think.
14:39:50 <intractable> yeah, one on the StateT's MonadState instance and the one i'm defining
14:39:54 <intractable> correct?
14:40:21 <intractable> i was just making all kinds of failed composition attempts ;) thanks.
14:40:38 <Heffalump> intractable: correct. Now try put :-)
14:48:33 <ehird> http://www.nabble.com/-scala--URGENT%3A-Please-read-if-you-have-any-information-about-Tony-Morris-to22462911.html <-- oh my god...
14:48:47 <ricky_clarkson> Apologies if this is a repeat.  Tony Morris, dibblego, is missing and has left a "goodbye world" note in #scala, #functionaljava and some emails.  Police have checked at his house and he is missing.  If anyone has any information about where he might ride his motorbike to please join #scala and let us know.
14:50:11 <Axman6> oh dear :|
14:51:44 <Eridius> this discussion is already in #haskell-blah
14:53:07 <ehird> Eridius: yeah, keep fighting the good fight of keeping the channels in order no matter what...
14:53:34 <Eridius> ehird: are you offended that I pointed out that there's a discussion in #haskell-blah on this subject?
14:53:44 <ehird> no, it sounded like you were trying to say to keep it in there
14:53:53 <ehird> I apologize if that was not the intent.
14:53:58 <intractable> Heffalump: double-duh.  it clicked. thanks muchly for your help =)
14:54:09 <intractable> Heffalump: and now i can go back to using generalizednewtypederiving ;)
14:54:32 <Eridius> ehird: well it sort of was. Announcing here is fine, but instead of starting a second discussion, anybody who wants to talk about it should go to #haskell-blah
14:54:42 <ehird> OK; sorry.
14:54:55 <aluink> i have an Int and want to convert to a Double, how can I do that?
14:55:26 <Eridius> @type fromIntegral
14:55:27 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:56:05 <aluink> Eridius: and the what?
14:56:25 <monochrom> @quote fromIntegral
14:56:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
14:56:26 <Heffalump> aluink: just use that function.
14:56:27 <Eridius> aluink: parse error
14:56:46 <travisbrady_> aluink: let b = 9::Int; let c = (fromIntegral b)::Double
15:02:58 * aluink just used haskell to calculate the probability of scores for rolling five 6d
15:03:03 <aluink> that was fun1
15:03:11 <Eridius> did you use the monte-carlo package? ;)
15:03:22 <aluink> nope, brute force ;)
15:03:35 <jpcooper> surely paper is much easier?
15:03:37 <jpcooper> :p
15:04:05 <evident> hey everybody. I am having a little problem turning a list of char-lists into a long string: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2321#a2321
15:04:17 <evident> can anybody help me solve that problem?
15:04:24 <aluink> jpcooper: with paper the problem becomes how to define a five-tuple scoring X
15:04:27 <Axman6> long string?
15:04:29 <Heffalump> @type concat
15:04:30 <lambdabot> forall a. [[a]] -> [a]
15:04:51 <aluink> jpcooper: list comprension made that trivial
15:05:12 <jpcooper> aluink, a five-tuple?
15:05:23 <evident> ahh thanks
15:05:26 <jpcooper> aah, are you trying to find the probability of certain sums?
15:05:49 <evident> concat - exactly the function i was looking for
15:08:42 <Gracenotes> > concatMap (join replicate) [1..]
15:08:44 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
15:09:21 <m0nkfish> cool
15:09:55 <aluink> jpcooper: yes, (3,3,3,3,3) being a five-tuple that adds up to 15 ;)
15:10:13 <aluink> let set = [1,2,3,4,5,6]
15:10:14 <Gracenotes> I'm not sure you can do that shorter in too many other programming languages :)
15:10:17 <jpcooper> yeah then I guess it's simpler to use Haskell :)
15:10:23 <aluink> > let set = [1,2,3,4,5,6]
15:10:25 <lambdabot>   <no location info>: parse error on input `;'
15:10:43 <Gracenotes> it's useless, the [1,2,2,3,3,3..], but Haskell's rather succinct to it. Maybe Perl can beat it, dunno.
15:10:53 <aluink> how can i set a value to be used later with lambdabot?
15:11:04 <Gracenotes> @help let
15:11:05 <lambdabot> let <x> = <e>. Add a binding
15:11:25 <aluink> yes, so why did that command just fail up there?
15:11:50 <Gracenotes> commands are immediately preceded with @
15:11:59 <Gracenotes> @elite You too can add a let binding
15:11:59 <aluink> oh
15:11:59 <lambdabot> YOU +o0 can aDD a lE7 8inDinG
15:12:21 <aluink> @let set = [1,2,3,4,5,6]
15:12:23 <lambdabot>  Defined.
15:12:43 <aluink> @let f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) :: Double) / (6 ** 5)
15:12:44 <lambdabot>  <local>:3:124:
15:12:44 <lambdabot>      Ambiguous occurrence `/'
15:12:44 <lambdabot>      It could refer to either `...
15:13:19 <Gracenotes> aluink: you can do local let expressions, you know :)
15:13:21 <aluink> uhh? that worked in ghci...why not here?
15:13:30 <aluink> yes, i'm sharing my function
15:13:46 <Gracenotes> it's not always a good idea to clog up lambdabot's brain with functions and values
15:14:05 <aluink> ok then
15:14:17 <Gracenotes> > let set = [1,1,2,2,3,4,5,5,6,7] in nub set -- like so :)
15:14:18 <lambdabot>   [1,2,3,4,5,6,7]
15:14:42 <Gracenotes> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) :: Double) / (6 ** 5) in f 3
15:14:44 <lambdabot>       Ambiguous occurrence `/'
15:14:44 <lambdabot>      It could refer to either `Prelude./', imp...
15:14:49 <Gracenotes> @type (/)
15:14:50 <lambdabot>     Ambiguous occurrence `/'
15:14:50 <lambdabot>     It could refer to either `L./', defined at <local>:1:2
15:14:50 <lambdabot>                           or `Prelude./', imported from Prelude
15:15:00 <aluink> oh, i see
15:15:11 <Gracenotes> someone's been adding too many @lets, it seems
15:15:30 <aluink> @help elite
15:15:31 <lambdabot> elite <phrase>. Translate English to elitespeak
15:15:33 <Gracenotes> @undefine /
15:15:42 <Gracenotes> @type (/)
15:15:43 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:15:53 <Gracenotes> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) :: Double) / (6 ** 5) in f 3
15:15:54 <lambdabot>   0.0
15:16:05 <aluink> you can't roll 5 dice and get a 3 ;)
15:16:26 <Gracenotes> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) :: CReal) / (6 ** 5) in 5*3
15:16:28 <lambdabot>   15
15:16:57 <Gracenotes> oops
15:17:03 <aluink> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) :: Double) / (6 ** 5) in f 15
15:17:05 <lambdabot>   8.371913580246913e-2
15:17:40 <aluink> anyhow, that's how i did it
15:17:57 <aluink> pretty straightforward
15:18:17 <aluink> anyone see any possible improvements?
15:18:32 <Gracenotes> it looks great
15:18:41 <Gracenotes> you can use a CReal for improved accuracy
15:18:50 <Gracenotes> > let set = [1,2,3,4,5,6]; f z = ((/) `on` fromIntegral) (length [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z]) (6 ^ 5) in (f 15 :: CReal)
15:18:52 <lambdabot>   0.0837191358024691358024691358024691358025
15:19:22 <Gracenotes> "((/) `on` fromIntegral) a b" is the same as "fromIntegral a / fromIntegral b"
15:19:33 <aluink> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z])) / (6 ** 5) in (f 17 :: CReal)
15:19:34 <lambdabot>   0.1003086419753086419753086419753086419753
15:19:42 <aluink> > let set = [1,2,3,4,5,6]; f z = ((fromIntegral . length $ [(a,b,c,d,e) | a <- set, b <-set, c <- set, d <-set, e <-set, (a+b+c+d+e) == z])) / (6 ** 5) in (f 5 :: CReal)
15:19:44 <lambdabot>   0.000128600823045267489711934156378600823
15:19:48 <aluink> alright, cool!
15:19:58 <Gracenotes> that comes with the numeric package
15:19:59 <aluink> yeah, i wasn't liking the exponential notation
15:20:01 <Gracenotes> @hackage numeric
15:20:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numeric
15:20:11 <Gracenotes> uhm.
15:20:27 <aluink> numerical types are something that always annoys me, in most languages
15:20:27 <Gracenotes> @hackage numbers
15:20:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
15:20:36 <aluink> hmmm, that's fubar ;)
15:20:42 <tromp_> that's not a very smart way to compute it
15:20:47 <Gracenotes> yeah, forgot the package name
15:21:11 <aluink> so why did lambdabot still return something? shouldn't it have complained?
15:21:23 <Gracenotes> it just appends what you give it to the end of the URL
15:21:34 <aluink> ahh
15:21:47 <aluink> alright, well this was fun, but i need some supper
15:21:50 <aluink> thanks!
15:21:51 <Gracenotes> but, yeah, you can do some combinatorics tricks and quickly solve the problem mathematically, instead of trying every single combination
15:22:02 <Gracenotes> okay, *waves* :)
15:22:15 <aluink> yeah, i know, i did plenty of that stuff in my Probability Theory class last semester
15:22:29 <aluink> i was just sitting here rolling dice, seeing how high of a score i could get
15:22:54 <aluink> and i was curious about the probabilities, and instead of doing all that combinatorics, i decided to ask Haskell ;)
15:23:16 <Gracenotes> yeah
15:26:54 <eu-prleu-peupeu1> anyone wants to join me in developing a 3D engine on top of reactive ?
15:32:57 <m4nic> maybe a strange question, but how would one split a string at ";"
15:34:10 <FalconNL> http://hackage.haskell.org/packages/archive/utility-ht/0.0.4/doc/html/Data-List-HT.html
15:34:28 <FalconNL> try chop, segmentAfter or something similar depending on your needs
15:34:38 <monochrom> Nice.
15:34:51 <m4nic> thx
15:34:59 <FalconNL> Does anyone happen to know if there's a library function to convert 4 Chars (i.e. a DWORD) to an Int?
15:35:40 <monochrom> fromIntegral can convert Word32 to Int.
15:35:55 <Eridius> FalconNL: maybe you shouldn't have 4 Chars in the first place?
15:36:08 <rjblack> java question for java experts...
15:36:22 <FalconNL> I'm working on a PNG input/output library. The PNG file format makes heavy use of them
15:36:28 <Eridius> so use ByteString
15:36:53 <monochrom> Data.Binary has tools for converting octet streams into real types.
15:36:54 <Eridius> Char doesn't have a defined byte encoding (though internally it's UCS-4)
15:36:58 <eu-prleu-peupeu1> anyone here would like to develop a 3D engine using reactive ?
15:37:57 <rjblack> anyone know how to write a java program in which you have to have a window.alert for a condition??
15:38:11 <eu-prleu-peupeu1> java ?!
15:38:17 <rjblack> such as if one number is larger than the other then window.alert
15:38:27 <rjblack> yeah...im a noob tryin to do some damn homework
15:38:31 <FalconNL> rjblack, I think you're in the wrong channel
15:38:35 <rjblack> where do i go
15:38:37 <eu-prleu-peupeu1> rjblack: try #java
15:38:42 <FalconNL> This is the IRC room for the Haskell programming language
15:38:48 <monochrom> #java, ##java, ###java, ...
15:39:00 <bd_> #############################....fix
15:39:02 <Axman6> why do people always end up in here asking programming questions? :\
15:39:20 <eu-prleu-peupeu1> because here is where all the l33tz join
15:39:26 <FalconNL> Perhaps the reputation as a friendly community?
15:39:28 <rjblack> does anyone just happen to know the answer?
15:39:34 <Saizan>  /topic + #users
15:39:42 <realtime> oh my..
15:39:45 <rjblack> haha
15:39:50 <ajones> Axman6: because this is one of the few places where you don't get "RTFM" or "here's your solution <insert code to delete HDD>"
15:40:32 <ajones> rjblack: window.alert in what Java framework? Or are you talking about JavaScript?
15:40:35 <monochrom> if (1>0) { do whatever you want }
15:40:44 <rjblack> script
15:40:54 <Heffalump> if anyone is going to help rjblack, please take it to messages
15:41:03 <rjblack> thats cool with me
15:41:29 <eu-prleu-peupeu1> rjblack: java != javascript != haskell
15:41:41 <eu-prleu-peupeu1> or should i have used /= :P
15:42:07 <Axman6> eu-prleu-peupeu1: btw, i really like your haskell logo entry. thinking i may out that at the top of my list :)
15:42:12 <FalconNL> length (nub [Java, JavaScript, Haskell]) == 3 :)
15:42:24 <eu-prleu-peupeu1> ahah
15:42:27 <eu-prleu-peupeu1> thanks Axman6
15:42:39 <eu-prleu-peupeu1> it was only a joke
15:42:44 <Eridius> what's the entry?
15:43:08 <monochrom> Does it consist of a machine defeating a human?
15:43:36 <BMeph> FalconNL: If you finish that library, would you put it on the Rosetta Code site? :)
15:43:57 <FalconNL> what's the rosetta code site? I was planning on putting it on hackage
15:44:06 <Axman6> Eridius: search for "The lightbulb lady" on http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
15:44:18 <eu-prleu-peupeu1> is it possible to fmap a function to () ?
15:44:23 <eu-prleu-peupeu1> fmap f () ?
15:44:39 <eu-prleu-peupeu1> is () a functor ?
15:44:40 <eu-prleu-peupeu1> :/
15:44:43 <Eridius> I doubt () is an instance of Functor
15:44:44 <Axman6> nope
15:44:55 <eu-prleu-peupeu1> hmm
15:45:02 <eu-prleu-peupeu1> how do i transform a () into something else ?
15:45:03 <BONUS> its not an instance of functor but it could be in some other language i think
15:45:17 <Gracenotes> newtype Unit a = Unit ()
15:45:20 <Gracenotes> ^ you can make this a Functor
15:45:20 <BONUS> fmap _ () = (), i think it holds the laws
15:45:21 <BONUS> yeah
15:45:33 <Gracenotes> the only problem is that () doesn't have a kind of * -> *
15:45:56 <eu-prleu-peupeu1> oh ok
15:45:57 <Gracenotes> (at least.)
15:46:55 <Gracenotes> I'm not sure if kinds have the same semantics as types, in terms of whether '* -> *'  >  '* -> (* -> *)', or something like that
15:46:56 <Axman6> @kind ()
15:46:58 <lambdabot> *
15:47:09 <Eridius> Gracenotes: Functor doesn't strictly require that
15:47:10 <Gracenotes> doubt it
15:47:37 <Eridius> it seems like you could make an instance for () or for any other class of kind * with one concrete constructor
15:47:40 <Eridius> that still follows the laws
15:47:49 <Eridius> e.g. turn fmap into id
15:48:00 <Gracenotes> what do you mean by 'concrete constructor'?
15:48:02 <Eridius> err, not id, but \_ b -> b
15:48:19 <Eridius> Gracenotes: remove the term "concrete"? I dunno how you'd have an abstract one
15:48:22 <Axman6> @src Functor
15:48:22 <monochrom> That's what newtype Unit a = Unit () does
15:48:22 <lambdabot> class  Functor f  where
15:48:22 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:48:24 <Eridius> I mean like data Foo = Foo
15:49:40 <eu-prleu-peupeu1> i really like reactive
15:50:21 <eu-prleu-peupeu1> i think it is kinda of easy once you understand the paradigm... now i just need to understand the paradigm, maybe if there were more examples of it
15:52:26 <Gracenotes> Eridius: here we go.. http://codepad.org/TRgUuohX
15:52:50 <Gracenotes> :)
15:52:59 <Gracenotes> eu-prleu-peupeu1: yeah, I know what you mean
15:53:29 <Gracenotes> I don't get it much at all. There's theory, but looking through the source you can't tell what's important and what's not
15:53:48 <Gracenotes> Eridius: you can also make a monad instance for it, by the way
15:54:01 <Eridius> hah
15:54:08 <eu-prleu-peupeu1> im trying out some easy stuff with it
15:54:09 <eu-prleu-peupeu1> :/
15:54:38 <Gracenotes> applicative, comonad probably..
15:55:05 * Eridius still doesn't know what a comonad is
15:55:14 <Gracenotes> eu-prleu-peupeu1: if you've gotten any code working, could you paste it? :)
15:55:21 <eu-prleu-peupeu1> yes i will
15:55:31 <eu-prleu-peupeu1> let me just finish this up...
15:55:34 <eu-prleu-peupeu1> eh
15:56:26 <Gracenotes> Eridius: comonads don't seem to be as important, at least for programming
15:56:38 <Gracenotes> from hackage, http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad.html
15:57:36 <Eridius> Gracenotes: that doesn't say what it *is*, it just says what the API is
15:58:42 <FalconNL> Ok, I'm now trying to get the hang of Bytestrings. You can get Word8's from a ByteString, but I haven't found a way yet to combine those Word8's into a Word32 or, alternatively, to get a Word32 directly from the ByteString. Is there an existing way to do this or am I just going about it all wrong?
15:59:09 <plumpkin> FalconNL: Data.Binary.Get
15:59:33 <FunctorSalad> any good reason why you can't have fundeps involving the associated typesyns being declared in the class?
15:59:57 <FunctorSalad> (it's causing major mayhem for me right now)
16:00:38 <FunctorSalad> I know I could use associated datatypes instead, but I wan't the associated things to be existing types
16:00:47 <Gracenotes> http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Comonads
16:00:49 <FunctorSalad> (without all the wrapping/unwrapping)
16:01:11 <FunctorSalad> s/wan't/want/ (oh dear)
16:03:16 <FunctorSalad> best ignore my rambling ;)
16:04:38 <ehird> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2322#a2323 <- very short sierpinski gasket program
16:04:41 <ehird> using a neat trick
16:04:53 <ehird> a point (x,y) is in the sierpinski triangle if (x & y) = 0
16:04:57 <ehird> where & = bitwise and
16:06:12 <bbbbbbbb> hello
16:07:53 <newsham> http://codepad.org/KbglAnNG
16:08:08 <ehird> newsham: that's a bad w,h choic
16:08:08 <ehird> e
16:08:11 <ehird> let it be 30,30
16:08:15 <newsham> ok
16:08:23 <ehird> it goes screwy on some :\
16:09:00 <newsham> http://codepad.org/lQGGDWNZ
16:10:33 <Pseudonym> Quick question, following on from yesterday.
16:10:40 <Pseudonym> Does someone have GHC 6.10 handy?
16:10:51 <Eridius> sure
16:10:52 * Pseudonym needs to check if a file compiles in something post-6.8
16:10:55 <Pseudonym> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2294#a2294
16:11:04 <Pseudonym> The error message I get is down the bottom.
16:11:14 <eu-prleu-peupeu1> okey
16:11:20 <eu-prleu-peupeu1> a simple reactive example
16:11:21 <eu-prleu-peupeu1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2324#a2324
16:11:34 <eu-prleu-peupeu1> Gracenotes: check it out
16:11:45 <Eridius> Pseudonym: I get that exact error
16:11:50 <Pseudonym> Thanks.
16:11:58 <Gracenotes> eee.
16:12:17 <FalconNL> Ok, the following seems to be working as a parser for DWORDS. Would this do or is it horribly inefficient? dword = count 4 anyChar >>= return . fromIntegral . runGet getWord32be . fromString
16:12:52 <Pseudonym> Aha.
16:13:00 <Pseudonym> OK, that's a WEIRD problem.
16:13:07 <eu-prleu-peupeu1> whenever the left mouse is pressed on the glut window, it outputs the time and the position on the console
16:13:11 <newsham> ehird: quick hack: http://codepad.org/Y1PV2gVc :)
16:13:22 <ehird> newsham: neat!
16:13:25 <ehird> btw
16:13:28 <ehird> turns out 31,31 works better
16:14:01 <eu-prleu-peupeu1> oh well, back to bed... tomorrow ill define a simple 3D engine architecture for haskell and reactive
16:14:27 <Gracenotes> eu-prleu-peupeu1: yeah, build fails
16:14:33 <Gracenotes> quite badly
16:14:34 <eu-prleu-peupeu1> fails ?
16:14:43 <Gracenotes> anyway. I suppose I'll have to update to GHC 6.10 sooner or later.
16:14:48 <eu-prleu-peupeu1> im using ghc 6.10.1
16:14:56 <eu-prleu-peupeu1> on windows
16:14:58 <Gracenotes> yeah. it's very inconvenient on Debian though
16:15:04 <eu-prleu-peupeu1> hmm
16:15:06 <Gracenotes> Debian-based, i.e. Ubuntu
16:15:12 <eu-prleu-peupeu1> i also have ghc 6.10.1 on ubuntu
16:15:20 <eu-prleu-peupeu1> its easy
16:15:25 <Gracenotes> it seems to screw with the old installations
16:15:39 <eu-prleu-peupeu1> you need to install it into a folder inside your home directory
16:15:44 <Gracenotes> I have plenty of distro packages install, as well
16:15:44 <Pseudonym> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2294#a2326
16:15:47 <Gracenotes> +ed
16:15:48 <FunctorSalad> eu-prleu-peupeu1: isn't there FieldTrip already for 3D + reactive?
16:15:57 <Pseudonym> There we are.
16:16:10 <eu-prleu-peupeu1> FunctorSalad: yes, but i dont know how to extend it... its too much haskell for my knowledge :/
16:16:21 <Pseudonym> It's not a bug exactly, it's just that the error is reported as being in the wrong place.
16:16:27 <FunctorSalad> eu-prleu-peupeu1: ah. was just mentioning it in case you hadn't seen it :)
16:16:44 <eu-prleu-peupeu1> i did, it is very simple and intuitive to use
16:17:05 <eu-prleu-peupeu1> but i need to extend it for what i want to do :/ and i don't know how
16:17:21 <eu-prleu-peupeu1> my guess is ill just rip the parts of the code that i understand and start working from there :/
16:18:30 <eu-prleu-peupeu1> Gracenotes: install ghc 6.10 into a folder inside your home folder, and then do a simple bash script to change the system symlinks whenever you want to use 6.10 or 6.8
16:19:07 <eu-prleu-peupeu1> i've done it on ubuntu and it works fine, ill give out my scripts when i switch to ubuntu, maybe tomorrow night
16:19:39 <Gracenotes> okay, that'd be helpful.
16:19:50 <Gracenotes> I just wonder if the Debian package situation can be fixed
16:19:59 <eu-prleu-peupeu1> oh :/
16:20:08 <Gracenotes> with a minimal number of headaches for the fixer.
16:20:18 <Gracenotes> is it just a build? What you dependencies?
16:20:21 <Gracenotes> *about
16:21:10 <eu-prleu-peupeu1> hmm, i dont know, i just installed it onto a folder, and then reinstalled the haskell packages (from hackagedb) that i wanted
16:21:17 <eu-prleu-peupeu1> cabal didn't work...
16:21:34 <eu-prleu-peupeu1> it started complaining about having 2 versions of ghc :P
16:21:48 <Gracenotes> mm hm.
16:21:49 <Eridius> ooh, we should make commercials with the guy from "will it blend?" but instead of blending stuff, we take source that compiles on 6.8 and the 6.10 compiler and ask "Will it build?"
16:22:01 <Gracenotes> no.
16:22:13 <Eridius> :D
16:22:31 <Pseudonym> :-)
16:22:33 <Gracenotes> eu-prleu-peupeu1: well the main thing that cabal does is take care of dependencies
16:22:53 * Pseudonym tries to compile coke + chicken
16:22:55 <Gracenotes> and, er, handle installing and uninstalling and upgrading. But that's possible
16:23:08 <Eridius> you can use --with-ghc= to specify the path for ghc
16:23:16 <eu-prleu-peupeu1> i use cabal in my freebsd machine
16:23:19 <Eridius> or --with-compiler=
16:23:50 <eu-prleu-peupeu1> oh nice, ill try it out :D
16:23:56 <Gracenotes> hrm. ghc depends on perl for some reason
16:24:01 <Eridius> o_O
16:24:08 <Gracenotes> http://packages.debian.org/lenny/ghc6
16:24:23 <eu-prleu-peupeu1> i think all programming languages should depend on BASIC
16:24:30 <Pseudonym> Gracenotes: It's the evil mangler.
16:24:35 <Pseudonym> ?quote mangler
16:24:35 <lambdabot> Pseudonym says: All hail the Evil Mangler!
16:24:43 <Pseudonym> Not the one I was after.
16:24:45 <Pseudonym> ?quote mangler
16:24:45 <lambdabot> Pseudonym says: All hail the Evil Mangler!
16:24:45 <Gracenotes> explox pl0x
16:24:46 <Pseudonym> Hmm.
16:24:49 <Eridius> Gracenotes: huh, same thing in MacPorts
16:24:49 <FunctorSalad> ?quote mangler
16:24:49 <lambdabot> Pseudonym says: All hail the Evil Mangler!
16:24:58 <FunctorSalad> what is this Evil Mangler?
16:25:03 <Pseudonym> It's an old quote to the effect that the fact that it's written in Perl is proof that it's evil.
16:25:04 <Gracenotes> HEIL MANGLER
16:25:21 <Pseudonym> http://hackage.haskell.org/trac/ghc/wiki/Commentary/EvilMangler
16:25:25 <Gracenotes> but, what introduced the dependency?
16:25:26 <eu-prleu-peupeu1> ghc is written in perl ?
16:25:41 <tomh> lol
16:25:47 <stepcut> FunctorSalad: it's a perl script that looks at the assembly generated by GCC and then uses regular expressions to remove lines of code from the assembly
16:25:49 <Gracenotes> os nos.
16:26:04 <tomh> does quickcheck 2.1.0.1 not compile on windows?
16:26:09 <Gracenotes> that's quick a dependency.
16:26:11 <Gracenotes> *quite
16:26:20 <stepcut> FunctorSalad: that's right! regular expressions to modify assembly code!
16:26:20 <FunctorSalad> eu-prleu-peupeu1: yes, except the inner loops, they run in javascript for efficiency
16:26:34 <FunctorSalad> stepcut: :)
16:26:48 <eu-prleu-peupeu1> :D
16:26:53 <tomh> anyone knows what this error can be caused by: Class `Exception' used as a type
16:26:57 <Gracenotes> this is all not very funny :/
16:27:01 <Pseudonym> There's one good reason for its existence, and that's to satisfy the vagaries of the STG architecture.
16:27:13 <Pseudonym> The other stuff is just for evilness.
16:27:15 <Eridius> hrm, so does this mean you can't take code generated by -fvia-C and compile it by hand with gcc?
16:27:29 <Pseudonym> Eridius: You can, but then it won't garbage collect.
16:27:31 <Pseudonym> Or something like that.
16:27:32 <Eridius> hah
16:27:49 <Pseudonym> Also it'll blow stack quickly.
16:27:54 <stepcut> Eridius: most of the regexs just remove useless stack checks or something like that
16:27:56 <Pseudonym> It's pretty evil.
16:28:06 <stepcut> Eridius: i think... dunno really know the details
16:28:12 <eu-prleu-peupeu1> evil mangler gives out a nice nick
16:28:25 <BONUS> tomh: you're using code for 6.8 on 6.10
16:28:29 <Eridius> so how does it handle porting to a new architecture?
16:28:40 <tomh> i dunno i downloaded a hackage package
16:28:40 <BONUS> since there's a new exception model in 6.10
16:28:40 <Pseudonym> If you used a SMLNJ-style stack, probably the mangler wouldn't be necessary.
16:28:44 <stepcut> Eridius: you have to supply the regexs for that architecture
16:29:03 <Pseudonym> You also need to supply it for a new major version of GCC.
16:29:03 <Eridius> blech
16:29:16 <stepcut> Eridius: there is a stage where you don't have to, but eventually you do.
16:29:25 <Eridius> I was hoping to play around with the idea of using -fvia-C to generate code that could then be compiled for the iPhone, but I guess that idea's dead
16:29:29 <pejo> Pseudonym, um, SMLNJ is strict and only has one stack, so that should be quite easy to deal with?
16:29:33 <tomh> BONUS: how can i get it to compile?
16:29:41 <BONUS> tomh: what's the code?
16:29:48 <stepcut> Eridius: many people have had the idea of targetting the ARM (myself included), but no one has done it yet :)
16:29:51 <Pseudonym> Doesn't SMLNJ use the heap for its stack records?
16:30:12 <stepcut> Eridius: I heard rumors that there is some work being done on the GHC backend to make porting easier, but I don't know any details or if it is even true
16:30:18 <eu-prleu-peupeu1> bye bye
16:30:21 <Eridius> hmm
16:30:24 <Pseudonym> It did in 1989, I'm pretty sure.
16:30:33 <FunctorSalad> case polymorphicThing :: Foo -> Foo of polymorphicThing -> {- code without lots of type annotations :) -}
16:30:34 <Pseudonym> It is 20 years later, so who knows what's changed.
16:30:38 <FunctorSalad> (hope this will work)
16:30:56 <pejo> Pseudonym, does it have to do that, or just a design choice?
16:31:07 <Pseudonym> Design choice, I believe.
16:31:14 <Pseudonym> It made the garbage collector a lot simpler.
16:31:21 <Pseudonym> Because you didn't have to check the C stack.
16:31:28 <tomh> BONUS: quickcheck 2.1.0.1
16:31:57 <Pseudonym> Also, it simplified a bunch of things.
16:32:15 <BONUS> oh, well, i recon you'd have to change quite a lot of things, probably the best way is to get a 6.10 compatible version of quickcheck
16:32:21 <Pseudonym> Because it compiled to CPS code, there was no stack rearrangement required.
16:33:34 <tomh> mm
16:38:50 <ddarius> Pseudonym: I'm pretty certain it still does.
16:40:35 <dcoutts> dons: yes, I've seen threadscape, cool indeed. I'll offer advice on use of gtk.
16:41:36 <Nafai> threadscape looks neat
16:43:24 <wani> Hello everybody. I'm very sorry for the stupid question, but I'm just taking my taste of Haskell - what is the Haskell analogue the unary negation of boolean types?
16:43:45 <dqd> not
16:43:59 <wani> ouch. thanks
16:44:57 <gwern> @hoogle Bool -> Bool
16:44:57 <lambdabot> Prelude not :: Bool -> Bool
16:44:57 <lambdabot> Data.Bool not :: Bool -> Bool
16:44:57 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
16:45:28 <gwern> @djunn Bool -> Bool
16:45:28 <lambdabot> f a = a
16:45:55 <gwern> hm. I was expecting a second function there - identity and negation both
16:47:06 <ddarius> gwern: It should list id before too long.
16:48:22 <wani> ghc doesn't like it. is "isReflexive ref = not elem False ref" supposed to work?
16:48:29 <wani> because it doesn't
16:49:17 <ddarius> It doesn't work because it is not supposed to.
16:49:51 <gwern> looks like it wouldn't parse
16:50:02 <gwern> not $ elem False ref mebbe
16:50:31 <ehird> > let dog = "chase" : tail dog in dog
16:50:46 <lambdabot>   thread killed
16:50:55 <ehird> Hm.
16:52:39 <ddarius> gwern: It parses.  It just parses into non-type-checking gobbeldygook.
16:53:01 <gwern> fine fine
16:59:10 <Peaker> How do multi-line string literals in ghc work again?
16:59:55 * monochrom looks it up
17:00:11 <ddarius> Peaker: From a \ to another \ you can have any whitespace.
17:00:17 <ddarius> > "foo \       \ bar"
17:00:18 <Peaker> ddarius: ah great thanks
17:00:19 <lambdabot>   "foo  bar"
17:00:29 <monochrom> yeah
17:02:16 <Tseg> > map (+1) [1..10]
17:02:17 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:04:05 <Tseg> > djinn t->t
17:04:07 <lambdabot>   <no location info>: parse error on input `->'
17:05:15 <Tseg> > id ? t->t
17:05:16 <lambdabot>   <no location info>: parse error on input `->'
17:05:34 <Tseg> > id ? t->t;
17:05:35 <lambdabot>   <no location info>: parse error on input `->'
17:06:05 <pumpkin_> what are you trying to do?
17:06:41 <Tseg> How to make LambdaBot give me a term for a type I specify?
17:07:40 <ehird> err
17:07:43 <ehird> @djinn t-.t
17:07:43 <lambdabot> Cannot parse command
17:07:44 <ehird> r
17:07:48 <ehird> @djinn t->t
17:07:48 <lambdabot> f a = a
17:07:53 <Tseg> Thank you!
17:07:58 <ehird> its not perfect
17:08:00 <ehird> :)
17:08:04 <Tseg> @djinn (a->a)->a
17:08:04 <lambdabot> -- f cannot be realized.
17:08:13 <ehird> sry.
17:08:21 <ehird> @src fix
17:08:21 <lambdabot> fix f = let x = f x in x
17:09:35 <Tseg> @djinn (a->(a->u)->u)->((a->u)->u)
17:09:35 <lambdabot> -- f cannot be realized.
17:09:43 <Tseg> I'm looking for a term mfixCont :: (a->(a->u)->u)->((a->u)->u), a monadic fixed point operator for the continuation monad.
17:10:35 <Tseg> I built one using references, but it's unsound in the presence of backtracking with callCC.
17:16:22 <Tseg> Can anyone lend me a monadic fixed point operator for continuations? Any total function of type (a->(a->u)->u)->((a->u)->u) will do.
17:16:27 <ehird> hm
17:16:58 <byorgey> @src Cont
17:16:59 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
17:17:08 <dolio> There's a reason it's not in the libraries.
17:17:15 <ddarius> Tseg: If djinn can't produce a result for it, then there is no total function of that type.
17:17:25 <FalconNL> I'm pretty sure there was a function like splitIntoGroupsOfLength :: Int -> [a] -> [[a]], but I can't think of the right name. Does anyone have a better memory than me?
17:17:30 <byorgey> so that's  (a -> Cont u a) -> Cont u a ?
17:17:37 <ehird> Tseg: well, fix isn't total
17:17:57 <Botje_> FalconNL: it's commonly called "chunk", and i don't think it's a standard function
17:18:03 <Tseg> byorgey, yes.
17:18:16 <ehird> FalconNL: try the split package
17:18:47 <Tseg> ehird, I'll take anything better than \f->error("").
17:18:47 * Nafai looks at http://www.reddit.com/r/haskell and wonders if it should be renamed http://www.reddit.com/r/dons
17:18:50 <Nafai> :)
17:18:58 <ehird> Tseg: you mean error "" rite
17:19:10 <FalconNL> ehird: That should work. thanks.
17:19:20 <ehird> (a -> (a -> u) -> u) -> (a -> u) ->u
17:19:22 <ehird> hm.
17:19:37 <Tseg> error("") == error"", pardon I'm a C programmer.
17:19:41 <ehird> \f g -> f ? g
17:19:46 <ehird> now I gotsa fill in g :-)
17:19:56 <ehird> :t \f g -> f (fix g) g
17:19:57 <lambdabot> forall a t. (a -> (a -> a) -> t) -> (a -> a) -> t
17:20:02 <ehird> Bit more restricted than you would like?
17:21:41 <Tseg> That won't quite work for delimited continuations.
17:22:07 <ehird> Mm.
17:22:18 <ehird> Well, you need to get an a, Tseg.
17:22:24 <ehird> There is no way, from your definition, you can get an a.
17:22:27 <ehird> Apart from `undefined`.
17:22:43 <ehird> The first argument takes a as its first argument. We have neither an a nor an (X->a). You can't write it.
17:23:42 <Tseg> That makes sense. Here's my reference trick: mfix(f)=let r=newRef(Nothing) in ContIO(\to->in runIO(f(unJust(readRef(r))))(\v->do {writeIORef(r)(Just(v)); to(v)}))
17:24:12 <ehird> AAAAAAAGH!!!
17:24:12 <Tseg> Where ContIO is a just wrapper data type.
17:24:20 <ehird> Put some spaces and less parens in there, for goodness sake!
17:24:45 <ehird> Tseg: ... But, yeah, that's just "undefined" in a guise.
17:24:48 <ehird> :t undefined
17:24:49 <lambdabot> forall a. a
17:24:52 <ehird> > undefined
17:24:53 <lambdabot>   * Exception: Prelude.undefined
17:25:49 <Tseg> Cleaned up: mfix(f)=let r=newRef(Nothing) in \to->f(unJust $ readRef r)(\v->do {writeIORef r (Just v ); to(v)})
17:26:53 <Tseg> That works perfectly for pure monadic continuations. It breaks with callCC :: ((a->m b)->m a)->m a.
17:27:02 <ehird> here's a really cleaned up version:
17:27:32 <ehird> mfix f = let r = newRef Nothing in \to -> f (unJust $ readRef r) (\v -> do writeIORef r (Just v); to v)
17:27:42 <ehird> :-)
17:27:51 <dolio> Have you seen Magnus Carlsson's Value Recursion in the Continuation Monad?
17:28:00 <dolio> I can't seem to find it anymore.
17:28:10 <dolio> But I have it, and it talks about what you want.
17:28:35 <Tseg> dolio, no. I've read all the papers I can find on value recursion in general monads, but couldn't find anything better in continuations.
17:29:45 <Tseg> Perhaps I need to find something less general than mfix :: (a->(a->u)->u)->((a->u)->u).
17:30:31 <Tseg> I just need a way of writing monadic comprehensions containing .. a<-m(a) ..
17:31:24 <Tseg> And that needs to yield consistent results when backtracking with callCC (each backtrack sees its own distinct version of a).
17:32:08 <Tseg> Come to think of it, mfix can't possible work, since it needs an a before it knows who to pass it to.
17:32:34 <Tseg> Actually, like ehird said.
17:35:05 <Sekaino> Hey guys, any lambdabot experts around?
17:35:22 <pumpkin_> try us
17:35:48 <Sekaino> Namely, this problem:
17:35:50 <Sekaino> <Tanuki> > 1
17:35:50 <Sekaino> <[deliciouslie]>   mueval-core: Prelude.read: no parse
17:35:50 <Sekaino> <[deliciouslie]>  mueval: ExitFailure 1
17:36:10 <Sekaino> Latest lambdabot darcs build on an Arch Linux system.
17:36:11 <pumpkin_> try calling mueval on its own?
17:36:26 <Sekaino> Against ghc 6.10.1
17:37:17 <Sekaino> [tanuki@ingus bin]$ mueval -e "1"
17:37:17 <Sekaino> 1
17:37:17 <Sekaino> [tanuki@ingus bin]$ mueval -e "1 + 1"
17:37:17 <Sekaino> 2
17:37:19 <Sekaino> Seems to work.
17:40:09 <Sekaino> Also, I get this error with some frequency, which may or may not be related: "Main: caught (and ignoring) too few bytes. Failed reading at byte position 8"
17:40:46 <Sekaino> Also, the latest version in Hackage shows the same behavior, which is why I tried the darcs build.
17:42:23 <tomh> :t Int
17:42:24 <lambdabot> Not in scope: data constructor `Int'
17:42:37 <tomh> :t >>=
17:42:38 <lambdabot> parse error on input `>>='
17:42:39 <Eridius> can someone explain this error:
17:42:39 <Eridius> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
17:42:41 <Eridius> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
17:43:11 <Eridius> I suppose I should uninstall process 1.0.1.1, I'm just confused as to how ghc-6.10.1 can require both
17:43:42 * Eridius updated to process 1.0.1.1 just because it was there. "I really wish there was some way cabal could warn me when I'm upgrading a ghc-bundled package"
17:43:58 <juhp_> Eridius: I think that is a faq :)  maybe you did cabal upgrade with older cabal-install?
17:44:20 <Eridius> no, I have latest cabal, and I did `cabal install process` after looking at the `cabal upgrade --dry-run` list and seeing that it was outdated
17:44:29 <Eridius> unfortunately cabal itself doesn't know what packages are provided with ghc
17:45:04 <Eridius> what the... I can't unregister process-1.0.1.1 because ghc-pkg thinks a bunch of stuff depends on it. Can it not tell that process-1.0.1.0 fulfills those dependencies?
17:45:34 <sjanssen> Eridius: it doesn't work like that
17:45:37 <Eridius> also, `ghc-pkg describe ghc-6.10.1` says it depends on process-1.0.1.0, so why does ghc-pkg think it depends on process-1.0.1.1?
17:46:01 <sjanssen> Eridius: a package is built against a specific version of a particular library
17:46:04 <Eridius> basically, this boils down to ghc-pkg thinks a bunch of stuff depends on process-1.0.1.1 even though they're declared as depending on process-1.0.1.0
17:46:08 <Eridius> sjanssen: I know, which is why I'm so confused
17:46:21 <Eridius> these packages depend on 1.0.1.0 but ghc-pkg claims they depend on 1.0.1.1
17:46:49 <Igloo> It might mean "transitively depends"
17:47:01 <Eridius> Igloo: how can ghc-6.10.1 possibly depend on a package that was installed later?
17:47:22 <Igloo> If a library it depends on got reinstalled
17:47:32 <wli> I've got things down to integer linear combinations of monomials times products of surds.
17:47:36 <Eridius> I believe process-1.0.1.1 is the very latest package I've installed
17:48:06 <Igloo> Also, you might have the same version of a library in your user package.conf and your global package.conf, which could confuse things
17:48:25 <Eridius> I install everything globally
17:49:35 <Eridius> oh hrm, maybe process isn't the latest package I installed, but I haven't re-installed anything since I installed it
17:50:03 <Eridius> ok, wtf. it's haskell98's fault
17:50:21 <Eridius> that's depending on process-1.0.1.1, and ghc depends on it, but it wasn't bundled with ghc
17:50:24 <wli> I'm not entirely sure how to find a basis for the radical extension of K(x), but have a vague idea it's going to involve linear algebra over something which is not Double or remotely close.
17:50:54 <Eridius> or at least, I only have one version of haskell98 installed, and I didn't even manually install it (cabal installed it as a dependency)
17:51:18 <Eridius> is it possible that cabal forced a reinstall of haskell98 in order to resolve the dependency on two versions of process (i.e. to "fix" it by reinstalling haskell98)?
17:52:29 <Eridius> hrm, I really wish I could ask ghc-pkg what depends on a specific package, besides trying to uninstall it
17:52:41 * Eridius forced the uninstall of process, then reinstalld haskell98, and how he'd love to ask "what depends on process-1.0.1.1" just to check
17:53:06 <Eridius> well, I can now install mueval, so I think the mess has probably been cleared up
17:54:04 <Eridius> ooh, haddock had a parse error on Mueval/Interpreter.hs
17:55:19 <gwern> yeah, I refuse to kowtow to that haddock bug
17:55:25 <Eridius> so fix it :P
17:55:26 <sjanssen> gwern: which bug?
17:55:50 <gwern> sjanssen: the one where -- ^ fails
17:56:00 <sjanssen> gwern: on data constructor arguments?
17:56:08 <gwern> no, this is type sigs
17:56:16 <gwern> render :: (Control.Monad.Trans.MonadIO m) => Int -> -- ^ max number of characters to include String -> -- ^ input m (String, Bool) -- ^ ( output, @True@ if we found an exception )
17:56:16 <sjanssen> oh, I hadn't seen that one
17:56:26 <gwern> (with newlines elided obviously)
17:56:37 <gwern> it fails on the first one, incidentally
17:56:40 <Eridius> I'm not familiar with haddock syntax. Why does -- ^ fail?
17:56:52 <sjanssen> gwern: does it work if the -> is on the next line?
17:57:05 <gwern> dunno
17:57:11 <sjanssen> eg. Int -- ^ max chars \n -> blahblahblah
17:57:48 <gwern> yes
17:58:55 <sjanssen> gwern: "yes, it works" or "yes, I get it but haven't tried it"?
17:59:09 <gwern> yes
17:59:19 * gwern is kidding; the former
17:59:26 <sjanssen> cool
18:00:21 <Sekaino> Hm, anyone know how to uninstall a package installed with cabal-install?
18:00:52 <gwern> you can't, really, short of manually finding all the files installed and deleting them by hand
18:00:58 <gwern> you can hide and unregister the package though
18:01:26 <Sekaino> If I'm installing to /usr/local, is it sufficient to clean out /usr/local/bin and /usr/local/lib?
18:02:19 <gwern> (amusing. my mueval repo is corrupt.)
18:04:27 <Eridius> oh great, mueval fails when I have monads-fd installed
18:04:30 <Eridius> mueval-core: NotAllowed "Could not find module `Control.Monad.Cont':\n  it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2"
18:05:25 <gwern> so would anything that needs that module
18:05:53 <gwern> it's really out of mueval's ambit to deal with contradictions in the libraries
18:06:33 <ccondon> Hey guys... I'm having a little trouble with parsec, and I'm new to this.
18:07:00 <ccondon> When I run the test code at the bottom of the page http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Expr.html , I get a typecheckking error
18:07:28 <ccondon> temp.hs:7:18:     Couldn't match expected type `TokenParser st'            against inferred type `GenParser tok st1 a'     In the first argument of `parens', namely `expr'     In the first argument of `(<|>)', namely `parens expr'     In the first argument of `(<?>)', namely `parens expr <|> natural'
18:13:40 <ccondon> Hm, I'm not sure if you got my last messages (I sent them from mibbit, and my browser crashed, so now i'm on irssi)
18:14:07 <sebaseba> ccondon: your last message was "temp.hs:7:18:    Couldn't match expected..."
18:14:28 <ccondon> okay, thanks, that was my last :)
18:14:54 <ccondon> does anyone know whats going on with that? I'm really confused by Parsec in general
18:16:27 <sebaseba> ccondon: I think you need to do declare your parsers by passing the lexer, e.g. "parens = P.parens lexer", where P is import qualified Text.ParserCombinators.Parsec.Token as P (for the older version of Parsec, should be a different module for the one you're using)
18:16:35 <mmorrow> , [$bf|.+[.+]|]
18:16:39 <lunabot>  luna: No instance for (GHC.Show.Show
18:16:41 <mmorrow> , [$bf|.+[.+]|] ""
18:16:43 <pumpkin> omg it's mmorrow
18:16:43 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
18:16:57 <mmorrow> omg johnnypumpkinseed
18:17:20 <pumpkin> lol
18:17:24 <mmorrow> :)
18:17:39 <sebaseba> ccondon: why don't you put your code on hpaste so we can take a look
18:17:51 <ccondon> okay, one second :)
18:18:24 <Axman6> pumpkin: i noticed i voted at least two of your comments on reddit up yesterday, on the same thread
18:18:30 <pumpkin> :o
18:18:42 <ccondon> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2327#a2327
18:18:47 <pumpkin> whee
18:19:28 <mmorrow> , [$bf2|++++++++++[.-]|] ""
18:19:30 <lunabot>  ("\n\t\b\a\ACK\ENQ\EOT\ETX\STX\SOH",(0,Mem (fromList [(0,0)])))
18:20:04 <ccondon> if it matters, I'm using ghci version 6.8.2
18:23:25 <wli> It needs a little work, since t^(1/2) reduces to Right (Just 't',[Expr7 1 0 [([Expr7 1 1 []],[Expr7 1 0 []],1,2)]],[Expr7 1 0 []])
18:24:22 <wli> No, wait, that's good.
18:24:30 <Axman6> :)
18:24:44 <wli> It's t^2 --> Right (Just 't',[Expr7 1 0 [([Expr7 1 1 []],[Expr7 1 0 []],2,1)]],[Expr7 1 0 []])
18:25:29 <Axman6> i hope you know what that means, because it's all greek to me :P
18:26:02 <wli> Okay, the first component of the tuple in the Right is the one-character name of the variable of the expression.
18:26:29 <wli> The second and third components are representations of the numerator and denominator of the expression.
18:27:54 * mmorrow puts a $0 bounty on a brainfuck fibonacci (infinite printout) one-liner
18:27:55 <wli> They're lists of summands of the form constant times x^k times a product of radicals, which are then of similar forms (pair of lists of summands for numerator and denominator etc.)
18:28:23 <wli> Plus integers for the numerator and denominator of the exponent.
18:28:25 <pumpkin> mmorrow: so we'd have to implement arbitrary precision arithmetic in bf too? or do you assume each cell isn't bounded?
18:28:43 <mmorrow> pumpkin: well, lunabot can only printout 78 chars or so..
18:28:48 <pumpkin> :(
18:28:55 <wli> All I need to do here is pull out integer factors.
18:29:20 <mmorrow> ok, so ammending the bounty terms.... the first 20 elements of fibonacci, printed out
18:29:33 <mmorrow> (not that that would make it any easier i don't think)
18:29:43 <pumpkin> :P
18:29:45 <mmorrow> welllll, explicitly coding it is banned
18:29:51 <pumpkin> even printing numbers in decimal is a royal pain
18:29:55 <mmorrow> yeah
18:30:03 <mmorrow> i tried for fib and quickly gave up
18:30:15 <mmorrow> brainfuck is such a pain in the ass to use
18:30:36 <mmorrow> it should be called asspain or something :P
18:30:41 <wli> For reference I should get t^2 ---> Right (Just 't',[Expr7 1 2 []],[Expr7 1 0 []])
18:31:07 <pumpkin> lol
18:31:17 <aempirei> can u model all the integers as functions from all functions that accept at least one integer to all other types, and this class of functions I_n : all functions that accept I_n -> all types I_n f - f I_n so like 6(f) = f(6)
18:31:56 <Axman6> o.O
18:31:59 <aempirei> lol
18:32:32 <Axman6> i guess anything's possible...
18:33:30 <Axman6> data MyInteger = MyI Integer (Integer -> Integer) maybe?
18:36:31 <aempirei> i mean you can trivially make syntax f(n) -> n(f) and instead of having one function f : N -> N you have |N| functions for each n in N n' : f -> N
18:37:39 <aempirei> useless nonsense
18:38:14 * edwardk doesn't see the point =)
18:45:40 <wli> Okay, I fixed the integer expnent issue.
18:45:40 <wli> This code is a mess, though.
18:45:40 <wli> Worse yet, I've not even gotten started on its actual task.
18:51:30 --- mode: irc.freenode.net set +o Igloo
18:51:31 --- mode: irc.freenode.net set +o ChanServ
18:51:46 <pumpkin> is he abominable?
18:51:49 <mmorrow> depends on whether the biohazard unicode char follows him or not
18:51:59 <Axman6> > text "\9731"
18:52:01 <lambdabot>   ☃
18:53:17 <mmorrow> , text "abominable snowman: ☃☣"
18:53:19 <lunabot>  abominable snowman: #
18:53:22 <gnuvince_> Me and some friends are debating NULL references with me being the only one in favor of a system such as Maybe to prevent misuses and them being only C and C++ practionners not understand what the problem is.  Is there a good paper or article that would describe the problem with NULL?
18:53:37 <mmorrow> wut, that came through for me as:
18:53:40 <mmorrow> abominable snowman: #
18:53:43 <mmorrow> ohh
18:53:46 <pumpkin> :o
18:53:47 <gnuvince_> Wow, that sentence came out wrong :-/
18:53:52 <mmorrow> , (text . utf8enc) "abominable snowman: ☃☣"
18:53:54 <lunabot>  abominable snowman: ☃☣
18:54:12 <mmorrow> , utf8enc "☃☣"
18:54:14 <lunabot>  "\226\152\131\226\152\163"
18:54:30 <wli> I may be in branch cut trouble.
18:54:47 <lament> gnuvince_: how is NULL different from Maybe?
18:55:25 <Axman6> gnuvince_: well, the guy who invented the null pointer says it's the biggest mistake he ever made... (or something along those lines)
18:55:29 <ddarius> gnuvince_: The problem with NULL is that it is always there.
18:55:41 <mmorrow> it's the fact that you can dereference NULL is what makes it "bad"
18:55:47 <mmorrow> not that it exists
18:56:02 <bd_> NULL is like an implicit fromJust everywhere
18:56:08 <mmorrow> exactly
18:56:26 <mmorrow> well, in a sense
18:56:27 <ddarius> bd_: Not exactly.  * is like fromJust.
18:56:34 <bd_> well, okay :)
18:56:38 <mmorrow> yeah
18:56:57 <lament> NULL isn't always there, it's only there in pointer types.
18:57:02 <sebaseba> gnufied: there's this paper http://users.encs.concordia.ca/~chalin/papers/TR-2006-003.v3s-pub.pdf
18:57:11 <bd_> pointer types are all over the place in C though :)
18:57:33 <sebaseba> gnufied: there might be more pointers at http://lambda-the-ultimate.org/node/3186
18:57:36 <ddarius> lament: I was limiting to pointer types.  NULL isn't relevant for non-reference/pointer types.
18:57:53 <ddarius> The problem is you can't have non-null pointer to foo.
18:57:54 <gnuvince_> sebaseba: I assume those were for me?
18:58:03 <Eridius> ahh, monads-fd is indirectly required by yi.
18:58:09 <BMeph> gnuvince_: I don't know a paper right off, but I remember someone blogging about it. Maybe try sigfpe. :)
18:58:17 <sebaseba> gnufied: yes
18:58:18 <Eridius> maybe mueval should just be haxx0red to explicitly hide monads-fd
18:58:29 <sebaseba> gnuvince_: yes, sorry!
18:58:35 <gnuvince_> sebaseba: ;)
18:58:42 <sebaseba> damn autocompletion user...
18:58:59 <mmorrow> Eridius: don't be scurred!
18:59:11 <lament> ddarius: and the problem with haskell is you can have a non-entire function.
18:59:21 <gnuvince_> ddarius: that's the point I'm not able to get through to them.  They don't see what the problem is with NULL being pervasive; "Just learn to code and check your return values!"
18:59:26 <Eridius> mmorrow: I shouldn't get scurvy?
18:59:37 <mmorrow> Eridius: eat your oranges!
19:00:22 <Eridius> but I'm on a ship, and we didn't take on no fruit because we needed space for the rum!
19:00:25 <ddarius> gnuvince_: The problem is you can't propagate the fact that you have checked so you get implicit contracts ("I'll pass you a non-null pointer") which, as experience has blatantly shown, are constantly violated.
19:00:30 <Eridius> yarr, this be a fools voyage
19:00:46 <ddarius> Even if you do meticulously check such things, it's wasteful code.
19:01:07 <lament> gnuvince_: are your haskell functions always entire? If not, your code has essentially the same problem of not checking enough values.
19:01:20 <mmorrow> Eridius: hmm, maybe orange rum would be a killer app here
19:01:26 <Eridius> oooh
19:02:12 <ddarius> gnuvince_: Basically, if they think the type system is useful at all, they should have no problem seeing how it could be useful here.  Otherwise they might as well just pass around void pointers all the time.
19:03:09 <BMeph> ddarius: The "real" problem, is that NULLonly has _some_ of the functionality of Maybe, and if it went ahead and did the rest (i.e., some way to fmap your Nullable types), then it would knock out a huge amount of problems.
19:04:00 <BMeph> gnuvince_: You should use the above point in your argument. ;)
19:04:08 * mmorrow passes around void* all the time
19:04:24 <gnuvince_> BMeph: I'm accumulating links and quotes :)
19:04:26 <ddarius> BMeph: If you had something like the Maybe monad, it would help, but it's still wasteful.  Would you rather put your entire (Haskell) program in the Maybe monad because you read in a number from the user, or would you prefer to check and once validated simply know that the number is a number.
19:06:20 <Gracenotes> @botsnack
19:06:20 <lambdabot> :)
19:06:20 <lunabot>  :)
19:06:48 <Gracenotes> @botsnack
19:06:48 <lambdabot> :)
19:06:48 <lunabot>  :)
19:06:56 <mmorrow> @botcrackpipe
19:06:56 <lambdabot> Unknown command, try @list
19:06:56 <lunabot>  :)
19:08:35 <BMeph> ddarius: If your whole program's in Maybe, would you notice? ;)
19:09:42 <ddarius> Yes.  You'd be writing in monadic style rather than in a pure style.
19:09:47 <wli> Depending on whether t^(2/6) == t^(1/3) or |t|^(1/3)
19:11:13 <kerlo_> If 2/6 == 1/3, then t^(2/6) == t^(1/3), unless you're weird.
19:11:46 <Axman6> > 7^^(1/3)
19:11:47 <lambdabot>   Add a type signature
19:11:52 <Axman6> > 7**(1/3)
19:11:53 <lambdabot>   1.912931182772389
19:12:02 <kiris> :t (**)
19:12:03 <lambdabot> forall a. (Floating a) => a -> a -> a
19:12:03 <Axman6> > (-7)**(1/3)
19:12:05 <lambdabot>   NaN
19:12:17 <kiris> :t 7**1
19:12:18 <lambdabot> forall t. (Floating t) => t
19:12:27 <Axman6> hmm, you can have cube roots of negative numbers right?
19:12:39 <BMeph> ddarius: ...but if your whole program's in Maybe, when are you going to use a pure style for anything?
19:12:52 <Axman6> > (-8)**(1/3) -- == -2?
19:12:53 <ddarius> BMeph: Never, which is my point.
19:12:54 <lambdabot>   NaN
19:13:03 <Axman6> > (-2)^3
19:13:05 <lambdabot>   -8
19:13:27 * BMeph is confused; he thought that is was /his/ point...
19:13:59 * BMeph meant *it, not is
19:14:30 <ddarius> [21:08] <BMeph> ddarius: If your whole program's in Maybe, would you notice? ;)
19:14:32 <ddarius> [21:09] <ddarius> Yes.  You'd be writing in monadic style rather than in a pure style.
19:14:39 <sarh> > (-8)^^(1%3)
19:14:40 <lambdabot>       No instance for (Integral (Ratio t))
19:14:40 <lambdabot>        arising from a use of `^^' ...
19:16:16 <pumpkin> > (-8)**(1/3) :: Complex Double
19:16:17 <lambdabot>   1.0 :+ (-1.732050807568877)
19:16:36 <pumpkin> > ((-8)**(1/3))**3 :: Complex Double
19:16:37 <lambdabot>   (-7.999999999999995) :+ (-9.79717439317882e-16)
19:16:45 <pumpkin> > ((-8)**(1/3))**3 :: Complex CReal
19:17:00 <lambdabot>   thread killed
19:17:01 <pumpkin> wow, CReal is epicly slow :)
19:17:04 <Axman6> i'm really looking forward to this threadscope program. should be useful
19:17:14 <byorgey> > (-1)**(1/6)
19:17:16 <lambdabot>   NaN
19:17:20 <byorgey> > (-1)**(1/5)
19:17:22 <lambdabot>   NaN
19:17:28 <byorgey> eh?
19:17:40 <byorgey> > (-1)**(1/5) :: Complex Double -- oh, duh
19:17:41 <lambdabot>   0.8090169943749475 :+ (-0.5877852522924731)
19:17:52 <BMeph> pumpkin: Is it? Or is it _monicly_ slow? ;p
19:17:59 <pumpkin> :o
19:18:33 <byorgey> argh
19:18:43 <Axman6> > (-1)**(1/5) :: Complex Double
19:18:44 <lambdabot>   0.8090169943749475 :+ (-0.5877852522924731)
19:18:53 <pumpkin> what if we want the other 5
19:18:54 <Axman6> > (-1)**(1/4) :: Complex Double
19:18:56 <lambdabot>   0.7071067811865476 :+ (-0.7071067811865475)
19:19:08 <pumpkin> other 4, I guess
19:19:15 <gwern> Eridius: you could remove cont from the imnport list in Mueval.Context if you don't mind editing the source and have no better way of fixing the conflict...
19:19:26 <Axman6> > sqrt 2 :+ -1*sqrt 2
19:19:27 <lambdabot>       precedence parsing error
19:19:27 <lambdabot>          cannot mix `(:+)' [infix 6] and prefi...
19:19:28 <gwern> of course, the issue will still exist; just mueval won't run into it
19:19:48 <Eridius> gwern: is there a simple way to edit mueval to hide monads-fd?
19:19:48 <Axman6> > (0.5* sqrt 2) :+ (-0.5*sqrt 2)
19:19:49 <byorgey> > map (((-1)**(1/5) :: Complex Double)^) [1..5]
19:19:50 <lambdabot>   [0.8090169943749475 :+ (-0.5877852522924731),0.30901699437494745 :+ (-0.951...
19:19:50 <lambdabot>   0.7071067811865476 :+ (-0.7071067811865476)
19:20:04 <byorgey> pumpkin: you can just do that
19:20:07 <pumpkin> yay
19:20:28 <byorgey> pumpkin: I think it always gives you the first root, which is always a generator for the whole group
19:22:11 <gwern> Eridius: yeah, just comment its line out
19:22:11 <Eridius> gwern: I mean without removing Cont from the import list
19:22:11 <gwern> Eridius: mueval whitelists modules - so it's explicitly listed somewhere in the src
19:22:11 <doctormach> Are there any changes in ghc 6.10.1 compared to ghc 6.8.3 that make programs use significantly more memory?
19:22:11 <gwern> Eridius: well, I guess you could do ghc-pkg hide monads-fd
19:22:11 <Eridius> gwern: would that interfere with my ability to build yi?
19:22:11 <travisbrady> is there any easy way to generate every possible value for some type? something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2329#a2329
19:22:18 <pumpkin> doctormach: in at least one case, a bug was introduced, yes
19:22:25 <gwern> Eridius: probably
19:22:31 <pumpkin> travisbrady: derive Enum
19:22:41 <gwern> Eridius: I've been meaning to try hiding mtl or monads-fd, and seeing which way breaks more stuff
19:22:50 <Axman6> travisbrady: Dog needs to be Dog Breed Color, not just Breed Color
19:22:55 <Eridius> mtl comes with ghc, monads-fd doesn't, so I would assume you should hide monads-fd
19:23:05 <Axman6> @instances Enum
19:23:07 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
19:23:18 <Axman6> @instances Ordering
19:23:18 <lambdabot> Couldn't find class `Ordering'. Try @instances-importing
19:23:22 <travisbrady> Axman6: oops, you're right
19:23:28 <pumpkin> Ordering is a type
19:23:36 <BMeph> pumpkin: That doesn't work, actually. :(
19:23:37 <pumpkin> :t EQ
19:23:38 <lambdabot> Ordering
19:23:43 <Axman6> oh right
19:23:47 <Axman6> m'bad
19:23:55 <Axman6> thogught something funky was going on
19:23:56 <pumpkin> BMeph: in an ideal world, it would :P
19:24:45 <Sekaino> Update: lambdabot installed and working successfully.  I changed tactics and installed everything in a local user directory after a fresh ghc install and it started working properly.
19:24:54 <BMeph> pumpkin: Yeah. It'll work in certain finite cases, but not in all, which seems stupid to me.
19:25:07 <travisbrady> pumpkin: so after deriving Enum how do i actually generate that list?  sorry, googling isn't helping much
19:25:20 <Axman6> beelsebob: you around?
19:25:35 <wli> kerlo: (t^2)^(1/6) differs from t^(1/3) on the negative real numbers.
19:25:35 <wli> It looks mostly like the last factor of 2 can't be removed when the numerator and denominator have common factors.
19:25:35 <wli> I could just be on crack and it doesn't apply because you're forced to write the square under the radical if you want that.
19:25:36 <pumpkin> travisbrady: map toEnum [0..] :P or something lame like that
19:25:36 <wli> But sup { x in R : x^6 <= t^2 } is definitely not sup { x in R : x^3 <= t }
19:25:40 <wli> Anyone else see weird bursts?
19:25:44 <BMeph> travisbrady: enumFrom -- hint, hint! ;)
19:26:59 <travisbrady> pumpkin, BMeph: thanks, i had seen that but only saw examples for Integers and the like, didn't understand how one could say "from, to" with regard to categories for which there is no natural ordering
19:28:28 <Eridius> @src enumFrom
19:28:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:29:09 <BMeph> travisbrady: It's because Haskell is sloppily-described in this case. By definition, "Class 'Enum' defines operations on sequentially ordered types."
19:29:51 <Eridius> and derived Enum types define the nullary constructors as being numbered left-to-right from 0 through n-1
19:30:35 <BMeph> travisbrady: I'd class Enum not being a subtype of Ordering as a monic fail - maybe literally. ;p
19:30:41 <travisbrady> is there anything that can be done for nullary constructors?  i'm trying to make a Card type
19:31:39 <Eridius> travisbrady: you mean for non-nullary constructors?
19:31:47 <travisbrady> Eridius: yes
19:31:56 <Eridius> you can use the [a] monad and the Enum operators on its component types
19:31:59 <travisbrady> sorry, has that backwards
19:32:29 <BMeph> Er, s/Ordering/Ord/
19:32:33 <Eridius> in the Dog example, something like enumFrom Color >>= \color -> enumFrom Terrier >>= \breed -> Dog breed color
19:32:45 <Eridius> *return Dog breed color
19:33:37 <romildo> Hi.
19:34:20 <romildo> Is it possible to write a lambda expression with more than one rule?
19:34:37 <romildo> For instance, given the function
19:34:47 <romildo>   len [] = 0
19:34:55 <romildo>   len (_:xs) = 1 + len xs
19:35:08 <ddarius> romildo: Use case.  You can't have alternatives in the pattern in a lambda abstraction.
19:35:22 <romildo> Is it possible to rewrite it using a lambda expression?
19:35:37 <pumpkin> case x of
19:35:50 <mmorrow> romildo: it's not
19:36:04 <mmorrow> but you can make a function like:
19:36:17 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
19:36:18 <lambdabot>  Defined.
19:36:40 * BMeph cyber-glances at ddarius, and sighs (sym)pathetically.
19:36:41 <mmorrow> len = list 0 (\_ xs -> 1 + len xs)
19:37:01 <ddarius> BMeph: ?
19:37:17 <Valodim> bromance?
19:37:46 <BMeph> "[19:35] <ddarius> romildo: Use case.  You can't have alternatives in the pattern in a lambda abstraction.
19:37:46 <BMeph> [19:35] <romildo> Is it possible to rewrite it using a lambda expression?"
19:39:45 <bd_> romildo: if you want to do that with lambdas
19:40:00 <bd_> romildo: let len = \l -> case l of [] -> 0; (_:xs) = 1 + len xs in len
19:40:08 <bd_> > (let len = \l -> case l of [] -> 0; (_:xs) = 1 + len xs in len) [1]
19:40:09 <lambdabot>   <no location info>: parse error on input `='
19:40:12 <bd_> err
19:40:18 <bd_> > (let len = \l -> case l of [] -> 0; (_:xs) -> 1 + len xs in len) [1]
19:40:19 <lambdabot>   1
19:40:23 <bd_> -> not =
19:40:39 <Valodim> -> /= =?
19:40:45 <romildo> I am looking for alternatives in the pattern in a lambda expression, but I was already told it does not exist in Haskell.
19:40:48 <bd_> heh
19:41:17 <bd_> romildo: well, yes. A lambda expression has only one pattern. At toplevel there's a shortcut to specify multiple patterns, but not in a lambda expression
19:41:27 <bd_> but if you need to do that, you can use a case, which is equivalent
19:41:32 <bd_> or you can define the function elsewhere
19:41:38 <ddarius> bd_: Not top-level, any function definition.
19:41:55 <bd_> ddarius: er, right. Point is, not an expression :)
19:42:52 <Valodim> I always wondered why there was no way to have guards in a case, or something equivalent
19:42:58 <romildo> So I am going to do the patter matching in a case expression in the body of the lambda expression.
19:43:06 <romildo> Thanks for the tips.
19:43:38 <mmorrow> a little unsafeCoerce does wonders for getting STRef's out of the ST monad..
19:43:53 <bd_> mmorrow: what devilry is this? :)
19:44:14 <mmorrow> bd_: heh, i'll paste some of the debauchery
19:47:00 <ddarius> Valodim: You can have guards in a case ... (?)
19:47:38 <Valodim> ..you can?
19:48:21 <ddarius> > case 3 of _ | pi == 4*atan 1 -> 5
19:48:23 <lambdabot>   5
19:48:55 <skorpan> is that new in 6.10 or something?
19:49:08 <pumpkin> guards?
19:49:16 <pumpkin> where else do you use them?
19:49:26 <pumpkin> function pattern matches and case pattern matches?
19:49:39 <skorpan> fun x | x < 5 = "howdy"
19:49:41 <skorpan> there
19:49:50 <skorpan> i don't think i ever used them anywhere else
19:50:08 <Valodim> wait they can be used in case statements? now that's nice to know
19:50:12 <sw17ch> @seen dons
19:50:13 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 6h 53m 43s ago.
19:50:19 <skorpan> Valodim: not statements ;)
19:50:34 <Valodim> expressions :P
19:50:54 <pumpkin> is code.haskell.org down?
19:51:17 <skorpan> pumpkin: http://downforeveryoneorjustme.com/
19:51:17 <Valodim> now that's good to know. I never ever saw guards used in a case, neither tutorials nor _, so I assumed it didn't work.. never gave it a shot, though
19:51:21 <Valodim> sweet
19:51:38 <pumpkin> skorpan: guess so :)
19:51:53 <skorpan> pumpkin: but the weird thing is that i can actually access it :P
19:51:59 <pumpkin> :o
19:52:00 <skorpan> Welcome to code.haskell.org
19:52:00 <skorpan> This is part of the Haskell community service.
19:52:09 <skorpan> although the "or just me" page says it's down
19:52:10 <Axman6> pumpkin: made another benchmark faster :)
19:52:15 <pumpkin> Axman6: sweet
19:52:30 <pumpkin> Axman6: you can trivially make the mandelbrot a lot faster on u32q btw ;)
19:52:39 <pumpkin> if someone hasn't done it already
19:52:49 <Axman6> but i can't test it against the C one because i don't have openmp instaled :\
19:53:14 <mmorrow> bd_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1842#a1842
19:53:31 <pumpkin> mmorrow: wow
19:53:38 <mmorrow> fork and write to a "Chan" (Q) in pure code !!@
19:53:56 <mmorrow> ("pure" code)
19:54:13 <pumpkin> you aliased unsafeCoerce to make yourself feel better about using it?
19:54:15 <mmorrow> (and threadDelay, killThread as well)
19:54:26 <mmorrow> pumpkin: naw, just so it'd be shorter to write ;)
19:54:41 <Axman6> anyway, lecture time. o/
19:54:42 <ddarius> mmorrow: Why not use IO and unsafePerformIO in that case?  Why use ST at all?
19:54:47 <mmorrow> also, since it's not unsafe here
19:54:50 <JamesIry> RWH wins the jolt award: http://tinyurl.com/cavm9u
19:54:57 <Axman6> whoot :D
19:55:07 <pumpkin> nice
19:55:13 <mmorrow> ddarius: no reason in particular
19:56:10 <JamesIry> I'm am all aglow with love for the world that Real World Haskell won and Programming in Scala made the finalist list on a mainstream productivity based award.  There is hope for humanity.
19:56:14 <mmorrow> ddarius: adding the atomicModifyIORef->STRef thing + fork/etc was an afterthought, i initially started out with just the Ref
19:57:09 <ddarius> bos31337, dons: Congrats.
19:57:45 <mmorrow> ddarius: ?
19:57:57 <gwern> should we feel insulted rwh didn't get 'productivity winner'? :)
19:58:00 <mmorrow> ah
19:58:16 <mmorrow> oh, i missed  JamesIry's comment
19:58:21 <JamesIry> gwern: I think that means "runner up"
19:59:11 <ddarius> dons: You can now call yourself the author of an award-winning book.
20:00:07 <wli> dons: Congratulations!
20:00:22 <pumpkin> no cosmicray today
20:00:26 <pumpkin> or we could congratulate them all!
20:00:42 <kyagrd> Jolt Award !
20:00:43 <JamesIry> @tell cosmicray congratulations!
20:00:44 <pumpkin> but meanwhile, congrats to bos31337 and dons :)
20:00:44 <lambdabot> Consider it noted.
20:11:25 <porges> @seen dons
20:11:25 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 7h 14m 55s ago.
20:12:51 <wli> I guess I should switch projects since I've made some progress on this one and am now stuck on it.
20:24:19 <twb> Is cho:/home accessible via AFS as well as sshfs?
20:25:02 <Chani> am I crazy for trying to build a tree top-down in haskell?
20:25:19 * Chani is trying to complete an assignment that wasn't written with functional languages in mind
20:26:02 <wli> I just tried and failed. I was trying to do bfs :: BinaryTree t -> BinaryTree (Int, t) to label nodes in breadth-first order.
20:26:09 <Eridius> Chani: maybe instead of building a tree, you should build a sequence of functions that each take a child and build the parent?
20:26:24 <Eridius> oh wait, that only works linearly
20:26:37 <Eridius> well no, it works if all your leafs are actually nodes with an empty child list
20:26:41 <Eridius> so then you evaluate the thing by passing []
20:26:50 <Eridius> although that does muddy the Binary data structure
20:27:08 <Chani> I've got a whole bunch of data structures, unfortunately
20:27:36 <Chani> maybe I should rewrite it so that they're all different productions of fewer data structures
20:27:48 <Eridius> your function could be Maybe BinaryTree t -> BinaryTree t, and if you hand it Nothing it produces a Leaf otherwise it produces a Node
20:27:58 <Chani> it's not a BinaryTree, though
20:28:00 <Eridius> so then your top-down function builds a bottom-up chain of functions
20:28:09 <wli> Eridius: That was my example.
20:28:09 <Eridius> oh I got confused, wli's doing Binary Tree
20:28:24 <Eridius> Chani: what's your data structure?
20:28:30 <Chani> I'm trying to build an LF(1) parser that outputs some sort of treelike structure
20:29:05 <Chani> right now I've got 18 metasymbols... urgh
20:29:21 <Eridius> ok, yeah, your situation is a bit more complicated
20:29:24 <Eridius> good luck ;)
20:29:35 <Chani> and I don't want to have to turn everything into Maybe this Maybe that Maybe theother
20:29:50 <jmcarthur> I'm finally playing with ViewPatterns and like it, but am I _always_ going to get warnings about overlapping and non-exhaustive patterns wherever I use view patterns with Wall?
20:30:05 <Eridius> Chani: ignore the Maybe bit
20:30:27 <Eridius> the basic advice, coming from an admitted Haskell newb, is to build a chain of functions that you "run" to produce your tree
20:30:35 <Chani> Eridius: if I don't have Maybes then I can't construct the parent until I have every child constructed...
20:30:39 <jmcarthur> oh wait, i get what's going on
20:30:51 <Eridius> Chani: right, which is why you produce a chain of lambdas instead
20:30:52 <jmcarthur> i'm using a partial function to supply my views
20:30:56 <Chani> hrm
20:30:58 <Eridius> Chani: look at how ShowS works
20:30:59 <jmcarthur> nevermind then :)
20:31:15 <Chani> Eridius: this would be so much easier if I wasn't trying to implement the specific type of parser the teacher wants
20:31:24 <Eridius> it does the exact same thing, a ShowS is actually a function String -> String, and you can use it to output strings left-to-right and avoid the cost of the ++ operator
20:31:30 <Chani> it's very non-Haskell
20:31:59 <Eridius> because when you use ShowS you're actually building up a chain of functions, and when you run it (by handing it "") it runs them in reverse to build the resulting string right-to-left
20:32:00 <Chani> oh?
20:32:10 <Chani> where's ShowS?
20:32:13 <Sekaino> Easter egg:
20:32:16 <Eridius> in the prelude
20:32:19 <Sekaino> @penis 1,1,2,3
20:32:20 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
20:32:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
20:32:30 <Pseudonym> Eridus: No, it's not right-to-left.
20:32:33 <Pseudonym> It's lazy, remember?
20:32:46 <Eridius> Pseudonym: I'm horribly glossing over things ;)
20:32:50 <Pseudonym> :-)
20:32:57 <Pseudonym> It's important, because it impacts complexity.
20:33:06 <Pseudonym> You don't construct the whole string if you don't use it all.
20:33:06 <ddarius> Neither laziness nor right-to-leftness really matter for ShowS
20:33:31 <Pseudonym> > take 5 (showString "Hello world . undefined $ "")
20:33:32 <lambdabot>   <no location info>:
20:33:32 <lambdabot>      lexical error in string/character literal at chara...
20:33:33 <Eridius> it's like saying foldr works right-to-left
20:33:38 <Pseudonym> > take 5 (showString "Hello world" . undefined $ "")
20:33:39 <lambdabot>   "Hello"
20:33:41 <Pseudonym> Right?
20:33:51 <mmorrow> pumpkin: looks like ghc just reverted from using SSE instructions on osx to regular x87 fp code, since it doesn't 16-byte align stuff (thought you might find this interesting)
20:34:00 <sutats> Can "map ((++ "'") . show) [1..9]" be rewritten less uglily?
20:34:02 * mmorrow is darcs pulling
20:34:06 <pumpkin> mmorrow: ?
20:34:16 <Pseudonym> > map ((++ "'") . show) [1..9]
20:34:17 <lambdabot>   ["1'","2'","3'","4'","5'","6'","7'","8'","9'"]
20:34:32 <pumpkin> mmorrow: how does it not 16-byte align things?
20:34:33 <Pseudonym> [ show n ++ "'" | n <- [1..9] ]
20:34:34 <Pseudonym> Perhaps?
20:34:39 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1843#a1843
20:34:48 <Pseudonym> That looks a bit less ugly to me.
20:34:51 <mmorrow> pumpkin: i'm not sure how exactly
20:34:55 <pumpkin> mmorrow: lame :/
20:34:55 <sutats> Pseudonym: That looks much more readable for sure.
20:35:15 <Eridius> > take 5 $ foldr (:undefined) "Hello World" "Random string"
20:35:16 <ddarius> > map (($"'") . shows) [1..9]
20:35:17 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
20:35:18 <lambdabot>   ["1'","2'","3'","4'","5'","6'","7'","8'","9'"]
20:35:40 <Chani> eh... "Show a => a -> ShowS" doesn't really tell me anything. I don't see what you were getting at, or how shows works
20:35:45 <Eridius> oops, I did the wrong fold lambda
20:35:56 <Eridius> @type SHowS
20:35:57 <sarh> > map (:"'") ['1'..'9'] -- depending on if you want 1..9 specifically
20:35:57 <lambdabot> Not in scope: data constructor `SHowS'
20:35:58 <lambdabot>   ["1'","2'","3'","4'","5'","6'","7'","8'","9'"]
20:35:59 <Eridius> @type ShowS
20:36:00 <lambdabot> Not in scope: data constructor `ShowS'
20:36:02 <ddarius> @src ShowS
20:36:02 <lambdabot> type ShowS = String -> String
20:36:06 <Eridius> ,,src ''ShowS
20:36:07 <lunabot>  luna: parse error on input `src'
20:36:10 <Eridius> ack, I can't type today
20:36:11 <sutats> ddarius: Interesting, never really thought about that. Thanks.
20:36:13 <Eridius> anyway, see what lambdabot said
20:36:33 <sutats> sarh: Yeah, it's those and only those.
20:36:35 <Chani> "type ShowS = String -> String
20:36:37 <Chani> ?
20:36:39 <Chani> Eridius: that?
20:36:42 <Eridius> Chani: yes
20:36:44 <Chani> what does that tell me?
20:36:47 <ddarius> sutats: It's not any more readable.  It is potentially more efficient (albeit probably not significant in this case)
20:36:54 <Chani> it takes a string and returns a string
20:37:01 <Eridius> Chani: right
20:37:08 <Chani> so?
20:37:26 <Eridius> so it lets you write display code in a left-to-right fashion
20:37:26 <mmorrow> ooh, interesting:
20:37:31 <Eridius> without incurring the overhead of appending strings together
20:37:32 <mmorrow>    - add newAlignedPinnedByteArray# for allocating pinned BAs with arbitrary alignment
20:37:34 <sutats> ddarius: Yeah, I like sarh's version with the tail consing.
20:37:35 <Chani> what does it *do* with the string it takes?
20:37:35 <sarh> > shows <$> [1..9] <*> ["'"]
20:37:36 <lambdabot>   ["1'","2'","3'","4'","5'","6'","7'","8'","9'"]
20:37:40 <mmorrow>    - the old newPinnedByteArray# now aligns to 16 bytes
20:37:50 <sutats> ddarius: Or whatever the term really is (I'm probably mangling the terms).
20:37:52 <Eridius> Chani: prepends another string on to the beginning and returns it
20:37:58 <Chani> o.0
20:38:04 <Eridius> > shows 3 "foo"
20:38:04 <Chani> ...what other string?
20:38:05 <lambdabot>   "3foo"
20:38:19 <Eridius> whatever string was used to build the ShowS
20:38:22 <Eridius> that's the whole point here
20:38:29 <Chani> I'm missing something
20:38:42 <Chani> > shows "foo"
20:38:43 <lambdabot>       Overlapping instances for Show (String -> String)
20:38:43 <lambdabot>        arising from a...
20:38:44 <Eridius> yes. ShowS isn't the type of functions, it's the type of lambdas that are created by functions
20:38:46 <Eridius> @type shows
20:38:47 <lambdabot> forall a. (Show a) => a -> String -> String
20:39:13 <Eridius> that would look better as (Show a) => a -> ShowS
20:39:22 <Chani> oh
20:39:27 <Eridius> shows is like show except it returns a ShowS
20:39:29 <Pseudonym> @src Show
20:39:29 <lambdabot> class  Show a  where
20:39:29 <lambdabot>     showsPrec :: Int -> a -> ShowS
20:39:29 <lambdabot>     show      :: a   -> String
20:39:29 <lambdabot>     showList  :: [a] -> ShowS
20:39:31 * Chani doesn't understand lambdas yet
20:39:33 <Eridius> @src show
20:39:34 <lambdabot> show x = shows x ""
20:39:52 <Eridius> > shows 3 . shows 4 . shows 5 ""
20:39:54 <lambdabot>   Couldn't match expected type `a -> String'
20:39:56 <Pseudonym> Chani: A lambda is a function which doesn't have a name.
20:39:59 <Eridius> oops
20:40:03 <Eridius> > (shows 3 . shows 4 . shows 5) ""
20:40:05 <lambdabot>   "345"
20:40:09 <Chani> Pseudonym: yeah, I've read about it, I just haven't grokked it yet
20:40:23 <Chani> and I'm too strewssed out to learn much right now :/
20:40:27 <Pseudonym> > let f x = x + 1 in map f [1,2,3]
20:40:28 <lambdabot>   [2,3,4]
20:40:31 <Pseudonym> You understnad that, Chani?
20:40:32 <Chani> anyways. I should get back to this damn homework
20:40:59 <Chani> need to build something top-down... somehow...
20:41:06 <Pseudonym> > map (\x -> x + 1) [1,2,3]  -- Same thing, only without naming f.
20:41:07 <lambdabot>   [2,3,4]
20:41:21 * Chani never liked things without names
20:41:23 <Eridius> @pl \x y -> y
20:41:23 <lambdabot> const id
20:41:36 <Eridius> ahh
20:41:36 <Pseudonym> The advantage, Chani, is that you only give important things names.
20:41:45 <Pseudonym> I name all my pets, but I don't name all my pens.
20:42:04 <Eridius> > take 5 $ foldr ((:undefined) . const id) "Hello world" "random string"
20:42:06 <lambdabot>   Couldn't match expected type `b -> b'
20:42:09 <Eridius> bah, I fail again
20:42:14 <kerlo_> Chani: ShowS is just a type, not a function.
20:42:33 <Gracenotes> also known as (flip const)
20:43:01 <sarh> > let f = (\x -> x + 1) in map f [1, 2, 3]  -- there now it's "named" Chani
20:43:02 <lambdabot>   [2,3,4]
20:43:13 <Eridius> Gracenotes: that makes sense
20:43:50 <Chani> maybe I can build some other data structure, and *then* build a tree from it once it's complete... I can't just pretend it's complete because I have to keep passing things down in a weird way, stupid algorithm really wasn't meant to be recursive...
20:44:00 <Gracenotes> const id is a bit more.. obscure
20:44:03 <Gracenotes> creative though
20:44:10 <Eridius> > take 5 $ foldr (\x y -> y:undefined) "Hello world" "random string"
20:44:11 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
20:44:11 <lambdabot>        Expect...
20:44:18 <Eridius> yarr, I am just full of fail today
20:44:31 <Eridius> Chani: yes, that's exactly what I'm suggesting you do
20:44:36 <Eridius> except the "other data structure" is a chain of lambdas
20:44:37 <mmorrow> Chani: translating imperative specs of algos into functional implementations is one of the things that takes a little while to figure out
20:44:38 <Pseudonym> I'm usually not full of occurs check failure, though.
20:44:49 <Chani> Eridius: huh
20:45:25 <mmorrow> Chani: and even when you've got it figured out (to some extent or another), it's usually not trivial
20:45:26 <Eridius> Chani: let's go back to ShowS. In an imperative world, if you wanted to append a bunch of strings together, you'd create the first string, then add the second, then add the third, etc, right?
20:45:40 <mmorrow> Chani: (but it's always doable)
20:45:41 <sarh> or use a StringBuilder
20:45:43 <Eridius> say in ruby, you'd do "string 1" + "string 2" + "string 3"
20:46:00 <Chani> mmorrow: oh lovely
20:46:08 <Chani> Eridius: ok...
20:46:20 <Chani> yay! food has appeared beside me
20:47:04 <Eridius> Chani: you can do "string 1" ++ "string 2" ++ "string 3" in haskell, but (assuming that this isn't actually all on one line, because the fixity of (++) helps in that case) that will be inefficient
20:47:17 <Eridius> since it has to rebuild the string each time it appends something to the end
20:47:52 <Eridius> if you use ShowS, instead of rebuilding the string, it just chains another ShowS, which when evaluated skip the string appends
20:48:51 <Eridius> eh, I suck at explaining
20:48:52 <Eridius> at least today
20:48:53 <Eridius> my brain is prematurely fried
20:49:03 <Eridius> Chani: you should stop trying to decipher my gibberish
20:49:10 <Eridius> let someone else help you ;)
20:49:17 <Chani> I think my brain just caught on to something, maybe, actually
20:50:10 <Eridius> > foldr1 (.) [shows "one", shows "two", shows "three"] ""
20:50:11 <lambdabot>   "\"one\"\"two\"\"three\""
20:50:30 <Eridius> > foldr1 (.) [showString "one", showString "two", showString "three"] ""
20:50:32 <lambdabot>   "onetwothree"
20:50:50 <Chani> so... my parse function keeps calling itself to slowly parse the data in suboptimal way (I learnt an easier parsing method in a different class but that's not waht this assignment is about)...
20:51:05 <Chani> right now it passes down a Program object...
20:51:12 <mmorrow> @type foldr (.) id . zipWith ($) (repeat shows)
20:51:13 <lambdabot> forall a. (Show a) => [a] -> String -> String
20:51:32 <mmorrow> @type [($), id]
20:51:33 <lambdabot> forall a b. [(a -> b) -> a -> b]
20:51:38 <mmorrow> @type foldr (.) id . zipWith id (repeat shows)
20:51:40 <lambdabot> forall b. (Show b) => [b] -> String -> String
20:52:21 <mmorrow> > let foo = foldr (.) id . zipWith id (repeat shows) in foo [0..9] ""
20:52:22 <lambdabot>   "0123456789"
20:52:52 <Chani> what if it passed down some kind of function that took as arguments the two objects needed to build the Program object...? and then each iteration that gets the chance to add something to the program adds another function.... err... my only problem is I don't know what to do when one function has all the arguments it needs and I have to po up and start adding aruments to hte parent again....
20:53:29 <Chani> maybe it'll make more sense if I show a bit of the code
20:53:31 <Chani> data Program = Program Dclrow Stmrow
20:53:44 <Chani> data Dclrow = Dcl ExtendDclrow
20:53:59 <Chani> er, wait
20:54:08 <Chani> data Dclrow = Dclrow Dcl ExtendDclrow
20:54:26 <Chani> data ExtendDclrow = ExtendDclrow Dcl ExtendDclrow | EndDclrow
20:54:29 <Chani> ...and so on
20:54:33 <mmorrow> Chani: keep in mind that all ADTs in haskell are essentially trees
20:54:39 <Chani> ADT?
20:54:44 <mmorrow> abstract data type
20:54:47 <mmorrow> data Foo = ...
20:54:51 <Chani> ah
20:55:02 <mmorrow> well, they're trees if they're recursive
20:55:06 <travisbrady> how would I make a Int-ish type with minBound = 2 and maxBound = 10?  my attempt here doesn't behave as I'd expect http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2331#a2331
20:55:07 <Chani> mmorrow: yes, so at the end my code has to spit out a Program
20:55:20 <bd_> They're still trees if they're not recursive, they're just bounded in depth.
20:55:28 <Chani> but it's only allowed to eat one token at a time...
20:55:38 <mmorrow> bd_: true
20:55:44 <bd_> also, hi, Chani
20:55:48 <Chani> o hai
20:55:55 <Chani> bd_: LTNS :)
20:56:10 <bd_> indeed
20:56:23 <bd_> What's with the idling and the not-not-idling? :)
20:56:29 <Chani> haha :)
20:57:04 <Chani> I keep forgetting I'm still on sine... too many other things eating my time
20:57:24 <Chani> like this stupid homework ;P
20:57:37 <wli> I'm still trying to figure out how to label trees in breadth-first order.
20:57:44 <Chani> ok, so... hrm...
20:58:38 <wli> Recursive ascent parsers sound relevant here.
20:59:17 <ddarius> > let tree = Node 'a' [Node 'b' [Node 'c' [], Node 'd' []], Node 'e' []]; bfn (Node a cs) l xs = (Node (l, a) cs',  ys ++ concat yss) where (cs', xs') = splitAt (length cs) xs; (ys,yss) = unzip $ map (\t -> bfn t (l+1) xs') cs in fst $ fix (bfn tree 0 . snd)
20:59:18 <lambdabot>   Node {rootLabel = (0,'a'), subForest = [Node {rootLabel = (1,'b'), subFores...
20:59:28 <Chani> my problem here is... say I finally get enough data to make a complete Dclrow. how do I get the next bit of data to go into creating a StmRow instead of haskell trying to add it to the already-complete Dclrow? this isn't a case where I have all the data already there and can put ( ) around it as needed
20:59:42 <ddarius> Stupid piece of shite.
20:59:59 * ddarius hates Data.Tree
21:00:08 <Chani> wli: I made a recursive descent parser for my other class. this one has to be an LF(k) parser, which seems to be something the teacher made up :P
21:01:33 <Chani> maybe I should make an array of stuff and have a function that eats the array and makes a tree out of it. then I can just pass the completed array to that function at the end.
21:01:54 <Chani> and if I write that successfully then I'll probably see a way to write something cooler oncce it's done
21:02:01 * bd_ has no idea what a Dclrow or StmRow are :)
21:02:21 <ddarius> > let display (Node a cs) = shows a . showParen True (foldr (.) id . map display cs); parenstree = Node 'a' [Node 'b' [Node 'c' [], Node 'd' []], Node 'e' []]; bfn (Node a cs) l xs = (Node (l, a) cs',  ys ++ concat yss) where (cs', xs') = splitAt (length cs) xs; (ys,yss) = unzip $ map (\t -> bfn t (l+1) xs') cs in display (fst $ fix (bfn tree 0 . snd)) ""
21:02:22 <lambdabot>   Not in scope: `tree'
21:02:25 <Chani> that's probaly the best way to figure it out... one bit at a time, instead of trying to produce the best possible parser right away
21:02:34 <ddarius> > let display (Node a cs) = shows a . showParen True (foldr (.) id . map display cs); tree = Node 'a' [Node 'b' [Node 'c' [], Node 'd' []], Node 'e' []]; bfn (Node a cs) l xs = (Node (l, a) cs',  ys ++ concat yss) where (cs', xs') = splitAt (length cs) xs; (ys,yss) = unzip $ map (\t -> bfn t (l+1) xs') cs in display (fst $ fix (bfn tree 0 . snd)) ""
21:02:36 <lambdabot>   Couldn't match expected type `String -> [a -> a]'
21:02:40 <Chani> bd_: I defined them just before you appeared :)
21:02:41 <bd_> but in an exercise like that, if you have an idea how to do it, it's probably worth a shot, as long as you're interested in hearing the 'correct' way to do it once you hack something into working :)
21:02:45 <bd_> oh :)
21:02:53 <ddarius> > let display (Node a cs) = shows a . showParen True (foldr (.) id $ map display cs); tree = Node 'a' [Node 'b' [Node 'c' [], Node 'd' []], Node 'e' []]; bfn (Node a cs) l xs = (Node (l, a) cs',  ys ++ concat yss) where (cs', xs') = splitAt (length cs) xs; (ys,yss) = unzip $ map (\t -> bfn t (l+1) xs') cs in display (fst $ fix (bfn tree 0 . snd)) ""
21:02:55 <lambdabot>   "(0,'a')((1,'b')((2,'c')()(2,'d')())(1,'e')())"
21:03:00 <ddarius> Woot.
21:03:09 <Chani> ok, time to write this before i forget
21:03:16 <bd_> hm, you didn't define Stmrow
21:03:36 * ddarius can't believe he wrote bfn correctly the first time.
21:03:59 <mae> hallo!
21:04:58 <wli> That's a different problem. I wrote the analogue of that correctly the first time too.
21:05:39 <wli> data BinaryTree t = Node t (BinaryTree t) (BinaryTree t) | Nil ; bfs :: BinaryTree t -> BinaryTree (Int, t) is another story.
21:06:32 <ddarius> wli: Um, how is it "another story".  A rose tree is certainly more complicated than and capable of representing a (non-empty) binary tree.
21:06:51 <ddarius> I'd have much preferred using a binary tree.
21:07:18 <wli> You seem to be doing something else after all.
21:07:27 <ddarius> What is an example run of bfs?
21:08:42 <wli> Node 'x' (Node 'y' Nil Nil) (Node 'z' Nil Nil) --> Node (1, 'x') (Node (2, 'y') Nil Nil) (Node (3, 'z') Nil Nil)
21:10:03 <wli> A rose tree version is fine too for these purposes.
21:11:52 <wli> Maybe you did do it.
21:12:06 <ddarius> bfn labels by level
21:12:18 <ddarius> s/by/with
21:12:29 <wli> I got thrown off by the display function.
21:13:49 <wli> Okay, slightly different, but I'm still impressed.
21:14:49 <mmorrow> wli: breadth-first numbering (algo from the okasaki paper, but not okasaki's algo) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=676
21:15:35 <mmorrow> it makes essential use of laziness and letrec
21:15:43 <sw17ch> @seen dons
21:15:43 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 8h 19m 14s ago.
21:16:24 <ddarius> Yeah, by label-with-level function is circular.
21:16:35 <ddarius> s/by/my
21:17:05 <wli> mmorrow: I can't smoke out how it works (as usual when functions named "go" appear).
21:17:08 <benl23> Anyone here with admin privs on code.haskell.org/nun? A renegade process needs to be killed.
21:17:39 <SamB> dcoutts:
21:17:41 <SamB> Igloo_:
21:17:44 <wli> It replaces the data instead of pairing but that can probably be easily fixed.
21:18:01 <benl23> SamB: sleeping i expect
21:18:05 <mmorrow> wli: heh, check out the presentation in that paper of it, i slightly modified (syntactically, not functionally) it with that foldl
21:18:24 <SamB> @where admins
21:18:25 <lambdabot> I know nothing about admins.
21:18:26 <SamB> @where admin
21:18:26 <lambdabot> I know nothing about admin.
21:18:30 <benl23> @localtime Igloo_
21:18:32 <lambdabot> Local time for Igloo_ is Thu Mar 12 04:18:31 2009
21:18:36 <benl23> indeed
21:18:39 <SamB> @fact admins
21:18:39 <lambdabot> I know nothing about admins
21:18:41 <SamB> @fact admin
21:18:41 <lambdabot> I know nothing about admin
21:18:46 <SamB> @where ops
21:18:46 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
21:18:53 <SamB> maybe one of them?
21:18:58 <glguy> ?COP
21:18:58 <lambdabot> Unknown command, try @list
21:18:59 <benl23> @localtime dons
21:19:01 <lambdabot> Local time for dons is Wed Mar 11 21:18:10 2009
21:19:02 <mmorrow> wli: http://www.eecs.usma.edu/webs/people/okasaki/icfp00.ps
21:19:31 <benl23> sucks @ me in pacific timezone
21:19:36 <SamB> not that they all have root, but it seems likely that someone with root on code.haskell.org who hangs out here would be in that list ;-)
21:21:49 <glguy> Who'd have guessed that it was darcs that was using all of the CPU?
21:22:06 <allbery_b> hm?
21:22:10 <SamB> um, isn't darcs the usual suspect ?
21:23:14 <glguy> allbery_b, on code.haskell.org
21:23:14 <allbery_b> oh, sorry, no ops on code.haskell.org
21:23:15 <glguy> I had them, but they were removed for the sake of removing them and isolating the ability to fix problems like this
21:23:15 <SamB> suckage
21:23:15 <SamB> that's a pretty bad sake
21:23:15 <mmorrow> wli: all you have to change in that to get breadth-first labeling is http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=676#a1844
21:23:19 <mmorrow> (like 3 chars)
21:23:54 <mmorrow> bfl :: Tree a -> Tree (a, Int)
21:26:12 <ddarius> Actually, bfn is trivial.
21:26:40 <travisbrady> anyone have any pointers on creating an Int-like type that only exists from 2 to 10?
21:26:40 <wli> Trivial is enough to blow me away.
21:26:51 <ddarius> I did it in a really crazy way.
21:27:09 <mmorrow> ddarius: it's trivial if you already know how to do it ;)
21:27:27 <allbery_b> travisbrady: you really want dependent types, but you can play type-level tricks or use runtime tests
21:27:53 <wli> I can't figure out how to reassemble the tree after taking it apart to figure out the numbers to pair up with.
21:27:58 <ddarius> mmorrow: No, it's trivial to write in a sane way. (I'm talking about what I wrote, not what Okasaki wrote.)
21:28:38 <mmorrow> ddarius: sure, in that sense it's trivial
21:28:47 <kniu> whoah, west point?
21:29:01 <travisbrady> allbery_b: thanks, dependent types look hard
21:29:03 <bos> woo! RWH won a Jolt Award tonight!
21:29:18 <shapr> Yay! link?
21:29:21 <mmorrow> bos: congrats
21:29:29 <travisbrady> bos: awesome, well deserved!
21:29:44 <bos> shapr: no link yet
21:29:47 <travisbrady> allbery_b: what do you mean by type-level tricks?
21:29:53 * bos `ap` pub
21:29:58 <shapr> aww
21:30:11 <ddarius> shapr: There's a link above.
21:30:25 <shapr> oh?
21:30:31 <Valodim> ...way above
21:30:43 <ddarius> shapr: Reverse search your buffer for "Congrats"
21:31:29 <mmorrow> ddarius: you'd make a great tech-help phone operator
21:32:22 <mmorrow> i bet you'd last maybe 20 min or one phonecall (whichever comes first) before you're fired :)
21:33:01 * mmorrow laughs picturing it
21:33:25 <Valodim> for a haskell helpline, tips like "reverse search your buffer for congrats" sounds entirely reasonable to me
21:33:42 <mmorrow> Valodim: that's not the only context i'm going on :)
21:34:00 <mmorrow> (and i'm not talking about a haskell helpline either)
21:34:15 <kniu> 1-800-HASKELL
21:34:22 <shapr> yay!
21:34:47 <Valodim> teach \bot to speak, add a nice waiting melody and voila
21:34:51 <Nafai> Hey shapr!
21:34:53 * mmorrow pictures a 53 year old woman whose internet explorer "just stopped working", and ddarius answering the phone
21:34:56 <shapr> hiya Nafai!
21:35:11 <pumpkin> lol
21:35:15 <Nafai> shapr: So do you know johnw from #emacs?
21:35:19 <shapr> of course!
21:35:22 <shapr> He's an awesome guy.
21:35:33 <Nafai> He has just recently become obsessed with Haskell :)
21:35:39 * shapr cackles evilly
21:35:53 <Nafai> Yeah
21:36:03 <Nafai> And, of course, he's going to pick it up quicker than me
21:36:07 <Nafai> Darn smart people
21:36:23 <shapr> Well, it's just a matter of spending a few minutes each day working on stuff.
21:36:40 <shapr> Perhaps you can talk to him about stuff he's learning and use that to boost your own learning?
21:36:52 <Nafai> Yeah, I think so
21:44:06 <allbery_b> travisbrady: none of it's easy. type level tricks are things like defining type level naturals but in such a way that taking the 8th successor is a type error., easier is just defining a normal ADT with 8 constructors. but in both cases you get to roll your own Num instance
21:45:03 <travisbrady> allbery_b: ahh, thank you.  i'd thought of the 8 constructor thing, but i had wanted to get the arithmetic for free
21:45:42 <allbery_b> I think you can simulate that with a newtype, but going beyond the bounds then becomes a runtime error
21:48:21 <cads_> what is the type of the del operator/
21:50:33 <allbery_b> @hackage type-level
21:50:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level
21:52:04 <allbery_b> might be useful for implementing a type that only supports (in type-level's syntax) D2 .. D10
21:52:15 <allbery_b> er, no. D2 .. D1 :*: D0
21:55:10 <pumpkin> any news on dibblego?
21:56:44 <cjb> pumpkin: nope.  #haskell-blah and #scala have been talking about it, rather than here.
21:57:08 <pumpkin> yeah, I know, was just wondering if anyone had heard anything more, didn't want to start a conversation on it
21:58:58 <Trinithis> is there a way to declare datatypes inside the ghci?
21:59:03 <pumpkin> unfortunately not
21:59:12 <Trinithis> :(
21:59:23 <pumpkin> ghci is essentially a big do expression that supports colon commands
22:35:47 <SubStack> @src gcd
22:35:47 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
22:35:47 <lambdabot> gcd x y = gcd' (abs x) (abs y)
22:35:47 <lambdabot>    where gcd' a 0  =  a
22:35:47 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
22:44:54 <dons> hey guys. just got word RWH won the Jolt Award for best technical book. Go Haskell!!
22:44:54 <lambdabot> dons: You have 11 new messages. '/msg lambdabot @messages' to read them.
22:50:34 <dons> we've not heard anything about dibblego?
22:50:47 <pumpkin> nope :/
22:50:54 <SamB> dons: was he sick?
22:50:58 <pumpkin> other than he wasnt at his house, and had taken his motorbike somewhere
22:51:33 <dons> :/
22:51:38 <Eridius> SamB: have you not heard? http://www.nabble.com/-scala--URGENT%3A-Please-read-if-you-have-any-information-about-Tony-Morris-td22462911.html
22:54:11 <Trinithis> > toRational 0.2
22:54:12 <lambdabot>   3602879701896397%18014398509481984
22:54:23 <Trinithis> is there a good way to get around that?
22:54:33 <pumpkin> > toRational (0.2 :: CReal)
22:54:34 <lambdabot>   * Exception: CReal.toRational
22:54:38 <pumpkin> boo :)
22:55:07 <Trinithis> > 0.2 :: Rational
22:55:08 <lambdabot>   1%5
22:55:11 <Trinithis> ah
22:55:16 <Trinithis> that'll work
22:55:39 <porges> toRational is thoroughly broken ;)
22:55:46 <Trinithis> haha
22:55:56 <mle> > 3602879701896397/18014398509481984
22:55:57 <lambdabot>   0.2
22:56:01 <mle> disagree.
22:56:02 <Trinithis> > 0.2 :: Int
22:56:03 <lambdabot>       No instance for (Fractional Int)
22:56:03 <lambdabot>        arising from the literal `0.2' ...
22:56:22 <Gracenotes> fromRational is better off... it's how literals are made into values
22:56:43 <Gracenotes> other way around isn't so hot :'(
22:57:15 <Trinithis> fromRational doesnt make too sense for x.x literals
22:57:22 <Trinithis> or is the ghc just smart
22:57:54 <Trinithis> and sees the literal 0.2 as 1%5
22:58:00 <Trinithis> and then does fromRAtional
22:58:57 <Gracenotes> I believe so.
22:59:30 <porges> mle: 3602879701896397/18014398509481984
22:59:30 <porges> 0.200000000000000011102230246251565404236316680908203125000000000...
23:00:16 <mle> porges: looks good to me
23:00:59 <mle> 1/5 isn't precisely representable in a binary floating point number.
23:01:29 <pumpkin> just round it to 1/4 ;)
23:01:29 <mle> that hairy fraction just shows the contents of the float-approximation for one floating point implementation.
23:01:36 <karlw> Does anyone know of a good ``advanced'' functional programming textbook?
23:01:36 <Ralith> hay guys
23:01:37 <mle> pumpkin: heh
23:01:40 <Trinithis> what's a 'binary' number? jk
23:01:45 <Ralith> I'm working on the euler project problems
23:01:54 <porges> mle: that's via bc :)
23:02:05 <Ralith> currently trying "take 1 $ filter (and . (\x -> map ((==0) . (x `mod`)) [1..20])) [1..]" for number five, but it's remarkably slow
23:02:08 <Ralith> any tips?
23:02:15 <ski> wli : SYN
23:02:23 <pumpkin> > 3602879701896397/18014398509481984 :: CReal
23:02:24 <lambdabot>   0.2000000000000000111022302462515654042363
23:02:31 <mle> porges: sure.  that implementation gives you arbitrary lengths of miscalculations
23:02:35 <karlw> Like SICP on steroids.
23:02:37 <Trinithis> Ralith: what's the problem you want to solve
23:02:44 <Ralith> What is the smallest number that is evenly divisible by all of the numbers from 1 to 20?
23:03:11 <porges> try [1,20...]
23:03:12 <pumpkin> Ralith: we can write out the code for you if you want
23:03:18 <loop> sounds like project euler..
23:03:18 <Trinithis> > factorial 20
23:03:19 <lambdabot>   Not in scope: `factorial'
23:03:19 <Ralith> pumpkin: that's no fun
23:03:21 <Ralith> porges: good plan
23:03:34 <Trinithis> > product [1..20]
23:03:35 <lambdabot>   2432902008176640000
23:03:37 <ski> > 2^4 * 3^2 * 5 * 7 * 11 * 13 * 17 * 19  -- Ralith
23:03:38 <lambdabot>   232792560
23:03:40 <pumpkin> foldl1 lcm [1..20]
23:04:00 <Gracenotes> karlw: there are many areas... :) there's SPJ's Implementing Functional Programming; TAPL and ATITAPL for theoretical stuff about types, lots of papers, etc.
23:04:04 <porges> pumpkin: don't give too much away :P
23:04:08 <Ralith> damnit guys -_-
23:04:19 <pumpkin> porges: I didn't!
23:04:21 <pumpkin> I left the > off :)
23:04:38 <Ralith> :P
23:04:39 <SubStack> number 5 as I recall
23:04:49 <Trinithis> what number is the problem? I'll see if ive done it before
23:05:00 * SubStack anticipates Trinithis's inquiry
23:05:05 <Ralith> number five, as both I and SubStack said.
23:05:21 <Trinithis> oh... i thought you meeant something else by 5
23:05:24 <Gracenotes> karlw: lots of stuff with cross-curricular topics like Categories for Types... and lots more papers....
23:06:23 <karlw> Gracenotes: My prof recommended ACM SIGPLAN on FP
23:06:30 <Ralith> pumpkin: so what'm I doing wrong?
23:06:35 <Trinithis> I don't have my solution anymore, but I bet I just brute forced it
23:06:46 <Gracenotes> ah. good for him
23:06:48 <Ralith> judging by how long mine's running, a brute force doesn't work.
23:06:53 <pumpkin> Ralith: I don't know :)
23:06:56 <Ralith> :P
23:07:00 <Gracenotes> -_-
23:07:06 <Trinithis> oh then i did something more clever
23:07:06 <pumpkin> if you show us what you're doing, maybe we can give you more of an idea
23:07:11 <Trinithis> lemme think for a moment
23:07:14 <Ralith> pumpkin: I did!
23:07:18 <pumpkin> oh
23:07:20 <Ralith> :P
23:07:31 <pumpkin> ah, didn't see that bit :)
23:08:04 <Ralith> oh hey!
23:08:08 <Ralith> my bruteforce returned.
23:08:16 <pumpkin> what did it give you?
23:08:17 <Ralith> passing it [20,40..] helped.
23:08:21 <Ralith> 232792560
23:08:27 <Ralith> so, the right number
23:08:27 <Trinithis> oh i think i just folded lcm over [1..20]
23:08:29 <Ralith> just very slowly
23:08:37 <Ralith> that's kinda cheating >_>
23:08:43 <Trinithis> > foldl1' lcm [1..20]
23:08:45 <lambdabot>   232792560
23:08:52 <pumpkin> better make it strict ;)
23:08:53 <Trinithis> that's the answer i bet
23:08:58 <Ralith> itis
23:09:15 <ski> (my computation above gave the same result)
23:09:25 <pumpkin> (so did mine)
23:09:41 <Ralith> ski: but it's unclear how you ended up with yours
23:09:51 <Gracenotes> > foldl1' lcm [1..40]
23:09:52 <lambdabot>   5342931457063200
23:10:06 <Gracenotes> > foldl1' lcm [1..100]
23:10:07 <lambdabot>   69720375229712477164533808935312303556800
23:10:12 <Ralith> hehe
23:10:32 <Ralith> even works on ten thousand pretty fast
23:10:34 <ski> Ralith : well, if something is ti be divisible by `4' then it will be divisble by `2', too
23:10:38 <Trinithis> > foldl1' gcd [1..20] -- 1
23:10:40 <lambdabot>   1
23:10:54 <Ralith> ski: why 2^4 and 3^2?
23:10:57 <Gracenotes> > foldl1' lcm [1..50000]
23:11:00 <lambdabot>   422297863844990477011660576230799852004412342353373216763947765154158145058...
23:11:01 <ski> Ralith : so, i put `2^4' there since that's the greatest power of `2' lesser or equal to `20'
23:11:02 <Ralith> other than that I can see you're just multiplying primes
23:11:06 <Ralith> ah.
23:11:16 <Ralith> same for 3
23:11:17 <ski> Ralith : now, similar for powers of `3'
23:11:23 <Ralith> and same for the rest, except it's all ^1
23:11:30 <Ralith> that's cool
23:11:43 <ski> and we don't need to consider `2*3' et.c. since those will already be covered by powers of `2', `3'
23:11:48 <ski> so just powers of primes
23:11:49 <Trinithis> UFD's! Hurray!
23:12:12 <Gracenotes> > length . show . foldl1' lcm $ [1..100000]
23:12:19 <lambdabot>   43452
23:12:46 <Ralith> neat!
23:17:15 <dons> http://twitter.com/gvanrossum/status/1269954818 <-- this is how the revolution begins, shapr
23:18:11 <ski> (Trinithis : Unique Factorization Domain, yes ?)
23:18:36 <Trinithis> yes
23:19:39 <Trinithis> > 999*999
23:19:40 <lambdabot>   998001
23:21:52 <Trinithis> @pl \x -> reverse x == x
23:21:53 <lambdabot> (==) =<< reverse
23:23:20 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [1..999^2]
23:23:21 <lambdabot>   997799
23:23:41 <Trinithis> fail....
23:23:46 <Gracenotes> dons: :D
23:24:02 <jfredett> Trinithis: ? looks like it worked to me...
23:24:08 <dons> :)
23:24:14 <Trinithis> project euler rejected it
23:24:23 <Trinithis> problem 4
23:24:43 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [1..99^2]
23:24:44 <lambdabot>   9779
23:25:33 <jfredett> dons: sweet deal
23:25:52 <jfredett> I got RWH on my kindle, I was excited... It made me feel quite geeky.
23:26:12 <jfredett> Trinithis: thats because thats not the answer.
23:26:17 <Trinithis> i know
23:26:19 <jfredett> I have something different.
23:26:24 <Trinithis> my idea failed that is
23:26:31 <jfredett> :(
23:26:47 <jfredett> which is odd... let me peek at my code...
23:27:32 <jfredett> oooh
23:27:44 <jfredett> I see what happened...
23:28:10 <jfredett> you're closer than you think
23:28:15 <Trinithis> ok
23:28:32 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [10..99^2]
23:28:34 <lambdabot>   9779
23:28:52 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [10^2..99^2]
23:28:54 <lambdabot>   9779
23:30:03 <jfredett> if you want a hint, this is one, it's rot-1 (a->b, etc.) "Qspevdu!pg!uxp!uisff!ejhju!ovncfst/"
23:30:18 <Trinithis> i think i know what the problem is
23:30:23 <Trinithis> i'm including primes
23:30:41 <jfredett> also, lambdabot, you are fantastic for quick & dirty cryptography
23:31:24 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [x*y | x <- [10..99], y <- [10..99]]
23:31:26 <lambdabot>   9009
23:31:28 <Trinithis> ok
23:31:36 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ [x*y | x <- [100..999], y <- [100..999]]
23:31:39 <lambdabot>   580085
23:31:56 <Gracenotes> @vixen you are fantastic for quick & dirty cryptography
23:31:56 <lambdabot> If I was looking for anonymous casual sex, I wouldn't be sitting here behind my computer talking to you!
23:32:02 <Gracenotes> true enough.
23:32:38 <Trinithis> > head $ filter (((==) =<< reverse) . show) $ reverse $ sort $ [x*y | x <- [100..999], y <- [100..999]]
23:32:39 <jfredett> btw... Trinithis, maximum will grab the max value of a list of Ord elements. that might be more helpful than that reverse business.
23:32:48 <lambdabot>   906609
23:32:56 <Trinithis> oh thanks
23:33:02 <jfredett> > maximum [1..10]
23:33:04 <lambdabot>   10
23:33:16 <Gracenotes> SUCCESS!
23:33:26 <jfredett> Hurrah! you got it.
23:33:43 <Gracenotes> orly
23:33:45 <jfredett> it said product of _3 digit_ numbers.
23:33:54 <glguy> you can do bette ron that project euler problem than to test every x and y value
23:34:04 <ski> (jfredett : which base ?)
23:34:15 <jfredett> ski: base 10, you loon.
23:34:26 <glguy> start at the top and count down, you can stop counting down as soon as the vlue you are testing is less than the best you've seen :)
23:34:39 <jfredett> it's question number 4, (base 10), the p-adic stuff doesn't come till question 214.
23:34:46 <glguy> You end up doing very few palendrome tests
23:34:50 <Trinithis> glguy: but it'll be longer code!
23:34:54 <ski> > head $ filter (((==) =<< reverse) . show) $ reverse $ sort $ [x*y | x <- [000..999], y <- [000..999]]
23:34:55 <Trinithis> i think
23:35:05 <lambdabot>   906609
23:35:12 <Gracenotes> @type diagonalize
23:35:15 <Ralith> > head $ filter (((==) =<< reverse) . show) $ [x*y | x <- [999..100], y <- [999..100]]
23:35:15 <lambdabot> Not in scope: `diagonalize'
23:35:16 <lambdabot>   * Exception: Prelude.head: empty list
23:35:23 <Ralith> :[
23:35:26 <glguy> Trinithis, not very much longer at all
23:35:31 <Gracenotes> , diagonalize [[1..3],[1..3]]
23:35:33 <jfredett> Trinithis: you could use arrows- they make everything shorter, and more awesome.
23:35:34 <lunabot>  luna: Not in scope: `diagonalize'
23:35:48 <Trinithis> jfredett: show me the arrow code
23:35:54 <Gracenotes> , diagonal [[1..3],[1..3]]
23:35:55 <Trinithis> been a while since i learned them
23:35:55 <lunabot>  [1,2,1,3,2,3]
23:36:10 <ski> Gracenotes : what is this `diagonalize' whereof you speak ?
23:36:14 <Gracenotes> , diagonal [[999,998..100],[999,998..100]]
23:36:15 <lunabot>  [999,998,999,997,998,996,997,995,996,994,995,993,994,992,993,991,992,990,...
23:36:16 <jfredett> why- theres an arrow called "solve Project Euler #4" you just type a bunch of random characters, and pray it works out to the right incantation of operators.
23:36:33 <Trinithis> lol
23:36:38 <jfredett> Trinithis: I was just making a joke, really.
23:36:47 <jfredett> it's 2:40am, I'm completely zonked.
23:37:19 <Trinithis> 11:40
23:37:22 <Gracenotes> , runOmega $ do { a <- [999,998..100]; b <- [999,998..100]; return (a,b)}
23:37:23 <lunabot>  luna: Couldn't match expected type `[t]'
23:37:27 <Gracenotes> :/
23:37:28 <jfredett> I have to get up in 5 hours, trying to determine whether it's better to start chugging mountain dew and try to just stay up
23:37:37 <Trinithis> :t runOmega
23:37:39 <lambdabot> Not in scope: `runOmega'
23:37:45 <jfredett> or whether I should try to sleep for the three hours
23:37:50 <jfredett> , type runOmega
23:37:51 <lunabot>  luna: parse error on input `type'
23:37:53 <jfredett> :(
23:38:02 <jfredett> lunabot: what's your type?
23:38:04 <Gracenotes> , runOmega $ do { a <- Omega [999,998..100]; b <- Omega [999,998..100]; return (a,b)}
23:38:05 <lunabot>  luna: Not in scope: data constructor `Omega'
23:38:08 <Gracenotes> X:X
23:38:20 <jfredett> @vixen whats your type?
23:38:20 <lambdabot> any type will due
23:38:24 <Gracenotes> , runOmega $ do { a <- each [999,998..100]; b <- each [999,998..100]; return (a,b)}
23:38:26 <lunabot>  [(999,999),(999,998),(998,999),(999,997),(998,998),(997,999),(999,996),(9...
23:38:28 <Gracenotes> yay :D
23:38:43 <ski> , [$ty|runOmega|]
23:38:45 <lunabot>  forall a . Omega a -> [] a
23:38:52 <Gracenotes> , runOmega $ do { a <- each [999,998..100]; b <- each [a,a-1,..100]; return (a,b)}
23:38:52 <Trinithis> what is Omega
23:38:53 <lunabot>  luna: parse error on input `..'
23:39:05 <Gracenotes> sorreh for spam
23:39:08 <jfredett> what the hell kinda type is that?
23:39:23 <jfredett> Omega -> list monadish thing?
23:39:33 <jfredett> err, omega monad?
23:40:00 <Gracenotes> , head $ filter (((==) =<< reverse) . show) $  runOmega $ do { a <- each [999,998..100]; b <- each [a, a-1 ..100]; return (a*b)}
23:40:02 <lunabot>  888888
23:40:29 <jfredett> , head $ filter (((==) =<< reverse) . show) $  runOmega $ do { a <- each [999,998..100]; b <- each [a, a-1 ..100]; return (a*b)}
23:40:30 <lunabot>  888888
23:40:32 <ski> , [$ty|each|]
23:40:34 <jfredett> , maximum $ filter (((==) =<< reverse) . show) $  runOmega $ do { a <- each [999,998..100]; b <- each [a, a-1 ..100]; return (a*b)}
23:40:35 <lunabot>  forall a . [] a -> Omega a
23:40:36 <lunabot>  906609
23:40:45 <jfredett> maximum, you loons, maximum.
23:40:50 <Gracenotes> x.x well, it's supposed to be an efficient means of looking through two long (possible infinite) lists.
23:40:53 <jfredett> it's your friend.
23:41:02 <jfredett> Gracenotes: thats interesting
23:41:07 <Trinithis> http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html?
23:41:14 <jfredett> it is a frakload faster than normal liss.
23:41:17 <jfredett> lists*
23:41:17 <Gracenotes> maximum is still a bit inefficient
23:41:26 <Gracenotes> , filter (((==) =<< reverse) . show) $  runOmega $ do { a <- each [999,998..100]; b <- each [a, a-1 ..100]; return (a*b)}
23:41:28 <lunabot>  [888888,861168,886688,906609,824428,819918,828828,855558,840048,853358,80...
23:41:32 <jfredett> head . sort would be no better....
23:41:33 <Gracenotes> 4th result
23:41:54 <jfredett> Theoretically, what is Omega?
23:42:02 <jfredett> <-- should just go to hackage and read the docs.
23:42:07 <ski> a greek letter
23:42:15 <jfredett> ski: FUUU! lol...
23:42:29 <jfredett> a, breadth-first list monad.
23:42:37 <jfredett> brilliant.
23:42:41 <ski> s/list/nondeterminism/
23:42:57 <jfredett> it says lists on the hackage place.
23:42:59 <ski> (angelic, for you pedants)
23:43:04 <glguy> > let {lo = 100; hi = 999} in foldl' (\m i -> fromMaybe m (find (((==)=<<reverse).show) [i*i,i*(i-1)..max m lo])) 0 [hi,hi-1..lo]
23:43:05 <lambdabot>   906609
23:43:15 <jfredett> but list/nondeterminism is roughly equiv...
23:43:35 <ski> (lazy) lists is one way of getting (angelic) nondeterminism
23:44:04 <Gracenotes> , (liftM2 (,) `on` each) [1..10] [1..10]
23:44:05 <lunabot>  luna: No instance for (GHC.Show.Show
23:44:24 <Gracenotes> well, with runOmega $.
23:45:38 <Trinithis> > runOmega $ (liftM2 (,) `on` each) [1..10] [1..10]
23:45:40 <lambdabot>   Not in scope: `runOmega'Not in scope: `each'
23:45:44 <Trinithis> , runOmega $ (liftM2 (,) `on` each) [1..10] [1..10]
23:45:46 <lunabot>  [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),...
23:45:54 <Trinithis> what is the , vs > ?
23:46:14 <jfredett>  , is to run code on lunabot, whoever that is
23:46:22 <jfredett>  > will run code on lambdabot
23:46:32 <Trinithis> ok
23:46:38 <Gracenotes> , help
23:46:40 <jfredett> lunabot has omega available.
23:46:40 <lunabot>  type of an expression:      , [$ty| \x -> x |]
23:46:40 <lunabot>  get info for a type/class:  , src ''Monad
23:46:40 <lunabot>  get info for a var/con:     , src 'fix
23:46:55 <jfredett> evidently.
23:47:40 <jfredett> anyway. I think I'll try for that 5 hours of sleep... gnite lads. (and lasses, if there be any.)
23:48:55 <Gracenotes> @vixen jfredett says goodnight :)
23:48:55 <lambdabot> good? not great?
23:51:07 <ski> , src 'src
23:51:10 <lunabot>  src :: Name -> Doc
23:51:41 <cads_> hey you guys, you guys remember the del operator from vector calculus? it was a vector of differential operators that. I think you could apply it directly to a scalar field to get its gradient, for example, or use the vector product to create the laplacian or something
23:53:06 <quicksilver> cads_: remember it? I never once left its side.
23:55:32 <cads_> hehe
23:56:37 <cads_> for 3 dimensions it's like  del :: (R^3 -> R) -> (R^3 -> R^3) ; del f = (d f x1, d f x2, d f x3)
23:58:52 <ski> del f = \(x0,x1,x2) -> (d f (x0,x1,x2) / d x0 , d f (x0,x1,x2) / d x1 , d f (x0,x1,x2) / d x2)
