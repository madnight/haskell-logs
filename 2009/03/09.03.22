00:00:05 <Gracenotes> hummus?
00:00:14 * mmorrow kicks the cat. feels bettar.
00:00:33 <dons> you can see two things in that logscale graph, i think
00:00:35 <xpika> mmorrow: if its for me its not
00:00:41 <dons> once is the "distro effect" for popular things
00:00:53 <dons> and then in the tail, packages are new enough they drop below their rank
00:01:09 <dons> in the middle, i think there's a small amount of inflation. things are being downloaded slightly more than their rank would suggest
00:01:32 * wli finally gets something that parses a few simple expressions rammed through parsec.
00:02:02 <solidsnack> dons: Wow, there is a lot going on in this channel all of a sudden.
00:02:12 <Gracenotes> dons: is there some kind of invariant for both lines in the Zipf's law graph?
00:02:24 <solidsnack> dons: Without time, it's hard to know what to draw from the Zipf's law graph.
00:02:36 <dons> hmm. no. it isn't time here
00:02:39 <dons> it's popularity
00:02:39 <wli> Have I mentioned how much I hate parsec?
00:02:39 <Gracenotes> e.g. an expected sum or something
00:02:47 <solidsnack> Maybe it flattens because there aren't that many people to download it.
00:02:59 <dons> so frequence of downloading something should be inversely proportional to its rank on the list, basically
00:03:05 <solidsnack> dons: Well, you're saying they move into distros.
00:03:11 <dons> yes, like xmonad.
00:03:18 <mmorrow> @w80 frequence
00:03:21 <lambdabot> *** "frequence" wn "WordNet (r) 2.0"
00:03:21 <lambdabot> frequence
00:03:21 <lambdabot>      n : the number of occurrences within a given time period
00:03:21 <lambdabot>          (usually 1 second); "the frequency of modulation was 40
00:03:21 <lambdabot>          cycles per second" [syn: {frequency}, {oftenness}]
00:03:25 <mmorrow> wut!
00:03:25 <dons> i'm quite certain xmonad's src downloads have dropped off because of distros
00:03:30 <solidsnack> Then we should a change with time.
00:03:36 <dons> and i think that's what we're seeing in that graph
00:03:36 <solidsnack> Ah, they have dropped off.
00:03:39 * mmorrow 's plan backfires
00:04:01 <solidsnack> All I'm saying is, you look at that, graph what it says is there is a download peak.
00:04:16 <dons> so we could actually predict when a package *should* move into the distros based on that
00:04:33 <ivanm> mmorrow: what _was_ your plan?
00:04:52 <mmorrow> ivanm: to see how many licks it takes to get to the center of a tootsie-pop
00:05:16 <ivanm> ummm..... OK...
00:05:25 <ivanm> that's not a plan, that's something you want to do...
00:05:27 <solidsnack> dons: Well, once again -- we'd want to see some information about what packages moved into distros and so on.
00:05:38 <solidsnack> The graph as given is merely suggestive.
00:05:52 <dons> yeah. so that's a good point
00:05:59 <dons> i could actually add which ones are are in distros
00:06:29 <solidsnack> dons: I mean, you obviously have all this information.
00:06:35 <ivanm> dons: here for gentoo, we typically still download from hackage
00:06:42 <wli> http://wli.pastebin.com/m698cdd26 <-- and this has essentially zero syntactic sugar, not even infix operators.
00:06:44 <ivanm> at least for packages in the overlay, which is most of them
00:06:54 * mmorrow stares blankly at ghc output as it builds ghc
00:06:58 <ivanm> it's only really popluar ones that get into the official gentoo mirror
00:07:03 <dons> ivanm: right. but even Arch is distributing binaries now
00:07:06 <ivanm> mmorrow: a great read, isn't it ;-)
00:07:08 <dons> ivanm: yeah, so maybe the top 10 packages?
00:07:15 <mmorrow> ivanm: truly
00:07:25 <ivanm> dons: well, how is that my fault if you're stuck with binaries? ;-)
00:07:33 <dons> it's a logscale, so we're talking about only the top 10 or so showing a distro effect
00:07:45 <dons> xmonad, pandoc, cabal, mtl
00:07:47 <ivanm> *nod*
00:07:53 <dons> haddock
00:08:06 <ivanm> then there's ones like gtk2hs which aren't on hackage anyway...
00:08:10 <dons> oh, bytestring is in the top 10
00:08:14 <dons> and its low becaues it comes with ghc now
00:08:19 <dons> so its distributed separately
00:08:25 <dons> yeah, they're not in the graph
00:08:27 <ivanm> dons: well, you'd expect so with the way you've snuck it into everything ;-)
00:08:40 <dons> [Char] is for the weak and frail
00:09:07 <ivanm> heh
00:09:11 <Heffalump> so what is the total number of downloads from hackage?
00:09:24 <ivanm> but if String is efficient enough for what you need, why bother with bytestring? *shrug*
00:09:51 <dons> Heffalump: http://galois.com/~dons/hackage/hackage.png
00:10:01 <dons> 850k approx.
00:10:07 <dons> should hit 1M soon if you project that curve
00:12:20 <Heffalump> can you do that on a log scale?
00:13:06 <dons> redid the popularity ranking one , Hackage, along with the Cabal infrastructure has been sponsored by Galois since it's inception. We use Cabal on most of our projects, and run our own Hackage instance internally.
00:13:10 <dons> For the community library hosting, we've noticed some interesting traffic growth over the past year or so, to hackage.haskell.org.
00:13:13 <dons> grr
00:13:15 <dons> http://galois.com/~dons/hackage/zipfs-law.png
00:13:21 <dons> firefox's paste buffer suxors
00:13:54 <dons> let me try the download one again.
00:15:02 <chowmeined> i know some kinds of network protocols are modeled with a finite state machine (such as HTTP), is there a way to model asynchronous network protocols?
00:15:10 <ImInYourMonad> so anyone have a graph lib lying around?
00:15:21 <Heffalump> there's at least one on hackage
00:15:23 <Heffalump> probably several
00:15:56 <dons> ImInYourMonad: go to hackage.
00:16:21 <mmorrow> dons: R makes really pretty graphs and the like
00:16:37 <solidsnack> chowmeined: CSP?
00:16:59 <ivanm> im_maciek: what kind of graphs?
00:17:10 <ivanm> s/im_maciek/ImInYourMonad/
00:17:24 <solidsnack> dons: So do you have graphs or stats on per package downloads?
00:17:30 <chowmeined> solidsnack, what do you mean
00:17:44 <solidsnack> chowmeined: Communicating Sequential Processes
00:17:49 <dons> here's the long tail one, packages sorted by popularity http://galois.com/~dons/hackage/longtail.png
00:17:57 <dons> solidsnack: yeah, i've got complete download data
00:18:01 <chowmeined> solidsnack, oh thanks
00:18:05 <dons> http://galois.com/~dons/hackage/hackage.csv
00:18:26 <dons> haven't fully validated yet, need to check against a different log parser, but it looks plausible
00:19:24 <solidsnack> That's monthlies?
00:19:39 <dons> yeap
00:20:26 <solidsnack> I've always wondered how "system-uuid" faired against "uuid". I guess I'm doing alright :)
00:20:55 <TomMD> eep!  people are downloading IPC - I need to get that removed.
00:21:02 <dons> heh
00:21:19 <ivanm> why, what's wrong with it?
00:21:32 <dons> nothing.
00:21:36 <dons> well, it's a bit slow ...
00:21:37 <TomMD> Well, it was a toy library ment as a stop-gap for a temporary issue.
00:21:38 <dons> but its nice
00:21:38 <solidsnack> It's weird that both UUID modules had hundreds more downloads in the last month.
00:21:46 <Heffalump> the final column is the total
00:21:47 <TomMD> The issue is gone and I really should never have uploaded the package
00:21:48 <Heffalump> not a month
00:21:51 <solidsnack> Ah.
00:21:53 <Heffalump> (I got caught by that as well)
00:21:55 <TomMD> Wasn't interested enough to make it right.
00:21:58 <dons> TomMD: i'm sure its useful for someone
00:22:19 <dons> final column is total. final two rows are monthly total, and cumulative
00:22:22 <dons> there's an .ods file too
00:23:55 <mmorrow> yeah, what's .ods?
00:24:16 <TomMD> Probably open document spreadsheet.
00:24:28 <mmorrow> solidsnack, Heffalump: haha, me too
00:24:33 <dons> open office. yell if you want the data in something else.
00:24:36 <mmorrow> TomMD: ah
00:24:51 * mmorrow prefers gnumeric
00:24:53 <dons> it's still prelim -- don't write up stuff based on the data, as i might find bugs in the generator.
00:24:55 <mmorrow> gnumeric++
00:24:57 <ivanm> dons: can you upload it in mystic runes?
00:24:58 <solidsnack> Can we get it in PowerPoint?
00:25:06 * dons slaps heads
00:25:10 <ivanm> heh
00:25:18 * mmorrow wants it in microsoft(R) word(R)
00:25:24 <ivanm> well, you did say to yell...
00:25:34 <ivanm> mmorrow: which version?
00:25:39 <mmorrow> 95
00:26:03 <solidsnack> for playstation
00:26:18 <ivanm> solidsnack: which one?
00:26:26 <solidsnack> ps2
00:27:03 * mmorrow quickly realizes that sudo yum list *R* was a bad idea
00:27:17 <ivanm> way too many packages?
00:27:21 <mmorrow> gah, it's not even case sensitive
00:27:22 <mmorrow> yeah
00:27:25 * ivanm likes eix
00:27:42 <solidsnack> dons: That's neat, it's good to see just how much growth there has been.
00:28:22 * wli seriously ponders kicking off some kind of parsing effort for strength wrt. grammars recognizable.
00:30:02 <ivanm> dons: oh, did you ask your colleague for the C/Haskell version of the cryptol sudoku solver?
00:30:07 <wli> Or whatever I had in mind.
00:31:23 <mmorrow> dons: one format that would actually be really nice would be sqlite3
00:31:49 <wli> Something where your EDSL is vastly closer to BNF for CFG's than anything out there.
00:35:07 <wli> For that I have to solve the ages-old riddle of grammar construction combinators (which I suspect there are actually numerous implementations of out there).
00:38:09 <vixey> what percent of haskellers are zen buddhists?
00:38:28 <vixey> I know it's non-zero
00:38:38 <wli> vixey: Try #haskell-blah for religion.
00:41:35 <psygnisfive> vixey, i think a better question is
00:41:41 <psygnisfive> what percent of zen buddhists are haskellers
00:42:44 <psygnisfive> tho i suspect if we spoke to a zen buddhist, the answer is the same either way, isnt it
00:46:43 <vixey> wli: still troubled by parsing problems?
00:47:18 <wli> vixey: I rammed my immediate concerns through parsec, but screamed in agony all the way.
00:47:22 <dons> Heffalump: on a log scale, the downloads, http://galois.com/~dons/hackage/download-logscale.png
00:48:22 <Heffalump> ta
00:48:49 <wli> vixey: The parsing libs out there are really low on the spit and polish factor. :(
00:49:07 <wli> vixey: Never mind functionality.
00:49:09 <ivanm> dons: oh, did you ask your colleague for the C/Haskell version of the cryptol sudoku solver?
00:49:13 <dons> ah not yet.
00:49:24 <ivanm> *shrug* no big rush
00:49:33 <ivanm> it's not like it will magically improve or anything ;-)
00:49:55 <vixey> My biggest concern is how to ensure that a pr
00:50:12 <vixey> printer is a section of a parser
00:51:20 <Guest96141> hi
00:52:06 <ivanm> O...K... then...
00:52:06 <Axman6> hi chris
00:52:08 <wli> vixey: My plot (assuming I ever get past this interpreter and the algebraic function calculator after it) is to have grammar construction combinators, and then have the parsing engine grind through the grammar, build state transition tables, use nondeterminism to avoid having to have the programmer do violence to the grammar for the sake of coddling a weak parser, and I forget what comes after that.
00:52:14 * ivanm wonders if that was a failed spam message...
00:52:42 <chrisosb> hi
00:53:13 <chrisosb> hello
00:53:15 <wli> vixey: Well, if you've got a grammar floating around, you can literally just run the grammar's rules as productions instead of derivations for idempotency of parsing and printing.
00:53:25 <Heffalump> hi
00:53:39 <chrisosb> can I ask a beginner haskell question?
00:53:44 <Heffalump> go ahead
00:53:56 <chrisosb> thanks
00:54:07 <chrisosb> I want to write a program that dynamically manipulates a graph
00:54:15 <chrisosb> but I want data associated with each node
00:54:15 * Axman6 rteminds chrisosb of the first rul of IRC: don't ask to ask, just ask
00:54:20 <chrisosb> and I want it to be updatable dynamically
00:54:35 <chrisosb> and still get good run time
00:54:36 <Axman6> reminds even
00:54:39 <chrisosb> is this possible with Haskell?
00:54:46 <ivanm> yes
00:54:59 <chrisosb> ok, good
00:55:06 <Stinger> @faq is it possible
00:55:06 <lambdabot> The answer is: Yes! Haskell can do that.
00:55:07 <chrisosb> I was worried because Haskell is purely functional
00:55:23 <Axman6> why would that change things?
00:55:23 <chrisosb> it wouldn't work
00:55:46 <chrisosb> well dynamic updates are harder, aren't they?
00:56:07 <chrisosb> I mean if I change a node do I have to create a whole new version of the graph?
00:56:59 <Axman6> possibly
00:57:27 <chrisosb> ok it seems like that would be very slow
00:57:38 <Axman6> depends how you write it
00:58:12 <chrisosb> if I have 100 edges going into a node
00:58:15 <chrisosb> and then change that node
00:58:20 <wli> vixey: Oh, yeah, I've got some rather interesting notions about interactive parsing, esp. using the stack of a shift/reduce parser and peeking into its state for various purposes, and also how to cope with in-place modifications of the input without reparsing it all, and a few other things.
00:58:23 <chrisosb> then all the nodes going into it need to be replaced, right?
00:58:42 <chrisosb> no matter how you write it?
00:59:31 <wli> vixey: Basically all kinds of tricks to use when parsing in the presence of command-line editing, in particular making multiline command-line editing at a repl work smoothly.
01:00:07 <Heffalump> chrisosb: you can use ST and mutable references if you are really worried about it
01:00:48 <chrisosb> oh okay
01:00:53 <chrisosb> I will look that up
01:01:04 <chrisosb> thanks very much for your help, guys!
01:01:18 <Heffalump> np
01:03:57 <chowmeined> solidsnack, could you use CSP to model something like the IRC protocol?
01:04:14 <solidsnack> chowmeined: Well, yes.
01:04:22 <solidsnack> I would almost say, of course.
01:04:31 <solidsnack> The trick is /how/ do you do it.
01:05:20 <solidsnack> You are interested in modeling client as well as server, I gather.
01:06:00 <chowmeined> yeah
01:06:01 <mmorrow> dons: http://moonpatio.com/hackage/hackage.db
01:06:46 <chowmeined> solidsnack, so i was reading about CSP, it looks like you model each individual process, and then state which process-states can run concurrently with other process-states?
01:07:08 <solidsnack> Well, you state and then demonstrate.
01:07:20 <chowmeined> solidsnack, except, it seemed to be talking about threads doing message passing
01:07:35 <solidsnack> That is what network protocols are exactly.
01:07:49 <solidsnack> Do you disagree?
01:07:53 <chowmeined> well
01:08:16 <Heffalump> CSP has been used in practice to model protocols, btw.
01:08:23 <chowmeined> the difference being, in CSP a single thread sends and receives messages and has its finite state, but when handling a protocol like irc
01:08:39 <chowmeined> multiple messages are sent/received in the same thread
01:09:01 <solidsnack> chowmeined: The same system thread, yes.
01:09:17 <solidsnack> You could model that with CSP anyways, though.
01:10:49 <dons> mmorrow: thanks
01:10:54 <chowmeined> solidsnack, ok, i guess im having trouble separating the thread concurrency going on and the protocol's own concurrency from being asynchronous
01:11:40 <solidsnack> chowmeined: Can you say more about what, in particular, you want to model?
01:11:50 <chowmeined> solidsnack, the irc protocol
01:12:18 * wli guesses people might get more excited about his parsing ideas if he were remotely able to execute them.
01:12:28 <dons> so i think next i'll try to work out the popularity by category
01:12:34 <solidsnack> chowmeined: I'm interested to see how that turns out.
01:12:44 <solidsnack> wli: I would be curious to see a paper first.
01:12:54 <chowmeined> solidsnack, i already have a full parsec parser for the irc protocol following the EBNF spec
01:13:17 <solidsnack> chowmeined: Yeah, but your model is a different thing.
01:13:22 * wli solidsnack: I tend not to write many papers. I'm more of an industry type.
01:13:32 <chowmeined> yeah im just saying this is all going together as a kind of, more formal IRC lib
01:13:40 <solidsnack> chowmeined: Interesting.
01:14:18 <chowmeined> im also using this to kind of learn how to design network protocols
01:14:51 <solidsnack> What are you going to try to demonstrate about the IRC protocol?
01:16:35 <chowmeined> um
01:16:41 <solidsnack> wli: Oh. In industry I believe it is called a white paper?
01:16:56 <solidsnack> chowmeined: I guess I'm just not sure what your model is going to show you.
01:17:04 <chowmeined> demonstrate, im not sure, like HTTP implementations use a finite state machine to handle the protocol
01:17:12 <wli> solidsnack: Sadly, I don't even get to do those very often.
01:17:24 <solidsnack> chowmeined: To handle one side of it, yeah.
01:17:26 <chowmeined> but, i got the impression that IRC couldn't be modeled as a finite state machine
01:17:59 <solidsnack> chowmeined: Have you read the FLP paper?
01:18:18 <chowmeined> so i wanted to use something that could handle one side of the irc protocol using a formal model
01:18:25 <solidsnack> Ah.
01:18:46 <solidsnack> Well, CSP is really for modelling a few processes.
01:19:16 <solidsnack> chowmeined: I don't see right away what is difficulty to model about IRC.
01:19:30 <chowmeined> ok, so i might use that instead of MVars for the rest of the app
01:19:51 <chowmeined> solidsnack, it couldnt be done with a finite state machine though right? at least thats what i understood
01:21:16 <solidsnack> Well, I don't know.
01:21:40 <solidsnack> Why wouldn't it be?
01:21:42 <chowmeined> for example, you register, then you can join channels at any time, its not a direct request response, you can also receive messages without sending anything
01:22:27 <chowmeined> you can send 3 requests and then get 3 responses, it would seem to not be finite state
01:23:26 <chowmeined> you can send a message and either get a response or not get a response, you can receive a message and either send a response or not send a response,
01:25:04 <solidsnack> Some of the things you mention are true of any network protocol.
01:25:16 <solidsnack> For example, sending a message and not getting a response.
01:25:40 <solidsnack> I guess in IRC, though, that is /valid/ behaviour.
01:27:20 <dons> TomMD: binary >= 0.4.0 && < 0.5.0 is wrong, in network-binary. 0.5.0.1 is out
01:27:34 <dons> should be < 0.6
01:27:55 <Gracenotes> some fun sorta-obfuscated code I wrote, requires Control.Monad.Instances and Control.Applicative: putStrLn.unlines.flip execState[" /\\","/__\\"].flip replicateM(modify ((++)<$>(map=<<(++).(>>" "))<*>map((liftM2(.)<*>flip)(++)<*>takeWhile(==' ')))) $ 4
01:28:24 <Gracenotes> any non-negative number works at the end, but >5 is too large for most terminals :)
01:30:13 <Gracenotes> oh, and also Control.Monad.State.
01:30:14 <chowmeined> solidsnack, well if it is finite state then i guess i could just do that, but what state do you have after 1 PRIVMSG, and after n?
01:31:07 <solidsnack> chowmeined: You are modeling both the client and the server as part of the same machine?
01:31:47 <chowmeined> solidsnack, well at some point it'd be nice to have it operating on sockets
01:32:15 <solidsnack> By the same machine, I mean, you are modelling the client/server as a state machine.
01:32:33 <solidsnack> Instead of modelling the client as one state machine and the server as a another.
01:32:37 <Axman6> Gracenotes: awesome :)
01:33:07 <chowmeined> solidsnack, which would be more appropriate
01:33:15 <ddarius> solidsnack: Isn't there a way to compose two separate state machines to get a combined one anyway.
01:33:31 <Axman6> Gracenotes: if i make my text really small, i can see 7 quite easily
01:33:53 <Axman6> and 8
01:33:59 <solidsnack> ddarius: I think it depends on how they are connected.
01:34:08 <solidsnack> ddarius: There is a third machine here, the network.
01:34:24 <solidsnack> chowmeined: I encourage you to model them as separate machines.
01:34:40 <solidsnack> Then when you send a PRIVMSG the state goes back to "doing nothing".
01:34:56 <Axman6> Gracenotes: sure is fun watching ghci print out n=8 :P
01:35:11 <Gracenotes> heh
01:35:21 <chowmeined> solidsnack, what about a machine for each direction for the client and server?
01:35:43 <solidsnack> chowmeined: Well, I don't know -- that might be better.
01:35:58 <solidsnack> Might be worse.
01:36:03 <chowmeined> solidsnack, since messages can be sent or received at any time and i already have them separated into two threads
01:36:22 <solidsnack> Hmm.
01:36:31 <chowmeined> solidsnack, so i guess i couldnt associate a PRIVMSG with a PRIVMSG_ERROR in the state machine
01:36:53 <solidsnack> This is on the client?
01:37:01 <pumpkin-> :o
01:37:11 <chowmeined> yes
01:37:33 <solidsnack> I don't know the IRC protocol very well. If there is no header then no, you can't, not in general.
01:38:27 <chowmeined> solidsnack, yeah there isnt a header, and i dont think there is a deterministic ordering for responses
01:38:27 <solidsnack> chowmeined: However, I fear at this point that we are really getting into the kinds of questions your study should be answering.
01:38:45 <chowmeined> oh right, my study
01:38:49 <solidsnack> I wouldn't want to set myself up as Mr. IRC and disappoint you.
01:39:14 <chowmeined> oh, im already fairly comfortable with the irc protocol
01:39:38 <solidsnack> By "your study" I mean, you are going to know a lot more about this then I do.
01:39:42 <solidsnack> s/then/than/
01:40:13 <chowmeined> oh
01:40:20 <Gracenotes> IRC is quite asynchronous and unreliable
01:40:26 <chowmeined> yeah
01:40:43 <chowmeined> it wasnt so much the IRC concepts, but how to fit it into a finite state machine given that its asynchronous and non-deterministic
01:40:47 <solidsnack> If you are interested in asynchronous semantics in general, I encourage you to look at the FLP paper and things like Paxos.
01:41:33 <Gracenotes> I believe it's impossible to associate inputs with outputs. it's meant more to be pretty-printed to humans than anything else ;)
01:42:07 <Gracenotes> (well, not impossible in all cases, just don't wait too long)
01:42:10 <solidsnack> Now email, on the other hand -- that's a lot easier to sort in this regard.
01:42:26 <chowmeined> Gracenotes, yeah :(
01:44:13 <Gracenotes> chowmeined: what sort of state machine did you have in mind?
01:44:48 <Gracenotes> most of what comprises IRC 'state', like channels joined etc., isn't exactly finite
01:45:53 <Gracenotes> or, given character limits, nonetheless huuuge.
01:46:15 <chowmeined> Gracenotes, but isnt that content? theres a finite state machine for http even though you can GET anything
01:47:32 <Gracenotes> oh, interesting. Do you have a link?
01:47:47 <pumpkin-> a turing machine has a finite number of states
01:47:54 <Gracenotes> I suspect that it has to do with things like HTTP 100
01:48:09 <Gracenotes> I've also seen a TCP FSM, not to mention
01:48:17 <Gracenotes> http://userpages.umbc.edu/~jeehye/cmsc491b/lectures/tcpstate/sld001.htm
01:48:23 <chowmeined> Gracenotes, http://www.w3.org/Library/User/Architecture/HTTPFeatures.html
01:49:31 <Gracenotes> ah, I see. simplified, though,
01:49:46 <chowmeined> i just want to do that but for an irc client instead
01:49:58 <Gracenotes> the things that make IRC asynchronous are mostly the content transferred
01:50:15 <chowmeined> i guess i could reduce it to something like
01:50:23 <Gracenotes> if you're just tracking connectedness, I'm sure a FSM could handle that
01:51:15 <chowmeined> BEGIN -> [PASS] -> NICK -> USER -> IDLE -> QUIT
01:51:32 <chowmeined> where IDLE is the majority of the connection, going from IDLE -> PRIVMSG -> IDLE
01:51:47 <chowmeined> and each point would have errors
01:52:06 <Gracenotes> how do you distinguish between sending and receiving privmsgs?
01:53:22 <chowmeined> Gracenotes, received privmsgs have a prefix showing their source
01:53:31 <Gracenotes> I mean, in your state model
01:54:00 <Gracenotes> (the things that tends to not have prefixes: PONGs and initial NOTICEs. beware!)
01:54:06 <wli> I forget how IRC has replies to specific messages/etc. or if it does at all. I think you just spray and pray.
01:54:25 <Gracenotes> there's no way to tell that this message made it to the server
01:54:32 <Gracenotes> the client just pastes it to the screen and hopes for the best
01:54:42 <Heffalump> well, except that TCP is a reliable delivery protocol
01:54:48 <Heffalump> if it doesn't make it to the server, then the connection should die
01:55:32 <Gracenotes> well, unless you're connected to every single server and can confirm that each client got the message
01:56:49 <chowmeined> i see, so how about modeling the irc client instead
01:57:08 <chowmeined> its not really a finite state machine liked you said Gracenotes
01:57:32 <chowmeined> its not finite i mean
01:58:24 <Gracenotes> yeah. most state-sheparding, the server takes care of.
01:58:25 <solidsnack> chowmeined: Modelling the state of any asynchronous system as a whole is a good way to lose a lot of hair.
01:59:20 <chowmeined> :(
02:00:00 <Gracenotes> so is compulsive hair-pulling
02:01:55 <pumpkin-> :o
02:04:02 <solidsnack> Gracenotes: Well, yes.
02:04:33 <dons> Heffalump: how about this, http://galois.com/~dons/hackage/hackage-future.png
02:05:06 <Heffalump> :-)
02:05:18 <dons> 10M in 2011 seems doable
02:05:50 <ivanm> dons: I take it you're assuming the rate of growth will remain constant?
02:06:04 <Heffalump> ivanm: the exponential rate of growth, yes
02:06:19 <dons> well, it really was exponential (2^n) in 2007
02:06:33 <dons> not sure what it is now. n^4 or something
02:06:44 <solidsnack> Can we create a fund based on growth in Haskell?
02:07:06 <dons> ivanm: but yes, that's clearly projecting that the 2008 rate will continue for 5 years
02:07:09 <chowmeined> oh log scale
02:07:19 <dons> log scale!
02:07:24 <chowmeined> so its growing pretty fast
02:07:30 <dons> yup
02:07:33 * trofi wants to build such pretty graphs too
02:07:35 <chowmeined> excellent
02:07:35 * ivanm awaits the great haskell crash of '10
02:07:37 <dons> http://galois.com/~dons/hackage/hackage.png
02:07:47 <dons> trofi: gnuplot is your friend
02:07:56 <ivanm> dons: library, or directly?
02:08:04 <trofi> can i ask you to share script for gnuplot?
02:08:10 <dons> directly, in this case. so i can rotate text and so on
02:08:19 <dons> i recommend http://gnuplot.sourceforge.net/demo/
02:08:25 <trofi> ok
02:08:32 <dons> lots of good examples and tricks
02:08:38 * Heffalump tries to figure out why cabal-install is insisting on building setup even for Build-Type:Simple things
02:08:40 * ivanm has idly considered writing a low-level gnuplot library using writer or something, with every gnuplot command (or at least most) catered for
02:08:53 <dons> the gnuplot lib we have is pretty good
02:08:56 <dons> just needs more buttons
02:08:59 <Gracenotes> gnuplot, R, povray, photoshop/gimp.. it takes commitment to make pretty things! :x
02:09:09 <dons> so does http://galois.com/~dons/hackage/hackage-future.png just seem silly?
02:09:23 <ivanm> dons: its severly lacking a lot of things
02:09:37 <ivanm> I ended up re-writing it basically for each assignment I needed to do 3D graphs in last year :s
02:09:45 * ivanm wishes chart could do 3D graphs
02:10:05 <TomMD> I think it will top out
02:10:34 <dons> some factors will come into play, i think. for one, if things get really popular, they go to the distro
02:10:39 <dons> so then they're not in the stats anymore
02:10:45 <dons> also, we run out of programmers at some point
02:10:48 <dons> and other resources :)
02:10:52 <TomMD> And not comsuming galois bandwidth.
02:10:54 <mmorrow> umm, i'm really confused. so on x86_64 on an intel core2(duo), sizeof(int)==4 ??!
02:10:55 <dons> heh
02:11:05 <trofi> yes!
02:11:18 <dons> mmorrow: long is your friend
02:11:27 <mmorrow> dons: sheesh, apparently :)
02:11:36 <trofi> mmorrow: msvc even has sifeof(long) == 4 !
02:11:42 <dons> TomMD: and the current rate i think is fed by all the new bindings we can do
02:11:44 <trofi> (for x86_64)
02:11:45 * mmorrow watches all his C code segfault
02:11:47 <dons> so at some point we run out of bindings to make
02:11:51 * Gracenotes grabs some popcorn
02:11:54 <dons> like we ran out of things to cabalise in 2008
02:11:56 <mmorrow> trofi: weird
02:11:57 <TomMD> I blame cabal-install.
02:12:17 <TomMD> I install one library on a whim and get ten others I never knew about automatically.
02:12:22 <TomMD> :-)
02:12:28 <dons> heh
02:12:35 <dons> yeah, and that's encouraging people to add dependencies
02:12:42 <dons> hmm. so that might be an exponential factor.
02:12:42 <TomMD> yep
02:12:53 <dons> easy to add arbitrary numbers of dependencies == more downloads
02:13:13 <dons> swap a module for a package dep, and you double your downloads
02:13:41 <TomMD> If we went with my preferred method of keeping all packages very very small and have larger meta-packages with many dependancies then the stats would be impressive indeed.
02:13:54 <dons> start distributing   the 'everything' package...
02:14:07 <dons> so cabal may well get us to 10M
02:14:15 <ivanm> everything == world + system (in gentoo, anyway...)
02:14:32 <TomMD> For example, I would have liked to see packages called AES, SHA, MD5, CipherClass, HashClass, DES, CipherModes  and then a crypto package that depends on all of  those.
02:15:12 * mmorrow wonders howtf he's going to pass a pointer through siglongjmp now that sizeof(int)!=sizeof(void*) :(
02:15:41 * TomMD goes to sleep
02:17:00 <wli> mmorrow: Array index into some array of your actual pointers?
02:17:01 <dons> yeah, bed time.
02:17:15 <ivanm> no it isn't!
02:17:16 <ivanm> @time
02:17:17 <lambdabot> Local time for ivanm is Sun Mar 22 19:17:16
02:17:36 <mmorrow> wli: hmm, yeah i guess i'll have to do something like that.
02:20:01 <mmorrow> wli: nice, that works out.
02:20:37 <wli> mmorrow: Did you ever hear my epiphanies about let floating and intraprocedural strictness analysis?
02:21:34 <mmorrow> wli: i didn't :(
02:21:42 * mmorrow reads the logs
02:24:23 <thoughtpolice> pumpkin_: ping?
02:25:43 <wli> mmorrow: When you hash cons it's like having a let expr for every subexpression, so screw named variables and explicit let exprs; keep some side info about variable names along with the hash cons tags, substitute indices into the expression table in place of any variable names, form the SCC DAG, and you're done. Non-singleton DAG nodes are where (possibly mutual) recursion occurs, singleton DAG nodes where recursion occurs are useless and not even possible
02:26:28 <mmorrow> hmm, i'll have to think that through.
02:26:54 <mmorrow> wli: a question though.. so what exactly is "hash cons(ing)"?
02:27:17 <mmorrow> i never really understood what that is.
02:27:29 <mauke> memoizing constructors
02:27:29 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
02:27:31 <Heffalump> it's keeping a global lookup table of all expressions you build, and thus getting sharing
02:27:43 <Heffalump> maximal sharing
02:27:52 <mmorrow> ahh. so somehow computing a hash of arbitrary expressions?
02:27:59 <wli> mmorrow: of copying expression, and the scope of any let expression is precisely the least common ancestor of all the uses if you were even to bother trying to float it up.
02:28:06 <Heffalump> mmorrow: you do it on a constructor by constructor basis
02:28:09 <Heffalump> (hence "consing")
02:28:26 <mmorrow> hmm, ok. i'll have to google this.
02:28:36 <wli> mmorrow: Instead of a recursive data structure, where recursion would occur, you use an Int as an index into a table e.g. an IntMap.
02:29:01 <wli> mmorrow: The Int's act like pointers for the data structure recursion to go through.
02:29:49 <mmorrow> wli: ah, ok sure. so just the haskell graph rep => IntMap (Set (Something Int))
02:30:10 <wli> mmorrow: In such a manner you can start tying your tree into a DAG via CSE or by replacing let-bound vars with Int's.
02:30:21 <wli> mmorrow: Yeah.
02:30:25 <mmorrow> cool
02:31:33 <wli> mmorrow: Strictness in expressions with no lambdas or applications is just biconnected components where each strict dependency edge is weighted 1 and each non-strict dependency edge is weighted 2.
02:32:31 <mmorrow> innteresting.
02:32:33 <wli> mmorrow: So you can cut down the closures in/around primops completely mechanically to the closures in/around the biconnected components.
02:33:29 <mmorrow> wli: have you ever used the fgl lib? i've been eyeing it to snake some code from for a while now ;)
02:34:21 <mmorrow> (one thing in partic i've been eyeing is its dominator code)
02:34:21 <wli> mmorrow: I've tried, but I've found that every time I need to do something with graphs, there's always some twist to the algorithms that makes stock graph algorithm code useless. :(
02:36:53 <wli> mmorrow: I've also got rather specific ideas about how to exploit the join semilattice structure of the SCC DAG for faster biconnected components, as well as ideas about how to exploit the tree-ish characteristics of the original expression graph for SCC's, so there's some strangeness wrt. stock graph algorithms.
02:38:25 <mmorrow> that'd be insteresting if you could extract a generic algo for that.
02:39:48 <mmorrow> (since SCCs is already linear, would that speed it up by a constant? (more?))
02:40:06 <wli> A constant at best.
02:40:32 <mmorrow> sound interesting
02:40:35 <mmorrow> +s
02:42:29 <alinp> hi
02:42:31 <wli> It's not that exciting. You know from the original tree-ish structure that you can break the thing down hierarchically for the most part.
02:42:57 <alinp> can anyone give me a link or something to read about the tail recursion ?
02:43:19 <alinp> tail recursion in respect to multiple languages
02:43:27 <alinp> not only to haskell
02:43:35 <mauke> wikipedia?
02:43:37 <Gracenotes> the wikipedia article is a good overview
02:43:40 <alinp> tail recursion, using examples and stuff
02:43:53 <alinp> yes, wikipedia is ok .. but I want something more specialized
02:43:56 <alinp> more details
02:44:07 <alinp> if not, I'll try wikipedia's liks
02:44:09 <alinp> links
02:44:20 <Saizan> what kind of details?
02:45:00 <alinp> for instance: details about tail recursion in a java context
02:45:06 <Gracenotes> there's not much to do with it... you can manually make a tail recursion function into an iterative one (if the language supports it), or the compiler can do it automatically, something call tail recursion optimization
02:45:22 <alinp> yes, if the language supports it
02:45:26 <Gracenotes> Java doesn't optimize tail recursion
02:45:31 <alinp> java afaik doesn't
02:45:35 <alinp> yes, indeed
02:45:37 <Gracenotes> it treats a recursive call as any other stack frame push
02:45:45 <Gracenotes> afaik.
02:46:03 <alinp> Gracenotes: you see, all these details I need to read about :)
02:46:12 <vixey> alinp: SICP
02:46:20 <Facedown> ##sicp
02:46:27 <Raevel> yep sicp
02:46:38 <mauke> http://img17.imageshack.us/img17/7679/sussmanashinonakukoroni.jpg
02:46:42 <alinp> oh, I'll take a look
02:46:44 <alinp> thanks ;)
02:46:53 <Gracenotes> mauke: I want to play that game :(
02:47:34 <wli> mmorrow: It's actually easily possible to improve on my strictness affair. I'm just avoiding coping with any sort of control flow to simplify it, and the goal was really just to get the really stupid stuff made entirely of arithmetic primops off the heap so as not to be outright offensivr.
02:49:05 <mmorrow> heh "outright offensive"
02:49:26 <Gracenotes> speaking of which, you need more strict anal
02:49:27 <mib_6b4goq9u> hi guys
02:49:35 <Gracenotes> er, hello mib_6b4goq9u
02:50:09 <mib_6b4goq9u> Does the $ have a speacial meaning in Haskell syntax?
02:50:32 <mib_6b4goq9u> Or do I have to dig in the code I am reading where it is redefined?
02:50:41 <p_l> as for TCO on java, I think some people get around it with goto (which is an instruction not used by Java in this way anywhere...)
02:50:51 <mauke> mib_6b4goq9u: no and no
02:51:06 * vixey 'gets around it' by using idiomatic java style such as while loops
02:51:40 <Heffalump> mib_6b4goq9u: well, sort of, but probably not
02:51:47 <Heffalump> $ is an operator with the normal definition f $ x = f x
02:51:52 <p_l> vixey: you can't issue a goto in Java, afaik. I meant "get around it" when you are writing compiler that targets JVM :D
02:51:58 <Axman6> @src ($)
02:51:58 * mauke avoids object attributes by making his variables final and creating derived classes on the fly
02:51:59 <lambdabot> f $ x = f x
02:52:03 <Axman6> mib_6b4goq9u: ^^
02:52:03 <Heffalump> (it has different precedence and fixity to normal function application, which is why it useful)
02:52:20 <mib_6b4goq9u> ok I am seeing withUnivArg :: YiAction (m ()) () => (Maybe Int -> m ()) -> YiM ()
02:52:28 <mib_6b4goq9u> withUnivArg cmd = do UniversalArg a <- withEditor getDynamic
02:52:30 <Heffalump> if it's right next to an expression or variable name, e.g $foo or $(foo), then in Template Haskell it means something different (a splice)
02:52:33 <mib_6b4goq9u> runAction $ makeAction (cmd a)
02:52:46 <Heffalump> ok, so there it's just function application with different precedence
02:52:54 <Heffalump> you could rewrite that last line runAction (makeAction (cmd a))
02:53:05 <mib_6b4goq9u> cool
02:53:08 <mib_6b4goq9u> but why is
02:53:15 <mib_6b4goq9u> the $ present then?
02:53:23 <Heffalump> because of the extra parens you need to get rid of it
02:53:33 <mib_6b4goq9u> ok
02:53:41 <Gracenotes> in "f x", f and x might each be many words
02:53:55 <Gracenotes> $ is a way to separate them, since its precedence is low
02:54:06 <trofi> :t ($!)
02:54:07 <lambdabot> forall a b. (a -> b) -> a -> b
02:54:20 <mib_6b4goq9u> oh to bind the parameters tighter
02:54:29 <wli> mmorrow: I'm in the midst of rewriting hash consing for the zillionth time, though this time I've at least got a parsing front end.
02:54:57 <wli> Actually I'm almost done.
02:55:14 <Gracenotes> mib_6b4goq9u: yes, but note, it accepts only one parameter. subtract $ 2 4 .. is not correct.
02:55:26 <Gracenotes> (well. at least for sane instances of Num.)
02:55:53 <trofi> > (+) $ 1 $ 2
02:55:54 <lambdabot>       Overlapping instances for Show (b -> b)
02:55:54 <lambdabot>        arising from a use of `s...
02:56:27 <wli> http://wli.pastebin.com/m7d056d0b <-- current code dump
02:56:48 <mib_6b4goq9u> thanks you guys are really cool, I honestly doubt whether I would be helping out so much as you guys even if I was smarter. :)
02:57:34 <mib_6b4goq9u> I mean 5 minutes and I get my doubts cleared
03:24:14 <twb> Does anybody have a Debian watchfile for a package that makes releases to hackage?
03:26:50 <blueonyx> hi
03:30:03 <twb> I found one in haskell-irc.
03:34:38 <akamaus> greetings
03:36:25 <akamaus> I'm trying to get the sample which fails quickcheck property in order to inspect it manually
03:36:41 <akamaus> I wrote this: http://pastebin.com/dbf0bb9c
03:37:02 <akamaus> but seems it gives wrong results..
04:00:19 <thoughtpolice> hm
04:00:32 * thoughtpolice is getting somewhere with trying to build 64bit ghc...
04:06:08 * wli is rapidly discovering all sorts of odd places variables get bound besides let expressions.
04:06:14 <yakov> hello
04:07:25 <yakov> guys, I can't find paper informally known as "Beautiful Visualization"
04:07:32 <yakov> could anybody please give me a hint
04:07:51 <yakov> it's about using Haskell to present scientific data (w/ OpenGL IIRC)
04:07:52 <zeno_> how to get these on ubuntu?
04:07:54 <zeno_> cabal: cannot configure leksah-0.4.3. It requires gtk >=0.10 and
04:07:55 <zeno_> gtksourceview2 >=0.10.0
04:09:38 <wli> wow, this is insanely painful
04:09:47 <yakov> (I've found it)
04:11:33 <zeno_> wli: what are you writing
04:11:46 <ivanm> zeno_: gtk2hs
04:11:58 <wli> an interpreter for some ill-defined mini-language
04:12:14 <zeno_> ivanm: hmm i installed that
04:15:06 <zeno_> oh didnt have some dependencies for it but it installed anyhow ic
04:17:46 <Saizan> dcoutts_: you could mention pkgenv http://article.gmane.org/gmane.comp.lang.haskell.cafe/53448 to get isolated environments, in your regression article
04:18:35 <Saizan> it hides the normal user packagedb too
04:18:37 <rittyan> is it okay to write my own 'filter' in haskell? I mean, do peopple do it from time to time?
04:18:57 <Saizan> rittyan: when learning, yes
04:19:33 <rittyan> hm, okay
04:19:52 <trofi> :t (on)
04:19:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:20:03 <trofi> :t filterBy
04:20:04 <lambdabot> Not in scope: `filterBy'
04:20:10 <Saizan> or if you need some variation, off course, like filterM
04:20:18 <Saizan> filter is already "By"
04:20:21 <Saizan> ?type filter
04:20:22 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:20:41 <mauke> filterNoBy :: [Bool] -> [Bool]
04:22:42 <Taejo> I'd go for filterNoBy :: [(Bool, a)] -> [a] (i.e. filterNoBy = map snd . filter fst)
04:23:08 <Taejo> or maybe just filterNoBy = filter fst
04:23:32 <mauke> class Boolean a where toBool :: a -> Bool; filterNoBy :: (Boolean a) => [a] -> [a]
04:23:49 <rittyan> is there a hex2char function, or better urldecode one? :)
04:25:31 <trofi> > readHex "0x0D" :: Char
04:25:32 <lambdabot>   Couldn't match expected type `Char'
04:25:37 <trofi> > readHex "0x0D" :: Int
04:25:38 <lambdabot>   Couldn't match expected type `Int'
04:26:23 <Axman6> :t readHex
04:26:25 <lambdabot> forall a. (Num a) => String -> [(a, String)]
04:26:25 <Saizan> rittyan: there's one in the HTTP package, iirc
04:26:34 <Saizan> ?hoogle urlDecode
04:26:34 <lambdabot> No results found
04:26:36 <mauke> http://hackage.haskell.org/packages/archive/url/2/doc/html/Network-URL.html#v%3AdecString
04:26:59 <Axman6> > readHex "0x1234abcd" :: [(Int,String)]
04:27:01 <lambdabot>   [(0,"x1234abcd")]
04:27:06 <Axman6> > readHex "1234abcd" :: [(Int,String)]
04:27:07 <trofi> :]
04:27:08 <lambdabot>   [(305441741,"")]
04:27:16 <trofi> > read "0x0D" :: Int
04:27:17 <lambdabot>   13
04:27:46 <rittyan> Saizan, thanks!
04:28:03 <ivanm> > readHex "0D" :: [(Int, String)]
04:28:04 <lambdabot>   [(13,"")]
04:29:38 <zeno_> rittyan: careful if its not a hex i think it dies
04:29:50 <zeno_> readHex "122" :: Int
04:29:55 <zeno_> > readHex "122" :: Int
04:29:56 <lambdabot>   Couldn't match expected type `Int'
04:30:25 <rittyan> well, I actually was needed a url decoding function
04:30:52 <trofi> :t runError
04:30:53 <lambdabot> Not in scope: `runError'
04:31:08 <trofi> :t runErrorT
04:31:09 <zeno_> rittyan: i think they implemented one for RWH
04:31:09 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
04:32:30 <Axman6> > readHex "1234abcdxyx123" :: [(Int,String)]
04:32:32 <lambdabot>   [(305441741,"xyx123")]
04:32:49 <Axman6> zeno_: just stops when it gets to something non hex
04:33:09 <zeno_> ah ok
04:33:23 <trofi> > readHex "z"
04:33:24 <wli> I think I'm paying a rather heavy price for my all-singing, all-dancing case expressions. Perhaps a heavier price than merited.
04:33:25 <lambdabot>   []
04:36:40 <wli> http://wli.pastebin.com/m2f29ad0f <-- code dump thus far... omfg I've still got 3 primcase types to go :(
04:52:43 <dcoutts> TomMD: pong
04:56:55 <NameAlreadyInUse> so how do i use ghc extensions like -XFlexibleInstances?
04:59:04 <Petrosian> NameAlreadyInUse: Put {-# LANGUAGE FlexibleInstances #-} at the start of a file.
04:59:19 <Petrosian> NameAlreadyInUse: Or :set -XFlexiableInstances in ghci.
04:59:39 <NameAlreadyInUse> ah thanks, that first one is what i was looking for
05:00:40 <Petrosian> You can also turn on the extensions with command-line flags to ghc
05:03:51 <NameAlreadyInUse> is there any way i can do "newtype Foo a = Num a => Foo a"?
05:04:10 <mauke> not in a useful way
05:04:44 <NameAlreadyInUse> what is the non-useful way, and what makes it non-useful?
05:05:12 <wli> phew, the 3 primcases turned out to be a lot easier since they didn't bind any vars in their alternatives and were all basically identical
05:05:40 <mauke> http://haskell.org/haskellwiki/Data_declaration_with_constraint
05:09:45 <wli> http://wli.pastebin.com/m118aac05 <-- code dump with primcases yanked off the AST
05:16:10 <kolmodin> ?ask waern många paket failar med "haddock: internal Haddock or GHC error: Maybe.fromJust: Nothing", vad göra?
05:16:10 <lambdabot> Consider it noted.
05:16:57 <wli> kolmodin: I heard a rumor you were fixing up gentoo's 6.10.2 to have readline support.
05:17:15 <kolmodin> wli: true. we've fixed it for ghc 6.10.1 too in the overlay
05:17:51 <wli> Well, shoot, I might as well migrate to 6.10.1 from the overlay, then.
05:18:23 <kolmodin> wli: just recompile and you should get all you need. we didn't bump the version
05:18:34 <wli> I masked 6.10.1 because the last time I installed it I got hurt.
05:18:44 <kolmodin> ouch :( what happened?
05:18:55 <wli> No readline. ;)
05:19:03 <kolmodin> haha, ok :)
05:19:08 <rittyan> oh, since you guys are gentooers, in what ebuild Network.URL is sitting?
05:19:29 <kolmodin> dev-haskell/network?
05:19:52 <rittyan> doesn't seem to be so
05:20:32 <Saizan__> kolmodin: is that with the new haddock and ghc-6.10.2?
05:20:51 <Saizan__> (the error i mean)
05:20:58 <kolmodin> Saizan__: it's with 2.4.1
05:21:08 <rittyan> kolmodin, because I have dev-haskell/network and cannot import url
05:21:29 <kolmodin> rittyan: I'll check
05:21:58 <rittyan> http://hackage.haskell.org/packages/archive/url/2/doc/html/Network-URL.html <- here's the url to what I want specificaly
05:22:04 <mk15> the :type of "readFile" returns an IO String
05:22:07 <Saizan> kolmodin: i've often got that with packages defining and using toplevel TH macros, and that should be fixed in 2.4.2 + 6.10.2
05:22:10 <mk15> does that mean it returns a monad?
05:22:15 <kolmodin> rittyan: Network.URL, not Network.URI ?
05:22:23 <mauke> mk15: what do you mean by "a monad"?
05:22:28 <kolmodin> rittyan: aha
05:22:46 <mk15> mauke: something that can have its contents extracted with >>=
05:22:51 <mauke> mk15: then yes
05:22:56 <rittyan> kolmodin, ah... URI has escape/unescape code... let me try to play with it.. maybe I don't need URL after all :)
05:23:27 <kolmodin> rittyan: ah, we don't have the url package as an ebuild (yet)
05:23:28 <Saizan> it's more properly called "monadic action" or just "action" or "monadic value"
05:24:32 <Saizan> monad refers to the type constructor 'm'
05:25:10 <rittyan> kolmodin, thanks! unEscapeString is what I need \o/ w00t
05:25:21 <kolmodin> rittyan: cool :)
05:25:35 <mk15> hmmm I  thought type constructors started with upper case letters?
05:25:48 <Axman6> they do
05:26:23 <wli> mk15: Constant/concrete ones do. Type variables can stand for type constructors, too.
05:26:38 <Saizan> mk15: yes, in your case the monad is IO
05:26:42 <wli> mk15: e.g. MonadState Int m => m Int
05:26:57 <Saizan> mk15: with m i was referring to the variable name used in type signatures
05:27:02 <Saizan> ?type (>>=)
05:27:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:27:49 <rittyan> though the problem with unEscapeString is that it accepts String, not ByteString
05:28:20 <mk15> thanks all (mauke, wli, Saizan)
05:29:25 <wli> mk15: silly :: (MonadState Int m, MonadIO m) => m () ; silly = do s <- liftIO getLine ; t <- get ; modify (+1) ; liftIO . putStrLn $ show t ++ ": " ++ show s ; silly
05:30:30 <mk15> :wli great ill check this out
05:30:54 <kolmodin> Saizan: good, so the trouble should go away then by upgrading
05:32:19 <michaelcdever> whats the difference between liftIO and forkIO??
05:32:39 <Saizan> they don't have much in common
05:32:48 <kolmodin> michaelcdever: forkIO will create a new haskell thread
05:33:05 <michaelcdever> and what does liftIO do?
05:33:10 <kolmodin> michaelcdever: while liftIO will execute a IO function in a transformer monad
05:33:27 <rittyan> how to convert ByteString to String?
05:33:28 <kolmodin> michaelcdever: so as Saizan said, they don't have much in common
05:33:44 <kolmodin> rittyan: unpack?
05:33:54 <michaelcdever> rittyan: unpack c where c is your bytestring
05:34:05 <trofi> @hoogle :: ByteString -> String
05:34:05 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
05:34:05 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
05:34:05 <lambdabot> Prelude show :: Show a => a -> String
05:34:07 <michaelcdever> ah ok kolmodin, cheers
05:36:16 <rittyan> is packing/unpacking fast enough to do something like.... B.pack . unEscapeString . B.unpack uri?
05:36:54 <trofi> how many megabytes per second do you plan to unpack?
05:37:04 <rittyan> ~30m/s
05:37:18 <rittyan> at least this is what current code shows
05:37:31 <rittyan> I wouldn't like to drop performance significantly
05:37:43 <trofi> is it IO bound?
05:37:50 <rittyan> yup
05:37:53 <kolmodin> rittyan: and how does the current code do it?
05:39:06 <trofi> you could use ByteString everywhere
05:39:20 <trofi> including file IO
05:39:23 <rittyan> kolmodin, http://pastebin.ca/1367976 <- here it is
05:39:43 <rittyan> tromp, except using 'unEscapeString' function that accepts strings only as I can get it from documentation
05:40:03 <trofi> ah, sorry, yes
05:40:11 <rittyan> that's the only problem :)
05:40:16 <trofi> @hoogle unEscapeString
05:40:16 <lambdabot> No results found
05:40:29 <rittyan> trofi, http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html#v%3AescapeURIString
05:41:34 <cocon> Couldn't match expected type `[a]' against inferred type `a1 -> b'
05:41:34 <cocon>     In the first argument of `List.foldr'
05:41:47 <cocon> ^ how is this possible?
05:45:33 <Axman6> List.foldr?
05:45:40 <bremner> cocon: arguments in wrong order?
05:49:34 <mk15> perhaps someone can help me decode this signature:
05:49:35 <mk15> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
05:49:35 <mk15> my interpretation: mapM takes in two parameters PLUS a monad via the >>= operator. The first parameter is a function that takes a value from the list of the second parameter, and ??????
05:51:26 <EvilTerran> er
05:51:44 <EvilTerran> ?src mapM
05:51:44 <lambdabot> mapM f as = sequence (map f as)
05:53:39 <EvilTerran> functions don't really "take in ... a monad", seeing as monads are types
05:55:54 <mk15> EvilTerran: hmmm, k
05:56:28 <EvilTerran> ?type sequence
05:56:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:57:19 <mk15> EvilTerran: I typed that out in my ghci....I have problems understanding these function signatures when there are monads
05:57:46 <Deewiant> Understanding type classes in general first might be a good idea
05:57:57 <mk15> EvilTerran: for example, what does the "=>" mean?
05:58:02 <Deewiant> ?type (==)
05:58:03 <lambdabot> forall a. (Eq a) => a -> a -> Bool
05:58:14 <mk15> EvilTerran: does it mean that a monad is passed via the >>= operator?
05:58:16 <Deewiant> mk15: Start with stuff like this and work your way up :-)
05:58:20 <EvilTerran> mk15, no
05:58:29 <Petrosian> Understanding kinds might not hurt either
05:58:35 <Petrosian> ?type fmap
05:58:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:58:58 <mk15> Deewiant: I understand that signature just fine....when there are no "=>" symbols
05:59:22 <Deewiant> Well, the '=>' symbol and what's to the left of it is kind of crucial to really understanding what it means :-)
05:59:55 <rittyan> @hoogle :: [Char] -> String
05:59:56 <lambdabot> Distribution.Simple.Utils dotToSep :: String -> String
05:59:56 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
05:59:56 <lambdabot> Distribution.Simple.Utils lowercase :: String -> String
05:59:56 <mk15> Deewiant: ok whats the symbol names so I can google it :)
06:00:04 <Deewiant> I have a lot of work to do so I'm hoping somebody else will explain this in detail
06:00:11 <rittyan> [Char] vs String = same thing?
06:00:13 <Deewiant> mk15: But basically, what you want to understand is type classes.
06:00:18 <Botje> rittyan: yes
06:00:20 <Deewiant> ?src String
06:00:20 <lambdabot> type String = [Char]
06:00:39 <Botje> mk15: the part to the left of => means "f is an instance of the Functor typeclass"
06:00:48 <Botje> which means f is a type that supports fmap
06:01:02 <EvilTerran> ?src Functor
06:01:02 <lambdabot> class  Functor f  where
06:01:02 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:01:52 <dcoutts_> Saizan: it should be possible to hide the user package db in Cabal too, it's just a matter of rearranging some apis
06:02:17 <dcoutts_> well, actually it's mostly changes to the UI that's needed
06:02:33 <dcoutts_> internally we can work with an arbitrary stack of package dbs
06:02:34 <mk15> Botje: Thanks, thats all I needed :)
06:03:31 <Botje> mk15: DO read some more about typeclasses though
06:03:57 <mk15> Botje: I think I was reading about them in the Real World Haskell book....ill go reread it
06:05:36 <cocon> why is there no strict version of foldr?
06:07:39 <rittyan> decodeUri :: B.ByteString -> B.ByteString
06:07:41 <rittyan> decodeUri uri = B.pack $ unEscapeString $ show uri
06:07:42 <gwern> @hoogle foldr
06:07:42 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
06:07:42 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
06:07:42 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
06:07:47 <rittyan> do you know how to optimize this function?
06:07:59 <gwern> cocon: probably because there is a strict foldl
06:08:00 <rittyan> I lose about 60 seconds on this one
06:09:10 <cocon> gwern: ?
06:09:25 <cocon> gwern: but if does something different
06:09:45 <gwern> but anyway there is a foldr'
06:09:58 <gwern> so the equivalence of foldr and foldl is irrelevant
06:10:21 <cocon> gwern: where is foldr'?
06:10:31 <gwern> hoogle it
06:12:12 <cocon> is hoogle down or is it me?
06:13:12 <thoughtpolice> http://downforeveryoneorjustme.com/haskell.org/hoogle
06:13:37 <cocon> it says it looks down
06:14:05 <gwern> down for me too
06:14:10 <cocon> gwern: so do you remember where foldr' is defined?
06:14:11 <gwern> luckily I have hoogle installedl ocally
06:14:17 <gwern> hoogle! not just web 2.0!
06:14:21 <cocon> up again
06:14:25 <gwern> it's web 0.0 as well!
06:14:40 <Saizan> dcoutts_: pkgenv seems to do that using the current UI
06:14:41 <cocon> it's in Foldable
06:14:44 <ziman> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:foldr
06:15:11 <dcoutts_> Saizan: oh well maybe it does work then using --global --package-db=
06:15:18 <gwern> ah, hoogle's loaded
06:17:04 <akamaus> is there anyway to reproduce quickcheck test case which failed the property? It's printed to stdout, but I want to get the value
06:19:23 <gwern> there are a number of qc functions which return more complex than IO ()
06:19:42 <gwern> look at them, I think you can probably extract the counterexample from the status record. or something.
06:27:03 <akamaus> gwern: I tried, I came to this: http://pastebin.com/dbf0bb9c
06:27:22 <akamaus> but I can reproduce the original value from stdGen
06:27:26 <akamaus> * cant
06:33:42 <Heffalump> dcoutts_: I'm not convinced that building just what can be installed simultaneously makes sense. for d in $(cat pkgs) ; do cabal install (...) $d ; done seems more useful to me
06:33:50 <Heffalump> (from the pov of regression testing)
06:34:42 <dcoutts_> Heffalump: that'll involve re-installing some things several times
06:34:59 <Heffalump> you mean different versions of the same thing?
06:35:06 <Heffalump> the same versions will stay around between installs
06:35:26 <dcoutts_> right, one package needs HaXml-1.13.x and another needs HaXml-1.19.x
06:35:34 <Heffalump> but that's fine
06:35:42 <Heffalump> you can have those two installed simultaneously
06:35:51 <dcoutts_> so we'll keep rebuilding things that depend on HaXml between the two versions
06:36:03 <dcoutts_> for things that need both HaXml and things that depend on it
06:36:13 <Heffalump> ah, right
06:36:20 <Heffalump> still, it seems like a more useful test
06:36:24 <dcoutts_> that's not necessarily bad
06:36:31 <dcoutts_> it just means more builds
06:37:01 <Heffalump> I tried it (following your instructions otherwise), but I found that cabal-install kept building the setup program for things it was installing, even if they were build-type: Simple
06:37:16 <dcoutts_> Heffalump: yes, that's an effect of the logging
06:37:36 <Heffalump> ah. That's really annoying, because it dominated the build time for most things.
06:37:45 <dcoutts_> :-(
06:38:25 <dcoutts_> Heffalump: the mechanism for logging has to be rewritten to make it work better
06:38:48 <dcoutts_> currently it works by calling the external setup and redirecting its output to a file
06:38:54 <Heffalump> will just using summaries have that problem too?
06:39:00 <dcoutts_> no
06:39:16 <dcoutts_> we always generate local summaries anyway
06:39:50 * Heffalump tries that then
06:40:20 <Heffalump> also, is there any way to remove the root-cmd from the cmdline (it's set in my cabal config)
06:40:30 <Heffalump> I guess I should just point at a clean config, though.
06:40:51 <dcoutts_> Heffalump: that'd be best. There isn't any command line for it I don't think.
06:44:29 <defun> :t (<*>)
06:44:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:03:43 <joaopizani> > sum [1,2,3,4]
07:03:44 <lambdabot>   10
07:07:35 <vininim> > sum $ take 100 [1..]
07:07:37 <lambdabot>   5050
07:10:31 <sundaymorning> vininim: I think you should concentrate more on your college assignments, after you're done with them you play with haskell and stuff.
07:12:27 <vininim> lolwat
07:13:44 <vininim> sundaymorning: i'm done, as far as schedule go =P
07:14:18 <sundaymorning> I mean, you're probably have a compiler's assignment that you already didn't turn in and you probably have to work on an article for some class
07:14:47 <sundaymorning> but you're just browsing 4chan and asking questions to lambdabot
07:14:51 <ImInYourMonad> how important is objectivityin a search engine? im building a search engine and will partly use boss and imthinking to integrate with latest tweets about it etc but when doing that im not neutrally searching the web but starting with a few specific places. that might make the results more relevant but also skew them. as long as this is stated, no problem?
07:16:15 <sundaymorning> what do you mean by objectivity?
07:16:40 <vininim> lol, my schedule is on track but thanks. =P
07:16:59 <vininim> and I haven't browsed 4chan for some months now, too boring
07:17:13 <sundaymorning> I know it's not, my name is Mariza Bigonha, and I KNOW what you're doing
07:17:17 <sundaymorning> I ALWAYS KNOW
07:17:43 <vininim> what? I thought your name was Rafael Almeida?
07:17:59 <sundaymorning> why would you think that of me?
07:19:31 <ImInYourMonad> sundaymorning: i mean users expect you to just collect data and rank them with no personal preference and not having the site infer what is relevant
07:19:42 <ImInYourMonad> http://www.reddit.com/r/programming/comments/86jbk/higher_order_functions_considered_unnecessary_for/ <- what do you think about that?
07:20:01 <vininim> that or marcot, because I would guess Mariza schedule to be tighter than mine. =P
07:21:29 <sundaymorning> nah, my schedule is free. My husband and daughter do most of the work. I grade tests every now and then, but that doesn't take more than a couple minutes.
07:21:41 <vininim> lol
07:22:25 <sundaymorning> ImInYourMonad: if your rank is modified by personal preferences, that seems a bit screwed up. But if you start at sites you think that will let you reach more of the web, then it looks fine to me.
07:25:57 <ImInYourMonad> http://www.stsc.hill.af.mil/crosstalk/2005/12/0512CroxfordChapman.html <- uh is that about functionalprogramming? i didnteven get the article
07:26:29 <ImInYourMonad> sundaymorning: yeah not my personal preferences but like you say use sites that i think can give mroe relevance
07:28:18 <sundaymorning> weighting the links of certain sites could be a good idea, but you have to have means to weight those. You really have to experiment with those kind of things to understand if they're helping or not
07:28:24 <sundaymorning> for that you need a user base even
07:30:58 <sundaymorning> in my experience with ir (not all that lot, actually) algorithms for ranking pages usually have cases where they really help and cases which they make it worse. Which one you choose depends on how many sites you are indexing, what kind of information people are searching for, etc
07:31:09 <sundaymorning> gee, he left me talking alone :(
07:31:48 <vininim> well, maybe those sites that receives many links, let's call it authorities, get some weighting in keyword, while those sites that point to the authorities, let's call them hubs, get weighting in links
07:32:08 <vininim> we can then rank the pages, and make some billion dollars
07:33:36 <sundaymorning> I like delicious idea the best, actually
07:34:02 <sundaymorning> aside from spamming, the idea of searching for sites that were actually useful to people is quite nice
07:35:48 <goomba``> have you heard of wolfram alpha sundaymorning
07:36:24 <goomba``> its going to answer people's questions supposedely
07:36:27 <zachk> so what is that haskell linux distro with all the latest goodies
07:36:48 <sundaymorning> goomba``: never heard of it
07:37:04 <goomba``> its an up and coming search engine
07:42:20 <sundaymorning> you can't really search it yet, right?
07:42:28 <sundaymorning> at least it doesn't seem to work here
07:43:19 <goomba``> not yet
07:44:00 <zachk> > let catalan=0:1:1:(zipWith (+) catalan  (zipWith (+) (tail catalan) ((tail.tail) catalan))) in take 10 catalan
07:44:01 <lambdabot>   [0,1,1,2,4,7,13,24,44,81]
07:44:09 <zachk> yay and on my first try
07:45:12 <byorgey> those... don't really look like Catalan numbers =)
07:45:37 <mauke> > let xs@(_:t@(_:tt)) = 0:1:1:map sum (transpose [xs,t,tt]) in xs
07:45:39 <lambdabot>   [0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,6...
07:45:39 <zachk> yea i just wiki'd it. D: its not
07:46:56 <Saizan> @oeis 0,1,1,2,4,7,13,24,44,81
07:46:57 <lambdabot>  Tribonacci numbers: a(n) = a(n-1) + a(n-2) + a(n-3) with a(0)=a(1)=0, a(2)=1.
07:46:57 <lambdabot>  [0,0,1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136,5768,10609,19513,35890,...
07:47:26 <byorgey> @oeis catalan
07:47:27 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
07:47:27 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
07:48:21 <zachk> @src tranpose
07:48:21 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:51:17 <zachk> > let a=[[1,2,3],[4,5,6],[7,8,9]] in (transpose.transpose) a==a
07:51:19 <lambdabot>   True
07:51:50 <vixey> > let a=[[1,2,3],[4,5,6,8242],[7,8,9]] in (transpose.transpose) a==a
07:51:51 <lambdabot>   False
07:52:07 <beelsebob> @check \x -> (transpose . transpose) x == x
07:52:09 <lambdabot>   "Falsifiable, after 0 tests:\n[[],[]]\n"
07:52:28 <Taejo> transpose [[],[]]
07:52:29 <Taejo> >transpose [[],[]]
07:52:39 <Taejo> > transpose [[],[]]
07:52:40 <lambdabot>   []
07:53:08 <zachk> > transpose [[]]
07:53:09 <lambdabot>   []
07:54:32 <byorgey> > let { (<<*>>) (x:xs) (y:ys) = x*y : (zipWith (+) (map (*x) (ys)) (xs <<*>> (y:ys))); catalan = 1 : catalan <<*>> catalan } in take 15 catalan
07:54:33 <lambdabot>   [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440]
07:55:14 <gwern> 'The U.S. has had none of them. It came closest during the Revolutionary War, when it churned out Continental currency to pay the bills. The peak monthly inflation rate then was 47.4%, in November 1779. During the Civil War greenbacks were printed to finance the fighting, and inflation peaked in March 1864 at a monthly rate of 40%.'
07:55:21 <gwern> oop.s mischan
07:55:39 <edwardk> @pl \j f g x y -> f x `j` g y
07:55:39 <lambdabot> ((flip . ((.) .)) .) . (.)
07:55:42 <edwardk> blech
07:57:52 <vixey> :t uncurry
07:57:53 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:58:07 <vixey> @pl \j f g x y -> uncurry j (f x, g y)
07:58:07 <lambdabot> (. (flip . (((.) . (,)) .))) . (.) . (.) . (.) . uncurry
07:59:10 <Saizan> ?type \j f g -> uncurry $ liftM2 j (f . fst) (g . snd)
07:59:11 <lambdabot> forall b c c1 a b1 c2. (c1 -> c2 -> b -> c) -> (a -> c1) -> (b1 -> c2) -> ((a, b1), b) -> c
08:03:05 <EvilTerran> ?type \j f g x y -> f x `j` g y
08:03:06 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t4
08:03:50 <Jasper> I have a homework related question, which I hoped someone could help me with.
08:04:44 <Heffalump> sure
08:05:17 <Jasper> The book we are using does things like: Given this data structure: data Expr Fl Float | In Int
08:05:28 <Heffalump> data Expr = Fl ... ?
08:05:50 <Jasper> I'm sorry, indeed
08:06:07 <Jasper> data Expr = Fl Float | In Int
08:06:46 <Jasper> It does things like defining functions with the type In->String
08:07:00 <mauke> invalid. In is not a type
08:07:05 <Heffalump> that can't be the same In as the one in Expr
08:07:17 <sundaymorning> I want to draw an infinite line using hopengl, anyone knows how to do it?
08:08:03 <sundaymorning> so far I'm using renderPrimitive Lines and setting very large values on vertexes
08:08:54 <vixey> sundaymorning: if you want true infinite you may have to compute this explicitly and render it directly
08:08:55 <Jasper> it can't? It really even includes an assignment in which I have to write such a function, at least if I am imterpreting it correctly (which I probably am not)
08:09:22 <zachk> sundaymorning: infinite is a process. so how in a finite amount of time do you expect to draw an infinite line on a finite state machine (ala a computer)
08:09:46 <vixey> I don't agree with infinite is a process applying here
08:10:26 <sarh> zachk we're talking about lines.  infinite line = line
08:10:47 <Heffalump> Jasper: in that definition, In defines a value of type Int -> Expr
08:10:49 <Heffalump> it does not define a type.
08:10:52 <Heffalump> what book is this?
08:10:55 <sarh> sundaymorning iirc OpenGL doesn't have any 'infinite line' primitive, just line segments
08:11:18 <sundaymorning> got it, thanks
08:11:41 <vixey> that doesn't mean it's impossible
08:12:23 <zachk> sundaymorning: just break your infinite line into an infinite number of finite line segments
08:12:29 <sundaymorning> yeah, I can draw it wherever the user looks at, I was just wondering if that couldn't be made automatically
08:12:35 <Jasper> it's a Dutch book written by a number of my teachers. Is it okey if I copy the assignment so you can see whether it's just plain wrong or whether I am interpreting it incorrectly?
08:12:39 <vixey> zachk: That doesn't work
08:12:57 <zachk> vixey: why wouldnt it
08:13:09 <sarh> zachk keep your trolling to other channels, thanks
08:13:15 <Heffalump> Jasper: sure.
08:13:21 <Heffalump> what uni is this?
08:13:26 * zachk thinks sarh is rude
08:13:42 <vixey> sarh: I think he's trying to help, just the ideas he said didn't apply to opengl
08:14:09 <vixey> sarh: In any case calling people trolls seems counterproductive
08:14:12 <Jasper> it's Utrecht University
08:14:31 <zachk> sundaymorning: do you want an infinite straight line? or one going around in a spiral perhaps
08:14:41 <vixey> sarh: it might seem like a nice descriptive term but in actuality it's a tool for bullying people ..
08:14:44 <Heffalump> jasper: ok, then at least one of the lecturers hangs out here sometimes :-)
08:14:59 <Jasper> ah :)
08:15:07 <Heffalump> anyway, stick the exercise on hpaste or whatever and we can advise
08:15:11 <sundaymorning> straight
08:15:19 <sundaymorning> for x, y and z axis
08:19:30 <vixey> "Martijn van Steenbergen requested feedback on a proposed module collecting utilities for working with type equality proofs."
08:19:38 <vixey> uh ... why?
08:19:47 <Heffalump> why not?
08:19:59 <vixey> congruence closure is already implemented in GHC -- System Fc(X) or whatever it's called
08:20:08 <Heffalump> only in the backend
08:20:51 <vixey> I guess that what I really want to know is what programs people are writing that use this
08:21:19 <Heffalump> I don't know about this specific library, but I find myself passing around equality proofs quite a lot when using typed abstract syntax.
08:21:40 <vixey> it sounds like he just saw something neat in Agda and copied it
08:21:58 <vixey> Heffalump: what programs over it?
08:22:09 <Heffalump> optimisers and the like
08:22:23 <Heffalump> if you want to compare two expressions for equality, you want to get a proof that the types are equal too
08:23:37 <Jasper> Heffalump: It seems I created the problem myself (in data Prop = Var Var | ... with a type Var = String; I decided to rename the second Var to solve the ambiguity (read: reader/writer ambiguity), but failed to notice the excercise's Var should be renamed as well)
08:23:37 <vixey> yeah this all happens behind the scenes
08:23:48 <vixey> making it explicit seems to defeat the purpose a bit
08:24:03 <vixey> probably it's unavoidable in some cases
08:24:45 <Heffalump> vixey: not really, the front-end thing will end up as back-end proof
08:24:51 <Heffalump> I don't think it could be inferred automatically.
08:25:04 <edwardk> slowly bundling a bunch of that monoid stuff i was rambling on about the other day into a package for hackage http://comonad.com/haskell/lexical-monoids/
08:25:26 <edwardk> i could probably use some help coming up with a more idiomatic UTF8 decoder though
08:25:54 <edwardk> and i'm not entirely sure i've selected the most appropriate classnames.
08:28:06 <edwardk> basically some combinators for lexing using monoids, which automatically parallelizes lexing lazy bytestrings, with monoids for utf8, a kinda hackish one for word splitting, and one for tracking source position
08:28:12 <edwardk> i could use some ideas for other monoids too
08:28:21 <Jasper> I then have another (less important) question, which I thought was possibly related, but turns out not to be. Let's use the simple data Expr = Fl Float | In Int again. Now say we have a function f::Expr->String, can one write f(In 4)? Our book does so quite often, but ghc complains about the constructor not being in scope when I do so
08:28:29 <edwardk> and i need to document it ;)
08:30:08 <Heffalump> Jasper: yes, you can
08:30:19 <Heffalump> is this all in one module?
08:32:07 <Jasper> No it is not... I was defining the Module in one file and typing in the example input given in the command line of ghci, so that's what's causing the problem
08:32:27 <Heffalump> you need to export Expr(..) from the module
08:32:34 <Heffalump> that'll export Expr and all its constructors
08:33:04 <Jasper> And you type the export in ghci or write it in your module?
08:33:09 <Heffalump> in the module
08:33:16 <Heffalump> module Foo (Expr(..)) where
08:33:40 <Heffalump> that'd just export Expr(..), obviously there might need to be other things within the brackets too
08:33:43 <mauke> or you can load the source in ghci and access everything
08:33:58 <Heffalump> mauke: that depends on whether there's a compiled object around
08:34:21 <Jasper> Okey, thanks a lot, Heffalump, I think I can happily continue on the assignment :)
08:34:30 <mauke> you can explicitly load the source
08:34:42 <Saizan> or use "module Foo where" which exports everything
08:35:17 <Heffalump> oh yes, what Saizan said makes most sense for just homework code
08:35:21 <Heffalump> mauke: how?
08:35:37 <mauke> :m + *Foo
08:35:39 <mauke> I think
08:35:42 <Heffalump> oh, right. ta.
08:36:37 <Jasper> okey, thanks everyone
08:38:38 <skorpan> is it possible to override (or hide) an instance of Show which is imported from another module?
08:39:35 <tromp> import Module hiding
08:39:42 <Saizan> no, you can't hide instances in general
08:39:57 <Saizan> you can use a newtype, or just use another function
08:40:19 <skorpan> then i'll go for a newtype...
08:40:21 <tromp> oops, i misunderstood
08:41:25 <ImInYourMonad> how did the pirate bay trial relaly ned?
08:43:05 <Heffalump> dcoutts_: actually, how do I override what config file cabal is using?
08:43:58 <dcoutts_> Heffalump: --config-file=
08:44:24 <Heffalump> ah. Either that's not in the command-line help or I'm blind.
08:44:41 <dcoutts_> Heffalump: it's not in the --help output I think
08:46:09 <Heffalump> ok, ta
08:46:25 * Heffalump leaves his computer building away and goes to make a high chair
08:47:40 <tromp> :t mapM
08:47:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:53:36 <mk15> ?src readFile
08:53:36 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
09:00:20 <zachk> sundaymorning: im working on what you asked for
09:01:22 <tromp> @hoogle stripSuffix
09:01:22 <lambdabot> No results found
09:01:57 <sundaymorning> zachk: cool, I'm reading the red book right now
09:02:06 <sundaymorning> I already found out a few things I was doing wrong :)
09:09:04 <sundaymorning> zachk: btw, do you know if it's possible to call mainLoop then close the window, then change the display function and call mainLoop again, creating a new window?
09:13:08 <zachk> sundaymorning: im not sure about opengl too much. ive mostly just used to do some 2d nbody simulations
09:13:38 <zachk> sundaymorning: you might be better off puting the extra functionality into the display function
09:13:45 <sundaymorning> I never used opengl, the closest of that kind of thing I came to was pygame
09:15:33 <sundaymorning> but now I'm writing a program for plotting curves on screen. I hope it will help me with my calculus study. I also hope to make some physics simulations later on
09:16:07 <zachk> sundaymorning: ill hpaste the code i wrote, im having library problems i just switched back to linux
09:19:16 <zachk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2762#a2762 sundaymorning
09:19:36 <zachk> oh wtf there is cmds in the middle of it
09:19:38 <rovar> is there a way I could convert a  [ (ByteString, IO MyType) ]   to  IO [ (ByteString, MyType) ]
09:19:43 <zachk> scroll down and it should be fine
09:19:46 <vixey> rovar: yes
09:19:50 <rovar> kind of like a sideways sequence
09:20:12 <vixey> first solve a simpler problem, (ByteString, IO MyType) -> IO (ByteString, MyType)
09:21:08 <mauke> :t uncurry (fmap fmap (,))
09:21:09 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
09:21:39 <rovar> wow
09:21:44 <byorgey> nice =)
09:21:46 <rovar> i thought I was getting the hang of haskell
09:22:09 <byorgey> rovar: you are.  that doesn't mean you know everything there is to know =)
09:22:57 <rovar> now I need to get my paper out and draw a bunch of lines trying to figure out what the hell that is doing
09:23:26 <byorgey> I don't even get what it is doing.
09:23:46 <mauke> @unpl uncurry (fmap fmap (,))
09:23:47 <lambdabot> uncurry (fmap fmap (,))
09:23:50 <mauke> wat
09:23:53 <vixey> hehe
09:24:14 <rovar> lambdabot doesn't even know what it is doing :)
09:24:35 <mauke> \(a,b) -> fmap ((,) a) b
09:24:41 <EvilTerran> ?type fmap fmap (,)
09:24:42 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
09:25:20 <byorgey> oh, the second fmap is (.)
09:25:22 <byorgey> sneaky
09:25:32 <byorgey> er, the first
09:25:33 <EvilTerran> ... or is the first fmap (.)?
09:25:51 <byorgey> infix vs, prefix, blah blah
09:25:55 <EvilTerran> i *think* it's uncurry (fmap . (,))
09:26:27 <byorgey> yup
09:26:58 <vixey> :t uncurry (fmap . (,))
09:26:59 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
09:27:07 <byorgey> rovar: you could also use something less obfuscated like  f (bs, io) = do { m <- io; return (bs, m) }
09:27:18 <Deewiant> ?pl \(a,b) -> fmap ((,) a) b
09:27:18 <lambdabot> uncurry (fmap . (,))
09:27:19 <EvilTerran> ... isn't that "strength"?
09:27:21 <byorgey> then map that over the list, and then sequence
09:27:44 <byorgey> EvilTerran: what's "strength"?
09:27:51 <mauke> what is love?
09:27:57 <EvilTerran> http://comonad.com/reader/2008/deriving-strength-from-laziness/
09:27:59 <ddarius> @src mapM
09:27:59 <lambdabot> mapM f as = sequence (map f as)
09:28:06 <Saizan> ?google strong functor
09:28:08 <lambdabot> http://home.imf.au.dk/kock/SFMM.pdf
09:28:08 <lambdabot> Title: Strong functors and monoidal monads
09:28:14 <vininim> baby don't hurt me
09:28:46 <byorgey> EvilTerran: so it is.
09:31:23 <ImInYourMonad> since all haskell programmers ar eminor gods
09:31:37 <ImInYourMonad> http://apiwiki.twitter.com/Search+API+Documentation <- is that supposed to be done in javascript? querying the site?
09:33:35 <vininim> Is anyone else stacking up a pile of papers cited here to read later... and now with more than 20 papers not yet read? =P
09:33:48 * vixey doesn't have any new papers to read
09:34:01 <ddarius> vininim: I have thousands of papers and a few hundred that I've not yet read.
09:34:08 <ddarius> I didn't get most of them from here though.
09:34:39 <ImInYourMonad> vixey: what do you study?
09:34:58 <vixey> linear logic
09:37:02 * EvilTerran has a dozen or so "to-read" papers, most of which he got from here directly or indirectly
09:37:28 * byorgey too
09:37:36 <ImInYourMonad> * ImInYourMonad is to awesome to read papers
09:38:06 <Badger> /me
09:38:11 * Badger uses /me
09:38:56 * ImInYourMonad doesn't read papers, he writes papers other people read
09:39:36 * Badger grabs ImInYourMonad's copy of the times
09:39:51 <vixey> I'd write papers but
09:39:54 <vixey> 1) I don't have anything to say
09:40:00 <vixey> 2) nobody would publish it
09:40:09 <vixey> 3) nobody would /understand/ it if they read it
09:40:42 <vixey> I seem to be completely unable to convey any meaningful content people didn't already know
09:41:44 <smtms> you should tart doing that "research" thing
09:43:33 <sundaymorning> vixey: get yourself some reputation (or get someone with reputation to co-author) and fix number 2.
09:44:02 <pejo> sundaymorning, I think 1) is a bigger problem actually.
09:44:26 <sundaymorning> ideally, yeah.
09:44:28 <ImInYourMonad> 1) has never been a problem for anyone
09:45:40 <ImInYourMonad> neither has 3) people will pretend
09:45:45 <sundaymorning> Maybe things would be more interesting if people requested papers instead of people wanted to publish articles.
09:46:02 <ImInYourMonad> then where will originalwork come from?
09:46:12 <sundaymorning> what you mean?
09:47:27 <ImInYourMonad> if everything isdone by request
09:47:37 <Olathe> ImInYourMonad: It would come from the people who come up with which papers to ask for and the people who figured out how to write them.
09:47:40 <sundaymorning> you got a question, you don't know the answer, you ask, someone answers with an article they wrote based on the research they were doing. Nowadays people just report in their work and they have to report in something
09:47:54 <mightybyte> @pl (\a b -> (f a, g a))
09:47:55 <sundaymorning> that's how crappy articles appear.
09:47:55 <lambdabot> const . liftM2 (,) f g
09:48:23 <sundaymorning> actually, the problem is researchers having to publish something
09:48:31 <ImInYourMonad> ok
09:49:25 <sundaymorning> it makes little sense to me that someone has to publish a given number of papers in order to be a college professor
09:49:57 <p_l> sundaymorning: depends on the country, and there's a difference between "proffessor" and just "lecturer/teacher" in many places
09:50:00 <rovar> it does kind of mess up the signal to noise ratio
09:51:01 <sundaymorning> well, yeah, if the person is a teacher and not a researcher as well, then it makes even less sense. But I don't think a researcher should have to publish periodically
09:51:06 <Olathe> If one paper is as good as another, that will happen.
09:51:32 <Olathe> Otherwise, you have to have some way of figuring out which things matter to people.
09:51:35 <sundaymorning> because research is not like engineering, you get to dead ends, you realise you weren't researching something interesting, etc.
09:52:33 <sundaymorning> so, if you publish periodically you're bound to publish crap or co-author stuff you don't even understand well.
09:52:52 <Olathe> If publishing crap brings you a lot of benefit, sure.
09:53:02 <Olathe> Helps you to keep your job and so on.
09:53:02 <p_l> sundaymorning: Well, in poland there was a motion to remove "habilitation" (I can't find translation for it) from requirements for "full" proffessor status
09:53:12 <p_l> sundaymorning: for some reason, liberal arts complained :>
09:53:25 <pejo> sundaymorning, there's plenty of people who publish periodically without producing large amounts of crap.
09:53:58 <bremner> p_l: there is no real translation for habilitation; I think France and Germany use the same term
09:54:01 <sundaymorning> pejo, I'm sure there is
09:54:17 <Olathe> There are rewards for doing that, too.
09:54:26 <Olathe> You get respect and so on.
09:55:03 <sundaymorning> the thing is that asking for publishing periodically incentivate more crap publishing than interesting ideas publishing
09:55:17 <vixey> I don't think so sundaymorning
09:55:28 <Olathe> Sure, if there's no difference in reward for crap or great things.
09:55:33 <vixey> monad reader is published periodically and the quality of that has not droppe
09:55:39 <Olathe> Why not produce crap if you don't care too much ?
09:55:44 <bremner> sundaymorning: agreed. But also hiding in your office for 10 years is not that helpful
09:55:53 <Olathe> Sure, but the people running Monad Reader throw out crap.
09:55:58 <Olathe> Which is great.
09:56:08 <stepcut> Olathe: :)
09:56:20 <sundaymorning> well, sometimes the paper is not really crap, but doesn't add all that much as well. You pretty much have to publish to a good conference, but you get accepted for things that are not really all that great and things people won't even look over
09:56:57 <vixey> sundaymorning: in my opinion, applications aren't what justifies research
09:57:07 <sundaymorning> bremner: yeah, society hasn't quite figure out how to reward the researcher, I think
09:57:27 <pejo> sundaymorning, my impression is that the good conferences actually have referees who read the articles.
09:58:08 <sundaymorning> vixey: what do you think justifies research?
09:58:27 <bremner> sundaymorning: thats true. But also we need some way to prevent researcher from being equivalent to holiday
09:58:50 <goomba``> make them code things instead of write papers
09:59:00 <vixey> yeah what we need is more buggy code
09:59:16 <ImInYourMonad> spj publishes all the time for great good of the haskell!
10:00:19 <sundaymorning> I decided to get a job instead of going into masters in part because I didn't really think people around me were researching interesting topics, they seemed more concerned with publishing articles than actually researching
10:00:51 * p_l considers going for PhD after his studies
10:00:53 <sundaymorning> maybe that's different somewhere else, and I hope to be able to research there some day.
10:01:43 <brad_larsen> If I use GADTs for a data type, ghc tells me it can't derive instances for Show, Eq, Ord, etc.
10:01:43 <sundaymorning> I understand that in the united states it's common to go straight to phd, but in Brazil the path is masters degree and then phd, I think it's the same as in europe
10:02:11 <brad_larsen> Is this because that is simply not implemented, or because with GADTs it makes derivation undecidable?
10:02:23 <ImInYourMonad> is the job market superstrong for PhDs? really well-paid?
10:02:33 <pejo> sundaymorning, I don't think there's anything implying that publishing will be less important in the near future. The metrics for what constitutes a good article might change, but funding agencies are still trying to measure how good your research is by your track record.
10:03:01 <lumi> Here's a weird question: Has anyone tried to build Haskell programs to run on Arm/Wince?
10:03:06 <sundaymorning> ImInYourMonad: I suspect it depends on your field, but not that highly paid overall I think
10:03:16 <pejo> @google why are there so few women in science philip greenspun
10:03:17 <lambdabot> http://philip.greenspun.com/careers/women-in-science
10:03:17 <lambdabot> Title: Women in Science
10:03:20 <ImInYourMonad> i mean after youve done your PhD
10:03:31 <brad_larsen> ImInYourMonad: No PhD here, but considering it.  In CS, from a few datapoints I have, the salary is good
10:03:39 <p_l> sundaymorning: In Scotland what is required is "Honours" degree, which is either Bachelor + Honours or Masters
10:03:46 <pejo> ImIn, that article answers some of your questions.
10:04:06 <brad_larsen> ImInYourMonad: e.g. a freshly-minted PhD going to Intel starting at ~83k euros
10:04:09 <sundaymorning> most people who have phd that I know of are professors in universities, they don't make huge amounts of money, but they're doing alright.
10:04:11 <brad_larsen> ImInYourMonad: or 89k, i don't remember
10:04:33 <p_l> Well, I'm thinking of moving away from scotland anyway :D
10:04:39 <brad_larsen> tenure track faculty positions in CS, in the US at least, pay well
10:05:05 <ImInYourMonad> when I am 25 then 89K, thats what i will wipe my ass with when i run out of toilet paper
10:05:29 <dons> sjanssen: debian installs _overlayed_ on the source downloads: http://xmonad.files.wordpress.com/2009/03/xmonad-source-vs-debian.png
10:05:42 <p_l> ImInYourMonad: I wouldn't do that even with £100 million a year :D
10:05:45 <dons> sjanssen: does that look like a "distro effect" reducing source builds to you?
10:06:25 <dons> source installs inversely proportional to how well the code is packaged in distros?
10:06:28 <pejo> brad_larsen, but what you're measuring there is what the smartest guy you ever knew, that worked all the time from his phd up until he got tenure is making. There's a lot of people who don't even get the tenure track position, and some who do get it don't get tenure.
10:06:32 * p_l always has a use for money to spend on
10:07:12 <sundaymorning> dons: what's the curve and what's the bars?
10:07:45 <dons> the curve is debian install votes (people using popcon). the bars are source downloads from hackage
10:07:53 <pejo> brad_larsen, and you're not counting the lost income during the 5+ years that person got a phd, or the $35k post-doc position(s) he or she had.
10:08:05 <sundaymorning> oh, I use xmonad from debian packages
10:08:11 <Igloo> dons: It's impossible to say, but I suspect the bargraph shows the "new shiny" effect, primarily amongst Haskellers
10:08:25 <Igloo> dons: While the line shows adoption among non-Haskellers
10:08:47 <Igloo> dons: You should really use % for the popcon graphs, BTW, not the absolute number
10:08:56 <sundaymorning> I'd rather use the darcs version in order to get the latest features and test them, but last time I checked I needed newer version of some libraries, so I dropped it for the time being
10:08:59 <dons> oh, yes. that's right.
10:09:10 <dons> they're approx the same curve though. so ok for this graph.
10:09:35 <dons> Igloo: yes, hmm. though i think the 'new shiny' effect in haskell world was earlier.
10:09:53 <Igloo> e.g. http://qa.debian.org/popcon.php?package=dpkg certainly isn't showing a surge in dpkg's popularity  :-)
10:09:53 <dons> the big bump was when it was popular enough for non-haskellers to go to the trouble of getting  the source. boy, that was a headachey time
10:10:27 <brad_larsen> pejo: i don't remember which report I saw.  a prof. showed it to me, to try to assuage my fears that a PhD would put me in a bad place, money-wise
10:10:36 <dons> i think this is the first time i've seen distro / source overlapped like this
10:10:55 <brad_larsen> pejo: for tenure-track CS positions, even with just a PhD, the salary was not bad
10:11:05 <brad_larsen> pejo: much lower for non-tenure track positions
10:11:41 <sundaymorning> I started using it after I saw a presentation simon gave to google. He used xmonad code, I think that was around that boom period, so I guess that had something to do with the boom as well.
10:12:55 <p_l> XMonad is growing, so it's probably a big source of new people
10:12:57 <Heffalump> if you want to do a non-academic job after your PhD the PhD will probably hurt your salary (certainly compared to having worked your way up that job instead of doing the PhD)
10:13:08 <pejo> brad_larsen, but you should compare this with what a person with similar drive and skills could do if they weren't getting a phd. I'm not saying people should stay away from getting a phd, I'm saying they should be getting one for the right reason, and a nice salary in the end is not the right reason - you'll earn more as a medicine doctor or a lawyer.
10:13:30 <p_l> Heffalump: depends on what you PhD was about, I guess
10:13:44 <Heffalump> I said probably, there are certainly exceptions.
10:13:54 <brad_larsen> pejo: i don't disagree, i'm just saying with a CS phd, the money probably won't be bad
10:13:58 <bremner> pejo: or a drug dealer.
10:14:10 <brad_larsen> pejo: i.e. you won't be living on ramen once you start working ;-)
10:14:42 * stepcut was eating ramen yesterday.. 
10:14:57 <sundaymorning> I think if your goal is to earn lots of money, legally, you shouldn't even get a CS degree
10:15:03 <pejo> brad_larsen, but neither will someone with a bachelors degree.
10:15:22 <Heffalump> sundaymorning: depends, most good jobs require a degree of some form
10:15:32 <sundaymorning> yeah, not CS degree, though
10:17:11 <vixey> @w80 labile
10:17:14 <lambdabot> *** "labile" wn "WordNet (r) 2.0"
10:17:14 <lambdabot> labile
10:17:14 <lambdabot>      adj 1: open to change; liable to change; "an emotionally labile
10:17:14 <lambdabot>             person"
10:17:14 <lambdabot>      2: (chemistry, physics, biology) readily undergoing change or
10:17:16 <lambdabot>         breakdown
10:17:33 <p_l> everytime I'm looking for jobs, it's either "relevant degree" or "n years of experience" or both of those. Mind you, I have yet to see someone have any information about how you could get that work experience :)
10:17:52 <Heffalump> plenty of companies give jobs to graduates
10:18:00 <ddarius> p_l: Military.
10:18:05 <goomba``> i am a chemistry student, in this field not getting a PhD is sort of failure
10:18:27 <p_l> ddarius: I'm considering that too, but it's tricky bussiness
10:18:30 <ImInYourMonad> goomba``: why?
10:18:34 * ddarius will probably never get a PhD, unless I do it just for the heck of it.
10:18:58 <ImInYourMonad> a PhD is liek 8 years in uni sint it? 5years for a master then a 2-3year doctorate?
10:19:18 <vininim> you can go right to doctorate
10:19:20 <goomba``> ImInYourMonad, there arent many serious jobs you can take with just the BS, and Masters degrees are skipped over
10:19:23 <stepcut> p_l: one method is to get hired and then transfer to a better position after you are hired. I have seen someone with out a degree get hired to do telephone tech support and then transfer to linux kernel development ;)
10:19:36 <Heffalump> depends what country, in the UK you can do BSc then PhD - 3 years each
10:19:55 <ImInYourMonad> oh 6 years for a PhD, not that bad
10:19:58 <p_l> stepcut: try finding that out before joining the company. No, I do not want to end on helpdesk if I can help it :D
10:20:10 <goomba``> you go straight to the PhD work and the consolation prize is a Masters
10:20:15 <p_l> ImInYourMonad: Depending on what you are getting PhD in, you might wing it in one year
10:20:28 <Heffalump> getting a PhD in one year would be very unusual
10:20:50 <Heffalump> stepcut: I'm sure that happens, but it won't be easy
10:21:12 <pejo> Heffalump, how common is it that people from a bs actually finish their phd in 3 years?
10:21:13 * ddarius has too little formal education and too little youth to really be interested in a PhD now without wanting to be an academic.
10:21:24 <p_l> Heffalump: the formula is: grab a certain kind of science major, tell them the topic, find them with a new PhD a year later. I heard similar people exist in liberal arts, but are rarer :P
10:21:53 <rovar> sorry to go off topic, but I've got an odd problem with Binary.Put
10:21:55 <p_l> mind you, the PhD area doesn't necessarily have to be in their major
10:22:09 <rovar> maybe there is a clever way to solve this recursively.
10:22:13 <ImInYourMonad> if i do this: learn program really well so i really master haskell + c/c++ + python and have a really solid understanding of algorithms and datastructures, then i do 1-2 years at uni studying linear algebra(which have done soem already), discrete math, diff equations, statistics, topology, diff geeomtry, harmooinc anaylsis and soem random physics courses, a cours ein operating systems and one in ahrd ware. I should be able to do th
10:22:14 <Heffalump> pejo: not sure. Most people doing PhDs in the UK don't finish in the 3 years, so probably not very.
10:22:28 <Heffalump> ImInYourMonad: you cut off at "I should be able to do th"
10:22:38 <ImInYourMonad>  2 years. then im done. you think it is possibleto get a really good job doing image analysis afer that?
10:22:48 <stepcut> Heffalump: it is 'easy' if you are actually qualified to do the programming work. If you are underqualified, then not.
10:22:49 <ImInYourMonad> like medical image analysis
10:22:49 <vininim> I should be able to do th
10:22:51 <rovar> I'm putting a binary protocol where the length  of an object is prefixed at the start of the object. But I don't know its length in bytes until I put it out to a bytestring
10:22:53 <p_l> ImInYourMonad: I think you forgot AI
10:22:59 <ImInYourMonad> AI = math
10:23:05 <p_l> ImInYourMonad: nope
10:23:14 <bremner> cough
10:23:25 <ImInYourMonad> no such thing as ai: linear algebra, staticstics,optimization(forgot to take that course)
10:23:31 <vininim> simbolic AI is ``math''
10:23:42 <vixey> no it's not
10:23:52 <p_l> vininim: yeah, but math is not everything in AI :)
10:23:57 <goomba``> machine learning uses alot of that math
10:23:59 <brad_larsen> machine learnings ~ applied statistics
10:24:02 <brad_larsen> ;-)
10:24:06 <ddarius> rovar: The easy but slow way is to put it out to a separate bytestring, take the length, and then put that bytestring.
10:24:08 <p_l> brad_larsen: true
10:24:13 <goomba``> but there are tons of ideas to know about the application of that math =]
10:24:27 <rovar> ddarius: yea, that's the approach I'm taking at the moment
10:24:35 <p_l> also there's a lot of stuff that is not your normal math in that :)
10:25:00 <brad_larsen> anyone know why ghc can't derive instances for a GADT?  is the general problem undecidable with GADTs, or is it just not implemented in ghc?
10:25:03 <vininim> well, operationally you must find heuristic so that it works efficiently...
10:25:07 <rovar> ddarius: it's either that or write my own hacked Put which doesn't actually put yet..
10:25:27 <vixey> brad_larsen: it's not implemented
10:26:36 <ImInYourMonad> but modern AI is machine learning basically: the guys that do AI, do they even know what they do?
10:26:38 <brad_larsen> vixey: so it's something that i could potentially contribute to ghc?  hmm.
10:26:51 <vixey> brad_larsen: I don't think it would be a valuable contribution
10:27:17 <vixey> brad_larsen: almost any GADT (that shouldn't better be written as an ADT) wouldn't be able to have things derived for it
10:27:29 <p_l> ImInYourMonad: If we knew, it wouldn't be called *research*
10:27:58 <vixey> brad_larsen: also GADTs let you define a class of ADTs and data types that operate over the entire class
10:28:00 <ddarius> rovar: Other than the fact that you will lose some potential laziness, it should not be much slower than putting things out directly.
10:28:08 <vixey> so in a way you can DIY derive things in that way
10:28:10 <p_l> ImInYourMonad: There's also a lot of philosophy & psychology in AGI research
10:28:13 <ImInYourMonad> p_l: fair enough but there is science and there is pseudo-science
10:28:28 <brad_larsen> vixey: such as?  i've only considered simple uses of gadts then, such as more type-safe ASTs.
10:28:29 <ImInYourMonad> i dotn want to build an AI anyway
10:28:35 <ImInYourMonad> image analysis doesnt need AI
10:28:49 <p_l> ImInYourMonad: I have yet to see pseudo-science AI stuff. And we have AIs already, image analysis is one of the kinds ;D
10:28:53 <goomba``> vixey so does GADTs sort of replace the functionality of deriving? and adds more?
10:29:11 <ImInYourMonad> image analysis seem to be machien elarning to me...
10:29:26 <ImInYourMonad> what do you mean with AI?
10:29:32 <vixey> goomba``: no because it is so horribly awkward to use
10:29:33 <ImInYourMonad> biological neuralnets?
10:29:36 <p_l> ImInYourMonad: And machine learning is the name used to hide AI from managers who think AI is bad :P
10:29:42 <vininim> gah
10:29:49 <goomba``> vixey, drat
10:29:53 <vininim> machine learning is part of AI
10:29:58 <ImInYourMonad> yes
10:30:23 <vixey> brad_larsen: you might define an untyped ADT and a stripping function that erases types -- that way you can used derived functions like show
10:30:26 <p_l> ImInYourMonad: ... The moment I'll hear that line for the third time, I'll kill the person. Biological neuralnets == AI, they are a *subset*
10:30:38 <p_l> *!=
10:30:59 <p_l> damn, rage caused me to use wrong operator
10:31:03 <sundaymorning> vininim: you know nothing about management
10:31:10 <rovar> p_l: don't code angry
10:31:10 * bremner is glad he is not in poland, so getting killed by p_l is less likely
10:31:31 <p_l> bremner: I'm currently in UK
10:31:40 <ImInYourMonad> p_l:so what does an AI researcher do with his day?
10:31:43 <vininim> sundaymorning: wat
10:31:50 <rovar> p_l: were you in Poland previously?
10:32:01 <vixey> ahaha
10:32:03 <p_l> ImInYourMonad: Try to narrow it first... AI is a *broad* subject
10:32:10 <p_l> rovar: born and raised there :)
10:32:36 <vixey> @remember <p_l> damn, rage caused me to use wrong operator <bremner> is glad he is not in poland, so getting killed by p_l is less likely
10:32:36 <lambdabot> Done.
10:32:44 <rovar> p_l: where at? I was just in Torun last fall at the College, and then toured a bit.
10:33:22 <p_l> rovar: near Warsaw, and spend every summer (except last) in Elbląg
10:33:25 <brad_larsen> vixey: do you have an example of a stripping function?  i've seen examples of untyped ADTs, with functions that *add* types to them.
10:33:59 <rovar> p_l:  that looks like a fun place to spend a summer. I was thinking about booking a vacation there with my wife and kid.
10:34:01 <vixey> data Typed t where Number :: Integer -> Typed Integer ; If :: Typed Bool -> Typed a -> Typed a -> Typed a
10:34:32 <p_l> rovar: Well, that's where my grandparent's lived. And I was later flying on gliders there :)
10:34:43 <rovar> nice
10:34:44 <vixey> data Untyped = UNumber Integer | UIf Untyped Untyped Untyped
10:35:04 <vixey> strip (Number i) = UNumber i ; strip (If b t e) = UIf (strip b) (strip t) (strip e)
10:35:16 <vixey> brad_larsen: now, showTyped = show . strip
10:35:23 <p_l> rovar: Now I'm thinking that coming to UK was a mistake
10:35:46 <brad_larsen> vixey: aha.  thanks for clarifying.
10:36:34 <rovar> p_l: what would be the motivation for leaving Poland? (aside from being able to get a job :) )
10:37:17 <rovar> p_I: also, any recommendations for coastal towns to visit?
10:37:24 <p_l> rovar: I moved to Scotland for university
10:37:28 <brad_larsen> vixey: do you have a short example of a GADT for which one couldn't derive, say, Show?
10:37:44 <p_l> rovar: unfortunately, not much, I'm more of a mountain person and have a bad memory for cities :)
10:37:53 <rovar> heh
10:38:09 <p_l> rovar: if you don't have problems with polish language, I recommend checking out smaller towns near coast as your "base"
10:39:30 <rovar> p_l: I can speak it a lot better than I can read it.   That really isn't saying much at all though. I studied quite a bit last summer and after coming back home, had no one to speak with and am rapidly forgetting it
10:39:32 <m4nic> is there a way to make a Map of an data using derive, does something like this already exists if all members of the datatype a Showable ?
10:40:40 <PeakerWork> is there a reversible computation arrow in a library somewhere?
10:41:16 <PeakerWork> I saw a paper once, but its an arrow (except arr, as usual)
10:43:01 <sjanssen> dons: oh yes
10:43:38 <sjanssen> dons: I bet April 2008 was when Debian fixed their xinerama packaging bug
10:43:54 <stepcut> m4nic: happstack-ixset?
10:46:35 <dons> sjanssen: http://www.reddit.com/r/programming/comments/84sqt/dear_reddit_i_am_seeing_12_articles_in/c08dp72
10:48:42 <rovar> heh
10:49:21 <rovar> i often wonder why reddit has become the hub of such conversation
10:49:28 <rovar> it is written in ASP.net (last I checked)
10:49:31 <tromp> @hoogle hGetContents
10:49:31 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
10:49:32 <lambdabot> System.IO hGetContents :: Handle -> IO String
10:49:32 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
10:50:15 <tromp> @hoogle getContents
10:50:15 <lambdabot> Prelude getContents :: IO String
10:50:15 <lambdabot> Data.ByteString getContents :: IO ByteString
10:50:15 <lambdabot> System.IO getContents :: IO String
10:50:17 <ddarius> What's wrong with ASP.NET?
10:50:24 <tomh> rovar: reddit was never written in asp.net
10:50:31 <rovar> hrrm.. that seems to not be the case now
10:50:41 <vixey> Awesome Server Pages
10:50:45 <rovar> tomh, good.  :)
10:50:47 <vixey> that's what ASP means
10:51:53 <rovar> it's gone through some significant change. the html used to be horribly formed and mangled with tables, now it's clean and div oriented.
10:51:58 <rovar> much easier to scrape :)
10:52:13 <tomh> 'div oriented' lol
10:52:29 <lowmagnet> I wrote a dirty css filter to drop everything but the links to the articles
10:52:37 <lowmagnet> looks sorta like news.ycombinator
10:52:38 <tomh> why would you wanna scrape it anyway
10:52:51 <rovar> aggregation
10:52:59 <tomh> they have rss :)
10:53:33 <rovar> i'm pretty sure they didn't back when I was interested in scraping it.
10:53:47 <tomh> ah ok, must been a while ago then
10:54:06 <rovar> 2 years? maybe 1 year.. don't recall
10:54:13 <Heffalump> dcoutts_: is there an obvious way to list the [non-|]recursive reverse-depends of a package?
10:54:42 <rovar> i had a simple python app that put all of the best of slashdot, digg tech and delicious into a kde widget
10:54:53 <rovar> now I just use popUrls.com :)
10:54:59 <mauke> "it is called /bin/true"
10:56:12 <ddarius> mauke: Indeed.
10:57:31 <dons> so this long tail effect on hackage http://galois.com/~dons/hackage/zipfs-law.png
10:57:45 <dons> gives me some thoughts on hackage itself- it should operate like a 'long tail' marketplace
10:57:59 <dons> i.e. like amazon. so reviews, votes, and links to point people to the less popular tail
10:58:17 <dons> and then we can do popularity by category and so on.
10:58:36 <Heffalump> hmm
10:58:49 <Heffalump> I think that might be overkill.
10:59:04 <Heffalump> Does it really work on other software distribution sites that do it?
10:59:04 <dons> well, we're planing on popularity by category.
10:59:12 <dons> not sure.
10:59:24 <Gracenotes> well, the way it's set up point people towards common dependencies
10:59:31 <Heffalump> my feeling is that it doesn't really. People determine popularity or appropriateness by out-of-band mechanisms.
10:59:35 <Gracenotes> which are gonna be more popular
10:59:36 <dons> this is classic long tail though, http://galois.com/~dons/hackage/longtail.png  which has some well known ways to help good stuff in the tail thrive
10:59:40 <dcoutts_> Heffalump: not from the command line no, there's no reverse deps info available.
10:59:59 <dons> dcoutts_: have you seen these graphs?
11:00:02 <dcoutts_> Heffalump: internally we have a map and a graph and a function to look up reverse deps
11:00:02 <Heffalump> dcoutts_: ok. It's just after realising how long this build will take, I'd have liked to restrict it to deps of mtl.
11:00:13 <Heffalump> internally in the cabal-install source?
11:00:19 <dcoutts_> Heffalump: yep
11:00:38 <Heffalump> ok, I might have a dig then. Are you interested in exposing it, and if so how?
11:00:59 <Gracenotes> dons: how do you have people use packages that don't suit their needs? like, asking them to download category-extras or something
11:01:13 <dons> no, no. :)
11:01:31 <dons> make sure that it doesn't just rely on out-of-band means to find other libs
11:01:39 <bremner> just make ghc include all of hackage. Probably not a noticable size bump
11:01:49 <dons> e.g. if you're on an xml lib page, it should suggest other xml libs, and other libs people also use when using xml
11:01:54 <goomba``> it would at least inform people of packages they might want to use
11:02:54 <dons> dcoutts_: did you see this: http://galois.com/~dons/hackage/hackage-future.png
11:02:58 <dcoutts_> Heffalump: you could construct the InstallPlan for the whole lot, extract the planIndex and use reverseDependencyClosure [mtl]
11:03:21 <dcoutts_> dons: yes I did :-) I might chop off a couple years though
11:03:25 <Heffalump> but the whole lot doesn't have an install plan, right?
11:03:27 <ddarius> dons: That seems excessive...
11:03:44 <dcoutts_> dons: predicting 5 years based on one year of data :-)
11:03:46 <dons> it's a joke :)
11:04:05 <dons> what would be reasonable though?
11:04:10 <dons> the next 2 years?
11:04:23 <ddarius> dons: People who don't pay attention to the axes/title may get the wrong impression.
11:04:29 <Elly> yikes
11:04:50 <Elly> by 2030 hackage will be using more bandwidth than the present-day internet
11:05:09 <dons> limits of growth eh
11:05:14 <ddarius> Elly: The 2030 Internet will have ridiculously more bandwidth than now.
11:05:19 <Heffalump> and by 2050 it'll be using more bandwidth than the entire internet, through the magic of Haskell
11:05:23 <dons> hehe
11:05:24 <dcoutts_> dons: what is the Y axis? downloads per what time unit?
11:05:32 <dons> each month
11:05:36 <rovar> hopefully by that time we'll have something more intelligent than TCP and BGP
11:05:40 <dcoutts_> dons: ok, better say that
11:05:43 <dons> yeah
11:06:05 <mstr> by 2050 we live in nuclear wasteland, coding haskell on cave walls with charcoal
11:06:24 <dcoutts_> dons: so that straight line prediction puts us on ~5m downloads per month by the end of 2011
11:06:24 <p_l> well, TCP isn't that bad, but BGP...
11:07:04 <p_l> also, it would be nice if networks stopped breaking IP deliberately
11:07:24 <p_l> it was bad enough with buggy routers
11:07:34 <dons> dcoutts_: right, that seems conservative. since we're on 1M now, and cabal-install's not quite everywhere yet
11:07:37 <dcoutts_> dons: is that right? are we at 1m downloads per month at the moment?
11:07:47 <dons> urgh. no.
11:07:51 <dons> sorry. that's total downloads
11:08:06 <dons> you're looking at cumulative downloads
11:08:07 <Heffalump> I think graphs of per-month figures would be most useful
11:08:23 <dcoutts_> dons: ahhh, 1m ever downloaded since the beginning of hackage
11:08:38 <dons> yep. Heffalump; yes, useful.
11:08:42 <dcoutts_> dons: that's more like it, though still nice. Does that include the 00-index.tar.gz file?
11:08:57 <dons> dcoutts_: nope
11:09:08 <dons> that's foo-x.y.tar.gz only
11:09:16 <dcoutts_> dons: 00-index.tar.gz is an excellent indicator of cabal-install usage but should obviously be excluded from download stats
11:09:23 <dons> yep
11:09:30 <sundaymorning> by 2051 we'll all be on IRC telling the young kids how they have it easy.
11:09:33 <dons> this is the cumulative total, http://galois.com/~dons/hackage/hackage.png
11:09:47 <dcoutts_> dons: I'd also be interested to see downloads by user agent over time, cabal-install vs all other agents
11:09:50 <mstr> sundaymorning: we already do that :/
11:10:02 <dons> dcoutts_: ok.
11:10:17 <dcoutts_> dons: I declare victory when cabal-install overtakes other people downloading manually with browsers, wget etc
11:10:37 <sundaymorning> dons: what did you use to generate that graph?
11:10:43 <Heffalump> dcoutts_: that's only a local victory, not a victory for Haskell.
11:10:53 <dcoutts_> Heffalump: yes, a personal victory :-)
11:11:02 <Igloo> dons: For finding the libraries that I want, questions like http://www.tex.ac.uk/cgi-bin/texfaq2html?label=letterclass in the UK TeX FAQ is by far the best thing I've seen
11:11:35 <pejo> Is there socks5-support in cabal-install?
11:11:45 <dcoutts_> pejo: nope
11:11:54 <dcoutts_> pejo: only normal http proxies
11:11:55 <sundaymorning> the problem with cabal, distutils, ruby gems, etc is that each language has its own and then there's things like apt-get, yum, etc
11:11:58 <trofi> @go tsocks
11:11:59 <lambdabot> http://tsocks.sourceforge.net/
11:11:59 <lambdabot> Title: tsocks - Transparent SOCKS Proxying Library
11:12:21 <dcoutts_> sundaymorning: that's why the automatic translators cabal->native are so important.
11:12:22 <TomMD> It would be neat to have a SOCKS package on hackage.
11:12:37 <dons> sundaymorning: gnuplot
11:13:07 <ddarius> sundaymorning: You should be using your distribution's tools to the extent possible.
11:13:24 <sundaymorning> dons: what did you use for the line color and shape?
11:13:36 <sundaymorning> ddarius: I agree with that
11:14:19 <dons> dcoutts_: quick grep. 230k cabal-install downloads
11:14:22 <dons> it may already have won..
11:14:33 <dons> sundaymorning: hmm?
11:15:33 <TomMD> dons: He thinks you used special options to set the line color, width, etc.
11:15:57 <sundaymorning> dons: always when I generate curves on gnuplot they don't look as smooth, so I was wondering what you used for linestyle and stuff like that. If you didn't do it by hand, nevermind then
11:16:27 <dons> oh, linecolor 3 linewidth 3
11:16:45 <dons> i use the visualizer (set output wxt)
11:16:53 <dons> which does antialiasing
11:16:58 <sundaymorning> hm
11:17:16 <sundaymorning> thanks
11:32:36 <trofi> @go bash eval on haskell
11:32:38 <lambdabot> http://blog.malde.org/index.php/2008/07/11/functional-bash-bracketing/
11:32:38 <lambdabot> Title: BHLog » Functional bash: bracketing
11:34:29 <gwern> I can't help but think that solution looks way too complex
11:34:36 <gwern> isn't that what subshells are for?
11:35:32 <gwern> bracket () { $1; shift; ("$@"); } practically gets you all the way there
11:35:36 * trofi searches shell evaluator implemented in haskell
11:36:10 <trofi> or better an AST builder
11:36:22 <gwern> I forget, is ketil male ketil here?
11:36:25 <gwern> @seen ketil
11:36:26 <lambdabot> I saw ketil leaving #haskell 7m 8d 19h 42m 21s ago, and .
11:37:12 <gwern> @ask ketil re http://blog.malde.org/index.php/2008/07/11/functional-bash-bracketing/ some reason you don't use 'local' or subshells like () ?
11:37:12 <lambdabot> Consider it noted.
11:37:13 <pejo> gwern, lb is forgetful, he was here in January this year atleast.
11:37:22 <gwern> @flush
11:37:30 <ddarius> preflex: seen ketil
11:37:30 <preflex>  Sorry, I haven't seen ketil
11:37:35 <ddarius> preflex: seen ketilm
11:37:35 <preflex>  Sorry, I haven't seen ketilm
11:37:37 <zax> How would you do a smirk smiley?
11:37:59 <trofi> ,\bot could have separate thread to sync itself once a day
11:38:03 <gwern> I like ~_-
11:38:05 <lunabot>  luna: parse error on input `)'
11:38:06 <mauke> preflex lost its brain
11:38:23 <ddarius> Damn zombies.
11:38:51 <gwern> ddarius: they're not unreasonable; I mean, nobody's gonna eat your eyes
11:39:11 <ddarius> That's true.  One doesn't really need their brain anyway.
11:39:35 <gwern> (fyi, you're all gonna die)
11:39:53 <ddarius> gwern: I hope so.
11:40:44 <gwern> no no, I was quoting coulton's re: your brains song, one of my favorites :(
11:42:29 <Nafai> I'd like to write a IRC bot in Haskell, but it needs to be able to connect via SSL.  Are there libraries that make this easy?
11:43:08 <skorpan> how does fmapDefault work?
11:43:11 <gwern> ssl? I think there's one ssl binding lib, but no idea how useful it'd be
11:43:24 <chessguy> @seen Trippy
11:43:25 <lambdabot> I haven't seen Trippy.
11:43:31 <chessguy> , @seen Trippy
11:43:32 <lunabot>  luna: parse error on input `@'
11:44:15 <ddarius> :t fmapDefault
11:44:16 <lambdabot> Not in scope: `fmapDefault'
11:44:27 <ddarius> @hoogle fmapDefault
11:44:27 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
11:44:41 <ddarius> @src Traversable
11:44:41 <lambdabot> class (Functor t, Foldable t) => Traversable t where
11:44:41 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
11:44:41 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
11:44:41 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
11:44:41 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
11:45:07 <ddarius> skorpan: Presumably it uses traverse at the identity functor.
11:45:27 <skorpan> @src Identity
11:45:28 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
11:46:10 <skorpan> what bothers me the most is that Traversable needs an instance of Functor and fmapDefault needs an instance of Traversable...
11:46:23 <skorpan> currently i'm just using an empty instance of Traversable
11:46:29 <ddarius> skorpan: fmapDefault is the proof that any Traversable is a Functor.
11:46:59 <ddarius> I.e. you can make an instance of Traversable and then simply define instance Functor Foo where fmap = fmapDefault
11:47:22 <skorpan> weird.
11:47:34 <ddarius> skorpan: It's like liftM
11:47:44 <Gracenotes> > (':':).(:[])$'D'
11:47:45 <lambdabot>   ":D"
11:47:47 <Gracenotes> :D
11:48:09 <skorpan> > reverse "D:"
11:48:11 <lambdabot>   ":D"
11:48:18 <skorpan> not quite as cool
11:49:04 <skorpan> > reverse "D==8"
11:49:06 <lambdabot>   "8==D"
11:49:09 <skorpan> har har
11:50:51 <tromp> > chr 63
11:50:52 <lambdabot>   '?'
11:51:14 <tromp> > chr 47
11:51:16 <lambdabot>   '/'
11:59:30 <Gracenotes> > let vkey = "lengthtwelve"; info = "possiblymorethanlength12" in map chr $ (zipWith xor `on` map ord) (cycle vkey) info
11:59:32 <lambdabot>   "\FS\n\GS\DC4\GS\n\CAN\SO\b\ETX\EOT\NUL\CAN\r\SI\t\CAN\r\SUB\DLE\DC1\EOTGW"
12:00:21 <Gracenotes> > let vkey = "lengthtwelve"; info = "\FS\n\GS\DC4\GS\n\CAN\SO\b\ETX\EOT\NUL\CAN\r\SI\t\CAN\r\SUB\DLE\DC1\EOTGW" in map chr $ (zipWith xor `on` map ord) (cycle vkey) info
12:00:23 <lambdabot>   "possiblymorethanlength12"
12:05:11 <mortenlysgaard> Is it possible to give store a function in a datatype, eg: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2765#a2765
12:06:21 <mauke> yes
12:06:29 <mauke> (Double -> Double)
12:07:00 <mortenlysgaard> I don't think i understand you?
12:07:05 <andyou> mauke: Double the fun!
12:07:13 <LeoD> data Neuron = Neuron [(Neuron, Double)] (Double -> Double)
12:07:38 <vixey> data Neuron double = Neuron [(Neuron double, double)] (double -> double)
12:07:40 <vixey> can work too
12:08:01 <vixey> sometimes abstracting something out makes other operations more natural -- hard to tell if it would in this case though
12:08:10 <vixey> quite a complex data
12:09:11 <mortenlysgaard> What dous (Double -> Double) in the datatype mean? I've never seen it before
12:09:52 <goomba``> a function that takes a double and produces a double
12:09:56 <LeoD> it's a function taking a double and retuning a double
12:10:06 <mortenlysgaard> Ah! Hehe
12:10:17 <mortenlysgaard> Makes sense now :D
12:10:52 <mortenlysgaard> So that's how you would write a function in a datatype?
12:11:00 <LeoD> yes
12:12:38 <mortenlysgaard> Nice, now it works :D
12:17:39 <skorpan> is there in general any performance penalty in having instantiated (or derived) Eq for a data type?
12:19:35 <ddarius> Not likely.
12:27:40 <skorpan> so suppose i have a tree like data structure and i want to run a function (lacking better terminology) on every part of the tree, should i go for defining this in fmap or define traverse using fmap = fmapDefault?
12:28:45 <wli> Traversable gives you the advantage of immediately having mapM at one's disposal.
12:29:08 <skorpan> so what's the difference between fmap and mapM here?
12:29:31 <vixey> just curious, what is this tree like?
12:29:37 <skorpan> it's an AST
12:29:52 <roconnor> fmapDefault?
12:30:04 <wli> Foldable will also get you mapM_
12:30:18 <wli> They're convenient to have around.
12:30:19 <roconnor> I'm really confused.  fmap and mapM have totally different types
12:30:29 <skorpan> :t mapM
12:30:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:30:31 <skorpan> :t fmap
12:30:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:30:32 <roconnor> well, I guess fmap can be implemented by mapM with the identity monad
12:31:15 <roconnor> but mapM can't be implemented in terms of map
12:31:28 <wli> @type join . fmap (undefined :: t -> m t')
12:31:29 <lambdabot> forall a (m :: * -> *) t'. (Functor m, Monad m) => m a -> m t'
12:32:01 <skorpan> but looking at mapM, ... hum.
12:32:09 <skorpan> i don't get it.
12:32:21 <skorpan> or i should say, i don't get how i could use it for my AST
12:32:27 <roconnor> wli: that is too special cased
12:32:45 <roconnor> @type traverse
12:32:46 <lambdabot> Not in scope: `traverse'
12:32:47 <skorpan> my tree looks something like: data Tree t = Function t (Tree t) t | Var [t]
12:33:17 <mauke> that's not a tree
12:33:26 <roconnor> skorpan: with mapM, you have to chose an order for the effects to be sequenced.
12:33:34 <wli> Maybe so. Still, I use mapM on all sorts of Traversable things all the time, and mapM_ on other sorts of traversable things all the time.
12:33:51 <pejo> skorpan, Neil Mitchell and Colin Runciman have a paper about Uniplate where they show how it's used in yhc to save lots of boilerplate code. It's not fmap or mapM though.
12:33:52 <skorpan> that's not a tree?
12:34:02 <roconnor> maybe I should stay out of this conversation, since I'm confused.
12:34:19 <skorpan> pejo: i stay as far away from generics as possible, having aborted a master thesis about it :P
12:34:24 <mauke> looks like a list to me
12:34:37 <mauke> ([(t,t)], [t])
12:34:48 <vixey> skorpan: can you say a bit about this "aborted a master thesis on generics"?
12:35:19 <skorpan> vixey: the idea was basically to try to figure out whether rewrite rules and such could help the performance in SYB
12:35:20 <pejo> skorpan, their functions are very readable I'd say.
12:36:06 <roconnor> mapM f (Function a b c) = f a >> mapM f b >> f c  ?
12:43:16 <wli> mapM f (Function x t y) = do { x' <- f x ; t' <- mapM f t ; y' <- f y ; return $ Function x' t' y' } ; mapM f (Var xs) = do { xs' <- mapM f xs ; return $ Var xs' }
12:44:36 <wli> skorpan: It doesn't really branch.
12:46:18 <wli> I've never figured out what gmapT, gmapQ, gmapQi, gmapM, gmapMp, gmapMo, et al are supposed to be.
12:51:03 <ddarius> skorpan: Uniplate isn't based on SYB.
12:53:34 <skorpan> ddarius: i know
12:54:25 <PeakerWork> @hoogle gmapT
12:54:25 <lambdabot> Data.Generics.Basics gmapT :: Data a => (b -> b) -> a -> a
12:54:32 <PeakerWork> @hoogle generics
12:54:32 <lambdabot> module Data.Generics
12:54:32 <lambdabot> Distribution.Extension Generics :: Extension
12:54:32 <lambdabot> Language.Haskell.Extension Generics :: Extension
12:55:10 <roconnor> @free (b -> b) -> a -> a
12:55:10 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
12:55:21 <roconnor> @free (foo::(b -> b) -> a -> a)
12:55:21 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
12:55:44 <Badger> Haskell++? :P
12:56:16 <PeakerWork> @free foo :: (b->b)->a->a
12:56:16 <lambdabot> f . h = k . f => g . foo h = foo k . g
12:56:31 <trofi> @help free
12:56:32 <lambdabot> free <ident>. Generate theorems for free
12:57:34 <PeakerWork> @free foo :: a -> b -> Either a b
12:57:34 <lambdabot> $map_Either f g . foo x = foo (f x) . g
12:58:05 <vininim> wat
12:58:26 <PeakerWork> bimap f g (foo x z) = foo (f x) (g z)
12:58:49 <ddarius> @free f :: (a,b) -> Either a b
12:58:49 <lambdabot> $map_Either g h . f = f . $map_Pair g h
13:00:58 <emfa> anyone got time to help me with a simple ui problem in wxhaskell?
13:13:51 <olivierp> hi, using Data.HList, does someone know how to declare a type class constraint on the elements of an HList?
13:26:03 <eu-prleu-peupeu> :)
13:28:12 <sjanssen> olivierp: class AllMyClass c; instance (MyClass x, AllMyClass xs) => AllMyClass (HCons x xs); instance AllMyClass HNil
13:28:41 <PeakerWork> is Scala pure?
13:28:56 <lament> how can it be
13:29:05 <PeakerWork> I don't know - I don't know anything about Scala
13:29:08 <olivierp> sjanssen: hmm thanks that looks fine
13:29:11 <rovar> no
13:29:17 <lament> me neither, i just know that it works with JVM's things
13:29:20 <lament> and interops with Java
13:29:29 <rovar> scala is basically an imperative language with some useful functional semantics
13:30:03 <rovar> i think there is at least one case where scala outperforms java in the shootout :)
13:30:06 <augustss> PeakerWork: no, scala is not pure
13:30:27 <PeakerWork> lament: it could have monads to interop with Java
13:30:38 <olivierp> sjanssen: does it still work with class (HList l) => AllMyClass l ?
13:30:44 <lament> PeakerWork: heh.
13:31:30 <rovar> calcUsingJVM :: a -> a -> JavaIO a
13:31:58 <sjanssen> olivierp: yes, it should\
13:32:15 <ambient> wasn't scala a macro language, as in it writes java and then compiles that?
13:32:19 <ambient> it's not straight jvm
13:32:34 <olivierp> sjanssen: ok. also, do you know why there's hFoldr but no hFoldl ?
13:32:39 <rovar> i'm pretty sure it compiles straight to bytecode
13:32:42 <ImInYourMonad> are ASTs generally BSTs or just B-trees?
13:32:48 <rovar> it probably started out as a macro lang
13:32:57 <sjanssen> ambient: if that is true, that wouldn't make it necessarily a macro language
13:33:20 <sjanssen> ImInYourMonad: neither, they're usually a tree customized for the particular syntax
13:33:23 <PeakerWork> I think AST is a bad term... We should be talking about ASG's, AST's are merely one step towards encoding them textually
13:33:54 <PeakerWork> (The abstract syntax is really a graph, not a tree)
13:34:40 <ImInYourMonad> sjanseen: so they could be morelike: data AST = Cond AST AST | Expr AST | Stat AST etc where each node could have very different number of children?
13:34:51 <sjanssen> ImInYourMonad: yes
13:35:18 <rovar> since we're near the subject, does anyone know where I could find more information about shared term graphs?
13:35:46 <Botje> ImInYourMonad: they're not always binary :)
13:36:00 <wli> Well, the tree structure is artifically imposed by syntax. The graph cycles and crowns and so on are simulated with bound variable reuse.
13:52:03 <ImInYourMonad> botje: thats whta i mean, they could have 3,4,5 chidlren in some nodes and some other nodes just 2
13:52:04 <BONUS> hey whats the shortest way to check if an integer is a power of 2
13:52:15 <ImInYourMonad> areyoupowerof2 kthnx
13:52:32 <Botje> BONUS: there's a bit twiddling trick
13:52:39 <BONUS> ooh, do tell
13:52:52 <Botje> foo & (foo - 1) == 0
13:53:09 <BONUS> > let foo = 128 in foo & (foo - 1) == 0
13:53:10 <lambdabot>   Not in scope: `&'
13:53:21 <Botje> .&. maybe?
13:53:26 <Botje> haven't twiddled bits in haskell yet :)
13:54:03 <Botje> ImInYourMonad: Have a look at uniplate or SYB if you're thinking of doing AST manipulation
13:54:13 <Botje> writing it all by hand is annoying :)
13:56:16 <BONUS> ah yeah its .&.
13:56:44 <Botje> @instances Bits
13:56:45 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
13:57:03 <Botje> heh
13:57:06 <Botje> Integer implements Bits too
13:57:20 <Botje> i'm guessing it's horribly slow though
13:59:53 <skorpan> where do i download hasktags?
13:59:58 <skorpan> i found some binary but i'm afraid it's old
14:00:31 <skorpan> oh, i already have it...
14:00:32 <skorpan> that's nice.
14:00:44 <trofi> it's distributed with ghc
14:02:38 <skorpan> christ hasktags used a lot of memory
14:02:48 <skorpan> 650 megs
14:05:34 <vixey> why is it a graph rather than a tree?
14:06:23 <ImInYourMonad> is 1 a power of 3?
14:06:55 <vixey> @keal 1 a power of 3?
14:06:55 <lambdabot> doctor just give meds not fix prollem
14:06:57 <wli> vixey: The tree has lower nodes tied together by variable binding.
14:07:31 <wli> Start by representing the tree as a graph.
14:08:27 <bremner> ImInYourMonad: 1 is a power of everything, except maybe 0
14:08:55 <wli> The RHS of a let-bound variable's definition is itself a node, so any time you see the let-bound variable as a graph node, redirect whatever has edges to the variable expression node directly to the RHS of the variable's definition.
14:09:09 <edwardk> heya wli
14:09:16 <wli> Including the RHS of the variable itself.
14:09:30 <wli> re edwardk
14:09:43 <edwardk> wli: http://comonad.com/haskell/lexical-monoids/dist/doc/html/lexical-monoids/ -- might put my earlier ramblings into context
14:09:50 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2767#a2767 <- is that function correct? what would be a good way to quickCheck a powerOf function?
14:09:57 <bremner> > 123456789 ** 0
14:09:59 <lambdabot>   1.0
14:10:06 <edwardk> i still need to add some better haddock to it, but its starting to make sense
14:10:37 <PeakerWork> > 0^0
14:10:39 <lambdabot>   1
14:10:41 <PeakerWork> > 0**0
14:10:42 <lambdabot>   1.0
14:10:47 <wli> Cool, checking it out.
14:10:55 <Axman6> 0^^0
14:10:58 <Axman6> > 0^^0
14:11:00 <lambdabot>   1.0
14:12:01 <wli> edwardk: I've got the new AST from parsing/etc. hash consed with let expressions eliminated.
14:12:41 <wli> edwardk: My all-singing, all-dancing case expressions were an SOB, though.
14:12:42 <vixey> I don't get that
14:13:22 <edwardk> wli: so with that you can say wordsFrom (point "someFile") "Hello World" :: [(SourcePosition String,String,())]  and it'll generate [(Pos "someFile" 1 1,"Hello",()),Pos "someFIle" 1 6,"World",())]
14:13:54 <wli> vixey: hash consing is like having a let expr and a var for every compound subexpression.
14:14:11 <edwardk> and if "Hello World" was instead a lazy bytestring it would automatically partition it into strict bytestring sized chunks and reduce in parallel
14:15:31 <edwardk> wli: nice
14:15:47 <edwardk> wli: one of these days i'll have to do the same thing for own toy
14:16:03 <wli> I'm nowhere near getting started on my own ideas wrt. parsing.
14:16:14 <wli> edwardk: The code is ugly, though. http://wli.pastebin.com/m118aac05
14:16:18 <kmeyer> :t fmap
14:16:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:16:35 <kmeyer> @search (Monad m) => (a -> b) -> m a -> m b
14:16:35 <lambdabot> Unknown command, try @list
14:16:43 <kmeyer> @hoogle (Monad m) => (a -> b) -> m a -> m b
14:16:44 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:16:44 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:16:44 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
14:16:47 <edwardk> yeah, it looks like LaTeX, oh wait, it is LaTeX ;)
14:17:50 <wli> There are a couple of lines that need to be broken up but otherwise a lot of layout's been done to get it to look right after lhs2TeX.
14:17:58 <gnut> how do I use function composition notation to say "f a b c = g $ h a b c" ?
14:18:23 <edwardk> the other thing i started to play with today was a categorical fingertree. it should be able to work just like an indexed monad.
14:18:41 <edwardk> you just need two categories and a forgetful functor between them
14:19:15 <wli> I've got an SCC DAG and some biconnected components to form on this graph.
14:19:52 <skorpan> i have a simple folding question... i have a list of <whatever> which i want to "run a function on" and then mappend them together so to speak.  i tried this, which didn't work:  myFun f xs = foldr (\el rest -> f el `mappend` rest) mempty xs
14:19:52 <wli> Though I do need some way to know that primops are happening.
14:19:56 <skorpan> any ideas?
14:20:50 <edwardk> skorpan strangely i just wrote that code myself ;)
14:21:01 <edwardk> skorpan look in http://comonad.com/haskell/lexical-monoids/dist/doc/html/lexical-monoids/src/Data-Monoid-Generator.html at the [c] instance i'm using
14:21:10 <skorpan> thanks, i'll take a look
14:21:40 <edwardk> er though i guess if you just want to run a function on it. foldMap should do the trick
14:21:41 <skorpan> so you're using foldMap (reduce . f)... what does that mean?
14:21:50 <edwardk> @type foldMap
14:21:52 <lambdabot> Not in scope: `foldMap'
14:21:59 <edwardk> @type Data.Foldable.foldMap
14:22:01 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
14:22:20 <wli> edwardk: When I eventually get around to parsing, I'll have to figure out how to arrange grammar construction combinators vs. parsing combinators per se.
14:22:21 <edwardk> in my setting reduce converts from a value to the monoid, so its an additional step
14:22:47 <skorpan> so basically, i'd have myFun f xs = foldMap f xs?  or even myFun = foldMap?
14:22:59 <edwardk> myFun = foldMap
14:23:08 <skorpan> cool, thanks
14:23:16 <vixey> edwardk is this free monoids?
14:23:37 <edwardk> for foldMap or my stuff?
14:23:49 <vixey> lexical monoids
14:24:25 <edwardk> vixey: not all free, and perhaps generator could use a better term, but generator/reducer seem to be the industry terms for things that have values and things that know how to tear them down
14:26:26 <edwardk> vixey: right now the basic idea is that i have a bunch of container that know how to split themselves up, and a bunch of monoids that can do interesting things over them for lexing purposes.
14:27:51 <edwardk> so then i can take a fingertree of (ByteString `WithReducer` UTF8 (something complicated)) and get tokens with file position, etc in parallel
14:28:01 <edwardk> and have cheap updates when part of the fingertree is replaced
14:29:01 <mattam> edwardk: looks nice
14:29:25 <edwardk> one of the next things i want to do is see if i can generate a simple regex monoid, so i can get the SourcePosition stuff to support #line directives easily
14:29:44 <edwardk> and go from there for keyword recognition, etc.
14:30:04 <edwardk> i have some fragments of a parallel haskell layout engine as well
14:30:22 <edwardk> heya mattam, you finally out in boston yet?
14:31:27 <mattam> edwardk: yep! I'm going back to France tomorrow though :)
14:31:31 <edwardk> doh
14:31:32 <mattam> Just for a week.
14:37:23 <wli> My parsing plot is grammar construction combinators vs. parser combinators, then build LR(0) (for interactive) or (unambigously compacted) LR(1) state transition and action tables from the grammar, then use Tomita or other nondeterminism to grind through the parse.
14:39:12 <skorpan> so i still can't figure out this foldMap stuff... i have posted my problem here: http://pastebin.com/d194e258d
14:39:22 <skorpan> could someone try to explain what the definition of "few" should be?
14:39:37 <skorpan> i think it's the Endo that's messing me up
14:40:10 <skorpan> hm, actually i just noticed an error in that question...
14:40:16 <edwardk> skorpan: foldMap (one . tokenToStroke)
14:40:36 <skorpan> http://pastebin.com/d4a46ddc
14:42:11 <skorpan> edwardk: seems to work...!  now all i have to do is to figure out HOW.
14:42:40 <mofmog> > LT 'mappend' EQ
14:42:41 <lambdabot>   <no location info>:
14:42:41 <lambdabot>      lexical error in string/character literal at chara...
14:42:41 <lambdabot> mofmog: You have 1 new message. '/msg lambdabot @messages' to read it.
14:43:04 <wli> When the smoke clears, you should be able to feed the interactive one 1 char at a time and stop and restart it at will, and inspect the state for the stack(s) of nonterminals in the process of derivation, unparse focused around some string of terminals from the original input and reparse when done, etc.
14:43:13 <edwardk> foldMap takes a function that reduces elements to a monoid, and then takes it upon itself to figure out the order it wants to apply the monoid over the data structure
14:43:56 <wli> I have doubts I'll get anywhere, though.
14:44:50 <mofmog> > LT `mappend` EQ
14:44:52 <lambdabot>   LT
14:45:10 <mofmog> Why do the haskell docs not tell me how mappend for Orderings are defined -__
14:45:28 <edwardk> mofmog probably because haddock has no way to provide documentation about an instance =/
14:45:46 <mofmog> it should at least tell me what they do -_-
14:46:18 <mofmog> as far as i can tell, mappend LT _ = LT, mappend GT _ = GT, mappend EQ EQ = EQ mappend EQ x = x ?
14:47:01 <int-e> mofmog: yes. so (a,b) `compare` (c,d) = compare a c `mappend` compare b d
14:47:05 <jedai> mofmog: It's lexical ordering
14:47:26 <edwardk> @hpaste
14:47:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:47:40 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2768#a2768
14:47:41 <wli> edwardk: The nasty thing about parsing is I want/need it for so many other things ahead of it in my queue of things to implement.
14:47:44 <jedai> mofmog: Well it's intended to be used with it
14:48:20 <mofmog> so it means that the first element of a tuple is more significant than the second?
14:48:27 <mofmog> or at least, that's what they want?
14:48:28 <int-e> mofmog: yep
14:48:37 <jedai> mofmog: That's what lexical ordering do yes
14:48:39 <int-e> mofmog: the first element decides, the second is a tie-breaker.
14:48:53 <edwardk> so i guess the monoid instance for Ordering is the one that returns the left most non-EQ value or EQ if none is present
14:49:29 <jedai> > mconcat [EQ,EQ, LT, GT, EQ]
14:49:31 <edwardk> that way if you map it over a list, you can mappend them and it will give you a lexicographical ordering
14:49:31 <lambdabot>   LT
14:50:05 <Heffalump> so that compare == mconcat . zipWith compare
14:50:36 <int-e> Heffalump: almost. you get into trouble with lists of differing lengths
14:50:45 <mofmog> > compare "awd" "bdd"
14:50:46 <Heffalump> oh yeah, shame
14:50:46 <lambdabot>   LT
14:51:01 <mofmog> > compare "aa" "ab"
14:51:02 <lambdabot>   LT
14:51:58 <mofmog> hmm, i wouldve never thought to make Ordering a monoid
14:52:16 <mofmog> but then again, it's no different than an integers monoid?
14:52:26 <int-e> compare xs == mconcat (zipWith compare xs) `mappend` (length xs `compare` length ys) ?
14:52:44 <jedai> With the proper instance of Monoid for functions, you an use it in sortBy :
14:52:46 <int-e> oh. add an ys as appropriate.
14:52:47 <vininim> > compare 1 2
14:52:49 <lambdabot>   LT
14:53:23 <jedai> sortBy (compareStuff `mappend` compareThing)
14:53:33 <int-e> > [1..] `compare` [1,2,3]
14:53:35 <lambdabot>   GT
14:53:53 <vininim> > [1..
14:53:54 <lambdabot>   <no location info>: parse error on input `;'
14:54:08 <vininim> > compare [1..] [1..]
14:54:23 <lambdabot>   thread killed
14:55:24 <mofmog> > EQ == mempty
14:55:26 <lambdabot>   True
14:55:54 <mofmog> yah, ok it all makes sense now and now it just seems obvious that Orderings should be a monoid
14:57:48 <vininim> > compare x y
14:57:50 <lambdabot>   LT
14:58:01 <vininim> o_O
14:58:10 <Valodim> > x
14:58:11 <lambdabot>   x
14:58:20 <LeoD> > y
14:58:22 <lambdabot>   y
14:58:28 <Valodim> huh
14:58:29 <LeoD> > abcdef
14:58:30 <int-e> > x^13
14:58:30 <jedai> vininim: It's because x = Var "x" and y = Var "y"
14:58:30 <lambdabot>   Not in scope: `abcdef'
14:58:32 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * x)
14:58:50 <jedai> vininim: since lambdabot use Debug.SimpleReflect
14:58:52 <LeoD> @type x
14:58:54 <lambdabot> Expr
14:59:02 <int-e> > x^4 == x*x*x*x
14:59:03 <Valodim> ah
14:59:03 <lambdabot>   False
14:59:06 <gwern> > 73000000 * 100
14:59:07 <lambdabot>   7300000000
14:59:09 <int-e> (evil :) )
14:59:22 <vininim> jedai: I know, but it doesn't make much sense to say that x < y
14:59:48 <jedai> vininim: It's just that "x" < "y"
15:00:31 <wli> Emit code to compute x^n for a given n with the fewest multiplications possible. ;)
15:00:53 <jedai> vininim: SimpleReflect produce some artefact like that but overall it's worth it since we can use lambdabot to demonstrate some simple computations
15:01:09 <int-e> > realToFrac x
15:01:11 <lambdabot>   * Exception: not a number
15:01:34 <wli> That is, for an n provided as input. optExpr :: Int -> Expr
15:02:49 <jedai> wli: Given that Expr don't keep sharing it's not really the right tool to do that, Debug.Traced would be more appropriate
15:07:32 <lilac> @check \xs ys -> length xs == length ys || xs `compare` xs == mconcat (zipWith compare xs ys)
15:07:34 <lambdabot>   "OK, passed 500 tests."
15:08:08 <Deewiant> lilac: xs `compare` ys or xs?
15:08:18 <jedai> @check \xs ys -> length xs /= length ys || xs `compare` ys == mconcat (zipWith compare xs ys)
15:08:20 <lambdabot>   "OK, passed 500 tests."
15:08:25 <Deewiant> :-)
15:08:43 <lilac> that's more like it P:)
15:09:25 <lilac> @hoogle [(a,b)] -> ([a],[b])
15:09:25 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:09:25 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:10:00 <Axman6> @src unzip
15:10:01 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
15:10:09 <lilac> @check \zs -> let (xs, ys) = unzip zs in xs `compare` ys == mconcat (zipWith compare xs ys)
15:10:11 <lambdabot>   "OK, passed 500 tests."
15:12:27 <jedai> @check \zs -> let (xs :: [Int] , ys) = unzip zs in xs `compare` ys == mconcat (zipWith compare xs ys)
15:12:27 <lambdabot>   Parse error in pattern at "in" (column 42)
15:13:36 <jedai> @check \zs -> let xs :: [Int]; (xs, ys) = unzip zs in xs `compare` ys == mconcat (zipWith compare xs ys)
15:13:38 <lambdabot>   "OK, passed 500 tests."
15:13:57 <jedai> What's the default ? Int or () ?
15:14:39 <jedai> @check \zs -> let (xs, ys) = unzip zs in length xs < 2
15:14:41 <lambdabot>   "Falsifiable, after 0 tests:\n[((),()),((),())]\n"
15:15:31 <jedai> Ok, () is the default, Int is more interesting most of the time though
15:18:05 <lilac> @check \zs -> let (xs, ys :: [Double]) = unzip zs in xs `compare` ys == mconcat (zipWith compare xs ys)
15:18:05 <lambdabot>   Parse error in pattern at "in" (column 44)
15:22:15 <mofmog> is there such thing as a comonoid?
15:22:27 <wli> edwardk: Anyway, my solution for let floating is to nuke let exprs entirely, a let-bound var's usages get replaced with the index of the defining subexpression (a pointer to the RHS of the let), and the variable name gets dumped in a table of temporary ID's to user-defined variable names (IntMap String). Now I need def/use arcs.
15:22:35 <lilac> > filter (join (==)) . sort . intercalate [(0/0)] $ map return [1,5,2,7,9,4,7,2,0]
15:22:37 <lambdabot>   [0.0,2.0,7.0,4.0,9.0,7.0,2.0,5.0,1.0]
15:22:39 <ImInYourMonad> Debasish Ghosh here?
15:22:56 <ImInYourMonad> http://twitter.com/debasishg/statuses/1371109266 <- where is that? god im jealous i want to lvie there
15:23:55 <wli> edwardk: I get weird forms of temporary definition from case exprs and lambda exprs.
15:24:02 <lilac> mofmog: a comonoid would have 'comempty :: Comonoid m => m -> (); comappend :: Comonoid m => m -> (m, m)' with coassociativity. i'm not sure what that would mean :)
15:24:21 <BMeph> jedai: Nice one - "putting the 'Int' back into 'interesting'." ;)
15:24:34 <kpreid> dons: http://hackage.haskell.org/trac/summer-of-code/ticket/1542 has a broken link
15:24:42 <Saizan> i've seen something like that in a sigfpe post
15:25:35 <ddarius> first comappend . comappend ~ second comappend . comappend
15:26:05 <ddarius> It's better to use a monoidal structure rather than a cartesian structure for comonoids.
15:26:11 <ddarius> (and even for monoids)
15:26:12 <wli> edwardk: Case being more straightforward than lambda; for case, the pattern vars (for lack of a better term) are what get defined, and they have a reasonable notion of having a value. For lambdas, the lambda-bound var is what gets defined and that's much weirder.
15:26:54 <lilac> first comempty . comappend ~ id ?
15:27:47 <ddarius> Yep.
15:28:06 <lilac> implying that comappend = id (at least in Hask)
15:28:49 <lilac> or rather comappend = join (,)
15:28:58 <ddarius> lilac: That is what it is for the cartesian structure.
15:32:01 <wli> edwardk: Essentially lambda-bound temporaries fail to depend on any data whatsoever, and so end up in a sort of nasty place in the graph. It's rather tempting to try to get rid of lambda subexpressions in every way possible.
15:33:02 <ImInYourMonad> is stuff like map (+1) ,filter (== True); currying or syntax?
15:33:14 <wli> both
15:33:23 <wli> They're called sections.
15:34:41 <ImInYourMonad> what I meant was is it jus tpartialapplication or it has to be done in the compiler with parsing?
15:34:53 <wli> both
15:35:04 <kpreid> (1+) is partial application but (+1) needs an extra function
15:35:08 <c_wraith> it's special syntax for partial application with infix operators. :)
15:36:37 <ImInYourMonad> p_l: http://news.ycombinator.com/item?id=527386 <- what do you think about those AI comments then?
15:38:31 <p_l> "My AI professors used to tell semi-jokingly that whenever we get computers to solve some task we thought required intelligence (thus we produced AI), the "intelligence" part of the AI gets redefined to exclude this particular solved topic (e.g. chess). We humans need to feel we are special." <--- single most important one, I guess
15:39:51 <wli> edwardk: I think it comes down to eta reduction and beta reducing fully saturated lambda expressions only used once.
15:41:53 <p_l> ImInYourMonad: The stance about humans redefining intelligence is now even less of a joke
15:42:30 <p_l> Basically, AI we have already done. It's AGI that is "blue sky"
15:42:46 <Saizan> G? General?
15:42:52 <p_l> yeah
15:43:02 <p_l> aka "oh gawd we made Skynet" ;-)
15:43:16 <kerlo> What's the AI that we have done?
15:43:17 <Badger> heh
15:43:52 <edwardk> wli: back, rereading what you just said for the last 20 minutes ;)
15:44:46 <p_l> kerlo: autonomic vehicles, data analysis, search, expert systems... there's a lot. It's just that we redefine intelligence to suit humans as the only sentient species :P
15:45:45 <mofmog> is there a reason haskell doesn't have variadic functions?
15:46:01 <Zao> Writing the type signature for one would be hard.
15:46:03 <vixey> mofmog; it does
15:46:04 <jeffwheeler> Should I be looking in Cabal's API to find the location of a package's executable (so I can find the mod-time)?
15:46:21 <mofmog> hrm, i just hate reading docs that have stuff like liftM10000
15:46:24 <edwardk> wli: it sounds good so far
15:46:30 <wli> mofmog: Witness Text.Printf
15:46:33 <mofmog> a->b->c->d->e->f->g
15:46:35 <p_l> kerlo: it's the "general" part that we are missing... and as Eliezer said in linked content, you need guts of STEEL to go there
15:46:45 <jeffwheeler> The closest I can find there is Distribution.PackageDescription, but I can't seem to generate a PackageDescription with just the string of the package name.
15:46:49 <Saizan> jeffwheeler: it won't help very much, Cabal doesn't keep an index of what's installed
15:47:20 <jeffwheeler> Saizan: ah, hmm; so is there a GHC API I should be looking at?
15:47:42 <kerlo> Hey, now. My friend's dog is sentient.
15:47:43 <jeffwheeler> I suppose I _could_ just assume it's installed in ~/.cabal/bin/, but that seems odd.
15:47:47 <Saizan> jeffwheeler: ghc-api only stores informations about libraries, executables are essentially untracked
15:47:56 <ddarius> kerlo: Is your friend?
15:48:13 <Saizan> jeffwheeler: for things like happy/alex/etc.. Cabal just looks into $PATH directories
15:48:15 <jeffwheeler> So, I guess I should go with checking ~/.cabal/bin/? Can users change that location?
15:48:17 <wli> edwardk: The lambda-bound vars are evil because they're invisible to forward dataflow.
15:48:19 <kerlo> ddarius: I don't believe that is a complete sentence.
15:48:27 <kerlo> Oh, yes it is.
15:48:28 <p_l> kerlo: Humans fail turing tests all the time...
15:48:33 <kerlo> Yes, he's sentient.
15:48:47 <Saizan> jeffwheeler: yes, they can use --prefix to change it anytime
15:49:04 <jeffwheeler> Saizan: hmm, but there's no good way to catch that?
15:49:06 <kerlo> I would be happy to see a chatbot that could pass a Turing test with me as judge.
15:49:26 <ddarius> @vixen do you think kerlo could tell you're a bot?
15:49:27 <lambdabot> no, how dare you ask if i'm a bot!
15:49:35 <mofmog> wli: CHEATING
15:49:40 <edwardk> wli: the other view is that they are the only thing you deal with in which case everything else is evil ;)
15:49:42 <Saizan> jeffwheeler: well, if you're writing code for a Setup.hs script the final install location should available from LocalBuildInfo
15:49:58 <Saizan> s/should/should be/
15:50:05 <mofmog> hrm, i guess a variadic function would be uncessary, just pass in a list
15:50:32 <jeffwheeler> Saizan: unfortunately not; I'm writing code for HConf in Yi to recompile if the ~/.cabal/bin/ binary is more recent than the ~/.yi/yi-*-* binary.
15:51:03 <p_l> kerlo: the problems is that with trolls, I had actual situation where we couldn't decide whether the nick was representing a markov bot, a misguided human or a troll
15:51:05 <wli> edwardk: I guess you have to find them all and treat them as roots in forward dataflow along with atomic subexpressions.
15:51:24 <gwern> jeffwheeler: oh, that'd be nice, as long as you're not hardwiring .cabal/bin
15:51:40 <Saizan> jeffwheeler: is it supposed to be run from the ~/.cabal/bin/ binary?
15:51:42 <jeffwheeler> gwern: that's what I'm trying to avoid, but it doesn't seem like we've got much choice
15:51:44 <gwern> it's annoying to have to always do --recompile-force after reinstalling. I sometimes forget
15:52:14 <gwern> jeffwheeler: perhaps you could get the data-file path and go up a directory or two?
15:52:25 <jeffwheeler> Saizan: ~/.cabal/bin/ is always the one that's run, but it starts the ~/.yi/yi-arch-os binary, recompiling if necessary.
15:52:27 <gwern> jeffwheeler: I say that because my yi binary would be in ~/bin/bin
15:52:58 <jeffwheeler> gwern: do you use --prefix?
15:53:02 <gwern> yes
15:53:05 <Saizan> jeffwheeler: well, the code could ask for the location of the current binary then
15:53:10 <gwern> hm, looks like you can install the binary to somewhere else, overriding a --prefix
15:53:32 <jeffwheeler> Saizan: oh, indeed. It seems like that would definitely work.
15:53:33 <ialpert> noob question: I've got a function that does a  myFunction x y z size = myFunction (myfun2 x y z) (size -1) until size = 0 . I want to use Controll.Parellel par and parseq to parallelize it ... when i change it to : myFunction x y z size = myFunction `par` (myfun2 `pseq` x y z) (size -1) it complains i'm not passing expected types ... any idea what i'm missing?
15:54:28 <Saizan> jeffwheeler: or use Paths_yi.bindir, assuming the user won't move the binary
15:54:33 <ddarius> ialpert: That parses as myfun2 `pseq` (x y z)
15:54:39 <ialpert> from the examples http://www.haskell.org/ghc/docs/6.6/html/users_guide/lang-parallel.html it seems like i'm doing the same thing\
15:54:55 <gwern> jeffwheeler: but wouldn't asking for current binary path fail? I understand you can't really do that on windows, and besides, if bin/bin/yi immediately loads ~/.yi/yi-executable, you'd get the .yi path
15:55:14 <jeffwheeler> Hmm, what's this Paths_yi thing? I'll look at that.
15:55:24 <jeffwheeler> I've seen that before, but don't know what it is.
15:55:26 <ialpert> hmm so affirst i thought par myFunction (pseq myFun2...)
15:55:39 <gwern> jeffwheeler: cabal generates a small module containing metadata about the installation
15:55:42 <Saizan> jeffwheeler: it's a module that Cabal autogenerates with informations from the configure step
15:55:48 <ddarius> Also these annotations don't make much (any) sense.
15:55:56 <Saizan> jeffwheeler: under dist/build/autogen
15:56:00 <jeffwheeler> Oh, nifty.
15:58:12 <ialpert> ddarius any suggestions how would i annotate it properly ?
15:59:36 <ddarius> ialpert: I don't think there is much to parallelize there.
15:59:49 <jedai> "myFunction x y z size = myFunction (myfun2 x y z) (size -1)" <--- This already has a typing problem : apparently myFunction hasn't the same type on the LHS and the RHS
15:59:54 <ialpert> ddarius even presuming myFun2 is heavy?
16:00:19 <ddarius> ialpert: You might want to give your actual code.
16:00:19 <ialpert> oh crappy example jedai
16:00:22 <ialpert> sorry
16:00:32 <ialpert> myFunction x y z size = myFunction (myfun2 x y z) y z (size -1)
16:00:58 <jedai> Ok, so basically y and z stay the same
16:01:20 <ialpert> jedai yeah
16:01:29 <ialpert> ddarius: runGenerations :: [Keyboard] -> FitnessAlgorithm -> StdGen -> Int -> [Keyboard]
16:01:29 <ialpert> runGenerations ks fa gen 0 = ks
16:01:29 <ialpert> runGenerations ks fa gen size =  runGenerations (kGen ks fa gen) fa gen (size - 1)
16:01:29 <ialpert>                                    where kGen = runGeneration
16:01:48 <jedai> the problem is apparently myfun2 needs x value before it can start its computation so you can't parallelize anything, it's tipically sequential
16:02:27 <jeffwheeler> Saizan, gwern: Using getBinDir in Paths_yi was the perfect solution; thanks!
16:02:28 <ialpert> guess i'll have to do it at another level
16:03:05 <monochrom> Perhaps if size is 5 you want to spawn 5 threads for 5 instances of «myfun2 x y z». To do that you write «let p = myfun2 x y z in p `par` myFunction p y z (size -1)»
16:03:42 <jedai> you can eventually rewrite it though : runGenerations ks fa gen size = (!! size) . iterate (\x -> runGeneration x fa gen) $ ks
16:04:01 <jedai> ialpert: it might gain you something
16:04:09 <jedai> ialpert: but no parallelism
16:04:13 <ialpert> monochrom: i think  jedai is right i need a generation to be done before i can do the next
16:04:34 <monochrom> True.
16:04:44 <ialpert> guess i was hopeing magic would occure
16:04:57 <ialpert> and it would find where it could be optimized
16:05:05 <ImInYourMonad> p_l: well GAI was called AI before...
16:05:16 <ialpert> "just search for a free core when you have something that can be done"
16:05:50 <p_l> ialpert: it's also a subset of AI
16:05:52 <jeffwheeler> gwern: pushed
16:06:31 <ialpert> p_I: GA's?
16:06:47 <p_l> ialpert: AGI
16:06:58 <p_l> Artificial *General* Intelligence
16:07:13 <p_l> formerly known as "Strong AI"
16:07:27 <ialpert> heh this for me is just a way of learning
16:07:45 <Pseudonym> That's the problem with AI.  The nomenclature keeps changing.
16:08:05 <ialpert> always liked GA solutions so decided to try that
16:08:19 <Pseudonym> I call it "electronic brain".  If it was good enough for the 1950s, it's good enough for me.
16:08:28 <gwern> jeffwheeler: looks right to me.
16:08:41 <gwern> Pseudonym: but what if we start running on rod logic or dna or quantum computers?
16:08:43 <jeffwheeler> I'm excited; I've wanted this for ages.
16:08:48 <gwern> WHERE'S YOUR GOD NOW
16:09:04 <Gracenotes> @vixen where's your god now?
16:09:05 <lambdabot> Jesus H. Christ...
16:09:05 <gwern> jeffwheeler: I always hate it when something I've wanted for ages turns out to be simple to do. regrets.
16:09:20 <jeffwheeler> Haha, yeah.
16:09:58 <gwern> I can't test it right now because derive is broken under 6.11
16:10:19 <p_l> Pseudonym: *electron* brain ;_)
16:10:24 <p_l> *;-)
16:11:03 <p_l> Pseudonym: also, part of the reason for changing nomenclature is the stigma associated with the word "AI" outside of games
16:11:46 <Pseudonym> That's a very recent phenomenon.
16:12:01 <gwern> ai winters aren't
16:12:02 <Pseudonym> It's also not a stigma.  If anything, it's a misconception.
16:12:11 <Pseudonym> There are students wanting to study AI thinking that it's games.
16:12:22 <Pseudonym> And when they find out what AI actually is, they're lost.
16:12:35 <olivierp> has anyone had problems with casts (using Data.Dynamic) in multithreaded code? I suspect that's what's causing a race condition in my code
16:12:42 <p_l> Pseudonym: Well, I had chosen AI because I wanted my studies to actually challenge me a little :P
16:13:07 <gwern> p_l: you didn't go into ai to build a better ai student?
16:13:10 <Pseudonym> Game development seems to be the new dot com bubble, as far as computer science education goes.
16:15:16 <p_l> Pseudonym: I was actually told we are going to use a gamedev oriented book at some point in AI curriculum. And I have to say, that books was great (read it before)
16:15:34 <defun> :t (<*>)
16:15:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:16:03 <ddarius> p_l: Which book?
16:16:12 <Pseudonym> We do a bit of machine learning stuff here, and people who think AI = games are useless to us.
16:17:58 <p_l> ddarius: "Artificial Intelligence for Games" by Ian Millington
16:18:11 <p_l> ddarius: quite good way of explaining real-time AI
16:18:25 <ImInYourMonad> fookin AIs stealin my girl
16:18:43 <ImInYourMonad> japanese robotics will soon produce a robot-mistress I think
16:21:13 <bremner> which will also be stolen by AIs
16:22:09 <lowmagnet> game 'ai' is pretty funny
16:22:34 <ambient> I'll be probably dead and buried before the humanity sees first strong AI
16:22:56 <Gracenotes> > fix $ (0:) . (1:) . (=<< [1..]) . ((<*>) . ((return .) . (+) <$>) <*> (. subtract 1)) . (!!)
16:22:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:23:03 <p_l> my computing soc. president was once called one of those "japanese female androids" :D
16:23:07 <Pseudonym> ambient: It's perfectly possible in principle.  All we need is a duplicate M-class planet and about four billion years of time.
16:23:50 <p_l> I suspect singularity happening first without AGI :)
16:24:36 <ImInYourMonad> singularity lolzor
16:26:21 * p_l is thinking of going more in direction of merge AIs than direct AGI stuff, but that's just his personal bias ;-)
16:26:40 <ImInYourMonad> http://podularraludop.appspot.com/ <- i collected osme machine learning, AI, reprap prodcasts on ymy site btw
16:27:40 <ImInYourMonad> podcasts
16:28:05 <b\6> yeah, prodcasts are about stuff to get cattle to go where you want.
16:28:37 <ambient> hehe
16:33:18 <b\6> i made a class. is it pretty bogus if the types for which i implement that class are empty datas? the class is about source code types, so i do stuff like data C = C; instance SourceCodeType C where ...
16:33:46 <ddarius> b\6: That's not an empty data type.
16:34:17 <b\6> well, seems like the most trivial thing i can make so i can create an instance.
16:35:32 <Saizan> b\6: you can use data C; with EmptyDataDecls
16:35:49 <b\6> Saizan: ah, ok. thanks.
16:36:12 <b\6> is it fairly normal to do stuff like that? it felt a little wrong.
16:37:09 <ialpert> will runghc take threaded options?
16:37:20 <Saizan> using types with no representation to add static guarantees is quite standard these days
16:37:56 <b\6> Saizan: thank you.
16:42:47 <elliottt> anyone have any favorite papers for implementing typeclasses?
16:43:02 <elliottt> (dictionary translation, in particular)
16:43:03 <ddarius> As far as I know, there's only really one or a few.
16:43:27 <elliottt> "Type Classes in Haskell"?
16:44:34 <Pseudonym> elliottt: You know about System F?
16:44:40 <elliottt> Pseudonym: yes
16:44:48 <ddarius> http://haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
16:44:58 <Pseudonym> The basic idea is that typeclass dictionary passing is big-lambdas.
16:45:11 <Pseudonym> At least if that's the technique you're using.
16:45:19 <Pseudonym> (Which GHC does do; Hugs doesn't.)
16:45:28 <elliottt> what does hugs do?
16:45:48 <Pseudonym> It uses a simpler translation.  There's a Mark Jones paper on it.
16:45:56 <elliottt> oh, perfect
16:45:58 * Pseudonym looks it up
16:46:09 <ddarius> http://www.cse.ogi.edu/~mpj/pubs/fpca93.html
16:46:14 <ddarius> That one?  or the other one?
16:46:26 <Pseudonym> I thin kthat's it.
16:46:31 <ddarius> Well, crap bad link.
16:46:48 <pejo> elliottt, Wadler & Blott is very readable.
16:46:51 <Pseudonym> ?go "implementing haskell type classes" mark jones
16:46:54 <lambdabot> http://portal.acm.org/citation.cfm?id=155112
16:46:54 <lambdabot> Title: Implementing type classes
16:47:52 <Pseudonym> Oh, another ione.
16:47:58 <Pseudonym> ?go "derivable type classes" mark jones
16:48:00 <lambdabot> http://citeseer.ist.psu.edu/57854.html
16:48:02 <Pseudonym> That one might be better.
16:48:15 <ddarius> Isn't that something else altogether?
16:48:24 <elliottt> http://web.cecs.pdx.edu/~mpj/pubs/pldi93.html
16:48:30 <elliottt> Pseudonym: is that the one you're talking about?
16:48:47 <ddarius> Or maybe not
16:49:01 <ImInYourMonad> is SPJ a category theorist at heart? who is responsible for most of the design decisions? is SPJ basically the guy that made haskell what it is? what about those Wadler and the other simon guy?
16:49:06 <Pseudonym> Yeah, looks like it.
16:49:12 <OffensiveNick> SPJ is a category terrorist
16:49:13 * ddarius was trying to point at this one before: http://citeseer.ist.psu.edu/jones95system.html
16:49:15 <Pseudonym> ImInYourMonad: Oddly enough, no.
16:49:21 <Pseudonym> SPJ is actually an engineer at heart.
16:49:31 <ddarius> As far as I know, SPJ doesn't know any category theory.
16:49:37 <Pseudonym> He's got real non-academic software engineering experience under his belt.
16:49:49 <Pseudonym> Phil Wadler is the not-so-closet category theorist of the bunch.
16:49:56 <OffensiveNick> and he's gonna fail
16:50:02 <ddarius> Clearly
16:50:03 <Pseudonym> But SPJ has a soft spot for type theory.
16:52:30 <pejo> Im, have you read the haskell history paper? It's very enlightening.
16:52:44 <elliottt> ddarius: thanks for the link
16:53:43 <gnut> is there a way to convert between C Types and haskell types? like between CInt and Int? or is that considered a no-no?
16:54:18 <mauke> fromIntegral
16:54:45 <gnut> mauke: oh... yeah. I knew that :). hehe... I meant between CDouble and Double?
16:54:50 <jmcarthur> gnut: it's not a nono. it's not casting like it would be in C ;)
16:54:55 <ddarius> realFrac
16:55:02 <mauke> :t realToFrac
16:55:03 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:55:19 <gnut> ddarius: mauke: ah.. thanks. that's what I was looking for.
16:55:33 <jmcarthur> @hoogle CDouble -> Double
16:55:34 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
16:55:34 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:55:34 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
16:55:46 <ddarius> gnut: realToFrac is the generic conversion function between fractional values like fromIntegral is for integral values.
16:55:57 <jmcarthur> don't use unsafeCoerce of course :)
16:56:16 <ddarius> It'd probably work.
16:56:21 <jmcarthur> probably
16:56:26 <gnut> okay. thanks!
16:56:43 <ddarius> @src CDouble
16:56:44 <lambdabot> Source not found. You type like i drive.
16:57:03 <ialpert> should i expect that ghc -O2 --make will produce much faster exe's then just running with runghc?
16:57:10 <ddarius> ialpert: Yes.
16:57:13 <mauke> ialpert: yes
16:57:14 <ialpert> (i'm seeing way more then double performance)
16:57:16 <ialpert> thanks
16:58:23 <ialpert> fyi parallising that previous question i mentioned had neglagable improvement
16:58:44 <ddarius> That's to be expected.
16:58:54 <ialpert> wondering if i should change my approch
16:59:43 <ialpert> would you consider the typical f (a:as) = f2 a: (f as) function to not be parallelizable?
17:00:03 <ddarius> That's different than what you had.
17:00:11 <ialpert> would have thought you could go par f2 a, and it would continue on with the rest of the list while that first  item got parallelized
17:00:12 <ddarius> That's trivially parallizable.
17:00:40 <Saizan> with parMap or parBuffer
17:00:43 <ialpert> ddarius it complained when i tried the par (f a):...
17:00:56 <ddarius> :t par
17:00:57 <lambdabot> forall a b. a -> b -> b
17:01:10 <ddarius> ialpert: Read some documentation on par.
17:01:22 <ialpert> ddarius ok
17:01:27 <roconnor> @type (\\)
17:01:29 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:01:50 <ialpert> ddarius: mostly am trying to see big jumps without understanding
17:02:07 <roconnor> @src (\\)
17:02:07 <lambdabot> (\\) = foldl (flip delete)
17:02:35 <ddarius> ialpert: That's not going to work if you don't even know how to make type correct code.
17:02:40 <jedai> ialpert: That don't work much ^^
17:03:03 <ialpert> ddarius well i've managed that -- it is working for me
17:03:19 <ddarius> (However, you can actually get pretty far just fitting the types together in many situations.)
17:03:26 <ialpert> guess i was expecting something like par :: (a ->b) -> b
17:03:41 <ialpert> ddarius: suppose that's what i'm doing
17:05:19 <jedai> ialpert: par :: a -> b -> b
17:06:05 <jedai> ialpert: "a `par` b" evaluates a and b in parallel and return b
17:06:19 <idnar> f (a:as) = f2 a: (f as) looks like parMap
17:06:22 <ialpert> jedai: oh thanks
17:06:34 <jedai> ialpert: so the trick is that a may be a part of b
17:07:33 <jedai> if you want to evaluate both components of a pair in parallel for example you can do the following :
17:08:02 <jedai> parPair (x,y) = x `par` y `pseq` (x,y)
17:09:52 <ialpert> is it reasonable to read pseq to say finish evaluation of both before next parallelization?
17:10:05 <ddarius> That doesn't make sense.
17:10:07 <jedai> if you want to evaluate all elements of a list in parallel, it's the same principle, but in practice you'll use something like parMap or other, par is far too low level (and confusing) for complex programs, which is why there is a library of precooked strategy
17:10:08 <ialpert> i'm somewhat associating seq with evaluate thunk
17:10:22 <ddarius> pseq is like seq only it guarantees to evaluate the first argument before the second.
17:11:02 <ddarius> In fact, for parPair there would be essentially no difference using seq instead of pseq.
17:12:36 <ialpert> ok, that helps a lot, thanks
17:13:58 <ddarius> The issue is if you write something like (a `par` b) `seq` a + b, it's completely legitimate for seq to evaluate the a + b first and then the a `par` b which would lead to no parallelism (a and b would need to be evaluated to do a + b and then there would be nothing for a `par` b to do)
17:14:04 <jedai> ialpert: I would suggest reading the paper on Strategy, it's not too long and it clarify things much
17:14:12 <jedai> ?go strategy haskell
17:14:14 <lambdabot> http://www.macs.hw.ac.uk/~dsg/gph/
17:14:14 <lambdabot> Title: Glasgow Parallel Haskell
17:14:36 <ialpert> ok
17:14:42 <ialpert> thanks alot again
17:14:59 <jedai> http://www.macs.hw.ac.uk/~dsg/gph/papers/abstracts/strategies.html
17:15:04 <ialpert> i think most of this is ahead of where i actually am ...
17:15:40 <jedai> Don't be too scared of the academic papers, most of them are written for people who don't really know the subject
17:16:30 <ialpert> jedai: i usually am not... comeing here was mostly because i wanted to see if i could get some instant gradification... hmm that sounds bad
17:16:54 <ialpert> ddarius: you know if there's any tools that will show you execution order so i could watch something like that
17:17:05 <ialpert> suppose i could just google haskell debuggers
17:18:08 <jedai> @seen dons
17:18:08 <lambdabot> dons is in #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6h 1m 14s ago.
17:18:22 <pejo> ialpert, http://raintown.org/?page_id=132
17:18:42 <ialpert> pejo:ty
17:19:09 <pejo> ialpert, but it's not publicly available yet I think. And you need a runtime system that will produce the logs that tool eats.
17:20:09 <rovar> has anyone done any work in the way of connection pooling with forkIO?
17:20:12 <ialpert> guess i should ask, any recommended editor/ide -- been using vim (syntax highlighted out of the box on gentoo)
17:20:40 <rovar> i'm thinking about making a generic connection pool for a db driver
17:20:49 <gwern> ialpert: leksah and yi are 2 haskell solutions
17:20:51 <kynky> leksah and emacs-cvs with haskell mode look good
17:22:24 <ialpert> ok , thanks for theinput
17:22:52 <dibblego> (join .) . intersperse -- is this in the stdlib?
17:23:00 <Saizan> intercalate
17:23:18 <dibblego> ah thanks
17:23:21 <Olathe> @unpl (join .) . intersperse
17:23:21 <lambdabot> (\ d i -> (intersperse d i) >>= \ e -> e)
17:23:21 <Saizan> new in 6.6.1 iirc, or so
17:31:39 <thomastc> hello!
17:31:45 <thomastc> does anyone here have experience with HSP?
17:32:11 <thomastc> or, to partly rephrase the question, is it actually being used for anything?
17:32:27 <rovar> #happs
17:32:52 <thomastc> many thanks rovar :)
17:43:24 <b\6> possible to define a type that means 'anything that is an instance of X'?
17:44:52 <kpreid> b\6: yes, it's called an existential type
17:45:48 <b\6> kpreid: yeah, but i guess i'm not seeing how to define Any type. type Any = forall a. X a type of thing.
17:46:07 <kpreid> it has to be a data type
17:46:18 <kpreid> data Any = forall a. X a
17:46:31 <kpreid> wait, X is your typeclass? do this
17:46:43 <kpreid> data Any = forall a. X a => Any a
17:46:45 <kpreid> that will work
17:46:52 <b\6> thanks.
17:46:57 <monochrom> http://www.haskell.org/haskellwiki/Existential_type  has examples.
17:47:02 <jedai> b\6: data Showable = forall a . (Show a) => S a
17:48:14 <jedai> You can make a list of Showable with different types inside, but be conscious that you can't extract them back safely, the exact type is lost. You can still use the function that works on Show instance though
17:48:51 <finlay> Hello
17:48:52 <jedai> If you want something that can be extracted back safely, you could look at Dynamic though
17:49:19 <jedai> Hi
17:49:39 * finlay suddenly feels shy
17:50:01 <jedai> This channel is pretty friendly, no reason to be shy :)
17:50:09 <finlay> I thought I would ask about ghc 6.10 and ubuntu
17:50:33 <finlay> the packaged version is 6.8, but the library "probability" requires 6.10
17:50:56 <finlay> so the question: should I build 6.10, or find a .deb package somewhere ?
17:51:03 <b\6> finlay: it's pretty easy to have an install of ghc in your ~.
17:51:08 <jedai> finlay: It's pretty easy to install the binary available on ghc site
17:51:17 <monochrom> There is a third choice. Use the binary tarball.
17:51:28 <finlay> the binary tarball, great
17:51:47 <finlay> I have installed cabal under ~/.cabal
17:51:49 <jedai> and since compiling GHC is pretty long (not hard but long), the binary is definitely a good choice
17:52:49 <monochrom> But Wow! ubuntu repos finally catch up to 6.8.2. :)
17:54:13 <jedai> Arch Linux is far ahead of Debian in supporting Haskell
17:54:23 <jedai> How is Gentoo by the way ?
17:54:54 <seoushi> the stable version of ghc in gentoo is 6.8.x I don't know about unstable tho
17:54:59 <finlay> Debian has a 6.10 package available
17:55:03 <Ralith> hay guys
17:55:11 <finlay> in sid
17:55:26 <Ralith> how practical are building shared libs inhaskell and dynamically loading them at runtime?
17:55:37 <Ralith> for e.g. a plugin system
17:55:53 <jedai> Ralith: It isn't really...
17:56:02 <Ralith> :/
17:56:04 <Ralith> whyzat
17:56:11 <jedai> Look at plugins though
17:56:13 <Ralith> that seems like a reasonable thing to want to do to me
17:56:14 <Ralith> link?
17:56:22 <jedai> I don't know how advanced it is
17:56:22 <monochrom> GHC execution model is funny.
17:57:10 <Ralith> right now I'm using hint to dynamically compile and load stuff, but that depends on having ghc available on the target system which is non-ideal
17:57:24 <jedai> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
17:57:27 <Ralith> plus compiling takes a while and isn't usually necessary
17:57:28 <Ralith> thanks
17:57:51 <Ralith> on that note, anyone know how to make hint leave object files or something unless the target file has changed?
17:58:23 <Ralith> jedai: plugin depends on ghc too.
17:58:34 <Ralith> can it function at runtime without ghc installed?
18:00:11 <jedai> Ralith: Nope, I'm pretty sure there is no solution that don't use ghc
18:00:21 <Ralith> that really sucks
18:01:54 <jedai> You can compile a dll on Windows and load it dynamically I think
18:01:57 <Ralith> what env var do I need to se to get ghc to look in a nonstandard lib dir?
18:02:04 <Ralith> jedai: I don't care about windows :P
18:02:22 <Ralith> but if that can be done, why not compile to .so and load dynamically?
18:07:11 <jedai> Ralith: contribute to GHC to add the functionality ?
18:07:36 <Ralith> contribute to ghc to make my program work without ghc?
18:07:38 <Ralith> that doesn't sound right.
18:08:10 <mmorrow_> Ralith: contribute to {j,l}hc then :)
18:08:22 <Ralith> contribute to ghc to make my program work without a compiler?
18:08:23 <Ralith> that doesn't sound right.
18:08:48 <jedai> Ralith: Well you still need to compile sometimes... if you want to be able to load precompiled object
18:08:48 <mmorrow_> but really though, ghc's dynamic linker is pretty entwined into its runtime
18:09:07 <mmorrow_> (where dynamic := dynamically linking/loading .o's)
18:09:23 <Ralith> well, I've no experience programming compilers, so I dunno about that
18:09:40 * wli gets some data dependency graph stuff going.
18:09:48 <Ralith> I keep getting this error trying to install Cabal on a system w/o root:
18:09:49 <Ralith> Setup.hs: Error: Could not find module: Distribution.Compiler with any suffix:
18:09:49 <Ralith> ["hi"]
18:10:12 <mmorrow_> and since there's no standard haskell abi or whatever like C, it'd be tough
18:11:24 <Ralith> I'd be happy if it worked within a single compiler
18:11:31 <Ralith> hell, at this point I'd be happy if I could install Cabal.
18:11:58 <mmorrow_> wli: i'm suffering through switching between the interpreter and gc :)
18:12:11 <mmorrow_> Ralith: heh
18:12:48 <Ralith> seriously, what's up with this?
18:13:04 <wli> GC sucks pretty hard.
18:13:12 <Ralith> how do I make Cabal work?
18:15:29 <thomastc> question for the haskell community: would I do the world a favour if I beat EclipseFP into shape?
18:15:39 <thomastc> think Visual Haskell but then for Eclipse
18:15:46 <thomastc> type inference and completion and all that jazz
18:16:18 <bremner> thomastc: some people have spoken in favour of that kind of thing
18:16:49 <thomastc> I personally would be in favour, just hoping to hear some arguments against, mainly ;)
18:17:07 <thomastc> the lack of a proper IDE is really holding Haskell back I think
18:17:28 <blackh> thomastc: I would be very much in favour, and I would use it... I'm just not motivated enough to do it myself.
18:17:44 <Ralith> thetallguy: emacs, yi
18:17:49 <bremner> personally I don't think IDEs are the main question.
18:18:17 <dons> leksah is remarkably popular this month.
18:18:18 <thomastc> bremner: at the risk of going off (my) topic, what *is* the main question?
18:18:22 <dons> it cracked the top 25 hackage downloads
18:18:32 <dons> maybe we should just declare leksah the haskell IDE
18:18:35 <Ralith> can I get some help with Cabal here?
18:18:39 <Ralith> Distribution/Compiler.hi exists
18:18:39 <dons> Ralith: yes
18:18:42 <Ralith> yay!
18:18:47 <Ralith> Setup.hs: Error: Could not find module: Distribution.Compiler with any suffix:
18:18:47 <Ralith> ["hi"]
18:18:47 <c_wraith> I just wish that emacs haskell-mode didn't try to generate syntactically-invalid haskell sometimes.
18:18:56 <bremner> thomastc: people just functional programming hard, and don't see the point
18:18:58 <thomastc> dons: couldn't even get it to run properly, kept locking up on me
18:18:58 <dons> thomastc: yes, you'd help a lot of people if eclipsefp was world class
18:19:08 <Ralith> trying to do runhaskell Setup.hs install in Cabal-1.6.0.2
18:19:11 <bremner> thomastc: don't mind me, I'm marking exams :-)
18:19:15 <dons> clearly a large group of people want IDE support, so let's have one.
18:19:15 <kpreid> dons: http://hackage.haskell.org/trac/summer-of-code/ticket/1542 has a broken link
18:19:21 <dons> kpreid: ok. it's a wiki...
18:19:21 <Ralith> configured with --prefix=$HOME
18:19:42 <kpreid> dons: no, it's a signup-only wiki :)
18:19:43 <dons> Ralith: you need to use the boostrap script
18:19:51 <Ralith> what bootstrap script?
18:20:23 <dons> well, actually, i'm only guessing that's the problem. (i.e. you don't have cabal installed, so it tries to load Setup.hs , which needs cabal )
18:20:31 <thomastc> and Eclipse is a fine IDE imho, it's come a great way since I used it five years ago, and now I'm actually growing fond of it :)
18:20:31 <dons> cabal comes with a makefile to bootstrap it. check the README
18:20:43 <dons> thomastc: go for it. build a project, make it great!
18:21:08 <dons> leksah's got some momentum though. maybe it would be possible to share code
18:21:22 <Saizan> no
18:22:06 <Saizan> Cabal autobootstraps
18:22:11 <Ralith> oh, wait, I managed to getsomewhere by pre-compiling Setup.hs
18:22:22 <Ralith> couldn't find any mention of a bootstrap script but this seems to be going somewhere
18:23:15 <dons> Saizan: if you do it wrong, it won't, last i tried. i might be wrong though.
18:23:26 <dons> Ralith: yeah, loading in ghci will try to interpret cabal in the current dir.
18:23:28 <dons> read the readme :)
18:23:38 <Ralith> ghci? is that what runhaskell is?
18:23:45 <Saizan> yes
18:23:49 <Ralith> kk
18:23:52 <Ralith> this seems to have worked!
18:23:53 <Ralith> yay
18:24:25 <Ralith> ty all
18:24:56 <Ralith> dons: one last thing: what environment variable can I throw $HOME/lib in to make ghc pass that as a search dir to ld?
18:25:11 <dons> LD_LIBRARY_PATH
18:25:14 <Ralith> kk
18:25:53 <thomastc> oh, and in a perfect world, the IDE would also have something like Hoogle, i.e. search functions by type, etc.
18:26:02 <Ralith> dons: didn't work
18:26:20 * thomastc goes off to look at the Eclipse API
18:27:05 <Ralith> $ LD_LIBRARY_PATH="$HOME/lib" ./bootstrap.sh
18:27:08 <Ralith> ...
18:27:09 <Ralith> /usr/bin/ld: cannot find -lgmp
18:27:25 <dons> export
18:27:28 <dons> oh.
18:27:34 <Ralith> tried that, too
18:27:37 <dons> you've got a broken system, eh?
18:27:40 <Ralith> huh?
18:27:50 <dons> you don't have a distro package for gmp?
18:27:54 <Ralith> no, I don't have root.
18:27:57 <dons> ah.
18:28:02 <Ralith> I do have gmp installed in ~
18:28:13 <Ralith> which works fine when I can manually pass -L to ghc
18:28:13 <dons> oh, you might need to edit the package.conf for ghc
18:28:15 <dons> to add -lgmp
18:28:19 <dons> yeah.
18:28:40 <dons> edit lib/ghc-6.10.1/package.conf
18:28:46 <Ralith> got it open
18:28:50 <dons> look for ldOptions
18:29:12 <Ralith> there's one on every line
18:29:14 <dons> add "-L/my/path/" to the list of ld flags for the rts package
18:29:18 <Ralith> kk
18:29:33 <dons> then ghc will pass that to ld every  time
18:29:54 <dons> it should be before the "-u", et al options
18:30:03 <dons> ldOptions = ["-u","ghczmpr
18:30:04 <dons> etc
18:30:04 <Ralith> handy
18:30:05 <Ralith> yeah
18:30:07 <Ralith> I follow
18:30:08 <Ralith> testing now
18:30:24 <dons> you can test my compiling a hello.hs
18:30:28 <dons> just to check it links properly
18:30:34 <dons> then once you know your ghc is ok, continue
18:30:40 <Ralith> ultimately it takes less time to just try to continue :P
18:31:10 <Ralith> it worked! :D
18:31:10 <Ralith> ty
18:31:29 <bremner> thomastc: I'd be more enthused about something that didn't want 300MB diskspace to install. But maybe I'm not the target market.
18:31:42 <further> hi all, I am overloading some operator, like "<+>" "<->" "<*>" "</>" (without quotes). how can I order their priority?
18:32:06 <dons> their fixity you mean?
18:32:21 <dons> infixl 9 (<+>) ?
18:32:30 <hamishmack> thomastc: Hi, which version of Leksah was locking up for you?  What OS?
18:32:43 <dons> you can check the fixity and precedence using the :info command
18:33:49 <further> dons: thanks, I am trying.
18:34:06 <thomastc> hamishmack: it's a while ago, I don't remember
18:34:17 <thomastc> it was Ubuntu Hardy
18:35:28 <wli> Okay, I think I just wrapped up dependency graph generation.
18:35:56 <mmorrow_> wli: here are some misc snippets http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1961
18:36:06 <dons> http://twitter.com/gvanrossum/statuses/1372452815
18:37:24 <wli> http://wli.pastebin.com/m58efe4de
18:38:48 <wli> mmorrow: Tough for me to interpret.
18:39:28 <ImInYourMonad> how does haskell lack a proper IDE when we have emacs?
18:39:52 <ImInYourMonad> Im all for leksha though, even though I couldnt get it going on windows.
18:39:58 <hamishmack> thomastc: It would be great if you could try again with the current version.
18:40:04 <ImInYourMonad> emacs still can be annoying soemtimes
18:40:08 <ImInYourMonad> but what about Yi?
18:40:28 <Raynes> ImInYourMonad: I got it going fine on Windows.
18:40:42 <Raynes> I just darcs + cabal installed it.
18:40:49 <dons> let's just not have the IDE debate, eh?
18:41:02 <dons> make one. we need more of everything. including IDEs
18:41:20 <Raynes> dons: I don't think anyone is debating anything.
18:42:24 <hamishmack> Raynes:  Did you use the pre packaged gtk2hs?
18:42:32 <Raynes> Yup.
18:42:38 <Raynes> Newest version.
18:42:47 <hamishmack> I get font problems for some reason
18:42:53 <Raynes> Well, whatever was newest 2 weeks ago.
18:42:59 <Ralith> leksha?
18:43:11 <Raynes> leksah.
18:43:11 <hamishmack> In leksah yes
18:43:14 <Ralith> ah.
18:43:21 <hamishmack> Text is all over the place
18:43:44 <Ralith> hm, I have to say it doesn't look as interesting as yi
18:43:53 <Raynes> Doesn't do that too me. But I haven't really used it, I just looked at it. I'd prefer Emacs over it.
18:44:03 <Ralith> too GUI-driven
18:44:12 <Raynes> to*
18:44:25 <dons> yi is an editor, leksah is an ide
18:44:38 <dons> yi would sit _inside_ leksah
18:45:04 <Raynes> Let's not have the "What's an editor and what's an IDE" debate ;)
18:45:47 <Ralith> dons: does leksah support embedding external editors?
18:45:54 <Ralith> most IDEs don't seem to; this is the problem.
18:46:50 <hamishmack> Ralith: we need to work out an interface first
18:49:37 <hamishmack> for instance autocomplete (if it stays in the IDE) needs to know the location of the cursor on the screen
18:54:26 <jedai> I tried leksah but for some reason I can't even write a whitespace in it, it must be a shortcut gone awry but I didn't try very hard to find the cause
18:54:51 <hamishmack> jedai: what OS?
18:55:25 <BMeph> =\
18:55:26 <BMeph> \
18:55:26 <jedai> Linux, Ubuntu Intrepid, GTK2Hs 0.10, GHC 6.10.1
18:57:21 <jedai> The bar display "<ctrl>space=StartComplete" every time I hit the spacebar
18:58:11 <jedai> It's Leksah 0.4.3
19:00:15 <hamishmack> Was this in an existing file or a new empty one?
19:01:08 <jedai> Everywhere (well I didn't try in an existing file), in the package creation interface, in a new empty file, ...
19:01:56 <jedai> And in an existing file too
19:02:28 <jedai> I would say that "Space" is bound to a global shortcut somehow
19:03:12 <Ralith> cabal: fromFlag NoFlag. Use fromFlagOrDefault
19:03:23 <Ralith> anyone know why I'm getting this after setting a few options in ~/.cabal/config?
19:03:56 <hamishmack> what about other keys?  If you press b does it try to build?
19:04:21 <zsh> So, i'm going through the haskell wikibook (with ghc 6.10.1), and in ghci, many results from the examples come back with ^JSOMENUMBERS appended to them. What's the deal with that?
19:04:43 <Ralith> cabal won't work on anything now
19:04:45 <jedai> hamishmack: No, a b just print a "b"
19:04:46 <Ralith> wth
19:05:05 <Ralith> the only way to not get the error is to uncomment remote-repo, which makes it kind of useless
19:05:21 <edwardk> hrmm is anyone here all that familiar with regex-tdfa internals?
19:05:41 <Ralith> google tells me nothing
19:05:57 <edwardk> i'm trying to see if i can raid it for its dfa compiler to back a monoidal version
19:06:13 <pejo> zsh, in EmacS?
19:06:25 <Ralith> dons: any idea why cabal-install would generate the error "cabal: fromFlag NoFlag. Use fromFlagOrDefault"?
19:06:37 <zsh> pejo: yeah, I just realized it's not doing it in a regular shell
19:06:47 <zsh> im in inf-haskell
19:06:52 <hamishmack> jedai: have a look in ~/.cabal/share/leksah-0.4.3/data/Default.keymap
19:07:47 <hamishmack> jedai: try deleting the line at the end <ctrl>space ...
19:07:59 <Ralith> ah, got it working; no idea why it borked though
19:08:03 <bremner> zsh: I have the same problem.  There was a nasty hack posted to the mailing lists; I haven't seen a real solution
19:08:16 <pejo> zsh, http://sites.google.com/site/haskell/notes
19:08:41 <thomastc> hamishmack: leksah 0.4.3 depends on base-4.0.0, but cabal seems unwilling to install that
19:08:49 <pejo> zsh, look at the piece that says Conal Elliott.
19:09:00 <zsh> thanks
19:09:09 <jedai> hamishmack: That did it, thanks, though I guess this line should only have worked if I pressed Ctrl+Space, no ?
19:09:37 <jedai> thomastc: base-4.0 comes with ghc 6.10
19:09:44 <pejo> bremner, there's a second solution on the page I gave too. Not sure if it works.
19:10:09 <jedai> thomastc: To be honest, right now leksah 0.4 needs the latest ghc with the latest gtk2hs
19:10:10 <bremner> pejo: thanks, I'm going to try the hook
19:10:25 <hamishmack> jedai: yes that is strange.
19:11:13 <thomastc> jedai: I see... which means I'd either have to stop being lazy, or upgrade to Intrepid, which (supposedly) is significantly slower than Hardy
19:11:26 <thomastc> ... maybe later :)
19:11:52 <wli> What are Intrepid and Hardy?
19:12:01 <jedai> thomastc: I didn't notice that Intrepid was any slower than Hardy ?? (maybe PulseAudio though)
19:12:03 <Zao> wli: Ubuntu releases.
19:12:09 <jedai> wli: release of ubuntu
19:12:09 <Zao> 8.10 and 8.04
19:12:26 <bremner> pejo: well, it echos  every expression you type,  but it is less annoying than before
19:12:29 <Zao> (year.month)
19:12:30 <jedai> thomastc: anyway Intrepid still has ghc6.8.2
19:12:32 <wli> I've not dealt with ubuntu.
19:13:05 <jedai> thomastc: so you would still need to install the latest ghc by hand and compile gtk2hs yourself
19:13:06 <Zao> Hardy is the current long term support one, so you'll have to suffer from reports from that for a long while :P
19:14:26 <thomastc> I'm somewhat reluctant to upgrade because I'm taking a don't-fix-what-ain't-broken approach towards my operating system
19:19:05 <jedai> thomastc: Probably a sane attitude... Anyway you can install the ghc6.10 binary in your home and install all your package locally so as to not disturb your system too much
19:19:14 <dolio> @seen mofmog
19:19:14 <lambdabot> mofmog is in #haskell. I last heard mofmog speak 3h 29m 9s ago.
19:19:25 <jedai> that's the defaut for cabal-install anyway
19:19:46 <finlay> thomastc: Im installing 6.10 on ubunto 8.10 'intrepid'
19:19:54 <finlay> well, when I get home from work
19:20:19 <finlay> probably use the binary release
19:25:28 <roconnor> @src (\\)
19:25:28 <lambdabot> (\\) = foldl (flip delete)
19:25:33 <roconnor> why is that a left fold?
19:25:44 <kpreid> :t \\
19:25:45 <lambdabot> parse error on input `\\'
19:25:48 <kpreid> :t (\\)
19:25:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
19:26:06 <dolio> You can't yield any values until you've taken care of all the deletions?
19:26:51 <dolio> Or, I suppose you can, but not using delete.
19:27:21 <roconnor> > delete 3 [3,3,3]
19:27:22 <lambdabot>   [3,3]
19:27:47 <dolio> > delete 3 [3,2,3,3]
19:27:48 <lambdabot>   [2,3,3]
19:28:42 <roconnor> > delete 3 [1,2..]
19:28:43 <lambdabot>   [1,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:28:59 <roconnor> > [1,2..] \\ [2,3]
19:29:00 <lambdabot>   [1,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
19:29:36 <roconnor> dolio: still, why is a left fold preferable?
19:30:23 <abuiles> Hi, in The Typeclassopedia ,  the typeclass pointed has a function called pure, but in the  hackage's  package  the function name is point , it seems like doing the same thing that  pure does, however I just want to be sure if I'm looking in the correct place and the name was changed or Is other Pointed..? thks
19:30:37 <Gracenotes> roconnor: it seems ...if Eq's == really means that two objects are indistinguishable, it shouldn't make too much of a difference
19:31:13 <roconnor> Gracenotes: right.  But there may be some efficency reasons to pick a left fold
19:31:42 <roconnor> oh I think I know why
19:31:44 <Olathe> @type point
19:31:45 <lambdabot> Not in scope: `point'
19:31:47 <Gracenotes> yeah. But also, the Eq contract might only hold to a certain point (for instance, if you pick a unique identifier)
19:31:58 <roconnor> > [1,2,3,2,1] \\ [2]
19:31:58 <kerlo> > delete 'l' "hello"
19:32:00 <lambdabot>   "helo"
19:32:00 <lambdabot>   [1,3,2,1]
19:32:05 <kerlo> I win. :-P
19:32:20 <roconnor> okay, I don't know why
19:32:33 <Gracenotes> but remember that the list you're folding on is the second one
19:32:37 <kerlo> > "Hello, hello! I don't know why you say goodbye; I say hello." \\ "hello world"
19:32:38 <lambdabot>   "H,el! I on't kno why you say goodbye; I say hello."
19:32:40 <roconnor> right
19:32:40 <dolio> I don't think it really matters.
19:32:50 <Olathe> > delete "bop" ["bop","shu","bop","shu","bop"]
19:32:51 <lambdabot>   ["shu","bop","shu","bop"]
19:32:59 <roconnor> dolio: you think they are equally as efficent?
19:33:13 <kerlo> > foldl (flip delete) "Hello, hello! I don't know why you say goodbye; I say hello." "hello world"
19:33:14 <lambdabot>   "H,el! I on't kno why you say goodbye; I say hello."
19:33:17 <kerlo> > foldr (flip delete) "Hello, hello! I don't know why you say goodbye; I say hello." "hello world"
19:33:17 <dolio> They both potentially cause stack overflows.
19:33:18 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
19:33:18 <lambdabot>        Expect...
19:33:22 <Olathe> @hoogle (Eq a) => a -> [a] -> [a]
19:33:23 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
19:33:23 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:33:23 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
19:33:26 <kerlo> Oh dear.
19:33:29 <roconnor> > foldr (delete) "Hello, hello! I don't know why you say goodbye; I say hello." "hello world"
19:33:30 <lambdabot>   "H,el! I on't kno why you say goodbye; I say hello."
19:33:46 <kerlo> Same output.
19:33:48 <Olathe> @type until
19:33:49 <dolio> foldl is probably more heap efficient, off the top of my head.
19:33:49 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
19:33:50 <Gracenotes> however, the 'l' that's removed first is the second one
19:33:59 <dolio> As far as keeping the original list around is concerned.
19:34:01 <Gracenotes> er, I mean, the first one. :)
19:34:16 <Gracenotes> so it'll remove the first l, and then the second l, in turn.
19:34:36 <Gracenotes> in some cases the opposite might be unexpected I suppose
19:34:47 <Gracenotes> not for Char
19:35:00 <kerlo> If you're at your house and you want to drive along the road between your house and the grocery store, one direction is preferable to the other.
19:35:28 <roconnor> Gracenotes: I'm pretty sure they are denotationally the same
19:35:35 <kerlo> A slightly better analogy: you have a spaghetty noodle, and one end is in front of you while the other is in the living room. It's best to start slurping at your end, not the living room end.
19:35:53 <ImInYourMonad> " since remote method/function calls become way harder" in haskell that is, how is that solved? data.dynamic?
19:35:59 * kerlo rolls away.
19:36:04 <roconnor> kerlo: are you talking about (\\)?
19:36:12 <kerlo> foldl versus foldr.
19:36:15 <ImInYourMonad> basically you can extend that to haskell+networking in general
19:36:21 <ImInYourMonad> vs python/dynamic langs
19:36:26 <dolio> > [1] \\ [2..1000000]
19:36:28 <lambdabot>   [1* Exception: stack overflow
19:36:33 <roconnor> kerlo: but the spaghetty strand is the first arguement, which isn't being folded.
19:36:35 <idnar> > foldl delete "Hello, hello! I don't know why you say goodbye; I say hello." "hello world"
19:36:36 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:36:36 <lambdabot>        Expect...
19:36:46 <dolio> > foldr delete [1] [2..1000000]
19:36:48 <lambdabot>   * Exception: stack overflow
19:36:52 <idnar> > foldl (flip delete) "Hello, hello! I don't know why you say goodbye; I say hello." "hello world"
19:36:53 <kerlo> roconnor: well, you're folding *something*.
19:36:53 <lambdabot>   "H,el! I on't kno why you say goodbye; I say hello."
19:36:57 <roconnor> dolio: interesting
19:37:01 <dolio> There we go. foldl is one better. :)
19:37:07 <Olathe> > let deleteAll _ [] = []; deleteAll x (y:ys) = if x == y then deleteAll x ys else y:deleteAll x ys in deleteAll "bop" ["bop","shu","bop","shu","bop"]
19:37:08 <lambdabot>   ["shu","shu"]
19:37:09 <dolio> > foldr delete [1,2] [3..1000000]
19:37:11 <lambdabot>   * Exception: stack overflow
19:37:18 <dolio> > foldl (flip delete) [1,2] [3..1000000]
19:37:20 <lambdabot>   * Exception: stack overflow
19:37:26 * wli tries to figure out how to exploit the special structure of this graph to do faster SCC's.
19:37:28 <idnar> > foldl' (flip delete) [1,2] [3..1000000]
19:37:29 <dolio> > foldl' (flip delete) [1,2] [3..1000000]
19:37:30 <lambdabot>   [1* Exception: stack overflow
19:37:31 <lambdabot>   [1* Exception: stack overflow
19:37:32 <idnar> heh
19:37:45 <idnar> @src delete
19:37:46 <lambdabot> delete = deleteBy (==)
19:37:49 <idnar> @src deleteBf
19:37:49 <lambdabot> Source not found. You untyped fool!
19:37:50 <idnar> @src deleteBy
19:37:50 <lambdabot> deleteBy eq x []        = []
19:37:51 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
19:37:51 <roconnor> dolio: I'm confused
19:37:53 <dolio> (\\) must get strictness analyzed into the foldl' version in compiled code.
19:38:20 <roconnor> dolio: how does strictness help when the output is a list?
19:38:33 <Olathe> > let deleteAny _ [] = []; deleteAny xs (y:ys) = if elem y xs then deleteAny xs ys else y:deleteAny xs ys in deleteAny [1, 2] [1..10000]
19:38:33 <dolio> It only helps with the first element. :)
19:38:34 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
19:38:43 <Olathe> Take that, Internet !
19:38:44 <roconnor> dolio: okay, that's moronic
19:38:46 <roconnor> :)
19:38:48 <idnar> haha
19:39:23 <dolio> With foldl' it's 1 : (delete 3 (delete 4 (delete 5 ...))) with foldl it's (delte 3 (delete 4 (delete 5 ...))).
19:39:44 <dolio> foldr is somewhat worse, I think.
19:39:59 <dolio> > foldr delete [1..1000000] [1..1000000]
19:40:01 <lambdabot>   * Exception: stack overflow
19:40:11 <dolio> > foldl' (flip delete) [1..1000000] [1..1000000]
19:40:12 <lambdabot>   []
19:40:16 <Olathe> @type foldr
19:40:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:40:22 <dolio> There's your foldl case.
19:40:38 <dolio> > foldl (flip delete) [1..1000000] [1..1000000]
19:40:40 <lambdabot>   * Exception: stack overflow
19:40:57 <roconnor> > foldl' (flip delete) [1..1000000] [1..1000000]
19:40:58 <lambdabot>   []
19:40:59 <ImInYourMonad> " since remote method/function calls become way harder" in haskell that is, how is that solved? data.dynamic?
19:41:03 <Olathe> > let deleteAny xs = foldr (\el ac -> if elem el xs then el:ac else ac) [] in deleteAny [1, 2] [1..10000]
19:41:03 <dolio> Needs the strictness analysis, though.
19:41:05 <lambdabot>   [1,2]
19:41:14 <Olathe> > let deleteAny xs = foldr (\el ac -> if elem el xs then ac else el:ac) [] in deleteAny [1, 2] [1..10000]
19:41:15 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
19:41:21 <Olathe> Yay, foldr.
19:41:57 <Olathe> > let deleteAny xs = filter (not . flip elem xs) in deleteAny [1, 2] [1..10000]
19:41:58 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,...
19:42:30 <roconnor> okay.  So what is the result here?  foldl isn't any better than foldr and foldl' is only epsilon better than those?
19:43:03 <dolio> foldr is bad on large lists of things to be deleted.
19:43:24 <dolio> foldl' is still bad on those if they're not actually in the list you're deleting from.
19:43:26 <roconnor> dolio: such as?
19:43:37 <Gracenotes> The folds go marching one by one hurrah, hurrah... the folds go marching one by one hurrah, hurrah!
19:43:40 <roconnor> oh right
19:43:41 <dolio> > foldr delete [1..1000000] [1..1000000]
19:43:43 <lambdabot>   * Exception: stack overflow
19:44:00 <roconnor> > [1..1000000] \\ [1..1000000]
19:44:01 <lambdabot>   []
19:44:04 <roconnor> ok
19:44:10 <dolio> Actually I suppose it's always pretty bad except for very special cases.
19:44:20 * roconnor nods
19:44:23 <roconnor> well
19:44:31 <roconnor> At least there are rare cases when it is good
19:44:34 <dolio> > ([1,2] ++ [1..1000000]) \\ [1..1000000]
19:44:36 <lambdabot>   [1* Exception: stack overflow
19:44:50 <roconnor> very very rare
19:44:50 <dolio> Nevertheless, it's good in more cases.
19:45:12 * wli balks at the full Tarjan algorithm.
19:45:18 <dolio> And defining it as foldl is the best you can do in the report, because foldl' doesn't exist.
19:45:32 <dolio> And maybe foldl + strictness analysis will turn it into foldl'.
19:45:36 <roconnor> yep
19:48:04 <wli> You've got quite a bit of leverage here because you know a defining subexpression in whose lower shadow the strongly connected component containing any node must lie.
19:48:56 <wli> There's even a strict tree structure to the definition relation.
19:49:36 <Ralith> what's the favorite database interface these days?
19:50:12 <wli> duh, except I nuked let expressions
19:54:02 <wli> The definition affair is essentially only for lambda-bound variables and variables introduced in pattern matching. So I'm failing to build the full graph by a rather long longshot.
19:56:48 <gnuvince_> How fast is Data.Binary?
19:57:45 <dons> fast
19:58:01 <dons> like fast enough for anything you'd consider parsing
19:58:12 <Nafai> dons: Do you have any suggestions if I want to write an IRC bot that needs to connect via SSL?
19:58:25 <dons> modify the irc library by gluing it to hopenssl ?
19:58:28 <gnuvince_> dons: I have a Java program that can process 1000+ binary files in 8 seconds.  My version in Clojure takes 2 minutes and half.  You think Data.Binary could be in Java's range?
19:58:39 <dons> yes.
19:58:47 <dons> ghc -O2
19:58:47 <gnuvince_> Cool
19:59:00 <dons> its not   the number of files though. it's the size
19:59:01 <fsanches> hi. could someone help me get this code to compile, please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2771#a2771
19:59:07 <dons> how many gigs?
19:59:33 <gnuvince_> dons: every file is between 50 and 500 kb
19:59:40 <dons> oh, tiny
19:59:42 <dons> go nuts
19:59:52 <dons> i was thinking more in the 100M range
20:00:07 <gnuvince_> Nah, they're really small files (Starcraft replay files if you're curious)
20:00:23 <Ralith> I'm getting: * Missing C library: sqlite3
20:00:24 <gnuvince_> I've been trying for two weeks to improve the performance of my Clojure version, but I'm giving up.
20:00:27 <Ralith> from cabal-install
20:00:32 <dons> Ralith: you're missing the C library sqlite3
20:00:34 <Ralith> despite there being a libsqlite3.so in
20:00:34 * Nafai tries to find an example for the irc lib
20:00:38 <dons> hmm. path?
20:00:46 <Ralith> it's in the lib searchpath.
20:00:54 <dons> check what the configure scripts are doing
20:00:57 <Ralith> I know this because it's in the same place as gmp.
20:01:04 <Ralith> uhh
20:01:12 <FunctorSalad> what could this be.... my program works fine when built with profiling, but otherwise <<loop>>? :(
20:01:14 * Ralith searches through .cabal
20:01:30 <FunctorSalad> (both are with -O2)
20:02:40 <dons> Ralith: might need to pass -L to cabal or in the .cabal file
20:02:59 <Ralith> I tried passing --extra-lib-dirs= as the error suggested
20:03:01 <Ralith> didn't do anything
20:03:07 <Ralith> I suspect the issue may be that sqlite3 needs libdl
20:03:15 <Ralith> will see if I can put that in the .cabal
20:04:02 <dons> you're going to learn a lot about cabal :)
20:04:05 <Ralith> er, where would I put the -ldl?
20:04:08 <Ralith> GHC-Options:?
20:04:22 <KilledByASideeff> @type foldl
20:04:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:04:53 <wli> Okay, now I build the full graph.
20:05:09 <KilledByASideeff> Okay, now I graph the full build.
20:06:29 <dons> hmm. -ldl is a bit odd...
20:06:31 <Ralith> dons: how do I even find out what the error really was?
20:06:38 * Ralith misses config.log
20:07:19 <Ralith> dons: I guessed libdl 'cuz gcc -lsqlite3 on an empty file doesn't work w/o -ldl too
20:07:23 <Nafai> So Network.IRC doesn't seem to do anything with network communication, it just handles the messages
20:07:48 <Ralith> Nafai: it provides datatypes and functions to get IRC commands into and out of them.
20:08:38 <Nafai> Ralith: So to use it, I would separately handle network communication and pass each line off to the parser
20:08:54 <Ralith> Nafai: yes; that is trivial to do.
20:09:10 <Nafai> Yeah, looks like it
20:09:22 <Nafai> Great, so it won't be hard to use this for SSL-fu
20:09:25 <Ralith> dons: so, how do I find out what the error really was>?
20:09:55 <Ralith> Nafai: harder with SSL, because SSL isn't very well supported, even via third party libs.
20:10:19 <Nafai> socat or openssl to the rescue then :)
20:10:20 <dons> Ralith: start turning on -v4
20:10:25 <dons> or simiiiilar flags
20:11:12 <KilledByASideeff> dons: what kind of softwar do you do at galois?
20:11:18 <KilledByASideeff> and is it in france?
20:11:21 <dons> nope
20:11:26 <dons> and haskell software :)
20:12:04 <Ralith> cabal: Bad verbosity: 4. Valid values are 0..3
20:12:07 * Ralith tries -v3 :P
20:12:15 <dons> hehe
20:12:39 <KilledByASideeff> dons: yes but what kind of programs, what do they do?
20:13:00 <Ralith> /usr/bin/gcc returned ExitFailure 1 with error message:
20:13:00 <Ralith> /home/ralith/lib/libsqlite3.so: undefined reference to `dlsym'
20:13:07 <Ralith> sounds like it needs libdl.
20:13:10 <dons> oh, check out the website. systems software mostly.
20:13:16 <Ralith> so how do I force it to link libdl in?
20:13:16 <dons> Ralith: mm
20:15:16 <wli> Argh it's still wrong. :(
20:15:28 * Ralith just needs to make it pass -ldl
20:16:25 <Ralith> tried adding dl to Extra-Libraries; didn't work
20:17:37 <Ralith> wait, got it
20:21:02 <wli> I need to materialize new nodes encountered and hand them back to the driver or some such.
20:24:42 <wli> Something like mention n = gets (IntMap.lookup n) >>= maybe (return ()) (const (modify (IntMap.insert n initDeps) >> tell (IntSet.singleton n)))
20:29:16 <wli> Then execWriterT to peel off the writer monad, union the worklist with the result of that, minView the worklist and recurse.
20:34:51 <chowmeined> Gracenotes, http://thoughtpad.net/alan-dean/http-headers-status.gif
20:38:49 <Gracenotes> cute.
20:40:05 <chowmeined> i was looking for that last night but i couldnt find it
20:40:11 <chowmeined> about the whole state machines for protocols thing
20:40:12 <Gracenotes> I can't find 100 on the chart
20:41:32 <Gracenotes> also, if Ender's Game slash exists, I must find it.
20:41:52 <Gracenotes> but yeah seems to be somewhat incomplete
20:42:04 <mjonsson> hiredman, can anyone recommend a good category theory book?I really liked the Typeclassopedia in the latest monad reader, and the earlier noise about monoids.
20:42:46 <wli> If I had just the right API for writers I could use MonadRWS all in one shot.
20:43:11 <Gracenotes> if you're already familiar-ish with programming languages like Haskell, Benjamin Pierce's Category Theory for Computer Scientists might interest you
20:44:21 <mjonsson> Gracenotes, I have Benjamin Perice's Types and Programming Languages but I'm not making much progress on it as I think he delves too much into proofs sometimes, so I'm afraid another book by him may have a similar effect on me
20:44:36 <wli> mapWriterT looks interesting from this POV.
20:45:48 <Gracenotes> well, the proofs in TAPL aren't all necessary for understanding it
20:45:55 <MyCatVerbs> Gracenotes: Rule 34 says of course it does.
20:46:02 <mjonsson> yeah, I just just skip some of them
20:46:21 <mjonsson> thanks for the recommendation
20:47:05 <Gracenotes> mjonsson: Cale has this on his server, which he recommends: http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
20:47:57 <mjonsson> Gracenotes, cool, i'm downloading
20:48:32 <Cale> Oh, you're interested in category theory?
20:48:45 <Cale> Ah
20:48:59 <mjonsson> yep
20:49:25 <mjonsson> The Typeclassopedia inspired me to overcome my fear of them
20:50:08 <Cale> Oh, you're not going to get very far with that one if you don't read the proofs though. They're important, but don't be put off by them. Proofs are the real content of mathematics.
20:51:16 <Cale> Most of the proofs in Awodey's book are not too hard to follow though.
20:52:15 <mjonsson> Oh nice, this book mentions monoids/posets as we talked about earlier
20:52:19 <Cale> yeah
20:52:57 <Gracenotes> @quote poset
20:52:57 <lambdabot> Gracenotes says: You are likely to be eaten by a poset
20:53:00 <wli> I'm pretty sure mapWriterT is what I'm looking for in order to fart around with the queue, although it's more like ...
20:53:17 <wli> @type let mapWriterT' f = mapWriterT (liftM ((,) ()) . f . snd =<<) in mapWriterT'
20:53:17 <lambdabot> forall w (m :: * -> *) a1 a. (Monad m) => (w -> m a1) -> WriterT w m a -> WriterT a1 m ()
20:53:27 <Gracenotes> @quote maze
20:53:27 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
20:54:45 <monochrom> haha
20:55:53 <wli> In such a manner a function taking a queue as an argument and updating the queue with a monadic result can manipulate the queue.
20:55:57 <Cale> Someone really should write it :)
20:56:58 <wli> IOW that enables to use MonadRWS for all this.
21:00:30 <Gracenotes> You have dropped your unambiguous instances.
21:00:41 <Gracenotes> You are likely to be eaten by an undecidable type system.
21:02:48 <solidsnack> You have fallen down a hole.
21:02:50 <edwardk> hrmm, if i were to just suck it up and implement it, whjere would be a good place in the namespace to put a type family based FingerTree?
21:03:19 <edwardk> not sure if anyone has any sort of convention for such conversions
21:03:20 <solidsnack> Org.Hackage.Data.FingerTree
21:03:34 * edwardk lifts an eyebrow.
21:03:54 <solidsnack> Org.Freenode.Haskell.Data.FingerTree
21:04:09 <solidsnack> Flashback.
21:04:11 <solidsnack> Sorry.
21:04:19 * edwardk shake's solidsnack out of his java induced hysteria
21:04:24 <edwardk> er shakes even
21:04:59 <MyCatVerbs> Gracenotes: all interesting type systems are undecidable. :P
21:05:27 <ImInYourMonad> free-theorems: Automatic generation of free theorems. <- what exactly does it do?
21:05:59 <edwardk> ImInYourMonad: given a type it tells you something about how every function with that type must behave
21:06:23 <edwardk> i.e. it'll tell you given the type of fmap alone that forall f g. fmap f . fmap g = fmap (f . g)
21:06:52 <edwardk> (it can't tell you the other functor law because its not guaranteed by the type though)
21:07:21 <Gracenotes> @free fmap . fmap
21:07:22 <lambdabot> Extra stuff at end of line
21:07:27 <Gracenotes> oh, you!
21:07:33 <Gracenotes> @free <*>
21:07:33 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
21:07:37 <Gracenotes> @free (<*>)
21:07:37 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
21:07:43 <Gracenotes> @free ap
21:07:44 <lambdabot> Expected variable or '.'
21:07:52 <edwardk> @free fmap
21:07:53 <lambdabot> Expected variable or '.'
21:08:01 * edwardk can never remember how that thing works
21:08:02 <Gracenotes> .x.
21:08:06 <Gracenotes> @help free
21:08:06 <lambdabot> free <ident>. Generate theorems for free
21:08:08 <wli> mention k  =  gets (IntMap.lookup k) >>= flip unless work . isNothing seems like it should be writable in a sexier way.
21:09:18 <MyCatVerbs> wli: mention k = gets (IntMap.lookup k) >>= (`unless` work) . isNothing -- for starters?
21:09:29 <Gracenotes> (Just _) <- gets blah; work
21:09:40 <Gracenotes> w/ do
21:10:30 <wli> Gracenotes: That throws pattern match exceptions on match failures.
21:11:05 <kerlo> @free x :: a -> b
21:11:05 <lambdabot> g . x = x . f
21:11:23 <edwardk> @free const :: a->b->a
21:11:23 <lambdabot> f . const x = const (f x) . g
21:11:29 <steveklabnik> hello #haskell. I've been thinking about my problem for the last few hours, and I'm a bit stuck. I have a feeling that I'm just overcomplicating things... I have a function, f :: Int -> Int -> IO (). I want to apply it from all combinations of 0 .. n, for both arguments. Like a square, with (x,y) pairs. I was trying to do it by mapping f over [0 ..n] to create a list of partially applied functions, and then mapM_-ing those functions over th
21:11:32 <kerlo> @free const.
21:11:33 <lambdabot> Extra stuff at end of line
21:11:38 <kerlo> @free .const.
21:11:38 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
21:12:02 * kerlo raises an eyebrow by roughly 25 decibels.
21:12:06 <MyCatVerbs> steveklabnik: you got cut off at "and then mapM_-ing those function over th..."
21:12:12 <Gracenotes> wli: oh. hm. I thought pattern-matching-do-failure worked nicer than that
21:12:20 <edwardk> @free map_mapEither :: (a->b) -> (c->d) -> Either a c -> Either b d
21:12:21 <lambdabot> g . p = q . f => k . f1 = f2 . h => $map_Either g k . map_mapEither p f1 = map_mapEither q f2 . $map_Either f h
21:12:33 <MyCatVerbs> steveklabnik: your approach sounds sound. There are two nice says of doing it.
21:12:33 <steveklabnik> MyCatVerbs: damn. Basically, that won't work, and i've done some reasearch, and i still can't figure it out.
21:12:52 <kerlo> @free callCC :: ((a -> b) -> a) -> a
21:12:52 <lambdabot> (forall p q. g . p = q . f             =>              f (h p) = k q) => f (callCC h) = callCC k
21:13:26 <JsutiN> > [ x + y | x <- [0..2], y <- [0..2] ]
21:13:27 <lambdabot>   [0,1,2,1,2,3,2,3,4]
21:13:52 <edwardk> @. pl djinn (a -> b -> c) -> (a -> b) -> a -> c
21:13:52 <MyCatVerbs> mapM_ (\j -> mapM_ (\i -> f i j) [1..n]) [1..n] -- should work, I think.
21:13:53 <lambdabot> f = ap
21:14:18 <FunctorSalad> you know there is a program "ftshell" on hackage for free theorems ;)
21:14:28 <kerlo> > let roll x = x ++ map (+1) x in 0 : concat (iterate roll [1])
21:14:29 * edwardk reduces the spam
21:14:30 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
21:14:32 <FunctorSalad> it also has extra features like telling you about strictness and stuff
21:14:34 <kerlo> Yay.
21:14:36 <MyCatVerbs> @type \f n -> mapM_ (\j -> mapM_ (\i -> f i j) [1..n]) [1..n]
21:14:37 <lambdabot> forall a (m :: * -> *) b. (Monad m, Enum a, Num a) => (a -> a -> m b) -> a -> m ()
21:14:53 <wli> @type let m `when'` p = (flip when m . p =<<) in when'
21:14:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m () -> (a -> Bool) -> m a -> m ()
21:15:02 <kerlo> Trick question: What's the average output value of that sequence?
21:15:04 <edwardk> i just wanted to show a couple of non-trivial examples
21:15:31 <kerlo> Tricky question: If that sequence is n, then does the series 1/n converge?
21:15:37 <FunctorSalad> I'm just wondering what that program means by "relation" on a type
21:15:41 <steveklabnik> MyCatVerbs: ahh, that looks like exactly what I was trying. Many thanks. At least my idea was correct... I was unsure if I was just going about it in a totally terrible way.
21:15:44 <MyCatVerbs> steveklabnik: that's the first one. The other, IMO nicer way, is to generate all pairs with a list comprehension (or, Hell, use the list monad for fun ;P), and then pass that to mapM_.
21:15:46 <FunctorSalad>  /pair of types
21:15:52 <kerlo> > let roll x = x ++ map (+1) x in scanl (+) 0 (map (1/) (0 : concat (iterate roll [1])))
21:15:53 <lambdabot>   [0.0,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinit...
21:16:08 <kerlo> > let roll x = x ++ map (+1) x in scanl (+) 0 (map (1/) (concat (iterate roll [1])))
21:16:09 <lambdabot>   [0.0,1.0,2.0,2.5,3.5,4.0,4.5,4.833333333333333,5.833333333333333,6.33333333...
21:16:31 <kerlo> > let roll x = x ++ map (+1) x in (scanl (+) 0 (map (1/) (concat (iterate roll [1])))) !! 10000
21:16:32 <MyCatVerbs> @type \f n -> mapM_ (curry f) [ (x,y) | x <- [1..n], y <- [1..n] ]
21:16:33 <lambdabot>   1702.8937340437199
21:16:33 <lambdabot> forall b c t. (Enum t, Num t) => (((t, t), b) -> c) -> t -> b -> ()
21:16:34 <steveklabnik> MyCatVerbs: ahh. Is either way considered 'better', or is this the kind of thing that doesn't really seem to come up often?
21:16:43 <kerlo> I'm guessing it doesn't converge, then.
21:17:10 <kerlo> Heck, now that I think, its divergence couldn't be much more trivial.
21:17:22 <MyCatVerbs> steveklabnik: it's a matter of taste. I just gave both versions - wouldn't you agree that the latter is much clearer and easier to read?
21:17:32 <edwardk> hrmm, is there a canonical Min and Max monoid around?
21:17:52 <wli> What's a Min and Max monoid supposed to be?
21:18:07 <edwardk> er canonical Min and Max monoids ;)
21:18:07 <MyCatVerbs> edwardk: for some reason there isn't one in Data.Monoid.
21:18:10 <Gracenotes> there's none in the base libraries
21:18:13 <steveklabnik> MyCatVerbs: yeah, I probably would. especially since pairs are what I'm after. Thanks.
21:18:49 <edwardk> instance (Ord a, Bounded a) => Monoid (Min a) where mempty = Min maxBound; Min a `mappend` Min b = Min (a `min` b)
21:18:52 <edwardk> or something like that
21:18:54 <MyCatVerbs> steveklabnik: it's more or less the same as any programming language - up until you find that it's running too slow and you need to optimize, the only thing you should really be worrying about is how clear it is to a reader. ^_^
21:19:13 <MyCatVerbs> steveklabnik: no worries. Happy hacking. ^^
21:19:19 <edwardk> MyCatVerbs k. i'll just add Data.Monoid.Ord or something to my monoid package
21:20:06 <edwardk> with a couple of other newtypes that add a maximum element or minimum element if it isn't present.
21:20:43 <edwardk> hrmm Maybe already effectively adds a minimum element right?
21:20:53 <edwardk> > Just 2 > Nothing
21:20:55 <lambdabot>   True
21:21:19 <edwardk> so just a priority monoid with infinity is needed i guess
21:21:21 <Gracenotes> > Just minBound > Nothing
21:21:22 <lambdabot>   True
21:21:25 <kadaver> optimize first, make your program readable when someone has to read it the first time, just my 2 cents
21:21:28 <Gracenotes> doesn't even require an instance :)
21:22:01 <edwardk> gracenotes: well, thats not a monoid i can use for Min or Max though
21:22:11 <kadaver> imouttayourmonads for now on btw
21:22:17 <edwardk> here is where i curse haskell's lack of BoundedAbove and BoundedBelow ;)
21:22:34 <kadaver> " since remote method/function calls become way harder" in haskell that is, how is that solved? data.dynamic?
21:23:55 <Gracenotes> BoundedToTheLeft
21:24:25 <Gracenotes> or BoundedToTheCross, for the religiously inclined :\
21:24:46 <kadaver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSoundFile <- can thsat be used formp3decoding?
21:26:49 <dolio> > Just undefined > Nothing
21:26:51 <lambdabot>   True
21:27:42 <Gracenotes> > Just $! undefined > Nothing
21:27:43 <lambdabot>   * Exception: Prelude.undefined
21:30:19 <dons> kadaver: its a binding to libsndfile isn't it?
21:30:24 <dons> so it can do whatever libsndfile does
21:30:33 <dons> btw .. we should have a binding to some mp3 decoder
21:30:41 <dons> and video playback too, fwiw
21:30:58 <TomMD> Or native code...
21:31:49 <kadaver> yes
21:31:54 <dons> for those with the  time
21:32:24 <kadaver> dons: you use ffi for your player?
21:32:34 <kadaver> how hard is video playback?
21:33:14 <dons> depends on the api i guess
21:33:27 <gwern> video playback, from the complexities I've seen in the past, is apparently brutally difficult
21:33:58 <gwern> just the legal issues cross my eyes, and I do wikipedia as a hobby
21:34:55 <dons> ffi , and let someone else work that out
21:35:52 <gwern> no kidding. anything else is a major time and effort sink. gotta be careful what projects to target
21:37:46 <edwardk> these look ok? http://comonad.com/haskell/lexical-monoids/dist/doc/html/lexical-monoids/Data-Monoid-Ord.html
21:38:25 <edwardk> only bothered with priority one way, couldn't see a huge case for the dual
21:44:21 <amz> ok, so... quick question... if I have a register-syntax structure (e.g. data Foo = {a :: String, b :: String}), and I have an object called foo1, and want to make a copy of it called foo2 while changing 'a', is that supposed to be foo2 = Foo {a = "blah"} foo1?
21:44:53 <dolio> foo2 = foo1 {a = "blah"}
21:45:14 <amz> ah, thanks :)
21:46:53 <amz> on a related question, is it possible to make that "a" be a variable?
21:47:00 <ddarius> "register-syntax structure"  That's a new one by me.
21:47:04 <amz> e.g., depending on a parameter I get on the function, I will update either field 'a' or 'b'
21:47:19 <amz> ddarius: sorry, still a noob, probably getting the names all wrong :D
21:47:57 <wli> edwardk: I can't say yes or no. I don't understand the idea behind the code, never mind the code itself.
21:49:10 <Gracenotes> @. type run text$(++")").("("++).intercalate",".take 5.drop 1.iterate("(.)"++)$[]
21:49:12 <lambdabot> forall b c a b1 c1 a1 a2 a3 b2 c2 a4 a5 a6 b3 c3 a7 b4 c4 a8 b5. ((b -> c) -> (a -> b) -> a -> c, (a2 -> b1 -> c1) -> a2 -> (a1 -> b1) -> a1 -> c1, (b2 -> c2) -> (a3 -> a4 -> b2) -> a3 -> a4 -> c2, (
21:49:12 <lambdabot> a5 -> a6 -> b3 -> c3) -> a5 -> a6 -> (a7 -> b3) -> a7 -> c3, (b5 -> c4) -> (b4 -> b5) -> (a8 -> b4) -> a8 -> c4)
21:49:15 <jedai> amz: No, you can't, record syntax sucks in Haskell
21:49:29 <edwardk> wli: the monoids there?
21:49:47 <jedai> amz: everyone agree and there's a dozen proposal to improve things but nobody is sure which would be best
21:49:52 <amz> I see, hehe
21:49:53 <wli> edwardk: The lexical monoid affair.
21:50:08 <wli> jedai: Example of an improvement proposal?
21:50:29 <jedai> amz: There's still "Functional references" or "semantic editors" whatever you want to call them, they're pretty cool
21:51:19 <jedai> wli: I think you can find some of them on the GHC dev wiki, if not, haskell-cafe should have some mythic threads on the subject
21:51:39 <jedai> amz: And they support what you're talking about
21:51:55 <edwardk> foo1 { a = "blah" }
21:52:00 <wli> I didn't think records were that bad.
21:52:01 <amz> well, I'll take a look into them eventually, I guess
21:52:04 <edwardk> oh whoa, i was way scrolled back
21:52:19 <amz> for now, it's tricky enough to get the basic syntax right
21:52:26 <amz> edwardk: are you the same edwardk of rizon?
21:52:30 <jedai> wli: They're not really bad, they're just way less useful than they could be
21:53:03 <wli> Fishing through the ghc dev wiki.
21:53:13 <jedai> wli: especially accessors/mutators aren't first class, which is not cool in the Haskell book
21:53:50 <edwardk> amz: given the fact that i'm not familiar with that name, probably not ;)
21:54:06 <amz> it's another irc networ
21:54:07 <amz> *network
21:54:28 <edwardk> not me. i'm usually here or efnet
21:54:32 <wli> jedai: I've no idea what first class accessors and mutators would be. What's a good search key for the wiki?
21:54:47 <gwern> @quote shivers
21:54:47 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
21:54:50 <gwern> @quote Olin
21:54:51 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
21:54:56 * wli is on efnet too.
21:54:59 <gwern> @quote Olin
21:54:59 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
21:55:07 <gwern> what, no olin shivers quotes?
21:55:45 <jedai> wli: a simple example is what amz wanted, express simply that you want to change one field or another (odf the same type) with the same value depending on the value of a bool
21:56:19 <Gracenotes> @quote python
21:56:19 <lambdabot> slava says: I will continue not using Python just as I have been not using it for the last 10 years.
21:56:28 <Gracenotes> indeed
21:56:42 <gwern> it's a pity slava isn't a haskeller. he's as productive as dons
21:57:17 <jedai> wli: with first class mutators, you should be able to write an expression that returns the mutator for field or field b depending on the test result, instead you have o repeat yourself and use record syntax two times
21:57:32 <Nafai> gwern: Heh.  No kidding.
21:57:50 <gwern> Gracenotes: ever read the acknowledgements to the scsh manual?
21:58:18 <wli> jedai: Okay, essentially some sort of mutator function that gets automatically defined by the type decl.
21:58:34 <jedai> wli: another thing that bugs many people is the fact that two datatypes in one module can't have the same field names, that means you sometimes have to use artificial names
21:59:07 <kadaver> is factor an acdemic language or his personal project?
21:59:21 <jedai> wli: right, you can get something close (and actually pretty cool) with "functional references" and using template haskell you even can generate them automatically
21:59:43 <Nafai> kadaver: Personal project, and very practical
21:59:43 <Gracenotes> gwern: no... why?
22:00:05 <juhp> Gracenotes: cos they are pretty funny... :)
22:00:21 <jedai> wli: Well anyway, THE right solution remains elusive
22:00:28 <Gracenotes> man scsh is pretty not-fruitful on Ubuntu :x\
22:00:48 <wli> jedai: I don't see anything in the wiki.
22:01:27 <jedai> wli: It's especially annoying when you have to update a value in a record nested in another record nested in ...
22:01:30 * juhp tries .net ;)
22:01:31 * Gracenotes waits for hsh
22:01:41 <juhp> Gracenotes: http://www.scsh.net/docu/html/man.html
22:02:11 <gwern> Gracenotes: scsh last I heard had deep 32-bit related problems
22:02:21 <Gracenotes> well then. :x
22:02:33 <gwern> also, hsh is just utilities for interfacing with and mimicking shell functionality
22:02:37 <gwern> it's not an actual shell
22:02:38 <Cale> hsh exists, but it's a library
22:02:43 <Cale> yeah
22:02:54 <juhp> we need one :)
22:02:54 <gwern> shsh is an actuall haskell shell, but it's too simple for actual interactive use
22:03:06 <gwern> not until we have a value-added proposition
22:03:08 <pumpkin> http://developers.slashdot.org/article.pl?sid=09/03/22/193205 mmm
22:03:11 <wli> jedai: What should I search for in the wiki?
22:04:25 <jedai> wli:  http://www.haskell.org/haskellwiki/Extensible_record
22:05:05 <gwern> Gracenotes: shivers has a rep for that kind of humor
22:05:17 <jedai> wli: You have some good links in there
22:05:31 <gwern> @remember OlinShivers They look at me funny; they think I twitch a lot. I'm not twitching. I'm controlling my impulse to snag my 9mm Sig-Sauer out from my day-pack and make a few strong points about the quality of undergraduate education in Amerika.
22:05:31 <lambdabot> I will remember.
22:06:08 <gwern> @remember OlinShivers Oh, yes, the *acknowledgements*. I think not. I did it. I did it all, by myself.
22:06:08 <lambdabot> Done.
22:07:30 <Gracenotes> @quote remember
22:07:31 <lambdabot> dcoutts says: remember, if it's not on hackage it doesn't exist!
22:07:50 * Gracenotes instinctively checks his nose
22:07:58 <jedai> wli: some stuff under http://www.haskell.org/haskellwiki/Record_access too
22:08:00 <gwern> I never can remember who originally coined that, me or dcoutts
22:08:42 <wli> jedai: That's probably more directly relevant. The extensible record affairs are a bit stronger medicine.
22:10:29 <juhp> @remember OlinShivers Who should I thank? My so-called ``colleagues,'' who laugh at me behind my back, all the while becoming famous on my work? My worthless graduate students, whose computer skills appear to be limited to downloading bitmaps off of netnews? My parents, who are still waiting for me to quit ``fooling around with computers,'' go to med school, and become a radiologist? My department chairman, a manager who gives one n
22:10:30 <juhp> ew insight into and sympathy for disgruntled postal workers?
22:10:30 <lambdabot> Okay.
22:11:15 <dolio> That didn't work so well.
22:11:19 <juhp> no
22:11:23 <juhp> ah well
22:11:36 <juhp> might have guessed
22:12:04 <juhp> probably should have split it up
22:13:11 <jedai> wli: well that's part of a whole, one of the reason that no proposal have been implemented is that there are several issues to resolve around records
22:13:23 <wli> jedai: That sort of stuff looks better to program in that what I'm using for core exprs in this mini-interpreter.
22:13:55 <wli> jedai: (Which is essentially Haskell-like record access.)
22:14:21 <wli> jedai: What are the several issues to resolve around records?
22:14:42 <edwardk> my brain just exploded. i need a fingertree of fingertrees
22:14:58 <jedai> wli: Well you have the extensibility, the name conflicts and the field modification/access syntax
22:15:02 <edwardk> rather using one of them in the monoid for the other
22:16:42 <jedai> wli: So ideally you would like a proposal that would handle all of that and in the meantime you don't want to implement a proposal that resolve one of the issue but may make another more complex
22:16:52 <wli> jedai: Okay, so it sounds like my mini-interpreter/mini-language do something on the extensibility front, have no coherent plan on the name conflict front, and is pretty much ignoring syntactic sugar beyond something of an abbreviation for the AST's.
22:21:50 <wli> jedai: The name conflict front could be troublesome since I assume the existence of a solution to that in conjunction with extensibility somewhere. I also presumed that the accessors and mutators were "just syntax" and didn't require much special to do in some fuller form.
22:22:47 <wli> jedai: By and large my focus was on extensible variants with records as something of an afterthought.
22:23:49 <wli> jedai: e.g. the record update/extension stuff I use allows multiple constructors to be specified for each set of field assignments.
22:24:42 <wli> jedai: And even a wildcard constructor to assign the label regardless of the specific constructor.
22:33:45 <rovar> is there some option i should specify to be able to use exceptions? I'm seeing
22:33:47 <rovar>     Ambiguous type variable `b' in the constraint:
22:33:48 <rovar>       `GHC.Exception.Exception b'
22:33:50 <rovar>         arising from a use of `catch'
22:34:15 <jedai> rovar: What version of GHC ?
22:34:28 <rovar> 6.10.1
22:35:00 <dons> --constraint='base<4'
22:35:05 <jedai> rovar: With catch you should specify what kind of Exception you want to catch
22:35:10 <dons> or else import Control.OldException
22:35:15 <rovar> ah
22:35:42 <jedai> or use the old exception system (from 6.10.1 on we have a new system of exception
22:36:16 <rovar> i'm not sure which exceptions may arise
22:39:26 <jedai> That's strange, the documentation for catch() seems to say that it can catch anything, what did you do exactly ?
22:40:01 <jedai> I guess I should reread the paper on extensible exceptions
22:40:31 <rovar> listenLoop (hGetLine handle) chan
22:40:33 <rovar>             `catch` (const $ return ())
22:40:34 <rovar>             `finally` hClose handle
22:42:58 <jedai> rovar: I think you probably should use withFile there
22:43:36 <sjanssen> rovar: the reason this doesn't work by default is that it is usually not a good idea to catch all exceptions
22:43:37 <rovar> i see what you're saying
22:43:40 <jedai> withFile file ReadMode $ \h -> listenLoop (hGetLine h) chan
22:44:11 <rovar> i made a catchIO :: IO a -> (IOException -> IO a) -> IO a
22:44:13 <rovar> as well
22:46:35 <jedai> rovar: Also rather than catch, you just want to ignore anything that may happen so try is probably more appropriate
22:47:24 <rovar> i would like to disconnect on socket close
22:47:25 <jedai> something like : try $ withFile file ReadMode $ \h -> listenLoop (hGetLine h) chan
22:48:03 <rovar> will withFile close the handle under any circumstances?
22:48:48 <jedai> rovar: Yes, it's the objective, it's a partial application of bracket
22:49:22 <rovar> withFile docs claim that it opens the file using openFile
22:49:55 <rovar> this is an already open socket
22:50:08 <jedai> rovar: if that is not what you want then finally is ok
22:50:42 <jedai> try $ listenLoop (hGetLine h) chan `finally` hClose h
22:50:54 <rovar> it's a good idea though. I think I'll make a withHandle or withOpenFile  that does the same
22:52:37 <rovar> but for now, it's time for sleep. Thanks for your help
22:58:09 <jedai> It appears that the documentation of catch() in Control.Exception hasn't been updated though it doesn't have the same semantics now ?
22:58:55 <jedai> to get the old semantic you must use something like `catch` (\e :: SomeException -> handler e), no ?
23:04:37 <mjonsson> Gracenotes, Cale: the Category Theory book by S. Awodey is great! Thanks.
23:04:52 <Gracenotes> :)
23:05:37 * mjonsson bed
23:09:54 <wli> conal: You there?
23:11:32 <b\6> on larger projects, i keep getting import cycles. is there a general strategy to avoid them?
23:13:50 <wli> b\6: Just write the bootstrap files.
23:14:21 <b\6> wli: hmm, ok.
23:14:27 <ski> (what's the title of that book ?)
23:16:00 <rittyan1> Hi, please help me to fix types description for the following short function: http://pastebin.ca/1368833
23:16:00 <pervonisse> I'm going to try making my own web framework in haskell (just for fun). And I'm wondering what would be the best way to deploy it, mod_haskell in apache or something else?
23:16:17 <rittyan1> fastcgi
23:16:35 <pervonisse> okay, thanks
23:17:03 <rittyan1> this way your framework is server-independant
23:17:11 <rittyan1> and most servers support fastcgi
23:17:36 <pervonisse> I see
23:17:57 <pumpkin> rittyan1: what's wrong with it?
23:18:04 <rittyan1> pumpkin, it doesn't compile :(
23:18:09 <jedai> rittyan1: You need a Eq constraint because of (/=) but really you don't need it
23:18:19 <rittyan1> oh hi jedai
23:18:19 <jedai> You should rewrite it :
23:18:22 <ski> rittyan1 : did you try removing the type signature and see what GHCi/Hugs infers the type to be, yet ?
23:18:47 <rittyan1> ski, oops, no
23:18:51 <ski> rittyan1 : also, you should match on `Nothing' (or `Just') rather than using `(/=)'
23:20:20 <jedai> rittyan1: http://pastebin.ca/1368835
23:21:10 <pumpkin> the type makes more sense, too
23:21:50 <jedai> pumpkin: Yes, no reason to keep the Maybe when we know it will always be Just
23:22:23 <rittyan1> thank you!
23:23:51 <ski> (there might be some reason, i suppose)
23:24:06 <rittyan1> jedai, btw thank you for ruining my monday at work (for my employers) :-D /me will be playing more with the code
23:25:03 <jedai> There's also filter' f = mapMaybe (\x -> liftM ((,) x) $ f x)
23:25:36 <jedai> Not exactly the same and possibly slower (or faster)
23:25:52 <jedai> Oops :
23:26:03 <jedai> filter' f = mapMaybe (\x -> fmap ((,) x) $ f x)
23:26:07 <rittyan1> jedai, I want that filter to know what regex has matched my log line
23:26:48 <rittyan1> (if you still remember my code)
23:26:52 <Petrosian> @pl \x -> fmap ((,) x) $ f x
23:26:53 <lambdabot> liftM2 fmap (,) f
23:26:54 <rittyan1> s/my/our/ (:-D)
23:27:08 <jedai> I remember
23:27:48 <jedai> I would propose a combination of find and this filter'
23:28:28 <rittyan1> this = with mapMaybe or with my Maybe stuff?
23:28:38 <jedai> something like filter' (find (=~ query) patterns)
23:28:50 <rittyan1> ah
23:29:21 <jedai> rittyan1: It's the same (the performance is probably equivalent too), choose the one you prefer (I prefer the mapMaybe one myself but well...)
23:30:19 <rittyan1> jedai, okay, thanks... that filter with find looks neat (reading docs of Data.List)
23:31:26 <ski> @type \f x -> fmap ((,) x) (f x)
23:31:27 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a -> f a1) -> a -> f (a, a1)
23:31:33 <ski> @type \f -> id &&& f
23:31:34 <lambdabot> forall a c'. (a -> c') -> a -> (a, c')
23:31:57 <ski> mhm
23:32:25 <jedai> ski: You want to get the "Just" out from the pair, the fmap is there for this reason
23:32:58 <ski> @type \f -> runKleisli (arr id &&& Kleisli f)
23:32:59 <lambdabot> forall a (m :: * -> *) c'. (Monad m) => (a -> m c') -> a -> m (a, c')
23:33:03 <ski> .. not quite
23:33:29 <pumpkin> it'd be nice to be able to get rid of that runKleisli and Kleisli stuff
23:33:41 <ski> get rid, how ?
23:33:51 <pumpkin> no clue, just saying it would be nice :)
23:33:56 <ski> jedai : what is that reason ?
23:34:10 <pumpkin> I know why it's needed, just saying it isn't as smooth as it could be :)
23:34:17 <jedai> ski: Getting the Maybe outside of the pair ?
23:34:34 <ski> yes, but why ?
23:34:41 <ski> why was that desired ?
23:34:44 <dolio> @type let strength (a,m) = fmap ((,) a) m in \f -> id &&& f >>> strength
23:34:46 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> f a1) -> a -> f (a, a1)
23:34:59 <jedai> ski: because that's the type mapMaybe want
23:35:32 <jedai> ski: And rittyan wanted something that also conserved the original element
23:36:07 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength (a,fb) = fmap ((,) a) fb
23:36:09 <lambdabot>  Defined.
23:36:51 <ski> @let graph :: (a -> b) -> (a -> (a,b)); graph f = id &&& f
23:36:52 <lambdabot>  Defined.
23:37:08 <ski> @let cograph :: (a -> b) -> (Either a b -> b); cograph f = f ||| id
23:37:09 <lambdabot>  Defined.
23:37:36 <ski> @type let filter' f = mapMaybe (\x -> fmap ((,) x) $ f x) in filter'
23:37:37 <lambdabot> forall a a1. (a -> Maybe a1) -> [a] -> [(a, a1)]
23:38:57 <ski> (jedai : i just haven't seen where rittyan1 wanted the `Just's to be removed ..)
23:39:16 <rittyan1> (maybe I don't know about it yet)
23:39:45 <jedai> ski: He didn't originally, but they don't add any information
23:40:05 <jedai> they take space and make looking at the value more complex...
23:40:29 <ski> surely `Just x' contains more information than `x'
23:40:43 <jedai> I assume he was trying to get his filter' to work and would have removed it later
23:40:49 <jedai> ski: No ?
23:40:49 <rittyan1> is that Just just indicates that it might be Nothing otherwise?
23:40:52 <ski> (namely the information that the value was not (but might have been) `Nothing')
23:41:07 <jedai> ski: Yes, but here it can't be Nothing...
23:41:22 <rittyan1> jedai, why it can't... it can in my case
23:41:24 <rittyan1> as I can see it
23:41:28 <ski> but if you combine the list with other lists, it may be `Nothing'
23:41:48 <jedai> rittyan1: It's a filter, it suppress every value for which f returns Nothing
23:41:56 <rittyan1> ah!
23:42:06 <rittyan1> true
23:42:13 <jedai> rittyan1: At least that's what you're original function was doing
23:42:19 <rittyan1> yes
23:42:36 <jedai> ski: I worked with him on his script, I don't think that's a possibility
23:43:23 <rittyan1> My intention: I have a list of regular expressios and list of strings... function passed to filter' checks one string at a time and returns regex that matched it, or Nothing if nothing matched
23:43:26 <rittyan1> that is all I wanted
23:43:38 <jedai> ski: And it don't seem to make much sense to keep all those useless Just for the remote possibility that the result be combined with a [(Maybe b, a)] list that can contain Nothing
23:43:39 <ski> jedai : do you mean more than just that  filter'  function ?
23:43:53 <jedai> ski: Yes
23:44:09 <c_wraith> rittyan1: use filter and listToMaybe?
23:44:18 <wli> Holy cow, I just figured out what I was doing wrong with my algebraic expression simplifier.
23:44:23 <c_wraith> Um, that ? isn't part of the function name. :)
23:44:48 <pervonisse> I'm trying to install fastcgi via "cabal install fastcgi", but it fails and complains about a missing "libcfgi.so" file. (But I have compiled and installed fastcgi from source)
23:44:48 <ski> jedai : probably you're right that rittyan1 has no use for those `Just's .. my (pedantic) point is just that throwing it away is throwing information away
23:44:48 <jedai> c_wraith: find already does the composition of filter and listToMaybe
23:45:13 <ski> wli : which was ?
23:45:38 <jedai> ski: I disagree, the resulting list doesn't have any more information with the Just
23:45:53 <jedai> ski: since it can't contain Nothing
23:46:31 <pervonisse> ah nevermind I got it
23:47:11 <jedai> ski: There is a direct bijection between the results of a filter' that keep those Maybe and one that doesn't so how could any information have disappeared ?
23:48:07 <wli> ski: The numerator and denominator can't be digested all at once. The way to go about it is to handle the linear case first where radicals appear in linear combinations with rational coefficients. Then find the basis (and minimal polynomial) by using the products of all the radicals raised to various powers less than the degree of the root as a basis to express raising that expression to sequentially higher powers until you find a linear dependence.
23:48:08 <ski> there's only such a bijection if you consider the *subtype* of the type involved, being the values that can be produced by those functions
23:49:09 * ski notes that we are talking about different things ..
23:49:14 <wli> ski: Once you have that in hand, you can invert rational linear combinations of radicals, so you do that for the denominator first, invert it, multiply the numerator by that inverse, and repeat the process to canonically express the whole.
23:49:18 <jedai> ski: Right, which is what we're considering, obviously the type [(Maybe b, a)] and [(b, a)] don't contain the same amount of information but for the results of filter' they do
23:49:55 <ski> yes, i agree with that (probably i should have stated more clearly what i was after ..)
23:50:34 <rittyan1> okay and... probably I  missed something... how to remove Justs?
23:50:54 <jedai> rittyan1: The Just are removed in both version I gave you
23:51:08 <ski> case blah of Nothing -> loop xs; Just y -> bleh y : loop xs
23:51:24 <rittyan1> jedai, ok, thank you
23:53:17 <rittyan1> I will try to understand that fmap ((,)..) stuff when I get to work
23:53:18 <ski> wli : and what were you doing wrong ?
23:53:48 <wli> ski: Trying to take on the numerator and denominator all at once.
23:54:41 <jedai> rittyan1: The idea is that Maybe is a Functor (a typeclass in Haskell, also a concept from category theory for the same thing)
23:54:42 <ski> and this is in the context of division of already simplified expressions ?
23:55:08 <jedai> fmap is a function that works on Functor, it's type is
23:55:12 <jedai> @type fmap
23:55:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:55:33 <wli> ski: No, it's in the context of taking completely unsimplified radical expressions and reducing them to canonical forms in which equality testing is possible.
23:55:51 <jedai> In our case it's (a -> b) -> Maybe a -> Maybe b
23:56:11 <jedai> > fmap (+5) (Just 3)
23:56:12 <lambdabot>   Just 8
23:56:20 <ski> @type let costrength :: Functor f => f (Either a b) -> Either (f a) b; costrength = costrength in \f -> costrength >>> cograph f
23:56:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (f a -> b) -> f (Either a b) -> b
23:56:22 <jedai> > fmap (+5) Nothing
23:56:23 <lambdabot>   Nothing
23:57:38 <wli> I'm not entirely sure how to get things like (5+2*6^(1/2))^(1/2) reduced to 2^(1/2) + 3^(1/2)
23:58:34 <wli> Never mind the analogues for rational/algebraic function fields.
23:59:09 <rittyan1> jedai, thanks, I will read about/play with it more
23:59:15 <rittyan1> as for now consider me being gone o/
