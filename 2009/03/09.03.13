00:00:27 <Axman6> well, i've made a moddest improvement to binary-trees :\
00:00:50 <Gracenotes> mmorrow: you too can experience the magic of recursion!
00:01:01 <Axman6> but bloody hell it uses a lot of RAM
00:01:15 <pumpkin> how much?
00:01:21 <Axman6> 1GB+
00:01:26 <pumpkin> wow
00:01:31 <Axman6> that's the current one any my new one
00:01:41 <Gracenotes> how fast is it?
00:02:49 <Axman6> well, when i run with N=20, it goes from 32 to 30 seconds
00:03:07 <Axman6> something seems very wrong, it should not be using tis much RAM i think
00:03:35 <pumpkin> Axman6: w00t
00:03:56 <Axman6> hmm, on the shootout machine, it only uses just under 400MB
00:04:01 <Axman6> with N=40
00:04:44 <pumpkin> Axman6: I ended up shaving 27 seconds down to 25 on my linux x86_64 machine :P
00:04:45 <Axman6> quickly fills up two gigs on my machine
00:04:49 <pumpkin> but it's epicly faster on mac os at least ;)
00:04:56 <Axman6> heh, yeah
00:06:33 <pumpkin> well, now I know I need to work harder on parallelizing stuff on mac os :P
00:08:13 <Axman6> ow, just scratch sunburn :(
00:09:14 * ivanm passes Axman6 some Aloe Vera lotion
00:09:19 <Axman6> ta
00:09:44 <Axman6> pumpkin: you have a linux machine to test things on?
00:09:52 <pumpkin> yeah, a xen instance
00:10:12 <Axman6> reckon you could try out http://shootout.alioth.debian.org/u64q/benchmark.php?test=binarytrees&lang=ghc&id=2 and see how the RAM usage does?
00:14:22 <beelsebob> Axman6: 182MB
00:14:37 <Axman6> beelsebob: on what machine
00:14:38 <Axman6> ?
00:14:47 <Axman6> and which N
00:14:49 <Pip> Which language is useful and safe ?
00:14:54 <beelsebob> my MacBook, and 20
00:15:00 <beelsebob> Pip: type @faq
00:15:02 <Axman6> beelsebob: try 40
00:15:28 <Pip> beelsebob, where is it ?
00:15:51 <pumpkin> Pip: haskell is useful and safe!
00:16:10 <Pip> Okay
00:16:40 <Axman6> @faq can haskell be super useful and super duper safe?
00:16:40 <lambdabot> The answer is: Yes! Haskell can do that.
00:16:50 <beelsebob> Axman6: 2GB
00:16:50 <Axman6> yep, it's in the FAQ
00:16:52 <Axman6> >_>
00:17:12 <Axman6> beelsebob: yeah, i think something's up here :\
00:17:21 <beelsebob> why?
00:17:30 <beelsebob> nothing looks up to me
00:17:35 <Axman6> well, on the shootout machine, it uses less than 1/4 of that
00:17:41 <beelsebob> with N=20
00:17:55 <beelsebob> in fact, it used half the ram here for N=20
00:17:59 <Axman6> oh it is 20, ha! awesome
00:18:08 <Axman6> thanks man :P
00:18:12 <beelsebob> >.<
00:18:26 <Axman6> must've dyslexified the -N4 and 20 into -N2 40 :P
00:24:59 <kiris> BONUS: ping
00:25:46 <wli> Okay, I finished writing reduce even though it'll never work.
00:30:13 <Pip> BONUS, Hi
00:33:06 <Gracenotes> B-B-B-B-B-BONUS BREAKER
00:33:48 <wli> mmorrow: Well, I'm not really working with an AST per se. I think this already qualifies as a graph of sorts.
00:33:59 <pumpkin> ASDAG?
00:34:42 <wli> pumpkin: recursive let can introduce cycles
00:35:48 <Pip> Learn Your Haskell is pretty cool : )
00:35:49 <wli> mmorrow/pumpkin: http://pastebin.com/m18bca50a
00:35:57 <Pip> *You a
00:38:18 <wli> The reduce code is massively confused as to whether it's dealing with expressions already qualified with environments or not.
00:40:53 <wli> I'm not entirely convinced the environment business is the way to deal with it.
00:41:40 <wli> (BTW it should be lhs2TeX'able into a nice-looking doc.)
00:49:21 <blackpanda> Can any one help me to lean Haskell? just an introduction? I have just installed GHCi on Windows XP.
00:50:11 <Axman6> @where LYAH
00:50:12 <lambdabot> www.learnyouahaskell.com
00:50:15 <ivanm> you mean learn?
00:50:24 <Axman6> beelsebob: try that link above
00:50:29 <Axman6> uh, blackpanda, not beelsebob
00:50:38 <ivanm> @where RWH
00:50:39 <lambdabot> is http://www.realworldhaskell.org/blog/
00:50:41 <ivanm> @where YAHT
00:50:41 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
00:50:43 <ivanm> @where wikibook
00:50:44 <lambdabot> http://en.wikibooks.org/wiki/Haskell
00:50:52 <ivanm> blackpanda: or one of these links ;-)
00:50:54 <ivanm> @where tutorial
00:50:54 <lambdabot> http://www.haskell.org/tutorial/
00:50:57 <ivanm> or that one
00:50:58 <Axman6> start with either LYAH or RWH
00:51:57 <blackpanda> Thanks a lot for all.
00:52:33 <Axman6> blackpanda: also, stick around in here, we're very helpful when it comes to beginners :)
00:52:35 <Axman6> by far the most hekpful channel i've ever been in
00:52:40 <Axman6> helpful too
00:52:43 <pumpkin> don't believe him!
00:52:47 <pumpkin> he likes to eat babies
00:52:49 <wli> Hmm. If I'm reading this right, the only confusion is in the VarExpr case.
01:04:10 <|jedai|> @src maximum
01:04:10 <lambdabot> maximum [] = undefined
01:04:10 <lambdabot> maximum xs = foldl1 max xs
01:04:34 <|jedai|> Someone tell me again why this isn't foldl1' or at least foldr1 ?
01:04:48 <pumpkin> because it isn't in the report
01:04:59 <jedai> pumpkin: That's really too bad...
01:05:08 <jedai> foldl1 makes no sense here
01:05:33 <pumpkin> yeah, I say we break GHC's defaults away from h98 and enable a compatibility mode for people who really want it :)
01:05:37 <wli> I may need a totally different evaluation strategy. :(
01:05:39 <jedai> foldr1 with specialization for Int, Integer... to foldl1' would probably be better
01:06:45 <jedai> or just admitting that maximum is for strict max and letting people use foldr1 themselves if they have an unusual max
01:10:16 <Gracenotes> maximum does involve going through the whole list x.x
01:11:07 <pumpkin> but doing any foldl without ' is generally a bad idea
01:11:27 <pumpkin> foldr/foldl' should be the options, I think
01:11:35 <jedai> Gracenotes: Why ? if max isn't strict in its second argument like on Bool, there's no reason why you can't conclude without sifting though the whole list
01:12:04 <pumpkin> jedai: ?
01:12:08 <jedai> > foldr1 max [True..]
01:12:09 <lambdabot>   <no location info>: parse error on input `]'
01:12:18 <Gracenotes> that's just [True]
01:12:29 <wli> Except when foldl builds an infinite list from another infinite list...
01:12:30 <pumpkin> jedai: unless you have some sort of maxBound check, you need to check the entire list
01:12:33 <Gracenotes> that's just [True]
01:12:34 <jedai> > foldr1 max (repeat True)
01:12:36 <lambdabot>   * Exception: stack overflow
01:12:42 <Gracenotes> er, darn up arrow
01:12:54 <Gracenotes> pumpkin beat me to the punch again :O this time about maxBound
01:13:12 <jedai> pumpkin: exactly, on certain type you can have max lazy in its second argument
01:13:26 <pumpkin> so you'd have a specialized version for Bounded arguments?
01:13:37 <pumpkin> with different semantics from the other ones?
01:13:41 <Gracenotes> jedai: that assumes that Bounded is consistent with Ord
01:13:49 <Gracenotes> there's no guarantee that's that the case
01:13:53 <jedai> pumpkin: In this case foldr1 is better than foldl1 anyway, in any other case you want foldl1' not foldl1
01:13:57 <Gracenotes> although it would be ridiculous if it weren't
01:14:02 <Gracenotes> you still can't assume that :(
01:14:21 <wli> pumpkin: Any thoughts on the small interpreter?
01:14:32 <jedai> Gracenotes: I'm not speaking about Bounded, I'm just speaking about the cases where lazyness would be useful in maximum
01:14:47 <pumpkin> wli: haven't been following, what's your issue? :)
01:14:59 <pumpkin> (sorry, I have a short scrollback and no logs :/)
01:15:03 <jedai> Gracenotes: And my conclusion is that in those cases foldl1 don't make sense either
01:15:03 <Gracenotes> I can only think of that as being useful in max maxBound undefined, or something
01:15:19 <wli> pumpkin: No/bad/etc. design.
01:15:38 <jedai> Gracenotes: right, there are a certain amount of type like that
01:15:59 <Axman6> > foldl1 max [1,4,2,5,47,337,57,4572,457,2457,2548,3568,456825,7]
01:16:01 <lambdabot>   456825
01:16:06 <Axman6> > foldr1 max [1,4,2,5,47,337,57,4572,457,2457,2548,3568,456825,7]
01:16:07 <lambdabot>   456825
01:16:09 <pumpkin> jedai: it seems like a pretty big change to semantics for not much benefit, though
01:16:31 <pumpkin> (the bounded one, I agree with the foldr)
01:17:00 <jedai> pumpkin: I never professed any change to the semantic of Bounded/Ord
01:17:22 <jedai> just noted that foldl1 is never the good choice
01:17:33 <pumpkin> I thought you were saying to make it cut off prematurely if maxBound was encountered
01:17:54 <jedai> pumpkin: No, I was just saying that some max could do that
01:18:08 <Axman6> :t max
01:18:09 <lambdabot> forall a. (Ord a) => a -> a -> a
01:18:13 <jedai> It's up to the implementer of the Ord instance
01:18:55 <pumpkin> in that case it would need to be foldl(1 then
01:19:27 <pumpkin> as it would potentially terminate on infinite input
01:19:50 <jedai> pumpkin: No ? If it's foldl1 you still have to go through the whole list, with foldr1 it can finish early
01:19:58 <Gracenotes> > let max' GT _ = GT; max' a b = max a b in liftA2 (,,,) (foldl1 max') (foldr1 max') (foldl1 max) (foldr1 max) ([LT, GT, undefined])
01:19:59 <lambdabot>   Couldn't match expected type `[Ordering]'
01:20:15 <Gracenotes> > let max' GT _ = GT; max' a b = max a b in liftA4 (,,,) (foldl1 max') (foldr1 max') (foldl1 max) (foldr1 max) ([LT, GT, undefined])
01:20:16 <lambdabot>   Not in scope: `liftA4'
01:20:19 <jedai> pumpkin: You mean you think that you don't want maximum to finish on infinite lists ?
01:20:20 <Gracenotes> heh
01:20:26 <Gracenotes> > let max' GT _ = GT; max' a b = max a b in liftM4 (,,,) (foldl1 max') (foldr1 max') (foldl1 max) (foldr1 max) ([LT, GT, undefined])
01:20:28 <lambdabot>   (GT,GT,* Exception: Prelude.undefined
01:20:44 <pumpkin> jedai: oh yeah, sorry :)
01:20:59 <Gracenotes> > let max' GT _ = GT; max' a b = max a b in foldr1 max [LT, GT, undefined]
01:21:08 <pumpkin> wli: don't think I'd have much useful input :/
01:21:08 <lambdabot>   * Exception: Prelude.undefined
01:22:02 <Gracenotes> > let max' GT _ = GT; max' a b = max a b in foldl1 max' ([LT, GT, undefined] ++ repeat GT)
01:22:56 <Gracenotes> y halo thar
01:23:24 <Gracenotes> @botsmack
01:23:24 <lunabot>  :)
01:23:29 <lambdabot> :)
01:26:14 <Axman6>  Gracenotes try foldr if you want short circuiting
01:26:29 <Gracenotes> yes, i knowsw
01:26:51 <Gracenotes> odd that lambdabot didn't say the thread was killed though
01:29:40 <Gracenotes> ;o
01:30:18 <quicksilver> parse error on input `unsafe'
01:30:21 <quicksilver> that's odd.
01:30:24 <v0|d> is there an easy way to use hasktags alogn with cabal?
01:30:26 <v0|d> is there an easy way to use hasktags alogn with cabal?
01:30:31 <v0|d> my ~/.cabal haev packages packed, hasktags cant walk.
01:30:38 <quicksilver> is some extension/flag needed to permit unsafe foreign imports?
01:30:57 <quicksilver> foreign import  unsafe "gluErrorString" gluErrorString
01:31:03 <v0|d> or maybe a quick way to unpack all installed packs in ~/.cabal?
01:31:03 <v0|d>  
01:33:12 <quicksilver> ah, unsafe requires ccall
01:33:15 <quicksilver> this just insn't going to work.
01:33:18 <quicksilver> :(
01:33:50 <pumpkin> what are you trying to do?
01:34:03 <pumpkin> oh
01:35:03 <quicksilver> pumpkin: tehre is a bug in HOpenGL
01:35:09 <quicksilver> pumpkin: I'm trying to test a fix.
01:35:18 <pumpkin> ah :)
01:35:22 <quicksilver> pumpkin: I was trying to copy out the particular file, but it has dependencies on other non-exported modules
01:35:27 <quicksilver> it has turned out to be a stupid game.
01:35:35 <pumpkin> ah yeah
01:35:45 <quicksilver> so, I'm building it properly from source.
01:36:01 <quicksilver> how do I use "this copy of HOpenGL from this source directory here" ?
01:36:08 <quicksilver> (and ignore the system-wide copy
01:36:52 <c_wraith> ... it'd be so nice if cabal had an uninstall option
01:37:03 <pumpkin> ah
01:37:55 <quicksilver> c_wraith: it would, but ghc-pkg unregister does the trick.
01:38:00 <quicksilver> but that's not quite what I'm trying to do.
01:38:07 <pumpkin> except it doesn't really get rid of the files
01:38:07 <quicksilver> I'm not trying to choose between two installed versions.
01:38:16 <quicksilver> I'm wondering how to use a not-yet-installed package
01:38:16 <pumpkin> in fact, it doesn't at all
01:38:24 <quicksilver> (because I'm editing it)
01:38:43 <c_wraith> I ran into similar problems editing a library I'm working on.  It's in one package, and I have another package that uses it.
01:39:07 <quicksilver> c_wraith: did you find a solution?
01:39:11 <c_wraith> version numbers help
01:39:20 <c_wraith> increase the version number of the version you're working on
01:39:25 * quicksilver is reading "5.8 Packages" from the GHC docs
01:39:28 <c_wraith> and require that version number in your test code
01:39:34 <quicksilver> c_wraith: does that let me use an uninstalled package, though?
01:39:40 <c_wraith> No.
01:39:41 <quicksilver> or will I have to install it to use it
01:39:42 * quicksilver nods
01:39:43 <c_wraith> In my case, it was installed
01:40:42 <quicksilver> dcoutts: ping?
01:40:53 <c_wraith> you could name the package something else and install it.  then it wouldn't collide with future versions of HOpenGL
01:41:06 <c_wraith> but...  that solution *also* makes me wish for uninstall
01:43:44 <quicksilver> I'm clearly doing something wrong.
01:43:59 <quicksilver> runhaskell Setup.hs install --user gives Setup.hs: /usr/local: createDirectory: permission denied (Permission denied)
01:44:05 <quicksilver> but surely that's the point of --user ?
01:44:10 <quicksilver> not to put it in /usr/local.
01:44:37 <Saizan> you need to pass --user to configure
01:44:41 <quicksilver> I did.
01:45:00 * quicksilver runs 'clean' and tries again.
01:45:35 <quicksilver> at least this package only takes a few seconds to build.
01:45:59 <quicksilver> same error, after clean/configure --user/build/install --user
01:46:22 <pumpkin> maybe it's doing something custom in Setup?
01:46:30 <pumpkin> check if there are any hardcoded global paths in the file?
01:46:34 <igel> quicksilver: --prefix=`pwd`/dist
01:46:39 <quicksilver> nope : main = defaultMainWithHooks defaultUserHooks
01:47:17 <c_wraith> um.  If that's in Setup, why isn't it just using the simple config? >_>
01:47:18 <igel> and maybe the behaviour of ./setup.hs build is not the same as cabal build ?
01:47:32 <Saizan> no, it's the same
01:47:41 <Saizan> quicksilver: which package?
01:47:48 <quicksilver> Saizan: OpenGL
01:47:58 <quicksilver> I see lots of /usr/local paths in config.log and configure
01:48:22 <Saizan> that can be it
01:48:48 <quicksilver> where are local packages supposed to go? ~/.cabal?
01:49:01 <quicksilver> should I try --prefix=~/.cabal
01:50:46 <Saizan> it worked fine here
01:50:58 <igel> quicksilver: which cabal version are you using?
01:51:13 <Saizan> maybe it doesn't refresh the output of the configure script when you rerun configure?
01:51:28 <quicksilver> igel: Cabal-1.2.4.0
01:51:38 <quicksilver> Saizan: perhaps. I'll try a fresh unpack.
01:53:05 <quicksilver> Saizan: same error on a clean unpack.
01:53:39 <Saizan> heh
01:53:59 <Saizan> next thing i'd try is to upgrade Cabal
01:55:43 <quicksilver> right.
01:56:34 <quicksilver> right now im walking to work, will try in a mo
02:06:40 <alexlea> Workybob said you people have closures...
02:06:56 <pumpkin> is that the killer feature of a language these days?
02:07:14 <alexlea> hell if i know, he said you people would laugh,..he lied...i see no laughter
02:07:20 <pumpkin> :)
02:07:20 <Workybob> pumpkin: C has it, it must be good
02:07:33 <pumpkin> alexlea: I chuckled to myself
02:07:34 <osfameron> C doesn't have closures
02:07:51 <Workybob> osfameron: the next standard does
02:08:00 <alexlea> pumpkin: well then, good...Workybob's honor has been restored
02:08:01 <Workybob> it's the big new feature
02:08:09 <osfameron> which standard?
02:08:16 <pumpkin> c2045
02:08:25 <Workybob> lol
02:08:52 <Workybob> oh scratch that
02:08:57 <Workybob> it's was Objective-C that's gaining them
02:08:57 <osfameron> http://notes-on-haskell.blogspot.com/2008/09/closures-are-coming.html ?
02:09:03 <pumpkin> eww, objective c
02:09:04 <Workybob> I thought they were adding them to the C standard in general
02:09:28 <Workybob> pumpkin: Obj-C is really excellent for what it does
02:09:34 <Workybob> it's just the complete oposite of what I want to do
02:09:35 <Workybob> >.<
02:09:45 <pumpkin> it's just so ugly :) it feels like frankenstein's monster
02:09:49 <pumpkin> I don't really mind working with it
02:09:57 <pumpkin> but it makes me feel slightly dirty when I do
02:10:05 <Workybob> ugly?  I think it's rather beautiful in comparison to other C like languages
02:10:19 * osfameron sorta fancies learning ObjC or D
02:10:27 <idnar> Objective C feels like a bunch of macros dropped on top of C
02:10:30 <idnar> ...oh wait :P
02:10:30 <osfameron> but ObjC lives in a little Apple ghetto doesn't it still?
02:10:33 <Workybob> idnar: it was originally
02:10:35 <Workybob> it's not any more
02:10:38 <Workybob> osfameron: no
02:10:39 <pumpkin> c is a "compact" language, it's simple and as a language, rather elegant
02:10:46 <pumpkin> objc does feel like a bunch of macros dropped on top of c
02:10:49 <idnar> Workybob: yeah, I know
02:10:50 <Workybob> osfameron: in fact, even the cocoa apis are breaking out of that
02:10:51 <pumpkin> even if it isn't anymore :P
02:10:59 <pumpkin> the whole property stuff that made now
02:11:03 <pumpkin> just reinforced that feeling
02:11:09 <pumpkin> needing to explicitly @synthesize properties
02:11:13 <pumpkin> feels like stuffing a macro
02:11:18 <pumpkin> IMPLEMENT(property)
02:11:20 <pumpkin> or something :P
02:11:34 <osfameron> Workybob: ah, that's interesting.  Maybe some of those little mac-only apps will become useful cross-platform things
02:16:23 <mmorrow> wli: cool
02:16:42 <pumpkin> mmorrow goes to sleep for the night, wakes up, and types cool :P
02:16:43 <mmorrow> wli: ok, so i see what you're doing now
02:16:52 <mmorrow> pumpkin: you know it!
02:16:59 <pumpkin> :)
02:19:35 <ImInYourMonad> so i need to come up with a big haskell project. it should be something exciting that has the potential tomake money.
02:20:01 <mmorrow> wli: so in terms of difference between your approach and one which "compiled" (lazy) functional code: if you're compiling to be interpreted/run without being embedded in another lazy functional lang, you'd need to (well, this is one way, i dunno others) (1) turn lambdas into lets (one way or another), and (2) lift all local functions (ie lets that don't just bind a var) to top-level
02:20:24 <pumpkin> ImInYourMonad: wow, that's quite ambitious
02:20:35 <pumpkin> ImInYourMonad: did you check out the haskell proposals subreddit?
02:21:22 <ivanm> money? you actually expect to make _money_? :o
02:21:24 <ivanm> ;-)
02:21:49 <ImInYourMonad> if i can ever get the glut header working i might make a 3d-game
02:22:11 <quicksilver> that would not be a money making proposal.
02:22:19 <ImInYourMonad> no i guess not
02:22:23 <quicksilver> you don't make money out of 3d games with an investment under $100 million
02:22:30 <pumpkin> sadly
02:22:38 <quicksilver> it could certainly be a fun proposal though.
02:22:40 <ImInYourMonad> pfft 100$ million it doesnt cost?
02:23:09 <pumpkin> Axman6: which bit?
02:23:17 <Axman6> can't see where stuff is written to the chan
02:23:21 <Axman6> or something...
02:23:26 <pumpkin> only on place :P
02:23:33 <pumpkin> the only role of the chan is as a poor man's join ;)
02:23:44 <ImInYourMonad> 100 employees * 3 years * 60K $ = 18million dollars
02:23:46 <ImInYourMonad> ouch
02:23:58 <pumpkin> Axman6: it was one of the lamest things I've done, and that's saying something
02:24:21 <Axman6> pumpkin: it's not that bad. using mvars may be clightly less overhead though
02:24:23 <Axman6> slightly*
02:24:24 <Zao> ImInYourMonad: I'd recommend trying the glfw package. It tends to be less painful to get the right version of the native library built and set up.
02:24:30 <ivanm> quicksilver: know from experience?
02:24:35 <Zao> GLUT has the horrible schism between glut and freeglut.
02:24:38 <pumpkin> Axman6: each worker writes once into the chan, so I try to read out of it x times
02:24:50 <quicksilver> ivanm: well, I've never tried to market a game. But I do have friends in the game industry.
02:25:01 <pumpkin> Axman6: there should be nWorker writes into the chan, I don't think it's a significant issue
02:25:03 <quicksilver> ivanm: of course, to be fair, it depends what ImInYourMonad meant by 3D game.
02:25:11 <Axman6> yeah, probably not
02:25:26 <quicksilver> ivanm: I took him to mean 'FPS', like Killzone 2.
02:25:39 <kiris> what's a good way to write an e-book with lots of pictures?
02:25:40 <quicksilver> ivanm: you need $100 million to make something to compete in that arena and make a profit.
02:25:44 <Axman6> blackh: you around man?
02:25:46 <pumpkin> Axman6: other than that, it's direct writing to memory
02:25:53 <Axman6> yeah
02:26:02 <quicksilver> something more original for the xbox live arcade or iphone can turn a profit on a much smaller investment, of course.
02:26:24 <blackh> Axman6: I'm around!
02:26:25 <Axman6> pumpkin: see the fuction parallel in http://shootout.alioth.debian.org/u32q/benchmark.php?test=regexdna&lang=ghc&id=4
02:26:45 <Axman6> blackh: heh, i was just going to ask where that parallel function of yours was, then i remembered :P
02:27:06 <pumpkin> Axman6: looks nice
02:27:14 <ImInYourMonad> quicksilver: yeah im working ona 2dshooter on android
02:27:28 <ImInYourMonad> and i have been thinking about xbox , you cn program in f sharp even!
02:27:49 <Axman6> blackh: i made the spectral-norm benchmark a little faster, and i've made a slight improvement to binary-trees
02:27:54 <kiris> anyone know what BONUS wrote Learn You A Haskell with?
02:28:05 <blackh> Axman6: That's great! How did you make binary-trees faster?
02:28:09 <pumpkin> kiris: acid?
02:28:13 <Axman6> blackh: http://shootout.alioth.debian.org/u32q/benchmark.php?test=spectralnorm&lang=all spectral-norm
02:28:18 <Axman6> blackh: adding !'s :P
02:28:23 <quicksilver> a peacock's feather quill pen, I think.
02:28:50 <blackh> Axman6: Well, I can see there's a lot of butt being kicked around here. I gave up with binary-trees.
02:29:04 <Axman6> heh
02:29:39 <blackh> Axman6: Crikey that's fast - 1.3 !!
02:29:44 <pumpkin> Axman6: I have some ideas on making it even faster btw (mandelbrot)
02:29:55 <pumpkin> even on non-macos
02:29:56 <Axman6> pumpkin: good :)
02:29:59 <Axman6> heh :P
02:30:12 <pumpkin> I at least want to get us to 1.5x
02:30:18 <pumpkin> :P
02:30:27 <quicksilver> Saizan: OK, installed the newest Cabal. Still, after I run "runhaskell Setup.hs configure --user", I find that config.log has "prefix='/usr/local'"
02:30:29 <pumpkin> they can cheat with their fancy asm instructions
02:30:34 <quicksilver> Saizan: (and that was a clean unpack, again)
02:30:45 <quicksilver> Saizan: what does your config.log look like?
02:31:14 <kiris> pumpkin: certainly acid was contributory in the writing of Learn You A Haskell, but what software? it doesn't say in the HTML export
02:31:28 <pumpkin> oh, don't know then :/
02:32:11 <pumpkin> does the author of http://www.easyvision.googlepages.com/ hang out in here?
02:33:00 <blackh> Axman6: I can't believe those benchmark figures.  Haskell is breathing right down Java's neck!
02:34:06 <Workybob> osfameron: I hope not
02:34:17 <Workybob> cross platform UIs are universally awful
02:34:32 <Axman6> blackh: yeah, we're doing well :)
02:34:45 <Workybob> I'd much rather they went down the route that things like Handbrake are going down – don't hard code the UI onto it, and code a different one for different platforms
02:35:34 <quicksilver> better results but more work.
02:35:47 <blackh> Axman6: Six months ago when I was reading introductory material on the Haskell wiki it said that if you really want speed, use OCaml instead. I think that's somewhat out of date now.
02:35:51 <quicksilver> if it's a choice between not having the software at all, and having a slightly cooky UI, I choose cooky.
02:36:05 <Axman6> haha, indeed :)
02:36:17 <pumpkin> it'd be nice if you could specify GUIs in terms of very high-level constructs, and have it specialize layouts/widget types that "feel natural" on each platform
02:36:34 <quicksilver> pumpkin: many clever people have taken that path.
02:36:35 <Workybob> quicksilver: yeh, but usually the choice is between having a slightly cooky UI and everyone thinking it's "good enough" or waiting 2 months for someone to get pissed off and code it
02:36:41 <pumpkin> quicksilver: ... and never returned?
02:36:46 <quicksilver> pumpkin: not yet, no.
02:36:49 <pumpkin> :(
02:36:55 <quicksilver> or at least, not returned with a beautiful solution.
02:36:58 <pumpkin> so the path is into the bottom
02:36:58 <quicksilver> it would be nice, though.
02:37:07 <Workybob> pumpkin: the problem with that is that UIs are not just about what they look like
02:37:07 <pumpkin> no return from bottom
02:37:11 <Workybob> they are about how they behave
02:37:20 <Workybob> and expected behaviors on different platforms are very very different
02:37:26 <tommyj> hi room
02:37:31 <Workybob> e.g. I alt click on a mac, I expect to get a copy
02:37:42 <Workybob> alt-cilck on a PC and I expect a totally different behavior
02:37:46 <tommyj> has anyone here tried Mozilla's bespin?
02:37:47 <pumpkin> Workybob: yeah, I'm talking about "create a document-based UI that supports the following operations on document (grouped), and the following global operations"
02:37:52 <pumpkin> that kind of level
02:38:05 <pumpkin> the details of how the toolbar looks, the layout of buttons, icons, etc.
02:38:16 <pumpkin> is all up to the platform instance of the UI :P
02:38:24 <Workybob> pumpkin: oh, I suspect by the time you abstract to that level you end up with a very very hard task to get a useful UI out of it
02:38:26 <dancor> sounds like Swing ;p
02:38:33 <pumpkin> not really
02:38:44 <pumpkin> you still pick widgets and place them yourself
02:38:47 <tommyj> I read about bespin at moneycritter.com and was wondering if anyone has tried it, looks cool!
02:38:51 <pumpkin> Workybob: indeed :)
02:38:54 <Workybob> pumpkin: and instantly we have a problem
02:39:04 <pumpkin> Workybob: I meant swing did that
02:39:04 <Workybob> oh, hang on, that was a response to swing
02:39:05 <Workybob> >.<
02:39:13 <pumpkin> tommyj: are you spamming? :P
02:39:21 <Workybob> pumpkin: it's an interesting idea though
02:39:33 <dancor> @vixen are you spamming? :P
02:39:33 <lambdabot> yes, i am
02:39:34 <tommyj> no, i am been trying to get peoples opinion on this
02:39:46 <quicksilver> tommyj: well, we have opinions on haskell programming here
02:39:47 <Workybob> I guess the problem is that there's a lot of UI concepts you get on some platforms but not on others
02:39:49 <tommyj> i am not selling anything
02:39:54 <Workybob> e.g. the idea of filter bars is very common on OS X
02:39:55 <Gracenotes> @vixen . vixen . vixen . vixen are you spamming? :(
02:39:55 <lambdabot> yes, i am
02:39:58 <pumpkin> Workybob: the only reason I bring it up is that if we look at things critically, most UIs fall into maybe 5 or 6 classes, and the differences are mostly not in the layouts
02:40:00 <Workybob> but I've not seen any other platform do that
02:40:05 <Gracenotes> @vixen yes, i am
02:40:05 <lambdabot> i guessed that
02:40:11 <Workybob> pumpkin: yeh
02:40:13 <dancor> Gracenotes: see we really need a . that shows intermediate results!
02:40:13 <pumpkin> Workybob: yeah, true :/
02:40:23 <ImInYourMonad> glfw seems cool, it installed and works, anyone have any examples?
02:40:24 <pumpkin> Workybob: we need to abstract so highly that even filter bars are an implementation detail ;)
02:40:30 <Workybob> hehe
02:40:32 <dancor> Gracenotes: think of how lol vixen . quote could be
02:40:34 <ImInYourMonad> DisplayBits: Bit depth of GL display buffers, used in openWindow. how?
02:40:35 <pumpkin> "Write me a GUI that does what I want"
02:40:39 <osfameron> Workybob: then again, if mac people realise that code can be ported simply, they might opensource their code, and then let someone make a crappy-but-working straight port first, and then work on a shiny UI after
02:40:39 <pumpkin> that's the kind of language
02:40:48 <Gracenotes> dancor: vixen has interesting combinations with .
02:40:50 <osfameron> as it is, there are lots of nice looking shareware apps in the mac ghetto
02:40:58 <pumpkin> shareware!
02:40:59 <Workybob> osfameron: my experience is that that rarely happens
02:41:04 <pumpkin> don't insult us with such a word!
02:41:04 <pumpkin> ;)
02:41:06 <Gracenotes> dancor: however, what vixen can say is finite. It's all in a text file somewhere :)
02:41:16 <Workybob> wheras the "just wait until we do it right" version usually does
02:41:19 <Saizan> quicksilver: i've prefix='/usr/local' too
02:41:30 <quicksilver> Saizan: oh, and it doesn't matter?
02:41:44 <quicksilver> Saizan: ah, you're right.
02:41:49 <quicksilver> Saizan: excellent :-)
02:41:56 <quicksilver> Saizan: I got distracted before actually testing 'install'
02:41:59 <Gracenotes> @vixen How do you feel about producing an answer based on regex matching of my question?
02:41:59 <lambdabot> i dunno, what was the question?
02:42:01 <quicksilver> damn real work. Such a distraction.
02:43:05 <dancor> Gracenotes: oh really finite?!  are there cooler newer grammartastic vixen-descendants
02:43:19 <pumpkin> lol
02:43:26 <pumpkin> my mac os spell checker doesn't like haskell :(
02:43:36 <pumpkin> it underlines it, and suggests "hassle" if I right click on it
02:44:00 <Axman6> gahh, this shits me. the binary trees one is about three times faster if you add -H300m
02:44:09 <Zao> pumpkin: Isn't that how some pronounce it?
02:44:29 <Gracenotes> dancor: I'm sure there are, but don't have the same charm
02:44:32 <Gracenotes> canned charm
02:45:16 <osfameron> I saw ocaml mentioned above, and just came across this yesterday http://steve.yegge.googlepages.com/more-ocaml
02:45:32 <Gracenotes> @vixen fdsak
02:45:32 <lambdabot> so, what made you want to message me?
02:45:36 <pumpkin> Axman6: how about forcing it to preallocate all that memory and freeing it?
02:45:36 <Gracenotes> @vixen fdsak
02:45:36 <lambdabot> I will NOT be ignored...
02:45:41 <osfameron> how is ocaml comparing to haskell *now* for those real world niceties (integration with perl/apache etc., debugger etc.)
02:45:43 <pumpkin> Axman6: I'm not sure if that would help
02:45:45 <Gracenotes> @vixen . vixen . vixen . vixen fdsak
02:45:45 <lambdabot> i am a bit of a vixen :)
02:46:10 <ImInYourMonad> what does !Int mean?
02:46:13 <pumpkin> Axman6: a simple mallocArray followed by a free, or something like that
02:46:14 <ImInYourMonad> a pointer?
02:46:24 <pumpkin> ImInYourMonad: a strict field in a data constructor
02:46:25 <Axman6> pumpkin: maybe, nit sure how you'd get it to use the memory uoi allocate though
02:46:34 <Axman6> ImInYourMonad: a strict Int
02:46:49 <Axman6> it won't ever be a thunk. it's like running seq on it
02:47:03 <pumpkin> Axman6: try mallocArray from Foreign.Array maybe?
02:47:19 <pumpkin> I have no clue if that kind of thing will help
02:47:26 <ImInYourMonad> ok
02:47:37 <pumpkin> but it might force it to allocate all the space in one go, rather than figuring out that it needs it as it goes along
02:47:37 <Axman6> and i have no idea how to make it happen pumpkin :P
02:47:51 <ivanm> Gracenotes: what's "fdsak" meant to mean?
02:48:01 <Axman6> actually, i think i get what you mean. do an alloc and then a free right awak?
02:48:03 <pejo> osfameron, there's still no perl4hs, is there?
02:48:03 <Axman6> away*
02:48:05 <pumpkin> Axman6: yeah
02:48:10 <Axman6> could work
02:48:12 <Gracenotes> ivanm: just a random string that vixen won't match against anything
02:48:23 <Gracenotes> @vixen Visual Basic
02:48:24 <lambdabot> Can you really catch syphilis from Visual Basic?
02:48:25 <ivanm> O...K... then
02:48:32 <Gracenotes> ^ vixen always matches Visual Basic with that
02:48:34 <Gracenotes> @vixen Visual Basic
02:48:35 <lambdabot> Can you really catch syphilis from Visual Basic?
02:48:46 <pumpkin> (mallocArray 30000000 :: IO Word8) >>= free
02:48:49 <pumpkin> Axman6: :P
02:48:54 <ivanm> @vixen Java
02:48:54 <lambdabot> Ok
02:48:58 <pumpkin> as I said, it might do absolutely nothing
02:48:59 <ivanm> :o
02:49:02 <mmorrow> @vixen Basically Visual
02:49:03 <lambdabot> Is that a real poncho or is that a Sears poncho?
02:49:03 <ivanm> @vixen Java
02:49:04 <lambdabot> too many perverts send out sick pictures of themselves. what type of man does that?
02:49:20 <mmorrow> @vixen Its really from Sears
02:49:20 <lambdabot> really!?
02:49:30 <mmorrow> @vixen really@
02:49:30 <lambdabot> really!?
02:49:33 <mmorrow> lol
02:49:39 <ivanm> @vixen lambdabot
02:49:39 <lambdabot> Crazy little wanker!
02:49:39 <quicksilver> oops. damn. recompiling opengl requires recompiling glut. I hate libraries.
02:49:41 <osfameron> pejo: not that I'm aware, no
02:49:49 <ivanm> :o
02:49:50 <pumpkin> that's rude!
02:49:52 * pumpkin slaps lambdabot
02:50:05 * ivanm slaps lambdabot's alternate identity of vixen
02:50:50 <pumpkin> Axman6: you trying it?
02:50:57 <Axman6> in a sec :P
02:51:01 <pumpkin> ah, just wondering :)
02:51:02 <ImInYourMonad> data Size 	Source
02:51:02 <ImInYourMonad> A 2-dimensional size, measured in pixels.
02:51:02 <ImInYourMonad> Constructors
02:51:02 <ImInYourMonad> Size !GLsizei !GLsizei	
02:51:06 <ImInYourMonad> http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GL-CoordTrans.html#t%3ASize
02:51:07 * Axman6 is trying to drink tea
02:51:12 <pumpkin> Axman6: TEA!
02:51:15 <ImInYourMonad> (G.Size 640 480)  right?
02:51:15 <kiris> Axman6: pennyroyal tea?
02:51:17 <pumpkin> that's terrible
02:51:19 <ImInYourMonad> Not in scope: data constructor `G.Size'
02:51:28 <pumpkin> it had better be white or green tea
02:51:42 <quicksilver> ImInYourMonad: depends how you imported openGL
02:51:58 <quicksilver> personally I import openGL unqualified
02:52:09 <quicksilver> so just (Size 640 480)
02:52:19 <johnw> Axman6: i like Sadaf tea a lot, basically earl grey but very good
02:52:36 <kiris> sit and drink pennyroyal teeeeeeeeeeeeaaaaaaaa
02:52:39 <johnw> (loose leaf, of course, bags are a waste)
02:52:43 <Axman6> not sure what this one it, dad brought it in for me becaus ei'm sick ;9
02:52:45 <Axman6> ;)
02:53:47 <Gracenotes> @vixen I love you! :D
02:53:47 <lambdabot> you're cute. :)
02:53:56 <Gracenotes> @vixen blow me a kiss! :D
02:53:57 <lambdabot> have you ever given another guy head?
02:53:58 <pumpkin> Gracenotes: you're up too late
02:54:00 <Gracenotes> ^.^
02:54:00 <pumpkin> lol
02:54:09 <Axman6> 400 * 1024*1024
02:54:14 <Gracenotes> (you can guess the substring matching there)
02:54:15 <Axman6> > 400 * 1024*1024
02:54:16 <ivanm> Gracenotes: maybe you and @vixen should get a private room...
02:54:17 <lambdabot>   419430400
02:54:22 <Axman6> > 500 * 1024*1024
02:54:23 <lambdabot>   524288000
02:54:34 <pumpkin> Gracenotes and the other guy should get a private room
02:54:45 <Gracenotes> ha
02:54:46 <ivanm> pumpkin: lol
02:55:03 <Gracenotes> @vixen blow me another kiss?
02:55:03 <lambdabot> give you a blowjob? wait, i'm a guy!
02:55:07 <pumpkin> lol
02:55:09 <kiris> 'ey fun bois, getaroom
02:55:23 <pumpkin> @vixen homophobe!
02:55:23 <Axman6> pumpkin: running it now...
02:55:23 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
02:55:28 <ivanm> I thought lambdabot and vixen are female :s
02:55:31 <Gracenotes> vixen says the cutest things sometimes
02:55:49 <pumpkin> Axman6: drumroll!
02:55:55 <Axman6> nothing :(
02:55:58 * ivanm points out the availability of "/msg lambdabot" to Gracenotes 
02:56:09 <pumpkin> Axman6: hmm, I wonder why
02:56:21 <pumpkin> Axman6: how much of its time does it spend GCing?
02:56:37 <Axman6> well, from my experiments with malloc on OS X, it doesn't actually allocate all the space
02:56:44 <pumpkin> ah, force it to
02:56:49 <pumpkin> poke values into the array
02:57:00 <pumpkin> at various intervals
02:57:02 <Axman6> another good idea  :P
02:57:36 <Axman6> Productivity  41.0% of total user, 45.2% of total elapsed
02:57:39 <Axman6> ................
02:57:42 <Axman6> ................................................
02:57:45 <pumpkin> so the rest is all GC?
02:57:59 <Axman6> yeah
02:58:03 <quicksilver> I'm not sure you're barking up the right tree, there.
02:58:07 <quicksilver> GHC doesn't use malloc anyway
02:58:14 <pumpkin> it does eventually doesn't it?
02:58:16 <quicksilver> no.
02:58:18 <pumpkin> mmap?
02:58:21 <Axman6> :\
02:58:34 <pumpkin> does it pull the memory out of dark places you don't want to visit?
02:58:41 <quicksilver> is the point here that a larger heap size reduces runtime?
02:58:48 <kiris> malloc is a c thing
02:59:12 <pumpkin> you still need to ask the OS for memory at some point
02:59:14 <quicksilver> it's more likely a GC effect I'd have thought.
02:59:28 <quicksilver> less frequent GCes, or altering the speed things move between generations
02:59:32 <quicksilver> or something along those lines.
02:59:49 <quicksilver> +RTS -sstderr will tell you MUT time vs GC time.
03:00:44 <pumpkin> yeah, I thought that's what he said the 41% was
03:01:06 <pumpkin> omg it's crayer!
03:01:14 <crayer> pumpkin, heheheheheh
03:01:20 <crayer> pumpkin, hi :D
03:02:37 <pumpkin> quicksilver: so where does ghc get its memory from? I thought the only ways were malloc or mmap
03:02:46 <quicksilver> pumpkin: it has its own storage manager, I'm not sure how it works, I suspect it requests pages directly from the OS>
03:03:31 <quicksilver> on linux you can just call brk(), I believe, for example.
03:03:58 <quicksilver> AIUI one of the reasons the GMP binding is such a pain is that GMP *does* use malloc.
03:04:16 <int-e> mmap is more common nowadays
03:04:16 <pumpkin> well, with -H300m it goes a lot faster
03:04:29 <Axman6> aqlmost three times as fast
03:04:56 <quicksilver> sure.
03:05:03 <quicksilver> I'm just doubting that the key cost there is the allocation
03:05:11 <quicksilver> allocation is cheap unless you're doing it 1 byte at a time.
03:05:12 <int-e> quicksilver: not quite - gmp has an interface to change the allocation functions. which ghc does; ghc makes them return a pointer after the header of a bytearray.
03:05:39 <quicksilver> the cost is probably a change in GC characteristics
03:05:41 <pumpkin> well, if it thinks its heap is smaller than it needs to be, it'll spend useless time GCing, then trying to allocate more?
03:05:51 <pumpkin> that was my reasoning
03:05:55 <pumpkin> but I know nothing :P
03:05:57 <int-e> quicksilver: it's really quite fast, but the interaction with the garbage collector is a bit of a mess, and binding additional gmp functions without adding new primops is very tricky at best.
03:06:06 <quicksilver> int-e: some issue with memory management makes it hard to add new primops
03:06:14 <quicksilver> int-e: right, that's what I was thinking of.
03:06:28 <quicksilver> pumpkin: with no heap settings at all, the heap is unbounded anyway
03:06:33 <pumpkin> yeah
03:06:49 <pumpkin> but it still makes an effort to keep it compact doesn't it? if you instantly give it a big one, it can put it off?
03:06:52 <pumpkin> or am I completely off here
03:07:08 <quicksilver> no, you're right.
03:07:19 <quicksilver> if you give it a big "hint" then it doesn't waste time trying to keep the heap small.
03:07:27 <pumpkin> yeah
03:07:41 <mmorrow> pumpkin: on unix, ghc mmaps /dev/zero
03:07:53 <ivanm> I seem to recall RWH having a chapter where IO is newtyped... anyone know where?
03:08:05 <Axman6> it'd be so nice if we could give certain runtime flags at compile time :\
03:08:11 <ivanm> nvm, found it
03:08:18 <pumpkin> @index poke
03:08:18 <lambdabot> Foreign.Storable, Foreign
03:08:21 <quicksilver> Axman6: you can.
03:08:28 <ImInYourMonad> anyone have a glfw example in haskell? the C tutorials are so long and messy. i just want to know the basics of what i need to put something up
03:08:29 <Axman6> you can?
03:08:45 <mmorrow> Axman6: you can if you link in the symbol "char *rtsflags = "....""
03:08:54 <mmorrow> (that's not the correct name though)
03:09:15 <quicksilver> Axman6: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
03:09:41 <quicksilver> it's slightly ugly but it works :)
03:09:51 <mmorrow> ooh, i also was messing around stumbled upon a way to do it without having to link anything in
03:09:57 <mmorrow> i almost forgot about that
03:10:24 <Axman6> gahh! frigging ISP!
03:11:08 <mmorrow> so you give ld a different entrypoint that "main", which is a C function you write that gets argv, does whatever, then calls main with whatever argv you want
03:11:12 <ivanm> Axman6: which one?
03:11:23 <Axman6> netspeed
03:11:32 <ivanm> never heard of them :s
03:11:43 <Axman6> they're a canberra one, TransACT provider
03:11:46 <ivanm> ahhh
03:11:53 <Workybob> augustss: you're sick
03:11:55 <Workybob> BASIC?
03:11:56 <ivanm> about to say, they're not in wikipedia so they mustn't be big ;-)
03:11:56 <Workybob> o.O
03:12:02 <Workybob> (also – that's fucking cool)
03:12:15 <ivanm> Workybob: he mentioned basic on his blog a while ago IIRC...
03:12:30 <ivanm> and I'd say more "disturbing" than cool
03:12:35 <quicksilver> mmorrow: how is that not having to link anything in?
03:12:41 <quicksilver> mmorrow: that's linking in your entry point!
03:12:44 <mmorrow> quicksilver: ok, you got me
03:12:47 <mmorrow> :)
03:12:47 <Workybob> ivanm: yep, disturbing sure, but very very cool
03:13:29 <mmorrow> quicksilver: but it does allow you to ... err, hmm that still doesn't let a lib set any flags
03:13:51 <pumpkin> aha, looks like the Foreign.mallocArray is using a native malloc or something
03:13:56 <pumpkin> I guess the name indicates that :P
03:14:02 <mmorrow> it does iirc
03:14:04 <pumpkin> let me try a newByteArray
03:14:14 <Axman6> quicksilver: hmm, that link isn't very useful here :\
03:14:32 * mmorrow has started just always using   foreign import unsafe ccall "malloc" malloc :: CSize -> IO (Ptr a)
03:14:45 <mmorrow> and ... .free
03:15:00 <pumpkin> mmorrow: I need to give the RTS more memory though
03:15:03 <pumpkin> malloc is outside of its control
03:15:13 <bastl> has anyone experiences with haxr? i try to access an xmlrpc server via https, and get "301, Moved permanentely"
03:15:20 <mmorrow> pumpkin: look at the code that mmaps /dev/zero
03:15:36 <quicksilver> Axman6: ? works for me.
03:15:58 <mmorrow> pumpkin: http://moonpatio.com/repos/LIBS/Language/ghc/rts/posix/OSMem.c
03:16:00 <Axman6> quicksilver: yeah, but we can't exactly include a C file for use in the shootout can we :\
03:16:05 <quicksilver> Axman6: oh, I see.
03:16:17 <quicksilver> Axman6: but you can specify runtime flags,  I think?
03:16:26 <pumpkin> mmorrow: I know, but I need to convince the RTS to take more memory, not just allocate more memory within the program
03:16:29 <Axman6> yeah, they won't let us use -H300m
03:16:31 <quicksilver> I'm sure other shootout entires have runtime flags.
03:16:34 <quicksilver> ah.
03:16:47 <Axman6> they allow others, but not that for some reason.
03:16:53 <mmorrow> pumpkin: oh, hmm
03:17:00 <pumpkin> > 400 * 1024 * 1024
03:17:02 <lambdabot>   419430400
03:17:03 <mmorrow> pumpkin: so there's a limit?
03:17:05 <Axman6> blackh: you know the reason behind not letting us use -H300m in the shootout right?
03:17:12 <pumpkin> mmorrow: not that I know of
03:17:19 <pumpkin> mmorrow: just testing a hypothesis right now :)
03:17:38 <blackh> Axman6: Yes - they don't want people to make it so big that it disables GC
03:17:42 <ivanm> Axman6: because there isn't 300M to spare?
03:18:00 <mmorrow> pumpkin: but i mean, the rts has a max amount it'll take currently?
03:18:05 <mmorrow> and you want more?
03:18:16 <pumpkin> mmorrow: no, but it doesn't know to expect lots of memory use
03:18:22 <pumpkin> so it's trying to be conservative (or so I think)
03:18:22 <mmorrow> ah
03:18:32 <pumpkin> so collecting when there really is no hope
03:18:49 <mmorrow> no hope of what?
03:19:04 <mmorrow> that it's even worth it
03:19:05 <mmorrow> ?
03:19:23 <pumpkin> yeah, it isn't worth it, but it tries anyway, because it doesn't know that it's running an artificial benchmark
03:19:30 <mmorrow> hah
03:19:33 <pumpkin> it runs way faster if you increase its heap size from a +RTS option
03:19:45 <HugoDaniel> good morning :)
03:20:20 <mmorrow> pumpkin: ohh, so you want to be able to dynamically do the same thing that that +RTS option does statically
03:20:23 <pumpkin> yeah
03:20:24 <pumpkin> well
03:20:31 <pumpkin> only because +RTS -H300m isn't allowed ;)
03:20:35 <mmorrow> (i think that might be in StaticOpts)
03:21:05 <mmorrow> ghc/compiler/main/StaticFlags.hs  i mean
03:21:09 <Gracenotes> @vixen would you like a mudkip? :)
03:21:09 <lambdabot> i might :)
03:21:13 <Gracenotes> :)
03:21:26 <mmorrow> hmm, maybe not
03:21:28 <ivanm> @slap Gracenotes
03:21:28 * lambdabot orders her trained monkeys to punch Gracenotes
03:22:17 * Gracenotes runs back to his mudkip farm
03:24:16 <mmorrow> pumpkin: it looks like -H sets  RtsFlags.GcFlags.heapSizeSuggestion
03:24:26 <pumpkin> how can you set that from inside the program?
03:24:36 <mmorrow> grep for "case 'H'" in ghc/rts/RtsFlags.c
03:24:49 <pumpkin> see, that's all happening in the c inside the RTS
03:24:56 <Gracenotes> > map chr $ zipWith (+) (map ord "marshtomp") [6,22,-17,-6,8,-15,3,7]
03:24:58 <lambdabot>   "swampert"
03:24:59 <mmorrow> pumpkin: maybe by just foreign import unsafe ccall "&" asdfsa :: Ptr CInt
03:25:03 <mmorrow> then poking
03:25:06 <pumpkin> lol
03:25:10 <mmorrow> :)
03:25:15 <skorpan> is it possible at all to install wxhaskell as --user using cabal install? because it seems that it uses "ghc-pkg update" without --user.
03:25:35 <pumpkin> mmorrow: not sure they'd like that either :P
03:25:45 <pejo> Axman, do the rules prohibit the compiler to deforest away the trees in that benchmark?
03:25:54 <Axman6> yes
03:26:01 <mmorrow> pumpkin: heh
03:26:07 <Axman6> has to be a statically allocated tree -_-
03:26:29 <pejo> Axman, sure, but do you need to traverse it?
03:26:59 <Axman6> i believe so... i don;t know much about this benchmark really. blackh may know more...
03:27:26 <pejo> I guess they would change the rules in case someone finds a too fast solution.
03:27:44 <blackh> pejo: The trees have to be allocated, and they have to be traversed
03:28:20 <pejo> blackh, silly. "Make sure you don't turn on too many optimizations in your compiler".
03:28:53 <quicksilver> the benchmark rules are silly.
03:29:09 <quicksilver> but if they weren't silly, 'printf("The answer")' would be the optimal solution to most of them.
03:29:31 <quicksilver> the intention of the rules is to restrict your code to whatever they feel they're trying to check in each particular case
03:29:45 <quicksilver> since that's not terribly well-defined, it's quite frustrating on the borderlines
03:30:21 <crayer> see you later :)
03:30:26 <quicksilver> especially since it feels like the rule-makers are subconciously restricting your case to 'this is how I would do it in C, so you mustn't do somethign substnatially better'
03:31:03 <SamB> yeah ... just because bitpacked arrays are a bitch to code in C ...
03:31:30 <pejo> quicksilver, writing the recursive traversals of a tree structure is how you would do it in most fp's though. And those languages can easily be deforested.
03:31:33 <blackh> It would be possible to make benchmarks where no rules are required, if the harness generated input and checked that a certain transformation was being implemented.
03:32:09 <quicksilver> you'd have to keep the generated input secret
03:32:17 <mmorrow> perhaps someone should make this benchmark site
03:32:19 <quicksilver> otherwise people could write code which special cased on the actual input
03:32:22 <quicksilver> or you could make it random
03:32:28 <quicksilver> ...but then the results would vary.
03:32:55 <blackh> It shouldn't matter if the results vary - it's all statistics.
03:33:33 <blackh> That is, make it short and executed many times.
03:33:58 <quicksilver> yes, that could work.
03:33:58 <mmorrow> it'd work if the correctness of the output was verifiable, but the input possibilities are massive
03:34:09 <mmorrow> like, benchmark1: fft
03:34:40 <SamB> what fuzz factor would be allowed in the output then?
03:34:42 <mmorrow> benchmark2: red-black tree insertion
03:34:54 <mmorrow> benchmark3: rbtree deletion
03:35:01 * mmorrow shudders
03:35:21 <SamB> you know how floating point is
03:35:34 <mmorrow> awesome?
03:36:03 <mmorrow> you could just require a given error bound
03:36:28 <SamB> yeah, that's what I meant by "fuzz factor"
03:36:37 <mmorrow> ok, call it 'e'
03:36:47 <pumpkin> can I ask the RTS to GC now? :P
03:37:02 <mmorrow> System.Mem.performGC i think
03:37:45 <pumpkin> boo :(
03:37:46 <Gracenotes> do GHC -no options override language pragmas?
03:37:48 <SamB> or ϵ ...
03:37:59 <pumpkin> I wonder why -H300m makes it faster :(
03:38:01 <Gracenotes> or the other way round
03:38:11 <mmorrow> or is an element of ... ?
03:38:26 <SamB> Gracenotes: where are the GHC options?
03:38:52 <SamB> mmorrow: that's supposed to be an epsilon actually
03:39:15 <Gracenotes> er... like -XScopedTypeVariables vs -XNoScopedTypeVariables
03:39:21 <SamB> % unicode ϵ
03:39:22 <SamB> U+03F5 GREEK LUNATE EPSILON SYMBOL
03:39:49 <SamB> so apparantly it's a loony's idea of an epsilon ?
03:39:56 <pumpkin> boo
03:40:00 <quicksilver> SamB: the epsilon should be part of the input.
03:40:09 <quicksilver> SamB: the code should be able to work within any chosen accuracy :)
03:40:19 <jedai> There are cuter epsilon in unicode though
03:40:31 <SamB> yeah
03:40:42 <SamB> I blame SCIM's LaTeX table
03:41:01 <SamB> I wish I knew how to edit/view it
03:41:11 <mmorrow> SamB: usually the ɛ version if used for that
03:41:23 <SamB> aww rats
03:41:40 <SamB> unicode actually uses a signed variable for the --max option
03:41:59 * SamB tried to pass a -1 ;-)
03:42:48 * SamB wonders why all of these unicode symbols are coming out bold here
03:42:57 <ivanm> font?
03:42:59 <SamB> or, well, maybe not all
03:43:04 <pumpkin> ah well, I fail
03:43:07 <pumpkin> I'm calling it a night
03:43:21 <ivanm> SamB: aren't all characters unicode (or have a unicode equivalent)?
03:43:35 <SamB> U+025B LATIN SMALL LETTER OPEN E
03:43:50 <SamB> mmorrow: really?
03:44:30 <SamB> oh, I remembered how to get the one I like
03:44:32 <mmorrow> SamB: it seems like that epsilon version is prefered in math notation (although i like the ϵ more myself)
03:44:39 <SamB> % unicode ε
03:44:40 <SamB> U+03B5 GREEK SMALL LETTER EPSILON
03:44:45 <SamB> \varepsilon
03:44:51 <ivanm> mmorrow: the other is normally used because that one is for set membership
03:44:56 <ivanm> (my guess, anyway)
03:45:14 <SamB> ivanm: or at least looks just like the symbol for set membership
03:45:18 <mmorrow> ivanm: set membership is actually a diff sym, but yeah that could be it
03:45:36 <ivanm> handwriting, don't forget! ;-)
03:45:47 <ivanm> and some mathematicians aren't much better than doctors :p
03:46:13 <ivanm> (probably from when mathematicians _where_ doctors, i.e. the only non-religious learned people around... :P )
03:46:23 <SamB> ivanm: were
03:46:24 <SamB> not where
03:46:34 <ivanm> yes, my mistake
03:46:44 <SamB> ;-P
03:47:23 <mmorrow> on the topic, sigma is ς when it's at the end of a word
03:47:43 * mmorrow might start using that sigma exclusively from now on
03:47:50 <ivanm> mmorrow: heh
03:47:52 <ivanm> that probably comes around from greek handwriting convention
03:48:31 <SamB> reminds me of ç
03:48:47 <ivanm> SamB: looks like the same symbol to me... >_>
03:48:50 <ivanm> is it meant to be?
03:48:54 <mmorrow> it's not
03:49:03 <mmorrow> , 'ς'
03:49:04 <lunabot>  '\962'
03:49:08 <mmorrow> , 'ç'
03:49:09 <lunabot>  '\231'
03:49:11 <ivanm> ahhh, slightly different curve
03:49:22 <daf> c-with-cedilla vs. final sigma
03:49:34 <quicksilver> mid word sigma should be like an "o" with a curve from the top
03:49:52 <quicksilver> end of word is rather like an english s where the bottom stroke trails downwards
03:50:04 <quicksilver> I'm not unicode capable in this terminal so I can't see what you typed :)
03:50:18 <quicksilver> we used to have two different "s"es in english, too.
03:50:35 <ivanm> quicksilver: the good old f vs s stuff?
03:50:56 <mmorrow> i wonder how many years/decades it'll be before unicode finally become standard (as in everything supports unicode)
03:51:09 <SamB> ivanm: I think it was a bit different from the f, but not enough for my eyes ...
03:51:23 <Gracenotes> > let func Nothing = Just 4; func = id in func (Just 5)
03:51:24 <SamB> mmorrow: including the microwave ?
03:51:24 <lambdabot>       Equations for `func' have different numbers of arguments
03:51:24 <lambdabot>        <intera...
03:51:29 <daf> ivanm: it was different to f too
03:51:43 <Gracenotes> hm
03:51:46 <mmorrow> SamB: yes. i want to snowman to be displayable on the lcd
03:51:58 <Gracenotes> > let func Nothing = 4; func = fromJust in func (Just 5)
03:51:59 <lambdabot>       Equations for `func' have different numbers of arguments
03:51:59 <lambdabot>        <intera...
03:52:03 <daf> ſ vs f
03:52:05 <SamB> mmorrow: could be centuries
03:56:37 <dancor> do ppl use the approach to testing in http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
03:57:01 <dancor> or do yall do lighter-weight things
03:57:24 <quicksilver> ivanm: yes. Much like an 'f' without a bar across it.
03:57:31 <Axman6> blackh: argh! this binart-tree thing is so frustrting!
03:57:41 <quicksilver> sometimes it had a tail, too (like the modern integral sign)
03:57:47 <pumpkin_> Axman6: yeah!
03:57:49 <quicksilver> then again, I think fs sometimes had tails themselves.
03:57:58 <pumpkin_> Axman6: give up on the preallocation, it didn't work :/
03:57:59 <Deewiant> dancor: I use test-framework (on Hackage)
03:58:01 <Axman6> pumpkin_: trying to parallelise it better to no avail -_-
03:58:07 <blackh> Axman6: Did you see my comment on dons's blog about binary-trees?
03:58:13 <Axman6> pumpkin_: heh, i gave up on that hours ago :P
03:58:13 <ivanm> pumpkin_: I thought you were going to bed... >_>
03:58:22 <pumpkin_> ivanm: that was my work self
03:58:23 <pumpkin_> now I
03:58:26 <Axman6> blackh: nope, i'll check it out
03:58:26 <pumpkin_> 'm at home ;)
03:58:31 <ivanm> heh
03:58:31 <quicksilver> mmorrow: I want to be allowed a car number plate with a snowman in!
03:58:33 <pumpkin_> ivanm: but yeah, probably will go to sleep soon :P
03:58:44 <pumpkin_> given that it's 7 am
03:58:45 <quicksilver> mmorrow: and I want to be allowed to make it the middle initial on my child's birth certificate!
03:58:47 <ivanm> you live close to work, I take it ;-)
03:58:48 <ivanm> pumpkin_: :o
03:58:51 <ivanm> you work overnight?
03:58:57 <dancor> Deewiant: cool.. do you have an example project online where i can see it being used
03:59:00 <dancor> perchance
03:59:07 <pumpkin_> ivanm: I'm a student with terrible sleep habits :P and yeah, I live close by
03:59:13 <blackh> Axman6: If you can't find it, I'll dig it up for you. That's why I think it's slow.
03:59:22 <ivanm> quicksilver: for it to be the middle initial, it needs a name to go along with it...
03:59:39 <Deewiant> dancor: Glob (also on Hackage) has some stuff
03:59:44 <dancor> thanks
04:00:18 <Axman6> blackh: yeah can't find it :\
04:02:17 <blackh> Axman6: http://www.reddit.com/r/haskell/comments/82va0/can_you_write_a_better_parallel_binarytrees/
04:03:03 <romildo> Hi.
04:05:37 <romildo> I have both parsec-2.1.0.1 and parsec-3.0.0 installed on my Gentoo Linux system. It seems that the API has changed a lot between these versions. Is there any concerns using the newest one? Do they have the same peformance?
04:06:25 <Axman6> ta blackh
04:06:39 <pejo> Deewiant, test-framework just takes care of running the tests, right?
04:06:45 <Axman6> romildo: i've heard that 3.0 is quite a bit slower
04:07:10 <Deewiant> pejo: Yep
04:10:00 <Gracenotes> hm... is there a problem with making a monad instance for sets?
04:10:09 <Deewiant> Yes.
04:10:24 * Gracenotes read a blog post once, but I don't think the argument stuck
04:10:31 <Deewiant> ?go monad set
04:10:31 <lambdabot> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
04:10:31 <lambdabot> Title: How to make Data.Set a monad
04:10:53 <Gracenotes> return = singleton; set >>= f = unions . toList $ map f set
04:10:57 <Gracenotes> not as simple as that? :)
04:11:01 <Gracenotes> oh, wait, the Ord
04:11:03 <Deewiant> Ord.
04:11:04 <Gracenotes> yeah
04:11:04 <Deewiant> :-)
04:12:32 <Gracenotes> I suppose you could make a data OrdSet = Ord a => Set a...? messy though, perhaps not usable
04:13:38 <Deewiant> Gracenotes: I forget how those class constraints on data types work, IIRC they're mostly trouble
04:13:54 <Gracenotes> @hoogle Set (Set a) -> Set a
04:13:54 <lambdabot> Data.Set deleteMax :: Set a -> Set a
04:13:54 <lambdabot> Data.Set deleteMin :: Set a -> Set a
04:13:54 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
04:14:06 <Gracenotes> it's bothersome that this doesn't exist either, although [Set a] -> Set a does :)
04:14:22 <Gracenotes> hm. I suppose I can just use map instead of Set.map.
04:14:35 <Gracenotes> messed up though
04:14:42 <pumpkin_> there's an RMonad replacement for Monad
04:14:43 <Deewiant> I wonder if something like that could be any better than unions . toList
04:14:48 <pumpkin_> that allows a Set monad quite easily
04:15:03 <pumpkin_> @hackage rmonad
04:15:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
04:15:33 <Gracenotes> awwz. cute.
04:15:52 <Axman6> @hackage ../../../../
04:15:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/../../../../
04:16:43 <ivanm> Axman6: stop being so mean!
04:16:55 <pumpkin_> :o
04:16:58 <Axman6> what! it's an awesome package!
04:19:36 <Gracenotes> that's what lambdabot said
04:19:42 <Gracenotes> *rimshot*
04:19:48 * pumpkin_ faceplams
04:20:41 <ivanm> where did lambdabot say it's an awesome package?
04:20:50 <pumpkin_> last night
04:21:27 <pumpkin_> omg BONUS is awake
04:21:32 <ivanm> O...K... then...
04:21:38 <ivanm> pumpkin_: go to bed, it's early for you :p
04:21:43 <pumpkin_> :(
04:21:51 <pumpkin_> if I go to bed then I have to wake up
04:21:58 <pumpkin_> and be productive and stuff
04:21:59 <ivanm> what, don't you like waking up?
04:22:04 * Gracenotes has been up since 1 AM
04:22:24 <Axman6> o.O
04:22:31 * ivanm has been up since 8:30 AM
04:23:03 * p_l has been up around since yesterday, with little nap in front of laptop
04:29:54 <Gracenotes> yay, my PDA evaluator works :)
04:30:05 <Gracenotes> nondeterminism is hard, let's go shopping!
04:32:18 <Gracenotes> modeled by data PDA a s = PDA { pdaTrans :: [Trans a s], pdaState :: State, pdaFinal :: [State] }, data Trans a s = Trans { transState :: (State, State), transChar :: (Maybe a), transStack :: ([s], [s]) }
04:33:40 <BONUS> pumpkin_: omg how did u kno
04:33:49 <pumpkin_> BONUS: twittur iz my frend
04:33:53 <BONUS> ah :]
04:36:14 <pumpkin_> BONUS: kiris was wondering what you used to write LYAH (apart from acid)
04:38:05 * awful Need People on !NEW! MuOnline Season 4 Server /msg me !!!!!!!
04:38:05 * awful Need People on !NEW! MuOnline Season 4 Server /msg me !!!!!!!
04:38:19 <pumpkin_> awful: if you're going to spam, at least be effective
04:38:20 <awful> http://mu.plevky.lv/
04:38:25 <awful> http://mu.plevky.lv/
04:38:25 <awful> http://mu.plevky.lv/
04:38:25 <awful> http://mu.plevky.lv/
04:38:26 <awful> http://mu.plevky.lv/
04:38:26 <awful> http://mu.plevky.lv/
04:38:26 <Gracenotes> that's pretty effective.
04:38:32 <pumpkin_> the first couple weren't
04:38:46 <Gracenotes> You had me at http://
04:39:01 <Axman6> @ops
04:39:01 <lambdabot> Maybe you meant: docs oeis pl
04:39:09 <Axman6> @where ops
04:39:10 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:39:19 --- mode: ChanServ set +o dcoutts
04:39:26 <dcoutts> oh too late
04:39:42 --- mode: ChanServ set -o dcoutts
04:39:46 <vegai> *!*@*.plevky.lv might work, though
04:40:12 <Axman6> aye
04:40:25 <pumpkin_> wow, it's just a gaming server
04:40:27 <pumpkin_> with no ads
04:40:58 <Axman6> where's .lv? :
04:40:59 <ivanm> which country has .lv?
04:41:03 <ivanm> Axman6: heh
04:41:03 <Axman6> heh
04:41:04 <pumpkin_> latvia I think
04:41:08 <Axman6> jynx!
04:41:10 <Axman6> >_>
04:41:13 <ivanm> not quite
04:41:14 <Gracenotes> @wikipedia .lv
04:41:15 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=.lv
04:41:15 <Axman6> makes sense
04:41:15 <ivanm> different wording
04:41:18 <ivanm> @quote sterio
04:41:18 <lambdabot> No quotes match. My brain just exploded
04:41:22 <Gracenotes> .lv is the Internet country code top-level domain (ccTLD) for Latvia.
04:41:22 <ivanm> @quote stereo
04:41:22 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
04:41:51 <Gracenotes> @quote russia
04:41:51 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
04:41:58 <Gracenotes> @quote russia
04:41:59 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
04:42:01 <ImInYourMonad> what are implicit params? do they mean pointsfree style? like: f = (a . b) instead of f xs = a $ b xs ?
04:42:19 <Axman6> @quote soviet
04:42:19 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
04:42:20 <Baughn> ImInYourMonad: No, more like dynamic scopig
04:42:22 <Baughn> *scoping
04:42:24 <Axman6> @quote soviet
04:42:25 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
04:42:28 <Axman6> lame :\
04:42:30 <pumpkin_> BONUS: there's no list monster in the LYAH pdf :(
04:42:34 <Gracenotes> implicit params are useful for figuring out what something's type should be
04:42:43 <osfameron> list monster?
04:42:44 <pumpkin_> http://learnyouahaskell.com/listmonster.png
04:42:46 <Gracenotes> other than that, they seem rather devious
04:42:57 <Baughn> Gracenotes: Are we talking about the ?x sort of implicit parameter here?
04:43:06 <Gracenotes> yes.
04:43:21 <Baughn> Hm. I'd never thought to use them like that, but..
04:43:28 <Gracenotes> @type join ?f 4
04:43:30 <lambdabot> forall a t. (Num t, ?f::t -> t -> a) => a
04:43:42 <Gracenotes> @type \f -> join f 4
04:43:43 <lambdabot> forall a t. (Num t) => (t -> t -> a) -> a
04:43:49 <Baughn> Oh, sure
04:43:52 <Baughn> The latter is nicer, IMO
04:44:09 <quicksilver> Baughn: the former labels it in the type, though
04:44:15 <quicksilver> " ?f::t -> t -> a"
04:44:17 <Baughn> @type flip join 4
04:44:18 <lambdabot> forall a b. (Num b) => (b -> b -> a) -> a
04:44:18 <quicksilver> that's useful if you have several.
04:44:32 <Baughn> quicksilver: I suppose
04:44:32 <quicksilver> it's just a hack to get GHC to give names to 'holes' in types.
04:45:06 <Baughn> So, when do we get to use type constraints like "Maybe *"? ;)
04:45:10 <HugoDaniel> what sound do you recommend to listen while coding in haskell ?
04:45:17 <pumpkin_> HugoDaniel: brown noise
04:45:20 <HugoDaniel> :D
04:45:21 <Baughn> HugoDaniel: J-pop
04:45:28 <Botje_> trance
04:45:37 <pumpkin_> http://en.wikipedia.org/wiki/Colors_of_noise
04:45:42 <HugoDaniel> pumpkin_, so im constantly runing to the bathroom
04:45:48 <vegai> I seem to have a monopoly on both the Soviet meme and non-humour
04:45:53 <Baughn> HugoDaniel: That's the brown note, not brown noise
04:46:02 <Gracenotes> right now I'm listening to Infected Mushroom, courtesy of pumpkin
04:46:07 <pumpkin_> :)
04:46:11 <HugoDaniel> ah ok
04:46:24 <Gracenotes> classical/romantic stuff is good, so long as voices aren't invoplved
04:46:25 <vegai> HugoDaniel: Muse: Butterflies & Hurricanes
04:46:27 <Gracenotes> -p
04:46:37 <vegai> otherwise it's a bit distracting, but it's got nice lyrics
04:47:04 <Gracenotes> then there's musicals, and Muse does indeed make for good working tracks, and video game music, and... er... my whole music collection :/
04:47:04 <pumpkin_> omg Muse
04:47:19 <pumpkin_> I love playing knights of cydonia on GH3 :P
04:47:45 <quicksilver> vegai: In soviet russia, non-humour has monopoly ON YOU
04:49:25 <vegai> http://www.musewiki.org/Time_Is_Running_Out_(song)   -- also fits many situations :)
04:49:55 <Gracenotes> Muse does sound a bit processed at times ;x
04:50:11 <pumpkin_> alright, finally bedtime
04:50:20 <pumpkin_> all this muse talk is putting me to sleep
04:50:23 <Baughn> vegai: I enjoy the human voice as an instrument, but lyrics are indeed distracting. Which is why I'll pick up songs in languages I don't understand. ;)
04:50:31 <Gracenotes> good morning, pumpkin. Sleep well
04:50:55 <vegai> Baughn: a nice benefit of having English as your second language, I suppose.
04:51:01 <pumpkin_> same to you :)
04:51:06 <vegai> as my second language, that is
04:51:21 <Baughn> Mine too. What, people have it as a /first/ language?
04:51:26 <vegai> heh.
04:51:28 <ImInYourMonad> in 10 years i will have revolutionized computer vision
04:51:56 <vegai> I usually can't figure out lyrics without reading them
04:52:06 <Axman6> ImInYourMonad: good luck :)
04:53:03 <Gracenotes> on that note, I do find some Japanese songs suitable for working, although I can't comprehend the lyrics
04:53:18 <vegai> I wanted freedom / Bound and restricted / I tried to give you up / But I'm addicted
04:53:46 <vegai> yeah, that's Haskell and me.
04:55:03 <sior|oifig> dcoutts, ping?
04:55:19 <dcoutts> sior|oifig: pong?
04:55:31 <sior|oifig> dcoutts, are you in the lab?#
04:55:39 <ImInYourMonad> im gonna start a computer vision projec tin haskell now. breast cancer tumour recognition or sumpin, gonna pwn those professors liek the leet dude i am.
04:55:58 <dcoutts> sior|oifig: not now but I will be soon if you want to pop in
04:56:10 <dcoutts> sior|oifig: I'll be there in 30 min
04:56:20 <sior|oifig> dcoutts, well, I'm actually on my way out, i'll find you next week, though, if you'er in?
04:56:36 <dcoutts> sior|oifig: yep I'll be in all week
04:57:23 <sior|oifig> dcoutts, alright, sweet!
04:59:05 <HugoDaniel> how do i map over two lists ?
04:59:06 <HugoDaniel> :P
04:59:11 <HugoDaniel> map2 ? :P
04:59:34 <Baughn> > zipWith (+) [1..3] [2..4]
04:59:35 <lambdabot>   [3,5,7]
04:59:36 <Botje_> HugoDaniel: two separate maps?
05:00:05 <HugoDaniel> ah zip yes, its a good idea
05:00:05 <HugoDaniel> thanks
05:00:12 <sior|oifig> dcoutts, looks like i'll be here a little bit longer, ping me when you geti nto the lab, and I may pop in for a sec
05:00:24 <dcoutts> sior|oifig: ok
05:07:39 <mmorrow> quicksilver: i heard that middle-naming a kid either the snowman or the biohazard unicode syms is patented
05:08:18 <mmorrow> those bastards!
05:08:47 <Saizan> and first-naming?
05:08:57 <maxote> mmorrow, is patented the nuclear unicode symb?
05:08:57 <mmorrow> i think that's ok
05:09:05 <maxote> patent it!
05:09:12 <mmorrow> maxote: i'm filling out that app as we speak ;)
05:10:06 * mmorrow also patents naming an imaginary friend after any of the wingdings
05:10:24 <ivanm> mmorrow: one big patent, or a patent for each character?
05:10:40 <mmorrow> ivanm: i'm not sure yet
05:10:59 <maxote> then we will have reserved codenumbers that are owned by patents's holders.
05:11:12 <maxote> in the Unicode standard
05:11:41 * Axman6 files a patent on naming people using unicode characters, except those already patented
05:11:46 <Ferdirand> how about naming a kid with the nul character ?
05:11:52 <maxote> and we want them out of the unicode addressing
05:12:01 * mmorrow releases the lawyers
05:12:16 <ivanm> "release the hounds!"
05:13:28 <maxote> the universal codes can't be patented
05:13:59 <maxote> everyones or nones.
05:14:13 <p_l> maxote: in US they probably can
05:14:38 <maxote> Unicode can't be owned by US
05:15:03 <quicksilver> the problem with stuff that can't be patented
05:15:07 <maxote> otherwise, each country will own its own unicode
05:15:09 <quicksilver> is that they it can, in fact, be patented.
05:15:19 <quicksilver> because the system is broken, and fails to apply its own rules.
05:15:31 <maxote> and then semantic conflicts of the codes
05:15:40 <augustss> The code point are not owned by anyone, but a particular font containing a Unicode code point can be.
05:15:42 <quicksilver> 9999 out of every 10000 patents are invalid for trivial, obvious failures to obey the rules.
05:15:56 <quicksilver> maxote: I think you may be under the false impression that we are making serious points :
05:15:59 <quicksilver> :)
05:16:04 <ivanm> mmorrow: http://www.userfriendly.org/cartoons/archives/03mar/uf005301.gif
05:17:47 <quicksilver> userfriendly++
05:17:54 <quicksilver> (well, in the good old days anyway)
05:18:04 <HugoDaniel> hmm
05:18:14 <HugoDaniel> im the public domain kind of guy
05:18:23 <ivanm> quicksilver: what's wrong with it these days?
05:18:30 <quicksilver> ivanm: I felt it lost its way a bit
05:18:42 <ivanm> a bit
05:18:50 <ivanm> not as bad as General Protection Fault did, though :s
05:18:53 <quicksilver> stopped reading it about 5 years ago, or so.
05:19:37 <quicksilver> I used to read Y2K, but I felt that lost its spark round about the year 2000
05:19:41 <quicksilver> which is ironic, I suppose.
05:19:49 <ivanm> heh
05:20:08 <maxote> i will build my own smaller encoding scheme, i'll name it char-encoding=my-own-unicode-with-smiles
05:21:29 * Axman6 invites UTF-17
05:22:42 * ivanm for one welcomes our new 17-bit Unicode overlords!
05:22:44 <Axman6> invents even
05:22:54 <ivanm> well, we had the Soviet Russia jokes before.. >_>
05:23:06 <quicksilver> I ACCIDENTALLY THE WHOLE 17 BITS!
05:23:37 <ivanm> THE WHOLE 17 BITS?
05:23:45 <maxote> later, U.S. will have a grave problem, each one of the codes have tons of different semantics
05:23:50 <Axman6> data Utf17 = U17 Bool Word8 Word8
05:24:15 <p_l> Axman6: ?
05:24:20 <SamB> maxote: ?
05:24:26 <RayNbow> Axman6: why not have more symmetry and use data Utf17 = U17 Word8 Bool Word8 -- ? :p
05:24:47 <p_l> I understand UTF-9 but why the hell UTF-17?
05:25:00 <quicksilver> p_l: nobody has any serious conversations, so we're being stupid
05:25:01 <Axman6> it's an extension to UTF-16
05:25:06 <quicksilver> p_l: you may feel free to ignore us!
05:25:09 <quicksilver> dcoutts_: hi!
05:25:10 <maxote> UTF7+escape+extra Unicode stuff
05:25:13 <bremner> p_l 17 is prime
05:25:20 <dcoutts_> quicksilver: hia
05:25:25 <dcoutts_> sior|oifig: ping
05:25:41 <p_l> ehh....
05:25:47 <quicksilver> dcoutts_: I have a package with with cabal 1.2.4 failed to properly installed as --user, but with cabal 1.6 it works. Is that surprising?
05:25:52 <quicksilver> dcoutts_: (the pacakge is opengl)
05:26:02 <dcoutts_> quicksilver: it is a bit surprising, yes
05:26:24 <dcoutts_> quicksilver: as far as I know we do not pass any extra options to configure in 1.6
05:26:34 <dcoutts_> quicksilver: dud you discover anything?
05:26:37 <dcoutts_> dud/did
05:26:39 <quicksilver> dcoutts_: there's nothing complex about the setup.hs, it's just import Distribution.Simple, defaultMainWithHooks defaultUserHooks
05:26:50 <quicksilver> dcoutts_: no, there is too much I don't understand. I thought I'd mention it to you.
05:27:04 <quicksilver> it does use an autotools configure.
05:27:12 <dcoutts_> quicksilver: how does it fail?
05:27:26 <quicksilver> dcoutts_: premission denied trying to make a directory in /usr/local
05:27:56 <dcoutts_> quicksilver: were you using just runghc Setup configure --user
05:28:00 <quicksilver> yes.
05:28:08 <dcoutts_> quicksilver: ah ok, then that's not surprising :-)
05:28:11 <sior|oifig> dcoutts_, brt :)
05:28:16 <quicksilver> dcoutts_: ?
05:28:19 <maxote> UTF7 = ASCII7 + escape value + 32-bit addressing scheme of the smiles
05:28:34 <quicksilver> maxote: 4 billion smilies is enough for anyone?
05:28:40 <maxote> no
05:28:45 <maxote> UTF7 = ASCII7 + escape value + 64-bit addressing scheme of the smiles
05:28:57 <dcoutts_> quicksilver: you didn't specify the --prefix. We changed the default prefix for --user to be $HOME/.cabal in 1.4. Previously the prefix always defaulted to /usr/local
05:29:10 <dcoutts_> quicksilver: you've just been using cabal-install too long :-) you've got it easy
05:29:36 <quicksilver> dcoutts_: actually I've never used cabal-install :) I very seldom use any packages which don't come with GHC, which is why I don't understand this stuff.
05:29:50 <quicksilver> dcoutts_: I was trying to debug a bug I found in opengl, which required compiling my own version ;)
05:30:02 <ivanm> quicksilver: what, you're a traditionalist or something? :p
05:30:04 <dcoutts_> quicksilver: we thought this new default makes more sense
05:30:30 <quicksilver> dcoutts_: on which note: is there any way to run against a package without installing it at all? e.g. when you're frequently modifying it whilst debugging something?
05:30:38 <quicksilver> I couldn't see anything in the ghc options.
05:30:43 <dcoutts_> quicksilver: you can register it inplace
05:30:48 <quicksilver> I agree the new default for --prefix makes a lot more sense.
05:31:25 <quicksilver> dcoutts_: oh, that sounds like what I wanted.
05:31:32 <quicksilver> (although in the end it wasn't a huge problem to keep installing it)
05:31:45 <maxote> so, the smiles is a highly compacted database of tons of 32x32 fonts
05:31:56 <quicksilver> dcoutts_: I was worried the paths in dist/installed-pkg-config would be wrong for the inplace case
05:32:35 <quicksilver> ivanm: not really; I just don't often seem to write code which needs libraries.
05:32:53 <ivanm> quicksilver: what, you just use the Prelude and that's it? :o
05:32:54 <ivanm> ;-)
05:32:57 <quicksilver> ivanm: I tend to write exploratory experimental code, which just plays with some ideas in the context of the standard libs.
05:33:01 <ivanm> quicksilver: or is it that you don't often write code? :p
05:33:23 <quicksilver> Prelude, OpenGL, and ByteString, mostly.
05:33:31 <quicksilver> Network, perhaps.
05:33:35 <ivanm> isn't bytestring separate nowadays?
05:33:43 <quicksilver> it's still an "extralib"
05:33:48 <quicksilver> which means it comes in the big installer bundles.
05:33:56 <ivanm> ahhhhh
05:34:08 * ivanm doesn't know, because in gentoo we don't install the others as a big bundle
05:34:26 * quicksilver nods
05:34:38 <quicksilver> when I use debian, I similarly restrict myself to stuff which is apt-get installable
05:34:44 <quicksilver> that tends to be a big enough selection, though.
05:34:57 <quicksilver> but my day to day hacking is only on the train.
05:35:05 <quicksilver> and my laptop is OSX, for better or for worse.
05:35:09 <ivanm> if I need another library, I just make an ebuild for it ;-)
05:35:13 <pejo> quicksilver, better!
05:35:22 <ivanm> quicksilver: so you never use haskell at work or at home? just on the train?
05:35:38 <quicksilver> ivanm: at work, seldom.
05:35:42 <quicksilver> at home, I barely use a computer.
05:35:49 <quicksilver> my family takes my time :)
05:35:54 <ivanm> I take it you're at work now then?
05:36:01 * quicksilver nods
05:36:12 <Axman6> git back to work!
05:36:13 <ivanm> your work allows you to IRC? :o
05:36:17 <quicksilver> of course.
05:36:22 <quicksilver> IRC is a useful tool.
05:36:24 <ivanm> Axman6: is the git reference intentional?
05:36:31 <ivanm> quicksilver: what do you actually do, work-wise?
05:36:34 <Axman6> no
05:36:41 <quicksilver> IT/Management.
05:36:54 <Axman6> except that i find linux rathe runpleasent, and that was supposed to sound rathe runpleasent :P
05:37:03 <Axman6> ant? meh
05:37:56 <ivanm> quicksilver: so not really any hacking at work then?
05:38:46 <quicksilver> ivanm: not so much these days. Our code is in perl, anyway :-/
05:39:02 <ivanm> *shudder*
05:39:24 * RayNbow can no longer program in Perl
05:39:25 <ImInYourMonad> does bsd have a nice desktop env like gnome or kde?
05:39:42 <Axman6> Gnome and KDE
05:39:52 <Axman6> and Xmonad, and ...
05:39:54 <ivanm> and xfce
05:40:01 <ivanm> and pretty much any DE or WM available for linux
05:40:03 <Axman6> fluxbox
05:40:19 <dcoutts_> quicksilver: yes, dist/installed-pkg-config would be wrong for the inplace case
05:40:40 <dcoutts_> quicksilver: did you find the option? setup register --inplace
05:40:59 <ivanm> RayNbow: the only perl I've touched is trying to debug some programs my brother wrote for a subject we (unfortunately) took together
05:41:09 <quicksilver> dcoutts_: ah, no. I thought it was a ghc-pkg option.
05:41:18 <ImInYourMonad> larry wall can no longer program in perl
05:41:18 * ivanm did his in haskell, and had a dramatically smaller number of issues \o/
05:41:22 <ivanm> ImInYourMonad: :o
05:41:25 <ivanm> are you serious?
05:41:53 <dcoutts_> quicksilver: ghc-pkg does not know where the files are, except what it is told in the installed package info file.
05:41:55 <Axman6> who's larry wall?
05:42:03 <quicksilver> dcoutts_: Ah. I see.
05:42:16 <quicksilver> ivanm: if I was starting from scratch we might use haskell.
05:42:22 <ivanm> Axman6: designer of that evil pseudo-language known as Perl
05:42:32 <ivanm> quicksilver: especially if you were in charge? ;-)
05:42:37 <quicksilver> ivanm: I am.
05:42:45 <Axman6> oh, the devil. ok
05:42:50 <ivanm> were you in charge back then?
05:42:56 <ivanm> Axman6: no, just one of his many minions
05:43:13 <ivanm> Axman6: a lesser minion than the redmondian ones, though ;-)
05:43:24 <Axman6> heh
05:43:34 <quicksilver> ivanm: four years ago I made the call that perl had the most mature set of libraries (web frameworks, database connectivity, xml-rpc, soap, http, templating)
05:43:43 <Axman6> i'm sure some of the MSR peeps are in redmond
05:43:43 <pejo> I'm not actually convinced about the advantages of fp for the tasks that perl is typically used for.
05:43:45 <ivanm> :o
05:43:47 <quicksilver> ivanm: on balance I still think that was the right call, four years ago.
05:43:52 <ivanm> even more so than something like Java? :o
05:44:00 <ivanm> quicksilver: what kind of programs are they that you used Perl? actual full-on applications? web stuff? sysadmin scripts?
05:44:06 <quicksilver> ivanm: it's considerably more complicated now.
05:44:06 <pejo> quicksilver, I think you were absolutely right.
05:44:12 <ivanm> quicksilver: *nod*
05:44:22 <ivanm> because there's heaps of languages with libraries?
05:44:23 <quicksilver> Axman6: the MSR guys are in cambridge (UK)
05:44:34 <Axman6> all of them?
05:44:36 <ivanm> (though it might be premature to call Haskell's "mature")
05:44:41 <RayNbow> ivanm: I wrote Perl back in the days when it was popular for CGI stuff :p
05:44:46 <ivanm> Axman6: pretty sure they are...
05:44:48 <pejo> quicksilver, isn't Daan Leijen in the US?
05:44:48 <quicksilver> well, also in the running when I made that assessment were python, ruby, and java
05:44:55 <ivanm> Axman6: different MSR places do different stuff
05:45:02 <Axman6> i was looking at the MSR website yesterday, ad i'm pretty sure i saw people from all around the place
05:45:08 <ivanm> e.g. QUT has an MSR lab, but its for DBs IIRC...
05:45:14 <quicksilver> pejo: sure, I thought we were talking about the MSR haskell guys.
05:45:36 <ivanm> http://en.wikipedia.org/wiki/Microsoft_Research
05:45:36 * RayNbow wonders if he still has (horrible) Perl scripts from those days...
05:45:49 <ivanm> doesn't list specialities though :s
05:46:02 <quicksilver> ivanm: real applications, but server-side, with web as a key componenet.
05:46:11 <ivanm> *nod*
05:46:16 <ivanm> so not desktop-based apps?
05:46:17 <maxote> the MS center is not in US, it's in UK
05:46:19 <quicksilver> web services, netowrk services, application serves, transaction processing.
05:46:27 <maxote>  /center/research center/
05:46:30 <quicksilver> no, nothing desktop.
05:46:35 * ivanm can't think of a single mainstream desktop-based app written either primarily or fully in perl
05:46:47 <ivanm> maxote: one of them is in the UK
05:46:59 <maxote> and the another in Canada
05:47:17 <ivanm> maxote: according to that link I posted, there's none in Canada
05:47:56 <ivanm> India, China, 3*US, UK
05:48:00 <maxote> and another another in India
05:48:14 <quicksilver> ivanm: there would certainly be work involved in bringng the haskell library set up to the capabilities we need. However, if we were starting today, that work might be worth it. The benefits might still outweight the cost.
05:48:15 <ivanm> http://en.wikipedia.org/wiki/Microsoft_Research <-- no canadian ones there
05:48:20 <bremner> ivanm: dvdrip
05:48:27 <quicksilver> four years back it didn't seem close enough.
05:48:35 <ivanm> bremner: is it? :o
05:49:00 <ivanm> bremner: dvdrip or dvd::rip?
05:49:06 <ivanm> duh, same thing
05:49:10 * ivanm facepalms
05:50:49 <quicksilver> ivanm: frozen bubble is written in perl, I think. Or it was once.
05:51:27 <quicksilver> but I think it's true there aren't that many.
05:51:36 <ivanm> hmm... that MSR link on wikipedia doens't include ghc as one of the projects...
05:51:53 <Philonous> quicksilver: Using newtypes to code invariants in the type system has some unpleasant drawbacks. For example is it fiddly to encode more than one invariant.
05:52:04 <osfameron> quicksilver: is it still?  FB runs on mobile phones and other places usually immune to Perl
05:52:20 <ivanm> quicksilver: yeah, looks like it still is
05:52:23 <quicksilver> Philonous: hmm. Well it's fiddly to compose invariants if that's what you mean.
05:52:24 <daf> quicksilver: I think in many cases, choice of language comes down to who's doing the work given feature/library parity
05:52:55 <ivanm> (of course, I'm using the gentoo ebuild's dependencies to determine this, and its rare for one to include gcc as a direct dep because it's installed by default anyway)
05:53:17 <ivanm> osfameron: FB?
05:53:19 <daf> quicksilver: how would your colleagues feel?
05:53:30 <quicksilver> daf: well given that I hired them all as perl developers
05:53:35 <quicksilver> daf: "surprised" might be one word :)
05:53:38 <Philonous> quicksilver: Yes. Something like type-level predicates would solve this
05:53:39 <ivanm> lol
05:53:47 <daf> quicksilver: :)
05:53:59 <quicksilver> Philonous: you can sometimes use typeclasses for a kind of capablities thing
05:54:03 <ivanm> start up a new primarily haskellian company (which unlike well-typed actually does its own stuff, rather than consultancy)! ;-)
05:54:18 <quicksilver> Philonous: but it's not entirely straightforward.
05:55:23 <Philonous> quicksilver: I'm not sure, but this might introduce more code complexity and therefore more opportunities for error than it solves in the first place.
05:56:22 <quicksilver> Philonous: Yes. I believe you might be right.
05:56:32 <quicksilver> Philonous: The best solution does vary from case to case :)
05:56:54 <pejo> ivanm, you need a customer, or preferably several.
05:57:08 <Philonous> quicksilver: Dependent types might be what I want. I could just annotate my types with Bools and therefore have type predicated
05:57:15 <ivanm> pejo: use quicksilver's current customers... they won't know which lang the apps are written in! ;-)
05:57:39 <osfameron> ivanm: frozen bubble
05:57:50 <ivanm> osfameron: yeah, quicksilver already brought that one up ;-)
05:58:00 <ivanm> and I've already admitted that I was wrong ;-)
05:58:27 <osfameron> ivanm: yes, though I was wondering if the phone ports etc. were still Perl
05:58:30 <trofi^w> @pl \ω -> ω^ω
05:58:30 <lambdabot> (line 1, column 3):
05:58:30 <lambdabot> unexpected "\137"
05:58:30 <lambdabot> expecting letter or digit, operator, pattern or "->"
05:58:45 <maxote> Philonous, http://en.wikipedia.org/wiki/Dependent_types  <--- see the languages
06:00:16 <ivanm> osfameron: phone ports? why would the point where you plug your phone in the wall use a programming language?
06:00:46 <osfameron> silly! ;-)
06:01:06 <ivanm> oh, wait, you mean the versions running on phones?
06:01:07 <maxote> Agda, Aldor, ATS, Cayenne, Coq, Dependent ML, Epigram, NuPRL, PVS, Sage, Twelf and Xanadu <-- the languages with dependent types
06:01:16 <ivanm> I was serious about the confusion...
06:01:26 <ivanm> the usage of "port" in that sense didn't occur to me :s
06:01:50 <osfameron> heh
06:03:24 <quicksilver> actually I misread osfameron's statement the same way the first time.
06:03:32 <quicksilver> on the 4th readin my neurons clicked into gear though.
06:08:09 <Itkovian> Any idea if ghc 6.10.x can be compiled using 6.8 on FreeBSD?
06:08:41 <quicksilver> I can't see why not...
06:09:03 <quicksilver> ghc 6.10 should be able to be compiled by 6.8 or indeed 6.6 on any platform it supports, shouldn't it?
06:11:42 <Philonous> Itkovian: On x68 you can. On amd64 there are problems. There is also a freebsd haskell channel : #haskell-freebsd
06:11:50 <Philonous> x86 even
06:12:05 <Itkovian> I'm on a corei7 (Intel)
06:12:25 <Philonous> Using what arch of FreeBSD?
06:14:28 <Philonous> Would you mind to uname -a?
06:14:45 <ManateeLazyCat> How to do "Char -> a"?
06:15:24 <opqdonut> you can't :)
06:15:33 <opqdonut> without using undefined
06:16:21 <ManateeLazyCat> opqdonut: How to do "Char -> String", then i use printf String
06:16:44 <opqdonut> or just "f x = [x]" :)
06:17:35 <ManateeLazyCat> opqdonut: I use "show Char" and got 'Char', i want remove ' that around Char
06:18:12 <opqdonut> use f x = [x]
06:18:15 <opqdonut> a string is a list of chars
06:18:49 <ManateeLazyCat> opqdonut: Damnit, stupid me, why use "show c", just [c] that i want.
06:18:55 <ManateeLazyCat> opqdonut: :)
06:19:21 <Itkovian> Philonous: Dang, it says amd64
06:20:38 <RayNbow> > show 'a'
06:20:39 <lambdabot>   "'a'"
06:20:55 <RayNbow> > return 'a' :: String
06:20:56 <lambdabot>   "a"
06:21:09 <ManateeLazyCat> > ['a']
06:21:11 <lambdabot>   "a"
06:21:19 <Itkovian> checked dmesg and there it detects the CPU as a Corei7?
06:21:22 <RayNbow> > (:[]) 'a' -- monkey power
06:21:24 <lambdabot>   "a"
06:21:47 <quicksilver> Itkovian: cpu != arch
06:21:58 <quicksilver> Itkovian: you can run a corei7 CPU in 32 bit or 64 bit mode.
06:22:19 <Itkovian> quicksilver: yeah, but AMD?
06:22:31 <Itkovian> afaik the 64 bit AMD stuff is way different from the 64-bit Intel stuff
06:22:39 <p_l> Itkovian: not true
06:22:49 <Axman6> Itkovian: no it's not
06:22:50 <Itkovian> Ok, I stand corrected ;-)
06:22:59 <p_l> (except that intel misses some instructions, emulating them in microcode)
06:23:19 <Axman6> Intel started using AMD's 64 extensions
06:23:30 <yottis> ia64 aka itanium was, but the current intel 64-bit stuff is compatible (or at least ~) with amd
06:23:44 <quicksilver> Itkovian: Intel totally fluffed their 64 bit launch
06:23:50 <Axman6> p_l: what do you mean?
06:24:02 <quicksilver> AMD got an end-run
06:24:11 <quicksilver> and Intel had to implement AMD's version instead.
06:24:14 <quicksilver> it was pretty funny.
06:24:16 <Axman6> i've hears Itanium is supposed to be quite nice
06:24:23 <p_l> Axman6: only for floating point :P
06:24:25 <quicksilver> although Intel is still selling more chips.
06:24:29 <abbe> but itanium is dead yet, it it ?
06:24:31 <Itkovian> quicksilver: We should probably buy some new AMD chips for comparison ;-)
06:24:34 <quicksilver> So I guess it was a pyrhhic victory for amd.
06:24:38 <Axman6> abbe: nope
06:24:40 <abbe> s/is dea/is not dea/
06:24:46 <p_l> abbe: there are few systems relying on itanium
06:25:04 <abbe> p_l, mostly HPCs ?
06:25:16 <p_l> abbe: vms
06:25:16 * ManateeLazyCat pasted "my code" at http://paste2.org/get/163726
06:25:26 <ManateeLazyCat> can make above code more simpler? At http://paste2.org/get/163726
06:25:42 <abbe> any Itanium workstations available ?
06:25:46 <ManateeLazyCat> Just don't type ">> return False" every line.
06:25:50 <p_l> abbe: not anymore
06:26:45 <Axman6> Intel are still developing the Itanium
06:26:48 <p_l> HP is the main maker of Itanium-based stuff now, cause they bet the farm on it
06:27:16 <abbe> okay.
06:29:23 <abbe> p_l, you worked on Itanium ?
06:29:54 <p_l> abbe: nope, but got interested in it through OpenVMS
06:29:57 <byorgey> ManateeLazyCat: you can remove every single occurrence of 'do'
06:30:20 <byorgey> ManateeLazyCat: 'do x'  is the same as 'x' if x is just some expression
06:30:50 <ManateeLazyCat> byorgey: So when time use 'do' ?
06:31:20 <byorgey> ManateeLazyCat: if you have multiple lines in the do block, like
06:31:22 <byorgey> do x
06:31:24 <byorgey>    y
06:31:32 <abbe> p_l, so you know Bliss ?
06:31:33 <RayNbow> @undo do {x <- getContents ; putStrLn x }
06:31:33 <lambdabot> getContents >>= \ x -> putStrLn x
06:31:51 <fasta> ManateeLazyCat: if you get tired of using >>= and >>
06:31:53 <ManateeLazyCat> byorgey: multi-line? should multi-expression?
06:32:09 <p_l> abbe: Not yet :D
06:32:17 <byorgey> ManateeLazyCat: what do you mean by 'multi-expression'?
06:32:33 <fasta> ManateeLazyCat: just read the report and understand the translation of do-syntax.
06:32:55 <quicksilver> ManateeLazyCat: do {x ; y} is a shortcut form of x >> y
06:32:56 <Axman6> @. pl undo do {x <- getContents ; putStrLn x }
06:32:56 <lambdabot> putStrLn =<< getContents
06:33:09 <abbe> p_l, you know of any Itanium box available for free use similar to deathrow alpha clusters ?
06:33:29 <p_l> abbe: Unfortunately no. The cheapest one I had seen was £850
06:34:09 <fasta> If only circular module dependencies could be displayed in a sane manner...
06:34:40 <abbe> p_l, you mean itanium box for sale in 850 GBP ?
06:34:45 <p_l> abbe: Yip
06:34:46 <p_l> *Yup
06:35:04 <p_l> rx2600 w/ 12G of RAM and 1GHz CPU
06:35:20 <abbe> p_l, cool, I thought it'll be expensive
06:35:38 <p_l> abbe: it's a "once in a few years" deal though :D
06:35:45 <Axman6> oh, woah... just found a google tech talk by conal :)
06:35:50 <abbe> p_l, lol
06:36:02 <BONUS> Axman6: linkz0rz
06:36:11 <Axman6> http://www.youtube.com/watch?v=faJ8N0giqzw&feature=channel
06:36:20 <p_l> abbe: basically a small company that specializes in reselling "Real Computers" (in old jargon file sense) got one :-)
06:36:38 <Axman6> i'm pretty sure it's him, since it's about functional programming
06:36:40 <abbe> p_l, okay
06:37:05 <p_l> abbe: Still, If I had the money, I'd have bought it :)
06:37:21 <p_l> getting memory for my Alpha proved problematic
06:37:30 <BONUS> Axman6: also where it says "Cona Elliot" at the beginning is a big hint
06:37:51 <Axman6> well that too. that was kind of my main reason for thinking it :P
06:38:08 <ManateeLazyCat> > :t >>==
06:38:10 <lambdabot>   <no location info>: parse error on input `:'
06:38:20 <ManateeLazyCat>  :t >>==
06:38:25 <ImInYourMonad> god i hate C++.
06:38:25 <trofi^w> :t (>>=)
06:38:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:38:43 * abbe only worked on x86 derivatives :(
06:38:54 <trofi^w> it forces you to write on it?
06:39:08 <Axman6> abbe: get yourself a G5 and play with some PowerPC goodness
06:39:26 <p_l> abbe: that's the same in practice for me, but I had the luck of gettin my hands on some real RISC stuff :)
06:40:06 * Axman6 is using the first non RISC computer his family's ever owned
06:40:10 <p_l> (If I had worked longer at my old place, I would end getting access to POWER & SPARC, maybe even Alpha)
06:40:27 <Axman6> unless the Mac Plus isn;t RISC...
06:40:28 <abbe> anyone still manufacturing them for workstations or i've to look for old one ?
06:40:33 <p_l> Axman6: isn't
06:40:42 <abbe> Axman6, lol
06:41:00 <Axman6> i know, i just always hit the ; instead of ' and got sick of correcting it
06:41:58 <ManateeLazyCat> So just use 'do' when have multiple action?
06:42:04 <abbe> Axman6, this is really cool :)
06:42:06 <Philonous> Axman6: Is this the talk about fudgets-style programming?
06:42:11 <p_l> abbe: for currently manufactured workstations, there's an IBM970 4-way workstation from Yellow Dog and SiCortex PDS. There are also more and more ARM-based desktops (as well as some more obscure MIPS)
06:42:11 <ManateeLazyCat> If just one, and not need 'do'?
06:42:30 <fasta> What does it matter which machine you use? As far as I am concerned, the only interesting thing is how fast the instructions are performed and that they don't make mistakes (or at least document the probability).
06:42:42 <abbe> p_l, I don't think anyone is selling those here in India :(
06:43:42 <p_l> abbe: SiCortex would be probably happy to send them internationally, the same with Yellow Dog - "indie" workstations can't be choosers :P
06:44:21 <dancor> indi in two ways
06:44:37 <p_l> some x86-64 systems also include proper "big iron" facilities, like real system monitor etc.
06:45:29 <abbe> p_l, lol, price of 24000 USD
06:45:58 <p_l> abbe: hey, 72 cores, low power and 48G of RAM. For a price of Mac Pro. that's a good deal xD
06:46:32 <abbe> p_l, true
06:46:53 <p_l> abbe: and only 300W power usage :)
06:50:41 <p_l> as for x86-64 compatible stuff, some makers (like Sun) made small modifications to amd64 to increase I/O performance
06:51:19 <Philonous> They don't write what kind of processors, or do they?
06:52:29 <p_l> Philonous: for which one? the amd64 stuff from sun was based on Opteron, with _all_ IO busses connected, not one like most multisocket x86 systems. SiCortex runs MIPS64
06:53:04 <Philonous> Ah mips
06:53:43 <p_l> the PDS name for their workstation is cause it's a smaller version of their supercomputers, and thus usable for development and tuning of apps for those :D
06:54:21 <Workybob> argh, hit by this wierdness again
06:54:22 * ManateeLazyCat pasted "simpler " at http://paste2.org/get/163735
06:54:24 <ManateeLazyCat> I modified a simpler version
06:54:31 <Workybob> why does cabal so often fail to find the source files you specify?
06:54:32 <ManateeLazyCat> Thanks, all
06:54:46 <dcoutts_> Workybob: what do you mean?
06:55:03 <ManateeLazyCat> Workybob: cabal upgrade failed?
06:55:28 <Workybob> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2356#a2356
06:56:20 <dcoutts_> Workybob: because you spelt it wrong :-)
06:56:33 <Workybob> >.<
06:56:34 <Workybob> thank you
06:57:52 <Axman6> heh
06:58:25 <dcoutts_> perhaps it should do a string distance test ;-)
06:58:42 <Workybob> could be a good idea
06:58:56 <Workybob> either that or say which directories it found
06:59:03 <gwern> haha go tuomov!
06:59:04 <gwern> 'You may remove Ion and Riot (among my other projects) from the
06:59:05 <gwern> list of programs using Darcs (on the wiki). Reason: no version
06:59:05 <gwern> for the most viable *nix platform of the day, Cygwin.'
06:59:10 <Workybob> e.g. in that error "could not find sources for MaybeI in src/Data"
06:59:20 <dcoutts_> gwern: he is a funny one
06:59:44 <gwern> I think I'll @quote that one
06:59:47 <gwern> @quote tuomov
06:59:47 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
07:00:05 <dcoutts_> Workybob: it already says it looked in src/
07:00:10 <gwern> @remember tumov You may remove Ion and Riot (among my other projects) from the list of programs using Darcs (on the wiki). Reason: no version for the most viable *nix platform of the day, Cygwin.
07:00:10 <lambdabot> Done.
07:00:22 <gwern> @forget tumov You may remove Ion and Riot (among my other projects) from the list of programs using Darcs (on the wiki). Reason: no version for the most viable *nix platform of the day, Cygwin.
07:00:22 <lambdabot> Done.
07:00:24 <Workybob> dcoutts_: yeh, but it's not clear whether it found Data or not from the error
07:00:37 <gwern> @remember tuomov You may remove Ion and Riot (among my other projects) from the list of programs using Darcs (on the wiki). Reason: no version for the most viable *nix platform of the day, Cygwin.
07:00:37 <lambdabot> Done.
07:00:41 <gwern> @quote tuomov
07:00:41 <lambdabot> tuomov says: You may remove Ion and Riot (among my other projects) from the list of programs using Darcs (on the wiki). Reason: no version for the most viable *nix platform of the day, Cygwin.
07:00:45 <gwern> @flush
07:00:45 <Workybob> which was what I was suspecting it hadn't found, because I'd just added that
07:00:57 <dcoutts_> Workybob: well it doesn't really look for src/Data, it only looks for the whole thing
07:01:15 <Igloo> gwern: What was the difference between the first and second one?
07:01:25 <Igloo> gwern: Oh, I see, typo in the name, n/m
07:01:30 <Workybob> dcoutts_: hmm, maybe "could not find source for Data.MaybeI in src, found directories for Data/"
07:04:15 <Peaker> @type (.) . (.) . (.) . (.) . (.)
07:04:15 <lambdabot> forall a a1 a2 a3 b c a4. (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
07:04:45 <Peaker> That's pronounced: "hi"
07:05:07 <lilac> oh. i read it as five-breasted lady
07:07:20 <ImInYourMonad> what si the rgb format called when it is given by 3 or 4 values between 0 and 1?
07:09:56 <Tigran> ImInYourMonad: CMYK?
07:10:23 <abbe> ImInYourMonad, ARGB ?
07:11:50 <Baughn> ImInYourMonad: Still RGB
07:12:13 <Baughn> Using floats instead of integers just makes it easier to reason about them
07:13:43 <Deewiant> RGB just tells what the values represent, not how the values themselves are represented
07:20:23 <zandax> hello
07:20:28 <abbe> hi zandax
07:21:35 <ImInYourMonad> why isnt Control.Monad in the prelude? and Data.List?
07:21:43 <Axman6> no
07:21:52 <Axman6> only the Prelude is in the Prelude ;)
07:22:00 <ImInYourMonad> i import them in every file...
07:22:24 <ImInYourMonad> i mean available without importing...
07:22:32 <zandax> I messed around with PLT Scheme the last days and tried to create a Pac Man game. However I noticed that I couldn't stay completly functional when I want to let the game work event based (without a recursive main loop). Can somebody give me a hint how I could handle event based state transformation in Haskell? :/
07:22:46 <fasta> ImInYourMonad: module ImInYourMonad(module Data.List, module Control.Monad) where import Data.List;import Control.Monad
07:22:56 <fasta> ImInYourMonad: Problem solved.
07:30:48 <lilac> hmm. "cabal install yi" gives me "cabal: alex version >=2.0.1 && <3 is required but it could not be found.", but if i run "cabal install alex" first it works fine. cabal bug?
07:31:42 <dcoutts_> lilac: yes it's a missing feature, it doesn't track build tools yes, only libs
07:36:00 <zever> hi, http://pastebin.com/m457e0fc9 , what could be the reason for this (first time I try to actually compile anything, everything works under ghci)
07:36:31 <dcoutts_> zever: use  ghc --make
07:38:26 <zever> dcoutts_ : thx, that works :)
07:46:08 <Axman6> @seen conal
07:46:08 <lambdabot> I saw conal leaving #haskell and #ghc 1m 17d 9h 32m 45s ago, and .
07:46:20 <Axman6> o.O
07:48:04 <byorgey> Axman6: I think lambdabot's memory got wiped
07:48:10 <Axman6> yeah
07:55:11 <pastah> i need to have a variable
07:55:23 <pastah> updatable by many threads indipendently
07:55:31 <pastah> i'm looking at GHC.Conc
07:55:37 <pastah> there's TVar and MVar
07:55:57 <pastah> which should be used for what
07:56:03 <quicksilver> MVar is conceptually simpler.
07:56:06 <pastah> ok
07:56:10 <quicksilver> TVar allows you to group updates into transactions
07:56:20 <quicksilver> which guarantees a consistent view of data
07:56:27 <pastah> quicksilver: nah, doesn't seem necessary
07:57:02 <pastah> what i'm going to do is that i'm going to a var like a writer
07:57:04 <pastah> sorta
07:57:30 <Axman6> pastah: may also want to look at Chans
07:57:30 <pastah> so each tread will produce results, continiously, and i need to put them all in the same place
07:57:38 <pastah> Axman6: ??
07:57:48 <Axman6> yeah, definitely sounds like Chans might help
07:57:56 <Axman6> Control.Concurrent.Chan
07:58:43 <quicksilver> a Chan you can stuff multiple results in
07:58:49 <quicksilver> it's like a queue (or a channel!)
07:58:56 <quicksilver> MVar is just one at a time and then it blocks.
07:59:59 <pastah> chan seems cool
08:00:11 <pastah> so what i'm gonna generati is graphics
08:00:18 <pastah> (turtlegraphics)
08:00:33 <pastah> so i was thinking of having an IntMap [Line]
08:00:44 <pastah> as a var
08:01:06 <pastah> and then when i run my program and i get to the "runInParalell"-combinator
08:01:12 <pastah> i would do forkIO
08:01:37 <aeolist> sjanssen: some guy from pidgin answered both your tickets
08:02:10 <pastah> and each thread would have in it's state a "level" of how deep into the computation it is, so when doing writes it would write to the key == it's current level
08:02:27 <pastah> so drawing the graphics would appear to happend all in paralell
08:02:57 <pastah> please shoot this idea down if it seems undoable/too hard/stupid :)
08:03:23 <HugoDaniel> you gotta love it: databaseGetSearchData :: Int -> Day -> [ ((Int, Day, String, Int), [(Double, String)]) ]
08:04:08 <quicksilver> pastah: it's probably an interesting exercise
08:04:16 <HugoDaniel> i forgot the io, its like this: databaseGetSearchData :: Int -> Day -> IO [ ((Int, Day, String, Int), [(Double, String)]) ] :/
08:04:18 <quicksilver> pastah: I doubt it will actually perform well
08:04:25 <pastah> quicksilver: can you think of any pitfalls?
08:04:33 <quicksilver> pastah: the interfaces we have to our graphcis hardwar are pretty much single-threaded
08:04:57 <quicksilver> (there is much parallelism inside the graphics card, but the data submission interface is single-threaded)
08:05:06 <quicksilver> so I'm not sure "drawing in parallel" really works.
08:05:45 <pastah> what will happend if have to write two graphics at the same time from two threads?
08:05:53 <pastah> quicksilver: this is drawn using wxHaskell
08:06:08 <pastah> so i guess that it will look like this
08:06:27 <pastah> submitG g i
08:06:38 <quicksilver> I expect you can't.
08:06:44 <quicksilver> Most gui libraries require synchronisation
08:06:54 <quicksilver> (you can only make graphics calls from one thread at once)
08:07:00 <quicksilver> I don't know for sure that is true of WX
08:07:08 <quicksilver> but it is true of gtk2hs and opengl, for example.
08:07:16 <pastah> = readChan myMap >>=\m -> writeChan m $ insert i g m
08:08:08 <HugoDaniel> i feel like im going to get very rich with haskell :P
08:08:24 <zachk2> hugo: that feeling will pass when you apply for foodstamps
08:08:33 <HugoDaniel> :)
08:08:37 <HugoDaniel> rich as a person
08:08:41 <pastah> quicksilver: for that definition of writeG what would happend if two do it at the same time?
08:08:51 <zachk2> then you are correct hugodaniel
08:08:57 <pastah> will they quee up?
08:12:44 <quicksilver> pastah: well that part is fine
08:13:05 <quicksilver> pastah: although you want an MVar not a Chan for that.
08:13:15 <quicksilver> it's actually issuing graphics commands in parallel that is hard.
08:13:52 <pastah> quicksilver: that will not happend in parallell
08:14:38 <pastah> the runGraphics will take my XVar (IntMap [Line]) and draw all the lines, on that level, in sequence
08:14:57 <quicksilver> cool.
08:14:59 <quicksilver> that sounds fine then.
08:15:31 <pastah> the MVar is just for the different threads to be able to think about just generating lines, not thinking about how a collection of lines would be formed
08:15:43 <pastah> quicksilver: so what are the pitfalls with MVar?
08:16:04 <Philonous> Are their any efforts to incorporate dependent types into haskell?
08:17:01 <pejo> Philonous, Conor Mcbride advertised a phd studentship recently.
08:17:03 * pastah leaves for a short while...
08:18:01 <maltem> Philonous: no, but there will be a project going for a ghc implementation of type-level integers
08:18:43 <quicksilver> Philonous: not a full-blown system, no
08:18:51 <quicksilver> I don't think anyone has a good plan for such a thing.
08:19:07 <maltem> Philonous: and Agda2 is a dependently-typed language that can be compiled to Haskell afair
08:19:14 <quicksilver> The existing working "fully dependent type" languages all take rather different approaches.
08:19:22 <quicksilver> agda, epigram, coq
08:20:40 <Philonous> I see. thanks.
08:22:58 --- mode: Cale set -oo Cale Heffalump
08:23:34 <quicksilver> Philonous: so, the current plan is incremental, I think.
08:23:50 <quicksilver> even GHC 6.6 style type classes permit certain kinds of dependent typing.
08:24:05 <quicksilver> type families add a little more, permitting a reasonably wide class of type functions.
08:24:08 <Raevel> haha, it seems that xmobar thinks time has stopped
08:24:22 <quicksilver> GHC devs have made comments about a 'datakind' system
08:24:29 <quicksilver> and lifting lists/tuples to the type level
08:24:30 <ImInYourMonad> are data-records limited to 1 constructor?
08:24:36 <quicksilver> which will be more steps in that direction.
08:24:37 <Cale> ImInYourMonad: no
08:24:38 <quicksilver> ImInYourMonad: no
08:24:46 <quicksilver> ImInYourMonad: although in some ways they're less useful with more than one.
08:27:59 <HugoDaniel> is there any way to automatically run a function once a file is loaded on ghci ?
08:28:13 <HugoDaniel> :l Main.hs runFunc
08:28:18 <HugoDaniel> something like this ?
08:30:01 <ImInYourMonad> hmm, thanks to whoever tipped me to glfw, it is very neat
08:30:28 <ImInYourMonad> ill have my 2d shooter ready in notime :)
08:31:30 <Zao> ImInYourMonad: You're welcome :P
08:34:23 <zong_sharo> mapAccumLM op acc = foldM (\(acc, xs) x -> op acc x >>= return . fmap (:xs)) (acc, [])
08:34:23 <lambdabot> zong_sharo: You have 1 new message. '/msg lambdabot @messages' to read it.
08:34:26 <zong_sharo> amirite?
08:41:42 <zandax> I'm a beginner in Haskell and I have some problems with state transformation. I used to have a mainloop which called itself with its state as a parameter. Now I want to create an event based game (with a canvas which is redrawn in another state when a key is pressed etc.) Can somebody give me a hint how to do that? :/
08:43:25 <skorpan> zandax: specifically what do you wants hint on? state? drawing? events?
08:44:08 <quicksilver> zandax: the most natural approach will depend which UI library you're using.
08:44:10 <quicksilver> I think.
08:45:29 <zandax> I haven't startet with the program yet.  I just was disappointed that I had to use imperative programming for doing that in Scheme.
08:46:26 <zandax> Let's assume I have a callback function for the key input and I have a callback function for the canvas. Now I want to move some objects on the canvas by key presses.
08:46:47 <zandax> could be done with the WinAPI, for example
08:47:23 <Cale> Okay, assuming that, you would likely use IORefs to hold the state of the objects, and simply update those in the event handlers.
08:48:59 <Cale> (and read from them in the canvas expose handler)
08:49:16 <zandax> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-IORef.html <- these?
08:49:28 <Saizan> yes
08:49:30 <zandax> looks simple.
08:49:55 <zandax> For Haskell I expected something more elegant, but who cares :D
08:50:35 <Saizan> "working" haskell's GUI libraries are just wraps around C ones, which are designed to be used imperatively
08:50:52 <dons> well.
08:50:58 <dons> to some approximation
08:51:13 <quicksilver> zandax: there is an interesting idea called functional reactive programming which gives a possibly cleaner interface.
08:51:16 <Saizan> you can abstract the use of IORefs behind a MonadState interface, though
08:51:28 <quicksilver> zandax: for example, keypresses might be represented as a 'stream of key events' Event Key.
08:51:41 <quicksilver> however, none of those interesting ideas are entirely ready for prime-time.
08:51:50 <zandax> :(
08:51:56 <dons> where prime-time means putting in a missle?
08:52:20 <dons> they're ready for alpha users
08:53:01 <zandax> I understand that these libraries were made for imperative languages. But I could not imagine a different system which works as efficient as an event based one.
08:53:16 <kiris> BONUS: ping
08:53:35 <BONUS> zing
08:53:46 <kiris> what did you write Learn You with?
08:53:52 <BONUS> my own hands
08:53:57 <dqd> Haha.
08:53:57 <tromp_> @hoogle ShowS
08:53:57 <lambdabot> Prelude type ShowS = String -> String
08:53:57 <lambdabot> Text.Show type ShowS = String -> String
08:53:57 <lambdabot> Prelude shows :: Show a => a -> ShowS
08:53:57 <quicksilver> zandax: "event-based" means different things to different people
08:54:01 <kiris> ~_~"
08:54:09 <BONUS> haha. you mean like text editor?
08:54:13 <quicksilver> zandax: since a key being pressed is what we mean by an event, then sure, all the interfaces are event-based
08:54:16 <tromp_> hmm, ghci doesn't see ShowS in the Prelude
08:54:18 <kiris> no, what produced the html pages
08:54:29 <BONUS> ah. it's actually kind of embarassing. you see .. PHP
08:54:34 <quicksilver> zandax: but some don't have to be callback/mutable reference based
08:54:36 <kiris> oh, nevermind then
08:54:41 <BONUS> but all i do is just include the sub-pages in the main template
08:55:33 <kiris> dons: wht did you write RWH with?
08:56:01 <dqd> RWH is written in DocBook.
08:56:11 <zandax> quicksilver: But how could I write a program with different states without a recursive loop? Could you explain me? (I am new to functional programming)
08:56:27 <kiris> hum
08:58:06 <quicksilver> zandax: in a slightly more declarative style.
08:58:16 <quicksilver> zandax: you work with "Behaviours" (values which change over time)
08:58:27 <quicksilver> zandax: and "Events" (discrete events which occur over time)
08:58:31 <quicksilver> and you combine them at a high level
08:58:35 <quicksilver> there is no explicit looping
08:58:52 <quicksilver> just the combination of input behaviours/events into an output behaviour (presumably your graphical display)
08:59:22 <quicksilver> I'm not sure if there is a really good introduction to this stuff:
08:59:23 <quicksilver> http://www.haskell.org/haskellwiki/Reactive
08:59:45 <quicksilver> I managed to grok it by reading conal's paper about 15 times and arguing with beelsebob repeatedly until it got into my thick skull.
08:59:47 <zandax> Interesting! And it is not possible to combine such a system with the OS callbacks?
08:59:51 <quicksilver> I would hope there is an easier route.
09:04:49 <skorpan> what was the name of that one french matematician who became like 21 years old and got killed in a duel?
09:05:25 <goomba> galois
09:06:08 <skorpan> right, thanks
09:06:23 <quicksilver> he was named after the company dons works for.
09:06:25 <skorpan> geez, he never even turned 21
09:06:38 <p_l> lol @ quicksilver
09:08:34 <fasta> quicksilver: I think it's the other way around.
09:08:37 <fasta> quicksilver: :D
09:09:34 <quicksilver> fasta: later this century, dons will use haskell to design a time machine. He will go back in time to a certain french family brining them futuristic gifts, and in return they will name their firstborn son.
09:09:46 <quicksilver> and so the wheel turns.
09:10:05 <p_l> and the ages come and turn past ;-)
09:13:02 <fasta> quicksilver: naming your son McDonald after McDonald's is kind of lame, though.
09:14:06 <quicksilver> Yes. That's really sad.
09:14:23 <quicksilver> If you're going to do that, at least call him McNugget.
09:14:38 <mornfall> Fortunately, you are fairly unlikely to construct a time machine using a hamburger.
09:14:52 <goomba> you could save galois's life if you had a time machine
09:15:02 <goomba> or would it create a paradox
09:15:13 <quicksilver> goomba: his mathematics would be so much less poignant if he hadn't died young.
09:15:15 <kiris> Back to France, 1800s: II
09:15:24 <moonlite> quicksilver: and later he will travel back in time for that duel?
09:15:27 <mornfall> goomba: It would screw up fabric of time, yes. :)
09:15:35 <quicksilver> I wouldn't have enjoyed my lecture course on galois theory anything like as much without the tragedy.
09:15:44 <ImInYourMonad> im using the example from glfw to do my game, the example uses IORef for the application-state. is that a good idea for a game? to keep the game-state in an IORef? or should i use something else?
09:15:53 <kiris> quicksilver: Oh, what could have been!
09:15:54 <quicksilver> ImInYourMonad: it's a reasonable idea.
09:16:05 <quicksilver> ImInYourMonad: you need some way to "feed it through the callback"
09:16:15 <fasta> goomba: according to current theories it is impossible to do so, then again, I don't really believe in time-machines like they think of them in physics. The one that designed this universe can do so, though.
09:16:24 <kiris> (except he seemed like a bit of a douche so it his demise seemed inevitable to me)
09:16:40 <quicksilver> with a little experience you may prefer to use state monads, but there will still be an IORef behind the scenes.
09:16:58 <quicksilver> since callbacks sit in IO, we have to use IO's mechanisms to tunnel data through them.
09:17:19 <quicksilver> there is a mailing list posting about this which google periodically finds and then loses again.
09:17:23 <quicksilver> @go monadic tunnelling
09:17:23 <lambdabot> No Result Found.
09:17:28 <BMeph> I imagine if you gave Galois a Lexan undershirt, and then put him in a "Witness Protection"-type program, maybe move him to Switzerland, it could work. :)
09:17:31 <quicksilver> seems today is a "lose" day.
09:21:18 <BMeph> quicksilver: http://sequence.complete.org/hwn/20080731
09:21:54 <quicksilver> ah, is it the inconsistency in my number of ls?
09:21:57 <quicksilver> @go monadic tunneling
09:21:58 <lambdabot> No Result Found.
09:22:04 <quicksilver> nope. It's just @go being odd.
09:24:42 <BMeph> quicksilver: At least Google's not saying, "Maybe you meant: monadic /chunneling/" ;)
09:25:08 <quicksilver> ;)
09:28:23 <mmorrow> preflex: seen ddarius
09:28:31 <mmorrow> @seen ddarius
09:28:31 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah and #haskell-overflow 1m 17d 10h 59m 20s ago, and .
09:29:16 <mmorrow> here's the start of an ML module system QQs + THery http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1873#a1873
09:30:22 <mmorrow> i need to get organized and i think this'll help
09:30:23 <TomMD> Axman6: If your still up, yes I posted the thread pools blog.
09:31:18 <mmorrow> here's the datatype that's going into: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1873#a1874
09:31:19 <byorgey> TomMD: cool, so you're at Portland State now?
09:31:32 <TomMD> Yep
09:31:36 <byorgey> doing a PhD?
09:31:48 <TomMD> Exactly.  And I have three weeks before courses
09:31:51 <mmorrow> if anyone has any ideas/suggestions, i'd love to hear them :)
09:32:12 <quicksilver> mmorrow: that's quite interesting.
09:32:15 <byorgey> TomMD: awesome.
09:32:22 <Saizan> mmorrow: what's their type?
09:32:32 <TomMD> byorgey: Your still at Penn, right?
09:32:33 <mmorrow> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1873#a1874
09:32:47 <byorgey> TomMD: right
09:33:04 <mmorrow> so i'm using haskell-src-meta's translation from haskell-src-exts syntax + Lift-stuff
09:33:04 <byorgey> and will be for the next 5 years or so =)
09:33:31 <mmorrow> and i'm abusing the fact that you can have empty data decls, and am using them as "specifications"
09:33:31 <TomMD> byorgey: Right, you were just starting after you gave that xmonad speech.
09:33:49 <TomMD> byorgey: Weren't you making your own language at one point?
09:33:59 <mmorrow> then in the structs, i'm just going to treat type syns as definitions for the corresponding empty data decls in the sig
09:34:26 <Saizan> and the type of strStk?
09:34:35 <byorgey> TomMD: well, my advisor (Stephanie Weirich) has funding for a project developing a new dependently typed language
09:34:43 <byorgey> TomMD: I may work on that in the future
09:34:46 <mmorrow> my initial idea is just to take a struct and a sig, merge them, then that could be spliced into a module or something
09:35:04 <mmorrow> Saizan: currently sig===struct
09:35:19 <Saizan> ah
09:35:30 <mmorrow> Saizan: but that's just because i haven't thought of what struct should be
09:35:46 <mmorrow> (or even if i should bother making it something else)
09:35:52 <TomMD> byorgey: Do dependently typed languages necessitate the programmer write theroms or is that only a weakness of the ones I have seen?
09:37:02 <quicksilver> TomMD: it is essentially necessary.
09:37:04 <mmorrow> Saizan: oh, so  [$sig|....|] :: Sig Name
09:37:17 <quicksilver> TomMD: although of course we all hope that the "System" can help you write the theorem.
09:37:22 <quicksilver> that was the key motivation behind epigram
09:37:27 <quicksilver> (make as much as possible automatic)
09:37:32 <mmorrow> (i forgot that it's parameterized by `b')
09:38:01 <TomMD> quicksilver: Of coarse.  I was just wondering if, for any useful dependant typing, it is always going to require non-trivial programmer interaction such as proofs.
09:38:05 <BMeph> TomMD: Welcome to "the Left Coast"! :)
09:38:16 <ImInYourMonad> im having some trouble with getting key input, it works fien for the mouse but isnt there something like last-pressed instead of checking explicitly for keys if they are pressed or released? (talking opengl + glfw here)
09:38:30 <TomMD> Type systems are nice because (I personally) consider type annoitations trivial for the programmer.
09:38:38 <TomMD> BMeph: Thanks!  Good to be here.
09:39:05 <TomMD> BMeph: Do I recall correctly that you are in Seattle, or is that too far north?
09:39:43 <BMeph> TomMD: Definitely too far, I'm the other direction, San Diego. :)
09:40:14 <TomMD> Ahh, drat.  San Diego is not 3 hours from Portland, so I guess you don't make the tech talks they have here.
09:42:07 <quicksilver> TomMD: I think it's an open question how much "useful" you can do without having to do any "hard" theorem proving work.
09:43:13 <roconnor> > 1225-36
09:43:15 <lambdabot>   1189
09:43:26 <roconnor> > 1225-36 + 2009
09:43:27 <lambdabot>   3198
09:43:29 <Philippa_> quicksilver: I'm already getting the impression that it depends a lot on what libs you have to hand. General proofs are your friend
09:43:59 --- mode: ChanServ set +o glguy
09:44:00 <glguy> unban 1
09:44:02 --- mode: glguy set -b *!*@gateway/web/ajax/mibbit.com/x-db7ccbb01cae375e
09:44:04 --- mode: glguy set -o glguy
09:44:13 <Philippa_> I get the feeling that for a lot of rote tasks, thee longterm answer should be "most of your day-to-day work"
09:44:27 <quicksilver> Philippa_: I find that intuitively convincing.
09:44:42 <quicksilver> Philippa_: but it's oustide my personal experience.
09:45:06 <quicksilver> I'm sad epigram's progress has been slow. I was very impressed with many of conor's ideas.
09:49:47 <byorgey> TomMD: however, because of Curry-Howard, in some sense you are writing theorems and proving them every time you write a Haskell program.
09:50:21 <byorgey> dependent types just let you express more.
09:50:58 <byorgey> there doesn't have to be some sort of conceptual break between "writing programs" and the supposedly more difficult process of "proving theorems".
09:51:59 <mercury^> quicksilver: Do you know anything about the progress of the DTYPE project?
09:52:13 <quicksilver> I'd not heard of it until this moment ;)
09:52:30 <Mzzz> Hi, in A Gentle Introduction to Haskell, page 19, there is an example that uses pattern binding, fib@(1:tfib), and it says the example won't work if pattern binding is not lazy, but I don't think so, someone has an answer?
09:52:52 <mercury^> I've only seen the paper stating the goals, which made be all enthusiastic.
09:52:58 <mercury^> Can't find anything else.
09:53:13 <quicksilver> sounds like a proposal for a research working group
09:53:17 <quicksilver> or whatever they are called
09:54:15 <fasta> What's the best (or just a very good) example program in any of the dependently typed programming languages?
09:54:36 <lilac> Mzzz: what's the full example?
09:56:30 <Mzzz> fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
09:57:50 <c_wraith> Mzzz, that list is infinite
09:58:09 <c_wraith> It can't work unless it's lazy, and that includes both fib and tfib
09:58:56 <c_wraith> if it wasn't lazy, it would attempt to fully evaluate the binding, which means fully evaluating both fib and tfib.
09:59:06 <c_wraith> that would run out of memory, clearly.
09:59:06 <mattam> fasta: depends on your audience. Euclidian division, matrix multiplication, verified type-checkers...
09:59:13 <mattam> fasta: You can find many nice examples in the Epigram lecture notes.
09:59:25 <fasta> mattam: a graph algorithm ;)
09:59:49 <RayNbow> > let fibs@(1:tfibs) = 1 : 1 : [ a+b | a <- fibs | b <- tfibs ]   in   fibs    -- parallel list comprehension extension
09:59:50 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:00:15 <Mzzz> c_wraith: But I'm talking about the patten matching
10:00:54 <mercury^> Hmm, is there a way to make the tfib local to that definition?
10:01:14 <mattam> fasta: Graphs are very general, dependent types are really about the fine structure.
10:01:41 <Mzzz> for example, is pattern binding is strict, will 'take 10 fib' work?
10:02:03 <Mzzz> for example, if pattern binding is strict, will 'take 10 fib' work?
10:02:12 <fasta> mattam: there exists proofs of correctness for lots of graph algorithms. If dependent types have a similar purpose, then where are all the proofs?
10:02:25 <fasta> exist*
10:05:14 <mattam> fasta: Well, you can always write "simply-typed" code and use the dependent types afterwards to reason on this code. That's how traditional proofs with dependent types work in e.g. Coq.
10:05:52 <fasta> mattam: do you have a link to an example of exactly that?
10:06:15 <mattam> You can also build the correctness criteria in the type of your function and simultaneously define it and prove it.
10:09:54 <maxote> is epigram the best depent-type programming language? or is ATS language?
10:10:15 <dons> ATS is a systems language
10:10:15 <mattam> Not with graph algorithms, but for a quicksort: http://mattam.org/repos/coq/misc/sort/quicksort.html
10:14:30 <Baughn> "(zipWith (*) `on` read) <$> getLine <*> getLine" <-- Is there a way I can avoid duplicating getLine?
10:14:38 <fasta> mattam: This seems to be a whole lot more trivial than that. http://en.wikipedia.org/wiki/Weakest_precondition
10:15:46 <quicksilver> Baughn: replicateM 2 getLine?
10:16:11 <Saizan> liftM2 (zipWith (*) `on` read) `join` getLine
10:16:13 <Baughn> quicksilver: That would be more concise than what I've already got, I mean. ;)
10:16:17 <Guest93133> hello
10:16:32 <quicksilver> Saizan: that doesn't execute getLine twice, does it?
10:16:46 <Saizan> sure it does
10:16:53 <fasta> mattam: for example, one doesn't need to know what Leibniz equality is.
10:16:54 <quicksilver> :t liftM2 (zipWith (*) `on` read) `join` getLine
10:16:55 <lambdabot> forall a. (Read a, Num a) => IO [a]
10:17:05 <Baughn> It does
10:17:22 <jmcarthur> maxote, "best" is hard to quantify for researchy areas
10:17:33 <jmcarthur> maxote, my favorite at the moment is Agda
10:17:36 <quicksilver> :t join (liftM2 (zipWith (*) `on` read))
10:17:37 <lambdabot> forall a (m :: * -> *). (Monad m, Read a, Num a) => m String -> m [a]
10:18:08 * quicksilver looks baffled.
10:18:10 <ddarius> Baughn: What you have is probably the clearest, shortest, and most maintainable rendition.
10:18:12 <quicksilver> Saizan: which monad is that `join` in ?
10:18:18 <dolio> Reader.
10:18:29 <Baughn> ddarius: Perhaps, but I want to at least understand Saizan's
10:18:32 <quicksilver> ah yes.
10:18:34 * quicksilver follows it now.
10:18:36 <quicksilver> dolio: thanks.
10:18:43 <Baughn> :t liftM2 (zipWith (*) `on` read)
10:18:44 <lambdabot> forall a (m :: * -> *). (Monad m, Read a, Num a) => m String -> m String -> m [a]
10:19:28 <cycloid> ghc can be very mean to newbies: mistakenly capitalize "import" and you get "parse error (possibly incorrect indentation)" pointing somewhere later in your code.  :-(  .
10:19:36 <cycloid> Sorry, just had to gripe.
10:20:01 <quicksilver> cycloid: true. GHC's error messages can be mean.
10:20:27 <mattam> fasta: it's not a pedagogical example :) As I said, you may find some in Conor's notes.
10:21:00 <fasta> mattam: I think I already read those years ago.
10:21:02 <dons> cycloid: compilers are generally mean if you put mistakes in.
10:21:40 <cycloid> mind you, it's better than "parse error at eof" that I used to see from a compiler which won't be named. :-)
10:21:45 <osfameron> it's possible to be a little gentle by reporting the *actual* error though
10:21:57 <osfameron> cycloid: heh, or BASIC with its "SYNTAX ERROR"? ;-)
10:22:29 <Baughn> > join (*) 2
10:22:31 <lambdabot>   4
10:23:07 <Baughn> Hm. Right, but it passes getLine twice, not getLine's /result/.. right.
10:24:24 <IRCstolemymonad> <interactive>: warning: too many hs_exit()s ; anyoen know why that is? it is in opengl and glfw, when doing keycalllbacks.
10:34:07 <IRCstolemymonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2359#a2359 <- why does that work? should waitForPress just loop endlessly?
10:34:40 <quicksilver> I don't think you're supposed to call waitForPress from inside the callback
10:34:47 <quicksilver> you're supposed to just let the callback return
10:34:55 <quicksilver> that's probably why you're getting too many hs_exits
10:35:01 <quicksilver> but I've not used glfw
10:35:40 <jmcarthur> quicksilver, i have, and your explanation sounds about right to me
10:36:31 <jmcarthur> glfw offers both callbacks and polling functions so that you can design your loop however you want, but the two shouldn't really be used together
10:38:30 <ehird> Vintage BASIC would be so much better with DRAW.
10:39:04 <lament> and PLAY!
10:44:29 <Chani> ok, so.... I have data structures that need several other data structures, but I don't get the later ones until, well, later... how do I create data a bit at a time...?
10:44:58 <Chani> data Program = Program Dclrow Stmrow deriving Show
10:45:16 <Baughn> Laziness?
10:46:00 <Chani> ^^ I need to create a Program by the time my code's done, but I don't have Dclrow or Stmrow yet, both depend on parsing the same stream of data
10:46:40 <Baughn> Right, then why don't you move the Dclrow/Stmrow creations up above, so you can use them in Program?
10:46:41 <Gracenotes> Chani: well, Program is a function :: Dclrow -> Stmrow -> Program
10:46:50 <Gracenotes> so it can be partially applied
10:46:51 <lament> createProgram stream = Program (makeDclrow stream) (makeStmrow stream)
10:46:55 <Chani> Baughn: there is no "above"
10:46:57 <Botje_> Chani: you could stub them out like so: data Dclrow = Dclrow
10:47:04 <Chani> Gracenotes: that's probably whta I want
10:47:08 <Botje_> then fill in the members later
10:47:30 <Baughn> Chani: If you use partial application, you won't be able to /read/ the structure until it's complete
10:47:34 <Gracenotes> Chani: yeah. The thing with partial application is that it's still a function, not a complete data structure
10:47:46 <Gracenotes> and also it requires a certain order
10:47:58 <Chani> lament: trhe problem: (makeStmrow stream) is wrong, because it'll get the input meant for dclrow. I have to give makeStmrow the data remaining *after* makedclrow has eaten part of it
10:48:29 <Gracenotes> so you want mutable variables, essentially?
10:48:55 <Chani> it doesn't matter that I can't read it until it's complete because it'll be complete by the end, assuming htere are no errors in the program it's parsing
10:49:06 <Baughn> Chani: Typically, you'll want to separate the I/O code from the structure-building code
10:49:30 <Gracenotes> what sort of stream is it? From a file, or a network..?
10:49:33 <Chani> Gracenotes: either that or a way to pass some of the output of makedclrow into makestmrow
10:49:54 <mperillo> hi
10:49:56 <lament> Chani: makedclrow could return a tuple consisting of dclrow and the remainder of the stream
10:50:04 <Gracenotes> @type partition
10:50:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:50:09 <mperillo> what function can I use with signature: (a, IO b) -> IO (a, b) ?
10:50:17 <Baughn> Chani: For example.. how large is this input, typically?
10:50:20 <Chani> Baughn: well, the "I/O" is actually a list of Tokens and a rather suboptimal algorithm for parsing them. I have to use a specific algorithm for the assignment
10:51:08 <Baughn> Chani: Is there any real reason why you can't just read the whole thing into memory first, and /then/ parse it in whatever order you feel like?
10:51:17 <Chani> Baughn: not large. I'm writing a parser for a toy language.
10:51:25 <Gracenotes> @type \(a, b) -> liftM ((,) a) b
10:51:26 <lambdabot> forall t a1 (m :: * -> *). (Monad m) => (t, m a1) -> m (t, a1)
10:51:33 <Chani> Baughn: because the assignment says I have to use a specific algorithm
10:51:36 <Gracenotes> @pl \(a, b) -> liftM ((,) a) b
10:51:37 <lambdabot> uncurry (fmap . (,))
10:51:44 <Chani> and this really wasn't meant for a functional language'
10:51:49 <Gracenotes> oh, neat
10:52:08 <Baughn> Chani: Well, so you want to build up two distinct data structures incrementally, using the same token source..
10:52:26 <Chani> Baughn: I guesss so
10:52:37 <mperillo> Gracenotes, thanks
10:52:53 <Baughn> Chani: No big deal. Something like a Writer with two data sinks, would do it.
10:52:55 <Gracenotes> mperillo: so something like "uncurry (liftM . (,))" would work. However, all it means is: if you have an (a, b) with, just do { b' <- b; return (a, b') }
10:52:56 <Chani> build one, eating the tokesn, build the next with whatever tokens it didn't eat...
10:53:05 <Gracenotes> @src liftM
10:53:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:53:12 <Gracenotes> it's just a shortcut :)
10:53:20 <Baughn> Chani: Hm. That's not simultaneously, then..
10:53:29 <Chani> note that I have a bunch of other data structures below the ones I mentioned
10:53:34 <Baughn> Chani: Most obvious way would be to have the first /return/ whatever tokens it didn't eat
10:53:45 <Baughn> Along with the parsed structure
10:53:57 <mperillo> Gracenotes, yes, I now that I can use the do notation, but I was hoping for a more compact solution
10:54:18 <Chani> Baughn: but then how to I get that returned data into makestmrow?
10:54:21 <Gracenotes> *nods*
10:55:22 <bogner> anyone know where the module "SelfSim" comes from? I just installed haskore from cabal and don't seem to have it, but it's in the examples
10:55:28 <Baughn> Chani: I'd have to see your code to be sure, but what's wrong with "let (dclRow, rest) = makeDclRow data in Program dclRow (makeStmtRow rest)"?
10:55:53 <Chani> Baughn: ahhh. I don't lknow how to use "let" properly yet :)
10:55:55 <Baughn> Chani: Or something like that. If it doesn't match your exact structure, there are all sorts of variations
10:56:05 <Chani> that's probably the key
10:56:33 <Baughn> Chani: One neat bit with let, order doesn't matter whatsoever; /everything/ is in the same scope, and can be used to define each other if necessary
10:56:41 <Baughn> Though this variant is simple enough
10:56:46 <Chani> intereting./
10:57:15 <Chani> ok... my next probalem will probably be figuring out which constructor to use for hte less trivial data. but I think I know how to do that
10:57:26 <Chani> mmmm, code
10:57:35 <Baughn> Chani: Ah.. You've read and understood the standard fibonnaci laziness show-horse, I suppose?
10:57:48 <bogner> oh, nevermind, i figured it out
10:59:09 <Baughn> > take 5 $ fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
10:59:11 <lambdabot>   [0,1,1,2,3]
10:59:44 <Sekaino> @penis 1,1,2,3
10:59:44 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
10:59:44 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:00:14 <Sekaino> > let fibs = 1 : scanl (+) 1 fibs in fibs
11:00:15 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:02:51 <Baughn> > fix ((0:) . (1:) . scanl (+) 1)
11:02:52 <lambdabot>   [0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,2745...
11:03:18 <Baughn> ..wait, that's not right...
11:03:37 <Baughn> @oeis [0,1,1,1,2,3,4,6,9]
11:03:37 <lambdabot>  Sequence not found.
11:03:51 <Baughn> @oeis 0,1,1,1,2,3,4,6,9
11:03:52 <lambdabot>  Expansion of (1-x)/(1-x-x^3).
11:03:52 <lambdabot>  [1,0,0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,2...
11:04:08 * Baughn blinks
11:05:04 <LeoD> @oeis 1,1,2,3,5,8,13
11:05:05 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
11:05:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:05:08 <LeoD> yay
11:05:22 <trofi> @oeis 1 2 3 4 5 6
11:05:28 <lambdabot>  The natural numbers. Also called the whole numbers, the counting numbers or ...
11:05:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:05:33 <EvilTerran> > fix ((0:) . (1:) . (zipWith (+) <*> tail))
11:05:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:05:56 <Gracenotes> i c wat u did thar
11:06:05 <Baughn> I'm not sure I do. Reader monad?
11:06:20 <EvilTerran> yup
11:06:25 <Gracenotes> huh?
11:06:38 <Gracenotes> the use of <*> is just nice pointless sugar :)
11:06:45 <rio> LeoD: oh hi, you just discovered the fibonacci numbers
11:06:54 <Chani> o.0
11:06:58 <LeoD> rio: yay :D:D:D
11:06:59 <Baughn> Gracenotes: Sugar for what, exactly? -_-
11:07:02 <Botje_> perhaps we should award achievement badges
11:07:06 <EvilTerran> > ((f :: Expr -> Expr -> Expr) <*> g) x
11:07:07 <lambdabot>   f x (g x)
11:07:18 <Botje_> could go well with the RPG idea :)
11:07:26 * edwardk still wants to be able to say: fix $ \f -> 1 `fby` 1 `fby` codo (x :> y :> _) <- f; x + y
11:07:30 <Botje_> "grasped monads" "wrote fib in a non-obvious fashion"
11:07:41 <Gracenotes> yep, as with the Exprs. So it just means (\xs -> zipWith (+) xs (tail xs))
11:07:45 <Gracenotes> @Baughn
11:07:46 <lambdabot> Unknown command, try @list
11:07:49 <Gracenotes> :x
11:07:49 <Botje_> "wrote a monad tutorial", obviously :)
11:08:00 <Chani> hrm
11:08:00 <Gracenotes> @type (<*>)
11:08:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:08:10 <Baughn> Botje_: Except a lot of the monad tutorials reveal a lack of understanding ^_^
11:08:21 <lament> monads are like gerbils
11:08:23 <Gracenotes> that's an Applicative. A function is an instance of an Applicative, like (r->)
11:08:39 <Gracenotes> so (r -> a -> b) -> (r -> a) -> (r -> b) :D
11:08:40 <Botje_> Baughn: fine, have a separate badge for "wrote a monad tutorial not involving metaphors"
11:08:53 <EvilTerran> Baughn, indeed; writing a monad tutorial (and then getting told how you're wrong by the community) is a very useful learning exercise
11:08:58 <edwardk> would a comonad tutorial count? ;)
11:09:00 <Gracenotes> oh, it's like Reader in that sense, function applicative
11:09:05 <lament> I think I deserve a badge for "wrote a monad tutorial and never released it to the public"
11:09:08 <Botje_> edwardk: you'd have a cobadge for that
11:09:09 <Gracenotes> lament: you just want to squeeze them to death, they're so cute? :D
11:09:16 <lament> Gracenotes: yes.
11:09:27 <edwardk> woot, can i use my cobadges to cancel your badge? or are they just equal and opposite?
11:09:27 <Baughn> Do I get a badge for "Explained monads to category theory teacher"?
11:09:30 <BONUS> it would be nice if you could do @type for some expression but tell it to replace every type variable thats bounded by a class constraint with an actualy type (constructor)
11:09:39 <BONUS> so that you could say give me (>>=) for Maybe
11:09:49 <Chani> I think my code accidentally changed the algorithm to be more bottom-up than top-down
11:10:06 <Botje_> edwardk: they have a different color, obviously
11:10:15 <Baughn> Chani: Rule one of haskell, imperative algorithms do not translate.
11:10:16 <Gracenotes> BONUS: that would be nice... it's simple enough to do on paper/in your favorite text editor, but still manual
11:10:20 <Chani> is there a way I can pass the incomplete Program along to another function?
11:10:31 <BONUS> Gracenotes: yeah exactly
11:10:46 <edwardk> botje: and what about an adjunction tutorial, wouldn't that give you pieces that you could assemble into a badge or a cobadge by putting them together in different orders?
11:10:46 <Botje_> Chani: "incomplete program?"
11:10:54 <Baughn> Chani: It's just another function.
11:11:01 <Chani> ok, the function then
11:11:01 <Botje_> edwardk: uh .. *looks around* yes?
11:11:20 <Botje_> cat. theory still scares me a bit
11:11:27 <Botje_> but i'm braving the catsters, one video at a time!
11:11:33 <edwardk> hah
11:11:41 <Gracenotes> @quote kitty
11:11:42 <lambdabot> No quotes match. Maybe you made a typo?
11:11:47 <Gracenotes> no you did
11:11:48 <Gracenotes> :(
11:12:14 <edwardk> Botje_: there was  catsters video series on string diagrams iirc, that covered a nice visual way to see a relationship between adjunctions and monads
11:12:19 <Chani> Baughn: I'm not really sure how to pass a function around
11:12:58 <Baughn> Chani: You don't need to do anything special. Pass it like any other value.
11:13:12 <BONUS> > zipWith (+) [1,2,3] [4,5,6]
11:13:15 <lambdabot>   [5,7,9]
11:13:17 <BONUS> (+) is the function i just passed
11:13:22 <BONUS> you could also do
11:13:35 <trofi> > map (+1) [1,2,3]
11:13:36 <lambdabot>   [2,3,4]
11:13:46 <BONUS> > map negate [1,2,3,4]
11:13:47 <lambdabot>   [-1,-2,-3,-4]
11:13:47 <Baughn> > map ($ 2) [(+1),(*2),(*3)]
11:13:48 <lambdabot>   [3,4,6]
11:13:51 <Chani> it'd be neat if there was some way to start with Program (foo) (foo) and then say "replace the first foo with Dclrow (foo) (foo)"
11:13:53 <BONUS> negate is the function
11:13:58 <tromp_> map succ "succ"
11:14:05 <tromp_> > map succ "succ"
11:14:06 <lambdabot>   "tvdd"
11:14:11 <Baughn> Chani: You can always just make a new Program
11:14:21 <Chani> I think if I tried to just tack things on hte end haskell would get confused about which arguments go with which constructors
11:14:23 <Trinithis> how would I update my Data.List library?
11:14:36 <Chani> Baughn: hmm?
11:14:38 <Gracenotes> > map (flip id 2) [(+1),(*2),(*3)]
11:14:39 <trofi> @hoogle Data.List
11:14:39 <lambdabot> module Data.List
11:14:39 <lambdabot> package list-extras
11:14:39 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
11:14:39 <lambdabot>   [3,4,6]
11:14:42 <edwardk> > map pred "WNT"
11:14:43 <lambdabot>   "VMS"
11:14:55 <Baughn> Chani: Haskell wouldn't get confused. You might, of course. :P
11:15:05 <Gracenotes> > map (flip id 2) [(+1), (+2), (+3)]
11:15:06 <lambdabot>   [3,4,5]
11:15:21 <Baughn> Chani: Well, instead of /changing/ the Program, you could make a new one derived from the old one
11:15:22 <trofi> > map const [1..]
11:15:23 <lambdabot>       Overlapping instances for Show (b -> a)
11:15:23 <lambdabot>        arising from a use of `s...
11:15:42 <trofi> :t (const id)
11:15:43 <Chani> Baughn: I mean... something like Program Dclrow foo bar Stmrow foo bar... haskell tends to think that I'm trying to make a Program with 6 argumenst
11:15:43 <Baughn> Chani: You can also pass arguments to any function in any order, though it won't produce a value until you've passed all of them
11:15:46 <lambdabot> forall a b. b -> a -> a
11:15:51 <Gracenotes> const id == flip const
11:15:52 <tromp_> you ca write ($2), Gracenotes
11:15:54 <Gracenotes> > map (flip id 100 . (+)) [1..]
11:15:55 <lambdabot>   [101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,11...
11:16:13 <Gracenotes> tromp_: I know, but why do that when you can do crazy obfuscating stuffs? :X
11:16:21 <Baughn> Chani: Though the syntax is a little awful, but.. "\a -> Program a dclstmt" would pass the second argument while leaving the first open, more or less
11:16:34 <Gracenotes> granted, not that crazy. still.
11:16:45 <Gracenotes> flip Program
11:17:18 <edwardk> or make program a record, so you can modify it using record syntax
11:17:43 <Chani> record syntax?
11:17:45 <Gracenotes> Chani: also, if you get the results of the stream as a list, you can use partition
11:18:16 <Gracenotes> well, depending on how simple the partitioning is...
11:18:26 <tromp_> if it's obfuscation you're after, then why not throw in some fmap fix return?
11:18:27 <Gracenotes> @hoogle partition
11:18:27 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
11:18:27 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
11:18:27 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
11:18:32 <Chani> problems is, I generally don't know if I'm at a point where I should be modifying Program or Dclrow or what, I don't know where I am at any particular point in hte algorithm
11:18:38 <Gracenotes> tromp_: good point.
11:18:42 <Botje> Gracenotes: partition between terminating and non-terminating functions; how hard could it be?
11:18:45 <edwardk> data Program = Program { progFoo :: Foo, progBar :: Bar } -- then you can prog = Program { progFoo = something, progBar = something else } .. and later on you can obtain new programs by saying things like prog' = prog { progFoo = myNewFoo }
11:18:55 <Botje> Chani: you should start by laying out some transformations
11:19:00 <Botje> each in a separate function
11:19:03 <Gracenotes> Botje: piece o cake
11:19:06 <Botje> which you can then chain together
11:19:17 <edwardk> but the result won't be very idiomatic haskell
11:19:38 <Chani> huh
11:20:27 <edwardk> chani: i missed what it is that you're trying to do, what algorithm are you reimplementing?
11:20:30 <Baughn> Chani: The main problem may be that you're trying to follow an algorithm meant for an imperative, mutative language. It's not going to work.
11:20:56 <Chani> edwardk: LF(k) parser, which seems to be something my teacher made up that's kinda like LL(k)
11:21:11 <Chani> Baughn: well, I'm trying to make it work ;)
11:21:55 * Chani doesn't have time to rewrite it all in c++, so...
11:22:04 <vininim> wait, LL is quite functional iirc
11:22:08 <Botje> oh, i thought you were writing a compiler
11:22:10 <Botje> carry one :)
11:22:10 <vininim> LR which is table lookup
11:22:32 <eu-prleu-peupeu> hi
11:23:36 <Trinithis> I have ghc 6.8.3... is there much new in 6.10.x?
11:23:48 <Trinithis> featurewise that is
11:23:56 <Baughn> Trinithis: Yep. INcluding bugs. :P
11:24:06 <wli> On-the-fly table-driven parsing would be nice to have. Sadly I'm the only person remotely interested.
11:24:07 <Trinithis> cool
11:24:13 <Chani> it's a fastback algorithm, and implementing most of the algorithm wasn't too hard - the problem is trying to make a tree structure with the result instead of a weird ugly backwards list
11:24:33 <edwardk> Trinithis: lots of features, not so many bugs ;)
11:24:34 <Baughn> Trinithis: View patterns are probably the most interesting,along with type families. And the most annoying, for view patterns - they don't work well with warnings yet.
11:24:45 <eu-prleu-peupeu> how do i write a function that given a directory, replaces all .exe and .bat files into .cmd files ?
11:24:52 <Chani> fuck. I forgot I have to hand in my math assignment soon.
11:24:54 <Trinithis> ill build it later... dont want to sit through it now thoguh
11:24:54 * Chani runs
11:25:09 * edwardk loves type families
11:25:11 <IRCstolemymonad> why cant i keep a button pressed but i have to pound it? this is nto good for a shmup
11:25:27 <edwardk> i keep meaning to go back and rewrite a bunch of old code with them
11:25:40 <wli> I'm not really capable of doing GLR on the fly or otherwise, so it's all smoke-blowing from me anyway.
11:25:43 <edwardk> shmup?
11:26:24 <Trinithis> never heard of type families... googlin
11:26:50 <Gracenotes> im in ur channel, googlin ur latest developments in type theory
11:26:56 <sjanssen> Trinithis: you're in for a treat@
11:26:59 <sjanssen> !
11:27:06 <Trinithis> oh DEAR!
11:27:33 <edwardk> the first piece of code i ever wrote for haskell needed them desperately, so i'm very pleased that they now exist
11:30:47 <Trinithis> i vaguely remember reading about view patterns and thought they were neat.  are they in practice?
11:30:58 <lilac> -XViewPatterns
11:31:00 <lilac> iirc
11:31:01 <edwardk> i've yet to be wowed by them
11:31:31 <lilac> , let eqHead (head -> a) (head -> b) = a == b in eqHead "Hello" "Howdy"
11:31:34 <lunabot>  True
11:32:57 <vininim> weird syntax at first look
11:33:17 <edwardk> keeps you from naming a cheesy temporary, which is nice
11:33:29 <lament> that looks kinda nasty
11:33:54 <lament> in an "x = x++" kind of way
11:34:06 <edwardk> they are a bit nicer when you have multiple variables you want to bind based on the functions' output
11:34:39 <Trinithis> mm
11:34:52 <mmorrow> , let fst3 (\(x,_,_)->x->x) = x in fst3 (1,2,3)
11:34:53 <lunabot>  1
11:34:56 <mmorrow> heh
11:35:14 <edwardk> haha
11:35:40 <edwardk> starts to look like the pattern calculus
11:36:08 <mmorrow> hmm, view patterns could be nice
11:36:09 <IRCstolemymonad> if i have: f arg1 arg2 and arg1 needs to be IOed. like readIORef. how can I do that on one line? modifyIORef aeroplane (updatePlane (=<< readIORef aeroplane) btn) doesnt wrok
11:37:13 <lilac> , let evilEq (unsafePerformIO -> a) (unsafePerformIO -> b) = a == b in evilEq readLn readLn
11:37:14 <lunabot>  luna: Not in scope: `unsafePerformIO'
11:37:36 <edwardk> mmorrow: i like them in scala/f#. had them as a central feature for kata for a while, but gutted them because my particular variant needed me to break my garbage collector pretty badly
11:38:08 <IRCstolemymonad>              --p <- readIORef aeroplane
11:38:09 <IRCstolemymonad>               --writeIORef aeroplane (updatePlane p btn)
11:38:13 <mmorrow> , let last (\xs->case xs of [x]->x; _:xs->last xs->x) = x in last [0..9]
11:38:15 <lunabot>  9
11:38:16 <IRCstolemymonad> how can that be done in one row?
11:38:19 <mmorrow> hah
11:38:20 <edwardk> ( i was inline caching the last view applied to a value in the value, because i was using them for pretty much everything)
11:38:20 <Gracenotes> IRCstolemymonad: try liftM, maybe
11:38:21 <mmorrow> sweet
11:38:55 <mmorrow> edwardk: ah nice, i'll have to check those out
11:39:05 <mmorrow> i've never used scala or f#
11:39:20 <edwardk> readIORef aeroplane >>= writeIORed aeroplane . flip updatePlane btn
11:39:22 <Gracenotes> IRCstolemymonad: hm, in that case liftM won't work (since it applies 'return' to the result)
11:39:26 <Gracenotes> yeah
11:39:27 <mmorrow> edwardk: how/why did it break the gc?
11:39:49 <mmorrow> oh
11:40:25 <edwardk> mmorrow: my gc relied on the global invariant that no references were ever changed from one non-null to another non-null, so it could skip using read/write barriers.
11:40:49 <edwardk> mmorrow: evaluation of thunks only added a reference and never changed one (modulo certain race condition concerns)
11:40:58 <cognominal_> does anyone has access to the acm site, I want to accès the pdb  "How to replace failure by a list of successes" by wadler
11:41:12 <dons> i think it is linked   from haskell.org
11:41:23 <eu-prleu-peupeu> how do i know if a given FilePath is executable ?
11:41:37 <mmorrow> edwardk: ah, i see. interesting
11:41:44 <edwardk> mmorrow: but inline caching the view yielded a slot that could in fact mutate
11:41:49 <Baughn> eu-prleu-peupeu: If it is, are you going to run it?
11:42:10 <cognominal_> dons, not from this page :(   http://www.haskell.org/haskellwiki/Research_papers/Program_development
11:42:14 <eu-prleu-peupeu> Baughn: no, im just going to take way its extension and create a new file that runs it
11:42:27 <cognominal_> I can't find it on wadler's page either :(
11:42:36 <edwardk> mmorrow: since my gc can use that constraint to do some things stupidly fast and in an easily separable manner, i dropped the views rather than the gc ;)
11:42:48 <eu-prleu-peupeu> the haskell part just looks inside a directory, and creates a new file for each executable filename there
11:42:58 <Baughn> eu-prleu-peupeu: Okay. It's OS-dependent, obviously. Now, ignoring the possibility that it's marked executable without actually /being/ an executable..
11:43:04 <IRCstolemymonad> why does opengl blip the screen and go into that really ugly mode on windows?
11:43:07 <eu-prleu-peupeu> hmmf
11:43:18 <eu-prleu-peupeu> okey, i would love to see it OS independent
11:43:25 <eu-prleu-peupeu> ill try to do it with the libmagic
11:43:31 <Baughn> eu-prleu-peupeu: On posix, use the access() syscall. I don't know if that's imported anywhere..
11:43:48 <Baughn> eu-prleu-peupeu: (No, just checking for the executable bits isn't enough. There can be ACLs and things.)
11:44:01 <eu-prleu-peupeu> oh
11:44:03 <Zao> IRCstolemymonad: If it picks a pixel format incompatible with DWM composition, Windows disables DWM for the duration of the OpenGL window.
11:44:04 <eu-prleu-peupeu> hmm eh
11:44:07 <mmorrow> edwardk: heh, i probably would have chosen that way too, now that i know how much of a pain gc's are
11:44:16 <eu-prleu-peupeu> then ill make it windows only, and just check for the extension
11:44:24 <eu-prleu-peupeu> this is for a ruby versus haskell comparison
11:44:40 <eu-prleu-peupeu> can you give me a simple task that is easy and elegant to do in haskell, but very hard to do in ruby ?
11:44:42 <mmorrow> well, not the gc itself per se, but precariously orchestrating everything to be juuust right for the gc
11:45:07 <IRCstolemymonad> @src flip
11:45:07 <lambdabot> flip f x y = f y x
11:45:29 <edwardk> mmorrow: the gc is very careful about tracking what gets communicated between threads, so that individual threads can locally gc most of their own data. this lets me use stop-the-world collection, without stopping the entire world, until i need to do a bigger collection and try to reclaim the stuff that has been communicated between threads
11:46:12 <Baughn> eu-prleu-peupeu: I don't know ruby well enough for that.. something depending on laziness would probably be best, though
11:46:21 <eu-prleu-peupeu> ok, thanks
11:47:35 <edwardk> and more importantly, avoid any read/write barriers in the meantime.
11:47:49 <Baughn> eu-prleu-peupeu: Or parallelism. There are some very good examples of that, in haskell.
11:48:19 <eu-prleu-peupeu> ok, ill look onto those
11:49:47 <dons> isn't this the only ruby/haskell comparison worth a damn, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ruby&lang2=ghc&box=1
11:50:02 <dons> it's cool that we're 10^3 x faster in mandelbrot.
11:50:12 <dons> 10^2 is so boring
11:50:31 <Baughn> What's with the memory use on pidigits, though?
11:50:43 <dons> it's the known 6.10.1 Integer gc bug. fixed in 6.10.2
11:50:58 <dons> FAQ.
11:51:23 <Baughn> Ah. I knew about that one, but I figured they'd use the 6.8.3 benchmark until it's fixed.
11:51:26 <mmorrow> edwardk: ah yeah, i remember you describing saying that. so when you do an involving-more-than-one-thread collection, do you stop everything, or do it n-wise or something?
11:51:27 <dons> nope
11:52:03 <dons> shows up most clearly here, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=gcc&lang2=ghc&box=1
11:52:13 <mmorrow> edwardk: also, does each thread have its own heap? and if so, is there a common globally shared one?
11:52:14 <beelsebob> their source size thing really needs to get fixed
11:52:21 <beelsebob> gzipped bytes is such a stupid measure
11:52:34 <beelsebob> repeated code is exactly what you want to measure, and gzip eliminates it
11:52:34 <dons> cute that we're faster than C in 4 benchmaks now, and withing 3x in all benchmarks
11:53:45 <beelsebob> has anyone figured out why pidigits uses so much ram?
11:54:10 <wli> The 6.10.1 integer GC bug, fixed in 6.10.2
11:54:17 <beelsebob> oh, okay
11:54:18 <edwardk> mmorrow: right now each thread runs local collections periodically, if they find themselves unable to obtain a certain quantum of pages from the global page store, they trigger a global collection. theoretically there could be a disjoint set based way of aggregating threads that have communicated but now its global
11:54:20 <dolio> Has anyone read the last 5 minutes of conversation? :)
11:54:25 <beelsebob> no
11:54:26 <beelsebob> :P
11:54:32 <wli> dolio: Apparently I'm the only one.
11:55:07 <edwardk> dolio: there is a conversation going on?
11:55:35 <lilac> what? WHAT ARE THESE WORDS ON MY SCREEN?
11:56:20 <lilac> also, what's with the pidigits memory usage? *ducks*
11:56:21 * ski detaches lilac's screen
11:57:08 <sm> hey all.. is there some reason haskell couldn't support optional trailing commas in lists, like in python ? so we wouldn't want to put the comma at the front of list items ?
11:57:24 * johnw wonders too
11:57:45 <gwern> probably wanted a more regular grammar
11:57:46 <BONUS> idk i used to think that too but i like the comma in front of list items in multiline lists convention
11:57:50 <BONUS> you get used to it
11:57:51 <MyCatVerbs> sm: good point. Hell, that's not unique to Python - C allows that, too.
11:58:07 <lament> comma in front of stuff looks ugly
11:58:12 * mmorrow likes the leading commas, and has started doing that in all language now
11:58:15 <edwardk> mmorrow: there is one global page pool, that each local thread snags ranges of pages from periodically using a cheesy little lock-free approach, then each thread owns its own pages, but pins the root of anything it sends over a channel.
11:58:30 <johnw> i'm not saying leading commas are bad or good, just why isn't there a choice?
11:58:35 <mauke> sm: use a trailing : after each element and a [] at the end
11:58:51 <TomMD> johnw: Beware of choice - choice leads to PERL and PERL leads to the dark side.
11:59:01 <mmorrow> edwardk: ah, i was just about to ask you about how you synchronize access to the heapptr-or-equiv
11:59:10 <mauke> it's Perl, not PERL
11:59:13 <johnw> haha, this isn't a choice between syntactic alternates haha
11:59:29 <ski> comma at end of stuff looks ugly
11:59:46 <mauke> comma between stuff looks ugly
11:59:50 <gwern> mauke: obviously TomMD comes to us from the deep past
11:59:57 <mmorrow> edwardk: oh cool, so sending over a channel in in some sense analogous to handing a ptr to a C function, in that you have to pin in
12:00:06 <edwardk> mmorrow: associated with each thread is what i call a heap, heaps can be unioned using a disjoint set approach so you can deal with 'joins' ala fork-join parallelism cheaply
12:00:16 <johnw> so is there no better than answer than, "get used to it"?  that seems a little procrustean to me
12:00:34 <lament> Commas are typographically designed to immediately follow something. A comma in the beginning of a line is nonsense. Some other operator would look much nicer in that case.
12:01:00 <johnw> good point
12:01:11 <johnw> comma-following has a history reaching back centuries
12:01:14 <mauke> pfft, reactionary propaganda
12:01:24 <ski> for multiple lines, commas should be aligned
12:01:26 <edwardk> using the disjoint set stuff you can figure out the heap an object is in in O(inverse-ackerman n) time, and heap merges are cheap
12:02:02 <mmorrow> edwardk: hm, i like the idea of treating (sub)heap(s) like that
12:02:02 <ski>   (quux,foo)
12:02:03 <ski>   (baz ,bar)
12:02:36 <IRCstolemymonad> doesnt GLFW have a way to output text into the window?
12:02:41 <mmorrow> edwardk: that's cool, i've been viewing the heap as a single global resource, but want to not
12:03:11 <edwardk> so gc basically just has to propagate the mark (pin) bits, and copy collect the page list. you can effectively use card marking by treadmilling the pages
12:04:06 <pastah> i am doing imports from two files and have a naming conflict
12:04:26 <MyCatVerbs> pastah: import qualified.
12:04:26 <wli> mmorrow/edwardk: I'm still in bad shape with heap/etc. management.
12:04:34 <pastah> (Graphics.UI.WX.stop and LOL.stop) but i don't want to make either qualified
12:04:44 <mmorrow> ah, iirc in some sml gc-describing paper they talk about how they use a card marking scheme of some sort, i glossed over it at the time
12:04:44 <ski> pastah : `import qualified Foo as F', then use `F.bar'
12:04:50 <edwardk> i've been toying with making untagged eval more expensive, i place a word at the beginning of each page that can optionally serve as a canonical tag for every reference into the page. if its 0, look right before the pointer for the tag, otherwise its the page tag. so you can effectively bibop the constructors
12:04:59 <pastah> i just want to rename LOL.stop to stopLOL but i want the rest from LOL to be as is
12:05:01 <MyCatVerbs> pastah: or you can do import Foo hiding (bar,baz,quux), if there are only a couple names that conflict and you don't need them anyway.
12:05:06 <ski> (pastah : or ignore the `as F' bit and use `Foo.bar')
12:05:34 <edwardk> then during collection you can optionally pool up certain constructors. that way if you have a page of cons's they just become a cons tag at the start of the page, and each cons node just becomes a pair of pointers in the page
12:05:37 <MyCatVerbs> pastah: import qualified LOL (stop) \n stopLOL = LOL.stop. :)
12:05:50 <edwardk> but you can still use a cheap bump allocator until you consolidate during collection
12:05:51 <pastah> hmmm.. LOL is just an interface, so i COULD import the actual source and do import qualifeid ACTUAL as X
12:06:02 <pastah> and that would qualify only stop
12:06:13 <ski> pastah : you know you can `import LOL hiding (stop); import qualified LOL', right ?
12:06:14 <pastah> if i add (stop)
12:06:41 <mmorrow> edwardk: do you ever collect code?
12:06:52 <edwardk> wli: its tricky to get right, as evidenced by the fact that i never ship any of this stuff ;)
12:06:56 <mmorrow> edwardk: and what's linking like?
12:08:26 <edwardk> mmorrow: yeah. tags (and hence indirectly their corresponding eval code) have to retain an index of all symbols they reference so i can collect code fragments.
12:09:02 <edwardk> mmorrow: currently compilation and evaluation are all in one great big pot, so i don't have prelinked stuff to deal with
12:10:20 <edwardk> mmorrow: the goal is to have the jit generate its fragments in an mmapped arena so that i can do restarts just be remapping that arena into memory, address space randomization screws me pretty hard though with that model
12:11:31 <mmorrow> edwardk: by address space randomization, do you mean because of absolute addresses in the code
12:11:39 <mmorrow> ?
12:11:48 <edwardk> mmorrow: in the resulting jitted code
12:11:57 <mmorrow> ah, i see
12:12:28 <edwardk> i could be smarter about it, load up the symbol table out of my own elf executable and make sure to have a symtab for the mmapped region and basically just 'relink' myself on reloading
12:12:40 <edwardk> but i have a long way to go before thats my biggest concern ;)
12:13:17 <mmorrow> yeah, i've been trying to come up with a way to avoid all absolute refs (and only use (virtual) pc-relative, or via (various) jump-tables
12:13:41 <mmorrow> so code can be dynamically linked in-mem
12:13:47 <mmorrow> by the interpreter
12:13:50 <edwardk> the jit is such a big deal for me because its when i'm doing almost all of my strictness/inlining, etc.
12:14:58 <mmorrow> a jit sounds really cool. i'd love to eventually get to a point where i can dynamically generate machine code and incrementally add it to (and collect it from) a running proc
12:15:20 <chowmeined> is there an SCTP library for haskell somewhere
12:15:49 <edwardk> in my case i'm trying to adapt the x64-x64 one i was doing for general purpose to use in a haskell-ish setting.
12:16:18 <edwardk> since every STG eval is an indirect call, there are a ton of poly-inline caching opportunities for it to optimize
12:16:32 <eu-prleu-peupeu> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2360#a2360
12:16:33 <mmorrow> edwardk: heh, that would be really sweet
12:16:41 <eu-prleu-peupeu> can someone help me do better than the ruby equivalent ?
12:16:54 <mmorrow> edwardk: so, something like an optimizing harpy?
12:16:58 <edwardk> and it has the potential to trace right through standard library code, so hopefully it can kick ass on benchmarks
12:16:58 <eu-prleu-peupeu> btw, my solution doesn't work, and i dont know why :P i guess its because its lazy
12:17:16 <johnw> regard commas, an interesting proposal I found on the wiki: http://www.haskell.org/haskellwiki/Accessible_layout_proposal
12:17:31 <mmorrow> edwardk: err, rephrasing... what does the jit take as input?
12:17:34 <edwardk> mmorrow: more like tracemonkey for x64
12:17:37 <Gracenotes> chowmeined: I can't find any
12:17:43 <edwardk> mmorrow: x64 assembly ;)
12:17:49 <mmorrow> ahhh, ok
12:17:51 <mmorrow> cool
12:17:57 <chowmeined> Gracenotes, hm, i couldnt either :(
12:18:07 <mmorrow> i forgot that part
12:18:12 <edwardk> and some annotations regarding the semantics of the instruction sequence as meta-information
12:19:25 <edwardk> i'll probably have to actually give up on just using a general x86-64 tracing jit for everything, and tweak it so i trace through a kata-specific bytecode until i try to call into standard libs
12:19:37 <dolio> eu-prleu-peupeu: return (sequence writeThem) looks wrong.
12:19:49 <dolio> It should probably just be 'sequence writeThem'.
12:19:52 <edwardk> fortunately the model i have is rather extensible, so tracing either is fine
12:19:56 <Gracenotes> chowmeined: if anything it might be addable to http://hackage.haskell.org/packages/archive/network/2.2.0.1/doc/html/Network-Socket.html#t%3ASocketType
12:20:02 <edwardk> the bytecode trace will permit higher level optimizations anyways
12:20:17 <Gracenotes> it's rather low level anyway... maybe you could implement it on top of Raw?
12:20:22 <eu-prleu-peupeu> hmm
12:20:29 <eu-prleu-peupeu> my point is that the ruby code looks better :/
12:20:30 <dolio> And then you can just do 'mapM ...' where '...' is the stuff after map. And you probably want mapM_, to boot.
12:20:32 <Gracenotes> hm. I'm not sure, I've only worked with TCP sockets
12:20:34 <Gracenotes> in Haskell
12:20:37 <chowmeined> Gracenotes, what.. its usually provided by the OS
12:20:52 <Gracenotes> chowmeined: ah. In that case FFI might be useful
12:21:05 <Gracenotes> assuming it's provided to C via the OS
12:21:24 <chowmeined> Gracenotes, yes
12:21:37 <edwardk> i'm trying very hard to plumb rewrite rules, etc. down so they are available to the jit to use to find opportunities for code motion
12:21:58 <eu-prleu-peupeu> my haskell skillz suck :P
12:22:39 <eu-prleu-peupeu> my haskillz
12:22:45 <chowmeined> Gracenotes, some new OSes supply it, linux, solaris and freebsd.. its better than TCP
12:22:49 <eu-prleu-peupeu> haskillz == haskell skillz
12:23:08 <acieroid> hmm
12:23:15 <ski> johnw : that reminds me of SRFI 49: Indentation-sensitive syntax <http://srfi.schemers.org/srfi-49/> by Egil Mller
12:23:23 <acieroid> "\n" =~ "[\\n]" :: Bool returns me False
12:23:29 <Gracenotes> eu-prleu-peupeu: part of the reason ruby is shorter is probably because it uses regular expressions
12:23:32 <acieroid> how can it be possible oO
12:23:35 <edwardk> mmorrow: oh and i wasn't entirely honest the model of one thread per heap was a little bit simplified, work stealing makes the whole thing a lot messier ;)
12:23:56 <acieroid> (with Text.Regex.Posix)
12:24:00 <eu-prleu-peupeu> yes
12:24:11 <goomba> ruby is seizure-inducigly slow
12:24:16 <eu-prleu-peupeu> i really should have read the rwh chapter on regex
12:24:19 <goomba> if that counts at all
12:24:43 <eu-prleu-peupeu> well, the point here is the ammount of work that is necessary for the coder to produce a given task
12:24:50 <Gracenotes> acieroid: in most regex engines, including Haskell's, things in character classes are literals for the most part
12:25:06 <Gracenotes> what you have there matches either a backslash or an 'n'
12:25:13 <johnw> goomba: aren't seizures induced by things going fast? :)
12:25:25 <Gracenotes> "\n" =~ "[\n]" :: Bool works, and so does "\\n" =~ "[\\n]" :: Bool
12:25:44 <acieroid> ok
12:26:03 <goomba> johnw, the slowness of ruby makes everything ELSE look so fast, the seizures start
12:26:07 <Gracenotes> I don't think \\n is supported in Haskell for meaning newline
12:26:10 <johnw> ahh, good one!
12:26:29 <Gracenotes> I don't get why \\n is supported in *any* regex engine except as a lazy hack for some otherwise ambiguous functionality.
12:26:31 <acieroid> but, is the class \\s including the \n ?
12:26:31 <edwardk> > fromEnum '\n'
12:26:33 <lambdabot>   10
12:26:38 <mmorrow> edwardk: sounds epic
12:26:48 <edwardk> mmorrow: if it ever works ;)
12:26:53 <Gracenotes> acieroid: it should. You can test it :)
12:26:54 <mmorrow> heh
12:27:06 <edwardk> mmorrow: bad case of 'second system syndrome' =)
12:27:11 <acieroid> oh year it works
12:27:21 <acieroid> my regex should be wrong so
12:27:26 <trofi> :t (fromEnum.toEnum)
12:27:27 <lambdabot>     Ambiguous type variable `b' in the constraint:
12:27:27 <lambdabot>       `Enum b' arising from a use of `fromEnum' at <interactive>:1:1-8
12:27:27 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
12:27:29 <FunctorSalad> btw, how the ... do you remember on which side of that operator the regex goes? :)
12:27:35 <edwardk> http://en.wikipedia.org/wiki/Second-system_effect <- my life =)
12:28:24 <Gracenotes> :t (toEnum.fromEnum)
12:28:24 <lambdabot> forall a a1. (Enum a1, Enum a) => a1 -> a
12:28:33 <Gracenotes> hrm
12:28:34 <lament> edwardk: interesting, this is your second reincarnation?
12:28:45 <FunctorSalad> hehe
12:28:49 <edwardk> lament: =)
12:28:57 <Eridius> lambdabot: no, that would be the Third-system effect :P
12:28:59 <Eridius> ack, lament
12:29:02 <edwardk> lament: my first reincarnation ;)
12:29:02 <Eridius> stupid tab-complete
12:29:08 <Eridius> yes, his second incarnation
12:30:36 <FunctorSalad> it would probably be more logically parsimonious to have only reincarnations and use the empty life as the induction start...
12:31:15 <FunctorSalad> (zing...)
12:31:21 <edwardk> hence the normalization of using 'incarnations' instead, no need for an empty life =)
12:31:32 <Eridius> oh snap!
12:32:02 <lament> my life is pretty empty...
12:32:22 <edwardk> otherwise it'd be like just having comonads and cocomonads. mmm. cocoa.
12:32:22 <acieroid> hum, I've problems with "{\n  \"" =~ "\\{[\\s\\ ]*\"" :: Bool that doesn' work
12:32:47 <acieroid> without the \" at the end of the regex, it works
12:33:59 <ImInYourMonad> http://hackage.haskell.org/packages/archive/GLFW/0.3/doc/html/Graphics-UI-GLFW.html#8 <- so how do i display the texture?
12:34:14 <Eridius> acieroid: \s should match all whitespace, so why the [\s ]?
12:34:44 <FunctorSalad> are you sure \s matches the newline?
12:34:55 <acieroid> yes FunctorSalad
12:35:02 <acieroid> right Eridius
12:35:26 <Eridius> what regex library is this?
12:35:29 <acieroid> so \s matches also the space
12:35:44 <acieroid> Text.Regex.Posix
12:36:02 <Eridius> ok, Posix regexes don't support \s style character classes
12:36:13 <Eridius> try using [[:whitespace:]] in place of [\s ]
12:36:27 <Eridius> err, [[:space:]]
12:36:38 <acieroid> ok
12:37:19 <acieroid> and it can parse more than a space ?
12:37:32 <Eridius> [[:space:]] is the character class for whitespace characters
12:37:39 <acieroid> ok
12:37:56 <edwardk> hrmm, funny i never even looked at the haskell regex stuff before
12:38:41 <Eridius> acieroid: BTW, if you cast to String instead of Bool you can see exactly what matched
12:38:56 <Eridius> which would have let you see why dropping the trailing " in the regex worked
12:39:15 <trez> :q
12:39:33 <Eridius> hrm, is "cast" an appropriate term when talking about adding type annotations?
12:39:50 <FunctorSalad> Eridius: it clashes with Data.Typeable.cast
12:40:20 <Eridius> ok
12:40:21 <wli> I think I'm still having troubles with earlier phases of compilation.
12:40:31 <wli> And/or code processing.
12:40:42 <FunctorSalad> Eridius: but I don't know, maybe it is the official term anyway :)
12:41:22 <Eridius> probably not. Casting implies actual conversion
12:41:56 <Baughn> Eridius: I like "constrain"
12:42:06 <edwardk> wli: how fares the lambda calculus interpreter?
12:42:11 <FunctorSalad> spezialise? fix?
12:42:18 <mib_54leepgv> Hello. I want to parse a binary file, starting from a particular offset. Can someone give me a clue how to hook a file handle, on which I have already done an hSeek, to Pasrsec please.
12:42:30 <Eridius> Baughn: hrm, constrain makes me think of specifying that a certain typeclass is required
12:42:46 <thoughtpolice> mib_54leepgv: hi, it may be easier to use the binary package; it's also probably faster
12:42:52 * EvilTerran likes "constrain", tbh
12:42:52 <Eridius> mib_54leepgv: why are you using Parsec for a binary file?
12:42:52 <thoughtpolice> mib_54leepgv: http://code.haskell.org/binary
12:42:56 <edwardk> how about annotate =)
12:43:06 <Eridius> edwardk: touché
12:43:12 <Eridius> ok, time for me to go eat food and get some work done
12:43:14 <ski> Eridius : s/cast/ascribe/
12:43:42 <mib_54leepgv> Probably because I don't know any better, and I've used Parsec before :-)
12:43:55 <mib_54leepgv> Thanks, I'll check that out.
12:43:58 <ski> `<expr> :: <type>' as an expression in `<expr>' with the type `<type>' ascribed to it
12:43:58 <Baughn> Eridius: Sometimes you /need/ parsec. binary only really lends itself well to file formats designed to be parsed without arbitrary readahead or, in particular, amibguities
12:44:19 <Eridius> Baughn: fair enough
12:44:20 <ski> (so it's a "type ascription")
12:44:20 <Baughn> Mind you, that's almost every binary file format right there. ;)
12:44:27 * BMeph feels that "constrain" feeds into the snide bondage remarks scripters make about a type system that works.
12:44:36 <Baughn> Eridius: At any rate, parsec doesn't come with a bytestring version for no reason
12:45:06 * BMeph also feels that such feeding isn't necessarily a bad thing.
12:45:07 <Eridius> yeah, I was gonna suggest that if mib_54leepgv wants Parsec maybe he should just use Data.ByteString.Lazy's hGetContents on the handle
12:45:42 <FunctorSalad> I thought that was evil, Eridius
12:45:42 <jordandanford> Hi, can anyone help me with a small problem (I'm new to Haskell)
12:45:44 <FunctorSalad> (lazy IO)
12:45:46 <Eridius> :D
12:45:48 <jordandanford> *?
12:45:56 <FunctorSalad> but I'm not staying I understand all the details...
12:45:59 <pumpkin_> lazy IO isn't inherently evil is it?
12:45:59 <Eridius> jordandanford: no, we only tackle huge, insurmountable problems here
12:46:04 <gwern> jordandanford: no, we only...
12:46:06 <pumpkin_> only if you need to do things that interact "on the outside"
12:46:07 <gwern> damn you Eridius >.<
12:46:11 * Eridius chuckles
12:46:22 <jordandanford> can you help me with a HUGE problem involving a two line function, then?
12:46:28 <FunctorSalad> Oleg argued on the mailing list that it breaks referential transparency in some sense
12:46:29 <Baughn> FunctorSalad: Lazy I/O is no more inherently evil than mutable data
12:46:30 <Eridius> jordandanford: I dunno, that doesn't sound very huge..
12:46:44 <ski> (FunctorSalad : reference ?)
12:46:47 <FunctorSalad> (but I don't know well enough to decide who was right in that argument)
12:46:47 <Baughn> FunctorSalad: And sure, it does, if you're not careful. So be careful.
12:46:48 <gwern> Eridius: what he neglected to mention is that each line is several thousand characters long
12:46:54 <jordandanford> can you help my with a HUGE problem involving complicated mathematical analysis, then?
12:46:55 <Eridius> gwern: ahh
12:47:13 <Baughn> FunctorSalad: Just because it /can/ break referential transparency doesn't mean you can't use it without problems. ;)
12:47:24 <gwern> jordandanford: spit it out already
12:47:51 <BONUS> lazy IO is cool for things like getting mouse movements as a list of position, etc.
12:48:06 <jordandanford> okay, so I'm trying to make a function that lists the factors for an integer
12:48:12 <mib_54leepgv> OK, binary looks interesting but not quite what I'm after. I want combinators like in Parsec. I'm playing with objects in pdf files, for which there is a grammar that I can express as Parsec combinators. But I want to do random access in the file and then parse from that position. And, yes, I was trying to use ByteStrings.
12:48:33 <FunctorSalad> ski: http://www.nabble.com/Definitions-of-purity-and-Lazy-IO-td22365938.html
12:48:40 <Gracenotes> nondeterministic leftmost derivation by conversion of grammar to PDA is hard, let's go shopping!
12:48:40 <jordandanford> factors x = [n | n <- [1..(x/2)], mod x n == 0] ++ [x]
12:48:47 <Baughn> mib_54leepgv: If you want parsec, use parsec; it works just fine on bytestrings.
12:49:02 <Gracenotes> I think I should make the PDA slightly more deterministic... :\
12:49:07 <Baughn> mib_54leepgv: _Most_ binary file formats are designed so binary will work just fine, but you'd know best if that's the case here.
12:49:31 <Gracenotes> right now it's using a lot of space
12:49:55 <jordandanford> when I plug in a number myself, it works fine, but when using it as a function with a parameter, GHCi returns a typing error
12:50:05 <pumpkin_> Gracenotes: you still awake??
12:50:08 <FunctorSalad> Baughn: what would being careful mean here? that you don't assume anything about when the read is performed?
12:50:19 <Gracenotes> pumpkin_: no, I slept for 3 hours
12:50:22 <pumpkin_> :O
12:50:23 <Eridius> jordandanford: what error?
12:50:43 <BMeph> @go oleg iteratee
12:50:43 <lambdabot> http://okmij.org/ftp/Streams.html
12:50:44 <lambdabot> Title: Streams and Iteratees
12:50:44 <Baughn> FunctorSalad: That you don't do I/O in the lazy i/o thunk that will affect the data returned by /another/ lazy i/o thunk
12:50:46 <mib_54leepgv> Yes, I can use Parsec with ByteString as long as I have read in enough already. When I don't know how much is enough, I want my file-reading-into-ByteString to just keep on reading if I haven't got enough already.
12:50:51 <jordandanford>     Ambiguous type variable `t' in the constraints:
12:50:51 <jordandanford>       `Integral t'
12:50:51 <jordandanford>         arising from a use of `factors' at <interactive>:1:0-10
12:50:51 <jordandanford>       `Fractional t'
12:50:51 <jordandanford>         arising from a use of `factors' at <interactive>:1:0-10
12:50:52 <jordandanford>     Probable fix: add a type signature that fixes these type variable(s)
12:50:55 <Eridius> jordandanford: I suspect your problem is if you look at the type of factors, it takes a Fractional
12:51:03 <Eridius> jordandanford: ah exactly what I thought
12:51:07 <Eridius> your use of / constrains x to Fractional
12:51:09 <Eridius> you should use `div` isntead
12:51:09 <ski> FunctorSalad : ok, ty (<http://article.gmane.org/gmane.comp.lang.haskell.general/16914>)
12:51:11 <Eridius> *instead
12:51:14 <FunctorSalad> Baughn: makes sense...
12:51:19 <Eridius> `div` does integer division, and it will constrain x to Integral instead
12:51:31 <Eridius> and of course integer division is all you need anyway
12:51:42 <Gracenotes> recognizing "aaa..aaabbb...bbb" with one hundred a's and one hundred b's takes 6 seconds
12:51:44 <jordandanford> okay, so what do I type the function as?
12:51:51 <jordandanford> sorry, I'm new to this whole thing
12:51:53 <Gracenotes> with the basic S -> aSb | (empty)
12:52:06 <Baughn> FunctorSalad: But at some level, to use lazy i/o you have to understand the haskell evaluation model and know when such inconsistencies are actually acceptable
12:52:08 <Eridius> jordandanford: it generally helps to figure out what the type of the function is supposed to be, and write it down
12:52:14 <Eridius> jordandanford: that way ghc can tell you if the function matches that type
12:52:25 <haedent> > (read "[1,2,3]")::[Int]
12:52:27 <lambdabot>   [1,2,3]
12:52:30 <Eridius> jordandanford: right now, factors is typing as (Fractional a) => a -> a
12:52:32 <gwern> let factors x = [n | n <- [1..(div x 2)], mod x n == 0] ++ [x] in factors 10
12:52:35 <haedent> > (read "[1..3]")::[Int]
12:52:37 <lambdabot>   * Exception: Prelude.read: no parse
12:52:40 <gwern> > let factors x = [n | n <- [1..(div x 2)], mod x n == 0] ++ [x] in factors 10
12:52:42 <lambdabot>   [1,2,5,10]
12:52:45 * haedent shakes a fist at Haskell
12:53:01 <jordandanford> oh okay
12:53:01 <mib_54leepgv> Is there a function that can do that, like hGetContents, but (a) from the current position and (b) without closing the file?
12:53:11 <gwern> > let factors x = [n | n <- [1..(x `div` 2)], x `mod` n == 0] ++ [x] in factors 10
12:53:12 <lambdabot>   [1,2,5,10]
12:53:18 * Gracenotes eats pumpkin's braaaains
12:53:22 <gwern> mm. infix isn't much clearer
12:53:37 <gwern> Gracenotes: sounds like you'd enjoy reading _Pride and Prejude and Zombies_
12:53:40 <Eridius> mib_54leepgv: hGetContents's lazy behavior requires the semi-close on the Handle, because if it didn't then any changes you make to the Handle would break the string returned from hGetContents
12:53:54 <Gracenotes> gwern: I'm not sure, I didn't enjoy Pride and Prejudice
12:54:00 <Eridius> Gracenotes: but it's got zombies!
12:54:02 <FunctorSalad> Baughn: isn't the haskell evaluation order undefined? (except that it shouldn't induce unnecessary strictness)
12:54:05 <gwern> maybe you'd like it more with the undead
12:54:06 <Gracenotes> good point.
12:54:24 <jordandanford> okay, now the error is:
12:54:26 <jordandanford>     Ambiguous type variable `t' in the constraints:
12:54:27 <jordandanford>       `Integral t'
12:54:27 <jordandanford>         arising from a use of `factors' at <interactive>:1:0-10
12:54:27 <jordandanford>       `Fractional t'
12:54:27 <jordandanford>         arising from a use of `factors' at <interactive>:1:0-10
12:54:28 <Baughn> FunctorSalad: Not at all
12:54:28 <jordandanford>     Probable fix: add a type signature that fixes these type variable(s)
12:54:41 <Eridius> jordandanford: why do you still have a Fractional in the mix?
12:54:49 <Eridius> jordandanford: what change did you make?
12:54:54 <jordandanford> oops, I realized my error
12:54:55 <Gracenotes> 'Jane Austen is the author of Sense and Sensibility, Persuasion, Mansfield Park, and other masterpieces of English literature. Seth Grahame-Smith is the author of How to Survive a Horror Movie and The Big Book of Porn. He lives in Los Angeles.'
12:55:04 <Gracenotes> mm hmmmmmmmm.
12:55:11 <jordandanford> I was messing with the type declaration when I didn't need to
12:55:14 <gwern> Gracenotes: a match made in heaven!
12:55:15 <Baughn> FunctorSalad: Well.. sometimes it is, but that "don't induce unneccessary strictness" bit covers a lot
12:55:39 <jordandanford> okay, that seems to work!
12:55:42 <jordandanford> thank you :)
12:55:51 <Baughn> FunctorSalad: Anyway, what I meant was that you should make sure it doesn't /matter/ what order the i/o is evaluated in
12:55:54 <Eridius> ok, *now* I'm idling. I meant to do that 30 minutes ago :/
12:56:06 <Gracenotes> gwern: 'This title has not yet been released.'
12:56:26 <Baughn> FunctorSalad: Which doesn't mean the program has to behave the same, just that both behaviours would be correct in your book
12:56:37 <gwern> Gracenotes: it takes time for the zombiefication to finish. soon it'll burst out of its unquiet grave!
12:56:56 <FunctorSalad> Baughn: haven't done enough order-critical IO to really have an intuition on it :)
12:57:05 * Gracenotes waits apprehensively
12:57:45 <FunctorSalad> but... with strict IO the IO monad *does* make sure that the order of actions is well-defined, right?
12:59:08 <FunctorSalad> (although the buffers can still be a surprise :))
12:59:59 <vegai> exceptions have surprised me in a few cases too
13:00:52 <mib_54leepgv> Perhaps I'm asking the wrong question. When using Parsec parse, it wants a list of tokens. My tokens are the Word8s in my pdf file. How to I get the bytes from the file into Parsec on demand?
13:01:44 <FunctorSalad> mib_54leepgv: maybe I'm mussing something, but... http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v:parse ?
13:01:48 <FunctorSalad> missing
13:03:12 <FunctorSalad> (the "s" param should be [Word8])
13:05:12 <mib_54leepgv> Yes, I see that. If I read the Word8s from the file I have a finite list. But I don't know how many to read, and the file could be larger than memory. So I'd like that list to grow, by reading another chunk of the file, if the parse ever reaches the current end of the list.
13:05:41 <c_wraith> Doesn't lazy evaluation automatically take care of that for you?
13:06:30 <ImInYourMonad> generate me a list of random please
13:07:14 <gwern> [4,1,1,2,6] <-- guaranteed random, chosen by roll of fair dice
13:07:28 <xs> ImInYourMonad: randoms.
13:07:40 <FunctorSalad> , parseTest (char 'a') (cycle 'a')
13:07:41 <lunabot>  luna: Not in scope: `parseTest'
13:09:04 <FunctorSalad> err, should be parseTest (string "a") (cycle "a")
13:09:24 <FunctorSalad> mib_54leepgv: that does terminate for me even though cycle "a" is infinite
13:09:40 <mib_54leepgv> I don't think it does, but I may be wrong. I'm using ByteString so I'm using its functions to read from the file. I can read a number of bytes or a line with no problem. But if I use hGetContents it reads to EOF immediately and closes the file, no?
13:09:55 <mib_54leepgv> My problem is the other way round.
13:10:15 <FunctorSalad> mib_54leepgv: getContents is lazy
13:10:53 <mib_54leepgv> What about ByteString.hGetContents?
13:11:06 <gwern> hm, http://mitpress.mit.edu/sicp/ no longer links to the lecture videos
13:11:07 <FunctorSalad> mib_54leepgv: sorry, you're right, it is strict for strict ByteStrings
13:11:18 <FunctorSalad> but http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy.html#v:hGetContents    is lazy
13:12:12 <edwardk> mib_54leepgv: you want lazy bytestrings
13:12:13 <mib_54leepgv> Ah. That's what I'm missing. Doh! Thanks very much for your help.
13:12:54 <Gracenotes> gwern: I don't recall it having done so
13:13:40 <Gracenotes> I can't find anything in http://web.archive.org/web/*/http://mitpress.mit.edu/sicp/ that does
13:15:15 <gwern> Gracenotes: the mit websites must've linked them at one point, because I remember an option between downloading from mit and downloading torrents
13:16:09 * edwardk wonders what a good RGN-like file-manipulation monad would look like
13:17:08 <Gracenotes> gwern: there's http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
13:17:10 <Saizan> RGN?
13:17:48 <edwardk> Saizan: oleg did a nested region monad thats kinda like ST for region based memory management
13:19:00 <Saizan> ah, i've seen the one for file handles
13:19:04 <edwardk> fluet and morrisett wrote: http://ttic.uchicago.edu/~fluet/research/rgn-monad/ICFP04/icfp04.pdf and oleg replied with a pure haskell implementation
13:19:04 <augustss> I think my new TV runs Linux.  Interesting.
13:19:16 <mmorrow> edwardk: haha, i was just reading about "second system syndrome" somewhere the other day, but i can't remember where it was
13:19:19 <edwardk> saizan: ah someone put one together?
13:19:44 <gwern> 'I have always dreamed my computer would be as easy to use as my phone. my dream has come true - I no longer know how to use my phone'
13:19:49 <Saizan> edwardk: an oleg paper last year, iirc
13:20:15 <edwardk> saizan: yeah oleg wrote up one of his minimistic trademark email messages some time thereafter
13:20:56 <edwardk> http://www.flippac.org/blog/wp-content/uploads/2007/06/monadicregions.hs appears to contain its contents
13:21:16 <mmorrow> the mythical man month
13:21:22 <mmorrow> (is where i read it)
13:21:27 <edwardk> mmorrow: yeah
13:21:42 <skorpan> how do you guys feel about calling e.g. javascript a programming language?
13:21:49 <mmorrow> heh, that was the first i'd ever heard that term too
13:22:00 <edwardk> skorpan: its a perfectly fine lisp. whats wrong with it?
13:22:17 <skorpan> edwardk: a lisp?  it's not a lisp...?
13:23:05 <mmorrow> i wish it had tco though
13:23:13 <mmorrow> then it would be friggin awesome
13:23:27 <edwardk> skorpan: it was a joke referencing a quote someone made a long time ago about how javascript was just a lisp with a funny syntax, because it supported closures so easily
13:23:58 <mmorrow> writing "function" everywhere instead of something short like "\" is a pita though
13:24:15 <skorpan> edwardk: hm, i feel like writing lisp-ish javascript now
13:24:32 <pejo> augustss, the tv itself?
13:24:36 <Gracenotes> JS also has a means of dynamic-ish scope: 'this'
13:24:45 <augustss> pejo: yes
13:24:50 <Raevel> js is cool
13:25:02 <mmorrow> ooh, that reminds me
13:25:16 * edwardk first really grokked continuation passing style through javascript
13:25:20 <Gracenotes> yeah. Somewhat hard to make anything particularly robust in it, but neat :)
13:25:32 <augustss> pejo: I just watched some movie clips from a USB stick I plugged in to the TV.
13:25:37 <Saizan> edwardk: i was thinking of this one http://portal.acm.org/citation.cfm?id=1411286.1411288
13:25:48 <Peaker> does ByteString still need a lot of C code to be fast? If not, can it be written to be parameterized on any type rather than Word8 ?
13:25:54 <dons> it has no C code.
13:25:57 <Gracenotes> yeah. function contSqrt(func, a) { func(a*a) }
13:25:58 <edwardk> mmorrow: there are ways to bypass the need for TCO in javascript, if you've converted entirely to tail calls you can borrow the trick that chicken scheme uses and just throw an exception burning away the stack whenever it gets too full
13:26:05 <Gracenotes> I think. :x
13:26:11 <mmorrow> oh snap!
13:26:15 <dons> Peaker: the StorableByteString is the version paramaterised
13:26:23 <Gracenotes> o nos
13:26:27 <Gracenotes> , 2+2
13:26:28 <lunabot>  4
13:26:35 <Gracenotes> :.
13:26:35 <pejo> augustss, odd, but nice. Are you going to make it run House? :-)
13:26:45 <mmorrow> ) function(x){return(x(x))}(function(x){return(x(x))})
13:26:46 <lunabotjs>  function (x) {
13:26:46 <lunabotjs>      return x(x);
13:26:46 <lunabotjs>  }
13:26:53 <Gracenotes> halp
13:27:04 <dolio> Does ByteString use any C code besides, like, memcpy?
13:27:14 <mmorrow> ) Date()
13:27:14 <lunabotjs>  Fri Mar 13 2009 15:27:13 GMT-0500 (CDT)
13:27:17 <augustss> pejo: I've not figured out how to boot anything else. :)  And that's just as well.
13:27:18 <Peaker> dons: google/cabal/hoogle don't seem to have much on that
13:27:30 <augustss> pejo: I'll use it to watch House.
13:27:50 <Gracenotes> ) this
13:27:50 <lunabotjs>  [object global]
13:27:58 <dons> Peaker: don't use it. use one of the new array libraries like uvector
13:28:10 <dons> well, storablevector is also ok
13:28:28 <edwardk> mmorrow: of course, if you want an _efficient_ cps transform of javascript code you don't want to just naively convert to cps. because the closures are expensive the cost to access a variable is usually proportional to the number of scopes between it and you
13:29:04 <Gracenotes> ) readUrl("http://www.google.com")
13:29:04 <lunabotjs>  some error.
13:29:18 <Peaker> dons: is bytestring considerably faster than these Vectors parametrized with Word8?
13:29:23 <mmorrow> edwardk: hmm
13:29:32 * edwardk wound up using an evil intermediate form for my javascript w/continuations to javascript compiler to get something that could actually avoid changing the asymptotics of the original code
13:29:34 <mmorrow> ) while(1);
13:29:37 <lunabotjs>  Killed.
13:29:47 <cschneid> I'm trying to build a shared lib w/ haskell.  I am invoking "ghc  -no-hs-main -optl '-shared' -o fib.so fib.hs" and I get these crazy symbol not found errors. ("_ZCMain_main_closure", referenced from:).  Any ideas on what to look at?
13:29:49 <dons> Peaker: not really
13:29:52 <mmorrow> edwardk: oh sweet
13:30:00 <mmorrow> edwardk: is there any code for that around?
13:30:14 <Saizan> cschneid: use --make
13:30:16 <edwardk> http://comonad.com/js/
13:30:35 <mmorrow> edwardk: ooho, awesome
13:30:38 <cschneid> Saizan: same problem. linking error
13:31:12 <edwardk> js/lang/Recompiler.js i think has a cheesy recompiler, not sure if the version up on that url is entirely internally consistent it was recovered after a drive crash, and some versions of the files are inconsistent with one another
13:31:27 <cschneid> Saizan: http://pastie.org/415639
13:31:58 <conal> Axman6: hi.  you found my "modern marriage" (tangible functional programming) google tech talk. :)
13:32:00 <edwardk> http://comonad.com/js/cps/Thread.js is probably more interesting, because it was how i was implementing client side threads in javascript, using 'blowing the stack' as a natural thread quantum
13:32:25 <edwardk> and just enqueuing the thread in the trampoline rather than resuming
13:33:20 <edwardk> if you dig around in the wiki content (available through the side bar on comonad.com) there are a bunch of explanations of how parts of it work, and somewhere in my post history is a post with a tar ball link for it
13:35:04 <mmorrow> edwardk: oh cool, i tried that using throw once to jump back to a trampoline to get some scrap of tailcalleverything coding back
13:35:08 <edwardk> i abandoned it when google released GWT because the idea of compiling from js+a few features to js wasn't nearly as good as compiling down from something with types
13:35:17 <mmorrow> but i was using a fixed recursion depth rather than a timer
13:35:31 <mmorrow> err, oh i think the timer's for threads
13:35:34 <edwardk> i use a fixed recursion depth of < 1000 levels
13:35:39 <mmorrow> ah, cool
13:35:43 <edwardk> the timer is because there is a second constraint other than stack depth
13:35:55 <edwardk> the other constraint is you can't execute more than a million consecutive instructions
13:36:07 <edwardk> or you get the 'javascript is taking too long' dialog =)
13:36:12 <mmorrow> heh
13:36:16 <edwardk> which i approximate by allowing it to blow the stack 20 times
13:36:32 <edwardk> and then i sleep for a millisecond to avoid the error and resume
13:36:48 <edwardk> so you can encode long running computations with this unlike, say, narrative js
13:37:00 <edwardk> unless they've since fixed that
13:37:34 <mmorrow> sweet, i'm psyched to hack around with this js :)
13:38:09 <edwardk> feel free, its mostly just been sitting on my site bitrotting. i had a couple of companies come sniffing around to use it for various things
13:38:26 <mmorrow> if you think about about it, the language that happened to be the web browser scripting lang could've been a llllllot worse
13:38:43 <edwardk> sure. brendan eich came up with something nifty
13:39:48 <edwardk> it is a shape about ecmascript 4 though, the death of that standard really killed my interest in javascript
13:39:51 <edwardk> er shame
13:39:55 <Baughn> mmorrow: Sure. It could, for example, have been Java.
13:40:06 <Baughn> That nearly happened
13:40:18 <mmorrow> edwardk: yeah, i was sad
13:40:23 <edwardk> especially considering i learned haskell to implement an ecmascript 4 compiler ;)
13:40:25 <mmorrow> Baughn: the horror
13:40:34 <mmorrow> edwardk: heh
13:40:47 <wli> I'm still trying to figure out how to evaluate things.
13:41:00 <Baughn> edwardk: How do you deal with it being possible to change function bindings at runtime?
13:41:31 <mmorrow> wli: i've been in this place for a month+, and i'm just starting to see some light at the end of the tunnel
13:41:50 <pumpkin_> :o
13:41:52 <Baughn> edwardk: Or.. er, I randomly assumed it was an /optimizing/ compiler. Is it?
13:41:56 <Gracenotes> hm. I wonder if something like this could be written in Haskell: http://broadcast.oreilly.com/2009/03/the-power-of-erlang-bit-syntax.html
13:41:58 <edwardk> pugs existed and perl 6 and ecmascript 4 share a lot of the crazier type features, etc.
13:42:08 <edwardk> Baughn: my first goal was to make it correct, then to make it fast ;)
13:42:11 <Gracenotes> a terse syntax for extracting sub-bitstrings from bitstrings
13:42:16 <Gracenotes> for use with protocols and the like
13:42:25 <mmorrow> Gracenotes: write a QuasiQuoter
13:42:30 * edwardk had coworkers teasing him about his obsession with 'jugs' ;)
13:42:36 <pumpkin_> mmm jugs
13:42:37 <Baughn> Gracenotes: Sure. (Actually, I'm working on one like that. Don't know if I'll be alllowed to release it, though.)
13:42:39 <Gracenotes> hm. I suppose that'd be an option.
13:42:49 <Gracenotes> Baughn: I see :x
13:43:02 <Baughn> Gracenotes: Well, I probably will, eventually
13:43:22 <Gracenotes> using TH?
13:43:26 <Baughn> There are just.. issues. The university insists on my using LGPL or BSD. I insist on using GPL or LGPL. LGPL and Haskell don't mix.
13:43:26 <edwardk> Gracenotes: the easiest answer is to just make a monad out of it. foo <- bits 16; bar <- bits 16; ...
13:43:29 <p_l> Baughn: What you won't be allowed to release
13:43:32 <Baughn> Gracenotes: No, just standard combinators
13:43:35 <edwardk> gracenotes and parse parsec style.
13:43:43 <Gracenotes> ah, I see. That's work nicely.
13:43:48 <Baughn> p_l: It's part of my master's thesis, and they're being very.. bureaucratic.
13:43:49 <p_l> ah
13:43:56 <Gracenotes> *that'd
13:44:11 <p_l> Baughn: You should be happy they don't actually order you to release with certain license
13:44:11 <SubStack> release it anyways
13:44:17 <Gracenotes> :x
13:44:17 <SubStack> larry wall style
13:44:33 <Gracenotes> what's this about applicative-style parsers, by the way?
13:44:36 <Baughn> p_l: That would be against norwegian law
13:44:41 <Gracenotes> as opposed to just monad-style
13:44:56 <edwardk> Gracenotes: efficiency
13:45:19 <p_l> Baughn: Depends on how your copyright would be considered. It's quite tricky thing, theses
13:45:20 <Gracenotes> efficiency in what sense? That one uses backtracking and another is one-pass?
13:45:33 <cschneid> ok, getting closer to a shared lib w/ haskell.  Any idea where this file would be?  I dont' see it anywhere under /usr.  ld: library not found for -lHSbase-4.0.0.0-ghc6.10.1
13:45:59 <Baughn> cschneid: Shold be a .a in your ghc install somewhere
13:46:05 <edwardk> Gracenotes: swierstra/duponcheel style parsers can't be made into monads, so you get a lot of extra work out of the monadic ones sometimes
13:46:10 <p_l> Baughn: Also, why are you set on GPL? (I won't hold it against you, don't worry :D)
13:46:23 <cschneid> Baughn: that's what I figured, my ghc is in /usr/bin, but I can't find any libs under /usr anywhere... hmm
13:46:27 <edwardk> Gracenotes: in fact it was one of the major motivations for arrows in haskell
13:46:34 <cschneid> is there a way for ghc to spit out where it thinks its libs are
13:46:40 <pumpkin_> -v ?
13:46:44 <Baughn> p_l: I dislike anyone being able to use my work for free
13:47:02 <Gracenotes> edwardk: hm, I see... has u a paper?
13:47:13 <Baughn> cschneid: /usr/lib/ghc-something
13:47:19 <edwardk> gracenotes: re the parser thing? look up the early arrow papers =)
13:47:19 <Baughn> cschneid: /base-4
13:47:27 <p_l> Baughn: Can't you declare your work then first as unreleased and then rerelease?
13:47:41 <cschneid> Baughn: looks like it might be in /Library/Frameworks (yay mac....).  older versions are under /usr/lib, which was throwing me off
13:47:48 <drhodes> I'm ecstatic if anyone uses my software for anything - what a compliment, imho.
13:47:59 <edwardk> http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf
13:48:16 <edwardk> the swierstra/duponcheel parser comes up a few pages in
13:48:30 <edwardk> applicatives are just nicer to work with than arrows.
13:48:30 <Gracenotes> ah yes. Right on the Arrows page
13:48:44 <p_l> heh. The only code I actually released for others to use I released under MIT license
13:48:53 <edwardk> if you want to see the connection between arrows and applicatives skim the arrows/idioms/monads stuff that wadler and company have been writing lately
13:48:55 <SubStack> p_l: you could always release it as bsd and then independently release the BSD code under the gpl
13:48:57 <Baughn> p_l: In order to do that I'd have to actually not release it
13:49:01 <Gracenotes> /arrows/biblio. So... monads are only useful in the applicative sense? Not the, uh, functor sense?
13:49:13 <cschneid> yup, was in /Library/Frameworks/GHC.framework/Versions/610/usr/lib/ghc-6.10.1/base-4.0.0.0 for some reason. thanks for the -v  :)
13:49:23 <p_l> SubStack: Only if it's 3-clause, not 4-clause :)
13:49:46 <edwardk> Gracenotes: nah, context sensitivity, etc. is handy monadically, but when you only _need_ the applicative portion, the applicative bits are more efficient
13:50:10 <Baughn> Gracenotes: http://www.cis.upenn.edu/~byorgey/papers/typeclassopedia-draft-090216.pdf <-- Have some dead sea scrolls
13:50:23 <p_l> lol @ dead sea scrolls
13:50:32 <Gracenotes> than arrows
13:50:44 <wli> I'm thinking lambda lifting might be in order.
13:51:19 <Baughn> > join ("foo",("-bar",42))
13:51:20 <lambdabot>       No instance for (Monad ((,) [Char]))
13:51:20 <lambdabot>        arising from a use of `join...
13:51:31 <edwardk> Baughn: or release the initial draft of it under bsd, then rapidly do some independent work on it to make it useful upgrading the license to gpl in the process ;)
13:51:34 <Gracenotes> Baughn: I must be confusing something. So a monad is a ____ applicative..?
13:51:53 <pumpkin_> moo!
13:52:02 <pumpkin_> A monad is a moo applicative
13:52:07 <Baughn> edwardk: I think the first thing I need to do is figure out just who owns the copyright on the thing anyhow
13:52:17 <Gracenotes> pumpkin u think so
13:52:21 <pumpkin_> yup
13:52:27 <edwardk> all monads in haskell are applicative. (though not monads are not necessarily applicative in other categories!)
13:52:41 <edwardk> er though monads
13:52:47 <Baughn> @instances Applicative
13:52:47 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:52:51 <mmorrow> ) go = function(cont){while(cont=cont()){}}; (function(x,y,z){var k=function(){if(x>z)return(undefined);x+=y;return(k)};go(k);return(x)})(0,7,1000000)
13:52:52 <lunabotjs>  1000006
13:52:52 <Gracenotes> but are all applicatives monads? And what distinguishes those that aren't?
13:52:56 <Baughn> @instances-importing Control.Applicative Applicative
13:52:56 <pumpkin_> nope
13:52:57 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:52:59 <edwardk> no
13:53:06 <edwardk> there are applicatives that are not monads
13:53:06 <Baughn> Gracenotes: You should read the pdf I gave you. ;)
13:53:24 <pumpkin_> applicative shmapplicative
13:53:25 <glguy> edwardk, so bind can’t be used to define ap, necessarily?
13:53:27 <Gracenotes> , src ''WrappedMonad
13:53:28 <edwardk> the possibility of meeting the monad laws ;)
13:53:31 <lunabot>  newtype WrappedMonad m a = WrapMonad {unwrapMonad :: (m a)}
13:53:32 <edwardk> the existence of bind. monads can 'decide what to do based on whats come before'
13:53:35 <Baughn> Gracenotes: But for a one-line summary, monads are applicatives that allow you to join nested applicatives
13:53:43 <edwardk> glguy: the other way around. you can always define ap given a monad
13:53:45 <edwardk> @src ap
13:53:46 <lambdabot> ap = liftM2 id
13:53:46 <Baughn> Gracenotes: Eg. join :: m (m a) -> m a
13:53:50 <Gracenotes> yeah
13:54:05 <Gracenotes> I once wrote <*> in terms of join, fmap and return...
13:54:10 <edwardk> glguy: but just given ap and fmap and return you can't define bind
13:54:18 <glguy> edwardk, right, but I'm trying to understand what enables something that is a monad to not be an applicaive
13:54:22 <Gracenotes> or just bind and return would work
13:54:23 <mmorrow> i love how in "var x = ....", `x' is visible on the rhs
13:54:31 <edwardk> bind gives a monad its 'context sensitivity'
13:54:36 <Baughn> glguy: If it's a monad, it /is/ an applicative
13:54:41 <glguy> Baughn, read up
13:54:42 <edwardk> glguy: every monad can be applicative
13:55:00 <Baughn> glguy: Well, there's no accounting for hysterical raisins
13:55:00 <glguy> no, you mentioned that that only works in Haskell
13:55:13 <Baughn> Although I personally think that bit should be fixed already. ;_;
13:55:14 <dolio> glguy: There's a notion of strong monads in category theory, so they might not all be strong.
13:55:15 <Gracenotes> edwardk: context sensitivity in which context? :)
13:55:26 <dolio> And applicatives are "strong lax monoidal functors".
13:55:29 <dolio> So maybe that's it.
13:55:38 * Baughn eats some delicious raisins.
13:55:49 * pumpkin_ watches more heads explode around the channel than his own
13:56:01 <Gracenotes> I take it WrappedMonad is Wrapped to avoid ambiguous instances
13:56:09 <edwardk> glguy: in other categories they may not be, but thats because other categories may not have exponentials ;)
13:56:09 <edwardk> it comes down to the definition of ap
13:56:09 <edwardk> @type ap
13:56:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:56:19 <edwardk> the strong lax monoidal stuff just scares the everliving crap out of people, but it comes down to whether or not arrows are objects in your category.
13:56:22 <p_l> Baughn: my mind autocompleted that as "delicious carrot cake" xD
13:56:27 <Baughn> Gracenotes: Mm. Every monad can be an applicative. Monad /should/ be a subclass of applicative, but it isn't. And so..
13:56:39 <pumpkin_> aha
13:56:46 <regulate> @src flip
13:56:46 <lambdabot> flip f x y = f y x
13:56:48 <edwardk> if you have an endofunctor on a category where there are no arrows, then you can never meet the requirement for ap =)
13:56:58 <edwardk> er where there are no exponentials
13:57:02 <Gracenotes> it's all crystal clear now!
13:57:05 <Gracenotes> wait
13:57:08 <glguy> edwardk, is this easier to explain using Arrow and ArrowApply?
13:57:12 <pumpkin_> it's clearer
13:57:18 <Baughn> p_l: No carrot cake, but I've got several loaves of carrot bread in the oven
13:57:20 <glguy> (when the target is a Haskell user)
13:57:22 <dolio> What about the 'unit :: f () ; pair :: f a -> f b -> f (a,b)' basis?
13:57:25 <Gracenotes> nevermind, that was just my brain dying for a few seconds
13:57:36 <glguy> ArrowApply putting the arrows in the value-space
13:57:48 <Baughn> @instances-importing Control.Applicative Applicative
13:57:49 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:57:57 <p_l> hmmm.... if I'm under NDA writing something that is "patent pending" and I find that there's a ton of prior art and the whole thing is a patent troll, can I inform USPT?
13:58:13 <edwardk> if your category has no objects of the form (a -> b), just arrows from a -> b. then it has no objects of the form m (a -> b), so ap can never be used.
13:58:15 <Baughn> Oh.. hang on, why isn't 'Monoid a => ((,) a)' a Monad as well?
13:58:26 <dolio> I suppose that might not be equivalent to ap/pure if there are no exponentials.
13:58:29 <edwardk> baugn: thats writer
13:58:57 <edwardk> baugn: they may not have made an anonymous Writer monad in Control.Monad.Writer though
13:59:35 <fynn> A question from #python:
13:59:41 <Baughn> > join ("foo",("bar",2)) -- It appears not.
13:59:42 <lambdabot>       No instance for (Monad ((,) [Char]))
13:59:42 <lambdabot>        arising from a use of `join...
13:59:58 <fynn> RWH is a Haskell tutorial from a more practical perspective.
14:00:18 <fynn> what tutorial would you recommend for someone looking for a more theoretical perspective?
14:00:51 <Baughn> (And don't say "start by taking a course in category theory")
14:00:54 <edwardk> fynn: all about monads or a gentle introduction to haskll
14:01:01 <Gracenotes> well, the first few chapters are rather theoretical
14:01:04 <edwardk> and a course in category theory ;)
14:01:09 <dons> fynn: hmmm...................
14:01:18 <Gracenotes> of Real World Haskell. In terms of an introduction to functional programming.
14:01:35 <Gracenotes> it's the case studies that are mainly the practical parts
14:02:00 <edwardk> fynn: http://www.haskell.org/tutorial/
14:04:29 <fynn> edwardk: /me wonders how many people actually learned Haskell by reading that ;)
14:04:36 <fynn> dons: anything to add...?
14:04:37 <edwardk> i keep meaning to write a 'teach your self haskell through category theory' or 'category theory through haskell'
14:04:43 <edwardk> fynn: i did =)
14:04:49 <fynn> yeah, that would be nice.
14:05:06 <Gracenotes> edwardk: Haskell through category theory seems a lot easier ;)
14:05:46 <edwardk> Gracenotes: more likely to get an audience that isn't afraid of math that way
14:05:50 <Gracenotes> in terms of category theory through Haskell, your categories are basically types, unless you make ADTs for new categories
14:05:59 <edwardk> and Hask is a pretty rich category
14:06:06 <Gracenotes> mm. true
14:06:16 <pumpkin_> I thought types were objects?
14:06:22 <dolio> So rich it's not a category. :)
14:06:33 <Gracenotes> pumpkin_: er, yeah, that's what I meant ;) and arrows are ->
14:06:46 <edwardk> well, any Monoid is just a category with one object, so you have a lot of others to play with
14:06:49 <fynn> there are already two books for "learn <math branch> through haskell"
14:07:06 <fynn> where <math branch> equals "logic" or "discrete math"
14:07:16 <edwardk> dolio: in the absence of seq ;)
14:07:20 <dolio> :)
14:07:28 <pumpkin_> how bout pseq?
14:07:32 <Gracenotes> I know, let's write 'Haskell for Scientists'! >_>
14:07:56 <pumpkin_> or haskell for role-playing gamers ;) like I proposed
14:08:15 <Gracenotes> you are the monad. You must bind to the function. You have one minute and thirty seconds.
14:08:22 <Gracenotes> Go go go go go
14:08:35 <fynn> teach Haskell through Anime
14:08:44 <edwardk> the manga guide to haskell?
14:08:51 <Gracenotes> yes please! :D
14:08:55 <vav> Alice for haskell would be awesome
14:09:07 <pumpkin_> alice in haskelland
14:09:18 <Gracenotes> down the fixhole
14:09:36 <pumpkin_> lol
14:09:42 <pumpkin_> somehow that sounds quite rude
14:09:56 <pumpkin_> although better than up the fixhole, fwiw
14:10:36 <dons> hey, for the theory, you could collect sigfpe's articles
14:10:38 <Gracenotes> hm. It does sound obscene. It's just your run of the mill "fix id" though
14:10:38 <dons> into the wikibook
14:11:00 <pumpkin_> we should have a pearls of FP blogosphere!
14:11:20 <pumpkin_> pearls of (FP blogosphere), that is
14:12:19 <edwardk> dons: yeah i tried to interest him into coauthoring with me at MSFP and he tried to convince me to collect the comonad.com stuff and just embellish it from there
14:13:23 <edwardk> dons: if i covered through kan extensions i could pretty much parallel the development in categories for the working mathematician
14:13:48 <dons> it would really be wonderful to fill out the theory wikibook with these texts (and alpheccar's et al)
14:13:55 <chessguy_> 'evening
14:14:16 <fynn> hmm, looks like RWH is the only up to date tutorial that's free online
14:14:35 <dons> there are other up to date tutorials
14:14:40 <dons> see. e.g. learnyouahaskell
14:14:59 <edwardk> dons: if someone wants to do it, i hereby designate that you can use the stuff in my catamorphism knol under whatever license is required to publish it to the haskell wiki. it might motivate me to add the rest of them
14:14:59 <wli> I thought my cantor function was more notable than the "fastest fib in the west" but anyway.
14:15:08 <fynn> dons: mhm anything else?
14:15:39 <vincenz> wli: you mean my log one?
14:15:53 <chessguy_> fynn: typeclassopedia?
14:16:03 <fynn> what's your impression of LYaH?
14:16:04 <wli> vincenz: I don't know what you mean by "your log one."
14:16:39 <vincenz> wli: I meant the one that has O(log N) as complexity?
14:16:55 <wli> vincenz: I meant http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
14:17:05 <Heffalump> @seen mnislaih
14:17:05 <lambdabot> I saw mnislaih leaving #haskell and #ghc 5m 8d 8h 1m 12s ago, and .
14:17:21 <Heffalump> that can't be right, he was here yesterday
14:18:04 <vincenz> wli: I'll compsre
14:18:32 <Gracenotes> fynn: LYAH is good :) You might also find stuff around the blogosphere: http://www.haskell.org/haskellwiki/Blog_articles
14:18:53 <Gracenotes> and a nice list at http://www.haskell.org/haskellwiki/Tutorials
14:20:30 <fynn> Gracenotes: thanks.
14:20:31 <edwardk> which reminds me, are there are good writeups on mendler-style recursion? i keep meaning to post something explaining it, but would like to cite whatever references there are
14:20:38 <BONUS> also the haskell wikibook thing is awesome
14:20:42 <BONUS> i still read it :]
14:20:56 <wli> vincenz: An ffi call to gmp's fibonacci function will probably be faster.
14:21:00 <johnw> BONUS: I really loved your tutorial, thank you so much
14:21:10 <BONUS> thank you for liking it :D
14:21:13 <edwardk> fynn: yeah, the haskell wikibook would also be a good place to go
14:21:40 <vincenz> wli: I don't use gmp
14:21:43 <Trinithis> I'm trying to install ghc6.10.1, and I'm getting a Cabal conflict. I've tried using "./configure --without-Cabal-1.0.6.1" but that doesn't work. Any ideas?
14:21:43 <johnw> BONUS: I particularly enjoyed the overflowing love for the language that come through loud and clear in your humor and your patience at explaining the examples
14:21:47 <wli> That's all micro-optimized at the bit-twiddling level.
14:22:08 <vincenz> wli: My implementation is not micro-optimized, but I do use a different algo
14:22:22 <Trinithis>  /s/1.6.0.1
14:22:28 <Raynes> BONUS: You should add puppies to the tutorial. Needs moar puppies.
14:22:41 <wli> vincenz: Not based on the duplication formulae?
14:22:55 <wli> vincenz: Matrix-based?
14:23:26 <BONUS> haha johnw thanks, yeah i am still amazed and awed by haskell and FP, and i try to make the examples clear and not use too much confusing language
14:23:31 <vincenz> wli: Not sure what the duplication formulae is.
14:23:36 <BONUS> Raynes: you got it! coming up in the next chapter (Exceptions)
14:23:46 <johnw> BONUS: well, before I read it I knew nothing, now I've written a few functions of my own
14:24:11 <edwardk> (a mendler style catamorphism changes the signature to cata :: (forall a. (a -> b) -> f a -> b) -> Fix f -> b -- eliminating the dependence on f being an instance of Functor through the Yoneda lemma
14:24:16 <wli> vincenz: The formulae for F_{2n+1} and F_{2n} in terms of F_n and F_{n+1}
14:24:23 <vincenz> wli: ah, yes, that one
14:24:37 <BONUS> johnw be sure to get real world haskell once my little tutorial has taught you what it has to teach
14:24:43 <wli> vincenz: That's all I'm using.
14:24:47 <johnw> yes, that's next in my reading queue
14:24:47 * edwardk realized that question was probably more suitable for #haskell-in-depth
14:25:11 <pumpkin_> edwardk: you think you're better than us!
14:25:19 <vincenz> wli: I use an array for momoization
14:25:25 <vincenz> memoization even
14:25:28 <edwardk> pumpkin: no i just don't want to keep scaring newbies =)
14:25:31 <Baughn> pumpkin_: He is better than us. My ears are still ringing, and I think I see tentacles reaching out of the shadows.
14:25:33 <vincenz> wli: and mine is a oneliner
14:25:36 <pumpkin_> :)
14:25:55 <wli> vincenz: Could be interesting.
14:26:03 <vincenz> wli: Let me try to find it
14:26:42 <Eridius> wli: huh, (uncurry (flip (,)) is an interesting trick
14:26:43 <edwardk> they went through all the trouble of creating the channel so i wouldn't keep terrorizing folks around here into thinking you had to know category theory to use haskell. ;) at least thats the way i see it anyways =)
14:27:06 <Eridius> @pl \(a, b) -> (b, a)
14:27:07 <lambdabot> uncurry (flip (,))
14:27:14 <Eridius> ok, so that is the simplest way
14:27:28 <Baughn> Eridius: ..my computer is reaching for me. It's all over now; the category of elder things is coming.
14:27:30 <wli> Eridius: The other one is faster.
14:27:34 <BONUS> johnw btw if you have any corrections, suggestions or requests regarding the tutorial, my inbox is always open :]
14:27:35 <Baughn> *edwardk
14:27:43 <edwardk> Baughn: hahaha
14:27:49 <Eridius> Baughn: is the Cthulhu typeclass still asleep?
14:28:18 <johnw> BONUS: just to get on those "up and coming" chapters :)  Your explanation of the IO Monad was so good, I wanted to see more
14:28:23 <Baughn> Eridius: I haven't checked, and I'm not going to. It might be using lazy i/o.
14:28:28 <Gracenotes> @djinn (a, b) -> (b, a)
14:28:28 <lambdabot> f (a, b) = (b, a)
14:28:32 <edwardk> yeah, there was an instance but we drowned the city it was in in the ocean to buy time for our civilization to develop.
14:28:34 <Eridius> edwardk: as someone who doesn't know category theory, would #haskell-in-depth still be a semi-understandable place to hang out?
14:28:38 <Gracenotes> @. pl djinn (a, b) -> (b, a)
14:28:38 <lambdabot> f = uncurry (flip (,))
14:28:40 <Trinithis> @ty uncurry (flip (,))
14:28:41 <lambdabot> forall b a. (a, b) -> (b, a)
14:28:50 <BONUS> haha yeah, working on the new stuff right nao.
14:28:55 <edwardk> Eridius: yeah
14:29:05 <byorgey> Eridius: sometimes it might be, and sometimes it might not.  only one way to find out. =)
14:29:06 <wli> I just didn't want to add another line for defining a swap function.
14:29:08 <gwern> the Cthulhu typeclass exports, of course, awaken :: OldOne -> OldOne, and devour :: OldOne -> RealWorld# -> RealWorld#
14:29:12 <Gracenotes> @djinn b -> (a -> b) -> Maybe a -> b
14:29:12 <lambdabot> f a b c =
14:29:12 <lambdabot>     case c of
14:29:12 <lambdabot>     Nothing -> a
14:29:12 <lambdabot>     Just d -> b d
14:29:20 <Gracenotes> (Prelude.mehbeh)
14:29:36 <wli> But that one is stupid anyway.
14:29:38 <edwardk> devour :: OldOne -> RealWorld# -> Void
14:29:38 <byorgey> Eridius: of course, the danger is that you might learn some category theory if you're not careful ;)
14:29:39 <Eridius> wli: does (uncurry (flip (,)) get optimized to the same thing as \(a, b) -> (b, a)?
14:29:44 <Eridius> byorgey: oh no!
14:29:50 <gwern> Gracenotes: that the haskell 'NY standard?
14:29:56 <wli> Eridius: I have no idea. The other one is smarter anyway.
14:30:02 <Raynes> BONUS: Awesome. <3 puppies.
14:30:06 <Eridius> wli: yeah, I'm just reading them both
14:30:09 <Gracenotes> ah course, gwern.
14:30:11 <Eridius> Gracenotes: what's @djinn?
14:30:25 <Gracenotes> tries to make a function given a type
14:30:28 <Eridius> huh
14:30:41 <Gracenotes> that matches the type.
14:30:45 <pumpkin_> @djinn (a -> a) -> a
14:30:45 <lambdabot> -- f cannot be realized.
14:30:47 <pumpkin_> boo :)
14:30:48 <Eridius> Gracenotes: I sure hope it matches the type
14:30:48 <Gracenotes> it can't work for everything
14:30:50 <edwardk> Eridius: therem prover, given a type, treats it as a logical predicate and gives you a function with that type if it can
14:30:53 <dolio> > let cata :: (forall a. (a -> b) -> f a -> b) -> Mu f -> b ; cata f = f (cata f) . out in cata (\g n -> case n of Nothing -> 0 ; Just n -> 1 + g n) (In . Just . In . Just . In . Just . In $ Nothing)
14:30:55 <lambdabot>   3
14:31:06 <vincenz> wli: is there any basic code out ther eto do benchmakring?
14:31:06 <pumpkin_> @djinn (a -> b, a) -> b
14:31:06 <lambdabot> f (a, b) = a b
14:31:10 <Eridius> lambdabot sure is impressive sometimes
14:31:14 <Gracenotes> @. type djinn b -> (a -> b) -> Maybe a -> b
14:31:15 <lambdabot> parse error on input `='
14:31:20 <Gracenotes> awwz.
14:31:23 <pumpkin_> Gracenotes: fail
14:31:26 <Eridius> @type curry ($)
14:31:27 <lambdabot>     Couldn't match expected type `(a, b)'
14:31:27 <lambdabot>            against inferred type `a1 -> b1'
14:31:27 <lambdabot>     Probable cause: `$' is applied to too few arguments
14:31:31 <Gracenotes> we needs appendings
14:31:33 <Eridius> err
14:31:35 <Eridius> @type uncurry ($)
14:31:36 <lambdabot> forall a b. (a -> b, a) -> b
14:31:42 <edwardk> dolio: playing with the mendler definition i gave above?
14:31:56 <Eridius> @. pl djinn (a -> b, a) -> b
14:31:56 <lambdabot> f = ap fst snd
14:31:59 <wli> vincenz: Someone besides me had some. I don't know what there is. I pretty much spewed out the code and never saw the results until someone else on #haskell pointed out that I'd appeared in the wiki.
14:32:01 <Eridius> hah
14:32:06 <Baughn> > uncurry ($) (succ, 2)
14:32:08 <lambdabot>   3
14:32:10 <Gracenotes> @type liftM2 id fst snd
14:32:11 <lambdabot> forall r b. (b -> r, b) -> r
14:32:13 <gwern> Eridius: actually djinn is a standalone prog
14:32:19 <dolio> Did you give the definition? I was seeing if I could figure it out based on the type.
14:32:21 <Eridius> gwern: huh
14:32:48 <edwardk> dolio: it appears you got it =). the definition is up in the knol on the topic
14:32:49 <gwern> lb just shells out to it
14:33:20 <edwardk> dolio: the mendler style anamorphism can be derived using the covariant yoneda lemma (that used the contravariant yoneda lemma)
14:33:24 <glguy> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
14:33:24 <glguy> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
14:33:35 * glguy wonders how to handle this
14:33:52 <pumpkin_> glguy: check that ghc-pkg list doesn't have the exact same package in system and user
14:33:54 * fynn is spreading the good word on Haskell in #python
14:33:54 <wli> vincenz: I've no idea what I did to benchmark in the original thread but the machines are gone, along with the code.
14:34:13 <fynn> I believe that entitles me to a complimentary monad.
14:34:14 <edwardk> dolio: and you can go on to do hylomorphisms ala mendler, and all the generalized grecomorphisms as well
14:34:24 <glguy> pumpkin_, old process in system, new process in user
14:34:41 <Baughn> glguy: Please do not do "cabal upgrade".
14:34:48 <wli> I don't really evangelize Haskell much. I mention it as something people might want to learn to diversify programming language knowledge.
14:34:55 <pumpkin_> glguy: dcoutts posted a nice diagram on haskell-cafe a few weeks back explaining the error
14:35:01 <pumpkin_> trying to find it now
14:35:16 <wli> Alongside several Prolog-like languages (including Prolog).
14:35:16 <Eridius> @help compose
14:35:16 <lambdabot> . <cmd1> <cmd2> [args].
14:35:16 <lambdabot> . [or compose] is the composition of two plugins
14:35:16 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
14:35:27 <Eridius> can you compose three plugins?
14:35:46 <pumpkin_> glguy: http://www.haskell.org/pipermail/haskell-cafe/2009-January/054523.html is the one, I think
14:35:56 <vincenz> wli: yours is much faster
14:36:01 <vincenz> wli: not sure why caching costs so much
14:36:33 <Gracenotes> instance Monad Fynn where return = python; q >>= f = f (haskellize q)
14:36:48 <dolio> > let ana :: (forall b. (a -> b) -> a -> f b) -> a -> Mu f ; ana f = In . f (ana f) in ana (\n -> if n == 0 then Nothing else Just (n-1)) 3
14:36:49 <lambdabot>   Couldn't match expected type `a -> f b'
14:37:02 <wli> vincenz: It's the same idea, mine is just using the foreknowledge of what is going to be pulled out of the cache in advance to reduce it in size to two elements.
14:37:19 <Eridius> @. type . pl djinn (a -> b, a) -> b
14:37:20 <lambdabot> parse error on input `='
14:37:22 <vincenz> wli: oh you start at the bottom, not the top?
14:37:23 <Gracenotes> fynn: congratulations, you won a psuedocode monad
14:37:23 <Eridius> bah
14:37:32 <wli> vincenz: Yes.
14:37:37 <Gracenotes> Eridius: unfortunately it won't work due to the =
14:37:41 <Gracenotes> @. type . pl . djinn (a -> b, a) -> b
14:37:41 <lambdabot> Plugin `compose' failed with: Unknown command: "(a"
14:37:42 <catface> @type fix
14:37:43 <lambdabot> forall a. (a -> a) -> a
14:37:43 <edwardk> you probably want (forall b. a -> (a -> b) -> f b) -> a -> Mu f -- that makes it clear you are applying the yoneda lemma to f
14:37:45 <Gracenotes> :X
14:37:49 <fynn> Gracenotes: oh thank you thank you it was all worth it
14:38:00 <wli> vincenz: Bitreversing the number tells which of the two duplicatoin recurrences to use.
14:38:05 <edwardk> CoAlgebra (Yoneda f) a -> a -> Mu f
14:38:07 <Eridius> @. pl djinn (a -> b, a) -> b
14:38:07 <lambdabot> f = ap fst snd
14:38:11 <vincenz> wli: interesting
14:38:13 <Eridius> ah that's the =
14:38:19 <Eridius> @type \f -> ap fst snd
14:38:20 <lambdabot> forall t b b1. t -> (b -> b1, b) -> b1
14:38:24 <vincenz> wli: for reference: http://cpoucet.wordpress.com/2008/04/07/update/
14:38:24 <LeoD> @. unpl pl (\x -> x + 2)
14:38:24 <lambdabot> (\ a -> 2 + a)
14:38:26 <Trinithis> @djinn (a -> a) -> a
14:38:26 <lambdabot> -- f cannot be realized.
14:38:28 <LeoD> yay
14:38:34 <Eridius> oops
14:38:36 <Eridius> @type ap fst snd
14:38:37 <lambdabot> forall b b1. (b -> b1, b) -> b1
14:38:42 <catface> does fix not count as (a -> a) -> a ?
14:38:53 <edwardk> the other is an Algebra (CoYoneda f) a -- modified to drop the existential
14:38:57 <vincenz> wli: I did not try to analyze which elements are used, I thought that since you're doing (n `div` 2  && n `div` 2 +1, you'd get a lot of fanout at the smaller numbers)
14:39:04 <Eridius> interesting, ghci has a much more complicated type annotation for that expression
14:39:17 <Trinithis> @djinn (a -> a) -> (a -> a -> a)
14:39:18 <lambdabot> f a b _ = a b
14:39:49 <Trinithis> cute tool
14:39:52 <Eridius> > ap fst snd $ (succ, 2)
14:39:52 <edwardk> @type uncurry id
14:39:54 <lambdabot> forall b c. (b -> c, b) -> c
14:39:54 <lambdabot>   3
14:40:00 <Eridius> huh, that expression doesn't work in ghci
14:40:01 <Eridius> what am I missing?
14:40:06 <Gracenotes> an import?
14:40:18 <Eridius> is there an alternative definition of ap somewhere?
14:40:20 <Gracenotes> Control.Monad
14:40:26 <Trinithis> <*>
14:40:34 <Trinithis> Control.Applicative
14:40:34 <Eridius> Gracenotes: yes, but that ap puts a Monad constraint on the types
14:40:35 <Gracenotes> ^ in Control.Applicative
14:40:49 <Eridius> Trinithis: that's <*>, not ap
14:40:55 <Eridius> @type ap
14:40:55 <edwardk> Eridius: its the use of ap from Control.Monad on the anonymous Control.Monad.Reader
14:40:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:41:08 <Gracenotes> Eridius: then why did you complain that ap wasn't in scope if you didn't want it? ;)
14:41:14 <wli> vincenz: A little care has to be taken to keep the fanout from happening.
14:41:21 <Eridius> edwardk: ah, there's an invisible monad in lambdabot's evaluation?
14:41:28 <edwardk> > fst <$> snd $ (succ,2)
14:41:29 <lambdabot>       No instance for (Num (a, b))
14:41:29 <lambdabot>        arising from the literal `2' at <in...
14:41:49 <Gracenotes> Eridius: ap *does* apply to monads
14:41:51 <edwardk> er woops
14:41:58 <edwardk> > fst <*> snd $ (succ,2)
14:41:59 <Eridius> Gracenotes: right
14:41:59 <lambdabot>   3
14:42:04 <catface> @djinn forall a. (a -> a) -> a
14:42:04 <lambdabot> -- f cannot be realized.
14:42:11 <Gracenotes> <*> applies to Applicatives
14:42:15 <catface> @type fix
14:42:16 <lambdabot> forall a. (a -> a) -> a
14:42:17 <Eridius> Gracenotes: try running ap fst snd in ghci, you'll see it complain about No instance for (Monad ((->) (b -> b, b)))
14:42:19 <wli> vincenz: Basically it's the choice of recurrences being guided by the evenness or oddness of the quotient by 2^j
14:42:23 <Gracenotes> all monads are applicatives
14:42:34 <Eridius> Gracenotes: I don't think you understand the problem here
14:42:36 <vincenz> wli: cool
14:42:48 <Gracenotes> Eridius: what do you have imported?
14:42:54 <Eridius> Gracenotes: Control.Monad
14:42:58 <dolio> , let ana :: (forall b. (a -> b) -> a -> f b) -> a -> Mu f ; ana f = In . f (ana f) in ana (\g n -> if n == 0 then Nothing else Just (g (n-1))) 3
14:42:59 <lunabot>  luna: Not in scope: data constructor `In'
14:43:04 <dolio> @type let ana :: (forall b. (a -> b) -> a -> f b) -> a -> Mu f ; ana f = In . f (ana f) in ana (\g n -> if n == 0 then Nothing else Just (g (n-1))) 3
14:43:05 <lambdabot> Mu Maybe
14:43:10 <dolio> There we go.
14:43:10 <Eridius> ooh
14:43:13 <Gracenotes> Eridius: try importing Control.Monad.Instances
14:43:16 <Eridius> Control.Monad.Instances gets it
14:43:16 <dolio> Can't show that, though.
14:43:31 <edwardk> Eridius: import Control.Monad.Instances
14:43:38 <Gracenotes> yeah, the problem is that ((->) r) isn't available by defualt
14:43:39 <Eridius> that type signature it complained about was complicated enough that I didn't catch that it matches an Instance
14:43:54 <wli> vincenz: It's very similar to exponentiation. The same bitreversal applies to exponentiation and so on.
14:44:00 <glguy> edwardk, in the spirit of Control.Monad.Categorical, ap would be m(a~>b)->(m a~>m b)?
14:44:17 <dolio> , let ana :: (forall b. (a -> b) -> a -> f b) -> a -> Mu f ; ana f = InF . f (ana f) in ana (\g n -> if n == 0 then Nothing else Just (g (n-1))) 3
14:44:18 <lunabot>  luna: Couldn't match expected type `Control.Functor.Fix.FixF f'
14:44:25 <Gracenotes> > (fst <*> snd) (negate, 10)
14:44:26 <lambdabot>   -10
14:44:30 <edwardk> Eridius: the (->)r monad is defined in there in case someone doesn't want to confuse a newbie =)
14:44:34 <dolio> , let ana :: (forall b. (a -> b) -> a -> f b) -> a -> FixF f ; ana f = InF . f (ana f) in ana (\g n -> if n == 0 then Nothing else Just (g (n-1))) 3
14:44:35 <lunabot>  luna: No instance for (GHC.Show.Show
14:44:36 <edwardk> glguy: close. you'd want it to use the exponential of the category instead. in the left hand side
14:44:40 <dolio> Bah. Forget it.
14:44:47 <Eridius> edwardk: yeah, I always forget that stuff like that is pushed off to Control.Monad.Instances
14:44:56 <Eridius> also partly because I still don't really understand the (->)r monad ;)
14:45:00 * Eridius has no intuitive grasp of it yet
14:45:13 <glguy> edwardk, what is the expenential?
14:45:27 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
14:45:28 <lambdabot>   ("hello","olleh","HELLO")
14:45:30 <pumpkin_> > liftM2 (+) (*4) (*3) 7
14:45:31 <lambdabot>   49
14:45:35 <Cale> Eridius: ^^ does that help?
14:45:35 <Gracenotes> Eridius: it's a bit like Reader
14:45:56 <pumpkin_> although that could be done with applicative, I guess
14:46:14 <edwardk> Technically you want: ap :: Prod (~>) (m (Exp (~>) a b) (m a) ~> m b
14:46:22 <Eridius> Cale: err, kinda, I can trace how that works, it's still the intuitiveness that I haven't quite clicked into place
14:46:23 <Cale> Eridius: computations are functions which take values of type e, and running a computation just means applying it to the parameter which the whole computation is applied to
14:46:24 <edwardk> assuming type family versions of Prod and Exp
14:46:53 <dolio> That's quite a signature.
14:47:05 <Eridius> Cale: hmm
14:47:10 <edwardk> an exponential is a representation of an arrow as an object in the category. with a way to apply it
14:47:25 <edwardk> er, and you'd need a CApplicative instance on m (~>) so
14:47:26 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
14:47:27 <lambdabot>   [5,7,10,25,32]
14:47:51 <Eridius> Cale: I think I understand, I just need to get my hands dirty in actually *using* it to make it click
14:48:03 <edwardk> ap :: CApplicative m (~>) => Prod (~>) (m (Exp (~>) a b) (m a) ~> m b
14:48:14 <glguy> edwardk, so the exponential is how you apply an (a~>b) to an 'a'?
14:48:21 <edwardk> yeah
14:48:28 <Cale> Eridius: Most of the usages are just to get handy functions from Control.Monad for manipulating functions.
14:48:39 <Cale> > ap f g x :: Expr
14:48:40 <lambdabot>   Add a type signature
14:48:47 <glguy> edwardk, is that represented in category-extras?
14:49:01 <Cale> hmm :)
14:49:04 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian-Closed.html
14:49:12 <edwardk> the version there doesn't use typeclasses
14:49:16 <Cale> > ap (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x
14:49:17 <lambdabot>   f x (g x)
14:49:18 <edwardk> a few versions back it did
14:49:34 <Cale> > ap (++) reverse "mirror"
14:49:35 <lambdabot>   "mirrorrorrim"
14:49:40 <dolio> > ap f (g :: Expr -> Expr) x :: Expr
14:49:41 <lambdabot>   f x (g x)
14:49:44 <edwardk> but then i stripped it so it wouldn't scare folks
14:49:52 <Cale> > ap zip tail [1..5]
14:49:53 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
14:50:33 <edwardk> i never implemented CApplicative, but the notion of exponentials are in Control.Category.Cartesian.Closed
14:50:38 <edwardk> er is
14:50:47 <byorgey> @quote zip`ap`tail
14:50:48 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
14:51:18 <Eridius> > (+) <$> (*3) <*> (*4) $ 7
14:51:19 <lambdabot>   49
14:51:19 <Cale> > map (liftM2 (,) head length) . group . sort $ "abracadabra"
14:51:20 <lambdabot>   [('a',5),('b',2),('c',1),('d',1),('r',2)]
14:51:25 <Eridius> > (+) <*> (*3) $ 7
14:51:26 <lambdabot>   28
14:51:27 <edwardk> and in a category with exponentials you could curry the definition i gave above and get one that looks like the haskell definition of ap
14:51:40 <wli> vincenz: Witness the following:
14:51:44 <edwardk> (using the curry from the link i gave)
14:51:45 <wli> > let step (u, v) p | p = (u*v, v*v) | otherwise = (u*u, u*v) ; myExpr (m :: Integer) (n :: Int) = let s = bitSize n in fst . foldl' step (1, m) $ dropWhile not [testBit n k | k <- [s - 1, s - 2 .. 0]] in myExpr 3 4
14:51:46 <byorgey> edwardk: your type signature for ap there seems to be missing a paren
14:51:46 <lambdabot>   81
14:51:51 <pumpkin_> Eridius: but you can't join an Applicative
14:52:01 <Eridius> pumpkin_: hmm? I'm not joining
14:52:08 <pumpkin_> I know
14:52:19 <Eridius> > (,) <*> succ $ 5
14:52:20 <lambdabot>   (5,6)
14:52:22 <glguy> edwardk, Have you seen the Prodarrows paper about stream processors?
14:52:23 <pumpkin_> you were just redoing the example I gave with applicative, was saying what couldn't be done with it :)
14:52:30 <Trinithis> anyone know how to remove Cabal from a linux system?
14:52:39 <pumpkin_> Trinithis: uninstall ghc
14:52:50 <Eridius> pumpkin_: ahh yes
14:52:56 <wli> vincenz: It's the same thing for Fibonacci, just the recurrences for the 2*n-th and 2*n+/-1 -th terms are different.
14:52:59 <pumpkin_> > join (==) 5
14:53:00 <lambdabot>   True
14:53:08 <Trinithis> fun
14:53:14 <Eridius> pumpkin_: heh
14:53:24 <edwardk> which would look like: ap :: CApplicative m (~>) => m (Exp (~>) a b) ~> Exp (~>) (m a) (m b)
14:53:28 <pumpkin_> > join (==) 5 :: Expr
14:53:28 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Bool'
14:53:30 <Eridius> > join (+) 5
14:53:31 <pumpkin_> :(
14:53:31 <lambdabot>   10
14:53:33 <vincenz> wli: Sorry, was not paying attention, reading
14:53:40 <Gracenotes> Eridius: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2364#a2364
14:53:41 <Eridius> > join (,) 3
14:53:42 <lambdabot>   (3,3)
14:53:43 <pumpkin_> Trinithis: cabal-install lives in .cabal usually
14:53:46 <pumpkin_> ~/.cabal, that is
14:53:46 <edwardk> byorgey: probably =) i wrote it off the cuff
14:54:02 <Trinithis> ok
14:54:06 <Gracenotes> Eridius: not sure if it'll help, but there's a bunch of implementations of an evaluator using Reader and ((->) r), all having the same behavior
14:54:09 <Eridius> huh
14:54:12 <Eridius> I'll have to look at that later
14:54:15 <Eridius> I have a phone interview in 5 minutes
14:54:18 <Gracenotes> it gets complicated, especially with qeval
14:54:20 <Gracenotes> okay :)
14:54:50 <byorgey> edwardk: sorry, I wasn't just pointing it out to be anal, I meant I actually wanted to know where the missing paren went
14:54:55 <byorgey> edwardk: but I think I have inferred it now =)
14:55:01 <edwardk> byorgey: ap :: CApplicative m (~>) => Prod (~>) (m (Exp (~>) a b)) (m a) ~> m b
14:55:01 <pumpkin_> StrictAnal
14:55:05 <ddarius> byorgey: It's on his cuff
14:55:10 <byorgey> yes, I got it right!
14:55:12 <byorgey> hehe
14:55:51 <edwardk> byorgey: i wasn't trying to be defensive, just couldn't find it while scrolling back at first ;)
14:56:03 <byorgey> =)
14:56:58 <edwardk> anyways the requirement of exponentials (and products) is why Monad could be a subclass of Applicative but CMonad would not necessarily be a subclass of CApplicative
14:57:21 <vincenz> CApplicative == ?
14:57:27 <vincenz> and CMonad == ?
14:57:38 <edwardk> vincenz: a generalization of applicative to arbitrary categories
14:57:43 * vincenz nods
14:57:52 <edwardk> vincenz: Control.Functor.Categorical in category-extras has CMonad iirc
14:57:55 <vincenz> edwardk: Generalizing over arrows?
14:58:23 <edwardk> vincenz: generalized over arbitrary categories, arrows are just one particularly heavily constrained categories
14:58:33 <glguy> It seems like it might be more clear to use fundep syntax here: (Prod (↝)(×), Exp (↝)(?)) ⇒ (m (a ? b)×m a) ↝ m b
14:58:38 <vincenz> edwardk: I meant not haskell arrows, but CT arrows
14:58:44 <vincenz> edwardk: Since I presume the objects are fixed to the haskell types.
14:58:48 <edwardk> vincenz: Control.Category.* in category extras makes progressively more interesting ones
14:58:57 <wli> > let myExpr (m :: Integer) (n :: Int) = let s = bitSize n in fst . flip execState (1, m) . mapM_ (\p -> do { (u, v) <- get ; if p then put (u*v, v*v) else put (u*u, u*v) }) $ dropWhile not [testBit n k | k <- [s - 1, s - 2 .. 0]] in myExpr 3 4
14:58:59 <lambdabot>   81
14:59:23 <edwardk> glguy: category extras uses fundeps right now, but they make it a pain in the ass to use. its a little clearer, but you wind up including every one of those things including the units, etc. even when you don't use them in the type signature
14:59:47 <edwardk> glguy: CCC (~>) => foo ~> bar -- tends to be a lot more concise
15:00:55 <edwardk> vincenz: in that sense, yes, but note you can have a category that consists of just one type, where the arrows are objects. i.e. you can make a category out of any monoid by abusing GADTs
15:01:09 <wli> There's a stupid trick somewhere for taking advantage of the fact the first bit you hit is always True
15:01:22 <whoppix> Is it possible to make lambdabot remember a function? I'd like it to learn fib, so that I don't have to inline the algorithmus, when playing around.
15:01:43 <vincenz> edwardk: oic
15:01:47 <vincenz> edwardk: the 1-category
15:01:50 <vincenz> or whatever that's called
15:02:34 <edwardk> data M x a b where M :: Monoid x => x -> M () () -- or more succinctly data M a b where M :: Monoid a => a -> M a a -- which yields a novel variation on the monoid as a category theme.
15:02:58 <edwardk> its not quite the category '1' that just has one object and one arrow.
15:03:18 <edwardk> any category with just one object is a monoid.
15:03:55 <edwardk> the (.) is the operation of the monoid and id is its unit. its associative by virtue of being a category and (.) is a binary operation
15:03:57 <vincenz> Ah, right,  Iwas confusing that
15:04:03 <vincenz> CT is still not my forte
15:04:09 <vincenz> I realized too late 1-ct requires 1 arrow
15:04:21 <Gracenotes> you have shamed your mother and father
15:04:32 <Gracenotes> it is an embarrassment you will take to your grave
15:04:35 <Gracenotes> :(
15:04:35 <wli> Woops, not always; if the argument is 0 it's not.
15:05:18 <edwardk> most ct things have nice analogues in abstract algebra when you restrict the category to one object, and as lattices/orders when you restrict them to at most one  canonical arrow between any two objects
15:05:49 <edwardk> (starting at preorder and working up)
15:07:07 <wli> Hmm. The Env things are like (perhaps partially filled-out) tables of free variables in lambda lifting.
15:08:02 <drhodes> whoppix: it can store lambda functions, if that helps
15:08:16 <drhodes> @let square = \x -> x*x
15:08:17 <lambdabot>  <local>:2:0:
15:08:17 <lambdabot>      Multiple declarations of `L.square'
15:08:17 <lambdabot>      Declared at: <loc...
15:08:28 <wli> They only need to include the free variables referenced by the nested scope, not necessarily everything defined above.
15:08:38 <drhodes> @let mySquare = \x -> x*x
15:08:39 <lambdabot>  Defined.
15:09:56 <whoppix> Draconxx, ah. thanks.
15:10:17 <drhodes> sure :)
15:10:26 <Gracenotes> @type square
15:10:27 <lambdabot> forall a. (Num a) => a -> a
15:10:29 <edwardk> @let double = join mappend
15:10:30 <lambdabot>  Defined.
15:10:31 <wli> I'm not 100% sure when you actually need them.
15:10:42 <chessguy> @type double
15:10:43 <lambdabot>     Ambiguous occurrence `double'
15:10:43 <lambdabot>     It could refer to either `L.double', defined at <local>:3:0
15:10:43 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.double', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
15:10:51 <chessguy> @type L.double
15:10:52 <lambdabot> forall a. (Monoid a) => a -> a
15:10:56 <Gracenotes> > L.double (Sum 10)
15:10:57 <lambdabot>   Sum {getSum = 20}
15:11:09 <chessguy> > L.double [1,2]
15:11:10 <lambdabot>   [1,2,1,2]
15:11:12 <ddarius> wli: You never do.
15:11:21 <edwardk> > L.double (Product 10)
15:11:22 <lambdabot>   Product {getProduct = 100}
15:11:36 <vincenz> '[
15:11:52 <whoppix> Draconxx, now I just don't really know how to put multiple statements and guards on one line.. Ah, I guess I'll just write it to a file.
15:12:46 <wli> ddarius: My current fuzzy thought is that they're needed when a function is either returned as a value or passed to another function, and variables escape there.
15:13:27 <glguy> edwardk: in the previous type signature, (Prod (↝)(×), Exp (↝)(?)) ⇒ (m (a ? b)×m a) ↝ m b  what symbol might ? commonly be?
15:13:41 <wli> ddarius: The fuzzy thought is fuzzy because "from what?" is not addressed.
15:14:20 <glguy> edwardk, would it actually be ↝ ?
15:15:11 <edwardk> > appEndo (L.double (Endo (*2))) 3
15:15:13 <lambdabot>   12
15:15:16 <wli> ddarius: I think it ends up being some modularity boundary. If you do whole-program analysis it's never necessary.
15:15:29 <Ficthe> U+219D RIGHTWARDS WAVE ARROW (↝)
15:15:59 <edwardk> glguy: in haskell, yes. some other categories might have exponentials that are different than the type of their hom sets.
15:16:18 <ddarius> wli: Well, I don't really know the context.  If you are talking about an Env to be packaged along with a closure, you only need the free variables referenced by the expression.
15:16:24 <erflynn> Someone explain why I should learn haskell
15:16:34 <ddarius> edwardk: (a -> b) not a Set and thus not a Hom-set.
15:16:46 <ddarius> erflynn: You shouldn't.
15:17:24 <edwardk> glguy: i.e. you can probably build a kleisli category with (->) for exponentials rather than (~>) but i've never done it/checked the laws
15:25:09 <edwardk> ddarius: i knew you'd pop up and clarify my terminology eventually ;)
15:25:09 <ddarius> edwardk: If I wanted to do that I'd simply state that you could either work in a "Hask" enriched category or you could talk about "strong exponentials" to make up terminology.
15:25:10 <Heffalump> hi
15:25:10 * ddarius wonders if saying "Hom-types" would make things easier for people learning about CT from a Haskell perspective.
15:26:55 * mmorrow is starting to like "type family a :-> b"
15:27:32 <pumpkin_> anyone have any idea how http://hackage.haskell.org/cgi-bin/hackage-scripts/package/streamproc-1.2 works?
15:27:39 <mmorrow> which would probably be more useful as "type family F c a b"
15:29:34 <wli> I'm still trying to work out what to do with these expression graphs.
15:31:33 <mmorrow> pumpkin_: it looks like it's the "build (abstractly) a thingy with a GADT, whose type describes the eventual outcome rather than what's actually inside it", then have an "eval" function that turns those contents into that outcome
15:32:28 <mmorrow> like eg
15:34:00 <mmorrow> data Lists a where One :: a -> Lists [a]; Many :: [Lists a] -> Lists [a]
15:34:42 <mmorrow> eval :: Lists a -> a; eval (One a) = [a]; eval (Many xs) = concatMap eval xs
15:35:18 <pumpkin_> hmm
15:35:29 <mmorrow> that didn't really add anything to the lists, but you can do arbitrary things during "eval"
15:36:05 <mmorrow> pumpkin_: this uses that idea http://moonpatio.com/repos/proc/src/Control/Concurrent/Proc.hs
15:37:29 <Eridius> is there a standard way of benchmarking code? I'm looking at wli's Fastest Fib in the West and I want to compare the two versions to see how much better the second is
15:39:18 <jenner> @pl foldr (\x -> ((++) . (\u -> [(f u)])) x ) []
15:39:18 <lambdabot> foldr ((++) . return . f) []
15:42:35 <povman> PING
15:42:40 <pumpkin_> PONG
15:42:56 <povman> ... PING
15:43:21 <Eridius> SYN
15:43:26 <povman> good morning all. I'm doing the dreaded hssdl-on-mac
15:43:28 <Eridius> or rather ACKSYN
15:43:34 <povman> ah
15:44:01 <Eridius> hssdl?
15:44:03 <povman> it's turning out to be not so dreaded, as i have everything working, but ghc --make builds in the wrong order
15:44:08 <povman> sdl bindings
15:44:26 <Eridius> I see a package called SDL on hackage
15:45:03 <povman> this is the one, yes.
15:45:10 <povman> the darcs repository is called hssdl
15:45:13 <Eridius> ah
15:45:19 <Eridius> looks like Lemmih is the author, maybe he can help you?
15:45:38 <povman> this is more of a ghc question
15:46:11 <wli> These guys are doing strange things with expression trees/graphs.
15:46:18 <povman> if i write "ghc --make -no-hs-main Test.hs Main.hs c_main.c", it tries to compile c_main.c before the ffi has generated header from Main.hs
15:46:39 <dons> don't do that.
15:46:47 <guenni> mmorrow: ping
15:46:52 <mmorrow> pumpkin_: oh, my bad. that's not even using GADTs
15:47:04 <mmorrow> pumpkin_: (i thought i saw a "where" there)
15:47:08 <mmorrow> guenni: hey
15:47:09 <pumpkin_> ah :)
15:47:16 <povman> dons: is this going to be "use cabal" ?
15:47:26 <mmorrow> pumpkin_: in that case, it reminds me of ReadP's `P' datatype
15:47:50 <dons> povman: use cabal
15:48:05 <povman> nammit :p
15:48:55 <guenni> mmorrow: I see quite a lot of code using IORefs, I'm kinda uncomfortable with that, could you say something nice about it to help me with that?
15:49:05 <Debugger> Is cabal evil in the sense it's "bypassing" the OS package manager?
15:49:09 <mmorrow> guenni: heh
15:49:23 <mmorrow> guenni: there's atomicModifyIORef should you need it
15:49:41 <mmorrow> also, using IORefs if a lot less ugly with something like
15:49:53 <Baughn> Debugger: Heh. Yes, if you think that's evil. :P
15:49:55 <mmorrow> ref = newIORef; (!) = readIORef; (.=) = writeIORef
15:50:19 <povman> Debugger: it might be the os package manager which is evil, in the sense that it doesn't integrate with cabal
15:50:21 <mmorrow> do x <- ref 42; print =<< (x!); x .= 99; print =<< (x!)
15:50:23 <mmorrow> 42
15:50:24 <mmorrow> 99
15:50:28 <guenni> mmorrow: well there is and I used it quite a bit, but it's still feels like mutable variables
15:50:52 <mmorrow> guenni: oh, well yeah there's no two ways about that part of it
15:51:17 <povman> mmorrow: what's that syntax?
15:51:24 <povman> oh my stupid
15:51:47 <guenni> mmorrow: is some code not possible without them then, or is it just part of the language as some sort of quick and dirty fix?
15:51:53 <mmorrow> povman: my current favorite renames for excruciatinglyLongAndUglyIOReferee
15:52:46 <kmeyer> hey, isn't there some sort of C language parser framework?
15:52:50 <mmorrow> guenni: i guess there's a few things that would be very inconvenient without them
15:53:06 <guenni> mmorrow: but still possible?
15:53:57 <mmorrow> guenni: definitely
15:54:21 <thoughtpolice> OH MY GOD http://cryp.to/streamproc/docs/Control-Arrow-SP.html
15:54:21 <mmorrow> guenni: possibly maybe slower though, depending on what you'r edoing
15:54:24 <povman> guenni: sometimes mutable variables are the nicest way to write your program
15:54:25 <thoughtpolice> worst colors EVER
15:54:39 <pumpkin_> thoughtpolice: I agree :)
15:54:53 <povman> guenni: e.g. you can pass them to another IO a and have them change
15:55:09 <wli> I'm still trying to smoke out the best way to evaluate these expression graphs.
15:55:10 <luite_> thoughtpolice: hm, that looks a bit like my emacs theme
15:55:15 <guenni> povman: so I noticed, I *was* a bit of a dissappointment though
15:55:20 <mmorrow> yeah, you can great graphs without any indirections
15:55:32 <mmorrow> like you have with   IntMap IntSet
15:56:05 <mmorrow> instead you just have  data Graph a = G {roots :: [IORef a]}
15:56:22 <wli> The representation looks great, but I can't figure out how to carry out evaluation on it, or further transformations to make to things.
15:56:41 <povman> guenni: you don't _have_ to use IO either, but your workaround would probably involve writing something like IO.
15:57:38 <guenni> povman: would you happen to know some refs where I can read more about this? Something like IORef considered harmful?
15:57:54 <povman> using IORef is completely safe though
15:58:27 <guenni> povman: Oh I don't question that, it's just about against RT, don't you think?
15:58:38 <povman> saying mutable variables are a bad thing in haskell is like saying recursion is a bad thing in C
15:59:32 <wli> Actually it is in many kernels because their stacks are very restrictively bounded.
16:00:32 <povman> guenni: it's not against RT. function :: IO ()  returns a procedure
16:00:38 <p_l> wli: And some people actually exploit that fact to implement better recursion :D
16:00:40 <kerlo> What is RT?
16:00:45 <povman> that procedure might change a value
16:00:48 <stepcut>  povman: except mutable variables are a bad idea in C too, you just don't have a choice.
16:01:06 <povman> they're not a bad idea!
16:01:31 <p_l> variables in C are just pointers to regions in memory or stack :D
16:01:36 <guenni> kerlo: referentail transparency
16:01:36 <wli> mmorrow: The trouble seems to be that I need to copy the code to evaluate the same expressions with different starting values.
16:02:03 <wli> p_l: Some of them never make it out of registers, and stack positions aren't necessarily stable.
16:02:24 <povman> if you were writing a GUI program, you might set up some callbacks with IORefs
16:02:26 <p_l> wli: And sometimes stack is implemented with registers as storage :)
16:03:05 <wli> You're either deluded, confused, or both.
16:03:22 <povman> for some problems, mutable variables are the simplest way to implement the solution
16:03:30 <p_l> wli: me? I'm trying to write an emulator of such arch :)
16:03:35 <kmeyer> how hard would it be to add a keyword to Language.C?
16:04:13 <wli> mmorrow: There's some kind of problem with separating code and data I'm trying to find an answer to.
16:04:40 <Gracenotes> povman: to say that returning an IO () is referentially transparent is kind of cheating. If you're running a useful program, chances are you're not merely passing them around.
16:05:14 <BONUS> i dont know, returning an IO () is referentially transparent imo, performing that IO () is not
16:05:26 <BONUS> but IO () is usually worthless if it isn't performed
16:05:27 <povman> BONUS: correct
16:05:46 <Gracenotes> so it's a rather trivial (and not useful) statement
16:05:51 <Gracenotes> true, though :)
16:06:09 <povman> i was refuting the claim that using IO () was not RT
16:06:58 <povman> you're simply returning a procedure which, when executed, modifies some memory
16:07:32 <povman> like how putStrLn modifies the terminal buffer memory
16:08:27 <guenni> povman: I might have misunderstood all this RT business, so sorry. I used to think that it might mean that the order of evaluation *must* be irrelevant and still yield the same result, my mistake
16:08:51 <Gracenotes> sure, you can return an IO (). But to say that not performing an action is referentially transparent is, as I said, cheating :) When GHC is running it, there's no real distinction.
16:09:09 <ddarius> guenni: That's a definition of "purity" (except that you need to add a modulo non-termination), not of "referential transparency"
16:09:36 <guenni> ddarius: my mistake,so sorry
16:09:36 <povman> guenni: evaluating a function :: IO () is RT. executing its return value isn't, but you can't usually do that in haskell
16:10:03 <ddarius> guenni: Not just yours.  Most of the people here are likely not using "referentially transparent" accurately either.
16:10:26 <Eridius> referentially transparent simply means that an expression can be replaced with its value with no changes in functionality
16:11:01 <guenni> Eridius: oh I like that one
16:11:11 <povman> well put
16:11:34 <povman> guenni: there's no reason to not like IORef when you are using IO
16:11:37 <Gracenotes> hm. both putStrLn "a" and putStrLn "b" can be replaced with IO (). But in the plumbing, there are two different RealWorlds, I suppose
16:11:50 <Eridius> from the wikipedia page: An expression is said to be referentially transparent if it can be replaced with its value without changing the program (in other words, yielding a program that has the same effects and output on the same input).
16:11:52 <ddarius> That's just a definition of "referentially transparent", my point is that referential transparency and purity are not the same things.
16:12:06 <BONUS> they're often related though
16:12:14 <ddarius> They are indeed related.
16:12:23 <Eridius> ddarius: yes, I'm not disputing what you said, I was just defining RT
16:12:35 <Eridius> purity and RT go hand-in-hand, but mean different things
16:12:39 <ddarius> Eridius: That wasn't meant as a response to you.
16:12:40 <BONUS> ddarius: how would you define purity?
16:12:41 <Eridius> ok
16:12:54 <ddarius> Eridius: They're often related but not necessarily so.
16:13:06 <guenni> one question: is it still *possible* to do entirely without IORef?
16:13:19 <guenni> and MVar?
16:13:25 <ddarius> BONUS: guenni gave a definition that corresponds to purity (albeit applying it to "referential transparency")
16:13:35 <povman> guenni: is it possible to do without putStrLn if your goal is to print to the screen?
16:13:52 <guenni> povman: I suppose no
16:13:52 <BONUS> yeah i guess thats a pretty good definition
16:14:01 <povman> guenni: probably, but it's freaking hard comparitively
16:14:01 <Eridius> purity means evaluating the result of a function yields no side effects
16:14:16 <Eridius> which implies that order of evaluation becomes irrelevant
16:14:59 <povman> guenni: conclusion: it depends on your problem
16:15:04 <guenni> It's just that I *feel*, so far, that using IORefs is a bit like cheating
16:15:42 <guenni> but I've bend over so many times already and got ... so I guess I'll get used to that too
16:16:24 <guenni> and eventually I'll say, Oh what the heck, so what if it is
16:16:28 <ddarius> povman: IORefs are internal in a way that terminal IO is not.  I can implement any external behavior you'd like without using IORefs, but if you want terminal IO, I'll need to do terminal IO.
16:16:55 <povman> a really good example at this point is multithreaded IO
16:17:21 <Gracenotes> o rly :o
16:17:33 <Gracenotes> :O O:
16:17:47 <povman> to communicate between threads the best way is probably a variable
16:18:37 <mle> TChans!
16:19:51 <povman> mle: isn't that pretty much the same thing
16:20:16 <mle> compared to an IORef?
16:20:21 <povman> yeah
16:20:37 <mle> TVars or MVars would be closer
16:21:09 <mle> TChans are a little more complicated
16:21:22 <povman> imo IORefs are just as pure as everything else in haskell, and if they're the best way to solve your problem then use them
16:22:11 <povman> someone wrote a novel without the letter 'e' once, but they didn't have to
16:22:27 <Peaker> povman: IO code in general is not really "pure"
16:22:56 <Eridius> povman: even better, they wrote it in French (which uses e even more than English)
16:23:05 <Eridius> povman: and even better than that, it was translated into English still without an e
16:23:14 <guenni> povman: it's just and unqualified point of view I was expressing, maybe they indeed are, it is just more about me not being comfortable with them yet.
16:24:12 <guenni> Eridius: hm, anything with sex and violence?
16:24:21 <Eridius> guenni: I have no idea what the book is about
16:27:55 <povman> Peaker: i think it's more that the von neumann architecture, and the universe in general, is not really pure
16:28:16 <Peaker> povman: that doesn't mean you shouldn't write pure code, though :)
16:28:19 <wli> I probably have to go back to the drawing board again.
16:28:34 <povman> it means that to actually DO something (in the universe) you have to be impure
16:28:35 <Peaker> povman: pure modeling of a "non-pure world" is possible and IMO desirable
16:28:49 <p_l> or universe is pure  but just likes to fuck with us
16:28:53 <Peaker> povman: someone has to be, not necessarily "you" -- e.g FRP
16:29:12 <povman> i'd say the definition of "doing something useful" probably includes "impure"
16:29:41 <povman> Peaker: of course, but someone's got to write these things somewhere
16:30:07 <Peaker> povman: pure things are also very useful, you don't have to be impure to be useful.. Non-IO functions are very useful
16:30:17 <Peaker> s/IO/impure monads
16:32:46 <povman> Peaker: only when you pump them through IO
16:33:13 <povman> or when your goal is to understand that function and thus improve your brain
16:33:23 <Philonous> I think purity is a relative thing. You can model impurity with pure functions (think of the state monad) and the other way around (IO values as World -> (a,World))
16:33:34 <povman> which is exactly what IO is
16:33:49 <Peaker> povman: your definition of "useful" is a little weird.  If you can do useful things with it, such as build pure values that are useful, then it is useful.  If the only way to use something is eventually via IO, it doesn't mean its not useful in itself
16:34:38 <povman> to me a function is just its definition
16:35:14 <povman> a definition is useless unless you use it for something, eg use IO to apply it to a value
16:35:39 <povman> and receive back a result
16:36:15 <Peaker> povman: in that sense, IO is just a definition too, useless unless you use a Haskell compiler and a computer to run it
16:36:24 <povman> thats exactly what i'm getting at
16:36:48 <Peaker> povman: its silly, though -- the pure values are meaningful and useful whether they're pumped through IO or build other pure values
16:36:56 <povman> when you write a function that returns IO, you're describing a series of steps. i don't see a problem with some of those steps involving changing a value
16:37:20 <Peaker> povman: the idea is that it is hard to reason about programs that destructively change values
16:37:34 <Peaker> povman: it is much easier to reason about programs whose whole output is modeled in their return type
16:38:49 <Peaker> povman: the semantics of pure functions is much easier to work with and compose
16:39:02 <povman> certainly. i'm not advocating the use of IORef, just saying it's valid
16:39:21 <Peaker> valid for creating programs that are uncompoosable and difficult to reason about :)
16:39:29 <Peaker> in this context, this might be a good read: http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
16:40:05 <povman> every program has to be sequential at some point
16:41:05 <Peaker> povman: that's probably wrong (sequential von neumann isn't the only possible model of execution), and that point should be late, rather than soon, in any case
16:41:35 <povman> i also despise von neumann architecture, but it's what we've got
16:42:17 <Peaker> povman: the way you *execute* programs shouldn't pollute the way you design and write them
16:44:56 <povman> how is it any harder to reason about IORef than with any other IO functions
16:46:48 <wli> Ugh, I've been talking to dead air all this time?
16:46:59 <wli> I was thinking that with no recursion and no lambdas and no function applications I can probably do it.
16:47:06 <wli> I think I did it recently even.
16:47:13 <Peaker> povman: Its harder to reason about IO in general
16:47:27 <Peaker> wli: did what?
16:47:31 <guenni> sry, another question, different subject, I see some piece of code here, using "liftIO", in which module do I find that definition?
16:47:35 <Eridius> wli: did you disconnect and not realize it?
16:47:38 <Peaker> @index liftIO
16:47:38 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
16:47:41 <wli> Peaker: Found a way to separate code and data.
16:47:44 <wli> Eridius: Yes.
16:47:57 <Peaker> wli: what do you mean?
16:48:01 <Eridius> wli: I always get suspicious when my IRC console stops constantly scrolling events from other rooms ;)
16:48:11 <Peaker> guenni: Control.Monad.Trans is probably what you want
16:48:20 <guenni> Peaker: thx
16:48:37 <guenni> Peaker: that's a neat trick to know
16:48:42 <wli> Peaker: Translating some expression to a sequence of operations on a set of temporaries (which, I guess, is vaguely a heap).
16:49:50 <wli> Peaker: Once I run into any sort of control flow I'm dead in the water.
16:50:12 <Peaker> wli: can you show a concrete example of what you want to do?
16:50:18 <povman> Peaker: that's true, but IO is unavoidable. i imagine that sometimes the combined effort and program complexity required to truly minimise use of IO would be greater than that of just using IO
16:51:21 <guenni> and one more question, is anybody here using takusen?
16:52:00 <wli> hunting for an old one
16:52:06 <Peaker> povman: FRP
16:52:40 <Peaker> povman: this problem is nearing solution. When FRP matures, IO will be a non-issue :)
16:53:03 <povman> Peaker: they're still working on that?!
16:53:04 <Eridius> is there a page somewhere that gives a good description of what FRP *is*?
16:53:23 <Peaker> povman: Why wouldn't they be?
16:53:24 <povman> 1. i didn't really understand how it worked last time and 2. i thought it was inactive
16:53:24 <guenni> povman: seems kind of revived actually
16:53:40 <povman> but it seems like a bloody awesome idea whatever it is
16:53:50 <Peaker> povman: FRP is pretty active.  Reactive should work okay as soon as GHC 6.10.2 is released
16:54:02 <Peaker> povman: FRP is a very simple alternative to IO
16:54:14 <wli> Peaker: Found it.
16:54:20 <povman> frp code baffled me
16:54:50 <guenni> takusen anyone?
16:54:50 <Peaker> povman: I can try to explain FRP if you want. Its very simple
16:54:56 <Eridius> Peaker: I'd love to hear an explanation
16:54:58 <povman> ok please
16:55:01 <guenni> me too
16:55:50 <Peaker> okay, conal's FRP (Reactive) has two main primitives it builds everything with
16:55:59 <Peaker> Behavior and Event
16:56:22 <Peaker> (Behavior a) is a time-varying value of type a.  It has a different value of type a for any given time. It can be thought of as (Time -> a)
16:56:37 <Peaker> (Behavior a) is continuous
16:57:03 <Peaker> Behavior is a Functor -- so you can build behaviors by manipulating existing behaviors.  For example,  there is a behavior called "time" which is the current time at all times
16:57:18 <Peaker> so fmap (*2) time   -- gives you the doubled current time at any given time
16:57:28 <wli> Peaker: http://wli.pastebin.com/m784ae36
16:57:52 <Eridius> doubling an abstract time doesn't seem useful unless you have a baseline
16:58:03 <Peaker> Behavior is also an Applicative, so you can combine Behaviors together to build new Behaviors.  x <*> y     applies a behavior function to a behavior argument to get a behavior result.
16:58:04 <wli> Peaker: Once I add let, lambda, app, case, etc. to the mix, I'm stuck.
16:58:16 <Peaker> Eridius: it is useful to get a time that is double the speed
16:58:25 <Eridius> Peaker: well how is Time defined?
16:58:33 <Peaker> Eridius: probably just Double
16:58:40 <Eridius> Peaker: I mean, if Time is, say, interval since some epoch, then doubling it is pretty useless
16:58:57 <Peaker> Eridius: its useless if you're using time's absolute value, but not if you're using it differentially
16:59:06 <wli> Peaker: Recursive let, that is.
16:59:14 <Eridius> Peaker: doubling is not differential
16:59:34 <Eridius> Peaker: anyway, go on
16:59:53 <Peaker> Eridius: if you snapshot the doubled time behavior at a given point, and another point, and subtract them - then the (wrong - epoch) component is cancelled out
17:00:11 <Peaker> @type (<*>)
17:00:12 <Eridius> Peaker: yes, I know that, I was just taking issue with your example
17:00:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:00:30 <Peaker> Eridius: fmap (*2) time is useful for that, but nm
17:00:50 <Peaker> Behavior is also a Monad in theory, but the current Reactive implementation has difficulty implementing it
17:01:14 <Peaker> The fact that Behavior is a monad means that if you have:  Behavior (Behavior a) you can join it into (Behavior a)
17:01:28 <povman> how do you use frp to do something though
17:01:40 <wli> Peaker: Basically any construct requiring contro flow.
17:01:43 <Peaker> Now, Behaviors are not enough to model everything, because they are continuous time-varying values
17:01:55 <Peaker> So Reactive also has Events
17:02:28 <Peaker> (Event a) is a discrete source of future timed values of type a -- It can be thought of as [(Time, a)]
17:03:00 <Peaker> For example:  (keyboardInput :: Event Key)  could represent the keyboard press events in the future
17:03:09 <Peaker> s/in the future//
17:03:28 <Philonous> Peaker: what do you mean when you say (Behavior a) is continuous?
17:04:00 <Peaker> Philonous: it means that it has a potentially different value of type a at any given time point.. These time points should be thought of as real numbers (even though that is obviously not true in the implementation)
17:04:03 <Eridius> Philonous: I interpret that to mean its input domain is the entire domain of Time
17:04:11 <Peaker> yeah, Eridius is right
17:04:13 <pumpkin_> :t loop
17:04:15 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
17:04:27 <Peaker> Now, there are a bunch of functions that allow combining these behaviors and events together
17:04:41 <Peaker> for example,  snapshot :: Behavior b -> Event a -> Event (a, b)
17:04:53 <Philonous> Ah ok. So we abstract away machine precision.
17:04:56 <Peaker> now, Events are also Functors, so you can "fmap" them to modify the event values
17:05:13 <pumpkin_> @djinn ((b, d) -> (c, d)) -> (b -> c)
17:05:13 <lambdabot> -- f cannot be realized.
17:05:21 <pumpkin_> not exactly surprising
17:05:36 <Peaker> Events are also Applicatives, so you can use:  ef <*> ex   and get an event which applies the functions in ef to the values in ex -- you get an event source that has *all* of the results (cartesian product)
17:06:01 <Peaker> the most useful way to combine event sources is with the Monoid instance...  someEvent `mappend` anotherEvent == event that fires for any occurance in either event
17:08:34 <Peaker> some more useful functions to handle events/behaviors are:  accumE :: a -> Event (a->a) -> Event a   ; stepper :: a -> Event a -> Behavior a ; monoidB :: Monoid a => Event (Behavior a) -> Behavior a
17:08:52 <Peaker> povman: for an example of how to actually build something with FRP
17:08:58 <Peaker> povman: lets take the pune game
17:09:01 <Peaker> povman: do you know pune?
17:09:19 <povman> no
17:09:20 <Badger> a pune, or play on words. :P
17:09:58 <Peaker> pune is a game where each player is a worm, and the worms have a current direction (real number) and they have left/right keys that add or subtract a little from the current direction
17:10:03 <Eridius> Peaker: so how does a FRP program express state?
17:10:06 <Peaker> the worms continually grow forward in the current direction
17:10:13 <povman> Peaker: like tron?
17:10:20 <wli> I thought it was a city in India.
17:10:23 <Peaker> povman: yeah but not 90-degree angles, real angles instead
17:10:27 <povman> ah cool
17:10:33 <catface> data Reply tok st a     = Ok !a !(State tok st) ParseError    --parsing succeeded with "a"
17:10:42 <catface> that means the state is strict doesn't it?
17:10:47 <Peaker> Eridius: You'd convert the state to a behavior, probably
17:10:47 <povman> should we move to #haskell-in-depth?
17:10:57 <Peaker> Eridius: or you could use accumE to model a state machine, for example
17:11:12 <ddarius> catface: You'd have to look at the State type as well, but yes, the user state is strict.
17:11:13 <Peaker> #haskell-overflow if you want
17:11:14 <Eridius> hmm
17:11:18 <wli> I think case might be doable with a sort of n-way multiplexer instruction.
17:11:25 <wli> Maybe not.
17:11:38 <catface> data State tok st       = State { stateInput :: [tok]
17:11:51 <catface> so the stateInput is not strict?
17:12:01 <ddarius> catface: No, it's not.
17:14:41 <wli> Other people can deal with control flow. Why can't I?
17:15:42 <ddarius> Trees and lists are easy.  Graphs are hard.
17:15:54 <tomh> monads are hard
17:15:58 <tomh> compared to graphs
17:16:25 <ddarius> They quite definitely are not.
17:16:37 <dolio> Graphs are definitely harder than monads.
17:16:45 <tomh> well to me they are
17:16:53 <ddarius> The idea of graphs is simple enough, but working with them is a huge pain in any language.
17:16:58 <pumpkin_> you should watch eugenia cheng!
17:17:01 <wli> What's definitely not what?
17:17:37 <tomh> well for now i have lots of trouble fitting all my problems into monads or monad transformers or monad readers and more like that
17:17:46 <badbrain> hi
17:17:52 <ddarius> tomh: Why are you trying to do that?
17:18:04 * pumpkin_ feels stupid, he only just realised that it's the catsters and not the casters :P
17:18:04 <tomh> because I am forced to
17:18:06 <pumpkin_> http://www.youtube.com/watch?v=9fohXBj2UEI
17:18:36 <ddarius> Crouching Consonant, Hidden Letter
17:18:42 <pumpkin_> hah
17:19:47 <badbrain> could you please point me to something that would allow me to inspect function's AST? I looked at Template Haskell briefly but as far as my understanding goes, it is more for generating AST rather than inspecting it (of let's say regular fold function)
17:20:13 <tomh> I think understanding what a monad is and actually use them in real life is very different
17:20:24 <badbrain> is it possible at all?
17:20:30 <pumpkin_> badbrain: sure
17:20:58 <pumpkin_> I think you can write a quasiquoter that takes in the haskell string, runs it through something like haskell-src-exts to get an AST, makes changes to it, and outputs the changed AST
17:21:03 <pumpkin_> there might be something simpler though
17:21:43 <guenni> I got it: MONADS ARE LIKE BURITOS
17:21:59 <pumpkin_> yup
17:22:23 <wli> Maybe I should try to do control flow of a C-like source language and translate FP programs to that.
17:22:27 <badbrain> pumpkin: would it be possible to turn a definition of "fold" or "map" into such string?
17:22:28 <necroforest> <guenni> I got it: MONADS ARE LIKE BURITOS
17:22:30 <pumpkin_> monads are like pumpkins, you can smash them, stick candles into them
17:22:36 <ddarius> Wait, I've finally figured it out.  Monads are like lax functors from 1 to Cat!
17:22:36 <necroforest> haha, i'd submit that to bash.org but nobody would get it
17:22:47 <pumpkin_> badbrain: not a pre-existing one, as far as I know
17:23:02 <guenni> well honestly I don't realy understand but I do manage to use them
17:23:06 <pumpkin_> ddarius: quick, write a tutorial ;)
17:23:12 <wli> Monads are like constipation. Comonads are like Ex-Lax.
17:23:19 <pumpkin_> lol
17:23:28 <guenni> I guess I need to figure out what an algebraic data type is first
17:23:39 <skorpan> @remember wli Monads are like constipation. Comonads are like Ex-Lax.
17:23:39 <lambdabot> Good to know.
17:23:45 <skorpan> did i do it right?
17:23:47 <pumpkin_> http://en.wikipedia.org/wiki/Algebraic_data_types
17:23:48 <pumpkin_> yup
17:23:50 <pumpkin_> @quote wli
17:23:50 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
17:23:54 <skorpan> cool
17:24:02 <Peaker> monads are containers that can be sequenced together such that each container gets built by a function that sees all of the previous results of all previous containers.  Monad containers can also be built to contain any specific value we want, too
17:24:38 <badbrain> I'm looking into a way of automatic creation of a function isomorphic to a given homomorphism, I thought that could be a way  but it doesn't seem feasible
17:24:39 <travisbrady> Peaker: that's a nice description
17:24:53 <ddarius> travisbrady: Now tell me how State fits it.
17:25:12 <Valodim> isomorphic to a homomorphism?
17:25:23 <Valodim> isn't an isomorphism basically a bijective homomorphism?
17:25:27 <Philonous> Monads are like an endofunctor with two associated natural transformations
17:25:33 <travisbrady> ddarius: i'd be lying if i said i knew
17:25:35 <pumpkin_> Philonous: quick, write a tutorial
17:25:59 <ddarius> Valodim: Not necessarily.  Either way, that doesn't stop you from having homomorphisms between homomorphisms.
17:26:15 <pumpkin_> how about heteromorphisms?
17:26:37 <Botje> pumpkin_: i was thinking the same thing :]
17:27:00 <skorpan> how about metromorphisms?
17:27:03 <pumpkin_> I don't think homomorphisms can merge with heteromorphisms
17:27:05 <badbrain> Valodim: still, for a given homomorphism, it is not obvious (afaik) to programmatically get a reverse function
17:27:29 <Valodim> there is not necessarily one, is there
17:27:37 <ddarius> badbrain: I think the word you want is "inverse" not "isomorphism"
17:27:51 <guenni> well for a non-math guy like me it's easy to think of atomic values, ie, 1, 2, .. or maybe 'a', 'b', 'c' .. but it's harder to make the step to something that is "composed" ie. SOMECONSTRUCTUR 5 "meandyou"
17:27:57 <badbrain> for a bijective function there should be, shouldn;t it?
17:28:20 <Valodim> yes for a bijective
17:28:34 <travisbrady> ddarius: how does State fit that description of a Monad?
17:28:45 <badbrain> ddarius: my understanding so far is that in terms of categries, isomorphism is a kind of inverse morphism, am I wrong?
17:28:58 <guenni> I have not realy seen anything helpful to make that transition
17:29:22 <Valodim> inversible morphism would be more accurate, nuh?
17:29:28 <ddarius> travisbrady: Why are you asking me?  I'm not the one that said it was a nice description.  I personally think it's useless at best and typically misleading.
17:29:31 <guenni> every tutorial presumes your ability to take that as a given
17:29:55 <travisbrady> ddarius: ahh, my mistake
17:30:32 <pumpkin_> stick to the "a monad is a pumpkin, just cuz" description
17:30:39 <skorpan> guenni: when i first started out learning haskell, i saw algebraic data types as an easy way to make my own silly types, instead of using the built-in primitives found in many other languages, such as int, char, double, arrays, and be stuck with those
17:30:43 <pumpkin_> or "a monad is a triple of abstract things" one
17:30:58 <skorpan> uh, no, that's abstract data types
17:31:07 <pumpkin_> ?
17:31:15 <skorpan> pumpkin_: that was me correcting myself
17:31:18 <pumpkin_> oh :)
17:31:19 <guenni> skorpan: me too, but it doesn't explain what the basis is for it
17:31:20 <badbrain> Valodim, isn't bjection an inversible morphism, just one is in terms of functions, the other in terms of categories?
17:31:34 <skorpan> guenni: the basis?
17:32:03 <guenni> yes, how it got there, from let's say set theory, or some other axiom
17:32:29 <skorpan> guenni: you're on your own buddy :) i never bothered looking too far into that field
17:32:57 <Valodim> bijection is an adjective :P
17:33:01 <Valodim> -ive.
17:33:02 <Valodim> argh
17:33:05 <guenni> skorpan: great, I just got dumped again :), story of my life
17:33:28 <badbrain> ;-)
17:33:36 <Valodim> meh
17:33:39 <skorpan> guenni: it's not you, it's me :)
17:33:42 <skorpan> (it is)
17:33:49 <skorpan> first time i got to say that and i really meant it
17:34:04 <Valodim> this category theory stuff is always making my brain asplode
17:34:30 <skorpan> fmap fmap fmap Valodim
17:34:44 <Valodim> *boom*
17:34:45 * wli thinks he could get further with a C-like source language.
17:35:12 <Valodim> the typeclassopedia did help quite a bit, indeed :)
17:35:13 <guenni> ok guys, for those of you with solid math bg, what is the field / branch in math that teaches you to get from atomic things 'a', 'b', 1, 2, 3 ... etc to (1, 2), (1, "be") etc
17:35:47 <Valodim> branch?
17:36:18 <guenni> yes, branch field, ie, set theory, linear algebra or what ever
17:36:36 <skorpan> guenni: type theory maybe
17:36:52 <Peaker> is there a nicer way to memoise than ([...]!!) ?   (!!) is slow
17:36:57 <Valodim> sounds like set theory indeed
17:37:04 <pumpkin_> PeakerWork: map?
17:37:09 <pumpkin_> IntMap
17:37:10 <guenni> skorpan: trying to make up already? :)
17:37:11 <badbrain> to give an example of what I mean, I wrote a simple bijection Int->String that converts a positive number into its string representation. I was able to inverse this code on a piece of paper, intuitively and I got a correct String->Int parser. I'm wondering whether it's possible to do it programatically and as a next step, with more general cases
17:37:15 <skorpan> i don't know, but there is some interesting things to read about in lambda calculus where you can encode e.g. pairs using *only* lambda calculus
17:37:18 <Peaker> pumpkin_: but then I need to put the computation in a monad
17:37:19 <ddarius> guenni: What do you not understand about that?  In some presentations of set theory, the existence of (a,b) for sets a and b is taken as an axiom.
17:37:25 <Valodim> not sure if sorted collections are part of set theory as well
17:37:54 <Valodim> badbrain: deriving (Read, Show)?
17:37:55 <Valodim> :P
17:38:05 <pumpkin_> Peaker: use rmonad? is the problem the Ord constraint?
17:38:17 <guenni> well I'm not sure if I can understand how the existence of algebraic data types can even be derived ..
17:38:39 <badbrain> Valodim: I want to get read from show ;) I guess I'm lazy
17:38:43 <Olathe> badbrain: Not in general.
17:38:44 <TSC> Peaker: You could use an immutable array
17:39:02 <Valodim> ah, that
17:39:25 <badbrain> Olathe: and programmatically?
17:39:38 <Olathe> badbrain: For instance, reversing MD5 or something should be somewhat difficult.
17:39:46 <Peaker> pumpkin_: no, the problem is that IntMap, afaik, cannot be built as an infinite data structure
17:39:54 <pumpkin_> oh
17:40:00 <pumpkin_> same problem with array I guess then
17:40:01 <Olathe> badbrain: For simple functions, you can do it automatically.
17:40:05 <badbrain> Olathe: MD5 can't be a bijection if it's supposed to have security meaning
17:40:17 <Olathe> badbrain: Well, even restricted inputs.
17:40:32 <pumpkin_> has anyone found an md5 fixpoint yet?
17:40:33 <ddarius> badbrain: Your Int -> String function isn't a bijection.
17:41:03 <Valodim> show :: Int -> String is not a bijection?
17:41:05 <ddarius> badbrain, Olathe: MD5 isn't a bijection and doesn't have an inverse because multiple things have the same MD5 digest.
17:41:16 <pumpkin_> Valodim: how would it be?
17:41:20 <badbrain> ddarius: why? it maps one Int into exactly one [Char]
17:41:37 <Olathe> ddarius: I know, but even if you restrict the inputs to make it a bijection, it should be hard to automatically create the inverse.
17:41:39 <Valodim> pumpkin_: well you can entirely represent an int as a string and vice versa, and that's what read and show do, don't they?
17:42:13 <pumpkin_> there are [Char]s that don't have Int counterparts
17:42:34 <Valodim> aah, that way around. yeah. duh. :P
17:42:45 <pumpkin_> so it's an injection
17:42:54 <Valodim> man it's getting too late for this kinda thinking. /me sleep.
17:42:58 <Olathe> A botox injection.
17:43:17 <badbrain> I guess I need more reading
17:43:45 <Valodim> ok for an injection getting from show to read is still possible, theoretically
17:44:30 <badbrain> pumpkin: but I don't need to consider a set of all [Char] - I can consider a finite set of [Char] representing Ints, is that right?
17:45:07 <badbrain> Valodim: this is my thinking
17:45:13 <Valodim> well for all instances of Ord you can traverse to the left and right to find the value. =P
17:45:17 <wli> The set of MD5 sums is finite and the set of strings ([Char]) is not, so there can be no surjection from the set of MD5 sums to the set of strings, nor any injection from the set of strings to the set of MD5 sums.
17:45:17 <pumpkin_> no, I'm just saying that a function taking Ints to Strings is necessarily not surjective (there's a finite number of Ints and an infinite number of strings, if nothing else)
17:45:19 <ddarius> Valodim: Indeed. And producing a value such that md5 value = x for a given x is also theoretically and even practically possible.  Just time-consuming.
17:45:35 <Olathe> Hahaha
17:46:34 <pumpkin_> badbrain: and even show :: Integer -> String isn't surjective (although you could build a bijection between [Char] and Integer in a different way
17:46:58 <mib_uelxtw> I'm creating a number crunching application in Haskell, but it will need to have a nice GUI. Existing bindings for Haskell won't cut it. How could I interface a GUI built in a different language with the engine written in Haskell?
17:47:18 <Alpounet> why not using qthaskell ?
17:47:28 <Alpounet> or gtk2hs
17:48:27 <badbrain> pumpkin: the fact that it isn't a surjection makes inverse function possible
17:49:04 <pumpkin_> hmm, an inverse that isn't defined on a subset of its domain?
17:49:07 <mib_uelxtw> Alpounet: I thought QTHaskell was not stable. (And I don't like the look of GTK on Windows/Mac OS X)
17:49:15 <badbrain> but it's true that Int->[Char] is not a bijection
17:49:56 <mmorrow> wli: yeah, i didn't really fully appreciate the code/data separation until recently
17:49:59 <Alpounet> v1.1.2, looks like a serious and viable work
17:50:07 <badbrain> pumpkin: you mean surjection or bijection?
17:50:07 <mib_uelxtw> Alpounet: also, QTHaskell is GPL. Which is not good for my commercial endavour.
17:50:47 <pumpkin_> badbrain: you said that it not being a surjection made an inverse possible... not being a surjection means that not all of the range is covered, so does that mean that the inverse would not be defined on some inputs?
17:51:04 <mmorrow> i love when you realize later that you didn't quite fully see something, but the messed up version of what you thought it was like was broken in such a way that you were correct by accident
17:51:08 <wli> mmorrow: I'm thinking translating to a C-like language before trying to go to linear code might be a good idea.
17:52:05 <wli> A C-like IR that is.
17:52:15 <Axman6> conal: I did indeed find it, and thought it was quite cool. Have you seen Apple's Quartz Composer?
17:52:20 <badbrain> pumpkin: well, I was wrong, it would need to be a bijection in a strict sense, non-surjection isn't enough indeed, thanks
17:52:24 <Alpounet> mib_uelxtw, oh, ok :-)
17:52:51 <pumpkin_> badbrain: ah, np :) I'm kind of rusty on this stuff too, so I'm probably spewing out much bullcrap :)
17:52:58 <pumpkin_> Axman6: quartz composer is loads of fun :D
17:53:08 <Axman6> yeah :D
17:53:10 <mmorrow> wli: here's an example/model of what would happen for a let (plus "support" code): http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1875#a1875
17:53:18 <conal> Axman6: yeah.  i've seen some of it.  in fact, i gave that same talk at apple the next day, and then at intel.
17:53:25 <pumpkin_> Axman6: it also has a really nice purty interface
17:53:37 <Axman6> conal: ha, i see. awesome :D
17:54:07 <thoughtpolice> oi
17:54:11 * thoughtpolice is almost done with work
17:54:13 <badbrain> pumpkin: seriously thanks :) I understood a few things tonight, my maths is also full of white spots
17:54:17 <conal> my impression of quartz is that it lacks a simple/general/powerful foundation.
17:54:17 <wli> mmorrow: I'm instantly lost with all the strange stack machine stuff.
17:54:27 <badbrain> pumpkin: actually I didn't mean to say "also"
17:54:29 <badbrain> :)
17:54:35 <conal> as do almost all "visual programming" systems.
17:54:37 <pumpkin_> hah, you're welcome :)
17:55:09 <pumpkin_> conal: yeah, composer is a nice UI/concept built up on top of not-so-pretty innards
17:55:21 <conal> pumpkin_: always seems to be the case with these systems.
17:56:16 <Axman6> i think it's very well done though. things are very composable, and once you've composed them, you can wrap them all up into a box to make a nice abstracted component
17:56:34 <pumpkin_> yeah, the composer does it nicely
17:56:43 <mmorrow> wli: i'm actually not using a stack there
17:56:49 <pumpkin_> but if you want to get similar behavior minus the composer, it's a lot more ugly
17:57:20 <pumpkin_> it's as if they stuck a nice (visual) composable API on top of something that didn't really work that way
17:57:29 <wli> mmorrow: Then I'm even more lost than I thought, then.
17:58:03 <mmorrow> wli: each of those "new*" is allocating a new heap node
17:58:05 <conal> i'm working on a new functional gpu programming system now.  i plan to resurrect eros and connect the two.
17:58:19 <mmorrow> that M monad is just State
17:58:37 <conal> because the foundation is so elegant, the filters are trivially easy to write and highly optimizable.
17:59:01 <mmorrow> (where i guesspossibly confusingly, the monad is S, and M a = S (State e) a, where State e = State {regs :: Regs, heap :: Heap}
17:59:02 <mmorrow> )
17:59:02 <lunabotjs>  jseval: <stdin>: hGetLine: end of file
18:00:51 <pumpkin_> conal: nice, I look forward to seeing more :D
18:01:05 <conal> :)
18:01:22 <Peaker> conal: any idea when ghc is released to fix the unamb/Reactive issues?
18:01:54 <conal> Peaker: no, i haven't heard what GHC release has/will-have the required fixes to the concurrency RTS.
18:02:19 <conal> Peaker: soon, i hope.  i keep thinking of cool things to do with unamb/lub.
18:04:41 <wli> mmorrow: Still, I'm quite lost wrt. what these PAP, FUN, CODE, etc. things are doing.
18:07:17 <mmorrow> wli: those are the different types of heap nodes/closures
18:07:36 <mmorrow> , getClosureType ()
18:07:39 <lunabot>  luna: Not in scope: `getClosureType'
18:07:41 <mmorrow> , closureType ()
18:07:45 <lunabot>  Constr
18:07:50 <mmorrow> , closureType (1 + 1)
18:07:52 <lunabot>  AP
18:07:54 <Peaker> conal: I really really want Reactive to be out already, I want to make a demonstration of how easy it is to implement a game with Reactive, by simply writing it in front of all my coworkers :)
18:08:10 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
18:08:12 <conal> Peaker: :)
18:08:12 <lunabot>  [AP,Constr]
18:08:18 <conal> Peaker: me too.
18:08:22 <mmorrow> , closureType id
18:08:24 <lunabot>  Fun
18:08:26 <conal> (want it to be out)
18:08:40 <mmorrow> , let x = const 42 in [closureType x, x `seq` closureType x]
18:08:42 <lunabot>  [AP,Indirection 28]
18:09:05 <thoughtpolice> conal: what's keeping reactive's development halted? it looks neato and i'd like to play, but from what I've heard there's a bad rts bug preventing work?
18:09:30 <Philonous> @type closureType
18:09:30 <lambdabot> Not in scope: `closureType'
18:09:32 <wli> mmorrow: I guess about all I can say is that I don't get them.
18:10:21 <conal> thoughtpolice: yes, a serious rts bug that unamb revealed.  (reactive uses unamb in a crucial way.)  and then i got engrossed in writing for icfp.
18:10:28 <dolio> , In Nothing
18:10:29 <lunabot>  luna: Not in scope: data constructor `In'
18:10:34 <dolio> , InF Nothing
18:10:35 <mmorrow> wli: like, when you say "let x = 42", that's really allocating a Constructor heap node with one literal value == 42
18:10:35 <lunabot>  luna: No instance for (GHC.Show.Show
18:10:42 <mmorrow> , src ''Int
18:10:45 <lunabot>  data Int = I# Int#
18:10:52 <mmorrow> and I# has tag 0
18:11:02 <mmorrow> CON 0 [42]
18:11:21 <Peaker> conal: what's the RTS bug exactly? is it difficult to describe?
18:11:25 <mmorrow> (but in that model code, i'm not considering unboxed literals)
18:11:35 <mmorrow> , src ''closureType
18:11:36 <lunabot>  luna: Not in scope: type variable `closureType'
18:11:40 <mmorrow> , src 'closureType
18:11:42 <lunabot>  closureType :: forall a . a -> ClosureType
18:11:55 <mmorrow> , src ''ClosureType
18:11:58 <lunabot>  data ClosureType = Constr
18:11:58 <lunabot>                   | Fun
18:11:58 <lunabot>                   | Thunk Int
18:12:00 <mmorrow> ..
18:12:08 <conal> Peaker: there are at least two long threads on the reactive mailing list plus one of my blog posts.  at least part of the problem has been fixed in ghc head.
18:12:11 <mmorrow> , ''ClosureType
18:12:12 <lunabot>  RtClosureInspect.ClosureType
18:12:20 <wli> And all the references to x in the let body use the address returned by the allocation as the operand where x would appear?
18:12:29 <chessguy> hmm, anybody tried the soegtk package from hackage lately? is that what i need to play with the HSOE code these days?
18:12:34 <mmorrow> wli: exactly
18:12:53 <wli> mmorrow: So what are AP and PAP?
18:13:03 <mmorrow> wli: so that's the eval/apply stuff
18:13:55 <sinewysam> just got disconnected..
18:13:59 <sinewysam> hi, i'm trying to write a program that checks to see if a binary tree is balanced or not. i get non-exhaustive pattern with tree v.
18:14:00 <mmorrow> i kinda did that quickly and wasn't focusing that much on being fully accurate wrt that part of it, but essentially PAP is for when you have less args than the arity of the function you want to apply to them
18:14:13 <sinewysam> http://pastebin.com/m48157800
18:14:28 <mmorrow> and AP there is for when you have _more_ args than the arity of the fun you want to apply to them
18:15:07 <Axman6> sinewysam: you need isBalanced Empty = .
18:15:12 <Axman6> ...*
18:15:16 <badbrain> pumpkin: now I'm reading that wikipedia says an injection can be made a bijection (thus inversible) by replacing codomain with function's actual range (in case of my example "[Char] representing integer"), so it should be theoretically correct to construct read from show. Sorry, I hope I'm not annoying, just thought it could be interesting to know.
18:15:18 <mmorrow> in which case you stick a continuation somewhere, eval the function applied to the correct num of args, then apply the result to the extra args saved in that continuation
18:15:21 <Axman6> maybe...
18:15:33 <Axman6> well anyway, you should stick it there incase
18:16:08 <mmorrow> AP [x1,..,xn] :=  [ ](x1,..,xn)
18:16:09 <cschneid> I'm still fighting with GHC, trying to build a shared library.  I'm almost there, but I get a: ld: library not found for -lHShaskell98-1.0.1.0-ghc6.10.1               collect2: ld returned 1 exit status
18:16:11 <wli> mmorrow: I'm a bit lost as to how that ends up translated from any FP stuff.
18:16:22 <Axman6> sinewysam: which function are you getting the failure in?
18:16:32 <sinewysam> isBalanced
18:16:42 <cschneid> how do I pass the location of that lib to haskell?
18:16:49 <mmorrow> wli: this is all after lifting all local lambdas and functions out to top-level, and generating some sort of flat instruction stream
18:16:53 <wli> mmorrow: That looks like a predefined heap format for one. Where's the code?
18:17:05 <mmorrow> wli: what do you mean?
18:17:12 <Axman6> sinewysam: ah, you want isBalanced (Node x l r)                     = isBalanced l && isBalanced r to be the last line
18:17:14 <sinewysam> Axman6: i noticed when i changed line 21 to = True, it works
18:17:21 <sinewysam> why?
18:17:23 <pumpkin_> badbrain: that makes sense, yeah :)
18:17:24 <sinewysam> yeah thats the line
18:17:39 <mmorrow> wli: oh, i see
18:17:46 <wli> mmorrow: I don't see an instruction stream.
18:17:50 <Axman6> well Node i l r will match Node 1 Empty (Node...) etc
18:18:09 <sinewysam> l will match Empty?
18:18:13 <Axman6> yes
18:18:26 <sinewysam> i thought l stands for a non-empty tree
18:18:30 <Axman6> no
18:18:35 <Axman6> it's just a name
18:18:45 <sinewysam> hmm
18:18:51 <Axman6> that's bound to whatever's on the left side of the node
18:18:53 <mmorrow> wli: ah, yeah. so that's the missing part
18:19:28 <mmorrow> wli: that code is just meant to model the heap, and leaves it to the programmer to pretend that they're the instruction stream via the M monad..
18:19:47 <wli> These heap nodes are really mysterious to me.
18:20:00 <Axman6> "case Node 1 Empty (Node 2 Empty Empty) of Node i l r" will bind i to 1, l to Empty and r to Node 2 Empty Empty
18:20:41 <aryah> hi!
18:20:52 <centrinia> Is my breadth-first search correct here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2369#a2369
18:20:58 <Axman6> sinewysam: make sense?
18:21:07 <wli> mmorrow: I don't know what you mean.
18:22:01 <aryah> just a quick question re ghc 'dependency' of xmonad - why couldnt it use some more lightweight interpreter,compiler for haskell98 rather than ghc?
18:22:12 <mmorrow> wli: so in that `test0' function, the bytecode/machcode would be what's triggering those actions via the interp/mach themselves, rather than me writing it out in haskell
18:22:35 <mmorrow> the instruction stream for that'd be something like:
18:23:03 <Axman6> aryah: because ghc's by far the best haskell compiler out there, and it probably relies on GHC extensions
18:23:09 <aryah> ah, thx
18:23:15 <sinewysam> Axman6: yeah, i thought Empty would only match to Empty, not just any variable
18:24:03 <Axman6> sinewysam: just got to thing about lists. (x:xs) will match any non empty list, so xs could be [1,2,3,4] or i coukld be the empty list []
18:24:52 <Axman6> think*
18:24:56 <sinewysam> k, thanks. i'll pay more attention to the order in which i write my patterns
18:25:16 <Axman6> good idea
18:26:31 <sinewysam> is it better practice to write the noChild function as a where ... (definition) function ?
18:26:36 <skorpan> centrinia: i don't know, but i'd just like to remind you that documentation is nice, but it can get too much ;)
18:26:52 <centrinia> Oh. :(
18:26:58 <skorpan> centrinia: you have documentation to the point where the code becomes virtually unreadable
18:27:22 <wli> mmorrow: Is there somehow instruction -related code there?
18:28:41 <skorpan> centrinia: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2369#a2370
18:29:02 <dcoutts> Trinithis: did you get your Cabal problem sorted out?
18:29:20 <TomMD> Hey Axman6, you were asking if I posted the thread pool blog - yeah, did you have a question or were you just pointing out the messed up code?
18:30:28 <cschneid> sorry, crashed my system :(.  Any advice on library linking?
18:30:39 <TomMD> --make
18:31:49 <centrinia> skorpan, Okay. That still doesn't solve my problem. :p
18:32:25 <skorpan> centrinia: try asking again, but with the less documented code ;P
18:33:52 <mmorrow> wli: here's almost that exact same expression in ghci with -ddump-bcos (i deleted all the core that's interspersed in there) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1876#a1876
18:34:58 <mmorrow> wli: so that's would be the instruction stream part of it, and what the haskell code in `test0' did to the heap would be roughly what that instruction stream would accomplish
18:35:15 <wli> So MKAP, MKPAP, ALLOC_AP, PUSH_BC0, are the pseudoinstructions?
18:35:26 <wli> Or bytecode instructions.
18:35:30 <mmorrow> yes, exactly
18:37:05 <centrinia> Okay, why does it take 3GB of memory to compute (bfs (addition_tree [1]) 199)) with bfs given here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2369#a2374 ?
18:37:10 <wli> That's some pretty weird stuff. I've done something like that with a push/enter but only via rote cut & waste -like regurgitation from other sources.
18:37:16 <mmorrow> and all that PUSH_APPLY_PPP/similar are (the bytecode versions of) all those generated cases for eval/apply that that GenApply.lhs file makes
18:37:25 <centrinia> I know that (addition_tree [1]) is quite large.
18:37:48 <centrinia> Uh, (bfs (bfs_levels (addition_tree [1])) 199)
18:39:20 <centrinia> bfs_levels is supposed to turn a tree into a list of lists where the outer list correspond to the levels and the inner lists correspond to the trees within a level.
18:39:44 <wli> mmorrow: I guess I don't have any intuition for what those are or when to use them.
18:39:56 <wli> Or how to use them either.
18:40:33 <centrinia> (bfs (bfs_level tree) n) looks for the first level that contains an element that satisfies some condition involving n and returns all elements at that level that satisfy that condition.
18:41:03 <wli> I know add/sub/div/mul and put the results in various places.
18:41:35 <wli> No idea how a case statement or a recursion would get involved there.
18:43:22 <mmorrow> you should read about how the STG machine works, because i think how any of the bytecodes fit into the big picture'd be pretty opaque without seeing the big picture already
18:43:39 <Axman6> TomMD: the messed up code mainly :P
18:48:27 <alatter> am I the only one getting a "404" HTTP error from "cabal update?"
18:48:40 <wli> Reading the STG paper.
18:49:21 <Axman6> alatter: works fine here
18:49:37 <alatter> Axman6: thanks
18:51:11 <alatter> well, "curl http://hackage.haskell.org/package/00-index.tar.gz" also gives 404, which is comforting at least :-)
18:51:36 <Axman6> heh
18:57:31 <TomMD> Axman6: Ok, well it should be fixed now.
19:05:43 <wli> The STG paper's bytecode ops are pretty mind-bending to me.
19:07:18 <ispiked> is there any paradigm for keeping track of a large amount of variables when looping over a list?
19:07:39 <ispiked> should I fold and accumulate in a large tuple, e.g. (x,y,z)?
19:10:41 <lowmagnet> Loving RWH so far
19:18:50 <Axman6> ispiked: seems as good a way as any to me
19:19:09 <ispiked> this is just looking kind of gross
19:19:57 <pumpkin> ispiked: what are the variables representing?
19:21:31 <ispiked> I'm finding the longest occurence of a character inside a substring, so I need to keep track of a) the current char b) how many current chars c) the char with the longest sequence d) the length of the longest sequence
19:22:46 <ispiked> e.g. longestChar(aaabbbcc) would yield b (greater char if there's a tie)
19:23:25 <gwern> hm. I don't think I'd do a fold on that - I'd probably dropWhile a [a] into a [[a]], then sort to get the longest subsequence first, and then do head . head
19:25:18 <ddarius> maximumBy (comparing length) . group
19:25:26 <Olathe> > group "aaabbbcc"
19:25:27 <lambdabot>   ["aaa","bbb","cc"]
19:25:50 <cads> > group "abbaracadabra"
19:25:51 <lambdabot>   ["a","bb","a","r","a","c","a","d","a","b","r","a"]
19:26:18 <Olathe> > sortBy (comparing (\x -> (length x, head x))) . group $ "aaabbbcc"
19:26:19 <lambdabot>   ["cc","aaa","bbb"]
19:26:26 <Olathe> > sortBy (flip comparing (\x -> (length x, head x))) . group $ "aaabbbcc"
19:26:27 <lambdabot>   Couldn't match expected type `[a] -> (Int, a)'
19:26:31 <Olathe> > sortBy (flip $ comparing (\x -> (length x, head x))) . group $ "aaabbbcc"
19:26:32 <lambdabot>   ["bbb","aaa","cc"]
19:26:36 <Olathe> > head . sortBy (flip $ comparing (\x -> (length x, head x))) . group $ "aaabbbcc"
19:26:37 <lambdabot>   "bbb"
19:26:39 <gnuvince_> @type on
19:26:40 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:26:41 <Olathe> > head . head . sortBy (flip $ comparing (\x -> (length x, head x))) . group $ "aaabbbcc"
19:26:42 <lambdabot>   'b'
19:27:14 <Olathe> Hmm...
19:27:27 <ispiked> well, you're no fun ;)
19:27:44 <ddarius> Honestly, if were going to implement the algorithm suggested by ispiked which is direct and efficient, I'd probably just use a recursive function.
19:28:12 <Olathe> > snd . head . sortBy (flip compare) . map (\x -> (length x, head x)) . group $ "aaabbbcc"
19:28:13 <lambdabot>   'b'
19:28:14 <ddarius> :t maximumBy
19:28:15 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:28:27 <ddarius> > maximumBy (comparing length) . group $ "aaabbbcc"
19:28:29 <lambdabot>   "bbb"
19:28:44 <cads> I  bet you could do it with bannanas and lenses and fulcrums and bobby pins
19:28:51 <Olathe> > snd . maximum . map (\x -> (length x, head x)) . group $ "aaabbbcc"
19:28:53 <lambdabot>   'b'
19:28:56 <Olathe> There :)
19:30:48 * ispiked processes
19:33:07 <chessguy> @pl \x -> (length x, head x)
19:33:07 <lambdabot> liftM2 (,) length head
19:33:26 <Peaker> @type (length &&& head)
19:33:27 <lambdabot> forall a. [a] -> (Int, a)
19:33:48 <chessguy> heh
19:33:49 <Axman6> > group [[1,2,3],[1,2,3],[],[],[],[2,3,4],[3,4,5]]
19:33:51 <lambdabot>   [[[1,2,3],[1,2,3]],[[],[],[]],[[2,3,4]],[[3,4,5]]]
19:34:05 <Axman6> > group $ group [[1,2,3],[1,2,3],[],[],[],[2,3,4],[3,4,5]]
19:34:06 <lambdabot>   [[[[1,2,3],[1,2,3]]],[[[],[],[]]],[[[2,3,4]]],[[[3,4,5]]]]
19:34:19 <Axman6> > group . group $ group [[1,2,3],[1,2,3],[],[],[],[2,3,4],[3,4,5]] -- >_>
19:34:20 <lambdabot>   [[[[[1,2,3],[1,2,3]]]],[[[[],[],[]]]],[[[[2,3,4]]]],[[[[3,4,5]]]]]
19:34:36 <Olathe> Oh dear
19:35:09 <olsner> the haskell equivalent of five star programming
19:35:22 <Olathe> What is five star programming ?
19:35:23 <Axman6> five star programming?
19:35:36 <drhodes> thought it was 3 start :D
19:35:38 <Draconx|Laptop> int *****x;
19:35:43 <olsner> http://c2.com/cgi/wiki?ThreeStarProgramming
19:35:50 <Olathe> Heheh
19:35:50 <fynn> more than four star programming, but less than six star programming
19:36:08 <olsner> yeah, it was originally three-star, but that was five levels of listing there
19:36:21 <koninkje> {-# RULES group . group == map (:[]) . group #-}
19:36:29 <ddarius> > let f (c:cs) = f' c 1 c 1 cs where f' c n lc ln (c':cs) | c == c' && n+1 >= lc = f' c (n+1) c n cs | c == c' = f' c (n+1) lc ln cs | otherwise = f' c' 1 lc ln cs; f' c n lc ln [] = (lc, ln) in f "aaabbbcc"
19:36:31 <lambdabot>       No instance for (Num Char)
19:36:31 <lambdabot>        arising from a use of `f' at <interac...
19:36:51 <ddarius> > let f (c:cs) = f' c 1 c 1 cs where f' c n lc ln (c':cs) | c == c' && n+1 >= ln = f' c (n+1) c n cs | c == c' = f' c (n+1) lc ln cs | otherwise = f' c' 1 lc ln cs; f' c n lc ln [] = (lc, ln) in f "aaabbbcc"
19:36:53 <lambdabot>   ('c',1)
19:36:59 <Olathe> > map (:[]) . map (:[]) . group $ [[1,2,3],[1,2,3],[],[],[],[2,3,4],[3,4,5]]
19:37:01 <lambdabot>   [[[[[1,2,3],[1,2,3]]]],[[[[],[],[]]]],[[[[2,3,4]]]],[[[[3,4,5]]]]]
19:37:02 <drhodes> > last (take 5 (iterate $ group [[1,2,3],[1,2,3],[],[],[],[2,3,4],[3,4,5]]))
19:37:03 <lambdabot>   Couldn't match expected type `a -> a'
19:37:11 <Axman6> @check \xs -> group . group xs == map (:[]) . group (xs :: [[Int]])
19:37:12 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:37:29 <Olathe> @check (map (:[]) . map (:[]) . group $ xs) = (group . group . group $ xs)
19:37:29 <Axman6> @check \xs -> (group . group xs) == (map (:[]) . group (xs :: [[Int]]))
19:37:29 <lambdabot>   Parse error at "=" (column 38)
19:37:30 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:37:36 <Olathe> @check \xs -> (map (:[]) . map (:[]) . group $ xs) = (group . group . group $ xs)
19:37:37 <lambdabot>   Parse error at "=" (column 45)
19:37:42 <Olathe> @check \xs -> (map (:[]) . map (:[]) . group $ xs) == (group . group . group $ xs)
19:37:43 <lambdabot>   "OK, passed 500 tests."
19:37:45 <ddarius> > let f (c:cs) = f' c 1 c 1 cs where f' c n lc ln (c':cs) | c == c' && n+1 >= ln = f' c (n+1) c (n+1) cs | c == c' = f' c (n+1) lc ln cs | otherwise = f' c' 1 lc ln cs; f' c n lc ln [] = (lc, ln) in f "aaabbbcc"
19:37:46 <lambdabot>   ('b',3)
19:38:15 <Axman6> @check \xs -> (map (:[]) . map (:[]) . group $ xs) == (group . group . group $ (xs:: [[Int]])
19:38:15 <lambdabot>  Unbalanced parentheses
19:38:20 <Axman6> @check \xs -> (map (:[]) . map (:[]) . group $ xs) == (group . group . group $ (xs:: [[Int]]))
19:38:23 <lambdabot>   "OK, passed 500 tests."
19:38:28 <Axman6> @check \xs -> (map (:[]) . map (:[]) . group $ xs) == (group . group . group $ (xs:: [Int]))
19:38:29 <lambdabot>  Terminated
19:38:33 <Axman6> o.O
19:39:39 <Axman6> "Some people even claimed they'd seen three-star code with function pointers involved, on more than one level of indirection. Sounded as real as UFOs to me."
19:41:01 <olsner> mauke probably does that kind of thing for fun
19:41:06 <idnar> heh
20:16:12 <FunctorSalad> how do I get alpha to work in HOpenGL? (I already have [RGBAMode, WithAlphaComponent])
20:16:52 <FunctorSalad> my first time with opengl too so this might be a general opengl oversight on my part ;)
20:22:27 <pumpkin> rules like "Each program must implement 4 separate functions / procedures / methods like the C# program." are sill
20:22:28 <pumpkin> y
20:27:26 <pastah> how do i go from a list to maybe? [] -> Nothing; (x:_) -> Just x
20:27:34 <pastah> is there some standard function?
20:28:35 <pumpkin> @index listToMaybe
20:28:35 <lambdabot> Data.Maybe
20:28:43 <pumpkin> > listtoMaybe []
20:28:44 <lambdabot>   Not in scope: `listtoMaybe'
20:28:46 <pumpkin> > listToMaybe []
20:28:47 <lambdabot>   Nothing
20:28:52 <pumpkin> > listToMaybe [3]
20:28:53 <lambdabot>   Just 3
20:28:59 <pumpkin> > listToMaybe [3,6]
20:29:00 <lambdabot>   Just 3
20:29:18 <idnar> it took me a while to find that function originally, because I was expecting it to be called safeHead or something
20:30:08 <pumpkin> fmap condom . head ?
20:30:17 <pastah> pumpkin: awsum
20:30:48 <Axman6> pants >>= woman
20:30:59 <Axman6> (assuming trousers are a monad)
20:31:30 <pastah> Axman6: isn't that the OPPOSITE of the way we want to go?
20:31:47 <pastah> getWoman >>= unTrouserize
20:31:52 <Axman6> what's inside the pants goes into the woman function
20:32:06 <pastah> Axman6: ouch
20:32:07 <Axman6> though... it's possible she then ends up with a penis...
20:32:38 <pastah> unsafePerformTrouserOperation
20:32:47 <lament> Axman6: you should perhaps write a monad tutorial
20:32:52 <lament> (or not?)
20:33:02 <pumpkin> lol
20:33:10 <pumpkin> I think everyone writes at least one monad tutorial?
20:33:11 <pastah> Axman6: yeah, learn you a haskell doesn't have it's ready yet
20:33:14 <Axman6> i was thinking that as well :P
20:33:16 <pastah> maybe you can contribute
20:33:22 <pastah> and draw pretty pictures :)
20:33:48 <pumpkin> I didn't think monads were that bad
20:33:59 * Axman6 takes this to #haskell-blah and invents the Genital monad
20:34:00 <pumpkin> everyone throws them around with the oohs and aahs when talking about haskell
20:34:47 <goomba> why dont comonads get any love
20:34:55 <lament> they get colove
20:35:01 <goomba> yes!
20:35:11 <pumpkin> cause they're in category extras
20:35:14 <ddarius> Coalgebraic things in general get very little appreciation in Haskell.
20:35:15 <pumpkin> rather than base
20:35:27 <ddarius> s/very little/relatively little/
20:35:45 <pumpkin> ddarius: how did you get such a strong background in CT?
20:35:57 <ddarius> pumpkin: Reading.
20:36:09 <ddarius> and, I guess, doing stuff.
20:36:50 <pumpkin> any books you suggest? the awodey one Cale recommends has disappeared from my library and I'm reluctant to buy it myself
20:38:05 <ddarius> I learned category theory from things online.  I own "Categories for the Working Mathematician" but I already had a good grasp on category theory when I bought it, so I didn't get too much from it.  It makes a good reference though.
20:38:20 <ddarius> I would, however, recommend Awodey's book as a decent introduction to category theory.
20:38:38 <pumpkin> maybe I'll just give in and live with the pdf :)
20:38:51 * Axman6 hopes his uni does a course on category theory
20:38:53 <ddarius> pumpkin: I'd also recommend learning about mathematics in general.
20:39:17 <pumpkin> yeah
20:39:22 <sciolizer> Anyone read Topoi?
20:40:06 <pastah> the maybe monad is like cheating
20:40:15 <pastah> everything is so awesomelly easy
20:40:27 <pumpkin> smelly?
20:40:52 <FunctorSalad> with the Either String monad you can even see where the error comes from ;)
20:41:17 <pastah> ddarius: what do you think of the book "introduction to category theory for computer scientists"? (green/purple-ish cover)
20:41:31 <pastah> @paste
20:41:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:41:39 <idnar> FunctorSalad: String is a pretty poor error type, though
20:42:14 <ddarius> pastah: Do you mean "Basic Category for Computer Scientists"?
20:42:33 <goomba> i bought practical foundations of mathematics and try to decipher that now and then
20:42:57 <FunctorSalad> idnar: thinking about a custom error type or is there a better alternative in general?
20:43:19 <Axman6> @remember the maybe monad is like cheating. everything is so awesomelly easy.
20:43:19 <lambdabot> Done.
20:43:26 <Axman6> @remember pastah the maybe monad is like cheating. everything is so awesomelly easy.
20:43:27 <lambdabot> Done.
20:43:29 <Axman6> duh
20:43:32 <Axman6> @quote the
20:43:32 <lambdabot> the says: maybe monad is like cheating. everything is so awesomelly easy.
20:43:36 <Axman6> @quote the
20:43:36 <lambdabot> the says: maybe monad is like cheating. everything is so awesomelly easy.
20:43:40 <Axman6> argh
20:43:43 <ivanm> bos31337: ping!
20:43:50 <Axman6> @forge
20:43:50 <lambdabot> Incorrect arguments to quote
20:43:55 <Axman6> @for
20:43:56 <lambdabot> Maybe you meant: forget fortune arr faq ft more yow
20:44:03 <Axman6> @help forget
20:44:03 <lambdabot> forget nick quote.  Delete a quote
20:44:07 <FunctorSalad> @forget the maybe monad is like cheating. everything is so awesomelly easy.
20:44:07 <lambdabot> Done.
20:44:11 <FunctorSalad> @quote the
20:44:11 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:44:12 <ivanm> Axman6: lol
20:44:15 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2378
20:44:19 <idnar> FunctorSalad: I don't really know what the appropriate Haskell convention is
20:44:32 <pastah> ddarius: yes
20:44:36 <idnar> FunctorSalad: but basically, the problem with String errors is that they're only suitable for human consumption
20:44:47 <idnar> FunctorSalad: that's maybe fine for error reporting, but not much good for error recovery
20:44:48 <ivanm> extensible exceptions?
20:44:55 <FunctorSalad> idnar: agreed
20:45:33 <FunctorSalad> idnar: but a human-readable error is a heck of a lot better than "Exception *** Prelude: undefined" IMHO ;)
20:45:35 <ddarius> pastah: I've never read it.  I think I skimmed some PDF of it at one point and didn't see anything interesting to me or particularly notable about the presentation.
20:45:42 <idnar> FunctorSalad: in Python, for example, instead of raising an exception ValueError('unable to parse configuration'), you should probably derive a ConfigurationParseError exception or something and raise that instead
20:45:47 <idnar> FunctorSalad: oh, sure
20:46:09 <idnar> FunctorSalad: or even worse, *** Exception: Maybe.fromJust: Nothing
20:46:11 <idnar> FunctorSalad: :P
20:46:20 <pastah> ddarius: but you knew the basics when you skimmed it?
20:46:34 <FunctorSalad> > fromJust Nothing
20:46:35 <lambdabot>   * Exception: Maybe.fromJust: Nothing
20:46:45 <FunctorSalad> oh, thought that one said 'undefined' too
20:47:06 <idnar> "You know that impossible situation that couldn't happen? Well, it just did."
20:47:08 <pastah> > error "lawlz my ballz"
20:47:10 <lambdabot>   * Exception: lawlz my ballz
20:47:19 <idnar> > undefined
20:47:20 <lambdabot>   * Exception: Prelude.undefined
20:47:37 <FunctorSalad> > (\(Maybe x) -> x) Nothing
20:47:38 <lambdabot>   Not in scope: data constructor `Maybe'
20:47:39 <ivanm> @src undefine
20:47:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:47:40 <ivanm> @src undefined
20:47:40 <lambdabot> undefined =  error "Prelude.undefined"
20:47:46 <FunctorSalad> > (\(Just x) -> x) Nothing
20:47:47 <lambdabot>   * Exception: /tmp/7219858995298651911:71:33-46: Non-exhaustive patterns in ...
20:47:51 <pumpkin> "Scala is also a functional language in the sense that every function is a value."
20:47:58 <idnar> > (\~(Just x) -> x) Nothing
20:47:59 <lambdabot>   <no location info>: parse error on input `->'
20:48:08 <idnar> eep
20:48:10 <ivanm> @djinn Maybe a -> a
20:48:10 <lambdabot> -- f cannot be realized.
20:48:12 <ddarius> pastah: Yes, but I also look at how they present the material.  It didn't seem any more accurate or approachable than most other introductions.
20:48:13 <ivanm> heh
20:48:27 <idnar> what's wrong with my pattern?
20:48:48 <Axman6> @djinn a -> Maybe a -> a
20:48:49 <lambdabot> f a b =
20:48:49 <lambdabot>     case b of
20:48:49 <lambdabot>     Nothing -> a
20:48:49 <lambdabot>     Just c -> c
20:48:49 <ivanm> idnar: ~ isn't allowed for lambdas?
20:49:00 <FunctorSalad> hmm maybe @bot doesn't have the language extension?
20:49:08 <ivanm> @djinn a -> Maybe b
20:49:08 <lambdabot> f _ = Nothing
20:49:09 <idnar> > let eek ~(Just x) = x in eek Nothing
20:49:10 <lambdabot>   * Exception: /tmp/4370860589616966662:71:36-52: Irrefutable pattern failed ...
20:49:12 <ddarius> pastah: I read the Awodey book knowing category theory.  I didn't learn anything from it, but I thought the way it presented the material was rather good.
20:49:15 <idnar> whee!
20:49:59 <idnar> hmm
20:50:03 <ddarius> idnar: You need more parentheses.
20:50:09 <idnar> ddarius: oh, right
20:50:14 <BMeph> ddarius: Was it because you already knew what the book covered, or something else?
20:50:33 <idnar> in (a `seq` b), if a is bottom, the whole thing will be bottom; but will it be the "same" bottom?
20:51:17 <idnar> I guess so (at least in ghc)
20:51:44 <pastah> ddarius: "the Awodey book"?
20:51:51 <ddarius> BMeph: I (assume I) already know what "Basic Category Theory for Computer Scientists" covers and I don't think it's presentation is particularly good (from what I could tell).  I'm not saying it is bad, just not better than most.
20:52:00 <ddarius> @google "Category Theory" Awodey
20:52:03 <lambdabot> http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0198568614
20:53:35 <pastah> ddarius: how good that it's cheap!
20:53:52 <pumpkin> :P
20:54:05 <pumpkin> that's why I was pissed that my library's copy got lost :(
20:54:16 <pumpkin> pastah: a pdf of the book floats around this channel though
20:54:40 <ddarius> I'd like to read this book at some point: http://www.amazon.com/Algebra-Programming-Prentice-Hall-International-Computer/dp/013507245X/ref=sr_1_1?ie=UTF8&s=books&qid=1237002862&sr=1-1
20:54:59 <pumpkin> 249 :o
20:55:19 <pastah> pumpkin: like in my incoming dcc tab?
20:55:35 <pumpkin> maybe :o
20:58:58 <ddarius> idnar: Not necessarily.
21:10:06 <irekj> the oxford book is, at least partially, available on google books: http://books.google.com/books?id=SJVsb1jCZu8C&dq=category+theory&printsec=frontcover&source=bl&ots=FEKZRkO_Rx&sig=Pss0NKKWs9Dadz1stpYll2qTR6U&hl=en&ei=Zmm4ScD0D4-O_gae_vmkBg&sa=X&oi=book_result&resnum=3&ct=result#PPA11,M2
21:10:52 <Cale> pumpkin: I have a PDF of Awodey, you know.
21:11:01 <pumpkin> yup :) you've given it to me
21:11:11 <pumpkin> I just didn't want to be too specific about the source in case
21:11:22 <pumpkin> ... :)
21:11:46 <Cale> ah...
21:12:13 <Cale> In fact, I don't know where it *originally* came from...
21:14:08 <Axman6> zomg! PIRACY! all the purity of this channel has just been lost!
21:14:28 <Cthulhon> Can someone upload or DCC that PDF for me please?
21:14:32 <ivanm> Axman6: lol (about purity)
21:15:13 <chessguy> hmm. State isn't comonadic, is it? :(
21:17:17 <chessguy> @hoogle Comonad
21:17:17 <lambdabot> No results found
21:17:48 <Axman6> @hackage  space in url!
21:17:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/space in url!
21:19:44 <chessguy> @yow
21:19:44 <lambdabot> I'm mentally OVERDRAWN!  What's that SIGNPOST up ahead?  Where's ROD
21:19:44 <lambdabot> STERLING when you really need him?
21:21:25 <Axman6> @hackage ../../../cgi-bin/sysinfo.cgi
21:21:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/../../../cgi-bin/sysinfo.cgi
21:21:43 <pumpkin> you're already in cgi-bin
21:21:43 <Axman6> h4x0r'd
21:21:49 <Axman6> i know!
21:23:42 <pumpkin> there's no requirement for the morphisms and objects in a category to be disjoint?
21:26:20 <ivanm> Axman6: is the new automatic -N extension for +RTS to avoid you from having to beg the shootout for run-time changes? ;-)
21:26:39 <Axman6> noting to do with me i'm afraid :P
21:27:02 <pumpkin> it'll probably be another year before that change makes it out to the general public, I'd  guess?
21:27:58 <ivanm> yeah :s
21:30:26 <Axman6> i swear i heard something in #ghc about them hoping for an august 6.12 :\
21:30:48 <ivanm> Axman6: sure it wasn't 6.10.2 ?
21:31:08 <Axman6> yeah
21:31:21 <Axman6> they were hoping to have an RC for that quite soon
21:31:36 <Axman6> ICFP papers got in the way though :P
21:31:58 <ivanm> lol
21:54:45 <mmorrow> pumpkin: in a category, objects are essentially just their identity morphisms
21:55:27 <mmorrow> in the sense that you could just identify them with their identities, and no information would be lost
21:55:47 <pumpkin> that makes sense
21:57:27 <pastah> @hoogle guard
21:57:27 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
21:57:27 <lambdabot> Language.Haskell.TH data Guard
21:57:27 <lambdabot> Language.Haskell.TH.Syntax data Guard
21:58:28 <pumpkin> mmorrow: any crazy projects on your horizon?
21:58:39 <Axman6> > quard True :: [Int]
21:58:40 <lambdabot>   Not in scope: `quard'
21:58:50 <Axman6> > guard True :: [()]
21:58:52 <lambdabot>   [()]
21:58:59 <Axman6> > guard False :: [()]
21:59:01 <lambdabot>   []
21:59:05 <FunctorSalad> the axioms for composeability without objects are a bit messy though
21:59:32 <Axman6> > guard False :: Maybe ()
21:59:33 <lambdabot>   Nothing
22:04:22 <Axman6> @instances Either
22:04:23 <lambdabot> Couldn't find class `Either'. Try @instances-importing
22:04:27 <Axman6> @instances Monad
22:04:27 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:04:28 <Axman6> urgh
22:04:33 <Axman6> brain splode
22:05:40 <FunctorSalad> > guard False :: Either String ()
22:05:42 <lambdabot>   Left ""
22:05:52 <FunctorSalad> this Axman6?
22:05:58 <pastah> @instances MonadPlus
22:05:59 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:06:10 <pastah> heh, cool, IO
22:06:16 <pumpkin> > let x = do y <- (^4); z <- (*3); z + y; in x 5
22:06:17 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> t
22:06:17 <lambdabot>      Proba...
22:06:27 <pumpkin> > let x = do y <- (^4); z <- (*3); return $ z + y; in x 5
22:06:29 <lambdabot>   640
22:06:32 <FunctorSalad> . o O ( Where does it get the "" from? is there an Error or Monoid constraint? )
22:06:43 <Axman6> > runState $ (guard True :: State String ())
22:06:44 <lambdabot>       Overlapping instances for Show (String -> ((), String))
22:06:44 <lambdabot>        arising ...
22:06:50 <pastah> > readFile "lol" `mplus` print "lol"
22:06:51 <lambdabot>   Couldn't match expected type `String' against inferred type `()'
22:07:12 <FunctorSalad> pastah: lambdabot won't run IO ;)
22:07:25 <pastah> fail...
22:07:50 <pumpkin> > (readFile "oi", 1)
22:07:51 <lambdabot>   (* Exception: "<IO [Char]>"
22:08:01 <pumpkin> why did it try to run that?
22:08:05 <Axman6> :t runState
22:08:06 <lambdabot> forall s a. State s a -> s -> (a, s)
22:08:07 <pumpkin> the show for IO runs it?
22:08:12 <FunctorSalad> > mapM_ sendSpam addresses
22:08:13 <lambdabot>   Not in scope: `sendSpam'Not in scope: `addresses'
22:08:16 <FunctorSalad> ;))
22:08:26 <Axman6> > runState (guard True :: State String ()) "test"
22:08:27 <lambdabot>       No instance for (MonadPlus (State String))
22:08:27 <lambdabot>        arising from a use of...
22:08:44 <Axman6> @instances MonadPlus
22:08:45 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:09:26 <FunctorSalad> pumpkin: sure it tried to run it? isn't that mueval complaining? (no idea)
22:10:06 <pumpkin> > (readFile, 1)
22:10:07 <lambdabot>       Overlapping instances for Show (FilePath -> IO String)
22:10:07 <lambdabot>        arising f...
22:10:54 <Axman6> is there any reason FilePath isn't [String]?
22:11:25 <FunctorSalad> yay I finally managed to render a string in HOpenGL
22:11:34 <Axman6> \o/
22:11:36 <pumpkin> who you callin a ho?
22:11:46 <Axman6> <o/
22:11:46 <FunctorSalad> turns out you need to scale 0.001 0.001 (0.001∷GLfloat) since the default is way large
22:11:50 <Axman6> \o>
22:12:01 <Axman6> ha
22:18:13 <mmorrow> pumpkin: i really want to have this interpreter into a releasable state within a week
22:18:27 <pumpkin> what's the language it interprets?
22:18:55 <mmorrow> it starts from a "core" language that's essentially an untyped barebones lazy functional language
22:19:18 <mmorrow> which should be easily targetble by any such language
22:19:42 <pumpkin> ah
22:19:59 <mmorrow> while at the same time simple enough to even target from a made-up-lang in 100 lines of code
22:20:08 <pumpkin> ah, nice
22:20:17 <wli> aha
22:20:22 <wli> Like LPS?
22:20:40 <mmorrow> also, i'm going to use ghc's external core backend so it'll have a haskell frontend
22:20:50 <mmorrow> wli: lps?
22:21:18 <wli> Yeah, a meta-interpreter.
22:21:41 <mmorrow> the heaps going to be exportable at any point, so you can freeze a heap image, save it to disk/send it over the network/whatnot, then resume at some future point
22:22:03 <pumpkin> sounds nice
22:22:25 <wli> http://lsi.uniovi.es/~labra/LPS/LPS.html
22:22:28 <pumpkin> you mentioned bytecode at some point
22:22:46 <mmorrow> one cool thing that i read in an smlnj paper, that's obvious after the fact, is that exporting the heap is essentially (actually, exactly) the same thing as garbage collecting (with a copying collector)
22:23:00 <mmorrow> you just s/tospace/omglol.txt/
22:23:08 <pumpkin> lol
22:23:32 <mmorrow> pumpkin: yeah, it compiles that core language down to a byecode, which it interprets
22:23:35 <pumpkin> ah
22:23:51 <mmorrow> the and the interpreter core is in C
22:23:58 <pumpkin> onoes
22:24:01 <cads> very cool mmorrow
22:24:03 <mmorrow> so it's free of any haskell runtime
22:24:13 <mmorrow> cads: i'm excited about it :)
22:25:22 <mmorrow> also, i have a minimal ffi for it too.
22:26:08 <cads> hey, mmorrow, I didn't know you studied cat. theory? how long have you been studying it?
22:26:28 <mmorrow> initially, it'll have syscall, and about 30 combinations of the most commonly used arg types (where arg := [Arg], Arg = W32 | W64
22:26:28 <mmorrow> )
22:26:40 <mmorrow> cads: i majored in math
22:26:59 <pumpkin> most undergrad math doesn't do category theory does it?
22:27:02 <mmorrow> cads: i mostly became familiar with it from studying abstract algebra
22:27:17 <mmorrow> pumpkin: i took a few (intro) grad courses
22:27:21 <pumpkin> ah, ok
22:27:24 <ivanm> pumpkin: it doesn't down under... (more of a postgrad thing)
22:27:24 <mmorrow> (and studied on my own)
22:27:51 <mmorrow> but yeah, i've never taken an actual "category theory" course
22:28:09 <mmorrow> i don't think those are very common though... (?)
22:28:31 <pumpkin> none over here :) not saying much though
22:28:36 <cads> it seems like category theory isn't very prevalent among mathematicians... not many people in the math channel have done it, for example
22:28:58 <mmorrow> pumpkin: heh, so you're in the middle of the woods, right
22:29:09 <pumpkin> yup :P
22:29:12 <pumpkin> people study hiking here
22:29:18 <pumpkin> and snowshoeing
22:29:18 <mmorrow> pumpkin: heh
22:29:29 <wli> More people should check out the LPS thing.
22:29:51 <mmorrow> cads: i think it depends on the focus area
22:29:54 <pumpkin> wli: seems very meta! :P
22:30:08 <pumpkin> I like the extensive FAQ sectin
22:30:10 <pumpkin> section
22:30:45 <wli> That's part of why it needs people to go into it.
22:30:53 <mmorrow> cads: like, algebraic geometry/(parts of) topology have a heavy category theory leaning
22:31:18 <mmorrow> but outside of that, it's not very common, yeah
22:31:55 * mmorrow looks at the lps link
22:32:04 <pumpkin> I'm still trying to figure out ((b, d) -> (c, d)) -> b -> c
22:32:12 <wli> The link barely says anything about it.
22:32:19 <pumpkin> oh actually
22:32:31 <wli> It's the code that matters.
22:33:08 <mmorrow> wli: hmm, that looks interesting
22:34:09 <FunctorSalad> mmorrow: not bad for differential geometry either :)
22:34:10 <wli> I remember when LPS came out.
22:34:11 <pumpkin> @type \f x -> let (a, y) = f (x, y) in a
22:34:12 <lambdabot> forall t t1 t2. ((t, t2) -> (t1, t2)) -> t -> t1
22:34:29 <FunctorSalad> (but I'm just a newb)
22:34:43 <pumpkin> whee
22:34:49 <pumpkin> that wasn't so hard
22:34:58 <pumpkin> assuming it's correct
22:35:41 <pumpkin> anyone recognize it?
22:35:51 <mmorrow> FunctorSalad: oh, it's excellent for that :), but i'd say it'd be viewed as snooty by all but the most abstract bent differential geometers
22:36:02 <mmorrow> *+ly
22:36:15 <wli> At one point in the past I understood enough of what was going on that if not entirely approachable I at least got the big picture though not the details of what it was doing.
22:36:19 <cads> mmorrow: it seems like it can be a strong framework to understand abstractions and how they relate to different fields, and as a mnemonic device for remembering different things... but this seems like basic category theory for practical purposes, rather than the advanced stuff for its own sake... am I completely wrong about the first part?
22:37:00 <FunctorSalad> mmorrow: yes, it's really odd... people seem to get subtly annoyed whenever I try to relate things to CT ;)
22:37:26 <cads> I wonder if they would have been the same way about set theory, 70 years ago
22:37:36 <mmorrow> cads: category theory is great because it does with math what math does with other stuff. unifies concepts, makes 10 things to learn into one thing, etc.
22:38:08 <cads> that's what i _need_!
22:38:34 <cads> its hard to break into it
22:38:53 <mmorrow> FunctorSalad: there's always (according to my 8th grade history book, but what do i know) resistance to new ideas.
22:39:10 * wli is not getting a whole lot of traction with the STG paper.
22:39:24 <Axman6> @djinn a -> b -> Maybe a -> Either a b -> (a,b)
22:39:24 <mmorrow> wli: yeah, i just skimmed that one for the most part.
22:39:24 <lambdabot> f a b c d =
22:39:24 <lambdabot>     case c of
22:39:24 <lambdabot>     Nothing -> case d of
22:39:24 <lambdabot>                Left e -> (e, b)
22:39:24 <lambdabot>                Right f -> (a, f)
22:39:25 <FunctorSalad> mmorrow: on the one hand I do believe it's useful, OTOH maybe I am really just being pretentious... hard to tell
22:39:26 <lambdabot>     Just g -> (g, b)
22:39:42 <pumpkin> @hoogle ((t, t2) -> (t1, t2)) -> t -> t1
22:39:42 <lambdabot> No results found
22:39:48 <pumpkin> hoogle fails
22:39:52 <mmorrow> wli: it's slightly outdated too. the one i got the most bang for the buck from was the lvm specification
22:39:57 <Axman6> zomg that owuldn't work it's referencing itself!
22:40:02 <Eridius> @pl \a -> (succ a, pred a)
22:40:02 <lambdabot> liftM2 (,) succ pred
22:40:10 <pumpkin> Axman6: I wrote a definition for it earlier
22:40:10 <wli> I'm not getting far with the Lazy VM spec either.
22:40:18 <Axman6> pumpkin: for what?
22:40:27 <pumpkin> oh, you were talking about the djinn output?
22:40:42 <Axman6> yeah :P
22:40:44 <pumpkin> ah
22:40:50 <pumpkin> how is it referencing itself? :o
22:40:58 <Axman6> notice the function's called f, and there's a
22:41:00 <mmorrow> wli: i had to implement/transcribe it to a minimally working model before i got the "ah, ok i'm starting to see how this stuff goes"
22:41:01 <Axman6> Right f there
22:41:05 <pumpkin> Axman6: that's a pattern match though
22:41:14 <Axman6> yeah but
22:41:22 <pumpkin> the omg-ness still applies?
22:41:41 <pumpkin> I wish I'd gotten into this stuff earlier
22:41:43 <Axman6> yes!
22:41:50 <Eridius> @pl \a -> (+) a (succ a)
22:41:50 <lambdabot> ap (+) succ
22:42:19 <mmorrow> pumpkin: yeah, too bad you're 40
22:42:22 <pumpkin> lol
22:42:26 <mmorrow> ;)
22:42:31 <ivanm> has anyone managed to get profiling support for gtk2hs-0.10 working?
22:42:33 * pumpkin sobs
22:43:27 <pumpkin> I dunno, I had no clue functional languages even existed when I was the age of some of the people who come in here :P
22:43:58 <mmorrow> pumpkin: i didn't know functional language existed until just under two years ago
22:43:59 <pumpkin> not that I'm old and cranky, but it would've affected what I studied to some degree
22:44:12 <Axman6> how old are you pumpkin?
22:44:20 <pumpkin> 24 :P
22:44:30 <Axman6> it was a year ago for me, almost exactly a year ago actually
22:44:38 <mmorrow> when i first saw haskell i was like "holy shitfork! that's what i've been trying to do in C for forever!"
22:44:40 <pumpkin> lol
22:44:44 <Axman6> actually, no, i'd started using erlang before then
22:44:51 <pumpkin> there you go
22:44:59 <Axman6> @quote mmorrow when i first saw haskell i was like "holy shitfork! that's what i've been trying to do in C for  forever!"
22:44:59 <lambdabot> No quotes match. You type like i drive.
22:45:06 <Axman6> @remember mmorrow when i first saw haskell i was like "holy shitfork! that's what i've been trying to do in C for  forever!"
22:45:06 <lambdabot> I will never forget.
22:45:15 <ivanm> I discovered Haskell (well, I'd heard about it earlier in passing...) end of '05
22:45:15 <pumpkin> the for forever is good
22:45:19 <Axman6> @quote shitfork
22:45:19 <lambdabot> mmorrow says: when i first saw haskell i was like "holy shitfork! that's what i've been trying to do in C for  forever!"
22:45:28 <ivanm> mmorrow: "shitfork"?
22:45:30 <pumpkin> @quote strictanal
22:45:31 <lambdabot> ddarius says: "pumpkin: Known for StrictAnal"
22:45:32 <mmorrow> heh, shitfork's a good one
22:45:40 <Axman6> @quote anal
22:45:40 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
22:45:48 <wli> I suck. People half my age programming in Haskell for a fifth the time I have or less are doing things that are essentially forever beyond my grasp.
22:45:51 <Axman6> @quote anal
22:45:51 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
22:45:58 <Axman6> @quote anal
22:45:59 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
22:45:59 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
22:46:04 <ivanm> Axman6: looking for the java one?
22:46:09 <pumpkin> wli: no you don't
22:46:10 <Axman6> @quote Axman
22:46:10 <lambdabot> No quotes match. It can only be attributed to human error.
22:46:14 <Axman6> @quote Axman6
22:46:14 <lambdabot> Axman6 says: inface, ST is just plain awesome
22:46:18 <Axman6> @quote Axman6
22:46:18 <lambdabot> Axman6 says: -ddump-occur-anal <- another terrible name...
22:46:26 <pumpkin> :)
22:46:28 <Axman6> :)
22:46:44 <wli> @quote wli
22:46:44 <lambdabot> wli says: brb kitchen fire
22:46:54 <wli> @quote wli
22:46:54 <lambdabot> wli says: My solution is to stop reading haskell.org
22:46:59 <wli> @quote wli
22:46:59 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
22:47:15 <ivanm> since we're doing the equivalent of googling for ourselves...
22:47:16 <Axman6> Ex-Lax? o.O
22:47:18 <ivanm> @quote ivanm
22:47:18 <lambdabot> osfameron says: <ivanm> @localtime popcorn <osfameron> every time is popcorn time
22:47:35 <wli> Why can't I figure out these virtual machines?
22:47:49 <FunctorSalad> Axman6: WTH, that flag actually exists
22:47:51 <Axman6> wli: because they don't really exist :O
22:47:53 <pumpkin> math rots the mind
22:47:57 <Axman6> FunctorSalad: yep
22:47:58 <pumpkin> so does school
22:48:05 <pumpkin> the only true teacher is PAIN
22:48:27 * pumpkin pulls out his cat o' nine tails
22:48:31 <ivanm> pumpkin: you mean this? www.physics.uq.edu.au/pain ?
22:48:45 <pumpkin> :o
22:48:51 <cads> @quote cads
22:48:51 <lambdabot> cads says: waiting is.
22:49:01 <ivanm> pumpkin: ;-)
22:49:06 <cads> yes. yes it is.
22:49:08 <pumpkin> I prefer my tools
22:49:34 <pumpkin> so edwardk tried to explain it to me
22:49:44 <pumpkin> but does anyone have any clue what the hell ArrowLoop is for? :P
22:49:52 <pumpkin> (that's what the funky type signature I wrote above is from)
22:50:04 <Axman6> pumpkin: the LHC
22:50:10 <FunctorSalad> pumpkin: that was my thought too when I read the docs ;)
22:50:19 <pumpkin> @type \f x -> let (a, y) = f (x, y) in a
22:50:20 <lambdabot> forall t t1 t2. ((t, t2) -> (t1, t2)) -> t -> t1
22:50:25 <pumpkin> that's my "solution" to the type
22:50:35 <pumpkin> but its existence still makes no sense to me
22:51:00 <Axman6> yeah... whut?
22:51:33 <pumpkin> if you think of it as feeding two things, you loop one of them back on itself, and pass the other through a function as the output?
22:51:42 <pumpkin> I can draw a picture, but it still doesn't make much sense to me
22:51:51 <Axman6> :t \f x -> let (a,_) = f (x,undefined) in a
22:51:52 <lambdabot> forall t t1 t2 a. ((t, a) -> (t1, t2)) -> t -> t1
22:52:05 <pumpkin> Axman6: I did that one too, but it didn't feel as loopy
22:52:09 <pumpkin> :t loop
22:52:10 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
22:52:27 <pumpkin> also, presumably the type signature is used for something and not just there to be esoteric
22:52:39 <FunctorSalad> to me it looks like the b is the "environment", then you go into an infinite loop iterating (d -> d), then you return some c :D
22:52:52 <Eridius> @pl \i -> if (i == 0) then (i+1) else (i-1)
22:52:52 <lambdabot> liftM2 if' (0 ==) (1 +) `ap` subtract 1
22:52:53 <Axman6> @djinn ((b, d) -> (c, d)) -> b -> c
22:52:53 <lambdabot> -- f cannot be realized.
22:52:57 <Eridius> hah
22:53:07 <FunctorSalad> I guess the infinite loop is broken by something like arrowZero at some point
22:53:29 <pumpkin> you can't realize fix either
22:53:34 <pumpkin> it's not total
22:53:50 <pumpkin> anyway, I'll be back in a few
22:54:54 <erikc> it takes an arrow with input (b,d) and output (c,d) and wires the d's together to produce an arrow with input b and output c
22:54:55 <cads> @djinn ((b, d) -> (c, d)) -> b -> d -> c
22:54:55 <lambdabot> f a b c =
22:54:56 <lambdabot>     case a (b, c) of
22:54:56 <lambdabot>     (d, _) -> d
22:55:06 <erikc> the d becomes a feedback
22:55:06 <benl23> @type id
22:55:07 <lambdabot> forall a. a -> a
22:55:35 <wli> I'mm getting nowhere. :(
22:55:50 <FunctorSalad> erikc: yeah, but the termination condition isn't apparent (I realize it can be hidden in the arrow somehow)
22:56:00 <FunctorSalad> (->) isn't ArrowLoop, is it?
22:56:01 <Axman6> @djinn a -> b -> Maybe c
22:56:01 <lambdabot> f _ _ = Nothing
22:56:01 <benl23> @type let { x1 = \y -> \z -> z y y; x2 = \y -> x1 (x1 y) } in x2 (\z -> z)
22:56:02 <lambdabot> forall t t1 t2. ((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2
22:56:22 <benl23> @type let { x1 = \y -> \z -> z y y; x2 = \y -> x1 (x1 y); x3 =  \y -> x2 (x2 y) } in x3 (\z -> z)
22:56:23 <lambdabot> forall t t1 t2 t3 t4. ((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1)
22:56:23 <lambdabot>  -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) ->
22:56:23 <lambdabot> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4
22:56:31 <Axman6> argh!
22:56:36 <ivanm> @slap benl23
22:56:36 * lambdabot beats up benl23
22:56:42 <Axman6> is this what the SPARC does you you? :O
22:56:44 <ivanm> benl23: use /msg lambdabot
22:56:49 <ivanm> please!
22:56:50 <ivanm> ;-)
22:56:57 * Axman6 can beat that though
22:57:05 <benl23> just one more!
22:57:23 <benl23> @type let { x1 = \y -> \z -> z y y; x2 = \y -> x1 (x1 y); x3 =  \y -> x2 (x2 y);  x4 = \y -> x3 (x3 y) } in x4 (\z -> z)
22:57:24 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8. ((((((((((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (
22:57:24 <lambdabot> t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -
22:57:24 <lambdabot> > t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t ->
22:57:24 <lambdabot> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t)
22:57:26 <lambdabot> -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5) -> t5) -> (((((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) ->
22:57:30 <lambdabot> [32 @more lines]
22:57:33 <benl23> doh!
22:57:35 <Axman6> @more
22:57:35 <lambdabot> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t
22:57:35 <lambdabot> -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> (((((((((t -> t) -> (t -> t) -> t1) ->
22:57:37 <lambdabot>  t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> (((((((t -> t) -> (t -> t)
22:57:37 * Axman6 ducks
22:57:40 <lambdabot> -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> t3) -> t3) -> t4) -> t4) -> t5)
22:57:43 <lambdabot> -> t5) -> t6) -> t6) -> (((((((((((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1) -> t1) -> t2) -> t2) -> (((((t -> t) -> (t -> t) -> t1) -> t1) -> (((t -> t) -> (t -> t) -> t1)
22:57:46 <lambdabot> [27 @more lines]
22:57:52 <Axman6> damn... i'm impressed
22:57:56 <benl23> hmm, I guess someone thought of that before
22:57:56 <Axman6> i think that may beat mine
22:58:14 <Axman6> :t \q w e r t y u i o p -> t y p e w r i t e r
22:58:15 <lambdabot>     Occurs check: cannot construct the infinite type:
22:58:15 <lambdabot>       t = t5 -> t7 -> t3 -> t2 -> t4 -> t6 -> t -> t3 -> t4 -> t1
22:58:15 <lambdabot>     Probable cause: `t' is applied to too many arguments
22:58:31 <Axman6> eh? it's always worked before o.O
22:59:03 <Axman6> :t \q w e r t y u i o p -> t y p e w r i t e r q
22:59:04 <lambdabot>     Occurs check: cannot construct the infinite type:
22:59:04 <lambdabot>       t = t6 -> t8 -> t4 -> t3 -> t5 -> t7 -> t -> t4 -> t5 -> t2 -> t1
22:59:04 <lambdabot>     Probable cause: `t' is applied to too many arguments
22:59:26 <Axman6> :t \q w e r t y u i o p -> t y p e w r i q e r  -- >_>
22:59:27 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9. t -> t1 -> t2 -> t3 -> (t4 -> t8 -> t2 -> t1 -> t3 -> t6 -> t -> t2 -> t3 -> t9) -> t4 -> t5 -> t6 -> t7 -> t8 -> t9
22:59:31 <Axman6> lameness
22:59:32 <ivanm> Axman6: the "t" function is taking in itself
22:59:36 <Axman6> yeah
22:59:37 <ivanm> so how do you specify it?
22:59:48 <Axman6> i dunno, but it's always worked before
23:00:17 <Axman6> @djinn b -> c -> (a -> a)
23:00:17 <lambdabot> f _ _ a = a
23:00:33 <wli> Maybe chapter 12 of the slpj book might help.
23:00:59 <Axman6> i'm upset, that thing used to work just fine :(
23:01:46 <pumpkin_> woot
23:03:24 <pumpkin_> Axman6: what' wrong? @pl is where that beast explodes
23:03:38 <Axman6> bleh, so it is!
23:03:53 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
23:03:56 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
23:03:56 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
23:03:56 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
23:03:56 <lambdabot> optimization suspended, use @pl-resume to continue.
23:04:07 <Axman6> ha ha! thankyou pumpkin_
23:04:12 <Axman6> i owe you a beer now :P
23:04:39 <ivanm> @pl-resume
23:04:45 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .) . (((((flip .
23:04:45 <lambdabot> ) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (
23:04:45 <lambdabot> flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
23:04:45 <lambdabot> optimization suspended, use @pl-resume to continue.
23:04:59 <ivanm> doesn't look much different... >_>
23:05:10 <Axman6> @pl-resume
23:05:21 <Axman6> oi!
23:05:22 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . join . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip
23:05:22 <lambdabot> flip id . ((flip . ((ap . ((flip . ((flip . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .))))
23:05:22 <lambdabot> optimization suspended, use @pl-resume to continue.
23:06:02 <Axman6> @. type pl \q w e r t y u i o p -> t y p e w r i t e r
23:06:07 <lambdabot>     Occurs check: cannot construct the infinite type:
23:06:07 <lambdabot>       b = a1 -> a -> b4 -> b3 -> b2 -> b1 -> b -> c
23:06:07 <lambdabot>     Probable cause: `.' is applied to too few arguments
23:07:00 <lament> this clearly proves that dvorak is superior
23:07:14 <Axman6> indeed
23:07:45 <pumpkin_> Axman6: no problem :P
23:07:55 <pumpkin_> glad to have given you some spammo
23:08:10 <Axman6> benl23: how'd you come up with that one anyway?
23:08:45 <benl23> Axman6: it's in a paper, I'll find it wait.
23:08:55 <Axman6> ah, ok :)
23:09:19 <wli> mmorrow: I think the 1987 slpj book is doing more for me than the lazy vm spec.
23:09:26 <benl23> Axman6: "Deciding ML typability is complete for deterministic exponential time" --	H. Marison, 1990
23:09:42 <wli> mmorrow: Or the STG paper.
23:11:26 <pumpkin_> what does STG stand for again?
23:11:28 <pumpkin_> @where STG
23:11:28 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
23:11:35 <pumpkin_> :(
23:11:55 <benl23> Axman6: s/Marison/Mairson
23:12:03 <Axman6> benl23: heh, running that in ghci formats it very nicely
23:12:14 <wli> Spineless Tagless G-machine
23:12:29 <wli> The newer STG variants have both spines and tags.
23:12:31 <benl23> Axman6: you can keep extending it, add a x5 binding the same way
23:12:34 <pumpkin_> ah
23:12:42 <pumpkin_> not the world's most accessible title
23:13:34 <Axman6> comes out at 1023 lines in ghci
23:17:55 <wli> I think I need to be able to do graph reduction by hand / on paper to get an idea of what to do.
23:19:29 <wli> I don't think I can unwind the spine by hand etc.
23:20:26 <mmorrow> wli: yeah, that's a good one
23:20:31 <mmorrow> (the spj book)
23:21:01 * ivanm gives wli some gloves to help him unwind bloody spines
23:21:06 <ivanm> oh, wait, did you mean the spine of a list? :o
23:21:07 <ivanm> ;-)
23:21:16 <mmorrow> there's this newer pdf (book too maybe) that has similar content that i recently found from somewhere that has some good stuff too
23:21:21 <mmorrow> lemme find the link
23:21:50 <mmorrow> wli: yeah, doing it in paper is essential i think
23:23:08 <pumpkin_> even more essential
23:23:19 <pumpkin_> is cheez-its with crunchy peanut butter
23:24:02 * pastah has fallen in love with the dynamic duo: lookup/catMaybe
23:24:06 <pastah> *catMaybes*
23:24:33 <wli> catMaybes $ map (flip Map.lookup m) ks yeah
23:25:21 <pastah> b <- catMaybes [lookup a xs]
23:25:51 <pastah> no more case mbVal of Nothing -> ...
23:27:02 <mmorrow> i can't find that link, so i put it here: http://moonpatio.com/repos/implem_functlang.pdf
23:27:32 <wli> mmorrow: What is it?
23:27:37 <mmorrow> pumpkin_: crunchy peanut butter has its moments, but creamy takes the cake in my book
23:27:45 <Gracenotes> hm, deriving with parametric datatypes seems interesting :) Whether it's an instance of the derived typeclass depends on the parametric variables used.
23:27:45 <wli> Is it the 1987 SLPJ book?
23:27:53 <Gracenotes> I'm glad GHC is smart like that...
23:27:54 <mmorrow> wli: it's a mini-book by spj+another author
23:28:00 <mmorrow> wli: this one's from 2000
23:28:08 <wli> PJ Lester
23:28:33 <wli> It's a vague update/reorg of the same material, but is missing a lot of material relative to the 1987 one.
23:28:33 <mmorrow> David R Lester == PJ ?
23:28:37 <pumpkin_> mmorrow: WE MUST FIGHT TO THE DEATH
23:28:51 <Gracenotes> interestingly, if the parametric types are not implied by an expression using a derived typeclass, it'll success
23:28:52 <wli> Never mind, PJ is Peyton Jones
23:28:53 <Gracenotes> *succeed
23:29:08 <mmorrow> wli: i think though there's some stuff that didn't exist in 87
23:29:20 <wli> Also true.
23:29:23 <mmorrow> pumpkin_: dueling? what weapons?
23:29:39 <pumpkin_> mmorrow: definitely nothing related to this channel cause I'd clearly lose
23:29:44 <mmorrow> pumpkin_: actually, i have to pass out. manana
23:29:52 <pumpkin_> oh, boo
23:30:06 <mmorrow> pumpkin_: i was thinking whatever the pistol form of a musket is
23:30:18 <mmorrow> (what are those called again..?)
23:30:42 <pumpkin_> not sure, not an expert on old firearms :)
23:31:19 <mmorrow> pumpkin_: i wonder when the last official back-to-back duel was
23:31:31 <mmorrow> (probably last week...)
23:31:31 <pumpkin_> I dunno
23:31:33 <mmorrow> heh
23:31:37 <pumpkin_> isn't that how galois died?
23:31:43 <mmorrow> i think so
23:32:32 <mmorrow> garh, now i want to remember what those guns are called
23:32:38 <mmorrow> it's totally a common word
23:32:56 * mmorrow passes out
23:33:21 <pumpkin_> pistol?
23:33:29 <mmorrow> oh, yeah
23:33:31 <mmorrow> heh
23:33:39 <mmorrow> they're totally just called pistols
23:34:43 <wli> I think the template instantiation machine could be accessible.
23:34:59 <wli> The 2000 PJ/Lester book seems to be doing even better than the 1987 one.
23:42:30 <wli> I wonder if you could ditch the G-machine's stack in favor of SPARC-like register windowing.
23:44:28 <wli> I think I hit pay dirt with the 2000 PJ/Lester book.
23:47:25 <Axman6> p_l: i was checking out that SiCortex stuff, and it seems really cool!
23:47:59 <pastah> anyone here know STM?
23:48:09 <Axman6> a little?
23:48:15 <pastah> what does "retry" mean?
23:48:30 <Axman6> it tries to run the action again if it failed
23:48:54 <pastah> but you have to explicitly say "when epicFail retry"+
23:48:56 <pastah> +
23:48:58 <pastah> ?
23:49:31 <ivanm> I don't think so...
23:49:42 <ivanm> @hoogle retry
23:49:43 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry :: Num a => String -> IO a -> IO a
23:49:43 <lambdabot> Foreign.C.Error throwErrnoIfMinus1Retry_ :: Num a => String -> IO a -> IO ()
23:49:43 <lambdabot> Foreign.C.Error throwErrnoIfMinus1RetryMayBlock :: Num a => String -> IO a -> IO b -> IO a
23:49:55 <ivanm> @more
23:49:59 <Axman6> :t Control.Concurrent.STM.retry
23:50:00 <lambdabot> forall a. GHC.Conc.STM a
23:50:05 <ivanm> OK, @more doens't work with @hoogle
23:50:09 <pastah> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#t%3ASTM
23:50:11 <ivanm> pastah: it's just retry foo
23:50:12 <pumpkin_>  @hoogle+
23:50:21 <ivanm> pumpkin_: hmmm?
23:50:25 <Axman6> @hoogle+
23:50:25 <lambdabot> Foreign.C.Error throwErrnoIfMinus1RetryMayBlock_ :: Num a => String -> IO a -> IO b -> IO ()
23:50:26 <lambdabot> Foreign.C.Error throwErrnoIfNullRetry :: String -> IO (Ptr a) -> IO (Ptr a)
23:50:26 <lambdabot> Foreign.C.Error throwErrnoIfNullRetryMayBlock :: String -> IO (Ptr a) -> IO b -> IO (Ptr a)
23:50:28 <Axman6> @hoogle+
23:50:29 <lambdabot> Foreign.C.Error throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
23:50:29 <lambdabot> Foreign.C.Error throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
23:50:29 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: a -> Bool -> String -> IO a -> IO b -> IO a
23:50:36 <ivanm> ahhh
23:50:38 <Axman6> lame foriegn stuff -_-
23:50:45 <ivanm> @slap Foreign
23:50:45 <lambdabot> Come on, let's all slap Foreign
23:51:40 <pastah> how nasty is it to put forkIO inside unsafePerformIO?
23:51:55 <ivanm> pastah: I'd say very
23:52:18 <ivanm> you should never use unsafePerformIO unless you know that the IO is actually a pure function with _no_ side effects
23:52:24 <Axman6> well, maybe not that nasty, but you'kk just get back a ThreadID
23:52:26 <ivanm> forkIO _does_ have a side effect
23:52:36 <ivanm> Axman6: and a thread floating around doing stuff
23:52:50 <ivanm> Axman6: its the referential transparency that could cause problems
23:53:02 <pumpkin_> pastah: why would you do that, anyway?
23:53:06 <wli> The TIM (Template Instantiation Machine) doesn't even seem to have instructions; it just builds an initial heap and graph reduces.
23:53:06 <pastah> yeah... well, maybe i'll do my forking within som MonadT IO then
23:53:09 <ivanm> e.g. const 2 (unsafePerformIO $ forkIO blah) will never create the fork
23:53:13 <Axman6> yeah, it's a very bad idea basically :P
23:53:30 <pastah> pumpkin_: dunno... just looking at hoogle and looking at the type signatures and reading
23:53:33 <ivanm> pastah: there's a reason the prefix of unsafePerformIO is _unsafe_
23:53:40 <pastah> i have tried to do any paralell computing at all
23:53:49 <ivanm> pastah: STM isn't parallel computing
23:53:49 <pastah> or ever used MVar or STM before
23:53:52 <ivanm> it's concurrency
23:53:55 <ivanm> there's a difference ;-)
23:53:58 <pastah> just trying to learn :)
23:53:59 <pastah> ok?
23:54:01 <ivanm> pastah: read the RWH chapter on STM
23:54:02 <ivanm> heh
23:54:24 * ivanm considers pastah's request to be allowed to learn...
23:54:37 <pastah> i don't have it yet
23:54:45 <ivanm> pastah: read it online then ;-)
23:54:56 <pastah> i'll probably buy some books later, in a few weeks
23:55:21 <pastah> i'm thikning of getting RWH, the erlang book, the wizard book and tcp/ip illustrated
23:55:37 <pastah> to stock up before the summer comes :D
23:56:01 <Gracenotes> :o
23:56:38 <ivanm> pastah: which erlang book?
23:56:46 <pastah> the non-orielly one
23:56:50 * ivanm still can't see why SICP is referred to as the "wizard book"
23:57:00 <pastah> with the image of a street on the cover
23:57:02 <ivanm> first of all, "SICP" is shorter than "the wizard book" ;-)
23:57:08 <ivanm> pastah: the white one?
23:57:11 <pumpkin_> he looks a bit like a wizard
23:57:14 <pumpkin_> the dude on the cover
23:57:15 * ivanm vaguely recalls starting to read that one
23:57:15 <pastah> yeah, white/brown
23:57:20 <ivanm> pumpkin_: _very_ vaguely
23:57:24 <pastah> pumpkin_: he IS a wizard
23:57:26 <pastah> DAMMIT
23:57:31 <ivanm> I'd say more a magi or something
23:57:32 <Axman6> pastah: the joe armstrong one?
23:57:35 <wli> It was purple and some other color when I got it.
23:57:37 <pastah> yeah
23:57:46 <pastah> http://icampus.mit.edu/xTutor/public/images/content/5/sicp-cover.jpg
23:57:46 <ivanm> wli: the colours are referring to the erlang book ;-)
23:57:51 <pastah> wizard!
23:57:54 <pumpkin_> ", it is also known as the Wizard Book (there is a wizard on the cover), and less commonly, the Purple Book."
23:57:58 <pumpkin_> from wikipedia
23:57:58 <ivanm> magi/wise man!
23:58:02 <pumpkin_> reductio ad wikipedium
23:58:22 <ivanm> pumpkin_: just because there's a lot of stupid people in the world that insist on giving irrelevant names to things...
23:58:23 <ivanm> ;-)
23:58:27 <pumpkin_> :P
23:58:31 * ivanm still calls SICP "SICP"
23:58:35 <pumpkin_> I do call it SICP too
23:58:38 <ivanm> as in sic-P
23:58:42 <Gracenotes> sick-puh
23:58:47 <pastah> wli: brown-ish: http://www.lsl.com.au/images/images-ref/programming-erlang.jpg
23:58:48 <Gracenotes> sick puppy :(
23:58:52 <pumpkin_> aw
23:58:52 * Axman6 calls it SICP because he can never remember what SICP stands for
23:59:04 <ivanm> Structure and Interpretation of Computer Programs, IIRC
23:59:08 <pumpkin_> hup
23:59:09 <pumpkin_> yup
23:59:11 <pastah> yup
23:59:14 <Gracenotes> yup
23:59:15 <Axman6> pastah: anyway, haskell's parallelism and concurrency stuff is awesomeness
23:59:33 <pastah> Axman6: yeah, the libraries seems really clean
23:59:39 <ivanm> Axman6: we just need the parallel stuff polished up a bit more from the looks of things
23:59:45 <Axman6> yeah
