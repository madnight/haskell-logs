00:01:37 <wli> e.g. (x + (x^2-1)^(1/2))^(1/2) = 2^(-1/2)*((x-1)^(1/2)+(x+1)^(1/2))
00:07:54 <wli> That may not be equivalent, so maybe the case for number fields where factorizations of the radicand yield roots doesn't help.
00:14:58 <wli> There is still stuff like (3*3^(2/3)+3^(1/3)-5)^(1/2) = 3^(2/3)-3^(1/3)+1 and I guess ((x^2+9)*(x^2+1)^(1/3)-4*x^2)^(1/2) = (x^2+1)^(2/3)-2*(x^2+1)^(1/3)-2
00:15:05 <amz> I have just finished my first real program in Haskell :D
00:15:08 <amz> console blackjack game
00:16:33 <wli> I wonder if the linear dependencies shake out if you raise such things to powers.
00:35:40 <FunctorSalad_> writing a domain specific mini-language with a Monad GADT is incredibly neat :)
00:36:25 <FunctorSalad_> the do blocks in that language almost look like they could be written by the end user
00:37:07 <FunctorSalad_> there would be security issues though (unsafePerformIO)
00:37:17 <FunctorSalad_> I wonder if mueval could be used
00:41:19 <quicksilver> unsafePerformIO type security problems are not too hard to solve
00:41:29 <quicksilver> you can just restrict imports/identifiers in scope.
00:41:47 <wli> What are the trickier ones, then?
00:43:53 <FunctorSalad_> hmm ISTR there was some issue
00:44:46 <FunctorSalad_> (someone changing one of the imports to re-export unsafe?)
00:45:08 <FunctorSalad_> but I don't see how a malicious user-generated-content-supplier could do that
00:53:35 <h0tzenpl0tz> o
00:54:39 <dibblego> @type cobind
00:54:40 <lambdabot> Not in scope: `cobind'
00:56:35 <Gracenotes> o:
00:57:03 <Gracenotes> > iterate (++":") "o"
00:57:05 <lambdabot>   ["o","o:","o::","o:::","o::::","o:::::","o::::::","o:::::::","o::::::::","o...
00:58:17 <Gracenotes> hm. I think a non-terminating variable of unfoldr might be useful
00:58:39 <Gracenotes> oh, wait... that's iterate! duh
00:58:45 <Gracenotes> *headdesk*
00:58:57 <Gracenotes> s/variable/version/
01:05:22 <ski> (dibblego : looking for comonads ?)
01:05:43 <dibblego> ski, got it, thanks
01:06:00 * ski looks confused
01:06:03 <ski> got what ?
01:06:06 <Gracenotes> pat pat
01:06:19 <dibblego> ski, what I was looking for :)
01:06:27 <ski> .. which was ?
01:06:35 <dibblego> the signature for cobind
01:06:47 <ski> (Gracenotes : btw, would you happen to know the name of the CT book by Awoday mentioned before ?)
01:06:57 <ski> ok
01:08:31 <Gracenotes> ski: I can't say I know the name, just that he wrote it and that it's a good resource :)
01:09:00 <Gracenotes> the front page of the PDF just says "Category Theory"
01:09:08 <Gracenotes> from Oxford press, and it looks like it's in a series
01:10:13 <ski> oh, it's available on the web somewhere ?
01:12:10 <ski> (.. ah, searching in the general library, as opposed to the mathematics department library, managed to turn it up .. hm "[electronic resource]" ..)
01:18:12 <b\6> i have an import cycle like a -> b -> c -> a. how do i do hs-boot stuff to fix?
02:03:35 <wli> So far so good. I raised (x^2+9)*(x^2+1)^(1/3)-4*x^2 to powers and discovered it was the root of a quadratic.
02:03:43 <CakeProphet> so if you use accept what will return if there's no clients connecting?
02:03:56 <CakeProphet> (accept from import Network)
02:05:55 <wli> Ugh, no, it was a cubic. :(
02:12:20 <CakeProphet> hmmm.. it looks like accept hangs up if there's nothing to accept... how do you make it not do that?
02:18:11 <ziman> CakeProphet, IIRC, you can use select() on server socket handles, too
02:18:45 <CakeProphet> ah okay
02:18:54 <ziman> i don't know how select() is supported in haskell though
02:20:22 <sjanssen> CakeProphet: are you using -threaded?
02:20:33 <CakeProphet> ...I'm not sure, so probably not.
02:21:05 <sjanssen> no, probably not :)
02:21:25 <CakeProphet> how will -threaded help and how do I add it.
02:21:46 <sjanssen> -threaded will allow a blocking foreign call to run simultaneously with other Haskell threads
02:22:08 <sjanssen> this is the problem you're seeing, right?  A thread running accept keeps your other threads from running?
02:22:38 <CakeProphet> ...well... my haskell program doesn't have any threads at all. but yes, accept does hang up when there's nothing to accept
02:22:42 <CakeProphet> which is not what I want.
02:23:15 <sjanssen> oh
02:23:35 <Baughn> ziman: You can use select on all FDs, period. Except /proc handles in linux, for which you can't. It rather sucks.
02:23:53 <CakeProphet> I suppose I could make a thread for accept?
02:23:56 <Baughn> ..which means you Do Not open files in /proc/ in haskell
02:24:00 <CakeProphet> and turn on -threaded?
02:24:15 <Baughn> CakeProphet: You only need -threaded to use >1 cpu core
02:24:31 <sjanssen> CakeProphet: yes, using multiple threads is the usual solution in Haskell
02:24:34 <sjanssen> Baughn: no, that isn't true
02:24:40 <CakeProphet> my computer only has one... but I guess I might run it on a different machine one day
02:24:58 <Baughn> sjanssen: Well, or to use bound threads, I suppose..
02:24:58 <sjanssen> Baughn: there are major differences with blocking foreign calls
02:25:02 <CakeProphet> how do you add -threaded in the source?
02:25:22 <sjanssen> CakeProphet: you can't put it in the source file, it must be provided on the command line
02:25:30 <sjanssen> ghc --make foo -threaded
02:25:37 <Baughn> CakeProphet: You can put it in ghc-options in a .cabal file, though
02:26:22 <CakeProphet> hmmm... this means I'll need to learn threading
02:26:26 <CakeProphet> in Haskell
02:26:31 <Baughn> It's easy. ;)
02:26:45 <CakeProphet> what's a solid way to maintain a global state in a Haskell program?
02:26:51 <CakeProphet> that's not too messy
02:26:58 <opqdonut> answer: it depends :)
02:27:02 <sjanssen> CakeProphet: on further investigation, -threaded might not be absolutely required with network/accept
02:27:16 <sjanssen> CakeProphet: but you probably want to use it anyway
02:27:20 <opqdonut> the state monad is of course the usual answer
02:27:26 <sjanssen> CakeProphet: the answer is "don't"
02:27:32 <CakeProphet> I'm not right now
02:27:39 <CakeProphet> but I see it becoming messy if I don't streamline it somehow
02:27:48 <Baughn> Then there's STM, MVars, channels, explicit state-passing, unsafePerformIO'd global MVars, and of course the standard "don't do it".
02:29:16 <Baughn> "robot = forkIO $ forever serve" <-- No pun intended.
02:29:54 <CakeProphet> I can't deny that my whole program is basically a server-side loop that polls input to manipulate a pool of state. If I don't use something like that then I'd have to do something like make a data structure containing everything and pass it around as a function argument.
02:30:10 <CakeProphet> Baughn:  what module is that in?
02:30:20 <Baughn> CakeProphet: Network.Hermes.TCP. :P
02:30:46 <CakeProphet> ...cabal?
02:30:54 <Baughn> Not uploaded yet
02:31:10 <Baughn> CakeProphet: I'd suggest looking into STM, by the way
02:31:36 <CakeProphet> I have... but I wasn't planning on using concurrency
02:31:55 <Baughn> CakeProphet: As for -threaded, to be entirely complete - it's required to have multiple cores running haskell threads /simultaneously/ (eg. -N2 or above), to use the parallel GC in 6.10, to avoid blocking the entire runtime on blocking foreign calls, to get deadlock detection, and probably a couple I forgot
02:32:03 <Baughn> STM isn't just for concurrency
02:32:19 <sjanssen> Baughn: deadlock detection works without -threaded
02:32:45 <Baughn> Aagh. Hm, but I actually read the RTS code for that, a while back..
02:33:11 <sjanssen> at least blocked indefinitely on MVar is detected
02:33:13 * Baughn shrugs. Whatever. Just use -threaded; it rarely hurts.
02:33:37 <Baughn> (Though it may be marginally slower on single-core machines, on some loads)
02:35:24 <quicksilver> really quite significantly slower, on certain pathological cases :)
02:35:37 <Baughn> Which don't occur in real life. ^^;
02:38:30 <CakeProphet> so Haskell has no select?
02:38:44 <CakeProphet> or anything that I can use that isn't a thread and some sort of read/write var
02:38:46 <Baughn> Ah.. hang on, I think I saw one somewhere
02:39:02 <sjanssen> CakeProphet: Haskell's threads are an interface to select
02:39:08 <Baughn> GHC might have one. But I can say pretty confidently that Haskell doesn't.
02:39:31 <quicksilver> CakeProphet: threads are simpler than select.
02:39:41 <quicksilver> CakeProphet: therefore GHC provides threads as an interface to select.
02:39:53 <Baughn> ..I'd prefer to have both
02:40:09 <quicksilver> then go seek in the posix module.
02:40:43 <Baughn> Right. To rephrase, I'd prefer to have a select-like function that operates on Handles, and hands off the actual processing to the I/O core. ^^;
02:41:11 <quicksilver> Why? What about the threaded IO interface do you dislike?
02:41:14 <Baughn> CakeProphet: I can't find one, by the way. Just things like "wait until this Handle is read/writable"
02:41:37 <Saizan> a library of server "templates"/"widgets" would help a lot in this area, i think
02:41:39 <quicksilver> it's trivial to build that kind of thing over the threaded interface.
02:42:02 <Baughn> There is that
02:42:19 <Baughn> ..I suppose I should just get writing.
02:43:52 <quicksilver> not trying to suggest I'm actually opposed to a more sophisticated interface to blocking/nonblocking IO, by the way.
02:43:57 <quicksilver> I'm just curious what your justification is ;)
02:44:17 <Baughn> Which would you prefer: "foo :: Hostname -> Portnumber -> (Int,Int) -> IO Conn", or "foo :: Hostname -> PortNumber -> Int -> Int -> IO Conn"?
02:44:19 <quicksilver> because for ever task I've undertaken, the GHC lightweight threads have been simpler than using select directly woudl have been.
02:44:39 <Baughn> The ints being two related timeout values
02:44:55 <sjanssen> quicksilver: I suppose there might be cases where even GHC's lightweight threads are too heavy
02:45:08 <Baughn> quicksilver: Okay. Other than the "You can build it yourself" bit, the /reason/ I'd want to do so..
02:45:53 <wli> Hmm, if I use Grobner I get more interesting results, like squaring some random stuff yields a fully inter-reduced set of only 2 polynomials.
02:45:56 <Baughn> quicksilver: I'm writing what amounts to a reactor; every thread has shared state with every other thread, and basically no local state. It'd be simpler to just have /one/ thread, and deal with the events directly.
02:46:29 <quicksilver> Baughn: in such cases I write little threads which push everything back ot the main thread in a (Chan Event)
02:46:43 <quicksilver> where 'Event' is some user-defined type encompassing all possible events
02:46:59 <quicksilver> (new connection accepted, data recived, conncetion closed, IO exception on connection, etc)
02:46:59 <Baughn> quicksilver: Which is what I'm doing, but it's still more work than a select-based thingy would be
02:47:18 <quicksilver> I don't think I agree :
02:47:19 <quicksilver> :O
02:47:21 <quicksilver> :)
02:47:35 <quicksilver> the main reason to move to a more sophisiticated model is to get away from select's own limitations.
02:47:48 <quicksilver> e.g. select() doesn't do async disk IO (only network IO is async in the simple posix model)
02:47:54 <Baughn> Well, I'm not saying threads aren't usually nice. :P
02:47:59 <quicksilver> select doesn't scale well to large numbers of fds
02:48:05 <quicksilver> etc.
02:48:16 <Baughn> I don't mean literally calling select(), either. Just a haskell equivalent, that avoids those problems.
02:48:17 <wli> epoll?
02:48:23 <Baughn> wli: Still no async disk IO
02:48:33 <wli> It's all doorstoppish, yes.
02:49:16 <CakeProphet> so... when will my program terminate now that I've used forkIO
02:49:32 <CakeProphet> will it terminate when the top-level thread terminates... or does it wait for all of the threads to terminate.
02:49:32 <quicksilver> CakeProphet: when the main thread terminates
02:49:36 <CakeProphet> alright.
02:49:57 <quicksilver> (except when you're running from ghci; I consider this a serious bug in ghci)
02:50:41 <CakeProphet> hmmm... I'm thinking about how I want my program to terminate.
02:51:43 <CakeProphet> the way it should end is by receiving the command "shutdown" from someone with privledge... so should I use an exception to propagate that up the call stack?
02:51:48 <porges> is seq in GHC defined in terms of a primitive seq#? I can't seem to find it :P
02:52:06 <CakeProphet> ...I ask because I've never used Exceptions... so I'd need help learning them
02:52:24 <quicksilver> CakeProphet: I'd just write a value to a "done" MVar
02:52:38 <quicksilver> CakeProphet: and have your main thread quit when that MVar is full.
02:52:50 <quicksilver> you certainly could throw an excpetion to the main thread instead.
02:53:24 <CakeProphet> hmmm... I like the MVar.
02:53:34 <CakeProphet> :t until
02:53:35 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
02:54:39 <CakeProphet> what's the name of the function that loops a do block until a condition is reached?
02:54:48 <CakeProphet> ...until?
02:55:01 <CakeProphet> @src until
02:55:01 <lambdabot> until p f x | p x       = x
02:55:01 <lambdabot>             | otherwise = until p f (f x)
02:55:12 <Baughn> quicksilver: Also. I'm implementing (at the moment) erlang-style message-passing, cross-machine. If you'll check me on this..
02:55:51 <quicksilver> CakeProphet: funnily enough there isn't one.
02:55:58 <quicksilver> CakeProphet: you might sensibly call it 'untilM'
02:56:05 <trygvis> Baughn: O.o .. is the code available?
02:56:10 <Baughn> trygvis: It will be
02:56:14 <CakeProphet> ...that's odd that it wouldn't exist.
02:56:20 <quicksilver> CakeProphet: it is rather, yes.
02:56:24 <trygvis> Baughn: shibby .. let me know when it is
02:56:46 <wli> Wouldn't untilM be something like untilM p f x | p x = x | otherwise = untilM p f =<< f x ?
02:56:54 <wli> ergh
02:57:07 <wli> untilM p f x | p x = return x | otherwise = untilM p f =<< f x ?
02:57:14 <sjanssen> wli: you'd probably want the predicate to be monadic also
02:57:31 <CakeProphet> quicksilver:  is this right?  untilM :: (a -> Bool) -> m a -> m a
02:57:41 <Baughn> quicksilver: Right now, I'm using a Printf-style class to construct function proxies (okay, so not quite erlang there), with typeOf on the return value of the terminating instance to get the function type. I then compare that to the type reported for the remote function, and produce a type-error when the function proxy is created if they don't match.
02:57:47 <quicksilver> CakeProphet: that's one choice.
02:57:55 <Baughn> quicksilver: Does that sound about right, or is there a better way?
02:58:00 <quicksilver> CakeProphet: another choice is m Bool -> m a -> m a
02:58:09 <wli> sjanssen: No problem. untilM p f x = do { b <- p x ; if b then return x else untilM p f =<< f x
02:58:15 <quicksilver> CakeProphet: the validity of these two choices might be one reason it isn't standard.
02:58:30 <CakeProphet> quicksilver:  hmmm... ah... you'd use bind on the predicate monad
02:58:36 <quicksilver> Baughn: it certainly sounds like a good direction.
02:58:38 <CakeProphet> instead of it being a regular predicate function
02:58:59 <quicksilver> (m Bool) says it just accesses the monadic stuff to decide if its time to finish
02:59:09 <quicksilver> (a -> Bool) says it accesses the value from the loop to decide if its time to finish
02:59:15 <quicksilver> (a -> m Bool) allows both :)
02:59:29 <CakeProphet> quicksilver:  hmmm... is (a -> Bool) a "m Bool"?
02:59:42 <Baughn> trygvis: Message passing, RPC, adjustable rate-limited streaming and a nameserver as a bonus. I'll make sure to notify you. ;)
03:00:07 <trygvis> yay
03:00:14 <quicksilver> CakeProphet: yes, for "Reader" monad.
03:00:26 <quicksilver> CakeProphet: "Reader a Bool" also known as (a -> Bool)
03:00:44 <quicksilver> so in fact, (a -> m Bool) is just 'n Bool'
03:00:52 <quicksilver> where 'n' is the monad "ReaderT m"
03:00:56 <quicksilver> where 'n' is the monad "ReaderT a m", rather
03:02:17 <yitz> @pl \p f -> head . dropWhile (not . p) . iterate f
03:02:18 <lambdabot> ((head .) .) . (. iterate) . (.) . dropWhile . (not .)
03:06:28 <Baughn> Funny thing.. I didn't realize ghci has history, because so far I've always had to SIGKILL it instead of quitting normally. -_-;
03:07:41 <Gracenotes> @pl \f p -> head . dropWhile (not . p) . iterate f
03:07:41 <lambdabot> ((head .) .) . flip ((.) . dropWhile . (not .)) . iterate
03:07:45 <Gracenotes> :o
03:11:23 <osfameron> @pl in "makes things harder to read" shocker?
03:11:23 <lambdabot> (line 1, column 1):
03:11:23 <lambdabot> unexpected reserved word "in"
03:11:23 <lambdabot> expecting white space, "()", natural, letter or digit, lambda abstraction or expression
03:11:34 <CakeProphet> hmmm... how do I create my own exception?
03:12:25 <Gracenotes> depends on your GHC version.
03:13:14 <CakeProphet> 6.6
03:13:42 <Gracenotes> 7.7
03:14:20 <Gracenotes> other than that, dunno. With 6.10 it seems you can make your own typeclass for an Exception. before, not sure.
03:14:33 <Gracenotes> well, typeclass instance
03:14:40 <CakeProphet> oh... this is 6.10
03:15:08 <CakeProphet> I don't understand toException and fromException... and they don't appear to be documented
03:15:37 * wli attempts to smoke out perfect powers in Q(x,y)/(y^n-p(x))
03:16:56 <quicksilver> CakeProphet: there is a paper you have to read to understand it properly (unfortunately)
03:17:06 <Gracenotes> SomeException is, as far as I can tell, a nasty compatibility hack
03:17:12 <quicksilver> I haven't taken the time to grok it properly myself.
03:17:28 <CakeProphet> rofl. everything in Haskell comes with a Ph.D thesis.
03:18:26 <RayNbow> awesome, the Narwhal logo's back on the Haskell reddit :)
03:18:58 <Gracenotes> welcome to Haskell, you will find your own private roflcoptor encoded into the first even number that isn't a sum of two primes
03:19:14 <Gracenotes> >=4 :3
03:20:05 * wli tries to somehow methodically determine that (x^2+9)*y-4*x^2 is a perfect square in Q(x,y)/(y^3-x^2-1)
03:20:21 <BONUS> yeah Simon Marlow wrote a paper about extensible hierarchic exceptions in Haskell by overloading toException and fromException and using existentials
03:20:58 <BONUS> it's a pretty genius idea, although i wouldn't use it in practice, because throwing exceptions from a pure context = icky
03:21:51 <quicksilver> BONUS: throwing them from thread to thread isn't so icky though
03:21:58 <quicksilver> (in IO code)
03:21:58 <wli> I wish MonadError were pervasively used in the base as opposed to these exceptions from pure contexts.
03:22:05 <quicksilver> although it's still not something I find I need to do very often.
03:22:16 <quicksilver> wli: not gonna happen - they dont' want base to depend on mtl.
03:22:44 <quicksilver> best case is for base to use "Either SomeErrorType" or "Maybe"
03:22:52 <BONUS> yeah
03:22:52 <wli> Then I'll never get my wish.
03:22:53 <quicksilver> which are relatively easy to 'promote' into MonadError
03:22:59 <wli> (As usual.)
03:23:10 <Gracenotes> I don't see why not to include mtl in base
03:23:21 <quicksilver> Gracenotes: it uses non-standard extensions.
03:23:23 <Gracenotes> granted, other packages define the same monads
03:23:24 <quicksilver> is the key point.
03:23:45 <quicksilver> (something like) mtl might get included in base once we standardise an extension set which makes it possible.
03:24:00 <quicksilver> presumably MPTC + some version of type families.
03:24:05 <quicksilver> but that's some way off IMO.
03:24:18 <Gracenotes> > text . reverse . ('\'':) . reverse $ "Haskell"
03:24:19 <lambdabot>   Haskell'
03:24:28 <Gracenotes> ^plox? :)
03:26:09 <Saizan> exceptions being extensible or not is orthogonal to throwing them from pure code or not
03:26:38 <BONUS> i wish there was a MonadFail typeclass that provided failure (with an optional string) and then ErrorT could use that instead of assuming Either
03:27:09 <Peaker> Maybe we should call pure exceptions: untyped exceptions...
03:27:29 <Peaker> Either/Maybe/etc are really just putting a proper type on those exceptions
03:27:41 <Saizan> BONUS: MonadFail won't let you catch them, presumably
03:28:03 <BONUS> yeah, i was just kind of going off on a tangent :)
03:28:38 <BONUS> those two are orthogonal but i don't think exception hierarchies are very useful for I/O exceptions
03:29:07 <Peaker> Maybe untyped exceptions should be completely uncatchable so that if people do want to catch "divisions by zero" or what not, they have to properly type them into a Maybe or such :)
03:29:23 <Peaker> And everyone shall know that there's one less "error handling mechanism" in Haskell :)
03:29:37 <FunctorSalad_> can I cast to a polymorphic type?
03:29:55 <BONUS> i dont think so
03:30:17 <FunctorSalad_> it doesn't seem to work but somehow ext1Q manages to
03:30:24 <yitz> BONUS: ErrorT is one concrete instance of MonadError. You can define whatever you'd like.
03:31:11 <FunctorSalad_> (I want to write a function that takes a Data and goes "if this is a list of Datas, do this, otherwise do that")
03:32:25 <yitz> Peaker: there is no way you could use a language in industry that doesn't have some mechanism that is guaranteed to catch all exceptions. is this part of the "fail at all costs" strategy?
03:32:50 <Peaker> yitz: what can you do with pure exceptions that you've caught?
03:33:36 <yitz> Peaker: give the user some message and return to the enclosing environment.
03:34:11 <wli> There has to be a better way than Grobner on an n-th power with undermined coefficients, esp. since it doesn't work most of the time.
03:34:38 <yitz> wli: nth power what?
03:34:39 <Peaker> yitz: well, if they can be caught as opaque values that cannot really be used, that's probably discouraging enough
03:35:11 <FunctorSalad_> hmm ext1Q uses dataCast1 to do it
03:35:12 <yitz> Peaker: "Panic! The impossible has happened..."
03:35:47 <wli> yitz: To find n-th roots in algebraic function fields if/when they exist, e.g. ((x^2+9)*(x^2+1)^(1/3)-4*x^2)^(1/2) = (x^2+1)^(2/3)-2*(x^2+1)^(1/3)-2
03:36:00 <idnar> Peaker: there are basically two general use cases for exception handling
03:36:13 <Peaker> yitz: maybe pure exceptions shouldn't become IO exceptions if used as input to an IO action generation function
03:36:23 <idnar> Peaker: 1) there is a particular subset of exceptional failure conditions from which you can recover; so you catch these, and perform recovery when you do
03:36:29 <yitz> wli: characteristic p?
03:36:48 <wli> yitz: No, over algebraic extensions of Q for ground fields.
03:36:57 <Peaker> idnar: unwind, recovery, wind again?
03:37:03 <idnar> Peaker: 2) you want to prevent failures in an isolated subsystem from tearing the whole system down; so you catch any error, who cares what, and then log it or something
03:37:20 <wli> yitz: Maybe even moving to extensions of the ground field in the process.
03:37:43 <idnar> eh, "isolated subsystem" isn't really what I mean
03:37:51 <quicksilver> idnar: still, I agree with you
03:37:58 <yitz> wli: for greater than degree 4 you're going to have some trouble
03:37:58 <quicksilver> that's definitely the idea.
03:38:02 <idnar> but for example, if your webserver's request handler spews an exception, you don't want the whole web server to crash
03:38:33 <wli> yitz: Basically if a user writes an algebraic expression I'm trying to figure out if they really extended the field or not.
03:40:30 <wli> e.g. they write (x^2+1)^(1/3)/(1 + ((x^2+9)*(x^2+1)^(1/3)-4*x^2)^(1/2)) and i need to go about finding an integral basis for the extension of Q(x) to use for zero testing etc.
03:40:36 <porges> quick question: newtype wrappers are supposed to disappear during compilation so they impose no overhead, but what about things like (map unProduct $ fold $ map Product xs)
03:41:21 <wli> yitz: If I can't find n-th powers it thwarts zero testing because the basis of the "apparent extension" is not actually linearly independent.
03:42:26 <quicksilver> porges: if it fuses correctly, then it will be fine.
03:42:47 <quicksilver> if not, you essentially have "map id"
03:42:58 <quicksilver> which is O(n) but with a low constant factor.
03:43:18 <porges> is there a smarter way to write it?
03:43:20 <yitz> wli: doesn't the impossibility of finding polynomial roots of degree > 4 make this look discouraging?
03:44:17 <wli> yitz: I don't know that it's equivalent to solving polynomials of degree greater than 4 in terms of radicals and rational operations.
03:44:32 <quicksilver> s/finding/finding in terms of surds/
03:44:34 <yitz> it's more general i think
03:45:41 <quicksilver> there's nothing 'insoluable' about quintics except the fact that galois theorists cleverly redefined the word 'soluble' to make their theorem look more impressive.
03:47:04 <yitz> quicksilver: wli wants to know if you need to extend the field. i think you can find special cases of that that would special cases of finding a rational root of a polynomial of arbitrary degree.
03:47:19 <yitz> that would be equivalent to
03:47:27 <quicksilver> yes, I agree. That was just pedantry for pedantry's sake
03:47:34 <quicksilver> and not entirely relevant to your discussion, sorry.
03:47:39 <yitz> heh
03:47:48 <wli> yitz: I suspect (y^2-2*y-2)^2 = (x^2+9)*y - 4*x^2 mod y^3-x^2-1 is more analogous to k-th roots mod n.
03:48:02 <quicksilver> I was so affronted when I learnt the trick the Galoisistes had played with the word 'soluble' I feel required to repeat it at every opportunity.
03:48:42 <yitz> quicksilver: true, but it's not really their fault. it was a classic unsolved problem at the time.
03:49:29 <wli> It all goes back to Gauss' construction of the 17-gon.
03:49:59 <yitz> we are drifting towards haskell-blah...
03:51:26 <wli> yitz: My first hope was that if I went for the minimal polynomial I'd discover it was actually quadratic or biquadratic, but that's not working out. The minpoly turned out to be u^3+12*x^2*u^2+48*x^4*u-16*x^4
03:51:54 <yitz> wli: you're interested in a specific rational function?
03:52:09 <wli> yitz: No, I'm working through examples.
03:52:14 <yitz> oh ok
03:52:49 <yitz> yeah. this sounds general enough to be really hard
03:53:19 <yitz> otoh if you can solve it you'll surprise a lot of people and become famous
03:57:23 <quicksilver> Nice. Only 10% of us left by that netsplit
03:58:06 <yitz> oh blech. there goes my scrollback. here we go to the channel logs.
03:58:35 --- mode: irc.freenode.net set +o ChanServ
03:58:46 <quicksilver> and, they're back. Or we're back. Or something.
03:59:25 <wli> yitz: I suspect if I can smoke out a minpoly reliably I'll find that the minpoly for a perfect power over a field is the same as the minpoly for the field or related to it in some meaningful way.
04:00:48 <wli> yitz: Rumor has it there are some structure theorems for this (due to Risch?) but they're ACM portal unobtainium etc.
04:04:21 <rittyan2> any ubuntu victims? how to get Text.Regex.PCRE there?
04:04:58 <yitz> wli: oh really? interesting. but even if so, i don't see how that will help you for arbitrary expressions involving nth roots.
04:05:03 <Peaker> rittyan2: I gave up on Ubuntu's Haskell packaging -- I removed all Haskell related packages, and installed ghc binaries in /usr/local/bin and cabal in my home dir, and I just cabal install whatever I need
04:05:19 <Peaker> rittyan2: cabal is much nicer than apt for current Haskell software
04:05:28 * quicksilver laughs ironically
04:05:32 <rittyan2> Peaker, I so believe you
04:05:38 * rittyan2 hates binary distros :<
04:05:39 <quicksilver> a tool which can't even remove software?
04:06:10 <quicksilver> cabal was never intended to replace distro packages
04:06:15 <quicksilver> it's a different goal
04:06:29 <yitz> cabal is designed to be *used* by distro packaging software
04:06:31 <rittyan2> well, if maintainers are not so good, you are on your own, no?
04:06:42 <Peaker> quicksilver: maybe I should have said "for getting current Haskell software"
04:07:03 <yitz> Peaker: build ghc head from source
04:07:26 <lepassive> I want some Functional vs OO paradigms
04:07:44 <yitz> lepassive: there is a wiki page about that
04:07:59 <wli> yitz: If t is in K(x)(y_1,y_2,...) and t is an n-th power, then t^(1/n) adds nothing to the field, so something degenerate will happen when you compute the minpoly of {t^(1/n),y_1,y_2,...} over K(x)
04:08:06 <yitz> @go haskell wiki oo
04:08:08 <lambdabot> http://en.wikipedia.org/wiki/O'Haskell
04:08:11 <yitz> no
04:08:12 <lepassive> yitz, mind giving me the link? i only got the benefits on functiona programming
04:08:29 <yitz> @go haskell wiki oo functional
04:08:32 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
04:08:32 <lambdabot> Title: Introduction - HaskellWiki
04:08:38 <yitz> no
04:08:45 <yitz> anyone remember?
04:09:37 <wli> yitz: The k-th roots of integers mod n are computable, so this should be computable, too.
04:10:23 <yitz> http://haskell.org/haskellwiki/OOP_vs_type_classes
04:10:43 <yitz> lepassive: try that one
04:10:51 * wli is not terribly impressed by the if statement example. The structure is precisely isomorphic.
04:10:54 <lepassive> yitz, okay thanks alot
04:13:44 <yitz> wli: i don't get it. you said you are in characteristic 0.
04:14:01 <idnar> yitz: bleh, giving C++ examples is cheating
04:14:24 <idnar> C++'s horrific verbosity is not inherently required by OOP :P
04:14:24 <yitz> wli: I get the feeling I am misunderstanding what you are trying to accomplish
04:14:39 <wli> yitz: The algebraic extension Q(x,(x^2+1)^(1/3)) is isomorphic to Q(x,y)/(y^3-x^2-1)
04:15:49 <yitz> idnar: what we really need there is a video of an OO program segfaulting. also easiest with C++. but also not fair I guess. :)
04:16:10 <wli> yitz: The characteristic of the underlying field remains 0; it's polynomial ideals getting factored out.
04:16:21 <idnar> yitz: haha
04:18:23 <yitz> wli: hm? that's not an isomorphism, that's by definition.
04:18:54 <yitz> rather, the first is an informal shorthand for the second
04:19:48 <wli> yitz: The analogy with k-th roots of integers mod n has to do with taking roots while modding out that polynomial ideal.
04:22:15 <yitz> wli: so then you're trying to find rational points of algebraic varieties? also not so easy I think...
04:23:14 <wli> yitz: That's vastly more general.
04:27:07 <yitz> wli: yes. but i think that extending a function field by arbitrary expressions involving nth roots and trying to determine how that extends the base function field is quite general.
04:28:45 <lepassive> yitz, all what i get is that FP takes you in faster than OO
04:28:56 <wli> I'm almost sure I've even seen answers to this. It's not that general or even close.
04:29:21 * SamB wonders neither RFC 2549 nor RFC 1149 has any errata -- 1149, at least, has been implemented
04:32:35 <rittyan2> jedai, are you here?
04:35:07 <lepassive> is O'Haskell active ?
04:37:05 <quicksilver> lepassive: No.
04:37:27 <quicksilver> lepassive: adding OO to haskell is like adding razor blades to apples.
04:37:44 <lepassive> quicksilver, valid point
04:37:49 <quicksilver> an engineer might like to design an efficient process, but no one would dream of using it.
04:38:27 <quicksilver> OOHaskell (note, two Os!) is an interesting exploration of what you can do within haskell
04:38:45 <quicksilver> although I think it should mostly be viewed as an experiment and a cookbook
04:38:50 <quicksilver> of the kind of things you can do.
04:38:54 <quicksilver> http://homepages.cwi.nl/~ralf/OOHaskell/
04:40:54 <rittyan2> can I do (\(x:xs) -> ...)?
04:41:03 <rittyan2> ah! I don't need that, nevermind
04:41:25 <RayNbow> > (\(x:xs) -> x) [1..]
04:41:25 <quicksilver> you can do it, though.
04:41:26 <lambdabot>   1
04:41:35 <RayNbow> > (\(x:xs) -> x) [] -- oh noes... :p
04:41:36 <lambdabot>   * Exception: /tmp/6895235456148423690:71:33-44: Non-exhaustive patterns in ...
04:42:26 <lepassive> quicksilver, isn't it all about how to group and operate on data ?
04:43:24 <wli> yitz: Use Grobner bases on { z^2 - (x^2+9)*y + 4*x^2, y^3 - x^2 - 1 } in a term ordering eliminating x first. You get y^4 - 4*y^3 + 8*y + 4 - z^2 , and then y^4 - 4*y^3 + 8*y + 4 is a perfect square.
04:45:22 <wli> yitz: I think perfect powers in Z[x] are more manageable.
04:46:12 <wli> yitz: Differentiation works if nothing else.
04:46:52 <quicksilver> lepassive: that would appear to describe a broad swathe of computer programming, yes :)
04:47:50 <wli> yitz: I'm not sure how generally this works just yet or if it needs handling for corner cases or really any sort of rigorous anything.
04:51:28 <HugoDaniel> i want to process a list so it can be easily turned into a map, something like this: [(a,b)] -> [(a,[b])], anyone knows of any functions to work this out ?
04:52:33 <ivanm> HugoDaniel: looks like a group job
04:52:57 <HugoDaniel> hmm
04:53:04 <HugoDaniel> i dont know the group function, let me check it out
04:53:06 <ivanm> maybe a sort as well if needed
04:53:12 <ivanm> @type group
04:53:13 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
04:53:21 <ivanm> actually, you'd probably want groupBy
04:53:24 <wli> yitz: There are probably massive holes all over this, but it's a start.
04:53:24 <ivanm> @type groupBy
04:53:26 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
04:54:01 <HugoDaniel> allright :)
04:54:02 <HugoDaniel> thanks
04:54:53 <quicksilver> > map (fst . head &&& map snd) . groupBy ((==)`on`fst) . sortBy (comparing fst) $ [(1,5),(2,3),(1,8),(2,2),(1,1)]
04:54:54 <lambdabot>   [(1,[5,8,1]),(2,[3,2])]
04:54:58 <quicksilver> HugoDaniel: there you go.
04:55:04 <quicksilver> HugoDaniel: now all you have to do is understand that ;)
04:55:28 <quicksilver> it's probably more efficient to use the Data.Map functions directly, though
04:55:29 <bremner> is there a nice LaTeX environment for little ghci example sessions?
04:55:33 <quicksilver> rather than preprocess it.
04:55:41 <ivanm> @type (&&&)
04:55:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:56:09 <HugoDaniel> quicksilver: i tried fromList, but it didn't work quite right :P
04:56:14 <HugoDaniel> ill need to group them first i guess
04:56:16 <ivanm> quicksilver: what does &&& do in terms of pairs?
04:56:42 <HugoDaniel> @type on
04:56:43 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:57:34 <wli> Personally, I would do IntMap.fromListWith IntSet.union $ List.map (second IntSet.singleton) ([(1,5),(2,3),(1,8),(2,2),(1,1)] :: [(Int,Int)])
04:57:35 <quicksilver> > Map.fromListWith (++) . map (second (:[])) $ [(1,5),(2,3),(1,8),(2,2),(1,1)]
04:57:37 <lambdabot>   fromList [(1,[1,8,5]),(2,[2,3])]
04:57:47 <quicksilver> HugoDaniel: that's what I meant by the Data.Map way
04:58:01 <quicksilver> ivanm: f &&& b is (\x -> (f x , b x))
04:58:02 <wli> Also see IntMap/IntSet
04:58:30 <ivanm> quicksilver: ahhh, k
04:59:58 <HugoDaniel> @type second
04:59:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
05:00:15 <quicksilver> HugoDaniel: 'second' pushes a function into the second parameter of a tupe
05:00:23 <quicksilver> > second (+1) (5,5)
05:00:25 <lambdabot>   (5,6)
05:00:25 <wli> > Map.fromListWith Set.union $ map (second Set.singleton) [(1,5),(2,3),(1,8),(2,2),(1,1)] -- in case they're not really Int's
05:00:27 <lambdabot>   fromList [(1,fromList [1,5,8]),(2,fromList [2,3])]
05:01:18 <HugoDaniel> they are Days, not ints
05:03:52 <wli> HugoDaniel: Map/Set is the way to go, then, but go for IntMap/IntSet where possible.
05:04:16 <ivanm> wli: is Map/Set the data-structure equivalent of MapReduce? :p
05:04:33 <wli> ivanm: heh
05:05:07 <Peaker> wli: I'd think ghc were smart enough to drop in IntMap/IntSet for Map Int/Set Int where semantics wouldn't change.. any idea why that isn't automatic?
05:05:08 * wli vaguely wonders if IntMap/IntSet puke on negative indices.
05:05:26 <ivanm> wli: I don't think so...
05:05:42 <ivanm> Peaker: because IntMap /= Map ...
05:05:52 <Peaker> ivanm: what difference is there in the semantics?
05:06:12 <wli> Peaker: The implementations are likely vastly different, e.g. balanced tree vs. trie.
05:06:21 <ivanm> Peaker: the data structure itself is different, and I'm not sure if the APIs are identical
05:06:35 <ivanm> Peaker: if there was a class they both instantiated, then that might be a different story
05:07:03 <Peaker> Yeah, it probably could be nice if Haskell stdlib had type-classes for maps, sets, etc
05:07:13 <ivanm> but still, if you specified a Map, then how can it replace it with an IntMap?
05:07:24 <ivanm> esp. if you then called other polymorphic code that expected a map
05:07:29 <ivanm> you'd have to specialise each one, etc.
05:07:46 <ivanm> Peaker: let's turn all of Haskell into one big type-class! ;-)
05:07:48 <Peaker> ivanm: if its specifically a "Map Int"
05:08:04 <Peaker> ivanm: like template specializations
05:08:08 <ivanm> Peaker: yes, but the data structures themselves are different
05:08:20 <ivanm> it's not just a matter of using a specialised algorithm
05:08:34 <ivanm> so type-checking won't work
05:08:39 <wli> The type constructors are furthermore different.
05:08:57 <wli> They've got differing arities, even.
05:10:12 <Peaker> wli: Seems that the type constructor (IntSet = Set Int)   and (IntMap = Map Int)  -- at least kind-wise
05:12:37 <ivanm> Peaker: if you have a generic function Map a b -> c, how is haskell going to be able to automagically convert it to IntMap b -> c ?
05:12:51 <lepassive> what about of inheritance usage in Haskell ?
05:12:54 <Saizan> Peaker: associated datatypes solve that problem without requiring so much compiler magic
05:13:16 <Peaker> ivanm: I'm talking about specific cases where its not polymorphic but Map k v where k is already known to be Int
05:14:01 <Saizan> Peaker: yeah, but suppose you're going to pass you Map Int to a functiond efined in another library somewhere that's written to be generic ofver Map a b
05:14:07 <ivanm> Peaker: but how can you guarantee you're only using the inbuilt functions
05:14:30 <Saizan> Peaker: ghc would need to rewrite that latter function to use IntMap under the hoods
05:14:55 <Peaker> Saizan: Well, as a user of a compiler, I throw such complexities at the compiler writers :)
05:14:57 <Saizan> Peaker: it's doable with whole program compilation, i guess
05:15:48 <Peaker> Saizan: it could keep enough information to rebuild/optimize the code for the specialization -- hopefully in a better way than C++ did it :)
05:16:39 <Saizan> yeah, the costs might not be worth the benefits, though
05:17:07 <Saizan> still associated datatypes solve the same problem in a more pricipled way, imo
05:17:14 <Peaker> yeah, something really bothers me about being exposed to the existence of both Map Int and IntMap in libraries and having to explicitly use the latter
05:17:48 <Peaker> Saizan: to use that you'd have a type-class for Maps with an associated data-type for each key type?
05:18:06 <Peaker> or for each key and value type pair?
05:18:26 <Saizan> depends on how you define the class, the key type suffices
05:19:37 <Saizan> you'd need something like OverlappingInstances or a default case to avoid writing too many instances, probably
05:22:52 <codebliss> Shouldn't this code strip all the front of a file so we get the extension (also with the ".")?  Code:    ext = takeWhile (/= '.')
05:23:10 <RickBarnev> TThijs, :P
05:23:17 <TThijs> RickBarnev :P
05:23:36 <Ferdirand> codebliss: don't you mean dropWhile ?
05:23:40 <RickBarnev> vraag maar aan deze gasten, die hebben er verstand van
05:23:48 <codebliss> Ah.  Thanks.  I'll try that
05:23:54 <codebliss> Sorry, noobie =)
05:24:05 <TThijs> juist, pro
05:24:27 <Ferdirand> codebliss: also, . can be part of a file name
05:24:43 <codebliss> Read from right end?
05:25:53 <quicksilver> Saizan: I don't think that associated types really do solve the IntMap problem to be honest
05:25:57 <codebliss> Errored.  lexical error in string/character
05:26:09 <quicksilver> Saizan: (in the sense that they require overlappinginstances, which I consider a sign that something is fatally broken)
05:26:28 <codebliss> Do you guys understand where I'm coming from?
05:27:00 <quicksilver> Saizan: I think the key problem is that (by design) a compiler which respects parametricity cannot behave differently for a polymorphic Map k v if that k turns out (at runtime) to be Int.
05:27:13 <codebliss> "fol/file.txt" -> "ol/file.txt" -> ... -> "e.txt" -> ".txt"
05:27:35 <quicksilver> so you either drop parametricity from you design (a shame) or you reconcile yourself to only catching some proportion of cases, those which can be statically observed by your compiler
05:27:42 <quicksilver> e.g. with SPECIALISE or a similar mechanism.
05:27:58 <quicksilver> codebliss: sure. Start from the right hand end.
05:28:12 <codebliss> Well I'm erroring either way.
05:28:23 <wli> yitz: It seems to work for a couple other simple examples.
05:28:31 <quicksilver> codebliss: you could just use System.FilePath
05:28:34 <codebliss> wouldn't it be takeWhile (/= '.') ignoring the fact there could be periods heading to it
05:28:38 <quicksilver> codebliss: that's what it's there for.
05:28:43 <codebliss> The point of me learning haskell is the basics lol
05:28:47 <quicksilver> ok.
05:28:52 <quicksilver> well reverse the string first.
05:29:00 <codebliss> I'm not going to use that unless I get the language =)
05:29:09 <codebliss> Couldn't you just read from the right?  Would be faster.
05:29:11 <quicksilver> > reverse . takeWhile (/='.') . reverse $ "foo/bar.txt"
05:29:13 <lambdabot>   "txt"
05:29:18 <quicksilver> codebliss: strings can't read from the right.
05:29:23 <RayNbow> codebliss: String = [Char]
05:29:27 <codebliss> They're just lists?
05:29:30 <quicksilver> right.
05:29:32 <RayNbow> and lists in Haskell are linked lists
05:29:34 <quicksilver> well I say "Can't"
05:29:36 <quicksilver> they can, and I just did.
05:29:43 <quicksilver> but the way you do it is reversing first :)
05:30:09 <codebliss> Well then there isn't a takeWhiler?
05:30:23 <Ferdirand> > System.FilePath.Posix.takeExtension "foo/bar.txt"
05:30:25 <lambdabot>   /tmp/6257036580954278563:70:32:
05:30:25 <lambdabot>      Not in scope: `System.FilePath.Posix.t...
05:30:38 <Ferdirand> eew
05:31:09 <RayNbow> @let takeWhileR p = reverse . takeWhile p . reverse
05:31:10 <lambdabot>  Defined.
05:31:23 <RayNbow> > takeWhileR (/='.') "foo/bar.txt"
05:31:25 <lambdabot>   "txt"
05:31:34 <quicksilver> codebliss: lists do not support direct access to the right-hand-end
05:31:44 <quicksilver> codebliss: so takeWhileR isn't really a natural primitive to supply.
05:31:52 <codebliss> What's the thing that goes with init?
05:31:58 <codebliss> There's heat tail init and...
05:32:08 <wli> yitz: Grobner bases conquer all.
05:32:13 <quicksilver> codebliss: last
05:32:22 <codebliss> There we go?
05:32:22 <RayNbow> > takeWhileR (/=0) [1..]   -- oh noes... :p
05:32:28 <codebliss> lmao =P
05:32:31 * RayNbow waits till lambdabot explodes
05:32:47 <lambdabot>   mueval: Prelude.read: no parse
05:32:49 <codebliss> I doubt a file path would be infinately long
05:32:52 <codebliss> That would be trouble lol
05:33:19 <RayNbow> codebliss: no, but takeWhileR has limited use as it only works on finite lists
05:33:29 <quicksilver> same is true of 'last'
05:33:30 <quicksilver> shrug
05:33:34 <quicksilver> I think it's a question of degree.
05:33:47 <quicksilver> Data.List contains mostly those functions which are natural, or have expected complexity.
05:33:47 <codebliss> takeWhileR is not in scope.  Where's it in?
05:33:54 <codebliss> Data.List? XD
05:34:01 <quicksilver> codebliss: RayNbow defined it 2 minutes ago.
05:34:12 <quicksilver> 12:31 < RayNbow> @let takeWhileR p = reverse . takeWhile p . reverse
05:34:13 <codebliss> Oh whoops
05:34:17 <codebliss> I see, sorry
05:34:24 <codebliss> What's with the @?
05:34:29 <RayNbow> lambdabot command
05:34:33 <quicksilver> that how you give lambdabot a command
05:34:41 <codebliss> Oh
05:34:48 <codebliss> We got a haskell bot?  Awesome
05:34:52 <RayNbow> @bot
05:34:53 <lunabot>  :)
05:34:53 <lambdabot> :)
05:34:58 <RayNbow> we have multiple
05:34:58 <codebliss> Ah lol
05:35:05 <bremner> bot fight!
05:35:44 <RayNbow> "IN THE RED CORNER, WE HAVE THE ALMIGHTY LAMBDABOT..." :p
05:35:46 <RickBarnev> hahahahat TT|KUTFP still here?:P
05:36:27 <codebliss> Thank you =)
05:37:21 <codebliss> If I were to put this dropWhileR in a library, should I use a ! to signal it can't be used on infinite lists, or just to give caution?
05:37:33 <wli> yitz: I feel like I have an answer of sorts.
05:39:35 <codebliss> So, is this currying in action RayNbow?
05:40:06 <codebliss> In your definition, p is the condition and the data?
05:40:16 <RayNbow> no, it's only the predicate
05:40:25 <codebliss> Hm?
05:40:37 <RayNbow> takeWhileR p = reverse . takeWhile p . reverse  -- this definition is equal to...
05:40:44 <RayNbow> takeWhileR p xs = (reverse . takeWhile p . reverse) xs   -- this definition
05:40:51 <codebliss> Oh.
05:40:58 <quicksilver> codebliss: I would not put it in a library. It's not a good function.
05:40:58 <codebliss> Duh.  Gotcha
05:41:10 <quicksilver> codebliss: you should always use functions appropriate to your data types
05:41:14 <codebliss> Alright lol
05:41:19 <quicksilver> if reading from the right is a common operation
05:41:24 <quicksilver> you should consider ByteString or Data.Sequence
05:41:43 <codebliss> Then again, I'm a noobie and have no idea what they are
05:42:15 <codebliss> I thought in functional programming you should be as general as possible?
05:43:09 <profmakx> the "as possible" part being the important one
05:43:19 <profmakx> but  thats the case in any programming language i guess
05:43:27 <desp> Uh.
05:43:46 <desp> Does Data.IntMap really have linear-time access to elements?
05:44:08 <quicksilver> Once it has more than 32 or 64 elements, yes.
05:44:17 <wli> You mean constant?
05:44:26 <quicksilver> sorry, I assumed he meant constant :)
05:44:50 <desp> ?
05:44:52 <bastl> are there any good realworld examples for haxml? i have sucessfully converted a dtd and can parse my xml-file, Now I want do something with the data (lookup, transform etc.) the documentation on haskell.org/haxml is rather terse.
05:45:07 <desp> You assumed I meant constant by linear?
05:45:14 <quicksilver> I did, yes.
05:45:22 * wli is dancing in the street about the method for determining whether radicands are perfect powers and no one else seems to care.
05:45:34 <desp> I'm just surprised that IntMap's (!) is apparently O(min(N,W)) while Map's (1) is O(log(n))
05:45:42 <desp> And IntMap is supposed to be more efficient.
05:46:01 <desp> quicksilver: so, what is IntMap's access time?
05:46:07 <yitz> wli: i was disconnected (electrical repair). you mean you solved it?
05:46:25 <quicksilver> desp: constant
05:46:28 <quicksilver> desp: O(W) is constant
05:46:31 <quicksilver> desp: W is a constant.
05:46:51 <RayNbow> wli: blog about it and submit it to the Haskell reddit? :)
05:47:04 <desp> quicksilver: so, once it has more than W elements, the access time gets linear?
05:47:08 <quicksilver> desp: CONSTANT
05:47:10 <quicksilver> not linear.
05:47:40 <desp> OK.
05:47:42 <Eelis> desp: once n>W, min(n,W) is always W
05:47:47 <desp> Right.
05:47:49 <loop> O(min(N,W)) is just tighter bound for O(W)
05:47:52 <profmakx> wli  can't you ask GAP?
05:47:54 <profmakx> *snicker*
05:47:58 <desp> :)
05:48:04 <codebliss> Geeks <3
05:48:50 <wli> yitz: Yes, given {z^n - q(x,y), y^k - p(x)} find a Grobner basis in a term order eliminating x, which results for some reason in z^n - f(y) in all cases I can think of to plug into Maple, at which point it's testing for perfect n-th powers in Z[x], which is easy with gcd's of f with its (n-1)-st derivative and farting around with the quotient.
05:51:01 <yitz> wli: well, now i understand better what you were trying to do. :)
05:55:34 <wli> yitz: Well, I've found that ((x^2+9)*(x^2+1)^(1/3)-4*x^2)^(1/2) = (x^2+1)^(2/3) - 2*(x^2+1)^(1/3) - 2 and ((2+3*x^3-x^9)*(x^3+1)^(3/5)+(4+11*x^3+10*x^6+3*x^9)*(x^3+1)^(2/5)-5-15*x^3-15*x^6-5*x^9)^(1/3) = (x^3+1)^(4/5)-(x^3+1)^(6/5)+x^3+1
05:56:39 <wli> 2 examples and a counterexample and an engineer would assume it worked. I merely skipped looking for a counterexample. ;)
05:57:26 <yitz> wli: you need a quickcheck property now :)
05:57:38 <bastl> could someone show me a good way howto write accessor-functions for (given) complex data types? see http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2779
05:57:41 * yitz is getting dizzy from these ascii polynomials
05:58:07 <bastl> the data type is generated from Dtd2Haskell, and i want to lookup something deep inside the data ...
05:58:15 <wli> yitz: Applications of QuickCheck to Grobner basis code sound like a paper topic.
05:58:49 <yitz> bastl: you definitely want to convert that to a record
05:59:20 <yitz> well not definitely. quicksilver is about to disagree and propose something else.
05:59:40 <bastl> yitz: then i'd had to patch haxml. I have a similar case with the ASTs generated by BNFC ...
06:00:17 <wli> yitz: I don't entirely understand why the Grobner basis always comes out as having something of the form z^n - f(y) in it.
06:00:38 <mmorrow> bastl: if the queries you have in mind aren't context-sensitive, Data.Generics is a quick and dirty way to pull out some info
06:01:25 <yitz> bastl: you can replace an ADT with an equivalent record type and all of the rest of the code will still work fine. That should be ok as long as your dtd stays the same.
06:01:36 <mmorrow> , everywhere (mkT (*2)) ((1,(42,8)),((2,93),5))
06:01:37 <lunabot>  ((2,(84,16)),((4,186),10))
06:02:11 <bastl> mmorrow: they are.
06:02:53 <bastl> yitz: but your first idea seems good: my function there is the accessor function thje record give automatically tight ?
06:03:15 <wli> yitz: Never mind. Just keep raising y to powers to obtain a basis for polynomials in x.
06:03:21 <bastl> *would give
06:03:49 <yitz> bastl: yes
06:03:57 <wli> yitz: You get high powers of y but q(x,y) is then a polynomial in y only.
06:05:22 <wli> yitz: In fact I can use that to special case the whole affair and avoid Grobner bases.
06:05:41 * mmorrow_ starts to worry that his computer just freezes about 1/hr (the mouse moves, nothing else)
06:07:03 <joga> mmorrow_, linux + ati graphics? ;)
06:07:25 * mmorrow_ checks
06:07:51 <mmorrow_> it's a thinkpad x301, and i put fedora64bit on it
06:08:50 <wli> yitz: If the polynomials in x acting as coefficients of the powers of y in q(x,y) aren't within any subspace spanned by powers of p(x) then it breaks down.
06:09:17 <joga> mmorrow_, seems it has intel gfx...well, they're not that perfect either. disabling desktop effects and such may help
06:10:16 <mmorrow_> joga: oh noes!! but my wobbly opengl transparent windows on a cube i can't bear to live without!
06:10:34 * mmorrow_ was serious too ;)
06:10:47 * mmorrow_ turns off effects
06:10:50 <joga> ;)
06:12:55 <mmorrow_> joga: so you think that's really it?
06:13:06 <mmorrow_> what would be happening?
06:13:34 <joga> mmorrow_, let's just say that whenever I use my mobility radeon 9000 on a certain laptop for drawing effects or other 3d, it *will* crash eventually
06:14:00 <joga> often as you described: mouse moves, but otherwise X is frozen, and the computer will lock up if I kill it remotely
06:14:08 <yitz> bastl: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2779#a2782
06:14:14 <mmorrow_> it's weird. it just freezes solid.. but the mouse moves just fine.
06:14:31 <joga> mmorrow_, so to me it sounds like a graphics driver bug or such
06:17:28 <porges> i love writing instances for ()
06:17:52 <bastl> yitz: thanks alot. but for the web'app dtd i have 420 lines of data types. So i'll have to generate that records. perhaps something malcomw could look at... ?
06:19:16 <Pellwurst> does anyone know the book "Real World Haskell" (O'REILLY)? I'm thinking about buying it and would like to hear some opinions...
06:19:54 <yitz> bastl: if it's a one-time thing, you should be able to do it in a few minutes using regexps in your favorite editor
06:20:40 <bastl> Pellwurst: read the title of this channel ?
06:20:42 <yitz> Pellwurst: in this channel you are likely to find the authors telling you it's good :)
06:21:18 <Pellwurst> lool, ouch
06:21:20 <yitz> Pellwurst: but I've never seen anyone around here not liking it, even non-authors like me.
06:21:20 <bastl> Pellwurst: try the online version first.
06:22:24 <bastl> most impressive pages of the book are the last three pages of the preface ...
06:22:51 <ejt> Pellwurst: RWH is very good, though I do feel you should glean all this information from years of reading papers and blog posts, rather than having it handed to you on a plate ...
06:23:59 <bastl> right, the plate isa on my desk, but it still takes time to understand and practise ...
06:24:20 <ejt> :)
06:24:26 <bastl> ( i tried to formulate foldl in terms of foldr an resigned ... )
06:24:27 <yitz> ejt: soon they're coming out with a new edition called "Academic World Haskell", containing only bibliographical reference that you are to read in order.
06:24:40 <yitz> references
06:24:52 <ejt> yitz: if only that were true :)
06:24:58 <quicksilver> yitz: actually it just contains them as a graph. You have to do the topological sort yourself.
06:25:21 <mornfall> quicksilver: Unfortunately, it has cycles in it.
06:25:49 <temoto> Is it possible to write "where" clause many times?
06:25:50 <quicksilver> mornfall: yup. Some things you just have to live with.
06:25:53 <temoto> like nested where
06:26:02 <yitz> temoto: yes
06:26:04 <quicksilver> temoto: yes, but there is seldom need to do so.
06:26:05 <mornfall> temoto: Yes, why not?
06:26:06 <Saizan_> quicksilver: re associated types: i think we should try to extract the useful and well behaved feature hidden inside OverlappinInstances :)
06:26:10 <temoto> Thanks.
06:26:30 <temoto> A friend having issues with nested where. Perhaps it's indentation issues then.
06:26:46 <quicksilver> temoto: haskell doesn't have arbitrary restrictions - let is valid anywhere an expression is valid, where is valid anywhere a definition is valid.
06:26:54 <quicksilver> on the other hand, nested where looks ugly as hell
06:27:04 <quicksilver> you only need if you're capturing local variables
06:27:07 <temoto> sorry, on the first hand what?
06:27:14 <quicksilver> and even then, I'd probably lift something to the top level
06:27:16 <quicksilver> the first hand was:
06:27:19 <quicksilver> temoto: haskell doesn't have arbitrary restrictions - let is valid anywhere an expression is valid, where is valid anywhere a definition is valid.
06:27:32 <temoto> aha
06:27:34 <quicksilver> Saizan_: If there is one, definitely.
06:27:51 <temoto> i can remember some difference between usage of let/in and where, though.
06:28:04 <yitz> > nest "where" where {nest x = "You can nest " ++ x ++ c where {c = " clauses."}}
06:28:05 <lambdabot>   "You can nest where clauses."
06:28:09 <temoto> Like let-in could be used in more places than where or something.
06:28:30 <quicksilver> temoto: the set of places they can be used is totally disjoint.
06:28:31 <ejt> temoto: let is an expression
06:28:32 <quicksilver> let for expressions
06:28:35 <quicksilver> where for definitions
06:28:50 <temoto> erhh..
06:28:51 <quicksilver> [*] slightly cooky sense of the word definition, it includes clauses of case statements.
06:29:12 <yitz> there are actually 3 - let, let..in, and where, all mutually disjoint
06:29:40 <quicksilver> although the first 'let' variant is a fairly simple minded sugar around the second
06:30:24 <temoto> I'm sorry, what is difference between expressions and definitions?
06:30:40 <temoto> I only understand how to use "where".
06:30:50 <temoto> Never used let-in.
06:31:22 <doserj> temoto: if it contains "=", it is a definition
06:31:25 <quicksilver> temoto: 1 is an expression.
06:31:28 <quicksilver> temoto: so is (1+2)
06:31:36 <quicksilver> and so is (putStrLn "hi")
06:31:45 <quicksilver> "f x = x+1" is a definition
06:33:42 <temoto> I don't get..
06:33:58 <quicksilver> I don't understand what you don't get.
06:34:02 <temoto> myfun x = let y = x* 2 in y
06:34:09 <temoto> is it normal?
06:34:11 <quicksilver> yes.
06:34:14 <mmorrow_> , [|let x = 42 in x|]
06:34:16 <lunabot>  LetE [ValD (VarP x_0) (NormalB (LitE (IntegerL 42))) []] (VarE x_0)
06:34:18 <quicksilver> (let y = x*2 in y) is an expression
06:34:21 <mmorrow_> , [|x where x = 42|]
06:34:22 <lunabot>  luna: parse error on input `where'
06:34:29 <temoto> AHA!
06:34:48 <quicksilver> temoto: defintions take the form (roughly) <name> <parameters> = <expression>
06:34:56 <temoto> So where can't be used in things like generators because they expect expressions.
06:34:58 <quicksilver> full details in the report.
06:35:07 <mmorrow_> temoto: exactly
06:35:14 <quicksilver> where can't be used in things like generators because generators are python and where is haskell.
06:35:21 <quicksilver> ;)
06:35:22 <temoto> Alright, thanks.
06:35:48 <temoto> quicksilver: i meant list comprehensions.
06:36:17 <temoto> BTW i miss "where" syntax in python very much.
06:37:17 <mmorrow_> , let x = y where y = 42 in x
06:37:18 <lunabot>  42
06:37:51 <temoto> , 42
06:37:53 <lunabot>  42
06:37:59 <mmorrow_> , x where x = 42
06:38:00 * doserj misses a where for expressions.
06:38:00 <lunabot>  luna: parse error on input `where'
06:38:04 <temoto> Way shorter :)
06:38:08 <mmorrow_> , let x = 42 in x
06:38:09 <lunabot>  42
06:38:13 <mmorrow_> heh
06:38:41 <mmorrow_> , let x = Node () [x,x] in levels x
06:38:43 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
06:39:19 <mmorrow_> @src fix
06:39:19 <lambdabot> fix f = let x = f x in x
06:39:37 <mmorrow_> , levels (fix (\x -> Node () [x,x]))
06:39:38 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
06:40:01 <temoto> I read SICP and at some place it says that devs are writing another micro DSL every time they write a program - like set of modules, functions in them it's a language too. And then they express their real-world problem in therms of that new created language.
06:40:12 <temoto> I never thought of programming that way.
06:40:29 <ejt> temoto: that's a very FP point of view (and one I like a lot)
06:41:32 <Eelis> isn't "DSL" just a trendy name for "nice library" ?
06:41:35 <temoto> But then i read article http://palm-mute.livejournal.com/16407.html  well it's in russian, but you can read haskell code. And the guy is just implemented abstract language with 4 operations on top of haskell types and all. It's just so amasing!
06:41:48 <temoto> Eelis: now it seems so, yeah.
06:42:36 <ejt> Eelis: with Haskell yes, with Lisp it tends to be library + set of macros, with imperative languagees it tends to be more difficult
06:42:39 <ambient> i don't think turing completeness is that hard actually...
06:42:51 <doserj> Eelis: to be pedantic, EDSL is a name for a library. DSL is a name for a parser
06:43:09 <temoto> doserj: what's leading E?
06:43:09 <Eelis> i meant EDSL, yes, sorry
06:43:15 <doserj> embedded
06:43:21 <temoto> hm
06:44:08 <temoto> How could noun change meaning from library to parser?
06:44:27 <temoto> I mean.. "domain specific language".. it doesn't says "... parser" or "parser for ..."
06:45:19 <Baughn> @hoogle Bool -> a -> a -> a
06:45:20 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
06:45:20 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
06:45:20 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
06:46:09 <quicksilver> temoto: because you have to parse a DSL to use it.
06:46:13 <quicksilver> temoto: hence, there must be a parser.
06:46:44 <temoto> quicksilver: why "embedded DSL" does not imply parser?
06:47:00 <quicksilver> temoto: because that's what embedded means.
06:47:09 <quicksilver> embedded means using your host language as syntax.
06:47:14 <quicksilver> DSL doesn't mean that.
06:47:21 <quicksilver> it has its own syntax => you have to parse it.
06:47:40 <doserj> temoto: in general, there is a smooth transition from parser to library, or from DSL to EDSL
06:47:58 <temoto> Aha.
06:48:13 <temoto> So that guy wrote EDSL?
06:49:05 <cognominal> when haskell 6.12 is due? will it include open data types?
06:49:25 <quicksilver> cognominal: I have see no proposal for open data types.
06:49:35 <quicksilver> so I have no reason to imagine they have the slightest chance of being in GHC 6.12
06:50:03 <cognominal> s/haskell/ghc/
06:50:24 <temoto> Open data types?
06:51:03 <RayNbow> quicksilver: what about a DSL with its own syntax that can be embedded in let's say a Java source file through use of an external parse/compilation step?
06:51:28 <RayNbow> how would you classify that?
06:51:42 <cognominal> temoto: see  http://people.cs.uu.nl/andres/OpenDatatypes.pdf
06:51:51 <temoto> cognominal: thanks.
06:52:57 <quicksilver> cognominal: I've not heard any whispers of that being implemented.
06:53:39 <cognominal> what is the place where there is a summary of upcoming 6.12 features?
06:55:05 <quicksilver> I'm not sure there is, really
06:55:09 <quicksilver> occasionally one of the devs makes a post
06:55:15 <quicksilver> and the HCAR reports normally have a status summary
06:55:59 <cognominal> HCAR?
06:56:25 <doserj> http://hackage.haskell.org/trac/ghc/wiki/Status/October08 has some bits, but may be outdated in parts
06:57:16 <byorgey_> @where HCAR
06:57:16 <lambdabot> http://www.haskell.org/communities/
06:57:22 <byorgey_> cognominal: ^^^
06:58:09 <cognominal> byorgey, thx
07:01:11 <kosmikus> cognominal: I don't think open data types will be implemented anytime soon if at all. Basically, someone would just have to do it. But unfortunately it requires a certain familiarity with GHC internals. I unfortunately don't have the time for now.
07:01:31 * edwardk waves hello to himself.
07:02:00 <Workybob> does anyone with experience with ghc api have any idea what might be going on here?
07:02:01 <Workybob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2785
07:02:53 <edwardk> open data types as in ocaml's polymorphic variants?
07:03:11 <edwardk> they interact very very poorly with the existence of type classes
07:03:39 <edwardk> for that matter any kind of width/depth subtyping does
07:03:59 <Saizan_> Workybob: is libGLEW.dylib
07:04:16 <lilac> aren't open data types implementable via constrained existentials?
07:04:20 <Saizan_> Workybob: .. a symlink or a linker script?
07:04:53 <Workybob> Saizan_: it's a symlink to libGLEW.1.5.1.dylib
07:05:09 <Saizan_> so you're not getting the same problem from ghci?
07:05:14 <Workybob> sec
07:05:24 <Workybob> not actually tried running something like this in ghci
07:05:42 <lilac> data OpenDataType = forall a. MemberOfOpenDataType a => ODT a
07:05:55 <Workybob> ah, yes, I am
07:05:59 <Workybob> is there any way round that Saizan_?
07:06:21 <edwardk> yeah, you can do that, but wadlers expression problem kicks in. you have one point of extension, that MemberOfOpenDataType class
07:07:01 <Saizan_> Workybob: not sure, i got problems like these when the lib was a script
07:08:21 <mmorrow_> this picture's pretty cool: http://volcanoes.usgs.gov/avo/dbimages/display/1107822450_3_3.jpg
07:09:01 <mmorrow_> (from 1990)
07:10:41 <cognominal> a cursory reading reading of the paper about open data types shows that everything is donce at compile time. The interest and the real difficulty of open data type is doing it at runtime thru loading plugins extending types. But the cost must be huge.
07:10:49 <cognominal> *done
07:11:18 <trofi^w> :t sequence
07:11:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:11:40 <lilac> isn't the expression problem fundamentally unsolvable, though?
07:12:27 <pejo> edwardk, you can combine type classes and subtyping though, and still get a sane behaviour.
07:12:43 <dons> go benl, http://www.reddit.com/r/programming/comments/86siu/ghc_on_sparc_pinning_threads_to_cores/
07:12:43 <lambdabot> dons: You have 11 new messages. '/msg lambdabot @messages' to read them.
07:12:54 <yitz> mmorrow_: sunrise soon in alaska, but we probably missed the best pics this time.
07:13:05 <pejo> dons, do you have 10+ messages every day you enter irc?
07:13:25 <dons> not new ones
07:13:31 <edwardk> pejo: you can? ;)
07:13:39 <trofi^w> is (liftM2 mplus act1 act2) lazy? if act1/act2 have IO (Maybe a) type?
07:13:44 <pejo> edwardk, O'Haskell did atleast.
07:13:54 <dons> the sparc backend is getting pretty sophisticated.
07:14:05 <dons> i recommend the ghc/opensparc blog if you want to do parallel haskell
07:14:51 <Zao> Is there any current cluster work with Haskell, or is it just single-node concurrency?
07:15:03 <quicksilver> I don't think there is anything recent.
07:15:06 <edwardk> pejo: I like O'Haskell, it has some great ideas in it, but I think its existence cripples the community, because it shows the existing tools are sufficient in some turing-complete sense to implement all the high-falutin ideas of oop. Its like saying you can write monads in prolog.
07:15:27 <quicksilver> edwardk: that sounds like a comment appropriate for OOHaskel
07:15:33 <quicksilver> edwardk: not O'Haskell ?
07:15:37 <edwardk> quicksilver: er you're right
07:15:38 <mmorrow_> yitz: yeah, too bad.
07:16:05 <edwardk> i have  adifferent rant for O'Haskell ;)
07:17:21 <quicksilver> edwardk: EWRONGRANT <segmentation fault>
07:17:49 <edwardk> O'Haskell always bugged me because of how it has to use all sorts of ad-hoc rules for the less-than-most-general types it infers, so I'd hardly hold it up as an example of how type classes and subtyping should interact ;)
07:17:51 <edwardk> hah
07:17:54 <Baughn> "connectTCP :: HostName -> -- ^ The hostname to connect to; may be a DNS name or an IPv4 or v6 address." <-- Why does Haddock give me a parse error on this?
07:18:38 <Saizan_> Baughn: move the arrow on the next line
07:18:50 <pejo> edwardk, my impression is the opposite - it was quite well known where the inference algorithm cut corners, and it did so for usability reasons.
07:19:41 <mmorrow_> , [$bf|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
07:19:43 <lunabot>  "Hello World!\n"
07:20:12 <Baughn> Saizan_: Ah. There we go.
07:20:22 * mmorrow_ thought for a second of trying to say something slightly more amusing, but quickly realized that would take a solid 10+ minutes
07:20:31 <lispy> heh
07:20:34 <emfa> hello, im pretty new to haskell and havnt got a real hold of all the monad buisness yet. I'm doing a simple gui in wxhaskell and need help to create a variable amount of buttons. How do i do?
07:20:47 <edwardk> pejo: fair enough. it just seems to me that the approach used by platforms like MLPolyR seems cleaner for the subtyping, even though they haven't shoehorned typeclasses in
07:21:20 <dons> emfa: in what sense should the number of buttons be variable?
07:21:23 <lispy> emfa: if you're new to monads, a wx gui is a bit much to start with :)  But, if you post some code I'm sure people can offer advice
07:22:07 <emfa> dons: the user should input number of rows and columns
07:22:16 <pejo> edwardk, perhaps. I guess time will tell.
07:23:33 <dons> emfa: ah ok. easy then. do you know how to read command line arguments?
07:23:41 <dons> then use that number  to generate a list of buttons
07:24:07 <dons> > [ show n ++ ": button" | n <- [1 .. 7] ]
07:24:10 <lambdabot>   ["1: button","2: button","3: button","4: button","5: button","6: button","7...
07:24:24 <dons> and loop over the list creating real buttons from them
07:24:43 <emfa> ah k
07:24:48 <emfa> gonna try it out, thanks
07:25:04 <emfa> ill be back hehe
07:25:06 <Saizan_> you'd probably want mapM
07:25:22 <Saizan_> ?type mapM
07:25:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:30:41 <Alpounet> ?type sequence
07:30:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:34:05 <yitz> mmorrow_: it just blew again. maybe we'll get some pics after all.
07:35:50 <wunki> is it a really stupid idea to make a game in Haskell?
07:35:53 <JsutiN> Hmm reading over the Python 3.0 docs, it appears they are moving steadily away from functional idioms.
07:37:24 <Baughn> wunki: Nah. Go right ahead.
07:37:29 <osfameron> wunki: if you're asking, then probably a) no, it'll be interesting and you'll learn a lot and b) you might hurt your brain a little :-)
07:37:38 <osfameron> (at least, that's my experience in trying)
07:37:55 <Baughn> wunki: You will find that parallelizing it is a lot easier in haskell. ;)
07:38:15 <yitz> JsutiN: why do you say that? because of "reduce"? that wasn't very useful to begin with.
07:38:17 <wunki> yeah, but will I need parallization :)
07:38:33 <Baughn> If you don't, then there are no issues at all with using haskell. :P
07:38:43 <Baughn> ..well, except maybe the GC
07:39:00 <wunki> just asked because everyone uses C++
07:39:16 <Baughn> If everone, cliff, etc.
07:39:58 <JsutiN> yitz, They removed "apply", changed the functionality of map and filter to not be composable (based on iterators and views now), etc
07:40:14 <BONUS> actually i tthink python is moving towards functional idioms, because filter and map are now lazy
07:40:17 <JsutiN> yitz, However they did add set and dictionary comprehensions, so that's a plus.
07:40:31 <BONUS> also zip, etc.
07:40:38 <JsutiN> BONUS, that is a good point.
07:40:42 <cognominal> BONUS, arrays will be lazy in Perl 6 too
07:40:42 <BONUS> and dict.items and such
07:40:48 <yitz> JsutiN: apply isn't needed. they have partial function now.
07:40:48 <BONUS> awesome
07:40:48 <wunki> but the important question is: Will I be able to build a nice game in Haskell (without to much effort).. I think you answered "yes"..
07:41:11 <Baughn> wunki: Depends on how you define "too much". It's not harder than C++, but...
07:41:11 <yitz> JsutiN: and as BONUS says, laziness is now easier.
07:41:13 <JsutiN> yitz, perhaps then my analysis was premature. :)
07:41:33 <yitz> JsutiN: however, composability is still as much of a problem as ever.
07:41:45 <JsutiN> I am saddened, however, by guido's comment about Haskell on his twitter.
07:42:12 <JsutiN> yitz, one could argue that composability and modularity are the cornerstones of a functional idiomatic style.
07:42:20 <yitz> the biggest problem is that func arguments are evaluated eagerly even for functional-like tools - most annoyingly itertools.chain
07:42:45 <yitz> JsutiN: you can do it in python. it's just a bit messy sometimes.
07:43:02 <Saizan_> Baughn: i guess for C++ there are more libraries/frameworks easily available?
07:43:06 <yitz> JsutiN: I often write my own version of chain that is lazier.
07:43:25 <Baughn> Saizan_: Ah. That is, admittedly, true.
07:43:39 <wunki> Saizan_: that's true for sure
07:43:58 <JsutiN> yitz, did you propose a PEP?
07:44:09 <BONUS> does chain evaluate all the argument iterators?
07:44:19 <yitz> i suppose map and zip are also a problem, but i don't use those much. after all, it's python, not haskell. :)
07:44:31 <yitz> BONUS: yes, annoyingly
07:44:45 <wunki> I read a paper about a shooter in Haskell, that went pretty well..
07:45:20 <BONUS> ugh whats the point then
07:45:26 <JsutiN> yitz, what about itertools.chain.fromIterable?
07:45:35 <yitz> JsutiN: I'm not sure it's worth a PEP. perhaps a feature request to add lazy_chain to itertools or something.
07:45:36 <JsutiN> err from_iterable
07:46:25 <yitz> BONUS: no, not that bad
07:46:44 <yitz> BONUS: the problem is if you give it an infinite list of iterators
07:46:58 <BONUS> ah, like that
07:47:18 <JsutiN> yitz, I get the impression that itertools.chain.from_iterable will do exactly what you want.
07:47:31 <sebas_> hello all, is there someone who has used the hackage upload function today?
07:47:46 <sebas_> ik keep on getting timeouts while uploading my package
07:48:04 <dons> hmm
07:48:12 <dons> do you get an error message?
07:48:36 <dons> one other user reported this.
07:48:56 <sebas_> I think I am the other user, at least I reported this on the haskell-cafe
07:49:20 <sebas_> I just keep on getting time-outs while uploading. The hackage upload page itself loads fine.
07:49:30 <dons> oh, someone reported it on reddit too
07:49:35 <yitz> JsutiN: could be. truth is, last time I needed that was still in 2.x
07:50:06 <JsutiN> yitz, it's new in 2.6, so it may well have been missing then.
07:50:10 <yitz> dons: is reddit the new hackage bug tracker?
07:50:11 <dons> forwarded to admins
07:50:15 <dons> heh
07:50:19 <dons> no.
07:50:43 <dons> but there's a good article on pinning threads that should get upmods, http://www.reddit.com/r/programming/comments/86swv/ghc_on_sparc_pinning_threads_to_cores/
07:51:18 <sebas_> dons: I think it was me also who reported on reddit, related to the build failures of Salvia webserver.
07:51:19 <yitz> reporting bugs on reddit is kind of like getting dressed outside on the street.
07:51:29 <dons> sebas_: ah ok.
07:51:32 <dons> yitz: yes.
07:51:48 <dons> yitz: but prob. ok  on the haskell reddit
07:53:05 <sebas_> anyway, I'll retry uploading my fixes some time later.
07:53:27 <sebas_> but it feels lame to announce a package and only have a broken version available on hackage
07:55:33 <yitz> dons: sounds like a modest beginning to me. why is it so exciting? maybe post a comment to the reddit.
08:00:01 <dons> well, it's a sequence of months of posts about the sparc
08:01:23 <yitz> hmm, that link gives me just today's post. with some graphs showing only a tiny effect of adding cores.
08:04:08 <rittyan2> is putStrLn lazy? If I do putStrLn in a multithreaded code, output is garbled. If I do putStr (text ++ "\n") it is not.
08:04:39 <rittyan2> maybe putStrLn prints character by character, or something like that.. in a lazy way :)
08:04:45 <pejo> rittyan, sounds like there's buffering involved.
08:04:47 <quicksilver> rittyan2: that has nothing to do with laziness.
08:04:47 <temoto> @src putStrLn
08:04:48 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
08:04:52 <temoto> aha
08:05:02 <rittyan2> oh!
08:05:04 <dons> so you can grab the lock on the handle
08:05:13 <quicksilver> rittyan2: it is simply the case that multithreaded code is free to switch thread between chars if it wants to.
08:05:15 <rittyan2> how to avoid garbled output then?
08:05:19 <dons> don't do multithreaded IO without some buffering
08:05:21 <rittyan2> quicksilver, that's true
08:05:22 <quicksilver> rittyan2: only print from one thread.
08:05:23 <dons> there are packages on hackage for this
08:05:32 <dons> concurrent-output is one package.
08:05:43 <quicksilver> (send messages via a Chan String to a lightweight printer-thread)
08:06:21 <rittyan2> quicksilver, that is a bit hardcore for me now :<
08:06:40 <dons> 5 or 6 lines of code.
08:06:44 <quicksilver> if that
08:06:44 <lilac> looks like in the current implementation it's unlikely for a putStr on a short string to be interrupted part-way through
08:06:59 <rittyan2> true but... it is my 3rd day I am playing with haskell
08:07:03 <quicksilver> if you're threadin, you shouldn't be scared of one more thread
08:07:05 <yitz> lilac: try it
08:07:18 <lilac> which explains why putStrLn  and putStr s; putChar '\n' behave differently in practice
08:08:40 <lilac> yitz: i'm unable to repro rittyan2's results here :)
08:08:52 <rittyan2> dons or quicksilver, can you help me to modify my code to add printing thread? :3
08:08:57 <yitz> lilac: Prelude Control.Concurrent> do forkIO (putStr "hello"); forkIO (putStr "world")
08:09:19 <ejt> rittyan2: hpaste what you've got so far
08:09:20 <yitz> lilac: ThhrweeolarldloIdd 22
08:09:41 <lilac> yitz: well quite
08:09:42 <rittyan2> http://paste.pocoo.org/show/109178/ <- that is my code
08:09:50 <yitz> lilac: The Glorious Glasgow Haskell Compilation System, version 6.10.1
08:09:52 <lilac> yitz: forM_ [1..10] (const . forkIO $ putStrLn "Foo!")
08:10:09 <lilac> yitz: seems to behave the same as forM_ [1..10] (const . forkIO $ putStr "Foo!\n") for me
08:11:28 <lilac> this is obvious in retrospect; it's got to call write() once per character since it doesn't know whether demanding the next char will block
08:11:46 <quicksilver> rittyan2: instead of putStrLn "hello" you do writeChan ch "hello"
08:12:27 <quicksilver> and you forkIO $ chanWriter ch where chanWriter ch = do l <- readChan ch; putStrLn l; chanWriter ch
08:12:57 <rittyan2> wow
08:13:00 <rittyan2> let me try
08:13:16 <rittyan2> quicksilver, does it mean I have to pass 'ch' around to be able to print?
08:13:17 <ejt> rittyan2: you're doing well if you wrote that on your 3rd day
08:13:32 <JsutiN> dons, any estimation of the impact of Real World Haskell on the general coding community yet?  Are we seeing an increase in useful Haskell code being generated?
08:13:35 <rittyan2> ejt, not without help of jedai :)
08:13:43 <rittyan2> ejt, thanks :)
08:15:13 <quicksilver> rittyan2: yes.
08:15:19 <quicksilver> haskell doesn't have global variables.
08:15:21 <quicksilver> thank god for that.
08:15:57 <FunctorSalad_> why are continuations often called 'k'? is this a kde-type thing? ;)
08:16:27 <rittyan2> quicksilver, true
08:18:11 <rittyan2> quicksilver, and how do I create 'ch'? I mean... "ch <- what?"
08:18:16 <quicksilver> FunctorSalad_: I have a feeling some influential writer on the subject was german
08:18:19 <quicksilver> rittyan2: newChan
08:18:55 <FunctorSalad_> quicksilver: hmm... "kontinuierung"? ;)
08:19:25 <yitz> rittyan2: which means that the type signatures of your functions will explicitly indicate if that function intends to mess with the console. and that's a good thing.
08:20:06 <rittyan2> I agree... except that its portability damages that way
08:20:23 <rittyan2> well, if it messes with output it is bad to just copy-and-paste that function... because output is often context-dependant
08:20:30 <rittyan2> so no probs
08:20:56 <rittyan2> http://paste.pocoo.org/show/109181/ <- I don't get it, why do I get syntax error? :|
08:21:33 <yitz> rittyan2: indeed - if you cut and paste, the typechecker will say ok, but this thing messes with the console, and you'll fix it up.
08:21:53 <rittyan2> (I like to write copypastable functions ^^)
08:22:11 <yitz> you cant use where there
08:22:32 <rittyan2> ah, I need to move it lower?
08:22:41 <yitz> right
08:22:41 <ejt> rittyan2: put the where after the mapM
08:25:36 <rittyan2> what type channels have?
08:25:43 <rittyan2> (to write it in into type signature of function)
08:25:48 * RayNbow looks at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2730#a2732 ... it used to be a nice and short function... until all the special cases were considered... :/
08:26:18 <rittyan2> (I think that I need to learn how to use lambdabot afte rall)
08:26:39 <ejt> rittyan2: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:newChan
08:26:44 <ejt> hayoo is great
08:27:09 <mmorrow_> preflex: cdecl struct{ofs i; ofs(*j)[];}O[];
08:27:34 <mmorrow> @seen preflex
08:27:34 <lambdabot> preflex is in #xmonad, #haskell-blah, #haskell and #ghc. I don't know when preflex last spoke.
08:29:41 <yitz> @hoogle chan
08:29:41 <lambdabot> module Control.Concurrent.Chan
08:29:42 <lambdabot> Control.Concurrent.Chan data Chan a
08:29:42 <lambdabot> package change-monger
08:34:33 <rittyan2> quicksilver, I have a problem here... readChan returns IO and putStrLn seems to unexpect it
08:35:31 <quicksilver> rittyan2: indeed.
08:35:47 <quicksilver> rittyan2: which is why the code I wrote said "l <- getChan ch; putStrLn l"
08:36:23 <rittyan2> no it was saying readChan :)
08:36:24 <quicksilver> (that has to be in a do block; in real code you'd ormally use a newline not a semicolon)
08:36:25 <rittyan2> okay let me try
08:36:30 <quicksilver> yeah, readChan :)
08:37:27 <rittyan2> ah!
08:37:53 <quicksilver> you can alternatively avoid naming the intermediate variable l
08:37:55 <quicksilver> and just write
08:38:01 <quicksilver> putStrLn =<< readChan ch
08:38:12 <quicksilver> but I thought the two-statement version might be easier to understand.
08:38:31 <rittyan2> I forgot to pass argument to readChan
08:38:33 <rittyan2> that was my problem
08:38:37 <quicksilver> ah ;)
08:39:26 <rittyan2> yay it works \o/
08:40:22 <rittyan2> thank you
08:40:44 <rittyan2> that is really easy to do if you know how to do it :)
08:43:21 <quicksilver> rittyan2: ain't that the truth.
08:46:43 <dons> JsutiN: a number of serious coders seem to have discovered Haskell through RWH. And hackage continuess to increase its rate of growth (charts available soon). So I imagine it has had an impact
08:50:38 <dons> why don't we have a beautiful cairo-based gui for ghci on windows?
08:50:50 <dons> so my charts draw nicely :)
08:50:55 <dancor> how does parsec magically know to track SourcePos iff the token-type is Char
08:51:01 <JsutiN> dons, that's great news.
08:51:01 <dons> killer app for ghc-on-windows anyone?
08:52:28 <p_l> dons: I'd suggest getting GHC into a shape that doesn't require Cygwin would be a killer app
08:52:43 <rittyan2> what do you suggest as a serialization format that is robust in haskell? cross-language availability is a must
08:52:50 <rittyan2> (json/yaml/protobuff/etc)
08:53:49 <p_l> Sexps? :P
08:53:51 * p_l hides
08:54:11 <dons> rittyan2: hmm.
08:54:15 <dons> cross-language eh?
08:54:27 <dons> well, whatever is popular elsewhere. csv, json, xml, yaml.
08:54:36 <dons> the erlang wire protocol...
08:54:52 <rittyan2> p_l, sexps > * :)
08:55:02 * dancor uses json a lot these days
08:55:10 <michaelcdever> what is json?
08:55:19 <dons> lightweight xml-ish thing
08:55:23 <dancor> http://en.wikipedia.org/wiki/Json
08:55:25 <dons> we've several good libraries for it.
08:55:28 <michaelcdever> ah cool!
08:55:31 <p_l> michaelcdever: JavaScript mutated into data format
08:55:33 <edwardk> dancor: thats because you use a bunch of char combinators that automatically track it
08:55:35 <dons> p_l: i thought ghc was pure mingw now
08:55:58 <p_l> dons: I tried setting up 6.10 + cabal... at some point I gave up
08:56:10 <dancor> @src char
08:56:10 <lambdabot> Source not found. Wrong!  You cheating scum!
08:56:22 <p_l> GHC itself work, but the whole ecosystem doesn't work outside pure haskell libs
08:56:25 <dons> http://hackage.haskell.org/trac/ghc/wiki/Building/Prerequisites#PreparingaWindowssystem
08:56:40 <dancor> edwardk: ah, i see it now
08:56:41 <dons> p_l: sure. usual windows problem: it has no package manager
08:56:54 <edwardk> dancor: check http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Char.html#satisfy
08:56:57 <dancor> yep
08:56:58 <dancor> tx
08:56:58 <dons> p_l: you do not need cygwin.
08:57:00 <edwardk> most of the stuff is built up over that
08:57:01 <p_l> dons: I'd say "usual autoconf problem: we assume we are on linux with bash"
08:57:17 <dons> that too. you need the auto* tools
08:57:18 <p_l> it's not something directly connected to GHC itself
08:57:21 <edwardk> otherwise youre stuck using tokenPrim yourself and tracking source positions
08:57:25 <dons> this is why a binary install is good for crippled systems
08:57:44 <dons> if only we had some windows distro maintainers
08:57:50 <quicksilver> p_l: of course the autotools don't assume they are on linux
08:58:09 <quicksilver> p_l: one of the reasons for the existence of autotools is to be portable over all reasonable systems
08:58:20 <quicksilver> VMS, AIX, Solaris, SunOS, etc.
08:58:22 <jedai> p_l: Using Mingw shell and with the autotools from mingw you can get some things to install even when they're not pure Haskell
08:58:24 <p_l> quicksilver: in theory...
08:58:33 <dons> report any non-portabilities!
08:58:33 <p_l> quicksilver: they don't work on VMS
08:58:41 * quicksilver shrugs
08:58:44 <quicksilver> they certainly don't assume linux
08:58:49 <quicksilver> that's just an absurd thing to say :P
08:58:49 <jedai> p_l: It's not the funniest ride around though :/
08:58:57 <dons> anyone know why there have been 5 books on scala published this year?
08:59:21 <p_l> quicksilver: It's partly my disillusioned, cranky opinion of autotools quality :P
08:59:53 <p_l> quicksilver: otoh, I rarely see a project that doesn't cut&paste the same "sane environment" template that makes me mad
09:00:06 <quicksilver> that's just tool misuse, though.
09:00:15 <quicksilver> although the tool may be so bad it encourages misuse :)
09:00:26 <pejo> quicksilver, the way configure scripts are written often assume bash. I think that stems from /bin/sh not being a real sh.
09:00:30 <quicksilver> what they do assume is a reasonable baseline BSD/SVR stylle un*x.
09:00:41 <p_l> quicksilver: the tool is so bad a simple makefile actually pwns it
09:01:25 <p_l> quicksilver: it's like someone tried to write an AI in m4
09:01:29 <dancor> makeTokenParser gets you from Char to Tokens (of some kind) right?  you still need to actually make your expression parser etc
09:01:46 <dcoutts_> dons: the scala people are the popular publishing types?
09:03:00 <p_l> quicksilver: also, my anger partially steemed from the fact that so many "windows" ports of various things use autoconf/cygwin combo. And no, I don't consider it a good way
09:03:01 <dons> dcoutts_: hmm.
09:03:34 <dons> too busy writing papers, not writing books.
09:03:42 * dons knows that's the tradeoff
09:03:53 <dcoutts_> p_l: there's only a few Hackage packages that need sh.exe etc, and many of those do actually work in MSYS, I've tried
09:04:12 <dcoutts_> dons: right, we write a lot but for a different kind of audience
09:04:35 <dcoutts_> dons: there's probably a good book to be published, post RWH material by collecting things from a bunch of papers
09:04:49 <p_l> dcoutts_: My quest would be complete if I could get a working devsystem _without_ msys...
09:04:49 <dons> HAppsStack: the book
09:04:56 <dons> Writing Correct Software With Haskell
09:04:59 <dcoutts_> dons: nothing new, just different presentation
09:05:02 <bremner> p_l install linux :-)
09:05:03 <dons> Multicore Programming in Haskell
09:05:10 <dons> The Art of Testing
09:05:22 <dcoutts_> p_l: yes, we hope to get there, in the mean time a few packages still use ./configure scripts.
09:05:47 <p_l> bremner: I use linux as my main system
09:06:15 <p_l> bremner: But I understand that possible clients might not want to move everything to linux just for the sake of some apps :)
09:06:40 <bremner> p_l: ahh, clients. yeah, they are a problem :-)
09:07:00 <dons> dcoutts_: remember back in the 90s there were a dozen haskell books
09:07:01 * bremner had clients once. The experience convinced him to go to grad school :-)
09:07:04 <dons> maybe its "new language syndrome"
09:07:13 <dons> its easier to write books about small, new things
09:07:17 <dons> than big confusing things
09:07:21 <p_l> bremner: In the end, frankly speaking, a free CL managed to trump haskell, and that's something rare :P
09:07:59 <dons> p_l: what's the problem? ghc on windows?
09:08:04 <RayNbow> hmm, when will the source documentation be generated for ghc/docs/latest?
09:08:42 <p_l> dons: ghc itself was working fine... I just failed in my quest to setup an environment without POSIX compatibility layers :-)
09:09:06 <dcoutts_> p_l: you mean when you were trying to install random other packages from Hackage ?
09:09:09 <dons> hmm.
09:09:26 <dcoutts_> p_l: it that it or was there something else?
09:09:31 <RayNbow> (currently I keep replacing "latest" in the URL with "6.8.3" manually)
09:09:32 <p_l> dcoutts_: yeah. In the end Igave up the windows side completely
09:09:48 <tomh> dons: is happstack: the book under development?
09:09:57 <dcoutts_> p_l: it's useful to know the real source of the problem so we can target our energies appropriately
09:10:37 <p_l> dcoutts_: I'd have to go again through it, but basically it boiled down to having a build environment not requiring MSYS or Cygwin that would work with Platfrom SDK
09:10:41 <p_l> *Platform
09:11:00 <dcoutts_> p_l: and what was it you were trying to install that needed MSYS etc
09:11:02 <dons> tomh: no, but gee, it should be.
09:11:12 <dons> afaik there are no other haskell books in the works.
09:11:18 <dons> which concerns me
09:11:36 <dcoutts_> p_l: btw, what do you mean about a "Platfrom SDK"
09:11:56 <p_l> dcoutts_: the official dev set for windows (yes, a free download)
09:12:34 <dcoutts_> p_l: oh you mean the set of MS free tools? C compiler, header files etc?
09:12:53 <pejo> dons, going to write another one? :-)
09:13:00 <dons> i need to write my thesis first.
09:13:01 <dons> really.
09:13:02 <tomh> dons: maybe because there is not really a general approach accepted by a large portion of the community about how to develop profession haskell software
09:13:03 <p_l> dcoutts_: Yeah, I was trying to avoid MSYS/Cygwin setting. It means a lot to some people :)
09:13:17 <dons> we should make s^3 write a book on multicore
09:13:50 <dcoutts_> p_l: I've never used those, what's the issue with the Platform SDK then? And yeah, I appreciate the hate for MSYS, we're trying to weed it out too.
09:13:59 <p_l> dcoutts_: If I find time to make another go at setting up a haskell development environment on Windows, I'll report more
09:14:22 <pejo> dons, such a book would be great to have. But it sounds like a nightmare to write considering how fast the field is moving.
09:14:37 <p_l> dcoutts_: Basically, I was trying to force native libs required by hackage packages to use Platform SDK instead of MinGW/MSYS/Cygwin
09:14:38 <dons> timing is everything
09:15:17 <dcoutts_> p_l: you mean like trying it get them to use MS cc.exe instead of gcc.exe ?
09:15:41 <p_l> dcoutts_: as well as weeding autoconf
09:15:48 <dons> ok.... ready guys?
09:15:58 <dons> for the first time ever: hackage popularity statistics!!
09:16:04 <dons> http://www.galois.com/blog/2009/03/23/one-million-haskell-downloads/
09:16:12 <dons> find out if *your* package made the top 100!
09:16:17 <dcoutts_> p_l: that's not going to fly, ghc uses gcc. I bundles a copy. Getting rid of ./configure scripts is much more doable however.
09:16:23 <dcoutts_> I/It
09:17:06 <dcoutts_> p_l: in theory, a dev setup should be just ghc + cabal and no need for MSYS etc. But that means killing off the ./configure scripts in a few packages on Hackage, eg OpenGL, etc
09:17:15 <RayNbow> dons: I'm surprised that xmonad has more downloads than spots #2-4
09:17:16 <p_l> dcoutts_: If I get more time on windows, I'll try again and maybe send some patches. I'd be very interested in getting a haskell environment with platform sdk
09:17:41 <p_l> dcoutts_: the thing is, some of the packages already have support for platform sdk, but cabal calls autotools on them
09:18:40 <dcoutts_> p_l: I'm not sure I really follow. Cabal doesn't call autotools. Some packages call a ./configure script. That needs the unix utils. What else in the platform sdk would packages use?
09:19:53 <p_l> dcoutts_: I mean the package definitions, sorry. Some of the native code they tried to compile already include build definitions for nmake or msbuild
09:20:04 <p_l> but my account is hazy, from few months ago
09:20:28 <dcoutts_> p_l: ok, well yes posting more details some time would be great
09:20:50 <p_l> dcoutts_: The next time I get some bigger effort on Windows, I'll try to take notes
09:21:00 <dcoutts_> great
09:21:05 <Igloo> dons: xmonad depends on X11-extras, right?
09:21:21 <BMeph_> edwardk: ping
09:21:58 <dons> Igloo: used to. back in 07
09:22:01 <dons> then we merged into X11
09:22:07 <Igloo> Ah, OK
09:22:08 <dons> so you're seeing the old xmonad frenzy
09:23:31 <BMeph_> dcoutts, p_l: Also, as long as you're looking at package interaction on windows, I'd look at some tings that seem to use the unix package (for readline, I presume) that will not load on a Windows system. Yi, and lambdabot being the more irritating (to me, anyhow). :)
09:24:01 <dcoutts_> BMeph_: and alex and happy need patching to not use perl
09:25:03 <dons> this definitely deserves upmods: http://www.reddit.com/r/programming/comments/86tu7/one_million_haskell_downloads/
09:25:07 <BMeph_> dcoutts_: Hm, I'll check out the history first, so I only stick my foot in my mouth to the ankle. :)
09:25:42 <dcoutts_> BMeph_: :-)  btw deps on unix package are not for readline
09:26:28 <dcoutts_> BMeph_: but it's interesting to check what they are for. I bet quite a few are for directory things that should be portable.
09:26:44 <BMeph_> dcoutts_: Not generally, but it seems like (from the README notes) if is an issue.
09:27:18 <dcoutts_> dons: you might like to make a properly scaled version of the cabal logo if you want it at that size. The quick browser scaling is pretty poor. We've got an svg of it.
09:28:49 <dcoutts_> dons: similarly the slight scale reduction of the graphs makes then look pretty awful, sadly.
09:28:56 <dons> hit mod-0
09:29:02 <dons> or click on the graphs to zoom
09:29:42 <dcoutts_> dons: yes, I know they link to properly sized ones, but the redittors will not be so forgiving :-)
09:29:58 <dons> ok.
09:30:11 <p_l> as for readline... it would be nice to have some warning about licenses :D
09:30:23 * dons wonders what scale is dcoutts browser zoom
09:30:23 * p_l recalls times readline hijacked projects
09:30:33 <mmorrow> dons: http://addictedtor.free.fr/graphiques/
09:30:42 <mmorrow> R FTW
09:30:54 <mmorrow> e.g.
09:30:55 <mmorrow> http://addictedtor.free.fr/graphiques/RGraphGallery.php?graph=70
09:30:55 <dons> mmorrow: ok ok
09:31:06 <mmorrow> :)
09:31:06 <dons> i'll do a binding to R then
09:31:12 <mmorrow> ooh, yay
09:32:14 <dcoutts_> dons: it's not my browser, the size of the images in the blog page are specified explicitly in the html
09:32:17 <mmorrow> (the code for that example (graph=70) http://addictedtor.free.fr/graphiques/sources/source_70.R)
09:33:02 <dcoutts_> dons: eg src="http://galois.com/~dons/hackage/hackage.png" alt="" width="450" height="340"  when the real size is 749x504. That inevitably means it looks bad when scaled down.
09:33:18 <dons> could you take a screenshot?
09:33:26 <dcoutts_> dons: I'm not complaining on my own behalf, I can click, my point is just if you're advertising to the redditors
09:33:43 <dons> that's fine, i just want to know if you're seeing what i'm seeing
09:34:35 <mmorrow> something like this for hackage would probably rule so hard someone would be injured http://addictedtor.free.fr/graphiques/RGraphGallery.php?graph=148
09:34:58 <mmorrow> (minus those fugly ellipses ;)
09:35:16 <dons> that's nutty
09:35:48 <dcoutts_> dons: http://haskell.org/~duncan/One%20Million%20Haskell%20Downloads.png
09:35:49 <mmorrow> R graphics are sooo sweet.
09:35:58 <dons> dcoutts_: ahaha
09:36:07 <dons> i'm not sure what to do though
09:36:23 <dons> it has to be scaled to a ratio of the (overly narrow) blog column
09:36:25 <dcoutts_> dons: don't resize. Or generate the graphs at two sizes.
09:36:44 <dcoutts_> dons: I know it's more work, but browsers suck at resizing.
09:36:48 <dons> yup
09:36:50 <p_l> make graphs in SVG?
09:37:30 <tomh> anyone here has article access?
09:37:31 <dons> dcoutts_: i'm thinking of regenerating the graphs weekly or monthly
09:37:42 <dcoutts_> dons: great
09:37:49 <dons> but we need ghc stats too
09:38:01 <dons> since presumably the core system is much more popular than 3rd party extras
09:38:18 <RayNbow> tomh: article access?
09:38:29 <tomh> ye to acm etc
09:38:54 <p_l> tomh: not in a uni?
09:39:03 <tomh> yes, but not at the moment
09:39:31 <tomh> i can only access it whenever im in the labs there
09:39:31 * p_l just hijacks univeristy access to online libraries
09:39:48 <tomh> oh wait i can use lynx to get articles i think
09:39:55 <tomh> or maybe an ssh tunel
09:40:10 <dons> dcoutts_: so anything surprising that   stands out in the popularity tables?
09:40:11 <RayNbow> I'd recommend using an SSH tunnel
09:40:17 <quicksilver> tomh: tried google scholar?
09:40:28 <RayNbow> some journal sites use icky javascript
09:40:45 <RayNbow> (like ScienceDirect, iirc)
09:40:52 <tomh> quicksilver: i know which article, but it is on acm :)
09:41:06 <RayNbow> oh, ACM's site is lynx-friendly :p
09:41:07 <quicksilver> the fact it is on acm doesn't mean it isn't on google scholar
09:41:21 <quicksilver> the majority of CS acm articles are also available elsewhere
09:41:26 <quicksilver> and google scholar will show you where.
09:41:36 <tomh> ah that way
09:41:38 <tomh> ye lemme try
09:41:46 <quicksilver> (normally author's homepage, sometimes university tech report download, etc)
09:41:59 <pervonisse> Can I make ghc include files that now are statically linked?
09:42:03 <pervonisse> (and shared)
09:42:25 <RayNbow> quicksilver: sometimes the tech report version differs from the published article version though
09:42:30 <tomh> ye found it good suggestion quicksilver
09:43:01 <quicksilver> RayNbow: true.
09:43:04 <p_l> btw, why not get acm membership? It's not really expensive...
09:43:14 <quicksilver> why should I?
09:43:22 <quicksilver> academic knowledge wants to be free.
09:43:25 <RayNbow> p_l: because using a SSH tunnel is "free" :p
09:43:25 <p_l> quicksilver: that was directed more at tomh
09:43:36 <p_l> RayNbow: Hah, that's my current way, too :D
09:43:37 <quicksilver> if all else fails, email the author
09:43:46 <quicksilver> most authors are absolutely flattered someone wants to read their paper.
09:43:59 <RayNbow> (if we discard the college/university fees for now :p)
09:44:21 <p_l> But I also had seen the other way around, from a journal side :)
09:44:24 <pervonisse> It's linked via a package flag
09:44:52 <pervonisse> but I get an error when I try to runt the compiled file because the lib can't be found in ld_library_path
09:45:08 <RayNbow> quicksilver: sometimes I wish certain books were available for free :p
09:45:16 <p_l> RayNbow: torrent? :P
09:45:24 <vixey> find a liberry
09:45:29 <dcoutts_> dons: looks pretty sane to me
09:45:31 <quicksilver> RayNbow: true. I can't quite explain why I have a different attitude for papers and books.
09:45:42 <quicksilver> RayNbow: yet, they feel qualititatively different to me.
09:45:47 <dons> further down the list got surprising
09:45:49 <vixey> some books are free as PhD thesis
09:45:53 <dons> i.e. rjson is more popular than galois json
09:45:54 <dcoutts_> dons: this "most popular within category is info that should be on hackage, in the new server
09:46:03 <quicksilver> RayNbow: a paper expounds a single idea and the objective of a paper is to share that idea for the greater good.
09:46:09 <dons> yeah, i consider this a first draft for what we'd want to see
09:46:15 <quicksilver> RayNbow: whereas a book is a more polished whole worth paying for.
09:46:24 <quicksilver> RayNbow: I think that's a pretty irrational stance, but there you are.
09:46:51 <dcoutts_> dons: I think for that we probably do not want to list an explicit score or rank unrelated packages. We don't want the competition to be too fierce or people start gaming the stats.
09:47:04 <dcoutts_> dons: I'd also rank on dependencies as well as downloads
09:47:04 <dons> dcoutts_: yes. that's a risk
09:47:11 <dons> we want a little competition, not too much.
09:47:14 <dcoutts_> dons: it needs the right balance
09:47:21 <kadaver> talking about hackage?
09:47:25 <olivierp> hi, does anyone know of problems when using atomicModifyIORef with Typeable values? I suspect that's causing a deadlock in my code
09:47:28 <dons> http://www.galois.com/blog/2009/03/23/one-million-haskell-downloads/ this
09:47:35 <dons> olivierp: hmm. no.
09:47:39 <dcoutts_> dons: to get some competition to encourage quality but without too much upset and cheating
09:47:45 <dons> olivierp: its an interesting idea.
09:47:52 <dons> dcoutts_: yeah. exactly.
09:48:03 <dons> or we have to implement cheat detection
09:48:07 <RayNbow> quicksilver: yeah, I agree that books have more value... but it sucks if you're reading a paper and it cites a book you don't have access to :p
09:48:58 <dcoutts_> dons: you and I know that a small investment in infrastructure can give big improvements by enabling/encouraging many other people to do great stuff, it's a little harder to sell that idea though, eg to the IHG
09:49:01 <RayNbow> http://www.amazon.com/Queueing-Systems-Theory-Leonard-Kleinrock/dp/0471491101 <-- I once read a paper that cited this book for example, and I don't have a strong background (if any at all) in queuing systems :p
09:49:15 <pervonisse> okay, I'm going to rephrase myself
09:49:28 <olivierp> dons: interesting as in plausible?
09:49:34 <dons> dcoutts_: yeah, removing small   bottlenecks, or adding a bit of information to guide behaviour can have huge , positive results
09:49:37 <quicksilver> RayNbow: true.
09:49:41 <dons> olivierp: well, typeable has to call into the runtime
09:49:46 <dons> to look up the type name in a hash
09:49:49 <quicksilver> RayNbow: it sucks when the book isn't a topic you care all that much about
09:49:57 <quicksilver> RayNbow: but you owuld just like to understand this one point.
09:49:59 <dons> i wonder if that isn't valid to do during atomicModify#
09:50:01 <dcoutts_> dons: right, but it tends to be unglamourous work
09:50:22 <dons> if we can make hackage itself a fun project to contribute to
09:50:37 <dcoutts_> dons: I'm proposing something related for GSoC
09:50:58 <pervonisse> I'm compiling a file with ghc and the compilation goes through. (And I'm linking to an external lib, fastcgi, via the package flag). However, when I try to run the ry it says "error while loading shared libraries, cannot open shared object file. no such file or directory"
09:50:58 <quicksilver> it's hard to make infrastructure projects feel fun :(
09:51:00 <dons> good idea. actually, i need to clean up some of those tickets
09:51:06 <dons> to help direct students into good stuff
09:51:11 <dcoutts_> dons: ugg, yes, they're all stale from last year
09:51:27 <quicksilver> dons: you're not in the SOC channel either
09:51:41 * RayNbow is going to check whether his lambda pepperoni pizza is ready...
09:52:53 <Badger> delicious
09:53:04 <olivierp> dons: i'm trying to reproduce it in a tiny testcase, not sure if there's gonna be enough concurrency
09:53:04 <RayNbow> not ready yet
09:53:23 <dons> olivierp: it's vaguely possible, is my thoughts
09:53:25 <RayNbow> the Heater Monad is not fast enough
09:53:26 <dons> but we'd need more info
09:53:47 <olivierp> dons: any idea of a workaround?
09:54:08 <Badger> RayNbow: ...
09:54:09 <dons> don't use atomicModifyIORef, use an MVar
09:54:18 <Badger> what kind of name is Heater for a monad
09:54:45 <tibbe> dons, ping
09:54:51 <RayNbow> Badger: feel free to send in a patch to rename it ;)
09:56:14 <kadaver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/random-shuffle-0.0.2 <- thats a nice surprise
09:56:17 <dons> tibbe: pong
09:56:43 <quicksilver> kadaver: it really would be better if you'd stick to one nickname
09:56:49 <quicksilver> (or obvious variations on a name
09:57:14 <kadaver> i said i changed last night
09:57:21 <edwardk> BMeph: pong
09:57:41 <kadaver> and cadaver is a logic consequence of being killed in a monad
09:57:45 <olivierp> dons: I'm wrapping a library that uses iorefs for (important) performance reasons
09:57:50 <dons> hmm.
09:57:54 <dons> well MVars are fast
09:57:57 <dons> and threadsafe
09:58:01 <Badger> RayNbow: if I could type right I would.
09:58:02 <dons> so you could put the IORef in an MVar
09:58:05 <Badger> probably.
09:58:06 <olivierp> dons: in just a tiny bit of their code (a concurrent list)
09:58:08 <Badger> maybe.
09:58:24 <dons> oh, from the concurrent list paper?
09:58:57 <olivierp> dons: possibly, it's the join library in hackage from sulzmann and lam
09:59:05 <dons> oh, so thats related, yes.
09:59:13 <dons> query haskell-cafe
09:59:45 <olivierp> dons: ok, i'll try to reproduce the bug in a testcase first
10:01:05 <int-e> atomicModifyIORef should not deadlock really. It's a compare-and-swap, and some bookkeeping. Granted, the bookkeeping code takes the storage manager lock on occasion, so I'm not completely sure.
10:01:15 <kadaver> 2,4,6*** Exception: src\System\Random\Shuffle.hs:(52,6)-(55,30): Non-exhaustive patterns in function shuffleTree
10:01:22 <kadaver> i think i fixed thta the last time around
10:01:26 <int-e> (and there may be a live lock, because the compare-and-swap is retried if it fails)
10:01:30 <kadaver> how do i bugfix?
10:01:40 <tibbe> dons: oh meeting, gotta run, ttyl :)
10:01:49 <int-e> (but in that case, *some* thread should make progress anyway.)
10:02:14 * RayNbow is going to execute eatPizza :: Pizza -> IO FullStomach
10:03:03 <int-e> so not a live lock, just starvation, because fairness isn't assured.
10:03:22 * Badger prefers to ignore the O part of that particular IO
10:03:37 <kadaver> is manlio perillo here?
10:03:51 * RayNbow almost choked while laughing...
10:03:51 <olivierp> int-e: well at the moment the program stops with: stackorig: thread blocked indefinitely
10:03:55 <RayNbow> ty Badger :p
10:04:03 <olivierp> int-e: looks like a deadlock
10:04:44 <Badger> anytime.
10:05:31 <dcoutts_> sioraiocht: ping
10:05:49 <dcoutts_> sioraiocht: where is your MSc thesis and how do I cite it properly :-)
10:06:23 <p_l> dcoutts_: request a bibtex file ;-)
10:07:28 <kadaver> how much of a PITA would it be to use a java mp3player from haskell? then id have to start a new jvm process for a song, not to cute?
10:08:28 <quicksilver> depends if the java mp3player has any mechanism to be controled by an external proces
10:08:35 <quicksilver> e.g. commands on stding, or sockets.
10:08:46 <quicksilver> mplayer (which is not java) has a slave mode for this kind of control
10:08:56 <quicksilver> I used it for a kind of proof-of-concept haskell mp3 browser
10:10:02 <p_l> kadaver: unless you really have to use java, use mplayer
10:10:29 <int-e> olivierp: Well I'm certain that atomicModifyIORef doesn't cause this. It doesn't block on the RTS level (which could cause that message) - it can only block between system threads (which the RTS would never notice. It would just hang.)
10:11:39 <olivierp> int-e: hmm. what is it that does block on the RTS level then?
10:14:09 <int-e> olivierp: black holes (i.e. thunks that another thread is currently evaluating), stm actions, exceptions and mvars.
10:14:46 <olivierp> int-e: uh. that's quite a lot to look into
10:17:33 <olivierp> int-e: so, it's not the iorefs. the library i'm wrapping also uses STM, MVars, and a single unsafeIOToSTM call
10:17:55 <olivierp> int-e: and everything works until i introduce Typeable values
10:18:18 <int-e> fun :-/
10:18:22 <olivierp> int-e: the original code has a few basic possible values hardcoded
10:18:45 <olivierp> int-e: so i really need a way to make it accept arbitrary value
10:20:22 <olivierp> int-e: do you think it makes sense for Typeable values to break things?
10:20:45 <olivierp> int-e: i feel like there's an obscure runtime bug under this
10:21:18 <int-e> not really; it uses unsafePerformIO inside, but no MVars, only IORefs in a probably-not-thread-safe way.
10:22:57 <olivierp> int-e: well then if it's not thread safe, it sounds like a bug right? or at least missing documentation
10:29:27 <int-e> olivierp: I think you may get false negatives (values of equal types that can't be casted to one another with Data.Typeable), due to unsafe updates of the hashtable in Data.Typeable. The cause for that is really in Data.HashTable. But unless you use a lot of different types, you're unlikely to actually trigger that problem.
10:30:19 <int-e> dunno. it's hard to say anything substantial without code.
10:32:10 <olivierp> int-e: well that might be the problem then. my Typeable values are method arguments; various method invocations get put into a store; and the library calls my Eq implementation to see if methods match, with potentially many concurrent threads
10:32:39 <olivierp> int-e: i know... but i can't figure out a way to reproduce this in isolation
10:33:49 <olivierp> int-e: and i can't just dump all my code on people
10:36:07 <pervonisse> guys, please, I really need your help! What would be the right way to fix this problem: When I compile my file I'm linking to a package (-package anotherpackage), but when I try to run it it complains that it cannot find a shared object file that belongs to this library
10:36:25 <pervonisse> And I know it has something to do with the LD_LIBRARY_PATH
10:36:35 <pervonisse> but I've heard that you are not suppose to set that explicitly
10:37:05 <Zao> nisse: LD_LIBRARY_PATH indicates additional search paths for the dynamic loader on some platforms.
10:37:06 <olivierp> pervonisse: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:pathtoyourlib ?
10:37:21 <Zao> You may be interesed in -R and -Wl,-rpath=
10:37:33 <Zao> Which are gcc-isms to embed additional rpath entries.
10:37:40 <pervonisse> I see
10:37:43 <pervonisse> thanks
10:37:46 <olivierp> pervonisse
10:37:52 <pervonisse> yea?
10:38:16 <olivierp> actually if it fails only at runtime you do want to change the LD_LIBRARY_PATH variable
10:38:32 <Zao> olivierp: Or embed proper rpaths.
10:38:53 <olivierp> Zao: hmm. I didn't know about that
10:39:16 <Zao> Silly platform dependant things :)
10:41:21 <pervonisse> Zao could you give me a googleable world so I could read upon it a bit more
10:42:43 <olivierp> int-e: how could I get more information about what exactly is causing my deadlock?
10:43:32 <olivierp> int-e: is there some way of getting a dump of threads, or something like that?
10:45:34 <Zao> pervonisse: See man ld  and search for -rpath
10:46:17 <Zao> http://blogs.sun.com/ali/entry/changing_elf_runpaths
10:46:50 <dancor> if i write my own satisfy, the parsec oneOf etc will continue to use the parsec satisfy right
10:46:57 <dancor> they must
10:49:05 <pervonisse> zao thanks
10:50:39 <quicksilver> dancor: yes. haskell has lexical scoping not dynamic.
10:50:53 <quicksilver> dancor: your satisfy is not related to parsec's satisfy.
10:51:59 <bremner> dancor: also the notion of module is relevant
10:54:13 <lilac> is dynamic scoping ever useful?
10:54:26 <vixey> yes
10:56:09 <RayNbow> http://www.reddit.com/r/programming/comments/86o30/a_somewhat_failed_adventure_in_haskell_abstraction/ <-- I'm wondering... would adding an ML-style module system to Haskell conflict with other Haskell features and how hard would it be to implement it?
10:56:36 <vixey> RayNbow: I think it could be done well
10:57:21 * RayNbow is not quite familiar with ML, so I cannot say much about it...
10:59:46 <RayNbow> perhaps I should also add "Learn ML" to my (already overfull) queue :p
11:00:12 <vixey> I don't know
11:00:20 <vixey> Haskell seems enough
11:00:40 <vixey> you can easily hack some ocaml thing if you know haskell
11:00:44 <vixey> for example
11:01:02 <dancor> quicksilver, bremner: if i just want to allow ppl to overload satisfy (to track their custom token type), should i make a typeclass where oneOf etc depend on a changeable satisfy?
11:01:31 <dancor> i'm willing to rewrite oneOf etc once, but want this to be the last time ;)
11:01:47 <RayNbow> vixey: but that probably applies to several other pairs of programming languages too
11:01:49 <jmcarthur> i don't think it would conflict as much as it would overlap
11:01:58 <ski> (lilac : is the reader/environment monad ever useful .. ?)
11:02:43 <lilac> ski: the context is somewhat different; i'm not sure it's necesasrily a valid comparison
11:03:27 <ski> what is the context ?
11:04:14 <pervonisse> this might be impossible to do anything about but it would be nice if whenever I do a "cabal install mypackage" after I've done a previous "cabal install mypackage" (but the first time it failed for some reason like missing lib) then it wouldn't need to recompile EVERYTHING
11:04:36 <int-e> olivierp: I'm not sure. There doesn't seem to be any debugging code in the corresponding place in the RTS, where blocked threads are sent an exception.
11:04:45 <dcoutts_> pervonisse: you mean not have to recompile the whole package?
11:04:52 <int-e> mmm. he left.
11:04:58 <jmcarthur> if it failed due to a missing library then it shouldn't have ever started to compile at all...
11:05:10 <lilac> ski: well, actually, i suppose you have a point :)
11:05:12 <dcoutts_> pervonisse: "EVERYTHING" here presumably does not include dependent packages etc
11:05:27 <lilac> ski: dynamic scoping is somewhat the same as implicit parameters, which is somewhat the same as a reader monad
11:05:48 <lilac> but that seems like a slightly unusual way of viewing it :)
11:05:57 <dcoutts_> pervonisse: as jmcarthur says, ideally we detect missing libs at configure time, so not much work wasted.
11:06:04 <dcoutts_> Cabal-1.6.0.2 does that now
11:06:22 <lilac> ski: in any case, i more meant dynamic scoping all the time (rather than lexical scoping)
11:06:54 <pervonisse> dcoutts ah okay, but in my case it was a "dev" lib that was missing, but you are saying even that could be discovered conf time
11:07:02 <pervonisse> ?
11:07:30 <dcoutts_> pervonisse: A C library, yes. That should now be detected at configure time with Cabal-1.6.0.2
11:08:04 <igel> is it still necessary to declare "Extensions: CPP" in a .cabal file when using #ifdef or can hackage handle that by now?
11:08:23 <dcoutts_> igel: it's always good to declare the extensions your package uses
11:08:52 <igel> well but everything else is declared in the LANGUAGE pragma, right?
11:09:06 <igel> or shall i list it twice?
11:09:10 <dcoutts_> igel: it's good to declare all of them
11:09:10 <ski> (lilac : i think it's generally accepted that "dynamic scoping" as default is usually the wrong choice)
11:09:39 <igel> hmm that's ugly to maintain :(
11:09:39 <dcoutts_> igel: Cabal will do the wrong thing in certain cases if you use CPP but do not say so
11:10:09 <igel> i only remember i declared it, because haddock on hackage didn't work iirc
11:10:14 <dcoutts_> igel: it's like maintaining the build-depends in the .cabal file and also maintaining imports in the sources. Yes a bit of a pain.
11:10:14 <ski> (lilac :  dynamic scoping : environment monad :: mutable variables : state monad )
11:10:27 <ski> (roughly)
11:10:45 <igel> dcoutts_: but CPP is not to be listed as language pragma, right?
11:11:05 <dcoutts_> igel: it can be listed as a language pragma, just like all the others
11:11:05 <RLa> with Parsec how to i check next character without eating it?
11:11:19 <igel> oh ok...
11:11:25 <dcoutts_> igel: it's only slightly special because it's not really a language feature but a pre-processor.
11:11:32 <Gracenotes> RLa: try
11:11:46 <RLa> doesn't try eat when it succeeds?
11:11:50 <igel> so i list everything as language pragma *and* under "Extensions:" in the .cabal?
11:12:01 <Gracenotes> RLa: well, yes.
11:12:32 <RLa> i would like to just check
11:12:34 <dcoutts_> igel: it won't necessarily break if you do not but it is good to do so, in future we may encourage it more strongly using warnings etc
11:12:42 <Gracenotes> I think there are lookahead methods. What's the problem, though? There are probably other ways to structure the parser.
11:12:46 <igel> Rla iirc there's lookAhead
11:12:46 <RLa> it might not make sense but that's what i need
11:13:07 <Gracenotes> @hoogle lookAhead
11:13:08 <lambdabot> Text.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
11:13:08 <lambdabot> Text.ParserCombinators.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
11:13:08 <lambdabot> System.IO hLookAhead :: Handle -> IO Char
11:13:19 <igel> dcoutts_: ok then i'll fix it up
11:13:34 <RLa> igel, thanks, it works
11:13:34 <igel> dcoutts_: but "Extensions:" is the right place?
11:13:41 <igel> RLa: np
11:13:51 <dcoutts_> igel: yep
11:13:57 <igel> ok :)
11:14:06 <igel> thanks
11:15:39 <Philonous> I'm trying to build GHC 6.10.2 RC1 When "Configuring ghc-6.10.1.20090314." cabal-bin complains about missing libraries (base, filepath, haskell98, hpc, template haskell and unix) at boot.stage2. Is there something I can do about that? Did I do something wrong maybe?
11:16:54 * ski considers `lookBefore', for symmetry
11:18:40 <RLa> ski, would that take last character that was just eaten :)
11:18:57 <ski> it would look at it, not take it
11:19:27 <ski> this whole business with looking ahead to me feels distasteful
11:20:01 <RLa> it's the business of making the parser efficient :)
11:20:10 <ski> maybe i'm misguided, but i think parsing should be a more symmetric business .. at least in semantics
11:20:48 <Gracenotes> d-_dX.Xb_-b
11:20:57 <ski> (i have no problem with having the operational semantics being assymetric, left-to-right)
11:23:03 <igel> yay, uploaded :)
11:25:00 <lilac> ski: i like the idea of a 'start anywhere, work in both directions' parser
11:25:09 <lilac> especially if it has monoidal structure
11:25:31 <lilac> combined with a fingertree it'd make for an ideal representation for use in a text editor's syntax highlighter
11:26:00 <ski> well, the simplest would be to start in both ends
11:26:33 <ski> starting anywhere requires either arbitrarily choosing some nonterminal to use in the middle
11:26:46 <lilac> i'd imagine that in most languages, you'd have ambiguity almost everywhere (comment versus code for a start)
11:26:48 <ski> or doing bottom-up-parsing, based on the tokens seen locally
11:28:08 <vixey> put some restriction like every token has a neighbourhood locally homeomophic to algol
11:28:22 <lilac> ski: why does your starting point need to be a nonterminal?
11:28:25 * ski grins
11:28:47 <lilac> ah, i see what you're saying now
11:29:01 <ski> well, rather a point in a clause between two terminal/nonterminals, i suppose
11:29:17 <lilac> well, a bottom-up method was what i had in mind anyway :)
11:29:33 <ski> obviously, that doesn't sound practical, so bottom-up would be what's left, in that case
11:29:37 <ehird> Is there a function that's (/) or div depending on the arguments types? In a typeclass somewhere.
11:29:41 <lilac> although i think the other way would work fine in a language like python
11:30:05 <lilac> ehird: that sounds ugly. you have generic code which wants those semantics?
11:30:15 <ehird> lilac: yep.
11:30:30 <lilac> interesting. what's the use case, if you don't mind my nosiness?
11:31:38 <lilac> @hoogle (Num a, Num b) => a -> b
11:31:39 <lambdabot> Prelude abs :: Num a => a -> a
11:31:39 <lambdabot> Prelude negate :: Num a => a -> a
11:31:39 <lambdabot> Prelude signum :: Num a => a -> a
11:31:47 <ehird> lilac: well, I'm mostly toying about but it's a case where you basically want 'the best possible division'
11:32:00 <ehird> it's a `mean` that works on both floatings and integrals
11:32:38 <lilac> are you ok with integer divisions being done as floating-point ones then rounded?
11:32:51 <ehird> Sure.
11:33:21 * ski . o O ( a * b =< c  <=>  a =< c / b )
11:35:14 <lilac> hmm. there doesn't appear to be a nice way to do 'maybeRound :: (RealFrac a, Num b) => a -> b' either
11:35:45 <lilac> probably because it would violate parametricity ;-)
11:40:39 <bavardage> how should I type an n-choose-r function+?
11:40:45 <bavardage> since it will take and return only integers
11:41:00 <bavardage> but since there is a division in there, ghci complains
11:41:31 <ski> > 35 `div` 7
11:41:32 <lambdabot>   5
11:41:49 <bavardage> oh kk :D
11:42:23 <kadaver> > catMaybe [Just 5,Nothing]
11:42:24 <lambdabot>   Not in scope: `catMaybe'
11:42:38 <kadaver> > Data.Maybe.catMaybe [Just 5,Nothing]
11:42:39 <lambdabot>   Not in scope: `Data.Maybe.catMaybe'
11:42:58 <ski> > 36 `div` 7
11:42:59 <lambdabot>   5
11:43:01 <ski> > 37 `div` 7
11:43:02 <lambdabot>   5
11:43:07 <ski> > 41 `div` 7
11:43:08 <lambdabot>   5
11:43:09 <ski> > 43 `div` 7
11:43:10 <lambdabot>   6
11:43:18 <kadaver> > randomRIO (0::Int,5)
11:43:20 <lambdabot>   * Exception: "<IO Int>"
11:43:37 <jedai> > catMaybes [Just 5,Nothing]
11:43:38 <lambdabot>   [5]
11:43:55 <kadaver> @type maybe
11:43:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:44:04 <ski> > randomR (0 :: Int,5) (mkStdGen 42)
11:44:06 <lambdabot>   (5,1720602 40692)
11:44:49 <quicksilver> conal: do you add a Monoid a => Monoid (Behaviour a) instance?
11:44:54 <kadaver> maybe (\x -> case x of Just y -> y) (Just 5)
11:44:57 <quicksilver> conal: or if not, has it ever occurred to you to do so?
11:45:02 <kadaver> > maybe (\x -> case x of Just y -> y) (Just 5)
11:45:04 <lambdabot>   Couldn't match expected type `a -> Maybe t -> t'
11:45:21 <conal> quicksilver: sounds familiar.  i think it's there.
11:45:26 <ski> > maybe "It's dead, Jim" show (Just 5)
11:45:27 <lambdabot>   "5"
11:45:33 <ski> > maybe "It's dead, Jim" show Nothing
11:45:34 <lambdabot>   "It's dead, Jim"
11:45:49 <conal> quicksilver: there's a definition that works for all applicative functors.
11:46:21 <quicksilver> conal: mempty = liftA mempty; mappend = liftA2 mappend, I presume
11:46:24 <jmcarthur> pure empty; liftA2 mappend; (modulo newtype wrapping)
11:46:30 <conal> yeah
11:46:39 <quicksilver> conal: but in the case of certain applicatives it might make sense to use some structure of the functor
11:46:45 <quicksilver> instead of a structure in the base type
11:46:54 <quicksilver> always a consideration for these kinds of 'lifted' instance
11:47:00 <conal> quicksilver: right.  there are often those two choices for Monoid.
11:47:38 <quicksilver> conal: I'm just finishing off a tech demo of a 'Geometry2D' style combinator set one might use with reactive.
11:47:46 <conal> e.g., function makes one choice and list makes another.
11:47:53 <quicksilver> conal: will post to reactive list this week I hope.
11:48:01 <conal> quicksilver: cool.
11:48:06 <conal> quicksilver: does it have a semantics?
11:48:22 <quicksilver> obligatory screenshot : http://roobarb.jellybean.co.uk/~jules/Picture%205.png
11:48:42 <conal> ooh.  pretty!
11:48:56 <anyfoo> oh my god, it's full of... err... lines
11:49:00 <quicksilver> I know you've always wanted a 'pieChart' combinator for those powerpoint-style presentations :)
11:49:16 * gnuvince feels like going to Woodstock all of a sudden...
11:49:20 <mak__> hi, is there any way to use a (Int,Int) with IOUArray?
11:49:32 <quicksilver> conal: it's pretty simple geometrically
11:49:38 <quicksilver> I don't see a semantic problem.
11:49:55 <pervonisse> I currently have an old version of ghc installed (via apt-get, ubuntu). What is the easiest way to upgrade? (The newest version isn't in the apt-get repos)
11:50:48 <conal> quicksilver: let me try again: do you have a semantic model in mind for your Geometry2D type?  and corresponding meanings for the combinators?
11:51:37 <conal> quicksilver: i'm not saying you should.  it's just the first thing i always wonder about a new type.
11:51:58 <lilac> > let fixFrom x f = let fx = f (fx `lub` x) in fx in fixFrom (2:undefined) (\(x:xs) -> x:x:xs)
11:51:59 <lambdabot>   Not in scope: `lub'
11:52:18 <conal> quicksilver: when there is a semantic model, it gives me a basis for thinking about the type.
11:53:23 <kadaver> is Henrik Nilsson well known for his func reactive programming?
11:55:37 <kadaver> Type classes, at least Haskell-style dictionary-passing global-instancing type classes, are broken by design. <- what does he mean?
11:56:10 <conal> kadaver: context?
11:57:00 <kadaver> http://www.reddit.com/r/programming/comments/86ol2/comparing_objective_caml_and_standard_ml/
11:57:08 <maltem> mak__: you can use a (IOUArray Int, IOUArray Int) anyways
11:58:42 <conal> kadaver: i thing the writer is saying that one cannot choose among instances and compose the desired ones.
11:59:46 <conal> kadaver: sometimes there's more than one useful instance for a given class & type.  haskell (nearly) forces you to pick at most one.
12:00:31 <bavardage> can I limit the class of the type variable (does that even make sense? extreme haskell newbie)
12:00:42 <edwardk> one of my major problems with haskell is that i _have_ to use newtypes for instance selection
12:01:09 <bavardage> data Distribution a = Binomial (Integer, a) | Poisson (a) deriving Show <--- I want to limit 'a' to a Fractional class
12:01:18 <vixey> bavardage: there's no point really
12:01:22 <edwardk> but they are so useful in general that its hard to complain
12:01:31 <vixey> type inference will realize that you have Fractional
12:01:47 <edwardk> a better module system just replaces them with plumbing problems
12:01:49 <bavardage> vixey: but I'd like it to moan if I try and make a Poisson distribution with a string parameter..
12:01:58 <bavardage> but if it's not possible
12:02:01 <vixey> bavardage: wh ?
12:02:03 <vixey> bavardage: why?
12:02:10 <bavardage> because that'd be silly :D
12:02:18 <ski> (bavardage : and `Bernoulli' ?)
12:02:22 <edwardk> bavardage: you can create one with a string parameter, you just can't pass it to any interesting functions ;)
12:02:28 <bavardage> oh kk :P
12:02:42 <bavardage> so in the functions, I have to specify how?
12:02:54 <edwardk> yeah, something like
12:03:13 <bavardage> foobar :: (Fractional a) => (Poisson a) => a ??
12:03:17 <edwardk> foo :: Fractional a => a -> a -> Distribution a
12:03:38 <vixey> bavardage: If you have f1 that uses a string version and f2 that uses a fractional version
12:03:40 <edwardk> or viceversa, Poisson there was a constructor, not a type
12:03:48 <vixey> bavardage: trying to use f1 and then f2 on the same object will give an error
12:03:59 <bavardage> edwardk: oh kk ty
12:04:03 <bavardage> vixey: thanks
12:04:07 <edwardk> personally i don't like the data Distribution a = Binomial a | Poisson a
12:04:09 <vixey> dunno why you are thanking me
12:04:15 <bavardage> edwardk: what would be better?
12:04:20 <vixey> I'm trying to pursuade you that what you're doing is pointless
12:04:27 <bavardage> vixey: and that's helpful :D
12:04:34 <bavardage> rather than letting me go off onto the wrong track
12:04:41 <vixey> doesn't seem to be working though
12:04:56 <emfa> how do I create an attribute in wxhaskell? need to put some info in a button.
12:05:08 <edwardk> i'd make a class Distribution f where you have generic implementation of the quantile/pdf/etc functions, and then make instances of that class for Poison, Binomial, etc.
12:05:08 <bavardage> vixey: nono, I see, I just enforce the types in the functions
12:05:12 <edwardk> er Poisson
12:05:20 <bavardage> oh kk
12:05:23 <bavardage> I started doing taht
12:05:27 <bavardage> and then thought aaah
12:05:33 <bavardage> kk
12:05:42 <bavardage> I'll have a go that way
12:05:48 <edwardk> the problem with making one ADT is you can't enforce that your function only takes a Poisson distribution
12:06:04 <edwardk> and you wind up with a 'closed world' where its hard to add distributions
12:06:12 <bavardage> point :D
12:06:49 <edwardk> you can arbitrarily make up a data AnyDistributionOf a = forall a. Distribution f => Any (f a)
12:07:03 <edwardk> and reclaim the ability to pass an arbitrary distribution of a value of type a around later
12:07:23 <kadaver> what si a short-function for do nothing ? ie (\x -> x).
12:07:30 <edwardk> @type id
12:07:31 <lambdabot> forall a. a -> a
12:07:36 <edwardk> > id 2
12:07:38 <lambdabot>   2
12:07:43 <omnihil> @type ()
12:07:44 <lambdabot> ()
12:07:52 <bavardage> edwardk: riight :P
12:08:12 <vixey> bavardage: if you have *A* concrete fractional and poisson type such as Quu
12:08:30 <vixey> then use: data Distribution = Binomial (Integer, Quu) | Poisson Quu
12:08:43 <bavardage> but if I were to do a class based approach
12:08:45 <bavardage> instead
12:08:51 <bavardage> class Distribution where ...
12:08:59 <vixey> that doesn't make sense
12:09:06 <vixey> classes are totally different from types
12:09:12 <bavardage> :(
12:09:22 <bavardage> maybe I need to go read some more first :P
12:10:18 <Valodim> if you have an oop background, classes are basically interfaces for types
12:10:30 <bavardage> yup
12:10:34 <bavardage> so I want a class then really
12:10:37 <bavardage> for a generic distribution
12:10:51 <bavardage> saying: "A distribution must have a variance and a mean
12:10:53 <vixey> what do you mean generic
12:10:57 <vixey> oh right
12:10:58 <emfa> how do I create an attribute in wxhaskell? need to put some info in a button.
12:11:02 <bavardage> would that be correct
12:11:06 <Valodim> the class is the interface definition, the implementation is the instance for the type
12:11:17 <edwardk> class Distribution f where quantile :: Fractional a => f a -> Probability -> a; ..
12:11:36 <cocon> hi
12:11:47 <bavardage> http://paste.pocoo.org/show/109214/
12:11:51 <cocon> How can I write a function "nmap" that does the following:
12:11:53 <cocon> nmap f [ [a0,a1,a2], [b0,b1,b2], [c0,c1,c2] ] = [ f [a0,b0,c0], f [a1,b1,c1], f [a2,b2,c2] ]
12:11:54 <edwardk> then your functor f encapulates the hyperparameters of the distribution
12:12:10 <bavardage> oh kk, I should limit the types probably too
12:12:15 <edwardk> and you make an instance of Distribution for it
12:12:18 <vixey> cocon: Don't think about mapping just yet
12:12:18 <bavardage> yup
12:12:35 <cocon> vixey: sorry?
12:12:39 <Valodim> isn't that basically just map?
12:12:42 <edwardk> instance Distribution Binomial where quantile (Binomial x y) prob = ...
12:12:43 <vixey> cocon: first solve:  [ [a0,a1,a2], [b0,b1,b2], [c0,c1,c2] ] |--> [ [a0,b0,c0], [a1,b1,c1], [a2,b2,c2] ]
12:13:09 <bavardage> edwardk: oooh I see :P
12:13:15 <bavardage> I think
12:13:23 <cocon> vixey: yes. just wondering if there's an elegant (short) way of doing it
12:13:28 <edwardk> it'll get more complicated because you'll want to have distinct Distribution classes for continuous and discrete distributions
12:13:39 <bavardage> yeah I thought I'd just start with Discreet
12:13:40 <bavardage> to have a play
12:13:41 <vixey> cocon: Well have you solved it?
12:13:52 <cocon> :)
12:14:05 <vixey> I take that as "no just give me the solution"
12:14:06 <LeoD> what do you mean by solving here? :o
12:14:18 <vixey> LeoD:  "first solve:  [ [a0,a1,a2], [b0,b1,b2], [c0,c1,c2] ] |--> [ [a0,b0,c0], [a1,b1,c1], [a2,b2,c2] ]"
12:14:19 <lilac> > transpose [[a,b,c],[d,e,f],[g,h,i]] :: [[Expr]]
12:14:20 <lambdabot>   [[a,d,g],[b,e,h],[c,f,i]]
12:14:20 <cocon> ok ok, I'll be back with a solution
12:14:22 <vixey> produce some kind of function that does it
12:14:24 <edwardk> i might still have some statistics code lying around from a bayes-using-gibbs-sampling monad i was playing with a couple years back
12:14:29 <LeoD> vixey: ahh :)
12:14:42 * lilac callously gives away the ending
12:14:42 <cocon> oh, there we are!!
12:14:50 <desp> I'm writing a DFS that given a tree, outputs the preorder and postorder of all nodes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2793#a2793
12:14:52 <cocon> lilac: thanks
12:15:01 <lilac> > map f $ transpose [[a,b,c],[d,e,f],[g,h,i]] :: [Expr]
12:15:03 <lambdabot>   [f [a,d,g],f [b,e,h],f [c,f,i]]
12:15:10 <desp> Is this a good way to write it?  Should I write in a tail-recursive accumulating style in Haskell?
12:15:15 <desp> Any comments?
12:15:31 <vixey> desp: absolutely not
12:15:55 <edwardk> vixey: ??
12:15:57 <desp> vixey: ?
12:16:18 <vixey> it's not DFS if you use tail recursion and accumulator
12:16:31 <desp> Uh.
12:16:55 <roconnor> what is a DFS?
12:17:04 <desp> Depth-first search.
12:17:40 <edwardk> anyways aside from the pedantic nature of if its what the assignment wants, yes, its a good idea to use explicit accumulators like that
12:18:20 <desp> edwardk: that's how I would write in OCaml, but the laziness is still confusing me.
12:18:21 <bavardage> oh fun, I can't multiple Integers by rationals :(
12:18:31 <Fredrik> @pl (\x -> (x, inverse x a))
12:18:31 <lambdabot> ap (,) (flip inverse a)
12:18:37 <vixey> multiply rationals by rationals
12:18:38 <desp> edwardk: I mean, the default fold isn't tail-recursive, you have to use foldl' for that, now?
12:18:42 <Fredrik> :t ap
12:18:42 <desp> s/now/no/
12:18:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:18:50 <vixey> :t (%1) :: Integer -> Rational
12:18:52 <lambdabot> Integer -> Rational
12:19:14 <roconnor> desp: in Haskell, guarded co-recursion is the way to go, rather than tail recursion
12:19:29 <desp> roconnor: could you point me to an example?
12:19:38 <edwardk> desp: the key consideration is that in a lazy setting often you don't want it to be. foldr can often do a lot less work
12:19:38 <roconnor> ya
12:20:02 <desp> edwardk: that's what confuses me.  But if I do need all the work, then tail recursion should be fine, no?
12:20:26 <vixey> desp: "tail recursion" isn't relevant to whether a bit of code is good or not in haskell
12:20:32 <roconnor> desp: http://www.reddit.com/comments/6as3z/a_first_haskell_experience/c03cgjs
12:20:46 <desp> vixey: sorry, but I don't think you're qualified to answer.
12:20:56 <desp> roconnor: thank you.
12:21:22 <edwardk> desp: actually she's right, that said, its a good heuristic
12:21:35 <vixey> desp: Sent you a PM
12:22:34 <roconnor> vixey: don't you find foldr to generally be better than foldl?
12:23:32 <vixey> roconnor: yes --I use that more often. I don't think they have any relation other than the name has 'fold' in it though
12:23:47 <bavardage> edwardk: bleh I'm lost
12:23:55 <bavardage> edwardk: http://paste.pocoo.org/show/109216/ how screwed up is that :P?
12:24:40 <edwardk> right now your tye for distribution means that you can ask for the mean of your distribution as being a value of any type ;)
12:24:52 <bavardage> right
12:24:56 <bavardage> so how do I enforce this..
12:25:02 <edwardk> data Binomial a = Binomial Integer a
12:25:16 <bavardage> right
12:25:17 <edwardk> class Distribution f where mean :: Fractional a => f a -> a
12:25:24 <roconnor> @src foldl
12:25:24 <lambdabot> foldl f z []     = z
12:25:24 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:26:01 <edwardk> instance Distribution Binomial where mean (Binomial n p) = fromInteger n * p
12:26:16 <roconnor> vixey: there are many times when the same functionality can be written with both foldl or a foldr
12:26:24 <bavardage> edwardk: and what should I do about the multiplication issue
12:26:25 <Fredrik> @src nubBy
12:26:26 <lambdabot> nubBy eq []             =  []
12:26:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
12:26:35 <edwardk> @type fromInteger
12:26:36 <lambdabot> forall a. (Num a) => Integer -> a
12:26:37 <bavardage> edwardk: since I can't multiple an integer by a rational
12:26:45 <bavardage> right
12:27:10 <edwardk> sold?
12:27:35 <bavardage> wow it works :P
12:27:37 <bavardage> hehehe
12:27:37 <kadaver> http://en.wikipedia.org/wiki/Lazarus_Long <- did Heinlein dig men in kilts?
12:27:46 <bavardage> mean (Binomial(n,p)) = n'*p where n' = fromInteger n so like this?
12:27:51 <edwardk> notice that that Binomial i just gave doesn't care that its even Rational, you can use it with Double, Float, any other fractional, etc.
12:27:59 <edwardk> thats fine
12:28:01 <cocon> how to best convert Int to Double? (fromInteger . toInteger) ?
12:28:13 <vixey> roconnor: I can only think of two, symmetric operator reducing a list into a single value & expressing each in terms of the other (+ partially applied versions of that which look decent on both sides)
12:28:21 <ziman> @src fromIntegral
12:28:22 <lambdabot> fromIntegral = fromInteger . toInteger
12:28:25 <edwardk> also, if you are going to use the (n,p) style at least make it a newtype rather than a data, otherwise you ave two bottoms in the type
12:28:29 <cocon> thanks, ziman
12:28:41 <bavardage> edwardk: thanks.. think I'm starting to get this now :D
12:28:41 <bavardage> hehe
12:28:46 <bavardage> eventually I will see the light
12:29:01 <edwardk> bavardage: its tricky getting started, it'll eventually all click
12:29:38 <roconnor> vixey: we were examining the definition of (\\) last night
12:29:42 <desp> I would like to publicly apologize for offending vixey.
12:29:47 <roconnor> @src (\\)
12:29:47 <lambdabot> (\\) = foldl (flip delete)
12:29:56 <vixey> desp you didn't offend me :p
12:30:01 <vixey> don't worry
12:30:11 <roconnor> vixey: so foldr delete vs foldr (flip delete).
12:30:28 <roconnor> vixey: (I also find it interesting that delete isn't symmetric)
12:30:36 <Gracenotes> o nos? ;x;
12:31:54 <kadaver> p_l: just because physical laws can be computed by a Turing-machine it doesn't mean that the brain is a Turing-machine. we can't compute all of them at the same time because then that computer would be the universe
12:31:54 <kadaver> yay for fuzzy thinking on my behalf
12:31:55 <bavardage> edwardk: yeah.. it's trying to unlearn lots of imperative duck-typed language :P
12:32:37 <pervonisse> I suppose no one here knows what might be wrong; I get the error "FCGX_Accept failed with the error code: -88" when I try to run a file I've compiled (which uses fastcgi)
12:33:31 <p_l> kadaver: turing machine is a quite limited computer... and brain isn't that much advanced
12:33:40 <Fredrik> @pl \x y -> gcd x y > 1
12:33:41 <lambdabot> flip flip 1 . ((>) .) . gcd
12:34:04 <Fredrik> @pl \x y -> gcd y x > 1
12:34:05 <lambdabot> flip flip 1 . ((>) .) . flip gcd
12:36:54 <roconnor> kadaver: I'm pretty sure than an ideal human plus as infinite reams of paper can implement universal computation.
12:37:32 <roconnor> kadaver: a friend of a friend implemented universal computation with a kindergarden class, a ball, and several toy letter blocks.
12:37:37 <roconnor> kadaver: they thought it was a game
12:38:02 <ziman> :D
12:38:21 <jedai> roconnor: The future of computation : kindergarten super computers !
12:38:37 <vixey> desp, here this may help you understand my point of view
12:38:42 <vixey> desp: http://rafb.net/p/cVvfMi84.html
12:39:02 <vixey> compare:  dfs bohm []  against  notDfs bohm const
12:43:07 <pervonisse> hmm. I'm not sure where I should ask for help about this. (I'm having trouble with haskell + fastcgi)
12:43:11 <Fredrik> @pl \x y -> x `mod` y == 0
12:43:11 <lambdabot> flip flip 0 . ((==) .) . mod
12:44:25 <desp> vixey: I didn't have infinite structures in mind.
12:44:45 <vixey> desp: one of the comment is pointing out that this isn't just about infinite objects
12:45:00 <Gracenotes> @pl \x y -> 0 == x `mod` y
12:45:01 <lambdabot> ((0 ==) .) . mod
12:45:57 <desp> vixey: I do see the comment, I don't see its significance, though.  Are you saying that an iterative DFS is not a true DFS?
12:46:21 <vixey> desp, in any case the code clearly illustrates that notDfs is /not/ going depth first
12:47:00 <conal> vixey: you can simplify your algorithm by picking a different list representation, e.g., Data.DList
12:47:00 <vixey> desp, I am only talking about Haskell (lazyness) though
12:47:14 <vixey> conal: which one ?
12:47:20 <conal> dfs
12:47:30 <conal> vixey: and i speculate notDfs also.
12:47:34 <Gracenotes> one can imperatively DFS with a stacks and backtracking ...
12:47:48 <desp> That would be my opinion as well.
12:48:03 <desp> And, hence, it's possible to write a tail-recursive DFS that actually does traverse in the usual order.
12:48:26 <desp> I'm not too familiar with continuation-passing style, so I'm still digesting that code.
12:48:45 <vixey> desp: You have a different way to implement 'tail recursive dfs' in haskell?
12:48:46 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2795#a2796 <- the first type is correct but i want something liek the second one. hwo can I ? the inut is: sumOn fst  [(Just 5,Nothing),(Just 4,Just 2)] -> 9
12:48:52 <conal> you could derive definitions for singleton and for ++ from those two definitions.
12:49:11 <vixey> Gracenotes: yeah basic prolog interp. you can do that in a strict language naturally or with some awkwardness (or omissions and a monad) haskell
12:49:25 <conal> and replace both definitions with identical, simpler code in terms of singleton and ++
12:49:38 <Gracenotes> yeah. But the iteration doesn't lend itself naturally to tail recursion reformulation, I don't think
12:50:02 <kadaver> sumOn :: (a -> Maybe Int) -> [a] -> Int is good enoguh perhaps
12:50:12 <EvilTerran> kadaver, the un-commented-out type signature's a specialisation of the commented-out one, as far as i can tell
12:50:32 <vixey> conal: :t singleton -- ?
12:50:48 <conal> vixey: a -> List a
12:50:53 <vixey> hm
12:51:04 <EvilTerran> kadaver, oh, i see, (Maybe Int, Maybe Int) as the passed-in function's parameter, while the list's [Maybe Int]
12:51:05 <conal> vixey: where you vary the List representation
12:51:33 <vixey> conal, I used (a la Cale) ++ for mappend, but that works too
12:52:11 <conal> vixey: great.  then you can use ++ without overloading.
12:52:19 <conal> vixey: i mean without redefining.
12:52:27 <vixey> ok thanks :)
12:52:42 <PeakerWork> kadaver: sumOn :: Num a => ((Maybe a, Maybe a) -> Maybe a) -> [Maybe a] -> a  ?
12:52:55 <conal> :)
12:53:25 <PeakerWork> kadaver: could be nice to curry that: Num a => (Maybe a -> Maybe a -> Maybe a) -> [Maybe a] -> a
12:54:03 <EvilTerran> PeakerWork, but why is the passed-in function taking two values?
12:54:11 <vixey> @hoogle [Maybe a] -> [a]
12:54:11 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:54:11 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
12:54:11 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:54:30 <PeakerWork> EvilTerran: oh, I'm not sure :)
12:55:29 <kadaver> it takes fst or snd as first arg
12:56:08 <EvilTerran> kadaver, but the list isn't made up of pairs, it's made of (Maybe Int)s...
12:56:52 <desp> vixey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2797#a2797 ?
12:57:13 <bavardage> how do I define 'default' functions for classes?
12:57:26 <PeakerWork> bavardage: just specify an implementation next to a type signature of a method
12:57:32 <bavardage> riight
12:57:46 <bavardage> I'll pastebin a sec, I'm having problems with the types again :D
12:58:28 <bavardage> oh wait
12:58:30 <bavardage> I think it worked
12:58:37 <desp> vixey: takes a [Tree a], of course.
12:58:56 <bavardage> yahoo :D
12:59:13 <desp> vixey: I am unable to run your "notDfs", btw
12:59:21 <vixey> why can't you run it
12:59:42 <desp> You said to use "notDfs bohm const", yes?
12:59:54 <ehird> How can I build ghc without installing a binary distribution? i.e., making it use the binary ghc inplace
13:01:36 <kadaver> ahsumOn :: ((Maybe Int, Maybe Int) -> Maybe Int) ->
13:01:36 <kadaver>          [(Maybe Int, Maybe Int)] -> Int
13:01:39 <kadaver> im stoopid
13:01:54 <desp> vixey: I need to go.  Please PM me if you find that my function is not a DFS or not tail-recursive.
13:02:13 <PeakerWork> kadaver: you can also use   ghc -Wall    and not specify the type signatures and it will infer them for you
13:02:23 <PeakerWork> (sometimes it will miss class contexts, there's a ghc bug)
13:03:28 <kadaver> Peakrwork: you mean it will annotatemy file? i know i dotn have to explicitly state them
13:04:06 <PeakerWork> kadaver: it will give you warnings with the types that you can copy manually into your file
13:04:47 <kadaver> or i can just use ghci like i always do and the compiel when im happy with the program :)
13:04:50 <iwannalog> hi, i'm trying to install xmonad with cabal and i got an error
13:05:10 <kadaver> i was mostly trying to find a better signature since waht ghci infers soemtimes is to general or not as readable
13:07:00 <PeakerWork> kadaver: why is it "too general"?
13:07:05 <PeakerWork> kadaver: what's wrong with generality? :)
13:07:30 <kadaver> i mean not explicit
13:07:52 <conal> kadaver: ghci is your friend.  it's telling you that your idea is bigger than you realized.
13:08:23 <ehird> conal++
13:08:32 <conal> ehird: thx!
13:08:34 <zakwilson> I'm looking to parse some log files and stick a gig or two (maybe more) of data somewhere that allows fast querying. Tokyo Tyrant looks like it might be a good choice. Any suggestions?
13:11:14 <bavardage> bleh
13:11:26 <bavardage> any advice on how to implement the cdf for a poisson
13:11:41 <bavardage> http://paste.pocoo.org/show/109228/ in here
13:12:21 <iwannalog> it said me : Could not find module `Graphics.X11.Xlib.Extras'
13:12:25 <iwannalog> can anyone help
13:14:29 <conal> @go Graphics.X11.Xlib.Extras
13:14:30 <lambdabot> http://hackage.haskell.org/packages/archive/X11/1.4.5/doc/html/Graphics-X11-Xlib-Extras.html
13:14:30 <lambdabot> Title: Graphics.X11.Xlib.Extras
13:14:55 <conal> iwannalog: maybe you're missing the X11 package
13:15:22 <Botje> bavardage: you really only need the pdf, apparently
13:15:32 <bavardage> Botje: that's what I mean :D
13:15:35 <bavardage> srry
13:15:36 <iwannalog> I don't know, usually cabal do that for me, doesn't it ?
13:15:41 <bavardage> "How do I implement the pdf" :P
13:15:45 <bavardage> type-wise
13:15:46 <Botje> uh
13:15:57 <Botje> you start by looking up the definition of poisson's pdf
13:16:02 <bavardage> since it should be e^(-l) * l^x / x!
13:16:04 <Botje> and write that dwn as haskell
13:16:07 <bavardage> however type-wise it cries
13:16:14 <bavardage> I have no clue how to make the types right
13:16:31 <Botje> bavardage: can you add your implementation of the pdf?
13:16:34 <Botje> along with any errors you get
13:17:20 <bavardage> pdf (Poisson(l)) x = (2.71^(-l)) * (l^x) / (x) just as this for now (no factorial but that's trivial to add)
13:17:34 <bavardage> Stats.hs:27:48: Couldn't match expected type `a' against inferred type `b'
13:17:48 <Botje> bavardage: in the paste, please
13:17:48 <bavardage> In the second argument of `(/)', namely `(x)'
13:17:52 <bavardage> oh kk srry P
13:17:56 <Botje> then i don't have to switch back all the time :)
13:18:14 <iwannalog> conal: you we're right, but do you know why I have to tell to cabal to install X11 before ?
13:18:15 <conal> @type (^)
13:18:16 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:18:22 <bavardage> http://paste.pocoo.org/show/109229/
13:18:24 <bavardage> Botje: thar
13:18:28 <Botje> thanks
13:18:32 <kadavr> why have i developed this aversion to if-then-else since starting to use haskell? i find it ugly
13:18:35 <iwannalog> byt thx for the info
13:18:59 <dcoutts_> iwannalog: are you using "cabal install xmonad" or are you using "runhaskell Setup" ?
13:19:07 <iwannalog> the first one
13:19:12 <monochrom> I don't find if-then-else ugly.
13:19:13 <Botje> bavardage: as conal pointed out, you need to use (^^)
13:19:17 <kadavr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2800#a2800 <- can that function be made more elegant?
13:19:22 <bavardage> oh kk :D
13:19:43 <dcoutts_> iwannalog: does ghc-pkg list X11 say that it is already installed?
13:19:53 <gio123> does somebody knows whether there is a chanel for elan users?
13:20:01 <iwannalog> dcoutts_: how can i know that ?
13:20:15 <dcoutts_> iwannalog: run "ghc-pkg list X11"
13:20:16 <bavardage> http://paste.pocoo.org/show/109230/ more funky errors
13:20:17 <Botje> :t let l = 10::Int in \x -> (2.71^^(-l)) * (l^^x) / (x)
13:20:18 <lambdabot>     No instance for (Fractional Int)
13:20:18 <lambdabot>       arising from the literal `2.71' at <interactive>:1:26-29
13:20:18 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
13:20:34 <gio123> does somebody knows whether there is a chanel for elan users?
13:20:37 <conal> @type (**)
13:20:38 <lambdabot> forall a. (Floating a) => a -> a -> a
13:20:47 <iwannalog> dcoutts_: yes it's look like it's installed
13:21:09 <Gracenotes> This cheese is burning me!
13:21:22 <dcoutts_> iwannalog: ok in that case what has happened is that the files got deleted but the package was not unregistered. This could happen if you did something like rm -rf ~/.cabal/
13:21:27 <vixey> This yin-yang is spinningh!
13:21:32 <ehird> Gracenotes: Is it, now.
13:21:51 <Botje> bavardage: l^^(fromIntegral x)
13:22:19 <iwannalog> dcoutts_: I installed xmonad once, by hand (rungh Setup.hs ...) with all the dependencies, and remove the installed packages by hand
13:22:30 <iwannalog> maybe that's the problem
13:22:34 <dcoutts_> iwannalog: if that is what happened then you'll get the same problem with every other package that was registered in the per-user package db. If you only deleted the files for the X11 package then it's sufficient to unregister X11 and use cabal install again
13:22:41 <kadavr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2801#a2801 <- someone have a huge amount of spam to test that on? takes <spam-email-file> <goodemails-file> <test-file> as input
13:22:48 <bavardage> Botje: kk :P
13:23:06 <Botje> bavardage: bleh
13:23:11 <Botje> you need to spam fromIntegral all over the place
13:23:14 <dcoutts_> iwannalog: ghc-pkg unregister --user X11 and then cabal install xmonad again. If you get a similar problem with other packages then do the same.
13:23:20 <bavardage> hehe
13:23:29 <bavardage> I'll just convert all vars into integrals
13:23:29 <Nafai> It would be nice if there was something like winghci written using gtk/pango/cairo or the like
13:23:31 <PeakerWork> Botje: on the upside, no need for () there :)
13:23:47 <Botje> bavardage: (2.71^^(fromIntegral (-l))) * ((fromIntegral l)^^(fromIntegral x)) / (fromIntegral x)
13:24:00 <PeakerWork> Botje: prefix is higher precedence than infix
13:24:02 <dcoutts_> iwannalog: in future, if you decide to rm -rf ~/.cabal then you also need to rm the ~/.ghc files which is where the list of registered packages is kept. If they get out of sync then things get confusing.
13:24:05 <kadavr> Botje: was that for me?
13:24:08 <Botje> PeakerWork: really?
13:24:12 <kadavr> oh
13:24:18 <PeakerWork> > 5^fromIntegral 3
13:24:19 <Botje> handy :)
13:24:19 <lambdabot>   125
13:24:35 <bavardage> I'll try that
13:24:56 <iwannalog> dcoutts_: if I do runghc configure --prefix=/toto ..., when I want to install it I have to do more things than just rm -R f /toto ?
13:25:02 <Botje> (2.71^^(-l)) * ((fromIntegral l)^^x) / (fromIntegral x)
13:25:06 <Botje> this should be enough
13:25:29 <dcoutts_> iwannalog: yes you also need to ghc-pkg unregister ${the package name}
13:25:49 <mauke> 2.71 ^^ (-l) * fromIntegral l ^^ x / fromIntegral x
13:25:55 <iwannalog> YUC
13:26:10 <iwannalog> sorry yuk, but thanks for the advice dcoutts_
13:26:44 <dcoutts_> iwannalog: one of these days someone will implement cabal uninstall
13:26:44 <kadavr> is there a way to check if a program was invoked via the command line or main as caleld rom ghci?
13:26:59 <dcoutts_> kadavr: you can try checking the program name
13:27:05 <Nafai> +1 for cabal uninstall
13:27:05 <mauke> kadavr: what's the point?
13:27:19 <Botje> Prelude System.Environment> getProgName
13:27:19 <bavardage> errors again :D
13:27:19 <Botje> "<interactive>"
13:27:21 <bavardage> http://paste.pocoo.org/show/109233/
13:27:40 <dcoutts_> Nafai: if you'd like to help implement it, that'd be great
13:28:00 <iwannalog> dcoutts_: but prefix must be sanctified, can we disable ghc register instead ?
13:28:12 <Botje> bavardage: should l be an Integral or not?
13:28:22 <bavardage> who knows :P
13:28:26 <Nafai> dcoutts_: Perhaps I should at one point :)
13:28:27 <dons> so apparently people think these hackage figures are really good.
13:28:29 <bavardage> l is not, no
13:28:34 <bavardage> l is fractional
13:28:42 <bavardage> l is usually some number like 0.25
13:28:45 <Botje> then drop the call to fromIntegral
13:28:47 <dcoutts_> iwannalog: I don't understand. It's possible to install the package without registering it, however in that case it cannot actually be used (at least not easily).
13:28:48 <bavardage> kk
13:28:59 <Botje> and you'll probably need to change 2.71 ^^ to 2.71 **
13:29:06 <dons> got one comment to the effect of "Don't rub our noses in Haskell's success" -- something that sounds a bit weird to my ears.
13:29:22 <Nafai> That is weird
13:29:30 <Botje> dons: perhaps someone trying to avoid success ;)
13:29:34 <bavardage> dammit still errors :(
13:29:35 <dons> heh
13:29:37 <bavardage> maybe I need to rethink this
13:29:40 <bavardage> I just don't get what the issue is
13:29:49 <bavardage> I don't understand the type system properly methinsk
13:29:58 <bavardage> I just wanna multiply some numbers together :(
13:29:58 <Nafai> Any one have any idea how much windows specific code winghci is?
13:30:08 <dons> didn't someone confirm winghci is written in C?
13:30:14 <Gracenotes> **^**
13:30:37 * Nafai downloads the code
13:30:43 <Botje> bavardage: work out the types for l and x first
13:30:53 <bavardage> and do what with this?
13:31:00 <bavardage> so I know.. x is an Integer
13:31:02 <bavardage> l is a Fractional
13:31:04 <Botje> then go through the expression and try to work out which exponentiation to use
13:31:20 <bavardage> but l *could* be an Integer if it wanted
13:31:27 <bavardage> does that make sense?
13:31:36 <bavardage> l is allowed to be 1, 1.1, 1/3
13:32:08 <Nafai> Darn
13:32:16 <Nafai> dons: Yes, it does look like a bunch of C code
13:33:54 <Gracenotes> @type let o = o in    o<<^(.)^>>o
13:33:55 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a (b -> c) d
13:33:56 <bavardage> so what exponentation do I need for Fractional ^ Fractional ?
13:34:46 <PeakerWork> @type (^)
13:34:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:34:56 <Gracenotes> Fraction ^ Fractional isn't closed under fractionals
13:34:57 <PeakerWork> bavardage: its only for integral exponents
13:34:59 <Gracenotes> *fractional
13:35:08 <bavardage> I can't have fractional exponents?
13:35:13 <bavardage> haskell doesn't support that?
13:35:20 <Gracenotes> (2%1)^(1%2) = sqrt 2, which is irrational
13:35:30 <Gracenotes> can't be accurately expressed as a ratio
13:35:39 <bavardage> dammit :P
13:35:41 <Gracenotes> well, not precisely anyway
13:35:42 <Badger> > 10^(1/2)
13:35:44 <lambdabot>   Add a type signature
13:35:56 <bavardage> so I have to change Fractional to a Floating?
13:36:30 <Gracenotes> to have non-integer exponents, I suppoose
13:36:33 <Gracenotes> ooose.
13:36:37 <bavardage> aha
13:36:41 <bavardage> think I'm getting somewhere
13:36:45 <bavardage> ty :D
13:36:58 <Badger> > 10^0.5
13:37:00 <lambdabot>   Add a type signature
13:37:08 <Badger> ohright.
13:37:09 <Gracenotes> sure. there's also CReal if you want more accuracy of sorts
13:37:12 <Cale> > 10**(1/2)
13:37:13 <lambdabot>   3.1622776601683795
13:37:21 <Badger> :t (**)
13:37:23 <lambdabot> forall a. (Floating a) => a -> a -> a
13:37:23 <Cale> > 10**(1/2) :: CReal
13:37:24 <Gracenotes> > 2**(1/2) :: Double
13:37:25 <lambdabot>   3.1622776601683793319988935444327185337196
13:37:26 <lambdabot>   1.4142135623730951
13:37:40 <iwannalog> dcoutts_: usually i rather like situations where a package never get out from its prefix, and i'm not scared of specify llibrary path (even ten paths, it doesn't scare me)
13:37:41 <wli> Quad, oct, etc. precision floating point could come in handy on various occasions, too.
13:37:47 <Gracenotes> > (4**(1/2), 4**(1/2)) :: (Double, CReal)
13:37:48 <lambdabot>   (2.0,2.0)
13:37:52 <Gracenotes> :x
13:38:07 <Cale> CReal has the problem that for any nontrivial calculation, it gets really really slow quickly.
13:38:12 <kadavr> bavardage: where is the code? ill help you
13:38:42 <dcoutts_> iwannalog: it's more like 100 :-) take a look some time with -v when you build a non-trivial package and see how many -package flags cabal passes to ghc.
13:38:51 <Gracenotes> Cale: yeah. Plus, on opportunities where it might make more sense to use an infinite stream of characters, it seems it's always incremental
13:38:53 <Gracenotes> afaik
13:39:10 <bavardage> kadavr: ty
13:39:12 <bavardage> kadavr: http://paste.pocoo.org/show/109235/
13:39:19 <bavardage> it works now up until the /
13:39:19 <dcoutts_> iwannalog: I agree in general with your point about keeping things under one prefix.
13:39:25 <bavardage> (line 25)
13:39:32 <bavardage> like without the division all is happy
13:39:46 <iwannalog> dcoutts_: but i could put all my packet to a folder (with ln -s) and just specify one path (I always do that with linux src)
13:39:58 <dcoutts_> iwannalog: it would be possible with ghc with a change in the way that packages are registered. Eg if it were done by a search path convention like ~/lib/ghc-x.y/*/package.conf
13:40:35 <dcoutts_> iwannalog: sure, it's just not sensible to try and do that manually. There's too much to manage to do it manually.
13:40:57 <dcoutts_> iwannalog: it's possible to register into isolated prefixes including isolated package dbs.
13:41:03 <dcoutts_> iwannalog: cabal supports it directly
13:41:14 <dcoutts_> --package-db=
13:42:12 <bavardage> kadavr: nm, I got it
13:42:18 <bavardage> Botje: I got it now ty lots :D
13:42:46 <wli> yitz: You're right that it can come down to unsolvable polynomials; if q(x,y) where z^n = q(x,y) has coefficients of powers of y not expressible in a basis of powers of p(x) where y^k = p(x) then you get a basically general bivariate polynomial in z and y when the smoke clears. If it's solvable in radicals, you can just check for perfect powers in Z[x] but if not, no conclusion is possible.
13:42:55 <iwannalog> dcoutts_: because I know the one day I will need two versions of the same library and I want to be sure that i can do that
13:43:32 <Cheery> hi, I'd need some code examples for constructing LR(0) parsing tables
13:43:45 <dcoutts_> iwannalog: that's already possible.
13:43:56 <iwannalog> by a simple manner ?
13:44:00 <dcoutts_> iwannalog: you can install as many different versions of the same package as you like
13:44:10 <dcoutts_> iwannalog: cabal install foo-1.0; cabal install foo-2.0
13:44:11 <Cheery> just because I have a bit of hard time catching the parser table construction from wikipedia
13:44:37 <iwannalog> dcoutts_: and the two will lives ? and how i specify the one I want to use for another package (or for my project)
13:44:45 <wli> conal: I made progress on the algebraic expression simplifier. Risch already did all this in 1975, though, and in greater generality (i.e. some differential extensions I'm foggy about how to make use of, though they're clear enough in definition).
13:44:51 <dcoutts_> iwannalog: the only thing you can't do that way is install two instances of the same version of a package (eg built two different ways, eg against different deps)
13:45:23 <dcoutts_> iwannalog: cabal picks the versions automatically based on the version constraints in your package .cabal file
13:45:32 <conal> wli: cool.  what are your goals?
13:45:48 <tromp> will it prefer the latest satisfying version then?
13:46:13 <wli> conal: I basically figured out that the case of irrational denominators follows from the linear case because integral bases for the linear case provide methods for inversion.
13:46:15 <dcoutts_> iwannalog: eg if your .cabal file says: build-depends: foo < 2, then cabal has to pick foo-1.0, but if it says build-depends: foo then cabal will probably pick the latest version (unless something else really requires the older one).
13:46:46 <conal> wli: neat.  do you blog?
13:47:05 <iwannalog> but if me for my project I want a specifc one (already installed) how I specify the one I want if I installed evereyboy with cabal ?
13:47:40 <dcoutts_> iwannalog: if you're using a .cabal file for your project then you just put the version constraint in the build-depends.
13:47:50 <kadavr> nitpickking spelling but: Discreet shuld be Discrete
13:48:01 <dcoutts_> iwannalog: if you're building manually with ghc --make then you can use -package foo-1.0 or whatever
13:48:16 <wli> conal: The last problem was roots of perfect powers, so z^n = q(x,y) and y^k = p(x) is the way that can get represented, then use Grobner (or linear algebra when possible) to eliminate x; much of the time, you just get z^n = f(y) and can just test if f(y) is a perfect power in Z[y].
13:48:24 <dcoutts_> iwannalog: by default if you don't give an exact version then ghc --make will pick the latest installed version
13:48:28 <iwannalog> I understand, cabal install package for ghc
13:48:38 <iwannalog> not for cabal
13:48:44 <iwannalog> like runghc
13:49:16 <dons> augustss, bos31337 thought about an llvm project for SoC under llvm's umbrella?
13:49:43 <dcoutts_> iwannalog: it's the same for runghc as for ghc --make, you use the -package foo-1.0 flag if you need to say exactly which version you want.
13:50:10 <bos31337> dons: that would be nifty, but not something for which i have any time to think about :-(
13:50:19 <iwannalog> there is no a system like gcc, using env variables or CPPFLAGS, LDFLAGS etc...
13:50:57 <wli> conal: Well, this is just Risch  from 1975. There isn't really anything happening except my not understanding things off the bt and attempting to reconstruct  parts of Risch's results  when they could just be looked bup by anyone with an ACM account.
13:50:58 <dcoutts_> iwannalog: there's a ghc env var to set the default list of package databases to use
13:51:32 <iwannalog> which one ? i never hack the ghc's working
13:51:58 <dcoutts_> iwannalog: I can't remember off the top of my head, check the ghc user guide
13:52:06 <iwannalog> ok
13:52:08 <dons> bos31337: so nothing in terms of suggesting work for students?
13:52:12 <iwannalog> i will have a look
13:52:18 <wli> conal: Basically the same sorts of classes of expressions as result from Risch's symbolic integration algorithm are possible to automatically differentiate with zero testing.
13:54:00 <iwannalog> When is the haskell logo vote closed and the result published ?
13:54:32 <wli> conal: And/or canonicalization procedures that admit simplification and zero testing and so on.
13:55:22 <poucet> dons: Are you going to Hac?
13:55:27 <tromp> even if the vote isn't closed yet, it'd be nice to see current standings
13:56:24 <wli> conal: When I found the right things to google for (search string now lost) I turned up citations of a paper slightly predating his results on integration on precisely that topic.
13:56:27 <dons> poucet: i think so.
13:56:30 <dons> need to buy a ticket...
13:56:35 <iwannalog> tromp: see the result during progress is not a good idea
13:57:29 <skorpan> is there any performance penalty in using FlexibleInstances?
13:57:37 <rittyan2> "<command line>: not built for interactive use" <- wtf, when I try to start ghci
13:57:43 <tromp> i dont know; it wld be like watching the polls
13:58:04 <luite_> hm, 17-19 of april, just after the exams of the 3rd, sounds good
13:58:10 <wli> conal: I think he may require the differential extensions to occur only linearly.
13:58:31 <tromp> is the outcome of logo contest final?
13:58:48 <tromp> or subject to further discussion ?
13:59:31 <dons> skorpan: interesting question
13:59:38 <dons> you think there'll be more runtime dictionary passing?
14:00:16 <skorpan> dons: i have no idea, just curious
14:02:49 * poucet will from now on go as this nick and drop vincenz, since this nick is more personal
14:03:31 <Adamant> I liked vincenz
14:07:14 <poucet> But it doesn't relate to my RL name :)
14:07:23 <kadavr> if i want to do a an FFI to a video decoder. 1. which one /which formats? 2. is this really hard? 3. how do you do a proper haskell ffi-lib, just wrap everything in haskell code and try to purify it?
14:07:31 <ehird> poucet: 'Real Name: vincenz'
14:09:13 <MARIO83> 	WANT  more or less decent money in the euro without an attachment?
14:09:13 <MARIO83> This English project, where you pay for:
14:09:13 <MARIO83> 1.Registratsiyu - 100 EURO
14:09:13 <MARIO83> 2.Prosmotr one advertising - 5 EURO
14:09:13 <MARIO83> 3.Prochtenie a message to your mail - 10 EURO
14:09:13 <poucet> ehird: Where does it say that?
14:09:14 <MARIO83> 4.Za attract each referral - 20 EURO
14:09:16 <MARIO83> Try it, you have nothing to lose!.
14:09:17 --- mode: ChanServ set +o poucet
14:09:18 <MARIO83> What you should do:
14:09:19 --- kick: MARIO83 was kicked by poucet (poucet)
14:09:22 <ehird> poucet: /whois
14:09:24 <ehird> also, lol wat
14:09:56 <vixey> @w80 
14:09:57 <poucet> ehird: for me it just says ircname
14:09:57 <lambdabot> No match for "".
14:10:08 <poucet> ehird: oh wel :)
14:10:11 <lament> that looks like automatic translation from russian to english
14:10:37 <kadavr> long live russian scamartists!
14:10:46 <ehird> yeah, like lament!
14:11:09 --- mode: poucet set +b *!v_fgd@194.44.175.44
14:11:32 --- mode: poucet set -o poucet
14:12:55 <bremner> dammit, anybody who can't use utf8 should be banned
14:13:10 <lament> and he was.
14:13:22 <vixey> so yeah anyway
14:13:30 <pumpkin> :o
14:14:00 <iwannalog> bremner: ASCII is good
14:14:43 <c_wraith> iwannalog: ASCII? so limited??
14:14:45 <kadavr> if i want to do a an FFI to a video decoder. 1. which one /which formats? 2. is this really hard? 3. how do you do a proper haskell ffi-lib, just wrap everything in haskell code and try to purify it?
14:14:46 <bremner> iwannalog: sure, just code-page-spam-ru that is bad
14:14:52 <c_wraith> Much like my japanese. :)
14:14:55 <lament> can't say  in ASCII, what use is that
14:15:22 <mauke> 
14:15:23 <bremner> lament \x->x^2
14:15:24 <iwannalog> for coding ASCII is the best (i know guys who code with utf-8
14:15:32 <vixey> (x)x^2
14:15:51 <lament> iwannalog: depends on whether you're ok with writing comments in your native language
14:16:06 <c_wraith> Didn't sun introduce a language with UTF-8 constructs in its syntax?  Fortress?
14:16:12 <c_wraith> I bet that never went very far.
14:16:27 <tibbe> dons: ping :)
14:16:35 <c_wraith> Well, unicode constructs.  UTF8 wasn't the only valid encoding
14:16:37 <iwannalog> lament: no comment must be in english
14:16:57 <augustss> dons: I've not thought of any SoC llvm project, but doing something about GC could be an interesting project
14:17:09 <lament> iwannalog: not everybody can speak English very well.
14:17:15 <lament> or at all.
14:17:36 <Saterus> RWH question: im doing Ch12 and am writing the array folds. is foldA1 supposed to fold the first element of the array twice? or is that a bug? there's only one comment mentioning it...
14:17:49 <iwannalog> lament: they h
14:17:51 <dons> tibbe:
14:18:12 <iwannalog> they should learn, there are so many usefull ressources in english
14:18:23 <dons> augustss: yeah, maybe just identify one killer problem to solve, and see if there's a student who'd run it through the llvm folks, with you guys as co-mentors
14:19:25 <bavardage> hmm
14:19:37 <bavardage> how can I allow a function to take/return both Floating and Rational?
14:19:40 <Boney> I find UTF-8 handy in source files even just so I can add a comment referring to another developer who's name I can't spell in ascii.
14:19:48 <bavardage> what type class should I use?
14:19:59 <iwannalog> Boney: ha, good argument
14:20:04 <tibbe> dons: do you have the analysis program you used on the hackage logs? I'm working on a logs analysis library and it would be nice to have 1) a real analysis case and 2) an implementationt to compare performance against
14:20:31 <lament> If i worked with my Russian friends, i would certainly prefer they write comments in Russian.
14:20:46 <dons> not public yet. i'll probably upload it later. was thinking it would be useful to have a apache log parser on hackage
14:20:54 <lament> Their english is quite horrible.
14:20:55 <Boney> It might also be useful for typing mathamatical or logical equations in comments.
14:21:02 <iwannalog> Boney: names who can't be write with ascii. Even chinese one can be written with ASCII.
14:21:34 <iwannalog> :D
14:21:54 <Boney> iwannalog: yep.  For a German name like G:odel I would write Goedel.
14:22:03 <iwannalog> we agree
14:22:08 <Boney> (sorry I don't have an input method setup that I'm farmiliar with).
14:22:27 <lament> Gdel
14:22:29 <pejo> Boney, 
14:23:00 <Boney> Also I cheat since the developer with umlouts and accents in his name only occur in his first name.  So I write his second name only.
14:23:07 <mmorrow> , (text . utf8enc) "\x2200"
14:23:09 <lunabot>  
14:23:13 <Boney> lunabot: yes.
14:23:13 <bavardage> Gdel
14:23:16 * bavardage has umlauts mapped
14:23:18 <Boney> pejo: that didn't look write to me.
14:23:37 <Boney> right*
14:23:40 <bavardage> 
14:23:41 <c_wraith> Boney, you probably don't have your client set to use utf8
14:23:44 <pumpkin> :o
14:23:46 <mmorrow> , ""
14:23:47 <lunabot>  "\246\246"
14:23:47 <pejo> Boney, I'm sensing a resistance towards iso-8859-1 in this channel.
14:23:47 <c_wraith> it's not the default for most IRC clients
14:23:48 <bavardage> e
14:23:53 <mmorrow> , utf8enc ""
14:23:54 <lunabot>  "\195\182"
14:24:04 <iwannalog> iso-8859-1, yuk
14:24:09 <iwannalog> i don't like this one
14:24:25 <Boney> c_wraith: the other symbols look fine to me,  the umlouts in godel and someone typed a lambda earlier.
14:24:27 <kadavr> dont teach our 's you bastards!
14:24:31 <kadavr> touch
14:24:42 <kadavr> how is russia lament?
14:24:46 <kadavr> where do you live?
14:24:46 <c_wraith> how does g?del look?
14:24:50 <iwannalog> ?
14:24:58 <iwannalog> c_wraith: it looke g?del
14:25:08 <Boney> c_wraith: I saw a question mark for the o.
14:25:12 <c_wraith> I'm sending utf8.  I hope.
14:25:12 <lament> kadavr: russia is really shitty, but the women are hot.
14:25:19 <lament> c_wraith: you aren't. Gdel.
14:25:22 <c_wraith> ???
14:25:35 <lament> <c_wraith> how does g?del look?
14:25:41 <iwannalog> same
14:25:43 <tibbe> dons: I'm including a common log parser and an extended log parser
14:25:44 <mauke> c_wraith: you are sending UTF-8, but it's the UTF-8 for QUESTION MARK (?)
14:25:57 <c_wraith> arg
14:25:59 <Boney> lunabot: I want to meet a young, georgious russian woman who knows about cryptography.
14:26:05 <c_wraith> my fault.  I didn't set an encoding for this server.  brb
14:26:06 <Boney> that'd be so sexy.
14:26:15 <c_wraith> 
14:26:21 <dons> tibbe: ooh
14:26:22 <mauke> U+3066 (e3 81 a6): HIRAGANA LETTER TE []; U+3059 (e3 81 99): HIRAGANA LETTER SU []; U+3068 (e3 81 a8): HIRAGANA LETTER TO []
14:26:31 <dons> i could have used that code on saturday , tibbe  :)
14:26:31 <c_wraith> And, you know, for completeness..  gdel
14:26:40 <iwannalog> 
14:26:56 <Boney> c_wraith: Hurray!
14:27:00 <c_wraith> Gah.  I don't speak chinese, iwannalog. :)
14:27:07 <iwannalog> me not
14:27:12 <lament> 
14:27:34 <c_wraith> lament, I can read "middle" and "person" in there.  Not enough.  :)
14:27:40 <iwannalog> 
14:27:47 <pejo> Let me just point out that quite a few of those UTF-8 characters are horrible for terminals.
14:27:49 <tibbe> dons: heh
14:28:09 <dons> coming to the hackathon, tibbe ?
14:28:11 <tibbe> tibbe: basically all you have to is provide a function to fold over the logs
14:28:15 <Zao> pejo: Stack some diacritics and see it go diacritical!
14:28:16 <tibbe> dons: will be in Thailand :/
14:28:19 <dons> tibbe: tibbe's talking to himself
14:28:21 <iwannalog> pejo: we're in XXIth century youknow
14:28:27 <dons> oh thailand
14:28:28 <tibbe> dons: haha
14:28:36 <dons> you didn't have to run to the other end of the landmass to avoid us
14:29:08 <dons> well, i might hold off on apache logs then, until you upload yours
14:29:12 * mauke wonders if  makes any sort of sense
14:29:14 <tibbe> dons: the log analysis function is simply: fold :: Monoid m => (LogEntry -> m) -> FilePath -> IO m
14:29:20 <dons> mm
14:29:21 <c_wraith> also, no one commented on how bad my pun was.  "gdel" for "completeness", and all
14:29:28 <tibbe> dons: I'd love to see it in whatever shape it is
14:29:31 <dons> and LogEntry is the parsed line?
14:29:38 <tibbe> dons: yes, parsed by the libraru
14:29:41 <dons> oh, its about 50 lines of bytestring hacking
14:29:44 <Boney> mauke: none,  I see whitespace.  or stuff typed with the color set to black.
14:29:45 <tibbe> dons: it also folds over lines, etc
14:29:48 <c_wraith> mauke, I think you'd want to write 
14:29:50 <dons> take/drop/split on lines.
14:29:55 <kadavr> http://hackage.haskell.org/packages/archive/HTTP/4000.0.4/doc/html/Network-HTTP-HandleStream.html im trying to figure out how to just do the simplest possible webserving. just want a mian fucntion that serves soemthing to port 8080
14:30:01 <c_wraith> katakana to indicate it's a borrowed foreign word
14:30:01 <dons> yes, that looks like a good interface
14:30:02 <kadavr> a string no html needed yet
14:30:12 <tibbe> dons: my log library is 50 lines of enumerator hacking ;) but I plan to parallize it, possibly over multiple machines ala Sawzall
14:30:48 <dons> ooh.
14:30:53 <mauke> c_wraith: I don't speak Japanese, only Engrish (and I can search the unicode character db) :-)
14:30:58 <Nafai> dons: So is there anything like winghci that is written in Haskell that could be ported to cairo or something?
14:31:27 <c_wraith> mauke: just remember most engrish is in katakana, instead of hiragana. :)
14:31:30 <rittyan2> http://paste.pocoo.org/show/109245/ <- does it look ok to you? it applies function to every nth specified element.. like mapN [(2, f)] [1..10] should apply 'f' to an element with index 2...
14:32:40 <mmorrow> @remember put some restriction like every token has a neighbourhood locally homeomophic to algol
14:32:40 <lambdabot> Done.
14:32:42 <mmorrow> heh
14:32:46 <mmorrow> aww crap
14:32:49 <pumpkin> @quote put
14:32:50 <lambdabot> put says: some restriction like every token has a neighbourhood locally homeomophic to algol
14:32:52 <mmorrow> @remember vixey put some restriction like every token has a neighbourhood locally homeomophic to algol
14:32:52 <lambdabot> It is stored.
14:33:01 <mmorrow> good ol' put.
14:33:36 <mmorrow> i wonder what his last name is?
14:34:17 <bavardage> is ther a way to combine floating and rational
14:34:21 <pumpkin> iton
14:34:27 <bavardage> so I can have a function that can gracefully deal with both
14:35:19 <c_wraith> bavardage: Does the Num typeclass do what you need?
14:35:27 <bavardage> who knows
14:35:29 <bavardage> 'cos I don't :P
14:35:38 <bavardage> pretty sure Num makes everything go boom
14:35:41 <mauke> what operations do you need?
14:35:59 <bavardage> multiplication/division/addition/subtraction/exponentation
14:36:12 <mauke> that shouldn't be a problem
14:36:21 <bavardage> http://paste.pocoo.org/show/109246/ so I have this
14:36:25 <mauke> what kind of exponents do you need?
14:36:44 <bavardage> I want to allow Binomial/Poisson to have rational parameters too
14:37:26 <mauke> exp on rationals? you're screwed
14:37:54 <bavardage> dammit :p
14:38:06 <bavardage> shame it's not possible to use rationals as much as possible
14:38:20 <bavardage> and then if there's exp involved turn into a floating
14:38:22 <bavardage> hrm
14:38:33 <mauke> > exp 1 :: CReal
14:38:35 <lambdabot>   2.7182818284590452353602874713526624977572
14:38:47 <bavardage> since Binomial doesn't actually use exponentation
14:39:02 <bavardage> right, is there a way to redefine the types of class functions
14:39:08 <bavardage> (no clue about correct terminology)
14:39:13 <bavardage> so for Binomial, it uses Num
14:39:16 <mauke> > showCReal 100 (exp 1 )
14:39:18 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
14:39:26 <bavardage> but then for poisson, it gets limited to Floating?
14:39:36 <mauke> not really
14:39:41 <bavardage> dammit
14:39:57 <bavardage> so is there *no* way of doing what I want to?
14:42:40 <mmorrow> vixey: alternatively you can do "notDfs (Branch l r) k = notDfs l (++ notDfs r k)"
14:43:17 <mmorrow> s/not/notnot/
14:44:23 <pumpkin> anyone here at stanford?
14:44:27 <vixey> I think that what I really want to say is a tree data type in ocaml/scheme/whatever is simply that -- but in haskell it's a program
14:44:47 <vixey> yeah I'm generalizing the 'lists are loops' slogan I guess
14:44:48 <wli> Maybe notDfs (Branch l r) k = notDfs l (>< notDfs r k) might be nicer.
14:45:03 <vixey> data = code
14:45:41 <Adamant> how do you decompose a list xs into (x:xs) when you're in a guard, or should I use some other method?
14:45:47 <wli> > Seq.fromList [1,2] >< Seq.fromList [3,4]
14:45:48 <lambdabot>       Failed to load interface for `Seq':
14:45:48 <lambdabot>        Use -v to see a list of the ...
14:46:54 <skorpan> @pl \c -> recoverwith (pure []) <|> c
14:46:54 <lambdabot> (recoverwith (pure []) <|>)
14:48:17 <Adamant> maybe what I'm getting at is - what's the difference between pattern matching and guards? can I mix the two, and should I?
14:49:39 <wli> @run (Sequence.><) (Sequence.fromList [1,2]) (Sequence.fromList [3,4])
14:49:40 <lambdabot>   fromList [1,2,3,4]
14:49:46 <Heffalump> Adamant: you can mix them and it is often a good idea to do so
14:50:46 <Adamant> Heffalump: any good references on mixing the two? i'm used to seeing programs with just one or the other
14:50:59 <Heffalump> not off the top of my head
14:51:02 <Adamant> ah
14:51:05 <Heffalump> it's just style, really
14:51:12 <Adamant> thanks anyway, at least I know where to start now
14:51:20 <Heffalump> pattern matching helps you select against an ADT, then guards help you refine that selection
14:52:34 <wli> ugh, nameclash between (Test.QuickCheck.><) and (Data.Sequence.><)
14:55:42 <pumpkin> thoughtpolice: yo yo
14:57:56 <kadaver> hpaset down?
15:00:08 <travisbrady> kadaver: you can use http://moonpatio.com/fastcgi/hpaste.fcgi/
15:01:09 <kadaver> http://rafb.net/p/CaL3Cv14.html <- so how do I create a Request? i cant get it to work. i just want to serve a simple string to 8080
15:01:51 <kadaver> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1962#a1962 <- hpasted
15:02:20 <kadaver> and cant I import Network.* to import everything from Network?
15:05:12 <tomh> is there any language extension needed for stuff like forall b. ?
15:05:20 * vininim_ hates springer
15:05:35 <monochrom> ScopedTypeVariable
15:06:05 <ddarius> tomh: It requires an extension, yes.  There are lots of extensions that enable that syntax.
15:06:06 <monochrom> should be ScopedTypeVariables
15:06:24 <dolio> It depends where you're putting it.
15:06:54 <tomh> in the type
15:07:07 <tomh> gonna try scopedTypeVariables
15:07:09 <dolio> It's always in a type.
15:07:09 <vixey> ScopedTypeVariables makes more sense than RankNTypes *switches*
15:07:29 <Heffalump> TypeOperators is actually the right one I think
15:07:32 <Heffalump> if you just want that
15:07:45 <dolio> TypeOperators allows types like :*:.
15:07:46 <tomh> oh the right one is RankNTypes
15:08:06 <Heffalump> oh, ok. Ignore me.
15:08:08 <vixey> RankNTypes is what I used to use but ScopedTypeVariables is a better name for it
15:08:37 <vixey> that's exactly what forall. is .. scope
15:08:46 <dolio> RankNTypes lets you do '(forall a. P a) -> b'. ScopedTypeVariables lets you do 'forall a b. (a -> b) -> f a -> f b', ExistentialQuantification lets you do 'data Foo = forall a. Foo a'...
15:09:00 <vixey> wait
15:09:19 <ddarius> dolio: That's a very incomplete description of ScopedTypeVariables.
15:09:20 <vixey> ScopedTypeVariables doesn't let you do (forall a. P a) -> b?
15:09:30 <dolio> ddarius: Yeah, yeah. :)
15:09:45 <dolio> Scoped type variables gives foralled variables lexical scope in your program.
15:10:23 <dolio> So if you do 'foo :: forall a. a -> b ; foo a = ... where bar :: a ; bar = ...', the 'a' in bar's type will be the same as the 'a' in foo's type.
15:10:35 <dolio> Whereas it'd otherwise be 'forall a. a' in bar's type.
15:10:47 <ddarius> s/foo a/foo x/ for clarity.
15:10:54 <dolio> Ah, yeah.
15:13:53 <ddarius> vixey: Scoping isn't the sole purpose/intent of forall.  exists scopes just as much.
15:14:02 <tomh> so whats the gain of putting forall a. in a type?
15:14:08 <wli> What, no tyvars with module scope?
15:14:25 <ddarius> tomh: You're the one that wanted to do it.  Why do you want to do it?
15:14:38 <tomh> well, school :/
15:14:40 <monochrom> The gain of forall is what dolio said.
15:15:00 <tomh> ah mm
15:15:32 <wli> So you have to write an explicit forall for ScopedTypeVariables to have an effect?
15:15:41 <ddarius> wli: Yes.
15:16:02 <ddarius> That keeps it from changing the meaning of any Haskell 98 code.
15:16:04 <wli> That explains a lot of why it has had no effect when I tried to use it.
15:16:44 <monochrom> Most GHC extensions work that way. You have to turn it on, and then you have to use the added syntax.
15:16:49 <wli> Next, RankNTypes.
15:19:12 <gnuvince_> With the FFI, if I want to "map" a C struct which contains a byte array (char * actually), do I need to make the conversion in the Storable instance?
15:19:17 <tomh> so basically the forall makes sure that if you do a forall a, and then letter in a function in the same scope, you define another type a, it is the same ?
15:19:24 <tomh> letter = later
15:19:25 <ddarius> gnuvince: No.
15:19:45 <ddarius> tomh: No.
15:20:12 <gnuvince_> ddarius: what's the correct way to go about this then?
15:20:17 <ddarius> tomh: But probably what you intended is the case.
15:20:30 <ddarius> gnuvince: There are types that directly correspond to C pointers.
15:20:41 <tomh> mm
15:20:52 <tomh> is there any good article which explains it for a noob? :)
15:21:01 <ddarius> Read the User's Guide.
15:21:18 <monochrom> s/define another/mention again/  and you'll be all set.
15:21:48 <gnuvince_> ddarius: I see that I was unclear in my original question: I would like to have a ByteString in my Haskell data structure.  Going from struct { int size; char *data; }; into MyStruct { size :: Int, data :: ByteString }
15:22:08 <ddarius> gnuvince: There are things that will make a bytestring from a pointer.
15:22:23 <tomh> ddarius: the one from ghc?
15:22:34 <ddarius> tomh: Yes. (What other one?)
15:22:44 <mmorrow> gnuvince: hsc2hs basically scans your haskell file for some special syntax, pulls some info out, prettyprints a C main() with various offsetof/sizeof/DEFINED_CONSTANTS that when run spits out haskell code in turn as a String.
15:23:11 <mmorrow> i hear c2hs is pretty nice
15:23:13 <gnuvince_> ddarius: I'll read the documentation of the Foreign modules then.  Thanks.
15:23:17 <ddarius> gnuvince: Also if "size" is for the number of characters, then ByteString already stores that information.
15:23:18 <mmorrow> haven't used it though
15:23:23 <tomh> I dunno, can be lots of others..
15:23:44 <mmorrow> gnuvince: you need to make sure you know the alignment of the fields in a struct though before you go poking
15:23:52 <gnuvince_> ddarius: yeah, but that would come after I figure out how to get the data out of that pointer into that ByteString and the other way around.
15:23:56 <ddarius> gnuvince: ByteStrings aren't part of the FFI so there will be no documentation on them in the FFI docs.
15:24:44 <mmorrow> gnuvince_: you use ByteString.Internal + mallocForeignPtr to build ByteStrings
15:25:06 <kadavr> couldnt you have a static fuctionallanguage without monads?
15:25:19 <gnuvince_> mmorrow: and where do I build it?
15:25:26 <kadavr> sure you could, are monads mostly a way to annotate types as impure?
15:25:31 <mmorrow> gnuvince_: i'm pasting an example
15:25:33 <vixey> kadavr: no
15:25:39 <gnuvince_> mmorrow: thanks, I appreciate that.
15:25:42 <mmorrow> np
15:25:59 <ddarius> gnuvince: http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Unsafe.html#v%3AunsafeUseAsCStringLen
15:29:09 <ddarius> gnuvince: If you aren't trying to avoid an O(n) hit, use packCString(Len)
15:29:50 <ddarius> (and I meant to link to unsafePackCStringLen before)
15:30:55 <gnuvince_> ddarius: I'll see if the performance calls for the unsafe version, but for now, I'm more interested in getting something working
15:31:06 <BMeph_> Cale: ping
15:31:47 <quicksilver> conal: well, I have in mind a semantics where Geometry2D corresponds to coloured open sets of R^2, I suppose
15:31:53 <quicksilver> conal: I'm not sure if that's what you mean...
15:33:30 <Rotaerk> holy channel population ..
15:34:01 <dons> ?users
15:34:01 <lambdabot> Maximum users seen in #haskell: 658, currently: 633 (96.2%), active: 20 (3.2%)
15:34:43 <seanl> is it now the biggest among the programming language channels?
15:34:52 <vixey> isn't it the biggest?
15:35:03 <pumpkin> when it was 699 maybe
15:36:00 <BMeph_> It's been over 700 before, excluding bots, hasn't it?
15:37:33 <Gracenotes> but has it been over 9*stab**stab**stab**stab**stab*
15:38:46 <dons> 699 is the max, afaik
15:39:04 <dons> yup
15:40:12 <solidsnack> Wow. Gracenotes an hero.
15:40:22 <solidsnack> Or shall I say, an haskell.
15:41:47 <BMeph_> Oh, according to searchirc.com, (Full disclosurer: the site runs on php) #php, #python and ##c++ are bigger than #haskell. :\
15:42:59 <BMeph_> Amusingly, the two most populated channels are #ubuntu and #debian. Sounds like a Lot of people desparate for help... ;p
15:43:01 <dons> heh. they've had a good run.
15:43:08 <conal> quicksilver: yeah that's the sort of thing i was asking.  i'd be interested in hearing if you can make that model precise and if your combinators can all be given (compositional) semantics in that model.
15:43:20 <conal> quicksilver: and whether it ends up the same as Pan or different.
15:46:17 <dolio> conal: I was wondering in regards to your denotational semantics thread: why not parameterize the semantics by the bit width of Ints, rather than making machine info part of its semantics? Or are you worried about, say, distributed computing?
15:47:01 <conal> dolio: yeah.  distributed computing, including migratory.
15:47:08 <dolio> Okay.
15:47:14 <b\6> is cwd per-process? i shouldn't set cwd in a forkIO, should i?
15:48:51 <Saizan__> yes, per process, and you probably shouldn't
15:49:06 <b\6> Saizan__: thanks.
15:51:05 <kadavr> did anyone here make a simple webserver?
15:52:00 <b\6> kadavr: there are a few around. maybe look at hyena.
15:52:03 <b\6> it's on github.
15:52:29 <kadavr> import Network.* haskell deosnt support something like that?
15:52:29 <Saizan__> kadavr: are you having a problem in particular?
15:52:40 <b\6> kadavr: oh, no way.
15:52:50 <Saizan__> the Network module should suffice, actually
15:52:57 <kadavr> Saizan_ : no, just trying to figure out how to write a basic one. or actually i have one. simpleHTTP
15:53:22 <kadavr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1962
15:54:10 <Saizan__> where is simpleHTTP defined?
15:54:24 <Saizan__> however it seems uriScheme wants more arguments.
15:54:53 <Saizan__> and simpleHTTP probably handles the listening himself
15:54:57 <vixey> http://en.wikipedia.org/wiki/Hendrik_Pieter_Barendregt
15:55:01 <vixey> seems very outdated
15:55:15 <Saizan__> listenOn is useless if you don't use the Socket it returns, anyway
15:56:19 <trofi> @pl do { r1 <- act1; if (isJust r1) then return r1; else do r2 <- act2; if (isJust r2) then return r2; else return (Just 0); }
15:56:19 <lambdabot> (line 1, column 4):
15:56:20 <lambdabot> unexpected "{"
15:56:20 <lambdabot> expecting variable, "(", operator or end of input
15:57:14 <Saizan__> a simple server looks like: "withSocketsDo $ do s <- listenOn (PortNumber 8080); forever $ do { (h,_,_) <- accept s; forkIO (handle h) }
15:57:17 <Saizan__> "
15:57:33 <Saizan__> where handle is the function that implements the communication with the client
15:58:20 <Saizan__> you also want to add exceptions catching, so that you close the sockets if anything bad happens
15:58:39 <lepassive> what about code reuse in haskell ? I got it's modular, abstraction, but what about subclassing ?
15:58:45 <trofi> @pl do { r1 <- act1; if (isJust r1) then return r1; else do { r2 <- act2; if (isJust r2) then return r2; else return (Just 0); } }
15:58:45 <lambdabot> (line 1, column 4):
15:58:46 <lambdabot> unexpected "{"
15:58:46 <lambdabot> expecting variable, "(", operator or end of input
15:58:49 <kadavr> http://hackage.haskell.org/packages/archive/HTTP/4000.0.4/doc/html/Network-HTTP-HandleStream.html <- simpleHTTP ,
15:59:40 <kadavr> http://hackage.haskell.org/packages/archive/network/2.2.0.1/doc/html/Network-URI.html#t%3AURI <- uriScheme
16:00:40 <conal> lepassive: i don't miss oop subclassing when i'm programming in a functional language.  i guess it's a different way to modularize.
16:00:57 <Saizan__> kadavr: ok, simpleHTTP is not a server, it's rather a simple way to perform an HTTP request from the client side
16:01:07 <tomh> i dont even miss subclassing when i do oop :P
16:01:17 <vininim_> @hoogle f -> g -> a -> (f a, g a)
16:01:17 <lambdabot> Data.IntMap insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
16:02:05 <lepassive> conal, then it's only modularity to allow code reuse?
16:02:16 <mmorrow> gnuvince: sry, got held up. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1963
16:02:42 <kadavr> where is forever?
16:03:01 <conal> lepassive: also types.  do you have some other forms in mind?
16:03:03 <mmorrow> gnuvince: (so clearly that poke def is quick and hackish with the hardcoded lengths, etc..)
16:03:05 <Saizan__> kadavr: also, uriScheme is an accessor for URI, but rqURI wants the full URI, so you must construct it with the URI constructor, passing it all the arguments
16:03:08 <vininim_> @pl h a = (f a, g a)
16:03:08 <lambdabot> h = liftM2 (,) f g
16:03:14 <Saizan__> ?index forever
16:03:15 <lambdabot> bzzt
16:03:19 <Saizan__> ?hoogle forever
16:03:20 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:03:26 <blackh> lepassive: I find Haskell's way of abstracting is a lot more concise. e.g. The factory pattern becomes... add an extra argument to the function and partially apply it.
16:03:26 <Saizan__> kadavr: Control.Monad
16:03:51 <lepassive> conal, hmmm inheritance maybe as type classes are like interfaces
16:04:12 <mmorrow> gnuvince_, ddarius: yeah, packCStringLen would be nice, but if you have to call strlen anyways..
16:04:17 <conal> lepassive: yep.
16:04:46 <conal> i sometimes think of FP as stateless OO with a much lighter-weight notation.
16:04:50 <lepassive> conal, but you don't get the data members do u ? what about upcasting/downcasting
16:04:55 <mmorrow> gnuvince_, ddarius: i meant s/pack/unsafePack/
16:05:22 <monochrom> downcasting is evil
16:05:27 <lepassive> blackh, I Like the haskell way really :) it's just a doubt
16:05:59 <gnuvince_> mmorrow: Thanks a lot!  Also, I'm pretty sure I won't ever have to write into that data structure, so that relieves me of packing that ByteString
16:06:03 <monochrom> Smalltalk doesn't need downcasting because it's really OO.
16:06:15 <mmorrow> np :)
16:06:30 <wli> What on earth is downcasting/upcasting?
16:06:42 <conal> lepassive: you'll probably get functional programming more if you step back from the mechanisms you're used to from OO, erase your slate and learn from a Beginner's Mind.
16:06:53 <blackh> lepassive: I think that a lot of OO is devoted to ensuring that the state management of an object is kept tidy.  Because everything is immutable in Haskell, a large amount of this need just disappears.
16:07:08 <mmorrow> gnuvince_: ah yeah, so that "c_strlen" is coming from ByteString.Internal
16:07:38 <mmorrow> (it's juts a straight foreign import ccall unsafe "strlen" c_strlen :: ...)
16:08:42 <lepassive> hmmm mind providing me of "code reuse in depth" in haskell ?
16:08:45 <desp> vixey: so, no comments about my code?
16:08:49 <monochrom> Upcasting is casting to a superclass. Downcasting is casting to a subclass (with runtime checking and possible exception).
16:08:54 <gnuvince_> I was watching a video by Rich Hickey (Clojure author) a few months ago where he talked about the difficulties of interacting between two languages that don't have the same semantics.  I didn't know what that meant at the time.  I've only just begun looking into it and already I can feel the problems coming at me :)
16:09:00 <vixey> your code is not depth first
16:09:06 <vixey> that is all my comments
16:09:21 <blackh> lepassive: My first attempt at a Haskell program was a small adventure game.  I thought as an experiment that I could try the same problem with what I know now.  This has been very good and is probably worth publishing on the wiki as a demonstration of how different the Haskell Way is.
16:09:22 <desp> vixey: could you explain why?
16:09:31 <vixey> no
16:09:36 <vixey> you will realize it eventually, or not
16:09:43 <wli> Hmm. Extensions where f, f' are algebraically dependent over F are nonelementary unless the relation is linear.
16:09:58 <pejo> wli, an upcast casts a subclass to one of its base classes.
16:10:04 <mmorrow> hpaste works again in case anyone was wondering..
16:10:22 <blackh> lepassive: I think that there's a big gap in the area of "how to do things the Haskell way" on the wiki.
16:10:37 <wli> pejo: The basic use of subtyping. So it's downcasts that are evil, modulo, perhaps, modula-style typecase.
16:10:49 <Saizan__> desp: where's your code?
16:11:00 <lepassive> blackh, very interesting, my first attemp was with a database/GUI app
16:11:05 <desp> Saizan__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2797
16:11:07 <blackh> lepassive: There's lots of stuff for beginners, but not much in helping make the leap to a different way of doing things. You do learn it, but it would be nice to get some help. That's what I found when I was learning.
16:11:10 <lepassive> attempt*
16:11:13 <vixey> So $\sqrt{2}$ is only in approximation 1.41212. As I just showed you, no matter how many decimals we provide, it remains an approximation. So you may wonder why we say that $\sqrt{2}$ exists. Well, it exists because WE WANT IT.
16:11:22 <desp> Saizan__: vixey is claiming that this code does not perform a depth-first traversal.
16:11:32 <vininim_> @pl h (x:xs) = (f (x:xs), g (x:xs))
16:11:32 <lambdabot> h = ap (ap (ap . (((,) . f) .) . (:)) ((g .) . (:)) . head) tail
16:11:40 <vininim_> oh i see
16:11:59 <desp> Saizan: to me, it looks like it does, and I'd be honestly grateful if someone can tell me what's the problem with it.
16:12:32 <monochrom> I hate the opinion that existence is defined by decimal expansion.
16:12:33 <wli> vixey: Like even the natural numbers, $\sqrt{2}$ exists only as a mental construct used as a tool to assist in modelling and communicating shared perceptions.
16:12:35 <desp> Saizan: compare with vixey's http://rafb.net/p/cVvfMi84.html
16:12:45 <blackh> lepassive: I'll briefly describe the difference between my first version and how I would do it now..
16:12:50 <kadavr> where is forever?
16:12:53 <kadavr> @hoogle forever
16:12:54 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:12:59 <vixey> I just like this "WE WANT IT" bit
16:13:07 <lepassive> blackh, can't wait :)
16:13:10 <vixey> I had not considered that
16:13:23 <monochrom> Decimal notations exists only because LOSERS WANT IT.
16:13:50 <kadavr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2807#a2807 <- ok what not typesystem bitch?
16:13:58 <monochrom> Real people and real math software work with sqrt(2) symbolically and axiomatically just fine.
16:14:36 * wli stacks MonadError atop MonadRWS and ponders how deep everyone else's monad stacks go.
16:14:52 <vininim_> @hoogle Monad m => ( m a -> m b) -> (m a -> m b) -> m a -> (m b, m b)
16:14:52 <lambdabot> No results found
16:15:05 <monochrom> In fact I saw a Scheme implementation (you know the superior number system of Scheme) that understands that (sqrt(2))^2 is an integer.
16:15:55 <wli> I'm digging algebraic functions pretty hard.
16:16:12 <blackh> lepassive: My first version had a StateT monad on top of an IO monad which was used everywhere, and a function "say" was defined as "lift $ putStrLn text"
16:16:12 <BONUS> vininim_: that's just &&& ... maybe you mean (a -> mb) -> (a -> m b) -> m a -> (m b, m b)
16:16:35 <mmorrow> wli: i love flattened monads
16:16:53 <sysadmin> I'm trying to recompile happstack on os x.
16:17:06 <sysadmin> Do you need pkill to do that?
16:17:26 <blackh> lepassive: When I defined the world, it was initialWorld = World {locationID = "river", inventory = [], rooms = Map.fromList [("river", river), ("path", path) ...  with river and path defined at the top level giving Room data structures.
16:17:50 <blackh> lepassive: So that's the old version. How I would do it now (I made a bit of a start last night)...
16:19:05 <Saizan> desp: well, the order of the resulting list is probably consistent with dfs on finite trees, but whats not depth-first is the order in which you unfold the trees
16:19:20 <blackh> lepassive: I use "interact (unlines . game . lines)" in main, and I use State WorldState for most of the rest of it
16:19:43 <Saizan> desp: or, at least, your version needs to explore all the tree before it outputs any element
16:19:53 <Saizan> *trees
16:20:15 <blackh> lepassive: Instead of defining the world directly, I have a bunch of functions to modify the world.  So for example, room :: RoomRef -> State RoomState () -> State WorldState ()
16:20:41 <Saizan> desp: tail recursion is not the best strategy in haskell
16:20:52 <wli> mmorrow: Now all I need is a MonadRWSE to flatten my usual monad stacks.
16:20:52 <lepassive> blackh, ahh i see, but it's kinda odd to write a game in Haskell write ?
16:20:53 <Saizan> desp: you use it only where you can't exploit laziness
16:21:04 <desp> Saizan: right... rconnor explained that neatly earlier.
16:21:08 <desp> Saizan: thanks for your help.
16:21:11 <blackh> lepassive: RoomRef is "newtype RoomRef = RoomRef Int", and the values are allocated by a function newRef.
16:21:13 <vininim_> BONUS: thanks
16:21:25 <Saizan> desp: ah, ok, i didn't follow :)
16:21:29 <vininim_> I bet there is something that already does this
16:21:35 <vininim_> > let windows n xs = unfoldr (g.((&&&) (take n) (drop 1))) xs where g (a,b) = if ((==n).length) a then Just (a,b) else Nothing in windows 4 [1..10]
16:21:36 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
16:21:39 <blackh> lepassive: 'room' creates a new room if it doesn't already exist, applies the state changes in the second argument, and pushed it into the world state's main map.
16:22:07 <blackh> lepassive: So there's no difference between creating a room in the initial game, and creating a room any time later.  Also, it can be used to modify existing rooms.
16:22:09 <wli> mmorrow: I guess it's because of the commutation behavior of Error vs. State (and maybe other things) that there isn't such a thing; there'd need to be two variants for each of the stacking orders.
16:22:45 <blackh> lepassive: Here's an example: beach <- create; room beach $ do ; describe "You are standing on a lovely wide sunny beach." ...
16:23:18 <blackh> lepassive: So the idea is that all transformations of the game state are done by primitives (such as "describe") and combinators (such as "room").
16:23:41 <desp> vixey: thanks to you as well.
16:23:45 <lepassive> blackh, very nice really
16:23:52 <vininim_> @pl (g.((&&&) (take n) (drop 1)))
16:23:53 <lambdabot> g . (take n &&& drop 1)
16:24:22 <vininim_> lambdabot++
16:24:39 <wli> I'm trying to think of how one copes with extending differential fields by e.g. Jacobian elliptic functions.
16:24:49 <blackh> lepassive: Then the whole game is written at a high level.  Commands would be associated with rooms or items, and then in the main loop you would search all the rooms and items in view for commands.  You would attach "take" and "drop" commands to an item with a helper function called "portable", for example.
16:25:06 <BONUS> fmap (+1) &&& fmap (+2) $ Just 3
16:25:07 <mmorrow> wli: i've thought about some TH code that takes an arbitrary stack of Monads, and derives the one-level flattened version
16:25:11 <BONUS> > fmap (+1) &&& fmap (+2) $ Just 3
16:25:13 <lambdabot>   (Just 4,Just 5)
16:25:24 <BONUS> i think thi sis pretty concise
16:25:35 <blackh> lepassive: The whole point is that everything that a particular game object can do is connected directly with that object. If it has magical properties, such as a key being able to open a door, that would be added by "command" or some helper function made from it.  The key idea is that everything is composable.
16:25:36 <mmorrow> wli: that's be interesting just to see the output code (.. and useful too)
16:25:39 <wli> mmorrow: Ah, but if they don't all commute, there is no unique flatened version.
16:25:52 <BONUS> @pl (\f g m -> fmap f &&& fmap g $ m)
16:25:52 <lambdabot> (. fmap) . (&&&) . fmap
16:26:05 <mmorrow> wli: RWS, SWR, SC, SCW, CWR, ....
16:26:17 <mmorrow> CWCWCWCWCWS
16:26:19 <blackh> lepassive: So I hope that's helpful.  If I finish the new version of the game I'll post it on the wiki and let you know.
16:26:48 <lepassive> blackh, it was very helpful thanks alot, sure I'll try it :)
16:26:59 <mmorrow> @unmtl ContT a (WriterT b (State c)) d
16:27:00 <lambdabot> (d -> c -> (a, b, c)) -> c -> (a, b, c)
16:27:07 <wli> mmorrow: Okay, the intention of "versions" vs. "version" noted.
16:27:19 <mmorrow> wli: ah, yeah totally.
16:27:53 <wli> I've never gotten the hang of using MonadCont for anything useful.
16:28:10 <mmorrow> wli: any possible permutation, flattened/optimized + derived classes (Functor, Monad, ...) + helper functions would be the complete package
16:28:25 <wli> I think I vaguely got the idea of ramming MonadCont actions past the typechecker, but that's about it.
16:28:37 <wli> brb
16:29:06 <Saizan> mmorrow: an infinite package?
16:29:26 <mmorrow> wli: yeah, i don't really use it for much either... but i pretty much just use the same 20-line custom State monad for any monadic task..
16:30:03 <mmorrow> Saizan: infinite in potential, yet finite in space ;)
16:31:29 <mmorrow> @unmtl StateT a (WriterT b (Cont c)) d
16:31:29 <lambdabot> a -> (d -> a -> b -> c) -> c
16:32:25 <mmorrow> @unmtl ContT z (RWST r w s (StateT a (WriterT b (ContT e Identity c))) d
16:32:25 <lambdabot> err: Parse error
16:32:33 <mmorrow> @unmtl ContT z (RWST r w s (StateT a (WriterT b (ContT e Identity c)))) d
16:32:33 <lambdabot> err: `(c -> e) -> e' is not a type function.
16:32:39 <mmorrow> wut
16:33:12 <mmorrow> @remember @unmtl err: `(c -> e) -> e' is not a type function.
16:33:12 <lambdabot> Okay.
16:33:34 <mmorrow> oops
16:33:37 <mmorrow> that was me
16:33:42 <mmorrow> @unmtl ContT z (RWST r w s (StateT a (WriterT b (ContT e Identity)))) d
16:33:43 <lambdabot> (d -> r -> s -> a -> (z -> s -> w -> a -> b -> e) -> e) -> r -> s -> a -> (z -> s -> w -> a -> b -> e) -> e
16:34:44 <mmorrow> C(RWS)SWCI
16:35:24 <mmorrow> @djinn (d -> r -> s -> a -> (z -> s -> w -> a -> b -> e) -> e) -> r -> s -> a -> (z -> s -> w -> a -> b -> e) -> e
16:35:25 <lambdabot> -- f cannot be realized.
16:36:05 <mmorrow> @. djinn unmtl ReaderT z (RWST r w s (StateT a (WriterT b (ReaderT e Identity)))) d
16:36:06 <lambdabot> -- f cannot be realized.
16:36:25 <mmorrow> @. djinn unmtl Reader r a
16:36:25 <lambdabot> -- f cannot be realized.
16:36:36 <Saizan> you should ask for return or bind
16:36:45 <mmorrow> heh
16:36:46 <kadavr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2807#a2807 <- ok what not typesystem bitch?
16:36:49 <hamishmack> I want to get the "expected type" for autocomplete in Leksah.  My plan is to replace the current word with a dumby function that will fail to match.  Then look at the compiler error.
16:36:51 <Saizan> just the monadic type is not a theorem
16:36:55 <kadavr> @hoogle forever
16:36:56 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
16:37:07 <hamishmack> Is there a suitable function a bit like "undefined"
16:37:38 <hamishmack> That would fail to match at compile time with everything (or almost everything)
16:37:47 <Saizan> ()?
16:37:49 <mmorrow> error . show
16:37:52 <mmorrow> ?
16:38:06 <mmorrow> oh, compile-time?
16:39:08 <mmorrow> , fix (\k s (t,Node _ z) -> ?omg k s t z)
16:39:10 <lunabot>  luna: Unbound implicit parameter (?omg::(t3
16:39:12 <hamishmack> Yes at compile time
16:39:28 <mmorrow> hamishmack: implicit parameters might help you
16:39:38 <mmorrow> , map ?f [Nothing, Just 99]
16:39:39 <lunabot>  luna: Unbound implicit parameter (?f::Data.Maybe.Maybe a -> b)
16:39:58 <mmorrow> , ?f map [Nothing, Just 99]
16:40:00 <lunabot>  luna: Unbound implicit parameter (?f::((a1 -> b) -> [a1] -> [b])
16:40:03 <mmorrow> etc
16:40:34 <hamishmack> Do you think Saizan's suggestion of () would work?
16:40:57 <hamishmack> It works for 1 + () and putStrLn ()
16:41:23 <mmorrow> i'm not sure what you're after exactly, but it's worth a try
16:41:53 <mmorrow> just start firing stuff at the typechecker and eventually you'll eke out enough info to best it ;)
16:42:39 <kadavr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1965#a1965 <- i tried compiling the ircbot on http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source , and got ambigous type variable in catch
16:42:43 <kadavr> what do i add?
16:43:13 <mmorrow> this would work:
16:43:27 <mmorrow> catchIO :: IO a -> (IOException -> IO a) -> IO a
16:43:32 <mmorrow> catchIO = catch
16:43:41 <mmorrow> (that's what i use..)
16:44:02 <kadavr> for me?
16:44:04 <mmorrow> and if you want to catch _everything_, do s/IOException/SomeException/
16:44:32 <mmorrow> kadavr: yeah, just replace all uses of "catch" with that catchIO
16:44:45 <kadavr> ah
16:44:48 <kadavr> thnx
16:44:50 <mmorrow> (it works because it's constrining the type of catch)
16:44:57 <mmorrow> *constraining
16:45:26 <mmorrow> > return 42 :: [Int]
16:45:27 <lambdabot>   [42]
16:45:31 <mmorrow> > return 42 :: Maybe Double
16:45:32 <lambdabot>   Just 42.0
16:45:40 <mmorrow> > return 42 :: IO Integer
16:45:41 <lambdabot>   * Exception: "<IO Integer>"
16:51:43 <hamishmack> mmorrow:  looks like () might be the way to go as "1 + ()" gives "No instance for (Num ())" where as "1 + ?f" just gives "Unbound implicit parameter (?f::t)"
16:56:49 <Shimei> Hi. I was wondering if anyone has looked into the class alias proposal and if it's at all feasible to implement in GHC easily. (http://hackage.haskell.org/trac/ghc/ticket/788)
16:57:04 <Shimei> (e.g. as an GSoC project or otherwise)
17:03:52 <kadavr> Saizan: thanksforyour example but i still dont get how to implement handle, i can do it as just handle s a = print (s,a) and then i get that printed but to the terminal. how do I serve it to the client at the port?
17:04:46 <wli> If f, f' are algebraically dependent over a differential field F and G = F(f,f',g'(f)) where g is the implicitly defined algebraic function defining f' = g(f), I think G' is contained in G.
17:05:56 <Saizan> kadavr: im my example handle :: Handle -> IO (), where the Handle is what you use to communicate with the client, like handle h = do hPutStr h "response"; hFlush h
17:06:46 <Saizan> kadavr: you can e.g. use hGetLine h to get data from the client
17:07:12 <Saizan> kadavr: then you've to parse the request, you'd probably want to use a library for that
17:07:27 <kadavr> where is hFlsuh and hPutStr or that was pseudo-names?
17:07:43 <Saizan> they are from System.IO
17:08:45 <kadavr> forever $ do (sock,sockaddr) <- S.accept s ; i had to change to that. but socket is not a handle...
17:09:35 <Saizan> can't you use Network.accept?
17:10:01 <Saizan> however you might want to look at the sources of http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mohws for inspiration
17:13:02 <wli> s' = c*d, c' = - s*d, d' = -k^2*s*c, then things start getting interesting.
17:15:54 <kadavr> haha then i chose the wrong one
17:17:49 <kadavr> bwaha!
17:18:44 <wli> F(s,c,d) seems to be differential (provided k^2 is in the ground field). Maybe similarly for s' = c, c' = -s and F(s,c) so the ground field may remain real.
17:20:40 <kadavr> Saizan: so now i need like you said just a parser for stuff like: GET / HTTP/1.1
17:21:03 <Saizan> kadavr: yeah
17:23:01 <lepassive> is there a sprintf in haskell ?
17:23:26 <monochrom> printf in haskell doubles as printf in C and sprintf in C.
17:24:10 <dons> hmm. why don't we overload show / print like that?
17:24:16 <dons> use show in an IO context, get print.
17:24:22 <dons> use show in a String context, get a string...
17:24:29 <dons> i guess we already had print.
17:24:34 <monochrom> main = do { s <- getLine; printf "%s\n" s }  -- this printf is an IO action.
17:25:07 <Gracenotes> the usual tradeoff, I suppose, is effing weird error messages
17:25:13 <monochrom> main = do { s <- getLine; let t = printf "%s\n" s; putStr t }  -- this printf is a String!
17:33:43 <eyeris> I'm reading the TMR article Typeclassopedia. In the functor section it references ((->) e). Is this the type constructor in function signatures?
17:34:27 <kadavr> so how many requests can a 1.73GHz, 1GB ram computer running a naive webserver handle per second?
17:34:30 <kadavr> you think?
17:35:02 <dolio> 32.33---repeating of course.
17:35:21 <monochrom> I think I can safely answer yes to eyeris.
17:36:31 <kadavr> also how do I serve so stuff is available for everyone? if i want my own computer as a webserver, and i serve at 8080 at my computer , what do you need to access that?
17:36:42 * kadavr feels like a noob
17:37:20 <eyeris> monochrom so e represents the parameter of the function? and it has only 1 parameter because all functions are curried?
17:37:36 <monochrom> Yes.
17:39:13 <Saizan> kadavr: the public ip of your machine, if you're behind a router you need to adjust the firewall settings on it, probably
17:39:59 <kadavr> Saizan: thanks a lot btw, i can just serve html directly to the socket and it works so i have a pathetic webserver but still, a webserver!
17:40:16 <kadavr> public ip = ip?
17:40:23 <kadavr> i mean what is the nonpublic one?
17:40:39 <eyeris> monochrom The exercise in TMR is to implement fmap for ((->) e). Is it this? fmap g ((->) e) = \e -> g e
17:40:54 <eyeris> In other words, is fmap for -> simply application
17:40:55 <eyeris> ?
17:41:05 <monochrom> "fmap g ((->) e)" is confusion.
17:41:31 <eyeris> So ((->) e) is not akin to (Just e)?
17:41:47 <monochrom> Maybe e is not akin to Just e.
17:42:32 <Saizan> kadavr: if you've a LAN your machine will have an ip like 192.168.0.x, that's valid only from inside your lan
17:42:35 <eyeris> Is it then possible to use destructured binding for -> in the definition of fmap?
17:42:46 <monochrom> Here is the type signature for fmap in case of ((-> e): fmap :: (a->b) -> ( (e->a) -> (e->b) )
17:43:00 <kadavr> so to ban an ip-adress what do you do? you need to ask the local node not to serve that ip to you?
17:43:02 <monochrom> No, functions don't have data constructors.
17:43:24 <monochrom> But you don't need data constructors for fmap for ((->)e)
17:44:12 <eyeris> I see.
17:44:25 <Saizan> kadavr: i'm not sure about what you're asking, but you might want to look for some documentation on networking in general
17:44:38 <monochrom> fmap g blah = ?  Let's see. g::a->b, blah::e->a, you want the answer to be answer::e->b.  There is a fairly straightforward thing to do.
17:44:46 <eyeris> fmap g :: (e->a) -> (e->b), so fmap g h = g . h?
17:45:01 <monochrom> Yes.
17:45:36 <eyeris> It made a lot more sense when I saw the type sig. It was pretty darn hard for me to write out the type sig myself.
17:45:40 <eyeris> Thanks.
17:46:53 <kadavr> 127.0.0.1:50101 , my ip, public or not?
17:46:59 <eyeris> Is there an operator that is the reverse of (.)? It is confusing for me to look at g . h; it makes more sense when I see h . g.
17:47:20 <monochrom> flip (.)
17:47:47 <monochrom> I think there is also a dedicated symbol defined in the libraries, but I forgot it.
17:47:49 <eyeris> I think it's because I want to simply be able to glue the type signatures together, end to end, in the same direction that I read them.
17:48:18 <Saizan> >>>
17:48:28 <Saizan> importing Control.Arrow
17:49:21 <conal> eyeris: alternatively, some people like to write the function arrows right-to-left.
17:49:36 <pejo> kadavr, whois yourself for information on what the irc server sees.
17:50:00 <dancor> :t bool
17:50:02 <lambdabot> Not in scope: `bool'
17:50:12 <eyeris> Thanks guys. Back to reading :)
17:50:45 <dancor> i guess i'm thinking of if'
17:50:59 <conal> eyeris: enjoy!
17:51:35 <conal> "bool" is a nice name when the condition comes last.  then it's a fold
17:51:51 <dancor> ya, but not in any standard lib
17:52:12 * dancor is a slave to conformity
17:52:39 <chessguy> @src guard
17:52:39 <lambdabot> guard True  =  return ()
17:52:39 <lambdabot> guard False =  mzero
17:52:41 <conal> the great thing about standards is that there are so many to conform to
17:52:44 <CakeProphet> dancor:  hah! make your own standard lib then
17:52:47 <wolf> Is there any speed benchmark between compiled haskell program and perl script?
17:53:10 <dancor> my own standard!
17:53:42 <CakeProphet> dancor:  call it Preface
17:53:53 <CakeProphet> or Prologue.
17:54:01 <CakeProphet> though that might sound too much like Prolog
17:54:13 <dancor> i have appearances to consider
17:55:02 <conal> dancor: appear lordly!
17:55:08 <dancor> good choice
17:55:51 <pejo> wolf, the computer language benchmarks game.
17:56:00 <omnihil> wolf, http://shootout.alioth.debian.org/
17:56:06 <omnihil> oops pejo beat me to it
17:56:15 <wolf> Great!
17:57:23 <dancor> isn't it wrong that anyToken doesn't update the position?
17:57:27 <dancor> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/src/Text-Parsec-Combinator.html#anyToken
17:58:35 <matthewp_> working on list monads right now on the real world haskell book club on #novalang if anyone is interested.  Looking for good hacking examples
17:58:36 <kadaver> so now I have come to an interesting thng about haskell. since im doing a webserver I want to allow hot code swapping, no shutting down the server to upgrade...so then Data.Dynamic is what I turn to?
17:59:05 <dancor> won't (anyToken >> string "lol error") have a wrong error on "Xlol erro!"
17:59:31 <eyeris> In the fmap type signature, is the proper english phrasing of "f a" "a functor f over a"?
17:59:38 <jedai> wolf: Basically, consider that Haskell will always be faster, and even much faster in plenty of case
17:59:47 <vininim_> > (exp 0.25) / ( (exp 0.5) + 2 * exp 0.25 )
17:59:48 <lambdabot>   0.304504342420284
18:00:08 <vininim_> > (exp 0.5) / ( (exp 0.5) + 2 * exp 0.25 )
18:00:09 <lambdabot>   0.390991315159432
18:00:26 <dancor> > parse "omg" (anyToken >> string "lol error") "_lol erro!"
18:00:27 <wolf> jedai: yeah, seems very good
18:00:28 <lambdabot>   Not in scope: `parse'Not in scope: `anyToken'Not in scope: `string'
18:00:39 <jedai> kadaver: You culd study the way happstack does it
18:00:46 <dancor> lambdawot
18:00:49 <wolf> even compare with C sometime.
18:01:12 <monochrom> matthewp_:  http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html  has my "forward constraint propagation" using the list monad.
18:01:40 <matthewp_> monochrom: thanks!  nice stuff
18:03:00 <dancor> ah right it's related to parsec ignoring position on non-Char types
18:03:06 <dancor> it's a bit of a caveat
18:03:30 <kadaver> how can i do the python-eq of: "hello %s" % #haskell -> "hello haskell" ?
18:03:45 <dancor> anyway _my_ regal (class ParserWithPos ..) is totally going to update the pos
18:04:40 <jedai> kadaver: "hello " ++ haskell
18:04:52 <mmorrow> hamishmack: nice. yeah, sometimes the "unbound impli..." error messages are useless
18:05:08 <jedai> kadaver: There are some printf equivalent implementation too
18:05:29 <jedai> kadaver: also : lit "hello " haskell
18:06:42 <roconnor> > printf "hello %s" "#haskell"
18:06:43 <lambdabot>   Add a type signature
18:06:43 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
18:07:17 <mmorrow> , $(printf "hello %s" "#haskell") (show [0..9])
18:07:18 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]
18:07:28 <mmorrow> , $(printf "hello %s #haskell") (show [0..9])
18:07:32 <lunabot>  "hello [0,1,2,3,4,5,6,7,8,9] #haskell"
18:07:52 <kadaver> jedai: but inside... "hello %s , how are you?" % "haskell"
18:07:55 <mmorrow> , printf "hello %s #haskell" (show [0..9]) :: String
18:07:56 <lunabot>  luna: Couldn't match expected type `GHC.Base.String -> GHC.Base.String'
18:07:58 <jedai> Text.Printf is rather limited
18:08:04 <mmorrow> > printf "hello %s #haskell" (show [0..9]) :: String
18:08:05 <lambdabot>   "hello [0,1,2,3,4,5,6,7,8,9] #haskell"
18:08:39 <jedai> , $(printf "hello %s, how are you") "haskell"
18:08:40 <dancor> is there a TH thing that is kwlr than printf
18:08:41 <lunabot>  "hello haskell, how are you"
18:08:48 <dancor> i guess that's the $(..) version
18:09:05 <mmorrow> , let (x,xs) = ("#haskell", show [0..4]) in [$here|hello $(x), [0..4] is $([0..4]) and $(xs)|]
18:09:07 <lunabot>  "hello \"#haskell\", [0..4] is [0,1,2,3,4] and \"[0,1,2,3,4]\""
18:09:09 <dancor> jedai: non-TH is limited bc you need more type sigs?
18:09:33 <mmorrow> dancor: i like the TH one more personally
18:09:43 <jedai> dancor: Yes, there are implementation richer than Text.Printf I think
18:09:43 <mmorrow> > printf "hello %s #haskell %d" (show [0..9]) :: String
18:09:45 <lambdabot>   "hello [0,1,2,3,4,5,6,7,8,9] #haskell * Exception: Printf.printf: argument ...
18:10:03 <jedai> dancor: What's cool with the TH one is that it's statically checked
18:10:04 <roconnor> RayNbow: all I can recommend is the section on corecursion in TTFP
18:10:04 <mmorrow> > $(printf "hello %s #haskell %d") (show [0..9])
18:10:05 <lambdabot>   <no location info>: parse error on input `$'
18:10:10 <mmorrow> , $(printf "hello %s #haskell %d") (show [0..9])
18:10:11 <chessguy> anybody remember where in RWH they talk about map vs. flip map, and putting whichever argument is more complicated second?
18:10:12 <lunabot>  luna: No instance for (GHC.Show.Show (a[a74D] -> GHC.Base.String))
18:10:16 <roconnor> @where TTFP
18:10:17 <lambdabot> I know nothing about ttfp.
18:10:23 <mmorrow> , [$ty| $(printf "hello %s #haskell %d") |]
18:10:26 <lunabot>  ()
18:10:29 <mmorrow> um
18:10:38 <mmorrow> , ?f $(printf "hello %s #haskell %d")
18:10:40 <lunabot>  luna: Unbound implicit parameter (?f::(GHC.Base.String
18:10:45 <mmorrow> , $(printf "hello %s #haskell %d")
18:10:48 <lunabot>  luna: No instance for (GHC.Show.Show
18:10:50 <mmorrow> epic
18:10:54 <monochrom> There are too many $( $[ ${ variations in TH. :)
18:11:14 <mmorrow> :: forall a (Show a, Integral a) => String -> a -> String
18:11:17 <roconnor> @where+ TTFP http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
18:11:17 <lambdabot> I will never forget.
18:11:19 <roconnor> @where TTFP
18:11:20 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
18:11:50 <mmorrow> monochrom: yeah
18:11:57 <monochrom> . o O ( Who would remember what TTFP stands for? )
18:14:04 <kadaver> i got print f thankls
18:14:51 <kadaver> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1966#a1966 <- why doesnt respond wotk properly there? i know str is equal to "GET / HTTP/1.1" , itried "GET / HTTP/1.1\n" to but didnt help
18:15:40 <koninkje> need \cr\lf as I recall. Or \cr\lf\cr\lf
18:15:40 <Botje> kadaver: str should be equal to "GET / HTTP/1.1\r"
18:15:55 <roconnor> monochrom: I would remember
18:15:56 <Botje> assuming getline strips off the \n
18:15:58 <Botje> i forgot
18:16:18 <monochrom> getLine strips off the \n
18:16:24 <roconnor> monochrom: TT = type theory, FP = functional programming
18:16:31 <monochrom> Oh, it may also strip off the \r
18:25:50 <kadavr> Saizan: once I have used forkIO to give a user a thread then i dont need to handle the thread itself at all? each new request is a nw thread? is this slow or the normal way to do it?
19:03:20 <kadavr> is Data.Dynamic basically turning haskells typesystem  into tagged types? so each thing carries around its type and then they are checked at runtime?
19:03:54 <dolio> Something like that.
19:04:20 <monochrom> When you do a cast, there are runtime checks protecting an unsafeCoerce.
19:05:03 <Ralith> graaaaaah
19:05:12 <dolio> And type classes are used to associate every type with a corresponding typerep value.
19:05:23 <dolio> Which you get by typeOf :: a -> TypeRep or something.
19:05:32 <kadavr> ok
19:05:46 <Ralith> I'm trying to dynamically compile and load a source file with hint
19:05:59 <dolio> Every concrete type, that is. It doesn't handle polymorphic types (since type classes don't, really).
19:06:05 <Ralith> I keep getting
19:06:07 <Ralith> WontCompile [GhcError {errMsg = "No instance for (Database.HDBC.Types.IConnection\n                   Datatypes.SuneState)\n  arising from a use of `Database.HDBC.Types.disconnect'\n               at <interactive>:1:34-43\nPossible fix:\n  add an instance declaration for\n  (Database.HDBC.Types.IConnection Datatypes.SuneState)"}
19:06:23 <Ralith> but the same file loads directly into ghci without complaint, and the types match those hint expects.
19:06:45 <Ralith> SuneState is a data structure which contains a HDBC connection.
19:07:07 <Ralith> waaaaaait a minute!
19:07:15 * Ralith needs to get himself a rubber ducky
19:07:32 <Ralith> problem resolved
19:07:34 <Ralith> ish.
19:13:11 <kadavr> im thinking since it is compiled hot code swapping can never be done without restarting?
19:14:51 <wli> It depends on a lot of things.
19:15:15 <necroforest> Is there a fancy term for when a function/operator is its own inverse? (i.e, F(F(x))=x)
19:15:20 <wli> If your language runtime and program are prepared to go a long way to support it, it is possible.
19:15:25 <TomMD> duality
19:15:32 <wli> necroforest: Inversion.
19:15:43 <wli> necroforest: Involution, sorry.
19:16:32 <adimit> Hello! Could anyone please point me to some documentation to the new GTK2hs EventM mechanisms? I'm a bit confused, and couldn't find anything but the API documentation on it, but so far it's a bit hard for me to get my head around it.
19:16:43 <adimit> (I'm speaking of GTK2hs 0.10 here)
19:17:05 <koninkje> wli: http://en.wikipedia.org/wiki/Involution_(mathematics)
19:17:23 <necroforest> wli, thanks :) my homework now sounds smarter
19:17:30 <wli> I was distracted while I was typing.
19:17:42 <roconnor> we should totally write minilight in Haskell
19:17:56 <wli> What's minilight?
19:18:03 <roconnor> http://www.hxa.name/minilight/
19:18:51 <kadavr> http://en.wikipedia.org/wiki/Involution_(mathematics)
19:19:17 <koninkje> there are some amusing generalisations of involutions in group theory where f^n x = x for some particular n (not just 2)
19:21:16 <Saterus> is there a dedicated Real World Haskell channel?
19:21:52 <wli> Well, those would be groups actions or permutation groups.
19:21:57 <monochrom> Haskell Picture Renderer: "We draw the picture lazily."
19:23:18 <roconnor> maybe this would be a good way to learn data parallel haskell.
19:29:39 <thoughtpolice> @seen pumpkin_
19:29:40 <lambdabot> pumpkin_ is in #haskell-blah, #ghc, #haskell-overflow and #haskell. I don't know when pumpkin_ last spoke.
19:29:46 <thoughtpolice> pumpkin_: ping
19:43:33 <kadavr> @type pumpkin
19:43:34 <lambdabot> Not in scope: `pumpkin'
19:43:59 <kadavr> @type pumpkin :: Int -> [Int]
19:44:00 <lambdabot> Not in scope: `pumpkin'
19:44:05 <kadavr> @type (pumpkin :: Int -> [Int])
19:44:06 <lambdabot> Not in scope: `pumpkin'
19:44:11 <kadavr> @type (Int -> [Int])
19:44:12 <lambdabot> parse error on input `->'
19:56:48 <kadavr> @src dons
19:56:49 <lambdabot> Source not found. Do you think like you type?
20:00:55 <bwr> Favorite haskell/math related blogs?
20:02:17 <saml> bwr, i like things i am amused at
20:02:35 <saml> http://augustss.blogspot.com/
20:02:52 <bwr> thanks
20:10:47 <kadaver> what is a good #channel to disciss networking and generalinternet stuff?
20:11:17 <jeffwheeler> In Happstack, all these monoids for URI routing seem brilliantly clean.
20:11:35 <jeffwheeler> Although the tutorial is, unfortunately, rather messy.
20:11:44 <bwr> How mature is Happstack? Is it ready for production web app?
20:11:50 <kadaver> yeah im looking at it right now.
20:12:03 <jeffwheeler> I haven't a clue; I just started playing with it yesterday, and it seems to have some very good ideas.
20:12:50 <kadaver> hello world was easy
20:12:51 <jeffwheeler> The StringTemplate stuff it suggests as one template seems uselessly ugly for larger sites, but it points to some alternatives, and I suspect haXML or whatever will work cleanly with it.
20:13:03 <jeffwheeler> One template engine, I mean.
20:13:17 <kadavr> http://tutorial.happstack.com/src/ControllerBasic.hs <- that example is pretty horrible imo
20:13:30 <jeffwheeler> Yeah, tons of the examples are really ugly.
20:13:41 <jeffwheeler> Yet the framework itself seems very elegant.
20:13:44 <jeffwheeler> I wish the tutorial was better.
20:14:51 <kadavr> great then
20:16:33 <jeffwheeler> It should be relatively possible to clean up the tutorial significantly, starting with more refined and specific examples.
20:17:01 <jeffwheeler> It's unnecessary, in my opinion, to make the entire site one big example. Most things can be written in ten or so lines, and be copied/pasted into test files.
20:17:57 <kadavr> yes
20:18:04 <kadavr> precisely
20:19:17 <jeffwheeler> I think Django has a great, general-purpose tutorial for beginners on their site; a succinct four-page guide that introduces various things like URI routing, form handling, etc. rapidly but simply.
20:21:19 <ddarius> Convert Django's tutorial to Happstack.
20:22:35 <jeffwheeler> Hmm, that's an idea; a simpler alternative to beautifying the current tutorial.
20:22:44 <jeffwheeler> I'll try to do that once I learn it myself. :)
20:23:03 <jeffwheeler> Anyways; for now I have to go
20:33:41 <wli> Aha, the condition that t' be in K[t] is the extension being monomial.
20:42:46 <kadaver> i want to count the nbrs of lines of haskell i ahve written
20:43:18 <kadaver> so i have /ghc-v/progs/ and i want for each dir for each file, count nbr of line s add add it alltogether
20:43:34 <kadaver> is there an easy way to count nbr of lines in a file in haskell?
20:44:17 <cpfr> hey anyone in here familiar with hint?
20:48:14 <wli> conal: Okay, it looks like transcendental functions of certain forms are handled, but only of a rather restrictive kind.
20:49:09 <wli> conal: And that is in the full generality of denominators etc.
20:50:07 <kadaver> what do you do with Monoids? you abstract out some pattern? anyoen ahve an example?
20:50:59 <dolio> Look at the writer monad.
20:51:14 <cpfr> I am trying to use the Haskell Interpreter Module
20:51:41 <cpfr> and I am trying to figure out how to embed values I compute in the outer Haskell into the inner Haskell
20:52:16 <Gracenotes> @go monoids finger trees
20:52:18 <lambdabot> http://apfelmus.nfshost.com/monoid-fingertree.html
20:52:18 <lambdabot> Title: Monoids and Finger Trees
20:52:30 <Gracenotes> ^ more applications
20:52:34 <wli> I wonder what non-monomial extensions are called, like t' in K(t) not just K[t], or t' being algebraic over K(t).
20:52:45 <Gracenotes> sigpfe's blog on blogspot has a few posts on monoids too
20:53:00 <Gracenotes> sigfpe.
21:04:58 <kadavr> anyone good with Text.Html? does it containt soem sort of metatags to render html?
21:05:03 <kadavr> aa = Html ([HtmlString "hello",HtmlString "there"])
21:05:12 <kadavr> just returns hellothere
21:09:56 <kadavr> http://www.mail-archive.com/debian-jobs@lists.debian.org/msg00003.html <- how much do you think haskell is in use thta you just never hear of?
21:10:27 <kadavr> http://www.aetion.com/jobs.html
21:12:57 <kadavr> eh a FILO stack is a queue right?
21:15:26 <Ralith> For HDBC's prepared statements, is there any way to cache them across multiple calls to the same function to make the preparation more worthwhile?
21:21:23 <zakwilson> kadavr: yes, a FILO is a queue
21:28:14 <llaarrll> hello all
21:29:02 <llaarrll> quick question
21:29:21 <kerlo> Ello.
21:29:28 <llaarrll> is there a way to represent integers as their written (English) name?
21:30:01 <llaarrll> in regards to a builtin function
21:30:10 <Zao> As strings, as types?
21:30:19 <llaarrll> as strings
21:30:34 <llaarrll> so 1 becomes "one"
21:30:42 <llaarrll> 2 becomes "two"
21:30:45 <llaarrll> so on and so forth
21:31:01 <Zao> There is no built-in function for that, I believe.
21:31:08 <Zao> It shouldn't be horribly hard to write one.
21:31:16 <Zao> Heck, one of the Euler problems is to spell out numbers.
21:31:16 <llaarrll> yeah, should be simple enough
21:31:26 <llaarrll> just not trying to reinvent the wheel
21:32:09 <llaarrll> also, Im doubleplus new to Haskell
21:32:27 <llaarrll> so I'll probably be popping in here every so often
21:34:11 <TSC> llaarrll: Welcome aboard!
21:34:22 <llaarrll> ah, thank you
21:35:25 <kadavr> from where are neglihs nbrs combos? ie you need to explictily give 0-20,30,40..90,hundred,thousand etc?
21:41:22 <pumpkin> thoughtpolice: oi :)
21:41:35 <kadaver> oi oi
21:41:43 <llaarrll> type Color
21:43:05 <kadavr> data Color = RGB (Int,Int,Int) or type Color = (Int,Int,Int)
21:45:39 <thoughtpolice> pumpkin: how goes it. :)
21:46:07 <pumpkin> thoughtpolice: not bad, at a symposium right now! was wondering if you'd had any success with x86_64 ghc
21:51:28 <kadaver> is there a isDirectory function already?
21:55:34 <kerlo> kadaver: what would it take?
21:55:42 <kerlo> What would be its type, rather.
21:57:48 <dons> yeah, in the directory package
21:57:54 <dons> ?hoogle Directory
21:57:54 <lambdabot> module System.Directory
21:57:54 <lambdabot> System.Posix.Internals Directory :: FDType
21:57:54 <lambdabot> package directory
21:57:56 <pumpkin> @hoogle FilePath -> Bool
21:57:57 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
21:57:57 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
21:57:57 <lambdabot> System.FilePath.Posix hasExtension :: FilePath -> Bool
21:58:13 <pumpkin> @hoogle+
21:58:14 <lambdabot> System.FilePath.Windows hasExtension :: FilePath -> Bool
21:58:14 <lambdabot> System.FilePath.Posix hasTrailingPathSeparator :: FilePath -> Bool
21:58:14 <lambdabot> System.FilePath.Windows hasTrailingPathSeparator :: FilePath -> Bool
22:05:26 <kadaver> which returns True for C:/progs/?
22:07:56 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html#v%3AdoesDirectoryExist
22:09:09 <kadaver> im tryign to recursively collect files
22:10:53 <kadaver> but eh
22:11:13 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2812#a2812
22:12:13 <kadaver> if IsDirectory x then getFiles x else x
22:12:13 <kadaver> is the principal
22:12:40 <pumpkin> the else x was lost
22:13:20 <pumpkin> kadaver: so what's wrong with it?
22:13:57 <kadaver> types
22:14:01 <pumpkin> ...
22:15:02 <sjanssen> kadaver: doesDirectoryExist is in the IO Monad, so you need: do d <- doesDirectoryExist x; if d then getFiles x else x
22:15:36 <pumpkin> return x?
22:15:59 <sjanssen> right
22:16:03 <kadaver> can (\x -> a x && b x) be simplified to drop the x somehow?
22:16:15 <sjanssen> liftM2 (&&)
22:16:27 <sjanssen> @pl \x -> a x && b x
22:16:28 <lambdabot> liftM2 (&&) a b
22:16:32 <pumpkin> not sure it's clearer though
22:16:55 <sjanssen> kadaver: you'll need Control.Monad and Control.Monad.Instances imported
22:17:29 <kadaver> but how do i map that?
22:17:32 <kadaver> ormapM?
22:18:11 <pumpkin> mapM (liftM2 (&&) a b) ...
22:20:12 <kadaver> yes
22:20:17 <kadaver> but for diretcorystuff
22:26:00 <pumpkin> kadaver: ?
22:30:42 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2813#a2813
22:30:52 <kadaver> so where od i need expression?
22:31:30 <kadaver> is should be simple
22:31:56 <kadaver> getFiles xs = map (\x -> if isdrectory x then getFiles x else x) xs
22:33:20 <TSC> kadaver: Put a $ after ps
22:33:30 <TSC>   "fs <- forM ps $ \x -> "
22:36:01 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2813#a2814
22:36:20 <kadaver> that helped but stilldoesnt work
22:38:49 <sjanssen> kadaver: return [x]
22:39:30 <sjanssen> and also return (concat fs)
22:41:32 <kadaver> thanks
22:41:41 <kadaver> [x] or x doesnt seme to matter thoug
22:41:46 <kadaver> is [x] for string?
22:42:06 <pumpkin> [x] just means a list with one element
22:42:15 <sjanssen> kadaver: it does matter
22:42:32 <sjanssen> without [] you'll just get all paths concatenated and returned as a single string
22:42:53 <sjanssen> [] will give you a list with each path a separate element
22:55:17 <enoksrd> anybody know where to download the example code in Real World Haskell?
22:55:47 <Saterus> enoksrd: http://www.haskell.org/haskellwiki/Real_World_Haskell
22:56:15 <enoksrd> thanks
22:56:52 <Saterus> enoksrd: np, i'm just surprised someone asked a question i could answer ;)
22:57:39 <enoksrd> :)
23:03:09 <sinelaw> (-1)^(-i) = e^pi   :P
23:03:30 <sinelaw> =~ 22
23:03:34 <pumpkin> zomg
23:04:06 <pumpkin> > (-1 :+ 0) ** (0 :+ -1)
23:04:08 <lambdabot>       precedence parsing error
23:04:08 <lambdabot>          cannot mix prefix `-' [infixl 6] and ...
23:04:24 <pumpkin> > (-1 :+ 0) ** (0 :+ (-1))
23:04:25 <lambdabot>       precedence parsing error
23:04:25 <lambdabot>          cannot mix prefix `-' [infixl 6] and ...
23:04:31 <pumpkin> > ((-1) :+ 0) ** (0 :+ (-1))
23:04:33 <lambdabot>   23.140692632779267 :+ 0.0
23:04:37 <sinelaw> ok, 23...
23:22:18 <ImInYourMonoid> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1969#a1969 <- so there it is
23:22:31 <ImInYourMonoid> a little program to count how many lines of haskell you have written :)
23:27:40 <Merito12> Anyone can give me some information about pseudocode and flowchart how to build a flowchart and how to make a pseudocode from it
23:28:22 <pumpkin> Merito12: uh... is this related to haskell? :)
23:28:49 <TomMD> Sounds like software engineering - is there a general channel for that?
23:29:01 <Merito12> no
23:29:09 <Merito12> or is there a channel
23:29:15 <pumpkin> just curious because the idea of a flowchart seems to not mesh very well with declarative code
23:29:21 <TomMD> At any rate, the answer to your question is 'True'
23:30:04 <dolio> Depends on your interpretation of "any".
23:30:21 <TomMD> There was no stipulation that the information be useful.
23:30:28 <dolio> Heh.
23:30:35 <TomMD> On the other hand, it might depend on what you call information.
23:32:00 <ImInYourMonoid> @faq can haskell write you a flowchart,get you laid and mix you a white russian at the same time ?
23:32:01 <lambdabot> The answer is: Yes! Haskell can do that.
23:43:48 <wli> This codebase is a trainwreck. Maybe I should start over yet again.
23:44:37 <dons> this is very cool http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SGdemo-1.0
23:50:56 <wli> I should probably start from a base of primops so I can carry things all the way through to evaluation.
23:51:03 <vegai> dons: nice
23:51:51 <dons> not sure what its doing. but cool to see new pure graphics apps
23:51:54 <vegai> I could see a clone of Quantum written on that some day
23:52:11 <vegai> quantum being a clone of dyson :) http://apistudios.com/hosted/marzec/quantum/
23:52:54 <dons> oh, yes.
23:53:06 <dons> you should ping neil brown with that suggestion :)
23:55:43 <dons> http://www.youtube.com/watch?v=tJ6AtfcorkY
23:55:46 <dons> is what we're talking about
