01:20:50 <matthew-_> ivanm: no doebt you're going to remind me that you sent me some patches and I've done nothing with them so far
01:20:51 <lambdabot> matthew-_: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:21:38 <matthew-_> right, re the new polyparse api, I hit that the other day. That's just import changes and nothing more
01:22:13 <matthew-_> ironically enough, I have a parser for dot-generated dot files already as part of another project
01:22:31 <ivanm> heh
01:22:37 <ivanm> using what?
01:22:56 <matthew-_> polyparse
01:24:30 <wli> That's Text.ParserCombinators.Poly, right?
01:26:00 <matthew-_> yup
01:26:17 <matthew-_> ivanm: it's very likely I'll sort out this package real soon now as I'm actually using it again
01:26:53 <wli> parsely sounded interesting somehow but I forget how
01:26:54 <ivanm> \o/
01:27:35 <matthew-_> anywho, I need to go breakfast scavenging
01:27:38 <matthew-_> I'm at etaps right now
01:28:08 <ivanm> what's etaps?
01:28:23 <matthew-_> @go etaps 2009 york
01:28:25 <lambdabot> http://www.cs.york.ac.uk/etaps09/
01:28:25 <lambdabot> Title: ETAPS 2009
01:29:14 <ivanm> ahhh, OK
01:29:26 * ivanm is hacking on latin square stuff atm
01:30:15 * wli runs into http://www-fp.dcs.st-and.ac.uk/~kh/papers/io-tutorial/io-tutorial.html
01:37:25 * wli discovers http://www.cs.uwindsor.ca/~hafiz/proHome.html
01:47:11 <lepassive> any python implementation in Haskell?
01:47:35 <lepassive> I found that GvR is a great fan of Haskell btw
02:05:57 <wli> Not sure but I wouldn't be surprised if there were one.
02:08:35 * wli thinks he's got ideas for grammar construction combinators.
02:16:40 <psygnisfive> wli: do tell
02:24:19 <kyagrd> Can we specify data file names with space in .cabal file?
02:25:58 <kyagrd> oh "file name" works
02:37:21 <wli> psygnisfive: Just do the same thing these guys are doing for parser combinators: use the nonterminal as a memoization key.
02:50:49 <ivanm> is it possible to define a class on types a and b, such that it has class functions toFoo :: a -> Foo, and fromFoo :: Foo -> b ?
02:51:12 <jedai> ivanm: Yes
02:51:24 <ivanm> how
02:51:25 <ivanm> ?
02:51:28 <jedai> It's multiparameter-class
02:52:10 <ivanm> jedai: a and b aren't parameters of another type...
02:52:42 <jedai> On the other hand, those functions aren't very nice since each only works on one of the two types parameters, so it would make more sense to have two classes
02:52:57 <jedai> ivanm: That's not a problem
02:53:44 <ivanm> well, the reason I want them in the same class is that I'm implementing a solver, which finds all possible values b for a given value a
02:53:49 <jedai> "class Stuff a b where stuffFun :: a -> b" is a valid class with the extension
02:54:31 <ivanm> hmmmm..... with the functional dependency extension as well?
02:54:33 <jedai> ivanm: I don't see why the class is needed or why you have two function
02:54:57 <jedai> ivanm: fundeps are one way to add a little structure to those class
02:55:09 <jedai> you also have type families
02:55:19 <ivanm> jedai: because I have a common class of problems that use Foo as a solver (with various intermediary functions on Foo)
02:55:46 <ivanm> (actually, they're the same problem, just at different stages of solving)
02:58:49 <ivanm> OK, type families don't look like what I want (mainly because I don't understand what they are :p )
02:59:43 <jedai> The class such as you describe it seems utterly useless
03:00:00 <ivanm> it's only for internal purposes...
03:00:10 <jedai> Also, consider the possibility to add a phantom type to Foo, it could help
03:00:29 <ivanm> OK, I"ll explain what I'm doing: I'm wanting to generate [Partial] Latin squares
03:01:44 <ivanm> the way I'm doing it is to generate a "shape" which indicates where to put values, then convert this to a solver type which fills in the values
03:02:16 <ivanm> these are then generated to the PartialLatinSquare type
03:02:32 <wli> GADT's help with phantom types
03:02:43 <ivanm> to complete a PartialLatinSquare, I use the solver type again (but tell it to fill in the rest of the values), which results in a LatinSquare value
03:03:01 <ivanm> wli: phantom types?
03:04:49 <wli> barfing
03:04:59 <jedai> ivanm: data Something a = One | Two
03:05:11 <ivanm> ahhh
03:05:16 <ivanm> where the a is absolutely useless?
03:05:28 <ivanm> wli: by "barfing", you mean what you said isn't relevant?
03:05:32 <jedai> ivanm: Yes, except for typechecking and inference
03:05:51 <ivanm> *nod*
03:06:21 <jedai> ivanm: As I suggested, you could add such a phantom type to your solver to indicate where it comes from, your class then start to make sense
03:06:43 <ivanm> ahh, missed that bit
03:06:49 <ivanm> hmmm...
03:07:22 <jedai> As it is as I said, putting the two functions in one class is senseless, even if you add fundeps
03:07:36 <ivanm> why?
03:08:07 <jedai> there is no relation between them, one works only with the b type, and one works only with the a types
03:08:50 <ivanm> well, the way I want to _use_ them will work (it will be of type a -> [b])
03:09:09 <jedai> Thus you could as well use explicitly different function since the only way Haskell is going to guess which instance to use is to put it explicitly as a type annotation
03:09:33 <jedai> ivanm: No, it won't work... They don't make sense
03:10:20 <ivanm> why not? solve :: (FooClass a b) => a -> [b]
03:10:32 <jedai> If you just want to combine them to get a "a -> [b]" function I fail to see where they're useful, you could as well write this latest function directly
03:10:55 <jedai> Ok, so make solve a function of your class
03:11:23 <ivanm> jedai: the solve function is independent of the class, it just uses the toFoo and fromFoo
03:12:40 <ivanm> damn, hpaste.el doesn't work with latest hpaste :(
03:12:45 <jedai> ivanm: Sooo here we are again, why isn't this "class" two class instead ?
03:13:01 <ivanm> jedai: because there's a dependency between a and b
03:13:16 <jedai> What dependency ?
03:13:59 <ivanm> jedai: I have Shape -> PLS and PLS -> LS; I _could_ have Shape -> LS, but not all Shapes are valid
03:14:11 <ivanm> that last requirement is why I need one class
03:14:46 <jedai> With a dependency and a phantom type in the solver we can make this one class
03:15:12 <ivanm> how?
03:15:38 <jedai> Something like class FooClass a b | a -> b where toFoo :: a -> Foo a; fromFoo :: Foo a -> b
03:16:03 <ivanm> jedai: ahhh, OK
03:16:20 <ivanm> that would require 3 extensions, right?
03:16:41 <jedai> You need the extension Multiparameter class and Fundeps, but I think Fundeps alone will pull the other
03:16:54 <ivanm> yeah
03:17:09 <ivanm> but I'd also need the GADT extension for the phantom class, right?
03:17:15 <jedai> and I don't remember if phantom types are an extension
03:17:24 <jedai> ivanm: You don't need GADT
03:17:35 <ivanm> s/GADT/Phantom/
03:17:55 <Heffalump> phantom types are H98
03:18:04 <ivanm> oh, OK
03:18:11 <ivanm> Heffalump: a non-extension for once? :o
03:18:12 <ivanm> ;-)
03:18:30 <ivanm> Heffalump: is that only because there's nothing "naughty" about it?
03:18:34 <jedai> Heffalump: It seemed like an artificial limitation to the type system if they weren't but thanks for the confirmation :)
03:19:05 <Heffalump> ivanm: sort of :-)
03:22:35 <mjk> i want to get a random list
03:23:11 <mjk> use the following func:drawInt x y = getStdRandom (randomR (x,y))
03:23:21 <mjk> the type is drawInt :: Int -> Int -> IO Int
03:24:52 <mjk> but i want to use drawInt to get a [Int], [IO Int] -> [Int], or IO Int -> Int
03:25:17 <mjk> can you help me?
03:25:50 <ivanm> mjk: randoms
03:25:55 <ivanm> or randomRs
03:26:14 <mjk> how to do IO Int -> Int?
03:26:18 <ivanm> you don't
03:26:45 <ivanm> you call newStdGen in your IO monad, pass it through to your pure function which calls random[R]s
03:27:00 <ivanm> note that random[R]s doesn't give back another seed, so you might have to split it before that
03:27:15 <mjk> can you give me a sample?
03:30:05 <ivanm> mjk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2992#a2992
03:30:09 <ivanm> something like that
03:30:15 <ivanm> I've probably got the wrong module being imported
03:30:24 <ivanm> whatever happened to the hpaste bot? :s
03:30:32 <mjk> ivanm: OK, thanks
03:31:53 <ivanm> RWH is on google books :o
03:36:48 <Baughn> Is it normal to start /every/ file with "import Control.Applicative; import Control.Monad"? And if so, shouldn't at least some of those be in the prelude?
03:36:50 <ITX> can Haskell be used for xbox 360/ps3 apps?
03:37:13 <ivanm> Baughn: I've never used Applicative...
03:37:27 <Baughn> ITX: Sure. Not necessarily easily, but..
03:37:51 <Baughn> ITX: Umh. The XBox 360 should be fairly easy; that's just a variant of windows, and porting ghc there should be nearly trivial.
03:38:15 <ITX> kk
03:38:39 <idnar> Baughn: nearly trivial? I'd imagine there'd be a fair amount of backend work
03:39:03 <ITX> just for game development career (hopefully) im really now debating over c# and haskell :P (again)
03:39:10 <Baughn> ITX: The PS3 might just fall under "linux/ppc", which is.. not supported, but both linux and ppc are individually. So, about the same amount of work, probably.
03:39:24 <idnar> oh, well, I suppose there's already PPC support
03:39:30 <idnar> (?)
03:39:32 <Baughn> idnar: Well, I don't know how similar the xbox's version of windows is to the standard version, really
03:39:43 <idnar> Baughn: I was thinking more of the hardware, not the software
03:40:12 <Baughn> Oh, right, they switched to PPC for the 360, didn't they?
03:40:26 <Baughn> Hmm. So exactly the same as the PS3 then, really
03:40:31 <idnar> well, it's some weird three core Cell variant
03:40:44 <Baughn> There are also interpreters and such (hugs, say) that should be  considerably easier to get working
03:41:01 <Baughn> idnar: You don't /have/ to use the Cell chips
03:41:12 <idnar> Baughn: what else are you going to use?
03:41:15 <ITX> because when I go to college i'll be taking maths and further maths, and i hear haskell ++ math = nooiceee
03:41:23 <idnar> Baughn: that's the only CPU you get on the 360 :P
03:41:37 <Baughn> idnar: The PPC chip?
03:41:58 <p_l> there's 3 POWER chips in x360, with some additional instructions
03:42:01 <idnar> Baughn: yes
03:42:12 <idnar> the Xenon
03:42:18 <Baughn> Wait a minute..
03:42:56 <Baughn> idnar: The real problem with the PS3's cell chips is that they can't access main memory directly.
03:43:01 <Baughn> Is that still the case for the Xenon?
03:43:18 <idnar> Baughn: that would mean there would be no way to access main memory at all
03:43:22 <idnar> Baughn: so presumably not :P
03:43:46 <Baughn> idnar: You could still be able to access it the same way as on the ps3 chips. :P
03:43:53 <vixey> The next program will stretch your brains even more. The program will compute the factorial of a number.
03:43:53 <idnar> Baughn: the only processors in the Xbox 360, so far as I understand it, are the Xenon (3-core PPC chip) and the Xenos (ATi-designed GPU)
03:45:09 <idnar> Baughn: the PS3 has 1x PPE and 7x SPE or something
03:45:50 <p_l> the PPE supports similar instruction set to PPC970... and wasn't it dual-core, btw?
03:45:53 <idnar> Baughn: as I understand it, the cores in the Xenon resemble the PPE, not the SPE
03:46:07 * edwardk finally finished slogging through adding documentation to http://comonad.com/haskell/monoids/dist/doc/html/monoids/index.html
03:46:26 <p_l> Baughn: Xenon is classic 3-core (each with 3 SMT) SMP cpu
03:47:14 <ITX> would i have to be a Haskell mastermind to make a game compared to say c# game?
03:47:27 <Baughn> It sure wouldn't hurt. ;)
03:47:34 <vixey> ITX: You can implement mastermind in Haskell easily
03:48:09 <edwardk> ITX: not necessarily a mastermind, but its a little trickier than in C# using, say, XNA because there are fewer frameworks
03:49:25 <ITX> kk, im just debating, making games with haskell wud probs be cool, but idk what to do :/
03:51:15 <edwardk> Baughn: there is a fair chunk of support for the ps3 cell cpu. iirc anand has a haskell DSL for generating fast code to run on them, and shapr spends a lot of time running haskell on his ps3. ;)
03:51:45 <edwardk> mainly in preparation for when he can get his cell-based ibm- bladeserver successfully powered up in his apartment
03:53:20 <ITX> by the way, has anyone in here made a simple game in haskell? if so then could i have a peek at the sourcE?#
03:54:20 <edwardk> ITX: skim http://darcs.haskell.org/ there is bound to be a few in there
03:54:54 <vixey> yo
03:55:54 <trofi> shu-thing? :]
03:57:17 <hamishmack> jedai: You know that <ctrl>space problem you had in Leksah the other day?
03:58:03 <Baughn> So, hang on - if a forkIO'd thread dies with some error, the program as a whole /doesn't/ get killed?
03:58:15 <Baughn> Is that reliable?
03:58:22 <hamishmack> jedai: I found something in the way we were handling <ctrl>tab that may have prevented the key release for ctrl from being processed
03:59:46 <hamishmack> jedai: If you have a chance can you try out darcs http://code.haskell.org/leksah-head
04:01:29 <hamishmack> jedai: with the line from data/Default.keymap replaced in your ~/.cabal/share/leksah-0.4.3/data/Default.keymap
04:02:11 <edwardk> does anyone know why all my instances show up twice in http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Reducer.html ?
04:02:20 <edwardk> er almost all
04:02:42 <edwardk> multiple exports/imports?
04:06:18 <leafw> can haskell be installed from ubuntu synaptic package manager? There's no obvious package name
04:06:40 <vixey> leafw: Yeah look for ghci
04:06:56 <leafw> vixey: thanks
04:07:14 <dobblego> ghc6
04:07:49 <leafw> it's unfortunate that the package name is not just "haskell", which is not in use
04:07:52 <leafw> thanks
04:10:24 <blygis> So. dons @ /reddit/haskell/, is that Don Syme?
04:10:52 <arjanb> no
04:11:00 <blygis> ok
04:12:51 <edwardk> don stewart
04:16:35 <trofi> am i alone having troubles with HsSyck ?
04:16:46 <trofi> Prelude Data.Yaml.Syck> parseYaml "a: {}" >>= emitYaml >>= putStrLn -- returns me complete garbage
04:18:15 <kadaver> so oen thing, does haskell,python,other high level langs have short ints? because thats quite significant if you know you only need short ints thats halving the memory use right there...
04:18:28 <Martijn> Good morning
04:18:38 <trofi> Data.Int ?
04:19:19 <trofi> @hoogle Word8
04:19:20 <lambdabot> Data.Word data Word8
04:19:20 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
04:19:29 <TSC> > 12 :: Int16
04:19:30 <lambdabot>   12
04:19:40 <TSC> There are fixed-width integers
04:21:11 <kadaver> ok
04:21:27 <Baughn> Not to mention unboxed arrays for the fixed-width integers
04:21:46 <trofi> (or FFI)
04:26:32 <wli> ISTR a package with larger integers as well.
04:26:45 <wli> e.g. Word256
04:27:12 <wli> e.g. Float256 might be nice.
04:27:52 <idnar> Word1048676 !
04:27:52 <Baughn> wli: We've got.. at least one of those. Two, I think.
04:27:55 <Baughn> Hang on
04:27:57 <idnar> er
04:28:00 <idnar> Word1048576
04:28:25 <Baughn> http://hackage.haskell.org/packages/archive/Crypto/4.2.0/doc/html/Data-LargeWord.html
04:30:10 <wli> cabal installing now
04:31:55 <wli> It only seems to go up to Word256.
04:32:22 <Baughn> wli: No, check the type definitions
04:32:40 <Baughn> I don't think there's anything stopping you from saying "type Word512 = LargeKey Word256 Word256" or so
04:33:01 <idnar> there's no Num instance, though
04:33:07 <kadaver> hmm 2d to 1d is m[r*c+c] = M[r][c] right?
04:33:19 <Baughn> idnar: There is. (Ord a, Bits a, LargeWord a, Bits b, LargeWord b) => Num (LargeKey a b)
04:33:31 <idnar> oh, whoops; I must have made a typo when I searched
04:34:23 <thomastc> kadaver: shot in the dark, don't know what you're doing, but maybe m[r*num_cols + c] on the left hand side?
04:35:18 <wli> They're missing signed analogues. Floating point of a similar nature is probably way too much to hope for.
04:38:22 <wli> It seems the trick they use to define arbitrarily large integers in terms of smaller ones is applicable neither to floating point nor signed integers.
04:39:12 <wli> Actually signed could probably be done.
04:40:23 <profmakx> you want arbitrary precision floats?
04:40:42 <wli> Multiple precision floats.
04:41:00 <wli> e.g. Float128, Float256, etc.
04:41:01 <profmakx> ah, like Float128
04:44:25 <wli> They're helpful for when you need to calculate approximations that work for double precision but must have their parameters computed to the minimum error possible in a double-precision representation.
04:44:56 <wli> Like Remez approximants.
04:47:27 <wli> There are other situations where you need to accumulate/etc. in double the precision of your result to get the full precision of the result.
04:51:24 <RayNbow> > let avg = foldMap (Sum &&& const (Sum 1)) >>> join (***) getSum >>> uncurry (/) in avg [1..10000] -- testing...
04:51:25 <lambdabot>   Not in scope: `foldMap'
04:51:41 <RayNbow> @let foldMap f xs = Data.Foldable.foldMap f xs
04:51:44 <lambdabot>  Defined.
04:51:47 <RayNbow> > let avg = foldMap (Sum &&& const (Sum 1)) >>> join (***) getSum >>> uncurry (/) in avg [1..10000] -- testing...
04:51:48 <lambdabot>   5000.5
04:52:18 <ITX> is there a way I can check a strings length? like .length or something?
04:52:35 <vixey> ITX: haha no
04:53:03 <ITX> whats with the haha?
04:53:38 <ITX> length [1,2,3] gives 3..
04:53:46 <RayNbow> > length "hello world"
04:53:48 <lambdabot>   11
04:53:55 <dolio> @seen Heffalump
04:53:55 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 1h 34m 53s ago.
04:54:05 <ulfdoz> Can you prove, that it works for other strings? ;)
04:54:17 <ITX>  > length "maybe i can"
04:54:23 <ITX> ugh
04:54:26 <RayNbow> > "hello" :: [Char]
04:54:27 <lambdabot>   "hello"
04:54:30 <ITX> > length "lol"
04:54:31 <lambdabot>   3
04:54:35 <ski> @check \s -> length (s :: String) == 11
04:54:36 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\798344\\476029\"\n"
04:54:55 <Eridius> that's an interesting first string to test
04:55:06 <TSC> That's the string I would have checked first
04:55:28 <ITX> I might get RWH soon
04:55:31 <Eridius> oh clearly, I just didn't realize QuickCheck had the foresight
04:59:18 <ITX> is: module LOL where == :s prompt "LOL" when you :l file ?
05:00:15 <evident> hey everybody... I am getting an error on a little script:
05:00:16 <evident> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=2996#a2996
05:00:22 <evident> can anybody help me there?
05:00:58 <evident> I dont understand why the inferred type is not general enough
05:01:24 <evident> why does it matter to the "bubble" function that it gets a list of tuples instead of just a normal list?
05:01:37 <Deewiant> The type you've specified for bubble is more general than its actual (inferred) type
05:01:49 <ITX> lol :: (Num a) => .. do I need the parenthesees?
05:02:13 <ski> no
05:02:19 <ITX> it works fine without them just, is it the standard or w.e?
05:02:30 <Deewiant> You've said that it works for any [a] but actually it needs to take a list of pairs
05:02:40 <Deewiant> ITX: If you have more than one type class you need the brackets
05:02:48 <Deewiant> (Num a, Num b) =>
05:02:55 <evident> ahh because in it I use the "wert" function which only works with tuples, right?
05:03:01 <Deewiant> evident: Yep.
05:03:05 <evident> ahhh
05:03:08 <evident> i c
05:03:08 <evident> :)
05:05:44 <evident> do you have any idea how i can fix that?
05:06:35 <Deewiant> Change your type signature, the compiler's giving you what it thinks is right so that might be a good place to start ;-)
05:07:02 <kadaver> can you transpose a matriux inplace? you could by just copying [x][y] to tem and and thens withc them right?
05:07:25 <evident> hmm ok... but it then gave me an error in the other function... well I'll try to find a way
05:07:31 <evident> thanks for your help so far
05:07:39 <Deewiant> I do think the inferred type looks a bit weird
05:18:15 <vixey> hah
05:18:18 <vixey> failed during the building phase. The exception was: exit: ExitFailure 1
05:18:41 <vixey> oh that's not all it also says: cabal: Error: some packages failed to install
05:19:35 <Mortomes> This might be the wrong channel to ask in, but when I'm trying to install wxhaskell on windows using the .bat, I get this error: error: Unable to find the wxHaskell packages (bin\wx.pkg) Maybe the installation directory is not properly specified?
05:20:17 <Mortomes> I have ghc 6.10.1 installed and am trying to install wxhaskell 0.11.0
05:21:42 <wli> kadaver: Yes, matrices can be transposed in-place.
05:23:43 <kadaver> wli: hmm it is easy for square matrices but if I want to transpose a 4*3 it is a bit trickier no? dont ui have to malloc a new one?
05:24:31 <Saizan> the space occupied is the same, you just have to interpret it differently
05:24:57 <wli> kadaver: Maybe. A better approach is probably to carry around some extra descriptions of the matrix and flip a tag bit that says whether it should be treated as normal or transposed.
05:27:44 <wli> e.g. keep the nonzero elements of the matrix in an open-addressed hashtable and use a wrapper API to find hashtable positions.
05:33:29 <wli> It helps a little with sparse matrices, though I think some other indices are needed to search for things in particular rows and columns.
05:35:29 <wli> The same thing probably works with just the single index and filtering the results in the probe sequence if they're for the wrong row/column/etc.
05:36:03 <wli> ergh
05:36:37 <wli> The same thing works with just the single integer search key, that is, vs. the pair of integers acting as a search key for the full matrix.
05:38:32 <wli> Another possibility might be using Data.Map where otherwise the arrays and/or hashtables are involved.
05:39:15 <jeltsch> Hello, are there some people who know Gtk2Hs a bit?
05:39:53 <jeltsch> I’d like to know whether there’s a difference between using a tree view directly and putting a tree view into a scrolled window where scrollbars are disabled.
05:44:56 <fxr_> did anybody tried to port ghc to dragonflybsd?
05:54:11 <ITX> btw why CAN'T you change var values in Haskell?
05:54:35 <vixey> ITX: that would ruin everything
05:55:22 <ITX> how is that? how would you move a person in a game? e.g. person.locationx++; ?
05:55:26 <mauke> ITX: you can if you're in IO or ST
05:55:37 <vixey> ITX: you dont' write "person.locationx++;" lol
05:55:46 <vixey> that's definitely not haskell
05:55:49 <mauke> ITX: oh, for that you could simply make a new person
05:55:51 <ITX> thats an example for a diffdo language
05:55:55 <ITX> *diffo
05:56:00 <mauke> *different
05:56:06 <ITX> ^^
05:56:27 <wli> person . location ++ is potentially Haskell.
05:56:29 <ITX> so for every new movement there would be a new person? surewly that would be memory consuming>
05:56:30 <kadaver> yes [row*tot_columns+column]
05:56:37 <mauke> ITX: why?
05:56:39 <ehamberg> it's another way to think. it takes getting used to.
05:56:40 <kadaver> yes [row*(tot_columns-1)+column] that is
05:57:07 <ITX> you'd have illnummerable people's? unless you could destroy old ones?
05:57:25 <maltem> ITX: We have a garbage collector that does the work for us
05:57:27 <mauke> unreachable objects are destroyed automatically
05:58:27 <ITX> ah (:
05:58:33 <wli> kadaver: That's a dense representation.
05:58:44 <ITX> ill get real world haskell some time, read it then hopefully be quite good at haskell (:
05:59:15 <maltem> Er, you do know it (and various other Haskell introductions) are available online?
05:59:40 <ITX> yeah i know
05:59:49 <ITX> lyah etc
06:00:05 <ITX> i came to haskell few months ago then went back to c#, then forgot the haskell bit :P
06:00:18 <ITX> so now I can do like really really basic functions
06:00:53 <Mortomes> This might be the wrong channel to ask in, but when I'm trying to install wxhaskell on windows using the .bat, I get this error: error: Unable to find the wxHaskell packages (bin\wx.pkg) Maybe the installation directory is not properly specified?
06:00:56 <Mortomes> I have ghc 6.10.1 installed and am trying to install wxhaskell 0.11.0
06:01:13 <wli> I think using the probe sequence in open addressing to enable iteration over rows and columns works.
06:02:49 <ITX> how comes: module LOL where        gives *LOL>       in ghci, i mean why an asterisk?
06:02:49 <Saizan> Mortomes: i think you'd have more luck asking on haskell-cafe, with as much relevants details as you can
06:03:10 <Saizan> Mortomes: the mailing list i mean
06:03:23 <Mortomes> Ok, I'll try that, thanks
06:04:23 <Saizan> Mortomes: or wxhaskell-devel@lists.sourceforge.net
06:04:24 <kpreid> ITX: the asterisk results from using :load rather than :m -- it means you can access the unexported definitions, at least
06:05:38 <mauke> ITX: it means ghci is using the source, not compiled object code
06:06:39 <maltem> Heh, it's unfortunate that f' is a valid Haskell identifier - it makes me wish that f* were, too
06:12:31 <Baughn> Or f"
06:15:53 <maltem> Yay for mandatory spaces between, and arbitrary characters within identifiers ;)
06:18:03 <ray> why would you want f" when you can get f''
06:20:30 <Baughn> ray: So I can have a program with both f" and f''
06:20:48 <Baughn> ray: Oh, and f"' too
06:20:54 <ray> for the obfuscated haskell contest
06:20:55 <EvilTerran> and f'"?
06:20:58 <Baughn> Yes
06:21:01 <EvilTerran> eeew
06:21:11 <Baughn> f"", of course, would parse as f ""
06:21:22 <EvilTerran> and f'"' as f '"' ?
06:21:29 <Baughn> You got it!
06:21:29 <dolio> > length"foo"
06:21:30 <lambdabot>   3
06:21:36 <EvilTerran> or f' "'...?
06:21:39 <maltem> and f"' "x"? ahh!
06:23:05 <ivanm> anyone know why ghc-pkg check keeps saying "package Chart-0.10.2 has missing dependencies:" (without saying what those dependencies are) even after I've successfully rebuilt it (from darcs)?
06:23:46 <Baughn> ivanm: It lists all the missing dependencies, actually
06:23:48 <Baughn> All none of them
06:23:59 <Baughn> ..I've seen that error before, but I don't recall what it was
06:24:05 <ivanm> ummm..... so if it isn't missing any dependencies, what's wrong with it? :s
06:24:47 <ivanm> I've seen it for stuff when I installed cabal-1.6.0.2 and unregistering the cabal shipped with ghc-6.10.1...
06:24:52 <ivanm> but I don't think that's the case here :s
06:33:42 <ivanm> gah, I had an error with process and thought that might be why chart is having problems... but that's not it! :@
06:34:47 <sw17ch> is there a standardized way to access "user" data from a haskell program?
06:34:54 <sw17ch> something preferrably cross platform?
06:35:09 <Baughn> @pl \a -> do foo a; bar a
06:35:09 <lambdabot> (line 1, column 15):
06:35:09 <lambdabot> unexpected ";"
06:35:09 <lambdabot> expecting variable, "(", operator or end of input
06:35:14 <sw17ch> something like data-files in cabal
06:35:18 <Baughn> @pl \a -> foo a >> bar a
06:35:18 <lambdabot> liftM2 (>>) foo bar
06:35:39 <lxuser_> sw17ch, use the windows registry
06:35:57 <sw17ch> lxuser_, ouch
06:36:00 <Baughn> @type liftM2 (>>) foo bar
06:36:01 <sw17ch> especially since this is linux
06:36:03 <lambdabot> Not in scope: `foo'
06:36:03 <lambdabot> Not in scope: `bar'
06:36:18 <ivanm> sw17ch: define "user data"
06:36:24 <Baughn> @type liftM2 (>>) getLine getLine
06:36:25 <lambdabot> IO [Char]
06:36:35 <Baughn> @type (>>) <$> getLine <*> getLine
06:36:36 <lambdabot> IO [Char]
06:36:39 <sw17ch> ivanm, i'm hoping for something that will point me to an AppData directory on windows, or ~/.[foo] on Unix
06:36:51 <ivanm> there isn't one
06:36:56 <sw17ch> ivanm, i didn't think so :(
06:36:58 <mauke> sw17ch: yes, we have that
06:37:06 <ivanm> gnome has something like that, xfce's latest version does, etc.
06:37:08 <sw17ch> mauke, ivanm, fight!
06:37:20 <ivanm> but each app has its own ~/.blah directory
06:37:29 <ivanm> though it's becoming standard to use ~/.config/blah
06:37:31 <ivanm> mauke: oh?
06:37:33 <mauke> sw17ch: http://haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html#v%3AgetAppUserDataDirectory
06:37:33 <sw17ch> mauke, elaborate?
06:37:38 <ivanm> what do you mean?
06:37:46 <ivanm> mauke: oh, I thought sw17ch meant for _all_ apps
06:38:01 <sw17ch> ivanm, no, i want a unique directory for *this* app :)
06:38:07 <sw17ch> mauke++
06:38:08 <ivanm> sw17ch: use ~/.foo
06:38:09 <sw17ch> perfect
06:38:11 <ivanm> *shrug*
06:38:37 <ivanm> ahh, which is what that function does
06:38:39 <sw17ch> ivanm, thanks any way :)
06:38:48 <sw17ch> i kept thinking something like this *had* to exist
06:38:50 <ivanm> sw17ch: note there's no real _standard_ way of defining such a thing
06:39:01 <sw17ch> ivanm, true, but there is a way
06:39:02 <sw17ch> :)
06:39:05 <ivanm> and you have to create that directory first
06:39:10 <ivanm> (if it's for your app)
06:39:12 <sw17ch> which is fine
06:39:27 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html#v%3AcreateDirectoryIfMissing
06:39:40 <ivanm> mauke: heh
06:40:14 <sw17ch> mauke, perhaps you have something that will finish the rest of this program for me as well? :)
06:40:16 <ivanm> mauke: so you could do: createDirectoryIfMissing . getAppUSerDataDirectory  kind of thing (obviously . doesn't work here)
06:40:24 <ivanm> ?
06:40:30 <mauke> yeah
06:40:41 <ivanm> see, there needs to be a FilePath version of getAppUSEr.... etc.
06:40:55 * ivanm wonders what that returns for Windows 98 vs XP vs Vista
06:41:05 <mauke>         dir <- getAppUserDataDirectory "miniplex"
06:41:05 <mauke>         createDirectoryIfMissing False dir
06:41:09 <mauke> (actual code)
06:41:35 <ivanm> oh, wait, the first function only fails if the _users_ directory doesn't exist
06:41:41 <sw17ch> @pl (\s -> createDirectoryIfMissing False $ getAppUserDataDirectory s)
06:41:41 <lambdabot> createDirectoryIfMissing False . getAppUserDataDirectory
06:41:43 <ivanm> I thought it was if the app's directory doesn't exist :s
06:42:01 <ivanm> sw17ch: note the getApp... is IO, so that won't work
06:42:16 <ivanm> you'll need to use do-notation like mauke did, or de-sugar it and use >>=
06:42:37 <sw17ch> right
06:43:21 <sw17ch> sweet
06:50:35 <ivanm> _roconnor_: you just wanted your name centered and emphasised, did you? :p
06:52:15 <insane> is there anyone who i can discuss summer of code application with?
06:52:31 <Badger> I believe
06:52:34 <Badger> #haskell-soc
06:56:02 <ivanm> Badger: what do you believe?
06:57:13 <Badger> in the power of #haskell-soc to unite GSoC people :)
06:57:38 <ivanm> heh
06:57:47 <ivanm> ohly haskellian GSoC people, presumably
06:58:24 <solidsnack> What is ℘ ? (\wp in TeX, see http://www.math.union.edu/~dpvc/jsMath/symbols/ord.html)
06:58:43 <ivanm> solidsnack: presumably the symbol used to denote an empty list in people who texify their code
06:59:25 <solidsnack> In mathematics, why would people use a script capital letter P for that?
06:59:53 <Baughn> I don't suppose "mathematicians are weird" will do?
06:59:59 <ivanm> solidsnack: for what?
07:00:10 <ivanm> the script capital P is for powerset, isn't it?
07:00:56 <solidsnack> ivanm: Aha, thank you.
07:01:58 <solidsnack> It is the "Weierstrass p" and is in fact a lower case p -- however, the original error in the unicode standard was not corrected.
07:02:33 <solidsnack> Turns out it is on Wikipedia. http://en.wikipedia.org/wiki/%E2%84%98
07:04:37 <maltem> At least with my font, ℘ indeed doesn't look very capital
07:05:23 <maltem> oh I see, it is supposed to be lower case
07:06:09 <solidsnack> maltem: The reason I called it a capital p is because I found a name for it by looking it up in a Unicode code table -- where it is mislabeled as a capital p.
07:06:44 <maltem> solidsnack: yeah I got that by now
07:07:12 <CosmicRay> is it just me or is there no regex substitution in ghc 6.10?  no subRegex or anything?
07:07:13 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
07:07:24 <maltem> oh and the actual script capital p is called "mathematical script capital p" :)
07:07:56 <solidsnack> CosmicRay: It would be in regex libraries, not in GHC 6.10.1 per se.
07:08:13 <CosmicRay> solidsnack: well right, but hoogle doesn't find it
07:08:30 <CosmicRay> nor does the index at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html which includes regex-base, regex-posix, etc
07:09:25 <solidsnack> CosmicRay: http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html#v%3AsubRegex
07:09:36 <CosmicRay> oh it's in regex-compat.
07:09:45 <CosmicRay> @hoogle subRegex
07:09:45 <lambdabot> No results found
07:09:48 <CosmicRay> weird.
07:09:54 <solidsnack> It is weird.
07:10:08 <CosmicRay> and weirder that it's only in regex-compat, not in the new infrastructure.
07:10:12 <CosmicRay> pfft.
07:11:58 <CosmicRay> and, crappily, it doesn't let a pattern match across \n.
07:12:01 <CosmicRay> grr.
07:14:52 <CosmicRay> hrmph.
07:14:59 <CosmicRay> Text.Regex.Posix has the same problem.
07:17:14 <agruman> could someone please explain why ghc prints this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3002#a3002
07:18:09 <mauke> because xs and head xs have different types
07:18:27 <agruman> why doesnt xs have Test2?
07:18:33 <agruman> its defined as that
07:18:37 <mauke> xs :: Test2, head xs :: Test1
07:19:28 <agruman> ah ofcourse
07:23:05 <rittyan1> how to close a file that I read with readFile? or it is closed automagically for me?
07:23:15 <agruman> mauke: thanks for the help
07:23:26 <mauke> it's closed for you when you reach the end of the returned string
07:23:36 <rittyan1> mauke, thanks
07:35:11 <eu-prleu-peupeu> hi
07:35:21 <maltem> rittyan1: It probablyy won't be closed if you don't, though.
07:37:22 <sander__> hi
07:37:32 <sander__> can you use map on an Array instance?
07:39:27 <maltem> @hoogle (a -> b) -> Array i a -> Array i b
07:39:27 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
07:39:28 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
07:39:28 <lambdabot> Data.Array.Base amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
07:41:03 <enkrav> Hello, I got a pattern match failure in a little but not tiny program, ghci tells me "Exception: No match in record selector Parser.valueOf", is there a way to trace the line in the code where the error happened?
07:44:46 <evident> hey everybody: can anyone help me with my error?
07:44:47 <evident> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3003#a3003
07:44:51 <evident> why do I get that?
07:45:14 <evident> I just want to filter every tuple, where the snd of the tuple matches the given Int
07:45:46 <mauke> your 'a' elements must be comparable
07:46:00 <mauke> for some reasons
07:46:18 <mauke> -s
07:46:26 <evident> but why? I dont even want to compare the a's
07:46:27 <evident> :)
07:46:41 <mauke> what's the type of hochwert?
07:47:11 <evident> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3003#a3003
07:47:13 <evident> oops
07:47:20 <evident> hochwert :: Ord a => [(a,Int)] -> Int
07:47:20 <evident> hochwert list = snd (last (bubble list))
07:47:26 <mauke> there you go
07:47:36 <mauke> hochwert requires Ord a
07:48:11 <evident> ahh i got it
07:48:22 <evident> i left it out on hochwert first and got the same error
07:48:29 <Baughn> "connectionLoop state{speed = speed-1}" <-- This looks scarily imperative ;_;
07:48:33 <evident> just because i had Ord in the bubble function
07:48:43 <evident> (where I didnt need it anyways)
07:48:52 <evident> so now i took it out everywhere and it works finde
07:48:56 <evident> -d
07:48:57 <evident> thanks!
07:52:53 <maltem> Btw, in evident's collectMax, will "hochwert list" be shared?
07:54:38 <evident> what does "shared" mean?
07:54:49 <mauke> only computed once
07:55:42 <evident> ok so filter doesn't compute it again and again for each element of list, right? That's good...
07:56:16 <maltem> evident: Well that was my question
07:56:33 <evident> well I also wrote a version of the collectMax function which works without filter and and any help functions, so it only walks through the list once
07:56:55 <wli> The n largest?
07:57:44 <evident> wli: yes I want to get the tuple with the highest Int in it (or more tuples as a list, if there are more
07:57:59 <evident> see the revision on my hpaste link for the other version
07:59:44 <nolrai_East> "connectionLoop state{speed = speed-1}" wont work, will it?
08:00:15 <nolrai_East> has the record syntax improved at some point?
08:01:20 <gwern> seems reasonable to me
08:01:35 <Saizan> state{speed = speed state - 1}
08:02:18 <Baughn> nolrai_East: I'm using record wildcards too
08:02:19 <wli> evident: Usually that refers to the n highest, not whatever you're on about. You take the top 10.
08:02:32 <Baughn> nolrai_East: ..although, I think I should move to StateT IO or so
08:02:32 <wli> evident:  or s/10/n/
08:02:56 <nolrai_East> ah
08:02:59 <Baughn> nolrai_East: " let connectionLoop state@(State{..}) = do"
08:03:50 <nolrai_East> that might be a good idea.
08:04:52 <Baughn> I'm not sure. This is very IO-heavy code, so..
08:04:56 <Baughn> @instances MonadIO
08:04:58 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
08:05:07 <rittyan1> is there a way to test memory-efficience of my code? it seems that my code either leaks or just sunoptimal
08:05:27 <Baughn> rittyan1: There are quite a lot of memory profiling tools, if you read ghc's user manual
08:06:53 <Baughn> On the other hand, a type such as "refreshScreen :: State -> IO ()" makes it abundantly obvious that the function doesn't alter the state
08:07:07 <Baughn> ..on the gripping hand, it might be writing directly to the process' memory and doing so anyway
08:07:20 <rittyan1> Baughn, ah... it seems that code works, it's just I am having <2G of memory and need more
08:07:32 <Baughn> rittyan1: *Should* it need that much memory?
08:07:36 <jeffwheeler> Are there any powerful choices for templating (for websites) beyond HStringTemplate (seems fairly weak) and HSX, which Turbinado has suggested it wants to move away from (because it's finicky).
08:07:47 <jeffwheeler> Most queries result in template-haskell. ;)
08:09:38 <rittyan1> Baughn, no I am not sure :) but it is good that it works at all
08:09:46 <Baughn> rittyan1: What does it do?
08:11:28 <nolrai_East> why is "%var" stolen by -XImplicitParams? I cant find a % in the documentation.
08:11:43 <rittyan1> Baughn, "greps" files in parallel, parses grepped stuff and puts it into a structure and then serializes it to json, and dumps to disk
08:12:02 <dolio> % is linear implicit parameters.
08:12:04 <mauke> http://www.haskell.org/pipermail/haskell/2004-January/013495.html
08:12:19 <dolio> Which were supposedly removed, but maybe they didn't remove the syntax.
08:13:18 <Baughn> rittyan1: Hum. Well, I suppose if it does a lot of work in the parser, it might need that much memory
08:13:34 <nolrai_East> huh
08:13:52 <Baughn> rittyan1: I'd look carefully at strictness, though. Laziness works great when you're pulling at data, but when you're reading files you're basically pushing it - not so great.
08:14:28 <rittyan1> what can I do about it?
08:14:58 <Baughn> rittyan1: Well, I'm basically guessing here. ;)
08:15:27 <rittyan1> Baughn, I mean, if I have to read files, there is not much I can do about not reading files, right? :)
08:15:55 <Baughn> rittyan1: Um, to confirm.. rnf the parsed data just before you start writing it out, call performGC, threadDelay a minute or so, then run with +RTS -Sstderr and see how much memory is left alive after that last GC
08:16:12 <Baughn> rittyan1: If it's considerably less than the program actually uses, then you have lazy-thunk buildup issues
08:17:09 <rittyan1> Baughn, I guess that it has to be done in ghci?
08:17:22 <Baughn> rittyan1: I don't see why. You can modify your program to do that.
08:17:34 <rittyan1> ah
08:18:14 <Baughn> rittyan1: (top won't show you memory use correctly, since the ghc rts never actually releases memory back to the OS.. at least, it didn't last I checked)
08:18:30 <rittyan1> Baughn, actually I think that Test.JSON isn't fast enough... I am running a simple script right now (reads json from files, and push that data gathered together to some other file) and it takes helluvalot of time for big jsons
08:18:30 <Baughn> It'll show you maximum memory use just fine, but that's not the goal here
08:18:47 <Baughn> rittyan1: Well, for really /fast/ de/serialization, you want Data.Binary
08:18:58 <rittyan1> I want interlanguage communication :)
08:19:04 <rittyan1> and json suits very well here
08:20:11 <Baughn> rittyan1: One thing you want to look out for is code where you, as an IO action, read some data from somewhere and use some function to combine it with existing state
08:20:26 <kynky> bytestring
08:20:54 <Baughn> rittyan1: That's almost guaranteed to at some point produce a lazy thunk that /would/ do the combining, if only it was forced, which it isn't. Instead you get buildup of chains of those thunks.
08:21:16 <Baughn> Which is what strictness annotations exist to fix. ;)
08:22:14 <rittyan1> aww
08:23:35 <kadaver> how do I know in c which FILE* refers to the keyboard deivce?
08:23:46 <mauke> C has no keyboard device
08:23:55 <Baughn> C may not even have FILE*s
08:24:03 <monochrom> Haha
08:24:05 <mauke> what
08:24:19 <mauke> do you mean a freestanding implementation?
08:24:24 <Baughn> Right ;)
08:24:25 <kadaver> gcc
08:24:33 <kadaver> i was told this by #C
08:24:35 <monochrom> embedded systems won't give you FILE* because it has no use.
08:24:38 <mauke> that's probably not what he's using :-)
08:24:42 <kadaver> and they are tards half of them so i ask ehre
08:24:43 <Baughn> kadaver: So why are you in #haskell asking this, now?
08:24:49 <mauke> kadaver: they were right
08:25:36 <monochrom> You have to be specific which OS your program runs on. And you have to eat the fact that whatever you do it's non-portable.
08:26:00 <Baughn> kadaver: Oh just use System.IO.stdin. That's perfectly portable.
08:26:46 <monochrom> System.IO.stdin does not tell you whether it is from the keyboard.
08:27:14 <Baughn> ..true, you'll want isATTY for that
08:27:31 <mauke> that still doesn't tell you
08:27:43 <Baughn> Sure. The user might be using voice recognition, or..
08:27:49 * Baughn pokes ssh -t
08:28:07 <monochrom> file redirection like myprogggie < /dev/null  # so not keyboard
08:28:07 <mauke> or there could be no user
08:28:29 <monochrom> "I accidentally my keyboard"
08:28:33 <Baughn> Oh, there is a user. Unless an AI is going rampant, there is.
08:28:47 <Baughn> He might not be at the keyboard, but he does exist
08:28:56 <monochrom> lambdabot does that all the time.
08:30:29 <monochrom> If you write GUI programs, you do not use stdin, even when it is attached to the keyboard.
08:31:24 <kadaver> i use windows vista
08:31:37 <trofi> aww
08:32:43 <monochrom> The GUI framework will not tell you where the keyboard is. Instead it says: write your keyboard event handler call-back, give it to me, I will send you keyboard events. You don't access the keyboard.
08:35:05 <Baughn> In the case of SDL, what it says is "I'll send you keyboard events if I feel like it. Sometimes I'll drop KEYUP events."
08:35:35 <Baughn> (Actually, SDL randomly drops events in general. By design.)
08:35:49 <mauke> what kind of design is that?
08:36:26 <trofi> limited message buffer?
08:36:32 <Baughn> Limited message buffer.
08:36:42 <mauke> ☉.☉
08:37:00 <Baughn> It's to ensure SDL uses a fixed amount of memory, apparently, but the buffer is way too small, and.. some events, I do /not/ want to lose.
08:37:10 <olsner> SDL is full of things like that... it's Simple after all
08:37:10 <Baughn> It makes keyboard handling an immense chore
08:37:22 <Baughn> No, what would be Simple is using a Chan
08:41:09 <nolrai_East> @ty Map.insert
08:41:10 <lambdabot> Couldn't find qualified module.
08:41:20 <nolrai_East> @ty Data.Map.insert
08:41:21 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
08:41:36 <nolrai_East> @ty M.insert
08:41:38 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
08:42:18 <kadaver> im not wiritng ugis anyway imjust debugging
08:42:39 <Baughn> Didn't handles/sockets use to have a finalizer to close them if they got lost?
08:43:04 <Baughn> nolrai_East: insertWith' is the strict version..
08:43:09 <kadaver> can you use the same opengl and glut files in c and c++?
08:43:22 <mauke> kadaver: how is that a Haskell question?
08:43:26 <kadaver> are games written in C or C++ generally?
08:43:36 <Baughn> nolrai_East: Though, a WHNF reduce is sufficient to strictify a map.. in keys, mind you. Not values. But that's the same as insertWith' does.
08:44:00 <Baughn> nolrai_East: (That is, a seq, or $!, or Strategies.rwhnf, or similar)
08:44:34 <ehamberg> kadaver: C++, in my experience
08:44:34 <Baughn> kadaver: These days? Written in Lua, more like.
08:44:46 <Baughn> With C++ or C for the inner loops
08:45:31 <Baughn> kadaver: You'll pay a performance cost for using pure Haskell, but chances are you won't notice.
08:45:57 <Baughn> kadaver: And you'd also pay a performance cost for not spending a month implementing a complex algorithm in C++ that you could write in a week in haskell. ;)
08:48:13 <kadaver> a month for oen algorithm? what kind of algorithm would that be?
08:48:37 <blygis> I'd guess some advanced 3D-graphical algorithm
08:48:39 <kadaver> but yeah it is not like im writing halo 4 so i probably will write the faster program in haskell not c
08:49:10 <Baughn> A pathfinding algorithm for a 2000x2000x300 map dealing with dynamic change in terrain and producing perfect paths in considerably less time than A* manages on the same
08:49:17 <Baughn> How's that? ;)
08:49:43 <kadaver> huh?
08:49:47 <pejo> A part of that month is spent for writing tests for your complex algorithm. (Not saying that Haskell eliminates that necessarily).
08:49:51 <Baughn> Though, actually that one took me about three days in haskell, and the C++ programmer I was demonstrating it to got a really horrified look on his face when I suggested using it
08:50:48 <Baughn> kadaver: Even just deciding what to cache, when the map changes dynamically, is pretty hard.
08:51:54 <kadaver> why was he horrified if it was that much better? would haskell put him out of a job?
08:52:12 <Baughn> For example.. DF players like to turn moats on and off, so the connectedness of the map can change, or at least the optimal routes. But I don't want to throw away the previous route /immediately/, since the moat might go away again..
08:52:20 <Baughn> A lot of it was trying to read the mind of the player
08:53:20 <Baughn> kadaver: No, but four hundred lines of fairly dense haskell mixed with logic programming, in a prototype, translates to several thousand - if not tens of thousands of - lines of bug-prone C++
08:54:25 <Baughn> kadaver: And chances are it'd /break/, as the game keeps evolving. So while it might be worthwhile in Haskell, in C++ it's something you'd only do at the end of the project, if then.
08:54:49 <monochrom> If you have longer code, you simply lose confidence in its promise, even though it promises the same thing as shorter code.
08:54:54 <mauke> link the Haskell version into the game :-)
08:55:11 <Baughn> I'd love to, but pathfinders aren't exactly modular things. ^^;
08:55:29 <monochrom> "so simple it obviously has no errors" vs "so complicated it has no obvious errors" thing.
08:56:17 <Baughn> In this case, more like "So complex it takes hours of work and lots of tests to ensure error-freeness". In /haskell/.
08:57:58 <monochrom> I teach students how to write proofs. I show them a short proof, and they are usually tempted to ask, "I have another way, it's longer, does it still get full marks?"  Yes of course, if you make no mistakes you get full marks.
08:58:22 <monochrom> Now tell me with a straight face that if you write 100 lines of proof you make absolutely no mistake. You are not a computer.
09:01:08 <monochrom> Ironically and bafflingly, some people actually reject haskell because it's "terse".
09:01:17 <iago> computers have errors too
09:01:55 <monochrom> Humans have more errors because humans think too much.
09:02:34 <paczesiowa> monochrom: some people actually reject apl because it's "terse".
09:02:35 <maltem> iago: Assuming ideal hardware, their only error is that they do what you tell them to
09:02:59 <iago> maltem, the problem is assume ideal hw
09:03:35 <iago> and anyway, programs made to verify proofs, are done by humans
09:03:49 <kadaver> haskell is expressive and succinct, perl is retard-golfing
09:05:45 <dolio> The trick is to make the programs short enough that you can have confidence in them.
09:05:58 <dolio> Then you can have confidence in the proofs they verify.
09:06:29 <iago> short is good of course
09:06:29 <iago> :P
09:07:59 <Baughn> "Server: <socket: 14>: hClose: resource vanished (Broken pipe)" <-- /proc/pid/fd states that socket 14 is still around, though. So how do I get rid of it, if hClose won't do it?
09:08:35 <mauke> good question
09:08:52 <mauke> sounds like a bug in hClose
09:09:48 * ppavelV6 was at russian haskell discussion at haskell@conference.jabber.ru
09:09:57 * ppavelV6 ashamed he's russian
09:10:13 <monochrom> Don't say that.
09:10:33 <monochrom> If you say that, I have to say I'm ashamed I'm human, too.
09:10:50 <ppavelV6> monochrom: yeah. sometimes i feel the same :)
09:10:50 <EvilTerran> monochrom is human? i thought you were a bot...
09:10:50 <Baughn> mauke: "Performing hClose on a handle that has already been closed has no effect; doing so is not an error." <-- That /has/ to be a bug, then.
09:10:56 <wli> Baughn: Probably needs GC to recover it.
09:11:07 <mauke> Baughn: huh? how is that related?
09:11:08 <Baughn> wli: Nope, a GC doesn't do it
09:11:31 <Baughn> mauke: The socket was closed on the remote end. Calling hClose on it afterwards caused an exception.
09:11:37 <wli> Baughn: hClose() on a closed descriptor should yield EBADF.
09:11:41 <EvilTerran> are you hClose'ing something that's been hGetContents'd?
09:11:45 <Baughn> wli: That's close(2)
09:11:50 <Baughn> No
09:11:53 <mauke> Baughn: but you're not calling hClose twice
09:12:18 <Baughn> mauke: But the documentation says just "closed", not "closed by hClose in this process"
09:12:32 <mauke> but that's what it means
09:12:41 <mauke> you can't close descriptors in other processes
09:12:42 <ppavelV6> very good way to promote haskell: "to speek here, answer the testbot's question. to answer question read tutorials at  www.haskell.org. to read tutorials learn English. It's not the place to learn English here". Answered the questions. Nobody talks in the room anyway.
09:18:18 <ra_> I have query regarding the Language.Haskell.Lexer module. Doesn't it export lexerPass0 <family> functions anymore ?
09:33:08 <gwern> 'Jason Dagit: Type-Correct Changes---A Safe Approach to Version Control Implementation. Jason is now a Master of Computer Science.'
09:33:17 <gwern> hee hee. he's levelled up!
09:33:43 <gwern> @quote fmap
09:33:44 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life is much happier now
09:33:48 <gwern> @quote fmap
09:33:49 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life is much happier now
09:33:53 <gwern> @quote battle
09:33:53 <lambdabot> ddarius says: fmap: Because getting functions to the values is half the battle.
09:34:05 <gwern> @quote postmodern
09:34:06 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
09:34:06 <lambdabot> is not fixed.
09:34:12 <vixey> @quote
09:34:12 <lambdabot> <kerlo> says: Cale: what's actually in a RealWorld value? <Cale> kerlo: nothing.
09:34:18 <vixey> @quote
09:34:19 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
09:34:19 <gwern> @quote goto
09:34:19 <lambdabot> conal says: Recursion is the goto of functional programming
09:34:27 <sioraiocht> @quote sioraiocht
09:34:27 <lambdabot> sioraiocht says: was dons PhD in writing random haskell libraries?
09:34:32 <gwern> @quote synergy
09:34:32 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
09:34:40 <vixey> I've made two new functions
09:34:45 <gwern> @quote algol
09:34:45 <lambdabot> No quotes match. Just what do you think you're doing Dave?
09:34:45 <vixey> (f & g) x = (f x, g x) ; (f × g) (x, y) = (f x, g y)
09:35:02 <gwern> @quote vixey
09:35:02 <lambdabot> vixey says: [to me, it] still feels like 'real money' is a contradiction
09:35:04 <gwern> @quote vixey
09:35:04 <lambdabot> vixey says: I've seen haskell by stubborns which is like foo_bar_baz concatMap . filter notNull my_list. it's so awful to read
09:35:06 <conal> @forget conal: Recursion is the goto of functional programming
09:35:06 <lambdabot> No match.
09:35:09 <mauke> vixey: also known as (***) and (&&&)
09:35:15 <gwern> conal: :(
09:35:17 <gwern> I liked it
09:35:25 <sioraiocht> :t (***)
09:35:26 <conal> @quote anonymous "Recursion is the goto of functional programming"
09:35:26 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
09:35:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:35:34 <gwern> although I would've written 'primitive recursion'
09:35:37 <Saizan_> vixey: those are (&&&) and (***)
09:35:38 <conal> i like it a lot.  i don't want to take credit for it.
09:35:56 <gwern> @quote homeomophic
09:35:56 <lambdabot> No quotes match. I've seen penguins that can type better than that.
09:35:56 <mauke> @quote goto
09:35:56 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
09:35:56 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
09:36:03 <gwern> @remember vixey put some restriction like every token has a neighbourhood locally homeomophic to algol
09:36:04 <lambdabot> It is forever etched in my memory.
09:36:05 <vixey> @quote vixey
09:36:05 <lambdabot> vixey says:  <ImInYourMonad> I'm a spelling-bee.  <vixey> more like spelling-eff
09:36:06 <conal> is there a @forget?
09:36:06 <Saizan_> @forget conal Recursion is the goto of functional programming
09:36:06 <lambdabot> Done.
09:36:11 <vixey> @quote vixey
09:36:11 <lambdabot> vixey says: put some restriction like every token has a neighbourhood locally homeomophic to algol
09:36:12 <gwern> @quote Unfortunately
09:36:12 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
09:36:15 <gwern> @quote Unfortunately
09:36:15 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
09:36:15 <lambdabot> computer science problem. ;-)
09:36:17 <conal> Saizan_: thanks!
09:36:27 <gwern> @quote Neo
09:36:27 <conal> @quote goto
09:36:27 <lambdabot> gwern says: Unfortunately Neo, no one can be *told* what the Monad is.
09:36:27 <lambdabot> DonaldKnuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
09:36:27 <lambdabot>  might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
09:36:36 <vixey> @quote
09:36:36 <lambdabot> bringert says: psicho: so you are saying that your teacher gave you two days to do an assignment in a language you didn't know?
09:37:04 <gwern> @remember anonymous Primitive recursion is the goto of functional programming.
09:37:05 <lambdabot> Nice!
09:37:10 <gwern> @quote conal
09:37:10 <lambdabot> conal says:  omg -- i can print right from emacs again.  praise be to Linux!
09:37:14 <gwern> @quote conal
09:37:14 <lambdabot> conal says:  so i'm wondering if the claim of referential transparency is pure make-believe.
09:37:16 <conal> :)
09:37:16 <gwern> @quote conal
09:37:17 <lambdabot> conal says:  omg -- i can print right from emacs again.  praise be to Linux!
09:37:19 <gwern> @quote conal
09:37:19 <lambdabot> conal says:  omg -- i can print right from emacs again.  praise be to Linux!
09:37:29 <gwern> conal is not very quotable 'twould seem
09:37:32 <gwern> @flush
09:37:37 <trofi> time to @flush
09:37:48 <trofi> eh
09:38:24 <paczesiowa> @src iterate
09:38:24 <lambdabot> iterate f x =  x : iterate f (f x)
09:39:24 <gwern> @src until
09:39:24 <lambdabot> until p f x | p x       = x
09:39:24 <lambdabot>             | otherwise = until p f (f x)
09:40:15 <sioraiocht> > interate (+1) [1..[
09:40:16 <lambdabot>   <no location info>: parse error on input `;'
09:40:19 <sioraiocht> > iterate (+1) [1..[
09:40:22 <lambdabot>   <no location info>: parse error on input `;'
09:40:22 <sioraiocht> > iterate (+1) [1..]
09:40:24 <lambdabot>       No instance for (Num [t])
09:40:24 <lambdabot>        arising from the literal `1' at <inter...
09:40:35 <sioraiocht> oh, oops
09:40:37 <sioraiocht> i quit
09:41:49 <conal> i think i heard that recursion/goto quote from erik meijer, but i couldn't confirm an origin.
09:41:55 <sioraiocht> @src (^)
09:41:55 <lambdabot> x ^ 0            =  1
09:41:55 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
09:41:55 <lambdabot>   where f _ 0 y = y
09:41:55 <lambdabot>         f x n y = g x n
09:41:55 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
09:41:57 <lambdabot>                       | otherwise = f x (n-1) (x*y)
09:41:59 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
09:42:30 <sioraiocht> @src (**)
09:42:31 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:42:46 <sioraiocht> lambdabot apologises now?
09:43:11 <trofi> time to time
09:43:15 <gwern> lb is a tsundere
09:43:29 <mauke> is RMS tsundere?
09:45:36 <gwern> rms has never baked me chocolate, so no
09:46:39 <vixey> I like & and × more
09:49:03 <vixey> > cycle "()"
09:49:05 <lambdabot>   "()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()...
09:50:47 * trofi 've noticed mueval does not delete some temporary files
09:51:07 <Cale> trofi is plural? :)
09:51:20 <vixey> :t sequence . map ?f
09:51:22 <lambdabot> forall (m :: * -> *) a a1. (?f::a1 -> m a, Monad m) => [a1] -> m [a]
09:51:22 <LeoD> @src cycle
09:51:23 <lambdabot> cycle [] = undefined
09:51:23 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:51:23 <ray> resistance is futile
09:51:36 <vixey> @hoogle (a -> m b) -> [a] -> m [b]
09:51:36 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:51:37 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:51:37 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
09:52:25 <trofi> Cale: it was plural form?
09:54:37 <sioraiocht> :t cycle
09:54:39 <lambdabot> forall a. [a] -> [a]
09:55:11 <sioraiocht> > cycle [1..2]
09:55:13 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
09:55:16 <sioraiocht> hrm
09:55:26 <trofi> > cycle cycle
09:55:27 <lambdabot>   Couldn't match expected type `[a]'
09:55:36 <sioraiocht> :t cycle cycle
09:55:37 <lambdabot>     Couldn't match expected type `[a]'
09:55:37 <lambdabot>            against inferred type `[a1] -> [a1]'
09:55:37 <lambdabot>     In the first argument of `cycle', namely `cycle'
09:55:46 <sioraiocht> :t cycle . cycle
09:55:47 <lambdabot> forall a. [a] -> [a]
09:55:52 <mauke> > cycle [{-.-}]
09:55:53 <lambdabot>   * Exception: Prelude.cycle: empty list
09:56:52 <ray> > cycle [cycle]
09:56:52 <lambdabot>       Overlapping instances for Show ([a] -> [a])
09:56:52 <lambdabot>        arising from a use o...
09:57:12 <ray> overlapping instaces, aren't we fancy
09:57:58 <idnar> @type cycle [cycle]
09:58:00 <lambdabot> forall a. [[a] -> [a]]
09:58:18 <vixey> I wish I could call a variable  foo*
09:58:23 <idnar> > map ($ "hello") (cycle [cycle])
09:58:24 <lambdabot>   ["hellohellohellohellohellohellohellohellohellohellohellohellohellohellohel...
09:58:24 <vixey> or something<star>
09:58:27 <vixey> some kind of star
09:58:44 <idnar> well okay, that was pointless of me
10:00:06 <ray> foo_star not good enough?
10:00:21 <vixey> not good
10:00:23 <ray> haskell gives you kids an ' and you demand a *
10:00:37 <ray> in my day, i wrote C
10:00:38 <vixey> I want that
10:00:44 <vixey> x*
10:00:50 <EvilTerran> there may be some obscure unicode character that's star-shaped and counts as alphanumeric
10:01:10 <ray> http://www.fileformat.info/info/unicode/char/22c6/index.htm
10:01:36 <Elly> vixey: you want scheme :)
10:01:50 <EvilTerran> ray, that's a symbol, not an alphanumeric, tho
10:02:35 <Cale> 星
10:03:06 <mauke> > '۞'
10:03:07 <lambdabot>   '\1758'
10:03:27 <mauke> > isAlphaNum '۞'
10:03:28 <lambdabot>   True
10:03:51 <Cale> > isAlphaNum '星'
10:03:52 <lambdabot>   True
10:03:57 <ray> for all your demon summoning needs, mauke
10:14:31 <monochrom> byorgey_: "Grouping - Map / Reduce. GÃ¼nther Schmidt asked" on the web page. It is one of those utf-8 vs iso-8859-1 conflict.
10:14:59 * monochrom feels really hurt that iso-8859-1 is still used at all.
10:17:21 <Taejo> what is polymorphic recursion? I've heard the phrase, but don't know the meaning
10:17:40 <vixey> You could define some strange nested data types like
10:17:56 <Philonous> Is GHC.Conc supposed to export "signalHandlerLock" in 6.10.2 RC1? the unix packages imports it but it isn't there (any more)
10:17:58 <vixey> data Perfect a = The a | Twice (Perfect (a,a))
10:17:59 <monochrom> You have seen data Tree a = ... | Branch (Tree a) (Tree a).
10:18:08 * ppavelV6 seen the Java programs running under Mac OSX having problems with character encodings
10:18:27 <vixey> so if you want to write a recursive function over a Perfect tree, you must do it by polymorphic recursion
10:18:35 <monochrom> What vixey says.  Note it's illegal in Haskell.
10:18:43 <mauke> Taejo: it's when a function calls itself in its own body, but with an argument of a type that's different from what it received itself
10:18:49 <mauke> monochrom: what?
10:19:04 <vixey> it is illegal I think, you have to use special extensions to turn it on
10:19:10 <mauke> I doubt that
10:19:26 <Taejo> mauke: ok, now I'm trying to think of a place where it could be useful
10:19:36 <mauke> data types like the above
10:19:45 <vixey> Taejo: try to write a program that turns Perfect --> [a] (list of leaves)
10:19:47 <monochrom> Chris Okasaki's book has a use.
10:20:03 <vixey> You must use an 'accumulating parameter' but it is a functional value
10:20:17 <kyagrd> My example (I forgot where I got it from but its a typical example) http://kyagrd.dyndns.org/wiki/PolymorphicRecursion
10:20:42 <mauke> x==[]?
10:20:47 <mauke> not typical or a good example
10:21:01 <vixey> I like my example :(
10:21:48 <EvilTerran> would a function in a typeclass instance that called the same function in a different instance constitute polymorphic recursion?
10:21:50 <mauke> kyagrd: that's not polymorphic recursion
10:22:07 <mauke> EvilTerran: I don't think so because it's actually calling a different function
10:22:34 <vixey> @src show []
10:22:34 <lambdabot> Source not found. My mind is going. I can feel it.
10:22:43 <vixey> something like show list = "[" ++ intercalate "," (map show) ++ "]"
10:22:57 <vixey> I don't think it is polymorphic recursion
10:23:04 <vixey> um
10:23:08 <vixey> show list = "[" ++ intercalate "," (map show list) ++ "]"
10:23:41 <kyagrd> Isn't the matrix transpose a typical example of polymorphic recursion?
10:23:53 <vixey> kyagrd: How did you define matrix?
10:24:07 <vixey> if it's [[a]] that is not polymorphic recursion
10:24:52 <mauke> > let {f n x = if n <= 0 then show x else f (n-1) (x,x)} in f 2 42
10:24:53 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
10:24:53 <lambdabot>        Exp...
10:25:05 <mauke> > let {f :: (Show a) => Int -> a -> String; f n x = if n <= 0 then show x else f (n-1) (x,x)} in f 2 42
10:25:07 <lambdabot>   "((42,42),(42,42))"
10:25:12 <mauke> > let {f :: (Show a) => Int -> a -> String; f n x = if n <= 0 then show x else f (n-1) (x,x)} in f 4 42
10:25:13 <lambdabot>   "((((42,42),(42,42)),((42,42),(42,42))),(((42,42),(42,42)),((42,42),(42,42)...
10:27:39 <sundaymorning> I want a sqrt that returns Just number if the it's a perfect square and Nothing if it's not. Is there something like that?
10:28:00 <vixey> no you must define it yourself
10:28:10 <wli> I don't remember how to deal with polymorphic recursion. I think it's defined as either a function recursing at a less general type than the overall function or a passed-in function argument instantiated at multiple more specific types.
10:28:37 <mauke> the latter is rank-2 types
10:28:43 <monochrom> It is the former.
10:28:55 <kyagrd> Oh, rank-2 types ... right sorry for my confusion
10:29:21 <monochrom> Perfect(a,a) is a less general type than Perfect a, and vixey's example function shows.
10:29:25 <mauke> hint: if your code works without type signatures, it doesn't use polymorphic recursion or rank-2 types
10:30:19 <kyagrd> We can type polymorphic recursion if we can annotate arbitrary-rank types  ... right?
10:30:32 <sundaymorning> is (sqrt x == fromIntegral (floor x)) a valid way to see if x is a perfect square or could I have issues due to floating imprecision?
10:31:02 <Taejo> sundaymorning: you definitely could (I had this issue a few weeks ago)
10:31:54 <wli> What's the type of (.) in let u t = (t, t) in u . u? Or dup so let u t = (t, t) ; dup f = f . f in dup u?
10:32:15 <Heffalump> sundaymorning: I think you forgot to use sqrt x on the RHS too
10:32:19 <seliopou> heh, wli: you're still on this?
10:32:25 <Heffalump> and I think it'd be very risky
10:32:42 <sundaymorning> yeah, I did
10:32:49 <monochrom> fromIntegral (floor x) is redundant
10:32:54 <wli> seliopou: I think it's just an example of higher-rank types.
10:33:18 <monochrom> Err nevermind, it is not redundant.
10:33:24 <mauke> ((a,a) -> ((a,a,),(a,a))) -> (a -> (a,a)) -> a -> ((a,a),(a,a))
10:34:02 <vixey> Taejo: did you try my puzzle ?
10:34:20 <mauke> the second examle looks like it doesn't typecheck, so that's rank-2
10:34:54 <Taejo> vixey: well, I wrote a function that gives the leaves, and it was polymorphically recursive (obviously)
10:35:00 <wli> I don't even remember how to specify higher-rank types.
10:35:06 <vixey> what did you come up with ?
10:35:29 <Taejo> leaves (The x) = [x]; leaves (Twice x) = foldr (\(x,y) -> (x:) . (y:)) [] $ leaves x
10:35:44 <vixey> hm that's better than my one
10:36:39 <monochrom> f :: Int -> Bool -> (forall x. x -> Maybe x) -> (Maybe Int, Maybe Bool); f n b g = (g n, g b)  -- rank-2
10:39:02 <wli> @type let dup :: (forall t . t -> (t, t)) -> s -> ((s,s),(s,s)) ; dup f = f . f ; u t = (t,t) in dup (dup u)
10:39:03 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, t)
10:39:03 <lambdabot>     In the first argument of `dup', namely `(dup u)'
10:39:29 <ski> kyagrd : no need for higher-ranked types, for polymorphic recursion
10:39:51 <monochrom> . o O ( But is it sufficient? )
10:40:24 * ski . o O ( is *what* sufficient ? )
10:40:50 <dolio> Heffalump: ping
10:41:03 <monochrom> You are so context-free pushdown automaton, but here it is:
10:41:20 <monochrom> Is higher-rank polymorphism sufficient to do polymorphic recursion?
10:42:07 <ski> i'm not sure a see the connection ?
10:42:20 <ski> do you mean via some fixed point combinator ?
10:42:32 <ski> (presumably with higher-ranked type)
10:45:21 <monochrom> I am not sure I see the connection either. But since you bothered to respond to this question:
10:45:28 <monochrom> <kyagrd> We can type polymorphic recursion if we can annotate arbitrary-rank types  ... right?
10:45:30 <kadaver> is object orientation just a hoax? i mean you put your stuff ina  module and you ahve a namespace or as in C prefix_function everything. and you can #define Matrix struct matrix* etc. it is just really garabeg collection thats missing(not that that is connected to OO really).and Java didnt even have geenrics fromt he start
10:45:31 <monochrom> with your:
10:45:39 <monochrom> <ski> kyagrd : no need for higher-ranked types, for polymorphic recursion
10:45:46 <monochrom> I thought you knew what you're talking about.
10:45:59 <monochrom> Err, I thought you actually understood the question.
10:46:23 <ski> i simply meant that you don't need to allow higher-ranked types to allow polymorphic recursion
10:47:01 <dolio> > let foo :: Show a => Int -> a -> String ; foo 0 a = show a ; foo n a = foo (n-1) (a,a) in foo 3 5
10:47:02 <ski> (you just need to be able to give polymorphic signatures to `let'-bound variables)
10:47:03 <lambdabot>   "(((5,5),(5,5)),((5,5),(5,5)))"
10:47:16 <monochrom> Oh, you're just spotting keywords and finding a factoid that may or may not be relevant, much like a search engine.
10:47:39 <mauke> hey, that's my job!
10:48:35 <wli> @type let dup :: (t -> (t', t')) -> t -> ((t', t'), (t', t')) ; dup f x = let y = f x in (y, y) in dup . dup . dup
10:48:37 <lambdabot> forall t t'. (t -> (t', t')) -> t -> ((((t', t'), (t', t')), ((t', t'), (t', t'))), (((t', t'), (t', t')), ((t', t'), (t', t'))))
10:48:39 <ski> monochrom : that correct. that's what i usually do, when pointing my focus to this channel and trying to see what the current discussion is about :)
10:50:18 <wli> dup f = f . f doesn't work but that def does.
10:50:26 <ski> (and it sounded to me like kyagrd might have thought that polymorphic recursion somehow depended on higher-ranked types .. possibly this was a mis-inference of mine)
10:51:53 <vixey> I have written a horrible function
10:51:56 <vixey> duplicates "exyyxz" ~> [(1,4),(2,3)]
10:52:26 <wli> vixey: What's so horrible about it?
10:52:29 <vixey> it describes where there are duplicates in a list
10:52:29 <vixey> do you think there is a good way to write it?
10:52:33 <wli> vixey: What's it meant to do?
10:52:35 <vixey> my implementation
10:52:44 <mauke> duplicates "aaa" == ?
10:52:54 <vixey> [(0,1),(0,2),(1,2)]
10:53:33 <seliopou> yeah, that's messed up
10:53:39 <seliopou> I just got what it's doing
10:54:41 <wli> Oh, well, Map.fromListWith IntSet.union . zip xs $ map IntSet.singleton could do something useful.
10:54:41 <seliopou> if (x, y) is in the return list, then for some character c input !! x == c and input !! y == c
10:54:43 <seliopou> righ?
10:54:43 <mauke> :t let duplicates [] = []; duplicates (x : xs) = map succ (findIndices (x ==) xs) : map (succ *** succ) duplicates xs in duplicates
10:54:45 <lambdabot>     Couldn't match expected type `[(b, b')]'
10:54:45 <lambdabot>            against inferred type `[t] -> [a]'
10:54:45 <lambdabot>     In the second argument of `map', namely `duplicates'
10:54:56 <mauke> :t let duplicates [] = []; duplicates (x : xs) = map succ (findIndices (x ==) xs) : map (succ *** succ) (duplicates xs) in duplicates
10:54:57 <lambdabot>     Couldn't match expected type `[Int]'
10:54:57 <lambdabot>            against inferred type `(b, b')'
10:54:57 <lambdabot>       Expected type: (b, b') -> [Int]
10:55:49 <seliopou> vixey: what do you use that for?
10:56:36 <vixey> seliopou: it gives a good error message
10:56:45 <vixey> we say exactly where are the problems
10:57:13 <ddarius> > map fst . filter (\((i,a),(j,b) -> j > i && a == b) . liftM2 (,) . zip [0..] $ "exyyxz"
10:57:15 <lambdabot>   <no location info>: parse error on input `->'
10:57:24 <ddarius> > map fst . filter (\((i,a),(j,b)) -> j > i && a == b) . liftM2 (,) . zip [0..] $ "exyyxz"
10:57:25 <lambdabot>   Couldn't match expected type `[((t1, t), (t1, t))]'
10:57:41 <mauke> > let duplicates [] = []; duplicates (x : xs) = map ((,) 0 . succ) (findIndices (x ==) xs) ++ map (succ *** succ) (duplicates xs) in duplicates "exyyxz"
10:57:43 <lambdabot>   [(1,4),(2,3)]
10:57:43 <ddarius> > map fst . filter (\((i,a),(j,b)) -> j > i && a == b) . join (liftM2 (,)) . zip [0..] $ "exyyxz"
10:57:45 <lambdabot>   [(1,'x'),(2,'y')]
10:58:07 <ddarius> > map (fst***fst) . filter (\((i,a),(j,b)) -> j > i && a == b) . join (liftM2 (,)) . zip [0..] $ "exyyxz"
10:58:09 <lambdabot>   [(1,4),(2,3)]
10:58:14 <ddarius> > map (fst***fst) . filter (\((i,a),(j,b)) -> j > i && a == b) . join (liftM2 (,)) . zip [0..] $ "aaa"
10:58:16 <lambdabot>   [(0,1),(0,2),(1,2)]
11:00:48 <ddarius> > (\xs -> [(i,j) | let ys = zip [0..] xs; (i,a) <- ys; (j,b) <- ys; j > i && a == b]) "exyyxz"
11:00:49 <lambdabot>   <no location info>: parse error on input `<-'
11:01:08 <ddarius> > (\xs -> [(i,j) | let ys = zip [0..] xs, (i,a) <- ys, (j,b) <- ys, j > i && a == b]) "exyyxz"
11:01:09 <lambdabot>   [(1,4),(2,3)]
11:02:09 <BMeph> What, no sortBy comparing flip? ;p
11:02:38 <BMeph> Er *sortBy (comparing flip)
11:02:49 <BMeph> :t sortBy (comparing flip)
11:02:52 <lambdabot> forall a b c. (Ord (b -> a -> c)) => [a -> b -> c] -> [a -> b -> c]
11:03:12 <BMeph> Okay, that was not what I wanted. :\
11:03:26 <wli> > let duplicates xs = let m = Map.fromListWith IntSet.union . zip xs $ List.map IntSet.singleton [0 ..] in Map.mapKeysWith IntSet.union (IntSet.findMin . fromJust . flip Map.lookup m) m in duplicates "exyyxz"
11:03:27 <lambdabot>       Failed to load interface for `IntSet':
11:03:27 <lambdabot>        Use -v to see a list of t...
11:03:34 <BMeph> :t sortBy (flip compare)
11:03:35 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:05:24 <wli> vixey: Try duplicates xs = let m = Map.fromListWith IntSet.union . zip xs $ List.map IntSet.singleton [0 ..] in Map.mapKeysWith IntSet.union (IntSet.findMin . fromJust . flip Map.lookup m) m
11:10:34 * edwardk wakes up and returns to hacking on monoids.
11:11:08 * ppavelV6 recalled he didn't read last issue of Monadic.Reader yet
11:12:55 * edwardk contemplates the right namespace for modules or left-seminearrings. 
11:13:02 <edwardk> er over
11:23:02 <felixc> hm, in Control.Concurrent.STM, what's the difference between a TArray and an array of MVars?
11:23:14 <edwardk> an array of TVars you mean?
11:23:43 <felixc> er, perhaps -- I have to admit this is my first foray into both haskell in general and STM
11:23:47 <edwardk> hah, sok
11:24:03 <edwardk> TVars are transactional, so if the transaction fails, all changes roll back, MVars are not
11:24:18 <felixc> ah, right, MVars are not in STM, just in Control.Concurrent
11:24:20 <edwardk> TArrays are like an Array of TVars
11:24:22 <edwardk> yeah
11:25:02 <felixc> hm I think I'm looking in the wrong place -- I don't need transactional operations... just an array of MVars probably
11:25:25 <edwardk> MVars are probably the place to go. the STM.* stuff is awesome when you need it though.
11:25:59 <felixc> yeah, it seems like a lot of stuff points to it as the latest and greatest, which is probably why I ended up looking at it in the fist place :)
11:26:36 <felixc> thanks!
11:37:12 <kerlo> So, I think I can make a traversable plane pretty easy.
11:38:00 <kerlo> Now I just have to figure out how to make arbitrary traversable graphs.
11:38:40 <kerlo> Wish me luck, eh?
11:40:16 <felixc> hm, I guess I still don't know what I'm doing
11:40:35 <felixc> I'm trying to make a mutable array of MVars, each of the form (Float, Float)
11:40:59 <felixc> so I'm trying to use Data.Array.IO's IOArray
11:41:24 <felixc> does that sound reasonable so far? IOArray's can hold MVars? MVars can be of that form?
11:41:34 <dons> hmm. fallingblocks is a pretty solid tetris
11:43:03 <vixey> @pl \list -> sequence (sequence list 0)
11:43:03 <lambdabot> sequence . flip sequence 0
11:43:05 <vixey> @pl \list -> sequence_ (sequence list 0)
11:43:05 <lambdabot> sequence_ . flip sequence 0
11:43:19 <edwardk> felixc: well, if you don't change which mvar is in each slot then it can be an 'Array' rather than an IOArray
11:43:29 <edwardk> if you are going to change which mvar is in each slot you'll need the IOArray
11:43:35 <vixey> @pl \o -> sequence_ (sequence list o)
11:43:35 <lambdabot> sequence_ . sequence list
11:43:39 <defun> I just tried to rebuild ghc-6.10.1 and got the following error: http://pastebin.com/fd76644f
11:43:47 <edwardk> you can change the contents of the MVar regardless, but changing the MVar is what you'd need an IOArray for
11:43:59 <defun> This shouldn't be happening since *I already built GHC* before.
11:44:34 <defun> Is GHC non-self-hostable?
11:45:10 <felixc> edwardk: ahhh... I see what you mean -- you're right, I'm not interested in swapping MVars, just updating the value of each one
11:45:32 <felixc> so I don't need the array itself to be mutable
11:45:48 <edwardk> yep
11:45:53 <felixc> cool, thanks
11:46:21 <felixc> hopefully that will simplify things a bit, I'm basically struggling with actually creating such an array
11:52:26 <BMeph> Is there a special name for monoids with a zero element?
11:52:35 <pumpkin> monoid?
11:52:48 <pumpkin> monoid0
11:52:57 <ppavelV6> @hoogle mzero
11:52:57 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
11:53:01 <Cale> BMeph: In that multiplication by that element results in that element?
11:53:04 <BMeph> I.e., where a * Z = Z * a = Z for any a in the set.
11:53:04 <ppavelV6> sorry
11:53:15 <pumpkin> I thought monoids already had a zero
11:53:19 <wli> Monoids are defined as semigroups with unit elements.
11:53:26 <Cale> pumpkin: Under addition.
11:53:32 <wli> i.e. they've already got 0's
11:53:33 <pumpkin> ah
11:53:46 <BMeph> Cale: Yes, exactly. Although, not necessarily "multiplication", just a binary operator suitable for a monoid.
11:53:47 <wli> Otherwise, if it had an annihilator it wouldn't be a monoid.
11:53:49 <pumpkin> but monoids don't really define more than one operation do they?
11:53:58 <ppavelV6> no they dont
11:54:02 <Cale> pumpkin: right.
11:54:14 <pumpkin> so "addition" is the only operation?
11:54:21 <pumpkin> and it already has an identity for that
11:54:21 <ppavelV6> yep
11:54:24 <Cale> BMeph has made it clear in which sense he means a zero.
11:54:32 <wli> Or maybe monoids can have annihilators. Hmm.
11:54:36 <Cale> They can.
11:54:47 <wli> BMeph: They're called annihilators BTW.
11:54:49 <Cale> Well, obviously.
11:54:59 <Cale> Look at integers under multiplication.
11:55:16 <pumpkin> hmm
11:55:40 <Cale> 0 is an appropriate Z for BMeph's definition
11:55:51 <BMeph> wli: Cool, that's a first step. But is there a name for annihilator-containing monoids? Or do you have to go to a group to get them?
11:55:52 <Cale> If we want to call it an annihilator, I suppose that's a decent name.
11:56:20 <Cale> Though... normally I think of annihilator as meaning something a bit different, but that's in a slightly different context anyway.
11:56:27 * pumpkin is confused
11:56:40 * BMeph is BMeph - pleased to meet you!
11:56:47 <pumpkin> :)
11:56:53 <BMeph> >;)
11:57:17 <BMeph> Cale: CT, or topos? ;)
11:57:22 <Cale> hm?
11:57:38 <BMeph> "normally I think of annihilator as meaning something a bit different, but that's in a slightly different context anyway." -- which context
11:57:42 <BMeph> ?
11:57:47 <Cale> Ring theory.
11:58:04 <BMeph> Ah, rings. That makes sense.
11:58:24 <seliopou> zero divisors?
11:59:12 <andyou_> How many here does maths?
11:59:12 <Cale> Suppose R is a ring, and M is a module over R, and S is a subset of M. Then the annihilator of S is the set of all elements r in R such that for each s in S, rs = 0.
11:59:21 <monochrom> I did maths.
11:59:37 <andyou_> Seems haskell appeals mostly to mathematicians.
12:00:05 <monochrom> That is just part of the truth.
12:00:20 <vixey> I don't think anyone that isn't a mathematician could write a working program
12:00:24 <Cale> andyou_: Well, I'm not sure about that, but, if you're a mathematician, then Haskell is more likely than most other programming languages to appeal to you.
12:00:38 <maltem> monochrom: Right, there are also Haskellians to whom maths appeals :)
12:00:46 <andyou_> Cale: True.
12:00:49 <monochrom> haha
12:00:57 <pumpkin> aha
12:01:08 <gnuvince_> Haskell appeals to me, but mathematics don't want anything to do with me
12:01:17 <Cale> I think there are enough non-mathematician Haskellers that it's not quite right to say that it appeals mostly to mathematicians.
12:01:19 <pumpkin> I missed <BMeph> I.e., where a * Z = Z * a = Z for any a in the set., and thought he was asking for something that = a :P
12:01:27 <maltem> (I'm not sure if I fall under that category, actually, starting to study maths now)
12:02:01 <andyou_> I fall under that category too... math student.
12:02:17 <Cale> But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
12:02:33 <vixey> hehe 'applied logician'
12:02:34 <pumpkin> sounds so much less romantic that way
12:02:59 <Gracenotes> well, rarely elsewhere do you get to run an IRC bot by proving theorems...
12:03:10 <vixey> Cale: that desc. makes haskell programmers sound completely insane
12:03:11 <vixey> :p
12:03:44 <kerlo> "I'm capable of speaking if you speak first." "Okay, prove it. What is the capital of Michigan?" "Lansing."
12:03:52 <maltem> @remember Cale But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
12:03:52 <lambdabot> Okay.
12:05:23 <andyou> I want to get into a field that combines maths and comp.sci... Computational group theory seems interesting... any other ideas?
12:05:45 <vixey> combines maths and comp.sci -- programming
12:06:05 <Cale> andyou: Well, there's some nice intersection with functional programming and category theory these days.
12:06:05 <andyou> vixey: Programming uses only very basic mathematics.
12:06:09 <vixey> no
12:06:24 <andyou> Cale: well, it seems like an extremely narrow field, doesn't it?
12:06:29 <vixey> I think when you say programming you are talking about hacking
12:06:32 <Cale> What does?
12:06:39 <Cale> Category theory?
12:06:47 <sundaymorning> andyou: it can use very elaborate mathematics, though
12:06:53 <Cale> I suppose it's not yet very large.
12:06:54 <sundaymorning> maxima, for instance
12:07:07 <andyou> Cale: Yes, cat.theory... seems more like a tool than a dicipline of its own.
12:07:07 <lament> programming uses only very basic mathematics and only very basic computer science :)
12:07:15 <Cale> andyou: Well...
12:07:44 <Cale> andyou: I tend to think of category theory as being suspended somewhere in between order theory and the theory of monoids.
12:08:07 <vixey> andyou: The amount of mathematics ignored when you write normal programs is vast
12:08:20 <seliopou> andyou: computational geometry's nice
12:08:22 <Cale> It generalises both of those and somehow manages to be richer-seeming than either of them.
12:08:29 * vixey sees category theory more like DNA
12:08:44 <vixey> (and set theory like atoms)
12:09:03 <andyou> seliopou: Oh? Do you include Computational topology and computational homology in that, or is it more differential topology and those sorts of things?
12:09:06 <ddarius> Cale: Why would it be "between" them if it generalizes both?
12:09:32 <vixey> andyou: Aren't the computations in homology mostly trivial?
12:09:42 <monochrom> Most programming languages allow you to introduce your own functions but not your own operators. This is an example of the many asymmetries that thinking people hates but unthinking people just accept as facts. Haskell doesn't have many of those asymmetries. Rather than saying Haskell appeals to mathematicians, it's more true that Haskell appeals to thinking people who keep noticing "why don't you follow it to its logical con
12:09:42 <monochrom> clusion, and it is not that hard to implement either?"
12:09:54 <andyou> vixey: Say what?
12:09:57 <Baughn> mauke: After lots of ghc recompiles, and some very noisy debugging, I've narrowed my hClose bug down to the second call to hClose' in the hClose definition for DuplexHandles. Specifically, the call to flushWriteBufferOnly in the attempt to close the read-side half of the handle.
12:10:09 <Cale> ddarius: Well, I don't know. It might cover them both at the same time :)
12:10:10 <edwardk> monochrom: well said
12:10:14 <mauke> Baughn: yes, obviously
12:10:15 <vixey> andyou: it's not something I study just wondering if what someone told me is true
12:10:23 <lament> monochrom: the ability to introduce operators is a pretty weak example for that
12:10:33 <Baughn> mauke: Soo.. why is that anything but a no-op for the /read-only half/?
12:10:37 <seliopou> andyou: sure :)
12:10:43 <edwardk> monochrom: of course saying that in here is like saying 'Can I get an Amen!' in an evangelical church ;)
12:10:47 <andyou> vixey: I've only taken a basic course in homology theory, but I can tell you it's not very easy. Or did you mean computationally?
12:10:49 <monochrom> Yeah, I am old and I can't recall the more annoying examples.
12:10:52 <seliopou> or rather, those things you mentioned probably use CG
12:11:04 <seliopou> the inclusion's the other way
12:11:08 <monochrom> Amen!
12:11:30 <monochrom> Credo in unum Deum! Amen! Amen!
12:12:22 <andyou> Then there's cryptography and all that... they claim their maths are pretty advanced; elliptic curves and all sorts of magic.
12:12:23 <lament> Achoo!
12:12:47 <mauke> Baughn: wait, what?
12:12:48 <monochrom> But the benefit of saying it here is that you guys can now re-tell it to other people. Another benefit is some people here are still wondering, and they may like to hear that.
12:12:53 <seliopou> elliptic curves are nice
12:12:54 <vixey> andyou: I meant computationally, thats why I said "aren't the computations ..."
12:12:58 <seliopou> they force you to learn algebra well
12:13:14 <edwardk> andyou: it always struck me as a nice collection of tricks. but then, pot, kettle, black i guess.
12:13:18 <andyou> vixey: Well, humans also do "computations".
12:13:34 <Baughn> mauke: In base/GHC/Handle.hs, the definition of hClose for duplex streams (such as this network socket) involves closing them one after the other. First the write side, then the read side.
12:14:30 <Baughn> mauke: If the remote host disconnects, then closing the write half succeeds just fine - as posix would agree - but trying to close the read side causes an exception. Which is fine, except the exception is inside a call to flushWriteBufferOnly on the handle-half, which really ought to be a no-op.
12:15:11 <mauke> Baughn: hmm, it should die while flushing the write buffer (while closing the write side)
12:15:12 <vixey> @dict predecessor
12:15:13 <lambdabot> Supported dictionary-lookup commands:
12:15:13 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
12:15:13 <lambdabot> Use "dict-help [cmd...]" for more.
12:15:20 <vixey> @w80 predecessor
12:15:23 <lambdabot> *** "predecessor" wn "WordNet (r) 2.0"
12:15:23 <lambdabot> predecessor
12:15:23 <lambdabot>      n : one who precedes you in time (as in holding a position or
12:15:23 <lambdabot>          office)
12:15:59 <vixey> if I had some sequence, and it's got a clearly defined next subsequnce -- what do you call that subsequence?
12:16:05 <vixey> predecessor is the wrong word..
12:16:12 <Baughn> mauke: Ah, well, it does that sometimes, if the close catches me between a write and the subsequent hFlush
12:16:33 <ehird> cabal-install wants parsec 2; will it work with parsec 3?
12:16:37 <Baughn> mauke: In that case it still runs the onException call to hClose, though
12:16:42 <Baughn> ..which promptly crashes oto
12:16:50 <mauke> yes
12:16:53 <Saizan> ehird: yes
12:17:10 <Saizan> ehird: well, it doesn't use parsec, only network that uses parsec
12:17:11 <Baughn> mauke: Anyway, I'd like to be able to reliably clean up after myself without switching to the low-level POSIX API
12:17:19 <Baughn> So, guess I should open a ticket
12:17:21 <ehird> Saizan: ah
12:17:40 <mauke> Baughn: yeah, hClose needs to close descriptors no matter what happens during the flush
12:17:44 <ehird> Saizan: It's just that bootstrap.sh checks for parsec 2
12:17:46 <ehird> I'll patch it
12:18:13 <Baughn> mauke: Pretty simple patch, then. I'll open a ticket with a patch. :)
12:18:18 <BMeph> vixey: Did someone say "successor" already? :)
12:18:32 <vixey> no BMeph
12:18:43 <vixey> sucessor is weird for a subsequence though :S
12:18:53 <vixey> because the subseq is smaller in a way
12:19:02 <sundaymorning> I was looking for a function just like catMaybes, what a weird name, though
12:19:08 <felixc> hm, so I am getting closer... I now have an Array of MVars of the form (Float, Float), however I'm obviously doing something wrong when trying to read them
12:19:18 <sundaymorning> why is it called that instead of filterNothings or something like that?
12:19:19 <BMeph> vixey: What about "consequent" then?
12:19:25 <vixey> ooh
12:19:31 <vixey> thank you BMeph :p consequent is greeat
12:19:40 <felixc> I am trying to do "x <- readMVar (the_array ! the_index)"
12:20:18 <felixc> but get "Couldn't match expected type `MVar a' against inferred type `IO (MVar (Float, Float))"
12:21:19 <Cale> felixc: It looks as if your array is for some reason full of IO actions?
12:21:36 <Cale> oh
12:21:49 <Cale> what type of array is it?
12:21:49 <felixc> hm, I think that's a mistake in my definition then -- I thought that was required since it's full of MVars
12:22:09 <felixc> an IArray of MVars, each of the form (Float, Float)
12:22:24 <mauke> yeah, no IO
12:22:38 <Cale> Yeah, you shouldn't make it an array of IO MVars then.
12:22:51 <vixey> oh this is rubbish :/
12:22:54 <felixc> ah okay, I
12:23:02 <felixc> will try removing that, thanks
12:23:04 <vixey> f (n:splitAt n -> (x,y)) -- it says 'n' not in scope
12:23:26 <Cale> Unless you really want to be able to run those actions multiple times, or they have other effects you're interested in.
12:24:07 <ehird> I've installed cabal-install. Yet, I have no .cabal/config.
12:24:08 <felixc> this is why I added that in the first place: Couldn't match expected type `MVar (Float, Float)' against inferred type `IO (MVar (t, t1))'
12:24:13 <Cale> vixey: What about f (n : (splitAt n -> (x,y))
12:24:15 <ehird> What do I do
12:24:16 <ehird> ?
12:24:17 <mauke> ehird: try running 'cabal'
12:24:20 <ehird> mauke: did that.
12:24:25 <ehird> maybe I have to run an actual operation?
12:24:28 <Cale> )
12:24:33 <mauke> dunno, try cabal update :-)
12:24:33 * ehird runs cabal update
12:24:38 <ehird> "Writing default configuration to /Users/ehird/.cabal/config"
12:24:39 <ehird> yep
12:24:41 <vixey> oh that works Cale
12:24:46 <vixey> thanks
12:24:56 <Cale> felixc: Do you understand how the type IO t differs from the type t?
12:25:27 <Cale> felixc: A value of type IO t is like a program which if you were to run it, would produce a value of type t.
12:25:44 <felixc> I see... hm, that's not what I need then
12:26:02 <felixc> but for some reason it thinks that the type of what I have is an IO action
12:26:13 <Cale> felixc: So if you have an IO t, and you want a value of type t, you probably want to run the IO action.
12:26:30 <Cale> Which you can do from inside of a do-block using the syntax  v <- x
12:26:35 <felixc> let me show you the actual line, it might make more sense then... this is what I have:
12:26:35 <Cale> If x :: IO t, then v :: t
12:26:38 <felixc> boids = listArray (1, num_boids) [(newMVar (0.0, 0.0))] :: Array Int (MVar (Float, Float))
12:26:50 <Cale> Right, that's not a list of MVara
12:26:52 <Cale> MVars*
12:26:55 <felixc> I am trying to make an array of MVars, each initialized to (0.0, 0.0)
12:27:04 <Cale> It's a list of IO actions (the same IO action over and over again)
12:27:23 <felixc> ah, newMVar is an action...?
12:27:24 <Cale> So, you want to actually *run* the newMVar actions, and put the *results* in the array
12:27:33 <chessguy> @hoogle newMVar
12:27:33 <lambdabot> Control.Concurrent.MVar newMVar :: a -> IO (MVar a)
12:27:33 <felixc> that sounds right
12:27:45 <Cale> newMVar (0.0,0.0) is an IO action which will produce an MVar if run.
12:27:51 <felixc> right
12:28:09 <Cale> felixc: Another problem is that your list has only one element, so most of the array will be uninitialised
12:28:27 <felixc> yeah, for debugging i am just making it 1 element
12:28:36 <chessguy> @type sequence_
12:28:36 <Cale> So what you want is  xs <- replicateM num_boids (newMVar (0,0))
12:28:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
12:28:48 <Cale> and then  let boids = listArray (1,num_boids) xs
12:28:55 <Cale> inside of a do-block
12:29:16 <Cale> The do-block itself will be an IO action.
12:29:39 <Cale> Which when run, will run newMVar (0,0) over and over num_boids times, collecting the new MVars into a list xs
12:29:48 <Cale> and then defining boids as that appropriate array
12:29:56 <Cale> You might then want to just return boids
12:30:05 <Gracenotes> @type replicateM_
12:30:06 <Cale> Or else perhaps do some more I/O with it.
12:30:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
12:30:15 <Cale> replicateM_ would be unsuitable here.
12:30:21 <Gracenotes> wha?
12:30:33 <Cale> Because you definitely want the new MVars you're creating.
12:30:33 <mdmkolbe> I'm reading some of the ByteString slides.  What is the loopU function they refer to?
12:30:36 <Gracenotes> I'm just checking the type... *cowers in fear*
12:30:39 <Cale> oh
12:30:39 <Cale> hehe
12:30:40 <Cale> :)
12:30:42 <felixc> Cale: thanks so much, that explains a lot!
12:30:43 <Cale> That's fine then :)
12:30:50 <rushan> test
12:30:53 <Gracenotes> :)
12:30:54 <chessguy> Gracenotes:  consider yourself SMACKED DOWN!!
12:31:00 <Gracenotes> o:
12:31:07 <mdmkolbe> @src loopU
12:31:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:31:23 <Cale> But yeah, replicateM_ is for when you don't want the results of the IO action you're running over and over.
12:31:31 <chessguy> @src replicateM
12:31:31 <lambdabot> replicateM n x = sequence (replicate n x)
12:31:54 <Gracenotes> actually, I wasn't even sure if replicateM_ existed
12:32:02 <chessguy> @src r n x = s (r' n x)
12:32:02 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:32:12 <chessguy> @pl r n x = s (r' n x)
12:32:12 <lambdabot> r = (s .) . r'
12:32:14 <Gracenotes> I'd think that sequence functions would have sequence_ variants, though
12:32:42 <Cale> I think they all do.
12:32:52 <Gracenotes> speaking of which, MORE XXXM FUNCTIONS NEEDED.
12:33:07 <Cale> Which ones do you want?
12:33:21 <mdmkolbe> @seen dons dcoutts
12:33:22 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #yi, #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I last heard dons speak 51m 49s ago.
12:33:22 <rushan> sorry is there someone who speak russia?
12:33:31 <mdmkolbe> @seen dcoutts
12:33:32 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 1d 8h 36m 37s ago.
12:34:00 <Cale> rushan: I think we have a few... not sure if they're here at the moment or not.
12:34:13 <Gracenotes> Cale: foldrM...
12:34:30 <Gracenotes> ifM'd be useful
12:34:49 <Gracenotes> untilM. Just more matching in general.
12:35:26 <Gracenotes> I think others might be needed, but it really only happens when you run into it :)
12:36:03 <ddarius> (print x >> 3M) +M incM ref
12:36:07 <paczesiowa> once I was writing smth reading dirs and I realised I needed partitionM, I googled for it and I found the whole code to read a directory:)
12:36:11 <chessguy> @where lambdabot
12:36:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
12:36:17 <chessguy> @seen lambdabot
12:36:17 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
12:36:17 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd, #gentoo-uy, #gentoo-
12:36:17 <lambdabot> haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
12:36:19 <rushan> i am new in haskell. ghc warning: "No explicit method nor default method for `BricsProvider.bricks". I create class and his instance for the type, but this warning appear...
12:36:36 <Gracenotes> ddarius: well. You can only liftM so much!
12:36:47 <Cale> rushan: It means that your instance didn't define that value.
12:37:16 <rushan> but the type is define
12:37:21 <rushan> instance BricsProvider Box where
12:37:22 <rushan>     bricks box = config box
12:37:47 <Cale> hmm
12:37:56 <Baughn> rushan: Could you paste the complete file (on rafb.net or similar)?
12:38:01 <chessguy> @paste
12:38:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:38:07 <kadaver> why would it be so bad to add generics to C? does geenrics unevitably involve runtime type-checks?
12:38:18 <kadaver> or lookups
12:38:31 <Baughn> kadaver: No, but C has very deliberately been designed to be implementable in a few days
12:38:33 <rushan> ok
12:38:35 <vixey> no I think generics should not involved runtime
12:38:40 <Cale> kadaver: In C it would be strange, because you basically can't get any further from having a uniform representation of data.
12:38:42 <Baughn> kadaver: Generics would break this
12:39:09 <wli> Generics, or parametric polymorphism, would require boxing and tagging or some such.
12:39:21 <Cale> I'm not sure which sense of the word 'generics' you mean
12:39:26 <ddarius> Baughn: I doubt you could implement C99 in a few days.
12:39:38 <kadaver> i see, one good thing about C is that it is easy to port?
12:39:55 <monochrom> "Learn C99 in 21 days with DIY compiler"?
12:39:58 <wli> no
12:40:20 <Baughn> kadaver: No, easy to /implement/. As in, from scratch.
12:40:21 <paczesiowa> wli: you could compile as many versions of each function (like id) as there are monomorphic usages of that function
12:40:34 <Baughn> ddarius: The freestanding version, I could
12:40:52 <kadaver> could one perhaps write a DSL for writing drivers?
12:40:55 <felixc> Cale: thanks yet again, I just confirmed that it works exactly desired
12:41:04 <felixc> *as desired, that is
12:41:05 <wli> paczesiowa: polymorphic recursion
12:41:16 <paczesiowa> wli: in c?
12:41:17 <monochrom> C++ was generic C. Original implementation was "just" macro expansion.
12:41:32 <rushan> link to code: http://rafb.net/p/bDuye420.html
12:41:32 <Baughn> ..macros straight from the ninth circle of hell, but macros
12:41:41 <chessguy> has C been implemented in haskell yet?
12:41:53 <paczesiowa> as dsl:)
12:42:06 <monochrom> "Learn C99 in 21 days with DIY compiler for Haskell programmers"?
12:42:20 <Gracenotes> Hola, me llamo Marco
12:42:36 <Gracenotes> *Macro
12:43:45 <Baughn> mauke: http://hackage.haskell.org/trac/ghc/ticket/3128 <-- It's probably easy to fix, but I'd most certainly leave race conditions in. Anyway.. if it got fixed sometime before monday, it'd help impress one of my professors that haskell is, in fact, useful. ;)
12:45:18 <pejo> kadaver, "Implementing Reliable Linux Device Drivers in ATS" describes how they wrote device drivers in ATS and compiled and linked them to the linux kernel.
12:45:22 <paczesiowa> can I make instances for rank2 types?
12:46:09 <Baughn> paczesiowa: Does GHC complain if you try?
12:46:54 <paczesiowa> Baughn: yeah, but I don't understand them well, so it might be smth unrelated to making instances
12:50:24 <samalog> Hi everyone! First time here. Don't beat me up too much ;) I was wondering if anyone had any suggestions about how you might best do image manipulation in haskell?
12:51:02 <samalog> I found a few hackage packages from some googling, but they appear to be C-binding rather than native haskell. Is this something that's just best done as a binding?
12:51:38 <Baughn> samalog: It's fairly typical "simple-but-performance-requiring" sort of code, so yes
12:51:48 <ehird> samalog: GD works well for me
12:51:51 <Baughn> Though you might want higher-level APIs in haskell for them
12:51:51 <ehird> it's all in IO but there you go
12:52:00 <ehird> very simple api
12:52:52 <Baughn> If you know know C well enough, you should be able to write safe non-IO bindings using unsafePerformIO. ;)
12:53:36 <dons> hmm. http://www.haskell.org/haskellwiki/Internationalization_of_Haskell_programs
12:53:39 <samalog> presumably, if I wanted to do it in haskell I'd be looking at representing an images as a nested set of lists? I'm less worried about the serialisation from file, and more worried about what a 4096^2 * 4xfloat texture turns into
12:53:46 <dons> seems like this could be a killer case for overloaded strings
12:53:58 <dons> samalog: wouldn't you use arrays?
12:54:04 <dons> flat, unboxed arrays
12:54:10 <eu-prleu-peupeu> i need an opinion, wich is better to use, a Map (Int, Int) Double, or a two dimensional array of Double ? (is it possible to have two dimensional arrays of double?)
12:54:21 <dons> Array (Int,Int) Double
12:54:30 <Baughn> dons: Oh yes, that would be lovely
12:54:34 <eu-prleu-peupeu> thanks dons :)
12:54:51 <samalog> dons: I'm kind of new to haskell so I may have missed something - I figured arrays were mutable structures than therefore not really a haskell thing?
12:55:33 <eu-prleu-peupeu> samalog: check out the wiki on the arrays, you have loads of different types of arrays
12:55:38 <Baughn> samalog: You just have to copy the whole thing when you make changes. If you make the changes complex enough, that's not really a problem - see uarray, etc.
12:55:43 <paczesiowa> purity is just to scare and educate newcomers
12:55:49 <Baughn> samalog: Then there are the actual mutable arrays, as in STArray..
12:55:51 <rushan> I found the source of the problem: it is in uncorrect indentation in the other place :)
12:55:53 <rushan> instance BricsProvider Figure where
12:55:54 <rushan>     bricks figure = config figure
12:56:12 <eu-prleu-peupeu> personally i feel lazyness is much scarier than purity :/
12:56:20 <dons> samalog: there's plenty of mutable structures, they're just not the default
12:56:34 <samalog> ah, yeah, just googled for arrays and found a load of stuff.
12:56:41 <samalog> thanks everyone.
12:56:42 <dons> samalog: ppoke around on hackage.haskell.org in the image manipulation libraries
12:56:45 <dons> to see what format they use
12:57:00 <ehird> dons: 19:52 dons: seems like this could be a killer case for overloaded strings
12:57:04 <ehird> that's rather too implicit for me
12:57:23 <dons> instead of writing:  ___ "foo" ?
12:57:28 <ehird> imo overloaded strings should always have the same content, intuitively
12:57:32 <ehird> dons: no, that's u gly
12:57:37 <ehird> but I don't think overloaded strings are the solution here
12:57:39 <dons> well, that's how we currently do it.
12:57:42 <ehird> hmm
12:57:44 <ehird> [[  putStrLn $ (__ "Hello, ") ++ name ++ (__ ", how are you?") ]]
12:57:45 <dons> i'd imagine a I18N string type
12:57:46 <ehird> that's not very good
12:57:50 <dons> that has an IsString instance
12:57:54 <ehird> it doesn't handle different sentence orders
12:57:59 <dons> and then we have putStrLn et al that do i18n , like utf8-string
12:58:06 <ehird> should be something like
12:58:15 <ehird> i dunno
12:58:26 <kadaver> does gcc produce really fast code? or why is C code fast? undefined behaviour?
12:58:28 <dons> have you seen the new how to?
12:58:39 <dons> kadaver: machine support, simple, lots of optimizations
12:58:44 <ehird> dons: no
12:58:50 <kadaver> I can see memory use being smaller(since you can control it) and obv more controllable.
12:58:56 <dons> http://www.haskell.org/haskellwiki/Internationalization_of_Haskell_programs
12:59:13 <ehird> yes
12:59:13 <dons> kadaver: hm. it's more that C isn't garbage collected
12:59:16 <ehird> my quote was from that
12:59:18 <dons> and ghc uses a copying collector
12:59:22 <kadaver> dons: what i meant
12:59:23 <dons> so it averages about 2x the footprint
12:59:33 <kadaver> ok
12:59:39 * dons reminds people to use the compacting collector if footprint is the issue
12:59:41 <ehird> regarding garbage collection—does ghc use a gc that runs in parallel with the mutator? any plans to?
12:59:55 <dons> per-thread young generations in parallel, is the plan
12:59:55 <kadaver> and with optimizations you mean gcc doing them or that you can tell gcc how to do them(inline etc)
13:00:08 <ehird> dons: that still blocks the thread, doesi t not?
13:00:09 <eu-prleu-peupeu> dons: are you going to the hackaton ?
13:00:14 <dons> ehird: the local thread.
13:00:16 <dons> not all the others
13:00:18 <Baughn> kadaver: GCC doing them. Loop unrolling, etc, which is still in the future for GHC.
13:00:23 <ehird> dons: yeah that's not what I meant
13:00:24 <dons> eu-prleu-peupeu: yes.
13:00:28 <dons> ehird: right. i know.
13:00:30 <ehird> :)
13:00:35 <dons> it's a "concurrent collector" you're asking for
13:00:38 <dons> which isn't planned
13:00:46 <Baughn> How about an incremental one?
13:00:48 <eu-prleu-peupeu> dons: okey, ill try to go just to give you a hug :)
13:00:55 <dons> that'll be interesting.
13:00:57 <eu-prleu-peupeu> a Hugs :P
13:01:32 <ehird> dons: that's a shame. I know how to write a concurrent mark-and-sweep, which is trivial, and I know how to write a generational/copying/etc collector, but not how to combine them both
13:01:45 <ehird> Maybe I'll have a shot at writing one to see what the advantages / disadvantages are
13:03:52 <dons> here's a screencast of the SDL tetris game, btw, it's nice. http://www.youtube.com/watch?v=UI7sL_z7mKI
13:04:04 <dons> Lemmih: ^^
13:04:49 <ddarius> ehird: Incremental/concurrent GCs tend to have rather poor throughput.
13:05:10 <ehird> ddarius: hrm
13:05:16 <ehird> ddarius: that isn't too much of an issue nowadays is it
13:05:36 <Baughn> ddarius: On occasion, latency is much more imporant than throughput
13:05:51 <Baughn> Though if I wanted predictability I probably shouldn't be using a lazy language. ^_^
13:06:19 <dons> dont' use lazy structures then.
13:06:29 <mmorrow> just made a little page for vacuum, with some info and a mini-gallery http://moonpatio.com/vacuum/
13:06:43 <Baughn> Well, I never said it was that important to me, now. :P
13:07:05 <mmorrow> if anyone happens to have any cool images, i'd love to put them up :)
13:07:18 <ehird> ddarius: I'd rather have a gc that didn't pause than a gc with huge throughput nowadays
13:07:23 <vixey> mmorrow: that DList is really cool
13:07:45 <mmorrow> vixey: yeah totally. i didn't realize juts *how* cool until after i saw the graph
13:07:58 <Baughn> ehird: I'd prefer both, and a way to switch between them at runtime. Use the high-throughput one if I start lagging.
13:08:03 <kadaver> so was there a plan or not to make an API to ghc or ghcs gc to allow the user to specify when stuff should be gc'ed ?
13:08:11 <ehird> Baughn: sure, that'd be fine.
13:08:46 <mmorrow> vixey: i was trying to think whether or not you can actually replace/add a new element to it or not, but haven't tried yet
13:09:01 <sundaymorning> ha, I think I got it :)
13:09:16 <sundaymorning> I was solving this problem of logic in haskell, I think I got the answer
13:09:28 <dons> mmorrow: woo!
13:09:36 <mmorrow> dons: :)
13:09:49 <arjanb> mmorrow: how hard would it be to animate evaluation steps with that?
13:10:11 <vixey> sundaymorning: what problem is it?
13:10:25 <mmorrow> arjanb: i've been thinking about this exactly, and i'm not sure. because, exactly what would count as a step?
13:12:37 <mmorrow> arjanb: the closest i've come to doing something like this is doing something like: foldM (insert an elem into something and spit out a .dot) blah blah
13:13:32 <mmorrow> arjanb: so at that level (ie you're controlling the "steps") you can do it for sure
13:13:44 <arjanb> i see
13:14:13 <mmorrow> an opengl viewer would be friggin sweet
13:14:43 <arjanb> maybe instructions for some abstract machine could count as steps
13:14:46 <mmorrow> arjanb: but yeah, animating it "automatically" i'm not sure how to do it
13:15:33 <arjanb> or something that looks after each heap change
13:15:45 <mmorrow> arjanb: yeah, all it would take is some definition for "step", but after you go below a certain level i think it'd have to be implem at the rts level (ie in C)
13:15:46 <ddarius> @google Omniscient debugging
13:15:46 <lambdabot> http://www.lambdacs.com/debugger/
13:16:19 <arjanb> but i guess it's tricky to do and would give very nosy results
13:16:41 <mmorrow> arjanb: i think it's worth think about though for sure
13:16:47 <mmorrow> *thinking
13:17:29 <thoughtpolice> mmorrow: what expression did  you pass to vacuum to generate the dlist graph?
13:18:39 <mmorrow> also i found a "bug" in unpackClosure# in PrimOps.cmm... it checks for certain closures that shouldn't be entered, but doesn't check for *all* such closures.... so currently it's impossible not to crash if you call unpackClosure# on an MVar#, ByteArray#, etc..
13:18:45 <rushan> dou you know is there the windows binary of Leksah ide?
13:19:06 <mmorrow> thoughtpolice: iirc  dlist [0..4]
13:19:44 <mmorrow> (writeFile "dlist.dot" . render . ppGraph . nameGraph . vacuum) (dlist [0..4])
13:22:53 <brad_larsen> I'm hoping to implement mixed mode arithmetic, using typeclasses and fundeps.
13:23:38 <brad_larsen> I've looked at <http://www.haskell.org/haskellwiki/Functional_dependencies>, but am having some troubles
13:24:21 <brad_larsen> I've put a simple case at <http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=1997>
13:25:29 <brad_larsen> An expression to add two vectors together, elementwise, doesn't typecheck.
13:25:41 <brad_larsen> anyone have pointers?
13:25:47 <mmorrow> arjanb: using imagemagick's "montage" with a sequence of different versions of a structure is pretty neat http://moonpatio.com/vacuum/gallery/sequence.html
13:26:20 <wli> very spiffy
13:26:33 <mmorrow> fingertrees are sweet
13:26:53 <augustss_> yumy fingers
13:27:02 <mmorrow> mmmm
13:27:49 <thoughtpolice> mmorrow: not exactly sure how to interpret the graphs - what's S# ?
13:28:04 <mmorrow> @src Integer
13:28:04 <lambdabot> data Integer = S# Int#
13:28:04 <lambdabot>              | J# Int# ByteArray#
13:28:11 <thoughtpolice> ah
13:30:01 <mmorrow> thoughtpolice: i just chose one particular way to name the nodes, but you could do whatever
13:30:08 <thoughtpolice> yeah
13:30:29 <thoughtpolice> no it makes more sense now, I was looking at oleg's Data.FDList under vacuum and didn't do ([1..5] :: [Int])
13:30:35 <thoughtpolice> so I was wondering where S# was coming from
13:30:52 <thoughtpolice> and I looked through GHC.Types, just not GHC.Integer
13:31:07 <mmorrow> ah, heh yeah you really start to realize just how often you're defaulting to Integer
13:31:34 <thoughtpolice> yeah
13:31:54 <thoughtpolice> but yes, pretty neat. it might be interesting to hook into xmonad. :)
13:31:55 <jrEving> helo
13:33:16 <jrEving> ?: should this have a lazy end?  [x | x <- [50,100..], x < 1000] or heat the cpu?
13:33:16 <lambdabot> Maybe you meant: . ? @ v
13:33:18 <mmorrow> thoughtpolice: that would be pretty cool
13:33:28 * thoughtpolice starts up his linux box....
13:33:51 <thoughtpolice> if i have enough memory....
13:34:47 <mmorrow> thoughtpolice: the only thing is that until unpackClosure# checks for all the closure types it should be checking for so as to not enter them, it might be crashy on stuff with a bunch of arrays/other ghc-primish things
13:35:59 <mmorrow> it's currently looking a the constructor's name String and special casing J#, MVar, and STRef, but there's no way it can check for everything that could hold a *Array#, MVar#, MutVar#, ...
13:36:43 <jmcarthur> Has anybody ever written any ideas up about updating knot-tied data structures without rewriting the whole structure? I'm really just looking for abstractions that look a lot like knot tying but aren't necessarily so in implementation.
13:38:22 <jmcarthur> for example: http://en.wikipedia.org/wiki/File:Btree.svg ... would there be a way to design a similar structure such that adding an element at the lower right doesn't update the portion of the tree that points to d1 through d5?
13:38:25 <mmorrow> jmcarthur: this is relevant i think http://www.haskell.org/pipermail/haskell-cafe/2009-January/052795.html
13:38:51 <jmcarthur> actually, my example isn't really knot tying
13:38:58 <jmcarthur> but still has sharing
13:39:11 <mmorrow> jmcarthur: i think zippers would be useful there
13:39:29 <jmcarthur> mmorrow: ah thanks for that link, and you're right, zippers might be cool for that
13:40:33 <thoughtpolice> mmorrow: I'M IN UR CLOSURES, LOOKIN AT UR HEAP
13:40:40 <thoughtpolice> mmorrow: also yes, it doesn't like bytestrings :)
13:41:05 <mmorrow> thoughtpolice: aw crap, that's worth another special case check...
13:41:19 <mmorrow> i guess it's the ForeignPtr...
13:41:23 <mmorrow> @src ForeignPtr
13:41:24 <lambdabot> data ForeignPtr a = ForeignPtr Addr# ForeignPtrContents
13:41:28 <mmorrow> @src ForeignPtrContents
13:41:28 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
13:41:28 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
13:41:28 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
13:41:38 <mmorrow> MutableByteArray#
13:42:01 <mmorrow> grr
13:42:13 <thoughtpolice> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1998#a1998
13:42:49 <mmorrow> thoughtpolice: check out the comment at the very end of this file http://moonpatio.com/vacuum/haddocks/src/GHC-Vacuum.html
13:42:49 <thoughtpolice> on that note I'm really getting tired of not having full-style import syntax in GHCi.
13:42:55 <jmcarthur> ah, the email is essentially advocating using a map to emulate pointers
13:43:04 <mmorrow> jmcarthur: exactly
13:43:06 <thoughtpolice> I think I might spend a day sometime this week and hack that into GHC head
13:43:10 <thoughtpolice> it would be oh so awesome
13:43:13 <mmorrow> it would
13:43:45 <thoughtpolice> mmorrow: don't you love cmm? :)
13:43:50 <mmorrow> :)
13:44:09 <jmcarthur> Oh, I didn't even notice it was Oleg. Obviously this is the best solution, then.
13:44:28 <thoughtpolice> @hackage liboleg
13:44:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/liboleg
13:44:29 <mmorrow> so i think just adding *_ARR_WORDS + MVAR + whatever else to that one check in unpackClosurezh_fast would solve the probelm
13:44:38 <thoughtpolice> ^^ now you can have oleg whereever you code :)
13:44:46 <mmorrow> heh
13:45:02 <jmcarthur> oleg is watching you code
13:45:12 <thoughtpolice> all the time.
13:45:26 <thoughtpolice> on that note I'm glad someone finally factored out the Iteratee stuff of his and put it in a general purpose lib
13:45:31 <jmcarthur> yes!
13:45:40 <jmcarthur> i can't wait to use it in a real project
13:49:13 <rushan> !predicate
13:49:19 <rushan> analog in haskell?
13:49:39 <mauke> !slap rushan
13:49:43 <paczesiowa> not . predicate
13:49:54 <paczesiowa> > not (1==1)
13:49:56 <lambdabot>   False
13:50:03 <vixey> @quote
13:50:04 <lambdabot> olsner says: shapr: 2eyb6ard 0a5ntenance
13:50:08 <paczesiowa> > not . (==1) $ 2
13:50:09 <vixey> preflex: be poppavic
13:50:10 <preflex>  no quotes found for poppavic
13:50:10 <lambdabot>   True
13:51:18 <thoughtpolice> omfg. sup is a nice mail client and all, but its deadlock issues are a fucking pain. :(
13:51:42 * thoughtpolice is getting more and more tempted to write something in haskell, perhaps using stm and data.binary
13:52:19 <McManiaC> why doesnt "ghc --make foo.hs" give me a executable programm anymore?
13:52:34 <thoughtpolice> McManiaC: is foo.hs your Main module?
13:52:39 <mauke> what does it give you instead?
13:53:07 <thoughtpolice> McManiaC: if you have 'module FooBar ...' at the top then it doesn't think it holds main, so you either need to a) change the name to Main or b) specify '-main-is FooBar.main' to ghc or whtaever
13:55:37 <dons> mmorrow:
13:55:38 <dons> Loading package vacuum-0.0.4 ... linking ... done.
13:55:38 <dons> <interactive>: internal error: ARR_WORDS object entered! (GHC version 6.10.1 for x86_64_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:55:46 <dons> mmorrow: don't do this: Prelude Data.ByteString> ppHs $ vacuum (Data.ByteString.replicate 10 49)
13:58:51 <dons> mmorrow: could vacuum undertand UNPACK pragmas?
13:59:02 <dons> i'd love to show graphically how indirections are removed...
14:00:16 <rushan> upperBrick bp i0 | null list =  Nothing
14:00:17 <rushan> upperBrick bp i0 = Just (i0, maximum list)
14:00:19 <rushan>     where list = [j | (i, j)<-blist, i == i0]
14:00:20 <rushan>           blist = bricks bp
14:00:28 <rushan>     Not in scope: `list'
14:00:33 <rushan> ,
14:00:33 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
14:00:34 <vixey> rushan; it's true
14:00:41 <dons> wow. the sharing in IntMap is awesome, mmorrow
14:00:52 <vixey> rushan; you probably meant  | null i0
14:00:58 <vixey> rushan; but even better is   upperBrick bp [] = Nothing=
14:00:59 <vixey> rushan; but even better is   upperBrick bp [] = Nothing
14:02:01 <rushan> no, It the list defined in 'where'
14:02:23 <vixey> that's impossible
14:02:29 <vixey> rushan, where only works for a single equation
14:02:39 <hesselink> :r
14:02:47 <rushan> so, functions in where only for last pattern?
14:02:53 <vixey> only for one pattern
14:03:10 <mauke> rushan: replace the second equation by '             | otherwise = Just (i0, maximum list)'
14:03:24 <thoughtpolice> dons: I ran it over oleg's Data.FDList code - pretty neato :)
14:03:30 <thoughtpolice> (which does use IntMap)
14:04:06 <thoughtpolice> dons: also I tried it on bytestring's too - it doesn't like that. :) I was thinking of hooking it into xmonad
14:04:12 <rushan> thanks all
14:05:33 <dons> maximal sharing,
14:05:34 <dons>  http://galois.com/~dons/images/intmap.svg
14:05:36 <dons> intmap roxors
14:05:47 <jmcarthur> ooh i want to try it on FDList!
14:05:49 <dons> (fromList (zip [1..20] (repeat (0xdeadbeef::Int)
14:05:57 <jmcarthur> vacuum is just one of the coolest things ever
14:06:00 <dons> so it shows how repeat builds a cycle
14:06:08 <dons> and then IntMap builds a perfect balanced tree
14:07:53 <thoughtpolice> dons: it would be neat to run through most of containers to see how everything happens. :) maybe all of hackage's "Data Structures" category?
14:07:55 <dons> i like haskell as an EDSL to describe graphs :)
14:07:58 <dons> yeah
14:08:04 <dons> i think a tour of the data structures...
14:08:32 <jmcarthur> would be awesome
14:10:44 <conal> byorgey_: piong
14:10:50 <conal> byorgey_: make that "ping"
14:10:52 <dons> mmorrow: i'm preparing a patch to display the graphs in a pop up window from ghci
14:10:57 <dons> so its a little more interactive
14:10:59 <dons> dot2window
14:14:35 <McManiaC> is there a "isString :: a -> Bool" function?
14:14:49 <vixey> McManiaC: no
14:15:10 <trofi> McManiaC: what should it do? :]
14:15:20 <McManiaC> hmm
14:15:31 <trofi> and how do you think to use it?
14:15:34 <McManiaC> isString (String _) = True
14:15:34 <McManiaC> isString _          = False
14:15:46 <mauke> not in scope: data constructor String
14:15:46 <beelsebob> what type does the argument have?
14:15:56 <McManiaC> sth like that
14:16:04 <mauke> McManiaC: how would you use that?
14:16:08 <beelsebob> McManiaC: the point is that the type system tells you if it's a string or not
14:16:08 <trofi> isString (x :: [Char]) = True
14:16:22 <paczesiowa> you can write a function that returns True for every value of type String, and False for every other type
14:16:39 <ilyak_> hi *
14:16:56 <paczesiowa> but its type will not be a -> Bool, but SomeClass a => a -> Bool
14:17:00 <ilyak_> is there a way to use destructuring assignment in where clause and so on?
14:17:14 <beelsebob> ilyak_: no
14:17:16 <ilyak_> Like where (prev, next) = my_tuple_function
14:17:20 <mauke> ilyak_: sure
14:17:21 <ilyak_> That's unfortunate!
14:17:23 <beelsebob> assignment in Haskell does not exist at all
14:17:24 <ilyak_> how?
14:17:27 <beelsebob> ilyak_: no, no it's not
14:17:29 <mauke> like that
14:17:31 <vixey> ilyak: You just write it
14:17:37 <McManiaC> hmk
14:17:38 <beelsebob> the lack of assignment is a good thing
14:17:40 <ilyak_> mauke: Doesn't compile for me
14:17:48 <beelsebob> vixey: what he wrote was a binding, not an assignment
14:17:51 <mauke> ilyak_: what's the error?
14:18:02 <ilyak_> mauke: either ( or = out of place
14:18:07 <ilyak_> depending on the indentation
14:18:15 <ilyak_> I guess I just can't indent it correctly
14:18:24 <mauke> what compiler is this?
14:18:35 <ilyak_> ghc 6.8.2
14:18:44 <mauke> ok, then it's your fault :-)
14:18:52 <ilyak_> okay, I'll look into this
14:22:06 <TomMD> @seen dcoutts
14:22:07 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 1d 10h 25m 15s ago.
14:22:11 <TomMD> @tell dcoutts I just sent a hackage-server patch updating to happstack-0.2.  It works fine for me, but I didn't test everything and don't claim to have understood the old code fully (ex: serveTarball).  Some of the TODOs look simple enough, I'll consider knocking a couple of them out if I have time.
14:22:11 <lambdabot> Consider it noted.
14:23:28 <matthew-_> @where sortBy
14:23:29 <lambdabot> I know nothing about sortby.
14:24:30 <paczesiowa> what's the best looking decrement operator in haskell?
14:24:39 <gnuvince_> pred?
14:25:04 <paczesiowa> gnuvince_: no, should look like C one
14:25:29 <paczesiowa> (i.--);
14:25:31 <gnuvince_> Why?
14:26:17 <c_wraith> It can't mean the same thing as the C one.
14:26:22 <c_wraith> So why should it look the same?
14:26:51 <paczesiowa> c_wraith: why not? (i.--) looks better than modifyIORef ref pred
14:27:18 <mauke> paczesiowa: I disagree
14:28:10 <paczesiowa> mauke: ok, but i-=1 looks better than modifyIORef
14:28:19 <mauke> no
14:28:21 <trofi> offByOne :]
14:28:59 <ilyak_> it works
14:29:04 <ilyak_> no idea why it didn't
14:29:04 <conal> paczesiowa: you could use "incr ref"  or "ref # incr", where (#) = flip ($)
14:29:18 <TomMD> sure it can, ignoring the fact that '--' is for comments:
14:29:18 <TomMD> (--) :: (Num a) => IORef a -> IO ()
14:29:18 <TomMD> (--) a = readIORef a >>= writeIORef a . (- 1)
14:29:47 <TomMD> oh, scrolled up and too late.
14:29:47 <paczesiowa> conal: I want c dsl
14:29:50 <trofi> xmonad has -->
14:29:56 <jmcarthur> paczesiowa: why?
14:30:11 <TomMD> paczesiowa: I thought that was done before.
14:30:13 <trofi> so np using smth with --
14:30:15 <paczesiowa> jmcarthur: to write ugly haskell that looks like C
14:30:20 <jmcarthur> heh
14:30:38 <paczesiowa> > let x -- y = x - y in 1 -- 2
14:30:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:30:59 <gnuvince_> Doesn't 6.10 have suffit operators?
14:31:35 <paczesiowa> gnuvince_: yes it does have ugly postfix operators, but still, what operator should it be?
14:31:36 * _roconnor prefers to write ugly haskell that looks like BASIC
14:32:05 <CosmicRay> @hoogle doesFileExist
14:32:05 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
14:32:07 <gnuvince_> paczesiowa: ~~|**&$
14:32:28 <paczesiowa> > let x ~~ y = x - y in 1 ~~ 2
14:32:29 <lambdabot>   -1
14:32:36 <paczesiowa> gnuvince_: thanks
14:32:54 <jmcarthur> > let x ^%*&$^ y = x - y in 1 ^%*&$^ 2
14:32:55 <lambdabot>   -1
14:33:11 <paczesiowa> (i~~);
14:35:51 <brad_larsen> does anyone know about attempts to redo the number classes hierarchy to support mixed-mode arithmetic?
14:35:58 <conal> ghc-haskell now has postix ops??
14:36:32 <dons> mmorrow: got resizable dynamic svg-based graphs going now
14:36:40 <paczesiowa> > let fac n = product [1..n] in let (!) n = fac n in (10!)
14:36:41 <lambdabot>   3628800
14:37:34 <BMeph> conal: You could do the above in 6.8, even. :)
14:37:48 <conal> oh -- the section style.
14:38:28 <tristes_tigres> take a circular list like in http://www.haskell.org/haskellwiki/Tying_the_Knot . Is it possible to count its elements, given that Haskell has no notion of pointer equality ?
14:38:40 <conal> it requires parens and doesn't work for prefix, right?
14:38:47 <paczesiowa> conal: right
14:39:13 <conal> paczesiowa: you'll want --i also, right?
14:39:49 <paczesiowa> conal: no, i-- is enough (I want simple dsl, not complete ansi 99)
14:39:58 <conal> cool
14:40:06 <conal> paczesiowa: and you don't mind the extra parens?
14:40:10 <ilyak_> tristes_tigres: well
14:40:22 <ilyak_> I guess you should store its length in the list
14:40:29 <paczesiowa> conal: yeah, but what you gonna do:/
14:40:43 <ilyak_> it would bloat the list considerably, tho
14:41:12 <tristes_tigres> ilyak:  but if you are given a DList like in the wiki. is it possible to tell its length ?
14:41:13 <paczesiowa> conal: beside switching haskell syntax to prolog one
14:41:15 <conal> paczesiowa: as long as it's not something that C programmers would use, maybe you're okay.  otherwise, i worry you'll be setting up expectations that you can't fulfill.
14:42:05 <paczesiowa> why would I do anything that someone would use? avoid success at all cost!
14:42:21 <jmcarthur> tristes_tigres: a knot-tied list is an infinite list
14:42:30 <ilyak_> tristes_tigres: If the list is improper, you can't surely
14:43:06 <tristes_tigres> jmcarthur: it's circular, not infinite
14:43:07 <ilyak_> If it is...
14:43:23 <jmcarthur> tristes_tigres: it's circular in memory due to sharing, but it's theoretically infinite
14:43:25 <conal> paczesiowa: i've had some experience with functional systems that try to look mainstream.  the user's were pretty unhappy when it turned out that their expectations clashed with reality.  just my 2 cents.
14:43:36 <koeien> tristes_tigres: we can't distinguish that
14:43:46 <monochrom> Without pointer equality you can't tell for sure.
14:44:17 <monochrom> I bet pointer equality is equivalent to knowing you've cycled.
14:44:44 <koeien> no, just a sufficient condition i guess
14:44:48 <ddarius> tristes_tigres: Whether it's circular or not is an (language) implementation detail.
14:44:55 <koeien> is it defined what GHC does in this case? i guess not
14:45:00 <monochrom> And function equality is equivalent to knowing you've been rickrolled.
14:45:08 <paczesiowa> conal: scala?
14:45:36 <jmcarthur> > length $ cycle [1,2,3]
14:45:48 <tristes_tigres> ddarius: infinite list is defined differently for circular list
14:45:50 <monochrom> That takes a lot of time, doesn't it? :)
14:45:51 <lambdabot>   thread killed
14:45:54 <conal> paczesiowa: no.  ActiveVRML/DirectAnimation.  An early version of FRP, which was a Microsoft product.
14:46:07 <jmcarthur> ^^ happens to not make an infinite list in memory, but it's still infinite length
14:46:43 <conal> paczesiowa: it was purely functional but was given an OO style interface, so users assumed that the methods altered objects instead of creating new objects.
14:46:45 <koeien> jmcarthur: laziness makes it difficult to reason about this;
14:46:48 <vixey> > length $ cycle [1,2,3] < (13 :: Natural)
14:46:49 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Natural'
14:46:56 <koeien> > length [1..] -- also constant memory
14:47:05 <jmcarthur> koeien: does it? i see on problem seeing where the sharing would be
14:47:11 <jmcarthur> *see no problem
14:47:18 <lambdabot>   mueval: Prelude.read: no parse
14:47:25 <jmcarthur> koeien: assuming the compiler would do sharing, of course
14:47:26 <ddarius> tristes_tigres: The language does not require any sharing at all.
14:47:30 <dons> mmorrow: Error: t.dot:5: syntax error near line 5
14:47:31 <dons> context:     ":|0" -> >>>  {"S#|1", <<< ":|2"}
14:47:35 <dons> any thoughts on what that is?
14:47:44 <koeien> jmcarthur: no, but if there is no sharing, it still is constant space
14:47:44 <ddarius> tristes_tigres: Nor does it disallow sharing things that are semantically equal.
14:47:57 <jmcarthur> koeien: unless you are holding on to the list
14:48:12 <koeien> jmcarthur: yes. in a vacuum this is not the case, but it could be
14:48:14 <conal> paczesiowa: i think it succeeded at getting past programmers' initial defensive wall -- by fooling them.
14:48:17 <edwardk> conal: needed to do automatic differentiation over left-semi-near-rings today, your beautiful differentiation post was a lot of help
14:48:20 <jmcarthur> koeien: and assuming a garbage collector that follows behind
14:48:24 <conal> edwardk: yay!
14:48:39 <conal> edwardk: the paper is clearer & more detailed.
14:48:41 <tristes_tigres> sharing ?
14:48:48 <edwardk> yeah, went through both
14:48:48 <ddarius> tristes_tigres: So as I said, whether the list is represented as a cycle in memory or not is a language implementation detail and, as such, there can be no difference in (observable) behavior to those two implementations.
14:49:04 <jmcarthur> tristes_tigres: you can use the new vacuum package to observe sharing in ghc :)
14:49:09 <edwardk> conal: http://comonad.com/haskell/monoids/dist/doc/html/monoids/
14:49:12 <koeien> yes, you would need to store a list together with its length
14:49:21 <monochrom> vacuum package?!!??!!!
14:49:24 <jmcarthur> tristes_tigres: but it is not for use in actual programs, just for exploring ghc
14:49:30 <edwardk> conal: i figured you might be interested since you use as many of these as anyone
14:49:43 <jmcarthur> monochrom: yes?
14:49:44 <monochrom> Oh interesting!
14:49:45 <conal> edwardk: thx.  also, what's a left-semi-near-ring?
14:50:12 <edwardk> conal: a pair of monoids that have a left-distributivity law between them. its a stripped down ring
14:50:16 <monochrom> What was its motivation? Do you know?
14:50:23 <conal> edwardk: neat. thx.
14:50:52 <jmcarthur> monochrom: i forget who wrote it, but the way dons is wording some things implies to me that mmorrow may be the author?
14:51:22 <edwardk> any alternative wrapped around a monoid can be treated as a left semi near ring, which is related to how any applicative wrapped around a monoid can be a monoid
14:51:33 <tristes_tigres> jmcarthur: just like unsafePerformIO is not for use in actual programs ? ^-)
14:51:49 <mauke> unsafePerformIO is for use in actual libraries
14:51:50 <vixey> everyone uses unsafePerformIO in all programs
14:51:55 <jmcarthur> tristes_tigres: unsafePerformIO may be used in actual programs when you can prove that it is safe
14:52:07 <edwardk> conal: in particular i'm interested in them because things like regexps and parsers form left-seminearrings and i'm using a bunch of monoids for parsing
14:52:09 <monochrom> I guess the motivation is precisely to marvel at beautiful paintings.
14:52:10 <jmcarthur> tristes_tigres: vacuum should *never* be used in real programs ;)
14:52:12 <vixey> "when you can prove that it is safe" means : If you feel like it
14:52:32 <conal> edwardk: sweet.
14:52:35 <vixey> nobody actually -proves- it safe
14:52:42 <jmcarthur> (as i understand what vacuum is, anyway)
14:52:49 <jmcarthur> vixey: nobody?!
14:53:07 <jmcarthur> i have sketched proofs for cases that i was using unsafePerformIO before...
14:53:25 <tristes_tigres> jmcarthur: it can not be safe ?
14:53:27 <monochrom> Yes, we all sketch proofs, but they remain sketychy.
14:53:37 <edwardk> conal: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/ was a series of 4 posts that used them a while back which you would probably enjoy
14:53:51 <conal> edwardk: thx.  i'll check it out.
14:54:03 <jmcarthur> monochrom: but it's still "proving" ... albeit perhaps not always formal
14:54:06 <edwardk> my library can be seem as a wide generalization of that to cover sort of arbitrary google style 'map-reduce' patterns
14:54:28 <jmcarthur> tristes_tigres: it can be safe if you preserve purity
14:54:32 <thoughtpolice> unsafePerformIO  is ok in the case you can show that there are not observable side-effects to fuck everything up.
14:54:44 <thoughtpolice> e.g. bytestring
14:54:56 <thoughtpolice> although you can break referential transparency with bytestring using unsafeAsCString
14:54:56 <tristes_tigres> jmcarthur: vacuum can not be safe ?
14:55:23 <jmcarthur> tristes_tigres: vacuum exposes details of the runtime which are not semantically guaranteed by the haskell spec
14:55:36 <conal> i was thinking there could be a variant of unsafePerformIO called "safePerformIO", which is restricted to "safe IOs".
14:55:57 <sundaymorning> well, no ghc extension is guaranteed by haskell spec
14:56:00 <conal> and then offer the advice that unsafePerformIO *never* be used except to implement safePerformIO.
14:56:29 <thoughtpolice> to be fair nothing in GHC is really 'guaranteed'
14:56:40 <paczesiowa> conal: what is "safe IOs" ?
14:56:43 <jmcarthur> conal: do you mean something like safePerformIO :: SafeIO a -> a ?
14:56:49 <tristes_tigres> I just am not so sure that distinction between infinite list and cicular list is purely implementational. It seems ot me there's a semantic difference
14:56:55 <jmcarthur> conal: where safe means.... something?
14:56:55 <sundaymorning> so I don't see how that would be a good reason not to use it in _any_ real program
14:57:15 <thoughtpolice> yes, some GHC extensions are ridiculously useful
14:57:17 <jmcarthur> tristes_tigres: what is: cycle [1,2,3] ?
14:57:24 <conal> yes.  that's the next question: What's a safe IO?
14:57:25 <thoughtpolice> and unsafePerformIO is ridiculously useful inc ertain instances
14:57:26 <TomMD> I think they are in _every_ real program.
14:57:39 <sundaymorning> I usually program with ghc in mind, not haskell spec
14:57:40 <tristes_tigres> @src cycle
14:57:40 <lambdabot> cycle [] = undefined
14:57:40 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:57:55 <thoughtpolice> sundaymorning: "when you say haskell, you mean GHC"
14:58:08 <conal> any Haskell implementation is full of safe IOs, but I don't know of an underlying theory.
14:58:12 <sundaymorning> yeah, something like that
14:58:23 <koeien> tristes_tigres: you cannot distinguish  cycle [0,1]   from   map (`mod` 2) [0..]
14:58:42 <ddarius> tristes_tigres: Anything that differentiates between: cycle xs = xs ++ cycle xs and cycle xs = let xs' = xs ++ xs' in xs' by definition violates referential transparency.
14:59:01 <jmcarthur> tristes_tigres: and what ddarius said is why vacuum is also unsafe
14:59:02 <tristes_tigres> koeien: I am not talking about cycle, but about DList
14:59:14 <monochrom> tristes_tigres is confusing "what you could do if you designed another language" with "what does the haskell definition say"
14:59:16 <sundaymorning> not using non-standard stuff is often quite boring. Maybe a good idea for projects that need to run in several different machines. But then again, I'm not sure haskell would be the way to go in that case.
14:59:41 <monochrom> If you define your own language you can make all kinds of distinctions you want and provide all kinds of features you want.
14:59:46 <jmcarthur> monochrom: that seems to be a common confusion around here, i think
15:00:14 <TomMD> sundaymorning: Why not?  I've used Haskell for multi-platform work and been quite happy.
15:00:15 <monochrom> If you look at Haskell then you play by its rule, not "but I as a human could tell the difference!"
15:00:25 <jmcarthur> sundaymorning: i personally think haskell98 is becoming quickly antiquated
15:00:39 <tristes_tigres> monochrom: if I have mutable cicular list, for instance, I can surely tell it form an infinite one
15:00:40 <TomMD> Lets hope Haskell' is out sooner rather than later.
15:00:46 <TomMD> Then we move on to Haskell''.
15:00:58 <ddarius> Haskell 98 is becoming antiquated at exactly one year per year.
15:01:05 <jmcarthur> tristes_tigres: but that is not a pure list
15:01:11 <jmcarthur> ddarius: :P
15:01:24 <trofi> > ("Haskell" ++) cycle "'"
15:01:28 <lambdabot>   Couldn't match expected type `t1 -> t'
15:01:43 <koeien> > scanl (++"'") "Haskell"
15:01:45 <lambdabot>   Couldn't match expected type `b -> [Char]'
15:01:45 <jmcarthur> tristes_tigres: actually, even then... how would you tell?
15:01:47 <sundaymorning> TomMD: multi-platform like in unix and windows or multi-platform like a great deal of the exoctic platforms out there?
15:01:54 <koeien> > iterate (++"'") "Haskell" -- blah
15:01:56 <lambdabot>   ["Haskell","Haskell'","Haskell''","Haskell'''","Haskell''''","Haskell'''''"...
15:01:59 <jmcarthur> tristes_tigres: short of having access to the pointers?
15:02:04 <ddarius> jmcarthur: IORef is an instance of Eq.
15:02:06 <thoughtpolice> > ("Haskell"++) (cycle "'")
15:02:08 <lambdabot>   "Haskell'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''...
15:02:12 <jmcarthur> ddarius: oh... access to the pointers :P
15:02:16 <tristes_tigres> I could lift DList into monad
15:02:28 <jmcarthur> why is IORef and instance of Eq?!?!
15:02:43 <sundaymorning> quite neat that cycle function
15:02:43 <paczesiowa> tristes_tigres: DList is a monad
15:02:44 <TomMD> sundaymorning: I ment Unix/Windows.  Do you mean multi-platform as in numerous embedded / bare metal systems, mobile, etc?
15:02:49 <tristes_tigres> jmcarthur: I change an element, then see if any consequtive lement changed
15:02:58 <sundaymorning> TomMD: yeah, that was what I had in mind.
15:03:00 <mauke> jmcarthur: why not?
15:03:10 <tristes_tigres> pczaseiowa: I don't think so
15:03:32 <TomMD> sundaymorning: If you expand into true embedded then almost no language is good as much of the hardware has custom language querks and APIs.
15:03:49 <jmcarthur> tristes_tigres: but if you changed an element, you performed a side effect, and anything is allowed to happen if you perform a side effect
15:03:50 <ddarius> tristes_tigres: You can tell the difference between a mutable circular list and a mutable infinite list because they are observationally different.  If I mutate the first element of a circular list, then I'll have changed every pth element as well for a cycle of length p.  This is not the case for an equivalent infinite list.
15:04:11 <paczesiowa> tristes_tigres: http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/src/Data-DList.html#DList
15:04:19 <jmcarthur> tristes_tigres: anyway, you got me anyway. i don't know what i said that
15:04:22 <jmcarthur> *why
15:04:24 <tristes_tigres> ddarius: quite so, that's what I am saying.
15:04:50 <jmcarthur> i guess i got into "disagree with everything you say" mode
15:05:01 <tristes_tigres> ddarius: so if you lift into monad infinite list and cicrcular list, you can see that they are different
15:05:26 <conal> tristes_tigres: for most monads, no.
15:05:28 <ddarius> tristes_tigres: You don't "lift" values into "mutable values"
15:05:32 <sundaymorning> TomMD: yeah, that what I meant, I didn't mean like haskell is lacking that. My point was that ghc runs on unix and windows, if you want your program to work on both you don't need to follow haskell98, but you can use everything ghc offers. Now, for the wider definition of multi-platform, using haskell98 wouldn't probably even help either. So I don't see much point in sticking with the standard.
15:05:35 <paczesiowa> tristes_tigres: you can lift infinite list into Id monad and notice anything new?
15:05:36 <jmcarthur> those are no longer pure lists though
15:05:38 <conal> tristes_tigres: actualy, for all monads, no.
15:05:48 <tristes_tigres> paczesiowa: I am not talking about that DList
15:06:33 <ddarius> If you use totally different functions to -build- a mutable list, then you can do what you want.  But you can't take an existing immutable list and "view" it as a mutable list.
15:06:38 <tristes_tigres> ddarius: you don't ?
15:06:41 <sundaymorning> Just like with C and C++ I think using gcc features and definitions is fine for most programs.
15:07:32 <tristes_tigres> conal: mutable circular list and mutable infinite list ARE different. We established that
15:07:36 <TomMD> sundaymorning: Got ya!  You probably already know, but there has been lots of talk about making a haskell bare metal ARM or Linux/ARM code generator.  I wouldn't be surprised to see it actually happen some time in the next couple years.
15:07:40 <conal> tristes_tigres: lists with circular representations are infinite.  there's nothing in the semantics of lists that allow you to observe the circularity.
15:08:15 <tristes_tigres> conal: if list is mutable, you can observe the circularity
15:08:22 <sundaymorning> TomMD: yeah, it could be a good language for embedded systems. Haskell is quite flexible.
15:08:32 <conal> tristes_tigres: then it's not a "list", i.e., not a value of type [a]
15:08:48 <jmcarthur> tristes_tigres: but you have changed your argument from pure lists to mutable lists. they are different things
15:08:48 <conal> tristes_tigres: maybe we're just stumbling over terminology here.
15:08:49 <monochrom> I have never seen a mutable infinite list. How much memory does it take? Do you know?
15:09:08 <idnar> haha
15:09:11 <conal> monochrom: keep counting.  let us know how it ends.
15:09:13 <TomMD> sundaymorning: Have you followed any of the Systems Haskell work from Portland State?  They've been adding a few extentions and doing a fair amount of kernel-level work.
15:09:15 <conal> ;)
15:09:16 <tristes_tigres> jmcarthur: mkDList can be lifted to builkd a mutable list
15:09:57 <jmcarthur> tristes_tigres: I remember where I was going when I questioned the ability to tell the difference between a mutable cyclic list and a mutable infinite list...
15:10:14 <sundaymorning> not really. I don't understand much of haskell internals in order to be able to follow that kind of stuff I think :P
15:10:27 <jmcarthur> tristes_tigres: If you change a value in a mutable list, how far do you keep searching before you decide that it's just an infinite list and not a very very long cyclic list?
15:10:30 <tristes_tigres> jmcarthur: you can THAT difference
15:10:46 <ddarius> tristes_tigres: You can write a new mkDList that makes a new mutable list type and then do what you want as has already been said.  If that's what you want to do, then do it.  But you can't start at a cyclic/infinite list, and "make" it mutable and then tell that it was cyclic or infinite.
15:11:06 <centrinia> tristes_tigres, do you mean fromList :: [a] -> DList a ?
15:11:12 <thoughtpolice> TomMD: galois apparently has a branch of GHC which can run on xen
15:11:24 <thoughtpolice> which is sweet, to say the least :)
15:11:27 <tristes_tigres> centrina: I mean http://www.haskell.org/haskellwiki/Tying_the_Knot
15:12:02 <dons> mmorrow: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-cairo-0.1
15:12:14 <tristes_tigres> ddarius: you can lift an existing mkDList into mutable list type
15:12:14 <sundaymorning> I'm developing my own hobby kernel, but I'm doing it in C. I thought about haskell, but I think learning ghc internals and hardware communication would be too much for a single project :P
15:12:20 <jmcarthur> dons: sweet!
15:12:56 <thoughtpolice> dons: awesome!
15:12:57 <ddarius> tristes_tigres: You can rewrite it to produce a mutable list type.  I've said this at least twice already and this is the last time I'm going to.
15:13:02 <thoughtpolice> dons: makes life much easier :)
15:13:17 <ddarius> tristes_tigres: You can't "lift" it unless by "lift" you mean "rewrite".
15:13:29 <tristes_tigres> darius: lifting a function inot monad isn't the same as rewrtiting it
15:13:29 <centrinia> tristes_tigres, You can lift mkDList :: [a] -> DList a into a type liftM mkDList :: m [a] -> m (DList a)
15:13:36 <monochrom> "lift" is not the same as "rewrite"
15:13:43 <tristes_tigres> centrina: that's what I mean
15:13:44 <centrinia> What do you do with an m (DList a)
15:14:00 <jmcarthur> tristes_tigres: "lifting" a pure list into a monad does not make it mutable
15:14:04 <tristes_tigres> ddarius: I mean lift and not rewrite
15:14:12 <ddarius> tristes_tigres: Then that won't change anything.
15:14:16 <centrinia> tristes_tigres, What is an (Monad m) => m (DList a) good for?
15:14:28 <monochrom> If you have access to source code, you can observe the difference between "lift" and "rewrite".
15:15:00 <tristes_tigres> ddarius: we agreed that a mutable circular and infinite lists are semantically differnet
15:15:30 <tristes_tigres> centrina: to tell the difference between a circular and infinite list
15:15:41 <ddarius> tristes_tigres: Lifting won't lead to a mutable list.  It will make an action that produces the same immutable list as jmcarthur said.
15:15:42 <pipio> alo
15:16:41 <jmcarthur> tristes_tigres: did you not see what i said earlier? you can only prove a mutable list is cyclic, but you can't prove that it's not if it's infinite
15:17:00 <centrinia> You could make DList an instance of Traversable. ;)
15:17:20 <tristes_tigres> jmcarthur: yes, and that means tha circular and infinite lists are semantically different
15:17:39 <jmcarthur> tristes_tigres: ... but you can't tell the difference in all cases...
15:18:03 <ddarius> tristes_tigres: Write a "lift" function such that "lift mkDList" produces a mutable list and then come back when you have the code.
15:18:15 <jmcarthur> tristes_tigres: how far do you go in a list before you declare that it is infinite?
15:18:18 * monochrom tries harder
15:18:39 <monochrom> If you can look at the source code, you can tell the difference between circular logic and infinite wisdom. :)
15:18:52 <tristes_tigres> jmcarthur: you can not prove in all cases, so what
15:18:55 <centrinia> jmcarthur, 5
15:19:16 <dons> http://www.youtube.com/watch?v=X4-212uMgy8
15:19:19 <dons> vacuum live
15:19:39 <monochrom> onoes, youtube demos
15:20:15 <dons> :P
15:20:19 <desp> dons: woha
15:20:21 <jmcarthur> tristes_tigres: if the difference is not observable, then it's not observable. i don't really know what else to say
15:20:36 <conal> tristes_tigres: some people are satisfied with solutions that sometimes work, and some people aren't.
15:20:45 <centrinia> If the difference is not observable, then they are semantically equivalent.
15:20:46 <mae> bos:
15:20:46 <tristes_tigres> jmcarthur: it is sometimes observable.
15:20:49 <mae> bos: you around
15:21:03 <bos> yep
15:21:10 <tristes_tigres> centrina: it is not necessarily not observable
15:21:27 <ddarius> tristes_tigres: If you are confident that you can write the appropriate "lift" function, stop arguing and go write it and then show it to us.
15:21:38 <jmcarthur> dons: sexy
15:21:45 <conal> here's a lovely quote from Buckminster Fuller: "When I'm working on a problem, I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong."
15:21:51 <mae> bos: would it be reasonable to change the dependency from unix to unix-compat: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip... I would like to use FileManip portably in windows :)
15:22:01 <centrinia> ddarius, would a nonconstructive proof of the existance of "lift" count as well? :)
15:22:05 <mae> bos: was using it for copying some datafiles for happstack
15:22:05 * jmcarthur votes for ddarius's suggestion
15:22:09 <ddarius> centrinia: Nope.
15:22:18 <vixey> "nonconstructive proof" ?
15:22:26 <tristes_tigres> conal: if there are programs that produce different results on infinite lists and circular lists, than they are semantically different
15:22:51 <centrinia> vixey, That's a proof of the existence of something that does not explicitly define what that something is.
15:22:55 <bos> mae: does it work if you do that?
15:22:55 <jmcarthur> can there even be a such thing as a nondestructive proof if we are talking about programs?
15:23:01 <conal> tristes_tigres: yes, assuming those programs are defined within the same semantic framework as the lists.
15:23:22 <mae> bos: have not tested yet :) but after using filemanip i realized that the windows build was broken
15:23:28 <mae> i shall try
15:23:38 <tristes_tigres> conal: then mutable circular lists and infinite lists are semantically different. QED
15:23:55 <mae> (on windows)
15:24:04 <conal> tristes_tigres: again, you're using "lists" differently from haskell lists, i.e., [a].
15:24:26 <jmcarthur> tristes_tigres: this is all moot if you can't come up with that definition of lift that we are eagerly awaiting
15:24:39 <vixey> tristes_tigres: "QED"?
15:24:50 <vixey> tristes_tigres: usually say that after you proved something..
15:24:52 <tristes_tigres> vixey: yes
15:24:58 <centrinia> Quantom ElectroDynamics
15:24:58 <mae> bos: point me a to where your source repository is and i'll send you a patch
15:25:15 * jmcarthur gives up because it is obvious that tristes_tigres is flat out ignoring the challenge
15:25:22 <centrinia> Uh, Quantum ElectroDynamics
15:25:29 <conal> tristes_tigres: do you understand the difference between a programmatically mutable "list" representation and the possibly-circular *representation* of programmatically-immutable lists?
15:25:32 <tristes_tigres> vixey: I just proved that mutable circular lists and infinite lists are semantically different
15:25:51 <rushan> haskell has not C++-like function overloading, so very hard to work with overloaded operators. e.g. I must do VectorD.+ instead +, becouse it is intersect with + operator for numeric. Is therer some fix?
15:25:53 <ilyak_> conal: you've just exploded my brane
15:25:55 <ilyak_> gratz
15:26:06 <conal> ilyak_: any time :)
15:26:14 <bd_> > let (<+>) = (+) in 4 <+> 5
15:26:14 <iago> rushan, make a Num instance
15:26:14 <lambdabot>   9
15:26:22 <bd_> rushan: You could declare a new shorthand operator like that
15:26:25 <vixey> tristes_tigres: what
15:26:40 <vixey> nothing is mutable
15:26:42 <conal> tristes_tigres: i'm wondering if you're confusing the two.  or maybe talking about one notion with words that people take to refer to the other.
15:26:46 <bd_> iago: that would require a fromInteger. How do you do that with a vector?
15:26:53 <conal> vixey: indeed!
15:27:00 <erikcyber> alo
15:27:02 <iago> bd_, 1-length vector?
15:27:05 <vixey> hi conal
15:27:06 <conal> vixey: (also, everything)
15:27:11 <conal> vixey: hi!
15:27:12 <tristes_tigres> vixey: nothing is mutable ?
15:27:15 <conal> vixey: how's life?
15:27:22 <bd_> iago: So, you'd have the same type for 1-length and 2-length vectors? How do you add those? :)
15:27:41 <dons> dcoutts: slapping a cairo gui on top of ghci turns out to be easy
15:27:46 <dons> gtk2hs++
15:27:53 <vixey> :)
15:28:04 <vixey> conal: I try to write something that is FRP tommorow
15:28:05 <mauke> bd_: (x) + (y,y) = (x,y,y)
15:28:08 <iago> bd_, you have the same type for 1-length list than for 2-length list, what's the problem
15:28:16 <vixey> just a little animation
15:28:18 <conal> vixey: sweet!  good luck.
15:28:25 <vixey> thanks
15:28:51 <dons> mmorrow: i'm not sure the graph nodes need to be numbered in vacuum
15:28:54 <bd_> mauke: so, (x,x) + (y,y) = (x,x,y,y)? that's not a vector
15:28:55 <bos> mae: http://darcs.serpentine.com/filemanip/
15:28:56 <dons> i'd instead prefer to see the contents of the boxes
15:29:05 <tristes_tigres> conal: I don't know what is the word "programmatically" doing in your question. I, naturally, am not talking about lists that are mutable by cosmic rays hitting the RAM storage
15:29:12 <dons> e.g. (C# 1) --> (:) x y ...
15:29:14 <bd_> iago: The thing is, vectors imply you should be able to add them. Vector addition only makes sense when the two input vectors have the same length
15:29:22 <rushan> thanks
15:29:47 <dons> mmorrow: make sense? e.g. in http://code.haskell.org/~dons/images/vacuum/intmap.png
15:29:54 <dons> numbering the nodes doesn't tell us anything.
15:29:59 <dons> but if we could get at the node contents..
15:30:09 <conal> tristes_tigres: np.  i mean whether mutation happens by a Haskell (for instance) program or by the Haskell implementation's run-time system.
15:30:12 <McManiaC> aLoading package readline-1.0.1.0 ... can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
15:30:21 <McManiaC> whats the problem here?
15:30:22 <McManiaC> :S
15:30:29 <iago> bd_, there are ways to address this problem, Vector Int [a] + check
15:30:48 <dons> mm. need to make the gui interactive. reusing a single panel
15:31:01 <iago> bd_, anyway, how do you want to represent each vector? using type-level programming?
15:31:29 <tristes_tigres> conal: I am not talking about mutable representations of the list. I am talking about lists whose values can be chaged by a program
15:31:38 <tristes_tigres> the values of elements
15:32:21 <conal> tristes_tigres: that's what i thought.  my hunch is that when you raised the subject, people thought you meant programmatically-immutable lists that have circular representation.
15:32:58 <conal> tristes_tigres: when people talk about "lists" here, they typically mean values of type [a].
15:33:14 <conal> tristes_tigres: so there may have been an early misunderstanding.
15:33:14 * jmcarthur thought that as well, until tristes_tigres claimed to be able to lift such a list into the realm of mutable lists and observe the difference after lifting
15:33:23 <bd_> iago: Well, encoding the vector size in the type would certainly be nice :)
15:33:58 <conal> jmcarthur: hm.  i see.  maybe confusions compounded.
15:34:01 <bd_> iago: but then fromInteger doesn't make sense, of course...
15:34:06 <bd_> nor does abs
15:34:08 <dons> some more data structure visualization fun, http://www.youtube.com/watch?v=A1wtQ_mYHHo
15:34:14 <dons> cyclic structures rock
15:34:18 <vav> Can type system restrict f :: [a] -> [a] to involutions, i.e. f . f == id is True? I've param f that so far seems hard to hide from users but if not id or reverse or another involution breaks code.
15:34:41 <iago> bd_, abs (1,-1,-2) == (1,1,2)
15:34:44 <iago> for example
15:34:48 <jmcarthur> conal: perhaps. i think you are more patient than i am though
15:34:53 <iago> vectorial abs :P
15:35:01 <conal> jmcarthur: not always!
15:35:03 <ddarius> vav: Haskell's can't, though you could make an abstract type representing such involutions and use Haskell's type system to enforce the abstraction.
15:35:46 <McManiaC> hi, im trying to use the readline package. so i put a "import System.Console.Readline" at the beginning of my .hs, but when i try to run main i get "Loading package readline-1.0.1.0 ... can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)"
15:36:10 <conal> vav: by keeping the representation private and proving that your own operation preserve involution-ness.
15:36:25 <tristes_tigres> unfortunately, askell standard library does not have Data.List.MList analogous to Data.Array.MArray
15:36:31 <conal> "involutionarity", "involutionousity"?
15:37:02 * Heffalump wonders what conal's conclusion was about denotational semantics for Haskell (re the haskell-prime thread)
15:37:12 <bd_> iago: that's not how abs is defined on a vector :)
15:37:18 <jmcarthur> Heffalump: which thread was this?
15:37:19 <bd_> abs on a vector produces a scalar
15:37:40 <bd_> iago: basically the point I'm trying to make is a vector isn't a number as defined by Num
15:37:40 <tristes_tigres> conal: I don't see how my words can be possibly interpreted that way
15:38:11 <iago> octave:2> abs([1,2,-3])
15:38:11 <iago> ans =
15:38:11 <iago>    1   2   3
15:38:18 <jmcarthur> oh, so there _was_ a misunderstanding
15:38:28 <iago> bd_, anyway, return a 1-length vector with the result :D
15:38:31 <Heffalump> jmcarthur: the one about Bools being tainted by Int - I forget the subject line
15:38:39 <jmcarthur> oh!
15:38:44 <bd_> iago: and now we come back to what does [1] + [2,3] equal?
15:38:45 <iago> bd_, although the type changes, ure
15:38:47 <iago> sure
15:38:48 <jmcarthur> yeah, i'm a little thrown off by that one too
15:38:55 <vav> ddarius, conal thanks, yes, expected such response. I think will work harder to refactor to keep from users rather than try abstract type. (Too fuzzy understanding of how monoid monad laws are enforced as it is.) This is early version of code anyway.
15:38:56 <mae> bos: ahh looks like you use System.Posix.Temp which is not available on unix-compat :\ nm for now
15:39:07 <tristes_tigres> so assuming a Data.ListMList similar to Data.Array.MArray, I could lift mkDList into this monad to make circular mutable list
15:39:09 <blackh> dons: By using YouTube you're excluding Ubuntu 64 bit users like myself. :/
15:39:17 <conal> Heffalump: i concluded that Haskell programs that use Int are unportable (failing a proof obligation) and are unsafe for distributed & migratory use.  and that the simplest way to look at the denotational semantics is that there are different Haskell languages with different semantics.
15:39:23 <jmcarthur> blackh: how is that excluding ubuntu 64 users?
15:39:30 <iago> bd_, say me please why <+> hasn't the same "problem"
15:39:41 <TomMD> How about non-flash users.   Could we just use ogm files?
15:40:02 <bd_> iago: because we're no longer in Num, and so we can simply not define fromInteger and friends. Then we just encode the size of the vector in the type, so the statement [1] + [2,3] is rejected with a type error
15:40:09 <Heffalump> conal: fair enough. You probably want a .NET language if you want that kind of portability.
15:40:21 <Heffalump> (or JVM)
15:40:42 <bd_> iago: likewise, we can define a vectorAbs :: Num n => Vector n a -> n (where a is a tag type giving vector dimensionality)
15:40:54 <blackh> jmcarthur: Nope. Adobe has not lowered itself to supporting 64 bit Linux yet.
15:40:55 <jmcarthur> or a more precise spec for Haskell' :)
15:41:06 <jmcarthur> blackh: really?
15:41:08 <conal> Heffalump: what does run-time environment have to do with giving a specific semantics to a language?
15:41:13 * jmcarthur wonders what flash he's using on Arch 64
15:41:26 <conal> jmcarthur: yes.  that's what i really want.  for haskell' to fix the semantic leak.
15:41:37 <c_wraith> jmcarthur: very likely 32-bit flash.
15:41:53 <Heffalump> conal: it helps to resolve the tension between under-definedness and efficient implementation
15:42:00 <blackh> jmcarthur: I don't like lockdown software, and I'm not going to jump through hoops to use it.
15:42:07 <conal> Heffalump: how?
15:42:16 <sundaymorning> by using youtube you're excluding people who don't have flash, like myself :P
15:42:29 <Heffalump> by providing a platform that is more defined than the hardware it runs on
15:42:43 <conal> Heffalump: and what's to stop Haskell from doing so?
15:42:56 <conal> Doesn't SML have a precise semantics?
15:42:59 <Heffalump> the time available to implementors
15:43:22 <jmcarthur> c_wraith: from the PKGBUILD http://download.macromedia.com/pub/labs/flashplayer10/libflashplayer-${pkgver}.linux-x86_64.so.tar.gz
15:43:23 <Heffalump> I've never read the definition, so I don't know.
15:43:41 <conal> Heffalump: i suspect it'd be more efficient if the implementors didn't have multiple semanticses to implement.
15:43:42 <jmcarthur> blackh: meh, no hoops for me to jump through :)
15:43:52 <jmcarthur> c_wraith: that may be an alpha or something, but it works great for me
15:44:00 <Heffalump> the point is that they can pick a convenient one
15:44:06 <Heffalump> not that they have to implement several different ones
15:44:26 <conal> Heffalump: we could just define Int = Int32.
15:44:31 <conal> sounds convenient to me.
15:44:33 <blackh> jmcarthur: YouTube is proprietary. YouTube's free bandwidth comes at a cost to freedom.
15:45:05 <jmcarthur> blackh: oh please. what freedom do i lose by willingly using youtube?
15:45:22 <Heffalump> we could, and then Int would be inefficient on non-32 bit platforms
15:45:22 <blackh> jmcarthur: The freedom not to have proprietary software doing who-knows-what on your system.
15:45:28 <rovar> the ability to look at its source code :)
15:45:49 <blackh> jmcarthur: In other words, the freedom not to be spied on.
15:45:56 <c_wraith> nothing about youtube requires you to execute proprietary code on your system
15:46:07 <jmcarthur> blackh: i have that freedom and exercise it regularly, but that doesn't mean i _can't_ use whatever software i want
15:46:09 <iago> bd_, well, fromInteger is a problem in this case, yes
15:46:12 <conal> Heffalump: I care that my code has a precise & tractable meaning.  I know that not everyone cares.
15:46:23 <blackh> c_wraith: Is there an open source flash player that works with YouTube? I haven't found one yet.
15:46:25 <jmcarthur> blackh: and as c_wraith says, you don't have to use adobe's proprietary flash player
15:46:41 <iago> bd_, although encode dimension in type a restriction that you imposed, not who ask
15:46:41 <sundaymorning> there's one that works more or less
15:46:45 <jmcarthur> blackh: there are several, as well as a way to make firefox use vlc or somesuch
15:46:48 <conal> Heffalump: one reason i wrote to haskell' about the matter was to find how who does care.  apparently, not many.
15:46:49 <jmcarthur> for flash media
15:46:52 <c_wraith> you don't even need a flash player.  it's trivial to extract the video url from the flash file, and play it with other software
15:46:57 <sundaymorning> but I rather not use any of them
15:46:57 <Heffalump> right, and that's why I'm suggesting that you look at execution platforms that offer more consistency of semantics
15:47:07 <blackh> jmcarthur: Thanks - I'll see what I can find. Last time I tried, it crashed.
15:47:10 <lament> blackh: if you're paranoid, you can always run the flash player inside a virtual machine so there's nothing useful to spy on
15:47:24 <dons> blackh: i'm using arch 64 bit /flash
15:47:30 <jmcarthur> blackh: to be honest, i stick with adobe's because it seems to work best, but i know a couple people you run mplayer or vlc as their flash media player
15:47:36 <dons> blackh: grab the adobe flash 64 bit plugin released last month
15:47:47 <conal> Heffalump: still doesn't make sense to me.  could those platforms be any more efficient than haskell's current platforms at semantically-precise data types?
15:48:03 <blackh> It's just the principle of the thing. Why should I be forced to install software that could be (and probably is) spying on me?
15:48:16 <blackh> That is, it's not paranoida.
15:48:17 <Heffalump> glancing through the SML basis library makes me think that it at least is imprecise about when Overflow exceptions are thrown, btw: http://www.standardml.org/Basis/integer.html
15:48:43 <jmcarthur> lament: a certain x86 vulnerability means that a root process can escape a virtual machine :(
15:48:45 <Heffalump> conal: my suspicion is that JIT compilation helps a lot there. It's just a suspicion though.
15:48:52 <jmcarthur> lament: root in the virtual machine, that is
15:48:53 <conal> Heffalump: oh, okay.
15:49:02 <lament> jmcarthur: hah
15:49:22 <conal> straw poll:  who is troubled that the semantics of Int is unspecified by the Haskell language spec and in fact has multiple, inconsistent implementations?
15:49:28 <jmcarthur> lament: and in fact can inhabit SMM, which is even above BIOS
15:49:49 <mauke> conal: what's the inconsistency?
15:49:51 <Heffalump> hmm, actually I'm not sure that it does help, because an implementation could always do exactly what the JIT does itself. So perhaps I'm talking nonsense.
15:50:03 <jmcarthur> conal: me, but only because Int is so standard in the libraries
15:50:10 <Heffalump> mauke: that Int is unspecified beyond being at least 29 bits, so wrap-around etc can happen at different points
15:50:19 <pejo> Heffalump, implementation burden is still an issue though.
15:50:26 <jmcarthur> conal: if the libs defaulted to using one of the more specified types i would be okay with the existence of Int
15:50:34 <mauke> Heffalump: does it guarantee wraparound on overflow?
15:50:36 <conal> jmcarthur: yeah, me too for that reason.  it's not an esoteric, implementation-level things.
15:50:38 <Heffalump> pejo: yeah. .NET/JVM centralise the portability burden
15:50:47 <Heffalump> mauke: don't think so, but that just increases the undefinedness
15:50:56 <mauke> meh, I'm fine with that
15:51:01 <mauke> C only gives me 16 bits
15:51:02 <conal> mauke: one is 32-bit vs 64-bit.  so that an int-containing boolean expression can evaluate to true sometimes and false sometimes.
15:51:14 <iago> bd_, or
15:51:15 <iago> data Vec s a =
15:51:15 <iago>         Vec [a]
15:51:15 <iago>     |   ConsVec a
15:51:15 <iago>     deriving (Eq, Show)
15:51:21 <iago> fromInteger i = ConsVec $ fromInteger i
15:51:21 <iago> :P
15:51:39 <Heffalump> I think it would be nice to have a core that is fully defined.
15:51:53 <conal> another question: who uses Int in their Haskell programs and then claims that they are portable?
15:52:02 <conal> i used to, but now i know better.
15:52:11 <jmcarthur> conal: another way to look at it, though, is that Int is only well-defined for integers less than 2**29 or whatever it is. you could consider any program that brings an Int above that number to be "incorrect"
15:52:14 <mauke> I do
15:52:32 <conal> jmcarthur: yeah -- that's what i mean by a proof obligation.
15:52:48 <jmcarthur> conal: oh i didn't see the mention of proof obligation
15:53:16 <mauke> Int is the least of my problems
15:53:19 <Heffalump> I wouldn't claim any program I'd written was portable without thinking about the limits of that portability, including Int.
15:53:22 <jmcarthur> but yeah, i think Int is no less dirty than a partial function
15:53:24 <mauke> I'd rather have a way to get at argv[0]
15:53:28 <jmcarthur> and no more, i mean
15:53:56 <conal> meanwhile, maybe i'll propose that hakell' renames (+) to "unsafePlus", etc.
15:53:57 <sioraiocht> can someone give me an example of a unary product?
15:54:02 <jmcarthur> conal: have you looked at agda, btw?
15:54:02 <conal> (not really :p)
15:54:17 <conal> jmcarthur: i've looked at dependent languages but not lately.
15:54:21 <conal> sioraiocht: 3
15:54:30 <sioraiocht> conal: can you explain?
15:54:39 <mauke> :t product
15:54:42 <lambdabot> forall a. (Num a) => [a] -> a
15:54:43 <conal> sioraiocht: it's product [3]
15:54:43 <jmcarthur> conal: might i recommend a look? i suspect that it may be more to your liking along these lines
15:54:51 <conal> jmcarthur: thanks!
15:54:56 <sioraiocht> i am struggling to conceptualise them in category theory
15:55:11 <pejo> jmcarthur, doesn't Agda compile down to Haskell though?
15:55:16 <conal> sioraiocht: sry.  a silly response.  oh! in CT
15:55:27 <sioraiocht> conal: yeah, sorry, heh
15:55:47 <jmcarthur> conal: its standard libs are very much in flux right now too, so you may be able to convince them about such things more easily :)
15:55:56 <sioraiocht> I understand the notion of finite, and even nullary products
15:56:04 <sioraiocht> but unary seem weird
15:56:12 <sioraiocht> and distinct from finite products
15:56:14 <jmcarthur> pejo: yes, but conal is after well-defined semantics as i understand it. implementation is a detail
15:56:36 <Heffalump> quite a big detail for a standardisation effort that is mainly aiming to codify existing practice!
15:56:50 <pejo> jmcarthur, what good is a well-defined semantics if no implementation follows it?
15:57:10 <conal> pejo: if the semantics were defined, the implementations would follow it.
15:57:12 <jmcarthur> pejo: what do you mean? the implementation is merely in progress, as is any.
15:58:01 <conal> the reason we have inconsistent haskell implementations is that the spec was imprecise.
15:58:21 <Heffalump> but perhaps the spec was made imprecise because people wanted implementation freedom?
15:58:24 <mmorrow> dons: whoa, awesome!
15:58:32 <jmcarthur> conal: to be as upfront about this as possible, agda is still in early enough stages that i don't think there is much of a spec yet
15:58:35 <conal> Heffalump: that's my suspicion.
15:58:37 <Heffalump> in fact my impression of the 29-bit stuff was that it was done precisely for that reason
15:58:45 <iago_> bd_, ok, I understand you now, but I usually call this generalized-abs "norm"
15:58:50 <conal> jmcarthur: sry.  i was still talking about haskell.
15:58:59 <jmcarthur> conal: yeah, i was just letting you know
15:59:02 <conal> thx
15:59:55 <mmorrow> dons: ah, the "syntax error" is just a warning since i'm using nonstandard dot syntax "a -> {b, c, d}"
16:00:40 <xplo45_> Hello
16:01:02 <mmorrow> dons: re: the numbered nodes, i'm going to add maybe a ppDotWithConfig :: Config -> ...
16:03:03 <conal> doesn't the semantic inconsistency of Int break referential transparency ?
16:03:20 <dons> mmorrow: ok. i'll tune the interactive gui some more.
16:03:31 <Botje> what, int is broken?
16:03:36 <beelsebob> conal: can you give an example?
16:03:37 <conal> people do seem to care about RT
16:03:49 <cads> hey, do you guys know a place that would host a little wiki for a programming language learning group?
16:04:07 <ppavelV6> conal: RT gives me a comfortable feeling of safeness :)
16:04:23 <Heffalump> it breaks it if you introduce remoting
16:04:26 <conal> beelsebob: of an expression that evaluates differently on different machines?
16:04:32 <ppavelV6> cads what kind of wiki?
16:04:38 <Heffalump> but I don't think that's generally considered to be part of RT
16:04:48 <jmcarthur> should it be?
16:04:50 <beelsebob> conal: I can think of plenty of expressions that evaluate differently given different environments
16:05:01 <ppavelV6> cads:  if anything else will fail contact me. I can't guarantee 100% uptime though. Closer to 99.9 maybe
16:05:04 <Heffalump> jmcarthur: *shrug*. It's a trade-off
16:05:08 <conal> beelsebob: i mean *closed* expressions, btw.
16:05:10 <beelsebob> what I'd like to see is one that evaluates differently on the same machine in the same program
16:05:15 <beelsebob> closed?
16:05:27 <cads> ppavelV6: we're just going through a book now, and we've been using a google docs to put together some collaborative notes
16:05:28 <conal> beelsebob: (no free variables)
16:05:33 <Heffalump> beelsebob: supposedly not dependent on an external environment
16:05:43 * BMeph is annoyed at the vast volume of concurrent computation papers...that assume the use of oblect-oriented PLs.
16:05:47 <beelsebob> I'm not sure such expressions exist in Haskell
16:05:50 <Heffalump> but of course with an under-defined semantics, everything is dependent on the implementation
16:05:55 <ddarius> cads: If it is Haskell related, you could just use a section of the wiki.
16:06:02 <cads> ppavelV6: I'm betting I can find a place that hosts free wikis :)
16:06:15 <conal> beelsebob: i wonder why people are unsatisfied with an expression evaluating inconsistently on the same machine but are satisfied if the inconsistency is between machines.
16:06:16 <ddarius> BMeph: Shouldn't make to much of a difference.
16:06:18 <beelsebob> integers have environment, that you can't inspect :(
16:06:37 <cads> ddarius: I'll be translating some haskell code into clojure for some examples, but it's mostly about clojure
16:06:40 * ppavelV6 didn't have an idea to charge cads :)
16:06:42 <beelsebob> conal: I'm not saying it's a good thing, merely that I'm unsure that it counts as breaking RT
16:06:44 <conal> maybe RT has become a sort of cargo cult.
16:06:57 <Heffalump> conal: because they don't actually move their code to other machines in that way
16:07:15 <conal> Heffalump: for now, they don't.
16:07:31 <Heffalump> also, the inconsistency is small in the sense that it's often easy to discharge the proof obligation in your head
16:07:33 <ddarius> And when they do, presumably such details will be specified.
16:07:43 <Heffalump> right
16:08:10 <conal> wikipedia says: "An expression is said to be referentially transparent if it can be replaced with its value without changing the program".  sounds like Int breaks RT by this definition.
16:08:13 <jmcarthur> We embraced purity before massive parallelism. Why do we cast away even stronger purity before distributed computing?
16:08:23 <conal> jmcarthur: exactly.
16:08:49 <beelsebob> conal: except that what I'm saying is that Haskell's (ill defined) semantics for integers has an environment which encompasses the computer theyre running on
16:08:54 <conal> beelsebob: the bit about single machine vs multiple -- i suspect it's a rationalization, not a reason.
16:08:56 <beelsebob> and that you're talking about two distinct values
16:09:13 <mmorrow> dons: i'm going to add a special case check so ForeignPtrs (==> ByteString) won't crash, but the root of the problem is in unpackClosure#. i'm going to file a bug rpt.
16:09:24 <conal> beelsebob: i'm not following.  what do machines have to do with Int semantics?
16:09:48 <beelsebob> conal: the fact that Haskell defines the semantics as "whatever the machine does with an int"
16:10:01 <Heffalump> actually it's "whatever the implementation does" which is slightly different
16:10:05 <Heffalump> but amounts to roughly the same thing
16:10:11 <beelsebob> yeh
16:10:21 <conal> beelsebob: which has nothing to do with RT does it?
16:10:32 <beelsebob> I don't think so
16:10:35 <conal> btw, by "rationalization", i mean a way to hold/defend a belief rather than to arrive at one.
16:10:41 <beelsebob> it means that your program is dependant on the computer it's running on
16:10:48 <beelsebob> which is a failing in the semantics
16:10:51 <beelsebob> but I don't think it breaks RT
16:11:11 <conal> beelsebob: i wonder.  from my reading of the wikipedia definition, it does indeed break RT
16:11:14 <jmcarthur> haskell :: Machine -> Semantics
16:11:37 <beelsebob> conal: I think jmcarthur's statement sums up what I'm talking about
16:11:50 <centrinia> haskell :: RealWorld -> (RealWorld,Semantics)
16:11:56 <conal> beelsebob: if you replace an ambiguous expression by its value, then you get a program that means something different.
16:12:00 <jmcarthur> centrinia: oh it's horrible!
16:12:05 <conal> beelsebob: because it's less machine-dependent than it used to be.
16:12:14 <beelsebob> conal: then that's not the value of the expression
16:12:33 <centrinia> jmcarthur, How about : haskell :: IO Semantics ?
16:12:43 <conal> beelsebob: if it's not, then "evaluating" an int expression in ghci does not give its value.
16:12:57 <beelsebob> true
16:12:58 <beelsebob> hmm
16:12:59 <conal> beelsebob: it instead give on element of its set-valued value.
16:13:11 <beelsebob> yeh, good point
16:13:14 <ddarius> conal: That's one way of viewing it.
16:13:33 * ppavelV6 asleep
16:13:47 <jmcarthur> conal: i think what beelsebob is getting at is that what the value of an expression is is not defined by the spec, which is precisely what you are arguing is a bad thing
16:14:00 <beelsebob> jmcarthur: no, I'm arguing that it's defined
16:14:05 <beelsebob> conal is arguing that it isn't
16:14:15 <beelsebob> and that because it isn't you get different answers in different places
16:14:18 <jmcarthur> or rather, it's defined by a spec which is a function of implementation, like i said :\
16:14:26 <beelsebob> yeh
16:14:27 <conal> beelsebob: no, i agree.  we're using different words.
16:14:39 <conal> beelsebob: what you call "machine-dependent", i'm calling "imprecisely defined"
16:14:58 <beelsebob> no, I agree on the imprecise definition part too
16:15:07 <conal> beelsebob: and not just machine-dependent but also implementation-dependent.
16:15:08 <beelsebob> and I'm coming round to the breaknig RT idea too
16:15:30 <Heffalump> I'm happy with RT being limited in scope.
16:15:54 <conal> Heffalump: to programs that don't use unsafePerformIO or Int?
16:15:58 <Heffalump> If we want it to extend to distributed computing we'll have to increase the constraints on implementation.
16:16:02 <Heffalump> no, to one implementation.
16:16:21 <ddarius> You can precisely define the semantic domain to be a function of machine/implementation configuration and thus the total result of the program would be a function machine/implementation configuration.
16:16:28 <beelsebob> conal: I do remember Colin Runciman making a comment that he was rather disapointed with the definition of naturals/ints in Haskell
16:16:37 <Heffalump> ddarius: sure, but that's a cop-out on the same lines as IO, really.
16:16:58 <conal> beelsebob: yeah.  i'm glad you got exposed to Colin.  he seems to really believe in functional programming.
16:17:01 <Heffalump> it doesn't actually help you do anything
16:17:13 <jmcarthur> it's a matter of what you do with imprecise semantics. the majority consensus so far seems to be that the implementation inhabits some subset of the defined behavior which is precise and then anything within that is RT
16:17:27 <ddarius> Heffalump: Only if you leave "machine/implementation configuration" completely open, but you can precisely define it to include such things as the behavior of Ints.
16:17:29 <conal> ddarius: yes, that precise definition is what i meant by "imprecise".
16:17:32 <beelsebob> conal: apparently it was a rather large bone of contetion in the original design
16:17:50 <conal> beelsebob: glad to hear!  now people don't seem to notice.
16:17:55 <jmcarthur> anyway, i have to leave now. shame :(
16:17:57 <conal> beelsebob: or care.
16:18:10 <beelsebob> well, I think it was a one or the other thing
16:18:15 <beelsebob> you can have efficient implementation
16:18:19 <beelsebob> or you can have real semantics
16:18:33 <conal> beelsebob: which i understand if the language were C.
16:18:41 <Heffalump> if you want to ensure full RT you have to actively ban *any* (non-IO) code that is implementation-dependent
16:18:59 <beelsebob> conal: I can similarly say "I understand the oposite if the language were lambda calculus"
16:19:24 <mae> argh i wish filemanip were portable :)
16:19:26 <beelsebob> note, I may slightly be playing devils advocate now
16:19:37 <conal> beelsebob: yeah, me too.  it's just that my impression used to be that haskell designers and some practitioners were unwilling to sacrifice semantics for implementation expedience.
16:19:50 <conal> beelsebob: my impression has changed. :(
16:20:08 <conal> beelsebob: but, hey.  what is, is.
16:20:14 <beelsebob> yeh
16:20:17 <ddarius> conal: There are several examples of just that happening besides Ints, e.g. the monomorphism restriction.
16:20:34 <beelsebob> the MR isn't about efficient implementaiton
16:20:38 <kadaver> how trixy would it be to write a wireless card driver for Ubuntu in haskell?
16:20:39 <beelsebob> it's about assuming that users are dumb
16:20:57 <Heffalump> it still favours operational concerns over semantic ones
16:21:01 <conal> beelsebob: yeah.  like removing monad comprehensions.
16:21:16 <beelsebob> Heffalump: true
16:21:50 <conal> so i'm left wondering if RT has any meaning for Haskell.
16:21:59 <conal> or if it's just a cargo cult incantation.
16:22:02 <inimino> conal: can't you just use Integer if it bothers you?
16:22:12 <Heffalump> yes, it does have meaning, within the scope of a single implementation
16:22:17 <conal> inimino: separate topic.
16:22:20 <Heffalump> we've said that over and over..
16:22:22 <beelsebob> inimino: Integer is implementation dependant too anyway
16:22:27 <dolio> Heffalump: Do you remember what's wrong with logict and Either? I can't find anywhere in the code that actually uses it.
16:22:33 <inimino> I don't really understand why Int being machine-specific is even an issue
16:22:39 <Heffalump> dolio: I've got the build logs, one sec
16:22:51 <conal> Heffalump: *every* language has a single meaning within the scope of a single implementation
16:22:55 <centrinia> Couldn't GHC have a pragma that forces the Int type to have exactly 32 bits?
16:22:56 <conal> Heffalump: so what?
16:23:01 <beelsebob> inimino: as an example, you can expect to write the value to a file, read it back in, and get the same value
16:23:02 <Heffalump> conal: yes, and RT applies in Haskell, and doesn't in C..
16:23:04 <inimino> beelsebob: you mean beyond memory constraints?
16:23:05 <_roconnor> Int32 ?
16:23:10 <beelsebob> that isn't true if the reading and writing happens on different machines
16:23:24 <centrinia> Yes.
16:23:26 <Heffalump> dolio: oh, doh. Sorry, I off-by-oned lining up the problems and the packages.
16:23:27 <conal> Heffalump: okay. i see.
16:23:38 <centrinia> type Int = Int32
16:23:41 <Heffalump> dolio: logict's problem is instance Applicative Identity
16:23:44 <beelsebob> (isn't necessarily true)
16:23:48 <conal> so essentially, there are many Haksell languages.  each one satisfies RT
16:23:53 <Heffalump> which is in logict and now in transformers too
16:23:58 <inimino> beelsebob: read and write it how?  Not using show and read, I presume?
16:24:01 <conal> but the collection of Haskell languages known as "Haskell" doesn't.
16:24:08 <dolio> Oh, okay. That makes more sense.
16:24:14 <beelsebob> inimino: no, writing the binary value, not a string representation of it
16:24:21 <Heffalump> dolio: sorry about the confusion
16:24:26 <dolio> No problem.
16:24:26 <mauke> what does the report guarantee about Float?
16:24:43 <Heffalump> mauke: not enough
16:25:04 <mauke> what about 'even (minBound :: Int)'?
16:25:28 <Heffalump> well, RT has other limitations, anyway. Your program can fail to execute due to external limitations (e.g. lack of memory) and RT doesn't extend to preserving that failure or lack thereof.
16:26:04 <beelsebob> mauke: yeh, nice point
16:26:09 <Heffalump> it's good to be explicit about the bounds occasionally but whatever you do there will be some such limitations.
16:26:39 <inimino> beelsebob: well, I'm ok with that, anything that gives access to binary representations directly is going to be implementation specific, but you could have a well-defined semantics without going near that
16:26:45 <mmorrow> dons: just uploaded a new version that works for ByteString, and has a `showHNodes' function that takes a config
16:27:02 <beelsebob> inimino: but the point is that that binary representaiton is the "value
16:27:03 <beelsebob> "
16:27:11 <Heffalump> dolio: the annoying thing is that I'm not sure how you can be compatible with both old mtl and (proposed) new mtl without CPP.
16:27:13 <beelsebob> Haskell defines it as whatever the implementation does
16:27:18 <kadaver> how trixy would it be to write a wireless card driver for Ubuntu in haskell?
16:27:21 <beelsebob> and most implementations do... the binary value
16:27:37 <Heffalump> kadaver: take a look at the FFI
16:27:41 <dolio> Heffalump: I'll just change the Applicative instance for Logic to be more manual.
16:27:43 <beelsebob> you *could* have a well defined semantics
16:27:44 <conal> mauke: nice.  simpler than my example.
16:27:45 <beelsebob> but you don't
16:28:22 <conal> mauke: all haskells implemented *so far* might agree on the meaning, but other haskells needn't.
16:28:26 <roconnor> > maxbound :: Int32
16:28:27 <lambdabot>   Not in scope: `maxbound'
16:28:33 <roconnor> > maxBound :: Int32
16:28:34 <lambdabot>   2147483647
16:28:51 <kadaver> Heffalump: well would it be wrothit or would I just be wrapping C-calls in haskell and end up with the same amount of code?
16:29:01 <Heffalump> the problem with "many different Haskells" (which is a nice way of characterising the issue, I think) is more than just Int.
16:29:16 <conal> Heffalump: i know.  i was starting with Int.
16:29:20 <ddarius> conal: If you use the "machine environment" semantics, you'd still get a single language that satisfied referential transparency since Haskell doesn't have any way of providing a different "machine environment" programmatically (currently).  If such a mechanism was provided, it could be done so in a way that still wouldn't violate referential transparency.
16:29:25 <Heffalump> Even if you standardised Int, if you allow implementations *anything* implementation-specific, you're lost.
16:29:44 <conal> ddarius: isn't RT vacuous then?
16:29:48 <Heffalump> i.e. not only does everything in the report need to be fully defined, but implementations have to be banned from adding anything not in the report.
16:29:52 <ddarius> conal: No.
16:29:58 <inimino> beelsebob: how would you write the binary value to a file?
16:30:16 <beelsebob> inimino: Data.Binary
16:30:17 <ddarius> conal: "machine environment" doesn't mean "any detail under the sun"
16:30:19 <Heffalump> of course it's not vacuous, it still applies inside the scope of a single program on a single implementation. How is that vacuous?
16:30:40 <Heffalump> (up to the limits of memory, cosmic rays, stack overflows, etc)
16:30:53 <beelsebob> or use ord
16:30:54 <conal> ddarius: i mean if the language cannot express a *value* of an int expression, then one cannot substitute such a value for the expression.
16:30:58 <beelsebob> or fromEnum
16:30:58 <inimino> beelsebob: ok
16:31:04 <Heffalump> at least for memory and cosmic rays, you do know that if two programs succeed they produce the same value
16:31:08 <conal> ddarius: that's why i wonder if RT has any meaning for Haskell
16:31:12 <vixey> > 1+1
16:31:14 <lambdabot>   2
16:31:27 <beelsebob> inimino: this is all somewhat irrelevant, mauke gave a much simpler example of how it breaks RT
16:31:32 <ddarius> conal: The value of an "int expression" would be a -function-.  Furthermore, it would be pretty constrained.
16:32:02 <conal> ddarius: and would that function be expressible more simply than the expression itself?
16:32:19 <conal> ddarius: i'm looking for a non-vacuous way to understand RT in the context of Haskell
16:32:54 <conal> ddarius: and one that doesn't apply equally well to C
16:32:58 <inimino> beelsebob: I don't think I understand how that breaks RT (if you mean even (minBound :: Int))
16:33:11 <Heffalump> cosmic-rays aside, you can substitute the RHS of a definition for the LHS of that definition from program A to program B, and they'll still produce the same result if they don't fail.
16:33:15 <RayNbow> :t forever $ test $ \x -> 1+1==2
16:33:16 <lambdabot> Not in scope: `test'
16:33:17 <beelsebob> inimino: depending on the machine's representation the minimum bound is different
16:33:17 <Heffalump> On the same implementation, that is.
16:33:20 <Heffalump> How is that vacuous?
16:33:23 <beelsebob> so you get a different value on different machines
16:33:28 <RayNbow> :t forever $ Test.QuickCheck.test $ \x -> 1+1==2
16:33:29 <lambdabot> Not in scope: `Test.QuickCheck.test'
16:33:44 <ddarius> If the bit width was all one had to worry about, the "machine environment" would be an Int >= 29, 1 + 1 would mean \bitWidth -> addMod (2^bitWidth) 1 1
16:33:59 <Heffalump> It's certainly not true in C because you can move things past side effects by doing so.
16:34:21 <beelsebob> inimino: I just designed a machine, it uses jam sandwiches to represent integers, but only has room for 4, the minBound of Int is 0 and the maxBound is 4
16:34:25 <roconnor> isn't it the case the (f ()) can dentote different values in different places, whereas in haskell (f ()) always denotes the same value everywhere?
16:34:28 <conal> Heffalump: i'm using a different definition of RT .  in which one substitutes *values*, not RHSs.
16:34:58 <inimino> beelsebob: sure, but what's that have to do with RT?
16:35:06 <Heffalump> conal: well, what's wrong with my one?
16:35:15 <Heffalump> (modulo several other flaws in applying it directly to Haskell)
16:35:19 <conal> Heffalump: not wrong, just different.
16:35:23 <beelsebob> inimino: do you think that my value "two jam sandwiches" means the same on an x86?
16:35:26 <inimino> beelsebob: I guess the issue here is that my definition of RT doesn't include more than one machine
16:35:29 <conal> Heffalump: and it leads to a different conclusion.
16:35:39 <beelsebob> inimino: but that's not *the* definition of RT
16:35:44 <Heffalump> so are you claiming it's vacuous?
16:35:49 <beelsebob> RT has nothing to do with machines at all
16:36:03 <conal> beelsebob: agreed!
16:36:08 <conal> beelsebob: nor about implementations.
16:36:11 <inimino> beelsebob: you seem to be saying that you can pull any bytes out of one machine, stick them into another, and get the same value, as a precondition for RT
16:36:21 <beelsebob> inimino: no
16:36:29 <pejo> Heffalump, I'm a bit late, but did you say that if f = e, and you find "e" somewhere in the program, you can put in "f" there instead?
16:36:34 <beelsebob> I'm suggesting that the definition of the semantics of an RT language should have nothing to do with bits and bytes
16:36:45 <beelsebob> and that that should merely be a detail of a correct implementaiton
16:36:49 <Heffalump> pejo: no, the other way round (otherwise you get infinite recursion problems)
16:37:11 <Heffalump> though that's still ok with my definition since I only went for partial equivalence
16:37:16 <inimino> beelsebob: ok, well then I think you're talking about the semantics of expressions, but maybe not about RT
16:37:25 <Heffalump> conal: your definition has to do with being able to move a value from one execution context to another, right?
16:37:38 <beelsebob> inimino: but the semantics of expressions has a lot to do with RT
16:37:39 <conal> Heffalump: not at all.
16:37:41 <kadaver> Heffalump: well would it be wrothit or would I just be wrapping C-calls in haskell and end up with the same amount of code?
16:37:44 <Heffalump> ok, what is it then?
16:37:46 <pejo> Heffalump, ah, sorry.
16:37:49 <dcoutts> TomMD: brilliant, thanks
16:37:49 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
16:37:50 <conal> Heffalump:  it has nothing to do with implementation at all.
16:37:56 <Heffalump> kadaver: no idea, I have no experience of writing drivers and very little of the FFI
16:38:08 <dcoutts> TomMD: don't worry about the serveTarball, it's not finished yet anyway
16:38:14 <conal> Heffalump: "An expression is said to be referentially transparent if it can be replaced with its value without changing the program"
16:38:18 <conal> (taken from wikipedia)
16:38:33 <Heffalump> ok, that's roughly what I meant above.
16:39:10 <conal> Heffalump: so, now apply that definition to 'even (maxBound :: Int)'
16:39:20 <roconnor> that seems like a pretty bad definition of RT
16:39:28 <beelsebob> roconnor: really?
16:39:29 <roconnor> or maybe I don't understand RT
16:39:34 <beelsebob> I thought that was *the* definition of RT
16:39:50 <Heffalump> Sure, RT applies within the scope of a single implementation on a single platform, so tell me what implementation and platform you'd like and I'll try to find out the value.
16:40:18 <conal> Heffalump: then you're not talking about Haskell.  you're talking about "each haskell".
16:40:21 <Heffalump> The fact that RT is limited doesn't make it vacuous.
16:40:23 <Heffalump> Yes, I know.
16:40:32 <Heffalump> Which is fine.
16:40:44 <conal> Heffalump: i'm suggesting that RT is either false or vacuous for Haskell.
16:40:45 <Heffalump> RT still means something, and is a stronger property than C gives you.
16:41:09 <inimino> conal: all you establish with even (minBound :: Int) is that some things are implementation defined
16:41:11 <conal> Heffalump: i'm suggesting that for Haskell, RT is not truer than for C
16:41:17 <Heffalump> Not at all, Haskell defines that RT must apply to each implementation separately. That's weaker than it applying across all haskell implementations, but it's still stronger than C.
16:41:31 <inimino> RT is still completely true, you just have a strange definition of it
16:41:32 <beelsebob> inimino: okay, I'm going to take the value of even (minBound :: Int)
16:41:35 <beelsebob> it's False
16:41:37 <conal> inimino: and that REST  is either false or vacuous for Haskell
16:41:40 <beelsebob> now replace it in the program
16:41:46 <conal> (REST == RT )
16:41:49 <beelsebob> and run the two on my jam sandwich machine
16:41:55 <beelsebob> the two give different results
16:41:56 <conal> (modul my emacs abbrevs)
16:42:19 <dolio> > even (minBound :: Int)
16:42:20 <inimino> beelsebob: you can't do that, you can only apply RT within a given environment
16:42:21 <lambdabot>   True
16:42:40 <roconnor> beelsebob: RT only applies to a single run of a single program.
16:42:40 <beelsebob> inimino: really?
16:42:47 <conal> inimino: RT is a semantic property, not an implementation property.
16:42:48 <beelsebob> roconnor: does it?
16:42:51 <roconnor> yes
16:42:55 <beelsebob> since when?
16:42:55 <conal> inimino: not an environment property.
16:43:03 <inimino> I would say it only applies to one run, yes
16:43:10 <beelsebob> last I checked, RT applied to the semantics of a language
16:43:14 <beelsebob> not to a run of a program
16:43:17 <ddarius> conal: And the semantics can be a function of implementation properties.
16:43:20 <conal> inimino: where did you get that notion?
16:43:29 <conal> ddarius: apparently, so!
16:43:37 <conal> ddarius: it's just that i prefer the other way around :)
16:43:42 <roconnor> beelsebob: I'd say an expression is RT if it denotes the same value for every occurance.
16:44:01 <roconnor> beelsebob: but that is just the definition that I've inferred.
16:44:02 <inimino> it's about the semantics of a language, but obviously once you have things that are implementation defined, things are going to change across implementations
16:44:06 <beelsebob> roconnor: well, it doesn't in the even (minBound :: Int) example
16:44:10 <conal> inimino: seriously, i'd like to know where you got the idea that RT has anything at all to do with a run.
16:44:23 <beelsebob> because the occurance on my jam sandwich machine is different than on PPC
16:44:26 <RayNbow> :t minBound
16:44:27 <lambdabot> forall a. (Bounded a) => a
16:44:36 <roconnor> beelsebob: sure it does (even (minBound :: Int) === even (minBound :: Int)) in every program
16:44:49 <roconnor> > (even (minBound :: Int) == even (minBound :: Int))
16:44:51 <lambdabot>   True
16:44:54 <roconnor> , (even (minBound :: Int) == even (minBound :: Int))
16:44:56 <Heffalump> conal: do you accept that if you want total equivalence, RT is completely impossible?
16:44:56 <lunabot>  True
16:45:04 <inimino> all that even (minBound :: Int) shows is that the language has some expressions that are implementation defined, which is obviously the case
16:45:09 <Heffalump> on any physical machine, that is
16:45:10 <beelsebob> roconnor: no, but the two expressions evaluated on different machines are different
16:45:23 <roconnor> beelsebob: ya, but that isn't want RT is about
16:45:33 <beelsebob> no, RT specifically doesn't say anything about machines
16:45:44 <ddarius> beelsebob: Currently there is no programmatic way provided by Haskell of evaluating an expression on two different machines.
16:45:47 <beelsebob> it specifically doesn't mention any constraints about "on a single machine"
16:45:50 <beelsebob> or "in a single run"
16:45:57 <inimino> conal: RT is about optimizations you can and can't do
16:46:00 <beelsebob> it applies everywhere, all the time, no matter what
16:46:05 <beelsebob> inimino: no, no it's not
16:46:13 <ddarius> beelsebob: However, even if we did add a 'migrate' primitive, there's no reason for 1 + 1 = migrate fooServere (1 + 1)
16:46:26 <inimino> beelsebob: in practice, it is
16:46:30 <Heffalump> beelsebob: ddarius's point is that the Haskell spec doesn't say anything about anything other than a single run of a single program on a single machine
16:46:34 <beelsebob> ddarius: who said anything about adding a migrate primitive
16:46:47 <beelsebob> Heffalump: sure, and that's exactly what conal is saying is bad
16:47:01 <roconnor> beelsebob: whatever property you are talking about, it isn't what I understand RT to mean.
16:47:01 <rovar> can Control.Concurrent.Chan be read from and written to simultaneously by multiple forkIO threads?
16:47:05 <beelsebob> conal would *like* the spec to say what the semantics of Ints is
16:47:15 <Heffalump> sure, but it's his (rather insulting) claims that RT is vacuous that are wrong
16:47:18 <beelsebob> roconnor: then go read the definition of RT
16:47:25 <beelsebob> Heffalump: why are they insulting?
16:47:33 <RayNbow> if on one machine minBound :: Int evaluated to a, and on another machine it evaluted to b... isn't that because the two minBounds were given different Ints?
16:47:35 <conal> Heffalump: where does the haskell spec differentiate between one run and two?
16:47:35 <beelsebob> and I don't think they are vacuous
16:47:35 <ddarius> beelsebob: If you want transparent migration, then I'm pretty sure the Report (perhaps softly) requires that the same expression mean the same thing within a single implementation (regardless of whether that implementation "distributes" it's computations).
16:47:43 <Heffalump> conal: it only defines what happens with main
16:48:01 <conal> Heffalump: *one* run of main vs two?
16:48:46 <conal> Heffalump: where does the spec specify what the meaning of main ?
16:48:51 <beelsebob> Heffalump: I think if you're insulted by the suggestion that Haskell may not be RT, then you need to take a step back from the language
16:48:51 <roconnor> beelsebob: where do you want me to look it up?
16:49:16 <Heffalump> beelsebob: the insulting bit was the reference to people who believe in RT just rationalizing their beliefs/it being a cargo cult
16:49:22 <dcoutts> TomMD: I've not received the hackage-server patch you sent
16:49:42 <bremner_> RT?
16:49:53 <conal> Heffalump: i do indeed wonder.  i'm looking for evidence to the contrary.
16:50:12 <Heffalump> conal: you seem to be ignoring me when I do provide such evidence.
16:50:14 <conal> i was very surprised to learn about the semantics ambiguity.
16:50:19 <RayNbow> is RT still a problem if we consider an expression like "minBound" to be a function?
16:50:31 <Heffalump> the beginning of the chapter on Modules (chapter 5) talks about main and defines a Haskell program.
16:50:42 <roconnor> RayNbow: there is no problem
16:50:47 <beelsebob> roconnor: well, wikipedia's reference list is a good start, it actually points at a nice paper discussing the different versions of definitions
16:51:02 <beelsebob> bremner_: referential transparency
16:51:03 <conal> Heffalump: what is that piece (chap 5) relevant to?
16:51:13 <RayNbow> roconnor: I was directing it at the people who think it is a problem :p
16:51:21 <roconnor> :)
16:51:22 <conal> Heffalump: what evidence?
16:51:30 <ehird> Is gtk2hs ever going to be on hackage?
16:51:32 <roconnor> RayNbow: they still think it is a problem
16:51:33 <Heffalump> well, the Wikipedia definition of RT you quoted earlier talks about "a program"
16:51:36 <Heffalump> so it seems quite relevant to that
16:51:52 <beelsebob> Heffalump: a program, but not a specific execution of it
16:51:59 <roconnor> RayNbow: there is no getting around that the minBound program produces different results on different platforms
16:51:59 <RayNbow> because if "minBound :: Int" gave different results on different machines... it's because minBound was given a different Int
16:52:01 <beelsebob> nor an environment in which it is run
16:52:01 <conal> Heffalump: i think you saw that i found it believable that *each* haskell is RT .  just not Haskell itself.
16:52:34 <roconnor> conal: what is your definition of RT?
16:52:43 <bremner_> beelsebob: Tx
16:53:06 <conal> roconnor: (again) "An expression is said to be referentially transparent if it can be replaced with its value without changing the program"
16:53:33 <roconnor> what does "its value" mean?
16:53:41 <conal> roconnor: by that definition (maybe not others) i'm saying that Haskell is either not RT or vacuously RT
16:53:42 <beelsebob> roconnor: that's kinda the point ;)
16:53:45 <conal> roconnor: exactly!
16:53:50 <vixey> does [1..] have a value
16:53:57 <roconnor> conal: I think you have a crappy definition
16:53:57 <beelsebob> conal: the thing is I'm not sure it's possible to write a "haskell program"
16:54:00 <roconnor> :)
16:54:07 <conal> roconnor: perhaps so.
16:54:24 <conal> beelsebob: say more
16:54:36 <inimino> conal: that definition defines RT expressions, not anything about languages
16:54:39 <conal> roconnor: i just went looking for a definition and that's the first one i came up with.
16:54:42 <Heffalump> also, absolute RT is unattainable, so you have to decide on reasonable limits otherwise the entire concept is vacuous.
16:54:42 <vixey> I wonder if we could recast some scott domain semantics into coherence spacesa
16:54:43 <ehird> I'd say minBound doesn't break rt.
16:54:52 <conal> inimino: what's the difference?
16:54:57 <inimino> so by that definition, no language is RT, vacuously or otherwise
16:55:02 <cads> does haskell have a library for vector spaces and matrices/affine spaces?
16:55:07 <conal> inimino: a language is a set of expressions, plus a semantics, isn't it?
16:55:12 <inimino> conal: what's the difference between languages and expressions?
16:55:12 <beelsebob> cads: yes – vector-space
16:55:23 <Heffalump> inimino: I bet some non-Turing complete ones could be, actually :-)
16:55:24 <inimino> conal: yes, you can define it that way, sure
16:55:57 <inimino> Heffalump: hehe, ok ;-)
16:56:01 <beelsebob> conal: You can write a program that is valid as a program in many different Haskells, but not a program that is itself in Haskell
16:56:03 <defun> hi, what is the distinguishment between monoids and monads? I know what monads are, though I'm fuzzy on monoids.
16:56:06 <beelsebob> the language doesn't exist
16:56:20 <beelsebob> Haskell defines a set of languages, not a language
16:56:29 <Heffalump> well, it doesn't exist if you insist on "a language" being some completely defined entity
16:56:41 <conal> beelsebob: do you have an example in mind?
16:56:41 <beelsebob> I do
16:56:50 <conal> beelsebob: please tell!
16:56:51 <Heffalump> rather than a partial definition of something, which is what most things that are commonly called "languages" actually are
16:57:04 <ddarius> defun: Then learn what monoids are and the difference will be obvious.
16:57:13 <RayNbow> defun: http://en.wiktionary.org/wiki/monoid <-- here is a concise definition
16:57:19 <beelsebob> Heffalump: doesn't mean we can't do better ;)
16:57:20 <Heffalump> any in that vein, I find it completely reasonable that Haskell is considered RT in the sense that all its implementations must be RT.
16:57:26 <Heffalump> s/any/and/
16:57:39 <defun> thanks.
16:57:57 <inimino> conal: so I think you need a better definition of RT as we seem to disagree about what it is
16:58:01 <beelsebob> conal: I'm not sure that I can, because I'm arguing for the non-existance of something, not the existance
16:58:01 <Heffalump> I would dispute the claim that it's uniformly "better" to completely define a language.
16:58:19 <RayNbow> @check \x -> Sum x `mappend` Sum 0 == Sum x
16:58:20 <lambdabot>   "OK, passed 500 tests."
16:58:28 <Heffalump> it's better for some things, and worse for others
16:58:30 <RayNbow> @check \x -> Sum 0 `mappend` Sum x == Sum x
16:58:31 <lambdabot>   "OK, passed 500 tests."
16:58:49 <beelsebob> @check \x -> x `mappend` x == x
16:58:49 <conal> inimino: would you like me to apply that rule in general when we disagree?
16:58:50 <lambdabot>   "OK, passed 500 tests."
16:58:59 <beelsebob> RayNbow: monoid + quickcheck == fail
16:59:03 <beelsebob> because it chooses the () monoid
16:59:11 <Heffalump> RT isn't an end in itself, but a useful aid to program comprehension and to program optimisers
16:59:13 <centrinia> @check \x y -> Sum x `mappend` Sum y == Sum (x+y)
16:59:14 <lambdabot>   "OK, passed 500 tests."
16:59:18 <ddarius> :t Sum
16:59:19 <lambdabot> forall a. a -> Sum a
16:59:25 <conal> inimino: i think i see your point.  so how about saying that an RT language is one in which all expressions are RT ?
16:59:26 <RayNbow> beelsebob: not only monoids
16:59:35 <ddarius> beelsebob: Not for expressions involving 0.
16:59:39 <conal> inimino: using the expression RT definition i gave?
16:59:41 <beelsebob> ddarius: oh, duh
16:59:48 <RayNbow> I once tried to test a simple reverse property on lists
16:59:51 <dcoutts> ehird: yes, eventually
16:59:55 <RayNbow> even a property I thought that should be false
16:59:57 <ddarius> > undefined `mappend` Sum 0
16:59:59 <lambdabot>   Sum {getSum = * Exception: Prelude.undefined
17:00:06 <ddarius> > Sum 0 `mappend` undefined
17:00:08 <lambdabot>   Sum {getSum = * Exception: Prelude.undefined
17:00:14 <RayNbow> but then I found out QC was generating [()] lists :p
17:00:22 <roconnor> conal: given your definition of RT, isn't it pretty clear that Haskell is RT while C isn't?
17:00:23 <ddarius> Failure of unit law.
17:00:40 * Heffalump bedificates
17:00:53 <Heffalump> short day tomorrow :-(
17:00:55 <RayNbow> @check \x -> x == () && () == x
17:00:56 <lambdabot>   "OK, passed 500 tests."
17:00:57 <conal> Heffalump: "any in that vein, I find it completely reasonable that Haskell is considered RT in the sense that all its implementations must be RT."  i think you're saying what i was saying: Haskell is not RT .  Each haskell is.
17:01:13 <beelsebob> @check \x y -> x == y
17:01:14 <lambdabot>   "OK, passed 500 tests."
17:01:18 <inimino> conal: that would be OK, but then we still have to define whether that has to apply across different machines, and so on
17:01:30 <beelsebob> conal: all values are equal, so it's okay :P
17:01:36 <conal> inimino: machines have nothing to do with RT
17:01:39 <beelsebob> (at least acording to quickcheck)
17:01:45 <Heffalump> conal: we are agreed on the underlying meaning of what we are each saying, but I disagree with your choice of words to summarise that position.
17:01:51 <conal> beelsebob: yes.  that's one example of what i meant by vacuous.
17:02:01 <Heffalump> in my opinion, Haskell is RT because it imposes RT on each implementation.
17:02:10 <beelsebob> yep
17:02:18 <dcoutts> Heffalump, beelsebob, conal: it seems clear that one can say that a partially specified language can be RT.
17:02:28 <roconnor> int foo (int x) { printf("Hello"); return x }
17:02:32 <dcoutts> If one is working with the context that the semantics are partially implementation defined then RT in that context means per-implementation
17:02:34 <conal> dcoutts: clear, how?
17:02:34 <beelsebob> dcoutts: really?
17:02:38 <Heffalump> dcoutts: well, it's not clear to conal. I think it is :-)
17:02:55 <conal> dcoutts: it can mean that.  i prefer a stronger notion of RT .  that's all.
17:02:56 <Cale> RT?
17:02:58 <inimino> conal: well actually it does, because we have to define program
17:03:00 <Cale> Realtime?
17:03:06 <Heffalump> If someone defines a language with a stronger guarantee, they can use a stronger form of words to indicate that.
17:03:09 <conal> referential transparency
17:03:11 <inimino> referentially transparent
17:03:13 <roconnor> if you replace (foo(5)) with 5 in C, the program would (counterfactually) produce a different result when executed.
17:03:14 <Heffalump> "This language is completely defined and also RT" would do the job nicely.
17:03:14 <Cale> Ah, okay
17:03:15 <beelsebob> dcoutts: so you're saying that RT in the context of a set of languages means "all lanugages in the set are RT, but the union may not be"?
17:03:16 <Cale> Yes
17:03:24 <roconnor> this can never happen in Haskell
17:03:28 <guenni> mmorrow: boah, I made it into the paper!
17:03:29 <Heffalump> beelsebob: the union isn't even defined.
17:03:29 <RayNbow> roconnor: int bottom() {for(;;);} // foo(bottom) == ? :p
17:03:37 <dcoutts> conal: but that's only because you're working in the context of a language completely specified denotational semantics
17:03:45 * RayNbow notices he misses a return statement
17:03:49 <conal> Heffalump: the union is Haskell itself.
17:03:58 * inimino starts a flame war about whether Haskell is "hard" or "soft" RT
17:04:02 <Cale> How is Haskell's referential transparency at issue?
17:04:18 <roconnor> RayNbow: some functions denote values that have no normal form.
17:04:18 <Heffalump> Cale: because it doesn't apply across different implementations
17:04:18 <conal> dcoutts: or the other way around.
17:04:31 <Heffalump> e.g. even (maxBound :: Int) is not guaranteed to be the same everywhere
17:04:31 <roconnor> RayNbow: same in haskell
17:04:33 <Cale> Heffalump: Are you referring to the possible existence of unsafePerformIO?
17:04:36 <Heffalump> Cale: no
17:04:40 <dcoutts> conal: if we've got a family of languages, each with sensible semantics (but not all the same) then each of them can be RT individually
17:04:51 <wli> It's probably closer to full abstraction -related issues.
17:04:52 <Cale> Then, I don't understand what the problem is, exactly.
17:05:03 <conal> dcoutts: yes.  that's what i call "weak RT"
17:05:09 <inimino> conal is arguing that minBound violates RT since if you replace it with it's value on one implementation, and then run that program on another, you get a different result
17:05:15 <conal> dcoutts: and what Heffalump calls "RT" , i think
17:05:16 <Cale> Uh, that's odd.
17:05:17 <Heffalump> Cale: conal claims that RT means that even (maxBound :: Int) should have a single defined value that applies everywhere.
17:05:22 <Cale> ?
17:05:24 <Cale> Why?
17:05:27 <monochrom> haskell 98 is soft lazy-time. ghc haskell is hard lazy-time.
17:05:33 <Heffalump> because he likes taking absolute positions? :-)
17:05:39 <wli> Okay, this does not sound like a full abstraction -related issue.
17:05:44 <conal> inimino: that's the "false" part. the "or vacuous" part is that one cannot substitute the value.
17:05:52 <monochrom> Oh, RT is not real-time? Heh.
17:06:00 <Heffalump> the argument has degenerated into one about how we define terms that aren't really completely defined in the world, so I don't think it's really getting anywhere
17:06:05 <Cale> Isn't minBound for Int something which is simply defined in the Prelude.
17:06:11 <beelsebob> Cale: because I can't replace even (minBound :: Int) with its value and expect it to still be equal to even (minBound :: Int) always
17:06:12 <Cale> So it just depends on which Prelude you're using.
17:06:16 <dcoutts> conal: but these kinds of "weakness" are not special to the RT property, it applies too all these semantic properties because we're talking about a parametrised family of languages
17:06:21 <conal> Heffalump: i suggested a particular definition of RT .
17:06:30 <conal> and my conclusions follow from that definition.
17:06:33 <Cale> If you use the same code it will always have the same value, but of course that includes the Prelude.
17:06:39 <roconnor> I could see Conal's property being useful, but it isn't what we mean by RT when we say Haskell is RT.
17:06:45 <Heffalump> conal: you pasted the Wikipedia definition and then made some extra claims about the context in which that applied.
17:06:48 <conal> dcoutts: agreed.  (minus the "but")
17:06:52 <dcoutts> conal: RT only makes sense in the context of a semantics, either operational or denotational
17:06:58 <conal> Heffalump: what claims?
17:07:03 <conal> dcoutts: yes
17:07:21 <inimino> conal: I think the problem is that that definition varies from what most of the rest of the programming language community means by the term
17:07:29 <Heffalump> that an expression should have a single defined value across all implementations of Haskell, for example.
17:07:30 <Cale> By a similar argument, I could claim that any Haskell module which imports another module isn't *really* referentially transparent because I could write a different version of the imported module and the code's meaning would change.
17:07:34 <Cale> That's... not sensible.
17:07:39 <conal> inimino: maybe so.  i'm open to other definitions.  do you have one?
17:07:41 <dcoutts> conal: hence some people were talking about "runs of programs" because they think about operational semantics and you say it's got nothing to do with machines because you're thinking of a single denotational semantics
17:07:56 <ddarius> We can turn a parameterized family of semantics, into a single semantics that parameterizes its semantic domain.
17:07:57 <David9> hello
17:07:59 <Heffalump> Cale: well, not really, because the Haskell standard does define a program as the collection of all the modules.
17:08:07 <inimino> Cale: that's a good point about the Prelude
17:08:09 <conal> Heffalump: "that an expression should have a.. " can you find a quote of mine ?
17:08:12 <Cale> Heffalump: Including the Prelude?
17:08:21 <conal> Heffalump: doesn't sound like something i'd say.
17:08:24 <beelsebob> also, that's just a really good argument for a haskell module should be a function from imports to set of definitions
17:08:29 <Cale> Heffalump: minBound :: Int is something defined by an instance in the Prelude.
17:08:36 <Heffalump> conal: no, I was summarising your position.
17:08:45 <Cale> David9: hello!
17:08:55 <conal> Heffalump: then please try again.  you missed.
17:09:01 <conal> dcoutts: operational semantics has to do with runs on machines?
17:09:18 <Heffalump> conal: well, if you don't think that, then why do you keep asking about even (maxBound :: Int)?
17:09:39 <Philippa_> conal: that's certainly the underlying intuition
17:09:47 <Heffalump> Cale: the standard does actually include it, good point.
17:09:52 <Cale> conal: I don't get what you're trying to say though. Isn't it the case that minBound :: Int is defined in an instance in the Prelude module?
17:09:58 <inimino> conal: I'm not sure I want to put forward a definition, but I have a vague fuzzy notion and your definition doesn't capture it
17:10:03 <conal> Heffalump: might be more than one reason.  if you point out one i might be able to answer.
17:10:11 <Heffalump> anyway, that's a bit of a distraction, because we can replace the example with something that overflows.
17:10:26 <conal> inimino: okay.
17:10:46 <conal> inimino: and yet you're somehow confident that haskell is RT ?
17:10:48 <wli> I would say that lacking full abstraction violates RT in that values may be well-defined (in terms of denotations) while computations fail to terminate.
17:10:54 <Cale> conal: Isn't it the case that by the same argument, one could complain that map isn't referentially transparent because by replacing the Prelude with a different version, we could alter its meaning?
17:11:22 <beelsebob> Cale: as Heffalumppoints out, we can easily replace the minBound example with something that overflows
17:11:28 <beelsebob> and avoid the prelude alltogether
17:11:29 <Heffalump> conal: about half an hour ago, you said you wanted to apply that definition (the Wikipedia one) to even (maxBound :: Int)
17:11:44 <Cale> beelsebob: hm?
17:11:58 <inimino> conal: my vague fuzzy notion seems to me closer to the general meaning of RT in the wider community the definition you gave, and I'm pretty confident Haskell meets it, so yes
17:11:58 <Heffalump> Cale: 2^28 + 2^28
17:11:59 <ddarius> Indeed, expressions involving 'map' would (typically) be represented in the semantics in exactly the same way as the "implementation details"
17:12:01 <Cale> I don't think the meaning of values has to be consistent across redefinition in order for RT to hold.
17:12:08 <conal> Heffalump: yes.  to make the discussion more concrete.
17:12:25 <dcoutts> Cale: yes, that's true. The semantics of modules is really via fuctors
17:12:33 <roconnor> > 2^28 + 2^28
17:12:34 <lambdabot>   536870912
17:12:37 <roconnor> , 2^28 + 2^28
17:12:38 <lunabot>  536870912
17:12:39 <beelsebob> Cale: what's the value of 2,000,000,000 + 2,000,000,000?
17:12:50 <Cale> beelsebob: Depends on the definition of Int.
17:12:54 <Cale> Which is in the Prelude.
17:12:56 <wli> dcoutts: The semantics of modules is via functors? How?
17:13:01 <Cale> If you replace the module then of course you can replace the meaning of the program.
17:13:06 <beelsebob> Cale: ohhhhh..... good point
17:13:19 <dcoutts> wli: parametrise each module by the interface of its imports
17:13:21 <beelsebob> interesting argument
17:13:22 <roconnor> Cale: are you saying that each platform has a "different" Prelude?
17:13:26 <Heffalump> conal: ok, so do you think that for Haskell to be RT, even (maxBound :: Int) must have a single value across all implementations of Haskell, or not?
17:13:26 <Cale> yes.
17:13:48 <Cale> If you're compiling for 64 bits, you're using a different Prelude than if you're compiling for 32 bits.
17:13:54 <Cale> Because the Int bounds change.
17:14:00 * wli is clueless about modules' formal semantics.
17:14:08 <ehird> Yi has a lot of frontends but only gtk and vty work properly, right?
17:14:11 <beelsebob> so to satisfy Conal, what we should do is define a "standard" prelude
17:14:14 <Cale> So Int's definition is different.
17:14:18 <wli> dcoutts: Okay, what's the next step?
17:14:19 <beelsebob> which is the same on all platforms
17:14:23 <beelsebob> including the definition of Int
17:14:24 <Cale> and so you're no longer comparing the same thing at all.
17:14:35 <conal> Heffalump: i'm suggesting looking at the definition i quoted with that example in mind.  when i look, i get that Haskell is either (a) not RT or (b) vacuously RT.   i was hoping others would look and see what they concluded as well.
17:14:48 <conal> beelsebob: yes.  *semantically*  standard.
17:14:57 <Heffalump> Right, so when you look, you add things to the definition that many other readers don't see in it.
17:15:01 <beelsebob> conal: so the language is RT
17:15:16 <gwern> ehird: I think the pango frontend by now probably works as well as gtk
17:15:17 <conal> Heffalump: demonstrate, please.
17:15:20 <beelsebob> but the language + an arbitrary library selection is not
17:15:27 <gwern> and the cocoa frontend keeps drifting in and out of workingness
17:15:29 <dcoutts> wli: the language really only defines them as namespace things, but we use them by replacement etc, eg cabal composes packages (ie swizzling imports) on the end user machine, namespace semantics does not describe that well, but composing functors does.
17:15:29 <lanaer> trying to run bootstrap.sh for the cabal-installer. HTTP-4000.0.4 uses monstrous amounts of memory (it had reached 1.7GB before I killed it) without seeming to make any progress. this in on PPC OS X 10.5 w/ GHC 6.10.1
17:15:31 <Heffalump> well, plenty of other people in this discussion think Haskell is RT ...
17:15:33 <ehird> gwern: pango? Howzat work? Draws directly? Why on earth?
17:15:44 <dcoutts> wli: the comparison is with ML functors, it's their module system
17:15:48 <gwern> ehird: better text performance or control, or something
17:15:54 <ehird> gwern: Last time I tried Cocoa, it didn't display any newlines.
17:15:59 <ehird> If that's fixed, hooray :-P
17:15:59 <conal> beelsebob: yeah.  i meant Haskell+Prelude.
17:16:01 <gwern> probably handles unicode better...
17:16:04 <Heffalump> btw, even the examples with literals do depend on the Prelude because of the fromInteger translation.
17:16:13 <wli> dcoutts: Yeah, ML functors are what I'm most interested in.
17:16:28 <beelsebob> conal: then I think that the argument that "you aren't using the same language" is very very strong
17:16:33 <beelsebob> you genuinely have different files
17:16:43 <wli> dcoutts: Are they in turn modelled via categorical functors or what happens?
17:16:43 <beelsebob> and genuinely are running a different program
17:16:53 <conal> Heffalump: i already knew people think Haskell is RT.  i was exploring whether what grounds that belief is held.
17:17:00 <dcoutts> wli: I'm a bit fuzzy on that tbh
17:17:27 <gwern> ehird: although you should try cocoa
17:17:28 <conal> Heffalump: hence my wonderings that you took offense to.
17:17:37 <gwern> I don't think we know whether the pointed-set transition broke it or not
17:17:42 * SimonRC goes for pizza
17:17:47 <ehird> gwern: I last tried it on darcs a few months ago.
17:17:52 <ehird> Like, um.
17:17:53 <ehird> Last month?
17:18:15 <dcoutts> conal: I think if we accept that the semantics has a number of parameters (eg Int size) then for a fixed set of the parameters I'd say yes it's RT
17:18:16 <roconnor> When people say "Haskell is RT" they mean that Haskell has a certain property that C or ML do not have.  Maybe RT is a bad name for this property, but a rose by any other name.
17:18:18 <wli> conal: I think the holes may be full abstraction and various low-level "escape hatches" like unsafePerformIO and FFI calls.
17:18:19 * gwern shrugs. I don't follow the ui changes very closely
17:18:31 <conal> dcoutts: me too.
17:18:49 <ehird> gwern: well, I'll try Cocoa, but, ever tried to compile HOC? (the cocoa bridge)
17:18:53 <conal> wli: you mean, beside the prelude?
17:19:00 <ehird> if you haven't, try it some time, unless you value having a working brain
17:19:02 <gwern> ehird: no. never used a mac
17:19:08 <beelsebob> ehird: oh, point – I was told you had succeeded
17:19:13 <beelsebob> I wanted to pick your brain about how
17:19:22 <ehird> beelsebob: Hey, I'm famous. :-)
17:19:25 <dcoutts> conal: if you let the parameters range freely then it's not really fair to ask for all these semantic properties to hold (though some may not be affected by any parameter)
17:19:30 <ehird> beelsebob: I'll tell you in /msg, if you want. It's rather complex.
17:19:32 <gwern> and the more I read about all the crazy stuff you mac users have to do for basic programming, the more I think I'll stay away from apple's expensive walled gardens...
17:19:38 <beelsebob> ehird: that would be *very* useful
17:19:41 <wli> conal: There could be some holes in RT roaming around the Prelude I'm not aware of.
17:19:46 <ehird> beelsebob: Aight then.
17:19:51 <conal> dcoutts: that's what i meant "each haskell" is RT, while Haskell isn't.
17:19:54 <dcoutts> conal: hence I'd say calling Haskell "weak rt" isn't really fair or useful
17:19:59 <Heffalump> dcoutts: btw, I've added a 'depends' command to cabal-install that just follows the dependencies of a package, ignoring version numbers. It can do it in reverse or forwards, and (optionally) recursively. Is that something that would be useful to have in cabal-install?
17:20:16 <conal> dcoutts: i didn't mean "weak" is a negative way.
17:20:20 <dcoutts> Heffalump: you mean prints them out?
17:20:24 <conal> dcoutts: i just mean relative to a stronger notion.
17:20:25 <Heffalump> yes, sorry
17:20:43 <conal> dcoutts: and i think it's an accurate statement.
17:20:44 <dcoutts> Heffalump: we could extend the cabal info with that feature, it already prints dependencies, but not reverse ones
17:20:46 <Heffalump> I found it useful for figuring out which packages to regression test mtl against.
17:20:48 <conal> dcoutts: not a criticism.
17:20:58 <mib_4r127trn> http://www.meine-nackte-ex.net/?uid=89015
17:21:14 <mib_4r127trn> see the new cell
17:21:15 <mib_4r127trn> http://www.meine-nackte-ex.net/?uid=89015
17:21:25 <ehird> mib_4r127trn: go away
17:21:38 <mib_4r127trn> why
17:21:38 --- mode: ChanServ set +o Heffalump
17:21:42 <ehird> because you are a spammer.
17:21:47 <Alpounet> Has anyone read "The Society of Mind", by Minsky ?
17:21:48 <mib_4r127trn> no
17:21:52 <Heffalump> doh
17:21:52 <ehird> hahahaha
17:21:54 <ehird> XD
17:21:58 <pejo> Heh
17:22:04 <RayNbow> Heffalump: good job :p
17:22:06 <mib_4r127trn> just look at my cellphone from apple http://www.meine-nackte-ex.net/?uid=89015
17:22:21 --- mode: ChanServ set +o Heffalump
17:22:32 * arjanb thinks Heffalump needs sleep
17:22:37 <conal> dcoutts: were you taking "weak rt" as a criticism?
17:22:38 <Heffalump> yes :-)
17:23:03 <dcoutts> conal: I just don't see that it's a useful description
17:23:14 <roconnor> conal: is ML 'weak rt' ?
17:23:14 <Heffalump> conal: it certainly sounds like a criticism when previously you were arguing that RT means what would now be termed "strong RT".
17:23:23 <conal> dcoutts: do you see it now -- as a contrast for the stronger notion i described?
17:23:37 <mib_4r127trn> porn http://www.meine-nackte-ex.net/?uid=89015
17:23:38 <conal> Heffalump: what argument?  i shared a definition?
17:23:40 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:42 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex.net/?uid=89015	porn http://www.meine-nackte-ex
17:23:43 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015v
17:23:43 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:44 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:45 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:46 --- mode: ChanServ set +o dcoutts
17:23:46 <conal> Heffalump: from wikipedia
17:23:47 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:49 <mib_4r127trn> 	porn http://www.meine-nackte-ex.net/?uid=89015
17:23:57 <RayNbow> lol, Excess Flood
17:24:09 <RayNbow> haven't seen that one in a while
17:24:13 <dcoutts> conal: anything like that becomes weak if you add more variants of the language and then still try to talk about properties of the whole family
17:24:41 * monochrom is tempted to just ban mibbit
17:24:41 <Heffalump> conal: you did far more than just share a definition, you then applied a line of reasoning to interpreting that definition that was certainly not universally accepted.
17:24:50 <conal> dcoutts: now i realize that when Heffalump says Haskell is RT he really mean *each* haskell is RT.
17:24:52 <Heffalump> what is mibbit?
17:24:57 <Heffalump> No, I don't.
17:24:58 <conal> dcoutts: i didn't know that before.
17:24:59 <Heffalump> I mean that Haskell is RT.
17:25:06 <RayNbow> Heffalump: mibbit = webbased IRC
17:25:07 <luite> does anyone know how to manually set the range of an axis in Charts-0.10.x? all examples use automatically scaled axes
17:25:23 <conal> Heffalump: show me.  i keep wondering how much you're imaging about what i mean vs what i really said & meant.
17:25:25 <dcoutts> conal: it's just another way of saying there isn't a single denotational semantics
17:25:32 <conal> s/imaging/imagining/
17:25:51 <conal> dcoutts: yeah.  which was news to me.  i only learned recently.
17:25:54 <wli> conal: I would think full abstraction would help.
17:26:20 <conal> wli: i think full abstraction is a separate issue from denotational ambiguity.
17:26:31 <rovar> think it would be possible to make Handle an instance of Ord?
17:26:55 <wli> conal: Denotational ambiguity resulting from machine dependence of certain data types?
17:27:11 <conal> wli: machine dependence etc.
17:27:26 <conal> wli: partial specification.
17:28:05 <wli> I'd just envision it as a specification parametrized by machine characteristics.
17:28:41 <dcoutts> conal: a more interesting question I think is if we can precisely capture the family of languages using a number of parameters
17:28:49 <Heffalump> conal: for example your insistence that "Haskell is RT" must mean something stronger than what you call "each Haskell is RT".
17:29:02 <wli> (have fun with 4GB+ of heap on 32-bit BTW)
17:29:15 <Heffalump> dcoutts: some of those parameters would be higher-order in the case of the Haskell standard
17:29:19 <dcoutts> conal: eg we know the size of Int is one such parameter, can we capture the full set
17:29:32 <conal> Heffalump: give me a quote about my "insistence"?  otherwise i won't know what you mean.
17:29:40 <dcoutts> Heffalump: for a fixed version of the language
17:30:11 <Heffalump> >> [00:24] <conal> dcoutts: now i realize that when
17:30:11 <Heffalump> >> Heffalump says Haskell is RT  he really mean *each*
17:30:11 <Heffalump> >> haskell is RT.
17:30:29 <conal> yes.  isn't that what you really meant?
17:31:06 <monochrom> Interesting. Quantifier placement.
17:31:09 <Heffalump> only in your definition of RT.
17:31:18 <conal> Heffalump: and now you're imagining that i insist everyone use "RT" to mean what i mean?
17:31:37 <Cale> Int is something defined by the Prelude, use a different Prelude, and it's no surprise that you might get a different Int.
17:31:41 <conal> Heffalump: i realize that you meant something specific.  i didn't realize it earlier.  so what?
17:32:00 <Heffalump> dcoutts: I mean that the behaviour of Int on overflow isn't defined either (I think) so you need something higher-order to define it.
17:32:06 <Heffalump> it's not just about the bit-width
17:32:06 <dcoutts> Cale: but the Prelude is special in being defined by the language spec
17:32:13 <conal> Heffalump: i know you got insulted early on.  i really didn't mean anything personal.
17:32:13 <Cale> Not entirely.
17:32:29 <Cale> The definition of Int is one of the things which it leaves to implementations.
17:32:38 <dcoutts> Heffalump: ah, the overflow isn't defined, ok I'd forgotten that
17:32:53 <dcoutts> Cale: but it partially specifies it
17:32:57 <dcoutts> Cale: eg that 1+1=2
17:32:59 <guenni> is there a pre-defined function that turns [1, 1, 1, 2, 2, 3, 4, 4, 5] into [[1, 1, 1], [2, 2], [3], [4, 4] [5]]?
17:33:06 <Cale> group
17:33:14 <Cale> > group [1, 1, 1, 2, 2, 3, 4, 4, 5]
17:33:16 <lambdabot>   [[1,1,1],[2,2],[3],[4,4],[5]]
17:33:34 <guenni> Cale: thx
17:33:36 <dcoutts> Cale: so it's not just a random import where you have to go and look at the definition of that module to see what it means
17:33:40 <Heffalump> conal: it feels like you are repeatedly using your own definition of RT to describe other people's positions, rather than being willing to qualify your statements to make it clear that you are taking a position that is different. I certainly didn't mean that each Haskell is RT by my own definition of RT, so what you said seems inaccurate to me, for example.
17:33:56 <Cale> dcoutts: In principle that's all it is.
17:34:09 <Heffalump> anyway, I really am going to bed. I didn't exactly feel personally insulted, just that you were using rather pejorative language in describing your own position.
17:34:12 <dcoutts> Cale: but then there's no basis
17:34:14 <conal> Heffalump: what did i say that you're objecting to?
17:34:21 <Cale> dcoutts: But in practice, the implementations implement bits of the Prelude with lower-level hackery.
17:34:24 <conal> Heffalump: was it the word "really"?
17:34:34 <dcoutts> Cale: well exactly
17:34:52 <Heffalump> that partly, but the fact that you said that I mean that each Haskell is RT. I only meant that if RT goes by your definition, not mine.
17:34:58 <Cale> But in principle, that hackery could be specified directly in Haskell.
17:35:00 <conal> Heffalump: and yeah, maybe you'd better get some sleep.
17:35:07 <Cale> (at least, I/O aside)
17:35:07 <dcoutts> Cale: and those lower bits are certainly not defined by the language, hence it has to (partially) define the Prelude
17:35:26 <Cale> Int is not one of the things which absolutely must be lower-level.
17:35:36 <conal> Heffalump: because your definition of RT *is* that each haskell is RT, right?
17:35:46 <Cale> In principle, it could be implemented with a normal algebraic datatype.
17:35:51 <dcoutts> conal: that it applies point-wise, yes
17:35:59 <conal> Heffalump: where the second "RT" is the wikipedia one.
17:36:00 <luite> hm, no-one used Chart (haskellcharts by tim docker) here?
17:36:36 <dcoutts> conal: again, it depends on the context. If you use different contexts then you get different answers.
17:36:51 <Heffalump> now we get back to you applying your own spin to the wikipedia definition (IMO) :-) I've really gone after I hit enter!
17:37:33 <conal> Heffalump: i'm not used to RT as applying to different language implementations.  but now i know what you mean.
17:38:03 <conal> Heffalump: i never did get to hear any substance behind that "spin" claim.  oh well.
17:38:30 <Cale> If you replaced the Prelude with a module wherein each definition was actually equal to the definition in the Prelude you were replacing, then you could apply RT in that way.
17:38:40 <samalog> Hi everyone. Is it possible to compile haskell into C, effectively using the haskell compiler as a C code generator? I see GHC has a compile "via-C" option, but it appears to generate .o files just the same.
17:38:54 <Cale> But if you want to change the meaning of some of the definitions, of course it's going to be affected.
17:39:01 <conal> Heffalump:  it can wait.
17:39:01 <conal> Heffalump: sleep well.
17:39:12 <dcoutts> Cale: are we sure? is that the only part of the language that is implementation defined?
17:39:19 <samalog> I write C libraries, and would like to use some haskell in them, but would need to compile in any code as source, not as a dll
17:39:21 <Cale> samalog: Not really with GHC. You can compile via C, but the intermediate C code is useless.
17:39:30 <dcoutts> Cale: if it is, then it's a reasonably strong property
17:39:45 <Cale> samalog: The output of GCC after compiling that C code needs to be further mangled by GHC before it will run.
17:40:01 <conal> when people get upset, it gets hard to separate interpretation from observation.
17:40:07 <Cale> dcoutts: Of course, GHC isn't a strict Haskell 98 implementation either.
17:40:23 <samalog> Cale: oh right. Any idea what kind of mangling goes on?
17:40:55 <dcoutts> Cale: true, but if the bits of the language that are implementation-defined are only the libs then that's rather nice. It partially answers conal's question.
17:41:07 <Cale> samalog: iirc, it had something to do with changing the calling convention? But it was years ago now that someone told me.
17:41:09 <dcoutts> it means we could have a single basis
17:41:35 <conal> dcoutts: e.g., it means that my program is unambiguous if i don't use any libs ;)
17:41:40 <dcoutts> and then the semantics of moving between implementations is no different than that in importing different modules (even prelude)
17:41:46 <dcoutts> conal: but you always do
17:41:58 <conal> dcoutts: yeah, i always do.
17:42:03 <dcoutts> conal: because the desugaring is defined in terms of the Prelude
17:42:14 <samalog> Cale: thanks, that's helpful anyway. Any other options? Other compilers? Any way to get at the intermediate C (mangled or otherwise)?
17:42:29 <TomMD> dcoutts: Odd, I think my postfix is broken.  At any rate, I manually sent the patch so you should have it now.
17:42:30 <Cale> conal: Of course, where the definitions made by those different libraries happen to be the same, then there ought to be agreement.
17:42:33 <conal> dcoutts: so language & prelude are not really separable.  hm .
17:42:39 <Cale> samalog: Why?
17:42:48 <Cale> samalog: What are you trying to accomplish?
17:43:03 <Cale> samalog: If you just want to interface with C programs, there's a nice FFI you can use.
17:43:19 <dcoutts> conal: but if we're prepared to parametrise by imports, like ML functors (and allow desugaring to refer to the imported Prelude rather than a static Prelude) then perhaps it gives us a single semantics
17:43:21 <conal> so maybe we could narrow the ambiguity issue to the libs.  i don't know whether that'd be useful progress.
17:43:23 <Cale> samalog: Wherein, you can import and export C functions as much as you like.
17:43:32 <conal> dcoutts: yeah.  maybe.
17:43:32 <dcoutts> TomMD: where did you send it?
17:43:41 <samalog> Cale: as far as I can tell from the docs, the FFI only works with C dlls, or have I misunderstood this?
17:43:45 <TomMD> dcoutts: hackage-serve + happstack-0.2 compiles and runs for me.  I'm going to fix up some glaring omissions (package checking, password changes, 'tarball') and then try to run my own hackage as a test.
17:43:52 <TomMD> dcoutts: oxford...
17:44:10 <Cale> samalog: No, it works with static things.
17:44:13 <TomMD> dcoutts: Ahh, duncan h . o - got it.
17:44:28 <Cale> samalog: In fact, if you pass a .c file on the commandline to GHC, it will compile it and link it into your program, even.
17:44:34 <samalog> Cale: I'd like to produce a C library, containing a mix of hand-written C and haskell-as-C.
17:44:40 <roconnor>  luite I use Chart, but I don't remember how to write axes directly.  It shouldn't be too hard
17:45:00 <dcoutts> TomMD: ah, about 'tarball' you mean the fact we serve the package .tar.gz files as "tarball"?
17:45:10 <Cale> samalog: That's fine. You'll just have to be careful to pass along the responsibility for starting the Haskell RTS to your library's users though.
17:45:10 <TomMD> dcoutts: Yes, exactly.
17:45:15 <dcoutts> TomMD: I can tell you what the url scheme we want to use
17:45:42 <TomMD> That would be good
17:45:48 <dcoutts> TomMD: www.thehost.org/package/foo-1.0.tar.gz
17:46:02 <dcoutts> TomMD: the plan is to have /packages/ distinct from /package/
17:46:27 <TomMD> dcoutts: Oh, and not www.thehost.org/package/foo/foo-x.y.tar.gz ?
17:46:43 <luite> roconnor: I guess it shouldn't be, but the only options that seem easy are completely hiding labels and ticks. The only way I know to adjust the range is by completely recalculating the positions and lengths of each tick
17:46:47 <conal> hm.  i wish i'd just dropped it with Heffalump once i knew he was sleepy.
17:46:58 <dcoutts> TomMD: /package/pkg is for individual elements of the packages collection while /packages/blah is for properties of the collection itself, like the index, aggregate reports etc
17:47:11 <TomMD> dcoutts: got it
17:47:20 <samalog> Cale: I've seen that it's possible to call C libraries from haskell, and that it's possible to produce a C library through GHC - but to do this last option it seems I have to use GHC to compile my code. I need to support several compilers so compiling through GHC isn't an option for me.
17:47:29 <Cale> samalog: However, creating shared object files with GHC is something I've never done myself.
17:47:47 <Cale> But I think some people have managed to do it.
17:48:05 <dcoutts> TomMD: we're trying to follow a REST style, normally we'd have collectionName/element but we have the issue that element names clash with properties of the collection itself and we'll have lots of both.
17:48:38 <dcoutts> TomMD: we could use /package/foo-x.y/foo-x.y.tar.gz but I don't see any particular advantage
17:49:12 <samalog> Any idea why GHC insists on driving gcc itself? Is there a particular reason it doesn't just spit out C source files and leave it to the user?
17:49:22 <dcoutts> TomMD: it'd always be /package/foo-x.y/foo-x.y.tar.gz not /package/foo/foo-x.y.tar.gz because /package/foo/ is the url for the latest/default version and we've also got versioned urls
17:49:33 <jmcarthur> samalog: it doesn't compile to c
17:49:34 <TomMD> dcoutts: I see your point - it doesn't matter to me.  By 'we' you and lemmih talked about this some time ago?
17:49:46 <dcoutts> TomMD: but there is never an unversioned tarball
17:49:53 <Cale> samalog: It only optionally compiles via C, and that isn't the default.
17:49:58 <dcoutts> TomMD: yes, Lemmih and I talked about it
17:50:03 <Cale> samalog: By default, it compiles directly to machine code.
17:50:12 <roconnor> luite: can't you just use (const foo) where foo :: AxisData
17:50:20 <roconnor> luite: you can make foo whatever you want
17:50:27 <Cale> samalog: For C code, it of course calls gcc, because it doesn't contain a C compiler.
17:50:27 <samalog> jmcarthur/Cale: very true - but presumably with -Fvia-c it is generating C somewhere along the line?
17:50:38 <luite> roconnor: yeah I'm trying to to a laxis_override ^= const (makeAxis ...
17:50:43 <Cale> samalog: It is, but it's not C code which is valid.
17:50:50 <dcoutts> TomMD: ah, got your patch now
17:50:58 <Cale> samalog: It's valid enough to be compiled by gcc, but that's it.
17:51:06 <Cale> samalog: If you tried to use it, it wouldn't work.
17:51:16 <ddarius> It post-processes the assembly code as well.
17:51:27 <dcoutts> TomMD: do you use darcs btw?
17:51:35 <ddarius> Note, as I understand it, GHC distributes with its own version of gcc.
17:51:37 <TomMD> dcoutts: I do, and thats how I sent it to you earlier today.
17:51:52 <TomMD> dcoutts: I guess my postfix is not operating correctly.
17:51:56 <samalog> Cale: I guess I'm quite confused here :) Is the gcc that comes with GHC a customised version then?
17:52:13 <Cale> samalog: I'm not sure about that part.
17:52:19 <dcoutts> TomMD: ok, if you can send the darcs patch that'd be great. Also means you get proper credit :-)
17:52:26 <ddarius> samalog: No.
17:52:29 <Cale> samalog: But the post-processing of the assembly output of GCC is something which it definitely does.
17:52:29 <samalog> I figured it was just there to save on packing dependency issues
17:53:01 <Flugan> I'm having trouble loading code using FFI into ghci, is this common?
17:53:01 <TomMD> dcoutts: I resent after restarting postfix, let me know.
17:53:09 <dcoutts> TomMD: ta
17:53:16 <Cale> If you prefer, you can use any C compiler you like to compile .o files from your .c and just use GHC to link them.
17:53:19 <ddarius> samalog: Because it post-processes the assembly, it is highly tied to the details of specific versions of GCC (not to mention using various GCC extensions which may also change.)
17:53:54 <luite> roconnor: oh that function wasn't exported :(
17:54:08 <samalog> Cale/ddarius: Ah. Ok I didn't know about the assembly post-processing. That explains things.
17:54:39 <samalog> So, presumably I'm looking at writing my own compiler if I want C/C++ out as a the backend...
17:54:52 <Cale> The reason why you'll want to use ghc to do the linking is that there are a gazillion things which your Haskell code might need linked in, and figuring out the correct C commandline is tedious.
17:54:58 <Cale> GCC commandline
17:55:03 <roconnor> luite: sorry. I haven't used this new version of Charts with Data.Accessor yet.
17:55:19 <roconnor> luite: I'm of only limited help.
17:55:40 <ddarius> samalog: JHC/LHC produces standard C.
17:55:55 <Cale> But, I've heard of people using GHC to construct .so files.
17:56:20 <Cale> I'm not sure how easy it is, but if you can do that, there would be no need to further worry about GHC.
17:56:33 <Cale> (I think)
17:56:43 <ddarius> You just link the .o files GHC produces.
17:57:54 <samalog> unfortunately, it's tricky linking object files with other compilers. There isn't really rock solid compatibility between compilers on objects. libs are ok.
17:59:01 <samalog> I haven't seen LHC or JHC before. I've just googled them up. Any comment on how mature they are?
17:59:20 <Cale> They're not.
18:00:19 <samalog> rats :)
18:00:40 <ehird> Woo, I just compiled HOC the simplest ever.
18:00:50 <ehird> beelsebob says he'll post it to the google code tracker later; if anyone's interested
18:01:26 <samalog> ok, it's 2am here so I'm going to dig into LHC/JHC tomorrow now. Thanks very much for the help!
18:02:34 <Cale> samalog: But maybe look to see if anyone's documented the way to construct DLL/.so files using GHC.
18:03:29 <samalog> Cale: will do. thanks.
18:03:32 <Flugan> Hi, I'm new to the channel, any rules of conduct I should be aware of?
18:03:46 <ehird> Flugan: be friendly. :)
18:03:55 <Cale> Flugan: Feel free to ask any questions about Haskell you might have.
18:04:12 <TomMD> Flugan: And if you start to get too off topic, hop on over to #haskell-blah.
18:04:21 <Cale> Flugan: If you have to paste something large, then use a pastebin, like...
18:04:23 <Cale> @paste
18:04:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:04:24 <Flugan> I am currently working on my first major Haskell project
18:04:35 <Cale> cool
18:04:59 <Flugan> about 15000 lines, academic so the main documentation is the code because people move on.
18:05:21 <TomMD> Thats almost quote worth.
18:05:21 <Cale> That's quite a lot of code, yeah :)
18:05:24 <TomMD> worthy
18:05:59 <Cale> Flugan: What project?
18:06:16 * Cale tries to imagine something which would be 15k lines of Haskell code.
18:06:23 <ehird> 1 5 k o _ o wow
18:06:29 <ehird> Cale: driving the LHC?
18:06:32 <ehird> can't think of anything else ;)
18:06:36 <Cale> hehe
18:06:54 <Flugan> We are writing a compiler that post processes MIPS assembler coming from gcc and restructures it to run on a flexible micro processor design
18:07:23 <ehird> Flugan: I can't imagine that taking 15k lines of code
18:07:53 <Cale> Depends how much restructuring :)
18:09:11 <Flugan> The architecture is an unorthodox VLIW where the internal pipeline of the cpu is exposed
18:10:22 * ddarius can see 15,000 lines popping out of that easily, most of them not very interesting.
18:10:22 <BMeph> Flugan: If it turns out that your project only takes 5000 lines, will people be upset and leave the project? ;)
18:10:53 <Flugan> not really
18:11:04 <Flugan> The density is varying
18:11:57 <pejo> Flugan, how come you chose Haskell?
18:12:00 <Flugan> and it's not really a good measure
18:12:38 <Flugan> Because it was already written in haskell.
18:15:31 <Flugan> I have currently given up on getting the code which uses FFI to load in ghci.
18:18:31 <dcoutts> Flugan: compile it first, it works fine
18:18:42 <Flugan> Recently performed unsafeIO to parse the command line
18:20:05 <dcoutts> Flugan: is that the same project Thomas Schilling was working on?
18:20:18 <Flugan> yes
18:20:25 <dcoutts> sounded like a fun project
18:20:32 <ddarius> You shouldn't need unsafePerformIO to read in command line parameters in GHCi.  Perhaps I misunderstood your intent?
18:21:10 <Flugan> As far as I know I do need unsafeIO
18:21:20 <ddarius> Just write: args <- getArgs
18:21:26 <Flugan> Passing along state to pure functions all over the place is not convenient
18:21:57 <dcoutts> Flugan: there should never be any need for unsafeIO in any real program, if you think there is it's usually a sign that it's not structured right.
18:22:44 <dcoutts> Flugan: if you've got lots of parameters passed together you've got a few options, you can put them into a record so at least it's only one arg to pass in
18:22:55 <dcoutts> Flugan: sometimes it's appropriate to use a reader monad
18:23:09 <Flugan> If we break it down you can use the reader monad to store the parsed options
18:23:26 <dcoutts> but if you're not using a monad already then I usually think the reader monad route is not so good
18:23:48 <Flugan> But then everything that is affected by the Options need to be inside the monad or have the option passed.
18:23:54 <dcoutts> usually I find in those situations that passing the info in appropriate structures is usually the right approach
18:24:39 <dcoutts> Flugan: I'd also not pass Options as one massive chunk, there's no reason that these input parameters need be command line args from the pov of the code that uses them
18:25:52 <dcoutts> Flugan: for example, Cabal is a program that has a lot of command line args and general config. We break it into a few structures and just pass them as parameters.
18:26:01 * BMeph looks at the big-ol' "@-hammer" in front of dcoutts' nick, and wonders if he knows that a spammer is due to arrive soon...
18:26:03 * PHO_ thinks getArgs doesn't need to be IO [String] because program arguments don't change time to time
18:26:08 --- mode: ChanServ set -o dcoutts
18:26:14 <dcoutts> BMeph: ah, I forgot
18:26:24 <JavaUser> looking for a coder to co-own and develop a platform for gaming tournaments
18:26:28 <ddarius> dcoutts: So did Heffalump before he went to sleep.
18:26:28 <dcoutts> BMeph: we had one earlier
18:26:59 <BMeph> dcoutts: I thought that might be the likelier case, but just in case, I wanted to cover other bases. :)
18:27:09 * ddarius starts spamming.
18:27:10 <dcoutts> BMeph: heh heh
18:27:16 <dcoutts> @slap ddarius
18:27:17 * lambdabot puts on her slapping gloves, and slaps ddarius
18:27:23 <jmcarthur> wow, the discussion about RT earlier looks like it got a bit heated
18:27:27 <conal> PHO_: same sort of reasoning, i guess, as in the previous protracted discussion of referential transparency.
18:27:35 <jmcarthur> wish i could have been around to fuel the fire
18:27:49 <conal> jmcarthur: i wish i'd fueled it a little less
18:28:06 <jmcarthur> conal: it seems like i went on a tangent, to be honest
18:28:07 <dcoutts> conal: oh, there are several annoying examples like that. For example stdin/out/err.
18:28:22 <conal> dcoutts: what about stdin/out/err?
18:28:29 <ddarius> Perhaps #haskell-in-depth would be a better place for future "protracted discussions" of that topic, by the way.
18:28:32 <conal> jmcarthur: oh?
18:28:37 <conal> ddarius: yeah.
18:28:43 <dcoutts> conal: they look like mere labels, like data STDHandle = StdIn | StdOut | StdErr, and if they were then it'd be fine
18:28:55 <dcoutts> conal: but each Handle is a mutable variable/object
18:29:09 <jmcarthur> conal: you wanted to discuss whether Haskell *should* follow your proposed definition of RT, but it seems like the topic turned into whether your definition of RT *is* the definition of RT
18:29:24 <roconnor> PHO_: see System.Environment.withArgs
18:29:41 <dcoutts> conal: so stdin :: Handle as a top level thing doesn't make sense, it should be a parameter of main, or something you can extract from the IO monad
18:29:44 <conal> jmcarthur: did i come off as shoulding?  hm.
18:30:09 <dcoutts> conal: there's no way to define stdin :: Handle within the language. That's the problem.
18:30:10 <PHO_> roconnor: aah! I see :)
18:30:25 <conal> dcoutts: i know why i wouldn't do stdin :: Handle, but i don't think i understand why you wouldn't.
18:30:34 <conal> dcoutts: ditto for getArgs
18:30:50 <dcoutts> conal: getArgs is quite different, it's in IO, it's ok
18:31:02 <dcoutts> conal: getStdin :: IO Handle would be ok
18:31:19 <conal> dcoutts:  i mean i don't know why you wouldn't be happy for getArgs :: [String]
18:31:29 <jmcarthur> conal: i don't think qualified shoulding is such a bad thing. it's only unqualified shoulding that is negative
18:31:38 <ddarius> @wn shoulding
18:31:40 <roconnor> conal: see System.Environment.withArgs
18:31:41 <lambdabot> No match for "shoulding".
18:31:52 <jmcarthur> conal: but this particular topic seemed to be hard to qualify properly :\
18:32:01 <dcoutts> conal: I'm not one of the people who thinks it's ok to have any old "static" bit of the environment be a global value.
18:32:25 <conal> dcoutts: neither do i, but maybe for different reason.
18:32:49 <conal> dcoutts: mine is that the semantics i like for [String] don't leave room for it.
18:32:51 <dcoutts> conal: I'm happy to parametrise the semantics by int size, but not by program arguments
18:33:16 <conal> dcoutts: okay.
18:33:58 <conal> jmcarthur: i hope i wasn't shoulding, qualified or not.  i think i was mainly fishing to see if anyone else out there thinks of languages the way i do.
18:34:23 <jmcarthur> conal: i don't think you were pushy, if that's what you mean
18:34:35 <conal> jmcarthur: yeah.  i guess something like that.
18:34:57 <jmcarthur> dcoutts: I understand what you mean, but I'm curious... would you consider getArgs :: [String] to be RT?
18:35:10 <jmcarthur> touching on definitions again
18:35:15 <dcoutts> jmcarthur: nope
18:35:17 <jmcarthur> okay
18:35:31 <roconnor> jmcarthur: I would
18:35:41 <roconnor> I'm not sure why dcoutts wouldn't
18:35:54 <conal> roconnor: me neither.
18:36:01 <jmcarthur> nor i
18:36:19 * EvilTerran wanders in... RT = referential(ly) transparen(t/cy)?
18:36:26 <conal> EvilTerran: yeah
18:36:35 <roconnor> though I think getArgs :: [String] is still a bad idea
18:36:37 <sjanssen> mmorrow++ vacuum looks like excellent software
18:36:40 <dolio> Probably because there's no definition you could write for it, unlike maxBound.
18:36:45 <dcoutts> jmcarthur: my position is that there should be a operational and denotational semantics for the language(s) but I'm happy for practical reasons to parametrise that by things like the size of Int.
18:37:09 <conal> dcoutts: and yet not by the program arguments.
18:37:18 <dcoutts> jmcarthur: which means I'm happy with maxBound :: Int but not getArgs :: [String]
18:37:20 <dcoutts> conal: exactly
18:37:42 <roconnor> dcoutts: but jmcarthur asked if getArgs :: [String] is RT, not if it is a good idea.
18:38:05 <EvilTerran> dcoutts, so it's RT if it can't change after compile-time, effectively?
18:38:07 <jmcarthur> in a dependently typed language i would probably be okay with Int :: IO Set :)
18:38:24 <EvilTerran> (assuming you have to recompile for different word sizes)
18:38:39 <dcoutts> EvilTerran: no, it's stronger than that
18:38:41 <ddarius> Command line arguments aren't implementation-defined, however, you could indeed treat them the same way, but if you do that, you open floodgates to all of, at least input, being treated that way (which you can do).
18:38:54 <dcoutts> conal: one is parametrising the language, the other is not, they're very different examples
18:39:05 <roconnor> wow
18:39:12 <roconnor> so many different understandings of RT
18:39:14 <ddarius> Also, I believe you can change the command line parameters at run-time.
18:39:15 <conal> dcoutts: parameterize the language by main's arguments ?
18:39:28 <dcoutts> conal: that doesn't make any sense :-)
18:39:30 <conal> ddarius: oh yeah, that'd be nasty.
18:39:37 <jmcarthur> roconnor: yeah, we obviously need more precise terminology
18:39:50 <conal> dcoutts: makes as much sense as the other, to me.
18:39:51 <ddarius> main should be explicitly parameterized anyway, for orthogonal reasons.
18:40:08 <conal> dcoutts: which is fine with me.  seems pretty subjective without precise criteria.
18:40:23 <conal> dcoutts: i'm glad you don't like getArgs :: [String], btw.
18:40:26 <dcoutts> conal: surely you see that we can construct a denotational semantics and then make some constant in it a variable parameter.
18:40:43 <conal> dcoutts: yeah
18:41:04 <conal> i have what i think is a simple criterion for these questions.
18:41:06 <dcoutts> and that's totally different than this issue of the environment of the operation of a program
18:41:26 <conal> dcoutts: that part i don't see
18:41:49 <dcoutts> conal: the environment comes into play through IO
18:41:50 <conal> dcoutts: i guess i'm just saying that your criterion is a mystery to me.
18:42:08 <conal> dcoutts: hm.  isn't that just an implementation consideration.
18:42:16 <conal> dcoutts: don't think of the arguments coming in through IO
18:42:32 <conal> dcoutts: or do.  i don't know what  difference it makes to you.
18:42:34 <roconnor> dcoutts: I don't see how you can claim getArgs :: [String] isn't RT without saying that Haskell isn't RT because of that example on Cafe with lazy IO.
18:42:38 <dcoutts> conal: you can have them as parameters to main, that's another option
18:43:15 <ddarius> roconnor: Lazy IO potentially does break referential transparency.
18:43:16 <dcoutts> roconnor: that's fine if you define the semantics of IO using non-determinism
18:43:31 <conal> dcoutts: i'm not up for another argument.  if you know what criterion you use, i'd like to hear it.  otherwise, i'd rather drop it.
18:43:42 <conal> still worn out from the bout with Heffalump
18:43:43 <ddarius> roconnor: It definitely violates purity a la Amr Sabry.
18:43:43 <roconnor> dcoutts: can't we define the semantics of getArgs using non-determinism?
18:43:58 <dcoutts> roconnor: not if it's type [String]
18:44:12 <roconnor> What makes [String] more special than IO ?
18:44:28 <conal> roconnor: maybe dcoutts has a model in mind for [String].
18:45:02 <dolio> The lazy IO doesn't rely on a nondeterministic IO action being selected, it relies on the IO action producing values nondeterministically when executed by the runtime.
18:45:09 <brownegg> couple of noob qs
18:45:26 <brownegg> i assume haskell functions can't return multiple values?  only containers if necessary?
18:45:37 <conal> brownegg: they can return tuples
18:45:44 <brownegg> ok that's what i figured
18:45:49 <conal> brownegg: but not unstructured multiple values.
18:45:52 <brownegg> so then in a type siganture
18:45:58 <dcoutts> conal: my criterion is if the parameter you want to vary is a sensible one for the language, and I say that Int size is sensible and main args are not
18:46:09 <TomMD> brownegg: tuple :: (a,b,c,d)
18:46:10 <brownegg> fn a b c :: int -> int -> int -> int
18:46:14 <TomMD> or how ever many elements are inthe tuple.
18:46:17 <brownegg> i know that the last term is the return?
18:46:17 * ddarius doesn't know what the difference between returning "unstructured multiple values" and returning a tuple is.
18:46:30 <conal> ddarius: common lisp has multi-value return
18:46:37 <brownegg> doesn't python as well?
18:46:38 <conal> ddarius: which is different from returning a structure
18:46:41 <conal> ?
18:46:43 <roconnor> dcoutts: ``my criterion is if the parameter you want to vary is a sensible one''  That is part of your definition of RT?!  Whether it is "sensible"?
18:46:55 <brownegg> i can't remember what does and doesn't
18:47:01 <ddarius> conal: I know.  As far as I can tell, it mainly comes down to a nice notation for selecting the first element of a (second-class) tuple implicitly.
18:47:02 <dcoutts> roconnor: no, we already agreed that RT depends on the semantic context
18:47:18 <brownegg> in any case, why are type signatures written as i just did, rather than something like
18:47:20 <roconnor> dcoutts: but the question is: is getArgs :: [String] RT?
18:47:29 <brownegg> fn a b c :: int, int, int -> int
18:47:33 <brownegg> isn't that more intuitive?
18:47:34 <jmcarthur> dcoutts: Yeah the issue seems to be what that semantic context includes.
18:47:47 <dcoutts> roconnor: you can define it using an operational semantics, a denotational one. If our semantics is parameterised by this or that, then we have to take that into account.
18:47:59 <dcoutts> jmcarthur: exactly
18:48:08 <conal> brownegg: haskell is founded in the lambda calculus, in which all functions take exactly one argument and yield exactly one result.
18:48:18 <roconnor> dcoutts: is System.Info.os RT?
18:48:19 <dons> brownegg: ghc actually compiles certain structures into 'unstructured return values' -- the multiple components are left in registers
18:48:21 <TomMD> brownegg: Your signatures are misleading.  "fn :: Int -> Int -> Int -> Int"   but "fn a b c :: Int"
18:48:27 <conal> brownegg: it's minimal & regular.  that's the aesthetic
18:48:37 <dcoutts> roconnor: in the semantic context I'm happy with, no it is not
18:48:40 <brownegg> so the notation implies single results mapped in chains
18:48:44 <dons> mmorrow: thanks. will update
18:48:51 <conal> @type System.Info.os
18:48:52 <lambdabot> String
18:48:55 <roconnor> bah
18:48:57 <TomMD> brownegg: Also, "fn a :: Int -> Int -> Int" so there we applied only a single 'Int' and the return value was a new function "Int -> Int -> Int"
18:49:03 <conal> oh dear :(
18:49:11 <jmcarthur> conal wants that context to include nothing so that the semantics can be treated purely as a math, as I understand it. dcoutts is willing to accept the context being not empty.
18:49:15 <ddarius> brownegg: You can write f :: (Int, Int, Int) -> Int if you want, though this is different than Int -> Int -> Int -> Int which both mean exactly what they look like (assuming you know the associativity of ->)
18:49:36 <brownegg> hm, ok
18:49:41 <brownegg> i think i need to read more
18:49:44 <conal> jmcarthur: yeah.  exactly.  :)
18:49:50 <dcoutts> roconnor: though you can also escape that by talking about semantics of modules as functors etc and then say that you're just building a different program on that other system.
18:49:51 <brownegg> just picked up hsoe... it's good
18:49:53 <jmcarthur> > System.Info.os
18:49:54 <lambdabot>   /tmp/2154375422478215117:70:32: Not in scope: `System.Info.os'
18:50:00 <dcoutts> roconnor: that's not so nice, I admit.
18:50:07 <conal> jmcarthur: i like semantics to be as simple as possible.
18:50:12 <jmcarthur> brb
18:50:25 <jbapple> Just saw this awesome video: http://www.youtube.com/watch?v=X4-212uMgy8
18:50:40 <conal> jbapple: what do you like about it?
18:50:54 <jbapple> I'm trying to do it myself, but "cabal: cannot configure vacuum-cairo-0.1. It requires cairo -any, gtk -any and svgcairo -any"
18:50:56 <dolio> At least I can write 'module System.Info where os = "Windows"'. What is your definition of getArgs :: [String]?
18:50:58 <roconnor> dcoutts: I guess I'm like conal in that I totally don't understand what you mean by RT.
18:51:17 <roconnor> dolio: my definition is linked at runtime.
18:51:23 <jbapple> conal: easy tool, useful for performance debugging, short video
18:51:44 <conal> jbapple: thx.
18:52:00 <jbapple> so I yum installed ghc-gtk, ghc-cairo, and ghc-svgcairo, but cabal can't see them, I think?
18:52:09 <jbapple> ghc-package list gives no hint that they are there
18:52:17 <jbapple> conal: thank YOU
18:52:20 <jbapple> :-)
18:52:20 <conal> jbapple: confession: i was fishing to see if you were spamming us.  i didn't recognize your nick.
18:52:23 <dcoutts> roconnor: it's a fairly clear property, given a semantics. There is an issue about an appropriate context, eg a hole in a program of type IO () isn't so useful, usually people use a context of type Int.
18:52:29 <conal> jbapple: ?? for what?
18:52:59 <dcoutts> roconnor: because we have more of a semantics for Int than IO (), the latter including non-determinism etc etc
18:53:32 <roconnor> dcoutts: shouldn't the definition of RT be more clear cut than that?
18:53:35 <jbapple> conal: I supposed the thanks was for a complement to something you did. I thought dons made the video, and I thought I didn't recognize the name for the vacuum package, but I thought, when you thanked me, that it was your name and I had just forgotten
18:53:41 <roconnor> dcoutts: yours sounds too fuzzy.
18:53:42 <jbapple> Anyway, the video is not a rickroll
18:54:09 <conal> jbapple: oh -- :)
18:54:19 <jbapple> So, I don't know how cabal looks for cairo, gtk, and svgcairo
18:54:35 <ddarius> jbapple: mmorrow made vacuum (unless I'm horribly mistaken)
18:54:46 <JohnnyL> is prolog as expressive as haskell? can it do equal extents of programming abilities?
18:55:06 <ddarius> JohnnyL: They're both Turing complete.
18:55:10 <dcoutts> roconnor: no it's quite precise. The normal definition iirc, is that we take a program of type Bool with a hole in it, then we substitue the two values into that hole. If the meanings are the same then it's RT. Yes?
18:55:23 <jbapple> JohnnyL: prolog is fun, but it's not as good for typed programming. Have you looked at mercury and/or curry?
18:55:23 <conal> JohnnyL: yeah.
18:55:52 <conal> JohnnyL: also check out lambda-prolog, which combines prolog and higher-order programming.
18:55:58 <conal> both higher-order functions and higher-order logic
18:56:03 <dolio> Does prolog have types at all?
18:56:05 <roconnor> dcoutts: Yes, and from that definition I'd say that System.Info.os is RT.
18:56:12 <jbapple> so, any ideas on how to register the packages to vacuum-cairo can see them?
18:56:17 <ddarius> dcoutts: That seems pretty butchered.
18:56:29 <jbapple> I also tried "sudo ghc-pkg --global register /usr/lib/ghc-6.10.1/gtk2hs-0.10.0/mumblemumble", to no avail
18:56:32 <dcoutts> ddarius: what did I miss?
18:56:51 <dcoutts> ddarius: or am I confusing contextual equivalence and referential transparency?
18:56:57 <ddarius> dcoutts: That sounds almost like a definition of observational equivalence for a value.
18:57:02 <roconnor> dcoutts: but your definition, and none of the RT definitions given seem to address issues that are needed to decide if System.Info.os or getArgs :: [String] is RT.
18:57:12 <dolio> Not that I disagree that not having a type system makes it "not as good for typed programming". :)
18:57:21 <ddarius> Referential transparency is that you can replaced a variable with its definition without changing the meaning of the program.
18:57:42 <ddarius> (i.e. you can "see through" the reference)
18:58:02 <jbapple> dolio: prolog is not statically typed, though there is a prototype tool for it
18:58:14 <roconnor> ddarius: that doesn't seem to be what we mean by RT.  Isn't ML RT according to that?
18:58:19 <conal> ddarius: there's a different definition on wikipedia.  or maybe i just took it too literally.
18:58:27 <dolio> No, it is not.
18:58:27 <JohnnyL> jbapple no but thanks for the info! :)
18:58:37 <conal> ddarius: says "value" instead of "definition".
18:58:46 <dolio> At least, I doubt it.
18:58:52 <ddarius> roconnor: No.  If I replace x = new 0 in f x x I get f (new 0) (new 0) which is certainly not the same.
18:59:01 <ddarius> roconnor: I can make a specific f if I need to.
18:59:04 <JohnnyL> conal ok thanks
18:59:09 <conal> :)
18:59:10 <dcoutts> ddarius: is that equivalent to saying the expression and the value are observationally equivalent?
18:59:16 <roconnor> ddarius: interesting.
18:59:36 <ddarius> dcoutts: Yes, but that's just the "without changing the meaning of the program" part.
18:59:39 <roconnor> ddarius: okay good.
18:59:54 <roconnor> ddarius: is getArgs :: [String] RT?
19:00:06 <glguy> Anyone know a program for interactively exploring geometry (I remember using cabri geometry for this in middle school)
19:00:23 <wli> getArgs :: IO [String]?
19:00:44 <dcoutts> wli: roconnor is asking is it ok if you take off the IO
19:00:54 <roconnor> wli: getArgs :: [String] is a from haskell standard in a parallel universe.
19:01:02 <dolio> roconnor: If you're really prepared to say you're generating a module with its definition at runtime and recompiling with it, then yes. :)
19:01:24 <glguy> withArgs :: [String] -> IO a -> IO a
19:01:30 <glguy> you can't take it out of IO while we have that :)
19:01:38 <ddarius> roconnor: If it is not possible to programmatically change getArgs, then yes, I would say that you could view programs that use getArgs (with the appropriate sense) as referentially transparent.
19:01:39 <roconnor> dolio: thanks.  I'll think about that.
19:01:54 <glguy> ?hoogle withArgs
19:01:54 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
19:02:09 <roconnor> ddarius: good good.  (by getArgs :: [String] I also mean that withArgs is removed)
19:02:19 <ddarius> roconnor: Whether 'getArgs' itself is referentially transparent depends on its definition.
19:02:53 <roconnor> ddarius: so Int can't be referentially transparent because there is no reference?
19:03:13 <conal> roconnor: or it is vacuously RT for that reason.
19:03:15 <roconnor> ddarius: or maybe this gets into Cale's different Prelude module idea.
19:03:19 <wli> getArgs using the IO monad is kind of pointless.
19:03:32 <roconnor> where there are multiple Preludes with different definitions that are RT.
19:03:43 <ddarius> roconnor: It doesn't make sense to say a type is or is not referentially transparent.
19:03:45 <guenni> let's say I have 2 sorted lists 1: [-1, 2, 3, 5] and 2: [0, 1, 2, 3, 4, 5, 6] and wanted to get [2, 3, 4, 5] as the result, is there a pre-defined zipping function for that?
19:03:47 <roconnor> conal: well, I'm not sure it is vacuous, because ML isn't RT.
19:04:04 <dolio> What does "vacuously RT" mean?
19:04:05 <roconnor> ddarius: er, right. I should have said (minBound :: Int)
19:04:18 <wli> In real-life terms it's not performed via system call; it's just memory access, and the Haskell RTS treats that memory as immutable.
19:04:28 <roconnor> conal: as per ddarius's example.
19:04:52 <conal> dolio: i mean if the definition says you can replace a variable by its value, but the value is not expressible.  or if the definition says you can replace a variable by its definition but there's no definition.  then RT vacuously.
19:04:53 * roconnor has actually learned a lot from all this RT talk
19:05:14 <conal> dolio: that's what i meant.
19:06:41 <roconnor> conal: I'm starting to get swayed to Cale's differing Prelude module idea.  It seems to fit very well with everything.
19:06:59 <wli> I was more interested in how module systems are modelled.
19:07:11 <wli> Uh-oh, what's Cale's differing Prelude idea?
19:07:33 <conal> roconnor: it makes sense to me.  but doesn't satisfy my desire that a haskell program using standard types have a (just one) precise & simple semantics.
19:07:39 <dcoutts> roconnor: it's a reasonably explanation if it is indeed true that the only thing the H98 report leaves up to implementations is some details in the Prelude. If it is great.
19:07:41 <roconnor> wli: the idea is that different platforms provide different Prelude modules, some with different definitions of Int and minBound :: Int.
19:08:23 <dcoutts> conal: it's worth looking, I think, for a basis that is precise and simple. The Prelude is perhaps too big.
19:08:33 <conal> roconnor: especially since i don't know how to write a haskell program that doesn't use a prelude.
19:08:53 <roconnor> conal: no implicit prelude
19:08:54 <roconnor> ;)
19:09:04 <dcoutts> conal: eg someone mentioned earlier, can we give a reference implementation of the Prelude within the language. Eg Int in terms of algebraic types etc.
19:09:40 <wli> 2^30 distinct alternatives? 2^32? 2^64?
19:09:42 <conal> dcoutts: and ask implementations to agree wht that spec (reference implementation)?
19:09:51 <ddarius> wli: 2^29
19:10:04 <jbapple> cabal can't find a package that is definitely listed in my package.conf file
19:10:05 <roconnor> conal: you could probably even write your own IO data type a la @wiki IO_Semantics.
19:10:09 <ddarius> (or maybe 2^30 if that was just the upper bound)
19:10:18 <jbapple> in fact, ghc-pkg can't see it either!
19:10:25 <roconnor> conal: but you'd have to hack a compiler to interpret your own IO data type
19:10:30 <conal> roconnor: yeah.  and it wouldn't agree with IO.  it couldn't cover the whole sin bin.
19:10:51 <dcoutts> conal: no, it's a semantic reference point. It's a particular unamibgious way to instantiate the Prelude parameter in your programs.
19:10:55 <wli> ddarius: Even 2^29 would still be infeasible for compilers to cope with in any reasonable amount of time.
19:10:57 <jbapple> Yet, I can see it with my own eyes when grepping  /usr/lib/ghc-6.10.1/package.conf
19:11:16 <dcoutts> jbapple: are you using runghc Setup configure by any chance?
19:11:22 <conal> roconnor: i think one of the purposes of IO is a place to put stuff that is semantically ill-defined.  i think that's what spj meant by the term "sin bin".
19:11:37 <andyou> How do I fix the statement "f x = n/2 where n = floor (x/3)"? I'm getting lost in the type classes :(
19:11:40 <jbapple> I am using cabal install
19:11:49 <dcoutts> jbapple: oh, the other possibility is the package is broken. cabal-install ignores broken packages.
19:11:53 <roconnor> conal: that might be what is done in practice, but I don't think it has to be that way.
19:12:03 <dcoutts> jbapple: does ghc-pkg list show it int {}'s ?
19:12:10 <conal> andyou: you've got to get back from an integral type to a fractional type before dividing by 2
19:12:20 <dolio> If you want to define a machine-independent semantics, why not just kick out Int altogether.
19:12:31 <dolio> Isn't its entire reason for existence to be a concession to performance?
19:12:36 <conal> andyou: or switch to n `div` 2, if you don't mind some loss in accuracy
19:12:42 <dcoutts> jbapple: see also the output of ghc-pkg check
19:12:56 <jbapple> dcoutts: all of a sudden my ghc-pkg is broken!
19:13:03 <jbapple> ghc-pkg: missing --global-conf option, location of global package.conf unknown
19:13:16 <andyou> conal: But isn't an Integral contained in a Fractional?
19:13:51 <dcoutts> jbapple: not sure what's going on there
19:14:03 <conal> andyou: i don't think so.
19:14:05 <jbapple> oh, I see the problem: my package manager install ghc in /usr/ when I already had a hand-installed copy in usr/local
19:14:07 <pumpkin> our the Monad instances we use in haskell the only possible ones given the laws, or are there other possible ones for certain cases?
19:14:11 <jbapple> what a mess!
19:14:13 <dcoutts> jbapple: ahhh
19:14:24 <pumpkin> our = are
19:14:28 <pumpkin> wow, that's an odd typo
19:14:30 <jbapple> ok: anybody know how to safely uninstall ghc from /usr/local? :-)
19:14:33 <pumpkin> must be thinking phonetically
19:14:57 <conal> pumpkin: do you mean for a given type?
19:14:58 <jbapple> $ make uninstall
19:14:58 <jbapple> make: *** No rule to make target `uninstall'.  Stop.
19:15:01 <andyou> conal: So the way to fix this is to make a separate function that does "floor (x/3)" with the correct types?
19:15:09 <conal> pumpkin: e.g., could there be a different list monad?
19:15:16 <pumpkin> conal: yeah, say for list, the concatMap as bind, etc.
19:15:19 <dcoutts> jbapple: rm the appropriate binaries in local/bin the rest is in local/lib/ghc-x.y
19:15:19 <pumpkin> yeah, basically
19:15:23 <conal> andyou: no.  you can insert a fromIntegral or some such
19:15:47 <conal> pumpkin: hm.  the stream monad is quite different from the list monad.
19:15:48 <jbapple> dcoutts: by "the rest is in", do you mean "the rest can be safely rm-ed"
19:16:02 <dcoutts> jbapple: yep
19:16:10 <conal> pumpkin: but i don't know if the possibility of finiteness precludes using the stream monad as the list monad
19:16:25 <conal> pumpkin: i.e., defining it analogously.
19:16:49 <conal> pumpkin: you know that there are (at least) two different list applicatives, right?
19:17:24 <conal> pumpkin: anyway, i wonder the same thing.  if you get an answer, would you let me know?
19:17:53 <sundaymorning> I'm reading an article and it talks about a functor ((->) e), but :t (->) gives me a parsing error.
19:17:59 <sundaymorning> what's up with that?
19:18:01 <conal> does anyone know if using the stream-style monad for list breaks any monad laws?
19:18:08 <pumpkin> conal: sure thing
19:18:21 <conal> sundaymorning: :t applies only to values
19:18:21 <pumpkin> conal: yeah, the ziplist and the monad-like one, right?
19:18:36 <conal> pumpkin: monad-like?
19:18:50 <pumpkin> the one that matches up with the standard list monad behavior
19:18:55 <dolio> The monad corresponding to ZipList has associativity issues.
19:18:57 <conal> pumpkin: oh.  yeah.
19:19:19 <conal> dolio: so maybe a monad associativity law fails?
19:19:21 <ddarius> sundaymorning: (->) is not a value.
19:19:26 <dolio> Right.
19:19:29 <dolio> I think at least.
19:19:38 <andyou> conal: Using fromIntegral it works, but gives a float (or whatever not-int). I guess I'll learn enough to fix this example in the future. Thanks for the help.
19:20:01 <conal> andyou: do you want to end up with an int?
19:20:08 <pumpkin> mmorrow: :o
19:20:19 * conal fights the impulse to ask which kind of Int.
19:20:24 <sundaymorning> ddarius: how does that (->) functor works then?
19:20:28 <andyou> conal: Yes.
19:20:34 * conal like dr strangelove fighting his fake arm.
19:20:37 <sundaymorning> I can fmap (2+) (Just 1)
19:20:38 <dolio> I don't have an example on hand, but I think you run into problems if you, essentialy, try to call join on non-square [[a]]s.
19:20:50 <conal> andyou: then maybe use `div` instead of /
19:20:51 <sundaymorning> but I don't get what I could do with (->)
19:20:59 <ddarius> sundaymorning: (->) is a type constructor, functors are type constructors, in fact, types are type constructors.
19:21:07 <ddarius> sundaymorning: Writing :t Int won't work either.
19:21:11 <ddarius> :k (->)
19:21:13 <lambdabot> ?? -> ? -> *
19:21:33 <conal> wow -- what's ?? vs ? vs * (?)
19:21:45 <ddarius> Some GHC craziness related to unboxed types.
19:21:53 <conal> (hm.  how do you end a question that has all that punctuation?)
19:22:05 <dolio> ?? is the union of # and *, ? is the union of ?? and (#).
19:22:05 <lambdabot> Plugin `compose' failed with: Unknown command: ""
19:22:14 <dolio> # is unboxed types, (#) is unboxed tuples.
19:22:26 <pumpkin> all sorts of crazy kinds of kinds!
19:22:37 <andyou> conal: Thanks, that worked :)
19:22:43 <conal> andyou: yay!
19:22:46 <pumpkin> soon we'll need another way of classifying kinds
19:22:48 <conal> dolio: thanks.  how on earth do you remember?
19:23:12 <dolio> I remember that you can only return unboxed tuples from functions, not pass them as arguments.
19:23:18 <dolio> The rest falls out from that.
19:23:34 <conal> dolio: cool.  thx.
19:23:58 <conal> dolio: and how do you remember that to/from distinction?
19:24:06 <conal> i have no internal model for these things.
19:24:56 <dolio> Well, unboxed tuples are for returning multiple results in registers, which you can't do any other way. There's no need for them as arguments, presumably.
19:25:08 <dolio> As long as GHC is smart enough at register allocation, at least. :)
19:25:24 <conal> wow -- i have a lot to learn
19:27:07 <SamB> dolio: indeed, there's no need
19:27:17 <SamB> but there's no need to NOT support them there either
19:27:47 <ddarius> conal: See "Kinds are Types" on this page for the details: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
19:28:01 <conal> ddarius: thx!
19:31:41 <jbapple> Has anyone else here gotten vaccum-cairo working?
19:32:02 <jbapple> I fixed by ghc install problem, but I'm getting "*** Exception: fd:7: hFlush: resource vanished (Broken pipe)" errors now
19:33:46 <dolio> > let diag ((x:_):xs) = x : diag (map (drop 1) xs) ; diag _ = [] ; m = [[[1,2],[3,4]],[[],[7,8]]] in (diag $ diag m, diag $ map diag m) -- <-- associativity fail, conal
19:33:47 <lambdabot>   ([1,8],[1])
19:35:01 <dolio> diag being the join for the monad corresponding to ZipList.
19:35:45 <dolio> It works if you ensure that your lists always have the same length (including infinite).
19:36:09 <gwern> how do you know if your two infinite lists are the same length?
19:36:18 <hiredman> does it need to be the same infinity?
19:36:25 <dolio> All infinite lists have the same length. :)
19:36:29 <hiredman> both א₀
19:40:13 <dolio> I guess that answers pumpkin's question. Vector N is a monad in two different ways.
19:42:22 <dolio> Or, wait. No it isn't.
19:43:48 <dolio> You can't make it a monad like list is, because join would be :: Vector N (Vector N a) -> Vector (N*N) a.
19:44:58 <gwern> hm. this vacuum visualization doesn't actually help much
19:46:02 <gwern> the node-texts are noisy and aren't clear what's actually in'em, although the overal structure is clear at least in the zip and intmap examples
19:46:28 <pumpkin> aw
19:48:15 <ddarius> data Stream a = Cons a (Stream a)
19:49:16 <pumpkin> mmorrow: why the switch to LGPL?
19:51:12 <mmorrow> i dunno, i'm kinda torn.
19:51:20 <pumpkin> oh no!
19:51:24 <mmorrow> heh
19:52:00 <mmorrow> it seemed like a nice compromise
19:52:17 <mmorrow> but i'm open to convincing.. :)
19:52:36 <pumpkin> oh, I'm not much of a license person :P
19:52:41 <pumpkin> was just curious
19:53:49 <mmorrow> pumpkin: have you seen dons' vacuum-cairo?
19:53:58 <pumpkin> yeah, well I saw the videos
19:54:05 <mmorrow> i haven't had a chance to build it yet, just got back from dinner
19:54:08 <mmorrow> videos!?!
19:54:20 <pumpkin> I don't have the gtk shebang installed at all
19:54:34 <pumpkin> http://www.youtube.com/user/donsbot
19:54:38 <gwern> mmorrow: youtube, even
19:54:40 <mmorrow> ah, just saw the gtk dep, me neither
19:54:45 <mmorrow> i should build it though
19:55:00 <mmorrow> sweet, /me looks
19:56:10 * Saizan_ imagines the new generation porn: videos of raw memory straight from the kernel
19:56:27 <gwern> no one's that kinky
19:56:28 <ddarius> Saizan needs to get a life.
19:56:46 <wli> heh
19:57:07 <Saizan_> i've just came back from my life, that's why i'm that prone to compromsing statements
19:57:24 <jbapple> mmorrow: Let us know if you get it working
19:59:12 <pumpkin> oh noes, not life
19:59:59 <mmorrow> jbapple: will do
20:00:15 <mmorrow> jbapple: nice to see you here, it's been a while :)
20:00:26 <kohwj> anyone manage to install template-haskell from cabal?
20:00:37 <kohwj> using ghc 6.10.1
20:01:24 <edwardk> hrmm. it looks like my little data compression algorithms as data structures approach thing is easier to implement than I thought.
20:01:26 <Saizan__> let's see
20:01:38 <conal> edwardk: woot!
20:01:41 <ddarius> edwardk: Dammit, I hate when that happens.
20:01:41 <mmorrow> kohwj: from my experience installing a template-haskell that didn't come with ghc usually ends in bad news
20:01:46 <edwardk> conal: http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Generator-LZ78.html
20:02:23 <conal> edwardk: geez -- elegant.
20:02:26 <kohwj> mmorrow: it has issues with the version of base it uses
20:02:40 <edwardk> i have another one i'm getting ready to add for Bentley-McIlroy, so the LZ78 compressor can recycle monoids locally, and the Bentley-McIlroy one compresses in the large
20:02:43 <BMeph> gwern: Rule 34 says otherwise. :)
20:02:57 <NameAlreadyInUse> is anyone here familiar with the SDL bindings on hackage?
20:03:02 <edwardk> then it becomes cheaper to parse compressed data than uncompressed data
20:04:01 <jbapple> mmorrow: thanks. it was vacuum&cairo that brought me back
20:04:03 <conal> edwardk: sounds great.
20:04:20 <wli> I forget how to beat LZ in offline apps.
20:04:27 <Saizan__> kohwj: yeah, you need to add base == 4.* to the .cabal file
20:04:41 <edwardk> now if i could only figure out why i can't commit to this darcs repo =/
20:06:04 <mmorrow> jbapple: nice
20:06:04 <Saizan__> kohwj: or pass --constraint="base == 4.*"
20:07:11 <kohwj> Saizan__: sudo cabal --constraint="base == 4.*" install happs-server
20:07:12 <kohwj> ?
20:07:13 <Saizan__> edwardk: slap it to submission
20:07:19 <mmorrow> kohwj: just be aware that installing a newer TH could break everything
20:07:32 <edwardk> Saizan__: trying to ;)
20:07:37 <mmorrow> (it might work though)
20:07:48 <edwardk> i think the repo i'm coming from got corrupted some how
20:07:49 <Saizan__> kohwj: i've only tested template-haskell, but it should work too
20:08:29 <Saizan__> kohwj: i've testet it from the unpacked source
20:08:31 <mmorrow> the issue is that template-haskell makes (hard-coded) assumptions about where certain stuff is (e.g. Bool)
20:09:01 <mmorrow> so if those locations happen to still be the same with the new TH as they are in your ghc, you're ok
20:09:11 <mmorrow> if not..
20:09:12 <Saizan__> but the version on hackage should be the same as 6.10.1
20:09:21 <mmorrow> nice, you should be good then
20:10:20 <kohwj> Saizan__: yup, i can get installed from source, but cabal doesn't know that it has been installed when i install stuff that depend on it
20:10:51 <dolio> @tell Heffalump I released a new logict (0.3) that removed the Applicative instance. Could you let me know if there are any other problems (or how to check for myself)?
20:10:51 <lambdabot> Consider it noted.
20:10:55 <Saizan__> kohwj: that's weird? what's the full error? hpaste.org
20:12:58 <edwardk> dolio: that reminds me i need to go figure out what the policy is on max package versions and figure out what i should set those to for category-extras and monoids
20:13:29 <dolio> Anything less than 1.0. :)
20:13:39 * Saizan__ spreads sugar upper bounds for everyone
20:14:19 <Saizan__> x.* or x.y.* is the preferred standard, i think
20:14:57 <edwardk> saizan: i just have like 10 different pre-reqs right now and honestly never looked to see what the versions i currently use are ;)
20:15:31 <kohwj> Saizan__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3032#a3033
20:15:40 <Saizan__> your packages are doomed.
20:16:15 <edwardk> hah
20:17:25 <Saizan__> kohwj: ok, to build template-haskell you need --constraint="base == 4.*", but to build happs-server it should pick your installed template-haskell
20:18:10 * wli tears his hair out trying to divine a "theory of modules" analogous to lambdacalc for term expressions.
20:18:43 <Saizan__> kohwj: btw, best to use cabal install --global --root-cmd=sudo
20:19:57 <edwardk> wli: there are a few floating around in ML circles.
20:20:42 <edwardk> robert harper wrote up a bunch of stuff. xavier leroy has that reusable module design, etc.
20:20:47 <wli> edwardk: Any survey papers not hidden behind ACM roadblocks?
20:20:51 <kohwj> Saizan__: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3034#a3034  no difference
20:21:08 <edwardk> wli: no idea. i just pony up the cash for ACM every year ;)
20:21:38 <Saizan__> kohwj: cabal --version?
20:22:03 <kohwj> cabal-install version 0.6.0 using version 1.6.0.1 of the Cabal librar
20:22:42 <Saizan__> kohwj: ah, you need to upgrade it, "cabal install cabal-install"
20:23:11 * BMeph prefers the perks of his uni ponying up for IEEE and ACM library privs
20:23:23 <Saizan__> kohwj: add Cabal there, if you want
20:23:59 <dolio> If you're doing modules, you should do MixML modules.
20:24:01 <edwardk> BMeph: as a non-academic i've since lost those privileges
20:24:29 <wli> dolio: Remind me what MixML does again.
20:24:40 <eu-prleu-peupeu> hi
20:24:44 <Saizan__> using uni's proxy for papers is essentially the only way i use my taxes
20:24:50 <BMeph> edwardk: Ah, but is your employer doing something similar? Something to check into... ;)
20:24:51 <kohwj> Saizan__: ok, i've upgraded cabal-install and Cabal is the latest version
20:24:54 <eu-prleu-peupeu> just got back from this crazy night, with some crazy girls
20:25:00 <dolio> ML-like modules with recursion and separate compilation.
20:25:16 <kohwj> sudo cabal install happs-server still wants to install template-haskell even though i already have
20:25:42 <gwern> BMeph: rule 34 merely claims the existence of such porn, not the existence of anyone so gratified
20:25:44 <Saizan__> kohwj: cabal install happs-server? without sudo?
20:25:58 <dolio> @go Mixin' Up the ML Module System
20:25:59 <gwern> because rule 34 is illegimitate; it's the internet's axiom of choice
20:26:00 <lambdabot> http://www.mpi-sws.org/~rossberg/papers/Dreyer,%20Rossberg%20-%20Mixin'%20Up%20the%20ML%20Module%20System.pdf
20:26:00 <lambdabot> Title: Mixin’ Up the ML Module System
20:26:09 <gwern> *besides
20:26:14 <kohwj> Saizan__: permission denied
20:26:16 <wli> dolio: I regard those sorts of things as obligatory, but it's an interpreter, so there's not much meaningful I can do wrt. separate compilation.
20:26:30 <kohwj> Saizan__: i have an urge to delete ~/.cabal
20:26:41 <dolio> Well, nevertheless, that paper goes into a somewhat theoretical basis for their modules.
20:26:51 <Saizan__> kohwj: it's not a big lost anyway
20:26:57 <kohwj> Saizan__: indeed
20:27:18 <kohwj> Saizan__: hey are you serious that it's ok?
20:27:26 <gwern> wli: an interpreter? this sounds like a job for - futamura projection man!
20:27:32 <gwern> @quote futamura
20:27:32 <lambdabot> gwern says: good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!
20:27:41 <Saizan__> kohwj: make sure to rerun cabal update afterwars
20:27:48 <BMeph> gwern: I imagined Saizan__'s active imagination was proff enough of "the existence of anyone so gratified". ;p
20:27:52 <kohwj> Saizan__: ok. thanks!
20:27:55 <BMeph> *proof
20:28:05 <gwern> BMeph: I demand a constructive proof!
20:28:13 <Saizan__> kohwj: and i still recommend "cabal install --global --root-cmd=sudo" instead of "sudo cabal install"
20:28:57 <Saizan__> hey, who spread the news about my active imagination?
20:28:59 * BMeph constructs a proof from the logs of #haskell
20:29:15 <kohwj> Saizan__: i only have one user account
20:29:40 <BMeph> Saizan__: " * Saizan_ imagines the new generation porn: videos of raw memory straight from the kernel" <-- uh, "who" == you. ;)
20:29:57 <gwern> one of the things I like about futamura is that it looks like futurama
20:29:58 <kohwj> Saizan__: that i use regularly.. so i'm ok if it's all local
20:30:35 <Saizan__> kohwj: why sudo then?
20:30:42 <kohwj> early mistake
20:30:52 <kohwj> oops, now cabal upgrade is hogging my cpus
20:30:54 <wli> dolio: um... for some reason this looks drastically more complex than I envisioned it was possible to be.
20:31:05 <dolio> Heh.
20:31:18 <Saizan__> not upgrade, update, but 0.6.0 shouldn't have that bug..
20:31:19 <gwern> kohwj: no, don't use cabal upgrade!
20:31:35 <Saizan__> kohwj: are you sure you don't have an older cabal-install around?
20:31:43 <kohwj> gwern: on a fresh ~/.cabal?
20:31:44 <dolio> Well you can take dependent records as your basis for modules like Agda (I think) does.
20:31:48 <kohwj> oops.
20:32:06 <dolio> But that probably won't handle (mutally) recursive modules gracefully.
20:34:03 <wli> dolio: my general thought on the subject is just to defer anything that wants to drag in a module not provided as an immediate argument into the linking process.
20:34:55 <kohwj> Saizan__: darn, i do have an old cabal-install
20:36:02 <Saizan__> kohwj: looping on 6.10.1 is a bug in the 0.5.x version
20:36:20 <kohwj> Saizan__: i see
20:39:07 <wli> dolio: Basically just collect constraints, grind them down using what you've got access to, store the results, and then slurp them back in and resume when passed to a linking phase of the compiler.
20:40:19 <edwardk> BMeph: nah, they aren't terribly academic at heart ;)
20:43:26 <wli> dolio: The typing rules for MixML are nightmarish.
20:46:57 <dolio> I never read that far.
20:49:47 <wli> The expanded online report seems to be referred to.
20:51:05 <NameAlreadyInUse> does anyone know why "windowSetResizable ... False" might snap the window to minimum size in Gtk2Hs?
20:58:21 <wli> What you can generally do is say what your dependencies are, what you absolutely require from them, what you export, and some descriptions of what you export.
21:01:08 <wli> So the question is whether you're doing this with or without information from having preprocessed dependencies. If it's a recursive dependency on itself with no intermediaries, no problem. If there are intermediaries not yet preprocessed, you're stuck bootstrapping and have to fix up whatever's getting bootstrapped "later," e.g. when everything's passed at once during link phases.
21:04:19 <wli> In an interpreter, you just load files as you need them. If you hit a cycle, you've already got the file loaded, so you just reuse whatever you've got from there. IOW interpreters sans persistent bytecode (or more) don't have separate compilation anyway.
21:05:48 <haro1> hi, i'm wondering if someone devised a way of defining a sufficiently complex or large set of function names so that one can feed a haskell interpreter another programming language , and make it run
21:06:31 <jmcarthur> haro1: you mean like a DSL, or like an actual interpreter written in Haskell?
21:06:39 <jbapple> haro1: http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html
21:06:58 <jmcarthur> +1 for that one
21:07:20 <haro1> jbapple: that look amazing
21:07:25 <haro1> looks
21:07:41 <haro1> jmcarthur: maybe like a DSL
21:08:09 <jmcarthur> haro1: in that case i would have probably linked to the same thing
21:08:26 <haro1> the language i'd like to interpret would be dbase III
21:08:28 <jmcarthur> haro1: although you could also just pass a string to an interpreter function, of course
21:08:36 * jmcarthur looks up dbase III
21:08:51 <haro1> jmcarthur: it's very old
21:09:02 <haro1> jmcarthur: and proprietary
21:09:54 <conal> sounds sort of like how denotational semantics works.  -- a purely functional interpreter for another programming language.
21:10:03 <haro1> but dbase III would be just an example , the ideas you provided look like the path i'd need to go
21:10:14 <haro1> conal: yes
21:10:30 <brool> is there any reason for mutable array creation to be O(n)?  I'm getting really strange benchmark results, and have the feeling it's just something stupid.  Example is here:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3035#a3035
21:11:04 <jmcarthur> brool: it should be O(n), yes
21:11:13 <jmcarthur> brool: an array has to be allocated all at once
21:14:57 <brool> jmcarthur: of course you're right.  array creation seems really slow, though.
21:15:13 <jmcarthur> your numbers do seem high to me
21:15:26 <jmcarthur> just not the time complexity
21:16:42 <Axman6> brool: where are you running it?
21:16:59 <brool> Axman6: GHC 6.10 / Mac
21:17:11 <Axman6> ghci or compiled?
21:17:17 <brool> compiled -O2
21:17:31 <Axman6> yeah, those numbers seem extremely strange then
21:17:35 <Axman6> profiled it?
21:17:49 <brool> yes -- it tells me that all the time is spent in makeArray :-)
21:18:46 <brool> newArray, rather
21:19:19 <Axman6> what about with much larger numbers?
21:19:45 <brool> they scale about linearly -- 100 elements takes about 44 seconds
21:19:50 <Axman6> like (0,1000)
21:20:03 <jbapple> There actually is a way to allocate mutable arrays of size n in in O(1) time
21:20:08 <Axman6> that's... broken, and not something i've ever experienced before
21:20:10 <jbapple> Lemme dig up a link . . . .
21:20:36 <jmcarthur> yeah, i've never seen that
21:20:58 <Axman6> i've created much larger arrays before and it's always been very fast
21:21:06 <gwern> 'Law 8 (Haskell version): Any sufficiently advanced type system includes an incomplete and twisted subset of Scheme' ouch
21:21:19 <jbapple> Well, not allocate
21:21:22 <jbapple> initialize
21:21:26 <jbapple> http://eli.thegreenplace.net/2008/08/23/initializing-an-array-in-constant-time/
21:24:17 <brool> Any suggestions for best way to track it down?  The best i can come up with is combing through C output
21:24:18 <wli> What is the array for?
21:24:53 <wli> The kernel won't let you get at fresh memory in constant time; it zeroes it all out. OTOH it lazily fills it in.
21:25:07 <brool> wli: Well, it was a text analysis program -- was using the array for letter counts -- but stripped it down to try and narrow down why it was slow
21:25:47 <wli> brool: What do indices and entries look like?
21:26:09 <wli> brool: Is it like a 3D 256x256x256 array for triples of chars?
21:26:39 <brool> wli: no, it was single dimension character frequencies -- UArray Word8 Int
21:27:04 <jbapple> wli: lazily? That seems very sophisticated.
21:27:07 <wli> brool: Are you creating these repetitively?
21:27:23 <wli> jbapple: yes, it's called "zero fill on demand" (ZFOD)
21:27:35 <brool> wli: yah, once per line of text -- about 300k lines in the test file
21:27:53 <Axman6> hmm
21:28:03 <sundaymorning> wli: I think it zeroes it out as it is actually requested. I mean, you allocated 100MB, only when you actually access some of that memory the kernel will zero it out.
21:28:06 <Axman6> lots of allocation going on there
21:28:12 <wli> brool: How many entries are typically 0?
21:28:18 <sundaymorning> so allocation should happen in nearly constant time
21:28:34 <brool> wli: most of them, probably
21:29:21 <wli> sundaymorning: You're right about zeroing it out as requested. Amortized cost OTOH is still the same as zeroing out every page touched up-front.
21:29:57 <sundaymorning> if you access all the pages, then yes
21:30:04 <brool> As a point of comparison, the Ocaml one is much faster -- and I narrowed it down to this.  On everything else the Haskell optimizer is amazing.
21:30:36 <wli> brool: What do you do with all these arrays when you're done with them?
21:31:04 <wli> brool: Do you e.g. add them up?
21:31:23 <brool> wli: no -- lines that meet certain frequency patterns are extracted
21:32:00 <wli> brool: What kinds of frequency patterns?
21:34:14 <brool> wli: it's looking for outliers in frequencies.  tbh it's not immensely useful, just a small program I had around and wanted to rewrite
21:34:15 <wli> brool: Do you know the frequency patterns in advance or do you have to compute statistics on all the lines etc.?
21:35:42 <brool> wli: the frequency patterns are known in advance, so the lines can be rejected as soon as they're read, and the memory usage of the program is pretty constant at 1M.
21:35:58 <wli> brool: I suspect you might want to use IOUArray to handle array updates, otherwise it allocates a fresh one for every char.
21:36:32 <wli> brool: With frequency patterns known in advance you should literally only ever need as many arrays as identified outliers.
21:37:37 <wli> brool: I suspect you don't modify them so you can probably just keep the scope of the mutability down to processing a single line.
21:37:54 <brool> i have to create a new array on every line, though -- and it looks like that's expensive
21:38:32 <wli> You can let the IOUArray ops span the whole affair and just re-zero it after every line.
21:39:12 <brool> so avoid construction/destruction, just zero it?  what is the closest equivalent to memset?
21:39:34 <ivanm> @uptime
21:39:34 <lambdabot> uptime: 4d 14h 55m 3s, longest uptime: 1m 10d 23h 44m 29s
21:39:49 <ivanm> what's going on? I thought lambdabot was meant to crash every second day :s
21:39:50 <ivanm> ;-)
21:40:19 <wli> brool: getBounds a >>= \(firstIdx, lastIdx) -> mapM_ (\k -> writeArray a k 0) [firstIdx .. lastIdx]
21:41:08 <brool> wli: okay, i'll try that, thanks
21:41:48 <wli> Just do the whole thing in the IO monad. You'll then know you're not allocating unless you explicitly call newArray or newArray_
21:43:28 <edwardk> ah woot, lz78 encoder done
21:43:32 <wli> brool: It would probably need some kind of region analysis to deal with this.
21:43:38 <wli> edwardk: holy cow you're fast
21:43:53 <edwardk> wli: http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Generator-LZ78.html -- added the encoder and quickcheck
21:44:43 <edwardk> wli: so if you have a lot of redundant data to work with you can 'reduce . encode' to dump it through a monoid, reusing monoids from earlier partial parses
21:45:37 <edwardk> it didn't wind up nearly as much code as i thought, the encoder is about as clear as the decoder
21:47:13 <wli> wow
21:47:44 <bsb_> hi, I'm new to Haskell but would like to mentioned on thing I miss from other P/Ls: longer examples in the documentation
21:48:03 <edwardk> it doesn't prune the dictionary at all, but since its intended for when you really want to recycle monoids and not for compression its still handy
21:48:34 <bsb_> it might be because I'm new, but I find it quite hard to penetrate the docs
21:48:59 <edwardk> i may add some logic to use Data.LRU to manage the contents of the Seq used by the decoder and the Map used by the encoder
21:49:37 <bsb_> is there are cultural reason for the missing examples?  or will I eventually reach type-enlightenement and not need them?
21:49:42 <edwardk> bsb: there are long tutorials out on the internet and some good books, but yeah in general haskell docs tend to be very terse from the 'how to use it' perspective
21:50:49 <brool> wli: re-initializing it instead of doing a newArray on every line brought it down about two magnitudes, thanks very much
21:52:16 <bsb_> edwardk: I've done lot's of tutorials, and found real work haskell excellent, but...
21:52:54 <bsb_> there were things explained in RWH that I could never have understood or known from a modules docs
21:53:45 <ant__> the only thing i recall from RWH is 'beware of fail'
21:53:49 <ant__> thats the only thing i learned tbh
21:55:10 <bsb_> a few examples from RWH that gave me "A-ha!" moments were Arrows, `on`, various concurrency things
21:55:37 <bsb_> also the various Array types
21:56:09 * Axman6 needs to read more rwh sometime
21:56:11 <wli> brool: Very cool. Let the channel know if it needs more speedups (e.g. is not yet as fast as or faster than ocaml).
21:56:46 <edwardk> wli: added a slower encoder that can use lists so you can get away with an Eq instance alone
21:57:08 <edwardk> bsb_: i'm as guilty as anyone of the general lack of usage-oriented documentation
21:58:46 <bsb_> do others just understand it, read the source or ..?
21:58:52 <wli> brool: Are you using bytestring?
21:59:12 <ivanm> Axman6: :o
21:59:23 <edwardk> bsb_: some puzzle through, some give up, some go write better documentation ;)
21:59:32 <edwardk> some come on channel and ask =)
21:59:52 * wli is reading about MixML's module system.
22:01:15 <kohwj> ok, i cleaned out my system of all haskell stuff, am using ghc 6.10.1, cabal 1.6.0.1 and cabal-install 0.6. "cabal install --constraint="base == 4.*" template-haskell" still doesn't work
22:02:29 <ivanm> kohwj: ummm.... why are you using --constraint ?
22:02:42 <kohwj> ivanm: because someone here told me to...
22:02:46 <ivanm> I've only ever used that for packages that don't know about base=4, and I've had to force base<4 :s
22:02:50 <ivanm> hmmm...
22:03:15 <kohwj> ivanm: doesn't work without the constraint either
22:03:51 <wli> Type signatures, type locators, import realizers, and module contexts are all fuzzy to me. Actually also what the difference between a module signature and a unit signature.
22:04:05 <brool> wli: yah, did that early on, it helped quite a bit
22:04:26 <ivanm> kohwj: what actual error do you get?
22:04:45 <kohwj> ivanm: hold on, i'll try something first...
22:04:47 <ivanm> wli: isn't a type signature the whole "a -> b -> c" stuff?
22:05:53 <bsb_> I'm now looking at NLP.WordNet and don't know where to start...
22:06:47 <bsb_> (I'm from a perl and unix background, used to the terse man pages and spoilt by the verbose cpan SYNOPSIS sections)
22:08:23 <bsb_> If hackage had an Examples wiki, then the "how does this thing work?" problem only need to be solved once...
22:12:40 <kohwj> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3036#a3036
22:13:09 <kohwj> ivanm: manually installing and editing the .cabal file works though
22:13:21 <wli> ivanm: Type substitutions, sorry. Somehow something called "type substitutions" are part of the MixML module language as a "semantic object.:
22:13:31 <kohwj> ivanm: but then cabal doesn't know that it's been installed
22:20:32 <ivanm> kohwj: it might work with --constraint="base < 4"
22:21:30 <kohwj> ivanm: like "cabal install --constraint="base < 4" template-haskell"?
22:21:37 <ivanm> yeah
22:27:20 <wli> ah, type substitutions are like type parameters passed to functors
22:28:55 <nolrai_East> I want a "forM" that works on Maps, how do I do this?
22:29:16 <wli> Data.Traversable and/or Data.Foldable
22:29:42 <nolrai_East> Thanks!
22:30:41 <wli> I think I'm getting more of the paper.
22:35:01 <wli> Rules 25, 26, and 29 are getting hairy.
22:35:13 <wli> 30 is the worst, though.
22:43:37 <kohwj> ivanm: nope, didn't work
22:49:18 * Hunner sees "an haskell" written around, and wonders if people don't pronounce the h?
22:50:21 <jeffwheeler> I like "Askell, don't ask"
22:50:45 <nolrai_East> some people put an before h always.
22:50:45 <dolio> Some people say stuff like "an historical ..." too. Never understood it myself.
22:51:37 <Hunner> oh good. I didn't want to have to change my pronunciation, personally
22:53:09 <nolrai_East> Is there a better way to write "liftM2 f m (return b)"?
22:53:30 <Zao> Hunner: There were a long thread on -cafe about how to pronounce it.
22:54:11 <Zao> There were even a sound clip linked with SPJ pronouncing it. :)
22:54:25 <Zao> His pronounciation should be able to be heard in the xmonad presentations.
22:54:38 <wli> nolrai_East: liftM f m b?
22:57:06 <wli> @type liftM (+) (return 1) 2
22:57:07 <lambdabot> forall a1. (Num a1) => a1 -> a1
22:58:14 <BMeph> From what I recall, it's a Cockney (English accent) thing to drop the "h" sound. At least, that's what I got from seeing "My Fair Lady". ;)
22:58:39 <pumpkin> I know some french people who tend to put an in front of H
22:58:45 <pumpkin> because they typically don't pronounce the H
23:00:26 <ozy`> BMeph: cockney, and french (hence "an historical...")
23:07:49 <jmcarthur> i know some people who pronounce the h who still put an in front of it
23:09:25 <wli> nolrai_East: m >>= flip f b
23:09:53 <wli> nolrai_East: m >>= return . flip f b
23:11:06 <BMeph> HEh-heh...
23:11:31 <BMeph> @remember jfredett I do all of my version numbers in Roman Numerals...
23:11:31 <lambdabot> Nice!
23:12:41 <Mr_Giraffe> :t flip (>>=)
23:12:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
23:14:10 <dobblego> :t (=<<)
23:14:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
23:22:57 <wli> flip (((((flip (.)) flip) . (.)) . ((flip (.)) (return .))) . (>>=)) is not what I'd call clarified
23:23:43 <wli> @pl \f m b -> m >>= return . flip f b
23:23:43 <lambdabot> flip ((.) . (>>=)) . ((return .) .) . flip
23:24:05 <wli> At least there's no use of ap.
23:33:39 * BMeph likes ap. He finds it...apt...at times.
23:35:13 <ivanm> kohwj: :(
23:35:30 <kohwj> ivanm: it's ok, TH isn't critical at the moment
23:35:38 <kohwj> ivanm: i've emailed the author about it
23:36:00 <ivanm> good-o
23:49:25 <wli> I'm not entirely sure what these guys are up to.
23:50:09 <wli> Leroy's paper seems to suggest they're doing something vaguely analogous to recursive descent parsing wrt. module typechecking.
23:59:36 <dons> jbapple: do you have 'dot' installed?
