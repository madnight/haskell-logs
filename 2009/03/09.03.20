00:00:42 <edwardk> line pragmas, etc fit the model cleanly
00:00:44 <wli> To me it sounds like that's a matter of undoing derivations around the edit sites and recapitulating the derivation process.
00:01:00 <wli> Focused around the edit sites.
00:01:13 <edwardk> yeah basically. i'm just using the monoids to make that rigorous
00:01:34 <wli> I have to think through the specifics of the process a bit more.
00:01:50 <edwardk> and groups, groups are even better than monoids because you can 'subtract' directly rather than re-add
00:02:31 <edwardk> i was using these in a distributed database project for a while, and got somewhat addicted to various map/reduce style primitives ;)
00:02:46 * edwardk wants to bring the bag of tricks to bear here
00:02:53 <wli> edwardk: This is very useful in a number of contexts.
00:03:12 <quicksilver> edwardk: are common grammars associative, though?
00:03:28 <quicksilver> edwardk: I appreciate that if they are, that helps what you're trying to do.
00:03:50 <wli> edwardk: I can't understand much more than using LBA's for this.
00:05:41 <Baughn> Is it possible to ask haskell what the real type of an arbitrary exception is? I mean, SomeException has to be storing the real type somewhere for catchJust and such to work, right?
00:05:58 <edwardk> quicksilver: what you need is a tool for parsing pieces of them that is. i need the 'defunctionalized parser' to be associative, basically you need an structural representation of what you've partially recognized that you can concatenate with another
00:06:13 <Baughn> ..well, not catchJust, but you get my point
00:06:14 <edwardk> quicksilver: the grammar can be all over the place
00:06:45 <edwardk> quicksilver: but it helps if its got a nice structure to it, otherwise you won't win anything ;)
00:07:04 <wli> edwardk: This sounds like sentential forms (strings of mixtures of terminals and nonterminals).
00:08:04 <wli> edwardk: Maybe you mean that nonterminals must carry around the parse trees for carrying out productions on-demand?
00:08:07 <quicksilver> edwardk: I appreciate the domain of associativity isn't as naive as "the language being associative"
00:08:19 <edwardk> quicksilver: fair enough =)
00:08:26 <quicksilver> edwardk: but there has to be a way to decompose the grammar associatively for a monoidal composition to have meaning.
00:08:36 <quicksilver> monoidal decomposition, rather
00:08:54 <edwardk> yeah
00:08:55 <wli> edwardk: One part of this that's stumping me is that edits operate on the underlying stream of terminals, which I don't have any idea how to map to where the nonterminals are in this process.
00:09:19 <quicksilver> edwardk: of course if your language *was* associative (concatenative) it would be trivial :)
00:09:26 <edwardk> quicksilver: in my case my grammar is pretty consistent, the biggest bugaboo i have to fight with is layout, everything else can pretty clearly parse any which way
00:09:35 <quicksilver> but whilst Joy is a very cool language it's not one I use for real programs.
00:10:38 <edwardk> but i can at least parse out indentation into nested scopes and spot layout opening rules, and try to pair down part of the stack so i don't need to know the whole layout stack
00:10:46 <wli> For my vastly cruder notions of what's going on, I'm guessing you would have to index the input stream with some sort of mapping to what nonterminals got derived from it.
00:12:02 <wli> Something like the least common ancestor in the parse tree of all of the consecutive modified nonterminals.
00:12:24 <edwardk> wli: right now i'm basically taking the input file chunking it up into bytestrings and loading those bytestrings into a fingertree.
00:13:31 <edwardk> the fingertree glues together a bunch of monoids about the source file, a filename/line #/column # monoid, a byte count monoid, a convert-utf8-to-characters-monoid-so-i-can-parse-chars-with-a-CharMonoid-monoid
00:14:14 <wli> I'm not sure precisely what you do when that least common ancestor deriving to something else forces different derivations in its ancestors in the parse tree. My wild guess is that you have to start unwinding productions up there, too.
00:14:31 <edwardk> wli: right now all i'm doing is the lexing phase.
00:14:39 <edwardk> wli: parsing over the top of that is another story
00:14:54 <wli> edwardk: You've got me interested in the more general problem now.
00:16:42 <wli> Yeah, I think you have to unwind the derivations around the least common ancestor in the parse tree until the entire input consists of a flat sentential form containing that least common ancestor in the parse tree directly "at the top".
00:17:35 <edwardk> wli: the problem i'm currently toying with is what does it take to write an 'alex' for monoidal lexing? you can glue together regexps to make a big one. i did that for a cpan module back in the day using tries, then you can transform that into a monoid, but i'm afraid that approach will be dreadfully naive
00:17:38 <wli> This gets more interesting when you've got multiple simultaneous edit sites.
00:18:11 <edwardk> well, in the fingertree setting, not so much, coz each of those edits should cost you something O (log n)
00:18:30 <edwardk> assuming you have an efficient glue for your monoid
00:19:27 <wli> edwardk: I'm clueless as to what you even mean by monoidal lexing/parsing. At this point I'm just rambling about how to carry out the task of re-parsing in the presence of updates to the middle of the input stream.
00:20:09 <edwardk> wli: comfortable with what a monoid is?
00:20:39 <aye_I_ken_the_wy> can  a unix admin liek me become a programmer by learning haskell at home?
00:20:47 <edwardk> wli: just some random associative operation with a unit, right?
00:21:07 <edwardk> aye_I_ken_the_wy: stranger things have happened ;)
00:21:22 <edwardk> to be fair, i think haskell is very accessible
00:22:39 <johnw> aye_I_ken_the_wy: i really don't see why not, some of us learned programming as kids at home, so why can't an experienced admin?
00:23:28 <aye_I_ken_the_wy> awesome!!
00:23:32 <aye_I_ken_the_wy> good night gents
00:23:38 <aye_I_ken_the_wy> I can fall asleep happy now
00:23:47 <edwardk> wli: so in the context of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2626#a2626 all you need to do is take that Monoid and run it with Pos "-Data.Foldable.foldMap delta over a list of chars and it nets you th
00:23:48 <johnw> good luck, aye_I_ken_the_wy  :)
00:23:49 <edwardk> er
00:24:10 <edwardk> Pos "-" 0 0 . Data.Foldable.foldMap delta
00:24:17 <edwardk> and er
00:24:22 <wli> yeah
00:24:27 <edwardk> Pos "-" 0 0 `mappend` Data.Foldable.foldMap delta
00:24:28 <edwardk> =)
00:24:41 <edwardk> you get the idea
00:24:51 <wli> The leap from monoid to whatever else you're doing is what's getting me, not what monoids are.
00:25:55 <edwardk> similarly you can take that Words monoid i pasted earlier and do the same thing. now, if you did that on two chunks of the file, then glued them together with mappend you'd get the same answer.
00:27:21 <edwardk> a fingertree just keeps track of some monoid over its members as it balances things out. if you go to insert into the middle of the tree it just has to recalculate its way back up the tree
00:28:16 <edwardk> so take the monoid, and a fingertree of your source file you get a result in your monoid, produce a modified finger tree and you get the modified monoidal value
00:28:26 <edwardk> its not all that deep
00:28:39 <edwardk> just a handful of funny monoids
00:32:14 <edwardk> sigfpe used a monoid that mapped the integers from 0 .. n onto the integers from 0 .. n to represent the result of having exposed a state machine in the starting state to some sequence of inputs, yielding a set of output states for each potential input state. so then each potential value you could expose the machine to gets mapped to a function representing how it would affect any input state.
00:34:18 <edwardk> that had the benefit that the amount of time it takes to concatenate two strings you are matching against is proportional to the number of states in the machine, not to the size of the strings you are concatenating. its still at least n + 1 times worse than doing it the straightforward way though until you have the finger tree remembering your current state and making slight modifications cheaper
00:35:43 <wli> This sounds applicable to FSM's only.
00:36:08 <edwardk>  that approach is, but thats not the only monoid you can use ;)
00:36:53 <edwardk> as long as you are just digesting some information from the source you can usually represent the information content in a much more compact manner than the source ;) http://blog.sigfpe.com/2009/01/beyond-regular-expressions-more.html
00:38:39 <wli> edwardk: I think I'm starting from the assumption of DCFG's and screaming every time the class of grammars gets hobbled just like with LL vs. LR.
00:40:49 <edwardk> wli: in my case my lexemes are pretty straightforward to recognize, i have to deal with balanced parens, braces, and layout rules immediately after certain keywords, and i have a few context sensitive locations where i need to parse differently depending on if i have space around a given lexeme. other than that its all operator precedence reduction and generating some fairly exhaustive logic when classes get instant
00:41:38 <wli> edwardk: I've been thinking about parsing at repl's for a long time. I got inspired by zsh doing several intersting things simultaneously.
00:42:51 <wli> edwardk: The first is multiline inputs are handled by figuring out if you've entered in something that parses completely at a linebreak. When you scroll through the history, it even has the multiline inputs' forms preserved to be edited as single commands etc.
00:43:25 <wli> edwardk: Then it gets better. When you hammer in linebreaks it changes the prompt to reflect the stack of nested constructs you're in the midst of.
00:43:49 <edwardk> ah good point
00:45:13 <wli> edwardk: The way zsh actually does it is all hand-coded hackery. I've been thinking about how similar things could be done with any sort of rigorous reasoning about it since I first saw zsh (1993? 1994?).
00:45:16 <edwardk> i'd forgotten about the subsh and cursh prompt bits
00:45:52 <wli> Try this, with linebreaks matching:
00:45:57 <wli> for f in *
00:45:58 <wli> do
00:46:02 <wli> echo $f
00:46:16 <wli> if [ -x $f ]
00:46:17 <wli> then
00:46:25 <wli> echo "$f is executable"
00:46:26 <wli> fi
00:46:29 <wli> done
00:47:03 <wli> You'll see it prompts during the span of the nested for and if with for> and for if>
00:47:08 <edwardk> yeah
00:48:05 * edwardk is trying to figure out how i can borrow the idea for the kata repl ;)
00:48:09 <edwardk> its trickier with layout
00:48:16 <edwardk> because i can usually end lexing any time
00:48:20 <edwardk> no terminal tokens
00:48:28 <Gracenotes> omnomnom
00:48:47 <edwardk> i think it would be nice to track free variables though, so you could say something like
00:48:55 <edwardk> foo x y z = x' where
00:49:01 <wli> Another trick is figuring out what pool of potential tab completions to use based on parsing state.
00:49:03 <edwardk> and have it prompt you with the fact that you need to define x'
00:49:49 <edwardk> yeah, i'm stuck heading down into domain-specific hell there ;)
00:50:30 <NameAlreadyInUse> what is the point of a modal window that spawns behind the application?
00:50:43 <edwardk> advertisements? ;)
00:50:49 <Gracenotes> > let foo x y = ?x' in 0
00:50:51 <lambdabot>   0
00:51:03 <Gracenotes> is there some way to make the in <expr> use foo somehow?
00:51:04 * cizra hates modal windows
00:51:08 <wli> LR parsers make that easy because they literally have lists of terminal symbols (which really correspond to types of tokens vs. specific hard tokens in most cases, but..) in their dispatch tables you can just use right off the bat to form a set of classes of tokens over which to carry out completions.
00:51:09 <NameAlreadyInUse> edwardk: but why? there is no way for you to reach the modal window
00:51:11 <cizra> They're too often used wrong.
00:51:17 <Gracenotes> with some alternate definition of foo, maybe?
00:51:27 <NameAlreadyInUse> cizra: i'll say
00:51:27 <edwardk> ah touche, modal. missed that ;)
00:51:53 <NameAlreadyInUse> cizra: i have had to terminate an application 3 times today because the modal dialog for "new update" spawns behind the main window
00:52:17 <wli> edwardk: Also, a brutal limitation with interactive input is zero lookahead. LL(k) for k > 0 is not possible, and LL(0) is quite weak, so things get rather brutal on that front.
00:53:46 <edwardk> i'm willing to have the interactive input thing give you only educated guesses
00:53:50 <wli> edwardk: My big thought is using Tomita's algorithm (the one which transforms LR(1) parsers into GLR, and other shift/reduce parsing algorithms to things with no names) on LR(0).
00:54:28 <wli> edwardk: But that's what I was just railing against with zsh: all the ad hoc.
01:02:43 <wli> LR(0) has substantial weaknesses, so the thought was to apply Tomita to it to get a broader class of grammars.
01:03:48 <wli> edwardk: Now the part where this gets interesting is when I try to do all this with multistage parsing, i.e. fixity decls and user-declared infix/etc. ops.
01:04:24 <andrey_nado> Hello! Could anybody explain what's wrong with my super function?
01:04:35 <edwardk> wli: well, finding fixity decls can be done cheaply in this setting, its applying them later
01:04:55 <wli> edwardk: You mean the monoidal setting?
01:05:08 <edwardk> yeah
01:05:20 <edwardk> my golden hammer of the last 8 hours or so
01:05:46 <wli> edwardk: I think I've gone off in a different direction while never actually figuring out what this monoidal parsing is.
01:05:59 <wli> (i.e. the weeds)
01:06:05 <edwardk> sok
01:06:24 <mofmog> so... i understand why bind takes a function (a -> m b) because bind is sort of like fmap and because it lets you compose functions
01:06:28 <edwardk> i'm beating my head against my utf-8 parser trying to make it more likely to actually be monoidal in the face of errors
01:06:30 <mofmog> but whats up with comonads?
01:06:36 <andrey_nado> is there anybody who could help me?
01:07:00 <mofmog> (w a -> b) ? You can't have (comonadFunction x) =>> ??
01:07:01 <edwardk> mofmog: they have an extract which takes a function like (w a -> b)
01:07:27 <edwardk> monads look at one tiny part of the monad and make something big. a -> m b, they 'expand' or 'substitute' in the monad.
01:07:48 <mofmog> yeah, it's like fmap, one thing at a time. I see a comonad as fmap but it knows everything
01:08:00 <edwardk> a comonadic action looks at all of the comonad and makes something small, w a -> b, they 'redecorate' their corner of the comonad.
01:08:28 <edwardk> when you extend the comonadic action you effectively 'rewrap' the output of the function
01:08:55 <mofmog> it seems like almost anything a monad could do, a comonad could also do
01:08:56 <mofmog> ??
01:09:08 <edwardk> or more correctly you apply an extra wrapper (duplicate), then you map your function that peels a wrapper off
01:09:17 <edwardk> mofmog: not quite, they are quite different
01:09:22 <wli> They're different things.
01:09:49 <mofmog> of course, hence my confusion
01:09:57 <edwardk> mofmog: comonads are useful for things where you always have some value lying around. i.e. Maybe is a monad but not a comonadm because you can't implement extract!
01:10:27 <edwardk> you can have a comonad for infinite streams but not [a], because the empty list doesn't contain an 'a' to extract
01:11:02 <mofmog> oh, i see
01:11:15 <edwardk> think of it as you can't get a value out of a monad in general, but you can ALWAYS get out of a comonad, on the other hand you can't construct a comonad in general ;)
01:11:30 <edwardk> so while you need runFoo methods to tear down a monad, you need them to build up a comonad
01:11:40 <mofmog> a comonad goes smaller, a monad goes bigger
01:12:38 <edwardk> a comonadic action figures out how to redecorate a corner of the comonad using information about the whole thing, in general a comonadic action once extended can't actually change the 'shape' of the resulting data structure.
01:12:53 <mofmog> what do you mean by redecorate?
01:13:00 <mofmog> change?
01:14:05 <edwardk> say you have a comonad like the product comonad. the product comonad is just that (,)e is a comonad, i.e. (e,a) -> a exists and so does ((e,a) -> b) -> (e,a) -> (e,b)
01:14:30 <edwardk> the comonadic action once extended just 'redecorates' replacing all a's with b's.
01:15:03 <edwardk> but a consequence of the comonad laws is that the general shape of the functor will remain the same, if it had 3 a's before it should likely have 3 b's after extension
01:15:18 <edwardk> while with a monad you may wind up with more or less
01:15:39 <edwardk> 'the dual of substitution is redecoration' is a fairly deep paper on the topic
01:16:01 <Gracenotes> surely there's a comonad for data Blah a = Item a | Cons a (Blah a) :)
01:16:05 <wli> What would make something both a monad and comonad?
01:16:24 <edwardk> wli: Identity is both.
01:16:30 <Gracenotes> and, actually, a monad for it as well, I'm pretty sure
01:16:39 <edwardk> gracenotes: sure
01:16:41 <wli> Gracenotes: newtype NEL t = NEL (t, [t])
01:17:22 <wli> edwardk: But more generally; Identity is pretty obvious, NEL is a bit more involved to work through but obvious that it should be after some effort.
01:17:41 <Gracenotes> wli: yeah, if you want to replace the first : with ,
01:17:45 <edwardk> wli: there are a ton of them actually, the non-empty list and of course by that token any number of stream variants, yoneda/coyoneda/density/codensity of anything that is both
01:18:15 <mofmog> good god, i sure hope the abstract algebra class im taking next semester helps me with this
01:18:42 <edwardk> the yoneda lemma you'd want to look up on the internet ;)
01:18:50 <edwardk> it comes up in category theory but thats about it
01:18:56 <edwardk> sigfpe has a nice blog post about it
01:18:58 <Gracenotes> yoneda lemma.. saw it in a category theory book, yeah
01:19:30 <edwardk> i have a series of posts from last year about kan extensions, which subsumes it http://comonad.com/reader/2008/kan-extensions/
01:20:10 <Gracenotes> I suppose that hom-sets and hom-functors and the Hom(a, b) notation are all related, but heck if I know how
01:20:39 <wli> edwardk: There's some typeclass representing things that are both monads and comonads simultaneously? Are there new properties that crop up when things are both monads and comonads simultaneously?
01:21:05 <edwardk> it comes down to the notion that 'f a' is basically the same thing as 'forall b. (a -> b) -> f b' you can put those two types into correspondence
01:21:38 <edwardk> wli: fraid not because a functor can have multiple monad instances that make sense even
01:21:55 <wli> No big deal, I guess.
01:22:03 <edwardk> wli: nothing really makes one more canonical
01:22:33 <wli> edwardk: And nothing special happens when you pair up simultaneous instances either, I guess.
01:22:34 <edwardk> there is a (useless) notion of a dyad which subsumes a monad and comonad, but none exist that aren't monads or comonads ;)
01:23:20 <andrey_nado> Can I ask a question? I need help with my Haskell code
01:23:57 <edwardk> nah, i tried hard, but one of my favorite examples is that (,)e can be both a writer monad and product comonad, and (->)e can be both a 'exponential' comonad and reader monad, there doesn't appear to be a good tie between them, that said, there IS a tie between any two adjoint functors, in that the adjunction gives rise to both a comonad and a monad
01:24:25 <Gracenotes> andrey_nado: go ahead..
01:25:08 <andrey_nado> I need a function to calculate mean of list of lists, here is a code
01:25:14 <edwardk> so with that you get a relationship between the (,)e comonad and the (->)e monad -- they are adjoint to one another, and hence give rise to the e -> (e,a) state monad when composed one way and the (e -> a, e) context comonad when composed the other way
01:25:14 <andrey_nado> meanl :: [[Double]] -> [Double]
01:25:18 <andrey_nado> meanl x = meanl' x [] 0
01:25:24 <andrey_nado>   where
01:25:28 <andrey_nado>     meanl' :: [[Double]] -> [Double] -> Int -> [Double]
01:25:31 <andrey_nado>     meanl' (x:xs) [] _  = meanl' xs x 1
01:25:32 <Gracenotes> edwardk: monoids aren't required for writer (,)e?
01:25:35 <andrey_nado>     meanl' [] s l       = map (\x -> x / fromIntegral l) s
01:25:38 <andrey_nado>     meanl' (x:xs) s l   = meanl' xs (zipWith (+) s x) (l + 1)
01:25:48 <Gracenotes> andrey_nado: there's a pastebin linked in the topic, by the way :)
01:25:57 <wli> edwardk: Well, it was actually the hope that being both a monad and comonad at the same time would give you enough conditions for maybe useful new properties.
01:26:08 <dolio> (,) e is a functor regardless of e.
01:26:26 <edwardk> gracenotes they are required for writer (,)e monad and the exponential (->)e comonad for the same reason
01:26:33 <edwardk> you need them to generate an 'e' out of thin air
01:26:35 <andrey_nado> meanl :: [[Double]] -> [Double]
01:26:36 <andrey_nado> meanl x = meanl' x [] 0
01:26:38 <andrey_nado>   where
01:26:40 <andrey_nado>     meanl' :: [[Double]] -> [Double] -> Int -> [Double]
01:26:41 <andrey_nado>     meanl' (x:xs) [] _  = meanl' xs x 1
01:26:43 <andrey_nado>     meanl' [] s l       = map (\x -> x / fromIntegral l) s
01:26:44 <andrey_nado>     meanl' (x:xs) s l   = meanl' xs (zipWith (+) s x) (l + 1)
01:26:51 <Gracenotes> edwardk: interesting.. how is monoid required for exponential?
01:26:56 <edwardk> but you don't need them for the composition of the functor
01:27:07 <Gracenotes> mempty?
01:27:14 <dolio> extract :: (w -> a) -> a
01:27:33 <Gracenotes> andrey_nado: what's the issue?
01:27:35 <andrey_nado> This functions works, but it requires huge amount of memory on huge lists. How can I make it more effective?
01:27:43 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Comonad/Exponent.hs
01:27:55 <dolio> Speaking of kan extensions...
01:28:00 <edwardk> think about it, where do you get the 'e' to an 'a' from?
01:28:17 <dolio> A few days back I was trying to puzzle out what exactly (co)ends were.
01:28:22 <andrey_nado> Bottleneck is meanl' (x:xs) s l = meanl' xs (zipWith (+) s x) (l + 1) line: I have to pass list as a parameter (second argument)
01:28:56 <andrey_nado> How can I effectively accumulate and pass sum of list?
01:29:03 <wli> andrey_nado: fromIntegral (length s) is genericLength s
01:29:28 <edwardk> and then, just like how with writer you could be boring and just toss out the previous answer using the 'Last' monoid, but its more interesting to use something else, you use the monoid to plumb in deltas on what would otherwise be a very boring environment
01:29:50 <Gracenotes> wli: he's not using length though, just unrolling the list once
01:30:15 <wli> Oh, that's another story.
01:30:23 <Gracenotes> if you have two accumulator variables, you can just use a 2-tuple
01:30:41 <wli> Sure thing.
01:30:46 <Gracenotes> or use (case in point) Writer if at least one of them is an integer and you're keeping track of a sum
01:31:59 <andrey_nado> Gracenotes, it's ok, but I still have to accumulate and pass list (either in tuple or explicitly).
01:32:54 <andrey_nado> I'd like to break my questions into several ones. First question: is my meanl function tail-recursive?
01:33:04 <wli> It looks like he wants foldr (\x (s, n) -> (x + s, n + 1)) (0, 0)
01:33:10 <Gracenotes> your combination of functions seems a bit... odd
01:34:11 <wli> Or maybe even foldr ((*** (1 +)) . (+)) (0, 0)
01:34:29 <andrey_nado> Gracenotes, please explain...
01:34:37 <wli> andrey_nado: Use foldr (\x (s, n) -> (x + s, n + 1)) (0, 0)
01:34:51 <Gracenotes> andrey_nado: well, one generally uses foldl and foldr when dealing with accumulations.
01:35:30 <Gracenotes> it just seems that meanl' is doing a lot of things just for one function.
01:36:07 <Gracenotes> unless I misunderstand what your function does :)
01:36:35 <Gracenotes> by the way, meanl' should be tail recursive, since you can just replace it with the recursive call to itself
01:37:27 <dolio> So, since a coend is a dinatural transformation to an object, it's sort of like a morphism from the structure picked out by a functor to an object (the substructure of which somehow captures the 'shape' of the functor)?
01:37:54 <dolio> And since it's initial, it preserves as much of the shape as possible.
01:38:35 <dolio> edwardk: Does that sound vaguely on target? Or totally wrong?
01:38:35 <Gracenotes> andrey_nado: how does it go about taking the mean?
01:38:55 <Gracenotes> do you just want the mean of means of respective lists?
01:40:04 <andrey_nado> Gracenotes, I have trace files. Each line contains set of numbers. I should walk across entire file and calculate mean for each column.
01:40:26 <dolio> That seems to fit with the (exists e. S e e) definition, since the only thing you can do with that is look at the shape, not the elements.
01:40:40 <andrey_nado> As a result I'll get set of means
01:40:58 <wli> I thought we answered the mean question.
01:41:58 <Gracenotes> andrey_nado: well, there is a transpose function, if that helps
01:42:19 <Gracenotes> > transpose [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
01:42:20 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
01:42:46 <wli> andrey_nado: It's a mean of vectors?
01:43:10 <andrey_nado> wli, yes
01:43:19 <wli> Okay, no problem.
01:43:25 <Gracenotes> so it's a mean, but it's in an unusual format
01:43:34 <Gracenotes> i.e. you want to take several means simultaneously
01:44:55 <andrey_nado> Gracenotes, yes, I'm calculating several mean values simultaneously
01:46:17 <Gracenotes> > foldr (\xs acc -> zipWith (\x (s, l) -> (s + x, l)) xs acc) (repeat (0, 0)) [[1,2,3],[4,5,6],[7,8,9]]
01:46:18 <lambdabot>   [(12,0),(15,0),(18,0)]
01:46:18 <andrey_nado> Gracenotes, I'm afraid transpose will work very long with my huge files
01:47:07 <Gracenotes> hm, forgot to add one to length. actually, there should be a more optimal solution
01:47:38 <wli> > let f :: [[Double]] -> [Double] ; f xs = let (total, n) = foldr (\x (s, n) -> (zipWith (+) x s, n + 1)) (repeat 0, 0) xs in map (/n) total in f ([[1 .. 10], [2, 4..20], [3, 6 .. 30]] :: [[Double]])
01:47:39 <lambdabot>   [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0]
01:48:10 <wli> I'm not sure what he actually wants.
01:48:13 <Gracenotes> yeah :) /me was typing it out too! >.>
01:48:55 <Gracenotes> folding with a (sums, length) is slightly more efficiently than folding with [(sum, length), (sum, length) ..] since you don't have to increment the length more than once
01:49:27 <wli> I'd use foldl' for this. It's all strict anyway.
01:50:03 <Gracenotes> but it should work nicely. GHC has lots of rules to optimize foldrs and maps and so on when they're chained together, whereas if you write a recursive function you might be on your own
01:50:07 <kohwj> no offense, but why do haskellers not use more meaningful function argument names?
01:50:31 <Gracenotes> laziness, of course! :p
01:50:31 <wli> kohwj: Feel grateful when we use function names at all.
01:50:51 <kohwj> gosh
01:52:05 <Baughn> kohwj: They /are/ meaningful
01:52:32 <andrey_nado> wli, I'm trying your code...
01:52:34 <Baughn> kohwj: They may not be familiar, but that's because they don't do exactly the same thing as whatever might be familiar, either
01:52:35 <Gracenotes> hm. some, at least. there are naming conventions
01:52:51 <Gracenotes> very informal, like (x:xs) to match a list
01:53:03 <kohwj> Baughn: Gracenotes: yes, (x:xs) and "a" for types
01:53:20 <kohwj> are there any more?
01:53:36 <Gracenotes> I guess the descriptive names are saved for the functions :)
01:53:52 <Baughn> kohwj: Suffixing a monadic combinator with _ for the variant that discards return data,
01:53:52 <dancor> p for tests (predicates?)
01:53:58 <dancor> @src filter
01:53:59 <lambdabot> filter _ []     = []
01:53:59 <lambdabot> filter p (x:xs)
01:53:59 <lambdabot>     | p x       = x : filter p xs
01:53:59 <lambdabot>     | otherwise = filter p xs
01:54:02 <wli> kohwj: For instance, there's no function name here:
01:54:04 <wli> > uncurry (flip (map . flip (/))) . foldl' (flip $ (*** (+1)) . zipWith (+)) (repeat 0, 0) $ ([[1 .. 10], [2, 4..20], [3, 6 .. 30]] :: [[Double]])
01:54:06 <lambdabot>   [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0]
01:54:16 <Baughn> kohwj: Suffixing functions with ' when they're strict.. okay, that one's a bit inconsistent
01:54:44 <dancor> kohwj: i think it has to do with math-background of a lot of ppl
01:54:49 <Baughn> kohwj: But for (x:xs), the /reason/ the name isn't descriptive is that there's nothing to describe. It's a list element; you can see that from the structure - but it's not any particular kind of list element
01:54:50 <Gracenotes> f and g for functions, n for numbers (like lengths)
01:54:53 <kohwj> why aren't you all afraid of serial-killer category theorists who read your code?
01:55:07 <kohwj> Baughn: yup, (x:xs) is really sensible
01:55:18 <mofmog> I think I get it
01:55:33 <Baughn> kohwj: Or even when it is, chances are the type is specified right above. No point in saying (crow:crows) when there's "foo :: [Crow] -> Egg" right above
01:55:39 <mofmog> coreturn is taking a big thing and you get a small thing, return is you take a small thing and get a big thing
01:56:40 <mofmog> join is when you have a bunch of individual things and you put them togehter. cojoin is when you have a bunch of stuff together and separate them
01:57:15 <kohwj> Baughn: true true
01:57:32 <wli> andrey_nado: How's the code doing?
01:57:53 <andrey_nado> I'm checking it now...
01:58:11 <wli> andrey_nado: Are you using the foldl' version?
01:58:22 <Baughn> mofmog: Did you mean to use the same "join" as the principal Monad operator, or are those different things?
01:58:29 <mofmog> yes
01:58:30 <wli> foldl' is a good idea because it's all strict anyway.
01:58:32 <mofmog> the first ting
01:58:41 <andrey_nado> wli, no I'm using foldr as you've written here
01:59:07 <Baughn> mofmog: In that case, I think I'd love to see an examlpe of cojoin. ;)
01:59:19 <Baughn> mofmog: I can see how join works, but cojoin sounds a lot like unscrambling an egg
01:59:22 <wli> andrey_nado: Give it a short. There's a foldl' version, too, which is f xs = let (total, n) = foldl' (\(s, n) x -> (zipWith (+) x s, n + 1)) (repeat 0, 0) xs in map (/n) total
01:59:25 <mofmog> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
01:59:47 <mofmog> The thing to know I think is that a comonad has a "focus"
02:00:01 <Baughn> Are zippers comonads?
02:00:03 <mofmog> and that you can switch the focus without destroying the underlying "data"
02:00:06 <wli> I'd call it a canonidcal projection.
02:00:07 <mofmog> apparently so
02:00:24 <mofmog> so the idea behind cojoin is to get a structure wherein you have ALL of the foci
02:00:35 <wli> A canonical projection, rather.
02:03:03 <wli> Something is doing defaulting to Integer.
02:03:31 <andrey_nado> wli, your code works but the problems still remains: I cannot make it work in constant memory amount
02:03:54 <wli> andrey_nado: Even the foldl' version?
02:03:57 <maurer1> Hey, is there a function that would split on a delimiter? i.e.
02:03:57 <maurer1> f :: a -> [a] -> [[a]]
02:03:57 <maurer1> f ',' "a,b,c" = ["a","b","c"]
02:03:58 <wli> > let f :: [[Double]] -> [Double] ; f xs = let { total :: [Double] ; n :: Double ; (total, n) = foldl' (\(s, k) x -> (zipWith (+) x s, k + 1)) (repeat 0, 0) xs } in map (/n) total in f ([[1 .. 10], [2, 4..20], [3, 6 .. 30]] :: [[Double]])
02:03:59 <lambdabot>   [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0]
02:04:02 <andrey_nado> wli: yes
02:04:26 <wli> andrey_nado: There is some kind of problem.
02:04:52 <wli> andrey_nado: Hang on while I come up with something for it.
02:05:15 <andrey_nado> wli, thank you!
02:12:35 <wli> > let f xs = let (total :: [Double], n :: Double) = runST $ do { st <- newSTRef (map (const 0) $ head xs, 0) ; mapM (\x -> modifySTRef st (zipWith (+) x *** (+1))) xs ; readSTRef st } in map (/n) total in f ([[1 .. 10], [2, 4 .. 20], [3, 6 .. 30]] :: [[Double]])
02:12:36 <lambdabot>   /tmp/3042777895808899876:70:138: Not in scope: `runST'/tmp/3042777895808899...
02:13:06 <wli> andrey_nado: Try that.
02:16:54 <wli> {- needs Control.Monad.ST and Data.STRef -} let f :: [[Double]] -> [Double] ; f xs = let { total :: [Double] ; n :: Double ; (total, n) = runST $ do { st <- newSTRef (map (const 0) $ head xs, 0) ; mapM (\x -> modifySTRef st (\(s, k) -> (zipWith (+) x s, k + 1))) xs ; readSTRef st } } in map (/n) total in f ([[1 .. 10], [2, 4 .. 20], [3, 6 .. 30]] :: [[Double]])
02:17:19 <wli> I at least got rid of the Control.Arrow dependency.
02:18:29 <andrey_nado> wli: could not compile
02:18:32 <wli> andrey_nado: That is attempting to force in-place update by using mutable reference API's.
02:18:43 <wli> andrey_nado: Error about *** ?
02:18:47 <andrey_nado> yes
02:19:07 <wli> andrey_nado: Control.Arrow, Data.STRef, and Control.Monad.ST are needed
02:19:40 <andrey_nado> got it, checking...
02:20:11 <wli> The in-place updates may not actually help, but I'm hoping.
02:21:06 <wli> Even without the in-place updates the GC should've noticed that the space getting eaten was immediately recoverable before expanding the heap to horrendous proportions.
02:21:08 <andrey_nado> wli: it doenlt still work in constant memory :(
02:21:29 <wli> andrey_nado: You're going to be forced to use mutable arrays from top to bottom, then.
02:22:01 <andrey_nado> wli: ok, I will try. What library should I use?
02:22:46 <wli> Data.Array.ST
02:22:58 <wli> andrey_nado: In particular, you want STUArray
02:23:38 <andrey_nado> wli: ok, thank you very much!
02:23:41 <andrey_nado> wli++
02:23:43 <wli> andrey_nado: You may end up needing IOUArray, too.
02:24:34 <wli> andrey_nado: STUArray ends up getting frozen and copied at some point. IOUArray hoists it all to the IO monad in main :: IO () and so you can parse and print without ever needing to copy.
02:25:46 <andrey_nado> wli: this all doesn't conorm to functional programming, yes?
02:25:59 <wli> andrey_nado: Not one bit, no.
02:26:02 <wli> instance MArray IOUArray Double IO
02:26:53 <andrey_nado> wli: thank you
02:26:57 <wli> You can use real monad transformers on all the IOUArray affairs, unlike STUArrays. Granted, IO must be the inner monad.
02:35:37 <NameAlreadyInUse> is (Array a) a monad?
02:37:18 <jethr0> not that I know of
02:37:29 <NameAlreadyInUse> could it be?
02:38:07 <dolio> You'd have to make a lot of arbitrary decisions.
02:39:07 <edbond1> how to do a pure action inside do block?
02:39:42 <jethr0> edbond1: "let"?
02:40:01 <ejt> edbond1: what is a 'pure action' ?
02:40:03 <edbond1> jethr0: can I mix do and let?
02:40:29 <jethr0> yes, you can use "let" inside a do block and don't need the "in" part
02:41:21 <edbond1> ejt: I'm trying to calculate time needed to perform some calculations?
02:41:45 <ejt> ah, you'll need to be careful then
02:41:46 <edbond1> ejt: '?' don't needed at the end.
02:42:08 <ejt> I think dons blogged on this once
02:42:45 <edbond1> I use getCurrentTime twice, but I don't know how to insert call to a pure function inside do block.
02:43:07 <mk15_> getCurrentTime won't be a pure function
02:43:20 <ejt> simple way is to print some aspect of the calculated value
02:43:21 <jethr0> edbond1: could you paste your code?
02:43:22 <jethr0> @paste
02:43:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:44:08 <mk15_> ejt: are you trying to find how long your entire program takes to run, or just a sebsection of it?
02:44:18 <NameAlreadyInUse> dolio: what sort of arbitrary decisions would have to be made?
02:44:19 <edbond1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2632#a2632
02:44:44 <mk15_> edbond1: are you trying to find how long your entire program takes to run, or just a sebsection of it?
02:44:49 <ejt> :)
02:44:51 <NameAlreadyInUse> dolio: wouldn't you only need to implement bind and return?
02:44:51 <edbond1> mk15_: just one function.
02:44:55 <dolio> NameAlreadyInUse: What are the indices of return x?
02:45:09 <NameAlreadyInUse> ah, true
02:45:23 <jkff> @seen vixey
02:45:23 <lambdabot> I saw vixey leaving ##logic and #haskell 9h 44m 58s ago, and .
02:45:37 <wli> andrey_nado: It's too long to paste on IRC.
02:46:23 <andrey_nado> wli: could you send me by email?
02:46:27 <wli> andrey_nado: f :: IOUArray (Int, Int) Double -> IO (IOUArray Int Double) ; f a = do { (_, (m, n)) <- getBounds a ; v <- newArray (1, m) 0 ; mapM_ (\j -> mapM_ (\i -> do { x <- readArray a (i, j) ; y <- readArray v i ; writeArray v i (x + y) }) [1 .. m]) [1 .. n] ; let n' = fromIntegral n in mapM_ (\i -> do { x <- readArray v i ; writeArray v i (x / n')}) [1..m] ; return v }
02:46:29 <jethr0> edbond1: you could you let, but you have to be careful that you also force the value of "std". otherwise it's lazily not going to be evaluated at all
02:46:32 <ejt> edbond1: there's some benchmark packages on hackage eg, microbench - I've notused any of them though
02:46:49 <wli> andrey_nado: Never mind, it fits. I just couldn't get the testcase garbage in along with it.
02:47:13 <wli> That was (\a -> getBounds a >>= \(_, m) -> mapM_ (\i -> readArray a i >>= print . (,) i) [1..m]) =<< f =<< do { a <- newArray_ ((1, 1), (10, 3)) ; mapM_ (\k -> let k' = fromIntegral k in writeArray a (k, 1) k' >> writeArray a (k, 2) (2*k') >> writeArray a (k, 3) (3*k')) [1..10]; return a }
02:47:25 <mk15_> edbond1: hmm I dont know if I can help you....perhaps you could try profiling your program http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
02:48:32 <wli> andrey_nado: I don't know you data format so I can't show how to construct the initial arrays.
02:48:40 <edbond1> jethr0: can you give me example of let and do?
02:49:02 <edbond1> ejt: thanks, I've used them but want to make this myself.
02:49:18 <edbond1> mk15_: thanks
02:49:27 <andrey_nado> wli: I'm reading from stdin -> lines (and convert each line string to [Double])
02:49:50 <wli> andrey_nado: Here mapM_ (\k -> ...) [1 .. n] is like for (k = 1; k <= n; ++k) { ... }
02:50:00 <wli> andrey_nado: Very literally.
02:50:16 <Workybob> more so... forM_ [1..n] (\k -> ...)
02:50:18 <wli> andrey_nado: How do you convert each line to [Double]? words?
02:50:29 <jethr0> do {t1 <- getTime; let x = std; putStrLn std; t2 <- getTime}
02:50:39 <andrey_nado> wli: (map (\w -> read w)) . words
02:50:42 <wli> andrey_nado: map words . lines?
02:50:45 <jethr0> stupid example, but as I said you have to be careful to force the value of std at the right time
02:50:46 <dolio> NameAlreadyInUse: In fact, I suspect the arbitrary choice of indices breaks the monad laws.
02:50:56 <jethr0> profiling seems like a good solution
02:51:00 <wli> andrey_nado: Okay.
02:51:06 <jethr0> s/putStrLn std/putStrLn x/
02:51:10 <ejt> edbond1: see here for some examples of let's inside a do: http://book.realworldhaskell.org/read/io.html
02:51:58 <dolio> NameAlreadyInUse: If you pick False as the index in singleton arrays with boolean indices, then "array (True,True) [(True,0)] >>= return = array (False,False) [(False,0)]", which doesn't fit with 'm >>= return = m'.
02:52:00 <edbond1> jethr0: thanks
02:53:34 <NameAlreadyInUse> dolio: oh, i see
02:53:49 <NameAlreadyInUse> dolio: i guess that rules it out for (Map a) as well?
02:54:12 <dolio> Seems like it.
02:56:04 <andrey_nado> wli: how to use your function?
02:56:58 <dolio> Arrays with limited size indices probably get you problems with associativity, as well.
02:57:28 <jethr0> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
02:57:52 <wli> andrey_nado: Something like this:
02:57:55 <wli> :t let mkArray s = let s' :: [[Double]] ; s' = map (map read . words) $ lines s ; m = length s' ; n = length $ head s' in do { a <- newArray_ ((1, 1), (m, n)) ; zipWithM_ (\i xs -> mapM_ (\(j, x) -> writeArray a (i, j) x) xs) [1 .. m] $ map (zip [1 .. n]) s' ; return a } in mkArray
02:57:56 <lambdabot> Not in scope: `newArray_'
02:57:56 <lambdabot> Not in scope: `writeArray'
02:59:23 <haraldk> ??xom
02:59:34 <wli> andrey_nado: readFile "mydata.dat" >>= mkArray will construct such an array from the format you described (no commas, just space separated columns and one row per-line).
02:59:39 <dolio> [False=>[False=>[False=>0,True=>1],True=>[False=>2,True=>3]],True=>[False=>[False=>4,True=>5],True=>[False=>6,True=>7]]]...
03:00:11 <wli> andrey_nado: Or getContents >>= mkArray if you read from stdin.
03:00:49 <dolio> I guess you get [False=>0,True=>1] in either case if you just try to concatenate them.
03:00:54 <edwardk> woot the incremental utf8 parser is no longer failing to be associative
03:01:25 <andrey_nado> wli: couldn't compile mkArray: Parse error in pattern
03:02:28 <wli> andrey_nado; Not sure where that could be coming from. I was careful not to use extensions.
03:04:40 <NameAlreadyInUse> @pl f x y z = x + y + z
03:04:41 <lambdabot> f = ((+) .) . (+)
03:06:56 <andrey_nado> wli: where xxxM_ function come from?
03:07:32 <wli> andrey_nado: Control.Monad and maybe Data.Array.IO
03:09:14 <andrey_nado> wli: still cannot compile. I'm trying following code:
03:09:15 <andrey_nado> let mkArray s = let s' :: [[Double]] ; s' = map (map read . words) $ lines s ; m = length s' ; n = length $ head s' in do { a <- newArray_ ((1, 1), (m, n)) ; zipWithM_ (\i xs -> mapM_ (\(j, x) -> writeArray a (i, j) x) xs) [1 .. m] $ map (zip [1 .. n]) s' ; return a } in mkArraylet mkArray s = let s' :: [[Double]] ; s' = map (map read . words) $ lines s ; m = length s' ; n = length $ head s'...
03:09:17 <andrey_nado> ...in do { a <- newArray_ ((1, 1), (m, n)) ; zipWithM_ (\i xs -> mapM_ (\(j, x) -> writeArray a (i, j) x) xs) [1 .. m] $ map (zip [1 .. n]) s' ; return a } in mkArray
03:12:01 <Gracenotes> wha, mutable arrays?
03:13:18 <Gracenotes> nothing wrong with some cuddering
03:22:27 <wli> andrey_nado: It compiles over here, so I'm not sure what happened in your case.
03:22:49 <andrey_nado> wli: ok thanks, I'll investigate
03:24:17 <wli> I can literally do readFile "nado.dat" >>= mkArray  >>= f >>= \v -> getBounds v >>= \(_, m) -> mapM_ (\i -> readArray v i >>= print . (,) i) [1 .. m]
03:27:37 <andrey_nado> wli: thank you for your consultation. Is there any FP-styled solution of my problem? (not involving mutable arrays and other imperative programming concepts)
03:27:50 <Gracenotes> cuddering :)
03:28:05 <Gracenotes> folding lists works perfectly fine
03:28:19 <wli> andrey_nado: Almost certainly; however, I myself am not skilled enough to do more than the imperative.
03:28:34 <wli> Gracenotes: He needs bounded space usage and is not achieving it with list folding.
03:28:38 <andrey_nado> Gracenotes: it doesn't work in my case :(
03:28:45 <Gracenotes> not foldl' ?
03:29:01 <wli> Not even foldl'
03:29:19 <Gracenotes> it doesn't work or it doesn't meet the requirements?
03:29:56 <andrey_nado> Gracenotes: I have to process huge files in limited memory amounts
03:30:01 <Gracenotes> if needed you can define a zipWith' (strict zipWith), if it helps
03:30:43 <andrey_nado> Gracenotes, I have no skills anough for it
03:30:45 <Gracenotes> yes, and with strictness the problem of unevaluated stuff in memory is alleviated
03:31:09 <Gracenotes> @src zipWith
03:31:09 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:31:09 <lambdabot> zipWith _ _      _      = []
03:31:39 <Gracenotes> zipWith' f (a:as) (b:bs) = let v = f a b in v `seq` v : zipWith f as bs  <-- strict
03:32:46 <Workybob> Gracenotes: at a guess you wanted zipWith' in the rhs
03:32:56 <Gracenotes> er, indeed I did
03:33:09 <Gracenotes> s/zipWith f as bs/zipWith' f as bs/
03:33:51 <Gracenotes> all that you need is to write a version with foldl and zipWith so that the types match up and it works for small input -- similar to stuff defined way up -- then switch to the strict variants and any size input.
03:38:27 <NameAlreadyInUse> @pl fac n = fix (\g f z x -> if null x then z else f ((\(h:_) -> h) x) (g f z ((\(_:t) -> t) x))) (*) 1 [1..n]
03:38:28 <wli> andrey_nado: Okay, here's the IOUArray affair in action.
03:38:28 <lambdabot> fac = fix ((ap (ap . flip (if' . null)) .) . ap ((.) . ap . (. head)) . flip flip tail . ((flip . ((.) .)) .)) (*) 1 . enumFromTo 1
03:41:43 <andrey_nado> Gracenotes: it doesn't work at all
03:43:31 <edbond1> how to translate this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2633#a2633 to haskell?
03:44:05 <ejt> edbond1: lookup Data.Bits
03:44:30 <edbond1> ejt: I know. What about recursiveness?
03:45:30 <edbond1> nevermind. I will solve this myself.
03:45:44 <mk15_> im working on an assignment where I need to join to lists together using fold. This is the code im using but im getting a compile error: join (x:xs) (y:ys) = foldr ++ [] [(x:xs), (y:ys)]
03:45:49 <ejt> edbond1: I'm not sure what you're asking, there is no recursion in the code snippet you pasted
03:45:53 <mk15_> two lists*
03:46:05 <wli> andrey_nado: http://wli.pastebin.com/m45d7f03c
03:46:48 <wli> Gracenotes: I already gave him a version with foldl' and zipWith
03:48:03 <doserj> mk15_: try "foldr (++) ..."
03:48:14 <doserj> mk15_: after that, look what happens with empty lists
03:49:39 <doserj> mk15_: but anyways, I don't think that this is the way you were supposed to solve the assignment :)
03:49:46 <andrey_nado> wli: I'm checking...
03:49:48 <wli> Gracenotes: For whatever reason the strictness analyzer failed to behave properly.
03:51:12 <wli> Gracenotes: Or maybe the GC didn't reap the youngest generation fast enough. Or whatever. The space behavior didn't fly.
03:51:22 <andrey_nado> wli: mkArray returns wrong format
03:51:36 <mk15_> doserj: thank you it works now....im curious why you say thats the wrong way?? Is there another way to solve this with foldl/r ??
03:51:36 <wli> andrey_nado: I had a feeling.
03:51:37 <andrey_nado> it transponses input data, and result is not what I need
03:52:13 <andrey_nado> actually it returns row means rather than column means
03:52:20 <wli> andrey_nado: Well, the formats are row major or column major.
03:52:37 <doserj> mk15_: the function you are supposed to define is simply (++). so you are supposed to define (++) in terms of fold, but not in terms of itself...
03:52:46 <wli> andrey_nado: Not hard to change that around.
03:53:13 <doserj> mk15_: you are supposed to fold over the argument lists
03:53:37 <mk15_> doserj: I see, ill try to figure out another way then..thanks
03:55:14 <cizra> doserj: I haven't followed the conversation, but wouldn't it be easier to define (++) through (:)?
03:55:55 <doserj> cizra: I guess that's the intended solution
03:57:13 <wli> andrey_nado: Is it enough to go on or should I fix it up more?
03:58:57 <andrey_nado> wli: I need a time to review and modify your code. At first glance it looks clear (and old-good imperatve :))
04:00:15 <andrey_nado> wli: thank you for explanationg regarding mutable arrays in haskell
04:00:34 <wli> No problem.
04:01:00 <mk15_> doserj: here is the proper solution fyi join l ll = foldr (:) ll l
04:01:01 <wli> andrey_nado: If you need to stack mutable arrays with monad transformers, use IOArrays and/or IOUArrays because ST doesn't stack.
04:01:47 <Saizan_> ST can be the base monad of a stack like IO do
04:01:57 <doserj> mk15_: good
04:01:59 <Saizan_> you can't have a stack with both ST and IO though
04:02:01 <mk15_> :)
04:02:05 <wli> andrey_nado: Or at least I find that STArrays/STUArrays cause endless headaches where IOArrays/IOUArrays
04:02:20 <wli> andrey_nado: Don't cause such problems.
04:02:23 <doserj> @src (++)
04:02:23 <lambdabot> []     ++ ys = ys
04:02:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:02:23 <lambdabot> -- OR
04:02:23 <lambdabot> xs ++ ys = foldr (:) ys xs
04:02:30 <doserj> :)
04:03:23 <wli> Saizan: For whatever reason the existential in ST gives me no end of trouble. I've no idea why no one else has such trouble with it.
04:03:36 <mk15_> :doserj haha :)
04:03:40 <edbond1> can I use comparision in case?
04:04:06 <Botje> edbond1: in a guard, yes
04:04:15 <Botje> case foo of blah | blah == "blargh" -> ...
04:04:27 <Botje> although you might as well do case foo of "blargh" -> for that one
04:04:28 <edbond1> Botje:  thanks
04:07:09 <edbond1> can I use guards in let expressions ?
04:07:53 <wli> edbond1: Yes.
04:07:57 * Guest3414 http://www.ihateyounatalie.com/?id=1322797
04:08:18 <wli> > let a = 1 in let b | even a = 0 | otherwise = 1 in b
04:08:19 <lambdabot>   1
04:12:55 <cizra> doserj: Is it possible to define (++) through only (:)? It's simple to create a version that reverses one of the string, but how to make it non-reversing?
04:13:05 <cizra> let plus as [] = as; plus a (b:bs) = plus (b:a) bs in plus "pepe" "lolo"
04:13:06 <cizra> > let plus as [] = as; plus a (b:bs) = plus (b:a) bs in plus "pepe" "lolo"
04:13:08 <lambdabot>   "ololpepe"
04:13:53 <Saizan_> wli: many have problems with it at first, but it's simple once you learn what you can and can't do, and the limits of type inference for higher-rank types
04:15:46 <wli> I can't even form undefined :: RWST Int [Int] Int (forall s . ST s) Int
04:17:39 <doserj> > let plus [] as = as; plus (b:bs) a = b: plus bs a in plus "pepe" "lolo" -- cizra
04:17:41 <lambdabot>   "pepelolo"
04:17:49 <Saizan_> your actions should be of type forall s. RWST Int [Int] Int (ST s) Int
04:18:04 <Saizan_> i.e. universally polymorphic in 's'
04:18:31 <cizra> doserj: Nice!
04:19:15 <quicksilver> wli: that's an impredicative type, which requires a different extension I think.
04:19:22 <quicksilver> you don't need them to use ST.
04:19:49 <wli> The type management here rapidly turns into a nightmare.
04:19:56 <opqdonut> > let plus xs ys = foldr (:) ys xs in plus "pepe" "lolo"
04:19:58 <lambdabot>   "pepelolo"
04:20:01 <opqdonut> ^_^
04:20:22 <wli> For IO you can at least fog it up nicely with MonadIO; there's no equivalent of MonadIO for ST
04:20:30 <quicksilver> except for MonadST
04:20:52 <wli> Wherever that is I don't have it.
04:21:06 <quicksilver> :)
04:21:14 <quicksilver> yeah, it's the name for an obvious idiom
04:21:20 <quicksilver> rather than actually existing
04:21:30 <quicksilver> there are multiple implementations on hackage, I think.
04:21:33 <dancor> http://hackage.haskell.org/packages/archive/funsat/0.5.2/doc/html/Control-Monad-MonadST.html#t%3AMonadST
04:21:56 <wli> Whatever idiom you're talking about I don't seem to be able to independently invent.
04:21:59 <quicksilver> one in 'funsat' and one in 'stateful-mtl' it looks like.
04:22:30 <NameAlreadyInUse> so what is a monad transformer, exactly?
04:22:48 <dancor> it's a way of getting one monad when you need two
04:23:02 <quicksilver> it's a type constructor that takes layers some extra capability on top of an existing monad
04:23:11 <quicksilver> like adding State to Maybe, say.
04:23:28 <NameAlreadyInUse> so i can combine two monads, and it will apply bind and return to both?
04:23:35 <quicksilver> yes.
04:23:43 <quicksilver> the combined return is just return.return
04:23:48 <quicksilver> the combined bind is slightly more complex
04:23:59 <quicksilver> (it doesn't have a general form, it varies case by case)
04:27:12 <wli> I'm not sure how far I can get even with ST.
04:28:15 <lilac> wli: i think of the 's' as some opaque reference to the ST computation I'm performing, and that usually makes it obvious how to pass it around
04:28:35 <wli> Most of the time I need something more like MonadState than ST, though it's vaguely useful that all kinds of stateful looking things floating around.
04:29:30 <lilac> wli: i don't know 's', so i write 'type MyMonad s a = RWST Int [Int] Int (ST s) a deriving (Monad)'
04:29:56 <lilac> then i have functions :: a -> MyMonad s b, and it all just kinda works
04:30:04 <quicksilver> lilac: you meant "newtype" and you need a constructor :)
04:30:20 <lilac> quicksilver: quite possibly :) it's been a while since i did this
04:30:53 <mk15_> im trying to define the signature of a function that takes in a list of pairs of integers, and outputs a list of integers...what I have so far isnt correct according to ghc:     f :: [(x:xs)] -> [x]
04:30:54 <lilac> wouldn't it also work if i dropped the 'deriving' clause?
04:31:15 <quicksilver> yes.
04:31:20 <wli> Most of the time I end up stacking everything atop IO in the end anyway, but ST insists on being the bottom of the stack, so it stops me dead cold.
04:31:32 <lilac> mk15_: "a:b" doesn't name a type
04:31:41 <quicksilver> wli: there is no conceivable reason to want ST and IO in the same stak.
04:31:55 <quicksilver> wli: ST is just a particular subset of IO which has a pure 'run' method.
04:31:57 <wli> It's vaguely inconsistent whether I hit the wall wrt. typedecls etc.
04:31:59 <mk15_> lilac: is there a way to represent a 2-tuple?
04:32:08 <quicksilver> mk15_: (1,2)
04:32:19 <quicksilver> mk15_: you should really read a basic haskell tutorial ;)
04:32:32 <wli> quicksilver: There is; STArrays for matrices/etc.
04:32:46 <quicksilver> wli: if your stack contains IO anyway you can use IOArrays
04:32:47 <lilac> mk15_: tuple types are written as (Int, Double, x). tuple values are written as (4, 2.5, 'x')
04:32:52 <quicksilver> wli: they are the same thing.
04:33:23 <lilac> mk15_: so the type of a list of pairs of Integer is [(Integer,Integer)]
04:33:25 <mk15_> quicksilver: i know how to make a tuple, but didnt know how to represent it as part of a function sig
04:33:32 <wli> quicksilver: Simultaneous usage across some pure places and some IO places etc. Lib functions exported. And so on.
04:33:52 <lilac> @type [(1,2),(toInteger 3,toInteger 4)]
04:33:53 <lambdabot> [(Integer, Integer)]
04:34:01 <quicksilver> mk15_: ah, fair enough. (typea,typeb)
04:34:11 <quicksilver> e.g. (String,Int) or (Char,String) etc.
04:34:30 <quicksilver> wli: well in that case you need a typeclass to abstract.
04:34:43 <wli> That's one place I got killed because I kept needing to have all these MArray -generic functions on arrays and everything died there.
04:34:49 <quicksilver> wli: you could possibly use MArray, which is already a typeclass absrtacting against that sort of thing.
04:34:49 <mk15_> lilac: thank you, that works perfectly
04:35:33 <lilac> no problem
04:37:13 <wli> Linear system solving over number fields is one place where it comes up. The linear system solver needs pure usage for inverting field elements and IO usage for input and output of the system taken as input on the larger field.
04:37:51 <wli> Saizan: SASL?
04:38:11 <Saizan_> wli: SASL?
04:38:23 <NameAlreadyInUse> what is the monad transformer version of Maybe?
04:38:37 <wli> Saizan: A strict functional language without higher-order functions.
04:39:01 <Saizan_> wli: ah, never used/seen it
04:39:05 <wli> No list comprehensions at all though.
04:39:46 <osfameron> comprehensions are just unpleasant sugar for map/grep
04:39:50 * osfameron ducks
04:40:51 <Saizan_> uhm, i prefer do blocks myself too, i get to choose where the return is
04:40:53 <wli> That reminds me that I still have no idea how to figure out what field extension of Q a given radical expression inhabits.
04:42:28 <wli> bbiaw headed to retinal specialist
04:42:43 <adimit> a unicode related question: when I'm using Char8.groupBy that groups by a function Char->Char->Bool, having a Unicode char as one or both of the Char arguments to that function doesn't seem to work for me. Is that expected behaviour, and how can I circumvent it? (I would sacrifice performance for it)
04:43:42 <adimit> (I think Char8 stores character data as 8bit, and doesn't seem to compare enough 8bit-blocks if I input some 16-bit characters...)
04:45:01 <Saizan_> Data.ByteString.Char8 essentially makes you work with latin1
04:45:08 <Saizan_> it's specified in the doc
04:45:43 <Saizan_> there's a new package that supports encodings over bytestrings, iirc?
04:46:04 <adimit> Saizan_: yes, that's why I suspected I've got a problem here. It's just that the type signature fooled me into believing it could use any valid Char and it would work As Expected.
04:46:55 <adimit> anyway, I would be glad if someone knew a nice workaround that doesn't force me to go back to [Char] (I'm writing a natural language tokenizer.)
04:47:07 <adimit> Saizan_: do you happen to know the name of that package?
04:47:32 <Saizan_> no, unfortunately
04:48:12 <Saizan_> ah, text and text-ico
04:48:19 <Saizan_> *text-icu
04:48:37 <quicksilver> adimit: check out utf8-string and encoding also
04:48:40 <quicksilver> and compactstring
04:48:42 <quicksilver> all on hackage
04:48:47 <quicksilver> I believe one of those might do what you want.
04:49:15 <adimit> quicksilver, Saizan_: I will look into both suggestions, they sound promising :-) Thank you
04:49:22 <lilac> @wiki New monads/MaybeT
04:49:23 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
04:49:43 <lilac> NameAlr... oh, you've gone.
04:50:08 <adimit> there doesn't seem to be a natural language tokenizer on Hackage... hrm. Maybe I'll upload mine when I'm done. Haskell needs moar NLP.
04:55:39 <jpu> Hello, Does anybody know how to export, using FFI, a function which returns to type GHC.IOBase.Handle?
04:56:06 <dancor> why can't two modules import each other?  i could just combine the two modules for example, why wouldn't it just behave like that
04:56:26 <ivanm> dancor: I thought they can
04:56:37 <ivanm> well, ghci can't, but ghc can
04:56:47 <ivanm> by half-compiling one, compiling the other then compiling the first fully
04:56:59 <dancor> ghc says "Module imports form a cycle for modules:"
04:57:11 <dancor> @ghc
04:57:11 <lambdabot> ghc says: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
04:57:16 <Igloo> dancor: Because ghc does separate compilation with -c
04:57:33 <Igloo> dancor: You can do it, but you have to write a .hs-boot file; see the user guide for details
04:58:51 * fasta thinks lack of support for mutually recursive modules is _really_ bad and leads to choices of implementation that are only a result of the weakness of the language implementation 
04:59:28 <dancor> mm
05:02:01 <fasta> There is a grand total of 30 uses of .hs-boot files on Hackage.
05:02:14 <fasta> Most of them are by compiler writers.
05:03:36 * quicksilver thinks that using mutually recursive modules is _really_ bad and not having easy access to them encourages good programming styles and modularisation.
05:05:37 * dancor is _really_ unsure either way
05:06:37 <fasta> quicksilver: why are mutually recursive modules bad and mutually recursive functions good?
05:07:11 * osfameron isn't sure about mutually recursive functions either ;-)
05:07:33 <quicksilver> mutually recursive functions are "one thing"
05:07:42 <quicksilver> they sit next to each other, they work together
05:07:56 <quicksilver> the fact we choose to cast them as two functions is a trivial issue of naming.
05:08:19 <quicksilver> and occasionally a desire to offer both entry points
05:08:20 <Peaker> fasta: if two modules depend on each other, why are they not just one module?
05:08:22 <quicksilver> (all entry points)
05:08:24 <dancor> i'm splitting one of my modules and at first it seemed like it would be clean at the end but now it's looking a bit wack
05:08:44 <fasta> Peaker: because the size of modules should be limited.
05:08:49 <quicksilver> Broadly by the same argument, I say that mutually recursive modules are also one thing.
05:08:50 <Peaker> fasta: modules should be layered on top of each other
05:09:02 <quicksilver> and since they're one thing, they don't deserve to be two "modules"
05:09:02 <fasta> Peaker: but that's not just always possible.
05:09:06 <quicksilver> cos that's not what modularity is.
05:09:20 <Peaker> fasta: Do you have an example?
05:09:33 * Peaker agrees with quicksilver 
05:09:42 <quicksilver> I am told by people who are smarter than me that there exist cases where a pair of mutually recursive modules really is what you want.
05:09:46 <quicksilver> I have never seen one.
05:09:50 <quicksilver> (that convinced me, I mean)
05:09:55 <fasta> Peaker: I can see whether I can distill an example.
05:09:55 <quicksilver> obviously this is subjective to some extent.
05:10:17 <quicksilver> Although it's only really subjective if you admit the possibility that quicksilver can be wrong ;)
05:10:29 <Peaker> inconceivable!
05:10:30 <osfameron> the very idea!
05:10:50 * Peaker saw the princess bride rather recently :)
05:12:00 <quicksilver> I've certainly seen cases where two mutually recursive modules was a better solution than one big one - but even better was to factor the core into a third module.
05:12:15 <quicksilver> (A <- C -> B) better than (A <-> B)
05:12:45 <quicksilver> probably that's what Peaker means by layering.
05:13:02 <fasta> Peaker:  Ok, I have a Foo which depends on Fooable. Fooable has a method called foo which returns a Bar, but this Bar contains Foo as a member.
05:14:20 <Peaker> fasta: A bunch of mutually-dependent types/type classes are fine, but Haskell makes it so easy to put the dependent types together in one module, but still put all of the various functions that handle those types layered on top of each other in separate modules
05:14:34 <Peaker> mutually-dependent types rather than value-dependent types, of course :)
05:14:50 <Peaker> functions and instances
05:14:58 <fasta> Peaker: right, that's what I do now, but I feel that those types should be in different modules too.
05:15:16 <quicksilver> fasta: why do you feel that?
05:15:20 <fasta> Peaker: the designers of Haskell agreed with me, at least when they designed the language. The implementors just don't.
05:15:21 <quicksilver> perhaps this is the heart of the question.
05:17:45 <fasta> quicksilver: because I see it that a "thing" should be in its own module. These "things" should be able to refer to any other "things". The fact that they are mutually recursive should not matter.
05:18:49 <osfameron> Peaker: yay!  I can't convince gf to watch that (she didn't even like Labyrinth, and refuses to believe me that PB would be good)
05:18:59 <fasta> "thing"*
05:19:14 <Peaker> osfameron: its only nostalgic good, I think :)  If I watched it for the first time now I'd just think its super silly :)
05:19:56 <fasta> quicksilver: another argument would be that adding a single field to a data declaration could cause the whole thing to be moved to the "solve the mutually recursive dependencies"-module.
05:20:24 <osfameron> possibly.  I cringed at *bits* of Labyrinth.  But I think TPB has enough humour and good actors to have *something* even for the weary postmodern adult.
05:21:13 <fasta> Just the fact that I think about it in this way should hint that it's a bad thing that there are no mutually recursive modules. Also, given that hs-boot files are actually used by the implementors, it seems to suggest that they have found a use-case for them.
05:24:22 <temoto> How to raise Int n to Int power p ?
05:24:53 <dancor> > 2 ^ 4
05:24:55 <lambdabot>   16
05:25:04 <temoto> dancor: thanks.
05:25:44 <dancor> interesting to see someone use irc without getting trapped
05:25:51 <dancor> inspiring
05:26:53 <osfameron> heh
05:28:36 <m`lan> irc. dont ever quit. u might miss sowething lol :)
05:29:02 <m`lan> -w+m too.
05:30:23 <ivanm> dancor: who?
05:30:53 <dancor> ivanm: temoto
05:31:14 <ivanm> oh, comes in, asks question, gets answer and leaves?
05:31:19 <dancor> ya
05:32:21 <ivanm> dancor: so IRC _isn't_ a black hole? :o
05:32:41 <dancor> singularirc
05:34:53 <Philonous> Maybe he's in single user mode :>
05:36:05 <m`lan> :( bit rude tho, he could have rtfm'ed / stfw'ed instead of demanding someone to tell
05:37:10 <dancor> it's fine with me bc if the question had been any harder i wouldn't have been able to answer it
05:38:02 <m`lan> at least he didnt ask if he may ask before actually asking
05:38:43 <temoto> ($) f x = f x, right?
05:39:07 <temoto> Is there (something) f x = x f?
05:39:24 <tomh> flip?
05:39:35 <temoto> @src flip
05:39:35 <lambdabot> flip f x y = f y x
05:39:46 <temoto> @src $
05:39:46 <lambdabot> f $ x = f x
05:39:52 <temoto> not quite
05:40:00 <Workybob> @hoogle a -> (a -> b) -> b
05:40:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:40:00 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
05:40:00 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
05:40:10 <Workybob> no
05:40:12 <Workybob> :P
05:40:13 <temoto> @src $!
05:40:14 <lambdabot> f $! x = x `seq` f x
05:40:30 <tomh> @src length
05:40:30 <lambdabot> Source not found. You speak an infinite deal of nothing
05:40:35 <temoto> It forces to eval x?
05:40:41 <Workybob> tentd: yes
05:41:29 <temoto> @hoogle x -> (x -> y) -> y
05:41:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:41:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
05:41:29 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
05:41:45 <temoto> so it doesn't care how i name params
05:41:50 <Workybob> no
05:41:52 <temoto> @src Data.Function
05:41:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:41:57 <Workybob> a type variable is a type variable
05:42:15 <temoto> ah Data.Function is module
05:42:16 <Workybob> the letter used doesn't matter
05:42:49 <temoto> Why duplicated Prelude and Data.Function ($) ?
05:43:08 <Workybob> because the hierarchical module structure came a long time after the prelude functions were defined
05:43:37 <temoto> Why redefine something that already is in Prelude?
05:43:56 <temoto> Do they want to get rid of Prelude some day?
05:44:30 <Workybob> it's purely a case of ($) belongs in Data.Function
05:44:41 <Workybob> but Data.Function didn't exist when the Prelude functions were defined
05:44:44 <Workybob> so it didn't then
05:45:13 <temoto> hm i guess i can't understand that
05:45:28 <temoto> Thanks for your time Workybob.
05:48:37 <ivanm> has anyone seen oxymor00n recently?
05:48:49 <ivanm> lambdabot hasn't seen him in 25 days, but that could just be due to crashes :s
05:49:08 <Deewiant> preflex: seen oxymor00n
05:49:08 <preflex>  Sorry, I haven't seen oxymor00n
05:49:42 <ivanm> Deewiant: hence why I'm asking the "people" here ;-)
05:50:18 <Deewiant> ivanm: According to my logs that nick hasn't been here in February or March
05:50:19 <ivanm> hmmmm.... might be better to ask in #xmonad, I got my channels mixed up (I knew I talked to him in _one_ of them...)
05:50:35 <ivanm> Deewiant: yeah, I don't think he's ever been in this channel ;-)
05:50:39 <ivanm> thanks anyway
05:50:43 <Deewiant> That would explain it ;-)
05:58:49 <mk15_> hi, I have two fibonacci functions, one extremely quick, and one extremely slow. I was wondering why there is a difference.... source code: http://dl.getdropbox.com/u/256410/fibonacci.hs
05:59:22 <quicksilver> mk15_: the second one reuses old calculations
05:59:39 <quicksilver> mk15_: the first one calculates anew every time.
06:00:04 <dancor> is there anything to generate a Binary instance for you?
06:00:05 <mk15_> quicksilver: thats what I guessed....but it seems to call itself recursively similarly to the first one
06:01:36 <quicksilver> mk15_: it doesn't call itself (like a function)
06:01:42 <quicksilver> mk15_: it accesses itself, for it is a list.
06:03:26 <dancor> also how is the Binary instance for [a] done
06:03:30 <NameAlreadyInUse> so is a monad transformer not a real monad?
06:03:51 <dancor> is it faster (and more space) to record like an isEnd bool with each element?
06:04:01 <dancor> (vs recording the length at the beginning)
06:04:20 <quicksilver> NameAlreadyInUse: a monad transformer is not a type in itself
06:04:27 <quicksilver> NameAlreadyInUse: it's a recipe for constructing types.
06:05:01 <mk15_> quicksilver: hmm I see what you are saying, makes more sense now :) thanks
06:06:06 <quicksilver> dancor: binary instance puts length first yes. And yes it is faster on very long lists not to waste time calculating the length first.
06:06:10 <NameAlreadyInUse> quicksilver: but isn't ListT a type?
06:06:15 <quicksilver> NameAlreadyInUse: No.
06:06:22 <quicksilver> not in the precise sense.
06:06:30 <quicksilver> ListT Maybe Bool is a type
06:06:48 <quicksilver> or at least, ListT does not have kind : *
06:06:57 <quicksilver> "normal types" or "concrete types" are kind : *
06:07:00 <NameAlreadyInUse> oh
06:07:04 <dancor> it's interesting that they chose the more compact form there but the faster/bigger form for like Bool's
06:07:23 <cnwdup> @src ListT (>>=)
06:07:23 <lambdabot> Source not found. I feel much better now.
06:07:48 <dancor> no comment about it in the docs http://hackage.haskell.org/packages/archive/binary/0.5.0.1/doc/html/src/Data-Binary.html
06:07:59 <quicksilver> dancor: if you could assume seekability you could get the best of both worlds.
06:08:02 <dancor> i'm just wondering bc i'm writing a Binary instance for a List-like type..
06:08:09 <quicksilver> dancor: (you could seek back and put the length in at the end)
06:08:18 <NameAlreadyInUse> what does it mean when the kind for (->) is ?? -> ? -> *?
06:08:34 <dancor> quicksilver: what is an example of such a "seekable" type?
06:08:40 <quicksilver> however seekability is incompatible with the basic design of Binary.
06:08:46 <dancor> oh
06:08:48 <quicksilver> dancor: well Handles have hTell.
06:08:52 <quicksilver> or Hseek
06:08:56 <quicksilver> or whatever they call it.
06:09:09 <dancor> i guess i'll make my thing faster and bigger
06:09:21 <dancor> i'm caching abstract-syntax-tree to disk
06:09:24 <dancor> for speed
06:09:59 <quicksilver> I will be interested to hear if it is actually any faster to re-read the binary AST
06:10:06 <quicksilver> than simple re-parse and reconstruct it :)
06:10:06 <chessguy_work> @pl \n -> s n ++ p n
06:10:07 <lambdabot> liftM2 (++) s p
06:10:44 <cnwdup> Are there some guide lines a library should satisfy uploading it to Hackage?
06:10:58 <quicksilver> it would be good if it compiled.
06:11:07 <dancor> quicksilver: ya i'll check of course but i expect so since i've heard parsec is slowish and at least right now my parser has lots of try's in it (some that don't seem easy to optimize out)
06:11:08 <cnwdup> And besides that?
06:11:17 <quicksilver> don't think so.
06:11:39 <quicksilver> dancor: yes, I could believe that.
06:11:52 <dancor> cnwdup: i think they want like everything there and surfacing the more useful stuff somehow is a separate problem
06:12:34 <cnwdup> Ok. Then I feel a little less insecure about making my library public (once I consider it stable enough.)
06:13:26 <wli> I'm waiting on this idiot doctor and trying to smoke out algorithms for determining integral bases of the field and the field given a radical expression over Q.
06:14:46 <dancor> the field and the field?
06:14:52 * dancor needs some parens in there..
06:18:48 * dancor tempted to learn TH for this Binary instance boilerplate..
06:19:03 <Zao> "5. Describe two advantages and two disadvantages of using functional languages for programming parallel systems."
06:19:27 <Zao> Thanks to the awesomeness of Haskell, I had trouble coming up with two disadvantages :)
06:19:36 <dancor> what did you come up with
06:19:45 <quicksilver> disadvantages: You might make other people envious. You might finish your assignment early and go out and commit some crimes.
06:20:00 <daf> haha
06:20:22 <lilac> disadvantages: compared to psychic programming, you actually have to write code, and compared to temporal paradox programming, the code isn't already written
06:20:32 <Saizan_> cnwdup: a proper .cabal file with upper bounds on the dependencies, haddock docs, filled maintainer field, homepage/source repo
06:20:58 <Zao> I went with having to introduce a whole bunch of strictness to be able to send thunks to other nodes as one.
06:21:17 <cnwdup> Saizan_, thanks. I'm going to have those aspects covered.
06:21:41 <dancor> Zao: but there are nonstrict functional langs
06:22:07 <NameAlreadyInUse> Zao: what did you end up putting for the disadvantages?
06:22:10 <Zao> True that. Haskell is the only one I have fresh in memory so I based my answers on that.
06:22:10 <coco`> Why does Haskell have to have "undefined"?
06:22:26 <lilac> coco`: depends what you mean...
06:22:28 <Peaker> coco`: do you understand why Haskell has to have "bottoms"?
06:22:37 <coco`> Peaker: no
06:22:48 <coco`> Peaker: I guess that's my question
06:23:05 <lilac> coco`: if haskell had no bottoms, we'd have to reject programs like 'let x = x in x'
06:23:27 <lilac> coco`: doing that in general is equivalent to the halting problem which is not computable
06:23:32 <coco`> lilac: is bottom the same as undefined?
06:23:42 <Peaker> coco`: Turing completeness implies there are bottoms/undefined values
06:23:52 <quicksilver> haskell doesn't *have* to have explicit access to undefined via a primitive like 'undefined.
06:23:59 <quicksilver> you could miss that out of the language.
06:24:00 <Peaker> coco`: you have to give up turing completeness and prove totality (which is a worthy goal) to get rid of undefined values
06:24:05 <NameAlreadyInUse> coco`: sometimes i use undefined as a "placeholder" value when i am fleshing things out
06:24:16 <quicksilver> but someone else could always write "undefined = let x = x in x"
06:24:20 <lilac> coco`: undefined is a predefined name in the Prelude whose value is bottom
06:24:23 <coco`> I see, so we *have to have* bottom in the denotational semantics, but no "undefined" as a language element?
06:24:29 <dancor> NameAlreadyInUse: yeah tho error "todo" is better for than prob
06:24:33 <quicksilver> right, it doesn't have to be a language element.
06:24:33 <Zao> NameAlreadyInUse: Having lots of unnecessary strictness introduced or suffer having to pass along possibly complex thunks.
06:24:43 <quicksilver> although it's convenient to get a guaranteed error message out
06:24:47 <Peaker> coco`: yep
06:24:48 <quicksilver> instead of running forever.
06:24:56 <lilac> coco`: the denotational semantics don't /have to/ have bottom in the same way that they don't /have to/ have side-effects (and indeed don't)
06:25:16 <Saizan_> for haskell it does
06:25:17 <lilac> coco`: however, removing bottom requires programs to come with a proof that they terminate.
06:25:50 <coco`> lilac: is that realistic? / Peaker: is proving totality realistic?
06:25:53 <dancor> i don't see how explicit undefined is ever better than an error "at least somewhat useful message"
06:25:57 <lilac> coco`: yes, some languages do that.
06:26:04 <lilac> coco`: but no mainstream ones as of yet.
06:26:12 <coco`> lilac: examples? Coq?
06:26:12 <quicksilver> coco`: it's very easy to restrict the language so that only total programs are possible.
06:26:16 <Peaker> coco`: I hope so. I haven't used them :)
06:26:21 <quicksilver> coco`: you just remove recursion entirely :)
06:26:29 <quicksilver> or more pragmaticallys, you limit it somewhat.
06:26:33 <lilac> compared to (partial) functional programming, total functional programming seems to be in its infancy
06:26:38 <quicksilver> Turner wrote a good review paper on this.
06:26:40 <coco`> yeah, System F seems to be such a language
06:27:13 <lilac> coco`: the 'common' way to do it is to require that recursion be well-founded (that is, the arguments in some sense get smaller each time around)
06:27:42 <coco`> but isn't it annoying that undefined is forced on us, even if a function is trivially total?
06:27:53 <quicksilver> yes.
06:27:55 <quicksilver> (sometimes)
06:28:16 <quicksilver> which is why people are writing things like Agda, Epigram, and so on.
06:28:22 <coco`> why not have something like a Maybe type that we have to use if we want to do something undecidable
06:28:26 <Zao> How's Haskell on cluster nowadays by the way?
06:28:28 <lilac> coco`: you can view the progression of languages as becoming more and more 'pure', moving more stuff into monads
06:28:40 <Zao> I realize I've only used it in shared memory machines thus far.
06:28:47 <lilac> coco`: in that sense, a partiality monad is a natural next step
06:29:11 <coco`> lilac: not sure what you mean... is it precise yet?
06:29:19 <lilac> ('functions' would by default be partial unless accompanied by a proof of totality)
06:29:27 <Saizan_> coco`: using undefined/error in "production" code is very bad style
06:29:51 <lilac> coco`: Maybe is actually pretty close to a partiality monad. the only difference is that you can't pattern-match on _|_
06:29:59 <coco`> lilac: hmm, I guess we want a strong decision procedure for that
06:30:15 <NameAlreadyInUse> lilac: you make it sound easier than it is, i think
06:30:59 <coco`> lilac: why can't we pattern-match on undefined?
06:31:14 <lilac> coco`: with dependent typing, you could have a function like "total :: (x :: Partial a) -> (proof :: ProofValueIsTotal x) -> (result :: a)"
06:31:25 <lilac> coco`: because that would require solving the halting problem in general
06:32:13 <coco`> hmmm, when undefined comes from non-termination, but what about user-injected ones?
06:32:53 <quicksilver> coco`: that would break the semantics.
06:32:54 <lilac> coco`: user-injected ones are in some sense equivalent to Nothing, and as such could be pattern-matched in a hypothetical language
06:33:07 <quicksilver> coco`: if you can pattern match on them, they aren't _|_
06:33:16 <quicksilver> it would allow you to write non-monotonic functions
06:33:18 <lilac> coco`: but this comes back to the question of which monads you want to implicitly be in
06:33:20 <quicksilver> (breaking Scott continuity)
06:33:55 <coco`> quicksilver: monotonic?
06:34:19 <coco`> lilac: why does it have to be a monad?
06:34:39 <lilac> In haskell, all types (newtypes aside) are implicitly 'Partial a'. You could create a language where all types were implicitly "Maybe (Partial a)" with a primitive 'user fail' separate from nontermination
06:34:53 <lilac> coco`: it doesn't have to be, but it does happen to be :)
06:35:06 <coco`> lilac: I see :)
06:35:30 <lilac> in some sense this is natural, since monads are kind-of ways of embedding one category into another in some sense.
06:35:35 <coco`> lilac: and when it's trivially total we could leave the Maybe type
06:36:01 * lilac thinks that "in some sense" * 2 + "kind-of" is sufficient vagueness for that sentence
06:37:24 <Peaker> lilac: I think Partial (Maybe a) and not the other way around?
06:37:46 <lilac> Peaker: the types are isomorphic
06:38:00 <lilac> (but yeah, your way around makes more sense! :-)
06:39:16 <dancor> shouldn't there already be an  instance (Enum a) => Binary a  ?
06:39:49 <Peaker> dancor: with overlapping instances?
06:39:52 <lilac> dancor: that would overlap with every other instance
06:40:13 <coco`> so what does ML lose by not having undefined in every type?
06:40:14 <dancor> wouldn't it provide the same implementation?
06:40:37 <dancor> i guess it would store too big of numbers
06:40:39 <lilac> coco`: i suspect ML does have undefined in every type ;-)
06:40:47 <lilac> coco`: or rather, bottom
06:41:29 <coco`> lilac: got you :)
06:41:30 <lilac> coco`: it's probably just less visible because without laziness, if you create a _|_ value your whole program's value is _|_
06:42:04 <coco`> so is it bad to use undefined when writing code?
06:42:46 <lilac> it can be a useful development tool; i know some people start by writing 'foo :: a -> b -> c; foo = undefined' then filling in the function body later
06:43:01 <lilac> although in most (all?) cases, it'd be better to use error rather than undefined
06:47:27 <quicksilver> coco`: 'monotonic' is an important theoretical property of haskell's semantics
06:47:37 <quicksilver> it basically means no function can make a value 'more defined' than it already was.
06:47:49 <quicksilver> obviously being able to pattern match on undefined would break it.
06:48:03 <quicksilver> that property is necessary to give a semantics to recursion, though.
06:48:09 <quicksilver> at least, it's necessary for the way we choose to do it.
06:48:55 <Peaker> well, in the IO monad you can catch pure exceptions :)
06:48:58 <quicksilver> "scott continuity" is the more accurate term.
06:48:58 <Peaker> and then make the value more defined
06:49:05 <quicksilver> Peaker: that's not making a value more defined.
06:49:09 <quicksilver> Peaker: it's hidden in the IO monad.
06:49:17 <quicksilver> there is no function which makes a value more defined.
06:49:19 <Peaker> and then you unsafePerformIO it :)
06:49:32 <quicksilver> sure, but then you don't have any semantics any more.
06:49:34 <wli> The trouble is that I could end up with larger fields than necessary if I don't do better than nae::::::::
06:50:17 <wli> uh-oh pupil dilation is making it impossible to read.
06:50:46 <dancor> when i try to use http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs to make a Binary instance for my structure Stmt ghc errors with "Possible fix: add an instance declaration for (Data.Data.Data Stmt)
06:51:26 <dancor> i thought that would be automagically done already?
06:52:31 <lilac> wli: you ok?
06:56:25 <ertai> Does someone know at which time haddock documentation is built on hackage ?
06:57:17 <NameAlreadyInUse> @src liftM
06:57:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:57:38 <NameAlreadyInUse> @undo do { x1 <- m1; return (f x1) }
06:57:38 <lambdabot> m1 >>= \ x1 -> return (f x1)
06:57:56 <Saizan_> dancor: no, you need to add deriving (Data), however i'd use Data.DeriveTH from the derive package
06:58:26 <lilac> @pl \f m1 -> m1 >>= return . f
06:58:26 <lambdabot> fmap
06:58:31 <lilac> hah
06:59:24 <NameAlreadyInUse> how can that be right?
07:00:38 <lilac> fmap = liftM for Monads which are Functors
07:00:53 <lilac> (note, all Monad instances can be made a Functor in this way)
07:01:24 <NameAlreadyInUse> oh, you're right
07:01:24 <ertai> moreover all mathematical monads are functors
07:01:53 <lilac> am i right in thinking that functor instances are unique?
07:01:58 <lilac> *Functor instsances
07:02:37 <ertai> lilac: what you mean? That only one functor instance is possible?
07:03:08 <Peaker> More Functors may be possible, but if there's a Monad instance, the Functor instance should have liftM semantics
07:03:34 <lilac> ertai: right.
07:03:57 <lilac> Peaker: got an example? i find it unlikely one exists ;-)
07:04:30 <ertai> lilac: at least we talk about functors in the category Hask (using haskell functions as arrows)
07:04:39 <Peaker> lilac: A tuple of 2
07:04:44 <nj32> is there a library for galois fields?
07:04:53 <lilac> Peaker: there's only one Functor instance for that.
07:04:58 <Saizan_> uhm, it might depend on if we talk about free or quotient types
07:05:06 <Peaker> lilac: you could have a Functor for the other tuple element
07:05:13 <lilac> not as a Functor instance.
07:05:26 <NameAlreadyInUse> so i have ListT Maybe Int
07:05:36 <NameAlreadyInUse> how can i turn this into [Maybe Int]
07:05:38 <Peaker> lilac: oh, technically, no. I thought you meant something else.   What I meant is that tuples' Functor instance should be consistent with the Monad instance
07:05:40 <lilac> specifically, forall a, (AFAICS) there's only one legal Functor instance for "(,) a"
07:05:52 <lilac> Peaker: i agree, but i'm wondering whether that's automatic
07:06:06 <lilac> Peaker: if there's only one Functor instance, then it /must/ agree with the Monad instance
07:06:15 <Peaker> lilac: because you can't have the free type variable not be the last one?
07:06:19 <Saizan_> @unmtl ListT Maybe Int
07:06:19 <lambdabot> Maybe [Int]
07:06:24 <Saizan_> NameAlreadyInUse: ^^^
07:06:25 <lilac> Peaker: in the case of (,), yeah
07:06:32 <Saizan_> :t runListT
07:06:33 <lambdabot> Not in scope: `runListT'
07:06:38 <NameAlreadyInUse> oh, right
07:06:47 <Peaker> lilac: well, the free type variable must always be the last one, in both Monad and Functor, so I think they'll be consistent
07:06:54 <Saizan_> you can pattern match on the ListT contructor, anyhow
07:07:18 <lilac> Peaker: that doesn't guarantee anything. i think it's possible to have multiple legal Monad instances for a type constructor
07:07:43 <NameAlreadyInUse> why does it swap it around though? wouldn't it make more sense to return [Maybe Int]?
07:07:45 <Saizan_> Peaker: the question was if for every T :: * -> * there's only one possible Functor instance or not
07:08:21 <vixey> Saizan: What is the answer ?
07:08:22 <Peaker> Yeah, I think that's true, but not completely certain.
07:08:24 <Saizan_> NameAlreadyInUse: that's how transformers works, [Maybe Int] is what you get from MaybeT [] Int
07:08:39 <Peaker> @free fmap :: (a -> b) -> f a -> f b
07:08:39 <lambdabot> Extra stuff at end of line
07:08:44 <Saizan_> vixey: unknown to us :)
07:08:47 <vixey> initial algebras are isomorphism -- a functor is a map from one initial algebra to another,  -- does this prove it?
07:08:52 <NameAlreadyInUse> Saizan_: why is it like that though?
07:08:58 <vixey> probably my statement about functor is wrong
07:09:11 <Peaker> I'm pretty sure that:     fmap f . fmap g = fmap (f . g)       means that there's only one fmap for T :: * -> *
07:09:20 <lilac> Peaker: not so
07:09:32 <Peaker> lilac: why not?
07:09:48 <lilac> Peaker: newtype A a = A Int; fmap1 f (A a) = A $ a+1; fmap2 f (A a) = A $ a+2
07:09:59 <lilac> Peaker: that class of non-fmaps is ruled out by 'fmap id = id'
07:10:06 <Saizan_> NameAlreadyInUse: you can't write Monad m => Monad (ListT m) where ... if ListT m a = [m a]
07:10:10 <dancor> Saizan_: ok thanks.  i got it working with standalone deriving.  what does Data.DeriveTH win me?
07:10:36 <vixey> I was thinking more parametricity
07:10:40 <Peaker> lilac: right, fmap id = id   destroys that
07:10:44 <vixey> @seen jkff
07:10:44 <lambdabot> jkff is in ##logic and #haskell. I last heard jkff speak 4h 25m 21s ago.
07:10:53 <Saizan_> dancor: you don't have to copy/paste code, you can just $(derive makeBinary ''YourType)
07:10:55 <byorgey> It's definitely a "folklore result" that there's only one functor for each T :: * -> *  but I forget why.
07:11:04 <byorgey> IIRC there was a thread on the ML about this not too long ago.
07:11:09 <Peaker> lilac: the only way I can envision multiple fmap semantics for the same T :: *->*  is the affect on the container, not the contained value (which is too polymorphic).  fmap id = id   mean that fmap is not allowed to affect the container
07:11:09 <lilac> byorgey: it follows from parametricity
07:11:14 <lilac> byorgey: or at least seems to
07:11:20 <byorgey> yeah, that sounds right.
07:11:20 <vixey> lets prove it!
07:11:42 <lilac> byorgey: either the functor contains type 'a' in some sense, in which case 'f' must be applied to all such things (from fmap id = id, it can't just use _|_)
07:11:55 <lilac> byorgey: or it does not, in which case fmap f = id (by fmap id = id)
07:12:14 <quicksilver> intuitively it feels related to parametricity
07:12:18 <quicksilver> I don't see how to prove it though
07:12:21 <lilac> fmap distributing over (.) is required to rule out some insertions of _|_
07:12:39 <lilac> (that is, fmap f can't use f _|_)
07:13:05 * vixey draws a commutative square
07:13:35 <byorgey> hah, I found it: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/48016/focus=48037
07:14:34 <dancor> Saizan_: ah, ince
07:14:35 <dancor> nice
07:18:30 <vixey> I don't get it
07:20:29 <vixey> it's unique because @free says so?
07:23:10 <PCanyi> is there any people here?
07:23:12 <jkff> vixey: Hi, have you seen my message about the book?
07:23:31 <vixey> no jkff but I have encountered a problem
07:23:31 <PCanyi> i am sorry i have not
07:23:38 <vixey> hi PCanyi
07:23:44 <PCanyi> hi~
07:23:52 <PCanyi> where are you from?
07:24:05 <jkff> vixey: Which one?
07:24:10 <PCanyi> you
07:24:13 <PCanyi> no
07:24:14 <jkff> (which problem)
07:24:27 <PCanyi> hehe
07:24:38 <PCanyi> wish all of you a good day
07:24:52 <jkff> Thanks PCanyi
07:25:00 <vixey> :)
07:25:04 <quicksilver> vixey: the actual proof is in this message http://article.gmane.org/gmane.comp.lang.haskell.cafe/48023
07:25:06 <PCanyi> that is all right~^^
07:25:25 <quicksilver> gmane is not very clever - it deosn't cahnge the URL when you click on a different message in the thread
07:25:27 <vixey> quicksilver, that's for [a]
07:25:30 <vixey> I meant
07:25:31 <vixey> []
07:25:38 <quicksilver> right.
07:25:54 <quicksilver> if you accept that proof, you can then see how the same proof applies to all products-of-sums-of-products
07:26:16 <vixey> I wonder if this is true for every category
07:26:18 <vixey> I think not
07:26:25 <vixey> so what categories is it true for?
07:26:46 <quicksilver> I'm not sure what properites of the category the free theorem thingy pivots on.
07:27:10 <quicksilver> but this is probably a property of products and coproducts in a CCC
07:27:26 <quicksilver> an possibly a slightly weaker property than CCC is enough.
07:29:05 <vixey> functors are unique by naturality?
07:31:23 <jkff> Not all of them. There was a thread in haskell-cafe that provided counterexamples: iirc, they were about Either
07:34:51 <djwonk> I'd like to learn some good ways to divide up a module so that it doesn't become unwieldy.  Submodules seem like one way, but I sometimes run into circular dependencies.
07:35:57 <lilac> Lemma: suppose g :: (a -> b) -> (f a -> f b). g f = id => (f = id /\ forall f', g f' = id)
07:37:10 * djwonk looks at http://www.haskell.org/onlinereport/standard-prelude.html to see how the Prelude does it
07:37:53 <djwonk> I didn't realize you could export a module (e.g. "module Prelude (module PreludeList) where"
07:39:40 <mopped> How would I create a dictionary/cache in haskell?
07:39:48 <quicksilver> Data.Map
07:40:16 <mopped> thanks
07:41:16 <djwonk> I have two data types (a Board and a Grid) and I want to provide a conversion from Grid to Board.  Is there a convention in Haskell for what module that code should live in?
07:41:45 <djwonk> i don't expect a combinatorial explosion of conversions
07:41:51 <djwonk> just a few
07:42:45 <NameAlreadyInUse> with ListT, is there some way i can Maybe [a] -> ListT Maybe a
07:42:54 <quicksilver> :t ListT
07:42:55 <lambdabot> Not in scope: data constructor `ListT'
07:43:01 <quicksilver> hmm
07:43:18 <quicksilver> :t Control.Monad.List.ListT
07:43:19 <lambdabot> forall (m :: * -> *) a. m [a] -> Control.Monad.List.ListT m a
07:43:31 <quicksilver> NameAlreadyInUse: that has precisely the type you asked for :)
07:43:40 <quicksilver> although it works for all monads, not just Maybe.
07:43:58 <quicksilver> on the other hand, ListT is not a well-behaved transformer.
07:44:25 <duke83__> hi there. I am very new to haskell and I just started with reading the book "Real World Haskell". For a project at the University I am looking for functional languages which are easy to interface with C. In the mentioned book, there is an example where they use the PCRE library to have Perl's Regex capabilities in Haskell.. it is a very nice example and really helped me a lot.. but I am looking for a way to register Haskell functions as callback function
07:45:37 <duke83__> ... so it should be really a two side thing.. where C may call Haskell and vice-versa..
07:45:40 <djwonk> To answer my own question from above: "For example, it is common to implement a library in several modules, but define the external API by having a single module which re-exports parts of these implementation modules." http://www.haskell.org/haddock/
07:46:14 <quicksilver> duke83__: it can be done.
07:46:18 <quicksilver> duke83__: it's not entirely simple.
07:46:29 <quicksilver> due to the type systems not matching up well.
07:47:01 <Mr_Giraffe> duke83__: it's a little...difficult
07:47:10 <Mr_Giraffe> i mean the type systems not matching up well is part of it
07:47:21 <Mr_Giraffe> but C is very state-based...
07:48:32 <vixey> @free (a,a)
07:48:32 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
07:48:37 <vixey> @free both :: (a,a)
07:48:37 <lambdabot> $map_Pair f f both = both
07:48:49 <duke83__> do you know of a tutorial where this is explained?
07:48:50 <vixey> that's wrong
07:49:33 <Mr_Giraffe> duke83__: no, but you could always poke around the sources for some libraries (openGL comes to mind) that are actually bindings to C libraries
07:50:08 <duke83__> actually I was doing the same thing using erlang... and it worked quite well for our purposes.. perhaps you know some differences
07:50:24 <Mr_Giraffe> well i was thinking in terms of mutation of data in haskell
07:50:37 <Mr_Giraffe> which is, you know, not really how things are "supposed" to work
07:50:55 <duke83__> sorry I don't understand you
07:51:07 <Mr_Giraffe> in haskell you can't say:
07:51:12 <ImInYourMonad> http://www.galois.com/blog/2008/09/12/left-fold-enumerators-a-safe-expressive-and-efficient-io-interface-for-haskell/
07:51:12 <Mr_Giraffe> x = 5 and then x = 6 later on
07:51:14 <vixey> why is this free theorem a lie
07:51:19 <ImInYourMonad> is Johan Tibeel swedish?
07:51:20 <duke83__> thats the same in erlang
07:51:25 <ImInYourMonad> sogoogle uses Haskell now?
07:51:32 <vixey> Mr_Giraffe: yes you can
07:51:36 <stepcut> duke83__: I don't have a tutorial, but check out ShutdownCallback and the next three declarations in this file, http://www.n-heptane.com/nhlab/repos/haskell-jack/Sound/JACK.hs
07:51:41 <vixey> > let x = 5 in let x = 6 in x
07:51:42 <lambdabot>   6
07:51:59 <Mr_Giraffe> vixey: why
07:52:04 <Mr_Giraffe> don't do that D:
07:52:12 <Mr_Giraffe> that's an interesting point, though
07:52:14 <Mr_Giraffe> let's see
07:52:19 <Mr_Giraffe> > let x = 5 in let x = x + 1 in x
07:52:21 <lambdabot>   * Exception: stack overflow
07:52:21 <stepcut> duke83__: that is an example of how to call a C function with takes a callback to a Haskell function. Not sure if that is what you are looking for
07:52:24 <quicksilver> that's somethign different though
07:52:25 <vixey> it's basically that each x has a different name
07:52:27 <quicksilver> they're not hte same x
07:52:30 <Mr_Giraffe> vixey: there
07:52:46 <vixey> > (\x -> (\x -> x) (x+1) 5
07:52:47 <lambdabot>   <no location info>: parse error on input `;'
07:52:51 <vixey> > (\x -> (\x -> x) (x+1)) 5
07:52:53 <lambdabot>   6
07:52:55 <Mr_Giraffe> what i mean is you can't mutate the data the variable contains
07:52:58 <Mr_Giraffe> but see, that's not mutation
07:53:03 <Mr_Giraffe> it's not the same as:
07:53:09 <Mr_Giraffe> int x = 0; x = x + 1;
07:53:56 <quicksilver> Mr_Giraffe: do x <- newIORef 0; modifyIORef x (+1);
07:54:00 <quicksilver> Mr_Giraffe: (I'm just saying ;)
07:54:03 <gwern> http://www.meow.org.uk/stan/xserver/photos.html <-- madness!
07:54:08 <duke83__> stepcut: ok it seems they are also doing some callbacks from C
07:55:27 <vixey> @free both :: forall a. (a,a)
07:55:27 <lambdabot> $map_Pair f f both = both
07:55:30 <vixey> @free both :: forall a. a -> (a,a)
07:55:31 <lambdabot> $map_Pair f f . both = both . f
07:59:14 <lilac> vixey: those look correct to me.
07:59:38 <lilac> vixey: as does the one for 'both :: (a, a)' which is the same as the first of the latter two
07:59:48 <duke83__> for those of you knowing Erlang's FFI how would you compare it to Haskell's
08:00:23 <NameAlreadyInUse> > take 10 (runListT $ ListT [[1..]])
08:00:24 <lambdabot>   Not in scope: `runListT'Not in scope: data constructor `ListT'
08:00:39 <lilac> vixey: hmm, actually, no, that's rubbish... the 'forall a. (a, a)' one is obviously wrong isn't it? :)
08:00:52 <NameAlreadyInUse> why does "take 10 (runListT $ ListT [[1..]])" result in stack overflow?
08:00:57 <vixey> I realized that forall a. (a, a) is simalar to  false :: forall a. a
08:01:08 <lilac> vixey: perhaps @free assumes the values are total?
08:01:08 <vixey> so every thereom about  forall a. (a, a)  is true
08:01:34 <lilac> yep, that'd do it
08:01:53 <quicksilver> @free theorems are only equalities in the total fragment.
08:01:54 <lambdabot> Extra stuff at end of line
08:01:55 <quicksilver> AFAIK.
08:02:01 <quicksilver> like most equalities, to be honest.
08:02:02 <vixey> I'm trying to implement free theorems
08:02:05 <vixey> it's realy complex
08:02:20 <quicksilver> monad laws are only valid in the total fragment, etc.
08:02:37 <NameAlreadyInUse> @src ListT (>>=)
08:02:37 <lambdabot> Source not found. Maybe you made a typo?
08:04:17 <vixey> Theorem (Parametricity Theorem) If f :: t, then (f , f )  R(t).
08:05:49 <NameAlreadyInUse> @src concat
08:05:49 <lambdabot> concat = foldr (++) []
08:05:51 <NameAlreadyInUse> @src concatMap
08:05:51 <lambdabot> concatMap f = foldr ((++) . f) []
08:07:48 <singintime> hello everybody!
08:07:58 <vixey> hi
08:08:14 <vixey> does anyone know what papers to read, to understand parametricity/free theorems better?
08:08:23 <vixey> I already read Wadlers and one by Reynolds
08:15:03 <doserj> vixey: there is some stuff at http://wwwtcs.inf.tu-dresden.de/~voigt/, for example http://wwwtcs.inf.tu-dresden.de/~voigt/free-slides.pdf
08:15:22 <vixey> thanks
08:16:48 <araujo> morning
08:17:59 <vixey> hi
08:22:17 <NameAlreadyInUse> @src ListT return
08:22:17 <lambdabot> Source not found. Take a stress pill and think things over.
08:23:07 <vixey> @free forall a. a -> a
08:23:07 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
08:23:22 <vixey> @free (?) :: forall a. a -> a
08:23:22 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
08:23:45 <NameAlreadyInUse> how would i right the return function for ListT?
08:24:13 <ImInYourMonad> my problem is i dont even know really what os considered a proof.
08:24:38 <vixey> @free i :: forall a. a -> a
08:24:38 <lambdabot> f . i = i . f
08:24:39 <ImInYourMonad> how do we know proof by induction is valid. I mean I have no problem with accepting it is but how do we know it really is.
08:24:51 <LeoD> you can prove proof by induction
08:24:58 <BONUS> NameAlreadyInUse: return x = ListT (return [a])
08:25:11 <ispiked> I'm strugging with figuring out how to make this random sample function work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2649#a2649
08:25:12 <BONUS> i mean return a = ListT (return [a])
08:25:43 <NameAlreadyInUse> thanks BONUS
08:25:57 <BONUS> basically a ListT is a list wrapped in some monad
08:26:15 <BONUS> so we make a singleton list and wrap it in a monad and then we also have to wrap it with the newtype constructor
08:27:27 <scook0> hmm... research.microsoft.com seems to be down for me
08:27:34 <scook0> can anyone else access it?
08:27:57 <LeoD> it's just a little slow
08:27:59 <byorgey> ImInYourMonad: well, if you want to get down to that level, it depends on what formal system you are working in.  In ZFC set theory, you can prove a theorem that says proof by induction works.
08:28:17 <asgaroth> scook0: http://downforeveryoneorjustme.com/research.microsoft.com
08:28:55 <scook0> yeah, I tried that; says it's up
08:29:03 <scook0> but I wanted a human's opinion
08:29:14 <scook0> I keep getting connection resets
08:29:43 <asgaroth> I can access it with acceptable speed.
08:30:26 <quicksilver> byorgey: although depending how you write the exioms, that essentially is one of the axioms I think.
08:32:25 <NameAlreadyInUse> @src mapM
08:32:25 <lambdabot> mapM f as = sequence (map f as)
08:36:08 <NameAlreadyInUse> @src sequencew
08:36:08 <lambdabot> Source not found. You untyped fool!
08:36:09 <NameAlreadyInUse> @src sequence
08:36:09 <lambdabot> sequence []     = return []
08:36:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:36:09 <lambdabot> --OR
08:36:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:36:27 <Workybob> sequence = foldr (liftA2 (:)) (pure []) -- this already!
08:36:34 <Workybob> no need for monads in mapM
08:36:59 <NameAlreadyInUse> @src liftM2
08:36:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:38:24 <ynyr__> scook0: are you in the uk?
08:38:40 <scook0> ynyr: Australia
08:39:01 <ynyr> ah
08:39:07 <ynyr> it's down for me too
08:39:09 <ynyr> (uk)
08:39:36 <cycloid> Hi folks.  A few days ago dons helped me locate a ghc bug re: +RTS -M ... I have another fail case that isn't fixed in the latest RC.  Should I go talk to the folks on #ghc about it?
08:41:39 <vixey> you know this forall case on free theorem
08:41:56 <vixey> say the values x and y are related by "forall a. f a"
08:42:02 <vixey> then what is the next step ?
08:42:48 <cads> morning funtor cats!
08:43:01 <cads> s/fun/funk
08:43:35 <vixey> @free k :: forall a. a -> forall b. b -> a
08:43:35 <lambdabot> f . k x = k (f x) . g
08:43:41 <vixey> @free k :: forall a. forall b. a -> b -> a
08:43:41 <lambdabot> f . k x = k (f x) . g
08:45:55 <lilac> ImInYourMonad: for an intuitive understanding of proof by induction, consider that outside of your formal system of logic you can construct a proof for each value of your set by following the inductive rules. induction says that argument is valid inside the system too
08:53:04 * mmorrow just got a new thinkpad x301 :-)
08:53:35 <pozic> mmorrow: drop it and put a video on your blog! ;)
08:53:51 * mmorrow is waiting for fedora to dl because he doesn't want to accept the windows license agreement
08:54:04 <mmorrow> pozic: :)
08:54:26 <quicksilver> mmorrow: by saying the word "windows" and drawing breath, you have accepted the windows license agreement
08:54:30 <quicksilver> mmorrow: bad luck.
08:54:33 * BMeph thinks dons would want mmorrow to use arch.
08:54:42 * quicksilver . . o O ( Ooops, I did too! )
08:55:01 <mmorrow> quicksilver: they got us good!
08:55:31 <mmorrow> BMeph: i was just debating fedora or arch, and the compiz opengl windowmanager by default with fedora tiped the scales
08:55:37 <mmorrow> *tipped
08:55:38 <quicksilver> debian ftw!
08:55:45 <quicksilver> but anything is better than fedora.
08:55:56 * quicksilver thinks we better not have this discussion. At least not in this channel.
08:55:56 <mmorrow> nuuh!
08:56:20 <cads> what's the haskell offtopic chinazzle?
08:56:35 <fasta> mmorrow: are you going to get a refund for the Windows license?
08:56:46 <mmorrow> fasta: heh, probably not.
08:56:55 <mmorrow> fasta: hmm, how much do those run?
08:56:56 <BMeph> cads: -blah. :)
08:57:04 <fasta> mmorrow: it depends on the country.
08:57:12 <mmorrow> us?
08:57:22 <cads> mmorrow: sell copies of it from under a trenchcoat
08:57:33 * mmorrow wonders with horror what he'd have to go through to get that refund
08:57:47 <fasta> mmorrow: in the us I have no idea, but there probably is someone who already did before.
08:57:55 * mmorrow looks for a trenchcoat
08:58:16 <cads> mmorrow: there is also the pleasure of burning a windows license...
08:58:47 <mmorrow> fasta: i'll check it out. if it involves not wiping the disk in 15:27, then the price is too high ;)
09:00:17 <fasta> If the EU wants to level the market place they just have to have MS set a price on the value of an OEM license and whenever you don't accept the license MS should pay within 5 days.
09:00:42 <fasta> All this "Internet Explorer" nonsense is quite pointless.
09:02:01 * cads sings: "millions of theorems.. theorems for free.. millions of theorems.. theorems for me"
09:02:19 <lilac> fasta: trouble is, machines with windows installed often cost less than those without, because the installer also gets to bundle a bunch of software you don't want
09:02:22 <dons> leksah's looking pretty nifty these days, http://www.reddit.com/r/programming/comments/867ef/leksah_a_haskell_ide_in_haskell/
09:02:32 <lepassive> how powerful is haskell really ?
09:02:42 <cads> lepassive: it is turing complete :)
09:02:43 <lilac> fasta: and various companies are prepared to pay money to get their software preinstalled on your machine
09:02:55 <centrinia> @faq Can Haskell beat every other programming language in any comparison test?
09:02:56 <lambdabot> The answer is: Yes! Haskell can do that.
09:02:57 <lilac> lepassive: with the right extensions, its type system is turing complete too
09:03:14 <lepassive> cads, i mean really, compared to stuff like C# or any fancy OO language ?
09:03:20 <centrinia> lepassive, It can beat every other language in any comparison test. The FAQ says so.
09:03:36 <Igloo> But why would anyone bother programming in a language with a non-Turing-complete kind system?
09:04:05 <lilac> lepassive: haskell is not an OO language. the comparison is hard to make.
09:04:07 <lepassive> centrinia, yes it does, I even wrote my first language in it
09:04:08 <vixey> lol
09:04:11 <fasta> lilac: that's exactly why they should set a price on it; it would make things a lot more transparent.
09:04:15 <cads> lepassive: doing programming grunt work hurts me in haskell... doing high level programming of the kind that is fun hurts me in most other languages
09:04:17 <centrinia> lepassive, How are you comparing Haskell to other languages?
09:04:29 <quicksilver> Igloo: I'm mostly concerned with the expressivity of the metakind system. If a language can't solve the rubiks cube in its metakind system, I fear it will be too limited for everyday use.
09:04:31 <mmorrow> :k \(*->*) -> let * = (*->*) * in *
09:04:32 <vixey> why would anyone use a language with only omega many universes?!
09:04:32 <lambdabot> parse error on input `\'
09:04:53 <dons> quicksilver: too limited for industrialists
09:04:53 <lepassive> centrinia,  very HUGE millions of lines ?
09:05:49 <centrinia> lepassive, Haskell code tends to be shorter than C# and other object oriented programming language code.
09:05:57 <centrinia> There should be a paper about that.
09:06:17 <lepassive> centrinia, I mean, is it only simple apps haskell can do ?
09:06:33 <quicksilver> OO languages promote a certain kind of modularity and reuse which is attractive.
09:06:36 <BONUS> lepassive: the haskell compiler (GHC) is written in haskell
09:06:50 <quicksilver> haskell promotes a rather different kind of modularity and reuse which I find even more attractive :)
09:06:58 <centrinia> lepassive, No. Turing completeness implies that any program that can be written in any other language can be written in Haskell.
09:07:05 <BONUS> basically in haskell you get awesome expresiveness, modularity, composability and you can model your problems in a really high level
09:07:13 <Philonous> When trying to build GHC 6.10.2 RC1 cabal complains about missing libraries that are clearly there
09:07:16 <vixey> centrinia: that's not what turing complete means or implies
09:07:25 <dons> and you get multicore parallelism on the cheap
09:07:31 <dons> this cannot be emphasised enough.
09:07:37 <BONUS> it's very declarative, which allows you to think about what stuff is rather than to think about how you'd do something in a von neuman machine
09:07:44 <BMeph> lepassive: Yes - haskell makes what would be hard in other languages, simple.
09:08:10 <BONUS> also the ease of passing around higher order functions makes it so that you can abstract "control flow" away into functions and achieve really useful generalizations
09:08:29 <Philonous> BMeph: Unfortunately the converse is also true.
09:08:37 <BONUS> laziness allows you to just transform data by composing functions and only what needs to get evaluated does
09:08:40 <BONUS> so in short, it's rly awesome
09:08:41 <lepassive> well that's enough for me really thanks :)
09:08:56 <lepassive> BONUS, when are you going to complete the tutorial ?
09:09:04 <BONUS> ahaha, very soon
09:09:15 <BONUS> a bit busy with school and procrastrination right now
09:09:18 <BONUS> but im working on it
09:09:19 <BONUS> :]
09:09:33 <dons> BONUS: you working on a new tutorial?
09:09:40 <lepassive> BONUS, hope to see it soon!
09:09:41 <BONUS> no, just finishing the current one
09:09:42 <mattam> centrinia: the same functions are computable, not necessarily the same programs can be executed.
09:09:43 <BONUS> :]
09:09:44 <dons> ah i see.
09:09:54 <dons> we need a learnyouamulticorehaskell.org
09:09:59 <BONUS> haha
09:10:04 <BONUS> that would rock
09:10:06 <ImInYourMonad> there was a great pdf book that I think was recommended here that I msut have mistakenly deleted frommy computer. about the axiomatic method and modern amthematics.
09:10:18 <BONUS> actually i'm really surprised that lyah is getting translated into like 4 languages as we speak
09:10:28 <jmcarthur> nice
09:10:28 <vixey> BONUS: wow cool
09:10:53 <dons> it had perfect timing
09:11:19 <BONUS> haha, yeah and i think i managed to fill a certain niche
09:12:30 <Ferdirand> BONUS: do you need translators ?
09:12:31 <jmcarthur> the _why niche?
09:12:41 <lilac> Learn You a Multicore Haskell For Great Perform?
09:12:56 <jmcarthur> lilac: i love that
09:12:59 <BONUS> Ferdirand: anyone's free to translate it :)
09:13:08 <BONUS> the source is online so it's easy to get into it
09:13:27 <BONUS> jmcarthur: i think a niche for people who want to approach functional programming but are kind of scared by it
09:13:31 <Ferdirand> right, but a little bit of coordination can help avoid duplicating effort
09:13:46 <jmcarthur> BONUS: yeah. that was a little tongue in cheek
09:14:03 <BONUS> Ferdirand: yeah that's true. translations are being done to czech, chinese, portugese and french right now
09:14:18 <centrinia> BONUS, how did you make the illustrations? :)
09:14:27 <BONUS> also whoever starts up a translation, i make a title drawing for them, like i did for http://naucte-se.haskell.cz
09:15:15 <BONUS> centrinia: i took a digital pen in my hand and i moved it across a tablet a lot of times hehe
09:16:04 <ImInYourMonad> there was a great pdf book that I think was recommended here that I msut have mistakenly deleted frommy computer. about the axiomatic method and modern amthematics.
09:16:08 <ImInYourMonad> anyone know which one?
09:16:27 <ImInYourMonad> it was written by some dudes who studied math perhaps 30 eyars ago and now wanted to pass iton to umy generation
09:16:30 <dons> BONUS: are they all linked from the main one?
09:16:35 <dons> once the translations are done
09:16:40 <cads> monad, link me if you remember
09:16:55 <BONUS> dons: not yet, but once they're done they will be. i offered to link them now but the translators said they'd rather finish them first
09:17:00 <dons> BONUS: youu should think about publishing it too
09:17:12 <dons> i'm sure after RWH publishers might jump on a completed manuscript
09:17:22 <cads> ImInYourMonad: I read a bit of a book that dealt with finite and combinatorial math, using haskell for implementing algorithms.
09:17:33 <vixey> what's the opposite of free?
09:17:33 <BONUS> yeah i'm thinking about a hard copy, that might be nice
09:17:35 <mmorrow> will i be able to use my wireless to install with the archlinux usb .img?
09:17:41 <BONUS> but of course i have a lot of writing to do first :)
09:17:47 <cads> vixey: american
09:17:52 <dqd> BONUS: Can you please add the exclamation mark to that Czech opening picture? (It's not urgent.)
09:17:54 <vixey> free theorems and _____ theorems
09:18:02 <seliopou> "I never call malloc() without calling free()"
09:18:11 <BONUS> dqd: will do!
09:18:18 <seliopou> so much drama in the phd...
09:18:19 <dqd> Thanks.
09:19:24 * mmorrow takes that as a 50/50 chance
09:19:40 <cads> vixey: I think american theorems doesn't sound bad, but costly theorems sounds cool too.. then again, free theorems can be costly to produce, no?
09:23:17 * mmorrow can't resist the fedora tractor beam..
09:23:36 <brad_larsen> ghc rules question:
09:23:38 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2653#a2653
09:24:05 <brad_larsen> is there any way to make that work, without changing the way `avg' is written?
09:25:26 <doserj> brad_larsen: I don't think so
09:25:55 <lilac> brad_larsen: you could specialize your rule for (/) ;-)
09:26:03 <brad_larsen> yeah, that works, specializing for (/)
09:26:09 <brad_larsen> but i want it to be general!
09:28:00 <ImInYourMonad> what is the common type for Double, Int and Float?
09:28:23 <sjanssen> ImInYourMonad: they're each different types
09:28:36 <sjanssen> they're all instances of Num, if that's what you'r asking
09:28:45 <BONUS> also of Ord
09:28:51 <BONUS> etc.
09:28:52 <ImInYourMonad> I want a function that take a list of doubles, ints or floats and returns a double
09:28:56 <sjanssen> Eq, Show, Read, ...
09:28:59 <ImInYourMonad> i want to restrict the type to those
09:29:12 <quicksilver> the only way to do that is:
09:29:19 <sjanssen> data MyType = AnInt Int | AFloat Float | ADouble Double
09:29:26 <quicksilver> precisely.
09:29:36 <quicksilver> sjanssen++ # finishing my sentence so I didnt have to.
09:29:47 <ImInYourMonad> that sucks
09:29:50 <BONUS> well you could mess about with existentials and typeables too but that's a can of pants
09:29:54 <sjanssen> or you can make them instances of some class and hope a third party doesn't write more instances
09:29:56 <quicksilver> no it doesn't. It's excellent.
09:30:05 <ImInYourMonad> average :: (Integral t, Fractional t1) => [t] -> t1
09:30:15 <quicksilver> the way it works is perfect, above reproach, and much better than what you wanted it to be.
09:30:25 <sjanssen> ImInYourMonad: I challenge you to write it more succinctly in any language
09:30:49 <sjanssen> especially given your insistence that it must be restricted to those three types
09:31:18 <BONUS> so what's wrong with that? if i have a list of some data type that is an instance of Integral and Fractional, i would want to be able to work out the average with that function
09:31:23 <BONUS> instead of it being restricted additionally
09:31:24 <cads> do you guys think haskell could easily be fitted to embedded applications like microcontrollers with 8 bits, very small memory, and very short stacks?
09:31:48 <BONUS> hmm i dont know
09:31:56 <ImInYourMonad> I could in a dynamic language
09:31:57 <quicksilver> cads: No.
09:32:09 <cads> not easily, then?
09:32:21 <sjanssen> cads: there is some work with nhc in embedded applications
09:32:26 <sjanssen> cads: but nothing like that, I think
09:32:28 <quicksilver> cads: good haskell implementations are pretty sure to need pointers.
09:32:34 <quicksilver> cads: 8 bit pointers are not very useful.
09:32:55 <cads> no, no, you don't want to use pointers in a pic :D
09:33:09 <quicksilver> I don't hink you want ot implement laziness without pointers.
09:33:14 <sjanssen> architectures like that are still in use?
09:33:15 <quicksilver> although feel free to prove me wrong.
09:34:07 <cads> I've got this code that runs on this toy helicopter, the toy itself is 30 dollars, the code is stolen intellectual property, and it's C... uses no pointers, heavy bit math for simple things, lookup tables for math functions, et cetera... it's _beautiful_
09:34:45 <quicksilver> sure.
09:34:45 <cads> it's so wonderful, you can see where the signal generator for the communications protocol is implemented as a C routine
09:35:02 <quicksilver> but saying something is beautiful doesn't make it a good target for haskell compilation.
09:35:13 <cads> but man you really realize how constrained that hardware is whilereading the code... functions never nest more than 3 deep
09:35:35 <BONUS> hmm, i bought an ARM9 CPU with some attached memory and I/O that i can directly program, i wonder if i could mix it with haskell somehow
09:35:46 <cads> quicksilver: yeah, it's obvious that it's a terrible target
09:35:55 <cads> haskell wants a more refined woman :)
09:39:09 <cads> I feel like we could use higher level constructs to describe the low level C code in a more comfortable way
09:39:31 <ImInYourMonad> average :: (Fractional t) => [t] -> t , why does that work? it magically converts to float it seems
09:40:05 <BONUS> there's no magic involved
09:40:20 <vininim> > average [1%2,1%4,2%3]
09:40:21 <lambdabot>   Not in scope: `average'
09:40:33 <BONUS> > length "hahaha" :: Float
09:40:34 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2655#a2655
09:40:35 <lambdabot>   Couldn't match expected type `Float' against inferred type `Int'
09:40:36 <BONUS> whoops
09:40:43 <BONUS> > genericLength "hahah" :: Float
09:40:45 <lambdabot>   5.0
09:40:45 <cads> sjanssen: thanks for the tip :)
09:41:02 <ImInYourMonad> well nwo t deosnt work of r ints lol
09:41:30 <ImInYourMonad> so this sucks,i have to have an average function for each type
09:41:42 <BONUS> fractionals are in Num, and you can get the length of a list in any Num instance
09:42:01 <vininim> maybe averaging an int is not what you want
09:42:21 <vininim> *a list of
09:42:45 <sjanssen> ImInYourMonad: to average Int you simply: average $ map fromIntegral  listOfInt
09:42:56 <BONUS> ImInYourMonad: what's the average of [1,4] as an Int?
09:42:57 <fasta> Is there a way to align Haskell code in Emacs in the same way as the vim mode does? In particular the :: in data declarations?
09:43:45 <BONUS> it's pretty much a fractional operation
09:44:21 <ImInYourMonad> Bonus: yes but it should take an int as input
09:44:28 <ImInYourMonad> average of a users movie grades
09:44:35 <ImInYourMonad> [1,4] -> 2.5
09:44:35 <Philonous> when compiling ghc 6.10.2 RC1 cabal complains about missing libraries at stage 2. Did I do something wrong / can I fix/work around that?
09:44:54 <BONUS> then yeah you can do
09:45:28 <Philonous> @src (%)
09:45:28 <lambdabot> x % y = reduce (x * signum y) (abs y)
09:45:36 <Philonous> @type (%)
09:45:37 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:45:42 <BONUS> > let avg xs = sum (map fromIntegral xs) / genericLength xs in avg [1::Int,2,3,4,5,6] :: Float
09:45:44 <lambdabot>   3.5
09:45:51 <BONUS> there we go
09:46:49 <ImInYourMonad> is there no proper round function?
09:47:00 <sjanssen> @hoogle round
09:47:00 <ImInYourMonad> floor,ceiling,round, none is
09:47:00 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
09:47:00 <lambdabot> Text.XHtml.Transitional background :: String -> HtmlAttr
09:47:00 <lambdabot> package HipmunkPlayground
09:47:08 <ImInYourMonad> > round 2.5
09:47:10 <lambdabot>   2
09:47:13 <sjanssen> ImInYourMonad: I don't feel guilty telling you to RTFM now
09:47:13 <ImInYourMonad> ...
09:47:43 <glguy> > round 2.50000000000001
09:47:44 <lambdabot>   3
09:48:57 <fasta> > round (2.5 ::CReal)
09:48:58 <lambdabot>   2
09:49:06 <fasta> That one is a bit odd.
09:49:28 <quicksilver> > round (25%10)
09:49:30 <lambdabot>   2
09:49:34 <quicksilver> so is that.
09:49:40 <glguy>  in case signum (abs r - 0.5) of
09:49:40 <glguy>                                 -1 -> n
09:49:40 <glguy>                                 0  -> if even n then n else m
09:49:40 <glguy>                                 1  -> m
09:49:46 <fasta> @src round
09:49:47 <lambdabot> Source not found. Maybe you made a typo?
09:49:48 <vixey> > map round [1,1.5..]
09:49:50 <lambdabot>   [1,2,2,2,3,4,4,4,5,6,6,6,7,8,8,8,9,10,10,10,11,12,12,12,13,14,14,14,15,16,1...
09:49:53 <fasta> @source round
09:49:53 <lambdabot> round not available
09:49:57 * vixey thanks to ddarius
09:50:02 <glguy> > round 3.5
09:50:04 <lambdabot>   4
09:50:07 <quicksilver> oh, banker's rounding
09:50:09 <quicksilver> of course.
09:50:11 <quicksilver> it's correct :)
09:50:22 <glguy> > map round [0.5,1.5..10]
09:50:23 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10]
09:52:05 <Peaker> > tail . concatMap (*2) $ [0,2..10]
09:52:06 <lambdabot>       No instance for (Num [b])
09:52:06 <lambdabot>        arising from the literal `2' at <inter...
09:52:24 <Peaker> > tail . concatMap (\x -> [x,x]) $ [0,2..10]
09:52:25 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10]
09:52:43 <Peaker> > tail . concatMap (replicate 2) $ [0,2..10]
09:52:45 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10]
09:58:04 <Olathe> > scanl (flip id) 0 (cycle [(+2),(+0)])
09:58:05 <lambdabot>   [0,2,2,4,4,6,6,8,8,10,10,12,12,14,14,16,16,18,18,20,20,22,22,24,24,26,26,28...
09:58:57 <singintime> oh god... i think i've just found why haskell is called haskell :)
09:59:09 <gnuvince> Because of Haskell Curry?
09:59:14 <singintime> yeah...
09:59:26 <glguy> ...
09:59:33 <Peaker> Olathe: :)
09:59:47 <singintime> i knew there was a very clever man called curry
10:00:42 <bremner> finish the limerick!
10:00:52 <singintime> which discovered that the (a*b)->c functions domain can be completely mapped into the a->b->c functions domain (or i think so)
10:01:05 <singintime> and viceversa
10:01:18 <singintime> but i didn't know his first name :)
10:03:57 <Peaker> singintime: its kinda trivial, though, isn't it?  (If * means type product)
10:04:42 <conal> who's to say what's trivial?  may be hard to appreciate from this side of the discovery.
10:05:01 <vixey> Haskell wrote some books on logic
10:05:27 <bremner> I heard H hated his name
10:06:23 <Peaker> conal: I guess a lot of great inventions are trivial after-the-fact
10:06:31 <Peaker>  /discoveries
10:06:48 <Apocalisp> He also disovered that proof systems and computational models are the same kind of thing.
10:06:50 <vixey> why do you think he invent  (a*b)->c --> a -> b -> c?
10:07:09 <vixey> other than the function 'curry' in Haskell ... what evidence is there?
10:07:29 <conal> Peaker: i'd say really profound discoveries often have a feeling of *inevitability* afterward.  not triviality.
10:07:32 <profmakx> n german its sometimes called "schoenfinkeln"
10:07:33 <Peaker> Apocalisp: you mean curry-howard?
10:08:21 <quicksilver> actually I think currying *is* genuinely obvious
10:08:23 <vixey> wiki says Moses Schnfinkel and Gottlob Frege,
10:08:29 <quicksilver> I think what is interesting about it is that it is useful.
10:08:29 <vixey> invented 'currying'
10:08:43 <conal> quicksilver: obvious is binary -- a relation between a thing and a mental state.
10:08:48 <singintime> just heard that on a class
10:08:55 <quicksilver> any fool can see that by fixing one argument of a function you get a function with one fewer argument.
10:09:03 <ddarius> vixey: I believe it is reasonably recognized that Schoenfinkel was the one who explicitly stated the proposition.  There were uses of it by Frege.  Curry was a student of Schoenfinkel if I remember correctly.
10:09:11 <quicksilver> that observation goes back as far as the concept of multiple argument functions.
10:09:18 <singintime> my teacher simply told me :)
10:09:21 <quicksilver> it's what you *do* with that observation that's interesting.
10:09:36 <conal> "At first people refuse to believe that a strange new thing can be done.  Then they begin to hope it can be done. Then they see it can be done. Then it is done and all the world wonders why it was not done centuries ago." - Frances Hodgson Burnett
10:10:02 <singintime> nice quote, conal
10:10:07 <Apocalisp> Peaker: Right, curry-howard
10:10:24 <conal> :)
10:11:18 <quicksilver> conal: I'm familiary with the quote, and the argument.
10:12:07 <ddarius> "Then they do some research and find that it -was- all done centuries ago."
10:12:08 <quicksilver> conal: but I don't feel it applies here.
10:12:18 <vixey> hehe
10:12:25 <lament> moral of the story: Provide more research funding!
10:12:56 <quicksilver> conal: any state of mind which admits the notion of a function with multiple arguments can appreciate that by fixing one of them gives a function with one fewer argument.
10:12:58 <singintime> lament: i totally agree :P
10:13:36 <quicksilver> conal: partial differentiation dates back at least to the 18th century
10:13:41 <quicksilver> probably further.
10:13:44 <BONUS> i think what's not important here is seeing that (a*b) -> c can be mapped to a -> b -> c but the real genius is in asking the question in the first place and then seeing how the answer can be applied
10:13:55 <Apocalisp> singintime: (a, b) -> c <=> a -> b -> c seems pretty trivial, but the implications aren't obvious.
10:14:00 <vixey> I don't think
10:14:01 <quicksilver> BONUS: it's how the answer can be applied that is interesting.
10:14:02 <vixey> :t curry
10:14:03 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:14:10 <vixey> has anything to do with Haskell Currys work
10:14:12 <quicksilver> agree with Apocalisp too. It's the implications.
10:14:26 <Apocalisp> BONUS: Right, the genius is in asking the question "so what?"
10:14:32 <BONUS> i wonder why the function is named curry then
10:14:33 <BONUS> haha
10:14:44 <vixey> it's not like he's some guy that sat about all day currying functions
10:14:49 <conal> BONUS: i'm with you.  genius lies in questioning.
10:15:00 <singintime> i know that in ocaml there's also a builtin function named uncurry
10:15:00 <quicksilver> BONUS: Strachey's fault, according to WP.
10:15:03 <conal> "Discovery is the ability to be puzzled by simple things." - Noam Chomsky
10:15:04 <singintime> same for haskell?
10:15:09 <quicksilver> "The name "currying", coined by Christopher Strachey in 1967, is a reference to logician Haskell Curry. An alternative name, Schonfinkelisation, has been proposed. [2]"
10:15:10 <BONUS> ah
10:15:22 <singintime> (total n00b here speaking :) )
10:15:23 <Apocalisp> Wikipedia says currying was invented by Sch?nfinkel and Frege, and independently by Curry.
10:15:33 <BONUS> well i see why they chose curry instead o f chonfinkelisize
10:15:45 <koala_man> haha
10:15:46 <singintime> bwahahahah
10:15:55 <maxote> "Your brain with all your knowledge has an end, your death" I
10:16:19 <conal> perhaps that's my main gripe with education: it trains people to answer questions more than to question answers.
10:16:36 <dons> mux: why isn't lambdaChess on hackage?
10:16:41 <lilac> @type let schoenfinkel-fregeify f a b = f (a, b) in shoenfinkel-fregeify
10:16:42 <lambdabot> Parse error in pattern
10:16:42 <bos> It's better than no education.
10:16:45 <vixey> conal: I figured pretty quickly the point of being in education was so that you'd /not ask questions/ and /do as you are supposed to/
10:16:53 <singintime> :t uncurry
10:16:54 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:16:59 <singintime> yeah
10:17:00 <conal> vixey: yep :(
10:17:31 <quicksilver> vixey: that's certainly not my experience of education.
10:17:35 <quicksilver> at any level, in this country.
10:17:45 <quicksilver> maybe I was particularly lucky with my teachers.
10:18:02 <conal> bos: humans are wired to learn.
10:18:38 <ImInYourMonad> can you tell quickCheck: "dont try empty lists" if the function isnt defined for it,in my case throws an error
10:18:49 <ImInYourMonad> i dont want to introduce Maybe
10:18:52 <ImInYourMonad> into it
10:19:24 <ImInYourMonad> should average and median use Maybe? because of lists of length 0?
10:19:26 <dons> dcoutts: do you remember why xiangqiboard is not cabalised?
10:19:27 <conal> bos: i'm all for nurturing learning.  just not imposing a preconceived one-size-fits-all educational model.
10:19:30 <BONUS> i find education to be better and more open at the university level here, up until there it's "do what you're told". but that's what makes a lot of people jaded towards education and learning, but i suppose that's a topic for another channel hehe
10:19:44 <dons> http://xiangqiboard.blogspot.com/ since it's one of the nicer 'graphical' haskell apps that people complain we don't have any of
10:20:34 <lament> "Xiangqiboard only supported the HoiXiangqi engine until now, which seems to be not around anymore."
10:20:40 <dons> interesting
10:20:43 <lament> "You can still download the source code, if you are interested. But you will not be able to play Xianghi with the software anymore for the time beeing. "
10:20:46 <lament> maybe that's why?
10:20:48 <conal> personally i was very lucky with undergrad (college of creative studies at ucsb) and grad (cmu cs).
10:20:53 <singintime> bye guys, see you in a couple of hours
10:21:10 <doserj> ImInYourMonad: not (null xs) ==> prop
10:21:19 <doserj> @type (==>)
10:21:20 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
10:21:34 <ImInYourMonad> quickCheck (\s -> median s < (fromIntegral $
10:21:34 <ImInYourMonad>                                 (L.sort s) !! ((div (length s) 2) + 1)))
10:21:39 <ImInYourMonad> how do I add that to it?
10:21:48 <dons> dcoutts: what's the standard way to upgrade gtk2hs errors about Main.hs:238:7: Not in scope: data constructor `LeftButton'
10:22:37 <doserj> \s -> not (null s) ==> median s < ...
10:23:48 <ImInYourMonad> i really hate haskells intendation sensitive syntax, is there some language extension to tur  it off?
10:23:54 <dons> dcoutts: i'm thinking we should have a clearer overview of canonical gui and graphical apps
10:23:58 <quicksilver> ImInYourMonad: just don't use it.
10:24:02 <quicksilver> ImInYourMonad: use { ; and } instead
10:24:05 <dons> so we've one or two nice ides, some good gtk apps, some good opengl apps
10:24:14 <quicksilver> ImInYourMonad: another thing you would find in the docs if you bothered to read them.
10:24:14 <dons> but they're kinda all over the place and hard to reference
10:24:16 <lament> ImInYourMonad: Just write everything in one line.
10:25:00 <quicksilver> dons: I think "one or two nice ides" might be raising false expectations.
10:25:08 <quicksilver> dons: we have "one or two promising ides in development"
10:25:11 <dons> well, leksah is a nice example
10:25:14 <dons> of a gui app
10:25:17 <quicksilver> yes it is.
10:25:18 <ddarius> "one or two nice ides that nobody uses"
10:25:22 <dons> sure.
10:25:23 <BONUS> i rarely get into fights with the indentation syntax
10:25:24 <BONUS> idk
10:25:30 <quicksilver> I love the indentation.
10:25:32 <lament> what do you mean nobody, there was that schemer's post
10:25:34 <dons> leksah.org
10:25:35 <quicksilver> but you don't have to use it.
10:25:46 <BONUS> i like it too
10:25:47 <lament> who switched scheme->haskell because of leksah?
10:25:50 <dons> still, i'd forgotten all about leksah
10:25:55 <dons> lament: yeah :)
10:26:00 <quicksilver> dons: it's certainly come along impressively.
10:26:15 <dons> so i just want these in one place, so people can contribute, and we can refer to them.
10:26:21 <ddarius> Even if there were a "nice" IDE for Haskell, I wouldn't care to use it.
10:26:25 <ozy`> hmm, leksah is one of those GTK apps that can be so troublesome on macs.....
10:26:26 <zachk> i switched from scheme to haskell because i (became (oh (so (list tired)))) of its syntax
10:26:51 <zachk> and the lack of decent libraries and a real compiler(referring to schme)
10:26:52 <vixey> how can you 'switch'
10:26:56 <lament> leksah looks very nice!
10:27:09 <dons> ah, and himerge. http://www.haskell.org/himerge/
10:27:09 <ddarius> :t \i became oh so list tired -> i (became (oh (so (list tired))))
10:27:10 <lambdabot> forall t t1 t2 t3 t4 t5. (t4 -> t5) -> (t3 -> t4) -> (t2 -> t3) -> (t1 -> t2) -> (t -> t1) -> t -> t5
10:27:12 <quicksilver> vixey: by deciding that for your new programming projects you will use language X not language Y
10:27:12 <thoughtpolice> i recently got it working on windows
10:27:14 <dons> another good gtk app
10:27:16 <vixey> it's not like you live inside a programming language (hopefully ones brain is not confined to such a deserted place)
10:27:19 <zachk> vixey: you stop writing code in one language and start to learn another
10:27:36 <zachk> vixey: my brain prefers deserted areas
10:27:37 <thoughtpolice> i'm actually setting up leksah on my friend's vista box so he can code haskellz :)
10:27:40 <quicksilver> vixey: most hobby programmers use primarily one language for hobby products.
10:27:42 <quicksilver> projects.
10:27:50 <lament> vixey: You perform a lobotomy on yourself, removing the areas affected by having learned the old language, and start learning the new one.
10:28:03 <vixey> yeah the lobotomy  bit is slightly worrying
10:28:07 <ddarius> Most programmer use primarily one language.
10:28:14 <lament> Chinese.
10:28:16 <ddarius> s/programmer/programmers/
10:28:20 <vixey> it seems like you could, rather than 'switch', add to what you already know
10:28:33 <quicksilver> of course you add to what you know.
10:28:44 <quicksilver> but if you choose one language primarily above others for new projects
10:28:47 <thoughtpolice> i don't think the word 'switch' is meant to be taken so literally.
10:28:48 <quicksilver> then that is a 'switch'
10:29:01 <vixey> there's another problem of switching, that people demand features from old language to be added to new language -- such as TCO into java
10:29:21 <quicksilver> ddarius: well, most programmers I know use two. The one they are required to use at work, and the one they choose to use outside work ;)
10:29:22 <ddarius> vixey: Java should have TCO for reasons unrelated to other languages.
10:29:29 <vixey> this seems to me like entropy making everything mudge toward a grey mass
10:29:42 <lament> vixey: I know! I switched to haskell from Python, and I keep demanding objects and everybody just tells me to go away.
10:29:44 <BONUS> whats TCO again?
10:29:45 <dons> gtk2hs' site needs a list of example apps by category
10:29:50 <Apocalisp> @check \a b c -> (a && b == c) == (a == (b == c))
10:29:51 <lambdabot>   "OK, passed 500 tests."
10:29:57 <thoughtpolice> BONUS: tail call optimization
10:30:00 <BONUS> ah
10:30:08 <ddarius> quicksilver: Most programmers I know use one.  The one they use at work.
10:30:09 <iago_> lament, why objects?
10:30:21 <ddarius> lament: Go away.
10:30:22 <thoughtpolice> BONUS: currently isn't implemented by hotspot - this is why clojure for example has to have 'recur', so it can properly optimize things
10:30:42 <BONUS> ah i see, so it's a JVM thing?
10:30:53 <zachk> i just wish functions were first class in java. i figured out a way to make map in it but it is like 3 lines of code to do a call
10:31:05 <ddarius> zachk: Try XSLT.
10:31:06 <vixey> BONUS: It's just one example of a general theme I am noticing
10:31:10 <iago_> lament, sometimes people need time to adapt, I though Haskell need some things that with time I see that aren't needed
10:31:10 <lament> iago_: as a practical, efficient, convenient means of namespace compartmentalization; and because sometimes inheritance is really nice
10:31:13 <vixey> adding Lambdas to C++0x is another example
10:31:15 <BONUS> aha
10:31:18 <Apocalisp> @djinn ((a, b) -> c) -> a - > b -> c
10:31:18 <lambdabot> Cannot parse command
10:31:18 <vixey> sory,
10:31:25 <vixey> adding "closures"to C++0x is another example
10:31:30 <thoughtpolice> there's someone out there working on getting TCO into hotspot - recently actually - but it won't be in the next major jvm/jdk release (v7 or something?) for sure and there's no telling when it will be
10:31:32 <Apocalisp> @djinn ((a, b) -> c) -> a -> b -> c
10:31:32 <lambdabot> f a b c = a (b, c)
10:31:36 <quicksilver> ddarius: yeah. I misspoke really. I meant "a common reason to use two is..."
10:31:41 <BONUS> zachk: yeah i implemented a filter and map with anonymous inner classes, lol. like 4 lines of boilerplate code to do filter (>3)
10:32:05 <iago_> lament, I think Haskell need ML-like modules, but not objects
10:32:06 <papna-work> I actually tend to find it interesting that most good programmers switch between multiple languages for various tasks.
10:32:32 <quicksilver> papna-work: I hear people talking about that more than I see them doing it.
10:32:37 <lament> iago_: i suppose that would solve the namespace problem in a similar fashion
10:32:40 <mux> dons: lambdach... oh damn! probably because I haven't touched this in ages and it's totally not functional besides showing up a nice GUI
10:32:44 <lament> iago_: but i don't know ML
10:32:47 <zachk> ddarius: how does xslt add first class functions to java
10:32:47 <kynky>  best tool for the job?
10:33:01 <ddarius> papna-work: More they have to for a variety of reasons.
10:33:20 <BONUS> i do that quite often. although i usually choose either Haskell, C or Python and very rarely Java
10:33:28 <papna-work> ddarius: Of course it is by necessity ;)
10:33:29 <zachk> lamet: from what ive seen ml is quite similar to haskell. except you get state. some of the functions are renamed and the libraries are different but they arent worlds apart
10:33:45 <lament> zachk: in particular, i don't know how ML modules are different from Haskell modules
10:33:46 * ddarius uses C#, VB, Javascript as well as things like SQL, XSLT, etc. to do his job.
10:33:50 <lament> except i vaguely heard that they were first-class
10:33:54 <quicksilver> kynky: best tool for the job is an excellent argument.
10:33:59 <bmh> huh... I don't see an implementation of the Burrows-Wheeler Transform on Hackage
10:34:08 <ddarius> lament: They are not in most MLs.
10:34:12 <quicksilver> kynky: but in practice I find that haskell is the best tool for almost any programming job I choose to attempt.
10:34:29 <quicksilver> kynky: which is of course a subjective notion of 'best'
10:34:31 <iago_> lament, ML modules could be parametrized and instantiated
10:34:42 <lament> sounds pretty first-class
10:34:58 <kynky> unless the requirements for a customer specify another language, or if architure targeted doesnt support haskell ?
10:34:58 <lament> parametrize with types?
10:35:11 <papna-work> quicksilver: People tend to like talking about things more than doing them. Still, I've seen several scientific applications written in Fortran for the math with C for the interface with Python embedded, or for example you see a lot of web development using (X)(HT)ML+maybe domain specific stuff on the+javascript+whatever scripting language.
10:35:13 <dons> mux: i'd forgotten about it. but you might want to toss it up on hackage so it's not lost
10:35:20 <thoughtpolice> ddarius: do you mean higher-order functors? sml/nj has that for sure,not sure of anything else...
10:35:23 <Saizan_> lament: and other modules
10:35:23 <lament> or just plain old parametrize
10:35:24 <ddarius> lament: They are not run-time values, rather there is effetively a language of functors and modules that can manipulate modules.
10:35:35 <quicksilver> kynky: yes, those would be good reasons :)
10:35:43 <ddarius> You can't, for example, build one based on user input.
10:35:50 <kynky> also level of experience in prpgramming language matters too :)
10:35:54 <lament> ah
10:36:08 <lament> sounds pretty limited then!
10:36:09 <quicksilver> papna-work: well HTML/XML are not programming languages.
10:36:13 <papna-work> quicksilver: Or the fact that a C project is apt to be interpersed with C preprocessor stuff which is very different in form and semantics, and that it is likely to be compiled with a Makefile or some other system that probably has a language of its own.
10:36:24 <mux> dons: yeah. it'd be even better if I could actually make it usable
10:36:25 <ddarius> lament: Alice ML may have full first-class modules.
10:36:30 <quicksilver> papna-work: JS is a forced choice. I'd rather use haskell as a scripting language in a web browser but I can't.
10:36:31 <papna-work> quicksilver: I almost qualified myself.
10:36:32 <BONUS> a lot of games use a combination of C++ and an interpreted language
10:36:36 <ddarius> Certainly they can be loaded at run-time.
10:37:02 <quicksilver> papna-work: one of the things that annoys me most about web programming (which I do a lot of ) is the forced context switch because you have to use JS at the client end.
10:37:39 <papna-work> quicksilver: I didn't say it was a matter of choosing the best tool for a job. I meant it required a lot of switching of tools.
10:37:44 <mux> did the 1000th package went it already? :)
10:37:48 <ozy`> quicksilver: heh, are you looking forward to the widespread availability of JS on servers? :p
10:37:53 <quicksilver> papna-work: yes, it does.
10:38:43 <iago_> lament, example http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.html
10:39:26 <Alpounet> lament, ML modules are _nearly_ 1st class
10:39:34 <Alpounet> not exactly
10:39:46 <Alpounet> we can pass them to functors
10:39:47 <Alpounet> return them
10:40:03 <Alpounet> but we can't make a list of modules, or store them in a record
10:40:06 <quicksilver> ozy`: well, JS is not a bad language.
10:40:07 <Alpounet> e.g
10:40:20 <quicksilver> ozy`: it might be my favourite dynamic language; so it woudl not be a terrible server-side language.
10:40:30 <lilac> quicksilver: JS is not a bad concept, but it's a reasonably poor implementation of that concept ;)
10:40:31 <quicksilver> ozy`: client-side haskell would be better though.
10:40:37 <ozy`> quicksilver: yeah, it's nicer than a lot of the alternatives
10:40:38 <kynky> as inyou could write a plugin for browsers that supported haskell, and so that it can be accessed through the dom, think few year ago, you could easily have pluggable activescripting in ms apps, so could easily add ms implementation of haskell in combonation with mshtml.dll to write own browser or a browserhelperobject to be used by ie i think, guess even easier with firefox
10:40:48 <quicksilver> lilac: really? which parts do you find to be cool?
10:40:52 <quicksilver> lilac: sorry, poor?
10:40:53 <ozy`> quicksilver: I dunno if we'll ever see client-side haskell except in plugins....
10:41:04 <lilac> quicksilver: its scoping rules and the behaviour of 'this' are both pretty pathetic
10:41:04 <quicksilver> yhc has a javascript backend.
10:41:13 <Baughn> @seen Schmidt
10:41:14 <lambdabot> Schmidt is in #xmonad and #haskell. I don't know when Schmidt last spoke.
10:41:15 <ozy`> oh right
10:41:18 <mux> if EMCAScript 4 ever happens, it'd be my favourite dynamic language
10:41:19 <thoughtpolice> yeah
10:41:25 <thoughtpolice> haskell-in-browser has been done
10:41:38 <quicksilver> lilac: ah yes. "with" is broken and "this" is only useful is used vae
10:41:40 <quicksilver> carefully.
10:41:43 <kynky> found early js limiting, but they all concentrating on speeding up js, cos alot of ppl already exprienced in it for we stuff, so easier if ppl used that than learnt something else
10:41:52 <conal> i'd like to do a haskell-based browser plug-in.  has any worked on such a thing?  there's probably reusable work there.
10:41:52 <thoughtpolice> i wonder if/how much farther the js backend for yhc has gotten lately...
10:42:05 <quicksilver> lilac: but if you pick and choose the bits you use, it is not a bad language. Reasonably expressive, reasonably concise.
10:42:13 <thoughtpolice> conal: there was a port of ghc 6.8.2 to javascript (with the RTS written in parts of js etc..)
10:42:24 <quicksilver> lilac: the "everything by reference" nature of variable capture is intuitively surprising until you get used to it.
10:42:38 <mux> yeah, js has been plagued by the infamous browser compatibility problems and the poor DOM API
10:42:46 <mux> but it's cool
10:42:50 <thoughtpolice> a ha!
10:42:51 <thoughtpolice> http://vir.mskhug.ru/
10:42:51 <p_l> fortunately current libraries help
10:42:53 <lilac> quicksilver: toString on bool is a cockup
10:42:59 <quicksilver> yeah I was completely ignoring browser/DOM stuff
10:43:00 <conal> thoughtpolice: sounded pretty cool.  i'm thinking of running ghc-compiled code in a browser.
10:43:04 <thoughtpolice> javascript backend for GHC!
10:43:08 <mux> jquery, prototype & friends sure make life easier if you're doing web dev
10:43:09 <quicksilver> since I was talking about the language.
10:43:11 <lilac> quicksilver: true.toString() == "true", but true == "1" and true != "true"
10:43:12 <p_l> (and lately MS and Mozilla have been cooperating on common APIs for new features O_OI)
10:43:27 <quicksilver> lilac: yes, that's pretty absurd.
10:43:36 <kynky> well you had  javascript from netscape, then ms jscript then ms putting forward emcascript spec
10:43:37 <lilac> quicksilver: 31 of its 56 reserved words are not used
10:43:43 <conal> has anyone here played with making Firefox plugins?
10:43:57 <lilac> quicksilver: 'void' and 'delete' are pointless
10:44:26 <mux> void shouldn't be part of ecmascript
10:44:32 <mux> I didn't even know there was a delete keyword.
10:44:59 <gwern> in the lambda, the mighty lambda, the haskell evals tonight
10:45:27 <inimino> lilac: why would you say void and delete are pointless?
10:46:09 <gwern> @remember LeonardoDaVinci Those who are enamored of practice without theory are like a pilot who goes into a ship without rudder or compass and never has any certainty where he is going. Practice should always be based on a sound knowledge of theory.
10:46:09 <lambdabot> Done.
10:46:13 <gwern> @flush
10:46:45 <conal> gwern: nice!
10:47:00 <gwern> heh
10:47:35 <lilac> inimino: because 'void' == 'function(x){}' and 'delete x' == 'x = undefined'
10:47:44 <dancor> tho isn't there some b.s. with 'void 0' is actually faster than 'undefined' bc undefined has to check in each layer of scoping if undefined has been redefined..?
10:48:07 <lilac> dancor: but why would anyone ever write 'void 0'?
10:48:13 <dancor> err void(0)?
10:48:20 <inimino> lilac: yes, but void has some utility in javascript: URIs
10:48:48 <lilac> inimino: 'javascript:void' is a hack which only uses JS because it's convenient AFAICS
10:49:09 * quicksilver imagined that 'delete x' was intended to be a stronger hint to the GC that I'd like x destroyed *now* please.
10:49:12 <inimino> lilac: like anything, it adds expressiveness to the language, at some small cost
10:49:18 <gwern> @quote Gwern
10:49:18 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
10:49:24 <gwern> good
10:49:25 <gwern> @quote gwern
10:49:25 <lambdabot> gwern says: The Java programmers will welcome us as liberators! I estimate that we will need 50,000 haskellers at most and will be able to wind up the occupation quickly
10:49:27 <mux> quicksilver: well that's what it is in the end
10:49:29 <gwern> @flush
10:49:38 <lilac> inimino: it's syntactic sugar which is unnecessary and not common enough to be worth it IMO
10:49:56 <inimino> lilac: and you're wrong about delete, those aren't equivalent
10:50:03 <mux> it probably made C++ guys happy
10:50:15 <dancor> #lang-freeforall
10:50:22 <lilac> inimino: i must have misread/misunderstood the ECMA standard :) it was a while ago
10:50:30 <kynky> thought haskell already had a big influence on the java language
10:50:41 <lament> i have a book javascript: the good parts
10:50:45 <lament> very good book!
10:50:52 <lament> its advice about void is simple: never use void.
10:50:54 <mux> haskell is a great tool to point at deficiencies in other languages
10:50:56 <inimino> lilac: you could make a case for not having void(), granted
10:50:59 <lilac> the good parts of javascript are a nice language
10:51:08 <lament> yes, that's the point the book makes
10:51:15 <gwern> kynky: just generics iirc
10:51:16 <lament> inside javascript there's a good language trying to get out ;)
10:51:50 <gwern> scheme, specifically
10:51:56 <inimino> I'm more concerned with things the language lacks than historical cruft it still has
10:52:01 <lament> (whereas haskell, it seems, is stuck inside a good language we haven't discovered yet...)
10:52:23 <ImInYourMonad> *Test> average [-1,-2]
10:52:23 <ImInYourMonad> -1.5
10:52:23 <ImInYourMonad> *Test> average [-1151694474,-995789175]
10:52:23 <ImInYourMonad> 1.0737418235e9
10:52:38 <gwern> heh heh. don't worry, eventually the dependent type guys will get it all worked out
10:52:39 <mux> I can smell integer overflows
10:52:51 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2686#a2686
10:53:28 <inimino> lilac: delete removes a property from an object, "= undefined" just sets it to undefined, but the object still has that named property
10:53:41 <ImInYourMonad> ^^ why does that give the wrong answer
10:53:42 <lilac> inimino: are those two states distinguishable?
10:54:23 <inimino> lilac: yes, as with hasOwnProperty, or for-in, or in
10:54:26 <mux> ImInYourMonad: as I said, this is an integer overflow, your types are constrained to Int
10:54:46 <mux> ImInYourMonad: at least "summa" needs to be an Integer
10:55:19 <mux> > maxBound :: Int
10:55:20 <lambdabot>   9223372036854775807
10:55:39 <mux> what the heck
10:56:00 <doserj> > maxBound::Int32
10:56:02 <lambdabot>   2147483647
10:56:04 <mux> looks like lambdabot is compiled on steroids without seriously big Int's
10:56:27 <doserj> lambdabot is running on 64bits
10:56:36 <mux> ImInYourMonad: more specifically, the expression "summa + x" constraints summa to be an Int since x is an Int
10:57:08 <mux> ImInYourMonad: (and since the addition operator takes two identical types)
10:57:13 <mux> :t (+)
10:57:14 <lambdabot> forall a. (Num a) => a -> a -> a
10:59:29 <mux> doserj: I somehow assumed that Int's were the same on 32 and 64bits architecture, probably because with C, int's usually stay 32bits
11:00:11 <doserj> mux: haskell /= C :)
11:00:24 <mux> sure, sure :-) *punishes self*
11:00:36 <eyeris> I am trying to build leksah. It tells me I have unmet dependencies, one of which is parsec. It says I need parsec >=2.1.0.1, but cabal update, then cabal install parsec says that it is up to date. What a I doing wrong?
11:01:11 <Botje> eyeris: cabal install --global, perhaps?
11:01:21 <eyeris> Wtf if --global?
11:01:21 <conal> The meaning of Haskell's Int type varies from one implementation/machine to another?
11:02:07 <doserj> conal: yes
11:02:10 <jmcarthur> conal: haskell guarantees at least 30 bits for Int i think
11:02:22 <lilac> eyeris: --global installs globally, --user installs for the user
11:03:10 <jmcarthur> there's always Data.Word if deterministic overflow is important
11:03:17 <dons> huh. leksah's kinda awesome.
11:03:21 <eyeris> lilac, I see that, but how is that not retarded? I will eventually have to install the program as root, so when I run Setup.hs as root for the uninstall, it will not detect my user-specific packages.
11:03:28 <conal> wow -- all this time, i've believed that Haskell's pure types had particular denotations.  i'm shocked.
11:03:34 <dons> screenshot of xmonad src imported as a project, http://galois.com/~dons/images/xmonad-leksah.png
11:04:03 <jmcarthur> conal: yeah, i'm not a big fan of Int's spec either
11:04:09 <eyeris> In any case, I've installed parsec as the same user configuring leksah
11:04:27 <conal> jmcarthur: it's a pretty basic blow to the possibility of a simple denotational semantics for haskell.
11:04:37 <conal> jmcarthur: for *pure* Haskell
11:05:33 <jmcarthur> yeah
11:06:22 <jmcarthur> multiword anagram algorithms are fun
11:07:25 <lilac> eyeris: why will you eventually have to install the program as root?
11:08:02 <lilac> eyeris: it would be retarded if you could have global packages depending on user-specific packages (what happens if you're not that user?)
11:08:59 <eyeris> lilac: I won't have to install it as root. That language was imprecise. What I meant was, if I want to install it, I will have to do so as root (or, at least, as a user different from the user I used to compile and test it)
11:09:00 <lilac> haskell should get a 'designed by smart people' logo
11:09:14 <lilac> eyeris: why?
11:09:43 <eyeris> lilac Why talk to me if you just want to chest thump?
11:10:00 <BONUS> lilac: i prefer: designed by guys with PhDs
11:10:05 <lilac> eyeris: i'm trying to understand what your problem is. i install packages as myself all the time
11:10:07 <BMeph> conal: You could slways cheat, and decline putting Int into...hmm, Integer uses Int specifically in Integer definitions. Never mind. :\
11:10:07 <eyeris> /usr is not writable by my user, for good reason.
11:10:13 <BMeph> *always
11:10:24 <lilac> eyeris: cabal install --user does not instasll to /usr for exactly that reason
11:10:29 <eyeris> OMG
11:10:48 <lilac> cabal install --user installs (by default?) into ~/.cabal
11:11:05 <conal> BMeph: i don't mind if Integer uses a non-semantic type like Int as part of an inaccessible implementation.
11:11:15 <eyeris> My user cannot run the install step because I am unable to write to /usr.
11:11:49 <ozy`> grrrmnggmnrrufhn
11:11:52 <eyeris> Therefore, if I build leksah as my user, then run the install step as root, then both root and my user will need the same packages
11:11:52 <lilac> eyeris: (sorry to ask the "obvious", but...) are you using the --user switch?
11:12:07 <eyeris> In either case, I've solved my problem.
11:12:10 <eyeris> cabal-install is old
11:12:19 <ozy`> how can I set up ghci to interpret ^W as "delete a (whitespace-separated) word" instead of "delete a line"?
11:12:24 <doserj> conal: I don't think anyone will complain if you define a denotational semantics where the meaning of Int is some Z/nZ for some n=2^k, even if the report doesn't specify that :)
11:12:49 <eyeris> Which, I forgot, is because cabal-install can't seem to sort out it's own dependency hell.
11:13:03 <lilac> doserj: i'll complain. i like negative numbers to work properly :)
11:13:12 <conal> doserj: if i did, then ghc would implement the semantics incorrectly.
11:13:59 <BMeph> conal: Oh, well then, it's on again. Kick 'Int' out of your "simple denotational" description, and only use bit-specific types (which is objectionable in its own way), such as Int32, Int64, etc. :)
11:14:30 <doserj> lilac, conal: where is the problem?
11:14:36 <lilac> doserj: Ord?
11:14:36 <eyeris> And I can't manually sort it out because Cabal 1.6.0.2 doesn't compile properly on amd64
11:15:19 <lilac> doserj: although the Ord semantics don't follow from a semantics of Z/nZ so maybe that's OK
11:15:20 <conal> doserj: i like programs to have precise & simple (tractable) meanings.  for me, it's the heart of reasoning about programs.
11:15:41 <conal> doserj: now i learn that even the type Int doesn't have a simple & precise meaning.
11:16:06 <conal> doserj: that instead the meaning of Int is execution-dependent, like IO.
11:16:07 <lilac> doserj: also, it kinda rules out efficient implementation on any clunky old sign-magnitude machines people might have kicking around ;-)
11:16:28 <BMeph> Now, if Haskell had a balanced-trinary numeric type, that would be "serious fun"...w/e that means. ;)
11:16:47 <lilac> conal: Integer should satisfy your concerns
11:17:19 <lilac> conal: the Haskell semantics of using any Int greater than (IIRC) 2^30 is implementation defined at best
11:17:22 <conal> lilac: it does, for Haskell programs that don't use Int.
11:17:40 <c_wraith> BMeph: That type is a little unwieldy if your hardware doesn't support it. :)
11:17:43 <BMeph> conal: Int32/Int64 sounds made for you. :)
11:17:59 <conal> BMeph: indeed.  Glad to be disillusioned.
11:18:04 <Saizan_> eyeris: i'm on x86_64 and "cabal install cabal-install" works perfectly
11:18:12 <Saizan_> eyeris: which problem are you having?
11:18:16 <lilac> conal: i can understand your disappointment
11:18:29 <BMeph> c_wraith: And hardware supports linked lists? ;)
11:18:47 <Saizan_> eyeris: if you cabal-install is too old you can use the bootstrap.sh script, or the cabal.exe on the download page if you're on windows
11:19:14 <conal> for me functional programming is all about simple denotation.  i'm gradually learning that FP is something different to many folks.
11:19:45 <eyeris> Saizan_ http://pastebin.ca/1366350
11:19:46 <c_wraith> BMeph: Linked lists work fine on any hardware that lets you get the content of a memory location via an address.  balanced trinary is unwieldy unless your hardware supports trinary.
11:20:05 <doserj> conal: I still don't see such a big difference between [[Int]] = Z/2^32Z and [[Int]] = Z/2^kZ
11:20:15 <BMeph> conal: I think that's for one, because "simple" is something different to many folks. :)
11:20:41 <doserj> (or maybe Z/2^31Z, or whatever ghc uses)
11:21:04 <eyeris> Saizan_ My guess is that you probably have GHC 6.10 too.
11:21:06 <BMeph> doserj: [[Intk]] = Z/2^kZ? :)
11:21:10 <Saizan_> eyeris: ah, that bug never occurred to me, i don't have a 6.8.2 to test anymore though, i've 6.8.3
11:21:14 <conal> doserj: i'm fine with a *fixed* choice of bit-length
11:21:37 <jmcarthur> doserj: k is implementation dependent, so it can't be determined just by looking at the code. i'd call that a problem, personally
11:21:51 <conal> BMeph: yeah.  i mean simple *denotational* semantics, if that helps.  i.e., a simple math model.
11:22:18 <eyeris> I think 6.10 is nearly Debian's sid packages. Perhaps I will try those.
11:22:28 <BMeph> conal: Oh, I "think" I understand you, I still stand by my comment, though. :)
11:22:41 <Saizan_> eyeris: if you think it might make a difference you can try 1.6.0.1
11:23:04 <skyde> can someone help me
11:23:09 <conal> BMeph: anything execution-dependent (like Int) causes the denotational model to have "function-from-bitlength" attached the semantic domains.  that's an example of what i mean by "less simple".
11:23:20 <eyeris> I think I have.
11:23:22 <skyde> i would like to use ghc --make to compile a simple programe
11:23:50 <skyde> nil.hs:2:36:
11:23:50 <skyde>     No instance for (Num (IO t))
11:23:50 <skyde>       arising from the literal `0'
11:23:51 <skyde> ..
11:24:11 <conal> is ghc then careful *not* to constant-fold in some situations, e.g., (maxBound :: Int) ?
11:24:15 <eyeris> skyde Could you put the code on pastebin?
11:24:24 <jmcarthur> skyde: you are attempting to type 0 :: IO a
11:25:10 <conal> maybe it's careful not to treat the Int Num dictionary as constant.
11:25:14 <lilac> conal: why would it not constant-fold in that case?
11:25:24 <jmcarthur> conal: it's known at compile time, surely
11:25:41 <conal> oh -- i see.  because it knows the target architecture.  :p
11:25:57 <skyde> http://pastebin.com/m6c6d8ed6
11:26:14 <BMeph> conal: "Denotational semantics is hard. Let's go shopping!" ;)
11:26:35 * EvilTerran does the NoImplicitPrelude dance
11:26:37 <conal> i'll be okay.  i just have to ajust my reality filters.
11:26:51 * BMeph takes incriminating photos
11:26:58 <EvilTerran> (re: http://computationalthoughts.blogspot.com/2009/02/comment-on-parameterized-monads.html)
11:26:59 <skyde> should i use a let instead of arrow ?
11:27:02 <jmcarthur> skyde: your first line is a pure computation but you are treating it like IO. try "let max =" instead of "max <-"
11:27:06 <jmcarthur> yup :)
11:27:24 <skyde> tanks
11:27:24 <skyde> :P
11:27:52 <eyeris> skyde maximum is not in the IO monad, so you don't use <-
11:27:53 <skyde> it work
11:27:53 <doserj> conal: if you want, you can always define a simple denotational semantics for "Haskell/32bit" and one for "Haskell/64bit" :)
11:27:56 <zachk1> man this wifi connection im using is worse then dialup, thank the good Lord for IRC
11:27:58 <jmcarthur> skyde: also, putStrLn gives you IO (), so the return () is unnecessary
11:28:39 <jmcarthur> and putStrLn (show x) can be simplified to print x
11:28:40 <conal> doserj: yeah, i suppose so.  doesn't sound so bad that way.  and some FFI bridges to link them.
11:28:45 <EvilTerran> ?src print
11:28:45 <lambdabot> print x = putStrLn (show x)
11:30:00 <conal> i wonder how distributed haskell coped with the 32/64-bit semantic incompatibility.
11:30:09 <zachk1> why am i running out of memory at $arg1=100,000 http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2687#a2687
11:31:37 <jmcarthur> conal: well, i think you can't just say Haskell/32bit or Haskell/64bit because it still may vary from implementation to implementation
11:31:46 <jmcarthur> not just from architecture to architecture
11:32:00 <conal> jmcarthur: oh, urg.
11:32:15 <skyde> i dont think i should use list comprehension for this kind of stuff anyway .. its slow ;)
11:33:04 <jmcarthur> skyde: list comprehensions aren't slow, but your algorithm might be
11:35:30 <eyeris> How can I tell which version of a library is installed?
11:35:44 <zachk1> ok constructing an array using a list comprehension to store the factorial function. ghci and ghc are giving me out of memory when i try to do factorial 10^5, uh how can i store that large of factorial values in an array (table)
11:35:53 <mux> eyeris: ghc-pkg list
11:35:55 <lilac> eyeris: i think ghc-pkg tells you that
11:36:27 <BMeph> eyeris, mux: ghc-pkg describe, maybe? :)
11:36:54 <eyeris> Those work.
11:37:52 <conal> does anyone know whether or not haskell' folks are reconsidering implementation-specificity of the semantics of Int?
11:38:17 <doserj> I don't think so
11:38:29 <conal> also, are there other examples of implementation-specific semantics not in imperative types like IO?
11:39:25 <conal> maybe clearer: are there other examples of implementation-specific semantics in "pure" types?
11:39:34 <zachk1> > let fact n=a where a=array (1,n) ([(1,1)]++[(i,i*(a!(i-1)))|i<-[2..n]])  in (fact 1000)!1000
11:39:35 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
11:39:47 <zachk1> ok how come that code cant do 100000?
11:40:02 <doserj> conal: Float and Double are only specified to be *at least* as precise as IEEE floating point numbers
11:40:10 <jmcarthur> zachk1: well, first of all, those are lists, not arrays... as for your actual question, lemme see...
11:40:16 <conal> doserj: thx.
11:40:24 <vixey> what is implementation-specific semantics?
11:40:47 <jmcarthur> zachk1: looks like it's just because you are making such a large list
11:40:56 <jmcarthur> > product [1..100000]
11:40:58 <zachk1> jmcarthur: i am turning the list into an array, i am trying to learn how to use arrays to speed up my programs, because before that i have just been mutating lists
11:41:02 <conal> vixey: i mean that the semantics is not nailed down by the language, but rather can differ from one implementation to the next.
11:41:12 <lambdabot>   thread killed
11:41:17 <jmcarthur> ugh
11:41:18 <jmcarthur> > product [1..100000]
11:41:29 <glguy> zachk1, it can on my computer
11:41:33 <lambdabot>   thread killed
11:41:35 <conal> vixey: e.g., "maxBound :: Int" meaning one value on a 32-bit machine and a different value on a 64-bit machine.
11:41:38 <vixey> conal: I guess that lazyness vs call-by-need is an example then
11:41:50 <conal> vixey: same (denotational) semantics.
11:41:50 <zachk1> glguy: i have 3 gigs of ram, how much do you have
11:41:58 <vixey> ohh I see
11:42:12 <conal> sometimes i forget to say "denotational".  sry.
11:42:43 <glguy> zachk1, 4
11:44:00 <zachk1> ok first, arrays in haskell are lazy, am i wrong to assume that once a value is calculated in the array that i will have a speed up for a relookup of that previously calculated value, if i have to look it up again, thereby giving me something like memoization
11:44:00 <Gracenotes> this doesn't quite seem right: http://blogs.msdn.com/ericlippert/archive/2005/10/26/483900.aspx
11:44:12 <doserj> conal: I guess the range of Unicode Char's is also not precisely defined
11:44:57 <c_wraith> zachk1: I believe it's implementation-dependent, how much caching of previous calculations goes on.
11:45:05 <Gracenotes> he uses idempotency to mean calling a function several times and getting the same value... doesn't it simply mean that composition a function with itself has certain properties?
11:45:07 <jmcarthur> zachk1: if the array is top level then i think you should have memoization
11:45:12 <jmcarthur> in most implementations
11:45:26 <vixey> Gracenotes: idempotent means   f . f = f  yes
11:46:02 <Gracenotes> yes. But, in the blog post it seems like he's talking about a referential transparency, not idempotency.
11:46:08 <conal> doserj: so again maxBound is not precisely-defined?
11:46:12 <zachk1> jmcarthur: i only use ghc...if i put the array in a reader monad will i still get memoization?
11:46:15 <Gracenotes> "A nice little idempotent function -- calling it two, three, n times has exactly the same result as calling it once. "
11:46:28 <vixey> maybe he is confused then
11:46:31 <Philippa_> Gracenotes: idempotency with an implicit state. Same way it's abused in web specs
11:47:15 <vixey> weird
11:47:20 <vixey> that post makes no sense
11:47:35 <Gracenotes> if you mean referentially transparent, you should just use referentially transparent :/
11:48:14 <vixey> what does "Five-Dollar Words for Programmers, Part One: Idempotence" mean?
11:48:28 <vixey> Five-Dollar is a reference to something?
11:48:32 <Philippa_> Gracenotes: it's not, though
11:49:10 <Gracenotes> what's not?
11:49:16 <dons> ertai: wow. that's quite a release.
11:49:17 <Philippa_> vixey: yeah, the perceived value of the words. cf "my two cents worth"
11:49:36 <Philippa_> Gracenotes: it's not RT. It's about the result, not the side-effects
11:49:49 <lilac> Gracenotes: if you view the function as acting on the state of the universe (or less grandly, the state of the program), his statement holds.
11:50:02 <ertai> dons: I hope at least
11:50:19 <dons> http://www.reddit.com/r/haskell/comments/86909/safe_lazy_io_in_haskell/
11:50:22 <dons> well done.
11:50:28 <dons> now i have to study it
11:50:49 <lilac> Gracenotes: i've certainly heard 'idempotent' used in this way before (but only in languages with side-effects)
11:51:34 <Gracenotes> it's an unfortunate use then, as it apparently leads to confusion. http://www.codinghorror.com/blog/archives/001244.html
11:51:36 <eu-prleu-peupeu> is the use of the state monad bad ?
11:51:44 <eu-prleu-peupeu> i mean, doesn't it make things "unpure" ?
11:51:47 <Gracenotes> From the comments: "As for Idempotent, consider this sequence: x = foo(bar); y = foo(bar); Now, if x and y are equal, foo() is idempotent."
11:52:05 <eu-prleu-peupeu> does it make it harder to (in the future) paralelize stuff ?
11:52:06 <inimino> vixey: probably Pulp Fiction
11:52:37 <Gracenotes> and then someone corrected him and said that what was talking about was actually 'determinism'
11:52:41 <vixey> so funny
11:52:46 <vixey> "Hey guys check out this /word/"
11:52:59 <vixey> geeks
11:53:10 <solidsnack> eu-prleu-peupeu: Use of the state monad is not "bad".
11:53:11 <lament> for five dollars, it better be a damn good word
11:53:32 <zachk1> eu-prleu-peupeu: no it is pure because the side effect is wrapped in a monad
11:53:39 <vixey> it's incredible he feels the need to justify using a word that has more than 3 syllables, "This isn't just academic."
11:53:45 <eu-prleu-peupeu> yes, and monad is just sequence
11:53:47 <solidsnack> LOLz
11:53:49 <Gracenotes> if x = foo(bar); y = foo(bar) --> x == y is a definition of idempotent in imperative programming, what the hell does that have to do with idempotency in functional programming languages?
11:53:56 <Apocalisp> Gracenotes: There was also one where they were all trying to figure out what a closure is.
11:54:10 <Philippa_> vixey: no, it's not. Using too many such words without reason makes things hard to read
11:54:11 <solidsnack> eu-prleu-peupeu: Monads express sequencing but that's a long conversation, actually.
11:54:27 <Philippa_> they should only be used if they improve readability
11:54:44 <Philippa_> otherwise, eschew obfuscation :-)
11:55:06 <eyeris> Why can't leksah's Setup.lhs find posix-regex 0.72.0.3? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2688#a2688
11:55:19 <eu-prleu-peupeu> hmm, okey, in my mind, monads = sequencing tool, at least thats how i see them as a tool
11:55:36 <Gracenotes> really, idempotency in a stateful context.. it confuses me :\ is it accurate what all the blaggers are saying on the intersphere?
11:55:41 <zachk1> eu-prleu-peupeu: if you use the state monad and you end up trying to do it all "functionally" you will be passing around a "state" argument to tons of functions and the "piping" between functions to modify that "state argument" will become an utter huge mess. trust me ive tried it
11:55:52 <zachk1> if you dont use the state monad i mean eu-prleu-peupeu
11:56:03 <eu-prleu-peupeu> so the usage of state monad won't make my life harder in the future, if i want to paralelize it
11:56:07 <eu-prleu-peupeu> yes, i understand that
11:56:12 <Philippa_> Gracenotes: it's an understandable abuse. Not quite as much as n-ary funcs in Haskell, admittedly
11:56:23 <vixey> Gracenotes, it's some misuse/adaption.. I don't like it
11:56:28 <solidsnack> eu-prleu-peupeu: It depends a lot on how you are using the state.
11:56:35 <eu-prleu-peupeu> :P i usually just wrap things in a state monad transformer whener i have loads of arguments for my functions
11:56:45 <solidsnack> Ah.
11:56:50 <eu-prleu-peupeu> thats when i see "hmm, it would be better to use a state monad to keep track of these"
11:56:51 <solidsnack> Could be reader, instead.
11:57:00 <Gracenotes> so I suppose not much can be done. so long as 'idempotent' doesn't become a buzzword, I think we'll be fine
11:57:03 <ImInYourMonad> why doesnt $ have the same effect as parenthesizing the expression?
11:57:22 <solidsnack> ImInYourMonad: Please be more specific.
11:57:37 <lilac> ImInYourMonad: it does. "a b $ c d" == "(a b) (c d)"
11:57:44 <Philippa_> lilac: wrong
11:57:47 <eu-prleu-peupeu> im planing to use state so i can have an initialization part for the modules of my program, and them just run a series of functions on that "initialized" state
11:57:48 <solidsnack> eu-prleu-peupeu: Different monads sequence different "effects".
11:57:49 <Gracenotes> :O
11:58:03 <Philippa_> lilac: that's only approximately true because of the way the type system works
11:58:05 <solidsnack> eu-prleu-peupeu: You change the data?
11:58:33 <eu-prleu-peupeu> changing the data is a possibility, but it won't occur often
11:58:37 <lilac> Philippa_: please continue :)
11:58:43 <Gracenotes> many errors with $ involve unexpected operator precedence rules
11:58:45 <vixey> a b $ c d = (a b) $ (c d) = ($) (a b) (c d) = (a b) (c d)
11:58:49 <eu-prleu-peupeu> only through event's (im planing on using reactive)
11:59:13 <Apocalisp> Gracenotes: The function f is idempotent if f(x) == f(f(x)), right? In a stateful context, it's the same thing, roughly fmap f (x,s) == fmap (f . f) (x,s). No?
11:59:29 <Gracenotes> > (,) =<< length $ "abc"
11:59:30 <lambdabot>   (3,"abc")
11:59:31 <mk15_>  ?src or
11:59:55 <mk15_> ?src print
11:59:56 <lambdabot> print x = putStrLn (show x)
12:00:00 <mk15_> ?src or
12:00:01 <lambdabot> or    =  foldr (||) False
12:00:05 <ImInYourMonad> i had an example
12:00:09 <Philippa_> lilac: the whole predicativity thing can bite you, and I'd have to check whether they're currently equivalent in GHC under the impredicative checker
12:00:13 <ImInYourMonad> 5 : $ [[1,2,3] !! 1 /// us one but a bad one
12:00:28 <Gracenotes> :$
12:00:36 <Gracenotes> Apocalisp: sounds like theory-after-the-fact :)
12:00:52 <iago_> (5:) $
12:01:45 <Gracenotes> ad hoc gratuitous formalization to justify certain usage of a word :/
12:02:28 <vixey> don't worry though, it's not just academic1
12:02:33 <Apocalisp> no, it's just saying that idempotence of f implies that f is equivalent to (f . f).
12:03:02 <lilac> Philippa_: are you saying that Haskell doesn't guarantee that "f $ x" == "f x"? and do you mean denotationally or operationally?
12:03:15 <vixey> lilac, e.g. ST monad
12:03:22 <Philippa_> lilac: I mean they may end up with differing types
12:03:25 <lilac> vixey: i was guessing it was something like that
12:04:06 <Gracenotes> Apocalisp: yes, of course. But see also the blog post :\ anyways...
12:04:20 * LeoD can't think of any idempotent functions except id and sort
12:04:54 <zachk1> LeoD: x=5 then x is an idempotent function
12:05:02 <zachk1> LeoD: of 0 arguments
12:05:07 <LeoD> hm, okay
12:05:12 <Philippa_> zachk1: no such thing in Haskell
12:05:17 <omnihil> how do you compose a function of zero arguments?
12:05:23 <vixey> LeoD: projection from R^3 into R^2
12:05:28 <omnihil> the (f . f) == f definition fails then
12:05:32 <Apocalisp> Gracenotes: Atwood's post? He's a little confused sometimes.
12:05:48 <Gracenotes> @pl \x y -> f x + y*y
12:05:48 <lambdabot> (. join (*)) . (+) . f
12:05:53 <Philippa_> zachk1: we have 'n-ary functions' as described via the curry-howard isomorphism, but that doesn't cover n=0
12:05:54 <Gracenotes> @pl (. join (*)) . (+) . f
12:05:55 <lambdabot> (. join (*)) . (+) . f
12:06:07 <Gracenotes> ^ @pl is for the most part idempotent, as far as I can tell
12:06:19 <Gracenotes> haven't found any exceptions so far
12:06:36 <lilac> Philippa_: do you have an example of this? do i need something higher-rank? (ST seems to work fine in my tests)
12:06:47 <Philippa_> lilac: try it in hugs instead of GHC :-)
12:06:49 <LeoD> Gracenotes: hah, true :D
12:07:00 <Gracenotes> absolute value is idempotent too.
12:07:10 <sjanssen> lilac: alternatively, try an older version of GHC, 6.6 or so
12:07:12 <Philippa_> many projections are
12:07:18 <Gracenotes> .nod.
12:07:25 <Philippa_> most forms of normalisation should be
12:08:01 <Gracenotes> lookie, another 5-dollar programming word, invariant
12:08:23 <Philippa_> invariant deserves the $5, it's an important concept
12:08:26 <vixey> invariant is only useful in academic contexts
12:08:27 <vixey> :p
12:08:30 <Gracenotes> sorting establishes an ordering invariant
12:08:31 <Apocalisp> LeoD: uppercase, lowercase
12:08:43 <LeoD> Apocalisp: right :>
12:08:57 <LeoD> ok, there are more idempotent functions than i thought
12:09:03 <LeoD> +n
12:09:04 <Apocalisp> heaps
12:09:19 <Gracenotes> so invariant and idempotent are at least somewhat related :)
12:09:25 <Gracenotes> 10 dollars, yay
12:09:35 <lilac> > (id :: ((forall x. x -> x) -> Int) -> ((forall x. x -> x) -> Int)) $ (const 42) $ (const undefined)
12:09:36 <lambdabot>       Cannot match a monotype with `(forall x. x -> x) -> Int'
12:09:36 <lambdabot>      Probable ...
12:09:41 <lilac> > (id :: ((forall x. x -> x) -> Int) -> ((forall x. x -> x) -> Int)) (const 42) (const undefined)
12:09:42 <lambdabot>   42
12:09:44 <lilac> tadaa
12:10:13 <Gracenotes> > (const 42) (const undefined)
12:10:15 <lambdabot>   42
12:10:55 <zachk1> how do i a multi-part function in one line of code
12:11:08 <zachk1> s/i/i define
12:11:21 <Gracenotes> multi-part?
12:11:43 <lilac> LeoD: let S be the set of things which function f maps to themselves. let S' be the remainder of f's domain. then f is idempotent iff f S' = S
12:12:05 <zachk1> Gracenotes: like this but on 1 line of code http://www.kimbly.com/blog/000263.html
12:13:17 <lilac> > fib = (map fib' [0..] !!) where { fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2) }
12:13:18 <lambdabot>   <no location info>: parse error on input `='
12:13:19 <Gracenotes> > let fib = (map fib' [0 ..] !!) where fib' 0 = 0; fib' 1 = 1; fib' n = fib (n - 1) + fib (n - 2) in fib 14
12:13:20 <lambdabot>   377
12:13:21 <lilac> > fib = (map fib' [0..] !!) where { fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2) } in fib
12:13:22 <lambdabot>   <no location info>: parse error on input `='
12:13:23 <mopped> Is it archlinux that comes with the latest deal for haskell?
12:13:29 <lilac> > let fib = (map fib' [0..] !!) where { fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2) } in fib
12:13:30 <lambdabot>       Overlapping instances for Show (Int -> a)
12:13:30 <lambdabot>        arising from a use of ...
12:13:34 <Gracenotes> :\
12:14:07 <Gracenotes> hm, you don't need the braces per se; I don't think there are any ambiguities in this case.
12:14:34 <lilac> there is ambiguity
12:14:54 <lilac> > let fib = (map fib' [0..] !!) where { fib' 0 = 0; fib' 1 = 1 }; fib' n = fib (n-1) + fib (n-2) in fib 14
12:14:55 <lambdabot>   * Exception: /tmp/4617337131164818707:71:106-127: Non-exhaustive patterns i...
12:15:01 <zachk1> lilac: thank you
12:15:15 <lilac> zachk1: Gracenotes got there first ;-)
12:15:18 <zachk1> Gracenotes: yes the braces seem to be required at least in ghci
12:15:19 <zachk1> oh
12:15:22 <Gracenotes> "in this case", that's all
12:15:48 <Gracenotes> zachk1: hm. what I fed to lambdabot was accepted by ghci
12:15:54 <lilac> zachk1: it's useful to learn which bits of haskell syntax want braces, even if you don't insert them (it helps you know where you need whitespace)
12:18:54 <zachk1> lilac: Gracenotes: ok how do i do it in ghci . it doesnt seem to allow where D:
12:19:09 <Gracenotes> :o
12:19:44 <Gracenotes> if you enter... let fib = (map fib' [0 ..] !!) where fib' 0 = 0; fib' 1 = 1; fib' n = fib (n - 1) + fib (n - 2)
12:19:56 <Gracenotes> then you can do... fib 1000, for instance, on the next line
12:20:18 <Gracenotes> or if you don't want a global definition but rather one-time use... let fib = (map fib' [0 ..] !!) where fib' 0 = 0; fib' 1 = 1; fib' n = fib (n - 1) + fib (n - 2) in fib 1000
12:20:30 <Gracenotes> does that work okay?
12:20:31 <lilac> zachk1: my guess is that you're missing the 'let'
12:20:44 <lilac> ghci is implicitly in something a lot like a 'do' block
12:25:40 <Saterus> are there any universities actually teaching haskell? (teaching would be different than doing research)
12:25:58 <vixey> yes
12:26:05 <mstr> y
12:26:39 <eyeris> Why can't leksah's Setup.lhs find posix-regex 0.72.0.3? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2688#a2688
12:27:13 <Saizan_> eyeris: use --user
12:27:49 <undertake> HAHA?DCC SEND "ff???f?" 0 0 0
12:27:50 <eyeris> Saizan_ Thanks.
12:28:32 <Saterus> vixey/mstr: any examples?
12:29:56 <eyeris> Where can I find the gtk and gtksourceview pacakges? I can't find them on hackage.
12:30:29 <Saizan_> ?google gtk2hs download
12:30:31 <lambdabot> http://www.haskell.org/gtk2hs/download/
12:30:31 <lambdabot> Title: Gtk2Hs  Download
12:31:07 <eyeris> Ah, gtk = gtk2hs?
12:31:34 <Saizan_> it's one of the packages provided
12:31:59 <sw17ch> just out of curiosity, what's keeping the std lib docs from providing source links?
12:32:20 <pejo> Saterus, Lule, Chalmers, Utrecht, Nottingham, Oxford
12:34:08 <Saterus> pejo: are they teaching haskell to undergrads?
12:34:16 <zachk1> > let fact::(Int->Integer) = (map fact' [1..] !!) where fact' 1=1;fact' n=n*fact'(n-1) in fact 10000
12:34:17 <lambdabot>   284654430688514622435830385344108087703706620684296951071725941227383878113...
12:34:34 <pejo> Saterus, yes.
12:35:01 <fabjan> It's in the introductory programming course at Chalmers no?
12:35:04 <zachk1> sweetness
12:35:37 <Gracenotes> > let fib = 0 : 1: zipWith (+) fib (tail fib) in fib
12:35:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:35:43 <dancor> i'm using parsec on [Tok] where Tok is my own type and it always says "(line 1, column 1)" in errors.  why doesn't it tell me the number of the token where the error occurs?
12:36:02 <dancor> like "(token 537)"
12:37:44 <dancor> oh i have to add incSourceColumn everywhere any token is consumed?
12:37:51 <conal> When ghc's brain explodes and it recommends that I might "unpack the constructor" (for a GADT), what does it mean?
12:38:08 <romildo> Hi.
12:38:40 <dancor> @vixen say hello
12:38:40 <lambdabot> hi
12:41:36 <romildo> Which additional files should be distributed together with a simple Haskell executable (like hello world) using gtk2hs in Windows?
12:42:58 <romildo> I mean, if I develop an application in Haskell using the gtk2hs library, which, if any, files should I distribute to users of the application that does not have neither haskell nor gtk+ installed in their system?
12:43:01 <kynky> depends on your license
12:43:05 <pejo> Saterus, that list is by no means exhaustive in any way.
12:43:41 <Saterus> pejo: i figured not, so i did a "site:*.edu haskell" search on google. im looking over its results...yale seems to be really active...
12:43:58 <romildo> kynky, let's say the softwae is free.
12:45:04 <kynky> gtk2hs is lgpl without static linking exception, so your app will ahve to have an lgpl compatible license, gtk is lgpl or mpl, so you can distribute that too
12:45:36 <zachk> is bsd lgpl compatible?
12:45:59 <jmcarthur> bsd is basically compatible with anything
12:46:08 <p_l> except GPL
12:46:31 <jmcarthur> you can put bsd code in a gpl project, it just has to be relicensed as gpl
12:46:39 <neale> BSD with the advertising clause is incompatible, but the advertising clause is so 1980
12:46:44 <jmcarthur> ah yeah
12:46:44 <p_l> jmcarthur: only if it's with the new BSD
12:46:50 <kynky> bsd3
12:47:17 * p_l just doesn't care about GPL and avoids linking his stuff to any GPL code that doesn't have linking exceptions
12:47:21 <conal> advertising clause?
12:47:26 <jmcarthur> same
12:47:33 <conal> what's this linking exception?
12:47:37 <lilac> > let fib 0 = 0; fib 1 = 1; fib 2 = 1; fib n | even n = fk * (2*fk1 - fk) | odd n = fk*fk + fk1*fk1 where k = n `div` 2; fk = fib k; fk1 = fib $ k+1 in map fib [0..]
12:47:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:47:55 <p_l> conal: advertising clause meant that you had to say that you used code developed by this and that
12:48:03 <neale> conal: he might be talking about LGPL
12:48:16 <jmcarthur> conal: http://en.wikipedia.org/wiki/Bsd_license#UC_Berkeley_advertising_clause
12:48:43 <kynky> you can distribute ghc, with your app and link with sourcode compiled on users machine, maybe even d/l the source from web first
12:48:48 <p_l> conal: linking exception means that you don't have to relicense your code under GPL/LGPL if you link to the library (or various other legalese..)
12:48:57 <zachk> yay i got memoiziation working in O(1) time for me to celebrate with a cig
12:49:39 <conal> p_l: is there a modified gpl/lgpl somewhere with this linking exception?
12:49:55 <p_l> conal: look for "GPL with linking exception" etc.
12:50:00 <neale> that *is* the LGPL
12:50:01 <kynky> wxhaskell has linking exceptio gtk2hs doesnt
12:50:07 <p_l> neale: not exactly
12:50:14 <kynky> xhb is bsd3, same as ghc
12:50:27 <p_l> neale: but IANAL, so YMMV :P
12:50:33 <neale> okay so I'm trying to get Text.XHtml in Hugs98, how do I do that?
12:50:35 <vixey> zachk: If you smoke it makes breathing difficult
12:50:44 <neale> or is there a hugs98 channel I should be on
12:51:11 <conal> p_l: linking-exception == LGPL, or something different?
12:51:36 <dancor> http://www.dina.dk/~abraham/rants/license.html
12:51:56 <kynky> c++ plays nice with lgpl, haskell doesnt
12:51:56 <p_l> conal: LGPL was reworded to make it easier to license libraries, "GPL with linking exception" was seen in the wild few times (doesn't allow for static linking usually)
12:51:58 <neale> holy cow, I'm using a version of hugs from 2003
12:51:59 <neale> nevermind
12:52:22 <BONUS> hugs hasnt been updated in ages
12:52:29 <BONUS> i'd suggest using ghc
12:52:33 <kynky> ghci
12:52:45 <conal> p_l: thanks.  i'll check it out.  have been wondering about such a thing.
12:52:47 <neale> I'd use GHC if I could have gotten it working in Solaris during the 4 days I tried.
12:53:05 <dancor> ownage
12:53:26 <p_l> conal: I decided to stay away from using any code that is under GPL just in case...
12:53:45 <p_l> (using as in using the sourcecode)
12:53:48 <neale> p_l: I knew a guy once whose monitor exploded because he used GPL code
12:53:55 <p_l> neale: ROTFL
12:53:57 <neale> and this was back in the day when monitors were big vacuum tubes
12:54:09 <neale> got bits of phosphor-coated glass in his chest, it wasn't pretty.
12:54:10 <dancor> it seems like haskellers don't like the gpl
12:54:14 <p_l> neale: reminds me of cryptonomicon
12:54:19 <neale> dancor: I like the GPL.
12:54:28 <kynky> monitors implode :) because of the vacuum
12:54:29 <p_l> dancor: you should see the problem Lispers have with GPL
12:54:40 <neale> kynky: that's why it's so important to stay away from the GPL
12:54:55 <neale> dancor: yeah, like especially that Lisper named Stallman.
12:55:00 <dancor> you should see the problems i have with lisp (this is a joke i'm not really good enough at anything to have such opinions)
12:55:10 <bremner> haskellers hate lisp which hates GPL; by transitivity...
12:55:31 <kynky> not communitive
12:55:34 <p_l> Stallman isn't much of a lisper these days...
12:55:41 <neale> ...
12:55:47 <dancor> elisp isn't much of a lisp..
12:55:51 <neale> ...
12:55:51 <bremner> emacs-lisp is not really lisp
12:55:53 <zachk> vixey: oh no i didnt get it working D:
12:55:55 <bremner> jinx
12:55:56 <Adamant> elisp sucks
12:56:03 <Adamant> I wish they had used Scheme or CL
12:56:04 <dancor> buy me a comonad
12:56:13 <neale> Adamant: they might have if either had existed.
12:56:14 <vixey> elisp sucks -- I hadn't noticed :p
12:56:20 <p_l> dancor: I'm not sure if rms does much coding on emacs these days, though I never read the changelog
12:56:33 <neale> wow.
12:56:41 <Adamant> neale: Scheme was around when they did Emacs, I thought
12:56:43 <neale> well you guys sure know a lot about things that you haven't read anything about.
12:56:46 <Adamant> just in a very early state
12:57:07 <dancor> it's not easy to be so willfully uninformed, but i'm willing to do i've been told
12:57:12 <neale> :)
12:57:16 <p_l> neale: scheme existed afaik when FSF emacs started to build its own elisp
12:57:41 <p_l> at least R1S :P
12:57:43 <neale> at that time scheme was written in Lisp
12:57:56 <p_l> neale: which lisp? Maclisp?
12:58:03 <neale> Yes, I believe so.
12:58:15 <Adamant> doesn't prevent a C interpreter
12:58:28 <neale> no, but then, rms isn't Knuth.
12:58:31 <bremner> afaik, multics emacs was also written in maclisp
12:58:55 <neale> bremner: do you suppose that has anything to do with it wanting to use lisp as the extension language?
12:59:23 <neale> okay, you've been a great audience.  try the veal!
12:59:49 <Badger> It's delicious.
13:00:00 <neale> the newest hugs is from September 2006
13:00:05 <bremner> neale: well, they could have used one thing for implementation (PL/1 was the obvious choice) and still use lisp for extension
13:00:20 <sw17ch> I want a REPL for C
13:00:22 <sw17ch> very badly
13:00:25 <Adamant> neale: have you been drinking again?
13:00:27 <neale> so the one I got on Solaris was a 3-years behind the 3-year-old release.
13:00:28 <dancor> everything should have a repl
13:00:35 <Adamant> sw17ch: there are C language interpreters
13:00:42 <neale> Adamant: that question presupposes that I at some point stopped.
13:00:52 <sw17ch> Adamant: yes, i know, but i want one that works the way ghci does
13:01:03 <sw17ch> interacting withotu skipping abeat with existing objects and source :)
13:01:16 <dancor> ghci is not the best repl i've ever used
13:01:17 <Adamant> sw17ch: ah
13:01:19 <Gracenotes> ghci is particularly nice when it comes to inspection.
13:01:21 <Adamant> no it isn't
13:01:31 <Adamant> it's better than irb
13:01:39 <Adamant> worse than most Lisp REPL's
13:01:41 <dancor> i'm willing to forgive it tho since haskell is tough (..and the best lang i've ever used)
13:02:01 <neale> sw17ch: have you tried Pike?
13:02:02 <p_l> Adamant: you mean SLIME or Genera? xD
13:02:04 <Gracenotes> well, Lisp "invented" the REPL :)
13:02:12 <sw17ch> neale: i've heard of it, b ut that's all
13:02:21 <Adamant> p_l: SLIME or just a regular old REPL
13:02:35 <neale> sw17ch: My brief interaction with it led me to believe it was lot like interpreted C.
13:02:57 <sw17ch> neat!
13:03:20 <Gracenotes> don't want to get into the whole Lisp-vs-Haskell thing, but in what respect are the functionalities of Lisp REPLs more useful than ghci?
13:03:43 <Gracenotes> just out of unfamiliarity with 'em
13:03:56 <Adamant> Gracenotes: biggest annoyance for me with ghci is you can't just C&P code without tweaking it
13:03:58 <chessguy_work> > pi
13:03:59 <sw17ch> Gracenotes: i tend to use clisp when i want to bang out something quick (like financial stuff)
13:03:59 <lambdabot>   3.141592653589793
13:04:02 <chessguy_work> what?
13:04:05 <sw17ch> it's a overgrown calculator to me
13:04:09 <chessguy_work> @index pi
13:04:09 <lambdabot> Prelude
13:04:13 <sw17ch> ghci is something that i use to demonstrate pure awesome to people
13:04:15 <p_l> Gracenotes: I dunno about "normal" REPL (this varies greatly), but SLIME quite possibly beats anything available for normal computers
13:04:20 <chessguy_work> bah, the prelude has an approximation for pi??
13:04:23 <dancor> idk bout lisp but my main problems are that i can't paste code into ghci and i can't get the types of things that aren't top-level
13:04:31 <zakwilson> I don't know that Lisp's REPL is much butter than ghci.
13:04:35 <Saizan_> chessguy_work: it's in some of the numerical classes
13:04:35 <Gracenotes> all Floatings have an approximation for pi
13:04:38 <Saizan_> ?type pi
13:04:39 <lambdabot> forall a. (Floating a) => a
13:04:42 <chessguy_work> @hoogle pi
13:04:43 <lambdabot> Prelude pi :: Floating a => a
13:04:43 <lambdabot> Data.Fixed type Pico = Fixed E12
13:04:43 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
13:04:47 <Trafalgard> wh...
13:04:47 <zakwilson> But SLIME does a lot more stuff than haskell-mode.
13:04:47 <Saizan_> Floating, apparently
13:04:51 <Gracenotes> > pi :: Float
13:04:52 <chessguy_work> @hoogle+
13:04:52 <lambdabot> package Pipe
13:04:54 <Trafalgard> > 4 :: [3 - 1]
13:04:54 <lambdabot> Distribution.Compiler buildCompilerFlavor :: CompilerFlavor
13:04:56 <lambdabot>   3.1415927
13:04:58 <lambdabot> System.Posix.Internals c_getpid :: IO CPid
13:05:01 <Adamant> zakwilson: more like a margarine improvement apparently
13:05:02 <Gracenotes> > pi :: CReal
13:05:02 <lambdabot>   <no location info>: parse error on input `-'
13:05:03 <p_l> zakwilson: depends which implementation. And the best REPL is SLIME REPL (unless you got Genera running)
13:05:06 <lambdabot>   3.1415926535897932384626433832795028841972
13:05:06 <Adamant> :P
13:05:22 <Trafalgard> I'm confused.
13:05:33 <Gracenotes> :: isn't a cons
13:05:33 <Trafalgard> I'm trying to do something like: a :: (foo' genB (count - 1))
13:05:36 <Trafalgard> and I'm getting -
13:05:43 <Trafalgard> as invalid.
13:05:45 <Trafalgard> oh.
13:05:48 <chessguy_work> Gracenotes, presumably that's still not exact, right?
13:05:54 <Trafalgard> why's the stupid compiler complain about - then
13:05:56 <chessguy_work> > show (pi :: CReal)
13:05:57 <lambdabot>   "3.1415926535897932384626433832795028841972"
13:05:58 <Trafalgard> :|
13:05:58 <Gracenotes> : is the cons. :: is "is type of" operator
13:06:13 <Trafalgard> This would be the second time I've done that
13:06:19 <zakwilson> I'd like to see an improved haskell-mode that interacts with a running environment the way SLIME does, but I don't know Emacs or Haskell well enough to say how practical that is.
13:06:26 <dancor> chessguy_work: it's just casting the truncated pi
13:06:33 <Trafalgard> thanks
13:06:37 <chessguy_work> bah
13:06:39 <Gracenotes> sure :)
13:06:48 <dancor> misleading type annotations ftw
13:06:57 <p_l> zakwilson: well, you can try making a swank for haskell...
13:06:59 <Gracenotes> p_l: what does SLIME do that's amazing?
13:07:44 <p_l> Gracenotes: Well, I'm not a great expert on SLIME, but it has a very good introspector, debugger, etc.
13:07:55 <p_l> and that's just what a newbie like me uses :)
13:08:09 <goomba``> i am wondering why parsec was throwing away one of my '\' characters during parsing: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1935#a1937
13:08:15 <Gracenotes> ah, yes. ghci and debugging.. \x.x
13:08:26 <zakwilson> SLIME does a lot of the stuff an IDE does by interacting with a live Lisp runtime.
13:08:29 <goomba``> it keeps the \" but removes the \ from \n
13:08:49 <zakwilson> Code completion, displaying documentation in the minibuffer when you type the name of a function or macro.
13:09:19 <p_l> or interacting with remote image
13:10:28 <zakwilson> Yes, that too. SLIME lets you connect to, look at what's going on inside and update a remote application.
13:11:04 <zakwilson> Trying to write Swank for Haskell, at this point would require knowing a lot more Haskell than I do. I'm working on that.
13:11:30 <chessguy_work> hmm. i need to find a bunch of 4-digit groupings of digits from pi where the first digit is 8
13:12:16 <bremner> euler problem?
13:12:18 <chessguy_work> this should be CAKE for haskell
13:12:27 <chessguy_work> bremner, surprisingly, no
13:12:51 <Gracenotes> goomba``: it does the same thing to both the quote and the \n
13:13:08 <goomba``> Gracenotes, ahh, i get it
13:13:10 <Gracenotes> you feed it \n, it gives you n. You feed it \", it gives you "
13:13:19 <sw17ch> > pi
13:13:20 <lambdabot>   3.141592653589793
13:13:21 <Gracenotes> it's just that showing a string escapes the characters
13:13:39 <Gracenotes> the problem is that, if you want to keep the backslahes, escapedChar doesn't do that
13:13:58 <Gracenotes> it's equivalent to (char '\\' >> char x)
13:14:04 <goomba``> actually why arent there backslashes in front of the enclosing "
13:14:07 <Gracenotes> which, if the match succeeds, returns a Parser with Char
13:14:11 <goomba``> its part of the string also
13:14:37 <Gracenotes> it's about how Show works for String
13:14:40 <sw17ch> so how does one get haskell to spit pi out forever?
13:14:40 <vininim> > lenght $ show ( pi :: CReal)
13:14:41 <lambdabot>   Not in scope: `lenght'
13:14:45 <Gracenotes> > show "yes" !! 0
13:14:47 <lambdabot>   '"'
13:14:48 <vininim> > length $ show ( pi :: CReal)
13:14:49 <lambdabot>   42
13:15:02 <vininim> kind of lame
13:15:04 <chessguy_work> sw17ch, that's what i'm trying to figure out
13:15:05 <Gracenotes> you see, (show "yes") returns a String with 5 characters
13:15:26 <Gracenotes> vininim: 40 is the default decimal length. use showCReal for more
13:15:45 <vininim> > length $ showCReal ( pi :: CReal)
13:15:46 <lambdabot>   Couldn't match expected type `Int' against inferred type `CReal'
13:15:47 <chessguy_work> > showCReal (pi :: CReal)
13:15:48 <lambdabot>   Couldn't match expected type `Int' against inferred type `CReal'
13:15:56 <Gracenotes> goomba``: so showing a string yields something that you could just paste right into the code again
13:16:05 <chessguy_work> @type showCReal
13:16:06 <lambdabot> Int -> CReal -> String
13:16:16 <vininim> > length $ showCReal 1000 ( pi :: CReal)
13:16:17 <chessguy_work> > showCReal 500 (pi :: CReal)
13:16:17 <lambdabot>   1002
13:16:18 <sw17ch> chessguy_work: Niel to the rescue: http://neilmitchell.blogspot.com/2009/02/monomorphism-and-defaulting.html
13:16:19 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:16:26 <vininim> awesome!
13:16:30 <eyeris> Why isn't Leksah trying to use Cabal 1.6.0.2 instead of 1.6.0.1?
13:16:35 <Gracenotes> > show "this is a \" complicated \\\\ string \\\"" -- goomba``
13:16:37 <lambdabot>   "\"this is a \\\" complicated \\\\\\\\ string \\\\\\\"\""
13:16:39 <goomba``> that is slightly confusing....
13:16:51 <Gracenotes> > read "\"this is a \\\" complicated \\\\\\\\ string \\\\\\\"\"" :: String
13:16:53 <lambdabot>   "this is a \" complicated \\\\ string \\\""
13:17:12 <chessguy_work> sw17ch, that's not exact though
13:17:15 <goomba``> is there a version of show that wont mess with my string
13:17:18 <sw17ch> chessguy_work: true
13:17:19 <sw17ch> :)
13:17:39 <dancor> what if you want an infinite lazy string of pi's digits?
13:17:43 <sw17ch> > showCReal 500 (pi :: CReal)
13:17:44 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
13:17:53 <Gracenotes> dancor: use an algorithm
13:18:03 <dancor> Gracenotes: why can't CReal do it
13:18:06 <Gracenotes> goomba``: no, but there's a way to wrap a String in a pretty-printing type so that it displays nicely
13:18:15 <Gracenotes> dancor: because CReal is arbitrary-length, not infinite-length
13:18:16 <sw17ch> > break (= '8') $ showCReal 500 (pi :: CReal)
13:18:16 <lambdabot>   <no location info>: parse error on input `='
13:18:17 <dancor> it's obviously using such an algorithm
13:18:23 <sw17ch> > break (== '8') $ showCReal 500 (pi :: CReal)
13:18:24 <lambdabot>   ("3.1415926535","8979323846264338327950288419716939937510582097494459230781...
13:18:41 <mle> you don't need the (::CReal) in there
13:18:43 <Gracenotes> what CReal does is that it calculates the digits to an arbitrary precision. And if you want a greater precision, it calculates that.
13:18:57 <Gracenotes> it's not quite infinite precision.
13:19:13 <Gracenotes> (to the extent I understand the internals, at least :)
13:19:14 <vininim> > length $ showCReal (2 ** 63) pi
13:19:15 <lambdabot>       No instance for (Floating Int)
13:19:15 <lambdabot>        arising from a use of `**' at <in...
13:19:35 <vininim> > length $ showCReal (2 ^ 63) pi
13:19:45 <Gracenotes> > text "this is a \" complicated \\\\ string \\\"" -- goomba``
13:19:46 <dancor> i thought CReal implemented numbers as like digitNum -> theDigit (in binary)
13:19:47 <lambdabot>   this is a " complicated \\ string \"
13:19:50 <lambdabot>   thread killed
13:19:52 <thomashartman1> is there some more elegant way to write projectM? Like using arrows or somethign? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2695#a2695
13:20:12 <Gracenotes> goomba``: you see, text turns a String into a Doc, which can then be shown literally
13:20:14 <Gracenotes> @index text
13:20:15 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
13:20:35 <Gracenotes> try Text.PrettyPrint
13:21:16 <sw17ch> @index showCReal
13:21:16 <lambdabot> bzzt
13:21:19 <dancor> it does: data CReal = CR (Int -> Integer)
13:21:20 <sw17ch> erm?
13:21:33 <goomba``> ok, ill try to fix that part, what was that about escapedChar being wrong if i wanted to keep the \\ ?
13:21:58 <Gracenotes> "char blah" always returns a result if it succeeds -- the character you just parsed
13:22:20 <Gracenotes> in the line char '\\', it returns a result, but you ignore the result
13:23:24 <goomba``> so i will have to make it into a [Char] ?
13:23:39 <goomba``> Parser [Char] that is
13:24:08 <dufflebu1k> Has anyone used cabal to install leksah?
13:24:08 <dancor> maybe it's just not worth it to try to write a showCRealInf that is any smarter than just doubling the number of digit as it goes
13:24:31 <goomba``> im going to read the parsec docs further, i stopped when i found the example for parsing '()' but now i realise it wasnt telling me everything i need to know
13:24:45 <goomba``> thanks for the help so far
13:25:00 <dancor> i think that is the reality of it, not exactly that its representation is arbitrary-but-not-infinite-friendly tho maybe could be seen that way
13:25:29 <chessguy_work> > sum $ take (maxBound :: Int) $ zipWith (/) (iterate negate 4) [1,3..]
13:25:31 <Gracenotes> goomba``: you can make it a Parser [Char], yes. there are a few ways to work with parser combinators to achieve what you want
13:25:41 <lambdabot>   mueval: Prelude.read: no parse
13:25:48 <Gracenotes> Leibniz is slooow :)
13:26:08 <dons> dufflebu1k: yeah
13:26:20 <dufflebu1k> I get a really weird error that ghc-6.10.1 requires process 1.0.1.1, but it also needs 1.0.1.0
13:26:23 <dufflebu1k> $ cabal install leksah
13:26:25 <dufflebu1k> Resolving dependencies...
13:26:28 <dufflebu1k> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
13:26:30 <dufflebu1k> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
13:26:40 <dons> don't upgrade the process library, i guess
13:26:44 <mle> so is there a Data.Number.CComplex somewhere?
13:27:03 <dons> $ ghc-pkg list process
13:27:03 <dons> /usr/lib/ghc-6.10.1/./package.conf: process-1.0.1.0
13:27:21 <dufflebu1k> dons: What's weird thoug is that it's saying the ghc-6.10.1 needs both versions... not that ghc needs one and leksah needs the other
13:27:45 <mle> maybe you rebuilt something ghc depends on using the later version?
13:27:50 <dufflebu1k> Oh, weird, I have one in /usr/lib, but also one in my hoe directory.
13:28:10 <dufflebu1k> home, not noe
13:28:24 <Gracenotes> > let g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in map intToDigit g(1,180,60,2)
13:28:25 <lambdabot>   Couldn't match expected type `[Int]'
13:28:28 * bos is saddened by the decreasing SNR of haskell-cafe
13:28:34 <Feuerbach> I see instance Monad m => Functor (WrappedMonad m), why is WrappedMonad required here? Is therre Monad m => Functor m definition somewhere?
13:28:40 <Gracenotes> hrm
13:28:41 <vixey> bos likewise
13:28:51 <bos> a lot of the noise is caused by a handful of pinheads.
13:28:54 <chessguy_work> > let piAt a b t p = (a+b)*(a+b)/(4*p)
13:28:54 <lambdabot>   <no location info>: parse error on input `;'
13:28:55 <vixey> yeah
13:28:56 <vixey> esp. when it's due to one person
13:29:12 <Gracenotes> > let g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t)) in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1) in g(1,180,60,2) -- dancor
13:29:14 <lambdabot>   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,...
13:29:20 <sw17ch> > map (take 4) $ map ('8':) $ take 5 $ drop 1 $ iterate (drop 1 . dropWhile (/= '8')) $ showCReal 500 pi
13:29:21 <lambdabot>   ["8979","8462","8327","8841","8419"]
13:29:22 <Gracenotes> an infinite list of pi digits
13:29:29 <sw17ch> chessguy_work: ^^
13:29:31 <Gracenotes> from an algorithm in http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf
13:29:42 <sw17ch> > let count = 5 in map (take 4) $ map ('8':) $ take count $ drop 1 $ iterate (drop 1 . dropWhile (/= '8')) $ showCReal 500 pi
13:29:44 <lambdabot>   ["8979","8462","8327","8841","8419"]
13:29:45 <Gracenotes> not proven correct, but incredibly fast and works for the first few thousand, at least
13:29:48 <dufflebu1k> There's no cabal option to remove something... is it safe to just delete the directory?
13:29:49 <sw17ch> that's the really evil version
13:30:07 <Gracenotes> CReal uses an atan formula and, as a result, gets really slow for later digits
13:30:09 <bos> i think it might be time to start gently asking people who are sources of noise to restrain themselves.
13:30:33 <Gracenotes> moo.
13:30:50 <chessguy_work> bos are you talking about the conversation about pi?
13:30:57 <bos> no.
13:31:02 <chessguy_work> oh ok
13:31:13 <bos> i didn't notice that.
13:31:31 <bos> but i used to read a fair proportion of what went on in haskell-cafe, and now i delete most of the traffic unread.
13:31:32 <sw17ch> > let count = 5 in map ((take 4) . ('8':)) $ take count $ drop 1 $ iterate (drop 1 . dropWhile (/= '8')) $ showCReal 500 pi
13:31:33 <lambdabot>   ["8979","8462","8327","8841","8419"]
13:31:45 <chessguy_work> bos, oh, i mis-read, thought you were talking about on here
13:31:50 <bos> no.
13:31:57 <sw17ch> yes, i felt noisy for a second too :(
13:32:00 <Gracenotes> bos: too much philosophy?
13:32:10 <bos> and quite a few people who used to be more voluble when the list was busy are now much quieter.
13:32:21 <bos> er, when the list was less busy.
13:32:26 <sw17ch> "argh! i hate logos!" "no! the logos rule!" "I DON'T KNOW WHAT WE'RE YELLING ABOUT"
13:32:27 <bos> thus further depressing the SNR.
13:32:40 <chessguy_work> bos, a cyclical process?
13:32:59 <Gracenotes> or spiraling
13:33:04 <chessguy_work> sw17ch, that's when gmail's "mute conversation" is handy
13:33:08 <bos> chessguy_work: i don't think it's cyclical. i think it's something that is killing the usefulness of the list, and it won't cycle back to a healthy state.
13:33:15 <sw17ch> > let count = 5 in map ((take 4) . ('8':)) $ (take count) . (drop 1) $ iterate (drop 1 . dropWhile (/= '8')) $ showCReal 500 pi
13:33:16 <lambdabot>   ["8979","8462","8327","8841","8419"]
13:33:19 <zakwilson> I'm a general beginner with Haskell and I want to try out Leksah. runhaskell Setup configure reports a large number of missing dependencies. Is there a way to tell it to install them automatically?
13:33:41 <chessguy_work> bos, err, yeah, i didn't mean cyclical. i think i meant self-perpetuating or something
13:33:45 <mle> bos: a "complex dis-tractor" ?
13:33:48 <sw17ch> chessguy_work: is my thingy getting close to what you were trying to do? i'm sure there's a better way
13:33:51 <dufflebu1k> zakwilson: cabal will probably get most of them.
13:34:20 <chessguy_work> > let count = 500 in map ((take 4) . ('8':)) $ (take count) . (drop 1) $ iterate (drop 1 . dropWhile (/= '8')) $ showCReal 500 pi
13:34:21 <lambdabot>   ["8979","8462","8327","8841","8419","8209","8164","8620","8998","8628","803...
13:34:34 <wchogg> I think the dependencies that will nab you if you try to cabal install leksah is gtk2hs, which I think you still need to install by hand.
13:34:52 <sw17ch> the only problem is that my iterate eventually degrades into repeat ""
13:35:04 <sw17ch> well, that's one of the problems
13:35:07 <dufflebu1k> Yeah, I had to use yum for the gtk2hs and gtksourceview2
13:35:20 <chessguy_work> @index showCReal
13:35:20 <lambdabot> bzzt
13:35:27 <zakwilson> Oh, wait. Now I see how to use cabal properly (in this situation).
13:35:29 <nathanic> ens?
13:35:30 <chessguy_work> @hoogle showCReal
13:35:31 <lambdabot> No results found
13:35:41 <Gracenotes> showCReal :: CReal -> Int -> String
13:35:49 <chessguy_work> but where is it?
13:35:53 <chessguy_work> (trying to import locally
13:35:53 <Gracenotes> or, rather, Int -> CReal
13:36:04 <sw17ch> chessguy_work:
13:36:25 <sw17ch> cabal install numbers
13:36:32 <sw17ch> Data.Number.CReal.showCReal
13:36:37 <sw17ch> chessguy_work: ^^
13:36:50 <mle> @hayoo CReal
13:36:51 <lambdabot> Unknown command, try @list
13:36:54 <mle> bah
13:37:28 <sw17ch> I keep reading CReal as Cereal and then i want lucky charms
13:37:32 <sw17ch> or chereos
13:38:17 * dufflebu1k notes that lucky charms is just sugar disguised as cereal
13:38:56 * sw17ch takes dufflebunk's note and covers it with milk and marshmallows
13:39:26 * sw17ch then discovers that marshmallow is a very strange word...
13:39:30 <chessguy_work> bos, i think we'll have to be pretty careful about how we define SNR before we start asking them to turn it down
13:39:37 <chessguy_work> err, up
13:40:05 <bos> chessguy_work: well clearly if it's not interesting to me personally, then nobody else will want to read it. so i'll just act as arbiter of taste.
13:40:14 <chessguy_work> haha
13:40:18 <chessguy_work> bos++
13:40:21 <bos> everything's bound to turn out well that way.
13:40:45 <bos> but more realistically, i would certainly feel comfortable asking people not to waffle about e.g. german grammar.
13:40:51 * chessguy_work makes a mental note to start budgeting for bribes to send bos' direction
13:40:58 <zachk> how do i "upcast" an int to an Integer
13:41:06 <bos> zachk: fromIntegral
13:41:12 <chessguy_work> @quote fromIntegral
13:41:12 <dons> hey guys. anyone want to guess how many package downloads have happened on hackage in the last 12 months?
13:41:12 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
13:41:28 <chessguy_work> dons, 8.4 million
13:41:40 <dons> oh, i wonder if i can get ghc stats.
13:41:47 <dons> chessguy_work: that's a lot
13:41:51 <dons> isn't that like 800/hr?
13:41:55 <bremner> fromIntegral 8.4 million
13:41:57 <chessguy_work> oh, you wanted a realistic guess?
13:41:59 <dons> yeah.
13:42:02 <chessguy_work> :)
13:42:48 <chessguy_work> to stick with my original digits, i'll say 8400
13:42:50 <sw17ch> dons: 3 * 52 * 10,000
13:42:55 <sw17ch> > 3 * 52 * 10000
13:42:56 <lambdabot>   1560000
13:43:01 <sw17ch> 1.5 million
13:43:03 <mofmog> so, the reason why >>= 's second argument is (a -> m b) is because inside a monad, you want to do a computation on a value and then get a "residue" which is stored in m right?
13:43:13 <mofmog> for example, in the writer monad, you do a computation and the residue is the log
13:43:16 <dons> well, i have 770k. 2000 a day, 88 an hour from hackage.
13:43:23 <dons> (so not counting ghc/hugs)
13:43:29 <mofmog> in a list, the residue is just everything, in the state, it is the state part
13:43:39 <sw17ch> > 770000 / (3 * 52 * 10000)
13:43:40 <lambdabot>   0.4935897435897436
13:43:53 <dons> 3 * 52 * 10k?
13:43:56 <b\6> how to Int -> Int -> Int -> Int -> HostAddress? i'm just worried about endianness.
13:43:56 <sw17ch> dons: my estimate was based on 3 packages/week/user with 10,000 users
13:43:59 <mofmog> and in a comonad you're trying to get rid of the residue and just get at a single value?
13:44:03 <dons> interesting
13:44:11 <sw17ch> based on my own usage
13:44:26 <dons> i'll crunch some stats over the weekend
13:44:27 <chessguy_work> you download 3 packages a week?
13:44:29 <sw17ch> i'm guessing i install 3 hackage packages per week, and i'm estimating 10K active uses
13:44:32 <sw17ch> uesers*
13:44:33 <dons> i download about 10 a day
13:44:34 <chessguy_work> wow
13:44:48 <sw17ch> chessguy_work: some weeks it's 0, some weeks it's 20
13:45:01 <sw17ch> depending on whether or not i'm having a go at happstack or something else with gobs of reqs
13:45:18 <chessguy_work> sw17ch, get out much? :)
13:46:41 <dons> ah, pity, ghc's logs are on the yale computer
13:46:42 <sw17ch> chessguy_work: i'm married, so i'm not exactly crusing for chicks any more... so i have a little more free time :)
13:46:47 <chessguy_work> haha
13:46:54 <dons> heh
13:47:24 <sw17ch> chessguy_work: actually, you should look up my Steam profile and find out exactly how much time i waste ... :{
13:47:47 <chessguy_work> crao
13:47:56 <chessguy_work> dude, i almost went to that site
13:48:11 <sw17ch> ?
13:48:21 <chessguy_work> you should be more careful about throwing around names of addicting sites like that :)
13:48:36 <sw17ch> like Steam as in Valve as in Half Life?
13:49:15 <bremner> grr. I finally update to ghc6.10 so   I can install the newest hxt, and now I find parsec is too new
13:51:57 <dons> huh, more than 100k downloads of hugs
13:52:13 <chessguy_work> wow
13:52:23 <chessguy_work> that's not good
13:52:32 <zachk> gig of ram holy smokes
13:52:35 * bremner wonders if he really needs hxt
13:52:41 <dons> chessguy_work: it's not? seems ok for a dead project
13:52:59 <chessguy_work> dons, i'd rather they were downloading ghc...
13:53:11 <dons> yeah. i don't have access to the ghc machine, sorry
13:53:23 <chessguy_work> i'm just saying, that number's higher than i'd like
13:53:26 <dons> yes.
13:53:30 <zachk> i hated hugs so bad i didnt touch haskell for 2 more years. till i found out about ghc and ghci :-D
13:53:32 <dons> schools and newbies
13:53:50 <dons> maybe we need a big banner
13:53:51 <wchogg> Wow...I never had such a visceral reaction to hugs.
13:53:53 <dons> "USE GHC"
13:53:57 <chessguy_work> zachk, i came pretty close to doing that
13:54:06 <ialpert> why ghc preffered (it's what i'm using)?
13:54:13 <vixey> it's better
13:54:21 <ialpert> better = faster?
13:54:21 <wchogg> Because ghc has crazy number of type extensions.
13:54:22 <dons> yeah, 141k downloads of hugs
13:54:33 <dons> ialpert: faster, parallel, better
13:54:35 <chessguy_work> anyway, i'm off to the weekend
13:54:50 <sw17ch> it's better like beer is better than pond scum
13:54:52 <bremner> hugs is lighter weight though, at least for very small systems
13:55:26 <dons> yeah, hugs runs on the iphone
13:56:00 <zachk> i enjoy terse error messages
13:56:13 <zachk> makes my error feel errorful
13:56:29 <bremner> zachk: fail
13:59:20 <Heffalump> @karma+ ertai -- cool looking IO library
13:59:20 <lambdabot> ertai's karma raised to 1.
13:59:33 <dons> ertai's awesome.
14:00:36 <sw17ch> what is ertai?
14:00:40 <sw17ch> hackaged?
14:01:47 <Heffalump> Nicholas Pouillard
14:03:34 <sundaymorning> I'm making a hopengl project for my use, so I can plot a few things. So want to use ghci such like this: 1. I write an expression such as "plot (\t -> (t, 2*t, 0)) [0..100]" 2. my graph gets shown on screen. 3. I exit the screen 4. I'm back to ghci
14:03:42 <sundaymorning> the 4th step is not happening
14:03:57 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2697#a2697 , 1+1=2 there you have it.
14:03:57 <sundaymorning> once I get in the mainLoop, if I close the screen the program and ghci exits
14:04:01 <dons> looks like we might just be over 1M downloads from hackage ...
14:04:10 <sundaymorning> how can I work around that?
14:04:19 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2697#a2698
14:04:28 <mopped> @src insert
14:04:29 <lambdabot> insert e ls = insertBy (compare) e ls
14:04:40 <Heffalump> dons: hackage has download stats?
14:04:45 <mopped> @src insertBy
14:04:45 <lambdabot> insertBy _   x [] = [x]
14:04:45 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
14:04:45 <lambdabot>                                  GT -> y : insertBy cmp x ys'
14:04:45 <lambdabot>                                  _  -> x : ys
14:04:55 <dons> Heffalump: i'm extracting them as we speak
14:04:59 <mopped> hmm
14:05:03 <mopped> so what does insert do? :S
14:05:12 <sw17ch> dons: it would be nice to see for individual packages
14:05:28 <dons> sw17ch: yes, i just got the anonymized logs. i'll crunch the stats tomorrow
14:05:36 <bremner> any examples of Text.XML.Light reorganizing an xml tree? is it suitable for that? I'm currently using hxt to do things like http://rafb.net/p/Aa9Yua70.html
14:06:03 <dons> Heffalump: i find this number rather satisfying :)
14:06:10 <Heffalump> can't think why ;-)
14:06:21 <dons> mwhaha
14:06:22 <Heffalump> will GHC 6.12 still have extralibs?
14:06:24 <mopped> > compare 1 2
14:06:25 <lambdabot>   LT
14:07:48 <mopped> > let f = foldl (\ a b -> insert b a) [] in 5 [1, 3, 4, 6, 7]
14:07:49 <lambdabot>       No instance for (Num ([t] -> a))
14:07:49 <lambdabot>        arising from the literal `5' at...
14:07:51 <dons> Heffalump: hmm. 6.12 isn't here yet.
14:07:51 <mopped> > let f = foldl (\ a b -> insert b a) [] in f 5 [1, 3, 4, 6, 7]
14:07:52 <lambdabot>   Couldn't match expected type `[t1] -> t'
14:08:14 <Heffalump> hence "will", not "does"...
14:08:28 <dons> i think it may. or extralibs may be called 'platform'
14:08:38 <dons> depends on the hackathon
14:08:41 <mopped> > let f = foldl (\ a b -> insert b a) [] in f [1, 4, 6, 7, 5, 2]
14:08:42 <lambdabot>   [1,2,4,5,6,7]
14:08:57 <dons> Heffalump: btw, if i book some spare time after the hackathon, should i drop by CS and see you guys? :)
14:11:25 <skorpan> http://bayimg.com/aAOinaaBg
14:11:33 <skorpan> proof that haskell is sexy
14:11:49 <singintime> hello world!
14:12:04 * singintime checking skorpan's link
14:12:14 <Peaker> > print "Hello world!"
14:12:15 <lambdabot>   * Exception: "<IO ()>"
14:12:52 * bremner reports skorpan's picture to the abuse link
14:13:00 <sw17ch> well, i'm going to finish moving
14:13:02 <sw17ch> bye all
14:14:49 <mopped> How do I get lambda bot to print out how functions work, say for foldl it'd have something like foldl f z [1..] would be something like  f (f (f z 1) 2) 3 (or however it works..)
14:15:01 <vixey> > foldl f z [1..]
14:15:19 <vixey> > foldl f z [1..3]
14:15:24 <lambdabot>   f (f (f z 1) 2) 3
14:15:59 <mofmog> i have a data structure like data Foo a = Foo a, and i'd like to say that a Bar is a Foo that contains an Integer
14:16:00 <seliopou> what is this chicanery!
14:16:04 <mofmog> who do i go around doin' this?
14:16:24 <seliopou> type Bar = Foo Integer
14:16:28 <mofmog> thanks
14:16:44 <seliopou> you might also want to look into newtype
14:16:54 <mofmog> i did, but it wasnt working right
14:17:33 <seliopou> newtype Bar = Bar (Foo Integer)
14:17:35 <seliopou> ?
14:18:16 <vagif> Hello, anyone using hs-dotnet or com package on windows ?
14:18:30 <Heffalump> vagif: I've tried hs-dotnet briefly
14:18:34 <Heffalump> but nothing beyond the example code
14:18:48 <vagif> i installed hs-dotnet
14:19:16 <dons> vagif: i sit near the author, if you have questions :)
14:19:27 <vagif> but when trying to run examples in ghci i get :
14:19:27 <vagif> *** Exception: NET bridge error:
14:19:29 <vagif>  Location: NET.Base.createObject
14:19:29 <vagif>  Source: System.Windows.Forms.Form
14:19:29 <vagif>  Kind: COM error: 0x80040154 Class not registered
14:19:43 <dons> but that doesn't happen if you compile it?
14:19:44 <Heffalump> did you install it with cabal install?
14:19:53 <vagif> yes cabal install
14:20:01 <vagif> no error on complie
14:20:10 <Heffalump> there was a bug in the cabal file, which I'm not sure if he's uploaded a fix for yet
14:20:14 <dons> bulat's had 35k downloads of his gtk-based freearc
14:20:25 <dons> all without cabal help to put it in distros
14:20:44 <Heffalump> ok, I don't think he has. One sec.
14:21:13 <vagif> so i just reinstall hs-dotnet with cabal install, when cabal file is fixed ?
14:21:26 <dons> you might need to cabal update to get the newest version?
14:21:30 <Heffalump> yes, and the fix is just to change it from build-type: simple to build-type: (not simple)
14:21:38 <dons> mwhaha
14:21:43 <Heffalump> where (not simple) is whatever it is with a custom Setup.hs, that I forget
14:21:43 <dons> Configure ?
14:21:48 <dons> Custom?
14:21:50 <Heffalump> yeah, that
14:21:58 <Heffalump> and then just redo the cabal install from the unpacked director
14:21:58 <Heffalump> y
14:22:13 <Heffalump> alternatively you can manually run the register command that's in the readme, I forget the details
14:22:20 <Heffalump> dons: tell Sigbjorn to upload the fix :-)
14:22:44 <dons> ok.
14:24:04 <dons> bug report lodged
14:27:04 <vagif> Heffalump: hs-dotnet did work after i manually run gacInstaller and regasm
14:27:09 <vagif> Thx!
14:27:13 <ImInYourMonad> how can I prove: n+n = 2 * n ? it is by definition because thats hwo I defined (*)...
14:29:51 <vagif> question on hs-dotnet. Is it possible to use non dotnet com packages through hs-dotnet ?
14:30:45 <p_l> vagif: certainly, if you connect to them through .NET
14:31:05 <vagif> p_l: how do i do that ?
14:31:15 <p_l> vagif: read .NET docs
14:31:20 <vagif> :) ok
14:31:36 <Heffalump> there's a whole bunch of stuff to do with generating interop code
14:32:12 <vagif> i see. I was hoping there's an easy way
14:32:43 <p_l> vagif: depending on the version of .NET runtime, you should be able to generate proxy classes on the fly from COM objects
14:33:26 <dons> sigbjorn sez:
14:33:27 <dons> "Many thanks. Thought I had included this already in a refresh release, but
14:33:27 <dons> my
14:33:27 <dons> mind is fuzzy. The whole thing has been rewritten and extended since then
14:33:27 <dons> though;
14:33:30 <dons> time to do a new major release very soon."
14:33:52 <dons> you should email him with feedback
14:33:59 <dons> he's very keen to help practical use
14:34:54 <mofmog> is there a function like iterate but for finite lists?
14:36:02 <Peaker> mofmog: take after iterate?
14:36:05 <dolio> take n . iterate f
14:37:17 <mofmog> ah, that works
14:37:21 <mofmog> go go lazy evaluation
14:37:47 <dolio> That should be just as efficient as a direct one after fusion, too.
14:37:59 <dolio> Assuming take and iterate are written right.
14:39:47 <mofmog> hm, what if i wanted to sometimes use an infinite list and sometimes a finite list?
14:40:02 <mofmog> in a function that used iterate
14:40:28 <mofmog> the thing being that i would take the amount of elements in the list
14:40:33 <vixey> mofmog: just program it that way then
14:41:01 <vixey> no?
14:41:30 <mofmog> take l $ iterate f lst where l = length lst
14:41:46 <mofmog> what if lst were infinite?
14:41:55 <vixey> then you have to reimplement take
14:41:55 <Peaker> mofmog: some would prefer that as:  take l . iterate f $ lst ...
14:41:57 <Heffalump> @type iterate
14:41:59 <lambdabot> forall a. (a -> a) -> a -> [a]
14:42:06 <vixey> :t take
14:42:07 <lambdabot> forall a. Int -> [a] -> [a]
14:42:10 <Heffalump> so while iterate can take a list, it doesn't have to
14:42:12 <vixey> it doesn't handle Natural numbers for example
14:42:14 <Heffalump> so do you really mean iterate?
14:42:20 <c_wraith> I thought the problem was that length doesn't terminate on an infinite list
14:42:26 <vixey> Natural is really the wrong term
14:42:27 <vixey> :t infinity
14:42:28 <lambdabot> Natural
14:42:40 <ImInYourMonad> so 1+1=2 cant actually be proven
14:43:13 <c_wraith> It can, depending on your axiomatic system.
14:44:03 <ImInYourMonad> in ZFC?
14:44:07 <c_wraith> Certainly
14:44:22 <c_wraith> ZF wouldn't be of much use if it couldn't prove that.
14:45:02 <mofmog> i'm basically doing my own version of sigfpe's cellular automata code
14:45:11 <Gracenotes> it was 'proved' in Principia Mathematica, at least
14:45:12 <mofmog> but i just want a finite "universe" so to speak
14:45:21 <ImInYourMonad> Theorem n_plus_n_Eq_n_mult_2 : forall n : nat, plus n n = mult n 2.
14:45:27 <ImInYourMonad> i cant even prove that
14:45:28 <Gracenotes> proven that is
14:45:40 <vixey> Gracenotes: well I think they used type theory there, but I haven't read it
14:45:50 <insane> hello
14:45:53 <Gracenotes> mm. very thick stuff...
14:46:12 <insane> what is Paths_hackage_server module and where i can get it
14:46:12 <insane> ?
14:46:54 <Junior> hello
14:47:09 <Gracenotes> ImInYourMonad: it should be provable on the natural numbers, at least by induction (compsci's favorite method >_>)...
14:47:30 <mofmog> ah nvm it works
14:47:57 <b\6> insane: i think it's something provided by cabal so your code can get its version number and stuff like that.
14:48:17 <Gracenotes> if (n+n = n*2), then (n+1+n+1 = (n+1)*2). maybe.
14:56:27 <hahagaj> q
14:57:55 <kerlo> Ello.
14:58:29 <ImInYourMonad> and then?
14:58:46 <ImInYourMonad> (n+n = n*2), then (n+1+n+1 = (n+1)*2) -> 2(n+1) = 2(n+1)?
14:58:49 <ddarius> 0 + 0 = 0 = 0 * 2 (additive identity and multiplicative zero), if n + n = 2n then (n + 1) + (n + 1) = (n + n) + (1 + 1) = 2n + 2 = 2(n+1)
14:59:09 <ddarius> commutativity of addition, induction hypotheses, distributivity
15:01:10 <Gracenotes> then again, if you want to prove that they're equal, you might want to go both ways
15:01:44 <Gracenotes> hmmm.
15:02:15 <Gracenotes> no, shouldn't have to. never mind.
15:02:25 <ImInYourMonad> doyou know how to do that stepin Coq?
15:03:26 <zakwilson> I am trying to install leksah. When I try to install gtksourceview2 from gtk2hs, I get:
15:03:27 <zakwilson> cabal: gtksourceview2.cabal:10: Parse of field 'exposed-modules' failed.
15:09:53 <tromp> :t splitAt
15:09:54 <lambdabot> forall a. Int -> [a] -> ([a], [a])
15:10:21 <Baughn> :t second
15:10:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:10:29 <wchogg> zakwilson : When I installed the gtksourceview2 component, ./configure automatically set it up for install once the c headers were installed
15:10:58 <Baughn> > iterate (second (splitAt 2)) [1..]
15:10:59 <lambdabot>   Couldn't match expected type `[a]'
15:11:07 <dons> @tell jeffersonheard it would be great to have a gallery of your haskell-generated imagery on your blog
15:11:08 <lambdabot> Consider it noted.
15:11:14 <Baughn> > iterate (second (splitAt 2)) ([],[1..])
15:11:15 <lambdabot>   Couldn't match expected type `[a]'
15:11:54 <Baughn> > iterate ((splitAt 2) . snd) ([],[1..])
15:11:55 <lambdabot>   [([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
15:11:55 <tromp> :t readInt
15:11:56 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
15:12:18 <Baughn> > iterate (fst . (splitAt 2) . snd) ([],[1..])
15:12:22 <lambdabot>   Couldn't match expected type `(a1, [a])'
15:12:32 <Baughn> > map fst $ iterate ((splitAt 2) . snd) ([],[1..])
15:12:34 <lambdabot>   [[],[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],...
15:13:21 <aluink> @type snd
15:13:22 <lambdabot> forall a b. (a, b) -> b
15:13:23 <zakwilson> wchogg: trying to install leksah still complains that gtksourceview2 is not installed.
15:15:13 <ImInYourMonad> but if 1+1=2 can be proven in ZFC, then it makes ZFC inconsistent or in complete right? whcih emans ther is soemthing lse you cant prove? then why not just assume 1+1=2 since everyone can agree on that one? :P
15:16:15 <wchogg> zakwilson : when you configured gtk2hs, did it list gtksourceview2 as one of the packages it'd install?
15:16:22 <Apocalisp> Here's one for you
15:16:23 <Apocalisp> @let (^^^) 1 x y = x * y
15:16:25 <lambdabot>  <local>:1:0:
15:16:25 <lambdabot>      Warning: Pattern match(es) are overlapped
15:16:25 <lambdabot>               In...
15:16:30 <Apocalisp> oh boo
15:16:31 <Baughn> ImInYourMonad: No, that's not right. Any formalism powerful enough to prove its own consistency will, in fact, turn out to have unprovable bits - but 1+1=2 isn't enough for that.
15:16:35 <Apocalisp> @undefine (^^^)
15:16:52 <Baughn> ImInYourMonad: You should try using it to prove that your proof mechanism works. ;)
15:16:54 <Apocalisp> @let (^^^) 1 x y = x * y
15:16:56 <lambdabot>  Defined.
15:17:01 <zakwilson> wchogg:  I didn't notice the first time around. I'm re-doing the install. This time it did list it as to be installed.
15:17:03 <Apocalisp> @let (^^^) k x 1 = x
15:17:04 <lambdabot>  Defined.
15:17:10 <Apocalisp> @let (^^^) k x y = (^^^) k x ((^^^) (k-1) x (y-1))
15:17:10 <Gracenotes> :ox
15:17:11 <lambdabot>  Defined.
15:17:46 <Gracenotes> you're sure it's not redefining over it?
15:17:48 <Apocalisp> Which is bigger, (^^^) 100 2 3 or (^^^) 27 15 ?
15:17:59 <Baughn> ImInYourMonad: More to the point, "2 = 1 + 1" is usually a definition, not something that requires proof
15:18:10 <Apocalisp> Which is bigger, (^^^) 100 2 3 or (^^^) 99 27 15 ?
15:18:29 <Gracenotes> ;.;
15:19:12 <Apocalisp> > (^^^) 1 2 3
15:19:15 <lambdabot>   6
15:19:22 <Apocalisp> > (^^^) 2 3 4
15:19:37 <lambdabot>   thread killed
15:19:38 <Gracenotes> so it is :\
15:19:41 <Apocalisp> :)
15:20:02 <Gracenotes> > (^^^) 2 4 3
15:20:04 <Baughn> > (^^^) 2 3 4 :: Expr
15:20:17 <Gracenotes> > (^^^) 1 2 3 :: Expr
15:21:14 <Baughn> Oh dear
15:21:34 <mk15> lambda bot is dead :(
15:21:42 <Apocalisp> @bot
15:21:42 <lunabot>  :)
15:22:19 <Apocalisp> I guess I have an infinite recursion there
15:22:58 <Gracenotes> or something exponential/tetrated
15:24:44 <mopped> if I only /2 on even numbers, how can I still make the types work with integers?
15:24:59 <ddarius> Use div
15:24:59 <Baughn> mopped: Use div instead
15:25:05 <ddarius> or quot
15:25:19 <mopped> thanks
15:27:02 <elena> #
15:28:08 <mopped> How about extracting an a from a Just a?
15:28:43 <vixey> extract (Just a) = a
15:28:52 <mopped> thanks
15:29:12 <Baughn> @src fromJust
15:29:25 <Baughn> mopped: Oh right. ANyway. It's called fromJust.
15:30:28 <ksf> how do I get hold of gtksourceview2 >=0.10.0?
15:30:45 <BMeph> vixey: Trisky. ;p
15:30:57 <ksf> it's not on hackage (surprise, surprise), and the gtk2hs ebuild neither installs it by default nor offers a use flag
15:31:09 * BMeph sighs at his horrid typing skliis...
15:31:28 <Baughn> ksf: You need to emerge the gtksourceview package first
15:32:16 <Baughn> ksf: And then "hope" it isn't explicitly disabled in the gtk2hs build. It should be, but then there should be a use flag too.
15:32:30 * ksf reads the ebuild
15:32:51 <ksf> the gnome flag depends on gtksourceview...
15:33:13 <BMeph> , Nothing >>= Just
15:33:18 <lunabot>  Nothing
15:33:36 <BMeph> , (Just 3) >>= Just
15:33:38 <lunabot>  Just 3
15:33:57 <BMeph> Bah, NM. :p
15:34:28 <BMeph> BBL - it's quitting time! :)
15:34:29 <ksf> does gtksourceview depend on gconf and glade, or do I have reason to complain?
15:35:18 <ksf> *sigh* no, it doesn't.
15:38:02 <vixey> @w80 exegenesis
15:38:12 <vixey> @w80 exegesis
15:38:28 <coco`> my program swaps... is there any way to tweak the RTS to do more aggressive garbage cocllection so as to avoid swapping?
15:38:57 <dons> set a lower heap bound. +RTS -M100M
15:38:59 <dons> for example
15:39:20 <dons> but if it's swapping, probably means an error (space leak , for example) or inappropriate data type. unless you know that's the expected memory rqeuirement
15:39:57 <mopped> hmm, i'm trying to use Data.Map as a cache, but i'm having trouble incorporating it into a recursive algorithm, or well, how I could do it at all without sideeffects/OO
15:40:07 <Apocalisp> @bot
15:40:07 <lunabot>  :)
15:40:10 <coco`> dons: I actually handle huge amounts of data, so it makes sense that it swaps
15:40:12 <vixey> mopped state monad
15:40:14 <lambdabot> :)
15:40:15 <dons> ok. :)
15:40:26 <Apocalisp> @undefine (^^^)
15:40:29 <dons> coco`: you might also try the compacting garbage collector
15:40:31 <dons> +RTS -c
15:40:32 <coco`> dons: I'll try the heap trick
15:40:37 <Apocalisp> @let (^^^) 1 x y = x * y
15:40:37 <mopped> ill look into it vixey, thanks
15:40:40 <dons> see the ghc runtime flags section in the user's guide
15:40:44 <Apocalisp> @let (^^^) k x 1 = x
15:40:44 <lambdabot>  Defined.
15:40:50 <lambdabot>  Defined.
15:40:59 <Apocalisp> @let (^^^) k x y = (^^^) (k-1) x ((^^^) k x (y-1))
15:41:04 <lambdabot>  Defined.
15:41:10 <Apocalisp> > (^^^) 2 3 4
15:41:18 <lambdabot>   81
15:41:21 <Apocalisp> yay
15:42:06 <Apocalisp> > (^^^) 3 4 5
15:42:08 <lambdabot>   * Exception: stack overflow
15:48:46 <singintime> wohooo just got my first program to work ;)
15:49:43 <singintime> it is called WorldDominator, v0.0.0.00000prealpha
15:49:55 <dons> sounds useful.
15:50:05 <singintime> by now it just opens a file and prints it to screen
15:50:09 <singintime> but beware
15:50:16 <Gracenotes> D:
15:50:21 <singintime> very soon I'll take control over your minds
15:50:31 <singintime> bwahahah
15:50:40 <singintime> *idiot mode off*
15:50:43 <gnut> is it more inefficient to define "data A = A Int Int; type B = [A]" vs "data B = B [Int] [Int]"? or are they the same?
15:50:43 <lambdabot> gnut: You have 1 new message. '/msg lambdabot @messages' to read it.
15:51:50 <mauke> gnut: they're different
15:51:52 * Gracenotes likes the former.. better to traverse n elements than 2n.
15:51:53 <ddarius> They're not even conceptually the same.
15:52:03 <Gracenotes> assuming the elements are 'paired' in the second
15:52:21 <Gracenotes> in which case one can just do data B = B [(Int, Int)] as well
15:52:24 <Apocalisp> > (^^^) 3 2 2
15:52:25 <lambdabot>   4
15:52:27 <Apocalisp> > (^^^) 3 2 3
15:52:29 <lambdabot>   16
15:52:32 <Apocalisp> > (^^^) 3 2 4
15:52:33 <lambdabot>   65536
15:52:35 <Apocalisp> > (^^^) 3 2 5
15:52:38 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
15:52:56 <gnut> Gracenotes: yes. that would work as well.
15:53:07 <gnut> I was just wondering how I should store my data.
15:53:35 <gnut> I guess it'll depend on how I plan to read or write into it. hmm...
15:53:54 <Apocalisp> > length $ show ((^^^) 3 2 5)
15:53:57 <lambdabot>   19729
15:54:10 <Gracenotes> if you have interesting operations you'd like to define for the int pairs, a second datatype might be useful
15:55:08 <Gracenotes> if it's just keeping state for not-so-related numbers, tuples would do fine as well
15:55:20 <Gracenotes> a type or newtype of (Int, Int). Or just use (Int, Int). Or A Int Int. or.. etc.
15:57:33 <gnut> hmm...
16:06:55 <mofmog> so algol apparently had something similar to case statements in haskell
16:07:32 <vixey> yeah ALGOL is way ahead of it's time
16:07:42 <mofmog> (was)
16:08:13 <mofmog> actually, algol seems to have the java feature creep thing going on for it, but it wasnt so much feature creep as feature diarrhea
16:08:32 <vixey> no
16:09:38 <ImProvablyWrong> http://leksah.org/screenshots.html <- anyone tried it?
16:09:50 <dons> played with it today. pretty nice.
16:09:56 <dons> didn't do anything serious with it yet.
16:12:43 <mofmog> ill wait for the emacs plugin
16:12:48 <mofmog> ohw ait
16:16:36 <roconnor> can leksah give me types of subexpressions while editing?
16:17:34 <vixey> where does quantum mechanics fit into all this curry-howard type stuff?
16:18:06 <zakwilson> I just tried Lekseh. No REPL?
16:23:27 <ddarius> vixey: What makes you think it does?
16:24:05 <vixey> ddarius: mostly because computer scientists study it
16:24:17 <vixey> not really a strong justification.. yet
16:24:30 <ddarius> Study what?
16:24:32 <vixey> there is quantum IO monad in Haskell, stuff like this
16:24:40 <vixey> quantum ... things
16:24:56 <vixey> it's something I don't really know about yet
16:25:11 <ddarius> As far as I can tell, computer scientists mostly study quantum computing.
16:25:20 <wchogg> I don't know if there's really been much work on a _type theory_ for quantum computation, so I don't know if there's much to connect it to logic yet.
16:25:24 <ddarius> There is however a bit of a connection, though not directly to CH.
16:25:28 <ImProvablyWrong> instance Monad Entanglement where return v = Entanglement v; Entanglement v >>= f = f v
16:26:16 <ImProvablyWrong> lol vixey: you dont knwo what quantum mechanics is?
16:27:12 <ddarius> ImProvablyWrong: What is quantum mechanics?
16:46:01 <vixey> "A more controversial viewpoint consists in looking for /disturbing/ semantics, which shed unexpected lights on the systems we know. Of course, this viewpoint is highly criticizable since there is no absolutely certainty that anything will result from such attempts"
17:08:24 <ImInYourMonad> why do people make sutff downlaodable only via darcs?
17:10:15 <dons> ImInYourMonad: they shouldn't really. at least, there must be releases on hackage
17:10:26 <dons> snapshot tar.gz seem to have become obsolete though
17:14:10 <stepcut> ImInYourMonad: because haskell programmers are lazy ;)
17:18:00 <iago_> am I the unique that thinks that should exists a specific RandomR class for randomR and randomRs?
17:19:16 <dolio> In case you want to generate random things that aren't sensibly ordered?
17:19:57 <iago_> yep, more concrete when the type that I'm instantiating isn't of Ord class
17:20:10 <ddarius> :t randomR
17:20:12 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
17:20:24 <iago_> haven't got sense to define randomR, you finally do randomR _ = random
17:22:28 <iago_> and are cases too where I don't see the sense of define randomR for Ord instances
17:22:30 <iago_> like [a]
17:22:50 <iago_> what will be randomR([1,2], [2,1])
17:23:28 <dolio> > let l = [1,2,3] in [1,2] < l && l < [2,1]
17:23:30 <lambdabot>   True
17:23:35 <dolio> Yeah, I don't disagree.
17:27:05 <Axman6> @instances Random
17:27:06 <lambdabot> Couldn't find class `Random'. Try @instances-importing
17:27:28 <Axman6> @instances-importing System.Random Random
17:27:29 <lambdabot> Bool, Char, Double, Float, Int, Integer
17:27:42 <dolio> Random is lacking in instances.
17:32:18 <Axman6> > 40*356.25*24*60*60 / 30
17:32:20 <lambdabot>   4.104e7
17:32:26 <Axman6> > 40*356.25*24*60*60 / 30 :: CReal
17:32:28 <lambdabot>   41040000.0
17:32:54 <mofmog> perhaps nesting a comonad inside another comonad was a terrible idea
17:33:07 <Axman6> ^^ how many copies of the very hungry catapillar have been sold since 1969 (one every 30 seconds)
17:35:14 <solidsnack> mofmog: i herd u like monadz
17:36:40 <mofmog> i herd u like comonads so i put a comonad so you can comonad while you comonad
17:36:51 <mofmog> *ghc's type unification system then explodes*
17:37:39 <mofmog> protip: if you want to extract an integer from a comonad, you shouldn't nest your comonads because then you have to go from w (w a) -> (w a) -> a
17:40:23 <roconnor> <vixey> where does quantum mechanics fit into all this curry-howard type stuff?
17:40:30 <roconnor> something about linear logic
17:40:35 <centrinia> Is anyone else having trouble visiting Lambda The Ultimate's web site because of duplicate keys in their database?
17:49:00 <wli> extract . join?
17:49:22 <wli> No need, I guess. extract . extract
17:53:05 <centrinia> @type extract
17:53:06 <lambdabot> Not in scope: `extract'
17:53:18 <dolio> extract :: Comonad w => w a -> a
17:55:00 <SubStack> @pl (tail xs, head xs)
17:55:00 <lambdabot> (tail xs, head xs)
17:55:09 <SubStack> @pl \xs -> (tail xs, head xs)
17:55:09 <lambdabot> liftM2 (,) tail head
17:55:16 <dolio> tail &&& head
17:55:22 <SubStack> nifteh
17:55:49 * SubStack still needs to read about those nifty arrows
17:57:21 <SubStack> that function sure did get shorter
18:01:28 <wli> You should've seen the vector accumulation.
18:03:04 <wli> @type uncurry (flip $ map . flip (/)) . foldr ((*** (+1)) . zipWith (+)) (repeat 0, 0)
18:03:05 <lambdabot> forall b'. (Fractional b') => [[b']] -> [b']
18:13:17 <adimit> erhm. How can it be that cabal gives me *this* error message? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2702#a2703
18:27:44 <bremner> so I have a class familiar with the basics of function programming, but only a little haskell, and I'm thinking of taking them through haskell types and intro to monads in 3 weeks (9 hours of lectures). Too ambitous? Any suggestions for supporting material?
18:31:05 <ozy`> bremner: RWH? it's a perfect example of how to introduce monads, I think
18:32:07 <bremner> ozy`: yeah, it is not bad. I'm wondering if doing chapters 1-4, and then 14 will make people's heads explode
18:34:23 <ozy`> be sure to show them how the syntax works
18:34:54 <bremner> yeah, they have seen the basic syntax for functions
18:35:07 <bremner> or you mean the bind syntax?
18:35:38 <ozy`> well, I mean, make sure they know all the different ways a function can be either prefix or infix
18:36:14 <bremner> ahh, good point.
18:36:26 <ozy`> 'cause that in particular can be mad confusing, dawg
18:36:29 <Saizan_> adimit: have you used cabal upgrade? however it's generally wise to unregister process-1.0.1.1
18:37:07 <Saizan_> adimit: you'd have to unregister a Cabal or haskell98 package in the user db too
18:37:32 <Saizan_> adimit: you'd find one of the two that has the same version as the corresponding package in the global db
18:37:56 <Saizan_> adimit: and since the one in the user db masks the other, you can get such an error
18:48:28 <dons> what's happening, hip cats?
18:49:19 <bremner> hey dons, just talking about RWH 1-4, 14, as a mini-haskell course :-)
18:49:26 <dons> cool!
18:50:09 <bremner> Its for a programming languages concepts class, so I'd like to cover monads, but I only have 3 weeks
18:50:23 <dons> oh, you'll be presenting material from RWH for the class?
18:50:28 <bremner> they know about higher order functions going in
18:50:45 <bremner> dons, I'm thinking so, I haven't got it all organized yet
18:50:47 <dons> ah, and then they move on to prolog or some other paradigm?
18:51:13 <dons> they're teaching the stm and parallelism chapter at standford and penn state, iirc
18:51:22 <dons> actually, stanford might be doing most of  the book
18:51:39 <dons> we should have a teaching page, about how to use material for teaching
18:51:41 <bremner> actually they have been using Oz (and the corresponding book by Van Roy and Haridi)
18:51:43 <centrinia> How well do the students take STM?
18:51:54 <dons> better than taking locks :)
18:51:56 <bremner> dons: yeah, I think a teaching page is a good plan
19:00:30 <Botje> we're using RWH for our haskell classes too
19:02:49 <SubStack> nifty
19:02:58 * SubStack is planning on ordering that soon
19:03:33 <SubStack> also might be doing some functional meetup stuff this summer on account of all the curious people around
19:03:42 <SubStack> despite the smallness of this town
19:05:10 * SubStack gets to write nifty haskell programs for work \o/
19:06:08 <byorgey> SubStack: congrats =)
19:06:27 <Nafai> SubStack: Yay!
19:06:34 <Nafai> I'm still doing Python :)
19:06:34 <SubStack> replacing some complicated c code that nobody understands with something pretty
19:06:54 <SubStack> ease of concurrency is a big plus
19:06:58 <SubStack> and portability
19:07:52 <SubStack> Nafai: it could be worse (IE: PHP)
19:08:11 <SubStack> lots of ruby here
19:10:10 <Nafai> SubStack: Yes, it could.  I just escaped Java, so life is good :)
19:10:23 <SubStack> indeed
19:10:57 <Nafai> Eventually it will be Haskell
19:11:01 <SubStack> :D
19:11:35 <SubStack> I also might get to build something in either erlang or haskell this summer for managing parallel batch jobs
19:12:21 * Botje would also like a job without java
19:16:45 <Nafai> Botje: I did 3 years in Java-land
19:18:26 <Botje> *shiver*
19:18:35 <Vorschlagsnoten> it wasn't that bad, was it?
19:19:47 <p_l> he could be doing 15... :P
19:22:35 <cocon> why is there no primitiv sub-array operation?
19:23:04 <Olathe> What's a subarray operation ?
19:23:25 <sciolizer> @hoogle (a -> Either b c) -> [a] -> ([b],[c])
19:23:26 <lambdabot> No results found
19:23:26 <Vorschlagsnoten> you can define an Array of (Int, Int) if you want for multi-dimensional access
19:24:07 <cocon> Olathe: make a new array with a contiguous subset of elements in the old array
19:24:56 <cocon> say we have a,b,c,d,e. I would like to grab e.g. b,c,d
19:25:09 <Olathe> It's not too hard to make something to do that.
19:25:23 <cocon> without allocating fresh memory?
19:26:04 <Olathe> @type ixmap
19:26:05 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
19:26:13 <lowmagnet> does anyone here run gtk2hs on mac?
19:26:16 <cocon> Olathe: I know it's not hard in general
19:26:23 <Olathe> cocon: subArray bnds = ixmap bnds (\i->i)
19:26:42 <Olathe> @type subArray
19:26:44 <lambdabot> Not in scope: `subArray'
19:26:56 <Olathe> @type let subArray bnds = ixmap bnds (\i->i) in subArray
19:26:56 <lambdabot> forall i e. (Ix i) => (i, i) -> Array i e -> Array i e
19:27:12 <lowmagnet> http://rafb.net/p/CbQcJ323.html    <--- my attempt to get gtk2hs up and running, failing on 'openBinaryFile'
19:27:15 <cocon> Olathe: this will copy the pointers into a new array
19:27:25 <cocon> Olathe: I want to avoid the copying
19:27:43 <Olathe> Are you sure it will ?
19:27:44 <Vorschlagsnoten> how can you be so sure it'll copy?
19:28:27 <Vorschlagsnoten> unfortunately, if you feed Olathe's version (x, y), it'll just make an array with x referring to the first element of the old array
19:28:38 <Vorschlagsnoten> not quite what you want
19:28:50 <cocon> ixmap has to copy because it doesn't know you're giving it (\i->i)
19:30:10 <Olathe> Vorschlagsnoten: No, it will start at index x of the old array.
19:30:36 <Olathe> ixmap b f a = array b [(i, a ! f i) | i <- range b]
19:30:55 <wli> I'm sort of unhappy with the codebase. I wonder if I should clean it up in-place or do a semispace GC sort of cleanup.
19:30:58 <Vorschlagsnoten> well, one way to check
19:31:41 <Olathe> > array (1, 10) . map (\x -> (x, x)) $ [1..10]
19:31:43 <lambdabot>   array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
19:32:05 <Vorschlagsnoten> or..
19:32:05 <Olathe> > ixmap (2, 5) id . array (1, 10) . map (\x -> (x, x)) $ [1..10]
19:32:06 <lambdabot>   array (2,5) [(2,2),(3,3),(4,4),(5,5)]
19:32:07 <Vorschlagsnoten> > let ar = listArray (0, 10) [0..10] in ixmap (2, 4) id ar
19:32:08 <lambdabot>   array (2,4) [(2,2),(3,3),(4,4)]
19:32:27 <Vorschlagsnoten> so I see. meh, poor documentation
19:32:38 <Olathe> > ixmap (2, 5) (+1) . array (1, 10) . map (\x -> (x, x)) $ [1..10]
19:32:39 <lambdabot>   array (2,5) [(2,3),(3,4),(4,5),(5,6)]
19:33:00 <Olathe> > ixmap (2, 5) (+1) . array (1, 10) . map (\x -> (x, chr (x + 65))) $ [1..10]
19:33:01 <lambdabot>   array (2,5) [(2,'D'),(3,'E'),(4,'F'),(5,'G')]
19:33:12 <Olathe> > array (1, 10) . map (\x -> (x, chr (x + 65))) $ [1..10]
19:33:13 <lambdabot>   array (1,10) [(1,'B'),(2,'C'),(3,'D'),(4,'E'),(5,'F'),(6,'G'),(7,'H'),(8,'I...
19:33:30 <Olathe> Hmm...
19:33:44 <cocon> from the implementation it's pretty obvious what happens
19:33:51 <Vorschlagsnoten> if you're dealing with immutable arrays, it
19:33:59 <Vorschlagsnoten> it's clear enough there's going to be some copying anyway :\
19:34:14 <Olathe> It's not so hard to make an array wrapper, I suppose.
19:34:22 * wli suspects he's gone seriously astray somewhere and should start over.
19:34:32 * lowmagnet answered his own question. Try version 0.10 of gtk2hs since it supports current ghc
19:35:36 <Vorschlagsnoten> I suppose the libraries don't have a subarray function, then -- or at least one that fits your needs
19:38:41 <wli> The sheer volume of code suggests I'm doing it wrong and a rethink is necessary. Not to mention the fact so much of it is boilerplate.
19:39:29 <Vorschlagsnoten> cocon: suppose you modify the subarray?
19:40:12 <Vorschlagsnoten> what's the expected behavior there?
19:43:35 <Vorschlagsnoten> perhaps it's undefined things like that why a non-pointer-copying subarray on immutable arrays doesn't make much sense, when all of Array's other operations are inherently pointer-copying (immutable)
19:45:31 <Vorschlagsnoten> you can do it with mutable arrays (if that's what you're using), but as Olathe said one can make a wrapper
19:46:44 <Vorschlagsnoten> :\ perhaps more useful array functions will be added soon... it's not the most fun API to work with.
19:51:06 <wli> I'm thinking now that if I'm hash consed and have lexically unique subexpr tags that let expressions are meaningless, and I just do dependency analysis.
19:51:46 <wli> I'm also thinking that hammering in AST's is too painful to keep testing going in any meaningful sense.
19:52:35 <nanothief> With yi under archlinux, I'm getting the following error while loading the yi configuration file: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1938#a1938 . Anyone know what could be wrong?
19:54:01 <dons> nanothief: try recompiling haskell-regex-tdf
19:55:55 <nanothief> dons: right giving that a shot (I assume you meant haskell-regex-tdfa? haskell-regex-tdf wasn't there)
19:56:12 <dons> that's the one, yep.
19:56:26 <dons> recompile the failing package, recompile yi. it can be that you get out of sync in your dependency tree
19:57:42 <wli> I basically hash cons, eliminate vars in favor of subexpression indices as per hash consing, form the DAG of SCC's, and roll from there. Each originally anonymous subexpression or nonrecursive let just becomes a singleton node in the SCC DAG.
20:00:01 <kerlo> @type ord
20:00:02 <lambdabot> Char -> Int
20:00:48 <nanothief> dons, thanks that got it working
20:01:12 <wli> No need to float lets or anything silly like that because the SCC DAG is precisely everything floated exactly where necessary (no junk) with no artificial ordering constraints within antichains (no confusion).
20:03:10 <wli> Or maybe having everything floated to precisely where necessary is the analogue of no confusion and no artificial ordering constraints within antichains of the SCC DAG is the analogue of no junk.
20:05:11 <wli> I'm pondering how to represent nodes within the SCC DAG since they may correspond to whole sets of temporaries at once.
20:05:41 <ImInYourMonad> anyone good with fluid dynamics?
20:06:01 <Spark> game of life + fourier transform
20:06:25 <wli> I think it has more to do with labelling dependency arcs in the SCC DAG with the component of the SCC depended upon, i.e. the original temporary in the SCC.
20:06:59 <wli> Complicated by some need to keep the original variables' names around in some form for error reporting.
20:09:05 <wli> There's more than just that. let x = ... in x + x gives two arcs.
20:10:31 <wli> That's not a good one. Con { lab1 = x, lab2 = x } gives two arcs in a more essential way.
20:10:52 <pjb3> I'm trying to go through the Learn You a Haskell tutorial, and this example gives a parse error:
20:10:56 <pjb3> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
20:11:56 <wli> pjb3: It only works if entered into a file.
20:12:18 <pjb3> wli: Oh, right, or I could use let?
20:12:24 <TSC> pjb3: Try:  let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1..20]
20:12:34 <wli> > let boomBangs xs = [if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [7..12]
20:12:36 <lambdabot>   ["BOOM!","BOOM!","BANG!"]
20:12:56 <kerlo> @type chr
20:12:58 <lambdabot> Int -> Char
20:12:59 <wli> pjb3: Exactly.
20:12:59 <kerlo> @index chr
20:12:59 <lambdabot> Data.Char
20:13:10 <pjb3> thanks!
20:16:43 <ImInYourMonad> > let tintin_didnt_say = "bombs" ++ " and " ++ "grenades" in tintin_didnt_say
20:16:44 <lambdabot>   "bombs and grenades"
20:17:05 <wli> The lower shadow of a node in the SCC DAG is precisely the scope of a floated let.
20:17:26 <ImInYourMonad> how about in a DCG?
20:17:47 <wli> Definite clause grammars have no bearing on this that I'm aware of.
20:18:06 <BMeph> wli: cyclic, vs. acyclic. ;)
20:18:39 <wli> The graph formed by collapsing all nodes into their SCC's is necessarily acyclic.
20:19:13 <BMeph> IIYM: ^^
20:19:52 <wli> The whole affair is predicated on first transforming the graph as to eliminate cycles, then working on the acyclic graph.
20:21:58 <wli> I'll bet Dilworth's theorem comes in somehow.
20:23:02 <cocon> how can I tell for sure whether gch has optimized a typeclass dictionary away?
20:23:27 <cocon> (ghc that is)
20:29:10 <lispy> cocon: hmm...You could look at the core, but I don't know if that would tell you 100%
20:29:26 <lispy> cocon: there is a compile option to make ghc output the core, check the ghc manual
20:30:36 <soares> Is there any way to extend data declarations?
20:30:47 <soares> as in, I have "data a = {foo :: String}"
20:31:17 <soares> and I want something like "data b = {bar :: String} deriving a" which has both foo and bar
20:31:23 <soares> is that possible?
20:31:34 <lispy> soares: there is no subtyping in haskell
20:31:42 <lispy> soares: but, your b could contain an a
20:31:58 <soares> lispy: thanks, that's what I expected.
20:32:06 <soares> any chance of something similar coming around sometime?
20:32:14 <soares> it would certainly be nice
20:32:17 <glguy> no, it doesn't make sense to have it
20:32:24 <soares> glguy: why not?
20:32:24 <glguy> you'd break all of the existing libraries
20:32:25 <lispy> soares: more to the point, if you describe the problem your solving with this a and b, I bet others could suggest solutions that are "more native to haskell"
20:33:24 <soares> well, I'm toying around trying to learn the language (as may be evident), so I was going to make a toy text-based RPG
20:33:46 <soares> The particular issue I was having was, how do I have different types that have similar core data, but different data
20:34:19 <soares> for example, a Character data type with some scores, and then a "human" type with name, age, whatever, and a "monster" type with monstery attributes.
20:35:48 <cocon> lispy: hmm, is that as painful as it sounds?
20:36:03 <cocon> lispy: looking at the core, that is
20:36:09 <Petrosian> soares: data Character = Human { name :: String, age :: Integer, score :: Integer } | Monster { monsteryAttribute :: MonsteryAttribute, score :: Integer }
20:36:40 <Petrosian> soares: Then your "score" selector function will work on both.
20:36:54 <soares> that gets ickier if you later say "all characters should have a second score!" and you have twelve character types.
20:37:11 <soares> I mean, I'm not going to run into that issue here, I'm just messing around for fun
20:37:28 <soares> but it would be nice to have subtyping for that purpose.
20:38:55 <kerlo> Classes may be useful.
20:39:01 <StoneToad> soares: you could make the score of type ScoreType instead of Integer
20:39:27 <StoneToad> you could then add extra score info w/o changing your character type
20:39:32 <BMeph> soares: I recommend "playing around" with it first, then see what/if you missing from it. :)
20:39:45 <soares> yeah, that's probably what I'll end up doing
20:39:45 <Petrosian> soares: Alternatively, have a "Score" class, and make your different data types representing humans and monsters instances
20:39:58 <soares> the drawback is that I can't pattern match the scores if I do that.
20:40:14 <BMeph> soares: Er, you *are
20:40:42 <cocon> hmmm, can SPECIALIZE pragmas make things slower?
20:41:14 <Petrosian> soares: class Score a where getScore :: a -> ScoreType; instance Score Human where... etc.
20:41:26 <soares> glguy, I'm curious as to how adding subtyping would break existing libraries
20:41:51 <soares> Petrosian : cool, thanks. That still doesn't allow pattern matching, although I'm sure I'd never need it. Just exploring the possibilities, you know.
20:42:22 <glguy> soares, functions written that only assumed the old constructors would not know what ot do with your new ones
20:46:20 <ImInYourMonad> @faq can haskell always find smooth solutions for navier stokes equations?
20:46:21 <lambdabot> The answer is: Yes! Haskell can do that.
20:46:33 <ImInYourMonad> wow 1million dollar, some oen quick!
20:51:56 <kerlo> @faq Can Haskell make @faq say something else?
20:51:56 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:25 <wli> Hmm, there may be even more. Forcing relations between temporaries do interesting things, too.
20:55:09 <BMeph> Darn, I wanted a clearer explanation on what pattern matching he couldn't do.
20:55:19 <BMeph> He sounded so sure about it, too....
20:56:24 <FunctorSalad> maybe he meant "let Human a b c score = h in ..." (obtaining teh score by a pattern match)
20:56:37 <wli> Any time one thing is strict in another you sort of have a new compound operation not requiring a heap thunk. So it's sort of like connected components.
20:57:18 <FunctorSalad> now what this has to do with polymorphism... no idea :)
20:57:55 <wli> Not sure if that should be on the SCC DAG or not. I think you can be strict in the values of things that recurse, so yes.
20:59:02 <wli> The closures end up being the connected components according to forcing edges.
21:01:10 <wli> It's starting to sound like I've got work to do.
21:03:56 <wli> Am I on track with any of this?
21:10:56 <wli> Hmm. What if there are multiple dependencies on a value, some of which are strict, and some of which are not? Then the connected components fall down.
21:19:57 <wli> Maybe you want to partition the graph into components where all within-component edges are strict and all between-component edges are non-strict? I'm not sure what sort of stock graph algorithm that corresponds to right offhand.
21:23:29 <c_wraith> wli, that's just a bfs from each node not yet in a component, using only strict edges for the bfs.
21:23:35 <c_wraith> or dfs.  it doesn't matter
21:23:40 <c_wraith> I suppose dfs is easier
21:24:16 <wli> c_wraith: I'm not convinced that's correct just yet. I think there are more criteria for absorbing an operation node into a strict component.
21:24:18 <c_wraith> it's just determining connected subcomponents of a graph while ignoring some edges.
21:24:26 <c_wraith> ah.  Well if it's more complicated, so be it.
21:24:34 <c_wraith> But the problem you described is easy enough. :)
21:25:59 <wli> I think it's where you can only absorb a node into a strict component if there are no edges from the node to any other component and at least one edge to the strict component is strict.
21:27:41 <wli> I think that's sufficient but it may not be necessary in the sense that it may be easy to do better.
21:28:38 <c_wraith> In any case, these are just determining connected subcomponents via some criteria...  Easy enough, algorithmically.
21:29:31 <wli> It's not carrying out the algorithm that's such an issue, but figuring out what algorithm to use.
21:29:54 <cads> how could I convert the numbers [1..26^3] into the list of 3 letter strings of alphabetic letters ?
21:30:08 <vininim> uh, doesn't SCC follow from MST?
21:30:44 <wli> vininim: If so that helps in various ways. It might even throw out unused junk.
21:31:12 <wli> vininim: The SCC DAG is for a different phase anyway.
21:31:13 <idnar> cads: convert to base 26, maybe?
21:32:36 <ImInYourMonad> how do you define integers in haskell? data Integer = Pred Integer | Zero | Succ Integer ?
21:33:35 <wli> First off you use a different name so you don't clash with the Prelude.
21:33:49 <wli> data Z = Pred Z | Zero | Succ Z
21:34:42 <BMeph> cabs: What idnar said. See Numeric.showIntAtBase would be my first stop. :)
21:34:57 <wli> i'd try data N = NatZero | Succ Nat ; data Z = ZZero | Signed Bool N
21:35:29 <wli> where the N in the Signed case implicitly has 1 added to it.
21:38:25 <wli> absZ ZZero = NZero ; absZ (Signed _ n) = Succ n
21:41:29 <wli> newtype N = N (Either () N) ; type Z = Either () (Bool, N) ; absZ = either (Left ()) (Right . snd)
21:41:50 <wli> ugh
21:42:11 <wli> absZ = either (N $ Left ()) (N . Right . snd)
21:42:14 <blackdog_> got a bit of a curly algorithmic question: i have a big chunk of linguistic raw data - just wikipedia, processed into sentences. I'm trying to extract n-gram data from it. I have a program that does this, but it has to store everything in memory at once. this won't fly for 18gb. My next thought was to split it into bite-size chunks and dump each to a file, then have a haskell program that reads each file in as a lazy bytestring. i can make sure the data
21:44:30 <Gracenotes> :(
21:45:04 <blackdog_> ... actually, that won't work at all. gah. need to write to file at each step. you make an excellent teddy bear, #haskell.
21:46:12 <kerlo> I love IRC with its message truncation.
21:46:18 <kerlo> ". . . i can make sure the data"
21:47:32 <blackdog_> kerlo: ... ah, crap. i didn't realise. :)
21:55:54 <ImInYourMonad> is this correct for Nat: minus O b = O
21:56:28 <Cale> ImInYourMonad: It works well to define it that way, because it's what happens, for example, when dropping elements from a list.
21:56:40 <jfredett> ImInYourMonad: I'm fairly sure minus 0 b = undefined for that- just like 3/2 is undefined for integers.
21:56:55 <jfredett> but thats how I usualy define it.
21:57:39 <Cale> That is, you end up with nice laws like...  length (drop n xs) = minus n (length xs)
21:57:49 <Cale> er
21:57:57 <Cale> Or  minus (length xs) n
21:58:10 <Cale> depending on the order of the arguments :)
21:59:04 <Cale> There's a whole paper somewhere on why it's nice to make it work that way...
21:59:10 <Cale> I forget who wrote it though...
21:59:59 <BMeph> Who on "the committee" decided that it was a good idea to have functions that take Natural numbers as arguments, but not to have a Natural type? "Picachu, I blame YOU!" :\
22:01:10 <ImInYourMonad> ok thansk
22:01:27 <ImInYourMonad> i have plus minus mult dec inc
22:01:33 <ImInYourMonad> but divide is tougher
22:01:34 <TomMD> BMeph: In GHC source they introduces a 'nat' type - yay!
22:01:58 <ImInYourMonad> mult untilgoalor soemthing?
22:02:52 <jfredett> ImInYourMonad: do you want some hints?
22:03:05 <BMeph> TomMD: I'll say, "It's about time!", but I really am more grateful than that, especially if it gets exposed to users. :)
22:04:31 <jfredett> Velociraptors: AHH!
22:04:41 * Velociraptors !!!
22:05:13 * jfredett leaves #haskell [" Velociraptors, EVERYBODY RUN! "] 
22:07:54 <ImInYourMonad> jfredett: ill go to bed now and do it tomorrow
22:15:11 * Gracenotes wonders what a true/false quiz would look like if modified for intuitionistic logic
22:15:20 <kmeyer> :t replicate
22:15:21 <lambdabot> forall a. Int -> a -> [a]
22:15:38 <kmeyer> > replicate 5 "hi"
22:15:39 <lambdabot>   ["hi","hi","hi","hi","hi"]
22:16:28 <kmeyer> > replicateM 3 (putStr "hi")
22:16:30 <lambdabot>   * Exception: "<IO [()]>"
22:16:58 <kmeyer> > unsafeperformIO (replicateM 3 (putStr "hi"))
22:16:59 <lambdabot>   Not in scope: `unsafeperformIO'
22:17:21 <Gracenotes> gottem!
22:18:41 <idnar> BMeph: uhm, how do you call a function that takes Natural numbers as arguments if there's no type?
22:20:44 <kmeyer> > replicateM 3 (Just "hi")
22:20:45 <lambdabot>   Just ["hi","hi","hi"]
22:20:58 <kmeyer> > replicateM 3 (["hi"])
22:21:00 <lambdabot>   [["hi","hi","hi"]]
22:23:24 <BMeph> idnar: You just use Ints or Integers, and throw an error if the argument's negative.
22:24:49 <idnar> oh, right
22:27:12 <solidsnack> In the non-empty list GADT example, we see that we can make a function that works only one constructor/subtype of a GADT. http://www.haskell.org/haskellwiki/GADT#Example_with_lists
22:27:46 <solidsnack> The parsing examples show us that we can make functions that work on all constructors of a GADT.
22:28:42 <solidsnack> Can we make functions that work on only /some/ constructors of a GADT while not being partial in the sense of accepting unmatchable arguments?
22:29:30 <solidsnack> The example in the list segment seems to show, also, that we can not make a function that returns a "generic" instance of a GADT -- it must return but one of the concrete subtypes.
22:29:46 <solidsnack> Is this a limitation of GADTs?
22:34:07 <dolio> What is a '"generic" instance of a GADT'?
22:34:50 <ivanm> what is a GADT', as opposed to a normal GADT?
22:35:27 <dolio> It's a GADT ending a phrase being enclosed in single quotes.
22:35:50 <ivanm> oh, wait, there was a single quote before "generic"
22:36:00 <ivanm> the quotes all merged together when a read that line ;-)
22:36:54 <solidsnack> dolio: Like, consider the example list making function in the example I linked to -- the function named `silly`.
22:37:15 <solidsnack> In both cases, it clearly returns some `List x y`.
22:37:32 <dolio> Yes.
22:37:35 <solidsnack> But it's a different `List x y` in each case.
22:37:42 <solidsnack> So the function can not typecheck.
22:38:08 <solidsnack> I would call the type of that function a "generic instance of a GADT".
22:38:39 <dolio> To make it type check you'd have to give it the type: silly :: Num n => Int -> (exists y. List n y)
22:39:12 <solidsnack> dolio: Is there a way to write that in actually valid Haskell?
22:39:25 <solidsnack> Or is that basically not expressible in Haskell?
22:39:48 <dolio> You'd have to make up an existential wrapper type, because GHC doesn't have first-class existentials.
22:39:55 <zeno> hi im getting errors with cabal upgrade, might be this /usr/bin/ld: cannot find -ledit.  ld is installed. heres the full text http://pastebin.ca/1365660
22:41:37 <dolio> For instance, you could add 'data Unknown' and a constructor 'Wrap :: List a b -> List a Unknown' to the list type.
22:42:12 <dolio> Then 'silly 0 = Wrap Nil ; silly 1 = Wrap (Cons 1 Nil)' type checks with silly :: Num n => Int -> List n Unknown
22:42:33 <solidsnack> dolio: That is undesirable, from a certain point of view.
22:43:00 <dolio> This has nothing to do with GADTs, though.
22:43:07 <solidsnack> dolio: There is no way to introduce, for example, a `forall` into the type of `silly` to resolve the matter?
22:43:19 <solidsnack> Has nothing to do with GADTs?
22:43:42 <dolio> What is the type of "silly 0 = True ; silly 1 = 5"?
22:44:03 <dolio> It's Int -> exists a. a.
22:44:43 <zeno> dolio: why isnt it just Int -> a ?
22:44:59 <solidsnack> zeno: Different `a` in each case.
22:45:16 <zeno> ah ok
22:45:18 <dolio> Because Int -> a means that given an Int, your function produces a value of any type I choose.
22:45:40 <dolio> Int -> exists a. a means given an int, it produces a value of some type it chooses.
22:46:15 <solidsnack> dolio: Hmm.
22:46:47 <solidsnack> So we can not make a function that produces either empty or non-empty lists.
22:46:52 <dolio> Of course, I can write 'silly :: Int -> Either Bool Int ; silly 0 = Left True ; silly 1 = Right 5'
22:47:14 <solidsnack> The function must produce one or the other.
22:47:34 <solidsnack> However, we can make a function that processes any kind of list.
22:47:41 <dolio> But I can also write 'silly :: Num n => Int -> Either (List n Empty) (List n NonEmpty) ; silly 0 = Left Nil ; silly 1 = Right (Cons 1 Nil)'.
22:48:55 <solidsnack> dolio: I'm not really looking for a solution to my problem.
22:49:12 <solidsnack> Rather, I'd like to use the problem to understand GADTs better.
22:49:17 <dolio> If you're tracking empiness in the type system, and you want to return a list of unknown empiness, you need to hide it with an existential.
22:52:30 <solidsnack> dolio: If I want to specify that any caller of `silly` must be prepared to handle all cases of `List`, it looks like I can't do it.
22:52:59 <lepassive> I want a simple example of ListStore with TreeView
22:54:12 <dolio> How is using the Either or existential not forcing them to handle them all? Aside from the fact that you're never required to handle all cases in Haskell?
22:55:01 <solidsnack> dolio: In the first case, I basically have to introduce a new type for every subset of the cases. In the latter, I have to put a nonsense constructor in the data type.
22:55:22 <dolio> With the either he has to do case analysis on it, and handle the Empty and NonEmpty cases.
22:56:03 <dolio> Well, go ahead and get first-class existentials added to GHC. Then you don't need to add a constructor or make a new wrapper.
22:56:10 <solidsnack> Interesting.
22:56:19 <solidsnack> So that is the crux of the matter.
22:57:02 <solidsnack> The queer thing is that I can write functions that process any subset of the GADT, no problem.
22:57:40 <solidsnack> Well, I will do some testing and see how that works out, actually.
22:58:12 <dolio> You can, of course, encode existentials as their universal eliminators.
22:58:33 <solidsnack> zeno: Do you have libedit installed?
22:58:56 <solidsnack> dolio: Can you explain what that means in different words?
22:58:57 <dolio> And make it: silly :: Num n => Int -> (forall e. List n e -> r) -> r ; silly 0 k = k Nil ; silly 1 k = k (Cons 1 Nil)
22:59:53 <solidsnack> Intersting.
23:03:57 <dolio> You can even make it look like its own type, and more like the existential wrapper.
23:05:04 <dolio> type UnknownList a = forall r. (forall e. List a e -> r) -> r ; wrap :: List a e -> UnknownList a ; wrap l k = k l
23:05:07 <dolio> Or something like that.
23:05:23 <dolio> Then 'silly 0 = wrap Nil ; silly 1 = wrap (Cons 1 Nil)'.
23:05:47 <dolio> silly :: Num n => Int -> UnknownList n
23:09:49 <solidsnack> I am going to fool around with this in a minute. Thanks for your ideas.
23:17:40 <mofmog> ugh writing cojoin is making my head hurt
23:17:52 <mofmog> two dimensional zippers actually make my mind hurt
23:18:36 <ray> three dimensional zippers make my scalp hurt when i get my hair caught in them
23:20:11 <ivanm> @remember ray three dimensional zippers make my scalp hurt when i get my hair caught in them
23:20:12 <lambdabot> Nice!
23:20:54 <dolio> cojoin shouldn't be that complicated.
23:21:25 <lepassive> anyone using Gtk2HS ?
23:21:48 <mofmog> dolio: that's what i was thinking
23:21:52 <dolio> The focused element is the current zipper, and for any direction you can move, the zipper moved in that direction is at the spot in that direction in the produced zipper.
23:22:34 <mofmog> so what i'm trying to do is do 2 dimensional cellular automata comonadically
23:22:54 <mofmog> like sigfpe's one dimensional example but of course 2 dimensional
23:23:24 <dolio> I imagine the pain there is getting a nice zipper representation.
23:23:31 <mofmog> yeah exactly
23:23:37 <mofmog> what i have is pretty dumb i think
23:24:14 <mofmog> I have data OneDimension a = O [a] a [a], then I have data TwoDimension a = T [OneDimension a] (OneDimension a) [OneDimension a]
23:25:40 <mofmog> the reasoning being that I want it to be that to apply a rule, I do "twodimension =>> rule" where rule's type is "TwoDimension Integer -> Integer"
23:26:49 <dons> lepassive: yeah
23:26:54 <dolio> Well, before you write cojoin, I'd write left, right, up, down :: TwoDimension a -> Maybe (TwoDimension a).
23:27:33 <dolio> Although even then constructing it will probably be not quite ideal.
23:27:52 <lepassive> dons, mind giving me a simple example of listStore/Treeview with one column ? i don't find straight forward
23:27:55 <lepassive> one*
23:28:04 <mofmog> dolio: I do have those
23:28:10 <jfredett> dons: that Distributed Haskell library you popped up on reddit is a _mess_
23:28:39 <mofmog> i know cojoin is gonna have to put TwoDimensions inside the onedimensions oh god my head hurts
23:31:19 <dons> jfredett: yikes
23:31:30 <dons> lepassive: hmm. dig around on the gtk2hs site or mailing list
23:32:02 <lepassive> dons, I did, i checked even the demos examples nothing is straight, but thanks for your help anyway :)
23:32:04 <mofmog> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2708#a2708
23:32:40 <jfredett> dons: Yah- I mean, no organization to speak of (because, I think, back then, the hierarchy was not yet established), odd preprocessor stuff, it's all lhs to boot... very weird.
23:32:44 <dolio> Anyhow, if you have dup a = (a,a), then 'unfoldr (fmap dup . left) z' gest you a list of all the zippers that should go to your left. etc.
23:32:56 <jfredett> the library itself looks cool. but it's scary.
23:33:28 <Gracenotes> @hoogle left
23:33:29 <lambdabot> Control.Arrow left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
23:33:29 <lambdabot> Prelude Left :: a -> Either a b
23:33:29 <lambdabot> Data.Either Left :: a -> Either a b
23:33:44 <dolio> And if you start from any one of those, 'unfoldr (fmap dup . up) z' gets you all the things that should go above it, and so on.
23:33:53 <dolio> Then you just need to figure out how to wrap those up properly.
23:34:52 <dolio> At least, I think those are the right functions.
23:35:49 <mofmog> i just dont like Maybe
23:35:57 <dolio> Whether you want to go up/down followed by left/right or vice versa depends on how exactly you're representing the grid.
23:37:10 <solidsnack> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2709
23:37:26 <solidsnack> Writing an Eq instance for the List type is not working out.
23:38:15 <solidsnack> Couldn't match expected type `l' against inferred type `l1'    l' is a rigid type variable bound by the constructor `Cons' at...
23:38:18 <solidsnack> &c.
23:38:26 <solidsnack> Line 26
23:38:50 <jfredett> put parens around the Con x l and Cons x' l' ?
23:39:11 <Gracenotes> solidsnack: is y a phantom type variable..?
23:39:13 <jfredett> eg (Cons x l) == (Cons x' l') -- maybe it's not binding right...
23:39:16 <solidsnack> jfredett: Why would that matter? They are being used with an operator.
23:39:23 <jfredett> solidsnack: just in case... :P
23:39:38 <solidsnack> Gracenotes: Yes.
23:40:15 <Gracenotes> ah, I see. And GADT allows you to pattern match on GADT constructors?
23:40:16 <dolio> solidsnack: First write the function "eq :: List x y -> List x y' -> Bool".
23:40:35 <solidsnack> Gracenotes: Seem to. I am still learning them.
23:41:37 <solidsnack> dolio: Okay.
23:42:42 <dolio> (==) can only compare lists with the same emptiness by that declaration, and l and l' may not have the same emptiness in that case.
23:43:53 <mofmog> WAIT, USING A ZIPPER IS A TERRIBLE IDEA
23:44:05 <mofmog> i should be using coordinates to encode the focus
23:44:20 <solidsnack> or mudkipz
23:44:37 <mofmog> no i can avoid having comonads in my comonads
23:45:03 <dolio> An array with a designated coordinate is still a comonad.
23:45:15 <mofmog> yeah,b ut now i wont have a comonad inside a comonad
23:45:31 <mofmog> or something stupid like that
23:45:38 <p_l> ... I guess you only find out how cracked a community is when 4chan becomes essential reading ...
23:45:42 <Gracenotes> dolio: could that be fixed, the GADT issue, by making a typeclass with Empty and NonEmpty in it?
23:45:43 <mofmog> and changing the focus is now fairly straight foward
23:45:49 <dolio> That is an easier way to encode a pointed celular automaton.
23:45:55 <dolio> It also makes sure it's rectangular.
23:46:04 <Gracenotes> (loose definition of "fixed")
23:46:15 <mofmog> yeah, i guess i was too set on copying sigfpe
23:46:23 <dolio> What GADT issue?
23:46:42 <Gracenotes> solidsnack's
23:47:18 <solidsnack> Gracenotes: They do not have constructors, though.
23:47:28 <dolio> (==) is defined to work only on values of the same type, so if you're tracking emptiness or length or something in the type system, you'll only be able to use (==) on things of the same emptiness/length/whatever.
23:47:37 <solidsnack> So I can not declare any instances, I don't think.
23:47:51 <dolio> Of course, you also know if their types are different, they're trivially not equal.
23:47:55 <dolio> Presumably.
23:48:12 <dolio> Because no empty list is equal to a non-empty list.
23:48:15 <Gracenotes> there's no way to compare empty and non-empty lists then, I suppose
23:48:23 <Gracenotes> in that type setup
23:49:58 <dolio> The third case in that paste is technically unnecessary, because knowing that they have the same emptiness means that you can never have one be Nil and the other be Cons.
23:50:34 <solidsnack> dolio: I know that.
23:50:55 <solidsnack> Hmm.
23:51:08 <solidsnack> I just define two different instances of Eq?
23:51:28 <solidsnack> Then comparing an empty and a non-empty list is a type error.
23:51:43 <solidsnack> Which is badass or annoying, depending on your point of view.
23:52:01 <dolio> Well, if you define that eq, you can define your instance as "(==) = eq".
23:52:24 <dolio> Because eq works even if they don't necessarily have the same emptiness, but it of course still works if they do.
23:53:11 <dolio> You'll still never be able to use (==) with one empty and one non-empty list, because it's a type error.
23:53:20 <solidsnack> dolio: Ah.
23:53:25 <solidsnack> cursors
23:53:47 <dolio> That's the error you're getting. l and l' are both existentially quantified, so they may each have either Empty or NonEmpty types.
23:54:05 <dolio> So you can't call (==) on them unless you prove they have the same type.
23:57:03 <dolio> That's another option you have, incidentally.
23:57:36 <dolio> If you do: "Cons x l@(Cons _ _) == Cons x' l'@(Cons _ _) = x == x' && l == l'".
23:57:55 <dolio> The match against Cons in both cases proves they have the same type.
