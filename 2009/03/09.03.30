00:04:32 <TomMD> Did I miss some sort of huge change in which GHC 6.10 and later won't export class instances unless explicity stated?
00:04:47 <TomMD> It seems to be that or I found a massively annoying regression.
00:04:49 <dons> nope
00:04:55 <dons> hmm..
00:05:04 <dons> no one's said anything.
00:05:14 <dons> that'd break a lot of things too
00:05:30 <TomMD> dons: After I make sure a good version of network-data is on hackage could you try to install it and see if you get a Binary instance for Data.IP.IPv4Header
00:05:47 <dons> sure.
00:06:04 <dons> but i'm about to fall asleep. ping me with the test to run.
00:06:14 <TomMD> dons: Haddock sees it on hackage, so it should work
00:06:28 <TomMD> dons: But both ghc-6.10.1 and ghc-head don't see it for me.  ghc-6.8.3 works find.
00:06:29 <TomMD> fine
00:06:58 <TomMD> Just "cabal install network-data"
00:07:05 <TomMD> ghci load Data.IP
00:07:11 <TomMD> and get the :info for IPv4Header
00:07:27 <TomMD> If Binary isn't listed then you've got the same thing I have... even though it should be there.
00:07:57 <dcoutts> g'morning TomMD
00:07:57 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
00:08:11 <TomMD> dcoutts: Good evening!
00:08:34 <dcoutts> TomMD: I don't understand your question about persistence
00:09:10 <dcoutts> TomMD: there's no need to do anything on restart, the happstack framework takes care of loading the state checkpoint and replaying the log
00:09:12 <TomMD> Well, when I shutdown then restart hackage-server I lose all the packages I uploaded.
00:09:31 <dcoutts> TomMD: that's a regression then
00:09:45 <dcoutts> TomMD: and we should ask the happstack folk
00:10:02 <TomMD> dcoutts: Humm, I kill hackage-server after loading several packages then restart (same arguments for directories etc) and I get a clean slate.  I see the package files in the store directory.
00:10:16 <dcoutts> TomMD: that's broken
00:10:17 <TomMD> dcoutts: I'll bug them another time, unless you beat me to it.
00:10:45 <dcoutts> TomMD: because it should write the event log file after every state update
00:10:52 <TomMD> dcoutts: But I have another oddity tonight (if you see above) so perhaps I've just lost my sanity.
00:11:14 <dcoutts> and killing the process doesn't loose any data already written to the event log file
00:15:11 <wli> fsync() ...
00:18:51 <osfameron> @pl (\n l -> take n $ map (take n) l)
00:18:51 <lambdabot> liftM2 (.) take (map . take)
00:19:10 <osfameron> not as cute as map.map or zipWith.zipWith :-)
00:21:08 <Baughn> ..it occurs to me, by the time you split object files into a thousand pieces to get around the static linker, you probably should stop bothering to use that linker.
00:21:56 <bmh> hello
00:22:24 <wli> It can only gc on a section-by-section basis.
00:23:00 <bmh> The bad: I'm stuck at the airport for five hours, the good: I'm online and have ghc installed.
00:23:07 <Badger> heh.
00:23:07 <wli> You'd have to write something language-aware (or some such) to go digging around within sections and carry out an accurate gc.
00:23:13 <Badger> code, code, code!
00:28:20 <dcoutts> dons: nice quote from Xavier Leroy: Saying "I'll do 1, 3 and 4 from scratch", Harrop-style, means a 5-year project.
00:28:38 <dcoutts> dons: context OCaml/LLVM: http://caml.inria.fr/pub/ml-archives/caml-list/2009/03/3a77bfcca0f90b763d127d1581d6a2f1.en.html
00:30:53 <wli> heh
00:31:32 <dcoutts> I didn't realise OCaml also now uses Cmm as the intermediate representation in the backend
00:34:17 <wli> LLVM has its flaws, but it's probably closer than C-- to what things need to be.
00:35:37 <__Ali__> the official haskell binaries do not come with cabal, is that right?
00:36:06 <dcoutts> __Ali__: they don't yet come with the 'cabal' command line tool, that's correct.
00:36:20 <__Ali__> i'm trying to build the latest cabal, but i get this error: Could not find module `Codec.Compression.GZip'
00:36:38 <__Ali__> the module is in zlib package which needs cabal itself to be installed
00:36:51 <dcoutts> __Ali__: does "ghc-pkg list zlib" say that it's installed already?
00:37:30 <__Ali__> it does: zlib-0.5.0.0
00:37:59 <dcoutts> __Ali__: ok, then I suspect that the zlib package got deleted without being properly unregistered
00:38:13 <dcoutts> __Ali__: are you running the cabal-install bootstrap.sh script?
00:38:55 <dcoutts> __Ali__: you should ghc-pkg unregister zlib --user and re-run the bootstrap.sh
00:38:55 <__Ali__> dcoutts, i have my haskell installed in a local dir, then i simply added the local dirs to LIBRARY_PATH and PATH, is that enough?
00:39:19 <dcoutts> __Ali__: every Haskell package gets registered, ghc-pkg maintains the database of registered packages
00:39:49 <__Ali__> dcoutts, it's a fresj install, doesn't the install script register them?
00:39:51 <dcoutts> __Ali__: LIBRARY_PATH is not really relevant to Haskell libs
00:40:23 <dcoutts> __Ali__: you've got an existing but broken install of the zlib package, that's the problem
00:40:38 <__Ali__> ok
00:40:53 <__Ali__> let me try unregistring..
00:40:54 <dcoutts> __Ali__: so you should unregister zlib, that'll get you back to a clean state for that package
00:41:08 <dcoutts> __Ali__: did you by any chance do something like rm -rf ~/.cabal ?
00:41:39 <dcoutts> if so then all the packages registered per-user will be broken but not unregistered correctly
00:41:48 <__Ali__> dcoutts, yes i did that already
00:41:54 <__Ali__> Could not find module `Network.Stream':
00:42:00 <__Ali__> everything is broken
00:42:04 <dcoutts> __Ali__: because the per-user ghc-pkg db is in ~/.ghc not in ~/.cabal
00:42:17 <TomMD> Could someone with a second to spare run: cabal install network-data ; ghci ;  :m Data.IP  ;  :info IPv4Header
00:42:33 <TomMD> And let me know if you see a 'Binary' instance for IPv4Header?
00:42:39 <dcoutts> __Ali__: so if you removed ~/.cabal then you should also delete the corresponding package db.
00:42:40 <TomMD> Oh, and the compiler version
00:43:14 <__Ali__> dcoutts, is it in ~/.ghc?
00:43:19 <dcoutts> __Ali__: yes
00:43:30 <dcoutts> __Ali__: one for each version of ghc
00:44:03 <dcoutts> TomMD: I do not see a Binary instance, what module is it defined in?
00:44:08 <dcoutts> TomMD: ghc-6.10.1
00:44:18 <dcoutts> and network-data-0.0.2
00:44:43 <TomMD> dcoutts: It is defined in Data.IP
00:45:02 <TomMD> dcoutts: And I do see the instance using ghc-6.8.3, but don't with later versions (including head)
00:45:24 <TomMD> dcoutts: But you can see the instance if you load the same source file with ghci (not installing the library).
00:45:31 <dcoutts> TomMD: I don't see the Binary instance in 6.8.2 either
00:45:32 <TomMD> so it seems to be a regression and I'm not insane.
00:45:35 <TomMD> Hummm
00:45:36 <__Ali__> dcoutts, this is all i have ~/.ghc/i386-linux-6.10.1/package.conf
00:45:44 <__Ali__> should i delete that?
00:45:59 <dcoutts> __Ali__: ok, if you delete that then all per-user registered packages will appear to vanish
00:46:12 <bmh1> damn swisscom.
00:46:23 <__Ali__> dcoutts, and i dont need to register them all again?
00:46:52 <TomMD> Its certainly in the source, viewable via the haddock docs on Hackage and by any editor in the world.  This is rather strange.
00:47:15 <dcoutts> TomMD: however if I :m + Data.Binary then I do see the instance Binary IPv4Header
00:47:31 <dcoutts> TomMD: which makes sense, I can't see the instance when the class itself is not in scope
00:47:58 <dcoutts> __Ali__: you'll need to install them all again
00:48:16 <dcoutts> __Ali__: if you want them installed that is
00:48:36 <dcoutts> TomMD: and I get the same behaviour in 6.8.2 and 6.10.1
00:49:41 <TomMD> dcoutts: Humm, I have different behavior with ghc-6.8.3 and the module that complains about the lack of an instance has Binary imported.  I think I should go to bed.
00:50:06 <TomMD> dcoutts: But I understand what you are saying about the ghci test needing Data.Binary, that does make sense.
00:52:41 <__Ali__> dcoutts, the problem was that cabal build script doesn't like changing the default installation path, i tried setting PREFIX var but it didn't work, it works with the default choice
00:55:59 <dcoutts> __Ali__: you can move the cabal binary after it's built
00:56:19 <__Ali__> dcoutts, yes :)
00:56:53 <__Ali__> dcoutts, i installed cabal to install leksah, it seems cabal doesn't do that anyway?
00:57:49 <dcoutts> __Ali__: can't it? I don't see why not
00:58:26 <__Ali__> dcoutts, the wiki says build it manually? http://www.haskell.org/haskellwiki/Leksah
01:00:12 <dcoutts> __Ali__: it works ok for me with cabal
01:01:30 <__Ali__> dcoutts, sorry, i didn't do cabal update, when cabal builds stuff, where are the temporary things saved? do cabal clean them afterwards?
01:02:34 <dcoutts> __Ali__: tarballs are downloaded in a subdir in ~/.cabal/  packages get built in temp dirs in $TMP and are cleaned afterwards
01:02:45 <wli> In the absence of better ideas maybe I should attempt to write my own monad tutorial.
01:03:43 <koala_man> go for it!
01:04:07 <wli> It's not like I know anything of my own.
01:06:12 <johnw> shapr: ping
01:06:18 <bmh> johnw: pong
01:08:00 <johnw> you are not shapr :)
01:08:05 <wli> Hmm. Maybe (Maybe t) could be more meaningful than Maybe t.
01:09:50 <trofi^w> :t Either
01:09:52 <lambdabot> Not in scope: data constructor `Either'
01:09:58 <trofi^w> :k Either
01:10:00 <lambdabot> * -> * -> *
01:10:34 <wli> Maybe (Either () t) might as well be Maybe (Maybe t)
01:11:43 <__Ali__> dcoutts, when cabal builds a package, they all get installed in ~/.cabal/lib, is there a way to ask cabal to reset the installation dir to my local haskell installation dir?
01:12:06 <dcoutts> __Ali__: yep, edit ~/.cabal/config
01:12:21 <bmh> hi danvet
01:12:22 <dcoutts> __Ali__: and set the prefix
01:13:55 <__Ali__> dcoutts, thanks, do i need to update something after that or manually move the exisitng binaries in ~/.cabal?
01:14:20 <dcoutts> __Ali__: you can't easily move existing libs, though binaries can usually be moved.
01:14:41 <dcoutts> __Ali__: you can reinstall using cabal install blah --reinstall
01:20:46 <__Ali__> dcoutts, setting -- prefix in ~/.cabal/config to the local haskell installation dir, and cabal install blah --reinstall still installs in ~/.cabal/lib
01:21:25 <__Ali__> i also tried changing this as well: -- libdir: $prefix/lib/ghc-6.10.1
01:21:47 <dcoutts> __Ali__: -- is a comment
01:21:58 <dcoutts> __Ali__: so you need to uncomment it first
01:22:35 <__Ali__> dcoutts, i wonder why it shows them blue in gedit :)
01:26:00 <__Ali__> dcoutts, when cabal install leksah complains about this:  cannot configure leksah-0.4.3. It requires glib >=0.10, gtk >=0.10 and gtksourceview2 >=0.10.0, does it mean the packages for my linux distro?
01:26:36 <dcoutts> __Ali__: no, it means haskell packages called glib, gtk etc. Those packages are from the gtk2hs project.
01:27:01 <dcoutts> __Ali__: some distros have native packages for the gtk2hs packages
01:27:09 <dcoutts> otherwise you've got to install gtk2hs manually
01:27:47 <__Ali__> dcoutts, do i have to add gtk2hs repository or something?
01:27:55 <pumpkin> how common is data X = X (no parameters, basically isomorphic to ())
01:28:19 <dcoutts> __Ali__: what distro are you on?
01:28:44 <__Ali__> dcoutts, ubuntu 8.10, but you know that it doesn't support haskell 6.10
01:29:19 <wli> pumpkin: Not too common, but all nullary ctors is not uncommon at all, it's just that when it happens, it's mostly more than 1.
01:29:29 <dcoutts> __Ali__: it's got gtk2hs for 6.8 but I think lesaka needs the very latest gtk2hs version, so you probably need to build gtk2hs manually
01:29:39 <wli> pumpkin: When all ctors are nullary there's even special accommodation to derive Bounded and Enum.
01:29:45 <pumpkin> the only reason I'm considering it, is to "name" (with a type) a collection of functions with a typeclass
01:30:09 <wli> pumpkin: Phantom types are the primary use, yes.
01:30:33 <pumpkin> alright :) I'll play around with it and see how ridiculously complicated I can make it
01:30:42 <bmh> pumpkin: do you sleep?
01:30:52 <pumpkin> I've been gone for over a week!
01:30:53 <wli> pumpkin: That is, of single ctor data types with all nullary ctors.
01:31:12 <pumpkin> yeah
01:31:27 <pumpkin> bmh: was just planning on getting some sleep now :) just finished a long long day of travel
01:31:53 <bmh> pumpkin: I'm just starting mine. I took a 0545 train into Geneva and my flight got delayed by 5 hours
01:32:06 * wli ponders the first thing to do for a monad tutorial.
01:32:16 * wli experiences a failure of imagination.
01:32:20 <pumpkin> compare it to something like a burrito
01:32:22 <bmh> wli: Give monads a cute fuzzy name so that people won't be frightened
01:32:23 <pumpkin> maybe a tamale?
01:34:00 <wli> Monads are like nonelementary transcendental extensions of differential rings by sets of algebraically dependent transcendentals satisfying a system of first-order algebraic differential equations with linear first derivative terms?
01:34:14 <bmh> wli: needs more jargon.
01:34:27 <pumpkin> zygohistomorphic prepromorphisms
01:34:34 <pumpkin> you need at least one of those
01:34:42 <bmh> add something about zeitgeist
01:35:27 <wli> Coends are probably the most crucial bit of superfluous jargon to throw in because you get to use integral signs.
01:35:48 <pumpkin> wli: or "a monad is like a bag with three pockets! in one pocket lies a functor, and in the other two are some cute natural transformations"
01:36:18 <bmh> wli: You should write customer service information for Franz Kafka International Airport
01:36:24 <pumpkin> you gotta lure them in with the down-to-earth imagery
01:36:44 <wli> pumpkin: Then some Japanese guy called Yoneda holds mugs you and takes all 3?
01:36:56 <quicksilver> "A monad is like a fish, with a bathtub full of assorted DIY tools?"
01:37:09 <pumpkin> hah
01:37:19 <pumpkin> wli: he's in the Yakuza, yes!
01:37:29 <pumpkin> he has a giant tattoo on his back
01:37:31 <pumpkin> of a lambda
01:37:36 <bmh> A monad is not like a fish. They're all kosher.
01:37:39 <pumpkin> (gotta tie it back to haskell)
01:37:44 <quicksilver> there is actually a Yakuza lemma, as it happens.
01:37:45 <bmh> %s/kosher/halal/g
01:37:54 <quicksilver> it's much more powerful than the Yoneda lemma.
01:37:55 <wli> A monad is like a fish riding a bicycle ET-style across a sky lit by a full moon?
01:37:59 <quicksilver> I can't tell you what it is, though.
01:38:01 <quicksilver> They'd hurt me.
01:38:18 <pumpkin> quicksilver: I know it, and told someone once, and now I'm missing a link of my finger
01:38:21 <pumpkin> link?
01:38:26 <pumpkin> what's the subdigital unit?
01:38:54 <pumpkin> phalanx?
01:39:16 <bmh> yes
01:39:22 <wli> Phalanges.
01:39:26 <bmh> in the plural.
01:39:31 <pumpkin> yeah
01:39:46 <__Ali__> dcoutts, do you know by any chance when haskell is compiled to java bytecode, can the java part call the code compiled to native code?
01:40:11 <dcoutts> __Ali__: I don't know of any project to compile Haskell to java bytecode
01:40:34 <pumpkin> I saw a project, but it was sounding rather pessimistic when I looked
01:40:40 <dcoutts> __Ali__: you can get Haskell and Java to talk to each other a bit via JNI
01:40:46 <__Ali__> dcoutts, that's the question i always get when i ask that question :) http://www.cs.rit.edu/~bja8464/lambdavm/
01:40:56 <quicksilver> there are at least two projects to compile haskell to java bytecode.
01:41:04 <quicksilver> they are both dead, bitrotted, and vaporware.
01:41:05 <__Ali__> dcoutts, that JNI approach is a little bit old, unmaintained and one-way
01:41:10 <quicksilver> In practice, therefore, there are none.
01:41:31 <__Ali__> dcoutts, do you know any other approach other than those two?
01:41:58 <dcoutts> __Ali__: I have no personal experience with Haskell/Java integration
01:46:08 <ejt> quick straw poll: who prefers the wl pretty printer to the standard Text.PrettyPrint one ?
02:08:32 <kadaver> man the people working at haskell must be exceptionally talented. my shoutouts to them.
02:08:49 <kadaver> how can everything about haskell be so easy and well done
02:09:00 <kadaver> does any other languge has such a neat FFI?
02:10:36 <SnailRacer> they try hard not to succeed
02:12:28 <pumpkin> kadaver: not everything is beautiful, but of the languages I've tried, it's definitely by far the most elegant/performant/fun
02:44:00 <aeolist> hey tobias_
02:44:07 <tobias_> hey aeolist
02:45:07 <FunctorSalad_> > showFFloat (Just 50) 0.1
02:45:09 <lambdabot>       Overlapping instances for Show (String -> String)
02:45:09 <lambdabot>        arising from a...
02:45:11 <FunctorSalad_> > showFFloat (Just 50) 0.1 ""
02:45:13 <lambdabot>   "0.10000000000000000000000000000000000000000000000000"
02:45:26 <FunctorSalad_> why is that exact...?
02:45:52 <FunctorSalad_> > toRational (0.1 :: Double)
02:45:54 <lambdabot>   3602879701896397%36028797018963968
02:45:59 <FunctorSalad_> hmm, ok
02:47:46 <quicksilver> > showFFloat (Just 80) 0.1 ""
02:47:47 <lambdabot>   "0.100000000000000000000000000000000000000000000000000000000000000000000000...
02:48:07 <FunctorSalad_> 16 or so should be enough already :)
02:48:37 <quicksilver> > log (2**53) / log 10
02:48:39 <lambdabot>   15.954589770191001
02:48:42 * quicksilver nods
02:50:29 <tobias_> hello and excuse my english, i want to write a function, let's say fun x with x argument to be eager evaluated, is there any way to do that? thanks
02:50:48 <FunctorSalad_> tobias_: bang patterns ("f !x = ....")
02:51:17 <tobias_> thanks FunctorSalad_ :)
02:51:39 <RayNbow> > scanl1 (+) $ iterate (/10) 0.9
02:51:40 <lambdabot>   [0.9,0.99,0.999,0.9999,0.99999,0.9999990000000001,0.9999999,0.9999999900000...
02:51:46 <FunctorSalad_> tobias_: that only forces the "top level" (dunno the proper term) of x to be evaluated, though... if you need x to be "deeply evaluated", there's Control.Concurrent.Strategies.rnf
02:52:04 <gal_bolle> spine of x
02:52:42 <FunctorSalad_> ah :)
02:53:51 <FunctorSalad_> and the package name is actually Control.Parallel.Strategies
02:54:08 <gal_bolle> oh no sorry
02:54:12 <Philonous> You need to make you data types a member of NFData for that to work, though.
02:54:21 <gal_bolle> that's not exactly that
02:54:48 <Philonous> instance*
02:54:57 <FunctorSalad_> Philonous: yep, Data.DeriveTH is handy for that :)
02:55:10 <FunctorSalad_> $(derive makeNFData ''MyType)
02:55:36 <Philonous> Oh, I've never used template haskell
02:55:44 <Philonous> Maybe I should
02:56:40 <kadaver> i have a question, why is #haskell so nice when so many other hcannels and programmers in general are so passive-aggressive. it is like they don't you to learn because you might become a better programmer and take their job :P
02:57:11 <gal_bolle> maybe it has something to do with academic culture
02:57:26 <gal_bolle> the ratio of teachers here is quite high, isn't it
02:57:38 <gal_bolle> (raise your hands?)
02:57:40 <blackh> kadaver: It's because we don't have any jobs.
02:57:47 <FunctorSalad_> =)
02:59:12 <blackh> I'm actually a bit more "commercially oriented" so I hope I give the commercial ones a good name, too.
03:00:57 <FunctorSalad_> #define qc(x,p) quickCheck ((unsafePerformIO (putStr ($(printf "%-60s ") "p"))) `seq` (\(x) -> (p)))
03:01:05 <FunctorSalad_> very handy macro ;)
03:01:34 <FunctorSalad_> hmm I could pull the putStr before the qc and avoid unsafePerformIO
03:01:38 <FunctorSalad_> err before the quickCheck
03:02:33 <FunctorSalad_> seems equivalent though
03:05:00 <FunctorSalad_> seperating the x out is necessary because you can't have lambdas in p - it will cause string escaping errors in "p" ;o
03:05:19 <FunctorSalad_> (seems like the evilness is already shining through)
03:05:43 <Philonous> I'm not sure I know what this is supposed to do.
03:08:01 <yitz> FunctorSalad_: I think you've set a record. #define, unsafePerformIO, printf, and seq, all in one.
03:08:18 <FunctorSalad_> here's the slightly saner version #define qc(x,p) putStr ($(printf "%-60s ") "p") >> quickCheck (\(x) -> (p))
03:08:33 <FunctorSalad_> yitz: yep, delightfully perverse
03:08:54 <FunctorSalad_> Philonous: quickcheck something and make a putStr indicating what it's checking
03:09:02 <dan_> > 1* 1
03:09:03 <lambdabot>   1
03:09:26 <dan_> anyone know why ghci is return 1 * 1 for me when i do that?
03:09:32 <dan_> like literally
03:09:35 <dan_> it print 1* 1
03:09:38 <dan_> rather than evaulating to 1
03:11:44 <yitz> @let x * y = text $ show x ++ " * " ++ show y
03:11:44 <lambdabot>  <local>:11:159:
03:11:45 <lambdabot>      Ambiguous occurrence `*'
03:11:45 <lambdabot>      It could refer to either ...
03:12:05 <yitz> @let (*) x y = text $ show x ++ " * " ++ show y
03:12:06 <lambdabot>  <local>:11:159:
03:12:07 <lambdabot>      Ambiguous occurrence `*'
03:12:07 <lambdabot>      It could refer to either ...
03:13:04 <yitz> @let (*) = \ x y -> text $ show x ++ " * " ++ show y
03:13:05 <lambdabot>  <local>:11:159:
03:13:06 <lambdabot>      Ambiguous occurrence `*'
03:13:06 <lambdabot>      It could refer to either ...
03:13:51 <yitz> dan_: anyway. could you have accidentally redefined * in ghci?
03:14:02 <dan_> mmm nope
03:14:35 <dan_> :t (*(
03:14:36 <lambdabot> parse error (possibly incorrect indentation)
03:14:38 <dan_> :t (*)
03:14:39 <lambdabot> forall a. (Num a) => a -> a -> a
03:14:48 <FunctorSalad_> dan_: :t 1 ?
03:14:51 <yitz> 1* 1 gives 1 for me in ghci
03:15:02 <dan_> :t 1^J1 :: (Num t) => t
03:15:04 <lambdabot> Not in scope: data constructor `J1'
03:15:09 <dan_> i keep getting carrot J
03:15:19 <dan_> i think my install is just messed up
03:15:24 <FunctorSalad_> dan_: something could have set the default Num to Expr or so ;)
03:15:38 <FunctorSalad_> but I can't come up with a story to make this plausible.
03:15:49 <FunctorSalad_> > (1::Expr) * 1
03:15:51 <lambdabot>   1 * 1
03:17:36 <FunctorSalad_> dan_: (1::Int) * 1 ?
03:17:57 <dan_> Prelude> (1::Int) * 1
03:17:57 <dan_> (1::Int) * 1^J1
03:17:57 <dan_> Prelude>
03:18:00 <dan_> lol
03:18:02 <dan_> weird
03:18:13 <FunctorSalad_> heh
03:18:22 <dan_> it's still printing 1 after a J
03:18:31 <dan_> oh
03:18:33 <dan_> it's just emacs
03:18:34 <FunctorSalad_> I think that's editline-related
03:18:36 <dan_> being screwy
03:18:37 <dan_> yea
03:18:38 <dan_> yea it is
03:18:50 <FunctorSalad_> try replacing ghci by "ghci-haskeline" in emacs
03:18:57 <FunctorSalad_> (cabal install ghci-haskeline)
03:19:27 <dan_> i'm on gentoo
03:19:31 <dan_> portage magic will save me
03:19:32 <dan_> !
03:19:47 <FunctorSalad_> yitz: by the way, that code is also using implicit params.
03:20:00 <FunctorSalad_> (for the numerical error bound epsilon)
03:31:50 <bmh> if I want my flight to be delayed less, what monad should I use?
03:33:43 <bastl1> how can make this look nicer? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2006#a2006
03:33:47 <bastl1> hi all
03:34:22 <wjt> bastl1: What's the definition of FieldDeclaration?
03:34:42 <wjt> bastl1: if Dmth and friends are records, you can say (Dmth {}) to pattern match them
03:35:35 <osfameron> "Dmthth" is a rather confusing name
03:35:58 <bastl1> osfameron: not my naming. stems from a java grammar.
03:36:28 <osfameron> ah... legacy shortname fun
03:36:52 <Shurique> do they need to be records? I thought "{}" works regardless
03:37:10 <wjt> perhaps
03:37:11 <bastl1> i pasted the datatype to the pastebin
03:37:15 <wli> FunctorSalad: What are you talking about with epsilon?
03:38:08 <bastl1> the datatype is given as its generated automatically .. :-/
03:38:09 <FunctorSalad_> wli: (~~) x y = abs (x-y) < ?eps * abs y
03:38:27 <FunctorSalad_> wli: (~~) :: forall a. (Num a, ?eps::a, Ord a) => a -> a -> Bool
03:38:28 <FunctorSalad_> :)
03:38:50 <FunctorSalad_> (it's only a test suite, not a library, so please don't kill me)
03:39:51 <FunctorSalad_> wli: (I need to increase eps for the more unstable tests)
03:40:44 <wli> FunctorSalad: I have no idea.
03:42:15 * wli attempts to come up with monad tutorial examples.
03:42:23 <ppavelV6> dan_:  hmmm.... overloaded (*)?
03:42:40 <dan_> ppavelV6, problems with readline
03:42:49 <dan_> the answer was after the random J
03:43:12 * ppavelV6 failed to make readline in ghci behave in vi mode under mac osx 
03:43:28 <wli> I downgraded back to 6.8.3 after I discovered the readline support for 6.10.1 had nothing to do with ghci.
03:43:42 <wli> ppavelV6: What do /etc/inputrc and ~/.inputrc look like?
03:43:54 <ppavelV6> wli: 1 sec
03:44:23 <ppavelV6> wli:  no /etc/inputrc and....
03:44:41 <ppavelV6> mac:~ pavel$ more ~/.inputrc
03:44:41 * ppavelV6 set editing-mode vi
03:44:41 * ppavelV6 set keymap vi
03:45:02 <ppavelV6> wli:  am i too naive?
03:45:41 <wli> set input-meta on
03:45:41 <wli> set output-meta on
03:45:50 * ppavelV6 tries
03:45:55 <wli> set meta-flag on
03:45:55 <wli> set convert-meta off
03:46:14 <wli> # fix ^W (default is broken)
03:46:14 <wli> C-W:backward-kill-word
03:46:40 <wli> ppavelV6: I haven't touched the keymap
03:46:57 <ppavelV6> wli: hmm
03:47:02 <ppavelV6> 1 sec
03:47:05 <wli> ppavelV6: I have keymap vi-insert commented out, along with bindings for ESC[A etc.
03:47:31 <McManiaC> is it possible to write something like
03:47:39 <McManiaC> f   | []        = putStrLn "empty" | (x:xs)    = putStrLn x
03:47:55 <McManiaC> (add new line after "empty")
03:48:00 <ppavelV6> wli: currently i can't get to "normal" mode
03:48:02 <wli> McManiaC: How would you write it otherwise?
03:48:14 <ppavelV6> wli: how about sharing your .inputrc?
03:48:16 <McManiaC> wli: f [] = ... ; f (x:xs) = ...
03:48:52 <wli> McManiaC: f z | [] <- z = putStrLn "empty" | x : _ <- z = putStrLn x
03:49:45 <McManiaC> ok
03:50:02 <wli> ppavelV6: http://wli.pastebin.com/m3cb6e40f
03:51:01 <sioraiocht> are all linear transformations in Vect_k representable as matrix multiplication?
03:52:04 <wli> sioraiocht: All linear operators L : F^m -> F^n are representible as matrices, not matrix multiplication.
03:52:19 <FunctorSalad_> sioraiocht: matrix multiplications represent linear maps from some space k^m to k^n (where k is your field). every vector space is isomorphic to some k^n, but you need to choose a basis
03:52:31 <wli> sioraiocht: Where F is a field, that is.
03:52:51 <sioraiocht> thanks
03:53:13 <wli> FunctorSalad: Well, I'd keep the implications the other way as there are vector spaces over noncommutative division rings.
03:53:15 <FunctorSalad_> (n can be infinite)
03:53:42 <FunctorSalad_> wli: which implications?
03:54:14 <wli> "every vector space is isomorphic to some k^n"
03:55:34 <sioraiocht> so in Vect_k, for arrows talking about linear transformations from one vector to another in the same field, right?
03:55:56 <wli> yeah
03:56:06 <wli> They can be different fields too, in some instances.
03:56:30 <sioraiocht> is it possible to have linear transformation f: V -> V that isn't id?
03:57:13 <wli> sioraicht: Field automorphisms from the Galois group of automorphisms of an extension of some ground field.
03:57:42 <sioraiocht> *head explodes*
03:57:47 <FunctorSalad_> wli: aren't all vector spaces over a skew field (shorter word ;)) k isomorphic to some k^n too?
03:57:48 <wli> sioraicht: e.g. complex conjugate over complex numbers, or f(a+b*2^(1/2)) = a - b*2^(1/2)
03:58:02 <sioraiocht> wli: sorry, but not in real vector spaces?
03:58:13 <FunctorSalad_> (noncommutative division ring)
03:58:30 <wli> sioraiocht: Q(2^(1/2)) is a real field.
03:58:58 <wli> FunctorSalad: Not infinite ones that I'm aware of.
03:59:39 <FunctorSalad_> oh, I see.
03:59:59 <profmakx> finite skew fields is cheating
04:00:02 <wli> FunctorSalad: I guess we can look up Weyl algebras.
04:00:12 <Ninju> s
04:00:32 <wli> profmakx: No, not the field itself being (in)finite, but its dimensionality.
04:02:33 <FunctorSalad_> wli: maybe I should qualify the question by saying that for vector spaces "every vector space has a basis" is equivalent to axiom of choice
04:02:36 <FunctorSalad_> (IIRC)
04:02:39 <wli> I'm pretty sure you can smoke out presentations of e.g. linear operators over H^2 as 8x8 real matrices, but I think you're SOL on e.g. Weyl algebras.
04:02:45 <FunctorSalad_> so it's not unarguably "true" ;)
04:03:07 <wli> It may take something more exotic than Weyl, though.
04:03:14 <quicksilver> finite dimension you don't need choice.
04:03:33 <FunctorSalad_> quicksilver: yep, the question was about infinite
04:03:54 <bastl1> is there something that combines predicates like " and :: (a -> Bool) -> (a -> Bool) -> (a -> Bool) )
04:03:59 <FunctorSalad_> (which is kind-of a moot point since nobody uses infinite-dimensional spaces without some topology ;))
04:04:18 <quicksilver> it's kind-of the definition of basis.
04:04:32 <sioraiocht> :t fmap (&&)
04:04:34 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f (Bool -> Bool)
04:04:41 <sioraiocht> that's not helpfull...
04:04:42 <FunctorSalad_> quicksilver: ?
04:04:53 <FunctorSalad_> the definition of basis allows infinite basises
04:05:25 <sioraiocht> @pf and p1 p2 x = p1 x (&&) p2 x
04:05:26 <lambdabot> Maybe you meant: bf pl
04:05:33 <sioraiocht> @pl and p1 p2 x = p1 x (&&) p2 x
04:05:34 <lambdabot> and = flip flip id . (ap .) . flip . flip flip (&&)
04:05:46 <sioraiocht> @pl and p1 p2 x = p1 x && p2 x
04:05:46 <lambdabot> and = liftM2 (&&)
04:06:02 <sioraiocht> bastl1: there you go =)
04:06:09 <quicksilver> FunctorSalad_: the fact that every finite dim space has a basis is kind of the definition of base. Or finite dimensional.
04:06:13 <sioraiocht> :t liftM2 (&&)
04:06:15 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
04:06:17 <quicksilver> FunctorSalad_: depending how you order the definitions.
04:06:36 <quicksilver> with infinite spaces I'm not familiar with stuff that doesn't at least require it to be a hilbert space.
04:06:58 <wli> Woops, I think Weyl algebras end up being ordinary infinite-dimensional vector spaces.
04:07:17 <wli> And they're not division rings.
04:07:21 <FunctorSalad_> quicksilver: huh? I've never seen "basis" defined as something not equivalent to "subset that is independent and generating"
04:08:25 <bastl1> sioraiocht: thanks. very helpful
04:08:46 <quicksilver> FunctorSalad_: right. And you define 'dimension' as 'the size of all independent and generating sets'
04:08:58 <FunctorSalad_> yes
04:09:06 <quicksilver> FunctorSalad_: therefore the very notion of dimension requires the existence of bases.
04:09:10 <quicksilver> that's all I was saing.
04:10:36 <FunctorSalad_> quicksilver: ah, right. you can avoid that by formulating it as "if V has a generating set S, it has a basis of cardinality <= S"
04:11:13 <FunctorSalad_> but I've lost what the question is too ;)
04:14:21 <wli> ISTR there are some strange constructions that don't do what one wants wrt. bases and/or the existence thereof.
04:21:51 <FunctorSalad_> wli: maybe you mean that R^n can be isomorphic to R^m, but m != n for modules?
04:23:00 <wli> FunctorSalad: I've no idea what I was thinking.
04:27:23 * wli attempts to come up with monad usage examples.
04:33:21 <__Ali__> does anyone know more examples on QuasiQuoting apart from the one in the wiki? http://www.haskell.org/haskellwiki/Quasiquotation
04:34:31 <wli> Algebraic number arithmetic for MonadReader, I guess.
04:34:59 <wli> Doesn't sound too promising.
04:36:01 <wli> How is it that I use monads for everything and somehow can't come up with monad usage cases when I'm specifically trying to cook up monad usage cases?
04:36:44 <osfameron> perhaps you need a Monad-use-case Monad
04:37:13 <wli> osfameron: Or a set of monadic monad tutorial writing combinators.
04:37:38 <osfameron> yay!
04:38:56 <wli> config file and cmdline arg settings
04:39:35 <osfameron> think of each tutorial as a parser into the essence of monadic understanding, returning those aspects of monadic understanding explained by the parser (on success)
04:40:17 <rio> LeoD: :O
04:40:47 <wli> I think you can just use Markov models involving nuclear waste canisters, burritos, twinkies, and so on.
04:44:45 <Japsu> nuclear waste canister (full) -> PROCESS -> burrito?
04:45:48 <wli> Japsu: ... and what do you think they're filling Twinkies with?
04:45:57 <opqdonut> process :: Arrow a => a Canister Burrito
04:46:14 <rio> Japsu: you need a more complex markov matrix to describe the processing of nuclear waste to burrtios
04:46:19 <Japsu> :D
04:46:47 <RayNbow> opqdonut: why not use GHC extensions and say Arrow (~>) => Canister ~> Burrito --? :p
04:46:47 <HugoDaniel> what is the best place to learn about haddock ?
04:46:55 <wli> rio: And Twinkie filling.
04:47:03 <opqdonut> RayNbow: :P
04:47:05 <rio> wli: Of Course.
04:47:26 <rio> i thought thats implicit anyway
04:50:25 <wli> rio: Hot dogs, too.
04:51:43 <chessguy_work> what's the opposite of referential transparency? referential opaqueness or something?
04:52:01 <wli> Referential opacity.
04:52:16 <chessguy_work> thanks
04:54:58 <SirLancer> how do you call a subfunction in a Haskell program?
04:55:20 <rio> what do you mean by subfunctionß
04:55:32 <SirLancer> I have a function main
04:56:04 <SirLancer> and I want main to call another function
04:56:16 <chessguy_work> main = print $ foo 3 "bar"
04:56:52 <SirLancer> Like anotherFunction(); in Java
04:57:15 <chessguy_work> main = print $ anotherFunction 3 "bar"
04:57:23 <SirLancer> hmm okay
04:57:29 <SirLancer> what's the 3 for?
04:57:41 <SirLancer> and the "bar"
04:57:43 <chessguy_work> SirLancer, the 3 and the "bar" are parameters being passed to anotherFunction
04:57:54 <chessguy_work> it's like anotherFunction(3, "bar");
04:57:57 <rio> thats main() { print(anotherFunction(3, "bar")); }
04:58:21 <SirLancer> okay
04:58:21 <mstr> main = anotherFunction
04:58:24 <chessguy_work> well, in haskell, if you didn't pass any parapeters to anotherFunction, it would be pretty boring
04:58:33 <mstr> print anotherFunction :P
04:59:06 <Japsu> SirLancer, in this case you need to make the distinction whether the function you're calling is "pure" or "in the IO monad"
04:59:24 <Japsu> SirLancer, if it's a pure function, it will take some parameters and return a result, doing nothing else whatsoever
04:59:44 <Japsu> SirLancer, if it's in the IO monad, it might have some side effects, such as printing something
05:00:14 <opqdonut> main = do print "a"; print (3 + 5)
05:00:16 <Japsu> SirLancer, in the above examples, "print" is a function in the IO monad that will take a parameter and produce side effects (in this case, printing a string representation of the parameter on the standard output)
05:00:22 <opqdonut> :t print
05:00:24 <lambdabot> forall a. (Show a) => a -> IO ()
05:00:24 <opqdonut> :t (+)
05:00:25 <lambdabot> forall a. (Num a) => a -> a -> a
05:00:43 <Japsu> SirLancer, whereas "anotherFunction" is a pure function that returns some value based on its parameters
05:01:40 <Japsu> SirLancer, in haskell terminology, you don't "call" functions... pure functions are "evaluated". monadic functions produce a monadic "action" that is then run.
05:02:00 <SirLancer> hmm okay
05:02:24 <Japsu> SirLancer, so, to your original question,
05:02:24 <SirLancer> I'll try these
05:02:29 <opqdonut> IO actions returned by functions are only "run" if they happen inside main or another function that get's called from main
05:02:50 <opqdonut> you can "perform" multiple IO actions by putting them in a do-block
05:02:56 <Japsu> SirLancer, you evaluate functions by writing their name and then their parameters, such as "print 3"
05:03:06 <opqdonut> you can evaluate multiple pure functions by binding them to variables in a let block
05:03:09 <Japsu> SirLancer, if they are monadic, if they return an action... well, what opqdonut said
05:08:31 <kadaver> C must be part ofprogrammer literacy right?
05:08:52 <kadaver> how come UNIs dont teach C to CS as an olbigatory course?
05:09:07 <ejt> people find it too hard
05:09:49 <kadaver> UNIs are not daycarecenters?
05:09:55 <Botje> pointers are hard! let's go shopping
05:10:14 <chessguy_work> @quote shopping
05:10:14 <lambdabot> samc says: monads are hard. let's go shopping!
05:10:18 <ejt> http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
05:11:22 <opqdonut> indeed
05:12:21 <koala_man> the title is very misleading
05:14:32 <ibid> kadaver: mostly because unis have a limited number of years they have access to their students, making planning the curriculum an exercise in setting priorities
05:14:46 <opqdonut> but java is just dumb
05:14:46 <wli> C is probably not as important as asm of some sort to get an idea of what computer code looks like.
05:14:53 <opqdonut> it interferes with teaching basic procedural programming
05:15:10 <ibid> kadaver: and frankly, when a curriculum planner compares a theory course and a C course, the theory is more likely to win
05:15:11 <opqdonut> objects and classes are abstractions that need considerable programming experience to see the point of
05:16:01 <ibid> no they aren't
05:16:22 <ibid> they just seem that way to people who have set their mind to procedural programming
05:16:47 <wli> ibid: They don't really think like that anymore. For the most part they're using curriculum content as something to sell in exchange for grants and equipment.
05:16:49 <kadaver> i thought classes was something very familiar(my firts langs were java and python), but that is whats wrong about them, they are more about fuzzy evryday thinking than goodprogramming imho
05:16:59 <opqdonut> indeed
05:17:23 <opqdonut> and having to bother with public static void main etc. is in the way of learning _abstraction_
05:17:25 <ibid> wli: i am involved in curriculum planning in my university.  i know what they think, and grants&equipment have nothing to do with it here
05:17:50 <opqdonut> functions are the primary form of abstraction to this day
05:19:02 <ibid> wli: the situation probably is different in different countries
05:19:43 <bremner> we might care about grants and equipment if we got any, but 0 versus 0 doesn't influence much
05:20:49 <kadaver> <- 80s <now> future ->
05:20:54 <wli> ibid: What, then? Over here they were having all sorts of problems with funding cuts etc. so when M$ rolled in and offered umpteen research grants and flooding the whole campus with new equipment and so on in exchange for a Java/Win32 -based curriculum and "opening up" the CS department to some massive number of students. It was used to cross-subsidize a fair amount of the rest of the campus.
05:21:03 <kadaver> <- java <python> -> haskell
05:21:12 <ibid> wli: nothinh like that here
05:21:32 <wli> ibid: Where is here?
05:21:53 <ibid> wli: university of jyväskylä, faculty of information technology (finland)
05:22:06 <lepassive> after a while now with Haskell I've somethings i want to make clear, the language is super awesome, however, I got *confused* with many STstuff, boxed, unboxed, ... etc anyway to overcome that ?
05:22:34 <bremner> now if the russians showed up with vodka :-)
05:22:35 <wli> ibid: Ah, your government is more than just a tool for rich people to rob the poor and kill them when they try to do anything about it.
05:22:56 <ejt> lepassive: keep playing and asking questions
05:23:39 <ibid> wli: in practice, our curriculum planning is mostly based on the following factors: international recommendations (acm/ieee core curriculum etc), our percieved core competences in teaching, and individual teacher preferences
05:24:17 <ibid> (also student preferences, as expressed in various forms)
05:24:18 <ejt> ibid: that all sounds good - but has there been a swing to Java over the last 10 years ?
05:24:24 <ibid> ejt: sure
05:25:06 <ibid> oh yeah, another factor: percieved job marketplace hot buttons :)
05:25:19 <ibid> but nothing like ms buying the curriculum
05:25:19 <lepassive> ejt, I'm afraid i don't *know* it's fields of use, RWH Boxed arrays and stuff like that in the bloomfilter chapter, but i don't get more info on how or when to use stuff like that... pretty crypto
05:25:32 <bremner> Java /= MS
05:25:58 * bremner is trying out for Captain Obvious
05:26:22 <ejt> lepassive: are you having performance issues with one of your programs ?
05:26:47 <lepassive> ejt, not yet, I started to migrating a few stuff to Haskell
05:28:26 <lepassive> ejt, I got some knowledge and I can code fine in imperative way -almost all are the same- but the main obstacle for me with Haskell is I can't think in Haskell, maybe not yet
05:28:53 <ejt> I found reading the haskell entries for the computer language shootout useful, but I didn't memorise this stuff - I'm just aware that this stuff can be done if my program is too slow
05:29:09 <ejt> lepassive: sounds like you need to concentrate on basic functional programming then
05:29:13 <ejt> certainly not STArray ;)
05:29:51 <lepassive> ejt,  maybe thats so :)
05:29:52 <blackh> lepassive: Hi there. Remember I was talking about my adventure game? Well, I got the new one working. Take a look at this: http://blacksapphire.com/haskell/adventure3.hs
05:30:34 <blackh> lepassive: This is supposed to be an example of "thinking in Haskell".  Let me know if it's useful to you.  If it is, I might publish it on the wiki with some notes.
05:31:12 <blackh> lepassive: The bit to read first is "createWorld" at the bottom. That's meant to be clear and easy to read.
05:31:38 <lepassive> blackh, Hi you! i got the message, but i'm afraid I'm not pretty used to work with lambdabot to write you back, however it sounds really good
05:31:51 <ejt> blackh: is it really thinking in haskell ?  it looks very imperative to me
05:32:13 <blackh> ejt: That could be - How would you improve it?
05:32:25 <Botje> C
05:32:30 <Botje> argh, sorry :)
05:32:53 <blackh> ejt: I wrote this to answer the following question: An adventure game works by changing game state. How do you do this in Haskell?
05:33:06 <ejt> blackh: I dont have a quick answer - these games are very stateful - maybe you should ask Conal
05:33:31 <ejt> blackh: I started porting the original Crowther & Woods adventure to haskell if you're interested
05:33:40 <ejt> (I've got too many other projects on the go)
05:33:52 <Workybob> blackh: fwiw, I've written an adventure game in Haskell too
05:34:00 <Workybob> my world was lazily generated
05:34:07 <Workybob> with a 2D zipper type thing
05:34:17 <blackh> ejt: That's an excellent idea. I'll do that. This is at least pure - it runs inside interact.  I am more interested in how to write adventures in Haskell than actual adventures themselves. :)
05:34:18 <Workybob> which let me define interesting worlds with things like infinite tunnels
05:34:23 <opqdonut> nice
05:34:35 <Workybob> the rooms to your side were defined as functions from World -> World
05:34:39 <Workybob> as were all actions you could do
05:34:47 <opqdonut> and non-euclidean geometries too!
05:34:56 <ejt> blackh: I'm increasingly of the opinion that 'do' is evil
05:35:10 <Workybob> opqdonut: indeed :D
05:35:17 <Workybob> ejt: it is :)
05:35:21 <Workybob> well... not always
05:35:27 <Workybob> it's just usually used for the wrong thing (TM)
05:35:32 <wli> ejt: m >>= \x -> f x is "better"?
05:35:40 <Workybob> wli: no, but m >>= f is
05:35:41 <Workybob> :P
05:35:48 <Workybob> or better yet... f =<< m
05:35:53 <blackh> Workybob: Mine is generally functions World -> World but in some cases I am using Room -> Room, etc
05:36:12 <Workybob> blackh: yeh, but using Data.Maps stops it from being lazy, unless I'm missunderstanding something
05:37:22 <wli> Well, I see stuff like m >>= \x -> ... >>= \y -> ... >>= ...
05:37:28 <lepassive> ejt, that's a more thing I see pretty much of haskell apps are mostly done *imperative way*
05:37:38 <ejt> wli: yes, I think it is, I think it encourages people to write better combinator libraries, rather than banging out imperative mindset code
05:38:00 <ejt> @hpaste
05:38:01 <Workybob> wli: yeh, what ejt said – that's just bad style
05:38:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:38:11 <Workybob> don't write Haskell code in imperative style ;)
05:38:45 <Workybob> wli: fwiw, most (not quite all) of the code I see like that is actually entirely within applicative
05:38:53 <Workybob> and much easier to read when written in that style
05:39:00 <lepassive> Workybob, well RWH webclient, gui app are imperative style way
05:39:00 <bremner> wouldn't it be easier to write imperitive code in some other language, if that is what you want?
05:39:01 <blackh> ejt: The reason why I used 'do' is because I wanted to chain state changes. I could have used . but 'do' + runState made it much more readable.
05:39:08 <Workybob> lepassive: no they're not
05:39:17 <lepassive> bremner, that's what scala for
05:39:22 <Workybob> well, they don't have to be
05:39:29 <EvilTerran> lepassive, eeeew, scala
05:39:42 <Workybob> web clients actually are briliant examples of something that should be written functionally
05:39:44 <Workybob> they get one input
05:39:47 <Workybob> and produce one output
05:39:48 <lepassive> Workybob, hmmmm many doS and running actions....
05:39:49 <Workybob> that's constant
05:40:01 <Workybob> and always the same for the same inptu
05:40:05 <Workybob> sounds *very* functional to me
05:40:15 <lepassive> EvilTerran, yeah i found GvR post of *hating* Scala and way to go Haskell!
05:40:53 * EvilTerran has been bitten by scala's implicit semicolons loads of times and has rarely been caught out by haskell layout,
05:41:03 <ejt> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3090#a3090
05:41:27 <ejt> ^^^ That's a parsec parser I wrote yesterday, it's monadic, but no 'do's in sight
05:41:41 <Workybob> looks aplicative to me
05:41:47 <Workybob> parsec is one of the perfect examples
05:41:51 <Workybob> the applicative interface is *lovely*
05:41:52 <ejt> yep
05:42:05 <Workybob> it essentially just lets you write BNF
05:42:40 <Saizan> if your grammar is context-free
05:42:41 <ejt> it worked so well it got me worrying that I use 'do' way too much
05:42:46 <Workybob> Saizan: yep, indeed
05:42:52 <lepassive> EvilTerran, there's a great alternative to Scala except for Haskell of course, Clojure"
05:43:00 <Workybob> ejt: also – blog about that – a while ago there was a thread about how haskell revolved around monads too much, and I said parsec was better... various people said "well, show us, we need a good example of an applicative parser"
05:43:31 <C-Keen> I have read about a haskell frontend for LLVM has anyone in here used it?
05:43:36 <ejt> when it's done :)
05:43:37 <blackh> ejt: Thanks. Will study. Do you have a suggestion of how my adventure game could be written without do?
05:43:58 <bremner> blackh: isn't do just syntactic sugar?
05:43:58 <ejt> blackh: the best I can do is paste my advent experiments
05:44:13 <ejt> will do so in half an hour when my wife gets home and turns my machine on
05:44:16 <Workybob> in the mean time.. anyone with any experience of GLFW here?  Does it have a constraint about running on the main thread?
05:44:31 <blackh> ejt: I am definitely interested in those.  I will be asleep by then but I'll pick it up tomorrow.
05:44:39 <yottis> i'd like to see something applicative that isn't a monad
05:44:57 <ejt> doesn't the paper have loads of examples ?
05:45:13 <blackh> bremner: I am not convinced that there is anything wrong with do, but I am willing to be persuaded.
05:45:24 <lepassive> Time to go, blackh thanks for keeping in mind :)
05:45:34 <lepassive> c ya later folks
05:45:40 <blackh> lepassive: See ya!
05:45:50 <ejt> bremner: yes do is sugar, but I think promotes imperative thinking
05:45:55 <bremner> blackh: I was trying to get at the distinction between "do free" and "less monadic"
05:46:48 <ejt> nothing wrong with monads
05:47:02 <Workybob> bremner: the distinction is that do notation is very imperative
05:47:05 <Workybob> it's suggests order
05:47:12 <blackh> bremner: The reasoning I used was that the adventure game was going to modify state, and a state monad gave more tidy syntax than a chain of . 's
05:47:15 <Workybob> worse than that... it suggests an order which is *not* the one things are executed in
05:47:39 <Workybob> using applicative style gets you much closer to describing things as they *are* not as they should be computed
05:47:42 <ejt> blackh: I wasn't arguing against using a monad
05:48:08 <blackh> ejt
05:48:50 <blackh> I can see why monads can be bad, but I don't really think I abused them in my adventure game.  But I want to learn, so I'd appreciate any comments.
05:51:01 <quicksilver> Workybob: almsot certainly, yes. Most openGL libraries (AFAIK, the linux, windows and osx ones) make use of local state in a non-thread-safe way per context.
05:51:20 <quicksilver> Workybob: so you need to be careful not to make calls simultaneously from multiple threads.
05:51:48 <quicksilver> Workybob: one simple way to do that is reserve one thread for opengl calls but you could just guard opengl calls wiht a mutex.
05:53:50 <darrenhobbs> on the subject of GUIs, what's the idiomatic haskell equivalent to (eg.) MVC ? Seems that purity and immutable state are in direct conflict with the needs of GUI code. Any good reading matter I can take a look at?
05:55:42 <ejt> blackh: you there still ?
05:55:56 <blackh> ejt: Yes - still hanging in there.
05:56:09 <ejt> got my machine on, so will post some snippets
05:56:16 <Axman6> blackh: 2am over there now?
05:56:29 <blackh> Axman6: Exactly so.
05:56:42 <wli> For me, most of it has to do with breaking up expressions that would otherwise be enormous into multiple pieces and split in some aesthetic way across lines.
05:57:01 <ejt> TBH, mine looks very much like yours, but I'm not happy with it
05:57:34 <Axman6> what're you doing man, git some sleep!
05:59:02 <ivanm> Axman6: well, it's about midnight down your way, isn't it?
05:59:03 <wli> And cramming it into a single page at the same time.
05:59:08 <ivanm> or has daylight savings finished?
05:59:10 <ejt> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3091#a3091
05:59:13 <Axman6> yeah
05:59:37 <codebliss> Is (>>=) similar to the pipe in *nix?
05:59:39 <wli> (page == 24 lines)
05:59:46 <opqdonut> codebliss: in a way, yes
05:59:50 <codebliss> I was looking over a lot of articles, and kind of understand it
05:59:50 <ejt> ^ that shows some location definitions, I was quite pleased with the little combinators for defining the actions (>-, ?- etc.)
05:59:53 <codebliss> Okay cool thanks
06:00:44 <codebliss> Once I saw **getLine >>= print . tail** I immediately notice it's like a pipe.  Also one of the better examples to explain parts of nomads to a newbie
06:01:09 <SirLancer> blackh: An adventure game made with Haskell?
06:03:25 <darrenhobbs> a nomadic adventure game?
06:03:48 <ivanm> you are a nomad, stuck in the IO monad
06:04:06 <ivanm> without an unsafePerformIO in sight
06:04:07 <darrenhobbs> sounds painful
06:04:09 <Badger> escape to purity!
06:04:11 <blackh> ejt: Thanks for that. I know that what I am doing is "modifying" my world into existence rather than declaring it, however, the logic behind this design is that the whole thing is based on the idea that the world can modify itself into existence as it goes.  It has the added advantage that the game language is more expressive, and extensible, e.g. defining "edible" doesn't involve adding a new flag.
06:04:28 <dolio> darrenhobbs: That'd probably be functional reactive programming. But people are still working on what the best way to formulate it is.
06:04:34 <dolio> It's been around for a while, though.
06:04:44 <ejt> blackh: I intended to get rid of the flags, this is work in progress
06:05:02 <darrenhobbs> dolio: thanks, gives me something to google for at least :)
06:05:10 <dolio> It's even influenced people outside of the functional language population, though. See flapjax.
06:05:13 <ejt> because it was a port of an imperative program I ported it as simply as possible, then was trying to make it more functional
06:05:36 <dolio> I think the flapjax people even say it's MVC done right or something, but it's really functional reactive programming. :)
06:05:38 <ejt> do you see my point about the actions though ?  they're monadic, but not written using 'do'
06:05:49 <dolio> I can't find the old video demoing it, though.
06:06:45 <blackh> ejt: Keep me posted, because I'm interested in the whole adventure game problem in Haskell - it seems like a good example of state-heavy code that goes to the heart of the question "How should things be done in Haskell?"
06:07:06 <ejt> y, I don't have an answer (yet)
06:07:23 <ejt> FRP is probably the answer
06:07:42 <ejt> if I could get my head around the libs
06:07:58 <blackh> I think adventure and FRP probably have a large amount in common.
06:08:16 <osfameron> are there good tutorials on FRP?  Matt Trout was threatening to implement it in Perl, was asking me if I knew anything about it...
06:08:45 <ejt> there were a couple of blog posts on Reactive a couple of months ago
06:08:51 <ejt> not much else though
06:09:22 <ejt> quicksilver was muching about with a very small FRP lib too, I don't know if that's more accessible for being smaller
06:09:59 <blackh> My adventure implementation is vaguely based on FRP as described in The Haskell School of Expression.
06:10:03 <ejt> adventure games just need events, not behaviours so I suspect a lot of reactive is unness. for them
06:10:16 <osfameron> ah!  I forgot HSOE describes a precursor of FRP
06:10:29 <osfameron> I must try reading the later chapters of that again, see if I understand them this time around...
06:10:58 <blackh> I am taking a more reactive approach.  For example, an event could change the description of an item or NPC.
06:11:51 <blackh> Also, an event could change an NPC's "goal".
06:12:01 <blackh> Axman6: Good night!!
06:12:08 <blackh> I am going to bed!
06:12:40 <Axman6> night man :)
06:13:33 <Axman6> heh, friend just used a new ... emotiword? /wrists
06:15:05 <FunctorSalad_> what is "[::]"?
06:15:17 <FunctorSalad_> according to the base libs haddock, it is an instance of Functor ;)
06:15:38 <Axman6> parallel arrys
06:15:41 <Axman6> arrays*
06:16:19 <FunctorSalad_> ah
06:19:14 <pluto> I tried to convert a Ratio Integer to a decimal string with: showFFloat (Just 24) (realToFrac (1 % 3)) "". how can I get arbitary precision?
06:19:59 <daf> pluto: Text.Printf?
06:20:04 <LeoD> rio: :D
06:20:35 <edwardk> pluto: i generally try to avoid the stuff from the Numerics lib
06:20:51 <codebliss> Warning:  This may be a dumb question.  Is there a simple reasoning I'm missing as to why in points-free **return x >>= f = f x** the return must be included?
06:21:13 <Botje> because >>= takes an m a as first argument
06:21:20 <Botje> and x is of type a
06:21:32 <codebliss> SO return formats a value to a monad?
06:21:36 <Botje> yup
06:21:38 <Botje> :t return
06:21:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:21:40 <codebliss> gotcha
06:21:55 <ejt> codebliss: for what you expected (>>=) == flip ($)
06:22:20 <ejt> which has nothing to do with monads
06:22:34 <codebliss> gotcha
06:22:49 <dolio> It's the identity monad.
06:24:37 <codebliss> I'm looking over **do { v <- m; return v } = do { m }** now.  So at the end of a sequence of monads, it returns the value of the last expression like normal f programming?
06:25:03 <ejt> simplify to **m**
06:25:08 <codebliss> So the monads are like a system for piping information along, and then at the end it shoots the value back to the normal haskell world?
06:25:21 <codebliss> It's just used to show they're the same thing, not real useful code, sorry
06:25:26 <ejt> codebliss: not quite piping
06:25:46 <codebliss> I haven't yet found a real difference to piping, so if you could explain that'd help  =)
06:25:55 <codebliss> http://en.wikibooks.org/wiki/Haskell/Category_theory atm
06:26:03 <ejt> well have a play with the list monad, rather than IO
06:26:12 <codebliss> kk
06:27:36 <codebliss> Just picked up haskell a week or two ago, sorry for any beginner questions.  Wanted to try it out after first touching F#
06:27:45 <Baughn> codebliss: Also, read the typeclassopedia ;)
06:27:53 <ejt> codebliss: sounds like you're doing well
06:27:59 <codebliss> Thanks.
06:28:15 <kadaver> dons: what is the name of that math visualization project you do?
06:28:22 <kadaver> or did or someone else did
06:30:41 <codebliss> By typeclassopedia do you mean the second article in Monad.Reader @ http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf ?
06:31:01 <edwardk> kadaver: that vacuum thing?
06:31:18 <ejt> codebliss: y, v. good article
06:31:50 <osfameron> is the TMR version the canonical one now?
06:31:58 <codebliss> Thanks  =)
06:32:00 * osfameron wgets
06:32:00 <pluto> daf: thanks. can you give me an example for printing (1 % 3) up to 100 decimal places?
06:33:14 <daf> > printf "%.100f" $ fromRational (1 % 3)
06:33:17 <lambdabot>   Add a type signature
06:33:27 <daf> > printf "%.100f" $ (fromRational (1 % 3) :: Double)
06:33:28 <lambdabot>   Add a type signature
06:33:31 <Baughn> > printf "%.100f" $ fromRational (1 % 3) :: String
06:33:33 <lambdabot>   "0.333333333333333300000000000000000000000000000000000000000000000000000000...
06:33:39 <daf> oh, right
06:33:43 <bremner> ugh
06:33:45 <kadaver> no some general math haskell visualization programs of toruses etc
06:33:48 <Baughn> ..the heck?
06:34:01 <daf> hmm
06:35:57 <edwardk> osfameron: brent wrote it for TMR, so i would suppose so
06:35:58 <Saizan> going through Double loses precision..
06:36:12 <osfameron> ah cool
06:36:34 <osfameron> I had a download of the draft that made the rounds on reddit a month or so ago
06:36:35 <codebliss> So fmap transforms a list of functions to a new function?
06:36:58 <codebliss> *fmap transforms a list of functions to a list of new functions
06:37:32 <edwardk> i am surprised that in this land of spigot algorithms Text.Printf doesn't have a Rational format, and that its formats don't have an option to take some modifier that says 'infinite precision' ;)
06:37:38 <Philonous> codebliss: "Piping information along" is not entirely wrong, but it's more general (and powerful) than that. Basically you have a Datatype X, map a  function over it thereby get a handfull of Xs and splice them back together afterwards, where the "mapping" and "splicing" is dependent on the datatype . You can use this to thread information along, concatenate lists of results etc.
06:38:11 <Philonous> @type fmap
06:38:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:38:23 <codebliss> ah
06:38:52 <Philonous> fmap "extends" a function f so it works on complex types rather than the basic type
06:39:17 <codebliss> Maybe I need to give this more time lol
06:39:30 <Philonous> It's like "if I have a function for numbers I can derive a function that works on lists of numbers, trees of numbers etc."
06:39:33 <codebliss> Basic type?  Is the complex type M t?
06:39:52 <codebliss> Oh
06:39:58 <codebliss> hm...
06:40:04 <Workybob> quicksilver: yeh, I discovered my bug – was setting the depth function before I created a GLFW window >.<
06:40:27 <codebliss> Without changing the original func?  Wouldn't that...be like foldl?
06:40:38 <Philonous> More like map
06:40:44 <ejt> codebliss: say I have a function that works on a single number ssay add1 = (+ 1)
06:40:46 <Philonous> Actually map is fmap for lists
06:40:51 <codebliss> Well say youkk
06:41:02 <codebliss> Oh ya lists are a monad...
06:41:04 <ejt> I can use fmap to 'lift' that to other types
06:41:14 <ejt> eg. fmap add1 [0..10]
06:41:24 <ejt> > fmap (+ 1) [0..10]
06:41:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
06:41:40 <Philonous> fmap (+1) $ Just 3
06:41:42 <Philonous> > fmap (+1) $ Just 3
06:41:42 <ejt> there it was lifted to work with lists
06:41:43 <codebliss> > map ((+) 1) [0..10]
06:41:43 <lambdabot>   Just 4
06:41:44 <darrenhobbs> what's the equivalent of printf "%.100f" $ fromRational (1 % 3) :: String that doesn't lose precision?
06:41:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
06:41:46 <codebliss> same thing?
06:41:47 <Philonous> > fmap (+1) $ Nothing
06:41:49 <lambdabot>   Nothing
06:42:08 <ejt> codebliss: y, except fmap is defined for lots of types
06:42:11 <ejt> map just for lists
06:42:16 <codebliss> oh
06:42:31 <ejt> and some of the instances are not really data structures
06:42:36 <codebliss> So map is a version of fmap for the list monad?
06:42:41 <Philonous> Exactly
06:42:45 <codebliss> kk
06:42:55 <codebliss> I always thought the other way around XD
06:43:06 <ejt> there is an operator <$> which is the same  as fmap
06:43:16 <ejt> > (^ 2) <$> [1..10]
06:43:17 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
06:43:22 <codebliss> ah
06:43:35 <codebliss> Wouldn't `fmap` work too?
06:43:45 <ejt> and if you want to lift a function with more arguments you can use <*>
06:43:53 <codebliss> kk
06:44:06 <ejt> > (+) <$> [1..10] <*> [10,9..1]
06:44:07 <lambdabot>   [11,10,9,8,7,6,5,4,3,2,12,11,10,9,8,7,6,5,4,3,13,12,11,10,9,8,7,6,5,4,14,13...
06:44:17 <codebliss> But since now all of these are for lists.  Are there any relatively simple examples that show the power of fmap?
06:44:20 <ejt> damn, bad example
06:44:40 <Philonous> codebliss: only map is for lists, the rest is more general.
06:44:42 <ejt> > fmap (+ 1) (4, 5)
06:44:44 <lambdabot>   (4,6)
06:44:56 <Philonous> > fmap (*2) $ Just 3
06:44:58 <lambdabot>   Just 6
06:45:25 <codebliss> What's in that monad again?
06:45:29 <codebliss> Nothing | Just x?
06:45:32 <Philonous> Yes
06:45:33 <edwardk> yeah
06:45:35 <codebliss> kk
06:45:46 <Philonous> > fmap (*3) Nothing
06:45:48 <lambdabot>   Nothing
06:45:53 <edwardk> when fmapping over Nothing, it has no value to apply your function to, so it has to return Nothing
06:46:00 <EvilTerran> > fmap f (Node x [Node y [], Node z []]) :: Tree Expr
06:46:01 <lambdabot>   Node {rootLabel = f x, subForest = [Node {rootLabel = f y, subForest = []},...
06:46:02 <codebliss> So **Just** turns it into the format for the monad, so it will return a Just x instead of x?
06:46:08 <Workybob> Anyone know ghc-api at all?
06:46:29 <Workybob> I'm pondering if there's a version of dynCompileExpr that will let me run something multi-line
06:46:41 <ejt> >  (fmap (^ 2) succ) 5
06:46:43 <lambdabot>   36
06:47:02 <ejt> codebliss: ^ that fmap changed the function 'succ'
06:47:07 <codebliss> I'm not huge on the types of structures for data yet, sorry.  Highschool student approaching freshman
06:47:55 <codebliss> Hm...
06:48:10 <codebliss> That's hard to wrap your head around
06:48:28 <ejt> don't worry about it, I was just trying to show that Functor is bigger than 'data structure'
06:48:39 <codebliss> mkay.
06:49:34 <wli> Workybob: Maybe a layout analyzer?
06:49:59 <codebliss> I'll finish typeclassopedia when I finish "getting" monads.
06:50:33 <wli> Workybob: (that would be something that translates whitespace layout affairs to semicolon-separated brace-wrapped affairs.
06:50:52 <Workybob> yeh, I'd thought about that – I am after all generating the expression automagically
06:51:03 <Workybob> but I'd hoped for something that would let me just pass a well layout out expr in
06:51:10 <Philonous> codebliss: Actually, all that was about functors
06:51:33 <codebliss> What exactly are functors?  I probably get everything around them, but I got to clear this up
06:51:36 <darrenhobbs> > :type Just
06:51:38 <lambdabot>   <no location info>: parse error on input `:'
06:51:56 <Workybob> codebliss: they're anything with a concept of something being inside them
06:52:04 <codebliss> Ah.
06:52:11 <dan_> what?
06:52:12 <codebliss> Collections Trees blahblah?
06:52:13 <Workybob> note "inside" is rather a specific term
06:52:23 <Workybob> functions have results "inside" them for example
06:52:24 <dan_> can you explain that definition bob?
06:52:25 <codebliss> kk
06:52:28 <dan_> that seems incomplete
06:52:30 <codebliss> ya
06:52:36 <Workybob> dan_: why do you think?
06:52:39 <dan_> mmm
06:52:40 <pluto> daf, Baughn: apparently precision is lost due to a conversion to a floating point number. is a "symbolic" string conversion without precision loss possible?
06:53:04 <dan_> functors, as far as code is concerned are just functions that get passed as arguments
06:53:17 <BONUS> i'd rather call them "things that can be mapped over"
06:53:19 <Workybob> dan_: huh?
06:53:20 <codebliss> kk
06:53:26 <Workybob> BONUS: yeh, that's perhaps a better description
06:53:27 <ejt> dan_: wrong functor
06:53:31 <codebliss> Then why did they prefer to use g and h for annonymous funcs instead of f?
06:53:35 <Workybob> though I'm not sure how you can map over something that doesn't have things inside
06:53:36 <Axman6> pluto: sounds like a limit of floats to me (or doubles)
06:53:39 <ejt> dan_: that's from C++
06:53:43 <wli> Functor qualifiers are on type constructors of kind * -> *
06:53:59 <codebliss> What's difference of a and *
06:54:10 <daf> pluto: seems that Text.Printf doesn't support ratios at least
06:54:23 <dan_> someone do my fortran homework
06:54:25 <dan_> i pay in beer
06:54:38 <dan_> jk jk
06:55:05 <darrenhobbs> http://en.wikibooks.org/wiki/Haskell/Category_theory has a section on Functors that seems to make sense to this haskell newbie
06:55:22 <codebliss> I'll reread =)
06:55:49 <codebliss> Biggest thng I didn't get is why on http://upload.wikimedia.org/wikibooks/en/3/36/Functor.png A and B merged
06:55:49 <vixey> a :: *
06:56:07 <zenzike> This my first chat on this irc, so bear with me if this is the wrong place to ask questions!
06:56:07 <zenzike> I'm defining a read function for a tree structure defined :
06:56:07 <zenzike> data Tree a = Fork (Tree a) (Tree a) | Leaf a | Stump
06:56:07 <zenzike> but I have an error message that I don't understand:
06:56:07 <zenzike>     Ambiguous type variable `a' in the constraint:
06:56:08 <zenzike>       `Read a' arising from a use of `readsTree'' at <interactive>:1:0-20
06:56:10 <zenzike>     Probable fix: add a type signature that fixes these type variable(s)
06:56:12 <zenzike> Can anybody lend a hand?
06:56:12 <codebliss> Every reason I find says C should merge with B also
06:56:21 <Axman6> functors are just things that given a function g :: a -> b, you can apply it to the functor f and turn f a into f b
06:56:29 <EvilTerran> ?hpaste
06:56:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:56:58 <Philonous> codebliss: in monads you work with functions where the right hand side is already lifted to the complex type, and you want the left side to be the complex type, too. For example you have a function Int -> [Int], but you want to it be [Int] -> [Int]. So what you do is you lift the whole function, than it is [Int] -> [[Int]], and afterwards you splice the right hand side (concat would do this for lists). Of course this doesn't wor
06:56:59 <Saizan> pluto: you could use this module http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-CReal.html or BigFloat in the same package
06:57:08 <EvilTerran> zenzike, if you paste your code & error message on there, we might be able to help you out
06:57:23 <Axman6> zenzike: this is the right place to ask, but don't paste large amounts of text
06:57:26 <Philonous> with every type*
06:57:35 <codebliss> Oh, okay.
06:58:07 <codebliss> Complex type is collection?
06:58:21 <Axman6> @src Complex
06:58:21 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
06:58:22 <Philonous> Might be. Or function. Or Tree.
06:58:29 <zenzike> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3094#a3094
06:58:34 <Axman6> >_>
06:58:39 <codebliss> A non-value?
06:58:42 <zenzike> sorry for the first spam message, it all came out at once ;)
06:58:42 <daf> pluto: it's certainly possible; I just can't think how right now
06:58:43 <Axman6> anyway, sleep time. night peeps
06:58:44 <Philonous> really enything that you can map over and splice together
06:58:58 <codebliss> zenzike: You could just write 1 big block lol
06:59:08 <codebliss> Philonous: Good def.
06:59:54 <zenzike> codebliss: yeah, i realised that after i hit enter. Im used to displaying linebreaks with ctrl+enter, but it obviously turned into multiple messages
07:00:01 <codebliss> This stuff reminds me of calc.  Small changes to what you're used to that opens up big doors.  Just seems weird at first.
07:00:10 <codebliss> zenzike: No problem  =)
07:01:34 <darrenhobbs> I can recommend Real World Haskell as a good introduction to all this monadic crazyness
07:01:49 <codebliss> On http://en.wikibooks.org/wiki/Haskell/Category_theory why when you apply a functor does A merge to B?
07:01:52 <codebliss> kk
07:02:29 <zenzike> I'm basically trying to parse a string into a tree structure that holds Chars in leaves, which is left associative by default, but allows brackets for different associations.
07:02:47 <vixey> zenzike: ok
07:02:58 <codebliss> Rereading http://book.realworldhaskell.org/read/ .  Thanks  =)
07:03:09 <vixey> zenzike: are you stuck ?
07:03:10 <codebliss> Definitely buying.
07:03:43 <zenzike> vixey, yes -- i can't get the readsTree function i'm defining to work
07:03:46 <vixey> zenzike: I should think join would rather have a type such as  :: Tree (Tree a) -> Tree
07:03:52 <vixey> zenzike: Tree (Tree a) -> Tree a **
07:04:33 <zenzike> vixey: the point of join is to stick two trees together -- i'm not sure what you're tyring to do with your signiature?
07:05:46 <vixey> zenzike: I think these two cases: readsTree' t (')':xs) = ... & readsTree' t (x:xs) = ... should not be written
07:06:35 <vixey> (actually it's a bit complicated by doing reads rather than just read)
07:06:55 <darrenhobbs> I think that diagram is just confusing. I don't think there's anything necessarily significant about the fact that A and B get mapped to the same object. Someone please correct me (and explain it!) if I'm wrong
07:06:57 <zenzike> vixey: i'm not sure i see what you're pointing to as a problem?
07:07:41 <vixey> zenzike: You are trying to write  String -> Tree Char  I guess, but I you should first write an easier program:  Tree Char -> String
07:07:59 <zenzike> vixey: i've done that one
07:08:06 <vixey> ok
07:08:09 <zenzike> vixey: i had no problems with that definition
07:09:02 <zenzike> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3094#a3095 shows the error i dont understand
07:09:37 <codebliss> Did I ever mention that haskell is awesome?  Any language with an awesome lazy system like this is a dream.
07:09:40 <codebliss> > take 5 $ map (^2) $ [1..]
07:09:41 <lambdabot>   [1,4,9,16,25]
07:09:45 <kadaver> i need a function game :: Concept -> DotExe
07:09:47 <vixey> > map (^2) $ [1..]
07:09:49 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
07:09:56 <ejt> zenzike: put a type decl on readsTree
07:09:59 <codebliss> Yep =)
07:10:18 <wli> Well, with join :: Tree (Tree a) -> Tree a, you can just use (>>=) to unravel bindings.
07:10:23 <codebliss> That is just too awesome.  It like limits the limits of imperative off my head
07:10:27 <zenzike> you mean like readsTree :: (Read a) => ReadS (Tree a)
07:10:47 <ejt> if that's what you intended
07:11:03 <ejt> and one for readsTree' too
07:11:30 <ejt> it documents your code, and also helps the compiler give you more helpful errors
07:11:38 <zenzike> They are actually in my def, but it doesnt help the error
07:13:31 <kadaver> how hard would it be to write a C compiler in haskell? or perhapsa C interpreter :p
07:14:09 <ejt> kadaver: the parser is already done (language-c)
07:14:11 <vixey> quite hard
07:15:22 <ejt> I think not too hard, have you seen augustss' obfuscated C contest entry from the mid 90's ?
07:15:59 <ejt> it implements a little vm, and the comment at the top of the file contains bytecode for a C->bytecode compiler
07:16:38 <wjt> ejt: url?
07:17:32 <daf> depends how good a C compiler for how much of C you want
07:17:34 <ejt> http://www.ioccc.org/1996/
07:17:46 <ejt> look at august.hint and august.c
07:17:54 <QtPlaty[HireMe]> foogle: [a] -> a -> [a]
07:18:34 <ejt> fabrice bellard did a proper c -> native code compiler a few years later
07:18:51 <daf> well, that's Fabrice Bellard :)
07:19:17 <ejt> y, whenever I want to feel stupid I go look at what he's been up to
07:22:24 <wjt> ejt, augustss: *nice*
07:28:38 <wli> For ioccc?
07:43:49 <ejt> zenzike: did you solve you problem ?
07:44:19 <singintime> hello everybody
07:44:41 <zenzike> ejt: still working on it :S
07:44:56 <ejt> the problem is ghci has no idea what type is in your tree
07:45:30 <zenzike> i figured that part out, but even something like : (reads "abc" :: Tree Char) gives me problems
07:45:32 <ejt> since you just mention Stump and [] in the expression, neither of which give enough info for type inferrence
07:45:43 <ejt> ok, different problem then
07:45:57 <vixey> zenzike: what problems?
07:46:21 <zenzike> the same one as earlier. i have a good showsTree function, but can't seem to get the readsTree to work
07:50:11 <Twey> @hoogle (Monad m) => Int -> m a -> m [a]
07:50:12 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
07:50:12 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
07:50:12 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:52:25 <wli> Maybe there needs to be a way to say some tyvar should remain polymorphic, though less general types are admissible.
07:54:49 <Twey> @hoogle a -> [a] -> Bool
07:54:50 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
07:54:50 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
07:54:50 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
07:55:04 <Twey> My Haskell's too rusty, should've remembered that
07:55:20 <vixey> @src elem
07:55:20 <lambdabot> elem x    =  any (== x)
07:55:23 <Twey> :(
07:55:39 <QtPlaty[HireMe]> Is there anyway to say "This or this" in a pattern match?
07:55:46 <vixey> no
07:55:57 * wli hasn't been using lists as much these days. Mostly (Int)Map and (Int)Set these days.
07:57:11 <quicksilver> QtPlaty[HireMe]: no, although I once suggested that as a feature enhancement.
07:57:31 * Badger hugs Twey 
07:57:57 <Twey> Hi Badge
07:58:31 <wli> I'll abuse Map as a priority queue from time to time.
07:58:44 <wferi> Hi! Why utf8-string doesn't provide validation? What do you use when you want to be sure the input is correct UTF8?
07:59:07 <wli> s/from time to time/at some point in almost every program/
07:59:09 <Twey> I think it throws an exception if it isn't
07:59:13 <Twey> Hahaha
07:59:27 <wferi> cool...
07:59:32 <wferi> :-/
08:00:10 <wferi> For the IO part, that may be usable.
08:01:24 <lilac> zenzike: try (reads "abc" :: (Tree Char, String))
08:01:29 <lilac> @type reads
08:01:31 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:01:38 <lilac> zenzike: try (reads "abc" :: (Tree Char, String))
08:01:39 <wferi> As I read the source, it does not throws exceptions.
08:01:51 <wferi> Simply inserts the replacement chars.
08:01:53 <lilac> erk, ... :: [(Tree Char, String)]
08:02:29 <dolio> utf8-string is a band-aid.
08:02:42 <Baughn> > read "2 3 4" :: [(Int,String)]
08:02:43 <wferi> Fine, so what do real men use?
08:02:44 <lambdabot>   * Exception: Prelude.read: no parse
08:02:47 <Baughn> > reads "2 3 4" :: [(Int,String)]
08:02:49 <lambdabot>   [(2," 3 4")]
08:02:54 <dolio> Data.Text, in the future.
08:03:06 * Twey gets his time machine.
08:03:14 <wferi> And what do real men use now?
08:03:24 <dolio> Band-aids.
08:03:27 <lilac> > reads "123 4" :: [(Int,String)]
08:03:29 <lambdabot>   [(123," 4")]
08:03:29 <wferi> :(
08:03:30 * Twey chuckles.
08:03:31 <lilac> :-(
08:03:40 <lilac> real men use duck tape
08:03:43 <vixey> @remember  <wferi> And what do real men use now? <dolio> Band-aids.
08:03:43 <lambdabot> I will remember.
08:03:53 <dolio> Data.Text may have some kind of verification already. I'm not really sure.
08:04:01 <wferi> lemme see
08:08:08 <wferi> otherwise = encodingError "UTF-8"
08:08:30 <wferi> That's an error at least.
08:15:59 <zenzike> does anybody have recommendations for good vim syntax highlighting for haskell? ie. something that highlights defined functions like in the pastie?
08:17:27 <zenzike> lilac: thanks for the suggestion :) it's type correct, but always returns []. at least that might mean a bug in my function
08:17:30 <zachk> zenzike: i like the default highlighing of vim 7.2 on windows xp
08:17:53 <vixey> zenzike: For "abc"
08:18:01 <vixey> is there 4 possible trees?
08:18:07 <zenzike> zachk: ah, improved from 7.1?
08:18:35 <zenzike> vixey: no, only 1, since my def should make that left associative, ie (((a)b)c)
08:18:52 <vixey> i was thinking like
08:19:00 <vixey> () & (a) & ((a)b) & ...
08:19:34 <zenzike> vixey: oh right. i dont think the fragments should be proper parses
08:19:44 <vixey> so when does  reads  know when to stop?
08:20:10 <zenzike> it should just keep consuming until the string is empty
08:20:23 <zachk> is there something like the List monad, works with guard, but can work on infinite lists, and starts from the smallest and grows out from there?
08:20:37 <vixey> zenzike: So you can simplify it a bit then, by writing  read  instead of  reads
08:21:36 <zenzike> maybe i'm getting things all wrong here, since i do have a "makeTree" function wiht sig: [Char] -> Tree Char that works fine
08:22:05 <vixey> why don't you just define reads to use that makeTree then?
08:22:08 <zenzike> the point is that i wanted to be able to type something like: join (reads "ab") (reads "c") and get the tree "abc"
08:22:33 <vixey> and that doesn't happen?
08:22:37 <vixey> :t reads
08:22:38 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:22:41 <vixey> I guess reads is the wrong type for that
08:22:50 <zenzike> i thought that reads needed to be defined in terms of an instance of Read a, through readsPrec, which takes something of type ReadS (Tree a)
08:23:01 <zenzike> yeah, exactly
08:23:14 <zenzike> which is where i get the monstrosity i'm working with :)
08:23:55 <zenzike> :t read
08:23:56 <lambdabot> forall a. (Read a) => String -> a
08:28:45 <EvilTerran> zachk, there's control-monad-omega and logict on hackage, they might do what you want
08:31:03 <zachk> will things from Control.Monad work with any monad?
08:31:20 <vixey> zachk: yes
08:31:20 <EvilTerran> from Control.Monad itself, yes
08:31:26 <vixey> Monad m => ... means any monad
08:31:31 <EvilTerran> from Control.Monad.SomethingElse, well, that depends on the SomethingElse
08:31:39 <zachk> ah sweet
08:32:08 <cognominal_> I am reading http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf and I cannot make sense of some code page 3
08:32:34 <cognominal_>  ’<’ → case lt s of  ...
08:32:57 <cognominal_> lt   is a String  so what the heck      lt s   can mean ?
08:34:12 <doserj> cognominal_: lt is a named field, of type string
08:34:22 <cognominal_> ho!
08:34:38 <cognominal_> I hate named fields in haskell
08:34:49 <vixey> I hate them too
08:34:55 <vixey> They are an irregularity
08:35:08 <Cale> Named fields do their job.
08:35:21 <cognominal_> also field names are global?
08:35:34 <dolio> They're just functions on the getting end.
08:36:10 <ertai> does anyone know why there is no enumFromToThenFracU in uvector ?
08:36:19 <Cale> cognominal_: Nothing in Haskell is really global.
08:36:26 <Cale> cognominal_: We have a module system :)
08:36:33 <Twey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2008#a2008 — there's something horribly wrong with this shuffling algorithm.  What is it?  Even after 200 passes it looks as if the list has hardly been shuffled at all — things like "DEFABC" for "ABCDEF"
08:36:39 <vixey> enumFromToThenFracU lol
08:36:40 <Cale> cognominal_: But they're module-scoped.
08:36:41 <Twey> The numbers seem to be suitably random
08:36:53 * Cale looks
08:37:26 <vixey> I think it's a bad algorithm :p
08:37:37 <quicksilver> Twey: cutting the deck doesn't shuffle cards
08:37:44 <Twey> Of course, it's an utterly shoddy algorithm, but it shouldn't be *that* shoddy
08:37:47 <EvilTerran> Twey, have you seen http://okmij.org/ftp/Haskell/#perfect-shuffle ?
08:37:52 <Twey> EvilTerran: I have
08:37:55 <quicksilver> Twey: it you're just computing a random cyclic rotation.
08:37:56 <EvilTerran> ... quicksilver makes a good point
08:38:01 <Twey> I have seen, I have boggled, and I have screamed
08:38:07 <vixey> yes it's rotation not permutation
08:38:07 <quicksilver> it's a common trick used by really poor magicians
08:38:10 <quicksilver> (like me, age 10)
08:38:12 <EvilTerran> repeatedly cutting a deck doesn't change the order of the cards
08:38:24 <quicksilver> cut the deck 10 times, audience pretends to be surprised when the order hasn't changed.
08:38:24 <Twey> quicksilver: Hm, can you explain?
08:38:27 <ertai> vixey: enumFromThenToFracU
08:38:35 <ejt> I remember that trick :)
08:38:49 <Cale> Twey: If you cut the deck somewhere and swap the two halves, you've essentially just rotated the cards a bit.
08:38:54 * Twey ponders.
08:38:56 <Twey> Oh, right
08:39:02 <Twey> So there are only six possible permutations?
08:39:06 <Cale> yeah
08:39:08 <EvilTerran> and rotations compose into rotations
08:39:13 <Twey> (for input of length six)
08:39:16 <quicksilver> they're a subgroup!
08:39:16 <Twey> I see
08:39:20 <Twey> Thanks :)
08:39:30 * Twey swaps instead
08:39:30 <quicksilver> group theory, as learnt through amateur card-sharpery
08:39:35 <Twey> Hahaha
08:39:41 <Cale> Twey: Don't just swap randomly either.
08:39:43 <quicksilver> I wonder how many card tricks can be given group theoretical explanations.
08:39:53 <Cale> Twey: Or you'll again not end up with an appropriate distribution.
08:40:01 <Twey> Cale: Why's that?
08:40:15 <vixey> quicksilver: all of them!
08:40:17 <Cale> Twey: Well, it's a bit like trying to sort a list by comparing and swapping random elements.
08:40:38 <Cale> Twey: Chances are you'll miss some :)
08:40:49 <Twey> Ah, yes
08:40:53 <Twey> So, what was it
08:41:00 <Twey> I need to swap each element with a random other element?
08:41:07 <c_wraith> No, that's not right.
08:41:07 * EvilTerran seems to recall that swapping each element in turn with a random one after it was sound
08:41:09 <Twey> Only one end of the swap being random
08:41:13 <Twey> Blast
08:41:18 <c_wraith> That's *close*
08:41:20 <c_wraith> but it's biased
08:41:31 <Twey> It's good enough for this purpose
08:41:36 <c_wraith> What you want is to essentially maintain a "shuffled" and a "not-shuffled" list
08:41:38 <Twey> But just for the sake of curiosity
08:41:41 <Twey> What's better?
08:41:42 <Twey> Aha
08:41:55 <c_wraith> and each iteration, choose one randomly from the not-shuffled list, and move it into the shuffled list
08:42:08 <c_wraith> There are clever ways to do that in an array, so it looks really slick
08:42:12 <Cale> For each k, swap element k with some element from k up to n.
08:42:30 * EvilTerran suggested what Cale just suggested, only less articulately
08:42:32 <Cale> (is a sort of imperative way to say that)
08:42:34 <Twey> I see *nods*
08:42:57 <vixey> hm
08:43:05 <vixey> if you swap from k = 0 .. n or k = n .. 0 ?
08:43:11 * Twey keeps seeing the Dilbert random number generator
08:43:20 <Twey> 'Nine... nine... nine... nine...'
08:43:36 <c_wraith> vixey, depends on if you loop from 0 up or n - 1 down.
08:43:49 <vixey> that's what I'm talking about
08:43:53 <vixey> does it matter?
08:44:03 <quicksilver> Twey: see also http://xkcd.com/221/
08:44:08 <c_wraith> No, it's the same algorithm from opposite ends of the array
08:44:24 <Twey> Haha, indeed
08:45:38 <MoxJet> Hello, I cannot find the gtk and cairo packages on hackage/cabal, where are they?
08:45:59 <Twey> @hoogle Int -> a -> [a] -> [a]
08:46:00 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:46:00 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
08:46:00 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
08:46:05 <c_wraith> vixey: Just mentally partition the array into "shuffled" and "unshuffled".  Always pull a randomly-chosen element from "unshuffled" into "shuffled".  It doesn't really matter which side of the array you declare to be which partition, so long as you implement it correctly.
08:46:13 <Saizan> @google gtk2hs download
08:46:15 <lambdabot> http://www.haskell.org/gtk2hs/download/
08:46:15 <lambdabot> Title: Gtk2Hs » Download
08:46:20 <Saizan> MoxJet: ^^^
08:46:23 <maltem> MoxJet: gtk2hs isn't fully cabalized yet. You'd have to get the source tree from the website
08:46:24 <MoxJet> clever ^^
08:46:27 <Cale> vixey: It's important that the number of ways for any given element to land in any given spot is the same. In order for this to happen, the simplest way to arrange it is just to make sure that each element of the original list is placed and then never has a chance to move.
08:46:31 <MoxJet> thanks
08:46:32 <kadaver> is there some good site where you can codereview? i miss that, i learn by myself and books but i have noone that reviews my work other than myself
08:46:42 <maltem> oops, I missed some lines ^^
08:47:39 <Cale> kadaver: Well, you can post things on hpaste, and then link us to them, or post a link to the haskell-cafe list asking for comments.
08:47:41 <EvilTerran> Cale, that strikes me as reminiscent of a kind of anti-insertion-sort
08:47:47 <Cale> EvilTerran: yeah
08:48:02 <Cale> You can obtain a shuffle from any sorting algorithm.
08:48:05 <EvilTerran> or anti-selection-sort, depending on what semantics "anti-" has in that sentence :P
08:48:14 <c_wraith> selection, by structure.
08:48:19 * EvilTerran envisages a merge-shuffle
08:48:32 <quicksilver> often known as a 'merfle'
08:48:47 <c_wraith> And...  please don't try to shuffle using qsort with a comparator that returns a random value.  that's biased beyond belief
08:51:46 <Cale> There is a way to turn quicksort into a proper shuffling algorithm though.
08:51:52 <wli> Sorting in what data structure?
08:52:18 <vixey> any sorting algorithm really
08:52:23 <Cale> yeah
08:52:27 <wli> Singly-linked list, doubly-linked list, array?
08:52:40 <vixey> if it's really a sort, it should be able to achieve any permutation
08:53:20 <wli> The data structure used to represent the ordered set/sequence/etc. makes a big difference wrt. the code.
08:53:25 <Cale> wli: It's irrelevant here :)
08:53:34 <Cale> An ordered sequence of some kind :)
08:53:53 <Cale> http://apfelmus.nfshost.com/random-permutations.html -- here's the merge sort one :)
08:54:22 <wli> Oh, you're trying to generate random permutations?
08:54:25 <Cale> wli: It only makes a difference with regard to performance.
08:54:38 <Cale> (what kind of data structure you use to hold the sequences)
08:54:54 <Cale> and I suppose how concise the code would be
08:55:05 <p0l0na1sE> [B
08:55:14 <wli> Well, sometimes it doesn't perform any differently. I was mostly thinking of how well the algorithm fit the data structure.
08:55:38 <Cale> p0l0na1sE: mojibake
08:56:03 <Cale> (Whatever character encoding that is, it's not the right one ;)
08:57:43 <wli> Some algorithms really want random access.
08:58:12 <wli> By the time you adapt the algorithm to some other data structure it's a different algorithm.
09:00:01 <LeCamarade> Is there an alternative linker I can use with GHC? I can't seem to build gold.
09:00:04 <RayNbow> @let takeUntil p xs = takeWhile (not . p) xs
09:00:05 <lambdabot>  <local>:37:0:
09:00:06 <lambdabot>      Multiple declarations of `L.takeUntil'
09:00:06 <lambdabot>      Declared at: ...
09:00:10 <LeCamarade> And ld proper is a bit too slow.
09:00:10 <RayNbow> hmm
09:00:13 <RayNbow> @hoogle takeUntil
09:00:14 <lambdabot> No results found
09:00:20 <Cale> Well, it depends on how you interpret the notion of an algorithm... people complain that the simple sorting algorithm which is often shown to beginners is "not really quicksort", but interpreted correctly, quicksort is exactly what it is.
09:00:28 <Cale> It's just not in-place.
09:00:38 <RayNbow> > takeUntil (==1.1) $ iterate (+0.1) 0.1
09:00:40 <lambdabot>   [0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999999...
09:00:54 <quicksilver> I'm one of the complainers.
09:01:00 <Cale> (or unlikely to be in-place anyway)
09:01:02 <RayNbow> > takeUntil (==1.1) $ iterate (+0.1) 0.1  ::  [CReal]
09:01:04 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
09:01:15 <quicksilver> I claim that a *key feature* of quicksort is the specific, clever, swapping algorithm used for the partition
09:01:31 <Cale> That was never a feature of quicksort to me.
09:01:35 <quicksilver> the mere idea of partitioning around a pivot is only half the specification.
09:01:46 <vixey> I want to see the original implementation (non recursive one)
09:01:48 <ejt> RayNbow: checking for equality of a floating point number isn't very clever
09:01:54 <RayNbow> ejt: I know :)
09:02:07 <idnar> >=1.1, I guess
09:02:17 <RayNbow> I was just trying to construct an example which gives "unexpected" results
09:02:22 <jmcarthur> i agree, quicksort is all about the fact that you can swap around the pivot very efficiently
09:02:45 <Cale> Any sorting algorithm which picks a pivot element from the list, splits the list into two halves, one of which consists of elements greater or equal to that, and the other which consists of elements less than it, and then recursively sorts the two halves is a quicksort.
09:03:03 <idnar> Cale: is there any point in using a quicksort that's not in-place?
09:03:04 <Cale> There are more efficient and less efficient ways of implementing that idea.
09:03:20 <quicksilver> I don't have a copy of hoare's article :)
09:03:23 <Cale> idnar: With immutable lists, it wouldn't be.
09:03:41 <quicksilver> I know that the people I used to work with felt the inplace swap was a key feature of the algorithm though.
09:03:44 <idnar> Cale: wouldn't be in-place?
09:03:46 <ejt> I think all quicksorts have to have the same O running time
09:03:53 <Cale> idnar: Right.
09:04:14 <idnar> Cale: well, yes, obviously; what I mean is, does quicksort have any advantage over other sorting algorithms if you're not doing it in-place?
09:04:18 <Cale> idnar: Unless the compiler was really really smart and a bunch of other conditions were met (like you didn't reuse the original list)
09:04:31 <ejt> if someone claimed to have implemented quicksort, but it took O(n^2) time, I'd argue that they haven't
09:04:46 <Cale> idnar: Well, it's still O(n log n) time average case
09:05:19 <Cale> O(n^2) time worst case, like all quicksorts which don't work harder at finding a good pivot are.
09:05:44 <idnar> Cale: isn't merge sort also Θ(n log n)
09:05:47 <Cale> It is.
09:05:57 <jmcarthur> merge sort is O(n log n) in worst case too though
09:06:04 <Cale> Merge sort is actually better for immutable lists in practice as well.
09:06:25 <Cale> and not much harder to implement
09:06:34 <quicksilver> merge sort timing is very predictable, with relatively little variation based on input list
09:06:38 <quicksilver> sometimes that's a good thing.
09:06:39 <idnar> okay, so quicksort is pointless if it's not in-place
09:06:42 <jmcarthur> i think merge sort is far easier to implement that _real_ quicksort ;)
09:06:46 <idnar> unless I've missed something?
09:06:54 <Cale> idnar: "pointless"?
09:07:04 <Cale> idnar: It's *an* algorithm.
09:07:12 <Cale> It might not be the best one.
09:07:21 <Cale> But that's always true.
09:08:03 <mercury^> There's also an in place mergesort.
09:08:04 <Cale> Even in-place quicksort is not necessarily the best thing.
09:08:10 <darrenhobbs> one of the observations about quicksort was that big jumps (swaps) are more efficient than little ones, so the swapping is important
09:08:34 <Cale> (even if you pick a pivot intelligently)
09:09:03 * raxas still remembers old times when merge sort was actually used to sort on _tapes_
09:09:19 <Cale> Asymptotically, of course, O(n log n) time is the best you can do for a general comparison sort.
09:09:38 <Cale> and you can't really hope for better than O(n) space :)
09:09:45 <Cale> (which the in-place version has)
09:09:52 <quicksilver> merge sort is easy to adapt to offline
09:09:58 <quicksilver> (like raxas's tapes)
09:10:01 <quicksilver> that's an advantage of it.
09:10:16 <idnar> looks like wikipedia thinks quicksort doen't have to be in-place
09:10:23 <jmcarthur> in place quicksort with intelligent pivot choice and a switch to insertion sort for the smallest partitions is really hard to beat for most cases
09:10:40 <c_wraith> idnar: of course it doesn't...  it's just most efficient if it is
09:10:49 <Cale> I tend not to think of algorithms as necessarily directly concerning memory at all.
09:10:52 <cognominal_> how to convert a Int to a [Char] ?
09:10:55 * EvilTerran really likes the functional mergesort
09:10:59 <Cale> cognominal_: show
09:11:02 <Cale> > show 7348291
09:11:04 <lambdabot>   "7348291"
09:11:04 <darrenhobbs> of course these days we've all got plenty of cores so parallel algorithms will become more important
09:11:08 <wli> IntMap would probably do this well.
09:11:13 <cognominal_> arf, obvious.   thx
09:11:30 <quicksilver> Cale: most algorithms aren't. A minority of algorithms are very explicit about their memory layout.
09:11:38 <Cale> quicksilver: right.
09:11:43 <quicksilver> Cale: some of the heap stuff is really about memory layout.
09:12:06 <quicksilver> B*-trees, too.
09:12:16 <idnar> darrenhobbs: yes, but I think people are overestimating on that axis
09:12:27 <wli> Memory layout is a very big deal these days, actually.
09:12:38 <darrenhobbs> Judy trees: they're all about optimising for the cpu cache
09:12:58 <wli> Cache footprint, cachelines dirtied, etc.
09:13:03 <Cale> Everything about most algorithms should be capturable in the lambda calculus :)
09:13:16 <vixey> well..............
09:13:18 <vixey> not sure Cale
09:13:33 <vixey> if you wanted to describe mutation you could do it via e.g. monads
09:13:40 <wli> quicksilver: Remind me what B^* is vs. B or B^+
09:13:47 <vixey> but that it's done in terms of lambda calculus is just an implementation detail in that case
09:14:29 <mattam> B? or B^+
09:14:48 <Cale> Well, really I think of algorithms as being even more abstract than that.
09:15:02 <quicksilver> wli: I can't remember any more. It's the kind of boring thing you only understand for as long as you need to to read a particular paper :)
09:15:37 <Cale> An algorithm isn't something which really belongs to a given language or context. It's an idea for how to do something.
09:16:04 <quicksilver> there is no reason why "how to do something" rules out a conversation about how you use memory cells.
09:16:07 <mercury^> "how" is open to interpretation
09:16:17 <quicksilver> I agree that quite often that's not an interesting point to emphasise.
09:16:20 <quicksilver> but sometimes, it is.
09:16:43 <mercury^> It is important if you are after a low constant factor.
09:16:46 <quicksilver> a discussion of a hashtable algorithm without talking about buckets and cells would be slightly perverse.
09:17:46 <Twey> Well, there is some context
09:17:56 <Twey> A functional algorithm isn't always an imperative algorithm
09:18:00 <wli> quicksilver: I mostly know of B^+
09:19:53 <EvilTerran> ?type ((||)`on`null) <*> tail
09:19:54 <lambdabot> forall a. [a] -> Bool
09:20:31 <EvilTerran> @check \xs -> (on(||)null<*>tail) xs == (length xs < 2)
09:20:33 <lambdabot>   "OK, passed 500 tests."
09:21:08 <kadaver> how much slower is reading a file in haskell than C?
09:21:14 <kadaver> any benchmarks on that?
09:21:15 <quicksilver> kadaver: it's about 1.1x faster
09:21:29 <kadaver> lazy io
09:21:34 <quicksilver> no, bytestrings.
09:21:45 <kadaver> but it is not...faster?
09:21:45 <quicksilver> built in [Char] IO is hideously slow.
09:21:58 <kadaver> are bytestrings really faster?
09:22:01 <pumpkin> yup
09:22:02 <kadaver> REALLY?
09:22:02 <quicksilver> yes, it's faster, because haskell is made of smile and win, whilst C is made of fart and lose.
09:22:04 <Twey> By far
09:22:20 <quicksilver> benchmarks are worthless
09:22:23 <rio> quicksilver: ill note that for further reference
09:22:25 <mercury^> You can certainly read a file just as fast in C. :>
09:22:25 <Cale> I think this is perhaps a bit of an exaggeration.
09:22:32 <quicksilver> but dons managed to show a benchmark where bytestring was faster
09:22:32 <Cale> It can very well be faster.
09:22:41 <Cale> But there are also cases where it's slower.
09:22:43 <EvilTerran> mmap()...
09:22:44 <kadaver> cool
09:22:48 <quicksilver> whoever chooses the benchmark wins the race
09:23:00 <quicksilver> but it is certainly true than haskell can be fast enough for what ever you need.
09:23:25 <Cale> The reason why it can be faster is that bytestring is filled with code-rewriting rules, such that you'd have to write very clever C code to match the performance of a naively-written bytestring program.
09:23:52 <jmcarthur> as with nearly any Haskell vs. C situation
09:23:56 <Cale> (to the extent that you couldn't make use of C library functions)
09:24:43 <Cale> But to say that it's 1.1x faster is possibly misleading.
09:25:01 <Cale> On average I'm not certain what the ratio is, but it's competitive anyway.
09:25:04 <pumpkin> I think it was a joke :P
09:25:18 <wli> The memory layout issue has been found to be so overwhelming that really stupid contiguity tricks have been found to have massive effects.
09:25:18 <quicksilver> it was a joke, yes.
09:25:28 <quicksilver> but I think there was a benchmark in which it was true.
09:25:39 <quicksilver> there were many other benchmarks in which different things were true.
09:25:45 <Cale> There was.
09:25:51 <RayNbow> hmm... a bug in random-shuffle package?
09:25:58 <quicksilver> the take-home message is : you can make haskell IO fast enough, if you care to take the time to do so.
09:26:05 <quicksilver> and using bytestring IO is a decent starting point.
09:26:19 <Cale> There were some very simple tasks on which bytestring was beating C, because in order to compete, the C code would have to be torn apart and rewritten to do block-buffering.
09:26:34 <Cale> (and not to make such high-level library calls)
09:26:41 <tessier_> Has anyone else considered that lazy evaluation is vaguely similar to measuring a quantum particle and collapsing the wave function to produce an actual result which did not exist before? Or is this the sort of thing all functional programmers consider amid the purple haze of mary jane?
09:26:55 <Cale> tessier_: It's much more deterministic than that.
09:27:01 <wli> C's format string stuff crucifies its string processing performance.
09:27:07 <tessier_> Cale: Yes, it is.
09:27:19 <tessier_> Cale: But not from the progams point of view.
09:27:22 <tessier_> program's
09:27:32 <Cale> tessier_: The entire point of purity is that you can't tell the difference between an evaluated expression and an unevaluated one :)
09:27:44 <jmcarthur> tessier_, how is the program's point of view any different than the programmer's?
09:27:46 <vixey> tessier_: I don't know .. anything about quantum physics actaully... but have you seen the quantum IO monad? not sure if it relates or not but it might
09:27:57 <quicksilver> wli: equally, haskell's [Char] stuff crucifies its string processing performance :)
09:27:58 <tessier_> Cale: I thought the entire point was avoiding side-effects?
09:28:07 <Cale> tessier_: Well, that too. :)
09:28:15 <mercury^> The two are related.
09:28:18 <tessier_> jmcarthur: The programmer can solve the halting problem.
09:28:38 <Cale> tessier_: But the reason we want to avoid side-effects is that it makes reasoning about the code easier.
09:28:44 <tessier_> Cale: Right.
09:29:03 <vixey> The programmer can solve the halting problem ???
09:29:15 <vixey> How about:
09:29:20 <Cale> tessier_: Why it makes reasoning about code easier is that we can use equations which are made true by the fact that evaluated expressions are indistinguishable from unevaluated ones.
09:29:22 <vixey> The programmer can solve specific instances of the halting problem
09:29:26 <vixey> this is also true of programs
09:30:17 <RayNbow> hmm, System.Random.Shuffle.shuffle' [] 0 (System.Random.mkStdGen 1)  --  is this supposed to crash GHCi 6.10.1?
09:30:25 <wli> quicksilver: [Char] is bad, but there are at least other high-level API's which _are_ efficient, vs. C where layer inversions and open coding and total non-genericity etc. are required to get it to perform.
09:30:40 <quicksilver> wli: true.
09:31:34 <Cale> Besides, collapsing of the wave function doesn't really happen :)
09:31:56 <Cale> It's just a trick which is valid to use when we don't care about the other components anymore :)
09:34:33 <bremner> @src otherwise
09:34:33 <lambdabot> otherwise = True
09:34:47 * Badger wonders if anyone could aid with a little regex problem.
09:34:53 <Badger> namely
09:34:58 <Badger> if($arg =~ m/(\d+)#(\d+)d(\d+)+(\d+)/)
09:35:07 * Badger wants to add ? to sections of that
09:35:10 <Cale> The "reason" that collapse of the waveform *appears* to happen is that quantum observables are linear maps, including the somewhat trivial observable of having witnessed a definite outcome. So if you have some state which is a formal sum of all these possibilities, and you apply the 'definiteness' operator to it, the result can be nothing but the formal sum of the definiteness operator applied to each of the definite
09:35:11 <Cale> possible outcomes.
09:35:11 <Badger> but unsure how
09:35:12 <idnar> Badger: you know what they say about regexes and problems
09:35:19 * bremner flees for #perl
09:35:29 <Badger> hey, haskell does regex. :P
09:35:38 <Badger> idnar: I do?
09:35:58 <Cale> (which is of course "true" in each case)
09:36:59 <Cale> So what's really happening is that the observer is being entangled with the quantum system they're observing.
09:37:19 <idnar> Badger: Some people, when confronted with a problem, think "I know, I'll use regular expressions."  Now they have two problems.
09:37:22 <Cale> If you have multiple nested observers, you have to care about that :)
09:37:24 <idnar> Badger: attributed to jwz, I believe
09:37:32 <Badger> heh.
09:37:53 <idnar> Badger: what parts do you want to add ? to
09:38:30 <Badger> I want to make (\d+)# and +(\d+) conditional.
09:38:47 * Badger doesn't know if conditional makes sense there.
09:38:54 <idnar> (?:(\d+)#)? I guess
09:39:17 <quicksilver> ? means optional not conditional
09:39:24 <quicksilver> I don't know what Badger means by conditional.
09:39:32 <Cale> (But if you don't care about other outside observers who will witness the people who witnessed the experiment, then it doesn't matter and you can just drop all the terms of that formal sum except the one that you saw.)
09:39:47 <MoxJet> I'm trying out vacuum-cairo, but I get  hFlush: resource vanished (Brutet rr)
09:39:47 <idnar> +(\d+) doesn't mean anything on its own, so I'm not sure what you meant about that
09:39:59 <MoxJet> (Broken Pipe) from it, anyone else getting this problem?
09:40:30 <Cale> (however, it seems that nobody cares ;)
09:40:41 <idnar> Cale: just kill all the witnessess
09:42:50 <paczesiowa> augustss: I think that your C dsl has call-by-name semantics:)
09:48:22 <ehird> ghc's brain just exploded; yay
09:49:52 <paczesiowa> augustss: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3105
09:50:50 <lilac> Cale: how do we know that entanglement happens (that is, that the outcome isn't just arbitrarily decided up-front)?
09:51:30 <Badger> quicksilver: I don't know what I mean by condiitonal either.
09:51:33 <Badger> meant optional.
09:51:39 <Badger> idnar: thankyou
09:51:52 <Cale> lilac: There are experiments (or at least thought experiments) which one can do that distinguish things, supposing you don't want information to travel faster than light.
09:52:40 <lilac> Cale: interesting. what words should i be googling for to find such things?
09:52:57 <Cale> I can get you an interesting video lecture...
09:54:05 <Cale> hmm
09:54:08 <bastl> hi. is there a way to save the current ghci session/history into a file?
09:54:24 <Cale> http://video.google.com/videoplay?docid=-4674461198051839963 -- it used to be here :/
09:56:16 <Cale> Hmm, well, anyway, I think I can recall the names.
09:57:09 <dons> ?seen mmorrow
09:57:10 <lambdabot> I saw mmorrow leaving #yi, #ghc and #haskell 23h 32m 46s ago, and .
09:57:18 <dons> bastl: doesn't it save it into a file by default? .history?
09:57:26 <Cale> http://en.wikipedia.org/wiki/Bell's_theorem
09:57:51 <ddarius> Jaynes on Bell: http://bayes.wustl.edu/etj/articles/cmystery.pdf
09:58:00 <Cale> There was a nicer version of Bell's theorem which was a bit clearer though
09:58:10 <Cale> and didn't involve the probabilistic aspects
09:58:29 <Cale> (but was essentially the same thing)
09:59:05 <Cale> I think it may have been due to Bohm.
09:59:55 <bastl> dons: i expected that and hoped someone here could tell me that file. ".history" doesnt exist in my home-dir
10:00:41 <lilac> Cale, ddarius: thanks!
10:05:12 <maltem> bastl: For me it's
10:05:20 <maltem> ~/.ghc/ghci_history
10:07:23 <kadaver> Couldn't match expected type `FilePath'
10:07:23 <kadaver>            against inferred type `B.ByteString'
10:07:29 <kadaver> ot in scope: data constructor `FilePath'
10:07:32 <kadaver> ok uh?
10:07:33 <bastl> maltem: yes just found it. thanks
10:07:44 <EvilTerran> FilePath = String, iirc
10:07:53 <EvilTerran> ?src FilePath
10:07:54 <lambdabot> type FilePath = String
10:10:27 <kadaver> wait i think i need to pack thr arg
10:11:42 <zenzike> to those who tried to help earlier, it turns out that i needed to enable FlexibleInstances for the types to work out well
10:12:03 <Cale> http://media.physics.harvard.edu/video/index.php?id=SidneyColeman_QMIYF.flv -- aha, here it is!
10:12:13 <Cale> (lilac and others)
10:13:46 <kadaver> isnt ByteString and String interchangeable(and change to B.readFile etc) ?
10:14:17 <EvilTerran> no, they're not interchangable, they're fundamentally different types
10:14:43 <dons> bastl: .ghc/ghci_history
10:16:07 <kadaver> i didnt mean interchangeable but that all operations ont hem are
10:16:17 <EvilTerran> kadaver, note that, say, "B.writeFile :: FilePath -> ByteString -> IO ()"; FilePath = String, so B.writeFile expects a String as its first parameter (the file path) and a ByteString as the second (the file contents)
10:16:29 <EvilTerran> yeah, they support much the same operations
10:19:17 <kadaver> Expected type: M.Map [a] Int
10:19:17 <kadaver>       Inferred type: M.Map B.ByteString Int
10:19:36 <kadaver> when chaning type from String to ByteString, si there some obvious reason for that+
10:22:31 <dons> kadaver: they're different types
10:23:41 <EvilTerran> kadaver, are you trying to pattern-match a ByteString as if it were a list somewhere?
10:23:53 <EvilTerran> or using a prelude list manipulation function instead of the B. version?
10:26:36 <Ornedan> I'm getting some weird behaviour from haskell-mode with ghc 6.10.1: It seems to echo the commands given, followed by ^J. Has anyone else encountered this? Also, what character is ^J?
10:26:52 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3107#a3107 <- code+error
10:27:41 <EvilTerran> ?type length -- kadaver
10:27:42 <lambdabot> forall a. [a] -> Int
10:28:03 <kadaver> ah i see
10:28:20 <lilac> Cale++
10:28:27 <EvilTerran> you probably want B.length on line 16
10:28:33 <kadaver> yes i changed
10:29:13 <bremner> Ornedan: try (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
10:29:24 <paczesiowa> Ornedan: some people talked about it yesterday, check logs from yesterday
10:29:36 * bremner = some people :-)
10:29:41 <kadaver> hmm, (words string) and (B.split ' ' string) seem,s to give different results
10:30:07 <kadaver> also, C processes faster than haskell does(hard to tell difference between ByteString and String but the C code is instant.
10:30:15 <kadaver> but yeah that might not be the IO duh
10:30:36 <EvilTerran> kadaver, are you compiling with -O?
10:30:55 <kadaver> (hrm, ghci)
10:30:58 * kadaver is an idiot
10:31:59 <Ornedan> bremner: Thanks, worked
10:32:58 <tromp_> >()
10:33:05 <tromp_> > ()
10:33:07 <lambdabot>   ()
10:33:09 <bremner> can we add that .emacs snippet to one of the bot's reperatoires?
10:35:45 <Cale> @help remember
10:35:46 <lambdabot> quote <nick>
10:35:46 <lambdabot> remember <nick> <quote>
10:35:46 <lambdabot> Quote somebody, a random person, or save a memorable quote
10:35:58 <maltem> Since I got annoyed by too many mysterious type and data constructor names in the GHC source, I've started a list: http://www.haskell.org/haskellwiki/GHC/List_of_abbreviations
10:36:14 <lilac> Ornedan: fyi, ^J is newline (^X is X - 64, and 'A' is 65, so ^J = 10 = newline)
10:40:44 <bremner> @remember emacs^J Problems with emacs and ghci6.10.1? try  (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
10:40:45 <lambdabot> Nice!
10:43:49 <paczesiowa> > ord 'M'
10:43:52 <lambdabot>   77
10:44:02 <paczesiowa> > chr $ ord 'M' - 64
10:44:04 <lambdabot>   '\r'
10:44:08 <kadaver> ok it is fast
10:44:12 <kadaver> but C is immediate
10:44:26 <kadaver> but that is prob not the IO but the program itself
10:46:15 <Twey> 18:31:13 < EvilTerran> kadaver, are you compiling with -O?
10:46:22 <Twey> kadaver: Try -O3 or so
10:47:33 <kadaver> -O3 ?
10:47:35 <MyCatVerbs> Twey: are you talking C or Haskell? -O3 is fine for C, but AFAIK the situation is still that one should only pass -O2 to GHC.
10:47:45 <Twey> Really?  Why's that?
10:48:29 <kadaver> -O3 -> types are off
10:48:35 <kadaver> no
10:48:45 <Twey> Types get stripped at compile-time anyway
10:48:52 <Twey> (they're maintained in the .hi)
10:48:54 <MyCatVerbs> Twey: bitrot. All the compiler hackers use -O2, so it turns out that passing -O3 would for at least a while actually turn on *fewer* optimisations just because it wasn't being maintained. I'm not sure what the situation is now, I think that behavoir might have been nipped in the bud.
10:49:06 <Twey> Oh right
10:49:09 <MyCatVerbs> s/compiler/GHC/ (in this specific case)
10:49:38 <dons> -O3 is -O2
10:49:41 <ppavelV6> does ghc become The Compiler?
10:50:21 <MyCatVerbs> dons: yeah, in 6.8 and up, right? But didn't 6.6 and earlier have badly-behaved -O3?
10:50:42 <Twey> ppavelV6: For most purposes.
10:51:07 <ehird> I am become GHC, compiler of Haskells.
10:51:19 <Twey> Hahahaha
10:51:27 <MyCatVerbs> ppavelV6: at the moment. It's assumed that JHC, YHC and NHC users know what they're doing well enough that all of their conversations will be in #-in-depth, instead of here. ;P
10:51:34 <ppavelV6> Twey: it's a bit scary. not that ghc is bad, but...
10:51:41 <kadaver> according to my spamfilter crime&punishment is spam
10:51:49 <ehird> ppavelV6: what's scary
10:51:50 <ppavelV6> MyCatVerbs:  :)
10:51:56 <ehird> plenty of other compilers are being worked on, research-wise
10:52:02 <lament> kadaver: that was my impression from reading it
10:52:03 <ehird> it's just that ghc is the option for getting stuff done (tm)
10:52:12 <ppavelV6> ehird: the scary thing is the language defined de-facto
10:52:16 <lament> kadaver: i was wondering what's the deal with all the penis enlargement and fake lotteries
10:52:40 <ehird> i disagree, ppavelV6. See Haskell Prime: widely used ghc extensions are supported by hugs, iirc, and Haskell' is standardizing some  ghc exts I believe
10:52:41 <ppavelV6> ehird: agreed.
10:53:01 <ppavelV6> btw what are the dates for haskell'
10:53:03 <ppavelV6> ?
10:53:14 <ehird> When It's Done, I believe.
10:53:28 <ppavelV6> ehird: :)
10:53:35 <jrx_> yesterday I was trying to compile my simple app with jhc and after an hour I gave up
10:54:03 <ehird> why does every haskell compiler end with hc it's so cliche.
10:54:12 <ppavelV6> i came from the Smalltalk background where VW is The Implementation. great one. But single
10:54:13 <Gracenotes> @hoogle Done
10:54:13 <lambdabot> Control.Parallel.Strategies type Done = ()
10:54:15 * Twey laughs.
10:54:15 <Gracenotes> thar. :x
10:54:29 <ppavelV6> :)))))
10:54:29 <Twey> We should create one called the Haskell Awesome Compiler Kit
10:55:15 <ehird> ppavelV6: Only in commercial uses.
10:55:18 <bremner> Function Universal Compiler Kit
10:55:22 <ehird> Squeak is the Thing for open source Smalltalk.
10:55:23 <ikke> fuck
10:55:45 <ehird> Twey: lambda compiler collection
10:55:50 <paczesiowa> or X Is Not Haskell Compiler
10:55:59 <Twey> XINHC?
10:56:01 <ray> that ends with hc
10:56:02 <ppavelV6> ehird: Yeah.Many (most?) interesting things happen in squeak... But when you have to Get Things Done.. :))
10:56:07 <Twey> That's not a snazzy acronym
10:56:18 <lament> probably that's why nobody uses smalltalk
10:56:27 <kadaver> lament: i rather liked it
10:56:27 <ppavelV6> VW is opensource btw
10:56:37 <ehird> Anahc: not a haskell compiler
10:56:47 <lament> ppavelV6: you mean "abandoned by its vendor"?
10:56:56 <ppavelV6> lament: ?
10:56:58 <ehird> VW is open source? What?
10:57:09 <ehird> Since when?
10:57:14 <ppavelV6> ehird: what part of the source do you miss?
10:57:23 <ehird> I was not aware it was open sourc ein any fashion.
10:57:42 <ehird> Are you *sure* it's DFSG open source?
10:58:11 <ppavelV6> ehird: you get the whole image by default, you get VM source if you buy commercial license OR if you sign NDA
10:58:22 <ehird> that's not open source!
10:58:30 <lament> that's the opposite of open source
10:58:32 <ppavelV6> ehird: so what's open source?
10:58:44 <ppavelV6> is the source closed?
10:58:46 <ehird> ppavelV6: licenses meeting the OSI & DFSG definitions
10:58:59 <ppavelV6> ehird: ok :)
10:59:02 <lament> ppavelV6: if you need to sign NDA, how is that "open" in any way?
10:59:18 <lament> that's pretty much the opposite...
10:59:23 <ppavelV6> lament: anybody can access the source
10:59:29 <ehird> >_<
10:59:36 <ehird> that's not what open source means
10:59:38 <ppavelV6> open source /= free
10:59:46 <lament> ppavelV6: NDA means closed
10:59:59 <vixey> ppavelV6: anybody can access the source /= open source
11:00:08 <lament> not anybody can access the source, only those who sign the NDA
11:00:08 * ppavelV6 disagreed, but not prepared for the flame
11:00:22 <ehird> it's not a subjective thing
11:00:22 <Twey> I think that's untrue, actually, vixey
11:00:41 <ehird> open source is a set of objective, solid requirements to a degree, visualworks fails them
11:00:43 <Twey> IIRC, open-source just means that the source is accessible
11:00:47 <ppavelV6> lament: people in Uganda probably don't have access to the BSD sources :)
11:00:54 <ppavelV6> at least some of them
11:00:56 <Twey> Free means that you can do what you like with them once you've got them
11:00:59 <lament> ppavelV6: legally, everybody has access to BSD sources
11:01:03 <ehird> Twey: No no no
11:01:05 <ehird> completely wrong
11:01:09 <ehird> the two terms are identical in practice
11:01:10 <lament> ppavelV6: but legally, nobody has access to VW source unless they sign the NDA
11:01:10 <ppavelV6> maybe
11:01:12 <Twey> Really?  Oh
11:01:23 <ehird> Twey: http://www.opensource.org/docs/osd
11:01:25 <lament> ppavelV6: "open" in "open source" refers to the legal aspect
11:01:29 <ehird> "Open source doesn't just mean access to the source code. The distribution terms of open-source software must comply with the following criteria:  "
11:01:34 <ehird> "1. Free Redistribution "
11:01:34 <idnar> I still dislike the term "open source", though
11:01:34 <ehird> Bam.
11:01:39 <ppavelV6> lament: nobody has access to BSD sources unless they signed ISP agreement :)
11:01:40 <Twey> Oho
11:01:42 <idnar> although I hate "FLOSS" or "FOSS" even more
11:01:50 <Twey> Hehe
11:01:50 <lament> ppavelV6: you're being silly for no reason.
11:01:51 <Twey> Flossy
11:01:54 <bavardage> ppavelV6: unless they phone someone and they get sent it on cd
11:01:54 <ehird> "The program must include source code, and must allow distribution in source code as well as compiled form. Where some form of a product is not distributed with source code, there must be a well-publicized means of obtaining the source code for no more than a reasonable reproduction cost preferably, downloading via the Internet without charge. "
11:01:59 <ppavelV6> lament sorry for that
11:02:00 <bremner> people who don't like terms of art or jargon should avoid the word "bug"
11:02:01 <Twey> ppavelV6: That's not true
11:02:04 <ehird> ppavelV6: it's very clear that VW doesn't meet those
11:02:11 <ppavelV6> ok guys.
11:02:12 <Twey> They could, e.g., have a friend post it on a disk.
11:02:18 <ppavelV6> i will agree with you.
11:02:31 <bavardage> best basic monad tutorial for a fairly newbish haskeller?
11:02:32 <ppavelV6> :)
11:02:43 <Twey> bavardage: Cale's 'Monads as Computation'
11:02:52 <ehird> bavardage: "Monads are like arguments about what open source means in #haskell"
11:02:54 <ehird> ;-)
11:03:01 <Twey> Hahahaha
11:03:13 <Twey> Yeah
11:03:19 <ppavelV6> "More monad tutorials are there, more people will conclude monads must be hard, more people who get monads write new tutorials" :)
11:03:19 <bavardage> riight :P
11:03:23 <bavardage> :D
11:03:30 <bavardage> Twey: ty
11:03:52 * ppavelV6 afraid to use o#@# in #haskell
11:03:55 <bavardage> Twey: http://www.haskell.org/haskellwiki/Monads_as_computation this one?
11:04:01 <Twey> bavardage: Yes
11:04:07 <bavardage> kk ty :D
11:04:08 <Twey> That's the one that triggered it for me
11:04:21 <Twey> The one in RWH is good too, but much more long-winded
11:04:30 <Twey> Maybe try it if you don't have any luck with that one
11:04:30 <Gracenotes> Monads are actually hunter-gatherer communities that tend to resist industrialization and live off of the land.
11:04:45 <ppavelV6> Monad should not have fail :-P
11:04:52 <lament> monads are like sections of a tube through which toxic waste flows. You can join the sections to make a longer tube.
11:04:54 <Twey> (on the other hand, maybe the counterpart, 'Monads as Containers', will do it for you)
11:05:04 <ppavelV6> lament:  %)
11:05:13 <Twey> (I never had much luck with the container metaphor)
11:05:23 <augustss> paczesiowa: Yes, it has. :)
11:05:44 <lament> sometimes a spaceman gets stuck in a tube and dies a horrible death in the toxic waste.
11:06:08 <Twey> So we have to take it out of its space-suit to give it an autopsy.
11:06:52 <paczesiowa> augustss: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3108 if you want to add it to examples:) (that cbn was the only thing that broke qsort)
11:07:08 <ppavelV6> may i ask?
11:07:13 * ppavelV6 afraid
11:07:59 <Twey> But we shouldn't touch the toxic waste, and the specimen might mysteriously come alive and gain superpowers, so we send in lots of little robots to do the work for us.
11:08:49 <monochrom> Why is I/O toxic? It is not. Why use toxic waste to describe I/O?
11:09:10 <osfameron> the toxic waste thing confuses me more than anything
11:09:12 * ppavelV6 goes doing his OS homework
11:09:14 <lament> monochrom: you can't allow it to contaminate the rest of your program, which is all oranges
11:09:29 * Twey rolls in the aisles.
11:09:31 <lament> that's why it has to be in a tube...
11:09:40 <lament> a series of tubes rather
11:09:56 <ppavelV6> the series of tubes are arrows...
11:10:03 * ppavelV6 hides again
11:10:13 <monochrom> You are begging the question. You assume it's contamination, which means you still assume it's toxic. Why is it contamination and toxic?
11:10:31 <jmcarthur> so many metaphors when the types and laws, plus some examples, should be enough...
11:11:03 <Gracenotes> in a sense, you do have to make an 'm a' into an 'a' to implement a monad, avoiding teh toxic.
11:11:10 <lament> monochrom: because the whole thing is a metaphor for how values in IO don't mix with pure values?
11:11:19 <Twey> *cough*runState*cough*
11:11:21 <Gracenotes> althouh, m a -> a is a key operation in a comonad :\
11:11:24 <ppavelV6> what ticked for me: try to write your own IO. i know that io is special and not recommended to learn monads
11:12:17 <monochrom> And I have the answer for you. It is because of a perverse, fetish obsession with pure functions that considers everything else toxic. Yes, even the list monad is toxic.
11:12:55 <lament> i think the toxic waste metaphor is meant for IO, not monads in general
11:12:55 <monochrom> If you want to promote separating two things, "separation of concerns" is more than strong enough. You don't need toxic.
11:13:11 <Twey> monochrom: Because monadic code doesn't look pretty?  :-P
11:13:17 <jmcarthur> toxic waste metaphor considered toxic
11:13:20 <Gracenotes> this face, the infection that poisons our love! :O
11:13:36 <monochrom> @remember jmcarthur toxic waste metaphor considered toxic
11:13:37 <lambdabot> I will remember.
11:14:07 <lament> the monads of the night...
11:14:25 <ppavelV6> where can i find lambdadot's dictionary for dummies?
11:14:27 <monochrom> I/O and most things in IO are not toxic. They are the purpose a program exists at all.
11:14:31 <jmcarthur> Twey, monadic code should look pretty unless you're doing it wrong...
11:14:31 <Twey> 'This is the monad of our discontent!'
11:14:40 <Twey> jmcarthur: It looks imperative
11:14:46 <Twey> Which makes me go 'urgh' :-P
11:14:48 <ppavelV6> monochrom:  who needs purposes anyway?
11:14:49 <jmcarthur> do notation looks imperative
11:14:56 <jmcarthur> so avoid do notation
11:15:04 <osfameron> huh?
11:15:05 <dolio> IO is more difficult to reason about.
11:15:05 <Twey> And do-notation is necessary for extended use of monads
11:15:12 <lament> monochrom: IO values are toxic because, allowed outside their tube, they would break referential transparency...
11:15:13 <jmcarthur> not it's not
11:15:16 <dolio> If you don't keep it contained, everything becomes more difficult to reason about.
11:15:22 <Twey> It is if you want it to remain readable
11:15:28 <jmcarthur> do notation is hack to appeal to imperative mindsets
11:15:31 <wunki> can I interrupt.. Which module to use to get a webpage (like Python Urllib)?
11:16:28 <lament> unsafePerformIO makes a hole in the pipe and toxic waste spills all over the program, making it impossible to reason about
11:17:09 <ppavelV6> you should have a license to use unsafePerormIO
11:17:12 <lament> so yes, there's definitely a fetish obssession, but it's with referential transparency, not with pure functions per se
11:17:39 <jmcarthur> Twey, at best, do notation is meant to be used only for monads that are _designed_ to be imperative, but most aren't
11:17:45 <Twey> ppavelV6: No, you should be writing a wrapper for non-Haskell code :-P
11:17:54 <kadaver> what does unsafeperformIO do? let you do sideeffects inside a pure function?
11:18:04 <monochrom> Breaking referential transparency is not toxic. It's just harder to reason about. We formal methods people actually know how to do it and it is not more difficult than for example Bird's Algebra of Programming which is just for pure functions.
11:18:12 <ppavelV6> kadaver: generally yes
11:18:13 <Twey> kadaver: It has type IO a -> a
11:18:29 <ppavelV6> :t unsafePerformIO
11:18:29 <kadaver> ah
11:18:30 <lambdabot> Not in scope: `unsafePerformIO'
11:18:41 <ppavelV6> and by the reason )
11:18:44 <monochrom> And above all it is not waste either.
11:18:45 <jmcarthur> @hoogle unsafePerformIO
11:18:46 <lambdabot> Foreign unsafePerformIO :: IO a -> a
11:18:46 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
11:19:05 <ppavelV6> jmcarthur: you just spread dangerous knowledge.
11:19:34 <ppavelV6> that better remain hidden and guarded :)
11:19:49 <Twey> We prefer to hide it in plain sight
11:20:04 <Gracenotes> Oh no! Every time you use >>= you're using unsafePerformIO!
11:20:10 * Twey laughs.
11:20:21 <Gracenotes> (although the type system requires that you make an IO b from it)
11:20:47 <bavardage> why can't you just pattern match things out of monads?
11:20:55 <bavardage> this whole nuclear waste thing YOU CANNOT LET IT OUT
11:21:05 <jmcarthur> bavardage, for some monads you can
11:21:05 <vixey> bavardage: You can do that for some monads
11:21:10 <bavardage> riight
11:21:14 <jmcarthur> bavardage, not for IO
11:21:14 <dolio> I'm pretty sure (>>=) doesn't use unsafePerformIO.
11:21:16 <Twey> bavardage: You can by default
11:21:16 <bavardage> what determines whether you can?
11:21:21 <bavardage> oh kk
11:21:22 <Gracenotes> dolio: well, not directly
11:21:26 <jmcarthur> bavardage, whether its constructors are exported
11:21:27 <Twey> Whether the type exports its constructor(s)
11:21:31 <bavardage> oh kk
11:21:38 <ppavelV6> >>= doesn't use unsaferPerformSomething
11:21:41 <bavardage> monads are a little clearer now I guess :P
11:21:45 <dolio> The latter feeds some global RealWorld into the action in question.
11:21:46 <bavardage> still don't quite 'get' them
11:21:46 <Twey> You can pattern-match on Maybe, for example
11:21:47 <vixey> >>= is opaque
11:21:54 <dolio> Or something like that.
11:21:56 <Gracenotes> however, it does 'unsafely' give you an a from an IO a
11:22:00 <ppavelV6> vixey: only if you made it so
11:22:07 <Gracenotes> requiring that you also make that into an IO action
11:22:09 <vixey> ppavelV6: talking about IO
11:22:09 <ppavelV6> @src (>>=)
11:22:10 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:22:15 <ppavelV6> vixey: oh.
11:22:17 <lament> >>= in the case of IO is essentially the same as :, isn't it?
11:22:18 <Twey> ppavelV6: It depends on the monad
11:22:31 <Twey> lament: Something like that
11:22:32 <ppavelV6> Twey: right
11:22:35 <dolio> @src IO (>>=)
11:22:35 <lambdabot> m >>= k     = bindIO m k
11:22:42 <Gracenotes> lament:  : in what sense?
11:22:43 <vixey> that's funny
11:22:49 <Twey> @src bindIO
11:22:49 <lambdabot> bindIO (IO m) k = IO ( \ s ->
11:22:49 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
11:22:50 <ppavelV6> there's nothing wrong with (>>=) per se
11:23:06 <mib_qcya7e0d> Good day, can I ask questions about happstack here?
11:23:12 <Twey> Why is that a case and not a let?
11:23:17 <jmcarthur> mib_qcya7e0d, i recommend #happs
11:23:22 <Gracenotes> Twey: ordering?
11:23:31 <lament> Gracenotes: in the sense of joining two things into a list structure without "doing" anything to them
11:23:32 <mib_qcya7e0d> Thanks ... I will try that.
11:23:36 <Gracenotes> IO isn't lazy, that would be against-ish-point
11:23:40 <Twey> Gracenotes: ?
11:23:42 <Twey> Ah, yes
11:23:50 <Twey> case is stricter.
11:24:04 <dolio> Using 'let' with unboxed tuples is weird anyway.
11:25:04 <dolio> 'let (# a, b #) = t in ...' turns into something like 'let (a, b) = case t of (# a', b' #) -> (a, b) in ...'
11:25:25 <dolio> Oops, that last a and b should have primes of course.
11:25:32 <Gracenotes> so, so that's what they are
11:25:37 <Gracenotes> @hoogle (#
11:25:37 <lambdabot> Parse error:
11:25:38 <lambdabot>   --count=20 (#
11:25:38 <lambdabot>                ^
11:25:44 <kadaver> is there a getopt module/function for haskell?
11:25:52 <Gracenotes> getArgs?
11:25:55 * ppavelV6 fails to follow the channel today - lots of traffic
11:25:56 <kadaver> yes
11:26:10 <kadaver> but getopt is a parser for commandlineargs
11:26:24 <Gracenotes> we have a parser for command line arguments somewhere
11:26:56 <ppavelV6> btw will somebody point me to introductory papers on ghc's GC? just a level above the sources
11:27:18 <Gracenotes> ...hm... somewhere >:[
11:27:30 <Gracenotes> here you go: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parseargs
11:27:47 <Twey> There's that, but it's terribly complex
11:27:56 <Twey> There's also System.Console.GetOpt
11:27:59 <Gracenotes> hm. Don't see why it can't use something like Data.Map
11:28:01 * ppavelV6 googles
11:29:11 <ehird> What's the unicode symbol for ::?
11:29:46 <monochrom> ∷ U+2237
11:29:59 <Gracenotes> as in cons or type-of?
11:29:59 <MyCatVerbs> ppavelV6: SimonMar gave a good talk about the new parallel collector at AngloHaskell 2008. I think he explained at least part of the anatomy of the single-threaded collector during that talk, too.
11:30:37 <ppavelV6> MyCatVerbs:  ok, i'll try to find this
11:30:40 <ehird> Gracenotes: type-of
11:30:45 <ehird> thanks monochrom
11:30:45 <Gracenotes> ∷
11:30:51 <Gracenotes> U+2237   PROPORTION
11:30:56 <MyCatVerbs> ppavelV6: http://www.haskell.org/haskellwiki/AngloHaskell/2008 leads to http://www.wellquite.org/anglohaskell2008/ from which you will find Simon Marlowe's slides in PowerPoint, and an Ogg Vorbis recording of his talk.
11:31:02 <Gracenotes> huh.
11:31:05 * ppavelV6 looked at ATS recently
11:31:13 <vixey> what do you think about ATS?
11:31:18 <MyCatVerbs> Incidentally, matthew-_++
11:31:19 <vixey> do you write anything with it?
11:31:21 <ppavelV6> MyCatVerbs:  thanks a lot
11:31:30 <ppavelV6> vixey: very nice. very chatty
11:31:34 <MyCatVerbs> ppavelV6: you're welcome. Happy hacking. ^^
11:31:47 <ppavelV6> vixey: having tools to prove termination is nice
11:32:06 <ppavelV6> vixey: will look closer one day
11:32:06 <ehird> compose ∷ (α → β) → (γ → α) → γ → β
11:32:07 <ehird> compose α β = λγ → α (β γ)
11:32:10 <ehird> ↑ yum
11:32:28 <vixey> yes
11:32:32 <vixey> agreed about termination
11:33:04 <ppavelV6> dependent typed seem very interesting anyway
11:33:23 <vixey> yeah
11:33:24 * ppavelV6 types
11:33:48 <bavardage> so, what kinda thing does anyone recommend I attempt to code using monads
11:34:10 <ppavelV6> vixey: can probably bridge formal reasoning and programming better than Haskell
11:35:25 <ppavelV6> bavardage:  there was something at wikibooks. give me a minute
11:35:30 <zenzike> hey guys, is there somewhere where  I can find a list of valid haskell function names/symbols?
11:35:50 <paczesiowa> zenzike: haskell report
11:36:06 <zenzike> thanks paczesiowa
11:36:23 <ppavelV6> bavardage: are you still here?
11:36:39 <bavardage> ppavelV6: indeed
11:36:43 <ppavelV6> http://www.google.com/search?client=safari&rls=en-us&q=monads+haskell&ie=UTF-8&oe=UTF-8 top results are all good sources. you have to wait while something triggers you
11:36:50 <bavardage> oh kk ty
11:36:52 <bavardage> I'll keep reading
11:36:53 * ppavelV6 read and read and think and read again
11:36:59 <ppavelV6> it's a matter of time
11:37:05 <bavardage> yup
11:37:15 <ppavelV6> probably some good mentorship can help
11:37:18 <bavardage> I'm still fairly newbish when it comes to haskell
11:37:27 <bavardage> and also, I don't have anything definite I wanna program in it
11:37:36 <bavardage> which is how I kinda learnt other languages
11:37:40 <ppavelV6> bavardage:  as i am
11:38:11 * ppavelV6 tries to create himself a job with haskell
11:38:42 <vixey> ppavelV6: it seems really hard to program with (totality & dependent types) at the moment,  a few tools have been figured out (like pattern matching) that help.. but I think we have to find out so much more .
11:39:05 <vixey> ppavelV6: well when I say program I mean with correctness proofs also
11:39:21 <bavardage> maybe that's another fun part
11:39:26 <bavardage> haskell seems very comp-sciency
11:39:32 <bavardage> and comp-science is all above my head
11:39:57 <augustss> paczesiowa: thanks!  I might fix the cbn thing.  and introduce pointers
11:41:24 <ehird> "19:38 ppavelV6 tries to create himself a job with haskell "
11:41:25 <ppavelV6> vixey: agreed
11:41:34 <ehird> ↑ Make you a Haskell job for great good?
11:41:46 <ppavelV6> ehird: I'm still in progress
11:42:13 <ehird> was a reference to http://learnyouahaskell.com/ ☺ (can you tell I'm testing my Unicode shortcuts…?)
11:42:18 <paczesiowa> augustss: how would you fix cbn? you'd have to use special funcall operator/function
11:42:20 <ppavelV6> ehird: I'm trying to find a niche I can use haskell with great success
11:42:52 <ppavelV6> ehird: nice shortcuts. Try two more times and I'll ask you for a tutorial :)
11:43:16 <ppavelV6> WOW
11:43:36 <ppavelV6> whom to honor for the site?
11:43:37 <ehird> ppavelV6: ¹²³⁴⁵⁶⁷⁸⁹⁰☺☹‽⌃⌥⌘⇧λ→←↑↓↖↗↙↘
11:43:46 <wunki> haha, nice site :)
11:43:58 <ehird> ppavelV6: I’d give you subscripted numbers and ☻ but those keybindings aren’t working. Sorry to disappoint.
11:44:02 <ppavelV6> ehird: you did it :) where is a tutorial? :)
11:44:30 * ppavelV6 dreams about tex support on irc
11:44:36 <ehird> Well, this is rather offtopic, so this is the last I’ll say… for OS X: http://pastie.org/431713.txt goes in ~/Library/KeyBindings/DefaultKeyBinding.dict.
11:44:41 <bavardage> ppavelV6: would be nice, yeah
11:44:42 <ehird> For other OS’s, I have no idea.
11:44:45 <ehird> ppavelV6: ++
11:45:01 <ehird> Ubiquitous TeX!
11:45:05 * ppavelV6 OSX fan
11:45:38 <ppavelV6> TeX is awful but nothing seem to beat it
11:46:16 <andyou> MATHML!
11:46:33 <ppavelV6> andyou: did you really tried to write MathML?
11:46:34 <ehird> andyou: AAAAH! Why do you plague us so?!
11:46:38 <ehird> Er, I mean, ‽
11:46:56 <andyou> ppavelV6: Just pulling your leg.
11:47:03 * ppavelV6 pulled
11:47:17 <ehird> andyou: *phew*
11:47:35 <paczesiowa> augustss: and I still don't know why you want to compare those expressions to special booleans, C uses ints for true/false, and it would make conditionals easier to type
11:47:47 * ppavelV6 gives a talk to his 8 months old daughter about virtues of FP
11:47:58 <jmcarthur> haha
11:48:12 <ppavelV6> that seem to make her sleep
11:48:32 <bavardage> wait, I can just do 'putStr "...."'?
11:48:45 <bavardage> w/o doing lots of crazy monad things?
11:48:49 <monochrom> Why do you people have children? Shouldn't you all be, like, 18yo?
11:49:03 <ehird> bavardage: That is crazy monad things. :-)
11:49:14 <vixey> I don't want TeX (turing complete) in IRC
11:49:28 <ehird> vixey: just don’t allow macros
11:49:36 <ehird> problem solved
11:49:36 <ppavelV6> monochrom:  yeah :( my fault :(
11:49:42 <vixey> why not some kind of linear-TeX which always terminates in O(n) on simple-TeX which is polynomial ime
11:49:47 <BMeph> monochrom: Why do you think 18yo's wouldn't have 2- or 3yo children? Besdides that they ought not to have such? ;)
11:50:10 <bavardage> monochrom: dw, I have no children.
11:50:15 <bavardage> YUCK
11:50:19 <vixey> lol
11:50:24 <ehird> "Eww, babies! YUCK"
11:50:25 <ppavelV6> bavardage: good for you
11:50:29 * BMeph once more promises to "lern2tiep"
11:50:30 <vixey> @remember <bavardage> monochrom: dw, I have no children. YUCK
11:50:31 <lambdabot> Okay.
11:50:40 <bavardage> :(
11:50:42 <ehird> monochrom: dw, I have no children. YUCK
11:50:42 <ehird> 19:50 lambdabot: Okay.
11:50:45 <ehird> er oops
11:50:50 <ehird> @remember bavardage monochrom: dw, I have no children. YUCK
11:50:50 <lambdabot> Good to know.
11:50:58 <ehird> vixey: FTFY
11:51:05 <bavardage> vixey: it would just be nice to be able to display formulas and such over irc
11:51:07 <ppavelV6> lambdabot, how about you? :))
11:51:15 <ehird> lamdabit
11:51:18 <ehird> *lambdabit
11:51:20 <vixey> yes
11:51:23 <ppavelV6> bavardage:  agreed
11:51:23 <nA1828KcFz9q> no need, read tex
11:51:30 <bavardage> nA1828KcFz9q: hehe
11:51:34 <paczesiowa> lambdabait
11:51:41 <ppavelV6> nA1828KcFz9q: 2D math is great
11:51:58 <nA1828KcFz9q> math comprehension is not something that is substantially increased with images in any case
11:52:07 <vixey> yes it is
11:52:24 * Philippa_ thinks someone's not done much category theory
11:52:33 <vixey> nA1...etc: our brains are wired differently
11:52:52 <ppavelV6> life comprehension is not something that is increased with images
11:52:58 * ppavelV6 goes learn lojba
11:52:58 <nA1828KcFz9q> Phil (incorrect)
11:53:01 <ppavelV6> lojban
11:53:23 <monochrom> There are a few people who can read TeX raw and cold. They generalize it to the rest of us.
11:53:35 <ppavelV6> :)
11:53:38 <Philippa_> I'd also thank you not to abbreviate my name like that. If I want my gender changed, I'll do it myself
11:53:40 <BMeph> What's the difference between a promise/future and a thunk?
11:53:49 <ppavelV6> may i stick to ams and LaTeX?
11:53:51 <bavardage> I always end up just doing pseudo-tex and ugly stuff over irc
11:54:21 <vixey> BMeph: I think a thunk is a promise
11:54:30 * jmcarthur is convincing a shocked coworker that he believes goto is all we need, no else, while, for, etc. and that we should standardize on this company-wide
11:54:36 <Philippa_> ppavelV6: LaTeX still offers you turing completeness, AIUI
11:54:37 <vixey> I don't really have much idea what a future is though
11:54:52 <ppavelV6> Philippa: :(
11:55:01 <vixey> jmcarthur: does he program in that way personally?
11:55:04 <ppavelV6> Philippa: just give me my nice formulas!
11:55:06 <vixey> wait..
11:55:10 <nA1828KcFz9q> the substantial amount of comprehension is done by the reader; the step between tex and images is comparably less significant
11:55:10 <Philippa_> yeah, IKWYM :-)
11:55:15 <vixey> jmcarthur: it's *you* that wants goto only?
11:55:28 <jmcarthur> vixey, it's a joke, but that is what i'm convincing him of
11:55:30 <monochrom> I think there is no difference between promise/future and thunk. I suppose some community uses the word "promise/future" because they emphasize that the way they use thunks is spawn new threads to evaluate the thunks. Of course we know it is not the only way to use thunks.
11:55:32 <jmcarthur> he's going to hate me
11:55:36 <vixey> lol
11:55:38 <vixey> what a odd joke
11:55:46 <jmcarthur> and next time he is about to inherit some code from me he is going to be afraid
11:55:48 <inimino> who needs any of this other fancy stuff anyway, it just slows down your code.
11:55:48 <nA1828KcFz9q> perhaps a few minutes will be shaved, in your reading of the intersection homology article on wikipedia, tex only
11:55:59 <ppavelV6> nA1828KcFz9q:  +100, but that's not the reason to not use cool looking typesetting :)
11:55:59 <Philippa_> nA1828KcFz9q: it's normally done, though, by rendering the TeX
11:56:17 <nA1828KcFz9q> ppavelV6, i do not follow
11:56:19 <Philippa_> either in your head or externally
11:56:34 <ppavelV6> nA1828KcFz9q: never mind
11:56:48 <nA1828KcFz9q> phil, only if you follow standard notations :-P
11:56:55 * BMeph actually giggled at jmcarthur abusing his coworker two days before it's "proper"
11:57:15 <Philippa_> nA1828KcFz9q: I asked you once. Be polite
11:57:29 <nA1828KcFz9q> phil, about what
11:57:44 <Philippa_> about abbreviating my name like that
11:57:56 <vixey> nA1828KcFz9q: you seem a bit confused...
11:57:59 <ppavelV6> just hit Tab :)
11:58:05 <monochrom> \Philippa
11:58:06 <nA1828KcFz9q> i am sorry Philippa_
11:58:07 <bavardage> maybe his client doesn't support it ;P
11:58:18 <jmcarthur> BMeph, "proper"?
11:58:37 <ppavelV6> any haskeller should have no problem writing his very own irc client
11:59:01 <Philippa_> I dunno, does accidentally losing the source part-way through count as a problem?
11:59:14 <MyCatVerbs> ppavelV6: a) "or her", or h(is|er), b) done that, kinda.
11:59:19 <BMeph> jmcarthur: As in, you should have this conversation two days from today, not today. Then it would be in the proper spirit. :)
11:59:23 <bavardage> hehe
11:59:24 <Zao> Philippa_: "source control" and "backups" are fun sentence fragments.
11:59:32 <bavardage> I guess an irc client would need monads?
11:59:33 <bavardage> :P
11:59:39 <ppavelV6> MyCatVerbs: pardon...
11:59:47 <bavardage> so so far, I've kinda realised that IO needs monads
11:59:49 <Philippa_> Zao: trust me, nothing is proof against a sufficient bout of stupidity :-) But yes
11:59:53 <bavardage> but how do you actually do anything with IO
11:59:59 <bavardage> since it seems all stuck in these nuclear pipes
12:00:01 <ppavelV6> bavardage: no doubt :)
12:00:06 <jmcarthur> BMeph, oh, are you assuming this guy is new? ;)
12:00:15 <MyCatVerbs> ppavelV6: I wrote a program for talking to IRC servers which simply transmitted lines vertabim for me. The principle feature I added over netcat was that it automated away responding to PING messages for me. :)
12:00:15 <monochrom> I write papers and thesis in LaTeX and I can tell you this. Three months after I finished a TeX file, I can look at the code and not see what's going on. I have to look at the PDF rendering.
12:00:19 <Philippa_> bavardage: by piping in and out of pure functions
12:00:29 <Philippa_> use the IO monad as the 'outer shell' of your program
12:00:34 <ppavelV6> MyCatVerbs: nice, keep it simple :)
12:00:38 <bavardage> rigth
12:00:44 <BMeph> jmcarthur: No, but I'm about to assume that you aren't thinking about what happens in two days...of are you Australian? :)
12:00:49 <bavardage> so I can't really use the io monad within other pure functions
12:00:52 <BMeph> *OR are you...
12:00:57 <jmcarthur> oh april fools :P
12:01:01 <Philippa_> for example, main = do in <- readFile "foo"; let out = f in; writeFile "bar" out where f = ...
12:01:05 <vixey> bavardage: no
12:01:08 <BMeph> jmcarthur: >;)
12:01:08 <jmcarthur> who says i'm not just building up?
12:01:13 <ppavelV6> bavardage: you're risking your soul doing so
12:01:16 <Philippa_> bavardage: that's the whole point
12:01:16 <MyCatVerbs> ppavelV6: more like, I vaguely enjoy talking RFC1459 for perverse reasons, but can never be bothered to attend to expend the energy to send PONG. :)
12:01:21 <vixey> bavardage:  You can build up IO things in a pure way, then use them from an IO block though
12:01:22 <jmcarthur> plus, he wouldn't believe me if it was april fools
12:01:27 <Philippa_> IO is inherently impure, so pure functions won't contain it
12:01:44 <ppavelV6> MyCatVerbs: just ask students to do the dirty work for you :)
12:01:52 <MyCatVerbs> ppavelV6: I *am* a student.
12:01:54 <BMeph> bavardage: Also, remember: "IO /= I/O". :)
12:01:59 <ppavelV6> MyCatVerbs:  :)))))
12:02:20 <ppavelV6> MyCatVerbs: ask your roommate :)
12:02:22 <MyCatVerbs> ppavelV6: hence I get my computer to do the dirty work for *me*. I'd be disappointed if I ever had a student who didn't. ;P
12:02:29 <bavardage> BMeph: what's the difference :o
12:02:49 * SubStack referential transparencies up the place
12:03:05 <ppavelV6> MyCatVerbs: very true. And the single piece of wisdom every IT person should have. Let computers do the work, let people think
12:03:19 <MyCatVerbs> ppavelV6: that would work, except for the bit where my roommate's first step would be to ask me for a link to the documentation for Python's networking modules.
12:03:22 <bavardage> I need to get some students to do my dirty work
12:03:30 <SubStack> let computers do the work so computers can think!
12:03:39 <BMeph> bavardage: Some I/O is "doable" in a non-IO setting. Some IO uses have nthing to do with I/O.
12:03:48 <BMeph> *nOthing
12:03:48 <bavardage> riiiiight
12:03:52 <ppavelV6> bavardage: it seems like there's  a constant lack of students :)
12:04:02 * SubStack is one of those
12:04:06 <MyCatVerbs> bavardage: problem is, most students are just dirty, and work doesn't come into it at all.
12:04:10 * ppavelV6 hopes computers don't listen here
12:04:18 <bavardage> ppavelV6: well I have no students :(
12:04:26 * SubStack goes off to his student job to write some haskell programs
12:04:27 <bavardage> but then again, I am no teacher, so maybe that's just one of those things
12:04:57 <guenni> hi, anybody here been using zipper data structures?
12:05:00 <ppavelV6> bavardage: i'm not a professor too :) just (ab)used the interns in the past :)
12:05:05 <bavardage> hehe
12:05:24 <bavardage> bleh screw monads for tonight, I'm gonna code something to numerically integrate things
12:06:33 <ppavelV6> bavardage: do you need it in haskell? probably matlab or mathematica can do the job if you have to integrate not to code
12:06:46 <bavardage> ppavelV6: no just for lols
12:06:51 <bavardage> just trapezium rule or so
12:06:52 <ppavelV6> i see :)
12:06:57 <bavardage> some idea that I have
12:07:05 <bavardage> is to recode what my calculator can do, in haskell
12:07:21 <MyCatVerbs> Sounds like a fine and entertaining plan.
12:07:25 <ppavelV6> that's really great
12:07:34 <ppavelV6> MyCatVerbs: no sarcasm please
12:07:49 <bavardage> haha
12:07:53 <bavardage> dw
12:07:58 <ppavelV6> cya
12:08:04 <bavardage> I realise it's not the most exciting thing since cheese
12:08:05 <bavardage> but w/e
12:08:08 <bavardage> ppavelV6: o/ cya
12:08:19 <bavardage> I have no other inspiration :D
12:09:25 <MyCatVerbs> ppavelV6: I do not ever engage in sarcasm in here. It never leads to productive discussions. #-blah, and elsewhere on the intertubes, sure, but not in places where people are trying to get things done.
12:09:30 * EvilTerran is a big proponent of the "code something random (that's no doubt been done better than I will a thousand times already) for my own amusement" school of learning programming
12:09:36 <Alpounet_> is Haskell suitable for Image/Video analysis ?
12:09:48 <EvilTerran> ?faq what Alpounet_ said
12:09:48 <lambdabot> The answer is: Yes! Haskell can do that.
12:09:59 <monochrom> That is a long school name.
12:10:01 <Alpounet_> I mean, are there already libraries for such things ?
12:10:10 <Alpounet_> (I knew about FAQ)
12:10:40 <EvilTerran> have you looked through hackage?
12:10:41 <ppavelV6> depends on whom you ask and what you really need
12:11:46 <ppavelV6> Alpounet_: if you're prepared to do some heavy optimization and drop to C or assembler occasionally it's no less suited than any other language (probably much better)
12:12:12 <ppavelV6> Alpounet_:  sorry, missed the piece about libraries
12:12:46 * ppavelV6 remembers the last time he tried to sell haskell and got a refuse: "No way. Requires thinking. Not suitable for programmers"
12:13:07 <matthew-_> right, if you're doing a parser, and you know one char is '\\' and the next char is 'n', how do you go from there to '\n' ?
12:15:01 <___> if parsec: char '\\' >> char 'n' >> return '\n'
12:15:44 * ppavelV6 recalls he promised himself to play with attoparsec
12:15:44 <matthew-_> yes, and for when the n isn't known?
12:16:01 <matthew-_> hmm, actually, this is quite painful, there's no choice but to special case
12:16:18 <Botje> what do you mean not known?
12:17:08 <matthew-_> n is any arbitrary char
12:17:52 <Botje> but you have some special cases, surely?
12:17:54 <ppavelV6> MyCatVerbs: that was intended as  a joke about sarcasm :) sorry if it sound offensive or something
12:17:57 <matthew-_> right, but you can't generically deal with \n \r \t \a etc
12:17:58 <EvilTerran> indeed not
12:17:59 <matthew-_> becasue, say, \" is different
12:18:02 <EvilTerran> seeing as they're fundamentally special cases
12:18:10 <matthew-_> it would appear so ;)
12:18:21 <EvilTerran> i'd almost read a \ in a string as "incoming special case"
12:18:41 <stulli> Hey, whats wrong with this syntax: foo :: forall a. Num a => a -> a
12:18:42 <inimino> switch to state "Incoming"
12:18:55 <stulli> I get a parse error at =>
12:18:56 <kadaver> i still havent come up with a monad!
12:18:59 <Gracenotes> stulli: nothing particularly. depends on where you use it though
12:19:00 <kadaver> ZipperFS, hwo good is it?
12:19:13 <MyCatVerbs> ppavelV6: I didn't get it. I just assumed you might've been mistaken. No offense either way.
12:19:14 <Gracenotes> oh, forall
12:19:41 <stulli> Gracenotes: Its just a simple function
12:19:52 <Gracenotes> stulli: try foo :: Num a => a -> a
12:20:11 <ppavelV6> MyCatVerbs:  that's a good practice: don't assume evil, assume mistake :) my fault anyway.
12:20:12 <___> char '\\' >> choice [char 'n' >> return '\n', char 't' >> return '\t', etc.]
12:20:31 <Gracenotes> stulli: 'forall a. Num a' means the same thing as 'Num a' in this case: "for all types that are a Num, take one and return another one"
12:20:33 <stulli> Gracenotes: That works, but i want forall and the type constraint
12:20:43 <Gracenotes> however, you need a special language extension to use the former
12:20:58 <stulli> Gracenotes: In this case yes, but i need it for another case :)
12:21:39 <Gracenotes> there's a wikibooks article about it: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
12:21:50 * wunki is impressed by Haskell logical purity..
12:21:53 <Gracenotes> the extension itself is ExistentialQuantification... in many cases there's a better solution
12:22:00 <Gracenotes> but if you need it, feel free to use it :)
12:22:20 <___> char '\\' >> choice (map escape [('n', '\n'), ('t', '\t'), ('\\', '\\')]) where escape (trigger, result) = char trigger >> return result
12:22:36 <stulli> Thanks, i will try. Just trying to reproduce some code from a paper
12:23:14 <ppavelV6> are existentials in haskel' btw?
12:23:39 * ppavelV6 admits he's lazy to just google it
12:23:53 <Gracenotes> I think the point is Haskell' is to integrate some GHC extensions into the core language
12:23:57 <Gracenotes> or at least a point
12:24:28 * ppavelV6 needs new LANGUAGE pragma like HaskelPrime
12:24:31 <vixey> I thought Haskell' was just to /specify/ extensions well (a good idea)
12:24:42 <vixey> but there is this impression it's like .. reinventing haskell (a terrible idea)
12:25:01 <Gracenotes> specify extensions? what mean you?
12:25:21 <jmcarthur> i thought it was to come up with a new Report
12:25:24 <jmcarthur> essentially
12:25:42 <jmcarthur> what the language would be like without explicitly loading more extensions
12:25:51 <ppavelV6> vixey: i'm not so familiar with haskell'. but some parts of the library can use some refinement probably. And some language extensions are de-facto standard
12:25:52 <maltem> was to != will, evidently :)
12:26:20 <ppavelV6> like MultiParamTypeClasses etc
12:26:23 <Gracenotes> if nothing else, it should at least be a stable standard people can rely upon.
12:26:42 <Gracenotes> e.g. commercial users (if any evar)
12:26:53 <ppavelV6> without thinking "is this just the implementation in hand or...". right.
12:28:39 <bolrod> nd?
12:30:10 <McManiaC> how can i use float with list comprehensions without getting those ugly rounding "errors"
12:30:13 <McManiaC> ?
12:30:24 <McManiaC> like 0.30000000000004 etc
12:30:44 <kadaver> has there been any experiments with game-in-episodes, ie release a game one level at the time, with some sort of payment system?
12:31:08 <omnihil> kadaver, in haskell or in general? it's been done but I don't know if it's been done in haskell.
12:31:13 <maltem> McManiaC: we need a code example, but you cannot have floating-point arithmetic without rounding errors in general
12:31:52 <McManiaC> countWith interval list = [ x * interval | x <- [1..], x * interval <= maximum list ]
12:32:12 <McManiaC> (plus, this function wont exit after the last element? :S )
12:32:15 <___> > [1%10, 2%10 .. 1] -- rationals don't have error.
12:32:16 <lambdabot>   [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
12:32:26 <vixey> ___++
12:32:32 <dmhouse> Can anyone get anything sensible out of http://shop.o2.co.uk/mobile_phone/Sony_Ericsson/W760i_Black? I get a load of "Your browser does not support this portlet." messages. (Firefox on Ubuntu).
12:32:35 <BMeph> McManiaC: Use a different "float" format. :)
12:32:51 <Gracenotes> McManiaC: er.. list comprehensions aren't as smart as you think they are, I don't think :)
12:33:07 <McManiaC> =(
12:33:08 <McManiaC> pity
12:33:16 <Gracenotes> it's not just floating point numbers
12:33:39 <Gracenotes> the problem is that putting an infinite list into a comprehension yields an infinite list
12:33:52 <McManiaC> ok
12:33:59 <vixey> use CReal
12:33:59 <___> use takeWhile
12:34:10 <Gracenotes> even if you don't allow any elements above the maximum, you'll have to test every single value until infinity to see if it applies
12:34:23 <Gracenotes> so you'll get every thing until the last value, and after that the computation will hang
12:34:58 <___> > let interval = 5; max = 45 in  takeWhile (<= max) [ x * interval | x <- [1..] ]
12:35:00 <lambdabot>   [5,10,15,20,25,30,35,40,45]
12:35:01 <Gracenotes> yeah. takeWhile works.
12:36:11 <maltem> > [5,10..45+1] :: [Double]
12:36:13 <lambdabot>   [5.0,10.0,15.0,20.0,25.0,30.0,35.0,40.0,45.0]
12:36:46 <vixey> > [5,10..45] :: [Double]
12:36:47 <lambdabot>   [5.0,10.0,15.0,20.0,25.0,30.0,35.0,40.0,45.0]
12:37:11 <jmcarthur> > [1..9+1]
12:37:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:37:31 <maltem> ok ok, I don't usually test in my head if this isn't a case where I'll get bitten by round-off errors
12:37:36 * jmcarthur didn't realize you can put expressions in those
12:38:36 <jmcarthur> :t fromRational
12:38:38 <lambdabot> forall a. (Fractional a) => Rational -> a
12:38:45 <dons> ?seen mmorrow
12:38:45 <lambdabot> I saw mmorrow leaving #yi, #ghc and #haskell 1d 2h 14m 21s ago, and .
12:38:48 <dons> bah
12:38:57 <jmcarthur> > fromRational [1%10..1] :: Double
12:38:59 <lambdabot>   Couldn't match expected type `Rational' against inferred type `[a]'
12:39:04 <kadaver> let probabilitySpam = classify 5 test spam ham
12:39:04 <kadaver>   print (if probabilitySpam >= 0.5 then "Spam" else "Ham", probabilitySpam); can I somehow get rid of the let but still only dot he computation once? can you use a monad for this perhaps :P
12:39:05 <jmcarthur> > fromRational [1%10..1] :: [Double]
12:39:06 <lambdabot>   Couldn't match expected type `Rational' against inferred type `[a]'
12:39:14 <___> jmcarthur: map fromRational
12:39:18 <jmcarthur> duh
12:39:19 <jmcarthur> thanks
12:39:23 <jmcarthur> > map fromRational [1%10..1] :: [Double]
12:39:25 <lambdabot>   [0.1,1.1]
12:39:32 <jmcarthur> oh i'm still retarded
12:39:41 <jmcarthur> okay i'm just gonna get back to my c++ work. the idea has been expressed already
12:39:50 <McManiaC> lol :)
12:39:52 <Gracenotes> o_O
12:39:55 <Gracenotes> O_o
12:40:00 <jmcarthur> c++ fried my brain today
12:40:02 <ziman> @pl \x -> (if x then y else z, x)
12:40:02 <lambdabot> (,) =<< flip (flip if' y) z
12:40:08 <McManiaC> this is probably the worst spam-channel i know of :D
12:41:05 <matthew-_> with polyparse, how are you meant to test for eof?
12:41:10 <matthew-_> optional next ?
12:43:12 <___> if polyparse has something like anyToken and fail, then anyToken >> fail would do it :)
12:44:29 <matthew-_> well next is anytoken and optional makes a parser optional
12:44:33 <matthew-_> so yeah, I guess so ;)
12:51:09 <kadaver> god java just makes laugh how did file-handlign become so ridic complicated, bufferedreader filereader blah
12:51:27 <lament> file handling is complicated
12:51:38 <lament> why would you think it isn't?
12:51:41 <vixey> kadaver: you can make it simple again
12:51:48 <vixey> kadaver: just write a class that deals with it
12:51:52 <monochrom> "god java" does not exist.
12:52:35 <MyCatVerbs> ppavelV6: I go one further, and assume that the mistake is usually on *my* part. ;P
12:52:43 <monochrom> And yes in fact write you own class or method to contain the bufferedreader-filereader boilerplate. It's easy.
12:53:20 <ppavelV6> MyCatVerbs: so this conversation has good chances to continue forever that's a good thing :-P
12:53:56 <dons> @tell mmorrow http://galois.com/~dons/tmp/vacuum.patch release a minor revision to vacuum on hackage since you're not around
12:53:56 <lambdabot> Consider it noted.
12:54:59 <ppavelV6> @seen kowey
12:54:59 <lambdabot> Last time I saw kowey was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #haskell,
12:54:59 <lambdabot>  #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.
12:54:59 <lambdabot> jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 3m 5d 23h 50s ago, and .
12:55:09 <Heffalump> ppavelV6: he's at a conference this week
12:55:13 <ppavelV6> ok
12:55:17 <ppavelV6> thanks
12:55:39 <dons> Heffalump: flights to the EU are ~$500 atm. woo
12:55:42 <dons> (return)
12:55:46 <Heffalump> dons: nice
12:55:56 <dons> yay for financial meltdown!
12:56:03 <SubStack> nifty
12:56:03 <Heffalump> that seems pretty cheap from the west coast
12:56:11 <dons> yup.
12:56:14 <MyCatVerbs> ppavelV6: one should always descend on recursion while conversating, so that eventually a conclusion will be reached, provided that the structure of the topic being discussed is not circular. :3
12:56:31 <nA1828KcFz9q> :-D
12:57:25 <monochrom> No, there is a non-circular way to generate infinite non-repeating conversation.
12:57:28 * ppavelV6 has his brain exploded by not-tail recursion and goes to bed
12:57:32 <ppavelV6> bye
12:58:13 <monochrom> In fact science itself is one such. You know how a good answer leads to more and even better questions.
12:58:20 <monochrom> Engineering is another.
12:59:04 <dons> new release of vacuum-cairo, should fix build errors.
12:59:20 <MoxJet> dons: does it fix broken pipe?
12:59:30 <dons> that's because you don't have graphviz installed
12:59:33 <dons> you'll get a warning now.
12:59:40 <MoxJet> dons: cool, thanks
13:02:11 <ziman> could you give me a hint how to install the packages like gtk, cairo or svgcairo that vacuum depends on but cabal does not know about?
13:03:44 <Heffalump> ziman: go to the gtk2hs home page and download it/follow the instructions
13:03:54 <Heffalump> we really need to get that on hackage
13:04:01 <ziman> Heffalump, thanks
13:04:18 <Heffalump> do I remember correctly that the reason it can't be cabalised is that it uses two levels of preprocessing which screws up some dependency analysis?
13:04:39 <guenni> dons: I want XMonad to run on Windows too!
13:04:56 <bavardage> guenni: there are just a few problems with that hehee
13:05:04 <Heffalump> X runs on Windows
13:05:12 <bavardage> Heffalump: oh right :P
13:05:14 <Heffalump> I don't see any reason XMonad wouldn't either
13:05:17 <bavardage> guenni: there are no problems with that
13:05:35 <Heffalump> I did try briefly a while ago but had various cygwin-related hassle - not xmonad specific.
13:05:47 <guenni> bavardage: apart from the Unix package you mean
13:06:00 <bavardage> indeed
13:06:00 <Heffalump> I think that should work on cygwin too
13:06:13 <Heffalump> I had some problems getting it to find its includes
13:06:15 <guenni> Heffalump: go and try it
13:06:29 <Heffalump> I did, but I got stuck at that point (but I didn't try very hard)
13:13:28 <bavardage> is integer a monad?
13:13:44 <Heffalump> no, because it has the wrong kind
13:14:11 <cocon> only types that take another type in argument can be monads
13:14:23 <cocon> is it possible to switch to another garbage collector at runtime?
13:14:32 <bavardage> "Another example is the type of integers, Integer. "
13:14:34 <cocon> or more generally, give RTS options at runtime
13:14:35 <bavardage> strange tutorial then
13:14:41 <Heffalump> cocon: nope
13:14:44 <Heffalump> bavardage: where?
13:14:50 <Heffalump> cocon: or rather, not that I know of.
13:14:52 <bavardage> http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html
13:14:59 <Heffalump> are you confusing monoid and monad?
13:15:03 <bavardage> oh wait, these are Monoids
13:15:06 <bavardage> yes, yes I am
13:15:10 <bavardage> THAT'S JUST NOT FAIR
13:15:13 <Gracenotes> caught! :O
13:15:16 <bavardage> pfft
13:15:22 <bavardage> but they also seem very similar...
13:15:23 <Heffalump> there should be a forfeit for that
13:15:28 <bavardage> with the whole identify thing
13:15:30 <Heffalump> Monoid and MonadPlus are very similar
13:15:34 <bavardage> and the rules of monoids
13:15:36 <bavardage> DAMMIT
13:16:07 <Heffalump> they only really differ in their kinds, and in the fact that MonadPlus implies some more laws because of the Monad superclass
13:16:33 <wunki> how does Haskell know that [1,2,3] == 1:(2:(3:[]))? Because it evaluates the right side and than compares?
13:16:42 <Heffalump> wunki: by definition
13:16:46 <Cale> bavardage: one can abstract the idea of monoid such that what we normally call monoids are monoid objects in the category of Sets, and then monads become monoid objects in another category
13:16:47 <Heffalump> the LHS is syntactic sugar for the LHS
13:16:52 <vixey> > [1,2,3] == 1:(2:(3:[]))
13:16:54 <lambdabot>   True
13:17:01 <Heffalump> IM syntactic sugar for the RHS
13:17:06 <bavardage> Cale: srry, I don't really know Set/Category theory yet :D
13:17:09 <vixey> it doesn't 'evaluate the right side them compare'
13:17:11 <Gracenotes> Heffalump: yeah, looks like a bottom explanation to me :)
13:17:13 <bavardage> Cale: I start my maths degree in september :P
13:17:14 <Cale> bavardage: So the concepts are actually related, but unless you know a bunch of category theory already, explaining how is not going to help much :)
13:17:19 <vixey> it checks if the heasd are equal, then checks if the tails are equal
13:17:19 <bavardage> yeah...
13:17:28 <vixey> the 'then' bit comes from pattern match here:
13:17:31 <vixey> @src (&&)
13:17:31 <lambdabot> True  && x = x
13:17:32 <lambdabot> False && _ = False
13:17:46 <Gracenotes> @src [] (==)
13:17:46 <lambdabot> []     == []     = True
13:17:47 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
13:17:47 <lambdabot> _      == _        = False
13:17:58 <wunki> hmm.. let me think about that...
13:18:04 <vixey> I'm just talking about the interesting case:  x == y && xs == ys
13:18:59 <wunki> i'm trying to 'get' why you can pass a list to a function with (x:xs)
13:19:15 <vixey> wunki: what do you mean by  a list  ?
13:19:21 <wunki> []
13:19:28 <vixey> here's an example:
13:19:38 <vixey> > let f (x:xs) = x in   f []
13:19:40 <lambdabot>   * Exception: /tmp/4063662596027225016:71:36-47: Non-exhaustive patterns in ...
13:19:45 <vixey> > let f (x:xs) = x in   f "fooobar"
13:19:46 <lambdabot>   'f'
13:21:01 <Gracenotes> > let f ((:) x xs) = x in f "it's a tarp"
13:21:03 <lambdabot>   'i'
13:21:27 <wunki> this is to complicated for me already.. feeling stupid right now..
13:22:04 <vixey> wunki: what is?
13:22:05 <Gracenotes> it's not too important to get how it works. It's just, if the list has no elements, it's empty: []
13:22:14 <EvilTerran> ?type []
13:22:15 <lambdabot> forall a. [a]
13:22:24 <Gracenotes> if it has some elements, it has a top element and the rest of the list
13:22:30 <vixey> other than everyone talking at once
13:22:30 <Gracenotes> they're separated by a ":"
13:22:37 <wunki> that I all understand
13:23:09 <EvilTerran> > 1 : 2 : 3 : []
13:23:10 <lambdabot>   [1,2,3]
13:23:11 <c_wraith> In some ways, it's mildly confusing that lists have special syntax.
13:24:19 <wunki> I know that you can make a list with :. But how does Haskell know that a list [1,2,3] is 1:2:3:[]
13:24:26 <c_wraith> If you had something like "data List a = Cons a List | Empty", the semantics would be more obvious
13:24:28 <Gracenotes> it's built into the language.
13:24:48 <Gracenotes> 'syntactic sugar'
13:24:48 <vixey> wunki: that's the definition of [1,2,3]
13:25:03 <EvilTerran> wunki, the syntax [1,2,3] is syntactic sugar for (1:(2:(3:[])))
13:25:05 <c_wraith> You're tripping over the fact that lists have special syntax, which hides the fact that nothing special is going on at all.
13:26:16 <wunki> ah, ok. Get it now (I think)
13:26:23 <EvilTerran> semantically, every list is either an empty list, [], or a value "consed" with another list
13:26:33 <EvilTerran> "cons" being spelt ":"
13:26:46 <dolio> (Or _|_)
13:26:56 <EvilTerran> (or ":" being pronounced "cons", if you prefer to look at it that way)
13:27:15 <wunki> ah, that's why they mention it with `cons` in RWH
13:27:31 <Gracenotes> > let f (x:xs) = x in f (let b = b in b)
13:27:35 <wunki> when you have to make your own list
13:27:47 <lambdabot>   thread killed
13:27:48 <maltem> dolio: I suppose EvilTerran, when saying "semantically", meant "in our usual forget-those-bottoms-for-now semantics"
13:27:55 <matthew-_> why does putStrLn "foo\b" and putStr "foo\b" differ by more than just the trailing newline?
13:27:55 <dolio> :)
13:27:56 <Gracenotes> , src ''[]
13:28:00 <lunabot>  data [] a = [] | a `(:)` ([a])
13:28:04 <wunki> thanks EvilTerran and vixey
13:28:17 <EvilTerran> np :)
13:28:24 <EvilTerran> matthew-_, er... because of your terminal, perhaps?
13:28:38 <vixey> that `(:)` is really bad
13:28:49 <EvilTerran> vixey, yeah =/
13:28:49 <vixey> > 1 `(:)` []
13:28:51 <lambdabot>   <no location info>: parse error on input `('
13:28:59 <EvilTerran> ``s wrap a name, not an expression
13:29:09 <matthew-_> mmm, I'm going to blame libedit or whatever it is
13:29:38 <Gracenotes> > 1 `(`(`(`(:)`)`)`)` [2,3]
13:29:40 <lambdabot>   <no location info>: parse error on input `('
13:29:44 <Gracenotes> aww!
13:31:56 <Gracenotes> yeah. If you can't make expressions into infix, you may as well not be able to make sections into prefix
13:32:46 <BMeph> Why are you guys using a definition from one interpreter, and using it on another interpreter? :)
13:32:53 <conal> i also wish `` wrapped expressions.  sigh.
13:33:07 * bavardage is making monadic sheep
13:33:09 <bavardage> weeeeeee
13:33:22 <BMeph> conal: Nice blog art(icle). I commented. :)
13:33:30 <conal> BMeph: thx!
13:33:32 <Gracenotes> BMeph: well, it's a definition insofar as TH thinks it is
13:33:42 <Gracenotes> me supposes.
13:34:01 <BMeph> conal: ALthough, I frankly think you could use a TON more of that conflict avoidance stuff you say you know... ;)
13:34:11 <Heffalump> conal: as in the TH `` thing?
13:35:23 <BMeph> conal: Not that I think you're being hostile, but that you should recognize when you're receiving hostile responses, and should work to calm things down. :)
13:36:03 <vixey> hi conal,
13:36:12 <conal> vixey: hi.
13:36:16 <vixey> I think my program turned out to be not frp .
13:36:38 <vixey> but I am will keep exploring stuff, probably figure something out eventually
13:37:18 <conal> BMeph: you commented on my blog?  i haven't seen it.
13:37:56 <jmcarthur> Is FRP well-defined enough that it's really meaningful to say whether a piece of code is or isn't FRP?
13:38:13 <vixey> jmcarthur,  did you look at my program ? :p
13:38:38 <jmcarthur> vixey, i did. i can't say i completely understood it in the limited time i looked though
13:40:38 <vixey> I think without being actually interactive, maybe there is something missing
13:43:24 <michaelcdever> hey all, isnt there functionality within ghc for testing?
13:43:47 <beelsebob> what kind of functionality would you like?
13:44:05 <michaelcdever> just say some unit testing?
13:44:29 <beelsebob> then you want to look at one of QuickCheck or SmallCheck
13:44:36 <Heffalump> or HUnit
13:44:42 <michaelcdever> ok cool, cheers!
13:44:49 <beelsebob> the first two arent' traditional unit testing suites though
13:44:54 <beelsebob> you specify properties to be checked
13:44:57 <beelsebob> not tests to be run
13:45:07 <beelsebob> it generates tests to check the properties
13:45:15 <blackh> michaelcdever: There are two testing frameworks on hackage that support both hunit and quickcheck
13:46:16 <blackh> michaelcdever: ...these are useful if you have lots of tests
13:46:45 <kadaver> Maybe really is elegant, it is a very neat solution to stuff i never liked about exceptions. and a lot more clean than returning NULL for failure like in C:
13:46:55 <michaelcdever> ah ok, test-framework is it?
13:47:15 <conal> BMeph: now i see your blog comment.  thx.
13:49:53 <beelsebob> kadaver: and with the applicative interface you even get to write code that checks for errors as you go, without cluttering it with if statements to determine if an error has occured
13:51:45 <BMeph> kadaver: I thought C's thing was returning -1 for failure.
13:52:13 <vixey> BMeph, or sometimes NULL or sometimes ...
13:52:26 <vininim> sometimes different from 0
13:52:26 <bavardage> where is `mplus` defined?
13:52:33 <Heffalump> Control.Monad
13:52:35 * BMeph goes to ##c to complain that every time his programm does 'i--' on a zeroed variable, it fails...
13:52:36 <bavardage> this tutorial references it, but doesn't say where it comes from...
13:52:41 <bavardage> Heffalump: so I just import that?
13:52:44 <Heffalump> yep
13:52:50 <Heffalump> @hoogle mplus
13:52:50 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
13:53:03 <vixey> @let (⊕) = mplus
13:53:07 <lambdabot>  Defined.
13:53:26 <bavardage> ty :D
13:53:29 <vixey> > "foo" ⊕ "bar"
13:53:30 <lambdabot>   "foobar"
13:53:38 <BMeph> vixey++
13:54:21 <jmcarthur> BMeph, usually errors in C are NULL for functions that return pointers or -1 otherwise, afaik
13:54:29 <jmcarthur> vixey++
13:55:10 <bavardage> Heffalump: I get a module error now
13:55:21 <Heffalump> be more precise :-)
13:55:28 <blackh> vixey: How do you get ghc to do this?
13:55:41 <jmcarthur> actually, i think i would prefer that ⊕ be for mappend
13:55:59 <blackh> vixey: Oh - I just had missing parentheses. It works! Yay - thanks.
13:56:06 <jmcarthur> don't know what that would make mplus though
13:56:10 <bavardage> Heffalump: oh wait nm, there seems to be a problem anyway
13:56:17 <kadaver> is there a function to count nbr of lines in a file?
13:56:37 <jmcarthur> i guess ++ would make sense for mappend
13:56:37 <Heffalump> kadaver: liftM (length . lines) . readFile
13:56:43 <bavardage> Heffalump: just me being a n00b
13:57:10 <orbitz> kadaver is in mah irc's watching me chat
13:58:27 <kadaver> mah?
13:58:38 <kadaver> orbitz didnt think u knew haskell?
13:58:46 <Heffalump> bastardised pronounciation of "my"
14:03:50 <BMeph> If by "bastardized" you mean "phonetic, according to someone from Birmingham", then sure. ;)
14:04:33 <BMeph> Hm, I should say Birmingham US, not UK. :)
14:04:37 <Heffalump> I'd have thought coming anywhere near Birmingham was a good definition of 'bastardized' ;-)
14:04:43 <Heffalump> though I mean UK, not US.
14:04:56 <BMeph> ROFL-House! :)
14:05:05 <plex0r> lewlies
14:06:10 <vixey> lol
14:07:54 <orbitz> kadaver: i know alls
14:08:44 <amgarchIn9> OT: can anybody point me to some algorith/implementation of a shared "counter" with atomic updates in a distributed memory architecture using message passing?
14:09:06 <vixey> I can't install ivor :/
14:09:35 <McManiaC> :t ap
14:09:35 <vixey> amgarchIn9: CTM gives this sort of stuff very thourough treatment
14:09:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:10:03 <vixey> I'm talking about the book by Peter Van Roy and Seif Hardy
14:11:05 <jmcarthur> conal, is the similarity between the last paragraph of your blog post and the semantics of unamb intentional (even if not, i wouldn't believe for a second that it's merely _coincidental_)?
14:11:07 <matthew-_> any gtk2hs experts alive?
14:11:10 <amgarchIn9> vixey: I am not from CS, you mean this: Concepts, Techniques, and Models of Computer Programming
14:11:51 <dolio> jmcarthur: It's the usual partial ordering of definedness that the semantics of Haskell is based on.
14:11:52 <jmcarthur> *preconditions of unamb, rather
14:12:39 <jmcarthur> dolio, it does make intuitive sense to me, but do you know of a formal description of this?
14:12:45 <conal> jmcarthur: re-reading ...
14:13:26 <dolio> Not really. Look up domain theory, I guess? :)
14:13:35 <jmcarthur> alright
14:13:47 <vixey> intro books about domain theory? :p
14:13:52 <BMeph> amgarchIn9: Yes. Do you know of another referent for CTM, by the way? :)
14:13:57 * jmcarthur has never looked at domain theory
14:13:59 <vixey> domain theory has massive prereqs.
14:14:08 <conal> jmcarthur:  oh -- about lub (generalized unamb).  i suppose since i've thought about unamb/lub recently, it's more likely that i'd notice the distinction between agreement and consistency.
14:14:31 <jmcarthur> lub?
14:14:42 <conal> least upper bound
14:14:45 <jmcarthur> oh!
14:14:57 <conal> unamb is a domain-restricted form of lub
14:15:14 <conal> jmcarthur: did you know there's a lub library?
14:15:24 <jmcarthur> did not at all know
14:15:27 * jmcarthur looks it up
14:15:41 <BMeph> Heh-heh: lub-lib. ;)
14:15:47 <conal> :)
14:16:09 <jmcarthur> oh, i did look at this at one point i think, or read related material somewhere at least
14:16:15 <conal> unamb is safe to use on flat domains.  lub works with functions, tuples, ...
14:16:45 <McManiaC> whats wrong with that?
14:16:46 <McManiaC> let contents = ["hallo\ndu"] in sort $ map (read :: String -> Float) (lines contents)
14:16:58 <jmcarthur> (x, _|_) `lub` (_|_, y) = (x,y)?
14:17:05 <conal> yeah!
14:17:08 <conal> nice, huh?
14:17:09 <McManiaC> s/hallo/123 etc..
14:17:13 <jmcarthur> okay, yeah nice
14:17:16 <dolio> "hallo" doesn't look like a float to me.
14:17:16 <conal> lub a b is defined whenever a & b are information-consistent.  i.e., "don't disagree", or (more explicitly) "don't contradict"
14:17:36 <jmcarthur> but it was hard enough to convince myself that unamb was "a good thing" ... now i have to do it all over again!
14:17:43 <conal> :)
14:17:52 <McManiaC> > let contents = ["123\n123"] in sort $ map (read :: String -> Float) (lines contents)
14:17:53 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
14:17:56 <cads> hey, i think my last line didn't get through
14:18:02 <cads> is there any way to get haskell's interactive mode working more like a lisp repl or ruby's irb, where you could type in pretty much any code line by line without different syntax from what you'd type into a file?
14:18:07 <conal> jmcarthur: keeps you in shape.
14:18:08 <jmcarthur> okay, i guess given those preconditions it passes my mental checks easily enough
14:18:09 <Heffalump> lub is just a better unamb, isn't it?
14:18:16 <conal> yes
14:18:22 <conal> lub is a better unamb
14:18:22 <Heffalump> so if you believe in unamb you should believe in lub :-)
14:18:24 <dolio> contents = "123\n123"
14:18:30 <EvilTerran> cads, yeah, :{ on a line on its own
14:18:37 <EvilTerran> cads, and :} on a line on its own when you're done
14:18:43 <conal> lub is simpler, semantically.
14:18:47 <McManiaC> dang
14:18:49 <McManiaC> :o
14:18:54 <conal> and more general. simplicity & generality usually go together, i find.
14:18:56 <jmcarthur> oh, is ptimes what the topic was when i came in and people were talking about x*0 and 0*x?
14:19:15 <jmcarthur> it was just one or two days ago
14:19:22 <Heffalump> I wonder what would be needed to also make it fast.
14:19:46 <Heffalump> (I haven't benchmarked it, but I presume the thread racing is relatively slow)
14:19:50 <BMeph> Conal: "don't contradict" -- heh-heh. :)
14:20:30 <conal> BMeph: i enjoyed your comments very much, and i replied.
14:22:11 <cads> EvilTerran: but don't I still have to say stuff like 'let f g a b = map g (zip a b)'
14:22:15 <BMeph> conal: Cool. That'll make me feel less like a completely clueless noob. I can handle being incompletely clueless.... :)
14:22:41 <conal> BMeph: :D
14:22:49 <conal> BMeph: i relate.
14:23:25 <Heffalump> hi dcoutts__
14:24:02 <Heffalump> is ghci expected to work on gtk2hs for windows?
14:25:01 <jmcarthur> would be nice to have a type class to generalize ptimes with
14:25:31 <jmcarthur> more general than Num, i mean
14:25:46 <jmcarthur> any binary operation with an absorbing element
14:28:26 <cads> can I add polymorphism to the (+) operator so that it can do vector addition on lists?
14:28:45 <kmcallister> yes
14:28:56 <kmcallister> :type (+)
14:28:58 <conal> Just posted another blog comment: http://conal.net/blog/posts/notions-of-purity-in-haskell/#comment-17812 .  It gets more to practical reasons for a functional programming language to have precise (and thus implementation-independent) semantics.
14:29:04 <Heffalump> cads: though you'll then need to either implement (*) for lists, or leave things a bit partial
14:29:08 <kmcallister> @type (+)
14:29:10 <lambdabot> forall a. (Num a) => a -> a -> a
14:29:32 <kmcallister> so define a Num instance for lists
14:29:36 <kmcallister> but you'll have to implement all of Num
14:29:37 <cads> Heffalump: I would have to implement * as scalar multiplication, and . as the dot product :D
14:29:52 <Heffalump> . ?
14:29:56 <vixey> you can't do  3 * [3,2,4]
14:29:56 <kmcallister> you can also define your own operator with a similar name
14:30:01 <Heffalump> * would be pointwise or something.
14:30:03 <vixey> oh wait actually you can
14:30:14 <vixey> 3 == [3,3,..] probably
14:30:19 <conal> vixey: yeah.
14:30:20 <kmcallister> so, if MPTC had existed for H98, would we have class Num a b where (+) :: a -> a -> b ?
14:30:26 <conal> in fact there's a package for this sort of thing.
14:30:31 <conal> @hackage applicative-numbers
14:30:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/applicative-numbers
14:30:57 <conal> fromInteger = pure
14:31:00 <Heffalump> conal: btw, I forgot to mention it on Saturday - how about modelling machine [in]dependence with phantom types?
14:31:21 <conal> Heffalump: how so?
14:31:24 <Heffalump> not exactly pretty, but it might get a long way with today's Haskell[s]
14:31:32 <Anon175> any girls  in here?
14:31:32 <conal> Heffalump: what might it look like?
14:31:35 <cads> vixey a*[b1..bn] = [a*b1..a*bn],     [a1..an] . [b1..bn] = a1*b1+..+an*bn
14:31:40 <Heffalump> I only have a vague idea.
14:32:01 <Heffalump> The basic point would be that the phantom type parameter would be polymorphic for universally valid expressions/values.
14:32:14 <Heffalump> And instantiated to something specific for machine-specific things.
14:32:32 <conal> Heffalump: oh yeah.  i like that idea.
14:32:42 <blackh> Anon175: Try a less male dominated profession.
14:32:48 <conal> Heffalump: Int is parameterized by a type that represents architectures (or whatever)
14:32:51 <Heffalump> so you can write your own "universal" library now
14:33:01 <conal> Heffalump: so forall arch. Int arch is portable.
14:33:04 <Heffalump> right
14:33:13 <conal> neat :)
14:33:25 <BMeph> jmcarthur: "an absorbing element"? That sounds like what I was asking about on...Friday, I think.
14:34:25 <conal> jmcarthur: an annihilator?
14:34:33 <conal> jmcarthur: like zero for multiplication?
14:34:43 <Heffalump> of course, I don't think Int (as it stands in Haskell today) can ever be portable, so probably that's a poor example.
14:34:56 <cads> conal, that seems like what I need... it seems like it allows you to create mathematical spaces from a single mathematical object, but I don't quite understand what a functor is
14:35:49 <adamvo> I'm trying to generate instances for this class with TH, but I'm getting an error that doesn't suggest how to fix it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3115#a3116
14:35:59 <dolio> Why not Num a b c where (+) :: a -> b -> c ...?
14:36:10 <dolio> Get back all the fun of C's numeric system.
14:36:20 <vixey> adamvo: forgetting TH for a moment, what do you want to implement?
14:36:24 <conal> unamb does have parAnnihilator.  for symmetric optimizations.  safer than things like (&&), (||)
14:36:49 <blackh> conal: I wanted to pick your brains a little if I could. I am trying to enhance my "thinking in Haskell" and so I wrote a rough adventure game that reflects the current state of my knowledge. http://blacksapphire.com/haskell/adventure3.hs  The reason why I chose adventure games as a problem is because it seems like a good example of something state-heavy.  I wondered if you could comment - I'm in no hurry, so any time.
14:36:56 <adamvo> vixey: Read and Show instances for functions
14:37:16 <adamvo> that can be passed as parameters
14:37:53 <vixey> @go a fun show instance for functions
14:37:54 <lambdabot> No Result Found.
14:38:05 <vixey> lambdabot sucks
14:38:16 <blackh> conal: I realize I am "mutating" the game world into existence rather than declaring it wholesale, but it seemed to fit in with the design so well - otherwise I'd have to write two ways to create things, if you see what I mean.
14:38:22 <vixey> adamvo; here's an example http://muaddibspace.blogspot.com/2008/06/just-fun-show-instance-for-functions_27.html
14:38:28 <adamvo> this method works fine, but its a bit tedious to have to create those dummy datatypes
14:38:29 <Trafalgard> Oh, cool, changing 'a' and 'b' and crap in function parameter type declarations makes inscrutable "Occurs check: cannot construct the infinite type: b = [b]" errors turn into sensible normal error messages :D
14:38:38 <conal> blackh: i looked before, and i liked what i saw, as far as haskell style.
14:38:41 <Trafalgard> *turning them into normal types like Float and Int
14:39:02 <adamvo> vixey: thanks, I'll take a look at that alternative
14:39:11 <blackh> conal: Thank you - it's helpful to have some confirmation that I'm on the right track.
14:39:13 <conal> blackh: i have a view i like to help people with, which is not quite thinking in haskell.  it's more thinking in meanings.
14:40:19 <conal> blackh: and no -- i don't get the part about "otherwise ... two ways to create thigns".
14:40:23 <conal> ("things")
14:40:37 <adamvo> vixey: hmm, that method doesn't seem to address the 'Read' part of it however
14:41:26 <conal> blackh: if it were mine, i'd of course try to make understand it in terms other than mutation.
14:41:31 <quuxman> so is "[a]" an "abstract data type", because you can write functions that manipulate a "[a]" without knowing what "a" is?
14:41:33 <BMeph> dolio: Considering that really, 'abs' should give a possibly different type than its arguments, I don't have a problem with the Num a b c part. :)
14:42:00 <conal> blackh: and then program accordingly.  but my tastes are on the extreme functional side.
14:42:02 <dolio> abs couldn't go in that class.
14:42:20 <blackh> conal: I have a whole lot of things like "describe" which adds a description, i.e. mutate the world in small pieces. The risk here (which turns out to be not so great in this example) is that you can get something out of order.  However, I also want to be able to make very flexible state changes, e.g. I might want to change the description of the rabbit when some event occurs.  So it is, at least, a flexible design.
14:42:54 <dolio> BMeph: I'm not that eager to have (+) :: Float -> Int -> Float.
14:42:55 <int-e> quuxman: "ADT" means "algebraic data type" in Haskell, usually.
14:43:28 <Gracenotes> maybe a MultipleDispatchNum >_>
14:43:43 <int-e> quuxman: and what you described is called (parametric) polymorphism.
14:43:49 <blackh> conal: That's the "two ways to create things" point: I could do a mkRoom that makes the room in one indivisible go.  Anyway, not a big deal. So do you have any comments about how you might implement an adventure game in terms other than mutation?
14:43:50 <dolio> Although I haven't tried it enough to definitively say it'd be bad.
14:44:08 <singintime> hello everybody
14:44:14 <blackh> singintime: Hello!
14:44:39 <quuxman> so are Java's and C#'s "generics" basically their retarded syntax for "parametric polymorphism" then?
14:44:55 <singintime> anyone has ever tried to do digital signal processing in haskell?
14:45:07 <lament> quuxman: yes, what's so retarded about it?
14:45:22 <dolio> Angle brackets, obviously.
14:45:35 <vixey> <> are the future
14:45:37 <quuxman> lament: yes, the angle brackets. But mainly because I haven't used it, and I have used Haskell's ;)
14:45:42 <blackh> singintime: Not that I know of. Are you talking about embedded signal processing, or running on a PC?
14:45:45 <lament> quuxman: ah :)
14:45:55 <monochrom> retarded syntax criticizes the syntax.
14:46:10 <singintime> on a pc
14:46:15 <BMeph> dolio: Part of the problem is that there isn't a convenient way to say "(+) :: lub (a -> b -> c) (b -> a -> c)"
14:46:23 <BMeph> NOOOOO!!
14:46:25 <singintime> I'd like to develop some puredata externals
14:46:37 <BMeph> dolio: Part of the problem is that there isn't a convenient way to say "(+) :: lub (a -> b -> c) (b -> a -> c)"
14:47:04 <BMeph> (dolio: I just wanted to make sure you saw it. :)
14:47:12 <dolio> What do you mean?
14:48:17 <singintime> thought it was a good idea, dsp is just applying mathematical functions to a signal, in the end
14:48:32 <singintime> simplifying a lot
14:48:36 <conal> there.  just added another remark: "Another way to express my last comment: distributed execution of declarative programs is almost as easy to see coming as Y2K.  So I'd like it if functional programmers are not among those with unfortunate (and avoidable) impediments in their programs."
14:48:49 <BMeph> dolio: I mean, it'd be just as constructive to say (+) :: Int -> Float -> Float, as it would Float -> Int -> Float. Hmm, I guess it should be (+) :: a -> b -> c| b -> c, a -> c
14:49:28 <BMeph> Oops, got to take my wife to get her arm set, I'll be more responsive in a bit...
14:49:35 <dolio> The functional dependence is "a b -> c" actually (I think that means c depends on the pair of a and b).
14:49:38 <adamvo> @hackage dsp
14:49:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dsp
14:49:45 <adamvo> singintime: ^^
14:49:56 <dolio> You need to write two instances for most pairs of types.
14:50:09 <dolio> One for Num Float Int Float and another for Num Int Float Float.
14:50:14 <EvilTerran> ... would that be easier with type families?
14:50:25 <dolio> You could get rid of c with type families.
14:50:51 <EvilTerran> but you'd still need MPTCs =/
14:50:51 <dolio> class Num a b where type Result a b :: * ; ...
14:51:02 <singintime> adamvo: thx ;)
14:51:04 <dolio> (+) :: a -> b -> Result a b
14:51:17 <conal> blackh: i don't think a mutable style *really* gives you any more flexibility or modularity.  it's just that the techniques for flexibility are different.  in functional programming, we define lots of independently composable building blocks.
14:51:44 <conal> like the vulcan philosophy of IDIC (infinite diversity in infinite combinations).
14:52:18 <blackh> singintime: Haskell would work fine for signal processing, but I don't know of much work. There's a package called fft that gives a FFT algorithm.
14:53:07 <conal> blackh: as for "... how you might implement an adventure game in terms other than mutation?", i think you'll get a more helpful answer from a different question, which is how to *think* about adventure games declaratively.  your implementation will never be cleaner than your thinking.
14:53:28 <conal> blackh: in other words, answers rarely improve on their questions.
14:53:29 <blackh> singintime: Haskell is not especially suited for embedded work right now, but that's changing (and you're not using it).
14:53:35 <dcoutts__> Heffalump: hia, yes we usually expect gtk2hs to work in ghci on Windows. I think it was broken in the last release due to some ghc/mingw problem. I'm not sure if it is fixed in the latest release.
14:54:17 <blackh> conal: Thanks very much for your help. A nice Zen Koan for me to contemplate.
14:54:53 <conal> blackh: :).  i always approach design by building up a theory of what things *are* (or *mean*).  everything else follows.
14:55:37 <conal> blackh: some hints on the "semantic design" methodology in http://conal.net/papers/type-class-morphisms
14:59:14 <SirLancer> Can you always put 'do' in the beginning of a function?
14:59:29 <skorpan> only if it's monadic i think
14:59:41 <conal> blackh: you're welcome.  let me know when you think i might be of more help to you.
14:59:44 <skorpan> otherwise it wouldn't make much sense, at least not to me
14:59:52 <monochrom> What is an adventure game?
15:00:46 <conal> SirLancer: "do" is just syntactic sugar for expressions involving (>>=).  if you take the sugar away, you'll get a clearer picture.
15:00:47 <blackh> monochrom: An adventure game (the classic kind) is like an interactive story, where you generally have rooms which contain items, and you can move items from one room to another and issue commands (such as "unlock door") to solve a puzzle.
15:01:19 <blackh> conal: I will go away and think about what adventure4.hs might look like.
15:01:21 <conal> "syntactic sugar causes cancer of the semicolon"  - alan perlis
15:01:21 <Gracenotes> a "do" expression always translates into something that's a Monad
15:01:25 <conal> blackh: :)
15:01:30 <monochrom> I think an adventure game is a graph. I am at an initial node. Repeatedly: when I'm at a node, an action takes me to a successor node.
15:01:32 <Gracenotes> you can use it anywhere in your code
15:01:43 <EvilTerran> monochrom, so an adventure game is a zipper?
15:02:01 <Gracenotes> although sometimes you might need to separate it with parens or a $ so the compiler doesn't get confused
15:02:29 <skorpan> Gracenotes: so you can use 'do' *anywhere*?
15:02:40 <monochrom> You can call it mutable state. You can call it zipper. You can call it foldl.
15:02:57 <Gracenotes> skorpan: mostly anywhere you could put any arbitrary expression, I'd imagine
15:02:58 <monochrom> or unfoldr
15:03:20 <skorpan> Gracenotes: and it can have any type?
15:03:26 <EvilTerran> ?type do undefined
15:03:27 <lambdabot> forall (t :: * -> *) t1. t t1
15:03:32 <Gracenotes> skorpan: see the first statement
15:03:36 <conal> about adventure & graphs, one can ask: are the graphs necessarily finite?  discrete?  constant?
15:03:59 <monochrom> The graph is constant.
15:04:06 <conal> maybe
15:04:12 <skorpan> Gracenotes: "anywhere you could put any arbitrary expression"?
15:04:15 <blackh> Infinite mazes are rather popular in adventure games.
15:04:17 <skorpan> i don't quite understand that.
15:04:18 <Gracenotes> no.
15:04:22 <conal> is that constantess in the *essence* of adventure?  or just accidental.
15:04:44 <monochrom> Why would the graph mutate? If you design the graph to mutate, I can convert it to a larger constant graph.
15:04:44 <Gracenotes> 'a "do" expression always translates into something that's a Monad'. If your code expects a type that's a monad, you're good to go.
15:05:07 <skorpan> Gracenotes: right
15:05:22 <EvilTerran> Gracenotes, the only things that're monads are type construtors; do you mean "monadic expression", perchance?
15:05:30 <conal> monochrom: maybe.  rather than "mutate", we might consider "vary with time".  perhaps continuously.
15:05:44 <Gracenotes> EvilTerran: well, we are specifically talking about types here
15:06:08 <Gracenotes> I think.
15:06:13 <EvilTerran> i mean, a do expression is a value
15:06:25 <EvilTerran> and something must be a type constructor (specifically, of kind * -> *) to be a monad
15:06:29 <Gracenotes> yes. So it can be used like any other value, so long as care is taken with the syntax.
15:06:41 <EvilTerran> i'm just being picky, don't worry about it :P
15:06:47 <Gracenotes> right, right :D
15:06:54 <conal> blackh: infinite mazes.  nice.  and exploit the lazy FP paradigm.
15:07:23 <Gracenotes> lazy infinite mazes would be neat
15:07:33 <conal> yeah!
15:07:37 <Gracenotes> there must be some bound on how complex you can make them though
15:07:46 <sw17ch> any one have issues with svgcairo-0.10.0 when trying out vacuum-cairo in Windows?
15:07:46 <ddarius> Gracenotes: It's called memory.
15:07:50 <sw17ch> ghci doesn't want to paly nice
15:08:18 <Gracenotes> hah. Well, I mean, no paths 50 screens across the game and back without explicitly looking at least 50 screens out
15:08:19 <conal> i like how scott mccloud explored the question: "what is a comic?" and sifted through which familiar aspects are accidental and which are essential.
15:08:56 <Gracenotes> unless you have open paths that you expect to connect some way off in the future.
15:09:36 <blackh> If you look at adventure game "world states", you would probably call it a tree rather than a graph, because you generally don't go back in "time". Rooms are a possibly infinite graph.
15:09:54 <Gracenotes> whether it's cyclic or not probably has a lot to do with the complexity
15:09:55 <conal> in "understanding comics".  scott mccloud asked the same basic question that i like to ask.
15:10:38 <Gracenotes> a tree vs. a graph. something like that. anyways, just conjecturing >_>
15:11:06 <monochrom> a comic is an adventure game
15:11:13 <ddarius> blackh: A cycle wouldn't correspond to going back in time (usually)
15:11:44 <ddarius> blackh: E.g. consider flipping a switch.  Often you can turn on and off a switch.  So turning on followed by turning off would be a cycle.
15:12:00 <blackh> True. A time machine would be fun. You could meet yourself.
15:12:30 <conal> and maybe the "graphs" of an adventure game are like the graphs inside the RTS of a purely functional language.
15:12:59 <conal> in other words, perhaps we can have a very simple semantics that doesn't talk about graphs.
15:13:33 <ddarius> conal: Why would an expression in a purely functional language be more simple than a graph?
15:14:01 <conal> ddarius: different level.  i mean the *semantics* of an expression needn't be a graph.
15:14:16 <conal> ddarius: like the semantics vs RTS rep of "2 + 3"
15:14:48 <monochrom> The semantics space of expressions doesn't give you an adventure game.
15:14:53 <conal> similarly, 3d graphics apis often have explicit "scene graphs", but i've never found it helpful to *expose* those graphs in the programming model, unless the host language is fairly weak at composition.
15:15:30 <conal> monochrom: it does when you find a fitting vocabulary (dsel).
15:15:41 <conal> monochrom: of course i don't mean merely numeric expressions.
15:16:05 <conal> *everything* we denote in haskell is expressed with expressions.
15:16:47 <monochrom> I think you're making a confused transition  graph -> thunk -> denotational semantics
15:17:07 <conal> monochrom: funny!  i think you are. :)
15:17:24 <conal> monochrom: so i now conjecture than neither of us is. and that we having a communication glitch.
15:17:48 <monochrom> A thunk has more information and entropy than its denotational semantics, as we established yesterday.
15:18:12 <skorpan> entropy?
15:18:20 <wunki-away> nn all
15:18:22 <conal> yes.  one can map thunk to meaning.  not reversable.
15:19:00 <monochrom> You need the extra information for an adventure game.
15:19:21 <conal> monochrom: how could you know such a thing?  "need" is a pretty strong term.
15:20:23 <conal> monochrom: it may turn out to be the case, but i sure wouldn't assume it going in.
15:21:45 <monochrom> I know because we all agreed that an adventure game is a graph.
15:22:13 <conal> monochrom: i didn't.  and even if we all it, we could all be wrong.
15:22:22 <conal> (if we all *did*)
15:22:34 <monochrom> We get to decide what an adventure game is. It is invented not discovered.
15:22:54 <conal> i like graph as a starting place.  then i'd go for simpler & more general.
15:23:08 <olsner> so, you define an adventure game as needing the extra information? :P
15:24:01 <conal> monochrom: the "invented, not discovered" is one tack.  it's not my favorite.
15:24:19 <SirLancer> I miss for-loops.
15:24:40 <kmcallister> SirLancer: for = flip mapM
15:24:52 <conal> SirLancer: that's the saddest thing i've heard all day. :(
15:24:55 <monochrom> Yes I say it to tease people. Most people are like "math is dicovered" and it's great fun to tease them this way.
15:25:27 <conal> monochrom: lol
15:26:14 <ddarius> The point is the proposed semantics of the adventure game is a graph.  There is no "extra information."  If anything, a graph may be too minimalistic.  You can choose a different semantics if you'd like.
15:27:18 <conal> ddarius: oh -- i thought we were still tossing around possibilities.  didn't realize there was attachment to the graph thing.
15:27:52 <conal> if you guys want to talk graphs, i won't disturb you.
15:28:27 <ppavelV6> if not anything else this channel is the great place to have fun :) very special humor :)
15:28:41 <conal> :)
15:28:54 <ddarius> conal: You can still toss around possibilities, but saying a graph has "extra information," in the same way that the term graph for an RTS has more information than the reduced form is non-sensical.
15:28:57 <kmcallister> monochrom: only platonists say that
15:29:56 <conal> ddarius: who sad "extra information"?  i must have missed it.
15:29:59 <jmcarthur> i don't think a zipper over a graph is a perfect fit. zippers usually provide ways to go back to nodes you have already visited, but presumably this is not always the case in an adventure game
15:30:15 <conal> ddarius: oh -- now i think i follow you.
15:30:31 <conal> ddarius: you didn't discover the sense, and you assume it wasn't there.
15:30:40 <conal> ddarius: right?\
15:30:43 <whpearson> jmcarthur: You can loop in an adventure game, pick up item, put down item.
15:31:01 <jmcarthur> whpearson, just because you sometimes can doesn't mean you always can
15:31:33 <monochrom> You can have a restricted zipper. It won't let to go all directions.
15:31:46 <jmcarthur> i could go for a directed graph with a zipper that respects the arrows i guess
15:32:09 <ddarius> I was going to add, "without, at least, giving an alternative semantics and some kind of reduction."  However, simply saying "expressions" and vaguely referencing RTSes doesn't lead to anything sensical to me.
15:32:11 <vixey> why do you want to zip?
15:32:17 <vixey> you don't edit the graph do you?
15:32:20 <jmcarthur> not sure i would call it a zipper any more though
15:32:30 <jmcarthur> vixey, good point
15:32:50 <conal> ddarius: so you only like contributions that reduce the space of exploration, not ones that expand it?
15:32:59 <vixey> if the nodes of the graph have mutable state then it may be possible to put a reference (e.g. Int or ST, anything like that) which points to a 'mutable' structure (like a Map)
15:33:10 <monochrom> Whether you edit the graph or not is determined by the zipper traversal function rather than the zipper data structure.
15:33:14 <jmcarthur> traversing, not zipping over, a directed graph sounds most appropriate
15:33:54 <jmcarthur> to me
15:34:11 <ddarius> conal: I didn't state whether I liked or disliked anything.
15:34:34 <conal> ddarius: my hope with such expanding comments is to stimulate more creative thinking.  i've found some people appreciate it more than others.
15:35:38 <monochrom> I appreciate reasoned creative thinking and disdain genetic-mutation creative thinking.
15:36:58 <ddarius> conal: The issue is your "expanding comment" is not connected to the discussion in, at least, a clear way.  You've not yet clarified which is why people aren't understanding you.
15:37:16 <ddarius> Hence, e.g. monochrom's comment about "confused transition(s)"
15:38:28 <ddarius> conal: I could, for example, say "Perhaps an adventure game is like an aardvark" which would also be an "expanding comment," but not likely a very useful one.
15:38:41 <A1kmm> Hi, I have a file larger than memory which contains a matrix of packed doubles (i.e. the whole file is a sequence of 8-byte doubles, arranged column-by-column then row-by-row). I want to try out algorithms that work on pairs of rows at a time, but I'm not really sure what will work efficiently.
15:38:48 <A1kmm> I have considered using unsafePerformIO to read in a non-lazy ByteString for a single row at a time (reading rows shouldn't have side effects as the file is considered immutable) and coercing from ByteString to a vector via the native pointer interface, but that seems messy.
15:38:55 <blackh> ddarius: But an adventure game might have an aardvark in it.
15:38:56 <A1kmm> Anyone have any suggestions on the best way to achieve this?
15:39:11 <conal> i sense things are heating up again, which doesn't make for the fun & creative environment i enjoy.  so i'll drop it.  if anyone gets my meaning, that's lovely.  if anyone doesn't and is curious, i'm happy to have a conversation in a fresh context.
15:39:27 <ddarius> blackh: If I can -explain- why I think an adventure game is like an aardvark, then maybe it would be useful, but the statement alone is unlikely to be useful.
15:40:08 <conal> i admit that i tend to get annoyed when someone applies a label like like "not useful" or "non-sensical" instead of admitting that they don't get the use or sense.
15:40:59 <vixey> I want to reask my question,
15:41:08 <vixey> (since we aren't in the middle of a netsplit)
15:41:31 <ppavelV6> A1kmm: hmm. why unsaferPerformIO?
15:41:45 <blackh> A1kmm: Lazy Bytestrings + Data.Binary.Get (from the binary package) would be a good starting point.
15:42:09 <ddarius> conal: You point out above that you feel that you and monochrom have had "a communication glitch," but then you never address it.
15:42:14 <conal> i guess i naively expect people to simply ask when they don't understand something, instead of applying a label like "non-sensical".  and once i hear such a label, i expect there's not much authentic curiosity.
15:42:18 <A1kmm> blackh: Doesn't Data.Binary.Get mean reading a Double at a time?
15:42:21 <blackh> A1kmm: You'd need to decode your doubles, and I don't think there is anything wrong with an ffi-level hack to do this.
15:42:27 <vixey> would there be any sort of framework to study/unify/.. the various sys-f'ish type systems.. things like rank 2, rank 2, boxy types, pred/impredicative polymorphim, typeclasses, fundeps, associated types, F(c), etc.. in the same style as Henks Lambda Cube is for PTSs?
15:42:55 <conal> ddarius: so?  i didn't address it.  glitches happen.
15:43:00 <blackh> A1kmm: Data.Binary.Get is efficient and lazy, which is good all round.
15:43:26 <conal> ddarius: IRC is such a thin channel, i something just notice communication isn't working and let it go.
15:43:37 <conal> if we were face-to-face, it'd be much easier, and i'd keep trying.
15:44:46 <A1kmm> blackh: also, doesn't Data.Binary.Get require a Data.ByteString.ByteString, not a Data.ByteString.Lazy.ByteString for actual IO?
15:44:47 <vixey> you don't want to get your mind stuck on a single train of thought
15:44:51 <ddarius> conal: I'm not particularly curious and I wasn't asking.  I was stating the situation as I saw it in some hope that it would resolve the "communication glitch."
15:45:19 <conal> ddarius: i'm glad to know.  thanks for your effort & intention.
15:45:27 <ddarius> conal: In a different vein, if you are going to decide to just "let [a conversation] go," you might want to inform the other participants.
15:45:43 <blackh> A1kmm: If you read your doubles as Word64's, you could cast a pointer using FFI.I think Data.Binary.Get uses a lazy bytestring for I/O but I have not actually used it in anger.
15:45:56 * vixey (I guess the answer to my question is no such thing exists)
15:45:58 <__Ali__> in a parallel application, when wrapping c/c++ to haskell, does it make sense to have haskell as the paralleliser driver, or should we use mpi in the c++ part?
15:46:22 <conal> ddarius: yes -- i see i could have been more explicit than i was.
15:46:36 <monochrom> vixey: The trouble is everyday people come up with a new framework.
15:47:24 <conal> okay -- back to work for me.  take care, fellow haskellers.
15:48:04 <monochrom> There are a time F_c was a ruling framework. It didn't rule long.
15:48:09 <monochrom> s/are/was/
15:48:10 <vixey> well yes
15:48:26 <ehird> @type \f a b -> map (uncurry f) $ zip a b
15:48:27 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:48:40 <vixey> I want to study F-ish type systems in more generality
15:48:42 <McManiaC> how can i convert a float to int?
15:48:53 <catface> anyone know if you can get a newline in the GHCi prompt?
15:48:54 <vixey> not like specific instances like you choose using {-# LANGUAGE ... #-}
15:49:04 <monochrom> The ruling frameworks are now like F_c^w|<:{}:[]...
15:49:40 <catface> McManiaC: round or floor
15:49:40 <monochrom> And every once in a while someone gives an extension of one of the frameworks.
15:50:03 <monochrom> There seems to be no end to this.
15:50:29 <McManiaC> thx
15:50:30 <McManiaC> :)
15:51:29 <vixey> I wonder if they are all pretty much just described by one thing
15:51:37 <A1kmm> blackh: I looked into Data.Binary, it seems it does have a lazy ByteString, and it uses the internal interface to make the chunk it is working on strict.
15:51:43 <vixey> maybe there is a natural coherent way to look at the whole spectrum
15:51:52 <vixey> but.. I guess that nobody really has written about such a thing
15:52:32 <A1kmm> blackh: Although I still think I will need to somehow convert an entire vector (row) of doubles at a time, not a single double, to get the performance I am looking for.
15:53:18 <pumpkin_> can someone remind me why instance (X a) => (Y a) is bad, but instance (X a) => Z (Y a) isn't?
15:53:31 <pumpkin_> oh wait
15:53:35 <pumpkin_> Y (Z a)
15:53:42 <ppavelV6> A1kmm: what do you mean by converting the entire vector ? with single opcode? minimizing function calls?
15:53:45 <blackh> A1kmm: This is possible, though I wouldn't assume it, because Haskell can be very efficient.
15:53:55 <dolio> rank-2 types is just another somewhat arbitrary limitation to whatever System-F you're in.
15:54:16 <dolio> Like only allowing 2nd order functions or something.
15:54:28 <ppavelV6> A1kmm: I think it's better start simple than probably look into core and do some measurements
15:54:37 <pumpkin_> doesn't the former one typically require FlexibleInstances?
15:54:55 <jmcarthur> overlapping, no?
15:54:59 <pumpkin_> oh, maybe
15:55:02 <pumpkin_> I can't remember
15:55:06 <Saizan> pumpkin_: the latter is provably terminating, also the former likely overlaps with other instances
15:55:22 <pumpkin_> what if you're sure it doesn't?
15:55:25 <pumpkin_> (overlap)
15:55:31 <Saizan> you need to allow FlexibleInstances and UndecidableInstances
15:55:34 <A1kmm> ppavelV6: Probably, although it does seem wasteful to copy an extra time when I am aiming for efficiency.
15:55:35 <pumpkin_> hmm
15:55:39 <Saizan> then it's ok
15:55:49 <ppavelV6> A1kmm: oh, copying... right
15:55:52 <jmcarthur> pumpkin_, you can't be 100% sure unless you also can disallow orphans (not exporting the type class, for example)
15:56:19 <pumpkin_> so the issue is roughly that you're not removing (simplifying) anything in the former case and are in the latter, so in the former case it could keep going?
15:57:06 <pumpkin_> it seems reasonable to be able to say that all Integral values are also X
15:57:07 <ppavelV6> A1kmm: I'd still keep my advise to leave it for later when you'll get numbers for the real situation though ;)
15:57:26 <pumpkin_> but I just don't get why it only works if you wrap it
15:57:34 <jmcarthur> pumpkin_, what if you could say that in order to be an Integral it must first be X?
15:57:56 <Saizan> pumpkin_: btw for that instance to not overlap it means that you don't have any other instances of Y around
15:57:57 <jmcarthur> pumpkin_, like the whole Functor, Applicative, Monad hierarchy
15:58:02 <pumpkin_> ah hmm
15:58:20 <pumpkin_> so it would allow circular messes
15:58:21 <Saizan> pumpkin_: since the context is not taken in consideration during resolution, it's only checked after an instance head matches
15:58:25 <A1kmm> ppavelV6: Although unless I am going to copy the vector for every column of the row I add, it seems that I don't need to try it to know it would be slow.
15:58:57 <ppavelV6> A1kmm: probably you're right here
15:59:37 <infoe|wk> :t flip flip
15:59:38 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
16:00:13 <pumpkin_> I think I see
16:00:22 <Gracenotes> flippity flip flip la
16:00:23 <pumpkin_> does TAPL cover System F?
16:00:27 <jmcarthur> yes
16:00:28 <Gracenotes> yes it does.
16:00:38 <pumpkin_> alright, I should read more :)
16:00:55 <pumpkin_> how about an unrelated question... does anyone know what a zygohistomorphic prepromorphism actually is?
16:00:59 <Gracenotes> it covers it rather late. I have a .chm of it somewhere... it's in the last subsection
16:01:01 <A1kmm> ppavelV6: So perhaps writing code to get a strict ByteString of a certain length at a certain offset of a lazy ByteString, and then using FFI to coerce it to a vector would be the way?
16:01:08 <pumpkin_> Gracenotes: I have the book at home, checked out from the lbi
16:01:10 <pumpkin_> lib
16:01:18 <pumpkin_> just haven't had a chance to read it yet
16:01:39 <jeffwheeler> Is there an obvious way to get the current directory through System.IO or similar?
16:01:41 <A1kmm> as long as I do copy on the lazy bytestring first so the strict one is GCd of course.
16:01:53 <jmcarthur> pumpkin_, TAPL is very much a text book. tough to just "read"
16:01:54 <jeffwheeler> It seems like I'm missing something obvious here. I just want a pwd-equivalent.
16:01:58 <dmhouse> ?hoogle getCurrentDirectory
16:01:58 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
16:02:09 <jeffwheeler> dmhouse: perfect, thanks.
16:02:11 <pumpkin_> jmcarthur: yeah, but I do tend to "just read" textbooks :)
16:02:14 <jmcarthur> more like "study" ;)
16:02:25 <pumpkin_> but of course, that's what I mean ;)
16:02:25 <vixey> unless you're the kind that eats monad transformers for breakfast and uses PhD thesis as bedding material
16:02:32 <pumpkin_> lol
16:03:20 <jmcarthur> those theses don't stand a chance against my violent reading comprehension
16:03:34 <pumpkin_> lol
16:03:43 <pumpkin_> so I take it no one knows the answer to my second question? :P
16:03:51 <vixey> yeah you got to approach it like a fight to the death
16:03:57 <Gracenotes> you has second question?
16:04:06 <pumpkin_> <pumpkin_> how about an unrelated question... does anyone know what a zygohistomorphic prepromorphism actually is?
16:04:11 <jmcarthur> pumpkin_, maybe edwardk or somebody would know
16:04:17 <dolio> The answer is: no, no one knows.
16:04:20 <Gracenotes> we have a wiki page on it
16:04:22 <jmcarthur> it was invented as a joke though :P
16:04:28 <pumpkin_> Gracenotes: I've seen it :P
16:04:30 <pumpkin_> didn't help ;)
16:04:31 <vixey> I don't think it's a joke
16:04:38 <pumpkin_> http://www.reddit.com/r/programming/comments/6ml1y/a_pretty_useful_haskell_snippet/?sort=new
16:04:56 <pumpkin_> he explains a bit there
16:04:57 <Gracenotes> it's not a joke, it's just useless
16:05:02 <pumpkin_> but I'd like more detail!
16:05:37 <Gracenotes> DENIED
16:06:49 <seafood> Is gtk2hs at hackage?
16:07:14 <Gracenotes> no, but it's on Facebook
16:07:17 <Gracenotes> "it's complicated"
16:07:23 <Gracenotes> :/
16:07:40 <seafood> Gracenotes: :)
16:07:46 <MyCatVerbs> seafood: 'fraid not. It hasn't been Cabalized, so you'll have to either install it from the tarball or your distro's repositories might have it. (I'm not sure what the situation with gtk2hs on Windows)
16:09:34 <jeffwheeler> seafood: no, but the latest release works in GHC 6.10.1
16:17:31 <vixey> anyone read Computational Semantics?
16:20:06 <revadak> im reading semantical computation
16:32:31 <Gracenotes> in which cases would a Stream be useful?
16:32:39 <Gracenotes> what.
16:33:23 <Gracenotes> it's pretty neat, but.. would it be of use in any cases?
16:34:20 <ddarius> When is an infinite list useful?
16:34:36 <vixey> I use infinite lists
16:34:42 <ddarius> (or perhaps you mean a different type of Stream (?))
16:36:05 <Gracenotes> I dunno. It seems a list would suffice.
16:36:43 <Gracenotes> and it has some nice RULES, etc. It is a neat type, though.
16:36:48 <Gracenotes> Stream.
16:36:58 <ddarius> Gracenotes: And instead of having a list type, we could simply have a tree type.
16:37:41 <Gracenotes> you mean a graph type? >_<
16:38:18 <ddarius> Actually I meant a hypergraph type.
16:39:17 <vixey> what's a hypergraph
16:39:47 <vininim> graph where edges connect multiple vertices?
16:40:47 <ddarius> That's what wikipedia says, albeit it has a strange restriction that there actually be edges.
16:41:55 <Gracenotes> a finite automaton based on a hypergraph would probably be quantum?
16:42:21 <Gracenotes> s/finite //
16:43:28 <vininim> nondeterminism is already mapped to quantum mechanics. =P
16:43:47 <Gracenotes> aww then.
16:59:26 <SirLancer> Why is it common to use uninformative variable names in Haskell?
17:00:00 <SirLancer> Even uninformative function names
17:00:24 * shapr boings cheerfully
17:00:36 <vixey> byye shapr
17:00:40 <shapr> bye?
17:00:42 <jmcarthur> SirLancer, typically top level declarations are informative
17:00:51 <shapr> vixey: Am I so clearly transient? :-)
17:00:58 <vixey> :p
17:01:02 <jmcarthur> SirLancer, parameters typically aren't because they are not very specific in the first place
17:01:05 * shapr GCs himself...
17:01:30 <monochrom> I haven't seen many uninformative names.
17:01:38 <jmcarthur> for example, "map f (x:xs) = f x : map f xs" ... is there anything more sensible to use in place of f, x, and xs?
17:01:51 <Adamant> jmcarthur: function for f
17:01:54 <Adamant> or func
17:02:05 <jmcarthur> but we already know its type from the type signature that you should have put there ;)
17:02:37 <jmcarthur> is "map function (item:remaining) = function item : map function remaining" really any more informative?
17:02:37 <monochrom> @quote thatwhich
17:02:37 <Adamant> yes, but a small bit of redundancy doesn't hurt.
17:02:37 <lambdabot> No quotes match. There are some things that I just don't know.
17:02:51 <Adamant> I like the x:xs bit
17:02:53 <SirLancer> (x:xs) is very confusing if the concept is not familiar
17:03:00 <dolio> "function" is not more sensible.
17:03:05 <Adamant> some specialized terminology is good.
17:03:07 <monochrom> I used to have a parody of "informative" names.
17:03:31 <Adamant> dolio: func isn't that bad
17:03:43 <jmcarthur> x:xs is a rather standard thing to do in Haskell though, so it isn't so unexpected.
17:03:57 <jmcarthur> i don't see how func helps any more than f
17:04:01 <SirLancer> having a function called function or f doesn't really tell what it does
17:04:01 <Adamant> jmcarthur: yes, I agree, but it is odd when you're learning the language
17:04:05 <jmcarthur> f is standard terminology for functions anyway
17:04:17 * Adamant shrugs
17:04:20 <jmcarthur> SirLancer, but we don't _know_ what it does. that's the point
17:04:22 <dolio> It's 4 times as long, and it's already obvious that it's a function, because functions are the only things that can be applied like "f x".
17:04:28 <monochrom> Precisely because some library functions are very general, there is not much you can do to give their parameters informative names. The information is just not there to begin with.
17:04:52 <Adamant> dolio: rm, ls!
17:05:00 <Adamant> great names thar.
17:05:24 <ddarius> There's also another aspect.  The smaller the scope, the less informative names tend to need to be.
17:05:29 <kadaver> Sir Lancer: I found the same at first, a lot of cryptic hosr tnames  but a lot of them are so common u get used to it and (x:xs) makes code very clean. f and p is also clear, f for function and pfor predicate, ie a function :: a -> Bool
17:05:31 <monochrom> If you think there is more information, it's likely because your mind is stuck with one particular application and you miss other unsimilar applications.
17:06:18 <inimino> ls probably should have just been l
17:06:42 <ddarius> monochrom: Trawl that monoid mailing list discussion and you can probably find your parody.
17:06:47 <jmcarthur> ls should have been heycomputercouldyoulistthefilesinthecurrentdirectoryplease
17:06:49 <inimino> ...but it's about three decades too late to worry about it
17:07:11 <matthewp> Going back and forth from Haskell and was wondering what would be a good way to do a transform such as this using a map: http://gist.github.com/87967
17:07:19 <matthewp> Any ideas?
17:07:39 <Adamant> jmcarthur: or they could have done it VMS-style and kept rm and ls around for those who want to use abbreviations
17:07:41 <monochrom> where is that monoid mailing list? I was never on it.
17:09:07 <ddarius> Map A (Map B C) ~ Map (A,B) C
17:09:07 <matthewp> a fold would be an answer, but looking for other options as well
17:09:12 <pastah> i'm having some GHC trouble
17:09:34 <SirLancer> you're with friends now
17:09:38 <pastah> i want to do ghci -m A/Lol.hs
17:09:52 <pastah> but Lol.hs has imports from A/B/Import.hs
17:09:58 <matthewp> ddarius: right, just trying to transform through some sort of pivot
17:10:16 <pastah> and i can't get it to work, the "-i" flag doesn't help
17:10:36 <SirLancer> Okay I'm really new to Haskell but I'm gonna stick with informative variable and function names.
17:10:54 <SirLancer> Because I might forget what my functions do
17:11:22 <monochrom> Oh, functions that actually do something specific, of course they need better names.
17:11:29 <SirLancer> Like would you name your kids J and K just because you want to be able to call them faster?
17:12:36 <matthewp> any takers on the issue?  Trying to go back and forth on the collective intelligence to Haskell and back
17:13:14 <McManiaC> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3126#a3126 <-- can anyone spot a mistake? :(
17:13:37 <SirLancer> monochrom: It's also more fun to make functions that do something specific.
17:13:38 <ddarius> McManiaC: The compiler can.
17:13:45 <McManiaC> nope =(
17:13:58 <McManiaC> Ok, modules loaded: Main.
17:13:59 <McManiaC> *Main>
17:14:12 <jmcarthur> SirLancer, i think your kids are important enough to get informative names. somebody else's kids, however...
17:14:29 <monochrom> I call my kids Jim and Kirk. That's like calling a function "foldl"
17:15:08 <ddarius> Jim and Kirk are more informative than J and K?
17:15:17 <SirLancer> It would be really confusing if all people had a name of one letter.
17:15:28 <ddarius> I'd say they're less informative.  More people named Jim or Kirk than named J or K.
17:15:37 <monochrom> Does anyone call my kids the full "Jameius Tiberius Kirkusos"? That's like calling a function "apply_a_binary_operator_from_left_to_right_with_seed"
17:15:40 <jmcarthur> if i'm serving a line of kids food in a school cafeteria, it's not necessarily helpful for me to know all their names
17:15:44 <adamvo> apropos short variable names, there was a ghc bug where long variable names weren't inlined as frequently as short ones? I can't seem to find it
17:16:09 <dolio> It was long module names.
17:17:03 <SirLancer> My functions are my legacy.
17:17:18 <ddarius> McManiaC: You're giving read a value in the wrong format.  You haven't provided enough information to say anything more than that.
17:17:20 <matthewp> sigh, ok, back to hacking then....
17:17:59 <monochrom> I mean on a daily basis of course.
17:18:12 <pluto> does anybody know how to convert a Ratio Integer to a decimal string without precision loss and standard libraries?
17:18:53 <ddarius> Albert C. Lai: You have a kid and his (her?) name is Jameius Tiberius Kirkusos?
17:19:08 <monochrom> Some namings you see in other communities are called "informative" but turn out to be pretentious and pompous.
17:19:17 <jmcarthur> > fromRational $ 2%7 :: CReal
17:19:18 <lambdabot>   0.2857142857142857142857142857142857142857
17:19:37 <jmcarthur> @hoogle CReal
17:19:37 <lambdabot> No results found
17:19:45 <jmcarthur> err.... it's around
17:20:09 <SirLancer> I don't even use peoples nicknames and ironically, when I talk about people to other people I DO use their first and last names.
17:20:10 <monochrom> Some turn out to be hilarious. supportsDataManipulationAndMetaManipulationAsWellAsMetaDataManipulationAndByTheWayThreadSafe
17:20:39 <jmcarthur> SirLancer, but you are still addressing specific people. the question is whether you would assign false names to anonymous people
17:20:43 <monochrom> That is what I have in mind when people say "informative names".
17:21:11 <monochrom> pretentious, pompous, hilarious.
17:21:16 <SirLancer> monochrom: Yeah because the only option is to either use one letter or ridiculously long names?
17:21:41 <monochrom> OK, so how are "map", "foldl", "unfoldr" uninformative?
17:22:00 <McManiaC> ddarius: its been working until i put in the take n... damnit =((
17:22:34 <SirLancer> jmcarthur: I would call anymonous people by what they can do. For example the lady who cleans is a cleaning lady.
17:22:43 <erikc> monochrom: i debugged one of those, and the best part was the threadsafety was commented out with // implement later
17:22:54 <monochrom> haha
17:23:09 <jmcarthur> SirLancer, so you would say "map funcFromAToB (a:as) = ..."?
17:23:36 <SirLancer> I don't want to continue discussing this subject.
17:23:46 <SirLancer> I wish to discontinue.
17:23:53 <ddarius> jmcarthur: We can be like Smalltalk and have variable names like "theNumber", "theList"
17:24:00 <ddarius> or "aNumber"
17:24:14 <monochrom> theMother  (sorry couldn't resist)
17:24:15 <lament> klass
17:24:23 <monochrom> El Sid
17:24:44 <jmcarthur> different languages also may have different naming requirements
17:25:03 <monochrom> MyFairLady
17:25:08 <lament> just name all variables after chinese characters
17:25:20 <lament> s/after//
17:25:26 <jmcarthur> lament, not Greek characters?
17:25:37 <SirLancer> The guy who teaches Haskell at our university uses one-letter names for everything.
17:25:47 <monochrom> map 甲 (乙:乙們)
17:26:00 <lament> hehe
17:26:01 <jmcarthur> monochrom, :(
17:26:19 <monochrom> You like greek letters?
17:26:38 <jmcarthur> i at least know what to call most of them
17:26:40 <jmcarthur> ;)
17:26:59 <monochrom> map ξ (ζ:ζς)
17:27:33 <jmcarthur> they are also just prettier, in my opinion
17:27:43 <lament> than chinese characters? No way.
17:27:49 <lament> You just need to work on your brush technique.
17:28:00 <jmcarthur> it's probably my font, right now
17:28:17 <jmcarthur> chinese characters can certainly be gorgeous
17:28:30 <jmcarthur> i like arabic even more though
17:28:48 <Debugger> Yeah
17:29:00 <Debugger> Japanese and arabic are my favorites
17:29:04 <monochrom> The direction of "f . g" makes more sense in Arabic. :)
17:29:15 <SirLancer> they have a character per word
17:29:42 <jmcarthur> i hope you are talking about chinese
17:29:45 <SirLancer> I wonder how you guys would abbreviate them
17:30:23 <jmcarthur> we wouldn't. we would just use the most generic word that still fits the intended meaning
17:30:45 <monochrom> Oh easy. profit warning = 盝利警告 abbreviated as 盝警
17:31:12 <monochrom> Think of it as "profwarn"
17:31:32 <skorpan`> the first one is just a big box over here
17:33:06 <njbartlett> Chinese doesn't really have a character per word, and Japanese certainly doesn't
17:33:51 <monochrom> oops. 盈利警告, 盈警
17:33:58 <SirLancer> they don't?
17:33:58 <ddarius> 口
17:34:07 <SirLancer> hmm
17:34:21 <monochrom> No fixed rule about how many characters per word.
17:35:04 <SirLancer> Yeah but don't they have symbols for words?
17:35:28 <monochrom> Word boundaries are not marked out, if that's want you mean.
17:36:02 <monochrom> Hell, we learned punctuations from Europeans. We didn't have them 300 years ago.
17:36:20 <monochrom> Even 100 years ago.
17:36:40 <SirLancer> So everybody talked like Christopher Walken :D
17:36:41 <kadaver> well for example in chris okasaki book he ueses R and B instead of Red and Black and while it is obvious what it means there i stll find using Red and Black is clearer, or perhaps not clearer but eaiser to read. just a concentration o lots of single characters is hareder for my to parse mentally
17:37:04 <monochrom> When speaking we have pauses at phrases clauses sentences... of course.
17:37:40 <SirLancer> Christopher Walken is said to speak without punctuation.
17:37:49 <SirLancer> His words just flow.
17:40:21 <SirLancer> I don't know why I thought the Chinese would have a symbol for each word if it isn't so like you say.
17:40:22 <ddarius> As if from a sputtering faucet.
17:42:01 <kadaver> matthewp: can you give an example of what the function does? i dont get quite what it does from reading the code
17:42:29 <matthewp> kadaver: sure, hold on, let me mock it up
17:42:42 <matthewp> say we have a data set that looks like the following
17:43:02 <SirLancer> let it in!
17:43:35 <matthewp> fromList [("Some Critic", fromList [("Some Movie", 4.5), ("Another Movie", 5.0)])]
17:43:48 <matthewp> Now we want to transpose those values to something like this
17:44:23 <matthewp> fromList [("Some Movie", fromList [("Some Critic", 4.5)])]
17:44:41 <matthewp> make sense?
17:45:07 <conal> does anyone have a handy ref to vector types with the length embedded in the type?
17:46:10 <dolio> There isn't a lot to them.
17:46:54 <matthewp> kadaver: I was thinking of nested folds to get at it, but kind of stumped
17:50:08 <kadaver> matthewp: yes i see
17:51:46 <matthewp> kadaver: any ideas?
17:54:24 <kadaver> im thinking
17:59:05 <kadaver> yes nested folds seems like the way to go
18:00:56 <matthewp> kadaver: ok, I got that far, but what the accumulators are, I'm not sure
18:04:34 <liyang> conal: what do you mean? Vectors indexed with type-level numbers? What sort of 'reference' are you after?
18:05:17 <kadaver> matthewp im working on it
18:07:04 <kadaver> arent Maps showable by default?
18:07:43 <matthewp> kadaver: should be
18:08:16 <shapr> Cale: Hey, will you be physically near McMaster next week? Want to hang out?
18:09:10 <Cale> Um, I'm in Brantford
18:09:55 <Cale> Which is under an hour away, but I don't have a car.
18:10:41 <shapr> Cale: Oh, that's too bad.
18:10:54 <shapr> Cale: Well, I'm driving up, I could visit YOU!
18:11:07 <Cale> If you'd like :)
18:11:18 <shapr> Sure! That would be cool!
18:12:04 <shapr> Cale: Any other Haskellers in the area other than desrt?
18:12:14 <pumpkin> :o
18:12:29 <Cale> Actually, my dad works near Hamilton as well, so I might just be able to work something out with him too.
18:12:46 <shapr> That would be nifty!
18:13:19 <DarthArachides> I think there are several at Waterloo
18:14:20 <shapr> How far away?
18:14:23 <Cale> Yeah, I heard something to the effect that after I left, there was a bit of an resurgence of Haskell popularity there :)
18:14:28 <shapr> Should I get us a venue for talks? :-)
18:15:05 <shapr> It would be cool to hang out and talk about cool code. Sadly all my recent code has been C# or IronPython.
18:15:34 <pumpkin> wow, university of waterloo is at almost the same latitude as I am
18:15:40 <shapr> DarthArachides: Got any names or pointers?
18:16:27 <DarthArachides> shapr: no, I don't know anyone personally, but let me ask in the club channel
18:16:38 <shapr> Yes please!
18:16:44 <kadaver> matthewp: im going to bed,might solve it tomorrow though goodnight all
18:16:53 <shapr> mattam: Hey! Are you back?
18:16:55 <matthewp> shapr: join the club, or the F# one :-)
18:17:19 <shapr> Which club?
18:17:32 <matthewp> shapr: The not doing much Haskell as I'd like club
18:17:36 <shapr> Oh right, that club...
18:18:08 <shapr> I haven't quite gotten to the point of trying to write SharePoint code with IronPython, I haven't gotten around to figuring out if I can just deploy all the DLLs in a wsp, but I don't see why not.
18:18:12 <shapr> Aanyway...
18:18:12 <matthewp> shapr: Just banging my head against the wall trying to convert a Map transpose to Haskell : http://gist.github.com/87967
18:18:24 <matthewp> from Python of course
18:19:10 <shapr> It should be something like 'map . map (\x y -> y x)'
18:19:18 <mimcpher> lisp > haskell, etc.
18:19:39 <shapr> I totally agree with him from some viewpoints.
18:20:01 <shapr> For example, it's a lot easier to do macros with lisp, since its syntax is its abstract syntax tree!
18:20:13 <matthewp> shapr: well, shapr: the idea is to take this: fromList [("Some Critic", fromList [("Some Movie", 4.5), ("Another Movie", 5.0)])]
18:20:15 <shapr> That's a powerful property.
18:20:27 <matthewp> shapr: to this fromList [("Some Movie", fromList [("Some Critic", 4.5)])]
18:20:52 <shapr> oh
18:21:12 <pumpkin> another netflix challenge?
18:21:29 <matthewp> shapr: it's a head scratcher for me, I know nested folds are an option here
18:21:38 <shapr> matthewp: Well, break it down...
18:21:41 <matthewp> pumpkin: no, this is the Collective Intelligence book
18:21:43 <pumpkin> ah
18:21:59 <matthewp> pumpkin: well, I'll get to that one shortly again
18:22:09 <shapr> for x in items: is pretty much map.
18:22:13 <orzo> is tehre a way to send an email to a trac user?
18:22:39 <matthewp> shapr: I see where you're going with that
18:22:51 <matthewp> shapr: hmmm, I way overcomplicated it I think
18:25:45 <matthewp> shapr: with the understanding that the inner becomes the outers key instead
18:28:54 <pumpkin> matthewp: doesn't seem hard
18:29:13 <chessguy> it's not, it's just really tedious
18:29:14 <pumpkin> it's essentially a flip operation
18:29:14 <matthewp> pumpkin: I know it shouldn't be, but it's been a long day
18:29:30 <pumpkin> if you think of it as a two-parameter function, it is just a flip
18:29:48 <chessguy> i think it's more like a transpose
18:29:55 <pumpkin> I mean
18:29:56 <pumpkin> :t flip
18:29:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:31:43 <matthewp> keeping in mind this is the type we're dealing with:
18:31:52 <matthewp> Map String (Map String Double)
18:31:57 <pumpkin> yeah
18:32:33 <matthewp> pumpkin: ok walk this through then with a flip
18:36:21 <pumpkin> how about: Map.fromListWith (Map.union) . concatMap (\(x, y) -> [(a, Map.singleton x b) | (a, b) <- Map.toList y]) . Map.toList
18:36:36 <pumpkin> not sure if that's sufficient
18:37:08 <pumpkin> > Map.fromListWith Map.union . concatMap (\(x, y) -> [(a, Map.singleton x b) | (a, b) <- Map.toList y]) . Map.toList $ Map.fromList [("Some Critic", Map.fromList [("Some Movie", 4.5), ("Another Movie", 5.0)])]
18:37:10 <lambdabot>   fromList [("Another Movie",fromList [("Some Critic",5.0)]),("Some Movie",fr...
18:38:37 <matthewp> pumpkin: looks interesting, let me give it a shot
18:38:55 <pumpkin> it's probably not very efficient, not sure
18:39:00 <mib_cmqfb9> Hello everyone
18:39:14 <pumpkin> hello Mr. Mib!
18:39:16 <matthewp> pumpkin: it's gotten me further than other solutions have
18:42:46 <bondu> hi
18:42:58 <abdullah_ak2002> lamdadot : fromList [("Another Movie",fromList [("Some Critic",5.0)]),("Some Movie",fr... ?
18:43:00 <bondu> anyone here programmer?
18:43:10 <abdullah_ak2002> What exactly is this for?
18:43:31 <pumpkin> abdullah_ak2002: it was a response to my message
18:43:43 <pumpkin> lambdabot ran the haskell code I posted
18:43:56 <bondu> hi pumpkin
18:43:58 <pumpkin> bondu: I should hope so
18:44:05 <bondu> k cool
18:44:10 <bondu> i need help
18:44:14 <pumpkin> but it isn't a "programming" channel
18:44:17 <pumpkin> it's a haskell channel ;)
18:44:22 <bondu> agree
18:44:26 <pumpkin> ok :)
18:45:05 <bondu> i have c code which outputs time but i don't know how to interface it with microcontroller
18:45:07 <bondu> ?
18:45:18 <pumpkin> <pumpkin> it's a haskell channel ;)
18:45:27 <bondu> hm
18:45:42 <bondu> so no programming discussion
18:45:45 <bondu> ?
18:46:15 <bondu> k thanks later
18:46:22 <pumpkin> well, it has to be at least vaguely related to the topic of the channel :P your question is too general to answer even in a microcontroller channel because you haven't given enough information :)
18:46:26 <pumpkin> lol
18:48:08 <abdullah_ak2002> ok anyone have any idea as to how to import Graphics.UI.GLUT?
18:48:32 <abdullah_ak2002> cabal?
18:48:35 <pumpkin> cabal install glut
18:49:00 <abdullah_ak2002> great
19:01:39 <abdullah_ak2002> I tried installing cabal bt it did not work
19:01:49 <abdullah_ak2002> I am running ubuntu 8.04
19:02:34 <kadaver> matthewp: it disturbed so had to fix it
19:02:37 <kadaver> i almost have ot
19:02:39 <kadaver> it
19:02:46 <kadaver> just need to insert back in
19:03:15 <abdullah_ak2002> I downloaded cabal from http://www.haskell.org/cabal/ and followed the instructions to install it
19:03:38 <blackh> abdullah_ak2002: Download cabal-install package and run the script called 'bootstrap.sh'
19:04:32 <abdullah_ak2002> blackh: ok thanks I'll try that
19:04:48 <blackh> abdullah_ak2002: You'll need some Ubuntu packages... zlib1g-dev is one of the ones you'll want...
19:05:01 <blackh> abdullah_ak2002: Also libgmp3-dev
19:05:20 <matthewp> kadaver: ok, great!
19:05:27 <matthewp> kadaver: yes, it's a tricky problem
19:05:35 <blackh> abdullah_ak2002: (Not sure about that one!)  But you also need libcurl4-gnutls-dev
19:09:22 <conal> liyang: (delayed response) nm.  i have it now.  thx.
19:12:01 <kadaver> meh
19:12:01 <kadaver> how do I update an innermap?
19:13:15 <BMeph> Why would an Ubuntu user need to download the gmp package?
19:13:39 <blackh> BMeph: That's a mistake. I was getting mixed up with building ghc, which I do on a regular basis. :)
19:16:34 <guenni> am I the only one who finds Olegs articles a challenging read?
19:16:56 <BMeph> blackh: Ah, okay. I just want to be sure we're passing out the good gouge on builds here. :)
19:17:02 <kadaver> updateInner (m,c,g) im = M.insert m (M.fromList [(c,g)]) M.empty
19:17:05 <dolio> Yep. They're all a piece of cake.
19:17:08 <kadaver> fromList [("somecritic",fromList [("smoemovie",4)])]
19:17:25 <kadaver> so how do I insert into the inner map if there is somehting there alresady?
19:17:33 <BMeph> guenni: I find it easy-going up until I analyze how the program actually does what is does. :)
19:17:35 <kadaver> ie update or soemhitng
19:17:38 <abdullah_ak2002> blackh: Successfully installed cabal
19:17:47 <BMeph> *what IT does.
19:18:13 <byorgey> guenni: oh, totally.  today I read three at once while riding my bike to school and writing a paper.
19:18:30 <byorgey> ;)
19:18:47 <guenni> byorgey: how did that work for you?
19:19:06 <byorgey> guenni: pretty well until I ran over that cat
19:19:07 <catface> so is curry isomorphic to howard then?
19:19:40 <guenni> byorgey: hope you got away before the owner showed up :)
19:19:57 <BMeph> kadaver: Wouldn't it be more like (Just . M.insert fInner cMap), or some such? :)
19:20:06 <byorgey> hehe =)
19:20:09 * shapr boings
19:20:16 <shapr> vixey!!
19:20:28 * byorgey throws rubber lambdas at shapr
19:20:38 * BMeph reads catface's comment, then gives him a rimshot
19:21:18 <guenni> has anyone here tried to replace Data.Maps with "Zipper" for instance
19:23:48 <shapr> hiya byorgey!
19:24:39 <BMeph> guenni: In what instance? :)
19:25:11 <BMeph> kadaver: Sorry, I see you changed it to an insert at the last moment. NM, then - "carry on!" ;)
19:25:24 <_dls_> hey guys, I'm hoping I can get a bit of help with class polymorphism... I understand that very abstractly typed functions are desirable, but I believe that my case motivates the use of instance types. (though I'm new here, so not sure). 8 line paste here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2012#a2012
19:26:10 <guenni> well I got a Map String (Map Int (Map Int Double)) and do not like it, I wonna replace it with something better
19:26:52 <blackh> guenni: Map (Int,Int) Double ?
19:27:04 <BMeph> _dls_: Got the fever for the flavor of a JSON encoder? ;)
19:27:10 <blackh> guenni: Of course I meant to say Map (String, Int, Int) Double
19:27:37 <guenni> blackh:hm, that would work
19:27:39 <_dls_> BMeph: yeah, I bet they hit the same problem. know a good one?
19:28:32 <BMeph> _dls_: I'd d/l one of the hackage packages, and blatantly rip it off. With proper accreditation, of course... ;)
19:29:23 <_dls> BMeph: thanks, found a good one :)
19:30:04 <guenni> blackh: that's so typical, the simplest and most obvious solution usually pass right over my head
19:35:22 <pumpkin> matthewp: did you have any luck?
19:35:38 <kadaver> pumpkin : im almost there
19:35:50 <kadaver> jsut trying tou figure out how to isnert into an inner map
19:36:13 <pumpkin> didn't what I posted work?
19:39:23 <pumpkin> kadaver: ?
19:42:52 <pumpkin> kadaver: ?
19:43:02 <kadaver> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3130#a3130
19:43:06 <kadaver> what i ahve
19:43:10 <kadaver> i jsut miss the last step
19:43:23 <kadaver> and inserting into an inner map seemsretardedly tricky
19:43:29 <kadaver> i didnt see your paste
19:43:35 <pumpkin> I just put it in the channel
19:44:04 <kadaver> i just wasnt here :P
19:44:12 <pumpkin> > Map.fromListWith (Map.union) . concatMap (\(x, y) -> [(a, Map.singleton x b) | (a, b) <- Map.toList y]) . Map.toList $ Map.fromList [("Some Critic", Map.fromList [("Some Movie", 4.5), ("Another Movie", 5.0)])]
19:44:13 <lambdabot>   fromList [("Another Movie",fromList [("Some Critic",5.0)]),("Some Movie",fr...
19:47:11 <kadaver> nice
19:47:24 <pumpkin> it's basically doing the same thing as yours is doing
19:47:28 <pumpkin> just less pretty
19:48:20 <kadaver> yours is prettier i think
19:48:42 <pumpkin> assuming it works right :P I only tested it on the example matthewp posted
19:49:00 <kadaver> but how do i do the last step?
19:49:06 <kadaver> from mine
19:49:16 <kadaver> how can it be that hard to isner tinto an inner map?
19:49:28 <kadaver> should i update, union or isnertWith?
19:49:56 <pumpkin> well, I just make each inner item a singleton map
19:50:01 <pumpkin> and union them using fromListWith
19:50:02 <abdullah_ak2002> hello everyone
19:50:14 <abdullah_ak2002> I am having problems running glut
19:50:23 <pumpkin> alternately you could fromListWith ++ and make every inner value a list with one item
19:50:35 <pumpkin> and then map a fromList to that
19:50:43 <pumpkin> but this is probably more efficient
19:54:01 <kadaver> manyMaps :: [M.Map Movie (Critic, Grade)]
19:54:07 <kadaver> i need to make them one Map now
19:54:15 <kadaver> fromListWith union that?
19:55:12 <pumpkin> that's an odd type
19:58:15 <kadaver> manyMaps :: [M.Map Movie (M.Map Critic Grade)]
19:58:19 <kadaver> thats better
19:58:35 <pumpkin> why a list of them
19:59:41 <kadaver> because i dont know how to make them a map
19:59:56 <kadaver> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3131#a3131
20:00:00 <pumpkin> foldl1' union
20:02:16 <kadaver> hmm that drops the same movies with different criritcs
20:02:33 <pumpkin> does my version?
20:03:54 <kadaver> nope
20:03:56 <kadaver> yours is correct
20:04:02 <kadaver> fromList [("Another Movie",fromList [("Some Critic",5.0)]),
20:04:02 <kadaver>           ("Some Movie",fromList [("Some Critic",4.5),("Swan",3.0)]),
20:04:03 <kadaver>           ("die hard",fromList [("Swan",4.0)])]
20:04:03 <kadaver> *
20:10:37 <matthewp> pumpkin: is your version still the same?
20:10:45 <matthewp> pumpkin: sorry had to drop off there
20:10:59 <pumpkin> yeah, I haven't touched it :)
20:11:08 <pumpkin> even has the original redundant parentheses!
20:12:39 <matthewp> pumpkin: ok, very cool.  Wish F# also had the Map.fromListWith and Map.union functions
20:13:12 <matthewp> pumpkin: guess I'll have to write the team again to add more to their plate :-)
20:17:21 <pumpkin> :D
20:17:26 <pumpkin> or just write them yourself :P
20:17:28 <pumpkin> they aren't hard at all
20:17:33 <pumpkin> well
20:17:44 <pumpkin> depending on how much access you have to the map structure :)
20:17:47 <thoughtpolice> hi pumpkin!
20:17:52 <pumpkin> o hai!
20:17:57 <pumpkin> sup?
20:18:23 <aj> is it possible to get a compiled haskell hello world down to a small executable? default ghc6 seems to be around 370kB
20:18:53 <thoughtpolice> pumpkin: not much. been really busy, hopefully I can write something for a gsoc proposal by like tomorrow.
20:19:03 <pumpkin> oh you gonna apply to be a student?
20:19:04 <thoughtpolice> pumpkin: but i bought a domain and website because nearlyfreespeech.net is so cheap :>
20:19:07 <thoughtpolice> yeah
20:19:13 <pumpkin> hah, I just saw :)
20:19:20 <pumpkin> popped up on twitter this second
20:19:38 <thoughtpolice> also trying to get linux on my ps3
20:19:50 <pumpkin> GHC for PS3 :D
20:19:53 <thoughtpolice> so i can play with spe's and stuff. but i can't copy locked files on there. uber lame :)
20:20:06 <thoughtpolice> pumpkin: first thing I was gonna do is install xmonad
20:20:11 <thoughtpolice> so i don't need to use a wireless mouse
20:20:14 <thoughtpolice> i already have a keyboard
20:20:25 <Hunner> death to the rodent!
20:20:59 <pumpkin> :o
20:22:09 <thoughtpolice> pumpkin: man I wish there was a nice cocoa version of ida pro. would be so nice :(
20:22:22 <pumpkin> yeah, me too :/
20:22:33 <pumpkin> whatcha reversing?
20:24:06 <thoughtpolice> pumpkin: oh nothign right now. waiting for the opportunity to present itself. i might as well start doing lots of crackmes again...
20:24:14 <pumpkin> ah :)
20:28:37 <kadaver> but gah i kill myself
20:31:06 <pumpkin> kadaver: ?
20:33:58 <sjanssen> @pl \(x, y) -> getSum x / getSum y
20:33:59 <lambdabot> uncurry ((. getSum) . (/) . getSum)
20:35:58 <pumpkin> @type uncurry ((/) `on` getSum)
20:36:00 <lambdabot> forall a. (Fractional a) => (Sum a, Sum a) -> a
20:37:03 <pumpkin> > uncurry ((/) `on` getSum) $ (Sum 5, Sum 7)
20:37:05 <lambdabot>   0.7142857142857143
20:41:34 <pumpkin> doesn't @pl know about on?
20:51:06 <kadaver> wow i got it
20:51:13 <shapr> What?
20:51:13 <kadaver> how retarded am i that too k to long
20:51:21 <shapr> Things take time?
20:51:25 <shapr> We all start at the beginning?
20:51:39 <kadaver> except im not at the beginning
20:51:43 <shapr> inga problem?
20:51:54 <kadaver> mnga problemet
20:51:57 <shapr> har du så mycket brattom? :-)
20:52:08 <pokesmot> i need a good recent backdoor trojan server program does any1 know where to get one?
20:52:28 <shapr> pokesmot: http://localhost/
20:52:40 --- mode: ChanServ set +o sjanssen
20:52:45 * shapr cackles evilly
20:52:48 <shapr> go go GADGET BOOT!
20:52:51 <sjanssen> pokesmot: if you're not hear to learn about Haskell programming, please leave
20:52:57 <shapr> ooh, tactfulness first.
20:53:00 <sjanssen> spelling fail.  If you're not here
20:53:35 <shapr> pokesmot: So, uh, wanna learn how to write network servers in Haskell?
20:53:43 * shapr hums the final countdown
20:53:56 <pokesmot> i want to exploit infected systems
20:54:07 <pumpkin> pokesmot: they call that being a scriptkiddie
20:54:17 --- kick: pokesmot was kicked by sjanssen (sjanssen)
20:54:18 <shapr> pokesmot: This irc channel is about learning actual skills.
20:54:21 <shapr> oh well
20:54:21 <pokesmot> ahh thanks for the info
20:54:25 <dolio> But where did the lighter fluid come from?
20:54:37 <shapr> pokesmot: So, if you want to learn something useful, this is a good place.
20:54:41 <pumpkin> pokesmot: it's not a good thing, hackers look down on you, and you go to jail
20:54:58 <shapr> If you want to exploit infected systems... well
20:55:02 * shapr shrugs
20:55:07 <shapr> It's not that great.
20:55:15 <pumpkin> :t unsafeExploitInfectedSystem
20:55:17 <lambdabot> Not in scope: `unsafeExploitInfectedSystem'
20:55:19 <pumpkin> :(
20:55:36 <pokesmot> i want to get inside computers hehe
20:55:41 <shapr> pokesmot: Seriously, programming requires brains.
20:56:19 <shapr> Using software that other people wrote to do stuff, does not require brains.
20:56:20 <pokesmot> i need an easy program hehe
20:56:21 <pumpkin> pokesmot: you should join a movie cast, maybe you can tap furiously at a keyboard with one hand, "hack the system", and be a master hacker :)
20:56:29 <shapr> pokesmot: What about learning how to write that sort of program for yourself?
20:56:40 <shapr> Haskell is a great language for writing all sorts of programs!
20:56:52 <pokesmot> i only know commodore 64 programming
20:57:05 <pokesmot> :1 start goto1
20:57:16 <shapr> pokesmot: Do you have a computer with an Intel or AMD CPU and Windows or Linux as the OS?
20:57:25 <pokesmot> windows
20:57:25 <shapr> pokesmot: Haskell is straightforward.
20:57:34 <pumpkin> sjanssen: you didn't like my (/) `on` getSum :(
20:57:38 <shapr> > map (\x -> x + 1) [1,2,77]
20:57:41 <lambdabot>   [2,3,78]
20:57:44 <pokesmot> tnx
20:58:03 --- mode: ChanServ set -o sjanssen
20:58:07 <shapr> pokesmot: How about downloading Haskell from http://www.haskell.org/ and trying that?
20:58:13 <matthewp> pumpkin: the problem is that they hide a lot of the map guts in internal classes
20:58:19 <pokesmot> ok i'll check it out
20:58:22 <matthewp> pumpkin: so it can be done, but not easy
20:58:34 <pokesmot> i'm old school c64 era
20:58:35 <pumpkin> matthewp: ah, that's unfortunate
20:58:41 <shapr> pokesmot: C64 was fun, I had one!
20:59:17 <shapr> pokesmot: There's a free book you can read about learning Haskell. It's a good book! I bought my own copy: http://book.realworldhaskell.org/
21:00:00 <shapr> pokesmot: Haskell is easy to learn, you can read the book and ask questions here on the #haskell channel.
21:00:00 <matthewp> pumpkin: Yeah, it's an internal type called MapTree, so can't really interject for a Map.fromListWith without some more serious work
21:00:00 <pokesmot> tnx
21:00:00 <pumpkin> lol
21:00:03 <shapr> oh well then.
21:00:14 <shapr> Perhaps he'll try it and come back with questions.
21:00:24 <matthewp> pumpkin: but I'll try anyhow, writing them now
21:01:51 <pumpkin> what are some good images that represent "computer science"?
21:02:03 <shapr> pumpkin: I predict pokesmot will get bored and go ask others.
21:02:18 <matthewp> As long as they aren't homework questions
21:02:23 <shapr> pumpkin: Cantor cube?
21:02:35 <pumpkin> is that the spongey thing?
21:02:36 <shapr> fractals?
21:02:54 <pumpkin> oh I was thinking about the sierpinski sponge
21:03:12 <shapr> Same deal...
21:03:14 <pumpkin> aha
21:03:22 <pumpkin> hmm, maybe
21:03:30 <repnop> devils staircase hehe
21:03:31 <pumpkin> I was thinking of a nice graph
21:04:21 <pumpkin> maybe a julia set too
21:04:38 <pumpkin> I'm making a flyer for an intro CS course I'm TAing :P
21:04:51 <shapr> As much as I think the glider is a silly hacker symbol, it is a nifty animated picture for CS purposes.
21:05:16 <pumpkin> ooh, I'll try to fit one of those in too
21:05:58 <shapr> pumpkin: What about a Koch snowflake in different iterations around the edges?
21:06:29 <pumpkin> hmm, could be fun, but then I'd have to generate it myself :P
21:06:36 <shapr> With HASKELL!
21:06:52 <pumpkin> someone needs to write a rewrite system library in haskell :P
21:07:08 <kadaver> foldl (\x (m,c,g) -> M.insert m
21:07:08 <kadaver>            (M.insert c g (case M.lookup m x of Just n  -> n
21:07:08 <kadaver>                                                Nothing -> M.empty)) x)
21:07:08 <kadaver>     M.empty (concat $ reorderTriple $ toTriple criticMap)'
21:07:23 <kadaver> is there no cleaner wyof inserting into an inner maP?
21:08:21 <shapr> kadaver: Throw it at @pl?
21:08:33 <pumpkin> lol
21:08:39 <shapr> You can likely clean it up with some point-free changes.
21:08:52 <shapr> Och @pl är så spannande!
21:08:53 <pumpkin> flip flip flip flip flip flip flip
21:08:55 <Gracenotes> the case statement -> fromMaybe
21:09:03 * shapr hoppar och studsar
21:09:14 <Gracenotes> @type fromMaybe
21:09:16 <lambdabot> forall a. a -> Maybe a -> a
21:09:51 <shapr> Det är lite svart att hitta nån svenskar har i Boston!
21:10:20 <shapr> kadaver: Vill du besöka mig? :-)
21:11:00 <pumpkin> he spent too much time in my monad and turned into a kadaver :o
21:11:00 <shapr> pumpkin: Isn't there an L-system app for Haskell?
21:11:20 <pumpkin> shapr: not that I know of, but I'm pretty new :)
21:11:43 <shapr> I've been here FOREVER!
21:11:47 <shapr> wah!
21:12:09 <pumpkin> since the beginning!
21:12:16 <pumpkin> I've been here since the end
21:12:30 <shapr> Nah, the end is not yet in sight.
21:12:47 <shapr> So I found boegel's HaskLS: http://users.elis.ugent.be/~kehoste/Haskell/HaskLS/
21:12:52 <pumpkin> http://www.visualcomplexity.com/ wow, I randomly came across this site again... I remember having lots of fun on it in high school, but couldn't remember what it was called and was sad
21:12:54 <shapr> But I know xerox worked on something..
21:13:02 <pumpkin> oh cool
21:13:38 <shapr> There's something niftier that uses gtk2hs
21:14:28 <shapr> Aha - http://darcs.haskell.org/~paolo/nymphaea/
21:14:36 <pumpkin> cool
21:14:40 <pumpkin> thanks :)
21:14:49 <kadaver> shapr=henrik nilsson?
21:14:55 <shapr> kadaver: nej!
21:15:04 <shapr> No way... I haven't seen him since ICFP 2003
21:15:21 <shapr> kadaver: Jag heter Shae, men jag är inte en tjej.
21:16:23 <shapr> kadaver: I'm just an American who lived in Sweden for a few years.
21:16:39 <Adamant> he is of 'Bama, lo, the many songs of his forefathers in Vahalla echo there!
21:17:02 <shapr> I'm from the Swedish speaking part of Alabama, exactly.
21:17:06 <Adamant> :P
21:17:07 <pumpkin> O' Bama?
21:17:39 <Adamant> Obama wants Change, ZoBama wants Brains
21:18:01 <Adamant> :P
21:18:11 <pumpkin> :o
21:18:19 <shapr> I just want hot chixx and cool code.
21:18:30 * araujo agrees
21:18:45 <Adamant> that solves most of your problems in life
21:18:54 <shapr> Yeah, hard to beat that combination.
21:19:23 * blackh 's favourite music is all Swedish.
21:19:35 <Adamant> let me guess, black and death metal?
21:19:38 <shapr> Abba?
21:19:39 <Adamant> :P
21:19:45 <blackh> Adamant: How did you guess?
21:19:50 <Adamant> your SN
21:19:55 <Adamant> black hundred?
21:20:07 <shapr> Ace of Bass?
21:20:10 <Adamant> also, Sweden doesn't make a lot of other kinds of exportable music :P
21:20:26 <shapr> Hey, Peps Persson rocks!
21:20:31 <kadaver> cool name SHae
21:20:41 * shapr boings cheerfully
21:20:52 <kadaver> yes Peps is a god
21:20:54 <shapr> and I like Stina Nordenstam too.
21:20:59 <kadaver> Adamant: sweden make sloads o exportable msuic
21:21:08 <blackh> Adamant: 'blackh' is the first six letters of my surname
21:21:19 <Adamant> kadaver: well, I should clarify, exportable to the US
21:21:25 <kadaver> chekc if you odny mind swedish lyrics Svenska akademien (reggae)
21:21:32 <Adamant> I forget you guys export a lot to other European countries
21:21:39 <shapr> What about Sweden's international hit song about IRC?
21:21:47 <Adamant> they had one?
21:21:50 <Adamant> I must hear it
21:21:51 <shapr> Yes, seriously.
21:22:00 <blackh> I like all Swedish music - even the music I haven't heard yet. And I have a Swedish chainsaw!
21:22:01 <kadaver> odny->dont
21:22:19 <Adamant> blackh: they make good forestry/logging/woodworking equipment
21:22:27 <shapr> Adamant: Bass Hunter wrote a song called båten anna
21:22:57 <shapr> Adamant: http://www.youtube.com/watch?v=RYQUsp-jxDQ
21:23:30 <shapr> The lyrics go something like "I know a bot, named Anna, she can ban you so hard"
21:23:44 <Adamant> very strange
21:23:59 <Adamant> T-Pain wants his autotuner back :P
21:24:05 <shapr> Yes, I agree. After years of exposure to Swedes... they are very strange.
21:24:27 <shapr> I like 'em though.
21:24:44 <seliopou> adam tensta is swedish
21:24:49 <seliopou> good hip hop
21:25:09 <sbahra> #haskell-blah ?
21:25:19 <shapr> bah, ok
21:25:25 <sbahra> I don't care, but you do.
21:25:29 <shapr> You're right.
21:25:34 <sbahra> :-P
21:25:35 * shapr moves the discussion to #haskell-blah
21:25:54 <shapr> Adamant: If you show up on #haskell-blah, I'll tell you the punchline of the song :-P
21:42:48 <amjith> Hi, I am learning Haskell with "Learn you a haskell" tutorial.
21:42:54 <amjith> I have a question on the lists.
21:43:04 <amjith> How do I flatten a nested list?
21:43:10 <pumpkin> concat
21:43:11 <pumpkin> or join
21:43:28 <pumpkin> > concat [[1,2,3],[4,5]]
21:43:29 <lambdabot>   [1,2,3,4,5]
21:43:33 <pumpkin> > join [[1,2,3],[4,5]]
21:43:35 <lambdabot>   [1,2,3,4,5]
21:43:41 <c_wraith> :t concat
21:43:42 <lambdabot> forall a. [[a]] -> [a]
21:43:44 <c_wraith> :t join
21:43:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:43:48 <amjith> Oooh. I got the concat working. Thanks very much. But join didn't work.
21:43:55 <dibblego> :M + Control.Monad
21:43:58 <dibblego> :m
21:44:09 <amjith> I got the following error. <interactive>:1:0: Not in scope: `join'
21:44:17 <dibblego> do that first ^
21:44:19 <Gracenotes> join is just the same as "concatMap id"
21:44:20 <dibblego> :m + Control.Monad
21:44:31 <Gracenotes> concat is a bit simpler :)
21:45:04 <amjith> Cool. thanks a lot, now I'll get back to my tutorial :)
21:48:40 <bvck> Hopefully quick question on Haskell class.
21:49:14 <bvck> I want to define a class Foo with function bar. But I also want to make sure that types that belong to this class also belong to Eq.
21:49:36 <dibblego> class (Eq a) => Foo a where bar :: a
21:51:05 <bvck> dibblego, thanks (I am getting used to getting quick answers from you...:))
21:54:39 <newsham> ?src join
21:54:40 <lambdabot> join x =  x >>= id
21:57:36 <dev31212> hi..
21:57:54 <dev31212> trying to wrap my head around an occurs check problem..cannot construct infinite list
21:57:56 <mib_5tx328> the operator % is invalid in haskell? who can tell me which the substitute is,thx
21:58:18 <newsham> you want the modulo operator?
21:58:19 <Gracenotes> > 10 `mod` 3
21:58:21 <lambdabot>   1
21:58:34 <dev31212> I have a simple BST here : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3132#a3132
21:58:36 <mib_5tx328> yes, many thanks
21:58:42 <Gracenotes> > mod 531 12
21:58:44 <lambdabot>   3
21:58:49 <dev31212> lets then say I have a list, let b = [1,2,3,4,5]
21:59:05 <dev31212> and I ant to fold it into the BST: let c = foldr insert EmptyTree b
21:59:08 <Gracenotes> it's a function, so you can use it in prefix, in infix, in infix sections, etc.
21:59:09 <dev31212> That works fine.
21:59:11 <bvck> Getting a strange error with that. 'Non type-variable argument in the constraint: Eq (ListSet a)'
21:59:19 <dev31212> But if I use foldl, I get the occurs check error
21:59:21 <bvck> The two offending lines are:
21:59:32 <Gracenotes> dev31212: foldr and foldl expect different argument orders
21:59:32 <bvck> newtype ListSet a = ListSet [a]; instance Eq (ListSet a) => Set (ListSet a) where
21:59:34 <dev31212> I have it working with foldr, just I want to not be confused why it doesnt work the other way
21:59:38 <dev31212> anyone have an idea?
21:59:43 <blackh> dev31212: You have to hunt for the bit where it's inferring two different types for the same thing - one being a list of the other.
21:59:56 <Gracenotes> in foldr, the accumulator is the second argument.
22:00:03 <blackh> dev31212: Note that foldr and foldl have their.... oh - Gracenotes already said that.
22:00:04 <Gracenotes> in foldl, the accumulator is the first argument.
22:00:20 <Gracenotes> so you might have to use (flip insert) instead of insert. possibly.
22:00:26 <dev31212> oh ok, thanks guys, thats what I figured..but I was confused because there would be no psattern match in that case
22:00:32 <dev31212> is it just the behavior of folding?
22:00:43 <Gracenotes> the argument order isn't terribly important
22:00:53 <dev31212> hmm ok
22:01:11 <blackh> bvck: You might need a GHC extension,or you might be doing things wrong - not sure which.
22:01:12 <Gracenotes> so long as it takes an accumulator and a value and gives a new accumulator
22:01:28 <dev31212> ok Gracenotes. thanks
22:01:42 <Gracenotes> sure. (the semantics of accumulation tend to be different from foldl and foldr, btw)
22:01:43 <dev31212> Ok, one last question..kind of a generalization
22:02:03 <bvck> (Use -XFlexibleContexts to permit this) is what ghci is telling me. I was hoping someone could clarify and provide an alternative without turning this on.
22:02:08 <dev31212> can I, accurately, say that when I get that occurs check on the foldr, it is because the arguments arent of the expected type?
22:02:28 <Cale> dev31212: yes
22:02:30 <dev31212> Its just so weird because there is no pattern to match the scenario...I guess its just a strange thing about folding
22:02:31 <blackh> bvck: You probably don't want to say Eq (ListSet a).  Instead,....
22:02:33 <dev31212> ok Cale, thanks
22:02:37 <Cale> dev31212: an occurs check is a type checking thing
22:02:41 <dev31212> Ahh!
22:02:43 <dev31212> Eureka
22:02:51 <blackh> bvck: Just make ListSet a an instance of Eq
22:03:08 <Cale> dev31212: It has to do with not allowing infinite types
22:03:10 <dev31212> Ok thanks a lot guys, Ive been trying to figure out for an hour
22:03:37 <dev31212> Cale, one last(really) isnt it odd that it doesnt puke on the fact no pattern match was found?
22:03:37 <bvck> blackh, okay. Thanks.
22:03:38 <blackh> bvck: Use Eq XX => on class declarations, but don't use it on instance declarations
22:03:42 <dev31212> or am I simply wrong about that
22:03:56 <Cale> dev31212: hmm...
22:04:07 <Cale> dev31212: I haven't looked at your program yet -- I just looked in
22:04:16 <Cale> dev31212: You might notice the difference in type between foldr and foldl
22:04:18 <Cale> :t foldr
22:04:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:04:22 <Cale> :t foldl
22:04:22 <bvck> blackh, ah! That's what I was missing. Right. Thanks again.
22:04:24 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:04:31 <dev31212> ahh
22:04:39 <dev31212> ah hah!
22:04:43 <Cale> Would be nicer with b and a swapped there...
22:04:45 <Cale> but yeah
22:04:46 <dev31212> yes, that is the one thing I neglected to do
22:04:48 <Gracenotes> forall a b. (b -> a -> b) -> b -> [a] -> b
22:04:50 <Cale> They're not equivalent :)
22:04:50 <dev31212> I think it makes sense to me now
22:04:52 <Gracenotes> ^ types switched
22:04:56 <dev31212> yes
22:04:58 <dev31212> thanks all
22:05:15 <dev31212> so its the pattern match in the fold function
22:05:18 <dev31212> not in my functions
22:05:37 <dev31212> um, I better take a break
22:05:38 <Gracenotes> well, type matching (unification)
22:05:48 <newsham> ?type foldr
22:05:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:05:52 <newsham> ?type foldl . flip
22:05:53 <lambdabot> forall a c. (a -> c -> c) -> c -> [a] -> c
22:06:11 <mib_5tx328> I want to use the floor function for a number of type Int, how to deal with ?
22:06:15 <Gracenotes> it's not related to pattern-matching as in function arguments
22:06:28 <dev31212> ok, I see.
22:06:32 <dev31212> This room is great
22:06:46 <dev31212> thanks again
22:06:50 * dev31212 afk
22:06:58 <Gracenotes> mib_5tx328: in that case, floor is just 'id'
22:07:07 <mmorrow> @seen dons
22:07:08 <lambdabot> dons is in #gentoo-haskell, #haskell-soc, #yi, #haskell, #ghc, #xmonad, #darcs, #arch-haskell and #concatenative. I last heard dons speak 9h 7m 34s ago.
22:07:28 <Gracenotes> mib_5tx328: there's no need to have a floor for an Int
22:07:29 <mib_5tx328> what that means?
22:07:30 <mmorrow> @tell dons i applied your patch and uploaded the new version to hackage
22:07:30 <lambdabot> Consider it noted.
22:08:12 <mib_5tx328> if I want to use the sqrt for a Int, how?
22:08:20 <mmorrow> sadf
22:08:20 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
22:08:23 <pumpkin> omg
22:08:39 <mmorrow> zmog
22:08:44 <lpjhjdh> is there something like: read :: ByteString -> a
22:09:05 <Cale> mib_5tx328: Use fromIntegral to convert the Int to Double
22:09:08 <mmorrow> @tell dons oh, i just saw the other patch. looking now.
22:09:09 <lambdabot> Consider it noted.
22:09:13 <Cale> mib_5tx328: and then you can apply sqrt
22:09:21 <Gracenotes> > let var = 5426 :: Int in sqrt (fromIntegral var)
22:09:23 <lambdabot>   73.66138744281159
22:09:29 <dev31212> yes, the :t foldl makes it clear to me now
22:09:30 <Gracenotes> ^ mib_5tx328
22:09:33 <dev31212> awesome
22:09:37 <dev31212> Now I can rest
22:09:51 <mmorrow> @tell dons ah, ok. applied in 0.0.6
22:09:51 <lambdabot> Consider it noted.
22:09:56 <mib_5tx328> thank you all
22:10:00 <mib_5tx328> I see
22:10:11 <mmorrow> pumpkin: howsit
22:11:33 <lpjhjdh> @hoogle ByteString -> a
22:11:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:11:34 <lambdabot> Prelude id :: a -> a
22:11:34 <lambdabot> Data.Function id :: a -> a
22:15:54 <luqui> lpjhjdh, read . unpack?
22:16:09 <pumpkin> hi :)
22:16:29 <mib_igxh8j0k> Hi
22:16:40 <pumpkin> hello, Mr. Mib
22:16:55 <mib_igxh8j0k> Can I ask a question here?
22:16:56 <pumpkin> or Mrs.
22:17:01 <mib_igxh8j0k> Mr.
22:17:04 <pumpkin> mib_igxh8j0k: you just did!
22:17:11 <pumpkin> only one question per person per day, I'm afraid ;)
22:17:16 <luqui> lol
22:17:18 <pumpkin> mib_igxh8j0k: but yeah
22:17:24 <pumpkin> ask away :)
22:17:24 <Cale> mib_igxh8j0k: of course :)
22:17:36 <mib_igxh8j0k> I am learning Haskell.
22:18:07 <mib_igxh8j0k> I want to process a CSV file.
22:18:35 <mib_igxh8j0k> I knew I can use the built-in CSV package.
22:18:46 <Cale> Are you more interested in the process of writing a CSV parser, or your other task? There are libraries on hackage for reading CSV.
22:18:49 <Cale> ah
22:19:29 <mib_igxh8j0k> The file has thousands of fields per record.
22:20:08 <mib_igxh8j0k> How can I automatically get the field name by reading the first line?
22:20:28 <Cale> That shouldn't be too bad, but it sounds like a very large file, so you might have to be careful about memory usage.
22:20:45 <Gracenotes> thousands of fields? goodness
22:20:55 <mib_igxh8j0k> For example. The first line reads "a","b","c"...
22:21:16 <mib_igxh8j0k> the second line reads 1,0,1...
22:22:20 <mib_igxh8j0k> For each line, I want to use "a" to represent the real data.
22:22:30 <Cale> mib_igxh8j0k: Okay, so you might want to turn each row into something like a Map String Int ?
22:22:46 <mmorrow> @type \(x:xs) -> zip x (transpose xs)
22:22:48 <lambdabot> forall a. [[a]] -> [(a, [a])]
22:23:04 <Cale> oh, that's cute :)
22:23:08 <mmorrow> :)
22:23:21 * mmorrow has done this more times than he cares to admit (re: csv file)
22:25:04 <mib_igxh8j0k> The problem is that I know there is a field name called "x", but its position may not always be the same.
22:25:27 <mmorrow> so are you sure then that you actually have enough info to do what you want?
22:25:44 <mmorrow> because if so, there's a way for sure
22:25:46 <mib_igxh8j0k> Is there something in haskell silimar to hash reference in Perl?
22:25:52 <mmorrow> Data.Map
22:25:53 <Cale> mib_igxh8j0k: Data.Map
22:25:55 <Cale> yeah :)
22:26:11 <Heffalump> hat's similar to hash tables, not hash references
22:26:16 <Heffalump> (I think)
22:26:18 <mmorrow> oh
22:26:22 <mmorrow> what's a hash reference?
22:26:28 <luqui> it's just a hash
22:26:33 <luqui> as a regular value...
22:26:40 <Heffalump> a pointer to a hash
22:26:44 <mmorrow> ah
22:26:45 <luqui> haskell does not have the vocabulary to differentiate between hashes and hashrefs
22:27:16 <Cale> Unless you want to talk about IORefs or something, and that would be misleading.
22:27:30 <Gracenotes> dynamic programming is somewhat difficult in Haskell
22:27:36 <luqui> yeah, it's really more about flattening, which haskell doesn't do...
22:27:36 <Cale> What? Really?
22:27:39 <mmorrow> :o
22:27:40 <Heffalump> Gracenotes: huh? No it's not
22:27:40 <Gracenotes> sometimes laziness can help. sometimes it doesn't.
22:27:47 <mib_igxh8j0k> In Perl, $ref->{a} will get you the value of "a" field.
22:28:00 <luqui> mib_5tx328, you want Data.Map
22:28:01 <mib_igxh8j0k> for each line when you do a loop.
22:28:02 <Gracenotes> for things where you'll need to modify a value more than once, you end up getting a bit stuck, I think :/
22:28:20 <Heffalump> what dynamic programming algorithms require that?
22:28:25 <luqui> Gracenotes, yeah true.  although some dynamic programming things have really beautiful solutions
22:28:30 <mmorrow> Gracenotes: you can just use (Int)Maps
22:28:35 <luqui> which only come out when you're not allowed to modify things :-)
22:28:36 <mmorrow> and modify the map
22:28:54 <Gracenotes> mmorrow: hm. I suppose.
22:29:15 <mmorrow> that's how i do graphs 99% of the time
22:29:24 <mmorrow> IntMap IntSet
22:29:26 <Gracenotes> yeah. probably the best way
22:29:40 <Gracenotes> I haven't had too much luck with LCS, but then again that was a bit ago.
22:29:50 <Cale> I don't really bother with the Int specialisations
22:29:56 <Cale> Map/Set are good :)
22:30:02 <mmorrow> Gracenotes: ooh, iirc there's an lcs pkg on hackage. maybe check out that code
22:30:13 <Gracenotes> well, I think it would be pretty easy
22:30:13 <pumpkin> we need a way to have haskell automatically specialize Map Int a to IntMap a
22:30:30 <Gracenotes> the main state in LCS is a map from positions to frequencies
22:30:36 <Heffalump> pumpkin: type families!
22:30:37 <mmorrow> i wish, it's sooooo annoying that IntMap has kind :: * -> *
22:30:39 <Gracenotes> which is renewed from iteration to iteration
22:30:47 <luqui> Heffalump, yeah, but... not in their current state
22:30:52 <mmorrow> Heffalump: yeah, i've played with that wrt Map/IntMap
22:30:55 <Heffalump> I know :-)
22:31:00 <pumpkin> aw
22:31:00 <Heffalump> (to luqui)
22:31:02 <mmorrow> grrr
22:31:08 <Cale> We need type families which are closed by a polymorphic catch-all case.
22:31:08 <Gracenotes> hm. Lemme try to implement it mahself.
22:31:32 <Heffalump> Cale: it can't be polymorphic cos of Ord
22:31:41 <Heffalump> at least, it'll be a bit of a weird "catch-all" case
22:31:49 <Gracenotes> I thought of type families earlier today, running on a treadmill >_>
22:31:51 <Cale> Well, yes.
22:31:55 <mmorrow> Gracenotes: the ST monad is useful too for when you need mutation
22:31:57 <Cale> Catch-most then :)
22:31:59 <Cale> hehe
22:32:09 <Gracenotes> what's the important way they differ from typeclasses again?
22:32:27 <Heffalump> I guess if you say in the family definition that Ord is required, it'll be less weird
22:32:40 <mib_igxh8j0k> Thank you guys.
22:32:50 <mib_igxh8j0k> I got go to sleep.
22:32:54 <Cale> Well, already when selecting an instance, only the structure of the type matters...
22:32:54 <mib_igxh8j0k> Bye.
22:32:59 <mmorrow> bye
22:33:03 <Cale> mib_igxh8j0k: See you around!
22:33:37 <Gracenotes> I was actually wondering if there's a general way to convert something from a Foo to a Bar, with data Foo a = FooNil | FooCons a (Foo a) and data Bar a = BarNil | BarCons a (Bar a)
22:33:46 <Gracenotes> and it seemed type families might fit
22:33:51 <Gracenotes> or was that GADTs :/
22:34:04 <Cale> Generics might fit
22:34:15 <Cale> (Data.Generics, and friends)
22:34:27 <Gracenotes> you'd have to pass a constructor of sorts
22:34:48 <Cale> You need a way to compare the structure of the types to construct an isomorphism.
22:35:04 <dons> mmorrow: awesome.
22:35:05 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
22:35:06 <dons> thanks
22:35:10 <Cale> You might also be able to rig something up using TH.
22:35:19 <Gracenotes> the important items would be (a -> m a -> m a) and (m a -> a)
22:35:33 <Cale> Of course, if you have the fold on one datatype, and you know how the constructors line up, you're done ;)
22:35:34 <Gracenotes> and also (m a) for the empty element
22:35:37 <pumpkin> if anyone likes visualizations, http://www.visualcomplexity.com/vc/ is a wonderful place to find them btw :)
22:35:52 <Gracenotes> actually, (m a) might not be required
22:35:57 <mmorrow> dons: np. yeah, when i saw that patch i was like "doh!" (since if there's only one extern node label, graphviz would make them all the same..)
22:36:02 <Gracenotes> er, I mean (m a -> a). anyways X_X
22:37:24 <mmorrow> dons: i got gtk all set up too. vacuum-cairo is pretty sweet.
22:37:42 <mmorrow> pumpkin: ooh, cool
22:38:01 <mmorrow> oh nice, i think i've been here a while ago, but forgot about it
22:38:19 <pumpkin> yeah, same here
22:38:27 <pumpkin> I loved to browse it in high school
22:38:36 <pumpkin> it's been around for a while, but I only rediscovered it tonight
22:38:51 <dons> great.
22:38:53 <Gracenotes> I would use vacuum-cairo but BASE 4 RAWR RAWR
22:38:55 <dons> sending my announce
22:38:56 <mmorrow> iirc i came across it about a year ago
22:39:01 <dons> Gracenotes: shouldn't matter...
22:39:09 * Gracenotes terrorizes a type neighborhood
22:39:11 <dons> cabal-install knows all
22:40:23 <Gracenotes> yeah, it obviously knows its limitations, because it's very good at explaining them to me
22:41:07 <QtPlaty[HireMe]> Possably dumb question, can you create a unary operator?
22:41:30 <pumpkin> only as postfix, and with a GHC extension
22:41:48 <QtPlaty[HireMe]> pumpkin: Thanks.
22:42:13 <mmorrow> i like using (!) = read{IO/ST}Ref
22:42:16 <mmorrow> (x!)
22:42:30 <Gracenotes> http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/syntax-extns.html#postfix-operators
22:42:36 <mmorrow> almost like SML
22:42:49 <Gracenotes> also explains some of the problems of unary operators. sorta.
22:43:00 <mmorrow> the parser would probably explode
22:43:15 <mmorrow> (this unary '-' but worse)
22:43:19 <mmorrow> s/this/think/
22:45:18 <dons> mmorrow: have you seen the different rendering i'm using now?
22:45:34 <mmorrow> dons: no, i haven't got the new version yet.
22:45:35 <dons> http://www.youtube.com/watch?v=oujaqo9GAmA
22:45:37 <dons> shows literals
22:45:42 <mmorrow> sweetness
22:46:03 <mmorrow> the screenvids are nice
22:46:04 <Gracenotes> > let (++) = (+1); x = 4320 in (x++)
22:46:06 <lambdabot>   4321
22:47:19 <pumpkin> oh vacuum's improved a lot
22:47:28 <pumpkin> I guess you've stopped showing the # boxes?
22:47:41 <dons> well, vacuum-cairo is rendering things differently
22:47:56 <pumpkin> ah :)
22:48:05 <pumpkin> looks like fun
22:48:12 <mmorrow> dons: very nice. one thing though... how do you deal with (42,42) ?
22:48:16 <pumpkin> saves us from having to write our own pretty printers
22:48:29 <pumpkin> (for debugging, at least)
22:48:50 <mmorrow> or (zip "hello" "oreo"), etc
22:48:50 <dons> mmorrow: it doesn't share it.
22:49:00 <mmorrow> yeah, but it'll be rendered like it does?
22:49:06 <dons> nope
22:49:16 <dons> try it out !
22:49:23 <dons> view (42,42)
22:49:26 <mmorrow> ooh, one step ahead.
22:49:28 <mmorrow> ;)
22:49:40 * mmorrow builds new version
22:50:12 <dons> http://galois.com/~dons/tmp/42.png
22:50:29 <mmorrow> ahh, nice so you're giving the nodes a [label = "..."] i take it..
22:50:38 <dons> yes
22:50:45 <mmorrow> beauty
22:51:01 <dons> and tweaked the rendering a little (crank up the antialiasing, slightly smaller arrows)
22:51:36 <dons> yeah, i'm hopeful this makes a decent teaching tool now, and i'm excited at how it helps understanding sharing and unpacking constructors
22:51:45 <mmorrow> looks like you got the aspect ratio mostly sorted out too
22:51:45 <dons> it shows how lazy bytestrings unpack very nicely
22:52:25 <mmorrow> yeah, i got motivated and started looking into the opengl/gtk2hs api..
22:52:42 <dons> i'm writing a blog post about how / what / why this works, and what its good for
22:52:46 <Gracenotes> dons: heh. "Done"
22:52:49 <pumpkin> now you just need to come up with your own graph layout algorithms and animate the whole thing so nodes can bounce around :P
22:53:01 <dons> well, you can actually animate this
22:53:03 * mmorrow has setting up a blog and using it on his short list
22:53:05 <Gracenotes> @hoogle Done
22:53:06 <lambdabot> Control.Parallel.Strategies type Done = ()
22:53:14 <pumpkin> mmorrow: along with twitter, right? :P
22:53:25 <dons> sequence_ [ threadDelay (10^5) >>> view x | x <- [1..n] ]
22:53:33 <mmorrow> pumpkin: heh, i think i may actually :)
22:53:33 <dons> poor mans graphical haskell
22:53:41 <pumpkin> whee
22:53:49 <dons> you just have to generate all intermediate states somehow
22:54:00 <dons> mmorrow: also, i want this to work:   view [| 1 + 2 |]
22:54:04 <dons> but it doesn't :)
22:54:08 <mmorrow> ooh
22:54:10 <dons> not sure why ExpQ's aren't normal
22:54:13 <luqui> so i'm guessing vacuum doesn't visualize infinite structures
22:54:17 <pumpkin> oh that would be cool
22:54:18 <dons> luqui: it tries :)
22:54:20 <luqui> looks like it is forcing the structures...
22:54:26 <luqui> heh :-)
22:54:26 <quicksilver> dons: you should get sponsorship for the tracks which get displayed when your playlist moves to the next track ;)
22:54:26 <dons> we need a isEval# primop
22:54:29 <dons> to test the eval bit
22:54:32 <mmorrow> dons: you'd have to (unsafePerformIO . runQ) or equiv
22:54:46 <mmorrow> (or lift and then unQ if you're using reify/etc)
22:54:54 <mmorrow> i'll make that work..
22:55:34 <mmorrow> dons: i want to send in a patch for unpackClosure# too, so it checks all the closure types that shouldn't be entered
22:55:58 <mmorrow> i think it'd just be a matter of adding those to the list
22:56:08 <dons> <interactive>: internal error: ARR_WORDS object entered! (GHC version 6.10.1 for x86_64_unknown_linux)
22:56:12 <mmorrow> exactly
22:56:13 <dons> yeah
22:56:19 <dons> Prelude Language.Haskell.TH System.IO.Unsafe System.Vacuum.Cairo> view $ (unsafePerformIO . runQ) [| 1 + 2 |]
22:56:23 <dons> don't do that.
22:56:23 <pumpkin> I've caused one of those before
22:56:26 <pumpkin> can't remember how though
22:56:42 <mmorrow> dons: ohhh. hah, i'll special case that one too i guess..
22:56:49 <dons> well, i really want   to see the AST!
22:57:14 <dons> but yeah, we should try to make it safe.
22:57:21 <mmorrow> oh nice, that's doable for sure (w/out even using vacuum). i should add that.
22:57:27 <dons> and let the simons know what you're up to.
22:57:42 <mmorrow> dons: yeah.
23:02:50 <mjk> what is the function 'id' for? is a placeholder?
23:05:31 <dibblego> because it is useful
23:05:42 <dons> > foldr (.) id [ (+1), (*2) ]  $ 7
23:05:43 <lambdabot>   15
23:07:36 <kerlo> mjk: it's like the number 0. There's generally no reason to flat out multiply by 0 or add 0, but sometimes, a formula where you add or multiply by x only does what you want when x = 0.
23:07:43 <blackh> mjk: One of my favourites uses of id is: (if _something_ then modify_it else id) value
23:08:14 * kerlo adds the obligatory "perhaps" to his statement
23:08:28 <Gracenotes> > join (Just (Just 10))
23:08:30 <lambdabot>   Just 10
23:08:34 <Gracenotes> @src join
23:08:34 <lambdabot> join x =  x >>= id
23:08:37 <mjk> kerlo: thanks
23:08:40 <Gracenotes> uses id behind the scenes
23:09:05 <Gracenotes> what >>= does is takes (Just (Just 10)) and then gives you (Just 10)
23:09:30 <Gracenotes> you need to feed that to a function, so you feed it to id. And it removes a layer of Maybe
23:13:02 <mmorrow> dons: have you seen andyjgill's dotgen pkg? i've been meaning to check it out http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dotgen
23:14:07 <dons> yes, he wrote it while sitting two desks from me.
23:14:12 <dons> modgraph uses it.
23:14:17 <dons> graphmod
23:14:26 <mmorrow> heh
23:19:54 <mjk> blackh: the mean is: id is itself
23:21:27 <kerlo> mjk: I guess. id 3 is 3 itself.
23:21:49 <kerlo> And the same for everything else that you can give to id.
23:24:08 <mmorrow> @type id id id id id id id id id id id id
23:24:09 <lambdabot> forall a. a -> a
23:24:32 <mmorrow> @type id . id . id . id . id . id . id . id . id . id . id . id
23:24:33 <lambdabot> forall a. a -> a
23:24:34 <luqui> i did
23:24:41 <mmorrow> heh
23:25:06 <kerlo> @type (id `id`) (`id` id)
23:25:07 <lambdabot> forall t a. ((a -> a) -> t) -> t
23:25:13 <kerlo> Whoa.
23:25:16 <pumpkin> that looks useful
23:25:17 <mmorrow> , (*2) `id` 42
23:25:18 <lunabot>  84
23:25:23 <mmorrow> , (*2) $ 42
23:25:25 <lunabot>  84
23:25:30 <mmorrow> ($) = flip id
23:25:35 <luqui> @type id (.) id id . id
23:25:36 <lambdabot> forall a. a -> a
23:26:19 <mmorrow> , zipWith id [(*2), negate] [1,2]
23:26:20 <lunabot>  [2,-2]
23:26:49 <mmorrow> i meant
23:26:54 <mmorrow> ($) = (flip . flip) id
23:27:01 <pumpkin> :o
23:27:14 <mmorrow> @type [id, (flip . flip) id]
23:27:16 <lambdabot> forall b c. [(b -> c) -> b -> c]
23:27:28 <mmorrow> (a -> b) -> (a -> b)
23:27:44 <mmorrow> so ($) really = id
23:27:53 <pumpkin> omg QED
23:27:58 <mmorrow> :)
23:28:36 <Gracenotes> omg u roxors
23:28:53 <pumpkin> omg I need to stop working on this ****ing flyer
23:29:37 <mmorrow> pumpkin: there's some amazing stuff on that site http://www.visualcomplexity.com/vc/index.cfm?all=yes
23:29:50 <pumpkin> yeah, pity some of the links are broken :(
23:29:58 <pumpkin> they should've mirrored the sites they link to
23:32:47 <kerlo> @free (a -> b) -> a -> b
23:32:47 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
23:36:04 <mmorrow> @free id
23:36:05 <lambdabot> f . id = id . f
23:36:17 <pumpkin> @free map
23:36:19 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
23:36:23 <pumpkin> @free concat
23:36:24 <lambdabot> $map f . concat = concat . $map ($map f)
23:37:15 <mmorrow> @free fix
23:37:17 <lambdabot> f . g = h . f => f (fix g) = fix h
23:38:10 <mmorrow> @type \h g f -> [f . g, h . f]
23:38:11 <lambdabot> forall b c. (c -> c) -> (b -> b) -> (b -> c) -> [b -> c]
23:38:59 <mmorrow> @type \h g f -> let _ = [f . g, h . f] in [f (fix g), fix h]
23:39:00 <lambdabot> forall b c. (c -> c) -> (b -> b) -> (b -> c) -> [c]
23:58:26 <doctormach> When I repeatedly execute view $ take 5 [1..] using vacuum-cairo it cycles through lists of length [1..5]
23:58:31 <doctormach> Is that expected behavior?
