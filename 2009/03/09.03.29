00:00:08 <dons> i think not having the 'dot' binary is likely to cause those hflush errors
00:03:06 <BMeph> kohwj: I deleted my install of TH and reinstalled it fine. You might want to check and make sure you're using the .0.2 version of Cabal.
00:04:52 <kohwj> BMeph: 1.6.0.2?
00:05:00 <kohwj> BMeph: i'm on 1.6.0.1
00:05:35 <kohwj> BMeph: cabal update & upgrade don't give me 1.6.0.2
00:09:00 <dons> mmorrow: the 'hackish' table is things that crash if we enter them?
00:09:05 <kohwj> BMeph: never mind, i just specified --reinstall
00:11:24 * Axman6 misses haskell :(
00:11:39 <Axman6> frigging C
00:13:07 <dons> mmorrow: also, i notice the bytestring is represented as a PS with a ptr to PlainPtr. so we don't see the unpacked length/offset fields.
00:13:10 <dons> that's interesting
00:17:36 <BMeph> kohwj: Have you done ''cabal install cabal' and 'cabal install cabal-install'?
00:18:06 <BMeph> kohwj: Okay, NM-ing. :)
00:22:10 <edwardk> dons: i went and made sure that source file was in the darcs repo, hopefully you should be all set
00:22:25 <edwardk> i just pushed another version up to hackage
00:24:02 <edwardk> woot, run length encoding generator and monoid to produce a run length encoding in parallel added
00:25:04 <BMeph> edwardk: I got an "Data\Group.hs:23:7:     Could not find module `Data.Monoid.Self':" error when I re-compiled. Did you hide something? :)
00:25:06 <wli> edwardk: After I read about it a bit, LZ78/LZW sound like they have a fair amount in common with RLE at least wrt. how one does them procedurally.
00:25:13 <edwardk> BMeph: strange
00:25:42 <edwardk> wli: they do actually
00:26:17 <edwardk> BMeph: its there in the source repository, which is weirding me out
00:26:27 <edwardk> hah
00:26:30 <edwardk> but not the cabal file
00:28:42 <edwardk> BMeph try 0.1.9
00:29:20 <edwardk> wli: i didn't want to do LZW because it requires you to prepopulate the dictionary with all possible objects, so LZ78 makes a better data structure than LZW
00:30:12 <edwardk> wli: and i kept a separate RLE monoid/generator because i can produce that in parallel, because there is a nice monoid for building it, while there isn't such a nice monoid for LZ78. i have to scan the source left-to-right
00:30:32 <edwardk> you can make up for it by chunking and running LZ78 over chunks, but you lose the dictionary at the edges
00:30:46 <wli> edwardk: "... and Simon Peyton Jones said, ``Let there be thunks,'' and the dictionary was never generated save for what was actually used."
00:30:49 <BMeph> edwardk: Now I get: "Data\Monoid\FromString.hs:25:7:   Could not find module `Data.Monoid.Instances':"
00:31:05 <edwardk> BMpeh: progress ;)
00:31:13 * BMeph snorts
00:31:21 <edwardk> wli: the problem is that it has to be enumerable
00:31:30 <edwardk> wli: and relatively small ;)
00:32:21 <edwardk> just using find . to generate the contents of the cabal file
00:32:29 <BMeph> I feel like Martin Escardo's Exhaustable sets-stuff should help us out with such things somehow...
00:32:58 <BMeph> edwardk: I guess I should've just kept .5 up. ;)
00:37:20 <edwardk> bmeph: ok, uploading, having regenerated the list of modules procedurally ;)
00:37:40 <kohwj> BMeph: yup, latest versions
00:37:55 <kohwj> BMeph: i guess it's a problem with the TH package
00:38:40 <edwardk> i need to break up a few of those dependencies into flags
00:40:48 <edwardk> BMeph: looking up the escardo stuff
00:41:18 <edwardk> oh i remember that
00:41:38 <BMeph> edwardk: BTW, 0.1.10 compiles. :)
00:41:43 <edwardk> woot
00:41:45 <edwardk> 4th times the charm
00:42:31 <edwardk> lots of fun combinators to play with, but mostly i enjoy just going in and asking the lz78 stutff to encode and decode ;)
00:42:32 <BMeph> edwardk: Maybe you should save a step, and just name the next version 0.1.15, that way it's bound to work the first time... ;p
00:43:04 <edwardk> now if i can just get the BentleyMcIlroy stuff to work
00:47:10 <edwardk> bmeph: now, one thing i'm considering is this: http://hackage.haskell.org/packages/archive/Diff/0.1.2/doc/html/Data-Algorithm-Diff.html#v%3AF
00:47:33 <wli> If I make up a bunch of typing rules and natural deduction or sequent calculus stuff, how do I know if it even makes any sense?
00:47:35 <edwardk> and trying to figure out what the best way to use that for incremental reparsing given a fingertree
00:47:45 <edwardk> wli: prove the admissability of cut, thats a good start
00:48:15 <edwardk> wli: my favorite way to make sure that it remains consistent is to appeal to 'Display Logic', but the papers for that are hard to find
00:48:39 <wli> I have no idea how "admissibility of cut" figures into anything.
00:48:54 <edwardk> mainly because that gives you a small list of 7 properties you have to ensure for each connective in isolation, that will globally give you the admissability of cut
00:48:58 <edwardk> hah fair enough
00:49:17 <edwardk> the admissability of cut is basically the fact that in your logic you can prove lemmas and reuse them
00:49:30 <edwardk> any proof using cut can be proven without cut in a 'good' logic.
00:50:02 <wli> It sounds like some sort of Prolog construct is getting plucked out of thin air, and then must have some property whose meaning is unclear.
00:50:03 <edwardk> usually cut isn't given as an axiom, its just proven that its admissible, that given any proof that uses cut you can commute it away and yield a proof that doesn't use it
00:50:43 <edwardk> http://twelf.plparty.org/wiki/Admissibility_of_cut
00:53:24 <edwardk> wli: basically cut says that if Gamma |- A, and Gamma, A |- C then Gamma |- C. which says that if you can go through an intermediate state A to get to C, you can get to C.
00:53:26 * wli is completely blown away.
00:53:35 <edwardk> its one of the rules that just makes sense when you think about it
00:54:19 <edwardk> wli: proving the admissability of cut is one of the most tedious things about working with your own logic
00:54:39 <wli> Or making up your own type system?
00:55:17 <edwardk> wli: thats why logicians like to use tricks to avoid having to construct it. i was using display logic as the back bone of a type system because the proof of cut elimination and the idea of forming a lemma or function are basically the same thing.
00:55:28 <edwardk> and display logic makes the proof of cut elimination easy and compositional
00:55:44 <edwardk> normally if you have n connectives your cut admissability proof grows to n^2 cases.
00:56:11 <wli> Is it something you can plug and chug with Agda et al?
00:56:40 <wli> Or Coq, or whatever?
00:57:00 <edwardk> wli: you _could_ but in general its a pain in the neck to encode any of this junk in any platform. naming, hoas, various encodings, etc. all generally suck
00:57:26 <edwardk> wli: twelf which that link uses is great at dealing with names, but not so great at other stuff.
00:58:20 <jbapple> If you're only using the usual binders, embedding is easier
00:58:41 <wli> How come this is the first time I've even heard of it?
00:58:53 <jbapple> The more (and more unusual) your binders are, the harder it is to encode things properly
00:59:14 <edwardk> wli: its audience is somewhat insular ;)
00:59:20 <jbapple> Twelf doesn't have polymorphism or proof scripting
00:59:26 <jbapple> This makes some people shy away
00:59:39 <jbapple> the CMU people are VERY INSISTENT that it's the right way
00:59:43 <jbapple> and they are very smart
00:59:54 <jbapple> but very insistent
01:00:00 <edwardk> and hence why others shy away ;)
01:00:07 <jbapple> :-)
01:00:42 <edwardk> wli: any other data compression algorithms you can think of that i should adapt into data structures?
01:01:03 <BMeph> edwardk: Ah, vcdiff.
01:01:09 <BMeph> I'll read up. :)
01:01:17 <edwardk> BMeph: bentley-mcilroy is already on my plate ;)
01:01:19 <wli> Compression? No. Error detection and correction OTOH...
01:01:48 <edwardk> BMeph: i've just got to figure out a pile of bugs in my current implementation and it'll be in there
01:02:04 <wli> Reed-Solomon, Goppa/AGC, etc.
01:02:35 <edwardk> bmeph: i figure i can use a gzip wrapper around a bentley-mcilroy transformer to deal with both local redundancy and large scale redundancy
01:02:41 <wli> jbapple: What do you mean by "binders?"
01:02:49 <edwardk> wli: hrmm, those would mostly drop in as monoidal reductions
01:03:04 <jbapple> wli: good question
01:03:05 <edwardk> wli: lambda, forall, exists, Pi, etc.
01:03:28 <edwardk> basically stuff that gives meaning to names
01:03:29 <jbapple> anything that introduces a new name
01:03:48 <edwardk> binders 'bind' names
01:04:27 <mmorrow> dons: yes, it's avoiding *Array#, MVar#, and stuff like that. The exact list is all the closure types whose info table is just "barf(\"Entered a _!\")" and that aren't checked for in unpackClosure# (see the comment at the very end of that file)
01:04:30 <wli> module decls, signature decls, import qualified as, variant constructor decls, variant label decls, let exprs, etc.?
01:05:17 <mmorrow> dons: so it's dropping the HValue that's the ByteArray# in J# for instance
01:05:35 <wli> And, of course, module-level variable bindings?
01:05:57 <edwardk> wli: one thing i liked about Yarrow was you could define new binders http://www.cs.ru.nl/~janz/yarrow/userg.html#binder
01:06:25 <edwardk> hrmm, haskell source code for that http://www.haskell.org/yarrow/yarrow98.html
01:07:29 <mmorrow> dons: hmm, i haven't tried ByteString yet, i'll see
01:10:25 <wli> So it's vaguely how many namespaces you're simultaneously screwing with?
01:14:11 <jbapple> wli: well, how many names
01:14:22 <jbapple> unless you allow pattern binders
01:14:40 <wli> NFI what a pattern binder is.
01:14:55 <jbapple> \(x,y) -> x+y binds two names
01:15:30 <wli> Well, this is only trying to actually define what I'm writing an interpreter for before I write it.
01:15:31 <jbapple> but in the usual formal calculi, binders only get one name: \xy -> (fst xx) + (snd xy)
01:16:16 <wli> I usually see huge messes above and below the line.
01:16:21 <jbapple> :-)
01:16:26 <wli> The top usually messier than the bottom.
01:16:44 <edwardk> hah
01:17:20 <edwardk> i obsessed about pure type systems and substructural logic for a while and got used to them
01:17:27 <wli> It looks like they're binding huge numbers of things at a time.
01:17:35 <wli> Not even fixed numbers of them.
01:18:09 <jbapple> the rules of the grammar may bind lots of things, but the binders in the language usually only bind one
01:19:18 <edwardk> wli: a binder is just something like \x. M that is one thing being bound, which means you have to deal with local renaming for 'x' within the expression M. there is a lot of other variable names and contexts and things floating around but those aren't 'binders'
01:20:17 <wli> \x y z -> x + y + z binds 3
01:20:41 <jbapple> right, but that's syntactic sugar
01:20:44 <wli> case exprs bind huge rafts of them at a time
01:21:01 <jbapple> for \x -> (\y -> (\z -> x+y+z))
01:21:29 <edwardk> the former could be rewritten into \x. \y. \z. x + y + z
01:21:56 <edwardk> case expressions can be rewritten into other styles that don't need multiple variable bindings, etc.
01:22:32 <wli> Does that simplify or complicate them?
01:22:41 <edwardk> depends on your perspecive ;)
01:23:05 <wli> I can see one binding per-alternative maybe.
01:23:21 <edwardk> woo, Functor LZ78
01:23:48 <mmorrow> @src repeat
01:23:48 <lambdabot> repeat x = xs where xs = x : xs
01:24:52 <wli> Is the idea here how many different analogues of alpha renaming you've got?
01:27:02 <wli> Or constellations of alpha/beta/etc. equivalences there are?
01:46:20 <ivanm> If I have one module that re-exports a definition from another module that is hidden (i.e. it isn't exposed in the .cabal file), where do the docs for that definition get placed by haddock?
01:52:20 <mmorrow> ivanm: i don't think they get put anywhere
01:52:30 <ivanm> :s
01:52:41 <ivanm> so I can have undocumented types and functions in my code? :p
01:53:10 <mmorrow> yay! ... :/
01:53:45 <ivanm> *sigh* OK, looks like I'll have to make those modules exported after all... >_>
01:53:54 <ivanm> even though they were only meant to be internal ones :s
01:54:13 <mmorrow> ivanm: you could just
01:54:14 <mmorrow> #ifdef __HADDOCK__
01:54:19 <mmorrow> foo :: ....
01:54:22 <mmorrow> foo = undefined
01:54:25 <mmorrow> #endif
01:54:37 <ivanm> hmmm...... how about type definitions?
01:54:39 <mmorrow> (and also #if.. the import)
01:54:46 <ivanm> and what would ghci think? :s
01:54:55 <mmorrow> it'll be ok
01:55:07 <ivanm> how do I #if the import?
01:55:11 <mmorrow> just put {-# LANGUAGE CPP #-} in the file
01:55:26 <mmorrow> i'll paste an e.g.
01:55:34 <ivanm> you mean #ifdef __HADDOCK__ ... #else import Foo #endif ?
01:56:12 <mmorrow> exactly, but a single #ifndef import Foo #endif would also work
01:56:23 <mmorrow> #ifndef __HADDOCK__ import Foo #endif would also work
01:57:33 <ivanm> *nod*
02:03:20 <kadaver> vietnow!
02:03:57 <ivanm> kadaver: wtf?
02:06:27 <wli> It's all dead air.
02:08:32 <edwardk> trying to figure out if "PutM" from binary can be made into a MonadPlus so i can build a nice parallelizable binary container
02:10:10 <edwardk> hrmm there is already a Builder monoid
02:11:37 <edwardk> ok, not a monadplus, but maybe i can build this out of Builder
02:14:03 <ivanm> mmorrow: what do you think the neater option is? a whole bunch of ifdefs, or just allowing that module to be visible?
02:15:30 <mmorrow> ivanm: i'm not sure, i think i could lean either way depending on what's in that hidden module..
02:16:12 <ivanm> actually.... I suppose I could allow the hidden modules, as none of internals are revealed
02:16:28 <ivanm> I was just going to have one big module that ties a couple of them in together, that's all
02:16:56 <ivanm> but one of them is remaining hidden, due to the high levels of ugly hackery it involves :s
02:16:58 <edwardk> hrmm interesting, the Binary instance for lists actually requires it to be finite. you can't encode an infinite binary list and just serialize it until you get bored
02:17:12 <wli> Where the denizens of #haskell lead, I cannot follow.
02:18:00 <augustss> edwardk: seems like only a minor nuisance.
02:18:19 <edwardk> augustss: its not terrible, just unexpected
02:18:45 <edwardk> augustss: i am trying to figure out how to add a nice parallelizable Binary based encoder for my monoid lib
02:19:08 <augustss> Ah.  Does binary put the list length first?
02:19:14 <edwardk> yeah
02:20:37 <mmorrow> edwardk: i guess you could do an "HTTP chunked" encoding
02:22:53 <edwardk> mmorrow: i'm not quite sure where i'm going yet, but i'd like to be able to use the Binary Char  instance as the inverse of the parallel utf8 decoder. and if i'm going that far i should be able to generate things off of other Binary instances. Builder's are monoids, but they are trivially so since they just difference list themselves together.
02:23:22 <ivanm> since mkcabal is dead, is there any other cabal-helpers? (since haskell-mode for emacs doesn't seem to generate stuff either :s )
02:24:19 * wli fails to figure out if his interpreter garbage makes any sense for want of the logic stuff used for such things.
02:24:49 <mmorrow> edwardk: hmm. some sort of "parallel builder" would be interesting (i have no idea what that's supposed to mean :)
02:25:46 <ivanm> mmorrow: heh
02:26:02 <edwardk> in my current library terminology I guess what I want is a Monoid that reduces any Generator, even my parallel ones, yielding a Generator that you can apply any Word8 Reducer to.
02:26:29 <mmorrow> ah, i see
02:26:57 <edwardk> mostly so i can round trip some things and check properties, but also so i can store a bunch of stuff flattened out into bytestrings on demand
02:28:36 <kadaver> http://www.haskell.org/haskellwiki/FFI_Introduction <- there .c files include .h files? why? isnt it supposed to be the other way around?
02:28:38 <edwardk> so i guess its not imperative that i store everything in the same bytestring, just that i be able to use the Builder machinery reasonably efficiently
02:29:01 <edwardk> kadaver: er, no? =)
02:29:27 <wli> Are reducers anything like linear-bounded automata?
02:30:07 <edwardk> a reducer is just a monoid that knows how to inject values from some other type.
02:31:28 <wli> It sounded vaguely like they shortened their input with every reduction carried out, in like fashion to an LBA.
02:31:32 <edwardk> i.e. my i have a reducer "UTF8" that knows how to take a Word8 and yield partial information about utf8 encoding. given several of that monoid mappened together it can feed the fully formed characters to an appropriate Char Reducer
02:32:21 <edwardk> kinda, reducers support unit, snoc and cons, unit injects a single value, snoc and cons are optional left and right- biased reductions
02:33:19 <edwardk> a reducer has no "lookahead" it can just merge one element into a monoid, either out of whole cloth or by just concatenating on the left or right
02:33:49 <wli> So they're more like zero-lookahead automata that can choose arbitrarily between the leftmost and rightmost derivations on a handle.
02:34:27 <wli> vs. an LBA nondeterministically plucking handles out of the middle of input and deriving nondeterministically from that.
02:35:03 <edwardk> wli: closer yeah
02:35:33 <edwardk> but note that they don't have to have anything to do with parsing. for instance i have reducers for monads, etc.
02:36:49 <edwardk> there is an 'Action m' monoid that encapsulates actions with no return type (m ()) in some Monad m. which is a reducer over 'm a' forall a. so that it can be used to directly implement mapM_ and forM_ over a Generator
02:38:46 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Combinators.html is mostly just a menagerie of uses of different Reducer instances
02:39:32 <wli> looking
02:39:47 <edwardk> augustss: btw- your http://augustss.blogspot.com/2008/07/lost-and-found-if-i-write-108-in.html post was useful. i needed a fast way to 'exponentiate' Monoids, and you already did all the hard work ;)
02:40:02 <augustss> :)
02:40:34 <edwardk> the generalized 'replicate' is basically just a cut and paste copy with attribution
02:41:09 <augustss> Well, it's the same code as is in the ghc library now.
02:42:30 <edwardk> that reminds me i need to test out the compression containers against sigfpe's regex example from a little while back
02:42:48 <ivanm> Can an Array store any data type?
02:42:57 <ivanm> e,g, even an infinite list?
02:43:05 <edwardk> sure, it doesn't force it
02:43:25 <ivanm> *nod*
02:43:34 <edwardk> now, the array itself can't be infinite, but it can hold onto infinite things
02:43:38 <ivanm> I take it it uses memory loc pointers rather than actually storing the value then?
02:43:51 <edwardk> yeah basically you get a bunch of pointers to thunks
02:43:55 <wli> Maybe I should try out the tracing there on my Fib function.
02:43:56 * ivanm had misread the IArray haddock page, and confused UArray entries with Array :s
02:46:19 <ivanm> wli: maybe you should try vacuuming :p
02:50:20 <kadaver> math.h,math.c,main.c. what includes what?
02:51:29 <edwardk> my goal right now is to make the lz78 stuff lazy enough that it doesn't choke on infinite sources
02:51:55 <mlesniak> Because I've seen both: what is the nameing convention for function names: foo_bar or fooBar or ...?
02:53:46 <edwardk> Prelude Data.Monoid.Generator.LZ78> take 20 $ decode $ encode (cycle "Hello") ==> "HelloHelloHelloHello" -- hah i should choose harder goals
02:54:21 <Eridius> Data.Monoid.Generator.LZ78?
02:54:24 <edwardk> as vixey would say i had to ditch 'tail recursion' ;)
02:54:43 <edwardk> Eridius: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Generator-LZ78.html
02:55:48 <wli> mlesniak: fooBar is more idiomatic to Haskell
02:56:52 <beelsebob> ehird: http://code.google.com/p/hoc/issues/detail?id=14 <-- for reference, I stuck up your method for building HoC
02:58:40 <beelsebob> also, Woooo, working HoC!
03:00:27 <kadaver> anyone know a good explanantion iof the linking and .h stuff in C because it makes me want to blow my brains out
03:00:47 <mlesniak> wli, Thanks
03:01:05 <edwardk> hrmm the parallel RLE builder is pretty dumb too, but the list based one works fine on infinite data
03:01:06 <Eridius> kadaver: .h files have nothing to do with linking
03:02:17 <edwardk> i think what i need is a 'dumb box' that doesn't try to rebalance like finger trees which just contains snoc, cons and append constructors
03:02:26 <edwardk> oh, and unit
03:02:44 <edwardk> and mempty
03:04:50 * kadaver thinks about drinking acid as a viable alternative to getting his head around C #includes and header files
03:05:10 <Eridius> C #includes and header files are trivially simple. What's the problem?
03:06:14 <kadaver> C channel can enevr give answer when you ask, its like they refuse to tell you anything outright.
03:06:23 <Eridius> there's a C channel? o_O
03:06:33 <Eridius> so kadaver, care to explain your issue?
03:06:42 <kadaver> math.c math.h and main.c . main.c should include math.h
03:06:55 <kadaver> but math.h shouldnt include math.c and math.c shouldtn include math.h ?
03:06:56 <Eridius> most likely yes
03:07:02 <Eridius> err, you don't include .c files
03:07:06 <Eridius> math.c should include math.h
03:07:11 <kadaver> why?
03:07:20 <Eridius> because math.h declares the functions that math.c will implement
03:07:24 <kadaver> it makes no sense
03:07:27 <Eridius> additionally, math.h may declare other types, like structs or enums
03:07:32 <Eridius> why doesn't it make sense?
03:09:50 <kadaver> gcc -Wall -o Main main.c isnt valid?
03:09:53 <mmorrow> -lm
03:10:03 <kadaver> -lm ?
03:10:05 <Eridius> kadaver: you're not compiling in math.c
03:10:08 <Axman6> kadaver: it makes sense if you understand why you need header files
03:10:10 <mmorrow> err, that is if you need the math lib
03:10:20 <mmorrow> n/m i think you're talking about something else.. :)
03:10:39 <kadaver> so allf iels to be compile dhsould be passed to the compiler not be included?
03:10:45 <Eridius> kadaver: `gcc -Wall -o Main main.c math.c` will work (unless you need to link against any system-provided libs, then you need to add the appropriate -l flags)
03:11:06 <Eridius> kadaver: .c files are not #included, only .h files are. And .h files aren't compiled, only .c files are
03:11:11 <Eridius> so you have to tell the compiler what files to compile
03:11:25 <Eridius> the header files declare the interfaces that the .c files implement, and header files also define new types
03:11:55 <Eridius> math.c must include math.h so it has access to its own interface (this allows it to make use of types declared in math.h, and for functions in math.c to call each other, and for the compiler to ensure that the function signatures in math.c match those in math.h)
03:12:43 <Eridius> but when you're compiling your program, you have to compile all the .c files
03:13:01 <Eridius> either put them all in one command, or compile them separate to object files, and then "compile" all the object files in one command
03:13:25 <Eridius> (you might want to do the two-step process so changing one source file doesn't require recompiling all of them)
03:15:32 <wli> There are other ways things do this.
03:16:33 <kadaver> ok now ig et it
03:16:47 <wli> I'd better not confuse him.
03:16:51 <Eridius> heh
03:17:35 <kadaver> does order matter
03:17:35 <kadaver> C:\cprogs\Hashtable>gcc -Wall -o Main main.c Hashtable.c LinkedList.c
03:18:16 <Eridius> in the general case, I don't believe so
03:20:03 <wli> If you're doing something where it matters, you should know that you're trying to do it and that you shouldn't be trying to do it.
03:20:19 <wli> (Linux initcalls...)
03:22:10 <dons> mmorrow: uploaded improved ui
03:22:19 <dons> now uses a persistant window,
03:22:20 <dons>   http://www.youtube.com/watch?v=nQkhELdAYB8
03:26:07 <Eridius> ugh, when I try and use vacuum-cairo I get these "Pango-WARNING **: Error loading GPOS table 0x6EAD" whenever it renders something
03:26:33 <kadaver> bah how do i compile to jsut an object file?
03:26:46 <Eridius> IIRC it's the -c switch
03:26:51 <mmorrow> dons: awesome
03:27:08 <mmorrow> dons: what are you using to make those captions?
03:27:59 <dons> youtube
03:28:49 <mmorrow> hmm, i guess i'm just not hip :)
03:29:06 <kadaver> and if Hashtable.c uses LinkedList.c how do I link them?
03:29:45 <mmorrow> dons: those list comprehensions are sweeet
03:30:01 <mmorrow> this is a pretty one too:
03:30:09 <mmorrow> fix (\x -> Node () [x,x])
03:30:10 <dons> yeah
03:30:11 <dons> ooh
03:31:03 <wli> (I guess ctor calls for C++)
03:31:55 <dons> mmorrow: so i might play a bit more with the size of the arrows, but probably done now.
03:32:10 <dons> you could imagine encorporating this with the ghci debugger
03:32:18 <mmorrow> dons: those Maps are really nice too
03:32:20 <dons> so the thing you force in the debugger also gets displayed alongside
03:32:24 <mmorrow> dons: totally.
03:32:34 <dons> yeah, the maps are interesting.
03:32:47 <dons> IntMap is perfectly balanced, while Map has funky rebalancing nodes (i think) going on
03:32:51 <mmorrow> i've gotta install gtk2hs asap
03:33:07 <dons> pacman -S gtk2hs , if you're using Arch
03:33:12 <Eridius> I don't suppose anybody knows how I can fix the pango warnings that I get?
03:33:12 <mmorrow> dons: oh interesting, i've only really done IntMaps thus far
03:33:18 <mmorrow> dons: heh
03:33:45 <wli> dons: I wonder how Data.Tree.AVL does, though its API is very weird relative to Data.Map
03:34:11 <mmorrow> wli: ooh, i'm making a note to check that one out too
03:34:42 <dons> mmorrow: have you announced vacuum on the lists yet?
03:34:49 <wli> And whatever the rbtree called a 2-3 tree is.
03:34:50 <dons> or has it just been a grassroots movement
03:35:00 <mmorrow> dons: no, i'm going to do that shortly though
03:35:06 <dons> "visualizing okasaki" would be a good post
03:35:13 <mmorrow> heh
03:35:18 <Eridius> hey dons, with vacuum-cairo 0.2, the window starts out really tiny
03:35:31 <dons> Eridius: sure. resize as needed.
03:35:43 <dons> it just takes the size of the splash screen by default
03:35:46 <Eridius> well sure, I can resize, it just starts out far smaller than any possible view would require
03:35:47 <Eridius> ahh
03:35:48 <kadaver> but how can i compile Hashtable.c to .o and link to LinkedList?
03:35:54 <dons> Eridius: oh, you using 0.2?
03:35:56 <Eridius> yes
03:35:59 <mmorrow> yeah, that'd be a pretty cool gallery.. vacuum all a bunch of stuff in purely functional datastructures
03:36:04 <dons> so it should be the size of that gtk image
03:36:09 <dons> try:  view (1,2)
03:36:11 * Eridius doesn't like resizing though because that causes it to re-display which causes it to re-print out 3 Pango warnings :/
03:36:20 <Eridius> so resizing spews about 20 pages onto my terminal
03:36:29 <dons> cute
03:36:35 <wli> Okasaki himself would probably be interested.
03:36:49 <Eridius> hrm, when the window's already visible, a single `view 3` call causes the trio of warnings to print out 3 times
03:37:15 <dons> i'm not sure why. i don't use pango
03:37:21 <Eridius> so what are the numbers in the vacuum graph? the order the values were visited in?
03:38:08 <Eridius> dons: graphviz uses svgcairo I think
03:38:28 <Eridius> actually hrm, graphviz isn't linking against librsvg by default
03:38:32 * Eridius just reinstalled the latest version today
03:38:52 <wli> gentoo doesn't like the deps
03:38:55 <Eridius> though svgcairo is still being linked against
03:39:03 <mmorrow> another thing i'm thinking about is the possibility of dumping arbitrary heap values to bits as a generic serialization method (w/ the sharing intact!) a la smlnj
03:39:17 <Eridius> oh durr, I'm confusing svgcairo with pango for some reason
03:39:31 * Eridius is confused because he had earlier issues with svgcairo, but the new issues are not the same as the old ones
03:39:38 <dons> integrating with ghci debugger would  be cheap and easy, imo.
03:39:47 <dons> then it'd get used for teaching...
03:39:53 <mmorrow> i think the reading-back-in part would need rts-support though..
03:40:08 <mmorrow> dons: yeah, it'd be really nice.
03:40:31 <Eridius> hrm dons, I actually see (process:87780) print the warnings, then (<interactive>:87779) print the same warnings 3 more times. Why is ghci re-echoing the same warnings as some child process?
03:40:32 <wli> mmorrow: exportFn for Haskell?
03:40:39 <mmorrow> wli: totally!
03:40:51 <Eridius> in any case, graphviz uses pango
03:40:52 <mmorrow> well, for ghc
03:41:27 <mmorrow> hmm, i guess it could be made somewhat rts-agnostic somehow
03:41:37 <Eridius> macports has a variant called no_pangocairo which apparently removes "pangocairo" support, with the effect that no antialiased bitmap output or PDF output
03:42:14 <wli> cabal: cannot configure vacuum-0.0.5. It requires base ==4.*, ghc ==6.10.1 and
03:42:14 <wli> ghc-prim -any
03:42:16 <ivanm> dons: I notice you don't seem to respond to messages in other channels... ;-)
03:42:27 <ivanm> wli: well, do you have ghc-6.10.1?
03:42:55 <wli> No. I'm not going to try to maintain a patched package.
03:43:00 <kadaver> C:\cprogs\Hashtable>gcc -Wall -O2 -c LinkedList.c; now I want tco compile Hashtable.c that uses(inclues LinkedList.h) LinkedList.c, how?
03:43:06 <ivanm> wli: hmmm?
03:43:07 <wli> Nor will I use it unpatched.
03:43:16 <ivanm> why do you need to patch it?
03:43:25 <wli> ivanm: readline
03:43:35 <ivanm> ahhhh
03:43:56 <ivanm> why don't you just use the readline version?
03:44:09 <wli> There isn't one.
03:44:21 <wli> kolmodin isn't done yet.
03:44:22 <ivanm> or libeditline... whatever it was released with
03:44:30 <ivanm> wli: I think it is...
03:44:33 <ivanm> s/it/he/
03:44:42 <ivanm> since that's what we've got here, and he's pushed the patches...
03:45:35 <wli> libeditline was a doorstop when I tried it, so I literally masked ghc-6.10.x and am holding out for being dead sure ghc-6.10.x as it appears in gentoo has the readline patches applied.
03:45:56 <ivanm> wli: the one in the overlay does
03:46:15 <catface> what about rlwrap?
03:46:18 <mmorrow> wli: the strict 6.10.1 dep is on accound of that it's using the closuretypes straight from ClosureTypes.h, and it needs to get an HscEnv from the ghc-api in order to init all the hidden global vars so it can (actually, i'm not even really sure why it needs that, but something crashes if i don't init ghc) do something or other..
03:46:41 <mmorrow> and the ghc-api has breaking changes 6.10.0 -> 6.10.1
03:46:46 <mmorrow> let alone previous versions
03:47:01 <mmorrow> wli: what ghc version do you have?
03:47:32 <wli> 6.8.3
03:48:00 <wli> ivanm: I don't see readline in the 6.10.1 ebuild I have from the overlay
03:48:02 <mmorrow> wli: cool. i'll see if i can make a version for 6.8.3, i don't think it'd be too difficult.
03:48:21 <ivanm> wli: if you've synced it recently, it should be there
03:48:47 <ivanm> wli: see if it has the arch_binaries ugliness from trofi...
03:48:53 <wli> I synced it only a couple of hours ago.
03:49:05 <wli> I see no arch_bin string.
03:50:12 <Eridius> what the... I just reinstalled graphviz using +no_pangocairo and yet it still is using pango
03:50:37 <ivanm> wli: where are you syncing from?
03:50:49 <ivanm> code.haskell.org/gentoo/gentoo-haskell ?
03:51:34 <mmorrow> Eridius: oh gahhh, i've been through that hell before.
03:51:41 <Eridius> mmorrow: any idea what's going on?
03:51:41 <mmorrow> are you trying to build from source?
03:51:47 <Eridius> I do build from source, yes
03:51:48 <ivanm> Eridius: manual compilation I take it?
03:51:49 <Eridius> using MacPorts
03:51:58 <wli> checking
03:52:06 * ivanm checks what gentoo uses
03:52:10 <mmorrow> i never actually got it resolved. on one box i had some precarious setup where everything worked
03:52:24 <ivanm> Eridius: you trying to use cairo still, or dumping that as well?
03:52:25 <mmorrow> but on another that didn't have whatever was needed, i never got it resolved
03:52:31 <ivanm> it appears you have to have pango if you want cairo...
03:52:41 <Eridius> ivanm: how can I dump cairo? The package is vacuum-cairo
03:52:44 <Eridius> and pango depends on cairo, not the other way
03:53:06 <ivanm> Eridius: I meant graphviz' cairo support depends on pango support
03:53:11 <Eridius> ah yes
03:53:12 <mmorrow> Eridius: i was building graphviz from the cvs, so i'm not sure
03:53:13 <ivanm> if I read the ebuild right
03:53:15 <Eridius> I don't care if graphviz uses cairo
03:53:54 <ivanm> Eridius: according to the ebuild for it in gentoo, if you use cairo then you still need pango for layout
03:53:58 <ivanm> *text layout
03:54:01 <wli> For some reason I no longer have the Haskell overlay installed.
03:54:05 <mmorrow> my thing was that i wanted graphviz to have the nice png rendering on this one hosted server, but couldn't seem to figure out howtf to get it (and iirc it had something or other to do with pangocairo)
03:54:05 <ivanm> wli: :o
03:55:04 <mmorrow> Eridius: so actually my experience might have no relevance to what you're doing .. :)
03:55:10 <Eridius> heh
03:55:15 <mmorrow> hehe
03:56:49 <Eridius> oh hrm, I think graphviz's only contribution here is the dot program, so it's not graphviz's usage of pango that's the problem
03:57:18 <Eridius> I think it's gtk2
03:57:44 <ivanm> Eridius: there's guis included in there, IIRC
03:57:57 <Eridius> ivanm: I'm looking at the vacuum-cairo source, I'm pretty sure the warnings are coming from Gtk2
03:58:05 <Eridius> rather irritating
03:58:19 <ivanm> Eridius: so is your problem from vacuum-cairo or graphviz?
03:58:28 <Eridius> vacuum-cairo
03:58:32 <Eridius> apparently it's coming from gtk2hs
03:58:38 <Eridius> and I can't break gtk2's relationship on pango
03:58:43 * Eridius wishes he knew why pango was printing these warnings in the first place
04:00:30 <wli> fresh overlay installed
04:02:47 <kadaver> struct record *r = malloc(sizeof(struct record)); or struct record *r = malloc(sizeof(struct record*));
04:03:01 <wli> I don't see any arch_binaries stuff
04:03:36 <ivanm> Eridius: gtk2hs doesn't seem to depend on pango here...
04:03:42 <Eridius> gtk2 does
04:03:45 <ivanm> of course, it might be a dep we've missed in the ebuilds...
04:03:45 <Eridius> for me, at least
04:03:57 <ivanm> Eridius: as in the gtk lib part of gtk2hs, or the real deal?
04:03:58 <Eridius> the MacPorts dependencies list for gtk2 shows pango
04:04:09 <Eridius> as in the gtk2 lib
04:05:48 <ivanm> ahhh
04:05:51 * ivanm can't help you there then
04:06:36 <wli> mmorrow: trying to install ghc-6.10.1
04:06:51 <mmorrow> wli: nice.
04:07:08 <kadaver> Hashtable.c:70: error: dereferencing pointer to incomplete type
04:07:14 <kadaver> what does thts men really?
04:07:29 <mmorrow> kadaver: add a cast
04:07:39 <mmorrow> *((foo*)x)
04:08:19 <mmorrow> it means it doesn't know what it's dereferencing, so it doesn't know what code to generate
04:09:48 <ivanm> wli: found the overlay again?
04:10:29 <ITX> where can i get a eMac?
04:12:13 <solidsnack> A jMac would be cool.
04:12:23 <vixey> is jMac orthogonal to iMac?
04:12:23 <solidsnack> Straight Java.
04:12:56 <bremner> ITX: ask in #emacs?
04:12:57 <solidsnack> vixey: Oh, that would be cool, too. You could have Macs for all the basis vectors of Clifford algebra.
04:12:58 * bremner ducks
04:13:16 <solidsnack> viMac
04:13:24 <solidsnack> That's what I've got :)
04:13:31 <dolio> Or one for each of the New Kids?
04:14:06 <ivanm> ITX: ask Apple
04:14:33 <vixey> > subtract 1 4
04:14:34 <lambdabot>   3
04:14:46 <ivanm> because AFAICT, (unsafePerformIO getChannelName) /= "#apple"
04:14:47 <ivanm> ;-)
04:15:34 <wli> ivanm: Yeah, I just had to layman --add=haskell to get it back after mysteriously having it disappear
04:15:42 <ITX> #emac
04:16:10 <pmurias> hi, where can I find a precise explanation of the monomorphism restriction (i have seen http://www.haskell.org/haskellwiki/Monomorphism_restriction but it dosn't explain it fully enough for me)
04:17:09 <ITX> anyone here know any uni's in UK that teach Haskell?
04:17:24 <ITX> just Haskell course not like haskell and other functional languages..
04:17:59 <kadaver> ITX: i would assume cambridge oxford etc,dont know though
04:18:14 <kadaver> maybe msot teach functional programming and not jst haskell
04:18:17 <kadaver> im not uk
04:20:32 <ITX> ah, i don't think i'll be able to get into them :(
04:20:38 <dolio> pmurias: You could try the haskell98 report. What was wrong with that page?
04:22:37 <frwmanners> ITX: Cambridge teaches ML, category theory for computer science &c. but not haskell per se as for as I know
04:23:01 <Adamant> does Oxford teach Haskell?
04:23:24 <Adamant> I would assume they do but you never know.
04:24:30 <RayNbow> http://www.haskell.org/haskellwiki/Education
04:24:33 <arjanb> ITX: there are about 10 where people do haskell related research but i have no idea about courses
04:25:10 <sioraiocht> Adamant: Oxford is a MAJOR fan of haskell
04:25:12 <catface> york taught gofer when i was there
04:25:20 <sioraiocht> Adamant: the first course in programming for first years is in Haskell
04:25:33 <sioraiocht> and a lot of reserach that utilises Haskell is done at Oxford
04:25:39 <Adamant> sioraiocht: I knew they supported lots of Haskell-wieldin Ph.D's
04:26:04 <beelsebob> anyone here used HoC before?
04:26:09 <sioraiocht> Adamant: yes =) There is a functional programming research group, and the Algebra of Programming group has overlapping interests
04:26:13 <Adamant> kind of odd for Cambridge to not be on the ball there.
04:26:16 <ITX> to get in oxford don't you need like all As or higher in GCSE/A level?
04:26:18 <beelsebob> sioraiocht: that's pretty common at UK unis
04:26:32 <beelsebob> that the first course is either Haskell or Scheme
04:26:36 <Adamant> I would have expected Cambridge to have lead the pack in that regard
04:26:47 <beelsebob> it reminds students that they don't know everything before they even start
04:26:51 <sioraiocht> Adamant: Cambridge's focus in CS is very different from Oxford's
04:27:05 <sioraiocht> ITX: depends on teh program and the student
04:27:07 <Adamant> sioraiocht: less theory-y, more practical?
04:27:14 <sioraiocht> Adamant: yes
04:27:17 <Adamant> sioraiocht: their security program is outstanding
04:27:27 <pmurias> dolio: i read the report at it cleared things up
04:27:35 <sioraiocht> Adamant: Oxford's focus is on formal methods and verification and such
04:27:41 <Adamant> ah, makes sense then
04:27:58 <luite> RayNbow: bah utrecht isn't even listed there
04:28:00 <wli> I need to bone up on my logic so I can define wtfh. I want to write my interpreter for.
04:28:00 <ITX> My expected grades are Cs and Ds - which are incorrect, factors included on your grades include where you live etc, how much your mam and dad earns, total crap - so far I've got an A in maths and A and B in science
04:29:07 <sioraiocht> ITX: oxford usually grants nearly everyone an interview, and a lot hinges on the interview
04:29:26 <sioraiocht> and any entrance exam, if there is one for the course for which you are applying
04:29:50 <Adamant> sioraiocht: ah, I just thought Oxford tended to be the laggard in sci/tech/math type things
04:29:57 <Adamant> compared to Cambridge
04:29:58 <sioraiocht> Adamant: no, that's not true at all
04:30:06 <wli> My sequent calculus and/or natural deduction or whatever (all my books are gone and they were worth several times more than my car) is nonexistant.
04:30:28 <ITX> <ITX> I found Haskell in a local uni, but it's not just Haskell, it's java too, I just want Haskell
04:30:28 <ITX> <ITX> http://coursework.cs.ncl.ac.uk/module/2007/CSC2001
04:30:30 <millz> University of Edinburgh teaches haskell as first programming language
04:30:44 <millz> with Philip Wadler as Professor and lecturer
04:30:45 <sioraiocht> Adamant: the
04:30:53 <Adamant> so it's more of a theoretical/practical distinction?
04:31:00 <sioraiocht> no, that's not in CS
04:31:19 <Adamant> ah
04:31:22 <sioraiocht> the oxford genetics lab, for example, is at the forefront of genetics research
04:31:33 <sioraiocht> the chemistry dept here is the largest in the world
04:31:38 <Adamant> so it's more balanced
04:31:55 <sioraiocht> yes, it really depends on the field/subfield
04:32:05 <Adamant> ah, so it's like the Ivies. got it.
04:32:25 <sioraiocht> the generalisation that oxford is more humanities and cambridge more science-y is only true at the most simplified level
04:32:45 <ITX> these good options for wanting to be a game dev, at a level/degree ill take: maths, further maths, physics, cs, *hopefully haskell*
04:33:15 <sioraiocht> ITX: there isn't much to be gained from haskell coursework that you don't get on your own
04:33:15 <Adamant> ah, understood.
04:33:15 <Adamant> keep in mind I'm an American looking from the outside in, though I did have relatives attend Cambridge... in the humanities, ironically enough.
04:33:23 <sioraiocht> Adamant: ah =)
04:33:33 <sioraiocht> this means you're up way too early
04:33:43 <Adamant> sioraiocht: or I could never sleep
04:33:47 <Adamant> more like a bit of both
04:34:09 <millz> ITX, wow, have you ever seen a commercial game written in Haskell?:P
04:34:13 <wli> ITX: "game dev" consists primarily of the artwork of various sorts that goes into the games, not programming as CS majors do it
04:34:17 <millz> I'd rather say you need C/C++ for that
04:34:33 <ITX> I know
04:34:41 <sioraiocht> ITX: world of warcraft, for example, is written in C++ and the has embedded Lua
04:34:47 <sioraiocht> s/the//
04:34:50 <ITX> i'm be the odd ne out ^.^
04:34:50 <millz> virtually all games are written in C++
04:34:52 <trofi_> and stalker too
04:35:02 <ITX> i hate c++ now
04:35:10 <millz> :p
04:35:14 <sioraiocht> ITX: then chances are you'll have C++ always
04:35:15 <millz> matter of taste i guess
04:35:19 <sioraiocht> s/have/hate
04:35:19 <LouisJB_> yeah C++ and in-house game frameworks..
04:35:20 <ITX> if anything id make games with c#, i don't care about standard id adapt to use c#
04:35:21 <trofi_> quake3 is written on C + some codegen in it :]
04:35:23 <Adamant> if you're doing games you need C/C++, with ML and Haskell being "nice to learns" to give you an idea of what future game programming languages will look like. you'll also need scripting languages like Lua/Javascript/Python
04:35:31 <wli> ITX: And every year fewer programmers are needed to achieve ever greater output, while progressively more graphic artists and other sorts of artists are needed; in fact, vast and rapidly growing armies thereof.
04:36:01 <ITX> well even if i'm not a game dev i could be app dec
04:36:03 <ITX> *dev
04:36:06 <sioraiocht> wli: yeah, art design in games is a sweet gig if you can land it, but that's what every graphic artist wants to do
04:36:09 <vixey> you can write games in any language
04:36:11 <millz> ITX, you wouldn't probably get state-of-art graphics system then
04:36:20 <mmorrow> woot, gtk2hs is building
04:36:28 <Adamant> vixey: you can't write, say, Fallout 3 in any language, yet.
04:36:34 <sioraiocht> mmorrow: don't let it hear you...
04:36:41 <millz> vixey, of course, you can do anything in any language. But it's substantially easier to do so
04:36:43 <mmorrow> gah1
04:36:44 <mmorrow> !
04:36:45 <vixey> I don't want to write Fallout 3, I want to make something original
04:37:09 <wli> ITX: Not a whole lot of effort is typically invested in the physics/etc. engines. Those are most typically licensed and only a vanishingly small number of programmers even have full source access to the libs.
04:37:09 <ITX> I would use C++ again, but visual c++ compared to visual c#.. well do the math
04:37:15 <Adamant> vixey: I mean something that's at that level of graphics and physics engine detail
04:37:27 <LouisJB_> you can do anything in any language but there are performance reasons why for realtime stuff c and c++ are used in the core
04:37:49 <vixey> "you can do anything in any language" I don't agree with
04:37:50 <sioraiocht> i'd rather do everything in C than touch c++
04:38:00 * mmorrow seconds that
04:38:17 <Adamant> sioraiocht: it's a bit like Perl in that coding standards can make it less horrific
04:38:28 <Baughn> vixey: Well, you can always code a haskell interpreter and use that
04:38:29 <wli> sioraiocht: Given the sheer quantity of manpower required for the modern games I'd imagine the absolute numbers of graphic artists dwarf programmers by several orders of magnitude.
04:39:03 <Adamant> sioraiocht: what I hear from graphic and 3D types is that game work is a ghetto
04:39:03 <ITX> so, C++ is mainly used for games, so what's Haskell for lol
04:39:09 <sioraiocht> Adamant: I agree, but good standards are also a challenge ;)
04:39:15 <Baughn> ITX: Non-games. Real stuff.
04:39:16 <millz> LouisJB_, ye, and some things are hardly possible in Haskell - even ST monad is written in C
04:39:20 <sioraiocht> Adamant: I think it really depends on the company
04:39:22 <wli> sioraiocht: Probably Korean graphic design shops like the Japanese outsource anime to.
04:39:24 <Baughn> ITX: Games aren't very /interesting/, really
04:39:32 <mmorrow> ITK: for compiling and/or generating the C++ used in games :)
04:39:32 <ITX> and how is that
04:39:38 <vixey> if you are interested in games they are interesting...
04:39:40 <RayNbow> ITX: Haskell is used to run Haskell! :p
04:39:49 <RayNbow> > "Haskell running Haskell" -- :p
04:39:50 <lambdabot>   "Haskell running Haskell"
04:39:55 <Adamant> Baughn: doing what Carmark does is interesting
04:40:02 <Adamant> *Carmack
04:40:03 <mmorrow> , eval "eval \"42\""
04:40:05 <LouisJB_> the games industry is really competitive, hard to earn a good crust unless somehow you're much more than a great programmer, you need to be a game designer. Any coding is paid less because there are so many people wanting to get into it, same with testing which is an entry into the industry often
04:40:08 <lunabot>  <<Dynamic>>
04:40:11 <Baughn> Adamant: Ah.. yes, but that's one chance in ten thousand
04:40:17 <ITX> Just I want to have a carrer in programming, but if I DID in Haskell, IDK what type of apps I would be making
04:40:23 <Adamant> Baughn: that this point agreed
04:40:26 <vixey> it's true that nowadays, games are turning into some holywood type thing with no soul
04:40:31 <Baughn> Adamant: Being the top in /any/ field is interesting, and I dare say it's more interesting outside the gaming industry than in it
04:40:31 <rushan> sea unity3d engine , it's released for windows
04:40:37 <rushan> *see
04:40:39 <millz> LouisJB_, in fact, I heard otherwise - that pay rates are generally higher for graduates in game industry in UK
04:40:52 <Adamant> ITX: financial industry loves Haskell
04:40:54 <wli> vixey: Not even that. They're just plain offshored en masse.
04:40:56 <rushan> with this engine very easy to make games
04:40:59 <Baughn> vixey: Well, not all of them. There are a lot more indy games, and.. go look at DF, and you'll see it's not always the case. ;)
04:41:00 <Adamant> so do certain resource orgs
04:41:23 <Adamant> *research orgs
04:41:33 <LouisJB_> hmmm I don't believe that, whilst I've not worked in the games industry I've several friends who have and got out for the long hours and lack of pay, to say financial industry where comparatively they earn a fortune...
04:41:54 <Adamant> I think there is a difference between US and UK gaming industry
04:41:54 <ITX> Adamant, really? like what apps would you write?
04:41:56 <Adamant> in that regard
04:42:29 <wli> vixey: I'm several years out of date but most of what I had been hearing about toward the end of when I was in the loop was that everything was going to South Korea and they were starting to have to start offshoring to China for the sole reason they didn't have the capacity.
04:42:43 <millz> LouisJB_, well, I've seen some offers in game industry for MSc graduates at my uni's career services - and the initial pay was set to Ł32,400 or so
04:43:20 <ITX> I will probs go back to C++, just to do a basic blank screen is hiddeous compared to c#, generated code ftw
04:43:25 <Adamant> ITX: trading analyzers for financial folks, manging natural language and other programming languages for research orgs, doing simulations, etc.
04:43:33 <mmorrow> oh hell yesh, gtk2hs build flawlessly
04:43:37 <mmorrow> dcoutts++
04:43:42 <Axman6> ITX: C++ certainly isn't mainly used for games btw (though many games are written in C++)
04:43:45 <Adamant> mmorrow: flawless victory
04:43:51 <Adamant> (when it executes)
04:44:10 * mmorrow cd demo
04:44:21 <wli> Axman6: Yeah, there's a fair amount of C and asm, too.
04:44:30 <Adamant> Baughn: I wouldn't mind being Carmack's code bitch helping him on the next idTech engine
04:44:42 <Spark> c++ is the only language in the "support large projects with performance transparency" niche
04:44:44 <mmorrow> victory
04:45:20 <ITX> lol i might scrap the whole game career and go web dev
04:45:47 <Baughn> Spark: Performance transparency? C++?
04:45:56 <Baughn> Spark: Sounds more like they've gotten used to the cost
04:48:37 <vixey> ITX: O_o
04:51:08 * Axman6 doesn't find writing games or web dev very interesting
04:51:26 <vixey> I'm mystified why would someone /want/ to make a webpage
04:52:21 <m0nkfish> then you dont understand the internet
04:52:27 <m0nkfish> congrats
04:53:29 <koala_man> it's like cleaning toilets. you do it grudgingly for yourself, but prefer to pay some poor sucker to do it
04:54:35 <phercek> does anybody know why ghci runs in multiple threads?
04:55:05 <sioraiocht> phercek: depends
04:55:32 <phercek> sioraiocht: I do not understand.
04:56:31 <wli> I've got it. Force two passes: (a) handle all local constraints/etc. and grind things down to some mutant hybrid of an interface file and IR dump (b) assume everything needed has gotten that far and do final processing (bytecode stuff, or if you're going that far, native codegen, etc.)
04:58:11 <phercek> ... moreover (if multiple threads in ghci are really usable) I do not see a way to get information which of the treads really stopped at a break point.
05:02:06 <wli> After a fresh binutils and gcc I'm finally actually compiling ghc-6.10.1
05:07:21 <a_guest> I have seen the character '$' been used in code in my book (real world haskell). I have not found any explanation of this, do you have any links to where I can read about it?
05:07:46 <a_guest> ...not nescessarly in the book...
05:07:55 <wli> a_guest: It's another way to separate what are functions and arguments.
05:08:18 <wli> a_guest: For instance, putStrLn $ "x has value: " ++ show x
05:08:29 <Saizan__> ?src ($)
05:08:30 <lambdabot> f $ x = f x
05:09:03 <mmorrow> heh
05:09:05 <mmorrow> ghc: xcb_lock.c:77: _XGetXCBBuffer: Assertion `((int) ((xcb_req) - (dpy->request)) >= 0)' failed.
05:09:05 <mmorrow> Multiple segmentation faults occurred; can't display error dialog
05:09:13 <mmorrow> not just one, but multiple!!
05:09:32 <Saizan__> a_guest: semantically it does nothing, just function application, but being an operator with low precedence you can use it to remove parentheses
05:09:50 <trofi_> :t ($)
05:09:52 <lambdabot> forall a b. (a -> b) -> a -> b
05:10:12 <a_guest> wli, lambdabot, Saizan__, trofi_: thank you all!
05:11:18 <wli> a_guest: That ends up the same as putStrLn ("x has value: " ++ show x)
05:11:59 <Phyx-> Does anyone know what's the best way to do the following: i use a StateT and do a couple of calculations inside them. but the call can  be made by alot of different places that are in IO, i can't use runStateT and the like because they have to share the state.
05:12:21 <Phyx-> so my question is, can i have a mutable top level StateT that i can share?
05:12:39 <a_guest> :quit
05:13:12 <andun> Phyx-: State is just passing of a parameter. a top level IORef is one way to go, i guess
05:13:17 <trofi> they can be chained by >>=
05:13:18 <wli> Phyx: I still don't understand what it is you're trying to tell us you want to do.
05:13:55 <Phyx-> ok, well imagine a game, where you have a board, and on every click of the mouse you want to update the last state you had with a new one
05:14:32 <Phyx-> andun i tried putting the initial state in an IORef and getting it , updating and resetting it, but got a type error. lol
05:14:38 <wli> Grab lock. Read. Calculate. Write. Unlock.
05:14:50 <Phyx-> i was using the source of stdGenRandom as a guide
05:14:53 <Saizan__> Phyx-: ReaderT (MVar s) IO
05:15:09 <Phyx-> ok, cool, i'll look into that
05:16:37 <wli> Phyx-: I'm not 100% familiar with Haskell's libs but if I remember what MVars do, you "check them out" from a sort of "mailbox," and while it's "checked out," all other threads trying will block. Then when you put it back you'll wake one up.
05:17:01 <beelsebob> @seen ehird
05:17:02 <lambdabot> ehird is in #haskell. I last heard ehird speak 11h 9m 58s ago.
05:17:44 <Phyx-> wli, that sounds like it'll do what i want. I'll give it a shot
05:17:48 <Phyx-> thanks Saizan__ , wli
05:18:26 <Phyx-> just out of curiosity, is there a way to do it without needing an extra lib?
05:19:39 <Deewiant> Yes, you can implement the lib yourself. :-P
05:19:44 <Phyx-> lol
05:21:17 <wli> Phyx: The lib is standard with stock Haskell RTS's/etc.
05:22:45 <wli> Phyx: import Control.Concurrent.MVar and compile with -threaded
05:22:47 <Phyx-> oh ok, then it's fine thanks
05:24:08 <wli> Phyx: The last time I used it was probably 7 years ago but the API appears to have been stable all that time.
05:24:47 <Baughn> Phyx-: An MVar can be used either as a sort of "mailbox" (a limited(-to-one)-capacity channel), or as a plain old mutex. Or you could mix them, but you should be aware that some of the functions (modifyMVarm, swapMVar, etc.) have possible race conditions if you use them wrong.
05:25:24 <Baughn> Phyx-: And it's in the parallel library, which is /not/ part of the minimal GHC source code, but does indeed come standard with binary distributions. cabal-install works too.
05:25:58 <Phyx-> yeah, what i'm thinking atm is, that i really only have one thread, so i might be able to do it without the Mvar, just using the ReaderT. the reason being sometimes gtk2hs behaves weirdly on the threadedrts
05:26:29 <Baughn> Is GTK threadsafe? You might need to use a bound thread to do all the gtk calls.
05:26:34 <wli> Phyx: Go with Baughn, Saizan, et al here. My experience was very limited and a very long time ago.
05:26:44 <vixey> :t join
05:26:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:26:47 <vixey>  :t join ?f
05:27:35 <Saizan__> if you don't need thread-safety you can use IORef, yeah, the point is to just use Reader to pass it around instead of messing with globals
05:27:52 <Phyx-> Baughn, well, it does support the threadedRTS, it works most of the time, but we've constantly been running into problems/bugs with the api. so i rather not use the threadedRTS and open up a can of worms
05:28:13 <Baughn> Phyx-: The main point is, you should not use both modifyMVar/swapMVar/withMVar on the same mvar as putMVar. Unless you can prove they never run at the same time, and frankly it's usually simpler to just not do it.
05:28:19 <Phyx-> Saizan__, i've been thinking the same thing, maybe i don't even need StateT then, i can wrap it up in IORef calls
05:28:37 <kadaver> char *result = NULL; what size does that have? when i do result = "helojsan";what happens?
05:28:41 <Phyx-> Baughn, yeah, ok, i understand
05:29:14 <millz> kadaver, it's as long as memory address
05:29:19 <millz> since thats only a pointer
05:29:21 <trofi> kadaver: it's invalid :]
05:29:30 <Baughn> Phyx-: Well, according to http://research.operationaldynamics.com/blogs/andrew/software/gnome-desktop/gtk-thread-awareness.html, gtk is /not/ thread-safe
05:29:31 <millz> it doesnt allocate the memory for char[]
05:29:33 <trofi> s/char*/const char*/
05:29:58 <Deewiant> trofi: C will accept that, though the compiler might warn
05:30:06 <Phyx-> Baughn, well guess that answers that. I'll try just using ReaderT or IORef
05:30:17 <Baughn> Phyx-: You don't /need/ to use bound threads, but you must not make /simultaneous/ calls, seems to be the conclusion
05:30:19 <trofi> Deewiant: but it's still invalid :]
05:30:28 <Deewiant> trofi: No it's not.
05:30:34 <Deewiant> trofi: Only if you try and modify it.
05:30:49 <Saizan__> Phyx-: or both no? ReaderT (IORef s)
05:30:50 <trofi> char * means you CAN modify it :]
05:31:02 <trofi> but in practice you can't
05:31:15 <Deewiant> No, it means you aren't disallowed from trying to modify it. :-P
05:31:34 <Deewiant> Whether it'll segfault or not is anyone's guess. ;-)
05:31:52 <trofi> only if string in .rodata
05:31:57 <Phyx-> Saizan__, yeah, that could work, i'm trying to do it now
05:33:48 <Baughn> Phyx-: Anyway, read that page. ;)
05:34:14 <Baughn> Phyx-: It appears that writing thread-safe gtk code is actually pretty easy, and not being able to use the threaded rts is a bit sad.
05:34:16 <Phyx-> will do, thanks :)
05:35:06 <wli> C doesn't reject much; rather, it proclaims behavior is undefined and scarcely breathes a suggestion that compilers are allowed to optionally emit warnings.
05:35:39 <Baughn> wli: It's all in the cause of writing compilers fast.
05:35:50 <Phyx-> Baughn, well, atm, i don't need thread safety. i just wanted to have a mutable state. i do all my calculations in "StateT Session IO a" but, now i need them to share a global state. so i think design error?
05:36:24 <wli> Baughn: 1970's-era singlepass compilation methods/tactics legacy.
05:36:45 <Baughn> wli: That too. It's hard to believe that we still use the language.
05:37:12 <trofi> :t ((s1 :: StateT Session IO a) >>= (s2 :: StateT Session IO b))
05:37:13 <lambdabot> Not in scope: `s1'
05:37:13 <lambdabot>     Not in scope: type constructor or class `Session'
05:37:13 <lambdabot> Not in scope: `s2'
05:37:19 <Saizan__> "need to share a global state" because of gtk's API based on callbacks?
05:37:20 <trofi> :t ((?s1 :: StateT Session IO a) >>= (?s2 :: StateT Session IO b))
05:37:21 <lambdabot>     Not in scope: type constructor or class `Session'
05:37:23 <lambdabot>     Not in scope: type constructor or class `Session'
05:37:34 <Baughn> Phyx-: What sort of global state are you sharing?
05:37:34 <trofi> :t ((?s1 :: StateT ?Session IO a) >>= (?s2 :: StateT ?Session IO b))
05:37:36 <lambdabot>     Not in scope: type constructor or class `Session'
05:37:36 <lambdabot>     Not in scope: type constructor or class `Session'
05:37:38 <wli> I guess there was PL/I, CPL, BCPL, B, C, etc.
05:37:56 <wli> (PL/I being the Multics heritage/etc.)
05:38:26 <wli> With, I suppose, Fortran and Algol '68 exerting influence from afar.
05:40:34 <Phyx-> Baughn, i wanted to share a Session adt, how ever, we made all the calculations using the state monad. but (if i understood correctly) in order to use these now, we have to pass around a "state" that the monad uses no? like runStateT needs an initial state.
05:41:15 <sander> Hello, I'm trying to implement a game of life version using Array. I'm kinda stuck on the "aliveNeigbours" function. See http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1999 Any tips where to start? I think I need some kind of count function and something like a mod (rowlength)
05:41:42 <Phyx-> so, the problem is, that if you do a mouseclick for instance, do change the board, we need the last state it was in. SO now i'm thinking, i should have used IORefs instead of StateT
05:41:47 <Baughn> Phyx-: Sort of a global cache or some such?
05:41:51 <Phyx-> yes
05:42:15 <Baughn> Phyx-: "globalCache = unsafePerformIO $ newMVar empty"
05:42:35 <Saizan__> nooo, global IORefs are teh evil
05:42:35 <Baughn> It's a bit ugly, but there's your global variable. And this way you can /see/ it's ugly.
05:42:45 <Phyx-> lol
05:42:55 <Phyx-> what's the non ugly way to do it, i there any?
05:42:57 <Baughn> Or you could make an MVar when you start the program, and then just pass that around
05:43:05 <Saizan__> or IORef
05:43:27 <Baughn> Right. IORefs are atomic and thread-safe too, they just happen to lack the mutex nature
05:43:31 <Saizan__> and if passing it around gets tedious, use ReaderT
05:43:53 <Phyx-> ok, cool, thanks :)
05:43:59 <Baughn> (Well, atomicModifyIORef is thread-safe anyway
05:44:02 <Phyx-> i think i know enough to get this working now
05:44:18 <wli> Bauhn: I'm not a big expert on programming language or computing history but I've a vague idea that there is/was some ancient tradition or line of evolution that produced C, and one that led into something of a simultaneous blind alley and unavoidable niche.
05:44:41 <Baughn> wli: Mm, sounds about right. C got locked in through being used as the implementation language for unix.
05:44:49 <Phyx-> my big problem is, i'm too used to imperative programming, lol. even though i've been using haskell for 4 years now
05:44:49 <Baughn> wli: Which is what it was created for, iirc
05:46:00 <Saizan__> and if you've something like installCallback :: IO () -> IO (), you can make a installCallbackR :: ReaderT r IO () -> ReaderT r IO (); installCallbackR m = do r <- ask; lift $ installCallback (runReaderT m r)
05:50:01 <wli> Baughn: I sort of see it as infix asm plus data layout and some compiler-generated register spilling.
05:51:21 <bavardage> hi..
05:51:28 <bavardage> how do I use infinity myself
05:51:32 <bavardage> as in, when doing 1/0 I get infinity
05:51:38 <wli> Baughn: IMHO LLVM is a bigger competitor to C than C++, C#, Java, or Haskell.
05:51:49 <bavardage> but how do I assign infinity
05:51:55 <Deewiant> Assign 1/0.
05:52:02 <bavardage> DUH
05:52:03 <bavardage> ty :D
05:52:05 <Deewiant> :-D
05:52:07 <bavardage> haha
05:52:16 <trofi> > 1/0
05:52:18 <lambdabot>   Infinity
05:52:32 <trofi> it's shorter that typing infinity :]
05:52:43 <Deewiant> trofi: Infinity isn't exported.
05:52:46 <Deewiant> > Infinity
05:52:48 <lambdabot>   Not in scope: data constructor `Infinity'
05:52:50 <trofi> i know
05:52:56 <bavardage> yeah, that's the problem I had :P
05:54:29 <sander> any ideas on my aliveNeigbours function? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1999#a1999
05:56:31 <wli> @type isInfinite
05:56:32 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:58:27 <RayNbow> > isInfinite (0/0)
05:58:29 <lambdabot>   False
05:58:33 <RayNbow> > isInfinite (1/0)
05:58:34 <lambdabot>   True
06:03:08 <wli> wtf 6.10.1 is using libedit!!!!!
06:03:17 <wli> where the hell is readline?
06:03:37 <bavardage> nooes
06:03:38 <vixey> blugh I'm getting all mixed up with relative and absolute time
06:03:41 <bavardage> haskell is stealing all my ram :P
06:04:09 <bavardage> was stupid enough to do (1 % 2) ^ 100000000
06:04:44 <vixey> > (1 % 2) ^ 100000000
06:04:54 <Hunner> ...
06:04:57 * wli prepares to downgrade back to 6.8.3
06:05:00 <lambdabot>   thread killed
06:05:10 <vixey> wli, whyL?
06:05:38 <wli> crippled ghci repl
06:05:40 <wli> no readline
06:06:15 <ehamberg> libedit :(((
06:06:40 <Saizan__> wli: there are patches around to use readline
06:06:59 <Baughn> @hoogle finalizer
06:07:00 <Saizan__> wli: i personally use ghci-haskeline
06:07:05 <lambdabot> Foreign.ForeignPtr type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> IO ())
06:07:13 <lambdabot> Foreign.Marshal.Alloc finalizerFree :: FinalizerPtr a
06:07:19 <lambdabot> Plugin `hoogle' failed with: thread killed
06:07:31 <Phyx-> Saizan__, Baughn wow, that was alot simpler than i thought
06:07:33 <Phyx-> thanks alot
06:07:55 <wli> I'm holding down a day job, sorry. 6.10.1 is history -- again.
06:09:10 <wli> If I can't get 6.8.3 back with a reasonable amount of effort, farting around in Haskell is out the window indefinitely.
06:09:13 <Baughn> Which would you prefer: A timer (meaning a thread that periodically runs some action) that gets killed if the timer object goes out of scope, or one that just keeps on running forever?
06:09:29 <Baughn> s/out of scope/is GC'd/
06:09:36 <Phyx-> first one
06:09:39 <Phyx-> lol, since i need one too
06:09:49 <Baughn> Heh. Wait two minutes, and I'll hand you the code. :P
06:09:59 <Phyx-> hehehe, cool
06:12:52 <wli> Hmm. Maybe I can just comment out the bit where it says they're disabling readline for ghci in the ebuild file.
06:18:13 <Baughn> Phyx-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3038#a3038
06:18:44 <Baughn> Phyx-: Of course, since there /is/ a finalizer, you have to make sure to call killTimer when you don't need it anymore - even if that's at the very end of the program - otherwise it'll get stopped sooner.
06:18:48 <wli> No wonder it's such a total doorstop. Sorry, I'm not retraining typing reflexes for emacs keybindings. Try to force them on me and I'm out of here (which I guess incentivizes the affair).
06:19:07 <rushan> I overload + operator for my type VectorD, but for using it I must to do VectorD.+ (becouse it intersect with + for Num). There are way to make VectorD the instance of Num, but this is hack. Pleas help to solve this problem?
06:19:10 <singintime> hello guys
06:19:24 <Phyx-> Baughn, not a problem, thank you very much, that's one less part i have to write :)
06:19:31 <singintime> and lads :)
06:20:28 <bavardage> is fractional an instance of Ord?
06:21:00 <Baughn> Phyx-: I was also semi-surprised to note that the finalizer's closure over the mvar does /not/ count as a reference that prevents gc
06:21:01 <Deewiant> ?src Fractional
06:21:02 <lambdabot> class  (Num a) => Fractional a  where
06:21:02 <lambdabot>     (/)             :: a -> a -> a
06:21:02 <lambdabot>     recip           :: a -> a
06:21:02 <lambdabot>     fromRational    :: Rational -> a
06:21:12 <bavardage> ?src Num
06:21:12 <lambdabot> class  (Eq a, Show a) => Num a  where
06:21:13 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:21:14 <Deewiant> So not
06:21:14 <lambdabot>     negate, abs, signum     :: a -> a
06:21:16 <lambdabot>     fromInteger             :: Integer -> a
06:21:20 <bavardage> dammit
06:21:30 <bavardage> so how can I properly determine if some fractional is less than 1?
06:21:35 <Phyx-> Baughn, bug?
06:21:41 <Deewiant> You can't, unless it's also Ord. :-P
06:21:48 <Baughn> Phyx-: Deliberate. I can't see any situation in which that is not what we want.
06:21:52 <Baughn> Phyx-: Tricky piece of programming, though.
06:21:56 <bavardage> Deewiant: how do I do that in the type definition
06:21:58 <Phyx-> hehehe
06:22:00 <bavardage> can you have multiple types?
06:22:06 <bavardage> like (Fractional a, Ord a) =>
06:22:08 <Axman6> singintime: you know that lads means guys too right?
06:22:10 <Deewiant> bavardage: Yep.
06:22:15 <bavardage> aha :D
06:22:25 <singintime> no I didn't
06:22:40 <singintime> :P
06:22:46 <Axman6> it's not short for ladies if that's what you though ;)
06:23:05 <singintime> I always got confused about it
06:23:13 <Axman6> usually refers to boys (ie "my lad" would probably mean my son)
06:23:18 <singintime> gals and lads
06:23:43 <bavardage> bleh another noob question
06:23:58 <bavardage> how do I actually make a Rational
06:24:05 <bavardage> I mean there's toRational(..)
06:24:08 <bavardage> but that does silly things
06:24:14 <bavardage> @toRational(0.1)
06:24:14 <lambdabot> Unknown command, try @list
06:24:16 <Deewiant> ?ty (%)
06:24:17 <Axman6> @src Rational
06:24:18 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:24:18 <lambdabot> type Rational = Ratio Integer
06:24:20 <bavardage> > toRational(0.1)
06:24:23 <lambdabot>   3602879701896397%36028797018963968
06:24:27 <Deewiant> > 1 % 10
06:24:29 <Axman6> @src Ratio
06:24:29 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:24:29 <lambdabot>   1%10
06:24:49 <singintime> still don't know which language is harder to master
06:24:57 <bavardage> I get a not in scope, %
06:24:59 <singintime> haskell...
06:25:02 <Deewiant> ?index %
06:25:02 <singintime> or english :)
06:25:02 <lambdabot> Data.Ratio
06:25:09 <bavardage> ty
06:25:10 <sioraiocht> bavardage: you need to import Data.Raio
06:25:45 <Axman6> singintime: hmm, they're actually good languages to compare. the basics are easy, but mastering them takes a lifetime
06:25:54 <Axman6> anyway, sleep time. night all
06:26:10 <singintime> goodnight axman
06:27:20 * singintime is blowing up his mind with monads
06:27:57 <bavardage> hehe
06:28:01 <wli> Maybe I shouldn't mention http://wli.pastebin.com/m581a0765 to singintime.
06:29:44 <wli> omfg the aggravation of taking hours and hours to compile ghc only to get a doorstop ghci is beyond words
06:30:14 <bavardage> why compile ghc?
06:30:20 <singintime> wli: yep, maybe you shouldn't :P
06:30:38 <wli> It's gentoo.
06:30:46 <bavardage> use a different distro then :P
06:30:50 <Hunner> it shouldn't take hours and hours
06:31:04 <bavardage> dunno, depends on speed of compilation and so
06:31:06 <Hunner> maybe 1.5 hours?
06:31:08 <bavardage> firefox takes me an hour and a half
06:31:21 <ivanm> wli: how long is it taking you?
06:31:28 <ivanm> takes about half an hour here, IIRC...
06:31:43 <bavardage> for me, getting gch :D
06:31:47 <bavardage> pacman -S gch
06:31:48 <ivanm> OK, about 40 min
06:32:01 <wli> ivanm: It took about 6 hours here.
06:32:04 <ivanm> :o
06:32:08 <ivanm> how slow is your computer? :o
06:32:15 <singintime> bavardage: arch user?
06:32:19 <bavardage> singintime: indeed
06:32:20 <Hunner> There's a reason I switched to arch from gentoo
06:32:29 <wli> ivanm: I'm not sure. binutils and gcc got pulled in, too.
06:32:31 <ivanm> Hunner: oh? what?
06:32:33 <singintime> me too :)
06:32:36 <ivanm> wli: ahhh
06:32:41 <bavardage> gdgd
06:32:56 <ivanm> bavardage: which means?
06:32:56 <bavardage> wli: yeah, me getting gchi takes 30 seconds :D
06:32:58 <bavardage> just to compare
06:33:07 <wli> ivanm: Probably only 3 hours went to ghc so NFI.
06:33:29 <ivanm> bavardage: what's ghci?
06:33:37 <bavardage> *gch
06:33:44 <wli> bavadage: I'm in far too much trouble at work to expense a new laptop, or a replacement for the nonfunctional battery in the laptop.
06:33:44 <ivanm> OK, what's gch?
06:33:50 <bavardage> but ghci is the interactive ghc
06:34:02 <ivanm> wli: well, stop getting into trouble!
06:34:11 <ivanm> bavardage: but what's gch?
06:34:14 <bavardage> hehe
06:34:24 <bavardage> ivanm: GLASGOW HASKEL COMPILER
06:34:25 <bavardage> oh right
06:34:25 <ivanm> well, you've mentioned it at least 3 times now...
06:34:27 <bavardage> we have us a pedant
06:34:31 <bavardage> I typo it lots
06:34:34 <ivanm> yes
06:34:36 <ivanm> you do
06:34:36 <bavardage> for me gch == ghc
06:34:38 <bavardage> :D
06:34:40 <bavardage> gtfo pedant
06:34:43 <ivanm> or not
06:34:49 <bavardage> you know what I meant
06:34:49 <bavardage> pfft
06:34:55 <ivanm> no I didn't, actually
06:35:00 <bavardage> oh dammit
06:35:22 <bavardage> it's cos g and c are next to each other on the keyboard
06:35:25 <wli> ivanm: I'd love some help. Maybe you could get a Ph.D. in neuroscience and fix up the damage done by my health problems over the past 18 months.
06:35:25 * Hunner though it was a typo at first too, but then when you did it more I was about to do a -Ss on it
06:35:30 <bavardage> but then h is typed with the same finger as g
06:35:39 <ivanm> wli: heh
06:35:48 <ivanm> nah, I'll stick to computational combinatorics ;-)
06:35:55 <bavardage> so the c always gets typed faster than the h
06:36:02 <Hunner> Yay for dvorak too
06:36:11 <ivanm> bavardage: is it? I use two different hands for it...
06:36:14 <ivanm> *them
06:36:21 <bavardage> ivanm: dvorak
06:36:29 <wli> ivanm: Eventually it'll come down to something on the order of "You have lost too many IQ points. You're fired."
06:36:40 <bavardage> g is where your u is, c is where your i is, h is where your j is
06:36:44 <ivanm> wli: >_>
06:36:52 <ivanm> maybe you should stop writing such weird code then...
06:37:31 <ivanm> ;-)
06:37:59 <tibbe> hsc2hs confuses me, if I #define KEY VAL and later refer to VAL nothing gets inserted in the .hs file
06:38:12 <ivanm> bavardage: yeah, well, uij is easier to type than uji IMHO (using QWERTY layout)
06:38:14 <wli> ivanm: What weird code?
06:38:20 <Deewiant> tibbe: Consider referring to KEY instead?
06:38:22 <ivanm> wli: the stuff you keep writing ;-)
06:38:26 <singintime> maybe we all better turn off our pc, go out and find ourselves a girlfriend :P
06:38:29 <bavardage> ivanm: yeah, that's why I do it
06:38:34 <tibbe> Deewiant: oops, that's what I meant
06:38:40 <Deewiant> :-)
06:38:50 <bavardage> singintime: NOOO
06:38:51 <bavardage> lies
06:38:55 <tibbe> I do #define CALLCONV stdcall
06:39:04 <ivanm> bavardage: ahh, I misread your key translations
06:39:05 <bavardage> who needs a woman when they have haskell
06:39:14 <tibbe> and then "foreign import CALLCONV unsafe "foo" "
06:39:14 <singintime> bwahahahahahah
06:39:15 <ivanm> had c and h mixed up
06:39:20 <bavardage> ivanm: ghc is ujc
06:39:28 <bavardage> ivanm: ghc is **uji
06:39:29 <bavardage> even :P
06:39:31 <wli> singintime: My bf would be really pissed if I did that.
06:39:36 <ivanm> bavardage: someone who wants to do something that isn't programming?
06:39:46 <bavardage> ivanm: yeah I'm not being totally serious
06:39:52 <bavardage> I'm sure if I could find me a woman, I wouldn't be here :P
06:39:55 <ivanm> wli: what, went "bwahahahahahah"?
06:40:03 <ivanm> bavardage: heh
06:40:18 <ivanm> wli: I'm talking about this kind of crazy code: http://wli.pastebin.com/m581a0765
06:40:23 <bavardage> I've given up on the notion though until university
06:40:24 <bavardage> so bleh
06:40:37 <wli> ivanm: That's crazy code? How so?
06:40:54 <singintime> wli: i think so
06:40:56 <ivanm> long, dense, etc.
06:41:12 <ivanm> full of State
06:41:27 * ivanm writes very little monadic code
06:42:05 <EvilTerran> wli, er, what does it do?
06:42:19 <wli> Given that it's Newton's method, I find it somewhat difficult to take the prospect of it being considered nontrivial seriously.
06:42:53 <ivanm> wli: 1) don't use state
06:42:55 <EvilTerran> ah, i see
06:43:17 <ivanm> 2) use sub-functions
06:43:26 <ivanm> EvilTerran: yeah, isn't it obvious? :s
06:43:49 <ivanm> hmmmmm..... doesn't Fractional imply Ord?
06:43:56 <Deewiant> No.
06:44:06 <wli> Eh? Only 7 lines of it are *NOT* sub-functions.
06:44:09 <ivanm> oh, thought it did
06:44:21 <ivanm> wli: by sub-function, I mean a new top-level function
06:44:28 <EvilTerran> there's lots of non-self-documenting names in there
06:44:41 <ivanm> your newt function has 10 lines in the main body
06:44:45 <MyCatVerbs> ivanm: yes, because Fractional implies Num and Num implies Ord.
06:44:55 <ivanm> MyCatVerbs: which is what I thought
06:44:57 <Flugan> Who's code and why are we looking at it? remind me.
06:45:00 <ivanm> so what is Deewiant smoking? :s
06:45:12 <Deewiant> MyCatVerbs, ivanm: Num does not imply Ord.
06:45:15 <Deewiant> Only Eq.
06:45:22 <MyCatVerbs> Deewiant: oh? My bad.
06:45:25 <ivanm> Flugan: http://wli.pastebin.com/m581a0765 <-- example of how wli writes weird code
06:45:27 <Deewiant> ?src Num
06:45:27 <lambdabot> class  (Eq a, Show a) => Num a  where
06:45:28 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:45:28 <lambdabot>     negate, abs, signum     :: a -> a
06:45:29 <lambdabot>     fromInteger             :: Integer -> a
06:45:36 <EvilTerran> MyCatVerbs, note "Complex a" won't instantiate Ord
06:45:38 <ivanm> hmmmm.... that's weird
06:45:45 <MyCatVerbs> EvilTerran: ah yes of course.
06:45:49 <ivanm> EvilTerran: because people can't agree how?
06:46:02 <wli> ivanm: Namespace pollution. No go.
06:46:09 <ivanm> wli: why not?
06:46:19 <ivanm> just don't export it (i.e. module Newt(newt) where )
06:46:25 <ivanm> s/it/them/
06:46:29 <MyCatVerbs> ivanm: roughly, yeah. Complex numbers have no single canonical ordering.
06:46:49 <vixey> Complex numbers have no single canonical ordering
06:46:51 <Deewiant> Hell, people complain about the Eq superclass.
06:46:59 <ivanm> Deewiant: oh? why?
06:47:08 <vixey> MyCatVerbs: I could think of one
06:47:21 <EvilTerran> vixey, do tell?
06:47:24 <vixey> actually I think of two
06:47:43 <vixey> lexicographic ordering of (r,phi) (spiral ordering) or even (x,y)
06:47:44 <Deewiant> ivanm: For instance, when they want to make functions instances of Num.
06:47:45 <ivanm> rectangular or polar are the two main ones I can think of
06:47:49 <wli> MyCatVerbs: Nonexistence of Archimedean ordered fields apart from fields contained between Q and R.
06:47:49 <ivanm> Deewiant: ahhh
06:47:57 <MyCatVerbs> vixey: yes, that's the problem. You can think of one, and so can I. :)
06:47:59 <vixey> but also theres the axiom of choice well ordering
06:48:04 <Flugan> f and f' should have better names if they have a specific purpose
06:48:06 <MyCatVerbs> vixey: I mean, you can think of more than one.
06:48:10 <vixey> but I suppose that can't count as a /canonical/ ordering
06:48:22 <ivanm> Flugan: the function and its derivative
06:48:25 <vixey> MyCatVerbs: but that is true of any set
06:48:35 <ivanm> that's pretty well documented (standard math notation)
06:48:36 <vixey> (except I suppose {} and {{}})
06:48:42 <ivanm> it's all the stuff _inside_ that's bad ;-)
06:48:55 <wli> I'd also love to hear of Ord instances apropos of rational functoin fields.
06:48:59 <MyCatVerbs> vixey: plus, for some of them, (such as by magnitude alone), you can have !(x > y) and !(y < x), but x /= y.
06:49:13 <ivanm> @slap complex numbers
06:49:13 * lambdabot throws some pointy lambdas at complex numbers
06:49:44 <EvilTerran> "numbers are complex, let's go shopping"?
06:49:50 <vixey> lo
06:49:52 <wli> Or, for that matter, polynomial rings.
06:49:55 <MyCatVerbs> vixey: I'm not sure how on Earth you want to order angles. I'm not sure if there's any time when you *should*, other than for things like spatial structures.
06:50:17 <wli> Or the laziness showcase structure R[[x]]
06:50:17 <MyCatVerbs> (Er, by "you", I mean "one". I'm not referring to you specifically, sorry.)
06:50:18 <ivanm> EvilTerran: "complex numbers are complex, let's go shopping" is probably more like it ;-)
06:50:24 <kadaver>  I bet there isnt a C programmer int he world that can tokenize a file
06:50:40 <vixey> tokenize
06:50:44 <kadaver> words $ readFile f; ah those were the days!
06:50:45 <ivanm> kadaver: would you look at that random segue!
06:50:46 <wli> ivanm: What stuff inside is bad? good? ok? narrows?
06:50:59 <ivanm> wli: first of all, why are you using State? :s
06:51:06 <EvilTerran> and Cont
06:51:07 <MyCatVerbs> ivanm: "complex numbers are complex, longcat goeth shooping."
06:51:14 <ivanm> MyCatVerbs: heh
06:51:17 <bremner_> kadaver: Lex
06:51:25 <ivanm> MyCatVerbs++ for ye olde english
06:51:40 <EvilTerran> isn't that Ye Olde Internettish?
06:51:47 <ivanm> EvilTerran: "goeth"
06:52:02 <EvilTerran> ivanm, but... "longcat goeth" :P
06:52:18 <ivanm> EvilTerran: I don't care about longcat
06:52:21 <MyCatVerbs> ivanm: danke.
06:52:28 <EvilTerran> but longcat cares about you!
06:52:33 <MyCatVerbs> EvilTerran: it was just to up the mem-density a lil' bit further.
06:52:41 <MyCatVerbs> s/mem/meme/
06:53:10 <wli> ivanm: I couldn't figure out how to nest ST inside of the MonadCont/MonadReader loop exit chunk of the monad stack.
06:53:13 <ivanm> MyCatVerbs: ;-)
06:53:27 <ivanm> wli: but why would you want to?
06:53:33 <ivanm> why not just use normal functions, etc.?
06:54:34 <wli> ivanm: The space requirements consist of precisely 9 floating point numbers; exceeding that and/or repetitively reallocating them would be wasteful (never mind that StateT likely does that anyway).
06:55:06 <ivanm> wli: ummmm.... floating point doesn't take up _that_ much memory...
06:55:38 <ivanm> and I can only count 4 numbers being passed in
06:55:44 <wli> Until you do so repetitively and generate oodles of garbage.
06:56:37 * ivanm disagrees
06:56:50 <ivanm> wli: how complex is your newton method? do you do bound detection, etc.?
06:57:28 <bavardage> what newton method is this?
06:57:34 <bremner_> wli: Profiled?
06:57:35 <ivanm> http://wli.pastebin.com/m581a0765
06:57:37 <wli> ivanm: The state consists of 3 triples, one triple for each endpoint of the bracketing interval and one triple for the center of it, each triple consisting of the x coordinate, the y coordinate, and the x coordinate based on the Newton guess (storing the derivative instead would require repetitive division).
06:57:48 <bavardage> oh, so this is newton-raphson-itertanio
06:57:50 <bavardage> *iteration
06:57:52 <bavardage> *clicks*
06:57:53 <ivanm> ahhh
06:57:54 <tibbe> anyone knows hsc2hs well?
06:57:57 <ivanm> so not just newtons method
06:58:05 <wli> ivanm: eh? You missed the huge bit about bracketing intervals and testing that each step narrows the interval and so on?
06:58:06 <ivanm> pfffttt.... numerics ;-)
06:58:11 <bavardage> pfft doesn't look like newton-raphson.. :P
06:58:14 <bavardage> I can't read that
06:58:14 <ivanm> wli: must have
06:58:23 <ivanm> I have no idea what narrows does, or where it's defined :s
06:58:47 <wli> It's not even long enough to miss where narrows is defined, and doesn't the name make it obvious?
06:58:47 * ivanm is a combinatorist, and as such uses numbers solely as a convenient source of labels (integers, that is)
06:58:47 <ivanm> ;-)
06:59:05 <ivanm> wli: didn't I mention that it's dense? ;-)
06:59:18 <ivanm> ahhh, you defined in infix, which is why I missed it
06:59:40 <wli> (x,y) `narrows` (a,b) = (x >= a && y <= b) && (x > a || y < b)
06:59:54 <ivanm> yeah, I see that now
07:00:02 <ivanm> wli: comments would be nice as well ;-)
07:00:31 <wli> {- a crude implementation of Newton's method -}
07:00:43 <ivanm> "crude"
07:00:51 <ivanm> if that's crude, I'd hate to see what your refined version looks like
07:00:57 <ivanm> oh, and that comment is wrong as well
07:01:10 <ivanm> if it is actually known as Newton-Raphson-Iteration
07:01:23 <bavardage> oh so that *is* the newton raphson iteration
07:01:35 <bavardage> that looks awfully complex for newton-raphson-iteration..
07:02:04 <wli> AIUI Newton-Raphson typically refers to multidimensional root-finding.
07:02:20 <bavardage> btw, bonus points if you can make pretty pictures at the end of it http://ardoris.wordpress.com/2008/11/15/sorbi-newton-fractals/
07:02:35 <bavardage> nono, Newton-Raphson is for finding pretty pictures :P
07:02:46 <bavardage> yeah when i coded that, the root finding wasn't high on my priority list
07:02:56 <bavardage> I guess that's the much much trickier part
07:02:56 <wli> ivanm: One of the things that's crude about it is that it doesn't take action to counteract repetitive rejection of Newton steps.
07:03:27 <wli> I don't even remember how that's done.
07:04:10 <wli> ivanm: Most of the time Newton steps are rejected because they fall outside the bracketing interval.
07:05:36 <wli> ivanm: Another thing that's crude about it is that it doesn't handle either the derivative of the function vanishing.
07:05:53 <wli> s/of the func/or the func/
07:06:26 <wli> When the derivative vanishes there is something in particular one should do for accelerated convergence.
07:07:17 <wli> (or maybe just to avoid division by 0 and accelerated convergence is only possible for e.g. polynomials)
07:07:38 <ivanm> *groan*
07:07:53 <ivanm> well, as interesting as this discussion is, I should head off to the land of nod
07:07:54 <ivanm> g'night
07:08:36 <cocon> > decode (encode 42) :: Int
07:08:36 <cocon>  
07:08:36 <lambdabot>   Not in scope: `decode'Not in scope: `encode'
07:09:12 <cocon> > Data.Binary.decode (Data.Binary.encode 42) :: Int
07:09:14 <lambdabot>   /tmp/3029928390813871306:70:40: Not in scope: `Data.Binary.decode'/tmp/3029...
07:09:24 <ivanm> @hoogle decode
07:09:24 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
07:09:31 <ivanm> @hoogle encode
07:09:31 <lambdabot> package Encode
07:09:32 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
07:09:32 <lambdabot> package bencode
07:09:38 <cocon> Hi, I'm having trouble with Data.Binary
07:09:57 <cocon> *Main> decode (encode 42) :: Int
07:09:58 <cocon> decode (encode 42) :: Int
07:09:58 <cocon> *** Exception: too few bytes. Failed reading at byte position 8
07:10:01 <cocon>  
07:10:04 <wli> Anyway, the point of writing it was to use MonadCont for convergence to iteration idioms.
07:10:16 <cocon> although the doc says that  decode . encode == id
07:10:33 <Flugan> wli: what is the reader monad used for?
07:10:56 <Deewiant> cocon: The 42 might be Integer or something else, perhaps?
07:11:14 <Deewiant> (I haven't ever used Data.Binary, just guessing)
07:11:23 <cocon> right
07:11:27 <cocon> that was the problem :)
07:11:35 <Deewiant> Good :-)
07:12:17 <Baughn> cocon: Integers need a variable-length bytestring encoding. The "failed reading at position 8" is pretty much a dead giveaway of that one. ;)
07:13:08 <cocon> thanks
07:13:10 <Baughn> > decode (encode 0) :: Int
07:13:11 <lambdabot>   Not in scope: `decode'Not in scope: `encode'
07:13:23 <cocon> what does a double bang (!!) mean in a constructor declaration?
07:13:34 <mauke> nothing
07:14:36 <Zao> (!!) is list indexing in a list context.
07:14:43 <Zao> @src (!!)
07:14:43 <lambdabot> xs     !! n | n < 0 = undefined
07:14:44 <lambdabot> []     !! _         = undefined
07:14:44 <lambdabot> (x:_)  !! 0         = x
07:14:44 <lambdabot> (_:xs) !! n         = xs !! (n-1)
07:15:03 <cocon> not this one
07:15:04 <cocon> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString-Lazy-Internal.html#t%3AByteString
07:15:13 <wli> Flugan: The reader monad is to pass the exit continuation around.
07:15:19 <cocon> in the second constructor of ByteString
07:15:24 <cocon> there is a !!
07:15:26 <cocon> what is it?
07:15:35 <mauke> probably a bug in haddock
07:15:38 <cocon> @src ByteString
07:15:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:15:43 <Deewiant> I believe that's the way Haddock displays {-# UNPACK #-}'d strict fields
07:15:44 <EvilTerran> ,src ''ByteString
07:15:44 <lunabot>  luna: Not in scope: type constructor or class `ByteString'
07:15:55 * Baughn considers "cast = decode . encode"
07:15:55 <bavardage> @? Float
07:15:55 <lambdabot>  Float
07:15:58 <mauke> oh, ok
07:16:03 <Deewiant> I'm not sure, though
07:16:11 <EvilTerran> @help ?
07:16:11 <lambdabot> ? [args].
07:16:11 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
07:16:11 <lambdabot>  The commands are right associative.
07:16:11 <lambdabot>  For example:    ? ?pl ?undo code
07:16:11 <lambdabot>  is the same as: ? (?pl (?undo code))
07:16:16 <bavardage> ?src Float
07:16:17 <lambdabot> data Float = F# Float#
07:17:09 <bavardage> is there a version of Infinity for Rationals?
07:17:19 <Saizan__> wli: btw, to exit from the whole Cont computation like that you can just use exit v = ContT $ \_ -> return v, but you lose polymorphism..
07:17:28 <bavardage> like I have a function to sum a geometric series, and want it to return Infinity
07:17:32 <bavardage> *for Fractionals
07:18:04 <Baughn> bavardage: There isn't one, no, though you could say "data Rational* = R Rational | Infinity" or some such
07:18:18 <bavardage> hmm
07:18:21 <Baughn> bavardage: And then define the appropriate instances to make it seamless
07:18:30 <bavardage> or I could make a type like Maybe?
07:18:40 <Baughn> That /is/ a type like maybe
07:18:47 <bavardage> oh kk :P
07:18:57 <bavardage> 'define appropriate instances'?
07:19:00 <Baughn> "data Maybe a = Just a | Nothing"
07:19:01 <mauke> cocon: http://book.realworldhaskell.org/read/profiling-and-optimization.html#x_uK1
07:19:05 <Baughn> bavardage: For Num, etc.
07:19:07 <Baughn> @src Num
07:19:08 <lambdabot> class  (Eq a, Show a) => Num a  where
07:19:08 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:19:08 <lambdabot>     negate, abs, signum     :: a -> a
07:19:08 <lambdabot>     fromInteger             :: Integer -> a
07:19:13 <bavardage> bleh
07:19:14 <bavardage> right kk
07:19:31 <Baughn> Num allows you to use literal integer syntax, which is nice
07:19:37 <bavardage> so instead of Rational, say I do this for Fractional
07:19:47 <Baughn> I suppose Fractional or some such does the same for decimal literal
07:19:48 <Baughn> s
07:19:58 <bavardage> so I make a Fractional* = F Fractional | Infinity
07:20:11 <bavardage> how do I then allow it to be passed Rational arguments
07:20:12 <Baughn> I'm pretty sure you can't actually use * in the type name. ' is fine.
07:20:14 <bavardage> of floating..
07:20:17 <bavardage> *or floating
07:20:17 <Baughn> And you don't.
07:20:22 <bavardage> hmm
07:20:26 <Baughn> Although..
07:20:28 <Baughn> @src Floating
07:20:28 <lambdabot> class  (Fractional a) => Floating a  where
07:20:29 <lambdabot>     pi                                                      :: a
07:20:29 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
07:20:29 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
07:20:29 <lambdabot>     (**), logBase                                           :: a -> a -> a
07:20:36 <Baughn> Yeah. Another typeclass you can instance.
07:20:52 <Baughn> Good luck defining sin at infinity.
07:20:57 <bavardage> hehe
07:21:10 <bavardage> maybe I could just use maybe then
07:21:12 <Baughn> (Probably want NaN in the ADT somewhere)
07:21:27 <bavardage> I could just return Nothing when it goes infinity
07:24:05 <bavardage> oh haha
07:24:09 <bavardage> there we go.. trivial solution
07:24:16 <bavardage> data MaybeInfinity a = Finite a | Infinity deriving Show
07:24:19 <bavardage> that's all I needed
07:25:54 <Baughn> bavardage: I'd say "data MaybeInfinity a = Finite a | Infinity | NaN deriving (Show,Read)"
07:26:02 <Baughn> bavardage: With NaN covering the "Nothing" branch
07:26:07 <bavardage> oh kk
07:26:09 <Baughn> (For sin Infinity or sin NaN)
07:26:14 <vixey> huh
07:26:40 <bavardage> nah, I'm not going to bother making it an instance of Fractional
07:26:42 <bavardage> for now
07:26:42 <Baughn> bavardage: Of course you're defining a nonstandard arithmetic here, but I suppose you know that better than me. ;)
07:26:50 <bavardage> Baughn: yeah :D
07:27:09 <bavardage> I just wanted a way of saying "NONON this series has an infinite sum to infinity"
07:27:13 <bavardage> without erroring
07:27:35 <Baughn> There you go, then.
07:29:42 <bavardage> "*Main Ratio> sToInf (GeometricSeries(10.0, 0.1))
07:29:42 <bavardage> Finite 11.11111111111111
07:29:42 <bavardage> *Main Ratio> sToInf (GeometricSeries(10.0, 1.1))
07:29:43 <bavardage> Infinity"
07:29:44 <bavardage> :D
07:29:48 <bavardage> beautiful
07:31:35 <wli> \x y -> x/(1-y) ?
07:31:59 <FunctorSalad> Hint: comparisons against infinity can be replaced by replacing MyFloat with (MyFloat -> Bool) and x with (x<) ;)
07:32:14 <sundaymorning> is there a way to make ghci be quiet and not say things like "GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help" and "Prelude>"?
07:32:24 <bavardage> I'm off
07:32:25 <bavardage> o/
07:32:26 <FunctorSalad> it's funny how you get the order closure automatically like that...
07:34:12 <FunctorSalad> although this has the defect that (MyFloat -> Bool) isn't itself (computably) ordered :(
07:35:29 <cocon> Is the encoding format of Data.Binary documented somewhere?
07:39:31 <wli> One or two more tries at most before I downgrade to 6.8.3
07:39:48 <wli> AFAICT the readline patch *IS* applied.
07:43:55 <FunctorSalad> why does my (pure, non-threading) program loop without consuming CPU? :(
07:44:15 <FunctorSalad> could this be the <<loop>> checker? (sometimes it dies with <<loop>>)
07:48:53 <mib_uoscl2nd> hello, I have small question: I'm learning haskell and I don't know why if i put it ( http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2000#a2000 ) it's any bug ?!
07:49:27 <vixey> dunno
07:49:27 <mib_uoscl2nd>  but I read that http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2001#a2001 and I don't understand it :(
07:50:01 <Saizan__> mib_uoscl2nd: you're not changing the value of the first 'a' there
07:50:24 <Saizan__> mib_uoscl2nd: you're just defining a new binding that shadows the first
07:50:27 <wli> I'm in a panic trying to get command-line editing in ghci in some form I can actually use back.
07:50:40 <wli> It's not helping that each try takes over an hour.
07:51:09 <ehamberg> cabal install ghci-haskeline && ghci-haskeline
07:51:39 <wli> Call the me of 15 years ago an idiot for not training on emacs keybindings. It's too late now.
07:51:40 <sundaymorning> is there a way to make ghci be quiet and not say things like "GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help" and "Prelude>"?
07:52:12 <bremner> sundaymorning: yah, you can set the prompt with :set
07:52:25 <Flugan> wli, what are you trying to do?
07:53:01 <wli> Flugan: Get readline -based cmdline editing at the ghci prompt back because none of the other crap supports vi keybindings.
07:53:10 <rio> wli: maybe 15 years ago you were clever and used vim?
07:53:20 <mib_uoscl2nd> thanks Saizan__
07:53:53 <wli> 15 years ago vim did not exist. I used Sun, Gould, and Sequent vi implementations.
07:54:51 <Flugan> What is the main benefit of running ghci inside emacs compared to running ghci in a separate tab, are you looking for a quicker switch to ghci from your editor?
07:55:18 <Saizan__> wli: tried this? http://www.nabble.com/building-ghc-6.10.1-against-readline-td21346346.html
07:55:22 <wli> I can barely understand you.
07:55:28 <sundaymorning> :set prompt helps, but it still doesn't get rid of the welcoming and living messages
07:55:55 <wli> Saizan: gentoo already applies them. Something in their packaging system is bypassing the patch or screwing things up.
07:55:57 <Flugan> I generally stay far away from emacs because I find it more frustrating than useful but my partner uses emacs and tried the integrated terminal without being sold either.
07:56:05 <Flugan> Sorry about that
07:56:14 <Flugan> wli
07:56:26 <kynky> emacs got good haskell support
07:56:50 <skorpan> "good"
07:56:51 <wli> That's all well and good. It unfortunately has very poor wli support.
07:57:02 <Flugan> I'm a noob when it comes to emacs but it has too many features missing
07:57:29 <Saizan__> we were talking about keybindings for ghci though
07:57:36 <skorpan> Flugan: like what?
07:57:49 <drhodes> there are many emacs cheat sheets available, it helps to print them out and put them in visible range.
07:59:00 <Flugan> Find in files, primarily
07:59:43 <sundaymorning> Flugan: like grep?
07:59:47 <Flugan> I like tabbed interface when working with many files
07:59:55 <Flugan> not like grep
08:00:08 <wli> drhodes: I'm sure that will be a great help undoing an entire 15-year-long (albeit now crashing to an end) computing career worth of vi usage, especially when I'm attempting to go about remedial programming to somehow regain some modicum of productivity after apparent serious impacts of medical conditions on cognitive function.
08:00:34 <wli> drhodes: Maybe you have more experience in these areas than I.
08:01:39 <Flugan> The emacs terminal have a tendency to work exactly like you want but at the same time disabling almost all emacs shortcuts or using a more limited line mode
08:01:40 <wli> Let's throw re-learning how to type and use text editors atop of sub-freshman -level programming. That'll get me much further.
08:03:08 <wli> Flugan: ESC 3 b is working wonders already.
08:03:38 <sundaymorning> I use vim as my editor, but I have learned the basics of emacs since its keybindings are used in several programs
08:03:40 <Flugan> good to know
08:04:30 <sundaymorning> it never hurts to learn a new set of keybindings
08:04:45 <wli> Flugan: In vi it enters cursor movement mode and moves 3 words back. In emacs keybindings (or whatever) it seems to insert 3 'b' characters.
08:05:10 <mmorrow> guenni: the paper?
08:06:09 <wli> mmorrow: I'm probably not going to see a ghci repl in any form I can use for a few days or (worse, if I have trouble) whenever things mysteriously start working.
08:08:32 <bremner> wli: did you try using rlwrap?
08:08:32 <mmorrow> wli: uhoh. did the build go to hell and take your 6.8.3 with it?
08:08:57 * bremner guesses you might have to shut off editline in  ghci to make it work
08:09:18 <mmorrow> bremner: yeah, they'd probably tear each other apart
08:09:48 <bremner> could be fun to watch
08:10:26 <mmorrow> true
08:13:46 <bremner> hmm, anyone know how to shut editline off in ghci?
08:14:32 <mauke> shouldn't that happen automatically if stdin is not a terminal?
08:15:17 <bremner> mauke: I think rlwrap lies about that
08:15:46 <mauke> cat | ghci
08:24:29 <vixey> > 100000000000000000+1
08:24:31 <vixey> > 1111111^2
08:24:31 <lambdabot>   100000000000000001
08:24:33 <lambdabot>   1234567654321
08:25:59 <bremner> wli: rlwrap -a ghci  seems to work (you need a .inputrc with set editing-mode vi, but I guess you already have that)
08:26:28 <ehird> 12:16 beelsebob: @seen ehird
08:26:28 <ehird> 12:16 lambdabot: ehird is in #haskell. I last heard ehird speak 11h 9m 58s ago.
08:26:31 <ehird> pong
08:27:50 <ehird> @seen beelsebob
08:27:50 <lambdabot> beelsebob is in #macosxdev, #haskell-blah, #macosx, #ghc and #haskell. I last heard beelsebob speak 43m 30s ago.
08:32:20 <igel> when i have multiple build targets in a .cabal file (a lib and a binary), is there a nice way to set the same dependencies etc. for both targets?
08:33:12 <igel> Build-Depends, hs-source-dirs, extensions and ghc-options are the same in my case
08:33:18 <dcoutts> igel: no, just have to mention them in both places
08:33:35 <dcoutts> igel: one day you'll be able to say that the exe depends on the lib
08:34:07 <igel> "mention"?
08:34:32 <igel> you mean declare the field but leave it empty?
08:35:32 <igel> i took a look at haddock and hscolour (they're in the same situtation)
08:35:57 <igel> what they do is set all the fields for one target and leave the other one almost empty
08:38:56 <Phyx-> hmm, I'm having a bit of a problem with a reader monad, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3052 is what i'm trying to do.. it should work i think
08:39:32 <vixey> var <- (readIORef =<< ask)
08:39:34 <vixey> this looks odd
08:39:59 <jmcarthur> :t readIORef =<< ask
08:40:00 <Phyx-> lol
08:40:00 <lambdabot> Not in scope: `readIORef'
08:40:04 <vixey> why don't you have something like
08:40:14 <vixey> ref <- lift $ ask ; var <- readIORef ref
08:40:14 <vixey> or
08:40:19 <vixey> ref <- ask ; var <- lift $ readIORef ref
08:40:37 <mauke> liftIO readIORef =<< ask?
08:40:38 <vixey> I don't know which it should be ..
08:40:39 <vixey> but if one of these works then you can put it all in one
08:41:05 <Phyx-> ah
08:41:08 <Phyx-> thanks mauke
08:41:25 <Phyx-> heh, after all that the problem was simple
08:41:25 <Phyx-> lol
08:42:17 <McManiaC_> "otherwise" - ok for "case" but not for pattern matching, correct?
08:42:27 <mauke> "case" is pattern matching
08:42:32 <igel> @src otherwise
08:42:32 <lambdabot> otherwise = True
08:42:32 <vixey> McManiaC_:
08:42:52 <__Ali__> how is it possible to use haskell to create a DSL with a new syntax? any resources?
08:42:52 <Martijn> Could someone advice me, please? I am building a standalone program for Yogurt (my MUD client) that depends on Hint. Should I release this as a separate package, so that people wishing to use just the library don't need to install hint?
08:42:53 <Baughn> For an ADT Foo with a field bar :: Bar, is there any syntax that will provide a convenient update function Bar -> Foo for an existing Foo?
08:43:34 <Phyx-> lol, now i guess i have to define an instance of monadreader :(
08:43:35 <McManiaC_> so where is it valid to use otherwise and where should i avoid it? we've been discussing it a while ago but i forgot it again :)
08:43:38 <Phyx-> No instance for (MonadReader (IORef Session) IO)
08:43:39 <Phyx-> lol
08:43:53 <Phyx-> i thought the point of monad transformers was that i didn't have to
08:44:16 <Baughn> McManiaC_: Otherwise has no special meaning. It's a global binding with the value True, and that's about it.
08:44:32 <Baughn> McManiaC_: You can use it in a pattern match, in which case you get a local binding shadowing the global one
08:44:43 <Baughn> s/Otherwise/otherwise/
08:45:00 <mauke> Phyx-: that looks wrong
08:45:13 <Phyx-> :(
08:45:15 <Martijn> McManiaC_: it is conventional to use _ in pattern matching and "case". otherwise is usually only used in pattern guards.
08:45:17 <McManiaC_> ok
08:45:59 <McManiaC_> ah okay i think thats it Martijn
08:46:00 <McManiaC_> thx
08:46:06 <Martijn> np
08:46:33 <Phyx-> mauke, i have this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3053
08:46:52 <mauke> yes, that's wrong
08:47:14 <mauke> readIORef =<< ask is a type error, haven't we just talked about that?
08:47:39 <Phyx-> to which someone said add liftIO
08:47:40 <Lemmih> __Ali__: It isn't really.
08:48:21 <McManiaC_> what is DSL?
08:48:26 <__Ali__> Lemmih, i thought haskell _is_ the language to create a new syntax for a DSL?
08:48:35 <__Ali__> domain-specific language
08:48:47 <mauke> Phyx-: no, I specifically said liftIO readIORef =<< ask, not "add liftIO"
08:48:57 <skorpan> __Ali__: what do you mean when you say new syntax?
08:49:07 <mauke> Phyx-: mind, that's still wrong, but what I really meant was "liftIO . readIORef =<< ask"
08:49:42 <__Ali__> skorpan, an aribrary (simplified) grammar, the end user od the DSL does not feel he's coding in haskell
08:49:44 <Baughn> __Ali__: Haskell's great at EDSLs, which means "no new syntax". DSLs, not particularily, but you'll find that the existing syntax is very flexible
08:49:58 <Phyx-> i still get the same instance error
08:50:27 <__Ali__> Baughn, whend u say it's great at edsl, why is it better than other languages at doing this?
08:50:45 <mauke> liftIO . readIORef =<< ask compiles here
08:50:53 <Heffalump> __Ali__: strong and flexible type system, and relatively minimal syntax
08:51:06 <Heffalump> not as minimal as lisp, but the type system makes up for that (IMO)
08:51:43 <Heffalump> http://www.infoq.com/interviews/DSL-Haskell-Lennart-Augustsson
08:51:45 <Phyx-> mauke, yes, it's not a type error, i stopped getting that long ago. my current problem is it says
08:51:46 <Heffalump> take a look at that
08:51:46 <Phyx-> No instance for (MonadReader (IORef Session) IO)
08:51:47 <Phyx->       arising from a use of `ask'
08:51:51 <vixey> Phyx-: did youtry what I said
08:51:51 <vixey> ?
08:52:05 <mauke> Phyx-: that is a type error
08:52:07 <__Ali__> Heffalump, my problem with EDSL is that there is no line between EDSL and API (eg ruby and ruby-rail -- rail is not a new language at all), does haskell allow us to draw a good line between a new language in edsl and api?
08:52:17 <Phyx-> vixey, yes
08:52:24 <Phyx-> ended up in with the same thing
08:52:26 <vixey> and it didn't work?
08:52:49 <rovar> __Ali__: That doesn't seem like a problem to me
08:53:02 <Phyx-> vixey, no, gave the same thing, lol
08:53:10 <Baughn> __Ali__: Yes, via the type system
08:53:11 <conal> __Ali__: there's a classic paper on the idea of EDSLs, called "The next 700 programming languages".
08:53:16 <Heffalump> __Ali__: why would you want to?
08:53:24 <vixey> Phyx-; I don't know what that means..
08:53:27 <vixey> the same thing  as ?
08:53:47 <vixey> it can't have given the same error because it was a different program
08:53:49 <conal> __Ali__: the author, Peter Landin, proposes a universal host language ISWIM, from which Haskell is descended.
08:54:25 <Phyx-> nvm, i think i see the problem, it's in the next call
08:54:29 <Phyx-> the runStateT call
08:55:04 <conal> __Ali__: i also wrote a paper a while back that includes criteria for host language, explaining why Haskell works well.  "Modeling Interactive 3D and Multimedia Animation with an Embedded Language" -- http://conal.net/papers/dsl97/dsl97.html
08:55:20 <__Ali__> Heffalump, assume i want to define 10 new keywords for my end user, i as the developer want to extend libraries hidden from the end user (simply because they do not wish to understand haskell), so i want to _only_ expose those domain-specific keywords required for the end user and nothing else
08:55:44 <Heffalump> __Ali__: if you want that, then write a DSL, not an EDSL.
08:55:52 <__Ali__> conal, thanks a lot, i'll read them
08:55:52 <Heffalump> The whole point of the 'E' is that you inherit features from the host language.
08:56:11 <Heffalump> well, much of the point. I guess you also get type-checking and stuff.
08:56:23 <conal> __Ali__: :)
08:56:27 <Phyx-> thanks vixey, mauke
08:56:53 <Heffalump> If you do some minimal pre-processing for them you could insist that they import Prelude (), and run with NoImplicitPrelude, then nothing in the base Haskell language would be exposed to them.
08:56:53 <__Ali__> Heffalump, well, i dont want to start from scratch and end up with an isolated language, i want to use haskell potentials as the developer, it's just that the end user will freak out interacting with haskell (or even java script)
08:56:58 <Heffalump> but that seems rather perverse to me
08:57:27 <Heffalump> why will they freak out? The most likely reason to me seems to be error messages, and you'll have that problem anyway if you hide stuff.
08:58:00 <Heffalump> (and I do have practical experience of maintaining an EDSL in Haskell that has end-users that aren't expected to be Haskell experts, though we do teach them Haskell)
08:58:23 <Phyx-> lol, sorry for being stubborn, i'm just not very use to monad tranformers yet
08:59:16 <__Ali__> Heffalump, let's say we have a EDSL in haskell with 10 keywords, for the sake of no reason, how can we bound the user to only be allowed to use those 10 keywords and nothing else in haskell?
08:59:41 <mauke> __Ali__: you can't
09:00:08 <__Ali__> mauke, haskell the meta-programming beast doesnt do this?
09:00:31 <mauke> have you confused haskell and lisp?
09:00:39 <Baughn> "case buffer of (S.length -> size) | size < minimumSize -> ..." <-- Ooh, nifty
09:00:56 <__Ali__> i thought haskell is more modern than lisp
09:01:07 <mauke> PHP is even more modern
09:01:11 <ehird> __Ali__: "haskell the meta-programming beast"? and it needs certain properties to be modern? are you sure you're not trolling?
09:01:11 <EvilTerran> __Ali__, so are most programming langauges
09:01:59 <__Ali__> modern version of lisp = inheriting lisp properties?
09:03:21 <mauke> scheme?
09:03:27 <ray> it's more modern by the only definition that makes any sense (it was invented in 1990, and lisp was invented in 1958), but that doesn't mean much
09:04:28 <Saizan__> __Ali__: you can just get the program as String and write a simple parser that converts the keywords to the equivalent combinators
09:05:49 <Saizan__> you could use QuasiQuoting if you want to embed it in an haskell source file
09:07:02 <beelsebob> hey ehird
09:07:17 <ehird> hi
09:07:23 <beelsebob> is there any tool for telling IB about the classes etc you define in Haskell?
09:07:28 <ehird> hm.
09:07:33 <beelsebob> I was toying with writing a tool to update nibs of the info
09:07:38 <ehird> i'm not overly familiar with IB
09:07:44 <ehird> I'll take a look
09:08:00 <beelsebob> evidently someone's managed it in the past, because the sample code works
09:08:04 <beelsebob> but I don't see quite how
09:08:11 <beelsebob> unless they manually edited the nib
09:08:43 <ehird> beelsebob: maybe they wrote an .h for it?
09:08:46 <ehird> and put that into IB
09:09:04 <beelsebob> yeh, that would work in old versions
09:09:09 <ehird> beelsebob: in Browser:
09:09:11 <beelsebob> unfortunately not doable in the latest IB though
09:09:13 <ehird>             CLASS = BrowserController;
09:09:13 <ehird>             LANGUAGE = ObjC;
09:09:19 <beelsebob> yeh
09:09:19 <ehird> so it obviously is some sort of hack
09:09:22 <beelsebob> okay
09:09:23 <__Ali__> Saizan__, Quasiquotation looks interesting, can it handle data type conversion?
09:09:30 <beelsebob> I'll carry on writing the tool to update nibs then
09:09:55 <ehird> beelsebob: as a long term project, would be nice to integrate it into the xcode suite so this just works
09:10:17 <beelsebob> ehird: yeh, someone's written half of one of them
09:10:23 <beelsebob> but it's not ideal
09:10:24 <ehird> ah
09:10:35 <beelsebob> it has syntax highlighting and error reporting
09:10:42 <beelsebob> but i don't see it updating nibs properly
09:10:58 <ehird> yeah not too fussed about editing w/ xcode
09:11:04 <beelsebob> ditto
09:11:08 <beelsebob> I have SEE, and it works
09:11:19 <Saizan__> __Ali__: it just let you define a parser :: String -> TemplateHaskellAST for your own syntax, and use it like [$parser| ... |]
09:11:25 <ehird> beelsebob: SEE?
09:11:27 <beelsebob> the only thing that could improve on it is something that lets me do syntax highlighting/refactoring using the CST rather than just regexps
09:11:30 <beelsebob> SubEthaEdit
09:11:33 <ehird> ah
09:11:47 <ehird> beelsebob: does it handle autoindentation of haskell like haskell-indentation.el?
09:12:07 <beelsebob> it doesn't – but I actively hate that – it does it totally out of my style
09:12:15 <ehird> shame
09:12:18 <Saizan__> __Ali__: http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/template-haskell.html#th-quasiquotation
09:12:45 <beelsebob> it just puts the cursor at the same indent level as the last line
09:12:45 <__Ali__> Saizan__, thanks, this paper is also nice http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
09:12:52 <beelsebob> and most Haskell indentation is a case of then pressing tab once
09:13:59 <beelsebob> ehird: do we know who's allowed to commit to HoC's svn btw?
09:14:03 <Heffalump> __Ali__: just preprocess the users' code to restrict them to importing Prelude () etc as I already suggested
09:14:22 <ehird> beelsebob: yes. (#haskell-osx? since this is not really ot here)
09:14:35 <beelsebob> sure
09:14:45 <conal> Heffalump: i think i made the same suggestion to __Ali__ yesterday.
09:15:01 <conal> "__Ali__: you could write your own trivial preprocessor that inserts the module header, instead of asking your users to."
09:15:09 <__Ali__> Heffalump, that's right
09:15:41 <conal> preceded by "__Ali__: if you really want, you can tell your users not to import anything but your one module and to turn off implicit prelude import."
09:15:59 <__Ali__> conal, yes you did, i don't know why i feel there is some vacuum in the outcome edsl
09:16:40 <conal> __Ali__: i don't think it's a good idea ultimately.  i ust think you'd get more clarity from the experiment.
09:16:44 <__Ali__> conal, and i replied that it's not nice to _ask_ the user not to import, your design should not allow the user to do so
09:16:44 <conal> (*just*)
09:17:01 <conal> __Ali__: right.  so i gave you the preprocessor suggestion.
09:17:25 <conal> __Ali__: simple.  give it a try and let us know.
09:18:19 <dolio> It sounds like the problem is that you don't want an EDSL, you want a DSL.
09:18:49 <dolio> (NEDSL)
09:19:06 <conal> dolio: that what i expect he'd conclude.  or that he really does want an edsl, including full access to complementary functionality.
09:19:22 <conal> complementarity is the jewel of edsl-ness.
09:19:29 <igel> uhm... are scoping rules somehow different when using template haskell?
09:19:33 <__Ali__> dolio, this may sound greedy, but i want something with the stand-alone-looking of a DSL and the power-of-being-accessible-to-the-host of EDSL
09:19:49 <igel> i have sth like
09:20:14 <igel> data Foo; $( something_with_foo_and_bar ); data Bar
09:20:15 <conal> __Ali__: do you mean the reverse, i.e., the power-of-accessing-the-host ?
09:20:30 <igel> and i get a compile error that bar is not found
09:20:39 <__Ali__> conal, i was going to say the sme about your comment :) do you mean the reverse?
09:21:13 <conal> __Ali__: yeah.  somehow there's a communication gap here.
09:21:36 <__Ali__> DSL = stand-alone and isolated, eg, it cannot access the haskell libraries without some sort of 'wrapping'
09:22:07 <__Ali__> EDSL = not stand-alone but not isolated, it can access all libraries in the host language
09:22:18 <conal> __Ali__: and you want isolated, right?
09:22:21 <__Ali__> how can we have the best of the both worlds?
09:22:42 <__Ali__> no, i want stand-alone wich can access the existing libraries in the haskell
09:23:07 <conal> in what sense is it "stand-alone" if it has that access?
09:23:08 <dolio> What's better about DSLs of the first type? Besides, probably, better domain specific syntax?
09:24:12 <__Ali__> dolio, yes it's all about domain specific syntax, then, it looks unnecessary and ugly that the user can also import a world of non relevant general purpose API into this specific domain
09:25:00 <__Ali__> conal, the access is something extra, not something necessary, the idea of access is to use the existing recourses without re-inventing the wheel my the new DSL
09:25:03 <pejo> Ali, why is that a problem if your users don't know Haskell?
09:26:17 <dolio> I was thinking more along the lines of being able to write more natural expressions that domain experts would be familiar with.
09:26:39 <__Ali__> pejo, i want to keep the DSL purely exposed to the end-user and the haskell layer purely to be exposed to the developer-users
09:26:42 <dolio> Instead of having to finesse function application and monads to look like what you want to say.
09:28:00 <__Ali__> dolio, how flexiable can haskell be in that sense? eg, if A is a matrix, can i define A' syntax as the transpose and ||A|| as the norm?
09:28:03 <rovar> anyone know if it is possible to make Handle an instance of Ord?
09:28:22 <vixey> __Ali__: none of that works
09:28:27 <vixey> __Ali__: you must use quotation
09:28:30 <dolio> No. You could do the latter if you had circumfix operators.
09:28:36 <dolio> But Haskell doesn't.
09:29:21 <__Ali__> so the EDSL approach is not an option for such requirements?
09:29:28 <rovar> I am having a hard time associating input from a socket with the state for that socket, my current approach is to spawn a socket reader with counter, and send the data from the socket down a channel with the "id"
09:29:32 <vixey> what's "the EDSL approach"?
09:29:43 <dolio> Technically you could probably give || a type such that ||a|| was the norm of a matrix, but that'd be somewhat hacky.
09:29:50 <FunctorSalad> :D
09:29:55 <conal> __Ali__: haskell is not that syntactically flexible.
09:30:00 <__Ali__> vixey, trying to have eg the A' from within haskell?
09:30:02 <Martijn> __Ali__: you may define prefix functions and infix operators. A' is neither.
09:30:11 <vixey> __Ali__: yeah what is it
09:30:25 <vixey> beyond this one specific example
09:30:31 <Martijn> __Ali__: I'm sure you'd like the distfix approach in Agda :-)
09:30:33 <FunctorSalad> || :: ? where ? == Matrix -> ? -> Scalar
09:30:41 <FunctorSalad> looks like an infinite type to me dolio
09:30:45 <FunctorSalad> but maybe with type classes
09:30:49 <conal> Lisp is sort of that flexible, once you buy into the s-expression restriction.
09:31:05 <dolio> FunctorSalad: Just type it as 'Matrix -> a -> Scalar'.
09:31:07 <__Ali__> Martijn, any links?
09:31:12 <dolio> Then you can put anything there. :)
09:31:27 <FunctorSalad> dolio: good point ;)
09:31:42 <Martijn> @hackage Agda-executable
09:31:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Agda-executable
09:31:47 <dolio> That still doesn't work, though, because that's 'a || (||)' is the norm.
09:32:00 <dolio> || isn't a regular function, so you're stuck.
09:32:22 <conal> dolio: the haskell libs have some pretty powerful tools for rolling your own syntax with parsers & unparsers.
09:32:26 <conal> oops
09:32:34 <conal> that one was for __Ali__
09:32:50 <__Ali__> got it :)
09:33:18 <__Ali__> conal, like which libs, apart from QuasiQoutation
09:33:41 <conal> __Ali__: parsec and wl-pprint (and other pprint variants)
09:34:03 <conal> __Ali__: there are probably some tools to help with type checking also.
09:34:13 <conal> __Ali__: check out hackage.
09:34:15 <conal> @hackage
09:34:15 <lambdabot> http://hackage.haskell.org
09:34:50 <FunctorSalad> can't you just let haskell do the typechecking after un-quasiquoting?
09:35:09 <Saizan__> you can
09:35:58 <conal> even better
09:36:29 <conal> __Ali__: sounds like you have a lot of input to digest.
09:36:36 <conal> __Ali__: good luck!
09:37:15 <__Ali__> conal, i wish that was all, i also want haskell to be as embedd-able as lua :)
09:37:33 <conal> __Ali__: yeah.  sry :(
09:38:09 <FunctorSalad> conal: btw I tried to implement the horner scheme from the music-of-streams paper...
09:38:25 <conal> FunctorSalad: yeah?
09:39:05 <FunctorSalad> but I'm stuck with "evalD (let f = 1+(z*f) in f)" hanging, where "evalD" takes the constant term and z is the power series "z"
09:39:49 <FunctorSalad> (I did it just for 1-dim domains for now, so it's not a linear-map-trie issue)
09:39:58 <jrx> hi everyone, I have read article on wiki about DiffArrays and it says they have superior performance to ordinary IArray and can be freely used in purely functional code. I'm just curious whether it has any drawbacks? Can I just change every ocurrence of IArray with DiffArray and be happy from performance boost?
09:40:27 <conal> FunctorSalad: linear-map-trie? are you working on derivatives?
09:41:52 <dolio> I've heard claims that they're actually not that fast. But if you get a speed up, go with it.
09:42:14 <FunctorSalad> conal: not directly, but they can be calculated from the horner-form (was just mentioning the tries because that's how you handle multidimensional domains in Data.MacLaurin, I think)
09:42:25 <latitude> howdy
09:42:27 <conal> FunctorSalad: oh, okay.
09:42:30 <Saizan__> you should avoid to refer to old versions of the array if you can
09:42:53 <dolio> Also, to get the best speedup, you need to try to not use old versions as much as possible.
09:42:54 <jrx> I fact I don't refer
09:43:01 <luite> jrx: you may also want to try IntMap
09:43:01 <latitude> how about compiling haskel with autotools? are there any chances?
09:43:01 <FunctorSalad> (in 1D the power series is essentially just a newtype for list)
09:43:09 <dolio> Otherwise it copies just like the other immutable arrays.
09:44:01 <pejo> latitude, autotools can be somewhat painful on Windows. But autotools is just shellscripts, you can do whatever you want there.
09:44:53 <Phyx-> is there a way within the haskell module system to specify what not to export, instead of what to include?
09:45:50 <latitude> pejo: windows is not an option, i need to distribute a suite of haskell and c++ sources
09:46:04 <Heffalump> Phyx-: not without playing tricks with two modules
09:46:11 <latitude> cpp srcs are targeted on unices
09:46:38 <latitude> just maybe there are any ac macroses ready in the wild?
09:46:43 <Heffalump> i.e have the second module import the first hiding stuff and then list the first in the second's export list
09:47:08 <pejo> latitude, you can have cabal call your configure script instead, and get the haskell building for free.
09:47:35 <conal> FunctorSalad: does it make sense to you that your f is productive in the horner rep?
09:47:42 <Phyx-> Heffalump, thought asmuch :(
09:48:22 <conal> FunctorSalad: i.e., f = 1+(z*f)
09:48:31 <FunctorSalad> conal: yes, as I see it it is just the series 1+z+z^2+z^3+...
09:49:33 <gwern> 'The language community should take some numerical analysts seriously enough -- it's numerical analysts who care about these support issues -- and not ask the guys designing H-bombs or supersonic wings, because these latter don't give much of a damn about floating point. Their algorithms are very robust, they can tolerate all sorts of floating point, after all, they run on Crays! Anything that runs on a Cray doesn't care how you round, ...
09:49:39 <gwern> ... because a Cray rounds in a way that beggars description.' <-- hee hee
09:50:39 <conal> FunctorSalad: re-reading the paper now, it looks to me like the first term out of a product depends on the first terms of each multiplicand
09:51:00 <conal> FunctorSalad: oh - i see
09:51:27 <conal> FunctorSalad: z leads with zero?
09:51:42 <conal> hm.
09:52:05 <FunctorSalad> conal: I'm using a safe constructor that catche the leading term
09:52:12 <FunctorSalad> *that catches the leading term being zero
09:52:17 <FunctorSalad> sorry, hit enter :)
09:53:03 <FunctorSalad> hmm or actually that's not even necessary in this case
09:54:10 <conal> FunctorSalad: i'm wondering how the impl can know that the leading term is zero.  i know it's zero because 0*x == x.
09:54:17 <FunctorSalad> hmm wait I think it tries to calculate (0*(0*(0....))) in the first term of z*f
09:54:20 <latitude> pejo: will i need cabal installed in addition to say ghc, in order to be able to compile the things? Or this Distribution.Simple package is bundled with haskell?
09:54:27 <conal> FunctorSalad: yeah.
09:55:12 <Heffalump> conal: your arithmetic worries me :-)
09:55:13 <conal> Heffalump: i know it's not always valid.
09:55:14 <conal> and in fact it's not valid in this examples.
09:55:15 <conal> (example)
09:55:36 <conal> because x is indeed _|_
09:55:42 <Heffalump> didn't you mean 0*x == 0 ?
09:55:52 <FunctorSalad> seems like I just need to check the leading terms of the two multiplicands for zeroness seperately rather than after they're multiplied
09:55:53 <pejo> latitude, cabal comes with your haskell compiler, cabal-install doesn't. But you don't need cabal-install to install packages, it's just a very convenient way to get them from hackage.
09:55:59 <conal> Heffalump: oh yeah, i did.
09:56:03 <conal> Heffalump: which is also false.
09:56:26 <Heffalump> yeah, but less dubious mathematically :-)
09:56:26 <Cale> ... If 0*x = x, then x = 0.
09:56:40 <conal> FunctorSalad: yeah.  but watch it.  you'll want an unbiased zero-test.
09:56:50 <conal> FunctorSalad: you can use unamb
09:56:52 <FunctorSalad> true...
09:56:56 <jmcarthur> what is the topic here?
09:56:58 <Cale> (I'm not really following this conversation, but the first equation made more sense as an explanation for knowing why something was 0)
09:57:13 <FunctorSalad> conal: thanks I'll look at it :)
09:57:18 <latitude> pejo: thanks for help
09:57:20 <conal> FunctorSalad: parAnnihilator is made for just this situation.
09:57:52 <conal> FunctorSalad: 'parAnnihilator (*) 0'
09:58:16 <conal> FunctorSalad: is a multiply that yields zero if either argument is zero, even if the other is bottom.
09:59:34 <conal> FunctorSalad: if you use unamb more than trivially, you'll probably need a pretty recent GHC.  the concurrency RTS had some bugs until recently.
09:59:58 <jmcarthur> conal: i might touch back on frp for a little bit. i'm curious if you remember any of the more interesting semantics you had thought up before you settled for now on those of Reactive?
10:00:20 <conal> jmcarthur: probably.  there were so many.
10:00:22 <FunctorSalad> conal: 6.10.1 or even more recent?
10:00:32 <jmcarthur> just looking to cheat a little for starting back up ;)
10:00:33 <conal> FunctorSalad: more recent
10:01:10 <jmcarthur> just wanting to pick your brain a bit, if you don't mind
10:01:31 <conal> FunctorSalad: if you don't use unamb compositionally, i think you'll be fine with 6.10.1.
10:01:35 <conal> jmcarthur: i don't mind.
10:02:18 <FunctorSalad> conal: compositionally? like "a `pmult` b `pmult` c"?
10:02:48 <conal> FunctorSalad: yeah
10:03:06 <jmcarthur> conal: did you ever think about what semantics could arise by dropping Event and having only Behavior as the primary model?
10:03:19 <conal> jmcarthur: yeah, from early on.
10:03:28 <conal> jmcarthur: i'd still like to get there
10:03:51 <conal> i don't know how.
10:03:53 <jmcarthur> conal: okay, so you abandoned it for the time being because it was difficult, not because it introduced some inherent complexity?
10:04:22 <jmcarthur> conal: i ask only to see if you had discovered some fundamental problem with it
10:04:49 <conal> jmcarthur: when i tried to model events as behaviors, i could handle info-less events, but not info-ful events.
10:04:54 <jmcarthur> i also don't know how to derive Events from just Behaviors, which i imagine was also your problem
10:05:09 <conal> jmcarthur: i tried Event a = Behavior (Maybe a)
10:05:39 <dolio> That's how they did it in the old days.
10:06:01 <jmcarthur> conal: so events were "impulses" in behaviors?
10:06:01 <conal> jmcarthur: the yampa guys do use that model.  i never understood the semantics from a continuous-time perspective.
10:06:44 <conal> jmcarthur: i guess so, though the maybe-behavior model doesn't impose impulse-ness.
10:06:46 <jmcarthur> conal: "info-less events" ... basically equivalent to Event ()?
10:06:55 <conal> jmcarthur: yeah.
10:07:33 <conal> jmcarthur: i could take the infimum of the times for 'Just ()' and call that the occurrence time.
10:07:50 <conal> jmcarthur: but when adding data, i don't know what data to use, since a limit might not exist.
10:08:04 <jmcarthur> conal: how did you envision that "sampling" behaviors would work, semantically, like your current snapshot functions?
10:08:10 <conal> jmcarthur: that was in 1995 or so.  i never saw past the snag.
10:08:29 <conal> jmcarthur: i didn't.   sampling isn't part of the semantics.
10:08:49 <conal> i mean discrete sampling isn't.
10:09:13 <jmcarthur> yeah, lemme think how to work that question better
10:09:18 <conal> sure
10:10:28 <jmcarthur> conal: did you have a plan as far as how a program could cause effects using a composition of Behaviors?
10:10:31 <bavardage> how do I sum a large list?
10:10:37 <bavardage> let result = [1.0/x | x<-[1..1000001]] like this
10:10:40 <bavardage> w/o a stack overflow
10:11:02 <conal> jmcarthur: oh yeah.  Fran had 'predicate :: Behavior Bool -> Event ()'
10:11:22 <jmcarthur> conal: was that a primitive?
10:11:23 <conal> jmcarthur: which could generalize to "Behavior (Maybe a) -> Event a"
10:11:39 <conal> jmcarthur: yeah.  implemented with interval analysis, iirc.
10:11:48 <conal> jmcarthur: it's in the fran paper (icfp 97)
10:12:14 <conal> jmcarthur: which you can find on http://conal.net/papers
10:12:48 <jmcarthur> conal: yeah, good idea. i should probably read that again before i ask more questions ;)
10:12:56 <jmcarthur> thank you for your time
10:13:03 <conal> jmcarthur: it's a start.  my pleasure.  :)
10:13:07 <vixey> @hoogle  const $ return ()
10:13:08 <lambdabot> Did you mean: $ (Const return return) (return ()) /count=20
10:13:08 <lambdabot> No results found
10:13:24 <conal> jmcarthur: warning: that paper used single-occurrence events, which i now call "future values".
10:13:36 <conal> jmcarthur: i switched to multi-occurrence very shortly after that paper.
10:13:42 <vixey> @hoogle  $$$
10:13:42 <lambdabot> No results found
10:13:48 <vixey> @hoogle flip $ id
10:13:48 <lambdabot> Warning: Unknown type $
10:13:49 <lambdabot> Control.Applicative unwrapArrow :: WrappedArrow a b c -> a b c
10:13:49 <lambdabot> Control.Arrow zeroArrow :: ArrowZero a => a b c
10:13:49 <jmcarthur> conal: thanks for the warning. that probably would have thrown me
10:13:49 <conal> hoogling for dollars
10:13:55 <conal> :)
10:14:03 <singintime> just for curiosity: which editor/IDE do you prefer to write haskell code?
10:14:14 <trofi> emacs
10:14:14 <singintime> I don't want to start the same pointless religion war
10:14:15 <bavardage> EMACS!
10:14:17 <conal> singintime: emacs.  nice haskell support
10:14:17 <luite> emacs
10:14:24 <vixey> I use emacs too
10:14:29 <conal> hah  -- i'm in emacs land :)
10:14:30 <jmcarthur> emacs
10:14:31 <bavardage> inded
10:14:33 <BONUS> vim
10:14:35 <BONUS> :]
10:14:39 <bavardage> BONUS: GTFO :D
10:14:39 <BONUS> combo breaker
10:14:39 <trofi> Hey!
10:14:39 <bavardage> hehe
10:14:40 <trofi> :]
10:14:44 <BONUS> haha
10:14:46 <conal> BONUS: yay -- some variety.
10:14:55 <trofi> > fix ("emacs "++)
10:14:57 <lambdabot>   "emacs emacs emacs emacs emacs emacs emacs emacs emacs emacs emacs emacs em...
10:14:57 <BONUS> emacs is awesome too though
10:14:59 <jmcarthur> singintime: i think you will find a higher-than-normal ratio of emacs to vim users here, but honestly, both are good anyway ;)
10:15:05 <BONUS> yup
10:15:21 <singintime> ok
10:15:34 <singintime> thx a lot
10:15:38 <Philonous> I wonder why no one mentioned yi
10:15:45 <vixey> nobody uses it ...
10:15:48 <singintime> I'll give them a try
10:15:50 <singintime> yi?
10:15:49 <jmcarthur> i don't use yi because i don't understand it yet
10:15:57 <trofi> YI does not work for me in xterm :[
10:16:03 <jmcarthur> and it seems too unstable/incomplete for me to bother yet
10:16:40 <singintime> oh... found it
10:16:56 <trofi> @let emacs = "emacs"
10:16:57 <singintime> I worship thee, St. Google!
10:16:59 <lambdabot>  Defined.
10:17:26 <sundaymo1ning> I use vim, anyone using something else is completely CLUELESS
10:17:38 <trofi> :]
10:18:17 <singintime> oh, god... I knew I'd better not ask that question... :)
10:18:18 <kynky> leksah too
10:18:35 <bavardage> shame, this emacs thing isn't a significant result :(
10:19:01 <bavardage> well out of 7, 6 emacs
10:19:14 <trofi> singintime: at least you can get help here to setup emacs :]
10:19:19 <bavardage> hehe indeed
10:19:23 <sundaymo1ning> there was 2 vims
10:19:27 <bavardage> really?
10:19:36 <trofi> yep :]
10:19:37 <bavardage> even less significant then
10:19:39 <sundaymo1ning> BONUS and me
10:19:45 <bavardage> so we can't actually draw any conclusions
10:19:49 <bavardage> how many total were there?
10:19:55 <sundaymo1ning> I didn't count
10:20:07 <bavardage> say 6 emacs 2 vim then
10:20:07 <trofi> @let inf = 1/0
10:20:10 <lambdabot>  Defined.
10:20:13 <trofi> > 2/inf
10:20:15 <lambdabot>   0.0
10:20:24 <bavardage> hmm 14% significant :(
10:20:28 <bavardage> TIS NOT ENOUGH
10:20:51 <sundaymo1ning> maybe vim people prefer the night and emacs prefer the day
10:21:01 <bavardage> maybe
10:21:03 <bavardage> that could be true
10:21:06 <Philonous> In which timezone?
10:21:12 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3054#a3054
10:21:16 <sundaymo1ning> whichever they are
10:21:39 <sundaymo1ning> but it's day in europe and in the americas right now, and I guess most people here are from europe or america
10:22:02 <trofi> ?localtime trofi
10:22:04 <lambdabot> Local time for trofi is Sun Mar 29 20:21:57 2009
10:22:16 <rovar> I'm sure I'm missing something obvious here, but i have two functions in the StateT monad, I'm trying to simply wanting to return a value
10:22:23 <kynky> from what ive read and seen emacs has the n#better haskell integration, but i guess lotsof ppl have decided with vim or emacs b4 they embark with haskell
10:22:50 <sundaymo1ning> I don't think the editor changes that much
10:23:07 <sundaymo1ning> in the end, you gotta know haskell and that's all
10:23:09 <vixey> I don't think it matters much, you just type
10:23:26 <singintime> me neither... I was just looking for some suggestions
10:23:47 * edwardk wakes up and tries to think of more monoids
10:23:47 <singintime> I'm quite new in the *nix world
10:23:52 <vixey> True `xor` True = False
10:23:52 <vixey> xor
10:24:02 <sundaymo1ning> you could even use kate, gedit, etc
10:24:04 <singintime> and so I don't actually have a favorite editor... yet :)
10:24:15 <sundaymo1ning> though most unix folks will use vim or emacs
10:24:33 <koeien> vim!!
10:24:36 <koeien> ;)
10:25:04 <sundaymo1ning> unlesse you use ed, the editor you use won't matter much :P
10:25:04 <rovar> is it not possible to return values from a function in a StateT monad?
10:25:06 * ddarius hopes edwardk didn't just actually wake up.
10:25:18 <edwardk> ddarius: went to sleep around 7am or so
10:25:27 <ddarius> edwardk: Why?
10:25:33 <singintime> wow, ed
10:25:39 <singintime> the standard editor
10:25:41 <edwardk> was finishing up packaging a bunch of containers for that monoid lib
10:25:49 <vixey> @quickcheck commutative xor
10:25:50 <lambdabot> Unknown command, try @list
10:26:15 <sundaymo1ning> yeah, it's common sense that ed is the most productive editor out there, but we are too lazy to be that productive
10:26:58 <ddarius> edwardk: I need to get you wife's phone number and call her to tell her to make you go to bed or make you go out as needed.
10:27:12 <edwardk> hah
10:27:26 <edwardk> she already gives me enough crap about such things, thank you ;)
10:27:43 <vixey> lol
10:27:46 <ddarius> edwardk: Apparently she could use a mite more encouragement.
10:27:47 <edwardk> she is also standing behind me laughing her head off
10:27:49 <monochrom> @help quickcheck
10:27:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:28:03 <vixey> @quackcheck
10:28:03 <lambdabot> Unknown command, try @list
10:28:14 <monochrom> perhaps it has no quickcheck
10:28:21 <ddarius> @check
10:28:22 <lambdabot>   <no location info>: parse error on input `;'
10:28:28 <monochrom> @help check
10:28:29 <lambdabot> check <expr>
10:28:29 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
10:28:42 <Heffalump> that really should say "disprove something".
10:28:45 <monochrom> @check \x y -> x && y == y && x
10:28:46 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\n()\n"
10:28:50 <vixey> heh
10:29:05 <Heffalump> what on earth was that?
10:29:09 <monochrom> @check \x y -> (x && y) == (y && x)
10:29:10 <Heffalump> > False && ()
10:29:11 <lambdabot>   "OK, passed 500 tests."
10:29:11 <vixey> x && (y == y) && x
10:29:11 <lambdabot>   Couldn't match expected type `Bool' against inferred type `()'
10:29:13 <Heffalump> oh, right :-)
10:29:48 <monochrom> . o O ( 500 tests is really exhaustive over, um, 2 booleans! )
10:29:58 <beelsebob> it might still have missed them
10:29:59 <beelsebob> they are random
10:30:04 <monochrom> haha
10:30:10 <beelsebob> go go smallcheck
10:30:18 <monochrom> @help scheck
10:30:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:30:32 <beelsebob> @scheck \x y -> (x && y) == (y && x)
10:30:33 <lambdabot>   "OK, passed 500 tests."
10:30:38 <beelsebob> ohhh... it did the same
10:30:45 <beelsebob> I thought it stopped after exhausting them
10:30:48 <beelsebob> and guarenteed coverage
10:31:01 <vixey> My program ended up 170 lines :(
10:31:02 <monochrom> scheck is check because edit distance <= 2
10:31:06 <vixey> that's really long
10:31:20 <monochrom> another example: stab is slap:
10:31:24 <monochrom> @stab monochrom
10:31:24 * lambdabot jabs monochrom with a C pointer
10:31:35 <vixey> @farmer
10:31:35 <lambdabot> Necessity is a mother.
10:31:38 <vixey> @farmer
10:31:39 <lambdabot> They closed the doors after the barn was stolen.
10:31:52 <ddarius> beelsebob: There used to be an scheck command.  I'm not sure where it went though.
10:32:21 <bremner> @slug monochrom
10:32:21 <lambdabot> Maybe you meant: bug slap
10:32:28 <ddarius> vixey: Unless you're writing Hello World, that doesn't seem unreasonable.
10:32:46 <rovar> can someone tell me why I get the error message listed here? : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3054#a3054
10:32:52 <rovar> LordanServer.hs:83  == line 21
10:32:56 <vixey> thanks
10:35:46 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3055#a3055 <- Im trying to FFI to C but I can't get it to work. Can somebody point out the error?
10:39:23 <FunctorSalad> conal: unamb is probably a necessary condition for this to work, but the <<loop>> checker still foils me ;)
10:39:55 <Saizan__> rovar: you need to use liftIO on atomically and putStrLn
10:40:22 <wli> I think I've lost ghci essentially until gentoo packages get fixed.
10:40:45 <gwern> @smallcheck \x->x==x
10:40:45 <lambdabot> Unknown command, try @list
10:41:04 <sundaymo1ning> @scheck \x->x==x
10:41:05 <lambdabot>   "OK, passed 500 tests."
10:41:24 <wli> There's no thought to it. It is the case. I've lost access to a Haskell repl.
10:41:31 <rovar> Saizan__: aagh. Thanks. I was looking completely in the wrong spot for the error
10:41:52 <FunctorSalad> is there any way to get more info about the alleged <<loop>>?
10:42:07 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3055#a3055 <- Im trying to FFI to C but I can't get it to work. Can somebody point out the error?
10:43:24 <monochrom> <<loop>> is a special kind of infinite loop that the runtime can detect. It comes from code like "x = x". That is all.
10:44:32 <monochrom> If the runtime didn't try to be smart and detect it, your program would non-terminate as normal, and you wouldn't be surprised.
10:44:35 <Saizan__> wli: haskeline supports vi keybindings apparently http://trac.haskell.org/haskeline/wiki/UserPrefs , so you could use ghci-haskeline from hackage in the mean time
10:45:18 <bremner> Saizan__: or as I mentioned earlier "rlwrap -a ghci"
10:45:40 <FunctorSalad> monochrom: it's almost like that, "print (let f = 1 + z*f in f)" with the Num ops being in a power series ring and z being the generator/variate
10:46:01 <FunctorSalad> the show instance only takes 10 terms, so it should terminate
10:47:02 <FunctorSalad> is it possible that this is a false positive?
10:47:28 <ddarius> FunctorSalad: No.
10:48:32 <Phyx-> ok, this might be a stupid question, lol. but is there such a thing that given, Reader r a , returns the r instead of the a that runReader does?
10:48:37 <monochrom> You can keep debugging your code.
10:48:45 <kadaver> is it possible that this is a negative positive?
10:48:53 <ddarius> Phyx-: ask
10:48:54 <ddarius> :t ask
10:48:56 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
10:49:19 <monochrom> A compiled program hangs. Of course you can always ask "maybe the compiler has a bug".
10:49:21 <rovar> what are the multiple reader/writer limitations of Chan vs TChan?  Can there be 1 simultaneous reader and writer on a Chan?
10:49:23 <Saizan__> FunctorSalad: you might miss an irrefutable pattern somewhere
10:49:50 <vixey> ok
10:49:56 <Phyx-> ddarius, lol, yeah, stupid me, lol
10:50:13 <FunctorSalad> Saizan__: hmm, ~-patterns, lambda binder patterns, anything else?
10:50:51 <HugoDaniel_> hi
10:51:01 <HugoDaniel_> how do i change a value in a list ?
10:51:02 <HugoDaniel_> like
10:51:12 <HugoDaniel_> lst[k] = x+y
10:51:21 <ddarius> HugoDaniel: You don't.
10:51:30 <monochrom> Don't change a value in a list.
10:51:38 <Saizan__> FunctorSalad: i meant ~-patterns specifically (wrong term?) a lambda pattern is still too strict for tying the know
10:51:42 <Saizan__> *knot
10:51:44 <HugoDaniel_> well, i was thinking about finding the index, then spliting the list, and constructing it again :/
10:51:52 <HugoDaniel_> but it sucks for performance (which is what i need in this case)
10:52:00 <jedai> Phyx-: That normally doesn't make sense since the r can't be modified in the monad... In other word the r returned would be the same you just fed to the run function...
10:52:04 <ddarius> Saizan__: You had the right term.
10:52:13 <vixey> Here's my program http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2003
10:52:15 <HugoDaniel_> okey, so what is the best data structure to change values ? a map ?
10:52:21 <ddarius> HugoDaniel: So you don't want to use a singly linked list.
10:52:26 <vixey> I tried to write FRP but I probably didn't manage
10:52:26 <jedai> Phyx-: Maybe you want Writer or State instead ?
10:52:31 <FunctorSalad> ddarius: a lambda-binder is irrefutable, maybe not Irrefutable
10:52:35 <Phyx-> jedai, in my case is an IORef
10:52:37 <vixey> anyway that's a nice littel animation ..
10:52:43 <HugoDaniel_> vixey: Data.Map then ?
10:52:46 <ddarius> HugoDaniel: An IntMap would work pretty nicely.
10:52:47 <FunctorSalad> (I agree it's more strict though)
10:52:54 <ddarius> FunctorSalad: What is a "lambda-binder"?
10:53:00 <vixey> I will ask in depth
10:53:02 * HugoDaniel_ searches for IntMap :)
10:53:17 <FunctorSalad> ddarius: (\Just x -> x) ...
10:53:32 <beelsebob> vixey: the lines about xor can quickly be deleted
10:53:33 <ddarius> FunctorSalad: That's a syntax error, and corrected, it is still quite refutable.
10:53:34 <beelsebob> (/=)
10:53:36 <monochrom> (\Just x -> x) is pretty strict.
10:53:36 <HugoDaniel_> okey, thanks :D
10:53:56 <ddarius> (Well, technically it's a type error)
10:54:53 <monochrom> > (\ ~(Just x) -> x) undefined `seq` "hello"
10:54:54 <lambdabot>   "* Exception: Prelude.undefined
10:55:08 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3056#a3056 <- new try, i renamed to mymath so no collision with the standard math.h
10:55:09 <monochrom> Oh ha
10:55:23 <monochrom> > (\ ~(Just x) -> 0) undefined `seq` "hello"
10:55:24 <lambdabot>   "hello"
10:55:30 <monochrom> > (\ (Just x) -> 0) undefined `seq` "hello"
10:55:32 <lambdabot>   "* Exception: Prelude.undefined
10:55:49 <FunctorSalad> maybe I'm misunderstanding the meaning of "irrefutable pattern"
10:55:59 <ddarius> FunctorSalad: It's defined in the Report.
10:56:08 <FunctorSalad> I thought it is "if this pattern doesn't match, the result is undefined"
10:56:22 <FunctorSalad> (rather than being about lazyness)
10:56:37 <monochrom> See my examples above.
10:57:00 <FunctorSalad> monochrom: yep, I see how the version without ~ is stricter
10:57:42 <ddarius> FunctorSalad: No, it's not.
10:57:56 <ddarius> Or sorry, misread.
10:58:01 <vixey> esp. wondering if people have encountered my way of dealing with time before
10:58:09 <jedai> Phyx-: Even then I don't really see the sense ? Getting the r in the monad (with ask) makes sense, getting it out of the monad don't : you obviously already have it since you must feed it to the "runReader" function to start the evaluation
10:58:50 <ddarius> jedai: You can use local, to locally change it.
10:58:54 <rovar> how would I retrieve the 3rd item from a 3 item tuple?
10:59:07 <ddarius> rovar: Pattern matching.
10:59:34 <rovar> blarg
11:00:06 <rovar> thanks :)
11:01:02 <monochrom> Althougth ~ postpones things, note that (\ ~(Just x) -> x) does not postpone things for very long.
11:01:14 <rovar> let third (a, b, c) = c
11:01:19 <FunctorSalad> hmm... do I need the ~ in "g ~x = ..." too or is that redundant? (if g is non-strict)
11:01:22 <Mr_Giraffe> :t ~
11:01:23 <lambdabot> parse error (possibly incorrect indentation)
11:01:26 <Mr_Giraffe> :t (~)
11:01:27 <lambdabot> parse error on input `)'
11:01:28 * Baughn wonders how confusing "StateT State IO ()" is
11:01:29 <rovar> i wonder if there is a way to generalize this.. probably with TH
11:01:30 <vixey> nobody is gonna look at my program I guess
11:01:30 <Mr_Giraffe> hrm
11:01:31 <monochrom> That one is redundant.
11:01:38 <vixey> rovar: no need to generalize it
11:02:08 <beelsebob> rovar: 1) use only pairs 2) third is a bad name, because it's indicative of first and second, not fst and snd
11:02:20 <monochrom> variables themselves don't cause forcing unless you ! them. constructors cause forcing unless you ~ them.
11:02:49 <Gracenotes> @. djinn type uncurry
11:02:50 <lambdabot> f a (b, c) = a b c
11:03:51 <monochrom> And so there seems to be a nice duality between ! and ~, between forcing and not forcing.
11:04:00 <ddarius> djinn's naive view of the world
11:04:02 <ddarius> @src uncurry
11:04:02 <lambdabot> uncurry f p = f (fst p) (snd p)
11:04:18 <ddarius> = uncurry f ~(a,b) = f a b
11:04:19 <monochrom> The duality breaks because of the 2nd law of thermodynamics. If you force something, it cannot go back to unforced.
11:05:24 <Baughn> monochrom: That is /not/ what the 2nd law of thermodynamics says
11:05:29 <monochrom> hehe
11:05:43 * Baughn would also like to point out reversible computing
11:05:56 <Baughn> (Which takes advantage of that crack in the "law")
11:06:07 <vixey> reversible computing is really sick
11:06:11 <monochrom> a forced thunk has higher entropy than an unforced thunk
11:06:19 <ddarius> Reversible computing is a bunch of garbage.
11:06:20 <Baughn> vixey: You mean slick, I hope
11:06:21 <vixey> I cannot imagine the kind of person which invented that
11:06:41 <vixey> Imagine if you invented reversible computing
11:06:52 <rovar> beelsebob: so I should name it thrd?  :)
11:06:52 <Baughn> ddarius: And if you know exactly where the garbage is, you can put the egg back together
11:06:59 <Baughn> vixey: I did. :P
11:07:02 <beelsebob> something like that, yeh
11:07:03 <Baughn> vixey: The principle is really simple
11:07:43 <monochrom> In physical reality, reversible computing is not very reversible.
11:07:52 <rovar> i changed the tuple to (a, (b,c))  only because it actually makes sense in this context
11:07:53 <Baughn> vixey: Entropy is a measure of what you don't know about the system... that's the /definition/. Reversible computing means you don't discard information, and so the entropy becomes zero.
11:07:55 <Philonous> "I uncomputed the solution, so now they have to work twelve more month on it."
11:08:03 <jedai> monochrom: Why ? It seems the forced thunk has the same amount of information as the unforced one (as long as there's no side-effect) so the same amount of entropy, no ?
11:08:07 <Baughn> monochrom: Well, it takes the same degree of isolation as quantum computing
11:08:14 <vixey> I know a bit about the theory
11:08:27 <vixey> I'm just talking about the genesis
11:08:30 <Baughn> jedai: No, the forced thunk discards the information used to make it
11:08:33 <Baughn> jedai: Think of folds
11:08:33 <Philonous> jedai: A forced thunk doesn't tell you how you acquired the solution.
11:08:43 <vixey> like the guy that invented DNA was on LSD apparently
11:08:48 <edwardk> hrmm what is the right way to package up quickcheck properties into a module but not export them?
11:08:50 <vixey> what about the guy that invented reversible computing?
11:08:58 <Baughn> monochrom: The difference is, if you leak a little information, that just means using more power - not that it fails to work entirely
11:09:04 <edwardk> so that the -Wall doesn't yell at me ;)
11:09:17 <Baughn> monochrom: So reversible computing should be perfectly workable, with sufficiently good manufacturing techniques
11:09:34 <p_l> "You can't unscramble an egg" "You can if you're powerful enough" :D
11:09:36 <jmcarthur> conal: did you ever think about anything sort of like this (not fully thought through): Event = Behavior (Time -> [a]), where (behavior `at` t') t returns a list of values that occurred on the interval (t, t')? it seems space inefficient since it probably holds on to all events, but maybe could be tweaked.
11:09:41 <Baughn> vixey: Oh, he was on DSL
11:09:50 <jmcarthur> conal: also implies the events don't have specific times. do they need it?
11:09:57 <vixey> in reversible computing a sorting algorithm takes not only an array to sort but it also takes the unit permutation
11:10:08 <vixey> once you sorted the list you get a undo permutation
11:10:21 <vixey> uncalling sort with a scambled permutation gives you back the unsorted list
11:11:06 <monochrom> You people are speaking like the only thing a computer does is mutate variables. In physical reality a computer spends electricity too. Can you tell the computer to give back electricity?
11:11:06 <Baughn> vixey: Of course you /can/ discard data, it just costs energy. The main idea is to carefully undo intermediate states and only discard the initial one.
11:11:13 <Baughn> monochrom: Yes.
11:11:31 <conal> jmcarthur: no, i didn't think of that one.
11:11:49 <vixey> It's such a tremendously bizarre concept
11:11:55 <monochrom> It is the same stupidity as throwing around denotational semantics without remembering there are timing issues and memory usage issues.
11:11:58 <jrx> is there in prelude some function with signature: [a -> a] -> a -> [a], returning list of values of consecutive applications of functions from given list to the input?
11:11:59 <Baughn> monochrom: At a fundamental level, the laws of physics are reversible. The second law of thermodynamics is a *statistical* law; the odds are vastly stacked against eggs unscrambling themselves, but /you can arrange for it to happen anyway/.
11:12:14 <jmcarthur> :t scanl
11:12:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
11:12:23 <Baughn> It's just not going to happen by accident
11:12:27 <vixey> I wonder what all the compression algorithms are that have been programmed in a reversible language
11:12:27 <vixey> jmcarthur,,
11:12:38 <jmcarthur> :t scanl ($)
11:12:39 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
11:12:39 <lambdabot>     Probable cause: `$' is applied to too many arguments
11:12:39 <lambdabot>     In the first argument of `scanl', namely `($)'
11:12:42 <jmcarthur> or something
11:12:47 <Baughn> vixey: No real point in reversible languages when you don't have reversible circuits
11:12:53 <jrx> jmcarthur: could you give me some clue how to use scanl in that context?
11:13:05 <jrx> jmcarthur: I can't see that, at the moment
11:13:11 <vixey> Baughn: you can study the theory without having the hardware, nothing wrong with that
11:13:31 <vixey> higher level theory
11:13:32 <Baughn> vixey: Hmm. It also occurs to me that, in a perfectly isolated reversible computer, the notion of "time" would lose its meaning
11:13:44 <Baughn> vixey: It's defined by the gradient of entropy, after all
11:13:55 <monochrom> Theories are invented not discovered. You can invent any theory you like to draw any conclusion you like.
11:14:15 <vixey> Baughn: I don't have that definition of time
11:14:21 <jmcarthur> :t scanl . flip ($)
11:14:22 <lambdabot>     Occurs check: cannot construct the infinite type: b = b1 -> a -> b
11:14:22 <lambdabot>     Probable cause: `flip' is applied to too many arguments
11:14:22 <lambdabot>     In the second argument of `(.)', namely `flip ($)'
11:14:26 <jmcarthur> :t scanl $ flip ($)
11:14:27 <lambdabot> forall b. b -> [b -> b] -> [b]
11:15:11 <jmcarthur> > let foo = scanl (flip ($)) in foo 0 [(+1), (+2), (+3)]
11:15:12 <lambdabot>   [0,1,3,6]
11:15:51 <jmcarthur> jrx: ^^?
11:15:53 <jrx> looks great, thaks !!
11:16:26 <Baughn> vixey: But the laws of physics do. :P
11:16:44 * wli breathes a sigh of relief as he finally succeeds in downgrading to 6.8.3
11:16:56 <ehird> wli: why would you do that?
11:16:56 <vixey> I always forget which way entropy goes
11:17:06 <Baughn> vixey: As I mentioned, they're reversible. Time is an emergent phenomenon, a consequence of the big bang apparently randomly being extremely low-entropy, thus constraining causality to work one way only
11:17:08 <ddarius> entropy always increases
11:17:31 <vixey> what are you saying
11:17:43 <vixey> physics is reversible
11:17:46 <jrx> any time I need something it appears that it has already been invented in Prelude, I think it won't stop amusing me
11:17:50 <jmcarthur> conal: any thoughts, or are you busy?
11:18:02 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3056#a3056 <- new try, i renamed to mymath so no collision with the standard math.h
11:18:02 <edwardk> conal: is there any chance of updating
11:18:06 <Baughn> vixey: The universe is exceedingly unbalanced. Entropy always increases, because any random change is overwhelmingly likely to increase entropy
11:18:06 <edwardk> er
11:18:18 <edwardk> conal: is there any chance of updating 'checkers' to QuickCheck 2.1 or so?
11:18:19 <vixey> @w80 entropy
11:18:23 <lambdabot> *** "entropy" wn "WordNet (r) 2.0"
11:18:23 <lambdabot> entropy
11:18:23 <lambdabot>      n 1: (communication theory) a numerical measure of the
11:18:23 <lambdabot>           uncertainty of an outcome; "the signal contained
11:18:23 <lambdabot>           thousands of bits of information" [syn: {information}, {selective
11:18:24 <lambdabot> [6 @more lines]
11:18:36 <vixey> I thought entropy goes down
11:18:45 <Baughn> Only if you look backwards in time
11:18:47 <ehird> entropy always increases; everyone knows that
11:18:47 <wli> ehird: Because I don't have long enough left in my computing career to learn a new set of command-line editing keybindings.
11:18:58 <ehird> that's like the most catchphrasy catchphrase ever to physics.
11:18:59 <Mr_Giraffe> ehird: not quite, entropy just never decreases
11:19:05 <edwardk> energy does, entropy is loss of useful energy
11:19:06 <conal> edwardk: oh, sure.  i haven't tried a more recent QC.  do you like it?
11:19:08 <ehird> wli: huh?
11:19:47 <kadaver> so no FFI gurus in here?
11:19:51 <edwardk> conal: i just figured it was a good practice for me to start from the most recent version ;) i think arbitrary/coarbitrary split, but i can't see any other huge differences
11:19:58 <wli> ehird: Of the command-line editing libraries, only readline supports vi keybindings at all.
11:20:11 <ehird> oh
11:20:12 <Baughn> vixey: http://www.overcomingbias.com/2008/02/second-law.html <-- Here, have an article
11:20:16 <ehird> wli: just run it under rlwrap
11:20:16 <vixey> I think editline supporst vi bindings
11:20:16 <mauke> kadaver: welcome to case insensitive filesystems
11:20:28 <edwardk> conal: i'm tempted to go through and add a ton of model checkers for the Generator instances I have
11:20:38 <vixey> nah Baughn I'd read a book on it but blog articles about stuff I don't know is dangerous
11:20:44 <mauke> wli: there's a pretty simple patch to build 6.10 against readline
11:20:54 <edwardk> now that it works i want to prove to myself why it works ;)
11:20:57 <ddarius> vixey: Read "The Road to Reality"
11:21:01 <conal> jmcarthur: off-hand i don't know how that event model would work out.  sounds promising enough to explore.  and exploring would lead to more insight & alternatives.  snapshot does rely on specific times.
11:21:07 <Baughn> vixey: I suppose. Well, if you wait a year or two there'll be a book with that article in it.
11:21:10 <Baughn> More or less
11:21:21 <conal> edwardk: is shrinking in there yet?
11:21:28 <edwardk> yeah
11:21:32 <edwardk> its in arbitrary
11:21:33 <conal> cool :)
11:21:45 <jmcarthur> conal: yeah before you typed that up i thought maybe i should have just left quiet until i had some more details worked out
11:22:04 <jmcarthur> was going to say "nevermind"
11:22:05 <edwardk> i went add added shrink cases to my stolen variant of your AddBounds, which is what started me down this road
11:22:09 <conal> jmcarthur: it's all good. :)
11:22:23 <conal> jmcarthur: i do like the idea.
11:22:39 <monochrom> Stephen Hawking writes "by reading this book you increase universal entropy by such and such amount. I suggest you stop reading now." :)
11:23:01 <vixey> do any of you FRP people want to comment about my code ?
11:23:07 <wli> mauke: Gento's package for 6.10.1 already has the patch. For whatever reason ghci in 6.10.1 is not actually using readline. So it's a doorstop, and I'll stay on 6.8.3 until I either stop using Haskell (e.g. because no extant compilers and interpreters support vi keybindings) or some ebuild appears that actually works.
11:23:18 <kadaver> mauke: if it is caseinsensitive then what does it matter?
11:23:26 <ddarius> Non-equilibrium thermodynamics is where it's at anyway.
11:23:31 <conal> vixey: have you posted it?
11:23:44 <vixey> yes http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2003#a2003
11:23:52 <vixey> it uses GLUT and OpenGL
11:24:04 <vixey> the only interesting bit of the code is the Animation section
11:24:14 <ehird> er
11:24:19 <mauke> kadaver: guess.
11:24:19 <ehird> do you need to define xor yourself?
11:24:19 <vixey> potentially frp bit of the code
11:24:51 <ddarius> xor = (/=)
11:25:10 <monochrom> @check \x y -> (x /= y) == (y /= x)
11:25:16 <lambdabot>   "OK, passed 500 tests."
11:25:42 <dolio> @check \x y -> (x /= y) == False
11:25:42 <monochrom> @check \x y z -> ((x /= y) /= z) == (x /= (y /= z))
11:25:45 <lambdabot>   "OK, passed 500 tests."
11:25:48 <lambdabot>   "OK, passed 500 tests."
11:25:54 <sundaymo1ning> why are you checking those things?
11:26:04 <sundaymo1ning> why wouldn't they be all true?
11:26:15 <monochrom> To push humanity one step closer to its demise.
11:26:25 <vixey> I don't understand this entroy stuff
11:26:28 <skorpan> word up
11:26:32 <vixey> is it real?
11:26:35 <skorpan> entroy?
11:26:38 <ehird> vixey: lol wut
11:26:43 <vixey> entropy
11:26:43 <ehird> "is entropy real?"
11:27:16 <vixey> entropy is obviously false by evolution
11:27:24 <dolio> Nope.
11:27:26 <ehird> are you trolling
11:27:26 <mauke> is pi real?
11:27:34 <monochrom> > pi
11:27:40 <kadaver> mymath.c and mymath.hs generates the same object file?
11:27:42 <monochrom> @type pi
11:27:48 <sundaymo1ning> vixey seems to be trolling
11:27:51 <mauke> kadaver: yes, very likely
11:27:53 <ddarius> mauke: Unless declared Int.
11:28:00 <monochrom> I have broken lambdabot
11:28:06 <mauke> kadaver: use more different names
11:28:08 <Deewiant> ?bot
11:28:12 <ehird> sundaymo1ning: Yes. Probably.
11:28:17 <Baughn> vixey: Did you seriously mean that question?
11:28:19 <monochrom> I have broken lambdabot. Is it real?
11:28:21 <Deewiant> , pi
11:28:24 <lunabot>  3.141592653589793
11:28:24 <vixey> sundaymo1ning: would prefer you didn't say things like that
11:28:45 <kadaver> !
11:29:00 <vixey> Baughn: can you really put a measure of entropy on the universe at every moment
11:29:08 <vixey> Baughn: and someone proved this is always decreasing
11:29:26 <sundaymorning> just in case you're not trolling, remember the sun :-P
11:29:34 <Baughn> vixey: *Increasing*.
11:29:39 <vixey> sundaymorning: just /ignore'ing you now
11:29:58 <Baughn> vixey: And sure you can. Or at least the parts we can see.
11:30:23 <vixey> 'parts we can see' reminds me of The Last Question
11:30:59 <ehird> cmon now
11:31:09 <lambdabot> forall a. (Floating a) => a
11:31:09 <lambdabot> :)
11:31:09 <lambdabot>   3.141592653589793
11:31:20 <dolio> You don't typically put a measure on the entropy of some system.
11:31:20 <ddarius> Perhaps this conversation should move to #haskell-blah
11:31:26 <monochrom> OK nice lambdabot is real.
11:31:41 <dolio> More commonly you measure the entropy change during some process.
11:32:41 * ddarius wonders what the net charge of the universe is.
11:33:16 <monochrom> . o O ( Don't touch another universe. We may all be zapped! )
11:33:24 * SamB discovers a "zip archive" in his ~/bin directory -- that actually runs
11:37:15 <vixey> I don't believe that entropy always increases, you can't prove this until you fully understand the brain
11:37:37 <monochrom> (\ ~(Just x) -> x) is still pretty strict because although the ~ tries to postpone, the x at the end forces it right away. All attempts at procrastination are confounded.
11:37:46 <vixey> if you assumed determism then I guess it makes sense
11:37:58 <SamB> vixey: I don't either, but I don't see why understanding the brain is involved
11:38:21 <SamB> well, I mean, maybe if you understood the brain you could disprove that entropy always increases ;-)
11:38:22 <vixey> SamB: Thinking of a new idea could be a decrease of entropy
11:38:31 <monochrom> @slurp
11:38:32 * lambdabot puts on her slapping gloves, and slaps
11:38:37 <monochrom> @slurp brain
11:38:37 * lambdabot secretly deletes brain's source code
11:38:38 <ehird> vixey: ;_;
11:38:41 <ehird> srsly.
11:38:59 <SamB> but I don't see how you could prove that it does just by understanding the brain ...
11:39:06 <kadaver> how about writing microcontroller DLSs in haskell?
11:39:29 <dons> kadaver: it's a good idea, and been done before
11:39:29 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:39:39 <kadaver> dons: links?
11:39:54 <dons> look at CUFP, e.g. Eaton's hydraulics microcontroller EDSL
11:40:01 <vixey> SamB: Prove or disprove
11:42:10 <monochrom> There is much misunderstanding around procastination and evaluation of thunks.
11:43:37 <vixey> it seems like godels theorem, valid in a very specific circumstance but may be vastly extrapolated because it's got some catchy philosophy behind it
11:44:15 <dons> mm. procrastination as an evaluation strategy
11:44:22 <dons> put off doing what you're actually demanded to do
11:44:28 <dons> while you eval some other thread
11:44:32 <monochrom> Heh that's just laziness but I like -tion words.
11:44:44 <dons> maybe it makes sense for parallel runtimes, but where there's some cost for context switching
11:45:09 <dons> no, procrastination is laziness where when you're asked to do something, you block, and do something else
11:45:10 <monochrom> Also we were talking about the ~ patterns and it is some kind of active procrastination.
11:46:28 <Gracenotes> dons: or perhaps used a coping mechanism for an inability to do somethin
11:46:30 <Gracenotes> g
11:46:38 <Gracenotes> self-handicapping, that is
11:46:55 <monochrom> Please don't self-handicap!
11:47:01 <Gracenotes> so if you're asked to do 12 `div` 0, you just twiddle some bits instead of throw an error to admit your shortcoming
11:47:15 <monochrom> eww. hahah ok
11:47:29 <monochrom> That's my supervisor's approach anyway.
11:47:32 <Gracenotes> yeah, self-handicapping in a psychological sense
11:47:50 <Gracenotes> "I don't put in any effort, I can blame my failure on lack of effort, not on lack of ability"
11:48:48 <__Ali__> what are the minimal runtime requirements when deploying to the end user?
11:48:56 <Gracenotes> taking drugs can be another form of self-handicapping, trying to hide a lack of ability. It can be symptotic of chronic procrastination. but... thank goodness Haskell doesn't do that.
11:50:42 <monochrom> I have a GHC-compiled program running on a 10yo laptop with 96MB RAM and 300MHz Celeron.
11:50:56 <monochrom> I think the program just takes 4MB.
11:51:03 <monochrom> I think the program just takes 4MB of RAM.
11:51:20 <Baughn> "modify (\st -> st{foo = bar}" <-- Is there a more concise way to say this?
11:51:34 <monochrom> No.
11:52:00 <TomMD> The free variable could be 's' instead of 'st'...
11:52:08 <trofi> :]
11:52:21 <Gracenotes> and all those spaces!!
11:52:34 <__Ali__> monochrom, i meant when you want to deploy a compiled program, does the user need to install anything? does the program have to come with some haskell shared libs?
11:52:55 <monochrom> Seems to me no other lib needed.
11:53:04 <Baughn> __Ali__: Haskell (ghc, anyway) does not yet /do/ shared libs
11:53:05 <trofi> external C libraries
11:53:07 <Baughn> So, no problem there
11:53:17 <monochrom> I just copied the executable to the old laptop.
11:53:24 <koeien> __Ali__: end user will need gmp probably
11:55:14 <__Ali__> koeien, gmp?
11:55:37 <koeien> __Ali__: on *nix
11:56:25 <__Ali__> is haskell any good on VMs? i saw an experimental project on haskell -> java bytecode, are there any mature ones around?
11:56:42 <monochrom> "libgmp3c2" on ubuntu
11:56:51 <__Ali__> monochrom, thanks!
11:57:44 <andrewsw> I'm trying to put to code the idea of expressing ax^2 as function composition where the result is a function that binds a value for a (coefficient) and returns a function that will evaluate ax^2.
11:58:18 <monochrom> \a -> \x -> a*x*x
11:58:23 <andrewsw> I keep getting infinite types and I know I just don't understand something
11:58:43 <andrewsw> monochrom: yes, but I want to be able compose arbitrary numbers of them to get ax, ax^3, etc
11:59:09 <TomMD> > (\a x -> a * (x ^ 2)) 2 3
11:59:10 <lambdabot>   18
11:59:27 <dolio> > x^2
11:59:29 <lambdabot>   x * x
12:00:25 <monochrom> You need a clearer, more specific description of your intention.
12:01:10 <andrewsw> I want to be able to say f(2) is equivalent to 2x, and f(f(2)) is equivalent to 2x^2 etc
12:01:13 <monochrom> Either that, or you should give a million examples.
12:01:26 <andrewsw> heh
12:01:45 <andrewsw> okay... f(f(f(2))) equiv to 2x^3
12:02:26 <Gracenotes> well, then the function is just (*x)
12:02:33 <andrewsw> hmmm...
12:02:43 <monochrom> I feel that such a function does not exist.
12:02:47 <__Ali__> is there any ghc 6.10 ubuntu package better than this solution: http://www.kuliniewicz.org/blog/archives/2009/03/24/installing-ghc-610-on-ubuntu-intrepid/
12:02:51 <Gracenotes> you can't go from 2x^2 to 2x^3 without knowing the x
12:02:54 <Gracenotes> in general
12:03:18 <ski> > f(f(f(2))) where f(a) = a*x
12:03:19 <lambdabot>   2 * x * x * x
12:03:48 <ski> > f(f(f(2))) where f(a) = a*x; x = 10
12:03:49 <lambdabot>   2000
12:03:51 <monochrom> Gracenotes: He means f(2) = \x -> 2*x, f(f(2)) = \x -> 2*x*x
12:04:10 <andrewsw> okay, that's what I'm not expressing. I want x to be a free variable throughout so the result of f(f(...(2)))) is a function in x s.t. I can supply values for x and get 2x^n
12:04:16 <andrewsw> monochrom: yes, I think so.
12:04:21 <monochrom> But such a function cannot exist.
12:04:28 <mauke> I don't see why not
12:04:38 <ski> if `x' is a free variable, then you can't supply values for it (it already has some value)
12:04:43 <mauke> f a = \x -> a * x
12:05:04 <monochrom> From the example f(2) = \x -> 2*x, you can generalize to f a = \x -> a*x, or f = \a x -> a*x, or f a x = a*x.
12:05:08 <mauke> oh wait, a needs to be a function
12:05:18 <Gracenotes> > f(f(2)) n where f a = \x -> a * x
12:05:19 <lambdabot>   Couldn't match expected type `t -> t' against inferred type `Expr'
12:05:20 <monochrom> Then f(f(2)) = f( \x -> 2*x ) = huh?
12:05:20 <Botje> ski: GHC _does_ supports dynamic scoping ;)
12:05:26 <andrewsw> mauke: that's what I thought
12:05:40 <mauke> f a = \x -> a x * x
12:05:46 <ski> (however, you could bind `x' further out, and then supply a value, at that level)
12:05:54 <Gracenotes> you've already bound x to 2*x in one application of f
12:05:57 <dolio> let two = const 2 ; f g x = g x * x in (f two x, f (f two) x, f (f (f two)) x)
12:06:03 <dolio> > let two = const 2 ; f g x = g x * x in (f two x, f (f two) x, f (f (f two)) x)
12:06:05 <lambdabot>   (2 * x,2 * x * x,2 * x * x * x)
12:06:05 <monochrom> Tell me how to write a function that works consistently for both numbers and functions.
12:06:23 <mauke> monochrom: instance (Num a) => Num (e -> a)
12:06:39 <monochrom> That's some kind of abuse IMO.
12:07:36 <andrewsw> dolio: I think that might be what I'm after
12:09:02 <dolio> > let two = const 2 ; (f * g) x = f x P.* g x ; x = id ; f = (* x) in (two x, f two x, f (f two) x, f (f (f two)) x)
12:09:03 <lambdabot>       Failed to load interface for `P':
12:09:03 <lambdabot>        Use -v to see a list of the fi...
12:11:53 <jeffwheeler> It seems that GHC 6.8.2 is still bundled with Ubuntu+1 (Jaunty), but I bet it's too late to change that. :-/
12:12:04 * osfameron is prototyping a web-based board-game in haskell, but the final game will be in Javascript.  I'm debating yhc->javascript, versus http://w3future.com/weblog/stories/2008/06/16/adtinjs.xml versus rewriting in idiomatic javascript...
12:12:26 <andrewsw> dolio: perfect, that's got what I need
12:12:34 <osfameron> also, I suppose I'd have to debate whether to have the game backend server written in Haskell, Perl (my comfort zone) or Javascript again...
12:14:40 <dolio> > let two = const 2 ; (f * g) x = f x Prelude.* g x ; x = id ; f = (* x) in (two y, f two y, f (f two) y, f (f (f two)) y)
12:14:42 <lambdabot>   (2,2 * y,2 * y * y,2 * y * y * y)
12:18:41 <Gracenotes> instance (Num a) -> Num (Monad m) where (+) = liftM2 (+); (*) = liftM2 (*); (-) = liftM2 (-); negate = liftM negate; abs = liftM abs; signum = liftM signum; fromInteger = return . fromInteger
12:18:44 <dolio> > map ($x) $ iterate (flip (liftM2 (*)) id) (return 2)
12:18:45 <lambdabot>   [2,2 * x,2 * x * x,2 * x * x * x,2 * x * x * x * x,2 * x * x * x * x * x,2 ...
12:19:01 <Gracenotes> for the function monad particularly
12:20:26 <inimino> osfameron: write JavaScript for the client, and Haskell or Perl on the server
12:20:39 <sundaymorning> osfameron: how do you write a server in javascript
12:21:21 <inimino> sundaymorning: there are server-side JavaScript interpreters e.g. Rhino
12:21:30 <sundaymorning> hm
12:22:31 <osfameron> yeah, or the Google Apps Engine, and others
12:22:57 <osfameron> the company I used to work for tried to write a Javascript app server, then imploded spectacularly when the parent company pulled the plug on it
12:23:36 <inimino> I thought Google Apps Engine only supported Python
12:23:47 <inimino> anyway bbiab
12:23:54 <osfameron> hmmm
12:24:26 <skorpan> \x -> x `sepBy` y
12:24:32 <skorpan> @pl \x -> x `sepBy` y
12:24:32 <lambdabot> (`sepBy` y)
12:24:33 <osfameron> ah yeah, Python for now.  my smistake
12:24:41 <osfameron> there are projects to get Perl and other langugaes supported on it too
12:25:01 <osfameron> in any case, there *are* server side javascript apps, lemme check my bookmarks...
12:26:47 <osfameron> hmmm, nothing in my delicious, but http://en.wikipedia.org/wiki/Server-side_JavaScript has links
12:26:57 <__Ali__> i wonder why there is no swig extension for haskell? is ffi _that_ automated that we dont need swig to wrap c/c++ code to haskell?
12:27:27 <paczesiowa> __Ali__: there are other wrappers for C I think (hsc2hs or smth like that)
12:27:42 <paczesiowa> wrapper generators
12:28:02 <osfameron> inimino: ideally I'd prototype in haskell and be able to reuse the code on client side... that's why I was thinking about Yhc, which has a javascript backend.
12:28:16 <__Ali__> paczesiowa, i guess they're not better than what JNI is for java, they don't do automation do they?
12:30:23 <paczesiowa> __Ali__: no idea, sorry
12:37:32 <dons> @tell mmorrow http://galois.com/~dons/tmp/nodeids.dpatch
12:37:32 <lambdabot> Consider it noted.
12:41:51 <patch-tag> When I am inside ghci, inside emacs, I get special character ^J
12:42:02 <patch-tag> it seems to happen intermittently. tried with both ansi-colo-comint-mode-on and off
12:42:06 <patch-tag> happens either way.
12:42:13 <patch-tag> any idea how to switch this off?
12:43:09 <bremner> patch-tag: try (add-hook 'haskell-mode-hook  '(lambda () (setq process-connection-type nil)))
12:45:04 <patch-tag> nope. didn't work. thanks anyways.
12:46:33 <bremner> patch-tag: to be pedantic, you restarted emacs, right?
12:46:51 <patch-tag> bremner: yes, edited .emacs, quit, restarted emacs.
12:48:07 <bremner> just checking... it is not always safe to assume.. Anyway, there is web page somewhere with various solutions; try googling with my suggestion?
12:48:25 <patch-tag> i'll do that.
12:49:34 <paczesiowa> speaking of ghci inside emacs, is it possible to use tab-completion there?
12:51:41 <trofi> @hoogle ReadE
12:51:41 <lambdabot> module Distribution.ReadE
12:51:42 <lambdabot> Distribution.ReadE newtype ReadE a
12:51:42 <lambdabot> Distribution.ReadE ReadE :: String -> Either ErrorMsg a -> ReadE a
12:53:27 <Eelis> in a Setup.hs, what's the difference between defaultUserHooks and autoconfUserHooks, other than that the former is deprecated while the latter appears to be undocumented?
12:55:46 <patch-tag> bremner: damndest thing, it appears to be working now... and I commented out the process-connection-type nil hook
12:56:09 <patch-tag> and it still works;
12:56:20 <inimino> osfameron: it's been about a year since I looked at YHC's JavaScript output, but at that time using it in production wasn't something I'd seriously consider
12:56:48 <osfameron> inimino: interesting!  any specific concerns?
12:56:56 <patch-tag> now I can't reproduce the problem.
12:57:20 <inimino> osfameron: bloat, speed
12:58:28 <patch-tag> ok, now I can reproduce the problem. ghci, then load a file (or ghci file.hs), has the special chars. Just ghci, and don't load a file, doesn't have the problem.
13:01:31 <osfameron> inimino: ah, fair enough.  Though to be fair, for my purposes, not having to write the code might still make that a win :-)  (i.e., I'd be more worried by bugginess/not really working)
13:02:44 <inimino> osfameron: well, you can use something like jQuery and it's pretty easy
13:03:09 <Phyx-> grrr. I have a big problem with gtk2hs, changing anything in the gui from within an event crashes it
13:03:40 <Phyx-> lordy, now that's a netsplit
13:04:13 <Phyx-> anyone here use gtk2hs? i keep running into this error
13:04:14 <Phyx-> Client: schedule: re-entered unsafely.
13:05:19 <patch-tag> ok, this is really bizarre now. emacs, with a .hs file (any .hs file, not necessarily the same one loaded in ghci), doesn't have the ^J issue. If you don't have a haskell file loaded, you get the ^Js.
13:05:53 <shapr> patch-tag: eh?
13:06:02 <patch-tag> yep.
13:06:20 <patch-tag> whether or not I have a .hs file loaded in another window affects the behavior of ghci in emacs.
13:06:22 <Phyx-> i think he meant eh, as in he doesn't get what you mean?
13:07:04 <patch-tag> shapr: a while back in irc bremner gave me advice on how to get ghci woring in emacs.
13:07:16 <patch-tag> it was a continuation of that conversation
13:07:33 <shapr> ah
13:07:55 <ehird> patch-tag: using inferior-haskell.el?
13:07:57 <ehird> if not do so :-)
13:08:28 <bremner> patch-tag: err, maybe the hook I gave is only run if you have a .hs file loaded?
13:08:31 <patch-tag> no, (load "$SHELLENV/emacshome/haskell-mode-2.4/haskell-site-file.el")
13:08:41 <patch-tag> so, inferior-haskell is said to be better?
13:08:50 <ehird> patch-tag: you are starting with M-x run-haskell?
13:08:59 <ehird> or c-c c-l in a haskell file? if so, that's inferior haskell
13:09:28 <osfameron> inimino: yeah, I'm definitely planning to use jQuery for the display stuff.  It's just the scoring/business rules... I was finding them a pain to prototype in Javascript, and haskell seemed "easier" ;-)
13:09:49 <patch-tag> ehird: no, wasn't doing that.
13:09:55 <ehird> patch-tag: try it
13:10:01 <ehird> it's much better than using it from an emacs shell
13:10:08 <ehird> and integrates with haskell-mode
13:10:10 <bremner> patch-tag: can you check the variable process-connection-type in a "bad" buffer
13:10:20 <inimino> osfameron: ok, well try the ##javascript channel if you get stuck ;-)
13:10:44 <ehird> bremner: what's the advantage over inferior-haskell? Sounds like a huge fuss.
13:10:54 <patch-tag> bremner: I believe your diagnosis that the hook you gave only works when a haskell file is open is correct.
13:11:04 <patch-tag> when I comment out that hook, the behavior is broken all the time.
13:11:25 <bremner> ehird: pardon? advantage of what?
13:11:34 <ehird> bremner: the ghci in emacs solution you seem to be advocating
13:12:35 <patch-tag> bremner: how do I check the value of an emacs variable?
13:12:41 <bremner> ehird: I'm not advocating anything. I use inferior-haskell.  I assumed patch-tag was too.
13:12:45 <younder> ehird: To interactivly be able to test code as you write it. And to test ideas before incorporating them into your program
13:12:55 <ehird> younder: err, that's what inferior-haskell does
13:12:57 <ehird> runs ghci
13:13:06 <ehird> bremner: ok, he seemed to say he wasn't
13:13:13 <ehird> since he said it wasn't via run-haskell or c-c c-l
13:13:24 <bremner> ehird: yah, mass confusion
13:13:24 <patch-tag> bremner: that hook you gave is close-enough-to-works-for-me that I am going to say it works for me.
13:13:38 <bremner> patch-tag: use inferior-haskell
13:13:39 <patch-tag> I just need to remember to have a haskell file open at the same time.
13:13:54 <ehird> inferior haskell is superior :-D
13:14:02 <patch-tag> bremner: I guess using inferior hasell amounts to what I just said.
13:14:19 <ehird> err how
13:14:24 <bremner> patch-tag: well M-x run-haskell doesn't need a file
13:14:31 <patch-tag> since c-c c-l assumes you already have a haskell file open
13:14:33 <ehird> wow this is confusing.
13:14:45 <ehird> patch-tag: inferior-haskell is better in other ways too
13:15:29 <vixey> is ^J a newline marker
13:15:49 <sioraiocht> vixey: not usually
13:15:57 <vixey> ok
13:15:59 <patch-tag> vixey: it is in emacs.
13:17:01 <patch-tag> at least, when you are in search mode, c-q c-j matches newlines
13:17:19 <patch-tag> don't know if that is the same as the ^J I encountered in ghci, I assumed so though.
13:17:24 <mauke> ^J == \n
13:21:19 <Flugan> is there there any variant of read that has the type :: Read a => String -> Maybe a
13:21:38 <mauke> :t listToMaybe . reads
13:21:40 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
13:21:47 <patch-tag> Flugan: maybe in Safe on hackage
13:21:53 <Deewiant> Safe has it
13:22:09 <roconnor> aww  http://www.reddit.com/r/functional/ has no love
13:23:07 <Flugan> can you link?
13:23:31 <Deewiant> ?hackage Safe
13:23:32 <vixey> oh my how man reddits are there
13:23:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Safe
13:23:39 <vixey> http://www.reddit.com/r/squiggol/
13:23:54 <vixey> http://www.reddit.com/r/types/ is good
13:23:57 <gwern> functional reddit? that's a waste of time, should redirect to the haskell reddit
13:24:03 * vixey doesn't know any others
13:24:47 <patch-tag> can someone clue me in on Text.XHtml tasbles? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3061#a3061
13:24:55 <gwern> and squiggol? wth, isn't squiggol a dead paper-language?
13:24:57 <ehird> dons: http://www.reddit.com/r/programming/comments/88ad7/bitescript_001_a_ruby_dsl_for_jvm_bytecode/c08jbm9 << how is this comment relevant
13:24:58 <ehird> ?
13:25:04 <vixey> squiggol is awesome
13:25:05 <ehird> gwern: woah, squiggol
13:25:07 <patch-tag> Is that even valid html getting outputted? Where are the td tags?
13:25:08 <vixey> that's what it is!
13:25:32 <gwern> ehird: I think it's a 'haskell too!' comment
13:25:44 <ehird> gwern: but that makes no sense, javascript != java, anybody knows that
13:25:51 <ehird> and jvm!=java
13:26:03 <gwern> ehird: HE'S TRYING ALRIGHT
13:26:11 <ehird> gwern: …wut
13:26:23 <gwern> one goes to war with the hackage one has, not the one one would like
13:26:30 <Flugan> Thank you
13:26:37 <dons> ehird: yikes. oops
13:26:40 <ehird> dons: :-D
13:26:40 <dons> dont' post before coffee :)
13:27:02 <dons> gone.
13:27:16 <ehird> Disproved: "coffee :: Mathematician -> [Theorem]". Proved: "coffee :: Haskeller -> Coherency".
13:27:19 * dons goes back to playing with vacuum/cairo
13:27:25 <ehird> Somebody call up stephen wolfram!
13:27:54 <gwern> dons: I noticed that the vacuum graphs, at the nodes, didn't seem to show the actual value at the node, but some sort of counter?
13:28:15 <dons> right.
13:28:22 <lament> i thought it was mathematician :: Coffee -> [Theorem]
13:28:33 <dons> getting quite pretty graphs now http://galois.com/~dons/images/map.png
13:28:39 <gwern> dons: is the author going to improve on that?
13:28:44 <dons> gwern: i'm trying to fix that: basically, nodes need to be unique
13:28:50 <dons> but those unique ids are being rendered
13:28:56 <dons> we just want them for laying out the graph though
13:29:04 <gwern> hm. maybe you could do a tuple and discard the id when showing?
13:29:34 <dons> hmm. could actually modify the SVG xml directly
13:29:41 <dons> but i think there might be a better way
13:30:11 <arjanb> doesn't dot support seperate ids and labels?
13:30:14 <dons> i think so.
13:30:18 <dons> i'm working through the manual :)
13:30:58 <dons> i think there's also a killer app here using the symbolic package
13:31:14 <dons> , foldr (+) 0 [1..10]
13:31:15 <lunabot>  55
13:31:23 <dons> what's the AST displaying command?
13:31:28 <dons> ,, foldr (+) 0 [1..10]
13:31:28 <gwern> symbolic? the simple expr stuff?
13:31:29 <lunabot>  luna: parse error on input `foldr'
13:31:31 <dons> yeah
13:31:34 <dons> then show the AST graph
13:31:37 <dons> bam.
13:31:44 <gwern> > foldr (x) 0 [1..10] -- maybe
13:31:45 <lambdabot>   Couldn't match expected type `a -> b -> b'
13:31:52 <dons> oh right
13:32:06 <gwern> hm. it's been a while since I tried to do it. had something to do with using a dummy undefiend variable...
13:32:07 <dons> ,, foldr (+) 0 [a..z]
13:32:08 <lunabot>  luna: parse error on input `foldr'
13:32:12 <dons> , foldr (+) 0 [a..z]
13:32:15 <lunabot>  luna: not a number
13:32:20 <dons> > foldr (+) 0 [a..z]
13:32:21 <gwern> > foldr (+) 0 [a..z]
13:32:23 <lambdabot>   * Exception: not a number
13:32:23 <lambdabot>   * Exception: not a number
13:32:25 <dons> heh
13:32:27 <dons> ok. ok
13:32:38 * gwern goes to look up lennart's blog posts on this
13:32:50 <dons> find out the package, and i'll add it to the cairo frontend
13:32:53 <dons> viewAST $ ...
13:33:00 <dons> though TH should work...
13:33:01 <dons> hmm
13:33:04 <dons> mmm
13:33:10 <gwern> > sum [1..5] :: Expr
13:33:12 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
13:33:16 <gwern> there we go
13:33:24 <c_wraith> :t sum
13:33:24 <gwern> dons: it's called simple-reflect on hackage iir
13:33:25 <lambdabot> forall a. (Num a) => [a] -> a
13:33:48 <dons> hmm. doesn't see into ExpQ nodes
13:33:53 <dons> gwern: ok.
13:33:59 <gwern> http://augustss.blogspot.com/2008_03_01_archive.html
13:34:04 <gwern> > x+y
13:34:05 <lambdabot>   x + y
13:34:15 <ehird> 21:28 lament: i thought it was mathematician :: Coffee -> [Theorem]
13:34:16 <ehird> so it is
13:34:18 <gwern> > foldr f z [1,2,3]
13:34:20 <lambdabot>   f 1 (f 2 (f 3 z))
13:34:37 <dons> this should work:   view [| 1 + 2 |]
13:34:50 <gwern> > \ x -> x + y
13:34:52 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
13:34:52 <lambdabot>        arising from a use...
13:35:07 <gwern> hm. that's interesting. thought that was supposed to work
13:35:23 <gwern> > scanr (.) id [(*2),f::Expr->Expr,(+1)]
13:35:25 <lambdabot>       Overlapping instances for Show (Expr -> Expr)
13:35:25 <lambdabot>        arising from a use...
13:35:53 <gwern> that was supposed to yield '[\ x1 -> f (x1 + 1) * 2,\ x1 -> f (x1 + 1),\ x1 -> x1 + 1,\ x1 -> x1]'
13:36:03 <gwern> oh well
13:36:33 <ehird> > uncurry f
13:36:34 <lambdabot>       Overlapping instances for Show ((a, b) -> c)
13:36:35 <lambdabot>        arising from a use ...
13:36:39 <ehird> :\
13:36:44 <ehird> > uncurry f :: (Expr,Expr)->Expr
13:36:46 <lambdabot>       Overlapping instances for Show ((Expr, Expr) -> Expr)
13:36:46 <lambdabot>        arising fr...
13:36:49 <ehird> f
13:37:56 <dons> the benefit of this library approach is that view things like TH or ghci debugger variables..
13:39:33 <Phyx-> Baughn, i seem to have lost the link you gave me about gtk's thread safetyness, do you still have it?
13:39:54 <sundaymorning> just read a bit about arrow category, there are stuff in haskell that are just way over my head.
13:41:05 <vixey> sundaymorning: You'll find that happening a lot
13:41:22 <sundaymorning> yeah, I already do :P
13:41:31 <Phyx-> lol
13:41:40 <sundaymorning> there are a few years that I'm a casual haskell programmer
13:42:03 <Baughn> Phyx-: http://research.operationaldynamics.com/blogs/andrew/software/gnome-desktop/gtk-thread-awareness.html
13:42:03 <Gracenotes> > scanr (.) id [(*2),f::Expr->Expr,(+1)] <*> pure g -- gwern
13:42:04 <lambdabot>       Ambiguous occurrence `pure'
13:42:05 <lambdabot>      It could refer to either `Control.Appl...
13:42:08 <Gracenotes> :/
13:42:13 <Gracenotes> > scanr (.) id [(*2),f::Expr->Expr,(+1)] <*> [g]
13:42:14 <Phyx-> Baughn, many thanks
13:42:14 <lambdabot>   [f (g + 1) * 2,f (g + 1),g + 1,g]
13:42:15 <Phyx-> :)
13:42:16 <sundaymorning> everytime I get some articles to read I see that there are stuff that I can't even grasp.
13:42:24 <Gracenotes> @type L.pure
13:42:25 <lambdabot> Not in scope: `L.pure'
13:42:31 * Phyx- files another gtk2hs bug report
13:42:44 <Gracenotes> ah, arrow. darn.
13:42:56 <sundaymorning> I was reading Typeclassopedia at http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
13:44:47 <Gracenotes> sundaymorning: it makes sense the more you use it. Some of the relationships between typeclasses are interesting theoretically, but not so much for just casual programming.
13:45:56 <sundaymorning> yeah, lots of things there I can't even think about a problem where I would use that as a good solution
13:47:01 <tibbe> @seen dcoutts
13:47:02 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 3h 42m 28s ago.
13:47:40 <Gracenotes> sundaymorning: well, in many cases you don't want to use a monad, applicative, or functor without having a specific instance in mind
13:48:39 <Gracenotes> (the main exception being some higher-level convenience functions)
13:49:43 <Gracenotes> so you're using the functionality that a particular instance of a typeclass provides
13:50:19 <Gracenotes> (one that usually follows from the rules and requirements of the typeclass itself)
13:50:26 <sundaymorning> yeah, I use them when I use mapMaybe, sequence, mapM, etc.
13:50:59 <sundaymorning> but for that I hardly even need any understanding of Monoids, Monads, Applicative, etc...
13:51:46 <sundaymorning> I once tried to read a book, joy of cats.
13:51:52 <sundaymorning> I didn't make it very far :P
13:52:12 <Gracenotes> monoids are simple enough to play with: just follow the types, you know
13:52:28 <ski> sundaymorning : maybe try starting with "Conceptual Mathematics", instead ?
13:52:37 <blackh> sundaymorning: I am chipping away at arrows.  So far I use 'first', 'second', and '***' which are very useful for doing things to the first, second, and both elements of a tuple respectively.
13:53:08 <Gracenotes> you can see that there's an instance for Num a => Monoid (Product a)
13:53:20 <snoobino> hey
13:53:28 <Gracenotes> > Product 3 `mappend` Product 290
13:53:30 <snoobino> what's the biggest number a float can handle ?
13:53:30 <lambdabot>   Product {getProduct = 870}
13:53:32 <blackh> snoobino: Hello!
13:53:38 <mauke> snoobino: infinity
13:54:13 <snoobino> mauke: isn't it bounded ?
13:54:30 <Gracenotes> snoobino: any floating point number gets less and less precise as you get up to higher values
13:54:53 <Gracenotes> at some point, most implementations just say "this number is so high, we may as well call it infinity"
13:55:04 <snoobino> ok
13:55:11 <wnoise> @pl \y -> let Just x = y in return x
13:55:11 <lambdabot> const (return x)
13:55:40 <Gracenotes> > 932^3910 :: Float
13:55:42 <lambdabot>   Infinity
13:56:01 <BMeph> Gracenotes: Same precision, less accuracy. :)
13:56:10 <c_wraith> > 1/0 :: Float
13:56:12 <lambdabot>   Infinity
13:56:30 <snoobino> > log 0
13:56:32 <lambdabot>   -Infinity
13:56:32 * BMeph looks surprised, and pulls off the pedant-hat that mysteriously appeared on his head.
13:56:38 <wnoise> Hmph
13:56:47 <mauke> the interesting question is, what's the second biggest number a float can handle?
13:56:57 <Gracenotes> BMeph: yes, I contemplated the difference briefly before deciding to go with 'precision'
13:57:06 <Gracenotes> I suppose I reached the wrong conclusion :)
13:57:25 <Gracenotes> you're right, though, floating points do represent specific values
13:57:26 <snoobino> > 1/0 - 1
13:57:28 <lambdabot>   Infinity
13:57:33 <Baughn> mauke: You're not supposed to ask that question.
13:57:34 <Gracenotes> just not always the value you'd like
13:57:43 <sundaymorning> you could do something like product l = getProduct (mconcat $ map Product l); but that wouldn't be much nicer than product = foldr (*)
13:57:55 <Botje> > 1/0 - 1/0
13:57:58 <lambdabot>   NaN
13:58:10 <snoobino> > exp 30
13:58:11 <sundaymorning> so I'm not really sure when it would benefit you to go to all the trouble of setting up a Product list or something like that
13:58:12 <lambdabot>   1.0686474581524463e13
13:58:20 <snoobino> > exp 900
13:58:22 <lambdabot>   Infinity
13:58:48 <snoobino> > exp 900 :: Ratio Integer
13:58:49 <lambdabot>       No instance for (Floating (Ratio Integer))
13:58:50 <lambdabot>        arising from a use of...
13:58:58 <Gracenotes> sundaymorning: there are some structures that abstract over Monoids. Like the Writer monad
13:59:20 <BMeph> sundaymorning: Especially, since it's supposed to be foldl', not foldr. Of course, they hadn't thought of foldl' when they made up the definition.
14:00:32 <Gracenotes> > let factorialWithSum i = if i < 1 then return 1 else do { tell (Sum i); i' <- factorialWithSum (i-1); return (i * i') } in runWriter (factorialWithSum 100)
14:00:34 <lambdabot>   (93326215443944152681699238856266700490715968264381621468592963895217599993...
14:00:38 <Gracenotes> > let factorialWithSum i = if i < 1 then return 1 else do { tell (Sum i); i' <- factorialWithSum (i-1); return (i * i') } in runWriter (factorialWithSum 10)
14:00:40 <lambdabot>   (3628800,Sum {getSum = 55})
14:00:53 <Gracenotes> calculates the sum and factorial at the same time using the Sum monoid
14:01:49 <Gracenotes> > let sumWithFactorial i = if i < 1 then return 0 else do { tell (Product i); i' <- sumWithFactorial (i-1); return (i + i') } in runWriter (sumWithFactorial 10)
14:01:50 <lambdabot>   (55,Product {getProduct = 3628800})
14:02:12 <Gracenotes> (the same, but in reverse)
14:02:22 <bavardage> is there a built in factorial function?
14:02:26 <bavardage> I always end up rolling my own
14:02:35 <RayNbow> > foldMap (Product &&& Sum) [1..10]
14:02:36 <lambdabot>   (Product {getProduct = 3628800},Sum {getSum = 55})
14:03:11 <ppavelV6> bavardage: it shouldn't be built in. People who learn Haskell should have something like "Hello, world!" :)
14:03:46 <c_wraith> :t foldMap
14:03:47 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
14:03:55 <paczesiowa> @src foldMap
14:03:56 <lambdabot> Source not found. I feel much better now.
14:03:57 <RayNbow> > let (!) n = product [1..n] in (10!)
14:03:59 <lambdabot>   3628800
14:04:01 <bavardage> ppavelV6: haha :P
14:04:02 <RayNbow> @hoogle foldMap
14:04:02 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:04:03 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:04:11 <Gracenotes> > let fibWithCount n = do { tell (Sum 1); if (n <= 1) then return 1 else do { f1 <- fibWithCount (n-1); f2 <- fibWithCount (n-2); return (f1 + f2) }} in runWriter (fibWithCount' 24)
14:04:12 <lambdabot>   Not in scope: `fibWithCount''
14:04:14 <bavardage> it would just be nice, no, to have a factorial :P
14:04:46 <Gracenotes> ...either lambdabot's connection is fucked up or mine is :/
14:05:03 <ppavelV6> bavardage: you can choose something here: http://www.willamette.edu/~fruehr/haskell/evolution.html
14:05:42 <RayNbow> > foldMap (Product &&& (const $ Sum 1)) [1..10]
14:05:43 <lambdabot>   (Product {getProduct = 3628800},Sum {getSum = 10})
14:05:58 <Baughn> Ooh, nifty. I think I've managed to wedge the RTS.
14:07:16 <Baughn> ..yep, that's wedged. Locked up trying to grab a futex at zero cpu use.
14:07:45 <BMeph> > let fibWithCount n = do { tell (Sum 1); if (n <= 1) then return 1 else do { f1 <- fibWithCount (n-1); f2 <- fibWithCount (n-2); return (f1 + f2) }} in runWriter (fibWithCount 24)
14:07:48 <lambdabot>   (75025,Sum {getSum = 150049})
14:09:07 <Baughn> Only seems to be the threaded runtime. Naturally.
14:09:08 <Gracenotes> effing freenode :\
14:09:32 <BMeph> Gracenotes: You had an "extra" ' on your fibWithCount in the Writer.
14:09:37 <BMeph> > let fibWithCount n = do { tell (Sum 1); if (n <= 1) then return 1 else do { f1 <- fibWithCount (n-1); f2 <- fibWithCount (n-2); return (f1 + f2) }} in runWriter (fibWithCount 24)
14:09:39 <lambdabot>   (75025,Sum {getSum = 150049})
14:09:58 <Gracenotes> anyway, though, fibWithCount is supposed to (sans the prime) count the number of recursive calls involved in the recursive fibonacci :)
14:10:19 <Gracenotes> yeah, I know
14:10:28 <Gracenotes> BMeph: actually, by the time you mentioned the extra ', I had sent the message about what fibWithCount did a minute earlier.
14:10:42 <Gracenotes> I'm getting lower latency reading lambdabot's online logs than from freenode itself
14:11:00 <bavardage> >let e x = sum[x**r/product[1..r]|r<-[0..1000]] in e 1
14:11:11 <bavardage> > let e x = sum[x**r/product[1..r]|r<-[0..1000]] in e 1
14:11:13 <lambdabot>   2.7182818284590455
14:11:20 <bavardage> > exp 1
14:11:21 <lambdabot>   2.718281828459045
14:11:29 <bavardage> > let e x = sum[x**r/product[1..r]|r<-[0..1000]] in (e 1) - exp 1
14:11:30 <lambdabot>   4.440892098500626e-16
14:11:38 <bavardage> good enough ;D
14:11:39 <BMeph> Gracenotes: Yeah, it must've gotten lost in the 'split. :\
14:20:53 <Gracenotes> im in ur monoid, abstracting ur combination of same-typed varbls
14:23:37 <Ferdirand> i've got an interesting (at my level at least) modelling problem
14:24:30 <Ferdirand> writing a small utility for tabletop gaming, the goal is to use ghci as a handy calculator, that has knowledge of complex dice rolling rules
14:25:26 <Ferdirand> now, i already wrote a "probabilistic" monad, that behaves akin to the list monad, but with weights. This is nice for computing odds of succeeding under a complex set of rules
14:25:51 <c_wraith> rolling on treasure tables?
14:26:05 <Ferdirand> no, for now just abstract rolls :)
14:26:18 <Ferdirand> another use case is to have the computer actually do the rolls
14:26:23 <BMeph> @dice 3d8
14:26:24 <lambdabot> 3d8 => 21
14:26:35 <BMeph> Ferdy: ^^ ;)
14:26:37 <Ferdirand> i could use the final computed distribution, but then i lose the roll details
14:26:56 <Ferdirand> or, i could embed the history of the rolls in my probabilistic type
14:26:56 <Baughn> @dice 451212777d3
14:26:56 <lambdabot> 451212777d3 => 902441064
14:27:03 <Baughn> Mind you, using the distribution is nice for other reasons
14:27:25 <monochrom_> Nice project.
14:27:31 <Ferdirand> but then, i cannot consolidate it anymore, and the size of the distribution becomes on^k) or something, for every case
14:27:41 <bavardage> Gracenotes: haha
14:27:44 <bavardage> Gracenotes: oh dear
14:28:22 <Ferdirand> so, i'm considering implementing two different monad instances, one that computes distributions efficiently, another that do rolls and keep track of them
14:28:37 <Ferdirand> using the same rule definitions, obviously
14:29:43 <Ferdirand> which scares me in an irrational way, because i am tempted to write something like class (Monad m) => Rollable r
14:29:46 <Gracenotes> Ferdirand: there is a nice way to choose an element randomly from a list of unknown length, by the way
14:29:57 <Gracenotes> not sure if it's relevant
14:30:12 <Ferdirand> then instance Rollable Probabilistic, and instance Rollable ThingThatLooksLikeWriterMonad
14:30:28 <Baughn> Gracenotes: Exponential distribution?
14:30:35 <monochrom> Not all monads are rollable.
14:30:43 <Gracenotes> this algorithm, courtesy osfameron... http://osfameron.vox.com/library/post/random-pain-in-haskell.html
14:30:49 <monochrom> But nevermind.
14:30:57 <Ferdirand> not all monads are rollable, but all rollables are monad
14:31:13 <Baughn> Gracenotes: Does that link work for you?
14:31:35 <Gracenotes> the one I just linked, yes
14:31:45 <Baughn> Ferdirand: Should be fine to have that, then
14:31:51 <Baughn> Hmm. I get "can't find server".
14:32:00 <Baughn> Oh, wait, now it works? -_-;
14:32:26 <Ferdirand> then my class Rollable would contain something to materialize a dice roll
14:32:39 <Ferdirand> that in the first case, would be the full distribution of the dice
14:33:05 <Ferdirand> and in the second, it would pick a random roll from a state, and record the roll
14:33:30 <Ferdirand> i have not grokked monad transformers yet, btw
14:33:34 <Ferdirand> which is a shame
14:33:54 <Ferdirand> also wondered wether arrows would be more appropriate
14:35:15 <Baughn> Ferdirand: There's no magic about transformers. You basically get to write all the code yourself; you just have to provide lift.
14:35:31 <Baughn> Well, and liftIO, if appropriate
14:35:49 <Gracenotes> in many cases you can just newtype another transformer
14:35:59 <Gracenotes> some.
14:35:59 <Ferdirand> well, i did not consider writing a transformer
14:36:36 <Ferdirand> but perhaps using them to easily get random picking + writer for the roll history
14:37:45 <Ferdirand> anyway, just wanted to check if there was something obviously flawed, or a trivial alternative route
14:38:24 <Ferdirand> i've been greatly impacted by all the "you don't really want typeclasses" talk, also :p
14:38:50 <osfameron> @pl \g -> concatMap s g ++ (concatMap s $ transpose g)
14:38:50 <lambdabot> liftM2 (++) (s =<<) ((s =<<) . transpose)
14:39:08 <osfameron> awww, that's purdy :-)
14:39:36 <bavardage> I need to learn monads :P
14:39:48 <bavardage> they are still a mystery to me
14:39:53 <Phyx-> does anyone know how you can force an EventBox from not processing Resize events? it's slowing the resizing
14:40:12 <pmurias> how can I convert an UArray to a Ptr?
14:40:34 <Ferdirand> bavardage: i'm at the next step. now everything looks like a monad to me :p
14:41:02 <bavardage> hehe
14:41:03 <Baughn> So now you need to learn not to see monads. :P
14:41:13 <bavardage> so monads turn haskell more imperative?
14:41:16 <Ferdirand> exactly
14:41:17 <Cale> no
14:41:21 <Cale> Not really :)
14:41:23 <bavardage> I mean sure, it's much deeper than that
14:41:29 <bavardage> but on the surface of it
14:41:41 <Cale> Well, there's a sense in which the IO monad does
14:41:47 <Ferdirand> (oops, i was answering Baughn)
14:41:56 <Cale> ah :)
14:42:26 <bavardage> hehehe
14:42:36 <bavardage> right, I think I've only ever seen the IO monad anyway
14:42:36 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
14:42:38 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:42:39 <Baughn> > join [[1,2],[3,4]] -- bavardage: join is the essence of the monad. Does that look imperative to you?
14:42:41 <lambdabot>   [1,2,3,4]
14:42:47 <bavardage> do I actually need to understand the maths of it?
14:42:52 <Cale> bavardage: no
14:42:54 <bavardage> heh no it doesn't look very imperative
14:42:58 <bavardage> heh phew
14:42:58 <Baughn> bavardage: Well, you should read the typeclassopedia at least
14:42:59 <osfameron> (map.map)++
14:43:04 <Baughn> bavardage: Monad = Applicative + join
14:43:17 <bavardage> and what is the point of them?
14:43:26 <Baughn> The IO monad is kinda handy. ;)
14:43:31 <bavardage> in a nutshell
14:43:33 <Cale> bavardage: To capture a pattern which occurs in many libraries
14:43:44 <Baughn> bavardage: To be able to write utility functions that work on all such patterns
14:43:46 <Cale> bavardage: and give us a uniform interface, and some handy functions which work with all of those
14:44:34 <Cale> For example, there's a function sequence. In the list monad, it's basically a Cartesian product...
14:44:41 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
14:44:43 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
14:45:03 <Cale> In the function monad, it's "apply all these functions to a value and get a list of the results"
14:45:13 <bavardage> right
14:45:16 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
14:45:17 <lambdabot>   [5,7,10,25,32]
14:45:40 <Cale> In the IO monad, it takes a bunch of IO actions and gives a single action which will run them all and collect a list of the results.
14:45:57 <Cale> In a parsing monad, it's the concatenation of a list of parsers.
14:46:26 <Baughn> (Which returns their results)
14:46:29 <Cale> By recognising something as a monad, we get a whole library of (potentially) useful functions for free.
14:46:47 <Cale> (like this 'sequence' function)
14:47:18 <seafood> So, I got a question. The Cairo bindings in Haskell are through the GTK bindings aren't they?
14:47:44 <Cale> seafood: Yeah, they're part of Gtk2Hs
14:48:12 <Cale> at least, they were when I last checked :)
14:48:13 <seafood> Hmm, there is a Quartz backend for Cairo on Mac OS X. No one's worked on binding to that have they?
14:48:29 <BMeph> Could someone explain why GHCi gives you an ambiguous occurence for a function when only one works?
14:48:39 <Cale> BMeph: what?
14:48:55 <BMeph> I think I get it, but if someone has an explanation, I'd still like to read it. :)
14:49:03 <Cale> BMeph: Maybe it can't decide what type you want?
14:49:35 <BMeph> Cale: Like, when you import Data.Map, or .Set, or .Sequence, and try to use "map".
14:49:54 <Cale> Oh, because more than one map is in scope.
14:50:04 <Cale> So you have to use qualified names to say which one.
14:50:38 <BMeph> I think it's because it doesn't know which function to partially apply, since they all take an (a -> b) function.
14:50:46 <Cale> It won't even try to typecheck if it can't decide which thing each variable refers to.
14:51:07 <seafood> Cale: I think I'm getting a little confused.  Why is Cairo part of Gtk2Hs?
14:51:12 <Gracenotes> > liftM2 (,) [1,2,3] [1,3,5]
14:51:14 <lambdabot>   [(1,1),(1,3),(1,5),(2,1),(2,3),(2,5),(3,1),(3,3),(3,5)]
14:51:24 <Cale> seafood: ask dcoutts
14:51:46 <Cale> seafood: I think it had something to do with cairo being integrated somewhat with Gtk2 at that time.
14:52:02 <bavardage> right I'm to bed
14:52:02 <bavardage> nn
14:52:03 <bavardage> o/
14:52:06 <seafood> Cale: Right, fair enough.
14:52:07 <BMeph> Cale: Except, if it could see the next argument, it could infer the right function from the type of that argument.
15:01:34 <jrx> hi, can anyone explain to me, why version 1 from here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3069#a3069 is so terribly slow (20x) compared to the second one?
15:02:09 <Baughn> jrx: Are you compiling with -O2?
15:02:19 <jrx> Baughn: yep, exactly
15:02:51 <Baughn> jrx: Fun. Well, I've no idea, but that's exactly the sort of thing haskell-cafe /loves/ to figure out.
15:03:56 <jrx> whats more it appers that the first definition gives the complexity O(n^2) while the second one as predicted O(n)
15:05:28 <jrx> I don't know if it changes anything, but I supply to it an infinite list of functions
15:05:42 <jrx> and at the end just consume the part of output
15:08:25 <Baughn> > (\x -> sequence . scanl (>>=) (return x)) 1 [2..5]
15:08:27 <lambdabot>       No instance for (Show (m [b]))
15:08:27 <lambdabot>        arising from a use of `show' at <...
15:08:43 <Baughn> > (\x -> sequence . scanl (>>=) (return x)) 1 [const [2], const [3]]
15:08:45 <lambdabot>   [[1,2,3]]
15:09:02 <Baughn> > (\x -> sequence . scanl (>>=) (return x)) 1 [x,y,z]
15:09:03 <lambdabot>   Couldn't match expected type `b -> m b'
15:09:13 <Baughn> > (\x -> sequence . scanl (>>=) (return x)) f [f,g,f]
15:09:15 <lambdabot>       No instance for (Show (m [b]))
15:09:15 <lambdabot>        arising from a use of `show' at <...
15:09:19 <Baughn> @type f
15:09:21 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:09:22 <Baughn> @type g
15:09:24 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:09:31 <Baughn> @type h
15:09:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
15:09:48 <dons> gwern: http://galois.com/~dons/images/chars.png
15:09:51 <Baughn> > (\x -> sequence . scanl (>>=) (return x)) 1 [f,g,h]
15:09:52 <lambdabot>       No instance for (Show (m [b]))
15:09:52 <lambdabot>        arising from a use of `show' at <...
15:09:58 <dons> displaying the guts of the closure for atomic types now
15:10:19 <dons> what do you think guys?
15:10:28 <Baughn> dons: So, is GHC going to end up with a proper introspection library eventually?
15:10:50 <dons> ghc-api kinda is that, I think. how "proper" is up for debate
15:10:54 <dons> this is all on top of ghc-api
15:11:03 <Nafai> dons: This looks awesome!
15:11:13 <Baughn> Ah. Well. Easy to use? :P
15:11:15 <Nafai> dons: I don't quite understand what's going on, but it does look awesome. :)
15:11:46 <Nafai> dons: This would be a great reason to have a ghci that is Cairo from the start, to have drop downs for completion, another window for this thing, etc
15:13:53 <defun> hi, I am making a parser to parse haskell-style-lists of colors. It is mostly finished, though it does not work on a certain kind of list. More details and code over here: (http://pastebin.com/f38971a6a) Please help me to fix this code to work on the final list example (which can be found in the link).
15:17:44 <kpreid> defun: I think the problem is that you've got nothing which *accepts* whitespace before ]
15:18:00 <defun> accepts?
15:18:16 <defun> you mean in the brackets function?
15:18:34 <defun> I see.
15:18:40 <defun> Let me test some stuff out.
15:18:42 <defun> brb.
15:18:43 <Shurique> anyone who's got experience with hsSDL on OS X? I've built the bindings according to the instructions at http://darcs.haskell.org/~lemmih/hsSDL/hssdl/MACOSX, but I don't quite understand how I'm supposed to compile SDL programs
15:19:48 <Ferdirand> hello again, can anyone enlighten me about this seemingly easy error ? 'possible fix' does not make sense to me
15:19:51 <Ferdirand> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3072#a3074
15:20:25 <kpreid> matches
15:20:26 <kpreid> also 'arch' is undefined?
15:20:46 <mauke> Ferdirand: you can't make that a monad
15:21:31 <lilac> Ferdirand: sadly, a Monad instance has to work for all types a, and that only works for Ord a => a
15:21:35 <defun> sorry arch is supposed to be color.
15:22:02 <defun> it /is/ color in the actual code.
15:22:21 <defun> kpreid: what do you mean by matches?
15:22:48 <kpreid> yes
15:22:55 <defun> and yes, 'brackets' won't work newlines.
15:23:04 <defun> I'll fix it soon.
15:23:23 <Ferdirand> lilac: but i can accept having (Ord a) => Proba a, why isn't that enough to guarantee type correctness ?
15:24:08 <mae> has anyone had any problems compiling / installing the "encoding" package? For me it never finishes -- and if I turn off optimizations the stack overflows
15:24:30 <mauke> :t return (* 2) >>= \f -> return (f 3)
15:24:31 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => m a
15:24:57 <mauke> Ferdirand: that type means it will work with all monads. it doesn't work with your Proba.
15:25:05 <mauke> therefore Proba is not a Monad
15:25:36 * Ferdirand 's brain trying to process 
15:25:42 <evergreen`>  /who
15:26:12 <Ferdirand> ah, duh. obviously.
15:26:16 <sundaymorning> I find it very unfortunate that Set needs Ord. I don't think it's a big problem for Map, but it looks weird for Set.
15:27:54 <augustss> Ferdirand: It's a well known problem with Haskell monads.
15:28:23 <Ferdirand> Haskell just failed me for the first time :(
15:28:42 <gwern> dons: looks much better! would it be asking too much to suggest that perhaps distinct elements of the original expression could be offset from each other?
15:28:46 <thoughtpolice> are you basically looking for restricted monads?
15:28:47 <kpreid> defun: you have brackets $ color `sepBy` separator. you want to match "brown\n   ]". brackets is like char '[' >> ... >> char ']'. the color rule matches only color names. the brackets rule does not match space, so it fails.
15:29:27 <gwern> dons:  that is, the tree of "hey" could be offset from the fromList and the zip [1..5], so it's easier to see what subgraph corresponds to what of the original
15:29:37 <thoughtpolice> Ferdirand: you might want to look at this:
15:29:39 <thoughtpolice> @hackage rmonad
15:29:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
15:29:56 <Ferdirand> i don't really need it though. it was just for performance.
15:30:02 <Ferdirand> thanks, will look at it
15:32:19 <Ferdirand> thoughtpolice: amazing. Thanks.
15:36:14 <dons> gwern: hard to achieve
15:40:27 <paczesiowa> @src Id
15:40:28 <lambdabot> Source not found. :(
15:40:33 <paczesiowa> :t Id
15:40:35 <lambdabot> Not in scope: data constructor `Id'
15:40:46 <paczesiowa> @hoogle Id
15:40:46 <lambdabot> Prelude id :: a -> a
15:40:47 <lambdabot> Data.Function id :: a -> a
15:40:47 <lambdabot> Text.Read Ident :: String -> Lexeme
15:41:29 <paczesiowa> @src Identity
15:41:29 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
15:42:10 <skorpan> if you have a bow (as in "bow and arrow") and you "pull the string" on it, what's that called?
15:42:22 <skorpan> i mean, that thing that you do when you're about to shoot
15:42:59 <vixey> stretching
15:43:00 <MyCatVerbs> skorpan: "nocking", to put an arrow on the string while it's taut.
15:43:04 <mauke> draw a bow?
15:43:15 <vixey> nocking is good
15:43:22 <skorpan> "nock your bow"?
15:43:35 <MyCatVerbs> skorpan: "draw" "stretch" or "pull" all work for "pull the string taut, ready to nock an arrow".
15:43:39 <vixey> @go terminology of archery
15:43:39 <lambdabot> No Result Found.
15:43:48 <paczesiowa> :t (\(f :: forall a. a -> a) -> let x = Identity f in case runIdentity x of f' -> (f' True, f' 'c')) id
15:43:50 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
15:43:50 <lambdabot>     In the first argument of `f'', namely 'c'
15:43:50 <lambdabot>     In the expression: f' 'c'
15:44:00 <MyCatVerbs> http://en.wikipedia.org/wiki/List_of_archery_terms <- naturally.
15:44:11 <skorpan> cool, thanks
15:44:24 * vixey bookmarks for future programs :p
15:44:26 <MyCatVerbs> It's more important than the identity of the 447th pokemon, therefore it's on wikipedia. Why didn't I think of trying that first? ¬¬
15:44:36 <paczesiowa> why Identity container makes things monotypes?
15:45:00 <gwern> dons: yeah, probably. but it would be nice, you'd have to admit
15:46:56 <MyCatVerbs> :t \(f :: forall a. a -> a) -> let x = Identity f in runIdentity f
15:46:58 <lambdabot>     Couldn't match expected type `Identity a'
15:46:58 <lambdabot>            against inferred type `a1 -> a1'
15:46:58 <lambdabot>     In the first argument of `runIdentity', namely `f'
15:47:11 <MyCatVerbs> :t \(f :: forall a. a -> a) -> let x = Identity f in runIdentity x
15:47:12 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
15:48:39 <paczesiowa> MyCatVerbs: if that's supposed to be an answer than I still don't get it:)
15:48:55 <paczesiowa> *then
15:49:21 <MyCatVerbs> paczesiowa: no, just trying the same thing and wondering. It does not look like putting it through Identity is what is making it monomorphic.
15:49:41 <MyCatVerbs> @index Identity
15:49:42 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
15:50:28 <ski> :t (\(f :: forall a. a -> a) -> let x = f in case x of f' -> (f' True, f' 'c')) id
15:50:29 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
15:50:30 <lambdabot>     In the first argument of `f'', namely 'c'
15:50:30 <lambdabot>     In the expression: f' 'c'
15:50:43 <ski> :t (\(f :: forall a. a -> a) -> case f of f' -> (f' True, f' 'c')) id
15:50:45 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Char'
15:50:45 <lambdabot>     In the first argument of `f'', namely 'c'
15:50:45 <lambdabot>     In the expression: f' 'c'
15:50:59 <ski> :t (\(f :: forall a. a -> a) -> let x = f in (x True, x 'c')) id
15:51:00 <lambdabot> (Bool, Char)
15:52:18 <Nafai> Hi byorgey!
15:52:23 <MyCatVerbs> So apparently it's making the binding with case rather than let that forces a single type.
15:53:10 <Saizan> that's what case does
15:53:59 <Gracenotes> @type (\f -> (f True, f 'c')) id
15:54:00 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
15:54:00 <lambdabot>       Expected type: Char -> t
15:54:00 <lambdabot>       Inferred type: Bool -> t1
15:54:01 <paczesiowa> damn, I can't make simple example:/
15:54:22 <Gracenotes> needs moar polymorphism
15:54:41 <defun> thanks, kpried. I will try to create a replacement for brackets.
15:55:48 <__Ali__> is he official ghc windows binaries built on cygwin?
15:56:55 <paczesiowa> ok, I have e :: IO (forall v. [E Int] -> E' v Int), and I can't put it into Identity, that makes more sense?
15:57:18 <paczesiowa> Cannot match a monotype with `IO (forall v. [E Int] -> E' v Int)'
15:58:29 <kpreid> defun: another approach is to use a lexer
16:00:08 <kadaver> another lexer is to use an approach
16:02:49 <Nafai> jfredett: Around?
16:05:49 <Flugan> What function is used to perform a replace over a list?
16:06:14 <kadaver> does haskell have toUpperCase and the opposite?
16:06:32 <BMeph> kadaver: Yes.
16:06:33 <sioraiocht> kadaver: toUpper and toLower
16:06:37 <sioraiocht> in Char
16:06:47 <sioraiocht> > toUpper 'a'
16:06:48 <lambdabot>   'A'
16:06:54 <kadaver> tried that
16:06:54 <kadaver> <interactive>:1:0: Not in scope: `toUpper'
16:06:57 <sioraiocht> yes
16:06:58 <sioraiocht> they're in char
16:07:00 <MyCatVerbs> > map (\x -> if x == 'j' then 'J' else x) $ "I had to help my uncle jack off a horse.\n"
16:07:00 <sioraiocht> Char
16:07:01 <lambdabot>   "I had to help my uncle Jack off a horse.\n"
16:07:10 <Baughn> Flugan: map?
16:07:23 <Baughn> Well, as you see.
16:07:23 <sioraiocht> Baughn: yes, a map
16:07:38 <MyCatVerbs> Flugan: something like teh above.
16:07:42 <MyCatVerbs> TEH. Not the.
16:07:43 <Baughn> I keep thinking there ought to be a more specific one, but..
16:08:17 <Phyx-> Baughn, just wrapped your Timer in a Countdown timer, works great :)
16:08:33 <Flugan> Thanks
16:08:45 <Baughn> Phyx-: The interface is a bit bad, but more to the point, there's a race condition in there
16:09:09 <Baughn> Phyx-: If you call setTimer /just/ as the.. um...
16:09:22 <Phyx-> hm?
16:09:27 <Baughn> Oh.
16:09:33 <Baughn> Never mind. No race condition. ^_^
16:09:36 <Phyx-> lol
16:09:48 <byorgey> hi Nafai!
16:10:09 <Baughn> I was thinking you could get two timeouts right on top of each other, but it delays first and times out later
16:10:14 <Phyx-> only thing i had to change was to be able to create a timer with no action, then to set the action
16:11:45 <gsm4> #gametheory
16:11:49 <gsm4> bah mt
16:12:34 <kadaver> random sequence of nbrs?
16:14:51 <Phyx-> Baughn, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3075#a3075 that i used
16:15:30 <Baughn> Phyx-: That performGC is rather gratuitous
16:15:42 <Baughn> Phyx-: (Don't do it. Seriously.)
16:15:44 <Phyx-> lol, i just saw it in your example usage
16:15:47 <Phyx-> why i copied it
16:15:48 <Phyx-> hehe
16:15:58 <Phyx-> removed
16:15:59 <Baughn> But that was to demonstrate the finalizer ^^;
16:16:38 <Baughn> Phyx-: Oh, and s/time left/interval/g
16:16:44 <Phyx-> heheh
16:17:39 <kadaver> i need a list of random numbers k thnx
16:18:13 <Phyx-> that should be alot cleaner than our current methods
16:18:42 <kadaver> isnt there a function to gen random nbrs?
16:18:55 <Phyx-> stdGen?
16:19:22 <Baughn> @src Randoms
16:19:22 <lambdabot> Source not found. Do you think like you type?
16:19:23 <Baughn> @src Random
16:19:23 <lambdabot> class Random a where
16:19:23 <lambdabot>   random    :: RandomGen g => g -> (a, g)
16:19:23 <lambdabot>   randoms   :: RandomGen g => g -> [a]
16:19:23 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
16:19:24 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
16:19:25 <Phyx-> http://hackage.haskell.org/packages/archive/random/1.0.0.1/doc/html/System-Random.html
16:19:26 <lambdabot>   randomRIO :: (a,a) -> IO a
16:19:28 <lambdabot>   randomIO  :: IO a
16:19:34 <Baughn> Ah. Noisy \bot.
16:19:41 <Baughn> Anyway, randoms and randomRs
16:20:05 <Phyx-> btw, the commandline hoogle seems less usefull then i expected
16:20:06 <Phyx-> lol
16:20:54 <kadaver> let r = randoms (length s)
16:20:59 <kadaver>  No instance for (RandomGen Int)
16:21:00 <kadaver>       arising from a use of `randoms'
16:21:42 <bremner> Is there a built in function in Text.XML.Light to go QName -> String
16:21:59 <Botje> maybe QName is an instance of show?
16:22:16 <bremner> err, yeah. let me ask it better
16:23:36 <bremner> I have xml like <para> blah </para>  and I want to extract "para" from the QName. I guess I can just pattern match
16:24:15 <Phyx-> kadaver, you have to pass it an RandomGen
16:24:15 <c_wraith> bremner, there's a function to do that.
16:24:17 <Phyx-> like
16:24:24 <Phyx-> randoms (mkStdGen 10) :: [Int]
16:25:35 <bremner> c_wraith: any idea where to look?
16:25:37 <c_wraith> bremner: look at the Text.XML.Light.Proc module
16:25:50 <c_wraith> It has all the useful functions
16:26:51 <bremner> c_wraith: huh, I must be blind, I didn't see it there.
16:26:52 <Phyx-> kadaver, newStdGen >>= return.randoms would also work
16:27:01 <kadaver> can we add lolcating to lambdabot?
16:27:06 <kadaver> lolcatify :: String -> IO String
16:27:14 <kadaver> *Lolcat> lolcatify "Im in your ciphers factorizing your primes"
16:27:19 <kadaver> "Im iN yOuR cIpHerz fACTORIzInG youR PRImEz"
16:27:22 <c_wraith> Oh, sorry, I think I misread your question.
16:27:27 <bremner> c_wraith: but really it is one line to write, so no biggy
16:27:37 <c_wraith> actually, there is a function to do that
16:27:50 <c_wraith> it's called qName
16:27:52 <bremner> there is a function to go the other way, unqual
16:28:00 <bremner> oh.
16:28:03 <c_wraith> when you have a data structure with named parts
16:28:08 <bremner> doh
16:28:10 <c_wraith> the name of the part is an accessor function
16:28:15 * bremner feels very stupid
16:28:33 <c_wraith> It's ok.  I manage to forget that regularly myself. :)
16:28:53 * bremner just lectured on this on thursday. I wonder if any of the students remember when I don't :-)
16:29:40 <edwardk> is there a syntax for defining field accessors in a GADT?
16:30:16 * edwardk guesses it probably doesn't make sense 
16:30:54 <Phyx-> hmm what's the best way to recover from errors thrown by read?
16:31:43 <roconnor> Phyx-: use reads
16:32:22 <Phyx-> roconnor, ah, sweet
16:32:26 <Phyx-> thanks
16:32:50 <Phyx-> *fixes his commandline parsers*
16:33:01 <Phyx-> GetOpt is handy
16:34:01 <ppavelV6> @type reads
16:34:02 <lambdabot> forall a. (Read a) => String -> [(a, String)]
16:35:32 <roconnor> @where SG
16:35:32 <lambdabot> I know nothing about sg.
16:36:00 <roconnor> @hackage SG
16:36:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SG
16:36:08 <bremner> next to malaysia isn't it?
16:36:18 <ppavelV6> :)
16:37:17 <roconnor> I need to write my own geometry lib sometime
16:37:45 <ppavelV6> roconnor: why?
16:37:52 <roconnor> because I have ideas
16:38:11 * ppavelV6 almost always have ideas
16:38:18 <roconnor> on how to do it the "right way"
16:38:36 <ppavelV6> most of mine are arguable dumb :(
16:38:37 <ppavelV6> :)
16:40:05 * ppavelV6 got an idea to learn more about Applicative
16:41:00 <powerofPI> hi
16:41:31 <powerofPI> i have a question on using timers with haskell. anyone can help?
16:41:52 <ppavelV6> powerofPI: go forward! ask it! :)
16:42:06 <ppavelV6> really have to go, sorry
16:42:27 <powerofPI> ok
16:42:42 <powerofPI> i'll ask anyhow..
16:43:27 <dons> ask ask ask
16:43:54 <powerofPI> i'd like to set up a timer. say, wait for five seconds while doing a lot of stuff and then be notified. i solved the problem forking a process that simply calls threadDelay 5000000 and then send a message to the channel where the original process is always listening
16:44:12 <dons> yep
16:44:13 <powerofPI> the problem is that now i would like to be able to inspect the
16:44:17 <dons> forking a thread.
16:44:47 <powerofPI> inspect the value of the timer, that is, how long i still have to wait.
16:45:05 <dons> so there'll need to be some shared state
16:45:15 <dons> and it'll have to wake up periodically to update the stop watch
16:45:35 <powerofPI> hum...
16:46:23 <powerofPI> so you say that instead of doing a threadDelay 5000000 I do say 10 times threadDelay 500000 (half a second)
16:46:25 <dons> well, you could always look at the clock
16:47:37 <powerofPI> looking at the clock does not seem to be a bad idea..i would just need to store the starting time
16:48:26 <powerofPI> but if i want to know when the time is up, i still need to fork a thread and be sent a message, or do you know a better way?
16:49:35 <dons> that's the best way
16:49:38 <dons> the threadDelay is a good timer
16:51:35 <rittyan> <offtopic>god make Text.JSON use bytestrings</offtopic>
16:51:42 <powerofPI> so, i launch the threadDelaying thread and keep receiving messages until i get the timeout thread. and also i store the starting time so that i always know how long still have to wait. seems OK?
16:53:42 <powerofPI> thanks for your help. ;)
16:53:56 <jmcarthur> vacuum continues to get sexier
16:55:03 <__Ali__> when some haskell code is compiled to java, can that javabytecode access some other haskell code compiled to native code?
16:55:25 <TomMD> powerofPI: There is also a library to schedule events - two actually.
16:55:33 <TomMD> powerofPI: control-timeout and control-event.
16:56:01 <jmcarthur> __Ali__: i'm not even aware of a haskell->java compiler. is there one?
16:56:07 <TomMD> powerofPI: I wasn't following the whole conversation, so maybe this isn't what you want.
16:56:36 <__Ali__> jmcarthur, http://www.cs.rit.edu/~bja8464/lambdavm/
16:56:48 <powerofPI> TOmMD:thanks..i 'll also have a look into those libraries
16:58:08 <amaron> can someone explain this to me:
16:58:19 <amaron>  subRegex (mkRegex ",") "one,two,three" ";"
16:58:32 <amaron> "*** Exception: Text/Regex/Base/Context.hs:210:40-66: Irrefutable pattern failed for pattern ((whole, _) : subs)
16:59:43 <BMeph> vacuum-cairo bombed out on me. :\
17:03:14 <sw17ch> omg vacuum-cairo
17:03:17 <sw17ch> o_O
17:03:28 <dons> v 0.3: http://www.youtube.com/watch?v=oujaqo9GAmA
17:03:39 <dons> think i'm pretty much done now.
17:03:45 <dons> BMeph: ?
17:03:57 <sw17ch> dons: just finished watching that if it's what was in your tweet
17:04:00 <dons> yep
17:04:07 <dons> added some annotations
17:04:10 <Nafai> dons: It won't compile for me :(
17:04:15 <dons> Nafai: why?
17:04:17 <sw17ch> i'm having a process error on windows :(
17:04:21 <powerofPI> tomMD: i can't find the control-event module... are you sure this is the name?
17:04:21 * sw17ch will try in linux later
17:04:25 <dons> sw17ch: missing 'dot' binary
17:04:52 <jmcarthur> me either
17:04:52 <sw17ch> dons: no, the cyclic process-1.0.1.1 vs process-1.0.1.0
17:04:58 <dons> oh.
17:05:01 <Nafai> dons: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3076#a3076
17:05:12 <TomMD> @hackage control-event
17:05:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-event
17:05:16 <Nafai> dons: I have a darcs version of gtk2hs installed
17:05:18 <TomMD> powerofPI: ^^^
17:05:38 <edwardk> did oleg and cc shan's implicit configuration paper ever find its way into hackage in some form?
17:05:40 * jmcarthur has whatever version is in aur and gets the same error
17:05:49 <dons> oh, it probably needs the patch i sent to mmorrow.
17:05:55 <dons> there's a patch to vacuum needed
17:06:12 <dons> http://galois.com/~dons/tmp/nodeids.dpatch
17:06:21 * jmcarthur will just wait patiently for the next upload of vacuum to hackage
17:06:25 <Nafai> dons: Yeah was just from cabal install vacuum-cairo
17:06:27 <Nafai> Ok
17:06:33 <Nafai> I'll wait too
17:06:37 <dons> sorry, mmorrow's not up yet to apply the patch
17:06:38 <Nafai> Looks awesome though :)
17:07:11 <sw17ch> dons: the images linked from hackage need updating for 0.3
17:07:24 <sw17ch> the stuff in the video with the constructors is way cooler
17:07:27 <dons> yeah
17:07:30 <dons> good idea.
17:07:47 <Nafai> I like the youtube annotations you did
17:07:59 * edwardk just gives in and writes it into his current package
17:08:06 <sw17ch> the C#|1 doesn't make nearly as much sense as the (:) -> 'h'
17:08:28 <glur> is there some combinator :: m a -> (a -> m b) -> m a
17:08:46 <mauke> glur: const
17:08:56 <edwardk> mauke: i think he wants the effect
17:08:56 <glur> :D
17:08:58 <jmcarthur> mauke: :P perhaps not what he wanted
17:09:15 <glur> ok, that technically answers my question :)
17:09:23 <mauke> @pl \mx f -> mx >>= \x -> f x >> return x
17:09:23 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
17:09:39 <edwardk> i presume for something like a parser that needs to have another parser applied right after that you don't care about?
17:09:40 <jmcarthur> @pl \m k -> m >>= \x -> k x >> x
17:09:40 <lambdabot> (. ((>>) =<<)) . (>>=)
17:09:44 <jmcarthur> woops
17:09:49 <jmcarthur> @pl \m k -> m >>= \x -> k x >> return x
17:09:49 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
17:09:59 <jmcarthur> oh i got beat anyway
17:11:04 <edwardk> i've used a similar combinator a couple of times myself usually infix with a name like 'discarding' or 'ignoring' based on the context ;)
17:11:40 <edwardk> foo <- token `discarding` spaces
17:12:30 <mauke> foo <- token <* spaces
17:12:47 <jmcarthur> @pl \k m -> m >>= \x -> k x >> return x
17:12:47 <lambdabot> (=<<) . (`ap` return) . ((>>) .)
17:12:51 <glur> :t (<*)
17:12:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:13:00 <edwardk> oh yeah
17:13:16 <mauke> value = token '(' *> expr <* token ')'
17:13:21 <edwardk> but it doesn't work when the guy on the right needs the context like glur wanted
17:13:32 <edwardk> hrmm of course mine didn't offer it either
17:13:47 * edwardk switches to <* gleefully
17:14:08 <edwardk> mauke: nice
17:15:35 <glur> thanks guys; I had assumed there would be something in Applicative to do it, but I guess I'll just have to write it out
17:17:28 <edwardk> glur: applicative can't contain it because you need the 'wrapper' to depend on a value dependently, thats inherently monadic. you can't choose the shape of future values with an applicative
17:17:43 <edwardk> er dependent on the contents of the applicative i mean
17:20:38 <glur> edwardk: true. I was using Applicative in the loose sense of "that place where all the useful combinators that I haven't learned yet live". should have put a "or somewhere" in there.
17:21:52 <Gracenotes> one day, when I find Mr. Base 4, I am going to stab it repeatedly in the B with a knife and ask why it wouldn't let me cabal install in peace >:[
17:27:26 <bremner> if I want to right justify a number in fixed width field, is Text.Printf my best bet?
17:29:13 <dons> @tell mmorrow vacuum-cairo 0.3 depends on the patch to be applied
17:29:14 <lambdabot> Consider it noted.
17:34:06 <Cale> bremner: that or just hacking together your own padding function for use with show... there might also be something on Hackage, but I haven't looked.
17:35:01 <bremner> Cale: printf is fine, I just wondered if I was missing a more ideomatic way of doing it
17:35:43 <bremner> the old convenience versus typesafe thing I guess
17:39:03 <Cale> bremner: There are things like this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tabular
17:39:12 <Cale> bremner: If you want to be fancy :)
17:47:21 <BMeph> dons: patch? What patch? Am I bombing out on compiling it because of a patch?
17:49:30 <dons> BMeph: yes
17:51:36 <eyeris> I am trying to understand Cale's sudoku solver on the wiki. I can't figure out the type of valAt'. http://haskell.org/haskellwiki/Sudoku#Monadic_non-deterministic_solver
17:51:48 * Cale looks
17:52:14 <Cale> Right...
17:52:43 <Cale> valAt' :: StateT (DiffUArray (Int,Int) Int) Nondet Int
17:52:47 <Cale> Yeah?
17:53:03 <eyeris> Why no arrows?
17:53:14 <Cale> Oh...
17:53:16 <Cale> right, right
17:53:22 <Cale> valAt' :: (Int,Int) -> StateT (DiffUArray (Int,Int) Int) Nondet Int
17:53:52 <Cale> So, it's just the unwrapped version of valAt
17:54:14 <Cale> valAt has a nicer type:
17:54:20 <eyeris> I don't understand that type either
17:54:27 <Cale> valAt :: (Int,Int) -> Sudoku Int
17:55:02 <eyeris> So now line up the type of Sudoku with the type of valAt'
17:55:05 <Cale> That is, it's an action in the Sudoku monad which gets the value at a given position on the current board.
17:55:15 <Cale> newtype Sudoku a = Sudoku (StateT (DiffUArray (Int,Int) Int) Nondet a)
17:55:49 <eyeris> I understand what it does. I just can't figure out how you can compose Sudoku and valAt'
17:56:06 <Cale> Sudoku :: StateT (DiffUArray (Int,Int) Int) Nondet a -> Sudoku a
17:56:28 <eyeris> Okay
17:56:52 <Cale> It might help to write it more pointfully?
17:57:11 <Cale> valAt (i,j) = Sudoku (valAt' (i,j))
17:59:06 <eyeris> What injects the Int into the type signature?
18:01:52 <eyeris> Oh, I see. It's the (!) on a DiffUArray (Int, Int) Int
18:02:48 <eyeris> It's confusing that 'a' in valAt' is not the same 'a' from the Sudoku type sig.
18:12:58 <shapr> Wow, #haskell is nearly eight years old!
18:14:40 <dons> shapr: something you'll like: http://www.youtube.com/watch?v=oujaqo9GAmA
18:15:50 * shapr looks
18:18:06 <FunctorSalad> when implementing shrink for something like a list... do I need to shrink the elements myself or will QC do that if the elements are generated using arbitrary themselves
18:19:03 <shapr> dons: Wow, that's sexy!
18:21:08 <shapr> FunctorSalad: Look at the other Arbitrary instances?
18:22:10 <FunctorSalad> shapr: ok :)
18:22:28 <shapr> FunctorSalad: It looks like you just implement Arbitrary and it works.
18:22:47 <shapr> And there's a standard definition for shrinking lists in comments.
18:22:49 <thoughtpolice> dons: is gtk2hs for ghc 6.10 in arch and will it install what's necessary to use vacuum-cairo?
18:22:52 <FunctorSalad>   arbitrary = oneof [liftM Left arbitrary, liftM Right arbitrary]
18:22:52 <FunctorSalad>   
18:22:52 <FunctorSalad>   shrink (Left x)  = [ Left  x' | x' <- shrink x ]
18:22:52 <FunctorSalad>   shrink (Right y) = [ Right y' | y' <- shrink y ]
18:22:55 <shapr> johnw: Hiya!
18:23:01 <FunctorSalad> (that's the Either instance)
18:23:01 <johnw> hello!
18:23:11 <shapr> johnw: Written any Haskell lately?
18:23:17 <dons> thoughtpolice: pacman -S gtk2hs is fine.
18:23:24 <dons> but vacuum needs a patch to run the latest version
18:23:26 <FunctorSalad> so it seems you do need to shrink arbitrary components
18:23:31 <johnw> shapr: yeah, a little bit
18:24:02 <thoughtpolice> dons: vacuum needs a patch for vacuum-cairo to work? that's fine; is it in a darcs repo?
18:24:17 <FunctorSalad> shapr: agreed, it often seems to work without implementing shrink ;)
18:24:43 <dons> thoughtpolice: http://galois.com/~dons/tmp/nodeids.dpatch
18:24:45 <shapr> johnw: Any thoughts? good/bad/anything?
18:24:47 <FunctorSalad> but I like to make sure, since shrink is quite nifty
18:24:53 <dons> waiting for mmorrow to apply it
18:25:03 <shapr> FunctorSalad: I agree, shrink is spiffy.
18:26:45 <shapr> dons: My first thought was "finger tree" ! But you beat me to it :-)
18:28:01 <TomMD> vacuum requries ghc == 6.10.1?  Is this the patch you keep mentioning, dons?
18:28:54 <TomMD> Or is that just a gtk2hs patch?
18:30:07 <thoughtpolice> dons: ty
18:30:13 <johnw> shapr: i love it!
18:30:44 <edwardk> ok, finally got the oleg and shan implicit configuration stuff to work with the modern type system. when ghc changed the way it handled 'wobbly' types and all that it broke pretty badly
18:32:06 <edwardk> unfortunately i can't go all the way to a type family for it, the type checker isn't happy with something when i try
18:32:14 <thoughtpolice> edwardk: what you do mean 'the modern typesystem'? i implemented at least the modulus math stuff on 6.10 (although there was a change in scoping that I had to fix)
18:32:28 <thoughtpolice> edwardk: using type families?
18:32:50 <edwardk> thoughtpolice: did you implement their reify and reflect or just the reifyIntegral/reflectIntegral?
18:33:16 <edwardk> reify and reflect don't work directly, since they try to bind a bunch of things in non-rigid contexts, so you have to change some of the examples a bit
18:33:28 <edwardk> er not the examples, but the code to make them cleaner
18:33:32 <thoughtpolice> edwardk: I only did the modulus math stuff, although I did read the rest of the paper
18:34:22 <edwardk> yeah, i tried transcoding the paper into code a year or so back and ran into a block because ghc changed the way it handled scoped type variables
18:34:28 <edwardk> i just now figured out how to get it to work
18:34:35 <pluto> how do you convert a Ratio Integer to decimal notation string?
18:34:48 <mightybyte> Anyone know how to convert a String to [Octet] (from Codec.Utils in the Crypto library)?  I'm not seeing an obvious way.
18:35:23 <dons> TomMD: it probably does need 6.10.x, but the patch is a tiny patch to vacuum
18:35:32 <edwardk> thoughtpolice: http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Reflection.html
18:35:37 <dons> mightybyte: map c2w "foo" ?
18:35:46 <edwardk> i'll add proper attribution, headings, etc. in a second, just wanted to get it to compile ;)
18:36:04 <Gracenotes> functional pearls really are quite fun to read :)
18:36:16 <Gracenotes> most of em anyway
18:36:37 <shapr> johnw: Any questions? :-)
18:36:45 <edwardk> thoughtpolice a lot of the type signatures let the compiler do more work down in the body of 'reify'
18:36:47 <johnw> shapr: working on it:)
18:36:55 <shapr> heh, ok
18:37:20 <edwardk> thoughtpolice: i was somewhat saddened when i tried to turn 'Reflected' into a class using a type family though.
18:37:30 <thoughtpolice> dons: i got the vacuum darcs repo and applied your patch, then installed vacuum-cairo 0.3, but it seems to always show the same graph?
18:37:52 <blackh> pluto: showFFloat (Just places) (realToFrac rat)
18:38:18 <blackh> pluto: import Numeric
18:38:19 <mightybyte> dons: c2w from Data.ByteString?
18:38:30 <edwardk> if i modify Reflected to have a type family Value for its second fundep, then reify :: a -> (forall s. Reflected s a => s -> w) -> w should be able to be rewritten reify :: a -> (forall s. (Reflected s, Value s ~ a) => s -> w) -> w -- but that claims something escapes
18:40:02 <dons> thoughtpolice: could be a refresh issue. try focusing the window, or resizing, and let me know
18:40:20 <thoughtpolice> dons: i just upgraded my system, i'ma restart anyway
18:40:33 <dons> k.
18:49:11 <thoughtpolice> dons: nope, doesn't help; i'm getting an exception from hFlush though because a pipe is broken :/
18:49:19 <pluto> blackh: thanks.
18:51:14 <bremner> Cale: heh, tabular looks pretty overkill. Anyway, I don't want to use any more external libraries.
18:53:09 <thoughtpolice> dons: here's the screenshot - http://img19.imageshack.us/img19/6641/screenxdv.png
19:06:04 <dons> thoughtpolice: oh, you don't have 'dot' installed
19:06:08 <dons> install graphviz
19:06:24 <dons> i should really add a check for that :)
19:23:55 <thoughtpolice> dons: ah
19:23:56 <thoughtpolice> :)
19:24:09 <dons> just pushed a patch to check for graphviz
19:26:52 <thoughtpolice> dons: yay works :) awesome
19:27:00 <eyeris> I have a parsec parser that doesn't *seem* to be consuming all of it's input, but also not returning a parse error. Is there any way I can tell which function consumed the last bit of input?
19:28:31 <dons> thoughtpolice: let me know if you think of something clever  to do with it.
19:29:32 <eyeris> Nevermind, I just found the culprit.
19:31:45 <TomMD> dons: I'm considering using vacuum-cairo to show DHT structures.  The main issue here is that each individual DHT contains values that represent the other instance - not a direct reference to the other instance.  If I could find a way around that during simulation then I'd have something fun.
19:35:13 <sw17ch> TomMD, Distributed Hash?
19:38:23 <defun> Is it me, or haskell very popular at chalmers?
19:42:23 <TomMD> sw17ch: Yes
19:42:36 <sw17ch> TomMD, how mature is it? :)
19:42:40 <TomMD> defun: It isn't just you - the people at Chalmers seem to think Haskell is very popular there too.
19:43:20 <TomMD> sw17ch: Certainly not done.  I've been really lazy about finishing up the 'join' procedure.  Even when its 'done' it isn't an application - just a DHT library so you need to layer some thing on top (like how Tapastry is on top of Pastry).
19:43:42 <sw17ch> TomMD, i've needed some method for distributing ip addresses in scurry
19:43:50 <sw17ch> and some one had mentioned that a DHT might help
19:44:11 <TomMD> sw17ch: Yep - I think we talked about this before and noticed you commented on my DHT reddit proposal.
19:44:18 <sw17ch> TomMD, ah, right :)
19:44:42 <sw17ch> well, when you do finish something up, do let me know
19:44:53 <sw17ch> i'm in the process of a rewrite with scurry :)
19:44:55 <TomMD> sw17ch: I've just been enjoying life too much to finish the library.  Starting courses this week but perhaps the different frame of mind I'll be in will result in more DHT coding, not less.
19:45:04 <TomMD> sw17ch: Will do.
19:45:33 <sw17ch> i actually have a new idea for my messaging...
19:45:49 <sw17ch> i've had a really hard time synchronizing the async stuff
19:45:53 <sw17ch> :)
19:46:28 <sw17ch> and i thought it might be cool to experiment with using green threads as "messages" that generate a packet, ensure it is received, and then clean up
19:46:33 <sw17ch> but, we'll see how that goes
19:47:06 <sw17ch> well, i need to get going
19:47:11 <sw17ch> bye all
20:04:34 <dons> TomMD: should be possible to hack.
20:06:18 <polishookm> can someone recommend a few online beginning tutorials?
20:06:37 <ddarius> See haskell.org
20:06:53 <polishookm> thank you
20:08:48 <sw17ch> any one else have a problem with haskell-src-meta-0.0.3.1
20:08:49 <sw17ch> ?
20:09:41 <TomMD> sw17ch: Worked for me (cabal install haskell-src-meta) but I am using ghc-6.11 if that matters.
20:10:07 <sw17ch> TomMD, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3078#a3078
20:10:10 <sw17ch> any ideas?
20:10:57 <TomMD> sw17ch: What version of haskell-src-exts do you have?
20:11:01 <sw17ch> 0.0.3.1
20:11:04 <sw17ch> latest
20:11:07 <sw17ch> wait
20:11:32 <TomMD> sw17ch: I have 0.4.8, and I'm guessing this is some sort of bad versioning that is biting you.
20:11:43 <sw17ch> i have 0.4.8 as well :\
20:11:50 <sw17ch> or so it seems
20:11:54 * sw17ch reinstalls
20:12:25 <sw17ch> well, that seemed to fix it :\
20:12:45 * sw17ch thinks his GHC install is a little messed up...
20:12:58 <sw17ch> i need to redo this box soon... gentoo is getting to be a problem :'(
20:14:07 <TomMD> sw17ch: Sounds like you have an issue, yeah.  My first Haskell box had hardware issues so I kept almost reporting GHC fatal errors when it was just a hardware goof-up.
20:14:28 <sw17ch> well, now it's telling me it can't find GHC.Paths
20:14:34 <sw17ch> but doesn't complain about missing libraries
20:15:15 <nanothief> A question with the haskell-cafe mailing list, who should I send the message to when replying to a message? Just the author, just the mailing list, or both?
20:16:02 <jedai> just the mailing list, or both (good mail client will see duplicates)
20:16:17 <jmcarthur> nanothief: it is typical to do both or just the mailing list
20:16:26 <sw17ch> any one else get this? --> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3079#a3079
20:16:31 <jmcarthur> nanothief: just the author if you want to move a topic off list
20:17:22 <nanothief> jmcarthur,jedai: ok thanks for the tips
20:17:31 <jmcarthur> sw17ch: i didn't get that. what version of ghc are you on?
20:17:36 <jmcarthur> i'm on 6.10.1
20:17:36 <sw17ch> 6.10.1
20:17:39 <jmcarthur> huh
20:17:41 <sw17ch> i had a bad version of ghc-paths
20:17:43 <sw17ch> it appears
20:17:50 <sw17ch> it's not checked, but seems that vacuum depends on 0.1.0.5
20:18:00 <sw17ch> or i just didn't have it but ghc thought i did :(
20:18:10 <sw17ch> no, scratch that, it's my machine's problem
20:18:12 <jmcarthur> oh, you must be a victim of cabal upgrade or something?
20:19:01 <jedai> I think it's an install of ghc that's using an old packages.conf or something
20:19:15 <sw17ch> jmcarthur, no, managing my own ghc after gentoo had one in there... something about my package config is all screwed up
20:19:39 <jmcarthur> ah
20:20:23 <sw17ch> k, last question, then i give up for the night: dons --> ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3080#a3080
20:21:48 <jedai> i think that's something else
20:22:06 <sw17ch> i'm assuming, i just wish i knew what...
20:22:11 <sw17ch> it appears to me like a library issue
20:22:12 <jmcarthur> sw17ch: 0.3 relies on a patch to vacuum that isn't in hackage yet
20:22:24 <sw17ch> jmcarthur, ah, well that'd do it
20:22:52 <jmcarthur> dons linked to the patch here earlier, but i have no idea how far back
20:23:26 <jmcarthur> sw17ch: here it is http://galois.com/~dons/tmp/nodeids.dpatch
20:23:30 <jmcarthur> i haven't tried it yet
20:23:43 <jmcarthur> i'm just gonna wait for an update to vacuum on hackage
20:23:44 <sw17ch> mm, i'll hope for the best tomorrow and try again then :)
20:23:49 <Gracenotes> X_X
20:24:01 <sw17ch> i'm assuming mmorrow will be quick on this :)
20:24:18 <jmcarthur> so far progress on vacuum seems to be lightning
20:24:28 <ddarius> It's young.
20:24:29 <sw17ch> when it's that cool, i'd expect no less :)
20:27:59 <mriou> hi, I want to get the rounded half length of a list, what I've got is
20:28:00 <mriou> round $ (fromInteger . toInteger $ length [1,2,3]) * 0.5
20:28:16 <mriou> but I'm having a hard time thinking there's nothing shorter
20:28:26 <ddarius> Don't ever use fromInteger.
20:28:29 <ddarius> @src fromIntegral
20:28:29 <lambdabot> fromIntegral = fromInteger . toInteger
20:28:33 <dons> > genericLength  [1,2,3] / 2
20:28:35 <lambdabot>   1.5
20:29:07 <mriou> thanks to both of you, I've checked the prelude on and on but I guess I've missed the best part :)
20:29:22 <ddarius> @index genericLength
20:29:22 <lambdabot> Data.List
20:29:25 <ddarius> @index fromIntegral
20:29:25 <lambdabot> Prelude
20:29:48 <ddarius> @index mapM
20:29:48 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:29:51 <thoughtpolice> dons: I might have fun with vacuum-cairo and xmonad; write an extension, M-v and poof, visualization of the core StackSet :)
20:30:08 <ddarius> @index transpose
20:30:09 <lambdabot> Data.List
20:30:23 <dons> thoughtpolice: mmm. that's a good idea.
20:30:28 <dons> i was wondering how we'd get stackset updates
20:30:31 <ddarius> I guess the non-heirarchical modules have been completely removed from @index's database.
20:31:25 <thoughtpolice> dons: off to the extension writing guide, then! :)
20:40:20 <_dls> hey guys, sorry to bother you but I've got a very confusing case here.... basically "sum (map (+1) [1,2]" is works fine, and "sum . map (+1) [1,2]" throws a type error. any idea what I'm doing wrong?
20:41:03 <TSC> > (sum . map (+1)) [1,2]
20:41:04 <lambdabot>   5
20:41:09 <TSC> Not enough parentheses
20:41:34 <TSC> Without the parens you get...
20:41:40 <TSC> > sum . map (+1) [1,2]
20:41:41 <lambdabot>   Couldn't match expected type `a -> [a1]'
20:41:59 <TSC> Because it's parsing as "sum . (map (+1) [1,2])"
20:42:12 <_dls> TSC: thanks. I'd tried the parens, but had put them before the (+1)
20:42:15 <TSC> The right-hand side of the . is not a function, so it is a type error
20:42:21 <_dls> > (sum . map) (+1) [1,2]
20:42:26 <lambdabot>   Couldn't match expected type `[a]'
20:42:38 <TSC> That won't work for a similar reason (:
20:42:43 <TSC> A common alternative is:
20:42:49 <TSC> > sum . map (+1) $ [1,2]
20:42:54 <lambdabot>   5
20:43:24 <_dls> wait, why doesn't the (sum . map) just return a function that then takes the (+1) as an argument
20:43:34 <TSC> :t sum
20:43:35 <lambdabot> forall a. (Num a) => [a] -> a
20:43:37 <TSC> :t map
20:43:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:43:42 <TSC> :t (.)
20:43:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:44:19 <TSC> If you have f . g, the output type of g should be the input type to f
20:44:38 <TSC> But the output type of map ([a] -> [b]) is not the input type to sum ([a])
20:45:03 <_dls> makes sense. once the (+1) is (curried?) the return type matches, but not before
20:45:22 <TSC> Yeah, the output type of "map (+1)" is [b], which does match the input to sum
20:45:45 <TSC> You'd say that the map is partially applied
20:46:05 <TSC> (Or just applied, depending on your perspective)
20:46:13 <_dls> awesome. thanks a lot :)
20:47:21 <centrinia_> Is it possible to determine if an expression has a certain type at runtime?
20:48:43 <jmcarthur> centrinia_: what is it that you are doing?
20:49:15 <jmcarthur> centrinia_:  typically you will either use an ADT or a type class to do different things for different types
20:50:24 <jmcarthur> besides that, there's Typeable
20:50:26 <centrinia_> Say if a certain expression (Integral a) => a has type Int, then I'll handle it one way, and if it has type Integer, I'll use it differently.
20:51:01 <jmcarthur> i would either have a type class with instances for Int and Integer or a data type with constructors for each
20:51:38 <jmcarthur> depending on whether you will only *ever* have Int or Integer or if you need to be able to extend it with other types elsewhere
20:51:40 <centrinia_> Okay.
20:52:07 <jmcarthur> centrinia_: for oneshot stuff you could even just use Either Int Integer, although it isn't very descriptive that way
20:54:05 <jmcarthur> my guess is that a type class would be more appropriate, but that is without context
20:54:50 <centrinia_> I just looked at Typeable.
20:56:10 * jmcarthur has never needed Typeable and considers it a last resort
21:11:19 * edwardk relaxes having finally got all the modular arithmetic stuff to typecheck. now to apply the same trick to my regex monoid
21:12:26 <ddarius> edwardk: You can't use some kind of monoid homomorphism to map the former to the latter.
21:13:01 <edwardk> ddarius: the only trick is making a monoid that has a type which depends on a term using the Data.Reflection stuff
21:13:59 <edwardk> in the former case its the modulus, in the latter case its the particular DFA i'm using
21:17:21 <edwardk> ddarius: i thought about implementing some of the basic residue number system stuff, but ultimately i just wanted to prove the concept and move on to regexes (regexen?) =)
21:21:43 <ddarius> So when all the dust settles, what is this going to do?
21:22:24 <edwardk> ddarius: lex in parallel and handle incremental updates to the source file quickly
21:23:15 <edwardk> basically i want to see how much of a parallel 'alex'/'parsec' i can put together using this machinery
21:24:37 <blackh> @seen bos
21:24:38 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
21:24:49 <edwardk> another piece that works nicely is the generator framework which provides a nice 'less general than functor' container class
21:25:05 <edwardk> and the set of reducers that can now do a lot of things other than just lex.
21:25:08 <bos> blackh: ?
21:25:32 <blackh> bos: Hello! I was just wondering about whether you wanted Data.Text to implement Ord.
21:25:45 <edwardk> ooh good call
21:25:54 <bos> blackh: it does now, just not yet released
21:26:09 <edwardk> bos: eta on data.text.lazy?
21:26:11 <blackh> bos: Thanks! That answers my question.  I am using it in hexpat, by the way, and boy is it fast!
21:26:17 <edwardk> <- inconsiderate needy end-user
21:26:45 <bos> edwardk: it needs a few days of work, but i don't have a few days to spare.
21:26:50 <bos> blackh: good!
21:27:20 <edwardk> bos: i included a generator for it in my current obsession ;)
21:27:48 * ddarius needs to keep simple mathematical structures away from edwardk.
21:27:57 <edwardk> hahaha
21:28:22 <edwardk> its nowhere near the size of category-extras yet
21:28:24 <edwardk> er.. wait
21:28:27 <edwardk> its catching up fast
21:29:15 <jmcarthur> is Data.Text just Data.ByteString for Unicode strings?
21:29:41 <edwardk> jmcarthur: data.wordstring basically
21:30:04 <edwardk> er Word16String?
21:30:16 <jmcarthur> ah, okay
21:30:59 <jmcarthur> nice, it packs and unpacks with String instead of [Word16]! it's so inconvenient that ByteString packs and unpacks on [Word8]
21:31:17 <ddarius> :t Data.ByteString.Char8.pack
21:31:18 <lambdabot> String -> BSC.ByteString
21:31:26 <jmcarthur> ...
21:31:32 * jmcarthur 's just flipped
21:31:37 <jmcarthur> *world just flipped
21:31:38 <jmcarthur> grr
21:32:29 <ddarius> Admittedly, that just pretends Chars are 8-bit characters, hence Data.Text.
21:35:24 <edwardk> jmcarthur: you can always run it through the utf8 reducer in my monoids library ;)
21:35:42 <edwardk> er bytestrings that is
21:41:21 <thoughtpolice> @tell dons ok I think I might have something almost working with vacuum-cairo, but there is some strange behavior when e.g. compiled
21:41:21 <lambdabot> Consider it noted.
21:46:22 <necroforest> I can't figure this out
21:46:42 <necroforest> I want to write a function that takes a list of strings, and returns a list of strings that is the "cartesian product" of all the strings
21:46:44 <necroforest> I.E
21:47:09 <necroforest> f ["ab", "cd", "e"] = ["ace", "ade", "bce", "bde"]
21:49:04 <edwardk> > join (liftM2 (++)) ["ab","cd","e"]
21:49:05 <lambdabot>   ["abab","abcd","abe","cdab","cdcd","cde","eab","ecd","ee"]
21:49:19 <necroforest> o.O that was short
21:49:48 * edwardk has been using liftM2 mappend a lot the last couple of days, thats just a special case
21:50:00 <necroforest> well, the output isn't quite orrect
21:50:04 <edwardk> oh
21:50:08 <edwardk> then i misunderstood what you want
21:50:17 <necroforest> actually it's completely wrong
21:50:18 <necroforest> lol
21:50:44 <ddarius> > sequence ["ab", "cd", "e"]
21:50:46 <lambdabot>   ["ace","ade","bce","bde"]
21:51:00 <edwardk> ah
21:51:05 <necroforest> that's even better
21:51:24 <edwardk> oh i see what you wanted now
21:52:11 <Gracenotes> @type liftM2 (++)
21:52:12 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
21:52:35 <dons> ?seen mmorrow
21:52:35 <lambdabot> I saw mmorrow leaving #yi, #ghc and #haskell 11h 28m 12s ago, and .
21:52:36 <ddarius> @src sequence
21:52:36 <lambdabot> sequence []     = return []
21:52:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:52:36 <lambdabot> --OR
21:52:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:54:37 <c_wraith> or?
21:54:58 <c_wraith> It's defined twice in different spots?
21:54:58 <edwardk> probably the normal version and the one from Data.Foldable
21:57:21 <wli> The libraries were a lot cleaner when monad comprehensions were still around and map, (++), et al were still general.
21:58:10 <dons> there were no libraries when  monad comprehensions were still around :)
21:58:11 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
21:58:17 <edwardk> hahahaha
21:58:25 <ddarius> dons: Then they were vacuously cleaner.
21:58:35 <dons> :D
21:58:40 <ddarius> edwardk, c_wraith: It's just another definition.
21:58:58 <wli> seriously though
21:59:16 <ddarius> sequence = foldr (liftM2 (:)) (return []) -- a thing of beauty
22:00:53 <edwardk> bah, its shorter in monoids. 'reduceWith getMonadSum' ;)
22:00:53 <wli> @type foldr (liftM2 (:)) mzero
22:00:54 <lambdabot> forall a1 (m :: * -> *). (MonadPlus m) => [m a1] -> m [a1]
22:03:12 <ddarius> That definition of sequence is interesting in what it reveals.  In an impure language it would be: foldr (:) [], but that's "just" id (on lists)
22:04:08 <edwardk> er woops, nope, thats msum
22:04:19 * edwardk goes back to the drawing board
22:04:30 <ddarius> A bit extra would need to be added technically as either in that case everything would already be done or nothing would get done.
22:05:22 <TomMD> @tell dcoutts Whats the plan for making packages persistent across restarts of hackage-server?  I see the storage and where 'update' is called when files are added, but where and how is this information going to be loaded on startup?  All the files could be re-read, but there are less HD intensive ways to do it.
22:05:22 <lambdabot> Consider it noted.
22:17:40 * wli is back to the drawing board, too.
22:39:59 <TomMD> @faq Can haskell give me deterministic IO?
22:39:59 <lambdabot> The answer is: Yes! Haskell can do that.
22:41:06 * wli is at a loss to formalize anything with the sequent calculus -based stuff.
23:20:39 <psygnisfive> is it REALLY this quiet here?
23:20:39 <psygnisfive> god
23:23:03 <Ralith> they knew you were coming, so they all left
23:23:34 <wli> I usually scare people off.
23:24:56 <dons> ?users
23:24:56 <lambdabot> Maximum users seen in #haskell: 658, currently: 553 (84.0%), active: 7 (1.3%)
23:25:18 <psygnisfive> i wonder what the most active was.
23:25:30 <psygnisfive> i bet it never creeps above 10%.
23:26:32 <wli> If I don't manage to creep quite everyone out with my personality and/or appearance, my code is bad enough to send the rest running screaming.
23:37:49 <aivuk> anyone here have some clue why the types of functions in happstack-helpers appers like (String -> happstack-server-0.2.1:Happstack.Server.SimpleHTTP.ServerPartT m a -> happstack-server-0.2.1:Happstack.Server.SimpleHTTP.ServerPartT m a) instead of something like: (String -> ServerPartT m a -> ServerPartT m a)?
23:48:37 <Axman6> dear god i hate probability
23:48:43 <wli> eh?
23:48:47 <Axman6> what a load of crap >_<
23:50:08 <Axman6> "let X be a discrete random vatiable. let Z = b + cX, where b,c are constants. show that E[(Z-µ_Z)^2] = c^2(E[X^2]-µ_X^2)
23:52:47 <Axman6> variable*
23:56:47 <wli> Well, use the sum definitions.
