00:07:10 <ManateeLazyCat> Have IRC channel discuss gtk2hs?
00:08:08 <ManateeLazyCat> I found #gtk+ discuss GTK develop, have any others channel discuss GTK?
00:16:59 <vixey> :t (***)***(***)
00:17:00 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 c1 b'1 c'1. (Arrow a1, Arrow a) => (a b c, a1 b1 c1) -> (a b' c' -> a (b, b') (c, c'), a1 b'1 c'1 -> a1 (b1, b'1) (c1, c'1))
00:17:03 <vixey> :t (&&&)&&&(&&&)
00:17:05 <lambdabot> forall (a :: * -> * -> *) b c c' c'1. (Arrow a) => a b c -> (a b c' -> a b (c, c'), a b c'1 -> a b (c, c'1))
00:17:10 <vixey> :t (+++)+++(+++)
00:17:11 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 c1 b'1 c'1. (ArrowChoice a1, ArrowChoice a) => Either (a b c) (a1 b1 c1) -> Either (a b' c' -> a (Either b b') (Either c c')) (a1 b'1 c'1 ->
00:17:11 <lambdabot>  a1 (Either b1 b'1) (Either c1 c'1))
00:17:56 <pumpkin-> :o
00:18:23 <pumpkin-> those types are a lot scarier than what they represent :P
00:21:42 <Olathe> Arrow type signatures are the work of SATAN
00:22:55 <MyCatVerbs> Heh. Backticks for using types as infix would be really useful there.
00:23:18 <MyCatVerbs> (Arrow a) => a b c, versus (Arrow arr) => (b `arr` c).
00:23:39 <vixey> Arrow (~>)
00:27:39 <pumpkin-> @type (+++)
00:27:41 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
00:29:04 <pumpkin-> > (+1) +++ (*5) $ Left 5
00:29:05 <lambdabot>   Left 6
00:29:07 <pumpkin-> > (+1) +++ (*5) $ Right 5
00:29:09 <lambdabot>   Right 25
00:29:26 <pumpkin-> I'm just dying to do something useful with things like that
00:30:03 <pumpkin-> @type app
00:30:05 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
00:30:10 <vixey> @let one = id
00:30:13 <lambdabot>  Defined.
00:30:15 <vixey> @let million = 10^6
00:30:17 <lambdabot>  Defined.
00:30:18 <vixey> > one million
00:30:19 <lambdabot>   1000000
00:31:02 <pumpkin-> app :: Int -> Int
00:31:04 <pumpkin-> > app :: Int -> Int
00:31:05 <lambdabot>   Couldn't match expected type `Int'
00:31:10 <pumpkin-> oh whoops
00:31:15 <vixey> > one one one one million
00:31:16 <lambdabot>   1000000
00:31:30 <pumpkin-> > app :: (Int -> Int, Int) -> Int
00:31:31 <lambdabot>       Overlapping instances for Show ((Int -> Int, Int) -> Int)
00:31:32 <lambdabot>        arisin...
00:31:45 <pumpkin-> now what the hell do I do with that?? :P
00:32:27 <MyCatVerbs> vixey: -XTypeOperators, though.
00:32:45 <MyCatVerbs> vixey: still! It's a lot cooler with that feature turned on.
00:32:47 <vixey> cool
00:32:53 <vixey> I didn't know that was even possible
00:33:12 * MyCatVerbs duplicates the entirity of Control.Arrow, albeit this time under the name "Pointy" and symbol "==>"
00:33:17 <pumpkin-> :)
00:33:29 <pumpkin-> I thought type operators gave you things like :*:
00:33:34 <pumpkin-> in types
00:33:37 <MyCatVerbs> pumpkin-: yep.
00:33:44 <pumpkin-> this feels even more meta
00:33:55 <pumpkin-> I guess not
00:34:00 <MyCatVerbs> pumpkin-: nah, it's exactly the same.
00:34:05 <pumpkin-> yeah
00:34:13 <MyCatVerbs> chain :: (a ==> b) -> (b ==> c) -> (a ==> c)
00:34:34 <pumpkin-> any idea on what to do with that app function? :)
00:34:47 <vixey> (a >-> b) -> (b >-> c) -> ...
00:35:02 <pumpkin-> ArrowChoice I get, and I use the basic arrow functions/operators quite a bit, but ArrowApply eludes me
00:35:06 <MyCatVerbs> vixey: yeah, that's probably a better choice of operator.
00:35:48 <MyCatVerbs> > (app :: (Int -> Int, Int) -> Int)) ((+3),5)
00:35:50 <lambdabot>   <no location info>: parse error on input `)'
00:35:56 <Gracenotes> oh nos
00:36:01 <dolio> But a >-> b looks like it's monic. :)
00:36:03 <MyCatVerbs> > (app :: (Int -> Int, Int) -> Int) ((+3),5)
00:36:05 <lambdabot>   8
00:36:10 <pumpkin-> @type loop ((+1) *** (*5))
00:36:12 <lambdabot> forall b. (Num b) => b -> b
00:36:18 <vixey> app should be ev
00:36:40 <pumpkin-> MyCatVerbs: wow :)
00:36:41 <dolio> :t curry app
00:36:42 <lambdabot> forall b c. (b -> c) -> b -> c
00:36:50 <pumpkin-> that was simple
00:37:00 <MyCatVerbs> Also, instance (Monad m) => Pointy (Konfuseme m) where... and newtype Konfuseme m a b = Kon { argh :: a -> m b }.
00:37:01 <pumpkin-> > app ((+3), 5)
00:37:03 <lambdabot>   8
00:37:23 <pumpkin-> lol
00:37:34 <MyCatVerbs> Because I always felt that "Kleisli" was an inappropriate name for what goes on in the deep dark dank depths Control.Arrow
00:37:35 <pumpkin-> Konfusemi?
00:37:51 <pumpkin-> just to maintain same start and end letters
00:37:55 <MyCatVerbs> So I made up a more appropriate name for it. :)
00:38:05 <pumpkin-> > loop ((+1) *** (*5)) $ 5
00:38:07 <lambdabot>   6
00:38:11 <pumpkin-> !
00:38:21 <vixey> Kleisli Triple
00:38:40 <dolio> @type proc x do f <- arr id -< x ; returnA -< f
00:38:41 <lambdabot> parse error on input `do'
00:39:00 <MyCatVerbs> pumpkin-: that one was easy, anyway. A tuple of an endomorphism and a value, resulting in another value? Of course the only interesting thing it could be doing would be to apply that endomorphism, zero or more times.
00:39:30 <dolio> @type proc x -> do f <- arr id -< x ; returnA -< f
00:39:31 <lambdabot> parse error on input `->'
00:39:47 <pumpkin-> doesn't it have to be exactly once?
00:39:53 <pumpkin-> for app?
00:40:01 <pumpkin-> oh, you're talking about loop?
00:40:14 <MyCatVerbs> pumpkin-: no, I'm talking about app's *type* when the arrow is (->)
00:40:29 <pumpkin-> app :: a (a b c, b) c
00:40:36 <MyCatVerbs> Methinks that (curry app) has exactly the type I'd expect to see from a Haskell implementation of Church numerals.
00:40:40 <dolio> , proc x -> returnA -< x
00:40:45 <lunabot>  luna: Pattern syntax in expression context: proc x -> returnA -< x
00:40:47 <MyCatVerbs> ...and corresponds to the number 1, too.
00:41:02 <pumpkin-> how could it apply a b c more than once?
00:41:04 <pumpkin-> or less than once :P
00:41:26 <dolio> , let proc = 5 in proc
00:41:27 <lunabot>  5
00:41:34 <dolio> > let proc = 5 in proc
00:41:35 <lambdabot>   5
00:41:42 <Cale> Hmm, Gnome's sort order for Japanese items seems ridiculous... あ comes before い (which is fine), but とい comes before とあ.
00:41:43 <dolio> Nobody's got arrow syntax.
00:41:56 <vixey> hi Cale
00:41:58 <Cale> hi
00:42:11 <MyCatVerbs> , let churchToInt f = f (+1) 0 in churchToInt (curry app)
00:42:12 <lunabot>  luna: Not in scope: `app'
00:42:17 <wli> Back.
00:42:19 <MyCatVerbs> > let churchToInt f = f (+1) 0 in churchToInt (curry app)
00:42:21 <lambdabot>   1
00:43:00 <vixey> Cale, I don't know how into type/set foundations but I found this really interesting bit about interpreting them in each other (I think we talkde about powersets a bit)
00:43:18 <pumpkin-> Cale: that does seem odd, have you checked http://en.wikipedia.org/wiki/Gojūon ?
00:43:26 <vixey> which is http://www.lix.polytechnique.fr/~werner/publis/tacs97.pdf
00:43:26 <MyCatVerbs> > let { intToChurch n f x = if n == 0 then x else intToChurch (n-1) f (f x); churchToInt f = f (+1) 0 } in churchToInt (intToChurch 40)
00:43:28 <lambdabot>   40
00:43:45 <pumpkin-> MyCatVerbs: any similarly succinct explanation for loop?
00:43:48 <MyCatVerbs> @type let { intToChurch n f x = if n == 0 then x else intToChurch (n-1) f (f x); churchToInt f = f (+1) 0 } in intToChurch 0
00:43:49 <lambdabot> forall t. (t -> t) -> t -> t
00:44:12 <MyCatVerbs> Note that that has almost the same type as app. :)
00:44:20 <MyCatVerbs> I don't know. What does loop do? =D
00:44:23 <MyCatVerbs> @type loop
00:44:25 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
00:44:31 <pumpkin-> > loop ((+1) *** (*5)) $ 5
00:44:33 <lambdabot>   6
00:44:36 <pumpkin-> not much from what I can see :)
00:44:56 <pumpkin-> but my types aren't very illustrative
00:45:03 <Cale> pumpkin-: That's what I would have expected at least for things which are purely kana.
00:45:09 <cinimod> @hoogle Monad m => (a -> Bool) -> [m a] -> m ()
00:45:10 <lambdabot> Foreign.Marshal.Error throwIf_ :: (a -> Bool) -> (a -> String) -> IO a -> IO ()
00:45:10 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
00:45:10 <lambdabot> Foreign.C.Error throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
00:45:10 <pumpkin-> yeah
00:45:51 <Gracenotes> oh nos
00:45:59 <cinimod> @hoogle Monad m => (a -> Bool) -> [m a] -> m [a]
00:46:00 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
00:46:00 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
00:46:00 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
00:46:21 <MyCatVerbs> pumpkin-: oh! The first parameter is the input to the function that you want to create using loop.
00:46:30 <Cale> pumpkin-: But it seems kana and kanji get mixed up in a way which makes no sense, and even latin things get sorted in between. Even just with kana, the order isn't lexicographical, but it's certainly doing *something*. It produces a consistent order based on the names, but for all I know it could just be hashing them all. :)
00:46:39 <pumpkin-> yeah
00:46:40 <pumpkin-> http://www.unicode.org/unicode/reports/tr10/
00:46:54 <MyCatVerbs> pumpkin-: the second parameter - that funky, what-the-Hell-is-it-doing-there? forall d. d, is the recursive parameter in something like "fix".
00:46:59 <pumpkin-> never looked much into their collation function, scary stuff
00:47:13 <pumpkin-> MyCatVerbs: but it doesn't seem to be doing anything with it? did I just pick a bad example?
00:47:48 <MyCatVerbs> @type \f x -> let (r,z) = f (x,z) in r
00:47:51 <lambdabot> forall t t1 t2. ((t, t2) -> (t1, t2)) -> t -> t1
00:47:58 <pumpkin-> :o
00:48:00 <MyCatVerbs> Probably that.
00:48:21 <MyCatVerbs> I'm guessing. I haven't looked inside the source. =)
00:48:29 <pumpkin-> I could just do that :)
00:48:39 <pumpkin-> but given the funky type, there aren't that many options that make sense I guess
00:48:58 <MyCatVerbs> > loop (\(input,recur) -> (toUpper input,recur)) 'a'
00:49:00 <lambdabot>   'A'
00:49:05 <MyCatVerbs> There, something nice and trivial. :)
00:49:25 <pumpkin-> so... next question is: why??
00:49:26 <pumpkin-> :P
00:49:35 <MyCatVerbs> > loop (\(input,recur) -> ((take 3 recur) ++ [toUpper input],'a':recur)) 'a'
00:49:36 <lambdabot>   "aaaA"
00:49:44 <paulvisschers_> Is there a function that converts for a unix timestamp to an UTCTime?
00:49:56 <paulvisschers_> for := from
00:49:57 * pumpkin- ponders MyCatVerbs's latest
00:50:05 <MyCatVerbs> Ha! So it's just Data.Function.fix, written backwards, uncurried.
00:50:09 <pumpkin-> lol
00:50:18 <Gracenotes> @type \f -> liftM (filter f) . sequence
00:50:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [m a] -> m [a]
00:50:36 <MyCatVerbs> pumpkin-: the scary thing is it's almost 9am and I did not sleep last night.
00:50:46 <pumpkin-> wow, maybe you should sleep
00:51:01 * wli is having trouble sleeping.
00:51:02 <pumpkin-> or no ArrowLoops for you tomorrow!
00:51:27 <MyCatVerbs> pumpkin-: if sleep deprivation is what it takes for this kinda stuff to make sense to me, perhaps I should stay up right 'til Monday and then try arrow *notation*, too! =D
00:51:34 <pumpkin-> lol
00:52:00 <pumpkin-> where is the notation defined?
00:52:13 <pumpkin-> I've seen stuff like --< or something
00:52:21 <MyCatVerbs> To the Google mobile!
00:52:43 * MyCatVerbs slams headfirst into GHC's user manual.
00:52:53 <pumpkin-> I'm on that page now
00:52:57 <MyCatVerbs> Apparently, in about a half dozen research papers. :)
00:55:03 <MyCatVerbs> When people say one typeclass is "more general" than another, do they mean the more general one is the one which applies to more types? Or the one which defines more powerful operations?
00:55:03 * wli goes back to attempting to write a type checker/inferencer.
00:55:52 <vixey> MyCatVerbs, that confused me too. . I think it's like Applicative is more general than Monad because there are more things which are Applicatives
00:56:21 <MyCatVerbs> vixey: methinks that you have answered my query.
00:56:49 <MyCatVerbs> vixey: thank you very much, kind Haskell hacker.
00:58:36 <kiris> where's taht parsec library that's top-down parsing?
00:58:37 <Eridius> vixey: Applicative is Monad without binding
00:58:51 <kiris> it was like a readp kind of parsec
00:58:52 <kmeyer> kiris: it's called parsec...
00:58:58 <kmeyer> oh
00:59:03 <kmeyer> sorry :)
00:59:28 <kiris> it's not released anywhere, someone posted a link in here a while ago to a source dir but I don't have the log
01:00:16 <pumpkin-> it's in the topic if you know what to search for, but parsec is mentioned so often it's probably hard
01:00:41 <pumpkin-> and google doesn't seem to index it
01:04:18 <wli> I'm stumped as to how to represent type schemes for H-M, never mind qualified types or row types.
01:05:44 <wli> I wonder where that on-the-fly GLR parser went.
01:06:18 <wli> (At least I think it was on the fly; I never got it working and never understood the code.)
01:08:21 <wli> I'm not entirely sure how one should go about that. I'm guessing grammar construction combinators and then crap that converts the grammar data structure constructed to a state machine transition table, then more crap that carries out the state transitions to parse.
01:09:45 <wli> WIth the machine resources going around these days I wonder moderately seriously if context-sensitive grammars are approachable.
01:11:55 <maxote> wli, the GLR parser uses CFG, it's Context-Free Grammar.
01:12:07 <wli> I know what GLR is.
01:13:28 <pumpkin-> o.O
01:13:29 <cinimod> @hoogle Monad m => [(Bool, m ()] -> m ()
01:13:30 <lambdabot> Parse error:
01:13:30 <lambdabot>   --count=20 "Monad m => [(Bool, m ()] -> m ()"
01:13:30 <lambdabot>                                     ^
01:13:33 <archersako> hello, is there a channel on freenode that offers help for scheme?
01:13:54 <cinimod> @hoogle Monad m => [(Bool, m ())] -> m ()
01:13:54 <lambdabot> No results found
01:14:09 <maxote> the automaton for the context-sensitive grammars should be as a Turing Machine.
01:14:30 <wli> It's not. It's a Linear-Bounded Automaton.
01:14:53 <cinimod> @hoogle Monad m => [(Bool, m a)] -> m [a]
01:14:54 <lambdabot> No results found
01:14:57 <Gracenotes> @type map snd . filter fst
01:14:58 <lambdabot> forall b. [(Bool, b)] -> [b]
01:15:14 <cinimod> I want a monadic version
01:15:17 <Gracenotes> @type mapM snd . filter fst
01:15:19 <lambdabot> forall (m :: * -> *) b. (Monad m) => [(Bool, m b)] -> m [b]
01:15:44 <kiris> proggit of recent: suddenly: Prolog!
01:15:55 <Gracenotes> heh
01:15:59 <cinimod> I was hoping for a library. It's easy enough to define yourself.
01:16:29 <Gracenotes> indeed, it's quite easy :) I'm not sure if that one's that common though
01:16:54 <pumpkin-> I've needed it a few times, the non-monadic one
01:17:02 <cinimod> There's something called monad loops (or something like that) but it looks very new
01:17:17 <Gracenotes> Control.Monad could use some nice extra functions though
01:17:20 <cinimod> A library on hackage I mean
01:18:05 <maxote> wli, i don't know the algorithm for the Linear-Bounded Automaton nand its complexity :(
01:18:09 <Gracenotes> still, what is has it composes well, it seems... X:
01:18:13 <Gracenotes> it
01:18:55 <pumpkin-> linear-bounded automaton = turing machine minus the infinite tape
01:20:11 <maxote> i know that grammars over CFGs are the NLP (Natural Language Processing in A.I.), chart parsing and forest parsing.
01:20:51 <pumpkin-> ?
01:21:07 <Gracenotes> I don't X_X
01:21:49 <maxote>  /are/are in/
01:22:04 <wli> Not just that, they can only reduce their workspace.
01:22:52 <wli> They get the original string as workspace, and can shorten and modify the string only as they work.
01:27:10 <maxote> pumpkin-, what's the maximum bound size of the finite tape for max. size of input's string in Linear-Bounded Automaton? O(k*n)? O((k*n)^2)? O((k*n)^3)? any idea?
01:27:41 <pumpkin-> how do you mean?
01:28:48 <maxote> what's the max. bound of the number of cells of the finite tape to recognize a language that has almost n symbols?
01:29:59 <pumpkin-> seems like if someone has figured such a relationship out (I'm definitely not knowledgeable about this stuff beyond the basics), it wouldn't differ from a regular turing machine
01:34:44 <maxote> i know that the max. bound of the finite tape for CFG is n for a language that has almost n symbols.
01:35:43 <altmattr> what is the best way to do data-type generics in ghc these days?
01:36:09 <vixey> altmattr I think it depends on what you want to do
01:36:47 <altmattr> defining substitution over HsModule
01:36:57 <altmattr> actually, a similar thing for another source lang
01:37:05 <altmattr> but best explained this way I think
01:37:28 <altmattr> HsModule is the datatype for haskell source code taht you get from Langauge.Haskell
01:37:37 <vixey> HsModule is a single data type
01:38:18 <altmattr> yeah, but I don't want to have to write the traversal 'boilerplate'
01:40:59 <altmattr> I had a feeling there was a generics library beind developed
01:41:06 <altmattr> or I could use Generic Haskell
01:41:10 <altmattr> or the SYB libraries
01:41:34 <altmattr> I am just wondering which of these (or some other) is generally preferred
01:45:49 <altmattr> hooey - hackage shows up a whole mess of alternatives
01:47:17 <Eridius> those darn developers, thinking they can write competing libraries. Why can't there just be one library for everything! ;)
01:47:23 <altmattr> let's take a pot shot........ syb, it has the finest name after all and the wiki is pretty
01:48:06 <altmattr> Plus, I think I already understand the everywher and everthing functions
01:49:07 <Eridius> ah yes, pretty == good. I learned just how wrong that could be in a course at college ;)
01:49:41 <Eridius> 3 libraries to choose from, every group in the class chose the same one because it had by far the best documentation. Later that year someone who worked on that library (it was the product of a previous course) apologized profusely to everyone who had to use it
01:50:01 <altmattr> ha!
01:50:19 <altmattr> I find there is rarely any overlap between programming ability and design talent
01:50:38 <Eridius> especially when it's the product of a course (i.e. people are required to do it, rather than doing it because they want to)
01:50:46 <altmattr> indeed
01:51:05 <altmattr> making things pretty is still a great way to cover up crappy work at uni/college though
01:55:10 <daf> design also comes into programming
01:55:23 <daf> I know good programmers who can't design software
01:55:33 <daf> they are good at getting things done, but their taste is questionable
01:55:55 <altmattr> daf: you water-muddier you :)
01:56:02 <daf> :)
01:56:11 <MyCatVerbs> maxote: the clue is in the name.
01:57:25 <MyCatVerbs> maxote: a linear bounded automaton is a Turing machine which is given, for some fixed k, k*n cells of tape to work on, where n is the input size.
01:57:38 <MyCatVerbs> maxote: so O(n).
01:58:12 <maxote> good for no stack overflow
01:58:51 <Axman6> i wrote a turing machine in haskell once, and implemented addition in it. took a long time :(
01:59:30 <pumpkin-> unary addition?
01:59:38 <pumpkin-> :P
03:05:07 <Axman6> uh?
03:05:10 <Axman6> eh*
03:05:12 <Axman6> rawr
03:40:29 <tibbe> @seen dcoutts
03:40:30 <lambdabot> dcoutts is in #haskell-soc, #haskell, #ghc, #gentoo-haskell, #haskell-overflow and #darcs. I don't know when dcoutts last spoke.
03:42:06 <trofi> @uptime
03:42:06 <lambdabot> uptime: 1d 13h 30m 40s, longest uptime: 1m 10d 23h 44m 29s
03:42:58 <ivanm> @seen dcoutts_
03:42:59 <lambdabot> dcoutts_ is in #haskell and #ghc. I last heard dcoutts_ speak 12h 50m 9s ago.
03:43:03 <ivanm> @seen dcoutts__
03:43:04 <lambdabot> I haven't seen dcoutts__.
03:43:05 <ivanm> ;-)
03:43:56 <trofi> @go http://code.haskell.org
03:44:12 <lambdabot> Plugin `search' failed with: thread killed
03:44:17 <ivanm> trofi: ummm..... I don't think that would work
03:44:24 <ivanm> @go inurl:code.haskell.org
03:44:39 <lambdabot> Plugin `search' failed with: thread killed
03:44:42 <trofi> :p
03:44:43 <has> ciao ivanm
03:44:50 <ivanm> ciao has
03:45:03 <has> coe va lavita
03:45:15 <ivanm> I'm not Italian, sorry ;-)
03:45:42 <Eelis> i've installed a binary ghc package from haskell.org with --prefix=$HOME/soft. to run it, i need to export LD_LIBRARY_PATH=$HOME/soft/lib, otherwise it can't find its dependencies (e.g. libedit.so.0). now, i'm reading (and finding out) that LD_LIBRARY_PATH is actually evil, and that binaries should be linked with -rpath to remove the need for LD_LIBRARY_PATH.
03:45:47 <Eelis> is there a way to install the binary ghc package from haskell.org in a custom location in such a way that one doesn't need to set LD_LIBRARY_PATH to run it?
03:45:48 <has> mi scusi tu no parli italiano
03:45:48 <ivanm> has: people in #haskell-it probably do though ;-)
03:46:06 <has>  :)
03:46:25 <ivanm> heh (/me thinks he worked out what has just said...)
03:46:39 * vixey thinks he worked out what has just said...
03:46:50 <vixey> O_O
03:46:55 <has>  :D
03:47:05 <Axman6> parli == speak?
03:47:08 <ivanm> yeah
03:47:09 <vixey> some how what you wrote there was clickable.. so I cliked it ...
03:47:21 <Axman6> excuse me, you don't speak italian?
03:47:40 <ivanm> Axman6: either that, or he translated what I said in English ;-)
03:47:50 <Axman6> ah, indeed
03:47:51 <has> ciao axman6
03:47:57 <trofi> [:
03:48:00 <Axman6> G'Day
03:48:06 <Axman6> G'Day has*
03:48:26 <ivanm> O...K... then...
03:49:53 <trofi> who can fix http://code.haskell.org here?
03:56:25 <Axman6> how interesting, seems sun dows work on both PostgreSQL and own MySQL
03:56:29 <Axman6> does*
03:57:26 <cnwdup> Damn, just entered rm Main.hs instead of vim Main.hs. )): Fortunately Main.hs didn't contain anything important. Still, I might should shower before I code.
03:57:33 <cnwdup> Or enable automatic backups in vim...
03:58:03 <trofi> SCMs is a good thing
04:01:05 <MyCatVerbs> cnwdup: for the love of Eris, use darcs.
04:02:00 <FunctorSalad> trofi: I guess you're referring to something else than "Serial_Copy_Management_System" :)
04:02:17 <Eridius> MyCatVerbs: for the love of Zeus, use git.
04:02:31 <FunctorSalad> ah http://en.wikipedia.org/wiki/Source_Code_Management
04:02:55 <Eridius> DVCS FTW
04:03:08 <cnwdup> MyCatVerbs, somehow I use that way to infrequent. I'm not planning on publishing anyways.
04:03:19 <FunctorSalad> Eridius: dunno, I'm a version control noob but I found darcs easier to use than git so far :)
04:03:34 <FunctorSalad> git-<auto complete> is just scary
04:03:38 <Eridius> cnwdup: sounds like a good way to accidentally lose your data
04:03:49 <ivanm> Axman6: Sun owns both ;-)
04:03:50 <Eridius> FunctorSalad: that's because you're looking at all of the internal tools
04:03:56 <Eridius> it's like opening up the darcs source and reading all the fucntions
04:03:58 <Eridius> *functions
04:03:59 <Axman6> ivanm: really? :o
04:04:14 <ivanm> IIRC, anyway...
04:04:23 <ivanm> note they have different strengths
04:04:32 <trofi> FunctorSalad: http://acronyms.thefreedictionary.com/Source+Code+Management :]
04:04:59 <ivanm> Axman6: according to wikipedia, I lie :s
04:05:15 <Axman6> i knew they bought MySQL
04:07:28 * ivanm wonders if it'd be worth creating a haskellian-DB, such as erlang's mnesia
04:07:46 * wli recalls his decade-long effort to write a symbolic integration routine for elliptic integrals in terms of inverse Jacobian elliptic functions.
04:08:50 <wli> What would a Haskellian DB be? I've no idea what Erlang's mnesia is.
04:09:04 <Axman6> ivanm: i've suggested it before
04:09:30 <ivanm> wli: mnesia uses erlang data structures and erlang syntax for queries rather than SQL
04:09:41 <Axman6> but it's distributed
04:09:53 <Axman6> anc ocncurrent and all that good shit
04:09:54 <Axman6> >_>
04:10:06 <ivanm> and soft-tolerant or whatever it is...
04:10:20 <ivanm> Axman6: then again, it's syntax is funky ;-)
04:10:40 <ivanm> a haskell front-end to erlang's runtime environment would be pretty cool
04:10:50 <Axman6> yeah
04:11:08 <ivanm> though I'd think that performance wise (even for parallelism and concurrency), direct compilation would probably still be better
04:11:09 <Axman6> though, haskell threads can out persorm elrang ones for certain things
04:11:27 * Axman6 points to his thread-ring program on the shootout
04:11:27 <Axman6> >_>
04:12:57 <MyCatVerbs> Axman6: not necessarily. Erllang's message passing is much more general than Haskell's MVars.
04:13:11 <Axman6> indeed
04:13:20 <ivanm> wli: http://en.wikipedia.org/wiki/Mnesia
04:15:16 <wli> My boss always said he wished he could use Prolog for database queries.
04:15:31 <wli> Well, before he got promoted.
04:17:09 <vegai> does Happstack's Data qualify as a haskellian db?
04:17:34 <goltrpoat> wli, i remember having the same thought the last time i had to touch db stuff
04:17:48 <wli> re goltrpoat ltns
04:17:59 <goltrpoat> indeed
04:18:27 <wli> goltrpoat: Things have not been going well for me for the past year or so.
04:18:33 <ivanm> what provides Data.Digest.Pure.SHA?
04:18:45 <trofi> @hoogle Data.Digest.Pure.SHA
04:18:47 <lambdabot> package HsHaruPDF
04:19:06 <ivanm> I don't think that's it, somehow ;-)
04:19:22 <goltrpoat> wli:  sorry to hear that..  job market stuff?
04:19:26 <ivanm> ahhh, SHA
04:19:27 <ivanm> dugh ;-)
04:21:27 <wli> goltrpoat: No, my job is the only thing saving my arse right now. A lot of medical problems, some other (severe) living arrangement difficulties (no euphemistic way to describe it without inadvertently trivializing it).
04:24:01 <dcoutts> tibbe: pong
04:24:49 <tibbe> dcoutts: I was going to ask you if we had some log files I could use to benchmark a log analysis library I'm writing but I found some :)
04:24:50 <goltrpoat> wli:  that sucks.  hope things improve.
04:25:27 <jpcooper> is there a simple way in which to block the main action indefinitely?
04:25:32 <jpcooper> apart from reading from an empty MVar
04:25:54 <Saizan> ivanm: happstack-state meets the "use haskell types and haskell for queries" and distributed requirement, though it's not designed around a central data store
04:26:11 <ivanm> Saizan: oh? you can do queries, etc. with it?
04:26:24 <augustss> jpcooper: you can probably block all signals and then wait for a signal
04:26:35 <jpcooper> right
04:27:03 <Saizan> ivanm: you write them as MonadState and MonadReader actions
04:27:10 <ivanm> *nod*
04:28:13 <wli> I've found MonadRWS handy.
04:28:37 <Saizan> if you need something vaguely relational there's -ixset, though it needs some work on optimization
04:29:06 <ivanm> I don't need it, was just wondering
04:29:11 <wli> Saizan: I've had needs for maintaining multiply-indexed data in-core. What's ixset?
04:30:04 <Saizan> wli: it's an heterogeneous list for Data.Map's, implemented with Typeable
04:30:22 <Saizan> wli: the package is called happstack-ixset
04:30:59 <wli> From http://happstack.com/docs/0.2/happstack-ixset/0.2/Happstack-Data-IxSet.html it doesn't seem to be what I'm after.
04:31:32 <Raevel> is there a good introduction ho happs(tack)?
04:32:00 <Saizan> the site has links to tutorials
04:32:37 <Saizan> wli: well, it keeps multiple indexes for a set of values
04:32:39 <dcoutts> tibbe: ok
04:32:40 <wli> I'm looking more for things like R-trees, KDB trees, et al.
04:32:50 <m4nic> hi all, how do I get the last inserted id from the sqlite database using haskell HDBC. Cannot find in online. Tried selecting OID but that doesn't seem to be solid.
04:32:50 <Raevel> "build a web 2.0 app in happstack" :-D
04:32:54 <Saizan> ah, i see
04:33:20 <wli> Saizan: The part that kills me is combined numerical/spatial and string queries.
04:34:04 <wli> Saizan: In fact substring/regex queries alone blow me away, but I've got worse floating around.
04:34:15 <Saizan> wli: yeah, the structures i've seen seem to require numerical indexes
04:36:30 <Azstal> m4nic: "select last_insert_rowid();"
04:36:51 <wli> Saizan: Prefix queries are easy enough, though. Also pointwise full matching queries.
04:37:47 <m4nic> Azstal: thanks a lot!
04:37:53 <wli> I've not been able to write a decent hash trie in Haskell because of the awkward array monad garbage.
04:38:10 <wli> That's relatively devastating.
04:42:13 <Fredrik_> @pl \b -> wins b two
04:42:13 <lambdabot> flip wins two
04:42:40 <Fredrik_> @t flip
04:42:40 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:42:44 <Fredrik_> :t flip
04:42:44 <vixey> loses two
04:42:45 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:42:59 <Fredrik_> @src flip
04:42:59 <lambdabot> flip f x y = f y x
04:43:01 <Fredrik_> lol
04:43:04 <Fredrik_> so obvious
04:43:06 <vixey> flip f y x = f x y
04:43:25 <Saizan> wli: you mean ST, or MArray?
04:43:52 <wli> Both, actually.
04:45:03 <wli> Trees of arrays are tough to get past the typechecker when you update the arrayd.
04:47:02 <Saizan> yeah, the region parameter can get pretty annoying, it contamintes all your structures and you've to be careful about adding signatures
04:50:10 <wli> I'm still stumped wrt. representing type schemes.
04:53:07 <Fredrik_> \i -> (i, move board Player2 i)
04:53:09 <Fredrik_> @pl \i -> (i, move board Player2 i)
04:53:09 <lambdabot> ap (,) (move board Player2)
04:53:23 <Fredrik_> :t ap
04:53:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:53:31 <Fredrik_> @src ap
04:53:32 <lambdabot> ap = liftM2 id
04:53:44 <vixey> @pl \i -> (id i, move board Player2 i)
04:53:44 <lambdabot> ap (,) (move board Player2)
04:53:53 <vixey> @pl \i -> (ide i, move board Player2 i)
04:53:53 <lambdabot> liftM2 (,) ide (move board Player2)
04:54:22 <vixey> @let (&) = liftA2 (,)
04:54:25 <lambdabot>  Defined.
04:54:26 <vixey> :t id & ?f
04:54:27 <Fredrik_> :t id
04:54:28 <lambdabot> forall a. a -> a
04:54:28 <lambdabot> forall a b. (?f::a -> b) => a -> (a, b)
04:54:43 <vixey> > "foo" & "bar"
04:54:45 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
04:54:49 <vixey> > (id & reverse) "quux"
04:54:51 <lambdabot>   ("quux","xuuq")
04:55:22 <Fredrik_> :t (,)
04:55:23 <lambdabot> forall a b. a -> b -> (a, b)
04:56:46 <Fredrik_> What exactly does this ap do, I dont get it.
04:59:47 <Fredrik_> > let foo = (,) `ap` (^2) in foo 5
04:59:49 <lambdabot>   (5,25)
04:59:52 <Fredrik_> how exactly does that work???
05:00:27 <vixey> :t do a <- (^2) ; (,) a
05:00:28 <lambdabot> forall a. (Num a) => a -> (a, a)
05:00:47 <vixey> > (do a <- (^2) ; (,) a) 5
05:00:49 <lambdabot>   (25,5)
05:02:48 <blueonyx> :t ap
05:02:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:05:01 <wli> I guess TypeApp (TypeScheme typeVar) (TypeScheme typeVar) | TypeConst TypeConst | TypeVar typeVar plus crud for row types, whatever the analogue of row types for variants is called, and qualifiers.
05:07:51 <paulvisschers_> Is there an easy way to round a floating point to 2 decimals?
05:07:53 <Fredrik_> @pl \i w -> wins w Player2
05:07:53 <lambdabot> const (flip wins Player2)
05:08:44 <PeakerWork> :t [ap, undefined::(a->b->c)->(a->b)->(a->c)]
05:08:45 <lambdabot> forall a b a1. [(a1 -> a -> b) -> (a1 -> a) -> a1 -> b]
05:09:08 <wli> %.2g in Text.Printf?
05:09:18 <vixey> :t [ap, undefined::x->y]
05:09:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m (a -> b) -> m a -> m b]
05:09:38 <vixey> :t [ap, undefined::x->y->z->w]
05:09:39 <lambdabot> forall a b z. [(z -> a -> b) -> (z -> a) -> z -> b]
05:09:49 <Fredrik_> @pl \i w -> wins Player2 w
05:09:49 <lambdabot> const (wins Player2)
05:09:53 <PeakerWork> Fredrik_: f `ap` g  when f and g are functions -- means that both f and g are funcs of the same arg, builds a func that gives the arg to both these funcs, and then applies left result to right result
05:09:54 <paulvisschers_> Actually, I want to print it with 2 decimals, so 1 become 1.00 and pi becomes 3.14 etc
05:10:24 <PeakerWork> Fredrik_: so in the context of functions, ap is:   (a->b->c)->(a->b)->(a->c)
05:10:27 <wli> Check Text.Printf
05:10:31 <paulvisschers_> and while I'm at it, how do I print numbers with comma's for every thousand, like 10,000 instead of 10000?
05:10:40 <Fredrik_> PeakerWork thx
05:11:42 <Fredrik_> @pl \(i, w) = wins Player2 w
05:11:43 <lambdabot> (line 1, column 9):
05:11:43 <lambdabot> unexpected "="
05:11:43 <lambdabot> expecting operator, pattern or "->"
05:11:58 <PeakerWork> paulvisschers_: you can divide it into groups of 3 and then intercalate the result with ","
05:12:04 <Fredrik_> @pl \x = wins Player2 $ snd x
05:12:04 <lambdabot> (line 1, column 4):
05:12:04 <lambdabot> unexpected "="
05:12:04 <lambdabot> expecting operator, pattern or "->"
05:12:09 <paulvisschers_> wli: I'll try that
05:12:14 <Fredrik_> @pl \x -> wins Player2 $ snd x
05:12:14 <lambdabot> wins Player2 . snd
05:12:45 <paulvisschers_> PeakerWork: That's possible, but I'd rather use something that is already made for this
05:12:58 <PeakerWork> paulvisschers_: Maybe you want to use locale-based functions then
05:16:25 <paulvisschers_> PeakerWork: Such as?
05:17:11 <PeakerWork> paulvisschers_: I'm not sure, I don't know them very much, but libc has functions that use the locale to choose number/date/etc formatting, and Haskell probably has wrappers for those.. Try to look up locale stuff in the docs
05:40:33 <paper_cc> @hoogle Locale
05:40:34 <lambdabot> package old-locale
05:40:34 <lambdabot> package setlocale
05:42:12 <jpcooper> @hoogle isioerror
05:42:12 <lambdabot> No results found
05:42:46 <hoknamahn__> guys, anyone knows what the hell this means? when i'm trying to make a qtHaskell package I have this error
05:42:49 <hoknamahn__> Configuring qtc-1.1.2...
05:42:51 <hoknamahn__> Setup: At least the following dependencies are missing:
05:42:52 <hoknamahn__> OpenGL -any
05:43:02 <hoknamahn__> what that any means?
05:43:12 <ivanm> hoknamahn__: you need to have the haskell opengl package installed
05:43:28 <hoknamahn__> cool thanks ivanm
05:44:00 <ivanm> no worries
05:44:05 <hoknamahn__> is it hopengl?
05:44:34 <ivanm> sounds about right
05:44:43 <hoknamahn__> okay thanks again
05:47:15 <Saizan> the package has to be called OpenGL
05:47:54 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL-2.2.1.1
05:48:00 <ivanm> Saizan: that's what the package .cabal file has to be called, but it might be called something else on hackage
05:48:30 <dcoutts_> ivanm: no they must be the same, it's enforced.
05:48:47 <ivanm> oh? even for capitilisation?
05:48:59 <dcoutts_> yes
05:49:03 <ivanm> @tell matthew-_ do you want me to try and get graphviz using the new polyparse API?
05:49:03 <lambdabot> Consider it noted.
05:49:22 <dcoutts_> ivanm: package name, tarball file name and .cabal file name must match.
05:49:44 <ivanm> duh, when using "cabal sdist", etc. it creates the tarball that way
05:50:05 <dcoutts_> ivanm: and if you do it any other way hackage will complain
05:50:10 <ivanm> *nod*
05:51:06 <ivanm> hmmm.... reading bos' reply on -cafe about bytestring vs uvector... why doesn't bytestring do fusion anymore? wasn't that one of the original points of bytestring, that it did all this fusion optimisation?
05:51:50 <ivanm> "If you want to use either library, understand that you're embarking on a bracing adventure." <-- heh
05:51:54 <hoknamahn__> so all haskell packages have to be installed using cabal?
05:52:01 <ivanm> hoknamahn__: no
05:52:09 <ivanm> (if by cabal you mean cabal-install)
05:52:14 <hoknamahn__> i'm confused
05:52:35 <hoknamahn__> when i have to use standard package system and when cabal?
05:52:56 <dcoutts_> hoknamahn__: if a Haskell package is provided by your distro then use that
05:52:58 <ivanm> hoknamahn__: if your system packages are up-to-date, use them
05:53:47 <dcoutts_> hoknamahn__: for things not provided by your distro you can use the cabal command line tool, which is a bit like a secondary package manager for Haskell packages (but not as mature as the system ones)
05:53:50 <ivanm> which, AFAIK, limits you to arch, gentoo and nix
05:53:54 <ivanm> *nixOS
05:54:02 <ivanm> kosmikus: there, I spruiked your baby, happy? :p
05:54:33 <ivanm> hoknamahn__: cabal-install doesn't ensure the C-libs, etc. that haskell packages need are installed, for example
05:55:18 <kowey> dear haskellers, http://lists.osuosl.org/pipermail/darcs-users/2009-March/018193.html <-- comments welcome!
05:55:41 <hoknamahn__> okay make sense
05:55:45 <hoknamahn__> thx
05:55:55 <ivanm> @ask kowey what, couldn't you give us the executive summary of what you expected us to comment on? :p
05:55:56 <lambdabot> Consider it noted.
06:12:53 <tibbe> then new exception library confuses me some, how do I simply catch all exceptions using "handle"?
06:13:45 <Heffalump> tibbe: you don't
06:13:58 <Saizan> with SomeException
06:14:09 <Saizan> i.e. using that as the exception type
06:14:38 <Axman6> :t Control.Exception.handle
06:14:39 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
06:15:11 <Axman6> handle (\e -> something (e::SomeException)) action
06:16:33 <Igloo> tibbe: Read http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Exception.html#4
06:17:43 <tibbe> Igloo: I'm trying to catch exceptions in forked threads and write them to a Chan and reraise them in the main thread
06:18:19 <Axman6> tibbe: check out my AVar package, it does exactly that :)
06:18:22 <tibbe> Igloo: like here http://www.serpentine.com/blog/2007/09/25/what-the-heck-is-a-wide-finder-anyway/
06:18:27 <tibbe> Axman6: will do
06:18:38 <Axman6> @hackage AVar
06:18:38 <Axman6> lambdabot: oi!
06:18:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AVar
06:19:15 <Fredrik_> How do I determine the largest Int value?
06:19:57 <Heffalump> > maxBound :: Int
06:19:59 <lambdabot>   9223372036854775807
06:20:34 <Fredrik_> thanks
06:20:39 <Fredrik_> why doesnt hoogle find this??
06:20:50 <Axman6> @hoogle maxBound
06:20:51 <lambdabot> Prelude maxBound :: Bounded a => a
06:20:57 <Axman6> @src Bounded
06:20:58 <lambdabot> class  Bounded a  where
06:20:58 <lambdabot>     minBound, maxBound :: a
06:21:02 <Fredrik_> try http://www.haskell.org/hoogle/?hoogle=maxBound
06:21:49 <Axman6> i haven't used the hoogle website for a long time
06:22:06 <tibbe> "haskell bus error"
06:22:08 <tibbe> great
06:22:24 <tibbe> doesn't that mean SIGSEV?
06:22:32 <Fredrik_> @src (.&.)
06:22:32 <lambdabot> Source not found. :(
06:22:35 <Fredrik_> :t (.&.)
06:22:37 <lambdabot>     Ambiguous occurrence `.&.'
06:22:37 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
06:22:37 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
06:23:15 <Axman6> :t (Data.Bits..&.)
06:23:16 <lambdabot> forall a. (Bits a) => a -> a -> a
06:32:11 <Axman6> ttp://www.tadpolecomputer.com/products/notebooks/bullfrogv2.asp ... wow
06:33:17 <Axman6> http*
06:38:36 <smg> @pl (\x -> (map fst x, map snd x)) [(x!!0,foo(x!!1)) | z <- [1..10], let foo n = [n `mod` 2, n `div` 2], let x = foo z ]
06:38:36 <lambdabot> (line 1, column 32):
06:38:36 <lambdabot> unexpected "["
06:38:36 <lambdabot> expecting variable, "(", operator or end of input
06:39:29 <smg> mh
06:39:31 <smg> @pl let (a,b) = (\x -> (map fst x, map snd x)) [(x!!0,foo(x!!1)) | z <- [1..10], let foo n = [n `mod` 2, n `div` 2], let x = foo z ]
06:39:31 <lambdabot> (line 1, column 5):
06:39:31 <lambdabot> unexpected "("
06:39:31 <lambdabot> expecting "()", natural, identifier or "in"
06:39:54 <smg> i see
06:40:08 <smg> real world haskell is a good book
06:47:48 <multiholle> i am trying to use the function "getAddrInfo" from Network.Socket but ghc says: "not in scope". i imported Network.Socket. what's wrong?
06:49:55 <maltem> multiholle: can you paste a small example on hpaste?
06:50:03 <Alpounet> :t getAddrInfo
06:50:05 <lambdabot> Not in scope: `getAddrInfo'
06:50:11 <Alpounet> :t Network.Socket.getAddrInfo
06:50:13 <lambdabot> Maybe Network.Socket.AddrInfo -> Maybe Network.Socket.HostName -> Maybe Network.Socket.ServiceName -> IO [Network.Socket.AddrInfo]
06:50:35 <vininim> wat
06:50:42 <multiholle> do i have to write Network.Socket.getAddrInfo?
06:51:58 <Alpounet> multiholle, importing Network.Socket should be okay... Can you, as maltem asked, paste a minimal code that produces the same error ?
06:52:21 <multiholle> i'll try.
06:52:33 <Axman6> where hpaste2
06:52:37 <Axman6> @where hpaste2
06:52:38 <lambdabot> http://hpaste.org/
06:52:42 <Axman6> multiholle: ^^
06:53:25 <multiholle> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2202#a2202 it's an example from real world haskell
06:56:32 <smg> @pl 2 + 3
06:56:32 <lambdabot> 5
06:56:41 <maltem> multiholle: works for me. hm, did they ever change the interface of Network.Socket maybe?
06:56:54 <ajcc> @pl 25^.5
06:56:54 <lambdabot> 25 ^. 5
06:57:15 <multiholle> i am using ghc 6.8.1
06:57:37 <ajcc> @pl 25^0.5
06:57:37 <lambdabot> 25 ^ 0 . 5
06:57:48 <vixey> @pl 25^5
06:57:49 <lambdabot> 25 ^ 5
06:58:13 <trofi> > 0 . 5
06:58:15 <lambdabot>       Overlapping instances for Show (a -> c)
06:58:15 <lambdabot>        arising from a use of `s...
06:58:39 <multiholle> what could i do?
07:01:43 <multiholle> nobody can help me?
07:02:36 <Axman6> multiholle: it might have moved in 6.10. you may have to do some searching to see where it used to be
07:04:53 <multiholle> could i reinstall the package?
07:07:36 <dcoutts_> multiholle: you don't say what is wrong. It works fine for me too. I'm using ghc 6.8 too.
07:07:44 <vininim> I hope it's safe to use parsec-3 with cabal-install
07:08:24 <dcoutts_> vininim: you can certainly install parsec-3 using cabal-install
07:08:42 <vininim> to bootstrap I mean
07:08:53 <dcoutts_> vininim: it will not use parsec 3
07:09:08 <Fredrik_> @hoogle [a] -> Bool
07:09:08 <lambdabot> Prelude null :: [a] -> Bool
07:09:08 <lambdabot> Data.List null :: [a] -> Bool
07:09:08 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
07:09:27 <vininim> I follow some suggestion to change the bootstrap script, and so far it works =P
07:09:31 <dcoutts_> vininim: so it doesn't matter if you've got parsec 3 installed or not. If you've got parsec 2 installed it'll work.
07:09:44 <lukeo05> I'm looking to try and make my (really very basic) code be more concise, and use better style, and optimized if at all possible. Any suggestions in general about general ways, or specific tricks, to go about doing this? (sorry for such a vague question... I'm just interested in common ways of making code 'nicer')
07:09:50 <vininim> http://sites.google.com/site/haskell/notes/cabal-on-debian
07:10:03 <dcoutts_> vininim: that page is just misinformation
07:10:15 <dcoutts_> someone should contact the author
07:10:19 <multiholle> docutts_: here is the output on xp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2202#a2205
07:11:04 <dcoutts_> vininim: for one thing it recommends a really really old version of cabal-install
07:11:19 <vininim> oh, but I got the latest
07:11:58 <vininim> you might be confusing pages though, because it recomends 1.6.2
07:12:38 <Ninju> lueko05: Without showing us actual code, that's a very open-ended question. I suggest going to haskell.org and reading through various Wiki articles.
07:12:39 <vininim> I mean, 0.6
07:13:41 <vininim> I remember reading the one that recommends 0.4
07:14:49 <multiholle> i don't know what to do :/
07:14:49 <dcoutts_> multiholle: ohh, that module is using Network.BSD and half of that is not available on Windows
07:15:09 <multiholle> realy?
07:15:35 <multiholle> what could i do instead?
07:15:59 <dcoutts_> vininim: ah, I see the page has been recently updated. It's much better now.
07:16:46 <dcoutts_> multiholle: either avoid using those non-portable functions or use it on linux
07:17:05 <dcoutts_> multiholle: the portable module is Network.Socket
07:17:19 <dcoutts_> it's also more high level
07:17:27 <dcoutts_> the Network.BSD is lower level stuff
07:17:47 <lukeo05> Ninju: I will do, thanks. Here is the code I am working with (it's the first thing i've written, so i'm sure it's _very_ basic!). Hints about what I might try would be better than actual answers on how to make it more concise, then I can try and figure it out myself which is more the point of coursework I guess?! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1817#a1817
07:18:20 <dcoutts_> vininim: so debian now only comes with parsec 3? are you sure? what does this report: $ ghc-pkg field network depends
07:19:11 <vininim> depends: base-4.0.0.0 parsec-3.0.0
07:19:15 <multiholle_> exists an other example that works on windows?
07:19:45 <dcoutts_> vininim: and that's the system deb, not one you installed?
07:19:52 <dcoutts_> vininim: for network
07:20:33 <shapr> I had fun yesterday discussing Haskell with Lemmih and Alex Jacobson at a diner, we talked about all sorts of nifty stuff.
07:20:34 <vininim> i   libghc6-network-dev             - Haskell network library for GHC
07:20:40 <vininim> system deb
07:20:49 <dcoutts_> gah, they've messed that up then
07:21:09 <dcoutts_> poor decision making, going out of step with everyone else
07:21:35 <shapr> does cabal come with ghc6.10 for windows? Should I be able to do "cabal install" after the default ghc6.10 installation on winxp?
07:21:45 <Heffalump> shapr: no
07:21:46 <dcoutts_> shapr: not yet
07:21:54 <multiholle_> docutts_: do you know what i could do?
07:22:03 <shapr> oh, so... is there a zip/tgz I can grab?
07:22:06 <dcoutts_> multiholle_: find another example
07:22:16 <Heffalump> shapr: there's an exe on the webpage
07:22:19 <dcoutts_> shapr: the download is available from the cabal home page
07:22:21 <shapr> ah, thanks
07:22:30 <multiholle_> dcoutts_: it's the only one i found :/
07:22:37 * Heffalump tries to figure out how pages in Cairo work
07:22:53 <dcoutts_> Heffalump: oh for pdf backend
07:22:58 <Heffalump> and ps, yes
07:23:11 <Heffalump> I seem to be getting two copies of my final page, which is a little confusing
07:23:12 <galvus_damor> isn't there an similar package like Network.BSD for windows?
07:23:23 <Heffalump> as I'm using showPage which should reset the canvas
07:23:28 <dcoutts_> galvus_damor: it's provided but half the functions are missing.
07:23:49 <shapr> Ok, that's my SoC nomination, make sure all released versions of GHC are able to do "cabal update" and "cabal install pony" immediately after installation.
07:24:07 <Heffalump> shapr: that's what the Haskell platform plans to do
07:24:22 <galvus_damor> is there a description which functions are there an which not?
07:24:40 <dcoutts_> galvus_damor: yes, in the #ifdefs in the source
07:25:41 <galvus_damor> ok, but where can i get the sources?
07:26:40 <shapr> Haskell Platform looks great
07:26:55 <multiholle_> does anybody know another network example, working on windows?
07:27:44 <vixey> I think you have to do something different (extra) on windows.. (which is what high level programming is all about)
07:27:46 <Axman6> shapr: is there actually mich work being done on it?
07:28:09 <shapr> Axman6: dcoutts and dons are the two people involved, so I think it's likely.
07:28:20 <Axman6> heh, yeah
07:28:26 <dcoutts_> though we're always busy
07:28:27 <shapr> Axman6: There's a public bugtracker, so I'm sure we could contribute.
07:28:44 <Axman6> yeah, i was just checking out the page
07:28:44 <shapr> right, I've not seen dons and duncan take long vacations.
07:28:52 <shapr> Though punting sure was fun.
07:28:55 * Axman6 thinks his AVar package should totally be included
07:28:56 <Axman6> >_>
07:28:58 <Heffalump> have the IHG priorities been decided?
07:29:08 <galvus_damor> which function can i use for the BSD function getAddrInfo?
07:29:18 <galvus_damor> (in windors)
07:30:20 <tibbe> galvus_damor: the source is at http://darcs.haskell.org/libraries/network
07:30:53 <galvus_damor> ok thanks
07:32:41 <Axman6> ah, so dcoutts is at Well Typed, now i've got some context of who they are
07:32:49 <dcoutts_> :-)
07:33:14 <Axman6> o/
07:33:33 <amaron> dcoutts_: hmmm, so if I allready have sorted model wrapped around ListStore, isn't that bad way to do it?
07:33:34 <Axman6> i was wondering who they were when i was reading about the IHG
07:33:49 <dcoutts_> Axman6: we would appreciate help on platform stuff. Neither of us are being funded to work on it.
07:33:55 <HugoDaniel> amazing grace
07:34:05 <amaron> dcoutts_: ups, sorry this came from history
07:34:14 <dcoutts_> ok :-)
07:34:25 <Axman6> dcoutts_: well, i'd be happy to help where i can. not sure how helpful i could be though
07:34:29 <amaron> I just woke up
07:34:50 <dcoutts_> Axman6: testing is a big one, and helping to prepare installers
07:34:59 <paper_cc> has anyone build FieldTrip-0.2.2? it fails with "Not in scope: type constructor or class `AVector'" for me
07:35:07 <Axman6> it'd be nice to see Gtk2hs in the platform IMO, but that won't happen without cabalising :\
07:35:10 <shapr> Axman6: and igloo and bringert
07:35:36 <dcoutts_> Axman6: indeed, and initially we're just looking at a few packages. No more packages in the first release.
07:35:46 <Axman6> shapr: ah, i see. not Igloo makes sense to me too :P always wondered where he came in this whole community thing
07:36:24 <Axman6> dcoutts_: so the ones that are listed on Trac are the only ones going to be in the platform initially?
07:36:28 <Axman6> s/not/now
07:36:28 <paper_cc> sources (Point3.hs) show that it tries to define a dependent type AVector within an instance declaration for AffineSpace, but there's no such type mentioned in Data.AffineSpace
07:36:32 <dcoutts_> Axman6: right
07:36:47 <Axman6> ok, sounds good to me
07:38:11 <Axman6> dcoutts_: no quickcheck? or does tht come with GHC already?
07:38:29 <dcoutts_> Axman6: it's there, see the haskell-platform.cabal file
07:38:43 <paper_cc> btw, FieldTrip-0.2.1 fails the same way
07:40:56 <amaron> Heffalump: I just saw you started to use cairo to generate pdfs. For what purpose? Some kind of reports generator perhaps?
07:41:25 <Ninju> lukeo05: I think the main thing is trying to get into the habit of writing things in terms of higher order functions. Using function composition, currying, and that kind of stuff. You've got some unnecessary things in there (zip [x] [y]  == [(x,y)], extra parenthesis which don't do anything, other small things like that). I'm not sure if I'm a fan of your function argument names, having a base case for the empty list (in your case a blank string) 
07:41:46 <paper_cc> aha, AVector is defined in vector-space ==0.5. someone should correct the dependencies for FieldTrip
07:42:03 <Heffalump> amaron: I'm drawing diagrams
07:42:16 <Heffalump> with the diagrams package
07:42:38 <tibbe> are there any examples where "fix" leads to clearer code than other alternatives?
07:42:40 <Igloo> Oh, when you were talking about that a while ago I assumed that was a latex diagrams package
07:42:47 * tibbe is confused by code containing fix twice
07:43:48 <amaron> Heffalump: cool. From your point of view, is it good enough for some kind of reports generation? Something like crystal reports?
07:45:14 <Heffalump> I don't know
07:45:16 <amaron> If one is going to write some business app in haskell, neat reports are required feature.
07:45:22 <Heffalump> text seems quite complicated
07:45:44 <Heffalump> I think there are other libraries for generating PDFs that would be more suited to text, but I am not familiar with them.
07:46:15 <Axman6> dcoutts_: well, i'll see what i can do tomorrow. i'm running a cabal install <all the packages> --reinstall now, and i'll check it out in the morning
07:46:34 <amaron> well I'm trying to find something like that, but so far cairo is only thing I found.
07:47:18 <Eelis> dcoutts_: if i have a Flag in my .cabal, should it not be mentioned in   runhaskell Setup.hs configure --help  ?
07:47:26 <lukeo05> Ninju: Thanks. The function names were given as part of the exercise. Also, is it wrong to have an empty list as a base case? If I didn't surely when I reached the end of the list it wouldn't work right? Although I guess it might be redundant in some places...
07:47:32 <Axman6> amaron: seen HPDF?
07:48:34 <amaron> Axman6: no, thanks, I'll check it.
07:48:42 <Axman6> @hackage HPPDF
07:48:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPPDF
07:48:46 <Axman6> @hackage HPDF
07:48:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HPDF
07:48:56 <Axman6> huh, i see how that works now... heh
07:50:01 <Axman6> amaron: also, http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=pdf ;)
07:50:49 <amaron> Axman6: :)
07:50:56 <Axman6> night all
07:51:30 <HugoDaniel> :)
07:51:39 <HugoDaniel> ill need that in the near future, thanks :)
07:52:53 <Ninju> lukeo05: No, of course that is fine. It just looked odd having "x" directly below "[]" as list arguments tend to be given pluralized names (e.g. "xs"). Although, when I see a lot of empty list base cases, it indicates to me that there are likely things that  can be written in terms of higher order functions but weren't.
08:00:23 <Ninju> lukeo05: Also, one thing I remember, which I may have forgotten to hint at: avoid unnecessary computation. Example: there's no sense in doing filter (x>) (x:xs), because you know x won't be greater than itself, so you can just do filter (x>) xs. Remember, length is expensive (and non-terminating for infinite lists), so try to avoid it. Again, I highly recommend reading some of the Wiki articles, which explain this kind of stuff in great detail, am
08:13:01 <itewsh> à tout à l'heure
08:34:14 <bmh> has anyone here used hfuse?
08:34:46 <p_l> bmh: try stalking Baughn, he might have
08:42:52 <maxote> :t zip
08:42:53 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
08:43:18 <maxote> > zip [1..] [1..]
08:43:20 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,...
08:46:00 <Heffalump> byorgey: what versions of GHC does diagrams aim to support?
08:49:33 <ztirf_> is there a version of core that you can get the compiler to output that hasn't been simplified as much as the -ddump-simpl output?
08:49:59 <ztirf_> I find -ddump-simpl very hard to read
08:50:11 <m0nkfish> what is the most succinct way to perform the following function: given a list [a,b,c,d,e,f..] return a list of pairs [(a,b),(c,d)(e,f)..]
08:50:33 <goltrpoat> so ive been trying to find a use for this type:  data T e a = Ret (e a) | Step (e (T e a)) | Par (e (T e a)) (e (T e a)) | Nest (e (T e (a,a)))
08:50:54 <EvilTerran> m0nkfish, explicit recursion's probably the easiest approach
08:51:04 <goltrpoat> if e is a functor, then T e is a functor.  if e is a monad, then T e is a monad.  and, T e is bigger than e
08:51:23 <goltrpoat> so you'd think there'd be something useful about it
08:51:37 <m0nkfish> pairs (x:y:zs) = (x,y) : zs
08:51:42 <m0nkfish> pairs [] = []
08:51:46 <bmh> yes.
08:52:01 <EvilTerran> m0nkfish, but what about the single-item list case?
08:52:05 <m0nkfish> exactly
08:52:06 <m0nkfish> :/
08:52:13 <m0nkfish> pairs _ = []
08:52:25 <EvilTerran> that would work
08:52:39 <m0nkfish> does [] match _
08:52:45 <m0nkfish> or i should say, does _ match []
08:52:52 <EvilTerran> yes
08:52:55 <EvilTerran> _ matches anything
08:53:01 <m0nkfish> so the second clause would be unnecessary
08:53:09 <EvilTerran> > case [] of _ -> "yay"
08:53:11 <lambdabot>   "yay"
08:53:19 <m0nkfish> yay
08:53:29 <EvilTerran> indeed, "pairs [] = []" is implied by "pairs _ = []"
08:54:07 <Fredrik_> Anyone want to play my Tic Tac Toe in Haskell against a very simple AI? :) http://haskell.pastebin.com/m216cd6e6
08:57:10 <Heffalump> byorgey: never mind, I replaced intercalate with concat & intersperse so it doesn't matter now
08:58:09 <Dessous> That AI sucks
08:58:12 <Dessous> I won it
08:58:17 <Dessous> in the game
08:58:19 <Fredrik_> of course, its mostly random :)
08:58:43 <bmh> ...why?
08:58:47 <Fredrik_> it's just smart enough to detect three-in-a-row
08:58:49 <Dessous> Tic Tac Toe is boring anyway cause it's always possible not to lose
08:58:55 <Fredrik_> also right
08:59:13 <bmh> Fredrik_: why don't you just enumerate the whole game tree? it's easy enough
08:59:33 <Fredrik_> My goal is to learn Haskell, not to make a perfect TTT AI
08:59:45 <Fredrik_> so if you have any comments on the code, please share them with me
09:00:02 <Dessous> I would if I knew any Haskell
09:07:00 <Baughn> Dessous: It's always possible not to lose in chess, too. ^_^
09:07:17 <Baughn> Well. Possibly.
09:07:28 <bmh> Baughn: I hear you might have used HFuse
09:07:45 <Baughn> bmh: Only a little, so far. What about it?
09:08:04 <bmh> Baughn: installation :-) I get a pile of errors when I run cabal install
09:08:21 <ztirf__> if I have a function called in an unsafeAccumArray loop, and I know that there are invariant computations in that function
09:08:27 <bmh> Fuse.hsc:133: error: invalid use of undefined type ‘struct stat’
09:08:30 <Dessous> Is it really possible not to lose in chess ever?
09:08:35 <ztirf__> is there any way to get ghc to move them out of the loop for me?
09:08:53 <Baughn> bmh: Can I assume you have the C libraries and headers installed?
09:09:04 <Baughn> Oh. Guess not.
09:09:31 <Baughn> Dessous: Either it's always possible to draw, or one side can always win. We don't actually know which, though.
09:10:21 <bmh> Baugh: duh. Thanks :-)
09:11:26 <Baughn> Dessous: Go is nicer. There, we /know/ black can always win. :P
09:11:51 <Baughn> (Assuming a negative one-half komi)
09:12:42 <Dessous> I don't really like Go that much. It's hard to get the big picture in Go imo
09:17:11 <zulon> hello!
09:17:33 <zulon> I'm currently using haskell-mode for Emacs, and I found an annoying bug
09:18:03 <zulon> when I run inf-haskell-*, it associates *every* buffer with the currently edited file
09:18:33 <zulon> is this the normal behaviour?
09:19:38 <zulon> (actually it associates the buffers with the directory, not the file)
09:21:03 <gwern> Dessous: maybe you'd be better with smaller boards? I find on 9x9 it's much easier to see the big picture and enjoy it
09:21:58 <zulon> nobody? :/
09:24:48 <p_l> Go also makes sure that we won't get to enumerate the whole tree for a quite long time... ;-)
09:27:38 <olsner> Baughn: oh, how do we know that "Either it's always possible to draw, or one side can always win." in chess?
09:28:07 <Baughn> olsner: Eh? Well, it's a total knowledge game..
09:28:09 <bmh> olsner: I think the question is typically phrased as a matter of "perfect play"
09:28:36 <olsner> hmm, so that applies to all total knowledge games?
09:28:37 <Baughn> Worse, chess may have enough regularities that it's actually /solvable/. Eventually.
09:28:41 <rovar> can anyone recommend reading on "shared term graphs" specifically what they are and how I can create them?
09:28:54 <Baughn> olsner: No, just the ones where games can't drag out forever
09:30:03 <Baughn> olsner: If it's a finite total knowledge game without randomness that prohibits cycles, /then/ it's solvable in principle. :P
09:30:32 <ImInYourMonad> hmm programming haskell and clojure makes much more sense to me now than programming python. i never used classes much in the first place. also i miss my dear static typechecker
09:32:28 <p_l> Chess afaik is solved for a certain type of endgames (certain amounts of figures etc.)
09:33:03 <Philippa_> well yeah, every newbie learns how to mate with a queen, two rooks etc etc
09:33:22 <p_l> when you hit such combination playing against computer, it will already knew whether it can win or not. If it can, it will :)
09:33:29 <Fredrik_> mate with the queen? pervert!
09:33:33 <vegai> ImInYourMonad: I thought clojure was dynamically typed
09:33:41 <gwern> Fredrik_: you'd hit it
09:33:52 <maltem> ImInYourMonad: Poor one, now you're trapped too
09:34:07 <p_l> gwern: but sometimes only with a 5m pole :P
09:34:08 <bmh> is there much of a haskell community in continental Europe?
09:34:37 <jpcooper> could anyone recommend a simple library for sending serialised objects over the net?
09:34:38 <Baughn> ImInYourMonad: Truth. Using Python for a bit a few weeks ago, I felt like I was trying to walk on quicksand..
09:34:49 <bmh> jpcooper: Text.JSON
09:34:55 <p_l> Baughn: Now imagine Basic :P
09:34:55 <maltem> bmh: Well there are people who use it...
09:35:06 <jpcooper> bmh, I'd like something that has error handling and whatnot
09:35:08 <Baughn> jpcooper: Data.Binary/Network.Bytestring
09:35:25 <jpcooper> I'll be sending showed versions of my objects
09:35:31 <jpcooper> I don't quite need HTTP, but something like it
09:35:34 <Baughn> jpcooper: If you want a full middleware layer.. how soon would you like it?
09:35:36 <p_l> jpcooper: BEEP?
09:35:48 <Baughn> BEEP?
09:35:53 <jpcooper> @hoogle beep
09:35:54 <lambdabot> No results found
09:36:01 <p_l> Blocks Extensible Exchange Protocol
09:36:36 <Baughn> There's no haskell binding, though
09:36:41 <p_l> basically a multiplexed stream which takes care of handshaking etc., then you send whatever stream data you want over it
09:36:52 <jpcooper> excellent, thanks
09:36:52 <p_l> Baughn: Should be simple enough to write one
09:36:54 <jpcooper> I might write one
09:36:59 <jpcooper> make myself useful
09:37:18 <p_l> the RFC is very short. The only bad thing is the (rather simple) XML for endpoint specification
09:37:29 <jpcooper> whoah, quite a long RFC
09:37:43 <jpcooper> actually, no it isn't
09:37:46 <p_l> jpcooper: compare it too HTTP. It's probably shorter :P
09:37:56 <elcerdo> i reinstalled ghc6.6 on debian and now i get messages like 'unknown package: filepath-1.1.0.1' when i try to reinstall any package. is there a way to reset this thing??
09:38:38 <p_l> elcerdo: I would start by replacing ghc6.6 with a newer version...
09:38:48 <Baughn> p_l: Debian.
09:39:02 <p_l> Baughn: Even Debian probably has newer packages
09:39:11 <paper_cc> Baughn: Haskell Unsafe.
09:39:46 <paper_cc> @go Haskell Unsafe
09:39:47 <lambdabot> http://haskell-unsafe.alioth.debian.org/haskell-unsafe.html
09:39:47 <lambdabot> Title: Haskell Unsafe
09:40:38 <Araneidae> Trying to run `cabal upgrade` and it's complaining that it can't read a cabal file: 'cabal: Couldn't read cabal file "./yi/0.5.2/yi.cabal"'.  Well, duh: that's the *new* version.  What am I doing wrong?
09:40:44 <p_l> Baughn: Debian stable includes GHC 6.82
09:40:47 <p_l> *6.8.2
09:40:54 <Fredrik_> What is the recommended IDE for developing Haskell software on Windows?
09:41:14 <p_l> Baughn: unstable has 6.10.1
09:41:50 <Baughn> p_l: That's new. It's troublesome being at the mercy of distributors, though.
09:41:54 <Baughn> Fredrik_: Unless something has changed recently, still emacs
09:42:12 <Herald> hi everyone
09:42:20 <Vq^> hello Herald
09:42:25 <maltem> Fredrik_: any serving text editor, and something resembling a unix shell
09:42:29 <Baughn> Fredrik_: http://haskell.org/haskellwiki/IDE <-- But there are a couple of alternatives if you"d like to try
09:42:32 <Araneidae> Should `cabal upgrade` just work?
09:42:36 <Baughn> Araneidae: No.
09:42:40 <p_l> Baughn: the exceptions for unstable are m68k and hurd-i386 having 6.6 and 6.8 on hppa, ia64 and armel
09:42:48 <Baughn> Araneidae: Right now, running that command is a Very Bad IDea
09:42:48 <bmh> Araneidae: Bug #2201?
09:42:53 <Araneidae> Oops!
09:43:04 <Araneidae> Where do I find that bug report?
09:43:11 <Baughn> @go bugs
09:43:12 * Araneidae is rather a noob here
09:43:13 <lambdabot> http://www.whatsthatbug.com/
09:43:13 <lambdabot> Title: What's That Bug? Insect identification
09:43:25 <bmh> @go ghc #2201
09:43:26 <lambdabot> No Result Found.
09:43:34 <Herald> im having some trouble with a fairly basic quickcheck problem - i'm trying to create a test generator for a list of exactly 36 elements - can anyone help me with that? I've looked through the quickcheck documentation, but I'm not understand how to use the Gen and arbitrary data types
09:43:35 <bmh> huh..
09:43:43 <Araneidae> what can I say ;)
09:43:43 <Baughn> @where bugs
09:43:43 <lambdabot> I know nothing about bugs.
09:43:45 <Baughn> @where bug
09:43:45 <lambdabot> I know nothing about bug.
09:44:02 <p_l> Baughn: Back during the time I used Debian unstable, stuff was progressing quite nicely
09:44:04 <Baughn> Araneidae: Uh. ANyway, http://hackage.haskell.org/trac/ghc/wiki/ReportABug
09:44:08 <Baughn> @where+ bugs http://hackage.haskell.org/trac/ghc/wiki/ReportABug
09:44:09 <lambdabot> It is stored.
09:44:43 <Araneidae> Searching for 2201 ...
09:44:55 <maltem> Herald: You would write an instance of Arbitrary for the, say, List36 data type
09:45:14 <Herald> how would i do that :-\
09:45:17 <Araneidae> Oh dear.  hackage.haskell.org is a little ... slow
09:45:41 <Herald> are there any collections of examples for test data generators for quickcheck?
09:45:43 <Araneidae> So.  Do I walk away from cabal and try again another day?
09:46:05 <Fredrik_> Baughn: reading about emacs now... it appears to be an operating system in itself :))
09:46:35 <Baughn> Araneidae: Cabal's fine, just don't run upgrade.
09:46:40 <Araneidae> Hmm.
09:46:45 <Araneidae> So how *do* I upgrade?
09:46:46 <maltem> Herald: lemme check
09:46:53 <Herald> thanks maltem
09:46:57 <Araneidae> Fetch doesn't work either
09:47:08 <Baughn> Araneidae: cabal install --reinstall
09:47:11 <p_l> Fredrik_: Never used Emacs?
09:47:12 <Baughn> Araneidae: Repeatedly.
09:47:15 <maltem> Herald: oh, sure, look at the quickcheck source code for some generic examples
09:47:15 <Araneidae> blimey
09:47:34 <trofi> :t lokup
09:47:36 <lambdabot> Not in scope: `lokup'
09:47:37 <Fredrik_> p_l: I almost avoided it because it seemed incredibly complex. I couldnt ever edit text without reading the manual.
09:47:39 <trofi> :t lookup
09:47:40 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
09:47:41 <Araneidae> The bug report is a year old.  DOes this mean that `cabal upgrade` has been broken for a year?
09:47:44 <Baughn> In practice, it's often easier to rm -r ~/.ghc and then pull them in by their dependencies
09:47:44 <Fredrik_> almost -> always
09:47:53 <Fredrik_> ever -> even
09:47:55 <Baughn> Araneidae: cabal upgrade has never worked
09:48:26 <p_l> Fredrik_: I think the only case where "I couldn't edit text without manual" applied was Vi... or Emacs on _very_ old terminal
09:48:36 <Araneidae> Oh dear.  It should say "I'm broken, I'm a nice idea, don't run me." rather than what it does.  Thanks for telling me, anyhow!
09:49:04 <Herald> maltem: you mean lines 1-46 ?
09:49:12 <Araneidae> Well.  `cabal install --reinstall yi` produces *exactly* the same error message.
09:49:22 <Baughn> Araneidae: IIRC they removed it in the latest code
09:49:44 <Baughn> Araneidae: Er, what error is this, exactly?
09:49:47 <p_l> Fredrik_: putting vi into shell for some luser was considered a quite good random generator
09:49:54 <Araneidae> $ cabal install --reinstall yi
09:49:54 <Araneidae> Resolving dependencies...
09:49:54 <Araneidae> cabal: Couldn't read cabal file "./yi/0.5.2/yi.cabal"
09:50:00 <Araneidae> Sorry about the microflood
09:50:20 <Baughn> Araneidae: Oh. That's new.
09:50:55 <Araneidae> Given that the installed version is 0.4.7 that's to be expected
09:51:31 <Baughn> Araneidae: Right off the top of my head, try 'sudo chown -R `whoami`: ~/.ghc ~/.cabal'
09:51:48 <Herald> still not getting it... can anyone give me more specific advice on how to write quickcheck test generators?
09:51:55 <Araneidae> No, cabal has *never* been run as root
09:52:03 <Araneidae> Well... maybe under the hood?
09:52:08 <Araneidae> I'll check for ownerships
09:52:12 <maltem> Herald: Possibly. Hold on a minute, I'll paste the example (I've never done this until now, that's why it takes so long :-/)
09:52:27 <Herald> maltem: ok, thank you :)
09:52:32 <Baughn> Araneidae: Hang on, how about without the --reinstall?
09:52:48 <Araneidae> Same error message
09:53:04 <Araneidae> I'll do your chown anyhow, it's harmless
09:53:14 <truestep> hi
09:53:39 <Araneidae> No difference
09:53:43 <shapr> hi truestep
09:54:43 <maltem> Herald: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2207
09:55:05 <Araneidae> One curious thing:
09:55:08 <Araneidae> ~$ cabal --version
09:55:08 <Araneidae> cabal-install version 0.5.2
09:55:08 <Araneidae> using version 1.4.0.2 of the Cabal library
09:55:13 <truestep> microsoft has released a sources or something for API interception, but I forget the name of this tool/sources, could somebody remind me
09:55:20 <Araneidae> Is that a sensible match of versions?
09:55:37 <truestep> ?
09:55:43 <maltem> Herald: I made it 5 elements so it's nicer to look at the generated lists :)
09:55:47 <Baughn> Probably. The cabal library will be whatever version shipped with ghc, anyhow.
09:55:51 <Herald> maltem: interesting, thanks very much
09:56:00 <Araneidae> ok.
09:56:27 <Baughn> Araneidae: That said, I'm using cabal-install 0.6.2. I don't know if it'd work on ghc 6.8, but have you tried upgrading?
09:56:55 <Araneidae> Well, I'm currently working with a stock Ubuntu install, I'm pretty sure.
09:56:56 <walter_> In the "Real World Haskell" a example:  ghci> let d1 = [Just 5, Nothing, Nothing, Just 8, Just 9]::[Maybe Int], why "Maybe Int"  but not "Maybe String" ?
09:57:20 <maltem> walter_: er, because 5 is a number, not a string?
09:57:21 <Fredrik_> because 5, 8 and 9 are Int?
09:57:24 <Araneidae> Oh.  Maybe not: `which cabal` reports a local version.  Hmm
09:58:10 <walter_> Oh, I forgot , Just is a reserved keyword
09:58:43 <walter_> so is "Nothing"
09:59:11 <EvilTerran> not exactly
09:59:12 <EvilTerran> ?src Maybe
09:59:12 <lambdabot> data Maybe a = Nothing | Just a
09:59:21 <Araneidae> They're not reserved, they're ordinary identifers -- which just happen to already be assigned in the prelud
09:59:35 <walter_> I see
09:59:35 <EvilTerran> but then, quite a few things that you'd expect to be keywords aren't
09:59:37 <EvilTerran> ?src Bool
09:59:37 <lambdabot> data Bool = False | True deriving (Eq, Ord)
10:00:01 <vixey> :t otherwise
10:00:02 <lambdabot> Bool
10:00:14 <EvilTerran> ?src otherwise
10:00:15 <lambdabot> otherwise = True
10:00:22 <Araneidae> :t "Does this work for any expression?"
10:00:24 <lambdabot> [Char]
10:00:28 <Araneidae> Cool
10:00:38 <walter_> cool, :0
10:00:42 <Baughn> > case False of True -> 1; otherwise -> 2
10:00:44 <lambdabot>   2
10:00:45 <shapr> Has anyone tried to build conjure with ghc 6.10?
10:00:47 <walter_> :)
10:00:52 <Baughn> otherwise /is/ a keyword. :P
10:01:16 <vixey> > case False of True -> 1; womble -> 2
10:01:17 <lambdabot>   2
10:01:18 <brad_larsen> dons, you here?
10:01:25 <sioraiocht> lol\
10:01:32 <Baughn> womble's a keyword too.
10:01:36 <EvilTerran> Baughn, stop confusing the newbies, it's mean :|
10:01:37 <vixey> lol
10:01:38 <Araneidae> > case False of True -> error "blah"; _ -> "A rather pointless keyword"
10:01:40 <lambdabot>   "A rather pointless keyword"
10:02:07 <shapr> Are there any plans to extend hackage to include the ability to report bugs and more? I've asked this before, but I forget the answer.
10:02:20 <Baughn> EvilTerran: This was new to me, though. Someone had already confused me. ^^;
10:02:56 <Baughn> > let foo = 1 in case 3 of 1 -> 2; foo -> 5
10:02:58 <lambdabot>   5
10:03:01 <viraptor> how can I make an IO () from a list of hPutStr-s? mapM and sequence give me IO [()] :/
10:03:03 <Baughn> Oh, now that's just wrong.
10:03:16 <Baughn> So, what, the last case clause /always/ matches?
10:03:27 <Baughn> > case 4 of 1 -> 2; 2 -> 3
10:03:29 <lambdabot>   * Exception: /tmp/4059319522650595655:71:52-75: Non-exhaustive patterns in ...
10:04:05 <brad_larsen> viraptor: sequence_?
10:04:07 <Baughn> > let foo = 2 in case 2 of foo -> 1; bar -> 3
10:04:08 <lambdabot>   mueval: Prelude.read: no parse
10:04:08 <lambdabot>  mueval: UnknownError "GHC reported errors a...
10:04:19 <brad_larsen> @type sequence_
10:04:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:04:52 <viraptor> brad_larsen: thanks :)
10:04:57 <Baughn> > case 2 of foo -> foo -- Doh. Now I get it.
10:04:57 <byorgey> Baughn: an identifier used as a pattern simply matches anything, binding the identifier to the value being matched.
10:04:58 <lambdabot>   2
10:05:09 <Baughn> byorgey: Of course I already knew that. Somewhere. ;_;
10:05:09 <byorgey> Baughn: it shadows and previous bindings for that identifier.
10:05:13 <byorgey> right =)
10:05:15 <byorgey> *any
10:05:49 <Baughn> Hang on, didn't I go trough this whole epiphany thing once before?
10:06:05 <byorgey> Baughn: maybe.  most epiphanies must be experienced 2-3 times before sinking in
10:06:57 <byorgey> however, if you epiphany persists for 4 or more times, see a Haskell professional
10:09:51 <walter_> let d0 = ["this is my work"]::[Maybe [Char]]  What's wrong with the statement? thanks
10:10:05 <walter_> haskell type drive me crazy
10:10:08 <brad_larsen> walter_: no 'Just'
10:10:09 <pumpkin-> let d0 = [Just "this is my work"}
10:10:45 <Araneidae> Ok.  Trying another path to getting cabal working.
10:10:45 <walter_> :(  got it.
10:10:48 <Araneidae> $ cabal upgrade cabal
10:10:48 <Araneidae> Resolving dependencies...
10:10:48 <Araneidae> cabal: cannot configure syb-0.1.0.0. It requires base >=4.0
10:10:48 <Araneidae> There is no available version of base that satisfies >=4.0
10:10:55 <Araneidae> Eh?
10:11:11 <pejo> Araneidae, are you using GHC 6.10?
10:11:21 <Araneidae> 6.8.2
10:11:32 <Baughn> base-4 is ghc-6.10
10:11:34 <Eelis> what's the equivalent of "make -j N" for "runhaskell Setup.hs build" ?
10:11:45 <Baughn> EvilTerran: "Yell at developers until fixed", sorry
10:11:52 <pejo> Eelis, doesn't exist yet afaik.
10:12:03 <Eelis> pejo: i see. pity
10:12:08 <Eelis> pejo: thanks
10:12:54 <Araneidae> I thought cabal was supposed to be well behaved and reliable.  Or am I completely misunderstanding its purpose?
10:13:26 <Baughn> Araneidae: No, you understand it correctly. It's supposed to be well behaved and reliable.
10:13:40 <pumpkin-> Araneidae: what makes you think it isn't?
10:13:55 <Araneidae> The fact that everything I try on what is a simple stock install fails.
10:13:55 <olsner> it is well-behaved and reliable, you just don't have the required version of base installed (as specified by the dependencies of the 'syb' package in this case)
10:14:04 <Araneidae> No, it doesn't work.
10:14:20 <Araneidae> I have an Ubuntu install of ghc which is fully up to date.
10:14:27 <pumpkin-> Araneidae: the one example you've given is because you don't have the latest compiler
10:14:28 <Baughn> Araneidae: Base-4 is GHC 6.10. If the package wants that, there's nothing Cabal could possibly do.
10:14:33 <pumpkin-> blame ubuntu for not packaging the latest version
10:14:35 <pumpkin-> :)
10:14:46 <Araneidae> Well.  Ok, there are two places to place blame.
10:14:57 <Araneidae> 1. Ubuntu's install is mildly elderly... true
10:15:09 <Araneidae> 2. cabal is demanding bleeding edge installs.
10:15:19 <pumpkin-> Araneidae: you don't need bleeding edge cabal...
10:15:19 <Baughn> Cabal does nothing of the sort. The yi developers did that.
10:15:55 <Fredrik_> Ah, now I remember my frustration with eMacs. I never knew how to mark text and then copy/paste :))
10:16:01 <pumpkin-> Araneidae: if you're fine with not having the latest GHC because it isn't packaged in ubuntu, I don't see why you insist on having the latest possible cabal
10:16:13 <Baughn> Fredrik_: C-space, move, M-w
10:16:16 <Baughn> Then C-y to paste
10:16:17 <Araneidae> Well, ok, that's a good point.
10:16:38 <Araneidae> Basically cabal is refusing to do any upgrades, so I figured the next step was to upgrade it
10:16:54 <pumpkin-> the next cabal version took out the upgrade command iirc :)
10:17:03 <pumpkin-> (cabal-install, that is)
10:17:05 <p_l> Fredrik_: Or if you are rodent-addicted, select text and middle click where you want to paste it
10:17:27 <Araneidae> Well, the README with the latest cabal install still says to use upgrade.
10:17:28 <Fredrik_> But I cannot see what I mark, that drives my crazy :)
10:17:55 <Botje> Fredrik_: M-x transient-mark-mode
10:18:01 <p_l> Fredrik_: ? It should normally change the appearance of marked text, unless you are working on something weird...
10:18:26 <Baughn> p_l: No, that's optional
10:18:28 <p_l> or maybe I'm always with transient-mark-mode ;-)
10:18:35 <Botje> Fredrik_: or you can do C-space twice
10:18:50 <m0nkfish> how do you delete the mark
10:19:04 <p_l> m0nkfish: C-g
10:19:05 <Baughn> Botje: What does that do, exactly?
10:19:22 <p_l> deactivates mark, afaik
10:19:27 <Botje> same as C-space, but enable transient mark mode iirc
10:19:38 <Baughn> First C-space gives me "mark set", second gives me "mark activated"
10:19:38 * p_l guesses he's got weird emacs
10:19:39 <m0nkfish> i like doublespace
10:19:52 <Fredrik_> Control Space, Meta W... how am I supposed to remember that stuff? lol
10:20:09 <p_l> Fredrik_: Buy a symbolics keyboard ... ;P
10:20:10 <m0nkfish> how did you learn to remember ctrl+c and ctrl+v
10:20:29 <m0nkfish> just use it
10:20:54 * p_l managed to own a computer for few years before learning of cut and paster
10:20:58 <p_l> *paste
10:21:17 <m0nkfish> im sure we all did :p
10:21:24 <m0nkfish> whats the command to delete the region
10:21:37 <brad_larsen> C-w
10:21:42 <m0nkfish> without cutting
10:21:51 <brad_larsen> uhhh.
10:21:55 <brad_larsen> don't know
10:22:12 <m0nkfish> i get confused between the mark-point region and the selected text region
10:22:16 <Fredrik_> Ah, it seems C-w is cut and M-w is copy
10:22:18 <m0nkfish> why are there both :(
10:23:10 <Fredrik_> lol, pasting is called "yanking" in emacs, thats sweet
10:23:26 <p_l> Fredrik_: That's cause you are yanking text back from kill ring :)
10:23:34 <gwern> emacs predates 'copy-paste'
10:23:46 <Fredrik_> ah, you can kill and delete text. very brutal.
10:23:51 <walter_> let d0 = "normally change the appearance"  writeFile "test" show(d0) , will also write the quotation into file test, how can I avoid quotation?
10:23:59 <p_l> gwern: Actually this stuff predates emacs :)
10:24:01 <m0nkfish> i just love how the tutorial tells you how to press the backspace key to delete a letter
10:24:02 <m0nkfish> its cute
10:24:05 <gwern> lies!
10:24:11 <Botje> walter_: drop the show
10:24:15 <Botje> writeFile "test" d0
10:24:20 <gwern> m0nkfish: that's related to the backspace/C-h issue...
10:24:32 <walter_> eh, :) thansk
10:24:33 <p_l> gwern: Nope. It's just that it was a rather different kill-yank :P
10:25:03 <Fredrik_> learning emacs is fun, but it also makes me hungry. gonna go to the kitchen and fetch me some carrots. or is there an emacs commando for that? :)
10:25:18 <p_l> Fredrik_: You need hw module for that :P
10:25:32 <p_l> then you can have M-x yank-carrot-from-fridge ;-)
10:25:33 <pumpkin-> commando :o
10:26:03 <p_l> and M-x butterflies for editing files on unpowered magnetic media ;-)
10:26:15 <mauke> M-butterfly
10:26:35 * p_l doesn't have a butterfly key
10:26:45 <Botje> macs do!
10:27:17 <p_l> Botje: except that it reports Meta ;-)
10:27:24 <p_l> IIRC
10:27:48 <p_l> can't ever figure those weirdo apple thingy
10:32:01 <Araneidae> Upgrading ghc on Ubuntu is no damned joke: I'm having to remove 22 packages associated with the old version
10:33:13 <Heffalump> shouldn't aptitude figure all that out?
10:33:38 <Araneidae> *If* aptitude knew about the new compiler ... which it doesn't
10:34:16 <Heffalump> you can't just get it to install a deb?
10:35:58 <Araneidae> Well, the Ubuntu debs are the ones that aptitude looks at -- and they're old
10:36:39 <Araneidae> A Debian deb may or may not be up to date and may or may not break my system.  Not excited about that.
10:41:52 <foo-nix> I am trying to install leksah, the haskell ide, and I am compiling it by hand. When I do so, it says it needs glib 0.10, which I have but I have (far newer) 2.18.4. Is a different glib meant? I am on gentoo linux.
10:43:38 <Heffalump> it means the haskell package
10:43:41 <Heffalump> you need to install gtk2hs
10:44:20 <ImInYourMonad> if Java can be used for cellphone apps, then why cant ghc? is ghc memory use more unpredictable(and yes it isnt normal java on cellphones it is dvm or microedition)
10:44:34 <foo-nix> Heffalump: I have installed gtk2hs
10:44:52 <Heffalump> foo-nix: then ghc-pkg ought to report that you have glib
10:44:56 <Heffalump> ghc-pkg list, that is
10:45:00 <foo-nix> Moreover, after I did some dependencies disappeared from the still neede listy of configure.
10:46:05 <foo-nix> Heffalump: Heffalump  it does not.
10:46:26 <Heffalump> then I think something went wrong with your gtk2hs install. Do you have gtk in that list?
10:48:17 <foo-nix> Ah, I probably need gtk2hs 0.1 or newer. I have  0.9.12.1 (which sounds newer).
10:48:27 <Heffalump> it's 0.10, not 0.1
10:48:56 <foo-nix> Heffalump: from a mathematics standpoint, that would be the same, but youy're right, this is versioning (/me slaps himself)
10:49:03 <foo-nix> thanx
10:49:12 <foo-nix> I will install it manually then
10:49:19 <Heffalump> from a mathematics standpoint, 0.9.12.1 is nonsensical..
10:49:56 <mauke> from a perl standpoint, 0.9.12.1 == "\0\9\12\1"
10:50:51 <foo-nix> Heffalump: true of course
10:51:09 <foo-nix> it is just that my head has this feature that it swaps 0.10 with .1 automatically.
10:54:12 <Araneidae> Should I have a ~/.cabal/config file?  Just installed 0.6.2 and http://hackage.haskell.org/trac/hackage/wiki/CabalInstall says I should have a "self documenting" config file.  No such luck
10:54:35 <Heffalump> have you run cabal once?
10:54:44 <Araneidae> Only cabal --version
10:54:57 <Alpounet> cabal update ?
10:55:02 <Araneidae> Good idea!
10:55:23 <Araneidae> Cheers: that did the trick!
11:01:12 <Araneidae> Is alex beyond the wit of cabal to install?
11:01:54 <Heffalump> I don't think so
11:02:01 * Heffalump is just trying and it certainly thinks it can do it
11:02:02 <Araneidae> Odd.  A dependency resolution step failed -- cabal didn't install alex, but it looks as if it can
11:02:05 <dcoutts> Araneidae: it does not yet track build tools as dependencies, only libs
11:02:12 <Heffalump> oh, right
11:02:16 <Araneidae> Ok, I'll install by hand.
11:02:26 <dcoutts> Araneidae: just cabal install alex
11:02:33 <Araneidae> yep
11:02:47 <Araneidae> Yeah, that's what I mean!
11:02:55 <Baughn> Couldn't you specify alex in build-depends?
11:03:33 <Araneidae> But it *still* fails!  Hmm.
11:03:44 <Saizan> alex is not a library, and you don't need to link it in
11:03:48 <Baughn> Araneidae: Is ~/.cabal/bin in your PATH?
11:03:57 <Araneidae> I've installed alex, it built and installed it ... but it's listed as not installed!
11:04:09 <Araneidae> Well.  A symlink to it is on my path
11:04:16 <Araneidae> Maybe that's the trouble?
11:04:16 <Baughn> It won't show up in the package list; that only shows libraries
11:04:23 <dcoutts> Araneidae: no, that's enough
11:04:23 <Baughn> No, that should be fun. Assuming it runs.
11:04:37 <Araneidae> `cabal list alex` reports:
11:04:44 <dcoutts> Araneidae: are you worried because cabal list alex says it's no installed?
11:04:44 <Araneidae>     Latest version available: 2.3.1
11:04:45 <Araneidae>     Latest version installed: [ Not installed ]
11:04:48 <Araneidae> Yes
11:04:58 <Araneidae> And because `cabal install yi` fails for the same reason.
11:05:06 <jauaor> hello
11:05:51 <Araneidae> Ah: I can see a cock-up I've made.  I commented out my symlink-bindir entry in the config file, so alex isn't on the path...
11:06:14 <trofi> hey, who can help me beat horrible ^J in emacs? (http://img149.imageshack.us/img149/571/20090308200156.png)
11:06:28 <Taejo> which version of GHC was the first with base >= 4?
11:06:32 <pejo> trofi, is it with ghci?
11:06:35 <dcoutts> Araneidae: the [ Not installed ] thing is misleading, it's not actually tracked because it has no registered lib. I've made a note to fix the wording.
11:06:55 <Saizan> Taejo: 6.10.1
11:07:01 <trofi> pejo: inferior haskell mode, i think ghci
11:07:07 <Taejo> Saizan: thanks
11:07:11 <Saizan> trofi: i use ghci-haskeline for that
11:07:25 <trofi> Saizan: what is it?
11:07:27 <pejo> trofi, http://blog.ox.cx/
11:07:33 <foo-nix> Heffalump: it seems to work now. my glib depedency problems are over, Thank you captain Magnificus!
11:07:39 <foo-nix> ^^
11:08:11 <trofi> i believe it is GHCi's bug
11:08:21 <Heffalump> you're welcome :-)
11:08:52 <Saizan> trofi: the problem is that ghci now uses editline, which is a poor readline clone because of licensing issues
11:09:10 <pejo> trofi, the blog page I linked contains a solution to your problem.
11:09:17 <Saizan> trofi: ghci-haskeline uses haskeline, which is quite better
11:09:18 <trofi> Saizan: so where problem does come from? libedit is stupid about TERM="dumb" ?
11:09:36 <Araneidae> Now Yi fails:Yi/Regex.hs:18:28:
11:09:36 <Araneidae>     Module `Text.Regex.TDFA.TDFA' does not export `patternToDFA'
11:09:40 <trofi> pejo: yes, thanks i've seent it but it looks like a hack :]
11:09:59 <Araneidae> Who is broken here?
11:11:00 <Saizan> trofi: i'm not sure about the details
11:11:18 <trofi> is there any bugreport?
11:12:02 <Saizan> there's a thread on ghc-users
11:12:06 <Ninju> Any ideas on how I can fix this: "During interactive linking, GHCi couldn't find the following symbol: base_DataziTuple_Z166T_con_info or base_DataziTuple_Z166T_static_info"
11:15:05 <foo-nix> What does 'you have to install gtksourceview2 in a version > 2.4.0' mean as stated here: http://www.haskell.org/haskellwiki/Leksah ?
11:15:26 <trofi> Saizan: can you point me to it? (i'd like to fetch bug# from ghc's trac)
11:15:48 <foo-nix> I.e. I cannot find the package anywhere and it is listed asversion  0.10 in ghc-pkg list.
11:16:11 * SamB wonders how hard it would be to get slime support for Emacs ...
11:17:03 <Saizan> trofi: i'd have to google, however they are planning to replace libedit with haskeline
11:17:30 <trofi> ah, ok thanks :]
11:18:00 <p_l> SamB: I think not easy :)
11:18:45 <trofi> ah, so ghci-haskeline is a separate binary
11:19:12 <Heffalump> it's really good to have on Windows
11:22:11 <Araneidae> Sigh.  Fighting with building with ghc.
11:22:33 <monochrom> don't build ghc.
11:22:36 <Araneidae> I've downloaded the yi sources, and have run `runghc Setup configure --user` (have this in my notes from somewhere)
11:22:45 <monochrom> oh oops, building with.
11:22:59 <Araneidae> and it complains about *loads* of missing dependencies :(
11:23:09 <Araneidae> First  few lines:
11:23:14 <trofi> Saizan: thanks, installed ghci-haskeline and symlinked it to ~/bin/ghci. looks good
11:23:22 <Araneidae> Setup: At least the following dependencies are missing:
11:23:22 <Araneidae> binary ==0.5.*,
11:23:22 <Araneidae> data-accessor ==0.2.*,
11:23:22 <Araneidae> data-accessor-monads-fd ==0.2.*,
11:23:33 <Araneidae> What does this all mean?
11:23:41 <Saizan> Araneidae: you can run "cabal install" from the source tree to get those installed automatically
11:23:48 <Araneidae> Already done that
11:23:55 <Araneidae> Oh I see
11:23:58 <Botje> you need those exact versions
11:24:00 <Araneidae> From the source tree?  Ok
11:24:08 <pejo> Araneidae, that it can't find binary 0.5.x, data-accessor 0.2.y and data-accessor-monads-fd 0.2.z.
11:24:33 <Araneidae> Thanks Saizan, that seems to be doing something useful!
11:26:52 <trofi> @hoogle plus
11:26:52 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
11:26:52 <lambdabot> Control.Arrow class ArrowZero a => ArrowPlus a
11:26:52 <lambdabot> Control.Monad class Monad m => MonadPlus m
11:27:35 <HugoDaniel> how do i do "read (function arg1 arg2)" ... function is Int -> Int -> IO String  ?
11:27:58 <Heffalump> liftM read (function arg1 arg2)
11:27:59 <mauke> function arg1 arg2 >>= \x -> ... read x ...
11:28:11 <Heffalump> will get you a IO whatever
11:28:41 <HugoDaniel> Heffalump: it wont work, because it need the returning type
11:29:15 <Heffalump> HugoDaniel: you'll need to use it in a context that determines
11:29:21 <Heffalump> that determines the returning type
11:29:27 <Heffalump> or use an explicit type sig
11:32:34 <HugoDaniel> how do i transform a Float into a Double ?
11:33:07 <mauke> :t realToFloat
11:33:08 <lambdabot> Not in scope: `realToFloat'
11:33:15 <mauke> er, frac
11:33:34 <mauke> > realToFrac (1.5 :: Float) :: Double
11:33:36 <lambdabot>   1.5
11:33:50 <trofi> @hoogle ':: Float -> Double'
11:33:50 <lambdabot> Parse error:
11:33:50 <lambdabot>   --count=20 "':: Float -> Double'"
11:33:50 <lambdabot>              ^
11:33:57 <trofi> @hoogle :: Float -> Double
11:33:58 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
11:33:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:33:58 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:46:14 <beelsebob> what's the right type for a threadsafe IORef type thing that allows for repeated writing without reading?
11:46:38 <mauke> depends on your definition of "threadsafe"
11:47:14 <dons> mmm
11:47:22 <dons> MVar or TVar?
11:47:33 <beelsebob> yeh, I think it is actually MVar
11:47:33 <dons> but is this more some kind of 'port' type?
11:47:41 <dons> a time varying value that you sample occasionally
11:47:42 <beelsebob> I was thinking that I didn't need to take every time I write
11:47:44 <beelsebob> but I think I do
11:49:30 <Baughn> I suppose you'll have to wrap another mvar around the mvar to avoid races while modifying or reading the inner mvar
11:49:44 <beelsebob> I don't think so
11:49:48 <tromp_> @hoogle showBase
11:49:48 <lambdabot> No results found
11:49:50 <beelsebob> because if I modify it I always take it first
11:50:00 <beelsebob> oh, but someone else could readMVar
11:50:06 <beelsebob> will that block until it's rewritten?
11:50:21 <beelsebob> yes, because it's take >>= put
11:50:23 <HugoDaniel> im sorry, i really need help with these functions: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2212#a2212
11:50:36 <HugoDaniel> its that "liftM read" that is screwing up :/
11:50:38 <Baughn> Hm. Guess it'd work.
11:50:55 <HugoDaniel> i should take the time to practice haskell more
11:51:01 <tromp_> > showIntAtBase 2 (floor (256*0.072021484375))
11:51:02 <lambdabot>       Overlapping instances for Show (t -> String -> String)
11:51:02 <lambdabot>        arising f...
11:51:11 <tromp_> :t floor
11:51:13 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:51:26 <tromp_> > showIntAtBase 2 (floor (256*0.072021484375)) ""
11:51:27 <lambdabot>       Overlapping instances for Show (String -> String)
11:51:27 <lambdabot>        arising from a...
11:52:41 <tromp_> > showIntAtBase 2 ("01"!!) (floor (256*0.072021484375)) ""
11:52:43 <lambdabot>   "10010"
11:52:48 <HugoDaniel> the idea is to use the executeMany for a given sql prepared statement on this list
11:52:59 <tromp_> they shld just add showBin :(
11:53:37 <mauke> showBin = showIntAtBase 2 intToDigit
11:54:09 <tromp_> > showIntAtBase 2 intToDigit (floor (256*0.1343994140625)) ""
11:54:10 <lambdabot>   "100010"
11:57:16 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2212#a2213  help please
12:01:53 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/DocTest-0.0.0
12:01:54 <dons> woo
12:04:48 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2214#a2215 help please!
12:04:57 <tromp_> @hoogle group
12:04:57 <lambdabot> Data.ByteString group :: ByteString -> [ByteString]
12:04:57 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
12:04:57 <lambdabot> Data.ByteString.Char8 group :: ByteString -> [ByteString]
12:05:34 <gwern> excellent. my interwiki plugin for gitit is done. now to convince john to expose the gitit functions I need...
12:05:34 <brad_larsen> hey dons, earlier on cafe bryan said that bytestrings had an early fusion framework, but that it's no longer used
12:06:11 <brad_larsen> the fusion framework described in "from lists to streams to nothing at all" paper?
12:06:30 <brad_larsen> i'm just curious:  why isn't fusion used with bytestrings any more?
12:06:38 <Cale> It isn't?
12:06:45 <dons> it's obsolete, so needs to be ported back to bytestrings
12:06:50 <brad_larsen> uh, unless i misinterpreted the email
12:07:37 <brad_larsen> so, no bytestring fusion at present?
12:07:58 <brad_larsen> there's a better, shinier fusion framework that needs to be ported?
12:08:21 <dons> that's right.
12:08:25 <dons> the one in uvector
12:08:38 <brad_larsen> aha.
12:08:43 <Cale> Isn't that still stream fusion?
12:09:21 <gio123> Cale:hi
12:09:27 <Cale> hi
12:10:22 <brad_larsen> any plans to support multidimensional arrays w/ uvector?
12:12:45 <gio123> Cale:could u see pm
12:13:12 <Fredrik_> OK, I got the emacs Haskell mode installed. Now how do I compile the programs I write in emacs??
12:14:34 <brad_larsen> yay, netsplit
12:16:54 <Fredrik_> OK, I got the emacs Haskell mode installed. Now how do I compile the programs I write in emacs?
12:17:57 <HugoDaniel> im fixing my problem with explicit recursion... so much for the lift's :/
12:18:19 <HugoDaniel> i think i've been bitten by monads
12:32:58 <paczesiowa> what does "a_s1no [ALWAYS Just L] :: Addr#" mean in ghc-core output?
12:35:22 <olsner> basically, that it's an Addr# value, with some annotation [ALWAYS Just L] that I don't know what it means :)
12:35:50 <johnbs> Is there a monadic pretty-printing library somewhere?  At the moment I'm using Text.PrettyPrint, but it would be nice to have a monad so I can thread printing options (and maybe other things)
12:36:28 <edwardk> does Sean Leather pop on here?
12:36:54 <edwardk> johnbs: hrmm i'm sure someones put one together
12:39:54 <edwardk> johnbs: what about that the parser/pretty-printer isomorphism stuff, doesn't that proceed monadically?
12:39:58 * edwardk googles
12:41:05 <johnbs> sounds interesting -- i was wondering earlier if there was a library that would do both together (it always seems silly having to write separate parsers and printers and mess around manually ensuring they can round-trip properly)
12:42:28 <edwardk> kinda like how i always wanted a REPL that would output a diff to the library I was using it on that encapsulated what i've done
12:43:46 <johnbs> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.5876 <-- do you mean that?
12:45:13 <johnbs> ah, maybe this will do what I want ( http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/ )
12:46:02 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2214#a2216  i have solved it through explicit recursion (if anyone is interested :P)
12:47:29 <HugoDaniel> one day im going to get rich with this curl bots / data analysis / presentation kind of things :P
12:47:58 <beelsebob> how might I go about chosing a random item from a Data.Map in an efficient way?
12:48:10 <HugoDaniel> its too much web 2.0 not to get rich by doing it :)
12:48:12 <beelsebob> s/item/key/
12:48:39 <HugoDaniel> random = 4
12:49:08 <Eelis> is there a way to disable the automatic satisfiability-based resolution for a specific cabal flag?
12:49:09 <beelsebob> the only way to do it is to get a list of keys, and pick an n between 0 and length keys
12:49:11 <beelsebob> :/
12:49:14 <beelsebob> list lookup icky
12:49:55 <paczesiowa> beelsebob: woudn't that get fused away?
12:50:03 <beelsebob> fused with what?
12:50:04 <johnbs> beelsebob: can't you just use Data.Map.elemAt?
12:50:21 <beelsebob> oh, neat johnbs, thanks
12:50:25 <paczesiowa> beelsebob: oh, nvm, you don't want to use it in its flattened form
12:50:44 <HugoDaniel> is there any way to get the database id of the inserted data with hodbc ?
13:04:38 <jpcooper> are there any alternatives to BEEP as a kind of simple middleware protocol?
13:04:48 <jpcooper> (which have implementations in Haskell)
13:12:27 <Eelis> why does "runhaskell Setup.hs configure" complain about missing dependencies for executables with "Buildable: False" ?
13:22:16 <paper_cc> can anyone explain the difference between Reactive and Behavior in the Reactive FRP library?
13:22:51 <ddarius> Behavior a = Reactive (Time -> a)
13:23:52 <paper_cc> ddarius: ah. thanks =)
13:28:39 <Taejo> > [(0, 0)..]
13:28:40 <lambdabot>       No instance for (Enum (t, t1))
13:28:40 <lambdabot>        arising from the arithmetic seque...
13:31:24 <kerlo> > [undefined..]
13:31:26 <lambdabot>   * Exception: Prelude.undefined
13:31:49 <kerlo> Gee, I wonder why.
13:31:50 <skorpan`> [1..undefined]
13:31:55 <skorpan`> > [1..undefined]
13:31:56 <lambdabot>   * Exception: Prelude.undefined
13:31:58 <kerlo> > [maxBound..] :: Int
13:32:00 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
13:32:07 <kerlo> > [maxBound..] :: [Int]
13:32:09 <lambdabot>   [9223372036854775807]
13:32:22 <kerlo> What a weird maximum bound.
13:32:46 <kerlo> > log (fromIntegral (maxBound :: Int) + 1) / log 2
13:32:48 <lambdabot>   63.0
13:33:04 <pejo> Isn't that 2^63?
13:33:07 <kerlo> So, 64-bit signed integer.
13:33:24 <Cale> > 2^63
13:33:25 <lambdabot>   9223372036854775808
13:33:28 <kiris> take that, visual basic
13:33:28 <Cale> > 2^63 - 1
13:33:30 <lambdabot>   9223372036854775807
13:34:00 <kerlo> > (maxBound :: Int) == 2^63 - 1
13:34:03 <lambdabot>   True
13:34:16 <kiris> :t maxBound
13:34:17 <lambdabot> forall a. (Bounded a) => a
13:34:22 <kiris> @src Bounded
13:34:22 <lambdabot> class  Bounded a  where
13:34:22 <lambdabot>     minBound, maxBound :: a
13:35:02 <Cale> > [2^(2^n - 1) - 1 | n <- [0..]]
13:35:03 <lambdabot>   [0,1,7,127,32767,2147483647,9223372036854775807,170141183460469231731687303...
13:39:34 <Cale> > iterate (\x -> 2^x - 1) 2
13:39:49 <lambdabot>   thread killed
13:40:08 <Cale> > take 5 $ iterate (\x -> 2^x - 1) 2
13:40:11 <lambdabot>   [2,3,7,127,170141183460469231731687303715884105727]
13:43:21 <dons> so lots of cool new libraries and apps this week.
13:43:56 <pulc> hi
13:44:06 <dons> a distributed map/reduce framework, doctest for haskell, llvm update, harpy updated, an implementation of C++ futures, a dph mona lisa solver, and happstack
13:44:17 <dons> so much code, so little time
13:44:20 <pulc> !list
13:44:36 <pejo> dons, and lots of interesting things to read on top of that!
13:46:14 <tibbe> dons: do you know if we have a multicore machine I can run some tests on?
13:46:27 <tibbe> dons: I'm writing a sawzall like library but only have two cores to test on
13:46:39 <tibbe> dons: if it had some striped disks that would be even better :)
13:48:01 <dons> and all the icfp papers, yes.
13:48:12 <dons> tibbe: hmm. ask dcoutts for access to sparky?
13:48:15 <dons> the sun opensparc box?
13:48:25 <tibbe> dons: hmm, good idea
13:48:31 <dons> maybe we should get a multicore x86_64 for communiity
13:48:34 <tibbe> dons: do we have the specs for that box somewhere?
13:48:51 <dons> it's an OpenSPARC T2
13:48:52 <tibbe> dcoutts: ping
13:49:02 <dons> lots of memory, 16 or 8 cores? 64 hardware threads
13:50:42 <tibbe> dons: it would be really cool if we had a few striped disks on ZFS too
13:50:46 <tibbe> dons: to do parallel I/O
13:50:51 <pumpkin-> mmm
13:51:04 <tibbe> dons: I'm trying to write a general purpose sawzall library that would do well on the Wide Finder 2 benchmark
13:51:38 <dons> awesome
13:51:53 <tibbe> dons: I'm testing on my laptop though which is a bit unreliable
13:52:06 <tibbe> dons: it's hard to turn off all power saving settings
13:52:16 <tibbe> dons: especially for the disk
13:53:21 <dons> yeah, i use a quad core at work for benchmarking now
13:54:23 <tibbe> dons: I have a dual core at work, I guess I should be able to get hold of something better. It's just hard to get a beefy machine that's not being used by someone else
13:54:35 <tibbe> dons: maybe I could use an EC2 instance
13:55:34 <shapr> Aren't EC2 instances only dual-core?
13:55:47 <shapr> tibbe: A real quad core isn't very expensive.
13:55:57 <shapr> Anything with more cores is more expensive.
13:57:18 <roconnor> woah
13:57:29 <roconnor> where did the new haskell reddit logo come from?
13:57:37 <roconnor> It's really quite good
13:58:14 <gnuvince_> roconnor: from the logo contest.  It's not bad, but it's no #51 by Mr Wheeler
13:58:29 <roconnor> gnuvince_ really, I find it comparable
13:58:48 <roconnor> gnuvince_, well the font for haskell in the reddit logo isn't great
13:59:00 <roconnor> but the logo itself, I think it is up there with #51
13:59:12 <gnuvince_> roconnor: this one (#19) is really the only other one I wouldn't mind being picked
13:59:21 <tibbe> shapr: it's a space issue, I have no more space for computers in my apartment
13:59:23 <roconnor> oh right, we are doing condorcet voting
13:59:30 <roconnor> that's great.  I get to rank my choices
13:59:44 <pumpkin-> tibbe: you accepting PMs?
13:59:55 <gnuvince_> roconnor: but tell me this isn't nice and modern: http://community.haskell.org/~eelco/logos/logo7000.png
14:00:19 <tibbe> pumpkin-: now, didn't see it :)
14:00:39 <roconnor> gnuvince_ that isn't my favourite varient.  A modern logo needs more rounded corners :)
14:00:58 <paczesiowa> I don't think that, presenting haskell logo inside a square, screams fun, like it should
14:01:49 <roconnor> paczesiowa: nothing screams fun like #100
14:02:07 <gnuvince_> The nice thing about the >>= variations is that's really associated with Haskell.  Lambda could be a bunch of other functional languages (especially Scheme)
14:02:23 <shapr> tibbe: Buy a shelf? :-)
14:02:44 <jleedev> gnuvince_: it looks more like an airline logo to me
14:03:00 <roconnor> gnuvince_ but there is an H in the square lambda logo.  That is haskelly
14:03:01 <gnuvince_> jleedev: I'd fly on that airline :)
14:03:32 <jleedev> haskell: industrial-strength in-flight service
14:03:51 <tibbe> shapr: I guess
14:04:03 <gnuvince_> "The fly doesn't take off until you are needed somewhere"
14:04:05 <tibbe> shapr: I also don't know how much longer I'll stay in switzerland
14:04:07 <gnuvince_> s/fly/plane
14:04:21 <tibbe> dons: you won't be in SF any time soon?
14:04:21 <tibbe> :)
14:04:31 <roconnor> which one is like an airline logo?
14:04:58 <jleedev> http://community.haskell.org/~eelco/logos/logo7000.png
14:05:05 <roconnor> oh
14:05:27 <jleedev> (in a good way)
14:05:58 <edwardk> @seen pumpkin
14:05:59 <lambdabot> I saw pumpkin leaving #haskell.it, #haskell-overflow, #haskell, #ghc and #haskell-blah 12h 42m 18s ago, and .
14:06:31 <roconnor> heh
14:06:39 <pumpkin-> ?
14:06:44 <roconnor> I get a kick out of lightbulb logos whenever I see them.
14:06:56 <edwardk> pumpkin: did you get my earlier bit about linear arrows?
14:07:06 <pumpkin-> oh, nope?
14:07:44 <roconnor> isn't 54 the same as 51?
14:08:08 <beelsebob> is there any way to query the GHC runtime and ask it how many lightweight threads its running?
14:08:11 <roconnor> and 55
14:08:23 <roconnor> well, half of 55
14:08:26 <edwardk> pumpkin: ah basically pointed out that you run into the problem that you have non-well-formed versions of even that notion, because you can apply arrows to themselves infinite numbers of times in haskell, etc.
14:08:35 <edwardk> just by manipulating the arrow primitives ;)
14:08:48 <pumpkin-> :o
14:09:07 <edwardk>  pumpkin: so all you did was push the problem down a level ;)
14:09:12 <edwardk> still needs type system support
14:12:34 <dublpaws> @users
14:12:34 <lambdabot> Maximum users seen in #haskell: 658, currently: 621 (94.4%), active: 19 (3.1%)
14:12:53 <tibbe> dons: do you have the date of a usable nightly snapshot of GHC handy?
14:19:36 <dons> tibbe: i think the recent ones are all good
14:20:14 <dons> blackh: my automated inliner found some improvements for your k-nuck
14:20:15 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=all
14:20:43 <Heffalump> what does your automated inliner do?
14:20:54 <dons> it uses a GA to breed best inlining points.
14:21:02 <Heffalump> using pragmas?
14:21:07 <dons> yep
14:21:11 <dons> also improved nbody,
14:21:12 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=all
14:21:20 <blackh> That is totally brilliant - it makes a huge difference!
14:21:28 <dons> i think i can tweak it to do the same for `par` and ! ....
14:21:35 <tibbe> dons: where's the inliner?
14:21:48 <Heffalump> ! sounds dangerous, how will you be sure the code is generally correct afterwards?
14:21:49 <pumpkin-> mkUniqueGrimily
14:21:59 <tibbe> dons: oh, and btw is there a repo for ghc-core. I want to contribute some patches to turn off coloring/asm output
14:22:02 <dons> Heffalump: inlining is almost always safe ...
14:22:18 <Heffalump> I just said '!' sounds dangerous, not that your inliner is
14:22:22 <dons> oh !
14:22:25 <dons> :)
14:22:26 <Heffalump> !!
14:22:37 <dons> yeah, the strictness one is harder. i think that should be user-supplied hints
14:22:45 <dons> tibbe: http://code.haskell.org/~dons/code/ghc-core/
14:22:48 <Heffalump> I guess the user could write ?! or something
14:22:54 <dons> tibbe: i've not relesaed the code yet, but am writing it up today
14:22:56 <Heffalump> and then you could decide which ones to actually use
14:22:58 <dons> yeah
14:23:12 <Heffalump> so how's your thesis?
14:23:19 <dons> :P
14:23:32 <beelsebob> winnar
14:23:42 <beelsebob> Haskell is completely smacking JCSP about here
14:23:49 <beelsebob> 68000 threads and not sweating
14:23:55 <dons> cool
14:23:57 <beelsebob> Java died horribly at 25000
14:24:21 <nanothief> @pl \c -> if (all isSpace $ last c) then init c else c
14:24:21 <lambdabot> join (ap (if' . all isSpace . last) init)
14:24:24 <edwardk> beelsebob: please tell me it'll be younger than that when it finally dies. ;)
14:24:34 <beelsebob> lol
14:24:40 <pumpkin-> edwardk: hmm, I still don't get it :)
14:24:42 <dons> blackh: the only problem with the GA is it takes 12+ hours to finish
14:24:54 <beelsebob> in the mean time – I've made a Haskell bible generator >.>
14:25:19 <edwardk> pumpkin i can define a identity function: A -o A  right?
14:25:31 <vegai> beelsebob: you made god? :P
14:25:34 <dons> we really need to work out binary-trees though. it's letting the side down.
14:25:35 <HugoDaniel> bible as in the holy book ?
14:25:36 <pumpkin-> yup
14:25:43 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp&box=1
14:25:46 <ImOuttaYourMonad> anyone good at topology? what would be a good programming exercise to solve a simple topology problem?
14:25:54 <beelsebob> vegai: "who shall be a present sent not displease my lord: thou into your brother will lead on my wages be?"
14:25:56 <blackh> dons: I posted a comment about binary-trees on reddit.
14:26:45 <blackh> http://www.reddit.com/r/haskell/comments/82va0/can_you_write_a_better_parallel_binarytrees/  Call me a defeatist. :)
14:26:49 <beelsebob> it's a markof chain toy, that spawns a thread for every word it sees
14:26:55 <Cale> World's Religious Texts -> Markov Chain Dissociator -> New Religious Movements!
14:27:04 <edwardk> pumpkin and being that that you want to represent that as an arrow in Haskell, we can fix it applyed to (>>>)
14:27:06 <edwardk> @type fix (arr id >>>)
14:27:08 <lambdabot> forall b (a :: * -> * -> *) d. (Arrow a) => a b d
14:27:28 <edwardk> because you can take the fixpoint in the 'metalanguage' that manipulates your arrows
14:27:51 <dons> mm. not sure if function calls have that much cost, blackh
14:28:03 <dons> they're basically push'n'jmp
14:28:19 <edwardk> but if you want a linear language that term shouldn't exist
14:28:46 <blackh> dons: The reason for this conclusion is the sheer amount of improvement of such a small change in an allocation-heavy piece of code. There could be some wrong assumption lurking there, as ghc optimization seems to be a fairly complex beast.
14:29:06 <dons> well, mm. isn't check all traversals and Int# ?
14:29:11 <dons> it's not actually allocating is it?
14:29:20 <dons> so unrolling would be expected to improve things -- less jumps
14:29:42 <dons> i'd expect it not to mater much in 'make' but to matter in 'check'
14:29:46 <edwardk> pumpkin: make sense?
14:29:53 <blackh> It's 10% improvement overall in a benchmark that does a lot of allocation overall (one allocation per loop in 'check' even though 'check' isn't doing it)
14:29:54 <pumpkin-> edwardk: sort of :)
14:30:16 <dons> yeah, that's interesting.
14:30:21 <blackh> If loop unrolling makes that much difference, then it seems like a lot.
14:30:31 <edwardk> the resulting category needs all sorts of things that hask can't have. i.e. a terminal object
14:30:42 <dons> yes, so its surprising loop unrolling is noticeable
14:31:20 <dons> i strongly doubt function calls cost more in ghc than say, erlang.
14:31:42 <blackh> You could be right, but it looks like there's something worth investigating there.
14:31:50 <dons> blackh: maybe attach the notes to the binary-trees ticket in ghc's bug db?
14:32:01 <blackh> I'll do that.
14:32:05 <gwern> thought improvements which prevent cache misses were supposed to be surprisingly large/nonlinear
14:32:08 <gwern> maybe that's what's happening
14:32:16 <blackh> I'll put some detailed evidence in there.
14:32:23 <pejo> dons, doesn't erlang try to adjust the stack so they can be tail-recursive even between functions with different number of arguments?
14:32:49 <dons> maybe, but erlang is slow, is my point.
14:32:59 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=hipe&box=1
14:33:10 <dons> while the gc issues are enough (i think) to be the dominant factor here
14:33:18 <centrinia> Is that pronounced "hype" or "hippie"?
14:33:33 <gwern> dons: well, maybe that's it - haskell is so fast that small changes have disproportionate effects
14:33:36 <dons> are there any other GC langs doing as well as haskell in that binary-trees benchmark, blackh ? just the jvm ones and erlang?
14:34:02 <dons> and lisp is about the same. interesting
14:35:49 <augustss> dons: If there were a compiler flag to set the default for the RTS flags, would that be disallowed?
14:36:31 <augustss> I've often wished for such a compiler flag.
14:36:31 <dons> not if it was some generic set, no. so -server would be ok.
14:36:39 <dons> it just has to be generic, not application/problem-specific
14:36:52 <dons> so -server could actually check how much ram, cpu, cache, and then tune a set of numbers...
14:37:53 <augustss> But not {-# OPTIONS_GHC --set-rts-flag -H1G #-} ?
14:38:06 <dons> no, i think that would be illegal.
14:38:34 <dons> but --expect-to-be-on-a-server
14:38:38 <dons> would be ok.
14:38:39 <pejo> So increasing the default heapsize for 6.12 would be ok, but not a flag?
14:38:41 <Tobsan> > :[]
14:38:42 <lambdabot>   <no location info>: parse error on input `:'
14:38:48 <dons> right
14:38:51 <Tobsan> > ():[]
14:38:52 <lambdabot>   [()]
14:38:58 <Heffalump> why are INLINE pragmas ok then?
14:39:00 <pejo> The rules seem a bit arbitrary.
14:39:00 <dons> has to be general purpose, not specific to the one benchmark
14:39:01 <augustss> dons: are you not allowed per-application compiler flags in general?
14:39:01 <pumpkin-> kind of ridiculous, can't we just make an argument against their silly rules?
14:39:26 <dons> for this one benchmark, they choose not to allow runtime flags that modify GC behaviour
14:39:33 <idnar> pumpkin-: if you allow benchmark specific customisations, then you can completely hack the system
14:39:45 <pumpkin-> how so?
14:39:53 <idnar> pumpkin-: ghc --benchmark=benchmark-name
14:40:01 <idnar> pumpkin-: and it just prints out a pre-stored result
14:40:04 <dons> no that's silly. no one's doing that.
14:40:10 <idnar> well, sure
14:40:10 <pumpkin-> idnar: you could always do that in the code :P
14:40:16 <dons> so whether it makes sense not to allow RTS flags is a separate matter
14:40:19 <pumpkin-> idnar: the point is, they look at the tests and approve them
14:40:30 <idnar> but that's the direction you're heading in once you start doing that
14:40:35 <pumpkin-> if it's just main = print 124125629825 -- the result
14:40:45 <dons> idnar: i think it's pretty clearly not a slippery slope
14:41:05 <pumpkin-> there's only so much compiler flags can do
14:41:09 <dons> the broader question is what/why are the current defaults set?
14:41:19 <pumpkin-> the point is to simulate what an expert in the language would write to go as fast as possible, it seems
14:41:19 <BONUS> well irl you'd use compiler flags to boost your performance
14:41:23 <pumpkin-> exactly
14:41:23 <augustss> idnar: that's nonsense.  For optimal performance of a program, I expect to tweak some flags.  I don't see how this is any different.
14:41:29 <centrinia> Looking up complete look-up tables is just as slow as computing the results.
14:41:43 <idnar> augustss: the benchmark is intended to demonstrate general case performance
14:41:44 <edwardk> dons: ok, so cull through the tests, figure out if there is a fairly uniform setting for the RTS flags and talk the ghc folks into accepting a patch that adds "--server" or something ;)
14:41:54 <pejo> Speaking about parallel performance - is anyone aware of papers about implementing parallel futures cheaply? It feels like something "everybody" knows but my google-fu is weak.
14:41:57 <idnar> augustss: doing tweaking on a per-program basis perverts that, I think
14:42:11 <Heffalump> idnar: using a GA to find INLINE points perverts that too
14:42:15 <augustss> idnar: but the general case is that you tweak the flags if you care about performance
14:42:22 <edwardk> pejo: its trickier than it sounds at first to get good performance out of them
14:42:27 <Japsu> !dice 80d10
14:42:31 <edwardk> pejo: what platform are you working on?
14:42:33 <Japsu> @dice 80d10
14:42:33 <lambdabot> 80d10 => 404
14:42:33 <dons> yes, sylvan made a good point on reddit that RTS flags are just how we live with a complex runtime
14:42:36 <dons> so they're quite idiomatic
14:42:43 <pumpkin-> idnar: it's measuring how well an experienced programmer can use the language implementation to achieve maximum performance, I think, and flags/obscure code are not perversions of that
14:42:50 <Japsu> (that's how much a friend of mine's character got damage in D&D)
14:42:57 <dons> pejo: http://hackage.haskell.org/packages/archive/future/1.0.0/doc/html/Control-Concurrent-Future.html ?
14:43:03 <pejo> edwardk, x86 would be jsut fine.
14:43:14 <idnar> augustss: well, sure; and maybe you rewrite part of the program in another language, or precalculate results, or ... -- but that doesn't mean any of those belong in a general-purpose benchmark
14:43:29 <idnar> although the question of where language features end and compiler flag tweaking starts is not entirely clear-cut
14:43:39 <pumpkin-> idnar: do unboxed values and low-level GHC constructs belong then?
14:44:01 <pumpkin-> is "idiomatic haskell" just writing a naive list-based algorithm?
14:44:12 <edwardk> pejo: well, high-performance futures tend to be very OS specific because, say in the world of windows you want to use low cost events for signalling, etc.
14:44:46 <Heffalump> it's very tempting to tell tuomov to please abandon Haskell software as it'd make all our lives better
14:44:56 <pumpkin-> tuomov?
14:45:01 <idnar> Heffalump: I thought he already did
14:45:12 <Heffalump> he's asking questions on ghc-users
14:45:15 <Heffalump> so I guess he didn't
14:45:16 <idnar> oh boy
14:45:29 <idnar> I hate people who whine about going away instead of just going away
14:45:32 <Heffalump> he still seems to be using darcs despite its fascist character set leanings or whatever
14:45:36 <centrinia> Are OPTIONS_GHC pragmas considered to be a case of compiler flag tweaking?
14:45:56 <dons> i think we need to clarify something.
14:45:58 <idnar> but then, we are talking about the guy who prefers Cygwin over a real Linux / UNIX / whatever system
14:46:01 <pejo> edwardk, ok, pthreads then, on some unixy OS, with a CPU that has CAS or similar.
14:46:03 <edwardk> pejo: i'm pretty familiar with the implementations used by Intel's thread building blocks, the .NET ParallelFX library, and a couple of other fast future implementations. the former are pretty heavily obsessed with avoiding round trips into the kernel.
14:46:15 <dons> the only tweaking flags /not/ allowed are +RTS -H or -A (GC flags) on the binary-tress benchmark
14:46:26 <dons> that's the only case. so its a bit of an odd one, yes, but in general you can tune all day
14:46:35 <stepcut> ?pl \e -> e >>= f
14:46:35 <lambdabot> (f =<<)
14:47:24 <Heffalump> I guess the point is that that benchmark is very sensitive to GC.
14:47:40 <dino-> Can you instruct cabal install to get a version other than the latest?
14:47:51 <Heffalump> I think you can just say foo-0.5
14:48:02 <Heffalump> but I could be misremembering and thinking of the way ghc-pkg works
14:48:11 <dons> Heffalump: right.
14:48:13 <dino-> ok, where foo<nothing> defaults to foo-<latest-version>
14:48:20 <dino-> oh
14:49:28 <centrinia> Does GHC include a garbage collector in every executable?
14:49:34 <pumpkin-> yup
14:49:35 <Heffalump> yes
14:49:46 <edwardk> pejo: ok, in unix land, emitting it: write the value, issue a write barrier, then signal. the signal can be lightweight so it only allocates a posix event if someone waiting needs to block on it. pick up checks to see if the signal is set, picks up if so, otherwise goes through the slow path of allocating an event, etc.
14:49:54 <centrinia> That's why the executables are so large. :(
14:50:21 <Heffalump> centrinia: they are so large because there's an entire RTS and large bits of the standard library in every executable
14:50:28 <Heffalump> the GC itself is probably relatively small
14:50:50 <edwardk> pejo: if you go the naive route of allocating an event for every signal it'll never scale
14:51:12 <ddarius> centrinia: The code to implement GC probably takes up less than 4kb.
14:51:20 <ddarius> s/implement/implement and support
14:52:13 <pumpkin-> centrinia: stripping the binaries helps a lot
14:52:19 <pumpkin-> sometimes
14:52:20 <pumpkin-> :)
14:52:42 <dons> its interesting we link the rts in every app, but we don't take advantage of that to specialize it automatically for every app
14:53:02 <edwardk> centrinia: the RTS for GHC is pretty big, its not the GC ;)
14:53:18 <centrinia> What does the RTS contain?
14:53:26 <Heffalump> dons: that'd be cool in principle, but difficult in practice
14:53:29 <dons> i wonder if there'd be any benefit to take a combined .hc bundle and the rts .c files, and compile them together, rather than linking as we currently do
14:53:40 <dons> Heffalump: yep
14:53:45 <dons> centrinia: most of a micro kernel
14:54:01 <edwardk> centrinia: every form of parallelism anyone ever baked into haskell, all the primops for arbitrary sized integers, etc. STM, thread scheduling...
14:54:04 <dons> threads, scheduler, io, memory management, signals ...
14:54:15 <Deewiant> centrinia: pass "+RTS --help" to any GHC-compiled program and see ;-)
14:54:35 <dons> Heffalump: so a partial whole program optimiser
14:54:41 <dons> using just the C backend
14:54:47 <edwardk> breaking up the RTS would probably go father towards shrinking GHC executables than anything
14:54:48 <ddarius> dons: A libghc, in analogy with libc, would save a good chunk of space.
14:54:55 <dons> oh most def.
14:55:04 <dons> helloworld goes to 4k or so with dyn linked libghc
14:55:15 <Heffalump> dons: C compilers only do inlining cross-procedure, though
14:55:16 <dons> edwardk: interesting. split objs for the rts
14:55:17 <Heffalump> (in reality)
14:55:25 <Heffalump> so it might make a bit of difference, but I doubt it would be much
14:55:37 <dons> yeah, we'd want our own tool i imagine
14:55:42 <dons> doesn't jhc put  them all in a single file?
14:55:53 <edwardk> dons: yeah, but its a whole program optimizer
14:55:57 <Heffalump> I think jhc effectively specialises its own RTS for each program, though I could be confused.
14:56:01 <dons> yes, iirc, it emits ansi C for the .hs part, drops in the rts , resluing in a single .C file
14:56:50 <edwardk> they specialize the entire RTS down to the cases used by the program, so even the parts that get included get tuned
14:57:11 <dons> mm
14:57:15 <dons> but no GC in jhc
14:57:35 <bremner> yikes, isn't that problematic?
14:57:45 <edwardk> yeah, mainly because they don't have any 'safe points' in the way they compile down from GRIN
14:57:56 <Heffalump> bremner: not really, since noone actually uses it for real programs :-)
14:58:15 <Heffalump> dons: I can't really see what specialisations you could get for a GC to a specific program.
14:58:16 <edwardk> bremmer: works fine if you don't run any program for too long ;)
14:58:25 <dons> well, it'd be nice to have an ICFP paper on JHC one day.
14:58:42 * ddarius would prefer a practical JHC.
14:58:45 <dons> Heffalump: yeah, it'd have to do some thing to estimate size/shape/amount of data i imagine
14:59:03 <dons> all jhc needs to do is publish weekly benchmarks against ghc to scare GHC HQ
14:59:07 <dons> then its work would be done.
14:59:13 <edwardk> ddarius: i think meacham bet the bank on being able to make region collection work well enough, and when it didn't he kinda wandered away from jhc in general, but i'm guessing
14:59:33 <pumpkin-> isn't he in here?
14:59:38 <ddarius> edwardk: I'm not worried about GC.  GC is irrelevant if you can't even compile the program.
14:59:43 <johnbs> he came in a few minutes ago
15:00:41 <edwardk> i know thats why i walked away from my original nuel compiler, the region inference stuff i was relying on couldn't keep me from leaking memory like a sieve. ;)
15:01:09 <ddarius> Floating garbage
15:01:40 <johnbs> i'd be very interested in hearing what problems you hit with it.  was it just not accurate enough? or were there problems with even getting a "correct" algorithm at all?
15:01:46 <SamB> meacham is back, actually
15:02:25 <johnbs> (actually i guess those two are the same since you can just trivially put everything in the same region and say it's "correct" because nothing gets deallocated too soon)
15:02:34 <edwardk> nowadays i have a more practical model with 'regions' just playing the role of determining what thread is responsible for it and pinning roots whenever i share something with another thread, so that 99% of the time i can just collect locally a la erlang.
15:02:37 <augustss> I think region allocation works much better in a struct language
15:02:40 <augustss> strict
15:02:55 <edwardk> augustss: yeah. laziness plays hell with it
15:03:22 <ddarius> edwardk: You could have abandoned laziness instead.
15:03:36 <Heffalump> when a thunk is forced, is it now automatically garbage?
15:03:58 <edwardk> johnbs: tofte or talpin did a summary paper reviewing '10 years of regions' or something that talked very effectively to that point
15:04:09 <johnbs> edwardk: thanks, i'll look that up
15:04:15 <ddarius> Heffalump: If you update the thunk, then yes.
15:04:28 <edwardk> ddarius: no thank you. with laziness goes a lot of the elegance of haskell syntax, you pick up crap like value restrictions, etc.
15:04:46 <ddarius> edwardk: The value restriction is way conservative.
15:04:54 <Heffalump> do garbage collectors generally make use of that?
15:05:18 <ddarius> Heffalump: They don't need to do anything special.  There's nothing pointing to the forced closure once the thunk is updated.
15:05:32 <SamB> http://blog.gmane.org/gmane.comp.lang.haskell.jhc
15:05:33 <edwardk> Heffalump: well you can still have references to the unevaluated thunk. when the GC runs it just forwards them straight to the result though.
15:05:35 <Heffalump> ddarius: sure, but they still waste effort figuring that fact out in some sense
15:06:23 <Heffalump> though I guess since most collectors are copying collectors which just don't do anything with garbage it doesn't matter
15:06:30 <ddarius> Heffalump: Not necessarily and any way it'll probably need to trace the references of the closure anyway so "telling the GC" would be costly.
15:06:34 <edwardk> ddarius: yes, but even its less restrictive variants ultimately impose some form of syntactic means to distinguish fun from val.
15:07:09 <SamB> I really wish I could bring myself to merge in his changes, but I can't seem to get over http://bugs.darcs.net/issue833
15:07:11 <ddarius> edwardk: Just don't have types and all this trouble goes away.  kata doesn't have types...
15:07:55 <dons> i think this is a good direction http://ha4.fajno.net/2009/03/pandoc-can-we-use-it-ouside-of-haskell.html
15:07:58 <edwardk> ddarius: hah, but it gets to be so clean by being lazy. ;)
15:08:09 <dons> someone has taken our great pandoc lib, and wrapped it to be easily used by in this case, C and PLT Scheme
15:08:19 <pejo> edwardk, "syntactic means to distinguish fun from val"?
15:08:20 <dons> we should do more of that, making good haskell tech easier to encorporate.
15:08:28 <dino-> Heffalump: Thanks re: cabal install specific version
15:09:01 <dons> ?users
15:09:01 <lambdabot> Maximum users seen in #haskell: 658, currently: 618 (93.9%), active: 22 (3.6%)
15:09:09 <sinelaw> @seen Peaker
15:09:09 <lambdabot> I saw Peaker leaving #haskell and #haskell-blah 23h 31m 17s ago, and .
15:09:14 <sinelaw> @seen PeakerWork
15:09:14 <lambdabot> I saw PeakerWork leaving #haskell-blah and #haskell 4h 36m 16s ago, and .
15:09:24 <edwardk> pejo: when is something run? when you open the module? when you ask it to run by passing it a ()? strictness kinda throws that issue in your face.
15:09:51 <Botje> > foldr1 f [a,b,c]
15:09:53 <lambdabot>   f a (f b c)
15:10:02 <Botje> > foldr1 f [a]
15:10:04 <lambdabot>   a
15:10:06 <Botje> excellent :)
15:10:24 <edwardk> besides there's no one else really camping out the 'lazy untyped' corner of programming-language land ;)
15:10:25 <pejo> edwardk, sure, but you're going to run it anyways - otherwise you wouldn't have put the code there.
15:10:49 <edwardk> modulo a couple of toy lazy lisps
15:10:56 <pumpkin-> mmm libpandoc
15:11:00 <pejo> edwardk, make it impure and you'll be one of few brave men!
15:11:08 <edwardk> pejo: hah thought about it ;)
15:11:21 <ddarius> edwardk: So you are going to push those squatters off with your toy untyped Haskellishy thing.
15:12:01 <edwardk> ddarius: sure. and my boundless enthusiasm ;)
15:13:00 <edwardk> i figure if i include enough category theory and abstract algebra in the prelude i can scare them away... alongside any potential user of the language. ;)
15:13:12 <pumpkin-> awesome
15:13:20 <edwardk> i've admittedly had better plans
15:13:48 <tibbe> dons: do you use ghc-core for your day-to-day performance optimizing? do you post process the results in any way. There are lots of annotations in the core
15:14:20 <ddarius> dual id : free monoid 'a -> free monoid 'a -- better known as reverse
15:14:43 <pumpkin-> is there a formal definition of dual by the way?
15:14:57 <pejo> edwardk, did you happen to have any references regarding the implementation of the futures, or was it all in your head?
15:14:57 <pumpkin-> I know plenty of examples of duals
15:15:07 <ddarius> For how I was using it there, yes.  For CT, yes.  In general, probably not.
15:15:25 <paper_cc> is there a simple notation for (flip (.)) except (>>>)?
15:15:27 <pumpkin-> I see
15:15:41 <pumpkin-> paper_cc: (. moo)
15:15:46 <edwardk> pejo: a lot of it is in my head. you might find that the c# community has a ton of resources on cheap event models, but they require some translation to turn into examples you can use in a posix setting.
15:16:39 <paper_cc> pumpkin-: @unpl
15:16:52 <pumpkin-> then no, I guess :)
15:17:07 <pumpkin-> what's wrong with >>> ?
15:17:42 <paper_cc> pumpkin: it takes space =)
15:17:44 <dons> tibbe: i read ghc-core output directly , day to day, ye.
15:17:54 <dons> but i'm doing mostly optimizing work at the moment
15:18:27 <edwardk> paper_cc: every time i ask someone if i should try to extend kata's syntax to allow "(;) = flip (.)" i get laughed at for some reason.
15:19:27 <Olathe> I hate wasps.
15:19:42 <pumpkin-> got stung?
15:20:09 <tibbe> dons: even the smallest functions blow up a lot
15:20:18 <tibbe> dons: and there are lots of @s in there
15:21:47 <Heffalump> I find it very hard to read too
15:22:01 <dons> i think it takes practice.
15:22:07 <dons> but yes, it could be easier.
15:22:13 <dons> i've only been doing it for 5 years.
15:22:16 <pumpkin-> I found it got a lot easier when I removed the fully qualified names, not sure if ghc-core does that for you
15:22:34 <pumpkin-> I was playing around with -ddump-simpl output directly
15:22:34 <dons> http://galois.com/~dons/images/ghc-core.png
15:22:37 <dons> is what ghc-core does
15:22:43 <dons> which should always be better than -ddump-simpl
15:22:48 <pumpkin-> ah cool :)
15:22:52 <pejo> edwardk, I'd be happy to manually schedule things on the pthreads if necessary. But I'll look around in the C# camp.
15:23:01 <pejo> edwardk, thanks.
15:23:06 <tibbe> dons: I think renaming it what's most painful
15:23:19 <tibbe> dons: it would be nicer if GHC could use the original name + counter
15:23:26 <dons> mm
15:23:29 <dons> yes.
15:23:30 <pumpkin-> dons: will it preserve CORE pragmas?
15:23:37 <dons> maybe?
15:23:47 <pumpkin-> ok
15:23:53 <tibbe> dons: everything being called a, a1, a2 isn't very helpful
15:24:09 <tibbe> dons: it's even hard to find the function you're looking for if it has been broken up/inlined
15:26:03 <tibbe> dons: I'm going to add a --no-asm flag to ghc-core if you don't mind
15:26:13 <tibbe> dons: or <your preferred name here>
15:26:16 <pumpkin-> ah yeah, it does seem to preserve the CORE notes
15:26:32 <dons> tibbe: ok.
15:26:47 <tibbe> dons: since it's takes a while to scroll past it all
15:27:28 * Heffalump finally wakes up and notices that ghc-core is a package that does useful things
15:27:49 <dons> Heffalump: oh my
15:27:59 * dons imagines Heffalump thought it was just another silly dons toy
15:28:02 <Heffalump> <taptaptap cabal install>
15:28:03 <edwardk> pejo: a lot of stuff was written up as msdn articles. you might also want to look up joe duffy
15:28:16 <Heffalump> no, I thought it was a way of talking about GHC's core...
15:28:23 <dons> weird
15:28:46 <dons> no, when simonmar was visiting galois last year we were talking about how to interactively tune core output
15:28:55 <dons> and i wrote a little tool to play with the ideas
15:29:14 <maxote> http://www.ats-lang.org/   ATS -- unleashing the potential of types!  version 0.0.1 lol
15:29:45 <Heffalump> maxote: ATS has a reputation for being really fast
15:30:05 <pejo> It's only going to get harder to read core though - the more optimizations you throw at it - the less likely you are to find something that resembles your original program.
15:30:26 <monochrom> I hate its verbose lengthy unorganized language for proofs but otherwise it's the right thing.
15:30:47 <Heffalump> pejo: that's inevitable. But if the core that directly corresponded to your input program really did closely correspond to it, you'd have a much better chance
15:32:00 <pejo> Heffalump, oh, definitely agreed. I find it painful to read myself, and I know where I should end up when I start reading it. Doing it on random programs would make me utterly confused.
15:32:13 * paper_cc learns reactive-glut
15:32:19 <paper_cc> Can anyone help? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2220#a2220
15:32:46 <paper_cc> This is supposed to print out average frames-per-second rate to the console, but it stalls on the first frame
15:34:02 <paper_cc> (though it works as intended when I remove the filterE part)
15:36:17 <viraptor> is there any stupid local mail forwarder that works well with `darcs send`? I don't want to mess with exim / sendmail just to send patches :/
15:36:27 <Olathe> pumpkin-: No, one seems to have made a home between the window glass and the inner screen next to my computer.
15:37:16 <Boney> viraptor: ssmtp
15:38:01 <viraptor> Boney: thanks, checking...
15:38:29 <Boney> all boxes should have some sort of MTA installed for this sort of thing.  But now-days few people recognise the need, they think that a webmail account is sufficent.
15:39:03 <pumpkin-> Olathe: oh no
15:40:05 <tibbe> dons: done. how would you like the patch?
15:40:30 <pejo> viraptor, darcs send -o output.darcs gives you a file
15:42:37 <dons> tibbe: darcs send is preferred
15:42:37 <sjanssen> viraptor: I use msmtp, it works well and is very easy to set up
15:42:50 <tibbe> dons: ok, to your galois address?
15:44:00 <tibbe> dons: sent, I think
15:44:11 <tibbe> darcs was very quick sending that
15:44:12 <tibbe> :)
15:44:24 <tibbe> i hope it worked
15:47:27 <viraptor> Boney: do you need any special command for ssmtp? it ignores my sender address :/ --sendmail-command="esmtp -v -t -fmy@email %<"
15:50:04 <dons> tibbe: got it
15:50:14 <tibbe> dons: great
15:50:33 <tibbe> dons: it could be somewhat more beautiful in the way I add the -ddump-asm option
15:52:57 <kerlo> Ah yes, now I get to apt-get all of GHC's modules. Do I want to do "apt-get install libghc*"?
15:53:28 <Heffalump> kerlo: that will get you more than what is normally bundled with GHC
15:53:37 <Heffalump> but it probably won't hurt
15:53:59 * kerlo does so
15:54:14 <Heffalump> (does that actually work, if you escape the *?)
15:54:38 <Heffalump> ooh, yes. Neat.
15:55:16 <aL3aqrab> i neED smtp Pm aLL spammer
15:55:24 <Heffalump> kerlo: hmmm, though it seems to pick up libghemical* which you don't want
15:57:44 <kerlo> But that doesn't start with libghc.
15:57:50 --- mode: ChanServ set +o dons
15:57:52 --- mode: dons set +b *!*n=a9b@*.rabat2-27-236-12-196.wanamaroc.com
15:57:52 --- kick: aL3aqrab was kicked by dons (dons)
15:57:56 --- mode: ChanServ set -o dons
15:58:00 <Heffalump> kerlo: yeah. I don't quite understand why it gets picked up.
15:58:06 <dons> tibbe: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghc-core-0.4.3
15:58:06 <Heffalump> But it definitely did on my machine.
15:58:41 <kerlo> Huh.
15:58:49 <Heffalump> and libghttp1
15:58:52 <kerlo> e looks to similar to c, I guess. :-P
15:59:05 <kerlo> too, rather.
15:59:09 <tibbe> dons: that was fast, thanks!
15:59:18 <Heffalump> oh well. /me disappears
16:03:08 <tibbe> why would "main" have more than one entry in the profiling output? in particular, why would it have 124?
16:04:08 <gwern> tibbe: maybe main calls itself?
16:04:40 <tibbe> gwern: nope
16:09:44 <tibbe> gwern: hmm, removing one call to getArgs brought that down to 1
16:10:21 <Alpounet> bye
16:10:40 <gwern> @src getArgs
16:10:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:15:01 <johnbs> is there an easy way of making a withState function for parsec, that looks like  withState :: ParsecT s u m a -> u -> ParsecT s () m a
16:15:39 <johnbs> it feels like that should be easy, but i'm hitting problems with everything i try :(
16:17:01 <glguy> is there any better way to add a list of vectors in polar form than to convert them to cartesian coordinates, add those, and convert back to polar?
16:17:22 <roconnor> nope
16:17:39 <glguy> :(
16:17:53 <roconnor> well, you could keep the vectors in non-polar form
16:17:58 <roconnor> that would be better :)
16:18:10 <glguy> the inputs and outputs to the function need to be in polar form
16:18:38 <roconnor> "need"
16:20:35 <ImOuttaYourMonad> "Our prototype machine - the Reduceron -is implemented using an FPGA, and is based on a simple template-instantiation evaluator. Running at only 91.5MHz on an FPGA, the Reduceron is faster than mature bytecode implementations of Haskell running ona 2.8GHz PC." that sounds insane, almost to good to be true.
16:21:30 <megaTherion> hi
16:21:49 <Boney> viraptor: you should just be able to use it the way you'd use /bin/sendmail or /bin/mail
16:21:50 <kerlo> FPGAs have many elements all running at 91.5MHz, don't they?
16:22:16 <ImOuttaYourMonad> so what does it mean really?
16:22:21 <megaTherion> anyone can tell me how to count in haskell while iterating over an list?
16:22:36 <roconnor> The Reduceron has many limitations that make it simply a neat toy, is my understanding.
16:22:41 <gwern> ImOuttaYourMonad: yeah, but for the price of that fpga you can buy an 8-core machine and hire a programmer to spend an hour parallelizing and tuning your code
16:22:41 <glguy> zipWith f [0..]
16:22:48 <glguy> or, mapAccumL
16:23:01 <kerlo> I don't know. Price is the important thing, really.
16:23:03 <p_l> gwern: depends how big a fpga you are buying
16:23:35 <gwern> p_l: big enough to run interesting programs, I suppose
16:24:10 <pejo> gwern, wasn't it a several years old FPGA they used?
16:24:33 <gwern> don't remember. but few people have fpgas sitting around anyway
16:24:36 <ImOuttaYourMonad> isnt an fpga just a small par tof a computer?
16:24:36 <p_l> also, they reference a bytecode implementation of haskell
16:24:41 <gwern> you have to pay for it eventually
16:24:46 <ImOuttaYourMonad> ImOuttaHereToWikipedia
16:25:12 <pejo> gwern, an 8-core machine is $2k though, and the programmer is what, $50 per hour?
16:25:46 <tromp_> > showIntAtBase 2 intToDigit (floor (256*0.1343994140625)) ""
16:25:47 <lambdabot>   "100010"
16:25:55 <gwern> pejo: an 8-core processor isn't 2k
16:25:58 <tromp_> > showIntAtBase 2 intToDigit (floor (250.131984447004608326*)) ""
16:25:59 <lambdabot>       No instance for (RealFrac (t -> t))
16:25:59 <lambdabot>        arising from a use of `floor...
16:26:05 <tromp_> > showIntAtBase 2 intToDigit (floor (250.131984447004608326)) ""
16:26:06 <lambdabot>   "11111010"
16:26:08 <gwern> keep in mind, a fpga needs motherboard harddrive regular processor etc
16:26:31 <gwern> also, if you phrase it right on -cafe the parallelizing is probably free :)
16:27:09 <tromp_> > showIntAtBase 2 intToDigit (floor (256*0.131984447004608326)) ""
16:27:11 <lambdabot>   "100001"
16:27:45 <pejo> gwern, if people don't have FPGA's laying around they surely don't have dual processor motherboards laying around either.
16:27:59 * Japsu has an FPGA laying around
16:28:01 <Japsu> ^^
16:28:09 * pumpkin- has a dual-processor mobo lying around
16:28:20 * mle has an fpga and dev-board lying around
16:28:31 <p_l> pejo: I've got a RISC computer lying around, waiting for more parity SIMMs
16:28:35 * Japsu also has C2Q Q9300 2,5GHz and Xeon E5430 2,0 GHz at his disposal ^^;
16:28:58 <Japsu> (oh, two of those xeons to be accurate)
16:29:03 * p_l is looking at gettin another Alpha and who knows, maybe few SPARCs :D
16:29:17 <gwern> pejo: I think a lot of recent motherboards support multi-core processors... my processor is quad-core and I picked cheap stuff
16:29:27 <Japsu> I've learned just about enough VHDL to think of doing something useful with the FPGA
16:29:27 <gwern> (you buy a lot of desktop power these days)
16:29:33 <Japsu> it's an Altera DE2 ev board
16:29:40 <p_l> gwern: Intel made it sure that everyone put SMP chips on normal mainboards
16:29:59 <pejo> gwern, quad core yes, 8-core requires two processors => enterprise market.
16:30:18 <kerlo> Is there a nice way to check the amount of CPU power a Linux machine has?
16:30:24 <gwern> eh, that'll change in another crank of moore's law
16:30:29 <pejo> kerlo, cat /proc/cpuinfo
16:30:33 <Japsu> there'll be 8-core Nehalem-EXen soon
16:30:35 <skorpan`> kerlo: uname -a
16:30:54 <p_l> Japsu: AFAIK they are two-socket configurations
16:31:17 <Japsu> p_l, err, I remember reading about 8-core single-socket XEons
16:31:20 * p_l is waiting for AMD's 32nm cpus
16:31:21 <Japsu> s/E/e/
16:31:26 <p_l> Japsu: 6 core
16:31:51 <p_l> Japsu: And they are in fact 3 dual-core xeons slapped on one module
16:32:11 <Japsu> p_l, http://www.tietokone.fi/uutta/uutinen.asp?news_id=36700 (in Finnish, sorry)
16:32:22 <kerlo> According to /proc/cpuinfo, normish.org has a 2-GHz dual-core CPU with one core.
16:32:29 <Japsu> "http://www.infoworld.com/article/09/02/05/Intel_eightcore_server_chip_is_Nehalem_EX_1.html?source=fssr"
16:32:38 <gwern> dual-core with one core?
16:32:45 <kerlo> Yep.
16:32:45 <Japsu> seems eight-coreish to me
16:32:45 <gwern> zomg someone stole normish's core!
16:32:46 <p_l> Japsu: Well, Nehalem might have 8core configuration
16:32:56 <kerlo> Someone bring my core back.
16:33:14 <p_l> Japsu: I'm still more inclined to wait for next-gen AMD stuff, with FireStream on chip :)
16:33:16 <gwern> obviously EVA-1 ate the core
16:33:17 <Japsu> p_l, yes, that is called nehalem-EX
16:33:23 <kerlo> Also, it has four entries. Three of them are for core 0, one is for core 1.
16:33:32 <Japsu> p_l, I'd like to see AMD get back to the race, but it isn't looking too good
16:33:32 <p_l> Japsu: In place of Xeon?
16:33:51 <Japsu> "The chip will likely take the spot in the product lineup that's currently held by the six-core 2.4GHz Xeon 7450, 2.13GHz Xeon 7455 and 2.66GHz Xeon 7460 processors"
16:33:58 <Japsu> http://www.techworld.com.au/article/275610/intel_confirms_eight-core_server_chip_nehalem_ex
16:34:13 <Japsu> so yes, it will probably be sold as Xeon
16:34:36 <p_l> Japsu: It would require probably quite a bit of black ops. Maybe even killing off some of the stuff that now comes in BIOS to come in something like Alpha's SROM
16:34:47 <Japsu> err
16:34:51 <Japsu> wtf are you saying
16:35:30 <p_l> Japsu: multi-core mobile cpus from AMD had BIOSes remove many important powersaving capabilities
16:35:42 <p_l> Japsu: AMD knew nothing about it
16:35:46 <Japsu> ...right
16:35:51 * p_l had one of those
16:36:00 <Japsu> last time I checked we were discussing eight-core xeons, not mobile AMD processors
16:36:16 <p_l> Japsu: But without funding, you won't get far :)
16:36:39 <p_l> And this is just an example of what happens
16:36:59 <p_l> Still, multi-socket market seems to be now dominated by AMD for anything bigger than two sockets
16:37:58 <p_l> though more than two-sockets in x86-world is a rare thing
16:38:08 <kiris> http://en.wikipedia.org/wiki/Nomad_(disambiguation) <- scroll tot eh bottom
16:38:27 <p_l> lol
16:38:52 <gwern> old 4chan jok
16:39:07 <gwern> the haskell nomads and the knights of the lambda calculus, warring against python
16:39:34 <p_l> ... Baughn warned me but I didn't expect 4chan on #haskell
16:39:56 <p_l> otoh, /g/ managed to release their own grid software, so...
16:40:03 <kiris> gwern: I think you mean ``FIOC''
16:40:21 <gwern> '     Discipline was tight in the Haskell nomads. If a given expression did
16:40:22 <gwern>      not behave deterministically he had to be wrapped up in the shroud of
16:40:22 <gwern>      the monad and returned to the homelands after a ritualistic suicide -
16:40:22 <gwern>      they couldn't afford to have monads in their tight-knit battle group. '
16:40:48 <Baughn> p_l: ##C, ##lisp, #haskell: The ugly, the pretty, the just plain weird.
16:41:13 <kiris> #lisp is scary;_;"
16:41:29 <gwern> 'He didn't notice, however, that Cons' intention was not to slay him with the lambda but rather to incorporate the lambda into a foldl incantation to collapse the OCaml's state into a single return value. The OCaml let out a scream as the tail-recursivefunction produced a single value from his state without any side-effects: -3.'
16:41:40 <p_l> kiris: No more, we don't have many trolls now
16:43:10 <kiris> gwern: quality literature
16:43:36 <Olathe> What sort of pack animal do monads use to carry their belongings as they wander ?
16:43:41 <gwern> kiris: if you say so
16:44:07 <gwern> Olathe: a caml, I always figured
16:44:15 <gwern> it is only fitting that they be our servants
16:44:32 <Gracenotes> http://en.wikipedia.org/wiki/Nomad_(disambiguation)_
16:44:39 <kerlo> Didn't I hear something once about an OI comonad?
16:44:44 <kiris> they also have an unfortunate sweet spot for pearls
16:44:45 <kerlo> Like IO, but a comonad instead.
16:45:50 <pumpkin-> lol
16:46:57 <chessguy> @type either
16:46:58 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:47:38 <Olathe> @type either (const Nothing) Just
16:47:39 <lambdabot> forall a a1. Either a1 a -> Maybe a
16:47:58 <chessguy> hmm. i don't get this
16:48:06 <chessguy> isValid x = let result = valid x in
16:48:06 <chessguy> 	either (const False) (const True) result
16:48:56 <Olathe> It gives False iff valid x failed.
16:49:04 <ddarius> isValid = either (const False) (const True) . valid
16:49:08 <kerlo> False if it's Left, True if it's Right, no?
16:49:10 <Olathe> If it succeeded, it gives true.
16:49:17 <chessguy> ddarius:  yeah, that's what i would have expected
16:49:18 <Olathe> Yep.
16:50:01 <Gracenotes> @. djinn type either
16:50:03 <lambdabot> f a b c =
16:50:03 <lambdabot>     case c of
16:50:03 <lambdabot>     Left d -> a d
16:50:03 <lambdabot>     Right e -> b e
16:50:06 <tibbe> what does :CoIO stand for in Core output?
16:50:20 <tibbe> and all these `cast`s?
16:50:34 <chessguy> i would've probably written "isValid x = case valid x of Left _ -> False.."
16:51:13 <chessguy> @pl i x = x >> return ()
16:51:13 <lambdabot> i = (>> return ())
16:51:15 * ddarius probably wouldn't have written isValid in the first place.
16:51:19 <Olathe> @djinn Either a b -> Bool
16:51:20 <lambdabot> f a =
16:51:20 <lambdabot>     case a of
16:51:20 <lambdabot>     Left _ -> False
16:51:20 <lambdabot>     Right _ -> True
16:51:22 <monochrom> yes, "either" is a packaging for the case expression.
16:51:41 <Olathe> @djinn Either a b -> Int
16:51:41 <lambdabot> Error: Undefined type Int
16:51:41 <Gracenotes> djinn got the Left/Right right :)
16:51:47 <Olathe> @djinn Either a b -> Maybe b
16:51:48 <lambdabot> f a =
16:51:48 <lambdabot>     case a of
16:51:48 <lambdabot>     Left _ -> Nothing
16:51:48 <lambdabot>     Right b -> Just b
16:51:58 <Olathe> @djinn Either a b -> Maybe a
16:51:59 <lambdabot> f a =
16:51:59 <lambdabot>     case a of
16:51:59 <lambdabot>     Left b -> Just b
16:51:59 <lambdabot>     Right _ -> Nothing
16:52:23 <Olathe> @djinn Maybe b -> Either a b
16:52:23 <lambdabot> -- f cannot be realized.
16:52:27 <Olathe> Bah.
16:52:28 <Gracenotes> @djinn Either a b -> Either b a
16:52:28 <lambdabot> f a =
16:52:28 <lambdabot>     case a of
16:52:28 <lambdabot>     Left b -> Right b
16:52:28 <lambdabot>     Right c -> Left c
16:52:47 <Olathe> @djinn Maybe a -> Maybe b
16:52:48 <lambdabot> f _ = Nothing
16:53:03 <Olathe> @djinn Either a b -> Either a c
16:53:03 <lambdabot> -- f cannot be realized.
17:01:29 <megaTherion> does haskell have any pow function?
17:01:32 <ddarius> dons: That xmonad layout is cool.  The definition of it is also cool.
17:01:34 <ddarius> :t pow
17:01:36 <lambdabot> Not in scope: `pow'
17:01:40 <ddarius> :t (^)
17:01:41 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
17:01:41 <ddarius> :t (^^)
17:01:42 <Gracenotes> we have three
17:01:43 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:01:43 <ddarius> :t (**)
17:01:45 <ddarius> :t exp
17:01:45 <lambdabot> forall a. (Floating a) => a -> a -> a
17:01:46 <lambdabot> forall a. (Floating a) => a -> a
17:02:00 <Gracenotes> four counting e^ :x
17:02:50 <dons> ddarius: the gimp one?
17:03:14 <ddarius> dons: Yes.
17:03:31 <dons> yeah, its nice how relative haskell newbies are doing config "programming" succesfully
17:03:47 <ddarius> dons: It really demonstrates "compositional layout combinators"
17:23:08 <shapr> Who recommended the STM as GC paper to me?
17:23:12 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:12 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:12 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:13 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:13 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:13 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:15 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:17 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:18 --- mode: ChanServ set +o Cale
17:23:19 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:19 <pumpkin-> @where ops
17:23:19 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
17:23:21 <mib_melvt2g1> http://ihateyoujessica.com/?id=q2dfvhtpd5bgnivlo0acfme6r32pwz
17:23:23 --- mode: Cale set +b *!*@gateway/web/ajax/mibbit.com/x-db7ccbb01cae375e
17:23:23 --- kick: mib_melvt2g1 was kicked by Cale (Cale)
17:23:23 <SubStack> banpz
17:23:29 --- mode: ChanServ set +o glguy
17:23:30 <shapr> dang
17:23:31 <pumpkin-> *sigh*
17:23:33 <shapr> I'm slow
17:23:37 <SubStack> Cale++
17:23:39 <shapr> I need a script for erc.
17:23:42 <Japsu> fragcount++
17:23:45 --- mode: Cale set -oo Cale glguy
17:23:48 <wli> msg #haskell-blah There's probably a way to implement it as an LBA.
17:24:02 <shapr> Looks like mibbit is causing trouble again.
17:24:20 <conal> shapr: if you make an erc script, please let me know.
17:24:24 <Gracenotes> hint: don't click. least not without adblock :/
17:24:33 <shapr> conal: You use erc too?
17:24:43 <ddarius> Gracenotes: Why would you click it?
17:24:43 <shapr> Gracenotes: Um, yeah :-)
17:24:48 <m0nkfish> lol what an excellent idea
17:24:53 <Gracenotes> ddarius: I didn't
17:25:05 <shapr> If they advertised it so very much, it's best to ignore it.
17:25:20 <m0nkfish> i clicked it
17:25:32 <m0nkfish> im still curious as to whether its genuine
17:25:39 <Gracenotes> it's a money-making ad scheme
17:25:41 <m0nkfish> but not too bothered about the incentive itself
17:25:42 <shapr> right
17:25:47 --- mode: ChanServ set +o glguy
17:25:50 --- mode: glguy set +d client-86-25-194-189*
17:25:53 <shapr> Anyway
17:25:55 <conal> shapr: yep.  i love emacs.
17:25:58 <m0nkfish> of course it is an ad scheme
17:25:59 <shapr> Me too!
17:26:00 <pumpkin-> it's clearly a smart way to get people to advertise your site for you
17:26:10 --- mode: glguy set -oo Cale glguy
17:26:11 <shapr> m0nkfish: What do you think about software transactional memory?
17:26:23 <m0nkfish> eh
17:26:26 <skorpan`> i can't figure out a definition of (<*>) for the Maybe monad... could someone give me a hint?
17:26:36 <shapr> m0nkfish: How can I make money with STM?
17:26:42 <skorpan`> (a hint, not the solution)
17:26:51 <m0nkfish> sell it for many rupees
17:26:59 <shapr> hm
17:27:03 <nominolo> dcoutts_: do you happen to know whether I need to do something special when *using* Gtk on OSX. I built it against the Gtk framework which supposedly does not need X11
17:27:57 <wli> Hmm. Axiom is supposed to implement large chunks of the Risch algorithm.
17:28:08 <L11> I need to write a function that tests whether a tree is balanced. My initial plan was to check each individual node, however this seems like it would have unecessary and redundant compution. Any more efficient methods?
17:28:48 <Olathe> L11: I think you have to do that.
17:28:57 <monochrom> I may be able to write a proof that you must visit every node at least once.
17:29:00 <Olathe> L11: You could precompute it as well while you're building the tree.
17:29:07 <monochrom> perhaps s/visit/query/
17:29:12 <Olathe> L11: Then, it would be fairly simple to compute.
17:29:17 <L11> hm
17:29:24 <L11> i'm not sure if thats an option
17:29:32 <L11> to precompute it
17:29:35 <Olathe> L11: But without that or some special type of tree, you have to visit all nodes.
17:29:43 <nominolo> L11 do you mean you want to use breadth-first traversal?
17:29:46 <L11> well its a binary tree
17:30:04 <L11> nominolo: possibly - can you refresh my memory as to what that is?
17:30:11 <ddarius> skorpan`: (<*>) = ap for any monad, hard to make that a hint
17:30:11 <Olathe> I mean, if you used a self-balancing binary tree, that would be something.
17:30:33 <monochrom> I don't understand the recent volley of such "how to ___ without <provably necessary work>" question. What is your real question?
17:30:42 <skorpan`> ddarius: so let's say it's not a monad
17:30:50 <nominolo> L11: http://en.wikipedia.org/wiki/Breadth-first_search
17:31:17 <Olathe> L11: If you want to keep your trees balanced, I'd recommend one of the nice self-balancing trees.
17:31:20 <nominolo> this way you can stop as soon as you have a layer that is not balanced
17:31:33 <Olathe> nominolo: Ahh, that's a good idea.
17:31:54 <L11> Olathe: well i will be given a tree, I need to decide if its balanced
17:32:12 <L11> so my first instinct was to check all nodes, and make sure its balanced
17:32:14 <wli> In-core B+ trees are good for cache and TLB behavior.
17:32:24 <L11> however in my instructions it says not do use this method
17:32:37 <L11> just wanted to see if anyone knew of any methods that would work better
17:34:12 <Olathe> L11: nominolo's way can skip a lot of work if it's not balanced.
17:34:41 <ddarius> Using a depth-first search will also skip a lot of (different) work.
17:34:59 <Olathe> Ahh, yes, that's also right.
17:35:13 <L11> hm i need to whip out my algorithms book :P
17:35:34 <monochrom> All you need is a recursive mind.
17:35:45 <pumpkin-> if you know how to do DFS, swap a stack for a queue and you have it
17:36:49 <monochrom> You need to compare depths of left subtree and right subtree.
17:38:01 <L11> hm
17:38:11 <Olathe> L11: If the first two leaf nodes are way out of balance, you can stop there.
17:38:35 <Olathe> L11: As one example. If you use &&, laziness will save you work
17:38:36 <L11> yea
17:39:28 <centrinia> You could also (lazily) construct another tree with the same shape as your given tree but whose nodes contain the heights of each subtree. You can then look for nodes with a left node that is much larger than the right node, or vice versa.
17:41:07 <ImOuttaYourMonad> ok im looking around at stanford and mits courses and it seems you can never learn that much can you? you will always be a fool. im interested in applied mathematics, im swedish, i will finish high school in 2years. where should i go to school? is it hard to get into cambridge or oxford(brr not sweden)?
17:41:19 <pumpkin-> o.O
17:41:31 <Gracenotes> O.o
17:41:38 <centrinia> o.O.o
17:41:42 <pumpkin-> lol
17:41:46 <SubStack> ImOuttaYourMonad: you could go to school up here in Alaska
17:41:48 <SubStack> even colder
17:42:10 <Gracenotes> ImOuttaYourMonad: one MIT course that was useful to me was the algorithms one
17:42:35 * SubStack used haskell for all his algorithms assignments
17:42:35 <ImOuttaYourMonad> I meant that there is so incredibl much to learn that even after you finsihed a PhD you still dont know that much,
17:42:49 <pumpkin-> of course, doesn't mean you can't go and soak up all you can
17:42:51 <ImOuttaYourMonad> i didnt mean there wasnt much to learn
17:43:00 <ImOuttaYourMonad> yes but is overwhelming
17:43:20 <SubStack> meh
17:43:39 <centrinia> Most professors will not be able to recall everything they learned in their studies without reference material. They might recall some of it though.
17:43:47 <SubStack> learn new things for the sake of building neat projects
17:43:49 <monochrom> "where to go to school" is a wrong question. "where to drink water" is a more relevant question. You need to avoid lead in water plumbing.
17:43:50 <Olathe> ImOuttaYourMonad: If you want to really learn, you have to do it on your own.
17:43:52 <Gracenotes> well, that reinterpretation of your comment was depressing
17:43:54 <Gracenotes> :(
17:43:56 <ImOuttaYourMonad> like i like math one dya it is easy the next day it is superhard. maybe i push myself to hard
17:44:03 <Olathe> ImOuttaYourMonad: Courses are nice as a starting point, but that's it.
17:44:26 <ImOuttaYourMonad> yes i want to learn so i can build
17:44:33 <gwern> memorizing most stuff is not necessary - 'nor need you regret the hours spent studying, for the shadow of lost knowledge at least protects you from many illusions'
17:44:49 <SubStack> ImOuttaYourMonad: then find something neat you'd like to build and build it
17:45:55 <SubStack> like an underwater rov or a sequence prediction algorithm or a wildfire simulator
17:46:00 <TomMD> Or go to the proposals page if you can't think of anything.
17:46:22 <gwern> SubStack: the problem is the optimal sequence prediction algorithm is uncomputable :(
17:46:28 <ImOuttaYourMonad> well i building computer games, tyring to learn image analyssi to do medical analysis
17:46:44 <SubStack> gwern: there are some ways to arrive at nice approximations
17:46:58 <ImOuttaYourMonad> and maybe i want to do a sports channel via internet thats treams sports and then run algorithms on it that automatically records highlights
17:47:11 <tomh> you want too much
17:47:16 <gwern> (but limiting results like AIXI are very depressing in a way)
17:47:37 <monochrom> I want to write programs that write correct programs.
17:47:50 <pumpkin-> yay, haskell can do that
17:47:50 <centrinia> I want to write correct programs that write correct programs.
17:47:57 <tomh> easy
17:48:01 <pumpkin-> @faq can haskell write programs that write correct programs?
17:48:01 <lambdabot> The answer is: Yes! Haskell can do that.
17:48:07 <Gracenotes> main = putStrLn ""
17:48:09 <tomh> write programs that output empty programs
17:48:11 <Gracenotes> looks correct to me
17:48:20 <Gracenotes> tomh: great minds think alike!
17:48:29 <Gracenotes> x.x
17:48:42 <tomh> hehe
17:48:51 <SubStack> gwern: regular languages might form a nice basis for a pushdown automata model
17:48:56 <centrinia> Isn't "programs" plural? The trivial program is only singluar. ;)
17:49:13 <SubStack> or so I've heard...
17:49:47 <Olathe> There are lots of ways to do a finite amount of nothing correctly.
17:50:04 <nominolo> dcoutts_: nvm, it works already
17:50:08 <gwern> centrinia: I'm sure there are multiple empty programs. 'main = return ()', 'main = { return () }' etc
17:50:21 <pumpkin-> would you call those distinct programs?
17:50:40 <centrinia> They are the same program modulo some relevant equivalence relation.
17:51:02 <ddarius> main = return n forall n :: Integer
17:51:20 <dons> dcoutts: we have the mighty simplifier, and the evil mangler, and the glorious glasgow compiler
17:51:23 <dons> but what is the inliner called?
17:51:29 <dons> the Intriguing Inliner?
17:51:31 <gwern> insightful inliner?
17:51:40 <dons> Intricate Inliner?
17:51:48 <kerlo> Ingenious Inliner?
17:51:51 <dons> mm
17:51:58 <gwern> Inglorious Inliner
17:52:02 <monochrom> insideous inliner
17:52:05 <dons> well, no, it is sommewhat glorious
17:52:09 <dons> i like ingenious
17:52:16 <dons> it thinks of things i'd not dream of doing
17:52:17 <monochrom> it is not ingenious
17:52:23 <dcoutts> dons: it's part of the mighty simplifier
17:52:31 <monochrom> oh, it is ingenious? nevermind.
17:52:36 <dons> yes. but it really is important enough to have its own evil name
17:52:37 <dons> http://research.microsoft.com/en-us/um/people/simonpj/papers/inlining/index.htm
17:52:43 <kerlo> Incipient Inliner.
17:52:45 <pumpkin-> inclusive inliner :P
17:52:54 <ddarius> "Intricate" is the adjective that has sounded most accurate so far
17:52:56 <centrinia> Jetty Juxtaposer. Lauder Linker. Mighty Maker.
17:53:10 <dons> ddarius: yes
17:53:20 <ddarius> The alliteration is also apparently not necessary.
17:53:27 <monochrom> well-tempered inliner
17:53:36 <pumpkin->  book 2
17:53:38 <centrinia> ddarius, tell that to Canonical. :(
17:53:40 <ImOuttaYourMonad> is there any real research on the theorem generstors in haskell? someone posted a link to a site which if you give it s type of a function it gives you the implementation(or somehitng)?
17:53:42 <kerlo> I prefer the equal-tempered inliner, myself.
17:53:47 <Axman6> dcoutts: about the hackell platform stuff, i had a go at reinstalling all the packages, and it seems like a lot of the warnings are just using -fyyy instead of -XYyy, and a few pattern match warnings
17:53:55 <kerlo> Actually, is equal temperament a form of well-temperament?
17:53:56 <pumpkin-> ImOuttaYourMonad: @djinn ?
17:54:02 <centrinia> @djinn (a,b) -> a
17:54:02 <lambdabot> f (a, _) = a
17:54:16 <gwern> Inquisitive Inliner?
17:54:26 <centrinia> Inept Inliner. :)
17:54:34 <Axman6> @djinn Bool a -> a -> (a -> b) -> b
17:54:34 <lambdabot> Error: kind error: (KArrow (KVar 0) (KVar 2),KStar)
17:54:44 <Axman6> @djinn Bool -> a -> a -> (a -> b) -> b
17:54:44 <lambdabot> f a b c d =
17:54:44 <lambdabot>     case a of
17:54:44 <lambdabot>     False -> d c
17:54:44 <lambdabot>     True -> d b
17:54:58 <gwern> inquisitive works on multiple levels - curious as in it's an interesting thing, or it's interested in finding out where to do stuff, or it's related to the Inquisition and thus is sinister :)
17:55:04 <monochrom> empowering inliner
17:55:05 <kerlo> @djinn (a -> b -> c -> d -> e -> f -> g -> h -> i) -> (a -> b -> c -> d -> e -> f -> g -> h) -> (a -> b -> c -> d -> e -> f -> g) -> (a -> b -> c -> d -> e -> f) -> (a -> b -> c -> d -> e) -> (a -> b -> c -> d) -> (a -> b -> c) -> (a -> b) -> a -> i
17:55:05 <lambdabot> f a b c d e f g h i =
17:55:05 <lambdabot>     a i (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))) (d i (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i))))) (c i
17:55:05 <lambdabot> (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))) (d i (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))))) (b i (h i) (
17:55:05 <lambdabot> g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))) (d i (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i))))) (c i (h i) (g i (h
17:55:07 <lambdabot> i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))) (d i (h i) (g i (h i)) (f i (h i) (g i (h i))) (e i (h i) (g i (h i)) (f i (h i) (g i (h i)))))))
17:55:11 <kerlo> ¡Ay!
17:55:11 <pumpkin-> o.O
17:55:18 <monochrom> empowering inliner --- it empowers other optimizers
17:55:26 <Axman6> wow, impressive that worked
17:55:27 <ddarius> Enabling
17:55:33 <gwern> but that doesn't alliterate!
17:55:43 <centrinia> Expensive Inliner.
17:55:45 <monochrom> Nothing alliterates anyway.
17:55:46 <kerlo> The adjective should start with "ex".
17:55:51 <gwern> Instamatic Inliner
17:56:02 <kerlo> Exceptinal Inliner.
17:56:05 <monochrom> explosive inliner
17:56:07 <centrinia> Inaccurate Inliner. :)
17:56:09 <kerlo> -tional, even.
17:56:12 <Spark> inlining inliner
17:56:15 <centrinia>  :O
17:56:22 <gwern> inliner inliner
17:56:24 <pumpkin-> inane inliner
17:56:33 <kerlo> Inliner inanity.
17:56:35 <monochrom> outspoken inliner
17:56:40 <Spark> hitler hitler
17:56:43 <m0nkfish> exhillarating inliner
17:56:49 <gwern> you see, 'inliner inliner' would be one of the others, but the noun inliner got inlined into the name
17:56:56 <monochrom> haha
17:57:07 <dcoutts> dons: I like illustrious inliner
17:57:18 <m0nkfish> eyecatching eyeliner
17:57:26 <centrinia> Intercal Inliner. o.O
17:57:41 <Spark> lining inns since 1847
17:57:43 <gwern> dcoutts: that's not too bad - goes well with glorious
17:58:02 <dons> :)
17:58:14 <Spark> intoxicated inliner
17:58:18 <monochrom> hehe Spark
17:58:37 * gwern presents the illustrious inliner, the most eligible code-phase in the county
17:58:43 <pumpkin-> :P
17:59:12 <SubStack> Spark: exxon valdez?
17:59:15 <Spark> sounds like an aircraft carrier
17:59:25 <Spark> the illustrious inliner of death
18:00:20 <Spark> http://en.wikipedia.org/wiki/File:HMS_Illustrious_1.jpg
18:00:55 <skorpan`> when i use "succ" in my code, i get "ambiguous type variable `a'", but (+1) works just fine.  while they do have different types, what about the type of succ makes ghci complain?
18:01:09 <skorpan`> or maybe what about the type of (+1) makes ghci understand?
18:01:09 <harblcat> is rewriting a good way to think about haskell program execution?
18:01:15 <monochrom> "1" enjoys defaulting.
18:01:38 <Spark> harblcat: it works well for any language that uses expressions
18:02:00 <skorpan`> monochrom: was that for me?
18:02:05 <monochrom> Yes.
18:02:08 <skorpan`> what do you mean?
18:02:20 <monochrom> numbers enjoy defaulting.
18:02:29 <kerlo> skorpan`: are you familiar with Haskell's classes?
18:02:41 <dolio> They also enjoy cake.
18:02:45 <skorpan`> kerlo: some of them
18:02:53 <kerlo> > show minBound
18:02:55 <lambdabot>   "()"
18:02:58 * kerlo blinks
18:03:09 <monochrom> http://haskell.org/onlinereport/decls.html#sect4.3.4 has details on defaulting
18:03:10 <gwern> numbers are looking for a logical mate who likes long walks on the beach, and cake
18:03:12 <skorpan`> "numbers enjoy defaulting", does that mean that there is a default definition in the case of (+1)?
18:03:27 <Spark> i enjoy my victims before they die
18:03:40 <ozy`> :t (+1)
18:03:41 <lambdabot> forall a. (Num a) => a -> a
18:03:41 <monochrom> default choice of type.
18:03:43 <kerlo> skorpan`: suppose you have a value of type Foo a => a -> String, and another value of type Foo a => a.
18:03:43 <ImOuttaYourMonad> If I say: I need: [[Integer]] -> [Integer]; forall a in input, a in result; would it be possible to generate functions that satisfies that? with genetic programming perhaps?
18:03:47 <gwern> numbers look for a room-mate who doesn't have a throw-up prone pet
18:03:51 <kerlo> If you apply the former to the latter, what instance of Foo does it use?
18:03:54 <ImOuttaYourMonad> tha would eb flatten for example
18:03:56 <ozy`> :t let f = (+ 1) in f
18:03:58 <lambdabot> forall a. (Num a) => a -> a
18:04:00 <ozy`> oh right
18:04:03 <ImOuttaYourMonad> foldr (++) []
18:04:04 <wli> I should probably go back to a more basic paper about type inference.
18:04:23 <Axman6> @src concat
18:04:23 <lambdabot> concat = foldr (++) []
18:04:48 <skorpan`> kerlo: i don't know?
18:05:04 <kniu> :t foldr
18:05:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:05:07 <kerlo> ImOuttaYourMonad: generate a function of a certain type satisfying certain properties?
18:05:26 <kerlo> skorpan`: and that's the thing. GHC doesn't know either; unless there's a default instance specified somewhere, you need to tell it.
18:06:32 <skorpan`> i don't quite follow, but thanks :P
18:06:48 <monochrom> I begin to hate this defaulting business. "(+) is polymorphic and the computer doesn't know what you want without context" should be the end of the story.
18:06:59 <ddarius> default ()
18:07:09 <gwern> @check \x -> x+x == 2*x
18:07:10 <lambdabot>   "OK, passed 500 tests."
18:07:30 <gwern> monochrom: but without extended defaulting we couldn't do that!
18:07:32 <monochrom> @check \x -> succ x == succ x
18:07:33 <lambdabot>   "* Exception: Prelude.Enum.().succ: bad argument
18:07:56 <monochrom> what is extended defaulting?
18:08:00 <pumpkin-> > [0, 0.. 1]
18:08:02 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:08:02 <glguy> gwern: and with it, we don't know what you just tested
18:08:14 <gwern> but we know it was true
18:08:25 <pumpkin-> @check \x -> x == x
18:08:27 <lambdabot>   "OK, passed 500 tests."
18:08:29 <m0nkfish> > last [1..10]
18:08:31 <lambdabot>   10
18:08:32 <pumpkin-> @check \x y -> x == y
18:08:34 <lambdabot>   "OK, passed 500 tests."
18:08:35 <pumpkin-> whee
18:08:37 <monochrom> @check \x -> x
18:08:38 <lambdabot>   "Arguments exhausted after 0 tests."
18:08:46 <m0nkfish> > last [0,0..1]
18:09:02 <lambdabot>   thread killed
18:09:04 <m0nkfish> :(
18:09:07 <kerlo> @check \x y -> x == x + 1
18:09:09 <lambdabot>   "Falsifiable, after 0 tests:\n0\n()\n"
18:09:12 <jleedev> > [minBound .. maxBound]
18:09:14 <lambdabot>   [()]
18:09:40 <kerlo> > map sqrt [minBound..maxBound]
18:09:42 <lambdabot>   Add a type signature
18:09:50 <jleedev> why?
18:10:08 <Axman6> > [minBound .. maxBound] :: [Int64]
18:10:08 <pumpkin-> it doesn't know what to give you
18:10:09 <kerlo> I want to see the full error message there.
18:10:10 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
18:10:16 <Axman6> > [minBound .. maxBound] :: [Int8]
18:10:16 <jleedev> because nothing is both bounded, floating, and enum?
18:10:18 <lambdabot>   [-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114...
18:10:34 <Axman6> @instances Bounded
18:10:35 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
18:10:41 <Axman6> @instances Floating
18:10:41 <lambdabot> Double, Float
18:10:45 <Axman6> @instances Enum
18:10:46 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
18:10:47 <kerlo> > minBound :: Float
18:10:49 <lambdabot>       No instance for (Bounded Float)
18:10:49 <lambdabot>        arising from a use of `minBound'...
18:10:55 <kerlo> Bah.
18:10:59 <jleedev> cool :)
18:11:11 <kerlo> Hmm, what is Dual?
18:11:16 <dolio> > map sqrt [minBound..maxBound] :: [Expr]
18:11:19 <ddarius> @src Dual
18:11:20 <jleedev> > fix error
18:11:23 <lambdabot>   * Exception: not a number
18:11:25 <lambdabot> Source not found. You speak an infinite deal of nothing
18:11:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:11:36 <ddarius> :t Dual
18:11:38 <lambdabot> forall a. a -> Dual a
18:11:42 <gwern> I've never seen dual before
18:11:43 <Axman6> > minBound :: Dual Int
18:11:45 <gwern> @info Dual
18:11:45 <lambdabot> Dual
18:11:45 <ozy`> :t (?:)
18:11:45 <lambdabot>   Dual {getDual = -9223372036854775808}
18:11:47 <lambdabot> Not in scope: `?:'
18:11:49 <pumpkin-> > mconcat $ map (Dual . Sum) [1..10]
18:11:50 <kerlo> > fix (error (fix error))
18:11:53 <lambdabot>   Dual {getDual = Sum {getSum = 55}}
18:11:54 <lambdabot>   * Exception: * Exception: * Exception: * Exception: * Exception: * Exceptio...
18:11:55 <Axman6> > maxBound :: Dual Int
18:11:57 <lambdabot>   Dual {getDual = 9223372036854775807}
18:11:58 <pumpkin-> the dual of the sum!
18:12:04 <Axman6> > maxBound :: Dual Integer
18:12:06 <lambdabot>       No instance for (Bounded Integer)
18:12:06 <lambdabot>        arising from a use of `maxBoun...
18:12:13 <gwern> @hoogle Dual
18:12:13 <lambdabot> Data.Monoid newtype Dual a
18:12:13 <lambdabot> Data.Monoid Dual :: a -> Dual a
18:12:13 <lambdabot> Data.Monoid getDual :: Dual a -> a
18:12:13 <Olathe> Dual is weird.
18:12:22 <jleedev> "The dual of a monoid, obtained by swapping the arguments of mappend."
18:12:26 <Axman6> @hoogle Dual
18:12:26 <lambdabot> Data.Monoid newtype Dual a
18:12:26 <lambdabot> Data.Monoid Dual :: a -> Dual a
18:12:26 <lambdabot> Data.Monoid getDual :: Dual a -> a
18:12:32 <Axman6> @hoogle+
18:12:37 <kerlo> @index Dual
18:12:37 <lambdabot> bzzt
18:12:38 <Axman6> @hoo
18:12:38 <lambdabot> Maybe you meant: hoogle hoogle+ show todo yow
18:12:59 <Axman6> @help todo
18:12:59 <lambdabot> todo. List todo entries
18:13:04 <Axman6> @todo
18:13:04 <lambdabot> 0. SamB: A way to get multiple results from a google search
18:13:04 <lambdabot> 1. dons: improve formatting of @dict
18:13:04 <lambdabot> 2. dons: write Haskell Manifesto
18:13:04 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
18:13:04 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
18:13:06 <lambdabot> [29 @more lines]
18:13:14 <gwern> @more
18:13:14 <lambdabot> 5. TheHunter: @type 1 :: Int
18:13:14 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
18:13:14 <lambdabot> 7. dons: Implement @whatis
18:13:14 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
18:13:16 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
18:13:17 <pumpkin-> :o
18:13:18 <lambdabot> [24 @more lines]
18:13:29 <glguy> gwern: -> /msg
18:13:32 <gwern> @type 1 :: Int
18:13:32 <pumpkin-> Haskell Manifesto!
18:13:34 <lambdabot> Int
18:13:44 <gwern> hm. what's todo about that?
18:13:55 <Axman6> todos for lambdabot?
18:13:59 <pumpkin-> sounds exciting
18:14:06 <kerlo> @type ()
18:14:09 <lambdabot> ()
18:14:18 <pumpkin-> @type undefined :: 1
18:14:20 <lambdabot> Unit
18:14:22 <skorpan`> could someone finish this line from typeclassopedia? "Also, note that although _ >> m = m would be a type-correct implementation of (>>), it"...?
18:14:32 <gwern> 1 is a type?
18:14:36 <Axman6> o.O
18:14:37 <pumpkin-> yeah, strangely enough
18:14:42 <pumpkin-> no other number is though
18:14:43 <monochrom> it would break a monad law.
18:14:50 <Axman6> :t undefined :: 2
18:14:52 <lambdabot> Only unit numeric type pattern is valid
18:14:55 <glguy> skorpan`: wouldn't fulfill the monad laws...
18:14:55 <gwern> @type undefined :: 0
18:14:57 <lambdabot> Only unit numeric type pattern is valid
18:14:58 <Axman6> :t undefined :: 1
18:15:00 <lambdabot> Unit
18:15:04 <skorpan`> glguy: thanks
18:15:08 <Axman6> @hoogle Unit
18:15:09 <lambdabot> Data.Generics data Unit
18:15:09 <lambdabot> Data.Generics Unit :: Unit
18:15:09 <lambdabot> Language.Haskell.Syntax unit_con :: HsExp
18:15:14 <kerlo> I think I remember @type being wonky when the input contained a ::.
18:15:29 <wli> THIH seems to be helping somewhat.
18:15:31 <shapr> @type a :: Int
18:15:31 <glguy> Can we move the lambdabot playing to private message, please
18:15:33 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
18:15:35 <shapr> whoops
18:16:23 <harblcat> Are macros possible in haskell in the same sense as lisp macros?
18:16:37 <kerlo> What do Lisp macros do?
18:16:58 <skorpan`> kerlo: "partial evaluation" i like to call it
18:17:08 <harblcat> basically write code for you.
18:17:18 <shapr> harblcat: Have you seen Template Haskell?
18:17:47 <harblcat> I believe I have
18:17:47 <kerlo> What do Lisp macros do?
18:18:02 <gwern> harblcat: yes and no. lazy evaluation and the typesystem get you very far, but for actual compile-time code generation there's Liskell which is more proof-of-concept than useful, and there's template haskell which is real and used, but hard to
18:18:02 <shapr> harblcat: How does that compare to Lisp macros from your viewpoint?
18:18:10 <glguy> Lisp’s macros have an easier time of manipulating code due to  the regular syntax of Lisp
18:19:39 <harblcat> Well, I was thinking that a *lot* of interesting things can be accomplished via composition
18:20:37 <dons> the smaller syntax, at least
18:20:42 <SubStack> binaries with template haskell in them get very big too
18:20:47 <dons> the Haskell AST is just a lot bigger. (and there are types too)
18:21:06 <dons> SubStack: oh, as template-haskell is linked dynamically, although it likely isn't needed
18:21:10 <dons> yes, that's a good point.
18:24:11 <Axman6> is it possible to see the AST of a program? like a ghc flag to output it?
18:26:03 <dons> yeah. -ddump-parsed
18:26:04 <dons> iirc
18:26:14 <Axman6> ah, thanks
18:27:13 <Axman6> hmm, seems to just output the program once it's been parsed
18:27:22 <Axman6> ==================== Parser ====================
18:27:22 <Axman6> module Main where
18:27:22 <Axman6> import qualified Data.List.Stream as  L
18:27:24 <Axman6> ...
18:27:42 <pumpkin-> pretty-printed AST == what you typed in with better formatting? :P
18:31:05 <Axman6> -ddump-occur-anal <- another terrible name...
18:31:14 <pumpkin-> lol
18:32:40 <thomashartman1> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2222#a2222
18:32:42 <thomashartman1> any idea?
18:37:15 <gwern> @quote anal
18:37:15 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
18:37:30 <gwern> @remember Axman6 -ddump-occur-anal <- another terrible name...
18:37:30 <lambdabot> Done.
18:37:32 <gwern> @quote anal
18:37:32 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
18:37:47 <Axman6> :)
18:37:56 <Axman6> @quote Axman6
18:37:56 <lambdabot> Axman6 says: -ddump-occur-anal <- another terrible name...
18:37:58 <Axman6> @quote Axman6
18:37:58 <lambdabot> Axman6 says: inface, ST is just plain awesome
18:38:06 <Axman6> @quote Axman6
18:38:06 <lambdabot> Axman6 says: inface, ST is just plain awesome
18:38:19 <Axman6> whoot, my crappy one got forgotten
18:38:27 <pumpkin-> @quote anal
18:38:28 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
18:38:31 <gwern> Axman6: one good quote, one bad quote, what are you going to do
18:38:51 <gwern> @quote gwern
18:38:51 <lambdabot> gwern says: [regarding the naming of Monoids] we will call them CuteFluffableThings, since you can put more fluff into them, but no one would remove fluff from a cute thing
18:39:57 <drhodes> is there a way to force a double to display in the N.NNNeN format?
18:40:00 <Gracenotes> o nos
18:40:12 <Axman6> tried printf?
18:40:12 <chessguy_work> > 7 ** 3
18:40:13 <Gracenotes> :o
18:40:14 <lambdabot>   343.0
18:40:25 <dolio> One of the showNFloat functions.
18:40:25 <Gracenotes> > 100^^100
18:40:27 <lambdabot>   1.0000000000000005e200
18:40:32 <dolio> > showFFloat 1
18:40:33 <lambdabot>       Overlapping instances for Show (a -> String -> String)
18:40:33 <lambdabot>        arising f...
18:40:40 <chessguy_work> > 12**3
18:40:41 <lambdabot>   1728.0
18:40:43 <dolio> > showFFloat 1 ""
18:40:44 <lambdabot>       Overlapping instances for Show (String -> String)
18:40:44 <lambdabot>        arising from a...
18:40:52 <chessguy_work> > 1728 / 365
18:40:52 <dolio> > showFFloat (Just 10) 1 ""
18:40:54 <lambdabot>   4.734246575342466
18:40:54 <lambdabot>   "1.0000000000"
18:41:07 <Gracenotes> @type showFFloat
18:41:08 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
18:41:10 <drhodes> :t printf
18:41:12 <lambdabot> forall r. (PrintfType r) => String -> r
18:41:20 <dolio> > showEFloat (Just 10) 1 ""
18:41:22 <lambdabot>   "1.0000000000e0"
18:41:30 <dolio> That one.
18:41:36 <drhodes> oohhhh, :))) Thanks !
18:41:40 <Axman6> : showFFLoat Nothing (10^1000) ""
18:41:46 <Axman6> > showFFLoat Nothing (10^1000) ""
18:41:47 <lambdabot>   Not in scope: `showFFLoat'
18:41:51 <Gracenotes> > showFFloat Nothing (5892^^43) " :O "
18:41:52 <lambdabot>   "13222017917086917000000000000000000000000000000000000000000000000000000000...
18:41:54 <Axman6> > showFFloat Nothing (10^1000) ""
18:41:55 <lambdabot>   "Infinity"
18:42:01 <Axman6> hoorah
18:42:23 <Gracenotes> > showFFloat (Just 40) (589^^2) "WHAT IS THIS I DON"T EVEN"
18:42:24 <lambdabot>   <no location info>:
18:42:24 <lambdabot>      lexical error in string/character literal at chara...
18:42:34 <Gracenotes> :O
18:42:42 <Gracenotes> > showFFloat (Just 40) (589^^2) ":("
18:42:43 <lambdabot>   "346921.0000000000000000000000000000000000000000:("
18:48:12 <ImOuttaYourMonad> what is the difference between linear and nonlinear systems? exact vs inexact solutions?
18:48:39 <pumpkin-> you mean a linear system of equations?
18:48:55 <wli> Wow.
18:49:22 <joed> I have a ford.
18:49:28 <Axman6> dons: whoot: http://shootout.alioth.debian.org/u64/benchmark.php?test=threadring&lang=all&box=1
18:49:49 <pumpkin-> oh nice, the illegal java is only 0.9 now
18:50:05 <mattam> 55
18:50:15 <dolio> Did they not let you compile without -threaded?
18:50:15 <pumpkin-> Axman6: you convinced them to leave out -threaded ?
18:50:18 <gwern> I can't help but be amused by the 29 minutes for ruby
18:50:24 <Axman6> apparently
18:50:32 <pumpkin-> sweet :)
18:50:38 <Axman6> but not in the multi core machine
18:50:42 <gwern> what's the java one doing that gets it 20s faster?
18:50:45 <pumpkin-> why not?
18:50:51 <Axman6> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all
18:51:20 <pumpkin-> that erlang entry is disturbingly high
18:51:32 <dolio> Why does it have CPU usage on all cores if it's not -threaded? :)
18:51:36 <Axman6> doesn' surprise me too much
18:51:56 <BMeph> I love how almost none of those programs use more than one core.
18:52:23 <dolio> BMeph: That's the one-core test suite.
18:52:25 <Axman6> it's not really a benchmark that works across multiple cores :\
18:52:53 <drhodes> is there a multicore shoot out?
18:53:00 <Axman6> yes
18:54:24 <dolio> Of course, thread ring doesn't get much multicore usage in the case where it's allowed, either.
18:54:28 <TomMD> drhodes: Yes, but... its the same benchmarks ran on a quad core.
18:54:36 <dolio> Aside from the scala entry, which somehow uses 90% of every core.
18:54:46 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
18:54:52 <dons> multicore shootout, drhodes
18:54:59 <TomMD> drhodes: So threadring, for example, is still shown even though its a problem that no one will be running in parallel.
18:55:04 <BMeph> The Java one is 0.6 in the multi-core version. :\
18:55:12 <pumpkin-> that's illegal though
18:55:17 <pumpkin-> they have fake cooperative threads :)
18:55:34 <Axman6> BMeph: it wouldnt be if the ghc one was compiled without -threaded
18:55:37 <dons> yeah, you can't do it in user land
18:55:38 <drhodes> ahh, thanks dons
18:56:18 <Axman6> notice the compilation line here http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=ghc&id=3
18:56:26 <dolio> Axman6: The threadring on the 4-core shootout uses 0% of the other cores, but the one on the 1-core shootout uses 1 - 3% of the other cores. :)
18:56:39 <Axman6> heh, yeah :)
18:57:35 <pumpkin-> probably means something else was happening on the machine at the same time?
18:57:40 <pumpkin-> the elapsed time == cpu time
19:00:11 * pumpkin- shrugs
19:12:08 <wli> Okay, between THIH and MPJ's Extensible Records and Variants paper I think I'm set. Heck, there's even rafts of example code as the papers are just literate Haskell programs.
19:14:20 <wli> What do people do, just write some piece of code they think is interesting as literate Haskell and publish the output of lhs2TeX ; pdflatex?
19:15:57 <chessguy> whatever floats your raft...
19:22:15 <toliko_smoren> hey I am trying to use simple network functions, but I am confused, I thought that port was just a number but PortId requires:Service String and UnixSocket String, what are these two?	
19:24:58 <ImOuttaYourMonad> if i have a Map of Maps, how do I update the inner one? given a customerid -> update the inner map with a new Map of mid -> grade
19:25:30 <pumpkin-> update . update ? :P
19:25:51 <pumpkin-> not quite that simple, but almost
19:26:43 <pumpkin-> ImOuttaYourMonad: what's the type of the function you'd like to write to update the internal Map?
19:27:40 <MyCatVerbs> :t \f k1 k2 mm -> update (\m -> Just $ update f k2 m) k1 mm
19:27:41 <lambdabot> Not in scope: `update'
19:27:41 <lambdabot> Not in scope: `update'
19:27:57 <ImOuttaYourMonad> updateWith singletong i guess
19:28:00 <MyCatVerbs> :t \f k1 k2 mm -> Data.Map.update (\m -> Just $ Data.Map.update f k2 m) k1 mm
19:28:01 <lambdabot> forall a k k1. (Ord k1, Ord k) => (a -> Maybe a) -> k1 -> k -> M.Map k1 (M.Map k a) -> M.Map k1 (M.Map k a)
19:28:02 <ImOuttaYourMonad> singleton
19:28:43 <toliko_smoren> can anyone explain to me the port thingies?
19:29:09 <ImOuttaYourMonad> does haskell have something like : path = path_to/mv_%07d ; path % 1 -> ~/mv_0000001,
19:29:24 <ImOuttaYourMonad> path % 12 -> ~/mv_0000012
19:29:27 <pumpkin-> printf?
19:29:39 <ImOuttaYourMonad> but not print
19:29:41 <wy> :t 1
19:29:42 <lambdabot> forall t. (Num t) => t
19:29:49 <pumpkin-> > printf "path_to/mv_%07d" 1 :: String
19:29:51 <lambdabot>   "path_to/mv_0000001"
19:29:53 <MyCatVerbs> toliko_smoren: port thingies? Where, please?
19:30:09 <wy> :t ((\f -> if (f True) then (f 1) else (f 2)) (\v -> v))
19:30:10 <lambdabot>     No instance for (Num Bool)
19:30:10 <lambdabot>       arising from the literal `1' at <interactive>:1:28
19:30:10 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
19:30:40 <Axman6> toliko_smoren: port thingies? o.O
19:30:44 <wy> okay :) Here is my question. What is the real reason that this program can't be typed?
19:31:01 * wli advises the channel that format strings are evil, if from no other standpoint than performance.
19:31:07 <pumpkin-> wy: because f needs to accept True and 1 and 2
19:31:21 <pumpkin-> wy: it could potentially be, if you defined a Num Bool, but it doesn't make much sense
19:31:30 <wy> pumpkin-: But \v->v should be able to accept any type
19:31:44 <Axman6> monomorphism restriction?
19:32:08 <wy> Axman6: I guess so, but I don't really understand why the restriction
19:32:18 <pumpkin-> I don't think so
19:32:31 <wy> :t \v -> v
19:32:32 <lambdabot> forall t. t -> t
19:33:55 <ImOuttaYourMonad> users is ad ict; users[int(parts[0])].update({movieid: int(parts[1])})
19:34:05 <ImOuttaYourMonad> thats the equivalent python code of what iw ant
19:34:15 <pumpkin-> wy: I think the issue is that the first lambda's argument has a specific type
19:35:13 <ddarius> Lambda bound variables are monomorphic.
19:35:19 <wy> :t let f = \v -> v in if (f True) then (f 1) else (f 2)
19:35:20 <lambdabot> forall t. (Num t) => t
19:35:37 <wy> ddarius: I just don't understand why let can work and normal lambda's can't
19:36:11 <wy> Are there some other type systems where this works?
19:36:12 <ddarius> Because let is where polymorphism is introduced in HM-based systems.
19:36:39 <ddarius> wy: You can give an explicit (rank-2) type that will make that work.
19:37:00 <wy> ddarius: rank-2 type?
19:37:04 <ddarius> wy: Things become a lot clearer if you make type instantiation and abstraction explicit.
19:37:06 <chessguy> what is a rank-2 type?
19:37:13 <pumpkin-> throw the forall into it?
19:37:22 <Gracenotes> :t let f = \v -> v; u = if (f 3 == 3) then (f 1) else (f 2) in f
19:37:23 <lambdabot> forall t. t -> t
19:37:26 <ddarius> A type with a nested occurrence of forall that can't be lifted out.
19:37:50 <ddarius> E.g. forall b. (forall a. a -> a) -> (b -> b)
19:38:27 <wy> I see
19:39:34 <ddarius> wy: Writing /\ for a type lambda, i.e. id :: forall a. a -> a; id = /\a.\x :: a -> x and then you'd use it, using f[type] for instantiation, as id[Bool] True.
19:40:09 <ddarius> Then the let version is: let f = /\t.\v:t -> v in if f[Bool] True then f[Int] 1 else f[Int] 2
19:41:18 <wy> ddarius: Is this Haskell syntax?
19:41:53 <ddarius> Whereas in the lambda version the inner expression is: (\f -> if f True then f 1 else f 2) which has no type applications and thus f must be monomorphic.
19:42:00 <ddarius> wy: No.
19:42:00 <MyCatVerbs> wy: no. It's roughly the same Haskell-like pseudocode syntax that you'll see in some academic papers.
19:42:32 <dolio> The lambda version is: "/\t. \f:(t -> t). if f True then f 1 else f 2" which is more obviously a type error.
19:43:20 <wy> Is that "church style" types?
19:43:39 <dolio> And the rank-2 version is: \f:(forall t. t -> t). if f[Bool] True then f[Int] 1 else f[Int] 2
19:43:58 <ddarius> wy: It is Church-style, but it's not the "types" that are Church-style it's the syntax/expressions.
19:44:17 <ddarius> "Church-style" just means that types are part of the terms.
19:44:19 <pumpkin-> ooh koninkje_away likes Heisig's book too
19:45:47 <alexyk> when building zlib, it creates an archive .a on my mac which later causes an error, archive has no table of contents.  Where in ghc setup is the ar command saved?  I need to add s to it on mac: ar cr => ar rcs
19:49:17 <ImOuttaYourMonad> and where is printf?
19:49:38 <kiris> @hoogle printf
19:49:38 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:49:38 <lambdabot> module Text.Printf
19:49:38 <lambdabot> package printf-mauke
19:54:34 <ImOuttaYourMonad> Couldn't match expected type `M.Map Int (M.Map Int Int)'
19:54:34 <ImOuttaYourMonad>            against inferred type `IO (M.Map Int (M.Map Int Int))'
19:54:38 <ImOuttaYourMonad> sigh types in ym ass
19:54:46 <ImOuttaYourMonad> im doing that in a dp
19:54:47 <ImOuttaYourMonad> do
19:55:05 <Axman6> you need to paste some code if you want help
19:55:25 <pumpkin-> you using <- where you should be using let?
19:55:54 <pumpkin-> hi alexyk :)
19:56:38 <alexyk> hi pumpkin!  I'm looking at Haskell too...  but buy is ocaml faster! :)
19:56:49 <TomMD> pumpkin-: That pattern matching won't work. If 'you' is a constructor you'll need to capitalize the 'Y'.
19:56:55 <Zao> alexyk: Hello troll.
19:57:01 <Axman6> heh
19:57:04 <pumpkin-> alexyk: not always!
19:57:06 <Zao> :P
19:57:22 <alexyk> pumpkin: I mean in terms of compiling
19:57:37 <Axman6> pfft, just means the compiler's doi ng a better job ;)
19:57:41 <pumpkin-> ah maybe :) ghc can get pretty sluggish sometimes... but that's just because it's thinking so hard
19:57:48 <ddarius> An excellent exercise for checking your understanding of Curry v. Church style lambda calculi is the following: The eta reduction rule for pairs is the following, for any term M, (fst M, snd M) ~> M.  The subject reduction property is if M :: T and M ~> M' then M' :: T, i.e. reduction preserves types (and typeability).  The exercise is to show that subject reduction fails in a Curry-style lambda calculus with the eta rule (and holds in a Church-style lambda
19:57:48 <ddarius>  calculus).
19:58:43 * Axman6 brainpop
19:59:09 <alexyk> so -- where does Setup build take the ar command from?  I need to add s to ar on Mac OSX
19:59:28 <pumpkin-> alexyk: not sure, but the easiest way by far to build packages is cabal-install
19:59:42 <Axman6> alexyk: i've never had any problems on OS X like that
19:59:42 <pumpkin-> cabal instal zlib :)
19:59:54 <alexyk> sure, so I try to bootstrap cabal-install from Linking dist/build/cabal/cabal ...
19:59:54 <alexyk> ld: in /private/var/folders/mw/mwJSf7ErEa4w8nWyKyyqD++++TY/-Tmp-/zlib-0.5.0.0/dist/build/libHSzlib-0.5.0.0.a, archive has no table of contents
20:00:04 <pumpkin-> ah
20:00:08 <Gracenotes> ddarius: is that to do with bottom in any sense?
20:00:17 <ddarius> Gracenotes: No
20:00:36 <Axman6> pumpkin-: can you apend to the end of a MUArr?
20:00:43 <alexyk> this happens on my mac and I've seen it happens where for others it doesn't; still I have a stock ar, and ranlib or ar s fixes it
20:00:57 <pumpkin-> Axman6: you can write past the end of it ;) but no, you can't explicitly append without reallocating another one
20:01:08 <Axman6> hmm, lame
20:01:09 <alexyk> hence the question is, where does ghc build process invoke ar and where are the default options stored
20:01:23 <pumpkin-> Axman6: it's pretty low-level :P
20:01:30 <Axman6> yeah
20:01:52 <pumpkin-> alexyk: hmm
20:02:05 <pumpkin-> so bootstrap.sh didn't work out of the box on your mac? :(
20:02:45 <alexyk> well I got that script: http://ghcmutterings.wordpress.com/2008/11/10/bootstrapping-cabal-install/#comment-24
20:03:01 <alexyk> and it fails at that place with ar
20:03:12 <alexyk> so I need to understand where ghc invokes ar
20:04:53 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2223#a2223
20:05:06 <Axman6> alexyk: i don't think you do. like i said, i've never had any such problems with ghc/ar on OS X
20:05:08 <pumpkin-> alexyk: that's a very early version on that page, try http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
20:05:35 <pumpkin-> ImOuttaYourMonad: ok...
20:06:12 <alexyk> Axman6: in fact I do, I've noticed this discrepancy with a couple other Mac folks, but can't trace it.
20:06:33 <alexyk> I need to either run ranlib or do ar s
20:06:34 <Axman6> which GHC/Xcode do you have installed?
20:07:03 <alexyk> Axman: latest XCode 312 and ghc 6.10.1 from macports
20:07:18 <Axman6> intel?
20:07:21 <alexyk> yep
20:07:25 <Axman6> how odd
20:07:40 <pumpkin-> alexyk: are you actually using the shell script in that code box in the blog post?
20:07:54 <ImOuttaYourMonad> N >> 2^D. what does >> mean there?
20:07:55 <alexyk> pumpkin: yep... why not?
20:08:11 <Axman6> ImOuttaYourMonad: possible much greater than
20:08:13 <pumpkin-> the one in the tarball I linked to is a lot newer
20:08:14 <alexyk> or should I get a later cabal-install?
20:08:19 <pumpkin-> alexyk: I'd get the latest
20:08:22 <pumpkin-> the 0.6.2 one I linked to
20:08:23 <alexyk> pumpkin: okok
20:08:40 <pumpkin-> I've never actually tried the one in that blog post, but I know that 0.6 and 0.6.2 work fine on my mac
20:09:33 <pumpkin-> ImOuttaYourMonad: context? in general, >> is sequencing, it's like >>= \_ ->
20:09:49 <dolio> ddarius: Do you mean find an M :: T and M ~> M' such that T is not a valid type for M'? Or where M' admits a more general type?
20:09:50 <pumpkin-> but given that you're putting numbers on the sides of it, it may not be?
20:09:58 <pumpkin-> in the c sense, it's a right bit shift
20:10:31 <ImOuttaYourMonad> pumpkin: Axman6 answered in the right context
20:10:32 <ddarius> dolio: The former.
20:10:37 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2223#a2223 <-
20:10:42 <pumpkin-> ah :)
20:10:48 <ddarius> If M' has a more general type then M' :: T will still hold.
20:10:54 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2223#a2224
20:11:03 <dolio> Right.
20:11:29 <pumpkin-> ImOuttaYourMonad: what about that paste?
20:12:11 <ImOuttaYourMonad> the eror is pasted
20:12:15 <ImOuttaYourMonad> now
20:12:21 <pumpkin-> oh
20:12:22 <pumpkin-> ok
20:13:03 <pumpkin-> :t foldM
20:13:05 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:13:44 <Axman6> > foldM (const.return) 1 ['a'..]
20:13:45 <lambdabot>       No instance for (Show (m a))
20:13:45 <lambdabot>        arising from a use of `show' at <in...
20:13:53 <Axman6> > foldM (const.return) 1 ['a'..] :: Maybe Int
20:13:55 <lambdabot>   Just 1
20:13:57 <alexyk> hrm -- bootstrap.sh fails too in cabal-install 0.6.2
20:14:00 <pumpkin-> ImOuttaYourMonad: you might have other problems though...
20:14:02 <alexyk> same ar problem
20:14:05 <pumpkin-> ack
20:14:33 <alexyk> so unless there's an expert on where ghc stores ar command options here, I'll be disappointed with all of you tonight :)
20:15:11 <pumpkin-> onoes :(
20:15:20 <Axman6> there shouldn't be any need to know where it is
20:15:27 <Axman6> you've probably got some other problem
20:16:12 <alexyk> Axman6: well ok I want to know just in case, with your kind permission
20:16:30 <alexyk> since it's important to know how ghc decides to link things
20:16:38 <alexyk> e.g. for security purposes
20:16:44 <Gracenotes> hm. how are Integers represented internally in GHC (to the extent that question isn't vague)?
20:16:54 <pumpkin-> Int = I# Int#
20:17:01 <Axman6> i wouldn't have a clue where it'd be. my suggestion is to download the packages needed for cabal-install and install them by hand
20:17:03 <Gracenotes> Integer
20:17:04 <Axman6> @src Integer
20:17:04 <lambdabot> data Integer = S# Int#
20:17:04 <lambdabot>              | J# Int# ByteArray#
20:17:05 <pumpkin-> oh
20:17:15 <pumpkin-> :)
20:17:31 <Gracenotes> ah. What's the first Int# for in J#?
20:17:47 <Axman6> for ints less than maxBound :: Int
20:17:52 <Axman6> more efficient
20:17:58 <pumpkin-> in the J# bit
20:18:16 <Axman6> oh, must be the length of the array
20:18:33 <Gracenotes> mm.
20:19:10 <Axman6> 179424691 <- the 10000000th prime!
20:19:16 <Axman6> i think...
20:19:20 <mle> what do you need to import to use I# and so forth?
20:19:21 <Axman6> > logBase 10 179424691
20:19:22 <lambdabot>   8.253882206975634
20:19:26 <Axman6> hmmm
20:19:29 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2225#a2225 <- so what now?
20:19:48 <Axman6> mle: GHC.Prim and set -XMagicHash
20:20:01 <Gracenotes> >            pong.movpad[0] = min(pong.movpad[0] + INCREMENT, HEIGHT - PAD_HEIGHT);
20:20:02 <lambdabot>   <no location info>: parse error on input `='
20:20:04 <mle> Heh, magichash...
20:20:06 <Gracenotes> oops, wrong copy/paste
20:20:16 <Gracenotes> > logBase 10 10000000
20:20:18 <lambdabot>   7.0
20:20:29 <Axman6> ah yes, right
20:20:31 <Gracenotes> 10 millions
20:20:33 <Gracenotes> t
20:20:34 <Gracenotes> h
20:20:40 <pumpkin-> might be the sign?
20:21:01 <pumpkin-> probably not though
20:22:30 <Gracenotes> ImOuttaYourMonad: parseFiles probably doesn't have the type you want it to
20:22:46 <pumpkin-> ImOuttaYourMonad: it really would help you to write down type signatures for functions, I think
20:22:58 <pumpkin-> oh wait, you have them :)
20:23:02 <pumpkin-> I could've sworn they weren't there before
20:23:14 <Gracenotes> pumpkin-: copied from GHC, I think
20:23:16 <Gracenotes> *ghci
20:23:36 <pumpkin-> parseFiles :: (Monad m, P.PrintfArg b, Enum b) =>
20:23:36 <pumpkin->               b -> b -> m (IO (M.Map Int (M.Map Int Int)))
20:23:38 <Gracenotes> don't use what ghci tells you -- write the type you want it to have first, then try to go about implementing that :)
20:23:47 <pumpkin-> ImOuttaYourMonad: that's probably bad ;)
20:23:59 <Gracenotes> (in this specific case, that is -- sometimes ghci can be helpful)
20:24:13 <Gracenotes> @type foldM
20:24:14 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
20:24:32 <Gracenotes> because foldM returns something that's of type (m a), you don't need to tack on the 'return $'
20:24:58 <pumpkin-> ImOuttaYourMonad: if it were sufficient to copy the types from ghci, then you wouldn't have to write them in at all... the issue is that sometimes you get the type slightly wrong, but in a way that is consistent
20:25:11 <Gracenotes> in this case, foldM returns an IO (Map Int (Map Int Int))
20:25:13 <ImOuttaYourMonad> well its foldM s fault
20:25:24 <Axman6> quick quiz! who can tell me what 0|100 0101 0|011 1011 1101 0000 0000 0000 is in IEEE-754!
20:25:35 <Axman6> (yes this is homework, and yes i already know the answer)
20:25:36 <Gracenotes> ImOuttaYourMonad: you shouldn't have added the return ;)
20:25:49 <Gracenotes> Axman6: what's with the bar lines?
20:25:52 <pumpkin-> ImOuttaYourMonad: my point is that if you'd written out the types (and reasoned about them) beforehand, GHC would've caught that extraneous return for you
20:26:07 <Axman6> Gracenotes: splitting it into sign bit, exponent and mantissa
20:27:47 <Gracenotes> ImOuttaYourMonad: also, the "Map.union" function might prove useful
20:28:55 <Gracenotes> ImOuttaYourMonad: unless, that is, you're dealing with an effing huge dataset >X>
20:29:09 <pumpkin-> which he is
20:29:16 <Gracenotes> yes
20:29:46 <Gracenotes> @hoogle insert
20:29:46 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
20:29:46 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
20:29:46 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
20:29:56 <Gracenotes> @type Map.insert
20:29:57 <lambdabot> Couldn't find qualified module.
20:30:02 <Gracenotes> @type Data.Map.insert
20:30:03 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
20:30:30 <ImOuttaYourMonad> ok so Map.insert replaces my old value, i want insertWith i guess?
20:30:37 <pumpkin-> probably
20:31:00 <ImOuttaYourMonad> i am dealing with an effing, effing big dataset
20:31:03 <ImOuttaYourMonad> 2GB
20:31:10 <ImOuttaYourMonad> but not for now
20:31:34 <pumpkin-> ImOuttaYourMonad: if you want to get up to something that size you need to think about it in advance :) especially if you don't have several gigs of ram
20:31:47 <Gracenotes> @type Data.Map.insertWith
20:31:48 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
20:32:10 <ddarius> If it can fit in RAM it's not -that- big.
20:32:25 <pumpkin-> yup
20:32:42 <pumpkin-> but it's close enough to not fitting in that not being efficient won't work
20:33:05 <ImOuttaYourMonad> yeah im ust playng with it so far
20:33:07 <mmorrow> ImOuttaYourMonad: if it really is, you probably want to use a database
20:33:19 <ImOuttaYourMonad> databases are waaaay to slow
20:33:27 <pumpkin-> mmorrow: I put my ARM crap on github :P
20:33:27 <mmorrow> haha
20:33:35 <ImOuttaYourMonad> at least the standard ones, postgresql
20:33:40 <mmorrow> pumpkin-: cool
20:33:44 <pumpkin-> mmorrow: but it hasn't developed much since I last talked about it
20:34:06 <mmorrow> pumpkin-: link?
20:34:17 <mmorrow> ImOuttaYourMonad: what are you trying to do?
20:34:28 <Axman6> @quote EdLin
20:34:29 <lambdabot> EdLin says: there's ##windows, but it's more of a support group than a support channel.
20:34:46 <ImOuttaYourMonad> update a Map of Maps
20:34:52 <pumpkin-> http://github.com/pumpkin/charm/tree/master (the .cabal file is just for show, it'll probably take some massaging to even get it to compile for now... haven't had much time :P)
20:35:03 <mmorrow> ImOuttaYourMonad: sqlite has an option for the db to be in :memory:
20:35:33 <mmorrow> pumpkin-: awesome, /me clones
20:35:56 <Gracenotes> ImOuttaYourMonad: how many elements in the map will you be dealing with?
20:36:03 <pumpkin-> mmorrow: make it awesomer please :P you have a github account btw?
20:36:25 <mmorrow> pumpkin-: i don't
20:36:29 <pumpkin-> oh no!
20:36:46 <pumpkin-> you are so last year
20:36:48 <pumpkin-> ;)
20:36:49 <mmorrow> pumpkin-: i should get one though, since it seems like the cool thing to do ;)
20:36:52 <mmorrow> heh
20:37:05 <pumpkin-> that was meant to be read with a valley-girlish accent btw
20:37:16 <mmorrow> mine to :)
20:37:26 <Gracenotes> it might be quicker to use a hash table with Ptrs, rather than a Data.Map
20:37:29 <mmorrow> (i just decided after the fact)
20:37:30 <ImOuttaYourMonad> eventually i will find another scheme, this is just temporary.
20:37:33 <pumpkin-> :D
20:37:37 <Gracenotes> :O
20:37:41 <mmorrow> :9
20:37:42 <ImOuttaYourMonad> pointers i haskell!?
20:37:45 <Gracenotes> :8
20:37:48 <pumpkin-> ImOuttaYourMonad: of course
20:37:54 <pumpkin-> u haz da powa if u wantz it
20:37:59 <mmorrow> , peek nullPtr
20:38:02 <lunabot>  luna: Not in scope: `peek'
20:38:07 <pumpkin-> aw
20:38:31 <Gracenotes> o nos
20:38:34 <ImOuttaYourMonad> mmorrow: but isnt it to slow anyway? can sqlite really handle that manyr equests? most people seem to use binary files in c++
20:38:42 <pumpkin-> u haz lolcat on ur keyborde?
20:39:12 <ImOuttaYourMonad> cAn Haz updATeMap soluTion k thnx?
20:39:18 <pumpkin-> ImOuttaYourMonad: you probably want to try learning one thing at a time though? not doing huge data processing + machine learning + haskell learning all at once?
20:39:25 <mmorrow> ImOuttaYourMonad: sqlite is written in C, so how is it different from a binary file + C++?
20:39:37 <Gracenotes> pumpkin-: http://upload.wikimedia.org/wikipedia/commons/0/08/Chat_wikipedien.jpg
20:39:44 <pumpkin-> lol
20:40:07 <pumpkin-> il y a un chat dans mon chat
20:40:11 <BMeph> lolcat iz in ur System, type-checking ur terms
20:40:20 <pumpkin-> that's almost begging for a YO DAWG
20:40:26 <mmorrow> ImOuttaYourMonad: but i still don't know what you're trying to do, so i don't know what you'd want to use
20:40:39 <pumpkin-> he's doing the netflix challenge!
20:40:45 <mmorrow> "updating a Map of Maps" is kinda vague :)
20:41:19 <mmorrow> pumpkin-: oh
20:41:30 * mmorrow reads what that is exactly
20:41:39 <Gracenotes> u leik
20:41:57 <pumpkin-> netflix gives you a bunch of user ratings of movies, and you're supposed to do 10% better than them at predicting future ratings
20:42:16 <dolio> ddarius: (\p. (fst p, snd p)) : (forall c. c)*(forall d. d) -> forall a b. a*b?
20:42:33 <mmorrow> pumpkin-: what do they give you if you do?
20:42:34 <pumpkin-> mmorrow: there are a fair number of haskellers on github already, btw, so you won't feel too lonely if you sign up
20:42:35 <ImOuttaYourMonad> im at 9.99
20:42:37 <pumpkin-> mmorrow: a million dollars
20:42:44 <mmorrow> pumpkin-: whoa
20:42:51 <Gracenotes> 10% is quite hard to reach though
20:42:55 <pumpkin-> yeah
20:43:03 <Gracenotes> excruciatingly, if the accounts are to be believed
20:43:03 <ddarius> dolio: It has nothing to do with (actual) polymorphism
20:43:03 <pumpkin-> people are getting pretty close
20:43:21 <pumpkin-> http://www.netflixprize.com/leaderboard
20:43:24 <pumpkin-> it's been going for a while now
20:43:27 <ImOuttaYourMonad> mmorrow: but it is 2 years on or soemthing and the leading team bellkor have 9,44 and they have been working on it since the beginning. they work on it daily, a team of professional dataminers
20:43:29 <Gracenotes> every so often there are people in the news who reach 8% or something, and happen to be professors or kids or local or alien or something
20:43:32 <dolio> Hmm...
20:43:42 <pumpkin-> they're up to 9.63 improvement
20:44:32 <ImOuttaYourMonad> funny thought since bellkor publish all their stuff if someone else would improve on their methods and slip over 10% just ahead of them
20:44:49 <p_l> ImOuttaYourMonad: That's the rule of this contest
20:44:56 <pumpkin-> just goes to show how hard it is :P
20:45:05 <Gracenotes> http://pragmatictheory.googlepages.com/progressgraph
20:45:16 <pumpkin-> we don't even know if there's enough information in the input dataset to get that kind of improvement
20:45:18 <ddarius> dolio: Use the STLC.
20:45:24 <pumpkin-> I'd expect there is though :)
20:45:41 <ImOuttaYourMonad> yeah it seems they might be overfitting from now on
20:45:52 * mmorrow always thinks "salt lake city" at first glance when people write "STLC"
20:45:57 <pumpkin-> I'm not sure I'd call it overfitting
20:46:09 <Gracenotes> time to sign up for 1000 netflix accounts and skew the results in favor of your algorithm.... right? right?
20:46:14 <pumpkin-> lol
20:46:20 <pumpkin-> I think the dataset is static
20:46:32 <Gracenotes> (1000 is also too small, I think)
20:46:40 <MyCatVerbs> I bet someone will eventually get it through lucky overfitting.
20:47:06 <Gracenotes> do you want to have... a... tasty.... mushroom??
20:47:16 <pumpkin-> infected?
20:47:35 <Gracenotes> they are weird voice samples sometimes
20:47:41 <Gracenotes> *have
20:47:48 <mmorrow> pumpkin-: ooh, charm looks nice
20:47:52 <MyCatVerbs> Salad fingers?
20:48:21 <BMeph> ad fingertrees? ;p
20:48:24 <ImOuttaYourMonad> let a = M.fromList [(1,M.fromList [(2,3)])] ; update a 1 (3,4) -> M.fromList [(1,M.fromList [(2,3),(3,4)]
20:48:26 <pumpkin-> mmorrow: thanks :) there's not much there yet, and even the instruction representation I'm not too happy about, but it's better than sitting around trying to decide for months and not producing anything (which is my usual pattern)
20:48:28 <BMeph> *Salad
20:48:32 <pumpkin-> salad fingers is awesome
20:48:57 * Gracenotes pattern matches pumpkin
20:48:58 <mmorrow> pumpkin-: heh, definitely. existence is half the battle.
20:49:15 <ImOuttaYourMonad> pumpin: well they are not predicing movies in general perhaps, i mean, just this set
20:49:44 <ddarius> dolio: You are looking for some term containing an example of an eta reducible subterm such that that term is typeable before eta reduction is applied but not typeable after.
20:49:47 <pumpkin-> yeah, but it's supposed to be a random subset isn't it?
20:50:40 <pumpkin-> mmorrow: that symbolic.hs doesn't belong, I found that it's on hackage after all, and I probably shouldn't be putting it into this module anyway
20:51:01 <Axman6> http://www.google.com/search?q=the+answer+to+life%2C+the+universe+and+everything
20:51:37 <ImOuttaYourMonad> let a = M.fromList [(1,M.fromList [(2,3)])] ; update a 1 (3,4) -> M.fromList [(1,M.fromList [(2,3),(3,4)] ; so is that updateWith?
20:57:00 <ImOuttaYourMonad> come on!
20:57:16 <ImOuttaYourMonad> this is like 1+1 in python
20:58:00 <pumpkin-> experiment!
20:58:07 <sjanssen> @docs Data.Map
20:58:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
20:58:13 <sjanssen> there is the fine manual
20:58:25 <pumpkin-> ImOuttaYourMonad: ghci is your friend, you can test things and see what works
20:58:43 <sjanssen> sorry, broken link.  Here is the real manual: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
20:59:18 <ImOuttaYourMonad> insertWith
20:59:22 <ImOuttaYourMonad>  use ghci
21:02:07 <ImOuttaYourMonad> seriosuly
21:02:10 <pumpkin-> ?
21:02:20 <Axman6> what's your rpoblem ImOuttaYourMonad?
21:03:18 <roconnor> aw man,  NULs are allowed in email addresses
21:03:19 <Gracenotes> unsafePerformThought
21:03:31 <pumpkin-> Gracenotes: heaven forbid!
21:03:49 <sjanssen> roconnor: really?  I wonder how many clients handle that in practice
21:03:49 <ddarius> dolio: I've recreated a problematic term if you decide to give up.
21:04:06 <Axman6> axman\NUL@gmail\NUL.com
21:04:21 <Axman6> \NULman@\NUL.com
21:07:07 <Axman6> lame, llvm.org is down :(
21:09:58 <pumpkin-> ImOuttaYourMonad: did you figure it out?
21:11:04 <ImOuttaYourMonad> no
21:11:12 <ImOuttaYourMonad> > insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")])
21:11:13 <lambdabot>   Not in scope: `insertWith'Not in scope: `fromList'
21:11:24 <ImOuttaYourMonad> > Data.Map.insertWith (++) 7 "xxx" (Data.Map.fromList [(5,"a"), (3,"b")])
21:11:25 <lambdabot>   /tmp/3420384580617703157:70:44: Not in scope: `Data.Map.insertWith'/tmp/342...
21:11:29 <pumpkin-> > Map.fromList [(1,2), (2,3)]
21:11:31 <lambdabot>   fromList [(1,2),(2,3)]
21:11:32 <ImOuttaYourMonad> bah
21:11:34 <ImOuttaYourMonad> yes
21:11:51 <ImOuttaYourMonad> fromList [(1,fromList [(2,3)])]
21:12:40 <Gracenotes> @src Map show
21:12:40 <lambdabot> Source not found. :(
21:12:43 <Gracenotes> :(
21:12:58 <Gracenotes> src teim
21:13:21 <ImOuttaYourMonad> fromList [(1,fromList [(2,3)])] ; i want to update the innrer ,ap if 1 else insert a new customer?
21:13:27 <ImOuttaYourMonad> isnt it obvious what im doing?
21:13:33 <pumpkin-> not at all
21:13:46 <Gracenotes> hm. It always says 'fromList'
21:14:00 <pumpkin-> Gracenotes: yeah, it's like uvector saying toU [..]
21:14:18 <Gracenotes> > Map.singleton "how did i get here" "i am not good with computer"
21:14:19 <lambdabot>   fromList [("how did i get here","i am not good with computer")]
21:14:59 <ImOuttaYourMonad> >>> import collections as C
21:14:59 <ImOuttaYourMonad> >>> users = C.defaultdict(dict)
21:14:59 <ImOuttaYourMonad> >>> users[5].update({34: 4})
21:14:59 <ImOuttaYourMonad> >>> users
21:14:59 <ImOuttaYourMonad> defaultdict(<type 'dict'>, {5: {34: 4}})
21:15:03 <pumpkin-> heh
21:15:50 <pumpkin-> that's a plain insert
21:15:51 <pumpkin-> we get that bit
21:16:20 <ImOuttaYourMonad> then...
21:16:27 <Gracenotes> > let users = Map.empty in Map.insert 5 (Map.singleton 34 4) users
21:16:28 <lambdabot>   fromList [(5,fromList [(34,4)])]
21:16:31 <mmorrow> @let collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
21:16:34 <lambdabot>  Defined.
21:16:42 <ImOuttaYourMonad> >>> users[5].update({12: 3})
21:16:42 <ImOuttaYourMonad> >>> users
21:16:42 <ImOuttaYourMonad> defaultdict(<type 'dict'>, {5: {34: 4, 12: 3}})
21:16:48 <Gracenotes> the difference between Python and Haskell is that Python has built-in syntax
21:16:58 <Gracenotes> and Python's are mutable
21:17:01 <mmorrow> @type collect M.union fst (M.singleton . snd)
21:17:03 <lambdabot>     Ambiguous occurrence `collect'
21:17:03 <lambdabot>     It could refer to either `L.collect', defined at <local>:32:0
21:17:03 <lambdabot>                           or `Test.QuickCheck.collect', imported from Test.QuickCheck
21:17:04 <pumpkin-> ImOuttaYourMonad: insertWith insert or something then
21:17:07 <mmorrow> gah
21:17:10 <pumpkin-> or insertWith union, yeah
21:17:14 <mmorrow> @let wrangle (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
21:17:15 <ImOuttaYourMonad> i tried that already
21:17:17 <lambdabot>  Defined.
21:17:24 <mmorrow> @type wrangle M.union fst (M.singleton . snd)
21:17:26 <lambdabot>     Couldn't match expected type `M.Map k a'
21:17:26 <lambdabot>            against inferred type `a1 -> M.Map b a1'
21:17:26 <lambdabot>     Probable cause: `.' is applied to too few arguments
21:17:26 <pumpkin-> ImOuttaYourMonad: you didn't tell us how it failed, you were probably just doing it wrong
21:17:49 <ImOuttaYourMonad> ah union works
21:18:06 <ImOuttaYourMonad> *Parsing> M.insertWith M.union 1 (M.fromList [(3,4)]) $ M.fromList [(1,M.fromList [(2,3)])]
21:18:06 <ImOuttaYourMonad> fromList [(1,fromList [(2,3),(3,4)])]
21:19:34 <mmorrow> use inserWith'
21:19:38 <mmorrow> use insertWith'
21:19:50 <mmorrow> @type wrangle M.union fst
21:19:51 <lambdabot> forall k a a1 b. (Ord a1, Ord k) => ((a1, b) -> M.Map k a) -> [(a1, b)] -> M.Map a1 (M.Map k a)
21:19:54 <pumpkin-> mmm wrangle
21:19:56 <pumpkin-> good word
21:20:05 <mmorrow> collect seem sto be taken..
21:20:06 <sjanssen> @type wrangle
21:20:07 <lambdabot> forall a b k. (Ord k) => (a -> a -> a) -> (b -> k) -> (b -> a) -> [b] -> M.Map k a
21:20:18 <mmorrow> wrangle (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
21:20:50 <ImOuttaYourMonad> wiiiii!
21:21:10 <mmorrow> > wrangle (+) id (const 1) . take 10000 . randomRs ('a','e') $ mkStdGen 28786
21:21:12 <lambdabot>   fromList [('a',2012),('b',1999),('c',1944),('d',2029),('e',2016)]
21:21:16 <pumpkin-> I know one of the guys who hacks the wii
21:21:29 <mmorrow> > wrangle (++) id (:[]) . take 10000 . randomRs ('a','e') $ mkStdGen 28786
21:21:31 <lambdabot>   fromList [('a',"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:21:47 <mmorrow> > wrangle S.union id S.singleton . take 10000 . randomRs ('a','e') $ mkStdGen 28786
21:21:49 <lambdabot>   /tmp/274682690193463722:70:80: Not in scope: `S.union'/tmp/2746826901934637...
21:22:30 <BMeph> pumpkin-: Aye, laddie, he's been a wii hacker since he was a wee hacker... ;p
21:22:36 <mmorrow> i don't know why it was rejecting " wrangle M.union fst (M.singleton . snd)"
21:22:44 <mmorrow> because that's correct
21:22:45 <pumpkin-> BMeph: lol
21:22:50 <pumpkin-> his nick is bushing
21:23:09 <mmorrow> oh, no it's not!
21:23:27 <mmorrow> @type wrangle M.union fst (uncurry M.singleton . snd)
21:23:29 <lambdabot> forall a a1 b. (Ord a, Ord a1) => [(a, (a1, b))] -> M.Map a (M.Map a1 b)
21:23:32 <mmorrow> there :)
21:24:59 <shukhov> is there a non transformer type of ErrorT?
21:25:08 <ddarius> Either
21:27:04 <shukhov> thank you
21:35:03 <pastah> @pl \v -> return (v,"X")
21:35:03 <lambdabot> return . flip (,) "X"
21:35:24 <pumpkin-> don't do it!
21:35:38 <pastah> pumpkin-: why should i liston to you?
21:36:50 * pastah is trimming his c interpreter line count
21:39:05 <pastah> can i define datatypes to make lamdabot sensetive about stuff like that when using @pl?
21:39:09 <pumpkin-> pastah: was just being silly :) but in that case I don't think @pl really helped much
21:39:22 <pastah> pumpkin-: 2 lines
21:39:35 <pastah>  (VarAssDecl i e) = evalExpr e >>= return . flip (,) i
21:39:40 <pastah> is the new one
21:39:47 <dolio> ddarius: Well, I don't think the answer is going to occur to me.
21:39:49 <pastah> old was 3 lines in do notation
21:39:49 <pumpkin-> yeah, but it's not clear
21:39:56 <pastah> pumpkin-: so what?
21:40:02 * pumpkin- shrugs :)
21:40:13 <pumpkin-> btw
21:40:16 <pumpkin-> >>= return .
21:40:19 <pumpkin-> is just fmap/liftM
21:40:33 <pastah> i have already trimmed this from 200 to 160 lines
21:40:39 <pastah> have to get below 150
21:40:41 <pumpkin-> aha, so you're golfing :P
21:40:45 <pastah> hehe
21:40:47 <pastah> sorta
21:40:53 <pumpkin-> why not fmap then
21:41:00 <wli> I have doubts it's possible to parse C in that little code, never mind interpreting it.
21:41:00 <pumpkin-> a few more characters shaved off
21:41:24 <pastah> wli: no, this is just an interpreter for a small subset of C
21:41:35 <pastah> the typechecker and parser are done sparately
21:41:43 <wli> What subset?
21:41:43 <toliko_smoren> hey I have two computers and I want the random function started with the same hash to return the same results, how do I do that?
21:41:59 <pastah> (parsing with BNFC and typechecking in a ~150 lines haskell module)
21:42:22 <pastah> wli: the subset used for this lab assignment in this course
21:43:26 <wli> Could you describe that subset?
21:43:41 <pastah> wli: http://www.cse.chalmers.se/edu/course/TIN321/laborations/lab3/lab3.html
21:44:07 <ImOuttaYourMonad> isnt reddit just a ripoff of digg?
21:44:46 <wli> Okay, I see it.
21:45:27 <pumpkin-> ImOuttaYourMonad: they were started close enough together (2004/2005) to make it not so clear, and reddit has a very different attitude (community aside)
21:45:55 <pastah> @pl \e s -> eval e >>= \b -> when b eval s
21:45:55 <lambdabot> (. flip (flip when eval)) . (>>=) . eval
21:46:01 <pastah> oh, i like that!
21:46:05 <pumpkin-> lol
21:46:12 <pastah> was this:
21:46:14 <pastah>   StmWhile e s    -> do
21:46:14 <pumpkin-> just run your entire program through @pl
21:46:16 <pastah> (VB b) <- evalExpr e
21:46:18 <pastah> when b (eval s >> eval stm)
21:46:21 <pastah> where stm comes from "case stm of"
21:46:45 <pumpkin-> @. pl undo do myEntireProgram
21:46:46 <lambdabot> myEntireProgram
21:46:50 <pastah> (data Value = ... | VB Bool | ...)
21:47:30 <pumpkin-> where do bools come from in c?
21:47:42 <pastah> @pl \e s -> eval e >>= \b -> when b (eval s >> eval stm)
21:47:42 <lambdabot> (. (flip when . (>> eval stm) . eval)) . (>>=) . eval
21:47:58 <pumpkin-> @. unpl pl \e s -> eval e >>= \b -> when b (eval s >> eval stm)
21:47:59 <lambdabot> (\ h t -> (eval h) >>= \ c -> when c ((eval t) >> (eval stm)))
21:48:08 <pumpkin-> surprisingly faithful
21:50:39 <mmorrow> this is a job for whenM !
21:51:55 <Saizan> mwhen
21:51:56 <mmorrow> pastah: if you're trying to reduce line count, i think factoring out common patterns into functions is usually a better bet than @pl alone
21:52:19 <pastah> mmorrow: did that as much as it's possible already
21:52:26 <pumpkin-> pastah: if you expect someone to grade your assignment, I expect indiscriminate use of @pl output won't make them too happy
21:52:58 <pastah> pumpkin-: they won't look at my code, all they care about is if can pass the test suite
21:52:59 <mmorrow> whenM (eval e) (mapM_ eval [s,stm])
21:53:20 <pumpkin-> purty
21:53:26 <pastah> mmorrow: hmm.... that seems pwetty sweet
21:53:28 <mmorrow> @pl \e s -> whenM (eval e) (eval s >> eval stm)
21:53:29 <lambdabot> (. ((>> eval stm) . eval)) . whenM . eval
21:53:30 <pastah> i should write that
21:53:33 <pumpkin-> and is actualy legible too :)
21:53:42 <mmorrow> whenM is nice
21:53:47 <pastah> btw, does that actually exist?
21:53:50 <pastah> @type whenM
21:53:51 <mmorrow> no
21:53:52 <lambdabot> Not in scope: `whenM'
21:53:52 <pumpkin-> you have to define it yourself don't you?
21:53:52 <mmorrow> :(
21:53:57 <pastah> yeah
21:53:58 <pumpkin-> pretty simple though
21:54:02 <pastah> yeah
21:54:18 <pastah> i'm just gonna count how many when's i have, and then do it
21:54:45 <pastah> no! i need to do it for special Value types bools
21:54:52 <pastah> then i could shave some lines
21:54:56 <mmorrow> heh
21:55:05 <pastah> (data Value = ...| VB Bool | ...)
21:55:14 <pumpkin-> pastah: where are you getting Bools from in c code?
21:55:27 <pastah> pumpkin-: if statements and whatever :)
21:55:36 <pumpkin-> hmm
21:56:08 <mmorrow> numToBool = (==0)
21:56:28 <pumpkin->  /= 0?
21:56:31 <mmorrow> heh
21:56:36 <mmorrow> numToBool = (/=0)
21:56:38 <mmorrow> ;)
21:57:38 <pastah> whenMV mb f = mb >>= \(VB b) -> if b then f else return ()
21:57:44 <pastah> this is gonna rock so hard"
21:57:46 <pastah> !!!
21:58:22 <pumpkin-> hmm
21:58:34 <pastah> cool!!
21:58:36 <pastah>   StmWhile e s    -> whenMV (evalExpr e) (eval s >> eval stm)
21:58:57 <pumpkin-> might as well just call it whenV
21:59:05 <mmorrow> just make sure you're positive it'll result in a (VB b) though
21:59:19 <mmorrow> or else dreaded pattern-match failure
21:59:30 <pastah> mmorrow: program wouldn't have passed the typechecker if it wasn't
21:59:35 <mmorrow> nice
22:00:28 <pastah> hmmm... iteVB mb f g = mb >>= \b -> if b then f else g
22:00:28 <ddarius> dolio: Consider M = (\f -> (f,f)) (\x -> x)
22:03:07 <rovar> anyone here use hdbc a bit?
22:03:12 <rovar> i have a general design question
22:03:32 <kyagrd> I've used in a small courswork project
22:03:44 <kyagrd> just to connect to postgresql
22:03:58 <rovar> i just started looking at it
22:04:35 <rovar> what I aim to do is build a wrapper for MongoDB
22:05:11 <pumpkin-> did someone really call a product mongodb?
22:05:17 <pumpkin-> wow
22:05:34 <rovar> just trying to decide whether or not to give it an hdbc wrapper, or if that would be overkill
22:05:49 <pumpkin-> mongodb isn't relational is it?
22:06:04 <rovar> no.. it's OO
22:06:13 <rovar> json-esque interface
22:06:13 <pumpkin-> would hdbc be a good fit?
22:06:20 <glguy> No, you shouldn't use m `mappend` Endo f over m . f
22:06:29 <rovar> i'm not sure.. the basics of it.. yes
22:06:45 <rovar> might be nice to offer a consistent interface.. it's just the queries will look different
22:07:03 <pumpkin-> "HDBC provides an abstraction layer between Haskell programs and SQL relational databases."
22:07:20 <pumpkin-> relational and document-based databases are different enough I'm not sure a common interface would buy you much
22:07:33 <rovar> i suppose
22:08:05 <ImOuttaYourMonad> can someone name a simple convex optimization problem that an idiot can solve?
22:08:17 <pumpkin-> find me the top of a mountain
22:08:33 <pumpkin-> a convex mountain :P
22:08:44 <pastah> pumpkin-: wanna help me shave soething?
22:08:51 <pumpkin-> sounds rather kinky
22:08:51 <pastah> it's an ugly 7 lines
22:08:58 <pumpkin-> but sure
22:09:02 <ImOuttaYourMonad> ok and how is this mountain given as input?
22:09:08 <pastah> doing both post and pri incrementation/decrementation
22:09:13 <pumpkin-> ImOuttaYourMonad: as a 2d array of heights
22:09:21 <pastah> here we go:
22:09:24 <pastah>   incDec :: Expr -> Integer -> Bool -> StateT VARBLZ IO Value
22:09:26 <pastah>   incDec e@(ExId id) n updateAfterEval = do
22:09:28 <pastah>         old <- evalExpr e
22:09:30 <pastah>         let new = case old of
22:09:31 <pumpkin-> @where paste
22:09:31 <lambdabot> http://hpaste.org/new
22:09:32 <pastah>                 (VI i) -> VI $ i + n
22:09:34 <pastah>                 (VD d) -> VD $ d + fromIntegral n
22:09:36 <pastah>         updateVar id new
22:09:38 <pastah>         if updateAfterEval then return old else return new
22:09:40 <pastah> *sorry for the flood*
22:09:49 <dons> ?seen Porges
22:09:49 <lambdabot> I saw Porges leaving #haskell 22h 33m 11s ago, and .
22:10:22 <sjanssen> VARBLZ?  Oh dear...
22:10:23 <ImOuttaYourMonad> pumpkin: mountainTop :: [Integer] -> Int ?
22:10:30 <pastah> pumpkin-: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2228#a2228
22:10:38 <pumpkin-> ImOuttaYourMonad: Array (Int, Int) Int or something
22:10:46 <pastah> sjanssen: type VARBLZ = [M.Map Id Value]
22:10:54 <ImOuttaYourMonad> yes but what is the point, i just search for the biggest one?
22:11:02 <ImOuttaYourMonad> thats like duh
22:11:12 <pumpkin-> [01:08:04] <ImOuttaYourMonad> can someone name a simple convex optimization problem that an idiot can solve?
22:11:19 <ImOuttaYourMonad> ok
22:11:21 <ImOuttaYourMonad> lol
22:11:25 <pumpkin-> in reality, you usually have an objective function
22:11:43 <pumpkin-> in my case, the array can be seen as the objective function, which isn't very interesting
22:13:12 <pumpkin-> ImOuttaYourMonad: linear programming is one form of it, if you want to look it up
22:13:17 <pumpkin-> there are probably plenty of examples
22:13:25 <rovar> pumpkin, looking at the interface.. it seems to me that the queries and their results are incidental
22:13:30 <rovar> for hdbc that is
22:13:57 <pumpkin-> rovar: I dunno, I'm just going by the blurb :) it says SQL/relational/ODBC-compliant and document-based DBs are none of those
22:14:05 <pumpkin-> but maybe it's more general than that
22:14:10 <rovar> sure.. they really are different
22:14:49 <rovar> but as I said. the differences between doc oriented and relational are relegated to the queries and their results :)
22:14:52 <pastah> pumpkin-: updated it with another 6 ugly lines
22:14:55 <rovar> everything else is the same
22:15:24 <pumpkin-> you need caseM :P
22:15:34 <pumpkin-> pity no such thing exists and you can't define it
22:15:39 <rovar> heh
22:16:25 <pastah> pumpkin-: if i can trim those two then everything in this program will be SOOO awesome
22:16:46 <pastah> maybe if that iteVB could maybe have a (a -> Bool or something...)
22:16:48 <pumpkin-> why do you have fromIntegral on the dec?
22:17:22 <pumpkin-> seems like you should be using things like Int32/Word32 ?
22:17:23 <pastah> hmm... lemme try without...
22:17:31 <pastah> Double/Integer
22:17:37 <pumpkin-> oh I see
22:17:40 <pumpkin-> I misunderstood
22:17:54 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2230#a2230 <- can sTuDenT HaZ pAt oN BaCk?
22:17:54 <pumpkin-> why is the increment an integer then?
22:18:25 <pumpkin-> ImOuttaYourMonad: that's just a 2d mountain though!
22:18:28 <pastah> pumpkin-: removed the fromInteger
22:18:32 <pastah>    Couldn't match expected type `Double'
22:18:33 <pastah>            against inferred type `Integer'
22:18:35 <pumpkin-> yeah, makes sense
22:18:38 <pumpkin-> I misunderstood what was going on
22:18:45 <pastah> call is:   ExPreDec  e   -> incDec e (-1) False
22:18:57 <pumpkin-> make Value a functor?
22:19:09 <ImOuttaYourMonad> pumpkin: yes so how would i rep a 3d one?
22:19:10 <pumpkin-> would look prettier maybe
22:19:30 <pastah> i tried something else before... having a class Pack a where pack :: a -> Value, unpack Value -> a
22:19:31 <pumpkin-> ImOuttaYourMonad: an (Int, Int)-indexed array, maybe
22:19:43 <pumpkin-> ImOuttaYourMonad: the issue is that what you're doing now is growing exponentially with the number of dimensions
22:20:08 <pastah> though it turned to shit and i got a lot of "could not determine *yadda* *yadda* *yadda*"
22:20:26 <ImOuttaYourMonad> well maybe i dont get how you mean i would rep the problem of higherdimension mountains
22:20:36 <dolio> ddarius: I guess Church style is something like: (fst ((\f:a->a. (f,f)) (\x:a. a)), snd ((\f:b->b. (f,f)) (\x:b. b)))?
22:20:45 <dolio> So eta doesn't apply because a /= b?
22:20:51 <pumpkin-> Array ((0,0), (5, 5)) [((0,0), heigh1), ...]
22:21:14 <pumpkin-> of course, a discrete search space helps too
22:21:21 <pumpkin-> really you'll just have a function
22:21:37 <mmorrow> dolio: this paper has a good section about various encodings http://cl.cse.wustl.edu/archon/archon.pdf
22:21:57 <mmorrow> (church, scott, morgenson-scott, (maybe others, i don't recall))
22:22:41 <mmorrow> yeah, just those three
22:23:07 <dolio> Church style typed lambda terms, not Church-encoded datatypes.
22:24:05 <pumpkin-> ImOuttaYourMonad: do you get the last example?
22:24:29 <mmorrow> dolio: oh
22:24:39 <ImOuttaYourMonad> duh now i see what you mean, yes it is for (0,3) -> 4, ((0,0),(3,3)) -> 16
22:24:49 <ImOuttaYourMonad> grows fast
22:24:54 <mmorrow> dolio: (on this topic, i think the scott encoding is the one SAPL uses)
22:24:54 <pumpkin-> yeah
22:25:11 <ImOuttaYourMonad> quadratic growth?
22:25:16 <mmorrow> but system F can't type the scott encoding..
22:25:19 <ImOuttaYourMonad> expoentil growth?
22:25:25 <pumpkin-> ImOuttaYourMonad: so now go from an Array, which is really just representing "height" in terms of a vector input
22:25:29 <dolio> Right.
22:25:33 <mmorrow> dolio: what are you doing?
22:25:52 <pumpkin-> ImOuttaYourMonad: to a general function from n inputs to a "weight" (analogous to the terrain height)
22:26:04 <pumpkin-> ImOuttaYourMonad: it's exponential in the number of variables you're optimizing over
22:27:01 <dolio> ddarius remarked that with Curry-style terms, eta violates subject reduction, but I was too myopic to come up with an example myself, so he had to give me an example.
22:27:24 <davidL> is there a recent survey of what operating system haskell users use?
22:27:27 <dolio> Although in retrospect, it's something I probably should have been able to come up with on my own.
22:27:37 <mmorrow> dolio: heh
22:28:42 <mmorrow> dolio: have you had any more thoughts about implementing the EPTS stuff? :)
22:29:18 <Saizan> that's a bit like join (***) f vs. f *** f
22:29:24 <dons> anyone know anything about the Open Software License version 3.0
22:29:38 <wli> What's EPTS?
22:29:46 <dolio> No. I started a little, and then I remembered that I wanted to also add stuff from I Am Not A Number, I Am A Free Variable...
22:29:54 <wli> Is it a variation of Pure Type Systems?
22:29:57 <dolio> But that's a fair amount of infrastructure work, so I got lazy and stopped.
22:29:59 <pumpkin-> Saizan: what is?
22:30:08 <mmorrow> dons: sounds sketchy, maybe russian mob ;)
22:30:29 <wli> I'm still chewing on row types/kinds.
22:30:35 <Saizan> dolio's term above
22:30:38 <pumpkin-> ah
22:30:48 <mmorrow> wli: http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
22:31:12 <dolio> wli: It's pure type systems extended with some additional rules for knowing when you can erase things at compile time (like types).
22:31:26 <mmorrow> dolio: heh, yeah the infrastructure part's always such a pain in the ass..
22:31:55 <dolio> So it formalizes compiler phase distinctions, or at least some stuff in that area.
22:32:07 <wli> I've got a better grip on how to proceed with inference now that I've looked up the answers in two of Mark P. Jones' papers, Typing Haskell in Haskell and A Polymorphic Type System for Extensible Records and Variants.
22:32:43 <wli> Once I understand the answers I've looked up, I can move.
22:32:51 <dolio> mmorrow: I think you're still overestimating the difficulty of actually implementing it. I think it's very little different than normal PTS checking. There's no additional graph structures needed or anything.
22:33:01 <mmorrow> and beyond that, it makes whether something is erasable not inherent in anything's definition, but dependent upon how it's used
22:33:25 <dolio> Toward the end, they tell you to implement your environments as Env = (Env', Int)...
22:33:44 <ImOuttaYourMonad> Array ((0,0), (5, 5)) [((0,0), heigh1), ...], how can I generate that?
22:33:50 <mmorrow> dolio: oh, i don't think it would be that hard per se. just that you'd (one'd) have to do the grunt work of actually implementing it
22:33:54 <dolio> And the annotated pi/lambda/ap is Term = ... | Pi Int Var Term Term | ...
22:34:00 <pumpkin-> http://squing.blogspot.com/2008/11/beautiful-folding.html what do people think?
22:34:09 <mmorrow> dolio: hmm, i'm pretty sure you _at the very least_ need to compute SCCs of the callgraph
22:34:12 * pastah starts using ';' inside his program
22:34:20 <pumpkin-> @slap pastah
22:34:21 <lambdabot> why on earth would I slap pastah?
22:34:21 <pastah> it's making me feel dirty
22:34:26 <pumpkin-> :(
22:34:40 <pastah> @faq can haskell make you filthy?
22:34:40 <lambdabot> The answer is: Yes! Haskell can do that.
22:34:49 <mmorrow> dolio: but that's not a big deal of course, i agree
22:35:57 <dons> ?tell Porges feel free to take over http://hackage.haskell.org/cgi-bin/hackage-scripts/package/email-validate-0.1
22:35:57 <lambdabot> Consider it noted.
22:36:03 <liza0> hello
22:36:08 <ImOuttaYourMonad> > [(x,y) | x <- [0..3] , y <- [0..3]]
22:36:09 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
22:36:10 <pastah> pumpkin-: help with my paste?
22:36:54 <liza0> i am interested in starting to learning haskell and would like to know what is a good book to start with
22:37:12 <Nafai> liza0: Real World Haskell is excellent
22:37:14 <pastah> maybe iteVB needs to take more arguments for runConDis to be able to handle it
22:37:22 <pumpkin-> making Value a Functor might help, or writing a maybe/either-like function for it
22:37:33 <pumpkin-> to avoid case-matching all the time
22:37:36 <liza0> ok thanks Nafai
22:37:48 <pastah> maybe i should add Maybe (a -> Bool) to it
22:38:02 <pastah> pumpkin-: yeah, and have a maybe there
22:38:19 <pastah> (a call to the function "maybe")
22:38:24 <pumpkin-> I mean a catamorphism for the type
22:38:39 <pumpkin-> you say what to do for each constructor
22:38:42 <pastah> miau?
22:38:52 <pumpkin-> although it does have quite a few constructors
22:39:00 <pastah> ehm...? in that inc/dec case?
22:39:03 <pumpkin-> so it might not be much prettier
22:39:04 <pumpkin-> yeah
22:39:08 <pumpkin-> but it might help elsewhere too
22:39:21 <dolio> mmorrow: I don't know, then. It sounds complex to me. :) What I mean is that I think their typing rules take that sort of thing into account.
22:39:32 <pastah> pumpkin-: no, that's the only place
22:39:36 <pastah> hang on, i'll annotate
22:40:46 <pastah> there, reload :)
22:41:01 <dolio> mmorrow: So if you type check things according to their rules, which is a minor extension of checking PTSes (I think), you're guaranteed that erasing all the c-annotated things is sound by that sort of analysis.
22:41:11 <dolio> But maybe I'm underestimating things.
22:41:21 <mmorrow> dolio: from what i understand, the SCCs of the callgraph are needed because that's how the propogation of (non-)erasibility is computed
22:42:12 <pumpkin-> pastah: my point is that there's common structure in your new function
22:42:26 <mmorrow> dolio: but building the callgraph is easy. it'd just be   fmap (\(Bind b bs e) -> (b, fvs e \\ bs)) (xs :: [Bind b])
22:42:29 <pumpkin-> pastah: it's unpacking VI/VD constructors, doing something to the value inside, and packing it up again
22:42:36 <mmorrow> :: [(b, [b])]
22:42:51 <pastah> pumpkin-: actually, that is the only place i do that
22:42:55 <pastah> in the whole program
22:43:25 <pastah> and i have data Value = LOL, not data Value a = LOL a
22:43:28 <mmorrow> err, (fvs e \\ (b:bs)) or whatever
22:43:36 <pastah> so i can't make an instance of functor :/
22:43:44 <pumpkin-> ah true
22:44:20 <pastah> so the only thing left i can do now is to inify the if statements in runConDis and incDec
22:44:35 <pumpkin-> dunno, I think you're pretty golfed
22:44:45 <pastah> NOT ENOUGH
22:44:53 <pastah> @faq can haskell always golf more?
22:44:53 <lambdabot> The answer is: Yes! Haskell can do that.
22:45:04 <mmorrow> dolio: (where i'm assuming data Bind e b = Bind b [b] (e b))
22:45:07 <pastah> pumpkin-: see?
22:45:42 <mmorrow> dolio: (and a "module"/"program" is ==> type Prog e b = [Bind e b])
22:46:59 <pumpkin-> ah
22:47:16 <mmorrow> dolio: (using this rep because that's the one i've been using recently for an interp i'm working on. i like this rep because it's polymorphic over the variable-rep and the "expression" type)
22:47:56 <mmorrow> dolio: so tranformations between two syntaxes become    foo :: [Bind e b] -> [Bind e' b]
22:48:02 <dolio> mmorrow: One other thing is that I've never implemented something like dependent matching ==> ordinary pts, so I don't have enough intuition to know how you'd add pattern matching atop a language like this.
22:48:32 <pastah> WUT?
22:48:40 <pastah> is "default" a keyword in haskell+
22:48:41 <pastah> ?
22:48:47 <lament> > default
22:48:48 <lambdabot>   <no location info>: parse error on input `default'
22:48:59 <pastah> it just got highligted when in gvim for me
22:49:04 <pastah> -when
22:49:31 <mmorrow> dolio: hmm, yeah i've never done something like that either. but i think it's reasonably done (from what i've read) if you restrict patterns in some way
22:50:01 <mmorrow> dolio: but personally i wouldn't even consider pattern matching in my first iteration
22:50:46 <mmorrow> dolio: (i'm not sure though if just disregarding it makes the excersize a waste of time though, but it seems to me it wouldn't)
22:50:49 <dolio> And Conor McBride's noted that, for instance, the proof erasibility in Agda is wrong, because it isn't lazy enough, and I don't know what implications that has for that sort of thing above EPTS.
22:51:48 <mmorrow> dolio: hmm, i'll have to read about that
22:52:26 <mmorrow> dolio: the PiSigma paper has a systematic way to do this, but i haven't worked through it yet (although i want to implem it sooner than later)
22:53:17 <mmorrow> dolio: (PiSigma though isn't meant as a proof-language though, and as such it allows general recursion)
22:53:38 <mmorrow> so it may be less restricted than Agda maybe, i'm not sure really what the issues are here
22:53:53 <dolio> Yeah, but I don't think it'd be a big change to swap positions there.
22:54:09 <mmorrow> but otoh, termination checking can simply be turned off in Agda with no consequences for the type-checker
22:54:11 <dolio> Type:Type is just easier.
22:55:53 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2232#a2232 <- there is the 3d soluton, growing fast yes. but how can I rep things in several dimensions in haskell?
22:55:54 <pastah> @pl \i j = unpack i == unpack j
22:55:54 <lambdabot> (line 1, column 6):
22:55:54 <lambdabot> unexpected "="
22:55:54 <lambdabot> expecting pattern or "->"
22:56:02 <mmorrow> dolio: also, wouldn't the computation of erasibility and type-checking of whatever lang you happen to be using be orthogonal concerns?
22:56:03 <pastah> @pl \i j -> unpack i == unpack j
22:56:03 <lambdabot> (. unpack) . (==) . unpack
22:56:18 <pumpkin-> (==) `on` unpack
22:56:39 <mmorrow> dolio: (that question might not make sense, i'm not positive ;)
22:56:41 <pumpkin-> :t (==) `on` unpack
22:56:42 <lambdabot> Not in scope: `unpack'
22:56:53 <pumpkin-> > (==) `on` f :: Expr
22:56:54 <ImOuttaYourMonad> take the input_dimensiona s a list?
22:56:55 <lambdabot>   Couldn't match expected type `Expr'
22:57:37 <pumpkin-> ImOuttaYourMonad: you want a general function from R^n to R, probably
22:57:38 <pumpkin-> that needs to be maximized/minimized
22:57:43 <dolio> In the past, usually only certain sorts were designated as erasible.
22:58:35 <dolio> Like types, or in Coq, any value x : t such that t : Prop.
22:58:41 <mmorrow> dolio: totally, and from my understanding this paper departs from that
22:59:30 <pumpkin-> what's the point of WrappedMonad?
22:59:36 <mmorrow> by (one way of looking at it i think) treating everything as an "expression", and erasing everything which doesn't have any computational impact on the program result
22:59:41 <pumpkin-> and WrappedArrow
23:01:46 <dolio> Yeah. But it's still tracked through typing judgements and such.
23:01:49 <mmorrow> dolio: hmm, yeah typechecking would need to be interleaved with that somehow/in-some-way, but i (want to) believe that they are separable
23:02:31 <pastah> pumpkin-: packing/unpacking didn't work anyway :/
23:02:38 <pastah> type class ambiguities
23:02:40 <dolio> Like in "\^c x:t -> e" x has no computational content.
23:03:06 <dolio> And it gets added to the typing context as "x :c t".
23:03:25 <mmorrow> what is "\^c" ?
23:03:43 <dolio> It's lambda with a superscript c.
23:03:48 <mmorrow> ahhhh, ok yeah
23:04:46 <mmorrow> hmm, but aren't the ^c and ^r superscripts computed?
23:05:06 <dolio> They're annotations required by the programmer.
23:05:13 <mmorrow> oh, really? hmm
23:05:33 <mmorrow> i didn't remember that part..
23:05:52 <mmorrow> i thought they were computed (via the SCC method i've been going on about)
23:05:56 <dolio> I don't think you can just compute that for arbitrary programs. That's like arbitrary dead code removal.
23:06:07 <mmorrow> hmm
23:07:05 <mmorrow> i thought that the initial ^c/^r tags were supplied by knowledge of the particular source lang you happen to be using, then propogated throughout the prog
23:07:41 <mmorrow> heh, i need to look at that paper again, because i might just be making things up in my mind ;)
23:09:25 <pastah> pumpkin-: SOLVED IT!!
23:09:29 <pumpkin-> ?
23:09:36 <pastah> clever use of maybe
23:09:53 <pastah> iteVB mv maB f g = mv >>= \(VB b) -> if (maybe b (b==) maB) then f else g
23:10:10 <dolio> mmorrow: Yeah, I don't remember them doing that. :)
23:10:13 <pastah> this'll allow me to one-line some other stuff
23:11:09 <mmorrow> dolio: heh
23:11:19 <dolio> They just showed how you could check the ^c/^r annotated language, and showed that if you checked, then erased to a language with all the ^c things removed, and computed a normal form, it was the same as computing the normal form and then erasing.
23:12:34 <dolio> Although I think the proof is elided from whatever copy of the paper I have.
23:12:55 <enoksrd> can someone suggest a better way to die on an error in my main method?
23:13:03 <enoksrd> this is all i came up with: let !die = if <condition> then error <message> else "no op" :P
23:13:58 <Cale> enoksrd: er... why let?
23:14:13 <enoksrd> not sure
23:14:30 <enoksrd> kept getting syntax error when i put the if-then-else at the top level of main
23:14:34 <dolio> if <condition> then <print out an error> else <the rest of your code>
23:14:35 <Cale> if <condition> then error "message" else return ()
23:14:47 <enoksrd> thanks
23:14:50 <pastah> pumpkin-: this is awesome! i'm down from 200 to 110 lines!
23:14:50 <Cale> Or dolio's suggestion.
23:14:51 <enoksrd> i like the second one
23:14:55 <pumpkin-> lol
23:14:57 <pumpkin-> I dread to read the code
23:15:07 <pastah> pumpkin-: nah, it's pretty awesome
23:15:20 <enoksrd> (don't really want to indent all my code inside the error check)
23:16:11 <dolio> when (<condition>) (print-error-message >> exitWith (ExitFailure <code>))
23:16:31 <enoksrd> :t when
23:16:32 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
23:17:51 <pastah> pumpkin-: hmm... if i make the functions to the then/else take as an argument the non-monadic value from the monadic bool computition and add const wherever it's not needed i can do some amazing shit
23:18:06 <pumpkin-> lol
23:18:34 <Gracenotes> don't overdose, dude
23:18:47 <pumpkin-> he crossed that line long ago
23:19:03 <pastah> @pl \mv maB f g ->  mv >>= \(VB b) -> if (maybe b (b==) maB) then f b else g b
23:19:03 <lambdabot> (line 1, column 29):
23:19:03 <lambdabot> unexpected "b"
23:19:03 <lambdabot> expecting operator or ")"
23:19:14 <pastah> @pl \mv maB f g ->  mv >>= \[b] -> if (maybe b (b==) maB) then f b else g b
23:19:14 <lambdabot> (line 1, column 25):
23:19:14 <lambdabot> unexpected "["
23:19:14 <lambdabot> expecting pattern
23:19:22 <pastah> @pl \mv maB f g ->  mv >>= \(x:_) -> if (maybe b (b==) maB) then f b else g b
23:19:23 <lambdabot> (. flip (flip . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . const . const) .)) .) . flip flip ($ b) . ((.) .) . (. ($ b)) . if' . maybe b (b ==)) tail) . (.) . (.) . (>>=)
23:19:23 <enoksrd> dolio: that's perfect, thanks
23:19:33 <pastah> that's fucking awesome!!
23:19:56 <Gracenotes> if' doesn't exist
23:20:02 <Gracenotes> we need something that does
23:20:08 <Gracenotes> like a -> a -> Bool -> a
23:20:20 <Gracenotes> if' is itself Bool -> a -> a -> a
23:20:39 <pastah> pumpkin-: what do you think about that?!
23:20:45 * pumpkin- barfs
23:21:33 <Gracenotes> rather hard to pl pattern matching
23:21:41 <pastah> oh, THERE "head" is... just have to replace that with "unVB"
23:21:57 <pastah> unVB (VB b) = b
23:22:03 <pastah> and i'm all set :D
23:22:30 <Gracenotes> @pl \mv maB f g -> mv >>= \x -> bool (fail) (bool (f b) (g b) (maybe b (b==) maB)) (not $ null x)
23:22:30 <lambdabot> (. flip (flip . ((flip . (((.) . bool fail) .)) .) . flip (flip . (. ($ b)) . bool . ($ b)) . maybe b (b ==)) (not . null)) . (.) . (.) . (>>=)
23:23:22 <pastah> waern: yo!
23:24:13 <pastah> @type bool
23:24:14 <lambdabot> Not in scope: `bool'
23:24:19 <Gracenotes> According to Arnold Rosenberg, what is the hardest natural language?
23:24:45 <wli> Navajo?
23:24:47 <dolio> Malbolge.
23:24:52 <dolio> Oh, wait.
23:25:15 <Gracenotes> a question from a CS exam from a previous semester of my computation class
23:25:21 <Gracenotes> (no, not that kind of class)
23:25:31 <lament> it does sound like that kind of class
23:25:38 <lament> how's that a CS question?
23:25:47 <pastah> chinese?
23:25:50 <Gracenotes> I dunno. It was worth 5 points though
23:26:00 <Gracenotes> I'd be willing to guess English is pretty hard
23:26:10 <Azstal> Presumably this: http://www.cs.umass.edu/~rsnbrg/hardest.pdf
23:26:22 <pastah> Gracenotes: nah, i just think the pronounciations are hard
23:26:25 <Azstal> I would have guessed Xoo or something like that. Of course, it's all relative.
23:26:42 <pastah> give me a good reason for the pronounciation differinces in the words "woman" and "women"
23:26:42 <dolio> I knew a guy who had a calculus exam with the question "What are caltrops?" on it, for a few points.
23:27:07 <pumpkin-> what are caltrops?
23:27:19 <dolio> Because, evidently, the practice exam had the definition on it, and anyone who didn't do the practice exam had to be punished.
23:27:30 <ddarius> @wn caltrop
23:27:31 <pumpkin-> lol
23:27:33 <lambdabot> *** "caltrop" wn "WordNet (r) 2.0"
23:27:33 <lambdabot> caltrop
23:27:33 <lambdabot>      n 1: tropical annual procumbent poisonous subshrub having fruit
23:27:33 <lambdabot>           that splits into five spiny nutlets; serious pasture
23:27:33 <lambdabot>           weed [syn: {devil's weed}, {Tribulus terestris}]
23:27:35 <lambdabot> [7 @more lines]
23:27:42 <dolio> So the guy put "I don't know what caltrops are," and when he got it back, it said, "That's too bad. -5".
23:27:50 <pumpkin-> http://en.wikipedia.org/wiki/Caltrop
23:27:55 <pastah> @pl \x -> f x x
23:27:55 <pumpkin-> wow
23:27:55 <lambdabot> join f
23:28:11 <pastah> @type join "lol"
23:28:12 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Char'
23:28:12 <lambdabot>       Expected type: [[a]]
23:28:12 <lambdabot>       Inferred type: [Char]
23:28:13 <Gracenotes> hm, it seems Chinese is the result
23:28:29 <pastah> @type join ord
23:28:30 <lambdabot>     Couldn't match expected type `Char -> a'
23:28:30 <lambdabot>            against inferred type `Int'
23:28:30 <lambdabot>     Probable cause: `ord' is applied to too many arguments
23:28:40 <pastah> @type join (==True)
23:28:41 <lambdabot>     Couldn't match expected type `Bool -> a'
23:28:41 <lambdabot>            against inferred type `Bool'
23:28:41 <lambdabot>     In the first argument of `join', namely `(== True)'
23:28:43 <Gracenotes> f has to be a function a -> a -> b
23:28:47 <Gracenotes> @type join (==)
23:28:47 <pastah> oh
23:28:48 <lambdabot> forall a. (Eq a) => a -> Bool
23:28:53 <Gracenotes> @type join
23:28:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
23:29:01 <Gracenotes> in this case, m is (s ->)
23:29:02 <pumpkin-> join (==) ftw
23:29:08 <Gracenotes> s, (s -> s -> a) -> (s -> a)
23:29:12 <Gracenotes> *so
23:29:23 <pastah> pretty awesome
23:29:41 <pastah> bah! i should focus on my golfing
23:30:49 <Gracenotes> arrows, monads, functors, applicatives, good for golfing. Except all the import statements, that is >_>
23:31:31 <pumpkin-> LANGUAGE GolfKthxIllBeNeedingAllOfBase
23:31:32 <pastah> what exactly does a computation in the (a ->) monad mean?
23:31:53 <pumpkin-> LANGUAGE AllYourBase?
23:31:55 <pastah>  do
23:32:08 <pastah> sorry, middle click...
23:32:10 <Gracenotes> pastah: well, you can check out the source for the definition :)
23:32:19 <Axman6> LANGUAGE GolfParallelPar
23:32:31 <pastah> Gracenotes: don't think it'll tell me too much
23:32:48 <pastah> it feels like it's all backwards, just like ContM
23:32:51 <Azstal> pastah: it's the reader monad
23:33:09 <Axman6> @hoogle exit
23:33:09 <lambdabot> module System.Exit
23:33:09 <lambdabot> System.Exit data ExitCode
23:33:09 <lambdabot> Control.Exception ExitException :: ExitCode -> Exception
23:33:23 <pastah> Azstal: yeah, i know how reader works, like for the local and look fuctions
23:33:35 <pastah> but (a ->) feels like something completely different
23:33:40 <Gracenotes> intuitively, the Reader monad takes an initial variable and seeds it through the statements to be executed
23:33:44 <pastah> at least when lambdabot uses it :)
23:33:58 <Gracenotes> it is more complicated, though :)
23:34:16 <wli> Reader is a little more than that.
23:34:28 <Gracenotes> yeah
23:34:29 <pastah> Gracenotes: yeah, cause i don't write "const $" at the beginning of each line
23:34:48 <pastah> (who doesn't want the value)
23:37:21 <wli> Reader has nested scope structure.
23:38:47 <pastah> shit, i should really look at the source
23:39:28 <pumpkin-> > liftM (+1) (+2) 4
23:39:30 <lambdabot>   7
23:40:14 <pumpkin-> > liftM2 (*) (+1) (+2) 4
23:40:16 <lambdabot>   30
23:40:20 <glguy> :t arr (+1) <<< arr (+2)
23:40:21 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a, Num b) => a b b
23:40:25 <Gracenotes> omg, it's like... composition, wtf
23:40:38 <pumpkin-> it's magick
23:40:53 <pumpkin-> been using a lot of that in my arm module :P
23:46:13 <glguy> There is a disturbing trend for bored people to try to find more interesting replacements for (.)  :-p
23:46:41 <Baughn> The liftM2 one could be useful, though. ^_^
23:47:02 <mauke> :t join (liftM2 liftM) id
23:47:03 <dons> yeah, why don't they try to find curious replacements for whitespace applicationn?
23:47:04 <lambdabot> forall a1. (a1 -> a1) -> a1 -> a1
23:47:37 <Baughn> ..rather looks like mauke just did.
23:47:48 <pumpkin-> I've been using it a bit like liftMn DataConstructor get get get but with things other than Data.Binary.Get.get
23:48:36 <pumpkin-> ended up being quite elegant I think
23:51:07 <ImOuttaYourMonad> pumpkin-: but how do I pass around higher-dimensional arguments when i dont know before hand how many they will be? store them in a list and have some sort of extra updating function? haskell not having optional or unlimited args forces me to that right?
23:51:35 <Baughn> A list it is. Probably.
23:51:46 <pumpkin-> ImOuttaYourMonad: yeah, a list, or deciding how many in advance... there are hackish ways to get variable numbers of args but I wouldn't recommend it
23:51:51 <lament> ImOuttaYourMonad: when do you ever need to do that?
23:52:14 <pumpkin-> ImOuttaYourMonad: what are you trying to do with this optimization stuff?
23:52:15 <Baughn> pumpkin-: If you're referring to the printf hack, that still decides the argument count at compile-time
23:52:23 <pumpkin-> Baughn: yeah, of course
23:53:07 <pumpkin-> I guess my statement looked like I was implying it was dynamic somehow
23:56:04 <pumpkin-> erikc: around?
23:56:13 <erikc> yup
23:56:22 <pumpkin-> how serious were you about that PPC thing?
23:56:54 <erikc> not serious :)
23:56:58 <pumpkin-> boo
23:57:00 <pumpkin-> :)
23:57:09 <Axman6> PPC thing?
23:58:27 <pumpkin-> well, I'm making Architecture.ARM, and he (jokingly) said he'd do PPC
23:59:59 <ddarius> What does Architecture.ARM do?
23:59:59 <Gracenotes> what did you end up naming the package?
