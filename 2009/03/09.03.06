00:11:35 <b\6> so, data AnyC = forall a . C a => AnyC a. i'm having problems extracting the 'a'. if i do case somec of { AnyC x -> x }, i get crazy stuff.
00:12:18 <dolio> You can't do that.
00:12:21 <kosmikus> you can't extract the 'a', you can only call methods from class C on it
00:12:24 <Baughn> b\6: Well, you can"t extract the a; you can only use the AnyC functions on it
00:12:32 <Baughn> Er. C.. as they said.
00:13:31 <b\6> Baughn: confused. C is the class with the good stuff i want to use. in AnyC x, isn't x the instance of C? how can i use the C functions on the AnyC?
00:14:02 <Baughn> b\6: Sorry about the confusion. You can't. ;)
00:14:19 <Baughn> b\6: But what do you do with it after extracting it from the AnyC?
00:14:46 <b\6> Baughn: well, if i could extract it, i could use the C functions on it, which is the point.
00:15:04 <kosmikus> say you have 'class C a where c :: a -> Int', then you can do 'case somec of { AnyC x -> c x }'
00:15:25 <Gracenotes> for convenience, you could make it a record type
00:15:40 <Baughn> b\6: I'm pretty sure you can't define a function to do the extraction, if that's what you're attempting
00:16:01 <Baughn> b\6: (But record field syntax will do it)
00:16:17 <b\6> hmm, ok. trying.
00:16:47 <Gracenotes> data AnyC = forall a . C a => AnyC { getA :: a }
00:17:32 <kosmikus> does that work?
00:17:39 <kosmikus> what's the type of getA ?
00:18:49 <Gracenotes> hm. Actually, it compiles, but it doesn't seem to work.
00:19:04 <Gracenotes> Cannot use record selector `getA' as a function due to escaped type variables. :)
00:19:08 <b\6> yeah.
00:19:13 <kosmikus> that's what I expect
00:19:26 <kosmikus> so why not just do what I said above
00:19:51 <b\6> trying, thanks.
00:19:59 <kosmikus> if you really must try to simulate OO in Haskell which is rarely needed, that's the way to go
00:21:08 <weilawei> does anyone have a working pipeline/method for writing literate haskell using markdown? (and getting syntax coloring to work)
00:21:23 <Gracenotes> I suppose you can manually define a recordish function
00:23:04 <Gracenotes> hrm. Actually the 'all' relation doesn't go the other way. Constructor extraction it is :)
00:23:29 <Gracenotes> that's what an exists might be useful for
00:23:44 <kosmikus> Gracenotes: what you can do is to define a datatype IsC that holds the methods of the class explicitly
00:24:39 <b\6> kosmikus: thanks, think that worked.
00:24:45 <kosmikus> Gracenotes: oh sorry, I meant AnyC
00:24:48 <kosmikus> b\6: ok
00:24:58 <Gracenotes> *nods*
00:33:10 <Gracenotes> hm. To be really devious, you could probably make AnyC an instance of C
00:33:11 <wli> Ugh, hpaste won't let you diff.
00:33:34 <Gracenotes> I don't know if Haskell would allow it, given the sticky recursion that /might/ result...
00:33:56 <wli> Maybe I should stick to pastebin
00:34:17 <wli> Anyway, is there a name for \lambda^\times extended with coproducts?
00:34:59 <wli> Or, for that matter, n-ary Cartesian products.
00:46:38 <dolio> I'm not sure there are any standard names for various extensions of the simply typed lambda calculus with all the different sugar you could add to it.
00:47:53 <wli> All I really know is $\lambda^\times$ and maybe a couple of variations, mostly not considering coproducts.
00:48:21 <dolio> That's STLC with built-in binary products?
00:49:00 <dolio> I mean, you can get n-ary products from binary products with nesting, obviously.
00:49:05 <wli> Yeah. I don't know what n-ary products are called.
00:50:05 <dolio> So I don't think most people bother making a distinction when it's just theory.
00:52:03 <Eridius> @src some
00:52:04 <lambdabot> some v = some_v
00:52:04 <lambdabot>   where many_v = some_v <|> pure []
00:52:04 <lambdabot>         some_v = (:) <$> v <*> many_v
00:53:24 <dolio> But products, coproducts, integers, etc. They're no more powerful than the ordinary simply typed lambda calculus.
00:53:35 <dolio> So I think they just get lumped into "simple types".
00:53:42 <wli> I figured there'd be some sort of subtle distinction. In the case where there are n-ary products, you can nest in like fashion to how binary products only would simulate n-ary products, and I'm not sure how that ends up backtranslating.
00:53:42 <dolio> You want booleans, add booleans.
00:54:03 <wli> No need for booleans with coproducts.
00:54:26 <Eridius> @src optional
00:54:26 <lambdabot> optional v = Just <$> v <|> pure Nothing
00:55:13 <wli> Booleans are just a coproduct of two nullary constructors. ;)
00:55:21 <dolio> Sure.
00:56:08 <dolio> The only thing you lose is some ability to distinguish between types.
00:56:44 <wli> Kind of like untyped vs. typed situations, sure.
01:00:44 * wli switches to pastebin.org
01:02:39 <wli> http://pastebin.com/m721662c4 <-- there it is
01:19:21 <harblcat> how flexible is haskell pertaining to new operators? all the <...> stuff makes me wonder.
01:21:27 <Cale> harblcat: New operators are treated just like any other function definitions.
01:22:01 <Cale> harblcat: Similarly, we try to avoid shadowing common names when making new ones.
01:22:29 <Cale> Though, especially so in the case of operators, because qualified names for infix operators are especially ugly.
01:22:39 <harblcat> Cale: What constitutes an operator, though? Could I have '[[' be an operator?
01:23:01 <Cale> [ is one of the exceptions to the symbols allowed, I believe
01:23:05 <Baughn> Unfortunately, no; [ is syntax
01:23:24 <harblcat> I see...
01:23:41 <Baughn> It'd be nice if [1,2,3,4] parsed as "fromList [1,2,3,4]" or some such
01:23:44 <Baughn> ..maybe.
01:24:20 <Baughn> At least, it'd allow a concise literal syntax for a lot more types
01:25:04 <Cale> The allowed symbol characters are !#$%&*+./<=>?@\^|-~ along with (supposedly) any unicode symbol or punctuation above the basic ascii range.
01:25:34 <harblcat> Aren't haskell files unicode-compatible?
01:25:56 <Cale> Yes.
01:26:03 <Cale> oh, and : is fine, but it's considered like 'uppercase', so as the first character, it would only be allowed in data constructors
01:26:36 <Cale> (and it must be the first character of infix data constructors)
01:27:39 <Cale> It's also interesting to note that --> is not the start of a comment, but an infix operator.
01:28:11 <Cale> At one point, you could tell the difference between hugs and ghc in a clever way using this fact, because one of them had a parsing bug :)
01:28:31 <harblcat> interesting...
01:29:25 <idnar> Cale: hmm, do you need "-- "?
01:29:27 <Cale> (comments must begin with some number >= 2 of dashes followed by a non-symbol character)
01:29:58 <Cale> So --this is fine
01:30:08 <Cale> But --* this is not a comment
01:31:13 <idnar> ah
01:31:16 <idnar> that's subtle
01:31:34 <idnar> but I suppose it's more or less what you'd expect if you didn't think about it hard
01:31:40 <harblcat> Heh, being able to use any unicode symbol as a function seems like an interesting idea...
01:32:19 <idnar> harblcat: I wish Python identifiers were a) Unicode, and b) could contain non-ascii characters
01:45:01 <Ka1Wr3n> Hello
01:45:09 <Ka1Wr3n> Anyone around?
01:45:35 <Saizan> here we are
01:45:59 <dibblego> @users
01:46:00 <lambdabot> Maximum users seen in #haskell: 658, currently: 586 (89.1%), active: 10 (1.7%)
01:46:00 <Ka1Wr3n> Hey :) Does haskell support multiplication of large numbers out of the box?
01:46:15 <igel> yes
01:46:22 <igel> Integer
01:46:27 <Ka1Wr3n> Something like Karatsuba's etc.
01:46:34 <Saizan> yes the Integer type is unbounded
01:46:39 <Ka1Wr3n> I need to multiply 80 digit numbers
01:46:45 <igel> no problem
01:46:46 <Ka1Wr3n> Is it efficient?
01:46:48 <dibblego> > 2^64 * 2^64
01:46:49 <lambdabot>   340282366920938463463374607431768211456
01:46:57 <Ka1Wr3n> I tried it on GHCi and it kinda hung on me
01:47:04 <Ka1Wr3n> Whoa
01:47:08 <dibblego> > 2^128 * 2^128
01:47:09 <lambdabot>   115792089237316195423570985008687907853269984665640564039457584007913129639...
01:47:29 <Ka1Wr3n> Ok, I'm impressed
01:47:42 <Saizan> compiled with -O2 is generally much faster
01:47:53 <aleator> Anyone enough familiar with haskell blas bindings to be able to tell me how to convert a vector to list of its elements?
01:47:57 <dolio> > 10^80 * 10^80
01:47:59 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
01:48:13 <Ka1Wr3n> Sett, ty guys
01:48:16 <Ka1Wr3n> *Sweet
01:48:30 <Ka1Wr3n> Oh, I have no control over compiler settings I'm afraid
01:48:56 <dancor> > length $ join (*) 10^80
01:48:58 <lambdabot>       No instance for (Num [a])
01:48:58 <lambdabot>        arising from a use of `*' at <interact...
01:49:04 <dancor> > length . show $ join (*) 10^80
01:49:06 <lambdabot>   161
01:49:14 <igel> is Integer so slow without -O2 ?
01:49:38 <Ka1Wr3n> Well I need to do f(n)=n^n where 1<= n < 10^9
01:49:55 <igel> lambdabot only uses ghci too, right?
01:50:11 <igel> or does it compile the expressions?
01:50:20 <dancor> it uses mueval which uses hint i think?
01:50:24 <dolio> take 90 . show $ 2^128 * 2^128 happens almost immediately in ghci for me.
01:50:25 <Ka1Wr3n> > (10^9)^(10^9)
01:50:32 <Gracenotes> entertain us
01:50:40 <lambdabot>   thread killed
01:50:52 <Ka1Wr3n> yeah, thats pretty much my problem
01:50:55 <Gracenotes> oh, jeez.
01:50:58 <Gracenotes> talk about lag.
01:51:19 <dolio> 80-digits isn't really that big.
01:51:25 <Gracenotes> my joke, dieded.
01:51:29 <dancor> > take 1 . show $ join (^) 10^9
01:51:59 <Cale> Ka1Wr3n: What are you trying to compute?
01:51:59 <Ka1Wr3n> Yeah, but for some reason n^n where n = 10^9 blows up
01:52:05 <wli> Those numbers aren't special. Try searching for taxicab numbers, or prime quadruplets.
01:52:06 <Cale> Ka1Wr3n: "for some reason"
01:52:17 <Cale> Ka1Wr3n: Think about how many bits that number will take.
01:52:17 <Ka1Wr3n> Cale: It's a contest
01:52:18 <lambdabot>   thread killed
01:52:27 <dolio> That's a 9-million digit number.
01:52:28 <Ka1Wr3n> Cale: I tried doing Karatsuba's in C and nearly lost my mind
01:52:38 <Cale> Ka1Wr3n: Is there something specific about that number which you're trying to compute?
01:53:09 <Ka1Wr3n> Cale: Nope, I have 30000 test cases for which I need to compute n^n where 1<n<10^9
01:53:13 <aempirei> werd
01:53:21 <blackh> Hi all. Does anyone remember the name of the package that allows you to concatenate loads of ByteStrings efficiently? Someone told me but I forgot before I could remember.
01:53:22 <Ka1Wr3n> Cale: I don't know what those cases are
01:53:32 <Ka1Wr3n> Cale: And I need to do this in under 0.3s
01:53:53 <mcnster> ffi q.  i have a C fn that returns "const char **".  what should the type of the foreign import that calls that C fn be?
01:53:55 <Cale> Ka1Wr3n: And... what do you need to output?
01:54:27 <blackh> mcnster: Ptr CString or Ptr (Ptr CChar)
01:54:46 <Ka1Wr3n> Cale: k, here's a sample
01:55:55 <Saizan> blackh: use Data.Binary.Put from binary,
01:56:02 <Ka1Wr3n> Cale: Input => 4 2, Output => 25 56; Input => 9 3, Output => 387 489
01:56:03 <dolio> > 1e9 * logBase 2 10
01:56:05 <lambdabot>   3.3219280948873625e9
01:56:06 <mcnster> blackh, assume Ptr CString.  how do i deref it?  i assume i have to make peekCString somewhere?
01:56:27 <Ka1Wr3n> Cale: Basically, for a given n and k, print the firs and last k digits of n^n
01:56:40 <Cale> Ka1Wr3n: Oh, that's *totally* different.
01:56:54 <Ka1Wr3n> Cale: Fair enough. I've no idea about this stuff
01:56:55 <Cale> Ka1Wr3n: The idea is then to avoid computing n^n at all.
01:57:05 <Ka1Wr3n> Cale: Oh, ok. Now I'm intrigued
01:57:26 <Ka1Wr3n> Cale: I figured that the requirement for the last k digits meant I cant do this lazily
01:57:39 <blackh> mcnster: cattrlist <- peekArray0 nullPtr cattrs ; attrlist <- mapM peekCString cattrlist (I think)
01:57:42 <dolio> Last k digits is easy.
01:57:54 <Cale> To compute the last k digits, you use modular arithmetic.
01:58:05 <dolio> First k I'm actually not sure how to do.
01:58:21 <Ka1Wr3n> Cale: Ok... any links? I'm not the best when it comes to math sadly...
01:58:29 <blackh> Saizan: Grazie
01:58:31 <Cale> For the first k, you'd want to use an approximation, similar to how floating point would be done.
01:58:33 <mcnster> blackh, thx :) that gives me a starting point
01:59:43 <Cale> Ka1Wr3n: Well... the Fermat/Euler theorem is a basic theorem from number theory which will help with the last few digits part.
02:00:24 <Ka1Wr3n> Cale: I'll look that up... anything else I should be studying
02:01:06 <dibblego> I once witnessed a French man telling off another man for pronouncing the 't' in Fermat
02:01:35 <Saizan> fermath?
02:01:56 <dibblego> "furmar"
02:03:44 <dancor> terra fermat
02:07:56 <imachuchu> umm, I have a question for the gurus here. This is for some HW (queue laughter), I have a function which will give me the two largest numbers in a list
02:08:17 <imachuchu> and I need to get the first one
02:08:24 <imachuchu> how would I sting the two together?
02:09:10 <imachuchu> aka: "secondLargest xs = head max2 xs"
02:10:59 <daf> imachuchu: surely that gives you the first largest, not the second largest
02:11:00 <BONUS> umm so the function you have gives you the two largest numbers in a list
02:11:32 <igel> let (x,y) = theTwoLargest xs in min x y
02:11:34 <imachuchu> yeah, smallest then largest
02:11:50 <igel> or what do you mean?
02:12:28 <daf> imachuchu: if it always returns two items, it should propably return a tuple
02:12:30 <imachuchu> given [1,2,3] it would return [2,3], and then I want to pull out the 2
02:12:47 <daf> imachuchu: then you can have "secondLargest = fst . max2"
02:13:17 <igel> imachuchu: do you want the *first* or the *smallest* of the two largest numbers?
02:14:10 <imachuchu> should be the same, max2 will return a list with second largest then largest
02:15:04 <BONUS> > min [2,3]
02:15:05 <lambdabot>       Overlapping instances for Show ([t] -> [t])
02:15:05 <lambdabot>        arising from a use o...
02:15:11 <BONUS> > minimum [2,3]
02:15:12 <lambdabot>   2
02:15:19 <BONUS> > [2,3] !! 0
02:15:21 <lambdabot>   2
02:15:43 <BONUS> that's some strange homework though
02:16:11 <igel> depends on what's being practiced :)
02:34:24 <imachuchu> ok, using what BONUS posted above I have "secondMax xs = minimum (max2 xs)", but it throws a "Char against inferred type '[Char]'" error
02:34:56 <cnwdup> imachuchu, of which type is max2 and secondMax?
02:35:00 <BONUS> what's the type of max2
02:35:02 <BONUS> yah
02:35:06 <imachuchu> give me a sec
02:40:01 <imachuchu> max2 :: (Ord t) => [t] -> [t]
02:40:09 <imachuchu> sorry it took so long
02:54:16 <imachuchu> any ideas?
02:54:20 <BONUS> > let secondMax xs = minimum (max2 xs) in [1,2,3,4]
02:54:21 <lambdabot>   Not in scope: `max2'
02:55:30 <BONUS> > let max2 = take 2 . sortBy (flip compare); secondMax xs = minimum (max2 xs) in [1,2,3,4]
02:55:32 <lambdabot>   [1,2,3,4]
02:55:37 <BONUS> > let max2 = take 2 . sortBy (flip compare); secondMax xs = minimum (max2 xs) in secondMax [1,2,3,4]
02:55:39 <lambdabot>   3
02:55:50 <BONUS> it seems to work
02:55:55 <Saizan> @source Control.Monad.Fix
02:55:55 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
02:56:49 <BONUS> how are you calling secondMax
02:58:59 <imachuchu> it is called by the professors code, so in one place like "secondMax [5,2,4,7,3,1]"
02:59:40 <imachuchu> in another,  secondMax "Howdy, there!"
03:00:25 <BONUS> > let max2 = take 2 . sortBy (flip compare); secondMax xs = minimum (max2 xs) in secondMax [5,2,4,7,3,1]
03:00:27 <lambdabot>   5
03:00:54 <BONUS> this seems to work so it might be something with the calling code
03:01:24 <Baughn> Sorting is O(length l), though; finding the m-th highest numbers should be O(m*length l) at worst
03:01:36 <Baughn> Er. Sorting is O(n lg n), of course
03:01:57 <imachuchu> well I defined max2 myself (ahem, not nearly as well though) so let me try all of your code and see what happens
03:02:21 <Baughn> :t foldl'
03:02:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:02:55 <BONUS> Baughn: yeah, i just quickly implemented max2 to display the correctness of the other function, which uses it
03:03:28 <Baughn> > foldl' (\s x -> take 2 (sort (x : s))) [-1,-1] [1..5]
03:03:30 <lambdabot>   [-1,-1]
03:03:56 <Baughn> > foldl' (\s x -> take 2 (reverse $ sort (x : s))) [-1,-1] [1..5]
03:03:58 <lambdabot>   [5,4]
03:04:07 <Baughn> Right. That should have the correct asymptotic performance, at least..
03:04:49 <Baughn> (You could of course do a lot better, eg. by reversing the sort comparison)
03:05:11 <Olathe> If sort is written correctly, then take 2 . sort will work in linear time.
03:05:27 <Baughn> Perhaps
03:05:27 <imachuchu> well efficiency isn't a requirement, and this is the first lesson in Haskell, so I figure compiling is a bit of an accomplishment
03:05:45 <Baughn> > take 2 (sort [1..50000])
03:05:47 <lambdabot>   [1,2]
03:06:27 <Baughn> ..there should be some way to test that theory
03:06:37 <brool> take 2 (sort [1..10000000]) takes forever
03:06:58 <Baughn> Well, it does at least have to iterate over a rather large list
03:07:04 <pejo> Baughn, I don't think you need to sort for finding the k maximum numbers.
03:07:31 <vixey> brool it has to check the entire list for example  take 2 (sort ([1..1000000]++[0]))
03:07:44 <Baughn> pejo: Oh, but you do. Sorting a list is a limit case of finding the m highest numbers in an n-element list, for when m=n
03:07:55 <Baughn> At least if you want the result list to be ordered
03:08:30 <Baughn> Anyway, sorting whole list != repeatedly sorting two-element sublists
03:09:04 <weilawei> does anyone here have a stance on literate programming? I'm kinda juggling a few things at once, weighing what seems to work well or not. Pros and cons? Use in tests but not "code"?
03:09:29 <Baughn> weilawei: It's great for walkthroughs, or in general whenever you have significantly more documentation than code
03:09:49 <vixey> does literate programming not just mean: lots of comments?
03:09:55 <Baughn> Pretty much
03:10:07 <vixey> I can't think of any way to object to that
03:10:11 <Baughn> It doesn't seem to play well with haddock, so normally I just non-literate haddocked style instead
03:10:25 <Baughn> Nice for writing papers, though. ;)
03:11:01 <imachuchu> if we only want k sorted elements of n objects then we have to read the list (n) and sort/read the k sublist so O(n * k ln k)?
03:11:24 <weilawei> Baughn: ive got a partially marked up file... i went absolutely nuts on the markup to see how you could make book quality docs -and- code... but i feel like mixing markdown/haskell/latex (code blocks) is too much punctuation and too confusing to use often, even if the result is pretty
03:11:28 <vixey> imachuchu, that's O(n)
03:11:54 <vixey> since 2 is a lot smaller than 100000
03:12:03 <imachuchu> depends on k doesn't it?
03:12:06 <brool> what about when k approaches n?
03:12:08 <imachuchu> in this case yes
03:12:22 <vixey> when k = n then the algorithm is O(0)
03:12:48 <Baughn> Right, I suppose the correct limit would be for when k = n/2
03:13:15 <imachuchu> if k = n then we are essentually just sorting n
03:13:27 <brool> if the result list has to be sorted, yah
03:14:00 <pejo> vixey, I think Knuth envisioned a tight integration with TeX, to make it easy for cross-references and similar things.
03:14:08 <Olathe> If k is a constant regardless of the size of the list, it's O(n).
03:14:45 <trygvis> is there an easy way to schedule threads/tasks? like cron does, just within the application
03:15:00 <trygvis> (sleep doesn't count)
03:18:10 <Cale> Well, there's an easy way to construct such an abstraction.
03:18:14 <Baughn> trygvis: Why doesn'T sleep count?
03:18:55 <Cale> If you want to wait until the current time of day is equal to a certain value, there are IO actions for getting it, and threadDelay can be used to wait in between tests.
03:19:00 <trygvis> because I need to make sure it happens at a regular interval, like cron
03:19:17 <trygvis> Cale: right, just wanted to know if there was something there already
03:19:18 <Cale> trygvis: Oh, then what's wrong with a loop with threadDelay then?
03:19:32 <Cale> If all that matters is the interval...
03:20:10 <vixey> A lot of the computer sci. guys like skiing
03:20:33 <trygvis> the interval between each *start* is important, so I would have to adjust for the time the scheduling take
03:20:40 <trygvis> not a big deal, just wanted to know
03:21:28 <Cale> trygvis: Note that functions can take an IO action as a parameter, which is useful in designing/factoring your abstraction here :)
03:24:40 <imachuchu> I'm almost done thanks to yous guys, but I am getting an error on "secondMax xs = minimum (max2 xs)", it expects type '[a]' but infers type '[b] -> [b]'
03:28:31 <vixey> what's max2?
03:28:54 <maltem> imachuchu: maybe make sure max2 has the type you want it to have
03:29:23 <imachuchu> it returns the largest two values in a list
03:29:54 <vixey> imachuchu, why do you not use
03:29:58 <vixey> max 2 xs
03:30:02 <vixey> rather than
03:30:04 <vixey> max2 xs
03:30:06 <vixey> ?
03:30:34 <maltem> vixey: because that would be different? :)
03:30:43 <vixey> what
03:30:58 <imachuchu> well it would be, max2 xs is different from max 2 xs
03:31:22 <imachuchu> though what can I say, I've been using Haskell for all of 2-3 days now
03:31:58 <HugoDaniel> how do i append to a list ?
03:32:05 <vixey> there is a problem,  max already comes from Prelude
03:32:06 <Deewiant> > [1] ++ [2]
03:32:08 <vixey> so you have to go
03:32:08 <lambdabot>   [1,2]
03:32:12 <vixey> import Prelude hiding (max)
03:32:20 <vixey> then you can define this new on
03:32:38 <HugoDaniel> thanks :)
03:32:43 <Deewiant> Is there any way of doing something like newtype Foo [x] = Foo x ?
03:32:48 <maltem> vixey: ah you were *not* referring to Prelude.max
03:33:08 <imachuchu> well max2 is not my idea, this is for homework sadly
03:33:18 <maltem> Deewiant: What is it going to mean?
03:33:29 <vixey> imachuchu, you can define
03:33:31 <vixey> max2 = max 2
03:33:43 <imachuchu> and it is of type "[b] -> [b]" which sounds fine by me
03:33:51 <imachuchu> give me a sec on that
03:34:32 <imachuchu> well max2 takes a list and then returns a list of the two largest elements
03:34:39 <brool> max2 = highest two numbers, not max of 2 and something
03:34:43 <Deewiant> maltem: Giving Foo an [x] is allowed and then it could forward the type of the list element to another type
03:35:01 <Deewiant> I suppose a better example would have been newtype Foo [x] = Foo (Maybe x) or something
03:35:56 <maltem> Deewiant: Would   x :: Foo Int   be a allowed in that setting?
03:36:04 <Deewiant> maltem: No, that'd be an error
03:36:16 <brool> imachuchu: can we see your definition of max2?  max2 should be [b] -> [b] but (max2 xs) should be a [b]
03:36:28 <maltem> Deewiant: Ok, that's not possible because it would require a smarter kind system than we have now
03:36:33 <vixey> max n = take n . sort
03:36:36 <vixey> max2 = max 2
03:36:43 <Deewiant> The reason I'd like this is that I have a type class with functions like 'x -> m x' where I need x to be a list on the LHS and non-list on the RHS
03:36:55 <Deewiant> maltem: But yeah, I figured it's not possible, thanks
03:37:10 <vixey> Deewiant, did you try with type families?
03:37:20 <Deewiant> vixey: No because I like Hugs compatibility.
03:37:30 <vixey> You definitely can't do this in hugs
03:37:32 <Deewiant> I think I can resolve this with a fundep anyway.
03:37:34 <imachuchu> I am currently working with code donated by Baughn, "max2 = foldl (\s x -> take 2 (reverse $ sort (x : s)))"
03:37:50 <vixey> imachuchu, dont' reverse a sort though
03:37:58 <vixey> sort by a flipped comparator
03:38:02 <brool> you need [-1,-1] at the end of that, i think
03:38:23 <MyCatVerbs> vixey: really no need to shadow Prelude.max. Plus, default sort order is ascending, not descending.
03:38:24 <imachuchu> brool: ?
03:38:44 <MyCatVerbs> brool means as a base case.
03:38:50 <imachuchu> well I was going to worry about the order last
03:39:02 <brool> max2 = foldl (\s x -> take 2 (reverse $ sort (x : s))) [-1,-1]
03:39:07 <vixey> MyCatVerbs, should it be  myMax  or  max'  or some meaningless thing?
03:39:14 <brool> > let max2 = foldl (\s x -> take 2 (reverse $ sort (x : s))) [-1,-1] in max2 [1..5]
03:39:15 <lambdabot>   [5,4]
03:39:40 <imachuchu> sorry, max2 it must be (professor ordererd)
03:39:45 <brool> your max2 will have a sig of [a] -> [a] -> [a]
03:39:48 <Olathe> @src sortBy
03:39:48 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
03:39:53 <Olathe> @src insertBy
03:39:53 <lambdabot> insertBy _   x [] = [x]
03:39:53 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
03:39:53 <lambdabot>                                  GT -> y : insertBy cmp x ys'
03:39:53 <lambdabot>                                  _  -> x : ys
03:40:03 <Baughn> imachuchu: I did mention you should reverse the comparator..
03:40:06 <MyCatVerbs> vixey: maxElements or something with an allusion to lists in the title, but sure. :P
03:40:18 <vixey> I think max is a fine name
03:40:31 <Baughn> imachuchu: In general, don't reverse sorts. It's okay in this case (since it's a three-element sort), but it'll usually cause stack overflows.
03:40:44 <Olathe> It will be identical to use max2 = take 2 . sortBy (flip compare)
03:40:44 <imachuchu> sorry, I wasn't worried about order till later, figured i could fix it later on
03:40:52 <Baughn> @src sort
03:40:52 <lambdabot> sort = sortBy compare
03:41:05 <vixey> Olathe, you should set a good example: max n = take n . sortBy (flip compare)
03:41:12 <vixey> then max2 = max 2
03:41:35 <MyCatVerbs> vixey: I... really, no. Not only does it shadow Prelude.max, but it's surprisingly common to use max :: (Ord a) => a -> a -> a, even in languages that are nothing like Haskell.
03:43:00 <MyCatVerbs> vixey: e.g. watch C programmers write #define MAX(a,b) (((a)<(b))? (b) : (a))
03:43:09 <vixey> lol you didn't use a tmp variable
03:43:23 <vixey> MAX(i++,rand());
03:43:59 <MyCatVerbs> vixey: ...are you drunk or something? And yes, that's why you don't do that. String-rewriting macro systems suck.
03:44:13 <vixey> you just did it
03:44:16 <vixey> A correct MAX macro in C is like 2 pages
03:44:41 <Baughn> MyCatVerbs: #define MAX(a,b) a > b ? a : b
03:45:06 <MyCatVerbs> Baughn: the extra parens are necessary to avoid operator precedence woes.
03:45:19 <vixey> #define MAX(a,b) b
03:45:41 <MyCatVerbs> Baughn: if a or b are expressions with comparisons in the middle, for example.
03:45:43 <catface> i did it without brackets once, took YEARS to work out what was wrong
03:46:24 <MyCatVerbs> catface: ouuuuch. x_x
03:47:07 <imachuchu> adding on the default values ([-1,-1]) it compiles but won't work for strings (which the test code tests)
03:47:26 <imachuchu> not sure why someone would want to get the two greatest chars out, but whatever
03:48:08 <brool> imachuchu: right, the [-1,-1] forces it to integer -- do you need it work with strings?
03:48:14 <imachuchu> sadly yes
03:48:24 <Olathe> You can use max' n = take n . sortBy (flip compare); max2 = max' 2
03:51:55 <brool> > let max2 x = take 2 $ sortBy (flip compare) x in max2 "ABCDE"
03:51:57 <lambdabot>   "ED"
03:52:12 <vixey> > let max n x = take n $ sortBy (flip compare) x in max 2 "ABCDE"
03:52:14 <lambdabot>   "ED"
03:52:28 <vixey> > let max n x = take n $ sortBy (flip compare) x in max 3 "ABCDE"
03:52:29 <lambdabot>   "EDC"
03:53:04 <drdozer1> is cabal likely to get a --use-darcs option, that when it can't find a dependency, attempts to acquire the source from darcs rather than a release?
03:53:31 <imachuchu> thanks vixey, that solved that problem wonderfully
03:53:45 <imachuchu> and you too brool
03:54:48 <imachuchu> last problem (I hope) is that secondMax won't work on stings either
03:55:02 <brool> imachuchu: i thought your prof gave you secondMax?
03:55:30 <imachuchu> no it's another function I have to create
03:55:40 <imachuchu> I currently have "secondMax xs = minimum (max2 xs)"
03:56:14 <imachuchu> but it throws an expected Char vs inferred [Char] error
03:56:32 <brool> imachuchu: even with your new max2?  that should work
03:56:43 <MyCatVerbs> So your definition of minimum is...? Ought to be (head . sort).
03:57:15 <imachuchu> even with them
03:57:19 <vixey> imachuchu I guess that is mine time to give up then
03:57:55 <imachuchu> oops, my mistake
03:58:02 <imachuchu> it's an error in his code ;)
03:58:27 <MyCatVerbs> imachuchu: what type is secondMax supposed to have? (Ord a) => [a] -> a, or has he asked for (Ord a) => [a] -> [a] for some crazy reason?
04:00:23 <imachuchu> thank you all for all of your help, my code now works and the only errors I am getting is on stuff I can't change
04:01:45 <imachuchu> till next assignment
04:02:21 <xDie> hi all
04:04:25 <pernod> Newbie alert: Could someone please tell me how to print a list of tuples to the terminal form haskell?
04:05:01 <pernod> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2144#a2144
04:08:05 <TSC> pernod: It looks like you need brackets around "coords stockprices"
04:08:13 <TSC> And "map" should perhaps be "mapM_"
04:09:02 <TSC> (of course, you could also use the simple "mapM_ print (coords stockprices)")
04:09:53 <pernod> TSC: I was hoping for something along the lines of mapM :)
04:10:49 <pernod> TSC: Thanks, the mapM_ allows me to print, but I would like to format stuff
04:11:07 <pernod> (e.g. "number;number", not "(number,number)")
04:11:10 <TSC> Yeah, I thought you might
04:11:20 <TSC> Then what you had should work, with those changes
04:11:36 <TSC> i.e. "mapM_ ( \(x,y) -> printf ... ) (coords stockprices)"
04:11:43 <TSC> @type printf
04:11:45 <lambdabot> forall r. (PrintfType r) => String -> r
04:12:27 <xDie> @join #bsduy
04:12:28 <lambdabot> Not enough privileges
04:13:34 <pernod> TSC: Indeed.
04:13:38 <pernod> Thank you very much.
04:13:45 <TSC> You're welcome.
04:14:32 <pernod> :t mapM_
04:14:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:15:27 <TSC> mapM_ is like mapM but it throws away the results
04:15:47 <TSC> And mapM is just sequence + map
04:21:22 <pernod> I have to admit that I find the monads a bit complex at the moment. Haven't really understood how they work, which complicates doing fairly straightforward tasks.
04:22:20 <Botje> pernod: just start using them
04:22:28 <Botje> if you bash long enough at the types, it all makes sense
04:22:32 <Ferdirand> is it a good idea to explain functors first when trying to explain monads to someone ?
04:22:52 <Botje> if you take the fmap + join approach to monads, sure
04:23:02 <pernod> I'm in the process of banging my head against them yes, seeing as I just tried to do something in Haskell that would have taken me 5 minutes in excel ;)
04:23:17 <maltem> Ferdirand: I would think so, yes
04:23:45 <maltem> Ferdirand: however, an even better idea is to explain type classes in general first
04:29:05 <Cale> pernod: More importantly than understanding monads for doing I/O in Haskell is simply understanding that IO actions are values.
04:29:23 <Fredrik> Is there a simpler way than using explicit recursion for this?
04:29:24 <Fredrik> readPosition = do
04:29:24 <Fredrik>     position <- readInt
04:29:24 <Fredrik>     if legal position then return position else readPosition
04:29:41 <Fredrik> Something like "until legal readPosition" or so :)
04:30:30 <Cale> Fredrik: I don't think there's anything directly in Control.Monad for that, though it's possible to write one.
04:30:53 <Cale> If you have to write a few loops of that form, it might be worthwhile to do that.
04:31:58 <Fredrik> OK, another question. Can I combine multiple predicates into on? Something like "pred1 AND pred2" to yield another predicate?
04:32:11 <Cale> I think the reason there's not a whileM/untilM in the libraries is that there are so many minor variations on it that it's hard to choose one.
04:32:26 <Cale> liftM2 (&&) will do that.
04:32:28 <pejo> Cale, while you arecorrect about the actions being values I'm not sure that it helps unless someone already happens to know lambda calculus quite well.
04:32:47 <Cale> er, that's using the (->) e monad though... you'll have to import Control.Monad.Instances
04:33:18 <Cale> pejo: Well, it's really hard to understand why something like  putStrLn getLine  doesn't work until you understand that.
04:33:42 <Cale> Sure, there's a typing issue there too.
04:34:18 <Cale> But it helps to know what kind of thing getLine is, and to understand that rather than passing the result of getLine to putStrLn, this means to pass getLine itself to putStrLn.
04:34:24 <pejo> Cale, that makes sense to me now, but I'm not sure it would have helped when I was an undergrad.
04:34:46 <vixey> pejo, some people learn stuff at different times
04:36:00 <Fredrik> Hm, I dont get this lifting stuff. Here is the xpression I want to simplify:
04:36:01 <Fredrik> (legal position) && (vacant board position)
04:36:13 <Fredrik> I want to say "(legal && vacant board) position" or something like that
04:38:06 <Cale> Yeah, that's what liftM2 does... for functions,  liftM2 f x y z = f (x z) (y z)
04:38:25 <Cale> Of course, you can also use a lambda.
04:39:00 <Cale> Or write a pre-lifted version of (&&)
04:39:31 <Zao> > (+2) &&& (*2) $ 10
04:39:33 <lambdabot>   (12,20)
04:40:28 <Cale> Like, write:
04:40:47 <Cale> (f <&&> g) x = f x && g x
04:40:59 <Cale> and then use that to combine your predicates
04:41:14 <Fredrik> And then <&&> would be the same as liftM2 (&&) ?
04:41:34 <Cale> yes
04:41:46 <Cale> Though, liftM2 (&&) actually has a more general type
04:41:51 <Cale> :t liftM2 (&&)
04:41:53 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
04:42:08 <Cale> But in the case that m = (e ->), it's the same
04:44:19 <Fredrik> OK, I got it to work with my custom function, but what would I need to change to make it work with the lifting:
04:44:19 <Fredrik> myAnd f g x = f x && g x
04:44:20 <Fredrik> readPosition board = do
04:44:20 <Fredrik>     position <- readInt
04:44:20 <Fredrik>     if (legal `myAnd` vacant board) position then return position else readPosition board
04:44:48 <maltem> :t liftA2 (&&) -- Once we're being general
04:44:49 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
04:45:37 <maltem> Fredrik: well that looks quite right?
04:45:51 <pernod> Umm.
04:46:01 <pernod> So if I want to print a list instead of a tuple ...
04:46:13 <pernod> Or actually, print a list of lists.
04:46:20 <pernod> [[Double]]
04:46:38 <Peaker> @type print [[1.2,3.4],[5.6,7.8::Double]]
04:46:39 <lambdabot> IO ()
04:47:12 <Peaker> pernod: "print" should work
04:48:03 <pernod> Peaker: Indeed it does, but how do I format the output as comma separated values?
04:48:24 <pernod> foldl?
04:48:30 <Peaker> pernod: for the list [[1.2,3.4],[5.6,7.8]] -- how do you want to format that?
04:48:32 <maltem> pernod: What exact format do you want (example)?
04:48:40 <pernod> 1.2;3.4
04:48:46 <pernod> 5.6;7.8
04:49:00 <Peaker> @type intercalate
04:49:01 <lambdabot> forall a. [a] -> [[a]] -> [a]
04:49:13 <Peaker> > intercalate ", " ["hello", "world", "ooooo"]
04:49:14 <lambdabot>   "hello, world, ooooo"
04:49:26 <pernod> Each list on it's own line, with a semicolon (or something) between each element in the sub-lists.
04:49:54 <maltem> > unlines $ map (intercalate ", " . map show) [[1.2,3.4],[5.6,7.8::Double]]
04:49:55 <lambdabot>   "1.2, 3.4\n5.6, 7.8\n"
04:50:10 <maltem> pernod: Like that?
04:50:24 <pernod> For example.
04:50:32 <Peaker> > unlines . map (intercalate ", " . map show) $ [[1.2,3.4],[5.6,7.8::Double]]
04:50:34 <lambdabot>   "1.2, 3.4\n5.6, 7.8\n"
04:50:46 <Peaker> > intercalate "\n" . map (intercalate ", " . map show) $ [[1.2,3.4],[5.6,7.8::Double]]
04:50:47 <lambdabot>   "1.2, 3.4\n5.6, 7.8"
04:50:57 <pernod> My word!
04:51:03 <pernod> *confused*
04:51:13 <Peaker> pernod: what confused you?
04:51:35 <pernod> Peaker: I think I just need to stare at this for a little while.
04:51:42 <Peaker> f $ g x = f . g $ x = f (g x)
04:51:53 <pernod> intercalcate stuffs something between each element i a list and returns it as a string?
04:52:02 <pernod> :t intercalcate
04:52:04 <lambdabot> Not in scope: `intercalcate'
04:52:17 <Peaker> pernod: intercalate concats the list you give it but places the separator its given between each two list items
04:52:29 <Peaker> intercalate ", "   is like Python's   ", ".join   :-)
04:52:34 <pernod> Peaker: Just what I wanted then!
04:52:39 <pernod> Thanks.
04:56:05 <pernod> Peaker: Where does this fabled funcion live, by the way?
04:56:24 <TSC> Data.List
04:56:51 <Peaker> @index intercalate
04:56:51 <lambdabot> bzzt
04:56:58 <Peaker> @hoogle intercalate
04:56:59 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
04:56:59 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:56:59 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
04:57:14 <pernod> Thank you very much all of you.
04:57:16 <Peaker> pernod: @index should generally tell you, but for the cases it fails, @hoogle works too
04:57:41 <Fredrik> I think I got it to work. Thanks everyone! Here it is: http://haskell.pastebin.com/m72400edb
04:58:07 <pernod> Peaker: It helps typing the function name correctly when I use hoogle, actually.
04:58:11 * pernod slaps forehead
05:01:52 <Fredrik> @pl (\f g x -> fx && gx)
05:01:52 <lambdabot> const (const (const (fx && gx)))
05:02:01 <Fredrik> lol?
05:02:11 <Fredrik> @pl (\f g x -> f x && g x)
05:02:11 <lambdabot> liftM2 (&&)
05:02:14 <Fredrik> LOL
05:04:05 <vixey> lol
05:04:22 <pernod> Hm.
05:04:28 <pernod> I still can't get it work though.
05:05:34 <Fredrik> http://haskell.pastebin.com/m57b4289c
05:05:56 <vixey> Fredrik that looks good
05:06:30 <Fredrik> thank you :)
05:08:12 <pernod> Forget it. Got it in the end.
05:08:14 <pernod> Thanks!
05:10:07 <Fredrik> Any ideas how I can make this less disgusting? :) http://haskell.pastebin.com/m11206f6c
05:10:32 <vixey> unlines
05:10:34 <vixey>  [ "foo"
05:10:36 <vixey>  , "bar"
05:10:36 <vixey>  ]
05:10:43 <Fredrik> of course! thank you
05:21:20 <Peaker> Fredrik: maybe http://haskell.pastebin.com/m1f56e173
05:24:00 <Fredrik> Peaker thanks, my solution is a lot messier :) http://haskell.pastebin.com/m4bce87eb
05:24:52 <Peaker> Fredrik: if you add "sep++" to the beginning of your   col m = ..      then you can remove it from the list
05:25:05 <drdozer1> is code.haskell.org down?
05:25:20 <drdozer1> or is it just me?
05:25:46 <Deewiant> http://downforeveryoneorjustme.com/code.haskell.org
05:26:35 <Badger> hah
05:27:02 <Deewiant> Argh, Hugs fails at polymorphic recursion with scoped type variables
05:27:59 <BONUS> Deewiant: example=
05:28:21 <BONUS> s/=/?
05:28:51 <Deewiant> BONUS: it'd be quite long
05:29:02 <Deewiant> and probably not understandable without huge amounts of context
05:29:19 <BONUS> ah i see. why are you using hugs though?
05:29:21 <Peaker> Does hugs attempt to support the various ghc/haskell' extensions?
05:29:35 <Deewiant> I just like to make my libraries Hugs compatible where possible
05:29:42 <Deewiant> And it looks like it isn't possible in this case :-/
05:29:43 <maxote> hugs should be modified, overall its type engine
05:30:08 <Deewiant> Peaker: it has some kind of support for scoped tyvars and I thought what I'm doing would work but evidently it doesn't
05:30:36 <Peaker> @hoogle Zip
05:30:36 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
05:30:36 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
05:30:36 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
05:30:42 <Deewiant> In general, no, GHC supports a lot more than Hugs.
05:30:42 <Peaker> is there a Zip typeclass somewhere?
05:30:49 <Deewiant> ?hoogle ZipList
05:30:49 <lambdabot> Control.Applicative newtype ZipList a
05:30:49 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
05:30:49 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
05:30:58 <Deewiant> Ah, typeclass. Not that I know of, no.
05:31:29 <Deewiant> BONUS: this is the type it's complaining about (one which it infers)
05:31:31 <Deewiant> *** Type          : (Alt a b, Boolable (a b)) => (a c -> a d -> a b) -> (a b -> e f g b -> e f g b) -> CMap e f g d -> a c -> CMap e f g c -> DList g -> [g] -> e f g b
05:31:45 <Deewiant> So yeah, a bit long. ;-P
05:33:38 <BONUS> haha i see
05:33:55 <Deewiant> That's actually a more general type than I give so it's a bit shorter. :-P
05:35:07 <Deewiant> Aha! Got it to work.
05:35:52 <Deewiant> Type class constraints don't propagate to definitions in 'where' clauses, evidently.
05:36:08 <Deewiant> So I just copied it over from the top-level definition. :-P
05:37:12 <Deewiant> Yay, the whole thing can be loaded now.
05:38:00 <Deewiant> It does make me wonder, though, if it makes any sense for me to try remaining compatible with Hugs on the language level when I'm blatantly ignoring constraints on the library level. (Hugs with base-4, anyone?)
05:41:59 <BONUS> eh i dont see the point in hugs compatibility
05:42:04 <BONUS> i mean when was the last release of hugs
05:42:53 <Deewiant> Late 2006 I think
05:43:00 <Deewiant> Yeah, September.
05:43:14 <araujo> morning
05:43:16 <BONUS> that's two years and a half :\
05:44:55 <Deewiant> I'm just sort of principally against locking code to a single compiler. Maybe I've spent too much time trying to hack some obscure GNU C code into a compiling state.
05:45:39 <Peaker> @hoogle peekMVar
05:45:39 <lambdabot> No results found
05:45:45 <Peaker> @hoogle readMVar
05:45:46 <lambdabot> Control.Concurrent.MVar readMVar :: MVar a -> IO a
05:46:51 <Deewiant> If there were any indication that the cool new GHC stuff would be in some standard any time sooner than in twenty years, then sure, I'd use it.
05:47:16 <McManiaC> how can i use a function which return IO Int in pure code?
05:47:28 <Deewiant> I'm optimistic about Haskell' though, I think it'll fit into that time frame, and hence I'm fine with being compatible to it. ;-)
05:48:07 <Zao> McManiaC: unsafePerformIOEvilness?
05:48:09 <Deewiant> McManiaC: read an IO tutorial or six.
05:48:09 <wli> I think O(k * n * ln(n))
05:49:40 <drdozer1> code.haskell.org still seems dead to me
05:49:45 <drdozer1> can anyone else contact it?
05:49:46 <Deewiant> McManiaC: In short: you can't use such a function in pure code, you can only use it in impure code and then pass the return value as Int into pure code.
05:50:09 <Deewiant> drdozer1: http://downforeveryoneorjustme.com/code.haskell.org still says it's down so it probably is.
05:50:23 <McManiaC> hm yeh, thinking about it its probably a bad idea to do that
05:50:27 <Peaker> I'm trying to work on a monadic iterator - sort of Like Pythonic generators or lazy IO, except its explicit about the IO (and generalized to all monads)
05:50:39 <maltem> Deewiant: Talking Haskell', do people still believe it will take good shape anytime soon?
05:50:42 <drdozer1> Deewiant: that's a pain
05:50:55 <dejones> JaffaCake: Hello.  :)
05:50:56 <Deewiant> maltem: Like said, I'm optimistic that it'll happen in the next 20 years. ;-)
05:51:01 <Peaker> Then I want it to have instances of Functor,Applicate,Monad,Zip, and its its own iteration/fold functions
05:51:07 <maltem> Deewiant: yeah...
05:51:19 <JaffaCake> hi dejones
05:51:20 <Peaker> then you could have a "fileLines" that does "lazy I/O" but doesn't have to use unsafe IO stuff to do it
05:52:28 <dejones> JaffaCake: I was thinking more about the compilation flags for EventLogging, if we later want to add support for graphing CPU and memory usage, the profiling of that information may incur much more significant overhead, would we remove the compilation flags for those too?  Or would that be supported separately?
05:53:35 <JaffaCake> I think probably the safest thing for now is to keep it as a separate RTS way with an -eventlog flag, on the grounds that in the future we might want to add very fine grained events
05:53:47 <McManiaC> @src foldr
05:53:47 <lambdabot> foldr f z []     = z
05:53:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:57:33 <McManiaC> let step _ = do num <- rollDice max
05:57:33 <McManiaC>                     return $ show num
05:57:49 <McManiaC> "the last statement in a 'do' construct must be an expression"
05:58:01 <McManiaC> i thought return solves that problem?
05:58:10 <idnar> McManiaC: your return is indented incorrectly
05:58:20 <McManiaC> not in my code idnar
05:58:29 <idnar> McManiaC: the "r" needs to be in line with the "n" in num
05:58:45 <McManiaC> thats a copy & paste mistake :)
05:59:32 <maltem> McManiaC: it's probably still wrong in the original file. Check if you have any tabs in there
05:59:56 <maltem> McManiaC: specifically if your tabs aren't shown with width 8
06:00:09 <McManiaC> i always use tabs
06:00:14 <McManiaC> < vim user
06:00:16 <McManiaC> *spaces
06:00:37 <maltem> hmm
06:01:05 <Fredrik> @pl (\x -> q ! x == r)
06:01:05 <lambdabot> (r ==) . (q !)
06:01:18 <maltem> Is there an outer do expression?
06:01:26 <McManiaC> yes maltem
06:01:35 <Deewiant> There must be or there'd have to be an 'in'.
06:01:44 <Fredrik> @pl (\a -> x ! a == p)
06:01:44 <lambdabot> (p ==) . (x !)
06:02:21 <maltem> McManiaC: And is the last statement in the outer do expression an expression?
06:02:37 <McManiaC> maltem: the last one is putStrLn
06:02:56 <Fredrik> @pl (\bar -> and (map ((player == ) . (x !)) bar))
06:02:56 <lambdabot> all ((player ==) . (x !))
06:03:05 <maxote> @hoogle Cabal
06:03:05 <lambdabot> package Cabal
06:03:05 <lambdabot> package cabal-install
06:03:05 <lambdabot> package cabal-rpm
06:03:06 <Fredrik> damn that bot is smart
06:03:26 <maxote> Fredrik, sure?
06:03:46 <Fredrik> @pl or (map (all ((player ==) . (x !))) win)
06:03:47 <lambdabot> any (all ((player ==) . (x !))) win
06:04:08 <Fredrik> smarter than me for sure :)
06:04:13 <maxote> Fredrik, try (reverse (reverse [1..]))
06:04:15 <McManiaC> maltem: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2146#a2146
06:05:42 <McManiaC> (no idea if it works that why, i never got beyond the "must be an expression" message =(
06:06:00 <Deewiant> McManiaC: your 'ret' and 'putStrLn' are indented one deeper than the 'let'
06:06:14 <McManiaC> aiaiaiai
06:06:17 <McManiaC> thats it :D
06:06:48 <McManiaC> stupid layout >.>
06:10:40 <gwern> @hoogle Stringable
06:10:40 <lambdabot> No results found
06:10:45 <gwern> hm... where is Stringable defined
06:11:45 <gwern> 'stringtable' keeps messing up my google searches :(
06:24:36 <vixey> @w80 retrogressive
06:24:39 <lambdabot> *** "retrogressive" wn "WordNet (r) 2.0"
06:24:39 <lambdabot> retrogressive
06:24:39 <lambdabot>      adj : going from better to worse [syn: {retrograde}]
06:24:46 <vixey> hi
06:37:13 <McManiaC> is there sth like showM for monads?
06:37:31 <McManiaC> or do i need liftM show?
06:38:51 <vixey> "sth"
06:39:42 <Peaker> McManiaC: you want to apply show inside the monad?
06:40:01 <Peaker> McManiaC: to apply f inside the monad, use liftM f, so as you said: "liftM show"
06:40:11 <McManiaC> ok
06:49:16 <vixey> @w80 sth
06:49:17 <lambdabot> *** "STH" wn "WordNet (r) 2.0"
06:49:17 <lambdabot> STH
06:49:17 <lambdabot>      n : a hormone produced by the anterior pituitary gland; promotes
06:49:17 <lambdabot>          growth in humans [syn: {somatotropin}, {somatotrophin}, {somatotropic
06:49:17 <lambdabot>          hormone}, {somatotrophic hormone}, {human growth hormone},
06:49:19 <lambdabot>           {growth hormone}]
06:49:24 <vixey> lol
06:51:46 <maltem> vixey: something
07:08:03 <Peaker> Seems to work: http://haskell.pastebin.com/d3dd70240
07:08:36 <Peaker> @hoogle unsafeInter
07:08:37 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
07:08:37 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
07:08:37 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
07:08:39 <Peaker> an implementation of MList -- sort of like Python generators -- explicit lazy I/O rather than yucky unsafeInterleaveIO
07:09:15 <Peaker> not sure if it is very useful, but many really dislike lazy I/O and reading the whole file strictly before any computation is wrong too
07:11:14 <Peaker> so I created MList, which has its own zip, append, concat, instances of Functor, Applicative, Monad, Monoid (Monoid new in   http://haskell.pastebin.com/df974742  )
07:16:52 <maltem> Peaker: Is that related to the enumerator/iteratee stuff floating on haskell-cafe?
07:17:15 <Peaker> not sure
07:17:17 <Peaker> maybe :)
07:17:37 <maltem> hm I don't think it's directly related
07:17:44 <maltem> iteratee stuff usually hurts my eyes
07:17:47 <Saizan> an enumerator also encapsulates the resource, usually
07:17:51 <Saizan> like the Handle
07:18:58 <Peaker> Saizan: You could have a line reader that closed the file when it hit the end (as there's no way to go back anyway)
07:20:14 <Peaker> a little prettified: http://haskell.pastebin.com/d467b3d75
07:20:45 <Peaker> I think this is nice: mapMList_ print $ liftA2 (++) (mlistForPath "test/blah") (mlistForPath "test/bleh")
07:20:49 <Saizan> yeah, but you also want to close the handle when you decide you don't need more lines
07:21:39 <Peaker> Saizan: Could wrap the MList reference with a file closer as finalizer or such
07:21:56 <Peaker> I guess this already happens because the finalizer of Handle itself probably does this
07:23:55 <Saizan> there's no guarantee on when and if that finalizer will run though
07:24:08 <Saizan> but MList looks useful anyway
07:24:19 <Peaker> cool, thanks :-)
07:27:51 <Saizan> it still needs a suitable consumer though, the fact that lazy IO doesn't is its big selling point
07:28:11 <Peaker> lazy IO doesn't what?
07:28:21 <Peaker> you mean doing the closing properly?
07:28:27 <edwardk> MList == ListT done right?
07:29:01 <Peaker> edwardk: Nope, MList is an explicitly "lazy I/O" list, where the IO-ness of getting the next element is encoded in the type, except its not IO-specific but for any monad
07:29:33 <Saizan> the datatype is the same though :)
07:29:50 <Gracenotes> is this like the lazy lists that apparently were used for IO way back in Haskell's history?
07:29:51 <Peaker> Hmm.. interesting to think about the relationship between MList and ListT then :)
07:30:09 <Peaker> Gracenotes: I don't think its like that
07:30:18 <Peaker> I haven't used those though, only heard about them
07:30:23 <Saizan> Gracenotes: no, those where simple list
07:30:40 <Gracenotes> how did they get processed?
07:31:09 <Peaker> Gracenotes: I guess similarly to unsafeInterleaveIO
07:31:13 <Saizan> you just consumed one while producing the other, like in interact
07:31:42 <Gracenotes> ah, interesting
07:31:59 <Peaker> is there a ListT done right anywhere?
07:32:06 <Peaker> could be nice to compare -- maybe even merge MList with that
07:32:10 <Saizan> on the haskellwiki
07:32:28 <Peaker> why isn't it in hackage instead?
07:32:50 <Peaker> wow, the type is not just similar, its identical :-)
07:32:59 <Peaker> and I had different ways to represent it, too
07:33:01 <Gracenotes> list is too built-in, it seems
07:33:14 <Peaker> all the names and everything too, heh
07:34:43 <Peaker> its probably better to use liftM than fmap for Monads, to avoid the big context clutter
07:34:52 <Peaker> I wonder if I should edit the wiki page to do that
07:36:34 <edwardk> peaker: ListT done right on th haskell wiki is your type =)
07:37:06 <Peaker> edwardk: yeah and there's some shared code too.. I guess they should be merged somehow
07:37:06 <edwardk> peaker: hence my earlier question. i advocated using that type for things like getContents, but most people don't want to hear it ;)
07:37:09 <McManiaC> comparing C to haskell, is there anything u know of which u can do in C but not in haskell?
07:37:10 <McManiaC> :D
07:37:39 <Peaker> edwardk: I didn't have any idea that the type was similar, I chose that instead of a Maybe type. Funny it ended up almost the same :)
07:37:49 <edwardk> McManiac: segfault because you accidentally freed memory, etc. ;)
07:38:03 <Peaker> McManiaC: The languages are so different that it might be better to ask what is shared, rather than what is different :)
07:38:14 <p_l> McManiaC: compile something completely standalone without any run time library.... but not many people would write that in C too :P
07:38:24 <edwardk> McManiac: hrmm, reason about memory consumption...
07:38:44 <Peaker> McManiaC: C lets you do your own memory management, and Haskell doesn't. C code is a sequence of side effects, and in Haskell, code is a graph of terms
07:38:47 <Saizan> a kernel, wli would say :)
07:39:25 <Peaker> it could be nice if C was replaced by a language that still let you do fine-grained resource management, but had the advanced features that were invented/discovered in the last 40 years
07:39:37 <Peaker> C++ was an attempt at that, but a pretty bad one :)
07:40:41 <Peaker> I think the idea of OO in a statically typed language like its done in C++, Java, C#, and D is pretty horrible, with the name mangling and throwing vtable ptrs into each and every value of a type (rather than grouping the vtable ptr and value only when the type is an existential, as done in Haskell)
07:41:43 <Peaker> edwardk: did you try using ListT-done-right to replace lazy I/O?
07:42:03 <Peaker> Maybe I should cabalize ListT-done-right
07:42:29 <edwardk> peaker: well, you still have a couple of effects that its not perfect for
07:42:37 <edwardk> peaker: without linear types its hard to control for those though
07:42:54 <Peaker> edwardk: examples?
07:44:15 <edwardk> sure. i can open a file, obtaining a ListT-done-right of its contents, and close the file, but now I have a whole bunch of ListT IO actions that i can't safely invoke, i'd like to reflect the linearity of that handle in the type
07:44:57 <edwardk> the altnernative is that haskell closes the file only lazily on reading the last of that ListT list
07:45:33 <McManiaC> Peaker: would you say, haskell is noticable slower than C? ive read very different opinions about that topic, some saying they're equal, haskell is outperforming C, C is faster than anything else etcpp
07:45:36 <Peaker> edwardk: or when all the references are discarded
07:46:02 <edwardk> the usual uniqueness/linear type model is to have opning the file give you a linear/unique token that you pass through to subsequent reads, and that closing the file consumes the token, thereby ending the logical thread of execution
07:46:06 <vixey> it's unnatural to assume that references will ever be disguarded
07:46:15 <vixey> you should use malloc/free if you want that distinction
07:47:08 <Peaker> McManiaC: languages don't have speeds - specific interpretations/compilations/executions of specific programs have speeds -- there are a tons of variables you need to account for before you can say anything accurate about relative speeds. As for vague statements, on uni-processor C probably outperforms Haskell
07:47:41 <Peaker> edwardk: how do linear types differ from uniqueness types?
07:48:28 <edwardk> mcmaniac: there are a lot of things that haskell can beat up on C at doing, and a lot of things that go the other way. currently i'd say there are probably 2:1 scenarios that favor C over the ones that favor the haskell approach in terms of raw performance, but the elegance is a nice factor in favor of haskell
07:49:02 <Botje> McManiaC: haskell is faster to write code in
07:49:19 <edwardk> peaker: think of linearity as a contract that you will never discard (weaken) the sole reference to this object in the future, and that you will only use it once (no contraction)
07:49:21 <Peaker> all the software engineering advantages you get from a HLL -- better productivity, better reliability, easier to read, and change, etc
07:49:24 <Botje> most of the time it's fast enough, else you have to optimize a bit
07:49:36 <edwardk> peaker: uniqueness on the other hand is a promise that you haven't contracted (shared) the reference yet.
07:49:44 <edwardk> so you can safely mutate it in place
07:50:02 <Peaker> edwardk: so I can discard a value of a unique-type?
07:50:22 <edwardk> in logical terms they are different temporal reflections of the same modality, one backward facing, and one forward facing.
07:50:26 <Peaker> edwardk: and what does "yet" mean here? Its a functional computation, right?
07:50:49 <Peaker> edwardk: oh, uniqueness is lost when you duplicate, but you are allowed to duplicate
07:50:56 <Peaker> right?
07:51:15 <edwardk> peaker: thats a separate consideration. i tend to classify uniqueness as 'unique relevant' and 'unique unrestricted', by using a richer lattice. the former is unweakenable. the latter allows weakening.
07:51:24 <edwardk> yeah
07:51:49 <Peaker> I see.  Are linear types implementable in Haskell, or a DSL?
07:51:55 <edwardk> nope
07:52:01 <edwardk> thats where clean mops up on us ;)
07:52:25 <edwardk> it requires a type system extension
07:52:33 <Peaker> Maybe you can implement a monad in which there are "linear" types?
07:52:38 <edwardk> nope
07:53:09 <edwardk> its an artifact of the strength of haskell functors. its a fundamental property of the category of Hask
07:53:11 <Peaker> Maybe its not a monad, but surely you can implement a language that has them and call it a DSL in Haskell :)
07:53:33 <vixey> but linear typechecking at compile time
07:53:48 <edwardk> yeah, but that language cannot be safely reflected using haskell variables as its variables
07:54:05 <Peaker> vixey: maybe if the combinators of this language are points-free, its possible to ensure you can only express valid linearity?
07:55:11 <Peaker> For example, you could say that a composition of arrows are passing a "linear typed value" through the arrow computation implicitly , maybe?
07:55:37 <Peaker> then - when you wanted to consume this linear-typed value, you'd have to escape the arrow and compose the arrow with some consumer?
07:55:39 <vixey> is  A -> B  short for  !A -o B ?
07:55:50 <Peaker> vixey: ?
07:56:16 <Cale> That seems right, if I understand what you mean by it.
07:56:19 <Peaker> edwardk: it can't use Haskell variables as variables, but isn't this property shared with arrows in general?
07:56:30 <edwardk> peaker: the problem is now you do variable management yourself by manually twisting environments, i'd never want to use that DSL ;)
07:56:42 <vixey> I want to  make a haskell like thing which has linear types
07:57:05 <edwardk> arrows can generally get away with it because of that ridiculously strong requirement that arr is a safe embedding of Hask.
07:57:33 <vixey> I don't even know if it's possible
07:57:34 <Peaker> edwardk: well, by arrows, I think most everyone means "arrows without arr" :)
07:57:41 <edwardk> vixey: i'm seriously considering including at least uniqueness types in kata if only because they are pretty much the only language feature i can't implement lazily in a library somewhere ;)
07:57:46 <Peaker> I think most agree that "arr" was a mistake
07:58:03 <edwardk> peaker: ok. Control.Category.Cartesian.Closed.CCC ;)
07:58:11 <vixey> edwardk, oh so you have types now? :)
07:58:14 <Peaker> edwardk: I don't know what that is :)
07:58:26 <edwardk> peaker: a module i wrote in category extras for arrows without arr
07:58:57 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian-Closed.html
07:58:58 <Peaker> edwardk: well, with arrow syntax sugar - you can "pointful" notation and points-free composition. the points-free composition can guarantee that you have linearity
07:59:05 <edwardk> relies on a bunch of other category-extras machinery
07:59:31 <vixey> :D
07:59:35 <ImInYourMonad> how do i do if x then print 10 main else print x?
07:59:36 <vixey> Category.Cartesian.Closed good name
07:59:37 <edwardk> arrow sugar relies unfortunately on the correctness of arr. i haven't managed to derive consistent CCC sugar ;)
07:59:48 <Botje> ImInYourMonad: "print 10 main" ?
08:00:23 <edwardk> i tried building up a much richer version based on wadler and company's variant on the arrow calculus
08:00:52 <ImInYourMonad> Botje:if True then do {print True;main} else print False
08:00:56 <edwardk> but when i saw it presented at MSFP i kinda lost interest, it didn't seem very robust and largely got ripped apart by the audience
08:01:00 <Peaker> edwardk: arrow sugar requires "arr"? What if you have fst, snd, and (,) arrows instead of "arr"?
08:01:05 <Botje> ImInYourMonad: well, there you go then :)
08:01:13 <Botje> print True >> main
08:02:19 <edwardk> peaker: keep in mind the proc sugar does case analysis for patterns that can fail, and all sorts of things.
08:02:45 <daf> #.
08:02:46 <Peaker> edwardk: well, what I mean is that doing points-free for linearity does not mean you give up the Haskell feel completely
08:03:05 <Peaker> edwardk: the question is whether it is possible to use arrows (or something similar) for linearity this way
08:03:06 <vixey> does it even work
08:03:36 <edwardk> peaker: juggling that question right now =)
08:04:10 <edwardk> i'm going to tentatively answer in the affirmative because i had hopes to use the arrow calculus stuff to do the same thing in kata before i wrote it off
08:04:50 <Peaker> someone on #haskell talked about languages that were completely points-free a while ago, and that with enough nice combinators, its not that bad at all
08:05:13 <edwardk> i might see if i can throw together a cheesy linear multiplative linear logic category
08:05:35 <edwardk> peaker: FORTH ;)
08:05:44 <edwardk> peaker: i disagree that its not bad
08:06:15 <edwardk> mainly because without names for variables its hard to hold a large problem in your head, and typically with pointfree code its hard to make minor refactorings.
08:06:44 <edwardk> minor structural changes make huge differences in the machinery you use to plumb it around in pointfree style
08:07:33 <Peaker> edwardk: I have never tried, so I don't know.. A good code editor would make it moot, though, I think :)
08:07:33 <ImInYourMonad> i think pointsfree looks much cleanr anbd elegant!
08:07:36 <edwardk> that said, i obviously like writing pointfree stuff
08:07:55 <edwardk> ImInYourMonad: in small-to-midsized examples I agree
08:07:58 <ImInYourMonad> can you run a repl in Yi? i have asked that several times with no asnwer
08:08:06 <Peaker> I was working on a code editor, but it was so interesting that I lost all interest at work, so I stopped writing that editor for now :-(
08:08:24 <edwardk> @. pl undo \f x y -> do x' <- x; y' <- y; return (f x' y')
08:08:25 <lambdabot> liftM2
08:08:29 <edwardk> hahah
08:08:49 <edwardk> so much for getting it to write that out in verbose form
08:09:15 <Peaker> @let both = join (***)
08:09:18 <lambdabot>  Defined.
08:09:46 <Botje> ooh
08:09:58 <Botje> using arrows AND monads in just two tokens
08:09:59 <Botje> evil :)
08:10:05 <Peaker> :)
08:10:23 <Peaker> @pl uglyBoth f (x, y) = (f x, f y)
08:10:24 <lambdabot> uglyBoth = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
08:10:24 <vixey> :t (>>>)>>>(>>>)
08:10:26 <lambdabot> forall (a :: * -> * -> *) b c d d1. (Arrow a) => a b c -> (a b d -> d1) -> a c d -> d1
08:10:32 <Peaker> @type let uglyBoth f (x, y) = (f x, f y) in uglyBoth
08:10:33 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
08:10:39 <Peaker> @type both
08:10:41 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
08:11:11 <Peaker> hmm -- is that type defaulting in action there?
08:11:25 <Peaker> oh it isn't, oops :)
08:11:41 <edwardk> peaker: the *** using , ?
08:11:51 <Peaker> nah, was just confused for a second there
08:11:54 <Botje> maybe \bot doesn't know any other arrows
08:11:58 <Botje> @instances Arrow
08:11:59 <lambdabot> (->), Kleisli m
08:12:08 <vixey> given stuff like <f,g> :: f :: x -> u, g :: y -> v=> (x,y) -> (u,v);  <f,g,h> :: (x,y,z) -> (u,v,w)
08:12:09 <edwardk> more interesting in category-extras
08:12:11 <vixey> both = <f,f>
08:12:16 <edwardk> both = join bimap
08:12:21 <Peaker> anyhow:  you can't use " (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)) " as evidence that PL "can grow ugly"  because there's obviously the nice  "both" instead :)
08:12:29 <vixey> both f = <f,f> *
08:12:30 <edwardk> now it works on Either as well ;)
08:12:36 <ImInYourMonad> how do I make a prompt? print "Brainfuck> " ; input <- getLine; does it on 2 lines
08:12:37 <vixey> <,> = bimap
08:13:05 <cnwdup> :t print
08:13:08 <lambdabot> forall a. (Show a) => a -> IO ()
08:13:20 <edwardk> and of course on all the other biendofunctors in the library
08:13:32 <cnwdup> ImInYourMonad, I'd use putStr "Brainfuck> "; input <- getLine.
08:14:20 <cnwdup> ImInYourMonad, print seems to append \n to the string.
08:14:34 <h0tzenpl0tz> when dealing with the XML-package from hackage "firstChild :: Cursor -> Maybe Cursor", how do you concat these fns? using Maybe-Monad?
08:14:49 <maltem> cnwdup: also, 'print' will quote the string
08:14:53 <vixey> yes Maybe monad
08:15:09 <h0tzenpl0tz> thanks
08:15:22 <maltem> h0tzenpl0tz: if you mean, you want the first child of the first child of ..., then yes
08:16:02 <h0tzenpl0tz> exactly. but i have no real clue how to parse xml in haskell .. i want to extract amazon dvd-metas into a custom data
08:16:17 <edwardk> vixey: you may be amused my current model for kata just has bifunctors as functors from a product category, so, nicely bifunctors are functors.
08:16:25 <edwardk> bimap f g = map (f,g) in that setting.
08:16:44 <h0tzenpl0tz> bifunctors... you guys are crazy
08:17:02 <Peaker> h0tzenpl0tz: bifunctors are probably simpler than you think :)  Anyway you might want Text.XML.Light
08:17:09 <Peaker> @package xml
08:17:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xml
08:17:10 <vixey> edwardk, so (f,g) has what type/
08:17:11 <vixey> ?
08:17:16 <h0tzenpl0tz> using it right now, thanks ;)
08:18:08 <edwardk> vixey: hah, i don't have types! ;) actually its a pair of functions, (a -> b, c -> d) -- in haskell you can get close by defining a GADT for the arrows of the category, but you can never finish modeling functors to/from it
08:18:41 <Peaker> h0tzenpl0tz: having any specific difficulty with it?
08:19:53 <h0tzenpl0tz> Peaker: trying to combine the maybe-monad with this "XML"-package. but my biggest problem is how to create functions which will fill a Meta-data with the extracted data...
08:20:27 <Peaker> h0tzenpl0tz: what do you mean by "combining maybe monad with XML package"?
08:20:40 <h0tzenpl0tz> firstChild :: Cursor -> Maybe Cursor
08:20:44 <h0tzenpl0tz> they all return Maybe
08:20:45 <Peaker> h0tzenpl0tz: you use the Maybe monad whereever it is appropriate in the code, probably having little to do with the xml package?
08:20:53 <h0tzenpl0tz> yes
08:21:12 <Peaker> h0tzenpl0tz: ah, then your functions that use them will probably also be:  Something -> Maybe SomethingElse ; and you can combine the results in various ways
08:21:18 <h0tzenpl0tz> is Maybe an instance of Monad and already implements bind and return or is the maybe-monad sth special?
08:21:26 <h0tzenpl0tz> yes
08:21:29 <Peaker> h0tzenpl0tz: Maybe is simply an instance of Monad
08:21:35 <Peaker> h0tzenpl0tz: nothing special
08:22:03 <Peaker> > lookup 3 [(1,2),(3,5),(7,9)]
08:22:05 <lambdabot>   Just 5
08:22:49 <Peaker> > let theList = [(1,3),(3,5),(5,1)] ; look x = lookup x theList in look 3 >>= look >>= look
08:22:50 <lambdabot>   Just 3
08:22:55 <Peaker> > let theList = [(1,3),(3,5),(5,1)] ; look x = lookup x theList in look 2 >>= look >>= look
08:22:57 <lambdabot>   Nothing
08:23:02 <h0tzenpl0tz> hm
08:23:03 <Peaker> h0tzenpl0tz: do you understand that?
08:23:34 <Peaker> h0tzenpl0tz: lookup is a function that returns a Maybe -- Just if it found the key in the list, or Nothing if it didn't find it
08:23:35 <h0tzenpl0tz> i do think so
08:23:55 <eu-prleu-peupeu> :)
08:24:01 <maltem> h0tzenpl0tz: For example, using do notation in the Maybe monad, you can write: do a <- firstChild something; b <- firstChild a; return (foo b)
08:24:15 <Peaker> h0tzenpl0tz: so >>= here is very useful, basically meaning: "If the computation had already failed and is Nothing, don't do anything, but if it succeeded, give the result to this function, and use its result
08:24:37 <Peaker> @src Maybe return
08:24:37 <lambdabot> return              = Just
08:24:40 <Peaker> @src Maybe (>>=)
08:24:40 <lambdabot> (Just x) >>= k      = k x
08:24:40 <lambdabot> Nothing  >>= _      = Nothing
08:24:54 <Peaker> That's ^^ most of what there is to it :-)
08:25:46 <Peaker> > let theList = [(1,3),(3,5),(5,1)] ; look x = lookup x theList in do { x <- look 1 ; y <- look x ; z <- look y ; return (z*2) }
08:25:47 <lambdabot>   Just 2
08:26:05 <h0tzenpl0tz> k, got that one
08:26:15 <h0tzenpl0tz> im trying to combine this with the io-stuff
08:26:19 <h0tzenpl0tz> thanks alot
08:27:20 <Peaker> h0tzenpl0tz: you should try to write most your code without IO, and only wrap it with a tiny bit of IO, if you can
08:27:31 <h0tzenpl0tz> tryin hard ;)
08:28:18 <h0tzenpl0tz> hm, do i pattern-match records?
08:28:18 <h0tzenpl0tz> Element {elName:: QName, elAttribs:: [Attr], elContent:: [Content],elLine :: Maybe Line }
08:28:38 <h0tzenpl0tz> +how ...
08:33:53 <gwern> h0tzenpl0tz: something like 'foo Element { elName = x } = doStuffTo x' iirc
08:34:34 <h0tzenpl0tz> thanks
08:34:58 * edwardk always finds the way that { } binds so tightly to be a little disconcerting
08:35:19 <gwern> but maybe it was actually '(Element {elName = x})'. dunno
08:35:44 <edwardk> thats the problem, i can never remember ;)
08:36:12 <ImInYourMonad> is {} for avoiding intendation sensitive code? i like to keep my linewidth < 80 chars
08:36:43 <Botje> get a bigger monitor :)
08:36:58 <edwardk> ImInYourMonad: when dealing with do, let, and other layout? yes thats its major purpose. that and easing machine generation of code
08:42:48 <dons> gwern: i wonder where this library lives: http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/
08:44:43 <gwern> dons: doesn't look like a haskell lib - c-- runtime interface?
08:46:55 <dons> gwern: well the paper says "we present a library" ...
08:46:58 <dons> the dataflow paper
08:47:16 <dons> "We present a Haskell library that makes it easy for compiler writers to implement program transformations based on dataflow analyses."
08:48:20 <gwern> dons: oh, that one. 'Our library is the workhorse of a new back end for the Glasgow Haskell Compiler. '
08:48:25 <gwern> presumably in a ghc branch then
08:48:47 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2149#a2149 <- why cant i do that?
08:49:07 <ImInYourMonad> i just want to move that black backwards so i can see it when i C-x 3 in emacs
08:49:18 <edwardk> dons: you mean c--?
08:49:31 <edwardk> http://www.cminusminus.org/
08:50:29 <edwardk> but it seemed to have fizzled. i've been on the mailing list for years and the only post i saw in the last couple has been someone asking if anyone was using it, and ramsey pointing out that the only major user was ghc and that the project as a whole hadn't gone anywhere lately
08:50:40 <h0tzenpl0tz> data Record = Record {foo :: String, bar :: Int} - how do i get an empty Record for a start?
08:50:51 <mauke> what do you mean by "empty"?
08:50:57 <edwardk> dons: or is there some particular c-- library in question in one o those papers?
08:51:03 <h0tzenpl0tz> default-valued?
08:51:54 <mauke> whatever = Record{ foo = "answer", bar = 42 }
08:52:05 <h0tzenpl0tz> ahh, sometimes its too simple
08:52:10 <h0tzenpl0tz> i dont get the record-syntax... thanks
08:52:56 <edwardk> h0tzenpl0tz: you can also define something like emptyRecord = Record [] 0
08:53:03 <edwardk> and then refine just the parts you care about
08:53:16 <edwardk> blah = emptyRecord { foo = "Hello" }
08:53:36 <h0tzenpl0tz> that looks nice. thanks
08:53:44 <mauke> blah = emptyRecord { foo = "Hello" } { foo = "Bye" } { foo = "wait, what" }
08:54:51 <edwardk> i do wish you could occasionally write record 'sections' { foo = "Hello" } would be nice without the \x  -> x { foo = "Hello" } noise.
08:55:33 <edwardk> though i see why it can't exist, etc.
08:56:18 <h0tzenpl0tz> is this to change record x's foo-property?
08:56:19 <edwardk> bar { ... } would be ambiguous, etc. but bar ({ foo = "hello" }) might be unambiguous.
08:56:28 <edwardk> yeah
08:56:54 <h0tzenpl0tz> napoleon would say: pretty sweeet
08:56:56 <edwardk> note the ({ ... }) stuff doesn't actually exist.
08:57:05 <h0tzenpl0tz> yes ;)
08:59:46 <pumpkin> moo
09:03:06 <ImInYourMonad> if I use {} cant I put it where I want?
09:03:26 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2150#a2150 <- intendation error
09:06:11 <agruman> anyone here that has a good understanding of closures and how to use them in a "interpreter" for small-sized haskell like language that would be willing to answer some questions in a pm?
09:08:34 <skorpan> in GHC, is every extension non-haskell98?
09:10:32 <vixey> agruman why don't you want to talk about it in #haskell
09:10:53 <ImInYourMonad> adding and subtracting from bytes, is there something like that built into Word8 ?
09:11:07 <wjt> > (15 - 3) :: Word8
09:11:09 <lambdabot>   12
09:11:16 <agruman> vixey, well i suppose i can, just think it might be outdrawn :O
09:11:39 <vixey> agruman I'm sure it's fine
09:11:41 <vixey> what do you wonder?
09:12:42 <agruman> the thing is i am supposed to implement a interpreter for haskell like sytax with "+-<" "\x -> ..." "if ..." and func defs "f = ..."
09:13:00 <vixey> ok
09:13:09 <BMeph_> skorpan: Yes. If it were haskell98-compatible, it wouldn't need an extension. :)
09:13:19 <agruman> and each arg to a function is a lambda expression, but i cant get my head around how to handle the args
09:13:20 <skorpan> BMeph_: thanks, just making sure ;)
09:13:46 <agruman> say i have f 1 2 wher "f = \x -> \y -> y + x"
09:14:01 <vixey> agruman, ok in Haskell we have like
09:14:21 <vixey> data Syntax = Num Integer | AddPrimitive | Lambda (Scope Syntax) | App Syntax Syntax
09:14:24 <vixey> something like that yeah?
09:14:39 <vixey> I guess it should have variables  | Var Integer
09:14:52 <vixey> and definitions  | Def String
09:15:11 <vixey> agruman so  App (App (Def "f") (Num 1)) (Num 2)
09:15:16 <vixey> for f 1 2 ?
09:16:00 <agruman> well i might have done my grammar wrong so i get a incorrect syntax tree ...
09:17:00 <agruman> since i get lambda (x) (lambda y (add x y))
09:17:17 <mauke> why is that wrong?
09:17:28 <vixey> agruman, that's of  f = \x -> \y -> y + x
09:17:34 <vixey> agruman, but I was just modelling  f 1 2
09:17:41 <vixey> are you doing this in lisp?
09:17:44 <agruman> ah ok
09:17:47 <agruman> no haskell
09:17:49 <vixey> (everything we do in Haskell works in Lisp too)
09:18:12 <vixey> agruman, I would represent it as:
09:18:30 <vixey> Lambda (Scope (Lambda (Scope (App (App AddPrimitive (Ref 0)) (Ref 1))))))
09:18:45 <andyjgill> Has anyone ported QuickCheck to ghc-6.10?
09:18:53 <vixey> aguman, using  newtype Scope a = Scope a  (from I am not a number I am a free variable)
09:19:02 <agruman> ok
09:19:19 <vixey> agruman, sorry I got the numbers wrong should be  (App (App AddPrimitive (Ref 1)) (Ref 0))
09:19:31 <vixey> agruman, but you do know what it means ? the de bruijn indices
09:19:45 <pumpkin> andyjgill: I've been using it in 6.10 for a while, so I assume so
09:19:50 <mauke> I'd use (Abs "x" (Abs "y" (App (App (Sym "+") (Sym "y")) (Sym "x"))))
09:20:01 <agruman> yes i know bruijn, atleast by name, not so familiar with it though
09:20:18 <vixey> agruman, Ref i means the variable introduces behind i binders
09:20:25 <andyjgill> pumpkin: pulling down QC 2.1.0.1 fails with Class `Exception' used as a type message.
09:20:51 <andyjgill> What version of QC are you using?
09:20:57 <agruman> from what i undestand, the way to do it is "evaluate the lambda in a special environment, with the bound variables = some value or expression"
09:21:02 <vixey> agruman: so \x -> \y -> \z -> x y z  is represented like \\\#2 #1 #0
09:21:49 <pumpkin> andyjgill: oh, weird, I'm running 1.2, which given the .cabal constraints must be using base 3 (2.1 just seems to say base >= 3)
09:21:59 <pumpkin> I assumed it was the latest :)
09:22:43 <andyjgill> Oh well. I might hack QC2 later to work with the new base, unless some else has done it already.
09:23:02 <tromp_> see http://www.augustsson.net/Darcs/Lambda/top.pdf for some example lambda calculus evaluators
09:24:05 <agruman> vixey f 1 2 in my grammar gives me "App (f) [(1), (2)]"
09:24:16 <skorpan> is there anything like ByteString which can handle unicode?
09:24:22 <dons> yes!!
09:24:24 <mauke> agruman: that looks weird
09:24:24 <dons> Data.Text
09:24:29 <vixey> agruman, seems a bit bad to do it that way but ok
09:24:53 <skorpan> @hoogle Data.Text
09:24:54 <lambdabot> module Data.Generics.Text
09:25:05 <agruman> mauke, well that might be why i cant get it right in my implementation :)
09:25:06 <dons> skorpan: check the 'text' package on hackage
09:25:30 <skorpan> thanks dons
09:25:46 <skorpan> dons: you don't happen to know if this is what yi uses?
09:25:47 <newsham> yet another lazy lc evaluator.  http://www.thenewsh.com/~newsham/x/obf.py
09:25:56 <dons> skorpan: nope, it doesn't use that
09:26:02 <ImInYourMonad> any linear algebra freakes out there? when repping ucstoemrs as a matrix should each vector of ratings be a row or a column?
09:26:17 <agruman> vixey, the reason for that is, i have f x y = x + y, in the source file, which is supposed to be "syntactic sugar" but i dont know how to change that to "f = \x \y x + y" in BNF ...
09:26:33 <pumpkin> ImInYourMonad: no real difference :P
09:26:38 <agruman> if thats possible, i would really appreciate a hint :O
09:26:50 <vixey> what do you mean BNF ?
09:27:07 <vixey> that should not interfere with code
09:27:32 <newsham> parse tree != abstract syntax tree
09:27:35 <agruman> backus naur form
09:27:50 <vixey> :t (!=)
09:27:51 <lambdabot> Not in scope: `!='
09:28:02 <agruman> we have a tool which converts bnf -> ast
09:28:02 <ImInYourMonad> pumpkin: for PCA?
09:28:23 <agruman> uses happy and some preprocessing
09:28:26 <mauke> agruman: sounds bad
09:28:29 <newsham> you need to write code that desugars afterwards
09:28:46 <pumpkin> omg watermelon, my long lost cousin
09:29:01 * watermelon is larger and juicier than pumpkin. :)
09:29:15 <pumpkin> yeah, but the juice is all water, don't fall for his false advertising
09:29:25 <agruman> so the way to go would be. my crazy ast -> desugar -> fresh new ast on the form (app app)?
09:29:52 <newsham> possibly :)
09:30:03 <pumpkin> ImInYourMonad: PCA is mostly just SVD, which doesn't care much about the interpretation of the matrix (just be consistent)
09:30:39 <agruman> ive been baning my head all read for 2 days trying to solve this in the eval code ... :(
09:31:45 <vixey> agruman, to write eval is a different problem
09:31:57 <vixey> agruman, I can show you how to write lazy eval in haskell if you want
09:32:53 <agruman> vixey, im sure you can :) the thing has always been that ive had func defs on the form "name = [args]" and not knowing what to do with it
09:33:07 <agruman> vixey, but my eval as such should be ok
09:34:30 <agruman> the easiest for me though would be if "name [args] = def" could be parsed as "name = \x -> ... -> def" by bnf
09:34:50 <vixey> just write a function that takes "name [args] = def" into "name = \x -> ... -> def"
09:35:07 <agruman> that works as well i guess
09:35:39 <agruman> but then i would need to preprocess the entire ast, since all functions might be on that form.
09:35:46 <vixey> that's fine
09:36:01 <agruman> is that how its done in haskell?
09:36:03 <vixey> that happens normally -- e.g. typechecking
09:36:10 <vixey> yes
09:36:14 <agruman> k
09:36:37 <agruman> our "language" only has ints so no typechecking is neccessary
09:36:58 <agruman> vixey, thanks alot for the help!
09:36:59 <agruman> :)
09:36:59 <watermelon> agruman: Are functions considered to be first class?
09:37:03 <mauke> wrong, it also has functions
09:37:13 <agruman> :)
09:37:16 <mauke> and possibly booleans
09:37:36 <agruman> nope, 0/1, but funcs are true though :=
09:38:20 <watermelon> What does (if 2 then 0 else 1) evaluate to?
09:38:36 <mauke> 0
09:39:03 <mgsloan2> Hello! I was just reading http://en.wikipedia.org/wiki/Structural_type_system, and noticed it says that Haskell is structurally typed.  This is incorrect, no?
09:39:33 <watermelon> Okay, so booleans are simply ints modulo the equivalence relation that partitions the ints into either {0} or everything else. :p
09:39:43 <vixey> mgsloan2, type families probably make it fit
09:39:48 <vixey> (and synonyms)
09:39:58 <mauke> toBool = (/= 0)
09:41:20 <mgsloan1> vixey - right, we could probably emulate structural typing, but it doesn't seem to be the way haskell works by default
09:41:28 <vixey> yeah
09:41:49 <mgsloan1> " Haskell, ML, Whiteoak and Objective Caml are examples of structurally-typed languages. " <- from the page
09:43:02 <watermelon> I don't think that with {data M a = N | J a}, fromJust (M a) would be valid w.r.t. to the type system.
09:43:20 <skorpan> are there any nice tutorials on GADTs out there?
09:43:36 <vixey> but if you define type M a = () :+: a
09:43:37 <watermelon> Uh, fromJust (J a)
09:44:46 <pumpkin> :o
09:44:53 <vixey> annoying
09:47:43 <Cadynum> Hello, im pretty new to haskell. i cant seem to find a proper sprintf function, only printf and hPrintf, can anyone point me in the right direction?
09:47:59 <vixey> Cadynum, printf doubles up as sprintf
09:48:12 <cnwdup> Cadynum, printf has a variable return type. printf "Hello, %s" "World." :: String should work.
09:48:21 <pumpkin> it's voodoo!
09:48:38 <cnwdup> > let str = printf ("Hello, %s." "World")::String in putStrln str
09:48:39 <lambdabot>   Not in scope: `putStrln'
09:48:46 <cnwdup> > let str = printf ("Hello, %s." "World")::String in putStrLn str
09:48:48 <lambdabot>   Couldn't match expected type `t -> String'
09:48:54 <pumpkin> putStrLn doesn't work on lambdabot
09:49:00 <pumpkin> (as an aside)
09:49:14 <cnwdup> Still I seem to have a bigger type problem. :D
09:49:27 <mauke> ("Hello, %s." "World")
09:49:28 <pumpkin> > let str = (printf  "Hello. %s" "World") :: String in str
09:49:30 <lambdabot>   "Hello. World"
09:49:37 <cnwdup> Uh, yeah.
09:49:40 <pumpkin> don't think the parens are even needed
09:49:53 <pumpkin> > let str = printf  "Hello. %s" "World" :: String in str
09:49:54 <lambdabot>   "Hello. World"
09:50:04 <cnwdup> I thought ::String would be applied to "World" only. Although you don't even need :: String, do you?
09:50:11 <cnwdup> > let str = printf "Hello, %s." "World" in str
09:50:13 <lambdabot>   Add a type signature
09:50:17 <cnwdup> Okay.
09:50:26 <Cadynum> wow, thanks for the instant response guys!
09:50:30 <pumpkin> I think lambdabot just calls show on the result
09:50:49 <watermelon> @type printf
09:50:51 <lambdabot> forall r. (PrintfType r) => String -> r
09:51:05 <Cadynum> very nice and helpful :)
09:51:06 <pumpkin> @instanecs PrintfType
09:51:07 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
09:53:06 <pastah> so i have my own datatype for evaluating rules... somewhat like this: data Rule a = And (Rule a) (Rule a) | ... | TRUE | FALSE | Atom a
09:53:24 <pastah> and i need to do reduction on a rule tree
09:53:28 <pumpkin> http://www.mathematik.uni-marburg.de/~eden/?content=implem_howto#compile wants GHC 5!?!?!
09:53:42 <pastah> so a given is (/\) :: Rule a -> Rule a -> Rule a
09:54:03 <pastah> but what ascii combitanion can i use to make it look like the negation sign?
09:54:05 <ImInYourMonad> http://en.wikipedia.org/wiki/Brainfuck <- there is no rule for how to create a Byte, when accepting a Byte should all bits just be set to zero then?
09:54:20 <pumpkin> creating/accepting?
09:54:30 <mauke> ImInYourMonad: huh?
09:54:32 <pumpkin> it works on a fixed buffer
09:54:34 <pastah> (-|) is on example, but will it look good? (-,) might not even typecheck
09:54:40 <pastah> any input is appreciated :)
09:54:58 * repnop doesn't get why people care about bf
09:55:04 <repnop> befunge at least is interesting ;)
09:55:05 <ImInYourMonad> pumpkin: fixed buffer?
09:55:07 <pumpkin> ImInYourMonad: oh, you mean the initial state of the machine?
09:55:10 <ImInYourMonad> yes
09:55:25 <pumpkin> people tend to start at 0, as far as I know
09:55:57 <pumpkin> ImInYourMonad: it does specify that on the page you linked btw
09:56:08 <pumpkin> "The brainfuck language uses a simple machine model consisting of the program and instruction pointer, as well as an array of at least 30,000 byte cells initialized to zero;"
10:00:12 <ImInYourMonad> lol yeah i need to read and think more before i aks, IRC makes it to easy to be stupid :)
10:00:25 <pumpkin> :)
10:00:33 <pumpkin> how did you move from PCA to BF btw?
10:00:51 <ImInYourMonad> im doing pca in brainfuvck like duh ob
10:00:54 <ImInYourMonad> v
10:00:55 <pastah> plz someone, give me ASCII ideas of representation for the negation symbol
10:00:57 <pumpkin> lol
10:01:02 <watermelon> Implement a PCA transform in Brainfuck. :)
10:01:19 <pastah> (-|) is the backwards "is provable in"-sign
10:01:25 <pastah> which seems kinda wrong here...
10:01:42 <ddarius> pastah: not
10:02:00 <pastah> ddarius: sorry, fuzzy logic here
10:02:01 <ddarius> If you don't have to worry about numbers, use -
10:02:03 <watermelon> x `nand` x
10:02:29 <pastah> and there are modules where you will want to access both Prelude.not and RuleStuffz."not"
10:02:29 <watermelon> 0 -
10:02:54 <pastah> so something else is required
10:04:08 <pumpkin> -- vs. - :P
10:04:15 <pastah> haha
10:04:22 <ddarius> pastah: You do know that you can't define unary operators in Haskell, right?
10:04:59 <pastah> oh shit
10:05:03 <pumpkin> :P
10:05:11 <pastah> that kinda sucks
10:05:18 <pumpkin> you can define postfix operators in ghc
10:05:30 <pumpkin> but that doesn't help you for -
10:05:46 <pastah> well, it'll just be notR :: Rule a -> Rule a then
10:07:58 <watermelon> Can you define ternary operators in Haskell?
10:08:33 <mauke> sort of, if you call them as (a ? b) c
10:09:03 <ddarius> watermelon: You can only define binary operators.  You can fake a variety of other things with sufficient cleverness.
10:09:18 <sjanssen> a ? b .: c -- is also possible
10:09:34 <pastah> sjanssen: source?
10:10:31 <sjanssen> pastah: I can't remember where I first saw it
10:10:42 <sjanssen> pastah: you just have to give ? and .: the right fixity
10:10:47 <sjanssen> @google ternary operator haskell
10:10:48 <ddarius> There are two different ways of defining it depending on which you give the higher precedence.
10:10:49 <lambdabot> http://www.haskell.org/haskellwiki/Ternary_operator
10:10:49 <lambdabot> Title: Ternary operator - HaskellWiki
10:10:49 <doserj> i like a ? b $ c
10:10:54 <pastah> (?) :: Bool -> (a,a) -> a
10:11:09 <pastah> (.:) a -> a -> (a,a)
10:11:39 <pastah> of course you need to do it
10:11:48 <pastah> b ? (x .: y)
10:11:59 <ddarius> pastah: That's one way if you have (.:) have higher precedence.  There's another way with (?) having higher precedence.
10:12:04 <pastah> anything else seems, well, less logical
10:12:49 <sjanssen> (?) :: Bool -> a -> (a -> a)
10:13:04 <sjanssen> (.:) :: (a -> a) -> a -> a
10:13:40 <centrinia> @type ($)
10:13:42 <lambdabot> forall a b. (a -> b) -> a -> b
10:14:18 <sjanssen> yes, ($) will work too
10:14:34 <proq> is there a web framework for haskell?
10:14:44 <repnop> afaik yes
10:14:51 <pumpkin> lots
10:14:58 <pumpkin> well, two at least
10:15:01 <raf_kig> :-)
10:15:06 <pumpkin> turbinado and happs/happstack
10:15:11 <ddarius> WASH
10:15:22 <pumpkin> fine, I'll go take a shower
10:15:25 <ddarius> Then you can use CGI or FastCGI
10:16:03 <centrinia> Isn't WASH a little old?
10:16:13 <dons> needs to be put on hackage
10:16:16 <dons> yes, it is old
10:16:21 <ddarius> centrinia: It's not as old as Haskell, but you use that too.
10:16:41 <dons> turbinado and happstack are the very active ones now, wash has been used commercially in the past 2 years, but isn't active
10:16:51 <centrinia> Isn't the last major update of WASH older than the last major update of Haskell?
10:17:00 <centrinia> Wait, I should have said GHC.
10:17:02 <dons> s/Haskell/GHC/
10:17:04 <eu-prleu-peupeu1> anyone here uses fieldtrip ?
10:17:32 <koeien> proq: Happstack is a bit more advanced/radical compared to Turbinado, which is more rails-like
10:17:34 <sjanssen> eu-prleu-peupeu1: I went to a museum back in elementary school
10:17:43 <pumpkin> lol
10:17:50 <eu-prleu-peupeu1> :P
10:18:02 <eu-prleu-peupeu1> anyone here uses Graphics.FieldTrip ? :)
10:19:11 <eu-prleu-peupeu1> its a gfx tool
10:20:12 <centrinia> Is there a relational database management system that implements typeclasses and algebraic data types for its field values?
10:20:34 <Botje> i think most of them rely on implicit conversions
10:20:40 <Botje> which of course fails hard sometimes :)
10:22:53 <mauke> @bot
10:22:53 <lambdabot> :)
10:22:53 <lunabot>  :)
10:23:11 <centrinia> @botsmack
10:23:12 <lambdabot> :)
10:23:12 <lunabot>  :)
10:23:19 <centrinia> That's weird.
10:24:51 <eu-prleu-peupeu> oh well, ill just whine at the fieldtrip mailing list
10:38:56 <Eelis> eelco: hm, will there be an option to vote for "no logo" in the upcoming poll?
10:39:36 <Eridius> ?t <$>
10:39:36 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:39:42 <Eridius> @type <$>
10:39:43 <lambdabot> parse error on input `<$>'
10:39:49 <Eridius> @type (<$>)
10:39:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:40:04 <Eridius> @type (.)
10:40:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:40:53 <Eridius> @hoogle (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
10:40:53 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
10:40:57 <Eridius> bah
10:41:08 <Eridius> @type liftA2 (.)
10:41:10 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
10:41:23 <Eridius> is there no built-in equivalent?
10:42:15 <h0tzenpl0tz> could somebody give me a hint which style to use? Maybe-Monad bind & do-notation vs. simple case-of: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2151#a2152
10:43:27 <h0tzenpl0tz> because actually i just want a list back. i dont want to stay in the maybe-monad ....
10:44:05 <h0tzenpl0tz> i just want to use the monad-functions of maybe to compose the xml-traversal-functions
10:45:07 <h0tzenpl0tz> additional problem is that all multiple-result xml-functions return a list and no maybe. so its always mixing. i cant find a smart way to compose these Maybe + [] xml-functions
10:45:07 <DCEmu_user01> Come visit my forum where you can watch the newest movies online for FREE: http://movieparadise.informe.com/
10:45:23 <Eridius> yay spamming
10:45:31 <mauke> fcuk
10:45:45 --- mode: ChanServ set +o mauke
10:45:49 * Eridius cheers
10:45:59 <mauke> @hoogle Maybe a -> [a]
10:46:00 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:46:00 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
10:46:00 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:46:30 <h0tzenpl0tz> hm
10:47:14 <Gracenotes> @instances Applicative
10:47:14 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:47:18 <Gracenotes> but but but
10:47:34 <Botje> sigh
10:47:38 <Botje> that informe.com site isn't much better
10:47:44 <Botje> the most active blogs are all spam :(
10:47:45 --- mode: mauke set -o mauke
10:47:45 <Gracenotes> @instances Control.Applicative.Applicative
10:47:46 <lambdabot> ((,) a), ((->) a), IO, Maybe, []
10:48:02 <h0tzenpl0tz> foobar :: Maybe Element -> [Result] - so you cant use the Maybe-Monad. whats the proper way to compose those xml-functions now?
10:48:37 <Gracenotes> h0tzenpl0tz: well, Nothing means an empty list
10:48:48 <idnar> @type maybeToList
10:48:50 <lambdabot> forall a. Maybe a -> [a]
10:48:51 <Gracenotes> I'd assume
10:49:03 <Gracenotes> Just means that you can calculate the results as appropriate
10:49:08 <Eridius> Gracenotes: I'm pretty sure the type system *requires* that Nothing be the empty list
10:49:13 <Eridius> well, assuming a non-pathalogical implementation
10:49:27 <paczesiowa> h0tzenpl0tz: what xml lib?
10:49:32 <idnar> Eridius: huh?
10:49:49 <Gracenotes> Eridius: if the only way to make a Result is with an Element, I suppose.
10:50:06 <h0tzenpl0tz> the light one: http://hackage.haskell.org/packages/archive/xml/1.3.3/doc/html/Text-XML-Light-Cursor.html#3
10:50:08 <Eridius> idnar: given the type of maybeToList, the only possible output from the input of Nothing is the empty list (assuming non-pathalogical - theory you could use error instead)
10:50:24 <idnar> oh, yes
10:50:34 <Gracenotes> Eridius: I don't mean in general, I mean in his specific function
10:50:36 <Eridius> Gracenotes: given that the type of the output depends on the type of the input, that means the contents of the output list *must* come from the input. So if the input is Nothing, the only possible output is []
10:50:39 <idnar> I thought we were discussing foobar :: Maybe Element -> [Result]
10:50:49 <Gracenotes> obviously it's impossible for a parametrically polymorphic function
10:50:53 <Eridius> oh
10:51:06 <Gracenotes> well, unless you return undefined, not terribly useful though ^_^
10:51:10 <Botje> there
10:51:21 <Botje> i reported that spammer at informe.com :)
10:51:23 <Eridius> I was responding to your comment that you'd assume Nothing means an emptyl ist
10:51:35 <Gracenotes> Eridius: oh. Yep, I mean in foobar
10:51:52 <h0tzenpl0tz> i have filterChild -> Maybe Element and filterChildren -> [Element]. i want to build a function which returns a [SomeResultRecord]. internally i want to combine the different xml-filter methods. so i thought about the maybe-monad, doing the filter-out-Nothing work
10:52:10 <Gracenotes> depending on his implementation it could mean something else.
10:52:18 <h0tzenpl0tz> then im trapped in the maybe monad and cant return [SomeResultRecord] as it has to be Maybe [...]
10:52:36 <Eridius> h0tzenpl0tz: why would you be trapped?
10:52:37 <mauke> you don't have to restrict yourself to the monad interface
10:52:40 <h0tzenpl0tz> so i cant figure out a way to use the neat Maybe-functionality *and* returning something non-Maybe
10:52:41 <Eridius> the Maybe monad is not like the IO monad - you can exit it
10:52:50 <h0tzenpl0tz> how??
10:52:59 <Eridius> err, by using a non-monadic function?
10:53:04 <Gracenotes> @src findIndices
10:53:04 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
10:53:06 <Eridius> like, say, maybe, or maybeToList, or fromJust, etc
10:53:06 <Gracenotes> @src findIndex
10:53:07 <lambdabot> findIndex p     = listToMaybe . findIndices p
10:53:13 <h0tzenpl0tz> oh
10:53:19 <Gracenotes> see those sources? It does a similar thing that you're doing
10:53:19 <h0tzenpl0tz> that was my fault
10:53:27 <Gracenotes> findIndices gets all the indices
10:53:35 <Gracenotes> findIndex gets the first result, if any
10:53:50 <h0tzenpl0tz> and then its packed into a Just to further work in the may-monad?
10:53:54 <Gracenotes> so that's a relatively sane (and reusing-code-way) to do it :)
10:54:02 <h0tzenpl0tz> thanks alot
10:54:25 <Eridius> h0tzenpl0tz: monads are not some mysterious thing
10:54:37 <Eridius> only the IO monad is special
10:54:44 <Gracenotes> okay. Yay specifications :D
10:54:53 <Eridius> every other monad is just extra functionality added to an existing type
10:54:54 <omnihil> is it possible to define a monad that can't be exited like IO?
10:55:15 <Eridius> yeah. have your monad be on a data whose implementation isn't exported
10:55:22 <mauke> omnihil: yes, hide the implementation of your type and don't export anything that lets you get at the internals
10:55:26 <Eridius> so once the user's data is wrapped in your datatype, they can't unwrap it
10:55:33 <mauke> in fact, you don't have to hide anything
10:55:48 <mauke> data Om a = Nom
10:55:56 * Eridius chuckles
10:56:09 <mauke> instance Monad Om where return _ = Nom; Nom >>= _ = Nom
10:56:12 <Eridius> I don't think throwing away user data is quite the same as not letting you exit the monad..
10:56:18 <Gracenotes> ah, the unary monad :)
10:56:37 <mauke> it's the same thing because you can't go Om a -> a
10:56:44 <Eridius> fair enough
10:56:48 <Gracenotes> if only () had an extra type parameter, then imagine all the uses!
10:56:56 <Eridius> OMG
10:57:05 <Eridius> it would be as revolutionary as Nullity was for mathematics!
10:57:55 <Gracenotes> more revolutionary!
10:58:18 <Eridius> impossible! Nullity solved the division-by-zero problem, what could be more revolutionary than that?
10:59:05 <pastah> @paste
10:59:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:59:21 <Gracenotes> Eridius: psssh. If dividing by zero can cause life support to crash and the patient to die, surely the () monad will completely heal them of their diseases
10:59:42 <Eridius> pfft
11:02:14 <h0tzenpl0tz> listToMaybe :: [a] -> Maybe a. But I need listToMaybe :: [a] -> Maybe [a]  to compose filterChild -> Maybe Element and filterChildren -> [Element]  ...
11:02:14 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2153 <-- if someone could tell me how to get the test running i would be grateful
11:02:22 <pastah> (running = working)
11:02:54 <mauke> h0tzenpl0tz: huh? [a] -> Maybe [a] is just ... Just
11:03:41 <Gracenotes> @type (.)
11:03:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:03:43 <h0tzenpl0tz> mauke: ok, then i dont get it all. if i have foo :: Maybe Result and bar :: [Result] - how do i combine them neatly without checking the Nothing-cases all the time?
11:03:47 <idnar> h0tzenpl0tz: why do you want Maybe [a]?
11:03:59 <mauke> h0tzenpl0tz: what result type?
11:04:08 <idnar> h0tzenpl0tz: if you compose (filterChild -> Maybe Element) with listToMaybe, you get filterChild -> [Element]
11:04:26 <h0tzenpl0tz> filterChildName :: (QName -> Bool) -> Element -> Maybe Element
11:04:28 <h0tzenpl0tz> filterChildrenName :: (QName -> Bool) -> Element -> [Element]
11:04:39 <h0tzenpl0tz> i want to combine those two (traversing an xml)
11:04:42 <idnar> and then you just work with lists
11:04:51 <h0tzenpl0tz> hm, thats an option too
11:05:09 <idnar> although listToMaybe . filterChildName is probably the same as take 1 . filterChildrenName
11:05:36 <h0tzenpl0tz> semantically it should be
11:06:24 <h0tzenpl0tz> hm, i dont find a smart way to traverse this crappy xml
11:06:52 <skorpan> can this sort of code be generalized? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2155#a2155
11:06:52 <pastah> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2153#a2154 <-- ok, sorry, this loads... could someone please take a look at this
11:07:48 <pastah> skorpan: quit your wining and look at my code
11:07:58 <skorpan> tl;dr
11:08:32 <pastah> skorpan: fu plz?
11:08:46 <pastah> seriously, i need to get it running
11:08:58 <skorpan> you're asking the wrong person anyways :P
11:09:08 <pastah> it's just boolean reduction, nothing to be afraid of
11:09:26 <vixey> pastah, stop being so rude
11:09:34 <skorpan> vixey: he's a friend of mine, he can be rude to me
11:09:42 <vixey> oh
11:10:01 <vixey> it looked very mean from my point of view
11:10:10 <skorpan> pastah: so what does the code do now?
11:10:15 <skorpan> "failz0r"?
11:10:23 <eu-prleu-peupeu> okey, ill just bombard the fieldtrip mailing list now :/
11:10:55 <skorpan> pastah: are you sure it should succeed? a quick look at (>>=) tells me it shouldn't
11:11:06 <pastah> well, TRUE >>= notR should give FALSE
11:11:11 <pastah> at least that's the idea
11:11:17 <eu-prleu-peupeu> is there a search engine for haskell function names ? i want to know which module certain function names belong to...
11:11:22 <Eridius> hoogle
11:11:32 <skorpan> pastah: but now it reads FALSE >>= notR which will be reduced to FALSE according to reduceRule
11:11:32 <centrinia> @hoogle (a -> r) -> r
11:11:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:11:33 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
11:11:33 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
11:11:51 <pastah> skorpan: yeah
11:11:59 <pastah> but i did Not pumpkin-> (reduceRule p (notR . strat))
11:12:18 <skorpan> pastah: what?
11:12:19 <pastah> correction:  Not p -> (reduceRule p (notR . strat))
11:12:31 <pastah> skorpan: Tab-completion spooking in weechat
11:12:48 <skorpan> pastah: but reduceRule won't go down that path
11:13:01 <pastah> but still, i don't know how to formulate it so that TRUE/FALSE just doesn't fall through
11:13:07 <skorpan> FALSE >>= notR becomes reduceRule FALSE notR which becomes FALSE
11:13:17 <pastah> (sorta like Nothing in the maybe monad)
11:13:23 <eu-prleu-peupeu> not that
11:13:30 <skorpan> pastah: do you see what i mean?
11:13:32 <pastah> skorpan: so how should i formulate this?
11:13:34 <pastah> skorpan: ye
11:13:36 <pastah> s
11:13:55 <pastah> pattern match (Not TRUE) -> FALSE ...
11:14:19 <skorpan> i don't get it.  what do you want to do?
11:14:27 <eu-prleu-peupeu> hayhoo does what i want :D
11:14:28 <eu-prleu-peupeu> really sweet
11:14:33 <pastah> i want the test to succeed
11:14:53 <pastah> which is a representation of the desired behaviour
11:15:07 <skorpan> you mean you want FALSE >>= notR to evaluate to TRUE?
11:15:08 <pastah> or maybe not ?
11:15:14 <pastah> yeah
11:15:21 <pastah> maybe that's the wrong approach
11:15:32 <skorpan> i think you should start looking at your definition of (>>=)
11:15:46 <skorpan> or to be precise, look at reduceRule
11:15:50 <pastah> anyway, what i REALLY want is for reduceRule to actually invert TRUE/FALSE
11:16:37 <skorpan> but that's notR?
11:16:57 <pastah> skorpan: yeah, you're right...
11:17:17 <pastah> (ulf gave me the idea of using monad here, hence the confusion)
11:17:18 <skorpan> i suppose you want FALSE >>= notR to be equivalent to TRUE
11:17:26 <pastah> yeah
11:17:32 <true\false> pastah: Stop hilighting me!
11:17:40 <skorpan> but reduceRule doesn't currently do that... so fix that :)
11:17:42 <pastah> true\false: hahahaha
11:18:01 <saml> > (>>) > (<<) where >> = 0; << = 0
11:18:03 <lambdabot>   <no location info>: parse error on input `>>'
11:18:07 <Eridius> @src partition
11:18:07 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
11:18:07 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
11:18:07 <lambdabot>                               | otherwise = (ts, x:fs)
11:18:22 <pastah> true\false: very high "blame yourself"-factor on having a nick like that in a programming related channel
11:18:36 <pastah> skorpan: annotate?
11:18:50 <true\false> pastah: Bahh
11:19:11 <skorpan> pastah: i don't know the specific solution, but it's obvious that reduceRule doesn't do what you want it to do
11:19:43 <skorpan> it seems that reduceRule acts as a lazy (&&) for TRUE and FALSE
11:19:44 <Gracenotes> @type partition
11:19:46 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:19:46 <pastah> skorpan: nc?
11:19:52 <skorpan> pastah: second floor
11:19:56 <pastah> coming...
11:20:04 <Gracenotes> :O  O:  :O  O:  :O  O:  :O  O:
11:20:12 <Eridius> if I need to consume the entire list at once (i.e. not be lazy), does it make any particular difference if I use foldl or foldr?
11:20:47 <Gracenotes> depends on whether the consuming needs to start from the left or from the right :)
11:21:22 <Eridius> I'm doing String -> String, but the first character on my output string depends on the entire contents of the intput string
11:21:23 <Gracenotes> if the list isn't infinite, then there *is* a right end of the list (the last element), and foldr can be used
11:21:41 <Mauke> lol wut
11:22:21 * Gracenotes parses this situation with his LALR-skates
11:22:33 <Eridius> I suppose I may as well use foldr, no particular need for foldl, I was just curious if it made any difference here
11:22:51 <Gracenotes> what kind of string processing are you doing?
11:23:41 <Eridius> I need to take a string that's a combination of digits and the minus sign, such as "32-4-21-" and pull all the minus signs to the front, then coalesce them so that two minus signs cancel each other out
11:23:55 <Eridius> I was going to do it with partition + a custom coalesce function, but I realized it's probably simpler just to fold over the list
11:24:29 <Eridius> oh hrm, it actually does make a difference if I use foldr or foldl -if I use foldl I have to use ++ instead of :
11:24:33 <Eridius> ..I think
11:25:04 <Gracenotes> if you're constructing a list with a fold, foldr is generally more convenient if you want to keep the order
11:25:12 <Eridius> yeah
11:25:24 <Eridius> I've just never had a use for foldl, so I was wondering when I'd need it ;)
11:25:29 <Eridius> of course, I always turn lists into other lists
11:26:10 <pchiusano> hello
11:26:27 <Gracenotes> greetings
11:26:28 <travisbrady> Gracenotes: is foldr preferable when it can be used?
11:27:17 <pchiusano> I am thinking of using haskell for some low-level programming... I'm not sure if this is a good idea
11:27:27 <vixey> doesn't make much sense
11:27:31 <vixey> Haskell is pretty high level
11:27:46 <Gracenotes> when the folding operation is associative, I tend to like left folding... foldl', that is
11:27:52 <Eridius> what sort of low-level programming?
11:28:05 <pchiusano> writing a compiler / language runtime
11:28:21 <Gracenotes> (if it's not associative, then foldl and foldr do rather different things)
11:29:08 <gwern> @faq
11:29:09 <lambdabot> The answer is: Yes! Haskell can do that.
11:29:35 * Eridius chuckles
11:30:25 <slint1> for example there is a perl implementation in haskell called pugs and ghc is written in haskell
11:30:53 <vixey> GHC Haskell Compiler is written in Haskell
11:30:57 <vixey> GHC Runtime is written in C
11:31:29 <trygvis> pchiusano: compilers/runtimes are not low-level programming
11:31:36 <vixey> runtime might be
11:31:38 <Gracenotes> C-C-C-C-C-CURRYBREAKER
11:31:40 <vixey> compile needn't be
11:32:03 <trygvis> I guess
11:33:05 <ImInYourMonad> what is the difference between newtype and type? type is just for renaming complex structures to something familiar kind of, but what does newtype do?
11:33:06 <pchiusano> hang on
11:33:08 <MyCatVerbs> Gracenotes: associative is not a particularly good minimum critereon. Strict versus lazy producer is.
11:33:27 <MyCatVerbs> ImInYourMonad: newtype is like a restricted version of data. Only one constructor allowed, only one field allowed.
11:33:50 <Eridius> Gracenotes: ++
11:34:12 <Gracenotes> MyCatVerbs: although, there is thet curious case of foldr (:)
11:34:14 <ImInYourMonad> mcv: ok
11:34:15 <Eridius> ImInYourMonad: newtype produces a new type, but doesn't change the underlying representation. So it only exists at the typing level
11:34:15 <Gracenotes> -t
11:34:28 <MyCatVerbs> ImInYourMonad: and the semantics with pattern matching are subtly different: an attempt to pattern match on a newtype'd constructor *always* succeeds, no matter what, whereas matching against a data constructor will fail if the thing being matched against is bottom.
11:34:45 <Eridius> really? huh
11:34:58 <Eridius> I suppose that makes sense, given that you're just unwrapping the type
11:35:02 <MyCatVerbs> ImInYourMonad: (but that's a really esoteric difference, which I almost guarantee that you won't care about, ever. It's just like that to make the optimizer's job a little easier, AFAIK. :)
11:35:20 <BONUS> also it helps you with some monadic laws and stuff
11:35:24 <BONUS> when bottom is concerned
11:36:00 <Eridius> MyCatVerbs: it actually makes sense given that once you're past typing, the newtype constructors disappear entirely
11:36:13 <Eridius> so a pattern match on MyNewType foo would just become a match on foo
11:36:46 <Gracenotes> MyCatVerbs: anyway, surely associative (on a finite list) -> can use either foldl or foldr, but not associative -> more specific criteria
11:37:17 <Eridius> Gracenotes: well, foldr lets you preserve laziness
11:37:25 <Eridius> though actually I suppose that requires a non-associative operator
11:38:33 <MyCatVerbs> Gracenotes: yes. But associative is *not* enough to declare that foldl is necessarily a better idea!
11:38:43 <MyCatVerbs> Er, associativity.
11:39:13 <Gracenotes> yeah.
11:40:37 <koeien> Eridius: what about 'and' ?
11:40:44 <koeien> or (&&), i mean
11:41:14 <Eridius> ok, fair enough
11:41:57 <Eridius> though that still isn't lazy, since it consumes the entire list to produce an output
11:42:12 <Eridius> laziness requires an associative constructor
11:42:18 <koeien> > foldr (&&) (False:repeat True)
11:42:20 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Bool]'
11:42:25 <koeien> > foldr (&&) True (False:repeat True)
11:42:26 <lambdabot>   False
11:42:33 <Eridius> hmm
11:42:44 <Eridius> ok, I clearly am not awake
11:42:48 <koeien> > foldl (&&) True (False:repeat True) -- fails to terminate
11:43:11 <lambdabot>   thread killed
11:43:33 <vixey> > foldl (||) False (True:repeat False) -- fails to terminate
11:44:02 <Mauke> foldl _ _ infinite_list fails to terminate
11:44:17 <mle> try using and and or instead
11:44:30 <koeien> foldl (\_ _ -> 37) True (repeat False)
11:44:34 <koeien> > foldl (\_ _ -> 37) True (repeat False)
11:44:42 <mle> > and $ False : repeat True
11:44:56 <koeien> mle: yeah sure, but was trying to make a point about associativity/laziness/infinite lists
11:45:24 <mle> foldl can't shortcut like and.
11:45:37 <koeien> yep. foldr can
11:45:40 <Eridius> @src and
11:45:44 <koeien> probably and = foldr (&&) True
11:45:52 <Eridius> yeah, I just wanted to see if lambdabot knew
11:45:58 <mle> @src and
11:46:12 <koeien> ?bot
11:46:37 <mle> your last foldl seems to have caused great angst in lambdabot
11:46:39 <Gracenotes> @src foldl
11:46:48 <koeien> mle: yep
11:46:55 <Gracenotes> , src foldl
11:46:57 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
11:46:57 <koeien> :(
11:47:04 <Gracenotes> ,src foldl
11:47:05 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
11:47:07 <aempirei> man i went to a haskell users group last nite in san francisco
11:47:08 <aempirei> i must say
11:47:10 <aempirei> that was funny
11:47:20 <koeien> in what sense?
11:47:53 <Eridius> aempirei: haskell users group in SF? Damnit, I should be paying attention to Meetup
11:48:14 <Eridius> it keeps bugging me each week about stuff, and I always ignore it
11:48:21 <Eridius> oh hrm, it doesn't have any hits for "haskell" anyway
11:48:25 <aempirei> i have no idea
11:48:28 <aempirei> where it was posted
11:48:36 <Eridius> was it interesting?
11:48:40 <aempirei> well
11:48:42 <aempirei> WELL
11:48:57 <aempirei> it was novel
11:49:00 <Eridius> o_O
11:49:22 <Eridius> what does that mean?
11:50:09 <aempirei> it was maximally nerdy but over all it was neat
11:50:31 <Deewiant> Opinions requested! Adding a newtype with a documentation-friendly name like "This_Is_Internal" to hide internal stuff from Haddock in instance declarations: good or bad idea? (Not sure if there's runtime overhead.)
11:50:42 <Gracenotes> s/but/and/ :)
11:51:10 <koeien> Deewiant: newtype does not incur runtime overhead generally
11:51:18 <koeien> maybe in cross-module optimization, don't know about that
11:51:43 <Deewiant> koeien: Yes, I would hope not, which is why I'm asking for opinions instead of rejecting it outright. ;-)
11:52:52 <Deewiant> The alternative would be to say something like "ignore the 'foo' instance, it's internal" or "read the 'foo' instance as 'bar'" in the doc for the data type.
11:53:39 <Deewiant> (I actually have both of those cases here: an internal class and an external class with internal constraints.)
11:54:02 <Eridius> aempirei: is it going to be a regular thing?
11:54:52 <Eridius> koeien: newtypes disappear after the typing stage. I would optimization occurs after that, no?
11:55:04 <ImInYourMonad> SO my Brainfuck runtime has a tape which is a 30K elem array. then a pointer would be an index and the value there?
11:55:05 <Eridius> although I suppose cross-module maybe a newtype simply turns opaque
11:55:12 * Eridius doesn't know much about how haskell compiles
11:55:16 <ImInYourMonad> bottom?
11:55:25 <koeien> Eridius: yeah probably
11:55:26 <Eridius> ImInYourMonad: the tape should be initialized to 0
11:55:32 <lament> a nice Haskelly way to model the brainfuck tape is with a zipper
11:55:34 <koeien> Eridius: i'm not a ghc hacker though
11:56:33 <ImInYourMonad> Eridius: how do you mean inited to zero? i create a 30K array where each is elem is a Byte set to zero
11:56:50 <Eridius> yes. You said bottom. That doesn't make much sense
11:56:58 <Eridius> it should be a list of 0's instead
11:58:20 <Gracenotes> ImInYourMonad: again, you can make a zipper with (replicate 30000 0) ;)
11:58:22 <skorpan> can this sort of code be generalized? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2155#a2155
11:58:38 <ImInYourMonad> yes i asked what people meant with bottom and types
11:58:45 <Deewiant> skorpan: generalized how?
11:59:00 <Gracenotes> since an array isn't lazy, may as well do listArray (0, 29999) (repeat 0)
11:59:13 <glguy> array isn't lazy?
11:59:14 <Gracenotes> which creates a huge array from an infinite list of zeroes
11:59:14 <ImInYourMonad> but why zeros?
11:59:29 <skorpan> Deewiant: e.g. suppose i want several functions like that one, with the same type, but different constructor.
11:59:37 <Deewiant> skorpan: type class.
11:59:57 <Gracenotes> ImInYourMonad: what else would it be?
12:00:04 <Eridius> can you not do something like Zip [0..] [0..] ?
12:00:09 <skorpan> Deewiant: i don't see what you mean... could you explain?
12:00:10 <Eridius> to have an infinite tape
12:00:13 <Gracenotes> Eridius: that's what I suggested :)
12:00:19 <Eridius> well actually, brainfuck starts at the "start", doesn't it?
12:00:23 <glguy> brainfuck works well with a zipper
12:00:23 <Eridius> so maybe Zip [] [0..]
12:00:25 <Gracenotes> ImInYourMonad doesn't seem to like zeros though
12:00:34 <skorpan> Deewiant: i should make a type class and instantiate it for that type?  won't the instance have the same boilerplate code like the one i just pasted?
12:00:36 <glguy> you'd want [0,0..]
12:00:38 <Gracenotes> er, zippers, that is
12:00:49 <Eridius> glguy: oh heh, you're right
12:00:55 <glguy> and you'd want the current element, too
12:00:59 <MyCatVerbs> Eridius: you don't want to use a singly-linked list for Brainfuck, because the head of the tape can move to the *left* as well as right. Hence a zipper.
12:01:01 <Eridius> ImInYourMonad: because the brainfuck tape contains integers
12:01:05 <Deewiant> skorpan: For instance, have a 'class Foo c where toMaybe :: c a -> Maybe a' and then spec x t = maybe False (x ==) (toMaybe t)
12:01:10 <Gracenotes> <Gracenotes> again, you can make a zipper with (replicate 30000 0) ;) <- if you want something finite
12:01:11 <Eridius> MyCatVerbs: yes, that's what Zip is
12:01:19 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2157#a2157 <- there is what i ahev so far, some of it is jsut sutff i tried out like validate for example.
12:01:23 <Gracenotes> I suggested this yesterday :)
12:01:26 <glguy> the values in brainfuck are 0-255
12:01:30 <MyCatVerbs> Eridius: oh, fie. I read that as zip. Sorry.
12:01:37 <Eridius> heh
12:01:42 <Gracenotes> who listens to me anyway...
12:01:44 <Eridius> Zip is the data constructor for Data.List.Zipper.Zipper
12:01:46 <Deewiant> skorpan: Or whatever abstraction you want to use. Maybe is simple, mapping your single 'Special' to a Just and everything else to Nothing but might not make sense for all your cases.
12:01:48 <Eridius> from the listzipper package
12:01:56 <ImInYourMonad> "the cells are 8-bit bytes, "
12:02:05 <Eridius> ImInYourMonad: ok so Word8s then?
12:02:21 <Eridius> or you could make an expanded Brainfuck that used Word32s and could input/output unicode ;)
12:02:27 <Deewiant> skorpan: Perhaps spec x t = t == Special x?
12:02:36 <Eridius> or you could even use Char
12:02:42 <Eridius> and turn + and - into succ and pred
12:03:42 <ImInYourMonad> to use hmatrix, where should i install lapack and blas?
12:03:48 <Deewiant> skorpan: But basically yes, if you have a lot of different types for which you want to define one function that is essentially the same for all of them, there's no way, apart from CPP or TH, to avoid writing similar code many times over.
12:03:48 <Eridius> uh hrm, Data.List.Zipper.Zipper can move right but.. not left?
12:03:48 <skorpan> Deewiant: actually, it's a bit more than what i pasted. i realize now that i should've pasted the full code...
12:04:02 <skorpan> Deewiant: the thing is that they're all the same type, just different constructors.
12:04:05 <MyCatVerbs> ImInYourMonad: anywhere where gcc and friends can find them.
12:04:25 <CosmicRay> @hoogle configMaxTest
12:04:41 <Deewiant> skorpan: Same difference.
12:04:44 <skorpan> Deewiant: this is the full code http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2158#a2158
12:05:44 <Deewiant> skorpan: You need to write the different functions or make a single type class (which amounts to the same thing but might reduce work if you need to do something similar later)
12:05:59 <Deewiant> skorpan: The only way around it is to use CPP or TH to generate the code for you.
12:06:06 <skorpan> okay then!
12:06:07 <koeien> @src sum
12:06:13 <skorpan> thanks a lot for your help Deewiant
12:06:27 <Deewiant> No problem :-)
12:06:27 <Eridius> Gracenotes: am I missing something, or does Zipper not have any way to move left?
12:06:41 <ImInYourMonad> cabal install zipper gave me multirec, is that right?
12:06:53 <ImInYourMonad> Could not find module `Data.List.Zipper.Zipper':
12:07:01 <Gracenotes> to move left on a zipper... well, you have three items: the left side, current, and right side
12:07:05 <skorpan> Deewiant: but i don't suppose there is any other magic extension to help me out?
12:07:12 <Deewiant> skorpan: Not that I can think of
12:07:20 <Eridius> ImInYourMonad: I'm looking at that package now. Data.List.Zipper.Ziper is from the listzipper package
12:07:27 <Eridius> it looks like the zipper package might offer a way to move left
12:07:29 <Eridius> (and.. up and down?)
12:07:39 <Gracenotes> Eridius: suppose you have 1 2 3 4 5, and you're focused on the 3
12:07:45 <Gracenotes> then the zipper is [2, 1] 3 [4, 5]
12:07:55 <Gracenotes> to move left, [1] 2 [3, 4, 5]
12:07:55 <Deewiant> skorpan: Which doesn't mean there /aren't/ any, of course ;-P
12:08:06 <Eridius> Gracenotes: yeah, check out Data.List.Zipper.Zipper (hoogle has it)
12:08:18 <Gracenotes> doesn't matter, you can easily implement your own
12:08:22 <Gracenotes> :)
12:08:27 <Gracenotes> the important thing is that the first list is 'backwards' in a sense.
12:08:32 <Gracenotes> it's like working off of two stacks
12:08:50 <ImInYourMonad> Compiling Generics.MultiRec.Zipper
12:09:08 <MyCatVerbs> left ((a:as), x, (b:bs) = (as, a, (x:b:bs)); right ((a:as), x, (b:bs)) = ((x:a:as), b, bs)
12:10:02 <tibbe_> are if expressions lazy, i.e. is there a difference between "return $ if a then b else c" and "return $! if a then b else c". My guess would be yes
12:10:12 <Eridius> Gracenotes: yeah, it's just weird that Data.List.Zipper.Zipper doesn't offer a "left" operator
12:10:21 <Gracenotes> hm.
12:11:00 <koeien> tibbe_: there is a difference
12:11:18 <koeien> tibbe_: take for example (return $ if undefined then 1 else 2) >> print "hello"
12:11:19 <tibbe_> koeien: ok, as I thought. thanks
12:11:24 <koeien> tibbe_: versus (return $! ...
12:15:01 <ImInYourMonad> so should i use a tape to be an array of zeros at first?
12:15:09 <ImInYourMonad> but it says bytes in the "spec"
12:15:21 <MyCatVerbs> ImInYourMonad: bytes-which-are-initialized-to-zero.
12:15:25 <Eridius> ImInYourMonad: actually, the tape should be initialized to your program data.
12:15:33 <Eridius> I would suggest something like program data ++ repeat 0
12:16:02 <Gracenotes> or, for a finite list, replicate 30000 (standard length)
12:16:22 <Gracenotes> The List Previously Known As Array
12:16:44 <Eridius> brainfuck is defined as being in an array of 30000 bytes, but there's no reason to actually conform to that unless you're worried about blowing up your memory
12:16:50 <Eridius> oh hrm, I'm wrong, program data is not on the tape
12:16:55 * Eridius hasn't looked at brainfuck in about 8 years
12:17:40 <MyCatVerbs> Secretly, we've replaced Eridius' neurons with a very fast Turing machine. Let's see if he notices in any finite quantity of time.
12:17:53 <Eridius> :D
12:18:13 <Eridius> that's the second grin-worthy statement I've seen here today. There's no haskelldb is there?
12:18:24 <ImInYourMonad> so the pointer is just the index of the array?
12:18:46 <Eridius> if you're using an array, then yes, it's just an index
12:18:49 <Eridius> but a zipper seems simpler
12:18:49 <ImInYourMonad> and this basically an abstract version fo a computer memory anyway right? the RAM?
12:18:57 <Gracenotes> although brainfuck doesn't 'know' the index
12:19:03 <ImInYourMonad> a pointer is basically address+value at address?
12:19:04 <Eridius> ImInYourMonad: a computer's RAM is just a very complicated tape
12:19:05 <MyCatVerbs> Eridius: there is, it's in lambdabot's head. But I can't remember how to use it.
12:19:23 <Gracenotes> @bf .
12:19:23 <lambdabot>   fd:8: hClose: resource vanished (Broken pipe)
12:19:31 <Gracenotes> bad lamby
12:19:35 <Eridius> heh
12:20:17 <Eridius> ?remember MyCatVerbs Secretly, we've replaced Eridius' neurons with a very fast Turing machine. Let's see if he notices in any finite quantity of time.
12:20:17 <lambdabot> It is stored.
12:21:20 <Eridius> ?remember Gracenotes if only () had an extra type parameter, then imagine all the uses!
12:21:21 <lambdabot> Good to know.
12:21:51 <Eridius> @yarr
12:21:51 <lambdabot> Where d' all t' pirates come from?
12:21:51 <lambdabot> Great Yarrmouth!
12:21:55 <Eridius> :D
12:22:50 <LeoD> @type ()
12:22:54 <lambdabot> ()
12:22:59 <LeoD> no way
12:23:03 * Eridius gasps
12:23:06 <ImInYourMonad> so what does the bf pointer now? is it not ok to define it as data Pointer = Pointer Index; type Index = Integer?
12:23:33 <Gracenotes> seems a little roundabout
12:23:44 <Gracenotes> a pointer's only as useful as the thing it's pointing to :D
12:23:50 <koeien> LeoD: ya rly :)
12:23:52 <MyCatVerbs> ImInYourMonad: yeah, but you might as well just write type Pointer = Integer.
12:24:35 <MyCatVerbs> ImInYourMonad: or even Int, rather than Integer, because you will run out of memory to store the tape on long before Int overflows on your machine.
12:24:45 <ImInYourMonad> the pointer is the head of a turnig machine?
12:25:37 <MyCatVerbs> ImInYourMonad: in Brainfuck? What pointer are you talking about?
12:26:01 <ImInYourMonad> w; an instruction pointer begins at the first command,
12:26:49 <MyCatVerbs> ImInYourMonad: right. The pointer is the location of the head on the tape.
12:27:25 <amaron> anyone plays with gtk2hs?
12:28:09 <MyCatVerbs> ImInYourMonad: the instruction pointer is a different thing again, it's another (arguably poorly chosen) name for the "program counter", i.e. the position of the machine within the Brainfuck program being executed. Yes, the Brainfuck machine has two tapes, not one.
12:28:27 <Gracenotes> @. type type ()
12:28:29 <lambdabot> ()
12:29:38 <ImInYourMonad> amaron: yes
12:29:42 <vixey> @. type type type type type type ()
12:29:44 <lambdabot> parse error (possibly incorrect indentation)
12:29:49 <gnut> is it better to pass an environment around as an argument? or use Reader?
12:29:51 <amaron> ImInYourMonad: how TreeIter can be used to access specific node in TreeModel?
12:30:02 <ImInYourMonad> no idea :)
12:30:13 <ImInYourMonad> i have done just a basic gui for an mp3player
12:30:14 <gnut> Reader may make the code look neater, but does it affect performance a lot?
12:30:22 <amaron> :)
12:30:35 <Gracenotes> @. type . type . type . type type ()
12:30:36 <Eridius> gnut: that's exactly what Reader does
12:30:40 <lambdabot> ()
12:30:41 <Eridius> Reader passes an environment around as an argument
12:30:53 <Gracenotes> hm. It must spawn a process for every type
12:31:12 <MyCatVerbs> gnut: GHC's optimizer is surprisingly good. It'll probably compile to the same code whether you use Reader or just pass the environment around manually.
12:31:34 <gnut> Eridius: yes. but then now my code will have to be written in a much more imperative way
12:31:40 <Eridius> MyCatVerbs: if he's passing the environment around as an argument, then I would fully expect it to compile to the same thing since Reader is literally just that
12:31:47 <gnut> MyCatVerbs: is that so? hmmm...
12:31:48 <Eridius> gnut: it's only imperative if you use do-blocks
12:31:58 <MyCatVerbs> Eridius: that's what I said!
12:32:02 <gnut> Eridius: heeheh.. okay. I see what you say.
12:32:06 <Eridius> and even then, it's not actually imperative because it doesn't guarantee execution order. only the IO monad does that
12:32:19 <travisbrady> does one need to obey a particular style or set of rules to get the stream fusion benefits of the uvector package?
12:32:40 <Gracenotes> gnut: with a Reader, the environment is implicitly the second argument
12:32:42 <pumpkin_> travisbrady: adding inlines might make things more fusible
12:32:56 <Gracenotes> with normal functions, it makes more sense to make the environment the first argument
12:32:58 <MyCatVerbs> travisbrady: just chain functions with Us at the ends of their names together with (.), and you're pretty much sorted.
12:33:05 <Gracenotes> for currying, etc.
12:33:10 <pumpkin_> travisbrady: anything in particular? you can ask the compiler to print out its simplification steps to see how much was fused
12:33:33 <amaron> I've also seen that onCursorChanged for TreeView is depricated, what is the other way to catch change of row in TreeView?
12:34:07 <gnut> ah okay
12:34:07 <travisbrady> pumpkin_: yes, i wrote this median finding code but it is man times slower than the same implementation using lists http://github.com/travisbrady/funzone/blob/a16c6e3f21ef339d095f6f68f116f2de213a06c9/uho.hs
12:34:12 <gnut> thanks for the tips
12:34:15 <travisbrady> s/man/many
12:34:54 <pumpkin_> travisbrady: there are a few things to be aware of when using it
12:36:37 <pumpkin_> travisbrady: that's O(n), right?
12:37:51 <pumpkin_> travisbrady: you might be best off doing this in the framework of uvector-algorithms' apply function
12:38:05 <travisbrady> pumpkin_: ahh, i hadn't heard of that
12:38:20 <pumpkin_> but in general indexU/lengthU isn't too great on UArrs
12:38:31 <pumpkin_> assuming you want it to stay a stream
12:39:58 <gnut> Gracenotes: thanks for the tip. it doesn't feel as dirty when you think of it now as a pure function just waiting for the last argument (the environment)
12:39:58 <Gracenotes> gnut: here's something I wrote a while back... doing basic evaluation with Readers vs. functions. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2159#a2159
12:40:13 <travisbrady> i'm guessing I'm must've done something wrong because I would think that uvector wouldn't perform so much worse than the list version
12:40:26 <Gracenotes> gnut: yep :) That's basically what it is
12:40:38 <pumpkin_> travisbrady: if you come up with a good fast median on UArrs, you should submit a patch to the statistics-fusion :)
12:40:55 <pumpkin_> (a package on hackage)
12:41:23 <travisbrady> pumpkin_: yeah i was planning on submitting a couple things, maybe a local linear regression filter if i can get it running speedily
12:41:48 <Gracenotes> gnut: in the code, they are very very similar
12:41:50 <pumpkin_> travisbrady: also, your partition function is going to break fusion (I have direct experience writing a similar partition function and having it break fusion)
12:42:06 <pumpkin_> travisbrady: but I'm not sure a fusible median is possible even
12:42:19 <Gracenotes> functions like mapM implicitly pass the argument, and so can be convenient, if you're willing to deal with the do notation and such
12:42:23 <gnut> Gracenotes: yes... I see :)
12:42:37 <pumpkin_> Gracenotes: how long have you been haskelling?
12:42:53 <travisbrady> i wouldn't be shocked yeah, to my knowledge there is no median algorithm that can operate on a stream
12:42:58 <Gracenotes> oh jeez, it's March already.
12:43:30 <pumpkin_> travisbrady: basically, if you can find out how to express median in terms of one of the nice built-in higher-order functions, then it's probably fusible, but I don't think you can
12:44:11 <Gracenotes> pumpkin: earliest logs I have here are December 6, 2008
12:44:29 <Gracenotes> so three months
12:44:43 <pumpkin_> :)
12:45:12 <Gracenotes> how about you..?
12:45:32 <pumpkin_> almost exactly the same time
12:45:49 <pumpkin_> I popped on once or twice before then to ask questions about my gf's haskell hw
12:45:53 <pumpkin_> :P
12:46:17 <pumpkin_> eventually she got me curious enough about the language that I decided to try it seriously
12:46:22 <gnut> you first learned haskell only three months ago?
12:46:35 <dons> bos31337: did you see we're cited in the ICPP paper on GpH and Eden...
12:46:37 <Gracenotes> yeah. I started out with Real World Haskell
12:47:27 <MyCatVerbs> pumpkin_: I'm confused at the concept that someone would be comfortable with writing Haskell but not with using IRC.
12:48:13 <Gracenotes> December 6, 2008...
12:48:19 <byorgey> really? that's not actually all that hard to believe.
12:48:20 <Gracenotes> 12:50:57 <dons> i've been really happy with the reviews of RWH so far. "this book will ignite the already growing haskell community. 10/10! " is my favourite i htink
12:48:22 <gnut> wow... I startetd around September 2007
12:48:23 <Gracenotes> 12:51:41 <Gracenotes> dons: hey, I'm somewhat of a novice myself, following the online version
12:48:28 <Gracenotes> 12:51:49 <Gracenotes> considerably informative
12:48:33 <dons> yeah, there's lots of academics who don't use irc, for example. and developers.
12:49:30 <czShadoW> Gracenotes: Haha, cool.
12:51:14 <ispiked> I have a list that's always going to be in the form of [(a, b)]. I want to create a new datatype, e.g. data Pair = Pair [(Int,Int)] | Empty, but then I can't use list functions on it...
12:51:23 <pumpkin_> she was taking a haskell course and had never been on IRC so I volunteered to ask for her
12:51:29 <MyCatVerbs> dons: bah, humbug!
12:51:55 <Eridius> ispiked: maybe you should have Pair = (Int,Int) and then use [Pair]
12:52:03 <MyCatVerbs> ispiked: type Pairs = [(Int,Int)]
12:52:11 <Eridius> or yeah, use type. I was just looking up that keyword ;)
12:52:18 <MyCatVerbs> ispiked: you don't need a seperate Empty constructor, because you use []. :)
12:52:31 <ispiked> thanks. I'll have to look into type
12:52:40 <Eridius> type is like C's typedef.
12:52:41 <Eridius> @t String
12:52:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:52:47 <Eridius> @i String
12:52:47 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
12:52:52 <Eridius> bah you can't do info?
12:52:56 <Eridius> @type String
12:52:58 <lambdabot> Not in scope: data constructor `String'
12:52:59 <Gracenotes> not a useful info anyway
12:53:07 <Eridius> I just wanted it to print out type String = [Char]
12:53:21 <pumpkin_> the IRC channel was so friendly it actually overcame my lack of interest in haskell
12:53:24 <amaron> dons: you use gtk2hs, right?
12:53:38 <Gracenotes> , src ''String
12:53:41 <lunabot>  type String = [Char]
12:53:56 <skorpan> what does '' mean?
12:54:20 <Gracenotes> heck if I know (>^_^)>
12:54:23 <Gracenotes> , help
12:54:25 <lunabot>  type of an expression:      , [$ty| \x -> x |]
12:54:25 <lunabot>  get info for a type/class:  , src ''Monad
12:54:25 <lunabot>  get info for a var/con:     , src 'fix
12:54:31 <Eridius> heh
12:57:17 <byorgey> skorpan: I... think it has to do with Template Haskell syntax?
12:59:11 <zcvvc> I'm starting to learn kinds. Either has kind * -> * -> * but (->) has ? -> ?? -> *. what do ? and ?? mean?
12:59:27 <Heffalump> it does?
12:59:36 <dibblego> zcvvc, it's a GHC thing -- (->) has the same kind as Either
12:59:49 <zcvvc> thanks
12:59:56 <aempirei> would you consider giving eachother ego-handjobs a collection of isomorphisms on the collection of compu-math jerk objects
13:00:11 <jeltsch> Hello, the homepage of the community server says: If your project has no other members, you might consider using       your community-hosted personal web space, rather than asking for a separate project.
13:00:40 <jeltsch> My question is: In which directory does this personal web space reside and through which URL do I access it?
13:00:52 <Heffalump> you access it through ~username/
13:01:06 <jeltsch> Heffalump: With which domain?
13:01:12 <Heffalump> code.haskell.org I think
13:01:15 <byorgey> jeltsch: it's in ~username/
13:01:34 <jeltsch> Heffalump: Isnt code.haskell.org for stuff under /srv/code?
13:01:35 <byorgey> erg, I was going to say,  ~username/public_html/ or something like that
13:01:41 <ImInYourMonad> im getting it now, soon i will brainfuck
13:01:47 <byorgey> that's a directory path, not a URL.
13:01:54 <jeltsch> byorgey: Okay, so ordinary UNIX conventions.
13:02:05 <byorgey> jeltsch: right.
13:02:07 <ImInYourMonad> anyway, to increment the byte how would I? if u said fill it with zeros? or i could just fill it with bits?
13:02:09 <jeltsch> byorgey: I know its a path. But I wanted to know the path and the URL
13:02:27 <jeltsch> Okay, so the path is ~username/public_html.
13:02:41 <byorgey> right, and the URL is code.haskell.org/~username/
13:02:49 <jeltsch> The URL is maybe http://community.haskell.org/~username/?
13:03:00 <jeltsch> Really code.haskell.org? Okay, Ill try.
13:03:03 <Heffalump> it might be, but code.haskell.org/~username/ definitely works
13:03:05 <byorgey> either one works.
13:03:10 <byorgey> I just tried it with mine.
13:03:45 <jeltsch> Okay, so when you use URLs with ~username, maybe everyone of all those domains works (e.g., projects.haskell.org)?
13:03:57 <Heffalump> quite possibly
13:04:10 <byorgey> yup, projects appears to work too.
13:05:35 <jeltsch> But just haskell.org doesnt. :-)
13:06:41 <byorgey> nope =)
13:07:13 <byorgey> I think that's actually a different server.
13:07:46 <jeltsch> byorgey: I think so, too. :-)
13:11:37 * byorgey actually ate some lambda cookies today!
13:12:04 <gnuvince> What would be the best way to swap two items in a list?
13:12:37 <Zao> Recurse until you match them, swap and glue on tail?
13:13:13 <gnuvince> Zao: two items anywhere in the list.
13:13:23 <gnuvince> swap [1,2,3,4,5] 0 4
13:13:29 <sjanssen> gnuvince: what are you given, index?
13:13:30 <sjanssen> or value
13:13:31 <byorgey> gnuvince: the best way is to assume they are equal. ;)
13:13:34 <Zao> Ah, indices are known.
13:13:35 <gnuvince> sjanssen: index.
13:13:46 <vixey> > let swab 0 c (x:xs) = (c:xs,x) ; swab n c (x:xs) = fmap (x:) (swab (n-1) c xs) in swab 2 '!' "xyzw"
13:13:48 <Zao> split a few times and twiddle the pieces?
13:13:54 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
13:14:00 <lambdabot>        Expect...
13:14:11 <vixey> > let swab 0 c (x:xs) = (x,c:xs) ; swab n c (x:xs) = fmap (x:) (swab (n-1) c xs) in swab 2 '!' "xyzw"
13:14:17 <sjanssen> gnuvince: I'd write separate insertIndex and deleteIndex functions and compose them
13:14:20 <lambdabot>   ('z',"xy!w")
13:14:28 <sjanssen> let laziness make it efficient
13:14:32 <vixey> gnuvince, use swab to implement swap
13:15:20 <gnuvince> OK
13:15:51 <gnuvince> I was just curious, there's a guy in another channel doing this in C, and he's probably just gonna swap the element member of his structs
13:15:54 <gnuvince> (mutations)
13:16:08 <vixey> gnuvince, that's what you could do with ST Array
13:16:18 <sjanssen> gnuvince: in cases where you need to do this in Haskell, you'd probably use another data structure
13:16:26 <vixey> gnuvince, that is an array not a list
13:16:32 <sjanssen> Data.Sequence, or an array (pure or mutable)
13:16:34 <vixey> gnuvince, compare it with a C linked list version
13:17:10 <gnuvince> sjanssen: I figured as much.
13:17:33 <gnuvince> It was just for my own curiosity
13:17:52 <gnuvince> I tried implementing one by reconstructing the list, but it was very ugly
13:18:13 <sjanssen> hmm, can we use Bird's repmin trick to do this more efficiently?
13:18:45 <Heffalump> sjanssen: the obvious algorithm is one-pass
13:20:01 <vixey> sjanssen, I guess that is my swab idea
13:20:50 <rovar> quick question. I would like to make a point free implementation of a function that takes 1 var and returns 1 var, but the functions I wish to use take 2 vars and return 1
13:21:15 <tromp_> so give them 1 arg
13:21:29 <rovar> e.g.  pow4 x = ( (mul x ) . (mul x) . (mul x) ) x
13:21:43 <rovar> but that's not point free, ya? what arg do I give them?
13:21:47 <ImInYourMonad> hmm if i accept input i move to the IO monad, how do I solve thta when using Parsec to interpret?
13:21:57 <tromp_> no need for that many ()
13:21:59 <vixey> rovar, it's almost point free
13:22:11 <Eridius> ImInYourMonad: by executing your Parsec parser from inside the IO monad?
13:22:11 <vixey> rovar, I suggest you abstract out the '4' though
13:22:19 <vixey> rovar, write  pow n x = ...
13:22:20 <rovar> i like the look of:  pow4 x = foldr1 mul [x,x,x,x]
13:22:28 <vixey> rovar, then  pow4 = pow 4
13:22:41 <tromp_> pow = square . square
13:22:43 <vixey> rovar, but don't melt the number into the function like that
13:22:50 <rovar> vixey sure.. this is more an exercise of making stuff point free
13:23:02 <vixey> rovar, ok but watch what hapens when you generalize
13:23:06 <rovar> i'm not actually going to use this function :)
13:23:11 <byorgey> rovar: if you really want to do something point-free where you duplicate an argument like that, then you need 'ap' from the ((->) e) monad
13:23:18 <byorgey> it's kind of ugly.
13:23:26 <vixey> rovar, there is a useful tool which should really be in Haskell already btw
13:23:31 <vixey> data N = Z | S N
13:23:34 <byorgey> well, you need the ((->) e) monad in general.
13:23:36 <vixey> instance Num N where ...
13:23:37 <tromp_> > ap ap const x y
13:23:38 <lambdabot>       Occurs check: cannot construct the infinite type: a = b1 -> a -> b
13:23:38 <lambdabot>     ...
13:23:50 <vixey> rovar: and foldN lets you implement this for generalized n in a point free way
13:24:04 <vixey> foldN z s Z = z ; foldN z s (S n) = s (foldN z s n)
13:24:13 <byorgey> rovar: there was a thread about this on a mailing list recently, let me see if I can find it for you
13:24:29 <sjanssen> vixey: so it is
13:24:39 <rovar> ahh
13:25:02 <rovar> foldN is what I was looking for.. actually.. that way I don't have to do the [x,x,x,x] which seemed the hackish part of that statement :)
13:25:13 <byorgey> rovar: http://thread.gmane.org/gmane.comp.lang.haskell.beginners/469
13:25:38 <vixey> N should be standard equipment but .. it's not
13:26:10 <LeoD> you could use take n $ repeat x
13:26:31 <Eridius> what's N?
13:26:36 <rovar> ah..is foldN defined in a library loadable by hugs?
13:27:09 <sjanssen> gnuvince: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2160#a2160 is rather elegant, IMO
13:32:05 <ImInYourMonad> how do i ocnvert 'a' to string?
13:32:15 <edwardk> > ['a']
13:32:16 <lambdabot>   "a"
13:32:21 <edwardk> > return 'a'
13:32:23 <lambdabot>       No instance for (Show (m Char))
13:32:23 <lambdabot>        arising from a use of `show' at ...
13:32:35 <edwardk> > return 'a' :: String
13:32:37 <lambdabot>   "a"
13:32:42 <Eridius> 'a':[]
13:32:52 <sjanssen> > pure 'a' :: String
13:32:54 <lambdabot>       Ambiguous occurrence `pure'
13:32:54 <lambdabot>      It could refer to either `Control.Appl...
13:32:57 <sjanssen> bah
13:33:05 <edwardk> > point 'a' -- if you use category-extras ;)
13:33:07 <lambdabot>   Not in scope: `point'
13:33:26 <LeoD> > Control.Applicative.pure 'a' :: String
13:33:28 <lambdabot>   "a"
13:33:30 <LeoD> yay!
13:33:35 <vixey> > "a"
13:33:36 <lambdabot>   "a"
13:33:44 <sjanssen> > take 1 $ repeat 'a'
13:33:45 <lambdabot>   "a"
13:33:52 <byorgey> LeoD: =)
13:34:05 <Eridius> > let charToString :: Char -> String; charToString = (:[]) in charToString 'a'
13:34:07 <lambdabot>   "a"
13:34:15 <byorgey> > (:[]) 'a'  -- give it to a robot monkey to eat
13:34:17 <lambdabot>   "a"
13:34:21 <LeoD> haha :D
13:34:53 <Eridius> > liftM 'a' :: String
13:34:54 <lambdabot>   Couldn't match expected type `a1 -> r' against inferred type `Char'
13:34:59 <Eridius> oops
13:35:01 <Eridius> > return 'a' :: String
13:35:03 <lambdabot>   "a"
13:35:07 <LeoD> right
13:35:30 <edwardk> > runKleisli (arr id) 'a' :: [a]
13:35:31 <lambdabot>   Couldn't match expected type `a' against inferred type `Char'
13:35:39 <edwardk> > runKleisli (arr id) 'a' :: String
13:35:40 <lambdabot>   "a"
13:35:42 <edwardk> =)
13:35:55 <Eridius> I need to learn how arrows work
13:36:34 <vixey> :t runKleisli ?arrid 'a'
13:36:35 <lambdabot> forall (m :: * -> *) b. (?arrid::Kleisli m Char b) => m b
13:36:48 <byorgey> edwardk: heh, nice =)
13:37:10 <edwardk> 'arr id = Kleisli return' in the Kleisli category for a monad
13:41:04 <nyingen> I'm having trouble with this function 'list_minus', which is supposed to take an integer and a list of things, and return a tuple consisting of the thing, and then the rest of the list not including the thing. list_minus :: Int -> [a] -> (a, [a]) but I get an 'occurs check' error
13:41:25 <nyingen> Not sure what to do about it
13:41:33 <vixey> write the case
13:41:40 <vixey> list_minus 0 (x:xs) = ...
13:41:48 <vixey> first of alla
13:42:27 <agruman> vixey, i could use some hints on how to do eval on "App (App (\x -> \y -> x + y) 1) 2" in a "correct" way "App (\x -> x) 1" works ok though. Currently its using call-by-value which is fine for now
13:43:04 <nyingen> er, I should have said that it returns, for a list x and int n, (x !! n, [rest of things in x])
13:43:08 <Heffalump> agruman: there's not much you can do other than apply it..
13:43:32 <Heffalump> well, you can use a type class to figure out an AST from the lambda abstraction
13:43:48 <Heffalump> i.e. a funny Num instance
13:43:49 <agruman> Heffalump, what do you mean?
13:44:07 <agruman> this is my "own" functional language
13:44:16 <Heffalump> oh, so that's not Haskell syntax?
13:44:19 <agruman> which im interpreting using haskell
13:44:20 <Heffalump> ok, never mind
13:44:57 <agruman> but its compilable using ghc so basically a small subset of haskell ... as exercise
13:45:10 <ImOuttaYourMonad> what are X essential commands/operators a turing-machine needs? read, print, left, right?
13:45:32 <idnar> destroy_universe
13:45:35 <agruman> though i cant quite get the lambda expressions and function applications right
13:45:45 <idnar> or maybe that's only for quantum turing machines
13:46:43 <tromp_> BF has 8 operations
13:46:45 <tombom> i can't believe he missed a way of actually changing values
13:47:01 <tromp_> using byte sized cells
13:47:22 <tromp_> using bits instead u dont need + and -, just flip
14:03:51 <ImOuttaYourMonad> ok my brainfuck interpreter is asoon done, i need increment byte dec byte and inut.
14:04:12 <ImOuttaYourMonad> so how should I do decrement byte? you guys said init everything to 0
14:04:21 <ImOuttaYourMonad> so im having bits or what?
14:04:32 <ImOuttaYourMonad> how do I decremtn 0 then and how do I increment 1?
14:04:45 <omnihil> if your data items are one bit then increment and decrement are the same operation
14:04:48 <omnihil> 0->1; 1->0;
14:04:51 <ImOuttaYourMonad> ok
14:05:34 <MyCatVerbs> Achtung! In Brainfuck, the data items are bytes, not single bits.
14:05:54 <MyCatVerbs> ImOuttaYourMonad: "increment" is a five-dollar word for "add one to".
14:06:06 <MyCatVerbs> ImOuttaYourMonad: "decrement" is a five-dollar word for "subtract one from".
14:06:35 <MyCatVerbs> In Haskell, they're often written as "succ" and "pred". ^_^
14:06:44 <ski> > succ ()
14:06:45 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
14:07:07 <tromp_> map succ "succ"
14:07:07 <MyCatVerbs> Apparently succ maxBound isn't allowed. ^_^
14:07:12 <jlouis> > succ 3
14:07:13 <omnihil> Brainfuck leaves a lot of things up to the implementation to decide, such as array and cell size, and what happens when EOF is read.
14:07:13 <tromp_> > map succ "succ"
14:07:14 <lambdabot>   4
14:07:15 <lambdabot>   "tvdd"
14:07:18 <MyCatVerbs> > succ (255 :: Word8)
14:07:18 <omnihil> that's from http://esolangs.org/wiki/Brainfuck
14:07:19 <lambdabot>   * Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
14:07:28 <tromp_> > map pred "pred"
14:07:30 <lambdabot>   "oqdc"
14:07:30 <MyCatVerbs> Oh snap, that's not right.
14:07:52 <nyingen> Anyone got a minute to take a look at this and tell me why I have an 'occurs check'? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1787#a1787
14:08:01 <MyCatVerbs> For a BF interpreter, you'll want 255+1 to overflow back to 0. So, er, use (+1) and (-1) for implementing Brainfuck, not succ and pred.
14:08:18 <omnihil> you also want 0-1=255
14:08:18 <lament> MyCatVerbs: actually that's not defined anywhere
14:08:28 <omnihil> if you want the unsigned-modulo-256 behavior
14:08:58 <MyCatVerbs> nyingen: because you wrote "concat y" when you meant to write "y".
14:09:01 <ski> nyingen : `y' is of type `[a]' .. why are you trying to `concat' it ?
14:09:17 <jlouis> nyingen: check the type of 'y' indeed
14:09:22 <MyCatVerbs> lament: meh. Isn't it how the principle implementation works?
14:09:27 <jlouis> and then the type signature of concat
14:09:35 <nyingen> ah, I see why I'm confused. My program always calls this function on lists of lists, so I wanted the 2nd value flattened
14:09:37 <ski> nyingen : also, check out `splitAt'
14:09:46 <nyingen> thanks, will do
14:09:56 <jlouis> MyCatVerbs: some brainfucks use the integers in the cells, no byte wraparound
14:09:56 <ski> > splitAt 3 "abcdefgh"
14:09:57 <lambdabot>   ("abc","defgh")
14:10:01 <ImOuttaYourMonad> meh
14:10:08 <ImOuttaYourMonad> show me how to use assocs on arrays
14:11:26 <MyCatVerbs> jlouis: oh! Well, I'm wrong, and not for the first time. Thanks.
14:12:03 <jlouis> MyCatVerbs: some brainfucks work exactly like you state
14:12:41 <jlouis> it is a bit up to debate, but you can rewrite programs of BF_i8 to BF_Z with some work
14:12:45 <ImOuttaYourMonad> A.assocs (A.array (0,2) $ zip [0..] [1,2,3]) 0 1
14:12:49 <ImOuttaYourMonad> why doesnt that work?
14:12:58 <ImOuttaYourMonad> ouldn't match expected type `t1 -> t2 -> t'
14:12:59 <ImOuttaYourMonad>            against inferred type `[(t3, e)]'
14:13:05 <omnihil> bonus points for writing a program in brainfuck to convert BF_i8 to BF_Z
14:13:12 <omnihil> and then converting it.
14:14:01 <MyCatVerbs> omnihil: did you mean writing a program in BF_i8 to convert BF_Z to BF_i8?
14:14:42 <MyCatVerbs> omnihil: or, IMO more fun, a program in BF_Z to convert BF_Z to BF_i8, and *then* run it through itself?
14:15:19 <jlouis> haha
14:15:37 <jlouis> ImOuttaYourMonad: your problem is that assocs is not working like you want
14:15:44 <omnihil> mycatverbs, it's definitely got to run through itself.
14:16:06 <BMeph_> MyCatVerbs: Or even...[write] a program in brainfuck to convert BF_i8 to BF_Z
14:16:06 <jlouis> array (0, 2) $ zip [0..] [1,2,3] builds up an array. The assocs function projects it out to an association list
14:16:19 <augustss> :t assocs
14:16:21 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
14:16:21 <jlouis> you can't apply 0 and 1 to a list
14:16:59 <jlouis> Can't remember what I did with Brainfuck
14:17:02 <koeien> QuickCheck rules :) is there any way i can pass some parameters to the QuickTest executable?
14:17:06 <MyCatVerbs> BMeph_: no, because that's just a BF implementation of @cat@.
14:17:08 <koeien> e.g. more verbose
14:17:20 <MyCatVerbs> s/@/"/g
14:18:08 <omnihil> not if people wrote code that depended on the special properties of the cell size
14:18:13 <jlouis> ah, my brainfuck interpreter was BF_N
14:18:46 <vixey> is BF_{0,1} TC?
14:18:48 <jlouis> (in Coq, nevertheless)
14:19:32 <jlouis> vixey: my intuition says so, but it has been wrong before :)
14:20:14 <nyingen> Another question: is there a library function or one-liner to take a list of functions and apply them to a list of values, returning the list of results?
14:21:04 <BMeph_> nyingen: What, you mead zipWith id? ;p
14:21:04 <augustss> nyingen: zipWith ($)
14:21:15 <BMeph_> s/mead/mean/
14:21:18 <nyingen> aha
14:21:25 <tromp_> hi Lennart
14:21:34 <nyingen> still adjusting to this crazy higher-order power :)
14:21:56 <vixey> hehe
14:22:02 <BMeph_> nyingen: Well, augustss's version is more "respectful" of the types involved. :)
14:22:03 <augustss> Hello tromp_ , whoever you are
14:22:23 <augustss> But BMeph_'s is cooler
14:22:46 * BMeph_ blushes at the praise of the "Haskell-Tech Master"
14:22:53 <brad_larsen> can someone elaborate on cabal's `-p' option (enable library profiling)?
14:22:56 <vixey> > [reverse,head,tail] <$> ["I","wonder","if","this","does","something"]
14:22:57 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
14:23:06 <vixey> > [reverse,head,tail] <$> "test"
14:23:07 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
14:23:07 <augustss> nope
14:23:18 <brad_larsen> does it install a version of a library built for profiling *in addition* to the non-profiling-enabled version?
14:23:23 <tromp_> augustss, i sent you an email a few days ago
14:23:24 <vixey> > [reverse,head,tail] <*> "test"
14:23:25 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
14:23:25 <lambdabot>        Expect...
14:23:27 <brad_larsen> or does it replace the non-profiling version?
14:23:29 <vixey> > [reverse,head,tail] <*> ["test"]
14:23:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
14:23:30 <lambdabot>        Expect...
14:23:30 <Heffalump> brad_larsen: in addition
14:23:44 <augustss> tromp_: did I answer?
14:23:44 <jlouis> Applicative! ... the types must match!
14:23:48 <brad_larsen> Heffalump: ok thanks
14:23:52 <tromp_> about your lambda calculus implementations
14:23:55 <tromp_> nope:(
14:24:04 <BMeph_> nyingen (and vixey): Oh, yeah - make sure that all of your functions have the same type. ;)
14:24:10 <tromp_> wondering if u got the email
14:24:17 <augustss> tromp_: ah, yes.  I wasn't sure what to answer, really. :)
14:24:23 <tromp_> ok then:)
14:24:35 <nyingen> BMeph_: indeed
14:24:46 <BMeph_> preflex: seen centrinia
14:24:56 <BMeph_> preflex: @seen centrinia
14:25:33 <BMeph_> Aw, no preflex. :(...
14:26:26 <tromp_> must be because my email didnt include any questions:)
14:26:49 <vixey> BMeph doh
14:26:56 <tromp_> anyway, you don't mind i re-use your code?
14:26:57 <vixey> that was a really bad mistake
14:26:58 <augustss> tromp_: indeed.  Nor anything I disagreed with
14:27:12 <augustss> tromp_: reuse it all you like
14:27:41 <tromp_> have you read my paper?
14:27:50 <Heffalump> augustss: does that job ad that someone forwarded to the haskell list earlier today originate from SC?
14:28:01 <augustss> tromp_: no :(
14:28:28 <augustss> Heffalump: well, yes and no.  It's a headhunter that keeps finding people, but we have not asked him to.
14:28:41 <Heffalump> ah :-)
14:28:47 <augustss> Heffalump: We actually have a hiring freeze at the moment.
14:29:01 <tromp_> i figure you're one of the few ppl who cld understand my lambda calculus program "pairup" and see if it can be shortened further:)
14:29:25 <tromp_> if you ever have that much time to waste:)
14:29:49 <augustss> tromp_: time is short.  I have to start reading ICFP papers now
14:30:25 <augustss> tromp_: send me a reminder to read it
14:30:55 <tromp_> ok, maybe in a month or 2
14:31:12 <augustss> After mid April
14:32:03 <kniu> @plf x y
14:32:03 <lambdabot> x y
14:32:22 <augustss> plf?
14:32:47 <kniu> typo.
14:32:48 <lambdabot> kniu: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:05 <Gracenotes> pointlessfree
14:34:42 <kniu> @pl maybe (background ray) (\ p -> lighted scene p + refracted scene ray p + reflected scene ray p) (trace ray (snd scene))
14:34:42 <lambdabot> maybe (background ray) (ap ((+) . ap ((+) . lighted scene) (refracted scene ray)) (reflected scene ray)) (trace ray (snd scene))
14:35:17 <kniu> @pl \ ray -> maybe (background ray) (\ p -> lighted scene p + refracted scene ray p + reflected scene ray p) (trace ray (snd scene))
14:35:18 <lambdabot> liftM2 maybe background (ap (ap . ((+) .) . ap ((+) . lighted scene) . refracted scene) (reflected scene)) `ap` flip trace (snd scene)
14:35:48 <kniu> @pl \ scene ray -> maybe (background ray) (\ p -> lighted scene p + refracted scene ray p + reflected scene ray p) (trace ray (snd scene))
14:35:49 <lambdabot> ap (ap . liftM2 maybe background . ap (ap . (liftM2 (+) .) . ap ((.) . ap . ((+) .) . lighted) refracted) reflected) (flip trace . snd)
14:35:49 <ImOuttaYourMonad> ok im done except for one thing, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2161#a2161
14:36:01 <ImOuttaYourMonad> i need input, how do I make the interpret function a monad?
14:36:23 <chessguy> what's that graphics protocol that's literally just a couple of magic numbers and then a series of rows of numbers representing colors of pixels or something?
14:36:23 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
14:37:17 <MyCatVerbs> chessguy: ppm.
14:37:21 <chessguy> yeah, that's it
14:40:04 <augustss> chessguy: the numbers are not magic :)
14:40:28 <chessguy> augustss:  magic in the sense of appearing arbitrary
14:41:01 <ImOuttaYourMonad> can I use | in dos?
14:41:10 <augustss> chessguy: well, the first characters identfy the format, so they are magic.  but the rest is the size of the bitmap
14:42:20 <p_l> ImOuttaYourMonad: yes. that was one of the features that helped DOS 2.0 fight against CP/M, ported directly from Unix :P
14:42:35 <chessguy> yeah, but i couldn't remember what they were, so they're all magic to me :)
14:43:04 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2161#a2162 <- how can I fix that? do+intendation stuff , im trying to move a pure fucntion into a do
14:43:19 <kniu> huh
14:43:23 <ImOuttaYourMonad> p_l I meant | as in case and dos as in do-construcy
14:43:32 <p_l> lol
14:43:38 <kniu> lambdabot only relayed a message when I typed something that is not a command for it.
14:43:46 <kniu> Is that intentional, or a bug?
14:43:57 <travisbrady> ImOuttaYourMonad: what error are you getting?
14:44:07 <ImOuttaYourMonad>   parse error (possibly incorrect indentation)
14:44:40 <travisbrady> ImOuttaYourMonad: can you paste the whole thing? line numbers are helpful
14:44:48 <travisbrady> put it in your hpaste though
14:45:43 <ImOuttaYourMonad> i did..
14:45:43 <Tobsan> is it possible to have the ST monad contain some kind of state, like the State monad?
14:45:44 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2161#a2162
14:46:03 <Tobsan> as i understood it, the type variable s is kind of "secret"
14:46:22 <Tobsan> which would mean that a is the only thing contained in the ST monad?
14:46:30 <Heffalump> Tobsan: no, it's not possible. You have to keep hold of STRefs to get at things.
14:46:36 <Heffalump> you can layer an StateT on top if you want
14:46:51 <Tobsan> Heffalump: oh :/
14:47:06 <travisbrady> ImOuttaYourMonad: i don't see any errors on that page
14:47:36 <Tobsan> Heffalump: I'm trying to convert a program using the state monad to one using ST
14:48:01 <Heffalump> Tobsan: why, for speed?
14:48:07 <Tobsan> Heffalump: yes
14:48:16 <Tobsan> and to use STArray
14:48:24 <augustss> Tobsan: Use STRef
14:48:31 <augustss> for the state, I mean
14:48:35 <Heffalump> well, the first thing you could do is change to ReaderT (ST s)
14:48:51 <Tobsan> hmm okay
14:49:01 <Heffalump> and store all the things that were previously in the state in STRefs at the beginning, and put the STRefs in the reader.
14:49:02 <ski> (`ReaderT (..) (ST s)')
14:49:03 <ddarius> type State s a = ReaderT (STRef s) ST a
14:49:20 <Tobsan> oh, I see
14:49:34 <ddarius> (except for I missed the phantom type parameter)
14:49:44 <ImOuttaYourMonad> come on, someone must be able to solve a simple intendation problem
14:49:47 <Heffalump> that wouldn't be very natural ST code, but it'd be a start on the refactoring process
14:49:54 <augustss> Tobsan: If the state has many parts I'd use one STRef for each part
14:50:08 <ddarius> ImOuttaYourMonad: I bet ImOuttaYourMonad can.
14:50:12 <travisbrady> ImOuttaYourMonad: i meant you didn't paste the text of the error ghc gave you
14:50:22 <chessguy> ImOuttaYourMonad: being obnoxious isn't a good way to get help
14:50:24 <Tobsan> augustss: okay
14:50:44 <pumpkin_> -- halts program = do
14:50:49 <pumpkin_> interesting function
14:50:53 <pumpkin_> you gonna finish implementing it?
14:50:55 <augustss> it's a comment
14:50:59 <pumpkin_> I know :)
14:51:05 <pumpkin_> it's commented out code though
14:51:14 <augustss> > do 5
14:51:15 <lambdabot>       No instance for (Num (t t1))
14:51:15 <lambdabot>        arising from the literal `5' at <in...
14:51:32 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2161#a2163 <- error too
14:51:40 <augustss> ghc think 'do 5' is fine.  I don't.
14:51:54 <pumpkin_> you just need to indent then a bit more
14:51:57 <pumpkin_> and else
14:52:00 <vixey> do 5 GOTO 5
14:52:11 <travisbrady> ImOuttaYourMonad: ok, just grabbed your code and tried compiling, line 63.  you need to indent the stuff after an if
14:52:17 <Tobsan> augustss: by the way, I think your talk on fun with type classes at chalmers was great
14:52:20 <travisbrady> ImOuttaYourMonad: you have more problems once you solve that though
14:52:21 <ddarius> augustss: GHC thinks it's an error (lacking a suitable Num instance) whereas arguably it should be 5.
14:52:40 <augustss> ImOuttaYourMonad: remove the do at the end of the interpreter line
14:52:51 <Gracenotes> eh... it's easy enough to write a program that checks if another program halts.
14:53:03 <augustss> ddarius: no, ghc does not think it's an error.  try it
14:53:11 <pumpkin_> Gracenotes: well, it can output True easily enough, outputting False is hard :P
14:53:21 <Gracenotes> exactly ;)
14:53:28 <ddarius> Okay, then why does lambdabot think it is an error?
14:53:55 <augustss> ddarius: lambdabot is better!
14:54:06 <ddarius> augustss: Yes, why?
14:54:20 <chessguy> @type do 5
14:54:21 <ddarius> (Actually, I lean toward it not being an error.)
14:54:21 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
14:54:32 <pumpkin_> paczesiowa: your fusible mapAccum was better than the one in stream-fusion, I meant to tell you but you left :)
14:54:44 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2164#a2164 ok now i get that instead (intendation orks, thnx)
14:54:53 <augustss> ddarius: I don't care much, but I think do should be monadic
14:55:04 <paczesiowa> pumpkin_: which one? I have like 10 versions now:)
14:55:14 <pumpkin_> paczesiowa: oh no, I'm not sure now :P
14:55:19 <pumpkin_> I don't have the code on hand
14:55:36 <ddarius> augustss: My question was, why is lambdabot giving a different result to GHC here?  It uses GHC in the end.
14:55:38 <paczesiowa> pumpkin_: that hpasted code?
14:55:39 <chessguy> @src unlines
14:55:39 <lambdabot> unlines = concatMap (++ "\n")
14:55:45 <ski> `instance Num a => Num (x -> a)' .. `do x <- 5; ...'
14:55:48 <chessguy> @type unlines
14:55:49 <lambdabot> [String] -> String
14:55:53 <pumpkin_> paczesiowa: yeah, it had a myMapAccumL/R (I can't remember which one you had)
14:56:16 <pumpkin_> the one in stream-fusion has a TODO note saying it doesn't fuse currently
14:56:17 <augustss> ddarius: well, I don't know enough about lambdabot to answer
14:56:23 <pumpkin_> so it's as fast as the regular list one
14:56:24 <vixey> instance Num ((o -> o) -> (o -> o)) where ...  another nice one   23 f  = f . f . f . f ...
14:56:33 <paczesiowa> pumkin_: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1721 ?
14:56:41 <pumpkin_> that's the one :)
14:56:58 <pumpkin_> I compared it against stream-fusion
14:57:27 <paczesiowa> pumpkin_: mapAccum[LR] can only be good consumer, it can't be good producer
14:57:39 <ImOuttaYourMonad> so my problem is IO Tape versus exected type Tape
14:57:54 <LeoD> get it outta the monad!
14:58:30 <pumpkin_> paczesiowa: makes sense
14:58:52 <paczesiowa> pumpkin_: besides I think those functions are usually used with snd (we don't care about final acc) so I wrote mapAccum, that is both good consumer and producer (under stream fusion)
14:59:04 <pumpkin_> oh nice
14:59:15 <vixey> "...which, since it is philosophy, can only be appropriately understood in the original German"
14:59:36 <augustss> vixey: !
14:59:55 <vixey> hey augustss
15:00:13 <augustss> vixey: it's true, about German. :)
15:01:15 <ImOuttaYourMonad> but wtf
15:01:18 <vixey> the problem is I don't know any German yet :p
15:01:26 <pumpkin_> ImOuttaYourMonad: ?
15:01:26 <augustss> Wovon man nicht sprechen kann, darber muss man schweigen.
15:01:27 <ImOuttaYourMonad> these are the things that drives people crazy about haskell
15:01:37 <pumpkin_> ImOuttaYourMonad: what are?
15:01:47 <ddarius> vixey: Well you've found a use for learning German, if you can find a use for philosophy.
15:02:17 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2165#a2165
15:02:55 <augustss> ImOuttaYourMonad: still, remove that extra do.
15:03:08 <ImOuttaYourMonad>  Right ',' -> interpret program (instruction_pointer+1)                           (store tape data_pointer)   data_pointer     result
15:03:18 <ImOuttaYourMonad> which extra do?
15:03:19 <pumpkin_> ImOuttaYourMonad: might need a >>= there
15:03:34 <pumpkin_> since store itself is an IO
15:03:37 <ski>   62 interpret program instruction_pointer tape data_pointer result = do
15:03:38 <ski> that one
15:03:47 <pumpkin_> oh
15:03:52 <pumpkin_> :)
15:04:00 <augustss> ImOuttaYourMonad: the one that forced you to change the indentation
15:04:04 <ImOuttaYourMonad> where is there
15:04:14 <pumpkin_> ImOuttaYourMonad: just out of curiosity, why do you comment out your types? :P
15:04:26 <ski> you've got a line number. just look it up in the paste
15:04:31 <augustss> pumpkin: they are wrong ;)
15:04:38 <ImOuttaYourMonad> well i had to bring it into the IO monad because of store
15:04:57 <pumpkin_> augustss: I guess that's a good reason :) I didn't look too closely, just saw a lot of commented out type annotations
15:04:59 <ImOuttaYourMonad> pumpkin: because sometimes ghci can make it work when i do
15:05:04 <ImOuttaYourMonad> or tell me something i didnt know
15:05:32 <pumpkin_> ImOuttaYourMonad: sometimes lack of type annotations will push an error to where you wouldn't expect it
15:05:33 <augustss> ImOuttaYourMonad: I think it's good to see what type can be deduced.  sometimes you get surprised
15:05:58 <augustss> But as pumpkin_ says, it's bad for error reporting
15:06:30 <paczesiowa> dons: do you have by any chance, function lines (over bytestrings), working with stream-fusion, laying around?
15:06:36 <ImOuttaYourMonad> but i dont get what the error is about, i have interpret which is mostly a pure fucntion but at ',' it needs input, i was therfore told do interpet in IO.
15:06:45 <ImOuttaYourMonad> there for e i did the do
15:07:17 <ImOuttaYourMonad> can a pure function call an impure one if it is done in main?
15:07:24 <ski> ImOuttaYourMonad : why don't you do `Right ',' -> do ...', then ?
15:07:54 <paczesiowa> ImOuttaYourMonad: main can call impure one and pass result to pure one
15:08:41 <augustss> ImOuttaYourMonad: putting interpret in IO is one way.  A cooler way is to make it a String->String function
15:08:59 <ski> (yes, "pure" functions can call "impure" ones. `id putStr "apa"')
15:09:12 <augustss> ImOuttaYourMonad: then you can do 'main = interact interpret'
15:09:33 <paczesiowa> and party like it is 1985 again
15:09:43 <pumpkin_> lol
15:09:52 <mmorrow> ImOuttaYourMonad: here're two (similar) ways to separate the IO from the pure part:
15:09:58 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=772
15:10:02 <pumpkin_> I'm not sure ImOuttaYourMonad was around in 1985
15:10:05 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2165#a2166
15:10:05 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=839
15:10:06 <ski> (augustss : but then, for more complicated stuff, you want `Cont (String -> String)' ..)
15:10:07 <pumpkin_> I barely aws
15:10:34 <ImOuttaYourMonad> who youc alling apa ski?
15:10:49 <pumpkin_> apa?
15:10:52 <augustss> ImOuttaYourMonad: also, I think using Parsec is overkill.  there is no real parsing involved
15:10:56 <ImOuttaYourMonad> 1993 im born
15:11:27 <ImOuttaYourMonad> is the assembly instruction movl = movleft?
15:11:30 <ImOuttaYourMonad> moveleft
15:11:30 <pumpkin_> ImOuttaYourMonad: brainfuck allows any of the non-code symbols to be present in the code, but it ignores them
15:11:31 <mmorrow> ImOuttaYourMonad: and here's a brainfuck compiler rwbarton wrote that uses harpy to compile to machine code, and then actually builds an ELF .o which you then hand to ld  http://moonpatio.com/repos/brain/
15:11:34 <pumpkin_> no, it's move long
15:11:56 <pumpkin_> no modern assembly behaves like brainfuck
15:11:58 <ski> (ImOuttaYourMonad : noone in particular .. just a common word to fill with)
15:12:19 <ImOuttaYourMonad> well first things first,
15:12:20 <pumpkin_> mmorrow: is it an optimizing compiler?
15:12:39 <vixey> hm
15:12:44 * ski has seen "rolig" as a function name in a research paper :)
15:12:45 <pumpkin_> it'd better not be adding 1 repeatedly :P
15:12:50 <augustss> the brainfuck compiler in the LLVM examples is optimizing
15:12:57 <ImOuttaYourMonad> i want to get this working, the rest is details
15:13:04 <mmorrow> pumpkin_: i added an optimization part that turns a bunch of "inc" instructions into a single "add"
15:13:09 <pumpkin_> ah :)
15:14:18 <mmorrow> i think it's so cool how rwbarton (ab)uses harpy to build a .o
15:15:11 <ImOuttaYourMonad> so if the programs runs into a non-ok symbol I should just move the instruction_pointer to the right?
15:16:18 <mmorrow> i'd just ignore that sym, so if you're interpreting straight from the input i guess yeah
15:16:32 <pumpkin_> mmorrow: he wrote his own elf generator :P
15:16:40 <pumpkin_> mmorrow: what about us poor non-ELFers :(
15:16:43 <mmorrow> pumpkin_: yeah :)
15:16:51 <mmorrow> pumpkin_: i think the term is "SOL"
15:16:52 <harbl> "A brainfuck program is a sequence of these commands, possibly interspersed with other characters (which are ignored)."
15:16:56 <mmorrow> pumpkin: ;)
15:17:04 <ImOuttaYourMonad> but anyway, what am i doing wrong?
15:17:39 <mmorrow> pumpkin_: also, i guess it's linux-specific too, since he passes the args to `syscall' in e{a,b[,c,d]}x
15:17:52 <pumpkin_> epic fail
15:17:54 <pumpkin_> tsk tsk
15:17:56 <ImOuttaYourMonad> Couldn't match expected type `[Char]' against inferred type `IO b'
15:18:01 <mmorrow> pumpkin_: apparently bsd expects them on the stack (as i learned from mauke's hell.s)
15:18:04 <ImOuttaYourMonad>     In a stmt of a 'do' expression:
15:18:04 <ImOuttaYourMonad>         updatedTape <- store tape data_pointer
15:18:24 <augustss> ImOuttaYourMonad: looks like you have monadic and non-monadic code all messed up
15:18:53 <nlogax> at least he's out of your monad now
15:19:00 <pumpkin_> lol
15:19:13 <augustss> Which is why I think you should not use the IO monad
15:19:43 <pumpkin_> ImOuttaYourMonad: the first couple of weeks of me learning haskell involved no IO
15:19:48 <pumpkin_> it's scary stuff!
15:20:03 <ImOuttaYourMonad> yes but im tyring to move out but somehow i need input which means IO
15:20:31 <ImOuttaYourMonad> so I should split and do my own parser and use that if not ',' ?
15:21:37 <travisbrady> anybody have ideas for something fun to implement in Haskell?
15:21:50 <vixey> travisbrady haskell
15:21:54 <wli> s/Germany and// and there's actually a sort of point to it.
15:22:01 <pumpkin_> travisbrady: write us lots of fast fusible stats functions for statistics-fusion! :D
15:22:16 <MarcWeber> travisbrady: You can help enhancing scion .. :)
15:22:19 <paczesiowa> @help tell
15:22:19 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
15:22:34 <wli> What's scion?
15:22:37 <paczesiowa> @tell dons do you have by any chance, function lines (over bytestrings), working with stream-fusion, laying around?
15:22:37 <lambdabot> Consider it noted.
15:22:41 <chessguy> MarcWeber:  scion?
15:22:56 <travisbrady> pumpkin_: i'm definitely going to be doing that
15:23:04 <pumpkin_> travisbrady: yay!
15:23:05 <mle> how do you get cabal to auto-haddock everything before installing it in ~/.cabal?
15:23:16 <MarcWeber> http://github.com/nominolo/scion/tree @ chessguy
15:23:24 <MarcWeber> and wil
15:23:31 <travisbrady> pumpkin_: where is your updated version of the fusion package?  i thought i saw that mentioned in Haskell-Cafe
15:23:42 <chessguy> oooooh
15:23:55 <pumpkin_> travisbrady: it doesn't have much in terms of functionality over the main repo...
15:24:03 <travisbrady> no vim!!  might have to play with that
15:24:04 <wli> What's scion?
15:24:19 <travisbrady> pumpkin_: mostly just memory/performance improvements?
15:24:20 <ImOuttaYourMonad> Right ',' -> do updatedTape <- store tape data_pointer
15:24:20 <ImOuttaYourMonad>                           interpret program (instruction_pointer+1) updatedTape data_pointer resul
15:24:25 <MarcWeber> travisbrady: That's wrong. My branch does support vim. However I've started heavy refactoring..
15:24:26 <ImOuttaYourMonad> whats wrong with that`?
15:24:46 <pumpkin_> travisbrady: no performance, a few minor bug fixes, lots of extra tests, and more haddock, really :)
15:25:02 <MarcWeber> travisbrady: If you're looking for vim support I can explain you my scripts..
15:25:43 <pumpkin_> travisbrady: dons' darcs repo (which is newer than the hackage version) is probably a better bet unless you specifically need something I've added
15:25:50 <travisbrady> MarcWeber: cool, i'll poke around the code a bit first
15:26:32 <wli> Maybe write some sort of system for related documents preprocessed into LaTeX by lhs2TeX can be merged into a single document.
15:27:10 <MarcWeber> travisbrady If you dowload "theonevimlib" you'll get background compilation. Using this branch: http://github.com/MarcWeber/scion/tree/master you'll get some vim support (not very usable yet.. syntax checking does work though..)
15:27:49 <ImOuttaYourMonad> ImOuttaYourMonad performs unsafePerformSuicide
15:28:54 * p_l performs unsafeLearnCOBOL
15:29:14 <gwern> p_l: no, don't do it! you have so much to live for!
15:29:44 * gwern pointedly ignores ImOuttaYourMonad 
15:30:41 <p_l> gwern: I'm interested in legacy systems anyway, and COBOL pays :)
15:30:46 <chessguy> gwern:  umm, i think by saying that, you....didn't
15:31:05 <MotherMonad> My son just made a bloody mess in here, whos gonna clean it up?
15:31:22 <pumpkin_> o.O
15:31:40 <pumpkin_> you're mom cant spel
15:31:42 <gwern> chessguy: well, my alternative was to tell him 'no. stop. don't do it. you have so much to live for', but I didn't think he would get the Edna Krabbaple/Simpsons ref so as to understand the sarcasm and intonation correctly
15:32:33 <jlouis> unsafePerformSuicide? nono
15:37:21 <EvilRanter> unsafePerformKingInYellow?
15:37:33 <lament> heh :)
15:37:54 <MarcWeber> travisbrady I you need any assistance let me know. I'll help you
15:39:01 <ImInYourMonad> but seriously im trying to rewrite the function to not use IO but then I have somehow ask for all the IO first?
15:39:04 <ImInYourMonad> thats ugly
15:39:13 <ImInYourMonad> why cant i do the parsing in IO Monad?
15:39:18 <ImInYourMonad> as is with interpret
15:39:27 <mmorrow> augustss: i take it the darcs repo linked to from the llvm hackage page is no longer being maintained (?)
15:39:46 * mmorrow just built llvm-0.6.5.0
15:40:24 <EvilTerran> ImInYourMonad, you *can* do everything in IO, but IO-less code is generally a lot easier to reason about
15:40:31 <pumpkin_> thoughtpolice: I noticed a generate-c on your github, is that ready for public consumption? do you plan to put it on hackage?
15:41:25 <ImInYourMonad> evilterran: well that is not a problem here and i just want to get it working
15:41:35 <wli> Generating and compiling a zillion numerical type aliases, this might take a while
15:41:46 <mmorrow> hehe, i chuckled at that
15:41:48 <pumpkin_> wow, a whole zillion
15:41:54 <mmorrow> a whole zillion!
15:42:09 <pumpkin_> I want a zillion dollars
15:42:25 <mmorrow> i heard there's this one tree you can get that grows money
15:42:33 * wli seems to be striking out on the prepackaged llvm for gentoo.
15:42:39 <mmorrow> but i'm skeptical
15:42:47 <czShadoW> Zimbabwe dollars?
15:43:10 <mmorrow> czShadoW: i think nigerian maybe
15:43:37 <gnut> If I have a record "data Blah = Blah { st :: Int }" with Reader "Reader Blah a", is there a better way to get st than "b <- ask >>= return st" ?
15:43:52 <BMeph_> edwardk: ping
15:44:04 <ddarius> gnut: asks st
15:44:12 <pumpkin_> the ZWD's inflation is:
15:44:12 <pumpkin_> 231 000 000% (official, July 08)
15:44:12 <pumpkin_> 89.7  1021% (HHIZ, 14 Nov 08)
15:44:12 <pumpkin_> 6.5  10108% (Forbes Asia)
15:44:13 <gnut> ddarius: oh... okay
15:44:17 <mmorrow> "Helo friend, I am prinse of a small tribe in nigeria. I have 4 zillion dollars i need to move to offshore..."
15:44:20 <gnut> ddarius: thanks.. let me look that up
15:44:42 <pumpkin_> that 1021% is actually 10^21%
15:44:46 <pumpkin_> and the other is 10^108%
15:44:56 <mmorrow> heh
15:45:06 <mmorrow> wow
15:45:09 <pumpkin_> http://en.wikipedia.org/wiki/File:ZWDvUSDchart.png
15:45:24 <pumpkin_> it's awesome when your exchange rate has an exponential curve on a logarithmic graph
15:45:30 <mmorrow> lol
15:45:48 <lament> ouch.
15:46:09 <mmorrow> yeah, s/lol/ouch/
15:47:11 <mmorrow> omg, it's like exponentially exponential ^2
15:47:15 <BMeph_> ouchol!
15:47:21 <pumpkin_> lolwut?
15:47:38 <lament> expxponential
15:47:52 <pumpkin_> there's a nice collection of haskellers on github too
15:47:56 <maxote> why don't buy zillions of zimbawuean dollars and sell trillions of trillions of trillions of zimbawuean dollars?
15:48:14 <pumpkin_> omg we haz value of zillion in that sentence
15:48:23 <lament> how many zillions are in a trillion of trillions of trillions?
15:48:34 <pumpkin_> I assumed 1
15:48:42 * mmorrow though 0.0002
15:50:59 * ddarius thought i / ln (-1)
15:51:14 <whoppix> pumpkin, is 1 us dollar really ~1.000.000.000.000.000.000.000.000.000.000 zimbabwean dollar? O_o
15:51:28 <lament> no, they have revalued the currency
15:51:34 <whoppix> At least you never get bored while counting money
15:51:36 <pumpkin_> well every so often they shave a bunch of zeros off it and increment the "currency version?"
15:51:36 <lament> those figures are in "old" zimbabwean dollars
15:51:43 <pumpkin_> whoops, extraneous question mark
15:51:53 <whoppix> pumpkin, haha, greatness
15:52:18 <pumpkin_> I'm used to a few zeros, I grew up with the italian lira!
15:52:20 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2165 <- surely someone has to know what I should do
15:52:36 <mmorrow> (.text+0xcc8): undefined reference to `LLVMGetPointerToGlobal'  :(
15:52:46 * ddarius grew up with the German lira.
15:53:01 <pumpkin_> ImInYourMonad: the line quoted in your error message is a comment
15:53:28 <ImInYourMonad> huh?
15:53:55 <pumpkin_> oh, I see
15:53:56 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2165 at the bottom
15:54:04 <pumpkin_> I was looking at the higher code :)
15:54:42 <pumpkin_> ImInYourMonad: you could stuff return $ in front of all the other cases
15:55:03 <mmorrow> hmm, i guess my llvm lib is too old or something..
15:55:25 * wli is downloading llvm from svn
15:56:18 * mmorrow is too :)
15:57:07 <pumpkin_> haskell needs more 2.0ish people :P
15:57:39 <wli> 2.0 of what?
15:57:51 <p_l> I prefer Web 0.0 :P
15:57:55 <pumpkin_> twitter, github, sans-serif websites with starburst logos and large text
15:58:01 <pumpkin_> !!!
15:58:13 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2165#a2167
15:58:21 <ImInYourMonad>  Occurs check: cannot construct the infinite type: a = m a
15:58:26 <p_l> sans-serif, github and large text is good... can't see anything of value in twitter :)
15:58:44 <pumpkin_> p_l: it's an essential part of the 2.0ness
15:58:51 <pumpkin_> ImInYourMonad: I guess I fail
15:59:05 <tromp_> ImInYourMonad: : you're not testing for 0 on a '['
15:59:16 <pumpkin_> ImInYourMonad: what I said is inherently bad, ignore me :)
15:59:17 * mmorrow looks at ml-risc while llvm builds
15:59:45 <Axman6> ml-risc?
15:59:47 <dmwit> ...the deuce?  You turn a single character into a String, parse the String into a character, then pattern match on the resulting Either?  Rather than just pattern matching on the single character?
15:59:59 <mmorrow> Axman6: http://www.cs.nyu.edu/leunga/www/MLRISC/Doc/html/index.html
16:00:03 <pumpkin_> lol
16:00:09 <Axman6> ta :)
16:00:24 * mmorrow hates C++
16:00:49 <pumpkin_> don't be hatin!
16:00:56 <mmorrow> i ain't scurred!
16:01:12 <maxote> is slower the lazy evaluation than the eager evaluation?
16:01:31 <pumpkin_> maxote: depends :) if you're going to be doing everything anyway, probably
16:01:46 <wli> svn checkout is taking forever here
16:01:52 <pumpkin_> git ftw
16:01:57 <dmwit> ImInYourMonad: You also need to return in the first branch.
16:01:58 <Axman6> maxote: that totally depends on what you're doing
16:02:02 <mmorrow> wli: oh sucky, i'm already make -j5'ing
16:02:22 <pumpkin_> I wanna get that epic sparc machine
16:02:29 <pumpkin_> and make -j64
16:02:32 <mmorrow> haha
16:02:32 <pumpkin_> or more
16:02:35 <dmwit> ImInYourMonad: i.e. in the instruction_pointer >= length program guard.
16:02:36 <Axman6> -j65
16:02:38 <mmorrow> that would be sweet
16:02:43 <pumpkin_> Axman6: ;)
16:02:47 <ImInYourMonad> tromp: i know i will fix that
16:02:49 <Axman6> don;t wanna be wasting time now pumpkin_!
16:03:01 <dmwit> ImInYourMonad: But may I humbly suggest the following tweak, to avoid repeating yourself:
16:03:05 <wli> My cellular modem is not very swift.
16:03:05 <ImInYourMonad> just annoyign that this simple thing isnt fixable
16:03:07 <p_l> pumpkin_: Get a SiCortex PDS... 72xMIPS64 and 48G (or 96G, there are no other options) of RAM :)
16:03:12 <maxote> make -j81, where's the 80 cores CPU?
16:03:14 <pumpkin_> wow
16:03:18 <mmorrow> wli: ouch
16:03:38 <dmwit> case ... of { Left _ -> error ...; Right ',' -> do { ... }; Right x -> return . interpret $ case x of { ... } }
16:03:49 <p_l> pumpkin_: And it's a development workstation for their supercomputers
16:04:01 <p_l> the workstation takes around 300W from the plug
16:04:09 <dmwit> ImInYourMonad: Where the final (...) are the <>+-[]. cases.
16:04:23 <wli> EVDO of like 1MB/s under circumstances which never happen.
16:05:12 <dmwit> ImInYourMonad: I also strongly suggest considering dropping the whole "parse" shenanigans and just pattern matching on (program !! instruction_pointer) instead.
16:05:24 <pumpkin_> yeah, we already suggested that :P
16:05:27 <dmwit> oh
16:05:29 <EvilTerran> ,src ''StateT
16:05:30 <pumpkin_> especially since it's in the "official bf spec"
16:05:35 <lunabot>  newtype StateT i m a = S (i -> m ((a, i)))
16:05:37 <pumpkin_> to ignore all non-instruction chars
16:05:38 <pumpkin_> (as comments)
16:05:55 <dmwit> That issue is orthogonal to the one I'm talking about.
16:06:10 <dmwit> He can still do that in his current architecture.
16:06:16 <dmwit> Anyway.
16:06:20 <mmorrow> EvilTerran: (in case you're like "wtf!!?", lunabot has s/mtl/monadLib/)
16:06:37 <EvilTerran> mmorrow, ah, that makes sense
16:06:48 <pumpkin_> I know he can, but we suggested dropping the parser because it's simpler and allows him to still do the same thing :)
16:06:53 <dmwit> It's also perfectly reasonable to do a parse, but then you should be parsing the entire program and returning an AST -- which would do away with the matchBracket business.
16:06:59 <dmwit> pumpkin_: right
16:11:46 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2168#a2168
16:12:03 <ImInYourMonad> that's what I have now, can't I just make a simple fix?
16:13:57 <EvilTerran> ?hoogle anyChar
16:13:57 <lambdabot> Text.Parsec.Char anyChar :: Stream s m Char => ParsecT s u m Char
16:13:57 <lambdabot> Text.ParserCombinators.Parsec.Char anyChar :: Stream s m Char => ParsecT s u m Char
16:14:12 <dcoutts> mle: did your Q about cabal and haddock get answered?
16:14:40 <EvilTerran> validSymbol = anyChar "<>+-.,[]"
16:15:27 <mmorrow> pumpkin: why is support for arm so absent in code-generators/etc ?
16:16:01 <mmorrow> because arm is usually used with embedded stuff and not computer computers?
16:16:31 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2168#a2169 <- still occurs check
16:17:46 <paczesiowa> ImInYourMonad: drop those returns in all those cases
16:18:05 <paczesiowa> ImInYourMonad: just leave the first one in line no 2
16:19:16 <paczesiowa> ImInYourMonad: in second line you return smth (so result of interpret is m a) and then you call recursively interpret so there is no need to return it again, it's already m a
16:19:44 <paczesiowa> ImInYourMonad: makes sense?
16:20:18 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2168#a2170
16:20:36 <ImInYourMonad> next error :)
16:20:58 <ImInYourMonad> ah wait
16:21:00 <ImInYourMonad> got it
16:21:32 <paczesiowa> ImInYourMonad: again, drop that last return
16:23:00 <mmorrow> wow, mlton can compile itself in < 5 minutes
16:23:16 <mle> dcoutts: no
16:23:33 <chessguy> > show [1,2,3]
16:23:35 <lambdabot>   "[1,2,3]"
16:24:03 <dcoutts> mle: ok, edit your ~/.cabal/config file and uncomment the field about documentation
16:24:20 <mle> Oh!
16:24:23 <chessguy> > foldr (++) "" [1,2,3]
16:24:24 <lambdabot>       No instance for (Num [Char])
16:24:24 <lambdabot>        arising from the literal `1' at <in...
16:24:26 <mle> thanks
16:24:42 <chessguy> > foldr (++) "" . map show $ [1,2,3]
16:24:43 <lambdabot>   "123"
16:24:46 <dcoutts> mle: they all correspond to configure/install flags but the config file is obviously persistent
16:25:03 <dcoutts> mle: so cabal configure/install --help is a good reference
16:25:27 <mle> so I see, thanks
16:26:10 <paczesiowa> >
16:26:19 <paczesiowa> >
16:29:55 <paczesiowa> dcoutts: maybe you can tell me, if there is lines function (over bytestrings) that works with stream fusion?
16:31:59 <wli> mmorrow: llvm doesn't look far from a decent IR
16:32:24 <chessguy> @type intercalate
16:32:25 <lambdabot> forall a. [a] -> [[a]] -> [a]
16:32:35 <chessguy> @src intercalate
16:32:35 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
16:32:45 <wli> mmorrow: SSA's a little irritating, but never mind that.
16:32:52 <chessguy> @src intersperse
16:32:52 <lambdabot> intersperse _   []     = []
16:32:52 <lambdabot> intersperse _   [x]    = [x]
16:32:52 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
16:33:48 <chessguy> > intercalate " " . map show $ [1,2,3]
16:33:49 <lambdabot>   "1 2 3"
16:34:18 <mmorrow> wli: apparently building the sparc backend is borked for my setup or something (default all backends get built), so i'm trying to build now with the sparc backend disabled :/
16:34:39 <mmorrow> (the error was an unknown identifier or some such)
16:34:42 <wli> mmorrow: Suckage. SPARC is enlightening to look at.
16:35:25 <chessguy> > unlines . map (intercalate " " . map show) $ [[1,2,3],[4,5,6]]
16:35:26 <lambdabot>   "1 2 3\n4 5 6\n"
16:35:47 <dcoutts> paczesiowa: there is not, it would need list stream fusion too. It's also nested which makes it much harder.
16:36:31 <chessguy> @index intercalate
16:36:31 <lambdabot> bzzt
16:36:34 <chessguy> @hoogle intercalate
16:36:34 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
16:36:35 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:36:35 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
16:36:51 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2171#a2172 , ok there it is, working. not quite done yet but works now,
16:36:59 <dcoutts> paczesiowa: our stream fusion impl of list used to have a fusible lines but that turned out to be too strict.
16:37:21 <dcoutts> paczesiowa: the standard lines function is quite amazingly lazy
16:37:29 <JohnnyL> chessguy what's the preoccupation in sorting 123456?
16:37:40 <dcoutts> paczesiowa: it yields the line before getting to the end of it
16:37:44 <chessguy> JohnnyL:  i'm not trying to sort it
16:37:45 <JohnnyL> i mean is there a goal in all this #haskell interpreter work?
16:37:56 <Botje> world domination?
16:37:57 <JohnnyL> I mean like will any of it see the day of production code?
16:38:02 <dcoutts> > lines ('a':undefined)
16:38:04 <lambdabot>   ["a* Exception: Prelude.undefined
16:38:06 <chessguy> JohnnyL: sorry, i was being lazy and not taking it to a lambdabot session
16:38:09 <Botje> an army of undead lambdas marching towards the imperative enemy?
16:38:43 <chessguy> JohnnyL: i'm doing a simple implementation of some of the Netpbm protocols
16:39:46 <paczesiowa> dcoutts: I'm not going to pass any bottoms to it, and there'll be plenty of lines (+1m) so yielding before end of one line isn't that important
16:40:09 <paczesiowa> dcoutts: and lines for strings is much more simpler than one for bytestrings
16:40:18 <paczesiowa> *simple
16:40:52 <dcoutts> paczesiowa: ordinary bytestring lines should give reasonable performance, even when not fused
16:41:50 <dcoutts> paczesiowa: we optimised both strict and lazy versions pretty heavily
16:42:14 <mmorrow> JohnnyL: what do you mean "all this #haskell interpreter work"?
16:42:23 <paczesiowa> dcoutts: well, I think I have a problem with the following consumer of lines (mapAccum). so performance is great. but it doesn't fuse with the next function
16:42:50 <paczesiowa> dcoutts: and I can't fuse  mapAccum with foldr/build
16:42:51 <dcoutts> paczesiowa: mapAccum tends to build big closures
16:43:00 <mmorrow> JohnnyL: as in how a bunch of people are writing interpreters? or are you talking about lambdabot..
16:43:25 <dcoutts> paczesiowa: you may just want to use a directly recursive function on the lists of lines
16:45:37 <paczesiowa> dcoutts: it wouldn't fuse either, I'm using this mapAccum: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1790#a1790 and it fuses ok with maximum on the left and enumFrom on the right, no problems with big closures
16:46:33 <mmorrow> gah, i keep running out of disc space while building llvm
16:46:36 <dcoutts> paczesiowa: ok, but you're not going to get it to fuse with lines
16:46:50 * mmorrow has to clean his hard disk
16:47:12 <paczesiowa> dcoutts: why? (besides that lines currently isn't stream-fusion friendly)
16:47:32 <dcoutts> paczesiowa: that's the only reason
16:47:52 <mmorrow> holy crap:
16:47:54 <mmorrow> [m@ganon llvm]$ du -h | tail -1
16:47:54 <mmorrow> 1.2G    .
16:48:01 <mmorrow> no wonder..
16:48:18 <dcoutts> paczesiowa: if you're prepared to write your own bytestring lines that produces a stream of bytestrings then it might work
16:49:00 <paczesiowa> dcoutts: oh:) I'm trying to write it in stream version, but it's hard (all attempts blow the stack).
16:49:53 <paczesiowa> dcoutts: how about little hint (at least acc type for stepper) ?
16:50:06 <dcoutts> paczesiowa: check out the list version
16:50:38 <dcoutts> paczesiowa: I'm a bit suspicious about that mapAccum
16:51:11 <paczesiowa> dcoutts: why?
16:51:22 <dcoutts> paczesiowa: the stepper function it looks too lazy to eliminate the Step constructors
16:51:52 <dcoutts> paczesiowa: have you checked that they get eliminated?
16:53:31 <paczesiowa> dcoutts: no, the only test I did, was maximum . mapAccum f . replicate 1m 0, and f was simple incrementing adder. and that mapAccum was much faster than unfusible foldr/build version
16:54:01 <dcoutts> paczesiowa: perhaps it does work, I'll not believe it till I look at the core though
16:54:03 <ispiked> is there any automatic optimization done in something like: if xform a == xform b then xform a else ... or should I create a local variable for the value of xform a?
16:54:41 <dcoutts> ispiked: there is not, use a local var if the sharing is important
16:55:00 * mmorrow makes disclean and rebuilds after being told (at the end of building!) that the a DEBUG build (the default apparently) is 10x slower than an --enable-optimized build... sigh
16:55:17 <dcoutts> ispiked: adding sharing can make things slower too, which is why ghc does not do it automatically
16:55:19 <paczesiowa> dcoutts: I've seen in stream-fusion all those expose acc, but I figured that, ghc was smart enough in this case
16:55:21 <ispiked> xform is a very simple function (just an alias for fst)
16:55:41 * ispiked googles haskell sharing
16:56:06 <wli> mmorrow: I'm still svn downloading.
16:56:10 <mmorrow> wli: heh
16:56:41 <ImInYourMonad> so brainfuck went into an infinite loop and freezed my computer so i had to restart.
16:56:46 <dcoutts> paczesiowa: have fun, I'm off to bed
16:56:52 <ImInYourMonad> anyone comment on it while i was gone?
16:57:18 <paczesiowa> dcoutts: me too, tomorrow is another day to defeat lines:) thanks for help
16:57:20 <mmorrow> ImInYourMonad: are you on windows?
16:57:26 <ImInYourMonad> yes
16:57:30 <ispiked> thanks, dcoutts
16:57:39 <ImInYourMonad> mmorrow: how did you guess :)
16:57:43 <mmorrow> ImInYourMonad: did it freeze in ghci, or was this compiled code?
16:57:47 * wli considers type systems.
16:57:48 <mmorrow> ImInYourMonad: heh
16:57:49 <ImInYourMonad> ghci
16:58:14 <mmorrow> ImInYourMonad: oh, ok. (on unix you can just ^Z and kill -9)
16:58:32 <JohnnyL> mmorrow i mean like splicing arrays filled with abc 123. rezipping them then spitting them out again in another insane array.
16:58:42 <JohnnyL> chessguy netpbm?
16:59:17 <chessguy> JohnnyL:  http://en.wikipedia.org/wiki/Netpbm_format#PPM_example
16:59:28 <chessguy> JohnnyL:  and they're lists, not arrays
16:59:41 <mmorrow> ImInYourMonad: it's because the bytecode isn't blackholing stuff like compiled code does, so instead of getting a <<loop>>, you just get a hopelessly locked up ghci (and apparently computer too on windows ;)
17:00:05 <chessguy> mmorrow:  what's -9?
17:00:31 <mmorrow> JohnnyL: you mean splicing *lists* filled with abc 123 ;)
17:00:43 <mmorrow> chessguy: -9?
17:00:47 <mmorrow> oh
17:00:52 <mmorrow> SIGKILL
17:00:57 <p_l> mmorrow: Or you have windows set correctly and kill the locked process the same way as on unix ;-)
17:01:04 <mmorrow> kill -9 === kill -KILL
17:01:20 <gwern> FINISH HIM!
17:01:24 <mmorrow> p_1: windows can be "set correctly"?? ;)
17:01:43 <mmorrow> gwern: fatality!
17:02:21 <p_l> mmorrow: can be. However, if they make it the default setting, the only thing they will get will be "Windows ver.X breaks all the programs! It suxxx!!!oneone XP was better" :P
17:03:22 <mmorrow> p_1: "!!!oneone".... lol
17:04:00 <p_l> mmorrow: Can't help it after Vista :P I admit, Vista had a lot of drawbacks, but it actually had important new stuff too... just the kind that most users wouldn't notice
17:04:20 <JohnnyL> mmorrow whatever
17:04:23 <JohnnyL> hey are you one of those tom slick brothers with a wink and a smile?
17:05:00 <mmorrow> JohnnyL: depends on whether that would increase my paypal balance or not ;)
17:05:03 <gwern> @wn cocker
17:05:06 <lambdabot> *** "cocker" wn "WordNet (r) 2.0"
17:05:06 <lambdabot> cocker
17:05:06 <lambdabot>      n : a small breed with a wavy silky hair originally developed in
17:05:06 <lambdabot>          England [syn: {cocker spaniel}, {English cocker spaniel}]
17:05:06 <lambdabot>      v : treat with excessive indulgence; "grandparents often pamper
17:05:08 <lambdabot> [3 @more lines]
17:05:23 <edwardk> p_l: yeah keyed events are very nice, but are practically invisible from outside of the kernel, etc. ;)
17:05:23 <p_l> mmorrow: I remember reading an example story that allowed a company to have global-wide VPN setup with all the stuff working, which was compatible with Linux/Samba etc. but not windows <6.0
17:05:24 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
17:05:44 <edwardk> @seen BMeph
17:05:44 <lambdabot> BMeph is in #haskell-blah, #concatenative, #ghc, #haskell-overflow and #haskell. I don't know when BMeph last spoke.
17:05:54 <gwern> should I be glad my grandparents didn't cocker me?
17:06:35 <JohnnyL> mmorrow the correct answer is: I am smiling.
17:06:47 <chessguy> @all-dict cocker
17:06:48 <lambdabot> *** "Cocker" gcide "The Collaborative International Dictionary of English v.0.48"
17:06:48 <lambdabot> Cocker \Cock"er\, v. t. [imp. & p. p. {Cockered}; p. pr. & vb.
17:06:48 <lambdabot>    n. {Cockering}.] [OE. cokeren; cf. W. cocru to indulge,
17:06:48 <lambdabot>    fondle, E. cock the bird, F. coqueliner to dandle (Cotgrave),
17:06:48 <lambdabot>    to imitate the crow of a cock, to run after the girls, and E.
17:06:50 <lambdabot> [38 @more lines]
17:06:53 <mmorrow> JohnnyL: darnit! that was my next guess
17:06:55 <JohnnyL> @wn schwa
17:06:56 <lambdabot> *** "schwa" wn "WordNet (r) 2.0"
17:06:56 <lambdabot> schwa
17:06:56 <lambdabot>      n : a neutral middle vowel; occurs in unstressed syllables [syn:
17:06:58 <lambdabot>           {shwa}]
17:07:04 <newsham> qua?
17:07:05 <chessguy> @wn cocker
17:07:05 <lambdabot> *** "cocker" wn "WordNet (r) 2.0"
17:07:05 <lambdabot> cocker
17:07:05 <lambdabot>      n : a small breed with a wavy silky hair originally developed in
17:07:06 <lambdabot>          England [syn: {cocker spaniel}, {English cocker spaniel}]
17:07:08 <lambdabot>      v : treat with excessive indulgence; "grandparents often pamper
17:07:10 <lambdabot> [3 @more lines]
17:07:22 <p_l> @more
17:07:23 <lambdabot>          the children"; "Let's not mollycoddle our students!"
17:07:23 <lambdabot>          [syn: {pamper}, {featherbed}, {cosset}, {baby}, {coddle},
17:07:23 <lambdabot>           {mollycoddle}, {spoil}, {indulge}]
17:07:25 <JohnnyL> oh well maybe someone will put a Urban Dictionary up in this bitch.
17:07:40 <newsham> the bot takes msgs
17:07:42 <chessguy> @list
17:07:42 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:07:44 <mmorrow> JohnnyL: write a lambdabot plugin
17:08:10 <chessguy> @jargon fool
17:08:10 <lambdabot> *** "fool" jargon "Jargon File (4.3.1, 29 Jun 2001)"
17:08:10 <lambdabot> fool n. As used by hackers, specifically describes a person who
17:08:10 <lambdabot>    habitually reasons from obviously or demonstrably incorrect premises and
17:08:10 <lambdabot>    cannot be persuaded by evidence to do otherwise; it is not generally
17:08:10 <lambdabot>    used in its other senses, i.e., to describe a person with a native
17:08:12 <lambdabot> [13 @more lines]
17:08:28 <chessguy> heh
17:08:44 <chessguy> "you, sir, are a person who habitually reasons from obviously or demonstrably incorrect premises"
17:08:46 <edwardk> @tell bmeph the old slipwave.info stuff is at http://comonad.com/tiddly.php tab over to All on the right to see the full list.
17:08:47 <lambdabot> Consider it noted.
17:08:53 <p_l> @jargon chainik
17:08:53 <lambdabot> No match for "chainik".
17:08:57 <p_l> @jargon kettle
17:08:57 <lambdabot> No match for "kettle".
17:08:59 <gwern> @quote fool
17:08:59 <lambdabot> lament says: Bullies at school used to tease little Huet: "Hey fool, your zipper's undone and the monad's sticking out!"
17:09:10 <chessguy> hahahaha
17:09:23 <chessguy> wow
17:09:26 <p_l> damn, I can't recall the exact name for the kettle jargon entry
17:09:48 <chessguy> @jargon jargon
17:09:48 <lambdabot> No match for "jargon".
17:10:57 <ImInYourMonad> basically, compile = generate machine code, interpret = transform text?
17:11:49 <chessguy> > foldl' f [1,2,3]
17:11:51 <lambdabot>       Overlapping instances for Show ([b] -> [t])
17:11:51 <lambdabot>        arising from a use o...
17:11:57 <wolverian> compile = change the program into something else, interpret = interpret the program as instructions
17:12:08 <chessguy> > foldl' f 0 [1,2,3] :: Expr
17:12:10 <lambdabot>   f (f (f 0 1) 2) 3
17:12:28 <wolverian> for an example, perl compiles the input script into bytecode, which it then interprets.
17:12:48 <wolverian> on the other hand, ghc compiles haskell into machine code, which the processor interprets.
17:13:08 <gwern> @quote ket
17:13:08 <lambdabot> ghc says: Exotic Stmt in meta brackets
17:13:14 <gwern> @quote kett
17:13:15 <lambdabot> No quotes match. You speak an infinite deal of nothing
17:13:36 <ddarius> @quote kmett
17:13:36 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:17:56 <ImInYourMonad> Java is interpreted?
17:18:21 <wli> Yes. It's called a bytecode interpreter.
17:19:04 <ddarius> In practice Java is compiled to JVM bytecode which is then usually both interpreted and also compiled to machine code.
17:19:57 <edwardk> @quote edwardk
17:19:58 <lambdabot> edwardk says: notes that in haskell, it seems that you asymptotically approach writing no code over time as you learn your way around whats already there
17:19:59 <chessguy> @hoogle testBit
17:19:59 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
17:20:35 <edwardk> ddarius: nothing in there under kmett
17:26:19 * wli looks at various ways to handle extensible records and/or variants.
17:30:28 <ispiked> is there as nice way for asserting that arguments are of a specific length before entering the body of a function?
17:30:39 <ispiked> especially a recursive one...
17:30:48 <Zao> ispiked: What kind of length?
17:31:00 <Zao> You can use guards.
17:31:05 <ispiked> Zao: I want to make sure a list is a specific length
17:31:40 <ispiked> but won't the guard catch it on the recursive call where the length has been shortened?
17:31:41 <Zao> f x | length x == 42 = "pie"
17:31:49 <Zao> Well, yes.
17:32:18 <Zao> Either verify it in a setup function before going into recursion or build it into your recursion.
17:32:21 <ispiked> it just seems silly to have to check the args, then define some recursive sub-function that has the same signature has the main function
17:33:07 <drhodes> is there a scientific notation module out there? didn't see one on hackage.
17:37:59 <Eridius> out of curiosity, is it possible to get a real-world job doing Haskell programming?
17:38:18 <Zao> Sure.
17:38:28 <sm> if you're good..
17:38:32 <Zao> http://www.haskell.org/haskellwiki/Haskell_in_industry
17:39:46 <Eridius> huh, http://www.ansemond.com/ is a bit odd. if that's actually implemented in Haskell, seems kinda odd since interacting with the UI would be far more complicated than storing data in a database
17:41:56 <Eridius> heh, http://article.gmane.org/gmane.comp.lang.haskell.cafe/21951 is amusing considering that HAppS is now orphaned
17:43:08 <Eridius> I guess I should be more specific - I don't suppose it's possible to get a real-world job doing Haskell programming on something other than finance sites while living in San Francisco? ;)
17:43:28 <Zao> While standing on one leg and waving a flag?
17:43:41 * Eridius chuckles
17:44:14 <Eridius> my real expertise is Mac/iPhone development using Cocoa, but I'm getting more and more interested in Haskell, to the tune of I've now spent 7 hours hacking on yi today
17:44:23 <shapr> Eridius: I don't know anyone hiring Haskellers in SF, but there are at least five companies in Boston.
17:44:25 <Eridius> I was just curious if it was actually possible to get a real job in Haskell
17:44:29 <Eridius> shapr: hah, I moved here from MA :P
17:44:35 <shapr> oh well :-)
17:44:39 * dancor gets to do some haskell at work in palo alto webdev..
17:44:54 <Eridius> I moved here because that's where Apple is, and I'm trying to get hired there but it's hard (they're not doing very much hiring at the moment, and they always hire internally before externally)
17:44:57 <shapr> Eridius: You're missing the Boston Area Haskell User's Group!
17:45:03 <Eridius> *gasp*
17:45:19 <Eridius> in theory there's an SF Haskell Users Group, but the blog for the one I could find shows no activity in over a year
17:45:28 <shapr> So, organize it?
17:45:31 <Eridius> someone here earlier today said they went to a SF Users group last night, but he couldn't remember where he saw the info
17:45:32 <shapr> bos31337 is in SF
17:54:54 <ImInYourMonad> how do I do listcomprehensiosn with condition
17:55:07 <ImInYourMonad> dict((s, [u for u in unitlist if s in u]) for s in squares)
17:55:42 <ImInYourMonad> > [u | u <- [1,2,3]]
17:55:44 <lambdabot>   [1,2,3]
17:55:57 <ImInYourMonad> > [u*u | u <- [1,2,3]]
17:55:58 <lambdabot>   [1,4,9]
17:56:10 <Eridius> you add , condition
17:57:06 <gnut> what's a good way to set the default value of a record in terms of the other values? i.e., "data Blah = { a :: Int; b :: Int }" but I'd like b = a ?
17:57:32 <gnut> oops... forgot the data constructor... but you know what I mean :)
17:57:33 <ImInYourMonad> > [u | u <- [1,2,3]; x < 10]
17:57:34 <lambdabot>   <no location info>: parse error on input `;'
17:57:49 <ImInYourMonad> > [u | u < 10 <- [1,2,3]]
17:57:49 <Botje> comma not semicolon
17:57:50 <lambdabot>   <no location info>: Parse error in pattern
17:57:55 <ImInYourMonad> > [u | u <- [1,2,3], x < 10]
17:57:56 <lambdabot>   []
17:58:04 <ImInYourMonad> > [u | u <- [1,2,3], u < 10]
17:58:05 <lambdabot>   [1,2,3]
17:58:12 <ImInYourMonad> why doesnt it complian on x there?
17:58:18 <drhodes> > x
17:58:18 <Botje> no idea
17:58:19 <lambdabot>   x
17:58:25 <Botje> probably because x is already defined
17:58:26 <Eridius> gnut: write a function that's used to construct a Blah
17:58:27 <drhodes> :t x
17:58:28 <lambdabot> Expr
17:58:39 <gnut> Eridius: hmmm... okay..
17:59:31 <drhodes> gnut: I was told to use lower case name for the constructor, so "blah"
18:00:19 <gnut> drhodes: it has to be uppercase if it's a type or data constructor.
18:01:05 <Eridius> gnut: he may have meant for the function that creates a Blah
18:01:44 <drhodes> default constructor will be a function which must start with a lower case letter, unless I misunderstood your query in which case I retract my previous statement.
18:02:18 <gnut> oh okay. my apologies then.
18:02:26 <Eridius> drhodes: he's confused because you're using the term "constructor" in a different way than he expected
18:02:30 <gnut> I thought you meant the part I was missing.
18:02:36 <drhodes> ahah!
18:02:39 <Eridius> you're using it to mean a function which constructs a value, whereas he's thinking of Blah as a constructor
18:02:42 <gnut> yeah...
18:04:28 <mynameisjoser> hi guys, still new to haskell.  i was wondering what are the tradeoffs of let and where, and when is it appropiate to use one or the other
18:05:00 <Eridius> mynameisjoser: there's no hidden tradeoffs. It's entirely about scoping
18:05:54 <mynameisjoser> is there a time when you can use one but not the other?
18:06:49 <mynameisjoser> oh i just found http://www.haskell.org/haskellwiki/Let_vs._Where
18:07:32 <ddarius> mynameisjoser: They are not even in the same syntactical class.
18:08:27 <mynameisjoser> ddarius: could you elaborate?
18:08:53 <ddarius> let expressions are expressions, where clauses are part of the function definition syntax
18:08:57 <Eridius> mynameisjoser: that page you linked mentions it in the second paragraph
18:10:31 <mynameisjoser> ahhh okay.  i was wondering how the where clause was modeled in lambda calculus
18:12:45 <ImInYourMonad> [a | a <- b, b <- [1..10]]
18:12:49 <ImInYourMonad> > [a | a <- b, b <- [1..10]]
18:12:51 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Expr'
18:13:05 <ImInYourMonad> > [a | b <- [1..10], a <- b]
18:13:06 <lambdabot>       No instance for (Enum [t])
18:13:06 <lambdabot>        arising from the arithmetic sequence ...
18:13:09 <ImInYourMonad> > [a | a <- b, b <- [1..10]]
18:13:10 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Expr'
18:13:22 <ImInYourMonad> > [a | a <- [1..10]]
18:13:23 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:13:34 <ImInYourMonad> > [a | a <- [1..10]]
18:13:35 <ImInYourMonad> peers = dict((s, set(s2 for u in units[s] for s2 in u if s2 != s))
18:13:35 <ImInYourMonad> --              for s in squares)
18:13:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:13:40 <ImInYourMonad> peers =
18:13:40 <ImInYourMonad>     M.fromList [(s, S.fromList [[s2 /= s | s2 <- u, u <- units M.! s,
18:13:40 <ImInYourMonad>                                  s2 <- u]]) | s <- squares]
18:13:43 <ImInYourMonad> fhfjfh
18:13:54 <ImInYourMonad> not do I turn that python expression into haskell?
18:14:07 <edwardk> @seen Peaker
18:14:08 <lambdabot> I saw Peaker leaving #haskell-blah and #haskell 3h 33m 32s ago, and .
18:15:08 <ImInYourMonad> damn why do people use supercomplicated listcomprehensions
18:15:26 <Mailas> i dont know
18:15:29 <Mailas> why do they?
18:17:37 <ImInYourMonad> becasue those pythonists think they are a fancy bunch
18:21:53 <chessguy> @type getArgs
18:21:54 <lambdabot> Not in scope: `getArgs'
18:22:03 <chessguy> @hoogle getArgs
18:22:03 <lambdabot> System.Environment getArgs :: IO [String]
18:22:36 <dolio> Fancy lads?
18:22:54 <Olathe> > [a | b <- map (:[]) [1..10], a <- b]
18:22:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:23:35 <Olathe> > [a | b <- [[zomg] | zomg <- [1..10]], a <- b]
18:23:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:24:16 <Olathe> @undo [a | b <- [[zomg] | zomg <- [1..10]], a <- b]
18:24:16 <lambdabot> concatMap (\ b -> concatMap (\ a -> [a]) b) concatMap (\ zomg -> [[zomg]]) [1 .. 10]
18:24:58 <dolio> http://www.youtube.com/watch?v=-29wqgRdN1U
18:34:05 <ImInYourMonad> either is very neat :)
18:46:34 <gwern> whoa, what's twb doing to the darcs wiki that makes it 1.2gigs of content?
18:50:56 <tehgeekmeister> is there some sneaky way to prevent code i'm testing from slowing my system down insanely when i write a nasty memory leak in on accident?
18:51:17 <omnihil> tehgeekmeister, install more RAM.
18:51:40 <tehgeekmeister> omnihil: that just makes it take a bit longer
18:51:43 <tehgeekmeister> i have 2gb
18:52:26 <thoughtpolice> resource limits?
18:52:30 <Olathe> You can try reducing the priority.
18:52:57 <Eridius> Olathe: that'd be if it was pegging CPU
18:53:01 <Eridius> he's worried about memory
18:53:22 <Eridius> maybe you can use ulimit
18:53:58 <wli> Get the latest Linux and use memory controller patches?
18:54:32 <tehgeekmeister> wli: but how will i run my nice pretty osx apps on the newest linux?!
18:54:44 <jmcarthur> tehgeekmeister: check up on ghc's RTS flags
18:54:52 <jmcarthur> there should be a way to limit heap size
18:54:59 <wli> OS X? Sorry, I'm clueless.
18:55:06 <p_l> tehgeekmeister: use ulimit/rlimit
18:55:18 <p_l> consult system documentation on exact syntax
18:55:30 <p_l> quite often man ulimit does *not* give you proper info
18:55:50 <tehgeekmeister> p_l: yeah, it doesn't for me, i'm finding the right docs
18:56:13 <Eridius> `help ulimit`
18:56:17 <ikkebr> what the function that unnests a nested list? [1,[2,[3]],[4,5]] becomes [1,2,3,4,5]
18:56:40 <Eridius> ikkebr: that's not a well-typed value
18:57:00 <Eridius> @hoogle [[a]] -> [a]
18:57:01 <lambdabot> Prelude concat :: [[a]] -> [a]
18:57:01 <lambdabot> Data.List concat :: [[a]] -> [a]
18:57:01 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
18:57:23 <ikkebr> > hoogle [[1,2],[3,4],5]
18:57:24 <lambdabot>   Not in scope: `hoogle'
18:57:27 <p_l> tehgeekmeister: You can write a small C app (or use FFI calls/some native haskell lib forit at the beginning of your program) and call setrlimit for RLIMIT_AS
18:57:30 <Eridius> o_O
18:57:32 <Gracenotes> @type [1,[2,[3]],[4,5]]
18:57:33 <lambdabot> forall t. (Num t, Num [t], Num [[t]]) => [[[t]]]
18:57:38 <Eridius> o_O
18:57:50 <Gracenotes> okay, it gets a bit messy with numbers
18:58:06 <Eridius> @type [x,[x,[x]],[x,x]]
18:58:07 <lambdabot>     Couldn't match expected type `Expr' against inferred type `[a]'
18:58:07 <lambdabot>     In the expression: [x, [x]]
18:58:10 <Eridius> heh
18:58:15 <Gracenotes> or even with booleans...
18:58:15 <Eridius> that's a more useful error
18:58:17 <Gracenotes> > [True,[False,[True]],[True,False]]
18:58:18 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
18:58:22 <Gracenotes> @type [True,[False,[True]],[True,False]]
18:58:23 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
18:58:23 <lambdabot>     In the expression: [False, [True]]
18:58:36 <p_l> @hoogle setResourceLimit
18:58:36 <lambdabot> No results found
18:59:06 <Gracenotes> ikkebr: anyway... the not-terribly-well-communicated point is that lists are homogeneous. Every element in a list has to be the same type
18:59:18 <p_l> tehgeekmeister: If you want to limit from haskell, System.Posix.Resource is your friend
18:59:35 <Eridius> how come hoogle doesn't have any info on the unix package?
18:59:38 <tehgeekmeister> p_l: hmm, no, don't want to from haskell, but good to know about
18:59:48 <Gracenotes> ikkebr: in [[1,2],[3,4],5], there are three elements in the list: [1,2] and [3,4] and 5
19:00:01 <Gracenotes> the first two elements are lists, but the third element isn't. That's not quite allowed.
19:00:14 <p_l> tehgeekmeister: setrlimit/getrlimit are like some ancient, forgotten concepts nowadays in linux/OS X
19:00:26 <Gracenotes> so a list like [[1,2],[3,4],[5]] *is* legal. Every element of the list is also a list of numbers
19:00:29 <Gracenotes> > concat [[1,2],[3,4],5]
19:00:30 <lambdabot>       No instance for (Num [t])
19:00:30 <lambdabot>        arising from the literal `5' at <inter...
19:00:34 <Gracenotes> > concat [[1,2],[3,4],[5]]
19:00:35 <Eridius> the RTS flag -Msize sets the maximum heap size to _size_ bytes
19:00:35 <lambdabot>   [1,2,3,4,5]
19:01:00 <Eridius> tehgeekmeister: 
19:01:04 <p_l> tehgeekmeister: users of other *nix systems don't chase after "fancy new library of the week" for basic system functionality :D
19:01:05 <tehgeekmeister> Eridius: oooh thanks
19:01:12 <Eridius> found it on http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-optinos-environment
19:01:34 <Eridius> so I believe you run your program and just add +RTS -Msize to the end
19:01:54 <tehgeekmeister> yeah i've had a few times recently that my code has stopped my system for a good ten minutes straight
19:02:01 <tehgeekmeister> before i could manage to kill it
19:02:06 <olsner> for a while there I thought "ooh, is there an "optinos environment" you can enable in the RTS?"
19:02:25 <olsner> ... then I realized someone had just misspelled options in the anchor name
19:02:41 <Eridius> haha
19:04:23 <p_l> tehgeekmeister: I don't know about OS X, but I'd recommend disabling overcommit too :)
19:04:40 <tehgeekmeister> p_l: overcommit?
19:05:11 <p_l> tehgeekmeister: a "feature" of some systems that make them return success on memory allocation even though there's no guaranteed memory to back it
19:05:24 <tehgeekmeister> feature?!
19:05:25 <p_l> it's done in hopes that the application wouldn't actually use it
19:05:28 <Eridius> o_O
19:06:11 <tehgeekmeister> huh, so colloquy says that when i use my iphone?  good to know
19:06:31 * Eridius chuckles
19:06:59 <Eridius> I don't get the point of IRCing from your iPhone. I wouldn't want to type that much on a mobile device, especially since I'd have to keep Colloquy running to stay logged in
19:07:00 <p_l> tehgeekmeister: Well, given how linux ignores MAP_NORESERVE in mmap (which should give you the mapping only, without memory, which should be allocated when you actually _write_ to it), it's the only way for me to run some of lisp implementations
19:07:34 <tehgeekmeister> Eridius: it's useful in rare situations
19:07:53 <tehgeekmeister> Eridius: i've used it for asking math questions i can't easily lookup in google because of notation or summat
19:08:05 <Eridius> heh
19:08:42 <p_l> jailbreak your phone -> install maxima -> have your math questions cut in half :P
19:09:12 <tehgeekmeister> baaah i like my iphone how it is
19:09:13 <Eridius> maxima?
19:09:16 <p_l> though I don't know if you can get maxima running on iphone
19:09:26 <p_l> Eridius: the granddaddy of computer algebra systems
19:09:30 <Eridius> ah
19:09:34 <p_l> Eridius: available as free software
19:10:46 <wli> It's not very good compared to modern commercial CAS's. :(
19:11:38 <p_l> wli: But it's free
19:11:54 <p_l> (including as in beer, which is important for a poor student)
19:13:36 <gnut> can you program iphone apps in haskell?
19:13:46 <tehgeekmeister> gnut: not from what i understand
19:13:58 <tehgeekmeister> gnut: i hear you can only really use objective c =/
19:14:04 <Eridius> if someone wants to teach GHC how to emit ARM code, then you might possibly be able to do it with HOC
19:14:06 <Eridius> ;)
19:14:08 <gnut> ah..
19:14:38 <p_l> I heard that someone ported recent GHC to work on arm, though not with ngc
19:14:38 <tehgeekmeister> that is why i will not write an iphone app, i do not want to use objective c that much
19:14:40 <gnut> when the Atom eventually comes out, wouldn't ghc need to compile into ARM?
19:14:45 <Eridius> tehgeekmeister: most of the APIs on the iPhone are Obj-C, so if you're not using Obj-C you can't do, well, anything
19:14:58 <Eridius> tehgeekmeister: really? obj-c is quite nice
19:15:07 <p_l> also, be happy that it's objective-c, not C++
19:15:31 <tehgeekmeister> Eridius: i don't know all that much about obj c, but i don't like what i know so much.  i should probably learn it someday, but haskell is my focus for now
19:15:40 <Eridius> heh
19:15:50 <Eridius> if you want to ever write anything with a GUI, Obj-C > Haskell :P
19:16:30 <p_l> now, if Etoile guys decided to finish their RTL for Objective-C and bring it up to match Apple's 2.0 RTL
19:18:15 <p_l> afaik one of Etoile devs once devoted 48h to write an Objective-C base library from scratch...
19:18:44 <ImInYourMonad> if doing prolog in haskell what is your recommended approach?
19:18:56 <ImInYourMonad> can I query cabal for a specific package?
19:20:01 <Eridius> cabal list, or cabal info?
19:20:21 <wli> logict
19:24:33 <chessguy> hmph
19:24:43 <chessguy> i've got my little automata-thing spitting out PBMs
19:25:30 <chessguy> but i can't get anything to read/convert them
19:32:26 <tehgeekmeister> kinda more a math question but i can only think of how to express it in haskell: given (\(i,j) -> (j,j+i)), is there a way (just using my head) to extract an expression for each part of the tuple at the nth iteration of the process?
19:33:50 <Eridius> just using your head? You mean, you want an static expression that evaluates to the nth iteration of that expression?
19:34:20 <ImInYourMonad> if i have to Either more than 2 types?
19:34:27 <Eridius> I would just write out a few of the steps and try and determine a pattern
19:34:40 <Eridius> ImInYourMonad: if you have more than 2 options, you'll have to write your own type that acts like Either
19:35:00 <chessguy> > map snd . take 10 $ iterate (\(i,j)->(j,j+1)) (1,1)
19:35:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:35:18 <Eridius> data MotiesEither a = Left a | Right a | GrippingHand a
19:35:19 <chessguy> > map snd . take 10 $ iterate (\(i,j)->(j,j+i)) (1,1)
19:35:20 <lambdabot>   [1,2,3,5,8,13,21,34,55,89]
19:35:41 <chessguy> that looks familiar :)
19:35:45 <Eridius> haha
19:36:14 <chessguy> i take it you're not starting from (1,1) though
19:36:14 <tehgeekmeister> Eridius: yeah
19:36:22 <Eridius> > map snd . take 10 $ iterate ((\i,j) -> (j,j+i)) (0,1)
19:36:23 <lambdabot>   <no location info>: parse error on input `,'
19:36:26 <tehgeekmeister> Eridius: and i want a method to do it in general
19:36:29 <Eridius> oops, what'd I typo?
19:36:29 <Philippa_> Eridius: they have to hold the same thing in each hand?
19:36:45 <Philippa_> (though I guess it makes it obvious what fmap should do!)
19:36:48 <tehgeekmeister> Eridius: i know how to do it in haskell brute force.  i want to manipulate that process.
19:36:51 <lifflander> Hey, guys. I'm trying to convert an Int to hex. Is there a library function for this?
19:36:53 <chessguy> > map snd . take 10 $ iterate (\(i,j)->(j,j+i)) (0,1)
19:36:54 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
19:36:54 <tehgeekmeister> Eridius: into an expression
19:36:55 <Eridius> Philippa_: heh, oops
19:37:08 <tehgeekmeister> (everyone will have noticed it's the fibonacci sequence.)
19:37:09 <Eridius> tehgeekmeister: sounds like you want a general solution to the fibonnaci sequence ;)
19:37:35 <Eridius> lifflander: try looking in Data.Char
19:37:43 <lifflander> Okay, thanks.
19:37:50 <ImInYourMonad> @src either
19:37:50 <lambdabot> either f _ (Left x)     =  f x
19:37:50 <lambdabot> either _ g (Right y)    =  g y
19:37:57 <ImInYourMonad> @src Either
19:37:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:38:19 <Eridius> Data.Char.intToDigit converts a number from the range of 0..15 to a single hex digit
19:38:32 <Eridius> ,src ''Either
19:38:35 <lunabot>  data Either a b = Left a | Right b
19:38:47 <Eridius> data MotiesEither a b c = Left a | Right b | GrippingHand c
19:39:00 <Eridius> of course you can't use that definition without hiding Either
19:39:10 <Eridius> so you should pick some suitable other name
19:39:37 <Eridius> lifflander: you might be more interested in Numeric.showHex
19:40:53 <tehgeekmeister> Eridius: hmm.  okay, so that's probably not doable.  =P  what i'm more interested in, i guess, is a way to prove the relation between that transformation and a sequence/set, then.
19:41:04 <tehgeekmeister> (or a relation in general.)
19:41:29 <lifflander> Right, I just searched the Data.Char and there is no function to hex.
19:41:41 <Eridius> lifflander: there is intToHex but that just produces a single hex digit
19:41:54 <Eridius> tehgeekmeister: if you have a concrete sequence, it seems like all you need to do is find the inputs to that transformation that produces the sequence
19:42:14 <lifflander> Right.
19:42:23 <Eridius> I would do that by producing a few steps from that transformation as expressions, then use those as constraints to find values for i and j that satisfy them
19:42:36 <Eridius> might be programmable in an environment like Mathematica
19:42:55 <ImInYourMonad> '\n' + '+'.join(['-'*(width*3)]*3) , how do I do that in haskell?
19:43:02 <ImInYourMonad> @src intersperse
19:43:03 <lambdabot> intersperse _   []     = []
19:43:03 <lambdabot> intersperse _   [x]    = [x]
19:43:03 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
19:43:11 <ImInYourMonad> @src intercalate
19:43:11 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
19:44:04 <Eridius> ImInYourMonad: what part of that don't you know how to do?
19:44:40 <Eridius> > let width = 4 in replicate (width*3) '-'
19:44:42 <lambdabot>   "------------"
19:44:56 <tehgeekmeister> oh!  induction is what i wanted.  i'm silly sometimes.
19:45:06 <Eridius> heh
19:46:09 <tehgeekmeister> (0,1) == two initial values of the fibonacci sequence
19:46:26 <ImInYourMonad> the joinpart
19:46:45 <Eridius> ok, so you have a list of 3 strings. you'll need intercalate to join
19:47:14 <gwern> > readHex "F"
19:47:15 <lambdabot>   [(15,"")]
19:47:28 <gwern> > readHex "1F"
19:47:29 <lambdabot>   [(31,"")]
19:47:36 <gwern> > readHex "1Fa"
19:47:38 <lambdabot>   [(506,"")]
19:47:46 <gwern> hur
19:47:51 <gwern> oh right, a is valid hex
19:47:53 <gwern> > readHex "1Fz"
19:47:55 <lambdabot>   [(31,"z")]
19:48:24 <ImInYourMonad> > intercalate '+' (replicate (3*3) '-')
19:48:26 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
19:48:29 <gwern> figured as much. still, that's very strange - one would expect something more like (Num a, Maybe String), not [(Num a, String)]
19:48:55 <Eridius> gwern: it's how ReadS works
19:48:58 <mmorrow> thoughtpolice: how's ml-risc going?
19:49:18 <gwern> @hoogle ReadS
19:49:18 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
19:49:18 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
19:49:18 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
19:49:21 <Eridius> it returns a number of potential parsings (readHex only returns one, but some ReadS's can return multiple). Each parsing is a tuple that contains (data, rest_of_string)
19:49:41 <ImInYourMonad> > intercalate '+' (replicate (3*3) '-')
19:49:42 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
19:49:47 <ImInYourMonad> @type intercalate
19:49:48 <gwern> Eridius: but what's wrong with Maybe? seems better than overloading on ""
19:49:48 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:49:53 <Eridius> so if you're going to use it directly you usually just pattern match against [(a, _)]
19:50:00 <Eridius> gwern: it's not an overloading
19:50:07 <Eridius> it's a simple definition - that's the remainder of the string after the parse
19:50:08 <mmorrow> > intercalate "+" (replicate (3*3) '-')
19:50:09 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
19:50:14 <mmorrow> gah
19:50:17 <Eridius> why use Maybe when the empty string is sufficient?
19:50:21 <chessguy> > intercalate "olo" (repeat "l")
19:50:22 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
19:50:27 <mmorrow> there we go
19:50:30 <wli> LLVM/Util/Arithmetic.hs:208:4:
19:50:30 <wli>     Illegal signature in pattern: Function (a -> IO b)
19:50:30 <wli>         Use -XPatternSignatures to permit it
19:50:35 <Eridius> ImInYourMonad: in your example you wanted intersperse
19:50:43 <Eridius> but in the python you pasted, it was a list of strings, not just a string
19:50:46 <mmorrow> wli: what ghc are you on?
19:50:49 <wli> mmorrow: How'd you get past that?
19:50:55 <wli> 6.8.3
19:50:57 <Eridius> > intercalate "+" $ replicate 3 $ replicate (width*3) '-'
19:50:57 <lifflander> I need to view my signed Int as an unsigned Int?
19:50:58 <lambdabot>   Not in scope: `width'
19:51:05 <Eridius> > let width = 4 in intercalate "+" $ replicate 3 $ replicate (width*3) '-'
19:51:06 <lambdabot>   "------------+------------+------------"
19:51:22 <mmorrow> i didn't have to, since i'm on 6.10.1. i think the issue is that the flag to enable that is different
19:51:24 <Eridius> lifflander: hex output is traditionally unsigned
19:51:25 <gwern> lifflander: you mean take the absolute value of the integer?
19:51:40 <mmorrow> err, not different per se, but that's just covered by a different flag now iirc
19:51:41 <lifflander> No not the absolute value.
19:51:41 <wli> Oh crap.
19:51:43 <Eridius> lifflander: what's your use case here?
19:52:06 <mmorrow> wli: i guess you can just add PatternSignatures to the extensions: field in the .cabal
19:52:19 <lifflander> I need actually see the hex value for the register without translating the sign bit.
19:52:21 <gwern> or do a LANGUAGE pragma in the file
19:52:25 <mmorrow> or just kill this fly with the -fglasgow-exts hammer
19:52:36 <Eridius> lifflander: "the register"?
19:52:48 <lifflander> It's for a bit manupulation calcuator.
19:52:50 <Eridius> lifflander: maybe you should be working with more explicit numeric types, like the ones offered by Data.Word
19:52:55 <wli> i used the -fglasgow-exts hammer.
19:53:02 <mmorrow> hehe, nice
19:53:16 <lifflander> Can I convert the Int to a Word and then view it as such?
19:53:29 <Eridius> why do you have an Int in the first place?
19:53:31 <mmorrow> fromIntegral
19:53:55 <Eridius> mmorrow: how does that work when converting from a negative Int to an unsigned Data.Word type?
19:54:07 <Eridius> Data.Word.Word is the unsigned equivalent of Int
19:54:15 <mmorrow> , fromIntegral (-42 :: Int) :: Word
19:54:17 <lunabot>  4294967254
19:54:25 <lifflander> Let me try...
19:54:30 <lifflander> In my program...
19:54:34 <Eridius> mmorrow: ok, that looks good
19:54:50 <mmorrow> , let foo = fromIntegral . max 0 :: Int -> Word in foo (- 42)
19:54:52 <lunabot>  0
19:55:49 <Eridius> > (flip showHex) "" $ (fromIntegral (-42 :: Int) :: Word)
19:55:50 <lambdabot>   "ffffffffffffffd6"
19:56:46 <wli> cabal install --flags="-fglasgow-exts -XPatternSignatures" --global llvm isn't doing it :(
19:58:11 <lifflander> Is a Word 32-bits for 64-bits or is that machine dependant?
19:58:51 <MyCatVerbs> lifflander: machine dependant.
19:59:29 <MyCatVerbs> lifflander: Int is, too. If you want an exact size, use Word8, Word16... or Int8, Int16...
19:59:33 <Eridius> Data.Word.Word is the same size as Int
19:59:33 * chessguy sighs
19:59:41 <Eridius> lifflander: it sounds like you should be using an exact size
19:59:59 <chessguy> i really didn't expect the reading/converting these PGM files to be harder than writing the automata part :(
20:00:00 <Eridius> I take it you're writing a virtual machine, probably as a homework assignment for a college CS course?
20:00:24 <Eridius> chessguy: why is reading PGM files hard?
20:00:35 <chessguy> Eridius:  i can't find a program that will do it
20:00:47 <Eridius> ..what is a PGM file?
20:00:51 <chessguy> heh
20:00:53 <lifflander> Thanks.
20:00:58 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2177#a2177 <- big hug to anyoen that can translate that into haskell
20:01:01 <Eridius> ah, Portable Grey Map?
20:01:12 <chessguy> yeah
20:01:17 <Eridius> I assume it's a relative of PPM? That shouldn't be hard to write your own parser
20:01:31 <ImInYourMonad> hsp-0.4.5 depends on haskell-src-exts-0.4.8 which failed to install.
20:01:31 <ImInYourMonad> hsx-0.4.8 depends on haskell-src-exts-0.4.8 which failed to install.
20:01:31 <ImInYourMonad> what are those?
20:01:35 <wli> aha, I needed --ghc-options=
20:01:39 <chessguy> Eridius:  well yeah, i could parse it
20:01:45 <chessguy> i'm looking for an app to display it
20:01:47 <Eridius> ImInYourMonad: a debugging function.. I hope you realize using the haskell equivalent will require the IO monad
20:01:55 <Eridius> so you can't just stick it into your pure board manipulation functions anymore
20:01:58 <Eridius> chessguy: what OS?
20:02:05 <chessguy> OS X
20:02:24 <Eridius> ok, I know a program that renders them, but I'm blanking on the name. gimme a min
20:02:46 <Eridius> GraphicConverter
20:02:52 <Eridius> http://osx.iusethis.com/app/graphicconverter
20:03:00 <Eridius> it opens every image format under the sun
20:03:22 <mmorrow> chessguy: http://hackage.haskell.org/packages/archive/hmatrix/0.5.0.1/doc/html/src/Graphics-Plot.html#matrixToPGM
20:03:25 <Eridius> hrm, I think Pixelmator might also work, it claims to handle .pgm files
20:03:38 <Eridius> mmorrow: he wants to read them, not write them
20:04:00 <mmorrow> wouldn't knowing how to write them be failry easy to invert?
20:04:04 <mmorrow> *fairly
20:04:13 <mmorrow> especially with code
20:04:22 <mmorrow> (maybe not, i dunno)
20:04:23 <Eridius> he just said he wants to display them, not manipulate them in code
20:04:44 <chessguy> right, i'm generating PGM files and i want to render them
20:04:45 <mmorrow> um, i think any prog that can display images can display pgms
20:04:54 <mmorrow> use imagemagick
20:04:57 <Eridius> chessguy: there's a QT image importer/exporter for PGM on http://www.mactcp.org.nz/quicktime/index.html
20:05:01 <mmorrow> convert foo.pgm foo.tiff
20:05:03 <mmorrow> convert foo.pgm foo.png
20:05:04 <mmorrow> etc
20:05:06 <Eridius> if you install that, you should be able to open them with any app that uses QT
20:05:18 <wli> Rumor has it that PNG's aren't tough to generate.
20:05:23 * Eridius chuckles
20:05:32 <chessguy> don't think i have imagemagick
20:05:41 <mmorrow> sudo yum install -y imagemagick
20:05:44 <mmorrow> (or equiv)
20:05:54 <Eridius> chessguy: just install the QT component
20:05:59 <mmorrow> ewwww
20:06:01 <Eridius> or download GraphicConverter
20:06:04 <mmorrow> :)
20:06:09 <mmorrow> are you on windows?
20:06:10 <Eridius> mmorrow: why eww? that brings PGM importing to all apps that use QT
20:06:18 <Eridius> mmorrow: he already said OS X. why do you think I started suggesting OS X programs?
20:06:22 <mmorrow> Eridius: why not use imagemagick
20:06:37 <mmorrow> it's written in portable C
20:06:40 <Eridius> because it takes longer to build/install than it does to just install the QT component or download GraphicConverter?
20:06:55 <Eridius> I'm suggesting ways to view the PGM files directly, not ways to convert them to other formats
20:07:05 <chessguy> now now, no flame wars needed
20:07:05 <mmorrow> display foo.pgm
20:07:17 <wli> I'd be more interested in ways to construct PNG files.
20:07:46 <mmorrow> Eridius: (i'm just not a fan of QT is all :)
20:08:04 <mmorrow> ohhhhh
20:08:08 <mmorrow> QuickTime ?
20:08:10 <Eridius> yes!
20:08:12 <mmorrow> haha
20:08:15 <Eridius> I said QT, not Qt :P
20:08:15 <mmorrow> ok
20:08:19 <mmorrow> heh
20:08:27 <Eridius> I was wondering at your objections
20:08:46 <mmorrow> heh, yeah i was like whytf install all kinds of QT crap??!
20:08:49 <Eridius> hehe
20:13:12 <chessguy> bah, graphic converter says my pgm file is broken :(
20:13:19 <chessguy> it doesn't look broken to me
20:13:34 <Eridius> it's probably correct
20:16:14 <mle> wli: like a native PNG reader/writer?
20:18:04 <wli> nle: Yeah. There's probalbly something out there for it already.
20:19:21 <Eridius> huh, there's a package called pngload which provides a simple PNG loader (though I wonder what internal representation it loads *to*? Perhaps a bitmap?)
20:19:45 * chessguy sighs
20:20:24 <wli> PNG is a relatively simple format, but my docs are all in storage.
20:26:07 <wli> ... and the channel dies
20:26:24 <Eridius> heh
20:27:07 <wli> pngload goes the wrong direction; I just want to generate stuff without reference to preexisting png's and dump it out in png format.
20:27:24 <Eridius> yeah I know it goes in the wrong direction. I was just pointing it out as it's the only result from `cabal list png`
20:30:10 <wli> dev-haskell/gd might do something.
20:30:57 <wli> gd is pretty much what I want.
20:31:12 <ImInYourMonad> is it easy to implement byte addition?
20:32:03 <dancor> ImInYourMonad: just addition mod 256?
20:32:56 <dancor> > (200 :: Word8) + (200 :: Word8)
20:32:57 <lambdabot>   144
20:33:56 <dancor> can sdl-image save pngs?
20:34:18 <dancor> load-only looks like.. http://hackage.haskell.org/packages/archive/SDL-image/0.5.2/doc/html/Graphics-UI-SDL-Image.html
20:34:38 <wli> I have it insalled but can't find it in ghci.
20:34:45 <wli> Ah, Graphics.UI
20:34:49 <ImInYourMonad> this brainfuck: ,>++++++[<-------->-],[<+>-]<. is supposed to add 2 nbrs together, i supply 5 and 3 and get -40
20:34:53 <Gracenotes> @src [] (<*>)
20:34:53 <lambdabot> (<*>) = ap
20:35:07 <Gracenotes> um, yay
20:35:10 <dancor> yeah i guess gd is the way to go.  http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html
20:35:52 <wli> All I need to do is plot curves without gnuplot weirdness in the way.
20:36:03 <ImInYourMonad> wait it actually does something just pushes the result wrong
20:36:14 <wli> And, for that matter, using my own splines.
20:36:21 <mmorrow> i have some code to write (color or greyscale) PNGs that i extended from some code to write just grayscale on the wiki
20:36:31 <mmorrow> i'll paste it
20:36:37 <wli> mmorrow: I'm interested.
20:36:56 <wli> The code to write just grayscale would be fine, even.
20:37:11 <wli> All I need is grayscale.
20:37:24 <mmorrow> it's not exactly cleaned up/documented, but it should be fairly easy to figure out
20:37:53 <ImInYourMonad> --,>[<->-],[<+>-]<. add 2 nbs together
20:37:53 <ImInYourMonad> --should be ,>++++++[<-------->-],[<+>-]<. though.
20:38:23 <wli> I don't see PNG code on the wiki, but anyway.
20:40:30 <ImInYourMonad> The first number is input in [0], and 48 is subtracted from it to correct it (the ASCII codes for the digits 0-9 are 48-57). This is done by putting a 6 in [1] and using a loop to subtract 8 from [0] that many times. (This is a common method of adding or subtracting large numbers.) Next, the second number is input in [1].
20:40:33 <ImInYourMonad> oops
20:45:41 <ImInYourMonad> why doesnt the haskell community just dump darcs? git won anyway right?
20:45:58 <edwardk> ImInYourMonad: because darcs does things git doesn't
20:46:16 <Gracenotes> hm. Hindley-Milner is more intuitive than I thought...
20:46:25 <wli> Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
20:46:36 <edwardk> gracenotes: yeah, its downright elegant all told
20:46:39 <Gracenotes> loose definition of 'thought', as I didn't study it
20:46:51 <Gracenotes> yeah :)
20:47:10 <Eridius> darcs does things git doesn't, but it's still a PITA to use :P
20:47:17 <edwardk> it becomes ugly again by the time you add in all the crazy wobbly type/system Fc stuff needed to model haskell though ;)
20:47:36 <edwardk> Eridius: sure. but i welcome them continuing to hammer the problem into a more palatable form.
20:47:39 <Gracenotes> which crazy wobbly types does Haskell have?
20:47:39 <Saizan> wli: is libpthread.so a linker script? the ghci linker can't handle those
20:47:53 <Eridius> edwardk: I just wish they did it on their own time instead of forcing me to interact with darcs repos :P
20:47:54 <edwardk> besides i've been stealing patch theory for commuting opcodes ;)
20:48:43 <Gracenotes> edwardk: is it to do with kinds?
20:49:07 <Saizan> darcs get/record/send, how can it be simpler?
20:49:16 <edwardk> Gracenotes: the opcode stuff?
20:49:30 <Eridius> Saizan: it's too simple. I can't do anything interesting
20:49:41 <Gracenotes> the Hindley-Milner getting freaky for Haskell
20:49:49 <edwardk> Gracenotes: in my case i have execution traces and i want to push stuff off of the main path that isn't needed by it, so i commute them out onto side exits.
20:49:52 <Eridius> for example, I can't even figure out how to ask it which patches I have that aren't in the remote repo
20:50:14 <Saizan> Eridius: darcs send tells you
20:50:36 <Eridius> ugh, I shouldn't have to do a dry-run send just to find that out
20:51:17 <Riastradh> Would you be happier if `send --dry-run' were spelled another way?
20:53:04 <mle> I like -o, actually
20:53:11 <Saizan> (wobbly types are the ones to handle gadts, or impredicativity?)
20:54:30 <wli> Weird, the y coordinates are flipped.
20:54:42 <edwardk> saizan: yeah
20:55:03 <edwardk> er gadts
20:55:12 <wli> let f (n :: Int) = floor (256 * sin ((fromIntegral n :: Double) * pi / 512)) :: Int ; ps = zip [0..256] (map f [0..256]) in do { i <- newImage (256, 256) ; fillImage 0 i ; zipWithM_ (\p1 p2 -> drawLine p1 p2 255 i) ps $ tail ps ; savePngFile "foo.png" i }
20:55:18 <wli> That doesn't do quite what I expect.
20:57:41 <wli> I guess the origin is the upper left corner or some such.
20:58:31 <wli> So ps = [(x, 256 - y) | (x, y) <- zip [0..256] $ map f [0..256]] instead
21:04:24 <ImInYourMonad> > replicateM $ System.Random.randomRIO (0::Int, 10)
21:04:25 <lambdabot>   Couldn't match expected type `Int' against inferred type `IO Int'
21:04:32 <ImInYourMonad> why?
21:05:36 <kerlo> @type replicateM
21:05:37 <Eridius> :t replicateM
21:05:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:05:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
21:05:54 <kerlo> replicateM takes an Int, not an m Int, I guess.
21:06:07 <edwardk> @type System.Random.randomRIO
21:06:08 <lambdabot> forall a. (Random a) => (a, a) -> IO a
21:06:30 <kerlo> So, (a -> m b -> m c) -> m a -> m b -> m c, anyone?
21:06:39 <mmorrow> wli, et al: i sucked it up and made a caballed darcs repo, with haddock docs included: http://moonpatio.com/repos/png-writer/
21:07:18 <edwardk> > replicateM 10 $ System.Random.randomRIO (0::Int, 10)
21:07:19 <lambdabot>   * Exception: "<IO [Int]>"
21:07:29 <mmorrow> so one thing i'd change is how the pixel data currently have to go through a list
21:07:45 <mmorrow> but at the same time, i'd also keep that ability for playing around
21:07:46 <edwardk> did you want a random number of replications or a given number of random things? =)
21:08:48 <ImInYourMonad> i want a list of random nbrs
21:09:08 <kerlo> ImInYourMonad: do you want a random number of random numbers?
21:09:15 <edwardk> @type randoms
21:09:17 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
21:09:37 <edwardk> @type randomRs
21:09:38 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
21:10:04 <kerlo> If not, consider replicateM numberOfRandomNumbers (System.Random.randomRIO (0::Int, 10))
21:10:16 <mmorrow> wli: yeah, so the `png' function is just for greyscale, and `writePng' does (iirc) any possible combo of options (i don't remember though if i covered all of them..)
21:10:34 <wli> Looks good.
21:10:55 <wli> I'm already where I need to be with GD, but I'll move to this anyway.
21:11:01 <mmorrow> let me know if anything's broken :)
21:15:44 <wli> I'm not sure how to spew out an image with this.
21:16:28 <mmorrow> wli: i'll paste a quick example
21:17:47 <ImInYourMonad> someone have a goo example of doing random stuff purely? ie passing around a Stdgen? because i dont get how to do it
21:17:52 <wli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2178#a2178
21:18:43 <edwardk> ImInYourMonad: when in doubt, don't. just stuff the StdGen in a State monad, and write a couple of little helpers that get it, use it and put it back
21:19:18 <edwardk> in that vein: http://www.haskell.org/haskellwiki/New_monads/MonadRandom
21:19:52 <edwardk> StdGen is hard to use raw because you need to make sure you didn't already use that particular seed.
21:20:03 <wli> mmorrow: I'm pretty happy with that.
21:20:18 <edwardk> its a case where uniqueness would come in real handy to enforce a certain 'quantum' nature with respect to seeds.
21:22:04 <ImInYourMonad> im trying to figure out Data.Binary, how do I define how the values should be serialized?
21:22:43 <ImInYourMonad> the thing is i did it once half a year ago but then i delete dthat program when i bought a new computer and now i dont remebr how
21:30:11 <mmorrow> wli: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1792#a1792
21:30:34 <mmorrow> generates a random PNG given a seed, width, height
21:30:50 <mmorrow> (slowness courtesy of System.Random)
21:31:11 <mmorrow> so juts something like:
21:31:30 <mmorrow> writePng 8 (RgbA (xs :: [[(Word8,Word8,Word8,Word8)]]))
21:32:02 <mmorrow> and replace the type of `xs' there by the type the corresponding GADT contructor expects for the given colortype
21:32:14 <mmorrow> (if using a diff con that is)
21:32:19 <wli> okay
21:33:01 <mmorrow> and the function `pngBitsPerChannel :: PngColor a -> [BitsPerChannel]" will tell you what the possible bits per channel are for a given colortype
21:33:30 <mmorrow> oh crap, i just realized that since i'm using Word8's, i can't do more that 8bits per channel :/
21:34:25 <wli> I'm mostly doing gnuplot-ish stuff here.
21:34:42 <mmorrow> oh crap, i forgot to expose PngColor's constructors
21:37:06 <ImInYourMonad> noone knows Data.Binary? i dont get it
21:37:17 <Eridius> sorry?
21:40:26 <mmorrow> wli: i just updated that repo to expose PngColor's cons
21:41:13 <edwardk> ImInYourMonad: I think it was the channel being more tactful than saying rtfm outright ;)
21:41:42 <ImInYourMonad> Eridius: if I have a Data.Map (Integer, Integer) Integer, do I need to specify how it should be serialized?
21:41:48 <edwardk> though, to be fair, i don;t think that I _have_ ever used Data.Binary ;)
21:42:26 <Eridius> ImInYourMonad: there's an instance of Binary for (Ord k, Binary k, Binary e) => Binary (Map k e)
21:42:30 <ImInYourMonad> well i use encodeFile but nothing seems to happen
21:42:47 <Eridius> are you sure?
21:42:54 <Eridius> are you sure it's actually being run, even?
21:43:38 <pumpkin> moo
21:44:32 <mmorrow> wli: oh nice, i just saw your paste
21:44:43 <ImInYourMonad> no
21:44:47 <mmorrow> wli: yeah, gd is great for drawing stuff
21:45:00 <Saizan> ImInYourMonad: you'd get a type error if it didn't know how to serialize it
21:45:13 <Eridius> ImInYourMonad: if encodeFile is compiling, and you're not getting an error, but you're seeing nothing happen, I suspect it's simply never being called
21:46:11 <ImInYourMonad> booya!
21:46:37 <ImInYourMonad> i had switched "hello" "pathto/file"
21:46:48 <pumpkin> :o
21:47:02 <pumpkin> are you really in my monad?
21:48:01 <ispiked> > filter (toUpper == 'A') ['b','a']
21:48:02 <lambdabot>   Couldn't match expected type `Char -> Char'
21:48:12 <kerlo> return ImInYourMonad :: Monad m => m Person
21:48:15 <ispiked> is tehre a way I can get that to work?
21:48:22 <kerlo> Yep, he's in your monad.
21:48:31 <pumpkin> onoes
21:49:18 <ispiked> it seems like it should accept it since it does yield a Char eventually...
21:50:10 <Saizan> ispiked: use a lambda
21:50:33 <ispiked> I am trying to avoid a lengthy list comprehension-style filter
21:50:49 <kerlo> > filter (\x -> toUpper x == 'A') ['b','a']
21:50:50 <Saizan> > filter (\x -> toUpper x == 'A') ['b','a']
21:50:51 <lambdabot>   "a"
21:50:51 <lambdabot>   "a"
21:50:57 <Saizan> @pl filter (\x -> toUpper x == 'A') ['b','a']
21:50:57 <lambdabot> filter (('A' ==) . toUpper) "ba"
21:51:23 <kerlo> @pl (x == y, y == x)
21:51:24 <lambdabot> (x == y, y == x)
21:52:16 <ImInYourMonad> how much space does Map (Int, Int) Int take?
21:52:24 <ispiked> I don't get how that changes things
21:52:44 <ispiked> isn't the lambda function still going to be (Char -> Char)?
21:53:07 <pumpkin> ImInYourMonad: linear in the number of key/value pairs :P
21:53:31 <Saizan> ?type toUpper == 'A' -- this makes little sense
21:53:32 <lambdabot>     Couldn't match expected type `Char -> Char'
21:53:32 <lambdabot>            against inferred type `Char'
21:53:32 <lambdabot>     In the second argument of `(==)', namely 'A'
21:53:53 <dancor> @pl \ x y -> join (,) $ x == y
21:53:54 <lambdabot> (join (,) .) . (==)
21:53:59 <Saizan> "toUpper == 'A'" means "compare toUpper and 'A' for equality"
21:54:03 <ispiked> I thought it would get curried
21:54:09 <Saizan> which can't be done since they have different types
21:54:13 <ispiked> ...or something
21:54:27 <Saizan> currying doesn't magically apply arguments
21:54:32 <ImInYourMonad> pumpkin: how much is Int?
21:54:41 <Saizan> or figures how a right composition
21:54:47 <Saizan> "out"
21:55:05 <Saizan> which is (('A' ==) . toUpper) in this case
21:55:06 <pumpkin> ImInYourMonad: on a 64-bit machine, 16 bytes
21:55:12 <ispiked> thanks Saizan
21:56:41 <dancor> > maxBound :: Int
21:56:43 <lambdabot>   9223372036854775807
21:56:49 <dancor> > minBound :: Int
21:56:50 <lambdabot>   -9223372036854775808
21:56:58 <Eridius> if I use newStablePtr but forget to call freeStablePtr, will the garbage collector catch my mistake, or is it special enough that it will end up preventing its value from ever being collected?
21:58:17 <edwardk> it'll stay there forever
21:58:30 <edwardk> because it doesn't know if you gave it away to c, or whatever
21:59:24 <dancor> pumpkin: isn't an Int only 8 bytes long on a 64bit machine?
21:59:34 <pumpkin> Int# would be
21:59:52 <dancor> so there is a another Int# for laziness?
21:59:53 <pumpkin> but you pay for the box too
21:59:55 <dancor> ok
22:00:03 <pumpkin> Int = I# Int#
22:00:05 <Eridius> edwardk: that's what I was afraid of. It looks like System.Posix.Process.forkProcess leaks the associated action if forkProcessPrim returns an error
22:00:48 <dancor> @remember futurama And the box itself is probably worth something too!
22:00:48 <lambdabot> I will remember.
22:01:28 <pumpkin> :)
22:01:38 <pumpkin> there was a blog post recently on size of things
22:01:41 <dolio> The butter in my pocket is melting!
22:01:55 <pumpkin> http://ghcmutterings.wordpress.com/2009/02/12/53/
22:02:05 <edwardk> dancor++
22:02:46 <Eridius> OW, my sperm!
22:02:50 <Eridius> Huh! Didn't hurt that time.
22:09:27 <dancor> ..it's bigger!
22:09:38 <Eridius> am I correct in thinking that the value "stable" gets leaked if throwErrnoIfMinus1 throws an error? http://pastie.textmate.org/410053
22:13:03 <Saizan> Eridius: i'd think so
22:13:54 <Eridius> that seems like a pretty big bug, given that it appears to be leaking an arbitrarily-sized IO action
22:14:03 <ImInYourMonad> > take 80 $ repeat [1..5]
22:14:05 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
22:15:10 <Saizan> one should use bracket for patterns like that
22:18:39 <edwardk> > take 80 $ cycle [1..5]
22:18:41 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
22:19:35 <Gracenotes> @src cycle
22:19:36 <lambdabot> cycle [] = undefined
22:19:36 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:20:34 <Eridius> ooh, ghc can compile via C? I wonder if that means it can actually compile to ARM?
22:20:56 <edwardk> > take 80 $ repeat =<< [1..5]
22:20:57 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:21:06 <edwardk> woops =)
22:21:13 <Eridius> o_O
22:21:30 <edwardk> guess i'd want LogicT =)
22:21:30 * Eridius understands why it behaved that way, he's just  curious as to what you were trying to attempt
22:24:51 <ImInYourMonad> uh
22:25:02 <ImInYourMonad> doesnt serializing take anyn space at all?
22:25:22 <edwardk> nope, though i suppose if you want to deserialize it later you might want it to ;)
22:25:33 <Eridius> o_O
22:28:00 <edwardk> for some reason i'm reminded of http://www.national.com/rap/files/datasheet.pdf
22:29:55 <ImInYourMonad> is that a joke?
22:30:06 <edwardk> if you have to ask..
22:31:03 * Eridius laughs
22:31:11 <Eridius> ImInYourMonad: read the name of the product
22:31:51 <dolio> , observeMany 80 $ repeat -<< msum (map return [1..5])
22:31:53 <lunabot>  luna: Not in scope: `-<<'
22:31:53 <edwardk> it becomes progressively more obvious as you read. see "cooling"
22:32:21 <dolio> , observeMany 80 $ msum (map return [1..5]) >>- repeat
22:32:22 <lunabot>  luna: Couldn't match expected type `Control.Monad.Logic.Logic a'
22:32:27 <dolio> Oops.
22:33:07 <dolio> , observeMany 80 $ msum (map return [1..5]) >>- \e -> fix (return e `mplus`)
22:33:08 <lunabot>  [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,1,2,1,4,1,2,1,3,1,2,1,5,1,2,1,3,...
22:33:47 <edwardk> @type observeMany
22:33:48 <lambdabot> forall a. Int -> Logic a -> [a]
22:33:55 <edwardk> wooo
22:35:12 <ImInYourMonad> lol
22:35:49 <ImInYourMonad> u mean read the description
22:38:34 <dolio> Oleg has some kind of 'FastNondet' that's even better, apparently.
22:38:41 <dolio> But technically not a monad.
22:38:50 <dolio> I think, at least.
22:46:07 <ImInYourMonad> when implementing a garbage collector, is that just keeping track of malloced memory and freeing it when it has no references?
22:46:40 <repnop> ImInYourMonad: gc is a very complex subject :)
22:46:40 * ivanm would assume it's _slightly_ more involved than that
22:46:47 <ivanm> such as _when_ to do so
22:46:49 <repnop> lots of papers on it
22:47:30 <Saizan> that's the idea though
22:47:34 <ivanm> IIRC, one reason some people don't like GC langs is because for mission-critical aps, you never know when it will suddenly decide to GC and thus slow the ap down
22:47:43 <Saizan> it's just hard to implement :)
22:47:43 <repnop> ivanm: there are solutions
22:48:00 <ivanm> *shrug* I just use them ;-)
22:48:16 * repnop mostly uses java these days
22:48:31 <repnop> go gc go :p
22:48:37 <ivanm> :o begone from this place, infidel! :p
22:49:36 <repnop> haskell seems interesting, i need to dedicate more time to it
22:49:42 <repnop> been lurking here for how long now :)
22:50:12 <ivanm> @where tutorial
22:50:12 <lambdabot> http://www.haskell.org/tutorial/
22:50:17 <ivanm> @where yaht
22:50:17 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
22:50:19 <ivanm> @where lyah
22:50:19 <lambdabot> www.learnyouahaskell.com
22:50:22 <repnop> yeah i know
22:50:23 <ivanm> @where rwh
22:50:23 <lambdabot> is http://www.realworldhaskell.org/blog/
22:50:25 <ivanm> ;-)
22:50:28 <repnop> and real world haskell etc
22:50:30 <repnop> that isn't the problem
22:50:32 <ivanm> pick one and start! ;-)
22:50:54 <repnop> i have a project that could be good for it, fx volatility modeling :)
22:51:02 <ivanm> \o/
22:51:03 <repnop> lazy eval + inf structures
22:51:12 * ivanm has no idea what that means, but it sounds good
22:51:19 <repnop> ivanm: currencies
22:51:37 <repnop> not as straight forward as stocks
22:51:48 <repnop> so most people use custom models for prediction and pricing on the options they sell
22:51:50 <ivanm> ?
22:52:16 <repnop> my broker had a flaw in their previous model that gave me a 12:1 return on a very low risk trade
22:52:40 <repnop> up to 12:1
22:52:57 <repnop> but lowest was around 7:1 so still was easy profit hehe
22:52:58 <ivanm> ahhhhh
22:53:49 <repnop> so it could be fun in haskell
22:54:11 <gnut> how do you interface with the markets?
22:54:23 <repnop> my main broker is a java api
22:54:37 <repnop> well api to a java client
22:54:49 <gnut> ah.. so you would need to write a ffi to java ?
22:54:51 <repnop> i'm too cheap to use FIX
22:55:00 <repnop> nah
22:55:20 <repnop> a socket would be easier
22:55:36 <Taejo> what does "Warning: Data.HMM: the following names could not be resolved: LogFloat" mean when I do 'cabal install'
22:55:55 <pumpkin> maybe cabal update?
22:56:16 <repnop> better to keep all parts in individual processes
22:56:28 <repnop> dont want some accident killing my trade manager
22:56:48 <Taejo> pumpkin: nope, doesn't help.
22:56:52 <Taejo> the package works fine
22:56:58 <pumpkin> the LogFloat package?
22:57:21 <Taejo> pumpkin: no, hmm, the package I'm building
22:57:27 <Taejo> which depends on logfloat
22:57:51 <pumpkin> try installing logfloat separately maybe?
22:58:11 <Taejo> pumpkin: I already have it installed
22:58:30 <pumpkin> maybe force reinstall it? :P
22:58:37 <pumpkin> I've had that happen when I messed with my cabal dir
22:59:33 <Taejo> pumpkin: still the same
22:59:40 <pumpkin> :(
23:02:41 <repnop> it's an interesting mathematical problem i guess
23:02:55 <repnop> no accurate volume figures, no single price data so on
23:04:38 <repnop> so you're working with imperfect information unlike exchange traded instruments
23:15:17 <edwardk> hah there are multiple clues ;)
23:15:28 <edwardk> er wrong channel
23:32:46 <mcnster> @hoogle unsafePerformIO
23:32:47 <lambdabot> Foreign unsafePerformIO :: IO a -> a
23:32:47 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
23:47:04 <edwardk> type HereBeDragons = IO
23:47:19 <Taejo> @pl \f g x y -> f (g x y)
23:47:20 <lambdabot> (.) . (.)
23:47:39 <Taejo> @pl \x y -> ?f (?g x y)
23:47:39 <lambdabot> (line 1, column 9):
23:47:39 <lambdabot> unexpected "?"
23:47:39 <lambdabot> expecting lambda abstraction or expression
23:47:43 <Taejo> @pl \x y -> f (g x y)
23:47:44 <lambdabot> (f .) . g
23:50:08 <ivanm> edwardk: is that valid? surely it should be: type HereBeDragons a = IO a
23:50:43 <edwardk> ivanm: its valid. you can have higher kinded types
23:50:58 <Taejo> :t foldl'
23:50:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:51:03 <edwardk> ivanm: tripped me out the first time i saw it ;)
23:51:23 <ivanm> edwardk: it just looks like the monomorphism restriction was about to raise its ugly head on the type level, that's all ;-)
23:51:30 <edwardk> ivanm: useful because when they are 'eta-reduced' like that you can use them in more situations
23:51:34 <mcnster> @hoogle ioError
23:51:35 <lambdabot> Prelude ioError :: IOError -> IO a
23:51:35 <lambdabot> Control.Exception ioError :: IOError -> IO a
23:51:35 <lambdabot> System.IO.Error ioError :: IOError -> IO a
23:51:47 <ivanm> edwardk: such as?
23:52:32 <edwardk> well, you can't partially apply a type synonym. so type Product a b = (a,b) -- sucks more than (,), but type Product = (,) can be partially applied, used in instance heads, etc.
23:53:26 <ivanm> *nod*
23:53:50 <ivanm> but can't you do the same with the non-reduced form?
23:54:22 <Taejo> :t group
23:54:23 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
23:54:41 <edwardk> instance Comonad (Product e) blows up in your face if you've defined type Product a b = (a,b) because the instance has partially appliued a type synonym.
23:54:50 <edwardk> but its happy with type Product = (,)
23:55:03 <ivanm> ahhh
23:55:17 <edwardk> (modulo the complaint that you shouldn't be putting instances on type synonyms in the first place, which can be LANGUAGE pragma'd away)
23:56:13 <pumpkin> how can I compile just a .o file without a main in it?
23:56:19 <pumpkin> ghc -c doesn't seem to do it
23:57:01 <ivanm> pumpkin: ghc Foo.hs (if Foo.hs doesn't have a main function)
23:57:04 <ivanm> I think that's it
23:57:18 <pumpkin> oh, it wanted me to give it a module name, silly me
23:57:49 <ivanm> heh
23:57:54 <Taejo> @pl trainNote c d = TrainNote (Note c d)
23:57:54 <lambdabot> trainNote = (TrainNote .) . Note
23:59:42 * ivanm would like to point out to Taejo the possibilities of "/msg lambdabot ... "
