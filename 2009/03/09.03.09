00:00:26 <pumpkin-> Gracenotes: probably charm unless I decide it's too cheesy, it's not in a releasable state yet
00:00:45 <pumpkin-> ddarius: for now it's just a decoder of the main instructions
00:01:03 <pumpkin-> with a lame pretty-printer sitting on top of it
00:01:07 <ddarius> pumpkin-: And later?
00:01:58 <pumpkin-> I might go the other way, but my main objective is to complete the disassembly part of it with a good representation of the instructions so I can write reversing tools on top of it
00:02:57 <ddarius> pumpkin-: Aren't there machine description files you could generate this from?  (Admittedly, you'd have to write/modify the generator.)
00:04:01 <pumpkin-> not really, ARM only really publishes the information in PDF form, and the only good looking disassembler I could find for it is in gnu binutils. I based mine on the binutils one, but they went straight from instruction to string, so it discarded any real semantic information
00:04:16 <pumpkin-> even the PDFs are hard to get, for more recent versions of the arch
00:05:37 <pumpkin-> and I wasn't too enthusiastic about using the binutils approach and parsing the asm back in
00:16:27 <pastah> @pl \x -> f x >>= g x
00:16:27 <lambdabot> liftM2 (>>=) f g
00:16:34 <pumpkin-> lol
00:16:46 <pumpkin-> that's what I was just talking about :)
00:17:01 <pumpkin-> you can also use on
00:17:08 <pumpkin-> @src on
00:17:08 <lambdabot> (*) `on` f = \x y -> f x * f y
00:17:27 <pumpkin-> but I guess with a single argument liftM2 is better
00:18:00 <Axman6> :t \x -> ?f x >>= ?g x
00:18:02 <lambdabot> forall (m :: * -> *) a t b. (Monad m, ?g::t -> a -> m b, ?f::t -> m a) => t -> m b
00:20:34 <pastah> @pl \x -> f x >>=\y -> g x y
00:20:34 <lambdabot> liftM2 (>>=) f g
00:20:44 <Gracenotes> o nos
00:20:45 <pastah> ohm...
00:20:51 <pastah> ehm..
00:20:53 <pastah> how the fuck?
00:21:06 <pumpkin-> ?
00:21:09 <pastah> @pl \x -> f x >> g x
00:21:09 <lambdabot> liftM2 (>>) f g
00:21:37 <pumpkin-> what's confusing?
00:21:55 <pumpkin-> \y -> g x y === g x
00:22:19 <Gracenotes> it's the same thing as liftA2 (>>) f g
00:23:00 <Gracenotes> which, I've heard it said, lambdabot should use more
00:23:06 <Gracenotes> pl
00:40:51 <mmorrow> pumpkin-: i don't see how gas could assemble for ARM, since it seems to be lacking any code to do so
00:41:14 <pumpkin-> mmorrow: hah, yeah, I couldn't find any either :) but it's supposed to be able to!
00:42:15 <mmorrow> weird
00:42:21 <pumpkin-> ./gas/testsuite/gas/arm/
00:42:32 <pastah> @pl f >>= \o -> (lol o) >>= \n -> g o n
00:42:32 <lambdabot> liftM2 (>>=) lol g =<< f
00:42:38 <mmorrow> hmm, i was lookuing in binutils/opcodes/
00:42:38 <pastah> nice
00:43:19 <pumpkin-> mmorrow: ./gas/config/tc-arm.c
00:43:40 <Alpounet> Hi guys !
00:44:13 <pastah> @pl f >>= \o -> (lol o) >>= \n -> g monB Nothing o n
00:44:13 <lambdabot> liftM2 (>>=) lol (g monB Nothing) =<< f
00:44:55 <pumpkin-> mmorrow: that file looks big enough to be the whole thing
00:44:58 <pumpkin-> 21000 lines
00:45:39 <mmorrow> just founf another snippet http://moonpatio.com/repos/LIBS/Language/binutils/include/opcode/arm.h
00:45:41 <pumpkin-> looks like the entire asm parser, code generator, and elf generator
00:45:52 <mmorrow> pumpkin-: ah, true. if that's the case i love their naming scheme
00:46:21 <mmorrow>  arm-dis.c ==> arm assembler everything
00:46:25 <mmorrow> nice!
00:46:35 <pumpkin-> I mean the config/tc-arm.c
00:46:37 <pastah> @pl f >>= \o -> (lol o) >>= \n -> g monB Nothing (return o) (return n)
00:46:37 <lambdabot> liftM2 (>>=) lol ((. return) . g monB Nothing . return) =<< f
00:46:43 <pumpkin-> is probably the entire assembler
00:46:51 <mmorrow> pumpkin-: ohh, i didn't see that yet..
00:46:52 <pumpkin-> not sure why it sits in config, but who expects binutils to make sense
00:47:06 <pumpkin-> the arm-dis.c definitely doesn't have enough information to assemble
00:47:15 <pumpkin-> you'd think they'd try to merge the two, to avoid discrepancies
00:47:32 <mmorrow> which config is that?
00:47:46 <pumpkin-> http://moonpatio.com/repos/LIBS/Language/binutils/gas/config/tc-arm.c
00:47:53 <mmorrow> ah
00:48:06 <mmorrow> awesome, the mystery is solved
00:48:09 <mmorrow> :)
00:48:12 <pumpkin-> that must be quite intense for the compiler to deal with
00:48:20 <pastah> holy shit i got it to work!!
00:48:26 <pumpkin-> they just stuffed the entire thing into one file
00:48:44 <toliko_smoren> hey, fboard is of type [[[a]]], why is this not working ? (map (map (map head)) fboard )
00:48:47 <pumpkin-> really elegant
00:48:49 <mmorrow> i love compilers written in C
00:48:56 <mmorrow> "how long is that file?"
00:49:03 <mmorrow> "oh, just 40,000 lines"
00:49:09 <pumpkin-> lol
00:49:11 <mmorrow> no biggy
00:49:25 <pumpkin-> this one doesn't even have any large tables in it
00:49:29 <mmorrow> heh
00:49:30 <pumpkin-> it's just a crapload o' code
00:49:53 <pumpkin-> I bet I could do the same thing in 1/10th the code in haskell :P
00:50:04 <mmorrow> i always try to picture the person that wrote all of this code, and only ever can see robots
00:50:09 <erikc> haha
00:50:45 <pumpkin-> gpl-evangelizing, c-generating gnubots
00:51:28 <pumpkin-> mmorrow: I bet you're itching to write an assembler now
00:51:39 <thoughtpolice> lhc generates pretty large c files
00:51:41 <mmorrow> pumpkin-: kinda, actually :)
00:51:44 <thoughtpolice> on the order of 30,000 lines.
00:51:57 <pumpkin-> thoughtpolice: but at least a human didn't write those 30000 lines
00:52:16 <aeolist> and most of everything, nobody asks you to debug it :D
00:52:35 <thoughtpolice> actually the C generated for implementing an arbitrary-precision Integer type (in haskell itself) when compiled with lhc is only like 20,000 lines
00:53:05 <thoughtpolice> pumpkin-: right, but when one of those 30,000 lines has a problem that causes a segfault, it's just as much of a pain to track :)
00:53:16 <pumpkin-> I bet
00:53:26 <ImOuttaYourMonad> is there some sort of methology to derive that a problem is np-complete?
00:54:01 <Gracenotes> yeah, a proof
00:54:09 <toliko_smoren> guys, can anyone actually help me with the function i wrote above, its getting late and I am getting dead
00:55:06 <Alpounet> @pl (map (map (map head)) fboard)
00:55:06 <lambdabot> map (map (map head)) fboard
00:55:08 <glguy> ImOuttaYourMonad, you show that you can express another NP-Complete problem in your new problem in polynomial time and that you can verify an answer in polynomial time
00:55:15 <pumpkin-> ImOuttaYourMonad: typically, you reduce a known np-complete problem to the one you're looking at
00:56:34 <pumpkin-> Alpounet: if you have no arguments (points), @pl can't remove anything
00:56:50 <glguy> pumpkin-, it will still try to simplify
00:57:08 <pumpkin-> it won't do anything interesting will it?
00:57:10 <Alpounet> 'kay
00:57:15 <glguy> ?pl id id
00:57:16 <lambdabot> id
00:57:19 <pumpkin-> @pl if x then 1 else 2
00:57:19 <lambdabot> if' x 1 2
00:57:21 <Gracenotes> :O
00:57:23 <pumpkin-> ah, interesting
00:57:32 <pumpkin-> @pl \fboard -> (map (map (map head)) fboard)
00:57:32 <lambdabot> map (map (map head))
00:58:06 <toliko_smoren> thats exactly what i have
00:58:14 <pumpkin-> ?
00:58:23 <toliko_smoren> and i get the expected type [[[a]]]-> [Bool]
00:58:26 <Gracenotes> @pl id id id id id f id id id id id g id id id id id id id id id x
00:58:26 <lambdabot> f id id id id id g id id id id id id id id id x
00:58:40 <toliko_smoren> infered type [[[a]]] -> [[a]]
00:58:41 <Gracenotes> @pl id id id id id f . id id id id id g . id id id id id id id id id x
00:58:41 <lambdabot> f . g . x
00:59:32 <Gracenotes> @type concatMap (map head)
00:59:33 <lambdabot> forall a. [[[a]]] -> [a]
01:00:24 <mmorrow> , fix ((h::Expr->Expr) . g . (f::Expr->Expr))
01:00:27 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
01:01:09 <mmorrow> seems to need those two annotations
01:01:40 <mmorrow> map (map (map f)) === (map . map . map) f
01:05:21 <pumpkin-> anyone here ever used TAO or PETSC?
01:12:30 <glguy> > exp(0 :+ pi)
01:12:32 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
01:13:26 <glguy> > exp(0 :+ pi) + 1
01:13:28 <lambdabot>   0.0 :+ 1.2246467991473532e-16
01:14:02 <dolio> > exp (0 :+ pi) + 1 :: Complex CReal
01:14:04 <lambdabot>   0.0 :+ 0.0
01:14:05 <Cale> Stupid waste of time problem: Explain exactly how that rounding error comes about ;)
01:14:27 <dolio> > sin pi
01:14:27 <pumpkin-> > sin pi
01:14:29 <lambdabot>   1.2246467991473532e-16
01:14:29 <lambdabot>   1.2246467991473532e-16
01:14:31 <pumpkin-> lol
01:14:39 <dolio> Mine displayed first!
01:14:41 <Guest_882> hi I was wondering if there is a windows/DOS version of the quickCheck script on the main quickCheck site. I don't understand how to convert the existing script. I compile it but it gives me an error whenever I try to give the compiled quickCheck executable a filename
01:14:44 <pumpkin-> no mine
01:15:00 <Cale> So, what algorithm is sin using? ;)
01:15:27 <pumpkin-> it's a primop
01:15:29 <Guest_882> i.e. I want to be able to use quickCheck over mutliple prop_ functions.
01:15:58 <wli> On x86 it's probably using inline asm for the floating point sine instruction.
01:16:25 <Guest_882> by executing the entire .hs file containing all prop_ functions.
01:16:40 <Guest_882> Can anyone give me a pointer in the right direction please?
01:16:43 <pumpkin-> primop   DoubleSinOp   "sinDouble#"      Monadic  -- this is the algorithm!!!1!!
01:16:44 <pumpkin-> :P
01:16:50 <Cale> Guest_882: what error?
01:17:01 <dolio> > sin (realToFrac (pi :: Double)) :: CReal
01:17:02 <lambdabot>   0.0000000000000001224646799147353177226066
01:17:19 <pumpkin-> callishOp DoubleSinOp    = Just MO_F64_Sin
01:17:30 <dolio> One that doesn't subtract pi?
01:17:34 <Cale> dolio: Oh, interesting :)
01:17:38 <Guest_882> Well I compile the quickCheck file into a main.exe file and then when I supply a file argument it doesn't like it
01:18:05 <Cale> dolio: So that looks like it comes entirely from the inaccuracy of pi.
01:18:13 <Saizan> Guest_882: is it giving you an error message?
01:18:17 <Axman6> > sin pi :: CReal
01:18:18 <lambdabot>   0.0
01:18:34 <pumpkin-> MO_F64_Sin    -> fsLit "sin"
01:18:35 <pumpkin-> whee
01:18:37 <pumpkin-> :P
01:18:43 <Guest_882> C:\Users\Mark\workspace\QuickCheck\src>runghc Main.hs DebugDemoCheck.hs
01:18:43 <Guest_882> '.' is not recognized as an internal or external command,
01:18:43 <Guest_882> operable program or batch file.
01:19:04 <Guest_882> where main is the quickCheck script
01:19:09 <pumpkin-> of course, that's the wrong arch, but you get the idea
01:19:16 <mmorrow> wli: ghc uses "fsin" on x86 :(
01:19:20 <Saizan> Guest_882: maybe it wants a module name
01:19:27 <Guest_882> tried that
01:19:31 <Guest_882> doesn't work
01:19:32 <Saizan> Guest_882: where can i find this script, btw?
01:19:36 * mmorrow wishes ghc used SSE(2)
01:19:42 <Guest_882> I guess most people are unix users.
01:19:48 <Guest_882> umm,...
01:20:05 <mmorrow> yeah, oops i meant "sin"
01:20:09 <mmorrow> s/f//
01:20:21 <Guest_882> http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
01:20:35 <pumpkin-> mmorrow: my search came up with the SPARC codegen first
01:20:41 <pumpkin-> and I actually pasted the old one too
01:21:06 <pumpkin-> so I fail
01:21:08 <mmorrow> oh no, it is "fsin"
01:21:14 <mmorrow> pumpkin-: ?
01:21:16 <mmorrow> oh
01:21:22 <mmorrow> epic fail :)
01:21:26 <pumpkin-> I thought you were referring to what I'd pasted :P
01:21:28 <Saizan> Guest_882: the problem is probably from this line system ("./ghci "++options opts'++" <hugsin")
01:22:01 <Saizan> Guest_882: try with system ("ghci "++options opts'++" <hugsin")
01:22:16 <Guest_882> ah yes, of course
01:22:16 <dolio> > pi - realToFrac (pi :: Double) :: CReal
01:22:18 <lambdabot>   0.0000000000000001224646799147353177226066
01:22:26 <mmorrow> pumpkin-: ah, ok i just realized the context here. i was responding to wli, but didn't know yours was in answer
01:22:39 <Guest_882> give me a few moments
01:22:56 <pumpkin-> well, given that my answer wasn't relevant, you weren't missing much
01:23:01 <dolio> Huh.
01:23:12 <mmorrow> wli: do "$ echo 'main = print (sin 42)' > sin.hs; ghc -O2 -S sin.hs; cat sin.s | grep sin"
01:23:24 <dolio> > pi - realToFrac (pi :: Double) - sin (realToFrac (pi :: Double)) :: CReal
01:23:25 <lambdabot>   0.0
01:23:39 <pumpkin-> hmm
01:24:12 <pumpkin-> > pi - sin (realToFrac (pi :: Double)) :: CReal
01:24:14 <lambdabot>   3.1415926535897931159979634685441851615906
01:24:39 <pumpkin-> > realToFrac (pi :: Double) :: CReal
01:24:41 <lambdabot>   3.1415926535897931159979634685441851615906
01:24:45 <mmorrow> @check \x -> 0 == x-(x::Double)
01:24:46 <lambdabot>   "OK, passed 500 tests."
01:24:48 <mmorrow> @check \x -> 0 == x-(x::Double)
01:24:48 <lambdabot>  Terminated
01:24:50 <mmorrow> @check \x -> 0 == x-(x::Double)
01:24:51 <lambdabot>   "OK, passed 500 tests."
01:25:02 <mmorrow> @check \x -> x == (x::Double)+pi-pi
01:25:03 <lambdabot>   "Falsifiable, after 4 tests:\n2.6666666666666665\n"
01:25:26 <mmorrow> (of course x-x==0 ..)
01:26:24 <mmorrow> @check \x -> pi == (pi+x)-(x::Double)
01:26:25 <lambdabot>   "Falsifiable, after 42 tests:\n15.9\n"
01:26:37 <mmorrow> @check \x -> pi == pi+(x-(x::Double))
01:26:39 <lambdabot>   "OK, passed 500 tests."
01:27:19 <dolio> > pi == pi + (0/0 - 0/0 :: Double)
01:27:21 <lambdabot>   False
01:27:40 <mmorrow> > (0/0) + 42
01:27:41 <lambdabot>   NaN
01:27:49 <pumpkin-> 0/0 is like the GPL :P
01:28:20 <mmorrow> > pi == (pi + 15.9) - 15.9
01:28:22 <lambdabot>   False
01:28:57 <mmorrow> > pi == pi + (15.9 - 15.9)
01:28:59 <lambdabot>   True
01:29:28 <wli> There are generalized continued fractions for pi floating around. The simple/regular continued fraction for pi has no programmable pattern, though.
01:30:33 <wli> The brilliant bit about the continued fractions, though, is that the convergence gives you progressively tightening bounding intervals.
01:31:28 <quicksilver> wli: well, pi is computable, so its regular continued fraction must be computable.
01:32:04 <quicksilver> I assume you mean that it's not computable in O(1) work per step.
01:32:18 <quicksilver> or perhaps it's not even PTIME work per step?
01:32:36 <wli> quicksilver: It is, but only by virtue of relatively brutal methods.
01:33:31 <wli> I tried to compute the regular continued fraction by narrowing intervals with its generalized continued fraction and playing interval arithmetic games. I failed.
01:34:41 * quicksilver nods
01:36:34 <wli> There might be a way involving transforming all the partial numerators to 1, splitting the partial denominators into integer and fractional parts, doing continued fraction addition, etc.
01:37:01 <Guest_882> Now I get this Saizan:
01:37:04 <Guest_882>     Failed to load interface for `QuickCheck':
01:37:04 <Guest_882>       Use -v to see a list of the files searched for.
01:37:04 <Guest_882> *DebugDemoCheck> Leaving GHCi.
01:37:41 <Guest_882> I think its complaining about an import Test.QuickCheck that it can't find
01:40:02 <wli> I guess you need to move from a generalized continued fraction to a quasi-regular continued fraction with rational elements, and then from that to a true regular continued fraction.
01:41:03 <wli> If I remembered Gosper's algorithms for continued fraction arithmetic, maybe something could be said.
01:43:12 <pumpkin-> I hate PETSC
01:43:32 <ImOuttaYourMonad> can there ever be a foundation of mathematics?
01:43:40 <pumpkin-> axioms?
01:43:54 <pumpkin-> at some point you have to say "this sounds reasonable"
01:44:04 <pumpkin-> and accept it
01:44:18 <mmorrow> quicksilver: re: our conversation about compiling cases/switches the other day: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1801
01:44:54 <mmorrow> quicksilver: so gcc does a jump-table for the first, and then i *think* something along the lines of binary search for the second
01:45:37 <mmorrow> quicksilver: (also, woe is he that cases on a bunch of Integer literals in haskell ;)
01:45:57 <wli> http://web.archive.org/web/20071207211816/http://www.tweedledum.com/rwg/cfup.htm
01:45:58 <pumpkin-> some jumptables aren't full .long
01:46:28 <mmorrow> pumpkin-: maybe it's for alignment or something?
01:46:32 <pumpkin-> mmorrow: you should run it through hex-rays
01:46:52 * mmorrow gets his hex-ray gun
01:46:58 <pumpkin-> mmorrow: well in that case they are using full addresses, but sometimes they use shorter offsets from the current location, possibly with shifts
01:47:11 <pumpkin-> lol
01:47:14 <pumpkin-> I meant the decompiler
01:47:22 <mmorrow> pumpkin-: ah yeah, true. i wonder what they do for PIC
01:50:04 <pumpkin-> I don't have hex-rays on this machine, but I can run it on my other computer tomorrow
01:50:45 <pumpkin-> I'd be curious what it did with the sparse switch
01:50:47 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1818#a1819
01:50:55 <mmorrow> for -fpic
01:51:09 <mmorrow> just does "@GOTOFF"
01:51:30 <mmorrow> i thought it was going to be more interesting
01:51:45 <pumpkin-> there are cases in which it does more interesting stuff, but I have no idea what causes them
01:52:23 <mmorrow> i guess maybe since x86 doesn't have explicitly PC-relative addressing they just take the easy way out
01:52:48 <pumpkin-> wanna try -Os?
01:52:54 <mmorrow> k
01:53:14 <mmorrow> (with or without -fpic ?)
01:53:18 <pumpkin-> with pic
01:54:23 <pumpkin-> I guess on x86 it can't do much more interesting than what it did there
01:54:36 <pumpkin-> those @GOTOFF are just offsets though
01:55:18 <mmorrow> dunno if there was any change http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1818#a1820
01:55:37 <mmorrow> i wish hpaste2 had diff
01:55:39 <pumpkin-> yeah, don't think there can be, now that I think about it
01:55:53 <pumpkin-> well I guess
01:56:00 <pumpkin-> it could realize that the sizes are bounded and not use .long
01:56:07 <pumpkin-> but that's about it
01:56:30 <mmorrow> are you sure though that that would be just as fast though (for whatever obscure reason)
01:56:43 <pumpkin-> it wouldn't
01:56:47 <pumpkin-> necessarily
01:56:55 <pumpkin-> but I just mean in the interest of preserving space
01:56:58 <pumpkin-> for -Os
01:57:00 <mmorrow> ah
01:57:02 <mmorrow> ohh
01:57:06 <mmorrow> gotcha
01:57:16 <pumpkin-> because the .long in the pic case are added to a nearby memory location
01:57:20 <pumpkin-> so are all pretty small
02:01:10 <mmorrow> pumpkin-: oh wow, i just googled hex-ray
02:01:28 <pumpkin-> it's a pretty sweet program :)
02:01:32 <trofi^w> ghci-haskeline does not understand '\EOT' is it bug or feature? (my inferior haskell does not close session by Ctrl+D)
02:01:42 <pumpkin-> one of these days I'll see how it deals with something ghc produces
02:01:50 <mmorrow> dang, $515
02:01:56 <pumpkin-> it's more than that
02:01:58 <trofi^w> (Ctrl+D<Enter>: <interactive>:1:0: lexical error at character '\EOT')
02:02:01 <mmorrow> pumpkin-: does the evaluation version not suck?\
02:02:07 <pumpkin-> that's just IDA
02:02:12 <pumpkin-> which is itself pretty awesome
02:02:16 <pumpkin-> hex-rays is 2 grand I think
02:02:27 <mmorrow> oh, super
02:02:31 <mmorrow> :)
02:02:33 <pumpkin-> IDA is a great disassembler though
02:03:21 <wli> I think it can be done with equivalence transformations.
02:04:00 <mmorrow> pumpkin-: oh, i see. i wasn't even on the hex-ray part
02:04:34 <mmorrow> 2299USD (1500EUR)
02:04:40 <mmorrow> yikes
02:04:51 <thoughtpolice> IDA is pretty much the best disassembler there is period
02:04:56 <pumpkin-> yup :)
02:05:13 <mmorrow> apparently hex-rays is bettar?
02:05:16 <thoughtpolice> s/pretty much/by a landslide/
02:05:17 <pumpkin-> I actually thought it was worth buying with my measly salary
02:05:24 <pumpkin-> mmorrow: it's a plugin for IDA
02:05:27 <thoughtpolice> mmorrow: hex-rays is an addon to IDA pro to do decompilation
02:05:27 <pumpkin-> that decompiles
02:05:34 <mmorrow> ohh, i see now
02:05:37 <mmorrow> whoa.
02:05:37 <wli> Use an equivalence transformation to get the first partial numerator to 1. Break off the integer and fractional parts of the partial denominator, use Gosper's addition to combine the fractional part of the partial denominator with the remaining terms. Recurse.
02:05:52 <pumpkin-> mmorrow: it isn't perfect, but it does a pretty good job a lot of the time
02:05:57 <mmorrow> so the plugin is 2 grand, and the main app is 500/1000
02:06:02 <pumpkin-> yeah
02:06:13 <pumpkin-> I got a 50% edu discount on the main app
02:06:18 <mmorrow> nice
02:06:25 <thoughtpolice> ilfak g. (the main IDA pro author) is a really smart guy; his blog has a lot of interesting stuff on it at times
02:06:34 <pumpkin-> yeah :)
02:06:39 <mmorrow> pumpkin-: do you get free upgrades4lyfe ?
02:06:46 <pumpkin-> mmorrow: only for a year :( my year is over
02:06:51 <mmorrow> :(
02:07:24 <mmorrow> thoughtpolice: link to blog?
02:07:30 <pumpkin-> http://hexblog.com/
02:07:34 <mmorrow> oh, http://www.hexblog.com/
02:07:36 <mmorrow> heh
02:07:57 <pumpkin-> I know a guy who works there
02:08:04 <pumpkin-> it sounds pretty cool :)
02:08:13 <mmorrow> pumpkin-: can he be bribed?
02:08:18 <mmorrow> :)
02:08:21 <pumpkin-> lol unfortunately not
02:08:53 <mmorrow> damn. i was gonna offer him a case of redbull for a few copies of hex-rays.. :(
02:08:57 <pumpkin-> aw
02:09:13 <pumpkin-> given the kinds of people who use the app, they have a big piracy issue
02:09:18 <mmorrow> i bet
02:09:19 <pumpkin-> in many cases they just refuse to sell it to people, even
02:09:40 <pumpkin-> they have an interesting watermarking scheme
02:09:48 <pumpkin-> every customer has his own uniquely generated copy
02:10:02 <pumpkin-> if it leaks, they publicly humiliate the leaker
02:10:02 <pumpkin-> :P
02:10:12 <mmorrow> hah
02:10:15 <pumpkin-> and possibly look into legal action
02:10:22 <pumpkin-> depends on the situation
02:10:52 <thoughtpolice> yeah, i've heard it's gotten a lot harder to get a legit license for IDA from the datarescue guys...
02:10:59 <pumpkin-> yeah
02:11:06 <pumpkin-> datarescue actually broke up from hex-rays
02:11:08 <thoughtpolice> especially for independent security researchers
02:11:10 <pumpkin-> and IDA is sold by hex-rays now
02:11:29 <pumpkin-> yup
02:11:38 <thoughtpolice> i mean, honestly, if I did a lot of security/reverse engineering, you bet your ass I would drop the $600 on IDA.
02:11:41 <thoughtpolice> totally worth it
02:11:50 <pumpkin-> yeah, it's what I did :)
02:12:03 <thoughtpolice> the graph interface for disassemblies introduced in 5.x is slick as hell and works great
02:12:18 <pejo> JaffaCake, been browsing "Runtime support for multicore Haskell". I'm curious about work stealing: do you have any numbers on how many steals that typically occur?
02:12:24 <thoughtpolice> pumpkin-: yeah, I used to be really /really/ into security research (softice and everything baby)
02:12:29 <pumpkin-> hah, fun
02:12:54 <pumpkin-> the only reason I keep a windows VM on my mac is to run IDA :P
02:13:08 <thoughtpolice> same here, really.
02:13:09 <pumpkin-> it has curses-ish interfaces for linux/mac, but they're no fun
02:13:15 <thoughtpolice> well, that and n64 roms
02:13:19 <pumpkin-> lol
02:13:23 <mstr> pumpkin-: I don't think they actually do anything about leakers
02:13:23 <thoughtpolice> pumpkin-: the curses interface is pretty much 100% unusable
02:13:34 <mstr> most likely they are carded anyway
02:13:35 <trofi^w> yep :[
02:13:43 <pumpkin-> mstr: they've discussed legal action on the private forums
02:13:51 <pumpkin-> mstr: but so far, they've only ever bitched at the leakers
02:14:14 <mstr> well, what can you do if it's bought by a stolen credit card number for example
02:15:03 <pumpkin-> well, they make a point of getting a good idea of who they're selling to
02:15:13 <pumpkin-> and if you look sketchy, they'll just refuse to give it to you
02:15:31 <mstr> yea. doesn't seem to work though
02:15:38 <pumpkin-> I didn't have much trouble coming from a .edu, but in general I hear it's pretty hard
02:15:44 <pumpkin-> 5.3 hasn't leaked yet as far as I know?
02:16:02 <pumpkin-> or 5.4
02:16:09 <mstr> you might be right. I don't know
02:16:22 <pumpkin-> the people I hang out would've mentioned it I think :)
02:16:30 <pumpkin-> *with
02:17:11 <h0tzenpl0tz> how to combine these two? filterChildName >>= filterChildrenName >>= [result]   where filterChildName :: Maybe Element and filterChildrenName :: [Element]
02:17:14 <pumpkin-> thoughtpolice: I did a lot of the iphone jailbreak stuff :)
02:21:00 <thoughtpolice> pumpkin-: oh really? fun :)
02:21:27 <pumpkin-> yeah, haven't had much time to do it recently, but had a lot of fun in the past with it
02:21:49 <thoughtpolice> pumpkin-: just lots of time reading disassembly outputs? how'd you get the code in the first place?
02:21:55 <thoughtpolice> and maybe this should be in -blah...
02:21:59 <pumpkin-> yeah, sorry :)
02:24:45 <h0tzenpl0tz> pumpkin-, thoughtpolice: could you please, please give me any hint to combine these xml-filtering functions above?
02:25:13 <h0tzenpl0tz> combining Maybe Element and [Element] results ...
02:26:16 <mmorrow> thoughtpolice: how is getting ml-risc to work going?
02:26:35 <thoughtpolice> mmorrow: reading a bit of the documentation I managed to generate from the source
02:26:41 <thoughtpolice> (well, really just a pdf version of the webpage)
02:26:54 <mmorrow> heh, that's a start :)
02:27:15 <thoughtpolice> mmorrow: I can get my copying GC up but, I just don't know how I want to hold onto gc roots
02:27:28 <thoughtpolice> a copying collector requires a little more cooperation from the compiler than a mark-sweep
02:27:30 <mmorrow> thoughtpolice: yeah, that's a total pita
02:27:33 <quicksilver> mmorrow: interesting stuff.
02:27:42 <mmorrow> i'm trying to figure out the same thing for my interp
02:27:52 <mmorrow> quicksilver: indeed
02:28:07 <mmorrow> quicksilver: i wonder what it's actually doing in the second case
02:28:27 <thoughtpolice> mmorrow: so, my plans are basically A) get a copying collector working, and B) get some type of code generation working through MLRISC
02:28:43 <mmorrow> thoughtpolice: what i think i've settled on is this:
02:29:13 <thoughtpolice> i'm thinking of using c-- as my low-level intermediate language
02:31:26 <mmorrow> (1) have a check at the beginning of every "function" (or some conception thereof in the "asm") for the (statically computed) max needed heap in that function, and if it fails, (2) you know where all the roots are coming into a function, so generate code that packs all registers/whatnot into a closure (w/ a bitmap or something indicating pointers), and (3) jump to the gc with the address of this closure and a continuation to resume
02:32:33 <mmorrow> so then the complexity is just in (1) computing max needed heap for a given stretch of code, and (2) constructing the closure of roots at runtime
02:32:41 <p_l> hmm... I wonder how it exactly worked with Cheney's GC
02:33:03 <mmorrow> p_1: i'm using a cheney gc
02:33:36 <mmorrow> p_1: it depends on the source lang though how exactly you call the gc, and resume from gc
02:33:39 <p_l> mmorrow: ah. I ended up returning the book I had on GC way too fast, I see :)
02:33:39 <thoughtpolice> mmorrow: so, you essentially want to encode GC roots in a closure and pass that to the gc function?
02:33:58 <thoughtpolice> p_l: my GC is a cheney one too, I just don't know quite how I want to encode root pointers yet
02:34:00 <chowmeined> hm
02:34:03 <mmorrow> thoughtpolice: yeah, something like this
02:34:04 <pejo> mmorrow, isn't computing the maximum needed heap for an arbitrary expression undecidable?
02:34:26 <mmorrow> pejo: well, you'd have to break it into chunks where it is possible
02:34:33 <thoughtpolice> obviously function parameters are roots since they can't, well, -not- be.
02:34:34 <mmorrow> i.e., for basic blocks
02:34:41 <quicksilver> these aren't arbitrary expressions, though
02:34:46 <quicksilver> they're code blocks
02:34:49 <quicksilver> which have restricted form
02:34:49 <mmorrow> quicksilver: exactly
02:34:55 <thoughtpolice> i'm just trying to find the easiest way to represent the roots using a calling convention/runtime format
02:34:58 <quicksilver> they may *jump* to other code, which reaches other heaps
02:35:04 <quicksilver> but you're only trying to compute one at a time.
02:35:59 <thoughtpolice> mmorrow: afaik, sml/nj (at least used to) do something similar; it would pass the GC an encoding of the registers/whatev. holding gc roots at the time of a collection. the trick was that this information is only known after register allocation
02:36:04 <mmorrow> thoughtpolice: yeah, it's just starting to become clear to me what i /have/ to do, but i'm still planning how i'm /actually/ going to manage to do it
02:36:41 <thoughtpolice> mmorrow: right. function params are obvious - you can take a route similar to GHC and just pass the first N in registers and the next on the stack, it's just a matter of how you want to lay out the stack/heap so you know where your roots are
02:36:46 <thoughtpolice> and yeah
02:36:48 <thoughtpolice> it is a PITA
02:36:56 <mmorrow> thoughtpolice: yeah, totally. i'm following their method pretty closely, since i think it's nice and it's the most organized/readable method i've seen thus far
02:36:56 <thoughtpolice> a mark-sweep collector is more self contained
02:37:10 <thoughtpolice> mmorrow: for sure
02:37:12 <p_l> afaik some compilers simply partitioned the registers?
02:37:19 <thoughtpolice> i've already ripped off appel's "a runtime system" paper plenty
02:37:27 <mmorrow> thoughtpolice: heh, me too
02:37:33 <p_l> (though it doesn't really work for architectures without many registers)
02:38:00 <mmorrow> p_1: the painful part comes though when you can mix ptrs and unboxed literals (either in registers or on the stack)
02:38:13 <mmorrow> then you have to arrange for the gc to know what is what
02:38:22 <mmorrow> and that's where all the "fun" begins
02:38:29 <thoughtpolice> mmorrow: notably I stole some of the basic formats of the runtime system; e.g. gc_alloc takes a size and allocates that many objs, including 1 more which it XORs with a tag (passed to gc alloc,) and the returned cell is pointed after that
02:38:46 <thoughtpolice> mmorrow: so I'm stealing the idea of having descriptors for all heap pointers at their -1 location
02:39:06 <mmorrow> thoughtpolice: yeah, i'm doing that too more or less
02:39:48 <thoughtpolice> mmorrow: my code uses c99 exact width integer types and some sanity checks to determine that sizeof(obj) == sizeof(void*), so, for every allocated object there's the overhead of one pointer which has no purpose other than to store the descriptor info in the high 4 bits
02:40:04 <p_l> mmorrow: avoid stack and partition registers into two sets, one that contains references and one that contains unboxed literals? ;)
02:40:16 <mmorrow> thoughtpolice: yeah, i'm using a one word descriptor too
02:40:45 <mmorrow> p_1: yeah, i'm going for no stack, but partitioning registers is a waste imo
02:40:54 <thoughtpolice> mmorrow: so there's a little overhead for the rest of the pointer that isn't used, but my code also can work with 64-bit pointers (seriously, thank you god for uint*_t types now)
02:41:25 <pejo> mmorrow, there's a paper by Tolmach where the first argument of the function is simply a bit-vector that flags which arguments that are boxed or not.
02:41:29 <mmorrow> since what if you want fill all regs with ptrs at one point? all the "literal" registers will be unused
02:41:33 <thoughtpolice> so with a 64-bit runtime, your records are only limited to something like 2^60 fields :)
02:41:49 <thoughtpolice> (since i steal the 4 high bits regardless of 32-bit or 64-bit)
02:41:58 <pumpkin-> terrible!
02:42:01 <p_l> mmorrow: avoiding stack can result in weird stuff, though. I can't wait to see MMIX done in hardware (it has stack... kind of. done on its registers)
02:42:07 <pumpkin-> I feel robbed of 15/16ths of my space
02:42:22 <mmorrow> pejo: yeah, i'm thinking about either some sort of a bitmap, or just statically (somehow) computing pointerhood of args
02:42:33 <pumpkin-> is everyone writing his/her own language?
02:42:38 <thoughtpolice> pumpkin-: you should!
02:42:40 <mmorrow> p_1: heh
02:42:44 <mmorrow> pumpkin-: yes!
02:42:45 <pejo> pumpkin, I'm not.
02:42:46 <pumpkin-> lol
02:42:51 <thoughtpolice> pumpkin-: i am!
02:43:01 <pumpkin-> I'm too lazy to write a language, I'd probably write something like OISC if I had to
02:43:21 <mmorrow> p_1: no stack is cool since then you can get first-class continuations almost for free... callcc++
02:44:09 <mmorrow> pumpkin-: i'm not writing a language per se, just an interpreter that's useable by any lang that can target its "core" language it starts compilation from
02:44:18 <pumpkin-> ah
02:44:25 * osfameron wonders if you can navigate using a zipper over a [[Cell]] type representation of a grid
02:44:27 <pumpkin-> !(per say)++
02:44:29 <mmorrow> (which is essentially an untyped, stripped-down haskellish lang)
02:44:38 <pumpkin-> :P
02:44:48 <pumpkin-> @karma !(per say)
02:44:48 <lambdabot> !(per has a karma of 0
02:44:51 <pumpkin-> boo
02:44:56 <osfameron> do you have to convert between [[Cell]] and the representation with up/down/left/right pointers ?
02:45:25 <mmorrow> osfameron: iirc there was a haskell-cafe thread about *exactly* this in january
02:45:41 <pejo> mmorrow, why are you concerned about unboxing and similar things if you are writing an interpreter?
02:45:51 <osfameron> mmorrow: oh yes, I remember that now vaguely!  thanks, I'll have a look
02:46:03 <p_l> afk
02:46:18 <mmorrow> pejo: because i want it to be faster than ghci, and ghci has to deal with such things :) also, it has an ffi to C
02:46:23 <paolino> osfameron, probably Saizan have a comonad for that IIRC
02:46:46 <osfameron> istr that one was for an infinite grid (whereas obviously [[Cell]] is finite at least in 2 directions
02:46:50 <thoughtpolice> mmorrow: right here next to me I have muchnick's book as well as jones and lins, so, if I get anywhere on how I want to store gc roots, I'll hollar at you. :)
02:46:51 <osfameron> paolino: a comonad?
02:47:18 <mmorrow> thoughtpolice: cool :) (i have muchnik and jones next to me too ;)
02:47:32 <thoughtpolice> i'll just have to start writing bits of assembler by hand following my own stack/calling convention I guess
02:47:43 <paolino> that is a memory, not completely sure, sorry
02:48:18 <osfameron> paolino: thanks, google finds me http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html which may well be relevant
02:48:26 <osfameron> I don't really understand what comonads are though :-)
02:56:20 <Saizan> osfameron: if Zipper [] a is the zipper for [a], then the one for [[a]] is Zipper [] (Zipper [] a), and depending on which layer you use the next/previous operations you move in one direction or the other
02:56:53 <Saizan> s/direction/dimension/
02:56:57 <Saizan> or whatever.
02:57:49 <osfameron> Saizan: ah I see (I think... I'll have to play with the Zipper libraries in anger)
02:58:05 <Saizan> uhm
02:58:26 <quicksilver> Saizan: it's not quite like that though
02:58:34 <quicksilver> Saizan: it 'remembers' where you are in each column
02:58:36 <Saizan> though that it's not actually right, since it works but you don't get O(1) access
02:58:39 <quicksilver> each column has a 'separate' cursor.
02:58:56 <quicksilver> when you move to neighbouring column, you don't move to the cell to your left (or right)
02:59:05 <quicksilver> you move to the last selected cell in that column.
02:59:08 <pumpkin-> in haskell's type system, you can have restrictions like Ord a => [a]... in a dependently typed language, could I have something like Even a => [(a :: Int)] or something along those lines?
02:59:38 <quicksilver> pumpkin-: the answer to what you mean, is yes.
02:59:39 <pumpkin-> I don't know how to represent values vs. types in that signature :P
02:59:43 <quicksilver> pumpkin-: what you said doesn't make sense ;)
02:59:46 <pumpkin-> I know :)
02:59:52 <quicksilver> pumpkin-: "a" is a type not a value, it won't be Even.
03:00:05 <ivanm> quicksilver: you expect pumpkin- to make sense? :o
03:00:06 <ivanm> ;-)
03:00:10 <pumpkin-> yeah, I attempted to clarify after that :P
03:00:22 <quicksilver> expect? no. aspire to? sure. What is life without aspiration.
03:00:26 <pumpkin-> hey, someone scooped out my brains and carved a face on me, you gotta understand
03:00:49 <pumpkin-> my intellect is sitting in someone's pie
03:01:17 <Badger> Delicious brains.
03:01:58 <pumpkin-> none left for you, sorry
03:02:03 <Badger> :'(
03:02:31 <ivanm> pumpkin-: what, you haven't grown any back since last octoboer?
03:02:35 <ivanm> *october
03:02:41 <pumpkin-> I live in a freezer
03:02:54 <paolino> quicksilver: the operators acting on the outside layer should move all the cell  pointers of the layer inside
03:03:30 <Badger> He's sitting in a server rack hooked up via firewire. :P
03:03:49 <paolino> cell  contexts, probably is a better name
03:04:29 <Saizan> quicksilver: right, so you need to fmap the operations to keep the columns in sync
03:04:57 <paolino> which is not O (1)
03:05:01 <quicksilver> Saizan: ah, right.
03:05:16 <pumpkin-> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=205 looks pretty neat
03:05:25 <quicksilver> Saizan: that makes it O(n) though
03:05:51 <osfameron> Saizan: so you keep a note of the current index and recreate the leftwards zipper when you move up/down ?
03:06:00 <Saizan> yeah, that was my afterthought too :)
03:06:50 <pejo> pumpkin, there's a functional pearl from ICFP by Okasaki in early 2000'ish, if you're interested in that stuff.
03:06:59 <Saizan> recreate in which sense?
03:07:24 <pumpkin-> pejo: related to the labeling?
03:08:46 <Saizan> uhm, in fact the derivative of f^2(x) is not f'^2(x)
03:09:37 <pejo> pumkin, yes, the cyclic program is described in the appendix.
03:10:24 <pumpkin-> ah cool
03:10:27 <pumpkin-> I think I found it
03:10:35 <pumpkin-> http://www.eecs.usma.edu/webs/people/okasaki/icfp00.ps ?
03:13:06 <ImInYourMonad> im trying to implement prolog in haskell. when declaring things like: HaskelHacker pumpkin. should those be strings? making the user define datas or types is a little bit over the top...
03:13:18 <pumpkin-> lol
03:13:38 <pumpkin-> HaskellNoob pumpkin if anything
03:13:54 <pumpkin-> I don't get the question though :)
03:16:39 <HugoDaniel> hmm
03:16:51 <HugoDaniel> pumpkin-: do you ever sleep ?
03:16:59 <pumpkin-> unfortunately not
03:17:10 <HugoDaniel> what do you do for a living ?
03:17:15 <pumpkin-> I'm a student
03:17:20 <HugoDaniel> nice
03:17:21 <gio123>  I have to prove  set1 \issubset set2, is it suffcient to prove set1=>set2 ?
03:18:50 <quicksilver> gio123: this is not a forum for random maths questions.
03:19:06 <gio123> ok
03:20:21 <ImOuttaYourMonad> fact: neversleeps pumpking; ?awake pumpkin -> true
03:21:26 <Saizan> is it possible to faithfully represent a grid with an ADT? [[a]] is a much larger type
03:22:19 <SamB_XP_> try a GADT ;-P
03:22:37 <osfameron> you could presumably have next-right and next-down links, assuming knot-tying cleverness
03:23:41 <pumpkin-> it would be cool to be able to represent "spherical" grids, mobius strips, and klein bottles
03:23:43 <osfameron> and that doesn't constrain the shape (e.g. make sure that a 10x10 grid is actually 10 wide and 10 high in all places)
03:24:05 <ImOuttaYourMonad> pumpkin-: you study math?
03:24:12 <pumpkin-> ImOuttaYourMonad: CS
03:24:41 <Saizan> SamB_XP_: how do you differentiate a GADT?:)
03:25:15 <SamB_XP_> Saizan: what, you want a zipper ?
03:25:49 <Saizan> SamB_XP_: yeah, we were discussing what's a good representation for a grid zipper
03:26:07 <alinp> is there a good haskell book out there ?
03:26:19 <pumpkin-> @where RWH
03:26:19 <lambdabot> is http://www.realworldhaskell.org/blog/
03:26:34 <alinp> beside of "real world haskell"
03:26:54 <ImOuttaYourMonad> so you should i write an interpreter/parser for prolog?
03:26:58 <alinp> I think that the chapters are a little bit strange ordered
03:27:01 <ImOuttaYourMonad> or just encode it in haskell?
03:27:04 <quicksilver> alinp: http://www.haskell.org/haskellwiki/Books
03:27:12 <quicksilver> hutton's book is well liked by some.
03:27:19 <alinp> thanks quicksilver
03:28:03 <pumpkin-> ImOuttaYourMonad: you seem to be doing a bunch of completely different things :P winning the netflix prize, solving convex optimization problems, writing logic languages, what else? :)
03:28:38 <Saizan> they might all fit together
03:29:47 <quicksilver> the unifying theme is world domination!
03:30:22 <Saizan> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.37.2565 <- this is a nice paper about embedding a logical language
03:30:31 <mmorrow> Saizan: this might be applicable http://www.haskell.org/pipermail/haskell-cafe/2009-January/052891.html
03:30:45 <mmorrow> original post was: http://www.haskell.org/pipermail/haskell-cafe/2009-January/052756.html
03:30:48 <pumpkin-> mmorrow: what time do you typically wake up btw?
03:31:03 <mmorrow> pumpkin-: depends when i need to wake up :)
03:31:18 * mmorrow doesn't have a regular schedule, just an appointment-driven one
03:31:57 <pumpkin-> ah okay
03:32:29 * Saizan uses randomizer
03:33:31 <dolio> data Pair f fs a = P (f a) (fs a) ; data Square f fs a = Z (fs (fs a)) | S (Unary f (Pair f fs) a)?
03:33:46 <dolio> Oops, that's not complete.
03:35:03 <dolio> Say instead 'data Unary f fs a = Z (fs (fs a)) | S (Unary f (Pair f fs) a) ; type Square = Unary Id (Const ())'?
03:40:43 <mmorrow> lol, i just tried to print something and the printer spits out a piece of paper with some unreadable lines with the top parts of the letters chopped off and three readable words saying:
03:40:50 <mmorrow> INTERNAL ERROR         FALSE   -
03:42:30 <mmorrow> dolio: is that for the grid?
03:43:14 <mmorrow> dolio: were those datatype RE: the infinite grid?
03:44:11 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2234#a2234 witness the beauty.
03:44:16 <mmorrow> hehe
03:44:44 <mmorrow> purdy
03:44:54 <quicksilver> dolio: awesome.
03:45:05 <quicksilver> how do you write size :: Square -> Int ?
03:45:18 <dolio> If the grid is infinite, then it's just Stream (Stream a), no?
03:45:44 <quicksilver> and why is fs applied twice in the Z case ?
03:45:58 <mmorrow> dolio: i suppose, but i guess that forces a row/column ordering
03:46:24 <mmorrow> err, s/ordering/whatever you call the diff between "rowmajor" and "colmajor"/
03:46:59 <dolio> Unary builds up a Vector n and then makes Vector n (Vector n a).
03:47:13 * mmorrow is still getting his grok on
03:48:06 <osfameron> what are S and Z ?
03:49:17 <Saizan> think of them as Succ and Zero, to count the dimensions
03:49:28 <Saizan> err, no, the number of elements in a row
03:49:47 <osfameron> where are they defined?
03:49:55 <osfameron> ah, sorry
03:49:55 <mmorrow> ooh, that just gave me the idea of an n-dimensional gridzipper for any n
03:49:56 <osfameron> in Unary
03:50:30 <quicksilver> dolio: oh, right.
03:50:35 <mmorrow> ohhhh, i just grokked what dolio did
03:50:35 <dolio> size' :: Unary f fs a -> Int ; size' (Z _) = 0 ; size' (S s) = 1 + size' s ; size :: Square a -> Int ; size = size'
03:50:49 <osfameron> how do you traverse the square?
03:51:06 <quicksilver> from a safe distance, with a pointed case statement.
03:51:07 <dolio> Heh.
03:51:19 <quicksilver> dolio: now the traversable instance, please
03:51:49 <dolio> Foldable shouldn't be bad...
03:52:00 <dolio> Well, for Squares.
03:53:30 <quicksilver> traversable's more fun though.
03:53:40 <quicksilver> functor, at least?
03:54:03 <dolio> I'll get rid of some of the noise first...
03:54:03 * SamB discovers that you can join two channels at once in x-chat
03:54:17 <quicksilver> actually functor is easy?
03:55:25 <quicksilver> instance Functor (Unary f fs) where fmap f (Z ffs) = Z ((fmap.fmap) f ffs); fmap f (S u) = S (fmap f u)
03:55:35 * mmorrow laughs at SamB
03:55:43 <quicksilver> careless overloading of 'f' as a name and a type.
03:55:45 <SamB> mmorrow: what's so funny about that ?
03:55:50 <SamB> I mean with join
03:55:56 <SamB> not the Network List stuff
03:55:58 * mmorrow laughs more
03:56:03 <mmorrow> :)
03:56:10 * SamB laughs too now
03:56:13 <quicksilver> but you need Functor contexts for fs and for Pair f fs
03:56:17 <SamB> but I dunno what I'm laughing for
03:56:45 <mmorrow> SamB: i don't actually use the network list/whatever, just type in the /joins manually each time
03:57:03 <SamB> mmorrow: seriously?
03:57:07 <mmorrow> yeah
03:57:22 <SamB> if your computer sponta-rebooted as much as mine has been, you would!
03:57:32 <SamB> of course, you'd probably have bought a new one too
03:57:40 <mmorrow> sponta-boot sounds like an energy drink
03:58:08 <SamB> I think it's a mobo/CPU problem
03:58:31 <SamB> or it could be RAM
03:59:16 <dolio> Somewhat more readable: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2234#a2235
03:59:21 <SamB> but the way the RAM testing tool just freezes part way through when I boot into it makes me suspect it's worse than RAM
04:00:15 <mmorrow> good thing you have insurance on it. you know, in case it gets "stolen"
04:00:50 <mmorrow> @slap mmorrow
04:00:50 * thoughtpolice proposes a SamB-new-computer-donation fund
04:00:50 * lambdabot secretly deletes mmorrow's source code
04:01:17 <thoughtpolice> SamB: maybe one that you can actually use lhc to compile stuff on without digging into your swap from what I've gathered? :)
04:01:18 <pumpkin-> onoes
04:01:40 * mmorrow could have sworn he saved that file in this directory..
04:01:58 <SamB> mmorrow: I haven't got any insurance, and it's not worth stealing
04:02:25 <mmorrow> SamB: wow, you're soooo bad at insurance fraud.
04:02:27 <SamB> and any would-be thief would have to figure out which computer was which, anyway -- I have two side-by-side ;-P
04:02:50 <SamB> it'd probably be cheaper to just get another one than to commit insurance fraud in this cae
04:04:33 <SamB> thoughtpolice: oh, and http://bugs.darcs.net/issue833 is the real reason I haven't gotten anything done on LHC lately
04:06:01 <thoughtpolice> SamB: conflict markers? trying to merge john's recent changes (i think I saw bang-pattern support in there for example...)
04:06:15 <SamB> precisely
04:06:30 <ImOuttaYourMonad> if i give this to parsec: cat(tom) :- true. ; can i then have aprsec return cat an tom?
04:06:34 <SamB> I can't bring myself to record mergers without knowing what patches I be merging!
04:08:00 <thoughtpolice> SamB: I've been woefully inactive. :( this term at uni. means a lot this time around, and I'm working on some other stuff too...
04:09:02 <SamB> yeah, well, I haven't done any LHC hacking over my entire spring break because of the way issue833 makes me feel
04:09:23 <SamB> okay, I also got distracted working on the "dvc" emacs package
04:09:29 <thoughtpolice> heheh
04:09:35 <pumpkin-> mmm, maybe I should go to sleep
04:09:37 <SamB> but that was as a direct result of issue833
04:09:41 <pumpkin-> it's 7:10 am :/
04:09:45 <ivanm> pumpkin-: :o
04:09:50 <ivanm> you haskelled all night long?
04:10:00 <pumpkin-> unfortunately not, I was c-ing
04:10:08 <ivanm> then that's no excuse! :@
04:10:13 <pumpkin-> when I have extra time, I'm moving all this crap code to haskell
04:10:16 <ivanm> just what do you think you were doing up all night!?!?!?!?!
04:10:18 <ivanm> ;-)
04:10:23 <pumpkin-> lol
04:10:26 <ivanm> pumpkin-: so you're prototyping in C? :o
04:10:38 <pumpkin-> no, I'm dealing with someone else's (academic) code that's in c
04:10:43 <ivanm> ahhhh
04:10:47 <ivanm> you're forgiven then :p
04:10:48 <pumpkin-> trying to add a variant algorithm to it
04:11:03 <pumpkin-> yay thanks :P
04:11:10 <ivanm> heh
04:11:28 * ivanm passes pumpkin- some sleeping pills and one of those eyemasks you get on long flights
04:11:47 <ivanm> by "long", I mean cross-continental over-nighters
04:11:49 <pumpkin-> luckily my blinds are good at keeping the light out
04:12:10 <pumpkin-> it's been snowing outside too
04:12:30 <thoughtpolice> pumpkin-: where do you live?! still snow?
04:13:26 <pumpkin-> in NH
04:13:35 <ivanm> snow? oh, yeah, that frozen water stuff I've managed to avoid having anything to do with as yet!
04:13:36 <ivanm> ;-)
04:13:37 <pumpkin-> yeah, we usually have snow this late in the year
04:13:50 <pumpkin-> but this year it's been thawing and freezing a lot
04:13:53 <pumpkin-> so it's annoying
04:14:04 <pumpkin-> I can't go snowboarding cause the snow feels like gravel most of the time
04:16:38 <dolio> quicksilver: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2234#a2236 Traversable turns out to be less exciting than initially expected.
04:18:42 <Axman6> ivanm: fail :)
04:18:57 <ivanm> Axman6: fail what?
04:19:21 <Axman6> dolio: from my experience, that's a very rare occurance in here. how interesting! :)
04:19:28 <Axman6> ivanm: the lack of snow in your life
04:19:47 <ivanm> how is that a fail? I find it great! :D
04:19:50 * ivanm abhors the cold :s
04:20:01 <Axman6> you're in queensland right?
04:20:10 <pumpkin-> I'm a warm weather guy generally too, but I enjoy snowboarding enough to make cold worth it
04:20:23 <ivanm> yes
04:20:46 <quicksilver> dolio: where did "Pair" go?
04:21:13 <quicksilver> dolio: or, alternatively, why don't you need "f" any more?
04:22:44 <Saizan> he inlined the Id
04:23:26 <ivanm> Saizan: is this the same "Id" that Jung proposed? :p
04:23:42 <Saizan> @slap ivanm
04:23:42 * lambdabot secretly deletes ivanm's source code
04:23:51 <ivanm> ow!
04:23:58 <Axman6> @yow!
04:23:58 <lambdabot> Yow!  I threw up on my window!
04:24:03 <thoughtpolice> woot woot!
04:24:04 <thoughtpolice> http://hackage.haskell.org/trac/ghc/ticket/1895
04:24:08 <thoughtpolice> (bottom comment)
04:24:31 <thoughtpolice> maybe I should spend a weekend hacking that together for GHC HQ. :) it would be a nice feature really
04:25:15 <Axman6> whoot indeed :)
04:26:16 <ivanm> thoughtpolice: what, an automatic critical level upgrader based on CC number? :p
04:27:33 <dolio> quicksilver: I turned it into Cons fs a, since it was only used with f = Id.
04:30:03 <dolio> Same with Const () => Nil.
04:35:19 <Axman6> @hoogle Void
04:35:19 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:36:18 <Axman6> is there any reason () was chosen instead of something like data Void = Void?
04:36:54 <ImInYourMonad> any parsec gos out there? how do I match an arbitrary amount of letters and then parenthesis?
04:37:12 <dolio> That's isomorphic to ().
04:37:29 <Axman6> i know, just wondering where the naming/notation came from
04:37:52 <dolio> Usually you'd have 'data Void'.
04:38:09 <dolio> Assuming you mean the same Void as in, say, djinn.
04:39:04 <quicksilver> Axman6: well () is the unit of the operation which in haskell notation goes from a and b to (a,b)
04:39:14 <quicksilver> Axman6: so it's fairly natural.
04:42:22 * Axman6 waits for LLVM to compile
04:44:47 <ImInYourMonad> can Parsec recognize arbitrarily long series?
04:44:54 <ImInYourMonad> cat(tom) :- true.
04:45:03 <quicksilver> yes, it can
04:45:08 <ImInYourMonad> rhino(jon) :- true.
04:45:10 <ImInYourMonad> how?
04:45:12 <quicksilver> although if you want backtracking you have to ask for it specficially
04:45:14 <quicksilver> with try.
05:01:09 <jeltsch> How do I convert from an arbitrary Num instance into Double?=
05:01:23 <pozic> Are class and type constructor namespaces the same?
05:01:33 <blueonyx> :t fromIntegral
05:01:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
05:01:55 <jeltsch> This can only convert from Integral instances, not from arbitrary Num instances.
05:02:01 <doserj> jeltsch: you cannot in general
05:02:19 <jeltsch> What is the most general numeric class I can convert from into Double?
05:02:47 <jeltsch> All Integral types should work, all rational types should work, all floating point types should work, what doesn’t?
05:02:59 <int-e> @src realToFrac
05:03:00 <lambdabot> realToFrac = fromRational . toRational
05:03:10 <jeltsch> :t realToFrac
05:03:11 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
05:03:19 <int-e> @instances Real
05:03:20 <lambdabot> Double, Float, Int, Integer
05:03:30 <jeltsch> realToFrac excludes Integral types, doesn’t it?
05:03:41 <int-e> no it doesn't.
05:03:55 <jeltsch> Ah, from Real not from Fractional. The order in the context is misleading.
05:04:11 <jeltsch> Okay, thanks.
05:04:29 <jeltsch> @instances Fractional
05:04:29 <lambdabot> Double, Float
05:04:33 <jeltsch> Ok.
05:04:59 <jeltsch> I would have expected Rational types being instances of Fractional, not floating point types.
05:05:01 <int-e> @instances-importing Data.Ratio Fractional
05:05:02 <lambdabot> Double, Float, Ratio a
05:05:45 <jeltsch> So what Num instances are not Real instances?
05:06:01 <jeltsch> @instances Num
05:06:02 <lambdabot> Double, Float, Int, Integer
05:06:04 <jeltsch>  @instances Real
05:06:21 <jeltsch> lambdabot, where are you?
05:06:30 <jeltsch> @instances Real
05:06:30 <lambdabot> Double, Float, Int, Integer
05:06:43 <jeltsch> Hmm, was lambdabot on the toilet?
05:07:17 <Axman6> you put a space in
05:07:22 <Axman6> < jeltsch>  @instances Real
05:07:28 <Axman6> < jeltsch> @instances Real
05:08:45 <HugoDaniel> how do i make a function f :: a -> [a] -> [[a]]such that [ [first_arg, second_arg1], [first_arg, second_arg2], ... ] ?
05:09:07 <HugoDaniel> im trying around with list comprehensions but i think im using the wrong tool again
05:09:41 <ivanm> HugoDaniel: f a as = map (\a' -> [a, a']) as
05:09:49 <doserj> Jeltsch: complex numbers, function rings, power series, etc.
05:09:50 <ivanm> @pl f a as = map (\a' -> [a, a']) as
05:09:50 <lambdabot> f = map . (. return) . (:)
05:10:14 <HugoDaniel> thanks ivanm
05:10:15 <HugoDaniel> :)
05:10:20 <ivanm> no worries
05:15:26 <viraptor> is there any advantage to use @pl version instead of the 'standard' one?
05:17:06 <mmorrow> dolio: this is kinda neat (and as i just found out almost identical to your earlier paste, save for the `nat' function that makes it convenient) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1824#a1824
05:17:22 <mmorrow> -- ghci> nest $(nat 18) (:[]) 42
05:17:22 <mmorrow> -- [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
05:18:07 <Axman6> viraptor: not in my opinion. sometimes it's clearer, but if you have more than one variable taken in by the function, or the result had more than one flip, const and/or ((f .) . g) then don't use it
05:18:18 <Axman6> that's my extended rule of thumb
05:18:39 <viraptor> :) thanks
05:19:09 <Axman6> take for example:...
05:19:28 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
05:19:32 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
05:19:32 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
05:19:32 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
05:19:32 <lambdabot> optimization suspended, use @pl-resume to continue.
05:21:43 <dolio> mmorrow: Well, the other half of the challenge I was responding to was can you do it "with an ADT?" If we're going to allow all kinds of type-level fanciness, we might as well use nice sized vectors.
05:22:13 <dolio> mmorrow: Or, wait, is this deep-map?
05:22:19 <mmorrow> it could be
05:22:59 <dolio> Interesting peano encoding.
05:24:18 <mmorrow> if we can use TH, then
05:24:21 <mmorrow> , $(fmaps 18) (*2) [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
05:24:23 <lunabot>  luna: Context reduction stack overflow; size = 20
05:24:25 <mmorrow> wut
05:24:33 <dolio> Heh.
05:24:37 <mmorrow> , $(fmaps 12) (*2) [[[[[[[[[[[[[42]]]]]]]]]]]]]
05:24:39 <lunabot>  luna: No instance for (GHC.Num.Num [t])
05:24:43 <ivanm> lol
05:24:44 <mmorrow> grr
05:24:48 <ivanm> mmorrow: your bot, you fix it ;-)
05:25:10 <mmorrow> , $(fmaps 12) (*2) [[[[[[[[[[[[42]]]]]]]]]]]]
05:25:13 <lunabot>  [[[[[[[[[[[[84]]]]]]]]]]]]
05:25:18 <mmorrow> i just miscounted :)
05:25:32 <ivanm> heh
05:25:57 * ivanm passes mmorrow a basic book on maths
05:26:24 <dolio> Counting for dummies.
05:26:32 <mmorrow> tries to add it to his bookshelf, fails
05:26:35 <mmorrow> + /me
05:27:46 <dolio> Or perhaps he'd prefer a copy of Kiss My Math.
05:27:55 <ivanm> heh
05:28:22 <mmorrow> ooh, yeah i want that one
05:28:24 <dolio> He seems like the Cosmo-reading type.
05:28:27 <mmorrow> heh
05:29:14 <Axman6> , typ "$(fmaps 12)"
05:29:17 <lunabot>  "forall (f :: * -> *)\n       (f :: * -> *)\n       (f :: * -> *)\n      ...
05:29:24 <mmorrow> wut!!
05:29:34 <Axman6> o.O
05:29:37 <Axman6> , typ "$(fmaps 3)"
05:29:40 <lunabot>  "forall (f :: * -> *) (f :: * -> *) a b (f :: * -> *).\n(GHC.Base.Functor...
05:29:46 <Axman6> , typ "$(fmaps 2)"
05:29:48 <dolio> Nice.
05:29:49 <lunabot>  "forall (f :: * -> *) a b (f :: * -> *).\n(GHC.Base.Functor f, GHC.Base.F...
05:29:57 <mmorrow> , ppDoc `fmap` fmaps 8
05:30:00 <dolio> , [$ty| either Right Left |]
05:30:01 <lunabot>  fmap . (fmap . (fmap . (fmap . (fmap . (fmap . (fmap . fmap))))))
05:30:04 <lunabot>  forall a a . Either a a -> Either a a
05:30:16 <mmorrow> dolio: gah, i don't know what is happening there
05:30:22 <dolio> You figure that one out yet?
05:30:24 <mmorrow> i don't _think_ it's my fault..
05:30:36 <dolio> I'm willing to believe it's the GHC api.
05:30:49 <mmorrow> dolio: hrm, wait i might have.. i just can't remember
05:30:57 <mmorrow> dolio: yeah, i think it is
05:31:15 <dolio> If it is you should probably complain at someone.
05:31:28 <mmorrow> it's weird though, because i thought ghci was using that same function..
05:31:34 <ivanm> dolio: at himself maybe? ;-)
05:31:57 <dolio> Tell pumpkin to fix it when he adds those GMP primops.
05:32:03 <mmorrow> dolio: yeah, i should try to figure out what it is
05:32:40 <mmorrow> dolio: heh, "oh btw, while you're in there..."
05:32:44 <EvilTerran> , [$ty|typ|]
05:32:46 <lunabot>  String -> String
05:32:53 <EvilTerran> , [$ty|ty|]
05:32:56 <lunabot>  QuasiQuoter
05:33:00 <mmorrow> , [$ty|tyQ|]
05:33:03 <lunabot>  QuasiQuoter
05:33:06 <mmorrow> grr
05:33:18 <mmorrow> , [$ty|[$tyQ|\x->x\|]|]
05:33:21 <lunabot>  Type
05:33:28 <mmorrow> , [$tyQ|[$tyQ|\x->x\|]|]
05:33:31 <lunabot>  ConT Type
05:33:40 <mmorrow> , [$tyQ|\x->x|]
05:33:43 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
05:33:46 <mmorrow> , [$ty|\x->x|]
05:33:49 <lunabot>  forall a . a -> a
05:33:52 <mmorrow> :)
05:34:12 <dolio> , [$tyQ| either Right Left |]
05:34:14 <lunabot>  ForallT [a,a] [] (AppT (AppT ArrowT (AppT (AppT (ConT Either) (VarT a)) (...
05:34:19 <mmorrow> fail
05:34:43 <trofi^w> , $tyQ
05:34:44 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
05:35:25 <mmorrow> too bad you can't splice types
05:35:39 <mmorrow> you can list them into an expression though..
05:35:42 <mmorrow> *lift
05:35:58 <mmorrow> , $(lift . return $ [$tyQ|\x->x|])
05:36:01 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
05:36:02 <mmorrow> oops
05:36:07 <mmorrow> , $(lift [$tyQ|\x->x|])
05:36:10 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (VarT a)) (VarT a))
05:36:19 <mmorrow> which is just id i guess..
05:36:26 <mmorrow> , lift [$tyQ|\x->x|]
05:36:29 <lunabot>  AppE (AppE (AppE (ConE ForallT) (ListE [AppE (AppE (ConE Name) (AppE (Var...
05:37:11 <mmorrow> ooh, i guess maybe you could kinda get type/decl splicing by lifting everything a meta-level up into an ExpQ, splicing there, then splicing that back
05:37:19 <Saizan> sigE is your friend
05:37:22 <mmorrow> err, maybe that wouldn't work
05:37:25 <mmorrow> Saizan: true
05:37:29 <mmorrow> oooh, totally
05:37:34 <mmorrow> hmm
05:37:49 <Saizan> in expressions only
05:39:17 <mmorrow> ,   $((\t -> [| sigE 42 $(lift =<< t) |]) [t|Int|])
05:39:19 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.TypeQ'
05:39:39 <mmorrow> ,   $((\t -> [| sigE 42 (return $(lift =<< t)) |]) [t|Int|])
05:39:41 <lunabot>  luna: No instance for (GHC.Num.Num Language.Haskell.TH.Lib.ExpQ)
05:39:46 <mmorrow> hmm
05:40:23 <mmorrow> ,   [$ty| (\t -> [|sigE 42 (return $(lift =<< t))\|]) |]
05:40:26 <lunabot>  forall a . Lift a => Q a -> ExpQ
05:40:51 <mmorrow> ohh
05:41:14 <mmorrow> ,   $((\t -> [|sigE (lift (42::Int)) (return $(lift =<< t))|]) [t|Int|])
05:41:16 <lunabot>  SigE (LitE (IntegerL 42)) (ConT Int)
05:41:36 <mmorrow> ,   let e = $((\t -> [|sigE (lift (42::Int)) (return $(lift =<< t))|]) [t|Int|]) in $e
05:41:38 <lunabot>  luna: GHC stage restriction: `e'
05:41:45 <mmorrow> i hate that
05:43:17 <mmorrow> ,   $((return . fromJust . fromDynamic . eval) "unQ $((\\t -> [|sigE (lift (42::Int)) (return $(lift =<< t))|]) [t|Int|])")
05:43:20 <lunabot>  42
05:43:22 <mmorrow> woot!!
05:44:28 <mmorrow> hmm, i'm not really sure what exactly that achieved (if anything)..
05:45:18 <ivanm> mmorrow: can't you test your own bot offline? :o
05:45:22 <ivanm> ;-)
05:45:41 <mmorrow> ivanm: amusingly, i actually can't :)
05:46:00 <ivanm> stuffed up, hey? :p
05:46:16 <mmorrow> perhaps
05:46:48 <ivanm> or did you try and keep lunabot strictly IRC and not CLI?
05:46:51 * mmorrow has no idea what that means, answers with non-sequitors :)
05:47:07 <mmorrow> ivanm: ohhh, yeah i can in that sense yes.
05:47:18 <ivanm> heh
06:45:08 <BONUS> @let anyM p = liftM or . mapM p
06:45:11 <lambdabot>  Defined.
06:45:20 <BONUS> @let allM p = liftM and . mapM p
06:45:23 <lambdabot>  Defined.
06:50:53 <BONUS> > allM (const [True, False]) [3,4,5,6]
06:50:55 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
06:50:59 <BONUS> ah
06:57:08 <ultrakrankerhamp> @pl \x y -> 2*x + 3*y
06:57:09 <lambdabot> (. (3 *)) . (+) . (2 *)
06:57:46 <ultrakrankerhamp> @pl \x y -> x + y
06:57:46 <lambdabot> (+)
06:58:06 <ultrakrankerhamp> @hoogle [a] -> Bool
06:58:06 <lambdabot> Prelude null :: [a] -> Bool
06:58:06 <lambdabot> Data.List null :: [a] -> Bool
06:58:06 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
06:58:13 <dolio> (2*) *** (3*) >>> uncurry (+)
06:58:15 <chowmeined> when dealing with concurrent servers, say you receive a message from a client on on thread and then want to send a few messages on a few other threads, whats a good way to structure that? I suppose if the threads sent messages using a shared server state (having socket handles) it would cause race conditions
06:58:30 <ultrakrankerhamp> @hoogle a -> b
06:58:31 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:58:31 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:58:31 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:59:13 <ultrakrankerhamp> > 5 + 5
06:59:15 <lambdabot>   10
07:00:50 <ultrakrankerhamp> @pl \(i, w) -> (i, f i)
07:00:51 <lambdabot> ap (,) f . fst
07:01:10 <ultrakrankerhamp> :t ap
07:01:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:01:34 <quicksilver> chowmeined: use a Chan to send the messages over to the sender-threads
07:01:51 <chowmeined> quicksilver, is that in hackage somewhere?
07:01:57 <quicksilver> chowmeined: no, it's a core GHC library
07:02:02 <quicksilver> Control.Concurrent.Chan
07:02:36 <chowmeined> quicksilver, oh thanks
07:14:42 <ultrakrankerhamp> @pl \pos -> x ! pos == player
07:14:43 <lambdabot> (player ==) . (x !)
07:15:05 <skorpan`> :t (!)
07:15:07 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
07:15:49 * ultrakrankerhamp eats salat
07:18:34 <Deewiant> Is there no easy way of using the same Haddock docstring in two different places without copy-pasting it?
07:24:11 <dcoutts_> Deewiant: there's a named doc feature
07:24:32 <Deewiant> dcoutts_: Doesn't work for toplevel declarations
07:24:57 <Deewiant> Only for stuff which isn't attached to declarations
07:25:54 <dcoutts_> Deewiant: ok, file a ticket with your use case
07:26:08 <dcoutts_> give a nice clear example in the ticket
07:26:23 <Deewiant> Data.Map and Data.IntMap are the obvious example :-)
07:26:35 <Deewiant> I think there've even been cases where they're out of sync
07:29:23 <thoughtpolice> mmorrow: looking at appel's continuations book the way it marks what registers contain root pointers is clever but I'm not sure it's viable for my stuff.
07:30:22 <thoughtpolice> mmorrow: it's full of ideas at least. :)
07:34:25 <kohwj> i'm not sure about the naming conventions for libraries- "Data.Map" makes sense for key-value pairs, and "Graphics.Rendering.Chart" for cairo-based charts, but what about a regular point-and-shape geometry library?
07:35:06 <kohwj> containing data types like "Point (data Point = Point {x :: Integer, y :: Integer}", "Rectangle", "Circle", etc
07:36:54 <orgroot> PING hoi
07:39:05 <pejo> JaffaCake, been reading your paper; do you have any numbers on how many steals that typically occur?
07:39:08 <Botje> PONG
07:39:35 <JaffaCake> pejo: no, but I don't expect there's anything surprising there
07:39:35 <lambdabot> JaffaCake: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:40:12 <ultrakrankerhamp> @pl \f x y -> f y x
07:40:13 <lambdabot> flip
07:40:23 <ultrakrankerhamp> :t flip
07:40:24 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:41:03 <ultrakrankerhamp> @upl flip
07:41:03 <lambdabot> Maybe you meant: pl unpl url
07:41:15 <ultrakrankerhamp> @unpl flip
07:41:15 <lambdabot> (\ a b c -> a c b)
07:41:59 <ultrakrankerhamp> @pl \x y -> y / x
07:41:59 <lambdabot> flip (/)
07:42:15 <ultrakrankerhamp> @pl \x y -> y + x
07:42:15 <lambdabot> (+)
07:43:45 <pejo> JaffaCake, was mostly curious about how common it is, but haven't found any concrete numbers anywhere. (Speaking of that, are you aware of "Idempotent Work Stealing" by Michael et al.?)
07:44:28 <jeltsch> Gtk2Hs question: How do I get the set of all selected rows?
07:44:43 <JaffaCake> pejo: stealing is the only way that sparks get distributed, so it's pretty common
07:44:57 <JaffaCake> re the paper, I have it on my desk waiting to be read :)
07:44:59 <dcoutts_> jeltsch: there's a selection object
07:45:29 <jeltsch> dcoutts_: Where?
07:45:29 <JaffaCake> amongst a stack of other interesting papers waiting to be read :-/
07:46:16 <dcoutts_> jeltsch: did you look in the documentation at all?
07:46:38 <jeltsch> dcoutts_: YES!!
07:47:16 <jeltsch> dcoutts_: Through the complete attributes and signals section of TreeView.
07:47:34 <pejo> JaffaCake, executive summary: "we allow running the same task several times and present some algorithms for queues that only have CAS in steal(). This is way faster than the Chase-Lev deque".
07:47:35 <jeltsch> dcoutts_: Ah, treeViewGetSelection.
07:48:10 <JaffaCake> pejo: yes, I'm familiar with the gist (someone else sent me a link to the paper)
07:48:11 <jeltsch> dcoutts_: I find that pretty awkward at times: Sometimes you have attributes, sometimes you have getter functions, sometimes you have both. What’s the reason for this?
07:48:42 <dcoutts_> jeltsch: the get/set methods are on their way out, to be replaced by attributes.
07:48:54 <JaffaCake> pejo: I doubt the CAS is the main bottleneck right now (I'd be delighted if it was though)
07:49:00 <jeltsch> dcoutts_: Ok.
07:49:17 <dcoutts_> jeltsch: but the transition is taking a while, but that's also so people's existing code does not break. It does make the docs pretty big sadly.
07:49:56 <jeltsch> dcoutts_: Yes, but introducing attributes doesn’t break peoples code.
07:50:05 <dcoutts_> jeltsch: right
07:50:48 <dcoutts_> jeltsch: the progression will be, add attributes for everything, deprecate get*/set* functions, and eventually remove them from the documentation and finally remove them completely.
07:51:32 <pejo> JaffaCake, nods, I'd like to measure the overhead of various queues under something that could be considered a "reasonable" work-load, and this seems to imply that some stealing would occur. No fancy theory, just to see how expensive various building blocks are.
07:52:40 <JaffaCake> pejo: feel free, the work-stealing queue implementation in GHC is quite well abstracted
07:53:02 <pejo> JaffaCake, nods, I was planning on borrowing it. :-)
07:53:06 <Deewiant> dcoutts_: Filed http://trac.haskell.org/haddock/ticket/97
07:53:27 <JaffaCake> pejo: I wish I'd borrowed one from somewhere, took me ages to get this one right
07:53:42 <JaffaCake> the barriers are very subtle
07:53:48 <pejo> JaffaCake, the header in it says it's written by Jost Berthold though?
07:53:56 <JaffaCake> originally, yes
07:54:07 <JaffaCake> his code had a lot of bugs I had to find later though :)
07:58:49 <pejo> JaffaCake, ok, thanks a bunch again. Liked the paper, gives a good overview of things!
07:59:21 <JaffaCake> great, glad you liked it
07:59:32 <JaffaCake> go and tell the ICFP committee ;)
08:00:08 <pejo> JaffaCake, they're wise enough to not listen to me. ;)
08:02:17 <eu-prleu-peupeu> hello
08:05:17 <sioraiocht> @src concat
08:05:17 <lambdabot> concat = foldr (++) []
08:05:55 <dons> here's a writeup on using the genetic algorithm lib i've been using to find better inlining heuristics ,
08:05:59 <dons>   http://www.reddit.com/r/programming/comments/838pv/evolving_faster_haskell_programs/
08:06:10 <eu-prleu-peupeu> l33t
08:06:11 <dons> (the one that sped up k-nuck on the shootout by 18% :)
08:07:57 <guenniofftobed5> how can I create an instance of Data Pico?
08:11:06 <pejo> dons, is -fecess-precision in your blogpost supposed to be excess-precision?
08:11:28 <wli> How appropriate. ;)
08:11:42 <dons> pejo: ah looking.
08:12:32 <dons> missing an 'x'
08:12:38 <dons> thanks
08:13:36 <wli> I'm not sure how that one survived the hardware design spec never mind got to public release.
08:16:02 <quicksilver> dons will come to regret the "pesky lazy languages" remark
08:16:15 <quicksilver> it will be quoted back to him in the -cafe for ever more!
08:16:40 <dons> well, for benchmarking purposes, rnf saves the day
08:17:24 <wli> "You lazy language! When I was your age I had 15 job."
08:18:04 <pozic> Does it matter in which order StateT and ContT are composed?
08:18:15 <ski> yes !
08:18:27 <ski> @untml StateT s (Cont o) a
08:18:27 <lambdabot> Maybe you meant: unmtl unpl
08:18:31 <ski> @unml StateT s (Cont o) a
08:18:31 <lambdabot> Maybe you meant: unmtl unpl
08:18:33 <ski> @unmtl StateT s (Cont o) a
08:18:33 <lambdabot> s -> (a -> s -> o) -> o
08:18:40 <ski> @unmtl ContT o (State s) a
08:18:40 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
08:18:56 <ski> those are quite different monads
08:19:10 <pozic> What is the difference?
08:19:37 <wli> I can't figure out how to use ContT to save my life anyway, so I don't worry about it much.
08:19:44 <ski> in the former, each continuation is called with a state
08:19:58 <ski> in the latter, the continuations also return a state
08:20:22 <ski> (i'm not sure about what this entails .. haven't played much with `ContT o (State s)')
08:21:15 <ski> btw, cf.
08:21:22 <mmorrow> @unmtl StateT s (Cont o) a
08:21:22 <lambdabot> s -> (a -> s -> o) -> o
08:21:25 <ski> @untml ContT o (Reader s) a
08:21:25 <lambdabot> Maybe you meant: unmtl unpl
08:21:29 <mmorrow> is actually pretty much just a State monad
08:21:30 <ski> @unmtl ContT o (Reader s) a
08:21:30 <lambdabot> (a -> s -> o) -> s -> o
08:22:01 <mmorrow> http://moonpatio.com/repos/monad-cps/src/Control/Monad/CPS/S.hs
08:22:06 <ski> mmorrow : we'll you get continuation operators, too
08:22:10 <ski> s/'//
08:22:17 <mmorrow> ski: yes, which is lovely :)
08:22:23 <mmorrow> summary:
08:22:25 <mmorrow> newtype S s a = S {unS :: forall o. s -> (s -> a -> o) -> o}
08:22:31 <mmorrow> S g >>= f = S (\s k -> g s (\s a -> unS (f a) s k))
08:22:34 <mmorrow> </summary>
08:22:46 <ski> wel, if you `forall o.' the `o', then that's different, of course
08:22:48 * wli does not grok callCC at all.
08:22:52 <mmorrow> oh, yeah right
08:23:01 <mmorrow> i wasn't paying attention to that
08:23:12 <mmorrow> heh, ok scratch what i said then :)
08:23:20 <quicksilver> haha, GA decides to inline an unsafePerformIO
08:23:21 <ski> so that `S s' is just an optimization on `State s', basically
08:23:30 <mmorrow> yes, exactly
08:23:30 <quicksilver> that's your come-uppance for using the global IORef hack ;)
08:23:44 <PeakerWork> quicksilver: GA?
08:23:44 <ski> wli : to grok it, you need to play with it (and possibly read a few papers about continuations)
08:23:57 <quicksilver> PeakerWork: genetic algorithm. dons' blog post
08:24:03 <PeakerWork> oh
08:24:40 <mmorrow> acovea is cool
08:24:50 <mmorrow> i've always meant to try it
08:25:36 <mmorrow> wli: all the "magic" of Cont is in the definition of (>>=)
08:25:46 <ski> @src Cont (>>=)
08:25:46 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
08:26:10 <mmorrow> wli: it essentially reverses what happens first
08:26:39 <ski> (hm .. "reverses" ?)
08:26:47 <mmorrow> yeah, bad choice of words..
08:26:58 <mmorrow> rephrasing:
08:28:09 <mmorrow> the cont `c' (using the above code's varnames) gets passed as a cont to the result of evaluating "k a", and all of this is passed as a cont to `m'
08:28:19 <mmorrow> so s/reverses/turns inside-out/
08:29:17 <ski> i'm not sure yet what you mean is turned inside-out, here ..
08:30:43 <mmorrow> > flip runCont id (Cont (\_ -> 42) >>= undefined)
08:30:45 <lambdabot>   42
08:31:36 <mmorrow> so i guess what i'm trying to say is that in "m >>= k", it's `m' that really has the final word as to the outcome, not `k'
08:32:01 <wli> yeah
08:32:05 <pozic> What's the point of the first argument to runCont? By that I mean why it exists at all, not what its current "function" is.
08:32:47 <ski> pozic : maybe you mean the second argument ?
08:33:17 <pozic> ski: yes, I did.
08:33:21 <ski> > runCont (Cont (\_ -> 42) >>= undefined) id
08:33:22 <lambdabot>   42
08:33:30 <ski> it's the current continuation
08:33:48 <ski> here we set it initially to `id' to extract the top-level result
08:34:11 <mmorrow> > runCont (return 42) (*2)
08:34:13 <lambdabot>   84
08:34:17 <ski>   ma >>= (\a -> amb a >>= (\b -> abmc a b))  =  Cont (\ka -> ma `runCont` (\a -> amb a `runCont` (\b -> abmc a b `runCont` kc)))  -- hm
08:34:23 <mmorrow> > runCont (Cont (\k -> k 42)) (*2)
08:34:25 <lambdabot>   84
08:34:40 <ski> maybe we should try the other way, to see the "turning inside-out" ..
08:34:49 <ski> (s/ka/kc/)
08:36:01 <chowmeined> is there a tutorial available on using Chan?
08:36:52 <wli> chewing on it
08:37:16 <ski>   (ma >>= (\a -> amb a)) >>= (\b -> bmc b)  =  Cont (\kc -> ma `runCont` (\a -> amb a `runCont` (\c -> bmc b `runCont` kc)))
08:37:23 <ski> that looks maybe better
08:38:07 <ski> irrespective of the associatedness of the original `>>='-chain, the resulting computation is basically the same anyway
08:39:04 <ski> (here, instead of first doing `ma' and then `amb a', and after that doing `bmc' .. we are actually doing `ma' first, and after that doing `amb a' and then `bmc b')
08:41:19 <pozic> Can I get continuations of multiple positions? I.e. I want to get continuations a, b and c for the following code: d;e;f (a, b and c are the continuations just after respectively d, e and f).
08:43:32 <ski> where do you want `a',`b',`c' in scope ?
08:46:00 <pozic> ski: I would like them to be fields of a constructor.
08:46:19 <pozic> ski: (Stored in a StateT)
08:46:20 <ski> "them" being ?
08:46:29 <pozic> ski: them being a, b and c.
08:46:45 <wli> i'm too distracted.
08:46:54 <ski> so you want to capture them, and then store them in the state ?
08:47:13 <pozic> ski: yes
08:48:10 <ski> and the next time you execute `e' there, do you want to store a new continuation in `b' ?
08:48:17 <mreh> len :: Point -> Double
08:48:17 <mreh> len (x, y) = sqrt (x^2 + y^2)
08:48:27 <mreh> lads why does the expression on the lhs return an int?!
08:48:36 <mreh> that's what ghci tells me
08:48:47 <ski> how is `Point' defined ?
08:48:47 <wjt> :t (^)
08:48:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
08:48:52 <mreh> (Double, Double)
08:49:13 <pozic> ski: executing e does not change anything.
08:49:37 <ski> pozic : no, but you must be about to execute `e' to be able to capture the `b' continuation
08:50:05 <mreh> wjt: the return type is an Integeral of (^)?
08:50:09 <ski> mreh : are you calling `len' from somewhere, with an `(Int,Int)'-typed expression ?
08:50:16 <mreh> nope
08:50:52 <mreh> it's a simple type mismatch
08:50:53 <ski> > let len :: (Double,Double) -> Double; len (x, y) = sqrt (x^2 + y^2); len (1.0,1.0)
08:50:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:51:01 <ski> > let len :: (Double,Double) -> Double; len (x, y) = sqrt (x^2 + y^2) in len (1.0,1.0)
08:51:02 <lambdabot>   1.4142135623730951
08:51:11 <ski> > let len :: (Double,Double) -> Double; len (x, y) = sqrt (x^2 + y^2) in len (1,1)
08:51:12 <lambdabot>   1.4142135623730951
08:51:21 <ski> seems to work o-k, here
08:52:08 <pozic> ski: why can't I do that? It's about the same as jumping to an arbitrary address in assembly.
08:52:16 <mreh> i'm so confused
08:52:38 <ski> pozic : `callCC' captures the *current* continuation of a "sub-expression"
08:52:38 <mreh> im using the previous version of GHCI
08:52:54 <ski> pozic : it does not (directly) allow the labelling of any expression
08:53:23 <ski> mreh : what happens if you paste the example just above into your GHCi ?
08:53:25 <pozic> ski: ok, so, is there anything which isn't called callCC, but does what I want?
08:53:39 <ski> i'm not quite sure what you want
08:54:00 <mreh> ski: i'll try
08:56:46 <mreh> how do i write multiple lines in GHCI?
08:56:52 <mreh> semi colon doesn't seem to work
08:56:58 <mreh> im searching the man pages
08:57:05 <ski> don't write multiple lines
08:57:20 <ski> just write `;' (and possibly `{',`}', as appropriate)
08:57:23 <sioraiocht> dcoutts: ping?
08:57:36 <dcoutts_> sioraiocht: pong
08:57:45 <ski> (the example above should work as-written, in GHCi)
08:58:06 <ziman> there's the :{ <lines> :} thing, iirc
08:58:08 <mreh> gives me a parse error on the semi-colon
08:58:08 <sioraiocht> dcoutts: did jim mention my work with fingertrees as ropes to you?
08:58:16 <mreh> ah
08:58:31 <dcoutts_> sioraiocht: yep, good stuff, esp for Data.Text
08:58:51 <ski> (i suppose one can define stuff like `getLabel :: a -> Cont o (Label o a,a)',`jumpLabel :: a -> Label o a -> Cont o b' ..)
08:58:53 <sioraiocht> well, I have some abstract untuned stuff done
08:59:02 <dcoutts_> sioraiocht: if it's fast enough on average then it might be a good default since it's got much better concat perf and concat is such a common op for strings
08:59:07 <mreh> ski: the answer is 1.41 etc
08:59:19 <mreh> i'm going to get my baseball bat
08:59:26 <ski> why so ?
08:59:44 <mreh> to reprogram this hunk of junk with it
08:59:46 <sioraiocht> the ropes paper doesn't really mention chunk size/merging very clearly.  Was just wondering your opinion on optimal chunk sizes
08:59:57 <sioraiocht> do you think they ought to be word sized? cache sized?
09:00:33 <ski> ziman : ah
09:00:49 <mreh> ski: the compiler tells me it infers Int from "sqrt(x^2 + y^2)"
09:00:59 <mreh> and I've just proven it returns a double
09:01:02 <dons> :t sqrt
09:01:04 <lambdabot> forall a. (Floating a) => a -> a
09:01:06 <dcoutts_> sioraiocht: chunk merging heuristics are going to be the key part of any of this
09:01:06 <dons> it can't be an Int
09:01:16 <ziman> :t (^)
09:01:17 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:01:34 <ski> mreh : maybe now is a good time for pasting your code (with context) ?
09:01:54 <mreh> there is no context
09:02:00 <dcoutts_> sioraiocht: average time will be good if we have direct access to the first few bytes, which as I understand it we do, because we keep the first chunk directly in a constructor
09:02:05 <mreh> I've just started writing a fresh library
09:02:12 <ski> mreh : so `len' is all there is in your module ?
09:02:21 <mreh> that and a type definition
09:02:32 <ski>   type Point = (Double,Double)
09:02:33 <sioraiocht> dcoutts_: in finger trees? yes
09:03:17 <sioraiocht> if you're dealing with the ends of sequence primarily, which are you in merging, etc, fingertrees do very well
09:03:27 <dcoutts_> sioraiocht: are you in the lab, want to come down and talk about it?
09:03:33 <mmorrow> sioraiocht: cool, fingertrees used for something? link?
09:03:47 <dcoutts_> mmorrow: for a standard implementation of Data.Text
09:03:47 <sioraiocht> mmorrow: well, not just yet, working on it right now
09:03:58 <mmorrow> interesting
09:04:04 <sioraiocht> dcoutts_: am not in the lab right now, but was gonna head there in a few minutes
09:04:05 <ski> mreh : sorry to have to ask about this, but are you sure you've (a) saved the current version you're reading (b) loaded this current version into GHCi ?
09:04:24 <mreh> ski: indeed
09:04:34 <mmorrow> dcoutts_, sioraiocht: so we're talking about fingertrees of ByteStrings?
09:04:45 <mreh> ill hpaste it
09:04:51 <dcoutts_> mmorrow: right but for unicode
09:05:01 <dcoutts_> sioraiocht: ok, well pop in when you get here
09:05:03 <mmorrow> ooh, this sounds way cool :)
09:05:10 <ski> mreh : please include exactly how you invoke `GHCi', and what you type into it to test the program
09:05:17 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2239#a2239
09:05:32 <mreh> prelude> :load Graphics.hs
09:05:36 <mreh> that's all i did
09:05:40 <ski>   type Point = (Int, Int)
09:05:43 <ski> that's your problem
09:06:03 <ski> you said you had `(Double,Double)' before
09:06:07 <mreh> :D
09:06:10 <ski> which do you actually want ?
09:06:16 <mreh> (Int, Int)
09:06:19 <mreh> it's for graphics
09:06:27 <mreh> what do you suggest?
09:06:28 <ski> then use `fromIntegral' to convert to `Double
09:06:32 <ski> '
09:06:51 <ski>   sqrt (fromIntegral (x^2 + y^2))
09:06:52 <ski> e.g.
09:06:57 <mreh> with graphics, is it worth keeping the precision
09:07:10 <mm_freak> @src hashUnique
09:07:10 <lambdabot> Source not found. You type like i drive.
09:07:44 <ski> precision of what ?
09:08:15 <thoughtpolice> mmorrow: oh and i found the sml-98 source to really be surprisingly readable, especially with the papers out next to it. but after looking at how GC roots are saved in sml's case (or at least they were,) i'm going to try a different strategy, although encoding them one way or another is necessary
09:08:29 <skorpan> in typeclassopedia, byorgey speaks of "MaybeT" which is supposed to be available "soon".  when is that?
09:08:56 <ski> (thoughtpolice : `sml-98' ? .. is that an implementation of SML ?)
09:08:59 <mmorrow> thoughtpolice: hmm, how exactly are they saved?
09:09:16 <thoughtpolice> ski: it's an older version of smlnj, sorry for not clarifying. :)
09:09:21 <ski> ok, ty
09:09:33 <glguy> skorpan, for now when you need MaybeT like behavior, you can use ChoiceT and findOne
09:09:59 <skorpan> glguy: i don't really need it, i'm just curious as to why it's currently not available and when it will be
09:10:10 <glguy> skorpan, it isn't necessary
09:10:15 <mmorrow> thoughtpolice: i'm thinking of, at each heapcheck point, knowing exactly which registers have ptrs in them + which stack slots are ptrs (if i have a stack)
09:10:20 <glguy> so I’d guess that it would be a while
09:10:31 <thoughtpolice> mmorrow: the design is really clever, but it seems kind of bound to CPS in a certain way
09:10:42 <wli> runContT :: ContT () IO IOError -> (IOError -> IO ()) -> IO () looks familiar.
09:11:11 <mmorrow> thoughtpolice: oh, ok. so you're talking about the "bundling everything into a record, and jumping to the gc" thing?
09:11:12 <ski> how so ?
09:11:25 <ski> (wli)
09:11:28 <thoughtpolice> mmorrow: basically, the beginning of every CPS function is a safepoint, because after closure conversion/spilling/hoisting etc, cps calls aren't recursive.
09:11:34 <wli> catch :: forall a. IO a -> (IOError -> IO a) -> IO a
09:11:38 <Eridius> wow, ghc seems stuck compiling a single file from the encoding package
09:11:41 <Eridius> [43 of 47] Compiling Data.Encoding.JISX0208 ( Data/Encoding/JISX0208.hs, dist/build/Data/Encoding/JISX0208.o )
09:11:44 <Eridius> it's shown that for about a minute now
09:11:44 <thoughtpolice> so what happens is, is the compiler inserts an arithmetic trick to try and trigger and overflow interrupt
09:11:49 <Eridius> and yet pegging one of my cores at 100%
09:11:53 <thoughtpolice> the overflow interrupt happens when the GC gets close to running out of memory
09:12:09 <thoughtpolice> the reason it's done this way is because the overflow+addition etc. can all normally be done in about one instruction
09:12:11 <glguy> Eridius, does that file have a large number of constants inside?
09:12:12 <ski> wli : but note that the `ContT () IO IOError' argument action monadically returns `IOError', not any `a'
09:12:13 <thoughtpolice> so it's ridiculously cheap, really
09:12:17 <Eridius> glguy: I don't know
09:12:29 <thoughtpolice> anyway, the interrupt trap is caught by the runtime system
09:12:40 <wli> @unmtl ContT () IO IOError
09:12:41 <lambdabot> (IOError -> IO ()) -> IO ()
09:12:48 <thoughtpolice> every CPS function, before its beginning, has a masked word sitting there
09:12:58 <thoughtpolice> this masked word actually encodes what registers have root pointers in them
09:13:12 <thoughtpolice> the runtime system pulls this out and enumerates it so it knows what registers to look for at every safe point
09:13:19 <Eridius> glguy: actually the file is very small
09:13:27 <Eridius> though it's using template haskell, so I don't know what it expands to
09:13:29 <ski> @unmtl MaybeT m a
09:13:29 <lambdabot> m (Maybe a)
09:13:29 <thoughtpolice> the compiler relies on in-line expansion/optimization to remove CPS calls where unnecessary
09:13:36 <thoughtpolice> to decrease some of the overhead of having so many safe points
09:13:43 <mmorrow> thoughtpolice: ahh, ok.
09:13:47 <wli> ski: I think the return is in the first arg position.
09:14:09 <Cheshire> thoughtpolice: does that also mean TCO
09:14:22 <mmorrow> Cheshire: everything is a tail call
09:14:23 <ski> wli : the `IOError' in `(IOError -> IO ()) -> IO ()' is the monadic return type of `ContT () IO IOError', yes
09:14:27 <thoughtpolice> mmorrow: so, it's kind of elaborate. it's also somewhat dependent on the optimizer being able to remove inline calls to make gc safepoints less frequent, and on top of that, the register-encoding trick has to happen after register allocation, because only then is it known what physical registers will hold root pointers
09:14:35 <Eridius> glguy: I suspect it does expand to something with a lot of constants. The associated .TXT file that the template haskell undoubtedly is doing stuff with has almost 7000 lines that define characters in an encoding
09:14:59 <mmorrow> thoughtpolice: if the calling convention is fixed, then it's easy to know what registers have pointers
09:15:02 <ski> afternoon, Cheshire
09:15:08 <Cheshire> hi ski
09:15:17 <mmorrow> thoughtpolice: (via the "type" of the function)
09:15:46 <mmorrow> (where "type" here only has to be (NotPtr -> (Ptr -> NotPtr) -> Ptr -> NotPtr) or whatever)
09:15:53 <wli> ski: It still looks like catch. I'm not sure what you're saying otherwise.
09:16:01 <thoughtpolice> mmorrow: right. you can be dependent on the specific backend establishing what subset of the registers hold roots
09:16:26 <thoughtpolice> mmorrow: in sml/nj's case, it's a little complicated, but the implementation is fairly simple.
09:16:32 <conal> dons: ping
09:16:38 <mmorrow> thoughtpolice: well, couldn't you just define the calling convention in terms of abstract registers, then just use that mapping?
09:16:43 <thoughtpolice> i mean it's still a whole lotta C code, but when you get C code, it's normally a whole lot
09:16:54 <mmorrow> heh, yeah
09:16:57 <Eridius> oh good, it finished compiling that file, but now it's doing the same thing on another one
09:17:25 <ski> wli : the only thing that `runContT :: ContT () IO IOError -> (IOError -> IO ()) -> IO ()' does is passing the `IOError -> IO ()' as argument into the `ContT () IO IOError', i.e. into the `(IOError -> IO ()) -> IO ()' .. the resulting `IO ()' is what's returned
09:17:36 <conal> @tell dons the "some papers" link on http://donsbot.wordpress.com/about/ points to the "about" page.
09:17:36 <lambdabot> Consider it noted.
09:18:00 <thoughtpolice> mmorrow: the sml/nj system compiles CPS to a von-neumann like machine which has abstract psuedo-registers that are distinct in their purpose
09:18:01 <ski> wli : in `catch :: forall a. IO a -> (IOError -> IO a) -> IO a', however, it does magic with the `IO'-actions to set an exception handler `IOError -> IO a' for the argument `IO a'
09:18:14 <conal> @ask dons how did you get the video for your icfp97 talk?  i'd like to get mine also.
09:18:15 <lambdabot> Consider it noted.
09:18:21 <thoughtpolice> mmorrow: every backend has appox ~6 dedicated registers
09:18:30 <thoughtpolice> on x86 it actually has to spill stuff to the stack
09:18:45 <ski> wli : however, one can think of `catch' in terms of one explicit and one implicit continuation
09:19:03 <ski> (wli : the explicit one being the exception handler given)
09:19:46 * ski wonder how to implement "proper head-recursion"
09:19:48 <thoughtpolice> mmorrow: but ultimately, when the overflow trap occurs, it seems as though the 'callgc' procedure mainly just uses the bitmask stored in the code-stream to determine what registers to use; every architecture has a pre-determined # of roots as well.
09:19:55 <mmorrow> thoughtpolice: have you seen this http://www.smlnj.org/compiler-notes/gc-api.ps ?
09:20:20 <mmorrow> yeah, i saw that arch-specific root stuff
09:20:34 <mmorrow> i didn't like that very much..
09:20:44 <thoughtpolice> mmorrow: there's a cleaner way to encode it I'm sure
09:20:51 <mmorrow> yeah, definitely i think
09:20:57 <thoughtpolice> I didn't think the 'storing a mask in the instruction stream' was too elegant
09:21:11 <thoughtpolice> although apparently it keeps the GC from reclaiming unused crap it might still think that register is holding onto
09:21:20 <thoughtpolice> but in practice I *really* doubt that's an issue
09:21:38 <thoughtpolice> then again, all the material i'm citing/looking at is approx. 15 years old, so... :)
09:21:41 <mmorrow> thoughtpolice: i don't see why a little code stub can't be generated for each point where the gc could be called, which sets up/whatever to roots at that point, then calls/jumps-to the gc
09:22:08 <thoughtpolice> mmorrow: right, basically an ASM stub which sets up the safe point
09:22:24 <mmorrow> exactly
09:22:29 <thoughtpolice> mmorrow: although most people would say splicing in ASM code like that isn't attractive, it is the most obvious, easy solution that comes to mind
09:22:45 <mmorrow> thoughtpolice: but if you're generating the asm/bytecode yourself...
09:22:58 <thoughtpolice> things get complicated. :)
09:23:12 <mmorrow> heh, so true with all this stuff :)
09:23:16 <thoughtpolice> I think i'd probably rather have a set of some .S files sitting around if it can make my life that much easier
09:23:40 <boegel> @seen Xif
09:23:40 <lambdabot> Last time I saw Xif was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
09:23:40 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 6m 21d 17h 39m 31s ago, and .
09:24:27 <thoughtpolice> mmorrow: of course, we don't want safe-point overhead too significant. that is one thing I like about the approach appel describes
09:24:32 <mmorrow> thoughtpolice: yeah, you could just pre-generate a bunch of code stubs for all the common cases of configurations, smiliar to how ghc pre-generates a bunch of stg_app functions
09:24:51 <thoughtpolice> catching an overflow trap as an indicator to start the GC, while at the same time keeping it in about 1 instruction is pretty damn ingeneous
09:25:01 <thoughtpolice> and it makes inserting safepoints at every function there is plausible
09:26:12 <Eridius> huh, `cabal install HDBC-sqlite3` just installed HDBC-2.1.0 for me even though I already had that installed
09:26:37 <mmorrow> thoughtpolice: yeah, that's pretty cool
09:29:34 <thoughtpolice> mmorrow: so I guess it's back to reading and writing hand bits of asm for now. :) hopefully i should get somewhere with this root issue soon...
09:32:32 <mmorrow> thoughtpolice: good luck :) hopefully i do teh same ;)
09:34:17 <augustss> What's a good name for a function that propagates references through a container?  Like  foo :: IORef (c a) -> c (IORef a)
09:34:45 <Cheshire> it reminds me of the roll from Mu
09:34:46 <opqdonut> refify?
09:35:06 <augustss> hmmm, maybe
09:37:07 <goomba`> can anyone tell me what is wrong with this code, i posted the error msg at the bottom... http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1825#a1826
09:37:09 <quicksilver> augustss: evil?
09:37:44 <byorgey> @type Data.Traversable.sequence
09:37:45 <opqdonut> goomba`: that's the "dreaded mononorphism restriction" at work
09:37:46 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
09:37:47 <augustss> quicksilver: There's nothing evil about it.  Any more than references, I mean.
09:37:56 <opqdonut> goomba`: give main a type signature and it'll go away
09:37:59 <Cheshire> augustss, hm.. if you take the fixed point of that -- you can freeze out all IO references (?)
09:37:59 <byorgey> augustss: ^^^ ?
09:38:01 <ski>   IORef (c a) -> IO (c (IORef a))  -- ?
09:38:09 <goomba`> thank you opqdonut
09:38:25 <opqdonut> goomba`: hmm, there might also be a real bug, wait a sec
09:38:39 <Cheshire> (except  c  would need to be a recursive type)
09:38:41 <augustss> Cheshire: It only works for containers, not values.  But I guess it could.
09:38:50 <opqdonut> goomba`: (show product) should probably be (show prod)
09:38:58 <blueonyx> goomba`, futhermore your prod will always be 0 :>
09:39:00 <opqdonut> goomba`: product is a function defined in prelude, that's why the error is so wacky
09:39:07 <quicksilver> augustss: well, if references are evil, then two references are more evil than one.
09:39:07 <opqdonut> yeah, foldr (*) 1
09:39:14 <ski> IORef (Mu c) -> Mu c
09:39:16 <quicksilver> augustss: and your function increases the amount of evil therefore ;)
09:39:16 <augustss> ski: Oh sure, Throw in an extra IO at the top, if you want.  I'm just interested in the name right now.
09:39:31 <ddarius> quicksilver: IORef (a, b)
09:39:50 <ski> (augustss : i was thinking you were maybe doing some GADT magic ..)
09:40:06 <augustss> ski: No, I'm doing Excel.
09:40:06 <byorgey> maybe "compartmentalize"?
09:40:15 <quicksilver> perreferate
09:40:39 <goomba`> opqdonut, thats what i get for cut and pasting
09:40:42 <byorgey> quicksilver++
09:40:47 <augustss> perreferate has a certain ring to it
09:40:50 <goomba`> (the foldr statement)
09:40:59 <ski> augustss : anyway, something related to `freeze' might work
09:43:14 <quicksilver> "seperate"? It's separating one big ref into lots of little independent refs.
09:43:31 <goomba`> so changing it to the correct name prod fixed the error entirely, whew
09:43:38 <opqdonut> yeh
09:43:48 <quicksilver> name is probably too generic for real code, but might work in a paper
09:43:52 <quicksilver> especially correctly spelt.
09:43:55 <quicksilver> *separate
09:45:31 <dons> conal: thanks
09:45:31 <lambdabot> dons: You have 9 new messages. '/msg lambdabot @messages' to read them.
09:45:39 <byorgey> the real solution is to find something general from CT of which it is a specific instance, and name it that. =)
09:45:40 <opqdonut> heh
09:45:45 <conal> :)
09:46:49 <kiris> should Show/Read instances always be isomorphic (is that the word?). ie the ideal case is show . read = read . show?
09:46:58 <kiris> uh, no that's probably stupid
09:47:01 <Cheshire> read should be left inverse of show
09:47:09 <Cheshire> but show needn't be left inverse of read
09:47:13 <kiris> right, yes!
09:47:14 <byorgey> read . show = id
09:47:29 <kiris> > show $ read "1.000"
09:47:30 <lambdabot>   "* Exception: Prelude.read: no parse
09:47:32 <MyCatVerbs> kiris: if possible, yes. If not, oh well.
09:47:38 <conal> show . read [= id
09:47:39 <kiris> > show $ (read "1.000" :: Double)
09:47:40 * Cheshire something that sounds like "split epimorphism" is probably a term for this
09:47:40 <lambdabot>   "1.0"
09:47:51 <conal> embedding/projection pair ?
09:47:57 <ski>   class (Category cat,Functor t) => CTraversable cat t where sequenceCat :: Applicative i => cat (t (i a)) (i (t a))  -- ?
09:47:58 * kiris googles that
09:48:07 <MyCatVerbs> Cheshire: shouldn't that be "endo" rather than "epi"?
09:48:18 <quicksilver> ski: well, there is a name for you. Call it cattiaita
09:48:28 <dolio> It's either epi or mono.
09:48:32 <quicksilver> ski: sounds like a kind of pasta, as a bonus.
09:48:37 <conal> how i think it's a monomorphism
09:48:37 <dolio> Endo is A -> A.
09:48:44 <conal> s/how //
09:48:49 <ski> `read' is an epi, `show' is a mono, `show . read' is an endo
09:48:55 <byorgey> quicksilver: you are just on fire today. =)
09:49:08 <ski> (or maybe a flipped `epi',`mono' again ?)
09:49:21 <ddarius> Ceshire: Split epi/mono is one term, retract/section is another term.
09:49:29 <ski> (no, i did not)
09:49:53 <Cheshire> thanks
09:50:08 <Cheshire> I've read these terms but I still forget them
09:50:20 <Cheshire> retract means that there exists f^-1 so that  f^-1 . f = id
09:50:48 <ski> in `r . s = id', `r' is the retraction, `s' is the section, the whole is a retract situation, and `s . r' is an endomorphism
09:50:55 <ddarius> Cheshire: Yes, except f^-1 is a bit strong notation-wise.
09:51:06 <ski> ("the whole" being `r . s = id')
09:51:12 <Cheshire> ddarius, I rather write, fº but people complain
09:51:16 <quicksilver> ski: a fortiori , s.r is an idempotent endomorphism
09:51:21 <joelr1> good day
09:51:37 <ski> quicksilver : yes, i was to mention that, but forgot it
09:51:38 <ddarius> Cheshire: I was referring to the fact that f^-1 usually means both a left and right inverse.
09:51:44 <Cheshire> ohh
09:51:45 <Cheshire> ok
09:52:06 <quicksilver> good afternoon, joelr1
09:52:25 <ddarius> ski: Are you sure you didn't switch r and s?
09:52:38 <kiris> does `r . s = id' tell us anything about 's . r'?
09:52:39 <Cheshire> so Read is a Retraction
09:52:44 <Cheshire> and Show is a Section :D
09:52:45 <ski> ddarius : i'm pretty sure it should be `r . s = id'
09:52:46 <ddarius> kiris: s . r is idempotent then
09:52:55 <byorgey> kiris: yes, s . r . s . r = s . id . r = s . r
09:52:57 <ddarius> ski: The section should be a monomorphism.
09:53:02 <ski> yes
09:53:28 <Cheshire> there is a mnemonic
09:53:38 <ddarius> ski: So f . s = g . s should imply f = g and we'd have that if we could precompose by r giving f . s . r = g . s . r = f . id = g . id
09:53:44 <Cheshire> mnemonomorphism
09:54:08 <kiris> byorgey: wow cool
09:54:15 <kiris> Cheshire: haha
09:54:25 <byorgey> so do the 'r' and 's' correspond in the correct way to both Read/Show and Retraction/Section?  Or are they flipped?  =)
09:54:48 <ski> ddarius : `forall f,g.  f . s = g . s  =>  f = g' means `s' is epi
09:54:51 <dolio> Awodey says es = 1_A, e is the retraction, s is the section.
09:55:07 <ddarius> ski: Ah yeah, you're right.
09:55:18 <Cheshire> byorgy, Read is a Retraction & Show is a Section
09:55:23 <byorgey> excellent =)
09:55:40 <byorgey> now I will always remember which is which!
09:55:47 <Cheshire> I hope I will too
09:56:04 <quicksilver> but will it help you remember which is epi and which is mono?
09:56:08 <byorgey> not that the terms 'retraction' and 'section' actually seem to come up all that often.
09:56:16 <quicksilver> and will it help you remember which end of the line to draw the doubled arrow?
09:56:18 <ski> i think the name "split epi" comes from "split idempotent"
09:56:23 <Cheshire> I just equate mono with injective (which is true in SET)
09:56:40 <byorgey> quicksilver: yes, and I've never seen doubled arrows (?)
09:56:59 * ddarius always forgets whether it's r . s = id or s . r = id and has to figure it out every time.
09:57:00 <ski> `i' is a split idempotent iff there is a retract situation `r' and `s' (i.e. `r . s = id') such that `s . r = i'
09:57:01 <quicksilver> in a commutative diagram you signify one with an arrow-head at the 'start' of the arrow
09:57:03 <dolio> Also, if e : X -> A, then A is a retract of X.
09:57:10 <ski> and then `r' is the "split epi", there
09:57:12 <quicksilver> and the other with an extra arrow head (total: two) at the end.
09:57:23 <quicksilver> >--->  and ---->>
09:57:32 <quicksilver> IIRC.
09:57:47 <dolio> >-> is mono, ->> is epi.
09:57:52 <byorgey> I see.  nope, I probably won't remember that. =)
09:57:54 <ski> ddarius : i've managed to burn `r . s = id' into my memory, so i sure hope that's the correct way :)
09:58:13 <kiris> maybe you could remember `r . s = id' with 'r' as in 'I retract my statement (s)' > _>
09:58:45 <ski> you can also consider maps between sets .. `r' should map back from the larger set into the smaller one
09:58:45 <ddarius> ski: I guess I should just remember that it is in alphabetical order.
09:58:53 <ski> (so that we get `r . s = id')
09:59:22 <dolio> Except when you say s;r = id.
09:59:24 <ddarius> ski: That would be equivalent to me "figuring it out" again.
09:59:27 <dolio> Then it's reverse alphabetical.
09:59:30 <ddarius> dolio: Curse you.
09:59:35 <ski> ddarius : yes :)
09:59:40 <Cheshire> hehe
10:00:18 <ski> quicksilver : that's because "epi" is a "property of the codomain end" of a morphism (and the other way around for "mono")
10:01:30 <dolio> So I was thinking about coends...
10:01:39 <dolio> And the wikipedia article on them really sucks.
10:01:52 <Deewiant> So you wrote a better one!
10:01:56 <wli> injective and surjective?
10:01:57 <dolio> No.
10:02:00 <kiris> epi is greek for "upon", if that helps
10:02:02 <ski> glad to hear you volonteer to write it better
10:02:10 <Cheshire> and sur is french for on
10:02:25 <BMeph> So, ends are a monic win, right? ;)
10:02:43 <ski> wli : (very roughly) `injective' generalizes to `mono', and `surjective' to `epi'
10:02:57 <BMeph> kiris: I prefer "over", but "same difference," as they say. :)
10:02:58 <byorgey> and "in" is latin for "in"
10:03:03 <wli> They're different?
10:03:21 <kiris> BMeph: yeah that's better
10:03:28 <ski> wli : which ?
10:03:48 <wli> injective vs. mono, surjective vs. epi.
10:03:50 <byorgey> wli: they're the same for the category of sets.
10:03:55 <Cheshire> same difference always made me think |a-b|=|b-a| .. but this does not describe the saying at all
10:04:18 <byorgey> wli: but the definitions of 'injective' and 'surjective' don't even make sense for more general categories.
10:04:25 <quicksilver> ski: why (very roughly) ?
10:04:34 <kiris> I thought it was |a-c|=|b-c| 6_6
10:04:39 <quicksilver> ski: surely it is precisely the case that injective generalises to mono ?
10:04:58 <wli> I've not seen examples of it breaking down.
10:05:07 <Cheshire> I only know SET and FIN
10:05:17 <byorgey> wli: well, suppose you have a category where the arrows are not functions.
10:05:30 <Cheshire> so I dunno any category which the latin vs french  make any difference
10:05:39 <wli> Maybe just a graph.
10:05:53 <BMeph> kiris: E.g., episkopos (Greek) == supervisor (Latin) == overseer (English). Funny, I never saw that comparison in Sunday School... ;)
10:06:18 <kiris> BMeph: cool
10:06:22 <dolio> So, if a coend is a dinatural transformation to an object, then that essentially means that the morphisms in the family have nothing to do with the objects the functor is parameterized by, so it's essentially embedding the structure/shape represented by the functor into an object in the target category?
10:06:51 <dolio> And then, since it's couniversal, that embedding preserves as much structure as possible, since all other such maps factor through it?
10:06:56 <dolio> Or am I completely off base?
10:07:42 <dolio> That seems to match somewhat with the Haskell-ish encoding as (exists a. S a a).
10:07:58 <ski> in the category of monoids, there's monomorphisms whose underlying function in the category of sets is not injective
10:07:58 <ski> (or maybe it was for epimorphism and surjective .. i forget)
10:10:08 <ski> byorgey : to compare, you need a category where `injective' and `surjective' makes sense .. i was thinking of concrete categories over `Set'
10:10:24 <kiris> ski: in r . s = id, say s :: X -> Y, is Y a subset of X and r brings it back into the superset X again?
10:10:50 <ski> the other way around
10:11:05 <kiris> oh, um
10:11:22 <quicksilver> the retract  "retracts" from the larger set to the smaller.
10:11:34 <ski> consider `Y' being people in a country, divides into areas
10:11:47 <ski> each area selects one person to represent them
10:11:51 <quicksilver> the section "embed" the smaller set as a  "section" of the larger
10:12:02 <ski> `s' injects from the set of representatives into the set of people
10:12:20 <ski> `r' maps each person to their representative
10:12:36 <ski> `r . s = id' says that the representative of a representative is themselves
10:12:53 <kiris> oh I get it
10:13:20 <ski> (one can alternatively think of `X' as the set of equivalence classes .. each equivalence class corresponds to the canconical representative of it)
10:13:55 <ski> (axiom of choice says that each retraction `r' has a section `s' that chooses a canonical representative in each equivalence class)
10:14:20 <ski> (s/retraction/epi/, i suppose)
10:15:19 <kiris> hmm
10:15:57 <kiris> could you have Y being the set of programmers, and X being the set of haskell programmers?
10:16:23 <ski> if each programmer defers to one haskell programmer, yes
10:16:33 <kiris> ohh, hum
10:16:40 <ski> (and each haskell programmer defers to herself/himself, of course)
10:16:58 <dolio> Retractions aren't how you define subobjects in general.
10:17:09 <kiris> I'm trying to think of another example
10:17:22 <ddarius> dolio: Retractions aren't how you define sub-objects at all.
10:17:49 <spkc> hi everyone :)
10:17:55 <gnut> hello
10:17:59 <dolio> Right, but he was told earlier that a retract could be thought of as a subset.
10:18:00 <scriptdevil> spkc, hey! :)
10:18:13 <ddarius> dolio: A retract -maps to- a subset.
10:18:27 <spkc> scriptdevil: i was looking for a RAD ide for haskell. is there such an animal?
10:18:31 <ski> the section is the subobject
10:18:40 <Cheshire> kiris, X = haskell programmers (assume we all have different names), Y = peoples names :: String
10:18:53 <scriptdevil> spkc, Well.. There was a hIDE.. I doubt if it is there now
10:19:06 <Cheshire> kiris, that way Y is bigger than X so you can go from X <-- Y <-- X without losing anything
10:19:11 <scriptdevil> spkc, Gvim/Emacs is more that what most need
10:19:16 <Cheshire> i.e. r :: X <-- Y and s :: Y <-- X exist
10:19:24 <spkc> scriptdevil: is _leksah_ any good?
10:19:28 <kiris> Cheshire: oh that's easier to understand
10:20:15 <scriptdevil> spkc, try it.
10:20:15 <ski> Cheshire : how do you map every name to a haskell programmer ? :)
10:20:40 <ski> (probably s/every/each/)
10:20:40 <ddarius> ski: This is Set.  Just do it arbitrarily.
10:20:44 <Cheshire> s(ski) = "ski"
10:20:49 <spkc> scriptdevil: :), thanks.
10:21:08 <Cheshire> r("NickServ") = Cheshire
10:21:09 <spkc> scriptdevil: visual haskell seems close to a RAD but is for windows :(
10:21:42 <ski> @hoogle RAD
10:21:42 <lambdabot> Text.XHtml.Frameset radio :: String -> String -> Html
10:21:42 <lambdabot> Text.XHtml.Strict radio :: String -> String -> Html
10:21:42 <lambdabot> Text.XHtml.Transitional radio :: String -> String -> Html
10:21:46 <scriptdevil> spkc, The Visual word makes me shrink away... So..
10:21:55 <Cheshire> @hoogle ACE
10:21:55 <lambdabot> Distribution.Simple.Command type ArgPlaceHolder = String
10:21:55 <lambdabot> Text.Parsec.Token braces :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
10:21:55 <lambdabot> Text.PrettyPrint.HughesPJ braces :: Doc -> Doc
10:22:06 <scriptdevil> ski, lol... was that ra?
10:22:07 <ski> Regrating Antirevolutionary Defibrinize ?
10:22:08 <kiris> so it only matters that haskell programmers can go to the set of people with names and back again?
10:22:15 <kiris> (not anyone else)
10:22:28 <spkc> scriptdevil: i see where you come from ;). thanks
10:22:31 <ski> (scriptdevil : sorry ?)
10:22:45 <Cheshire> @w80 Defibrinize
10:22:47 <lambdabot> No match for "Defibrinize".
10:22:50 <Cheshire> awwww
10:22:55 <Cheshire> what can it mean?
10:22:57 <scriptdevil> ski: I mean RAD... You got a bunch of radios ;)
10:23:01 <Cheshire> fib^-1 /
10:23:02 <Cheshire> ?
10:23:11 <ski> presumably spkc knows what it means
10:23:23 <Cheshire> spkc, can you define Defibrinize
10:23:51 <spkc> Cheshire: i am just a beginner, even if what oyu are asking is a joke i wouldnt get it :)
10:24:21 <kiris> is Map in `Map k a' a retraction?
10:24:26 <ddarius> One doesn't acquire humor until after a year of Haskell.
10:24:36 <ski> kiris : between which kinds ?
10:24:43 <Cheshire> spkc, was a joke :p
10:25:11 <scriptdevil> ddarius, It doesnt take too long to sort out if it was a joke ;)
10:25:12 <kiris> ski: maybe not, n/m
10:25:26 <Cheshire> @let (&) = liftA2 (,)
10:25:27 <lambdabot>  <local>:36:0:
10:25:27 <lambdabot>      Multiple declarations of `L.&'
10:25:27 <lambdabot>      Declared at: <local>:...
10:25:42 <kiris> ski: but Data.Map.(!) retracts, right?
10:25:54 <ski> @type (Data.Map.!)
10:25:55 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
10:26:17 <kiris> bah, no
10:26:44 <kiris> (!) is a section?
10:27:24 <ski> do you mean between `k -> a' and `Map k a' ?
10:27:26 <kiris> or does this not work atall?
10:27:29 <spkc> (Cheshire: well, at least i saw thru it)
10:27:30 <ddarius> Something being a section/retraction is reasonably special.
10:27:56 <spkc> thanks guys. have a good one
10:28:22 <kiris> ski: I don't know
10:28:29 * ski neither
10:28:31 <kiris> :p
10:30:02 <ski> i wonder how much trouble it is to implement left-recursion
10:30:03 <kiris> it seems like `read' takes a value from the bigger set of any String, to the smaller set of values which are instances of Read
10:30:37 <ski> values aren't instances of `Read'
10:30:44 <ski> types can be instances of `Read'
10:30:58 <kiris> ok
10:31:21 <ski> i think in `read . show = id' it is meant to consider one instance of `Read',`Show' at a time
10:31:31 <ski> so you get a family of retract situations
10:32:31 <ski> so, e.g. in one case, `read' takes values in `String' into values in `Integer'
10:32:39 <kiris> right
10:32:40 <dolio> Like for (), the string "()" gets sent to the () equivalence class, and everything else gets put in the bottom class.
10:33:13 <dolio> > read "(  )"
10:33:14 <lambdabot>   ()
10:33:22 <dolio> Or, not everything else, I guess.
10:33:30 <ski> > read "(())"
10:33:31 <lambdabot>   ()
10:33:38 <byorgey> > read "(  {- foo bar -} )"
10:33:40 <lambdabot>   * Exception: Prelude.read: no parse
10:33:44 <ski> ha !
10:33:44 <byorgey> just checking =)
10:33:55 <dolio> > read "{- foo bar -} ()"
10:33:57 <lambdabot>   * Exception: Prelude.read: no parse
10:33:59 <kiris> why is (()) a valid parse?
10:34:11 <ski> > read "((1234))" :: Integer
10:34:13 <lambdabot>   1234
10:34:14 <byorgey> kiris: it's just the value () in parentheses.
10:34:17 <kiris> oh, duh
10:34:32 <kiris> (didn't know 'read' supported parens)
10:34:38 <byorgey> I didn't either, actually =)
10:34:40 <ski> @type readParen
10:34:41 <lambdabot> forall a. Bool -> ReadS a -> String -> [(a, String)]
10:40:32 <kiris> how does lambdabot know that you're after a ()?
10:40:32 <dolio> > read "() {- foo -}"
10:40:32 <lambdabot>   * Exception: Prelude.read: no parse
10:40:32 <kiris> in my ghci it says ambiguous type variable
10:40:32 <ski> kiris : it defaults to `()'
10:40:32 <kiris> ok
10:40:32 <byorgey> kiris: sneaky type defaulting
10:40:32 <byorgey> > read "3"
10:40:32 <ski> @check \x -> x == x
10:40:32 <lambdabot>   * Exception: Prelude.read: no parse
10:40:32 <lambdabot>   "OK, passed 500 tests."
10:40:32 <ski> @check \x -> x /= x
10:40:32 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
10:40:32 <dolio> > lex "{- foo -}"
10:40:32 <lambdabot>   [("{","- foo -}")]
10:40:32 <kiris> can type defaulting be done in standard haskell or is that an implementation thing?
10:40:32 <ski> @check \x -> xs == reverse x
10:40:32 <lambdabot>   Not in scope: `xs'
10:40:32 <ski> @check \xs -> xs == reverse xs
10:40:32 <lambdabot>   "OK, passed 500 tests."
10:40:32 <ski> that's `()' defaulting for you
10:40:32 <dolio> Huh, lex doesn't do comments?
10:40:32 <ski> @check \xs -> xs == reverse (xs :: [Bool])
10:40:32 <lambdabot>   "Falsifiable, after 2 tests:\n[False,True,True]\n"
10:40:32 <maltem> kiris: Defaulting to Integer or Double is Haskell 98, everything else isn't
10:40:32 <byorgey> kiris: type defaulting is standard.  however, GHC has some extended type defaulting rules (such as the one for () ) that are turned on in lambdabot.
10:40:32 <kiris> ok
10:40:32 <ski> @type lex
10:40:32 <lambdabot> String -> [(String, String)]
10:40:32 <maltem> kiris: or actually it's not "default to Integer" but "defaulting Integral"
10:40:32 <kiris> I thought it was defaulting Num?
10:40:32 <kiris> :t 0
10:40:32 <lambdabot> forall t. (Num t) => t
10:40:32 <dolio> > lex "M.where"
10:40:32 <lambdabot>   [("M",".where")]
10:40:32 <ski> @type Text.ParserCombinators.ReadP.readS_to_P lex
10:40:32 <lambdabot> Text.ParserCombinators.ReadP.ReadP String
10:40:32 <gnut> is there an effort to port ghc to ARM?
10:40:32 <kiris> maltem: when does it default to integral?
10:40:33 <maltem> kiris: "Integral a => a" gets defaulted to "Integer" unless a  default  statement says otherwise
10:40:37 <LeoD> @src fix
10:40:38 <lambdabot> fix f = let x = f x in x
10:41:00 <maltem> kiris: But it's not a thing that is terribly useful to know
10:41:09 * ski thinks `fix' would look nicer, using `where'
10:41:42 <ski>   fix f = x
10:41:46 <ski>     where
10:41:46 <ski>     x = f x
10:42:35 <maltem> ski: I agree that it's easier to comprehend with "where"
10:45:23 <kiris> I was thinking about a memcached implementation and whether Read/Show would be a valid way to serialize (ignoring speed issues)
10:45:23 <gnuvince> :t fix
10:45:25 <lambdabot> forall a. (a -> a) -> a
10:45:29 <dons> kiris: use Data.Binary
10:45:39 <dons> that's what it's designed for :)
10:45:42 <gnuvince> > fix (+3)
10:45:57 <lambdabot>   thread killed
10:46:06 <ski> > fix (0*)
10:46:07 <lambdabot>   * Exception: stack overflow
10:46:13 <kiris> ok
10:46:48 <Alpounet> @type fix
10:46:49 <lambdabot> forall a. (a -> a) -> a
10:47:13 <dolio> > let 0 * _ = 0 ; m * n = m Prelude.* n in fix (0*)
10:47:15 <lambdabot>   0
10:47:39 <wchogg> kiris : I'd second dons notion about Data.Binary.  Also, are you familiar with happstack-state?
10:48:41 <dons> or using TCache, or the memcached bindings or holumbus-state
10:50:55 <kiris> wchogg: nope
10:53:57 <wchogg> kiris : happstack-state is kind of a logical step beyond memcached, where there's nothing but the in memory data objects and the serialized event log.  I'm biased, but I think its a really interesting system.  You can read about it on tutorial.happstack.com.  Also, it'd be worth looking at any of the other libraries that dons mentioned.  There's lots of good stuff right now.
10:54:00 <kiris> the memcached bindings seemed broken to me, didn't seem to do the protocol properly, but I dunno. so I was reading the memcached protocol spec
10:54:31 <kiris> wchogg: I'll have a look :-)
10:56:49 <conal> dons: how did you get access to your icfp 07 talk video?  i remember recording being done but never heard they were available.
10:57:26 <dons> ah, malcolm recorded them all
10:57:31 <dons> the HW ones.
10:57:55 <dons> http://www.ludd.ltu.se/~pj/hw2007/HaskellWorkshop.html
10:58:04 <kiris> wchogg: isn't the point of memcache being distributed?
10:58:07 <ski> @hoogle Dual
10:58:07 <lambdabot> Data.Monoid newtype Dual a
10:58:07 <lambdabot> Data.Monoid Dual :: a -> Dual a
10:58:07 <lambdabot> Data.Monoid getDual :: Dual a -> a
10:58:12 <conal> dons: oh, so not the conference recordings by the local folks.  i wonder what happened to them.
10:58:19 <dons> some things from ICFP, http://www.ludd.ltu.se/~pj/icfp2007/ICFP2007.html
10:58:22 <ski> (hm .. not the `Dual' i was thinking of ..)
10:58:25 <dons> conal: oh they disappear into ACM somewhere
10:58:28 <dons> never to be seen againnn
10:58:37 <conal> dons: oh well :(
11:00:38 <wchogg> kiris : you can combine happstack-state with Spread to distribute load
11:00:51 <kiris> wchogg: oh cool :D
11:01:05 <boozkachu> happstack seems pretty cool
11:01:52 <kiris> well I was looking forward to implementing memcached from the protocol spec just because I like reading specs and using them to make implementations, but I guess I'll read hapstack's tutorial instead
11:11:39 <kiris> happstack does look pretty cool
11:13:23 * maltem is usually scared away when the list of extensions doesn't fit on one line anymore
11:19:07 <augustss> dons: I love your GA stuff.  It's somehow really wrong that the compiler doesn't do the right thing, but it's very cool that you can use GA in this way. :)
11:20:48 <dons> hehe. i think its all just too big a search space for general heuristics baked into ghc to always be right.
11:21:06 <dons> it may be though we can find better thresholds for ghc this way too
11:29:37 <dcoutts_> dons: Andy and I have talked about doing feedback directed optimisation. Your flag tuning is in a sense a simple form of feedback directed optimisation.
11:29:53 <dons> yep
11:30:07 <dons> its a sort of black box version of satnam's profiling stuff too.
11:30:58 <dcoutts_> and adding strictness, well that's just evil :-)
11:31:20 <dons> heh
11:32:14 <dcoutts_> dons: though perhaps that too can be done in a more principled way
11:32:27 <dcoutts_> ie check at runtime if a function is strict
11:32:38 <dcoutts_> and use that to feedback to the compiler
11:32:40 <dons> yeah
11:32:44 <dcoutts_> just evaluate at undefined
11:32:56 <dons> so a safety pass
11:33:06 <dons> then use that to weed out non-strict things.
11:33:13 <dcoutts_> it's not complete because of non-termination
11:33:29 <dcoutts_> but you can just use a timeout, and anything over the timeout is not strict
11:33:46 <dcoutts_> or rather unknown so cannot be marked strict
11:33:48 <dons> yep
11:34:03 <dons> i bet there's all sorts of magic values in ghc we could improve
11:34:13 <dons> if only there was a structured, programmatic way to get at them
11:34:26 <dcoutts_> maybe, but I suspect these things vary too much from program to program
11:34:43 <dons> yes, that's possible too.
11:34:52 <dons> but say, case unfolding magic value == 300
11:35:04 <dons> who knows if that makes sense
11:35:08 <dcoutts_> so we may have reached a local optimum for nofib, but improvements are still possible for individual progs
11:35:13 <dcoutts_> or bit of progs
11:35:22 <dons> well, i'm not sure we're even optimal for nofib.
11:35:23 <dcoutts_> hence wanting fine grained feedback
11:35:32 <dons> maybe at one point in the past, a particular combination was optimal
11:35:38 <dcoutts_> right
11:35:38 <dons> then we added other things, and didn't remeasure
11:35:48 <dcoutts_> quite possible and indeed probable
11:35:48 <Botje> they're optimal because SPJ says they are!
11:35:50 <dons> so we're stuck with e.g. heap defaults from 2001
11:35:52 <dons> etc.
11:36:07 <dcoutts_> dons: but that's also because the nofib programs do not change much
11:36:09 <dons> it'd be cool to retune on every release :)
11:36:17 <conal> indeed
11:36:19 <dcoutts_> they become less representative
11:36:45 <dcoutts_> dons: so you might be using 4GB heaps in your day to day hacking, but nofib isn't
11:37:11 <dons> yep
11:37:24 <dons> lots of interesting trade offs
11:37:28 <PeakerWork> its even worse than specificity being beneficial for different programs, different options can be beneficial for those same programs on different inputs
11:37:39 <PeakerWork> so you might want to move some of the heuristics to runtime, ideally?
11:37:48 <dcoutts_> PeakerWork: or different parts of the program, but independent of input
11:38:12 <dcoutts_> eg unfold more heavily in "hot" bits and optimise for size in your command line parsing code
11:40:59 <dons> dcoutts_: its a good case for getting access to internal heuristics
11:41:21 <dons> so we can find domain-specific block layouts, heap sizes and other thresholds
11:42:03 <dcoutts_> dons: ah you mean instead of -fblah-blah=300 globally on the command line, you mean adding pragmas that apply to just one function/expression?
11:42:24 <dons> no, just in general having a rule to expose any internal magic numbers to the programmer
11:42:30 <dons> either via flags or pragams
11:42:54 <benmachine> good afternoon
11:43:02 <dcoutts_> dons: right, most are already flags. Any interesting ones that are constants should be exposed as flags.
11:43:03 <benmachine> er, good evening, my clock is wrong
11:44:31 * glguy recommends a room with windows
11:44:43 * conal just discovered that "IO" is an easy typo for "()".
11:46:24 <benmachine> so, how can I slow down my program and make it a little more cpu-friendly (optionally using SDL)
11:46:56 <dons> benmachine: threadDelay?
11:47:11 * benmachine looks this up
11:47:18 <BMeph> benmachine: Since I'm in California, good morning! ;)
11:47:22 <eu-prleu-peupeu1> hi
11:48:09 <BMeph> eu-prleu-peupeu1: hi
11:48:54 <adrian_> @src foldb
11:48:54 <lambdabot> Source not found. :(
11:50:42 <augustss> conal: since you never use IO anyway... ;)  type IO = ()
11:51:31 <adrian_> > foldb (*) 1 [1..1000]
11:51:34 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
11:51:35 <conal> augustss: good idea.  that's my goal anyway.
11:52:34 <adrian_> > foldb (++) 1 (map (:[]) [1..10])
11:52:36 <lambdabot>       No instance for (Num [a])
11:52:36 <lambdabot>        arising from the literal `1' at <inter...
11:52:44 <adrian_> > foldb (++) [] (map (:[]) [1..10])
11:52:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:53:15 <adrian_> > foldb (\a b -> (a,b)) () (map (:()) [1..10])
11:53:16 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
11:53:16 <lambdabot>        Exp...
11:53:18 <augustss> > foldb f x [a,b,c,d,e,f,g,h]
11:53:19 <lambdabot>   f x (f (f (f a b) (f c d)) (f (f e f) (f g h)))
11:53:44 <Cheshire> :t foldb ?f x [a,b,c,d,e,?f,g,h]
11:53:44 <adrian_> does anyone of some sources on foldb
11:53:45 <augustss> > foldb f x [a,b,c,d,e,i,j,k,l]
11:53:45 <lambdabot> Top level:
11:53:45 <lambdabot>     Couldn't match expected type `Expr -> Expr -> Expr'
11:53:45 <lambdabot>            against inferred type `Expr'
11:53:47 <lambdabot>   f x (f (f (f (f a b) (f c d)) (f (f e i) (f j k))) l)
11:53:49 <Cheshire> what
11:53:53 <Cheshire> how did it type
11:53:57 <Cheshire> :t f
11:53:58 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:54:03 <Cheshire> ohh different f's
11:54:28 <adrian_> what's its ordinary name? binary partition fold?
11:54:58 <augustss> tree fold?
11:55:33 <Cheshire> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))
11:55:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:55:56 <Cheshire> > foldb f x [a,b,c,d,i,j,k,l]
11:55:57 <lambdabot>   f x (f (f (f a b) (f c d)) (f (f i j) (f k l)))
11:55:58 <augustss> > f i x
11:56:00 <lambdabot>   Add a type signature
11:56:48 <augustss> > foldb f x [a,b,c]
11:56:50 <lambdabot>   f x (f (f a b) c)
11:56:58 <augustss> That's not good
11:57:06 <Cheshire> fold-bizarre
11:57:41 <ski> is `foldb f x' meant to be a monoid morphism ?
11:57:45 <tromp_> > :t foldb
11:57:46 <lambdabot>   <no location info>: parse error on input `:'
11:57:52 <benmachine> :t foldb
11:57:54 <lambdabot> forall a. (a -> a -> a) -> a -> [a] -> a
11:58:07 <LeoD> @src foldb
11:58:08 <lambdabot> Source not found.
11:58:14 <ski> (i.e. assuming `f',`x' forms a monoid)
11:59:01 <benmachine> > foldb f x [a,b,c,d]
11:59:02 <lambdabot>   f x (f (f a b) (f c d))
11:59:19 <benmachine> binary fold?
11:59:23 <Cheshire> what is the definition of foldb?
12:00:06 <ski> > foldb f x []
12:00:08 <lambdabot>   x
12:00:32 <adrian_> Cheshire: think mergesort
12:00:42 <adrian_> Cheshire: mergesort = folb merge
12:00:56 <Cheshire> I mean the exact source code
12:01:09 <benmachine> @src mergesort
12:01:09 <lambdabot> Source not found.
12:01:57 <ziman> foldb ~ fold binary?
12:05:36 <ski>   foldb f z [] =   z
12:05:41 <ski>   foldb f z as = f z (loop as)
12:05:45 <ski>     where
12:05:49 <ski>     loop [a] = a
12:05:54 <ski>     loop as  = loop (fold as)
12:05:59 <ski>     fold [        ] = [               ]
12:06:05 <ski>     fold [ a             ] = [a]
12:06:06 <ski>     fold (a0:a1:as) = f a0 a1 : fold as
12:06:20 <ski> something like that, i would assume
12:07:17 <Cheshire> that is difficult to read ski
12:08:27 <tromp_> basically, just pair up elements with f, and repeat
12:09:06 <ski> (Cheshire : yes, obviously i failed with indenting it properly, editing it on a single line ..)
12:18:04 <paczesiowa> why lazy bytestrings use structure isomorphic to list but not list itself? and why there are no fusions on that structure?
12:22:27 <mmuthanna>    /part
12:26:55 <dcoutts_> paczesiowa: it is stricter, it saves an indirection to the data.
12:27:47 <paczesiowa> dcoutts_: makes sense, how about fusions?
12:28:14 <dcoutts_> paczesiowa: we can do fusion on the whole thing, the chunk structure and representation is not so important
12:30:08 <dcoutts_> paczesiowa: what I mean is, there's little point in trying to inherit any fusion from the list structure by reusing list directly.
12:31:28 <dcoutts_> dons: about libpandoc, there's a Cabal ticket on better support for making foreign libs
12:31:41 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/148
12:31:47 <paczesiowa> dcoutts_: but there aren't any interesting fusions on bytestrings
12:31:48 <dcoutts_> dons: it's totally doable, given time
12:32:28 <dcoutts_> paczesiowa: the current 0.9 bytestring release does not use stream fusion, the stream fusion version of bytestring does do it on strict and lazy bytestrings to good effect.
12:32:53 <dcoutts_> paczesiowa: see our first paper on bytestrings
12:33:11 <paczesiowa> dcoutts_: where is that stream fusion version?
12:33:18 <trofi> @hoogle CReal
12:33:18 <lambdabot> No results found
12:35:03 <dcoutts_> paczesiowa: http://www.cse.unsw.edu.au/~dons/code/fps-unstable/
12:36:47 <trofi> @hoogle Data.Number.CReal
12:36:47 <lambdabot> No results found
12:39:38 <paczesiowa> dcoutts_: what happened to that code?
12:39:48 <dcoutts_> paczesiowa: it's still there
12:40:27 <paczesiowa> dcoutts_: I mean why is is "unstable" and noone has touched it for 2 years
12:40:35 <dcoutts_> paczesiowa: there's no fundamental reason it's not being used in the current releases except time
12:41:11 <dcoutts_> it's a significant effort to switch it over, a good month's work or so
12:41:39 <dcoutts_> since there's plenty we've learned in the mean time that we'd also want to incorporate
12:42:00 <paczesiowa> dcoutts_: wouldn't it be easier with stream fusion (seems like more advanced concept)?
12:42:25 <dcoutts_> paczesiowa: wouldn't what be easier? and easier compared to what?
12:44:05 <paczesiowa> dcoutts_: fusions based on Streams and step functions (like in stream-fusion package) seem easier to understand than those combinators FuseEFL,MapEFL etc.
12:44:31 <dcoutts_> paczesiowa: that fps-unstalbe code does use stream fusion, the first version of it
12:44:43 <dcoutts_> it's also got a few versions of functional array fusion
12:44:59 <dcoutts_> which is what the MapEFL stuff is about
12:45:11 <dcoutts_> paczesiowa: take a look in the stream fusion module, it's all there
12:45:35 <dcoutts_> paczesiowa: the various versions are compared in the paper
12:46:22 <dcoutts_> specifically the stream fusion vs the best functional array fusion vs no fusion
12:47:53 <pejo> dcoutts, "EFL"?
12:48:13 <paczesiowa> so there is yet another fusion system (array based)...
12:48:36 <dcoutts_> paczesiowa: yes, you can read the old papers on that. They're cited in the bytestring paper.
12:50:30 <dcoutts_> pejo: I can't remember where that suffix comes from, it's a functional array fusion idiom
12:50:58 <pejo> dcoutts, oh, is this the Chakravarty/Keller paper from 2001 or so?
12:51:05 <dcoutts_> pejo: right
12:51:37 <dcoutts_> pejo: we started with that, made a few improvements before coming up with stream fusion. So we were able to compare.
12:51:42 <paczesiowa> dcoutts_: stream-fusion paper didn't mention that, only fold/build and unfold/destroy. is stream-fusion better than array fusion or just different?
12:52:03 <dcoutts_> paczesiowa: ah, you must have only read the second paper, the one about stream fusion for lists.
12:52:45 <dcoutts_> paczesiowa: see http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
12:53:00 <pervonisse> hello
12:53:25 <pervonisse> is it possible to have an installation of ghc without having root permissions?
12:53:36 <pervonisse> eh, install without root permissions I mean
12:53:46 <Botje> sure
12:53:49 <dcoutts_> pervonisse: yes
12:53:55 <Botje> just set an appropriate DESTDIR when make install'ing
12:54:02 <pervonisse> okay
12:54:03 <paczesiowa> god, there is another one? I can't take a 5 min break without you inventing smth new:)
12:54:17 <pervonisse> thanks
12:54:20 <dcoutts_> Botje: erm, you want to set prefix, not DESTDIR
12:54:30 <dcoutts_> pervonisse: configure with the right --prefix
12:54:35 <Botje> really? oops :)
12:54:37 <pejo> paczesiowa, now combine all this with Supero, and the number of options makes it even harder to decide!
12:54:45 <Botje> worked for my local install i think
12:55:17 <pervonisse> ok
12:55:36 <dcoutts_> Botje: for the binary it may well do since it might be prefix independent, I'd not rely on that though.
12:55:40 <pervonisse> hmm, how big is the installation?
12:55:59 <dcoutts_> Botje: DESTDIR is for creating an install image, eg to tar up for distribution
12:56:19 <dcoutts_> pervonisse: a few 100mb
12:56:32 <pervonisse> ah okay, thanks again
12:59:26 <paczesiowa> dcoutts_: just to be sure, there are 2 papers: first is about bytestrings AND fusions, second is about stream-fusion only, right?
12:59:52 <dcoutts_> paczesiowa: right
13:21:09 <dons> dcoutts_: yeah, i think there's a revolution waiting to happen if cabal can export C headers with every lib.
13:21:42 <dcoutts_> dons: I hope so, it's a matter of finding the development time from somewhere.
13:21:45 <dons> yes.
13:21:52 <dcoutts_> so many things to do
13:21:59 * dcoutts_ disappears
13:22:04 <dons> summer of code, hackathon and IHG coming up..
13:22:04 <dons> .
13:22:09 <dcoutts_> @arr!
13:22:09 <lambdabot> Avast!
13:22:16 * dcoutts_ isn't here
13:22:55 <c_wraith> beginner question:  how do I re-write a function of the form "f x = g $ h x" to not use a parameter?  This feels like it should be obvious, but I'm not seeing it.
13:23:31 <Cheshire> c_wraith, f = g . h
13:23:36 <c_wraith> It's just..  "f = g . h", isn't it?  *sigh*  I'm slow today
13:24:35 <pumpkin-> c_wraith: in general, @pl on lambdabot can help you figure those things out, too
13:24:43 <LeoD> @pl f x = g $ h x
13:24:44 <lambdabot> f = g . h
13:25:34 <c_wraith> @pl f x y = g h $ i x y
13:25:34 <lambdabot> f = (g h .) . i
13:25:46 <c_wraith> Heh.  No wonder I couldn't figure that out.
13:25:48 <PeakerWork> c_wraith: whenever you have a $ b x   its the same as:  a $ b $ x   and  all sequences of a$b$c$...  are the same as: a.b.c...$last
13:26:03 <c_wraith> Thanks for letting me know about @pl
13:26:05 <PeakerWork> c_wraith: you might want to use the "result" function on that one
13:26:50 <PeakerWork> @go semantic editor combinators
13:26:54 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:26:54 <lambdabot> Title: Conal Elliott » Semantic editor combinators
13:27:07 <PeakerWork> c_wraith: Read this page, it helps with this stuff and other stuff too
13:27:11 <c_wraith> thank you
13:28:08 <conal> PeakerWork: thx for the plug. :)
13:28:32 <PeakerWork> conal: I direct everyone to that page, its great :)
13:28:41 <conal> :) :)
13:29:26 <conal> i have yet to write the follow-on post about generalizing SECs from functions to deep arrows.  powerful stuff.
13:30:10 <Cheshire> what's a SCE?
13:30:11 <PeakerWork> conal: I used some Data.Accessors which is kinda similar to SECs except it has more specific types
13:30:12 <Cheshire> oh
13:30:16 <Cheshire> nvm I figured it out
13:30:30 <conal> PeakerWork: yeah.  it is kind of similar.
13:45:17 <slint> is there a predefined function like words or lines only with an own seperator?
13:45:35 <dons> in the 'split' package
13:46:07 <dons> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
13:46:21 <slint> thanx
13:46:33 <dons> cabal install split
13:47:42 <Libertus> Is it normal to feel a bit stupid the first time one reads "Arrows, Robots, and Functional Reactive Programming", or is it just me?
13:47:50 <Libertus> :)
13:47:59 <boegel> dons: you're like a walking Haskell encyclopedia, aren't you? :)
13:48:44 <dons> i try to stay on top of my game.
13:48:56 <csmark> <--- feels like an idiot
13:49:09 <dons> Libertus: FRP is weird.
13:49:16 <conal> :)
13:49:27 <boegel> dons: I really like your blog post on GAs and Haskell
13:49:40 <dons> cheesr. yes, i saw the comment from Itkovian
13:49:48 <boegel> dons: you should browse through my COLE paper, if you can find the time
13:49:48 <Libertus> dons: i'm sensing the power, but it's probably a bit beyond my capabilities for now
13:49:57 <daf> dons: "weird"?
13:50:31 <opqdonut> 2249.09  dons$ Libertus: FRP is weird.
13:50:39 <opqdonut> gah, stupid mouse
13:51:06 <Libertus> What I can't figure out is where the rps parameter is coming from in, for instance, the definition of rcTurn. It's probably an arrow syntax thing, but I'm not sure.
13:51:52 <conal> Libertus: you might get some foundational intuition from http://conal.net/fran/tutorial.htm
13:52:15 <conal> Libertus: the essential idea of FRP without the arrow notation.
13:52:35 <Libertus> conal: thanks
13:54:09 <Libertus> It's odd. I started programming by writing games. Now, a couple of decades later, I can't imagine doing it again. Waaaay more complex these days.
13:55:14 <tromp_> you can still write a pong game these days
13:55:19 <conal> Libertus: yes.  there's been lots of effort in expanding the complexity and not as much in finding simplicity again with the new functionality.
13:55:52 <Libertus> conal: phew... I though it was my brain degrading :)
13:56:13 <roconnor> Libertus: I feel the same way.  I wonder what happend to me.  I think I just know how hard it is now.
13:56:43 <pumpkin-> the bouncing kids on that page are awesome
13:56:50 <conal> :)
13:57:12 <Libertus> Yeah... I can't believe how arrogant I was at 12... just sitting down and deciding to write a game!
13:57:34 <Cheshire> that's not arrogant
13:58:58 <proq> Libertus: why is that arrogant?  were you not able to finish the game?
13:59:05 <Libertus> More like total lack of fear and circumspection... no idea how hard it is or how long it will take, combined with free meals and laundry :)
13:59:28 <Libertus> I finished the games back then. Now I'm scared to start. But that's ok... I'm older and wiser.
14:00:04 <shamrock> Cheshire: you got that right about the complexity. I have just been playing bioshock running on cedega on debian. The lighting and physics are a tad better than they were back in 85 when I was writing "inc a" or whetver for a Z80 to move a character right by a pixel :-;
14:00:13 <roconnor> Libertus: oh, that is where we differ.  I rarely finished programs I wrote
14:00:15 <conal> Libertus: i really believe the modern complexity is unnecessary.  it's just harder to simplify than to compmlicate.
14:01:28 <slint> i think most 3d games are reinventing the wheel
14:01:29 <Cheshire> shamrock :) the old games are wonders to read if you can get the source
14:02:30 <proq> Libertus: I agree it is wise to be afraid at times, but you plod on
14:02:45 <Libertus> conal: that's why I find Haskell appealing... i can use it to simplify certain problems, so long as I can extract a moment or two of genius from my aging mind
14:03:32 <Libertus> proq: I've no intention of giving up. I don't like feeling stupid, but it's a necessary step along the path to enlightenment
14:04:44 <Libertus> i could do with a time machine and send myself forward a couple of years so I can elide the hard work :)
14:04:55 <shamrock> Cheshire: not really. I wrote a few back when and it seemed great at the time but most was pretty crap compared to what we would expect now. Sure, more effort into saving bytes but that was about it. People expect more now.
14:05:25 <conal> Libertus: maybe part of the shift is that children are more open-minded about the perspectives they take, i.e., questions & categories.  adults mostly accept their culture's dominant questions & categories.
14:05:40 <chessguy> hmm, i wonder if there's some type magic that could be done so that applying a function to both a raw value and that value in the functor had the same name
14:05:41 <shamrock> There were of course notable exceptions breaking the genre.
14:05:50 <chessguy> s/the functor/a functor/
14:06:46 <mauke> binary-strict--  # no docs
14:07:10 <conal> Libertus: in programming, the cultural context is largely sequentiality, state, and discreteness, which is a very poor fit for graphics, behavior, interaction, etc.
14:08:09 <ski> chessguy : elaborate ?
14:08:16 <loop9> Hello
14:08:28 <ski> hi there, yourself
14:08:33 <Libertus> conal: absolutely... it's like I have to remember something I already figured out years ago but forgot during a career spend building business apps
14:08:36 <mauke> haddock--  # no docs for binary-strict
14:08:49 <loop9> Anyone know anythin about VB
14:09:12 <loop9> dfs
14:09:13 <loop9> ds
14:09:13 <loop9> fsdf
14:09:13 <loop9> dsf
14:09:13 <loop9> sf
14:09:14 <loop9> dsf
14:09:15 <loop9> df
14:09:17 <loop9> sdf
14:09:19 <loop9> sdf
14:09:21 <loop9> dsf
14:09:23 <loop9> sdf
14:09:25 <chessguy> @where ops
14:09:25 <loop9> sORRY
14:09:25 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:09:26 <Cheshire> hi loop9
14:09:27 <loop9> hello
14:09:35 <loop9> Hwllo
14:09:35 <Japsu> in my buffer: @wher
14:09:38 * Japsu too slow
14:09:46 <loop9> Cheshire
14:09:50 <loop9> Do you know VB
14:09:55 <Cheshire> loop9, yes
14:10:00 <Axman6> visual basic?
14:10:03 <loop9> cAN WE HAVE A RIVATE CHAT
14:10:04 <chessguy> ski: i was just thinking, it seems like it would streamline a lot if i could say "f $ x" and "f $ MyFunctor x" without changing $
14:10:07 <ski> loop9 : maybe try ##VB.NET ?
14:10:07 <Axman6> or the beer?
14:10:09 <Japsu> please ignore the troll
14:10:18 --- mode: ChanServ set +o glguy
14:10:20 --- mode: glguy set +b *!*@94-171-216-52.cable.ubr15.wolv.blueyonder.co.uk
14:10:27 <chessguy> buh-bye
14:10:52 <conal> Libertus: a question i like in software design is "what is it" or "what does it mean"?  for instance, what is animation, and what is graphics.  if ever i use a verb in the answer, i'm off track of the question and re-mired in imperative thinking.
14:11:14 <ski> chessguy : where `MyFunctor' is what ? a data constructor ? at type constructor ?
14:11:29 <chessguy> chessguy, an instance of Functor
14:11:50 <Axman6> chessguy: your poor car/gps :(
14:11:53 <conal> Libertus: the innocence ("arrogance") of a child is vital
14:12:01 <ski> so maybe you mean `f $ x' where `x' in the first case have type `a', and in the second case have type `MyFunctor a' ?
14:12:02 <chessguy> Axman6, ugh, don't get me started
14:12:12 <Libertus> conal: oooh... that's got me thinking...
14:12:15 <conal> Libertus: ... vital to creativity.
14:12:17 <chessguy> ski sure
14:12:17 <conal> :)
14:12:27 <chessguy> ski: x has the same type in both
14:12:41 <chessguy> ski: in my original
14:12:44 <Libertus> I may have (temporarily) lost my appreciation for simple coolness
14:12:51 <mauke> binary-strict--  # no docs
14:13:23 <Libertus> Building stuff for the sake of it, rather than for some illusory perception of external value
14:13:25 <ski> chessguy : i think a syntax for something like that is possible .. but i haven't implemented it yet
14:13:54 <conal> Libertus: in a word: "Play"
14:14:03 <Libertus> conal: perfect
14:14:09 <conal> :)
14:14:17 <Libertus> easy to forget
14:14:29 <opqdonut> chessguy: that's kinda like something i was thinking about some time ago
14:14:48 <opqdonut> chessguy: making a haskell-like language in which every computation is monadic, one just chooses the monad appropriately
14:15:07 <opqdonut> chessguy: there would be an "implicit" identity monad around if nothing else were
14:15:19 <augustss> opqdonut: tell me when you have succeeded.  I want it!
14:15:22 <ski> (i would write the former like `f x'  and the latter like `> f <x> <' or something of the like ..)
14:15:27 <chessguy> opqdonut, yeah, my idea was the same thing for an identity functor
14:15:32 --- mode: glguy set -o glguy
14:15:34 <conal> Libertus: one of my mentors says "never do anything that isn't play".  life's too precious.
14:15:57 <chessguy> augustss, surely something like this is possible in the huge magic that is typeclass hackery
14:15:58 <ski> opqdonut : that's a bit similar to my scheme, i think
14:16:08 <opqdonut> augustss: when one thinks it through, problems with type-inference start rising up. it needs something else than "vanilla" h-m inference
14:16:27 <augustss> chessguy: I think the problem is ambiguity
14:16:33 <opqdonut> ski: which does what?
14:16:40 <ski> sorry ?
14:16:42 <Ninju> When upgrading GHC (currently on 6.8.3, looking to install 6.10.1), is there anything I need in terms of preparation? (I'm mostly just thinking about cabal here, as installing packages from that has been a pain in the ass)
14:17:27 <chessguy> augustss, oh?
14:17:58 <dons> Ninju: make sure you use cabal install
14:18:03 <dons> cabal install foo
14:18:06 <dons> will save the day
14:18:08 <ski> (we need a stack of implicit functors ..)
14:18:24 <augustss> chessguy: I have no deeper insights than that :)
14:18:31 <chessguy> augustss, lol, ok
14:18:34 <mauke> binary-strict--  # API incompatible with binary
14:18:52 <ski> opqdonut : sorry, clarify "which does what?" ?
14:19:03 <Ninju> do I need to reinstall cabal (uninstall before upgrade, then install again after) and reinstall all my packages, or does it just work out okay?
14:19:50 * ski should write down/up his system sometime ..
14:20:00 <csmark> nooob ? here...what is this "binary-strict- -...." ?
14:20:08 <dons> Ninju: nope. just install 6.10
14:20:14 <dons> i'd then upgrade cabal anyay
14:20:16 <dons> then reinstall things
14:20:17 <opqdonut> ski: your scheme, please elaborate on it
14:20:35 <Ninju> dons: Ok, thanks.
14:20:58 * BMeph is intrigued by ski's ideas and would like to subscribe to his newsletter
14:21:28 * BMeph think opqdonut will get the first subscription, though
14:21:38 <opqdonut> :)
14:21:52 <chessguy> hmph. i brought the idea up
14:22:03 <chessguy> just because i have no clue how to begin to think about implementing it....
14:22:14 <ski> it's just a couple ideas for a system for reflecting monads, applicatives, functors (and maybe more) that i've been thinking on and off for a couple of years
14:22:28 <opqdonut> reflecting as in?
14:22:35 <ski> as in monadic reflection
14:22:52 <ski> (see `Representing Monads' by Andrzej Filinski)
14:23:08 <ski> as a very simple example, consider
14:23:13 <opqdonut> ah
14:23:19 <ski>   data Person = P Name Age
14:23:23 <ski> we assume
14:23:23 <opqdonut> (yes, i googled up filinski)
14:23:33 <ski>   parseName :: IO Name
14:23:38 <ski>   parseAge :: IO Age
14:23:40 <ski> we want to write
14:23:48 <ski>   parsePerson :: IO Person
14:24:05 <ski> we define it as
14:24:21 <ski>   <parsePerson> = P <parseName> <parseAge>
14:24:24 <ski> note that
14:24:36 <ski>   <parseName> :: Name  -- with `IO' side-effects
14:24:36 <plex0r> -_+
14:24:50 <ski> if we have
14:24:53 <ski>   x :: m a
14:25:07 <ski> for some monad `a' (or functor, applicative, in more general cases)
14:25:08 <ski> then
14:25:18 <ski>   <x> :: a  -- with `m'-side-effects
14:25:33 <ski> that's the basic goal/idea
14:25:48 <ski> the details is in how to make a working coherent system for this
14:26:04 <opqdonut> yeah, that's pretty much what i was chasing after
14:26:08 <ski> (and i believe i have gotten many of those right)
14:26:14 <p_l> hmm, anyone can show me some Network.Socket examples?
14:26:15 <opqdonut> sounds nice
14:26:38 <ski> (sorry, obviously `m' is the monad, not `a')
14:27:20 <ski> one nice thing is that you might notice that
14:28:08 <ski> (writing `>x<' of `x' as the "inverse" of `<x>' of `x')
14:28:34 <ski>   >if foo then bar else baz<  =  foo >>= \b -> if b then >bar< else >baz<
14:28:49 <plesn> hello!
14:29:15 <glguy> why does cabal check dependencies for things that are not buildable?
14:29:27 <ski> (so you could write side-effectful expressions in the condition of an `if'-`then'-`else', instead of having to name the intermediate boolean)
14:29:38 <glguy> if the test harness is "buildable: False", then I don't care if I don't have the expected quickcheck available to not build with
14:30:36 <chessguy> http://codepad.org/738zFLzx
14:30:55 <chessguy> basically, i want to write apply once so that it can fit both of these definitions
14:32:07 <ski> chessguy : i think that's problematic, since you can't unify `f a' with `b' such that `f = id' and `a = b'
14:32:25 <ski> (no higher-order unification)
14:32:42 <chessguy> yeah
14:33:56 <plesn> ----------------------------------------------------------------------
14:33:59 <chessguy> thus the need for an implicit Id functor
14:36:28 <skorpan> is it possible to derive Show for some datatype that was imported?
14:36:36 <ski> (`fmap f >x< = >f x<' ..)
14:36:47 <skorpan> i.e. without modifying the imported module
14:37:30 <paczesiowa> skorpan: there is standalone deriving in ghc
14:37:42 <chessguy> ski: i'd rather write it without any special bracketing, but i'd accept that :)
14:37:45 <ski> 8.5.2. Stand-alone deriving declarations <http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving>
14:38:46 <skorpan> thanks, but i just realized i can't derive Show for this anyways :P
14:39:01 <chessguy> heh
14:39:40 <ski> (of course, that definition of `fmap' would be circular, since it would expand to calls to `fmap' :)
14:40:07 <skorpan> now that we're on the subject on fmap, what the hell is fmap fmap fmap?
14:40:15 <Botje> deep dark magic
14:40:16 <ski> @type fmap fmap fmap
14:40:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:40:20 <pumpkin-> it uses the Functor instance of ->
14:40:22 <ski> @type fmap . fmap
14:40:24 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:40:28 <ski> (same thing)
14:40:32 <pumpkin-> which happens to make fmap .
14:40:44 <EvilTerran> ?src (->) fmap
14:40:44 <lambdabot> fmap = (.)
14:40:53 <skorpan> oh
14:40:56 <skorpan> i see
14:41:02 <skorpan> [22:39] <Botje> deep dark magic
14:41:04 <pumpkin-> fmap `fmap` fmap === fmap . fmap
14:41:04 <skorpan> word up
14:41:31 <chessguy> @type fmap fmap
14:41:31 <ski> (why `===' ?)
14:41:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
14:41:35 <chessguy> @type fmap . fmap
14:41:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:42:00 <ski> @type  (<*>) fmap
14:42:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> f a) -> (a -> b) -> f b
14:46:22 <ddarius> :t fmap ap fmap
14:46:24 <lambdabot> forall a a1 b. (a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
14:51:50 <idnar> @unpl fmap ap fmap
14:51:50 <lambdabot> fmap (\ d e -> d >>= \ b -> e >>= \ a -> return (b a)) fmap
14:54:29 <Botje> ski: probably to mimic the "defined-as" equality from mathematics
14:54:39 <Botje> which is three bars arranged horizontally
14:55:30 <Botje> ≡ <- this one
14:57:37 <benmachine> three bars isn't defined as, strictly speaking
14:57:43 <benmachine> it's just identity
14:58:05 <benmachine> e.g. sin^2 x + cos^2 x === 1
14:59:25 * Cheshire writes  sin^2 x + cos^2 x = 1
14:59:33 <benmachine> well that's also true
14:59:40 <Cheshire> := for defined
14:59:40 <benmachine> but not such a strong statement :)
15:00:12 <benmachine> sin²x + cos²x ≡ 1
15:00:12 <mauke> sin^2 + cos^2 == 1
15:00:15 <benmachine> there we go
15:00:28 <Cheshire> what is wrong with =
15:00:34 <conal> benmachine: what's this distinction you're making between identity and (?) equality?
15:01:40 <benmachine> conal: sin x = 1 can be true, sin x ≡ 1 isn't
15:01:58 <conal> benmachine: because you have a rule of injecting quantifiers?
15:02:26 <benmachine> how I was taught it was that identity was essentially a way of saying "for all <variable>"
15:02:33 <mauke> ...> [sin^2 + cos^2, 1] <*> [0.1, 0.2 .. 0.5]
15:02:34 <mauke> [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
15:02:36 <conal> benmachine: so for you, ≡ is a partly-syntactic rather than purely-semantic device.
15:02:45 <conal> now i get it.
15:03:03 <benmachine> is it just me?
15:03:04 <sebjoh_> hi, what's the difference between using "data Dtype = .. " and "data Dtype where .."?
15:03:06 <conal> i prefer mauke's version.
15:03:11 <conal> equality on functions.
15:03:18 <chessguy> sebjoh_, the latter is a GADT
15:03:27 <chessguy> sebjoh_, search around for GADT
15:03:43 <sebjoh_> chessguy: thanks
15:03:44 <conal> benmachine: well, conventional math notation is pretty sloppy.
15:04:06 <sebjoh_> chessguy: all I needed to know
15:04:26 <conal> benmachine: and mushes syntax & semantics together.  e.g., "function of one variable".
15:04:39 <benmachine> I guess so
15:05:14 <benmachine> wikipedia, source of all knowledge, says
15:05:15 <benmachine> An identity is an equality that remains true regardless of the values of any variables that appear within it, to distinguish it from an equality which is true under more particular conditions. For this, the 'triple bar' symbol ≡ is sometimes used. (However, this can be ambiguous since the same symbol can also be used with different meanings, for example for a congruence relation.)
15:05:37 <conal> ick.  a syntactic definition.
15:05:45 <conal> but now i understand where you're coming from.
15:07:51 <conal> it's a macro, rather than a function.
15:08:14 <conal> so it needn't have compositional semantics.
15:09:36 * ddarius tends to use more accurate (if not always more explicit) notation.
15:12:44 <conal> one useful distinction is semantic equality vs a computable subset.  Haskell's (==) is the latter (unless abused).
15:14:04 <ddarius> I would say it is more along the lines of "extensional" versus "intensional"
15:14:51 <conal> ddarius: what is?
15:17:10 <ddarius> The difference between Haskell's (==) and a semantic equality seems more along the lines of extensional and intensional v. computable and not necessarily computable.
15:17:58 <kerlo> @docs
15:17:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:17:59 <conal> ddarius: which one do you see as extensional and which intensional?
15:18:50 <conal> i think of all non-extensional uses of (==) as being bugs.
15:19:20 <ddarius> It's not quite those, but the Haskell (==) seems to be more extensional and semantic equality more intensional.
15:19:22 <Cheshire> what dose extentional mean?
15:19:29 <Cheshire> is that like  forall P, P x -> P y ?
15:19:32 <Cheshire> to say x == y
15:19:36 <conal> ddarius: semantic equality non-extensional?
15:20:33 <conal> i use "extensional" to mean semantically compositional, i.e., the meaning of the whole is strictly a function of the meanings (extensions) of the parts.
15:20:44 * kerlo frowns
15:21:04 <kerlo> Is Control.Exception.SomeException a recent addition?
15:22:05 <ddarius> conal: I am using "extensional" here to showing equality based on external properties (i.e. observables) v. "intensional" which uses how something is defined even if that isn't externally observable.
15:22:33 <Cheshire> I didn't understand that about intensional
15:23:00 <conal> ddarius: to me your definition sounds compatible with my meaning.
15:23:04 <Cheshire> well I guess it makes sense
15:23:14 <conal> like a function vs a macro
15:23:59 <conal> extensional cannot access the construction/definition/syntax of something.  just the thing itself (denotation of the expression).
15:24:15 <kerlo> Well, that was the easiest problem to fix ever. Control.Exception.SomeException was not in scope, so I commented out the type signature that referenced it, and now it compiles. I think.
15:24:26 <kerlo> But now I'm getting this: sillylisp.hi: openBinaryFile: permission denied (Permission denied)
15:25:16 <conal> so for me, extensionality is the essence of functional programming.
15:25:54 <Cheshire> I read about extensionality in set theory
15:26:10 <conal> though i'm starting to use the term "denotational programming" for what i mean by "functional programming".  some people include IO as functional programming.
15:26:13 <Cheshire> they said it's the basis of mathematical reasoning
15:26:49 * kerlo tries not compiling to a flash drive
15:27:05 <QtPlaty[hireme]> IO is needed for any real world application of functional programing.
15:27:13 <conal> it is that basis for me
15:27:23 <kerlo> sillylisp.o: In function `r1DT_info':
15:27:23 <kerlo> (.text+0x332): undefined reference to `mtlzm1zi1zi0zi0_ControlziMonadziTrans_zdf1_closure'
15:27:26 <kerlo> Aaa.
15:27:39 <conal> QtPlaty[hireme]: "needed" is pretty strong.
15:27:59 <conal> QtPlaty[hireme]: maybe true without further insights.
15:28:02 <kerlo> Functions are IO.
15:28:10 <conal> also a self-fulfilling prophecy.
15:28:34 <QtPlaty[hireme]> conal: How so?
15:28:58 <conal> QtPlaty[hireme]: i'm just imagining how one could believe a particular mechanism, say IO, is "needed".
15:29:30 <omnihil> qtplaty, writing a library for other people is a real-world application of functional programming that does not require use of IO.
15:29:31 <conal> QtPlaty[hireme]: one answer is "lack of other ideas at the time", i.e., a property of people's thinking at a particular time, more than anything essential
15:30:16 <Cheshire> conal, huh ? you need IO to interact with files systems or networks or graphical dispalys .. ?
15:30:33 <kerlo> A REPL doesn't use the IO monad. Lazy K doesn't use the IO monad.
15:30:37 <conal> Cheshire: only if you buy into a popular set of assumtions, right?
15:30:44 <Cheshire> conal, one could possibly write pure interfaces to these things but the pure interfaces are defined using IO
15:30:57 <Cheshire> conal, I don't know what assumptions they are
15:30:58 <conal> Cheshire: imagine more broadly.
15:31:12 <conal> Cheshire: that's the way of assumptions, isn't it?
15:31:13 <QtPlaty[hireme]> kerlo: A REPL uses IO just not the IO monad.
15:31:24 <kerlo> I guess it depends on just what you mean by "IO", really, doesn't it.
15:31:27 <Cheshire> what is the way of assumptions?
15:31:39 <conal> Cheshire: that one is usually unaware of them.
15:31:55 <kerlo> A piece of functional programming is useless if it just runs and then exits.
15:31:57 <Cheshire> conal, a bit impossible to tell I guess -- sometimes I make assumptions precise sometimes not
15:32:09 <Cheshire> but necessarily I can't tell how often..
15:32:11 <QtPlaty[hireme]> Indeed REPL is very clearly about IO interactions Read Eval Print Loop.  Read and Print are very IOish.
15:34:34 <kerlo> So, what does a person do when GHC says stuff like "undefined reference to `mtlzm1zi1zi0zi0_ControlziMonadziTrans_zdf1_closure'"?
15:34:50 <omnihil> kerlo, are you using --make?
15:35:48 <kerlo> No.
15:35:53 <kerlo> That sounds like a good idea.
15:36:51 <conal> the whole imperative computation model ("IO" in the Haskell sense) is artificial.  it's an invention.  so i'm skeptical about any claims that it's some necessary.
15:37:41 <conal> just habitual, not natural or necessary.
15:38:17 <QtPlaty[hireme]> Haskell is artificial.  And in a broader sence so is all of Haskell.
15:38:37 <conal> so?
15:38:52 <conal> one artifical thing is not necessarily necessary for another artificial thing.
15:39:01 <conal> or even likely necessary
15:39:29 <mle> conal: a LazyK using monads would be rather nice...
15:39:54 <QtPlaty[hireme]> It can be argued that unless your a neo-platonist all of mathmatics is artificial.  So using its classification as artifical as support for its un-necessarty isn't valid.
15:40:05 <Cheshire> conal, well I would like to share that viewpoint it sounds very interesting.. at the moment it seems like Haskell is implemented in or compiled to lower level things which must do IO .. so I don't see it disappearing
15:40:36 <Cheshire> I don't see how you could like, bootstrap away IO but still do network/filesystem/graphic/event interaction ..
15:40:48 <Cheshire> since all that stuff is IO..
15:40:54 <conal> QtPlaty[hireme]: i wasn't trying to show that IO is unnecessary.  i was explaining why i doubt your assertion that it is necessary.
15:41:19 <Cheshire> conal, (actually what is the exact thing you refer to when you say IO?)
15:41:22 <conal> Cheshire: and yet those lower level things don't do IO in the sense of imperative programming.
15:41:41 <conal> Cheshire: i mean the imperative computation model
15:41:52 <conal> Cheshire: discrete, stateful, sequential.
15:42:29 <conal> Cheshire: "I don't see how" is a great starting point, if it's accompanied by curiosity about how.
15:42:56 <conal> while "necessary" and "impossible" are ways to stay stuck.
15:43:00 <BMeph> Remember, "IO" =/= "I/O". :)
15:43:05 <conal> imnho
15:43:10 <conal> BMeph: exactly!
15:43:48 * BMeph does his "OMG, conal said I got something right!" dance
15:43:53 <Cheshire> hehe
15:43:57 <conal> BMeph: hah!
15:44:24 <conal> i can believe I/O is usesful in its essence, while IO (the imperative computation model) is just a fad/habit/rut.
15:44:31 <conal> *useful*
15:44:58 <Cale> Hmm, but is IO really the same as the usual imperative computation model?
15:45:16 <conal> Cale: yeah, i think so.
15:45:20 <Cale> I can see that it's perhaps a lot closer than other models you might have considered.
15:45:20 <conal> Cale: (semantically)
15:45:25 <Cale> But I don't think it's the same at all.
15:45:43 <monochrom> I/O does not have to be imperative.
15:45:43 <Cale> After all, how many imperative languages have (>>=)?
15:45:49 <conal> monochrom: agreed.
15:45:56 <conal> Cale: all of them do, semantically.
15:46:05 <Cale> I don't think so...
15:46:15 <Cale> Many of them don't even have first class functions.
15:46:20 <conal> Haskell's IO type is a more *convenient* way to describe imperative computation.
15:46:33 <Cale> So it wouldn't even make sense for them to have something corresponding to (>>=) which takes a function as a parameter.
15:46:38 <conal> Cale: agreed.  which is orthogonal to the *semantics* of IO
15:47:05 <conal> Cale: i'm distinguishing between the semantic model of IO and the building blocks that haskell provides.
15:47:39 <conal> (>>=) doesn't alter the semantic model of IO
15:47:52 <conal> just how convenient it is to program imperatively.
15:48:28 <conal> C is a great way to write denotationally impenetrable programs.  Haskell is a better way.
15:48:31 <Cale> Okay... and even then there are subtle differences... normally in imperative programming you don't give a name to the result of a computation, you only give names to places to store values, and update mutable cells...
15:48:47 <monochrom> An important job of IO's >>= is to define event order.
15:48:49 <conal> Cale: again, that's not IO, that's IORef
15:49:19 <Cale> conal: Right,  x := foo(bar)  in Pascal, say, is not like  x <- foo bar  in Haskell.
15:49:45 <ddarius> Cale: The semantics of x := foo(bar) is not x <- foo bar
15:49:52 <Cale> yeah.
15:49:59 <Cale> It's more like writeIORef x =<< foo bar
15:50:04 <conal> Cale: i don't want to make (or argue with) claims about whose way of writing imperative programs is better.
15:50:22 <conal> i'm a lot more interested in how to program functionally instead.
15:50:38 <Cale> I just, think the style of writing programs in the IO monad is sufficiently different from classical imperative programming that perhaps it warrants a new name.
15:50:41 <ddarius> Yes. Which is fine.  x <- foo bar is not meant to model that.  rather you have foo(bar) is modelled as liftM2 ($) foo bar
15:50:41 <conal> i'm happy to agree to "haskell is the world's best imperative programming language"
15:50:56 <conal> Cale: which is compatible with what i was saying.
15:51:05 <Cheshire> can you compile IO monad code directly to C?
15:51:06 <monochrom> monadic programming is the new name :)
15:51:12 <conal> Cale: you're talking about vocabulary, and i'm talking about the semantic domain.
15:51:15 <Cheshire> or directly to assembly
15:51:20 <Cale> It's also impossible or unusably difficult to write things like sequence/forM as library functions in most imperative programming languages.
15:51:23 <conal> Cheshire: ghc does/did it.
15:51:42 <conal> Cale: yes, "haskell is the world's best imperative programming language"
15:51:43 <ddarius> Cale: There's no need to. for-loops a
15:51:48 <ddarius> -are- forMs
15:51:53 <kerlo> What is a .hi file?
15:52:21 <Cale> ddarius: things like
15:52:51 <Cheshire> Cale, but in Scheme say.. you can write these things
15:52:55 <conal> Cale: personally i didn't pick up haskell because i was looking for a better imperative programming language.
15:52:59 <Cale> conal: But my point is that the way we use the IO monad isn't just imperative programming, it's using functional programming to perhaps accomplish imperative programming.
15:53:11 <EvilTerran> semantics!
15:53:32 <conal> Cale: and i'd say something similar: haskell nicely combines functional & imperative programming.
15:53:40 <ddarius> Cale: My and Conal's point is that with Haskell and the IO monad you are writing directly in the semantic domain of C (say).  C is syntactic sugar for that.
15:53:40 <monochrom> synmatix
15:53:41 <travisbrady> kerlo: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html
15:53:58 <conal> Cale: which is cool in a mechanics sense, but not in a semantic sense.
15:54:12 <Cale> I'm not sure I understand what you mean.
15:54:42 <conal> ddarius: right.  C & Haskell+IO have the same semantic domain, and hence the same essential semantic problems.
15:55:14 <Cale> The things which can be accomplished are perhaps the same, but you'd hope this was true of any solution to the problem of I/O. The things which can be accomplished easily or naturally are somewhat different.
15:55:22 <Cale> I don't understand how else to compare them.
15:55:24 <conal> ddarius: haskell+io is a more of power tool for writing semantically inscrutable programs.
15:55:35 <Cheshire> conal, is there a problem if you start with IO and build something nice in terms of it?
15:55:58 <jenner> guys, I'm a bit lost with the definition of class/instance/type and corresponding constructors from the tutorial, is there some other doc that would explain it in detail?
15:56:03 <Cheshire> (something which could be e.g. replaced with primitves, or implemented in terms of different IO system)
15:56:13 <conal> Cheshire: yes & no.  in a sense, pure functional (i.e., no IO) programming is exactly that.
15:56:26 <Cale> jenner: Hmm... you could try the Report.
15:56:32 <Cale> jenner: Or just ask a question :)
15:56:50 <conal> Cheshire: the RTS of a pure FP lang is implement with lots of side-effects.  if done correctly, the result lives in a much simpler semantic domain than the implementation does.
15:56:54 <jenner> Cale: I'm afraid I can't even form a real question right now :)
15:57:16 <conal> Cheshire: my gripe with the imperative model is that it leaked out of the RTS into the application programming model.
15:57:30 <Cale> jenner: Which tutorial are you reading?
15:57:44 <conal> Cheshire: which i also appreciate as a crutch until we learn to think more functionally
15:57:49 <jenner> Cale: haskell.org/tutorial
15:58:08 <Cale> jenner: Oh, that's a somewhat difficult one unless you already, say, know ML :)
15:58:08 <QtPlaty[hireme]> conal: What model would you use for application programing then?
15:58:10 <osfameron> gah!  trying to represent a grid in haskell requires a functioning brain
15:58:24 <BONUS> that one's also known as the not so gentle introduction to haskell :]
15:58:52 <conal> QtPlaty[hireme]: i think about what things mean and go from there.  it's difficult and fun.
15:59:05 <jenner> Cale: I don't ... I thought I was a bit prepared since I'm used to list comprehension/map/filter/lambda etc. from other languages, but boy I was so wrong :)
15:59:07 <QtPlaty[hireme]> conal: And I/O interaction?
15:59:24 <conal> QtPlaty[hireme]: i have plenty of papers on my publications page if you want to see what i mean.  also the two recent papers on my blog.
15:59:35 <Cheshire> conal, oh! how does zipperfs fit into your view?
15:59:40 <QtPlaty[hireme]> conal: URL?
15:59:40 <Cheshire> Olegs thing
16:00:05 <conal> @go conal
16:00:06 <lambdabot> http://www.robbieconal.com/
16:00:06 <lambdabot> Title: Robbie Conal's Art Attack!
16:00:10 <conal> oh :(
16:00:14 <conal> http://conal.net
16:00:14 <Cale> jenner: Basically... values (like 5, "hello", (\x -> x^2), etc.) are arranged into types (like Integer, String, Integer -> Integer, etc.)
16:00:23 <QtPlaty[hireme]> gotcha
16:00:26 <conal> @where conal
16:00:27 <lambdabot> http://conal.net
16:01:10 <Cale> jenner: Classes are like predicates on types, that is, they can either be true or false for any given type.
16:01:11 <conal> QtPlaty[hireme]: see also http://conal.net/blog for my two most recent papers.  especially the one on "denotational design".
16:01:28 <Cale> jenner: When the predicate is true, the class provides some functionality associated with the type
16:01:57 <Cale> jenner: For instance the class Eq consists of the types which have a definition of equality on their values.
16:02:08 <Cale> That is, the types where you can use (==) and (/=)
16:03:07 <Cale> If you create your own new datatype, you can usually decide to have the compiler derive an instance of Eq automatically (because Eq is one of the special few which support that), or you can write your own definition of (==) by writing an instance declaration.
16:03:09 <wli> No preorder class(es). :(
16:03:15 <Cale> Oh, I have to go to dinner.
16:03:20 <Cale> But maybe that helps a bit.
16:03:23 <jenner> Cale: so basically, if I say type ... deriving (Eq) I can use (==) if the default == matches my type or if I provide my own == implementation?
16:03:33 <jenner> yes, ok
16:03:48 <BONUS> typeclasses are like behaviours that a type supports
16:03:52 <BONUS> or things it can acts like
16:04:14 <jenner> so classes are used a) for pattern patching and b) as a sort of a "mixin class"
16:04:18 <BONUS> if you make your type part of the Eq class, that's saying that values of your type can act as things that can be equated
16:04:19 <jenner> BONUS: I see
16:04:35 <BONUS> they aren't used for pattern matching :) that's constructors
16:04:49 <jenner> ah! see, I knew I was misunderstanding things
16:04:56 <BONUS> basically you make a type and you think: what can this type act like? can it act like something that can be equated? can it act like something that can be ordered?
16:05:05 <monochrom> I think of typeclass as organized overloading
16:06:20 <BONUS> typeclasses are cool cause you can make your typeclasses and types independently
16:06:32 <BONUS> and then think about what makes sense and connect them
16:07:02 <jenner> hm, I'm still confused about types and data and constructors :(
16:07:43 <BONUS> basically you have a type, say Bool
16:07:45 <wli> conal: I'd at least use the word "Grassman" or phrase "exterior algebra" somewhere.
16:07:50 <Cheshire> jenner, what about them?
16:07:53 <BONUS> data Bool = True | False
16:08:06 <jenner> by using 'data FooBar = Foo | Bar' I create a new type, right?
16:08:07 <BONUS> Bool is the type, True and False are the constructors that can be used to make a value of that type
16:08:15 <BONUS> yeah
16:08:20 <jenner> ah, ok
16:08:32 <BONUS> you can read that like: a FooBar is either a Foo or a Bar
16:08:42 <wli> conal: Or maybe even "Jacobian."
16:08:54 <BONUS> you can also have stuff like data Person = Person String Int
16:08:56 <osfameron> how do you pattern match on a whole record?  I want to define 'foo (Cell c) = ...' but it's complaining because Cell is actually a 3-element record
16:09:04 <osfameron> I just want the whole thing
16:09:23 <osfameron> aha...  c@(Cell {})
16:09:27 <BONUS> what that means is that the type Person has one type constructor (also called Person) and that constructor has two fields: one is a string, the other an int
16:09:42 <BONUS> and because Person is the constructor, you can pattern match against it
16:09:50 <Cheshire> jenner, it defines a new tye FooBar with two new values Foo and Bar which have type FooBar
16:09:53 <BONUS> like f (Person name age) = ...
16:10:17 <jenner> but I have to define the constructor somewhere, right?
16:10:29 <kerlo> jenner: no, the data declaration defines them.
16:10:30 <jenner> Cheshire: yeah, got it
16:10:33 <omnihil> jenner, Foo and Bar are the constructors
16:10:35 <benmachine> it tends to confuse me how types and constructors often seem to have the same names
16:10:43 <jenner> hm
16:11:32 <jenner> aargh, ok, I think I understand now :)
16:11:54 <BONUS> or like if you have data Maybe a = Nothing | Just a
16:12:12 <jenner> ok, so we
16:12:15 <BONUS> Nothing and Just are the data constructors and you can pattern match against them
16:12:18 <Badger> @src (.)
16:12:18 <lambdabot> (f . g) x = f (g x)
16:12:26 <BONUS> so you can do
16:12:30 <jenner> 've got the types and constructors, how about kinds?
16:12:33 <BONUS> f Nothing = <something>
16:12:39 <BONUS> f (Just a) = <something else>
16:12:48 <conal> wli: yes, i could have mentioned jacobian as a particular representation of linear maps.  do you have a grassman pointer?
16:12:56 <BONUS> and the a will have the value of the thing that it holds inside
16:12:59 <kerlo> How do I get GHC to give me a .hc file?
16:13:13 <jenner> BONUS: I think I got it now, the pointer about constructor + pattern matching was precious
16:13:29 <pumpkin_> kerlo: --keep-hc-file(s) -fvia-C iirc
16:13:36 <Cheshire> jenner, kinds are like types for type :p
16:13:41 <omnihil> or just ghc -C
16:13:46 <Cheshire> so you have   value :: types  and types :: value
16:13:49 <Cheshire> oops
16:13:52 <Cheshire> types :: kinds
16:13:54 <pumpkin_> omnihil: nice, that looks a lot nicer :)
16:14:03 <conal> a point of the "beautiful differentiation" paper is that derivatives are not numbers, vectors, matrices, etc but rather something more simple/general.
16:14:05 <BONUS> kinds are like the types of types
16:14:16 <conal> wli: oh, i found grassman.  thanks.
16:14:20 <kerlo> pumpkin_: the flag is called --keep-hc-file(s)?
16:14:31 <pumpkin_> well, both the singular and plural work I think
16:14:36 <pumpkin_> I can't remember
16:14:36 <BONUS> like if you have Maybe a = Just a | Nothing. we say that Maybe takes one type parameter
16:14:45 <BONUS> because it can be a Maybe Int, Maybe String, whatever
16:14:52 <BONUS> if the a insied the Just is an Int or String
16:14:53 <omnihil> ghc --help can tell you the answer, too.
16:15:01 <pumpkin_> * -> * is a cute smiley
16:15:08 <conal> wli: thanks for the comments.  i'll check out exterior algebra.
16:15:17 <BONUS> so Maybe a has a kind of * -> * because it takes one simple type as the 'a'
16:15:17 <jenner> BONUS: but what if it's nothing?
16:15:19 <BONUS> Maybe a
16:15:22 <f4hy> Does anyone else have problems with emacs indentation?
16:15:25 <pumpkin_> jenner: makes no difference
16:15:37 <BONUS> jenner: doesn't matter, kinds don't care about data constructors
16:15:37 <kerlo> Huh. It doesn't recognize either --keep-hc-file or --keep-hc-files.
16:15:38 <BONUS> just the types
16:15:52 <wli> conal: ISTR simplification being carried out via the determination of a basis for a vector space of functions sufficient to represent the terms, then trying to annihilate the result with linear differential operators, then doing something horrible I can't remember at all (finding an annihilating linear differential operator, solving the diffeq, then reconstructing things from there? It was bad, whatever it was.)
16:16:04 <pumpkin_> kerlo: whoops, single -
16:16:11 <pumpkin_> kerlo: but apparently -C does the same thing
16:16:17 <BONUS> goin to sleep now, don't mean to toot my own horn, but this might be a cool read for oyu http://learnyouahaskell.com/making-our-own-types-and-typeclasses i wrote this with people who get confused about types, data constructors, type constructors, kinds, etc. in mind
16:16:23 <conal> wli: thanks for the warning!;)
16:16:31 <pumpkin_> and it has awesome pictures
16:16:34 <BONUS> :]
16:16:36 <BONUS> take care y'all
16:16:49 <f4hy> After the module statment I can not get emacs to indent things correctly.. does it need to be formated som mystery magical way?
16:16:51 <kerlo> pumpkin_: should I drop --make as well?
16:16:52 <pumpkin_> don't toot your own horn too much, you might grow hairy palms
16:16:57 <pumpkin_> kerlo: shouldn't matter
16:16:59 <BONUS> hehe
16:17:03 <kerlo> ns@laptop-d:~/Desktop/sillylisp$ ghc -C -fvia-C -keep-hc-file --make sillylisp
16:17:04 <kerlo> ns@laptop-d:~/Desktop/sillylisp$ ls
16:17:04 <kerlo> sillylisp  sillylisp.hi  sillylisp.hs  sillylisp.o
16:17:06 <jenner> huh, ok, I need to let it settle a bit, I caome back to you guys later, if I may :)
16:17:07 <wli> conal: In the algebraic case apart from simplifying nested surds there are other, much easier methods.
16:17:22 <pumpkin_> kerlo: was it already compiled?
16:17:31 <kerlo> Yes.
16:17:39 <kerlo> Should I get rid of all but the .hs file?
16:17:41 <pumpkin_> kerlo: you might need -fforce-recomp then, or to delete the product
16:18:21 <kerlo> Yay, it worked.
16:19:54 <jenner> hm, just to make sure I get this right: multiple inheritance in haskell doesn't really mean what it means in other imperative OO-languages (e.g. python), tight? I mean there's no way to have two classes with the same method and a third class inheriting from those two
16:20:06 <pumpkin_> kerlo: the c file isn't very legible though :)
16:20:22 <Badger> :t (0-)
16:20:23 <lambdabot> forall t. (Num t) => t -> t
16:20:28 <Badger> :t negate
16:20:30 <lambdabot> forall a. (Num a) => a -> a
16:20:37 <kerlo> I would imagine not.
16:20:38 <pumpkin_> typeclasses aren't very much like OO classes, other than sharing the word class
16:20:48 <omnihil> is it possible to have two different typeclasses that both define the same operator?
16:21:17 <jenner> iirc operators are just functions, so I guess not
16:21:30 <benmachine> @src negate
16:21:30 <lambdabot> negate x = 0 - x
16:21:33 <omnihil> @type (==)
16:21:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:21:49 <benmachine> @src id
16:21:49 <lambdabot> id x = x
16:21:50 <omnihil> ah, that makes sense
16:21:54 <f4hy> Why does emacs indet my file like this?? http://pastebin.com/d6cc22b6b
16:23:13 <wli> conal: Linear combinations with coefs in Q(x) of transcendental functions can be reduced to polynomials times those transcendental functions, which is an easier case too.
16:23:50 <jenner> so, now, there are types (data Foo = ...) with corresponding constructors and there are typeclasses (class Foo x where...) that are actually more like interfaces in java, right?
16:24:05 <wli> conal: It really has more to do with algebraic functions vs. transcendental functions than constant vs. non-constant.
16:24:42 <conal> wli: wild
16:24:56 <f4hy> Is there an editor for haskell that gets the indentation correct?
16:25:36 <jenner> ah, and types use typeclasses to substantiate their behavior by inheriting them, whereas typeclasses can inherit other typeclasses to extend their declared functionality, right?
16:26:07 <wli> conal: Every time "polynomials" or "rationals" get involved as an easy special case it almost immediately generalizes to algebraic functions via integral elements/bases etc.
16:26:17 <kiris> f4hy: haskell-mode in emacs
16:26:34 <f4hy> kiris: I just posted an example of haskell-mode getting it wrong
16:26:39 <f4hy> and I cant figure out how to fix it
16:26:43 <pumpkin_> jenner: typeclasses in haskell are closer to "interfaces" in java
16:26:50 <pumpkin_> but even that isn't a very good approximation
16:27:05 <kiris> f4hy: so? it has one or two problems
16:27:21 <jenner> pumpkin_: yes, but this comparison gives me at least an idea what we're talking about :)
16:27:26 <kiris> f4hy: for the most part it gets it right
16:27:29 <f4hy> kiris: well my question is still valid then. is there one that gets ir correct
16:27:55 <jenner> pumpkin_: now what is an instance? :)
16:27:58 <pumpkin_> jenner: they typically express *-able notions
16:28:03 <pumpkin_> typeclasses
16:28:07 <f4hy> kiris: it seems like getting it wrong always for the module statment is not a very small error
16:28:27 <kiris> f4hy: sucks to be you
16:28:37 <pumpkin_> jenner: and an instance allows you to specify for your own type what it means to be Xable
16:28:58 <f4hy> kiris: wow how helpful
16:29:36 <Cale> jenner: Do you know about type variables already?
16:29:50 * wli ponders something to fiddle with algebraic functions.
16:29:52 <jenner> pumpkin_: what'S the difference between an instance and a type then?
16:30:02 <Cale> jenner: Basically, types are allowed to use variables to express polymorphism in that the variable could take on any type at all.
16:30:04 <kiris> f4hy: what do you expect?
16:30:12 <pumpkin_> jenner: an instance explains how a type fits into a typeclass, sort of :)
16:30:20 <Cale> jenner: Typeclasses are used to restrict the types which the variables range over.
16:30:39 <Cale> jenner: For instance, length :: [a] -> Integer does not care what type the elements of the list are.
16:30:49 <jenner> Cale: ok
16:31:00 <f4hy> kiris: that someone could direct me to tool that gets haskell formatting correct, or that someone knew how to get emacs to do it correctly
16:31:02 <Cale> jenner: But for a function like sort, it can't have a type like [a] -> [a], because it needs to look at the elements and compare them
16:31:10 <jenner> yeah
16:31:26 <Cale> jenner: So in order to say that the elements of the list must be of an ordering-comparable type, we write sort :: Ord a => [a] -> [a]
16:31:39 <benmachine> @src length
16:31:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:32:16 <f4hy> kiris: I find it really frustrating to work in a language that does not have a tool to help with the indentation. I would imagine others would feel the same way so someone would know how to solve the problem
16:32:25 <pumpkin_> f4hy: is emacs doing indentation wrong really that big a deal? :P I use textmate that always gets it wrong :)
16:32:47 <kiris> f4hy: except it does have a tool to do the indentation, it just has some errors that are easy to work around
16:32:54 <nominolo> f4hy: what is emacs doing not correctly?
16:33:08 <nominolo> @losers
16:33:08 <lambdabot> Maximum users seen in #haskell: 658, currently: 621 (94.4%), active: 20 (3.2%)
16:33:09 <f4hy> pumpkin_: For learning it is really hard. I had to try to figure out what the correct indentaion was
16:33:13 <jenner> Cale: so defining sort :: [Num] -> [Num] would be too restrictive, ok
16:33:18 <f4hy> nominolo: http://pastebin.com/d6cc22b6b
16:33:25 <Cale> jenner: Classes are not types.
16:33:29 <benmachine> I turn autoindenting off
16:33:33 <jmcarthur> since indentation is significant, it simply can't be automatic. it changes the meaning to have different indentation...
16:33:34 <benmachine> because everyone else is wrong
16:33:46 <jmcarthur> emacs does the best it can by providing toggling indentation
16:33:50 <Cale> jenner: But, yeah. Num a => [a] -> [a] wouldn't make sense for sort.
16:34:05 <omnihil> jenner, you could define "data Person = Person String Integer" and give them a name and age. you could then define the 'Ord' operations for Person based on age, and sort would magically do the right thing.
16:34:13 <f4hy> jmcarthur: ya but emacs will alternate through the valid indentation places, but does not have the correct one as an option for the module statement
16:34:25 <nominolo> f4hy: ah, so the problem is that the indention depends on what you want to do next
16:34:26 <jenner> omnihil: ok
16:34:42 <nominolo> well, except for the top-level thing you pasted there.  that's plain wrong
16:34:57 <f4hy> nominolo: but it should alternate through the valid ones, and the correct one is not a choice
16:35:27 <nominolo> f4hy: for me it jumps to column 4 and back to 0, repeatedly
16:35:31 <nominolo> column 0 is corroct
16:35:46 <f4hy> nominolo: it does not jump to 0 for me
16:35:53 <nominolo> oh, that's weird then
16:35:54 <f4hy> nominolo: it says 4 is the sole indentation
16:36:06 <nominolo> what version of the haskell-mode are you using?
16:36:16 <f4hy> let me check
16:36:44 <f4hy> 2.4
16:36:51 <f4hy> 2.4/
16:36:56 <nominolo> oh, I have 2.3
16:36:57 <f4hy> is there a newer one?
16:37:01 <f4hy> oh..
16:37:27 <nominolo> last changelog entry from Valentine's Day 2007
16:37:43 <nominolo> maybe someone tried to make it "smarter"
16:37:52 <kiris> f4hy: haskell-mode also indents "then" and "else" wrongly, I suspect that will be a major issue for you
16:39:29 <JoshTriplett> How can I efficiently convert a number to a hex string, padded with leading zeros to a fixed width?
16:39:35 <kiris> Yi, the haskell editor, may do some things better
16:40:15 <f4hy> kiris: maybe I will try that. it is just called Yi?
16:40:27 <kiris> yeah
16:40:31 <kiris> http://www.haskell.org/haskellwiki/Yi
16:41:08 <nominolo> I'm not sure how "ready" Yi is.  It certainly made a lot of progress, though
16:41:11 <kiris> it can be installed with cabal install
16:41:16 <f4hy> Thanks. Does anyone use it? does it do well with indentations?
16:41:25 <f4hy> kiris: thanks
16:41:28 <jenner> err... types can be instances of type classes?
16:41:59 <kiris> jenner: sure
16:42:14 <Cheshire> I would say that a typeclass is defined for a type if you write an instance for that type
16:42:28 <Cheshire> so Eq is defined for Bool, Integer,.. but not for a -> B
16:42:32 <benmachine> Yi/Regex.hs:18:28: Module `Text.Regex.TDFA.TDFA' does not export `patternToDFA'
16:42:32 <benmachine> cabal: Error: some packages failed to install:
16:42:38 <kiris> f4hy: judging from the video demo, it has some extra clever indentation things but I haven't used it enough personally to say how well it does things in general
16:42:38 * benmachine is confused
16:42:48 <jenner> Cheshire: ok
16:43:18 <f4hy> Alright cool
16:43:52 <f4hy> nominolo: Is there a place to report bugs for haskell-mode or is it not really that large of a project
16:44:29 <nominolo> f4hy: not sure how maintained it is.  Maybe I should just fork it and put it on github
16:44:35 <jenner> so when I say data Foo = FooConstructor ... deriving (Eq, Ord, Show) I basically could do the same thing by providing an instance Eq Foo..., instance Ord Foo, etc. right?
16:44:36 <kiris> e.g. foo = do bar
16:44:36 <kiris>               zot
16:44:36 <kiris> if you start typing just after 'foo' to add parens, the 'zot' will stay aligned with 'bar'
16:44:52 <nominolo> f4hy: and, yes, probably an email to the author would be fine
16:44:56 <kiris> s/parens/parameters
16:45:03 <Cale> jenner: yeah
16:45:10 * jenner sighs with relief
16:45:14 <jenner> Cale: thanks
16:45:14 <JoshTriplett> kiris: Yeah, it won't fix the indentation of other lines until you re-indent those lines.
16:45:29 * wli is baffled as to why whitespace isn't being ignored as it should.
16:45:36 <wli> In Parsec that is.
16:45:52 <nominolo> f4hy: ah, so the cvs version has been changed just 5 weeks ago
16:46:11 <osfameron> gah, mutable pointers really do make some things simpler
16:46:16 <Philippa_> wli: got the code/problem narrowed down to something you can drop on a paste site?
16:46:34 <wli> It's not big to begin with.
16:46:37 <pejo> nominolo, isn't Stefan Monnier maintaining it?
16:46:37 <lambdabot> pejo: You have 1 new message. '/msg lambdabot @messages' to read it.
16:46:53 <nominolo> pejo: yes
16:47:18 <benmachine> I can't install Yi with `cabal install yi`, because it says a module it depends on isn't exporting something it expects
16:47:26 <nominolo> pejo: but if the latest release is from 2007, one may ask questions ;)
16:47:51 <benmachine> I've no idea how anyone's going to be able to help with that but you guys are all cleverer than me so I'm putting my hope in that?
16:48:00 <wli> http://pastebin.com/m4bdad339
16:48:10 <f4hy> nominolo: I will try the cvs version of it this afternoon and see if it fixes my problem
16:48:41 <nominolo> i'm trying it right now
16:48:46 <thoughtpolice> monnier has stated before he does releases infrequently
16:48:51 <thoughtpolice> but CVS is pretty regularly updated
16:49:12 <thoughtpolice> so I just started running haskell-mode from CVS, there are already lots of bugs fixed in comparison to 2.4 afaik
16:49:15 <JoshTriplett> How do I showHex a value such that it always has the same number of characters?  For instance, I want to turn 5 into 00000005.
16:49:19 <f4hy> thoughtpolice: good to know. I will try to keep up with the CVS
16:49:54 <pumpkin_> people still use CVS??
16:49:55 * pumpkin_ faints
16:50:04 <thoughtpolice> pumpkin_: inorite?!
16:50:05 <wli> Philippa: http://pastebin.com/m4bdad339
16:50:05 <Botje> wli: you have to ignore whitespace once
16:50:11 <Philippa_> wli: where does it choke on whitespace - after the operators?
16:50:28 <jmcarthur> pumpkin_: somebody where i work prefers CVS over all other version control systems, including the DVCSs... git is his second favorite
16:50:55 <nominolo> f4hy: same problem
16:50:57 <pumpkin_> do you think he's knowledgeable in the other ones enough to actually prefer?
16:51:04 <thoughtpolice> jmcarthur: any reasons why?
16:51:10 <wli> Botje/Philippa: Anywhere; it even gets wrong answers and parses as if the input were truncated.
16:51:17 <f4hy> nominolo: hmm. Alright I will have to send him an email I guess
16:51:24 <Botje> oh, that's bad :)
16:51:34 <f4hy> nominolo: thanks for checking it out and helping with it though!
16:51:41 <jmcarthur> pumpkin_, thoughtpolice: he gave reasons, but i don't remember them now. he does understand what he's talking about
16:52:12 <wli> I can't just filter whitespace since that would accept two adjacent literals where it should not.
16:52:23 <pejo> pumpkin, I keep a lot of my documents in CVS.
16:52:33 <jmcarthur> in his mind, CVS > git > other DVCSs > other VCSs > SVN
16:53:14 <wli> Do I have to pepper spaces everywhere or something?
16:53:32 <Botje> wli: how are you calling the parser?
16:53:56 <Botje> also, I think char is not a token parser
16:53:58 <JoshTriplett> jmcarthur: Reverse the first > to a < and that more accurately matches most people's opinions. :)
16:54:01 <wli> runParser parseExpr () ""
16:54:04 <travisbrady> what do we call "type", "data", "import", etc in Haskell?
16:54:23 <Philippa_> travisbrady: keywords?
16:54:42 <SamB_irssi> I think most DVCs are incomparable
16:54:44 <nominolo> f4hy: what happens if you type M-x haskell-indentation-mode?
16:54:50 <SamB_irssi> tla is an exception
16:55:16 <travisbrady> Philippa_: but what are they?  are they statements? they're not functions, so what is something in Haskell that is not a function?
16:55:29 <Botje> wli: your ^ case should be lexeme (char '^')
16:55:30 <wli> Botje: What should I use instead?
16:55:35 <f4hy> nominolo: it turns off auto indentation
16:55:44 <Philippa_> travisbrady: top-level declarations?
16:55:48 <nominolo> f4hy: well, it works a bit differently
16:55:50 <Botje> otherwise spaces after a ^ don't get consumed
16:55:59 <Botje> and likewise for your mkBinOp function
16:56:04 <f4hy> nominolo: ? what do you mean
16:56:06 <SamB_irssi> jmcarthur: what reasons can he have ?
16:56:19 <Philippa_> (infix declarations don't have to be top-level either, btw)
16:56:24 <nominolo> f4hy: try writing a function and then let x = 5 <RET>
16:56:51 <nominolo> f4hy: it no longer cycles, but you can use backspace
16:57:48 <f4hy> nominolo: I dont get it.
16:57:50 <SamB_irssi> pejo: I use RCS for that
16:58:04 <SamB_irssi> if I don't use RCS, I use a DVCs
16:58:09 <nominolo> f4hy: well, at the toplevel hitting TAB of course does nothing
16:58:10 <osfameron> yay!
16:58:11 <SamB_irssi> er. DVCS
16:58:22 <nominolo> f4hy: but inside a function it does something different
16:58:24 <osfameron> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2242#a2242 <-- this took 3 hours to write...
16:58:29 <osfameron> pesky lack of mutable references :-)
16:58:31 * osfameron ducks
16:58:32 * SamB_irssi is a bit confused because he's been hacking on an elisp package called dvc ...
16:58:40 <f4hy> nominolo: nope.. now tab at the toplevel inserts a bunch of spaces
16:59:01 <nominolo> f4hy: oh, it mostly works in CVS HEAD, though
16:59:27 <f4hy> nominolo: ok well I will try the cvs version then.
17:00:11 * SamB_irssi thinks it's a long time since he's used the CVS version of anything
17:00:18 <Botje> wli: i just checked. In my compiler I use reservedOp in my opTable
17:00:25 * SamB_irssi doesn't think he's used CVS in ... oh ... the past year or two ?
17:00:32 <Botje> (instead of char as you do)
17:00:38 <Botje> good, time for some ETQW
17:00:44 <Botje> STROYENT MAN!
17:01:58 <wli> Okay
17:03:29 <monochrom> wli: I have sample code at http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
17:03:45 <wli> Looks good.
17:04:37 <jenner> guys, does anyone know if gofer is much different compared to haskell98?
17:05:15 <nominolo> didn't most of gofer make it into haskell98?
17:06:04 <jenner> so gofer is a subset of haskell98 wrt what? (except of the standard library stuff)
17:06:12 * wli bookmarks monochrom's page.
17:06:26 <wli> jenner: The standard library part is horrific beyond belief.
17:07:35 <jenner> wli: what I'd like to find out is -- if I'm comfortable with haskell, will I fail at my "functional programming" exam next week? :)
17:07:41 <Axman6> jenner: it was what haskell came from i think. see http://donsbot.wordpress.com/2009/01/31/reviving-the-gofer-standard-prelude-circa-1994/
17:07:47 <jenner> wli: which is based on gofer
17:07:58 <jenner> Axman6: ah, thanks
17:08:01 <wli> jenner: Probably not.
17:08:24 <Axman6> jenner: they're very similar, but reading that might help you understand the major differences, like continuation based IO
17:09:39 <pumpkin_> jmcarthur: I find it hard to believe he can give good reasons to support something that doesn't even maintain enough information to give you a consistent snapshot of history
17:10:08 * wli will clean up the parser.
17:10:11 <jenner> Axman6: hm, the script has 3 chapters covering monads though, there's no mention of continuations
17:10:58 <jenner> we're talking about gofer 2.3.0
17:11:12 <jenner> weird
17:14:47 <McManiaC> how do you comment more than one line? :D
17:14:54 <omnihil> {- -}
17:15:20 <McManiaC> thx
17:15:57 <monochrom> {-@^@-}
17:29:06 <kiris> {·.·}
17:36:10 <gwern> dons: 'ven if the programmer has a few heursitics in mind to help with pruning, the search space is still huge.' <-- needs moar sp
17:38:21 <RayNbow> @check \x -> lcm x 1 == x && lcm 1 x == x
17:38:22 <lambdabot>   "Falsifiable, after 1 tests:\n-2\n"
17:39:35 <RayNbow> @check \x -> x >= 0 ==> lcm x 1 == x && lcm 1 x == x
17:39:36 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
17:39:36 <lambdabot>           ...
17:42:39 <byorgey> @info (==>)
17:42:39 <lambdabot> (==>)
17:42:47 <byorgey> =P
17:43:12 <byorgey> @check \x -> x >= 0 ==> (lcm x 1 == x && lcm 1 x == x)
17:43:13 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
17:43:13 <lambdabot>           ...
17:43:34 <byorgey> @check \x -> (x :: Integer) >= 0 ==> (lcm x 1 == x && lcm 1 x == x)
17:43:35 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
17:43:35 <lambdabot>           ...
17:44:40 <Axman6> byorgey: just use || instead of ==>
17:44:59 <byorgey> ah, good point
17:45:08 <byorgey> @check \x -> (x :: Integer) >= 0 || (lcm x 1 == x && lcm 1 x == x)
17:45:09 <lambdabot>   "Falsifiable, after 0 tests:\n-1\n"
17:45:21 <byorgey> @check \x -> (x :: Integer) <= 0 || (lcm x 1 == x && lcm 1 x == x)
17:45:22 <lambdabot>   "OK, passed 500 tests."
17:50:12 <RayNbow> > lcm (-2) (-3)
17:50:13 <lambdabot>   6
17:50:33 <RayNbow> negative numbers are evil :p
17:50:42 <benmachine> > lcm (-1) 1
17:50:43 <lambdabot>   1
18:19:18 <lispy> > lcm (-1) (-1)
18:19:19 <lambdabot>   1
18:19:34 <lispy> > gcd (-1) (-1)
18:19:36 <lambdabot>   1
18:20:48 <vincenz> @seen dons
18:20:49 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 4h 33s ago.
18:20:50 <vincenz> @seen ndm
18:20:51 <lambdabot> I haven't seen ndm.
18:27:19 <JanglerNPL> ?src lcm
18:27:19 <lambdabot> lcm _ 0     =  0
18:27:19 <lambdabot> lcm 0 _     =  0
18:27:19 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
18:32:37 <jkup> is there anything like perl's split/join functions already defined in haskell?
18:33:03 <jkup> or should i go on defining, join delim = foldr1 (\x y -> x ++ [delim] ++ y)
18:33:19 <augustss> intercalate
18:33:46 <augustss> :t intercalate
18:33:48 <lambdabot> forall a. [a] -> [[a]] -> [a]
18:34:20 <jkup> nifty, thanks
18:34:37 <wli> Axman6: I don't know how to move from the cases like sin(x)/((x^2+1)^(1/3) + x) + cos(x)/((x^2+1)^(1/3) - x), where transcendental functions appear linearly, to where sin(x) and cos(x) show up in denominators.
18:37:18 <wli> Axman6: Where they show up in the denominators I'm less sure of how to make sure things don't reduce to 0 apart from reducing the algebraic coefficients of powers of sin(x) and cos(x) to 0 and hoping.
18:38:13 <Axman6> are there formulas for what to do for that sort of situation?
18:39:27 <wli> The answer wouldn't be a formula anyway, it would be a decision procedure for whether some expression reduces to 0, or, alternatively, some set of reduction/rewrite rules to put it into normal form.
18:46:15 <wli> I think there may be a way to reduce it to the linear case using differential operators in the case that the transcendentals are solutions to diffeq's of certain forms.
18:49:02 <wli> Something like smoking out differential operators annihilating the numerator, then doing crud with the denominator and the Leibniz rule to get a diffeq annihilating the whole affair, then some sort of solution basis to that yields a basis to normalize with.
18:49:54 <wli> I'm not going to try quite that hard.
19:09:58 <wli> I think the things have to be solutions of a linear diffeq with constant coefficients, maybe I don't remember it at all.
19:11:51 <aempirei> can [] be considered a function from types to types ?
19:11:54 <aempirei> at least conceptually
19:12:13 <araujo> it's a data type
19:12:21 <aempirei> yes i know what
19:12:24 <araujo> which they behave like function applications
19:12:29 <aempirei> but imagine if you would
19:12:34 <araujo> so we can say from that point of view.. it does it
19:12:35 <sarh> it's not a datatype
19:12:39 <newsham> yes,  [] maps from types to types
19:12:42 <newsham> ?kind []
19:12:43 <aempirei> sweet
19:12:44 <lambdabot> * -> *
19:12:51 <MyCatVerbs> aempirei: yes. It has kind (* -> *).
19:13:15 <sarh> ?kind StateT
19:13:16 <lambdabot> * -> (* -> *) -> * -> *
19:13:19 <MyCatVerbs> aempirei: I think it's more common to call things like Functors "mappings" from types to types than functions.
19:13:30 <aempirei> oh in haskell world
19:13:31 <aempirei> yeah
19:13:33 <aempirei> that makes sense
19:13:39 <araujo> :)
19:14:23 <sebjoh_> @faq Does Haskell make sense?
19:14:23 <lambdabot> The answer is: Yes! Haskell can do that.
19:14:30 <sarh> sometimes
19:14:31 <MyCatVerbs> Admittedly it's all kind of a pain in the arse caused by having the same concepts in both code and the type system, but not wanting to use the same names for them. :)
19:14:41 <augustss> I think calling [] a function from type to type is fine.
19:14:51 <newsham> aempire: this is well worth the read:  http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
19:15:06 <kpreid> now let's bring Curry-Howard into it
19:16:05 <aempirei> sweet
19:16:55 <b1> ...
19:17:29 <augustss> aempirei: And there's a type system for the type level functions.  But those types are usually called kinds.
19:18:18 <b1> right, so, I'm trying to use cabal and it starts "Resolving dependencies..." and dies uninformatively by stating "Killed"
19:18:33 <augustss> That sounds bad
19:18:34 <b1> cabal-install v 0.5.2, cabal lib 1.4.0.2 for what it's worth
19:18:45 <aempirei> so C++ templates are similar to these type functors
19:18:56 <aempirei> at least the most similar data typing concept
19:18:59 <newsham> or java generics.
19:19:01 <aempirei> ok
19:19:02 <aempirei> yea
19:20:04 <Cale> Just to be clear, not every type function is a functor. To be a functor, there needs to be an implementation of fmap :: (a -> b) -> (f a -> f b), for the given f.
19:20:39 <b1> anyone? cabal?
19:20:57 <newsham> b1: wish i knew. :(  sounds broken.
19:20:58 <b1> damn the nickserver, by the way.
19:21:08 <augustss> b1: try a newer version?
19:21:10 <bmh> there we go.
19:22:09 <bmh> augustss: I'll give it a shot
19:23:21 <bmh> odd, I have ghc 6.10.1, which ought to have cabal 1.6.0.1
19:33:36 <Axman6> ok, maths question, would it be possible to have a base pi numbering system?
19:36:30 <Cale> Axman6: yes
19:36:45 <Pseudonym> Yes.
19:37:03 <sarh> if you can tolerate severely many different representations for a given number
19:37:08 <Pseudonym> The 1998 edition of Knuth volume 2 goess into it in a bit.
19:37:08 <IminYourMonad> maybe im stupid but amdahl's law: 1 / (1-P), if 50% of a program is parallellized, how can the speedup be 2? should it be 50%?
19:37:23 <Pseudonym> The section is called "positional number systems".
19:37:55 <vincenz> IminYourMonad: well no, in theory you could run that parallelizable fraction on an infinte set of cores
19:38:05 <Pseudonym> http://en.wikipedia.org/wiki/Golden_ratio_base
19:38:10 <Pseudonym> That is one way of thinking about it.
19:40:08 <Axman6> Cale: and it would go 1,2,3,10,11,12,20... which would be 1,2,3,3.14159...4.14159... in base 10?
19:40:22 <Axman6> uh, 11,12,13
19:40:24 <Cale> IminYourMonad: Amdahl's law is talking about the limit of the speedup as the number of parallel elements tends to infinity
19:40:46 <Cale> Axman6: Yeah, it's just polynomials in pi
19:41:00 <Pseudonym> ? [0,1..] >>= \e -> [pi^e,2*pi^e,3*pi^e]
19:41:05 <Pseudonym> > [0,1..] >>= \e -> [pi^e,2*pi^e,3*pi^e]
19:41:06 <lambdabot>   [1.0,2.0,3.0,3.141592653589793,6.283185307179586,9.42477796076938,9.8696044...
19:43:40 <IminYourMonad> i see
19:49:20 <Cale> It's perhaps worth noting that Amdahl's law doesn't account for the way that parallelisation changes the problems which it's possible to try to solve, because it fixes the problem and then works out the speedup for varying processors.
19:50:57 <Cale> It might be that the 50% of the processing time which can't be parallelised is (for example) logarithmic in the input size, in which case as you add more processors, you can make the problem much larger without using more time.
19:53:59 <vincenz> Amhdal's law is mostly to be used for upperbounding, not for getting actual speedups
20:03:36 <MyCatVerbs> Amhdal's law is mostly to be used for making people feel depressed. :)
20:06:09 <gwern> amdahl's law - yet another full programmer employment result :(
20:06:27 <gwern> sometimes I wish we could just get even one major area without a nasty limiting result!
20:07:30 * juhp wonders if the c2hs hackage will replace gtk2hs' internal c2hs
20:16:38 <ahunter1> Am I msising something in the standard library of type (roughly) (i,i) -> (i -> e) -> Array i e (or similar with STArray et al?)
20:17:27 <ahunter1> I guess it's vaguely equivalent and decently efficient implemented as array (x,y) $ map f $ enumFromTo x y, but still, seems like a good function for the interface
20:17:58 <Saizan> using range is more appropriate
20:18:25 <glguy> newListArray is close
20:18:57 <roconnor> ahunter1: enumFromTo isn't what you want
20:19:16 <Lemmih> MyCatVerbs: You should send that quote to HWN.
20:19:23 <ahunter1> roconnor: yeah, yeah, range, I forgot...I just meant that composition seems like it should just exist in std
20:19:34 <roconnor> right, range, that's it
20:19:54 <roconnor> Bah, Saizan already said this
20:19:56 <roconnor> I'm too slow
20:20:17 <vincenz> roconnor: Hello
20:20:38 <roconnor> vincenz: hello
20:20:45 <vincenz> roconnor: how's it going
20:20:56 <roconnor> vincenz: I'm unemployed!
20:21:04 <vincenz> o.O
20:22:14 <chiusano> hello
20:23:06 <chiusano> does Haskell provide a simple mutable box type?
20:23:14 <TomMD> chiusano
20:23:18 <TomMD> chiusano: Yes
20:23:48 <Saizan> the simplest is IORef
20:23:49 <chiusano> with get :: Box a -> IO a and set Box a -> a -> IO a
20:23:53 <TomMD> chiusano: Look at Control.Concurrent.STM, Control.Concurrent.MVar, and Data.IORef
20:24:13 <gwern> @quote Amdahl
20:24:13 <lambdabot> No quotes match. :(
20:24:27 <chiusano> aha
20:24:36 <Axman6> chiusano: either IORefs or MVars are what you want i think
20:24:39 <gwern> @remember MyCatVerbs Amhdal's law is mostly to be used for making people feel depressed. :)
20:24:39 <lambdabot> Okay.
20:24:44 <gwern> @quote Amdahl
20:24:45 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
20:24:46 <chiusano> is IORef primitive, or could you implement them in Haskell?
20:24:47 <TomMD> chiusano: I suggest MVar and Chan (from Control.Concurrent.Chan) for most uses.
20:24:59 <Axman6> primitive afaik
20:25:44 <MyCatVerbs> Lemmih: which quote? Amdahl's law?
20:25:49 <chiusano> okay, cool, thank you
20:26:11 <gwern> @forget MyCatVerbs Amhdal's law is mostly to be used for making people feel depressed. :)
20:26:11 <lambdabot> Done.
20:26:21 <gwern> @remember MyCatVerbs Amdahl's law is mostly to be used for making people feel depressed. :)
20:26:22 <lambdabot> Good to know.
20:26:24 <gwern> @quote Amdahl
20:26:24 <lambdabot> MyCatVerbs says: Amdahl's law is mostly to be used for making people feel depressed. :)
20:26:34 <gwern> there we go. correct spelling n all
20:26:36 <gwern> @flush
20:27:06 <chiusano> actually, I have another question, is there an IORef but for other monads?
20:27:22 <Axman6> IORef is built using STRefs
20:27:46 <Axman6> the ST monad is a sort of safe IO monad (no actual side effects, but you can have mutable state inside it safely)
20:28:05 <MyCatVerbs> gwern: thank you for correcting me. ^^
20:28:46 <chiusano> it looks like IORef is basically the same as STRef, but in a different monad
20:29:04 <Saizan> it is
20:29:23 <Axman6> chiusano: well, i think that are actually the same, but using RealWorld for the 'state' parameter of the STRef
20:29:45 <Axman6> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
20:29:51 <Axman6> hmm, no source links
20:30:16 <Axman6> chiusano: what do you want to use them for btw?
20:31:09 <chiusano> Axman6: nothing in particular - I was just curious
20:32:20 <Axman6> chiusano: you might also want to look at MVars, which can be empty or full (IO/STRefs can only ever be full. MVars are a good way of synchronising between two threads)
20:32:46 <chiusano> ya, I was looking at those... they seem handy
20:33:26 <Axman6> like, you can do something like this: main = do {var <- newEmptyMVar; forkIO (someIOAction >>= putMVar var); takeMVar var} and main will wait until someIOAction puts its result in var
20:34:40 <Axman6> or main = do {var <- newEmptyMVar; forkIO (someIOAction >>=  putMVar var); takeMVar var}
20:34:44 <Axman6> whoops
20:35:02 <chiusano> hmm
20:35:36 <Axman6> or main = do {var1 <- newEmptyMVar; var2 <- newEmptyMVar; forkIO (someIOAction >>=  putMVar var1); forkIO (someOtherIOAction >>= putMVar var2); takeMVar var1; takeMVar var2}
20:36:00 <Axman6> which means someIOAction and someOtherIOAction can run concurrently, and main won't exit until both have finished
20:36:09 <chiusano> that is cool
20:36:13 <Axman6> yep :)
20:36:28 <chiusano> MVar seems like a useful primitive for building higher level abstractions
20:37:06 <Axman6> well, Chans are built from MVars. they're a means for having a channel between threads.
20:37:31 <chiusano> can Chans be distributed across machines?
20:37:38 <Axman6> no
20:38:07 <chiusano> hm
20:38:56 <Axman6> so say in an http server, you might have one thread forked that listens on a socket, and puts the http requests into a Chan. then you could have a few other threads all listening to that thread, and they will take from the Chan, process the request, and then try and take another request from the chan. a pretty easy way to get a multithreded HTTP server
20:39:22 <Axman6> chiusano: for that sort of thing, i still thing Erlang is better suited. i do wish there was some nice way to do that though
20:39:26 <chiusano> nice
20:40:06 <chiusano> I have to run... thanks for help
20:40:07 <Axman6> also, MVars are a lot faster than mutexes and such in C, so concurrenct in haskell is not just easy, it's fast
20:40:08 <chiusano> :)
20:40:11 <Axman6> o/
20:45:11 <Axman6> anyone know what QSems are for? i'm not familliar with semaphores
20:45:44 <Pseudonym> Semaphores are a synchronisation primitive that a lot of other synchronoisation objects can be made out of.
20:45:58 <MyCatVerbs> Axman6: they're ordinary semaphores. An integer that starts with some value. You can try to decrement it. If it's value is zero, then it stays at zero and you block.
20:46:18 <Pseudonym> The way I think about them is they're a bucket of tokens.
20:46:22 <Pseudonym> There are two things you can do.
20:46:27 <Axman6> got a practical example?
20:46:28 <MyCatVerbs> Axman6: you can also increment it. If there's at least one thread blocked on it, then exactly one of those threads is unblocked, and the value stays at zero.
20:46:28 <Pseudonym> Put a token in the bucket, or get a token out.
20:46:35 <Pseudonym> If there aren't any in there, you wait until there is.
20:46:37 <pumpkin_> the taking out is blocking
20:46:53 <Pseudonym> Axman: Well, you can make a mutex, for example.
20:46:57 <Pseudonym> A bucket with one token.
20:47:07 <MyCatVerbs> Axman6: in practice they're a step up from locks merely because the thread that "opens" a semaphore needn't be the same one that "closed" it. :)
20:47:10 <Pseudonym> Whoever has the token has access
20:48:04 <Pseudonym> The reason why they're important is that they're... uhm... I think they're universal in some sense.
20:48:16 <Pseudonym> You can't implement a condition variable if all you have is mutexes.
20:48:17 <Axman6> heh
20:48:21 <Pseudonym> But you can if you have semaphores.
20:48:32 <Pseudonym> But more to the point, they're easy to implement on top of spinlocks.
20:48:40 <Pseudonym> So in that sense, they're historically important.
20:48:56 <Axman6> from reading the code, i think i understand what they do now
20:49:15 <MyCatVerbs> You can implement barriers in terms of semaphores very easily, too. Also read-write locks.
20:49:32 <Pseudonym> Right.
20:49:48 <Pseudonym> So they're not a terribly efficient way to implement such things, but they're a universal primitive.
20:49:51 <Pseudonym> In some deep sense.
20:50:21 <TomMD> Axman6: And you can use semaphores to make great dead-lock situations.
20:50:51 <Axman6> heh, good to know :)
20:52:06 <MyCatVerbs> Axman6: also, MVars are not AFAIK faster than the concurrency primitives you get in C in the threaded case.
20:52:20 <MyCatVerbs> In fact, they should be a little slower - albeit wildly more convenient.
20:52:50 <Saizan> they are way faster if you don't link with -threaded though
20:53:23 <MyCatVerbs> Axman6: the expensive thing is the fact that you have to synchronize between all the CPUs in the machine. That costs something on the order of an L2 cache miss's worth of CPU time burnt every single time you hit one, AFAIK.
20:54:51 <MyCatVerbs> Yes. With the non-threaded VM, working with MVars does not cost interestingly more than working with IORefs does - they're pretty much just normal pointers.
20:55:37 <TomMD> But if you assume your code will always be running with the non-threaded VM you run a serious risk of me hitting you.
20:55:39 <MyCatVerbs> If you actually design and write a daemon that way, it'll probably run much, much faster if you compile it without the threaded VM, and simply run one process for each of your computer's CPUs.
20:56:08 <MyCatVerbs> TomMD: true, that is a suicidal assumption for libraries to make.
20:56:49 <MyCatVerbs> TomMD: for applications, that's fine, though.
20:57:00 <MyCatVerbs> IMO, YMMV, etc.
20:57:26 <TomMD> Well, for applications you are the final controller of the binary in many important ways - so I'd typically agree.
20:58:56 <MyCatVerbs> I'd be surprised to see anyone extensively using Concurrent Haskell under the hood in most libraries, though.
20:59:08 <TomMD> humm can't think of a simple example for a threadpool.
20:59:28 <TomMD> Simple to show but complex enough to need state of the threads to be semi-synced.
20:59:39 <MyCatVerbs> Semi-synced?
21:00:19 <MyCatVerbs> Wouldn't just an ordinary farmer/workers parallel processing scheme suffice?
21:00:24 <TomMD> any N jobs can use an old state but it is assumed that 1) The state will remain consistant (using STM) 2) Newest jobs get a recent state.
21:00:47 <MyCatVerbs> Actually, I think I've written one app that could do with that.
21:01:23 <TomMD> Its on hackage.  The API is a bit complex to some; I'm trying to make a half decent blog about it.
21:01:41 <TomMD> @hackage control-engine
21:01:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-engine
21:01:58 <ahunter1> OK, I think I'm slightly screwing up my Control.Applicative and needing too many parens:
21:02:05 <ahunter1> stuff <- lines <$> (readFile =<< head <$> getArgs)
21:02:13 <MyCatVerbs> Web crawling for a search engine. Say you want to make many requests concurrently, but without having to go to the trouble of using event-driven APIs. So you use a thread pool, and a queue of URLs to be visited, and keep a set of all the URLs that have been visited so far.
21:03:01 <MyCatVerbs> When you download a page, you add all the links from it that aren't in the visited set to the queue to be visited.
21:03:40 <pumpkin_> ahunter1: that seems strangely convoluted :)
21:03:42 <TomMD> MyCatVerbs: Pretty good.
21:03:52 <MyCatVerbs> If, when a worker takes a URL off the queue, it turns out to be in the current visited set, then it just ignores it.
21:04:15 <ahunter1> pumpkin_: just trying to use the standard stuff to pipe a IO result through a few pure things (and some inpure ones)
21:04:20 <ahunter1> how would you write it?
21:04:24 <MyCatVerbs> So avoiding putting URLs in the queue twice is merely a problem for performance, rather than correctness.
21:05:08 <TomMD> MyCatVerbs: Much more interesting than yet-another-firewall (which is what my thinking was stuck in)
21:05:11 <TomMD> Thanks
21:06:01 <MyCatVerbs> TomMD: welcome. It didn't take much thought. I've written one (albeit its threading mechanisms sucked and I'm surprised they worked at all) and hence the idea of how one might do it better stuck in my mind. =)
21:08:19 <pumpkin_> ahunter1: fmap lines $ readFile . head =<< getArgs maybe?
21:08:32 <pumpkin_> pretty much the same thing :P
21:08:34 <MyCatVerbs> Also, for that example, I'd use large Bloom filters rather than actually keeping the URLs around, because it doesn't actually quite matter in practice if you fail to ever visit some pages. Sure, it'll make your data have holes in it once every, say, 10^6 elements or so, but when you get into the millions of pages scanned, it's irrelevant. You're going to get ten times that many holes anyway from momentary network screwups, broken ...
21:08:40 <MyCatVerbs> ... webservers, etc.
21:09:03 <MyCatVerbs> I need to find whoever wrote the line-splitting plugin for irssi that I'm using right now, and hug them for that.
21:09:13 <Axman6> heh
21:09:24 <Axman6> sounds useful
21:10:07 <MyCatVerbs> That's the first time it's actually saved me. But it's more important than just avoiding being truncated mid-monologue.
21:10:43 <MyCatVerbs> It means that I don't have to worry that my monologue might be interrupted halfway through. I don't have to think about it. I have more free mental energy to monologue with! Mwhahahahah!
21:11:25 <TomMD> MyCatVerbs: Funny you mention the bloom filter - exactly what I was thinking.
21:11:42 <pumpkin_> flower power
21:52:47 <skorpan> ...
21:55:22 <pumpkin_> ... indeed
21:56:07 <sbahra> Hi
21:58:41 <Gracenotes> fo sho
21:59:04 <skorpan> shizzles
21:59:18 <Gracenotes> I should say so
22:03:30 <pumpkin_> fo shizzle my nizzle
22:06:23 <Saizan> are there estabilished methods to measure potential parallelism?
22:12:56 * wli fails to normalize algebraic functions of a single variable.
22:23:41 <vincenz> @seen conal
22:23:41 <lambdabot> I saw conal leaving #haskell and #ghc 1h 52m 19s ago, and .
22:24:56 <maxote> hi guys, what's the algorithmic difference between Hindley-Milner and Damas-Milner? the Damas-Milner method is unknown to me :s
22:26:01 <wli> wikipedia
22:27:09 <maxote> wli, the wikipedia doesn't say the difference, doesn't say about Damas.
22:27:19 <Saizan> afaiu they both refer to the same type system/inference algorithm
22:27:46 <maxote> Saizan, why the same?
22:28:19 <wli> D-M was a minor/subtle change, not sure what
22:28:36 <maxote> wli, it's the problem, the minor change is unknown.
22:29:02 <wli> Most mean D-M when saying H-M.
22:29:47 <Saizan> http://en.wikipedia.org/wiki/Hindley-Damas-Milner_theorem#Hindley.E2.80.93Milner_type_inference_algorithm
22:29:57 <Saizan> Luis Damas [2] finally proved that Milner's algorithm is complete and extended it to support systems with polymorphic references.
22:30:41 <maxote> Damas -> "extended it to support systems with polymorphic references."  where can i see this extension?
22:31:04 <Saizan> i.e. let bindings ?
22:31:28 <Saizan> i guess you can look at the referenced paper
22:32:30 <maxote> be careful, in the past, "polymorphic" was written in HM, "parametrically polymorphic" was written in System F (overall F_2)
22:36:19 <maxote> people confuses the meanings between polymorphism and parametrical polymorphism. Most they believe polymorphism is refered to parametrical polymorphism.
22:37:32 <Saizan> well in HM and the lambda cube that's the only polymorphism you have, no?
22:38:58 <IminYourMonad> do you think studying CS/math by yourself is a waste of time? because it is hard to learn it s well as you do in uni(I presume) by studying yourself and trying to figure stuff out by yourself and having noone to check
22:40:01 <maxote> Saizan, wrong, lambda cube is the Barendregt's cube, HM is one vertex of the lambda cube.
22:40:03 <cads_> I'm in your monad, stealing all your bind
22:40:25 <Saizan> maxote: so?
22:40:53 <Saizan> maxote: do you have non-parametric polymorphism on other vertices?
22:41:11 <pumpkin_> IminYourMonad: not at all
22:41:34 <cads_> IminYourMonad: I think it's possible to grab a few books in jump into graduate level maths and CS... really it's ridiculous a lot of the useless stuff they teach you in your first four years, it's mostly for discipline, I figure
22:42:01 <maxote> yes, if HM is 1st order propositional logic, the another non-parametric polymorphism is 1st order predicative logic
22:42:32 <maxote> it's another vertex
22:42:46 <Saizan> ok, dependent types, why are those non-parametric?
22:43:21 <maxote> i think they will be parametric if they are 2nd or higher order.
22:43:30 <facedownH> maxote: ?
22:45:20 <maxote> e.g. one polynomial is polymorphic, the incognites and coeficients are alpha and beta, they can be boolean, natural, integer, rational, real, complex, algebraic, etc.
22:46:04 <maxote> the derivative function is parametric polymorphic, it is, the input is a polynomial, and the output is another polynomial.
22:46:27 <facedownH> ?
22:46:37 <pumpkin_> so what is polymorphism that isn't parametric, in this case?
22:46:52 <Saizan> i think you're using a peculiar definition of "parametric"
22:47:28 <maxote> para-metric, it is, metric is boolean, natural, integer, rational, real, complex, algebraic, etc., para-metric is something more complicated.
22:48:03 <pumpkin_> you're reducing it to its etymology? :o
22:48:19 <maxote> yes
22:48:39 <Saizan> parametric polymorphism is usually used in contrast to bounded polymorphism, where instantiating a function to a particular type can change its behaviour
22:48:45 <Saizan> while in parametric it cannot
22:49:39 <Saizan> i'm not sure where 1st order predicative falls
22:49:41 <Gracenotes> ad-hoc, some say
22:49:51 <pumpkin_> next to a metric?
22:49:56 <pumpkin_> == parametric
22:50:12 <pumpkin_> :P
22:50:43 <Gracenotes> o nos
22:50:57 * pumpkin_ puts on his etymology hat
22:50:58 <maxote> pumpkin, i heard paralogic, paramodulation, etc
22:52:13 * Saizan thinks that using etymology to derive a meaning doesn't work well for formal terms
22:52:22 <pumpkin_> yeah :)
22:52:54 <inimino> it can be illuminating even if inaccurate
22:53:00 <pumpkin_> except for zygohistomorphic prepromorphisms
22:53:06 <pumpkin_> then etymology is all you have
23:12:42 <cads_> can we say that the statement of a parametric type is a function of some parameters?  F(3) :: R -> R -> R -> R, F(1) :: R -> R?
23:14:32 <Saizan> you're saying that a parametric type can be seen as a function from types to types?
23:15:15 <cads_> from values to types, I think?
23:15:28 <Cale> whaa?
23:15:57 <Cale> Give an example of a normal parametric type of the sort you mean. Ordinarily (in Haskell) types have type parameters.
23:15:59 <Saizan> in HM you don't have functions from values to types at all
23:16:05 <Cale> Like (Tree a)
23:16:34 <pumpkin_> I'd like values to types :P
23:16:40 <Cale> (Which specialises to Tree Integer and Tree String)
23:16:42 <pumpkin_> but I don't see it happening in haskell
23:17:57 <cads_> cale, my brain is too tired
23:21:20 <cads_> what's the type of functions F that map R^n into R for a given n > 0?
23:21:44 <Cale> Um, in Haskell?
23:22:06 <cads_> in whatever type annotation that'd be handy for it :D
23:22:44 <Cale> Well, if I wasn't concerned with Haskell, I might just write R^n -> R
23:23:51 <Cale> In Haskell, I would normally be forced to use a tuple type, or else not worry about fixing the number of vector components at compile time.
23:24:05 <IminYourMonad> how many hardware courses do you need as a programmer? i mean you dont any actually but to really be a good programmer you need to nderstand the computer, especially obv for the lowlevel stuff. but lets say i want to be a machinelearning/computergame/computervision programmer, is a basic course in computer architecture and processor design enough to get a good grasp?
23:24:25 <pumpkin_> "but to really be a good programmer you need to nderstand the computer"
23:25:19 <pumpkin_> I guess you'd need to define good programmer first ;) but you don't need to know too much about the hardware in general
23:25:49 <pumpkin_> it might be handy to understand why some things work the way they do, but haskell is nice in that can isolate you from those details
23:26:08 <pumpkin_> including ordering of instructions
23:28:14 <cads_> cale, I wouldn't mind writing something like    L2Norm : R^n -> forall n in N+, R^n -> R : X maps-to-> sqrt[sum_{k=1->n} [X_{k}^2]
23:28:27 <cads_> ]
23:28:27 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
23:29:27 <pumpkin_> cads_: I'd like that too :P although maybe with a different syntax
23:30:32 <Cale> cads_: That's... a strange placement for the forall
23:32:02 <cads_> ... yeah the first 'R^n ->' should not be there
23:32:56 <Saizan> yeah, that's expressible with dependent types
23:35:02 <luqui> cads_, X maps-to-> ...   is a long way of writing \x ->   :-)
23:37:01 <cads_> :)
23:38:06 <Cale> Or a short way, if you have the LaTeX symbol
23:38:51 <Cale> Has anyone tried writing things from lambda calculus using ↦
23:38:57 <Cale> ?
23:40:37 <cads_> http://mathbin.net/6750
23:41:33 <cads_> latex makes me happy :)
23:41:48 <pumpkin_> where does the X come from?
23:42:21 <luqui> cads_, that all makes sense to me except for the colon before X
23:42:21 <pumpkin_> and isn't it normally N^+?
23:43:32 <luqui> my preferred notation for such things is still lambda with a dot
23:43:37 <luqui> (not a silly arrow)
23:46:28 <cads_> luqui, you'd read it like "l2 is a function that maps from R^n to R such that X (which is assumed to be an element of R^n) is mapped to the square root of the sum of the squares of it elements"
23:46:51 <cads_> its*! :)
23:48:13 <luqui> so, you're using colon as both "is" and "such that"
23:48:47 <cads_> I always read ":" as "such that", anyways ... so "l2 such that Rn is mapped to R such that X maps to bleh"
23:49:00 <luqui> yeah, but that doesn't make sense
23:49:14 <luqui> l2 isn't a proposition
23:49:50 <cads_> ooh you're right
23:50:28 <luqui> so in d.t. languages, the second colon would just be an equals
23:50:40 <luqui> (although then the X |-> ...  becomes an object rather than a proposition)
23:51:01 <erikc> ImInYourMonad: ive found the digital circuits, processor design, memory, busses parts of my undergrad quite handy for programming, the analog circuit / power system stuff not at all
23:51:23 <pumpkin_> erikc: you did EE?
23:51:29 <erikc> ECE
23:51:40 <pumpkin_> ah
