00:02:18 <opqdonut> is there a changelog somewhere?
00:05:40 <Lex> Hello Everyone!
00:06:19 <aleator> I'm trying to build ghc610. make hangs with http://haskell.pastebin.com/d141cc710 Any ideas?
00:07:17 <Lex> Could anyone help me on a program that diphers text using the Vigenere cipher?(it's supposed to be simple, but I find it hard)
00:07:30 <pumpkin_> ##crypto?
00:07:54 <pumpkin_> aleator: check your ghc-pkg list
00:08:02 <pumpkin_> and make sure there's not the identical package in the system and user dir
00:09:27 <Lex> Can anyone help me out on a program?
00:11:08 <Saizan> Lex: are you stuck on something in particular?
00:12:35 <Lex> yes, I'm having trouble making the program take a string that involves only letters
00:13:26 <aleator> pumpkin_: doesn't seem to be
00:13:26 <opqdonut> > filter isAlpha "a23c4f66//&55"
00:13:28 <lambdabot>   "acf"
00:14:06 <Lex> It's supposed to be a simple vigenere cipher program, but I don't know how to start
00:15:25 <ManateeLazyCat> Someone show simple example for how to use >>> ?
00:15:46 <opqdonut> > (+1) >>> (*2) $ 3
00:15:48 <lambdabot>   8
00:15:58 <opqdonut> for functions, >>> is just flip (.)
00:16:14 <pumpkin_> flip (<<<) :P
00:16:18 <opqdonut> > (1,2) >>> (3,4)
00:16:19 <lambdabot>       No instance for (Arrow (,))
00:16:19 <lambdabot>        arising from a use of `>>>' at <inte...
00:16:20 * SubStack paws at catface 
00:16:34 <opqdonut> hmm? there should be an Arrow (,) -instance
00:16:44 <SubStack> my sequence prediction data structure finally grows correctly \o/
00:17:00 <SubStack> or so it would seem anyways
00:17:46 <SubStack> builds up patterns surprisingly quickly considering it's deriving statistics for all of the subsequences
00:20:25 <ManateeLazyCat> Thanks, all.
00:20:59 <Lex> Could anyone help me out please
00:22:01 <lokathor> string that takes only letters?
00:22:33 <mae> is it still true that if you don't use explicit import lists, ghc won't be able to efficiently split your objects?
00:22:40 <mae> and your executable will be larger?
00:23:12 <osfameron> it seems unlikely given how good the compiler is... doesn't it "know" which functions you actually ended up using?
00:23:26 <osfameron> I thought the reason for being specific was to avoid confusion/clashes later
00:23:51 <augustss> JohnMeacham: is it on hackage?
00:23:55 <pumpkin_> oh no
00:24:00 <pumpkin_> not that question
00:24:24 <augustss> It's a fair question to anyone making a release of any Haskell program.
00:24:36 <lokathor> Lex: from Data.Char use isLetter; lettersOnly = filter isLetter
00:25:05 <augustss> pumpkin_: Personally I've stopped installing things that are not on Hackage.
00:26:11 <pumpkin_> augustss: I know :) just being silly... I had understood that question was one of the reasons for LHC
00:26:53 <augustss> pumpkin_: So I heard, but people can change, so it was a serious question.
00:29:04 <Lex> How can I use int fgetc()?
00:29:52 <pumpkin_> write an FFI binding to it ;)
00:29:58 <pumpkin_> or just use the haskell interface
00:30:00 <lokathor> is that... a C thing? you'd have to use the Forign Function Interface if you want it exactly; if you just want input reading you can use getLine or some such
00:30:15 <augustss> Lex: don't
00:32:41 <wli> mmorrow: Still there?
00:32:54 <lokathor> lex: I suppose hGetChar might be more like what you want
00:33:58 <ertai_> Is there still no way in GHCi to import a module *qualified*?
00:35:50 <Lex> Well the purpose is to read one character at a time so im rquired to use either getchar or fgetc
00:37:20 <JohnMeacham> augustss: no, http://repetae.net/computer/jhc
00:37:31 <JohnMeacham> and there is a yum repository at http://repetae.net/yum
00:37:42 <lokathor> Lex: fgetc is written in C; you probably don't want to call C unless you already know what you're doing
00:38:10 <lokathor> use hGetChar or getChar instead
00:45:12 <jyaan> How do I provide the result of one function as the argument to another function?
00:45:18 <ManateeLazyCat> I see, (>>>) flip (.), "(+1) >>> (*2) $ 3" same as "(*2) . (+1) $ 3", alike (<<<) have same effect with (.)
00:46:27 <mmorrow> wli: yes
00:47:16 <mmorrow> JohnMeacham: cool
00:47:26 <wli> mmorrow: I've got a vague idea for a register windowing inspired 3AC IR that might get me off the ground wrt. branching.
00:48:17 <mmorrow> wli: there's this sweet lambdacalc evaluator "the shortest beta normalizer" that i found on that fplunch blog. it's handy, i'll paste
00:48:18 <ManateeLazyCat> Have difference between "<<<" and "." ? When time use "<<<" ? When time use "." ?
00:48:24 <wli> mmorrow: Also, the sad statement made by what little I've managed to do thus far will probably give you an idea of how stuck I am in far more basic issues.
00:48:41 <JohnMeacham> if anyone with fedora wants to test the yum repo, 'rpm -i http://repetae.net/yum/repetae-repo-1.0-3.noarch.rpm' should give you access to the repository, and then yum install 'jhc' should work. I hope to get an apt repository running too, but don't have much experience with that.
00:49:47 <mmorrow> wli: yeah, i didn't really get any sense of what i was doing/how to do it until i transcribed word-for-word this into code over a one+ week period: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.81.7841
00:49:49 <BONUS> ManateeLazyCat: . works on just functions, <<< works on more stuff
00:49:56 <BONUS> if you're composing functions, use .
00:50:14 <ManateeLazyCat> BONUS: I see, thanks.
00:50:31 <mmorrow> wli: then sat on it for a month, cleaned it up, then started from (almost) scratch. and here i am + 2 weeks into that.. :)
00:50:39 <JohnMeacham> the new features are that it comes with applicative and containers now, which are quite nice. and I added a lot of minor compatability fixes with ghc (like fixing some cases where pragmas were parsed slightly differently) so more code compiles 'out of the box'. in fact, containers is built from an unchanged darcs tree.
00:50:39 <wli> mmorrow: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1762#a1762
00:50:48 <mmorrow> JohnMeacham: oh nice, i have fedora
00:50:54 * mmorrow tries
00:51:50 <ManateeLazyCat> BONUS: "f >>> g $ h" same as "g (f (h))", >>> like sugar, use Math style is easier to understand >>>
00:52:51 <ManateeLazyCat> BONUS: <<< works on more stuff, can you write a simple example for describe "more stuff"?
00:52:56 <quicksilver> math style? british/american (i.e. the dominant style these days) writes functions in the order "g f"
00:53:06 <quicksilver> the french school used to use the "f g" style.
00:53:28 <quicksilver> unix pipes are "f g" of course.
00:53:42 <jyaan> I've seen both in school
00:53:54 <ManateeLazyCat> quicksilver: Yep, sometimes Haskell give me feeling like do mathematics than programming
00:54:46 <mmorrow> JohnMeacham: worked nicely :)
00:54:49 <mmorrow> [m@ganon ~]$ jhc -V
00:54:49 <mmorrow> jhc 0.5.20090304 (neopdoxhedvo-1)
00:55:06 <ManateeLazyCat> quicksilver: "f (h)" h is argument of function "f", and "f (h)" is argument of function "g", so i wrote "g (f (h))". :)
00:55:11 <JohnMeacham> cool. :)
00:55:43 <mmorrow> wli: sweet, reading ...
00:57:44 <wli> mmorrow: Well, that's far more aspirational than operational. The sort of thing I can actually write is at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1751
00:57:47 <mmorrow> wli: oh, interesting. i'm just about to the point where i have to do interprocedural stuff (doing intra-.. atm)
00:59:02 <BONUS> ManateeLazyCat: >>> works on arrows, not just functions
00:59:08 <BONUS> arrows are like functions, only more general
00:59:38 <BONUS> for instance an arrow from a to b can be anything that takes an a and produces a b, even a parallel computation or whatever
00:59:59 <ManateeLazyCat> BONUS: I see, now i'm studying what is arrow. :)
01:00:16 <wli> mmorrow: I don't really know what the deal is with interprocedural affairs. I'm sort of vaguely guessing.
01:00:17 <ManateeLazyCat> BONUS: Thanks for your explain!
01:00:42 <BONUS> hehe np, basically it's a typeclass that describes things that have input and an output. naturally, functions are in that typeclass
01:01:52 <ManateeLazyCat> BONUS: Haskell is so beautiful language..
01:02:11 <BONUS> thats so true :' )
01:02:32 <njouini> Hi
01:02:38 <BONUS> hi
01:02:39 <njouini> I'm a Haskell newb
01:03:00 <njouini> I've been reading some tutorials and getting pretty excited..
01:03:17 <njouini> Now I started to code some simple functions
01:03:46 <njouini> I'm pretty blocked because I cannot get one of my functions to work
01:03:54 <mmorrow> wli: it seems like while the graph algos you do with the graphs you make are a "science", how exactly you represent stuff is an "art" (in that from what i've seen everyone invents their own method)
01:03:54 <njouini> What I want is:
01:04:08 <njouini> a function that takes a list as an argument
01:04:17 <njouini> myFn [1,2,3,4]
01:04:33 <njouini> and returns another list [3,5,7]
01:04:57 <njouini> So I coded something like this:
01:05:16 <njouini> listSumL (x:y:ws) = (x+y) : listSumL (y:ws)
01:06:00 <njouini> I get an error:
01:06:08 <njouini> Non-exhaustive patterns in function listSumL
01:06:31 <njouini> I understand that this is due that I do not have a "termination clause" for my recursive function
01:06:36 <mornfall> njouini: What about listSumL []? :)
01:06:48 <mornfall> Well, [x].
01:06:51 <mornfall> Whatever.
01:07:05 <njouini> You mean: listSumL [x] = [x]
01:07:06 <njouini> ?
01:07:16 <wli> mmorrow: Well, this is only meant to faithfully represent things like condition codes getting set (more important for floating point than integer), quotient and remainder being simultaneously generated, high and low words of multiplication results getting generated, etc. In principle, one could toposort the straight-line code and spew macro-assembler garbage for it.
01:07:37 <mornfall> njouini: I don't really understand what you are trying to compute.
01:08:09 <njouini> given a list of [1,2,3,4] I want back a list of [3,5,7]
01:08:37 <njouini> so it's like add previous sum previous
01:08:47 <mornfall> njouini: \x -> zipWith (+) x (tail x)
01:08:49 <njouini> I understand it's a bit like fibonacci
01:09:07 <njouini> mornfall: Yeah but I do not want to use zipWith
01:09:13 <mornfall> Why?
01:09:39 <njouini> Since I'm trying to lear why my approach is wrong.
01:09:44 <mmorrow> wli: you'd also have to do register allocation
01:09:46 <njouini> And results in an error.
01:10:28 <mmorrow> wli: unless you deal with (real) registers explicitly in your ast..
01:10:40 <mornfall> njouini: You already know that, no? (See above.)
01:10:46 <njouini> No?
01:11:00 <njouini> No I do not know why my function does not work correctly.
01:11:02 <mornfall> Where's your listSumL [x]?
01:11:17 <njouini> listSumL (x:y:ws) = (x+y) : listSumL (y:ws)
01:11:17 <njouini> listSumL [x] = [x]
01:11:23 <mornfall> That's not going to work.
01:12:08 <wli> mmorrow: Probably, yeah. I'm just hoping to not have to do divisions twice to get both quotient and remainder and crud like that.
01:12:11 <mornfall> In [1,2,3,4] -> [3,5,7] there's no 4 in the result...
01:12:21 <njouini> Yes
01:12:31 <njouini> And I want to get rid of it :)
01:12:35 <mornfall> ...
01:12:42 <mornfall> Well, think about it for a second. :)
01:13:02 <mmorrow> wli: another convenient thing that seems to be used in more than a few places is to have a datatype
01:13:05 <njouini> I did.
01:13:07 <pumpkin_> anyone know of a good program for displaying cepsotrgrams of signals?
01:13:08 <njouini> The problem is:
01:13:32 <mornfall> > let s (x:y:ys) = x+y:s (y:ys); s [x] = []; in s [1,2,3,4]
01:13:33 <lambdabot>   [3,5,7]
01:13:35 <njouini> Either a: I can code it the way that it calculates correctly but dies in the end
01:13:55 <mmorrow> data Prim = Asm Name Arity [Instr] | Call Name Arity
01:14:00 <wli> FE_INVALID/FE_DIVBYZERO/FE_OVERFLOW/FE_UNDERFLOW bits in the FPU control word.
01:14:34 <mmorrow> then, you can treat hand-coded primitive functions in the same way that you treat arbitrary calls
01:14:34 <wli> mmorrow: What's that the type for?
01:14:49 <mmorrow> so then you can have a huge
01:14:54 <mmorrow> prelude :: [Prim]
01:15:01 <wli> Okay, yeah.
01:16:00 <mmorrow> the really nice thing though, is that then in your ast you have  ... | Call Prim [Exp] | ....
01:16:17 <wli> mmorrow: The division case can probably be punted on like that. More awkward things like condition codes in the FPU and/or ALU are another story.
01:16:57 <mmorrow> wli: ah, yeah. those seem like a total pita.
01:18:00 <njouini> mornfall: Thanks.
01:18:11 <njouini> This was just what I was looking for.
01:18:30 <njouini> Now this thing leads us to next question.
01:18:30 <wli> mmorrow: I vaguely wanted predication in the IR to artificially lengthen basic blocks, but there is some weirdness with undefined temporaries.
01:18:43 <njouini> s [x] = []
01:19:07 <njouini> I want to print value of x when this funciton gets called
01:19:20 <wli> mmorrow: The condition codes make a lot of sense there.
01:19:56 <njouini> So I whould write
01:20:07 <njouini> s [Ã—] = print x; []
01:20:28 <njouini> But that whould not work.
01:20:39 <osfameron> njouini: Debug.Trace.trace
01:20:44 <ManateeLazyCat> Someone show me the simple example for "first" ? I mean "first" in Control.Arrow
01:21:09 <njouini> osfameron: What is it and how is it used?
01:21:29 <pumpkin_> > first f (a, b) :: (Expr, Expr)
01:21:30 <lambdabot>   (f a,b)
01:21:35 <pumpkin_> ManateeLazyCat: ^^
01:21:38 <Peaker> osfameron: import Debug.Trace ; s [x] = trace ("x = " ++ show x) []
01:21:42 <Peaker> oops
01:21:45 <Peaker> njouini: ^
01:21:52 <njouini> Thanks!
01:21:55 <ManateeLazyCat> pumpkin_: Thanks!
01:22:25 <pumpkin_> np :)
01:23:21 <wli> mmorrow: There is more weirdness because the underlying machines don't cleanly break up control vs. computation, e.g. ARM predication makes arbitrary computations conditional.
01:24:08 <wli> cmov on x86 is most of where that hurts there.
01:24:09 <njouini> Now this is cool
01:27:07 <njouini> Haskell is great.
01:27:13 <njouini> It has tought me so much.
01:27:21 <Lemmih> JohnMeacham: Congrats on the new release.
01:27:39 <njouini> For me recursion was really hard to understand until I played with Haskell
01:27:48 <ManateeLazyCat> first (*3) (1, 2)   => (3, 2), I see, just apply function (*3) to the *first* element, great.
01:27:49 <kmeyer> really?
01:27:58 <kmeyer> recursion is just a general purpose loop, with a stack
01:28:12 <BONUS> i wouldn't say that
01:28:23 <jyaan> I like it so far
01:28:34 <quicksilver> the recursion in merge sort isn't much like a loop.
01:28:36 <jyaan> I've never really done functional programming before either
01:28:57 <kmeyer> quicksilver: the recursion in merge sort is exactly like a loop, actually.
01:29:02 <kmeyer> iterative merge sort is trivial
01:29:09 <BONUS> i'd say that recursion is a way of solving a problem by expressing it as results of subproblems until the subproblem is trivial and then building it up from that
01:29:34 <kmeyer> BONUS: yup.
01:29:35 <BONUS> it can be implemented with a loop and a stack or whatever, but it doesn't need a computer at all
01:29:41 <quicksilver> kmeyer: how is it exactly like a loop?
01:29:41 <kmeyer> right
01:29:50 <quicksilver> BONUS: that's well-founded recursion - not all recursion is well founded.
01:29:55 <quicksilver> at least, not in haskell.
01:29:57 <BONUS> ah
01:30:14 <kmeyer> quicksilver: loop as size of the chunk you're merging increases from 1 to powers of 2 until the chunksize is larger than the set size.
01:30:27 <kmeyer> then merge each chunk of that size.
01:30:38 <quicksilver> but that isn't what the program looks like
01:30:44 <quicksilver> that's a non-trivial transformation on the program
01:30:48 <quicksilver> which assumes an evaluation order.
01:31:06 <quicksilver> the recursive defintion of merge sort can easily choose to descend down one side completely before starting on the other side.
01:31:23 <kmeyer> sure, the order is arbitrary and doesn't matter
01:31:25 <kmeyer> which is the point
01:31:43 <quicksilver> but the recursion pattern in the obvious recursive definition of merge sort is, itself, nothing like a loop
01:31:52 <pumpkin_> BONUS: how about ackermann's function?
01:31:58 <quicksilver> it is depth-first traversal with backtracking
01:32:04 <pumpkin_> it does eventually stop recursing, but I'm not sure I'd call it "subproblem"
01:32:06 <kmeyer> right, which is a loop + a stack
01:32:14 * quicksilver shrugs
01:32:28 <quicksilver> I think you've just redefined loop to mean what you want it to mean.
01:32:29 <BONUS> ackerman's isn't primitive recursive but it's still recursive
01:32:37 <BONUS> if that's what you mean
01:32:45 <ManateeLazyCat> I type ":t first" got "first :: (Arrow a) => a b c -> a (b, d) (c, d)", this describe is simple, how do i know what is "b" or "c"?
01:32:58 <ManateeLazyCat> I just know "a" is arrow.
01:33:06 <ManateeLazyCat> Have any tips?
01:33:22 <BONUS> (Arrow a) => a b c means: arrow from b to c
01:33:26 <JohnMeacham> Lemmih: is the lhc project pulling patches from the jhc repo at all? I debated a while the best way to collaborate, there were some useful patches in the lhc repository I wanted but was still darcs 1.0 so couldn't. I figured it wouldn't be very good form to replicate other peoples patches directly then check them in myself so switched jhc to darcs 2 format to make things easier.
01:33:29 <pumpkin_> BONUS: yeah, was just wondering if you'd call it a "subproblem" in that case
01:33:39 <BONUS> if that a takes the form of a function then it's b -> c
01:33:48 <kmeyer> quicksilver: maybe so, but
01:33:56 <kmeyer> I see loops/recursion as very similar things
01:34:13 <doserj> ManateeLazyCat: a,b,c are universally quantified type variables. they can be anything
01:34:14 <BONUS> yeah hmm i'd really have to think on how to define recursion as best as possible, it's trickier than it sounds :)
01:34:19 <kmeyer> often recursion is a lot easier way of expressing a problem
01:34:37 <BONUS> doserj: of course, a must be an arrow
01:34:45 <doserj> BONUS: sure
01:34:48 <kmeyer> BONUS: just define it in terms of stack frames :D
01:35:00 <BONUS> hehe
01:35:05 <quicksilver> BONUS: recursion is finding the least-fixed-point (if it's well-founded)
01:35:07 <doserj> ManateeLazyCat: how do you know what a is in head::[a] -> a?
01:35:08 <ManateeLazyCat> BONUS: So in "first (*3) (1, 2)", "a" is "(*3)" b is "(1, 2)" and c is result "(3, 2)"?
01:35:13 <quicksilver> or actually, even if it's not
01:35:32 <quicksilver> whether or not you consider that useful as a 'definition' is a matter of taste.
01:35:40 <BONUS> yeah hmm
01:35:45 <quicksilver> you could argue it's a description, or even an implementation, rather than a definition.
01:35:59 <Lemmih> JohnMeacham: We pulled some of your tags, I think. SamB knows more about it.
01:36:05 <Saizan> ManateeLazyCat: no, a, b, and c are types
01:36:55 <BONUS> ManateeLazyCat:  if you take the general type Arrow a => a b c -> a (b, d) (c, d) and translate a into a function, then it's (b -> c) -> (b, d) -> (c, d)
01:37:05 <BONUS> s/translate/constrain
01:37:09 <pumpkin_> can someone show me an example the Kleisli instance of Arrow? I know it means you can make "monad arrows" but am not sure how that works
01:37:16 <JohnMeacham> I am not sure how much longer they will be enough in sync that patches pull cleanly. and I realized afterwords that we did a big darcs no-no by doing two seperate conversions of a darcs 1 to darcs2 repository then trying to share patches. but apparently it worked out.
01:37:19 <kmeyer> quicksilver: I don't mean to pretend I'm some kind of expert, but the typical CS undergrad fare I get assigned has questions like "turn this recursive function into a loop" (or vice versa) and it always seems pretty easy.
01:37:25 <Peaker> a, b, c can be anything of kind *, not quite anything at all
01:37:33 <BONUS> pumpkin: Kleisli (replicate 10)
01:37:36 <BONUS> :t replicate 10
01:37:37 <lambdabot> forall a. a -> [a]
01:37:46 <BONUS> :t Kleisli (replicate 10)
01:37:48 <lambdabot> forall a. Kleisli [] a a
01:37:53 <Saizan> pumpkin_: it's the arrow where >>> == >=>
01:37:55 <doserj> in that example, a is Num a => a -> a, b is Num a => a, c is Num a => a, and d is Num b => b
01:38:37 * doserj likes to reuse variable names to confuse people
01:39:15 <pumpkin_> hmm
01:39:22 <pumpkin_> any examples of where it's useful?
01:39:23 <dolio> > let foldN z s 0 = z ; foldN z s (n + 1) = s $ foldN z s n ; ack = foldN (+1) (\f -> foldN (f 1) f) in (ack 3 0, ack 3 1, ack 3 2, ack 3 3, ack 3 4)
01:39:25 <lambdabot>   (5,13,29,61,125)
01:40:32 <JohnMeacham> I have almost 60% coverage of nobench now, which is good. and I know most failures are due to missing libraries (mainly array related) that I can fill in. too bad the array classes are multiparameter.... it does make things tricky. I need an intermediate GC between the boehm one and 'none'. boehm is dog slow, but does get fully working binaries in the end so is useful as a benchmark.
01:40:38 <Saizan> pumpkin_: ever written code like (foo =<<) . (bar =<<) $ x ?
01:40:46 <ManateeLazyCat> Thanks, all. But "a" "b" "c" is always confuse Haskell newbie..
01:41:14 <pumpkin_> Saizan: a bit, yeah
01:41:34 <pumpkin_> so >=> "composes" foo and bar like that
01:42:11 <Saizan> right, foo <=< bar = (foo =<<) . bar
01:42:14 <dolio> > let foldN z s 0 = z ; foldN z s (n + 1) = s $ foldN z s n ; ack = foldN (+1) (\f -> foldN (f 1) f) in ack 4 1
01:42:15 <pumpkin_> and succinct examples of actually using it in an arrow context?
01:42:29 <lambdabot>   thread killed
01:42:32 <pumpkin_> just trying to understand what the generality of arrow buys you there
01:43:10 <Saizan> not much, really
01:43:13 <Lemmih> JohnMeacham: Did we see we changed the way type-classes are handled? There were some problems with the way the rules were generated.
01:43:20 <BONUS> afaik people haven't gotten any real world use of Kleisli
01:43:26 <BONUS> usually >=> is enough
01:43:34 <pumpkin_> ah
01:43:52 <BONUS> i've been thinking about if monad transformers inside kleisli arrows might work
01:44:01 <Saizan> well, unless you count HXT :)
01:44:12 <pumpkin_> so would it be correct to say that about 99.9% of real-world Control.Arrow use is first/second/&&&/***, on the -> instance?
01:44:15 <JohnMeacham> Lemmih: yeah, I fixed some bugs related to that as part of this release too. but I think it was via a completely independent method to what you did.
01:44:29 <BONUS> pumpkin_: i'd say so yeah
01:44:39 <Saizan> pumpkin_: if #haskell golfing is real world..
01:44:42 <BONUS> i dont know about 99.9%, but a major part, yes
01:44:59 <pumpkin_> if functionality were ordered, what would be next after those four?
01:45:00 <JohnMeacham> but ultimately fixing the same issues. They were the ones brought up by Control.Arrow and friends right? instances involving (->)?
01:45:02 <doserj> maybe the occasional user of hxt, or some arrow-based frp also
01:45:07 <pumpkin_> ArrowChoice use?
01:45:30 <dolio> >>> is useful with those other combinators.
01:45:37 <pumpkin_> ah yeah
01:45:39 <dolio> Since it has different precedence than (.).
01:45:43 <pumpkin_> I thought that came from a different module though
01:45:58 <dolio> So you can write stuff like "f . g *** h . i >>> j *** k"
01:46:03 <dolio> And confuse the hell out of people.
01:46:06 <pumpkin_> lol
01:46:09 <pumpkin_> my ultime goal :D
01:46:12 <BONUS> > first (Kleisli (replicate 10 . map show)) (2,3)
01:46:13 <lambdabot>   Couldn't match expected type `(t1, t2) -> t'
01:46:28 <BONUS> > runKleisli (first (Kleisli (replicate 10 . map show))) (2,3)
01:46:30 <lambdabot>       No instance for (Num [a])
01:46:30 <lambdabot>        arising from the literal `2' at <inter...
01:46:38 <BONUS> eh, nvm
01:47:36 <pumpkin_> just goes to show how obscure it all is :P
01:48:02 <JohnMeacham> Lemmih: I now ship applicative (Control.Arrow, etc) as standard with jhc, so hopefully those bugs won't creep back. (->) as a first class type brings up some odd corner cases in the code.
01:48:42 <wli> My mergesort thought is chunk n = unfoldr (\xs -> let (ys, zs) = splitAt n xs in if null ys then Nothing else Just (ys, zs)) ; merge (x:xs) (y:ys) | x <= y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys ; merge [] ys = ys ; merge xs [] = xs ; mergeSort xs = mergeSort' $ map return xs ; mergeSort' [] = [] ; mergeSort' [x] = x ; mergeSort' xs@(_:_:_) = mergeSort' . map (foldr1 merge) $ chunk 2 xs
01:55:40 <wli> I have no idea if that's considered reasonable.
01:56:26 <dolio> It's better to find increasing/decreasing runs instead of arbitrarily selecting size-2 chunks.
01:56:38 <dolio> But other than that.
01:57:07 <wli> It starts with size 1 chunks, and groups pairs of lists to merge from there.
01:57:16 <dolio> I think that change still hasn't been pushed into GHC.
01:57:30 <JohnMeacham> last time I tried to write a new garbage collector for jhc I ended up writing a full scheme interpreter to test my garbage collector... hmm...
01:57:35 <dolio> Despite there being a thread about how YHC's merge sort was way better a while ago.
01:57:43 <wli> I'm not sure how to find increasing and decreasing runs.
01:58:00 <pumpkin_> is that how timsort works?
01:58:09 <dolio> Well, it does that, among other things.
01:58:24 <dolio> The other things wouldn't be as useful for lists, though.
01:59:57 <pumpkin_> ah
02:01:44 <pumpkin_> can't find anything to draw a cepstrogram, can anyone think of another name for it?
02:01:56 <dolio> Well, it also has a minimum chunk size, which you could use with lists, I suppose. But I don't know how much more efficient an insertion sort is than a merge sort for very small lists.
02:03:25 * wli tries to think of how to break up a list into increasing and decreasing runs.
02:03:27 <dolio> It probably doesn't have the same benefits.
02:03:49 <pumpkin_> wli: take the derivative!
02:04:00 <pumpkin_> :P
02:04:09 <JohnMeacham> I have wondered whether a 3 way mergesort would be more efficient. a lot of these divide and conquer algorithms have a sweet spot around 'e' which is 2.718... I don't know if mergesort is one of them... perhaps 2-3 finger trees or something...
02:04:28 <weilawei> hi! im working through the exercises in RWH and I've got some code and an error I can't figure out how to fix (it's a type error, shouldn't be anything major, I hope): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2115
02:04:31 <njouini> mornfall: I ran to another problem.
02:05:11 <pumpkin_> weilawei: you're unzipping a list of non-pairs
02:05:24 <pumpkin_> oh actually
02:05:25 <weilawei> pumpkin_: thats not what the error refers to
02:05:55 <pumpkin_> yeah, I didn't look closely enough and the lines don't match up?
02:05:58 <pumpkin_> :P
02:06:04 <weilawei> I also don't know how to write a proper type signature for coTan and crossProduct
02:06:06 <weilawei> they do actually
02:06:13 <pumpkin_> oh I see
02:06:17 <pumpkin_> I just fail :)
02:06:22 <JohnMeacham> looks like someone already thought about it for heapsort at least http://en.wikipedia.org/wiki/Heapsort#cite_note-1
02:06:28 <quicksilver> kmeyer: sure, it's always easy but "it's easy to turn A in to B" is not the same statement as "A is the same thing as B". I don't dispute that loops and recursion are equally expressive, for example.
02:06:56 <kmeyer> ok, maybe my statement was too strong
02:07:56 <weilawei> pumpkin_: it's okay.. this is my second night seriously tackling more than a few lines of Haskell at a time (been building up to it!) so im in the dark myself
02:08:16 <pumpkin_> weilawei: I think it is related to what I said earlier actually
02:08:43 <weilawei> well i want to unzip a list of tuples, where the fst is a Point2D and the snd is a MyDirection
02:09:03 <weilawei> validPointsOf should return a list of such tuples
02:10:15 <pumpkin_> hmm
02:10:21 <dolio> > let run _ _ [] = ([],[]) ; run p x (y:ys) | x `p` y = first (y:) $ run p y ys | otherwise = ([],y:ys) ; slice [] = Nothing ; slice [x] = Just ([x],[]) ; slice (x:y:zs) | x < y = Just . first (x:) $ run (<=) y zs | otherwise = Just . first (reverse . (x:)) $ run (>=) y zs in unfoldr slice $ [1..10] ++ [10,9..1] ++ [1..5] ++ [1..5]
02:10:22 <lambdabot>   [[1,3,4,5,6,7,8,9,10,10],[1,1,2,3,4,5,6,7,9],[2,4,5],[1,3,4,5]]
02:10:32 <dolio> Well, that's not quite right.
02:11:38 <pumpkin_> weilawei: maybe MyStraight -> (fst x) : validPointsOf xs ?
02:11:48 <pumpkin_> and so on
02:11:51 <dolio> > let run _ _ [] = ([],[]) ; run p x (y:ys) | x `p` y = first (y:) $ run p y ys | otherwise = ([],y:ys) ; slice [] = Nothing ; slice [x] = Just ([x],[]) ; slice (x:y:zs) | x < y = Just . first ((x:) . (y:)) $ run (<=) y zs | otherwise = Just . first (reverse . (x:) . (y:)) $ run (>=) y zs in unfoldr slice $ [1..10] ++ [10,9..1] ++ [1..5] ++ [1..5]
02:11:52 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,10],[1,1,2,3,4,5,6,7,8,9],[2,3,4,5],[1,2,3,4,5]]
02:12:04 <wli> whoa
02:12:09 <wli> That's hard.
02:12:37 <pumpkin_> weilawei: in general, I'd encourage you to put a type signature on validPointsOf too, as it'll happily assume a type you don't intend and generate a type error elsewhere (not sure if that's the problem here though)
02:12:54 <weilawei> pumpkin_: how do I do that inside the function?
02:13:03 <weilawei> im -really- new to haskell
02:13:08 <pumpkin_> same syntax as outside
02:13:13 <weilawei> just dump it right in there?
02:13:15 <pumpkin_> but try the (fst x) : validPointsOf xs
02:13:16 <pumpkin_> yeah
02:13:30 <pumpkin_> you don't actually need the parens there I don't think
02:14:05 <njouini> Hey, How do I write a function like this: fun (x > 3) = 3
02:14:21 <njouini> So I want the patter matcher to match anything bigger thatn 3
02:14:22 <pumpkin_> fun x | x > 3 = 3
02:14:31 <njouini> What does the | mean?
02:14:35 <pumpkin_> it's a guard
02:14:41 <pumpkin_> you can put any boolean expression after it
02:14:47 <wli> Read it as "such that."
02:14:49 <njouini> Okay.
02:15:01 <wli> fun x such that x is greater than 3 equals 3
02:15:21 <quicksilver> I read it as "when"
02:15:28 <pumpkin_> I read it as where
02:15:33 <njouini> But wait: Am I "messing up" my design when I include too much logic to pattern matching.
02:15:34 <pumpkin_> who has a "who"?
02:15:41 <quicksilver> fun x | x > 3 = 3 | x < 1 = 1 | otherwise = 2
02:16:01 <quicksilver> "when x is greater than three, then 3; when x is less than one ...
02:16:44 <njouini> It seems to be easier to write function which utilize patter matcing as much as possible but is there a catch?
02:17:12 <weilawei> pumpkin_: okay i took out to fst unzip, changed it to fst x and added a type signature
02:17:16 <weilawei> but im still at the same issue
02:17:40 <ManateeLazyCat> Someone show simple example for (***) ? Thanks again. :)
02:17:40 <pumpkin_> why take out fst unzip?
02:17:46 <pumpkin_> oh
02:17:46 <weilawei> pumpkin_: because it's no longer needed
02:17:47 <pumpkin_> I see
02:18:01 <dolio> > succ *** pred $ (1,1)
02:18:02 <lambdabot>   (2,0)
02:18:06 <pumpkin_> > f *** g $ (a, b) :: (Expr, Expr)
02:18:07 <lambdabot>   (f a,g b)
02:19:19 <ManateeLazyCat> Oh, changed sequence...
02:19:21 <weilawei> i also like how easy it is to rip out blocks of code and shuffle them around ^__^
02:21:31 <ManateeLazyCat> In "(***) :: (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')", what is b' or c'? Confusion..
02:22:46 <weilawei> pumpkin_: oh major duh
02:22:56 <njouini> Hmmm....
02:22:59 <weilawei> im trying to concatenate to something that's a MyDirection not a list
02:23:11 <njouini> Based on my studies Haskell is almost too good to be true.
02:23:18 <weilawei> njouini: im agreeing
02:23:22 <njouini> It's like writing math but for computer.
02:23:34 <weilawei> okay, im not much on math, but this is fantastically elegant
02:23:47 <weilawei> i keep reminding myself not to overcomplicate things
02:23:52 <njouini> Example: I looked http://en.wikipedia.org/wiki/Fibonacci_numbers
02:24:06 <njouini> Okay, there was a definition of fibonacci functions
02:24:12 <njouini> *function
02:24:15 <pumpkin_> lol
02:24:22 <njouini> I just wrote it in haskell
02:24:24 <pumpkin_> weilawei: glad you got it :)
02:24:26 <njouini> And it worked
02:24:31 <pumpkin_> weilawei: I'm braindead, wanna go to sleep :(
02:25:00 <weilawei> pumpkin_: me too... but that didnt actually solve it
02:25:01 <njouini> Hmm... This leads me to another subject
02:25:06 <weilawei> it fixed it in the interpreter xD in theory..
02:25:16 <njouini> I can make it do my math homework...
02:25:33 <pumpkin_> @faq can haskell do njouini's math homework?
02:25:33 <lambdabot> The answer is: Yes! Haskell can do that.
02:26:16 <njouini> It feels so easy.. Almost like cheating.
02:26:28 <pumpkin_> and it can be wicked fast too
02:26:36 <quicksilver> homework is easy. Life is cheating.
02:27:09 <weilawei> quicksilver: what about doing hard homework so life is easy?
02:30:26 <ManateeLazyCat> How do you know write correct code just see ":type" output? Example, "first" write front, but "***" write second. Confusion....
02:30:32 <njouini> Hmm.. Can I answer in Haskell to math exam?
02:31:01 <weilawei> @faq can njouini use haskell on his math exam?
02:31:02 <lambdabot> The answer is: Yes! Haskell can do that.
02:31:20 <njouini> @faw how dows faq work?
02:31:20 <lambdabot> The answer is: Yes! Haskell can do that.
02:31:23 <njouini> :D
02:31:30 <njouini> @faq how dows faq work?
02:31:30 <lambdabot> The answer is: Yes! Haskell can do that.
02:31:37 <weilawei> @ how
02:31:39 <weilawei> @f how
02:31:39 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune fptools free freshname ft . ? @ bf v
02:31:41 <weilawei> @fa how
02:31:41 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber ft
02:31:44 <weilawei> aha...
02:31:52 <weilawei> DSL written in haskell for the chan?
02:31:57 <pumpkin_> faq = const "Yes! haskell can do that"
02:51:41 <wli> It's a bit nightmarish, but my solution to the run problem is:
02:52:12 <wli> It doesn't fit in the maximum line length. :(
02:59:57 <wli> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1767#a1767
03:00:46 <wli> Probably better to use some kind of monad.
03:01:57 <pumpkin_> wli: your sleep schedule seems as bad as mine
03:02:21 <wli> I'm having trouble I need to keep watch over.
03:08:22 <pumpkin_> I hate badly designed libraries
03:10:31 <HugoDaniel> pumpkin_: in haskell ?
03:10:40 <pumpkin_> in general
03:12:47 <rabideejit> Hello.  I'm having a bit of trouble with regular expressions.  How do I get posix regular expressions to return [ String ]?  Real World Haskell suggests to do something like "I, B. Ionsonii, uurit a lift'd batch" =~ "(uu|ii)" :: [String]  but that comes up with a type error --- even in the book.
03:16:25 <weilawei> still not havin any luck: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2117#a2118
03:16:35 <weilawei> any ideas pumpkin_? or are you off to bed?
03:16:39 <nanothief> rabideejit, the REal world haskell stuff is a little out of date, use [[String]] instead
03:16:56 <pumpkin_> unfortunately not to bed yet :/
03:16:57 <pumpkin_> :P
03:16:59 <temoto-wd> uhm... i've read wiki "Dependant types" but.. could anyone explain it a bit simplier, like no math background?
03:16:59 <rabideejit> ok, hankyou
03:17:08 <pumpkin_> temoto-wd: types that depend on values
03:17:08 <ivanm> weilawei: what are you trying to do?
03:17:39 <weilawei> ivanm: complete the last exercise in chapter 3 of RWH, which is to find the set of points that lie on a convex hull
03:18:00 <temoto-wd> pumpkin_: yeah... but that's not really substantive. I don't get the idea.
03:18:04 <weilawei> the code + error are in that paste
03:18:08 <rabideejit> weilawei: your coTan uses /, which expects fractional arguments
03:18:15 <rabideejit> you need to fromIntegral probably
03:18:17 <ivanm> weilawei: are the line numbers in your first paste accurate?
03:18:20 <weilawei> yes
03:18:29 <ivanm> ahhh, _there's_ coTan
03:18:36 <temoto-wd> pumpkin_: like isn't Maybe monad a dependant type?
03:18:52 <ivanm> weilawei: as rabideejit said, your Point2D is using Ints, when it should probably be Doubles
03:18:55 <pumpkin_> temoto-wd: it's more like being able to delcare a list of a fixed length
03:18:59 <weilawei> would that fix it all?
03:19:02 * ivanm isn't familiar with the RWH exercises
03:19:04 <ivanm> weilawei: it should do
03:19:06 <pumpkin_> and have the type system prevent you from adding to it beyond that length
03:19:18 <ivanm> weilawei: since you can't divide two integers (though there is div for that)
03:19:18 <weilawei> wow
03:19:20 <weilawei> it fixed it
03:19:23 <ivanm> @type (/)
03:19:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
03:19:29 <ivanm> @instances Fractional
03:19:30 <lambdabot> Double, Float
03:19:31 <ivanm> weilawei: ^^
03:19:32 <weilawei> i've been hacking away at this for like 2 hours on this last problem
03:20:04 <temoto-wd> pumpkin_: oh well... isn't it basic bound checking done in all interpreted languages?
03:20:19 <pumpkin_> temoto-wd: bounds checking at compile time?
03:20:25 <nanothief> rabideejit, I made a few regex notes of my own, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1768#a1768 if your interested
03:20:46 <weilawei> thank you ivanm, rabideejit, and pumpkin_
03:20:53 <rabideejit> cheers nanotheif
03:20:53 <temoto-wd> pumpkin_: so dependant types allow compile with bounds checking?
03:21:02 <ivanm> no worries ;-)
03:21:03 <pumpkin_> temoto-wd: that's just one example
03:21:07 <temoto-wd> pumpkin_: sure.
03:21:18 <pumpkin_> but something like that, I think
03:21:28 <pumpkin_> I'm a newbie myself so I can't speak authoritatively
03:21:34 <pumpkin_> :)
03:21:48 <temoto-wd> pumpkin_: but then, if value is unknown at compile time, dependant types uh.. do nothing?
03:21:50 <weilawei> so I have a style question.. is it best to put all your type declarations in one spot, say up top?
03:21:58 <weilawei> or do people put them right above the function
03:22:14 <pumpkin_> temoto-wd: nope, that's the point (if I understand correctly)
03:22:25 <pumpkin_> temoto-wd: you can approximate the "known-at-compile-time" situation in haskell
03:22:30 <Cale> weilawei: always immediately before each function definition
03:22:32 <temoto-wd> pumpkin_: so they add runtime checking then?
03:22:32 <pumpkin_> with things like peano numbers in the types
03:22:43 <weilawei> Cale: could you explain why? im very new to this
03:23:04 <temoto-wd> weilawei: style is not a matter of "why" :)
03:23:17 <pumpkin_> temoto-wd: I think it's more like a compile-time "proof" that the index will never exceed the bounds in that example
03:23:19 <Cale> weilawei: Well, it's important documentation, and helps you to write the function.
03:23:20 <pejo> temoto-wd, Suppose you're appending two lists, one of length n and the other of length m. Then the length of append list1 list2 should be (n+m).
03:23:36 <rabideejit> cheerio all
03:23:44 <Cale> weilawei: and helps someone who is reading the code to read that function
03:23:53 <weilawei> temoto-wd: sure it is! i indent the way i do because i believe it to be more readable. now you can answer the question "Why does weilawei indent the way he does?"
03:24:00 <pejo> temoto-wd, so you prove that append given two lists of length m and n then returns a list of length (m+n).
03:24:09 <Cale> weilawei: It's pretty much the same reason you put comments about each function near the function definition too.
03:24:26 <weilawei> Cale: mmkay cool. and there are doc tools to yank all my type definitions out?
03:25:06 <temoto-wd> weilawei: from python i learned to indent "compatible way", "mainstream way". Though i'd prefer tabs.
03:25:27 <Cale> weilawei: Yes, along with specially marked boxes^H^H^H^H^H comments. Haddock will produce HTML documentation automatically.
03:25:36 <weilawei> temoto-wd: i came from python, but i already had an indenting style that was compatible with it when i went to python (from C/C++)
03:25:54 <temoto-wd> weilawei: cool :)
03:25:54 <weilawei> so haskell doesn't bother me in the least wrt indentation. it's nice
03:26:16 <weilawei> isn't there something about haskell not liking tabs?
03:26:20 <Cale> weilawei: Just make sure you indent with spaces and not tabs.
03:26:23 <weilawei> not that I use anything but spaces in my own code
03:26:28 <temoto-wd> pejo: but haskell doesn't have dependant types, right?
03:26:51 <Cale> The compiler says tabs always align to the next 8-space boundary, editors don't always do that.
03:27:01 <weilawei> oh yeah.. i like 4 space "tabs"
03:27:04 <Cale> and vertical alignment matters
03:27:28 <mmorrow> JohnMeacham: haha, yeah when i try to test out various gc experimentation of mine i always end up writing a (new each time, half-assed, not really "working") "lisp" interpreter
03:27:29 <Cale> So if you start putting tab characters in, things can get confusing quickly.
03:27:44 <pumpkin_> wow, mmorrow and Cale have crazy sleep hours too
03:27:44 <temoto-wd> what a nasty compiler... isn't it configured to use 4-space tabs?
03:27:49 <weilawei> but i actually kinda fudge things to whatever looks best xD so a lot of my code isn;t even on tab stop[s
03:27:49 <Cale> pumpkin_: heh
03:28:02 <Cale> pumpkin_: I might just try to stay awake today...
03:28:02 <mmorrow> pumpkin_: :)
03:28:10 <pumpkin_> I'm considering it too
03:28:19 <Cale> I was caught up studying Japanese...
03:28:24 <Cale> I can't stop :)
03:28:25 <weilawei> but if i needed to deal with it... each tab would count for up to the next 8 space tabstop per tab
03:28:32 <pumpkin_> hah
03:28:38 <pumpkin_> Cale: how long you been studying?
03:28:59 <Cale> Well, I've been studying pretty intensely for the last few weeks now.
03:29:00 <mmorrow> temoto-wd: ghc interprets tabs as commands to delete certain crucial rts header files
03:29:18 <pumpkin_> Cale: if it's self-taught, and you really want to learn the kanji well, you should try heisig :)
03:29:32 <Cale> I know about 600 kanji or so.
03:29:33 <pejo> temoto-wd, well, you can do funky stuff through extensions, but it doesn't feel like you're programming in Agda for example. (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level uses a whole slew of extensions).
03:29:56 <Cale> I actually really like learning kanji. :)
03:30:23 <pumpkin_> Cale: the heisig goal is to learn all the jouyou kanji :) a friend of mine did it in 6 months (obviously for a restricted definition of learn). it's an interesting approach
03:30:27 <pumpkin_> I love the kanji as well
03:30:32 <pumpkin_> one of my favorite aspects of learning the language
03:30:54 <Cale> and I certainly can't read stuff which is all written in kana. It's too hard to parse.
03:30:56 <mmorrow> wli: yeah, that's cool how arm instructions have that conditional prefix thing
03:31:03 <fasta> Does anyone know how with the kuribas indentation mode, starting from an empty module one can insert module Foo (module Bar, module Zork) where import Bar <newline> import Zork (the only requirement is that there are newlines between the module exports and and that C-o is not used)?
03:31:30 <temoto-wd> pejo: but still in haskell, compiler will optimize "append", right?
03:32:48 <pumpkin_> Cale, anyway, if you're interested, check out http://www.nanzan-u.ac.jp/SHUBUNKEN/publications/miscPublications/pdf/RK4/RK4-00.pdf (and the book it's from on amazon)
03:33:30 <pejo> temoto-wd, I came in when you were asking about dependent types; I'm not sure what you mean by that question?
03:34:29 <Cale> Yeah, I've heard Heisig is good.
03:42:27 <temoto-wd> pejo: i'm trying to understand what's so good in dependant types that can't be done in transparent compiler optimizations. So far i see them very close.
03:42:57 <temoto-wd> Probably that's because i don't have deep understanding what dependant types are.
03:43:35 <pumpkin_> it's not necessarily an optimization thing
03:43:57 <pumpkin_> it's allowing you to take type safety to the "next level"
03:45:33 <pejo> temoto, your optimizations can not prove that append returns a list of length m+n given input of m+n normally.
03:46:01 <temoto-wd> pejo: why need prove?
03:46:03 <pejo> temoto, nor do your optimizations prove that sort actually returns a sorted list.
03:46:16 <pumpkin_> temoto-wd: for safety
03:46:18 <temoto-wd> Isn't unit testing for proofs?
03:46:35 <pumpkin_> temoto-wd: unit testing is what one does in the absence of formal correctness proofs
03:46:38 <temoto-wd> Is dependant types like self-testing code?
03:46:42 <pejo> temoto, dependent types are normally used for statically ensuring safety properties of your program.
03:47:07 <temoto-wd> Like this even can't go wrong?
03:47:19 <pumpkin_> temoto-wd: say you wanted to be able to represent n-dimensional vectors in your program, but ensure at compile time that there's no way for you to ever try to add a 2-dimensional vector to a 3-dimensional vector
03:47:35 <pumpkin_> currently you can do this in haskell if you decide on the dimensions at compile time
03:47:40 <pejo> temoto, like "append can't return a list that is shorter than the length of both inputs together".
03:48:19 <pumpkin_> temoto-wd: it gives you more safety than unit tests, because it's hard to check that your unit tests are covering all code paths and are covering your inputs uniformly
03:48:31 <pumpkin_> temoto-wd: and even if it were uniform, you'd still only have a probability
03:49:03 <temoto-wd> Yeah, unit tests show only presence of errors, they don't show absence.
03:49:10 <pumpkin_> yeah
03:49:10 <temoto-wd> I kinda used to that.
03:49:26 <pumpkin_> well, just like the type system takes some of the unit testing burden off you in haskell
03:49:53 <pumpkin_> having a dependent type system would make it even harder to get your program to compile, but even more likely to be correct once it did
03:50:11 <temoto-wd> uh could you give an example how append would be uh.. declared? with dependant types?
03:50:18 <njouini> What does "non strict" mean, when speaking about Haskell?
03:51:05 <osfameron> more mary poppins than supernanny :-)
03:51:43 <osfameron> njouini: "strict" is the opposite of "lazy", aiui
03:51:54 <doserj> njouini: "f is strict" means f undefined == undefined.  "f is non-strict" means f undefined /= undefined
03:52:07 <njouini> okay
03:53:27 <doserj> osfameron: technically, lazy is the opposite of eager, they are properties of evaluation strategies, i.e., implementations. strict/non-strict are purely semantical properties
03:53:30 <kapil> doserj: shouldn't be "f undefined not necessarily undefined" to be more pedantic.
03:53:52 <doserj> kapil: don't think so
03:53:59 <osfameron> doserj: what about f a = a ?
03:54:11 <osfameron> is that strict because f undefined = undefined ?
03:54:20 <dolio> Yes.
03:54:23 <doserj> yes
03:54:40 <weilawei> is there a simple way to graph a list of (x,y) pairs representing cartesian coordinates? im trying to visualize what a function of mine is doing because it's working right (in terms of syntactic correctness) but not logically correct
03:55:00 <weilawei> and i dont have any graph paper handy. x_x
03:55:31 <kapil> doserj: hm... so 'id' is a strict function?
03:55:47 <Zao> weilawei: Spit out values in two columns and throw at gnuplot?
03:56:01 <doserj> kapil: yes
03:56:13 <kapil> ok.
03:56:15 <weilawei> Zao: good idea
03:56:24 <pumpkin_> there's a gnuplot module for haskell too
03:56:29 <pumpkin_> but it's not as flexible as I'd like it
03:56:44 <pumpkin_> one of these days I'll submit a patch :)
04:00:18 <HugoDaniel> im feeling quite the superior being, coding in haskell
04:00:19 <HugoDaniel> :)
04:00:37 <HugoDaniel> like i've been given access to a future tech tool
04:01:01 <HugoDaniel> i guess i should stop doing drugs, it would help
04:01:05 <pumpkin_> :P
04:01:19 <pumpkin_> haskell is the best drug
04:01:22 <pumpkin_> or something like that
04:02:17 <HugoDaniel> hehe
04:04:16 <HugoDaniel> is there an easier way to build a list of the kind of data structures from a list of pairs, as shown here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2120#a2120
04:04:22 <HugoDaniel> ?
04:04:28 <HugoDaniel> im doing it using list comprehensions
04:04:34 <HugoDaniel> but i feel like im using the wrong tool :/
04:05:24 <pumpkin_> that's going to do all combinations
04:06:01 <HugoDaniel> oh
04:06:06 <HugoDaniel> its not working right :/
04:06:09 <HugoDaniel> big fail
04:06:58 <McManiaC> [ (x,y) | x <- [1..5] , y <- [1..5] ] will creat sth like (1,1) (1,2) (1,3) (1,4) (1,5) (2,1) etcpp
04:06:59 <doserj> [ SearchData "test" p c | (p,c) <- t]
04:07:05 <McManiaC> just had that yesterday :D
04:07:23 <pumpkin_> > [ (x,y) | x <- [1..5] , y <- [1..5] ]
04:07:24 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
04:07:31 <doserj> well, [ SearchData "test" p c | (c,p) <- t]
04:07:40 <McManiaC> :p pumpkin_
04:07:44 <HugoDaniel> ah, nice
04:07:45 <HugoDaniel> :D
04:07:53 <HugoDaniel> haskell 101
04:07:54 <HugoDaniel> :D
04:07:57 <McManiaC> hehe
04:07:57 <pumpkin_> there's a nice function call uncurry
04:08:15 <HugoDaniel> very nice good
04:08:32 <pumpkin_> it takes you from the chicken tikka masala to the chicken
04:08:40 <pumpkin_> and the masala
04:08:47 <HugoDaniel> :)
04:09:17 <HugoDaniel> i use flip, but then flip doesn work right on a -> b -> c -> d
04:09:18 <ivanm> hmmmm.... why does the @src of uncurry use fst and snd for the tuple rather than pattern matching? laziness?
04:16:22 <pumpkin_> @src uncurry
04:16:22 <lambdabot> uncurry f p = f (fst p) (snd p)
04:16:27 <pumpkin_> eww, that is ugly :)
04:16:53 <Botje> be glad YOU don't have to write that :]
04:17:45 <doserj> it could have been "uncurry f ~(a,b) = f a b"
04:18:28 <osfameron> what's the ~  ?
04:18:33 <HugoDaniel> how do i test for emptyness ?
04:18:37 <doserj> irrefutable pattern matching
04:18:39 <HugoDaniel> im using the length
04:18:46 <doserj> HugoDaniel: don#t
04:18:48 <HugoDaniel> length lst == 0
04:18:58 <quicksil1er> HugoDaniel: null
04:18:58 <doserj> > null []
04:18:59 <lambdabot>   True
04:19:04 <HugoDaniel> ah
04:19:05 <HugoDaniel> sweet
04:19:08 <pumpkin_> osfameron: "trust me GHC, this is a tuple, so don't check and just bind a to its fst and b to its snd"
04:19:24 <osfameron> what if it isn't a tuple?
04:19:32 <osfameron> and what do we need that annotation?
04:19:33 <pumpkin_> it has to be a tuple
04:19:38 <pumpkin_> but it might be undefined
04:19:38 <quicksil1er> osfameron: that's the type checker's job.
04:19:41 <pumpkin_> in which case it'll show up later
04:20:01 <osfameron> quicksil1er: ah I see, that's a separate phase?
04:20:24 <pumpkin_> > let f (x, y) = 5 in f undefined
04:20:25 <lambdabot>   * Exception: Prelude.undefined
04:20:27 <pumpkin_> > let f ~(x, y) = 5 in f undefined
04:20:28 <lambdabot>   5
04:20:44 <pumpkin_> it never needed x or y, so it didn't bother finding out if it was undefined
04:20:52 <pumpkin_> "finding out"
04:21:04 <quicksil1er> osfameron: type checking is compile time.
04:21:10 <quicksil1er> osfameron: constructor checking is run time
04:21:16 <osfameron> pumpkin_: but why would we pass undefined to uncurry ?
04:21:32 <quicksil1er> that's "the point" of type checking.
04:21:38 <pumpkin_> osfameron: we use undefined as an easy way to represent non-terminating computation and errors
04:21:41 <osfameron> quicksil1er: ah... I probably don't understand the distinction
04:21:49 <quicksil1er> you do it at compile time so your code can rely on the right thing being in the right place
04:21:56 <quicksil1er> and therefore it doesn't have to waste time checking at runtime.
04:22:30 <quicksil1er> osfameron: "why would we pass undefined"? Because haskell is turing-complete, the type checker can't tell if all computations will terminate.
04:23:25 <maltem> pumpkin_: actually, we use bottom to represent those, and define "undefined" to evaluate to bottom
04:23:39 <pumpkin_> :)
04:24:02 <osfameron> quicksil1er: ok, but defining uncurry with or without ~, if I do: uncurry (+) (1,undefined)  I get Exception: Prelude.undefined
04:24:07 <osfameron> what's the ~ pattern saving me from?
04:24:26 <maltem> (Well if we use undefined to refer only to Prelude.undefined, but I think it's reasonable to do so)
04:24:36 <quicksil1er> > uncurry const (1,undefined)
04:24:37 <lambdabot>   1
04:24:42 <quicksil1er> osfameron: ^^ that
04:24:52 <quicksil1er> i.e. a function which doesn't inspect its second argument
04:25:04 <quicksil1er> or, more realistically, doesn't *always* inspect its second argument
04:25:06 <weilawei> my function for finding the convex hull comes out wrong.. any ideas what's going on? (convex hull.. imagine a rubber band being wrapped around the outside of a set of pegs). http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2121
04:25:13 <osfameron> hmmm, does ghci not reevaluate a function I 'let' ?
04:25:18 <osfameron> both those definitions seem to work
04:25:23 <weilawei> theres a picture of the input points, output, and my expected results @ http://img510.imageshack.us/img510/9971/resultsg.jpg
04:25:28 * quicksil1er thinks
04:25:31 <osfameron> oh, no user error
04:26:19 <osfameron> hmm
04:26:23 <osfameron> > let x f ~(a,b) = f a b in x const (1,undefined)
04:26:24 <lambdabot>   1
04:26:28 <osfameron> > let x f (a,b) = f a b in x const (1,undefined)
04:26:29 <lambdabot>   1
04:26:44 * quicksil1er thinks he got that wrong.
04:26:54 <Workybob> the ~ saves you nothing in uncurry
04:27:01 <Workybob> because uncurry really does make sure that it's got a tuple
04:27:04 <Workybob> actually no
04:27:09 <pumpkin_> nope
04:27:11 <Workybob> it does save you something...
04:27:19 <quicksil1er> what about if "f" doesn't inspect *either* argument
04:27:26 <Workybob> indeed
04:27:46 <quicksil1er> > let x f (a,b) = f a b in x (\a b -> 5) undefined
04:27:48 <lambdabot>   * Exception: Prelude.undefined
04:27:53 <quicksil1er> > let x f ~(a,b) = f a b in x (\a b -> 5) undefined
04:27:55 <lambdabot>   5
04:28:04 <Ka1Wr3n> Hey, I'm a noob, and have a really noob question
04:28:11 <Workybob> Ka1Wr3n: fire away
04:28:17 <Workybob> don't ask to ask â€“ ask
04:28:22 <quicksil1er> however I'm not sure I can construct an interesting practical case where you rely on uncurry having this laziness property.
04:28:26 <Ka1Wr3n> For f(n) = n^n
04:28:44 <Ka1Wr3n> I want to get k digits for any n
04:28:57 <Ka1Wr3n> I understand this ivery efficiently done in Haskell
04:29:12 <Workybob> quicksil1er: how about uncurry (f c) where f x a b = if x > 5 then 2 else doStuffWith a b
04:29:16 <pumpkin_> is n integral?
04:29:16 <Ka1Wr3n> But I also want to get the last k digits
04:29:34 <Ka1Wr3n> Simple int, yes
04:29:50 <Workybob> Ka1Wr3n: you want to do the multiplications mod 10^k
04:29:51 <Ka1Wr3n> Is there an efficient wat to get hold of the last k digits
04:29:54 <pumpkin_> simple Int? it's going to grow awfully fast
04:29:57 <Ka1Wr3n> Yes
04:30:03 <Ka1Wr3n> That is acceptable
04:30:04 <Ferdirand> ah, another one doing project euler, eh ? :)
04:30:08 <pumpkin_> :P
04:30:14 <Workybob> Ka1Wr3n: no, I wasn't trying to understand the question â€“ I was explaining a solution
04:30:23 <maltem> Ka1Wr3n: Int cannot hold very large values
04:30:24 <pumpkin_> modular arithemtic is the way to go :P
04:30:33 <pumpkin_> along with Integer
04:30:35 <Ka1Wr3n> Workybob: k, my bad
04:31:06 <Ka1Wr3n> Workybob: Actually, I don't care about the details of f(n) - for  any f(n), what is an efficient way of picking up the last k digits of the result
04:31:18 <Workybob> doing it mod k...
04:31:19 <pumpkin_> what he said
04:31:39 <Workybob> 10^k rather
04:31:50 <Ferdirand> you should care about the details of f(n) though
04:32:20 <pumpkin_> Ka1Wr3n: that kind of approach is how people get the last few digits of graham's number
04:32:23 <pumpkin_> without computing it all :P
04:32:40 <pumpkin_> probably the only possible way to do that
04:32:45 <Ka1Wr3n> pumpkin_: k, I'll look that up
04:32:55 <Ka1Wr3n> pumpkin_: any suggested links?
04:33:00 <pumpkin_> well, not sure you're interested in graham's number itself
04:33:19 <pumpkin_> Ka1Wr3n: but modular arithmetic is just computing the remainder when dividing by a number
04:33:24 <Ka1Wr3n> pumpkin_: not really, no
04:33:52 <Tigran> > let f n k = (n ^ n) `mod` (10 ^ k) in f 12345 3
04:33:54 <lambdabot>   625
04:34:14 <Ka1Wr3n> Tigran: cool, ty
04:35:09 <Ka1Wr3n> Tigran: Any way I can do that more generically when I don't know anything beyond f(n) besides that it'll return a list?
04:35:11 <quicksil1er> except what tigran did isn't remotely efficient.
04:35:21 <pumpkin_> Ka1Wr3n: that same approach
04:35:25 <quicksil1er> what you're supposed to do is use repeated squaring repeatedly
04:35:27 <tomh> is there a lines function which considers cross platform end of line functions?
04:35:33 <quicksil1er> and reduce modulo 10^k at each step
04:35:35 <quicksil1er> not at the end.
04:35:42 <Ka1Wr3n> quicksil1er: k
04:35:48 <pumpkin_> Ka1Wr3n: this is the approach used by things like RSA
04:35:56 <Ka1Wr3n> pumpkin_: Cool
04:35:57 <pumpkin_> that takes a rather large number and raises it to a rather large exponent
04:36:04 * quicksil1er apologies for the redundant redundancy.
04:36:10 <Ka1Wr3n> I need to write all this down so I can spike after office hours :)
04:36:13 <maltem> newtype Mod1000 = Mod Int; instance Num Mod1000 where ...
04:36:29 <idnar> quicksil1er: heh, I keep reading your nickname as quicksillier
04:38:07 * maltem wonders how to vary k in that newtype without dependent types... Just Peano?
04:38:46 <quicksilver> maltem: take a lok at Data.Fixed
04:38:51 <quicksilver> for a rather simple approach.
04:41:35 <maltem> quicksilver: ah that looks smart enough
04:42:48 <maltem> Bah, the ghc html library docs really need source links
04:45:43 <quicksilver> maltem: they do, if you use the correct version.
04:45:52 <quicksilver> maltem: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
04:46:19 <quicksilver> (didn't we have thisconversation once before?)
04:47:17 <maltem> quicksilver: You just really made my life easier :)
04:47:25 <quicksilver> good. I aim to please.
04:47:37 <quicksilver> I don't know why the other set doesn't have them. I think haddock was dubared when they were generated.
04:48:00 <quicksilver> I tried to find out if someone could get them regenerated, but I failed.
04:48:29 <maltem> What is current vs. latest anyway?
04:49:03 <quicksilver> HEAD vs released, I think?
04:49:06 <quicksilver> or HEAD vs branch?
04:49:22 <Igloo> They're *BSD terms
04:50:24 <maltem> Name conventions fail so hard when you don't know them :)
04:50:58 <maltem> Hm, for once, the Haddock versions differ
04:59:33 <weilawei> so, let's say I want to process a list of things.. if it's Left or Straight, keep the value and move on to the next. if it's Right, drop the last thing we processed (before the current one). so, a value that's already been decided as "good" or that we kept can be thrown away
04:59:38 <weilawei> whats the functional idiom for this?
05:00:11 <Workybob> weilawei: sounds like a variation on fold that looks at two values at a time
05:02:31 <maltem> ... which you can simulate by zipping the list with its tail, and then fold over that
05:02:40 <Workybob> very true
05:02:58 <Workybob> in fact, you could even do half the work with a zipWith
05:03:19 <maltem> so true too
05:03:45 <weilawei> uh im new to haskell and dont quite get fold xD much less a weird version of fold
05:04:04 <Workybob> well, maltem has reduced it to a fold, not a weird version
05:05:08 <maltem> Let's start with the zip:
05:05:47 <Workybob> let f x Right = Nothing; f x _ = Just x; g xs = zipWith f xs (tail xs) in catMaybes . g -- that should do it, no?
05:05:57 <maltem> > let list = [1,2,-2,3] in zipWith (\a b -> if a - b = 0 then Nothing else Just a) list (tail list)
05:05:58 <lambdabot>   <no location info>: parse error on input `='
05:06:12 <maltem> humph
05:06:30 <weilawei> > let list = [1,2,-2,3] in zipWith (\a b -> if a - b == 0 then Nothing else Just a) list (tail list)
05:06:32 <lambdabot>   [Just 1,Just 2,Just (-2)]
05:07:06 <maltem> right
05:07:31 <maltem> oh my example was bad too :)
05:07:41 <maltem> > let list = [1,2,-2,3] in zipWith (\a b -> if a + b == 0 then Nothing else Just a) list (tail list)
05:07:42 <lambdabot>   [Just 1,Nothing,Just (-2)]
05:08:15 <Workybob> > let list = [1,2,-2,3] in catMaybes $ zipWith (\a b -> if a + b == 0 then Nothing else Just a) list (tail list)
05:08:16 <lambdabot>   [1,-2]
05:08:40 <Workybob> note weilawei â€“ catMaybes is where the fold comes in
05:08:43 <Workybob> @src catMaybes
05:08:44 <lambdabot> catMaybes ls = [x | Just x <- ls]
05:08:50 <Workybob> oh, it just isn't written that way
05:08:52 <h0tzenpl0tz> could anybody pls help me "cabal install curl" under windows? the configure-scripts seems to rely on linux "sh"-command... any idea?
05:08:52 <Workybob> >.>
05:09:18 <Workybob> h0tzenpl0tz: probably needs cygwin or mingw... but I'm no windows expert
05:09:28 <h0tzenpl0tz> k, thanks
05:09:34 <h0tzenpl0tz> *booting vm* ....
05:10:07 <maltem> weilawei: You'd only have to adjust the example if you want to keep the final 3
05:11:03 <weilawei> maltem: well i have a data type that has three possible values, Left, Right, and Straight.. im still trying to figure out what's going on in your example and translate it in my brain to that xD
05:11:18 <Workybob> weilawei: the key function you need to look at is the lambda in the middle
05:11:36 <Workybob> in maltem's example it makes descisions about whether to include something based on whether it and the next value add up to 0
05:11:51 <Workybob> in your example it needs to just ignore the first argument and ask "hey, is the second argument Right"
05:11:58 <weilawei> okay
05:12:14 <Workybob> let f x Right = Nothing; f x _ = Just x -- something like this
05:14:36 <Alpounet> Hi everybody.
05:15:56 <Workybob> hi Dr Nick
05:18:38 <weilawei> Workybob and maltem: thanks for the suggestion.. im a bit too tired to figure it out, but i have an inkling my solution needs serious revision
05:18:42 <weilawei> night!
05:18:48 <Workybob> nn
05:25:48 <chessguy> @hoogle minimumBy
05:25:48 <lambdabot> Data.Foldable minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
05:25:48 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
05:26:45 <h0tzenpl0tz> whats a "good way" (newbie) to parse arbitrary strings like "Star.Wars.Episode.III.Revenge.Of.The.Sith.2005.720p.HDTV.x264.INTERNAL-hV" for title, year, etc?
05:26:54 <pumpkin_> o.O
05:26:58 <opqdonut> parsec
05:27:08 <pumpkin_> O.o
05:27:10 <vegai> not at all suspicious string!
05:27:12 <opqdonut> or just split the string and use heuristics
05:27:26 <vegai> pumpkin_: these are not the torrents you're looking for
05:27:28 <h0tzenpl0tz> who cares, i have the legal bluray too
05:27:31 <pumpkin_> lol
05:27:43 <h0tzenpl0tz> i want a heuristics approach
05:27:45 <pumpkin_> h0tzenpl0tz: it's not that simple :P
05:27:59 <h0tzenpl0tz> i know, im looking for a smart way to analyze these sort of strings
05:28:04 <pumpkin_> lol
05:28:06 <pumpkin_> not what I meant
05:28:15 <h0tzenpl0tz> ah k
05:28:17 <chessguy> @src Ord
05:28:17 <lambdabot> class  (Eq a) => Ord a  where
05:28:17 <lambdabot>     compare      :: a -> a -> Ordering
05:28:17 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
05:28:17 <lambdabot>     max, min         :: a -> a -> a
05:28:18 <Vq^> vegai: it's not necessarily illegal
05:28:25 <vegai> h0tzenpl0tz: are the five parts always like that?
05:28:30 <vegai> h0tzenpl0tz: the last five I mean
05:28:52 <vegai> Vq^: of course not
05:28:56 <h0tzenpl0tz> vegai: not at all. sometimes release-year is missing, sometimes i ripped it myself, so theres no release-group, etc
05:28:57 <pumpkin_> h0tzenpl0tz: presumably the sketchy team that um, uploaded that takes pride in being consistent, and has a standard naming scheme
05:29:01 <pumpkin_> oh
05:29:49 <h0tzenpl0tz> would be the first approach to create filters for like 5 default naming-schemes and later thinking about non-standard naming
05:29:54 <h0tzenpl0tz> or is there a more general approach?
05:30:06 <Guest63914> hi
05:30:12 <pumpkin_> heuristics
05:30:16 <Guest63914> evetyone
05:30:19 <Vq^> Guest63914: hiya
05:30:19 <pumpkin_> which can be as general as you make them :P
05:30:30 <vegai> seems like a problem where you should just make something that works and fix it along the way
05:30:42 <h0tzenpl0tz> pumpkin_: what do you understand under heuristics? is there any "haskell-pattern" to try patterns or something?
05:30:57 <Vq^> h0tzenpl0tz: parsec probably can't help you past the point where you have extracted the different words
05:31:11 <h0tzenpl0tz> Vq^: thats what i thought. thanks
05:31:11 <vegai> I suppose your first pass should try to figure out the separator
05:31:23 <Guest63914> info
05:31:28 <pumpkin_> h0tzenpl0tz: like, searching for numbers delimited by dots, that fall into 1940-2010, is probably the movie date, so split there
05:31:32 <vegai> than try to look for the last word that's part of the title
05:31:38 <pumpkin_> h0tzenpl0tz: 720p,1080p, etc.
05:32:07 <h0tzenpl0tz> k, are there any special libraries or haskell-conventions to help me going. im currently reading RWH and try to build a first app
05:32:10 <Vq^> Guest63914: what kind of information do you require sir?
05:33:01 <galvus_damor> hi
05:33:43 <galvus_damor> i have a question concerning the network package for haskell
05:34:02 <pumpkin_> ...
05:34:17 <galvus_damor> i want to send a simple text messages via the internet
05:34:38 <galvus_damor> i've found a small programm http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2123#a2123
05:35:09 <galvus_damor> the problem is, that i can send messages to 127.0.0.1 or my own local ip-address
05:35:11 <chessguy> @type minimum
05:35:12 <lambdabot> forall a. (Ord a) => [a] -> a
05:35:24 <daf> galvus_damor: the server and client port numbers don't match
05:35:37 <galvus_damor> oh sorry
05:35:43 <pumpkin_> galvus_damor: to send text messages, you probably only need the client
05:36:12 <galvus_damor> the server is an old version the programm doesn't work also with correct prot numbers
05:36:17 <McManiaC> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2124 << why doesnt he find "args"??
05:36:40 <chessguy> @src comparing
05:36:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
05:36:48 <chessguy> @type comparing
05:36:49 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:37:18 <pumpkin_> McManiaC: maybe an indentation error?
05:37:26 <galvus_damor> pumpkin: i've tryed it ,but the message doesn't arrived
05:38:53 <McManiaC> pumpkin_: cant find anything :S
05:39:05 <quicksilver> galvus_damor: getContents and hGetContents are completely unsafe to use in this way.
05:39:20 <quicksilver> galvus_damor: whenever you have a socket, you need two threads
05:39:24 <quicksilver> one for reading, one for writing
05:39:31 <quicksilver> otherwise you'll deadlock yourself.
05:40:23 <galvus_damor> ok
05:42:12 <galvus_damor> can i use something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2123#a2126
05:43:29 <doserj> McManiaC: you could use let instead of where
05:43:30 <McManiaC> do you always have to use let in do blocks? or can u use where aswell?
05:43:57 <pumpkin_> McManiaC: always let
05:44:00 <pumpkin_> and it's a different let
05:44:02 <McManiaC> ah okay
05:44:04 <pumpkin_> from the let ... in
05:44:04 <McManiaC> makes sense
05:44:15 <McManiaC> okay with let it is working now =)
05:44:56 <h0tzenpl0tz> whats the haskelllish-way to write "data Person = Person {type :: Foo}"  the reserved keyword "type" kills me
05:45:44 <maltem> personType, unPerson, ...
05:46:13 <pumpkin_> unPerson would only be a wrapper type though?
05:46:25 <maltem> guess so
05:46:32 <pumpkin_> runPerson ;)
05:46:37 <h0tzenpl0tz> hm
05:46:50 <maltem> data Forrest = ...
05:46:51 <h0tzenpl0tz> i dont get it
05:47:05 <h0tzenpl0tz> data Person = Person {ptype:: PersonType, name::String, ....}
05:47:08 <h0tzenpl0tz> is this the right way?
05:47:22 <h0tzenpl0tz> PersonType = JustPerson | Writer | Director ...
05:47:25 <maltem> sure if it works
05:47:53 <h0tzenpl0tz> its pretty hard beginning with haskell. i always ask myself if this is the "right way" to go...
05:48:29 <maltem> Let the compiler tell you about the obviously wrong ways :)
05:49:33 <h0tzenpl0tz> k ;)
05:49:54 <h0tzenpl0tz> whats the xml-package to use if i only need lightweight non-validating parsing of amazon rest-responsen?
05:55:40 <h0tzenpl0tz> is there any website giving some examples for using the "xml"-package?
05:55:44 <McManiaC> im feeling so stupid... is there a "quick" way of getting rid of the error msg in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2124 when passing no arguments?
05:56:03 <McManiaC> instead of writing an if block or even an "action" function with let
05:56:05 <McManiaC> ?
05:56:43 <andun> when (null args) $ error "No arguments"?
05:58:31 <andun> or don't you want to exit? you could use case args of ["add"] -> ...; otherwise -> ...;
05:58:53 <doserj> case args of [] -> ... ;"add":_ -> ... ; "done":_ -> ...
05:59:24 <andun> ("add":_) in that case
05:59:38 <McManiaC> hey that it
05:59:38 <doserj> btw, who came up with the idea of using otherwise in pattern matching? Don't do that.
05:59:39 <McManiaC> =)
06:00:09 <McManiaC> why not dos?
06:00:27 <McManiaC> just _ ?
06:00:28 <doserj> McManiaC: it doesn't do what you think it does. And it may lead to surprising errors
06:00:36 <andun> yeah :P
06:00:39 <doserj> McManiaC: yes. _ is better
06:00:42 <McManiaC> okay
06:00:54 <doserj> > otherwise
06:00:55 <lambdabot>   True
06:01:08 <McManiaC> im reading the real world haskell book, theyve been using it there
06:01:10 <doserj> you are shadowing the value otherwise
06:01:24 <doserj> McManiaC: I doubt that
06:01:40 <doserj> McManiaC: it should be used in guards, not in pattern matches
06:01:52 <BONUS> i didnt know you cold pattern match on otherwise
06:01:59 <BONUS> is that some kind of special case or what
06:02:02 <BONUS> looks very stupid
06:02:02 <doserj> BONUS: it is just a variable
06:02:03 * McManiaC is confused
06:02:10 <idnar> BONUS: it's the same as pattern matching on "foo"
06:02:18 <idnar> so it's very misleading
06:02:27 <BONUS> doserj: i know but i mean you cant do case 3 of 4 -> "blah"; True -> "foo";
06:02:41 <BONUS> whereas you can do case 3 of 4 -> "blah"; otherwise -> "foo";
06:03:15 <BONUS> so hmm what's up with that
06:03:22 <maltem> BONUS: True is a constructor, not a variable
06:03:25 <ddarius> BONUS: s/otherwise/x/
06:03:31 <BONUS> oh lol
06:03:42 <BONUS> ahaha
06:04:04 <BONUS> i didnt catch that, it just gives otherwise the value of the case var
06:04:09 <BONUS> yeah i wouldnt use that
06:04:56 <byorgey> who is xahlee and why do people keep @remembering his dumb, spiteful ranting?
06:05:12 <ddarius> byorgey: Some crazy and I don't know.
06:05:22 <idnar> @quote xahlee
06:05:22 <lambdabot> xahlee says: What's left are so called computer scientist, typically morons.
06:05:29 <idnar> @quote xahlee
06:05:29 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
06:05:36 <idnar> heh
06:05:42 <byorgey> ok, well, that last one is funny =)
06:05:53 <idnar> @quote xahlee
06:05:53 <lambdabot> xahlee says: This thread, illustrates, how often comp lang fanatics propagate patently false things, in their fanaticism.
06:05:58 <idnar> @quote xahlee
06:05:59 <lambdabot> xahlee says: What's left are so called computer scientist, typically morons.
06:06:03 <idnar> @quote xahlee
06:06:04 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
06:06:17 <BONUS> what a troll
06:06:24 <McManiaC> can u use guards with case? or if?
06:06:29 * idnar wonders what a "reputable" computer scientist is
06:06:50 <BONUS> you can use them with case yes
06:07:12 <doserj> McManiaC: you can use guards for patterns. case uses pattersn, if doesn't
06:07:54 <McManiaC> hm yeah ofcourse
06:07:54 <McManiaC> *g
06:19:57 <chessguy_> 'morning
06:21:40 <h0tzenpl0tz> could somebody give me kickstart on how to use and connect (á la bind due to Maybe?) these xml-functions? http://hackage.haskell.org/packages/archive/xml/1.3.3/doc/html/Text-XML-Light-Cursor.html
06:22:08 <McManiaC> how can i get the systems home directory?
06:22:41 <andun> what do you mean by that?
06:23:15 <McManiaC> i want to open a file ~/.foo
06:23:33 <koeien> @where getHomeDirectory
06:23:33 <lambdabot> I know nothing about gethomedirectory.
06:23:34 <McManiaC> but i get *** Exception: ~/.foo: openFile: does not exist (No such file or directory)
06:23:46 <koeien> McManiaC: System.Directory has the function you need
06:23:52 <quicksilver> the ~ notation is supported by your shell
06:23:57 <quicksilver> not the underlying filesystem.
06:24:02 <koeien> McManiaC: ~ is because bash expands it
06:24:06 <koeien> or w/e shell you use
06:24:18 <koeien> McManiaC: try    echo ~   and you'll see
06:25:56 <McManiaC> yeh
06:28:55 <chessguy_> are you trying to do it OS-indepemdent?
06:32:29 <Alpounet> McManiaC, in Windows, you'll get a file put in a place nobody has gone before you :-p
06:37:05 <McManiaC> :D
06:37:54 <walter_> Could you give a example of para input with the function foldlSum :  foldlSum :: (Num a) => [a] -> a
06:38:09 <Workybob> para input?
06:38:26 <Elly> I'm curious what that means too
06:38:41 <walter_> foldlSuml "1" ["1", "3", 5"] doesnt work
06:38:48 <Workybob> no
06:38:51 <Elly> because those are strings
06:38:55 <Elly> and it takes Num types
06:38:57 <Workybob> that's because it's type says it takes a list of numeric values
06:39:02 <Workybob> you gave it a string and a list of strings
06:40:17 <Elly> you can read the type sig as: "a must be Num in [a] -> a"
06:40:18 <walter_> Can you give a example  how to use the function foldlSum
06:40:28 <koeien> walter_: > foldlSum [1,2,3,37]
06:40:28 <Elly> you can figure it out
06:40:47 <koeien> walter_: you haven't seen typeclasses before ?
06:41:00 <Elly> [a] -> a means it takes a list of some numeric type a, and returns a numeric type a
06:41:25 <walter_> I man quite new on haskell, not learn the  typeclasses by now.
06:42:26 <walter_> well,  I understand typeclass, but dont understand (num a)=>a
06:42:31 <Workybob> walter_: well, when you see Num a, you can substitute any numeric type for a â€“ so it could mean [Int] -> Int, it could mean [Float] -> Float ... etc
06:42:36 <koeien> walter_: suppose i have a function of type   f ::  [a] -> a   , can you think of a possible input to f ?
06:42:37 <Elly> then you don't understand typeclasses :P
06:42:52 <Elly> the '=>' syntax can be read as 'in'
06:43:14 <walter_> I see
06:43:15 <Elly> with constraints on typeclasses on the left side, and type variables on the right side
06:43:31 <walter_> koeien: yes
06:43:34 <Elly> so 'Num a => [a] -> a' can be read as "a is Num in [a] -> a"
06:44:11 <walter_> Ellly: understood
06:44:15 <koeien> walter_: yeah so (Num a) => ... means that a should be a type that has a Num instance. e.g. Int, Float
06:44:20 <walter_> thanks you all
06:52:39 <alinp1> hi
06:52:50 <alinp1> Prelude module will load by default when compiling ?
06:53:04 <Botje> yes
06:53:19 <alinp1> thanks
07:02:49 <asgaroth> Is it just me or are the taglib-bindings missing a setTitle function?
07:03:03 <mnislaih> those who are familiar with the restricted monads of Control.RMonad, does the embed trick work with a mtl monad transformer around the restricted monad ?
07:13:18 <ImOuttaYourMonad> > let (x:xs):ys = [[1,2,3],[4,5,6]] in ys
07:13:19 <lambdabot>   [[4,5,6]]
07:13:25 <ImOuttaYourMonad> > let (x:xs):ys = [[1,2,3],[4,5,6]] in x
07:13:27 <lambdabot>   1
07:13:31 <ImOuttaYourMonad> > let (x:xs):ys = [[1,2,3],[4,5,6]] in xs
07:13:32 <lambdabot>   [2,3]
07:17:53 <drhodes> is 'of' only used with 'case'?
07:18:28 <Igloo> Yes
07:18:42 <drhodes> thanks
07:30:11 <ImOuttaYourMonad> is
07:30:11 <ImOuttaYourMonad> sharedFeatures xs ys = unzip $ filter (\(x,y) -> x /= 0 && y /= 0) $
07:30:11 <ImOuttaYourMonad>                        zip xs ys
07:30:11 <ImOuttaYourMonad> lazy?
07:30:11 <ImOuttaYourMonad> one iteration?
07:30:11 <ImOuttaYourMonad> over the lists?
07:30:43 <Workybob> it may be a tiny little niggle, but I really which case x of was match x against
07:31:07 <Igloo> Workybob: why?
07:31:09 <Workybob> match x against is more descriptive of what you're doing, and doesn't make you think "oh cool, I can use this for doing stuff like checking ranges"
07:31:37 <Raevel> ImOuttaYourMonad: yes, i think so
07:31:56 <chessguy_work> @pl \(x,y) -> 0 /= x && 0 /= y
07:31:57 <lambdabot> uncurry ((. (0 /=)) . (&&) . (0 /=))
07:32:33 <chessguy_work> @src uncurry
07:32:33 <lambdabot> uncurry f p = f (fst p) (snd p)
07:34:12 <nominolo> :t (>>)
07:34:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:34:31 <nominolo> @hoogle (Applicative m) => m a -> m b -> m b
07:34:32 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
07:34:32 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
07:34:32 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
07:35:12 <Raevel> uncurry ((||) `on` (/= 0))
07:37:58 <BONUS> data AnyPred a = AnyPred (a -> Bool), instance Monoid (AnyPred a) where mempty = AnyPred (const True); AnyPred f `mappend` AnyPred g = AnyPred (\x -> f x || g x)
07:38:08 <BONUS> hmm, im wondering if this might be a useful monoid
07:41:40 <maltem> @hoogle Any
07:41:41 <lambdabot> Data.Monoid newtype Any
07:41:41 <lambdabot> Data.Monoid Any :: Bool -> Any
07:41:41 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
07:41:49 <doserj> BONUS: there is instance Monoid Any, and instance Monoid b => Monoid (a->b)
07:42:29 <BONUS> i knew about Any, i didnt know about the second instance, ah
07:42:32 <BONUS> cool
07:43:12 <paper_cc> , src ''Any
07:43:17 <lunabot>  luna: Not in scope: type constructor or class `Any'
07:46:47 <BMeph|back> I wish the definition were just written: uncurry f (x,y) = f x y.  In fact, wasn't it written that way before?
07:47:23 <LeoD> @src uncurry
07:47:23 <lambdabot> uncurry f p = f (fst p) (snd p)
07:47:32 <jeffersonheard> @hoogle (a -> b) -> (m a -> m b)
07:47:33 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
07:47:34 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:47:34 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:47:34 <Workybob> BMeph|back: that's stricter than the current one
07:48:03 <Workybob> > let f a b = 5 in uncurry f undefined
07:48:04 <lambdabot>   5
07:48:18 <Workybob> > let f a b = 5; uncurry f (a,b) = f a b in uncurry f undefined
07:48:20 <lambdabot>   * Exception: Prelude.undefined
07:50:27 <doserj> > let f a b = 5; uncurry f ~(a,b) = f a b in uncurry f undefined
07:50:27 <tomh> anyone here knows how to set the height of a textView with gtk2hs?
07:50:28 <lambdabot>   5
07:51:51 <Liskni_si> gah
07:52:05 <Liskni_si> what shall i do if i want to quickcheck an IO function?
07:52:21 <Liskni_si> (all it does is alloca, poke and peek)
07:52:29 <Liskni_si> is that a good use for unsafePerformIO?
07:55:26 <jeffersonheard> @hoogle (f b -> c) -> (a,b) -> (a,c)
07:55:27 <lambdabot> No results found
07:55:37 <jeffersonheard> ah well
07:55:54 <jeffersonheard> I've got this: mapsnd (remap mx' 0 0 height' . clamp 0 mx' . (sub (3*mx'))) . filter ((>=(3*mx')) . snd) <$> positives
07:56:00 <jeffersonheard> where positives is a Maybe value
07:56:15 <jeffersonheard> and I want to lift the left side to deal with maybes
07:56:22 <jeffersonheard> I thought <$> would do it, but it's not
07:56:52 <jeffersonheard> positives is a list of (a, Maybe b)
07:56:54 <jeffersonheard> oh
07:56:55 <jeffersonheard> wait
07:56:57 <jeffersonheard> found it
07:56:59 <jeffersonheard> nm.
08:00:45 <jeffersonheard> odd...  not exactly.  now it complains about needing height' to be a Maybe Double
08:00:54 <jeffersonheard>  mapsnd ((remap mx' 0 0 height' . clamp 0 mx') <$>)
08:01:30 <jeffersonheard> where mapsnd maps f over the second value of a pair for every pair in a list of pairs
08:04:28 <jad4> hmm small cat theory question
08:04:43 <jad4> if I have     g: A -> B
08:05:08 <ImOuttaYourMonad> why isnt Data.List, Data.Ord and perhaps Data.Map in the Prelude?
08:05:09 <jad4> then I can get   eta o g : A -> T B
08:05:25 <jad4> and also   T g : T A -> T B
08:05:54 <jad4> what do you call each of those?
08:06:11 <jad4> the latter would be a lifting right
08:06:18 <jad4> what about the former?
08:07:35 <jad4> or using haskell notation
08:07:50 <jad4> what do you call  return . g
08:11:53 <roconnor> @type map ?g
08:11:54 <lambdabot> forall a b. (?g::a -> b) => [a] -> [b]
08:12:00 <roconnor> @type liftM ?g
08:12:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m, ?g::a1 -> r) => m a1 -> m r
08:12:11 <roconnor> that is T g
08:12:37 <roconnor> I think return . g is called return . g
08:13:12 <roconnor> although I guess you could call it runKliesli (pure g)
08:13:14 <opqdonut> thanks, roconnor
08:13:23 <roconnor> @type  runKliesli (pure ?g)
08:13:25 <opqdonut> for this deep insight ;)
08:13:25 <lambdabot> Not in scope: `runKliesli'
08:13:36 <roconnor> @type  runKleisli (pure ?g)
08:13:38 <lambdabot> forall b (m :: * -> *) a. (Applicative (Kleisli m a), ?g::b) => a -> m b
08:14:19 <roconnor> sorry, it's runKleili (pure g)
08:14:20 <roconnor> (of course)
08:14:21 <opqdonut> jad4: (>>= return . g) is liftM g
08:14:43 <Workybob> much better known as fmap
08:14:53 <opqdonut> or <$>
08:14:57 <Workybob> indeed
08:15:12 <roconnor> opqdonut: oops.  I think I may have misunderstood jad4's question
08:15:17 <opqdonut> i seem to prefer liftM to fmap and liftA when the context is monadic
08:15:30 <roconnor> I thought he was asking about how to represent category concepts in Haskell
08:15:39 <Workybob> I prefer fmap, because neither liftM or liftA should exist
08:15:49 <opqdonut> roconnor: ah so he was, i misunderstood
08:15:52 <Workybob> the hierarchy should be in place to guarentee that fmap is always there
08:16:01 <opqdonut> indeed
08:16:14 <roconnor> opqdonut: I'm not sure I'm right.
08:16:28 <doserj> Workybob: some would say that fmap shouldn't be there :)
08:16:39 <Workybob> doserj: who would say that?
08:16:39 <opqdonut> liftF ;)
08:16:48 <Workybob> heh
08:16:50 <opqdonut> Workybob: for example those who would prefer it being "map"
08:16:59 <Workybob> well, that's just a naming issue
08:17:00 <opqdonut> +named
08:17:02 <opqdonut> yeah
08:17:06 <Workybob> I mean the function with type (Functor f) => ...
08:17:12 <Workybob> rather than (Applicative f) ...
08:17:15 <Workybob> or (Monad f) ...
08:17:17 <opqdonut> indeed.
08:18:17 <drhodes> > "12foo345" =~ "[fo]" :: Int
08:18:18 <lambdabot>   3
08:18:37 <opqdonut> i love how magic the regex library is :)
08:18:51 <drhodes> > "12foo345" =~ "[fo]" :: [String]
08:18:52 <lambdabot>   ["f","o","o"]
08:19:01 <opqdonut> exactly
08:19:52 <drhodes> there's something tricky going on there, but I'm afraid to ask. ;)
08:19:56 <daf> it's incredibly confusing to use in GHCI until you work out you have to give explicit type signatures
08:20:12 <daf> and it's really annoying to work out which type signatures you can actually use
08:20:14 <ImOuttaYourMonad> can someone show a good use of Monoid?
08:20:47 <Workybob> ImOuttaYourMonad: anything that can be built up to contain many things
08:20:55 <daf> ImOuttaYourMonad: I like http://apfelmus.nfshost.com/monoid-fingertree.html
08:20:57 <opqdonut> ?info Writer
08:20:58 <lambdabot> Writer
08:21:04 <opqdonut> gah
08:21:17 <Workybob> ImOuttaYourMonad: Reactive's Event monoid is very useful
08:21:33 <opqdonut> anyway, Monoid w => Monad (Writer w)
08:21:33 <quicksilver> opqdonut: I despise how magic the regex thingy is
08:21:50 <opqdonut> Writers over Monoids are nice
08:23:38 <BMeph> I prefer Cale's sort example. That way, we get people to shut up about the whole "containing" issue. :\
08:25:34 <jad4> roconnor, ah no...
08:26:05 <jad4> roconnor, well if I just wanted to represent the categorical concept in haskell return . g seems like the direct translation no?
08:26:42 <roconnor> ya sorry.  I guess I don't understand the question
08:26:43 <jad4> roconnor, but I have never heard abour the runKleisli and pure functions so that was nice :)
08:27:06 <McManiaC> doesFileExist is IO Bool... how can i use that with if?
08:27:09 <jad4> roconnor, it's just that I have a case where I do a liftM, I call that a lifting
08:27:19 <jad4> roconnor, and another where I compose it with return
08:27:32 <jad4> roconnor, and don't know what to call that one to distinguish form the first
08:27:42 <quicksilver> McManiaC: x <- doesFileExist f; if x then ... else ....
08:27:47 <jad4> roconnor,  was wondering if there's any categorical name for that, composing with eta
08:27:54 <daf> @src liftM
08:27:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:35:45 <McManiaC> how can i use UTF8 characters with ghc? :S
08:36:16 <McManiaC> Ã¤ i.e. gets displayed as ï¿½
08:38:23 <quicksilver> haskell supports unicode Chars
08:38:28 <quicksilver> indeed, Char is always unicode.
08:38:33 <quicksilver> ghc supports UTF8 source files.
08:38:48 <quicksilver> however, to atually input and output unicode from your program, you need to use an encoding library.
08:38:55 <quicksilver> e.g. utf8-string from hackage.
08:41:25 <McManiaC> import Data.String.UTF8 ?
08:43:50 <McManiaC> Main.hs:53:4:
08:43:51 <McManiaC>     Ambiguous occurrence `putStrLn'
08:43:51 <McManiaC>     It could refer to either `Prelude.putStrLn', imported from Prelude
08:43:51 <McManiaC>                           or `System.IO.UTF8.putStrLn', imported from System.IO.UTF
08:44:10 <McManiaC> :S
08:44:47 <Cheshire> you should hide the prelude one
08:44:58 <doserj> either import qualified System.IO.UTF8 as UTF8, or import Prelude hiding (...)
08:46:03 <Cheshire> I might write a program to solve integral equations
08:46:11 <Zao> Arbitrary?
08:46:25 <McManiaC> cool works
08:46:27 <McManiaC> thanks
08:47:34 <ImOuttaYourMonad> hmm when i first started to get into more advanced math by myself it all seemed incredibly hard, but i think i ahve penetrated soem of it now. a lot of the more philosophical stuff is just fancy words for fairly intuitive stuff it seems. and matrices and linae algebra is really cool when you have diret use of it.
08:50:14 <Cheshire> what philosophical stuff?
08:50:59 <jeffersonheard> anyone tried to build haxr from cabal lately?
08:51:07 <jeffersonheard> it's not working.  complains about ConnError being out of scope
08:55:27 <tomh> how can i map on a type IO ([a])?
08:55:45 <Cheshire> tomh, to go from  (a -> b)  to (IO a -> IO b)  you can use  fmap
08:55:45 <tomh> thought liftM (map f) or something would work
08:55:52 <Cheshire> :t liftM map
08:55:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
08:56:11 <tomh> ok fmap it is :)
08:56:20 <Cheshire> I think fmap = liftM
08:56:30 <ImInYourMonad> hmm fingertrees are cool, whya rent haskell lists made that way?
08:56:34 <daf> :t mapM
08:56:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:57:03 <Cheshire> ImInYourMonad curious what you were rreferring to?
08:59:50 <marcot> Hello, is there a good library for string substitution?
09:00:14 <jeffersonheard> okay, I figured it out, but only sort of...  cabal installed HTTP-4000.0.4 as part of its bootstrap, but haxr requires < 4000.0, but for some reason, cabal isn't seeing the HTTP 3000 that I installed
09:00:26 <jeffersonheard> I'm about ready to throw up my hands at this today
09:00:33 <jeffersonheard> I never can get cabal to work properly
09:02:08 <ImInYourMonad> jeffersonheard: on windows? i have the same problem then
09:02:23 <jeffersonheard> no, not on windows, on ubuntu linux.
09:02:43 <ImInYourMonad> Cheshire: abstract algebra, category theory. it is working through each step.
09:11:10 <apn> @pl \a b -> if p then a:b else b
09:11:11 <lambdabot> join . (if' p .) . (:)
09:11:37 <Cheshire> apn, maybe you don't care but here's how I would write it:  bool (a:) id p b
09:11:53 <Cheshire> bool is the function a -> a -> Bool -> a
09:12:07 <apn> Cheshire thank you
09:13:53 <zachk> > map (\c->if c `elem` ['a'..'z'] then head $ drop 13 $ dropWhile (\x->x/=c) $ cycle ['a'..'z'] else c) "hello world"
09:13:54 <lambdabot>   "uryyb jbeyq"
09:14:01 <zachk> sweetness
09:14:04 <ImInYourMonad> if i want to write: [[1,2,4,3],[4,3,4,2]] to a file with the outer [] removed and write one list per row, how do I do tha?
09:14:04 <ImInYourMonad> writeFile output (show $ map (\x -> show x ++ "\r\n") predictions)
09:14:04 <ImInYourMonad> doesnt work as i want
09:15:30 <apn> ImInYourMonad: what does it do?
09:15:40 <zachk> iminyourmonad: try mapM_ (hPrint Handle) yourListofLists
09:15:51 <zachk> where handle should be handle
09:16:07 <apn> > show $ map (\x -> show x ++ "\n") $ [[1..3],[4..6]]
09:16:09 <lambdabot>   "[\"[1,2,3]\\n\",\"[4,5,6]\\n\"]"
09:16:26 <apn> ah
09:16:44 <apn> :t unlines
09:16:45 <lambdabot> [String] -> String
09:17:04 <apn> > unlines.map show $ [[1..4],[5..8]]
09:17:04 <lambdabot>   "[1,2,3,4]\n[5,6,7,8]\n"
09:17:35 <apn> there, that should work
09:19:42 <McManiaC> ('-':'-':_)
09:19:57 <McManiaC> is there a more readable way to write that?
09:20:03 <McManiaC> like "--" ++ _ or sth?
09:20:48 <doserj> in a pattern? no. But you can use a guard like "--" `isPrefixOf` x
09:20:58 <McManiaC> okay
09:21:28 <Cheshire> you can use view pattern
09:21:42 <Cheshire> f (strip "--" -> Just tail) = ...
09:21:44 <Cheshire> f otherwise = ...
09:21:57 <Cheshire> (define strip :: String -> String -> Maybe String)
09:23:40 <McManiaC> O.o
09:23:41 <McManiaC> okay
09:24:12 <Cheshire> ?
09:26:13 <McManiaC> nice way :)
09:27:40 <ghostscript> Hi: Could somebody tell me if there is a way to convert an Int  to a PortNumber (defined in the Network module)?
09:28:06 <ghostscript> Turns out that when I put an integer as the argument, the compiler can infer the type correctly
09:29:12 <ghostscript> but if I use something like connect address (PortNumber (read x))  then it has a problem
09:29:30 <ghostscript> it has an Int (for read x) where it expects a PortNumber
09:29:52 <ziman> ghostscript, (PortNumber $ fromIntegral x)
09:30:44 <ghostscript> Oh
09:30:46 <ghostscript> Thanks
09:30:48 <ziman> ghostscript, it looks like the argument needs to be Integral, which is satisfied for numeric literals
09:30:57 <ghostscript> I looked up the definition of the Integral class
09:30:58 <ziman> ghostscript, it took me a while to figure it out, too ;)
09:31:25 <ziman> when I used it for the first time
09:31:38 <ghostscript> but there was no function which I could find useful at first glance
09:31:48 <ghostscript> ziman: Thanks again
09:32:05 <quicksilver> ghostscript, ziman : I believe that is wrong.
09:32:12 <ghostscript> ziman: If I may ask, Where is fromIntegral defined?
09:32:12 <ziman> I don't even know what type PortNumber takes as the argument; i've never browsed the sources
09:32:15 <quicksilver> it's an error that "PortNumber" is exported.
09:32:26 <quicksilver> you should either just use a literal (1234)
09:32:34 <quicksilver> or if you already have an int, use (fromIntegral 1234)
09:32:41 <quicksilver> but never use the PortNumber constructor explicitly.
09:32:50 <ziman> oh, PortNumber is Integral?
09:32:54 <ghostscript> quicksilver: Thanks
09:32:57 <ghostscript> ziman: yes
09:33:13 <quicksilver> the internal rep is in network byte order
09:33:15 <ghostscript> ziman: It derives Integral, Eq, Show among others
09:33:20 <ghostscript> Ok
09:33:28 <quicksilver> if you access the internal rep (by using the constructor explicitly) you are bypassing the byte-swap
09:33:30 <ziman> i see. thanks quicksilver
09:33:34 <quicksilver> which makes your code endian-dependent.
09:33:39 <quicksilver> doesn't matter on intel, of course
09:33:43 <ghostscript> quickSilver: So I should not use the PortNumber constructor at all
09:33:47 <quicksilver> since host byte order is network byte correct.
09:33:52 <quicksilver> ghostscript: right
09:33:59 <quicksilver> or at least, that's what I believe :)
09:34:01 <ghostscript> quicksilver: Oh I see
09:34:05 <ziman> quicksilver, well, intel is little endian
09:34:18 <ghostscript> But somehow the module exports it
09:34:21 <ziman> we do have to do the conversion
09:35:07 <quicksilver> oh, yes, you're right
09:35:10 <quicksilver> so it will matter on intel
09:35:16 <quicksilver> it doesn't matter if you're writing client and server
09:35:20 <quicksilver> because the two mistakes cancel out :)
09:35:23 <ziman> I thought it was exported because you may want to choose between Unix sockets, Port numbers, etc. just by choosing the appropriate constructor
09:35:25 <quicksilver> ghostscript: the export is a bug
09:35:43 <ziman> quicksilver, I did not write the server and it works :)
09:36:01 <ziman> but however, if it's deprecated, better not to use it :)
09:37:11 <ziman> hm, but looking at the Network docs, it seems okay to me... http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
09:37:14 <quicksilver> ziman, ghostscript : http://hackage.haskell.org/trac/ghc/ticket/2446
09:37:21 <quicksilver> describes the problem.
09:37:24 <quicksilver> Maybe I explained wrong?
09:37:33 <ghostscript> quiksilver: if I don't use the PortNumber constructor
09:37:41 <ghostscript> the compiler flags it an error
09:37:47 <ziman> oh, PortNum /= PortNumebr
09:37:57 <ghostscript> while it compiles with the PortNumber Constructor
09:38:04 <ziman> quicksilver, PortNumber belongs to the PortID type
09:38:14 <quicksilver> ah!
09:38:20 <ziman> whereas PortNum belongs to the PortNumber type ;)
09:38:21 * quicksilver apologies for all the un-necessary noise.
09:38:27 <quicksilver> how confusing ;)
09:38:30 <quicksilver> confused me, at any rate.
09:38:37 <ghostscript> quiksilver: yes that was confusing :-)
09:38:46 <ziman> yeah, cool naming ;)
09:38:51 <ghostscript> quiksilver, ziman: Thanks for all your help
09:39:05 <Cheshire> > Sum 1
09:39:07 <lambdabot>   Sum {getSum = 1}
09:40:42 <alar> are Ptr pointers governed by GC?
09:40:48 <ghostscript> ziman, quiksilver: Thanks to you too, I finally got my 15-minute hacked version of nc running :-D
09:40:55 <ghostscript> *you two
09:41:27 <ziman> what is nc? :)
09:41:31 <ghostscript> netcat
09:41:34 <ghostscript> :-)
09:41:36 * pumpkin hides from dons
09:41:38 <pumpkin> meow
09:41:43 <ziman> nice ;)
09:41:56 <zachk> if i just want to play some *.wav files using haskell what should i use
09:42:04 <centrinia> pumpkin, Did you get the ByteString to UArr converter to work?
09:42:21 <pumpkin> centrinia: you talking about the cafe post about it?
09:42:27 <centrinia> Yeah.
09:42:46 <pumpkin> it half-works, but I haven't had time to touch it recently
09:43:04 <pumpkin> now I feel guilty (and dons is probably pissed) that my bugs are getting reported to the whole list :P
09:43:23 <McManiaC> *** Exception: /home/nils/.todo: openBinaryFile: resource busy (file is locked)
09:43:28 <centrinia> Can I look at your bugs?
09:43:32 <pumpkin> sure
09:43:40 <pumpkin> my repo is on patch-tag
09:43:43 <dons> shrug
09:43:54 <McManiaC> whats happening there :S
09:44:09 <McManiaC> im trying to write to a file using appendFile from System.IO.UTF8
09:44:18 <McManiaC> appendFile from prelude wont work either
09:44:37 <ImOuttaYourMonad> can : (\x y -> x ++ " " ++ show y) be compredd sed foldl ((++) . show) or something?
09:44:41 <int-e> McManiaC: did you use readFile on the same file earlier?
09:44:50 <McManiaC> yes
09:44:52 <centrinia> Supern00b?
09:45:31 <int-e> McManiaC: then you have to make sure you read the data till the end, or alternatively, use a combination of withFile and hGetContents.
09:46:10 <McManiaC> int-e: how?
09:46:13 <int-e> McManiaC: (readFile is lazy; the file isn't closed before you've actually used all the data in the file. and as long as it hasn't been closed, it's locked and you can't open it again, as appendFile tries to do.)
09:46:25 <McManiaC> okay
09:47:44 <int-e> McManiaC: the easiest way is probably to do a  return $! length filedata   where filedata is the value returned by readFile.
09:49:16 <alar> can someone enlighten me on pointers?
09:49:26 <ImInYourMonad> is appendFile for writing tot he end of a file?
09:49:37 <pumpkin> alar: what about them?
09:49:39 <ImInYourMonad> alar: ask
09:49:57 <alar> are Ptrs governed by GC?
09:50:14 <alar> I see that ForeignPtrs are half-governed by GC
09:50:45 <alar> GC counts references, but finalizer actually kills them
09:51:04 <alar> and I see that Ptrs have function "free"
09:51:14 <McManiaC> ImInYourMonad: yes
09:51:15 <alar> does it mean that GC never remoces them?
09:51:22 <alar> removes
09:51:34 <McManiaC> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2129#a2129 <- is what im trying to do
09:51:47 <McManiaC> readTodo is reading from a given file
09:52:33 <ImInYourMonad> predictionsToString xs = unlines $ map (\z -> (drop 1 $ foldl (\x y -> x ++ " " ++ show y) "" z) ++ "\n") xs ///// there must be a nicer way of doing that
09:52:38 <int-e> McManiaC: ok, in that particular case, you can add a   return $! count  after the let
09:53:17 <int-e> McManiaC: which will force the count to be calculated right away, and that will force the whole file to be read
09:53:26 <ImInYourMonad> McManiaC: yes what?
09:53:49 <McManiaC> <ImInYourMonad> is appendFile for writing tot he end of a file?
09:53:52 <ImInYourMonad> ok
09:53:52 <Gracenotes> ImInYourMonad: you might be interested in intersperse and/or intercalate
09:53:55 <McManiaC> ok thx int-e , it worked =)
09:54:04 <Gracenotes> from Data.List
09:54:21 <Gracenotes> plus, foldl with appending is inefficient :)
09:56:05 <Gracenotes> ImInYourMonad: so try, prefix ++ intercalate your args ++ suffix
09:56:48 <McManiaC> uuuh
09:56:54 <McManiaC> another problem with UTF8 characters
09:57:05 <McManiaC> getArgs seems to mess everything up :S
10:12:28 <ImInYourMonad> i dont get how to use intercalate
10:12:41 <EvilTerran> ?type intercalate
10:12:42 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:12:42 <ImInYourMonad> > intercalate
10:12:43 <lambdabot>       Overlapping instances for Show ([a] -> [[a]] -> [a])
10:12:43 <lambdabot>        arising fro...
10:12:51 <Cheshire> sigh
10:13:01 <EvilTerran> > intercalate [1] [[2,3,4],[5,6,7],[8,9,0]]
10:13:02 <lambdabot>   [2,3,4,1,5,6,7,1,8,9,0]
10:13:19 <ImInYourMonad> > Data.List.intercalate ["\n"] [[1,2,3],[4,5,6]]
10:13:20 <shag> i think i am blind, but how do i user "read" in my parsec parser? e.g. my parser should return Int if "read" succeeds and otherwise it should fail
10:13:21 <lambdabot>       No instance for (Num [Char])
10:13:21 <lambdabot>        arising from the literal `1' at <in...
10:13:35 <doserj> > intercalate "," ["Hello","World"]
10:13:35 <ImInYourMonad> > Data.List.intercalate ["\n"] [map show [1,2,3], map show[4,5,6]]
10:13:36 <lambdabot>   "Hello,World"
10:13:37 <lambdabot>   ["1","2","3","\n","4","5","6"]
10:13:47 <ImInYourMonad> well it doesnt make it simplter
10:14:00 <EvilTerran> > intercalate "\n" (map show [1,2,3,4,5,6])
10:14:01 <lambdabot>   "1\n2\n3\n4\n5\n6"
10:14:11 <EvilTerran> > unlines (map show [1..6])
10:14:13 <lambdabot>   "1\n2\n3\n4\n5\n6\n"
10:14:18 <skorpan> :t intercalate
10:14:18 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:14:24 <skorpan> :t intersperse
10:14:25 <lambdabot> forall a. a -> [a] -> [a]
10:14:44 <CirceOfAaea> Wow
10:14:57 <skorpan> @src intercalate
10:14:57 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:15:00 <skorpan> i knew it...!
10:15:05 <CirceOfAaea> I neve new there was a ghci running here
10:15:10 <CirceOfAaea> :-)
10:15:35 <CirceOfAaea> map (\x->x+1) [1,2,3]
10:15:48 <skorpan> use > first
10:15:53 <skorpan> > map (\x->x+1) [1,2,3]
10:15:54 <lambdabot>   [2,3,4]
10:16:00 <EvilTerran> , intercalate " " ["actually,","there's","two","interpreters"]
10:16:00 <CirceOfAaea> Awesome
10:16:02 <lunabot>  luna: Not in scope: `intercalate'
10:16:10 <CirceOfAaea> :-)
10:16:12 <EvilTerran> ... but lunabot doesn't seem to know intercalate
10:16:18 <skorpan> other awesomeness is @djinn
10:16:20 <Gracenotes> > intercalate "\n\n" $ map (intercalate " " . map show) ["yes", "no", "maybe"] -- ImInYourMonad
10:16:22 <lambdabot>   "'y' 'e' 's'\n\n'n' 'o'\n\n'm' 'a' 'y' 'b' 'e'"
10:16:28 <CirceOfAaea> skorpan: Thanks
10:16:34 <CirceOfAaea> @dzinn
10:16:34 <lambdabot> Cannot parse command
10:16:40 <CirceOfAaea> @djinn
10:16:41 <lambdabot> Cannot parse command
10:16:43 <skorpan> @djinn a -> [a]
10:16:43 <lambdabot> Error: Undefined type []
10:16:46 <skorpan> oh, wait
10:16:55 <Gracenotes> ImInYourMonad: getting the arguments of the right type can be a pain, but they are rather convenient functions
10:17:18 <ImInYourMonad> makePrintable [[4,3,3],[3,2,4]] -> "4 3 3\n3 2 4\n"
10:17:21 <ImInYourMonad> is what iw ant
10:17:24 <skorpan> what did i do wrong with @djinn?
10:17:28 <Gracenotes> in fact, you can use unwords instead of intercalate " "
10:17:37 <CirceOfAaea> > unlines ("Circe":"is":"a":"formidable":"sorceress.":[])
10:17:38 <lambdabot>   "Circe\nis\na\nformidable\nsorceress.\n"
10:18:02 <CirceOfAaea> > putStrLn $ unlines ("Circe":"is":"a":"formidable":"sorceress.":[])
10:18:04 <lambdabot>   * Exception: "<IO ()>"
10:18:07 <doserj> skorpan: djinn doesn't understand recursive types like [a]
10:18:07 <CirceOfAaea> Ok
10:18:07 <Gracenotes> ImInYourMonad: okay, I was just emulating what you had above
10:18:09 <Gracenotes> > unlines $ map (unwords . map show) [[4,3,3],[3,2,4]]
10:18:11 <lambdabot>   "4 3 3\n3 2 4\n"
10:18:27 <skorpan> doserj: but http://lambda-the-ultimate.org/node/1178 does it
10:18:30 <Gracenotes> unwords is like intercalate, but it uses a " " for you
10:18:34 <skorpan> @djinn a -> [a] -> [a]
10:18:34 <lambdabot> Error: Undefined type []
10:18:36 <CirceOfAaea> I think I will get back to ghci
10:18:41 <Gracenotes> unlines too, except it also appends an extra \n
10:18:42 <CirceOfAaea> What does djinn do?
10:18:49 <skorpan> @djinn a -> b -> c
10:18:49 <lambdabot> -- f cannot be realized.
10:18:52 <skorpan> what the...!
10:18:53 <Cheshire> it generates a program based on a type
10:19:00 <skorpan> yes, it's the inverse of a typechecker :P
10:19:07 <doserj> @djinn (a,b) -> a
10:19:08 <lambdabot> f (a, _) = a
10:19:14 <Cheshire> ?djinn (a -> a) -> (Maybe a -> (a,a))
10:19:14 <lambdabot> -- f cannot be realized.
10:19:20 <CirceOfAaea> Oh
10:19:21 <Gracenotes> @djinn (a -> c) -> (b -> c) -> Either a b -> c
10:19:22 <lambdabot> f a b c =
10:19:22 <lambdabot>     case c of
10:19:22 <lambdabot>     Left d -> a d
10:19:22 <lambdabot>     Right e -> b e
10:19:24 <Cheshire> ?djinn (a -> a) -> (Maybe a -> Maybe (a,a))
10:19:25 <lambdabot> f a b =
10:19:26 <lambdabot>     case b of
10:19:28 <lambdabot>     Nothing -> Nothing
10:19:30 <lambdabot>     Just c -> Just (a c, a c)
10:19:30 <CirceOfAaea> But that is not ingeneral possible right?
10:19:32 <Gracenotes> @src either
10:19:32 <BONUS> @djinn (a -> b -> c) -> b -> a -> c
10:19:33 <lambdabot> f a b c = a c b
10:19:34 <lambdabot> either f _ (Left x)     =  f x
10:19:36 <lambdabot> either _ g (Right y)    =  g y
10:19:45 <skorpan> CirceOfAaea: it generates any program which fits the type
10:19:53 <Gracenotes> @djinn c -> (b -> c) -> Maybe b -> c
10:19:54 <lambdabot> f a b c =
10:19:54 <lambdabot>     case c of
10:19:54 <lambdabot>     Nothing -> a
10:19:54 <lambdabot>     Just d -> b d
10:19:57 <Gracenotes> ^ maybe
10:20:22 <Gracenotes> CirceOfAaea: that's not always possible, though, you're right
10:20:27 <Gracenotes> @djinn a -> b
10:20:28 <lambdabot> -- f cannot be realized.
10:20:34 <Gracenotes> there's no general function going from a to b
10:20:38 <skorpan> Gracenotes: could you explain why that's not possible?
10:20:43 <skorpan> why not just f _ = 1?
10:21:00 <beelsebob> does 1 have type forall b . b?
10:21:04 <Cheshire> skorpan:  pinkElephant = pinkElephant has any type you give it
10:21:20 <BONUS> skorpan: f _ = 1 is (Num a) => b -> a
10:21:34 <Gracenotes> skorpan: suppose Data Public = Private Int, and you export the Public type but not Private constructor
10:21:37 <int-e> @type const undefined -- but @djinn only considers total functions, and this one isn't total.
10:21:39 <lambdabot> forall a b. b -> a
10:22:22 <Gracenotes> well, that's dealing with the module system. But the thing is, given any type b, you can't always come up with a value. Bottom being an exception, since every type has one.
10:22:29 <skorpan> so why not this: f x = x
10:22:39 <BONUS> f x = x is a -> a
10:22:45 <BONUS> its more restricted than a -> b
10:22:47 <skorpan> right
10:22:53 <skorpan> of course!
10:22:55 <CirceOfAaea> Gracenotes: so does it do some sort of database matching?
10:22:56 <int-e> @djinn a -> a
10:22:56 <lambdabot> f a = a
10:22:58 <skorpan> thanks for the explanations
10:23:09 <BONUS> basically you can't come up with some value out of thin air that holds for all types
10:23:18 <BONUS> except for undefined
10:23:21 <skorpan> is that some theorem or something? :)
10:23:25 <BONUS> but that's a barrel of wossname
10:23:28 <int-e> @type fix id -- *ducks*
10:23:29 <lambdabot> forall a. a
10:23:33 <pumpkin> zomg
10:23:38 <mauke> djinn is actually a theorem prover
10:23:43 <CirceOfAaea> oh
10:23:45 <CirceOfAaea> Ok
10:23:48 <CirceOfAaea> :mauke
10:23:49 <Gracenotes> CirceOfAaea: well, here's the source: http://code.haskell.org/lambdabot/Plugin/Djinn.hs
10:24:09 <Cheshire> it's very difficult to read
10:24:10 <int-e> @type (.)
10:24:12 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:24:17 <pumpkin> isn't most of djinn in its data files?
10:24:17 <Cheshire> there is a decision procedure for this subset of LK
10:24:31 <Gracenotes> you can think of it as trying to find a path from any type in the input to the output type
10:24:36 <Gracenotes> rather informally
10:24:55 <Gracenotes> @djinn (a -> b -> c) -> (a -> b) -> a -> c
10:24:56 <lambdabot> f a b c = a c (b c)
10:25:16 <int-e> and you can read the output type as a logical formula with '->' being implication.
10:25:27 <int-e> @type flip id -- modus ponens
10:25:29 <lambdabot> forall b c. b -> (b -> c) -> c
10:25:39 <BONUS> can djinn come up with the implementation for any combinator
10:25:49 <BONUS> :t on
10:25:51 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:26:10 <BONUS> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
10:26:11 <lambdabot> f a b c _ = a (b c) (b c)
10:26:30 <Gracenotes> oh, the Djinn source just starts a process and inputs/outputs into that. messy :x
10:26:34 <int-e> (modus ponens is built into the type system: if  f :: a -> b  and  x :: a, then  f x :: b; f x is really a proof for b in that model.)
10:26:46 <Gracenotes> @hackage djinn
10:26:46 <Cheshire> modus ponens aka Cut
10:26:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/djinn
10:27:26 <ImInYourMonad> toString xs = foldl (++) "" $ map (\x -> (unwords $ map show $ x) ++ "\n") xs
10:27:29 <ImInYourMonad> not prettier
10:27:38 <CirceOfAaea> Gracenotes: The source does not seem to be doing any unification magic at the surface at least
10:27:53 <CirceOfAaea> Is it just a hook to something else
10:27:55 <int-e> foldl (++) "" = concat. and you should prefer foldr there
10:27:56 <Gracenotes> the source I gave you just starts a process (popen)
10:27:58 <Gracenotes> yes, I realized :)
10:28:08 <Gracenotes> try the hackage link above
10:30:02 <int-e> ImInYourMonad: so toString xs = foldl (++) "" $ map (\x -> (unwords $ map show $ x) ++ "\n") xs = concat . map (x -> x ++ "\n") . map (unwords . map show) $ xs = unlines . map (unwords . map show) $ xs. toString = unlines . map (unwords . map show) -- which is what Gracenotes wrote earlier
10:30:51 <int-e> @src unlines
10:30:51 <lambdabot> unlines = concatMap (++ "\n")
10:31:02 <int-e> close enough.
10:34:37 <McManiaC> is there a way of using getLine without adding a new line?
10:35:00 <McManiaC> as in bash
10:35:05 <McManiaC>  echo -n "PC neustarten?  [j/N] "
10:35:05 <McManiaC>     read yesno
10:35:13 <skorpan> do { x <- getLine; let y = init x; ... } ;)
10:35:55 <mauke> McManiaC: huh?
10:35:58 <ImInYourMonad> why arent haskell lists fingertrees?
10:36:15 <skorpan> McManiaC: you don't happen to mean getChar?
10:36:31 <int-e> ImInYourMonad: you mean, why aren't finger trees the default?
10:36:31 <mauke> do putStr "PC neustarten?  [j/N] "; hFlush stdout; yesno <- getLine;
10:36:50 <int-e> ImInYourMonad: because iterating over a finger tree has quite a bit more overhead than iterating over a list
10:37:09 <int-e> ImInYourMonad: as Cale puts it, lists are our loops. and loops are fairly fundamental
10:37:46 <Cale> Also, finger tree sequences can't be infinite.
10:38:15 <McManiaC> thx mauke :)
10:38:25 <int-e> good point. they can't even be very lazy.
10:41:21 <Cheshire> @go  Theoretical Pearl  Chuch Numerals, Twice!
10:41:24 <lambdabot> http://www.comlab.ox.ac.uk/people/ralf.hinze/publications/Church.pdf
10:41:24 <lambdabot> Title: THEORETICAL PEARL Church numerals, twice!
10:41:47 <ImInYourMonad> ok
10:41:47 <ImInYourMonad> but Data.Sequence is a fingertree?
10:41:47 <ImInYourMonad> lists are our loops?
10:42:01 <int-e> Data.Sequence is a fingertree, yes.
10:42:15 <Cale> ImInYourMonad: Yeah, you can think of a list as a loop which has yet to occur.
10:42:30 <int-e> > foldl' (+) 0 [1..100] -- this is a loop in other programming languages
10:42:32 <lambdabot>   5050
10:43:16 <ImInYourMonad> yes
10:43:24 <ImInYourMonad> i see what you mean
10:43:30 <ImInYourMonad> for x in range(100)
10:43:46 <int-e> (or xrange)
10:44:11 <ImInYourMonad> how do i unimport something in ghci
10:44:20 <int-e> :m -Module
10:44:31 <Gracenotes> functional programming has different types of loops, in a sense :) Making a new list from an old one, accumulating throughout a list, etc.
10:48:49 <trofi> > showHex 123
10:48:50 <lambdabot>       Overlapping instances for Show (String -> String)
10:48:50 <lambdabot>        arising from a...
10:49:05 <trofi> > showHex 123 ""
10:49:05 <lambdabot>   "7b"
11:10:05 <m4nic> Hello everyone, Newbie question: I am playing with Text.XHtml and was wondering if it was possible to carry some kind of state. Like running it wrapped in a StateT. If so are there any examples of this. Or is it wiser to just pass the state along as an argument?
11:11:26 <Saizan> m4nic: Text.XHtml doesn't use a monad
11:12:06 <Saizan> m4nic: so you can just use a type like State YourState Html
11:12:53 <m4nic> ok
11:27:08 <mmorrow> does anyone know off hand if-possible/where to get nyse historical data (just care about 6mos back) that has a sample rate > 1/day ?
11:27:10 <alar> m4nic: or play with HXT
11:27:31 <mmorrow> (w/out paying)
11:30:15 <travisbrady> mmorrow: opentick maybe?
11:30:53 <BMeph> mmorrow: Yahoo! Financial, maybe? ;)
11:31:26 <travisbrady> BMeph: he wants more than 1 sample per day though
11:31:39 <mmorrow> BMeph: yahoo doesn't seem to have finer than day resolution
11:32:02 <mmorrow> travisbrady: cool, thx
11:32:11 * mmorrow tries
11:33:09 <mmorrow> travisbrady: oh nice, that looks like it might hit the spot :)
11:33:09 <travisbrady> i've been wanting to work with the OpenTick feed with Haskell for while actually, haven't gotten around to it yet
11:33:25 <BMeph> mmorrow: To get multiple samples in one day, yes, you'll have to go to a week's range or smaller, so that's a pain, but it's possible. :)
11:33:46 <travisbrady> mmorrow: yeah, i think the idea with opentick is that you could run a full on automated trading operation with it
11:33:59 <BMeph> But if Opentick does it more programmatically, more power to you. :)
11:34:07 <mmorrow> BMeph: this opentick looks nice
11:34:09 <mmorrow> yeah
11:34:49 <mmorrow> travisbrady: i'm mostly interesting in historical data atm, but i'll let you know if anything comes of this.
11:35:38 <travisbrady> mmorrow: cool
11:35:40 <BMeph> http://www.opentick.com/index.php?app=content&event=api looks most relevant to your interests (@mmorrow and travisbrady)
11:36:36 <mmorrow> BMeph, travisbrady: wow, this site is sweet.
11:36:48 * mmorrow starts to scheme
11:55:01 <yohan> hey
11:55:27 <yohan> I read a paper about haskell by Johan Hughes, called why functional programming languages matters
11:55:41 <yohan> don't really understand why programmers should use lazy evaluation, isn't that slower?
11:56:22 <mauke> why would it be slower?
11:56:24 <JuanDaugherty> yohan, haskells goal is expressivity not speed.
11:57:06 <BONUS> well most of the time with lazy evaluation nothing is really done, and doing nothing is faster than doing something
11:57:09 <BONUS> hehe
11:57:11 <skorpan> i wouldn't say expressivity is the goal of haskell
11:57:28 <JuanDaugherty> (concise expressivity)
11:57:40 <asgaroth> composability and correctness are probably among the top goals
11:57:56 <skorpan> pureness also
11:58:05 <vixey> slower because you have less predictable memory usage, more bookkeeping by the RTS, larger distance between hardware and language and lack of mutation means log n algorithmic slowdown for many algorithms
11:58:08 * mauke misses preflex
11:58:08 <skorpan> maybe that's "purity"?
11:58:27 <asgaroth> isn't purity rather a way of achieving correctness(along with some optimization advantages)?
11:58:41 <vixey> yet:  it only take haskell less than a second to compute 4 factorial
11:58:47 <vixey> so it's not a problem in real world programming problems
11:58:57 <yohan> mauke: well duh, like doing it lazy
11:59:03 <skorpan> asgaroth: that's true
11:59:06 <yohan> its faster to do it in a for loop?
11:59:11 <mauke> yohan: laziness means doing less
11:59:15 <mauke> yohan: why wouldn't that be faster?
11:59:17 <yohan> mauke: yeah
11:59:21 <JuanDaugherty> in general, only inexperienced programmers worry about optimization before it's time to do so.
11:59:25 <yohan> Because you are doing less things
11:59:30 <BONUS> also space complexity is usually better
11:59:31 <yohan> Or?
11:59:31 <mauke> ... yes?
11:59:43 <asgaroth> algorithmic optimization is much more important 99% of the time anyway
11:59:46 <mauke> doing less = taking less time
11:59:48 <yohan> yeah, so you are doing less things in a smaller time-frame
11:59:50 <vixey> yohan, say I went to the shops and bought some things and then I went for a walk up a hill and came back
11:59:53 <olsner> the fastest way to sort a million integers is not sorting a million integers, etc :)
11:59:53 <yohan> but I wanna do everything
12:00:01 <mauke> yohan: no, you don't
12:00:02 <vixey> yohan, would that take longer than just going to the shops and coming back? (being lazy)
12:00:05 <yohan> olsner: incorrect
12:00:12 <jkup> or you doing less things? or are you doing things to make less work for the machine? what are your goals?
12:00:21 <jkup> s/^or/are/
12:00:26 <yohan> vixey: yeah?
12:00:36 <vixey> yohan, I'll let you think about it for a couple days
12:00:44 <yohan> vixey: but what if you need to get cash from the hill? then u cant buy stuff
12:01:15 <QtPlatypus> Though the lack of structures with O(1) access speeds kills a number of algorythmic optimisations.
12:02:08 <thoughtpolice> yohan: laziness is a good thing. it helps a lot, by a) keeping us 'honest' and b) letting is write code that is more natural and obviously correct.
12:02:18 <asgaroth> QtPlatypus: Which structures with constant access speeds does haskell lack compared to other languages?(We have mutable arrays, zippers,...)
12:02:33 <JuanDaugherty> haskell is built for X, not speed.
12:02:58 <yohan> thoughtpolice: keeping us honest_
12:03:06 <olsner> lots of things in haskell *are* built for speed though
12:03:15 <yohan> what do you mean by "letting is write code"?
12:03:24 <JuanDaugherty> yes, but haskell itself isn't
12:03:31 <QtPlatypus> asgaroth: hashes.  And the mutable arrays are not well publisized.
12:04:24 <asgaroth> QtPlatypus: this could probably used for hashes: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Mem-StableName.html
12:04:34 <thoughtpolice> yohan: by 'keeping us honest' i mean that if you want a lazy language, it had better be pure. purity is the only way lazy evaluation makes sense - and purity is really good. if we adopt laziness, purity is the only reasonable way to go.
12:04:45 <thoughtpolice> yohan: i mean't "letting us write code that is etc. etc"
12:04:50 <thoughtpolice> argh
12:04:54 * thoughtpolice hasn't woken up yet
12:05:26 <yohan> dunno why we need to be pure
12:05:33 <BONUS> show me a language that's "build for speed" and i'll show you a language that takes ages to code anything in
12:05:42 <yohan> BONUS: Fortran
12:05:44 <yohan> its awesome
12:05:44 <olsner> JuanDaugherty: I guess that's true, which really is awesome - haskell is a language that actually allows performant implementations while in itself not being built for speed but for X
12:05:55 <yohan> worked well since the 70s
12:05:57 <yohan> even before that
12:05:58 <vixey> yohan, why do we need to wear a grey t-shirt?
12:06:06 <BONUS> yohan: if it's pure, that means that the data doesn't change. if we call a function with the same params, we get the same result, so it doesn't matter when we evaluate it
12:06:27 <yohan> vixey: what?
12:06:28 <BONUS> if there was no purity but laziness, your program could give different results each time, based on when the functions were actually evaluated
12:06:40 <vixey> yohan, same anwer to your question as to mine
12:06:56 <yohan> vixey: and yours was?
12:07:11 <thoughtpolice> yohan: purity makes it easier to test and reason about your code.
12:07:17 <thoughtpolice> it's awesome. ;)
12:07:42 <asgaroth> It also makes the compilers job much easier
12:07:46 <Botje> coding in impure languages is like eating spaghetti with a barbecue fork
12:08:01 <Botje> at least that was my experience two days ago :)
12:08:07 <Botje> long time no imperation!
12:08:08 <olsner> like eating soup with a rubber fork
12:08:14 <BONUS> Botje: did you manage to eat anything at all
12:08:21 * thoughtpolice is actually writing a project in sml right now
12:08:26 <mynameisjoser> quick question for a newcomer to haskell:  how could i test that a value is of some type?  for example:   if var (typeof) Bool
12:08:41 <mauke> mynameisjoser: you don't
12:08:41 <Botje> BONUS: my team won 2nd place in the .. ehh .. spaghetti eating contest.
12:08:45 <asgaroth> mynameisjoser: the type of every value is known at compile time
12:08:47 <BONUS> hehe
12:09:27 <ztirF> anyone know why this code could possibly give a stack overflow:
12:09:29 <ztirF> mrank  x = (unsafeFreeze x :: IO (CArray i a)) >>= return . rank
12:09:34 <ImInYourMonad> mynameisjoser: post an example of what you are tying to do, normally oud patternmatch
12:09:40 <mynameisjoser> asgaroth: i'm working a small project for class, and we've defined our own types using the "data" syntax.  im writing a function to see if a particular variable is of that type.
12:09:43 <yohan> coolio
12:09:48 <mauke> mynameisjoser: you can't
12:09:50 <trofi> > let isBool :: Bool = True
12:09:51 <lambdabot>   <no location info>: parse error on input `;'
12:09:57 <trofi> > let isBool :: Bool = True in isBool "asd"
12:09:57 <lambdabot>   Couldn't match expected type `[Char] -> t'
12:10:09 <thoughtpolice> yohan: in reality, purity and laziness tend to work out really well
12:10:09 <ImInYourMonad> mynameisjoser: getVal (Mytype x) = x; i that is what you want
12:10:10 <yohan> so if you want to add an element to a list, you need to copy the entire list? Cause you cant modify the list?
12:10:14 <JuanDaugherty> olsner, "performant" isn't an English work, I don't think, but yeah.
12:10:19 <ImInYourMonad> to get the val out
12:10:25 <yohan> thoughtpolice: being a virgin and smoking weed?
12:10:27 <Botje> mynameisjoser: perhaps you mean "data constructor" instead of "type"
12:10:29 <asgaroth> mynameisjoser: there is no way to have an expression in your program of which you don't know the type at compile time.
12:10:32 <ImInYourMonad> yohan: lists share structure
12:10:39 <Botje> you have data Foo = Foo ... | Bar ... | Baz ...; right?
12:10:46 <JuanDaugherty> *word
12:10:53 <yohan> ImInYourMonad: cool
12:10:57 <thoughtpolice> yohan: you don't copy the list, you simply create a new element and make it share the same pointers
12:11:06 <yohan> thoughtpolice: ah k
12:11:08 <thoughtpolice> i.e. the original structure is 'shared'
12:11:17 <yohan> crap I gotta hit the shitter
12:11:58 <mynameisjoser> okay.  Botje is right, i mean data constructor.  i want to see if a variable of a type has a particular data constructor.
12:12:13 <asgaroth> mynameisjoser: pattern matching is the way to go then
12:12:18 <olsner> JuanDaugherty: hmm, "well-performing", or something then ... but I'm pretty sure there's a word like "performant" that you can use for that
12:12:19 <Botje> mynameisjoser: yes, then you want pattern matching :)
12:12:23 <asgaroth> isFoo (Foo x) = True; isFoo _ = False
12:12:32 <Zao> case x of ...
12:12:55 <olsner> (dictionary.com only lists a synonym of "performer")
12:12:56 <mynameisjoser> can you use pattern matching in a case statement?
12:13:03 <da-x> hey guys, let's say I have 'data x = X {a, b, c, d::Int}' and I want to have a function 'f :: x -> x' that takes an x and returns it but with the c field replaced with '2 :: Int'. What's the shortest way to implement such function?
12:13:08 <olsner> a case statement *is* pattern matching :)
12:13:18 <mynameisjoser> fantastic.  thanks guys.  i really appreciate the help.
12:13:25 <JuanDaugherty> if it were it would be something like an operator in a calculus of info systems like those of CAR Hoare or more pointedly Bjorge Langefors
12:13:39 <mauke> da-x: f x = x{ c = 2 }
12:13:44 <mynameisjoser> thanks Botje and asgaroth
12:13:51 <olsner> > let foo = () in case foo of
12:13:51 <lambdabot>   <no location info>: parse error on input `}'
12:13:52 <da-x> mauke: waw, thanks
12:13:53 <Botje> mynameisjoser: no problem, come by again soon! :)
12:13:56 <olsner> > let foo = () in case foo of {}
12:13:57 <lambdabot>   <no location info>: parse error on input `}'
12:14:10 <trofi> :t ({})
12:14:11 <lambdabot> parse error on input `{'
12:14:17 <trofi> :t ({;})
12:14:18 <lambdabot> parse error on input `{'
12:14:29 <olsner> hmm, maybe it's impossible to write a case expression without cases? :)
12:14:33 <Zao> > let x = Just "lol" in case x of Just n -> n; Nothing -> "nope"
12:14:34 <lambdabot>   "lol"
12:14:51 <olsner> > maybe "nope" (Just "lol")
12:14:52 <lambdabot>   Couldn't match expected type `a -> [Char]'
12:15:00 <olsner> fail :(
12:15:02 <trofi> > case undefined of _ -> True
12:15:03 <mauke> fromMaybe
12:15:03 <lambdabot>   True
12:15:32 <trofi> > case undefined of _ -> ()
12:15:33 <lambdabot>   ()
12:15:50 <trofi> > case () of () -> ()
12:15:50 <lambdabot>   ()
12:16:07 <trofi> @pl case () of () -> ()
12:16:07 <lambdabot> (line 1, column 8):
12:16:08 <lambdabot> unexpected " "
12:16:08 <lambdabot> expecting variable, "(", operator or end of input
12:16:12 <olsner> lambdabot should have something like a preview, so that you don't send it to the channel without having seen if your example showed what you thought it did :)
12:16:24 <asgaroth> olsner: /msg lambdabot
12:16:37 <dmwit> trofi: ?pl doesn't do case (and can't, in general).
12:16:47 <trofi> why?
12:16:50 <dmwit> > case undefined of () -> "suckers"
12:16:51 <lambdabot>   "* Exception: Prelude.undefined
12:16:57 <dmwit> trofi: Because not all data types have the appropriate functions.
12:17:07 <trofi> @pl if True then 1 else 1
12:17:07 <lambdabot> if' True 1 1
12:17:22 <olsner> asgaroth: yeah, but you don't usually think of that until after you've failed at least once in the channel
12:17:41 <drhodes> what does the pl in @pl stand for?
12:17:47 <trofi> pointless
12:17:51 <asgaroth> olsner: true
12:17:57 <trofi> @help pl
12:17:57 <lambdabot> pointless <expr>. Play with pointfree code.
12:18:14 <dmwit> ?pf \x -> f x
12:18:14 <lambdabot> Maybe you meant: bf pl
12:18:19 <dmwit> Aw, shucks. =)
12:18:30 <trofi> ?bf ++.
12:18:30 <ImInYourMonad> one thing I dont get is code-generation for different architectures, I mean I get for different OSes, you have a diferent ghc. but does GHC check when compiling, oh this compter us Intel so lets generate Intel-assembly?
12:18:30 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
12:18:43 <travisbrady> @hoogle if'
12:18:43 <lambdabot> No results found
12:18:51 <travisbrady> where does if' come from?
12:18:57 <trofi> @src if'
12:18:58 <Botje> @source if'
12:18:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:18:59 <lambdabot> if' not available
12:19:00 <pejo> Im, no, it's built in that it compiles for intel.
12:19:02 <dmwit> It's internal to ?pl.
12:19:05 <mauke> travisbrady: from @pl
12:19:11 <olsner> ImInYourMonad: current ghc's are compiled for the specific architecture, so that the ghc compiled for intel generates intel
12:19:20 <Botje> trofi: it's a common function usually defined as if' c t e = if c then t else e
12:19:24 <dmwit> travisbrady: But it's really easy to define: "if' p x y = if p then x else y".
12:19:35 <travisbrady> mauke: so is that code compilable then?
12:19:44 <travisbrady> dmwit: ahh, thank you
12:20:37 <drhodes> I thought ghc compiles down to C where gcc takes over -or- the the evil mangler stictches together ASM?
12:20:45 <mauke> no
12:20:54 <mauke> the evil mangler is for postprocessing gcc output
12:20:59 <trofi> it has some backends
12:21:04 <Botje> drhodes: there's a custom ASM emitter nowadays
12:21:13 <Botje> which doesn't go via C and doesn't need mangling
12:21:14 <dmwit> GHC used to go via C.  You can still get that with -fvia-c.
12:21:17 <dmwit> But nobody does. =)
12:21:19 <trofi> native and -fvia-C
12:21:23 <Botje> .. except the -fffi people?
12:21:27 <ImInYourMonad> olsner: what i mean is i have a PC with windows, but i didnt download a windows+intel-ghc, just a windows one. so ghc checks what my computer is?
12:21:29 <drhodes> I see, :)
12:21:31 <Botje> or does the native backend also handle ffi?
12:21:39 <dmwit> Native can also do FFI.
12:21:41 <trofi> i think yes
12:21:46 <Botje> ImInYourMonad: windows is intel by definition.
12:21:51 <Botje> (well, x86)
12:21:54 <trofi> last amd64 bug was in native codegen AFAIU
12:22:05 <Botje> because that's the only platform windows runs on.
12:22:11 <pejo> Im, if you run Windows on an Alpha or similar GHC isn't going to work for you.
12:22:12 <ImInYourMonad> i downloaded ghc-core but i didnt see any code-generation, where can i see how diffferent haskell-constructs generate asm-code?
12:22:40 <ImInYourMonad> amd64 cant run windows?
12:22:42 <trofi> @go RWH ghc-core
12:22:44 <dmwit> Maybe these questions would be better answered in #ghc.
12:22:45 <lambdabot> http://www.cse.unsw.edu.au/~dons/blog/2008/08
12:22:45 <lambdabot> Title: Haskell hacking
12:22:48 <Botje> ImInYourMonad: sure it can.
12:22:53 <Botje> amd64 is compatible with x86
12:23:08 <ImInYourMonad> so for linux there are different compilers? or one compiler that checks architecture?
12:23:09 <michaelcdever> hey, i know that using >>= i can chain a single function into more functions, but is there a way to pass several functions into more functions?
12:23:10 <trofi> windows has x86-64 port
12:23:21 <dmwit> ImInYourMonad: There are different compilers.
12:23:35 <Botje> michaelcdever: can you give a code example?
12:23:38 <mauke> ImInYourMonad: ghc -keep-s-file
12:24:03 <dmwit> :t liftM2 -- michaelcdever ?
12:24:04 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:24:42 <dmwit> :t sequence -- related
12:24:42 <michaelcdever> well ok, say i do, windowNew >>= (\m -> do something) thats fine
12:24:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:25:10 <michaelcdever> say i wanted to pass two windowNew functions into another?
12:25:22 <mauke> what?
12:25:27 <Botje> windowNew >>= \w1 -> windowNew >>= \w2 -> ...
12:25:37 <Botje> michaelcdever: but you do know that do syntax is handier for this, right?
12:25:54 <Botje> do { w1 <- windowNew; w2 <- windowNew; ... }
12:25:55 <michaelcdever> i.e. id end up with something like (\m n)?
12:26:10 <michaelcdever> sorry (\m n -> do something with m and n )
12:26:16 <mauke> michaelcdever: no, you'd end up with  windowNew >>= \w1 -> windowNew >>= \w2 -> ...
12:26:18 <Botje> michaelcdever: no, in my example, the binding for w2 scopes across everything on its right.
12:27:07 <dmwit> replicateM 2 windowNew >>= \[m, n] -> ...
12:27:31 <Botje> time for ETQW
12:27:50 <dmwit> liftM2 (,) windowNew windowNew >>= uncurry (\m n -> ...)
12:28:22 <dmwit> do { w <- windowNew; w' <- windowNew; ... } -- so many options!  okay I'm done now
12:28:45 <dmwit> :t uncurry
12:28:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:29:21 <michaelcdever> ah ok, right that was probably me just being stupid
12:29:39 <michaelcdever> what i was thinking of doesn't make sense anyway
12:31:57 <McManiaC>         newContent (n:ns) c = newContent ns (removeN n c)
12:31:57 <McManiaC>         newContent [] c     = c
12:32:06 <McManiaC> is there any way to get rid of that tailrecursion?
12:32:53 <olsner> @src foldr
12:32:53 <lambdabot> foldr f z []     = z
12:32:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:32:55 <mauke> foldl (\z x -> removeN x z) c ns
12:33:18 <McManiaC> >.>
12:33:37 <McManiaC> ive been trying to do this for like an hour with foldr, map map etc
12:34:33 <vixey> newContent (n:ns) c = removeN n (newContent ns c)
12:37:21 <ztirF> ow.  Coding for arbitrary dimensions is hard
12:38:17 <olsner> you forgot the obligatory "let's go shopping"
12:38:20 <olsner> :)
12:39:45 <ztirF> olsner: I don't know that joke - where's it from?
12:39:55 <olsner> @quote shopping
12:39:56 <lambdabot> samc says: monads are hard. let's go shopping!
12:39:59 <olsner> @quote shopping
12:39:59 <lambdabot> mauke says: reading existentials is hard. let's go shopping!
12:40:03 <ImInYourMonad> how is Data.Set implemented? red-black-trees?
12:40:05 <olsner> @quote shopping
12:40:06 <lambdabot> samc says: monads are hard. let's go shopping!
12:40:14 <ztirF> haha
12:40:29 <olsner> I think it comes from somewhere else originally
12:40:30 <ImInYourMonad> so is it possible to generate Main.s, optimize it, and then compile that file to .exe?
12:40:35 <vixey> barbie says math is hard
12:40:49 <mauke> ImInYourMonad: what do you mean by "optimize it"?
12:41:19 <ztirF> I have to ask, but I know I'm not going to like the answer: why aren't tuples foldable?
12:41:41 <mauke> they probably are with some kind of generic fold
12:41:53 <mauke> but in general, tuples of different lengths have different types
12:42:10 <ImInYourMonad> mauke: well i meant change it
12:42:23 <mauke> ImInYourMonad: probably
12:42:57 <dmwit> ImInYourMonad: Data.Set are finger trees, I think.
12:43:33 <dmwit> ztirF: What would a fold on a tuple mean?
12:44:02 <ztirF> dmwit: same thing as it does on a map.  The tuple would have to be homogeneous, of course.
12:44:12 <ztirF> err list not map
12:44:39 <dmwit> If you know the tuple is homogeneous, why aren't you using a list?
12:44:51 <ztirF> because arrays are indexed using tuples
12:44:59 <dmwit> Aha!
12:45:04 <dmwit> You need my Ix instance for lists.
12:45:23 <dmwit> http://www.dmwit.com/MultiArray.hs has it
12:45:35 <dmwit> Or it would, if that file existed...
12:46:02 <dmwit> http://www.dmwit.com/programming/MultiArray.hs, I mean
12:49:02 <ztirF> cool - if I use that with stream fusion there should be no slowdown versus Ix tuples, right
12:49:24 <ztirF> this code is in the inside of a loop so it does matter a bit
12:50:31 <Gracenotes> @src unlines
12:50:31 <lambdabot> unlines = concatMap (++ "\n")
12:50:45 <Gracenotes> @src intercalate
12:50:45 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
12:50:58 <Gracenotes> @src intersperse
12:50:59 <lambdabot> intersperse _   []     = []
12:50:59 <lambdabot> intersperse _   [x]    = [x]
12:50:59 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
12:57:08 <dmwit> ztirF: Oh, I have no idea about how fast it is.
12:57:14 <dmwit> ztirF: It could be very slow indeed.
12:57:19 <ztirF> heh, guess we'll find out
12:57:24 <Phillemann> I have a (basic) question regarding pattern matching. Is pattern matching expressions only possible with the (:) operator? I can see that when calling "function (x:xs)" with, say, "a:b:[]", x is matched with a and xs with b:[], but I cannot declare a function "function (x+xs)" where this applies to, say, "a+b+c"
12:57:47 <dmwit> Phillemann: Pattern matching is allowed with any constructors.
12:57:52 <dmwit> (:) and [] are constructors.
12:58:02 <dmwit> So are, say, (Left x) and (Right y) for the Either data type.
12:58:11 <Phillemann> (:) is a constructor?
12:58:13 <dmwit> (*) is a function, not a constructor, so you can't pattern match on it.
12:58:16 <dmwit> Phillemann: yes
12:58:21 <vixey> Phillemann, you can use  f (n+1) = ...
12:58:37 <dmwit> (+) is a little bit special... but don't get started down that road, it only leads to pain.
12:58:40 <Zao> vixey: Isn't that an extension?
12:58:49 <dmwit> Zao: Nope, that's pure H98.
12:58:50 <dmwit> =/
12:58:54 <vixey> Phillemann, but not, f (n+m) = ..., because there could be lots of solutions
12:59:01 <vixey> Zao, no
13:00:09 <dmwit> Phillemann: As a rule, things in the term namespace that start with an upper case letter or a colon are constructors; nothing else is.
13:00:14 <Phillemann> dmwit: So there's stuff defined in the language just for operator +?
13:00:26 <dmwit> Phillemann: Well... sort of.
13:00:50 <dmwit> Phillemann: There's a "hack" that lets you pattern match on (n+k) patterns, for statically-known values of k.
13:01:02 <dmwit> Phillemann: Which essentially matches on the pattern n, then subtracts k.
13:01:04 <Phillemann> Hmmm. What I like about Haskell so far is that it doesn't make a lot of exceptions. Like "integers are magically defined, so are the operators on it"...
13:01:15 <dmwit> Phillemann: Yeah.
13:01:25 <vixey> Phillemann, Haskell is no exception
13:01:26 <dmwit> Phillemann: n+k patterns have since fallen out of favor with a lot of people.
13:02:10 <dmwit> > let f (n+1) = n in f 1
13:02:12 <lambdabot>   0
13:02:14 <dmwit> > let f (n+1) = n in f 0
13:02:15 <lambdabot>   * Exception: /tmp/5491298701337586832:71:44-54: Non-exhaustive patterns in ...
13:02:18 <olsner> dmwit: and compares to >= 0 after subtracting k
13:02:18 <dmwit> nasty, see?
13:02:40 <Phillemann> Hmmm
13:02:56 <dmwit> But just don't use that, and you'll be fine.
13:03:21 <xcvvc> another important constructor is (,) (pairs): f (x,y) = x+y
13:03:21 <dmwit> Everything else about pattern matches is totally regular and beautiful. =)
13:03:22 <dmwit> xcvvc: Oh, good point.
13:03:29 <dmwit> (,) and (,,) and (,,,) and so on
13:04:02 <olsner> @ty let f (n+1) = n in f
13:04:03 <lambdabot> forall t. (Integral t) => t -> t
13:05:38 <sporkbomb> May I please have your opinion on the following? --> http://pastebin.com/m3fcafe03
13:05:54 <sporkbomb> I'm just wondering if there is a best practice -- regardless of the language
13:06:09 <dmwit> Maybe you should ask in #python. ;-)
13:06:25 <dmwit> In Haskell, best practice is
13:06:27 <vixey> sporkbomb ask #python or whatever that it
13:06:35 <dmwit> when (x != 0) (doStuff >> doMoreStuff)
13:06:39 <sporkbomb> crap ... sorry guys
13:06:44 <sporkbomb> obviously wrong window
13:06:51 <vixey> it's fine
13:06:55 * sporkbomb is ashamed of his brain fart
13:07:05 <travisbrady> sporkbomb: example02 is better in my opinion, more explicit
13:07:06 <dmwit> Or
13:07:20 <dmwit> unless (x == 0) (doStuff >> doMoreStuff) -- depending on which one reads better
13:07:28 <sporkbomb> travisbrady: that was my initial gut instinct ... but I am trying to imagine much more code
13:07:39 <dmwit> Both can work, depending on what you're doing.
13:34:46 <dejones_work> Any suggestions on how to specify the username for getting a darcs repos from community.haskell.org?
13:34:55 <jeltsch> Hello, is there any library which provides a â€œfractionâ€ data type, i.e., a type whose values correspond to the reals in the interval [0,1] or to percentages in the interval [0 %, 100 %]?
13:35:45 <jeltsch> dejones_work: darcs get username@community.haskell.org:/... if you go via SSH.
13:36:06 <dejones_work> jeltsch, thanks
13:38:45 <pejo> jeltsch, that sounds like stuff that Thomas Anberrée's thesis has the foundations for.
13:39:16 <jeltsch> pejo: Whatâ€™s the ? in "Thomas Anberr?e"?
13:39:39 <pejo> jeltsch, e with a ' above.
13:40:14 <davidad> jeltsch, pejo: no need to do fancy stuff like that if you actually only need rationals in [0,1]
13:40:39 <pejo> davidad, oh, doh. I misinterpreted his question.
13:40:46 <davidad> in which case I think you can use two unsigned integers, numerator and denominator - numerator
13:41:37 <pejo> jeltsch, sorry, disregard what I said and go for davidad's answer instead. :-)
13:41:55 <Eridius> how come regex-tdfa links against parsec-2.1.0.1 by default instead of parsec-3.0.0?
13:42:06 <jeltsch> I donâ€™t need anything complicated.
13:42:25 <jeltsch> I just wanted to make the progress bar in Grapefruit a bit more type safe.
13:42:47 <jeltsch> A progress bar shouldnâ€™t take arbitrary reals as its fraction but only reals between 0 and 1.
13:43:18 <jeltsch> And it definitely should not take integers like, for example, the progress bar in Gtk2Hs does.
13:43:43 <jeltsch> A progress bar can show any real percentage between 0 % and 100 % in principal.
13:43:46 <vixey> jeltsch, [Bool]
13:44:18 <jeltsch> Itâ€™s just that common GUI toolkits only support integers.
13:44:30 <wli> Continued fractions with 0 for the first element. ;)
13:45:04 <jeltsch> I just wanted to know whether such a data type already exists, not how I could define one (although your suggestions are interesting ;-) ).
13:45:06 <vixey> yeah written in base 2
13:45:31 <jeltsch> I just want to improve interoperability by reusing libraries.
13:47:26 <sioraiocht> can anyone help give me some hints about to write "append" for finger trees?
13:48:03 <jeltsch> Okay, no suggestions?
13:48:10 <jeltsch> Then Iâ€™ll leave. :-)
13:48:14 <jeltsch> Bye.
13:52:27 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2132#a2132 <- error message when installing GLUT with cabal. opengl installs successfully but im missing the GLUT-header. where can I find it and where am I supposed to put it?
13:57:13 <eu-prleu-peupeu> :)
13:58:01 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2134#a2134 <- Main.s, assembly geenrated by ghc. I hardly know any assambly at all more than mov eax for example.
13:58:21 <ImOuttaYourMonad> what does each instructuon do? does asembly have anything like procedure or function+
13:59:46 <pejo> Im, you need a book or a tutorial or something similar, teaching assembly is a bit out of scope for this channel. On top of this you're trying to follow complex code.
14:01:04 <eu-prleu-peupeu> haskell should have an equivalent to the __asm__ :P
14:01:08 <eu-prleu-peupeu> the gnu version
14:01:12 <eu-prleu-peupeu> and a goto
14:01:26 <eu-prleu-peupeu> gotos are whats missing in haskell
14:01:32 <czShadoW> Haha, awesome.
14:01:43 <jkup> compile something with ghc -C .. there will be gotos
14:02:45 <vixey> goto breaks purity
14:03:09 <vixey> it would expose evaulation order for example
14:03:32 <vixey> you can use goto in an embedded language though
14:03:59 <vixey> (some mixture of ST and Cont would give a straight forward implementation)
14:05:18 <Eridius> hrm, why isn't Real World Haskell in the Kindle store? :P
14:10:43 <vixey> Haskell is a mistake, carried through to perfection. It is the language of the future for the programming techniques of the past: it creates a new generation of coding bums.
14:11:40 * cjb raises an eyebrow
14:12:15 <lament> Haskell is APL?
14:12:35 <sioraiocht> no?
14:13:06 <ImInYourMonad> isnt that a quote about lisp?
14:13:11 <ImInYourMonad> or ah apl?
14:13:36 <Cale> vixey: ã¸ãˆãˆãˆã€‚ã€‚ã€‚ã©ã†ã—ã¦ï¼Ÿ
14:14:17 <dmwit> I really like the Japanese ?.
14:14:24 <dmwit> Such a friendly, bubbly shape.
14:14:54 <rfgpfeiffer> > pl \n -> foldl (.) id . replicate n
14:14:55 <lambdabot>   <no location info>: parse error on input `\'
14:15:13 <dmwit> ?pl \n -> foldl (.) id . replicate n
14:15:13 <lambdabot> (foldl (.) id .) . replicate
14:15:27 <Adamant> did Djiksta ever actually write any programs, anyway?
14:15:32 <dmwit> > "this is for running Haskell expressions, silly"
14:15:33 <Adamant> I mean, Knuth did TeX.
14:15:33 <lambdabot>   "this is for running Haskell expressions, silly"
14:15:54 <Adamant> *Djikstra
14:16:30 <ImInYourMonad> vixey: are you a 19-year-old girl from california? or is that vixen?
14:16:35 <ImInYourMonad> @seen vixen
14:16:36 <lambdabot> I haven't seen vixen.
14:16:38 <ImInYourMonad> @seen vixey
14:16:39 <lambdabot> vixey is in ##logic and #haskell. I last heard vixey speak 5m 55s ago.
14:17:05 <mstr> 19-year-old girl who codes haskell, right
14:18:00 <ImInYourMonad> + lives in california
14:18:11 <lament> vixen, vixey, all the same
14:19:34 <dmwit> ?vixen asl?
14:19:34 <lambdabot> 19/f/California
14:19:55 <dmwit> ?vixen Well aren't you a cute one?  Are you busy tonight?
14:19:55 <lambdabot> awww, you're too sweet to say that!
14:20:36 <mstr> http://marvin.hb0da.org/~beavis/archive/files/scene.org.jpg
14:21:21 <dmwit> priorities
14:21:23 <dmwit> he has them
14:21:50 <vixey> ã€‚_
14:22:41 <cjb> one of these days men on IRC will talk about women as if they were equals rather than cute young things that occasionally do something silly like show traces of intelligence
14:22:52 <mstr> i lold
14:22:53 <lament> s/women/bots
14:22:55 <vixey> cjb I doubt it
14:23:03 <vixey> this is already 2009
14:23:16 <dmwit> I like to think I already do that.
14:23:27 <dmwit> I like to think I do it several times a day without even knowing it... =P
14:24:16 <lament> cjb: they're not always young.
14:24:40 <waterson> is there a way to *uninstall* a cabal module that I've installed?
14:24:54 <dmwit> waterson: Kind of.  You can unregister it.
14:25:00 <dmwit> If you know where the files are, you can then delete them.
14:25:01 <pejo> waterson, ghc-pkg unregister should unregister it.
14:25:35 <waterson> dmwit, pejo: gotcha...i'll give that a whirl
14:26:06 <ImInYourMonad> vixey \/
14:26:11 <ImInYourMonad> thats a heart
14:31:42 <vixey> "If a program is a solution to a problem than knowing that it terminates for any input is an important aspect of it being a solution. Often the best way to see that it is terminating is expressing it in a language where all programs terminate."
14:32:22 <ImInYourMonad> vixey: picture plz
14:32:58 <vixey> ImInYourMonad: stop
14:33:01 <Saizan> ImInYourMonad: such behaviour is not tolerable in this channel.
14:33:17 <vixey> ImInYourMonad: I'm going to ban you
14:35:26 <ImInYourMonad> no
14:35:26 <ImInYourMonad> dont be so drastic
14:35:26 <ImInYourMonad> ill stop
14:35:36 <ImInYourMonad> i cant help im a 16year old with a heart the size of a melon
14:35:48 <vixey> ImInYourMonad: go back to implementing tree algorithms then :p
14:41:38 <mle> In MY day we moved turtles around.
14:41:42 * mle waves a cane
14:41:50 <paczesiowa> how are bytestrings fused (Fusion.hs is empty module) ?
14:42:15 <vixey> mle uphill both ways
14:42:42 <vixey> paczesiowa, my impression was via lots of rewrite rules (not sure how true that is though)
14:46:12 <paczesiowa> vixey: there are no rewrite rules in bytestring sources (well no interesting ones)
14:48:40 <paczesiowa> vixey: only specialise-type of rules, no foldr/build and no stream fusion
14:50:25 <paczesiowa> and I need lines function working on bytestrings and based on stream fusion
14:51:37 <Gracenotes> paczesiowa: such a function is in http://www.cse.unsw.edu.au/~dons/streams/Data-List-Stream.html
14:51:56 <Gracenotes> oh, ByteStrings
14:52:09 <paczesiowa> Gracenotes: yeahL)
14:52:13 <paczesiowa> :)
14:52:22 <Gracenotes> I'm pretty sure the paper mentions converting between streams and ByteStrings
14:52:43 <Gracenotes> not positive if there's anything written to that effect...
14:53:32 <paczesiowa> which paper? stream fusion one? I don't think there's anything about bytestrings
14:53:49 <Gracenotes> must have been slides then
14:55:41 <Gracenotes> paczesiowa: there's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text , but that doesn't use ByteStrings afaik
14:56:00 <Gracenotes> there's http://hackage.haskell.org/packages/archive/text/0.1/doc/html/Data-Text-Encoding.html though
14:56:17 <Gracenotes> assuming it's at most UTF-8 encoded
14:56:51 <paczesiowa> Gracenotes: I don't need utf8, but I need speed (parsing a lot of syslog logs)
14:57:23 <scwizard> so coming from a C++ background I was thinking "oh no, Haskell doesn't have function overloading, how does it survive without it!"
14:57:28 <scwizard> and then I went :type (+)
14:57:30 <scwizard> and I realized
14:57:34 <Gracenotes> the description is "text: An efficient packed Unicode text type" :)
14:57:44 <scwizard> that function overloading is a hack, and always has been O_O
14:58:33 <vixey> scwizard: it's a hack yeah
14:58:40 <Gracenotes> overloading is rather ad-hoc
14:58:51 <vixey> scwizard: It would be great if someone thought of a better way to do it
14:58:58 <scwizard> getting my mind blown like this is exactly the reason I started learning haskell
14:59:10 <scwizard> vixey: there is a better way to do it,
14:59:16 <Gracenotes> overloading is dispatch based on number of arguments and/or types of arguments
14:59:20 <scwizard> it's called a robust type system
14:59:20 <vixey> scwizard: what is it?
14:59:40 <vixey> scwizard: can you elaborate a bit please
14:59:48 <scwizard> k, in a bit
15:00:06 <paczesiowa> Gracenotes: maybe I'll try it later, I'd prefer Char8 based bytestrings, but rewriting lines, from bytestring, to streams sounds hard (that function uses lists for 3 different purposes)
15:00:16 <scwizard> take deque->insert()
15:00:57 <scwizard> iterator insert ( iterator position, const T& x ); void insert ( iterator position, size_type n, const T& x ); template <class InputIterator> (iterator position, InputIterator first, InputIterator last);
15:01:01 <Gracenotes> paczesiowa: except, ByteStrings aren't terribly efficient
15:01:15 <scwizard> what the function insert in and of itself does, is take a position to insert something in, and a collection of values to insert
15:01:31 <Gracenotes> paczesiowa: the more string processing you do, the more using the 'text' package will pay off :)
15:01:42 <scwizard> so basically, there should be some type that represents a collection of values, instead of using a patchwork of incomplete types
15:02:55 <scwizard> ["gee a universal type for representing a collection of values", "what a novel concept"]
15:03:30 <vixey> scwizard: do you mean untyped?
15:03:34 <paczesiowa> Gracenotes: I only need reading, lines, splitAt. I have date parsing function hand tuned
15:03:37 <scwizard> vixey: ???
15:03:42 <bos31337> if you're processing ASCII syslog data, then bytestring will probably be fastest.
15:03:46 <vixey> scwizard: like lisp
15:03:55 <scwizard> I don't have experiance with lisp yet
15:04:05 <ImInYourMonad> im toying around with Parsec, it is very very nice!
15:04:20 <Gracenotes> paczesiowa: well, you might be better off if you keep it all in text. The functions provided are nearly the same; the only possible disadvantage is that there's no constructor to pattern match on (like (a:as))
15:04:31 <scwizard> but anyways, what I'm saying in this example, is that a collection of values is a type
15:04:54 <Gracenotes> paczesiowa: if you want to stick to ByteStrings, you can check out the source of lines/splitAt/etc. and rewrite them for ByteStrings
15:05:04 <ddarius> scwizard: Define "collection"
15:05:12 <scwizard> ddarius: well in this case a list of values
15:05:21 <scwizard> a list of whatever type the container is of
15:05:38 <bos> paczesiowa: why do you think you need to rewrite these things?
15:05:38 <scwizard> and there shouldn't be more than one way to force that type of thing in
15:05:39 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
15:05:55 <Gracenotes> paczesiowa: otherwise, I thought you had mentioned something about stream fusion... it just matters on what you're doing with them. It might be more speedy to use Text only; it shouldn't be difficult to switch.
15:06:27 <paczesiowa> Gracenotes: parsing dates needs fast indexing of bytestrings so Text wont do. Data.List.lines wouldn't work with bytestrings.
15:06:58 <scwizard> to put it more abstractly, the hacky way is to write an overloaded function "add" that accepts a variety of parameters, and the correct way is to have the function "add" take two numbers and add them
15:07:01 <skorpan> would someone explain to me what's haskellish about this? http://community.haskell.org/~eelco/logos/Haskell0.png
15:07:07 <bos> paczesiowa: use Data.ByteString.Char8.lines ?
15:07:18 <scwizard> s/a variety of parameters/a variety of parameters that are all various types of numbers/
15:07:20 <vixey> skorpan monads are like neuclear waste containers .. or something..
15:07:29 <paczesiowa> bos: I split input to lines, then I mapAccumL parsing function over it, and profiler says that mapAccum takes most of the time (mapAccum itself, not the pasing function)
15:07:35 <paczesiowa> bos: yes, of course
15:07:49 <skorpan> vixey: from what i've seen, monads can be seen as just about anything.
15:08:36 <bos> paczesiowa: are you aware that mapAccumL is non-strict?
15:09:07 <paczesiowa> skorpan: monads are warm and fuzzy, and there's this monad tutorial based on nuclear containers
15:09:20 <bos> paczesiowa: have you needed to increase the default stack size to run your program?
15:09:41 <skorpan> paczesiowa: oh, right, i think i remember that... wasn't that something about big fuzzy monsters though?
15:09:53 <paczesiowa> bos: no, testing on over 1m lines worked fine
15:09:54 <wli> Better to go the algebraic route and define it all in terms of fmap, return, and join.
15:10:45 <bos> paczesiowa: what does your code look like?
15:11:47 <paczesiowa> bos: gimme 2 minutes (I need to find eth cable for my laptop)
15:13:09 <ImInYourMonad> how is opengl supposed to be imported? import qualified Graphics.Rendering.OpenGL as O doesnt work for me. Could not find module `Graphics.Rendering.OpenGL'
15:18:08 <Cale> ImInYourMonad: are you using ghci or ghc?
15:18:20 <Cale> ImInYourMonad: Do you have the OpenGL package installed?
15:18:46 <beelsebob> ImInYourMonad: have you specified -package OpenGL
15:21:57 <paczesiowa> bos: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1775#a1775
15:23:20 <paczesiowa> bos: that readTime is so big, because when I had it split in many functions, ghc wouldn't inline/unfold/fuse them and it was slower
15:24:16 <ddarius> paczesiowa: Then you use an INLINE pragma.
15:26:22 <paczesiowa> ddarius: I'll make it prettier when it is fast enough:>
15:27:36 <paczesiowa> anyway, myMapAccumL takes 50% individual time. I think it would be faster if it got fused with lines
15:29:16 <ImInYourMonad> Cale: ghci
15:29:21 <ImInYourMonad> not specified anything
15:30:06 <ImInYourMonad> when compiling instead it works
15:30:16 <StoneToad> is there a preexisting function to take every Nth element of a list?
15:30:39 <travisbrady> StoneToad: !!
15:30:45 <Cale> ImInYourMonad: You might try -package OpenGL or something on the GHCi commandline.
15:30:46 <travisbrady> @src !!
15:30:46 <lambdabot> xs     !! n | n < 0 = undefined
15:30:46 <lambdabot> []     !! _         = undefined
15:30:46 <lambdabot> (x:_)  !! 0         = x
15:30:46 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:30:55 <Cale> ImInYourMonad: er, when running it
15:31:13 <bodq> @hoogle (a -> b -> c) ->
15:31:13 <lambdabot> Parse error:
15:31:13 <lambdabot>   --count=20 "(a -> b -> c) ->"
15:31:13 <lambdabot>                              ^
15:31:21 <bodq> @hoogle (a -> b -> c) -> ((a, b) -> c)
15:31:22 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
15:31:22 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
15:31:22 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
15:31:47 <StoneToad> travisbrady: so I do map (\a -> xs !! a) [1,3..12]?
15:31:51 <StoneToad> that feels really nasty
15:32:06 <ImInYourMonad> Prelude> -package OpenGL
15:32:14 <travisbrady> StoneToad: do you have a list of lists?
15:32:21 <travisbrady> if you just want the nth element just do
15:32:41 <travisbrady> > [1..10] !! 3
15:32:43 <lambdabot>   4
15:32:43 <sjanssen> StoneToad: you'd have to write the function yourself, but there is a better way
15:32:43 <StoneToad> I want say every even indexed element
15:32:57 <ziman> StoneToad, I'd use: let chunkBy n = map (take n) . takeWhile (not.null) . iterate (drop n) in map head . chunkBy n
15:33:09 <ziman> or by zipping with [1..] and filtering on fst
15:33:17 <travisbrady> another thing to note is that lists aren't really designed for lots of random access like that
15:33:23 <bodq> travisbrady: \a -> xs !! a === (xs !!)
15:33:55 <travisbrady> bodq: i can see that, but i wasn't sure why he was mapping that
15:34:07 <bodq> err, that was for StoneToad :)
15:34:20 <da-x> got a function that checks if a string ends with another string? couldn't find it on hoogle..
15:34:22 <StoneToad> travisbrady: that was my understanding of what you suggested,
15:34:26 <bodq> travisbrady: I missed the question anyway :)
15:34:49 <bodq> StoneToad: what was the original question?
15:34:56 <sjanssen> da-x: isSuffixOf from Data.List
15:34:59 <StoneToad> bodq: yea, I got burned once with (+(-1)) so I wanted to be careful
15:35:06 <ImInYourMonad> <interactive>:1:1: Not in scope: `package'
15:35:06 <ImInYourMonad> <interactive>:1:9: Not in scope: data constructor `OpenGL'
15:35:06 <ImInYourMonad> Pr
15:35:06 <ImInYourMonad> > [1..10] !! 5
15:35:06 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2135#a2135 <- what am i doing wrong with the =<< opeartor there?
15:35:07 <lambdabot>   6
15:35:24 <bodq> StoneToad: it's just -1 is retarded, everything else is fine
15:35:41 <vixey> - is terrible
15:35:52 <vixey> I am constantly amazed that this is part of Haskell
15:36:32 <bodq> maybe we need to adopt unicode
15:36:32 <Eridius> negative number constants is pretty much the only thing I think OCaml did better ;)
15:36:37 <StoneToad> this wasn't really a problem with -1, it was a problem with my understanding of partial function application... I somehow assumed that it would bind the -1 as the 2nd argument to (+) since it was after it...
15:36:51 <bodq> and then -1 will be (shortdash) 1 and (-) 1 will be (minus) 1
15:37:14 <StoneToad> bodq: sounds like a typing nightmare
15:37:20 <Eridius> bodq: sounds like a reading nightmare
15:37:29 <Eridius> typing â€“ is easy on OS X
15:37:31 <Eridius> âŒ¥-
15:37:56 <bodq> > (+ (-1)) 2 # should be 1? what's wrong with it StoneToad ?
15:37:57 <lambdabot>   <no location info>: parse error on input `;'
15:38:02 <Eridius> I like how OCaml uses ~3 for negative 3
15:38:03 <bodq> > (+ (-1)) 2 -- should be 1? what's wrong with it StoneToad ?
15:38:04 <lambdabot>   1
15:38:16 <beelsebob> Eridius: that's not a minus
15:38:20 <beelsebob> that's an en-dash
15:38:30 <travisbrady> ImInYourMonad: i'm not sure you want to be using Parsec if you're working with a large volume of data, have you looked at bytestring?
15:38:32 <Eridius> beelsebob: - â€“ â€” am I missing something?
15:38:35 <beelsebob> there's actually 4 different - like glyphs
15:38:38 <beelsebob> hyphen
15:38:40 <beelsebob> en-dash
15:38:41 <beelsebob> em-dash
15:38:43 <beelsebob> and minus
15:38:48 <bodq> Eridius: don't know about reading nightmare, short dashes are distinctly different
15:38:53 <Eridius> beelsebob: âˆ’
15:39:07 <Eridius> heh, Unicode Hex Input, then âŒ¥2212
15:39:10 <ImInYourMonad> travisbrady: im ust playing around with parsec to learn it. my data si simple to parse so thats not a problem
15:39:14 <bodq> Eridius: would meaningful spaces be better? -1 vs - 1
15:39:19 <beelsebob> Eridius: not saying it's imposible to produce on OS X â€“ just that it's not as easy as alt -
15:39:24 <beelsebob> because that's en-dash
15:40:11 <Eridius> bodq: I wouldn't mind making that distinction, but I think it's a bit late
15:40:18 <Eridius> beelsebob: hrm, looks like you're right
15:40:39 <bodq> Eridius: but maybe "portability nightmare" because microsoft's encoding will have minus where everyone else in the world has "terminate this program" character :)
15:40:45 <ImInYourMonad> input <- readFile path
15:40:45 <ImInYourMonad> --   return $ validate p input
15:40:50 <ImInYourMonad> cant i >>= that?
15:40:53 <ImInYourMonad> somehow
15:41:00 <pumpkin> @undo is your friend
15:41:01 <lambdabot> is your friend
15:41:06 <ImInYourMonad> make it one line
15:41:17 <ImInYourMonad> @friend
15:41:18 <lambdabot> Unknown command, try @list
15:41:24 <pumpkin> @. pl undo do input <- readFile path; return $ validate p input
15:41:25 <lambdabot> validate p `fmap` readFile path
15:41:30 <pumpkin> tada
15:41:33 <ImInYourMonad> @src AlanTuring
15:41:33 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:41:34 <pumpkin> of course
15:41:34 <Eridius> ImInYourMonad: readFile path >>= return . validate p
15:41:37 <Eridius> I think
15:41:38 <pumpkin> now you don't have the file anymore
15:41:47 <pumpkin> no return
15:41:54 <Eridius> ooh, fmap. even cleaner
15:42:07 <beelsebob> Eridius: IIRC there is an easy key combo for minus, but I don't remember it â€“ I used to know shit like this by heart from working in a publisher
15:42:22 <pumpkin> ImInYourMonad: but as I said, you lose your input <- that way
15:42:45 <Eridius> beelsebob: I'm not seeing anything other than -â€“â€” in Keyboard Viewer. Maybe your publishing house had a custom keymapping?
15:44:36 <dmwit> fmap (validate p) (readFile path)
15:44:54 <dmwit> Oh, it's already been suggested.
15:45:13 <beelsebob> validate p <$> readFile path
15:47:38 <ImInYourMonad> o instance for (Show (IO Bool))
15:47:38 <ImInYourMonad>       arising from a use of `print'
15:47:40 <bodq> funny
15:47:56 <bodq> ^s/^/--/ doesn't work if the line starts with a +
15:48:09 <pumpkin> print =<<
15:48:09 <ImInYourMonad> ah <-
15:48:50 <Gracenotes> bodq: -- can be part of a symbol
15:49:07 <bodq> yep
15:49:13 <bodq> but still it's funny
15:49:42 <bodq> haskell is the only language I know where 's/^/<comment leader>/' is not guaranteed to produce a comment :)
15:49:43 <Gracenotes> yeah. It's inconvenient :/ a space is all
15:50:48 <bodq>  [piece |  (j, piece) <- [(1, Rook), (2, Knight), (3, Bishop), (4, Queen) (5, King), (6, Bishop), (7, Knight), (8, King)]]
15:50:54 <bodq> -- what's wrong here??
15:51:23 <Gracenotes> bodq: well... in C and similar, you can do a line break with \
15:51:30 <bodq> [I get: Couldn't match expected type `t1 -> (t, Piece)'  against inferred type `(t2, Piece)'
15:51:41 <Gracenotes> oh, never mind, \* isn't exactly a comment
15:51:57 <JuanDaugherty> bodq: your experience of computer langs must be fairly limited.
15:52:26 <vixey> JuanDaugherty: why do you think that
15:52:28 <bodq> JuanDaugherty: indeed, I don't know branfuck too well for example :)
15:53:12 <JuanDaugherty> because of your statement that you'd never seen where where changing the first char on a line introduces a syntactically correct comment.
15:53:20 <JuanDaugherty> *seen a lang
15:53:30 <chessguy> 'evening
15:53:30 <lambdabot> chessguy: You have 1 new message. '/msg lambdabot @messages' to read it.
15:54:02 <JuanDaugherty> *char or token
15:54:06 <bodq> JuanDaugherty: ahem. that's a strange way to read that
15:54:32 <lament> speaking as a brainfuck expert, trying to comment stuff on a per-line basis can be pretty tricky.
15:54:45 <Eridius> ooh, I should write a brainfuck interpreter in haskell
15:54:51 * Eridius wrote one in REALbasic years and years ago
15:54:55 <omnihil> eridius, and a haskell interpreter in brainfuck.
15:54:56 <Gracenotes> not recommended as brainfuck comment characters: < > + - , .
15:54:57 <dmwit> bodq: You're missing a comma after (4, Queen).
15:55:01 <bodq> Eridius: you can probably do that with the type system :)
15:55:02 <Eridius> omnihil: .....owwwww
15:55:06 <Gracenotes> and [ ]
15:55:09 <dmwit> bodq: Also, you should be using map snd instead of a list comprehension.
15:55:10 <bodq> dmwit: Thanks! :)
15:55:20 <Gracenotes> Eridius: have you used zippers?
15:55:24 <ehird> 23:38 Eridius: I like how OCaml uses ~3 for negative 3
15:55:26 <ehird> no it does not
15:55:26 <JuanDaugherty> brainfuck is offensive ... as a waste of time and resources
15:55:26 <bodq> dmwit: right, that was a simplified example
15:55:29 <ehird> # ~3;;
15:55:29 <ehird> Error: Syntax error
15:55:35 <Eridius> Gracenotes: why do you need comment characters? the common thing to do is just ignore *all* characters that aren't brainfuck operations, which means you can write comments anywhere as long as they don't contain brainfuck operators
15:55:38 <Eridius> Gracenotes: I have not. why?
15:55:39 <dmwit> bodq: okay =)
15:55:45 <newsham> I like how C uses ~3 + 1 for negative 3
15:55:46 <ehird> JuanDaugherty: it's for fun...
15:55:49 <bodq> dmwit: I have something like [((i,j) piece) | i <- [...], (j, piece) <- [...]]
15:55:51 <Eridius> ehird: it doesn't? I don't use OCaml, but I thought that's what they went with
15:55:52 <lament> Eridius: the discussion was about commenting entire lines, probably of code
15:55:54 <ehird> JuanDaugherty: what's wrong with fun?
15:55:56 <ehird> Eridius: it's -
15:55:59 <Eridius> lament: ahh
15:56:07 <Gracenotes> Eridius: that's the joke. The 8 characters brainfuck syntactically recognizes are not recommended as comment characters. By default.
15:56:09 <Eridius> ehird: then where does ~3 come from?
15:56:13 <Eridius> Gracenotes: I see
15:56:14 <ehird> Eridius: C?
15:56:17 <lament> it is possible to comment brainfuck code bu putting it inside of [-][ code goes here]
15:56:18 <ehird> ~N + 1
15:56:22 <Gracenotes> -.-
15:56:23 <JuanDaugherty> that ain't what I call fun
15:56:23 <lament> provided all the brackets match up
15:56:25 <Eridius> ehird: no, not binary negation, numeric negation
15:56:27 <ehird> lament: comment, not code
15:56:38 <ehird> JuanDaugherty: gee, people have different hobbies to you, ya don't say?
15:56:44 <dmwit> bodq: I bet that doesn't do what you want it to do.
15:56:58 <newsham> eridius: ~3 + 1 is numeric negation
15:57:04 <bodq> dmwit: there's a comma missing in what I posted after (i,j) but otherwise why not?
15:57:10 <dmwit> Well... maybe it does.
15:57:17 <Eridius> newsham: yes but I'm not talking about binary representation here but syntax
15:57:20 <dmwit> Never mind me.
15:57:29 <dmwit> I'm making unwarranted assumptions about code you haven't even posted here. =P
15:57:29 <newsham> eridius: *nod* just being intentionally obtuse
15:57:30 <bodq> dmwit: I will know in a fre seconds :)
15:57:40 <JuanDaugherty> I didn't say I had a right not to be offended, just that I find it offensive as a concept and a reality
15:57:45 <Gracenotes> Eridius: but a zipper is rather basic... it has a focus character and two stacks. It's like navigating through a doubly-linked list
15:57:51 <omnihil> -3 is just syntactic sugar for ~3+1, so it is syntax.
15:57:59 <Gracenotes> it's just one technique
15:58:04 <ehird> JuanDaugherty: being offended at a joke programming language? how thin is your skin exactly?
15:58:04 <JuanDaugherty> it's to computing like bleeding is to medicine
15:58:11 <newsham> omnihil: depending on your conventions.
15:58:18 <Eridius> hrm, Haskell should support Â¬3 as negation
15:58:26 <ehird> Eridius: ++
15:58:31 <Gracenotes> eek, unicode
15:58:35 * Eridius cackles
15:58:46 <Gracenotes> JuanDaugherty: bleeding is pretty important, wouldn't you say? It's an important part of theory. Turing tarpits and all.
15:59:05 <newsham> data Nat = Z | S Nat;  what's ~(S Z) ?
15:59:19 <lament> JuanDaugherty: actually many people think brainfuck is offensive, because of the name
15:59:23 <bodq> dmwit: actually it works fine, not sure what you meant
15:59:28 <lament> JuanDaugherty: there was an attempt to get the offensive word out
15:59:33 <JuanDaugherty> yes just thought of that, could also have value in some sw eng studies
15:59:35 <lament> JuanDaugherty: and rename it to just "fuck"
15:59:45 <Gracenotes> data Int = Pos Nat | Neg Nat
15:59:55 <Eridius> lament: A+, would read joke again
15:59:58 <JuanDaugherty> actually the name is the only thing I like about it
15:59:59 <bodq> lament: but it /is/ brainfuck :)
16:00:16 <ehird> JuanDaugherty: people have been making these things for ages
16:00:20 <ehird> first was in 1972
16:00:23 <ehird> they don't harm anyone
16:00:27 <omnihil> brainfuck is minimalist and turing complete all at once. no other language really takes those two things to the same extreme.
16:00:32 <Gracenotes> > "lame" `isPrefixOf` "lament"
16:00:34 <lambdabot>   True
16:00:34 <ehird> omnihil: BCT
16:00:39 <vixey> omnihil, lambda calculus
16:00:45 <Eridius> brainfuck's design goal was to produce a turing-complete language with the smallest possible interpreter
16:00:45 <ehird> omnihil: http://esolangs.org/wiki/BCT
16:00:52 <ehird> Eridius: compiler
16:00:55 <Gracenotes> Unlambda
16:00:56 <newsham> > "nt" `isSuffixOf` "lament"
16:00:57 <lambdabot>   True
16:01:07 <dmwit> ?remember lament there was an attempt to get the offensive word out and rename "brainfuck" to just "fuck"
16:01:07 <lambdabot> Nice!
16:01:09 <ehird> Gracenotes: unlambda is more bloated than BF
16:01:11 <Eridius> ehird: was it a compiler? It was only 242 bytes (and IIRC it was later shrunk even further)
16:01:15 <ehird> yes, compiler
16:01:21 <Eridius> huh
16:01:22 <JuanDaugherty> ah, I thought it's name was its purpose.
16:01:24 <newsham> lament++
16:01:26 <ehird> but it was for the amiga
16:01:27 <Gracenotes> ehird: it is minimalist though, at least in syntax
16:01:27 <bodq> @hoogle ((a,b,c) -> d) -> (a -> b -> c -> d)
16:01:28 <lambdabot> No results found
16:01:32 <Eridius> ah
16:01:35 <bodq> hmm
16:01:37 <ehird> Gracenotes: not really, there's like 15 symbols
16:01:38 <JuanDaugherty> (having forgotten about the computing basis)
16:01:45 <ehird> no matching though
16:01:54 <bodq> @pl \(a,b,c) -> f a b c
16:01:55 <lambdabot> (line 1, column 6):
16:01:55 <lambdabot> unexpected ","
16:01:55 <lambdabot> expecting letter or digit, operator or ")"
16:01:55 <lambdabot> ambiguous use of a non associative operator
16:02:01 <Gracenotes> ehird: how many are required for Turing-completeness, though?
16:02:07 <ehird> 2.
16:02:13 <ehird> http://esolangs.org/wiki/BCT
16:02:15 <bodq> ummm
16:02:18 <ehird> if you prefer the functional flavor, 2.
16:02:22 <Gracenotes> ehird: I mean in Unlambda
16:02:25 <ehird> oh.
16:02:28 <ehird> 3.
16:02:30 <Fredrik> I have a question. When I say x = [1+2, 7*8] when and where are the result 3 and 56 stored? Are they stored inside the real list? Does that question even make sense?
16:02:30 <ehird> `, s and k.
16:02:46 <Gracenotes> yeah. Reasonably good, I think.
16:03:09 <bodq> Fredrik: they are not even computed unless you read them
16:03:21 <Fredrik> Yes, but when i say x, they are computed.
16:03:24 <tromp_> well, you need a symbol for application too, with s and k
16:03:26 <Fredrik> So are the results then stored?
16:03:30 <tromp_> or parentheses
16:03:37 <lament> tromp_: ` is application.
16:03:48 <tromp_> so that's 3 symbols in all
16:03:53 <chessguy> Fredrik:  no, using x does not mean they get computed
16:03:56 <lament> that's what ehird said
16:04:04 <tromp_> sorry, overlooked the `
16:04:04 <Gracenotes> one of my favorite esoteric languages is Befunge, though.
16:04:08 <ImInYourMonad> if i want to create a brainfuck interpreter, how do I use < > for their brainfuck purpose and not their normal use? and is parsec good for defining a parser for brainfuck or i should just code my own?
16:04:12 <chessguy> Fredrik:  e.g., if you do 'length x', it won't do either addition
16:04:23 <Fredrik> But when I type x into ghci, I get the results
16:04:25 <paczesiowa> http://barker.linguistics.fas.nyu.edu/Stuff/Iota/
16:04:27 <Gracenotes> ImInYourMonad: what's their normal use?
16:04:29 <paczesiowa> 2 symbols
16:04:33 <bodq> Fredrik: that calls "print x"
16:04:35 <tromp_> binary lambda calculus uses 2 symbols too
16:04:42 <ehird> tromp_: no
16:04:42 <bodq> Fredrik: which evaluates everything
16:04:43 <ehird> you need names
16:04:43 <Fredrik> Let's say somehow I get the results. Does the list then contain the real values? Or still just the computations?
16:04:57 <tromp_> blc uses no names
16:04:58 <|Nihil|> Hey guys... what's the most elegent way to make a function that, given an input list, gives back a list of lists of pairs representing all the bijections between the input list and itself? I.E., that would perform like this -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2136#a2136
16:05:03 <ehird> tromp_: oh, you mean '0' and '1'
16:05:03 <chessguy> Fredrik: reasoning about when things get evaluated in haskell is hard
16:05:05 <ehird> that is cheating
16:05:05 <Gracenotes> ehird: well, you can use unary names. 0, 00, 000, 0000, etc.
16:05:06 <ImInYourMonad> Gracenotes: why do you need to be like that? ehir normal use is for tests, here for icnremtn
16:05:06 <tromp_> yes
16:05:12 <lament> tromp_: 1 symbol, then.
16:05:13 <bodq> Fredrik: when lazy results are computed they are replaced by real values
16:05:17 <ehird> lament: exactly
16:05:18 <ehird> 1
16:05:19 <ehird> :P
16:05:21 <ImInYourMonad> data Pointer x = Cell x (Pointer x) | End x deriving(Show) , that is a a tree, bad rep of a pointer?
16:05:45 <bodq> Fredrik: but I hear it's not quite the full story for ghci command line
16:05:57 <Gracenotes> ImInYourMonad: how will you traverse backwards?
16:06:18 <Fredrik> OK, so if they are indeed replaced, how does x = 0 : 1 : zipWith (+) x (tail x) work? The list only consists of three cons-cells. How can all those values be stored? That totally confuses me.
16:06:22 <bodq> Fredrik: but in your program, x = a * b will only get computed once, and will be stored in memory on subsequent accesses
16:06:22 <tromp_> bcl is the most compact language, since you can embed binary data in it
16:06:26 <SubStack> > [ (a,b) | a <- [1..3], b <- [1..3] ]
16:06:27 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
16:06:36 <Gracenotes> ImInYourMonad: I'm not aware of parsec using <> for special values...
16:06:39 <tromp_> i mean blc
16:06:43 <Gracenotes> hm. If you say so.
16:06:53 <bodq> Fredrik: they are not stored unless you evaluate them
16:07:01 <bodq> Fredrik: whick you don't for the infinite list
16:07:22 <bodq> Fredrik: also if you just traverse the list, the head gets discarded because there are no references to it any more
16:07:33 <Fredrik> how soon does it get discarded?
16:07:39 <ehird> tromp_: BCT is more compact in semantics.
16:07:41 <|Nihil|> SubStack: hm, I'm hoping to have them in the six sublists like in the paste, so each sublist represents a possible mapping
16:07:44 <bodq> Fredrik: that's up to the GC
16:07:53 <SubStack> I've seen this before...
16:07:53 <tromp_> what's bct?
16:08:15 <Gracenotes> ImInYourMonad: what you have there is basically a list of x's. data List x = Cons x (List x) | Nil, except Nil has a value.
16:08:15 <ehird> tromp_: http://esolangs.org/wiki/BCT
16:08:22 <ImInYourMonad> data Pointer x = Cell x (Pointer x) (Pointer x) | End x deriving(Show) ?
16:08:26 <Saizan> ImInYourMonad: you usually take the input as a string and parse that with parsec, or you write a simple parsers like parse ('<':rest) = Increment : parse rest
16:08:34 <bodq> Fredrik: if you do 'take 10000000 x' that would probably lead to an out of memory error
16:08:45 <Saizan> ImInYourMonad: where Increment is a constructor of the datatype you'll use to represent brainfuck code
16:09:03 <ImInYourMonad> Gracenotes: ok i had 2 questions in one, 1. should i use Parsec? 2. if i dont, how cna i use < and > for my own purpose?
16:09:10 <bodq> Fredrik: but 'length (take 10000000 x)' would not, unless something holds a reference to the head of x
16:09:11 <Fredrik> hm, wait i made a mistake. that list is actually infinitely long, not three cons cells. boy infinite data structures are confusing.
16:09:26 <ehird> ImInYourMonad: what is its own purpose?!
16:09:27 <Gracenotes> ImInYourMonad: as Saizan mentioned, you can just parsec it using pattern matching
16:09:32 <bodq> Fredrik: there is no list :) just cons cells
16:09:35 <Gracenotes> *parse
16:09:40 <zachk> infinite data structues are confusing at first
16:09:41 <ImInYourMonad> ok
16:09:58 <Fredrik> and they are generated on demand, i see.. it somehow makes sense. still confusing for my "call by value brain" :)
16:10:02 <zachk> but infinite is just a process
16:10:17 <lament> tell aristotle that
16:10:17 <Gracenotes> beware of nested [], though :)
16:10:30 <Gracenotes> ImInYourMonad: I've seen it done with... data Pointer x = Pointer [x] x [x]
16:11:09 <bodq> Fredrik: that would be one of the least confusing things :) more to come
16:11:17 <Fredrik> Am I right in assuming that x = 0 : 1 : zipWith ... computes the numbers in linear time complexity?
16:11:19 <Gracenotes> so if you're navigating 1 2 3 4 5 and you're at the 3, your current state is [2, 1] 3 [4, 5]. Moving right, you have [3, 2, 1] 4 [5]
16:12:08 <bodq> Fredrik: yes, but also in linear memory
16:12:22 <bodq> I think
16:12:41 <Fredrik> unless i need each value only once and the gc kicks in? :)
16:13:18 <bodq> Fredrik: yes, but then there's also the GC overhead
16:13:31 <Fredrik> I don't mind GC overhead, I like how cool the solutions looks :)
16:13:33 <bodq> Fredrik: that's why tail-recursive solutions are probably faster
16:13:41 <bodq> Fredrik: but
16:13:46 <pejo> GC overhead is proportional to live memory, not garbage.
16:13:50 <Fredrik> How many fibonacci numbers do you really need?
16:14:10 <bodq> Fredrik: the only way you know for sure is to look at the core that the compiler generates
16:14:16 <bodq> Fredrik: ohh many :)
16:14:19 <ImInYourMonad> FredrikLundh?
16:14:34 <bodq> pejo: what overhead do you mean here?
16:14:43 <Fredrik> As soon as I break the 2^31 border, we're already better than Java :)
16:14:54 <Fredrik> no my name is not lundh if thats what you ask
16:15:05 <bodq> pejo: I was referring to constantly allocating/deallocating memory, maybe "GC overhead" was not the right term for that
16:15:27 <bodq> Fredrik: BigNum?
16:15:41 <bodq> OrWhatsItCalled
16:15:45 <Fredrik> BigInteger? Yeah, but come on... how ugly does that code look? :)
16:15:53 <pejo> bodq, if you fill your heap quickly with just garbage the collection is really cheap: just flip from and to-space and you're set to go again.
16:16:50 <ImInYourMonad> is happs mantained?
16:17:07 <Fredrik> > let x = 0 : 1 : zipWith (+) x (tail x)
16:17:07 <Fredrik> > length $ takeWhile ( < 2^31 ) x
16:17:09 <lambdabot>   <no location info>: parse error on input `;'
16:17:09 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
16:17:21 <Fredrik> > let x = 0 : 1 : zipWith (+) x (tail x) in length $ takeWhile ( < 2^31 ) x
16:17:22 <lambdabot>   47
16:17:36 <ddarius> ImInYourMonad: Nope.  There's happstack that continues it though.
16:18:10 <Fredrik> 47 numbers, thats not very much
16:18:15 <Fredrik> how about long
16:18:19 <Fredrik> > let x = 0 : 1 : zipWith (+) x (tail x) in length $ takeWhile ( < 2^63 ) x
16:18:20 <tromp_> thx for link, ehird. is there  a bug in the example execution?
16:18:21 <lambdabot>   93
16:18:26 <Fredrik> still less than 100
16:18:31 <ehird> tromp_: why would there be?
16:18:38 <bodq> Fredrik: but then you can be computing log(fib(n))
16:18:59 <tromp_> from 9th instruction on, there's no more appending to the data?
16:19:31 <tromp_> gonna grab bagel, back in 3 min
16:19:40 <ehird> tromp_: hm
16:19:45 <bodq> Fredrik: ok here's a puzzle for you
16:19:57 <bodq> Fredrik: you know how to compute fibonacci
16:20:00 <Fredrik> yes
16:20:06 <bodq> Fredrik: what about prime numbers oneliner?
16:20:07 <Fredrik> from wikipedia :)
16:20:16 <Fredrik> i doubt i can do it
16:20:26 <bodq> Fredrik: Yes You Can! [:)]
16:20:43 <bodq> everybody shold start chanting "Yes We Can"
16:20:53 <Fredrik> Let's see, the list of prime numbers consists of all numbers that have no other divisors besides 1 and itself
16:20:56 <dons> ?faq
16:20:56 <lambdabot> The answer is: Yes! Haskell can do that.
16:20:56 <Fredrik> can i express that nicely?
16:21:42 <bodq> Fredrik: here's a hint
16:21:48 <bodq> Fredrik: let primes = ...
16:22:11 <bodq> Fredrik: you take [2..] and remove ones that are not prime
16:22:19 <tromp_> let primes = [2,3,5,7..]
16:22:47 <tromp_> > [2,3,5,7..]
16:22:48 <lambdabot>   <no location info>: parse error on input `..'
16:23:00 <bodq> Fredrik: the point is, you already have /some/ primes computed in primes variable
16:23:21 <BMeph> Fredrik: Here
16:23:23 <Gracenotes> dons: so you go to/teach at UNSW? They've posted some useful lectures on YouTube about computing :) http://www.youtube.com/view_play_list?p=6B940F08B9773B9F
16:23:25 <bodq> so you can use them just like you do for fib
16:23:43 <BMeph> Fredrik: ... is another hint:
16:24:18 <BMeph> Fredrik: Make a function, say 'ld', that finds the Largest Divisor of a number.
16:24:55 <BMeph> Fredrik: Then, all of the primes should be numbers whose largest divisor is the number itself. :)
16:25:49 <BMeph> Fredrik: Ooh, no that doesn't work. Okay, find the Least divisor, that way, you can still call it 'ld'. ;)
16:25:50 <omnihil> http://okmij.org/ftp/Algorithms.html#Eratosthenes-sieve
16:26:16 <dons> Gracenotes: that's my comp1A lecturer, richard buckland.
16:26:20 <dons> taught me haskell in 1999
16:26:29 <bodq> BMeph: the goal is not just to find primes, but to implement the sieve in the nice self-consuming way akin to aforementioned Fibonacci computation
16:26:29 <dons> oh my. 10 years ago
16:26:45 <Gracenotes> wow. neat! He's very enthusiastic.
16:27:31 <bodq> dons, omnihil, ahaha, I've seen some of these lectures -- very funny and engaging
16:27:37 <ImInYourMonad> but should I construct a tree and a pointer is a node?
16:27:43 <dons> so wow, 10 years, 1 month, 5 days of Haskell.
16:28:01 <osfameron> hehe http://www.flickr.com/photos/kaptainkobold/3327269677/
16:28:02 <bodq> dons: and look how far you've got :)
16:28:04 <BONUS> im clocking in at 1 year soon
16:28:12 <osfameron> (oops, wrong chan, sorry)
16:28:23 <BONUS> in april i believe
16:28:27 <ImInYourMonad> happstack == HJavascript? thats what i got when i did cabal install happstack
16:28:37 <dons> yeah, now i program it every day for a job :)
16:28:48 <ImInYourMonad> dons: what job exactly?
16:29:05 <dons> research & dev at galois.com
16:29:07 <Fredrik> > let divisors n = [x | x <- [1..n], n `mod` x == 0] in let primes = filter (\x -> length (divisors x) == 2) [1..] in primes
16:29:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:29:16 <Fredrik> :)
16:29:30 <Fredrik> Does that count as 1 line? :)
16:29:31 <ImInYourMonad> cool
16:29:54 <tromp_> oh, ehird, the front data bit is 0, so it doesn't append...
16:30:00 <bodq> Fredrik: not bad
16:30:02 <ehird> tromp_: :)
16:30:05 <bodq> Fredrik: but that's N^2
16:30:15 <dcoutts> dons: oh of course, you started in Autumn '99 in the southern hemisphere
16:30:15 <Fredrik> Yeah, but how many prime numbers do you really need? :)
16:30:32 <rictic> Any pointers for debugging this linking error http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1776 when compiling this file http://github.com/rictic/twerp-h/blob/30b9f90569188b4878a19ae1ca79bb3a884d33a7/TwerpInterp.hs ?  I've got a new install of ghc if it matters
16:30:33 <bodq> Fredrik: (10^9) ^2 is too big
16:30:35 <dmwit> > nubBy (((==1) .) . gcd) [2..]
16:30:36 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
16:30:47 <dmwit> > nubBy (((>1) .) . gcd) [2..]
16:30:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
16:30:53 <dcoutts> dons: I was wondering how we could both have started learning Haskell in '99 and yet me not have reached the 10 year anniversary yet :-)
16:31:00 <bodq> @src nubBy
16:31:01 <lambdabot> nubBy eq []             =  []
16:31:01 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:31:08 <dmwit> rictic: Use --make.
16:31:18 * dcoutts will have been doing Haskell 10 years in October
16:31:33 <dons> hehe
16:31:38 <Fredrik> gcd is a built-in function? cool
16:31:58 <bodq> Fredrik: anyway
16:32:00 <rictic> dmwit: Thanks, that seems to have gotten it :)
16:32:01 <bodq> Fredrik: http://haskell.org/haskellwiki/Prime_numbers
16:32:34 <Gracenotes> smallest naive primes function I've seen :)
16:33:10 <Fredrik> I dont understand that nubBy at all
16:33:16 <Fredrik> But I guess thats normal :)
16:33:45 <Fredrik> I feel like a nub :)
16:33:52 <pejo> dcoutts, 99 was obviously a good year.
16:34:07 <Nafai> I was learning Python in '99 :(
16:34:16 <dcoutts> pejo: heh :-)
16:34:49 <bodq> Gracenotes: http://haskell.org/haskellwiki/Blow_your_mind
16:34:53 <Gracenotes> I was in the 4th grade, I think >_>
16:34:58 <Gracenotes> in 99
16:35:46 <Gracenotes> bodq: oh, yeah. Nice page... I should check it out again :)
16:35:57 <Fredrik> Anyone care to read chapter 5 (pages 13 to 15) and tell me if I've written complete nonsense? :) http://www.file-upload.net/download-1502097/Haskell5.pdf.html
16:36:30 <zachk> i passed algebra 1 in the 5th grade with an 89 on the final and i didnt study but that was probably before you were born gracenotes O:-)
16:37:12 <Gracenotes> zachk: you had finals in the 5th grade? Jeez :P I took basic algebra in the 4th grade, but it was informal.
16:37:34 <zachk> they let me take 8th grade algebra 1 in 5th grade
16:37:40 <bodq> Fredrik: skimmed over it, looks nice, but I'm not sure that the world needs yet another haskell tutorial :)
16:37:49 <zachk> there was a kid at my school two years younger then me doing calculus
16:37:59 <Fredrik> It doesn't. I just need to get proficient with LaTeX :)
16:38:10 <Gracenotes> zachk: goodness. Where was your school?
16:38:17 <bodq> Fredrik: although it might be good if you have to appeal to some specific audience
16:38:19 <zachk> alabama
16:38:29 <zachk> huntsville
16:38:32 <bodq> ah latex
16:38:37 <zachk> it was a public magnet school
16:39:00 <Fredrik> My target audience likes to be thrown in the water. Some basics, and then program, program, program :)
16:39:02 <Gracenotes> oh, magnet. Yeah, the South has definitely got the magnet system right, in terms of public education
16:39:03 <zachk> most of my friends dads worked for nasa, my did just fixed nukes for the army D:
16:39:15 <Fredrik> So I need lots of exercises
16:39:18 <bodq> Fredrik: what you call "type classes" is actually polymorphism
16:39:22 <Fredrik> page?
16:39:35 <bodq> 7
16:39:43 <Gracenotes> some states in the South kinda suck in terms of education, but my friends who're in Magnet schools say they like it
16:39:51 <bodq> at least the first few things
16:39:54 <Gracenotes> even in quote-sucky-unquote states
16:40:04 <zachk> i moved to upstate new york
16:40:09 <zachk> slept through highschool
16:40:10 <Gracenotes> that's my home :)
16:40:13 <Fredrik> Well, aren't type classes a form of compile time polymorphism?
16:40:14 <zachk> straight a's
16:40:17 <zachk> got into college
16:40:23 <Fredrik> parametric polymorphism, that is?
16:40:24 <zachk> and was like what is this study stuff
16:40:26 <Gracenotes> good ol' poughkeepsie
16:40:26 <bodq> Fredrik: no
16:40:29 <zachk> epic fail
16:40:36 <bodq> Fredrik: let
16:40:41 <bodq> Fredrik: let's take "length"
16:40:45 <bodq> Fredrik: it works for a list of anything
16:40:54 <bodq> Fredrik: and there are no type classes involved
16:41:00 <Fredrik> yes, but there are in square
16:41:01 <Gracenotes> typeclasses could be considered a form of inclusional polymorphism
16:41:11 <Fredrik> you can square only (Num a) types
16:41:16 <bodq> Fredrik: `square' in you example is related to type classes only becuase (*) is
16:41:25 <bodq> @t (*)
16:41:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:41:27 * BMeph was learning Okinawan Japanese in '99
16:41:30 <bodq> @type (*)
16:41:32 <lambdabot> forall a. (Num a) => a -> a -> a
16:41:38 <Fredrik> there you go
16:41:44 <bodq> @type \a b -> a*b
16:41:46 <lambdabot> forall a. (Num a) => a -> a -> a
16:41:53 <Fredrik> even more evidence :)
16:42:07 <bodq> fredcy: eh? you're missing the point
16:42:13 <bodq> Fredrik: that is
16:42:25 <bodq> Fredrik: you can define functions that apply to any type
16:42:26 <Saizan> Fredrik: parametric polymorphism is the one without a typeclass context
16:42:34 <bodq> Fredrik: and that would have nothing to do with typeclasses
16:42:46 <bodq> @type \a -> a
16:42:47 <lambdabot> forall t. t -> t
16:43:06 <bodq> > let x = \a -> a in x ["asdf"]
16:43:08 <lambdabot>   ["asdf"]
16:43:11 <bodq> > let x = \a -> a in x 0
16:43:12 <lambdabot>   0
16:43:18 <Gracenotes> :O
16:43:28 <bodq> Fredrik: no typeclasses, see? :)
16:43:38 <BMeph> Whoops, gotta go play in traffic, heh-heh.
16:43:41 <Fredrik> I don't see the connection to Chapter 3.2
16:43:47 <Fredrik> There I talk about Num which is clearly a type class
16:44:06 <bodq> Fredrik: yeah some parts of it are relevant, others aren't
16:44:54 <Fredrik> Hm, so what exactly would you phrase differently on page 7?
16:44:59 <bodq> Fredrik: also mentioning typeclasses without mentioning what you can do with them is not very useful
16:45:07 <ImInYourMonad> im looking at parsec examples to find out how to combine different parsers. i have managed to do a parse that checks if a string is only digits. but if i want to validate that it lloks like: digit\spacedigit\colondigit etc?
16:45:14 * dmwit doesn't understand bodq's complaint, either
16:45:46 <dmwit> digit >> space >> char ':' >> digit
16:45:52 <bodq> Fredrik: remove the square example and add "instance Num Complex where ..."
16:45:58 <dmwit> space = satisfy isSpace -- or so
16:46:01 <bodq> Fredrik: also mention :info
16:46:03 <scwizard> why does this paper say it's for a philosophy phd instead of a comp sci one? http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
16:46:03 <bodq> @info Num
16:46:03 <lambdabot> Num
16:46:05 <dmwit> :t isDigit
16:46:06 <lambdabot> Char -> Bool
16:46:12 <dmwit> digit = satisfy isDigit
16:46:14 <Gracenotes> ImInYourMonad: something like: do { d1 <- digit; space; d2 <- digit; char ':'; d3 <- digit; ... }
16:46:47 <scwizard> is it written in too plain english for a comp sci paper or what?
16:46:54 <Gracenotes> dmwit's will work also, although you might not be able to collect values (without doing something more liftM3-ish)
16:46:55 <Fredrik> I'll think about your feedback, thanks.
16:47:07 <dmwit> scwizard: Ph. D. stands for Doctor of Philosophy, you know.
16:47:13 <scwizard> o
16:47:15 <dmwit> scwizard: And Philosophy is a branch of Mathematics, these days.
16:47:16 <scwizard> know I didn't know that
16:47:22 <Gracenotes> all these computer scientists, wanting to be philosophers
16:47:27 <Gracenotes> shame
16:47:32 <Fredrik> Now it's bedtime for me
16:47:37 <Fredrik> Thanks for the fun prime puzzle
16:47:41 <scwizard> dmwit: thanks for clearing that up
16:47:57 <ImInYourMonad> and how do I tell that it is a repeated pattern?
16:48:24 <bodq> Fredrik: guten nacht :)
16:48:29 <Fredrik> danke schoen :)
16:48:41 <Fredrik> weißwurst, sauerkraut, hefeweizen :)
16:48:42 <Gracenotes> many?
16:49:34 <Gracenotes> many :: GenParser tok st a -> GenParser tok st [a]
16:50:07 <Gracenotes> depends one what you mean by 'repeated'
16:50:41 <Gracenotes> -e
16:53:32 <ImInYourMonad> movieParser = P.digit >> P.space >> P.digit >> P.char ':' >> P.digit; can i then do:  = case (P.parse movieParser "" input) of ...; and that should work? (it doesnt)
16:54:45 <Gracenotes> that parser should accept something like "5 3:9"
16:54:56 <Gracenotes> and it should return the last digit (in this case 9)
16:55:04 <Gracenotes> "Right 9"
16:55:36 <Olathe> Hmm...
16:55:47 <Olathe> @src (>>=) Either
16:55:48 <lambdabot> Source not found. Take a stress pill and think things over.
16:56:09 <Gracenotes> you see, P.digit and P.space and P.char return the character that was processed
16:56:17 <Olathe> @src Either (>>=)
16:56:17 <lambdabot> Left  l >>= _ = Left l
16:56:17 <lambdabot> Right r >>= k = k r
16:56:38 <Gracenotes> however, by chaining with >>, it throws the result away
16:56:45 <Olathe> You can use Either to give a result early.
16:57:17 <Gracenotes> your example is do { P.digit; P.space; P.digit; P.char ':'; P.digit }, and the last statement, P.digit, is what it returns
16:57:52 <Gracenotes> P.parse returns Either by default (iirc), and it can be used with the function 'either'... or something like. X.X
16:58:05 <Olathe> > let f n = if n < 1 then Left n else Right (n - 1) in (Right 3) >>= f >>= f >>= f >>= f >>= f
16:58:06 <lambdabot>   Add a type signature
16:58:15 <Olathe> > let f n = if n < 1 then Left n else Right (n - 1) in (Right 3) >>= f >>= f >>= f >>= f >>= f :: Either Int Int
16:58:16 <lambdabot>       No instance for (Error Int)
16:58:16 <lambdabot>        arising from a use of `>>=' at <inte...
16:58:22 <Olathe> Hmm...
16:59:17 <Olathe> Where is Error required for Left ?
17:00:53 <Gracenotes> @type let f n = if n < 1 then Left n else Right (n - 1) in (Right 3) >>= f >>= f >>= f >>= f >>= f
17:00:54 <lambdabot> forall a. (Error a, Ord a, Num a) => Either a a
17:01:18 <ImInYourMonad> thansk ti works
17:01:38 <Olathe> Is there something like Either but not for errors ?
17:01:58 <Gracenotes> :(
17:02:35 <Gracenotes> ImInYourMonad: if you're familiar-ish with JSON, http://snippets.dzone.com/posts/show/3660 might be useful
17:02:53 <Gracenotes> (even if not JSON is simple)
17:03:19 <Gracenotes> and also the linked-to JSON parser
17:03:37 <Gracenotes> from the page. http://www.lshift.net/blog/2006/07/13/writing-ajax-applications-in-haskell
17:05:01 <vili7> I'm getting a strange DLL error when I try to run a simple OpenGL/Glut program in GHC "Can't load .so/.DLL for: Xi (addDLL: could not load DLL)". Any idea how to fix this?
17:08:23 <bodq> @type (//)
17:08:24 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
17:08:32 <ImInYourMonad> ok i see it search from the start at the string until it matches and if it matches and ther eis more it still "matches"
17:08:42 <bodq> @hoogle Array i e -> i -> e -> Array i e
17:08:42 <lambdabot> No results found
17:08:47 <bodq> @hoogle Array i e -> (i, e) -> Array i e
17:08:48 <lambdabot> Data.Array.Base (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
17:08:48 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
17:08:48 <lambdabot> Data.Array.Base unsafeReplace :: (IArray a e, Ix i) => a i e -> [(Int, e)] -> a i e
17:08:59 <ImInYourMonad> but i dont see how to define: X pattern repeat-pattern \n
17:11:16 <Gracenotes> @hoogle try
17:11:16 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
17:11:16 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
17:11:16 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
17:11:25 <Gracenotes> the last one :) ImInYourMonad
17:12:11 <Gracenotes> string "abc" <|> string "abf"  will fail for abf, but pass for ababf
17:12:24 <Gracenotes> try (string "abc") <|> string "abf"  will pass for abf
17:12:49 <Gracenotes> I think.
17:13:48 <bodq> So I have data Corrdinate = Coordinate Int Int, what's the easiest way to make it an an instance of Ix using (a,b)'s implementaion of all Ix's method?
17:14:46 * Gracenotes does type Coordinate = (Int, Int), and (Int, Int) is already Ix
17:15:37 <bodq> Gracenotes: but then there's no constructor
17:15:48 <bodq> Gracenotes: but I would like the constructor to be called "Coordinate"
17:15:48 <Olathe> @src Ix
17:15:48 <lambdabot> class (Ord a) => Ix a where
17:15:49 <lambdabot>     range           :: (a,a) -> [a]
17:15:49 <lambdabot>     index           :: (a,a) -> a -> Int
17:15:49 <lambdabot>     inRange         :: (a,a) -> a -> Bool
17:15:49 <lambdabot>     rangeSize       :: (a,a) -> Int
17:16:14 <Olathe> You can implement all those methods pretty easily.
17:16:30 <bodq> Olathe: yes I can but that's slightly lame
17:16:42 <Olathe> instance Ix Coordinate; range (Coordinate x y) = range (x, y); ...
17:16:43 <bodq> Olathe: what I want is to get (Int, Int)'s implementation
17:16:58 <bodq> Olathe: nope
17:17:05 <bodq> Olathe: range ((Coordinate a b), (Coordinate c d)) = range ((a, b), (c, d))
17:17:14 <Olathe> Ahh.
17:17:20 <Olathe> Well, you see how to do it :)
17:17:38 <Gracenotes> bodq: sorry, was away
17:17:41 <Gracenotes> try newtype deriving
17:17:53 <Gracenotes> newtype Coordinate = Coordinate (Int, Int) deriving (Ix)
17:18:08 <Gracenotes> {# LANGUAGE GeneralizedNewtypeDeriving #}
17:18:25 <Gracenotes> just one option :) If you want to implement your own Ix instance, that should be good too
17:18:43 <ImInYourMonad> what do Prag,as do and how do they effect outside modules that call modules that use them?
17:18:57 <bodq> Gracenotes: aha that seems to be working, thanks
17:19:25 <Gracenotes> the (Int, Int) instance is weird in that it allows out-of-range things -- (1,7) has meaning in ((0,0),(5,5)) -- but that shouldn't be a huge problem I hope, bounds-checking is always possible
17:19:54 <bodq> Gracenotes: indeed, but how would I defined a bound type?
17:20:06 <bodq> Gracenotes: I was under the impression that no, haskell can not do that
17:20:43 <bodq> Gracenotes: unless I want to have data OneEight = One | Two | ... :)
17:21:01 <Gracenotes> it can't without a wrapping. For example, the constructor for a ratio of numbers is :%
17:21:08 <Olathe> You can hide the constructor and provide an alternative.
17:21:31 <Gracenotes> there are many values that are duplicates, so only % is public, and that ensures that only valid values are provided. Module-hiding magic and such.
17:22:34 <Gracenotes> bodq: anyway, Coordinate with the (Int, Int) Ix instance should be fine, just check bounds before accessing/writing an index if you're unsure :) Like you would an array in other languages.
17:23:54 <bodq> Gracenotes: it's for array indices, so I would assume Array does that for me
17:24:00 <bodq> Gracenotes: or what?
17:24:52 <Gracenotes> > listArray ((0, 0), (1, 1)) [1..] ! (0, 2)
17:24:54 <lambdabot>   3
17:25:03 <Gracenotes> > listArray ((0, 0), (1, 1)) [1..] ! (40, 291)
17:25:04 <lambdabot>   * Exception: Error in array index
17:25:09 <bodq> ugh
17:25:10 <bodq> right
17:25:26 <bodq> > index ((0, 0), (1,1)) (0, 2)
17:25:27 <lambdabot>   * Exception: Error in array index
17:25:43 <bodq> hmm
17:25:51 <Gracenotes> hrm :x
17:25:51 <bodq> howso?
17:26:26 <bodq> > GHC.Arr.unsafeIndex  ((0, 0), (1,1)) (0, 2)
17:26:28 <lambdabot>   /tmp/4942690980272176771:70:56: Not in scope: `GHC.Arr.unsafeIndex'
17:26:54 <bodq> that gives me 2
17:26:59 <bodq> not 3 btw
17:27:11 <Gracenotes> yes. the index is 2
17:27:19 <Gracenotes> 0, 1, 2, 3 are the indices, for values 1, 2, 3, 4
17:27:20 <bodq> oh right, [1..]
17:27:24 <bodq> ack
17:27:27 <Gracenotes> I guess that's why.
17:27:43 <Gracenotes> but, bound-checking, I guess.
17:28:07 <bodq>  > (listArray ((0, 0), (1, 1)) [1..] :: IArray Int Int) ! (0, 2)
17:28:19 <bodq> > (listArray ((0, 0), (1, 1)) [1..] :: IArray Int Int) ! (0, 2)
17:28:20 <lambdabot>       Not in scope: type constructor or class `IArray'
17:28:26 <bodq> hmm
17:28:36 <ImInYourMonad> how can I do something like: rating x = take x $ repeat (P.space >> P.digit >> P.char ':' >> P.digit)
17:28:51 <ImInYourMonad> Im seeing the power of Parsec though, seems very elegant.
17:29:51 <bodq> @src index :: ((Int, Int), (Int, Int)) -> (Int, Int) -> Int
17:29:52 <lambdabot> Source not found. You untyped fool!
17:29:59 <bodq> whatever
17:30:06 * bodq gives up and goes to bed
17:30:13 <bodq> thanks for the warning Gracenotes
17:30:14 <Gracenotes> ImInYourMonad: you know, that only parses it without recording the values :) have you seen http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-ParserCombinators-Parsec-Combinator.html ?
17:30:15 <Olathe> ImInYourMonad: iterate (\x -> P.space >> P.digit >> P.char ':' >> P.digit >> x) (return ()) !! x
17:31:22 <Gracenotes> replicateM (P.space >> P.digit >> P.char ':' >> P.digit) mehbeh
17:31:45 <Olathe> @src replicateM
17:31:45 <lambdabot> replicateM n x = sequence (replicate n x)
17:31:46 <Gracenotes> or not. :x
17:32:00 <Olathe> @src sequence
17:32:00 <lambdabot> sequence []     = return []
17:32:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:32:00 <lambdabot> --OR
17:32:00 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:32:02 <Gracenotes> oh, mehbeh.
17:32:15 <Olathe> @src replicateM_
17:32:15 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
17:32:20 <Olathe> @src sequence_
17:32:20 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:32:42 <Olathe> Ahh, I think that's what I had.
17:33:20 <Olathe> replicateM_ 5 (P.space >> P.digit >> P.char ':' >> P.digit)
17:35:59 <ImInYourMonad> where is replicateM?
17:36:09 <shapr> @index replicateM
17:36:09 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
17:37:11 <Gracenotes> most utilities in Control.Monad
17:37:35 <Gracenotes> other utilities in Control.Warm.Fuzzy
17:38:10 <ivanm> if in a monadic context, foo :: a -> [b] and I do "b <- foo a; case (bar b) ...", does it map the case statement over each result from foo?
17:38:21 <ivanm> Gracenotes: lol
17:39:16 <Gracenotes> including replicateHeaddesk :: Int -> IO ()
17:39:46 <ivanm> heh
17:40:49 <Gracenotes> ivanm: yes, for the list monad it concatenates all the results of the things after it for every item
17:41:07 <ivanm> Gracenotes: yeah, thought so, just wanted to check
17:41:51 * ivanm _loves_ debugging code, especially when making it use a new API :s
17:46:29 <mun> hi
17:46:41 <ImInYourMonad> yes!! got itworking, how effin cool isnt Parsec? very powerful...
17:49:00 <ImInYourMonad> if haskell is a programming language then all other languages are jokes!
17:49:23 <ImInYourMonad> hey C++ go over there -> and hang out with Brainfuck
17:50:31 * chessguy slips ImInYourMonad a mild sedative
17:50:35 * ivanm was trying to work out the lambda expression in ImInYourMonad's last statement before he realised there wasn't one...
17:50:48 <Gracenotes> different jokes for different jobs
17:50:58 <ivanm> heh
17:51:04 * Saizan spreads sugar lambdas over the channel
17:52:41 <ivanm> Saizan: real sugar? none of that artificial sweetener garbage?
17:52:43 <ivanm> \o/
17:54:00 <Olathe> Yay, sugar lambdas !
17:55:14 <Saizan> ivanm: yeah, both cane and beet
17:55:25 <ivanm> yummmmmm......
17:55:58 <ivanm> "No lambdas hurt in the making of this joke" ;-)
18:00:01 <tromp_> if you think haskell it too concise and prefer more verbose lambdas then try http://perl.plover.com/lambda/jfp/lambda-brief.pl
18:01:30 <Axman6> heh
18:03:38 <mun> hi
18:04:20 <Axman6> o/
18:05:45 <kohwj> i'm trying to install hsxmpp via its downloaded source, but "runhaskell Setup.hs configure" says that mtl isn't installed (but it is, in my ~/.cabal/lib). is there a way to point Setup.hs to ~/.cabal/lib?
18:05:51 <ImInYourMonad> how do I express or in Parsec?
18:06:03 <ImInYourMonad> P.digit or P.char ':'
18:06:09 <dcoutts> kohwj: us cabal install instead of runhaskell Setup.hs configure
18:06:12 <dcoutts> us/use
18:06:25 <mun> hi
18:06:35 <EvilTerran> ImInYourMonad, <|>
18:06:38 <kohwj> dcoutts: oh! i see
18:07:02 <kohwj> ok it works, except that-  Could not find module `System.Random':  it is a member of package random-1.0.0.1, which is hidden
18:07:07 <EvilTerran> ImInYourMonad, but be aware that p <|> q fails overall if p consumes any input and then fails
18:07:18 <dcoutts> kohwj: since you've got the cabal program there's no need to use runhaskell Setup. If you really wanted to though you could still do so, just add the --user flag. The cabal program does --user by default.
18:07:37 <mun> can a zipper be thought of as a morphism on a data structure? i was given the following explanation, but how a zipper is a pair of type T*T' http://pastebin.com/m5b9b01a3
18:08:04 <dcoutts> kohwj: ah well that's a problem with the package. It's not been updated for ghc-6.8+. You can fix the package by editing the .cabal file to add random to the build-depends.
18:08:06 <mun> isn't a zipper a pair of current focus and the context?
18:08:56 <kohwj> dcoutts: awesome! works now :) thanks so much
18:08:57 <dcoutts> kohwj: and that's why runhaskell Setup did not find the package, because when doing a --global install it cannot look at any --user packages. Make sense?
18:09:03 <kohwj> dcoutts: yup
18:09:18 <kohwj> dcoutts: --user -> in /home/.cabal, --global -> somewhere else
18:09:29 <dcoutts> --global -> /usr/local
18:10:21 <chessguy> mun:  do you mean morphism in the category theoretical sense?
18:10:39 <CakeProphet> >let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in map fib [1..]
18:10:45 <mun> chessguy, yes that's right
18:10:46 <CakeProphet> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in map fib [1..]
18:10:47 <lambdabot>   <no location info>: parse error on input `in'
18:11:04 <chessguy> hm. Cale  would be a good one to ask about that
18:11:19 <BMeph> chessguy: Is there another sense? :)
18:11:29 <CakeProphet> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5)) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in map fib [1..]
18:11:30 <lambdabot>   [0.9999999999999999,2.0,3.0,5.0,8.0,13.000000000000002,21.0,34.0,55.0,89.0,...
18:11:37 <CakeProphet> ...
18:11:45 <CakeProphet> lol floating point.
18:11:53 <EvilTerran> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5)) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in map fib [1..] :: [CReal]
18:12:08 <lambdabot>   thread killed
18:12:14 <EvilTerran> hum
18:12:17 <CakeProphet> ...is CReal not lazy?
18:12:36 <Olathe> Lazy how ?
18:12:39 <CakeProphet> > [1..] ::CReal
18:12:41 <lambdabot>   Couldn't match expected type `CReal' against inferred type `[a]'
18:12:43 <CakeProphet> > [1..] ::[CReal]
18:12:46 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
18:12:47 <EvilTerran> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5)) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in map fib [1..] :: [CReal]
18:12:49 <CakeProphet> nevermind
18:12:50 <Cale> mun: Well, although we can't write it in Haskell (well, not easily anyway), taking the derivative of a type is a functor.
18:13:02 <lambdabot>   thread killed
18:13:03 <EvilTerran> that's weird; it seems to work in pm
18:13:10 <EvilTerran> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5)) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in take 20 $ map fib [1..] :: [CReal]
18:13:12 <lambdabot>   [1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0,89.0,144.0,233.0,377.0,610.0,987.0...
18:13:15 <BMeph> > let phi = (1+(sqrt 5))/2; y = (1-(sqrt 5))/2;  fib n = (1/(sqrt 5)) * (phi ^ (n+1)) - (1/(sqrt 5))*(y ^ (n+1)) in take 12 . map fib $ [1..] :: [CReal]
18:13:16 <lambdabot>   [1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0,89.0,144.0,233.0]
18:13:17 <Cale> mun: as is taking the zipper...
18:13:20 <Axman6> > [1.0..] !! 100000 :: CReal
18:13:22 <lambdabot>   * Exception: stack overflow
18:13:30 <chessguy> ah, speak the name of Cale  and he rises from the dead :)
18:13:36 <Olathe> Heheh
18:13:39 <EvilTerran> CakeProphet, there we go; no more lol floating point
18:14:03 <kohwj> i've spent the week trying to find inspiration for a cool haskell project. ideas i thought up include a chart library (but it has been implemented by someone else), a tic-tac-toe AI, a SAT solver and the game of life. do you have any ideas? i intend to write something useful and put it on hackage
18:14:14 <Cale> It's troublesome, but you all have my name, and that gives you power over me ;)
18:14:22 <mun> Cale does the description here make sense to u? http://pastebin.com/m5b9b01a3
18:14:27 <CakeProphet> EvilTerran:  hmmm... is there a more efficient way to compute the fibonacci sequence?
18:14:34 <chessguy> Cale:  don't worry, it's for great good
18:14:34 <Olathe> If you just want a Fibonacci function, @let ffib :: Int -> Integer; ffib n = snd.foldl' ffib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] where ffib' (f, g) p | p = (f*(f+2*g), ss) | otherwise = (ss, g*(2*f - g)) where ss = f*f+g*g --by wli
18:14:42 <Olathe> > ffib 1000000
18:14:44 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
18:14:48 <Olathe> It's fast
18:14:54 <EvilTerran> O.o
18:15:02 <Axman6> kohwj: i've wondered about doinf a game of life before, but not idea about the display of it
18:15:02 <Saizan> kohwj: replace cabal-install's dependency solver with a complete one based on SAT?
18:15:11 <Cale> mun: Yes, that's pretty much it.
18:15:12 <Olathe> It's also exact.
18:15:36 <CakeProphet> Olathe:  I'm also stumped as to how it works.
18:15:38 <kohwj> Saizan: if i'm not wrong, a SAT solver solves boolean prepositions
18:15:43 <kohwj> Axman6: cairo
18:16:00 <Olathe> CakeProphet: It uses something like GMP's Fibonacci function.
18:16:17 <mun> Cale, why is it a pair of T*T'? http://en.wikibooks.org/wiki/Haskell/Zippers says that it's just a pair of the position and the context
18:16:18 <Saizan> kohwj: yeah, but you can encode problems with richer domains into propositional logic
18:16:25 <Cale> mun: Oh, perhaps I see what you mean though, one might ask whether there's a natural transformation T -> Z, and there is...
18:16:45 <Olathe> CakeProphet: If the index is even, you do something with the index `div` 2, otherwise you do something else with the index `div` 2.
18:16:46 <mun> Cale, is T in the description supposed to be the context?
18:17:04 <kohwj> Saizan: hmm...
18:17:04 <Olathe> CakeProphet: So, you can look at the sequence of bits in the index and do whatever to get the result.
18:17:14 <Olathe> CakeProphet: I think that's how wli's function works.
18:17:17 <Cale> Oh, right, your datatype isn't a functor.
18:17:22 <Cale> So, that doesn't make sense.
18:17:34 <CakeProphet> Olathe:  using a fib n style function is slower than having the whole sequence in one function, right?
18:17:41 <CakeProphet> because of how the sequence is defined.
18:17:42 <mun> Cale, could it be a functor?
18:17:52 <Cale> if it had a type parameter, yeah
18:18:20 <chessguy> almost anything can be a functor :)
18:18:32 <kohwj> Saizan: hm, wikipedia says that graph colouring, planning and scheduling problems can be encoded into SAT
18:18:33 <Olathe> CakeProphet: Yes, if you want a list, it's quicker to use simple addition.
18:18:38 <kohwj> Saizan: worth a look :)
18:18:48 <Olathe> CakeProphet: If you want a random index, it's quicker to use something like GMP.
18:18:53 <mun> Cale, i have a phone call at the moment. it'd be great if we could talk about this further a little bit later. sorry!
18:18:58 <mun> Cale, thanks for your patience
18:19:07 <Cale> no problem
18:19:54 * chessguy ponders going through wolfram's NKS and making a little collection of haskell libraries for the different abstract machines he describes, just for fun
18:23:31 <drhodes> those should parallelize easily
18:23:59 <Gracenotes> what kind of machines?
18:24:49 <kohwj> Axman6: well, cairo isn't the only option.. there's also HOpenGL
18:25:15 <CakeProphet> Olathe:  I wonder if there's a general case that could be optimized. Utilizing already known values of a function to compute other values more efficiently.
18:25:30 <drhodes> Gracenotes: maybe this is where chessguy is referring: http://www.wolframscience.com/nksonline/chapter-3
18:26:01 <chessguy> yep, that's it
18:26:12 <Gracenotes> oh, I see, mostly in terms of cellular automata
18:26:29 <Gracenotes> it might just be me, but I don't see why people like cellular automata so much ;)
18:26:57 <chessguy> meh, for me it would be more of just the fun of coding
18:27:09 <CakeProphet> Gracenotes:  Emergent behavior is frowzy.
18:27:20 <chessguy> but it is cool to see complex behavior come out of very simple rules
18:27:23 <chessguy> frowzy?
18:27:32 <Gracenotes> surely you mean cromulent?
18:27:40 <CakeProphet> no no, frowzy.
18:27:41 <chessguy> @all-dict frozy
18:27:44 <lambdabot> No match for "frozy".
18:27:48 <chessguy> @all-dict frowzy
18:27:49 <lambdabot> *** "Frowzy" gcide "The Collaborative International Dictionary of English v.0.48"
18:27:49 <lambdabot> Frowzy \Frow"zy\, a. [See {Frouzy}.]
18:27:49 <lambdabot>    Slovenly; unkempt; untidy; frouzy. "With head all frowzy."
18:27:49 <lambdabot>    --Spenser.
18:27:49 <lambdabot>    [1913 Webster]
18:27:51 <lambdabot> [31 @more lines]
18:27:57 <chessguy> @more
18:27:57 <lambdabot>  
18:27:57 <lambdabot>          The frowzy soldiers' wives hanging out clothes. --W. D.
18:27:57 <lambdabot>                                                   Howells.
18:27:59 <lambdabot>    [1913 Webster]
18:28:01 <lambdabot>  
18:28:03 <lambdabot> [26 @more lines]
18:28:04 <CakeProphet> that's the technical definition
18:28:06 <CakeProphet> however
18:28:07 <chessguy> lol
18:28:30 <CakeProphet> if all the popular youngsters can use technically negative words to describe things that are cool
18:28:36 <CakeProphet> I can use frowzy to mean "awesome"
18:29:24 <drhodes> Gracenotes: star logo has a near collection of cellular automata programs included, http://education.mit.edu/starlogo/, I prefer the original 2-d varient of the app.
18:29:25 <Gracenotes> no you can't. prescriptivists will roll over in their graves!
18:29:27 <CakeProphet> plus it's an old word, which makes it even more frowzy.
18:29:52 <omnihil> using frowzy in that way is perfectly cromulent.
18:30:09 <drhodes> simulating ant behavior, forest fires, rabbits&grass population dynamics.
18:31:19 <CakeProphet> any system that can simulate a working Turing machine is cool to me.
18:31:41 <CakeProphet> unless it's developed by Sun.
18:31:49 <CakeProphet> or is part of .NET or something.
18:31:54 <goomba`> studying actual ants, forests, rabbits and grass can be pretty neat too.
18:31:58 <ImInYourMonad> data Bit = One | Zero deriving(Show) ; how do I rep Byte? data Byte = Byte [Bit] ?
18:32:42 <CakeProphet> ImInYourMonad:  heh, use Char
18:32:43 <Olathe> ImInYourMonad: (Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit)
18:32:56 <Cale> ImInYourMonad: apart from the fact that your Byte type technically allows as many bits as you please, that's fine, and probably convenient
18:32:57 <Olathe> Word8
18:33:21 <Cale> Though... if you're actually interested in practical applications, it's not terribly practical.
18:33:23 <Axman6> CakeProphet: what's wrong with Sun?
18:33:24 <Gracenotes> > "(" ++ intercalate ", " (repeat "Bit") ++ ")"
18:33:25 <lambdabot>   "(Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit...
18:33:32 <Cale> Each bit there is going to cost a lot! :)
18:33:32 <pumpkin> it's CakeProphet :o
18:33:44 <CakeProphet> Axman6:  I'm being facetious -- I just don't like Java in paticular.
18:33:52 <Axman6> heh
18:33:54 <CakeProphet> it's pumpkin?
18:34:12 <Gracenotes> pumpkin teim!!!
18:34:19 <Gracenotes> cake teim!!!!!!
18:36:16 <Gracenotes> ;_;
18:36:20 <ImInYourMonad> Cale: Brainfuck interpreter isnt all that practical
18:36:31 <mun> Cale, back. are you still around?
18:37:16 <ImInYourMonad> so if i wanted to rep it is a 8 bit exactly, what would I use?
18:37:45 <Gracenotes> we need some kind of brainfuck module system, and C interface
18:37:48 <drhodes> :t pack
18:37:50 <lambdabot> Not in scope: `pack'
18:37:51 <Gracenotes> an extension
18:38:02 <Cale> mun: yep
18:38:16 <Cale> ImInYourMonad: It might be more convenient just to use Word8
18:38:25 <mun> Cale, cool. thanks!
18:38:38 <Cale> ImInYourMonad: Which is a positive integer restricted to 8 bits.
18:40:41 <mun> Cale, if i understand that description properly, T can be something like c2(c3), c1(c2(c3), c3), etc. while T' can be something like c2_1, c1_1(c3), etc. so if i have a pair of type T*T' (c3, c2_1), what does that actually mean?
18:40:53 <thoughtpolice> mmorrow: ping?
18:40:57 <mun> Cale, that the argument of c2 is c3?
18:41:00 <ImInYourMonad> sure but sint it possible have a data of 8 elems?
18:41:19 <hoelzro1> Is there a way to run HApps applications via CGI or something?  I'd like to set up Gitit on my hosted space, but I obviously can't run it as root...any thoughts?
18:41:34 <Olathe> ImInYourMonad: You could have it stored as Word8 internally but hide that: data Byte = Byte Word8; byte :: (Bit, Bit, Bit, Bit, Bit, Bit, Bit, Bit) -> Byte; byte (a, b, c, d, e, f, g, h) = Byte (f' 128 a + f' 64 b + f' 32 c + f' 16 d + f' 8 e + f' 4 f + f' 2 g + f' 1 h) where f' _ Zero = 0; f' n _ = n
18:42:15 <Cale> mun: hmm... actually, I think you took the derivative a little strangely there.
18:42:19 <Olathe> Then, export byte, but not Byte, and make sure to implement Show and so on.
18:43:03 <Cale> When you differentiate T * T, you use the product rule, and it differentiates to T' * T + T * T'
18:44:21 <Cale> So it would be T' = c1_1(T' * T) | c1_2(T * T') | c2_1 T'
18:44:27 <kerlo> Note to self: Do not try to determine what channel I'm in my looking at what people have said. Instead, look at the blue bar that says #haskell.
18:45:12 <Cale> mun: However, since there's no type parameter there, the derivative (at least for finite recursive data) will be 0.
18:45:47 <Cale> mun: That is, you won't actually be able to construct a (finite) element of T'
18:46:19 <Cale> mun: It's similar to differentiating a constant function.
18:47:22 <mun> Cale, but how is the derivative of T is a zipper?
18:47:40 <Cale> mun: The way to think of it is that if a data structure has no elements, you can't remove one of them to make a hole.
18:47:41 <mun> or is it?
18:47:44 <Cale> It is.
18:47:56 <Cale> Well... "zipper" tends to imply a little more
18:48:26 <Cale> Normally they'll choose something isomorphic to the naively constructed derivative, but which is easier to work with.
18:49:02 <ImInYourMonad> where is Word8?
18:49:56 <Cale> Like, using a pair of lists instead of data List' a = Hole (List a) | NotYet a (List' a)
18:50:07 <Cale> ImInYourMonad: Data.Word, iirc.
18:50:49 <kerlo> Would "class Derivative a -> b where" be the syntax for a class with parameters a and b where for each a there can be only one b?
18:51:12 <Cale> class Derivative a b | a -> b where ...
18:51:14 <Riastradh> No.  Use:  class Derivative a b | a -> b where ...
18:51:19 * kerlo nods
18:51:37 <Cale> Or...  class Differentiable t where type Derivative t; ...
18:51:46 <kerlo> travisbrady: are you by any chance related to a Lucas Brady?
18:52:02 <travisbrady> kerlo: not to my knowledge
18:52:10 <Gracenotes> some are related by blood, some by marriage.
18:52:14 <Gracenotes> Other are related...
18:52:15 <Gracenotes> ...by chance
18:52:27 <kerlo> Cale: that looks like what I want, though it also looks like a recent extension I don't know how to use.
18:52:33 <mun> Cale, ok. it says that a zipper is a pair (x, ctxt) of having type (T * T'). how can a pair have the type (T * T')?
18:53:30 <Gracenotes> in some notations (a, b), with a having type A and b having type B, has type (A * B)
18:53:38 <Cale> mun: Well, with your specific example, after correcting the derivative, it seems that the only elements of T' will be infinite.
18:53:57 <Gracenotes> in Haskell, that's just (A, B). (if I understand your question)
18:55:51 <Cale> oh... perhaps I see why we're looking at this differently...
18:56:20 <Cale> hmm
18:56:27 <mun> Cale, is T' T prime or the derivative of T?
18:56:39 <Cale> I was thinking it's the derivative.
18:56:50 <mun> and is * a cartesian product or multiplication
18:57:03 <Cale> In this context, those are the same thing.
18:57:07 <mun> Cale, would it make sense if it wasn't a derivative?
18:57:13 <mun> Cale, that's true.
18:57:36 <mun> Cale, I guess it would still make sense right...
18:57:56 <Cale> I don't think I see how T' represents every location in T where a recursive portion of the structure can occur.
18:58:01 <mun> so c1 is a binary function, c2 is unary and c3 is a constant
18:58:25 <Cale> It seems only to be capable of representing those which occur at depth 1
18:58:54 <mun> Cale, but c1_1 takes in a type T, and T itself is recursive.
18:59:38 <ImInYourMonad> thnx cale
18:59:41 <ImInYourMonad> alla
19:02:16 <Cale> mun: Aha, okay, I see what's going on here.
19:02:27 <Cale> T = mu X. X * X + X + 1
19:02:53 <Cale> T' = mu X. 2 * X + 1
19:03:16 <mun> Cale, yep
19:03:17 <Cale> So it's differentiation under the fixpoint.
19:03:35 <mun> hmm what do you mean by the fixpoint?
19:03:46 <Cale> The "mu X." bit.
19:03:53 <mun> right. okay
19:04:36 <Cale> But then T' = c1_1(T') | c1_2(T') | c2_1
19:04:48 <ImInYourMonad> what is a memorycell called? addressspace?
19:04:54 <mun> Cale, you mean c1_1(T) rather than T'?
19:05:08 <Cale> no, I'm specifically saying it ought to be T' there.
19:05:40 <mun> Cale, right. okay.
19:05:58 <Cale> and this really does sort of represent a position in a data structure... though it's slightly awkward because that position may not exist.
19:06:56 <mun> Cale, hmm how is c1_1(T') a position?
19:07:17 <mun> Cale, oh
19:07:18 <Cale> It represents the left branch of the c_1 constructor.
19:07:20 <Cale> er...
19:07:21 <mun> yeah
19:07:37 <bremner> @src groupBy
19:07:37 <lambdabot> groupBy _  []       =  []
19:07:37 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:07:37 <lambdabot>     where (ys,zs) = span (eq x) xs
19:08:34 <seydar> when should I use the Zipper dataset?
19:09:15 <Cale> mun: I'll warn you that I'm a little tired... so I'm not thinking very clearly at the moment :)
19:09:21 <pumpkin> seydar: when you need to zip lots of things
19:09:28 <Cale> mun: There's something strange going on here.
19:09:30 <mun> Cale, i think c1_1(T) should make more sense
19:09:47 <mun> Cale, the pair (x, ctxt) is the actual zipper, it says. so a pair (X*X+X+1, X*X) is a zipper
19:09:59 <mun> assuming you're taking the first position of c1
19:10:23 <seydar> funny, pumpkin, you're a funny guy
19:10:27 <mun> otherwise (X*X+X+1, 2*X) is a zipper
19:10:43 <mun> i might be missing a big part of the story
19:10:44 <pumpkin> seydar: I wasn't being a smartass
19:10:48 <Cale> But how do you represent the position which follows the left and then the right subbranch of nested c1's?
19:10:50 <mun> Cale, sorry for keeping u awake
19:10:55 <seydar> pumpkin: what does zipping things mean?
19:11:03 <Cale> No, it's okay, I'd be awake anyway :)
19:11:10 <pumpkin> > zip [1..10] [2..11]
19:11:12 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
19:11:14 <Cale> I might go to bed soon though :)
19:11:19 <pumpkin> > zip3 [1..10] [2..11] [3..12]
19:11:21 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10),(9,10,11)...
19:11:30 <pumpkin> there are zipN up to 6 or 7 I think
19:11:34 <mun> Cale, i'm pretty desperate here because my prof seems to understand that description, while i find it quite obtuse
19:11:38 <seydar> pumpkin: i was referring to ListZipper
19:11:53 <rovar> wow.. the non operator form of ap is really hard to use
19:12:02 <rovar> it is a good exercise though :)
19:12:11 <Cale> mun: Do you have Conor McBride's paper?
19:12:20 <Cale> mun: I seem to remember it being reasonable to understand.
19:12:51 <dmwit> seydar: A zipper is good when you need to rove around a piece of data.
19:13:01 <seydar> but like... how?
19:13:16 <mun> Cale, but just to look at (x,ctxt) of type (T*T') being a zipper.. i thought a zipper doesn't contain the original structure
19:13:23 <seydar> if i want to access any element, is it good for that?
19:13:32 <mun> Cale, no i haven't read that. i've already read Huet's.
19:13:40 <dmwit> seydar: For example, if you have a graph, and you want to conceptually "be" at a particular node, but also able to "move" to neighboring nodes... you'd use a zipper on a graph.
19:13:46 <mun> Cale, is the zipper described in http://en.wikibooks.org/wiki/Haskell/Zippers the notion of zipper you agree with?
19:13:50 <Cale> mun: The idea is that, once you've picked the right T'
19:14:06 <Cale> T' will represent a version of the data structure with a hole in it
19:14:17 <Cale> and the T will be the part which fits into that hole
19:14:18 <mun> Cale, yes, i agree
19:14:26 <seydar> dmwit: should I ever have to use an Array in functional world?
19:14:32 <pumpkin> seydar: it's like a cursor, it seems
19:14:33 <dmwit> seydar: Another example: say you're keeping a parse tree, and you want to wander around the tree and make changes to subtrees.  A zipper over a tree would be good for that.
19:14:44 <mun> Cale, oooh!
19:14:46 <dmwit> seydar: Sure.
19:15:01 <Cale> mun: However, it's confusing to do this with datatypes that have no contained elements, like this one.
19:15:04 <dmwit> seydar: Not as often as you might think, if you came from C/C++, but they're occasionally useful.
19:15:04 <mun> so T, i.e. the first element of the pair isn't the original structure
19:15:16 <Cale> Right.
19:15:18 <mun> but a structure of the type T, with the corresponding hole in it
19:15:31 <Cale> Uh...
19:15:37 <Cale> T is what fits into the hole
19:15:42 <seydar> dmwit: I'm trying to write a simple opcode VM, and I'm thinking of ways to represent memory
19:15:48 <Cale> and T' should be like T, but admit a single hole
19:15:54 <pumpkin> seydar: a zipper probably isn't ideal for that
19:15:55 <mun> Cale, do you know much about shallow and deep embedding of logics?
19:16:06 <pumpkin> seydar: an array or an IntMap is probably better
19:16:16 <seydar> pumpkin: what's an IntMap?
19:16:20 <Cale> Not a whole lot...
19:16:39 <mun> Cale, because my prof suggests that one could see zipper as a pair of shallow and deep embedding
19:16:48 <mun> do you agree?
19:16:52 <pumpkin> seydar: you know Data.Map?
19:16:57 <Cale> Uh, that sounds strange.
19:17:00 <pumpkin> it's like that but more efficient, if your keys are Int
19:17:12 <lstor> If I define a module as "module X where", and then import X in another file -- will all the functions in X be hidden by default (when I don't specify any as a part of the module)?
19:17:19 <seydar> pumpkin: nice
19:17:23 <Cale> mun: http://www.cs.nott.ac.uk/~ctm/diff.pdf
19:17:34 <pumpkin> seydar: it uses a trie-like structure, if you know what I mean
19:17:35 <Cale> mun: Figure 1 gives the whole idea away
19:17:41 <mun> Cale, that's because you could carry a parse tree-like structure around and still have the formula
19:17:48 <mun> Cale, thanks
19:18:06 <dmwit> seydar: Yeah, zippers aren't the way to go for models of (sequential) memory.  You should almost certainly use an Array (or STArray!) for that.
19:18:13 <wli> Someone should write some low-level mutable memory thing with STRefs or some such to maintain sorted rank-indexed lists.
19:18:28 <seydar> pumpkin: sweet, thanks!
19:18:30 * dmwit nominates wli
19:18:34 <seydar> dmwit: what's STArray?
19:18:43 <dmwit> seydar: It's a safe, mutable array.
19:18:46 <pumpkin> seydar: if you want it to have lots of memory in your VM, you might want to do (ST)UArray
19:18:51 <wli> I've already tried and failed.
19:19:17 <dmwit> seydar: When you're done mutating it, you can freeze it into a pure Array, or you can just use it within ST for storage.
19:19:17 <seydar> pumpkin: what's the difference between STArray and STUArray and UArray
19:19:28 <wli> (Using AVL trees.)
19:19:36 <pumpkin> STUArray = STArray, but unboxed (so it can't be polymorphic or lazy)
19:19:37 <dmwit> seydar: ST -> mutable; IO -> mutable, but in IO instead of ST; U -> unboxed
19:19:46 <Cale> seydar: The U implies unboxed, which means that if any element is computed, the whole array must be computed.
19:20:14 <pumpkin> seydar: the U means the array elements are represented directly, which makes them faster (can be stored in registers sometimes) and use less memory, but are less flexible
19:20:17 <dmwit> The tradeoff (which Cale didn't mention) is that STUArrays are generally faster when it's possible to use them.
19:21:07 <Cale> Yes, generally a good deal faster, because they're more compact in memory, and involve less indirection.
19:21:35 <seydar> so with STUArray, i shouldn't expect any laziness, right?
19:21:41 <Cale> right
19:21:48 <Cale> With STArray, you can.
19:22:14 <Cale> The other thing about UArrays of various types is that they can only have very specific types of elements.
19:22:35 <Cale> Whereas the boxing in plain lazy arrays allows any type of element to be stored.
19:23:40 <mun> Cale, thanks very much for your input. i agree with your interpretation, but somehow it doesn't seem to fit into the shallow+deep embedding context. i should just go ask my prof tmr.
19:25:53 <Cale> ã˜ã‚ƒã€ãŠä¼‘ã¿
19:27:48 <mun> bye Cale
19:28:36 <Cale> g'night :)
19:28:43 <seydar> how do zippers work on trees?
19:28:59 <pumpkin-> http://www.haskell.org/haskellwiki/Zipper
19:29:02 <TomMD> Very well
19:29:08 <pumpkin-> there's a diagram on there :)
19:29:09 <pumpkin-> might help
19:30:24 <mun> seydar, try this as well http://en.wikibooks.org/wiki/Haskell/Zippers
19:30:56 <pumpkin-> seydar: also, as a general resource, have you looked at RWH? it's freely available online (but also in book form)
19:32:37 <seydar> i have yet to!
19:32:38 <seydar> thanks!
19:32:50 <seydar> pumpkin-: you should drop by CS48 this springs
19:32:52 <seydar> spring*
19:32:52 <seydar> k?
19:32:58 <pumpkin-> which is 48?
19:36:14 <mmorrow> thoughtpolice: pong
19:36:31 <thoughtpolice> mmorrow: was wondering if you've written any cool stuff in sml?
19:37:31 <mmorrow> thoughtpolice: not really aside from playing around in the repl. i'd like to though.
19:37:57 <thoughtpolice> mmorrow: i'm trying to figure out how to get a simple example of mlrisc working :/
19:38:02 <thoughtpolice> with mlton though
19:38:07 <mmorrow> thoughtpolice: particularly interesting is the various compiler-related sigs/structs in smlnj (which are exposed/visible in the repl)
19:38:30 <mmorrow> thoughtpolice: i don't really know anything about mlton
19:39:04 <wli> The SML/NJ repl is awesome.
19:39:27 <mmorrow> thoughtpolice: http://www.smlnj.org/doc/features.html
19:39:57 <wli> The bit where you can take random functions and turn them into executables straight from the repl is awesome.
19:40:55 <mmorrow> wli: yeah totally
19:41:28 <thoughtpolice> i've been playing with 110.69
19:41:34 <thoughtpolice> it's pretty neat :)
19:41:43 <mmorrow> thoughtpolice: i have unpacked src for smlnj/related here for when i want to reference the code (sends everything as text/plain):  http://moonpatio.com/repos/LIBS/Language/smlnj
19:41:58 <mmorrow> the MLRISC subdir: http://moonpatio.com/repos/LIBS/Language/smlnj/MLRISC/
19:42:19 <thoughtpolice> mmorrow: cool
19:43:11 <mmorrow> oh wow, i haven't really looked in the mlrisc subdir before....: implems for a bunch of graph algo: http://moonpatio.com/repos/LIBS/Language/smlnj/MLRISC/graphs/
19:44:19 <wli> I still think GURRR or similar is the way for things on that level.
19:46:11 <mmorrow> actually annoyingly i can't seem to figure out how to get .sig to send as text/plain for some reason
19:46:37 <mmorrow> (editing mimetypes doesn't seem to work oddly, but surely i'm missing something (?))
19:47:33 <thoughtpolice> mmorrow: mlton is pretty cool, it has a port of most of smlnj's libs (mostly the same, sans the extensions smlnj provides)
19:47:49 <thoughtpolice> and it's nice and optimizing. :)
19:48:13 <thoughtpolice> (heap2exe for smlnj doesn't work on os x I think  anyway :( )
19:48:22 <mmorrow> awww
19:48:31 <mmorrow> cool, i should check mlton out
19:50:55 <mmorrow> thoughtpolice: nice, there's a lot of cool code in mlrisc too
19:52:19 <wli> MLRISC is uberspiffy, yeah.
19:54:50 <wli> SMLofNJ.exportFn is the thing IIRC.
19:57:09 <Saizan> is it me or there are many more ML implementations than haskell ones?
19:57:15 <wli> I'm on 110.67-r2, whatever the r2 is.
19:57:41 <wli> It's an easier language to implement, I guess.
19:57:45 <thoughtpolice> sml: sml/nj, mlton, poly/ml, moscow ml... haskell: hugs, ghc, lhc...
19:59:28 <wli> hugs is barely maintained if at all.
19:59:58 <wli> Then again, hugs98 isn't doing much beyond bugfixes.
19:59:59 <thoughtpolice> mmorrow: i'm attempting to write a compiler using mlton right now... i just have to figure mlrisc out :)
20:00:13 <thoughtpolice> mmorrow: also, appel's papers are *awesome*
20:00:19 <thoughtpolice> he writes great stuff :)
20:01:51 <wli> I don't see lhc in portage, but I do see jhc and yhc, both of which I've forgotten the details  of.
20:02:03 <thoughtpolice> wli: cabal install lhc!
20:02:10 <wli> I'm not sure where nhc went.
20:02:20 <thoughtpolice> (i work on it, it can compile stuff!)
20:02:26 <thoughtpolice> actually nhc is pretty stable
20:02:37 <thoughtpolice> it's still viable for development really, and still compiles
20:02:39 <Saizan> there was an nhc release last year
20:06:00 <jmcarthur> nhc: small executables, yhc: some branch of nhc that i never tried investigating, jhc: whole program optimization, lhc: fork of jhc due to some conflicts with jhc maintainer (?), hugs: interpreter written in C, ghc: friggin awesome, anything major that i missed?
20:06:18 <dolio> hbc
20:06:26 * jmcarthur looks up hbc
20:06:36 <dolio> Helium, ehc.
20:07:11 <chessguy> @type m g = m' (t g) g
20:07:12 <lambdabot> parse error on input `='
20:07:13 <chessguy> @type m g = m' (t g) g
20:07:14 <lambdabot> parse error on input `='
20:07:15 <chessguy> heh
20:07:17 <chessguy> my brain is not working
20:07:19 <chessguy> @pl m g = m' (t g) g
20:07:19 <lambdabot> m = m' =<< t
20:07:21 <jmcarthur> ah, i have seen helium and ehc
20:07:24 * thoughtpolice hopes lhc can be more of 'a fork of jhc' at some point in time :)
20:07:30 <thoughtpolice> s/more of/more than/
20:08:05 <jmcarthur> thoughtpolice: i have noticed that lhc development is far more transparent and apparently more speedy than jhc so far. that is a big plus
20:08:20 <thoughtpolice> jmcarthur: we're trying. :)
20:08:50 <jmcarthur> i am mostly a silent observer, but i am very interested in jhc/lhc
20:09:10 <dolio> I think a lot of jhc development happens on John Meacham's computer, and he publishes in spurts.
20:09:31 <thoughtpolice> it's likely.
20:09:40 <dolio> Either that or he actually writes in spurts, but that seems unlikely. :)
20:09:44 <jmcarthur> ah, i forgot to mention to everyone... i am the same person as geezusfreeek, just under a new nick
20:10:16 <jmcarthur> got tired of the long, hard to spell name
20:11:45 <jmcarthur> dolio: that is probably true, but this is what i meant by "transparency"
20:11:55 <dolio> Yeah.
20:12:30 <jmcarthur> is hbc maintained?
20:12:40 <dolio> I don't think so.
20:13:30 <dolio> There's gofer, too.
20:13:42 <dolio> That got subsumed by hugs, I guess.
20:13:53 <dolio> Or something like that.
20:14:23 <jmcarthur> seems to be quite a few, albeit in a very wide variety of states
20:15:10 <pumpkin-> cutest picture ever: http://learnyouahaskell.com/listmonster.png
20:15:19 <pumpkin-> maybe not ever, but pretty close
20:18:26 <Gracenotes> cutest picture ever: [insert picture of pumpkin-]
20:18:32 <pumpkin-> :o
20:18:54 <jeffwheeler> pumpkin-: I love it!
20:19:10 <ivanm> Gracenotes: might be a cute picture for N. Americans around halloween time, but I for one am not a big fan of pumpkins...
20:19:18 <pumpkin-> I just advertised LYAH on my twitter
20:19:29 <jeffwheeler> pumpkin-: I much prefer LYAH than the original Ruby one; the graphics are far nicer
20:19:29 <pumpkin-> ivanm: me neither, I've never actually eaten anything pumpkin related
20:19:32 <Raynes> pumpkin- I just tweeted your twitter.
20:19:35 <Gracenotes> you may send your funds for the Pumpkin Fan Club to my PayPal account
20:19:36 <wli> The lhc guys should keep the warnings down a little.
20:19:45 <ivanm> pumpkin-: then why the name?
20:19:48 <pumpkin-> jeffwheeler: yeah
20:19:56 <pumpkin-> ivanm: I'm not sure actually, pretty random
20:20:04 <ivanm> wli: WARNING: you're using lhc
20:20:04 <ivanm> ;-)
20:20:07 <ivanm> pumpkin-: heh
20:20:23 <Raynes> Why's guide to Ruby taught Ruby well, but it was so fucking degrading listening to those long unnecessary rambles. I got so bored I quit Ruby O.O
20:20:25 <pumpkin-> ivanm: I'll justify it by saying I'm not a cannibal
20:20:28 * ivanm wonders what happen's to pumpkin's karma if pumpkin- adds another `-' to the end of his nick...
20:20:31 <wli> I'm not sure where lhc and yhc are these days.
20:20:31 <ivanm> pumpkin-: heh
20:20:34 <wli> er
20:20:41 <wli> yhc and jhc
20:20:48 <ivanm> dead?
20:21:03 <wli> That's what I'm wondering.
20:21:06 <ivanm> hi pumpkin--
20:21:08 <jeffwheeler> Hmm. http://mono-project.com/Languages
20:21:10 <ivanm> @karma pumpkin
20:21:10 <lambdabot> pumpkin has a karma of 2
20:21:13 <pumpkin--> :(
20:21:16 <ivanm> how are you going pumpkin--
20:21:17 <jeffwheeler> I wonder what it would mean if Haskell was on that list.
20:21:17 <ivanm> @karma pumpkin
20:21:17 <lambdabot> pumpkin has a karma of 1
20:21:19 <ivanm> \o/
20:21:21 <ivanm> :p
20:21:24 <pumpkin--> :'(
20:21:35 <ivanm> jeffwheeler: death, that's what...
20:21:43 <ivanm> ;-)
20:21:54 <jeffwheeler> Lots of nice Linux apps use Mono. I respect it.
20:22:16 <wli> I see yhc-darcs and jhc + jhc-darcs in the gentoo Haskell overlay.
20:22:16 <ImInYourMonad> what is the easiest way to do a serious compiler? generate C-code and then comple that?
20:22:21 <jeffwheeler> At least Banshee and F-Spot. And Tomboy.
20:22:48 <wli> ImInYourMonad: The fact the compiler is serious means it wasn't easy to do.
20:22:53 <cjb> jeffwheeler: the first thing that comes to mind for those three is "crash a lot" :)
20:23:00 <ivanm> wli: yes, but I doubt they work
20:23:01 <wli> ImInYourMonad: C front ends aren't serious compilers.
20:23:02 <jeffwheeler> cjb: haha, indeed
20:23:12 <ivanm> they're only still there due to sheer inertia I suspect
20:23:34 <wli> I've no idea if their codebases are history or what.
20:24:10 <thoughtpolice> wli: not true I think, jhc is a very 'serious' compiler when it comes to optimization and it compiles to C - there is also mercury, and DDC
20:24:20 <ImInYourMonad> is http://www.bitc-lang.org/ type-safe and statically typed?
20:24:22 <thoughtpolice> it's just not all that workable sometimes
20:24:22 <cjb> wli: llvm?
20:24:30 <thoughtpolice> as we have found out while working on lhc
20:25:32 <thoughtpolice> i mean sure there're ways to shoehorn GC into generated C code (using the shadow-stack trick for gc roots, like mercury and DDC do) but it's not all that pretty.
20:25:56 <wli> C abstracts out a surprising amount of machine-level details, and obfuscates a surprising amount of machine details too.
20:25:57 <ImInYourMonad> since there are OSes written in haskell, isnt haskell suited as a systems programming langauge? ar those written in a very restrictive style?
20:26:00 <thoughtpolice> it does work for accurate collection though
20:26:07 <wli> Kernels see this too.
20:26:11 <cjb> hm, I used to think Oleg was pretty awesome
20:26:13 <thoughtpolice> wli: ture :)
20:26:31 <ImInYourMonad> cjb: but not anymore?
20:26:45 <cjb> reading the haskell-cafe thread, he's being a little crank-y
20:26:51 <cjb> or is it just me?
20:26:52 <ImInYourMonad> could something even be called haskell without GC?
20:27:23 <wli> ImInYourMonad: I'm very skeptical about OS's written with implicit GC in the source language.
20:29:43 <wli> ImInYourMonad: OS kernels are very much about raw memory and doing specific things with specific address ranges and so on. One of the kernel's fundamental tasks is memory management. Arranging to manage memory on the kernel's behalf is preposterous.
20:31:17 <Philippa_> arguably the RTS would be the kernel
20:31:34 <ImInYourMonad> how do I serialize haskell code?
20:31:37 <cjb> wli: "unless you're X"
20:32:13 <wli> ImInYourMonad: MVars, Chans, etc.
20:32:28 <ImInYourMonad> I meant as in marhsalling
20:32:30 <Gracenotes> or Binary. Depending on what you mean
20:32:42 <ImInYourMonad> Data.Binary?
20:32:47 <Gracenotes> yes.
20:33:16 <Gracenotes> then there's CReal-izing, which is a different matter X_X
20:33:51 <wli> When languages have trivial RTS's you can actually achieve some sort of separation between the language RTS and the kernel. About all C needs is some odd things like certain integer division ops emulated and it's good to go.
20:34:01 <ImInYourMonad> when doing netflix, would it make sense to parse and store it as i want and then marshall the datastructure? because relational databases are way to slow.
20:34:26 <ImInYourMonad> RTS=runtimesystem?
20:35:26 <wli> When you can't cleanly separate the language RTS and the kernel you're really dealing with a compiler and kernel at the same time, which is nightmarish.
20:36:11 <wli> There are other, more specific issues with how GC operates that aren't nice for kernels either.
20:36:26 <jmcarthur> possibly one could make an rts with just enough logic to handle garbage collection and provide an ffi to the raw hardware, then do the kernel using haskell or whatever language the rts is for
20:36:48 <ImInYourMonad> when doing the netflix prize, 2GB of data or so in files, 100million ratings, would it make sense to parse and store it as i want and then marshall the datastructure? because relational databases are way to slow.
20:37:07 <wli> Trust me, kernels require manual memory management.
20:37:08 <jmcarthur> although it would still be a rather large rts
20:37:23 <pumpkin--> ImInYourMonad: yes
20:37:25 <ImInYourMonad> wli: will that always be true?
20:37:34 <wli> What is the RTS that does GC for Haskell implementations written in?
20:37:41 <ImInYourMonad> pumpkin: yes to netflix marhsall?
20:37:45 <pumpkin--> yup
20:38:04 <pumpkin--> c
20:38:12 <wli> ImInYourMonad: Yes, because what kernels do sits logically prior to nontrivial language RTS's.
20:39:11 <wli> The kernel is in C for all of the same reasons the GC code for the language RTS is in C, and more.
20:39:32 <thoughtpolice> cjb: what thread?
20:40:09 <wli> Don't try to use higher-level languages for kernels. Rather, design better low-level languags.
20:41:41 * thoughtpolice thinks D could become hot if LDC became the mainline compiler
20:42:15 <Raynes> D is hot to those who use it.
20:42:23 <Raynes> But it seems to be on a standstill.
20:42:32 <Raynes> Nothing ever happens.
20:42:59 <wli> I don't know much if anything about D.
20:43:06 <ImInYourMonad> but ok, functional language for Systems?
20:43:06 <jmcarthur> i thought there are improvements to D almost continuously...
20:43:08 <Raynes> I've used it in the past.
20:43:18 <ImInYourMonad> are functional constructs to dpeendant on GC?
20:43:23 <jmcarthur> when i used it quite a while ago there were
20:43:24 <ImInYourMonad> so what baout bitc?
20:43:37 <Raynes> D is worked on very actively, but that isn't what I meant by "nothing ever happens."
20:43:59 <Raynes> ImInYourMonad: Type a little slower.
20:44:03 <wli> One of the big nasties about C is all the undefined behavior.
20:44:15 <ImInYourMonad> so better type system
20:44:16 <wli> ImInYourMonad: Yes. Higher-order functions.
20:44:32 <ImInYourMonad> instead of function pointers
20:44:38 <wli> Has D got a website?
20:44:50 <wli> ImInYourMonad: That's not what the difference is.
20:44:54 <Raynes> wli: Digitalmars.com :p
20:44:55 <jmcarthur> digitalmars.com/d
20:45:07 <ImInYourMonad> wli: what difference?
20:45:18 <thoughtpolice> higher order functions can have free variables
20:46:04 <Raynes> Does Haskell have a website?
20:46:06 <Raynes> Hehe.
20:46:16 <thoughtpolice> you need a GC for closure support really; a closure is a function paired with its environment (free variable information)
20:46:18 <jeffwheeler> @whereis Haskell
20:46:18 <lambdabot> Maybe you meant: where where+
20:46:22 <jeffwheeler> @where Haskell
20:46:23 <lambdabot> http://haskell.org
20:46:29 <ImInYourMonad> gnight
20:46:47 <Raynes> jeffwheeler: That was a joke bro.
20:47:08 <jeffwheeler> Raynes: I know; I was curious whether it was in @where
20:47:24 <jeffwheeler> It could have been easily overlooked. ;)
20:48:24 <wli> I'm not too impressed with D.
20:49:18 <wli> At first glance it doesn't seem to be dealing with the flaws or addressing the programming-in-the-large problems.
20:49:21 <Raynes> wli: It's not all that impressive.
20:49:33 <jmcarthur> D is just what C++ should be, is all
20:49:48 <Raynes> D is a better designed C++, but still suffers the same problems.
20:50:00 <wli> D is GC'd, yuck.
20:50:01 <jmcarthur> right, the fundamental problems of the model
20:50:09 <jmcarthur> D is optionally GCed
20:50:19 <jmcarthur> you can control it or disable it or replace it or whatever you want
20:51:06 <wli> It speaks ill of their priorities. They seem to be guided by userspace concerns if that.
20:51:25 <jmcarthur> there are multiple kernel projects in D, i believe
20:51:46 <jmcarthur> and they seem to suffer no runtime problems that i have heard
20:52:32 <jmcarthur> there are even two completely distinct standard libraries for D, which i think is a testament to how separated it is from its runtime
20:52:35 <jmcarthur> these include the GC
20:53:16 <Raynes> Y'know. This discussion should probably be in another channel. Like #Haskell-Blah
20:53:20 <Raynes> It's certainly off topic.
20:53:23 <wli> They'll probably do okay, albeit not impressively better than C/C++.
20:53:24 <jmcarthur> yeah
20:53:28 <jmcarthur> i need to leave anyway i guess
20:54:09 <Gracenotes> wow. A C program that took 20 minutes printing intermediate result and then the final result took 7 seconds without the intermediate printing
20:54:23 <Gracenotes> IO is fucking slow. X_X
20:55:57 <wli> So this one IR I'm considering has 22 different cases for operation types and 41 different operations.
20:56:51 <wli> Where, granted, the operation types are parametrized over the types of some of their arguments (some of which type parameters must match).
20:59:44 <wli> This one suggestion I got wrt. how to structure operations seems to only "condense" the outer cases by a factor of 2:1 or thereabouts.
21:03:17 <wli> The LOC cost of the nesting doesn't seem to pay off vs. going flat and having a case for each operation with its own parameter type descriptions.
21:03:21 <wli> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1779#a1779
21:05:05 <wli> Granted, 9/22 cases are for loading constants into temporaries.
21:05:27 <wli> Maybe only 13 cases should count, at which point it does pay off vs. nesting.
21:06:03 <wli> Gracenotes: Format string -based IO formatting is known to suck hard.
21:06:37 <Gracenotes> hm. It did use %d. Maybe I should it manually processing the string
21:06:43 <Gracenotes> *do
21:07:12 <Gracenotes> it that's easy to do right-to-left. Jeez, forgot :/
21:07:13 <wli> It's not just that. It's that the buffer management is horrific.
21:08:03 <wli> Basically, just use a string table for constant strings, a series of buffers for dynamically generated strings, and a giant writev(). Formatted input is another, more complicated story.
21:09:15 <Gracenotes> that's what's done?
21:09:40 <wli> The writev's iovec can be precomputed for the most part except for the iov_len components of the iovec elements corresponding to the dynamically-generated buffers.
21:10:37 <wli> Gracenotes: copying of the constant crap, generating strings, and more copying of constant crap, all to a dynamically-expanded buffer with lots of copying and other crap.
21:12:25 <Gracenotes> perhaps splitting it up into threads might work, although the final answer would be computed long before it's printed
21:12:40 <wli> No, it's innately single-threaded.
21:12:54 <Gracenotes> I mean, one thread for printing, another for computing?
21:13:41 <Gracenotes> passed through some kind of queue of ints. I haven't done threads in C yet, though :)
21:16:12 <Gracenotes> hm. It looks like the languages I have used threads in were basically interfaces to C's.
21:16:55 <Gracenotes> shouldn't be that difficult :)
21:17:06 <thoughtpolice> lots of languages wrap pthreads, yeah
21:18:22 <wli> The stock pthreads are crippled in some respects. M:N threads are much more performant, but need more kernel help than is available in Linux.
21:24:42 * thoughtpolice finally got isabelle/hol working, but on linux...
21:42:48 <Eridius> is there any way to easily open the installed doucmentation for an installed library without poking around in /usr/local/share/doc?
21:47:24 <NameAlreadyInUse> which is the best fold to use for mundane tasks again?
21:47:56 <TSC> foldr for lazy, foldl' for strict
21:48:11 <NameAlreadyInUse> ok, thanks
21:48:11 <TSC> I'm not sure what you mean by mundane, though
21:48:23 <NameAlreadyInUse> i mean for general tasks
21:48:27 <NameAlreadyInUse> probably a bad use of the word mundane
21:48:40 <TSC> "General task" isn't much better (:
21:48:52 <TSC> Anyway, those two are the most used I think
21:54:51 <Saizan> Eridius: with a local hoogle installation you can use hoogle --info foo to get the haddock doc for foo and a link
21:55:10 <Eridius> local hoogle installation? Oooh
21:55:12 <Eridius> I didn't know you could do taht
22:01:02 <aempirei> hask-lol
22:09:43 <Saizan> Eridius: yeah, too bad cabal-install doesn't automatically keep an hoogle index with all the libraries automatically
22:09:51 <Saizan> (yet)
22:09:56 <Eridius> how can I get hoogle to index my documentation?
22:12:39 <Saizan> the default hoogle index is the one for the standard libraries
22:13:04 <Saizan> then you can build an hoogle index from a .cabal package with cabal haddock --hoogle
22:13:15 <Saizan> and you can use hoogle to merge them
22:13:27 <Eridius> but I have to build the hoogle index per-package?
22:14:03 <Saizan> yeah
22:14:17 <Eridius> bleh
22:24:44 <wli> That seems to be a rather natural interpretation of mutually recursive let bindings.
22:25:20 <Saizan> which?
22:26:05 <Gracenotes> :)
22:26:16 <Gracenotes> :X
22:26:20 <wli> Meant for #haskell-in-depth
22:35:56 <b\6> i made a Map whose values can be any instance of a certain class. when i try to M.lookup and run functions in the class on what i get, ghc says "ambiguous type variable". not sure what it means.
22:40:42 <mmorrow> thoughtpolice: yeah, appel's papers are totally awesome.
22:41:31 <mmorrow> thoughtpolice: i'd say 51% of what i know wrt this is based on them
22:55:44 <Gracenotes> b\6: have you ensured that your keys are Ords?
22:56:01 <b\6> Gracenotes: yeah. the keys seem to be ok.
23:01:09 <bos31337> @seen dons
23:01:09 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 5h 47m 2s ago.
23:04:26 <b\6> is it legit to do something like  type AnyC = forall a. C a => a  ?  i'm trying to make AnyC any type just so long as it's an instance of C.
23:09:31 <Gracenotes> b\6: well, you can do data AnyC = forall a . C a => AnyC a
23:09:37 <Gracenotes> with ExistentialQuantification
23:11:26 <b\6> Gracenotes: thanks, i'll try.
23:11:53 <Gracenotes> b\6: sure. Control.Exception does this with SomeException, for the class Exception
23:12:21 <Gracenotes> so it's around in the libs...
23:21:25 <bastl> good morning from germany ...
23:21:33 <dmwit> Good morning from America!
23:21:46 <bastl> hmm ;-)
23:22:03 <dmwit> Well, it's technically morning. ;-)
23:22:30 <maxote> Good night from Spain
23:22:32 <bastl> im looking for something like "zip" for Data.Tree. any ideas?
23:23:18 <bastl> in fact i want to number every single node in the tree: f :: Tree a -> Tree (Int,a)
23:23:34 <ivanm> good afternoon/evening from Down Under!
23:24:10 <dmwit> This is like the archetypical use case for the State monad.
23:25:40 <bastl> have to learn that then :-) finally ...
23:33:27 <Gracenotes> bastl: well, you can do it with some simple recursion :)
23:34:03 <Gracenotes> State is a nice way to abstract from passing around the Ints everywhere though
23:34:49 <Gracenotes> a function with just recursion might look like Tree a -> Int -> (Int, Tree (Int, a))
23:35:01 <Gracenotes> with State, Tree a -> State Int (Tree (Int, a))
23:41:16 <dmwit> In fact, State Int (Tree (Int, a)) = Int -> (Int, Tree (Int, a)).
23:41:29 <dmwit> (With a constructor thrown in for the compiler.)
23:42:02 <Saizan> Int -> (Tree (Int,a),Int) unfortunately
23:42:11 <dmwit> So if you can write the former, the latter should be quite instructive.
23:42:29 <Gracenotes> oh no, the order reversed???!!!!shiftone
23:42:38 <dmwit> ?unmtl State s a
23:42:38 <lambdabot> s -> (a, s)
23:42:47 <dmwit> yep
23:42:50 <Gracenotes> yeah, the order of state never made much sense
23:43:22 <Asztal^_^> http://okmij.org/ftp/Haskell/numbered-monad.txt may also be of interest
23:43:24 <Gracenotes> arbitrary is as arbitrary does, though
23:43:37 <Saizan> with s -> (s,a) fmap = fmap . fmap
23:44:00 <Asztal^_^> ?unmtl StateT s (ReaderT r (WriterT w a)))
23:44:01 <lambdabot> err: Parse error
23:45:18 <Saizan> ?unmtl StateT s (ReaderT r (WriterT w m)) a
23:45:18 <lambdabot> s -> r -> m (a, s, w)
23:45:39 <Asztal^_^> yeah, I just realised that, thanks :)
23:46:58 <dmwit> a triple...?
23:47:04 <dmwit> ?unmtl WriterT w m a
23:47:04 <lambdabot> m (a, w)
23:47:15 <dmwit> ?unmtl StateT s m a
23:47:16 <lambdabot> s -> m (a, s)
23:47:28 <dmwit> ...
23:47:31 <dmwit> Only one left...
23:47:37 <dmwit> ?unmtl ReaderT r m a
23:47:37 <lambdabot> r -> m a
23:47:48 <dmwit> Where the deuce is that triple coming from?
23:47:51 <harblcat> Is there a way to take a list such as [a] and pad each side of it so that, say, pad 1 b [a] = [[b,b,b],[b,a,b],[b,b,b]]?
23:48:03 <dmwit> Why, yes!
23:48:32 <maxote> has Haskell Unix's system calls? (e.g. for spawning processes)
23:48:42 <dmwit> We have forkIO.
23:48:45 <dmwit> :t forkIO
23:48:46 <lambdabot> Not in scope: `forkIO'
23:48:51 <dmwit> ?hoogle forkIO
23:48:51 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
23:49:13 <sjanssen> maxote: yes, System.Process is the high-level version and System.Posix.Process is the Unix specific version
23:49:17 <dmwit> We also have *nix-specific stuff, if you need it.
23:49:26 <maxote> thanks
23:49:43 <dmwit> errr... yeah, I guess spawning and forking are really quite different.
23:49:45 * dmwit feels silly
23:50:07 <sjanssen> dmwit: "forkIO" and "process" don't belong in the same category :)
23:50:15 <dmwit> right
23:50:45 <Baughn> Well, they're both "things that let you do multiple things at once"
23:51:00 <sjanssen> come to think of it, I have no idea what happens to forkIO'd threads after a forkProcess
23:51:03 * sjanssen boggles
23:51:15 <Baughn> They should get forked as well. They're just data.
23:51:30 <Baughn> POSIX threads have more issues.. hopefully ghc deals with that
23:51:33 <sjanssen> well, what happen to pthreads?
23:51:42 <Baughn> ..yeah. Quite. What.
23:52:19 <Baughn> (I don't really know. I know it's inconsistent across various OSs; I've not yet felt the need to explore it beyond that)
23:52:57 <Baughn> ..as it is, the only safe way to fork is to shut down threads first, and then recreate them at need
23:53:45 <sjanssen> GHC probably does some variant of that.  I know forkProcess is not exactly the same as fork()
23:56:10 <Baughn> @hoogle forkProcess
23:56:11 <lambdabot> No results found
23:56:43 <Baughn> Ah. I was wondering how they implemented it on windows.. guess they don't.
