00:00:02 <pumpkin_> is Control.Parallel.Strategies new in 6.10?
00:00:09 <Axman6> pastah: MVars are really nice. i think they're a little oike a mutex in C, but they're a _lot_ faster
00:00:14 <pastah> so what is the difference with concurrency and paralellism? both are things happening at the same time, are thy not?
00:00:14 <ivanm> pumpkin_: don't think so
00:00:26 <ivanm> pastah: concurrency: multiple threads, same CPU/computer
00:00:34 <ivanm> parallelism: multiple CPUs/computers/etc.
00:00:42 <ivanm> that's the quick-and-dirty difference between them
00:00:43 <Axman6> ivanm: not necessarilly
00:00:57 <pastah> ivanm: oh! concurrency is what i should bother with then
00:01:10 <ivanm> pastah: basically, concurrency is more on different stuff at the same time, parallelism is for doing the same stuff faster by splitting it up into chunks
00:01:14 <Axman6> concurrency involves doing different things at the same time. parallelism seems to me to be more about doing lots of the same thing at ocne
00:01:18 * pastah isn't exactly running qnx here...
00:01:20 <ivanm> ^^ a much better explanation
00:01:28 <ivanm> Axman6: hah, beat you! ;-)
00:01:33 <Axman6> pfft
00:01:37 <ivanm> :D
00:01:37 <Axman6> mine was better though!
00:01:49 <pastah> you both win!
00:01:55 <pastah> now kiss and make up
00:02:13 <pumpkin_> *out
00:02:34 * Axman6 wraps his manly arms around ivanm, and puckers up, while stealing his slightly earlier print of RWH
00:02:46 * ivanm runs away from Axman6 
00:02:51 <pastah> but ok, so paralellism is for performance gains and concurrency is for handling lots of stuff happening at the same time
00:02:57 <Axman6> my arms are still around you
00:02:58 <ivanm> and I've kept my RWH hidden in a safe place!
00:03:02 <ivanm> Axman6: pffftttt
00:03:05 <ivanm> doubt it
00:03:15 <Axman6> pastah: well, concurrenct can give you performnce gains too ;)
00:03:31 <pastah> Axman6: of course
00:03:44 <ivanm> pastah: parallelism is more for high-end calculation jobs
00:03:46 <Axman6> in my case, often does too :P
00:04:05 <ivanm> the technical difference is more on the approaches taken
00:04:15 <Axman6> parallelism is for stuff that you can do a lot of without relying on other stuff to finish in many cases
00:04:27 <ivanm> of course, you can use parallelism stuff on a single CPU, but they often don't work as well
00:04:27 <pumpkin_> Lemmih: omg a core parser :o
00:04:37 <Axman6> :O
00:05:06 <Gracenotes> whar?
00:05:13 <pumpkin_> whar alse
00:05:27 <pastah> ivanm: well, games is something that springs to mind...
00:05:28 <pumpkin_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/core-0.1
00:05:45 <ivanm> pastah: *nod*
00:06:08 <ivanm> note that a lot of the various mainstream parallelism toolkits (MPI, OpenMP, etc.) are devoted more on how to pass information around from one cpu to another
00:06:15 <Gracenotes> pumpkin_: quite a minimalistic interface :)
00:06:22 <pastah> ok
00:06:29 <pumpkin_> Gracenotes: looks a lot like haskell-src
00:06:34 <Gracenotes> mm
00:06:48 <pastah> but if i NEED to do paralellism in haskell, do i just do pseq?
00:06:59 <pastah> or is there something else?
00:07:00 <ivanm> ummmm..... stuff like that, yeah
00:07:10 <ivanm> though there's various branches of ghc, etc. aimed at parallelism
00:07:13 <pumpkin_> par
00:07:13 <pastah> (/more)
00:07:21 <Gracenotes> distributed systems in Haskell are wanting, afaik
00:07:25 <pumpkin_> parMap, etc.
00:07:30 <ivanm> note that atm, ghc has the issue where it's all using the one run-time
00:07:38 <Gracenotes> but just for threads and cores... fine
00:07:40 <pastah> @hoogle parMap
00:07:41 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
00:07:41 <ivanm> so it can't do erlang's message passing, etc.
00:07:41 <pumpkin_> Eden looked cool, but it doesn't look up to date
00:08:07 <pastah> @hoogle Strategy
00:08:07 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
00:08:07 <lambdabot> package StrategyLib
00:08:10 <ivanm> pastah: most parallel apps (AFAIK, anyway) basically run multiple instances of an app (one per CPU/computer) and pass info betwen them
00:08:18 <ivanm> GHC doesn't have this feature as yet :(
00:08:52 <pumpkin_> anyone know how in quickcheck I can make an assertion that error should be called?
00:08:55 <Gracenotes> time for some concatZipWith action woot.
00:09:31 <pastah> @type concatZipWith
00:09:31 <ivanm> pumpkin_: can you even catch errors to ensure an error was called?
00:09:32 <lambdabot> Not in scope: `concatZipWith'
00:09:34 <pastah> awww
00:09:37 * ivanm presume you can, but never has
00:09:43 <pumpkin_> ivanm: I thought you could as of 6.10
00:09:46 <ivanm> Gracenotes: in what way?
00:09:57 <pastah> @type \f xs ys -> concat $ ZipWith f xs ys
00:09:57 <ivanm> pumpkin_: exceptions /= errors, so I don't know
00:09:58 <lambdabot> Not in scope: data constructor `ZipWith'
00:10:02 <Gracenotes> in the way that I'm using concat . zipWith :X
00:10:04 <pastah> @type \f xs ys -> concat $ zipWith f xs ys
00:10:05 <lambdabot> forall a a1 b. (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
00:10:40 <Gracenotes> converting a DFA representation to an NFA one
00:11:07 <pastah> Gracenotes: those being short for...?
00:11:37 <Gracenotes> finite automata. Just stuff with accepting/rejecting input based on some calculations. It can be used to implement regular expressions.
00:11:46 <ibid> pastah: deterministic finite automaton, nondeterministic finite automaton
00:11:53 <pastah> @type error
00:11:54 <lambdabot> forall a. [Char] -> a
00:12:09 <ibid> Gracenotes: don't you usually convert the other way around? that conversion being rather trivial
00:12:26 <ibid> *the conversion above
00:12:35 <Gracenotes> yes, it is trivial :) I'm going to write NFA -> DFA next
00:13:13 <mmorrow> pastah: forkIO in unsafePerformIO is ok when you don't feel the need to ask if it's ok ;)
00:13:36 <mmorrow> pastah: (so atm i'd say no.. :)
00:13:43 * mmorrow really passes out now
00:14:07 <pumpkin_> lol
00:14:19 <mmorrow> pastah: (but of course feel free to disregard me and try it ;)
00:14:22 <Gracenotes> in this case, though, I have an interesting DFA representation: the transitions are described by [a] [[State]], where the second list !! n is the transition from the first list !! n to the new state
00:14:27 <mmorrow> pumpkin_: :)
00:14:34 <Gracenotes> I'm considering scrapping it and just using State -> a -> State
00:14:45 <wli> Gracenotes: I remember having done LR(1) at some point but I was lost as to how to return parse trees or incorporate semantic actions.
00:14:55 <Gracenotes> but in that case I can't minimize and do other nice stuff :/
00:15:18 <pastah> well, what i would be doing in the would be writing to MVars inside an unsafePerformIO
00:15:20 <ibid> Gracenotes: what about [(a, [State])]?
00:15:26 <ibid> Gracenotes: or Map a [State]
00:16:42 <Gracenotes> that works, but ensuring uniqueness of transitions and that the necessary ones exist is trivial in the other model
00:16:59 <Gracenotes> awws. :x
00:17:10 <pastah> @google haddock haskell
00:17:11 <lambdabot> http://www.haskell.org/haddock/
00:17:11 <lambdabot> Title: Haddock
00:17:54 <Gracenotes> I'll have a look at what other people are doing on the internet...
00:20:28 <Gracenotes> unfortunately, blindly NFA -> DFA would cause an inordinate number of state tuples. A function makes more sense in that regard for converting to, but not converting from.
00:21:40 <Gracenotes> (obviously a common problem)
00:24:01 <callen> alright guys.
00:24:11 <callen> is there a haskell tutorial that doesn't cockslap babies in the face?
00:24:53 <Gracenotes> I don't think babies are the intended audience of Haskell tutorials.
00:25:01 <Gracenotes> you might find http://learnyouahaskell.com/ accessible
00:25:33 <pumpkin_> I'm getting really odd core for my failing test
00:26:17 <ivanm> @time pumpkin_
00:26:18 <lambdabot> Local time for pumpkin_ is 2009-03-14 03:26:13 -0400
00:26:26 <pumpkin_> :o
00:26:27 <ivanm> pumpkin_: maybe you should get some sleep for once... >_>
00:26:31 <pumpkin_> lol
00:26:36 <pumpkin_> I will soon
00:26:39 <pumpkin_> I just want to figure out this bug
00:26:52 <Gracenotes> pumpkin: Haskell superhero by night... sleeper by day. :O
00:26:56 <pumpkin_> lol
00:27:41 <blackh> callen: Try "Yet another Haskell tutorial". That's a man's tutorial, that is.
00:27:54 <pumpkin_> I'm getting huge walls of code like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2380#a2380
00:28:02 <pumpkin_> is that normal? I haven't seen it before
00:29:07 <callen> blackh: it isn't accessibility but rather the lack of systematization in the official tutorial.
00:29:23 <callen> but thank you all, I shall try them both.
00:29:51 <callen> the worst part is I know lisp and scheme. -_-
00:31:56 <Gracenotes> implicit params... they're useful, but the question marks burn my eyes... THE UGLY o_o
00:32:40 <callen> Gracenotes: you look familiar. o___________o
00:32:53 <pumpkin_> bos31337: you around?
00:33:15 <Gracenotes> callen: I pet you once in ##c
00:33:35 <Gracenotes> you purred.
00:33:36 <ImInYourMonad> No instance for (R.RandomGen (IO R.StdGen))
00:33:36 <ImInYourMonad>       arising from a use of `R.randoms'
00:33:37 <bos31337> estoy aquí
00:33:49 <callen> Gracenotes: oh right, you're the nice one.
00:33:52 <ImInYourMonad> do i need to declare types for a random fucntion?
00:33:58 * callen hugs Gracenotes 
00:34:20 <ImInYourMonad> explosion a b= R.randomRs (a,b) R.newStdGen
00:34:26 <Gracenotes> callen: I think I just seemed nice because you were spewing invective at some guy
00:34:28 <ImInYourMonad> doesnt work
00:34:31 <Gracenotes> who was reciprocating
00:34:35 <ivanm> bos: did you get my message from lambdabot?
00:34:47 <bos> nope
00:34:47 <callen> Gracenotes: petting me disarms me pretty quickly over IRC and meatspace.
00:34:50 <pumpkin_> bos: do you have any hints on catching bugs in fusion? I'm still stuck with that issue I mentioned a while ago about a function call working fine in ghci/unoptimized but when optimized (the testsuite) it seems to fail immediately
00:35:04 <Gracenotes> callen: furry? ;)
00:35:13 <callen> Gracenotes: no, just a sensitive scalp.
00:35:14 <Gracenotes> anyway, *hugs*
00:35:15 <bos> pumpkin_: not at this hour of the night, sorry. i'm about to go to bed.
00:35:22 <pumpkin_> ah okay, sorry
00:35:37 <Gracenotes> callen: ah, I see :x
00:35:55 <Gracenotes> @vixen *pets*
00:35:55 <lambdabot> Hahaha
00:36:24 <Gracenotes> @vixen What? My petting has been rejected? :(
00:36:25 <lambdabot> let's don't talk about that
00:36:27 <ivanm> bos: I originally asked dons about this, but he said to ask you: is there a library form of the RWH globbing stuff? if not, do you mind if I write one based on the code in the book?
00:36:34 <ivanm> @slap Gracenotes
00:36:34 <lambdabot> why on earth would I slap Gracenotes?
00:36:40 <Gracenotes> yeah, why?
00:36:49 <ivanm> grrr....
00:36:59 <Gracenotes> @vixen You wouldn't slap me, would you?
00:36:59 <lambdabot> me?
00:37:13 <ImInYourMonad> explosion a b= R.randomRs (a,b) R.newStdGen
00:37:18 <ImInYourMonad> No instance for (R.RandomGen (IO R.StdGen))
00:37:19 <Gracenotes> .x.
00:37:19 <callen> Gracenotes: I wouldn't slap you, but I might nuzz your hand.
00:37:22 <ImInYourMonad>       arising from a use of `R.randoms'
00:37:26 <Gracenotes> awwww.
00:37:35 * callen :D
00:37:43 <ImInYourMonad> how do i use randomRs
00:38:03 <ivanm> @hoogle randomRs
00:38:04 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
00:38:30 <ivanm> > let g = mkSeed 1 in take 10 $ randomRs (0,10) g :: [Int]
00:38:31 <lambdabot>   Not in scope: `mkSeed'
00:38:53 <ivanm> > let g = mkStdGen 1 in take 10 $ randomRs (0,10) g :: [Int]
00:38:55 <lambdabot>   [3,3,9,7,6,0,6,4,8,1]
00:38:59 <ivanm> ImInYourMonad: ^^
00:42:28 <pumpkin_> BAH
00:42:53 <ImInYourMonad> match expected type `t -> g'
00:42:53 <ImInYourMonad>            against inferred type `IO R.StdGen'
00:43:27 <ImInYourMonad> e a b n = R.randomRs (a,b) (R.newStdGen n) :: [Int]
00:44:42 <ImInYourMonad> e n a b r = take n (R.randomRs (a::Int,b::Int) (R.newStdGen n) :: [Int])
00:45:26 <wli> Yeah, I think you can unravel all the stack machine stuff via register windowing -like affairs.
00:45:27 <ivanm> pumpkin_: what?
00:45:32 <toliko_smoren> anyone know any website with practice parsing/streams questions?
00:45:36 <pumpkin_> just this annoying bug
00:46:50 <wli> ... and once you have register windowing you can cut back on the bloat with register allocation -like affairs, but I'll leave that for another day.
00:48:53 <wli> If you're using a stack outright, stack slot reuse is nightmarish.
00:48:54 <ImInYourMonad> ok it works
00:51:22 <wli> Control is essentially done with the spine as a control stack.
00:54:21 * hotaru2k3 wonders if there's a nicer way to do "loeb (map const [0, 1] ++ map (uncurry (flip (.)) . ((take 2 .) . genericDrop *** genericIndex [\[a, b] -> b * (2 * a + b), sum . map(^2)]) . (\(q, r) -> (q + r - 1, r)) . flip divMod 2) [2..])"
00:55:26 <Gracenotes> hotaru2k3: what does it do?
00:55:44 <hotaru2k3> > let loeb = fix (fmap . flip id =<<) in loeb (map const [0, 1] ++ map (uncurry (flip (.)) . ((take 2 .) . genericDrop *** genericIndex [\[a, b] -> b * (2 * a + b), sum . map (^2)]) . (\(q, r) -> (q + r - 1, r)) . flip divMod 2) [2..])
00:55:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:56:31 <Gracenotes> well, there are nicer ways to do Fibonacci...
00:56:42 <hotaru2k3> > let loeb = fix (fmap . flip id =<<) in loeb (map const [0, 1] ++ map (uncurry (flip (.)) . ((take 2 .) . genericDrop *** genericIndex [\[a, b] -> b * (2 * a + b), sum . map (^2)]) . (\(q, r) -> (q + r - 1, r)) . flip divMod 2) [2..]) !! 100000
00:56:44 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
00:56:59 <johnw> Gracenotes: I really like let fib = 1 : 1 : zipWith (+) fib (tail fib)
00:57:03 <wli> Every time something gets pushed to the top of the stack, just hand back a new temporary (you should be able to figure out a number for it to statically insert in the bytecode), and every time things get popped from the stack for use as operands, you can smoke out temporary numbers to use for each stack operand etc.
00:57:05 <hotaru2k3> nicer ways that aren't a lot slower?
00:57:09 <Gracenotes> hotaru2k3: ah, the log(n) formula?
00:57:12 <Gracenotes> neat
00:57:54 <wli> hotaru2k3: I hate to toot my own horn, but http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
00:59:30 <wli> hotaru2k3: When generating sequential Fibonacci numbers, it's faster to use the linear recurrence. If you're starting from a high number, just bootstrap the linear recurrence by computing the initial two with the logarithmic recurrence.
01:00:39 <ivanm> bos: you still there?
01:02:29 <wli> let fib :: Int -> Integer ; fib n = let fib' (f, g) p = let ss = f*f+g*g in if p then (f*(f+2*g), ss) else (ss, g*(2*f-g)) in snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] in fib 100000
01:03:03 <wli> > let fib :: Int -> Integer ; fib n = let fib' (f, g) p = let ss = f*f+g*g in if p then (f*(f+2*g), ss) else (ss, g*(2*f-g)) in snd . foldl' fib' (1, 0) $ dropWhile not $ [testBit n k | k <- let s = bitSize n in [s-1,s-2..0]] in fib 100000
01:03:04 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
01:03:43 <Gracenotes> @type testBit
01:03:44 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
01:04:59 <pumpkin_> whee, I caught my bug
01:05:19 <pumpkin_> really annoying when a bug causes an exception that crashes the testsuite (and quickcheck batch doesn't print out what exception it is)
01:05:30 <wli> (0.28 secs, 41874324 bytes) for hotaru2k3's and (0.17 secs, 10881260 bytes) for mine.
01:06:01 <wli> For 100000
01:06:50 <wli> hotaru2k3's overflows on 1000000 and mine completes with (1.62 secs, 85730296 bytes)
01:07:48 <hotaru2k3> > let fib n = let twoFibs n = case n of {0 -> (1,0); _ -> (\((a,b),r)->let x=a*a+b*b;y=b*(2*a+b)in(0^r*x+r*y,r*x+y)).(twoFibs***id)$divMod n 2 } in snd $ twoFibs n in fib 100000
01:07:49 <lambdabot>   259740693472217241661550340212759154148804853865176965847247707039525345435...
01:08:03 <wli> Gracenotes: You can use Word64 if you want a bigger one.
01:10:25 <wli> hotaru2k3: Pretty good. Down to 0.19s
01:11:15 <hotaru2k3> wli: it's just as fast as yours on my computer
01:12:21 <wli> hotaru2k3: For 1000000 I get (1.60 secs, 87946052 bytes) with yours and (1.69 secs, 85626920 bytes) with mine, which makes it a serious contender.
01:14:22 <wli> hotaruk2k3: You're using a nicer form of the duplication formula.
01:14:34 <pumpkin_> dons: w00t, finished the UAProd-based binary instances, and fixed the bug that was causing the testsuite to crash :)
01:15:11 <wli> Then again, I run mine a couple of times in ghci for 1000000 and get (1.44 secs, 85903752 bytes)
01:16:39 <eu-prleu-peupeu> :)
01:16:54 <eu-prleu-peupeu> good morning
01:18:20 <pumpkin_> whoa
01:18:20 <pumpkin_> Prelude Data.Array.Vector Data.Binary Data.ByteString.Lazy> unsafeDeserialize $ unsafeSerialize (toU [True]) :: (UArr Bool, ByteString)
01:18:20 <pumpkin_> (toU [False],Empty)
01:18:26 <pumpkin_> something's definitely wrong there :P
01:19:39 <ivanm> @type Data.ByteString.Lazy.unsafeDeserialize . Data.ByteString.Lazy.unsafeSerialize
01:19:40 <lambdabot>     Not in scope: `Data.ByteString.Lazy.unsafeDeserialize'
01:19:40 <lambdabot>     Not in scope: `Data.ByteString.Lazy.unsafeSerialize'
01:19:53 <ivanm> or is it binary stuff?
01:20:03 <ivanm> @type Data.Binary.unsafeDeserialize . Data.Binary.unsafeSerialize
01:20:04 <lambdabot> Not in scope: `Data.Binary.unsafeDeserialize'
01:20:04 <lambdabot> Not in scope: `Data.Binary.unsafeSerialize'
01:20:11 <ivanm> @hoogle unsafeDeserialize
01:20:11 <lambdabot> No results found
01:20:20 <ivanm> pumpkin_: OK, I give up
01:20:21 <ivanm> ;-)
01:20:30 <Gracenotes> pumpkin_: oh dear, looks unsafe to me
01:20:42 <pumpkin_> lol, I wrote it myself
01:20:46 <pumpkin_> it's very very unsafe
01:20:53 <pumpkin_> but not unsafe enough for what I pasted to happen
01:21:22 <pumpkin_> it's mostly the serialize that's unsafe
01:21:41 <pumpkin_> the deserialize is unsafe in the sense that it's machine-dependent, so you can't expect to send files like this around
01:22:10 <pumpkin_> it might be possible to make the deserialize even more unsafe than the serialize though, but I'm not sure it's worth trying
01:22:40 <Gracenotes> instance (Binary a, Binary b) => Binary (a,b) where put (a,b) = put a >> put b; get = liftM2 (,) get get
01:22:55 <pumpkin_> ?
01:22:56 <pumpkin_> class (UA a) => UnsafeIO a where
01:22:56 <pumpkin_>   unsafeSerialize :: UArr a -> L.ByteString
01:22:56 <pumpkin_>   unsafeDeserialize :: L.ByteString -> (UArr a, L.ByteString)
01:22:58 <pumpkin_> :P
01:23:09 <pumpkin_> maybe it should be called UnsafeBinary
01:23:16 <Gracenotes> I see. Either way, they're unsafe
01:23:16 <pumpkin_> that would make more sense, probably
01:23:34 <Gracenotes> I think Binary is rather unsafe. Totally unboxed.
01:23:50 <Gracenotes> its correctness depends on making sure one particular component doesn't overshoot.
01:24:03 * Gracenotes hasn't used it, but that's the impression, anyway :)
01:24:43 <pumpkin_> it's deterministic and doesn't have side effects, seems pretty safe :P
01:24:57 <pumpkin_> it may behave strangely
01:24:59 <Gracenotes> well, I mean in terms of data correctness
01:25:17 <Gracenotes> unsafeCorruptDataStream
01:25:23 <Gracenotes> :x x:
01:25:26 <pumpkin_> ah well, you can clearly convert any data type into any other datatype, but you have to be trying quite hard :P
01:25:32 <pumpkin_> well, any Binary datatype
01:25:58 <Gracenotes> Just 4 == [4] ;)
01:26:10 <Gracenotes> == Right 4. among others... :x
01:26:32 <pumpkin_> only so much you can do about that, unless you want to start using something like typehash
01:26:44 <pumpkin_> but it hasn't affected == really
01:27:06 <Gracenotes> hm?
01:27:13 <pumpkin_> directly :P
01:27:25 <beelsebob> Gracenotes: that sounds like a good thing to me – given strong type checking I can guarentee that I parse the correct type from the binary stream, so I don't want a load of overhead in the encoded version
01:27:34 <beelsebob> I guess it does let you implement unsafeCoerce though
01:27:49 <Gracenotes> beelsebob: yes, it's good for performance
01:27:58 <pumpkin_> not really the full unsafeCoerce
01:28:00 <Gracenotes> and kind of checking usually isn't ;)
01:28:02 <Gracenotes> *any
01:28:03 <pumpkin_> only the safe bits of unsafeCoerce
01:28:05 <wli> Hotaru: I'm trying them on 10^7 with output redirected to /dev/null from the shell.
01:28:48 <wli> Hmm. I might not have enough RAM for a proper test on that large of numbers.
01:29:23 <wli> hotaru2k3: Sorry, 10^8
01:30:03 <wli> hotaru2k3: For 10^7 mine was 6.27user 0.04system 0:06.55elapsed 96%CPU (0avgtext+0avgdata 0maxresident)k and yours was 6.55user 0.03system 0:06.92elapsed 94%CPU (0avgtext+0avgdata 0maxresident)k, which is not a very significant difference.
01:31:37 <wli> hotaru2k3: I'm not seeing big differences for 10^8 either.
01:32:26 <wli> hotaru2k3: I'm probably going to run out of RAM for this next one.
01:33:45 <wli> hotaru2k3: With my hardware limitations I'd probably have to do repeated runs on a quiescent machine, and worse yet, statistical analysis on the results of repeated tests.
01:34:13 <hotaru2k3> wli: you obviously have a lot more ram than i do... and a much faster cpu, i've never gotten higher than 10^7
01:35:31 <wli> hotaru2k3: They're in the same asymptotic class, so we're not doing a whole lot more than trying to find out what the nearly-equal constant factors are to a high enough precision to figure out which one has higher or lower constant factors.
01:37:07 <wli> hotaru2k3: For 10^8 I get 125.55user 0.69system 2:09.17elapsed 97%CPU (0avgtext+0avgdata 0maxresident)k for mine and 127.21user 0.62system 2:09.06elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k for yours, which isn't a significant difference, either.
01:38:06 <wli> hotaru2k3: I suspect the hardware capacities of any machines either of us have access to are too limited (as is our patience) to have big enough arguments for there to be a significant difference.
01:38:41 <hotaru2k3> wli: yeah, probably
01:39:20 <wli> hotaru2k3: The argument would have to be big enough for the divisions by 2 on the argument to have significant overhead.
01:40:48 <wli> hotaru2k3: There may be a statistically significant difference as things now stand, but without a better test harness and the patience etc. to analyze numerous long, repeated runs, there's no way to tell.
01:43:38 <wli> hotaru2k3: If there's a difference it's definitely too small to be obvious with a small number of runs. I see enough variability that sometimes yours is a second or so faster, and sometimes mine is a second or so faster.
01:44:47 <wli> hotaru2k3: It would definitely take something like a student's t test to discriminate between them.
01:46:11 <wli> I wonder if there's some kind of thing to force full evaluation of something, throw away the result, and collect timing statistics, so that the printing etc. can be taken out of the loop.
01:53:31 <wli> The quick hack is to do fib n `mod` 2
01:54:11 <wli> That gets the printing out of the equation.
01:54:54 <blackh> wli: Microbench and rnf
01:57:19 <wli> blackh: Sounds promising.
01:58:21 <wli> blackh: What's rnf?
01:58:57 <blackh> wli: microbench is a little benchmark program, and rnf comes from Control.Parallel.Strategies - rnf forces evaluation....
01:59:13 <blackh> wli: But it requires you to make your data structure an instance of NFData
01:59:25 <wli> blackh: This is all single-threaded.
02:00:01 <blackh> wli: That's OK - rnf is useful for parallel stuff but also useful for any reason why you want to force evaluation
02:00:17 <wli> How's microbench work? It seems to be sparsely documented.
02:01:05 <wli> hotaru2k3: I'm picking up substantial differences in favor of mine when printing is taken out.
02:01:41 <wli> hotaru2k3: 145.66user 1.31system 2:41.66elapsed 90%CPU (0avgtext+0avgdata 0maxresident)k
02:01:46 <wli> 2184inputs+0outputs (16major+219323minor)pagefaults 0swaps
02:01:51 <wli> That's mine on 10^8
02:02:08 <wli> hotaru2k3: Yours on 10^8 was 173.61user 1.02system 3:03.21elapsed 95%CPU (0avgtext+0avgdata 0maxresident)k
02:02:15 <blackh> you give it a string and an IO ()
02:02:24 <blackh> I'm working on an example...
02:03:29 <wli> It looks like you give it a string and a value of class microbenchable, where run applies the value to an Int.
02:04:08 <wli> I don't know what the string is supposed to do.
02:04:24 <blackh> Prelude Microbench Control.Parallel.Strategies> microbench "test1" $ writeFile "hello" "hello.txt"
02:04:24 <blackh> * test1: ...............
02:04:24 <blackh>   85.906ns per iteration / 11640.67 per second
02:04:29 <blackh> ^ Example
02:04:43 <blackh> There's a cosmetic bug where 'ns' should really read 'us'
02:04:46 <wli> Okay.
02:05:08 <blackh> Now, for pure code, GHC will optimize it down to nothing if you run it repeatedly with the same input.
02:05:42 <blackh> So you have to find a way to "trick" GHC into thinking it's working with a different value.
02:05:51 <blackh> Reading it from an IORef should work
02:06:11 <blackh> I have not tried this. I'll see if it works.
02:07:34 <Araneidae> cabal uninstall ?  Please!
02:07:52 <pumpkin_> ghc-pkg unregister
02:08:01 <Araneidae> Ok.
02:08:08 <blackh> wli: OK - reading it from an IORef works. Here is an example:
02:08:13 <Araneidae> And the cabal database itself, will it follow  suit?
02:08:17 <blackh> wli: x <- newIORef [1..10000]
02:08:24 <pumpkin_> Araneidae: that's all it does :)
02:08:26 <blackh> wli:  microbench "test2" (sum `fmap` readIORef x >>= \x -> rnf x `seq` return ())
02:08:41 <blackh> wli: 594.818ns per iteration / 1681.19 per second.
02:08:51 <Araneidae> Cheers!  Cabal needs some tweaking...
02:10:03 <Araneidae> Oh dear.  I would expect an uninstall function to actually remove stuff -- the "unregistered" application is still there, I'm going to have to remove it by hand.  Annoying...
02:10:08 <wli> blackh: If it's a function from Int -> Integer what do I do?
02:10:56 <blackh> wli: microbench "test2" (rnf (sum [1..10000]) `seq` return () :: IO ()) <-- The point is that this does *not* work
02:11:23 <blackh> wli: Copy my example above and replace your function with 'sum'
02:12:07 <blackh> wli: The reason why the example above doesn't work is because GHC only calculates the 'sum' once, and just returns the answer every subsequent time.
02:12:56 <blackh> wli: Don't forget that 'ns' is wrong! Perhaps I should bug the maintainer about this.
02:13:03 <wli> blackh: Like main = microbench "wli" (fib `fmap` readIORef x >>= \x -> rnf x `seq` return ())
02:14:01 <blackh> wli: That looks good. Actually you could say (readIORef x >>= \x -> rnf (fib x) `seq` return ())
02:14:27 <wli> I don't seem to have Control.Parallel.Strategies
02:15:38 <blackh> wli: The reason why "`seq` return ()" is necessary, is because the IO monad needs to evaluate what IO action to do next, so you know 'return ()' is being evaluated.  Then we just attach a `seq` to get our own stuff evaluated.
02:16:40 <wli> Where is Control.Parallel.Strategies?
02:16:59 <blackh> wli: In the 'parallel' package but it comes with ghc 6.10.1
02:17:15 <wli> What can I use with 6.8.3?
02:17:37 <pumpkin_> @hackage parallel
02:17:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel
02:17:54 <blackh> wli: If it doesn't come with 6.8.3 then just use parallel
02:18:10 <wli> cabal installing
02:18:41 <wli> Um, where's the readIORef x come from?
02:18:46 <wli> Rather, the x?
02:18:56 <pumpkin_> is there an elegant way to tell quickcheck to expect an error for the expression with certain parameters?
02:19:09 <blackh> x <- newIORef <something>
02:19:36 <ImInYourMonad> anyoen good with glfw? is showing text the only way to use textures?
02:20:23 <ImInYourMonad> and how do i display the actual texture?
02:20:49 <wli> blackh: work n = newIORef n >>= readIORef >>= \x -> rnf (fib x) `seq` return ()
02:21:34 <blackh> wli: You can put the newIORef outside the loop - Probably a good idea, because it'll be relatively slow.
02:22:04 <blackh> wli: readIORef is very very fast
02:25:02 <wli> blackh: What sort of guarantee do I have that they're being applied to equal inputs?
02:25:32 <blackh> wli: Can you rephrase that?
02:25:49 <sizur> in my desperate attempt (remembering the goodness of #haskell) i will ask something distantly related to this channel:  How can i typeset the word METAPOST in LaTeX? (#latex doesn't know)
02:26:21 <wli> blackh: It gives some kind of input to the functions of type Int -> IO ()
02:26:30 <wli> blackh: How do I know they're the same inputs?
02:26:43 <callen> sizur: typeset? explain the verbiage please.
02:27:03 <ivanm> sizur: \METAPOST ?
02:27:29 <blackh> wli: Actually I don't know - I've only ever used the IO version
02:27:39 <blackh> wli: The IO version doesn't get passed an integer
02:28:48 <blackh> wli: I am probably doing it the hard way. :)
02:30:31 <pumpkin_> sjanssen: I've added bounds checking to all the uvector bits I know of that are unsafe... now if we set SAFE on by default, you can be happy!
02:33:38 <sizur> ivanm: Unidentified control sequence.
02:34:36 <ivanm> sizur: is there one?
02:34:36 <wli> blackh: Now I'm using this:
02:34:57 <wli> blackh: work n = newIORef n >>= readIORef >>= (`seq` return ()) . rnf . fib ; main = microbench "hotaru" (mapM_ (work . read) =<< getArgs)
02:35:42 <blackh> wli: Wouldn't you want to put getArgs outside the microbench? You don't want to measure the speed of that.
02:36:15 <wli> blackh: It's dwarfed by the computations on the huge Integer values.
02:36:16 <sizur> ivanm: ok, finally found. it's \metapostlogo :P
02:36:48 <blackh> wli: That's OK. Microbench works well on things that take a very short time too
02:37:09 <wli> blackh: The numbers must be large for the asymptotics to set in anyway.
02:41:50 <wli> http://wli.pastebin.com/m11d8ae53
02:43:46 <wli> Fib 10000 100000 1000000 10000000 --> * wli: . 1066608.000ns per iteration / 0.94 per second. * hotaru: . 1164234.000ns per iteration / 0.86 per second.
02:43:56 <pumpkin_> wow :P
02:45:51 <wli> Fib 10000 100000 1000000 10000000 100000000 ---> * wli: . 12800979.000ns per iteration / 7.81e-2 per second. * hotaru: . 15112810.000ns per iteration / 6.62e-2 per second.
02:46:17 <ImInYourMonad> ok i love indian movies. i was thnking online video and tv is hot these days because there is finally enough(?) bandwidth to make ot feasible. now there will probably be opportunities for making a lot of sub-sites in this area and not just youtube and joost that will dominate. what do you think about making a bollywood-internet-tv-on-demand-site? obv right to movies etc would probably cost loads but the movies have commercial break
02:46:55 <ImInYourMonad> yeah i know this is not something a 16yearold would reate from his bedroom but allow me to dream
02:47:08 <wli> I'm not entirely convinced it's the right thing to do since there aren't confidence intervals or anything.
02:47:41 <blackh> wli: You need super-duper-bench, not microbench!
02:47:47 <wli> I'd frankly even prefer head-to-head comparisons and input data and so on with student's t ec.
02:47:59 <wli> s/ec\./etc./
02:49:27 <wli> blackh: Feel free to post to pastebin with suggestions for pulling out of the loop etc.
02:49:42 <blackh> OK... I will
02:50:47 <wli> I'm trying on some bigger numbers.
02:51:58 <wli> I think for the interpreter I should try the TIM (Three Instruction Machine) with SPARC-esque register windowing instead of a stack.
02:52:55 <wli> Fib 10000 100000 1000000 10000000 100000000 1000000000 ---> * wli: . 160082835.000ns per iteration / 6.25e-3 per second. * hotaru: . 187897704.000ns per iteration / 5.32e-3 per second.
02:54:41 <wli> hotaru2k3: Pretty good stuff, though. I'll bet you could get a lot closer (or even beat it) with some micro-optimization.
02:57:51 <hotaru2k3> wli: actually i may have already beat it...
02:58:19 <wli> hotaru2k3: Cool. What's it look like?
02:58:30 <blackh> wli: http://wli.pastebin.com/m42b035e2   <-- Here's a tweaked version with unnecessary stuff taken outside the loop
03:03:41 <hotaru2k3> wli: http://pastebin.com/m2fd944f
03:07:18 <wli> hotaru2k3: Trying it out.
03:08:35 <wli> hotaru2k3: You should be able to run the test harness code, too.
03:10:12 <Heffalump> @seen conal
03:10:12 <lambdabot> I saw conal leaving #haskell and #ghc 6h 22m 41s ago, and .
03:10:19 <hotaru2k3> Fib 100000 1000000 10000000 ---> * wli: . 4022549.000ns per iteration / 0.25 per second. * hotaru: . 3191654.000ns per iteration / 0.31 per second.
03:10:35 <wli> hotaru2k3: Good stuff!
03:10:48 <hotaru2k3> thanks
03:11:15 * wli loses the fastest fib in the west title.
03:11:25 <ImInYourMonad> > toInteger 5.0
03:11:26 <lambdabot>   Add a type signature
03:11:33 <ImInYourMonad> > toInteger 5.0 :: Float
03:11:34 <lambdabot>   Couldn't match expected type `Float'
03:11:40 <ImInYourMonad> > toInteger (5.0 :: Float)
03:11:41 <lambdabot>       No instance for (Integral Float)
03:11:42 <lambdabot>        arising from a use of `toIntege...
03:11:47 <ImInYourMonad> > toInteger (5.0 :: Double)
03:11:48 <lambdabot>       No instance for (Integral Double)
03:11:48 <lambdabot>        arising from a use of `toInteg...
03:11:50 <ImInYourMonad> ?
03:11:57 <mxc> :t toInteger
03:11:58 <lambdabot> forall a. (Integral a) => a -> Integer
03:12:11 <mxc> :t 5.0
03:12:12 <lambdabot> forall t. (Fractional t) => t
03:12:18 <hotaru2k3> > floor 5.0
03:12:19 <lambdabot>   5
03:12:22 <mxc> yeah
03:12:47 <mxc> anyone here familiar with happstack?
03:12:56 <wli> ./Fib 10000 100000 1000000 10000000 100000000 1000000000 ---> * wli: . 163317727.000ns per iteration / 6.12e-3 per second. * hotaru: . 133249282.000ns per iteration / 7.50e-3 per second.
03:13:03 <wli> hotaru2k3: I see it too.
03:13:13 <mxc> and if happstack 0.2 is ready for 'primetime'
03:13:43 <mxc> ?seen ndm
03:13:43 <lambdabot> I haven't seen ndm.
03:14:20 <pumpkin_> how many digits does the 1000000000th fibonacci number have?
03:16:29 <wli> No idea.
03:17:42 <ImInYourMonad> is there a function: map fromIntegral?
03:17:53 <pumpkin_> that seems awfully specific
03:18:02 <pumpkin_> so yes, the function is map fromIntegral ;)
03:22:04 * hotaru2k3 wonders if there's a "fastest factorial in the west"...
03:23:17 <wli> Now I'm curious as to why it's faster.
03:24:16 <ImInYourMonad> lol
03:24:26 <Gracenotes> > filterM (const [True, False]) [1,2,3]
03:24:27 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
03:24:36 <Gracenotes> > filterM (const [False, True]) [1,2,3]
03:24:37 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
03:25:01 <Gracenotes> hm :/
03:25:04 <blackh> wli: Oh dear - that's what got me and Axman6 started on benchmarks.
03:27:26 <wli> http://wli.pastebin.com/m505b90d8 <-- final version
03:29:10 <wli> I get slightly different results when it's 2^n - 1
03:31:25 <wli> ./Fib $(( 2**26 - 1 )) $(( 2**27 - 1 )) $(( 2**28 - 1 )) ---> * wli: . 54182277.000ns per iteration / 1.85e-2 per second. * hotaru: . 54217299.000ns per iteration / 1.84e-2 per second.
03:32:15 <pumpkin_> have you tried with -fvia-C and various c optimizations?
03:32:20 <wli> $ ./Fib $(( 2**24 - 1 )) $(( 2**25 - 1 )) $(( 2**26 - 1 )) ---> * wli: . 12122438.000ns per iteration / 8.25e-2 per second. * hotaru: . 12291029.000ns per iteration / 8.14e-2 per second.
03:32:25 <wli> pumpkin: no
03:32:36 <pumpkin_> not sure if would make any difference, but one of the two might be easier for the c backend to deal with
03:32:39 <wli> pumpkin: Just ghc -O2
03:32:57 <callen> pumpkin wli is there some reason why, as I learn haskell, that the list/tuple-ness of it reminds me of Lisp?
03:33:12 <pumpkin_> parentheses maybe? :P
03:33:32 <wli> Lists as control stacks etc.
03:33:34 <callen> pumpkin: no, I mean the structure and fundamentalness of the tuples and lists.
03:33:54 <pumpkin_> but in lisp aren't lists just nested tuples?
03:34:07 <pumpkin_> or am I confused
03:34:31 <callen> you're technically correct, but Lisp is homoiconic, has s-expressions, etc.
03:34:45 <hotaru2k3> wli: "_ -> undefined" slows it down
03:34:50 <callen> Lisp strikes me as marginally less elegant with respect to algorithms.
03:35:00 <callen> seems more powerful though.
03:35:21 <wli> hotaru2k3: I was just trying to shut up warnings. It's still winning in general.
03:35:24 <pumpkin_> depends what you mean by more powerful
03:35:27 <callen> I don't know all of haskell yet, so we'll see.
03:35:34 <pumpkin_> it's easier to write macros for
03:35:44 <pumpkin_> but you tend to not need to write macros as much for haskell
03:35:45 <callen> pumpkin: lisp makes it obscenely easy to add complex and broad new features to existing software.
03:36:57 <pumpkin_> that seems to be generally true in haskell, except for the fact that you might need to make significant changes if you decide you need stateful behavior in a pure function after writing it
03:37:13 <int-e> wli: why do you convert to Integer in hotaru? (divMod (fromIntegral n :: Integer) 2)
03:37:35 <callen> pumpkin: *smacks forehead* oh right, the type system is way different between the two.
03:37:42 <pumpkin_> :)
03:38:16 <callen> pumpkin: luckily spending some time with C and the derivatives thereof have me acclimated to it.
03:38:33 <pumpkin_> aha, but haskell's types are vastly more powerful than c's
03:38:49 <pumpkin_> and you also have to deal with them explicitly a lot less, due to inference, which is relieving :)
03:39:48 <callen> pumpkin: true, and the existence of arbitrary length integers was relieving since I happen to rather like projecteuler.
03:40:01 <callen> pumpkin: I don't like having to f$@#$ with BigNum libs in C.
03:40:03 <callen> At all.
03:40:14 <blackh> I am not sure if this is relevant, but I have come to the conclusion that object oriented code gets longer as the quality improves (split into more classes), while Haskell gets shorted as the quality improves.
03:40:43 <callen> blackh: I am delighted with the structure of the code thus far. OCaml made me feel like I was being pounded in the face.
03:40:51 <callen> blackh: I know what this feels like because I've boxed before.
03:40:56 <callen> or more accurately, been boxed.
03:41:08 <callen> ProTip: Don't challenge amateur boxers to a fight.
03:41:18 <Zao> callen: It's a common feeling :)
03:41:24 <Gracenotes> whoa, I didn't realize my own school had video lectures of an algorithms course, just like MIT's (but with a different textbook)
03:41:26 <Gracenotes> -- http://www.cs.sunysb.edu/~algorith/video-lectures/
03:41:26 <blackh> callen: Ouch! Well, I can wax lyrical about Haskell for ages, but I come entirely from Imperativeland.
03:41:35 <Gracenotes> I'll have to watch it some time
03:41:40 <Gracenotes> or better yet, attend the class ;)
03:41:57 <callen> blackh: I come from a hybrid of C, asm, ruby, lisp. some middle-ground object oriented stuff too.
03:42:12 <callen> Gracenotes: coooooool. :)
03:43:09 <callen> blackh pumpkin Gracenotes => I have to admit, using haskell with anything requiring algorithms like project euler feels like cheating.
03:43:32 <pumpkin_> don't worry, it's only the early problems that can be solved using readily available libraries :)
03:43:50 <callen> pumpkin: no, I always use my own algorithms. I never use libraries.
03:44:48 <pumpkin_> either way, the amount of difference decreases as you go along
03:44:55 <catface> @pl comp2 f g a b = f (g a) (g b)
03:44:55 <lambdabot> comp2 = join . ((flip . ((.) .)) .) . (.)
03:45:31 <callen> catface: what's pl?
03:45:37 <mauke> @help pl
03:45:37 <lambdabot> pointless <expr>. Play with pointfree code.
03:45:44 <pumpkin_> catface: on would help there probably
03:46:03 <mauke> catface: f `on` g
03:46:33 <pumpkin_> comp2 = on
03:48:19 <callen> pumpkin: this pointsfree stuff is making me go for a loop like when I finally " aha'd " lisp.
03:48:29 <pumpkin_> :)
03:48:33 <pumpkin_> it's fun
03:48:36 <callen> however, I'm still in the confusion prior to that state, but I can see the *why*
03:48:48 <pumpkin_> sometimes it makes code clearer, sometimes it makes it more obscure
03:49:19 <mauke> http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
03:49:29 <callen> f x = x + 1         into         f = (+ 1)     This would really mess with an imperative coder.
03:49:45 <mauke> it's not so weird once you understand currying
03:49:57 <wli> I'll bet at least some of it is due to unrolling of recursion.
03:50:13 <wli> ... which doesn't happen across module boundaries.
03:50:23 <callen> mauke: I don't, I finally buckled down and started tinkering last night.
03:51:16 <mauke> (defun plus (x) (lambda (y) (+ x y)))
03:52:23 <wli> My first FP lang was Standard ML. I went on a big language learning kick in 1996 or 1997.
03:52:23 <catface> thanks pumpkin
03:53:11 <wli> Standard ML, Objective Caml, Haskell, Prolog, Mercury, Scheme, Common Lisp, and a number of others. I've mostly retained only that list, though.
03:53:26 <callen> mauke: why the s-expression?
03:53:31 <Gracenotes> Bring on into Prelude! Bring on into Prelude! Bring on into Prelude!
03:53:45 <callen> Gracenotes: ???
03:53:53 <Gracenotes> Data.Function.on
03:53:58 <wli> There was weird stuff like Eiffel and Modula-3 in there, too.
03:54:04 <mauke> callen: because you said you know Lisp
03:55:42 <callen> mauke: were you using a lambda to explain currying?
03:57:38 <Gracenotes> > let plus a b = a+b; plusOne = plus 1 in plusOne 5
03:57:40 <lambdabot>   6
03:57:51 <catface> i love how "looping constructs" like map, iterate are just functions
03:58:03 <callen> Gracenotes: partial app?
03:58:05 <mauke> callen: yes
03:58:26 <Gracenotes> callen: it's not even so much mapping as just applying
03:58:39 <Gracenotes> oh, yes, sorry, misread
03:59:42 <callen> Gracenotes: absorbing as much as I can, but Star Trek is an excellent distraction. dual monitors will do that to you.
04:00:19 <Gracenotes> hah. well, you can't put dual monitors on your lap.
04:00:27 <Gracenotes> (not like you'd want to)
04:00:31 <callen> Gracenotes: my lappy died, I use the desktop now.
04:00:36 <callen> Gracenotes: you can have that if you use a Thinkpad.
04:01:04 <Gracenotes> thinkpad? nope
04:01:47 <callen> Gracenotes: yup, the W series have the option of a secondary pull-out display
04:01:55 <callen> and it's juuuuust big enough for a couple terminals. :D
04:02:57 <Gracenotes> oh, I see. Yeah, have a Dell and an HP Mininote
04:03:45 <callen> Gracenotes: what model Dell? Happy with it?
04:04:24 <Gracenotes> an Inspiron 1525, and yep, happy. The keyboard sucks though.
04:04:52 <callen> Gracenotes: you know, my now-dead 600m had a great keyboard.
04:05:03 <callen> not very 'sturdy', but a good feel.
04:05:14 <callen> Gracenotes: OS?
04:05:25 <Gracenotes> the keys stick a bit too often (not even using springs!), but they can be fixed with some jabbing
04:05:27 <Gracenotes> Ubuntu
04:05:42 <Gracenotes> I bought the laptop with it; Dell has that option.
04:05:52 <callen> so I've been told.
04:06:23 <Gracenotes> @type Map.fromList . zip
04:06:24 <lambdabot> Couldn't find qualified module.
04:07:03 <Gracenotes> @type (M.fromList .) . zip
04:07:04 <lambdabot> forall a b. (Ord a) => [a] -> [b] -> M.Map a b
04:08:46 <ImInYourMonad> how do I avoid re-writing the whole screen in opengl rather than just the part that changed?
04:09:16 <Zao> ImInYourMonad: You don't, generally.
04:12:02 <wli> Is there some way to get ghc to inline foldl'?
04:12:52 <blackh> wli: You could try inline from GHC.Exts but it might be inlining it anyway
04:13:03 <wli> -ddump-core?
04:16:30 <wli> I see external calls to testBit and dropWhile
04:24:02 <wli> I think foldl' got inlined but not dropWhile or testBit
04:25:37 <Baughn> Is there anyone around who can get me an account on the haskell.org wiki?
04:26:12 <wli> I basically need/want that idiot loop unrolled.
04:26:48 <ImInYourMonad> so to overwrite locally in opengl how do you do? dont swapbuffers?
04:27:20 <Baughn> ImInYourMonad: Could you rephrase that?
04:27:49 <Gracenotes> Baughn: yes.
04:28:02 <ImInYourMonad> 'dont use GL.clear [GL.ColorBuffer]
04:28:27 <Baughn> ..I don't see why not. That's a perfectly normal part of the rendering loop.
04:29:00 <Baughn> Buffer swaps are fine and all, but they often won't clear the buffer that gets swapped in
04:29:31 <Zao> By design.
04:29:36 <Gracenotes> Baughn: you can email Ashley Yakeley <ashley@semantic.org>
04:29:44 <Gracenotes> with your intended account name and email address
04:29:49 <Baughn> Gracenotes: Ah. Thanks
04:29:54 <Zao> clear color+depth, draw, flip, repeat.
04:29:56 <wli> It sort of seemed to help to pull the testBit out.
04:30:03 <Gracenotes> then once it's created, reset the password using your email
04:30:12 <Baughn> Zao: I've found that depending on either behaviour won't work
04:30:36 <Zao> Baughn: Always clear and you're safe.
04:30:56 <Baughn> Zao: Well, sure. Unless you're /trying/ to exploit partial printing. :P
04:31:13 <Zao> Baughn: For which you should use accumulation buffers anyway.
04:31:24 <Baughn> Zao: Which aren't supported on the older cards
04:31:35 <Zao> Neither is GL, if you go far enough back :P
04:32:00 <Zao> Accumulation buffers are 1.1, so you'd have to go quite far back.
04:32:06 <Baughn> Actually, accumulation buffers? I'd been using framebuffers
04:32:28 <Baughn> Hmm
04:32:42 <Zao> pbuffers and FBOs are modern and sane.
04:33:01 <Baughn> I'm dealing with some very non-modern, non-sane cards
04:33:11 <Baughn> How would I use accumulation buffers to do this, anyhow?
04:33:42 <Zao> No idea really, I've never used them.
04:33:50 <Baughn> Eh
04:34:00 <Zao> From what I see, they're mostly used to implement cheap motion blur by blending in the previous frame.
04:34:21 <Baughn> Well, actually, I can see how
04:34:28 <Baughn> Hm. Looks like it'd work fine.
04:35:08 <ImInYourMonad> well not using gl.clear [gl.colorBuffer] helped me now. but im still unclear on what the actual way to draw things in opengl is, i mean i can do it but im not sure i use the right methods it he right order
04:35:40 <Baughn> ImInYourMonad: I'd suggest reading the nehe tutorials..
04:35:47 <paper_cc> @go NeHe
04:35:51 <lambdabot> http://nehe.gamedev.net/
04:35:51 <lambdabot> Title: NeHe Productions: Main Page
04:36:11 <Zao> ImInYourMonad: Set up relevant view and projection matrices, clear, draw primitives, flip, repeat.
04:36:59 <Zao> If you're using immediate mode (which I assume you are), you can affect subsequent glVertex calls by calling glTexcoord, glColor, glNormal and such prior.
04:37:18 <ImInYourMonad> > transpose [1,2,3]
04:37:19 <lambdabot>       No instance for (Num [a])
04:37:19 <lambdabot>        arising from the literal `1' at <inter...
04:37:23 <Zao> ImInYourMonad: http://fly.cc.fer.hr/~unreal/theredbook/
04:38:15 <ImInYourMonad> > transpose [[1],[2],[3]]
04:38:16 <lambdabot>   [[1,2,3]]
04:39:22 <Gracenotes> > transpose [[1,2], [3,4]]
04:39:23 <lambdabot>   [[1,3],[2,4]]
04:39:28 <Gracenotes> it's flipping along the diagonal
04:40:04 <Gracenotes> (which you might already know... just mentioning anyway)
04:40:17 <Gracenotes> :s
04:40:24 <mauke> transpose == zipN
04:43:01 <Gracenotes> s:
04:48:37 <toyvo> hello. i am trying to make a package portable to ghc8, and am having trouble with Control.Exception.try which changed a lot since then.. What's the best way to do this?
04:48:49 <toyvo> s/ghc8/ghc6.8
04:49:31 <catface> can you call a non-function (with typeclass tricks or something?)
04:50:10 <toyvo> hm how would that work? what i want to do basically is to catch /any/ kind of exception
04:50:23 <toyvo> in ghc 6.8 Exception was a type, while in ghc6.10 it is a type class
04:50:35 <Heffalump> toyvo: why do you want to catch any exception?
04:50:54 <Baughn> catface: Define "call". Pass parameters to one?
04:51:11 <Baughn> catface: If so, no. Otherwise, all thunks can be considered nullary functions anyhow.
04:51:31 <catface> be able to type nonfunc 2 3
04:51:47 <toyvo> Heffalump: basically it's a library for writing unix daemons. catching exceptions here is a safety belt of sorts. the assumption is it never happens, but if it does, it's nice to have the exception printed out to syslog
04:51:49 <Baughn> catface: Yeah. Not going to happen.
04:52:29 <Baughn> catface: nonfunc ^$^ 2 3, maybe, but there ^$^ would be a function that creates (or extracts) the function you actually want to call somehow
04:52:52 <Heffalump> you can use onException to do something when the error happens, but it'll get rethrown afterwards
04:53:04 <Heffalump> I had a vague feeling there was a catchAny, but I can't find it.
04:53:38 <toyvo> Heffalump: well i know how to do it in both versions of GHC separately, but not in both :)
04:54:16 <Heffalump> toyvo: oh, right. Use the extensible-extensions package, I think.
04:54:25 <Heffalump> extensible-exceptions
04:54:37 <toyvo> thanks a lot! will look into it
04:54:39 <Heffalump> that uses preprocessor magic to give a consistent interface
04:55:40 <toyvo> looks like exactly the solution!! i love #haskell. thanks!
05:15:12 <stulli> Hi. Im trying to reproduce the parallel quicksort from RWH, but the use of force gives me this error message:
05:15:17 <stulli> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2382#a2382
05:15:31 <stulli> the code is also in the hpaste
05:16:17 <Baughn> stulli: You need to add an NFData constraint
05:16:55 <stulli> like (NFData a) => ?
05:17:03 <Baughn> Yep
05:17:25 <Baughn> You can't use force on just any value
05:18:07 <stulli> Ok, thanks. When cant i use force?
05:18:22 <Baughn> When the value's type isn't an instance of NFData.
05:18:50 <Baughn> @type force
05:18:51 <lambdabot> forall a. (NFData a) => a -> a
05:18:54 <Baughn> See?
05:19:07 <rabideejit> is there a MonadPlus version of filter?  Something like MonadPlus m => ( a -> Bool ) -> [ a ] -> m a
05:19:49 <Baughn> stulli: Incidentally, force is normally an O(n) operation - it'll walk the entire data structure you pass to it.
05:19:56 <Gracenotes> > force [1,2,3]
05:19:57 <lambdabot>   mueval: Prelude.read: no parse
05:19:57 <lambdabot>  mueval: UnknownError "GHC reported errors a...
05:20:03 <mauke> @undefine
05:20:10 <mauke> > force [1,2,3]
05:20:11 <lambdabot>   mueval: Prelude.read: no parse
05:20:11 <lambdabot>  mueval: UnknownError "GHC reported errors a...
05:20:14 <mauke> > 2
05:20:15 <lambdabot>   2
05:20:18 <mauke> what
05:20:24 <Baughn> These errors really could use some fixing
05:20:28 <Gracenotes> 'no parse' vs. 'not in scope'
05:20:37 <Saizan> > foooo
05:20:38 <lambdabot>   Not in scope: `foooo'
05:20:43 <Gracenotes> dunno. I think lambdabot's a tricky little thing, isn't it
05:20:52 <Baughn> Oh yes. Very tricky.
05:21:19 <Gracenotes> > const 3 force
05:21:19 <lambdabot>   Add a type signature
05:21:25 <Saizan> @seen lispy
05:21:25 <lambdabot> lispy is in #haskell-blah, #darcs and #haskell. I don't know when lispy last spoke.
05:21:30 <Gracenotes> > const 3 (force::Int->Int)
05:21:31 <lambdabot>   mueval: Prelude.read: no parse
05:21:31 <lambdabot>  mueval: UnknownError "GHC reported errors a...
05:22:21 <wli> Is it -optc-funroll-loops?
05:22:35 <stulli> Baughn: Im still thinking about it, i think im happy to know that force cant be used with everything and leave the "why" for later :)
05:22:45 <Baughn> wli: -optc-O3, more like
05:23:07 <wli> Thanks.
05:23:13 <Baughn> stulli: You really should learn how typeclasses work at a basic level before starting in parallelization. -_-
05:23:52 <Baughn> wli: (Which implies -funroll-loops, but also a lot of other stuff. -funroll-loops is, by the way, generally considered a bad idea.)
05:24:21 <wli> Yeah. It's slower. But for this case I have a loop that should be unrolled.
05:24:46 <Baughn> Mm. Theoretically ghc should be able to handle the unrolling, but unfortunately that's still in the future
05:24:52 <Baughn> So -fvia-c -optc-O3 is the best you can do
05:25:19 <wli> It's not getting unraveled far enough for -fvia-C -optc-O3 to help.
05:25:49 <Baughn> wli: There's also the option of manual unrolling, if you don't mind the extra work
05:26:25 <wli> That's 32 copies of the loop body.
05:29:11 <Heffalump> you could use TH to do it
05:31:57 <wli> Aha, error in transcription.
05:32:05 <irekj> ]
05:32:06 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
05:33:26 <ImInYourMonad> in Vim: how do I remove the icons beneath the File | Edit | ... menu? #vim is quiet...
05:33:49 <ivanm> is there any way of shortening the module listing in ghci?
05:33:50 <BONUS> :set guioptions-=m
05:33:52 <BONUS> try this?
05:33:52 <Zao> se go-=T
05:34:06 <Zao> m is the menu, T is the toolbar.
05:34:13 <mauke> alias gvim=vim
05:34:31 <Zao> :he 'go  for the whole list of options
05:34:39 <Gracenotes> @. run run "'" ++ intercalate "':'" (map return "o nos") ++ "':[]"
05:34:41 <lambdabot>   "'o':' ':'n':'o':'s':[]"
05:34:54 <Gracenotes> @. run run text $ "'" ++ intercalate "':'" (map return "o nos") ++ "':[]"
05:34:56 <lambdabot>   "o nos"
05:35:37 <ImInYourMonad> thats was the wrong menu, iw ant the menus, not the icosn beneath the menu
05:36:08 <wli> I managed to get rid of dropWhile and foldl' (whether or not foldl' was getting inlined anyway).
05:41:53 <wli> Okay, this is retarded.
05:42:06 <wli> The winner is whoever runs last.
05:43:04 <wli> It's nothing to do with the algorithms and everything to do with RTS bullcrap.
05:44:10 <wli> Okay, microbench sucks. It's giving wrong answers.
05:48:27 <wli> False alarm on the Fastest Fib in the West. :(
05:48:37 <wli> The answers thus far are inconclusive.
05:48:54 <wli> * wli: . 12486376.000ns per iteration / 8.01e-2 per second.
05:49:09 <wli> * hotaru: . 12484302.000ns per iteration / 8.01e-2 per second.
05:51:27 <wli> from ./Fib $(( 2**24 - 1 )) $(( 2**25 - 1 )) $(( 2**26 - 1 )) $(( 10**5 )) $(( 10**6 )) $(( 10**7 ))
05:55:03 <wli> I've got a slight edge after some tweaks but am still unconvinced the tests are reliable enough to distinguish between them.
05:56:21 <wli> * hotaru: . 36252418.000ns per iteration / 2.76e-2 per second.
05:56:28 <twb> Does Cabal have any concept of $mandir, the path into which manpages are installed?
05:56:42 <wli> * wli: . 34968644.000ns per iteration / 2.86e-2 per second.
05:56:58 <wli> For $ ./Fib $(( 2**25 - 1 )) $(( 2**26 - 1 )) $(( 2**27 - 1 )) $(( 10**6 )) $(( 10**7 )) $(( 10**8 ))
05:58:19 <wli> http://wli.pastebin.com/m417ddf39
06:00:25 <blackh> wli: Speed kills, you know!
06:01:01 <dcoutts> twb: it does actually, but it has no other support for installing man pages
06:01:36 <blackh> wli: I should also say, well done!
06:02:19 <tibbe> if I take something someone else wrote in e.g. C and create a Haskell version of it. What's the proper English expression for that, "adopted from"?
06:02:48 <tibbe> it's not a pure cut-n-paste since it has been modified to be Hakelly
06:02:54 <tibbe> Haskelly*
06:02:59 <Baughn> "Babelfished", posibly
06:03:11 <mauke> transliterated
06:03:12 <wli> blackh: Well, it was dumb explicit recursion in order to get rid of cross-module call overhead.
06:03:15 <FunctorSalad_> adapted?
06:03:20 <Baughn> Ported?
06:03:28 <twb> dcoutts: er, does that mean that I basically have to add a postCopy that says something like getMandir >>= \d -> install "doc/darcs.1" d?
06:03:30 <tibbe> FunctorSalad_: yes, that was what I was looking for
06:03:44 <dcoutts> twb: exactly
06:03:50 <twb> dcoutts: OK, cool.
06:04:02 <dcoutts> twb: only the code is less pretty
06:04:38 <twb> dcoutts: well of course :P
06:04:47 <dcoutts> heh
06:05:07 <twb> Haskell is not exactly an ideal fit for an autoconf-and-make tool :P
06:08:18 <ImInYourMonad> thats was the wrong menu, iw ant the menus, not the icosn beneath the menu
06:08:21 <ImInYourMonad> in Vim: how do I remove the icons beneath the File | Edit | ... menu? #vim is quiet...
06:08:44 <twb> OK, so Distribution.Simple.InstallDirs provides the actual mandir, but how do I get the appropriate InstallDirs object?
06:08:53 <Zao> ImInYourMonad: -=T didn't do it?
06:08:59 <Zao> I assume you're referring to the toolbar.
06:09:04 <pejo> Im, zao answered your question right below the other answer last time.
06:12:04 * twb tries downloading the "whole hackage" tarball, unpacking it, and grep -r'ing it for examples.
06:14:14 <FunctorSalad_> I accidentally the whole hackage
06:14:51 <FunctorSalad_> but good idea :)
06:15:17 <chessguy> @type ?foo >>= return
06:15:18 <lambdabot> forall (m :: * -> *) a. (Monad m, ?foo::m a) => m a
06:15:42 <chessguy> @type ?foo >>= return . ?bar
06:15:43 <lambdabot> forall a b (m :: * -> *). (?bar::a -> b, Monad m, ?foo::m a) => m b
06:16:24 <twb> Hackage maintainers: please arrange matters so that an HTTP HEAD of archive.tar will return a Content-Length!
06:17:13 <twb> (I'm also too scared to try a wget --continue (i.e. a Range'd GET).
06:23:46 <Peaker> hmm.. attempted solution of euler27: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2383#a2383
06:23:49 <Peaker> causes a stack overflow
06:24:02 <Peaker> everything here should run in O(1) memory, really
06:24:51 <mauke> > 2000^2
06:24:52 <lambdabot>   4000000
06:25:51 <Peaker> @hoogle maximumBy
06:25:51 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
06:25:51 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
06:25:59 <Peaker> is maximumBy lazy?
06:26:19 <Peaker> @src maximumBy
06:26:19 <lambdabot> Source not found. It can only be attributed to human error.
06:27:01 <bolrod> @src Data.List.maximumBy
06:27:01 <lambdabot> Source not found. Do you think like you type?
06:27:13 <Peaker> @hoogle foldl1'
06:27:14 <lambdabot> Data.ByteString foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
06:27:14 <lambdabot> Data.List foldl1' :: (a -> a -> a) -> [a] -> a
06:27:14 <lambdabot> Data.ByteString.Char8 foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
06:28:31 <int-e> Peaker: yes. it uses foldl1 internally
06:29:13 <Peaker> int-e: strict foldl1'?
06:29:40 <Peaker> @src maximum
06:29:40 <lambdabot> maximum [] = undefined
06:29:40 <lambdabot> maximum xs = foldl1 max xs
06:29:50 <Peaker> lazy foldl1?
06:31:01 <ImInYourMonad> wait, does glfw only support 2D?
06:31:10 <int-e> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2383#a2384
06:31:24 <int-e> Peaker: if I meant foldl1' I'd have written foldl1' ;-)
06:31:24 <ImInYourMonad> how do I create a window in only opengl?
06:32:44 <twb> @hoogle Distribution.Package.PackageIdentifier -> PackageDescription
06:32:44 <lambdabot> Parse error:
06:32:44 <lambdabot>   --count=20 "Distribution.Package.PackageIdentifier -> PackageDescription"
06:32:44 <lambdabot>                          ^
06:32:51 <wli> Now with some comments: http://wli.pastebin.com/m56fa0239
06:32:54 <Peaker> int-e: why use foldl1 and not foldl1'?
06:32:54 <twb> @hoogle PackageIdentifier -> PackageDescription
06:32:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:32:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:32:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
06:33:10 <int-e> ImInYourMonad: OpenGL doesn't do that. GLX and WGL do, and GLUT provides utilities for that.
06:33:21 <twb> I can never seem to work out what the hell I'm doing on my own :-/
06:33:37 <Zao> ImInYourMonad: "only support 2D"?
06:33:57 <ImInYourMonad> Zao not only as in little but it doesnt support 3d?
06:34:17 <Zao> GLFW only provides windowing, input and such.
06:34:47 <Zao> You use the usual OpenGL commands to do things, and there's nothing inherently 2D there.
06:34:51 <int-e> Peaker: I don't know. Or, equally unsatisfactory: "because Haskell 98 specifies it that way."
06:35:03 <FunctorSalad_> ImInYourMonad: this is for GLUT, but I found it great for getting going http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-1
06:35:38 <FunctorSalad_> the issues like "how the hell do I make a window and draw on the screen" are always the most scary ;)
06:35:56 <ImInYourMonad> yes
06:36:03 <ImInYourMonad> wait 3d is just 2d anyway right
06:36:34 <ImInYourMonad> glut seeems nicer
06:36:42 <Zao> http://www.acc.umu.se/~zao/Hastris/trunk/
06:36:47 <FunctorSalad_> ImInYourMonad: you send 3d primitives to OpenGL, you don't need to do the perspective projection manually :)
06:36:52 <Zao> FancyUI.hs there might make things clearer, or muddier.
06:37:53 <Zao> Notable bits is the reshape function that sets the projection and base view matrix, and the draw* functions that actually draws things.
06:45:28 <wli> With some results: http://wli.pastebin.com/m2c4818e7
06:46:20 <FunctorSalad_> so should you use an AppEnvironment containing IORefs or a IORef containing an AppState for OpenGL? :)
06:46:44 <FunctorSalad_> I guess with the former you can distinguish mutable and immutable parts of the state
06:47:23 <ImInYourMonad>  glVertex3f( 1.0f,-1.0f, 1.0f) , bu the last one is z right? glfw doesnt support that?
06:47:41 <ImInYourMonad> because i use a vertex4 but nothing was drawn
06:47:42 <mstr> SDL is probably nicer than GLUT
06:50:38 <Peaker> Yeah, SDL is much nicer to use
06:50:47 <Peaker> but unfortunately, only OpenGL/GLUT give you good graphics performance :-(
06:51:17 <ImInYourMonad> but for a 2d-scroller shmup, is it good enough? i used sdl in scheme  just very little, it seemed easy
06:51:18 <twb> SDL still tells the WM that *every* window it ever creates is a dialog :-/
06:52:44 <Peaker> ImInYourMonad: even a scroller is much nicer with OpenGL (SDL+OpenGL or GLUT+OpenGL) because you can set sync-to-vblank and get muuuuch smoother scroll
06:53:05 <Peaker> smooth scroll is really important and I think its sad that sync-to-vblank is not the default (and worse, its pretty hard to enable for 2d graphics :-( )
06:53:42 <ImInYourMonad> peaker: what do ou mean sdl vs sdl+opengl isnt sdl sdlopengl
06:53:59 <Peaker> ImInYourMonad: SDL has its own 2d drawing which is easy to use
06:54:09 <Peaker> ImInYourMonad: or you can just use SDL for events/etc but draw via opengl
06:54:15 <ImInYourMonad> ok
06:54:16 <Peaker> ImInYourMonad: opengl is not very easy to use
06:54:37 <guenni> any takusen users here?
06:55:14 <ImInYourMonad> opengl doesnt have any windowing by default right?
06:55:44 <twb> Argh!
06:56:01 <twb> It doesn't help that there's a lag between hitting C-x C-s and tramp actually saving it on the remote end.
06:56:25 <Peaker> ImInYourMonad: GLUT is the library meant to make windowing stuff easy with OGL
06:56:26 <twb> So I'm sitting there going "hmm, that didn't work", but the compile *actually* failed because the edit hadn't propagated through
06:56:52 <FunctorSalad_> what's nicer about SDL than GLUT?
06:57:04 <ImInYourMonad> i want the full powr of opengl but some framework that does make it easy to get windows up
06:57:13 <FunctorSalad_> (and what's sync-to-vblank? :))
06:57:37 <Peaker> FunctorSalad_: SDL 2d drawing is nicer than OpenGL 2d drawing
06:58:08 <FunctorSalad_> hmm can't you just draw 3d stuff in a plane?
06:58:13 <Peaker> FunctorSalad_: sync-to-vblank is the ability to wait until the copy from video memory to the screen is complete, so you don't draw (overwrite video memory) while its copying and get a "tear effect" where half the image is from one frame and half from the other frame
06:58:31 <FunctorSalad_> (and set orthographic projection if that's possible)
06:58:37 <Peaker> FunctorSalad_: you can, its significantly harder to do 3d drawing on a plane than it is to just blit surfaces and draw shapes with SDL
06:59:10 <Peaker> FunctorSalad_: the tear effect is really common, and really annoying
06:59:25 <Peaker> FunctorSalad_: its pretty amazing how good it looks when its completely smooth and sync'd to the screen's FPS
06:59:26 <mykelyk> >1
06:59:31 <FunctorSalad_> Peaker: isn't that prevented by DoubleBuffer too?
06:59:44 <Peaker> FunctorSalad_: no, even double buffer switch causes tear effect, its not atmoic
06:59:46 <Peaker> s/atomic
07:00:07 <FunctorSalad_> ah I see, synced to the screen
07:00:26 <FunctorSalad_> I'll have to see how to set that in HOpenGL :)
07:00:33 <Peaker> FunctorSalad_: my friend wrote a text reader which is sync-to-vblank'd.. so much nicer to use than a browser or such
07:02:28 <FunctorSalad_> Peaker: I think I've seen it without knowing the name, some OpenGL apps just seem smoother than the usual graphics
07:03:23 <Peaker> FunctorSalad_: tear effect just seems ugly until you learn to recognize it. its too fast to notice but looks like an ugly horizontal line somewhere on the screen
07:03:37 <FatalDooM> Cool police chse video :)) http://www.policejnihonicky.ic.cz
07:03:48 --- mode: ChanServ set +o mauke
07:04:33 <twb> Argh, no wonder it wasn't working.
07:04:49 <twb> There are two functions both called absoluteInstallDirs, and I was importing the "low level" one.
07:05:43 <FunctorSalad_> Peaker: can't find "sync" or "blank" in the HOpenGL/GLUT index
07:05:48 --- mode: mauke set -o mauke
07:06:16 <mykelyk> > 1
07:06:19 <lambdabot>   1
07:06:38 <mykelyk> > reverse [1..]
07:06:55 <lambdabot>   thread killed
07:07:08 <FunctorSalad_> Peaker: any other name that option may go by?
07:07:50 <Peaker> FunctorSalad_: GL_SWAP_CONTROL
07:07:59 <Peaker> oh wait, that may be pygame-specific :)
07:08:55 <twb> So damn close...
07:09:10 <twb> This doesn't work because $PWD is wrong, I guess:
07:09:11 <twb> copyFile "doc/darcs.1 " $ (dir </> "man1/darcs.1")
07:09:49 <Peaker> FunctorSalad_: C code that enables its use: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2385#a2385
07:10:04 <Peaker> in the context of SDL that is
07:11:30 <Peaker> FunctorSalad_: "GLX_SGI_swap_control" is the name of the GLX extension, glXSwapIntervalSGI is the name of the function to look up and call with GetProcAddress. again, its sad its not always on by default :-(
07:12:04 <Peaker> FunctorSalad_: maybe HOpenGL should just call that on the C side at init time
07:12:19 <FunctorSalad_> Peaker: ah, I'll check out this variable http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GL-StringQueries.html#v%3AglExtensions
07:13:03 <Peaker> who thought it was reasonable to have tear effect by default? :-(
07:15:01 <Peaker> FunctorSalad_: trying to call "get" on that gets a seg fault here
07:16:16 <FunctorSalad_> Peaker: did you getArgsAndInitialize?
07:16:34 <FunctorSalad_> and maybe createWindow too
07:16:50 <FunctorSalad_> it dumps lots of extensions for me but can't find that one
07:18:17 <Peaker> FunctorSalad_: still seg faults here
07:18:19 <mykelyk> How can I use hDeleteMany from Data.HList?
07:18:23 <Peaker> try createWindow now I guess
07:19:18 <Peaker> FunctorSalad_: ah, after createWindow its ok
07:20:42 <mykelyk> No HList guru here?
07:21:09 <FunctorSalad_> Peaker: it prints a bunch of GL_ARB, GL_NV, GL_EXT stuff so I guess the driver is working, but no GLX_SGI_swap_control
07:21:27 <Peaker> FunctorSalad_: I can't see it here either, but that's weird iirc I had it on this machine before
07:22:25 <Peaker> FunctorSalad_: also, enabling it in SDL does work and it uses that string
07:22:33 <Peaker> FunctorSalad_: so maybe its using a different query function
07:23:21 <FunctorSalad_> Peaker: maybe it's just the enabled exts? (the var is settable)
07:24:10 <tomh> what would be the best way to start building a random number gen for haskell using a reader monad?
07:24:25 <Peaker> FunctorSalad_: it keeps seg faulting
07:24:35 <Botje> tomh: that's really what state is for
07:24:46 <tomh> Botje: what do you mean
07:24:57 <Botje> reader only allows you to read from the environment
07:25:01 <Peaker> FunctorSalad_: segfault on every "get" call except the first one after "getArgsAndInitialize >> createWindow "blah" "
07:25:09 <Botje> with a RNG you have to store your updated generator somewhere
07:25:15 <tomh> ye but i have to use a reader
07:25:33 <Botje> do you have to generate multiple random numbers?
07:25:44 <tomh> just one i guess
07:25:52 <Botje> oh
07:25:52 <tomh> i read a number n
07:25:56 <FunctorSalad_> ReaderT (IORef Int) IO a? ;)
07:26:00 <SamB> what is just one random number ?
07:26:07 <FunctorSalad_> (*corrupted by HOpenGL*)
07:26:11 <Botje> then you might as well generate it before entering the computation
07:26:12 <tomh> and then using the reader monad i have to build a random num between -n and n
07:26:53 <tomh> and i have to use all these weird ask and liftM functions
07:27:10 <Botje> runReader (...) (mkStdGen 42)
07:27:24 <tomh> is there any good documentation about what exactly you can use a reader monad for
07:27:25 <Botje> inside the ... part you have to use ask to get the stdgen
07:27:38 <tomh> ye thats what i kinda got
07:27:40 <Botje> in short: it's for passing around values implicitly
07:27:50 <tomh> mm ok
07:27:55 <Botje> it's best if you think in terms of types
07:28:19 <FunctorSalad_> Peaker: hmm cancel that, it's not settable
07:28:21 <Botje> the ... part has to have type Reader StdGen a
07:28:23 <SamB> the simplest MonadReader is just (->) e
07:28:37 <tomh> ye i got the Reader StdGen type
07:28:44 <Botje> you can look up the type of randomR
07:28:48 <Botje> see what it needs
07:28:55 <wli> Argh Data.Bits doesn't have the cross-module inlining stuff like Data.List does.
07:28:57 <tomh> ye i got that too
07:29:01 <SamB> :t randomR
07:29:04 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
07:29:05 <Botje> and you know ask will have type Reader StdGen StdGen here
07:29:06 <tomh> ok thanks i think i can try again some stuff :)
07:29:27 <Botje> try to fit them together, use the types as a guide
07:29:41 <tomh> ye if it types check im 90% there i guess
07:29:46 <SamB> @pl (\r -> asks (randomR r))
07:29:46 <lambdabot> asks . randomR
07:30:00 <SamB> huh.
07:30:10 <SamB> I guess that was kind of obvious, in retrospect
07:30:34 <FunctorSalad_> using Reader StdGen will give you the same number every time
07:30:41 <SamB> true!
07:30:46 <FunctorSalad_> unless you manually increment the state with each call
07:30:57 <SamB> @src MonadState
07:30:57 <lambdabot> Source not found. Just try something else.
07:31:08 <SamB> @doc Control.Monad.State
07:31:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
07:31:48 <FunctorSalad_> @type local
07:31:49 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
07:31:56 <FunctorSalad_> (using that one I mean :))
07:31:58 <SamB> why isn't there a combination modify/gets method ?
07:32:03 <SamB> or utility function
07:33:54 <dolio> Whenever I write modify myself, I have it return the in-state.
07:34:09 <dolio> Because it seems like I want that more often than I just want () back.
07:44:09 <augustss> @seen ndm
07:44:10 <lambdabot> I haven't seen ndm.
07:46:35 <tomh> hmm it is not possible to write lambda functions without arguments?
07:47:52 <osfameron> aren't they just variables?
07:48:09 <tomh> ye, i guess
07:49:13 <augustss> tomh: no.  All functions have exactly one argument.  Or they wouldn't be functions.
07:49:32 <osfameron> hmmm, this means that 'main' isn't a function
07:49:40 <augustss> No, it's not.
07:49:51 <osfameron> gosh
07:50:02 <osfameron> that had never occurred to me before.  tickles me.
07:50:20 <jkff> osfameron: Is int main() a function? If so, what is its argument?
07:50:20 <lambdabot> jkff: You have 1 new message. '/msg lambdabot @messages' to read it.
07:50:54 <augustss> jkff: well, C has a different concept of function.
07:50:57 <wli> It seems a little hairy, but I think it's possible to change these stack machines to register machines with infinite numbers of temporaries.
07:51:13 <jkff> That's what I'm talking about :)
07:51:43 <augustss> You can mimic the C functions in Haskell by using tuples.  A function taking an empty tuple as argument is still a function.
07:52:00 <osfameron> heh, that's cute
07:52:02 <jkff> I mean, in C, main also was not a mathematical function, so it's a bit incorrect of osfameron to say that he never saw 'main' not be a function
07:52:15 <osfameron> not at all
07:52:32 <osfameron> it's *entirely* correct to say that I never noticed that main wasn't a function
07:52:55 <jkff> Well, if you put it that way, it is :)
07:53:06 <augustss> It has type IO (), I see no -> there. :)
07:53:38 <jkff> (At least unless it is hidden in the definition of IO type, which you should not care about)
07:53:41 <osfameron> I'm surprised it doesn't take ARGV or similar as parameters
07:54:03 <augustss> osfameron: It could, but instead you access those via the IO monad.
07:54:09 <osfameron> as it would sort of make sense to see a program as a function from paramters -> exit status
07:54:17 <osfameron> fair enough
07:54:34 <augustss> osfameron: but it's also a function of the state of the file systems, etc, etc
07:54:46 <osfameron> hah, touche'
07:55:04 <gaal> hey there! Is lambdabot installable by cabal on ghc 6.8? I'm getting dependency problems, looking for base-4, and can't find an older enough version on hackage
07:55:14 <osfameron> it also simplifies program definitions if simple ones don't have to have boilerplate to take in arguments and return an int
07:55:24 <jkff> ...And those also *do* get passed and returned, however as a 'compiler optimization', this gets implemented as an in-place modification of the world.
07:55:51 <jkff> (translating the words of a developer of Clean)
07:57:51 <ImInYourMonad> how do I gen a random float?
07:57:52 <pejo> gaal, base-4 is ghc 6.10
07:58:09 <pejo> gaal, but you already knew that apparently. Sorry.
07:58:33 <jkff> :t random
07:58:34 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
07:58:45 <jkff> :t newStdGen
07:58:46 <lambdabot> IO StdGen
07:58:58 <augustss> :t makeStdGen
07:58:59 <lambdabot> Not in scope: `makeStdGen'
07:59:10 <jkff> :t random `liftM` newStdGen :: IO (Float,StdGen)
07:59:11 <lambdabot> IO (Float, StdGen)
07:59:25 <augustss> :t mkStdGen
07:59:26 <lambdabot> Int -> StdGen
07:59:49 <jkff> > random (mkStdGen 123567) :: (Float,StdGen)
07:59:52 <lambdabot>   (0.85668844,1707203701 1655838864)
08:00:16 <jkff> > randoms (mkStdGen 123567) :: [Float]
08:00:17 <lambdabot>   [0.85668844,0.72218734,0.6237462,0.41721126,0.8128467,0.76942086,0.34763417...
08:00:48 <augustss> > randoms (mkStdGen 42) :: [Float]
08:00:49 <lambdabot>   [0.110407025,0.8453985,0.3077821,0.78138804,0.5242582,0.5196911,0.20084688,...
08:01:12 <ImInYourMonad> *Rotating3DCube> R.random R.newStdGen
08:01:12 <ImInYourMonad> <interactive>:1:0:
08:01:12 <ImInYourMonad>     No instance for (R.RandomGen (IO R.StdGen))
08:01:17 <wli> I wish I had some idea of where people are getting the ideas for these virtual machines from.
08:01:37 <augustss> Thin air?
08:01:49 <gaal> R.newVirtualMachineStdGen?
08:01:51 <jkff> ImInYourMonad: newStdGen has type 'IO StdGen', and R.random accepts a value of type StdGen
08:02:44 <Taejo> anybody now when logo voting is going to open?
08:02:52 <wli> Well, one can say that. I've seen the defunctionalization etc. affairs and they seem to hint that the machines can be almost (or perhaps actually) automatically derived. Unfortunately, I don't understand a word of it.
08:04:01 <wli> I'm reading what the machines do, but not understanding it well enough to alter them.
08:04:06 <Azstal> Taejo: 16th March, http://article.gmane.org/gmane.comp.lang.haskell.cafe/54201
08:04:23 <Taejo> Azstal: thanks
08:05:32 <ImInYourMonad> hmm does $ have weird precedence?
08:05:47 <ImInYourMonad>  fst $ (R.random (R.mkStdGen 120) :: (Float,R.StdGen)) i had to paren  fst $ (R.random (R.mkStdGen 120) :: (Float,R.StdGen))
08:05:51 <bremner> that is the point of $
08:06:08 <wli> That's not $
08:06:10 <wli> It's ::
08:06:29 <wli> The :: has lower precedence than any expression operator no matter what.
08:06:53 <wli> The only way to make :: operate on a subexpression at all is to confine it within parentheses.
08:08:05 <wli> augustss: Mostly it's because I hate stack machines. I desperately want some sort of register machine with an infinite supply of registers in the machine model vs. the stack weirdness.
08:12:03 <gwern> Gracenotes: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/ <-- told you mit had the SICP videos
08:12:39 <Botje> it is a good day to generate some C code.
08:13:36 <beelsebob> got something to add to lambdabot's protontorpedo list... "Comrade: inst haskell basically c--"
08:13:52 <Botje> well, it is
08:14:07 <Botje> but there's some weird functional language implemented on top of it :)
08:14:12 <beelsebob> hehe
08:14:53 <ImInYourMonad> can I mae ghc not produce .hi,.o etc? just keep the original .hs file and produce an exe
08:14:55 <ImInYourMonad> ?
08:17:31 <beelsebob> ImInYourMonad: no
08:17:39 <beelsebob> both those files are necessary to create the exe
08:17:48 <beelsebob> you can write a script that deletes them after though
08:22:18 <ImInYourMonad> is exe.manifest needed?
08:22:23 <Alpounet> you can write a Makefile, or similar, with cleaning at the end
08:24:44 <ImInYourMonad> i never leanred make. all buoldsystems seems so incredibly complicated to do so little. ant makes me want to kill myself for example (xml, hello!?).
08:25:46 <Botje> makefiles are dead easy
08:25:58 <Botje> if it helps any, they're just practical applications of topological sorts :)
08:27:11 <Saizan> ImInYourMonad: you can pass it -hidir and -odir flags to put them out of your way
08:27:52 <Saizan> like in /tmp
08:28:04 <wli> I think I'm seeing some problems with register machine models vs. the tailcalls etc.
08:33:25 <ImInYourMonad> meh doesnt work
08:33:32 <ImInYourMonad> then i get an -odir anyway
08:33:38 <ImInYourMonad> emacs doesnt want to delete files for me
08:34:47 <mstr> ImInYourMonad: tried scons?
08:41:05 <Botje> would you recommend using language-c to generate C?
08:46:06 <TomMD> Botje: That or use System.Human to generate the C - its up to you.
08:46:52 <Botje> i won't be using many exotic features
08:47:03 <Botje> but i'm not in the mood for prettyrpinting
08:48:50 <tomh> mm what exactly can you do with liftM
08:49:03 <tomh> it is just applying a constructor on a monad or something?
08:49:15 <Raevel> that depends on what monad instance you're using it with
08:49:18 <mauke> it's fmap
08:50:02 <Botje> tomh: the type should be instructive enough
08:50:09 <RayNbow> :t liftM
08:50:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:50:18 <Botje> it takes a function (a -> b)
08:50:24 <Botje> takes an m a, and produces an m b
08:50:50 <tomh> mmm
08:50:56 <RayNbow> hmm, why does lambdabot tack an "1" to the type variable a?
08:52:23 <RayNbow> ah... probably because the source code uses a1... :p
08:53:30 <tomh> so how can a liftM be usefull in combination with ask? Atm my ask requires an StdGen but I want it to require an Int is this possible by using liftM somehow?
09:03:41 <ImInYourMonad> why does opengl switch into some other "mode" in windows, like the screen flickers black and then all the windows have this really ugly look
09:10:16 <Alpounet> ImInYourMonad, I guess it's because of GLUT rather than OpenGL. Many libraries should provide you a GLWidget or something of that kind in order to put your 3D Scene in it and to have a fancy window around :-)
09:10:33 <Alpounet> BTW, you should close Windows, forever.
09:10:36 <Alpounet> :-)
09:17:51 <ImInYourMonad> how do i disable Areo in opengl?
09:17:51 <ImInYourMonad> glfw
09:19:09 <p_l> ImInYourMonad: You mean Aero?
09:19:27 <p_l> it will either disable compositing by itself, or you can switch to full screen
09:19:44 <aeolist> Oreo!
09:20:23 <rabideejit> I think I've found a bug in the curl package.
09:21:11 <idnar> ImInYourMonad: if your windows are all going "ugly", then it sounds like Aero is already being disabled :P
09:21:28 <idnar> I guess that happens when an application requests exclusive mode
09:22:32 <ImInYourMonad> if i want to install glut and tell cabal where glut.h is at the same time, how do i do that?
09:23:09 <Saizan> --extra-include-dirs=
09:25:34 <ImInYourMonad> and that should then be the whole path or just the dir?
09:27:17 <ImInYourMonad> checking GL/glut.h presence... no
09:27:26 <ImInYourMonad> wtf where does it expect it to be so i can put it there?
09:27:38 <RayNbow> ImInYourMonad: you're trying to build HOpenGL under Windows?
09:27:40 <ImInYourMonad> because giving the link apparently doesnt work
09:27:43 <ImInYourMonad> yes
09:28:04 <ImInYourMonad> well glut
09:28:08 <ImInYourMonad> i have opengl working
09:28:13 <ImInYourMonad> and flgw
09:28:15 <RayNbow> http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
09:28:58 <ImInYourMonad> ty
09:31:58 <Zao> idnar: The trigger for going into basic mode is requesting a certain kind of pixel format.
09:33:18 <Zao> idnar: Pass in PFD_SUPPORT_COMPOSITION when creating the context to fix it.
09:33:28 <idnar> Zao: ah
09:33:38 <Zao> And as thus, is dependant on glut/glfw/whatnot doing the Right Thing.
09:33:39 <idnar> Zao: I don't use Windows much these days, but good to know
09:39:23 <ImInYourMonad> what is -lwinmm
09:40:01 <Zao> winmm is the Windows library that has among other things timers, midi input, sound, suchlike.
09:46:59 <edmoore> so: 1. I know little to nothing about programming. I can do basic stuff in C++, and use matlab/octave a lot. That's about it. I have read about haskell, but not really in possession of the skills to accurately assess why it specifically is good, nor the whole function paradigm in general.
09:47:23 <edmoore> 2. I have to write a clustering algorithm to give me some gaussians for a bunch of monte carlo sims I've been doing
09:47:43 <edmoore> 3. Last night I had a really vivid and intense dream that haskell would be the best language to write this clustering algorithm
09:47:57 <edmoore> is this at all true or is my brain just being silly?
09:48:09 <newsham> i cant vouch for #2
09:48:11 <appletizer> definitely true
09:48:47 <newsham> and i have no proof to substantiate #1 either
09:49:40 <edmoore> appletizer: for the benefit of my education - would you be able to enumerate a couple of reasons why it's true?
09:50:23 <ImInYourMonad> edmoore: haskell is great for programming anything and especially mathematics
09:50:43 <ImInYourMonad> i have done some basic machine learning stuff (KNN, curvefitting) in it
09:50:49 <ImInYourMonad> very expressive like matlab
09:51:09 * ddarius is pretty sure programming anything in a language you don't know at all is never the "best solution" unless you simply don't know any language at all.
09:51:15 <ImInYourMonad> but fast (but not quiet as fast) like c++
09:51:33 <edmoore> ImInYourMonad: this is all sounding promising. I'm going to do soft k-means with a fully defined 2-d covarience matrix
09:51:47 <edmoore> ddarius: sure, though I'm after an excuse to give it a go
09:51:55 <edmoore> it's not like it has to be done for tomorrow
09:52:26 <edmoore> is it easy enough to do basic things like read in a csv file full of data points?
09:52:39 <edmoore> i know there are very nice data structures in which to store them once i've done that
09:52:45 <dolio> The language you use with matlab is terrible.
09:52:46 <appletizer> edmoore, specifically for clustering, if you're used to the imperative paradigm and are hardpressed for time, it might not be worth it
09:52:47 <newsham> there's a csv library.
09:52:52 <newsham> on hackage
09:53:00 <appletizer> edmoore, having said that, one of the advantages of haskell is the ability to write mathy functions as is
09:53:42 <appletizer> edmoore, but to be fair, languages really don't differ that much such that when i had to code clustering or AI-type algos, pretty much any language works
09:54:15 <appletizer> (did it in prolog, java, c/c++, haskell, python as an example, oh and matlab too :)
09:54:18 <edmoore> ok, that's good to know
09:54:20 <edmoore> thanks
09:54:38 <appletizer> to also be a bit more objective, one of the downsides of haskell is its smaller library
09:55:00 * appletizer but likes lazy evaluation :)
09:55:56 <edmoore> i don't mind writing libraries for things. I often prefer it - whilst I'm still a student, it's useful, and I'm costing a company any money to reinvent the wheels
10:16:14 <ImInYourMonad> $ patch -p1 < ../glutWin2112.patch
10:16:15 <ImInYourMonad> sh: /bin/patch: Permission denied
10:19:20 <blaat_> @help
10:19:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:19:44 <blaat_> @list
10:19:44 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:20:15 <orzo> hi
10:20:19 <orzo> i want to do some image processing experiments
10:20:45 <orzo> i have input images in the form of jpegs
10:21:03 <ImInYourMonad> edmoore: check out http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=csv for haskell csv libs
10:21:04 <orzo> does haskell have nice libraries for this stuff?
10:21:07 <dons> pumpkin: i'm resyncing uvector against your branch
10:21:11 <dons> orzo: check on hackage
10:21:16 <ImInYourMonad> http://hackage.haskell.org/packages/archive/pkg-list.html <- is the place to go for haskelllibs
10:21:17 <edmoore> ImInYourMonad: great - thank you
10:21:22 <edmoore> I think I'll have a play
10:22:48 <athos> @simplify x + x + x
10:22:48 <lambdabot> Unknown command, try @list
10:23:01 <athos> :-)
10:23:38 <maltem> @pl \x -> x + x + x
10:23:38 <lambdabot> (+) =<< join (+)
10:24:39 <orzo> looks liek sdl-image or stb-image
10:24:46 <athos> :D
10:24:49 <orzo> choices suck
10:25:01 <orzo> oh wll thanks
10:29:01 <dino-> You know, it's kind of spooky to me that I can't find the matchRegex function in the API docs with the Index searcher.
10:29:13 <dino-> I mean in a bad way.
10:30:08 <dino-> I wonder if that API would be altogether easier to grok without the (=~) fancy stuff.
10:31:03 <bremner> is ghc6.10 garbage collection multithreaded? The docs confused me.
10:32:46 <dons> bremner: yes.
10:33:18 <bremner> cool. I think this page probably needs an update: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
10:36:22 <dino-> huh, I couldn't get to the haddock page for Text.Regex from the standard libraries Contents, but I was able to get that page loaded by navigating directly to file:///usr/local/share/doc/ghc/libraries/regex-compat/Text-Regex.html
10:36:34 <chessguy_> anybody have a link for whyfp handy?
10:36:50 <dino-> Funny that haddock failed to link that at all when it was generated.
10:37:05 <dino-> Both in my own local copy and the lib docs linked to on haskell.org
10:37:23 <chessguy_> @go why functional programming matters
10:37:26 <lambdabot> http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
10:37:26 <lambdabot> Title: Why Functional Programming Matters
10:51:53 <dons> pumpkin: uvector is resynced up to the point prior to the binary patches
10:51:53 <dons> so we should be good now
10:56:58 <ImInYourMonad> Graphics\UI\GLUT\QueryUtils.hs:41:15:
10:57:00 <ImInYourMonad>     parse error on input `CALLCONV'
10:57:12 <ImInYourMonad> if configure succeeds doesnt always build succeed then?
10:57:24 <dino-> Yay, happstack guys! Was able to cabal install the whole 0.8 tutorial + happstack 0.2.1
10:57:34 <dcoutts> :-)
10:58:57 <dons> i find it difficult to deal with Manlio. He's finding things out with uvector, but then just saying 'something is wrong' on the -cafe@. i need patches and tests :/
11:00:07 <mae> dino-: yay
11:00:25 <ImInYourMonad> i still get GLUT.h not foudn even when using msys and : http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
11:01:51 <pumpkin_> dons: thanks a lot!
11:02:55 <dons> pumpkin_: so now we just need to sort out the IO story
11:03:07 <dino-> It was nutty because, against everyone's better judgement, we couldn't wait a week ago and had hackerized 0.7 in with old happstack.
11:03:10 <dons> well that, and all the manual instances that don't invoke fusion.
11:03:18 <dino-> So had to rip all that business out today
11:03:35 <pumpkin_> yeah
11:05:15 <bremner> has anyone got any speedup on 2 cores with the sorting example (parSort2) in RWH chapter 24 and ghc 6.10.1?
11:06:35 <mae> dino-: you mean happstack-0.1? yeah that was a bit more hairy, we added tighter dependency constraints to the 0.2.1 cabal
11:08:25 <dino-> mae: Yes happs-tutorial 0.7.1 and happstack 0.1, exactly
11:08:40 <dons> bremner: i wonder - is that the one with only one `par` ?
11:08:56 <dons> it might fall into the ghc 6.10.1 limit of only firing up the second core with 2+ `par` sparks
11:09:04 <dons> (a little bug fixed in 6.10.2)
11:09:06 * bremner looks
11:09:07 <dons> try adding another spark
11:09:23 <dons> e.g. like this one . http://haskell.org/haskellwiki/Haskell_in_5_steps#Write_your_first_parallel_Haskell_program
11:10:25 <bremner> hmm, looks like the book example does indeed get hit by that ghc bug.
11:11:39 <dons> yeah, 'sok. ghc 6.10.2 is out soon
11:12:06 * bremner mutters about ghc and debian having different timescales
11:12:36 * p_l recalls seeing 6.10 in debians repo...
11:12:48 <pejo> Heh, what programs have the same timescale as debian, TeX?
11:13:13 <bremner> p_l: that is my point. The transition to 6.10.1 is just winding down
11:13:41 <bremner> pejo: emacs?
11:27:17 <ImInYourMonad> if i install hmatrix and it complains they dont exist, should i just untar them or do they need to be compiled?
11:27:55 <p_l> ... that sentence parsed weirdly
11:29:06 <ImInYourMonad> lol
11:29:30 <ImInYourMonad> When I install hmatrix I get a complaing that gsl and lapack doesnt exist. So I download and put them in home but should I also compile them?
11:29:33 <ImInYourMonad> runhaskell Setup configure --extra-include-dirs=C:/msys/1.0/home/saftarn/
11:30:21 <pumpkin_> yes, you need to compmile them too
11:30:27 <pumpkin_> and install them
11:30:42 <ImInYourMonad> runhaskell Setup configure --extra-include-dirs=C:/msys/1.0/home/saftarn/lapack-3.2/
11:31:03 <ImInYourMonad> isnt there a pure haskell matrix lib?
11:31:45 <edwardk> several, iirc frederik eaton had one which used type-level integers to make sure the sizes all matched up, etc.
11:32:06 <philipp_> ImInYourMonad: there are no good native math libs, unfortunately...
11:32:43 <p_l> it would be hard to get around lapack fast...
11:38:21 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2389#a2389
11:38:33 <ImInYourMonad> ^^ anyone know how to use extra-lib-dirs? i cant get it to work
11:40:23 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2389#a2390
11:40:26 <ImInYourMonad> didnt work either ^^
11:47:01 <ImInYourMonad> noone knows how to use it?
11:47:21 <pumpkin_> you'll need extra-include-dirs too
11:47:39 <pumpkin_> also, you installed and compiled lapack and gsl?
11:57:50 <ImInYourMonad> no
11:57:59 <ImInYourMonad> im tyring another ow
11:58:15 <ImInYourMonad> $ runhaskell setup configure --extra-lib-dirs=C:/msys/1.0/home/saftarn/libsvm-2
11:58:15 <ImInYourMonad> .88/ --extra-include-dirs=C:/msys/1.0/home/saftarn/tools/
11:58:24 <ImInYourMonad> isnt that correct?
11:58:48 <pumpkin_> libsvm now :o
11:59:58 <pumpkin_> the basic idea is: if it complains about not finding a header file, you find out what folder that header file is in (using some sort of searching mechanism) and add that as an --extra-include-dirs parameter
12:00:57 <pumpkin_> so if that saftarn/tools/ folder contains .h files, then that makes sense, if not, it doesn't
12:02:48 <ski> (mm .. hallon-saft)
12:06:31 <opqdonut> (mm .. l)
12:12:28 <ImNotInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2392#a2392
12:12:30 <ImNotInYourMonad> isnt that how i shold do it?
12:12:39 <ImNotInYourMonad> has anyone successfully used --extra-lib-dirs ?
12:12:45 <pumpkin_> yes
12:13:04 <pumpkin_> but unless your folders are named misleadingly
12:13:06 <pumpkin_> it's still wrong
12:13:19 <pumpkin_> --extra-include-dirs=C:/msys/1.0/home/saftarn/libs
12:13:19 <pumpkin_> vm-2.88/windows/ --extra-lib-dirs=C:/msys/1.0/home/saftarn/libsvm-2.88/
12:13:46 <pumpkin_> there's probably an include dir in there, which is what you wnat to point --extra-include-dirs at
12:13:57 <pumpkin_> for the lib dirs, you're going to have to build libsvm
12:15:48 <ddarius> Ferrero is a good confectioner
12:16:04 <pumpkin_> yup
12:20:46 <ImNotInYourMonad> pumpkin: i have a working installation of libsvm, ie it is compiled etc, i use the java version and i sued it from python and i used the C version
12:20:55 <ImNotInYourMonad> there is no dir called include
12:26:04 <pumpkin_> then you need something like libsvm-dev
12:26:27 <pumpkin_> or to find what folder has the include files :)
12:30:29 <ImNotInYourMonad> but what does the include dir have?
12:30:36 <pumpkin_> svm.h, apparently :)
12:30:44 <pumpkin_> that's what the error says it's looking for
12:30:59 <pumpkin_> I'd expect that file includes a few other svm-specific files
12:31:17 <ImNotInYourMonad> yes which are also there
12:31:20 <ImNotInYourMonad> yes which are also there
12:31:26 <ImNotInYourMonad> should i put them in include/
12:31:26 <pumpkin_> where?
12:31:29 <ImNotInYourMonad> same
12:31:31 <pumpkin_> no, you don't need to
12:32:02 <pumpkin_> you just need to point --extra-include-dirs at the folder that contains svm.h, and if the package is set up right, it should work
12:32:25 <ImNotInYourMonad> ok what should lib pointo to then?
12:32:32 <eu-prleu-peupeu> hello
12:32:49 <pumpkin_> somewhere where your .dll files live, I'd guess
12:33:00 <ImNotInYourMonad> libsvm should have dlls ?
12:33:03 <ImNotInYourMonad> ti doesnt
12:33:10 <pumpkin_> it should have some sort of library
12:33:22 <pumpkin_> maybe not a dynamic one
12:33:25 <ImNotInYourMonad> why? it has svmh. and some .c files
12:33:30 <ImNotInYourMonad> and then there are some exes
12:33:54 <ImNotInYourMonad> at leats now it didnt complaing about svm.h just: Missing C library svm
12:33:54 <Gracenotes> hm... lazy lists are indeed useful, it means that NFA-to-DFA doesn't have to blow up in size if a segment is never used :)
12:34:11 * Gracenotes should probably minimize the DFA anyway
12:34:34 <pumpkin_> ImNotInYourMonad: it needs to be able to link against something... if there isn't a library, there needs to be
12:34:35 <Gracenotes> well, it does mean that the previous NFA will be kept in memory. hm.
12:35:23 <ImNotInYourMonad> pumpkin and exe files works?
12:35:27 <pumpkin_> no
12:35:35 <pumpkin_> you can't link against an exe
12:35:38 <ImNotInYourMonad> becuase now configure and build worked but not install
12:36:24 <ImNotInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2393#a2393
12:36:59 <ImNotInYourMonad> so if i have only .h and .c files can i compile them myself to some sort of dll?
12:37:22 <ImNotInYourMonad> dlls are for linking object code to other programs?
12:37:33 <Zao> A dll is a dynamic library.
12:37:38 <Zao> cf. .so on linux.
12:37:48 <pumpkin_> you need either a .lib file or a .dll file, I'd expect
12:37:59 <Zao> You do not link directly against it, you either link against a stub library or resolve entrypoints at runtime.
12:38:15 <Zao> (LoadLibrary + GetProcAddress)
12:38:53 <ski> m . m >-> m . n >-> n  =  m . m >-> m >-> n
12:38:55 <ImNotInYourMonad> but are .lib and .dll files made when compiled?
12:39:31 <Zao> When you build a dynamic library, you generally get both a dll and a stub library to link against.
12:39:53 <ImNotInYourMonad> > let (s,k,i) = "skit" in (s,k,i)
12:39:54 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
12:39:59 <ddarius> Gracenotes: NFAs tend to be smaller than DFAs so keeping it in memory probably isn't too bad.
12:40:39 <Olathe> > let (s:k:i:_) = "skit" in (s, k, i)
12:40:40 <lambdabot>   ('s','k','i')
12:40:57 <Gracenotes> mm
12:41:42 <ImNotInYourMonad> so how did anyone else install libsvm?
12:44:01 * ski shakes fist at ImNotInYourMonad ..
12:44:49 <dolio> Clearly he's goading you into changing your name to a different set of combinators.
12:44:53 <ImNotInYourMonad> how does djinn work?
12:44:54 <ski> (.. young people today .. in my time people behaved properly)
12:45:56 <monochrom> In my time people behaved monomorphically.
12:46:02 <Gracenotes> > let (s, k, i) = ('s':k, 'k':i, 'i':s) in s
12:46:04 <lambdabot>   "skiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskiskisk...
12:46:25 * ski needs to practice more with thinking like an old grumpy git
12:47:04 <ImNotInYourMonad> awesome! they have this thing called READMEs where you can like read how to install, libsvm for example
12:47:10 <Gracenotes> :O
12:47:17 <ImNotInYourMonad> ImNotInYourMonad shoots self
12:47:35 <Gracenotes> ImNotInYourMonad: I think djinn could work by trying to find combinations of types that work and backtracking
12:48:26 <Gracenotes> not sure how it actually works. I think the problem is equivalent to that of path-finding in a graph
12:48:55 <Gracenotes> and Either/Maybe... hm, must introduce other complications :)
12:49:28 <dolio> ImNotInYourMonad: djinn treats a type as a proposition in a corresponding logic, uses an algorithm for finding proofs in that logic, and then uses the fact that proofs in the logic correspond to programs with the type.
12:49:36 <ImNotInYourMonad> $ make
12:49:37 <ImNotInYourMonad> make: *** No targets specified and no makefile found.  Stop.
12:49:46 <ImNotInYourMonad> but there is Makefile and Makefile.win ...
12:50:48 <Gracenotes> dolio: so it an NP problem?
12:50:52 <eu-prleu-peupeu> why this doesn't work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2394#a2394 ?
12:51:22 <dolio> I don't know. Is that NP?
12:51:24 <skorpan> eu-prleu-peupeu: what's the error?
12:51:50 <ImNotInYourMonad> dolio: ok but basically that leads to a function with the correct type but that is all? the function might do something completely different than what you want I assume?
12:52:05 <olsner> I guess we'll notice when someone solves a 3SAT problem using djinn
12:52:10 <dolio> If there is more than one function of that type.
12:52:14 <Gracenotes> heh
12:52:24 <dolio> @djinn a -> a -> a
12:52:24 <lambdabot> f _ a = a
12:52:30 <eu-prleu-peupeu> skorpan: no error :P it just doesn't write the .cmd files with the filename of the executable writen inside them
12:52:40 <Gracenotes> well, you can solve graph path problems with djinn
12:52:54 <pumpkin_> eu-prleu-peupeu: you haven't shown us the whole program
12:53:09 <pumpkin_> liftM?
12:53:12 <ddarius> olsner: We can embed classical propositional logic into intuitionistic propositional logic and djinn will prove any such proposition.
12:53:24 <eu-prleu-peupeu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2394#a2395
12:53:25 <eu-prleu-peupeu> here
12:53:26 <eu-prleu-peupeu> :P
12:53:34 <monochrom> djinn's job is NP-complete.
12:53:46 <pumpkin_> eu-prleu-peupeu: it doesn't do anything because you don't have a main function ;)
12:53:52 <dolio> Sometimes there's only one function of a particular type (as far as djinn is concerned), so it can't choose the wrong one.
12:54:00 <pumpkin_> and Control.Mona is in the Louvre
12:54:02 <ski> n . n >-> m . n >-> n  =  n . n >-> n
12:54:09 <eu-prleu-peupeu> pumpkin_: when i call it from the ghci, it doesn't do anything at all
12:54:10 <dolio> Unless the one you want involves undefined, or something.
12:54:17 <eu-prleu-peupeu> pumpkin_: copy paste error
12:54:20 <pumpkin_> eu-prleu-peupeu: what's its type?
12:54:28 <ski> (pumpkin_ : s/function/action/)
12:54:37 <monochrom> Mona is in the Louvre. Monad is in the Lawvere.
12:54:55 <dolio> @djinn Not (Not (((a -> b) -> a) -> a))
12:54:55 <lambdabot> f a =
12:54:55 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
12:55:04 <pumpkin_> @type liftM (mapM_ f) (getDirectoryContents ".")
12:55:04 <lambdabot> Not in scope: `getDirectoryContents'
12:55:13 <olsner> @ty void
12:55:14 <lambdabot> Not in scope: `void'
12:55:14 <pumpkin_> @hoogle getDirectoryContents
12:55:15 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
12:55:21 <ski> void :: Void -> a
12:55:29 <ski> void u = case u of {}
12:55:30 <pumpkin_> @type liftM (mapM_ f) (return ["oi"])
12:55:30 <dolio> @djinn Not (Not (Either a (Not a)))
12:55:30 <lambdabot> forall (m :: * -> *) b (m1 :: * -> *). (Monad m1, Monad m, SimpleReflect.FromExpr (m b)) => m1 (m ())
12:55:30 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
12:55:31 <eu-prleu-peupeu> what about now pumpkin_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2394#a2396 ?
12:55:35 <eu-prleu-peupeu> is it better ?
12:55:36 <Olathe> > void :: Int
12:55:37 <lambdabot>   Not in scope: `void'
12:55:41 <Gracenotes> @djinn-env
12:55:41 <lambdabot> data () = ()
12:55:41 <lambdabot> data Either a b = Left a | Right b
12:55:41 <lambdabot> data Maybe a = Nothing | Just a
12:55:41 <lambdabot> data Bool = False | True
12:55:41 <lambdabot> data Void
12:55:43 <lambdabot> type Not x = x -> Void
12:55:45 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:55:51 <pumpkin_> eu-prleu-peupeu: my guess is that you have an IO (IO
12:55:57 <ski> @djinn Void -> a
12:55:58 <lambdabot> f = void
12:56:08 <pumpkin_> eu-prleu-peupeu: so either use =<< or join the result
12:56:22 <Olathe> @djinn Void -> Maybe a
12:56:22 <lambdabot> f = void
12:56:31 <Olathe> @djinn Void -> Either a b
12:56:31 <pumpkin_> bbl;
12:56:31 <lambdabot> f = void
12:56:37 <Olathe> @djinn Void -> Either a b -> Void
12:56:37 <lambdabot> f = void
12:56:41 <Olathe> Heh
12:56:42 <olsner> this is cool, I find djinn so much more awesome now :)
12:56:50 <Gracenotes> @djinn Void -> a -> Maybe a
12:56:50 <lambdabot> f = void
12:56:51 <eu-prleu-peupeu> why doesn't IO(IO()) work ?!
12:56:53 <Gracenotes> :/
12:56:55 <ski> @djinn (a -> Void) -> (a -> Void)
12:56:55 <lambdabot> f a = a
12:56:56 <Junior> hi
12:57:04 <Junior> Hi
12:57:06 <Gracenotes> eu-prleu-peupeu: usually if you have IO (IO ()), you're doing somethin wrong
12:57:09 <Olathe> Hello.
12:57:18 <monochrom> IO(IO()) works. I sometimes use it.
12:57:23 <Gracenotes> you can use 'join' to make it work
12:57:26 <Junior> I'm brazilian
12:57:34 <ski> we're haskellians
12:57:51 <Olathe> Some of us are evil haskellians, too.
12:58:03 <Junior> hello
12:58:12 <ski> (Olathe : is that a constructive or a clasical "Some" ?)
12:58:21 <Gracenotes> eu-prleu-peupeu: but, in many cases, it's a problem with types. If you need IO to make an IO action, good, but just making an IO action should be fine
12:58:26 <Olathe> Classical, I think.
12:58:33 <Olathe> What's constructive some ?
12:58:51 <ski> one where the proof actually finds examples of things haveing the property stated
12:59:21 <Olathe> Ahh.
12:59:29 <Junior> shit
12:59:32 <Junior> shit
12:59:33 <ski> e.g., in "every vector space has a basic", the "has" is not constructive
12:59:41 <ski> (s/basic/basis/)
12:59:44 <Junior> burros
12:59:44 <monochrom> Some of us always tell the truth and the rest always tell lies. You ask one of us "are you one of those who always tell the truth?" and he answers "if yes, I'll eat my hat". Does he eat his hat?
12:59:47 <Junior> haaha
12:59:50 <Junior> fala
12:59:52 <eu-prleu-peupeu> okey
12:59:56 <Junior> alguma coisa
13:00:01 <ski> Junior : do you have a haskell question ?
13:00:15 <Junior> ski is shit
13:00:20 <babilen> hi all. i just started to learn haskell. i am coming from python/java/c/prolog and opted for "Real world Haskell". Is that a good book or are there better ones you would suggest?
13:00:24 <Junior> !!!!!!!!!!!
13:00:25 <iago_> Junior, que cousa
13:00:35 <leadnose> babilen, it's good.
13:00:44 <Olathe> monochrom: If yes, he does.
13:00:52 <Junior> VOC FALA PORTUGUES
13:00:56 <ski> Junior : why do you think that ?
13:01:06 <eu-prleu-peupeu> is there any better way to work this problem out ? ... im trying to write cmd files for each executable in a given directory
13:01:11 <ski> Junior : do you prefer the `c' and `b' combinators ?
13:01:27 <babilen> leadnose: i had that impression as well, but wanted to check first. it could have been on the "do not touch this book" list
13:01:45 <eu-prleu-peupeu> Junior: vá, tens de ser mais preciso, não é português, é brazileiro
13:01:47 <Junior> I didn't hear myself
13:01:49 <Olathe> monochrom: If no, he doesn't exist.
13:02:06 <Olathe> monochrom: Or something.
13:02:09 <Junior> legal
13:02:12 <dons> babilen: i'm biased, but i think it's the most practical book written on haskell yet :)
13:02:18 <Junior> vocs so brasileiros
13:02:22 <eu-prleu-peupeu> Junior: que é o equivalente a um português deslavado, mais pobre, vá
13:02:44 <Junior> voc  de onde eu-prleu-peupeu
13:02:56 <eu-prleu-peupeu> Junior: english ?
13:03:03 <Junior> yes
13:03:14 <dolio> Only until Haskell for Scientists comes out. :)
13:03:20 <iago_> Junior, qu queres
13:03:22 <dons> heh
13:03:23 <Junior> yes I do
13:03:25 <eu-prleu-peupeu> dont you know how to set your characters to iso-8859-1 ?
13:03:36 <iago_> Junior, eu sonche da galiza
13:03:37 <iago_> ;P
13:03:39 <Junior> vocs sabem portugus
13:03:51 <ski> dolio : or "Haskell for the working category terrorist" !
13:04:09 <eu-prleu-peupeu> Junior: yes but this is an english speaking channel, please speak in english
13:04:12 <iago_> Junior, eu sei :? estou farto de repetilo
13:04:52 <Junior> por que este progama
13:05:03 <Junior> tem que falar ingles
13:05:10 <Junior>  chato
13:05:18 <Junior> mas voc  de onde?
13:05:25 <Junior> eu-prleu-peupeu
13:05:25 * ski has browsed in a book that implements limits, adjunctions, et.c. in SML .. maybe one should do something similar in Haskell
13:05:48 <ddarius> ski: I converted all the code to Haskell at one point, but I unfortunately lost that code.
13:05:58 <ddarius> ski: It's mechanical.
13:05:59 <ski> how sad
13:06:26 <Junior> hellooooooo
13:06:30 <Junior> aloooo
13:06:38 <Junior> responda
13:06:41 <ski> (yes, translating directly would be mechanical .. but translating some concepts into haskell types and classes might not be so much)
13:06:55 <mornfall> Is there a way to dump memory usage stats from inside application? At a given point...
13:06:56 <eu-prleu-peupeu> junior: in private plz
13:07:03 <polveroj> ski: isn't most of that stuff in Control.Category?
13:07:11 <ski> (of course, one will hit into no kind-polymorphism, et.c. pretty quickly)
13:07:11 <monochrom> I think Richard Bird's "Introduction to FP using Haskell" is the only Haskell book that answers why foldl causes stack overflow and how foldl' fixes it. Pretty amazingly practical for a "theoretical", "academic" book.
13:08:01 <polveroj> ski: err, I mean category-extras.
13:08:02 <Adamant> monochrom: I'm pretty sure YAHT tells you that as well
13:08:05 <Adamant> but I could be wrong
13:08:13 <ski> polveroj : that's mostly for categories whose objects are indexed by `*', no ?
13:08:47 <Junior> bye bye
13:09:00 <ski> (hm, that's probably slightly inaccurate .. yell if you want elaboration)
13:09:05 <ski> Junior : bye
13:09:55 <Junior> shit
13:10:16 <koeien> using Unicode in source code rules
13:10:16 <Taejo> @pl toHist n = replicate n 0 ++ [1]
13:10:16 <lambdabot> toHist = (++ [1]) . flip replicate 0
13:10:57 <ski>   toHist = (++ [1]) . (`replicate` 0)
13:11:49 <eu-prleu-peupeu> i am going to create a blog about haskell
13:12:24 <Olathe> eu-prleu-peupeu: In order to allow that, we must have your assurance that you will refrain from monad tutorials.
13:12:49 <eu-prleu-peupeu> :)
13:13:05 <eu-prleu-peupeu> i shouldn't have skimmed those chapters on rwh :)
13:13:18 <xs> is there a nice way for a parsec parser to handle function application? (at the moment i am resorting to try.)
13:13:43 <ski> "handle function application" ?
13:14:35 <xs> parse "foo(a,b,c)" as well as, for example, basic arithmetic expressions.
13:14:41 <xs> (with variables)
13:14:41 <eu-prleu-peupeu> but no monad tuts... just some experiments, and some tuts about other things haskell
13:14:59 <ski> xs : left-factor your grammar ?
13:15:59 <xs> ski: hm. how does that help?
13:16:04 <jkff> @seen vixey
13:16:04 <lambdabot> vixey is in ##logic. I last heard vixey speak 3h 17m 26s ago.
13:16:08 <dolio> chainl?
13:16:27 <ImNotInYourMonad> yay libsvm in haskell works!
13:16:41 <ski> you can parse `foo' first, and then check if there's a paren after, if so, you try an applicate, otherwise you have a variable
13:17:58 <ski> (of course, you need to iterate to parse stuff like `foo(a,b,c)(d,e)')
13:18:36 <xs> ski: ah. yes. that's what i'm doing. i suppose there's no nicer way.
13:19:01 <ski> unfortunately, Parsec doesn't automatically left-factor (it can't)
13:19:58 <ddarius> It captures certain common patterns of left-recursion in combinators, primarily chainl.
13:19:59 <ski> (also, imo, `try' is a wart)
13:20:13 <ddarius> imo try is key
13:20:27 <Olathe> iyo there is no try
13:20:34 <xs> heh :)
13:21:19 <Gracenotes> hm, constructors as functions is rather useful... particularly with liftMX for ((->) r)
13:21:47 <ski> (yes, it is key to be able to express what you can express by `try' .. i don't like it more for that, though)
13:22:25 <ddarius> ski: As long as Parsec is what it is, I think making try explicit is the right thing to do.
13:22:48 <ski> probably true :)
13:25:01 <ImNotInYourMonad> what does songsmith do? generate new acoustic music?
13:25:15 <ski> state : environment :: list : maybe :: ? : ?
13:26:01 <ski> @hoogle songsmith
13:26:01 <lambdabot> No results found
13:26:26 <ski> @hackage songsmith
13:26:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/songsmith
13:30:57 <pumpkin> does anyone have any hints on how to write a quickcheck test that says "expect error if x > y or x < k, or expect f(x, y) == z otherwise?" I think I can do it with catch, but quickcheck tests are pure, so do I need to do it in an unsafePerformIO? or does quickcheck have built-in functionality for making that prettier?
13:31:58 <gnuvince_> Is there a library to read binary data (bytes, words, dwords)?  Something like Python's struct module?
13:32:07 <pumpkin> Data.Binary.Get ?
13:32:25 <pumpkin> it doesn't have a built-in way to serialize IEEE float/doubles, but the rest is all there
13:32:41 <gnuvince_> pumpkin: for my case, that wouldn't matter.
13:32:43 <pumpkin> but it isn't based on a format string like python/ruby
13:32:47 <Heffalump> pumpkin: QuickCheck 2 has combinators to expect exceptions, I think
13:33:07 <gnuvince_> pumpkin: doesn't matter, I just need something to say "read 3 bytes, then 2 words, then 1 dword"
13:33:35 <pumpkin> Heffalump: cool, I was looking but couldn't see anything obvious for doing that
13:33:39 <pumpkin> I'll look harder :)
13:34:15 <iago_> I see a bit strange this use of quickcheck
13:34:24 <Heffalump> pumpkin: expectFailure?
13:34:26 <pumpkin> how so?
13:34:27 <pumpkin> ooh
13:34:48 <Heffalump> hmm, not sure that's right
13:35:17 <pumpkin> I think it might be
13:35:23 <pumpkin> actually
13:35:24 <pumpkin> hmm
13:35:46 <pumpkin> it just seems to say expect it to fail sometimes, doesn't seem to let me provide a predicate for when that should happen
13:36:16 <Heffalump> yeah, though I'm not quite sure of the point of a combinator that says "well this might pass or it might not"
13:36:17 <Gracenotes> hm. Why is Set.map defined in terms of converting to/from list, instead of just iterating through the tree branches?
13:36:33 <Heffalump> Gracenotes: because it has to reorder the tree afterwards
13:36:36 <Gracenotes> oh, wait, ordering
13:36:38 <Gracenotes> yeah
13:41:05 <pumpkin> does the author of quickcheck hang out on IRC?
13:41:22 <Ralith> @pl \x -> reverse x == reverse x
13:41:22 <lambdabot> liftM2 (==) reverse reverse
13:45:24 <wli> int-e: It gives a warning otherwise.
13:46:27 <pumpkin> wow, quickcheck 2 can show functions now
13:46:47 <pumpkin> the functions it generates, that is
13:47:00 <conal> pumpkin: what do they look like?
13:47:18 <pumpkin> a simple mapping of a finite set of inputs to outputs, I think
13:47:30 <Gracenotes> @type (join (==)) . reverse
13:47:30 <pumpkin> I haven't actually tried it, I just saw that it has a show instance for its Function type
13:47:31 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:47:49 <conal> pumpkin: qc2 has its own function type?
13:48:03 <pumpkin> yeah
13:48:22 <pumpkin> well, even earlier versions could generate functions if you had coarbitrary instances for them
13:48:32 <pumpkin> for the types, that is
13:48:52 <wli> int-e: You're right that it would be a speedup.
13:49:22 <conal> pumpkin: oh -- you mean an instance for functions, rather than a new function type?
13:49:33 <pumpkin> yeah, just an Arbitrary function instance
13:49:44 <pumpkin> but it does have a Function type
13:49:48 <pumpkin> that wraps a regular function
13:49:56 <pumpkin> along with a table of values
13:50:13 <conal> oh.  maybe finite functions?
13:50:17 <pumpkin> yup
13:50:54 <wli> The benchmark methodology is garbage anyway, though.
13:54:06 <Ralith> @pl \x -> x == reverse x
13:54:06 <lambdabot> ap (==) reverse
13:54:15 <Ralith> ap?
13:54:18 <pumpkin> liftM2 id
13:54:30 <pumpkin> :t ap
13:54:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:55:03 <ImNotInYourMonad> *** Exception: gnuplot: runGenProcess: does not exist (No such file or directory) ; that is when I have installed via msys
13:55:26 <pumpkin> I'd guess gnuplot is not in your path
13:56:11 <ImNotInYourMonad> woudlnt the install fail then?
13:56:22 <pumpkin> nope, it doesn't need to link against gnuplot
13:56:25 <pumpkin> it just calls the program
13:57:04 <pumpkin> what's with people who send emails in fixed-width fonts?
13:58:11 <conal> pumpkin: maybe they want alignment preserved.
13:58:38 <wli> How do you send emails with any font specified at all?
13:58:53 <pumpkin> still reduces legibility for human language text :P
13:58:57 <pumpkin> wli: html emails
13:59:08 * p_l sets his mail reader to be in fixed width
13:59:24 * cjb too
13:59:27 <pumpkin> reading anyting but code in a fixed-width font makes me cry :)
13:59:35 <conal> pumpkin: i use a variable width font and then sometimes set just the code fragments in fixed.
13:59:39 * dancor fixedwidth4life
13:59:40 <pumpkin> yeah
13:59:45 <p_l> though if you are sending HTML mail, it doesn't make sense
13:59:48 <pumpkin> I'm a bit of a typography nerd though, so that might explain
13:59:49 <pumpkin> it
13:59:50 <wli> I vaguely remember a <font face= .. directive in HTML, but then again, my HTML dates from ca. 1995.
14:00:08 <p_l> pumpkin: well, I'm far from being nerdy but I do know basics :D
14:00:38 * ski reads his emails in a fixed-width font terminal ..
14:00:39 <maltem> pumpkin: Oh, so you run your mail through latex to have a better view on it? :)
14:00:46 <pumpkin> lol, no
14:00:55 <pumpkin> but proportional fonts are nice
14:01:35 <pumpkin> don't see why not to use them unless you want to guarantee alignment
14:01:39 <wli> They can be nice even for code. My lhs2TeX boilerplate setup uses a proportional font.
14:02:05 <pumpkin> yeah, once you have a more sophisticated typesetting system than a plain text file, you can get alignment without relying on the font being ugly :P
14:02:08 <maltem> right, but I like guaranteed alignment in mails
14:02:15 <wli> I've taken to shoehorning extra spaces in all over the place to make various things alignment columns.
14:02:31 <p_l> as for fonts, the funniest is when people use certain fonts without hinting (I was guilty of that some time ago... I still have the screenshot somewhere, comparing before and later)
14:02:41 <pumpkin> ah yeah
14:02:41 <wli> maltem: I arrange for simultaneous alignment in the source text and output PDF.
14:02:53 <pumpkin> on mac os, certain PDFs aren't hinted
14:02:58 <pumpkin> and it's really ugly
14:03:15 <ImNotInYourMonad> pumpkin: is that the windows path or does msys have its own path?
14:03:20 <maltem> wli: yeah I've seen lhs2tex doing nice tricks
14:03:35 <pumpkin> ImNotInYourMonad: not sure, haven't used windows for coding work in years
14:03:40 <ski> ("hinted" meaning ?)
14:03:46 <wli> I somehow manage to do this using tabs and all.
14:04:01 <p_l> ImNotInYourMonad: BTW, what Windows version are you using?
14:04:03 <wli> I can't remember the last time I got a layout error from ghc/ghci.
14:04:13 <pumpkin> ski: taking advantage of the layout of color components in pixels on your screen
14:05:20 <pumpkin> at least in most cases
14:05:28 <pumpkin> it's a more general technique than that though
14:05:31 <ImNotInYourMonad> Vista
14:05:41 <p_l> ImNotInYourMonad: Ultimate?
14:06:07 <wli> I use color components sparingly. My life is a Frank Miller movie.
14:06:14 <ImInYourMonad> nomral vista i think
14:06:25 <pumpkin> :)
14:06:51 <ImInYourMonad> but where does it look normally? can i put gnuplot.exe somewhere where it can find it?
14:07:16 <wli> I just use Graphics.GD
14:09:10 <ImInYourMonad> for plotting?
14:09:17 <wli> Yeah.
14:09:23 <ski> evil plotting ?
14:09:35 <adamvo> would it be possible for @pl to factor out common applications with Data.Function.on ?
14:09:49 <p_l> btw, for comparison between hinted and unhinted... http://plasek.rootnode.net/hinted-vs-unhinted-consolas.jpg
14:10:37 <Zao> jpg makes kitty cry :(
14:11:22 <p_l> Zao: I use jpg since pngs made people cry
14:12:01 <ImInYourMonad> wli: does that package need the original lib or it contains it?
14:12:07 <ImInYourMonad> his is a binding to a (currently very small) subset of the GD graphics library.
14:12:27 <wli> I think it needs the original.
14:12:33 <ImInYourMonad> libgd.org?
14:13:03 <wli> I'd use your distro's package manager.
14:14:37 <pumpkin> p_l: pngs are awesome,
14:14:46 <pumpkin> jpg for non-photo data is evil
14:15:00 <pumpkin> and makes god club a bab(b)y seal every time you do it
14:15:08 <bmh> hey pumpkin
14:15:11 <pumpkin> how is babby seal formed?
14:15:12 <bmh> I was told to give you a hard time
14:15:15 <pumpkin> hi bmh
14:15:17 <pumpkin> oh no!
14:15:19 * pumpkin hides
14:15:31 <bmh> I also hear your girlfriend knows haskell.
14:15:34 <bmh> Mine knows java.
14:15:37 <pumpkin> hah
14:15:37 <bmh> (I think you win)
14:15:42 <pumpkin> I only learned haskell because she was taking a course
14:15:49 <bmh> yeah
14:15:55 <pumpkin> and kept looking over her shoulder, and it looked cool
14:16:02 <p_l> lol
14:16:02 <bmh> your redheaded friend was easy to spot.
14:16:04 <Ralith> is there some kind of 'infinity' integral?
14:16:08 <Heffalump> my wife isn't too keen on learning Haskell
14:16:11 <pumpkin> bmh: I bet :P
14:16:31 <pumpkin> bmh: he said you didn't even try to convince him to do computational biology!
14:16:55 <bmh> pumpkin: I was more interested in talking to the girls who studied graphic design.
14:17:14 <pumpkin> ah :)
14:29:20 <int-e> wli: what kind of warning? (I replaced (fromIntegral n :: Integer) by n and got no warning)
14:32:08 <wli> int-e: Defaulting to Integer.
14:32:28 <wli> int-e: I just moved the type annotation to where it was strictly necessary.
14:33:09 <wli> int-e: i.e. the result of twoFibs
14:34:03 <wli> int-e: The non-exhaustive pattern matches can't be shut up because of the observable performance impact. :(
14:34:52 <wli> int-e: I usually compile with -Wall and -Werror
14:35:00 <ImInYourMonad> NameCacheAccessor m , what is that? ic ant find it in the haddock docs. if i want to just takr a .hs file and generate a html ile, how do i do?
14:41:28 <gwern> can one use guards as part of a regular expression?
14:41:42 <gwern> eg. '\x -> | x > 4 = True' etc
14:42:19 <Deewiant> \x -> case undefined of _ | x > 4 -> True
14:42:37 <gwern> hm. seems kind of ugly
14:42:55 <Deewiant> Guards are only valid in function definitions and case expressions
14:44:59 <ImInYourMonad> import qualified Distribution.Haddock as H , why doesnt that work?
14:45:26 <povman> ImInYourMonad: what about it doesn't work?
14:45:27 * Heffalump reads the webpage again and notices the instructions on how to do it
14:46:49 <ImInYourMonad> importing
14:46:55 <ImInYourMonad> Could not find module `Distribution.Haddock':
14:47:49 <povman> do you mean Distribution.Simple.Haddock ?
14:51:41 <martin__> hi, im looking for a way to "paint" custom shapes in haskell...I dont think Glade lets me do this, please point me in a direction :)
14:52:28 <beelsebob> gwern: surely the relevant syntax would be \x | x > 4 -> True
14:52:36 <beelsebob> but i don't think so, no
14:53:00 <beelsebob> > (\x | x > 4 -> True) 3
14:53:01 <lambdabot>   <no location info>: parse error on input `|'
14:53:03 <beelsebob> :(
14:54:59 <notsmack> martin__, probably need more info about what you're trying to do
14:55:16 <beelsebob> I wonder...
14:55:40 <beelsebob> > let (->) x y = x + y in (\x -> x -> 5) 4
14:55:41 <lambdabot>   <no location info>: parse error on input `->'
14:55:43 <beelsebob> :(
14:56:00 <beelsebob> Haskell has too many corner cases
14:56:17 <beelsebob> I should just code in Lambda calculus
14:57:08 <martin__> notsmack, im creating a boardgame for a school project and need to create custom shapes....the widgets provided in glade wont suffice
14:57:09 <defun> A friend of mine asks: "when would one use case instead of if-then-else, if ever?" I'm not sure what to answer.
14:57:26 <endojelly> why is there no cabal package in debian/ubuntu?
14:57:30 <pumpkin> because if-then-else is ugly
14:57:39 <pumpkin> case is purtier
14:57:41 <endojelly> defun, you can't unpack patterns with if-then-else
14:57:56 <defun> please elaborate.
14:57:59 <pumpkin> I'm going to start the "ABOLISH IF-THEN-ELSE IN HASKELL" movement
14:58:04 <beelsebob> defun: because case can do pattern matching as well as if-then-else
14:58:10 <beelsebob> pumpkin: I'm right behind you!
14:58:19 <defun> then, why not just do regular old pattern matching?
14:58:24 <beelsebob> although I would love the "if" function to be in the Prelude
14:58:24 <pumpkin> it'll also help to make haskell even more foreign/inaccessible to newcomers
14:58:27 <pumpkin> which is a good thing
14:58:29 <pumpkin> :P
14:58:36 <beelsebob> defun: because regular old pattern matching should be case ;)
14:58:37 <endojelly> > (\x -> case x of Just y: y) (Just 1)
14:58:37 <lambdabot>   <no location info>: parse error on input `)'
14:58:51 <pumpkin> I think giving newcomers too many "familiar" things to hold on to will delay their learning
14:58:55 <endojelly> > (\x -> case x of Just y -> y) (Just 1)
14:58:56 <lambdabot>   1
14:59:05 <endojelly> try doing that with if-then-else, you can't!
14:59:05 <beelsebob> pumpkin: that's entirely believable
14:59:25 <defun> so, regular old pattern matching is just sugar for case?
14:59:30 <beelsebob> defun: yep
14:59:33 <endojelly> yes
14:59:33 <beelsebob> case is core language
14:59:38 <pumpkin> yeah, all the low level knows about is case and let
14:59:42 <pumpkin> and function application, I guess
14:59:47 <beelsebob> no other control flow is in the core
14:59:50 <endojelly> imagine a big case around each function definition
14:59:54 <endojelly> that's basically what it is
15:00:01 <defun> cool.
15:01:53 <ImInYourMonad> newtype InputVector = InputVector { unInputVector :: [Double]}
15:02:04 <ImInYourMonad> how do I construct one of those?
15:02:14 <beelsebob> InputVector [5,6,7]
15:02:27 <beelsebob> or InputVector {unInputVector = [5,6,7]}
15:02:45 <pejo> endojelly, around each function definition?
15:02:51 <ImInYourMonad> but i do that
15:02:54 <ImInYourMonad> not in scpe
15:02:58 <jmcarthur> > (\x -> if isJust x then fromJust x else undefined) (Just 1)
15:02:59 <lambdabot>   1
15:03:03 <jmcarthur> :P
15:03:06 <endojelly> pejo, around the body of each function definition :P
15:03:12 <endojelly> jmcarthur, but how is isJust implemented
15:03:15 <beelsebob> ImInYourMonad: then you haven't imported something
15:03:20 <jmcarthur> endojelly, it was just a joke
15:03:26 <endojelly> jmcarthur, oh, ok %)
15:03:46 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2398#a2398
15:03:48 <endojelly> actually, that was exactly what happened when I teached a class about SML
15:03:58 <endojelly> where exactly that topic came up: pattern matching vs. if
15:04:19 <endojelly> some students always said "well I could define another function which unpacks the pattern"
15:04:27 <endojelly> yeah, but HOW does it do that? 8)
15:05:07 <povman> martin__: you're probably better off looking at a GTK tutorial than here...
15:05:25 <povman> gtk2hs has cairo bindings too, which are pretty nice iirc
15:06:14 <beelsebob> they would be if cairo weren't so damn slow :(
15:06:30 <ImInYourMonad> http://home.telfort.nl/sp969709/gtk2hs/index.html
15:06:43 <ImInYourMonad> how do i tell lambdabot where something is?
15:06:45 <martin__> povman hmmm thanks a few keywords is what I needed...cairo looks like it might get the job done :)
15:06:45 <povman> you don't have to use cairo
15:06:52 <ImInYourMonad> martin__: http://home.telfort.nl/sp969709/gtk2hs/index.html
15:07:05 <ImInYourMonad> lambdabot: gtk tutorial is http://home.telfort.nl/sp969709/gtk2hs/index.html
15:07:12 <beelsebob> povman: no, in fact the slowness is what's making us not use it, and use quartz/wpf instead :(
15:07:32 <beelsebob> no idea what to do on linux
15:07:34 <povman> is cairo slow in other languages?
15:07:45 <beelsebob> yes
15:07:59 <beelsebob> for some reason it's buffer swaps are *painful*
15:08:03 <povman> evenwith hardware acceleration?
15:08:13 <beelsebob> it doesn't do hardware acceleration on anything but linux
15:08:14 <povman> hmh. oh well :D
15:08:17 <povman> oh wow
15:08:22 <beelsebob> so maybe on linux it isn't painful
15:08:35 <beelsebob> it's so slow that it can't even be just CPU -> GPU time
15:08:41 <beelsebob> it must be doing a bag load of martialling too
15:08:59 <povman> well my guess is that 95% of gtk users are on linux
15:09:00 <pumpkin> that's very bellicose of you
15:09:10 <beelsebob> povman: believable
15:09:14 <endojelly> not having cabal on ubuntu sucks so much.
15:09:17 <beelsebob> shame it's not usable for cross platform dev though :(
15:09:20 <ImInYourMonad> gah wtf Loading package hslibsvm-2.88.0.1 ... can't load .so/.DLL for: stdc++ (addDLL: could not load DLL)
15:09:21 <pumpkin> endojelly: then install it :P
15:09:25 <endojelly> or is it actually in a package where I don't suspect it?
15:09:29 <endojelly> pumpkin, there's no package! :(
15:09:32 <dons> what's this libsvm people keep talking about?
15:09:40 <povman> I want a Radians type
15:09:44 <dons> ah http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hslibsvm
15:09:48 <pumpkin> endojelly: sure there is, the tarball on hackage :P
15:09:57 <beelsebob> povman: units in types would be awesome in general
15:10:00 <endojelly> pumpkin, but a package would be so much *easier* 8)
15:10:02 <pumpkin> endojelly: with its own specially crafted package manager, called bootstrap.sh :P
15:10:20 <pumpkin> endojelly: there's only so much easier than wget && sh you can get :P
15:10:25 <endojelly> pumpkin, okay okay I comply %)
15:10:26 <povman> beelsebob: well - for now i want a real number mod 2pi
15:10:49 <povman> is there one lying around or do i have to write it?
15:10:57 <beelsebob> povman: easy enough to do with a newtype and a num instance
15:11:00 <povman> also is there a real mod function?
15:11:02 <pumpkin> ImInYourMonad: you working on netflix again, wit hlibsvm?
15:11:02 <beelsebob> wouldn't mind you putting it on hackage though ;)
15:11:10 <pumpkin> *with
15:11:29 <endojelly> pumpkin, actually, that's really fast and easy.
15:11:38 <pumpkin> yeah :)
15:11:58 <endojelly> i should get used to cabal
15:12:03 <endojelly> i still do makefiles for my haskell projects
15:13:12 <povman> hmm looking up     "real modulo" haskell   on google, the second result says "Haskell hurts my brain"
15:14:14 <beelsebob> hahahahahahahahahahahahaha
15:14:57 <endojelly> is it a good idea to install cabal systemwide by specifying /usr/local als PREFIX env?
15:18:06 <sm>  doh.. I start coding up a doctest.hs then find Simon Hengel released one last week
15:19:10 <povman> but seriously - is there a good real modulo algorithm, or should i just subtract 2pi until 0 <= it < 2pi ?
15:19:32 <ImInYourMonad> why is gnuplot called gnuplot when it isnt gnu-licensed?
15:19:54 <endojelly> it isn't? funny.
15:20:00 <wli> povman: Try floor.
15:20:28 <povman> wli: isn't that the integer part function?
15:24:28 <beelsebob> povman: divide by 2pi, take the floating part, and multiply by 2pi
15:25:00 <povman> oh, leet idea!
15:25:05 <beelsebob> s/floating/fractional/
15:25:33 <Deewiant> > Data.Fixed.mod' 4 pi
15:25:34 <lambdabot>   0.8584073464102069
15:25:57 <ImInYourMonad> data RealFloat a => Complex a = !a :+ !a , so how do I create just any complex nbr? using Data.Complex
15:26:07 <Chani> or do integer division, multiply the result by 2pi, and subtract from the original number. less rounding error that way, I think
15:26:23 <wli> > let x `fmod` y = x - y * fromInteger (floor $ x / y) in 9 `fmod` (2*pi)
15:26:24 <lambdabot>   2.7168146928204138
15:26:34 <Deewiant> > Data.Fixed.mod' 9 (2*pi)
15:26:35 <lambdabot>   2.7168146928204138
15:26:50 <povman> ImInYourMonad: 2 :+ 3    ==     2 + 3i
15:27:14 <beelsebob> hmm
15:27:21 <povman> integer division?
15:27:26 <beelsebob> yet another argument for GADTs
15:28:38 <BONUS> just found a use for untilM, w00t
15:29:02 <BONUS> haskell is so amazing, i can't even begin to express that
15:29:16 <beelsebob> @type untilM
15:29:17 <lambdabot> Not in scope: `untilM'
15:29:17 <povman> ahh Deewiant thanks
15:29:23 <povman> (and thanks everyone else too...)
15:29:31 <beelsebob> BONUS: whar is it, what it do?
15:29:36 <ddarius> @hoogle untilM
15:29:36 <lambdabot> No results found
15:29:37 <Deewiant> ?hoogle mod
15:29:37 <lambdabot> Prelude mod :: Integral a => a -> a -> a
15:29:37 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
15:29:37 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
15:29:44 <Deewiant> povman: Thank Hoogle, not me. :-P
15:29:45 <BONUS> i typed it
15:29:54 <BONUS> (a -> Bool) -> (a -> m a) -> a -> m a
15:30:09 <povman> bah, stupid prelude. needs to be destroyed imo
15:30:09 <beelsebob> BONUS: ah, yeh, I called that satisfiesM
15:30:18 <beelsebob> youll find it in checkers
15:30:31 <beelsebob> (because I needed it there, and it should have been a micro-package but I couldn't be arsed)
15:30:34 <BONUS> and i used it so that i have an I/O action that prompts the user for input until the input line is blank and when it is, the IO action yields a list of all the getLine results
15:30:49 <beelsebob> ah, neat
15:31:00 <beelsebob> I used it for generating a random number that satisfied a certain property
15:31:06 <BONUS> ah, awesome
15:31:14 <BONUS> i wonder why there aren't more M functions in the librares
15:31:18 <BONUS> like takeWhileM, etc.
15:31:22 <int-e> @type liftM2 (>>) guard
15:31:23 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (Bool -> m b) -> Bool -> m b
15:31:33 <beelsebob> I suspect takeWhileM is actually takeWhileA
15:31:39 <BONUS> ah
15:31:49 <BONUS> like mapM
15:31:52 <beelsebob> indeed
15:32:06 <beelsebob> folds in general tend to be applicative, not monadic
15:32:10 <int-e> @type liftM2 (>>) . (guard .)
15:32:11 <lambdabot> forall b (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> (a -> m b) -> a -> m b
15:32:26 <beelsebob> int-e: nice :)
15:32:27 <BONUS> int-e: omg. wow
15:33:00 <BONUS> i still after a year of doing haskell get amazed at how powerful and elegant it can be
15:33:16 <BONUS> i can't even put it into words and i've been thinking about that a lot. why is haskell so awesome
15:33:52 <ImInYourMonad> if i have a function f x y; and then do map f [(1,2),(3,4)], how do I do? map (f . uncurry) xs doesnt work
15:34:11 <Heffalump> map (uncurry f)
15:34:29 <BONUS> i've come to a conclusion that it's kind of a combination of laziness, typeclasses, ADTs and higher order functions that allows you to express patterns in a really general way and as behaviors that you can compose together
15:35:03 <ImInYourMonad> ADTs?
15:35:09 <BONUS> algebraic data types
15:35:13 <ImInYourMonad> algebraic datatypes
15:35:14 <ImInYourMonad> yes
15:35:39 <Heffalump> hi grahamhutton
15:35:39 <ImInYourMonad> i have not much experience with typeclasses but HOFand ADT for sure
15:35:47 <conal> BONUS: how do ADTs help?  the others are clear to me.
15:35:51 <BONUS> "why functional programming matters" kind of explains that but not all of the awesomeness
15:35:54 <grahamhutton> hi ganesh!
15:36:15 <ImInYourMonad> conal: datatsrtuctures are very eelegant with ADTs
15:36:31 <Heffalump> ADTs are great for describing interfaces clearly
15:36:32 <BONUS> conal: hmm. i guess you could have that without ADTs, it just makes it really nice with pattern matching and type parameters i guess
15:36:57 <conal> BONUS: so maybe ADT is the base case, and the other three are the composition part.
15:36:59 <grahamhutton> heffalump: and many thanks for the ICFP sponorship -- much appreciated!!
15:37:12 <BONUS> hmm yeah!
15:38:08 <BONUS> it's just so wonderful to make and use functions that capture some general behaviors and then the functions and types that are passed to them can determine the specific behaviors
15:38:15 <BONUS> not talking about behaviors here in a FRP sense
15:38:21 <pumpkin> ImInYourMonad: it predates gnu iirc, and was a play on "new"
15:38:30 <Power> halo
15:38:42 <Gracenotes> yay, my NFA->DFA converter is totally complete :D now for the minimization... *takes out chainsaw*
15:38:54 <Power> www.doctorbet.do.am
15:39:02 <ImInYourMonad> shouldnt it work to import Distribution.Haddock or haddock can only be used compiled?
15:39:04 <Gracenotes> spa.... mmity?
15:39:05 <BONUS> idk, i've just been thinking a lot for the last couple of days why exactly haskell strikes me as so awesome
15:39:25 <conal> BONUS: amen!
15:39:47 <ImInYourMonad> yes
15:39:49 <ImInYourMonad> Failed to load interface for `Haddock.GHC.Utils':
15:39:51 <ImInYourMonad> ok?
15:40:29 <povman> HUH how do I define signum for angles??
15:40:48 <pumpkin> signum (Angle a) = 1
15:40:48 <povman> const 1?
15:40:51 <povman> ok :p
15:41:00 <Gracenotes> you're making a Num instance?
15:41:03 <povman> yeah
15:41:07 <conal> BONUS: i think you'll find some similar sentiments in http://conal.net/papers/dsl97/, in the section called "Choosing a host language for modeled animation".
15:41:20 <mmorrow> povman: signum = error "why is signum in Num?" -- ?
15:41:21 <pumpkin> povman: how does multiplying angles make sense? :o
15:41:28 <BONUS> thanks, gonna give that a read now!
15:41:32 <povman> yeah that's what i thought too
15:41:34 <pumpkin> (*) = error "why is * in Num"
15:41:49 <Gracenotes> signum and abs don't always have to be well-defined.
15:41:49 <Gracenotes> for Nums. It seems.
15:41:51 <povman> oh undefined, right
15:42:08 <pumpkin> just massage the typeclass to be what you want it to be by imaginative undefined placement
15:42:12 <Gracenotes> povman: well, I think just returning 1 is right
15:42:22 <povman> for signum?
15:42:30 <povman> is there such thing as a negative angle?
15:42:36 <BONUS> btw conal found your Tangible Functional Programming talk on youchoob yesterday ... my mind = blown, rly awesome, gratz!
15:42:45 <mmorrow> depends how you are defining angles
15:42:49 <conal> BONUS: yay!  :)
15:42:54 <povman> 0 <= a < 2pi
15:42:56 <povman> :p
15:42:58 <Gracenotes> povman: uh, depends on whether you have control over your constructor or not :)
15:43:32 <povman> Gracenotes: i do
15:43:38 <BONUS> povman: depends, do you consider 0 and 2pi to be the same angle?
15:43:44 <povman> yes
15:43:47 <BONUS> ah
15:43:56 <BONUS> yeah then i guess signum = const 1
15:43:57 <Gracenotes> okay. Then 0 if it's 0 or 2pi, 1 otherwise
15:44:11 <povman> isn't signum undefined at 0
15:44:18 <pumpkin> > signum 0
15:44:19 <lambdabot>   0
15:44:21 <pumpkin> guess not :P
15:44:23 <povman> pff
15:44:26 <povman> it is in real life
15:44:27 <Gracenotes> you're thinking of the derivative of abs
15:44:30 <pumpkin> Gracenotes: I'd be wary of doing equality on floats though
15:44:38 <conal> @type signum
15:44:39 <lambdabot> forall a. (Num a) => a -> a
15:44:39 <Deewiant> > signum (-0) :: Float
15:44:40 <lambdabot>   0.0
15:44:43 <Deewiant> O_o
15:44:46 <Gracenotes> signum is not the derivative of abs, although it's identical except on one datapoint
15:44:51 <Gracenotes> namely 0
15:44:53 <conal> signum on angles = 1 what?  radian?
15:44:59 <povman> what , no it's not
15:45:03 <povman> > signum 400
15:45:04 <lambdabot>   1
15:45:12 <pumpkin>  conal: no units :P
15:45:17 <pumpkin> http://en.wikipedia.org/wiki/Sign_function
15:45:20 <Gracenotes> signum's range {-1, 0, 1}
15:45:23 <povman> conal: exactly
15:45:26 <ddarius> Gracenotes: Clearly the derivative of abs should be half-way between abs x for x < 0 and abs x for x > 0
15:45:30 <conal> pumpkin: what angle is 1?
15:45:38 <povman> conal: 1 radian
15:45:41 <pumpkin> ?
15:45:43 <povman> in my case at least...
15:45:57 <Gracenotes> ddarius: half-way sounds suspiciously like a limit to me!
15:46:26 <conal> povman: that's my guess, and i doubt it's a useful choice for signum.
15:46:35 <povman> yeah it's a bit stupid
15:46:46 <BONUS> i dont know what you're making here, but i'd let an angle be in the range from -inf to inf
15:46:49 <povman> i'm going to put signum, abs, and * as undefined
15:46:59 <Gracenotes> :/
15:47:08 <ddarius> Gracenotes: D abs 0 = (lim abs x as x -> 0+ + lim abs x as x -> 0-) / 2
15:47:08 <pumpkin> make abs take care of modding the angle :P
15:47:12 <conal> povman: what's compelling to you about angles as Num ?
15:47:15 <Gracenotes> I think it's better to make a dummy implementation than an undefined one
15:47:31 <pumpkin> povman: http://www.haskell.org/haskellwiki/Type_classes_are_for_reusability
15:47:32 <Gracenotes> for signum and abs, anyway
15:47:34 <povman> conal: someone told me to
15:47:47 <conal> povman: maybe you could tell them why not.
15:47:48 <pumpkin> "Do you really need a Num instance for a network port, just in order to be able to write 80 for a port number? How would sensible definitions of (*) would look like?"
15:47:52 <ImInYourMonad>  is it not possible to pass args to gnuplot on the command line?
15:48:00 <povman> i'm writing a game
15:48:30 <povman> i want to be able to keep adding to an angle and not have it start losing precision
15:48:30 <conal> povman: instead of Num, you might use VectorSpace
15:50:29 <povman> use a vector instead of an angle?
15:50:48 <conal> povman: use VectorSpace instead of Num
15:50:53 <BONUS> vector spaces define a + operation and multiplying with a scalar
15:50:56 <conal> povman: instance VectorSpace Angle where ...
15:50:58 <ddarius> Gracenotes: L[df/dx](s) = sL[f](s) - f(0), so do L^-1(sL[abs])
15:51:31 <conal> @hackage vector-space
15:51:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vector-space
15:51:33 <Gracenotes> hm... the ascii notation is killing my brain.
15:51:41 <povman> conal: i have the docs here
15:51:44 <conal> :)
15:51:47 <pumpkin> I insist that someone develop an IRC client with TeX support
15:51:50 <pumpkin> !
15:51:59 <conal> pumpkin: !!
15:52:04 <pumpkin> conal: !!!
15:52:11 <conal> pumpkin: heh.
15:52:14 * ddarius nominates pumpkin.
15:52:21 <BONUS> although i wonder if defining an angle in a vector space would satisfy the vector space laws
15:52:21 <Gracenotes> I think there's an extension for a popular IRC client
15:52:26 <notsmack> pumpkin:  pidgin + pidgin-latex?
15:52:35 * glguy detects loop, kicks broken threads
15:52:40 <ddarius> Gracenotes: Oh yeah, L being the Laplace transform
15:52:41 <pumpkin> :t loop
15:52:42 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
15:52:44 <conal> pumpkin: also with eval support for functional media
15:52:48 <pumpkin> mmm
15:52:52 <pumpkin> we need yirc
15:52:55 <povman> conal: you think i should make angle a vectorspace? the name is a bit misleading innit?
15:53:06 <pumpkin> it makes sense
15:53:19 <ddarius> povman: Why is it misleading?
15:53:21 <BONUS> vector spaces don't really imply vectors :)
15:53:27 <BONUS> except that there's "vector" in the name
15:53:35 <pumpkin> povman: you can make vector spaces out of a lot of things you don't normally consider vectors
15:53:38 <BONUS> vectors form vector spaces, sure, but so does a lot of other stuff
15:53:48 <Gracenotes> ddarius: oh. I quite seriously need to review calculus.
15:53:56 <conal> povman: "vector space" is a pretty general term.
15:54:04 <povman> huh. ok, i believe you
15:54:12 <ddarius> BONUS: If it forms a vector space, it is a vector.
15:54:18 <povman> and it refers to an additive group which can be scaled?
15:54:29 <conal> povman: yeah.
15:54:30 <pumpkin> let's call the common one euclidean vector or something :P
15:54:31 <Gracenotes> not doing it during senior year of high school was bad idea. since I had taken the course itself a year before that.
15:54:35 <Gracenotes> ddarius: so you're saying the derivative of abs at 0 is 0?
15:54:36 <BONUS> ddarius: ah, i see, i was thinking of "vectors" too tightly :)
15:54:53 <povman> alright, thanks. i'll do that
15:55:14 <conal> "the derivative of abs at 0 is 0?"  i think "the" is a bug here.
15:55:15 <pumpkin> http://en.wikipedia.org/wiki/Examples_of_vector_spaces not very many interesting examples on that page
15:55:15 <ddarius> Gracenotes: The derivative of abs at 0 is undefined, but if we were going to give it a definition, 0 has some perks.
15:55:20 <povman> btw conal since you're here, should i be considering Reactive for this or should i wait a while?
15:55:31 <ddarius> Gracenotes: L^-1 . L /= id
15:55:47 <amz> quick noob question... float to int (not Integer) and vice-versa?
15:55:54 <conal> povman: Reactive is going through some bumps right now.  might be more fun to use later.
15:56:23 <povman> conal: I also completely don't understand how i could use it in conjunction with sdl to make a game
15:56:23 <amz> ah, floor and fromIntegral :)
15:56:27 <Gracenotes> I see. I wouldn't say they're equivalent, of course. I trust you that it's convenient, though.
15:56:29 <conal> amz: fromIntegral and floor/round
15:56:37 <ddarius> @src Floating
15:56:37 <lambdabot> class  (Fractional a) => Floating a  where
15:56:37 <lambdabot>     pi                                                      :: a
15:56:37 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:56:37 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:56:37 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:56:43 <ddarius> @src RealFrac
15:56:43 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
15:56:43 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
15:56:43 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
15:56:46 <amz> thanks :)
15:56:46 <ddarius> There we go.
15:57:16 <conal> povman: the sdl part would be buried in what i call a "legacy adapter".  (where "legacy" means imperative)
15:57:44 <pumpkin> now that more people are around, does anyone know how to write tests in quickcheck that expect an error to be thrown under certain conditions?
15:57:45 <conal> povman: think of sdl -- and *all* imperative computation -- as living in a RTS for a purely functional paradigm.
15:58:46 <povman> i probably need to get used to thinking in FRP rather than in imperative style
15:58:54 <ImInYourMonad> what is a nice function to plot? like an optimixation problem for example
15:59:08 <pumpkin> ImInYourMonad: optimize sin(x) ;)
15:59:10 <povman> conal: so would i write a kind of 'engine' which frp programs run in?
15:59:23 <povman> conal: i assume the rendering is still all IO code?
15:59:39 <pumpkin> w00t, hardcore forking action on github in the git community!
15:59:42 <pumpkin> *haskell community
15:59:48 <conal> povman: engine -- something like that.  "rendering" can be mostly functional.
15:59:53 <pumpkin> http://github.com/tibbe/haskell-style-guide/network
16:00:22 <conal> povman: i.e., most of what people mean by "rendering" can be given a simple functional basis.
16:00:30 <Olathe> > 0 - 0
16:00:31 <lambdabot>   0
16:00:34 <ImInYourMonad> how cna i plot several functions in the same plot?
16:00:41 <conal> povman: leaving a thin imperative residue
16:00:48 <pumpkin> @google gnuplot manual
16:00:49 <lambdabot> http://www.gnuplot.info/docs/gnuplot.html
16:00:49 <lambdabot> Title: gnuplot
16:01:11 <pumpkin> ImInYourMonad: gnuplot should have a degree dedicated to it :P
16:01:15 <povman> conal: this is interesting - i must read your blog or something
16:01:25 <pumpkin> it should be required reading
16:01:39 <Olathe> > Nothing - Nothing
16:01:39 <lambdabot>       No instance for (Num (Maybe a))
16:01:39 <lambdabot>        arising from a use of `-' at <in...
16:01:59 <BONUS> > liftM2 (-) Nothing Nothing
16:02:00 <lambdabot>   Nothing
16:02:05 <conal> povman: one thought experiment that may help you shift toward declarative is to keep asking what things "mean".  if you ever use a verb, you know you're back in the imperative rut.
16:02:19 <adamvo> could someone check this updated cabal file for pointfree: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2400#a2400
16:02:33 <BONUS> yeah, think of what stuff *is* instead of what the steps are to get it
16:02:34 <Olathe> BONUS: Heheh
16:02:36 <conal> povman: in other words always ask what you want something to *be*, not to *do*
16:02:58 <adamvo> It works, but I don't know if its the best way to do it, and I don't have a hackage account
16:03:02 <povman> well yes - but SDL all runs in IO
16:03:11 <conal> povman: that's why i say you can't do anything with functional programming.  that's what's awesome about it.
16:03:27 <povman> conal: i said roughly the same thing yesterday and people killed me :'(
16:03:53 <conal> povman: yeah.  i get that reaction also.  they'll come around.
16:04:14 <BONUS> it's interesting how when at first you start FP, the no mutable state thing seems kind of limiting, but then you actually see it's liberating
16:04:22 <jmcarthur> conal, do you mind if i ask what you've been up to since reactive is on hold right now?
16:04:28 <conal> povman: the thought experiment would be to ask what simple (and hence functional) idea is that SDL code an implementation of.
16:04:38 <BONUS> because you don't have to think about "what's this variable's value now .. and now" but you just think about what stuff is in terms of other stuff
16:05:08 * jmcarthur figures he should have checked conal's blog first before asking
16:05:23 <conal> jmcarthur: not at all.  i obsessed over writing for ICFP, with two resulting papers.  then i dove into a new dsel and compiler for gpu programming, which is going great.
16:06:07 <Power> www.doctorbet.do.am
16:06:13 <pumpkin> @where ops
16:06:14 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
16:06:19 --- mode: ChanServ set +o glguy
16:06:21 --- mode: glguy set +b *!*@195.60.175.242
16:06:44 --- kick: Power was kicked by glguy (no spam)
16:06:55 --- mode: glguy set -o glguy
16:07:14 <pumpkin> it'd be pretty easy to write a bot that checked for "X joined; X posts URL < 30 seconds later, with nothing in between"
16:07:20 <jmcarthur> conal, nice! i haven't read the papers yet (intend to), but i didn't know about the GPU programming stuff. sounds awesome
16:07:23 <conal> would someone post a #haskell op tutorial on the wiki?
16:07:44 <pumpkin> conal: how do you mean?
16:07:46 <ddarius> conal: There are some tips on the wiki, not really a tutorial.
16:07:54 <povman> conal: it doesn't help that the documentation for VectorSpace says "Scale a vector"
16:08:02 <glguy> conal, you can start by joining #haskell-ops :)
16:08:19 <conal> jmcarthur: it's a lot of fun.  while i've done similar systems before, i like this one a lot better.  it uses GADTs and keeps all the syntax and its manipulation (e.g., algebraic rewriting) statically typed.
16:08:31 <conal> glguy: oh, thanks.
16:08:44 <conal> povman: yeah.  "vector" is also a pretty generic term.
16:08:52 <povman> uh ok then :p
16:08:52 <conal> ddarius: oh?  url?
16:08:55 <idnar> is Reactive "on hold" due to some specific problem, or just shifting interests?
16:09:03 <mreh> lads, ive installed the HGL from the SOE installer, but my GHC doesn't list the package in the .conf file
16:09:11 <jmcarthur> GADTs are awesome. whenever i use them i wish i had real dependent types though
16:09:11 <mreh> is there a step i've missed
16:09:18 <gwern> isn't conal grubbing for money like the rest of us nowadays?
16:09:27 <mmorrow> jmcarthur: me too
16:09:35 <pumpkin> mmm grubbing for money
16:09:51 <mreh> anyone have an idea?
16:10:02 <conal> idnar: a problem came up with the company that was sponsoring the work.  i'd hoped to work it out.  meanwhile, i got into paper writing.  i'll get back to it, though.
16:10:13 <mmorrow> mreh: did you install them locally instead of globally?
16:10:21 <TomMD> mreh: What does 'ghc-pkg list' say?
16:10:29 <lunabot>  luna: lexical error in string/character literal at end of input
16:10:29 <mreh> its not in ghc-pkg
16:10:32 <mreh> yes it was local
16:10:40 <idnar> conal: ah, I see
16:10:41 <mreh> is that where i fucked up
16:10:43 <mmorrow> uhoh, lunabug
16:10:44 <conal> i am tilting my thinking toward things that may generate some future income.  i don't plan to stop doing functional programming or get a regular job, however.
16:11:08 <pumpkin> mmorrow: that happens occasionally, but I'm not sure what it responds to
16:11:16 <mmorrow> pumpkin: it's the "]"
16:11:32 <pumpkin> I don't see no ]
16:11:35 <TomMD> mreh: If it isn't registered, and thus showing with ghc-pkg, then it won't be accessible - or I'm missing what you are trying to do.
16:11:39 <Zao> 00:10 -!- trofi [n=slyfox@93.84.97.63] has quit ["byebye :]"]
16:11:42 <conal> idnar: also, i got burnt out with debugging some tricky laziness stuff.  some of which turned out to be bugs in GHC's concurrency RTS.
16:11:42 <pumpkin> oh :)
16:11:42 <mmorrow> i guess it's not only responding the `elem` "]," at the beginning of a msg
16:11:43 <mreh> mmorrow: What's the deal with a local install
16:11:52 <pumpkin> I wasn't looking at join/part messages
16:11:58 <ddarius> conal: http://www.haskell.org/haskellwiki/IRC_channel/Management
16:12:03 <mreh> TomMD: how do i register the packaged?
16:12:05 <mmorrow> mreh: i'm not sure, i always exclusively install stuff to the global db
16:12:06 <mreh> TomMD: how do i register the package?
16:12:41 <glguy> mmorrow, it might be looking at the :
16:12:44 <glguy> which starts the last message
16:13:01 <TomMD> mreh: How di dyou actually install it?  Did you use cabal-install?
16:13:05 <mmorrow> glguy: ooh, good point. that might be it
16:13:09 <diracdelta> What are the minimal requirements for a c compiler to compile the generated .hc file?
16:13:13 <mmorrow> :] 42
16:13:21 <diracdelta> It needs "Stg.h" to be present
16:13:22 <mmorrow> hmm
16:13:24 <glguy> : is used all the time as cons
16:13:26 <TomMD> mreh: If you didn't use cabal install then I suggest you do that.  The alternative is 'ghc-pkg register' with some arguments I don't remember.
16:13:34 <glguy> so... it would be strange I suppose if that broke in normal messages
16:13:38 <mreh> thanks
16:13:45 <mreh> im just looking at the usage now, thanks
16:13:50 <mmorrow> glguy: oh, i was thinking you meant because of the ":" in raw irc messages
16:14:00 <glguy> mmorrow, well.. I was
16:14:02 <mmorrow> err, but he said "byebye" before the : anyways i guess
16:14:06 <glguy> I'm not sure what the quit message looks like raw
16:14:08 <mmorrow> glguy: oh, hmm
16:14:11 <diracdelta> which standar librararies/headers does it need?
16:14:16 <mmorrow> glguy: yeah, me neither
16:15:25 <diracdelta> wait... ghc includes gcc.exe for the windows version?
16:15:36 <diracdelta> is c code always created as an intermediary for ghc?
16:15:48 <conal> ddarius: just what i wanted.  thanks a bunch!
16:16:10 <seliopou> diracdelta: No, but needs an assembler, I believe
16:16:16 <pejo> diracdelta, no, it has a native code generator as well.
16:18:28 <jmcarthur> diracdelta, ghc either generates assembly and uses GCC to assemble that or it uses its own code generator, depending on what flags you give it
16:18:49 <diracdelta> jmcarthur: ah. So it's using gcc as an assembler then?
16:19:07 <jmcarthur> diracdelta, at least it does with you give it fvia-c. i'm not sure what the default is
16:19:46 <seliopou> diracdelta: try -v when you're compiling and you'll see the gcc invocation
16:20:02 <diracdelta> seliopou: hm. I'll try that, thank you.
16:21:32 <diracdelta> selipou: so it does. Do you know if any special flags are sent to gcc for compilation? Or should "gcc test.hc" create a working executable?
16:21:54 <seliopou> you can use -optc to pass flags, I believe
16:23:31 <Botje> @pl \d1 d2 -> nest d1 4 d2
16:23:31 <lambdabot> flip nest 4
16:27:25 <pejo> diracdelta, why aren't you using ghc to compile your file instead?
16:28:18 <diracdelta> pejo: I am. I was just interested in how the build process works. Specifically, I was interested in figuring out how to take the generated .hc file from ghc and change what compiler it gets built with.
16:30:30 <diracdelta> pejo: basically, I'm trying to write a haskell program on a HC12 microcontroller. Briefly looking into this topic, it seems I should be using something called nhc and not ghc. Is this correct?
16:30:45 <diracdelta> pejo: and if so, what are the primary differences in these two?
16:31:40 <sjanssen> diracdelta: the output of GHC is not portable and GHC is not a cross compiler
16:32:36 <diracdelta> sjannsen: thanks. What parts of the generated .hc file are system specfic?
16:33:10 <sjanssen> diracdelta: basically the whole thing AIUI
16:33:39 <sjanssen> diracdelta: what sort of architecture is this microcontroller?
16:35:40 <diracdelta> sjanseen: it's a 16 bit microcontroller. What in particular would be useful to know about the architecture?
16:39:15 <diracdelta> Our setup has 32k of program memory, about 4k of runtime memory.
16:39:49 <mmorrow> diracdelta: ghc minimum default allocation block size is 4k
16:39:58 <mmorrow> , let x = 42 in x
16:40:01 <lunabot>  42
16:40:03 <mmorrow> 4k right there
16:40:07 <mmorrow> at least
16:40:27 <mmorrow> (not counting all the other stuff it needed to do)
16:42:42 <mmorrow> diracdelta: what seems to be the strategy i've seen for embedded stuff/fpgas/etc is to either write a minimal compiler from haskell to some bytecode or the machcode of the device itself, or to use haskell as a meta-language to generate code (like C or asm) that'll run on it
16:43:05 <mmorrow> (the latter being hugely more reasonable)
16:43:26 <mmorrow> @go reduceron2
16:43:28 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
16:43:28 <lambdabot> Title: The Reduceron
16:43:37 <mmorrow> (an example of the first strategy)
16:44:16 <diracdelta> mmorrow: makes sense. Looks interesting.
16:45:26 <diracdelta> mmorrow: question, did I understand your statement about default allocation block size in that each haskell label corresponds to a 4k allocation block? Or do multiple haskell labels get placed in a single allocation block?
16:46:04 <diracdelta> mmorrow: of course, I should probably just be asking for a good review of the low level implementation details of haskell at this point.
16:46:29 <defun> Is it possible to have a hypothetical haskell program retreive information (such as lists and values) from a *.hs file compiled to an object file?
16:46:44 <Philippa_> diracdelta: no such thing, that varies from haskell implementation to haskell implementation. GHC isn't suitable for that environment
16:47:05 <povman> defun: are you talking about plugins?
16:47:20 <defun> yes, i suppose that's what it's called.
16:47:27 <Philippa_> diracdelta: and it'll put multiple values in a block quite happily, it just won't allocate a smaller block
16:47:40 <povman> http://www.cse.unsw.edu.au/~dons/hs-plugins/
16:47:44 <diracdelta> Philippa_: thanks, that's what I thought.
16:48:09 <defun> thanks, ttyl.
16:48:34 <diracdelta> Phillipa: er, so your saying that the best 'review' of low level implementations of haskell would be the compiler sources themselves?
16:49:07 <Philippa_> diracdelta: I'm saying that you'd have to look at docs for those specific implementations
16:49:20 <Philippa_> honestly though, the metalang approach is far more likely to work out for you
16:49:38 <diracdelta> Phillipa_: Agreed. Though I'm interested anyhow :), so thank you.
16:50:04 <Philippa_> there's not so much "folklore" about nhc, comparatively few people use or have used it
16:51:29 <augustss> nhc used to be the best option fr heap profiling.
16:51:29 <mmorrow> diracdelta: as i understand, it allocates memory (by default, but changeable) in 4k blocks, but "let x = 42 in x" definitely doesn't fill that block, yes.
16:52:41 <wli> Metalang? Like LPS?
16:52:51 <Philippa_> LPS?
16:52:56 <mmorrow> , [$bf|.+[.+]|]
16:52:59 <lunabot>  luna: No instance for (GHC.Show.Show
16:53:01 <mmorrow> , [$bf|.+[.+]|] ""
16:53:02 <Philippa_> I mean using haskell to generate code for the target platform
16:53:03 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
16:53:15 <wli> http://lsi.uniovi.es/~labra/LPS/LPS.html
16:53:38 <diracdelta> mmorrow: thank you for the clarification. Much more reasonable (in fact, I probably shouldn't have needed to ask)
16:53:47 <mmorrow> diracdelta: :)
16:54:06 <wli> (There are almost no docs; you have to look at the code to see what it's doing, which is moderately impressive.)
16:56:37 <wli> (Basically, it takes a language description and interprets the language described, whose semantics may vary over a broad range, and that all at runtime, albeit once per-startup.)
16:57:12 <Philippa_> wli: in that project, Haskell is used as a metametalang :-) The lang description lang being a metalang
16:58:02 <wli> Sure, yeah.
16:58:15 <wli> It's pretty far out.
17:00:23 <wli> It uses some sort of universal algebra -related affair for language definitions.
17:00:52 <gwern> so, I've been working through chapter 1 of SICP. anyone want to review my little essay/review of it? http://community.haskell.org/~gwern/wiki/sicp/Chapter 1.page
17:03:52 <wli> I so hate stack machines. I wish there were a register/memory -based G-machine or other abstract machine model.
17:04:40 <wli> I wish I were able to make up such a thing.
17:04:46 <p_l> wli: parrot is a register machine, MMIX also makes it easy to avoid stack (it has a giant register window)
17:04:59 <twb> In Parsec, how do I say "one or more <parser>"?
17:05:08 <mle> many1
17:05:10 <twb> e.g. phrase = oneOrMore word
17:05:14 <twb> Thanks.
17:06:00 <dolio> Aren't register machines the hotness these days anyway?
17:06:24 <dolio> Lua? The webkit javascript machine?
17:06:29 <Philippa_> wli: shouldn't be too hard to do from an ANF-like language?
17:08:09 <wli> Well, I keep flopping every time I try to wing it.
17:08:42 <wli> p_l: Well, those aren't terribly easy to translate FP languages to.
17:09:52 <twb> You know, why am I bothering to write a parser for RFC 2822?
17:09:58 <p_l> dolio: cause it took the general IT crowd to notice that stack machines weren't faster by design
17:10:00 <twb> There bloody well should be one already
17:10:06 <gwern> twb: because it's there?
17:10:17 <twb> Specifically, I want the ability to parse addr-spec and display-name in http://tools.ietf.org/html/rfc2822
17:10:19 <wli> I hit the wall in/around any sort of control flow.
17:14:45 <drbean> gwern: Does the URL have a space? http://community.haskell.org/~gwern/wiki/sicp/Chapter 1.page
17:15:44 <wli> I'm starting to get the gist of how the code/data separation works, though.
17:17:27 <gwern> drbean: sure does
17:19:22 <jrockway> osfameron: ping
17:19:35 <jrockway> osfameron: interesting blog post about grids, i spent some time a while back struggling with that
17:19:48 <jrockway> the best i could get was a doubly-linked list... i couldn't figure out the inductive step on a grid :)
17:20:02 <jrockway> then i got distracted by something else shiny, and forgot about it until you mentioned it again
17:20:11 <mreha> guys, what exaclty can i register with "ghc-pkg register"? .hs files?
17:20:32 <gwern> > (99 + 99 + 69) / 3
17:20:33 <lambdabot>   89.0
17:20:37 <m`lan> jrockway: url? :)
17:20:48 <wli> It's not obvious at all how e.g. the G-machine maintains stack balance (or if it does).
17:21:06 <gwern> > (90 + 90 + 69) / 3
17:21:07 <lambdabot>   83.0
17:21:37 <Philippa_> stack balance? (I should know this)
17:21:44 <jrockway> m`lan: http://greenokapi.net/blog/2009/03/10/rough-grids-in-haskell/
17:21:49 <m`lan> thanks :)
17:21:58 <mreha> can anyone help? I've installed SOE, but it hasn't registered with my GHCi
17:22:37 <wli> Philippa: Each procedure restores the stack to the same height it was when they were called upon return. With tailcalls in tow, this is completely non-obvious.
17:23:42 <Philippa_> wli: if you support tail calls, that becomes something for the compiler to not screw up
17:23:58 <Heffalump> the G-machine is part of the compiler...
17:24:27 <mreha> heeeeyalp!!
17:24:46 <Philippa_> yes, but you can conceptualise everything before the G-machine as a smaller one
17:24:59 <wli> If you've got a register file, say, with register windowing or some such, when to do what with registers (blow away the local stack frame's register set, save it somewhere, restore it).
17:24:59 <Heffalump> mreha: I'm just reading the SOE installation instructions and getting a headache
17:25:06 <twb> @hoogle interactive
17:25:07 <lambdabot> System.Process runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
17:25:07 <lambdabot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
17:25:22 <twb> @hoogle interact
17:25:22 <lambdabot> Prelude interact :: (String -> String) -> IO ()
17:25:22 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
17:25:22 <lambdabot> System.IO interact :: (String -> String) -> IO ()
17:25:38 <mreha> Heffalump: i couldn't find any from the .msi installer
17:25:52 <mreha> are you thinking of the cabal installation?
17:25:54 <Philippa_> wli: with a tail call, anything from this frame wants to go boom - aside from shuffling the parms somewhere appropriate
17:25:59 <Heffalump> >> The SOE source code requires no installation once
17:25:59 <Heffalump> >> GLFW is installed.  Simply place the SOE code where
17:25:59 <Heffalump> >> you want it, load any module into GHCi, and hope for
17:25:59 <Heffalump> >> the best!
17:26:03 <Heffalump> what happens when you do that?
17:26:14 <wli> When things jump around in the G-machine it's very unclear as to which operations correspond to doing what with registers in terms of calling convention support (i.e. saving registers on the stack, blowing them away, restoring from the stack).
17:26:19 <Heffalump> I was reading this page: http://www.haskell.org/soe/software1.htm
17:27:10 <mreha> Heffalump: it works alright, i just want a generic installation :'(
17:27:25 <Heffalump> sounds like someone should package it up for hackage
17:27:36 <mreha> unless...
17:27:38 <Heffalump> you need a .package file for ghc-pkg register, IIRC
17:27:45 <Heffalump> but cabal normally sorts all that out for you
17:27:53 <Philippa_> wli: for a non-tail call, save anything not dead. For a tail call, save nothing
17:28:08 <mreha> i've seen a few peoples dumps from their ghc-pkg with a HGL-3.x in their list
17:28:16 <wli> The G-machine branches don't cleanly map onto call vs. tailcall.
17:28:25 <mreha> there is probably something already out there
17:29:01 <wli> I guess I can try to roll my own without reference to G-machines etc. but it's very hairy.
17:29:56 <Philippa_> wli: yeah, you probably want to roll your own bytecode from an IR just the next level up. The usual G-machine code for that's an ANF variant, isn't it?
17:30:15 <Philippa_> oh, the STG variant from the eval/apply paper's fairly sane
17:30:17 <Heffalump> cabal install HGL seems to be possible
17:30:26 <Heffalump> dunno about on Windows though (since you mention .msi)
17:30:51 <Philippa_> wli: I take it you definitely want non-strict?
17:31:00 <mreha> all it doesn is unpack some files where it wants to
17:31:04 <p_l> cabal-install on windows... is not a good idea unless you only install pure haskell code
17:31:19 <Philippa_> for strict I would've thought it's fairly easy to see your way from an ANF-like to code
17:31:26 <wli> Philippa: Yeah. Maybe I need to find something between the abstract machine level and the core level.
17:31:31 <Heffalump> p_l: or something like zlib that bundles its own C library for conditional use on Windows
17:31:50 <Philippa_> wli: the STG lang's about what you're after, I think. Very low-level ANF variant
17:31:55 <wli> Philippa: Maybe. I've not even considered strict.
17:32:28 <wli> Philippa: I'll give the STG language a shot after I get back from the hospice.
17:32:43 <p_l> Heffalump: I guess that's because zlib is portable, not "autotools portable" (which is "linux and maybe few more unices if author was extra careful")
17:33:38 <Heffalump> yeah
17:34:14 <p_l> I gave up coding in Haskell for Windows
17:35:05 <mreha> im just playing really
17:35:34 <Heffalump> I think Haskell stuff works pretty well on Windows considering how crappy Windows is as a platform for C stuff
17:35:42 <mreha> has anyone here managed to transfer these skills to flash?
17:36:01 <TomMD> Heffalump: Sure, but that's never a good comparison.
17:36:26 <wli> Maybe I should do an automatic differentiation and maybe even integration affair for rational functions before I try automatic differentiation for algebraic extensions of K(x) where K is an extension of Q.
17:36:56 <TomMD> Heffalump: I recall one systems researcher saying the same thing about Haskell vs. C for out of memory issues.  "Sure, but C doesn't fix those issues either."
17:37:14 <pumpkin> there are some really stupid people on the internet! I guess I probably fall into that category too for sounding so surprised at the statement
17:39:38 <wli> I've got some expression normalization going, but I ran out of steam before I figured out how to rationalize denominators, find integral bases, or anything of that sort.
17:40:42 <wli> I couldn't even smoke out how to figure out what precisely the extension of Q(x) was given the various expressions in radicals.
17:42:56 <wli> It may be that I have to represent it as a tower of cyclotomic and "real" radical extensions explicitly, at which point I get very lost very quickly as to how to get a basis at all, never mind an integral basis.
17:43:05 <conal> is there a way to tell ghci where to search for CPP include files?  i'm getting an include from the applicative-numbers library, but ghci doesn't find it.
17:43:18 <conal> no problem when i compile with cabal+ghc.
17:43:40 <conal> (except loss of ghci)
17:43:46 <Heffalump> I'm fairly sure I've done it, but I can't remember how and I can't get at the code right now to check.
17:43:50 <Heffalump> -I ?
17:44:14 <conal> i'm looking for something i can put in a .ghci
17:44:14 <Heffalump> but I think that's the same for ghc.
17:44:31 <conal> maybe that's what cabal generates
17:45:29 <Heffalump> if the header file is in a package, it should just work in both, IIRC
17:45:41 <Heffalump> because the package file tells both ghc and ghci what to do
17:46:15 <pumpkin> I think it's -I, yeah
17:46:31 <pumpkin> it worked for me the one time I needed it, at least
17:46:46 <wli> Hmm. I actually have to do the same thing for Q just to figure out the base field K to do coefficient arithmetic on.
17:46:48 <conal> Heffalump: oh, hm.  that's what i'd hoped.  doesn't seem to be working for me.
17:47:07 <conal> i.e., ghci is failing to find the include file, although ghc+cabal finds it.
17:47:19 <Heffalump> I can check once they turn the power back on at work (so probably Sunday evening)
17:47:25 <pumpkin> conal: so if you do :l Module it complains about the missing header file?
17:47:41 <wli> (I don't have any provisions for introducing transcendentals anyway.)
17:48:04 <pumpkin> just say they transcend your library :)
17:48:11 <conal> pumpkin: yeah.
17:48:24 <pumpkin> I had exactly that situation yesterday and the -I worked
17:48:27 <pumpkin> thats an eye
17:48:28 <pumpkin> not an ell
17:48:30 <pumpkin> :P
17:48:40 <pumpkin> in case your font is as ambiguous as mine
17:48:47 <Heffalump> I don't think conal should have to use -I when the header file is in a package
17:49:05 <conal> pumpkin: thanks.  i'll try it.
17:49:08 <pumpkin> oh, in my case it was in a package, but I was trying to run "inside" the package
17:49:09 <conal> Heffalump: me neither.
17:49:20 <pumpkin> if it's already compiled, you should definitely not need to
17:49:23 <Heffalump> an installed package, then
17:49:26 <wli> pumpkin: It's a calculator, not a library per se. The idea is that these particular function fields can fully normalize expressions to reduce to zero etc. on account of linear algebraic concerns.
17:49:36 <conal> hm.  maybe a bug then.
17:49:55 <Heffalump> you presumably did set whichever cabal field is appropriate?
17:50:07 <gwern> hm. this is odd. why do the SICP lectures have a midi version of Bach's _Jesu, bleibet meine frende_?
17:50:29 <gwern> (as their theme)
17:50:48 <lament> why wouldn't they, really?
17:50:49 <wli> pumpkin: So, for instance, automatic differentiation can fully reduce the result and eliminate 0 * x occurring even in ways where one has to collect like terms to reduce subexpressions to 0.
17:51:02 <conal> Heffalump: i set include-dirs and install-includes
17:51:03 <pumpkin> cool
17:51:18 <Heffalump> that sounds right to me from memory
17:51:24 <gwern> lament: well, I wasn't expecting a theme at all, and I just wonder why they picked that one, and why they picked a crappy-sounding version
17:51:29 <pumpkin> wli: I'm sure it would be quite nice as a library, even if you're not writing it as one right now
17:51:30 <wli> pumpkin: This is pretty obvious how to do for rational functions.
17:52:12 <conal> Heffalump: http://hackage.haskell.org/packages/archive/applicative-numbers/0.0.2/applicative-numbers.cabal
17:52:42 <conal> does that .cabal look right, for making src/ApplicativeNumeric-inc.hs available to other packages?
17:53:00 <conal> i'd *much* rather have it work without -I, since the location would be installation-specific.
17:53:03 <Heffalump> I honestly can't remember without comparing with the one that does work
17:53:44 <wli> pumpkin: It's also possible to do for algebraic functions, i.e. rational functions plus n-th roots of rational functions because some theorems about those let you construct linear algebraic bases and rationalize denominators in every instance so it's all collected in terms of coefficients of the basis functions (where the coefficients are now rational functoins and the basis functions either 1 or n-th roots of rational functions).
17:55:22 <wli> I should probably scale back my design goals and get a prototype operating purely on Q(x) going.
17:56:02 <wli> In that case it's very obvious how to find common denominators, collect like terms in the numerator, and do polynomial gcd.
17:57:29 <pumpkin> that "Hello Haskell, Goodbye Lisp" proggit post is very controversial :P
17:57:32 <JuanDaugherty> freunde oder freude, surely
17:57:37 <pumpkin> it's funny how much people love to hate things they don't understand
17:57:46 <wli> pumpkin: I'm not 100% sure but I think there are some very involved methods for doing things in a like fashion when you add transcendental functions that are solutions to differential equations of certain forms.
17:58:04 <pumpkin> "look at me, I'm a good coder and I only know c++... you clearly need nothing else, QED"
17:58:33 <pumpkin> wli: sounds over my head :) but I look forward to seeing it when you're done
17:59:53 <twb> Bleh, I never understand the "right" way to handle whitespace in parsec.
18:00:03 <Heffalump> twb: <aol>
18:00:07 <Botje> use a token parser and don't worry about it :)
18:00:23 <twb> Botje: OK, let me paraphrase: I don't understand how to tokenize in Parsec.
18:00:26 <mauke> 1) make every token parser swallow trailing whitespace
18:00:41 <mauke> 2) skip whitespace at the beginning
18:00:43 <wli> pumpkin: I'm only going to even try for the stuff with n-th roots of rational functions (e.g. ((x^2+1)/(x^3-1))^(1/5)). Even having e.g. sin(x) and cos(x) etc. occurring only linearly is painful enough that I'm going to punt on it.
18:00:55 <conal> does anyone have a handy example of a .cabal file that provides .h files to other packages?  i guess i'm doing something wrong.
18:01:09 <mauke> e.g. number = liftM read (many1 digit) <* whitespace
18:01:11 <gwern> to other packages? can't say I've ever heard of anyone doing that
18:03:48 <gwern> 'When I first approached Haskell, I was shocked at the amount of syntax I saw. Operators abounded – more even than C – like: ->, =>, ::, $, $!, etc, etc. The more I looked, the more operators there seemed to be, until I began feel as lost as when I read Perl code.' <-- ouch
18:04:05 <conal> i like what comes next.
18:04:30 <gwern> the macros or the 'haskell can look like fingernails-in-oatmeal^W^W^Wlisp as well'?
18:05:00 <wli> pumpkin: What I have thus far is messy and I'll probably start over from the ground up.
18:05:04 <wli> pumpkin: http://wli.pastebin.com/m4b420d00
18:05:17 <pumpkin> I do that quite often, once I figure something out
18:06:39 <pumpkin> wow, there's a lot of code :)
18:06:54 <wli> I've got a long series of data structures where I progressively narrow down how the expression is constructed and transform it over and over again.
18:08:48 <wli> I got it down to a sum of products of constants times univariate monomials times surds.
18:09:31 <mauke> now you're just making up words
18:09:35 <wli> More specifically, numerator and denominators being integer linear combinations of monomials times products of surds.
18:10:16 <pumpkin> lol
18:10:26 <pumpkin> how ab-surd!
18:10:51 <pumpkin> :)
18:11:26 <gwern> hee hee. sussman in the video is chalking up 5 or so closing parentheses, stops, considers, and has to erase one
18:11:39 <gwern> easy to parse for machines, not so good for humans...
18:12:24 <pumpkin> I was surprised by my scheme prof being able to write parens without doing that
18:12:39 <pumpkin> I guess lots of practice allows you to keep some sort of subconscious nesting counter
18:12:52 <gwern> maybe he just follows the indentation
18:13:28 <mauke> there's an easy trick: put each ) in its own line/indentation level
18:13:46 <mmorrow> wli: i attempted to fix LPS to build with current ghc, and got it to compile (EPIC class conflict hell), but now all the (only tried .il progs) seem to blow the haskell stack when i run them. http://moonpatio.com/repos/MISC/LPS-090314/
18:13:48 <pumpkin> yeah, but he was writing on the board and didn't have that much space
18:14:19 <Botje> the trick is to look at each of the opening parens in turn when closing them
18:14:25 <mmorrow> with all the overlapping instances and class debauchery going on there i pity the person that has to figure out what's happening
18:14:47 <JuanDaugherty> *fool
18:14:51 <mmorrow> hehe
18:15:25 <gwern> (mit's classrooms have comfy looking chairs)
18:15:34 <pumpkin> OH NO, NOT THE COMFY CHAIR
18:15:48 <idnar> Botje: yeah, but you have to exclude already-closed parens
18:16:02 <Gracenotes> gwern: you've been there often?
18:16:13 * Gracenotes is trying to recall the context in which you and MIT are related...
18:16:16 <gwern> Gracenotes: no, I'm watching the sicp video
18:16:30 <gwern> I've *been* to mit once, but I didn't actually poke my head in any of the classrooms
18:16:43 <JuanDaugherty> gwern, Gracenotes: are you the same-named individuals from #wikipedia?
18:16:57 <wli> mmorrow: Yeah, it's bitrotted badly.
18:16:58 <gwern> JuanDaugherty: no, the #wikipedia are our stalkers
18:16:59 <Gracenotes> I am, but I can't vouch for gwern!
18:17:08 <gwern> JuanDaugherty: we keep complaining to freenode, but they're on the take
18:17:08 <mauke> http://farm1.static.flickr.com/52/171946298_31988a2d82.jpg
18:17:12 <mmorrow> that repo i linked to builds with 6.10.1 at least
18:17:19 <JuanDaugherty> that's what I thought. What lang is "gwern", finnish?
18:17:22 <pumpkin> mauke: lol
18:17:27 <Gracenotes> gwern: I think the video-taping may have something to do with it
18:17:28 <gwern> JuanDaugherty: welsh
18:17:31 <mmorrow> wli: (using the Makefile i added)
18:17:32 <JuanDaugherty> ah
18:17:42 <pumpkin> cymru?
18:17:46 <gwern> Gracenotes: you think they picked the nicest classroom?
18:17:50 <wli> Wales
18:17:51 <Gracenotes> gwern: not to mention the impeccably 80s-style hair and dress of the students.
18:18:07 <mmorrow> wli: the interp works fine, but the (four) .il progs i tried to exec all blew the haskell stack
18:18:26 <gwern> Gracenotes: although I'm still wondering what's with the bach midi and the nametags on everyone's tables
18:18:35 <Gracenotes> oh god, the bach midi :/
18:18:36 <mmorrow> so i suspect it's some instance being chosen for who-knows-what that isn't the one that the author intended to be chosen
18:18:44 <pumpkin> bach midi ftw
18:18:46 <mmorrow> (Overlapping + Undecidable Instances)(
18:18:54 <pumpkin> I want my complete bach works on midi back
18:19:04 <gwern> ick
18:19:06 <mmorrow> and the entire thing is a tangle of class instances..
18:19:07 <pumpkin> mmorrow: sounds like fail to me
18:19:22 <mmorrow> i was cursing like a sailor while trying to get it built :)
18:19:23 <Gracenotes> anyway, from this I've concluded that the school was armed in advance with the knowledge that someone would be video-taping the course
18:19:24 <gwern> pumpkin: I'll give you my 16gigs of real complete bach if you never suggest that again
18:19:33 <pumpkin> gwern: I'll take it :D
18:19:45 <pumpkin> ;)
18:19:49 <JuanDaugherty> complete? Every single BWV?
18:19:54 <pumpkin> I can give you complete beethoven in exchange
18:19:56 <gwern> believe so
18:20:08 <pumpkin> decent performers?
18:20:08 <gwern> alas, I no longer have the diskspace for a complete beethoven
18:20:11 <pumpkin> aw
18:20:15 <pumpkin> it's lossless, too :P
18:20:19 <pumpkin> took me ages to rip 87 cds
18:20:27 <Gracenotes> library?
18:20:43 <pumpkin> let's just pretend I bought the complete beethoven edition :P
18:20:45 <gwern> pumpkin: lossless is irrelevant to me, actually. I lack the hearing to discern the difference
18:20:48 <pumpkin> (but yeah)
18:21:07 <pumpkin> gwern: same :) but it makes me feel warm and fuzzy to have it lossless, when disk space is so cheap
18:21:41 <idnar> it's mostly a matter of audio equipment, not hearing
18:21:42 * gwern actually meant I am physically unable to hear the difference, not merely not sophisticated enough
18:21:57 <idnar> although obviously your hearing puts an upper bound on things too
18:22:08 <Gracenotes> gwern: hm. are you tone deaf?
18:22:11 <idnar> but if you've got lossless audio, then you don't need to care
18:22:18 <wli> mmorrow: There may or may not be brute-force methods of accomplishing what overapping instances does.
18:22:29 <gwern> Gracenotes: close - more that I'm half-deaf :)
18:22:34 <Gracenotes> gwern: obviously tone deaf != deafness
18:22:34 <pumpkin> no amount of audio equipment will let you hear the difference between a 256 kbps mp3 and lossless :P the audiophile shops with 20k power cables and 1k wooden knobs would have you believe otherwise
18:22:49 <idnar> pumpkin: that depends a lot on what the audio is
18:22:51 <pumpkin> I just keep lossless cause I can, not because I think one day I'll be able to hear it
18:23:04 <Philippa_> pumpkin: I know someone who reckons he can hear the filter bank involved
18:23:04 <Gracenotes> gwern: hm, accident? congenital?
18:23:10 <gwern> Gracenotes: latter
18:23:11 <idnar> pumpkin: MP3 encoding introduces certain audio artifacts at any bitrate, which are actually quite easily noticeable in some kinds of music, and completely imperceptible in others
18:23:16 <Philippa_> if so, there's no bitrate that'll undo it
18:23:17 <gwern> (both lectures so far have been sussman... wonder when abelson will show up)
18:23:18 <Gracenotes> ah
18:23:22 <Philippa_> idnar: exactly
18:23:25 <pumpkin> idnar: that's true actually :)
18:23:33 <Gracenotes> gwern: they switch every two lectures, I think
18:23:37 <idnar> pumpkin: of course, more people listen to Britney Spears than to Autechre, so...
18:23:39 <pumpkin> lol
18:23:42 <Philippa_> AAC doesn't, however
18:23:44 <pumpkin> most of my music is classical
18:23:50 <gwern> hmm hmm. guess I'll find out next weekend when I tackle chapter 2
18:23:56 <mmorrow> wli: in the last few months i've grown to not like type classes very much (in that i only use them in 2 situations ever) (not talking about Monad, Functor, the like either)
18:23:59 <pumpkin> the rest is psytrance and SOAD :P
18:24:10 <gwern> it's interesting how the lectures cover different material from the book
18:24:31 <mmorrow> (i use a class to pretty printing a particular AST, and a class to translating a massive AST to another massive AST)
18:24:38 <mmorrow> and pretty much only those two cases
18:24:42 <gwern> for exmapl,e this peano-addition-in-constant-space - nowhere in chapter 1
18:24:43 <Gracenotes> you mean, different language? :)
18:25:10 <bjorkintosh> What I didn’t realize is that in Haskell, much of the syntax you see are just special function names. There is very little “true” syntax going on; the rest is built on top of a highly expressive core.
18:25:16 <gwern> auughh, he's doing fibonacci ><
18:25:19 <bjorkintosh> what is this 'highly expressive core' from that article?
18:25:28 <bjorkintosh> http://www.newartisans.com/2009/03/hello-haskell-goodbye-lisp.html
18:25:33 <gwern> bjorkintosh: functiona pplication, case expressions, basically
18:25:46 <bjorkintosh> how small is this core?
18:26:12 <Gracenotes> naive Fibonacci -- a superior demonstration of the capabilities of recursion!
18:26:15 <gwern> bjorkintosh: the [x | x<-[1..]] list comps? desugar into calls to filter function etc. guards? desguar into nested if-then-elses. do-notation? down to >> >>= functiona calls etc.
18:26:29 <bjorkintosh> alright.
18:26:38 <bjorkintosh> i'd like to find this unsweetened version of haskell.
18:27:10 <gwern> `infix`? down to prefix function (ie 1 `(+)` 2 -> (+) 1 2 and so on
18:27:10 <Gracenotes> gwern: hm, it seems peano has been delegated to an exercise, http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.1
18:27:25 <bjorkintosh> oh that book again.
18:27:34 <bjorkintosh> Gracenotes. it'll destroy your mind!
18:27:38 <wli> gwern: I'm so sick of Fibonacci.
18:27:46 <Gracenotes> bjorkintosh: dare you insult the Sussman?
18:27:50 <gwern> bjorkintosh: I don't think there really is any, except maybe the haskell '98 report has to describe how to desugar? there's ghc core, but I dunno whether that's desugared
18:27:54 <bjorkintosh> and the abelson too, yes.
18:28:18 <bjorkintosh> haskell '98 report.
18:28:18 <bjorkintosh> okay.
18:28:24 <Gracenotes> nooo! The Sussman shall cast a spell on you! The power of wistful thinking shall smite you!
18:28:31 <bjorkintosh> pfft.
18:28:37 <bjorkintosh> i aim never to be a great programmer.
18:28:43 <bjorkintosh> sussman can **** my *** ***
18:28:43 <gwern> hmmm... I'm confused. I've been calling 1.1 chapter 1, but it seems this is wrong
18:28:49 <mauke> THE ANTICUDDER
18:28:53 <Gracenotes> gwern: I was confused by this at first as well
18:29:01 <gwern> mauke: channeling 4ch again?
18:29:06 <gwern> maybe I'll just call it section 1 chapter 1...
18:29:14 <wli> gwern: I don't really want to go through the pain of micro-optimizing my Fibonacci function to compete with people.
18:29:32 <gwern> wli: pardon?
18:29:34 <Gracenotes> yeah, I'm still banned from prog :/
18:29:46 <wli> gwern: How/why I'm sick of Fibonacci.
18:29:47 <gwern> Gracenotes: did you post unevaluated-function pron?
18:29:53 <mauke> Gracenotes: haha, how did you do that?
18:30:01 <Gracenotes> unsophisticated spam filter
18:30:07 <gwern> wli: where were you competing for the fast fibonacci? :/
18:30:11 <defun> is hs-plugins dead? will it ever be cabalized?
18:30:15 <dons> ?
18:30:23 <dons> it's been on hackage since 2006...
18:30:28 <gwern> defun: it's cabalized, dead, and essentially superseded by hint
18:30:34 <defun> one sec.
18:30:37 <dons> i believe it was the second hackage package?
18:30:39 <Gracenotes> mauke: you too can post innocuous URLs and be banned!
18:30:45 <wli> gwern: I'm sort of the current title-holder.
18:31:00 <dons> gwern: hmm. i'm not sure hint provides object code loading support, does it? you mean specifically the eval mechanism?
18:31:00 <gwern> dons: surely it wasn't that early?
18:31:09 <dons> it was one of our first test packages
18:31:19 <gwern> dons: well, people rarely seem to use the object code loading
18:31:21 <bjorkintosh> alright. i'll go look at the report.
18:31:27 <dons> Sun Sep 24 19:15:00 UTC 2006 IsaacJones plugins 1.0
18:31:29 <mauke> Gracenotes: I prefer to post stupid code snippets
18:31:30 <defun> it was stored as "plugins" instead of "hs-plugins".
18:31:31 <gwern> everyone I've heard looking for hint in like the past year has been looking for eval
18:31:33 <dons> gwern: but its a distinct capability
18:31:41 <dons> and one that isn't subsumed
18:31:52 <dons> the eval mechanism is gladly replaced by a bytecode interpreter + ghci
18:31:56 <dons> ghc-api, i mean
18:32:02 <mmorrow> bjorkintosh: also, since you can make new Monads, and monads have the special "do" notation (and since you can define new "operators"), this goes a really long way in being able to create mini embedded syntaxes
18:32:18 <dons> gwern: sure. however, if you need plugins, hint doesn't help.
18:32:21 <Gracenotes> mauke: well, too much haxxing is no good for the brain
18:32:24 <dons> and sometimes we need plugins.
18:32:24 <gwern> according to http://hackage.haskell.org/packages/archive/log hs-plugins was #12
18:32:39 <Heffalump> pumpkin/anyone else who might be interested: I made a mailing list for rmonad: http://projects.haskell.org/cgi-bin/mailman/listinfo/rmonad
18:32:40 <bjorkintosh> i'm surprised there isn't a lisp-syntax version of haskell yet.
18:32:45 <gwern> noooo - now sussman is doing towers of hanoi!
18:32:46 <Gracenotes> there is
18:32:46 <dons> bjorkintosh: there is.
18:32:47 <gwern> bjorkintosh: liskell
18:32:49 <dons> just no one uses it :)
18:32:49 <bjorkintosh> that slimy language...
18:32:51 <pumpkin> yay
18:32:53 <gwern> @where liskell
18:32:53 <idnar> what's rmonad?
18:32:53 <lambdabot> http://clemens.endorphin.org/liskell
18:33:03 <pumpkin> I'm rmonad's greatest fan!
18:33:04 <pumpkin> :P
18:33:14 <Heffalump> a restricted monads package (it's on hackage with that name)
18:33:30 <Gracenotes> pumpkin: psssh, says you. RMonad signed my stomach once
18:33:33 <idnar> oh, right; it sounded like something to do with xmonad
18:33:43 <gwern> points for having a physical towers of hanoi set, though...
18:33:43 <dons> heh
18:33:44 <pumpkin> Gracenotes: omg so jealous
18:33:50 <Heffalump> nope, it actually has something very specific to do with monads, unlike xmonad :-)
18:34:00 <bjorkintosh> very interesting.
18:34:11 <Heffalump> pumpkin: hey, *I* wrote it :-)
18:34:20 <Gracenotes> RMonad would sound like a promising name for a rapper, if not for the similar to "gonad"
18:34:29 <Gracenotes> +ity
18:34:35 <wli> bbiaw headed to hospice
18:34:37 <idnar> Gracenotes: "if not for"? surely that makes it even more suitable?
18:34:40 <bjorkintosh> what sort of nerdy rapper will pick such a name?
18:34:53 <Heffalump> bjorkintosh: what, like "bjorkintosh"?
18:34:57 <bjorkintosh>  :|
18:34:57 <pumpkin> Heffalump: sorry, you don't have the autograph on your stomach, Gracenotes is cooler
18:35:00 <bjorkintosh> shush!
18:35:11 <bjorkintosh> oh i'm not a nerd btw.
18:35:15 <bjorkintosh> just to set the record straight.
18:35:15 <pumpkin> :o
18:35:17 <gwern> redorkulous!
18:35:18 <Heffalump> pumpkin: oh ok then
18:35:18 <bjorkintosh> so ... yeah.
18:35:39 <pumpkin> Heffalump: but I do suppose you could actually put an autograph on your own stomach, so hmm
18:35:39 <gwern> you're in #haskell, you read tech blogs, you have a nick like bjorkintosh... I find your assertion officially redorkulous
18:35:48 <pumpkin> redonkulous
18:35:54 <Heffalump> pumpkin: I considered pointing that out, but since I don't actually want to do that I decided not to
18:36:00 <pumpkin> ah
18:36:01 <idnar> gwern: that makes him a geek, not a nerd
18:36:07 <defun> does xmonad use hs-plugins to load config files?
18:36:10 <Gracenotes> pumpkin: er, I should probably mention that 'stomach' is the name of one of my machines and that RMonad gave me an SSL certificate. Still !!
18:36:14 <gwern> idnar: I deny your definitions
18:36:16 <gwern> defun: no
18:36:17 <bjorkintosh> i'm here by accident. i just want to find that tiny core of haskell.
18:36:20 <bjorkintosh> and then i'll be off.
18:36:31 <bjorkintosh> oh . i see the '98 language report is done d/ling
18:36:35 <defun> then what is used? is it a lib, or is it in xmonad.
18:36:41 <gwern> well if you want the academic name, the polymorphic typed calculus, or perhaps system F
18:36:56 <bjorkintosh> system F?
18:36:57 <Heffalump> pumpkin: I'm adding monad transformers to it atm
18:37:02 <pumpkin> ooh, nice
18:37:05 <Gracenotes> we also have higher-ranked polymorphism
18:37:09 <Gracenotes> available as GHC extensions
18:37:16 <bjorkintosh> inneresting.
18:37:28 <pumpkin> it's a neat idea, I'd given up on being able to do restricted monads
18:37:30 <gwern> defun: it's in xmonad. it's an neat idea - the global xmonad state can be serialized to disk, then xmonad calls ghc compile on the config file, and runs the new result (replacing itself, and handing the global state over to the new xmonad0
18:37:45 <gwern> defun: there're research papers that describe this idea
18:37:53 <defun> where?
18:38:06 <bjorkintosh> very very nice.
18:38:08 <bjorkintosh> thank you.
18:38:22 <bjorkintosh> i don't want to be associated with nerds, since i'm not one. so i'll be off now.
18:38:25 <bjorkintosh> ta ta :)
18:38:33 <gwern> what a strange fellow
18:38:40 <defun> indeed
18:38:47 <idnar> oh noes, I'm going to get nerd cooties!!!11
18:38:59 <Heffalump> you think he was actually serious about that?
18:39:00 * gwern administers the vaccine to idnar 
18:39:33 <gwern> Heffalump: I enjoy dog biscuits with my tea. I'd credit his fear of social taint
18:39:42 <mmorrow> ooh, sweetness. a new release of harpy
18:40:08 <idnar> Heffalump: I couldn't tell
18:40:13 <pumpkin> mmorrow: still doesn't fix my complaints with the disassembler, but I suppose if I don't tell the author what I don't like, he's unlikely to fix it, eh
18:40:19 <dons> have the llvm bindings killed harpy?
18:40:26 <Heffalump> I was about to ask the same thing
18:40:27 <TomMD> Does anyone know how packages like harpy and llvm deal with NX protections?  Do you just have to disable them?
18:40:30 <dons> pumpkin: it is so not worth talking to ayrnieu, btw
18:40:35 <JuanDaugherty> "nerd" and "geek" seem to have become terms referring to someone who has a life of the mind
18:40:44 <pumpkin> dons: ah, I don't know of reputations on reddit yet, ok :)
18:40:47 <dons> he will glue you down in wandering passages of verbosity with little point at the end
18:40:57 <gwern> JuanDaugherty: nah. I've never heard o anyone calling, say, Daniel dennet a nerd or geek
18:40:58 <dons> and you'll wonder why you wasted the effort
18:41:07 <pumpkin> but someone is wrong on the internet! :P
18:41:11 <dons> yeah!
18:41:13 <mmorrow> pumpkin: yeah, if i were going to write an assembler/disassembler i'd probably start from scratch instead of use harpy's code as a start
18:41:15 <dons> there always is.
18:41:15 <gwern> (nerds and geeks are too associated with technical matters)
18:41:26 <Gracenotes> hm... isn't Grieg's Violin Sonata 1 *anywhere* on the internet? :(
18:41:35 <idnar> someone should write a web 2.0 assembler called "assemblr"
18:41:44 <gwern> dons: delusions are endless; I vow to dissolve them all. sentient beings are numberless; I vow to save them all...
18:41:47 <mauke> .oO( foldr )
18:41:56 <pumpkin> Gracenotes: Grieg isn't one of those ones that people looking for easy listening find, other than "Morning mood" or "hall of the mountain king"
18:41:59 <idnar> Gracenotes: everything is on the internet; but I don't happen to know where that particular thing is right now :P
18:42:05 <JuanDaugherty> people who use that term would definitely apply it to Dennet or any other intellectual
18:42:10 <Axman6> well i'm kinda happy. my prime number finder found the 100,000,000th prime number in 102m47.952s
18:42:13 <dons> gwern: let me know how that goes :)
18:42:21 <mauke> the important question is, is there any *porn* of Grieg?
18:42:21 <pumpkin> Axman6: wow
18:42:27 <pumpkin> mauke: I'm sure
18:42:28 <idnar> Axman6: oh wow, I didn't even know the 100,000,000th prime number was missing
18:42:36 <pumpkin> someone postulated there was no pumpkin porn when he saw my nick
18:42:38 <idnar> Axman6: did it get hurt badly?
18:42:38 <pumpkin> he was wrong
18:42:50 <gwern> the 100,000,000th prime: 'Hey, I wasn't missing - I was right here all along'
18:42:53 <idnar> pumpkin: rule 34
18:42:53 <Gracenotes> pumpkin: it's hardly easily listening, but it's so fun :)
18:43:11 <pumpkin> mauke: append -porn.com to my nick :)
18:43:13 <Gracenotes> must. find. (!!)
18:43:25 <Axman6> idnar: nah it was fine, car broke down
18:43:26 <Gracenotes> ^ not function composition
18:43:28 <gwern> dons: :( sometimes I think I should knock off the religious & philosophical allusions here, since the xkcd ones are received with so much more approbation
18:43:32 <idnar> "If it exists, there is porn of it. No exceptions."
18:43:44 <Gracenotes> @type ?must . ?find . (!!)
18:43:45 <lambdabot> forall c c1 a. (?find::(Int -> a) -> c1, ?must::c1 -> c) => [a] -> c
18:44:24 <pumpkin> anyone up for the pumpkin-djinn challenge? :P
18:45:02 <Gracenotes> pumpkin, what now? :3
18:45:13 <Olathe> @type ?a . ?b . ?c
18:45:14 <lambdabot> forall c b c1 a. (?c::a -> b, ?b::b -> c1, ?a::c1 -> c) => a -> c
18:45:15 <pumpkin> same one I had yesterday
18:45:22 <gwern> 'It's the Great Coercion, Charlie Brown!' 'But linus, you know there's no such function as :: a -> b, right?' 'If I have faith, he'll come on Halloween and reward me!'
18:45:48 <Gracenotes> and what was that?
18:45:49 <pumpkin> to come up with a definition and a meaningful explanation of ((a, b) -> (c, b)) -> a -> c
18:46:53 <mauke> :t \f a -> let (c, b) = f (a, b) in c
18:46:54 <lambdabot> forall t t1 t2. ((t, t2) -> (t1, t2)) -> t -> t1
18:46:59 <Gracenotes> aha! It is on the internet after all, Amazon
18:47:08 <gwern> hm, doesn't that simplify to (a -> c) -> a -> c?
18:47:42 <pumpkin> mauke: now for "wtf" bit :)
18:47:56 <gwern> (since the b can be undefined looks like)
18:48:07 <Gracenotes> @djinn ((a, b) -> (c, b)) -> a -> c -- o nos
18:48:08 <lambdabot> Cannot parse command
18:48:10 <pumpkin> gwern: pretty much
18:48:14 <Gracenotes> o nos
18:48:16 <Gracenotes> @djinn ((a, b) -> (c, b)) -> a -> c
18:48:16 <lambdabot> -- f cannot be realized.
18:48:18 <Gracenotes> o nos
18:48:37 <Olathe> @type f (***) id
18:48:38 <lambdabot>     No instances for (Test.SmallCheck.Serial (a b c),
18:48:38 <lambdabot>                       Show (a b c),
18:48:38 <lambdabot>                       Test.SmallCheck.Serial (a b' c'),
18:48:43 <Olathe> O...K
18:48:45 <pumpkin> :o
18:48:51 <pumpkin> smallcheck defines ***?
18:48:52 <Olathe> @type f *** id
18:48:53 <lambdabot> forall b c a. (SimpleReflect.FromExpr c, Show b) => (b, a) -> (c, a)
18:48:58 <pumpkin> oh
18:49:05 <Olathe> @type fst . f *** id
18:49:06 <lambdabot> forall a b a1 b'. (SimpleReflect.FromExpr (a, b), Show a1) => (a1, b') -> (a, b')
18:49:18 <Olathe> @type fst . (f *** id)
18:49:19 <lambdabot> forall b c b'. (SimpleReflect.FromExpr c, Show b) => (b, b') -> c
18:49:26 <Axman6> :t fst . ?f *** id
18:49:27 <lambdabot> forall a b a1 b'. (?f::a1 -> (a, b)) => (a1, b') -> (a, b')
18:49:35 <mmorrow> @type \f a -> let (c, b) = f (a, b) in c
18:49:35 <Olathe> @type \f -> fst . (f *** id)
18:49:36 <lambdabot> forall t t1 t2. ((t, t2) -> (t1, t2)) -> t -> t1
18:49:36 <lambdabot> forall b c b'. (b -> c) -> (b, b') -> c
18:50:22 <Olathe> @pl \f a -> let (c, b) = f (a, b) in c
18:50:22 <lambdabot> (line 1, column 13):
18:50:22 <lambdabot> unexpected "("
18:50:22 <lambdabot> expecting "()", natural, identifier or "in"
18:50:30 <mmorrow> @let feedback f a = let (c, b) = f (a, b) in c
18:50:31 <lambdabot>  Defined.
18:51:16 <pumpkin> so it's for the case in which you have a function that operates on a pair and you can't decompose it, but you don't want the snd?
18:51:44 <pumpkin> > feedback ((+1) *** (+2)) 5
18:51:45 <lambdabot>   6
18:52:07 <pumpkin> > loop ((+1) *** (+2)) 5
18:52:08 <lambdabot>   6
18:52:37 <pumpkin> I'm still looking for non-contrived examples of its use though
18:53:21 <mmorrow> > feedback (\(a,b) -> (take 10 b, a:b)) 0
18:53:22 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
18:53:36 <Axman6> > loop (\(a,b) -> (b,a)) 1
18:53:37 <lambdabot>   1
18:53:41 <Axman6> o.O
18:53:52 <pumpkin> > loop (\(a,b) -> (take 10 b, a:b)) 0
18:53:53 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
18:53:59 <pumpkin> wow
18:54:11 <Olathe> @type \f -> fst . f . (flip (,) undefined)
18:54:11 <Axman6> demon function!
18:54:12 <lambdabot> forall a b a1 b1. ((a1, b1) -> (a, b)) -> a1 -> a
18:54:18 <pumpkin> so it's half fix
18:54:24 <pumpkin> half first
18:54:25 <Olathe> @pl \f -> fst . f . (flip (,) undefined)
18:54:25 <lambdabot> (fst .) . (. flip (,) undefined)
18:54:28 <pumpkin> sort of
18:54:37 <mauke> :t \f a -> fst $ fix (\(_, b) -> f (a, b))
18:54:38 <lambdabot> forall t a b. ((t, b) -> (a, b)) -> t -> a
18:54:46 <mauke> @pl \f a -> fst $ fix (\(_, b) -> f (a, b))
18:54:46 <lambdabot> ((fst . fix) .) . flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (,)) . (.)
18:54:51 <pumpkin> ew
18:55:11 <mmorrow> @pl \f a -> let (c, b) = f (a, b) in c
18:55:11 <lambdabot> (line 1, column 13):
18:55:12 <lambdabot> unexpected "("
18:55:12 <lambdabot> expecting "()", natural, identifier or "in"
18:55:16 <Olathe> @type \f -> fst . ?f . (flip (,) undefined)
18:55:17 <lambdabot> forall t a b a1 b1. (?f::(a1, b1) -> (a, b)) => t -> a1 -> a
18:55:38 <pumpkin> alright, I think I finally get it, although my brain is in a knot right now
18:55:50 <mmorrow> pumpkin: good, because that's what it ties!
18:55:52 <pumpkin> although I'm still trying to think of real situations where you'd use it
18:56:20 <maurer1> Does anyone know a good way to get zipWith over arrays?
18:56:21 <pumpkin> I guess any situation where you use *** as I did above is too boring for it to be worthwhile
18:56:30 <mauke> @pl \f a -> fst . fix $ f . first (const a)
18:56:30 <lambdabot> ((fst . fix) .) . (. (first . const)) . (.)
18:56:37 <mauke> :t \f a -> fst . fix $ f . first (const a)
18:56:38 <lambdabot> forall a b a1. ((a1, b) -> (a, b)) -> a1 -> a
18:56:59 <maurer1> I could just elems it first, but this would be slow due to an extra copy in and out
18:57:03 <Gracenotes> hm... I forgot which symphony movement I wanted to purchase :(
18:57:12 <pumpkin> Gracenotes: epic fail
18:57:13 <mauke> @unpl ((fst . fix) .) . (. (first . const)) . (.)
18:57:13 <lambdabot> (\ i u -> fst (fix (\ f -> i (first (\ _ -> u) f))))
18:57:45 <Gracenotes> pumpkin: epic fail for the underscore doppelganger
18:57:58 <Gracenotes> ah well. I just pick one.
18:57:58 <pumpkin> huh?
18:58:12 <Gracenotes> You know who I'm talking. pumpkin_, the shady character in the corner.
18:58:13 <bjorkintosh> mmm. so is system F related to martin-lof's type theory (whoevver he is?)
18:58:15 <Gracenotes> +about
18:59:05 <bjorkintosh> i'm beginning to think there're SEVERAL (up to a bazillion - 1) type theories out there.
18:59:39 <pumpkin> Heffalump: given that we're the only two subscribers to your rmonad list, maybe it'd be worth posting to cafe about it?
18:59:48 <pumpkin> bjorkintosh: aren't you too cool for us?
19:00:07 <pumpkin> there are actually a bazillion and 3 type theores out there though
19:00:26 <bjorkintosh> nooo. nothing to do with coolness, i assure you.
19:00:34 <Heffalump> pumpkin: I might, or I might put a note in the description in the next release
19:00:44 <Gracenotes> > intercalate ", " $ map (("rank-"++).(++" polymorphism").show) [0..]
19:00:45 <lambdabot>   "rank-0 polymorphism, rank-1 polymorphism, rank-2 polymorphism, rank-3 poly...
19:00:57 <Gracenotes> aww. So many type systems, so little space.
19:01:08 <Heffalump> it's just that a few people have contacted me about it separately, so it seemed to make sense to centralise the communication
19:01:13 <bjorkintosh> i'm just not a monocole wearing, vest and top hat dandy categorical theorist is all.
19:01:18 <pumpkin> Heffalump: have you ever announced rmonad publicly? no one I've tried evangelizing it to has heard of it, and it seems a pity
19:01:34 <Heffalump> not really
19:01:38 <Heffalump> I should, you're right
19:02:24 <Axman6> > map (("rank-"++).(++" polymorphism, ").show) [0..]
19:02:26 <lambdabot>   ["rank-0 polymorphism, ","rank-1 polymorphism, ","rank-2 polymorphism, ","r...
19:02:30 <pumpkin> :)
19:02:32 <Axman6> bleh, of course
19:02:38 <Axman6> > concatMap (("rank-"++).(++" polymorphism, ").show) [0..]
19:02:39 <lambdabot>   "rank-0 polymorphism, rank-1 polymorphism, rank-2 polymorphism, rank-3 poly...
19:02:46 <pumpkin> we need an easy way to do string interpolation in haskell
19:03:09 <mauke> printf!
19:03:15 <pumpkin> even easier!
19:03:22 <Gracenotes> Axman6: well, you'll have an extra ", " when you reach the end ;)
19:03:29 <Axman6> :P
19:03:30 <bjorkintosh> printf of C fame?
19:03:36 <pumpkin> [$i|hello I am a string #{var1}-#{var2}|]
19:03:56 <Axman6> , [$i|hello I am a string #{var1}-#{var2}|]
19:03:59 <lunabot>  luna: applicateQ fails.
19:04:06 <pumpkin> seems simple enough to transform that to "hello I am a string " ++ (show var1) ++ "-" ++ (show var2)
19:04:44 <mmorrow> , [$i|(,,,,) "asd" "fgh" "qwer" "rtyu" [0..]|]
19:04:46 <lunabot>  [('a','f','q','r',0),('a','f','q','r',1),('a','f','q','r',2),('a','f','q'...
19:04:52 <mauke> > concatMap (printf "rank-%d polymorphism, ") [0 ..]
19:04:52 <lambdabot>   Add a type signature
19:04:59 <mauke> > concatMap (printf "rank-%d polymorphism, ") [0 ..] :: String
19:05:00 <lambdabot>   "rank-0 polymorphism, rank-1 polymorphism, rank-2 polymorphism, rank-3 poly...
19:05:02 <pumpkin> oh my
19:05:17 <mmorrow> , concatMap $(printf "rank-%d polymorphism, ") [0 ..]
19:05:20 <lunabot>  "rank-0 polymorphism, rank-1 polymorphism, rank-2 polymorphism, rank-3 po...
19:05:38 <pumpkin> printf is no fun though!
19:05:45 <pumpkin> I want ruby-like string interpolation wah wah wah
19:05:51 <pumpkin> :P
19:06:01 <Gracenotes> no, heathen! pointless string manipulation is as god intended!
19:06:12 <mmorrow> , [$here|hello I am a string $([0..9])|]
19:06:14 <lunabot>  "hello I am a string [0,1,2,3,4,5,6,7,8,9]"
19:06:24 <mmorrow> :)
19:06:33 <pumpkin> mmorrow: almost what I want, except here is too long :P
19:06:55 <pumpkin> and I can't stick outer variables in there can I?
19:06:58 <Gracenotes> @pl \a b c -> a ++ ": " ++ map show b ++ " in " ++ show c
19:06:59 <lambdabot> (. (((": " ++) .) . (. ((" in " ++) . show)) . (++) . map show)) . (.) . (++)
19:07:10 <mmorrow> , let xs = [0..9] in [$here|hello I am a string $(xs)|]
19:07:12 <lunabot>  "hello I am a string [0,1,2,3,4,5,6,7,8,9]"
19:07:15 <pumpkin> , let x = 5 in [$here|hello I am a string and x is $(x)]
19:07:16 <lunabot>  luna: lexical error in string/character literal at end of input
19:07:19 <pumpkin> oh
19:07:21 <pumpkin> , let x = 5 in [$here|hello I am a string and x is $(x)|]
19:07:22 <Gracenotes> no ur not!
19:07:23 <lunabot>  "hello I am a string and x is 5"
19:07:34 <pumpkin> mmorrow: so my only complaint is that here is too much typing ;)
19:07:37 <pumpkin> but that's awesome
19:07:48 <mmorrow> then cvhange the name of the QQ to what you like :)
19:07:51 <pumpkin> did you write here, or is available elsewhere?
19:07:55 <mmorrow> i'll paste it
19:07:58 <pumpkin> whee
19:08:01 <mmorrow> (< 100 lines)
19:08:27 <Gracenotes> , let x = "this" in [$here|mmorrow is god and there is none beside him, also quotes are handled like $(x)|]
19:08:29 <lunabot>  "mmorrow is god and there is none beside him, also quotes are handled lik...
19:08:33 <Gracenotes> :(
19:08:40 <pumpkin> fail
19:08:41 <Gracenotes> , let x = "this" in [$here|blah $(x) blah|]
19:08:44 <lunabot>  "blah \"this\" blah"
19:08:51 <Gracenotes> :x
19:09:55 <Gracenotes> is there a string-showing utility?
19:09:56 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1898#a1898
19:10:03 <Gracenotes> or just Showable? :)
19:10:06 <Gracenotes> *Show
19:10:18 <pumpkin> nice
19:10:21 <mmorrow> , let x = text "here" in [$here|blah $(x) blah|]
19:10:23 <lunabot>  "blah here blah"
19:10:35 <Gracenotes> ah, I see. prettyprinting
19:10:48 <pumpkin> , let x = "here" in [$here|blah $(text x) blah|]
19:10:48 <mmorrow> Gracenotes: it only calls `show' on the spliced value because i made it do that (for convenience)
19:10:50 <lunabot>  "blah here blah"
19:10:55 <mmorrow> you could just as easily not
19:11:29 <mmorrow> liftHere (CodeH e)  = [|show $(return e)|]
19:11:33 <mmorrow> is the relevant line
19:11:48 <Gracenotes> @type text
19:11:48 <pumpkin> ah
19:11:49 <lambdabot> String -> Doc
19:12:06 <mauke> , [$here|$(x)|]
19:12:08 <lunabot>  "x"
19:12:10 <mmorrow> Gracenotes: i just chose Doc because it shows Strings without the quotes
19:12:17 <mmorrow> , [$ty| x |]
19:12:20 <lunabot>  Expr
19:12:29 <mauke> , [$here|$(var "zomg")|]
19:12:31 <lunabot>  luna: Not in scope: `var'
19:20:17 <pumpkin> @index catch
19:20:17 <lambdabot> Control.Exception, System.IO.Error, Prelude
19:28:56 <pumpkin> @index unsafePerformIO
19:28:57 <lambdabot> System.IO.Unsafe, Foreign
19:32:49 <Gracenotes> whoa, converting my NFA for (hello|goodbye)* into DFA made something with 32768 states!
19:32:57 <Gracenotes> Some it call it failure... I call it awesome! :O
19:33:05 <Gracenotes> > logBase 2 32768
19:33:06 <lambdabot>   15.0
19:33:09 <jm> Is there a way to import only some data constructors from a module with "as"? My import looks like <<import MyModule as MM (MyModule)>>, and the error I receive when trying to use the constructor is <<Not in scope: data constructor `MyModule'>>
19:33:28 <Gracenotes> now, I just need to not number every single element of the powerset... :)
19:34:18 <pumpkin> Gracenotes: you mean you don't know your powers of two by heart??
19:34:26 <Gracenotes> *gasp*
19:34:28 <pumpkin> I know them _all_
19:34:32 <Gracenotes> indeed I do, I was merely demonstrating
19:34:51 <Gracenotes> quick, 2^539478
19:34:57 <pumpkin> duh
19:35:08 <dolio> Nope, wrong.
19:35:19 <pumpkin> it starts with 11481557714980160563513899826542667207459319, but I can't be bothered to type any more digits out, sry
19:35:28 <Gracenotes> that's okay. 2009th digit?
19:35:40 <pumpkin> I can't count digits in my head, silly
19:35:48 <Gracenotes> prime digits between 5000 and 6000?
19:36:00 <Gracenotes> I thought you said you knew your powers of two! pssh.
19:36:26 <Gracenotes> (prime meaning prime digit numbers)
19:37:10 <pumpkin> :o
19:37:17 <Gracenotes> o:
19:37:21 <pumpkin> you know some numbers
19:37:27 <pumpkin> but you can't pick arbitrary digits out in your head!
19:37:28 <pumpkin> silly
19:38:35 <pumpkin> anyone have a better name for shouldErrorIf2 ?
19:39:04 <Gracenotes> giveGracenotesAnswerForGivenPowerOfBase2
19:39:14 <pumpkin> :: Bool -> (a -> b -> Bool) -> a -> b -> Bool
19:39:33 <pumpkin> maybe I should make the first one be a bool too
19:39:35 <pumpkin> I mean, a function
19:39:58 <MyCatVerbs> pumpkin: everything is a damn function in that!
19:40:19 <pumpkin> I'm trying to write a quickcheck helper that allows me to say a given proposition should throw an error under certain conditions
19:40:37 <pumpkin> I wrote it, but it's ugly
19:40:51 <pumpkin> not proposition, but you know what I mean
19:41:25 <Gracenotes> what's the first Bool for?
19:41:41 <pumpkin> that's whether it's supposed to throw an error
19:41:45 <pumpkin> it should probably be a function
19:42:38 <Gracenotes> by 'throw an error', you mean return False?
19:42:43 <dolio> What kind of error?
19:42:49 <pumpkin> no, actually error "string"
19:43:05 <Gracenotes> o:
19:43:08 <dolio> There's some quickcheck alike that lets you talk about strictness and bottoms and stuff.
19:43:34 <dolio> That dons and dcoutts used to test the stream fusion library for conformance with H98 list functions, I think.
19:43:41 <pumpkin> hmm
19:43:55 <pumpkin> I thought the uvector testsuite was based on the stream fusion library's one
19:44:02 <pumpkin> and it seems to be regular quickcheck
19:44:09 <pumpkin> (that's what I'm adding to)
19:45:04 <dolio> http://www.cs.nott.ac.uk/~nad/software/ChasingBottoms/docs/
19:45:35 <pumpkin> interesting
19:46:03 <pumpkin> I'm just using catch to catch the error call
19:46:28 <mmorrow> <Gracenotes> whoa, converting my NFA for (hello|goodbye)* into DFA made something with 32768 states!
19:46:43 <mmorrow> Gracenotes: graphviz plz? kthx :)
19:47:02 <dolio> > 2^7
19:47:03 <lambdabot>   128
19:47:09 <dolio> > 2^15
19:47:10 <lambdabot>   32768
19:47:48 <Gracenotes> 6 for hello, 7 for goodbye, 1 for the union, 1 for the kleene
19:48:15 <Gracenotes> hm, 8 for goodbye? Lemme think.
19:48:37 <dolio> Seems like you could do better than that.
19:49:07 <Gracenotes> nope, 5 for hello, 6 for goodbye
19:50:23 <pumpkin> :t on
19:50:24 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:50:31 <Gracenotes> dolio: yes, this is just about making it work. My DFA representation is less than optimal :)
19:50:38 <dolio> :)
19:51:27 <Gracenotes> of course, 15 states is pretty good for (hello|goodbye)* as an NFA.
19:52:00 <Gracenotes> hm... *calculates*
19:55:14 <dolio> 0 <e- 12 <y- 11 <b- 10 <d- 9 <o- 8 <o- 7 <o- 6 <g- 0 -h> 1 -e> 2 -l> 3 -l> 4 -o> 0, accept on 0?
19:55:38 <dolio> Oops, I put too many 'o's in goodbye.
19:55:54 <davidL> anyone look at today's project euler problem?
19:56:04 <Axman6> nope, got a link?
19:56:10 <davidL> http://projecteuler.net/index.php?section=problems&id=236
19:56:12 <Axman6> haven't done any PE for a long time
19:56:43 <Gracenotes> dolio: ha! I have an interesting result for you.
19:56:47 <davidL> I'm wondering if the numbers in the table refer to ALL products, spoiled and nonspoiled, or just the nonspoiled
19:56:54 <Gracenotes> in converting the NFA to the DFA, 32768 states are produced
19:57:01 <Gracenotes> however, only 14 of those are reachable :D
19:57:05 <Gracenotes> > 14/32768
19:57:07 <lambdabot>   4.2724609375e-4
19:57:13 <pumpkin> o.O
19:57:45 <Gracenotes> the NFA-to-DFA translation makes a state for *every* powerset. I intend to rewrite it by only bothering with reachable
19:57:51 <Gracenotes> this clearly indicates why I should :D
19:58:01 <Gracenotes> s/powerset/element of the powerset/
19:58:31 <Axman6> davidL: heh, i wouldn't even know where to begin there :P
19:58:47 <davidL> it's a wordy problem
19:59:51 <dolio> Yes, well, converting that particular NFA to a DFA only requires adding one 'fail' state and transitions for all the disallowed letters.
20:00:03 <dolio> So it's obviously quite bad to take the power set.
20:00:44 <Gracenotes> I should try checking out the used size/powerset size for more complicated NFAs, now that I can do so
20:01:36 <Gracenotes> (the powerset size can be calculated almost instantly, but now that I have them all, I might as well)
20:02:51 <twb> dcoutts_: why does "cabal clean" keep telling me
20:02:51 <twb> Error while removing dist/: dist/setup: removeDirectory: unsatisified constraints (Directory not empty)
20:05:17 <Gracenotes> > 10/1024 :: CReal -- for (hey)*(hello)*
20:05:18 <lambdabot>   0.009765625
20:06:08 <Gracenotes> hm. Any regex that might cause a blowup of states? I heard a?...a?a...a is pretty bad
20:06:44 <mmorrow> that looks like a+ to me
20:07:18 <mmorrow> wouldn't that only have a single loop?
20:07:55 <Gracenotes> Ah. In this case, I mean that the number of a? or a in ... is fixed
20:08:09 <mmorrow> ah, so a{n}
20:08:25 <dolio> Well, if there are m a?s, followed by n as, and you match against a string of k as, then it can match in m choose (k - n) ways, no?
20:08:28 <Gracenotes> > ((++) `on` (take 10 . cycle)) "a?" "a"
20:08:29 <lambdabot>   "a?a?a?a?a?aaaaaaaaaa"
20:08:48 <Gracenotes> > ((++) `on` (concat . take 10 . repeat)) "a?" "a"
20:08:48 <mmorrow> a{m,n}
20:08:49 <lambdabot>   "a?a?a?a?a?a?a?a?a?a?aaaaaaaaaa"
20:08:54 <dolio> And it doesn't know what k - n is until it gets to the end of the string?
20:08:57 <Gracenotes> that's it
20:09:36 <Gracenotes> in Perl, that's a nightmare case for a large n. a{n} isn't.
20:10:09 <mmorrow> i'm sure there's a best way to do a{m,n}
20:10:37 <mmorrow> (i've never studied NFAs/DFAs, bailed from cs before i got to that)
20:11:28 <pumpkin> aw cs bailout
20:11:34 <pumpkin> why do you hate CS?
20:11:39 <pumpkin> ;)
20:11:44 <mmorrow> well, took other cs classes, but i guess i just never took one where you'd encounter those
20:11:49 <mmorrow> pumpkin: i'm a hata
20:11:58 <mmorrow> hatah?
20:11:59 <Axman6> a md hata?
20:12:01 <Axman6> mad*
20:12:16 <dolio> Really? At my school, that was the course called "computer science".
20:12:59 <dolio> (Technically, "theoretical computer science".)
20:13:04 <mmorrow> dolio: hmm. i took datastructures, and an "advanced analysis of algorithms", but never came across those
20:13:52 <mmorrow> i think the analysis of algorithms class was "beyond that", but i never actually took the prerequisite course or something
20:14:04 <dolio> Yeah, you wouldn't find them in data structures and algorithms.
20:14:41 <mmorrow> the algorithms one was more mathematical analysis/design of algos
20:14:57 <mmorrow> (and the datastructures on was the standard cs course)
20:15:19 <dolio> I don't think our algorithms class even used Turing machines to explain what NP was.
20:15:47 <dolio> They just said it was something that had a polynomial time algorithm to check potential solutions.
20:16:05 <dolio> Er, an algorithm is in NP if ...
20:16:22 <mmorrow> dolio: ahh, yeah that was one thing that killed me in that algos class and these two semester of crypto classes i took. they were technically grad classes, and assumed all that was already known, but i just signed up for them anyways ;)
20:16:37 <Gracenotes> argh. I've mumbled my states up!
20:16:45 <mmorrow> especially in crypto, this woman would throw around turing machines like it was her job
20:16:48 <MyCatVerbs> dolio: that sounds sane enough to me. The certificate definition of NP is exactly equivalent to the nondeterministic Turing machine one, and perhaps more intuitive too.
20:16:49 <mmorrow> (and it was! ;)
20:16:49 <Gracenotes> integer naming indeed has a cost.
20:17:42 <MyCatVerbs> mmorrow: Turing machines in crypto? Relativisation to show how difficult various schemes are to crack, or what?
20:18:00 <dolio> Yeah. I don't disagree there. The only way it might lack is in explaining where the name NP comes from.
20:18:07 <mmorrow> MyCatVerbs: yeah, proving security and/or lack of
20:18:20 <mmorrow> there was no programming in this one
20:18:57 <mmorrow> zero knowledge proofs, negligible probabilities, stuff like that
20:19:04 <MyCatVerbs> dolio: I suppose it's still funny to present the students with the idea of nondeterministic machines, though.
20:19:05 <Gracenotes> mmorrow: sorry to reply late, but apparently it's bad for perl because it has to do lots of backtracking, but fine in an NFA->DFA because that combines multiple searches into one.
20:19:15 <mmorrow> Gracenotes: ah, interesting
20:19:25 <Gracenotes> anyway, I've discovered a bug :3 I must attend to it
20:19:28 <Gracenotes> ;)
20:20:05 <MyCatVerbs> dolio: just for the sake of making them think, "Forget a unicorn. I need to get divine intervention to grant me a nonterministic RAM." ;)
20:21:06 <Gracenotes> then there's the Perlis quote about Turing tarpits...
20:21:38 <MyCatVerbs> I wonder if Perlis ever used m4? :)
20:27:40 <mmorrow> MyCatVerbs: http://www1.cs.columbia.edu/~tal/6998/#syllabus
20:32:27 <johnw> i have a stupid monad question
20:32:46 <johnw> or rather, a question about a fairly stupid monad :)
20:32:49 <johnw> http://gist.github.com/79274
20:33:09 <johnw> this code will only compile if I remove the call to flipCat on line 26, and replace "(flipCat y x)" with x
20:33:23 <johnw> what I don't understand is why, since x is a Probable t, and (flipCat y x) should return a Probable t
20:33:32 <johnw> but the compiler complains about Probable a != a1
20:33:39 <Valodim> hahaha, a schroedinger monad?
20:33:48 <johnw> yeah, it's just to test what I understand about monads
20:34:02 <johnw> i put a live cat in the box, and I should get a live or dead cat when I peek in the box, but not before
20:34:34 <johnw> i've added the error message to the Gist
20:34:52 <mmorrow> johnw: is it not the same just to flip the coin once at the beginning, rather than in every (>>=) for Unopened?
20:35:23 <johnw> well, I had hoped to make this all schroedingery, so that the flip would occur when you first applied any function to the Unopened box
20:35:37 <johnw> what I'd really like is for it to return an opened box in that case
20:35:42 <johnw> but I can't get to that point yet
20:36:32 <dbelange> Does anyone know the syntax to declare a variable?
20:36:37 <johnw> i come to you after about 5 hours of trying to beat this into my head alone
20:37:02 <mmorrow> dbelange: let x = 42
20:37:27 <mmorrow> johnw: by "apply", do you mean via (>>=), or .. ?
20:37:30 <Axman6> dbelange: declare it where?
20:37:37 <johnw> mmorrow: yeah, the >>=
20:37:42 <mmorrow> dbelange: (i was assuming you meant in ghci)
20:38:13 <Valodim> @type (>>=)
20:38:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:38:16 <dbelange> No, this doesn't work.
20:38:19 <dbelange> let x = 42
20:38:22 <dbelange> let x = x + 1
20:38:24 <dbelange> x
20:38:31 <mmorrow> johnw: so you want (Unopened y x >>= f) to cause the box to be Opened ?
20:38:40 <johnw> mmorrow: yes, is that possible?
20:38:45 <mmorrow> sure
20:38:58 <johnw> i felt it ought to be
20:39:03 <Valodim> johnw: but flipCat returns a probable a, >>= expects something in a Schroedinger monad?
20:39:10 <dbelange> How do I change a variable?
20:39:17 <Valodim> oh wait, f $
20:39:25 <johnw> dbelange: you need to use "let y = x + 1", you can't change x
20:39:27 <mmorrow> err, yeah, does that compile?
20:39:34 <johnw> mmorrow: no, what i have doesn't
20:39:40 <johnw> unless I replace "flipCat y x" with just "x"
20:39:41 <mmorrow> ahhh, ok :)
20:39:51 <johnw> but aren't x and flipCat y x of the same type?
20:39:54 <dbelange> johnw: That doesn't make any sense with a for loop, say.
20:39:59 <dbelange> I need to increment x.
20:40:10 <jm> dbelange: then you'll be happy to hear that Haskell does not have for loops.
20:40:11 <Valodim> still, f expects an a and flipCat returns a Probable a
20:40:17 <johnw> dbelange: in the world of Haskell, you would iterate using a recursion function, there are no foor loops
20:40:33 <johnw> Valodim: ahh...
20:40:36 <jm> dbelange: consider reading a book on Haskell, such as Real World Haskell <http://book.realworldhaskell.org/read/>
20:40:39 <dbelange> Okay, so how do I increment x using a recursion function?
20:40:41 <johnw> I tried "f $ Opened (flipCat y x)
20:40:44 <johnw> but no love there either
20:41:02 <johnw> then it says that Probable a does not match Schroedinger (Probable a)
20:41:16 <mmorrow> johnw: so if the cat is dead, you still want "f" to operate on some value?
20:41:27 <johnw> mmorrow: for this iteration, sure
20:41:35 <johnw> mmorrow: i'll get fancy once I understand why this fails...
20:41:44 <mmorrow> because as you have it, what's the difference in the "a" if the cat is live or dead
20:41:46 <mmorrow> ?
20:41:54 <johnw> Probable a is either Live a or Dead a
20:42:10 <mmorrow> but "f" has to be :: a -> Schroedinger b
20:42:15 <dbelange> Okay, so can I make a for loop using monads?
20:42:17 <Valodim> yeah, but you have to work with a there not with Probable a
20:42:24 <johnw> yeah, and a here is Probable a, isn't it?
20:42:34 <mmorrow> no, just "a"
20:42:47 <mmorrow> as in anything
20:42:49 <johnw> when I created my first unopened box, I said "Unopened gen (Live (Cat "Felix"))"
20:42:55 <johnw> i thought would bind a to Probable a
20:43:07 <johnw> err, not bind, but infer
20:43:07 <Valodim> what do you want to happen if the cat is alive and you bind a function to it?
20:43:10 <mmorrow> ah, so in that case, you're working with Schroedinger (Probable a)
20:43:13 <Valodim> and what should happen on dead, for that matter
20:43:20 <mmorrow> but a Monad instance has to work for _all_ "a"
20:43:22 <johnw> Valodim: i haven't gotten that far yet
20:43:28 <Valodim> well that's where you are
20:43:29 <jm> dbelange: there are ways to imitate a loop, but you almost certainly don't want to.
20:43:32 <johnw> mmorrow: ahhh
20:43:48 <dbelange> I do want to, as it is necessary for my algorithm.
20:44:20 <jm> What algorithm are you writing? It can likely be represented using a recursive definition, instead.
20:44:56 <Valodim> flipCat gen (Cat x) = Cat (x ++ status)
20:44:56 <Valodim>   where status = if flipCoin gen then Cat "alive " else "dead "
20:44:57 <dbelange> Yeah, I know Church's Thesis.
20:45:15 <Valodim> that would just prepend the dead or alive thing, if you use that your >>= should work
20:45:35 <Valodim> whoops, minus the Cat there in the "then"
20:46:03 <johnw> Valodim: so I have to avoid the Probable type?
20:46:14 <Valodim> depends on what you want to do
20:46:26 <dbelange> The algorithm I'm writing is too complicated to relate.
20:47:03 <johnw> i can feel I'm missing something fundamental, I thought my "a" would be completely opaque to the Monad, but it seems that flipCat is forcing the type inference to compare a completely generic a to a more specific Probable a, is that what's happening?
20:47:23 <Valodim> yes
20:47:29 <johnw> ok, that makes sense at least
20:47:32 <sm> yes
20:47:34 * johnw bandages head
20:47:35 <mmorrow> johnw: in the monad instance def, you can't assume 'a' is anything other than 'a'
20:47:46 <johnw> mmorrow: ah, ah, ah *light bulb*
20:47:47 <johnw> thanks
20:47:50 <mmorrow> :)
20:47:54 <sm> johnw: I think it wants a declaration to constrain flipCat's second argument , but I don't see where
20:48:52 <johnw> so, my next question is, if I want to do this all monad-like, where do I do the flip?
20:49:46 <Valodim> Maybe data Cat = AliveCat a | DeadCat a | WhoKnowsCat a?
20:50:04 <Valodim> uh, maybe as in possibly and missing an a there :P
20:50:05 <johnw> http://gist.github.com/79274 now compiles, but there is no flip to fix the state of the cat if anyone tries to reference the monad
20:50:06 <mmorrow> but then in that rep, what's the diff if the cat is alive or dead?
20:50:48 <mmorrow> so i guess the question is really "what are you trying to achieve with this Schroedinger type?"
20:50:58 <johnw> mmorrow: nothing but silliness to help me grok things
20:51:10 <johnw> it's unimportant, if you guys had better things to discuss
20:51:34 <mmorrow> (not asking because i think there's nothing to achieve, just because i don't know and the answer to that would i think determine how you redefine Cat)
20:52:00 <johnw> so, i've added another type constructor for probable: Live | Dead | Unknown
20:52:03 <mmorrow> because as-is, it's not compatible with a Monad instance
20:52:04 <johnw> I want this to happen:
20:52:24 <johnw> when I put a Live cat into the Monad, it becomes an Unknown cat.  When I use the monad in some way, it becomes a Dead or Live cat, based on a roll of the dice
20:52:45 <mmorrow> one thing i can think of is that you do   data Probable a = Live a | Dead
20:52:50 <mmorrow> which is equiv to Maybe
20:52:59 <johnw> that sounds right
20:53:21 <johnw> and then "Dead >>= f = Dead"?
20:53:23 <mmorrow> then you can make a monad instance where    Opened Dead >>= _ = Opened Dead
20:53:30 <mmorrow> johnw: exactly
20:54:18 <mmorrow> Unopened gen prob >>= f = Opened (determine if prob is live or dead) >>= f
20:54:36 <mmorrow> Opene (Live a) >>= f = f a
20:54:52 <mmorrow> or similar
20:55:24 <pumpkin> bah, this is confusing me
20:55:43 <johnw> mmorrow: ahh.... _ >>= f = _ >>= f
20:55:47 <johnw> that would never have occurred to me
20:56:07 <mmorrow> johnw: yeah, just reduce it to another case
20:56:27 <johnw> ok, i updated the gist, but now I'm back to the "cannot construct the infinite type: a = Probable a" problem
20:56:36 <johnw> this time, on the Opened Dead line
20:56:45 <johnw> "Opened Dead >>= _ = Opened Dead"
20:57:35 <mmorrow> that's assuming that ... | Opened a | ... is really  Opened (Probable a)
20:57:56 <mmorrow> so you probably want to redefine Schroedinger
20:58:26 <mmorrow> data Schroedinger a = Opened (Probable a) | Unopened StdGen a
20:58:29 <mmorrow> then make
20:58:41 <mmorrow> flipCat :: StdGen -> a -> Probable a
20:59:06 <mmorrow> (and     return a = return x = Unopened (mkStdGen 100) a)
20:59:08 <mmorrow> )
20:59:11 <johnw> ok, did all that
20:59:20 <mmorrow> does it work?
20:59:27 <johnw> omg
20:59:39 <johnw> it does!!
20:59:43 <mmorrow> yay! :)
20:59:43 <johnw> thank you so much
20:59:45 <mmorrow> np
20:59:49 <johnw> you've solved the riddle of my entire day
20:59:57 <johnw> all while shopping I kept trying to pick this apart
20:59:58 <mmorrow> glad to help :)
21:00:10 <johnw> you certainly have, now back to the books :)  bye mmorrow, Valodim
21:00:15 <mmorrow> bye
21:00:26 <sm> don't forget to paste that last version
21:02:21 <johnw> done
21:02:34 <pumpkin> alright, I think I'm confused somewhere
21:02:55 <pumpkin> if I have a function checkBool :: Bool -> a -> a
21:03:09 <johnw> mmorrow: one last question, while I understand what "Unopened y x >>= f = Opened (flipCat y x) >>= f" is doing, I don't understand why "Unopened y x >>= f = Opened (flipCat y x)" is not an option (compiler error "Couldn't match expected type `b' against inferred type `a'")
21:03:19 <pumpkin> checkBool b x = if b then x else error "false!"
21:03:55 <pumpkin> what happens if I do checkBool (expression ...) $ functionThatCanCallError
21:04:10 <pumpkin> which error gets thrown?
21:04:16 <pumpkin> if both would throw an error
21:04:20 <mmorrow> johnw: because "Opened (flipCat y x)" has to be of type (Schroedinger b), but it's of type (Schroedinger a)
21:04:40 <johnw> oh.. because of the x being passed down and returned
21:04:45 <mmorrow> exactly
21:04:50 <Gracenotes> it's functions like this that make me realize how expressive functional programming is: testZeroes nfa = map (second (runNFA nfa)) . zip [0..] $ iterate ('0':) ""
21:04:55 <johnw> great, thanks again
21:04:59 <mmorrow> np
21:05:04 <Axman6> > let checkBool b x = if b then x else error "Oh Noes!!!" in checkBool False (error "huh?")
21:05:04 <Gracenotes> imagine doing it in Java... I'd have to have a for loop, adding a zero to the end every iteration
21:05:05 <lambdabot>   * Exception: Oh Noes!!!
21:05:14 <Axman6> > let checkBool b x = if b then x else error "Oh Noes!!!" in checkBool True (error "huh?")
21:05:15 <lambdabot>   * Exception: huh?
21:05:16 <pumpkin> Axman6: that's what I expect
21:05:23 <pumpkin> except I'm not seeing that
21:05:26 <Axman6> > let checkBool b x = if b then x else error "Oh Noes!!!" in checkBool True $! (error "huh?")
21:05:28 <lambdabot>   * Exception: huh?
21:05:34 <Axman6> > let checkBool b x = if b then x else error "Oh Noes!!!" in checkBool False $! (error "huh?")
21:05:35 <lambdabot>   * Exception: huh?
21:05:47 <pumpkin> not using $!
21:06:01 <Gracenotes> is quickCheck using it for you? :)
21:06:07 <pumpkin> nope
21:06:14 <Gracenotes> mm
21:07:19 <pumpkin> but there's weird fusion going on
21:08:08 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2405#a2405 is what I'm talking about
21:08:16 <pumpkin> all that unstreamU stuff at the end
21:08:21 <pumpkin> is erroring before my checkbool can
21:10:48 <pumpkin> any ideas?
21:13:35 <pumpkin> :(
21:16:43 <Axman6> no ideas for you!
21:17:06 <pumpkin> :(
21:18:13 * Axman6 gives pumpkin some soup instead
21:18:18 <mmorrow> what's the type of checkBool?
21:18:41 <mmorrow> ohh, i didn't see the ($)
21:19:01 <orzo> I just build a library from hackage and set the prefix to /opt/hackage
21:19:10 <orzo> then i made a program and ghc just found it
21:19:19 <orzo> how does ghc know where to find libraries?
21:19:29 <Axman6> magic
21:19:47 <orzo> if i installed files anywhere but under the prefix, i'd like to know what they are
21:19:47 <Axman6> cabal probably registeres the package with ghc-pkg
21:21:04 <dons> orzo: there's  a package.conf file
21:21:07 <dons> in lib/ghc-*/
21:21:14 <dons> where ghc-pkg registers and unregisters packages
21:21:49 <mmorrow> pumpkin: maybe something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2405#a2406
21:22:23 <orzo> oh
21:22:25 <mmorrow> pumpkin: oops, i guess that should be (checkBool ... = if not (p a) ....)
21:22:50 <mmorrow> pumpkin: oops, i also forgot to pass (a1,a2) to checkBool
21:23:39 <mmorrow> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2405#a2407
21:24:25 <orzo> eh
21:24:50 <orzo> well what's teh proper way to uninstall this, its a cabal package
21:25:56 <mmorrow> orzo: sudo ghc-pkg unregister foo-0.2.3 && sudo rm -rf /opt/hackage/foo-0.2.3
21:28:57 <callen> can we rename this to #genius ? This channel is good for everything.
21:29:16 <gwern> alas, that would be false advertising
21:29:21 <gwern> many of us are merely bright
21:30:58 <orzo> my ghc is managed by apt and i want to let the package.conf be only for apt installed packages
21:31:37 <dons> maybe distinguish global and user installs, then, orzo ?
21:31:45 <dons> cabal will install as user by default in your home
21:31:53 <dons> which won't modify the global things apt messes with
21:32:12 <orzo> ya i guess
21:32:35 <orzo> but i feel it's messing with my system
21:32:45 <orzo> i didnt intend the package for a specific user
21:33:33 <orzo> i'd rather have an /opt/hackage/ directory with build haskell packages and a package.conf under there that will be searched (I guess i could sym link it from home)
21:33:44 <orzo> s/build/built/
21:34:46 <Axman6> heh, i love seeing C like this: *pInt |= (1 << remainder);
21:35:35 <orzo> it seems like ghc isn't playing nice with the usual unix conventions
21:35:41 <orzo> why not
21:36:08 <dons> hmm?
21:36:10 <bos> it plays fine with them.
21:36:20 <dons> ghc will pick up your packages from either the global cache, or your local cache
21:36:28 <dons> or even other places if you're tricky.
21:36:32 <bos> every sane distro has a perfectly happy marriage of system package manager and ghc.
21:36:39 <dons> but the 2 phase, global/local thing seems to work fine for everyone
21:37:01 <dons> my package manager messes with the global cache, my cabal-install modifies the local one
21:37:10 <orzo> local ?
21:37:16 <orzo> you mean the one in home?
21:37:27 <dons> yeah. under $HOME/.cabal
21:37:46 <dons> and cabal will install there by default, saving you from confusing your poor apt
21:38:27 <orzo> there's 3 cases.  Global Managed, Global Unmanaged, and User Unmanaged.
21:38:29 <bos> apt does not in any case get confused if you install packages globally.
21:38:38 <orzo> you are calling "local" user unmanaged
21:38:45 <dons> 'unmanaged'?
21:38:48 <orzo> but what about global unmanaged?
21:38:56 <orzo> unmanaged = installed manually, not using apt
21:39:00 <bos> orzo: nobody cares about that case in practice.
21:39:02 <dons> they're still managed though.
21:39:04 <bos> except you.
21:39:15 <dons> ghc-pkg registers/unregisters them. apt is just glue over that
21:39:18 <orzo> pft
21:39:22 <orzo> did you conduct a survey, bos?
21:39:29 * dons isn't sure what the problem is
21:39:46 <dons> ah, you want   to do global unmanaged installs of packages that are also managed by apt?
21:39:57 <dons> i.e. apt get foo ; cabal install foo --global ?
21:40:08 <dons> then the latter clobbers the apt one, and things break?
21:40:17 <dons> since if you're not doing that, then everything is fine.
21:40:58 <dons> so, a) don't use global "unmanaged" things that you've previously told apt to manage.
21:41:08 <dons> otherwise, global or local "unmanaged" is ok
21:42:32 <orzo> well i don't like it
21:42:42 <dons> why?
21:43:12 <dons> ah, you *want* to do global installs, of things apt already manages, for some reason?
21:43:50 <dons> or you just want things installed by cabal to not use /usr/lib ?
21:44:06 <dons> (in which case, --prefix is your friend. cabal install foo --global --prefix=/opt/hackage
21:45:55 <orzo> i did use a prefix
21:46:21 <orzo> probably i dont want --global
21:47:00 <orzo> probably i want a prefix with --local and then do something funny like make my local package.conf be a symlink to one under my prefix
21:47:20 <orzo> that's lame though
21:47:34 <dons> no need for the symlink in the last case
21:47:44 <dons> just use local with a prefix
21:48:10 <orzo> if i use local, doesn't it register with a package.conf under $HOME/.ghc ?
21:48:48 <orzo> there's a separate package registery for each user with local isntalls, right?
21:48:48 <dons> somewhere like that. wherever your local package.conf is
21:48:51 <dons> yep
21:49:02 <dons> ghc then uses the union of the global, and your local, set
21:49:18 <dons> like global and local prefs in every app everywhere
21:49:42 <orzo> yes, well there should actually be 3 sets
21:50:23 <orzo> global under /usr, then some global under /usr/local or wherever, and then the per-user one
21:51:52 <orzo> that's how pkg-config works and most other things
21:52:41 <orzo> python
21:52:46 <orzo> does it
21:52:49 <orzo> everybody does it
21:52:58 <orzo> just not ghc becaues you guys think nobody cares
21:53:10 <dons> well, you could put your global under /usr/local
21:53:12 <dons> why not?
21:53:39 <dons> seems like a corner case, having two global sets. but feel free to request it on the cabal ticket
21:53:56 <dons> http://hackage.haskell.org/trac/hackage/
21:53:58 <solidsnack> I think they are for "maintainer global" and "user global"
21:54:09 <solidsnack> I think it is a BSDism, actually.
21:54:19 <solidsnack> The ones in /usr belong to the distro maintainer.
21:54:34 <solidsnack> The ones in /usr/local belong to the system administrator.
21:54:45 <orzo> right
21:56:03 <solidsnack> Many have abandoned this ancient practice; but it's tidy and as more distros ship GHC it will be helpful.
21:56:25 <pumpkin> mmorrow: why does checkBool need to call the function?
21:57:06 <sutats> solidsnack: Doesn't /opt fill the role for /usr/local more so nowadays?
21:57:16 <Axman6> no
21:57:19 <dons> all distros already ship ghc
21:57:29 <Axman6> whoops, wrong chan. but still, i'm saying no :P
21:57:31 <solidsnack> dons: Okay, but few people use it.
21:57:35 <dons> ghc?
21:57:46 <dons> i guess 'few' compared to youtube, sure.
21:57:57 <solidsnack> dons: Few compared to the Python interpreter.
21:58:00 <dons> but it has been through the packaging process of all the distros, and survived
21:58:11 <solidsnack> dons: Okay.
21:58:22 <zachk1> i love ghc
21:58:27 <solidsnack> That's good to know -- I didn't know it was so widely available.
21:58:39 <dons> e.g. on arch, i've got my 970 distro packages in /usr/lib/* and my another 100 in ~/.ghc/
21:58:48 <dons> some 15 or so came by default in /usr/lib with ghc
21:59:15 <solidsnack> sutats: I think /opt/ was always something different.
21:59:45 <solidsnack> It's where you go to insert a whole new dir hierarchy for an app.
22:00:07 <solidsnack> In other words, in /usr/local you /usr/local/lib
22:00:27 <sutats> solidsnack: Ah, okay, I see the difference.
22:00:33 <solidsnack> But in /opt/, you /opt/java-12321/lib
22:01:09 <solidsnack> or /opt/jdk-9000/bin
22:02:09 * pumpkin is very confused
22:02:19 <orzo> maybe you should be able to register an auxillary global registry in your local user one
22:02:45 <orzo> you could do that to support the /opt case
22:03:04 <orzo> or the /usr/local/ case too i suppose
22:03:21 <dons> my distro has 86% of hackage packaged natively in distro format
22:03:37 <orzo> so what
22:03:47 <dons> i just think that's cool.
22:03:51 <orzo> there's still 14%
22:03:58 <dons> which only work on windows...
22:04:01 <Axman6> dons: luckily, 'your' distro is the only distro i've ever been abe to stand :P
22:04:02 <solidsnack> LOLz
22:04:15 <Axman6> able*
22:04:15 <mmorrow> pumpkin: i just used that as a way to force the condition to be evaluated
22:04:19 <pumpkin> hmm
22:04:32 <pumpkin> mmorrow: I guess I'm just confused as to why the last parameter is being evaluated first
22:04:35 <mmorrow> but i dunno what your original def was
22:04:38 <mmorrow> yeah, me too
22:04:45 <pumpkin> I'll paste both
22:04:46 <mmorrow> how did you define checkBool?
22:05:13 <dons> orzo's distro has 4% of hackage packaged
22:05:14 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2408#a2408
22:05:15 <dons> suxors :/
22:05:26 <dons> no wonder nobody knows about the cool libs and tools
22:05:32 <mmorrow> pumpkin: (yeah, in hindsight it would be super annoying to have to have checkBool call the function, making it necessary to tuplify all the args)
22:06:03 <orzo> my distro is debian
22:06:08 <orzo> debian has only 4%?
22:06:10 <pumpkin> debian still has ghc 6.8
22:06:17 <mmorrow> the horroew
22:06:18 <dons> yeah, by my count.
22:06:19 <orzo> well debian unstable
22:06:20 <mmorrow> *horrow
22:06:22 <mmorrow> gah
22:06:24 <mmorrow> *horror
22:06:32 <johnw> MacPorts only has maybe 12 or so hackage packages
22:06:36 <pumpkin> I bet your hands are used to typing orrow
22:06:45 <mmorrow> pumpkin: heh
22:06:47 <pumpkin> from all the sorrow
22:06:52 <dons> hey, 1%, johnw :)
22:07:03 <dons> this is bad though. people use what comes up when they search their distro package.
22:07:04 <orzo> i think your second correction should have two astericks in order to fully override the first one
22:07:06 * mmorrow tries to think of another *orrow, can't
22:07:13 <dons> if pandoc or gitit don't come up, they'll use some other markup or wiki impl.
22:07:14 <pumpkin> borrow
22:07:23 <mmorrow> orzo: true. kinda like a p.p.s
22:07:30 <mmorrow> pumpkin: grr
22:07:35 <pumpkin> :P
22:08:19 <pumpkin> tomorrow
22:08:22 <pumpkin> same as morrow though
22:08:28 <gogonkt> ............
22:08:29 <bmh> pumpkin: do you spend all day here?
22:08:29 <mmorrow> yeah
22:08:39 <pumpkin> bmh: not always :)
22:08:40 <dons> ask your distro maintainer to stock your favourite haskell beverages.
22:09:02 <bmh> I'm still on my data structures binge.
22:09:07 <bmh> I just implemented skew heaps
22:09:17 <pumpkin> you should try soft heaps :o
22:09:27 <dons> bmh: you releasing them ?
22:09:30 <dons>  sounds useful
22:09:30 <bmh> I haven't made up my mind on randomized data structures
22:09:32 <mmorrow> bmh: do you have the okasaki book?
22:09:39 <mmorrow> it's nice
22:09:41 <bmh> mmorrow: no, but I've read parts of it before
22:10:09 <bmh> dons: I could, I'm not sure people will be happy with some of my design decisions
22:10:10 <pumpkin> mmorrow: you think a rewrite rule is messing with my check?
22:10:20 <mmorrow> pumpkin: ooh, maybe
22:10:23 <bmh> I decided not to bother with using explicit keys and rely on Ord
22:10:36 <mmorrow> but i don't see how that would rewrite the boolean check
22:10:36 <pumpkin> mmorrow: the only applicable one is streamU/unstreamU
22:10:42 <pumpkin> yeah, I doubt that's it
22:10:44 <mmorrow> what is the def?
22:11:05 <pumpkin> "streamU/unstreamU" forall s.
22:11:05 <pumpkin>   streamU (unstreamU s) = s
22:11:14 <bmh> for soft heaps I might be inclined to implement it in C and hook it in with the FFI
22:11:26 <dons> urgh
22:11:28 <mmorrow> pumpkin: remind me, what was the function in that paste
22:11:42 <bmh> dons: What would you suggest instead? Doing it all in the IO Monad?
22:11:52 <dons> ST ?
22:11:54 <pumpkin> combineU, implemented in terms of unstreamU
22:11:55 * mmorrow has so much crap open right now
22:11:59 <dons> i guess you're modifying memory, only, right?
22:12:01 <pumpkin> ( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2408#a2408 )
22:12:04 <mmorrow> thx
22:12:05 <dons> so you want a memory effects monad
22:12:07 <bmh> how 'bout the RNG?
22:12:32 <dons> mm.. maybe it is in IO then.
22:12:44 <bmh> which is displeasing to me
22:12:46 <dons> mersenne-twister + IOU updates
22:12:53 <dons> well, hey, you can write a paper on the pure implementation
22:13:17 <bmh> I could do it in the ST monad, does that count?
22:13:32 <bmh> there's also the nonsense of merging randomized data structures -- where do the RNGs go?
22:13:33 <mmorrow> pumpkin: i think it's worth dumping all rewrites while you build it and making sure that's not what's happening, because i think it'd be really hard to figure out in your head
22:13:33 <pumpkin> does a soft heap actually need randomness?
22:13:52 <mmorrow> (because two rewrites could then move stuff around that results in a third, and so on...)
22:13:59 <pumpkin> hmm, yeah
22:14:12 <pumpkin> ack
22:14:34 <pumpkin> maybe I'll just take a break for now
22:14:44 <bmh> so, time to fess up to my lack of skills: this is the first time I'm created my own class
22:14:58 <Axman6> class?
22:15:07 <bmh> a la Eq, Ord
22:15:12 <Axman6> ah, yes, right
22:16:09 <bmh> if someone could point me to a gentle introduction, I'd appreciate it
22:17:54 <dons> seems like a single random source in a variable is kinda ok in ST.
22:18:11 <lament> bmh: http://www.haskell.org/tutorial/classes.html :)
22:19:47 <Gracenotes> hm. why the Show constraint on Nums? Because it's convenient not to write 'Show a =>' everywhere? :)
22:21:10 <orzo> how do i tell ghci to run a program immediately?
22:21:24 <orzo> instead of dropping me into an interactive interpretter
22:21:36 <pumpkin> runghc?
22:21:47 <Lemmih> orzo: -e.
22:23:24 <orzo> runghc is what i was looking for
22:24:40 <Gracenotes> hm... http://haskell.tailorfontela.com.br/
22:25:21 <Gracenotes> neat :) /me didn't know this version was maintained
22:25:40 <Gracenotes> although not entirely up to date I suppose
22:29:05 <pumpkin> mmorrow: adding an inline pragma to my condition seems to have fixed it, I think
22:29:11 <pumpkin> :P
22:29:22 <bmh> dons: et al, if you want to check out my code I can throw up a repo
22:29:24 * pumpkin worships the voodoo gods and asks no questions
22:30:01 <Cale> Gracenotes: I didn't even know it existed! That's pretty cool :)
22:30:13 <pumpkin> most of it is still in english
22:30:27 <pumpkin> man, GHC is slow on one my test files
22:32:10 <pumpkin> it's under 300 lines, and takes about 20 seconds to compile on my 2 ghz xeon
22:33:27 <callen> pumpkin: what in god's name are you doing?
22:33:45 <pumpkin> completing the testsuite
22:33:52 <pumpkin> making it check for error conditions
22:36:27 <bmh> must be doing something stupid in this implementation -- the skew heap is 10x slower than the binomial heap
22:37:02 <bmh> (12x than Data.List.sort)
22:37:49 <bmh> ah-ha. I am.
22:38:44 <bmh> Let this be a lesson, kids: Don't make your data structures optimally unbalanced and expect good results!
22:40:45 <bmh> next up: pairing heaps.
22:41:21 <Gracenotes> what's the page with OOP classes clunkily implemented in Haskell?
22:41:28 <Gracenotes> I think it's on the wiki
22:43:51 <Gracenotes> hm. It might have been a mailing list post.
22:46:50 * pumpkin screams at rewrite rules
22:47:01 <bmh> using TH?
22:47:16 <pumpkin> just the GHC rules pragma
22:47:39 <bmh> I do have to say that scheme macros are much easier to use than template haskell.
22:48:06 <Gracenotes> maybe you can write a quasiquoter to make them as easy to use :P
22:48:22 <bmh> maybe you can... :-P
22:55:25 <Eridius> bmh: scheme macros may be easier to use, but quite often a situation where you'd want a macro in scheme doesn't require them in haskell
22:59:01 <pumpkin> dons: I think the rewrite rules are wreaking havoc on my attempts to make things safe :(
22:59:07 <pumpkin> let's just cut out all the fusion! :D
22:59:09 <pumpkin> ;)
23:01:14 <pumpkin> http://www.workerwrapper.com/ whoa, that's an odd site
23:08:41 <pumpkin> I like the paper
23:09:08 <Gracenotes> we need a website for every functional programming concept
23:09:22 <Gracenotes> foldl.com and foldr.com, good starts
23:10:03 <callen> Prelude Main> doubleMe 2
23:10:04 <callen> <interactive>:1:0: Not in scope: `doubleMe'
23:10:05 <pumpkin> lol at foldl.com
23:10:12 <pumpkin> and foldr.com
23:10:13 <callen> what's going on? I successfully loaded my hs file.
23:10:19 <callen> this worked in windows. :|
23:10:28 <Axman6> callen: try :reload
23:10:40 <Axman6> happened to me a few times. that seems to work
23:11:26 <callen> Axman6: still no.
23:11:34 <Axman6> hmm
23:11:45 <Axman6> :l file.hs
23:11:46 <Axman6> ?
23:12:02 <pumpkin> callen: is it exported?
23:12:10 <callen> I already :l file.hs
23:12:15 <callen> pumpkin: exported?
23:12:32 <pumpkin> module Main (...) where?
23:12:35 <Axman6> module Foo (exportedFunc, exportedFunc2) where
23:12:49 <Axman6> but leaving out the (exp...) exports everythign
23:12:59 <pumpkin> I guess you shouldn't need to even export when running like that
23:13:02 <callen> I have no idea what you're talking about, I just started learning this language.
23:13:12 <callen> the instructions in the tutorial which are the instructions that worked on windows
23:13:19 <callen> said to just :l the file.
23:13:27 <pumpkin> what does the file look like?
23:13:29 <callen> and I did. and it's not working.
23:13:29 <Axman6> in ghci right?
23:13:31 <callen> yes.
23:13:40 <Axman6> mist pasting the file on hpaste?
23:13:44 <Axman6> @where hpaste
23:13:44 <lambdabot> http://hpaste.org/
23:13:50 <callen> http://codepad.org/PHpgmb1A
23:13:54 <callen> code is there.
23:13:58 <Axman6> uh, mist = mind
23:14:07 <callen> I like codepad.
23:14:49 <pumpkin> lostNumbers :o
23:15:03 <callen> pumpkin: what?
23:16:14 <Gracenotes> callen:  okay, so you start ghci in the directory that file is in?
23:16:18 <Axman6> callen: i can't see anything wrong with it
23:16:22 <callen> Gracenotes: yes.
23:16:29 <callen> Axman6: and it worked in Windows just fine, which is why I'm baffled.
23:17:20 <Gracenotes> and it says [1 of 1] Compiling Main             ( blah.hs, interpreted )
23:17:20 <callen> EOF'd and then tried all over again, no dice.
23:17:29 <callen> Prelude> :l testing.hs
23:17:32 <callen> Ok, modules loaded: Main
23:17:38 <callen> says it loaded okay.
23:17:46 <callen> Prelude Main> doubleMe 2
23:17:47 <callen> <interactive>:1:0: Not in scope: `doubleMe'
23:17:49 <Gracenotes> hm, I see. Do any of the other functions in it work?
23:18:00 <callen> Gracenotes: no.
23:18:39 <harblcat> Are you sure the file contains that code? :P
23:18:55 <callen> harblcat: I'm staring at it in gedit, and it's the only .hs file in the directory.
23:19:05 <callen> could you please, for godssakes, stop asking me "stupid people" questions.
23:19:16 <callen> I had this working on windows fine, and this is far from my first language or interpreter.
23:19:30 <pumpkin> :browse Main
23:19:33 <lament> is the computer turned on?
23:19:42 <callen> Prelude Main> :browse Main
23:19:45 <callen> main :: IO ()
23:19:53 <pumpkin> that's it?
23:19:59 <callen> so it says.
23:20:16 <pumpkin> try writing module Main where at the top of the file
23:20:17 <pumpkin> and reloading
23:21:16 <callen> pumpkin: fixed it. why did this fix it, why did it work in Windows and not here?
23:21:24 <callen> the browse main brings up everything too.
23:21:24 <pumpkin> same version of GHC?
23:21:47 <pumpkin> had you compiled the file before running ghci?
23:21:56 <pumpkin> (was there a .hi file lying around?)
23:21:58 <callen> pumpkin: I have no idea, one was the binary distribution for win32, one was the apt-get
23:22:02 <callen> yes, in both cases.
23:24:53 <callen> pumpkin: linux version is 6.8.2, windows version is current stable 6.10.1
23:25:08 <callen> did they change the way things are loaded in ghci after 6.8.2?
23:25:14 <Axman6> probably
23:25:59 <callen> how annoying.
23:26:12 <Gracenotes> hm. I use 6.8.2 (Ubuntu) and a simple file like "double x = x+x" loads in ghci just fine
23:26:20 <harblcat> It works fine with me, too...
23:27:09 <ivanm> I've just been reading the lastest HWN... anyone know what Baughn's quote is meant to be? :s
23:27:34 <callen> Gracenotes: I'm in ubuntu too. Sigh. my title of human fuzzer continues to be true.
23:27:47 <Gracenotes> :3
23:28:07 <Axman6> Gracenotes: what about if you add main = putStrLn "hello world"?
23:29:01 <Gracenotes> Axman6: it prints "hello world" when I call main. Is this normal?
23:29:18 <Axman6> can you call the other functions?
23:29:27 <Gracenotes> I don't have any other functions
23:29:42 <Gracenotes> callen: hm... I suppose it might have to do with compiling it beforehand
23:31:21 <callen> Gracenotes: explain?
23:32:53 <Gracenotes> I suppose that when you tell ghci to load your file, it doesn't parse the newer version, but looks at the object code of the older version? Just a guess, dunno.
23:33:08 <callen> Gracenotes: that's not it, I can guarantee it.
23:33:21 <Gracenotes> *nods*
23:33:29 <harblcat> callen: had you compiled the code with ghc beforehand?
23:33:41 <Gracenotes> 0.0
23:34:03 <Gracenotes> harblcat: see above
23:34:05 <Axman6> > concat $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:34:06 <lambdabot>   "(((5(,(9()2(252,292),(,5,,,9,)3(353,393))()5),)9))"
23:34:11 <callen> harblcat: I tested everything.
23:34:14 <Axman6> holy...
23:34:42 <ivanm> Axman6: yeah, I had a similar reaction :s
23:34:44 <Axman6> Baughn: you're crazy :|
23:34:46 <harblcat> Okay, so what happens if you go ahead and comment out that 'module Main where'? Does the problem return?
23:34:47 <ivanm> wtf is it meant to be? :s
23:34:54 <callen> harblcat: every permutation was tested and all loads failed until I added a "module Main where" above everything.
23:35:11 <Gracenotes> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:35:13 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
23:35:27 <Gracenotes> ah
23:35:31 <callen> harblcat: do you want me to recompile or delete existing object files?
23:35:56 <callen> harblcat: I just tested it without changing anything, it worked with that line commented out.
23:36:03 <Gracenotes> that makes a bit more sense...
23:36:05 <callen> deleting object files, trying it without any existing binaries.
23:36:33 <Gracenotes> > flip map [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
23:36:35 <lambdabot>   ["(2,3)","(5,9)"]
23:37:09 <callen> Gracenotes harblcat still works without any existing object files.
23:37:10 <harblcat> callen, when you got the file into linux from windows, how did you do it?
23:37:13 <callen> or the line.
23:37:31 <callen> harblcat: ntfs-3g, direct access. my terminal is inside the ntfs mount. this affects nothing.
23:38:30 <Gracenotes> beware, harblcat tech support is $5 per minute
23:38:40 <callen> Gracenotes: I'm unemployed, fscking try me.
23:38:49 <harblcat> lol, I am free :P
23:39:11 <Gracenotes> >_>
23:39:12 <Lemmih> Free? I'll take two!
23:39:15 <callen> well it's working in the absence of that line, the binaries, and the object file.
23:39:23 <callen> i cannot reproduce the problem.
23:39:27 <callen> as yet. anyway.
23:39:38 <Gracenotes> seems like a good thing.
23:39:43 <harblcat> Well, you're saying that you mounted the ntfs drive, cd'd into the directory, and ran ghci on foo.hs?
23:40:29 <callen> Gracenotes: unpredictable and unreproduceable software behavior is never a good thing.
23:40:40 <callen> harblcat: I didn't mount the drive, that wonderful thing called an fstab did.
23:40:53 <callen> ghci then :l testing.hs while cd'd in the directory.
23:40:59 <harblcat> right right...
23:41:00 <callen> which worked fine on Windows.
23:41:10 <callen> don't make me reiterate that the ntfs partition isn't the issue here.
23:41:18 <callen> it's not, it's something in the interpreter.
23:41:36 <harblcat> I'd ask you to go back into windows, open the file, save it, come back into linux, and try it again, but that certainly seems like a lot of work...
23:41:44 <callen> we've got two different versions of the interpreter between windows and linux.
23:41:57 <callen> harblcat: I refuse, this software isn't my problem. I'm trying to learn a programming language, not fix it for someone.
23:42:10 <callen> neat language, but ghci isn't my project, I have enough work ahead of me with nasm.
23:42:14 <p_l> maybe it's something to do with ntfs not being case-insensitive
23:42:23 <Gracenotes> x.x
23:42:24 <callen> p_l: it's case sensitive on Linux.
23:42:46 <callen> p_l: it has nothing to do with the ntfs partition.
23:42:46 <harblcat> Well, ubuntu (I assume) doesn't have the latest-and-greatest ghc, although it is relatively easy to get it. (relatively)
23:43:01 <callen> I will use a hot iron that says as much on your hide if you suggest it again.
23:43:10 <callen> harblcat: I already said that there were two different versions involved.
23:43:13 <Gracenotes> anyway, I've never run into that scenario, and it might be a bug in 6.8 that was fixed in 6.10. Just keep on going with GHCI and dynamic loading and you'll be fine (I was, at least).
23:43:16 <p_l> callen: depends on settings (aka depends on "you want to fuckup idiotic win32 apps" or not)
23:43:17 <harblcat> Well, you should be able to reproduce the error if you started from the original file you had to begin with.
23:43:19 <callen> I even stated the version numbers.
23:43:22 <callen> Gracenotes: which is what I said.
23:43:39 <dons> pumpkin... i'm still unsure as to why things aren't safe...
23:43:40 <callen> p_l: i don't run windows applications from an ntfs mount.
23:43:49 * p_l uses case-sensitive windows, so he has weirder set
23:43:54 <Gracenotes> right. So don't worry about it... you can pastebin your recent .bash_history if you like *shrugs*
23:44:10 <pumpkin> dons: in the stream sense, they are in general
23:44:11 <pumpkin> I think
23:44:12 <callen> Gracenotes: if I can't reproduce the behavior, I'm not going to bother trying to fix it.
23:44:35 <Gracenotes> yeah, that's fine (?)
23:44:35 <callen> I imagine this chat room is logged by somebody out there, I pasted enough for someone to take a look if they care.
23:45:16 <pumpkin> dons: but something like replicateEachU 1 (toU [10]) (toU [1]) is unsafe if it doesn't fuse I think
23:45:25 <Mr_Giraffe> ello~
23:45:34 <Mr_Giraffe> do any of you guys use the haskell SDL bindings?
23:45:52 <Mr_Giraffe> (rather, should i even be using them?)
23:46:30 <dons> Mr_Giraffe: i've used them for a couple of things
23:46:30 <Gracenotes> callen: sure :) Also, here's John Hodgman holding a cute ferret: http://www.areasofmyexpertise.com/wp-content/uploads/2008/10/21.jpg
23:46:35 <dons> no problems.
23:46:41 <Gracenotes> :\
23:46:44 <dons> pumpkin: hmm
23:47:03 <Mr_Giraffe> dons: it's not that i'm having a problem per se
23:47:13 <pumpkin> I've definitely seen lots of crashes because of things like that, and if I'm understanding correctly, the non-fusion is what causes them
23:47:16 <ddarius> Gracenotes: All ferrets look like that (modulo coloring)
23:47:25 <Mr_Giraffe> i'm just wondering how to do masking in the haskell as opposed to in C++
23:47:42 <Gracenotes> ddarius: hrm, that's a large equivalence class, I'd say
23:48:11 <Mr_Giraffe> in haskell*
23:49:24 <ddarius> Gracenotes: There aren't that many coloring patterns for ferrets.  I had two a long time ago.  One that looked pretty much exactly like that one and another that had a gray/white closer to solid coloring.
23:50:18 <Lemmih> dons: What have you been using them for?
23:51:20 <Gracenotes> ddarius: oh, okay. I'm curious, how were they as pets? Did you let them run around (the house)?
23:51:55 <Mr_Giraffe> dons: is setColorKey (not) doing something that i'm not aware of?
23:51:58 <ivanm> it's illegal to keep ferrets as pets in (at least most of) Australia...
23:52:12 <pumpkin> case FerretColor of BlackWhite -> ...; GrayWhite -> ...; _ -> error "not possible"
23:52:22 <p_l> some people keep them as programmers
23:52:28 <ivanm> p_l: heh
23:52:45 <p_l> they approach code monkey (ferrets?) levels
23:53:02 <p_l> read "it sometimes even compiles" ;-)
23:53:36 <p_l> otoh, someone once made a cat play with keyboard, and generated source ran once fed into perl
23:54:18 <ivanm> p_l: yes, but what did that perl code do?
23:54:48 <ivanm> at least if it was Haskell, it's easier to prevent random code from formatting your computer or something (let alone launching nuclear missiles...)
23:55:21 <ddarius> Gracenotes: Yeah, they were out most of the time.  They're entertaining as heck to watch.  They are noticably less friendly than dogs (with people and with other animals), but they'll get along well enough (we had two > 70lb dogs at the time as well).
23:55:36 <ddarius> They do crap behind furniture quite often.
23:55:43 <Gracenotes> oh :)
23:55:49 <ivanm> ddarius: sure it wasn't that the dogs intimidated them into behaving? ;-)
23:56:15 <ddarius> ivanm: The dogs were more intimidated by them.
23:56:22 <ivanm> heh
23:56:36 <lament> in a room with two 70lb dogs I would probably also crap behind the furniture.
