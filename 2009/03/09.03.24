00:03:13 <wli> Yet another interpreter is probably not needed.
00:07:03 <dons> blackh: you should publish some benchmarks about hexpat...
00:07:11 <dons> since speed is the main differentiator
00:08:25 <blackh> dons: Hello! What do you think would be helpful?
00:08:55 <dons> well, run the expat benchmarks on hexpat, xml, haxml and hxt
00:09:07 <dons> publish the results :)
00:09:12 <dons> then we'll know something we don't know now
00:09:57 <dons> haxml:6k downloads; hxt: 3k; xml: 1.6k; hexpat:0.4k -- but its probably the fastest by far
00:09:59 <blackh> OK - I'll do that.  I was thinking of making an announcement anyway.  I've finished changing the API now.
00:10:41 <dons> btw, i don't know if i told you this, but i was 20% of the way through a hexpat binding when you announced yours :)
00:10:48 <dons> i abandoned work at that point
00:10:51 <dons> :)
00:12:44 <blackh> :)  I like speed! Speed is very good!
00:13:02 <joga> don't take too much
00:13:14 <dons> all these monad libraries need use cases and examples
00:13:28 <dons> i'd never know when to use half of them
00:14:07 <wli> I can't even figure out when to use MonadCont
00:14:47 <dons> hmm. hackage doesn't display dependencies listed under conditionals
00:14:56 <dons> e.g. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/string-combinators-0.2
00:15:00 <dons> dcoutts_: ^ known bug?
00:15:07 * dons is lazy and doesn't check the hackage trac
00:16:12 <Mr_Awesome> is there any way to combine two patterns into one so i don't have to repeat the rhs of the function definition?
00:17:46 <wli> I'm going to go back to getting a calculator going end-to-end and try to extend it with things again.
00:20:27 <dons> i'm thinking about packages differently now I know the actual download stats
00:22:33 <dons> Cale: don't you think its kinda weird we didn't really know about haskell libraries till the last year or two. It was chaos for nearly 18 yearrs
00:52:51 <dons> sjanssen: the new HD level of resolution on youtube works pretty well for screencasts http://www.youtube.com/watch?v=2Lqzygxvus0
00:53:05 <dons> click the HD button
00:55:30 <dolio> Videos with practically no motion are about all it's good for on my machine. :)
00:56:04 <dons> heh
00:56:07 <dons> bandwidth?
00:56:58 <dolio> No. Flash just can't draw more than about 1/2 FPS on that setting.
00:57:11 <dons> ah
00:57:58 <dolio> I assume that's because the linux flash plugin totally sucks.
00:58:14 <monadzilla> I like this nick
00:58:44 <dons> only a couple of hours left in the haskell poll competition!!
00:58:48 <dons> polls close in 2 hrs
00:59:08 <wli> dons: CPO-STV?
00:59:09 <dons> dolio: hmm. seems ok here. but maybe i'm using the official x86_64 linux flash?
00:59:33 <dolio> Well, my computer is also 4 years old.
00:59:35 <wli> Hmm. One could implement user-defined operators by calling buildExpressionParser at runtime.
00:59:40 <dolio> But, still...
01:00:02 <monadzilla> dons: what is the competition?
01:01:19 <dons> to choose the new haskell logo
01:01:21 <wli> feh, no postfix operators
01:01:35 <wli> Oh, for that I'd use CSSD or CWP.
01:01:46 <monadzilla> ahh
01:01:58 <monadzilla> I should vote
01:09:22 <wunki> some nice logo's in the poll competition...
01:09:32 <wunki> tough choice
01:10:58 * wunki chooses logo #19
01:12:13 <seoushi> I liked 19 as well.. I would say 70 is better but it sorta looks like ruby on rails
01:12:27 * wunki looking at 70
01:13:03 <wunki> hmmm, to shiny for me.. :)
01:13:15 <wunki> how do I place a vote?
01:13:43 <seoushi> you have to have a ballot... http://www.haskell.org/pipermail/haskell-cafe/2009-March/057895.html
01:14:38 <wunki> ah, no voting for me :)
01:15:15 <seoushi> me either but I haven't been in the community long enough to feel like I have a say so it's all good
01:15:22 <wunki> same
01:15:46 <wunki> well, let's hope they also like 17
01:16:35 <seoushi> 17 is a bit too somple for me, having an icon is a good idea imho
01:16:40 <seoushi> err simple
01:16:54 <jml> which page has the logos?
01:16:59 <seoushi> http://www.haskell.org/logos/poll.html
01:17:13 <wunki> http://www.haskell.org/logos/poll.html
01:17:14 <jml> thx
01:17:47 <seoushi> I like the narwhal as well :)
01:17:55 <wunki> # ?
01:18:00 <jml> wow, heaps more than we got for the Launchpad logo comp :)
01:18:07 <seoushi> 106
01:18:16 <osfameron> etoomanylogos ;-)
01:18:24 <seoushi> same as the haskell/reddit logo
01:18:53 <wunki> 106: a unicorn sealion?
01:18:56 <osfameron> I like the >>= logos
01:19:01 <seoushi> narwhal
01:19:02 <jml> a lot of good ones though
01:19:17 <monadzilla> my favorite is this one
01:19:18 <monadzilla> http://www.haskell.org/logos/logos/Lenny1b0.png
01:19:34 <monadzilla> or this http://www.haskell.org/logos/logos/logo6000.png
01:19:51 <wunki> you like simplicity :)
01:19:57 <monadzilla> yep :)
01:20:06 <seoushi> some of them I don't understand why they were accepted like #56
01:20:14 <wunki> Lenny is nice
01:20:17 <seoushi> you can't even read the thing lol
01:20:19 <osfameron> because they were submitted
01:20:32 <osfameron> and there is no cabal ;-)
01:20:38 <osfameron> (except *that* cabal obviously)
01:20:43 <seoushi> fair enough
01:20:49 <wunki> (haha, a narwhal is an actual beast, how cool..)
01:21:48 <seoushi> I think the only reason I like it is because it was in the first futurama movie (probably why others like it as well). On a more serious note I wouldn't want it to be the offical logo.
01:22:12 <monadzilla> which one?
01:22:19 <seoushi> 106
01:22:41 <monadzilla> i think others like it because narwhals are a huge internet meme lately
01:23:20 <monadzilla> if someone made a narwhal shaped like a lambda, that would be cool
01:24:04 <osfameron> yeah I'm worried the narwhal will win
01:24:05 <osfameron> I say "worried", I guess there are other far more worrying things...
01:24:07 <seoushi> I don't see how it would look right without it's back being broken or having the nickname tripod
01:26:00 <monadzilla> it could be similar to the narwhal in 106 but with the fin outstretched more
01:26:10 <monadzilla> just do the narwhal from a different angle
01:27:25 <zeno> which is more recent sourceview or gtksourceview2
01:31:30 <seoushi> I'm not sure but I believe sourceview is just a lib and gtksourceview is the gtk interface of it.. could be wrong
01:47:02 <zakwilson> gtksourceview is a C library for GTK for displaying source code: http://projects.gnome.org/gtksourceview/
01:54:16 <kadaver> which video decoder library would you recommend doing a FFI to?
01:56:36 <wli> wtf. does lexeme do anyway?
01:56:44 <kadaver> > Data.List.sortBy snd [(2,3),(1,4)]
01:56:46 <lambdabot>       Occurs check: cannot construct the infinite type:
01:56:46 <lambdabot>        b = (a, b) -> ...
01:57:01 <kadaver> how do I pass a comparartor to soem sortfunction
01:59:13 <seoushi> the compare function needs to return LT, GT or EQ when given two inputs I believe
01:59:33 <kadaver> > Data.List.sortBy (<) [2,3,1,4]
01:59:34 <lambdabot>   Couldn't match expected type `Ordering'
02:00:36 <kadaver> Ord.orderBy
02:00:40 <kadaver> > Ord.orderBy
02:00:41 <lambdabot>       Failed to load interface for `Ord':
02:00:41 <lambdabot>        Use -v to see a list of the ...
02:00:51 <kadaver> > orderBy
02:00:52 <lambdabot>   Not in scope: `orderBy'
02:01:17 <dibblego> kadaver, what are you looking for?
02:02:46 <seoushi> kadaver, something like this? Data.List.sortBy (\a b -> compare (snd a) (snd b))  [(2,4),(1,3)]
02:03:23 <ejt> > sortBy (comparing snd) [(2, 4), (1, 3)]
02:03:24 <lambdabot>   [(1,3),(2,4)]
02:13:31 <wli> fixity decls at the prompt; yay
02:13:56 <kadaver> yes
02:14:13 <kadaver> learn me a college degree for greayt good?
02:15:53 <seoushi> simple question: I'm defining some data types and two of them have the same internal field names, apparently that isn't allowed. Do I have to prefix everything with hungarian like notation like they do in RWH or is there a nicer way to do it?
02:17:13 <ejt> seoushi: hungarian, or put each type in a seperate module and qualify the accessors
02:17:29 <wli> > unfoldr Map.maxView $ Map.fromList [(3.5,"quagga"),(2.0,"aardwolf"),(5.3,"echidna")]
02:17:30 <lambdabot>   ["echidna","quagga","aardwolf"]
02:17:43 <seoushi> ejt, thanks
02:25:39 <wunki> can someone tell me how to put the Haskell-cafe mailing list in a seperate mailbox in mutt?
02:26:05 <wli> use procmail.
02:26:10 <ejt> wunki: procmail is good for filtering
02:26:44 <wunki> ok, and procmail will fetch the mailing list for me?
02:28:31 <rittyan1> emacs users, what indentation function you are using in haskell-mode?
02:28:32 <wunki> ah, nm, stupid question..
02:29:19 <ejt> wunki: there is a procmail channel
02:33:53 <enkrav> Hello, I have written an array insertion sort using the ST monad but I am not really satisfied with the performance...  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1970#a1970
02:33:58 <quicksilver> rittyan1: kuribas's patched indentation mode
02:34:02 <quicksilver> @where kuribas-indentation
02:34:02 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
02:34:05 <quicksilver> rittyan1: that one.
02:34:12 <enkrav> if somebody could tell me if I did something obviously wrong.
02:34:29 <enkrav> I would be glad
02:35:35 <quicksilver> looks like bubblesort to me?
02:36:18 <yitz> rittyan1: I use the haskell-mode that comes with Debian. I'm not sure if that includes kuribas indentation, but it works fine for me.
02:36:25 <quicksilver> it doesn't.
02:36:30 <quicksilver> kuribas one is much better.
02:36:50 <rittyan1> quicksilver, I just enable haskell-indentation-mode and it just works?
02:37:02 <enkrav> quickSilver: it really looks like insertion sort to me
02:37:08 <yitz> works well enough no make it not worth it to deal with yet another manually installed piece of software.
02:37:09 <quicksilver> rittyan1: yes. You need to not enable (or disable) the old indent-mode
02:37:12 <rittyan1> yitz, 1) i will never use debian in my life 2) haskell-mode doesn't work for me, that one that comes with gentoo
02:37:29 <enkrav> it's just that the C implemenation is about 25 times faster
02:37:42 <quicksilver> enkrav: it only ever swaps adjacent elements.
02:37:48 <quicksilver> how can that be insertion sort?
02:37:52 <yitz> rittyan1: make a gentoo ebuild for kuribas indentation then
02:38:00 <quicksilver> it hardly needs an ebuild
02:38:03 <rittyan1> yitz, or put it into ~/elisp/ ;)
02:38:04 <quicksilver> it's one .el file
02:38:09 <quicksilver> just put it into your elips directory :P
02:38:22 <quicksilver> I can't remember what eventually drove me off the haskell-mode
02:38:31 <quicksilver> I *think* it got confused by some construct I use fairly often.
02:38:31 <wli> Ugh, I'm totally failing to get MonadCont to exit properly.
02:38:54 <yitz> rittyan1: or use arch linux, which comes with all haskell goodness imaginable.
02:39:06 <quicksilver> but anyhow, kuribas' one does a far better job of enumerating the valid indentation choices.
02:39:49 <enkrav> quicksilver: well bubble or insertion does not really matter since the c implementation is identical
02:40:12 <yitz> quicksilver, rittyan1: manual installs always start out seeming simple. then, two years later when things change and you don't remember what you installed or how, you spend hours figuring out how to fix what is broken.
02:40:48 <rittyan1> yitz, not with emacs... it hardly changed since dinosaurs era
02:40:50 <quicksilver> yitz: in general I have some sympathy with that argument.
02:40:57 <rittyan1> though yes I do not like manual instals
02:41:02 <quicksilver> yitz: in the specific case of emacs and elisp
02:41:12 <quicksilver> the intended use of emacs is that you do a bit of lisp customisation
02:41:19 <yitz> rittyan1: not true, emacs has been one of the culprits for me in the past
02:41:22 <quicksilver> maintaining a few .el files of your own is a price easily worth paying.
02:41:38 <quicksilver> enkrav: OK, but it's not insertion sort :)
02:41:44 <quicksilver> enkrav: what options did you use to compile it?
02:41:56 <enkrav> -O2
02:42:04 <quicksilver> enkrav: can you paste teh C code too?
02:42:14 <yitz> quicksilver: and exactly where are those .el files? and exactly where is the line in the config file that makes emacs use it? there are thousands of possible combinations.
02:43:11 <reified> hi everyone, anyone here done any work on model transformation using Haskell?
02:43:12 <yitz> so now i let debian maintain those .el files for me, and i don't have to remember nor relearn emacs every year or two.
02:43:27 <rittyan1> cool
02:43:36 <enkrav> quicksilver, here is the c code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1971#a1971
02:43:37 <rittyan1> i am using ubuntu at work and i have manual installs of haskell goodness
02:43:40 <rittyan1> go figure
02:43:44 <quicksilver> yitz: the .el files are in ~/elisp; the line in the config file is of course in ~/.emacs
02:44:00 <quicksilver> yitz: I'll thank you not to tell me the way I'm using emacs is "wrong"; I think I know what I'm doing.
02:44:03 <yitz> and yes, that means i occasionally need to press the backspace key a few times to get the indentation the way i like it. worth it to me.
02:44:37 <yitz> quicksilver: oh no, please, i am expressing no opinion about your emacs style. just describing my own. :)
02:47:20 <quicksilver> enkrav: there are certainly differences between your two code samples. the inner loop counts down from i to 0 in the C; it counts down from n to i in the haskell.
02:47:34 <quicksilver> I suspect it doesn't matter but it makes it hard to compare them
02:48:53 <enkrav> I think the haskell loop2 also goes from i to 1
02:49:12 <enkrav> as I call it with "loop2 arr i"
02:49:15 <yitz> quicksilver: or /usr/lib/emacs/elisp or /usr/local/lib/elisp/ or /usr/lib/emacs/2.22/elisp or /etc/emacs22/site-start.d or /opt/local/lib/emacs/2.22/elisp or who knows where else
02:49:34 <enkrav> and the condition is i>1
02:49:53 <quicksilver> yitz: well I content myself with only two sets of elisp (a) that install with my emacs package (b) that I install by hand in ~/elisp.
02:50:01 <quicksilver> yitz: only two places to look - within the bounds of sanity.
02:50:03 <yitz> fair enough
02:50:47 <ejt> yitz: I think you'll find most long term emacs users drags round a set of elisp files with them - I've got code in my elisp dir from '93
02:51:24 <quicksilver> enkrav: the C++ code doesn't even work.
02:51:37 <quicksilver> enkrav: ./csort 10 gives "2 4 0 0 4 2 4 0 0 4 End"
02:51:39 <quicksilver> that's not sorted.
02:51:52 <yitz> I am a long term emacs user and I used to have that too. now I threw them all away and just use what is available in packages on whatever platform I am on - which is quite robust on most platforms nowadays.
02:52:05 <kadaver> what is it called when you zero the modem?
02:52:10 <enkrav> quicksilver, sorry
02:52:27 <enkrav> quicksilver, when I fix the whole experiment I will tell what the results are
02:52:29 * wli succeeds in using MonadCont
02:53:32 <quicksilver> enkrav: you want 'j' not 'i' in the inner loop
02:53:39 <quicksilver> enkrav: (all a[i] need to be a[j])
02:53:56 <quicksilver> then they at least both compile although they work on different data
02:54:00 <quicksilver> s/compile/sort/
02:54:15 <dbbddbdb> Hi!  What does «Functor ((→) (a → b → a))» in «(Num a, Functor ((->) (a -> b -> a))) => b -> a» mean?
02:54:40 <yitz> enkrav: don't forget to compile with -O2 for this kind of thing
02:54:43 <wli> repl :: (MonadIO m, MonadCont m, MonadState OpMap m) => m ()
02:55:41 <wli> It barely parses exprs, but it has fixity decls.
02:55:50 <kadaver> benchmarks are pointless, under real world conditions haskell will pwn everythign else
02:56:00 <enkrav> OK, now the difference is only 5 or so
02:56:13 <quicksilver> enkrav: having fixed those two problems, I see a 3.5x difference
02:56:25 <quicksilver> which sounds about right
02:56:29 <quicksilver> haskell array access is 'safe'
02:56:34 <quicksilver> (ever access is bounds checked)
02:56:38 <enkrav> ok
02:56:40 <quicksilver> that will be part of the difference.
02:56:57 <quicksilver> and part of the difference will gcc's better code generator
02:57:03 <enkrav> yes, it is very acceptable
02:57:06 <quicksilver> (unrolling loops and scheduling)
02:57:18 <enkrav> maybe I could try fviac
02:57:31 <kadaver> which video decoder library would you recommend doing a FFI to?
02:58:09 <yitz> enkrav: you could probably do better by allocating some memory manually and poking around in it with pointers, but why bother with that?
02:58:57 <enkrav> yitz only for curiosity I suppose, not for real work
02:59:20 <quicksilver> there are unchecked read/write operations
02:59:26 <quicksilver> I don't remember where they are though
02:59:28 <enkrav> just to have the warm feeling that if I need I can
02:59:36 <quicksilver> @hoogle unsafeWrite
02:59:37 <lambdabot> Data.Array.Base unsafeWrite :: (MArray a e m, Ix i) => a i e -> Int -> e -> m ()
02:59:58 <yitz> in real life Data.List.sort has always been sufficient for me
03:01:20 <quicksilver> enkrav: unsafeWrite/unsafeRead shaves a further 25% off the runtime for me
03:01:29 <quicksilver> enkrav: giving C a remaining 2.5x advantage
03:01:48 <quicksilver> I put that down to code gen + loop unrolling, I think
03:02:07 * ivanm just came into this conversation, but wonders why quicksilver is advocating unsafe functions...
03:02:14 <yitz> heheh
03:02:20 <quicksilver> ivanm: bounds checking is an array overhead
03:02:26 <ivanm> oh, for _arrays_
03:02:30 <quicksilver> ivanm: enkrav was curious why his array code was slower than the C stuff.
03:02:45 <ivanm> I thought you were talking about unsafe IO stuff
03:03:08 <quicksilver> enkrav: there is active work on the GHC codegen, and we hope to see some of that remaining advanage knocked off.
03:03:16 <quicksilver> and there are even some people talking about unrolling
03:03:19 <quicksilver> although that's a bit harder.
03:04:41 <yitz> it makes more sense to invest effort in better utilizing multiple cores than in shaving off another one or two percent on a single one
03:04:51 <quicksilver> that's certainly true
03:05:02 <quicksilver> however there is still about 80% left to shave off a single core
03:05:07 <quicksilver> that's quite a generous beard.
03:06:54 <yitz> even 80% - if cores increase with moore's law you'll quickly overtake that
03:07:16 <yitz> though 80% is certainly tempting
03:08:21 <sjanssen> yitz: I don't think this argument makes very much sense
03:08:29 <osfameron> if functional languages really prove to scale better to new technology we'll find ourselves in the odd situation where someone writes a backend to gcc to compile C to haskell :-)
03:08:41 <sjanssen> for one, we don't know how to magically parallelize serial programs
03:08:41 <yitz> sjanssen: we're arguing? :)
03:09:13 <sjanssen> yitz: I mean "it makes more sense to invest effort in better utilizing multiple cores ..."
03:12:15 <yitz> sjanssen: serial data dependencies will always be an inherent limiting factor, it's true. but we're obviously still very primitive in our automated use of multiple cores. so i am claiming that research effort in that direction is likely to be more efficient in speeding up general use code.
03:12:50 <wli> A lot of C code is only impure by dint of serial data dependency expressed via memory modification.
03:12:51 <sjanssen> yitz: from a compiler writer's view, I don't think that is quite true
03:13:37 <sjanssen> work on parellelism requires breakthroughs, but most of the problems with GHC's backend have already been solved by others
03:15:04 <paolino> anyone can suggest the easiest way to support haxr with http ?
03:15:09 <yitz> sjanssen: true. so your saying it's orthogonal effort
03:15:15 <yitz> you're
03:16:14 <sjanssen> yitz: I'm saying I want both and that we shouldn't discount the value of either
03:16:19 <wli> Certain sorts of C code are amenable to transformations carrying memory allocated structures to compiler-managed heap nodes, but it sounds incredibly difficult to automate, requiring inter-procedural and inter-module analysis if not entirely infeasible due to computability or algorithmic complexity.
03:16:54 <yitz> sjanssen: anyway i think a lot of future progress on core utilization may depend on architecture advances as well
03:17:17 <yitz> wli: some of those become much easier in pure functional language.
03:17:22 <wli> What kinds of architectural advances?
03:18:03 <yitz> wli: memory that is well-suited to parallel gc for example
03:18:09 <yitz> in hardware
03:18:23 <wli> yitz: Well, this would be something like translating C to moderately idiomatic Haskell vs. brute-force translations to raw memory manipulation in Haskell.
03:19:43 <yitz> i would like to see memory that can be read-only in parallel for many cores simultaneously, writable by one dedicated core. seems like that ought to be feasible.
03:21:00 <HugoDaniel> what are the results of the logo competition ?
03:21:58 <cjs> :w
03:22:29 <blackh> HugoDaniel: I think we have to wait another hour and a half.
03:22:38 * blackh wants a new cup
03:22:49 <wli> yitz: IOW a CREW vs. an EREW?
03:23:36 <wli> Hmm. I wonder how to avoid having to pass the exit continuation as an arg all the time.
03:25:12 <Saizan> use a Reader?
03:26:15 <kadaver> benchmarks are pointless, under real world conditions haskell will pwn everythign else
03:26:19 <kadaver> which video decoder library would you recommend doing a FFI to?
03:27:02 <ivanm> kadaver: recommend in terms of ease of doing so, or which people would like to see/use?
03:27:20 <kadaver> like to use see
03:27:55 <ivanm> maybe matroska?
03:28:07 <ivanm> (seeing as how it's free/open)
03:28:38 <yitz> @yow -- wli
03:28:39 <lambdabot> We have DIFFERENT amounts of HAIR --
03:31:37 <C-Keen> hm, I have installed libreadline from mac ports and I have told cabal to look for it in --extra-include-dirs --extra-lib-dirs I also have installed the GNU.framework for mac but it still fails...any suggestions?
03:37:19 <dcoutts> C-Keen: you're doing cabal install readline?
03:38:04 <dcoutts> sadly, the readline package uses a ./configure script that does not respect the --extra-include-dirs --extra-lib-dirs flags
03:38:15 <C-Keen> dcoutts: ah ok
03:38:21 <C-Keen> dcoutts: so I run it manually
03:38:36 <dcoutts> from reading it, it looks like it uses a couple env vars
03:38:37 <dcoutts> READLINE_INCLUDE_DIRS=
03:38:37 <dcoutts> READLINE_LIB_DIRS=
03:39:29 <C-Keen> dcoutts: also ./configure --with-readline-{includes,libraries]= works
03:39:33 <C-Keen> dcoutts: thanks
03:40:32 <dcoutts> the Setup.hs for readline ought to translate --extra-include-dirs --extra-lib-dirs flags into --with-readline-{includes,libraries]=
03:43:37 <wli> repl :: (MonadIO m, MonadCont m, MonadReader (() -> m ()) m, MonadState OpMap m) => m () doesn't seem to be able to peel off ReaderT very effectively.
03:43:46 <C-Keen> dcoutts: hm, when I run configure manually I can cabal build, but cabal install will start with a clean copy making my configure run vanish
03:43:55 <dcoutts> C-Keen: yep
03:44:04 <dcoutts> C-Keen: try setting the env vars
03:44:30 <C-Keen> dcoutts: setting the env variables also has no effect (I used export in my shell) probably because it is starting in a fresh environment>
03:44:58 <dcoutts> C-Keen: oh, hmm.
03:45:02 <temoto> @src Point
03:45:02 <lambdabot> Source not found. Where did you learn to type?
03:45:15 <temoto> :t Point
03:45:16 <lambdabot> Not in scope: data constructor `Point'
03:45:25 <temoto> Please, help.
03:45:29 <dcoutts> C-Keen: if you're keen you could patch the Setup.hs properly and send the patch in for the benefit of everyone. I'm opening a ticket.
03:46:01 <wli> Using ReaderT here seems to involve some pain.
03:46:08 <C-Keen> dcoutts: Setup.hs is very minimal :)
03:47:25 <wli> Using ReaderT to store the continuation seems not to be getting far.
03:48:07 <dcoutts> C-Keen: yes, it'd involve using defaultMainWithHooks and using a configure hook to pass extra args to configure
03:48:12 <C-Keen> dcoutts: which darcs repo should I base my work against?
03:48:27 <C-Keen> dcoutts: ah
03:48:33 <C-Keen> ok
03:48:37 <dcoutts> C-Keen: http://darcs.haskell.org/packages/readline/
03:48:53 <dcoutts> C-Keen: you'd want to refer to the code in Cabal, to see what happens for configure at the moment
03:49:01 <dcoutts> C-Keen: to see how it calls ./configure
03:49:54 <C-Keen> alright
03:52:40 <rittyan1> http://paste.pocoo.org/show/109325/ <- that's how I work with json. Is there a way to avoid functions I declared, such as 'query', 'from', 'datetime' etc? or should I name them as 'getQueryFromAttackReport'? That's kind of fugly
03:54:17 <quicksilver> rittyan1: I tend to name them arQuery, arFrom, arDatetime etc
03:55:03 <rittyan1> quicksilver, so there is no way and this is normal? (i'm new to the language)
03:55:57 <rittyan1> quicksilver, yes such naming scheme looks better
03:55:59 <rittyan1> thanks
03:56:52 <quicksilver> rittyan1: alternatively put the type in a module and don't export the selectors.
03:57:52 <rittyan1> I thought about it
03:59:33 <wli> After some headaches it seems to have been rammed through.
04:01:38 <dcoutts> C-Keen: I've filed: http://hackage.haskell.org/trac/ghc/ticket/3121
04:02:04 <wli> main = flip evalStateT Map.empty . flip runContT return . callCC $ runReaderT repl
04:03:52 <wli> repl :: (MonadIO (t m), MonadTrans t, Monad m, MonadReader (() -> m ()) (t m), MonadState OpMap (t m)) => t m ()
04:04:30 <wli> Look at my monad transformer stack and fear me.
04:04:55 * Saizan fears
04:04:55 <solidsnack_> wli: Wow.
04:05:08 <solidsnack_> what the heck, my nick is taken
04:05:26 <bobshush> is there an online version of djinn?
04:05:30 <Saizan> i tend to use at least one concrete top-level transformer though
04:05:55 <wli> It's not every day that I do something like exit  <-  asks (($ ()) . (lift .))
04:06:18 <quicksilver> bobshush: well, lambdabot is online and you can use it in a private message :)
04:06:26 <quicksilver> bobshush: I'm not aware of a web-based one though.
04:07:21 <bobshush> how do i do private messages? :P
04:07:33 <solidsnack> type /quit
04:07:38 <solidsnack> or, i mean
04:07:47 <solidsnack>  /msg lambdabot
04:07:48 <sioraiocht> dcoutts: pong
04:07:57 <sioraiocht> dcoutts: sorry, I was in london all weekend, just got back =)
04:09:49 <lepassive> @hoogle Show
04:09:49 <lambdabot> module Text.Show
04:09:49 <lambdabot> Prelude class Show a
04:09:49 <lambdabot> Text.Show class Show a
04:12:12 <lepassive> where is class Show def in GHC source code ?
04:12:39 <Olathe> @index show
04:12:39 <lambdabot> Text.Show, Prelude
04:13:08 <lepassive> Olathe, I see class Show in Show.LHS file is it ?
04:13:45 <Olathe> http://hackage.haskell.org/packages/archive/base/3.0.2.0/doc/html/src/GHC-Show.html
04:13:57 <wli> I'm not entirely sure how to shorten do { exit <- asks (($ ()) . (lift .)) ; exit }
04:14:00 <bobshush> @djinn a -> a
04:14:00 <lambdabot> f a = a
04:14:24 <lepassive> Olathe, okay thanks
04:14:38 <Olathe> You're welcome.
04:14:48 <Saizan> wli: btw, why not just MonadReader (m ()) (t m) ?
04:14:52 <Olathe> @undo do { exit <- asks (($ ()) . (lift .)) ; exit }
04:14:52 <lambdabot> asks (($ ()) . (lift .)) >>= \ exit -> exit
04:15:18 <Olathe> asks (($ ()) . (lift .)) >>= id
04:15:18 <Saizan> wli: i.e. applying ($ ()) when you store the continuation rather than when you use it
04:15:19 <wli> Saizan: I had trouble with that for whatever reason.
04:15:30 <ejt> wli can't you use join ?
04:15:34 <BONUS> (>>= id) = join
04:15:35 <BONUS> yeah
04:15:37 <BONUS> agh beaten
04:15:40 <ejt> :)
04:15:54 <solidsnack> :t join
04:15:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:16:06 <solidsnack> oh, duh
04:16:43 <wli> Saizan: The continuation monad constrains things weirdly.
04:17:03 <C-Keen> dcoutts: have you got an example, how I am supposed to build a confHook?
04:18:44 <bobshush> @djinn m (m a) -> m a
04:18:44 <lambdabot> -- f cannot be realized.
04:18:57 <bobshush> can djinn not derive join?
04:19:07 <ejt> it doesn't know it's a monad
04:19:08 <TSC> Wouldn't it need the Monad constraint?
04:19:12 <wli> @type callCC . runReaderT
04:19:13 <lambdabot> forall b (m :: * -> *) a. (MonadCont m) => ReaderT (a -> m b) m a -> m a
04:19:27 <bobshush> @djinn (Monad m) => m (m a) -> m a
04:19:27 <lambdabot> Error: Class not found: Monad
04:19:54 <bobshush> @type join
04:19:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:20:24 <bobshush> @djinn forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:20:24 <lambdabot> Cannot parse command
04:20:44 <lepassive> @where Haskell vs OOP
04:20:44 <lambdabot> http://haskell.org
04:20:58 <lepassive> lambdabot, :@
04:21:39 <bobshush> is there any way to tell djinn join is a monad?
04:22:36 <quicksilver> bobshush: join isn't a monad :)
04:22:38 <quicksilver> join is a funciton.
04:22:53 <quicksilver> I'm not sure djinn understands type classes at all.
04:23:33 <bobshush> *m a is a monad?
04:24:13 <Saizan> m a is a "monadic action" or "monadic value" if m is a monad
04:25:43 <bobshush> quicksilver: hmm. what information would it need to be able to derive these sorts of things?
04:26:19 <wli> Saizan: I got it.
04:27:10 <quicksilver> bobshush: well if you added the monad laws to its axiom base
04:27:11 <bobshush> Saizan: its 4:30 am where i'm sitting, mumble mumble grumble.
04:27:15 <quicksilver> then it really wouldn't need much
04:27:27 <quicksilver> it would just need to be able to actually understand type class syntax
04:27:31 <quicksilver> which I don't think it does.
04:27:50 <Saizan> it understands typeclasses for types of kind *
04:28:12 <dcoutts_> C-Keen: yes, there's some examples about, lemme find one
04:28:14 <Saizan> well, it probably doesn't work well with higher-kinded types in general
04:29:02 <bobshush> kind * ?
04:29:08 <wli> I now have main = flip evalStateT Map.empty . flip runContT return . flip runReaderT (return ()) $ repl
04:29:22 <wli> And repl :: (MonadIO (t m), MonadTrans t, Monad m, MonadReader (m ()) (t m), MonadState OpMap (t m)) => t m ()
04:29:34 <wli> Right Quit      ->  join $ asks lift
04:30:23 <alar> how do I use C variable through FFI?
04:30:44 <wli> Saizan: Except that broke it.
04:31:01 <Saizan> wli: return () won't really exit
04:31:02 <alar> GHC produces strange errors when I try to follow FFI spec
04:31:20 <wli> Saizan: What will?
04:31:32 <Saizan> wli: you want something that discards the passed continuation
04:32:18 <Saizan> contructed with callCC if you want to keep the monad polymorphic
04:33:07 <wli> callCC . const $ return () ?
04:33:18 <wli> No dice.
04:33:32 <Saizan> ?type callCC
04:33:34 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
04:34:12 <dcoutts_> C-Keen: take a look at the Setup.hs for ghc-paths
04:34:20 <Saizan> ?type \m -> callCC (\k -> runReaderT m (k ()))
04:34:21 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => ReaderT (m b) m () -> m ()
04:34:44 <temoto> How to translate python "\n".join( ["item1", "item2"] )  ? It should reduce/fold list glueing "\n" between items.
04:34:48 <dcoutts_> C-Keen: but also look at Distribution.Simple in Cabal, to see the existing autoconfHooks postConf hook
04:34:59 <Saizan> ?type \m -> callCC (\k -> runReaderT m (k () >> return ())) -- if you want
04:35:01 <lambdabot> forall (m :: * -> *). (MonadCont m) => ReaderT (m ()) m () -> m ()
04:35:13 <bobshush> so a kind of * -> * is a thing that can take any type and return some sort of new type based on it?
04:35:30 <quicksilver> > intercalate "\n" ["item1","item2"]
04:35:31 <lambdabot>   "item1\nitem2"
04:35:35 <quicksilver> temoto: ^^
04:35:41 <temoto> quicksilver: thank you very much.
04:35:47 <temoto> rittyan1: ^^^
04:35:49 <Saizan> bobshush: yes, like Maybe, [], etc..
04:36:14 <bobshush> i see. i have learned something.
04:36:22 <temoto> @src intercalate
04:36:22 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
04:36:39 <Saizan> you can use :kind to ask for the kind of a given type
04:36:43 <bobshush> does djinn therefore not like lists, if it doesn't like higher kinds?
04:37:08 <bobshush> @kind [a]
04:37:09 <lambdabot> Not in scope: type variable `a'
04:37:18 <bobshush> :kind [a]
04:37:20 <Saizan> well, it doesn't like higher-kinded type variables, iirc
04:37:25 <Saizan> @kind []
04:37:26 <lambdabot> * -> *
04:37:29 <Saizan> @kind [Int]
04:37:31 <lambdabot> *
04:37:32 <bobshush> ah
04:37:36 <Saizan> @kind forall a. [a]
04:37:37 <lambdabot> *
04:38:10 <Saizan> however djinn doesn't like lists because they are a recursive type
04:38:18 <Saizan> but:
04:38:28 <Saizan> @djinn Maybe (Maybe a) -> Maybe a
04:38:28 <lambdabot> f a =
04:38:28 <lambdabot>     case a of
04:38:28 <lambdabot>     Nothing -> Nothing
04:38:28 <lambdabot>     Just b -> b
04:38:52 <bobshush> @djinn [[a]] -> [a]
04:38:52 <lambdabot> Error: Undefined type []
04:39:19 <wli> Saizan: Hmm. I can't figure out what the thing you wrote is doing.
04:39:56 <bobshush> undefined type []?
04:41:48 <Saizan> bobshush: djinn has its own list of definitions, you can see them with @djinn-env, better in private to not flood
04:43:17 <Saizan> wli: it's using callCC in the tranformed monad to get the current continuation (which will indeed abort the normal control flow when called), and then using it to run the given ReaderT action
04:44:42 <chessguy_work> so http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html#find.traverse looks to be a cool idea, but that section is apparently a mess, based on the comments. anybody done any fiddling with this?
04:48:57 <wli> Saizan: >> return () doesn't appear to be necessary.
04:51:10 <ivanm> does Jean-Philippe Bernardy frequent this channel?
04:51:11 <wli> I'm using flip evalStateT Map.empty . flip runContT return . callCC $ runReaderT repl . ($ ())
04:51:29 <HugoDaniel> is it possible to know the result of the logo poll ?
04:51:52 <ivanm> oh, I still have to vote for that...
04:51:55 <ivanm> is it still open? :o
04:52:40 * ivanm has 9 minutes by the looks of things...
04:52:57 <wli> Saizan: I understand this as \k -> runReaderT repl (k ()) where k is the continuation passed in via flip runContT return, so it unravels to return ()
04:54:51 <rittyan1> when I do 'words' (bytestring one) on bytestrings I get [Chunk "mystring" Empty] kind of list... how do I make it clean (strip all these chunks and empties)?
04:57:36 <HugoDaniel> i only voted on 4 logos
04:57:47 <HugoDaniel> the others were really bad
04:59:20 <ivanm> HugoDaniel: oh, I gave the benefit of the doubt to a few others
04:59:25 <ivanm> but in general, yes they were bad
04:59:29 * ivanm quite looks the current logo
05:05:22 <HugoDaniel> heheh
05:05:59 <HugoDaniel> after i did my logo, i read some geometric composition and typographic books
05:06:15 <HugoDaniel> and now i know that its very bad
05:06:40 <blackh> Looks like we have a winner.
05:06:52 <HugoDaniel> a clear winner ?
05:06:59 <HugoDaniel> can you paste the page please ?
05:07:11 <blackh> http://www.cs.cornell.edu/w8/~andru/cgi-perl/civs/results.pl?id=E_d21b0256a4fd5ed7
05:08:09 <HugoDaniel> oh :(
05:08:11 <HugoDaniel> a bind variation
05:08:16 <HugoDaniel> i really disliked those
05:09:09 <quicksilver> I disliked the bind ideas on principal (bind is not a central idea of haskell) but even of the bind ideas, I dislike the cold hard lines of that one.
05:09:21 <quicksilver> it's a very boring realisation.
05:09:25 <HugoDaniel> yes :/
05:09:43 <chessguy_work> this is just the first round, though, right?
05:09:44 <blackh> The voice of the people is the voice of the Almighty!
05:09:50 <quicksilver> the softer edges of 50 make it more attractive (although I'm not entirely sure about the colour scheme)
05:09:57 <quicksilver> chessguy_work: No. condorcet is a one-round voting algorithm.
05:10:01 <Baughn> @hoogle fsync
05:10:01 <lambdabot> No results found
05:10:02 <HugoDaniel> the one i liked the most for a t-shirt is the number 100 :)
05:10:13 <HugoDaniel> oh well, haskell is so much more than bind :/
05:10:17 <chessguy_work> "This is the first round of choosing a new Haskell logo. Depending on the outcome of this voting round, there might be other rounds for choosing a specific variation."
05:11:02 <Baughn> Hum. I'd've /liked/ to vote, but I never got anything but crashes from the thing
05:11:06 <quicksilver> chessguy_work: that's only if the winner had multiple variations.
05:11:10 <chessguy_work> HugoDaniel, i don't get that. what's the block supposed to symbolize
05:11:27 <quicksilver> we could vote between those three, I guess
05:11:31 <quicksilver> but they're basically the same.
05:11:55 <quicksilver> on the positive side, at least this logo has a strong recognisable shape and works in black and white and at different scales.
05:12:46 <blackh> I don't care. I just want something to put next to "powered by Haskell" on my web app!
05:13:26 <blackh> I liked the more curvy #50 better.
05:14:25 <blackh> It's simple and recognizable.
05:14:48 <HugoDaniel> yes
05:14:52 <ivanm> ummm..... that logo doesn't even _say_ "Haskell" :s
05:15:03 <osfameron> there's a winner already?
05:15:10 <ivanm> yeah, number 51
05:15:17 <quicksilver> ivanm: logos don't need to have words in
05:15:20 <ivanm> http://www.haskell.org/logos/logos/logo7000.png
05:15:24 <quicksilver> in fact, the most successful ones don't.
05:15:35 <ivanm> quicksilver: yes, but unless you recognise that as >>=, there's no way of knowing that it represents haskell
05:15:47 <osfameron> ah, I like the bind variants
05:15:54 <osfameron> anyway, languages don't really need logos
05:16:03 <chessguy_work> osfameron, hear hear
05:16:06 <quicksilver> there is no way of recognising that a flag fluterring in the wind with four coloured squares represents windows, ivanm
05:16:07 <HugoDaniel> hmm well, it could be recognized as a peculiar shape that is immediately associated with haskell
05:16:17 <gal_bolle> we should make a banner with that logo + "haskell"
05:16:23 <osfameron> I don't know the python/C/PHP/C#/F# logos, the Java one is horrid, Perl has 2, not widely used, etc.
05:16:27 <gal_bolle> it's normal practice to have both
05:16:33 <quicksilver> well yes
05:16:41 <quicksilver> you can obviously put words next to your logo if you want to :)
05:17:07 <gal_bolle> yes, but having an official design for when you want to is a good thing
05:17:12 <osfameron> the new one is at least more attractive to put on the haskell.org page than the current hodgepodge
05:17:27 <HugoDaniel> now haskell.org can have a merchandising section :)
05:17:43 <osfameron> yay!  will it sell lambdapotatoes?
05:17:45 <HugoDaniel> selling tshirts with the logo n.100
05:17:51 * bremner thinks the logo should be a page-long typing failure from ghc
05:17:57 <HugoDaniel> and some other "user created logos"
05:18:06 <wjt> bremner: :D
05:18:14 <rittyan1> I have a bytestring, I do B.words on it and I get list of chunks such as [Chunk "foo" Empty, Chunk "bar" Empty, ...]. Is there a way to strip this unnecessary information (such as Chunk/Empty), because when I do 'show' on a chunk I get "Chunk \"foo\" Empty" instead of just "foo".
05:18:44 <osfameron> what does logo 100 mean?  It's cute but I don't get the joke :-)
05:18:58 <chessguy_work> osfameron, yeah, i'm trying to figure out the same thing
05:19:00 <osfameron> (I assume it's a joke on the emergency exit sign, but what does it mean in haskell terms?)
05:19:24 <blackh> I read the comment on the old logo page - it's to do with Haskell's speed.
05:19:48 <osfameron> unpredictable and tricky to optmizie? ;-P
05:19:50 * osfameron ducks
05:19:57 <HugoDaniel> i like n.33
05:20:22 <agemo> rittyan1: I might have misunderstood you, but are you looking for 'map (\(Chunk s _) -> s)' ?
05:20:29 <HugoDaniel> the best one for a t-shirt is n.100
05:20:40 <ivanm> quicksilver: the difference is, they have brand power
05:20:48 <ivanm> we don't :(
05:21:01 <chessguy_work> wchogg :)
05:21:28 <osfameron> I like the palindrome puns for t-shirt designs too
05:21:45 <Baughn> osfameron: C will run around the stadium in two minutes. Haskell will walk backwards two meters, crossing the finishing line in three seconds.
05:21:50 <osfameron> like 109-110 and 101
05:21:51 <rittyan1> agemo, right... but I cannot find what module exports Chunk and Empty, it must be something from ByteString but... whatever I tried to import with these two functions I get errors about module not exporting these things
05:22:16 <Baughn> rittyan1: What are you trying to do, again? I don't think you're supposed to care about those constructors..
05:22:55 <Baughn> rittyan1: Data.ByteString.Lazy.toChunks is fine, if you really, really want to see the individual chunks.
05:23:11 <rittyan1> Baughn, I split bytestring using 'words', then I do some processing on strings and do 'show', serialize to json and drop to disk... the problem is that 'show' saves all that stuff, i.e. I get "Chunk" and "Empty" text in my json
05:23:44 <Baughn> rittyan1: Ah. And I don't suppose there's a read instance for lazy bytestrings.
05:24:20 <Baughn> rittyan1: Bytestrings are binary data, though. Can you normally store binary in JSON?
05:24:30 <Baughn> rittyan1: You might want to encode as base64 and store as a string
05:24:43 <quicksilver> bytestrings aren't necessarily binary data
05:24:55 <quicksilver> maybe rittyan1's are Char8 :)
05:25:04 <Baughn> ASCII. ^^;
05:25:24 <Baughn> rittyan1: Well, which is it?
05:25:41 <quicksilver> using 'show' on bytestring is the wrong thing to do, by the way.
05:26:08 <Baughn> It's fine for debugging, but I don't think I'd like using Show/Read to store data
05:26:20 <Baughn> Either Binary, or a Binary-like class for JSON?
05:26:40 <quicksilver> or just putStr the ByteString directly.
05:26:44 <quicksilver> depending what you are trying to do.
05:26:55 <HugoDaniel> im going to do a wallpaper based on the new logo :)
05:26:58 <quicksilver> if you're really trying to write JSON you'll need to use JSON's escape mechanism I guess
05:27:00 <Baughn> Well, JSON /is/ normally supposed to be human-readable ^^:
05:27:30 <Baughn> If it isn't, you shouldn't be using JSON. It's not the most efficient possible route for computer-only-readable stuff..
05:27:41 <quicksilver> Baughn: I presume JSON has a way to encode \n and \t though
05:27:43 <quicksilver> that kind of thing.
05:27:50 <quicksilver> and quotes embedded in quoted strings
05:27:56 <Baughn> Oh, sure, if you don't mind a three-fold size increase
05:28:18 <Baughn> It's got what JS has, which is "\x74" or so
05:28:28 <rittyan1> I am back
05:28:44 <Baughn> rittyan1: Actually, are you using Text.JSON?
05:28:46 <rittyan1> Baughn, I am using Lazy.Char8 module
05:28:51 <rittyan1> and yes I am using Text.JSON
05:29:27 <ivanm> how do the default (i.e. non-FGL) graphs work?
05:29:33 <Baughn> rittyan1: So, what's actually in the bytestrings? Just plain ASCII?
05:29:57 <ivanm> I'm trying to look at the types, but it doesn't seem to match my "intuition" of how a graph works (maybe I've been corrupted by FGL?)...
05:30:01 <wchogg> Heh, just saw that the logo vote is done.
05:30:10 <Baughn> rittyan1: Anyway, JSON (the class) already has an instance for bytestrings. You should be able to just say "showJSON bytestring".
05:30:12 <ivanm> oh, wait, duh, now I see it...
05:30:17 <ivanm> it's a "traditional" graph datatype
05:30:32 * ivanm realises that reading comments to type sigs also helps understanding them... :s
05:31:31 <dcoutts_> @seen Heffalump
05:31:31 <lambdabot> Heffalump is in #darcs and #haskell. I last heard Heffalump speak 14h 23m 24s ago.
05:32:28 <rittyan1> Baughn, yes plain ascii
05:32:35 <gerard_> if I write a function "findAny :: String -> String -> Int -> [String] -> [String] -> (Int, Int)"  to search for the first occurrence of one of the strings in one of the lists of strings, am I doing something wrong? It feels like I'm emulating the imperative state machine by using lots of parameters.
05:32:56 <dcoutts_> @tell Heffalump in that debian-haskell discussion on the cabal-debian stuff, it would be good to mention that we welcome suggestions for debian lint policy to be brought further upstream (where it makes sense) and checked at the hackage level.
05:32:56 <lambdabot> Consider it noted.
05:32:58 <rittyan1> Baughn, hm... okay... thouhg I don't like it
05:33:40 <dcoutts_> @tell Heffalump eg platform packages can be held to that slightly higher standard. Anything to automate the cabal -> native translation, even just spell checking the descriptions, fixing "api" -> "API" etc.
05:33:40 <lambdabot> Consider it noted.
05:34:21 <rittyan1> Baughn, maybe I better show the code and you will give me an advice closer to context?
05:34:47 <Baughn> rittyan1: Sorry, I've actually got to run now, but you could ask the channel
05:34:54 <rittyan1> okay, thanks anyway
05:36:27 <Baughn> @go hayoo
05:36:28 <lambdabot> No Result Found.
05:37:16 <temoto> @src intersperse
05:37:17 <lambdabot> intersperse _   []     = []
05:37:17 <lambdabot> intersperse _   [x]    = [x]
05:37:17 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
05:38:28 <rittyan1> Baughn, i just used unpack instead of show and it works :3 silly me
05:38:47 <Baughn> rittyan1: Or you could just use Text.JSON.encode.
05:40:33 <rittyan1> Baughn, http://paste.pocoo.org/show/109332/ <- here's my final (atm) code... I use encode on my own data type
05:41:05 <gwern> hm, let's take a look at the logo winners
05:42:01 <gwern> 1st place was http://www.haskell.org/logos/logos/logo8000.png 2nd place was http://www.haskell.org/logos/logos/Tshirt-l.png
05:42:15 <gwern> 3rd place http://www.haskell.org/logos/logos/Haskel_l.png
05:43:05 <zachk> i am not a decent enough haskell programmer. but a translation of this program to haskell would show off our reduced line count. http://www.hxa.name/minilight/ its a very small lines of code ray tracer
05:43:11 <aeolist> i for one welcome the new logo
05:43:14 <rittyan1> I like 1st and 3rd
05:43:26 <gwern> the 1st place isn't bad. I'm not too fond of 2 and 3, but they didn't win
05:43:27 <zachk> they already have the ray tracer translated into quite a few languages
05:43:33 * EvilTerran really quite likes the 1st
05:43:40 <gwern> I think I voted for 1st place as my 2nd or 3rd choice
05:43:48 <wchogg> I think the winning logo is cute.  Of course, I never thought anything was wrong with the old logo :p
05:44:16 <gwern> wchogg: your aesthetic taste must've shriveled up and died years ago then
05:44:21 <nlogax> i liked the narwhal
05:44:26 <wchogg> gwern : Actually it's vestigial.
05:45:09 <HugoDaniel> now haskell is a modern language, lets make lots of opengl demos with the new logo spinning around
05:45:28 * ivanm doesn't mind 2 or 3, but doesn't like 1 :s
05:45:40 <ivanm> gwern: I prefered the original logo as well...
05:45:42 <ivanm> maths++
05:45:47 <bob2> HugoDaniel: when did that happen?
05:46:01 <ivanm> bob2: the new logo? 45 minutes ago ;-)
05:46:29 <trofi^w> :t (>>\=)
05:46:31 <lambdabot> Not in scope: `>>\='
05:46:47 <trofi^w> @let (>>\=) = fix
05:46:49 <lambdabot>  Defined.
05:46:57 <ivanm> why do you want to do that?
05:48:02 <EvilTerran> >λ=
05:48:43 <zachk> that first place logo has really tight design. but its coloring isnt nearly as good as 2nd and 3rd
05:48:44 <trofi^w> exactly
05:48:56 <koeien> @oeis [1,240,2160,6720]
05:48:56 <lambdabot>  Sequence not found.
05:49:01 <zachk> ive noticed getting opengl working on linux is still a major pain as compared to windows
05:49:10 <byorgey> I was under the impression that once a design was chosen, there might be another round to choose colors etc.
05:49:16 <bob2> ivanm: oh, I meant "now haskell is a modern language" ;-)
05:49:18 <zachk> and its not just with haskell, python etc. need the libs need the libs
05:49:18 <ivanm> zachk: oh?
05:49:34 * ivanm doesn't recall having any problems here...
05:49:41 <ivanm> maybe you need a better distro? :p
05:49:42 <gwern> byorgey: well, there must be. #51 comes in multiple flavors
05:49:50 <zachk> ivanm: ubuntu is sucking for me
05:49:53 <byorgey> ok, good =)
05:50:14 <ivanm> gwern: yeah, I found that strange: some people had each colour a different entry, whilst others had one big entry :s
05:50:32 <ivanm> zachk: arch and gentoo are the distros that have the best haskell support
05:50:37 <gwern> ivanm: the former's loss
05:50:39 <ivanm> (AFAIK, anyway)
05:50:48 <koeien> gentoo?
05:50:54 <ivanm> gwern: not really, as it gave them extra entries to drive them up
05:50:54 <trofi^w> sure! :]
05:51:01 <ivanm> koeien: yes!
05:51:05 <koeien> didn't know that
05:51:11 <ivanm> we don't have as many packages as arch, because we're careful in how we package
05:51:11 <koeien> i prefer debian anyway ;)
05:51:14 <zachk> ivanm: yea i burned them. gentoo doesnt recognize my laptops ethernet. and arch i forget how to manually setup network configs.  its been like man like 8 years since i used a lot of linux
05:51:14 <ivanm> heh
05:51:30 <ivanm> zachk: how could it not recognize it?
05:51:41 <ivanm> unless its some funky proprietary module that only ubuntu has...
05:51:48 <ivanm> or do you mean the gentoo liveCD?
05:51:55 <zachk> ivanm: well arch picks it up
05:51:55 <trofi^w> etherenet? i don't believe
05:51:55 * ivanm has never installed Gentoo from the official installers
05:52:00 <gwern> ivanm: that doesn't make sense, wouldn't that just dilute their votes?
05:52:06 <zachk> ivanm: gentoo minimal install amd64
05:52:08 <quicksilver> ivanm: one of the advantages of condorcet is that splitting your alternative doesn't grant you an advantage.
05:52:11 <gwern> the republican party doesn't run 20 nominees, after all
05:52:17 <ivanm> gwern: could be...
05:52:26 <ivanm> I wouldn't know, I'm not a yank ;-)
05:52:30 <quicksilver> ivanm: other people can dislike both your choices just as easily as they can dislike one; and you can like both just as easily as you can like one.
05:52:34 <zachk> ivanm: i did do an old gentoo install years ago. took me like a week
05:52:40 <ivanm> zachk: yeah, I always used a ubuntu or fedora live CD to install gentoo
05:52:47 <abbe> ivanm, gentoo has an installer, ?
05:52:50 <ivanm> abbe: yes
05:52:56 <ivanm> text-based, curses-based and graphical
05:53:01 <zachk> abbe: it has now for at least a few years
05:53:05 <abbe> lol, then i've also never installed from it :-D
05:53:06 <ivanm> (where text-based == "here's a bash prompt")
05:53:15 <ivanm> abbe: what did you use then?
05:54:05 <abbe> my existing OS's shell, and shell on live cd :-)
05:54:16 <chessguy_work> boy, RWH made a mess of some stuff :(
05:54:28 <ivanm> chessguy_work: like what?
05:54:33 * abbe wishes he had a powerful CPU so he can continue his Gentoo :(
05:55:19 <chessguy_work> a lot of the examples are very hard to follow along with. the exception-handling mechanisms completely changed immediately after the book was written. and some code is just flat broken.
05:56:03 <ivanm> I get most of the examples, at least if I think about them for a bit; the exception stuff is unfortunate (probably too late to re-write it); and I've only found a few cases where the code is broken
05:56:24 * ivanm thinks the last point is O'Reilly's fault, rather than that of dons, bos and CosmicRay
05:56:39 <chessguy_work> i'm not trying to assign "fault"
05:56:49 <chessguy_work> just saying it's a shame
05:57:11 <chessguy_work> as for the examples, i get the idea of them, but i'd love to be able to follow along and play with the code too
05:57:21 <ivanm> yeah
05:57:28 * ivanm wishes the globbing library was on hackage
05:57:35 <chessguy_work> the way they're written just isn't conducive to that though
05:57:41 <ivanm> I've asked bos if he'd let me package it, but he's never responded :s
05:59:43 <chessguy_work> @pl \s p -> f u (fo s p)
05:59:44 <lambdabot> (f u .) . fo
06:00:25 <chessguy_work> i think there are some really cool possibilities with this Iterator stuff (chapter 9), but if i want to do anything with it, i'll have to write it from scratch
06:00:31 <chessguy_work> pretty much
06:01:16 <crayer> hi :)   directSuccessors l b = map (snd) (filter (\x -> ((fst x) == b)) l)   returns "abc" instead of ['a','b','c']. Where's my mistake?
06:01:27 * ivanm can't recall that chapter...
06:01:32 <ivanm> crayer: they're the same
06:01:44 <ivanm> "abc" is syntactic sugar for ['a', 'b', 'c']
06:01:48 <ivanm> @src Show
06:01:48 <lambdabot> class  Show a  where
06:01:48 <lambdabot>     showsPrec :: Int -> a -> ShowS
06:01:48 <lambdabot>     show      :: a   -> String
06:01:48 <lambdabot>     showList  :: [a] -> ShowS
06:01:55 <crayer> ivanm, i know, but the offical solution returns the latter
06:01:59 <ivanm> crayer: ^^ for Char, showList uses a pretty form
06:02:02 <ivanm> crayer: no difference
06:02:12 <ivanm> where is this "official" solution?
06:02:18 <ivanm> because they _are_ the same
06:02:19 <wli> Why are all the evalStateT, runContT, etc. arguments in the exact wrong order?
06:02:29 <ivanm> AFAICT, it should never be printed as ['a', 'b', 'c']
06:02:41 <ivanm> wli: who says they're in the wrong order?
06:02:52 <ejt> hmm, djinn does handle classes (referring back to a conversation before lunch):
06:02:54 <chessguy_work> @pl \l b -> map snd (filter ((== b) . fst) l)
06:02:55 <lambdabot> (map snd .) . flip (filter . (. fst) . (==))
06:03:03 <chessguy_work> @pl \b l -> map snd (filter ((== b) . fst) l)
06:03:04 <lambdabot> (map snd .) . filter . (. fst) . (==)
06:03:08 <ejt> Djinn> class Monad m where
06:03:09 <ejt> Djinn>    (>>=) :: m a -> (a -> m b) -> m b
06:03:09 <ejt> Djinn>    return :: a -> m a
06:03:09 <ejt> Djinn> (>>) ? (Monad a) => m a -> m b -> m b
06:03:09 <ejt> (>>) :: (Monad a) => m a -> m b -> m b
06:03:11 <ejt> (>>) a b = a >>= (\ _ -> b)
06:03:13 <ejt> Djinn> join ? (Monad a) => m (m a) -> m a
06:03:16 <ejt> join :: (Monad a) => m (m a) -> m a
06:03:18 <ejt> join _ = case bind (\ a -> bind (\ _ -> Node a)) of Node b -> return b Nil -> (>>=) return
06:04:34 <wli> ivanm: main = flip evalStateT Map.empty . flip runContT return . callCC $ runReaderT repl . ($ ())
06:05:08 <ivanm> wli: I've never used ST... but maybe whoever designed it preferred it the other way?
06:06:13 <wli> ivanm: I always end up unraveling monad transformer stacks with pipelines of flip runMonadT initStuff . flip runOtherMonadT otherInitStuff . flip runMonad3T init3Stuff etc.
06:06:22 <crayer> ivanm: osolution hasn't been published yet. there's just that example on the exercise sheet :)
06:06:33 <ivanm> crayer: well, they're the same
06:06:42 <ivanm> and AFAIK, you'll never see a String printed as a list
06:07:02 <ivanm> > show ['a', 'b', 'c']
06:07:03 <lambdabot>   "\"abc\""
06:07:25 <crayer> ivanm, yes, and since I'm surprised, I thought "hey why not ask the haskell channel" :)
06:07:41 <quicksilver> ejt: neat.
06:08:37 <wli> showStringAsList s = "[" ++ intercalate "," (map show s) ++ "]"
06:08:46 <ivanm> crayer: heh
06:10:02 <ddarius> newtype NotChar = NotChar Char; instance Show NotChar where show (NotChar c) = show c; showStringAsList = show . map NotChar
06:13:01 <crayer> hm, I'm stuck.   I've got a circle in my graph and I'm supposed to write an algorithm in Haskell which finds the successors of any node. I thought I should write a loop where it looks for the successor of a ++ the successor of a's successor etc. but I'm a little confused... where does it stop in a circle? any hint that puts me on a better direction?
06:13:04 <Athas> Has anyone written a MUD client in Haskell?
06:13:35 <ivanm> crayer: how are you representing a graph?
06:13:37 <zachk> Athas: someone was trying to it is named yogurt and gpl'd i believe
06:13:41 <ddarius> Athas: Probably.  People have certainly mentioned doing such projects.  I don't think anything is released publically.
06:13:41 <wli> ncurses library support is basically C FFI stubs.
06:14:12 <ddarius> @hackage yogurt
06:14:12 <zachk> Athas: i took roll your own irc bot turned it into an irc client then turned it into a mud client. it kind of works but its not very well developed
06:14:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yogurt
06:14:27 <zachk> ivanm: haskell opengl is just broken on ubuntu
06:14:36 <ivanm> and by "successors", do you mean _all_ successors, or just immediate ones (e.g. if a -> b -> c, c is a successor of a)
06:14:37 <Athas> Thanks, I will take a look at yogurt.
06:14:39 <zachk> ivanm: my window doesnt even come up
06:14:48 <ivanm> zachk: well, don't look at me! ;-)
06:14:50 <zachk> Athas: its on cabal last i knew
06:14:58 <zachk> ivanm: so you recommend arch?
06:15:07 <ivanm> zachk: well, I use gentoo ;-)
06:15:08 <wli> tty/pty support libs don't seem to be considered very exciting by very many people, though there are various quite interesting problems in and around that area.
06:15:30 * ivanm doesn't really like some of the design decisions in arch (the distro, not the haskell package stuff)
06:15:53 <scook0> curses is gross
06:16:19 * p_l agrees with ivanm
06:16:29 <crayer> ivanm:        [(a,a)]        e.g. [('a','b'),('b','c'),('c','a')]
06:16:44 <ivanm> crayer: so you're using a list of pairs to denote edges?
06:16:51 <crayer> right
06:17:41 <ivanm> are you assuming a directed or undirected graph?
06:17:49 <crayer> but don't tell me the solution :) I just need a hint...
06:17:51 <crayer> directed graph
06:17:55 <ivanm> OK
06:18:00 <ivanm> crayer: remove each edge as you traverse it
06:18:08 <ivanm> that stops you from going in circles
06:18:28 <pushpam> hello everyone...
06:18:40 <crayer> yeah I thought about it :) let's hope it wasn't the solution heheh
06:18:46 * wli usually uses IntMap (NodeInfo, IntSet) for graphs.
06:18:46 <ivanm> (actually, you'll probably want to remove _all_ edges from the given vertex to ensure there isn't multiple possible circles)
06:18:53 <ivanm> crayer: that's what I've done
06:19:04 <ivanm> wli: what, the two current graph implementations available aren't good enough for you?
06:19:23 <ivanm> IIRC, FGL has an IntMap based one (the PatriciaGraph option) available...
06:19:40 <ivanm> but I find the standard TreeGraph to be good enough for my purposes so far
06:19:54 <wli> ivanm: I usually get enough domain-specific content to render graph libraries unusable.
06:20:05 <ivanm> oh, OK
06:20:10 <ivanm> care to give some examples?
06:20:15 <crayer> ivanm, you wrote a code for it? did you need more than 5 lines?
06:20:31 <ivanm> crayer: ummm.... probably
06:20:40 <ivanm> but I used common functions, etc. and used FGL graphs
06:20:46 <ivanm> actually, I lie...
06:20:49 <ivanm> I didn't write that
06:20:55 <ivanm> I wrote cycle-detection routines ;-)
06:21:07 <ivanm> but FGL has functions to find all possible successors IIRC...
06:21:09 <wli> ivanm: Biconnected components, except some edges count double.
06:21:34 <ivanm> ahhh
06:22:09 <ivanm> wli: do you know much about graph theory itself (apart from just using graphs)?
06:22:11 <pushpam> plz, could anybody tell me whatz being discussed
06:22:44 <ivanm> pushpam: well, crayer is looking for suggestions on how to find all recursive successors of a given vertex in a graph without getting into cycles
06:22:55 <ivanm> and wli and I are discussing graph datatype representations on the side
06:23:04 <wli> ivanm: SCC's, except I know in advance there is tree-like structure where certain node types can only have cycles within their lower shadows.
06:23:31 <ivanm> ahhh, so special knowledge you can hard-code in?
06:24:11 <wli> Or need to hard-code in in a number of instances.
06:24:20 <ivanm> *nod*
06:24:36 <pushpam> ohhh.... thanx a lot... but didn't understand a lot... u see , i am just a beginner:)
06:24:58 <ivanm> wli: do you know what the difference between graph isomorphisms and graph canonization is? wikipedia is confusing me on the latter :s
06:25:02 <ivanm> pushpam: heh
06:25:07 <wli> The graph libs last I looked didn't have easy ways to carry things around on the side.
06:25:11 <ivanm> @quote off-topic
06:25:11 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
06:25:23 <ivanm> wli: unless you carry knowledge in the labels of FGL, no
06:25:26 <wli> ivanm: I know what graph isomorphisms are, but not canonization.
06:25:35 <ivanm> (and AFAICT, you can't carry _any_ extra knowledge in the standard graph type)
06:25:40 <ivanm> wli: *nod*
06:26:11 <ivanm> I'm wanting to keep only one isomorphic form of each graph in a list of brute-forced generated graphs...
06:26:17 <wli> That issue usually doorstops me.
06:27:06 <ivanm> hgal has routines to tell if two are isomprphic (so I can use nubBy) as well as convert a graph to its canonical form (so I can use a filter (\ g -> g == canonicGraph g) ), _if_ it's the same thing
06:27:36 <ivanm> filter would be nicer since it's O(n) as opposed to O(n^2) (ignoring the comparisons themselves)... :s
06:28:17 <ddarius> ivanm: As the page says, G ~ H iff Canon(G) = Canon(H)
06:29:00 <ivanm> gah, missed that somehow :s
06:29:06 <ivanm> thanks ddarius
06:29:09 <wli> One of the things that crops up is that a bunch of information is external to the graph itself.
06:29:19 <ivanm> so it looks like I can't use canonical form as a way of avoiding the nubBy :s
06:29:28 <ivanm> wli: *nod*
06:30:17 <wli> Tables of things on the side, things involving the order of the array I've got vertices sitting in based on how they were generated, etc.
06:30:20 <ddarius> ivanm: Canonizing everything and then using some form of graph equality (or better some kind of hashing of the graph) is probably far faster than nubBy isomorphic
06:30:46 <ivanm> ddarius: oh? how could I test for graph equality or hash it?
06:30:58 <ivanm> I basically want a function [Graph] -> [Graph]
06:31:30 <ivanm> (actually, it's [a] -> [a], with a class function a -> Graph, but that's besides the point)
06:33:11 <ivanm> I could use "g == canonicGraph g" for the early stuff where I'm generating every possible graph, but later when I expand upon those graphs I can't guarantee that I've got all of them so the equality case mightn't occur :s
06:33:29 <wli> (BTW at some point I realized that it's only worth doing SCC's within binding groups, so breaking up let statements prematurely is/was a fatal blow.)
06:33:42 <ivanm> heh
06:34:09 <ddarius> g == canonicGraph g will only occur if g = canonicGraph g' for a graph g'.
06:34:25 <lilac> is there a strict-by-default (with optional laziness) version of haskell?
06:34:40 <ivanm> lilac: there's a few small ones I've heard of...
06:34:41 <ddarius> Mostly no.
06:34:53 <ivanm> one being developed at aberystwyth (is that how it's spelt) IIRC
06:35:02 <ivanm> ddarius: ummm.... what? ;-)
06:35:10 <zachk> lilac: you can add a few characters to get strictness. though laziness is the way to be :-D
06:35:45 <lilac> zachk: it depends on the circumstances. in situations where you need tight control over memory usage, lazy-by-default can be a killer
06:35:49 <zachk> lilac: its either $! or !$ and for data types add !Int to force it to strict i believe though check the pidigits benchmark
06:36:37 <zachk> > sum !$ map (* 2) [1..10]
06:36:40 <lambdabot>   Not in scope: `!$'
06:36:42 <lilac> zachk: it's $! for a stricter form of $ and ! in a pattern / type. but that doesn't really solve my problem
06:36:47 <zachk> > sum $! map (* 2) [1..10]
06:36:49 <lambdabot>   110
06:36:59 <Cale> dons: What do you mean "didn't know about"?
06:36:59 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
06:37:08 <zachk> lilac: im a neophyte :-/ what kind of strictness do you need
06:37:26 <lilac> zachk: $! is only weak head strictness in any case; 'sum $! ...' won't force the whole list
06:37:56 <lilac> (except that the sum itself will, of course (for most Num instances))
06:38:10 <ivanm> ddarius: so what do you recommend I do?
06:38:29 <zachk> > let strictList n=[1..n] in sum $! map (*2) $! strictList 10
06:38:30 <lambdabot>   110
06:38:40 <zachk> lilac: will that force the whole list?
06:38:43 <lilac> zachk: i want to be able to easily reason about my program's memory usage :)
06:38:52 <zachk> lilac: ahhhh
06:39:12 <quicksilver> the problem with adding strictness annotations all over the place is they can actually get quite expensive.
06:39:13 <zachk> lilac: i usually just pull up my OS's process viewer and watch from there
06:39:20 <quicksilver> especially excessive use of `rnf`
06:39:25 <quicksilver> rnf is O(n), typicaly
06:39:28 <zachk> quicksilver: whats rnf?
06:39:42 <quicksilver> reduce to normal form
06:39:47 <lilac> zachk: rnf is basically 'full' / recursive strictness
06:39:47 <quicksilver> @hoogle rnf
06:39:48 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
06:40:15 <lilac> zachk: whereas ! and seq give you 'weak head normal form'
06:40:32 <lilac> zachk: which means the top-most data constructor (and recursively any of its strict members) will be forced only
06:41:29 <lilac> zachk: so "[1..] `seq` True" still terminates because the LHS is forced to just "<thunk>:<thunk>"
06:41:32 <zachk> lilac: is there a GHC extensions to force rnf?
06:41:43 <lilac> zachk: whereas [1..] `rnf` True does not terminate
06:41:51 <zachk> lilac: LHS?
06:41:56 <lilac> Left Hand Side
06:42:13 <lilac> (acutally, i think the Num instance defaults to Int, so it might terminate...)
06:42:30 <zachk> > seq [1..] True
06:42:31 <lambdabot>   True
06:42:41 <lilac> > rnf [1..] True
06:42:42 <lambdabot>   Couldn't match expected type `Bool -> t'
06:42:44 <lilac> :(
06:42:49 <lilac> @type rnf
06:42:50 <zachk> :-/
06:42:52 <lambdabot> forall a. (NFData a) => a -> Done
06:43:06 <zachk> lilac: what does NFData mean?
06:43:06 <lilac> > rnf [1..] `seq` True
06:43:14 <ivanm> @hoogle NFData
06:43:18 <lilac> zachk: it's a typeclass which provides the rnf operation
06:43:29 <lambdabot>   thread killed
06:43:30 <lilac> zachk: you can't apply rnf to all types (for instance, it can't be applied to functions)
06:43:33 <ivanm> @hoogle NFData
06:43:34 <lambdabot> thread killed
06:43:40 <ivanm> @slap lambdabot
06:43:58 * ivanm didn't do it!
06:44:01 <ivanm> honest!
06:44:04 <ejt> lilac: if you want a strict language look at the ML family (ocaml etc.)
06:44:04 * wli has probably not sufficiently appreciated the importance of setting up a good repl.
06:44:04 <p_l> lol
06:44:05 <lilac> :)
06:44:18 <lilac> ejt: but ... but ... i like haskell :-/
06:44:22 <ivanm> wli: well, it's not like you have many options...
06:44:25 <zachk> wli: how is your parsing going?
06:45:12 <wli> ivanm: Hammering in AST's at the prompt with little more than readline and Read/Show to assist...
06:45:16 <ejt> lilac: then you have to get your head around laziness .. rather than wishing you could turn it off ;)   I think it's a normal stage for people to go through when learning haskell to get frustrated with memory issues.  I know I did
06:45:44 <pejo> ejt, OR he could design a strict language!
06:46:01 <ejt> but he likes haskell
06:46:15 <wli> For me it was too long ago to remember if so. I don't remember it but that doesn't mean it didn't happen.
06:46:23 * p_l found a book with a strict, pure variant of lisp... with a compiler for it included in appendix :)
06:46:28 <lilac> ejt: i don't think getting my head around it is the answer ;-)
06:47:15 <wli> p_l: I presume IA64 was not one of the compiler's target architectures.
06:47:37 <p_l> wli: it was compiling into CL environment you were supposed to type it into :)
06:47:53 <p_l> like the compilers for Scheme and Prolog in PAIP
06:48:26 <lilac> ejt: allow me to put it this way: the software i would like to write in haskell is currently written in C++, and is careful about its memory usage, yet still often uses >15GB of RAM
06:48:58 <wli> p_l: I guess they could always try silicon compilers.
06:49:12 <ejt> lilac: let me put it another way too; haskell without laziness is not haskell - there wouldn't be much that could remain the same
06:49:17 <quicksilver> lilac: I'm not sure laziness is the key issue there.
06:49:17 <p_l> lilac: sometimes the dataset is big enough...
06:49:37 <quicksilver> lilac: even with a strict haskell, you'd still have the problem that idiomatic haskell code consumes quite a lot of memory
06:49:52 <quicksilver> parametricity is a cost.
06:49:56 <lilac> ejt: i don't want haskell without laziness, i want laziness off by default. i want to think 'can/should i make this lazy?' rather than 'can/should i make this strict?'
06:50:10 <pejo> ejt, what can't remain the same?
06:50:31 <wli> "Let's write some code for reservation stations, reorder buffers, and TLB's!"
06:51:09 <lilac> quicksilver: that's a good point. i hope the conclusion isn't that one needs a more low-level language for this type of problem :-/
06:51:26 <wunki> ah, I received RWH just now.. time to become a pro haskell hacker :)
06:51:36 <pao> wunki: have fun! ;-)
06:51:45 <wunki> pao: thanks!
06:52:00 <bremner> Does OCaml have optional laziness?
06:52:09 <quicksilver> bremner: only in a weak sense
06:52:19 <gerard_> I'm trying to learn Haskell, and wrote this simple diff program for practice (http://codepad.org/F3qxTbev), I'm wondering if I "got it" in the sense that this is the way to program in Haskell. Comments please!
06:52:22 <quicksilver> (you'd have to write "fun () => ..." everywhere)
06:52:38 <wli> lilac: ML variants sound like they're what you're looking for. In a sense, Haskell is itself one.
06:52:43 <quicksilver> lilac: I think the conclusion is that when you deal with huge data sets, you need to manage your memory carefully.
06:53:10 <quicksilver> lilac: I don't think that's impossible with haskell. I wrote (part of) a B*-tree library in haskell which can work with direct memory access.
06:53:10 <pejo> quicksilver, Ocaml has tried to lift the value restriction though.
06:53:24 <lilac> quicksilver: does that necessitate working at a lower level of abstraction, do you think?
06:54:18 <lilac> gerard_: instead of using 'head', diff should probably pattern match on (a:as) and (b:bs)
06:55:29 <gerard_> lilac: yeah, but then I'd have to write "(a:as)" everywhere I now just use "a" right?
06:55:48 <lilac> gerard_: you can write as@(a:as') or similar
06:56:07 <lilac> gerard_: that binds as to the list, a to the head and as' to the tail
06:56:22 <wli> gerard: You're off to a very good start to learning Haskell.
06:56:41 <zachk> gerard: very good start. now learn about foldl and foldr :-D
06:56:48 <jedai> rittyan1: I answered your question in PM
06:57:12 <gerard_> wli, zachk: thanks :)
06:57:17 <lilac> gerard_: using (++) as you do has the potential to be inefficient.
06:57:21 <porges> are superclass equality constraints for type families due for GHC 6.11?
06:57:25 <gerard_> still find foldr and foldr confusing :p
06:57:39 * wli doesn't use lists as much anymore, but rather Map, Set, Sequence, IntMap, IntSet, etc.
06:58:06 <zachk> gerard_: i recommend "Programming in Haskell" by graham hutton goes from into to comp sci to toy compilers
06:58:27 <zachk> gerard_: it killed off alot of my major neophyte questions
06:58:41 <lilac> gerard_: there are lots of ways to make this diff faster, if you're interested in that
06:59:22 <gerard_> lilac: the algorithm is O(n^3) I guess
06:59:50 <gerard_> lilac: how would you write "change a b"?
07:00:53 <lilac> gerard_: the same, but i'd drop the parentheses around the maps, and probably call the parameters as and bs
07:02:01 <lilac> gerard_: it's pretty good code. i think sync and findAny could possibly be changed to make the algorithm more obvious
07:02:01 <gerard_> ok, so the ++ is still the most efficient solution?
07:02:31 <zachk> gerard_: ++ is horribly ineffecient but used often times when speed is not of the utmost importance
07:02:32 <gerard_> you don't want to know how long it took me to write it :p
07:02:50 <lilac> gerard_: (++) is fine if it's used in a right-associative fashion
07:02:57 <zachk> gerard_: its ok it took me forever to write 200 lines to simulate the solar system in opengl
07:03:02 <lilac> but it's O(n^2) if used in a left-associative fashion
07:03:38 <zachk> > 1:2:3:4:5==[1..5]
07:03:41 <lambdabot>       No instance for (Num [t])
07:03:41 <lambdabot>        arising from the literal `5' at <inter...
07:03:46 <zachk> > 1:2:3:4:5:[]==[1..5]
07:03:48 <lambdabot>   True
07:03:52 <gerard_> lilac: Haskell stores lists as linked lists right?
07:04:02 <lilac> yes, that's right. singly-linked lists.
07:04:04 <lilac> @src []
07:04:04 <lambdabot> data [] a = [] | a : [a]
07:04:22 <gerard_> if it keeps a pointer to the end it should not be inefficient to append two of them
07:04:27 <zachk> > 1+2+3+4+5+0==foldr (+) 0 [1..5]
07:04:28 <lambdabot>   True
07:04:36 <jedai> gerard_: It don't
07:04:41 <zachk> gerard_: that is how foldr works
07:04:42 <lilac> it doesn't keep a pointer to the end. even if it did, it couldn't (in general) change such a pointer.
07:05:01 <jedai> gerard_: And you forget that data structures are immutable in Haskell
07:05:23 <gerard_> jedai: ah, yes, that's the problem
07:05:41 <jedai> gerard_: if you appended as you suggest, you would be modifying the original list which would completely break the purity of Haskell
07:05:45 <lilac> gerard_: the problem with left-associative (++) is that if you have (++) ((++) ((++) ((++) ((++) ..., to find the value of each element, the entire stack of (++)s must be traversed.
07:05:50 <zachk> gerard_: its takes the (:) operator and replaces it with a two argument function and replaces the end of the list with preferably an identity of the aforementioned two arguement function
07:05:52 <gerard_> standard trick it to not append but to put everything you want to append in a new list right?
07:05:56 <C-Keen> dcoutts: from what I know now is, that it seems that older versions of cabal used to call configure in the postConfHook, whereas this seems to happen now in confHook. Shall I reimplement configure to fit readline's Setup's needs? I still don't understand fully how cabal works
07:06:13 <jedai> gerard_: So you have to copy the whole first list (you can still share the second list though)
07:06:46 <zachk> gerard_: i usually just `cons` (:) to the front of the list passing it along in accumalator variable then for say the case f [] a=reverse a and return the list reversed
07:07:56 <jedai> @src (++)
07:07:56 <lambdabot> []     ++ ys = ys
07:07:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:07:57 <lambdabot> -- OR
07:07:57 <lambdabot> xs ++ ys = foldr (:) ys xs
07:08:02 <gerard_> zachk: you lost me there, but I'll read up on it
07:09:11 <lilac> gerard_: i'd probably make 'findAny' return Maybe (Int, Int) with Nothing meaning failure rather than (Int, Int) with (-1,-1) meaning failure
07:09:26 <bastl> i want to search the IRC logs. is there any nice interface to that ?
07:09:36 <zachk> bastl: perl?
07:09:37 <gerard_> lilac: thought about that, but it will be more code right?
07:09:46 <bastl> zachk: something ready to use ...
07:09:56 <zachk> grep?
07:09:57 <Ferdirand> grep ?
07:10:03 <gerard_> lilac: ah no, good suggestions
07:10:10 <EvilTerran> parsec?
07:10:26 <bastl> http://tunes.org/~nef/logs/haskell/ proposes http://meme.b9.com/ which is a dead link ...
07:10:26 <lilac> gerard_: possibly. i don't know if you're ready for this, but the amount of code can be reduced by using Maybe's monadic interface
07:10:31 <zachk> bastl: what are you searching for
07:10:55 <bastl> something i got an answer to somedays ago ... :-) but i dont want to ask again ;-)
07:11:03 <lilac> bastl: google?
07:11:10 <bastl> lilac: how?
07:11:22 <mun_> hi
07:11:23 <lilac> @go zyogmatic prepropmorphism site:http://tunes.org
07:11:23 <lambdabot> No Result Found.
07:11:36 <bastl> lilac: i tried site:... but no results found ...
07:11:40 <bastl> ah
07:11:45 <gerard_> make it return Maybe (Int, Int)... on faillure Nothing and on success Just (i, 0) right?
07:11:46 <mun_> does anyone know how feasible it is to embed a higher-order logic programming language, e.g., lambdaProlog into Haskell?
07:11:53 <gerard_> and also check those in the case
07:11:59 <mun_> i've seen Prolog embedded in Haskell, but how about a higher-order one?
07:12:14 <lilac> @go bastl asks a question site:http://tunes.org
07:12:15 <lambdabot> No Result Found.
07:12:21 <zachk> gerard_: the best monad tutorial ive found is this http://www.haskell.org/all_about_monads/html/index.html and for trying your hand at messing with a working program try this http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
07:12:31 <edwardk> mun_: there are a ton of dependently typed language interpreters/embeddings for haskell
07:12:46 <lilac> hmm, that works fine when typed into google :-/
07:12:53 <bastl> lilac: google doesnt seem to index the logs.
07:12:58 <mun_> edwardk, oh. have you got any examples?
07:13:02 <bastl> (which is a pity)
07:13:11 <lilac> bastl: weird. i'm getting results here.
07:13:33 <edwardk> mun: http://people.cs.uu.nl/johanj/MSc/jwroorda/ is a starting point
07:13:56 <pejo> bastl, it work for me.
07:14:00 <bastl> lilac: oh, i had the path /~nef/.../... also in the site:   thing
07:14:08 <bastl> works for me too. sorry.
07:14:36 <lilac> :D
07:14:40 <edwardk> mun: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html implements a kinda simple dependently typed lambda calculus as well
07:14:55 <mun_> edwardk, thanks
07:15:06 <gerard_> ok, lilac, zachk, jedai, thanks for your help, I'll try to use your suggestions, and will probably pass by again when I've got a new version
07:15:35 <lilac> gerard_: no problem, and good luck! how long have you been learning haskell for?
07:16:28 <gerard_> about 15 hours I think
07:16:38 <lilac> *blink* then you're doing stunningly well :)
07:17:11 <gerard_> could also be 20
07:17:20 <gerard_> easy to loose track when you're staring at code
07:17:21 <bastl> lilac: but still: there could be a nicer interface... (e.g. search for keywords/authors on a specific day ... perhaps this would be a nice plugin for lambdabot !?
07:18:22 <lilac> bastl: most assuredly so :) i'd imagine it wouldn't be too hard even (the hardest part is probably getting hold of the logs)
07:18:37 <gerard_> it really surprises me how hard Haskell (or functional programming is), I can use any imperative language almost immediately
07:18:57 <gerard_> but well, back to the code
07:19:14 <sjw> bastl: I hacked a log module up to lambdabot ages ago, I guess it is still in the repo
07:19:27 <edwardk> gerard_: it only hurts for a little while ;)
07:19:27 <lilac> gerard_: i found that too. programming in haskell requires you to think in quite different ways from the imperative mindset
07:20:09 <gerard_> I find you really have to think bottom up instead of top down
07:20:15 <lilac> yeah, it definitely gets easier (to the point where you start getting annoyed at how tedious imperative programming is :))
07:20:49 <Sekaino> gerard_, I think the difficulty of learning FP is directly proportional to the experience you have thinking imperatively.
07:20:50 <lilac> i find you have to think more about your data and less about your code / control flow
07:21:20 <sjw> lilac: exactly
07:21:36 <Stinger> how much of a pain are aquafers really
07:21:47 <sjw> or, you can't just hack until things work
07:21:50 <Sekaino> gerard_, for someone with pure math training, FP comes quite naturally (at least in my experience).
07:21:57 <Stinger> hmmm wrong chan
07:22:14 <gerard_> Sekaino: too bad if you're an chemical engineer :p
07:22:20 <Sekaino> :)
07:22:20 <Ferdirand> dwarf fortress ftw !
07:22:58 <Sekaino> gerard_, the good news, as people have noted, is that at some point it just gels and you "get it."
07:26:11 <Sekaino> sjw, I like that phrasing.  "You can't just hack until things work."  That describes my experience with Haskell exactly.  You must think much more carefully about the larger scope of your efforts to program well.
07:28:14 <C-Keen> dcoutts: I do have a patch for the Setup.hs, but it does not work if I run cabal in that directory. Why?
07:29:44 <Saizan> C-Keen: you need build-type: Custom in the .cabal file, maybe
07:32:57 <C-Keen> Saizan: hm...will try thanks
07:33:19 <temoto-wd> :t find
07:33:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:33:27 <temoto-wd> :t fmap
07:33:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:33:39 <temoto-wd> *??
07:34:11 <temoto-wd> What is f :: * -> *   ?
07:34:19 <ejt> *'s are kinds
07:34:45 <ejt> it says f is a type constructor that takes 1 arg
07:34:54 <EvilTerran> and that one arg is a type proper
07:35:01 <RayNbow> :k Int
07:35:02 <lambdabot> *
07:35:03 <RayNbow> :k Maybe
07:35:04 <lambdabot> * -> *
07:35:06 <RayNbow> :k Maybe Bool
07:35:07 <lambdabot> *
07:35:13 <RayNbow> :)
07:35:16 <EvilTerran> :k Maybe (Maybe Bool)
07:35:18 <lambdabot> *
07:35:35 <C-Keen> Saizan: thanks this did iy
07:35:36 <C-Keen> it
07:36:00 <RayNbow> EvilTerran: how uncertain would a function be if it returned a Maybe Maybe? :p
07:36:35 * EvilTerran notes Maybe (Maybe Bool) ~~ 4
07:37:00 <EvilTerran> (seeing as Bool ~~ 2 and Maybe a ~~ a+1)
07:37:05 * ski notes that Miranda displayed type-variables by `*',`**',et.c.
07:37:27 <lilac> @type let findAny a b x y = join . find isJust . map check $ zip3 [0..] (tails x) (tails y) where  check (n, x, y) | a `isPrefixOf` x = Just (n, 0) | b `isPrefixOf` y = Just (0, n) in  findAny
07:37:29 <lambdabot> forall a a1 t. (Enum t, Eq a1, Eq a, Num t) => [a] -> [a1] -> [a] -> [a1] -> Maybe (t, t)
07:38:08 <lilac> gerard_: ^^ when you're ready for it, that's how i'd write findAny :)
07:39:21 <RayNbow> :k Maybe (Maybe (Maybe ()))
07:39:22 <lambdabot> *
07:39:34 <jedai> lilac: zipWith3 rather than map . zip3, no ?
07:39:46 <lilac> jedai: yeah, good point :)
07:40:24 <lilac> jedai: it's also a pretty cheesy use of 'join', but i'm reluctant to use fmap fromJust
07:41:00 <gerard_> lilac: is it any faster than my version?
07:41:41 <lilac> gerard_: i think it's probably about the same
07:41:45 <jedai> lilac: I kinda like this join, it goes well with my concept of what join does (collapse a two level monad into one level)
07:41:59 <ski> (s/monad/monad action/)
07:42:18 <gerard_> lilac: but my version is much clearer right? (at least, it is to me)
07:42:27 <lilac> jedai: it's slightly weird given that 'find isJust' returns either Nothing or Just (Just a)
07:42:47 <lilac> gerard_: your version is fairly imperative in my view
07:43:06 <lilac> gerard_: that is, more vocused on the how than the what
07:43:09 <lilac> *focused
07:44:44 <lilac> but it's a matter of taste. i'd be interested in which version the channel prefers. mine is here: http://codepad.org/J1PzE9V9
07:45:26 <lilac> (original is here: http://codepad.org/F3qxTbev)
07:46:47 <edwardk> hah, i was just getting ready to format lilac's version into an hpaste so that gerard_ could see it
07:47:43 <EvilTerran> @check \xs -> (join . find isJust) xs == msum xs
07:47:44 <lambdabot>   "OK, passed 500 tests."
07:47:44 * ejt votes for lilac 
07:48:15 <ejt> but I don't like the uncurried function
07:48:39 <edwardk> what, no zipWith3 check [0..] `on` tails ? =)
07:48:40 <wjt> @type find
07:48:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:48:44 <jedai> ejt: in fact it is curried, lilac just forgot to update check from its precedent version
07:48:59 <ejt> ooh, yes, zipWith3
07:49:05 <EvilTerran> ?type zipWith3
07:49:06 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
07:50:31 <jedai> http://codepad.org/gmFWl7vn
07:51:26 <lilac> ejt: oops, i forgot to curry 'check' when i switched to using zipWith3 :)
07:51:32 <jedai> Like EvilTerran I prefer msum, it better translate the idea that we get the first Just
07:51:36 <crayer> yay :) solved the tree problem :D
07:51:43 <lilac> jedai: nice :)
07:51:49 <vixey> I can't read these what does it do
07:51:57 <lilac> jedai: i'd completely forgotten about msum
07:52:10 <jedai> lilac: It was EvilTerran idea
07:52:28 <C-Keen> hm, on another note: did cabal have a buildPrograms function at one point in time and what was it good for?
07:52:39 <crayer> I've got a huge problem when it comes to graphs and trees! Could you guys recommend me a website with exercises on graphs/trees? (i need some practice!)
07:52:53 <jedai> vixey: it search a in xs and b in ys in parallel and returns the first match (by length of prefix before a/b)
07:53:00 <vixey> crayer: prove that in every graph there is a subgraph that's a tree
07:53:13 <lilac> The result type still isn't right, I don't think
07:53:19 <lilac> vixey: do you count the empty graph as a tree?
07:53:40 <crayer> crayer: nah, not that kind of tree exercises :) we did that in discrete math etc. I mean haskell algorithms for trees / graphs
07:53:55 <gerard_> jedai: ahh, I love it, thanks
07:54:07 <crayer> great. I'm talking to myself :P
07:54:07 <crayer> heh
07:54:16 <crayer> vixey, I was talking to you :D
07:55:47 <jedai> crayer: You have some interestings libraries on Graph in Haskell, the real challenge being than most graph algorithms rely on state to be performant
07:56:32 <jedai> crayer: Tree algorithms on the other hand are mostly a pleasure to write in Haskell :)
07:57:26 <lilac> @type (msum .) . zipWith3 ?check [0..] `on` tails
07:57:27 <lambdabot> forall (m :: * -> *) a a1 a2. (Enum a1, Num a1, ?check::a1 -> [a2] -> [a2] -> m a, MonadPlus m) => [a2] -> [a2] -> m a
07:57:44 <EvilTerran> crayer, so you want such problems as "find a shortest path", "find a minimum-weight spanning tree", that kinda thing?
07:57:46 <lilac> a bridge too far?
07:57:47 <edwardk> fortunately most of those imperative algorithms can be boxed up behind a functional facade.
07:58:22 <crayer> EvilTerran, yes. stuff that's implementable in haskell :)
07:58:33 <crayer> I need to practice :)
07:58:48 <EvilTerran> ?faq are those implementable in haskell?
07:58:48 <lambdabot> The answer is: Yes! Haskell can do that.
07:58:51 <edwardk> crayer you might want to start by looking at Data.Graph
07:58:56 <jedai> edwardk: Yes but doing it elegantly and with easy to compose units is a challenge
07:59:06 <crayer> thanks for the suggestions!
07:59:12 * EvilTerran prefers the Map NodeId (Set NodeId) approach
08:00:41 <vixey> data Graph a = a :-->: [Graph a]
08:01:47 <vixey> type Graph' a = a -> [a]
08:02:01 <vixey> these types together can work well
08:02:23 <vixey> I've not used: data Graph'' a = a :-->: Graph'' [a]
08:03:11 <ejt> lilac: I just posted a badly formatted comment in reply to your findAny
08:03:34 <EvilTerran> vixey, uh, would that last one work?
08:03:54 <ejt> lilac: http://codepad.org/qMqzRgpM
08:03:57 * EvilTerran gets rapidly confused by polymorphic recursion in data types
08:04:00 <edwardk> the last one would probably require some non-trivial theorem proving/combinators
08:04:55 <lilac> @hoogle Monad m => m [a] -> (a -> m b) -> m [b]
08:04:55 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
08:04:55 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:04:55 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
08:05:13 <lilac> @pl \a f -> mapM (f =<<) a
08:05:13 <lambdabot> flip (mapM . (=<<))
08:06:35 <Cadynum> hi! i have a problem with getAddrInfo from Network.Socket. on linux it compiles fine, but on windows (wine ghc 6.10.1) it says "Not in scope: `getAddrInfo'". I googled and i saw others reporting the same issue, but i failed to see a solution. anyone got any idea? (or some other function i can use instead?)
08:07:59 <edwardk> hrmm. given mealy machines Mealy a b = Mealy (a -> (b, Mealy a b)) and their left adjoint newtype Comealy a b = Comealy (b, a -> Comealy a b) -- Comealy a `o` Mealy` a is a comonad, and Mealy a `o` Comealy a is a monad, now what the heck can i do with the mealy-machine of comealy-machines monad ;)
08:08:36 <quicksilver> edwardk: use it to compose a tongue-twisting rhyme?
08:08:40 <edwardk> hah
08:08:42 * vixey laugh
08:09:01 <vixey> where does this Mealy come from?
08:09:13 <RayNbow> edwardk: Comealy? O_O
08:09:40 <edwardk> Mealy machine states are just machines that take an input, and return an output and a new machine state
08:09:53 <gerard_> jedai: your version looks good but doesn't work... findAny "123" "abc" "sioigau123ofdug" "sdfsd": expected output = Just (7,0) your version says: Nothing
08:10:26 <jeffersonheard> what is the recommended version of HaXml to use?  The latest?
08:10:29 <edwardk> raynbow: you can make 'comealy' more explicit by making Melay a b = Mealy (a -> Comealy a b) -- and making them mutualy recursive to see that they are just off by one versions of each other
08:11:15 <edwardk> vixey: Mealy machines are one of the two common ways of writing out automata, Mealy or Moore machines
08:11:38 <edwardk> Melay puts the output on the edge, Moore puts the output as part of the state
08:12:42 <RayNbow> edwardk: I'm not ready for co-stuff yet ;)
08:12:55 <ejt> gerard_: I based my findAll of lilacs - his also gives Nothing :)
08:13:07 <vixey> what is findAll?
08:13:11 <RayNbow> (it's somewhere on my long ToRead/Learn/Etc list though)
08:13:38 <lilac> @type (&&&)
08:13:39 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:13:51 <malcolmw> jeffersonheard: if you have no need to be backward compatible, then certainly the latest version of HaXml would be recommended I think
08:14:30 <gerard_> ejt: yours does work
08:14:52 * gerard_ should really learn how to use quicktest
08:15:32 <gerard_> the problem is that the result of a zip has the length of the shortest list
08:15:44 <jeffersonheard> k.  second question anyone who's familiar with the HaXml combinators interested in helping me on a quick project of general interest to the Haskell community?  I'm trying to write something that will generate a Haskell module from an XML Schema with read/write instances for XML documents in that schema
08:15:49 <jeffersonheard> as opposed to a DTD, which is less general
08:16:20 <jeffersonheard> I'm not terribly familiar with HaXml, but I have need for it.
08:17:00 <edwardk> gerard: there needs to be a nice 'long zip' for monoids or something
08:17:50 * EvilTerran has used a "generalZip :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]"
08:18:29 <malcolmw> jeffersonheard: generating haskell types from a Schema has been done I think - search for HAIFA
08:18:54 <vixey> @go HAIFA
08:18:55 <lambdabot> http://en.wikipedia.org/wiki/Haifa
08:18:55 <lambdabot> Title: Haifa - Wikipedia, the free encyclopedia
08:18:58 <scook0> if you know ahead of time which list will be shorter
08:19:17 <scook0> you can just stick (++ repeat paddingElement) on the end of it
08:21:50 <vixey> How do you prove correct a purely functional parser?
08:23:39 <temoto-wd> @src forever
08:23:39 <lambdabot> Source not found. My brain just exploded
08:23:45 <temoto-wd> :t forever
08:23:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
08:28:23 <jeffersonheard> malcomw: the project has been abandoned as of 2006...
08:28:37 <BONUS> that reminds me
08:28:48 <BONUS> is haskore development still in any way active?
08:29:11 <byorgey> BONUS: I think so, Henning Thielemann has been doing some work on it recently
08:29:50 <skorpan> is that the "music" library?
08:29:58 <BONUS> awesome, i'll have to give it a second look. i'd love to do live coding on a show
08:30:02 <BONUS> in haskell
08:30:08 <Workybob> I'm getting a very odd link error which I'm near certain is something to do with a dodgy spec in my cabal file, but I can't figure out what the hell is going on... Anyone have any ideas what I could have bugered up here?
08:30:10 <Workybob> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2821#a2821
08:30:16 <byorgey> skorpan: yeah
08:30:51 <skorpan> i remember i was going to do something like that for my project in the advanced functional programming course, but realized that everything had already been done in haskore
08:31:27 <BONUS> i'd love to make some VST plugins in haskell, i'll have to take a look at that
08:31:45 <skorpan> purely functional music
08:32:12 <sysadmin> Has anyone here worked with happstack?
08:32:18 <BONUS> in a sense, music is a function of time
08:32:50 <seliopou> BONUS, everything's a function of time :P
08:33:07 <BONUS> haha, true
08:33:08 <vixey> time is a function of time
08:33:14 <skorpan> `id'?
08:33:17 <seliopou> vixey, deeeep
08:33:21 <seliopou> :)
08:33:39 <vixey> @seen jkff
08:33:39 <lambdabot> I haven't seen jkff.
08:34:42 <byorgey> BONUS: ...and by 'recently' it turns out that I mean Henning has been working on Haskore development for *five years*
08:34:51 <jeffersonheard> malcomw...  Yeah, just looked at it, and it's really fairly limited in the schemae it can parse...  I don't think it can handle KML, for one thing, which is what I wanted it for.  Also, it parses schemae, but it doesn't seem to create a parser for the XML document that goes with the schema
08:34:57 <byorgey> most recent darcs patch is January of this year, and they go back to 2004 =)
08:35:01 <BONUS> ah
08:35:06 <BONUS> awesome
08:35:20 <BONUS> cause i looked at haskore's site and it says that the latest release is february 2000
08:35:42 <byorgey> BONUS: yeah, that's Paul Hudak's site, I think Henning has taken over development now
08:36:08 <BONUS> aha
08:36:13 <byorgey> I've also been looking at Rohan Drape's supercollider bindings (hsc3)
08:36:19 <BONUS> yeah me too
08:36:29 <byorgey> and there's also haskore-supercollider, which lets you use SC as a backend to play Haskore music
08:36:49 <BONUS> i've been looking at supercollider recently and it seems nice but i'd much rather use the haskell language
08:37:06 <lilac> > (inits &&& tails) "Hello"
08:37:07 <lambdabot>   (["","H","He","Hel","Hell","Hello"],["Hello","ello","llo","lo","o",""])
08:37:16 <BONUS> you mean it can send haskore music to the sc server?
08:37:53 <lilac> > transpose $ (inits &&& tails) "Hello"
08:37:54 <lambdabot>   Couldn't match expected type `[[a]]'
08:37:56 <byorgey> BONUS: yep
08:38:05 <lilac> > uncurry zip $ (inits &&& tails) "Hello"
08:38:06 <lambdabot>   [("","Hello"),("H","ello"),("He","llo"),("Hel","lo"),("Hell","o"),("Hello",...
08:38:12 <byorgey> BONUS: hsc3 lets you use Haskell to control the supercollider server.
08:38:18 <BONUS> agh, i'm looking at a haskore tutorial from 1997
08:38:25 <byorgey> you don't have to use the supercollider language
08:38:29 <BONUS> is there anything more recent
08:38:33 <BONUS> awesome
08:38:59 <byorgey> that's what I meant by 'supercollider bindings' =)
08:39:18 <mib_x8osph> > let square x = x*x in let guess = 1 in  abs $ (square guess) - x < 0.001
08:39:18 <lambdabot>       No instance for (Num Bool)
08:39:19 <lambdabot>        arising from a use of `abs' at <inter...
08:39:21 <byorgey> hmm, I don't know about more recent Haskore tutorials
08:39:50 <mib_x8osph> school of expression is more recent than '97
08:39:53 <byorgey> BONUS: have you seen the wiki page?  http://www.haskell.org/haskellwiki/Haskore
08:40:06 <mib_x8osph> :t abs
08:40:07 <lambdabot> forall a. (Num a) => a -> a
08:40:26 <lilac> @index getArgs
08:40:26 <lambdabot> System.Environment
08:40:29 <BONUS> ah no i haven't, awesome
08:40:36 <byorgey> mib_x8osph: needs more parentheses
08:40:49 <mib_x8osph> > let square x = x*x in let guess = 1 in  (abs $ (square guess) - x) < 0.001
08:40:50 <lambdabot>   False
08:40:50 <chalkyExt> I'm really excited about happstack.  Finnaly!  A web framework in haskell.  Now, if only I could get it to recompile.
08:41:23 <chalkyExt> Does anyone know what happstack is?
08:41:24 <mib_x8osph> hm, I guess it gets parsed as abs (square-guess-x < 0.001)
08:41:39 <byorgey> > x
08:41:40 <mib_x8osph> chalkyExt: finally? happs has been around since like '05 or earlier
08:41:41 <lambdabot>   x
08:41:57 <byorgey> mib_x8osph: the 'x' at the end is not the same as the first 'x'
08:42:05 <chalkyExt> http://tutorial.happstack.com/tutorial/run-tutorial-locally
08:42:06 <rittyan1> how to make an eternal (!) iteration? let foo f = map f [1..] OR let foo f = map f $ cycle [1]? will [1..] ever exhaust?
08:42:38 <Saizan> chalkyExt: you can find the happstack developers on #happs
08:42:39 <mib_x8osph> > let square x = x*x in let guess = 1 in let x = 5 in abs $ (square guess) - x
08:42:40 <lambdabot>   4
08:42:44 <byorgey> rittyan1: [1..] is an infinite ascending list
08:42:57 <chalkyExt> Saizan:  Thanks!
08:42:58 <mib_x8osph> > let square x = x*x in let guess = 1 in let x = 5 in abs (square guess) - x
08:42:58 <byorgey> cycle [1] is an infinite list of 1's, better written as (repeat 1)
08:42:59 <lambdabot>   -4
08:43:19 <byorgey> rittyan1: what exactly are you trying to do?
08:43:28 <rittyan1> byorgey, but [1..] still may overflow someday...
08:43:37 <byorgey> rittyan1: overflow how?
08:43:38 <rittyan1> byorgey, nothing at all
08:43:53 <rittyan1> byorgey, 100km-long int?
08:44:09 <byorgey> rittyan1: hehe, well, yes, it stops when you run out of memory
08:44:21 <rittyan1> byorgey, while "repeat 1" is literally eternal
08:44:24 <rittyan1> right?
08:44:44 <rittyan1> I know that I should not be thinking about it, but still I am curious :)
08:44:59 <inimino> nothing is literally eternal
08:45:01 <byorgey> rittyan1: I'm not sure what distinction you are trying to make.
08:45:20 <scook0> it's circular, if that's what you mean
08:45:40 <scook0> repeat 1 should allocate only one cons
08:45:41 <mib_x8osph> I wouldn't be surprised if enumFrom on ints/integer is defined in terms of repeat
08:45:46 <rittyan1> I just mean that repeat 1 will never lead me to out of memory stuff, while [1..] potentially may
08:45:51 <scook0> whereas [1..] will allocate arbitrarily many, if you let it
08:46:13 <TomMD> rittyan1: Well, if you use foldr on 'repeat 1' then you just might find issues...
08:46:18 <rittyan1> byorgey, I just used "forever" function first time in my life and though how I would make a forever function myself
08:47:00 <scook0> @src repeat
08:47:01 <lambdabot> repeat x = xs where xs = x : xs
08:47:59 <byorgey> rittyan1: forever m = m >> forever m ?
08:48:10 <byorgey> no need to bring lists of integers into it
08:48:28 <rittyan1> well, ">>" is something I don't know about yet :)
08:48:29 <byorgey> just use recursion =)
08:48:31 <rittyan1> okay
08:48:38 <byorgey> @type (>>)
08:48:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
08:48:53 <byorgey> it sequences two monadic computations, ignoring the result of the first one
08:49:38 <scook0> (but still retaining whatever "effect" the first one had, for appropriate monads)
08:50:12 <Saizan> > "abc" >> [1,2]
08:50:12 <lambdabot>   [1,2,1,2,1,2]
08:50:18 <jedai> rittyan1: "m >> forever m" is the real code behind the syntactic sugar "do { m; forever m }"
08:50:30 <rittyan1> yes I know
08:50:51 <rittyan1> but since I don't know much about monads and "do"-things, I tried to think in terms I know
08:50:58 <rittyan1> forgive me :D
08:51:11 * Saizan wonders if there's any difference with fix (m >>) for IO
08:52:00 <mib_x8osph> @hoogle (x -> Bool) -> x -> x
08:52:00 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:52:00 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
08:52:00 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
08:52:35 <mib_x8osph> hm... that doesn't seem quite right. I was expecting to be able to do newton's method with iterate or fix or something
08:53:39 <vixey> How brilliant is the PEG algorithm
08:53:54 <vixey> it's like this definition of infinite list of fibs
08:54:05 <edwardk> vixey: packrat parsing?
08:54:10 <vixey> yes
08:54:21 <vixey> it's just a shame that PEG has such complex theory
08:54:36 <edwardk> i'd just be happier if there was any way to inject context into it ;)
08:54:55 <edwardk> and i haven't come up with a good packrat monoid yet ;)
08:55:21 <mib_x8osph> :t iterate
08:55:22 <lambdabot> forall a. (a -> a) -> a -> [a]
08:55:55 <mib_x8osph> :t fix
08:55:56 <lambdabot> forall a. (a -> a) -> a
08:57:53 <dancor> should i just change (data Intercal a b = Intercal a b (Intercal a b) | Interend a) to (data Intercal = Intercal [(a, b)] a)?
08:58:12 <vixey> data Intercal a b = Nil | Cons a (Intercal b a)
08:58:16 <dancor> i could reuse things more with the 2nd form and i can't see benefits to the first from
08:58:33 <dancor> vixey: woah
08:58:34 <mib_x8osph> @hoogle (x -> Bool) -> (x -> x) -> x -> x
08:58:34 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:58:34 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
08:58:34 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
09:00:02 <dancor> well that allows ab and abab
09:00:03 <mib_x8osph> > until (\x -> < 0.001) (\x -> x / 2) 5
09:00:04 <lambdabot>   <no location info>: parse error on input `<'
09:00:17 <lilac> gerard_: significant refactoring of your diff program: http://codepad.org/icwWUNCY
09:00:22 <dancor> which is possibly more sane but not what i need for my type..
09:00:23 <mib_x8osph> > until (\x -> x < 0.001) (\x -> x / 2) 5
09:00:24 <lambdabot>   6.103515625e-4
09:01:01 <mib_x8osph> hm, which would be... 0.00061035 or so. seems sensible
09:06:30 <gerard_> lilac: does it actually work? what happens when you feed it two completely different files?
09:06:51 <lilac> gerard_: it does actually work (in my tests), and it should be faster than your version too
09:07:34 <lilac> gerard_: it's pretty easy to prove that it must create a correct diff
09:07:44 <lilac> however, that diff may well not be very good
09:08:17 <gerard_> lilac: it's about 24 times slower
09:08:19 <gerard_> :p
09:08:26 <lilac> :D
09:09:01 <gerard_> *your version* is 24 times slower
09:09:05 <lilac> indeed.
09:09:20 <lilac> that's somewhat entertaining
09:09:27 * lilac wonders what he did wrong :)
09:10:05 <lilac> i suspect it's the use of 'inits'
09:11:20 <lilac> @hoogle ZipList
09:11:20 <lambdabot> Control.Applicative newtype ZipList a
09:11:20 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
09:11:20 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
09:11:30 <lilac> @hoogle list zipper
09:11:30 <lambdabot> No results found
09:14:55 <pcc1> is it possible to see the inferred type signatures for a module that fails to compile (ghc)? -ddump-types only works with successful compilations
09:15:50 <vixey> pcc1: probably fails to compile due to type errors
09:16:02 <lilac> pcc1: in full generality, you're asking to see inferred types in the case where type inference failed
09:16:33 <lilac> (or possibly where type inference never happened)
09:16:41 <opqdonut> well it could show the pratial contexts
09:16:55 <pcc1> yes.  in my case some types are inferred but not others.  it would really help to see those types that are inferred
09:17:18 <lilac> indeed. showing types for binding groups which have been inferred seems sensible (and i'm kinda surprised -ddump-types doesn't do that)
09:17:21 <Cale> pcc1: You can just comment out whatever part of the module is causing problems.
09:17:46 <Cale> (which, maybe is a little inconvenient, but it's what I do)
09:17:51 <quicksilver> it is very annoying.
09:17:55 <pcc1> yes, I have been doing that but wondered if there was a better way
09:17:57 <quicksilver> perhaps my number 1 GHC gripe.
09:18:24 <quicksilver> it should be prepared to compile the maximal chunk of file which excludes erroring chunks.
09:20:13 <Cale> Having the ability to compile as much of the file as possible would be good in the case of being connected with a text editor.
09:21:09 <quicksilver> even failing that it would be nice if ghci would at least revert to its old state
09:21:21 <quicksilver> (rather than throwing all its toys on the floor when a new edit fails to compile)
09:23:00 <dons> the new logo is somewhat similar to the xmonad logo
09:23:24 <athos> indeed
09:23:35 <athos> and there still is no mascot :(
09:23:41 <athos> at least no official one i think
09:23:41 <ehird> a logo was picked?
09:23:46 <ehird> which?
09:24:20 <ehird> ah.
09:24:25 <ehird> the _wrong_ one. ;-)
09:24:39 <athos> !
09:24:42 <sannysanoff> new logo is not good.
09:24:48 <lilac> which one?
09:24:49 <sannysanoff> old log is much more inspiring!
09:24:52 <sannysanoff> old logo
09:24:53 <ehird> http://www.haskell.org/logos/logos/logo7000.png
09:24:59 <ehird> I like the concept, but it doesn't have a "box"
09:25:05 <ehird> e.g. in the haskell reddit it pokes out a bit
09:25:10 <ehird> doesn't seem to fit together
09:25:26 <BONUS> i like it :]
09:25:33 <lilac> is that the logo for haskell for commodore 64?
09:25:50 <Cale> I was just going to say, it reminds me a bit too much of the C64 logo :)
09:26:43 <jeffersonheard> ah, but think of all the new binary operators we could add if we still had the c64 keyboard
09:26:50 <Saizan> this one was clearly the best http://haskell.org/logos/logos/hasksun4.png
09:26:52 <jeffersonheard> HaskeAPL
09:26:54 <sannysanoff> beat me to death, but haskell does not have so much sharp edges!!
09:27:02 <sannysanoff> (re: logo)
09:27:03 <ehird> Saizan: that's way too cluttered
09:27:18 <ehird> sannysanoff: Yeah, I think a smoother, rounder version of the new one would be best
09:27:27 <lilac> sannysanoff: what is that, some kind of strange attractor?
09:27:41 <ehird> lilac: Saizan
09:27:42 <lilac> s/sannysanoff/Saizan/
09:28:13 <lilac> ok, that's it, no more than 26**2 people are allowed on IRC at once
09:28:29 <ehird> @users
09:28:29 <lambdabot> Maximum users seen in #haskell: 658, currently: 630 (95.7%), active: 24 (3.8%)
09:28:36 <Saizan> i don't really know, but it looks badass
09:28:38 <ehird> lilac: there are less than 26**2 in here atm
09:28:39 <Cale> Hmm... "Tokyo Society for the Application of Currying"
09:28:47 <dancor> badass++
09:28:54 <vixey> Cale, such a good pun
09:28:59 <Cale> (TSAC should not be confused with the Tokyo Schönfinkel Appreciation Club a rather strange group of people who seem to have some sort of beef with Haskell Curry.)
09:29:27 <dons> i guess we should just make a wiki page for variants of the current logo
09:29:32 <vixey> that's real o_o
09:29:54 <BONUS> i like the new logo a lot, i just think it might use some colors
09:30:08 <earthy> oh, has it been chosen?
09:30:09 <BONUS> when i think of haskell, i still don't associate it with any color
09:30:12 <ehird> haskell prime should be renamed Moses
09:30:19 <vixey> haskell is green
09:30:24 <ehird> haskell is octarine
09:30:25 <vixey> like neuclear waste
09:30:27 <BONUS> maybe i think of it as a kind of RWH purple
09:30:29 <ehird> duh
09:30:31 <BONUS> hehe octarine yeah
09:30:50 <BONUS> actually i think the new logo would be smashing in purple
09:31:24 <dons> BONUS thinks everything is smashing in purple
09:31:35 <Stinger> yes, shmashing *smokes pipe*
09:31:36 <lilac> @type (>\=)
09:31:36 <ehird> Purple is smashing in purple
09:31:37 <lambdabot> Not in scope: `>\='
09:31:38 <BONUS> haha true
09:31:51 <earthy> ah, good. ;)
09:32:04 <sannysanoff> haskell is monospace!
09:32:07 <lilac> @let (>\=) = "Haskell!"
09:32:09 <lambdabot>  Defined.
09:32:39 <ehird> lilac: it's more >>\=
09:32:52 <doserj> \\__
09:32:55 <doserj> /\-
09:33:05 <doserj> damn
09:33:07 <earthy> ;)
09:33:09 <doserj> \\__
09:33:10 <BONUS> i read >\= kind of as DONT BIND!
09:33:18 <ehird> @let (>>\=) = (>>) . (\x -> something involving =)
09:33:18 <lambdabot>   Parse error
09:33:18 <doserj>  \\__
09:33:23 <doserj>  //\--
09:33:32 <EvilTerran> (>λ=)!
09:33:33 <earthy> almost, doserj
09:33:37 <doserj>  \\__
09:33:39 <doserj>  //\-
09:33:43 <earthy> gotcha! :)
09:34:09 <BONUS> (>\=) = const . const mzero
09:34:22 <ehird> @let (>λ=) = const . const mzero
09:34:22 <lambdabot>   Parse error
09:34:23 <EvilTerran> ?type const.const mzero
09:34:24 <lambdabot> forall b (m :: * -> *) a a1. (MonadPlus m) => a1 -> b -> m a
09:34:35 <EvilTerran> λ is alphanumeric
09:34:41 <ehird> ugh
09:34:54 <osfameron> it's hideous... \ is prettier...
09:35:06 <ehird> osfameron: lambda is not hideous, you, you you thing!
09:35:09 <osfameron> (in lucida console or whatever font this is at any rate)
09:35:18 <ehird> lucida console? ow
09:35:20 <osfameron> it's like a retarded backwards "h"
09:35:23 <lilac> > (>\=) :: Expr
09:35:24 <lambdabot>   \\__
09:35:24 <lambdabot>  //\-
09:35:30 <lilac> :(
09:35:33 <Olathe> O-o
09:35:48 <lilac> > (>\=) :: Expr
09:35:50 <lambdabot>   \\__
09:35:50 <lambdabot>   //\-
09:36:11 <Gracenotes> >>\= is actually "don't do a signed right shift, modifying the original variable"
09:36:28 <osfameron> heh
09:36:37 <dancor> it's guaranteed to do any other operation
09:36:45 <BONUS> hey who made the cabal logo
09:36:47 <BONUS> i like that a lot
09:37:11 <skorpan> jeff's logo is awesome
09:37:17 <Gracenotes> it just needs some happy colors
09:37:19 <EvilTerran> which one's jeff's?
09:37:32 <earthy> the chosen one. :)
09:37:37 <lilac> who is jeff? :)
09:38:03 <opqdonut> the guy who made the logo
09:38:16 <lilac> i meant, /nick? or does he not irc?
09:39:08 <lilac> anyway, i'm off to graffiti the new logo on various walls ;-)
09:39:54 <ehird> :t ap
09:39:55 <Gracenotes> we need shirts with the narwhal logo and the "freedom from state" logo
09:39:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:39:57 <ehird> :t (<*>)
09:39:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:40:09 <idnar> separation of church and state?
09:40:14 <comex> <interactive>:1:0: Not in scope: `<*>'
09:40:17 <Gracenotes> there already is a shift with the "freedom from state" graphics logo on it, but not the witty text
09:40:18 <comex> <interactive>:1:0: Not in scope: `ap'
09:40:21 <ehird> comex: so import them.
09:40:22 <ehird> @hoogle ap
09:40:22 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
09:40:23 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
09:40:23 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
09:40:25 <ehird> @hoogle (<*>)
09:40:25 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:57:05 <vixey> where does this strange notation come from?
09:57:12 <vixey> data Maybe a = Nothing | Just a
09:57:25 <vixey> especially: Just a
09:57:26 <idnar> why is that strange?
09:58:12 <vixey> it's odd because Just is a value whereas a is a type
09:58:13 <gnuvince> vixey: Just is a data constructor that takes one argument of type a.  That seems like a good syntax to illustrate that.
09:58:29 <vixey> but where is it from?
09:58:37 <gnuvince> You invent it.
09:58:46 <vixey> no I didn't
09:59:00 <gnuvince> data GnuvinceFood = Sandwich | Pizza | Kiwis
09:59:03 <conal> vixey: ML was first and had a similar notation.  i don't know how it was cooked up.
09:59:14 <vixey> why would ML choose this
09:59:21 <conal> i wonder also.
09:59:42 <vixey> Is it BNF
09:59:53 <Sekaino> Darn dyslexia... http://hackage.haskell.org/cgi-bin/hackage-scripts/package/salvia-0.1.1  Perhaps not the best choice of name for dyslexic readers.
10:00:02 <idnar> haha
10:00:04 <RayNbow> :D
10:00:10 <gnuvince> I fear I don't see the problem then.
10:00:20 <tromp> saliva?
10:00:35 <ddarius> vixey: There is certainly a relation to BNF.
10:00:35 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
10:00:53 <RayNbow> <vixey> it's odd because Just is a value whereas a is a type <-- I once tried teaching ADTs to someone via MSN Messenger... he also stumbled over this
10:01:15 <conal> vixey: hm.  might be from BNF.  ML was a "metalanguage" for LCF.
10:01:20 <ddarius> From one perspective, "Just" is just a label (like for records)
10:01:37 <idnar> let's switch to GADT syntax exclusively :P
10:01:38 <ddarius> Miranda and Clean use a syntax that is even more reminescent of BNF
10:02:25 <Sekaino> ddarius, do you happen to know the current status of Clean?  I lost track of it a few years back.
10:02:26 <RayNbow> idnar: well, the person I was talking to on MSN thought the GADT notation was clearer when I showed him that alternative :p
10:02:48 <ddarius> Sekaino: It's alive and well as far as I know, unless that has changed in the last year or so.
10:03:07 <Sekaino> ddarius, do they have dynamic linking working on linux yet? :)
10:03:07 <idnar> RayNbow: the only problem I have with GADT notation is that the "structure" of the data type seems to be magicked out of thin air
10:03:10 <quicksilver> vixey: even without typevariables
10:03:22 <idnar> RayNbow: of course, that's also true for the normal syntax, but it doesn't seem that way
10:03:23 <quicksilver> vixey: data ContainsAnInt = CAI Int
10:03:38 <quicksilver> vixey: you still have the "surprising" juxtaposition of constructor CAI with type Int
10:03:41 <idnar> RayNbow: "Just a" looks like a sort of container with some holes in it where you can put stuff
10:03:46 <quicksilver> the type variable case is just the natural abstract of that.
10:03:56 <idnar> Just :: a -> Maybe a is just a function... where does the body magically come from?!
10:04:10 <vixey> what body?
10:04:17 <idnar> the definition, I mean
10:04:20 <ddarius> Sekaino: I've never used Clean.
10:04:27 <vixey> Just = <this part?>
10:04:32 <idnar> yeah
10:04:38 <idnar> the compiler supplies it, obviously
10:04:41 <vixey> it doesn't come from nowhere
10:04:43 <RayNbow> idnar: true
10:04:45 <idnar> but it just somehow seems more magical than "Just a"
10:04:53 <vixey> it doesn't come at all -- there is no definition
10:05:12 <idnar> vixey: there is code that is executed when "Just 5" is evaluated
10:05:40 <doserj> there is nothing to evaluate in "Just 5"
10:05:51 <idnar> or, well, bad terminology
10:06:20 <idnar> but the point is, Just is a function; when you apply it, something has to decide what happens
10:06:56 <doserj> 'Just' applied to some value 'x' is the value 'Just x', by definition.
10:07:00 <jeffersonheard> what's the diff. between fcat and vcat in Text.PrettyPrint?
10:07:02 <edwardk> idnar: the gadt syntax is pretty close to what other languages with (co)inductive data structures do, so i guess its just a familiarity thing
10:07:05 <chalkyExt> f
10:07:18 <vixey> doserj: Well that is a truism, and doesn't seem to explain anything
10:07:19 <jeffersonheard> i.e. I don't know what a "paragraph fill" is supposed to mean in this context
10:07:27 <jeffersonheard> is fcat the list version of $+$?
10:07:31 <doserj> vixey: the point is, there is nothing else to do
10:07:38 <Aisling> Just is a data constructor like any other, afaict?
10:07:48 <idnar> doserj: 'Just x' doesn't get stored as a string in memory :P
10:08:19 <doserj> idnar: it get's stored as the constructor 'Just', applied to the value 'x'
10:08:39 <vixey> idnar: Is it confusing because something (the implementation of Just) is computed from the type?
10:09:08 <idnar> doserj: yes, I understand how it works; I'm just trying to describe why the two different syntaxes affect me differently
10:09:12 <idnar> vixey: I think so
10:10:02 <idnar> vixey: perhaps if I'd learned GADT syntax first, I wouldn't have this hangup
10:10:31 <vixey> I wonder if there are any more syntaxe
10:10:32 <idnar> vixey: but I guess in some part of my brain, I think of "Just x" and "Either a b" as specifying a sort of notional in-memory representation
10:10:35 <vixey> syntaxes
10:10:56 <idnar> all they actually do is specify a constructor name and argument order, which is the same as the GADT syntax
10:11:15 <idnar> actually, maybe it's because I'm familiar with C/C++
10:11:41 <idnar> "Either a b" is kinda like "struct foo { int a; int b; }"
10:11:48 <idnar> although that's a bit of a stretch
10:11:56 <vixey> no that is no stretch
10:12:05 <vixey> they are very similar
10:12:09 <ddarius> data constructors are similar to (the predefined) constructors in C++.  They are one of the major places where memory is actually allocated and initialized.
10:12:29 <idnar> ddarius: well, hmm, that's an interesting comparison
10:12:41 <vixey> struct left { int a }
10:12:52 <idnar> in C++, you have to define the class members, and then you write a separate constructor (or use the default one)
10:13:38 <Sekaino> idnar,  data Foo = Foo { a :: Int, b :: Int }
10:13:39 <idnar> with GADT syntax, you just write the type of the constructor, and you don't get to define any special behaviour, so there's no body
10:13:49 <idnar> and then the class "members" are magically inferred
10:14:18 <idnar> (and they're also anonymous)
10:14:32 <idnar> I don't suppose you can combine GADT syntax with record syntax
10:15:31 <ddarius> abstract class Maybe<A> { public abstract B maybe<B>(B b, Func<A,B> f); }; class Nothing<A> : Maybe<A> { public Nothing(){}; public override B maybe<B>(B b, Func<A,B> f) { return b; } }; class Just<A> : Maybe<A> { public Just(A a) { _a = a; }; public override B maybe<B>(B b, Func<A,B> f) { return f(_a); }; private readonly A _a; }
10:15:53 <pejo> bos, did you release that frameworkish thing that you used for comments on RWH?
10:15:57 <RayNbow> ddarius: how dare you to stain this channel with ugly Java! :p
10:16:03 <ddarius> RayNbow: That's not Java.
10:16:06 <RayNbow> oh wait
10:16:11 <RayNbow> yeah, I noticed the :
10:16:23 <idnar> C#?
10:16:24 <bos> pejo: you can find it at http://hg.serpentine.com/mercurial/book/
10:16:28 <lilac> i'm so glad i can just write 'data Maybe a = Nothing | Just a'
10:16:28 <seliopou> that is even worse
10:16:29 <ddarius> idnar: Yes.
10:16:33 <pejo> bos, thank you!
10:16:37 <idnar> man, generics :(
10:16:59 <ddarius> lilac: Well that C# example has some benefits (it's extensible, sort of) and some drawbacks.
10:17:08 <idnar> I tried to write a python version of Maybe
10:17:11 <idnar> I'm not sure it was a success
10:17:51 <lilac> ddarius: yeah, the semantics don't quite match; a closer example would be
10:18:00 <idnar> wrapping Just around values is awkward, but without the wrapper, it's hard to implement other operations nicely
10:19:13 <lilac> class Maybe t a where maybe :: t -> b -> (a -> b) -> b; data Nothing; data Just a = Just a; instance Maybe Nothing a where maybe _ b _ = b; instance Maybe (Just a) a where maybe (Just a) _ f = f a
10:19:39 <ddarius> lilac: That's farther.  Now you can't make a list of Maybe.
10:19:54 <lilac> data IMaybe a = forall t. Maybe t a => IMaybe t
10:20:11 <RayNbow> are there any IRC clients that can parse Haskell and pretty format it? :p
10:20:11 <jedai> and instance IMaybe
10:20:47 <ddarius> lilac: At that point you might as well pass the dictionary around explicitly, but then you find the "dictionary" is just the maybe function and you rediscover Church-encoding.
10:31:16 <C-Keen> dcoutts: yet another cabal question: how do I pass linker flags to ghc?
10:33:34 <luite_> is there a way to automatically install all dependencies for a package, with profiling enabled?
10:33:39 <luite_> using cabal-install
10:35:28 <Saizan> you can pass -p to build a package with profiling, but cabal can't find the packages to reinstall for you, currently
10:36:04 <Saizan> if the dependencies are already installed, i mean
10:36:07 <luite_> Saizan: yes I know, the problem is just with the dependencies that were already installed
10:38:54 <dons> did anyone else know this was valid?
10:38:55 <dons>  map :: ((a :: *) -> b) -> [a] -> [b]
10:39:43 <vixey> hm what is the purpose of this, some kind of precursor to kind polymorphism?
10:40:14 <Gracenotes> , diagonal [[0..], [0..]]
10:40:17 <lunabot>  [0,1,0,2,1,3,2,4,3,5,4,6,5,7,6,8,7,9,8,10,9,11,10,12,11,13,12,14,13,15,14...
10:40:29 <Gracenotes> , diagonal [[0..], [0..],[0..]]
10:40:30 <lunabot>  [0,1,0,2,1,0,3,2,1,4,3,2,5,4,3,6,5,4,7,6,5,8,7,6,9,8,7,10,9,8,11,10,9,12,...
10:41:40 <jeffersonheard> blarghargle.  I recompiled GHC the other day and now it's not catching any control characters.  Can't even backspace
10:42:31 <vixey> I wonder if we could replace this horrid command line interface that keeps getting replaced with some basic GKT thing
10:42:35 <vixey> GTK
10:42:54 <kynky> licensing
10:42:54 <Cale> jeffersonheard: What would bring you to recompile GHC? Are you running the development version?
10:43:20 <jeffersonheard> No, I run ubuntu and I wanted to use GHC 6.10.1, so I downloaded the sources and compiled it
10:43:26 <Saizan> jeffersonheard: "cabal install ghci-haskeline"
10:43:28 <kynky> would assume it would have to be bsd3 compatible
10:43:32 <Cale> jeffersonheard: The generic linux binary works.
10:43:35 <jeffersonheard> Saizan; THANK YOU
10:43:44 <dons> jeffersonheard: i notice there are no screenshots or code for hieroglyph demos?
10:44:01 <Cale> jeffersonheard: so you don't have to waste your time compiling in the future :)
10:44:17 <dons> jeffersonheard: isn't that editline ?
10:44:28 <jeffersonheard> Cale: Oh, I never thought to check...  saw Fedora on there and thought better of installing it
10:45:38 <jeffersonheard> dons: I got hammered with this Big Board project and with the AVL project...  There are some simple examples on my blog, but you're right.  it's time to get going on some demos
10:46:09 <dons> cool. i want to do a survey of 2D graphics options for haskell
10:46:14 <dons> so having demo code is useful :)
10:46:24 <jeffersonheard> I should clean up the data waves stuff, then
10:46:39 <jeffersonheard> Need an interactive demo as well
10:46:43 <kynky> well there is cairo and gd
10:46:50 <dons> and a dozen others
10:46:54 <kynky> gd aka libgd
10:47:32 <kynky> platform specific ones too
10:48:34 <jeffersonheard> dons: if you want, I can send you the datawaves code, and you can look at it if that'd help.  Otherwise it'll be when I get five minutes free to clean it up
10:49:21 <jeffersonheard> dons: The Big Board = the cover story at www.renci.org, and yes, it's entirely written in Haskell
10:49:39 <jeffersonheard> AVL = automated vehicle location, which is written in python actually.
10:50:19 <edwardk> dons: kind annotations work anywhere on types
10:50:26 <dons> jeffersonheard: oh, for SC09?
10:50:30 <dons> you'll be in town?
10:50:36 <jeffersonheard> dunno yet.  I might be
10:50:55 <kynky> cairo is lgpl or mpl, but gtk2hs is lgpl, mpl plays nicer with bsd3 licensing of ghc, than the lgpl does in regards with distributing static linked files from what i can understand
10:51:19 <dons> you should hammer this 'haskell for visualisation' story. :)
10:51:29 <merve> =)
10:51:48 <jeffersonheard> dons: I have a book proposal out at CUP, and they said "we'll go ahead with it, but revise it" and I've been sitting on it unfortunately
10:51:55 <jeffersonheard> need to finish the revisions and get it out the door
10:52:02 <jeffersonheard> on Haskell for Vis.
10:52:10 <dons> have you considered speaking at CUFP about the big board?
10:52:14 <jeffersonheard> and I will be submitting Hieroglyph at the Haskell Symposium
10:52:18 <jeffersonheard> dons: I have indeed
10:52:38 <jeffersonheard> dons: do you want me to run the same tutorial, revised, that I did last year?  are we doing tutorial sessions again?
10:52:54 <dons> yeah, DEFUN is on again
10:53:51 <jeffersonheard> well that answers the second question :-)
10:56:54 <jeffersonheard> dons: is the call for papers out on CUFP yet?  I saw the haskell symposium
10:57:05 <jeffersonheard> also some conference out in Slovakia that looks similar to CUFP
10:57:06 <agruman> heya, do haskell have multiline comments?
10:57:12 <dons> http://cufp.galois.com/2009/call.html
10:57:15 <jeffersonheard> agruman, yes {- -}
10:57:18 <dons> deadline for presentations is May 15
10:57:23 <jeffersonheard> dons: Thanks
10:57:34 <dons> i'd strongly suggest something about the big board :)
10:57:39 <agruman> jeffersonheard, thanks
10:57:46 <dons> jeffersonheard: it's getting deployed in the field?
10:58:51 <jeffersonheard> dons: yes, indeedy.  We'll have it in the NC EOC for the June Emergency Management exercise.  A prof at Duke will be using it next semester for something or other I forget.  We're integrating most of our data streams with it.
10:58:57 <jeffersonheard> I'm in the middle of a big rewrite
10:59:06 <dons> awesome. amazing work, and well done!
10:59:23 <alexsuraci> yay, the logo I wanted won :D
11:00:08 <jeffersonheard> The rewrite is supposed to add KML, WFS/WGS, and shapefile support, which is a huge pain.  Also rewriting the display code using Hieroglyph now that I have hieroglyph and simultaenously working on an abridged GL backend for it
11:02:54 <goomba`> what does it mean when a newtype definition has a pair of { } 's after it along with a function signature inside those braces?
11:03:14 <dons> you're defining a single field record
11:03:17 <dons> with an accessor
11:03:34 <goomba`> thanks
11:04:31 <edwardk> goomba`: data Foo a = Foo { bar :: a, baz :: Int } -- is like saying data Foo a Int; bar (Foo a _) = a; baz (Foo _ i) = i -- but it also lets you use record syntax to define and rewrite just part of the record
11:05:08 <edwardk> er data Foo a = Foo a Int
11:11:10 <quicksilver> conal: I'm having considerable difficulty writing what should be a natural Reactive combinator
11:11:21 <conal> yeah?
11:11:39 <quicksilver> conal: a Behaviour which, on receiving an Event (Behaviour) switches to that for a finite time only
11:11:49 <quicksilver> and then falls back to its original behaviour.
11:12:18 <conal> hm
11:12:54 <quicksilver> I'm open to the possibility that I've cast the problem wrong. I can step back to the concrete problem I'm trying to solve, if you like ;)
11:13:57 <conal> quicksilver: your combinator sounds useful.
11:14:07 <quicksilver> The concrete problem is a number of possible states with 'transitions' in between
11:14:14 <quicksilver> where a transition lasts a finite time.
11:14:37 <quicksilver> so the goal is to take an Event (s -> s)
11:14:46 <quicksilver> (requests to change state)
11:14:53 <quicksilver> and produce Behaviour (Transition s)
11:15:04 <quicksilver> in which, data Transition s = InState s | Transition Double s s
11:15:22 <quicksilver> that is, we are either in the state 's', or we are in transition between two states.
11:15:35 <quicksilver> (the Double just ranges from 0..1 during the transition)
11:15:53 <quicksilver> it's all about animated GUIs really.
11:16:01 <conal> neat
11:16:19 <quicksilver> it would be, if I could do it ;)
11:16:25 <conal> heh
11:16:46 <conal> the duration is known when the transition starts?
11:16:49 <quicksilver> Yes.
11:17:07 <quicksilver> in fact it might as well be fixed to 1 second for the purpose of discussion.
11:17:58 <conal> with the current model (absolute time, non-interactive behaviors), what you want will be awkward.
11:18:17 <quicksilver> :(
11:18:38 <conal> yeah
11:18:39 <quicksilver> how did your work on relative time behaviours go?
11:19:26 <conal> mostly fine, iirc.  i got discouraged about a tension -- perhaps even conflict -- between Monoid and Comonad.
11:19:30 * quicksilver nods
11:19:47 <conal> Monoid insists that there be zero-duration segments, and Comonad that there not be.
11:19:50 <quicksilver> I've been fighting this problem and gone combinator-blind
11:19:56 <quicksilver> can I confirm something about the semantics of switcher?
11:20:01 <conal> sure
11:20:24 <quicksilver> the Event is 'in charge', in the sense that when the Event decides its time for a new behaviour, the old behaviour is powerless to change it, right?
11:21:14 <conal> quicksilver: hard for me to think about in those terms.  it's functional.  nothing really changes.
11:21:38 <quicksilver> yes, I like to anthropmorphise.
11:21:42 <conal> but if you mean the semantics of switcher, then i think i get you, and yes.
11:21:58 <quicksilver> After the second occurrence of the event, the behaviour which was in the first occurrence has no semantic relevance
11:22:14 <quicksilver> we are now determined entirely by the behaviour which is in the second occurrence
11:22:19 <quicksilver> (until the 3rd occurrence, etc)
11:22:22 <conal> (it's like (+).  the arguments don't get to overrule addition.)
11:22:26 <jeffersonheard> I so rarely use GHCi...  what does it mean when it complains that X is a package module and won't load it?  How do I get the same effect as a series of import statements?
11:22:34 <conal> yeah
11:22:40 <conal> (for quicksilver)
11:23:04 <quicksilver> conal: OK, good. Well I think I can do what I need with (a) a delay combinator (b) recursion and (c) explicit agiing.
11:23:19 <quicksilver> conal: but it's the need to use explicit aging which made me think I'd done somethign wrong.
11:23:24 <quicksilver> that's combinator smell!
11:23:39 <quicksilver> (also I'm not sure recursion works problem in my implementation anyway ;P)
11:23:48 <quicksilver> s/problem/properly/
11:23:54 <conal> quicksilver: explicit aging fits very nicely with Comonad (interface & semantics)
11:24:01 <quicksilver> indeed.
11:24:22 <conal> quicksilver: and yeah, its obviated in a model for relative-time, interactive behaviors.
11:24:27 <quicksilver> and I do have cojoinE and cojoinR in my code-base.
11:24:36 <conal> me too
11:24:40 <quicksilver> not sure what you mean by interactive in this context?
11:25:53 <conal> quicksilver: as described in http://conal.net/blog/posts/why-classic-frp-does-not-fit-interactive-behavior/
11:26:10 <quicksilver> will take a moment to load over 3G :)
11:26:25 <quicksilver> oh, I read that post.
11:26:30 <quicksilver> the terms didn't stick.
11:26:54 <quicksilver> conal: I have a probably obvious observation about the missing monad instance for Behaviour
11:27:06 <conal> yeah?
11:27:16 <quicksilver> conal: we can't quite write (B a) -> (a -> B b) -> (B b)
11:27:36 <quicksilver> however, in practice you should be able to rewrite your middle combinator in the form B(a -> b)
11:27:49 <conal> applicative?
11:28:06 <quicksilver> (because semantically (a -> B b) = (a -> t -> b) = (t -> a -> b) = (B (a -> b))
11:28:17 <quicksilver> ..and if you can, you can just use <*>
11:28:37 <quicksilver> in every practical case I have thought I needed the Monad instance for B I've been able to do this transformation on my code.
11:28:39 <conal> oh yeah.  i hadn't noticed that equivalence. :)
11:28:49 <conal> cool.  thanks for the tip.
11:28:55 <quicksilver> although I'm not claiming I can do it mechanically.
11:29:07 <quicksilver> just that it should generally be possible, and that's the semantic reason why.
11:29:18 <conal> nice. :)
11:29:50 <quicksilver> it depends how "opaque" the time-dependence is, I think.
11:29:53 * BMeph_ always mentally changes "cojoinE" to "cojones"
11:29:56 <sbahra> I like the new logo
11:30:04 <quicksilver> wow! someone likes it :)
11:30:18 <sbahra> It's nice
11:30:26 <sbahra> Minimalist.
11:30:48 <Mr_Giraffe> out of curiosity, what projects do you guys use these crazy sets of functions for?
11:30:56 <lament> there's a new logo?
11:30:57 <conal> i'm resigned.  if people think of Haskell as half-sequential then i guess the logo fits.
11:31:01 <sbahra> lament, apparently
11:31:06 <sbahra> lament, http://www.haskell.org/logos/logos/logo7000.png
11:31:14 <lament> haskell.org still has the old one
11:31:27 <quicksilver> Mr_Giraffe: which crazy sets of functions?
11:31:28 <lament> hah, did that one win?
11:32:09 <lament> wow, won by far
11:32:09 <jmelesky> conal: i think mostly people think of haskell as having many funny-looking operators, some of which are photogenic
11:32:11 <Mr_Giraffe> quicksilver: ah, wait
11:32:12 <tromp> >\=
11:32:16 <Mr_Giraffe> are you doing functional-reactive stuff?
11:32:30 <lament> i still think it's too militaristic-looking... but it's probably the nicest one :)
11:32:41 <lilac> conal: i think emphasizing haskell's explicit use of monads (as opposed to most languages where they are implicit) is probably a good thing in the logo
11:33:07 <conal> lilac: yeah.  sigh.
11:33:21 <lilac> the nice thing about haskell as compared to most mainstream languages is that you can choose to work outside all monads (except Partial)
11:33:26 <conal> we wear our sins on our sleeves. i guess that's progress.
11:33:50 <tromp> so the >>= and lambda denote pure and functional
11:34:12 <tromp> the logo doesn't show laziness though
11:34:15 <lilac> tromp: well, as pure as a partial language can get, i guess :)
11:34:26 <lilac> tromp: the logo wasn't even coloured in. how lazy is that?
11:34:46 <tromp> it has 2 shades of grey though"_
11:34:50 <dons> laziness bah
11:34:57 <conal> "segregated" fits better than "pure" for me.
11:35:01 <dons> functions, and the real world (>>=)
11:35:06 <conal> haskell: a segregated functional language.
11:35:11 <lament> it's very sharp-looking
11:35:16 <Mr_Giraffe> conal: separate but equal?
11:35:16 <lament> pointy
11:35:18 <dons> applying functional approaches to the world.
11:35:23 <dons> that's what it's saying :)
11:35:41 <conal> the world isn't sequential.
11:35:49 <conal> imperative programming is.
11:35:49 <BMeph_> "Haskell - Parental Advisory: Explicit Monads" ;p
11:35:54 <BONUS> @remember dons applying functional approaches to the world.
11:35:54 <lambdabot> Done.
11:35:55 <conal> "applying functional approaches to imperative programming."
11:35:58 <dons> >>= is not imperative
11:36:05 <dons> it's just how we solve a lot of world problems
11:36:06 <BONUS> i like that as a catchphrase/motto
11:36:18 <conal> dons: by the world, you meant imperative, not monadic, right?
11:36:21 <mstr> "implicit use of monads in other languages" what is that?
11:36:35 <dons> monadic approaches to manage messy awkward problems
11:36:38 <dons> in general.
11:36:41 <BMeph_> dons: To mix about three metaphors at once, not even a categorical imperative? ;p
11:36:45 <conal> yeah.
11:36:56 <conal> anyway, just my personal disappointment that the >>= is a large as the lambda.
11:37:09 <tromp> actually, the absence of ' in the logo denotes laziness:)
11:37:17 <monochrom> haha
11:37:17 <dons> fundamentally, we use functional approaches (purity, laziness) and types, to solve the awkward squad and get stuff done.
11:37:27 <lilac> mstr: imperative languages tend to live in the IO monad. some pure languages live in Cont.
11:37:59 <lilac> mstr: that is, all operations in these languages can have side effects, or call a continuation, or whatever
11:38:05 <conal> dons: for that perspective, the logo fits.  it's just not my perspective.
11:38:28 <mstr> ah
11:38:29 <conal> i'm not objecting to the logo as a community statement.  just feeling a bit lonely.
11:38:38 <sjw> dons: I like the logo :)
11:38:48 <tromp> it grew on me
11:38:51 <sjw> although I suppose the arrows people will grumble :)
11:39:14 <sjw> and you could have tried to stuff in a turnstile somewhere
11:39:16 <monochrom> where is the new logo?
11:39:17 <lilac> conal: i dislike the logo basically because it puts an emphasis on implementation (>>=) rather than representation and semantics
11:39:28 <conal> lilac:  :)
11:39:50 <quicksilver> I dislike the logo because it reminds me of an ugly train company logo.
11:39:56 <pumpkin> &&&>>=<*>fmap should be the new logo, to appease all the main typeclasses
11:39:56 <lilac> that said, i think it's a neat way of representing what it does represent, and for some people will perfectly describe how they view haskell :)
11:40:02 <jeffersonheard> I dislike W3C standards documents
11:40:11 <lament> i guess this logo does mean that Haskell is not about to throw away monads
11:40:11 <mstr> that image up there is the new haskell logo?
11:40:34 <quicksilver> conal: well, since you don't have an immediate solution I will plug away at my hacked attempts.
11:40:34 <conal> lilac: that's what i'm realizing as well.  other people come to haskell for reasons quite different from mine.   and it's their logo.
11:40:36 <lament> weren't monads meant as a temporary solution?
11:40:43 <mstr> a lot better than current one, althought just about anything would be :)
11:40:44 <conal> quicksilver: yeah.  go for it.
11:40:45 <pumpkin> :o
11:40:54 <quicksilver> conal: I needed to add 'delay' anyway.
11:40:58 <pumpkin> lament: temporary solution until what?
11:41:06 <conal> quicksilver: is it semantic?
11:41:15 <quicksilver> conal: unfortunately my model doesn't admi events guaranteed to occur at fixed times.
11:41:25 <monochrom> Oh haha, I see now, it's a railway logo alright. :)
11:41:26 <lament> lilac, conal: if it's any consolation, the current logo, which haskell had for ages, has >>
11:41:35 <quicksilver> s/model/implementation/
11:41:38 <lament> pumpkin: until something better is invented
11:41:46 <pumpkin> hmm
11:41:47 <jmcarthur> lament, i think monads were just meant as a better solution than what was before... streams
11:41:49 <quicksilver> I've known I needed to add them for a while.
11:41:49 <quicksilver> I've known I needed to add them for a whI guess then is now.
11:42:17 <jmcarthur> arguably, everything about haskell was tentative... until we started building a big collection of libraries and programs
11:42:18 <quicksilver> conal: delay is perfectly semantics, yes. [(t0,v0),(t1,v1),...] --> [(t0+d,v0),(t1+d,v1),...]
11:42:27 <conal> quicksilver: cool.
11:42:36 <jmcarthur> avoiding success at all costs meant haskell could be more agile, but that is beginning to change, i think
11:42:37 <jmelesky> jmcarthur: and started getting popular
11:42:43 <conal> i think there was a lot of creativity about genuinely (semantically) functional I/O before the monadic approach was invented.
11:43:00 <quicksilver> conal: I don't even have `atTimes` though.
11:43:17 <conal> which made imperative programming workable.  less incentive to replace it.
11:43:27 <jmcarthur> even haskell' is making a lot of sacrifices in the name of some backward compatibility
11:43:55 <lament> jmcarthur: time to switch to agda? :)
11:44:02 <lilac> conal: i don't know if this helps, but it was you who made me realise that haskell is about representation and semantics, and letting the implementation flow from that
11:44:03 <jmcarthur> lament, perhaps :)
11:44:14 * jmcarthur has taken a lot of interest in agda
11:44:20 <conal> lilac: thanks!  :)
11:44:48 <quicksilver> conal: monads aren't a bar to functional smenatics, inherently. If you implemented 'putStrLn' using a Writer monad that would be a perfectly functional semantics of 'O'
11:44:54 <quicksilver> and it would still be a monad.
11:45:02 <jmcarthur> conal is a morally stabilizing force in the haskell community :)
11:45:10 <conal> lilac: i'm starting to use the term "denotational programming" as a replacement for "functional programming", since use of the latter has come to include imperative programming.
11:45:29 <quicksilver> the palce the functional semantics fall down is when you bundle all the operational semantics of libc/POSIX into a box called 'IO'.
11:45:33 <conal> quicksilver: i agree.  i love Monad.
11:46:06 <BMeph_> conal: Just wondering, but did you ever toy around with the concept of segments having (Maybe a) length/duration, with Nothing representing functions (i.e., having no limit)? :)
11:46:46 <conal> BMeph_: yes about allowing infinite duration, though not necessarily with that representation.
11:49:50 <CSWookie> I'm trying to work my way through "A gentle Introdution", and the examples it uses keep bringing up errors in ghci.  What am I doing wrong?
11:50:27 <conal> CSWookie: tough to guess.  example?
11:51:42 <CSWookie> conal: I'm trying to use the forall function it talks about in the polymorphic types section, and it says forall is not in scope.
11:51:58 <CSWookie> And I'm getting parse errors when I try to define the inc function it defines.
11:52:25 <conal> CSWookie: it's a language extension.  you'll need a LANGUAGE pragma
11:52:33 <CSWookie> I'm thinking maybe I need to put ghci into some other mode, or import a library or something?
11:52:37 <paper_cc> {-# LANGUAGE ExistentialQuantification #-}
11:52:41 <CSWookie> Ah.
11:52:55 <conal> CSWookie: the particular extension depends on your use of forall.
11:53:08 <paper_cc> CSWookie: in GHCi, use ghci -XExistentialQuantification
11:53:10 <conal> could be ExistentialQuantification, ScopedTypeVariables, Rank2Types, or RankNTypes
11:53:52 <CSWookie> Huh.
11:53:53 <conal> if you use the LANGUAGE pragma instead of -X..., you won't have to repeat it on each compile
11:54:19 <CSWookie> conal: Well, I want to play int the interpreter for now, not write to files.
11:54:24 <CSWookie> But thanks.
11:54:26 <conal> but if you want to use in in the repl, then i guess -X is your friend.
11:54:29 <BMeph_> CSWookie: Or use :set -XExistentialQuantification
11:54:43 <conal> which you can also put in a .ghci
11:54:50 <BMeph_> s/Or/Then/ :)
11:55:14 <jeffersonheard> Is there a combinator I'm missing for alternation in Text.PrettyPrint?   I'm looking for something such that l <combinator> r = if isEmpty l then r else l
11:55:38 <CSWookie> That still complains.
11:56:00 <conal> CSWookie: maybe a different extension.  what's the code?
11:56:09 <vixey> jeffersonheard: you can define it yourself
11:56:21 <CSWookie> conal: You have a pastebin?  I can paste a screen grab.
11:56:34 <conal> @hpaste
11:56:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:56:48 <CSWookie> (forall a)[a]
11:57:03 <CSWookie> OK, Screen grab ahoy.
11:57:05 <jeffersonheard> vixey, I know that.  I was going to; didn't want to obfuscate my code by defining already defined functions.
11:57:10 <conal> try "forall a. [a]"
11:57:30 <vixey> when you do functional programming, it's not obfuscation to define some new functions
11:57:30 <CSWookie> Same thing...  here.  One mo
11:58:08 <quicksilver> conal: by the way your observation about the semantics of my Geometry2D type made me think harder
11:58:17 <CSWookie> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2825#a2825
11:58:23 <quicksilver> conal: I first realised my Monoid instance didn't make semantic sense.
11:58:37 <quicksilver> conal: then I realised that even my construction combinators didn't ;)
11:58:41 <conal> quicksilver: hurray!  thanks for letting me know.
11:58:45 <mauke> CSWookie: 'forall' is for types, not expressions
11:59:13 <conal> quicksilver: that's why, for me, defining the semantic domain is the single most illuminating design question.
11:59:14 <quicksilver> conal: The first is easy to fix, by lifting to endormorphism - functions from (sets of) coloured open sets to coloured open sets.
11:59:27 <quicksilver> conal: endormorphisms are always a well behaved monoid.
11:59:41 <quicksilver> conal: but that's not sufficient to save my constructors.
11:59:53 <conal> quicksilver: cool :)
12:00:15 <quicksilver> conal: the ability to write (stroke red 5 (blah)) - which effectively reinterprets blah to have 5 pixel wide stroke lines in red
12:00:20 <conal> CSWookie: ghci wants a value expression, not a type expression.
12:00:23 <quicksilver> conal: shows that I need more semantic structure.
12:00:31 <quicksilver> conal: I will keep pondering this in slow time :)
12:00:57 <BMeph_> CSWookie: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2825#a2826
12:01:12 <conal> quicksilver: cool.  glad i could help you question your answer.
12:01:52 <quicksilver> conal: you should get a T-shirt. "Conal : Helping over people question their answers since 19xx"
12:02:04 <CSWookie> BMeph_: So, what did you do that was different.
12:02:43 <mauke> CSWookie: what.
12:02:43 <conal> quicksilver: :D
12:03:00 <BMeph_> CSWookie: What I put in the paste is what I put in the interpreter.
12:03:32 <CSWookie> BMeph_: Right, but what does the hook business do?
12:04:04 <CSWookie> mauke: Hmm?
12:04:37 <rittyan1> hi all
12:05:37 <jedai> CSWookie: Nohing it's just there to show you how to use forall in the types
12:17:47 <dancor> @pl f (w, x, y, z) = F w x y z
12:17:47 <lambdabot> (line 1, column 16):
12:17:47 <lambdabot> unexpected "="
12:17:47 <lambdabot> expecting variable, "(", operator or end of input
12:20:03 <LeoD> @pl \(w, x, y, z) -> F w x y z
12:20:04 <lambdabot> (line 1, column 7):
12:20:04 <lambdabot> unexpected ","
12:20:04 <lambdabot> expecting letter or digit, operator or ")"
12:20:04 <lambdabot> ambiguous use of a non associative operator
12:20:14 <LeoD> ah
12:20:31 <dancor> pl only likes n-tuples for n = 2 doesn't it
12:22:42 <lilac> quicksilver: sounds like you're working with functions from some configuration space (line style, thinkness, brush pattern, etc) to coloured open sets?
12:26:15 <vixey> @pl \((w, x), (y, z)) -> F w x y z
12:26:16 <lambdabot> uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . F))
12:33:05 <fynn> could anyone remind me how to prevent the importation of certain functions from Prelude?
12:33:12 <jeffersonheard> I'm beginning to wonder if I could accidentally create Skynet by using too many combinators in one program
12:33:32 <jeffersonheard> The denisty of code without "do" is astounding
12:33:45 <ziman> `import Prelude hiding (foo, bar)' might work
12:33:50 * EmielRegis http://photos-d.ak.fbcdn.net/photos-ak-snc1/v2684/200/4/1269154409/n1269154409_30345851_1371214.jpg
12:36:30 <fynn> ziman: thanks, that seems to be it
12:38:44 <olsner> jeffersonheard: nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
12:39:36 <jeffersonheard> @remember olsner nah, SkyNet is just a zygohistomorphic prepromorphism, nothing fancy
12:39:36 <lambdabot> Nice!
12:40:11 <RayNbow> @quote skynet
12:40:11 <lambdabot> dons says: note down this date, people, 13-09-2006. today lambdabot == skynet
12:40:29 <RayNbow> so... lambdabot is nothing fancy either? :p
12:40:31 <vixey> hi grahamhutton
12:40:39 <grahamhutton> hi vixey!
12:40:49 <vixey> what's going on ?
12:41:13 <jeffersonheard> quick, someone disconnect hoogle so lambdabot/skynet can no longer introspect!
12:44:31 <RayNbow> wait... lambdabot doesn't make use of a recursion theorem to introspect itself?
12:46:33 <vixey> a recursion theorem ? what is it
12:48:17 <olsner> a theorem somehow related to recursion, methinks
12:48:20 <fynn> hey, I'm getting some weird errors on ghci:
12:48:22 <fynn> http://paste.pocoo.org/show/109422/
12:48:58 <mauke> fynn: that just means it doesn't know how to print functions
12:49:01 <mads-> Hi. I just installed Visual Haskell (a haskell plugin for Visual Studio). Does haskell have a system("PAUSE") (as C/C++ does)? Or can you recommend something better to use when doing haskell in windows?
12:49:17 <mauke> mads-: run your program from the command line
12:49:37 <bd_> :t getLine
12:49:38 <lambdabot> IO String
12:49:39 <mauke> or do it quick & dirty, add 'getLine' to the end
12:49:47 <fynn> mauke: OK, what should I do about it, if I want to do things like defining length in ghci?
12:49:48 <paper_cc> mads-: ghci =)
12:49:55 <mauke> fynn: huh?
12:50:12 <mads-> mauke: thanks :) I just hate using command line in windows...
12:50:15 <mauke> fynn: you need "let" to define things in ghci
12:50:26 <mads-> paper_cc: I need to run a file thru ghc
12:51:23 <paper_cc> fynn: you can't give type signatures like this in ghci. it thinks you want to print 'length' with type unified to [a] -> String, and says it cannot print a function
12:52:19 <paper_cc> mads-: then you can use the getLine computation as bd_ suggested, but in general GHCi may be a better tool to debug
12:54:56 <RayNbow> <vixey> a recursion theorem ? what is it <-- sorry for the late reply, but the recursion theorem more or less states that every program should be able to access its own source code
12:55:39 * jmcarthur wishes xmonad simply supplied a zipper you can simply add as many workspaces to as you want as you use it and just move through them sequentially
12:56:27 <jmcarthur> 9 workspaces i can jump to randomly is great. i just think infinite workspaces i can traverse would be nicer
12:56:42 <fynn> paper_cc: thanks a lot, that was exactly the problem.
12:57:12 <fynn> paper_cc: incidentally, how do I explicitly print the result of "length [1, 2, 3]"
12:57:40 <BMeph_> RayNbow: Does recursion theory also have some provision for access to a compiler? Because just having access to source code doesn't seem that impressive to me. :)
12:57:44 <paper_cc> fynn: type it and it'll be printed
12:57:58 <bd_> BMeph_: Without opening the source code as a file and reading it in :)
12:59:00 <fynn> paper_cc: I mean, explicitly (in a ghci independent way:)
12:59:24 <mauke> fynn: print (length [1,2,3])
12:59:24 <BMeph_> bd_: Is that a recursion theory proviso? I don't know - I'm sure I know even less about it than vixey does.
12:59:35 <paper_cc> fynn: putStrLn . show $ foobar will print foobar and \n
12:59:40 <jedai> print
12:59:46 <paper_cc> fynn: print foobar will print foobar and no \n
12:59:51 <mauke> paper_cc: wrong
12:59:58 <jedai> paper_cc: print print a "\n"
13:00:03 <paper_cc> @src print
13:00:03 <lambdabot> print x = putStrLn (show x)
13:00:07 <jedai> paper_cc: In fact
13:00:25 <fynn> mauke: cool, thanks
13:00:26 <jedai> ...ok
13:00:27 <paper_cc> mauke: you're right. thanks
13:00:28 <BMeph_> paper_cc: 'print me' == 'putStrLn (show me)'
13:00:29 <bd_> BMeph_: well, basically yes. It's what makes quines possible.
13:01:06 <bd_> BMeph_: The important thing to note is the recursion theory is abstract - there's no OS interaction, it just says you can encode a representation of the source code into itself, without ending up with infinite length
13:01:38 <fynn> mauke, paper_cc: hmmm http://codepad.org/HASDrHYD
13:02:12 <mauke> fynn: you can't just put random expressions in a file
13:02:22 <RayNbow> <bd_> BMeph_: well, basically yes. It's what makes quines possible. <-- and viruses :p
13:02:33 <mauke> fynn: you probably want something like 'main = print (length [1,2,3])'
13:02:39 * BMeph_ sneezes
13:02:55 <bd_> RayNbow: viruses can cheat and take advantage of the fact that they're on a von neumann architecture, though :)
13:03:16 <RayNbow> bd_: true :p
13:04:39 <paper_cc> fynn: yes, you want to define main :: IO (), there's no top-level functions in Haskell
13:05:23 <paper_cc> fynn: i.e. main = print $ length [1,2,3] or (equivalently) main = print (length [1,2,3])
13:07:24 <fynn> paper_cc, mauke: cool, finally working: http://codepad.org/leIG0Nmg
13:07:55 <fynn> thanks for the help, guys.
13:10:45 <paper_cc> fynn: no problem
13:10:57 <paper_cc> fynn: btw, no need for brackets after 'length'
13:12:13 <fynn> yeah... they were left there from an earlier iteration :)
13:12:55 <quicksilver> lilac: probably
13:13:11 <quicksilver> lilac: the hiearchy can change the parameters for subtrees
13:13:27 <quicksilver> lilac: but I don't think that invalidates your observation.
13:20:23 <eu-prleu-peupeu> check this out: http://www.stsc.hill.af.mil/CrossTalk/2008/01/0801DewarSchonberg.html
13:21:56 <skorpan> > (+) 5 6
13:21:57 <lambdabot>   11
13:22:04 <skorpan> > (*) ((+) 5) 6
13:22:05 <lambdabot>       No instance for (Num (t -> t))
13:22:05 <lambdabot>        arising from the literal `6' at <...
13:22:10 <skorpan> > (*) ((+) 5 6) 5
13:22:12 <lambdabot>   55
13:26:18 <RayNbow> > (+6) >>= (*) $ 5
13:26:19 <lambdabot>   55
13:26:45 <tromp> :t State
13:26:46 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:29:15 <Adamant> eu-prleu-peupeu: it seems mostly a extended complaint that nobody uses Ada
13:29:24 <Adamant> even for things where they should
13:30:07 <p_l|backup> Adamant: I considered it more of a cry to actually teach students what the fuck a computer is
13:30:23 * p_l|backup had today his most pathetic CS lecture ever
13:30:45 <chowmeined> what
13:30:48 <Adamant> p_l|backup: what happened?
13:30:52 <chowmeined> :(
13:31:16 <lament> what is a computer?
13:31:25 <Badger> did they teach you to printf? :P
13:31:27 <p_l|backup> Adamant: it was about "stepping out" outside of BlueJ...
13:31:27 <opqdonut> she's a woman
13:31:36 <Adamant> p_l|backup: ow.
13:31:37 <opqdonut> that does routine integrals etc ;)
13:31:43 <chowmeined> bluej is goofy
13:31:58 <RayNbow> lament: http://en.wikipedia.org/wiki/Human_computer :p
13:32:00 <monochrom> "what is computer" is like "what is monad"
13:32:18 <nominolo> @users
13:32:18 <lambdabot> Maximum users seen in #haskell: 658, currently: 630 (95.7%), active: 22 (3.5%)
13:32:20 <p_l|backup> not to mention the desperate measures taken to avoud showing that computer, in the end, executes a stream of instructions etc.
13:32:22 * Baughn sweatdrops
13:32:31 <p_l|backup> hi Baughn
13:32:40 <monochrom> Indeed, "a monad is about computation", and "a computer is about computation" too. :)
13:32:54 <Baughn> Monads aren't about computation, though
13:33:02 <vixey> I'm confused about vipassana..
13:33:06 <Baughn> Well, no more than anything on a computer is
13:33:17 <monochrom> I agree. It's sarcasm.
13:33:19 <p_l|backup> that letter that eu-prleu-peupeu linked speaks truth about how CS is taught nowadays
13:33:30 <Baughn> monochrom: Sorry, I've read too many monad tutorials to tell
13:33:39 <monochrom> My sentiment too. :)
13:34:24 <monochrom> "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
13:34:38 <p_l|backup> what the authors proposed in that was IIRC to teach students both from assembly and from HLL pov.
13:34:45 <vixey> haha
13:34:54 <lament> The universe is about a narrative.
13:35:01 <vixey> @remember monochrom "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
13:35:01 <lambdabot> Good to know.
13:35:06 <monochrom> yay!
13:35:21 <p_l|backup> good quote
13:35:30 <ehird> X is about X——Segfault
13:35:54 * p_l|backup just read today a post where one guy complained about Dell shipping bad keyboards in a laptop line and >50% of comments were "get a mac"
13:36:26 <monochrom> haha
13:36:28 * p_l|backup can't stand mac keyboards
13:37:01 * RayNbow can't stand touchpads
13:37:14 <p_l|backup> me too, but trackpoint is acceptable :)
13:37:15 * dancor can't believe we still use keyboards
13:37:23 <bremner> we had a discussion in class today that coined(?) the phrase "a mac user, but not an idiot"
13:37:29 * Baughn can't believe we still use mice
13:37:41 <RayNbow> p_l|backup: trackpoints/accupoints/<other names here> are awesome :)
13:37:44 <orbitz> i've moved on to morats
13:37:48 * monochrom can stand most things.
13:37:51 * lament can't believe we still use computers
13:38:01 * monochrom can't believe we still use brains
13:38:02 <p_l|backup> dancor: we still haven't created a better input device for computers, sadly
13:38:04 * vixey ... can't believe it's not butter
13:38:07 <lament> dancor: what can be better than a keyboard?
13:38:20 <p_l|backup> lament: direct link to brain
13:38:25 <Gracenotes> int *ptr = NULL; printf("S stands for "); fflush(stdout); *ptr = 0;
13:38:30 <Gracenotes> ^ learning the alphabet with C
13:38:33 <vixey> p_l|backup: that doesn't sound much better to me
13:38:36 <monochrom> eliminate human from the loop
13:38:36 <RayNbow> a secure wireless link to the brain
13:38:44 <p_l|backup> No, no wireless
13:38:45 * Baughn can't believe we still believe instead of computing bayesian updates
13:39:04 <maltem> Aren't there those input devices for disabled people that are direct links to the brain, more or less?
13:39:13 * mstr can't believe that macs get people so emotional. they are computers ffs :)
13:39:16 <Baughn> maltem: Yeah, but they kinda.. suck
13:39:18 <p_l|backup> maltem: they are very limited
13:39:34 <maltem> Baughn: I would have guessed so, given you cannot buy them at the local store
13:39:35 <monochrom> Hawking is still not using direct link.
13:39:37 <Baughn> As I said.
13:39:50 <dancor> we can't risk putting hawking under the blade
13:39:57 <monochrom> haha
13:40:05 <Baughn> Can we risk not doing so?
13:40:07 <RayNbow> mstr: within a few years, there will be legislation allowing people to marry with Macs :p
13:40:12 <Baughn> Cyborg Hawking might save the world
13:40:18 <RayNbow> -with
13:40:23 <monochrom> Well his micro-sensing things are working fine now.
13:40:27 <dancor> we could be hawking our futures
13:40:46 <p_l|backup> RayNbow: I think I prefer people marrying fictional characters than people marrying Macs
13:41:34 <monochrom> Don't marry the big Mac. Food are supposed to be eaten, not married.
13:41:49 <dancor> allow the flavors to marry
13:41:53 <lament> first marry, then eat
13:42:02 <monochrom> hehehehe OK!
13:42:16 * monochrom goes woo some tea and cookie.
13:42:47 <maltem> The existence of time zones continues to amaze me.
13:43:34 <dancor> move to china?  anyway daylight savings is the real kicker..
13:43:57 <RayNbow> ah... DST...
13:44:07 <p_l|backup> maltem: what's wrong with timezones (except DST)?
13:44:09 <jeffwheeler> If everybody just moved to my time-zone, then the whole system would be way easier. We'd all use the same times, and it would still be the same time of day!
13:44:27 <dancor> you can certainly think in UTC if you want
13:44:29 <lament> jeffwheeler: ok i'm moving in!
13:44:29 <dancor> start a movement
13:44:39 <RayNbow> DST has its uses though :p
13:44:44 <jeffwheeler> lament: I'm in Central, and staying here. No DST. :)
13:45:00 <lament> can i stay on the couch?
13:45:15 <jeffwheeler> lament: if you're willing to come to my dorm room in August, too.
13:45:34 <Gracenotes> or if there were no time zimes; midnight in UTC was midnight in UTC, and everyone in New York work up to go to work at 12 PM
13:45:40 <maltem> p_l|backup: Actually, I meant the setup of the earth, making me read about tea and cookies
13:45:47 <Gracenotes> *would wake up
13:45:51 <jeffwheeler> Gracenotes: that's why we all move into the same time zone. :)
13:46:18 * RayNbow currently lives in the CET timezone...
13:46:26 <RayNbow> but next Sunday it will change to CEST :p
13:46:28 * p_l|backup was simply taught to use two separate times, *Local* and *UTC*
13:47:16 <Gracenotes> RayNbow: oh, so you'll be inCEST soon
13:48:44 <Gracenotes> wha.
13:49:01 <RayNbow> Gracenotes: no comment... don't want any police at my door! :p
13:49:56 <p_l|backup> *DONK*
13:51:42 <RayNbow> hmm
13:52:12 <RayNbow> Gracenotes: it seems that some forms of incest are not illegal in the Netherlands
13:52:43 <p_l|backup> usually cousins are fair game
13:52:57 <FunctorSalad> I'm new with the FFI... what could this really mean? (.text+0x1851): undefined reference to `ftglGetLayoutBBox'
13:53:18 <FunctorSalad> (that function clearly exists in the C source, and other functions do work)
13:53:35 <RayNbow> p_l|backup: sister-brother might be allowed too... but I'm not sure... (legal texts are hard to read)
13:53:38 <Gracenotes> RayNbow: I don't think (identical) twincest should be illegal, no?
13:53:59 <FunctorSalad> hehe
13:54:12 <Gracenotes> it makes for 'good' fanfics anyway
13:54:16 <jedai> RayNbow: The question then becomes : is that really incest ? After all I don't think there is any precise definition so shouldn't local legal text makes authority ?
13:54:16 <___> well this is certainly an interesting conversation to walk into.
13:54:31 <___> in #haskell no less
13:54:54 <Gracenotes> sorry, it led from talking about timezones
13:54:55 <p_l|backup> RayNbow: it's usually illegal, as "first-degree" relation, just as "second-degree", like niece-aunt/uncle
13:54:57 <jedai> I think any further comments should move into blah though...
13:55:13 <Gracenotes> anyway, the main motivation behind any such laws should be genetic in nature. (and of course abuse is bad)
13:56:01 <jedai> Most such law to my knowledge forbid relation between person separated by two degree of relation or less
13:56:22 <p_l|backup> Gracenotes: that's why in many places it's defined by relation, with first cousins generally being accepted, although sometimes requiring a court approval
13:56:28 <lament> Gracenotes: genetic motivation can also be used for any arbitrary eugenics program.
13:56:35 <Gracenotes> in other news, here is a pretty Sierpinski triangle generator: putStrLn.unlines.(!!3).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
13:56:39 <lament> For example, forbidding interracial marriage for genetic reasons.
13:56:40 <jedai> As p_l said that means cousins are fair play
13:56:51 <Gracenotes> lament: I mean inbreeding
13:57:13 * p_l|backup wonders if that knowledge about cousin marriage is going to shake someone just as much as him :P
13:57:33 <Debugger> Interracial marriages are cool imo..
13:57:38 <lament> Gracenotes: if we forbid incest because there's a chance of genetic disorders, we should certainly forbid anyone with manifest genetic disorders from having children
13:57:45 <FunctorSalad> p_l|backup: IIRC I read in wikipedia that it used to be pretty common
13:58:33 <p_l|backup> lament: IMHO the best option would be mandatory genetic check of any child and correctional procedure in earliest stages
13:58:54 <jedai> Gracenotes: inbreeding effects have been greatly exagerated in recent times, most scare exemple came from intensive inbreeding on generations
13:58:56 <lament> p_l|backup: meaning abortion? How else do you "correct" genetic disorders?
13:58:57 <Gracenotes> lament: right. I'm just saying that if the laws need to have a jusification, that should be it. And the genetic disorder thing is tricky: it would be best to discourage those people, but what can you do, really. Otherwise I'm ambivalent.
13:59:23 <lament> Gracenotes: you can certainly forbid them from having children
13:59:30 <goomba`> +
13:59:33 <jedai> lament: genetic therapy (meaning no real solution for now)
13:59:35 <p_l|backup> lament: no abortion, I mean to *create* technology capable of simulating and then "patching" the genes
13:59:40 <RayNbow> "Wetboek van Strafrecht" (criminal law, NL), article 249... is only about parent-child, parent-foster child, etc. and things like teacher-student, doctor-patient...
13:59:41 <lament> ah.
13:59:45 <FunctorSalad> forming babbies...
13:59:55 <Gracenotes> p_l|backup: like bone marrow, you mean?
14:00:08 <p_l|backup> Gracenotes: well, more advanced, but kind of like that
14:00:12 <lament> p_l|backup: and then make sure every child is tall, smart, physically able, and Aryan.
14:00:18 <clanehin> I wonder if there is a library that implements regular expressions for arbitrary types with arbitrary predicates.  e.g., I instead of matching 'abbb' I want to match a list with one Left {} and three Right {}'s.
14:00:33 <p_l|backup> lament: no, not Aryan... but smart and physically able? sure
14:00:34 <lament> p_l|backup: I'm sure you see the potential for abuse.
14:00:43 <FunctorSalad> lament: uhm not to take sides here but the "aryan" doesn't really follow
14:00:43 <Gracenotes> clanehin: what's the difference between a left {} and a right {}?
14:00:45 <jedai> lament: Or has solar wings and can live in void too ^^
14:00:59 <lament> FunctorSalad: it does, from "mandatory"
14:01:02 <clanehin> Gracenotes: typed as Either
14:01:18 <mauke> Gracenotes: learn about Either
14:01:21 <Gracenotes> clanehin: and what do you mean by {}?
14:01:25 <p_l|backup> lament: Yes, I see the potential. I wouldn't mind certain kinds of mandatory patching...
14:01:32 <mauke> record syntax pattern matching
14:01:32 <clanehin> Gracenotes: that's haskell pattern matching syntax
14:01:32 <Gracenotes> mauke: I know about it. I assumed he meant matching parens
14:01:36 <vixey> @seen jkff
14:01:37 <lambdabot> I haven't seen jkff.
14:01:41 <vixey> where is this guy got to ..
14:01:43 <jedai> clanehin: Yes, it's called view patterns, it's an extension in 6.10
14:01:52 <mauke> wtf
14:01:53 <yitz> @quote conal  recursion
14:01:54 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:02:01 <vixey> @quote recursion
14:02:01 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
14:02:04 <dancor>  @quote conal
14:02:06 <yitz> @remember conal Recursion is the goto of functional programming
14:02:07 <lambdabot> Good to know.
14:02:21 <clanehin> jedai: not quite, I want to match regular expressions in this way
14:02:21 <Debugger> ?
14:02:29 <Gracenotes> what the hell.
14:02:29 <yitz> @quote conal
14:02:30 <Debugger> yitz: What do you mean?
14:02:30 <lambdabot> conal says: Recursion is the goto of functional programming
14:02:47 <yitz> Debugger: you mean what does conal mean?
14:02:59 <jedai> clanehin: Well view pattern allows you to do things like that
14:03:03 <Debugger> goto is shit in imperative languages...
14:03:06 <yitz> (quoted from his cafe post a few minutes ago)
14:03:07 <dancor> you shouldn't have to write-out recursions
14:03:17 <Debugger> Recursion is a necessity in functional language
14:03:18 <dancor> and if you do so you are being very low-level
14:03:27 <vixey> yeah I don't get that quote at all!
14:03:31 <jedai> clanehin: I'm not sure I understand your need exactly, could you give an exemple ?
14:03:37 <Gracenotes> clanehin: you'll have to explain better. What's the input and expected output?
14:03:49 <Gracenotes> sry :\
14:03:51 <dancor> i.e. use folds instead of writing out recursions etc
14:03:51 <yitz> Debugger: goto is a necessity in imperative languages - but they are hidden in higher-level constructs like foreach
14:04:00 <mauke> regular expressions on data structures, not strings
14:04:11 <clanehin> The input would be a list of some arbitrary data type, and a regular expression containing predicates on that data type
14:04:12 <Debugger> yitz: A weird way to see it imo
14:04:15 <clanehin> mauke: exactly
14:04:17 <lament> yitz: what? goto is hidden in higher-level constructs like recursion in the same way that it's hidden in foreach.
14:04:18 <vixey> yitz: that's not conceptually, a goto
14:04:31 <Gracenotes> clanehin: so it would be a list of functions, like isLeft and isRight
14:04:41 <yitz> vixey: it gets compiled to gotos
14:04:52 <clanehin> Gracenotes: yes, with some kind of annotation for how they would be built into a regular expression
14:04:58 <FunctorSalad> isn't it an old joke that goto is called callCC now? ;)
14:05:04 <vixey> don't know what compilation has to do with conceptualization
14:05:06 <RayNbow> jnz, js, jmp, and friends <3
14:05:07 <yitz> just like higher-level functional code gets translated to recursion in the libraries
14:05:07 <Gracenotes> clanehin: also, you can do very little with an arbitrary data type
14:05:30 <p_l|backup> FunctorSalad: I had seen callCC implemented with function call
14:05:46 <lament> @src forM
14:05:46 <lambdabot> forM = flip mapM
14:05:51 <lament> do you see goto anywhere?
14:06:10 <yitz> lament: nope
14:06:22 <lament> me neither, yet forM is foreach
14:06:32 <FunctorSalad> p_l|backup: how else would it be implemented? I think the idea is that it leads to similarly complex control flow, not that it is implemented with goto :)
14:06:46 <dancor> more like #hasktroll lately
14:07:12 <yitz> vixey: there are certain rare cases where raw recursion is the simplest and clearest way to express something, but usually it's contrived
14:07:37 <conal> btw, i got that "goto" quote from Erik Meijer.  wasn't sure where it originated.
14:07:38 <Gracenotes> clanehin: I don't think it could be called a regular expression in that case. If you made it into an NFA (for instance), you're saying that you'd want the transitions to be predicates other than equality tests? There's nothing you can do *in general* for it, only specific cases, except maybe Template Haskell or some complicated metalanguage construct, which I don't know too much about.
14:07:46 <yitz> dancor: what's your favourite colour?
14:07:49 <p_l|backup> FunctorSalad: normally TCO and similar get implemented with goto in many places, but Chicken makes every statement a continuation that is compiled into calling a subroutine with an ever-growing stack
14:08:00 <dancor> yitz: ourange
14:08:13 <yitz> dancor: red. no - blue!
14:08:18 <dancor> aka international orange
14:08:25 <yitz> oops, that's for #python
14:08:33 <clanehin> Gracenotes: I suppose there could be a mapping function onto some type that does support equality tests
14:08:56 <jedai> clanehin: There has been some research into "regular patterns" though never integrated in a language that has seen much use
14:09:08 * dancor metatrolling
14:09:12 <vixey> jedai: Well it got added to haskell at one point
14:09:18 <jedai> clanehin: globally it hasn't proved too useful
14:09:21 <FunctorSalad> who is trolling?
14:09:33 <vixey> jedai: And there's that language which is based on it to.. (can't remember the name)
14:09:39 <jedai> vixey: Yes I know, but it never stuck and it isn't in GHC actually
14:09:40 <Gracenotes> dancor trolls with header starts
14:09:50 <vixey> you know.. ok
14:10:11 <Gracenotes> ^AACTION trolling lol^A
14:10:27 <clanehin> jedai: cool, at least I have something to google, thanks
14:10:53 <jedai> vixey: I mean that the concept never seemed so useful that there was an uproar by forward thinking programmers to have it integrated into their favorite language
14:11:23 <yitz> @quote recursion
14:11:24 <lambdabot> blackdog says:  <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
14:11:24 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
14:11:24 <lambdabot> still
14:11:40 <jedai> vixey: I know of at least a derivation of ML, one for Haskell, even a variant for Java I think with this kind of capability
14:12:07 <Gracenotes> jedai: ahm. How do you represent such patterns in syntax?
14:13:07 <jedai> Gracenotes: That looks a lot like regular expressions but with constructors instead of characters, it depended on the variant, you would have to look into them to know more
14:13:24 <Gracenotes> as strings?
14:13:47 <Gracenotes> it seems like it could be done in Parsec with a GenParser of whatever datatype was wanted
14:13:54 <FunctorSalad> Gracenotes: wait. isn't it rather impossible for identical twincest to result in children anyway?
14:14:03 <Gracenotes> in Haskell, at least. (if that helps, clanehin)
14:14:06 <FunctorSalad> (replying to some minutes ago)
14:14:13 <Gracenotes> FunctorSalad: yes, that's the point :)
14:14:20 <yitz> FunctorSalad: took you a while to figure that out?
14:14:52 <jedai> Gracenotes: Not as strings, it was a specific syntax IIRC
14:14:53 <FunctorSalad> yitz: yes. I thought the point was that since they're identical, the probabilty of disease won't be higher for the children
14:14:59 <FunctorSalad> seriously.
14:15:14 <FunctorSalad> :)
14:15:24 <yitz> FunctorSalad: you could cross clone them if they're females
14:15:26 <Gracenotes> clanehin: Parsec is more powerful than regular expressions, and although it's mainly used for parsing lists of characters, the internal mechanism allows it to be used for parsing lists of anything
14:15:31 <FunctorSalad> yitz: yep
14:15:34 <jedai> Gracenotes: Parsec could have difficulty exploring orthogonal dimension though (depth)
14:15:37 <Gracenotes> plus, if written in an applicative style it's very clean and concise
14:15:42 <skorpan> is there any way to use infix notation but for three arguments?  say that want "x `hello` y z" to mean "hello x y z"?
14:15:43 <p_l|backup> FunctorSalad: They are working on female-female birth ;-)
14:15:51 <clanehin> Gracenotes: thanks, that's also helpful
14:15:53 <skorpan> @hoogle a -> a -> a
14:15:53 <lambdabot> Prelude asTypeOf :: a -> a -> a
14:15:53 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
14:15:53 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
14:15:56 <skorpan> @hoogle a -> a -> a -> a
14:15:56 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
14:15:56 <lambdabot> Language.Haskell.TH.Syntax CondE :: Exp -> Exp -> Exp -> Exp
14:15:56 <lambdabot> Language.Haskell.Syntax HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
14:15:59 <Gracenotes> EEEEEK
14:16:02 <clanehin> http://www.cs.chalmers.se/~d00nibro/harp/index.html
14:16:02 <Heffalump> in any case, the genetic combination *would* be dangerous
14:16:04 <Gracenotes> jedai: hm? It can be used for context-free, recursve stuff.
14:16:07 <___> (x ! y) z
14:16:21 <Heffalump> because for each gene, there'd be a 50% chance of it crossing with exactly the same gene
14:16:27 <skorpan> ___: i suppose that x ! y z would mean the same thing as long as ! has higher precedence, right?
14:16:37 <Sargun> <- is for doing I/O assignments, correct? Why don't we justuse =?
14:16:43 <___> function application has the highest fixity
14:16:52 <skorpan> ___: ah, true
14:17:05 <jedai> Gracenotes: You need to parse trees, not only streams, though Parsec can probably do it... Well it's worth a try anyway
14:17:07 <mauke> Sargun: no, it's for locally "extracting" stuff
14:17:19 <FunctorSalad> Heffalump: hmm true so the child won't be a clone after all?
14:17:19 <Sargun> mauke, extracting? How so?
14:17:29 <yitz> ___: how do you pronounce your name?
14:17:41 <___> anyway you like :)
14:17:47 * FunctorSalad feels dumb
14:17:51 <mauke> Sargun: well, looking at the types, if the RHS has type 'm a' then the LHS has type 'a'
14:17:52 <Gracenotes> jedai: oh, I see. Well, you can make parsers for items using combinators or parsers for subitems
14:17:55 <Gracenotes> *of
14:18:07 <Sargun> Man, Haskell is so odd...
14:18:09 <Gracenotes> <__> IS NOT HUMAN
14:18:15 <mauke> in 'x <- getLine', x :: String and getLine :: IO String
14:18:30 <jedai> Sargun: <- is not an assignment, no ! To better understand what's going on, you should try to look at the translation of the do-syntaxic sugar
14:18:30 <Heffalump> FunctorSalad: correct. Unless you clone it, obviously.
14:18:36 <jeffwheeler> Heh, what's with all these "Jeff isn't a citizen" posts on the mailing list? ;)
14:18:50 <jeffwheeler> I'm in here or #yi pretty much every day. :P
14:18:52 * Sargun is used to Python, Erlang, and C. Haskell is like whoa..
14:18:59 <yitz> jeffwheeler: sore loosers
14:19:08 <yitz> losers
14:19:11 <Heffalump> reddit is being pretty rude about the logo
14:19:15 <Gracenotes> > let a = listArray (0,100) (repeat id) in (a ! 10) 40
14:19:15 <mauke> Sargun: the whole IO system is callback based
14:19:16 <lambdabot>   40
14:19:23 <Gracenotes> > let a = listArray (0,100) (repeat id) in a ! 10 40
14:19:24 <lambdabot>       Overlapping instances for Show (a -> a)
14:19:24 <lambdabot>        arising from a use of `s...
14:19:30 <Sargun> mauke, you mean under the hood?
14:19:31 <___> @undo do {x <- expr}
14:19:31 <lambdabot>  Parse error at "}" (column 14)
14:19:33 <Gracenotes> function application binds closer than symbols
14:19:49 <Gracenotes> __, 'fraid that's not a valid do block :(
14:19:52 <mauke> Sargun: the 'x' in 'x <- foo' is actually a callback parameter
14:19:54 <jedai> Sargun: Yes, Haskell is very surprising to almost all programmers, but that's why it's interesting to learn, no other language can open such new horizons in a programmer skill IMHO
14:19:55 * conal is enjoying the "too smart" haskell-cafe thread.
14:20:01 <___> @undo do {x <- expr; expr2}
14:20:01 <lambdabot> expr >>= \ x -> expr2
14:20:06 <mauke> Sargun: everything after '<-' is the callback body
14:20:14 * ___ has not done any haskell in a great long while
14:20:51 <Gracenotes> in do {x <- expr; expr2}, the x and expr2 are bound together, whereas the expr was before you even got to them
14:21:28 <Sargun> jedai, I've heard great things about it.
14:21:50 <___> (\x -> expr2) is a function that is bound (>>=) to the result of expr
14:22:17 <conal> ___: great handle!
14:22:25 <vixey> Gracenotes: yeah which is immensly confusing when you compare it with the  let  binding rules
14:22:32 <yitz> conal: me too :)
14:22:53 <gerard_> ___: whoops, parse error in my brain trying to process your name
14:23:11 <Gracenotes> vixey: yeah. Although you can think of it as.. let (YourMonad x) = expr
14:23:15 <___> geez
14:23:35 <Gracenotes> __ IS NOT HUMAN. WELCOME BROTHER BORINGOLDNICK
14:23:57 <__> yeah
14:24:05 * yitz is getting really confused
14:24:55 * mauke is now known as λ
14:25:15 * boringoldnick bows before the lambda
14:25:25 <Gracenotes> mauke has now gotten a nick-change error
14:27:59 <boringoldnick> @yow!
14:27:59 <lambdabot> My mind is making ashtrays in Dayton ...
14:30:33 <mle> [_] would be legal
14:32:59 <sbahra> @vixen hi honey
14:33:00 <lambdabot> how're you?
14:33:10 <sbahra> @vixen not bad, and you?
14:33:10 <lambdabot> just not bad?
14:37:59 <FunctorSalad> is there a FFI common pitfalls/troubleshooting manual somewhere?
14:40:06 <gerard_> using Data.ByteString my diff program is only 10x slower than the official one
14:40:27 <pao> FunctorSalad: I've found lots of useful info in rwh chapter and http://www.haskell.org/haskellwiki/FFI (expecially the cook book)
14:40:52 <FunctorSalad> pao: thanks I'll look :)
14:41:17 <pao> FunctorSalad: you're welcome
14:41:24 <pao> :-)
14:41:25 <blackh> @tell lepassive http://blacksapphire.com/haskell/adventure3.hs I "finished" the adventure game.  It is a little rough - I am not trying to make it perfect. Tell me if you think this is useful for you for learning Haskell, and I might publish it with some notes. I am not doing any comparison with OO but it might be interesting to write the same program in an OO style.
14:41:25 <lambdabot> Consider it noted.
14:42:11 <blackh> If anyone else has any comments on the usefulness of the above program for teaching Haskell, say on.
14:43:16 <blackh> The thinking here is that there's a bit of a shortage of "thinking in Haskell"-type educational resources on the wiki, and I thought this might fill the gap a little.
14:49:52 <Gracenotes> blackh: can you do anything with the tree? :3
14:50:38 <blackh> Gracenotes: The first tree doesn't exist as an item but you could add it with no description.  Then you could climb it if you wanted.
14:52:16 <yitz> blackh: it's a nice example. as a teaching tool it obviously would need context and however much narrative is needed in the context
14:52:25 <Cale> blackh: globalCommands might look  better as a case
14:52:33 <yitz> blackh: get rid of the error calls though
14:52:39 <Gracenotes> blackh: ah... I can't do anything anymore :3 very nice so far :)
14:52:53 <boringoldnick> createWorld reads very nicely
14:52:58 <Gracenotes> although there are a few undocumented commands
14:53:42 <skorpan> i have a long expression in a deeply nested program.  is it possible to get GHC to show me the type it infers on it?
14:53:50 * conal has a hard time not reading "commands" as "comonads"
14:53:57 <Cale> hehe
14:54:04 <boringoldnick> skorpan: you could force a type error with (expr :: ())
14:54:12 <skorpan> well, i have somethingsomething <*> undefined, and i'd like to see which type the expression i replace "undefined" with should have
14:54:15 <boringoldnick> presuming of course that that's not it's actual type :)
14:54:22 <blackh> When I first started Haskell I couldn't get my head around the question "How do you manage complex state?" so that's why I tried writing an adventure game.  This is how I would do it now, 8 months later.  Thanks for your feedback, all.
14:54:26 <Gracenotes> skorpan: if you can make an explicit param
14:54:26 <vixey> you can ask
14:55:10 <vixey> :t \x -> head (() (reverse . map (+1) $ x))
14:55:11 <lambdabot>     Couldn't match expected type `[a1] -> [a]'
14:55:12 <lambdabot>            against inferred type `()'
14:55:12 <lambdabot>     In the first argument of `head', namely
14:55:13 <vixey> like that
14:55:24 <vixey> sometimes it says what you acutally wanted to know
14:55:25 <skorpan> thanks that worked
14:55:32 <Gracenotes> cute trick
14:55:52 <Gracenotes> whoa, the too smart mailing list discussion is really going fast
14:56:09 <vixey> another trick is:
14:56:14 <vixey> f = ... (g x) ...
14:56:18 <vixey> g = undefined f
14:56:32 <vixey> now g has any type, but f is in a SCC with g
14:56:47 <vixey> I learned this trick when I implement a type checker :p
14:56:48 <Gracenotes> the State solution is nice and elegant.. rarely is the State constructor explicitly used
14:57:01 <Gracenotes> afaik
14:57:10 <vixey> anyway this gives me a nice idea, I think
14:57:10 <yitz> Gracenotes: no it's a common trick for those one-liners
14:57:26 <vixey> you know this lisp paste that hilights parens?
14:57:38 <vixey> could there be something similar for haskell but it shows types
14:57:53 <vixey> I am not sure if the way code is written you could point in the same way though..
14:57:53 <Gracenotes> yitz: yeah, I make evalState tricks every so often, but with short do blocks that work just fine
14:58:18 <vixey> how do you _point_ at a bracket of haskell code?
14:58:51 <dancor> vixey: one possibility is for it to reparse the code to insert the optional bracketing?
14:59:47 <dancor> iirc most haskell parsers kill whitespace tho which you might want to try to preserve
14:59:47 <yitz> Gracenotes: that's why I there was a built-in polymorphic constructor: mkState :: MonadState s m => (s -> (a, s)) -> m a
14:59:54 <yitz> why I wish
15:00:13 <Gracenotes> hm. Well, that wouldn't work for all MonadState, I don't think
15:00:16 <vixey> yitz: but it's impossible to implement ?
15:00:28 <RayNbow> @seen roconnor
15:00:29 <lambdabot> roconnor is in #haskell. I don't know when roconnor last spoke.
15:00:33 <yitz> vixey: well I guess it would need to be a class method
15:00:48 <Gracenotes> you mean like arr? :)
15:01:03 <vixey> aha
15:01:03 <Gracenotes> something that, it seems, ends up limiting at times
15:01:36 <yitz> Gracenotes: hmm general arrows would be a little too much
15:01:54 <pumpkin> @type arr matey
15:01:55 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
15:01:57 <Gracenotes> yes, a but seem like a nice abstraction anyway
15:02:03 <yitz> Gracenotes: I just don't want to be forced to choose between State and StateT in a library.
15:02:13 <Gracenotes> @type arr id
15:02:14 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
15:02:25 <pumpkin> ARR
15:02:29 <yitz> @arr
15:02:29 <lambdabot> Aye Aye Cap'n
15:02:44 <seliopou> have type families gained wide use yet?
15:02:50 <seliopou> or... use?
15:03:07 <vixey> seliopou: I used them once in an academic example
15:03:17 <yitz> seliopou: there's already a TF alternative to the fundeps in mtl
15:03:28 <yitz> on hackage
15:03:39 <seliopou> how many hackage packages would you say use them
15:03:45 <seliopou> percentage, let's say
15:04:22 <ddarius> :t \f -> do s <- get; let { (a,s') = f s }; put s'; return a
15:04:24 <lambdabot> forall (t :: * -> *) t1 t2. (MonadState t1 t) => (t1 -> (t2, t1)) -> t t2
15:04:37 <seliopou> yitz: what's it called?
15:05:02 <yitz> seliopou: well, very small, but more fair to compare it to things it replaces like fundeps than to all of hackage
15:05:44 <yitz> mtl-tf
15:05:46 <seliopou> I'm trying to get an idea of how many haskell users are familiar with it
15:05:54 <yitz> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl-tf
15:05:59 <seliopou> thx
15:08:04 <Gracenotes> @src State return
15:08:04 <lambdabot> Source not found. I am sorry.
15:08:44 <Gracenotes> State $ \s -> (a, s), me thoughts. :X
15:11:39 <facedownL> @src
15:11:39 <lambdabot> src <id>. Display the implementation of a standard function
15:11:57 <yitz> hmm, there's also monad-tf. same author as mtl-tf, seems more up-to-date
15:12:07 <yitz> seliopou ^
15:12:10 <Gracenotes> , src State return
15:12:11 <lunabot>  luna: Not in scope: data constructor `State'
15:12:23 <Gracenotes> , src State'' return
15:12:24 <lunabot>  luna: Not in scope: data constructor `State'''
15:12:29 <Gracenotes> :oX
15:13:41 <yitz> @type State . (,)
15:13:42 <lambdabot> forall s a. a -> State s a
15:13:49 <Port2has> hi
15:14:05 <yitz> so return = State . (,)
15:14:13 <yitz> hi Port2has
15:14:14 <Port2has> can somebody answer stupid question
15:14:41 <Port2has> how to specify explicetly type for value
15:14:54 <Zao> > 42.0 :: Double
15:14:55 <lambdabot>   42.0
15:16:12 <yitz> Port2has: so you just write :: <type>. but often you need to put the whole thing in parens, like (42 :: Double)
15:16:20 <Gracenotes> yitz: ah. I learned about State before pointless, largely. /me gets used to that then
15:17:01 <yitz> @pl return
15:17:01 <lambdabot> return
15:17:32 <Port2has> Thanks
15:17:58 <Gracenotes> the function instances for Monad and Applicative make pointless code too easy, almost :)
15:17:59 <Port2has> I wonder why i find it in the Internet so long :)
15:18:00 <yitz> @pl \x -> State $ \s -> (x, s)
15:18:01 <lambdabot> State . (,)
15:18:23 <yitz> Port2has: this channel is the best place on the Internet
15:18:27 <Gracenotes> *too easy to abuse, not to mention
15:18:45 <monochrom> pointfree is easier than people make it out.
15:19:17 <yitz> I agree with Gracenotes.
15:19:40 <monochrom> A postmodern slogan for pointfree can be "focus on the operations, not the operands".
15:19:41 <Port2has> agree, next time i will go straight here
15:20:34 <Gracenotes> I can't say (f .) . g, (. f) . g, and the like are instantly readable without using them a while, either
15:20:35 <yitz> monochrom: no, it's "((focus .) .)"
15:20:44 <monochrom> hahahaha you win
15:20:56 <beelsebob> my conclusion: Haskell is *deffinately* more readable than C
15:21:07 <beelsebob> though not easily so
15:21:11 <wli> The operations are the operands.
15:21:43 <monochrom> Oh most everything requires practice. Only the nipples are intuitive.
15:21:50 <beelsebob> just been given a buggy algorithm written in both C and Haskell to debug... none of it my code... Referential transparency goes a long way when trying to think about these things
15:21:55 <wli> (.) . (.)
15:22:07 <yitz> beelsebob: so does the type checker
15:22:23 <beelsebob> yeh, though both sets of code compiled and did the same thing
15:22:35 <beelsebob> the bug was in the algorithm, not the implementation therof
15:23:42 <monochrom> You know how elementary tools don't scale up and you need advanced tools to scale up. Pointful vs pointfree is one of those instances.
15:24:21 <vixey> so...
15:24:28 <vixey> I want a book or something like a pdf I don't know
15:24:59 <vixey> but is there anything which does 1) functional parsing 2) correctness proofs a robot could understand
15:25:49 <monochrom> Do you need the book to show a correctness proof of one example of funtional parsing?
15:26:13 <vixey> I need something to teach me how to prove correctness of parsing algorithms
15:26:19 <monochrom> Because so far there is none.
15:26:25 <thomashartman1> What controls if a cabal package installs as a library (i.e., which shows up when you do ghc-pkg list ?)
15:26:30 <vixey> that explains why I couldn't find it!
15:26:42 <yitz> vixey: write it
15:26:52 <vixey> yitz: yes I would love to be able to write such a book
15:27:03 <thomashartman1> I am trying to modify gitit to be library based, so it can be used as a plugin in other apps, like patch-tag for a start, but later who knows, hackage, or any happstack app that needs a cms.
15:27:22 <mle> vixey: well what parsing things have you looked at so far?
15:27:34 <monochrom> If you decouple (1) from (2), Richard Bird's "Introduction to Functional Programming using Haskell", 2ed.  Has monad transformers too.  Has stack overflow of foldl and how to fix it with foldl' too.
15:27:39 <thomashartman1> cabal install gitit installs an executable but not a lib as far as I can see.
15:28:27 <monochrom> Can you imagine that? A book written before there was the Haskell Wiki, and it already explained foldl stack overflow and foldl'.
15:28:54 <mle> and... what sort of correctness?  as terrible as that question sounds
15:29:25 <yitz> monochrom: that was in the days when foldl' seemed clever, rather than foldl a mistake
15:29:32 <thomashartman1> fwiw, cabal file is http://github.com/jgm/gitit/blob/a49b6ca9b7cec0cd08ca9020b8559584be3b68e5/gitit.cabal
15:29:43 <dons> mm. zipWithM_ ($)
15:29:51 <dons> using haskell at work is fun.
15:30:21 <bvck> Haskell syntax question: Could someone please help me read the '=' in data Maybe a = Nothing | Just a?
15:30:22 <vixey> mle: Total correctness!
15:30:23 <Axman6> hey dons
15:30:29 <vixey> bvck: equals
15:30:35 <bvck> Does it really?
15:30:40 <Axman6> yep
15:30:55 <thomashartman1> bvck: values of type Maybe a can be constructed one of two ways.
15:31:02 <thomashartman1> Nothing or Just a
15:31:02 <bvck> Even though on the left is 'type constructor' and on the right 'data constructor'?
15:31:03 <thomashartman1> that's it
15:31:25 <vixey> monochrom: Richard Birds book explains parsing, but no proofs ?
15:31:27 <Axman6> bvck: could read it as 'is made up of' i guess
15:31:39 <monochrom> He proves something else.
15:31:54 <yitz> bvck: ok, how about "is constructed by"
15:32:03 <vixey> monochrom: my problem (which is tremendously distressing) is that I could actually write the program -- I just cannot explain what it does formall
15:32:05 <monochrom> He proves e.g. fusion laws etc.
15:32:05 <vixey> formally
15:32:20 <Axman6> dons: i know it's been asked before, but is there any chance those galois tech talks could be recorded? seems like there's a lot of good stuff going on, that no one really gets to see :( (if they already are... then i'd love to know where ;)
15:32:26 <bvck> yitz, axman6, thanks. The '=' keeps making me think of 'equality'...:)
15:32:42 <dons> we don't have video equipment, nor video experts. if we did have an expert, probably we'd record them.
15:32:51 <yitz> bvck: in haskell == is equality, = is declaration
15:32:53 <thomashartman1> bvck: yeah. it's not equality ;)
15:33:01 <monochrom> Come over to take my course for how to write specifications formally.
15:33:05 <thomashartman1> bvc: = isn't equality in most programming languages
15:33:08 <thomashartman1> usually equality is ==
15:33:09 <yitz> though we read it as "equals"
15:33:20 <thomashartman1> = is more like "assignment" in languages like ec, perl java etc
15:33:28 <yitz> horrors
15:33:44 <jeffwheeler> Which is rather odd . . . I wonder why that got started.
15:33:59 <jeffwheeler> (And why Haskell followed suit.)
15:34:16 <monochrom> Specifying the parsing job is rather advanced.
15:34:23 <yitz> started with C I think.
15:35:22 <vixey> monochrom: I would really to do that actually
15:35:37 <jmelesky> dons: the pdx python group is putting together the stuff needed for webcasting. if the idea is easily portable, i'd happily give you a runthrough for galois tech talks
15:35:41 <jedai> thomashartman1: In Haskell though "=" is not assignment, it's definition, it tells "this is equal to this", "==" is a test of equality
15:36:19 <thomashartman1> jedai: there really is no concept assignment in haskell I guess, unless you count stuff like iorefs and the like which allow mutable state right?
15:36:19 <vixey> like to do that
15:36:26 <monochrom> So far I only know how to do this: give a boolean answer to whether or not the input string is in the language. I don't know yet how to do this: give Just (tree) where tree "corresponds" to the input string. I don't know how to do that "correspond".
15:36:30 <iwannalog> == is a test of equivalence not equality
15:36:54 <Axman6> now let's not get technical here
15:36:55 <Axman6> :P
15:37:06 <dons> jmelesky: huh.
15:37:24 <dons> jmelesky: and the ignite pdx talks had awesome cinematography on the cheap, iirc
15:37:26 <vixey> monochrom: With dependent types I give a specification by defining (1) a relation (datatype) that relates text to syntax, then  print :: (s :: String) -> exists t, s R t.. and parse :: (t :: Syntax) -> exists s, s R t
15:37:42 <dons> jmelesky: yeah, we should talk more
15:37:42 <vixey> by defining R a relation sorry
15:37:42 <jedai> iwannalog: This is disputable (and in fact has been disputed in more than one interminable thread on haskell-cafe)
15:37:48 <wli> This is one of the reasons why recursive descent parsing is horrible. Matching the operational spec to the grammar is highly nontrivial.
15:37:55 <vixey> the thing is that it's impossibly difficult to actually implement this
15:37:57 <bvck> So it would make more sense to read '=' as 'is defined by'?
15:38:00 <dons> iwannalog: almost always it is structural equality
15:38:18 <bvck> (not even assignment)
15:38:33 <wli> The right way is to take an annotated grammar as input.
15:38:46 <jedai> bvck: I'll maintain that "=" in value and function definition may and should be read as "is equal to"
15:39:06 <jmelesky> dons: afaik, it's pretty much just a mac laptop with a more easily movable camera and mic. i'll report back after the pre-meeting tech meeting with more info.
15:39:07 <vixey> Maybe I want to define some kind of prologish thing and prove some general theory about it - and implement a parser in /that/
15:39:10 <monochrom> Oh I can write a relation between strings and trees! That helps me. I know more about what to do now.
15:39:20 <jedai> bvck: it really is the equal you'll see in mathematics definitions
15:39:25 <iwannalog> jedai: it's not disputable
15:39:30 <thomashartman1> bvck: i'd say so, at least for type declarations like Maybe a = ...
15:39:42 <jedai> iwannalog: It has been disputed though
15:40:08 <monochrom> The language is already defined by recursion. There is no problem defining correspondence between string and tree by recursion too.
15:40:10 <iwannalog> for mathematician people it's not disputable, it's not an equality
15:40:20 <yitz> fortran used = for assignment because there was no equality operator. so people got used to that. algol introduced a new operator for assignment, but C introduced a new equality operator instead.
15:40:34 <Axman6> dons: no one at galois has a macbook or something then? (ot ideal, but it can work)
15:40:42 <monochrom> And I guess there is always the venue of "define f : tree -> string first, then just say the parser tries to invert f."
15:40:49 <dons> yeah, we've lots of macbooks
15:41:02 <thomashartman1> hey, what determines whether cabal install installs something that shows up in ghc-pkg list?
15:41:04 <dons> jmelesky: ok. the specs would be good
15:41:08 <jedai> iwannalog: I don't really see what you're speaking about, Eq is never explicitly told to be about relation of equivalence or relation of equality
15:41:12 <vixey> monochrom: Actually I jumped the gun a bit,
15:41:26 <iwannalog> never ?
15:41:34 <Axman6> i've seen a few techtalks recorded on macbooks. it works,, though it's not great (the worst example is those set of happs videos on youtube)
15:41:37 <bvck> I did not realize this was a philosophical question...:) Do I need to dig up my set theory books?...:)
15:41:45 <jedai> iwannalog: It is up to the programmer to decide which it is and there was many heated dispute on the subject
15:41:45 <vixey> monochrom: parse should be partial, it may error -- there is two options though Maybe or Either (exists t, s R t) (not (exists t, s R t))
15:41:50 <Axman6> bvck: you haven't already? :O
15:42:05 <iwannalog> jedai: it's not specified that it must be an equivalence ?
15:42:13 <iwannalog> i didn't know that
15:42:13 <bvck> I decided to upgrade to 'Category theory' directly (woe is me)...:)
15:42:41 <thomashartman1> bvck: how about reading this? http://www.defmacro.org/ramblings/equality.html
15:42:42 <thomashartman1> :)
15:42:55 <jedai> iwannalog: No, unfortunately. Anyway it's up to you to choose which you prefer.
15:43:05 <vixey> bvck: in this data definition it really is a nonsense
15:43:05 <bvck> thomashartman1, thanks. Will do.
15:43:22 <wli> Hmm. I guess you could do something like pattern match on stuff like Terminal "\\" : Terminal v : Terminal "=" : NonTerminal e@(Expr _) : Terminal "in" : NonTerminal e'@(Expr _) : xs and return NonTerminal (Expr (Let ...))) : xs
15:43:23 <vixey> bvck: this '|' sum of things are not well typed .. 'data Just' isn't an object
15:43:33 <vixey> bvck: Basically it's just an incantation which looks vaugely like BNF
15:43:41 <iwannalog> jedai: (for me equality is an equivalence) so I don't understand your answer
15:43:53 <wli> Maybe carrying out some nondeterministic choices.
15:44:29 <jedai> iwannalog: Note that there also is the debate of how you would define "equality", for exemple if from the outside of a module you can't distinguish between two values that are structurally distinct and (==) on those values is it still an equality
15:44:31 <bvck> vixey, I liked the syntax for GADT better for this reason.
15:44:36 <yitz> dons: but macbook is better than nothing until you get something better going
15:44:56 <vixey> bvck: yeah it's conceptually much clearer
15:44:56 <jedai> iwannalog: equality is an equivalence, but every equivalence isn't an equality
15:45:04 <iwannalog> jedai: equality doesn't belong to unprooved computer system
15:45:22 <vixey> iwannalog: huh ?
15:45:49 <iwannalog> without proof == is something very hard to manage
15:46:08 <wli> You've got to go fishing around for reductions to carry out all over the input, though.
15:46:08 <vixey> iwannalog: I kind of almost agree .. we could really say this about _every programming problem_ though
15:47:44 <wli> I guess you could try nondeterministically splitting the input and looking for derivations as far to the right as possible.
15:47:59 <iwannalog> it's just that i think that Eq is a bad name, and that Equiv would be better
15:48:13 <iwannalog> no no sorry it's not what I mean
15:48:15 <yitz> > let n = 1/9 in map (==n) . iterate (subtract 1 . (* 10)) $ n
15:48:16 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
15:48:36 <iwannalog> but i like to not think about it
15:49:08 <vixey> wli: well yeah, but I want something that's reasonably efficient
15:49:24 <vixey> wli: but maybe in a lazy context that isn't so bad
15:49:53 <td123> does haskell have builtin (standard) libraries that support networking and/or multithreading?
15:50:02 <wli> vixey: Well, you can build state machines based on the grammars that make it efficient.
15:50:25 <Peaker> td123: Control.Concurrent for multithreading
15:50:33 <yitz> @faq does haskell have builtin (standard) libraries that support networking and/or multithreading?
15:50:33 <Peaker> td123: there are libraries for networking too, of course
15:50:33 <lambdabot> The answer is: Yes! Haskell can do that.
15:50:53 <Gracenotes> well, depends on the definition of builtin
15:50:58 <Gracenotes> well hallo debian
15:51:33 <jedai> iwannalog: Well I agree that Eq can easily be confusing, it wouldn't be so bad if the report stated unequivocally whether it stand for Equal or Equivalence
15:51:35 <Axman6> td123: haskell has excellent multithreading support. it's truly lovely to work with, and usually very safe
15:52:23 <iwannalog> jedai: equal is defined everywher in math, but it's too hard to define it in haskell (or anyother language) for every type
15:53:05 <Axman6> td123: http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all demonstrates the performance of haskells multithreading support (the top program was totally not submitted by me >_>)
15:53:12 <vixey> iwannalog: it is kinda easy to define by recursion on types -- it's impossible to /decide/
15:53:38 <jedai> td123: Haskell supports multithreading, GHC has a very efficient n over m model (user threads over kernel threads). To exploit those threads you have a lot of way, whether the code you want to parallelize is pure or in the IO monad
15:53:45 <iwannalog> vixey: yes
15:54:00 <vixey> iwannalog: oh well I guess that is way beyond "inside haskell" so yeah ignore me
15:54:07 <jedai> I agree with both of you (vixey, iwannalog)
15:54:46 <wli> vixey: They may end up being nondeterministic state machines, though. e.g. if you get action conflicts then just use LogicT or something to make a nondeterministic choice wrt. state transitions.
15:54:53 <iwannalog> no it was an intersting remark
15:54:53 <jedai> td123: Haskell is really a nice language to exploit multicores
15:59:22 <wli> That reminds me, parallel nondeterminism...
16:02:19 <tromp> gratz on the winning logo, jeffwheeler!
16:02:35 <jeffwheeler> tromp: thanks!
16:06:23 <roconnor> @seen RayNbow
16:06:23 <lambdabot> RayNbow is in #haskell. I last heard RayNbow speak 1h 5m 54s ago.
16:06:47 <SubStack> yay, my concurrent network haskell program is peaking at about 170MB/s, which is just the same as netcat
16:06:56 <vixey> hi roconnor
16:07:13 <SubStack> and that's only a single thread
16:07:45 <pumpkin> @free a -> a
16:07:45 <lambdabot> Extra stuff at end of line
16:07:47 <pumpkin> hmm
16:07:53 <pumpkin> how does @free work?
16:07:59 <pumpkin> isn't it sort of like djinn?
16:08:07 <roconnor> hi vixey
16:08:34 <pumpkin> @help free
16:08:34 <lambdabot> free <ident>. Generate theorems for free
16:09:11 <tromp> Src forM
16:09:18 <tromp> @src forM
16:09:19 <lambdabot> forM = flip mapM
16:09:59 <SubStack> it's faster than netcat now \o/
16:10:21 <pumpkin> meow
16:10:25 <pumpkin> what is?
16:10:32 <thomashartman1> how do you pass a flag to the cabal command? eg, want to install http://github.com/jgm/gitit/blob/a49b6ca9b7cec0cd08ca9020b8559584be3b68e5/gitit.cabal with flag "plugins" true without modifying that cabal file
16:10:47 <pumpkin> oh, I see
16:10:48 <thomashartman1> cabal install --plugins... nope......
16:11:14 <thoughtpolice> thomashartman1: cabal install -fplugins
16:11:21 <thomashartman1> thank you
16:12:08 <pejo> @free map -- pumpkin
16:12:09 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
16:12:18 <pumpkin> ack
16:12:28 <Gracenotes> free-falling, I'm a *pause* free-falling...
16:12:42 <pumpkin> what does the $ mean?
16:12:57 <wli> One thing to cut down on the nondeterministic choices is when actions commute.
16:13:09 <thoughtpolice> pumpkin: also no luck on the x86 64 route. :( we may have to wait until the backend changes and new build system are in place so we can bootstrap from hc files again
16:13:25 <pumpkin> thoughtpolice: that's why I was trying to start from 6.6
16:13:33 <pumpkin> but yeah, it definitely isn't easy :/
16:13:44 <pumpkin> I'll give it another go when I get some time again
16:13:54 <wli> I think derivations from disjoint substrings commute.
16:14:22 <thoughtpolice> pumpkin: I'm not even sure that would work; I mean, compiling old GHCs with new GHCs isn't supported. 6.6 is the last place to have working hc bootstrap, and it didn't support x86/leopard which makes using static binaries a pain, etc.
16:14:24 <pumpkin> it seems like it shouldn't be hard... there's no technical reason x86_64 should be any harder on osx, but I guess it is anyway :P
16:14:43 <pumpkin> thoughtpolice: oh, I already have an old ghc setup to compile 6.6 with
16:15:00 <pumpkin> I have an x86 6.6 to compile my from-hc 6.6 x86_64 going
16:15:21 <pumpkin> and had it going most of the way but was getting ready to throw my computer out of the window, so I took a break
16:16:13 <JoshTriplett> > unfoldr (\l -> do (x1:x2:xs) <- return l ; return ((x1,x2),xs)) [1..10]
16:16:15 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:16:29 <thoughtpolice> pumpkin: it would probably be easiest it wait for the build system/codegen changes to settle. that probably won't happen for several months, but then again I don't think lives are dependent upon an x86_64 os x build :)
16:16:33 <wli> Heuristically, there are things that act as brackets you should be able to use to partition the input.
16:16:38 <JoshTriplett> Any better way to break up a list into every N elements?
16:16:50 <thoughtpolice> pumpkin: but I'll keep looking into it; at the very least the RTS is probably going to need some changes for working on OS X like chak said
16:16:51 <vixey> JoshTriplett: I think your way is great
16:16:52 <pumpkin> thoughtpolice: speak for yourself! I want to use lots of RAM :P
16:17:04 <vixey> JoshTriplett: You can generalize it from 3 to n by using splitAt
16:17:08 <vixey> I think..
16:17:10 <vixey> :t splitAt
16:17:11 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:17:14 <pumpkin> and all those extra unused registers make me want to club baby seals
16:17:15 <wli> JoshTriplett: This is an FAQ.
16:17:39 <JoshTriplett> wli: I kinda figured as much.  Where might I find the FGA? :)
16:17:43 <vixey> > unfoldr (\l -> do (x1:x2:xs) <- return l ; return ((x1,x2),xs)) [1..10]
16:17:44 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:17:54 <thoughtpolice> pumpkin: yes, I just realized how nice the added registers on x86_64 are. :)
16:17:56 <vixey> > unfoldr (\(x1:x2:xs) -> Just ((x1,x2),xs)) [1..10]
16:17:57 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)* Exception: /tmp/2644153770801760467:71:69-...
16:18:04 <vixey> ah I see what you do there
16:18:07 <vixey> with the monad
16:18:14 <JoshTriplett> Yeah, the Maybe monad rocks. :)
16:18:15 <Gracenotes> it's fail, if you ask me
16:18:17 <vixey> > unfoldr (\l -> case l of [] -> Nothing ; (x1:x2:xs) -> Just ((x1,x2),xs)) [1..10]
16:18:18 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:18:18 <pumpkin> thoughtpolice: ah well, maybe I'll succeed with some extra work, I'll let you know if I ever get anywhere
16:18:24 <vixey> ahaa
16:18:24 <pumpkin> gotta go now
16:18:25 <pumpkin> :)
16:18:41 <Gracenotes> General Failure
16:18:43 <Gracenotes> *salutes*
16:18:53 <Peaker> Who is General Failure and why is he reading my disk?
16:20:09 <tromp> :t null
16:20:10 <lambdabot> forall a. [a] -> Bool
16:20:21 <JoshTriplett> > unfoldr (\l -> let (a,b) = splitAt 3 l in do guard (length a == 3) ; return (a,b)) [1..10]
16:20:22 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
16:20:29 <JoshTriplett> That works, but I have to call length.  ick.
16:20:48 <wli> no
16:20:53 <Gracenotes> a 'chunk' function?
16:21:00 <vixey> JoshTriplett: grumble that sucks
16:21:03 <wli> > let chunk n = unfoldr (\xs -> let y = splitAt n xs in guard (y /= ([],[])) >> return y) in chunk 3 [1..10]
16:21:04 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:21:10 <vixey> JoshTriplett: how about a version of splitAt that just returns a Maybe
16:21:13 <vixey> http://www.youtube.com/watch?v=9fohXBj2UEI
16:21:14 <Gracenotes> wli: doesn't do the same thing
16:21:23 <wli> Okay.
16:21:27 <JoshTriplett> wli: That emits a final partial.  I guess I could filter it off, but...
16:21:27 <vixey> why is lambdabot not saying the url ..
16:21:29 <tromp> > takeWhile (not.null) . evalState (State . splitAt 3) $ "abcedfghi"
16:21:30 <lambdabot>   Couldn't match expected type `s -> (a, s)'
16:21:39 <wli> JoshTriplett: Custom splitAt.
16:21:48 <Peaker> @type unfoldr
16:21:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:21:55 <Gracenotes> @type splitAt
16:21:57 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:22:01 <Gracenotes> @src splitAt
16:22:01 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
16:22:03 <JoshTriplett> wli: Right.  I just wanted to figure out if I could do this without a custom function.
16:22:04 <vixey> split : Int -> [a] -> Maybe ([a], [a])
16:22:19 <vixey> JoshTriplett: that is not good way to functional program imo
16:22:21 <Gracenotes> the actual implementation of splitAt (in GHC) is more elegant
16:22:28 <JoshTriplett> Gracenotes: I should hope so, yes. :)
16:22:33 <Gracenotes> well, faster, at least
16:22:34 <vixey> avoiding to define a function is just going to be difficult for yourself
16:22:42 <conal> does anyone know a way to turn off ghc's "duplicate constraints" warnings (without turning off others)?
16:22:59 <JoshTriplett> vixey: For the purposes of the program I wanted to write, I didn't.  But after the fact, I wondered if a better solution existed.
16:24:00 <tromp> maybe you can adapt the takeList discussed on cafe
16:24:11 <Gracenotes> JoshTriplett: from a few days ago, me posted http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2597
16:24:29 <Peaker> vixey: the sound quality in that video is problematic
16:24:50 <Gracenotes> a Maybe variant, although probably performing less (the primitives can be ignored of course), would work :)
16:25:02 <Gracenotes> performing less. vague. hrm, anyway.
16:25:22 <JoshTriplett> > map fst $ iterate (\(c,l) -> splitAt 3 l) [1..10]
16:25:23 <lambdabot>   Couldn't match expected type `([a], [a])'
16:25:39 <JoshTriplett> > map fst $ iterate (\(c,l) -> splitAt 3 l) ([], [1..10])
16:25:40 <lambdabot>   [[],[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
16:25:55 <JoshTriplett> > map fst $ iterate (\(c,l) -> splitAt 3 l) $ splitAt 3 l
16:25:56 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
16:26:03 <JoshTriplett> > map fst $ iterate (\(c,l) -> splitAt 3 l) $ splitAt 3 [1..10]
16:26:05 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
16:26:40 <JoshTriplett> > takeWhile (not . null) $ map fst $ iterate (splitAt 3 . snd) $ splitAt 3 [1..10]
16:26:42 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:26:58 <Peaker> > takeWhile (not . null) . map fst . iterate (splitAt 3 . snd) $ [1..10]
16:26:59 <lambdabot>   Couldn't match expected type `([a], [a])'
16:27:15 <tromp> > takeWhile (not.null) . evalState (mapM (State . splitAt) (repeat 3) ) $ "abcedfghi"
16:27:16 <lambdabot>   ["abc","edf","ghi"]
16:27:32 <JoshTriplett> > takeWhile (not.null) . evalState (mapM (State . splitAt) (repeat 3) ) $ "abcedfghij"
16:27:34 <lambdabot>   ["abc","edf","ghi","j"]
16:28:01 <tromp> repeat looks ugly though
16:28:22 <tromp> is there a takeWhileNot ?
16:28:32 <Badger> @hoogle takeWhileNot
16:28:33 <lambdabot> No results found
16:28:36 <JoshTriplett> @hoogle takeUntil
16:28:36 <lambdabot> No results found
16:28:41 <JoshTriplett> Sadly no.
16:28:53 <JoshTriplett> > let takeUntil = takeWhile . not
16:28:54 <lambdabot>   <no location info>: parse error on input `;'
16:29:03 <JoshTriplett> @let takeUntil = takeWhile . not
16:29:04 <lambdabot>  Couldn't match expected type `a -> Bool'
16:29:12 <Badger> @src takeWhile
16:29:13 <lambdabot> takeWhile _ []                 =  []
16:29:13 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
16:29:13 <lambdabot>                    | otherwise =  []
16:29:32 <JoshTriplett> @let takeUntil = (takeWhile . not .)
16:29:33 <lambdabot>  <local>:3:12:
16:29:33 <lambdabot>      The operator `.' [infixr 9] of a section
16:29:33 <lambdabot>          must ha...
16:30:18 <wli> Data.Sequence needs to get involved.
16:30:19 <jedai> @let takeUntil p = takeWhile (not . p)
16:30:20 <lambdabot>  Defined.
16:30:22 <thomashartman1> If in cabal file I have cpp-options:       -D_VERSION="0.6.1"
16:30:33 <JoshTriplett> jedai: You've got a point there. ;)
16:30:35 <wli> So you don't end up reversing a list in accumulators or whatever.
16:30:37 <jedai> Let's keep some points from time to time...
16:30:40 <vixey> I like jedais one
16:30:48 <vixey> takeUntil p = takeWhile (not . p) is point fre
16:30:55 <vixey> btw
16:31:02 <thomashartman1> how do I load this in ghci? I tried ghci -cpp -D_VERSION="0.6.1" Gitit.hs
16:31:06 <thomashartman1> but no dice
16:31:31 <JoshTriplett> > take 3 <$> [1..10]
16:31:32 <lambdabot>       No instance for (Enum [a])
16:31:32 <lambdabot>        arising from the arithmetic sequence ...
16:31:36 <dons> thomashartman1: you'll have to extract the flags cabal generates for ghc
16:31:37 <dons> use cabal -v
16:31:44 <dons> then look at what ghc line it prints
16:31:50 <dons> adding 'cabal ghci' support is a hot item atm
16:31:58 <Botje> @pl \x -> transformBi (fun x (isThunk x))
16:32:03 <lambdabot> transformBi . ap fun isThunk
16:32:07 <Botje> hmm
16:32:10 <Botje> @pl \x -> transformBi (fun (isThunk x) x)
16:32:10 <lambdabot> transformBi . (fun =<< isThunk)
16:32:16 <Botje> scary
16:32:19 <thomashartman1> cabal -v "unrecognized command" ?
16:32:28 <JoshTriplett> @pl \p -> takeWhile (not . p)
16:32:29 <lambdabot> takeWhile . (not .)
16:32:34 <JoshTriplett> Ah, precedence.
16:32:39 <thomashartman1> oh I get it
16:32:41 <vixey> @pl \x -> fun (identity x) (isThunk x)
16:32:42 <lambdabot> liftM2 fun identity isThunk
16:32:52 <vixey> @pl \x -> transformBi (fun (identity x) (isThunk x))
16:32:52 <lambdabot> transformBi . liftM2 fun identity isThunk
16:33:01 <vixey> transformBi . liftA2 fun identity isThunk
16:33:07 <yitz> @type takeWhile . (.) not
16:33:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
16:33:11 <jedai> Botje: I tend to find any usage of the ((->) e) Monad beyond the basic very scary indeed
16:33:18 <vixey> transformBi . (fun <$> identity<*>  isThunk)
16:33:23 <vixey> transformBi . (fun <$> identity <*> isThunk)
16:33:24 <tromp> > takeWhile (not.null) . evalState ( sequence . repeat $ State (splitAt 3) ) $ "abcedfghi"
16:33:25 <lambdabot>   ["abc","edf","ghi"]
16:33:26 <vixey> :)
16:33:48 <yitz> @let repeatM = sequence . repeat
16:33:49 <lambdabot>  Defined.
16:33:49 <tromp> maybe we shouldd have a repeatM
16:33:59 <yitz> ok you have it
16:34:30 <tromp> > takeUntil null . evalState (repeatM $ State (splitAt 3) ) $ "abcedfghi"
16:34:31 <lambdabot>   ["abc","edf","ghi"]
16:34:55 <jedai> yitz: Isn't that forever ?
16:35:02 <jedai> @type forever
16:35:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:35:04 <tromp> no, that doesnt make a list
16:35:09 <jedai> @type repeatM
16:35:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
16:35:14 <tromp> just discards results
16:35:20 <jedai> Ah right
16:36:38 <jedai> > takeUntil null . iterate drop 3 $ "abcdefghi"
16:36:39 <lambdabot>   Couldn't match expected type `Int'
16:36:47 <jedai> > takeUntil null . iterate (drop 3 )$ "abcdefghi"
16:36:48 <lambdabot>   ["abcdefghi","defghi","ghi"]
16:36:56 <tromp> @pl \n -> takeUntil null . evalState (repeatM $ State (splitAt n) )
16:36:56 <lambdabot> (takeUntil null .) . evalState . repeatM . State . splitAt
16:37:09 <yitz> > let wrapLines = takeUntil null . evalState . repeatM . State . splitAt in wrapLines 10 "This line is just a bit too long, let's wrap it."
16:37:10 <lambdabot>   Couldn't match expected type `[[a]]'
16:37:12 <tromp> now we're getting really unreadable:)
16:37:17 <jedai> > takeUntil null . map (take 3) . iterate (drop 3) $ "abcdefghi"
16:37:18 <lambdabot>   ["abc","def","ghi"]
16:38:06 <yitz> > let wrapLines = (takeUntil null .) . evalState . repeatM . State . splitAt in wrapLines 10 "This line is just a bit too long, let's wrap it."
16:38:07 <lambdabot>   ["This line ","is just a ","bit too lo","ng, let's ","wrap it."]
16:38:52 <Botje> @pl \x -> transformBi (noTHR (isThunk x) x)
16:38:53 <lambdabot> transformBi . (noTHR =<< isThunk)
16:39:00 <Botje> heh. same thing, doh :)
16:39:49 <Gracenotes> proper wrapping needs some kind of look-ahead
16:40:05 <pumpkin> wrapping?
16:40:28 <Gracenotes> or if not, not updating a line until you're sure it'll all fit, then moving on the next one when it doesn't
16:40:37 <pumpkin> ah
16:40:39 <vixey> Botje, did you see my way?
16:40:45 <Gracenotes> I'm sure there's a cute way to do that in Haskell.
16:40:46 <pumpkin> I vaguely remember a dynamic programming algorithm for that
16:40:50 <vixey> transformBi . (fun <$> identity <*> isThunk)
16:41:04 <jedai> > takeUntil null . unfoldr (Just . splitAt 3) $ "abcdefghi"
16:41:08 <lambdabot>   ["abc","def","ghi"]
16:41:24 <jedai> > takeUntil null . unfoldr (Just . splitAt 3) $ "abcdefghijk"
16:41:25 <lambdabot>   ["abc","def","ghi","jk"]
16:42:15 <Gracenotes> pumpkin: yeah, along the lines of what I was thinking of.
16:42:19 <wli> > let mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = mySplit' (n - 1) xs ys >>= return . first (y:) | otherwise = mzero in mySplit (5 :: Int) [1 .. 10] :: Maybe ([Int],[Int])
16:42:20 <lambdabot>   Just ([1,2,3,4,5],[6,7,8,9,10])
16:42:38 <jedai> > let wrapLines = takeUntil null . unfoldr . (Just . splitAt .) in wrapLines 10 "This line is just a bit too long, let's wrap it."
16:42:38 <wli> > let mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = mySplit' (n - 1) xs ys >>= return . first (y:) | otherwise = mzero in mySplit (5 :: Int) [1 .. 3] :: Maybe ([Int],[Int])
16:42:39 <lambdabot>       The operator `.' [infixr 9] of a section
16:42:39 <lambdabot>          must have lower prece...
16:42:40 <lambdabot>   Nothing
16:42:57 <vixey> hehe didn't know lambdabot could write haikus
16:42:58 <jedai> > let wrapLines = takeUntil null . unfoldr . ((Just . splitAt) .) in wrapLines 10 "This line is just a bit too long, let's wrap it."
16:42:59 <lambdabot>   Couldn't match expected type `(a, a1)'
16:43:50 <wli> > let mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = mySplit' (n - 1) xs ys >>= return . first (y:) | otherwise = mzero in unfoldr (mySplit (3 :: Int)) [0 .. 10] :: [[Int]]
16:43:51 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8]]
16:44:32 <JoshTriplett> wli: Impressively unreadable, but correct.
16:45:59 <JoshTriplett> > groupBy (<) [1,2,3,4,5,1,2,3,4,5]
16:46:00 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5]]
16:46:20 <JoshTriplett> @type on
16:46:21 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:46:41 <wli> JoshTriplett: Then try mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = do { (xs', ys') <- mySplit' (n - 1) xs ys ; return (y : xs', ys') } | otherwise = mzero
16:46:52 <Peaker> > map (take 3) . takeWhile (not . null) . iterate (drop 3) . tails $ [1..10]
16:46:53 <lambdabot>   [[[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10]],[[4,5,6,7...
16:46:59 <yitz> > groupBy (<) [1,2,4,3,5,1,2,4,3,5]
16:47:00 <lambdabot>   [[1,2,4,3,5],[1,2,4,3,5]]
16:47:26 <JoshTriplett> > map snd $ groupBy ((<) `on` fst) $ zipWith (cycle [1..3]) [1..10]
16:47:27 <lambdabot>   Couldn't match expected type `a -> b -> c'
16:47:44 <JoshTriplett> > map snd $ groupBy ((<) `on` fst) $ zip (cycle [1..3]) [1..10]
16:47:45 <lambdabot>   Couldn't match expected type `(a, b)'
16:47:56 <purplepenguins> It appears that both mtl and monads-fd define Control.Monad.Reader...anyone have a suggestion for working around this?
16:48:10 <Peaker> > iterate (drop 3) . tails $ [1..10]
16:48:12 <JoshTriplett> > groupBy ((<) `on` fst) $ zip (cycle [1..3]) [1..10]
16:48:12 <lambdabot>   [[[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8...
16:48:13 <lambdabot>   [[(1,1),(2,2),(3,3)],[(1,4),(2,5),(3,6)],[(1,7),(2,8),(3,9)],[(1,10)]]
16:48:27 <JoshTriplett> > map (map snd) $ groupBy ((<) `on` fst) $ zip (cycle [1..3]) [1..10]
16:48:28 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:48:36 <vixey> > let drop (x:xs) = xs ; take (x:xs) = (x,xs) ; repeat f xs = case f xs of (x,ys) -> x : repeat f ys in repeat (take . drop . drop) ['a'..'z']
16:48:37 <lambdabot>   "cfilorux* Exception: /tmp/6602443185519768149:71:55-74: Non-exhaustive pat...
16:48:52 <vixey> > let drop (x:xs) = xs ; take (x:xs) = (x,xs) ; repeat f xs = case f xs of (x,ys) -> x : repeat f ys in repeat (take . drop) ['a'..'z']
16:48:53 <lambdabot>   "bdfhjlnprtvxz* Exception: /tmp/1769821866857367072:71:36-51: Non-exhaustiv...
16:48:58 <JoshTriplett> > map (map snd) $ groupBy (\a b -> a == 3) $ zip (cycle [1..3]) [1..10]
16:48:59 <lambdabot>       No instance for (Num (a, b))
16:48:59 <lambdabot>        arising from the literal `3' at <in...
16:49:08 <JoshTriplett> > map (map snd) $ groupBy (\a b -> fst a == 3) $ zip (cycle [1..3]) [1..10]
16:49:10 <lambdabot>   [[1],[2],[3,4,5,6,7,8,9,10]]
16:49:59 <jedai> purplepenguins: It appears that the current suggestion is that we should use transformers and monad-fd (or monad-tf) instead of mtl, I must say I don't really remember what are the advantages of transformers over mtl
16:50:41 <yitz> jedai: it works with monad-ft and monad-fd
16:50:47 <jedai> If indeed this is confirmed we may be in for another painful upgrade in some years
16:50:47 <JoshTriplett> > map (map snd) $ groupBy ((<) `on` fst) $ zip (cycle [1..3]) [1..10]
16:50:48 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:51:18 <Peaker> > map (take 3 . head) . takeWhile (not . null) . iterate (drop 3) . tails $ [1..10]
16:51:19 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:51:19 <purplepenguins> Okay, so I have to obliterate mtl from my cabal store by hand?
16:51:32 <vixey> > groupBy ((<) `on` (`mod` 3)) [1..10]
16:51:33 <lambdabot>   [[1,2],[3,4,5],[6,7,8],[9,10]]
16:51:43 <purplepenguins> Also, does monads-fd + transformers provide all the necessary bits for packages that require mtl as a dependency?
16:51:45 <jedai> yitz: To my confusion I don't know the advantages (I know the disadvantages of mtl but not really what monad-* brings)
16:51:58 <int-e> Peaker: why the 'tails'?
16:52:09 <JoshTriplett> vixey: Nice idea, if you rely on having a list of integers. :)
16:52:21 <Peaker> int-e: its 2 am, I'm just confused :)
16:52:39 <jedai> Peaker: I suggested "takeUntil null . map (take 3) . iterate (drop 3)"
16:52:50 <Peaker> jedai: ah
16:52:59 <Peaker> jedai: that's the nicest I've seen yet, I think
16:53:03 <jedai> Which is cute but less efficient than some others proposal I guess
16:53:05 <JoshTriplett> > [x | (3,x) <- zip (cycle [1..3]) (tails [1..10])]
16:53:06 <lambdabot>   [[3,4,5,6,7,8,9,10],[6,7,8,9,10],[9,10]]
16:53:24 <JoshTriplett> > [x | (1,x) <- zip (cycle [1..3]) (tails [1..10])]
16:53:25 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10]]
16:53:40 <JoshTriplett> > [take 3 x | (1,x) <- zip (cycle [1..3]) (tails [1..10])]
16:53:41 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
16:54:30 <jeffwheeler> > [x | (1,x) <- zip (cycle [1..3]) (tails [1..10])]
16:54:31 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10]]
16:54:43 <vixey> @w80 quala
16:54:46 <lambdabot> No match for "quala".
16:54:52 <jedai> > unfoldr (\xs -> guard (null xs) >> splitAt 3 xs) $ [1..14]
16:54:53 <lambdabot>   Couldn't match expected type `Maybe (a, [a1])'
16:55:00 <vixey> oh it's not bilingual
16:55:30 <JoshTriplett> > [take 3 x | (1,x@(_:_:_:_)) <- zip (cycle [1..3]) (tails [1..10])]
16:55:31 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
16:55:34 <pumpkin> return?
16:55:37 <jedai> > unfoldr (\xs -> guard (null xs) >> return (splitAt 3 xs)) $ [1..14]
16:55:38 <lambdabot>   []
16:55:57 <JoshTriplett> jedai: "not (null xs)" perhaps?
16:56:08 <jedai> JoshTriplett: right ! :/
16:56:19 <jedai> > unfoldr (\xs -> guard (not $ null xs) >> return (splitAt 3 xs)) $ [1..14]
16:56:20 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14]]
16:56:24 <wli> jedai: He wants no partial sublists at the ends.
16:56:37 <int-e> @type liftM2 (>>) f g
16:56:38 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, SimpleReflect.FromExpr (m1 (m b)), SimpleReflect.FromExpr (m1 (m a)), Monad m) => m1 (m b)
16:56:41 <int-e> @type liftM2 (>>) ?f ?g
16:56:42 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, ?g::m1 (m b), ?f::m1 (m a), Monad m) => m1 (m b)
16:56:50 <wli> > let mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = do { (xs', ys') <- mySplit' (n - 1) xs ys ; return (y : xs', ys') } | otherwise = mzero in unfoldr (mySplit (3 :: Int)) [0 .. 10] :: [[Int]]
16:56:51 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8]]
16:56:56 <JoshTriplett> wli: At this point, it seems sufficiently painful to handle the N case that I'd rather just pattern-match and handle the common cases of 2, 3, and so on.
16:57:12 <wli> JoshTriplett: The above will do it for you.
16:57:12 <JoshTriplett> wli: Given that pretty much every time I've wanted this I wanted 2 or 3 or 4.
16:57:18 <jedai> wli: Frankly in his case the only really good solution is to write his own splitAt
16:57:32 <wli> jedai: Like mySplit above?
16:57:39 <jedai> wli: right
16:57:45 <yitz> @pl let mySplit n = mySplit' n [] ; mySplit' n xs yy | n == 0 = return (xs, yy) | y : ys <- yy = do { (xs', ys') <- mySplit' (n - 1) xs ys ; return (y : xs', ys') } | otherwise = mzero in unfoldr (mySplit (3 :: Int)) [0 .. 10] :: [[Int]]
16:57:45 <Peaker> guard (not $ null xs) = guard ((not . null) xs) = guard . not . null $ xs
16:57:45 <lambdabot> (line 1, column 50):
16:57:45 <lambdabot> unexpected "|"
16:57:45 <lambdabot> expecting pattern or "="
16:58:34 <wli> yitz: I don't believe lambdabot has PatternGuards
16:58:51 <yitz> ew pattern guards
16:59:05 <Botje> they're cool!
16:59:08 <JoshTriplett> wli: In any case, thanks for the help.
16:59:08 <wli> I love pattern guards. What's wrong with them?
16:59:11 <JoshTriplett> Same to the rest of the channel.
16:59:28 <int-e> > let w = unfoldr . liftM2 (>>) (guard . not . null) . (return .) . splitAt in w 3 "fdjsdas"
16:59:29 <lambdabot>   ["fdj","sda","s"]
16:59:35 <yitz> wli: they are the ugliest possible abusive overload of <-
16:59:36 <Botje> replace foo | Just foo' <- lookup foo replacements = foo'
17:00:19 <Gracenotes> i cu pointfree thar int-e
17:01:46 <int-e> You can recognize most point-free code easily by its abundance of dots.
17:01:50 <yitz> wli: there is just no need for them. any pg expression can (and should) be written in the Exit monad, or the MonadPlus instance of Maybe, or even (shudder) the Cont monad. Just don't obscure the monad with pgs.
17:02:19 <RayNbow> @seen roconnor
17:02:20 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 54m 12s ago.
17:03:09 <pumpkin> > evalState (replicateM 3 . State . splitAt $ 3) $ [1..10]
17:03:10 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
17:03:14 * bremner likes pattern guards too, because they make sense to people who don't grok monads
17:03:35 <wli> Monads are fine. I just find pattern guards to be a super-clear way to write things.
17:03:39 <Gracenotes> > let pointy = length . findIndices (=='.' ) in pointy "unfoldr . liftM2 (>>) (guard . not . null) . (return .) . splitAt"
17:03:40 <lambdabot>   6
17:03:41 * RayNbow has the feeling his eyes are getting tired...
17:04:08 <yitz> bremner: because they confuse the meaning of <- they should *especially* be avoided by people who want to learn about monads
17:04:13 <Gracenotes> > let pointy = length . findIndices (=='.') in pointy "length . findIndices (=='.')"
17:04:14 <lambdabot>   2
17:04:14 <RayNbow> I misread "evalState" in pumpkin's msg as "evilState" :p
17:04:41 <wli> yitz: What should be used instead of <- for some equivalent syntactic construct?
17:05:24 <yitz> wli: don't know. something new. <<- or whatever.
17:05:38 <bremner> yitz: pattern guards don't need <-
17:06:13 <wli> bremner: The PatternGuard extension refers to pattern matching in guard expressions.
17:06:14 <yitz> bremner: then they are just guards, which are fine
17:06:20 <Gracenotes> > let pointy = ((length . findIndices) .) . (==) in pointy '.' "length . findIndices (=='.')"
17:06:21 <lambdabot>   Couldn't match expected type `[a]'
17:06:24 <Gracenotes> :x
17:06:30 <bremner> oh, me blushes
17:06:39 <wli> bremner: Reread the mySplit' above.
17:06:41 <bremner> I guess I just like guards then :-)
17:08:21 <bremner> I see, I only saw the first guard
17:08:30 * bremner wondered what the fuss was  about :-)
17:08:38 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2836#a2836 <- are the scheme and haskell fucntion equal there? http://news.ycombinator.com/item?id=530605 <-there the scheme awas posted. ijust dont get the cons function. it shouldtake 2 args but with the lambda it takes 3.
17:09:22 <kadaver> (p (lambda (a b) a)))
17:09:22 <kadaver> what does that do? destrcutre?
17:09:32 <xaxa> hi
17:09:45 <pumpkin> > let mySplit n xs = takeWhile ((n ==) . length) . evalState (sequence . repeat . State . splitAt $ n) $ xs in mySplit 3 [1..10]
17:09:46 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
17:09:51 <blackh> xaxa: Hello!
17:10:13 <Gracenotes> kadaver: the cons you posted is incompatible with the car and cdr
17:10:21 <pumpkin> can anyone think of a nice way to get rid of the takeWhile?
17:10:34 <wli> pumpkin: That's pretty golfed.
17:10:36 <kadaver> Gracenotes: yeah that swhat i dont get, but it isnt in the swcheme version?
17:10:50 <pumpkin> wli: incomprehensibly so?
17:11:00 <Gracenotes> kadaver: the scheme definitions of car/cdr don't involve tuples, do they? :)
17:11:03 <pumpkin> sequence . repeat feels like forever, but it isn't
17:11:04 <pumpkin> :/
17:11:10 <pumpkin> repeatM? :P
17:11:18 <pumpkin> @index repeatM
17:11:18 <lambdabot> bzzt
17:11:29 <Gracenotes> to be compatible with the car/cdr, cons would have to be cons a b = (a, b), and for the other way around, car p = p const, cdr p = p (flip const)
17:11:32 <pumpkin> @src forever
17:11:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:11:34 <Gracenotes> const is \a b -> a
17:11:45 <Gracenotes> just like the scheme version
17:11:57 <yitz> kadaver: in the scheme, p is a *function* that takes a function as its parameter
17:12:00 <Botje> kadaver: car p = p (\a b -> a)
17:12:00 <wli> pumpkin: Maybe not incomprehensible, but more like trading off some nasty inefficiencies for shorter code.
17:12:00 <int-e> > forever Nothing
17:12:02 <lambdabot>   Nothing
17:12:15 <pumpkin> wli: inefficiencies?
17:12:26 <Gracenotes> what cons really does (in scheme, at least) is make a function that takes two arguments
17:12:46 <Gracenotes> or a function that accepts a function that takes two arguments :)
17:12:53 <wli> pumpkin: The ((== n) . length affair.
17:12:57 <Gracenotes> the first argument is the first part of the tuple, and the second argument is the second part. To access the first part, try \a b -> a
17:13:05 <pumpkin> wli: oh, yeah :P
17:13:06 <Gracenotes> which is a function that takes two arguments and returns the first
17:13:12 <Gracenotes> ##sicp might cover this as well
17:13:15 <pumpkin> wli: still O(n) though, I'm safe
17:13:18 <pumpkin> ;)
17:13:38 <pumpkin> actually, not quite
17:13:42 <kadaver> const?
17:13:48 <tromp> pumpkin: takeUntil (-1 `elem`) ....    ++[-1]
17:13:51 <Gracenotes> @src const
17:13:52 <lambdabot> const x _ = x
17:14:20 <kadaver> whats the point of const?
17:14:30 <Gracenotes> not having to write out \a b -> a
17:14:42 <Gracenotes> clutters up code.
17:14:44 <pumpkin> kadaver: sometimes a function will pass in something you don't need
17:14:51 <Gracenotes> equivalent to.. lambda (a b) a
17:15:10 <Gracenotes> flip const flips the initial arguments, like lambda (b a) a
17:15:19 <kadaver> i still dont get the cons function since it needs 3 args whie,l cons takes 2
17:15:36 <EvilTerran> cons function?
17:16:19 <kadaver> yes cons
17:16:24 <kadaver> cons a b = \f -> f a b
17:16:42 <kadaver> > let cons a b = \f -> f a b in cons 1 [2]
17:16:43 <lambdabot>       Overlapping instances for Show ((t -> [t1] -> t2) -> t2)
17:16:43 <lambdabot>        arising...
17:16:52 <EvilTerran> ah, the encoding of a pair in the lambda calculus
17:17:01 <Gracenotes> the thing is, cons returns a function
17:17:19 <EvilTerran> cons takes the fst, the snd, and a continuation to pass them to
17:17:23 <kadaver> so with consonly ther eis no syntax for the ist
17:17:47 <kadaver> i see now it works
17:17:57 <Gracenotes> no. Haskell lists are their own thing; we have an explicit cons operator
17:18:12 <Gracenotes> , src []''
17:18:15 <lunabot>  luna: parse error on input `)'
17:18:17 <Gracenotes> :\
17:18:29 <ddarius> '' is a prefix operator
17:18:48 <stepcut> do I need to enable an extension besides GADTs to do, data Nat  :: * -> * where ...
17:18:54 <kadaver> why doesnt cons 12 (cons 4 5) work though?
17:19:02 <Gracenotes> ddarius: oh. anyway to get lunabot to behave, besides a good whipping?
17:19:25 <kerlo> kadaver: because 5 is not a list.
17:19:33 <kerlo> I assume that by cons you mean Haskell's cons operator, :.
17:19:43 <wli> JoshTriplett: http://wli.pastebin.com/m296be48e
17:19:52 <Gracenotes> kerlo: where's your cudder??
17:20:14 <Gracenotes> kadaver: you need a nil element
17:20:25 <Gracenotes> which is equal to (flip const), in the lambda calculus encoding
17:20:34 <Gracenotes> or \a b -> b
17:20:39 <yitz> kadaver: it does work. it gives you a dotted pair.
17:20:42 <ddarius> Gracenotes: Whipping the servant boy because you're speaking a language he doesn't know is unlikely to help.
17:21:03 <Gracenotes> @type let cons a b = \f -> f a b; nil = flip const in cons 12 (cons 4 5)
17:21:04 <lambdabot> forall t t1 t2 t3 t4. (Num t2, Num t1, Num t) => (t -> ((t1 -> t2 -> t3) -> t3) -> t4) -> t4
17:21:08 <wli> JoshTriplett: Indentation helps a lot with its comprehensibility.
17:21:37 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2837#a2837 <-
17:21:54 <tromp> why do you choose that nil, Gracenotes?
17:22:10 <kerlo> Now, if you're going to make a cons in lambda calculus, I think I'd use cons a b = \f g -> f a b
17:22:59 <Gracenotes> tromp: iirc it's a lambda calculus encoding? I forgot, though :\
17:23:25 <Gracenotes> > let cons a b = \f -> f a b; nil = flip const; car p = p const; cdr p = p (flip const) in (car.cdr) $ cons 12 (cons 4 5)
17:23:26 <lambdabot>   4
17:23:27 <tromp> i wonder where you saw that
17:23:29 <kadaver> where does the g come from?
17:23:49 <Gracenotes> > let cons a b = \f -> f a b; nil = undefined; car p = p const; cdr p = p (flip const) in (car.cdr) $ cons 12 (cons 4 nil)
17:23:50 <lambdabot>   4
17:23:56 <tromp> cause it's the choice i make in my binary lambda calculus stuff
17:24:24 <tromp> and i haven't seen it elsewhere
17:26:07 <Gracenotes> hm. I can't say I recall >_<
17:26:26 <pumpkin> > let (>_<) = (+) in 5 >_< 7
17:26:27 <lambdabot>   <no location info>: parse error on input `)'
17:26:28 <kadaver> cdr cdr s wrong though
17:26:30 <pumpkin> boo
17:26:41 <wli> JoshTriplett: Okay, take 2:
17:27:03 <Gracenotes> tromp: ah, Peter Selinger's Notes on Lambda Calculus defines it that way
17:27:29 <Gracenotes> In the lambda calculus, we can define nil = λxy.y and H :: T = λxy.xHT
17:27:39 <tromp> ah, thx
17:28:05 <Gracenotes> I might have gotten it from elsewhere, don't know though
17:28:35 <wli> JoshTriplett: http://wli.pastebin.com/m2b5e89bb
17:28:56 <Gracenotes> also false, and zero
17:29:15 <ddarius> > let nil = \n c -> n; cons a as n c = c a (as n c) in cons 1 (cons 2 (cons 3 nil)) 0 (+)
17:29:17 <lambdabot>   6
17:31:10 <kadaver> what year pc hardware does iphone and android compare to?
17:31:21 <Gracenotes> ddarius: so, is there an instruction manual on lunabot you'd recommend?
17:31:23 <p_l> kadaver: that's a stupid question, IMHO...
17:31:45 <ddarius> Gracenotes: '' is a TH operator.
17:31:46 <p_l> kadaver: you shouldn't compare different architectures targeting different targets this way
17:32:17 <Gracenotes> ddarius: ah, good. Anyway to have it display the [] datatype's (imagined) constructors?
17:32:27 <ddarius> , src ''[]
17:32:31 <lunabot>  data [] a = [] | a `(:)` ([a])
17:32:42 <Gracenotes> ah, great
17:32:46 <ddarius> , src '[]
17:32:49 <lunabot>  data [a_0] = ... | [] | ...
17:32:49 <lunabot>  infixl 9
17:33:27 <Gracenotes> how does TH get the information? being incestuously built into GHC?
17:33:29 <wli> JoshTriplett: In case you don't mind Control.Arrow, there is http://wli.pastebin.com/m5aa3593d
17:34:03 <roconnor> @seen RayNbow
17:34:03 <lambdabot> RayNbow is in #haskell. I last heard RayNbow speak 29m 48s ago.
17:34:23 <ddarius> Gracenotes: TH knows the definitions of types that are in scope.  That's part of its purpose.
17:34:33 <Gracenotes> , src maybe
17:34:34 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
17:34:38 <Gracenotes> ah
17:34:45 <Gracenotes> , src 'maybe
17:34:48 <lunabot>  maybe :: forall b a . b -> (a -> b) -> Maybe a -> b
17:35:04 <ddarius> However, src may be implemented using the Data class.
17:35:14 <ddarius> , src 'src
17:35:16 <lunabot>  src :: Name -> Doc
17:35:25 <Gracenotes> ah.
17:37:58 <wli> No pattern guards and no explicit case statements, so I figure that ought to get past the style reviewers. Also shorter.
17:39:00 <DocMAX3> hello, you probably won't believe me, but today i sucked my OWN dick!!!!! =)
17:39:12 <ddarius> @where ops
17:39:12 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
17:39:19 <Gracenotes> now go film it and put it on xtube
17:39:19 <p_l> ...
17:39:57 <DocMAX3> Gracenotes good idea
17:40:05 <dolio> Can you now die happy?
17:40:08 <roconnor> @type evalState . map (State . splitAt)
17:40:09 <lambdabot>     Couldn't match expected type `State s a'
17:40:09 <lambdabot>            against inferred type `[State [a1] [a1]]'
17:40:09 <lambdabot>       Expected type: [Int] -> State s a
17:40:20 <roconnor> @type evalState . mapM (State . splitAt)
17:40:21 <lambdabot> forall a. [Int] -> [a] -> [[a]]
17:40:30 <wli> > let chunk n = unfoldr (chunk' n []) ; chunk' 0 xs ys = Just (xs, ys) ; chunk' k xs (y:ys) = fmap (first (y:)) $ chunk' (k - 1) xs ys ; chunk' _ _ _ = Nothing in chunk 3 [1..10]
17:40:31 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
17:40:56 <thomastc> would it be possible to use th GHC API to parse and tyypecheck a Haskell program, and extract the type of a certain declared item?
17:41:11 <DocMAX3> Gracenotes can u believe what i did?
17:41:15 <wli> roconnor: The constraint is no incomplete lists that thwarts the usual golfed approach.
17:41:18 <roconnor> I never would have thought of that
17:41:18 --- mode: ChanServ set +o Igloo
17:41:24 <thomastc> I'm poking around in the API docs a bit but it's hard if you don't know what module to click :)
17:41:30 --- mode: Igloo set +b *!*@f049129202.adsl.alicedsl.de
17:41:39 --- kick: DocMAX3 was kicked by Igloo (Igloo)
17:42:12 --- mode: Igloo set -o Igloo
17:43:20 <roconnor> @type splitAt
17:43:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:43:28 <thomastc> oh, th eGHC module seems useful :)
17:43:35 <thomastc> makes sense :)
17:43:53 <dolio> The problem with that example State code is that it gives legitimacy to the clearly incorrect s -> (a, s) tuple ordering. :)
17:44:07 * p_l found it funny that geoip gave him missile address for our recently kicked guest
17:44:24 <roconnor> the nice thing about evalState . map (State . splitAt) is that evalState and splitAt are essentially no-ops (well I guess evalState is like fst), so it boils down to "mapM splitAt"
17:45:10 <dolio> Yeah. If you were using Agda, you could probably write: mapM {State} splitAt.
17:45:29 <Gracenotes> ddarius: hm.. in what interpretation of the lambda calculus is it used as a fold, as you had above? Is there a paper on it?
17:45:35 <dolio> Assuming it can't just infer State, which it probably can't.
17:46:08 * Gracenotes is a little rusty on LC, not to mention.. hrm
17:46:20 <Gracenotes> untyped anyway
17:46:48 <Ralith> anyone here used System.Plugins?
17:48:10 <dolio> > let chunk ([],_) = Nothing ; chunk (n:ns, l) = Just . second ((,) ns) $ splitAt n l in unfoldr chunk ([1,2,3,4],[1..10])
17:48:11 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
17:50:02 <roconnor> > evalState . mapM (State . splitAt) $ [1,2,3,4] [1..10]
17:50:03 <lambdabot>   Couldn't match expected type `t -> [Int]'
17:50:57 <dolio> > evalState (mapM (State . splitAt) [1..4]) [1..10]
17:50:58 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
17:52:40 <dolio> > let infixl 0 $ ; f $ x = f x in evalState $ mapM (State . splitAt) [1..4] $ [1..10]
17:52:41 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
17:53:00 <thomastc> http://code.google.com/soc/2008/haskell/appinfo.html?csaid=4189AF2C8AE5E25A does anyone know what became of that project?
17:53:41 <jethr0> > let worker [] _ = []; worker (x:xs) ys = (take x ys) : worker xs (drop x ys) in worker [1,2,3,4] [1..10]
17:53:42 <lambdabot>   [[1],[2,3],[4,5,6],[7,8,9,10]]
17:54:33 <RayNbow> @seen roconnor
17:54:33 <lambdabot> I saw roconnor leaving #haskell 1m 55s ago, and .
17:54:44 <wli> > let m = do { x <- State (splitAt 3) ; if null x then return [] else do { xs <- m ; return $ x : xs }} in evalState m [1 :: Int .. 10]
17:54:44 <Gracenotes> then
17:54:45 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
17:54:50 <RayNbow> (great, we keep missing each other :p)
17:55:14 <Gracenotes> will the two lambda lovers ever be united?
17:55:28 <jethr0> :t evalState
17:55:29 <lambdabot> forall s a. State s a -> s -> a
17:55:49 <RayNbow> Gracenotes: perhaps we will find out in tomorrow's episode? :p
17:56:00 * RayNbow is going to hit the sack soon :p
17:56:17 <Gracenotes> next week. we like to keep suspense (and production value) high
17:56:41 <jethr0> will you at least give a preview?
17:57:29 <RayNbow> jethr0: after the commercial break... maybe :p
17:57:32 <jethr0> dolio: what does the "State" in (State . splitAt) mean?
17:57:48 <dolio> Turns an s -> (a, s) into a State s a.
17:57:54 * Gracenotes goes off
17:58:29 <jethr0> dolio: even though I have a fleeting understanding of state monad, your above statement confuses me
17:58:38 <RayNbow> @src State
17:58:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:58:39 <jethr0> could you give a brief explanation why it works?
17:58:41 <dibblego> @type State
17:58:42 <lambdabot> forall s a. (s -> (a, s)) -> State s a
17:58:49 <dolio> newtype State s a = State (s -> (a, s))
17:59:02 <dolio> It's the newtype constructor.
17:59:31 <jethr0> that part I get, but why the mapM?
17:59:56 <jethr0> @type (mapM (State . splitAt))
17:59:57 <lambdabot> forall a. [Int] -> State [a] [[a]]
18:00:04 <jethr0> aahh
18:00:19 <dolio> @type map splitAt
18:00:20 <lambdabot> forall a. [Int] -> [[a] -> ([a], [a])]
18:00:48 <jethr0> that's pretty concise code. did you write that down from the top of your head?
18:01:01 <dolio> Someone wrote it on the mailing list.
18:01:07 <jethr0> ah, k
18:01:52 <jethr0> basically it "abuses" the fact that the state monad is based on functions, and that by chance splitAt fits that bill perfectly. right?
18:02:16 <dolio> I don't know if I'd call it abuse. :)
18:02:35 <FunctorSalad> is there a way to run an equivalent of /usr/bin/nm portably form cabal?
18:02:47 <dolio> If you had a language where you could declare a raw "s -> (a, s)" a monad it'd be quite nice.
18:02:51 <wli> Well, I'd do something like State . splitAt 3 and try to figure out how to loop.
18:03:18 <FunctorSalad> (there is what appears to be a typo in a symbol in my libftgl.a o_O but I don't want the binding to break again when it's fixed)
18:03:19 <dolio> Since it'd be "mapM splitAt", since "splitAt n" is an action in that monad for all n.
18:03:44 <dolio> The State is for instance/dictionary selection in Haskell.
18:03:55 <Ralith> When trying to load a precompiled bit of haskell code at runtime I'm getting "unknown symbol `Config_cfgAdmins_closure'" from System.Plugins
18:03:58 <jethr0> "instance/dictionary selection"?
18:04:08 <FunctorSalad> (according to the source it should be ftglGetLayoutBBox, but my debian-installed binary only has "ftgGetlLayoutBBox"... now that's a wtf)
18:04:13 <Ralith> what am I doing wrong?
18:04:29 <wli> I guess you could use zip to make sure the list lengths match, but anyway.
18:04:30 <Ralith> the module containing the aforementioned symbol is built into the calling program
18:04:38 <jethr0> FunctorSalad: might be a version mismatch...?
18:05:19 <FunctorSalad> jethr0: seems like a typo, since everything else in ftgl is prefixed 'ftgl' too... maybe it's some arcane symbol renaming scheme unknown to me o_O
18:05:29 <dolio> jethr0: Well, in for instance Agda, you can declare s -> (a, s) a monad, but it won't figure out what monad you want to use just from "mapM splitAt". So you'd need to write "mapM StateMonad splitAt" or something like that, which specifies that you want to be using the s -> (a, s) monad functions.
18:06:09 <dolio> The "State ." serves the same purpose in Haskell, by wrapping the s -> (a, s) up into a newtype.
18:06:10 <FunctorSalad> jethr0: theoretically it's the same version, though I didn't build it myself from the source containing the correct symbol
18:06:45 <jethr0> k, thx
18:07:25 <dolio> The actual equivalent of "evalState . mapM (State . splitAt)" would be "fst . mapM State splitAt" I suppose.
18:07:44 <dolio> Not too different.
18:08:20 <gwern> @wn droll
18:08:23 <lambdabot> *** "droll" wn "WordNet (r) 2.0"
18:08:24 <lambdabot> droll
18:08:24 <lambdabot>      adj : comical in an odd or whimsical manner; "a droll little man
18:08:24 <lambdabot>            with a quiet tongue-in-cheek kind of humor"
18:09:20 <jethr0> @wn drole
18:09:21 <lambdabot> No match for "drole".
18:09:23 <Ralith> in fact
18:09:30 <Ralith> I know for certain that Config is built in
18:09:38 <Ralith> because it's responsible for getting the program to the point of loading anything.
18:09:48 <gwern> @wn prole
18:09:49 <lambdabot> *** "prole" wn "WordNet (r) 2.0"
18:09:49 <lambdabot> prole
18:09:49 <lambdabot>      n : a member of the working class (not necessarily employed);
18:09:49 <lambdabot>          "workers of the world--unite!" [syn: {proletarian}, {worker}]
18:10:45 <Ralith> if I try a module that doesn't import Config, I get:
18:10:51 <Ralith> unknown symbol `__stginit_Types_'
18:10:56 <Ralith> which sounds internal
18:11:06 <wli> > takeWhile (not . null) $ evalState (mapM (State . splitAt) (repeat 3)) [1 :: Int .. 10]
18:11:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
18:11:14 <wli> That's how it looks in full.
18:12:02 <newsham> ssplit n xs = do { xs <- gets take n; modify (drop n); return xs } ?
18:12:29 <newsham> gets (take n)
18:12:33 <Ralith> help?
18:13:32 <FunctorSalad> jethr0: built it myself, and the symbol is still renamed :)
18:13:43 <newsham> gets (take n) <* modify (drop n)   ?
18:14:02 <Ralith> in fact
18:14:17 <Ralith> even the examples at http://www.cse.unsw.edu.au/~dons/hs-plugins/hs-plugins-Z-H-6.html don't work
18:14:23 <Ralith> dons: this is your code; any ideas?
18:16:29 <dons> mm?
18:16:43 <dons> on windows?
18:16:50 <Ralith> nope
18:16:53 <Ralith> arch linux
18:16:57 <dons> using plugins from AUR?
18:17:02 <Ralith> from cabal
18:17:02 <bremner> heh
18:17:04 <dons> ok.
18:17:22 <dons> send a bug report. plugins is unmaintained at the moment though
18:17:32 <Ralith> :(
18:17:47 <dons> :(
18:17:49 <Ralith> any other packages you can recommend for loading precompiled code?
18:18:00 <dons> no. that's the one. loading a simple Foo.o should work fine.
18:18:12 <dons> e.g. turbinado does that using plugins
18:18:26 <dons> i'm not sure how well more complicated things involving package search are
18:19:05 <Ralith> loading a simple Foo.o how?
18:19:28 <dons> load "foo.o"
18:19:34 <dons> is that what you're trying to do?
18:20:01 <Ralith> well, load takes a lot more than one argument
18:20:02 <dons> so: plugins is unmaintained. but simple plugin loading does appear to work. i'd be interested in reports of that not working
18:20:04 <Ralith> but basically that.
18:20:05 <dons> sure.
18:20:19 <Ralith> so no, that doesn't seem to work here
18:20:25 <dons> ok. good. so send me a test case
18:20:50 <Ralith> I'll just see if I can get the one-plugin example to reproduce
18:22:36 <dons> ok
18:23:34 <Ralith> ...huh.
18:23:43 <Ralith> this one won't even compile. I must be doing something wrong.
18:23:44 <Ralith> StringProcPlugin.hs:6:9: Not in scope: `stringProcessor'
18:32:04 <cpfr> is there a really nice way to replace the ~ in filepaths with haskell say, "~/foo.hs" to "/home/cpfr/foo.hs"
18:32:17 <cpfr> i am trying canonicalizePath but no dice
18:35:21 <validuser> try normalizePath?
18:39:29 <Ralith> dons: where do you want the testcase?
18:39:48 <Ralith> had to comment out a few lines but it gets to the error now, rather than bailing out earlier
18:40:27 <bjorkintosh> what do you guys think of hudak's book 'haskell school of expression'?
18:41:15 <wli> > let chunk n = execWriter . evalStateT (fix (\x -> StateT (return . splitAt n) >>= tell . (:[]) >> gets (not . null) >>= flip when x)) in chunk 3 [1 .. 10]
18:41:17 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
18:44:35 <cpfr> validuser, I dont think that function exists
18:47:08 <leimy_> bjorkintosh: I like it
18:47:26 <leimy_> I think it covers things you won't see in some other places... like roll your own state monad with some decorations.
18:51:58 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in execWriter . evalStateT m in chunk 3 [1 .. 10]
18:51:59 <lambdabot>       No instance for (Show (m [t]))
18:51:59 <lambdabot>        arising from a use of `show' at <...
18:52:03 <kadaver> p <- page
18:52:03 <kadaver>               hPutStr h $ respond clientinput p; how do i do this in one step?
18:52:04 <bjorkintosh> decorations?
18:52:12 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in execWriter . evalStateT m in chunk 3 [1 .. 10] :: [[Int]]
18:52:13 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
18:52:21 * Ralith pokes dons 
18:52:32 <Botje> kadaver: hPutStr h . respons clientinput =<< p
18:52:38 <Botje> (you asked :p)
18:52:39 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in execWriter . evalStateT m in chunk 3 [1 .. 10] :: Sequence.Seq [Int]
18:52:40 <lambdabot>   fromList [[1,2,3],[4,5,6],[7,8,9],[10]]
18:52:43 <Botje> err
18:52:46 <Botje> page, instead of p
18:53:29 <wli> Am I missing a Data.Sequence.toList or is it actually not there?
18:54:38 <wli> Writing out unfoldr (\xs -> case viewl xs of { EmptyL -> Nothing ; y :< ys -> Just (y, ys) }) every time is kind of aggravating.
18:55:22 <wli> Something like minView/maxView from Map that plugs into unfoldr with no wrapping would've at least mitigated it.
18:55:22 <ddarius> :t toList
18:55:23 <lambdabot> Not in scope: `toList'
18:55:30 <ddarius> @Hoogle toList
18:55:30 <lambdabot> Maybe you meant: google hoogle
18:55:35 <ddarius> @hoogle toList
18:55:35 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
18:55:36 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
18:55:36 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
18:55:43 <mmorrow_> yeah, it's totally annoying that they didn't bother to have it
18:55:59 <mmorrow_> (they expect you to use Data.Foldable)
18:56:07 <mmorrow_> ((to make your own))
18:56:22 <ddarius> > ((()))
18:56:23 <lambdabot>   ()
18:56:26 <mmorrow_> heh
18:56:57 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in Data.Foldable.toList (execWriter . evalStateT m in chunk 3 [1 .. 10] :: Sequence.Seq [Int])
18:56:57 <lambdabot>   <no location info>: parse error on input `in'
18:57:08 <newsham> ?type ((()))
18:57:09 <lambdabot> ()
18:57:17 <mmorrow_> ah nice, i forgot there's a Data.Foldable.toList
18:57:22 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in execWriter . evalStateT m in chunk 3 [1 .. 10] :: Sequence.Seq [Int]
18:57:23 <lambdabot>   fromList [[1,2,3],[4,5,6],[7,8,9],[10]]
18:58:06 <wli> > let chunk n = let m = StateT (return . splitAt n) >>= tell . return >> gets (not . null) >>= flip when m in execWriter . evalStateT m in Data.Foldable.toList (chunk 3 [1 .. 10] :: Sequence.Seq [Int])
18:58:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
18:59:07 <dolio> > fromList [1..] :: Seq Int
18:59:08 <lambdabot>   Not in scope: `fromList'Not in scope: type constructor or class `Seq'
18:59:17 <wli> ugh, meant for private message to lambdabot, not the channel
18:59:23 <dolio> > fromList [1..] :: Data.Sequence.Seq Int
18:59:24 <lambdabot>   Not in scope: `fromList'
18:59:32 <dolio> > Data.Sequence.fromList [1..] :: Data.Sequence.Seq Int
18:59:33 <lambdabot>   /tmp/3168804355957963762:70:36:
18:59:33 <lambdabot>      Not in scope: `Data.Sequence.fromList'...
18:59:38 <dolio> Geeze.
18:59:52 <wli> > Sequence.fromList [1..10]
18:59:53 <lambdabot>   fromList [1,2,3,4,5,6,7,8,9,10]
19:00:16 <mmorrow_> dolio: n'existe pas
19:00:31 <dolio> > Sequence.fromList [1..]
19:00:45 <wli> The module namespace weirdness with lambdabot is horrendous.
19:00:46 <lambdabot>   mueval: Prelude.read: no parse
19:01:09 <mmorrow_> wli: the ghc-api is to blame
19:01:39 <Ralith> how does lambdabot do plugins?
19:01:51 <mmorrow> Ralith: via hint, which uses the ghc-api
19:03:00 <thomastc> mmorrow: do you happen to know whether the ghc api is ready to be used in IDEs?
19:03:51 <mmorrow> thomastc: various projects have/are using it to varying extents, but i'm not sure what you'd call "ready"
19:04:07 <cpfr> validuser, any idea
19:04:18 <mmorrow> i guess the situation is that it's the _only_ way to get various info with ghc atm
19:05:04 <thomastc> for example, is it possible to hand it a source file, then extract the types of everything in that file?
19:05:10 <mmorrow> thomastc: check out: yi, scion, simon marlow did a visual studio something and wrote a paper about it (i think it's bitrotted)
19:05:26 <mmorrow> thomastc: sure
19:05:40 <wli> Well, the ancient version of VS it worked with still works with it.
19:05:58 <mmorrow> thomastc: (unfirtunately) the only real documentation though is the code itself..
19:06:00 <ddarius> thomastc: It has the capabilities, the interface is just not stable.
19:06:04 <mmorrow> *unfortunately
19:06:10 <wli> It didn't really do very much compared to what language plugins usually do, though.
19:06:14 <mmorrow> yeah, that too. it's very volatile
19:06:39 <Ralith> what's the simplest way to find out what's consuming memory within a program?
19:06:40 <mmorrow> code for ghc-X.Y.0 probably will break with ghc-X.Y.1
19:07:06 <mmorrow> so i guess in that sense it may not be "ready", but the alternative is having nothing, so ..
19:08:06 <thomastc> mmorrow: hmm, then maybe it's not a good idea to base new EclipseFP code on it, until it's refactored
19:08:17 <newsham> ralith: the real world haskell book has a profiling chapter that discusses using the profiler to determine which parts are using memory and the gc
19:08:19 <mmorrow> thomastc: some papers here may be of interest http://www.haskell.org/~simonmar/bib/bib.html
19:08:23 <thomastc> which was a 2008 GSoC project, but I can't figure out whether it actually happened
19:08:30 <Ralith> kk
19:08:50 <wli> Nice, all I had to do was make it forever repl and I could nuke the explicit recursion
19:09:41 <wli> That is, with MonadCont providing loopbreaks.
19:10:04 <mmorrow> thomastc: i think though there's no real alternative to get the services it provides though. one solution (which (old) yi used and i think is decent) is to provide an interface to the ghc-api's functionality, and have you app use that. then breaking changes will only effect the implem code for your interface module
19:10:47 * mmorrow tries to find the old yi's code
19:10:52 <thomastc> in EclipseFP that would be needed anyway, since the rest of it is Java...
19:11:22 <mmorrow> thomastc: oh, hmm. i'm not sure. what exactly is the goal of EclipseFP?
19:12:13 <thomastc> Haskell support in Eclipse (formerly OCaml too)
19:13:01 <mmorrow> thomastc: this code (which afaik is broken with current ghc-api) was written particularly with ide support in mind http://code.haskell.org/shim/
19:13:56 <zeno> 5 has kind *, (+5) * -> *, and (+) * -> * -> * right?
19:13:58 <mmorrow> thomastc: hmm, well i suppose whether you'll need/want to use the ghc-api depends on whether you want to load/typecheck/etc haskell code _w/in the ide's address space_ or not
19:14:32 <mmorrow> (and also you'll need to use haskell to access the ghc-api (unless you code a wrapper or something))
19:15:06 <thomastc> yes, I know that I need to use Haskell
19:15:15 <thomastc> but what would be the alternative to using the GHC API?
19:15:33 <kadaver> p_l: why is "what year pc hardware does iphone and android compare to?" a stupid question? im just wondering about a rough estimate
19:15:36 <mmorrow> thomastc: ah, this is an _active_ ide support project: http://github.com/nominolo/scion/tree/master
19:16:08 <p_l> kadaver: Well, in terms of processing power, it might have some sense. But it's a very different kind of platform, IMHO
19:16:11 <mmorrow> (and here, but not sure if this page is active anymore http://code.google.com/p/scion-lib/)
19:16:17 <thomastc> ah, right! so something _did_ come out of that GSoC project last year :)
19:16:25 <mmorrow> heh
19:16:36 <ddarius> zeno: None of those have kinds.
19:16:44 <ddarius> zeno: Types have kinds.  Values have types.
19:17:21 <zeno> ddarius: ok, so Int has kind *, Int -> Int: * > *, etc right
19:17:22 <mmorrow> thomastc: the only alternative to using the ghc-api that i can think of would be to write your own parser/typechecker/etc (which isn't very practical unfortunately)
19:17:34 <mmorrow> (or of course to use something like scion that wraps it for you)
19:18:23 <mmorrow> thomastc: you probably want to ask nominolo about scion
19:18:28 <mmorrow> @seen nominolo
19:18:28 <lambdabot> I saw nominolo leaving #haskell-soc, #yi, #ghc and #haskell 4h 37m 45s ago, and .
19:18:32 <thomastc> well, scion was written with exactly this in mind
19:18:37 <mmorrow> totally
19:19:39 <thomastc> and I like that it seems to have a client/server architecture. interfacing between haskell and java would be... hairy... at best
19:20:09 <mmorrow> heh, yeah at best
19:20:47 <thomastc> would rpobably need a C intermediate thingy
19:20:53 <mmorrow> you'd probably need to do (haskell <--ffi--> C <--whatever--> Java)
19:20:56 <mmorrow> exactly
19:21:42 <ddarius> zeno: Those all have kind *.
19:22:28 <ddarius> zeno: Read "*" as "Type".  Int is a Type, Int -> Int is a Type.  Maybe is a type constructor, i.e. a type level function from Type to Type.
19:22:29 <ddarius> :k Maybe
19:22:32 <lambdabot> * -> *
19:22:48 <mmorrow> thomastc: this might be interesting at the idea-level http://www.haskell.org/~simonmar/papers/vshaskell.pdf
19:23:04 <mmorrow> maybe this too http://www.haskell.org/~simonmar/papers/ghci-debug.pdf
19:23:13 <wli> mmorrow: I'm farting around more with infix ops declared at the repl and data types declared at the repl for the moment.
19:23:29 <mmorrow> wli: ooh, very cool.
19:23:56 <mmorrow> wli: what are you doing with them?
19:24:20 <thomastc> mmorrow: got those, thanks
19:24:34 <mmorrow> thomastc: the haddock one is good too
19:24:43 <wli> mmorrow: Building up ways to abbreviate AST's so I can actually do something meaningful with testcases.
19:25:05 <mmorrow> how do you mean "abbreviate"?
19:25:22 <mmorrow> (as in represent?)
19:25:38 <wli> mmorrow: Parsed syntax vs. Read/Show directly on the data decl.
19:26:00 <mmorrow> ahh, i see. so like prettyprinting-ish
19:26:52 <wli> It's more like just a parser vs. prettyprinting, but otherwise a more elaborate framework surrounding it all.
19:27:34 <mmorrow> nice, yeah i've been thinking about ways to structure a repl-interface too recently
19:27:53 <adimit> hmm... I can't seem to find any good examples on disconnecting events in gtk2hs. Basically, one has to keep a global state around where the connectId is stored. How do I best go about adding global state to a gui App? IORed?
19:27:56 <mmorrow> (not too hard yet though..)
19:28:05 <adimit> *IORef? (Thanks very much for any help)
19:29:44 <mmorrow> if it's single-threaded, you can use a top-level unsafePerformIO'ed IORef
19:29:50 <mmorrow> but i'd do that cautiously
19:30:07 <mmorrow> you could also use a State or a Reader monad
19:30:08 <thomastc> does anyone here know who are actual GSoC mentors for the Haskell project?
19:30:34 <mmorrow> adimit: (also, you can s/IORef/MVar/ if you need sync)
19:30:36 <thomastc> and to whom I should talk about this eclipsefp stuf, specifically
19:30:50 <mmorrow> thomastc: i'd talk to nominolo for sure
19:31:00 <mmorrow> he could probably answer that question
19:31:50 <thomastc> I'll just send him an e-mail then
19:32:30 <adimit> mmorrow: well, basically, I have to register an event with a component when a file is loaded, and then I have to change that event when a new file is loaded, so I don't really care about sync. Why would I have to unsafeperformIO the IORef? I'm not really good at that, it's at the very edge of my abilities...
19:32:37 <adimit> (currently.. :-)
19:33:06 <mmorrow> adimit: you only would need to use unsafePerformIO if you want the IORef to be _at the top-level_ in the module
19:33:35 <mmorrow> if not, then you could just use use an IORef normally
19:33:42 <seydar> pumpkin_: oj oj oj
19:34:45 <mmorrow> data SomeStateForSomething = SSFS { ...., evQ :: Chan Ev, ... } might be nice
19:35:08 <seydar> DOTA!
19:35:20 <seydar> does the guy who wrote "learn you a haskell" troll around here?
19:35:43 <mmorrow> (or s/Chan Ev/IORef [Ev]/ (or something) if you're singly threaded and plan to always be)
19:36:01 <adimit> mmorrow: ok, thanks. I'll try to avoid putting it at the top level then.
19:36:04 <mmorrow> (err, but a list is a poor substitute to a Q)
19:37:00 <mmorrow> seydar: BONUS
19:37:03 <mmorrow> @seen BONUS
19:37:04 <lambdabot> BONUS is in #haskell. I last heard BONUS speak 8h 56s ago.
19:37:29 <seydar> BONUS: pingaling!
19:37:44 <seydar> is it possible to send 10MB pings?
19:38:40 <p_l> seydar: not with IPv4
19:38:46 <seydar> but with IPv6?
19:38:54 <seydar> it'd be so sweet to do that
19:38:56 <p_l> seydar: it might be possible
19:39:09 <p_l> but afaik the network is not required to pass them :)
19:39:19 <seydar> it totally should
19:39:31 <seydar> so is there some doped up tutorial on monads out there?
19:39:50 <BMeph> seydar, naugh, that wouldn't be a good idea.
19:40:06 <seydar> monads +methamphetamines turns up like 570 results
19:40:35 <BMeph> seydar: Assuming, you find BONUS' creation to be...lacking? ;p
19:40:46 <seydar> oh gods no
19:40:53 <seydar> i'm just waiting for him to explain monads
19:41:30 <seydar> that dudezor could get me arrested for possession of drugs if i were to even carry a printout around
19:46:14 <FunctorSalad> seydar: http://www.google.com/search?q=monads%20LSD%20OR%20psilocybin
19:46:20 <FunctorSalad> 4620 :D
19:46:32 <mmorrow> adimit: ah, i missed your description of what you're doing exactly. you probably just could stick an IORef into the state of each of those particular components, then keep a [IORef Info] around to notify each component when the file(s) are loaded
19:46:55 <monochrom> Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing is not fixed.
19:47:49 <mmorrow> adimit: (or just a [ThatComponent], where data ThatComponent = TC {..., loadedInfo :: IORef (Maybe Info), .. } or something
19:48:19 <mmorrow> monochrom: heh
19:48:37 <mmorrow> @remember monochrom Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing is not fixed.
19:48:37 <lambdabot> Done.
19:50:30 <adimit> mmorrow: I was going in that general direction, but I'm currently trying to solve it with a Reader monad. It strikes me as the cleaner solution. My problem here specifically is the 'keeping around part.' I only get the handle on the data (ConnectId) quite deep into the initialization of the gui, and I wouldn't know where exactly to keep it around.
19:50:46 <adimit> of course, it might just be the fact that it's 4 a.m. and I should go to bed.
19:51:21 <seydar> adimit: don't be crazy, it's 11
19:51:29 <mmorrow> adimit: yeah, everything is simple modulo those pesky "design decisions" ;)
19:52:11 <adimit> mmorrow: exactly. I'll see if I can come up with something that makes at least a little sense, and then post to haskell-beginners to see what those guys have to offer.
19:52:14 <mmorrow> adimit: (you probably would need a State monad, unless you have something(s) mutable in the Reader's env)
19:52:24 <mmorrow> adimit: good luck :)
19:52:32 <adimit> mmorrow: good, state monad then. Thanks for the warning.
19:52:36 <mmorrow> np
19:53:17 <adimit> I think the gtk2hs guys really need to document that (and in case I find a workable solution, I'll submit that) There's not a single example of code on the net that actually *uses* the disconnect function.
19:53:31 <adimit> (in a non-trivial way, i.e. not one line after the other)
19:53:55 <wli> mmorrow: I'm starting over again with primops so I can have parsing through preprocessing through execution end-to-end.
19:54:30 <wli> That is, as I extend things.
19:54:59 <seydar> is there a nice lil' function for *effectively* update an element in a list?
19:55:02 <FunctorSalad> I'm using a ReaderT IO containing IORefs in my OpenGL thing now, since everything is IO in OpenGL anyway... would it be better for performance to switch to StateT as much as possible?
19:55:06 <seydar> updating*
19:55:17 <FunctorSalad> (because GHC could optimize)
19:56:07 <wli> mmorrow: My variable elimination stuff was premature, since nontrivial SCC's can only arise via let bindings and within the bound vars of a let binding.
19:56:10 <jedai> seydar: You can't modify value in Haskell, they're immutable
19:56:37 <jedai> seydar: of course you could write a function that takes a list and returns a modified version of the list
19:57:04 <seydar> jedai: yea, that's what i meant by effectively updates
19:57:10 <seydar> none already made?
19:57:14 <seydar> time to roll up dem sleeves
19:57:15 <jedai> seydar: It's not really a need that arise frequently but that's quite easy to write
19:58:13 <jedai> if you want to modify an element by index, use splitAt
19:58:45 <wli> mmorrow: I probably also want to hash cons edges, so expression nodes only refer directly to indices of edge structures in an IntMap and the contents of the edges in the IntMap describe source and destination nodes and additional info, e.g. strictness -related info at later times.
19:58:51 <jedai> or eventually use a manual recursion
19:59:27 <newsham> > let repl n y xs = let (hd,(x:tl)) = splitAt n xs in hd ++ y:tl in repl 5 3 [10,11,12,13,14,15]
19:59:30 <lambdabot>   [10,11,12,13,14,3]
19:59:46 <newsham> > let repl n y xs = let (hd,(x:tl)) = splitAt n xs in hd ++ y:tl in repl  3 5 [10,11,12,13,14,15]
19:59:47 <lambdabot>   [10,11,12,5,14,15]
19:59:56 <newsham> hmm, not quite.
20:00:04 <newsham> err.. i guess thats what i meant
20:00:24 <dolio> > let repl n y xs = let (hd,(x:tl)) = splitAt n xs in hd ++ y:tl in repl 18 5 [10..15]
20:00:26 <lambdabot>   * Exception: /tmp/4744515420802511393:71:82-107: Irrefutable pattern failed...
20:00:32 <newsham> the other case for splitAt pattern matching should be sent to error
20:00:43 <newsham> with case stmt
20:00:53 <newsham> or use Maybe type
20:00:55 <jedai> let modifyIndex n f xs = case splitAt n xs of { (beg, e:end) -> beg ++ (f e : end); (_,[]) -> xs } in modifyIndex 5 (+1) [1..10]
20:01:01 <jedai> > let modifyIndex n f xs = case splitAt n xs of { (beg, e:end) -> beg ++ (f e : end); (_,[]) -> xs } in modifyIndex 5 (+1) [1..10]
20:01:02 <lambdabot>   [1,2,3,4,5,7,7,8,9,10]
20:02:11 <kadaver> how is haskell for realtimr stuff like robotics?
20:02:40 <jedai> Still consider the possibility that you may not really need it (every time I thought I did, I turned out wrong)
20:03:05 <newsham> if you really need it you might really want an array
20:03:09 <jedai> kadaver: Not so good (being a language with a GC not especially studied for realtime)
20:03:28 <jedai> newsham: Right :)
20:03:37 <seydar> jedai: can you correct this? make it more haskelly? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2841#a2841
20:03:40 <jedai> kadaver: Soft realtime eventually
20:04:00 <kadaver> is the garbagecollector reliable?
20:04:15 <kadaver> jedai: python is jsut a fair amount in robotics
20:04:22 <kadaver> jsut->used
20:04:49 <kadaver> not sure but perhaps python only uses referencecounting and thus is more reliable?
20:05:03 <jedai> kadaver: Wherever Python can be used, Haskell can probably be used
20:05:29 <wli> refcounting sucks; cascading refcounts kill it
20:05:45 <newsham> python has a lot of platform support.
20:06:17 <jedai> kadaver: as I said soft realtime can be achievable but not hard realtime, I would be pretty surprised that Python be used for hard realtime (and would avoid any company or hardware that would try)
20:07:44 <zeno> why is this type signature illegal?  (RandomGen g) => g -> [a] -> (a, g)? its for pickRandom g l = first (l !!) $ randomR (0, length l) g
20:07:46 <gwern> @src until
20:07:46 <lambdabot> until p f x | p x       = x
20:07:47 <lambdabot>             | otherwise = until p f (f x)
20:08:33 <seydar> how do i straight up exit from a haskell program, no questions asked?
20:08:44 <wli> Basically when data structures have high fanout you can have a zillion refcounts to decrement when an object's refcount hits 0; if you try to do it incrementally, then you can have a dead object kept alive only by not-yet-cascaded refcounts... then each of the structures it points to (try a B+ tree or hash trie) can have its refcount hit zero with its own large fanout. So you either get a huge refcount-zeroing frenzy on the order of a GC pause or mountains
20:09:12 <zeno> seydar: head [] will do that, just gives a statement no questions :)
20:09:28 <blackh> seydar: See System.Exit module
20:10:11 <seydar> blackh: is there a version i can use anywhere, regardless of type?
20:10:12 <wli> There are much more intelligent GC algorithms.
20:10:17 <jedai> seydar: To "exit" from a pure function, you may use error "Exiting for whatever reason"
20:10:39 <blackh> seydar: If you want to exit from pure code, throw an exception and catch it at the IO level.
20:10:39 <seydar> sweetsauce with a hint of lemon!
20:10:39 <wli> MonadCont
20:10:47 <jedai> seydar: though that may be caught by an exception handler
20:11:31 <blackh> seydar: Have a look at Control.Exception.Extensible.throw
20:12:00 <wli> What you want is a GC algorithm that doesn't have to wander through mountains of garbage. I'm big on treadmills.
20:12:19 <seydar> ok. bedtime for bonzo
20:12:24 <seydar> thank you everybody!
20:13:10 <gwern> 'sqrt orig limt = until (\x -> abs (x^2 - orig) <= limt) (\x -> (x + (orig / x)) / 2) 1.0'
20:13:13 <gwern> nice
20:13:49 <gwern> the original was like 13 lines of scheme, or 8 with reformatting and some inlining
20:13:57 <JuniperJaxx> hey everyone
20:13:58 <JuniperJaxx> :)(
20:14:00 <gwern> it's really nice how the libraries have all the usual recursion schemes
20:14:00 <JuniperJaxx> :) *
20:14:18 <gwern> > let sqrt' orig limt = until (\x -> abs (x^2 - orig) <= limt) (\x -> (x + (orig / x)) / 2) 1.0 in sqrt' 25 0.1
20:14:19 <lambdabot>   5.000023178253949
20:14:32 <gwern> > let sqrt' orig limt = until (\x -> abs (x^2 - orig) <= limt) (\x -> (x + (orig / x)) / 2) 1.0 in sqrt' 25 0.0001
20:14:34 <lambdabot>   5.000000000053722
20:14:51 <fynn> what do you guys think of the new logo?  http://www.haskell.org/logos/logos/logo7000.png
20:15:11 <gwern> like it well enough
20:15:21 <gwern> or I did till it molested my dog
20:15:31 <JuniperJaxx> lol
20:15:53 <Zao> Looks like a mix between a public transportation logo and Commodore.
20:15:59 <JuniperJaxx> haa
20:16:02 <JuniperJaxx> haha*
20:16:07 <Zao> The vote is over already?
20:16:11 <gwern> > let sqrt' orig limt = until (\x -> abs (x^2 - orig) <= limt) (\x -> (x + (orig / x)) / 2) 1 in sqrt' 25 0.0001
20:16:13 <lambdabot>   5.000000000053722
20:16:16 <fynn> Zao: seems so
20:16:19 <gwern> Zao: well how long did you want us to dogshed it?
20:16:46 <fynn> I wish it was less zesty
20:16:50 <Zao> I hadn't gotten around voting yet :(
20:17:01 <Zao> I would have expected at least a month or so :)
20:17:12 <Zao> Oh well, it could've been worse.
20:17:13 <fynn> like, more of a reserved and feminine lambda shape.
20:17:13 <gwern> a month? yeesh
20:17:24 <gwern> fynn: too reserved!
20:17:34 <Zao> gwern: Haskell makes people too effective .
20:17:37 <gwern> @vixen isn't it too repressed for you, my minx?
20:17:37 <lambdabot> let's don't talk about that
20:17:58 <fynn> gwern: (I didn't get the dog molestation joke)
20:18:19 <jedai> The new logo is pretty nice, I hope we can get variation with different mood (more rounded, warm colors, ...)
20:18:56 <Zao> How well does it do with transparency and inversion?
20:18:56 <jedai> It was my favorite though so I guess I can't very well complain ^^
20:20:16 <gwern> now we need a yi logo updated to match the new haskell one
20:20:27 <gwern> Zao: I think it'd do well with transparency. dunno inversion
20:23:41 <kadaver> so for realtime C and/or C++ is used? ugh
20:23:50 <Ralith> aw, they didn't pick my favorite :(
20:41:24 * wli tries to smoke out how to specify that one type has another's constructors and possibly extends various of those constructors with new fields.
20:42:18 <zok> Hi, When I install cabal-install, there is an error : Could not find module `Codec.Compression.GZip'
20:42:51 <zok> but it says zlib is already installed
20:43:18 <wli> data Foo shares Bar, Snoo with Blort and extends Gronk with Snark?
20:43:47 * edwardk calls the paramedics, wli has finally flipped out
20:45:40 <Kydoc> newbie question about a simple text processing task : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2842#a2842
20:46:01 <Kydoc> anything grossly inefficient, or is that about what I should expect without destructive updates?
20:49:55 <gwern> 'WITHOUT SCHEME ALL COMPUTER SCIENCE IS MEANINGLESS.' 'You mean WITHOUT SCHEMA ALL COMPUTER SCIENCE IS UNDEFINED.'
20:51:51 <gwern> 'But programming now isn’t so much like that, said Sussman. Nowadays you muck around with incomprehensible or nonexistent man pages for software you don’t know who wrote. You have to do basic science on your libraries to see how they work, trying out different inputs and seeing how the code reacts. This is a fundamentally different job, and it needed a different course.'
20:51:57 <gwern> 'And why Python, then? Well, said Sussman, it probably just had a library already implemented for the robotics interface, that was all.'
20:52:00 <gwern> ouch
20:52:18 <fynn> hehe, everyone's quoting that
20:52:30 <fynn> but I do think Sussman is sort of evading ;)
20:52:47 <gwern> (I suddenly feel an urge to find out what robotics interface that is and write a haskell binding)
20:52:57 <fynn> somehow one can't quite see 6.001 switching to, say, Java or C#
20:52:59 <idnar> sounds like he has a point :P
20:53:22 <gwern> fynn: it's worth quoting. sussman is very good; SICP alone proves that
20:53:45 <fynn> gwern: yeah, it's a nice quote. my point is that it's inaccurate, too ;)
20:54:18 <fynn> I'm sure there are many other languages out there (probably at least Java and C++) that have an interface to that "robotics" thing, whatever it is.
20:55:10 <gwern> well, c++ is not really an intro language
20:55:22 <gwern> (at least, I truly pity those poor souls for whom it is)
20:55:38 <fynn> C++ is completely unlike Scheme, as is Java, as is Pascal
20:55:45 <dolio> My high school's programming course was taught in C++.
20:55:46 <fynn> ...but not Python :)
20:56:04 <dolio> Probably because that's what was on the AP test at the time.
20:56:36 <kmeyer> gwern: not that 6.001 was much of an intro course
20:56:45 <fynn> kmeyer: in MIT, it is...
20:56:59 <fynn> it's the main introductory programming course.
20:57:02 <kmeyer> eh, not anymore
20:57:08 <kmeyer> they thought it was too hard, got rid of it
20:57:12 <kmeyer> now it's 6.01
20:57:14 <gwern> in normal colleges, you learn courses; in MIT, courses learn you!
20:57:22 <futurestack> are other languages harder / easier as an intro language?  or does c++ as an intro language ingrain poor / unnecessary coding idioms / principles?
20:57:34 <fynn> gwern: please explain that dog joke, I fear I may die without knowing
20:57:35 <futurestack> sorry for all the switches
20:57:47 <gwern> fynn: if you don't get it by now, you never will
20:57:49 <fynn> futurestack: C++ is a terrible language to learn and use.
20:58:08 <fynn> it has a huge amount of syntax and features to learn.
20:58:16 <futurestack> fynn:  I agree.  and yet it has taught me much about computers that I wouldn't have learned otherwise
20:58:45 <futurestack> I'm in here because I'm intrigued by a world that claims to be free of the horrendousness of the c++ labor camps
20:58:49 <fynn> and then, after you learn them, there's a ton more special cases and exceptions and edge cases and gotachas to learn about anything you learned in the first stage.
20:59:01 <gwern> futurestack: c++ has all the difficulties of c's lowlevel nature with say pointer manipulation, all its inconsistencies and faults, and piles on issues all its own; it's hard enough to learn well even if you already know programming, so it's cruel and unusual punishment to make a normal freshman learn c++ AND programming simulatenously
20:59:06 <Pseudonym> Programming in C++ is terrible.  You have to _know_ stuff!
20:59:09 <fynn> it's like a pyramid standing on its head.
20:59:18 <futurestack> heh
20:59:34 <fynn> Pseudonym: yeah, more stuff than you'd need to know in most other languages...
20:59:41 <futurestack> so haskell is worlds beyond worlds better
20:59:51 <fynn> futurestack: most C++ programmers don't really know C++.
20:59:52 <Pseudonym> Less than in Java, I suspect.
21:00:01 <futurestack> ah
21:00:02 <fynn> Pseudonym: uhm, no? :)
21:00:05 <futurestack> that may explain it
21:00:05 <gwern> well, that may be a little excessive an econium
21:00:09 <kmeyer> java is C++ without the corners
21:00:13 <gwern> *enconium
21:00:48 <Pseudonym> fynn: By "Java" I mean the whole platform, not just the language.
21:01:09 <Pseudonym> Because you need to know the platform to program in Java.
21:01:22 <futurestack> I was well aware that programmers who use "higher level" languages scorn c++ and from what I can tell, for good reason.  but I was curious if there was some deeper reason beyond "it's a huge pain in the ass"
21:01:31 <fynn> futurestack: most C++ programmers I've met either use it as C with a few extra features, or cower behind massive opaque IDEs that hide all the complexity from them.
21:01:45 <Pseudonym> futurestack: Of cours there's a deeper reason.  99.9% of them have never used C++ for anything serious.
21:02:14 <futurestack> Pseudonym:  please continue assuming that I'm an idiot and define "serious" :)
21:02:25 <futurestack> fynn:  like xcode?
21:02:27 <fynn> Pseudonym: what do you mean with "knowing the platform"?  knowing all the implementation details of the JVM?
21:02:29 <Pseudonym> futurestack: Anything over a million lines long is "serious".
21:02:35 <Pseudonym> fynn: No, I mean J2EE.
21:02:39 <futurestack> really?   interesting
21:03:04 <futurestack> i figured codebases of that size were one of the primary attractions of C++ over C
21:03:25 <fynn> Pseudonym: not that J2EE is simple or anything, but is it really comparable?
21:03:43 <Pseudonym> fynn: As far as amount of stuff you need to know to get anything does is concerned, yes.
21:03:55 <gwern> > let cbrt n lmt = until (\x -> abs (x^3 - n) <= lmt) (\x -> (n/x^2 + 2*x) / 3) 1 in cbrt 9 0.00001
21:03:56 <fynn> futurestack: more like visual studio :)
21:03:56 <lambdabot>   2.0800838232385224
21:03:57 <Pseudonym> It's different, that's for sure.
21:04:11 <futurestack> ic
21:04:11 <gwern> > let cbrt n lmt = until (\x -> abs (x^3 - n) <= lmt) (\x -> ((n/x^2) + 2*x) / 3) 1 in cbrt 9 0.00001
21:04:12 <lambdabot>   2.0800838232385224
21:04:15 <fynn> Pseudonym: hm, you can do Java without using J2EE
21:04:25 <fynn> in any case, I don't care to praise Java.
21:04:27 <Pseudonym> fynn: Yes, but then you're just using an inferior programming language.
21:04:28 <gwern> > let cbrt n lmt = until (\x -> abs (x^3 - n) <= lmt) (\x -> ((n/x^2) + 2*x) / 3) 1 in cbrt 9 0.000000001
21:04:29 <lambdabot>   2.080083823051904
21:04:35 <Pseudonym> Java programmers use it despite the language, not because of it.
21:04:47 <gwern> > let cbrt n lmt = until (\x -> abs (x^3 - n) <= lmt) (\x -> ((n/x^2) + 2*x) / 3) 1 in cbrt 27 0.000000001
21:04:48 <lambdabot>   3.0000000000000977
21:04:58 <Pseudonym> Most people who praise Java don't praise the language, they praise the platform.
21:05:44 <Pseudonym> futurestack: I think you might have misunderstood what I meant earlier.
21:05:56 <futurestack> fynn: so let me ask one more question here.  how does an IDE 'hide' the complexity of the language from the user?  I've used xcode some and it's basically a frontend for gcc, all it can do is parrot error messages
21:06:07 <Pseudonym> I mean that 99.9% of programmers who knock C++ have never used C++ for anything serious.
21:06:09 <futurestack> Pseudonym: which part?
21:06:12 <futurestack> ah
21:06:16 <gwern> is Double like Integer ie. arbitrary precision?
21:06:19 <Pseudonym> I know this, because I used to do it.
21:06:40 * bos wonders what something serious is
21:06:50 <gwern> futurestack: the more an IDE can do for you, the more it says that the language is weak because it can't handle it itself
21:07:00 * wli has never used C++ for anything serious, but still thinks his negative opinion of C++ is valid.
21:07:27 <Pseudonym> bos: I mentioned that anything over a million lines is "serious", but obviously that's sufficient but not necessary.
21:07:29 <gwern> futurestack: although the line between very-smart-helpful-IDE and IDE-making-up-for-language-flaws is not always obvious, consider the legendary IDEs for smalltalk or some of the lisp ones
21:07:59 <bos> Pseudonym: i might have guessed you meant performing unspeakable acts with the STL or writing massive flotillas of templates
21:08:06 <wli> In my case, I leverage my use of C, and note the extensions provided by C++ wouldn't help.
21:08:37 <wli> Or to the extent they would help, they're awkward and inadequate.
21:08:38 <Pseudonym> bos: A lot of the template flotillas aren't "serious", they're downright frivolous.
21:09:03 <futurestack> gwern:  I think I see what you mean.
21:09:07 <Pseudonym> I'm not claiming that C++ is a good fit with many problems.  I'm merely saying that most of the criticism is mistargeted.
21:09:35 <aLegendaryPengui> C++ is weak
21:10:28 <wli> It raises some very serious problems. One is that the sorts of semantics it's building on top of are very low-level, and its extensions interfere with what that's useful for.
21:11:08 <fynn> futurestack: right, it doesn't really do much. what it does do is let you build - by point an click - something that uses C++, and is relatively bug-free.
21:11:13 <gwern> whew, now chapter 1 of SICP is well and truly finished; I daffest way too long on that newton's method section
21:11:21 <gwern> but the `until` one liner proved to be quite satisfying
21:11:36 <fynn> futurestack: so you get Python's level of optimization, and C++ level of readability.
21:11:38 <gwern> I wonder why none of my web searches turned up a newton's method implementation using until?
21:11:40 <wli> Another is that it left modularity only very inadequately addressed via namespaces.
21:11:49 <gwern> eeryone seems to use iterate or primitive recursion
21:12:12 <fynn> gwern: hm?  what are you talking about?  you're reading SICP right now?
21:12:24 <fynn> are you writing the examples in Haskell or something?
21:12:24 <wli> And frankly the modularity issue is an overt crisis in C/C++ programs of any size.
21:12:24 <adimit> @seen mmorrow
21:12:25 <lambdabot> I saw mmorrow leaving #yi, #ghc and #haskell 53m 13s ago, and .
21:12:29 <aLegendaryPengui> SICP is too old school imo
21:12:41 <gwern> fynn: yes, I've been doing them in both scheme and haskell more or less
21:12:46 <gwern> (slow way to do things)
21:12:57 <futurestack> fynn:  I haven't had that issue I suppose, or maybe I'm ignorant of it because my ide *is* hiding it from me
21:12:58 <gwern> aLegendaryPengui: old school? and what's wired, then?
21:13:01 <fynn> gwern: is there a transcription of SICP to Haskell
21:13:13 <futurestack> but when I fuck up, I'm generally informed in no uncertain terms by gcc how I did it
21:13:18 <gwern> fynn: there's a partial transcription up to chapter 4, I think. I've been avoiding it
21:13:29 <aLegendaryPengui> I read SICP before, i just thought some of the sections were dated
21:13:31 <fynn> futurestack: from what you describe, xcode isn't as immersive as visual studio
21:13:46 <Pseudonym> Grrrr.  There is no such thing as "C/C++".
21:13:49 <aLegendaryPengui> the lectures are pretty funny though
21:13:53 <aLegendaryPengui> they are all online
21:14:00 <fynn> in visual studio, you can build a simple gui app (say, a form-feeder) in C++ knowing hardly any C++.
21:14:02 <gwern> yes, I've been watching them too
21:14:12 <gwern> I've not been hugely impressed, but it's early chapters yet
21:14:15 <wli> A fair amount of the modularity crisis is the handwritten module interface files and the very serious problems arising from skew between the header declarations and actual definitions.
21:14:16 <fynn> gwern: url for that?
21:14:18 <aLegendaryPengui> its mostly a really good book, i didnt like the circuitry part
21:14:26 <aLegendaryPengui> it was too hardware oriented
21:14:47 <futurestack> fynn:  interesting.   I'll have to give it a shot and see how it conceals errors from the user :?
21:14:50 <gwern> fynn: for what?
21:15:04 <futurestack> thanks for your time guys
21:15:08 <wli> Another is that you get really bad header interdependencies that are completely an artifact of the preprocessing and singlepass garbage going on with C and C++.
21:15:09 <aLegendaryPengui> they really like to compute PI in SICP btw
21:15:17 <fynn> gwern: found it - http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
21:15:47 <aLegendaryPengui> why not just read a good haskell book, or arent there any
21:16:10 <fynn> SICP is pretty awesome
21:16:20 <wli> Pseudonym: C/C++ is valid here in particular because C++ shares all the issues I'm describing with C; in fact, I'm going on about deficiencies in C that C++ as an extension of C left unaddressed.
21:16:20 <fynn> I don't understand how you're saying it's "old school"
21:16:21 <gwern> because I'm bored with RWH, and I didn't feel like doign school of expression or okasaki
21:16:43 <kadaver> could you have HOF without GC? could HOF be added to C? i mean you have function pointers already but proper higher-order-functions
21:16:50 <fynn> most of the stuff there is fundamental programming tasks that would never get old.
21:16:53 <gwern> which were my options, basically. besides, I've been meaning to do SICP/learn scheme for many more years than I have been meaning any of the other 3 :)
21:17:11 <wli> gwern: Come up with some projects that take some work for you to do, and write about them as you do them.
21:17:40 <gwern> kadaver: from the papers I read on trying to add tail recursion to gcc, I think there are things in c besides no gc that prevent proper closures, which are needed for real HOF
21:17:55 <gwern> (but I'll admit I'm not at all sure about that)
21:18:05 <gwern> wli: oh, I do do that sometimes
21:18:20 <wli> gwern: Lack of nested functions with lexical scope.
21:18:38 <gwern> but I don't like creating new things, I'd rather work on someone else's stuff; more efficient. NIH is the syndrome I dread the most
21:18:51 <aLegendaryPengui> NIH?
21:18:59 <Pseudonym> Oh, wli, I've managed to get most of the cruft out of the output from the Tarski algebra solver.
21:19:06 <Pseudonym> *TarskiAlgebra> putStrLn . prettyPrint $ f2
21:19:06 <wli> gwern: I could suggest some projects for you. ;)
21:19:06 <Pseudonym> exists x. c + b * x + a * x * x = 0
21:19:06 <Pseudonym> *TarskiAlgebra> putStrLn . prettyPrint . simplifyFormula . eliminateQuantifiers $ f2
21:19:06 <Pseudonym> a = 0 && b = 0 && c = 0 || (a = 0 || ~ (0 > b * b + (-4) * a * c)) && (~ (a = 0) || ~ (b = 0))
21:19:16 <wli> Pseudonym: Fantastic!
21:19:29 <gwern> aLegendaryPengui: not invented here. google it
21:19:31 <wli> Pseudonym: BTW what is f2?
21:19:40 <Pseudonym> f2 is just the test data.
21:19:49 <gwern> wli: I doubt you have any useful projects of just the right size for a good little essay/blog post
21:19:53 <aLegendaryPengui> working on other peoples stuff, you realize how dumb other people are
21:19:55 <aLegendaryPengui> whats the point in that
21:20:40 <wli> gwern: My thoughts on projects are usually somewhat bigger than that.
21:21:14 <Saterus> wli: are you thinking more of SoC scale projects?
21:21:47 <zeno> is there a way to remove the monomorphism restriction?
21:22:00 <wli> Saterus: I think they're smaller than the typical SoC projects.
21:22:18 <dolio> {-# LANGUAGE NoMonomorphismRestriction #-}
21:22:40 <wli> Saterus: I think they're more open-ended even if they're less code.
21:23:11 <Saterus> wli: i'd be interested in hearing what you've been thinking of. i've been looking for something interesting to get involved in...
21:23:16 <zeno> dolio: ah thanks
21:23:40 <wli> Saterus: Well, there isn't necessarily any project associated with any of the things I go on about.
21:24:38 <Saterus> wli: that's kind of how you made it sound. it sounded more like you had ideas floating around in your head that you hadn't had time to put any serious effort into. (thats how i read it anyway)
21:24:56 <gwern> wli: a list might be interesting. I could always add it to my TODO
21:25:47 <wli> Saterus: One thing I've done a fair amount of thinking about is parsing with two emphases: strength in terms of the *grammar* (not language) and being oriented toward interactive input at a repl.
21:26:22 <gwern> 'night
21:27:08 <wli> Saterus: A few different things happen. First, there basically needs to be some sort of grammar specification as an object in its own right so that one can e.g. compare it against the BNF in some formal definition.
21:28:31 <harblcat> hi all! quick question: what is the difference between 'data' and 'newtype'?
21:28:38 <wli> Saterus: The second is that interactive use at a repl wants all sorts of strange things. For instance, it may want to dive into the parser state to get an idea of what set of tokens to use for tab completion.
21:29:49 <ddarius> harblcat: The Report has a great section on that.
21:29:52 <wli> Saterus: Another is that since they're entering things in one character at a time, you can't use any lookahead.
21:29:53 <enoksrd> harblcat: if you know C, the (bad?) analogy is data ~ struct, newtype ~ typedef
21:30:13 <ddarius> enoksrd: Indeed a bad analogy.
21:30:13 <koninkje> no, type ~ typedef
21:30:51 <wli> Saterus: Yet another is that there are a bunch of situations where the user will go back and alter input in the middle of the line -- or, worse yet, in the middle of multiline input if that's supported.
21:30:52 <Saterus> harblcat: http://www.haskell.org/haskellwiki/Newtype
21:31:15 <harblcat> ah, thanks!
21:31:33 <enoksrd> koninkje: oops, was thinking newtype was type
21:31:42 <wli> Saterus: Avoiding having to re-parse from scratch when users move the cursor around and start editing in the middle of everything comes up from that.
21:32:28 <koninkje> harblcat: from the high level, data defines an algebraic data type (think combo of structs and unions), whereas newtype uses the same underlying representation for a new, otherwise unrelated, type
21:32:55 <Saterus> wli: interesting. i feel like i don't know enough about how its traditionally done to carry on an intelligent conversation with you...it's interesting.....
21:33:30 <enoksrd> anybody have experience with getting source metadata working in leksah IDE?
21:34:32 <enoksrd> whenever i click "source" i get a "no infos" message
21:35:02 <wli> Saterus: The solutions for the last part start getting tricky. What you end up getting is reducing the input to a string of terminals and nonterminals where the nonterminals carry their parse trees around with them, and do reductions based on the gramar rules out in the middle of the string like a linear-bounded automaton would, except you don't need linear-bounded automata.
21:35:15 <enoksrd> but according to ~/.leksah/source_packages.txt it knows the correct paths to a bunch of sources
21:35:59 <wli> Saterus: What you can do is adjust the stock state machine parsing algorithms to handle encountering nonterminals right in their input, and it all goes through without a hitch.
21:37:12 <wli> Saterus: The outputs of the state machines need to be adjusted so they operate by side effect on the input string when performing derivations.
21:37:30 <Saterus> wli: so every terminal has an accompanying nonterminal carrying the extra information?
21:38:13 <wli> Saterus: So when you hit an edit-in-the-middle situation, you run through the productions to lift the edited region of text to the top-level input string, and so on.
21:38:27 <wli> Saterus: no, terminal nodes are always leaves in the parse tree
21:40:00 <wli> Saterus: There is still some work to do to see if one can salvage the parsing automaton's stack information vs. only preserving the derivations saved via side effects modifying the input string.
21:40:10 <Saterus> wli: i think my inexperience with how all this works with actual software is showing. i'm taking theoretical computer science now, but don't take compilers till the fall.
21:42:47 <wli> Saterus: Well, there's a fair amount of other stuff to do on the interactive parsing front beyond mere strength of grammars or handling these kind of user input issues. Basic handling for multiline commands is lacking, though it requires some parser feedback which doesn't delve very deeply into the parser's specifics.
21:43:38 <yaru1022> :info Array
21:43:50 <yaru1022> @info Array
21:43:50 <lambdabot> Array
21:44:00 <yaru1022> @kind Array
21:44:01 <lambdabot> * -> * -> *
21:44:05 <wli> Saterus: Basically it would be like entering a do { } block, and if you get a newline before seeing a closing brace, you count it as part of the same multiline command.
21:44:11 <yaru1022> @t fmap
21:44:11 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
21:44:48 <Saterus> wli: i thought thats how it worked. ghci does that, right?
21:45:37 <wli> Saterus: In essence, the newline only ends the command if the parser says that all brace/bracket -like syntactic constructs are closed. No, ghci does not do it now that I'm aware of.
21:46:51 <wli> Saterus: The next issue that instantly comes up once you have that is getting multiline commands to come back up in the history properly and how to get the readline-like affair to edit them.
21:47:03 <ilseman2> how do you ask lambdabot to point-freeify something?
21:47:52 <wli> Saterus: Properly means do not do what bash does. Bring them back up as multiple lines and have the user scroll up and down the lines brought up within the multiline command.
21:48:22 <Saterus> wli: ghci help says " :{\n ..lines.. \n:}\n       multiline command". i just tested it, it works, even if it is a bit picky...
21:48:33 <wli> Saterus: (bash alters the expression structure to cram it all onto one line so readline can handle it)
21:49:13 <Saterus> wli: thats what inf-haskell mode does in emacs. pulls up each line individually in the history. i see what you mean.
21:50:26 <wli> Saterus: zsh does multiline commands in the manner I'm on about. I've not seen inf-haskell mode.
21:50:46 <ilseman2> @pl  writeGraph g fp = writeFile fp $ graph2Dot g
21:50:46 <lambdabot> writeGraph = flip writeFile . graph2Dot
21:50:48 <Saterus> wli: it does exactly what you described bash doing.
21:50:49 <wli> Saterus: I had in mind within a tty/pty vs. a GUI app.
21:51:15 <Saterus> wli: yeah, i get that now.
21:51:19 <wli> Saterus: If you can grab zsh and see how it does multiline commands that ought to clarify things a bit.
21:51:40 <wli> for f in *
21:51:42 <wli> do
21:51:46 <wli> echo $f
21:51:47 <wli> done
21:52:08 <wli> That sequence of input lines in zsh will show a lot, esp. if you scroll back up to it and so on.
21:56:01 <wli> It even adjusts the prompt to show which specific nested constructs it's expecting you to complete in order to terminate the command.
21:56:25 <Saterus> wli: ah, i see what you mean. its much smarter than the ghci one. yeah, that is nice.
21:57:59 <wli> Saterus: The basic idea is to get bits (or all) zsh's command-line editing smarts into some Haskell interactive input lib, and maybe even go beyond.
21:59:04 <wli> Saterus: zsh's code is horrible and extremely ad hoc, so I wouldn't even look at its implementation, just its featureset.
21:59:33 <Saterus> wli: good example. now i understand what you are proposing.
22:01:14 <wli> It's pretty open-ended. I did a lot of thought about what a parser would have to function intelligently with zsh-style editing. The line input and output mechanics are also things that want/need work.
22:01:46 <wli> Saterus: Given how many interpreters people write, this sort of thing could get into widespread use.
22:01:57 <Saterus> wli: it seems like a worthwhile thing to do as well. it'd make experimenting with input a lot easier. yeah, exactly.
22:03:57 <Eridius> huh, interesting logo choice
22:04:06 * Eridius didn't vote, didn't even look at 99% of the logos. but still, it just seems a little... commercial
22:04:20 <Eridius> as the top reddit comment put, "I would definitely fly on that airline"
22:05:32 <Gracenotes> we just need some good colors
22:06:34 <Eridius> I rather liked #2
22:06:45 <Saterus> wli: very interesting idea. i like it. i'll have to think about it more.
22:06:57 <FunctorSalad> it would be cool if there was a systematic typelevel distinction between points and differences of points (e.g. date vs. duration, size vs. scaling factor, point vs. translation, ...)
22:07:29 <idnar> ooh, that's the logo I ranked first
22:08:12 <conal> FunctorSalad: there's Data.AffineSpace in vector-space
22:08:17 <Eridius> I think someone suggested the other day that maybe we should have two logos, one for informal community use and one for the more commercial world
22:08:25 <Eridius> I think the #1 logo fits that second use well
22:08:32 <FunctorSalad> conal: yep, it should be used more widely :)
22:09:32 <Gracenotes> again, #1, colors. hm.. .any ideas?
22:09:41 <Gracenotes> cool? warm? neutral?
22:10:11 <Gracenotes> lots o' contrast? any other ridiculously simple art terms?
22:10:56 <FunctorSalad> yes, yellow on saturated blue! j/k
22:11:37 <Gracenotes> purple/orange
22:12:35 <Elly> @hoogle <$>
22:12:35 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:17:16 <kadaver> so what would a good low-level lang do different than C? type-safety and no(or alot less) undefined behaviour. more?
22:17:23 <jmcarthur> I like the idea of warm colors. Emphasize that Haskell is warm and fuzzy.
22:17:38 <ray> pastel colors, comic sans
22:17:57 <ray> a background with flowers
22:18:05 <Gracenotes> comic sans would be great if someone were writing haskell comics
22:18:38 <ray> i wonder if there's a monospace comic sans
22:18:44 <Gracenotes> speaking of which, haskell manga please
22:19:00 <jmcarthur> kadaver: have you looked at Cyclone or BitC?
22:19:01 <inimino> comic sans is not appropriate for anything
22:19:21 <Gracenotes> as I said, it is appropriate for comics
22:19:34 <ray> it is appropriate for anything you want to look warm and fuzzy
22:19:35 <Gracenotes> that's why it was made
22:19:37 <inimino> only comics making fun of the guy who designed Comic Sans
22:19:42 <Gracenotes> (even with possible kerning issues)
22:20:21 <Gracenotes> only comics making fun of inimino
22:22:16 <kadaver> are there several newtons methods?
22:23:06 <Gracenotes> there's one newton method that applies to any power.
22:23:35 <dolio> Power?
22:23:37 <blackdog> is there a data structure like bloom filters that never gives false positives but may give false negatives?
22:23:42 <Gracenotes> the two-power version may be used by plugging in '2' in the formula and simplifying it
22:24:12 <Gracenotes> dolio: well, it applies to any function really
22:24:32 <wli> AFAIK it's just newtonStep f f' x = x - (f x)/(f' x); higher-dimensional analogues are Newton-Raphson etc.
22:24:34 <Gracenotes> the power version is most commonly used though.
22:25:53 * wli mostly sees it used to polish roots after they're sufficiently bracketed by other methods.
22:27:18 <FunctorSalad> meh I severly fscked up my transformation matrix stack . o O ( use newtypes for different coordinate systems? )
22:27:50 <Gracenotes> not a bad idea :!
22:28:23 <FunctorSalad> I mean, the problem is I can't find where, with OpenGL transformations being basically dynamic scopes
22:28:35 <b\6> looking for magic words to help me google for the ways things can be related, like if every x is a y, x and y have a $something relationship, like every dog is an animal.
22:29:06 <lament> too many magic words...
22:30:23 <sjanssen> b\6: x is a subset of y?
22:31:41 <b\6> sjanssen: kind of, but more general. maybe it's related to labelling or categorizing. haskell is 'under' programming in some sense.
22:31:49 <b\6> those relationships have wacky names.
22:31:59 <edwardk> is there any haskell bitset out there that you can actually ask for the whole list of set bits?
22:32:22 <jmcarthur> b\6: something as general as "one-to-many"?
22:32:35 <wli> Not sure what you have in mind for a bitset. I guess I use IntSet most of the time for that sort of thing.
22:32:50 <b\6> jmcarthur: yeah, that sort of thing. i hadn't searched on that.
22:33:08 <edwardk> wli: i was peeking at: http://hackage.haskell.org/packages/archive/bitset/1.0/doc/html/Data-BitSet.html or the Bits interface
22:33:54 <edwardk> basically i'm looking for something i can use as a generator of bools for my monoid stuff, so i have an excuse to use generalizations of all and any
22:34:09 <edwardk> and the only Bool generator i have is [a], so all and any aren't very much generalized ;)
22:34:13 <edwardk> er [Bool]
22:34:17 <jmcarthur> b\6: you can also say that A "subsumes" B, for some kinds of relationships
22:34:31 <b\6> oh yeah, good one.
22:35:53 <b\6> oh hell yeah: hyponym
22:36:08 <b\6> hyponymy (A is subordinate of B; A is kind of B)
22:36:33 <b\6> the magic word is apparently "semantic relation".
22:36:55 <jmcarthur> woah, never seen that word before
22:37:01 <FunctorSalad> " like if every x is a y, x and y have a $something relationship, like every dog is an animal" <-- I misread the second "like" as "then" and wondered whether I'm on crack or you are ;)
22:37:28 <BMeph> Sounds like something edwardk would throw '-morphism' on and stick in -extras... ;)
22:37:56 <jmcarthur> heh
22:38:00 <jmcarthur> i was thinking the same thing
22:38:03 <FunctorSalad> BMeph: subset inclusions are essentially equivalence classes of monomorphisms ;)
22:38:10 <b\6> sorry, sorry.
22:38:25 <BMeph> edwardk: So, So, what is a hyponymorphism? ;)
22:38:31 <edwardk> hah
22:38:50 <Gracenotes> how many ponies are involved?
22:38:50 <jmcarthur> a "hi pony morphism"
22:38:59 <b\6> is this related to the mighty morphin power rangers?
22:39:13 <FunctorSalad> (where i1 : S1 -> S is equivalent to i2 : S2 -> S iff i1 = i2 . f for some f)
22:39:22 <jmcarthur> go go mightymorphism power rangers!
22:39:33 <edwardk> cabal install pony -- and find out ;)
22:39:40 <FunctorSalad> hmm and f an isomorphism
22:40:05 * jmcarthur wants to come up with a plausible definition for "mightymorphism" now
22:41:42 <zeno> which is the convention: put the functions that are simplest (depend on no others) on the bottom, or the top or the module?
22:41:52 <edwardk> bah, haskell needs a Semigroup class. Monoid is too strong ;)
22:42:18 <jmcarthur> zeno: my personal preference is to put those near the top, but i don't know if there is a convention
22:42:36 <pumpkin> edwardk: numerical prelude? :P
22:42:43 <FunctorSalad> zeno: you could put the "general-purpose" ones in a seperate module
22:42:59 <zeno> FunctorSalad: ya i have a AndrewsUtils module too :)
22:42:59 <edwardk> pumpkin: went down that road once, gave up started a whole other language to avoid shooting myself
22:43:10 <zeno> jmcarthur: ok ill just go with that thx
22:43:25 <pumpkin> aw
22:43:31 <pumpkin> edwardk: you don't like it?
22:43:38 <zeno> maybe it depends on if your using the waterfall or just hack it to together method of development :)
22:43:57 <jmcarthur> edwardk: i repeat that over and over, always just giving up and coming back to haskell again
22:44:29 <BMeph> zeno: Please, I believe the technical term for that is "iterative incremental". ;)
22:47:40 <rittyan1> morning
22:49:29 <edwardk> gah, ghc doesn't seem to like infix class names in instance heads for some reason, but will take them all over the place in class definitions, etc.
22:51:56 <lament> @quote xah
22:51:57 <lambdabot> No quotes match. Do you think like you type?
22:52:00 <lament> @quote xahlee
22:52:00 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
22:53:19 <pumpkin> xah lee ftw
22:54:22 <FunctorSalad> BMeph: I prefer the term "hack & slay"
22:54:25 <FunctorSalad> =)
23:00:54 <FunctorSalad> @let kitten_supply = fix ( "kitten" : )
23:00:57 <lambdabot>  Defined.
23:03:09 <lament> > take 5 kitten_supply
23:03:10 <lambdabot>   ["kitten","kitten","kitten","kitten","kitten"]
23:03:19 <lament> AWWWWW
23:04:22 <Heffalump> @let shoot "kitten" = "kitten body"
23:04:24 <lambdabot>  Defined.
23:04:31 <Heffalump> > take 5 $ map shoot kitten_supply
23:04:33 <lambdabot>   ["kitten body","kitten body","kitten body","kitten body","kitten body"]
23:04:34 <Heffalump> yay
23:04:38 <FunctorSalad> :o
23:04:47 * Heffalump fed up with cats pooing in his garden
23:06:26 <idnar> hahaha
23:09:54 <Gracenotes> > take 5 $ zipWith (\k -> if k then shoot else id) (randomRs (False, True) (mkStdGen 2191)) kitten_supply
23:09:56 <lambdabot>   ["kitten body","kitten body","kitten","kitten","kitten body"]
23:10:07 <Gracenotes> so I see there were 2 lucky ones
23:10:28 <lament> > intercalate " looking at " kitten_supply
23:10:29 <lambdabot>   "kitten looking at kitten looking at kitten looking at kitten looking at ki...
23:16:48 <kadaver> a good webserver, does it keep pages in memory? how do I cache things with haskell? use a Map String String ?
23:17:30 <SubStack> is there a more idomatic way of chunking up a list into groups of size n than writing an explicitly recursive function?
23:17:38 <SubStack> I find myself doing this over and over
23:17:49 <kadaver> @type partition
23:17:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
23:18:01 <dibblego> SubStack, see Data.List.Split
23:19:12 <SubStack> splitEvery, nifty
23:19:14 <SubStack> dibblego++
23:19:38 <pumpkin> yay it's dibblego
23:21:43 <kadaver> combine splitAt somehow?
23:22:14 <pumpkin> combine?
23:22:37 <Gracenotes> inspired by the current mailing list discussion, you could probably do something like evalState . mapM (State $ splitAt 3)
23:22:58 <Gracenotes> very cute solution :) I guess it's one use of State being -> (a, s) instead of (s, a)
23:23:06 <pumpkin> I posted that (but correct) earlier
23:23:09 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2843#a2843 <- split :: Int -> [a] -> [a]
23:23:12 <pumpkin> :P
23:23:25 <pumpkin> > let mySplit n xs = takeWhile ((n ==) . length) . evalState (sequence . repeat . State . splitAt $ n) $ xs in mySplit 3 [1..10]
23:23:27 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
23:23:32 <pumpkin> not the most elegant it could be
23:23:33 <Gracenotes> oh lord. :\
23:23:40 <pumpkin> the takeWhile is ugly
23:23:55 <Gracenotes> and the length
23:24:00 <Gracenotes> but that's for exact chunking
23:24:01 <pumpkin> yeah, I meant that whole lump
23:24:10 <Gracenotes> best to make your own splitAt
23:24:16 <pumpkin> yeah, that's what whoever it was was asking for
23:24:26 <Gracenotes> yeah, mapM wouldn't work. twas blindly copied! :OX
23:24:31 <Gracenotes> from memory
23:24:42 <pumpkin> I wanted a repeatM :P
23:24:45 <kadaver> isnt my solution better? it is much clearer even if 2 lines
23:24:53 <SubStack> I like it better when I can just import something that does it for me
23:24:54 <kadaver> i dont like code golfing for real solutions...
23:25:04 <pumpkin> @let repeatM = sequence . repeat
23:25:04 <lambdabot>  <local>:23:0:
23:25:05 <lambdabot>      Multiple declarations of `L.repeatM'
23:25:05 <lambdabot>      Declared at: <l...
23:25:16 <Gracenotes> pumpkin: there would be a lot of nice M things
23:25:16 * ozy` instantiates Num [Int] for a time-of-day type so he can write 7:30, etc.
23:25:17 <pumpkin> kadaver: it isn't just golfing, using state is actually quite clear I think
23:25:43 <pumpkin> kadaver: you're doing a state-like operation in your splitAt
23:25:52 <pumpkin> kadaver: if you recognize it and use it as such
23:26:23 <pumpkin> you may be exploiting the representation of State, but it's not that bad
23:26:32 <pumpkin> it's still state :P
23:26:34 <Gracenotes> Concentration... 64... category is... functions that should  be in Control.Monad!
23:26:39 <Gracenotes> foldrM
23:27:03 <FunctorSalad> > let { mySplit n xs = [ f i j | i < [0..(n-1)], j <- [0..(length xs - 1 `div` n)] ]  ;  f i j = xs !! (i+n*j) } in mySplit 5 (take 20 $ concat kitten_supply)
23:27:04 <lambdabot>   Not in scope: `xs'
23:27:05 <Gracenotes> ifM
23:27:16 <FunctorSalad> > let { mySplit n xs = [ f xs i j | i < [0..(n-1)], j <- [0..(length xs - 1 `div` n)] ]  ;  f xs i j = xs !! (i+n*j) } in mySplit 5 (take 20 $ concat kitten_supply)
23:27:17 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
23:27:26 <Gracenotes> repeatM
23:27:34 <FunctorSalad> > let { mySplit n xs = [ f xs i j | i <- [0..(n-1)], j <- [0..(length xs - 1 `div` n)] ]  ;  f xs i j = xs !! (i+n*j) } in mySplit 5 (take 20 $ concat kitten_supply)
23:27:35 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
23:27:42 <FunctorSalad> *stops spamming*
23:27:59 <pumpkin> omg kittens
23:28:02 * Gracenotes goes off to cleanself
23:30:51 * SubStack paws at the kitten supplies
23:31:53 <FunctorSalad> I wonder why it doesn't shadow f
23:31:56 <FunctorSalad> > f
23:31:57 <lambdabot>   Add a type signature
23:33:22 <lament> > f :: Int
23:33:23 <lambdabot>       No instance for (SimpleReflect.FromExpr Int)
23:33:23 <lambdabot>        arising from a use ...
23:41:14 <dolio> FunctorSalad: f xs i j = xs !! (i+n*j) -- n is free, n :: Expr.
23:41:33 <FunctorSalad> oh, right
23:43:38 <SubStack> PPM++ for being easy to parse
23:47:31 <zakwilson> Inferior Haskell with Ghci is putting ^J some places where I expect newlines. Is there an obvious problem/fix here?
23:49:43 <quicksilver> zakwilson: http://blog.ox.cx/2009/02/06/ghci-and-emacs/
23:49:49 <quicksilver> no idea what that's about :-/
23:50:50 <quicksilver> zakwilson: http://www.nabble.com/problem-with-echo-prompting-in-ghci-(visible-in-emacs)-td20451779.html
23:50:53 <quicksilver> better explanation.
23:53:12 <zakwilson> quicksilver: thanks
23:56:24 <zakwilson> That fixed it.
23:57:13 <kadaver> a good webserver, does it keep pages in memory? how do I cache things with haskell? use a Map String String ?
