00:00:34 <jmcarthur> the vacuum package looks cool
00:00:59 <pumpkin-> yeah, I'm excited
00:01:35 <jmcarthur> :t ((/=) `on` sort) <*> nub
00:01:37 <lambdabot> forall a. (Ord a) => [a] -> Bool
00:07:10 <Lemmih> @seen dcoutts
00:07:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I don't know when dcoutts last spoke.
00:08:43 <rovar> I'm running out of mem here, but don't think I should be.
00:08:56 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1991
00:09:23 * wli breaks out the brown paper bag.
00:09:37 <rovar> yea.. it sucks.. but hey, I'm learning.
00:09:51 <wli> No, bugs in my code.
00:09:54 <rovar> oh
00:11:07 <pumpkin-> dons: I see in your TODO that you've considered UArr (UArr a)... do you have any thoughts on how this could work? for Streams you already have that working I think, but the BUArr stuff might be complicated
00:15:10 <wli> http://wli.pastebin.com/m61be8e22 <-- corrected, I hope
00:20:19 <FunctorSalad_> why's the chain rule commented out in Data.Maclaurin? (ping conal?)
00:37:28 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1991#a1993
00:37:50 <rovar> can someone tell my why this is rapidly eating 3GB of ram before quitting?
00:38:47 <rovar> my guess is drop for sequence doesn't really release the node.. but it's hard to be sure
00:39:31 <rovar> compiling with -O3 --make
00:59:50 <aleator> Is Control.Monad.State lazy?
01:00:51 <JohnMeacham> jhc has a bug tracker now: http://repetae.net/computer/jhc/bug/
01:02:16 <rovar> nice
01:03:56 <pumpkin-> aleator: I believe so
01:53:29 <zeno> rovar: http://book.realworldhaskell.org/read/profiling-and-optimization.html
01:54:03 <pumpkin-> we need an optimization library for haskell
01:54:28 <wli> I'd settle for an adequate microbenchmarking library.
01:54:57 <pumpkin-> oh, I mean optimization in the sense of having a cost function and a high-dimensional space to maximize/minimize it over
01:55:08 <pumpkin-> but the other sense too
01:58:35 <wli> It's difficult to adapt things in generality. I think most problems where it matters end up having to do violence to whatever code they borrow.
01:59:08 <Axman6> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.2 <- made me think i had a dead pixel :(
01:59:21 <pumpkin-> lol
02:00:13 <wli> There is a lot that can't be driven without domain-specific or problem-specific knowledge peppered about in awkward places.
02:01:10 <wli> For instance, even 1D root finders can't get off the ground with any reliability unless you bracket a root up-front for them somehow.
02:05:22 <wli> I think graded lex makes a fair amount of sense for handling s^2+c^1=1 and d^2+k^2*s^2=1 but you're still stuck being unable to rationalize denominators.
02:21:00 <edwardk> ok, finally bit the bullet and started uploading that monoid library to hackage, i figure that will keep me adding documentation to it ;)
02:21:13 <pumpkin-> which monoid library?
02:21:31 <edwardk> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monoids-0.1.2
02:21:43 <pumpkin-> lots and lots of monoids!
02:21:49 <edwardk> i got bored
02:21:59 <pumpkin-> do I get free Monoids from MonadPlus?
02:22:04 <edwardk> yeah
02:22:10 <edwardk> MonadSum in Data.Monoid.Monad
02:22:42 <edwardk> and there are Monadic Monoid adapters in Data.Monoid.Monad.* since every monad is associative
02:22:42 <pumpkin-> looks like more monoids than I could ever use, but it's good to know they're there
02:22:52 <pumpkin-> lol
02:23:30 <edwardk> Data.Monoid.Reducer and Data.Monoid.Generator are my favorite parts
02:23:51 <ejt> edwardk: looks useful
02:23:57 <yottis> have there been btw any plans for making Monad a subclass of Applicative in some future haskell version?
02:24:09 <aleator> pumpkin-: You mentioned an optimization library. I've worked on metaheuristic optimization for some time now, and am planning to release some dozen or so algorithms in near future. Also HMatrix has simple direct search and cg-methods.
02:24:38 <edwardk> yottis: people keep mentioning it, but there seems to be no inertia in that direction. if you're going there you might as well drop my 'Pointed' superclass on it too ;)
02:24:53 <pumpkin-> aleator: ooh, sounds nice! any preview of the dozen or so algorithms? which ones do you have?
02:24:58 <yottis> i was just about to ask about that next
02:25:15 <quicksilver> yottis: there are at least two objects : (1) it breaks backward compatibility
02:25:15 <yottis> seems kinda silly to have all these return/pure/singleton/whatever functions
02:25:29 <quicksilver> yottis: (2) it makes it "slightly" more of a pain to define new instances.
02:25:30 <yottis> yeah that's definetly a turnoff
02:25:34 <edwardk> ejt: a lot of common mapM_ like things just drop out from the use of the monoids and combinators provided. traverse_ f = getTraversal . reduce f
02:25:36 <pumpkin-> same with MonadPlus and Monoid, really
02:25:38 <quicksilver> yottis: I have no sympathy at all with (2).
02:25:47 <quicksilver> yottis: but I do have sympathy with (1)
02:26:22 <aleator> pumpkin-: Well, standard stuff like GA, ES, SA and more modern stuff based on DE, like jDE, SADE, DEPSR, DEGL and few memetic versions of these. What would you be looking for?
02:26:32 <ejt> edwardk: so do you have an ETA on the documentation ? ;)
02:26:34 <quicksilver> pumpkin-, edwardk : am I right in thinking that TypeEqualities lets us write "instance (a ~ b) => Monoid (a -> b)", by the way? That seems quite attractive.
02:26:38 <quicksilver> down with the Endo wrapper.
02:26:48 <pumpkin-> aleator: ack, I can decipher some of those acronyms, but most of them are opaque
02:26:52 <edwardk> ejt: hah, i have it built on my local machine one sec. ;)
02:27:07 <yottis> well, one approach could be to be able to define superclass methods when instantiating a subclass
02:27:08 <aleator> pumpkin-: Oh sorry :) Differential evolution and modern variants basically.
02:27:09 <zeno> what package should i cabal install? im updated/graded  Could not find module `Data.Time.Clock': Perhaps you haven't installed the profiling libraries for package time-1.1.2.3?
02:27:14 <pumpkin-> gradient ascent, simulated annealing
02:27:23 <pumpkin-> are the ones I can see
02:27:54 <edwardk> quicksilver: technically i have the pieces for that already in category-extras and monoids, there is a discrete categry that just contains identity arrows and a monoid of generalized endomorphisms. ;)
02:28:08 * quicksilver nods
02:28:13 <pumpkin-> aleator: anyway, it sounds exciting... how does one feed data into your functions, and what license do you plan on releasing it under?
02:28:29 <aleator> pumpkin-: I've not dabbled much with gradient based. HsASA does pretty good SA for continous problems.
02:28:34 <quicksilver> edwardk: I think it's probably a better instance for (->) than Monoid b => Monoid (a -> b)
02:28:38 <quicksilver> edwardk: then again, you never know.
02:29:02 <wli> aleator: I usually need Lagrange multipliers. :(
02:29:25 <edwardk> ejt: http://comonad.com/haskell/monoids/dist/doc/html/monoids/
02:29:50 <aleator> pumpkin-: Well, currently it is optimizing [Double] -> [Double] in a rectangular area, though some stuff is using HBlas/HMatrix. Licence will be, please cite me if you "publish something with these, otherwise bsd".
02:29:55 <edwardk> quicksilver: actually i don't think you can get what you want, now that i've reparsed it
02:30:16 <ejt> edwardk: great, that's given me something to read at work today :)
02:30:33 <aleator> ack [Double] -> Double.
02:30:35 <quicksilver> edwardk: no? I thought that's what type equalities did?
02:30:47 <pumpkin-> aleator: nice :)
02:30:52 <pumpkin-> although I'm not sure about lists
02:30:54 <pumpkin-> but I'll live for now :P
02:30:58 <edwardk> quicksilver: i'm pretty darn sure that won't get propagated through to sites you want it to
02:31:11 <pumpkin-> anyway, I'll keep an eye out for it on hackage recent uploads :)
02:31:35 <edwardk> quicksilver: otherwise type equalities would let you define things like functors on arguments other than the last one, etc. and dogs and cats would be living together in harmony
02:32:09 <ejt> edwardk: is redefining (+) useful ?  since you either have to qualify it or hide the one in the prelude ?
02:32:31 <edwardk> ejt: all of the 'Sugar' ones are when you want to make your small example code pretty.
02:32:36 <edwardk> hence why its not in the main files
02:32:53 <aleator> pumpkin-: Well, It will take me few weeks with this workload. Most importantly it needs some refactoring to unify interfaces and to use some common vector stuff/classes
02:32:55 <ejt> y, I realise it's optional, just wondered if I was missing something
02:32:59 <doserj> edwardk: do you know why on http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Reducer.html most of the instances are duplicated? Bug in haddock?
02:32:59 <edwardk> you can import pretty much anything else unqualified
02:33:11 * ejt wonders how many of his haskell files don't use (+), probably a fair few
02:33:28 <edwardk> yeah haddock bug. some of those are actually different instances, like the bytestring instances, etc.
02:33:33 <pumpkin-> aleator: ah, well if you want some help with it I'd be interested to poke around in it (if you wanted to put it up on github or patch-tag or some other public repo hosting) if I get any time
02:34:00 <pumpkin-> aleator: either way, still nice to know someone's working on something I've been looking for
02:34:49 <edwardk> ejt: basically i define 'plus' and 'zero' so i don't have to sit around making up incomprehensible names for further up the type hierarchy and then make everything else fit. the various Foo.Sugar bits let you get back (+) and (-) and (*) and so forth if you want them for this.
02:35:00 <aleator> pumpkin-: Sure. I'll try to make something preliminary soonish and I'll drop you a note then. Esp. interface design needs some "realworld" testing.
02:35:04 <edwardk> i think it works as a good compromise, a nice rigorous numerical hierarchy, but not forcing you to use it.
02:35:10 <aleator> pumpkin-: What are you planning to do with these?
02:35:27 <edwardk> especially since i only picked up the parts of the hierarchy i actually needed. (i.e. i need near-semi-rings for my regexp monoid)
02:35:34 <ejt> edwardk: anything to avoid using 'mappend' :)
02:35:54 <edwardk> ejt: hah, i think that word is responsible for the perpetual obscurity of haskell monoids ;)
02:36:00 <pumpkin-> aleator: a few machine learning algorithms I play with use libraries like TAO for maximum likelihood training of CRFs
02:36:19 <quicksilver> edwardk: what do you use instead of mappend?
02:36:28 <quicksilver> I was thiking of making a library proposal for a better name.
02:36:29 <pumpkin-> aleator: I've been looking forward to doing a CRF implementation in haskell, and didn't want to deal with an FFI binding to TAO/PETSc
02:36:35 <edwardk> quicksilver: Data.Monoid.Additive gives you 'plus' and 'zero'
02:36:46 * quicksilver nods
02:36:51 <quicksilver> I don't think 'plus' is a good name.
02:36:57 <pumpkin-> star!
02:36:58 <edwardk> that way Data.Monoid.Multiplicative can give you one and times
02:37:01 <quicksilver> (addition is commutative)
02:37:01 <aleator> -> lecturing
02:37:06 <ejt> quicksilver: I'd favour a symbol rather than a textual name
02:37:13 <pumpkin-> I kind of like plus
02:37:14 <quicksilver> I was going to propose (+>)
02:37:26 <quicksilver> (and then (<+) = flip mappend)
02:37:31 <ejt> I like that
02:37:38 <pumpkin-> that feels noncommutative somehow
02:37:45 <quicksilver> pumpkin-: yes. Which is the whole point.
02:37:46 <pumpkin-> I guess mappend isn't commutative
02:37:48 <pumpkin-> :)
02:37:54 <quicksilver> most interesting monoids are non-commutative.
02:37:54 <edwardk> quicksilver: my math teachers didn't have the bias towards commutative plus, it was there a little, but it wasn't as strong as some of you folks seem to have had it beaten into you ;)
02:38:02 <BONUS> > "Hey" `mappend` "there"
02:38:02 <quicksilver> edwardk: fair enough.
02:38:03 <ejt> it highlights it's not commutative
02:38:03 <lambdabot>   "Heythere"
02:38:10 <edwardk> more importantly, it lets me layer multiplication over some existing monoids.
02:38:23 <quicksilver> ejt: it looks 'enough like' ++ to make you see a link between them
02:38:28 <quicksilver> ejt: it looks nice for functions too
02:38:44 <quicksilver> (which let to my question about using type equalities to escape the Endo newtype)
02:39:29 <edwardk> anyways my main goal with the library is to avoid requiring you to manually 'mappend' in most scenarios. thats what 'reduce' and 'mapReduce' are for
02:39:45 <quicksilver> maybe you're right.
02:39:50 <edwardk> in particular the mapReduce instance for lazy bytestrings even parMaps
02:41:05 <edwardk> mainly because it is ripped out of part of my parser for kata, which wants to feed a ton of monoids into a fingertree in parallel, and then update itself just based on incremental source changes to the fingertree cheaply
02:41:21 <rittyan1> morning
02:41:30 <ejt> morning
02:41:58 <quicksilver> edwardk: I find myself using monoids for composing graphics and things like that.
02:42:09 <quicksilver> edwardk: really they're just well hidden instances of an endomorphism monoid
02:42:18 <quicksilver> in particular they're definitely not commutative.
02:43:10 <edwardk> quicksilver: i'm trying to get a usable monoidal parser combinator library, in particular i'm trying to get a usable enough regular expression engine to make a drop-in 'lex' clone which just returns other monoids up stream when it matches.
02:43:51 <edwardk> i have a few hand coded regexes that i've got working, but to make it intoa general library i need to use something like the 'implicit configuration' pearl
02:44:35 <edwardk> the other thing is it seems to really want a nice 'monadic monoid' where mappend' :: a -> a -> m a -- in some Monad
02:44:57 <edwardk> it could probably be applicative, but i want memoization without leaking memory like a sieve
02:45:10 <pao> hi all, ... what is the most idiomatic version for \x -> (x,x)?  join (,)? is there anything better?
02:45:35 <quicksilver> pao: (\x -> (x,x))
02:45:39 <edwardk> in category-extras there is 'diag' in Control.Category.Cartesian ;)
02:45:40 <quicksilver> dont' be afraid of the lambda.
02:45:49 <pao> quicksilver: ok :-)
02:46:00 <quicksilver> there are some cases where a lambda expression is the most concise and easily understood way of writing a function ;)
02:46:12 <edwardk> bah, being understood is vastly overrated ;)
02:46:13 <pao> quicksilver: point taken :-)
02:46:23 <pao> edwardk: LOL
02:46:24 <quicksilver> > (id&&&id) 5
02:46:25 <lambdabot>   (5,5)
02:46:29 <quicksilver> pao: ^^ just for fun.
02:47:06 <quicksilver> For example, I personally prefer (\x->[x]) to (return). Unless the generalisation is interesting.
02:47:25 <pao> quicksilver: would be useful to have a utility function for that? just as "on" ...
02:47:49 <pao> *wouldn't
02:48:03 <BONUS> i prefer just putting [ ] around a value if it's in scope, otherwise i prefer (:[])
02:49:06 <edwardk> quicksilver: what other containers can people think of that i'd want to iterate over? unlike Foldable i'm not restricted to Functors
02:51:12 <edwardk> I've got ByteStrings, IntSet, Text, [c], IntMap, Map, Seq a, FingerTrees,Set, the values of an IntMap or Map, the keys of an IntMap or Map, and bytestrings counting bytes as chars.
02:51:54 <edwardk> you can feed the bytestring through the UTF8 monoid if you have a char reducer as well, so for instance my regexes don't have to understand utf-8 thats handled a level below them
02:52:17 <edwardk> i'm just not very familiar with what collection libraries folks are using these days
02:52:46 <edwardk> oh i guess i should do Arrays
02:52:54 <edwardk> kinda silly that I forgot them
02:52:55 <rittyan1> is there a configurable "words" function? I want to set my own delimiters (space only)
02:56:14 <HugoDaniel> hello
02:58:56 <osfameron> rittyan1: Data.List.Split in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split I think
02:58:59 <quicksilver> pao: isn't that what '&&&' is? not sure I follow.
03:00:12 <pao> quicksilver: duplicate == (id&&&id) .... that's what I was thinking of... just a pointless rumbling :-)
03:00:22 <pao> *=
03:00:32 <edwardk> pao: there is &&& if you want to apply two functions and i have 'diag' in category-extras if you really want the more general id &&& id
03:00:52 <edwardk> which corresponds to the \Delta morphism in a cartesian category
03:01:15 <edwardk> and more interestingly works in any such category, not just haskell functions
03:01:39 <edwardk> (for that matter there is a generalization of &&& in tehre as well)
03:03:07 <pao> edwardk: thanks... let's add cartesian categories to the list of  things to study :-)
03:03:43 <dolio> Isn't there &&& in any category with products?
03:03:46 <pao> the problem is that it grows much quicker than what I can consume :-)
03:03:59 <dolio> I mean, depending on what you think &&& is.
03:04:05 <osfameron> what was the monadic trick to repeat arguments of a function?
03:04:23 <edwardk> dolio: probably, but i don't bother to define anything weaker than a precartesian category before i jsut start calling them foo bifunctors
03:04:26 <idnar> osfameron: join
03:04:32 <edwardk> > join (+) 3
03:04:33 <lambdabot>   6
03:04:58 <dolio> Oh, we're talking about categories-that-category-extras-defines.
03:05:03 <edwardk> dolio: and even my particular notion of a precartesian category had to be tweaked a little
03:05:03 <osfameron> thanks
03:05:08 <edwardk> dolio: yeah
03:05:12 <dolio> Okay.
03:05:20 <edwardk> dolio: i need to go back through and fix up some of the goofy definitions in there
03:05:29 * edwardk winces a little when he sees some of them
03:06:28 <osfameron> :t join
03:06:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:06:41 <osfameron> I so don't get why it does that...
03:07:18 <edwardk> osfameron (a->) is a monad
03:07:23 <osfameron> it's something to do with functions "being a monad" and repeating the argument being the only sane thing to do for join..
03:07:24 <quicksilver> osfameron: for the function (reader) monad, m (m a) is (b -> b -> a)
03:07:37 <osfameron> where did the b come from?
03:07:48 <quicksilver> osfameron: the monad. You might call it 'reader b'
03:08:39 <osfameron> ok, and from (b->b->a) -> (b->a) there's only one thing it can do
03:08:51 <osfameron> I should look at the function monad, that's very hazy to me
03:12:03 <rittyan1> osfameron, thanks
03:12:53 <quicksilver> osfameron: the function monad is "apply a bunch of functions to the same argument"
03:13:33 <quicksilver> :t do {x <- (+1); y <- (*3); z <- (/5); return (x,y,z) }
03:13:35 <lambdabot> forall a. (Fractional a) => a -> (a, a, a)
03:13:38 <HugoDaniel> hmm the java framework called processing is quite trendy
03:13:49 <HugoDaniel> i wonder if there are any similar projects for haskell
03:13:49 <quicksilver> > do {x <- (+1); y <- (*3); z <- (/5); return (x,y,z) } $ 8
03:13:51 <lambdabot>   (9.0,24.0,1.6)
03:14:12 <Baughn> I've got a test program using HsOpenSSL that fails on ghc 6.11, but works just fine on 6.10. If anyone with sufficient knowledge of ghc internals would like to look at it and decide whether the bug is in ghc or hsopenssl, that'd be swell
03:16:01 * Baughn is meanwhile trying to get the git version working so he can bisect
03:16:01 <osfameron> quicksilver: ah, that's why it's (a->) because the return type of each possible function call is not specified
03:16:58 <quicksilver> osfameron: right. It's a monad, it can return anything internally.
03:17:24 <quicksilver> osfameron: perhaps here is a more interesting example where the types do indeed differ
03:17:54 <quicksilver> > do { l <- length; c <- head; s <- (++"bar"); return (l,c,s) } $ "foo"
03:17:56 <lambdabot>   (3,'f',"foobar")
03:19:00 <osfameron> yeah
03:19:38 <quicksilver> > ((,,) <$> length <*> head <*> (++"bar")) "foo"
03:19:38 <zeno> when i try to compile something with -prof -auto-all -caf-all -fforce-recomp i get Could not find module `System.TimeIt': which i installed with cabal and imports into ghci fine
03:19:39 <lambdabot>   (3,'f',"foobar")
03:19:47 <quicksilver> osfameron: ^^ you can haz Applicatie syntax too.
03:20:29 <quicksilver> zeno: it's probably telling you it can't find the *profiling* version of that.
03:20:41 <quicksilver> zeno: you need to reinstall it with -p to get profiling libs.
03:22:13 <zeno> > (,,) 1 2 3
03:22:14 <lambdabot>   (1,2,3)
03:22:40 <zeno> quicksilver: it meaning ghc?
03:22:48 <zeno> or timeit
03:23:35 <quicksilver> zeno: timeit
03:23:46 <zeno> phew ok thx
03:23:48 <quicksilver> (And any other packages you installed with cabal which you need for this program)
03:23:59 <quicksilver> ghc comes with all its libs in profiling versions, fortunately.
03:42:05 <osfameron> quicksilver: eeeek!  I don't get applicative yet either...
03:42:10 <tpr> To what projects haskell is well suited? I mean: I would like to learn haskell, but I have hard time to think about what could I write.. for example web applications are probably not "suited"
03:43:35 <quicksilver> I think just about everything except hard real time is suitable.
03:43:53 <quicksilver> but I guess what you're worrying about is the libraries.
03:44:05 <quicksilver> certainly haskell web applications libraries are not as widely used and are perhaps less mature
03:44:11 <quicksilver> (I can't judge since I haven't really used them)
03:44:20 <quicksilver> writing a simple web application using CGI or fastcgi is easy though.
03:45:23 <HugoDaniel> tpr: what would you like to code ?
03:51:18 <HugoDaniel> real world haskell is a really great book
03:51:35 * ppavelV6 agreed, but a bit longish :)
03:52:25 <HugoDaniel> i walk around with it all day long to read it on the metro and on the bus
03:52:45 <ppavelV6> it's better when combined with others
03:52:50 <HugoDaniel> im in chapter 6, i didn't quite get the "as" @ part, ill have to study it better when i have the time
03:52:53 <HugoDaniel> hmm
03:53:02 <HugoDaniel> im also reading the purely functional data structures
03:53:42 <HugoDaniel> i like technical books, i can read several at the same time without getting mixed or confused (it does not happen with romances though)
03:54:57 <ppavelV6> rwh is a great book. It did (and does and will do)  a lot for haskell's popularity. Many people were astonished to find out that haskell is really more than an academic toy.
03:55:03 <quicksilver> I liked the romance in rwh.
03:55:11 <HugoDaniel> :)
03:55:16 <ppavelV6> actually, it's the technology toolchain ready to us
03:56:00 <dcoutts> Lemmih: pong
03:59:13 <HugoDaniel> how do i transform a [fromList [a], fromList [a], ..] into [a] ?
03:59:40 <idnar> @type fromList
03:59:42 <lambdabot> Not in scope: `fromList'
03:59:43 <tpr> HugoDaniel: I don't know.. Maybe something scientific?
03:59:49 <idnar> what's fromList?
04:00:12 <ppavelV6> :t concat
04:00:13 <lambdabot> forall a. [[a]] -> [a]
04:00:25 <idnar> or, I suppose I should ask, which fromList is that?
04:00:39 <ppavelV6> what's the type of fromList?
04:00:51 <ppavelV6> i'd suggest transform _ = [] :)
04:01:07 <HugoDaniel> sorry
04:01:29 * doserj suggests concatMap toList
04:04:08 <HugoDaniel> im doing a (last . Map.elems) myMap
04:04:09 <HugoDaniel> and it returns "fromList [a]"
04:04:09 <HugoDaniel> and i just want a [a] :P
04:04:27 <HugoDaniel> its a map of sets, ill look for a set function to do it
04:08:12 <kadaver> one thing i dont get with open addressing. if i store hash(a) in array index 13420 and then i have a collision so i store that in 13421 instead of 13420. but then if i get a value that really is 13421 instead what do i do? put it in 13421 and move 13421? to where?
04:08:22 <kadaver> separate chaining is easier?
04:11:35 <quicksilver> kadaver: push it to 13422
04:13:41 <quicksilver> kadaver: whenever you look up anything you have to check what you've got
04:13:51 <quicksilver> and keep jumping forwards.
04:13:56 <thorkilnaur> kadaver, On highest authority (Knuth, Volume 3), the idea is to establish a "probe sequence" (e.g. linear like 13420, 13421, 13422, ... wrapping around at the end) and simply locate the first free spot.
04:14:26 <quicksilver> it's obviously a very bad idea to have this happen often.
04:14:35 <Workybob> or just make the hash table contain linked lists of items
04:14:47 <Workybob> (or sets rather)
04:14:48 <quicksilver> that's what kadaver means by 'chaining'
04:15:01 <quicksilver> that involves dynamic memory allocation, though.
04:15:13 <quicksilver> sometimes the problem you're trying to solve is avoiding any dynamic memory allocation.
04:15:17 <Workybob> true
04:20:29 <wli> I know open addressing.
04:21:04 * Baughn has turned this assignment into a full-blown haskell tutorial. Fun. Now for the monad tutorial...
04:21:18 <idnar> wli: show me!
04:21:35 <wli> kadaver: You do the same thing, you use the secondary hash function as an increment modulo the hashtable size and move to the first free spot you find.
04:21:58 <idnar> stop trying to hash me and hash me!
04:22:14 <wli> It's a little awkward in Haskell.
04:33:26 <kadaver> hmm C just seems hopelessly copy-and-pasty.
04:34:04 <wli> kadaver: how is open addressing going?
04:34:50 <Baughn> What was the type inference algorithm used in GHC called, again?
04:35:56 <kadaver> wli: well i was looking at the different ways to do hashtables and I decided for using chaining, so each index int he array is a linked lsit of records
04:36:08 <kadaver> and that means i have to change my linkedlist
04:36:58 <wli> kadaver: you could use AVL trees instead of linked lists
04:38:15 <wli> Baughn: They usually have names (if any at all) referring to them as variants of Hindley-Milner.
04:38:31 <bremner> any QuickCheck experts: I'm trying to run http://adept.linux.kiev.ua:8080/repos/hhgtth/cd-fit.hs and I get  `coarbitrary' is not a (visible) method of class `Arbitrary'
04:39:57 <kadaver> wli: well i am doing it in C...i ahve written bst and redblacktree in haskell already, this is a project to learn c better and better my datstructures skills.
04:40:17 <kadaver> 'or oh you said instead of linked lists
04:40:20 <Baughn> wli: Thanks
04:40:26 <kadaver> well i have linekd list but no avl tree so :P
04:40:38 <mfp> Baughn: System FC
04:41:04 <wli> kadaver: Still do hashing, but use a balanced BST as the collision chain instead of a list.
04:41:13 <wli> F_c is the type system not hte type inference algo
04:41:47 * mfp scrolls up
04:42:33 <doserj> bremner: just delete the coarbitrary=undefined line.
04:42:50 <doserj> bremner: in quickcheck2, coarbitrary is in a separate type class
04:43:00 <bremner> doserj: thanks.
04:52:02 * quicksilver flames wren for a ridiculous cafe post.
04:52:50 <ejt> which thread ?
04:53:51 <quicksilver> ejt: the unsafe exception catching one
04:54:00 <quicksilver> ejt: I really can't believe he wrote such rubbish
04:54:08 <quicksilver> considering I know he understands the issue perfetly well.
04:57:25 <dolio> You could probably do what he wants in GHC, but it'd not be pleasurable to use.
04:58:46 <dolio> We'd be trading unsafeHead for uselessHead.
05:20:23 <wli> Is this head on empty lists again?
05:21:49 <C-Keen> > head []
05:21:50 <lambdabot>   * Exception: Prelude.head: empty list
05:22:26 <wli> I think this is people wanting listToMaybe to be used in place of head.
05:23:09 <wli> > (listToMaybe [], listToMaybe [1..10])
05:23:10 <lambdabot>   (Nothing,Just 1)
05:24:05 <wli> I'm not sure what the answer to unsafe projection functions should be.
05:24:29 <wli> There are a lot of situations where you know some of the alternatives in a datatype can't occur.
05:25:18 <vixey> > (join (&&&) listToMaybe) ([],[()])
05:25:19 <lambdabot>   Couldn't match expected type `[a]'
05:26:38 <wli> if null xs then return retVal else do { put $ head xs ; f (tail xs) }
05:27:45 <wli> Or something more intelligent. You might know that the list is infinite, for instance.
05:31:45 <wli> Some sort of property of the data may ensure you never get to exhaust the list, like arithmetic properties. head $ dropWhile (\k -> k *k < n) [0 .. n] where arithmetic is done in some arbitrary-precision unsigned type.
05:39:24 <wli> > (join (***) listToMaybe) ([],[()])
05:39:25 <lambdabot>   (Nothing,Just ())
05:42:31 <wli> I take it as a sign I'm representing the data wrongly.
05:43:02 <vixey> yeah that's often the case
05:44:42 <wli> Not quite everything can be done in terms of Set and Map, either, but when you've got a hammer, everything looks like a nail.
05:45:00 <kadaver> god programming in C really make me appreicate Haskell. in fact everytime i touc other languages im just more convinced aboutt he greatness of haskell.
05:45:21 <gnuvince> kadaver: :)
05:46:00 <ivanm> kadaver: which of course doesn't mean haskell itself doesn't have some ways it can be fixed up...
05:46:27 <wli> kadaver: There are tasks for which Haskell's unsuited. For userspace it's probably a great idea for non-system-level affairs.
05:47:11 <wli> (e.g. ld.so in Haskell is probably not a bright idea, nor would trying to write Haskell's low-level GC and threading RTS internals in Haskell itself)
05:49:48 <kadaver> ld.so?
05:50:10 <ivanm> dynamic linking libraries on *nix
05:50:18 <ivanm> analogous to dlls in windows
05:50:30 <kadaver> sure I don't claim C is dead. for different purposes obv. btu fior the programming I do I value productivity and correctness almost only.
05:50:43 <wli> kadaver: The dynamic linker.
05:51:40 <quicksilver> I think C might be dying.
05:51:45 <quicksilver> but its death will be very very very slow.
05:52:23 <FunctorSalad_> in TH, is x guaranteed to be fresh in sth like [| \x -> ... |] ?
05:52:35 <wli> There is a need for a language something like C, but with improvements in areas where the constraints of where it's used can tolerate it.
05:52:47 <ivanm> quicksilver: well, what other languages are available that work on all platforms, all architecture levels (from microarchitecture to supercomputers), etc.?
05:53:07 <wli> ivanm: C doesn't fit that description.
05:53:12 <ivanm> haskell probably isn't suited for microcontrollers
05:53:17 <ivanm> wli: oh? in what way?
05:53:51 <wli> ivanm: The mainframe kernels and apps tend not to be written in C.
05:54:21 <ivanm> wli: oh? what are they written in?
05:54:23 <quicksilver> ivanm: well, with your comment suitably modified for accuracy, that's why the death is going to be slow.
05:54:46 <ivanm> and if they run linux, then the kernel _is_ written in C
05:54:46 <quicksilver> ivanm: but if you were designing a new microcontroller, you might necessary think the first step was to port a C compiler to it.
05:54:49 <ivanm> quicksilver: yeah
05:55:01 <marcot> Is there a way to use haddock with literate haskell without having to include > -- ?
05:55:06 <wli> ivanm: Assembly for the kernel and a mix of very obscure (mostly ancient IBM) languages, e.g. REXX.
05:55:07 <quicksilver> ivanm: you might instead write a DSL/special purpose compiler
05:55:10 <quicksilver> in haskell.
05:55:12 <ivanm> exactly: C is used for microcontrollers, hence you make C work on it
05:55:23 <ivanm> quicksilver: hmmmm....
05:55:29 <FunctorSalad_> fwiw, appears like the answer to what I just asked is 'yes'
05:55:35 <quicksilver> ivanm: mainframes don't run linux.
05:55:41 <ivanm> but would laziness/GC be appropriate?
05:55:54 <FunctorSalad_> , runQ (let x = [|\x -> 2*x|] in [|($x,$x)|])
05:55:56 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Syntax.Exp))
05:56:05 <FunctorSalad_> , let x = [|\x -> 2*x|] in [|($x,$x)|]
05:56:07 <lunabot>  TupE [LamE [VarP x_0] (InfixE (Just (LitE (IntegerL 2))) (VarE *) (Just (...
05:56:10 <ivanm> quicksilver: hmmm.... well, I've never touched mainframes, just the other extremes
05:56:13 <FunctorSalad_> , more
05:56:14 <lunabot>  luna: Not in scope: `more'
05:56:29 <wli> Mainframes are actually obscure anymore. I doubt many people have very accurate ideas about what they are.
05:56:29 <wahjava> hi everyone, is Data.FiniteMap part of GHC 6.10.1 ?
05:56:42 <wli> wahjava: It's called Data.Map now
05:56:53 <ivanm> wli: exactly
05:57:05 <ivanm> FiniteMap? when was that ever part of haskell?
05:57:07 <wahjava> wli, okay, thanks
05:57:08 <ivanm> :/
05:57:26 <quicksilver> ivanm: I said a DSL/compiler in haskell.
05:57:34 <quicksilver> ivanm: you wouldn't run haskell on the microcontroller.
05:57:41 <quicksilver> ivanm: you'd run assembly language on the microcontroller
05:57:48 <quicksilver> generated by a carefully chosen set of combinators.
05:57:52 <quicksilver> code generation by haskell.
05:57:57 <quicksilver> i.e. a special puprpose compiler.
05:57:59 <ivanm> *nod*
05:58:11 <ivanm> quicksilver: but would you be writing _haskell_ to compile down?
05:58:15 <quicksilver> no
05:58:20 <quicksilver> you'd be writing a custom language
05:58:27 <quicksilver> which modelled the feature set of your controller very closely.
05:58:28 <ivanm> which was kinda my point
05:58:40 <quicksilver> don't want to port the MONSTER which is the C language
05:58:45 <quicksilver> if you don't need 95% of its features
05:58:58 <quicksilver> and of the remaning part, 40% are not-really-quite-right.
05:59:27 <ivanm> *nod*
05:59:55 <wli> I have two thoughts, one of which is that C will mutate into something unrecognizable with systems programming usefulness, and the other having to do with the impacts of current events on computing in general.
06:00:09 <quicksilver> wli: only two thoughts? surely that's a slow day for wli ;)
06:00:48 <wli> They go in somewhat conflicting directions.
06:01:13 <wli> K&R to ANSI was a huge leap.
06:01:42 <wli> So serious change does happen over time.
06:02:21 <chessguy_work> > let try guess x | good_enough (guess x) = x | otherwise = try (improve (guess x)) x; my_sqrt x = try 1 x; improve guess x = (guess + (x / guess)) / 2; good_enough guess x = abs (square guess - x) < 0.001 in my_sqrt 4
06:02:21 <gnuvince> The bitc people should write a gcc frontend
06:02:22 <lambdabot>   Not in scope: `square'
06:02:28 <dolio> FiniteMap is GHC 6.2-ish.
06:02:38 <ivanm> ahhh
06:02:39 <chessguy_work> > let try guess x | good_enough (guess x) = x | otherwise = try (improve (guess x)) x; my_sqrt x = try 1 x; improve guess x = (guess + (x / guess)) / 2; good_enough guess x = abs ((guess*guess) - x) < 0.001 in my_sqrt 4
06:02:40 <lambdabot>   Couldn't match expected type `Bool'
06:02:43 <ivanm> why "Finite" Map?
06:02:50 <ivanm> because you can't have an infinite one?
06:02:55 <dolio> Data.Map is finite, too.
06:03:46 <ivanm> and so they changed the name because it's bad enough you have to import qualified without having that ridiculously long name?
06:03:53 <doserj> ivanm: type InfiniteMap = (->)  :)
06:03:59 <wli> ivanm: It was strict, so only finite mappings could be reified.
06:03:59 <ivanm> heh
06:04:09 <dolio> I think Data.Map is a completely different implementation replacing the old one.
06:04:25 <wli> ivanm: It was too ancient for that to be an issue.
06:04:33 <kadaver> what do mainframes run?
06:04:52 <wli> OS/360, MVS, VM/ESA, etc.
06:05:02 <ivanm> ahhh, OK
06:05:18 <ivanm> wli: so old ancient stuff?
06:05:46 <wli> ivanm: Yeah. I think over 5 years old.
06:05:50 <chessguy_work> @type let g x y = abs ((x*x)-x)) < 0.001
06:05:51 <lambdabot> parse error on input `)'
06:05:59 <wli> ivanm: Before hierarchical libs, even.
06:06:06 <ivanm> so > 5 == ancient? :o
06:06:09 <chessguy_work> @type let g x y = abs ((x*x)-y)) < 0.001 in g
06:06:11 <lambdabot> parse error on input `)'
06:06:19 <chessguy_work> @type let g x y = abs ((x*x)-y) < 0.001 in g
06:06:20 <lambdabot> forall a. (Ord a, Fractional a) => a -> a -> Bool
06:06:40 <quicksilver> ivanm: they still exist. the successor to OS/360 is now called z/OS, I think.
06:06:42 <marcot> How can I add an apostrophe after an identifier in Haddock?  'Identifier''s, for instance, is not working.
06:06:56 <ivanm> marcot: triple ' ?
06:07:04 <ivanm> \' maybe?
06:07:11 <marcot> ivanm: \' doesnt work too..
06:07:54 <marcot> ivanm: 'Type'''s give me Type''s, where Type is not being linked.
06:08:09 <wli> chessguy: http://wli.pastebin.com/m581a0765  <-- I was root-finding earlier tonight myself.
06:08:12 <ivanm> *shrug* no idea
06:08:46 <kadaver> why OS/360 ?
06:08:58 <kadaver> and why dont they run linux? to big?
06:09:37 <wli> kadaver: They can run Linux, but there is very little real-life use of Linux on them.
06:10:06 <ivanm> kadaver: because it's already running
06:10:17 <ivanm> so why replace something that works?
06:11:03 <wli> kadaver: The people who buy them do so to get the 40 years of backward compatibility in addition to the usual performance concerns. The boot protocol on these things literally involves emulating paper tape.
06:12:33 <p_l|backup> also those things usually have stuff like self-healing cpus etc. :)
06:12:49 <wli> kadaver: To these guys, UNIX isn't evena young upstart; Multics was...
06:12:57 <ivanm> p_l|backup: so if I stab one, it magically repairs itself? :o
06:12:57 <lepassive> I want a simple full-commented bloomfilter implementation but not the one in RWH
06:13:08 <ivanm> lepassive: there's bloomfilter on hackage
06:13:44 <lepassive> ivanm, I don't want to use it, I want to understand it the datastructure
06:14:05 <ivanm> ahhh
06:14:09 <ivanm> that's another story then ;-)
06:14:16 <wli> p_l|backups: Yeah, there's a lot of super-HA stuff requiring extensive OS support. You'd basically have to spend 30-40 years reorganizing your kernel to do similar.
06:14:17 <ivanm> IIRC, there's a blog article about this...
06:14:19 <p_l|backup> ivanm: actually all cpu modules contain two redundant units that execute the same instruction stream and compare result, if they start to differ, all caches are cleaned, cpu resetted etc. and they reexecute failed operation. If it fail again, the system calls home for a replacement unit and switches processes to other units
06:14:58 <ivanm> p_l|backup: oh, so it tries to detect possible failures, but doesn't actually heal? :o
06:14:59 <ivanm> :(
06:15:12 <p_l|backup> the cpus are hotpluggable, connected by fiber optic cables. Like blades, but predate them :)
06:15:16 <wli> That doesn't sound like one of IBM's.
06:15:30 <wli> Maybe it is and I just don't know it.
06:15:38 <p_l|backup> wli: That's the current top-of-the line S/390 :)
06:15:40 <quicksilver> if it finds a failure it sends an android back in time to kill the chip designer who made the mistake.
06:15:44 <quicksilver> brutal but effective.
06:15:46 <wli> Hotpluggability of IBM's CPU's I do know about.
06:16:12 <p_l|backup> But uber-HA has some bad manpower results...
06:16:17 <ivanm> quicksilver: well, it won't make it fixed...
06:16:42 <quicksilver> it makes it never have happened!
06:16:47 <ivanm> especially if the guy who made the mistake did everything else for that chip (including the android sending part)
06:16:48 <wli> p_l: Some of the users have deep enough pockets not to care about that, either.
06:17:07 <p_l|backup> wli: I meant something different with that :)
06:17:10 <ivanm> quicksilver: is this related to the quantum haskell causing time travel we were discussing the other day? ;-)
06:17:23 <quicksilver> most of the applications run on these machines in actual fact run just as well on a $299 dell laptop.
06:17:26 <quicksilver> but don't tell anyone, please :)
06:17:49 <ivanm> heh
06:17:52 <ivanm> quicksilver: job security? ;-)
06:17:54 <p_l|backup> quicksilver: except that your dell laptop doesn't survive being blown apart by military :)
06:18:10 <quicksilver> No. I strive to avoid that situation.
06:18:13 <wli> ... or irradiation
06:18:13 <quicksilver> with, so far, 100% success.
06:18:26 <quicksilver> (incidentally I don't have a dell laptop. I'd never buy one of them!)
06:18:37 <ivanm> quicksilver: I quite like my Dell Vostro 1200
06:18:50 <p_l|backup> One of the adverts I had seen for VMS included a distributed cluster achieving zero downtime in face of one of the datacenters getting blown to bits
06:18:53 <ivanm> apart from 64bit not working for some reason (possibly due to the shared mem with video)
06:19:42 <p_l|backup> the real problem with those super-stable, unbreakable machines is that some people don't understand that you need to have someone to take care of them..
06:20:01 <ivanm> p_l|backup: someone who knows COBOL!
06:20:05 <quicksilver> they're like racehorses.
06:20:06 <p_l|backup> ivanm: not necessarily
06:20:10 <kadaver> lepassive: wikipedia has a good one. i amwriting a hashtable a C it doesnt seem much harder to write a bloom filter ocne thats finsihed
06:20:15 <ivanm> that's where the _real_ money is at, since no-one in their right mind _wants_ to know COBOL
06:20:16 <ivanm> :s
06:20:23 <quicksilver> I thought the real money was in SAP
06:21:06 <FunctorSalad_> to be honest my only knowledge about COBOL ist from all the sarcastic references to it :)
06:21:10 * vixey still feels like 'real money' is a contradiction
06:21:17 <ivanm> quicksilver: OK, the not-quite-so-real money is in COBOL
06:21:18 <p_l|backup> I heard a story about a NonStop cluster finally shutting down when a datacenter ran out of diesel after some ridiculous outage. The company didn't knew how to bring it back, despite it being a critical system, since they fired the last sysadmin of those a year earlier
06:21:23 <wli> p_l: I think there was something about Pentagon waste I saw over 5 years ago where actual trials for computers and/or clusters surviving in various senses are done.
06:21:24 <ivanm> vixey: heh
06:21:44 <ivanm> @remember vixey [to me, it] still feels like 'real money' is a contradiction
06:21:45 <lambdabot> Done.
06:22:31 <lepassive> kadaver, I'll check its wikipedia entry, BTW Hashtable's implementation sounds bit easy(tried it with java)
06:22:41 <p_l|backup> basically, build a nearly unbreakable system, and get fired since you don't have anything to do...
06:23:06 <wli> p_l: Things like dropping printers off roofs and requiring that they finish the print job they're in the middle of.
06:23:07 <wli> p_l: Also throwing grenades into server rooms etc.
06:23:42 <p_l|backup> wli: I want one of those printers :3
06:24:08 <ivanm> wli: IIRC, the CIA disposes of HDDs by shooting them...
06:24:11 <wli> p_l: I've heard True Stories (TM) about AS/400's getting walled off to where they're physically inaccessible.
06:24:42 <p_l|backup> wli: a coworker once told about finding an ethernet cable ending in the wall...
06:25:09 <EvilTerran> ivanm, i have a friend who does that
06:25:30 <ivanm> I've heard of someone that turns HDDs into hangers to put into his aviary
06:25:44 <p_l|backup> ivanm: hdds are disposed of with drills. BOFHs prefers termite, though :)
06:26:01 <FunctorSalad_> ivanm: I read "hangar" there.
06:26:12 <quicksilver> p_l|backup: thermite?
06:26:15 <ivanm> ummm.... how would termites dispose of HDDs?
06:26:21 * quicksilver has never seen a termite dispose of an HDD>
06:26:21 <wli> p_l: The AS/400 story was actually kind of lame. Basically they were doing rewiring and discovered that the thing had been walled off. It never went down until brought down for the rewiring effort.
06:26:23 <p_l|backup> *thermite
06:26:25 <wli> Thermite
06:26:26 <ivanm> since last I checked, HDDs weren't made of wood...
06:26:29 <FunctorSalad_> (to put his aviation equipment into)
06:26:34 <ivanm> FunctorSalad_: heh
06:27:22 <p_l|backup> wli: I heard of another case of "oh, this is just furniture, I can get those network cables to connect this $NEWIMPORTANTSERVER
06:27:36 <wli> p_l: They took the wall out, discovered a whole load of servers still running since the room got walled off (not just AS/400's), etc.
06:27:49 * FunctorSalad_ thought writing a template haskell differentiator should be easy, but way too much feature creep potential there ;)
06:27:54 <p_l|backup> wli: 5 minutes later they've got *very* angry calls from stock exchange
06:27:57 <ivanm> wli: heh
06:28:26 <wli> p_l: Which one?
06:28:36 <marcot> Is there a nub variation which works like UNIX uniq, which removes only duplicates if they're in sequence?
06:28:42 <p_l|backup> wli: I think it was in NYC :>
06:28:56 <kadaver> p_l: isnt that the problem with IT, the better you do your jbo the less you are needed-> why would peopel thgen be interested in doing a good job and using good tools?
06:29:02 <FunctorSalad_> (differentiate 't [| exp (2*t) |] = [| \t' -> 2*exp (2*t') |])
06:29:05 <vixey> oxymoron
06:29:09 <wli> marcot: map head . group
06:29:18 <ivanm> marcot: you mean as in uniq [1,2,3,1,1] = [1,2,3,1] ?
06:29:26 <marcot> wli: good.  thanks.
06:29:35 <ivanm> oh, yeah, that would work
06:29:48 <marcot> > concatMap head $ group [1, 2, 3,  1, 1]
06:29:49 <lambdabot>       No instance for (Num [b])
06:29:50 <lambdabot>        arising from the literal `1' at <inter...
06:29:51 <ivanm> FunctorSalad_: that's mean to work for any mathematical function? :o
06:30:01 <ivanm> marcot: no, not concatMap
06:30:09 <ivanm> > map head $ group [1,2,3,1,1]
06:30:10 <lambdabot>   [1,2,3,1]
06:30:10 <marcot> sure..
06:30:14 <p_l|backup> oh, and the NonStop cluster that was in WTC had been shaken rather badly during a bomb attack. It didn't stop working, despite cabinets lying in rather different positions :)
06:30:17 <marcot> thanks.
06:30:30 <FunctorSalad_> ivanm: yes. with vector space domain, in fact. no wait, into *any* differentiable manifold etc. etc.
06:30:32 <ivanm> if you _really_ want to use concatMap, then it's concatMap (return . head) ... ;-)
06:30:38 <ivanm> FunctorSalad_: :o
06:30:48 <FunctorSalad_> err codomain
06:30:55 <ivanm> so you're turning TH into a symbolic algebra manipulator?
06:31:00 <FunctorSalad_> I was willing to restrict the domain to float
06:31:05 <wli> concatMap (take 1) . group
06:31:05 <ivanm> heh
06:31:11 <ivanm> so no complex? :(
06:31:14 <FunctorSalad_> but if you want to exploit the chain rule you need arbitrary domains anway :(
06:31:31 <ivanm> wli: well, that will also work in the weird case that group misbehaves and creates an empty list...
06:32:01 * ivanm wonders if there's any way to "prove" group won't return an empty sub-list without looking at its source, or otherwise to specify in the type system that group won't do such a thing
06:32:11 <ivanm> _that_ (the latter) would be cool
06:32:19 <FunctorSalad_> ivanm: it wouldn't work with *any* function, I was just conceiving of an ad-hoc list of rules like that
06:32:35 <quicksilver> ivanm: data NonEmptyList = Cons a [a]
06:32:36 <ivanm> (you could possibly do so by having data NonEmptyList a = NEL a [a] ... )
06:32:42 <ivanm> FunctorSalad_: :(
06:32:42 <quicksilver> ivanm: but it's not very convenient.
06:32:50 <ivanm> quicksilver: heh, yeah, but I meant using normal lists
06:32:52 <wli> FunctorSalad: There's a bunch of stuff about differential rings on this front.
06:33:08 <ivanm> haskell's polymorphic strong static typing doesn't go far enough!
06:33:41 <wli> FunctorSalad: I've been trying to figure out how any of the symbolic algorithms are extended to work (or if they are) for Jacobian elliptic functions.
06:34:56 <FunctorSalad_> wli: maybe it would be less work to just differentiate symbolic-expression ADTs and run an eval, rather than trying to differentiate quoted pieces of arbitrary haskell expressions
06:35:21 <FunctorSalad_> hadn't really thought it through ;)
06:35:34 <wahjava> wli, so FiniteMap is no more available in GHC, and we've to use Map instead, hmm...?
06:35:39 <quicksilver> there is also automatic differentiation.
06:35:48 * wahjava is going through YAHT's Parsec example.
06:35:58 <wli> FunctorSalad: They focus primarily on what are called monomial extensions of a differential ring, and the way things are generalized in the literature isn't very relevant to computation.
06:36:19 <wli> FunctorSalad: That sounds very different.
06:36:36 * FunctorSalad_ doesn't know what a differential ring is :(
06:36:59 <FunctorSalad_> ring with a derivative operator satisfying the leibniz rule?
06:37:18 <wli> FunctorSalad: That's easy. Basically it's a set of functions where if f, g are in R then so are f*g, f+g, and f' and g'.
06:37:37 <wli> FunctorSalad: Yeah, it satisfies the Leibniz rule, too.
06:37:51 <rittyan1> everytime I read #haskell I am feeling myself a 13y-old boy
06:38:09 <rittyan1> probably because I was studying laws instead of math and physics
06:38:11 <FunctorSalad_> wli: oh wait, now I remember about differential algebras from the context of manifolds
06:38:30 <FunctorSalad_> (algebra of differential forms)
06:39:00 <wli> FunctorSalad: Mostly things start from Q(x), rational functions with rational coefficients, and start extending it in various ways, basically with e^f, log(f), or roots of algebraic equations.
06:40:11 <wli> FunctorSalad: Those are called elementary extensions. Then you can extend things with "transcendentals" where the derivative is given by a diffeq that allows you to eliminate occurrences of the derivative from the resulting expression somehow.
06:41:02 <wli> FunctorSalad: e.g. t = tan(x) is given by the diffeq t' = t^2 + 1
06:41:11 <FunctorSalad> *nod*
06:42:25 <wli> FunctorSalad: The stuff I can find docs on only covers the 1D case, that is, where a single variable's derivative can be expressed as a polynomial in the original variable.
06:43:32 <wli> FunctorSalad: Jacobian elliptic functions would be 3 transcendentals at once and a constant k (which might already be in the field of constants) so that s' = c * d, c' = - s * d, d' = - k^2 * s * c
06:43:55 <FunctorSalad> wli: that's totally over my knowledge :)
06:44:22 <dolio> e^f and log(f) aren't defined with differential equations?
06:44:40 <wli> dolio: They're considered elementary extensions.
06:44:46 <vixey> e^x can be defined by infinite series
06:45:13 <wli> This isn't R[[x]]
06:46:59 <FunctorSalad> originally I just wanted to draw some stuff in opengl requiring derivatives but I got carried away a bit :-(
06:47:30 <quicksilver> heh
06:47:41 <quicksilver> for that purpose I'd have thought automatic differentiation was more appropriate.
06:48:10 <FunctorSalad> maybe I should just leave it at newtype CurveC2 = CurveC2 (Float -> (Vec3,Vec3,Vec3)) ;)
06:48:25 <FunctorSalad> quicksilver: is that a technical term?
06:49:02 <FunctorSalad> *looks it up in wiki* I see
06:49:51 <Saizan> (anyone has .tex snippets with inference rules?)
06:50:11 <quicksilver> FunctorSalad: yes.
06:50:35 <quicksilver> FunctorSalad: it's particular simple to implement in haskell if you don't mind abusing Num instances slightly.
06:50:40 <quicksilver> I think there is a good blog post about it
06:50:53 <Saizan> there's a library too, iirc, from conal
06:51:09 <quicksilver> FunctorSalad: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
06:51:09 <ejt> and a paper, from Conal again
06:51:16 <quicksilver> augustss++
06:51:20 <quicksilver> conal++
06:51:20 <quicksilver> ;)
06:51:55 <FunctorSalad> Saizan: vector-space?
06:52:19 <p0l0na1sE> are there resources for learning haskell for one with a strong mathematics background
06:52:29 <p0l0na1sE> to which you cn direct me
06:53:04 <Saizan> FunctorSalad: that sounds like it
06:53:32 <vixey> @where LYAH
06:53:32 <lambdabot> www.learnyouahaskell.com
06:53:34 <vixey> p0l0na1sE:  ^
06:53:48 <p0l0na1sE> thank you
06:54:08 <Saizan> the gentle introduction too, i'd think (or is that more for ML background?)
06:54:28 <ejt> gentle introduction is my favourite
07:00:43 <FunctorSalad> hehe aren't these automatic differentiaton pairs exactly the same concept as tangent vectors?
07:12:44 <vixey> bah !!
07:14:06 <LeCamarade> What, again, is the fate of laziness in Haskell'?
07:14:43 <wli> LeCamarade: There to stay.
07:14:45 <ivanm> LeCamarade: it will stay, presumably
07:15:08 <ivanm> haskell without laziness is like ....... actually, I don't know what it's like :s
07:15:08 <vixey> I thought Haskell' is just specifications for some of these extensions to haskell
07:15:20 <vixey> not really any change - right?
07:15:33 <LeCamarade> 'Cause I depend on it a little too much. In production code.
07:15:41 <wli> Haskell' is very conservative. It probably won't even cover all of those in active use.
07:15:47 <ivanm> vixey: it is a gradual upgrade, rather than a complete rewrite
07:15:54 <byorgey> LeCamarade: Haskell without laziness is like a well without water.  Like an eagle with no wings.
07:16:05 <ivanm> LeCamarade: how can you depend on laziness too much? :o
07:16:18 <LeCamarade> I want, also, to thank the GHC team: I compiled with 6.10 (latest) today, sans glitches, an app that was written for 6.4. :-)
07:16:29 <wli> byorgey: Like a Wendy's hamburger with no beef.
07:16:36 <ivanm> "oi, haskell, here's a function to solve the riemann hypothesis, I expect you to be able to solve it when I ask you to!"
07:16:36 <byorgey> hehe
07:16:37 <ivanm> ;-)
07:16:56 <ivanm> LeCamarade: no exception changes or anything? :o
07:16:59 <LeCamarade> ivanm: I write all my declarations in one place, then their uses below.
07:17:00 <byorgey> like a Wendy's milkshake with no milk.
07:17:00 <ivanm> that's amazing!
07:17:15 <ivanm> byorgey: oh, so it uses that artificial soya stuff?
07:17:27 <LeCamarade> ivanm: I only had to stop assuming that Data.Map.lookup didn't return a Monad, which is a sad loss.
07:17:27 <byorgey> ivanm: no, all it has is 'shake'
07:17:45 <LeCamarade> I used to treat that monad as a list. But now it returns Maybe.
07:17:49 <ivanm> LeCamarade: I think the issue was that too many monads take "fail" as throwing an irrecoverable error
07:17:59 <ivanm> byorgey: as in it shakes your hand?
07:18:20 <Saizan> maybeToList
07:18:24 <quicksilver> :t maybeToList
07:18:25 <lambdabot> forall a. Maybe a -> [a]
07:18:37 <quicksilver> LeCamarade: you could have used maybeToList . lookup k
07:18:40 <quicksilver> if that's what you wnated.
07:18:43 <vixey> :t (>=>)
07:18:44 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
07:18:55 <LeCamarade> I just let it be Maybe. Maybe TheyBringItBack. :-(
07:19:05 <LeCamarade> I used it thus:
07:19:19 <ivanm> a non-usage? :o
07:19:21 <vixey> :t (>>= return)
07:19:21 <ivanm> ;-)
07:19:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
07:19:28 <LeCamarade> (DM.lookup k m) ++ (DM.lookup ...)
07:19:35 <ivanm> vixey: isn't that half of one of the monad laws?
07:19:54 * dolio finally gets around to reading Oleg's response to "typeOf for polymorphic value".
07:20:03 <ivanm> LeCamarade: so now you use catMaybe or something?
07:20:12 <dolio> Hey, you just have to turn on overlapping and incoherent instances. How tame. :)
07:20:22 <LeCamarade> But you've got to admit it is terrifyingly neat to return a Monad in that situation. I do it for all my code that otherwise would have returned Maybe.
07:20:37 <ivanm> dolio: "and incoherent"? so you can't understand what they're saying?
07:20:50 <LeCamarade> ivanm: No, I just used case and so on. But it was in only two spots.
07:21:02 <ivanm> LeCamarade: I asked about that here when they did that changeover, and was told it was a bad idea due to fail :(
07:21:13 <LeCamarade> May I note, also, that I compiled for Windows with one clean sweep.
07:21:18 <ivanm> and that you should explicitly use Maybe, Either String, etc.
07:21:25 <LeCamarade> It was great. GHC rocks.
07:21:26 <ivanm> LeCamarade: :o
07:21:38 <dolio> I forget what exactly incoherent instances does. It's something like allowing GHC to make arbitrary decisions even when two equally good overlapping instances apply.
07:21:45 <ivanm> ahhh
07:21:52 <ivanm> "pick a random instance"
07:21:53 <ivanm> ;-)
07:21:58 <Saizan> why gmail never manages to get oleg put oleg's emails in the right thread? no reply-to?
07:22:05 <ivanm> so you'll never know _what_ your code will do for this compile! ;-)
07:22:07 <EvilTerran> "pick the instance that appears lexically first", iirc
07:22:08 <LeCamarade> fail is not bad. They should have added to the docs of Control.Monad. I have lost one Haskell brag point, but oh well.
07:22:11 <ivanm> Saizan: could be
07:22:34 <ivanm> LeCamarade: most monads have fail = error, IIRC
07:22:44 <dolio> My mail client always puts them at top-level, too.
07:22:56 <quicksilver> LeCamarade: even if fail was not bad, (and it is actually horrifically bad), it still wouldn't be the right choice for Map.lookup
07:23:01 <ivanm> byorgey says bad things about fail in Monad in the typeclassopedia (I didn't get up to reading why it's bad, just that it was bad)
07:23:04 <quicksilver> @quote arbitrary
07:23:04 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
07:23:12 <quicksilver> LeCamarade: ^^ mckinna has it.
07:23:20 <ivanm> quicksilver: oh? why not?
07:23:33 <quicksilver> because there is no extra information conveyed.
07:23:39 <LeCamarade> quicksilver: A compiler should nake arbitrariness shrink, not the programmer.
07:23:58 <ivanm> we need an "CaptureError" class, that has instances for Maybe, Error String and [] just for these situations
07:24:06 <ivanm> so you can choose which one of those you want
07:24:28 <dolio> ivanm: He uses them so that "data W = forall a. W a ; class C a where op :: a -> Int ; instance C a where ... ; instance C Bool where ... ; ... case foo of W x -> op x" is well typed.
07:24:35 <dolio> Which seems fairly sketchy to me.
07:24:48 <ivanm> quicksilver: not sure what you're saying there wrt that quote...
07:25:08 <ivanm> where does "initial" come from for lookups, etc.?
07:25:08 <quicksilver> ivanm: (MonadWithFail m) => m v is no better than Maybe v
07:25:08 <amaron> I'm using gtk2hs for my project, and after upgrading glade to ver. 3.6 glade output is no longer compatibile with gtk2hs 0.10.0, I have segmentation fault
07:25:17 <quicksilver> ivanm: there is precisely one thing that can go wrong.
07:25:22 <quicksilver> (the element may not be there)
07:25:33 <quicksilver> the situation is precisely one thing being wrong is precisely what Maybe models
07:25:48 <ivanm> quicksilver: well, I'm thinking of replacing Maybe with Either String in my code so as to create an error log, etc.
07:25:49 <quicksilver> (but has nothing do with monads, at all)
07:25:55 <ivanm> in which case you _do_ have more information
07:26:01 <quicksilver> ivanm: it's trivial to "promote" a maybe to an Either
07:26:04 <ivanm> rather than just knowing that it fails
07:26:06 <quicksilver> for when you do have that information.
07:26:22 <ivanm> quicksilver: well, yes, but how can you let the user of your library choose which they'd prefer?
07:26:27 <wli> quicksilver: Then there are lists, where "the" element is not unique, but anyway.
07:26:32 <quicksilver> ivanm: I do.
07:26:39 <FunctorSalad> quicksilver: oh no more mission creep :o "The problem of computing a full Jacobian of F:R^n -> R^m with a minimum number of arithmetic operations is [...] NP-complete."
07:26:43 <quicksilver> ivanm: they choose, by applying the appropriate combinator to the most general function.
07:26:45 <ivanm> quicksilver: oh? how?
07:27:00 <ivanm> quicksilver: ummmmm.... what?
07:27:07 <FunctorSalad> :)
07:27:27 <dolio> Geeze, that really does work.
07:27:35 <quicksilver> :t maybe (Left "key not found") Right
07:27:37 <lambdabot> forall b. Maybe b -> Either [Char] b
07:27:54 <quicksilver> ivanm: ^^ combinator which 'upgrades' Maybe into either string, providing an appropriate error message.
07:27:59 <quicksilver> call that "withError"
07:28:01 <ivanm> quicksilver: yes, but what happens if it's an inner error?
07:28:11 <ivanm> it's easier to convert Either String -> Maybe
07:28:13 <quicksilver> :t withError s = maybe (Left s) Right
07:28:15 <lambdabot> parse error on input `='
07:28:17 <ivanm> @djinn Either b a -> Maybe a
07:28:17 <lambdabot> f a =
07:28:18 <lambdabot>     case a of
07:28:18 <lambdabot>     Left _ -> Nothing
07:28:18 <lambdabot>     Right b -> Just b
07:28:19 <quicksilver> rubbish
07:28:26 <quicksilver> if there was more than one thing that could go wrong
07:28:30 <quicksilver> then Maybe would have been the wrong type.
07:28:31 <dolio> Apparently overlapping instances is sufficient to make that work. No incoherent instances needed.
07:28:40 <quicksilver> I said Maybe is the right type when *exactly* one thing can go wrong.
07:28:46 <dolio> No wonder quicksilver thinks they're evil. :)
07:28:46 <quicksilver> which is the case with Map.Lookup.
07:29:06 <quicksilver> when multiple things can go wrong then some variation of Either probably is the right type, I agree.
07:29:16 <ivanm> quicksilver: why? say I'm doing a two-step parsing of output (had to do something like this for hackport), where if either step fails it returns Nothing
07:29:27 <ivanm> quicksilver: ahhh, OK
07:29:38 <quicksilver> and it scales nicely
07:29:57 <quicksilver> do x <- firstThing `withError` "first thing went wrong"
07:30:01 <Ferdirand> strips away much utility of the Maybe monad, though. no ?
07:30:07 <quicksilver> y <- secondThing `withError` "second thing went wrong"
07:30:10 <ivanm> I still think that in some cases you sould let the library user choose which type to use, such as usage of [a] vs Maybe a for output
07:30:17 <ivanm> as it might make the calling of that function nicer
07:30:24 <quicksilver> ivanm: here I seemlessly join two simple things, written in Maybe, into something in Either string
07:30:26 <wli> I've made my own error types with various error codes and noMsg/strMsg constructors to make the Error instance fly.
07:30:33 <quicksilver> assigning a correct error messages to each type
07:30:37 <ivanm> quicksilver: *nod*
07:30:43 <quicksilver> (you could use a proper type instead of string, that was for easy illustration)
07:30:43 <ivanm> @hoogle withError
07:30:44 <lambdabot> No results found
07:30:59 <quicksilver> these combinators scale, they combine nicely, they allow elegant error propogation and name re-writing.
07:31:02 <quicksilver> what's not to like?
07:31:10 <FunctorSalad> . o O ( ... MoanadFail m where moan :: ... )
07:31:22 <ivanm> quicksilver: well, it would help if I knew what a combinator was ;-)
07:31:56 <quicksilver> class Quicksilver where rant :: ...; instance Quicksilver (MonadsWithFail); instance Quicksilver (OverlappingInstances)
07:32:09 <wli> A combinator is a lambda form with no free variables.
07:32:26 <quicksilver> ivanm: a combinator is when you avoid using explicit lambdas, basically
07:32:39 <ivanm> ahhhh
07:32:52 <quicksilver> building up complex structures by combining together higher order functions (typically) without needing explicit use of \
07:33:09 <quicksilver> map is a combinator, so is my withError, and so on.
07:33:26 <ivanm> so partial application (or whatever it's called) can be thought of as a really simple/basic combinator? (e.g. map succ vs map (\x -> succ x))
07:34:39 <yrlnry> a combinator is a function whose value is obtained only by applying the arguments to one another in some combination.
07:35:05 <yrlnry> I came in in the middle, so perhaps that isn't pertinent.
07:35:16 <wli> The combinatory style is often carried out with setting up long composition pipelines.
07:35:22 <ivanm> *nod*
07:35:31 <ivanm> whoops, it's rather late here :s
07:35:39 * ivanm -> land of nod
07:36:12 <wli> e.g. runWriter . flip evalStateT foo . flip runContT return . callCC . runReaderT . rep
07:36:28 <ivanm> EvilTerran: do you believe me that it's late? ;-)
07:36:42 <EvilTerran> ah, half past midnight's not that late :P
07:37:15 <ivanm> EvilTerran: when I've been going to bed after midnight and getting up before 8 for the past week, I consider it to be late ;-)
07:38:21 <EvilTerran> i'd see the 8am starts as too early, not the midnight finishes as too late ;]
07:38:41 <ivanm> EvilTerran: well, yeah...
07:38:50 <ivanm> these pesky people actually expect me to turn up and work :s
07:38:57 <EvilTerran> D:
07:39:08 <ivanm> (note that my dad says I should get up earlier, go to work earlier and leave earlier... what a stupid idea!)
07:39:42 <marcot> > :t (!!)
07:39:43 <lambdabot>   <no location info>: parse error on input `:'
07:39:50 <marcot> :t (!!)
07:39:52 <lambdabot> forall a. [a] -> Int -> a
07:40:07 <marcot> Why don't it uses Word, if negative index are not accepted?
07:40:23 <ivanm> Int is more convenient
07:41:10 <marcot> Why?
07:41:32 <wli> No need to import Data.Word, one char shorter, etc.
07:41:42 <ivanm> and most calculations are done using Int
07:41:45 <EvilTerran> Word wasn't part of the original report, was it?
07:41:47 <quicksilver> marcot: efficient compilation.
07:41:48 <quicksilver> sadly.
07:42:05 <dolio> Word doesn't exist in Haskell98.
07:42:07 <quicksilver> we throw our beautiful semantics down the drain of practicality.
07:42:13 <EvilTerran> really, it should be (!!) :: Integral i => [a] -> i -> a
07:42:13 <marcot> wli: I thought Word has the same size of Int.
07:42:16 <BMeph> wli: Don't forget, no support for Natural numbers in general.
07:42:22 <EvilTerran> ?type genericIndex
07:42:23 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
07:42:29 <wli> Compilation to efficient code or speed of codegen itself?
07:42:29 <vixey> @hoogle UInt
07:42:30 <lambdabot> Foreign.C.Types data CUInt
07:42:30 <lambdabot> Foreign.C.Types data CUIntMax
07:42:30 <lambdabot> Foreign.C.Types data CUIntPtr
07:42:39 <vixey> @hoogle Unsigned
07:42:39 <lambdabot> No results found
07:42:42 <ivanm> BMeph: is that natural numbers with or without 0? ;-)
07:42:47 <marcot> EvilTerran: thanks.
07:42:58 <wli> BMeph: Yeah, it's really irritating.
07:43:01 <kadaver> if a insetr into a hashtable is done with a key that is already there the standard way is to overwrite the previous value right?
07:43:20 <wli> kadaver: Rephrase please.
07:43:24 <marcot> quicksilver: Why is Int more efficient than Word?
07:44:05 <marcot> kadaver: If the key is already present in the map, the associated value is  replaced with the supplied value. insert is equivalent to  insertWith const.
07:44:23 <quicksilver> marcot: because Int is what your CPU supports.
07:44:54 <marcot> kadaver: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Ainsert
07:45:01 <thomastc> Word will just do the computation in an Int, then truncate the result
07:45:29 <marcot> thomastc: Is this what happens in unsigned int in C?
07:45:29 <quicksilver> thomastc: Word has a greater range than Int.
07:45:33 <BMeph> ivanm: I consider "Natural" numbers as [0..], and Z+ as [1..]. I do know that "Natural" is a fuzzy definition.
07:45:37 <marcot> quicksilver: that's what I thought.
07:45:49 <marcot> quicksilver: So in C unsigned int has worse performance than int?
07:45:53 <quicksilver> thomastc: well, the ranges are non-comparable.
07:46:19 <quicksilver> marcot: no. C supports unsigned int natively.
07:46:33 <quicksilver> marcot: at least, it does on most arches.
07:46:36 <wli> signed vs. unsigned speed in registers is usually a small difference
07:46:43 <marcot> quicksilver: So why Haskell doesn't?
07:46:48 <marcot> > maxBound :: Int
07:46:50 <quicksilver> because no one has written the code to do so.
07:46:50 <lambdabot>   9223372036854775807
07:46:52 <quicksilver> as far as I know.
07:46:58 <marcot> > maxBound :: Word
07:47:00 <lambdabot>   18446744073709551615
07:47:28 <thomastc> > 2**63 - 1
07:47:29 <lambdabot>   9.223372036854776e18
07:48:07 <thomastc> ah so Word is 64 bits... thought that it would be two bytes... as is the common definition of a word in other languages
07:48:47 <marcot> > fromIntegral (maxBound :: Word) / fromIntegral (maxBound :: Int)
07:48:48 <lambdabot>   2.0
07:48:53 <wli> No, it's whatever fits into an integer register.
07:49:22 <quicksilver> hmm
07:49:28 <quicksilver> actually GHC.Word does have unboxed types.
07:49:34 <quicksilver> I think I'm entirely wrong.
07:49:43 <quicksilver> I think GHC can compile Words natively.
07:49:55 <quicksilver> although I see some bug reports about strictness analysis and RULES.
07:51:12 <dolio> @src Word
07:51:12 <lambdabot> Source not found. My mind is going. I can feel it.
07:51:24 <dolio> data Word = W# Word#
07:51:46 <thomastc> haha that reply from the bot is awesome :D "daisy, daisy..."
07:51:47 <marcot> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016705.html
07:52:04 <quicksilver> so I think we fall back to the main reason being that Word isn't in haskell98
07:52:12 <quicksilver> although I doubt people would be that interested in changing it
07:52:26 <quicksilver> the 'fromIntegral' all over when you interoperated with Int would get old quick.
07:52:27 <wli> Nah, you've got to import a module and it's 1 char longer.
07:55:13 <marcot> quicksilver: what do you mean by get old?
07:56:20 <quicksilver> marcot: I mean, would become annoying.
07:56:35 <BMeph> thomastc: Word and Int are "implementation-dependent". Its size is whatever's native to the machine, as wli said.
07:57:42 <thomastc> so Int is the machine's native size, and Word is twice that size?
07:57:53 <dolio> Word is unsigned.
07:57:57 <dolio> Int is signed.
07:58:12 <Philippa_> there's a minimum size in H98, isn't there?
07:58:24 <dolio> Yeah. Minimum Int size is 30 bits.
07:58:27 <wli> 29 bits
07:58:29 <Philippa_> plus you might lose a bit or two to tagging for the GC
07:58:32 <wli> 30? Okay.
07:59:02 <Philippa_> if you want a known-size int or word, there're types for that
08:02:01 <vixey> if you have two numbers that are tagged like that, how do you add them?
08:02:34 <wunki> OT: How would a Haskell type person look like, being strong, static and inferring? :)
08:03:24 <thomastc> like the "thinker" statue by rodin :P
08:03:30 <wunki> haha
08:03:59 <Botje> like the painting "the scream" because of all the type errors ;)
08:05:11 <wunki> :) Beautifull painting it is..
08:06:19 <maxote> > N0 = [0..]
08:06:20 <lambdabot>   <no location info>: parse error on input `='
08:06:46 <maxote> > let N0 = [0..] in N1 = [1..] in (N0,N1);
08:06:47 <lambdabot>   <no location info>: parse error on input `='
08:06:58 <EvilTerran> maxote, variable names have to start with a lowercase letter
08:10:14 <wli> Uppercase first letters mean either constructors or types.
08:10:20 <marcot> Is the GHC darcs repository inactive?
08:10:33 <Botje> aren't they using git now?
08:10:33 <marcot> In the GHC wiki there's a link to darcs.haskell.org, which seems to be down.
08:11:04 <Saizan> they are still using darcs
08:11:15 <marcot> Saizan: in another server?
08:11:49 <Saizan> no, if d.h.o is down something is wrong
08:12:00 <marcot> Saizan: it seems to be a problem with my dns, sorry.
08:12:15 <Saizan> yeah, it works for me
08:18:20 <FunctorSalad> @pl (\x -> (x.))
08:18:20 <lambdabot> (.)
08:18:28 <FunctorSalad> meh.
08:19:28 <quicksilver> what were you hoping for? :)
08:20:12 <centrinia> @pl flip (\f -> join . liftM f)
08:20:13 <lambdabot> (>>=)
08:20:20 <centrinia> Hmm.
08:20:35 <FunctorSalad> quicksilver: nothing, was just meh'ing about my sillyness ;)
08:22:41 <rittyan1> is it okay that I can't divite Ints? I have a function that returns the Int type, and when I try to apply '/' on its result, I get 'No instance for (Fractional Int)
08:22:56 <ejt> use `div`
08:22:58 <rittyan1> *divide
08:23:00 <idnar> rittyan1: if you want integer division, use div
08:23:06 <idnar> > 5 `div` 2
08:23:08 <lambdabot>   2
08:23:09 <rittyan1> oh I see (that is not obvious)
08:23:12 <rittyan1> thanks
08:23:18 <BONUS> just check for 0 beforehand
08:23:19 <rittyan1> yes it works :3
08:23:23 <BONUS> > 3 `div` 0
08:23:24 <lambdabot>   * Exception: divide by zero
08:23:25 <BONUS> oom
08:23:28 <FunctorSalad> @pl (\r t -> rmul  (m t) r)
08:23:28 <lambdabot> flip (rmul . m)
08:23:29 <BONUS> boom*
08:23:53 <FunctorSalad> @pl (\m r t -> rmul  (m t) r)
08:23:54 <lambdabot> flip . (rmul .)
08:24:15 <rittyan1> diffClockTimes sucks :< I am sorry to say that
08:24:25 <Feuerbach> @pl (\rmul m r t -> rmul  (m t) r)
08:24:25 <lambdabot> (flip .) . (.)
08:24:46 <rittyan1> TimeDiff has years, months and days, and yet diffClockTimes returns a TimeDiff with everything set to zero except seconds (big big value)
08:25:13 <temoto-alt> Is there any simplier way to do Int / Int than fromIntegral x / fromIntegral y ?
08:25:32 <quicksilver> rittyan1: that library is broken and obsolete
08:25:36 <quicksilver> rittyan1: use Data.Time.Clock
08:25:39 <rittyan1> quicksilver, what should I use? I use System.Time
08:25:48 <quicksilver> rittyan1: with the type UTCTime and `diffUTCTime`
08:26:03 <centrinia> :t on (/) fromIntegral
08:26:04 <lambdabot> forall b a. (Integral a, Fractional b) => a -> a -> b
08:26:31 <EvilTerran> > (f `on` g) x y :: Expr
08:26:32 <lambdabot>   Add a type signature
08:26:37 <EvilTerran> gah
08:26:43 <temoto-alt> What is "on" ?
08:26:48 <rittyan1> I so wish everything would have its 'Show' code
08:26:55 <centrinia> :t on
08:26:56 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:26:56 <EvilTerran> > ((f :: Expr -> Expr -> Expr) `on` g) x y
08:26:57 <FunctorSalad> :t (%) -- if a rational result is fine too
08:26:59 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
08:26:59 <lambdabot>   f (g x) (g y)
08:27:08 <EvilTerran> ?src on
08:27:09 <lambdabot> (*) `on` f = \x y -> f x * f y
08:27:37 <EvilTerran> (f `on` g) x y = f (g x) (g y)
08:28:44 <quicksilver> rittyan1: if you mean UTCTime, it does.
08:28:54 <quicksilver> rittyan1: it's just (weirdly) in a module called Data.Time.Format.
08:29:03 <quicksilver> rittyan1: dont really understand why they split it up like that :)
08:31:10 <rittyan1> oh, indeed
08:31:19 <rittyan1> quicksilver, a bug must be filed, I believe
08:31:27 <quicksilver> feel free.
08:31:39 <quicksilver> but the decision was taken deliberately, it wasn't  mistake.
08:31:44 <quicksilver> I just don't know why.
08:31:56 <rittyan1> then it can't be helped
08:32:26 <rittyan1> btw, 'substring x y xs = drop x $ take (x+y) xs' <- is there a better way?
08:32:52 <Saizan> splitAt
08:33:09 <Saizan> not so better..
08:33:18 <quicksilver> rittyan1: that's about what I would do.
08:33:25 <centrinia> substring x y = take y . drop x
08:33:27 <quicksilver> give or take off-by-one errors.
08:33:43 <Saizan> i'd drop first too
08:33:49 <centrinia> @pl \x y -> take y . drop x
08:33:50 <lambdabot> flip ((.) . take) . drop
08:33:57 <temoto-alt> I don't have "on" defined.
08:34:05 <temoto-alt> Must import something?
08:34:08 <centrinia> temoto-alt, import Data.Function
08:34:54 <rittyan1> centrinia, oh, that's simpler :-D
08:35:52 <temoto-alt> ghci could not find :load +Data.Function  :(
08:36:07 <quicksilver> temoto-alt: :m not :load
08:36:08 <centrinia> Use the pointless expression (flip ((.) . take) . drop)
08:36:10 <zachk> :module +Data.Function
08:36:13 <quicksilver> :load loads source files
08:36:17 <quicksilver> (or object files)
08:36:24 <temoto-alt> oh
08:36:24 <quicksilver> :m brings installed modules into scope
08:36:36 <zachk> > map (^3) [1..10]
08:36:37 <quicksilver> :m for libraries, :l for code you're working on now.
08:36:38 <lambdabot>   [1,8,27,64,125,216,343,512,729,1000]
08:36:39 <temoto-alt> That's why it didn't import Text.JSON!
08:37:30 <temoto-alt> quicksilver: thanks.
08:38:15 <zachk> > let f1 n=sum $ map (^3) [1..n] in let f2 n=n(n+1)(n+2)(n+3)`div`6 in f1 100==f2 100
08:38:17 <lambdabot>       Occurs check: cannot construct the infinite type:
08:38:17 <lambdabot>        a = a -> a -> ...
08:38:32 <vixey> n(n+1)(n+2)(n+3) is wrong
08:38:36 <zachk> > let f1 n=sum $ map (^3) [1..n] in let f2 n=n*(n+1)*(n+2)*(n+3)`div`6 in f1 100==f2 100
08:38:38 <lambdabot>   False
08:38:41 <zachk> too much maths
08:38:48 <vixey> > let f1 n=sum $ map (^3) [1..n] in let f2 n=(n*(n+1)*(n+2)*(n+3))`div`6 in f1 100==f2 100
08:38:50 <lambdabot>   False
08:39:47 <zachk> man im way off have to check my calculations. im doing an ubuntu upgrade so i have no ghci :-/ gogogo lambdabot
08:39:52 <centrinia> zachk, I don't think f2 should be quartic with respect to n.
08:39:55 <kadaver> ok som il told to invent a maybe monad in C. i should not return an itn from a ahshtable but a struct {value int; fail bool}
08:40:42 <Ferdirand> i don't think returning a struct is very portable
08:41:03 <zachk> > let f1 n=sum $ map (^3) [1..n] in let f2 n=n*(n+1)*(n+2)`div`6 in f1 100==f2 100
08:41:04 <lambdabot>   False
08:41:37 <centrinia> > 2*3 `div` 2
08:41:39 <lambdabot>   3
08:41:45 <zachk> > let f1 n=sum $ map (^4) [1..n] in let f2 n=n*(n+1)*(n+2)*(n+3)`div`24 in f1 100==f2 100
08:41:46 <lambdabot>   False
08:42:24 <hallongrottan> Is there a way to solve circular dependencies in funcion arguments? Function apa wants a lazy list as an argument, and generates a lazy list as output. Function bepa wants a lazy list as an argument, and also generates a lazy list as output. However, the apa argument is supposed to come from bepa, and vice versa. Is there a way to solve this?
08:42:40 <quicksilver> Ferdirand: pretty sure returning a struct was standardised in C99
08:42:40 <hallongrottan> apa and bepa are supposed to run forever
08:42:45 <zachk> > let f1 n=sum $ map (^3) [1..n] in let f2 n=n*(n+1)*(n+2)`div`6 in f1 100==f2 100
08:42:47 <quicksilver> Ferdirand: that's a little while ago now.
08:42:47 <lambdabot>   False
08:42:57 <zachk> hallongrottan: cycle
08:43:03 <hallongrottan> :t cycle
08:43:04 <lambdabot> forall a. [a] -> [a]
08:43:09 <hallongrottan> hmm
08:43:15 <zachk> > take 10 $ cycle [1..3]
08:43:17 <lambdabot>   [1,2,3,1,2,3,1,2,3,1]
08:43:22 <maltem> zachk: n(n+1)(2n+1)/6 is for the sum of squares
08:43:44 <BONUS> hallongrottan: if the two functions form a closed loop, how are you supposed to get anything out of them?
08:43:58 <zachk> > 2n+1??what
08:43:59 <lambdabot>   Not in scope: `??'Not in scope: `what'
08:44:15 <vixey> > let ying = 1 : yang ; yang = 0 : ying in (ying,yang)
08:44:17 <lambdabot>   ([1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
08:44:22 <hallongrottan> BONUS: one of the functions should output more than just the list
08:44:52 <hallongrottan> for example, a number or so
08:45:28 <jmcarthur> hallongrottan, can you hpaste what you have so far or explain in more detail what these functions are supposed to do?
08:45:34 <BONUS> then i dont think there should be a problem, laziness usually takes care of such stuff, like vixey demonstrated
08:45:35 <aleator> I've got a 60gb image and machine with 96gb of ram. Would people here think that I might be feasibly able to use haskell in processing that directly, without much c-code?
08:45:38 <doserj> > let f1 n = sum . map (^3) $ [1..n] in let f2 n = n*(n+1)`div`2 in f1 100 == (f2 100)^2
08:45:40 <lambdabot>   True
08:45:55 <centrinia> > (scanl (\x  y -> x+y^3) 9 [1..10]) &&& (map (\n -> (n*(n+1)*(2*n+1)) `div` 6)) $ [1..10]
08:45:56 <lambdabot>   Couldn't match expected type `a -> c' against inferred type `[b]'
08:46:05 <centrinia> > (scanl (\x  y -> x+y^3) 0) &&& (map (\n -> (n*(n+1)*(2*n+1)) `div` 6)) $ [1..10]
08:46:06 <zachk> > let f1 n=sum $ map (^2) [1..n] in let f2=n*(n+1)*(2*n+1)`div`6 in f1 100=f2 100
08:46:07 <hallongrottan> jmcarthur: i can paint the flow and paste!
08:46:07 <lambdabot>   ([0,1,9,36,100,225,441,784,1296,2025,3025],[1,5,14,30,55,91,140,204,285,385])
08:46:08 <lambdabot>   <no location info>: parse error on input `='
08:46:22 <zachk> > let f1 n=sum $ map (^2) [1..n] in let f2=n*(n+1)*(2*n+1)`div`6 in f1 100==f2 100
08:46:23 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `Expr'
08:46:25 <centrinia> > (scanl (\x  y -> x+y^2) 0) &&& (map (\n -> (n*(n+1)*(2*n+1)) `div` 6)) $ [1..10]
08:46:27 <lambdabot>   ([0,1,5,14,30,55,91,140,204,285,385],[1,5,14,30,55,91,140,204,285,385])
08:46:29 <vixey> doserj: cool
08:46:42 <jmcarthur> hallongrottan, are you familiar with using recursive let?
08:47:17 <vixey> hallongrottan: like  let (x, l) = (3, "xyz")
08:47:21 <centrinia> > (scanl (\x  y -> x+y^2) 0) &&& (map (\n -> (n*(n+1)*(2*n+1)) `div` 6)) $ [0..10]
08:47:22 <lambdabot>   ([0,0,1,5,14,30,55,91,140,204,285,385],[0,1,5,14,30,55,91,140,204,285,385])
08:47:36 <kadaver> in vim, how do I comment out a block?
08:47:42 <hallongrottan> how do you mean? currently the thought is to do: x <- compute something; xs <- recurse; return (x:xs)
08:48:04 <maltem> kadaver: 0 C-v jjj I -- ESC
08:48:07 <quicksilver> aleator: Depending on the kind of process you're doing.
08:48:27 <quicksilver> aleator: my first instinct is to leave it on the disk and just treat it as a random access file.
08:48:31 <zachk> > let f1 n=sum $ map (^2) [1..n] in let f2 n=n*(n+1)*(2*n+1) `div` 6 in f1 100==f2 100
08:48:33 <lambdabot>   True
08:48:34 <jmcarthur> @src cycle
08:48:35 <lambdabot> cycle [] = undefined
08:48:35 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:48:37 <zachk> finally
08:48:41 <quicksilver> aleator: if you really need it all in memory at once, mmap it, if your OS will mmap things that big.
08:48:42 <jmcarthur> @src repeat
08:48:42 <lambdabot> repeat x = xs where xs = x : xs
08:49:06 <aleator> quicksilver: Image alignment, keypoint detection.. and engineers want an fft.
08:49:09 <jmcarthur> hmm, those examples aren't complex enough to demonstrate what i want to show
08:49:46 <jmcarthur> hallongrottan, nevermind, just come up with a good way to explain what you want to do :)
08:50:15 <aleator> quicksilver: Most I can do in pieces, not all. I was just wondering if there exists tools that could be used to efficiently access binary data.
08:50:28 <centrinia> > take 15 $ let cycle' = concat . repeat in cycle' [1..3]
08:50:29 <hallongrottan> jmcarthur: will do, brb :)
08:50:29 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
08:50:38 <centrinia> > take 15 $ let cycle' = concat . repeat in cycle' []
08:50:53 <lambdabot>   thread killed
08:51:10 <wli> aleator: bytestring, hGetBuf/hPutBuf, Data.Binary
08:51:21 <doserj> vixey: apparently sum_{i=1..n} i^(2k+1) is a polynom in sum_{i=1..n} i, for every k.
08:51:44 <wli> Faulhaber?
08:51:53 <doserj> yes
08:52:44 <jmcarthur> centrinia, cycle = concat . repeat looks like a nice definition
08:52:57 <jmcarthur> hallongrottan, brb
08:53:36 <jmcarthur> ah n/m. in five minutes or so that will apply again though
08:55:27 <zachk> > let f=sum . map (^2) in f [1..5]
08:55:30 <lambdabot>   55
08:55:35 <aleator> wli, quicksilver: I'm just pondering. Haskell has good multiprocessor support, but I'm bit lost when it comes to efficient and clean mauling of binary data.
08:56:46 <hallongrottan> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2951
08:56:56 <hallongrottan> simplest i could come up with
08:57:17 <quicksilver> aleator: bytestring / foreignptr / ptr
08:58:38 <rio> > sum . map (^2) [1..5]
08:58:40 <lambdabot>   Couldn't match expected type `a -> [a1]'
08:58:58 <rio> right
08:58:58 <centrinia> > sum . map (^2) $ [1..5]
08:59:01 <lambdabot>   55
08:59:08 <jmcarthur> hallongrottan, I still don't quite understand. Are you wanting mutual recursion or concurrency?
08:59:33 <hallongrottan> jmcarthur: well, concurrency would be the ideal, but mutual recursion is sort of fine
09:00:02 <aleator> quicksilver: Any thoughts on uvector/arrays/parallel arrays?
09:00:04 <jmcarthur> for a concurrency problem i think using concurrency would probably be easier
09:00:27 <jmcarthur> mutual recursion in this case would be like rolling your own concurrency
09:00:56 <hallongrottan> oh, sounds a bit overkill :)
09:01:01 <jmcarthur> hallongrottan, have you used MVar or STM or anything like that before?
09:01:06 <jmcarthur> oh really?
09:01:09 <hallongrottan> :D
09:01:26 <hallongrottan> yes, that could be an alternative
09:02:05 <jmcarthur> i realize i have effectively told you to sidestep the problem though. would you rather try it with mutual recursion?
09:02:18 <hallongrottan> but doing things with STM would require the code to walk into IO
09:02:37 <jmcarthur> i admit i still don't quite understand the problem so i don't know if mutual recursion is even feasible
09:02:42 <quicksilver> aleator: I dont think they're designed for file IO. 5'm sure you could get something working.
09:02:58 <hallongrottan> jmcarthur: the ideal would be for cpu and ppu to feed each other lazy lists of shared memory
09:03:09 <hallongrottan> but that seems very hard to do
09:03:18 <jmcarthur> hallongrottan, which one gets it first?
09:03:32 <hallongrottan> well, that is the problem :)
09:03:35 <jmcarthur> brb
09:04:26 <hallongrottan> i wrote some code for running ppu and cpu one step at the time, and to exchange the memory between the steps
09:04:56 <hallongrottan> however, that is quite ugly
09:08:03 <zachk> @src enumFromTo
09:08:03 <lambdabot> Source not found. My brain just exploded
09:08:09 <zachk> @src enumerateFromTo
09:08:09 <lambdabot> Source not found. :(
09:08:13 <zachk> @src enumerate
09:08:13 <lambdabot> Source not found. Take a stress pill and think things over.
09:08:20 <zachk> @src enumerateFrom
09:08:20 <lambdabot> Source not found. My brain just exploded
09:08:43 <zachk> > let f n=[1..n] in f 3
09:08:46 <lambdabot>   [1,2,3]
09:08:57 <zachk> whats the regular name for that function
09:09:36 <vixey> enumFromTo 1
09:09:48 <zachk> @src enumFrom
09:09:48 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:10:10 <vixey> [a..] = enumFrom a
09:10:15 <vixey> [a..b] = enumFromTo a b
09:10:23 <vixey> [a,m..b] = enumFromToBy a m b -- I think
09:10:46 <vixey> why on earth do I know these things
09:10:46 <zachk> > let f=sum.map(^2).enumFrom in f 3
09:11:01 <zachk> because you are descended from one of the gods?
09:11:25 <zachk> > let f=sum.map(^2).enumFrom 1 in f 3
09:11:30 <lambdabot>   thread killed
09:11:35 <lambdabot>   Couldn't match expected type `a -> [a1]'
09:11:38 <maltem> vixey: enumFromThenTo
09:11:46 <vixey> thanks
09:12:30 <zachk> > let f=sum.map(^2).enumFromThen to  1 in f 3
09:12:32 <lambdabot>   Not in scope: `to'
09:12:40 <zachk> > let f=sum.map(^2).enumFromThenTo  1 in f 3
09:12:43 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t -> [t]'
09:12:48 <centrinia> Why isn't Enum a subclass of Bounded?
09:12:49 * zachk hits himself in the head with a frying pan 
09:13:05 <vixey> zachk: You wrote this: > let f n=sum.map(^2).[1..n] in f 3
09:13:14 <vixey> zachk: You should write this: > let f n=sum.map(^2)[1..n] in f 3
09:13:16 <doserj> centrinia: because of [1..]
09:13:23 <vixey> well that's wrong too isn't it
09:13:24 <maltem> centrinia: Because Enum should really be called DotDotNotation
09:13:34 <vixey> zachk: You should write this**: > let f n=sum.map(^2)$[1..n] in f 3
09:13:44 <zachk> > let f=sum.map(^2) $ enumFrom  in f 3
09:13:46 <lambdabot>   Couldn't match expected type `[a]'
09:14:08 <zachk> i am trying to get rid of my $ i use them way to much. i wish to become more pointless
09:14:17 <vixey> well I know what to do
09:14:22 <vixey> start at the beginning like
09:14:34 <vixey> > (enumFromTo 1) 3
09:14:38 <lambdabot>   [1,2,3]
09:14:45 <vixey> @let square = join (*)
09:14:47 <vixey> > (map square . enumFromTo 1) 3
09:14:50 <lambdabot>   Not in scope: `square'
09:14:51 <lambdabot>  Defined.
09:14:53 <zachk> > let f=sum.map (^2) $ enumFromTo 1 in f 3
09:14:56 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t -> [t]'
09:15:08 <zachk> > let f=(sum.map) (^2) $ enumFromTo 1 in f 3
09:15:10 <lambdabot>   Couldn't match expected type `[a]'
09:15:15 <vixey> zachk: Try to build it from the start like I started to do
09:15:20 <vixey> I bet this way will work
09:15:23 <zachk> > let f=sum $ map (^2) $ enumFromTo 1 in f 3
09:15:26 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t -> [t]'
09:15:35 <zachk> /me cries
09:15:45 <vixey> zachk, like this:
09:15:47 <vixey> > (enumFromTo 1) 3
09:15:49 <lambdabot>   [1,2,3]
09:15:51 <vixey> > (map square . enumFromTo 1) 3
09:15:53 <lambdabot>   [1,4,9]
09:15:54 <vixey> etc
09:16:13 <vixey> (I am using ()'s instead of let because I find that less obtrusive)
09:16:18 <jmcarthur> hallongrottan, i don't think that sounds ugly
09:16:24 <vixey> anyway the point is building it in steps
09:16:24 <hallongrottan> no?
09:16:29 <jmcarthur> not at all
09:16:30 <zachk> (sum.map (^2) enumFromTo 1) 3
09:16:39 <zachk> > (sum.map (^2) enumFromTo 1) 3
09:16:41 <lambdabot>   Couldn't match expected type `[a]'
09:16:41 <hallongrottan> jmcarthur: well that is the alternative then
09:16:43 <vixey> zachk: Start at the -beginning-
09:17:01 <hallongrottan> but it would have been much nicer with both functions running forever just feeding each other
09:17:09 <zachk> > (enumFromTo 1) 3
09:17:12 <lambdabot>   [1,2,3]
09:17:17 <jmcarthur> hallongrottan, that would be cool and elegant, sure, but i don't think not doing that is ugly
09:17:28 <hallongrottan> well, ok
09:17:28 <centrinia> > (join (.)) (+1) 2
09:17:31 <lambdabot>   4
09:17:44 <zachk> > (map (^2).enumFromTo 1) 3
09:17:46 <lambdabot>   [1,4,9]
09:18:15 <zachk> > (sum.(map (^2)).enumFromTo 1) 3
09:18:18 <lambdabot>   14
09:18:31 <zachk> there we go :D thanks vixey
09:18:39 <vixey> good :)
09:18:47 <vixey> you can write all programs this way
09:19:30 <zachk> yea i use $ alot but i find the pointfree style interesting and it seems to be less typing so I want to learn it
09:19:54 <vixey> zachk: About (.) vs ($)
09:19:58 <centrinia> All expressions should be pointfree.
09:20:13 <jmcarthur> > sum . map (^2) . enumFromTo 1 $ 3
09:20:16 <lambdabot>   14
09:20:19 <zachk> do they compile to faster code?
09:20:27 <jmcarthur> centrinia, i don't know about _all_...
09:20:31 <jmcarthur> zachk, usually, afaik
09:20:40 <vixey> properties of (.): f . id = f = id . f ; (f . g) . h = f . g . h = f . (g . h)
09:20:48 <vixey> properties of ($):  none
09:21:03 <zachk> so its better for algebraic reasoning
09:21:07 <jmcarthur> :t ($)
09:21:09 <vixey> yes
09:21:10 <lambdabot> forall a b. (a -> b) -> a -> b
09:21:15 <vixey> why does algebraic reasoning matter?
09:21:44 <vixey> I couldn't explain it myself, but it seems very important
09:21:47 <zachk> well ive seen from "programming in haskell" that you can do what looks to be little proofs on your code and it get to run better in bigO time
09:21:59 <vixey> ah yeah
09:22:04 <vixey> I've seen a couple things like this
09:22:04 <zachk> ive yet to master that book
09:22:10 <hallongrottan> jmcarthur: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2953#a2953
09:22:15 <hallongrottan> that is how we have it now
09:22:30 <centrinia> Algebraic reasoning is important because we already have a lot of tools to reason using algebra.
09:23:55 <jmcarthur> hallongrottan, all those 's make me think that a state monad of some sort might be nice, but it'd probably only be worth it if other functions suffer from the same problem
09:24:00 <quicksilver> algebraic properties make refactoring and modularisation nicer
09:24:05 <quicksilver> in particular, (.) being associative
09:24:16 <quicksilver> means you can 'chop out' any part of a (.) pipeline and give it a name for re-use.
09:24:24 <thomashartman1> @src sequence
09:24:24 <lambdabot> sequence []     = return []
09:24:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:24:25 <lambdabot> --OR
09:24:25 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:24:25 <hallongrottan> jmcarthur: yes, and they don't :)
09:24:49 <thomashartman1> @type sequence
09:24:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:25:07 <thomashartman1> @type foldM
09:25:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
09:25:56 <thomashartman1> @help
09:25:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:26:02 <thomashartman1> @list
09:26:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:26:53 <thomashartman1> @eval 2*2
09:27:01 <vixey> @pl 2*2
09:27:02 <lambdabot> 4
09:27:11 <thomashartman1> thx'
09:27:45 <thomashartman1> @eval sequence . map (id) [1,2,3,4]
09:27:59 <thomashartman1> @eval sequence . map (return . id) [1,2,3,4]
09:28:04 <thomashartman1> oops
09:28:10 <vixey> he :p
09:28:11 <thomashartman1> @pl sequence . map (return . id) [1,2,3,4]
09:28:12 <lambdabot> sequence . map return [1, 2, 3, 4]
09:29:00 <thomashartman1> that's wrong too.
09:29:19 <thomashartman1> @run 2
09:29:21 <lambdabot>   2
09:29:29 <thomashartman1> @run sequence . map (return . id) [1,2,3,4]
09:29:31 <lambdabot>   Couldn't match expected type `a -> [m a1]'
09:30:08 <thomashartman1> @run sequence . foldr (return . id) (return ()) [1,2,3,4]
09:30:10 <lambdabot>   Couldn't match expected type `[m a]' against inferred type `()'
09:30:16 <jmcarthur> hallongrottan, only suggestion i can think of with limited time is to change that big case statement to: maybe id (:) px =<< runNES ks cmem'' cpu' pmem' ppu'
09:30:29 <thomashartman1> @src mapM
09:30:29 <lambdabot> mapM f as = sequence (map f as)
09:30:51 <hallongrottan> jmcarthur: heh, extremely readable :)
09:30:59 <jmcarthur> yes :)
09:31:37 <thomashartman1> @run sequence . map (return . id) $ [1,2,3,4]
09:31:40 <lambdabot>       No instance for (Show (m [a]))
09:31:40 <lambdabot>        arising from a use of `show' at <...
09:31:47 <rovar> does anyone know if there is a ring-buffer / circular list type implementation for haskell?
09:31:52 <thomashartman1> @run putStrLn "meh"
09:31:54 <lambdabot>   * Exception: "<IO ()>"
09:32:07 <rovar> I know that's a bit low level, but I'm working on a low level protocol that needs to store a fixed history of buffers
09:32:23 <vixey> rovar: infinite list isn't ok ?
09:32:35 <rovar> so when a new one is added, the oldest is removed.. my current implementation uses Seq, where I add to the right and drop from the left
09:32:52 <vixey> you can implement it by two lists back to back
09:33:02 <thomashartman1> @type sequence . map (return . id) $ [1,2,3,4]
09:33:04 <rovar> vixey, no, because I'm building this list, it will actually end up infinite :)
09:33:05 <lambdabot> forall (m :: * -> *) a. (Num a, Monad m) => m [a]
09:33:24 <thomashartman1> @type ( sequence . map (return . id) $ [1,2,3,4] :: Maybe Int)
09:33:27 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
09:33:27 <lambdabot>       Expected type: Maybe Int
09:33:27 <lambdabot>       Inferred type: Maybe [a]
09:33:33 <thomashartman1> @type ( sequence . map (return . id) $ [1,2,3,4] :: Maybe [Int])
09:33:36 <lambdabot> Maybe [Int]
09:33:38 <rovar> vixey: what do you mean by two lists back to back?
09:33:42 <thomashartman1> @run ( sequence . map (return . id) $ [1,2,3,4] :: Maybe [Int])
09:33:45 <lambdabot>   Just [1,2,3,4]
09:33:55 <vixey> x --> (xs,ys:<:y) = (x:>:xs,ys)
09:34:05 <vixey> x --> (xs,[]) = ([x],reverse xs)
09:34:06 <rovar> i was thinking about using an MArray and shifting all of the values for an add.
09:34:14 <vixey> this is how to put x into the thing
09:34:31 <vixey> pretend that :>: and :<: are (:) and flip (:)
09:34:38 <rovar> that is technically creating a new list for each operation though, yes?
09:34:45 <EvilTerran> rovar, you could create a wrapper around a mutable array that worked as a ring-buffer
09:34:46 <thomashartman1> @run ( sequence . foldr (return . id) (return ()) $ [1,2,3,4] :: Maybe [Int])
09:34:49 <lambdabot>   Couldn't match expected type `m a' against inferred type `()'
09:34:53 <vixey> rovar: No
09:34:54 <thomashartman1> @src sequence
09:34:54 <lambdabot> sequence []     = return []
09:34:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:34:54 <lambdabot> --OR
09:34:54 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:34:55 <rovar> EvilTerran: yea, that's my next plan
09:35:05 <zachk> > f 3 where f=sum.(map (^2)).enumFromTo 1
09:35:08 <lambdabot>   14
09:35:08 <thomashartman1> @run ( sequence . foldr (return . id) (return []) $ [1,2,3,4] :: Maybe [Int])
09:35:10 <lambdabot>   Couldn't match expected type `Maybe' against inferred type `[]'
09:35:19 <zachk> > f 3 where f=sum.(map (^3)).enumFromTo 1
09:35:23 <lambdabot>   36
09:35:48 <EvilTerran> rovar, your Seq version's probably fine for most purposes, anyway
09:36:14 <thomashartman1> @run ( sequence . foldr (liftM2 (:)) (return []) $ [1,2,3,4] :: Maybe [Int])
09:36:16 <lambdabot>   Couldn't match expected type `Maybe' against inferred type `[]'
09:36:19 <rovar> In my early benchmarks the allocs are killing me
09:36:31 <rovar> for 1mil iterations it allocs over 1GB during the run
09:36:43 * jmcarthur wishes there was a nicer syntax for most of the cases where flip is used
09:36:56 <zachk> > f1 3==f2 3 where f1=sum.(map (^2)).enumFromTo 1;f2 n=n*(n+1)*(2*n+1)`div`6
09:36:59 <lambdabot>   True
09:36:59 <vixey> where is the flip id?
09:37:08 <bmh> +?
09:37:19 <thomashartman1> @run ( foldr (liftM2 (:)) (return []) ) . map $ [1,2,3,4] :: Maybe [Int])
09:37:21 <lambdabot>   <no location info>: parse error on input `)'
09:37:38 <zachk> > f1 3==f2 3 where f1=sum.(map (^3)).enumFromTo 1;f2 n=n*(n+1)*(2*n+1)*(3*n+1)`div`24
09:37:39 <EvilTerran> jmcarthur, you can write (flip f x) as (`f` x), that's sometimes cleaner...
09:37:41 <lambdabot>   False
09:37:51 <thomashartman1> @run foldr (liftM2 (:)) (return [])  . map $ [1,2,3,4] :: Maybe [Int]
09:37:53 <lambdabot>   Couldn't match expected type `[m a1]'
09:38:12 <jmcarthur> EvilTerran, for some cases that works
09:38:14 <thomashartman1> @run ( foldr (liftM2 (:)) (return []) )  . map $ [1,2,3,4] :: Maybe [Int]
09:38:16 <lambdabot>   Couldn't match expected type `[m a1]'
09:38:25 <EvilTerran> jmcarthur, or let (<...>) = flip, then you could write (f <...> x)
09:39:09 <thomashartman1> @src sequence
09:39:09 <lambdabot> sequence []     = return []
09:39:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:39:09 <lambdabot> --OR
09:39:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:39:15 <thomashartman1> @src mapM
09:39:15 <lambdabot> mapM f as = sequence (map f as)
09:39:19 <zachk> > f1 3==f2 3 where f1=sum.(map (^3)).enumFromTo 1;f2 n=n*(n+1)*(2*n+1)*(2*n+2)`div`24
09:39:20 <lambdabot>   False
09:39:52 <zachk> i am just going to have to wait till i can get ghci running on this box i guess :-/ otherwise i will just spam for hours
09:40:03 <thomashartman1> @type foldr (liftM2 (:) ) (return [] )
09:40:04 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
09:40:21 <thomashartman1> @type foldr (liftM2 (:) ) (return [] ) . map
09:40:22 <lambdabot>     Couldn't match expected type `[m a1]'
09:40:22 <lambdabot>            against inferred type `[a] -> [b]'
09:40:22 <lambdabot>     Probable cause: `map' is applied to too few arguments
09:40:29 <thomashartman1> @type \f -> foldr (liftM2 (:) ) (return [] ) . map f
09:40:30 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> [a] -> m [a1]
09:40:35 <monochrom> /msg lambdabot > 1+1
09:40:38 <EvilTerran> zachk, you know you can talk to lambdabot via pm?
09:40:40 <ccccc> salut, viens me voir nue sur mon site internet : http://www.maxicanne.com (GRATUIT)
09:40:47 <EvilTerran> ops?
09:40:55 <zachk> EvilTerran: oh yeah i always forget that :-D
09:40:57 --- mode: ChanServ set +o monochrom
09:41:08 <BONUS> @type ((foldr (liftM2 (:)) (return []) .) . map
09:41:09 <lambdabot> parse error (possibly incorrect indentation)
09:41:20 <BONUS> @type (foldr (liftM2 (:)) (return []) .) . map
09:41:22 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => (a -> m a1) -> [a] -> m [a1]
09:41:24 --- mode: monochrom set -o monochrom
09:41:28 <BONUS> :]
09:41:37 <thomashartman1> thanks bonus. Can I use private messages with lambdabot if I haven't registered a password protected identity with irc?
09:41:49 <BONUS> i think you can, not sure though
09:42:24 <BONUS> its strange how i've developed an intuition for the (f .) . g idiom but i've never bothered to, like, analitically understand it
09:42:44 <BONUS> @type (f .) . g
09:42:45 <lambdabot>     Ambiguous type variable `b' in the constraints:
09:42:45 <lambdabot>       `SimpleReflect.FromExpr b'
09:42:45 <lambdabot>         arising from a use of `g' at <interactive>:1:8
09:43:09 <thomashartman1> @type (f .)
09:43:10 <EvilTerran> ((f.) . g) x y = ((f.) (g x)) y = (f . g x) y
09:43:10 <lambdabot> forall b c a. (SimpleReflect.FromExpr c, Show b) => (a -> b) -> a -> c
09:43:33 <thomashartman1> @info SimpleReflect.FromExpr
09:43:33 <lambdabot> SimpleReflect.FromExpr
09:44:52 <thomashartman1> SimpleReflect isn't in the standard libs, is it?
09:44:57 <EvilTerran> no
09:45:02 <EvilTerran> ?where simplereflect
09:45:02 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:45:16 <thomashartman1> @where simplereflect
09:45:16 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:48:55 <thomashartman1> Can someone hint me how to pm lambdabot so I can cut down on spam?
09:49:28 <bmh>  /msg lambdabot ?
09:49:29 <jmcarthur> thomashartman1, /msg lambdabot <stuff> ?
09:49:40 <vixey> why don't you get ghci?
09:50:19 <thomashartman1> no pl. also I like to see the discussions scroll by :)
09:50:33 <thomashartman1> also no @src.
09:50:47 <vixey> you can get them added to ghci
09:51:06 <thomashartman1> Last time I tried that I think I got stuck with plugins or something.
09:51:11 <thomashartman1> Is lambdabot on hackage?
09:51:58 <RayNbow> roconnor: I printed TTFP today @ my university... :)
09:52:36 <zachk> RayNbow: whats TTFP ?
09:52:46 <RayNbow> @where TTFP
09:52:46 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
09:53:01 <jmcarthur> thomashartman1, pl is in the pointfree package
09:53:25 <RayNbow> I asked roconnor if he had some resources on corecurion and he recommended TTFP
09:53:32 <jmcarthur> as a standalone executable, anyway
09:53:55 <roconnor> :)
09:54:13 <vixey> what is the meaning of a coinductive proof?
09:54:36 <roconnor> vixey: same thing as a coninductive function
09:54:51 <roconnor> vixey: usually used to prove a coinductive proposition.
09:55:47 <drdozer> I'm trying to debug a program in ghci using the breakpoint/trace stuff
09:55:51 <drdozer> but not having any luck
09:55:59 <drdozer> I've set a couple of breakpoints
09:56:08 <drdozer> but when I run main, it doesn't stop at them
09:56:26 <drdozer> I've also tried :trace main and :step main, with no joy
09:57:42 <drdozer> what should I be doing?
09:58:02 <skorpan> :t foldMaap
09:58:03 <lambdabot> Not in scope: `foldMaap'
09:58:04 <skorpan> :t foldMap
09:58:04 <sebaseba_> drdozer: what happens when you run your code?
09:58:05 <lambdabot> Not in scope: `foldMap'
09:58:18 <doserj> drdozer: are you debugging compiled code?
09:58:18 <skorpan> :t Data.Monoid.foldMap
09:58:20 <lambdabot> Not in scope: `Data.Monoid.foldMap'
09:58:27 <skorpan> :t Data.Foldable.foldMap
09:58:28 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
09:58:37 <drdozer> sebaseba_: the main method runs and then terminates as normal, but it computes the wrong result - that's why I want to debug it :)
09:59:03 <zachk> > map s [1..3] where s n=map (f n) [1..10] ; f n=sum.map (^n).enumFromTo 1 ;
09:59:05 <lambdabot>   [[1,3,6,10,15,21,28,36,45,55],[1,5,14,30,55,91,140,204,285,385],[1,9,36,100...
09:59:17 <drdozer> doserj: I've only ever run this code in ghci, and there's no compiled stuff in the directory
10:00:23 <skorpan> how do i find the instance of Foldable for []?
10:01:12 <thomashartman1> @instances help
10:01:12 <lambdabot> Couldn't find class `help'. Try @instances-importing
10:01:21 <thomashartman1> @instances Foldable
10:01:21 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
10:01:32 <doserj> drdozer: you are sure the code that you break on is actually reached?
10:01:40 <thomashartman1> @instances-importing Foldable
10:01:40 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
10:01:48 <skorpan> @instances Data.Foldable.Foldable
10:01:49 <lambdabot> Maybe, []
10:01:54 <nolrai_East> I could sware I read something on how if you instiatated your class on Unit, Sum, and Product you could make it automaticly derivable? anyone have any idea what I was reading?
10:01:55 <skorpan> then what?
10:02:24 <drdozer> doserJ: yeah - very sure
10:02:31 <sebaseba_> skorpan: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Foldable.html#Foldable
10:02:43 <skorpan> sebaseba_: thanks, but how do i find such things on my own?
10:02:58 <sebaseba_> skorpan: use http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:03:11 <skorpan> lol, thanks again
10:03:55 <sebaseba_> skorpan: in this case, search for "Foldable", then you get a "source" link in the first hit, Data.Foldable
10:04:08 <drdozer> doserj: if I prefix the body of the function I want to break at with "bob" `trace` then in the output you can see "bob" but the program doesn't block at the breakpoint
10:04:15 <skorpan> sebaseba_: got it!
10:04:24 <sebaseba_> skorpan: there's also http://haskell.org/hoogle/
10:04:40 <skorpan> i did use hoogle, but it didn't show me the source
10:06:39 <sebaseba_> skorpan: you're right, Hoogle only shows the link to the interface documentation on haskell.org
10:06:57 <skorpan> i think i remember hoogle sometimes showing the sources...
10:07:12 <sebaseba_> skorpan: me too...
10:07:36 <drdozer> is there something I am meant to do other than setting a break point and running main?
10:09:22 <Saizan> drdozer: are you running it with :trace ?
10:09:56 <drdozer> :trace main
10:10:03 <drdozer> after :break learnTable
10:10:50 <drdozer> and it runs to completion, printing out "bob" as it goes (which is printed by trace in learnTable
10:12:23 <doserj> drdozer: does it work without the :trace?
10:17:59 <drdozer> doserj: it runs identically with and without :trace - vis, it runs iwthout stopping at the breakpoint
10:18:57 <doserj> drdozer: even the first time you run it, i.e., directly after loading the file, and setting the breakbpoint?
10:20:36 <drdozer> doserj: yup, the first and every time
10:28:03 <testuser69542> @src id
10:28:03 <lambdabot> id x = x
10:29:03 <doserj> drdozer: if you just start ghci, load your files, and :step main, it also doesn't break?
10:35:57 <drdozer> doserj: ah, that seems to have got it
10:35:58 <drdozer> weird
10:36:22 <doserj> drdozer: your breakpoints are on top-level functions?
10:37:33 <drdozer> doserj: yeah
10:39:05 <doserj> drdozer: and when you :step main again, it doesn't break?
10:40:22 <drdozer> no, doesn't seem to
10:40:38 <drdozer> oh well - I will cherish the tracing run I have
10:41:09 <doserj> drdozer: I get the same here, when the functions are very simple.
10:43:19 <kadaver> hmm learning haskell has also made me ask this(especially after writing my own awesome brianfuck itnerpreter): why the hell do people write compilers in C? why not do it in haskell and then some small parts in C where needed? like the python interpreter for example.
10:43:37 <vixey> because C is faster !!!
10:43:41 <trofi> C is a little more portable? :]
10:45:05 <mornfall> kadaver: Know about pugs?
10:46:09 <kadaver> yes
10:46:49 <drdozer> well, it was a valiant effort, but the tracer in ghci is unusable for me
10:46:59 <drdozer> we /really/ need a decent haskell IDE
10:47:41 <kadaver> but speed in reality os different from speed in theory. I mean if you write it in ghc then you can spend much more time optimizing anyway because you can code faster which means you might end up with the afster program anyway?
10:47:52 <kadaver> drdozer: checke dleksah?
10:47:57 <kadaver> drdozer: checked leksah?
10:48:35 <mornfall> Leksah doesn't seem to quite work for me.
10:48:48 <mornfall> But, I have upgraded GHC since. Maybe it works now.
10:48:55 <mornfall> Ah, right, it needs gtk2hs.
10:48:58 <mornfall> Which is a bitch.
10:51:44 <FunctorSalad> I think leksah isn't far from a useable state
10:53:29 <FunctorSalad> apparently it's pretty much a one-man project currently; I'm sure the author would be glad if someone joined :)
10:55:31 <mornfall> Well, I'm sorta busy with darcs. But admittedly, an IDE would be handy, since we teach haskell in the first semester and the tools are ... inadequate?
10:56:18 <BONUS> i dont get this "need" for IDEs
10:56:34 <BONUS> especially when you have such an expressive language where 90% is thinking
10:56:42 <vixey> wellllll............
10:56:56 <FunctorSalad> BONUS: uh, no. it still makes my wrists hurt :(
10:56:58 <vixey> BONUS: something that let you see the types going on a bit more clearer (and interactively) would be nic
10:57:01 <vixey> nice
10:57:10 <vixey> but just :t in ghci is enough
10:57:15 <vixey> (for me)
10:57:16 <BONUS> but i understand peoples' opinions differ on the whole IDE vs. no IDE thing
10:57:25 <BONUS> yeah i learned by just doing a whole lot of :t in ghci
10:57:26 <FunctorSalad> how about "go to definition" in a huge project...
10:57:31 <tromp> hi BONUS. did you make the LYAHFGG tutorial?
10:57:49 <chessguy_work> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car (cons 1 2)
10:57:51 <FunctorSalad> (admittedly that kinda works in emacs haskell-mode ;))
10:57:51 <lambdabot>   1
10:57:58 <chessguy_work> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in cdr (cons 1 2)
10:58:00 <lambdabot>   2
10:58:04 <chessguy_work> beautiful
10:58:29 <vixey> not really
10:59:13 <monochrom> People need an IDE for thinking, too.
10:59:13 <chessguy_work> @type let ?cons x y = \pick -> if (pick == 1) then x else y; ?car x = x 1; ?cdr x = x 2 in cdr (cons 1 2) in cons
10:59:13 <lambdabot> Parse error in pattern
10:59:15 <chessguy_work> @type let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in cdr (cons 1 2) in cons
10:59:15 <BONUS> tromp: hello :) yeah its me
10:59:16 <lambdabot> parse error on input `in'
10:59:21 <FunctorSalad> mehh murphy disconnect
10:59:29 <chessguy_work> @type let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in cons
10:59:31 <lambdabot> forall t a. (Num a) => t -> t -> a -> t
10:59:42 <tromp> then i want to congratualte you on a marvelous piece of work. both in content and form
11:00:06 <tromp> where did you get those cute pics?
11:00:14 <chessguy_work> @type let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car
11:00:15 <BONUS> why thank you :] very nice to see you like it. drew them myself hehe
11:00:16 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
11:00:24 <FunctorSalad> BONUS: so anyway, I think it'd be nice to get documentation without interrupting what one is doing
11:00:30 <tromp> wow, then i'm even more impressed!
11:01:07 <monochrom> @where LYAHFGG
11:01:07 <lambdabot> I know nothing about lyahfgg.
11:01:10 <BONUS> FunctorSalad: yeah, hmm, i see your point. i guess i've just developed a workflow with vim + online docs that its sometimes hard for me to forget about it
11:01:15 <FunctorSalad> BONUS: also boilerplate like creating a case skeleton for a large datatype
11:01:16 <BONUS> @where lyah
11:01:16 <lambdabot> www.learnyouahaskell.com
11:01:22 <BONUS> :]
11:01:24 <rovar> where is "for" defined?
11:01:31 <vixey> @hoogle for
11:01:31 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
11:01:31 <chessguy_work> for = flip map
11:01:31 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
11:01:31 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
11:01:36 <chessguy_work> oh
11:01:39 <BONUS> rovar: forM is in Control.Monad
11:01:40 <rovar> danke
11:02:01 <tromp> > for "hello" succ
11:02:03 <pumpkin-> moo
11:02:03 <lambdabot>   Not in scope: `for'
11:02:35 <tromp> > forM "hello" succ
11:02:36 <lambdabot>   Couldn't match expected type `m b' against inferred type `Char'
11:02:45 <rovar> ?
11:03:11 <tromp> > forM "hello" $ Id.succ
11:03:13 <lambdabot>       Failed to load interface for `Id':
11:03:13 <lambdabot>        it is a member of package ghc...
11:03:19 <tromp> > forM "hello" $ Id . succ
11:03:21 <lambdabot>   Not in scope: data constructor `Id'
11:03:36 <BONUS> > forM ["hehe","haha"] (\x -> [succ, pred])
11:03:38 <lambdabot>       Overlapping instances for Show (a -> a)
11:03:38 <lambdabot>        arising from a use of `s...
11:03:51 <vixey> > ["hehe","haha"] <*> [succ, pred]
11:03:52 <lambdabot>   Couldn't match expected type `a -> b'
11:04:01 <vixey> > [succ, pred] <$> ["hehe","haha"]
11:04:03 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
11:04:42 <jmcarthur> > [succ, pred] <* ["hehe","haha"]
11:04:43 <lambdabot>       Overlapping instances for Show (a -> a)
11:04:44 <lambdabot>        arising from a use of `s...
11:04:49 <vixey> > [map succ, map pred] <*> ["hehe","haha"]
11:04:51 <lambdabot>   ["ifif","ibib","gdgd","g`g`"]
11:04:59 <jmcarthur> > map <$> [succ, pred] <*> ["hehe","haha"]
11:05:01 <lambdabot>   ["ifif","ibib","gdgd","g`g`"]
11:05:11 <jmcarthur> > liftA2 [succ, pred] ["hehe","haha"]
11:05:12 <lambdabot>   Couldn't match expected type `a -> b -> c'
11:05:36 <jmcarthur> woops
11:06:05 <jmcarthur> > ZipList [succ, pred] <*> ZipList ["hehe","haha"]
11:06:07 <lambdabot>       No instance for (Show (ZipList [Char]))
11:06:07 <lambdabot>        arising from a use of `s...
11:06:13 <jmcarthur> @src ZipList
11:06:13 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:06:39 <EvilTerran> > getZipList $ ZipList [succ, pred] <*> ZipList ["hehe","haha"]
11:06:40 <lambdabot>       No instance for (Enum [Char])
11:06:40 <lambdabot>        arising from a use of `succ' at <i...
11:06:54 <EvilTerran> ...
11:06:57 <jmcarthur> > getZipList $ map <$> ZipList [succ, pred] <*> ZipList ["hehe","haha"]
11:06:59 <lambdabot>   ["ifif","g`g`"]
11:07:31 <FunctorSalad> > concatMap (\x -> if x^5 `mod` 29 < 15 then "he" else "ha") [0...]
11:07:33 <lambdabot>   <no location info>: parse error on input `]'
11:07:37 <FunctorSalad> > concatMap (\x -> if x^5 `mod` 29 < 15 then "he" else "ha") [0..]
11:07:40 <lambdabot>   "hehehehehehahehahahehehehehehahehahahahahahehehahehahahahahehehehehehaheha...
11:09:34 <jmcarthur> :blink:
11:09:48 <monochrom> crazy...
11:10:03 <FunctorSalad> a truly crazy laugh =)
11:10:09 <monochrom> @flat FunctorSalad
11:10:09 <lambdabot> Maybe you meant: fact faq ft let slap what
11:10:17 <monochrom> failed
11:10:18 <vixey> @fact
11:10:22 <vixey> @fact whouca
11:10:25 <lambdabot> I can not handle empty facts.
11:10:27 <lambdabot> I know nothing about whouca
11:10:29 <monochrom> @flap FunctorSalad
11:10:30 * lambdabot is overcome by a sudden desire to hurt FunctorSalad
11:10:38 <vixey> @quoet
11:10:38 <lambdabot> Maybe you meant: quit quote
11:10:43 <vixey> @qual
11:10:43 <lambdabot> Maybe you meant: eval keal quit url
11:10:43 <monochrom> haha overcome by sudden desire
11:10:48 <tromp> cycle "hehehehehehahehahahehehehehehahehahahahahahehehahehahahaha"
11:10:58 <Baughn> > forever []
11:11:04 <FunctorSalad> I didn't think the number theory through but it was the first kinda-pseudorandom thing that came to mind...
11:11:07 <lambdabot>   []
11:11:11 <Baughn> > forever [2]
11:11:13 <lambdabot>   * Exception: stack overflow
11:11:45 <tromp> hmm, what's ther shortest haskell expression giving an aperiodic string?
11:12:00 <tromp> > fix show
11:12:01 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:12:19 <tromp> i guess
11:12:20 <FunctorSalad> > #
11:12:22 <lambdabot>   <no location info>: parse error on input `#'
11:12:23 <FunctorSalad> :P
11:12:27 <FunctorSalad> you didn't say infinite...
11:12:36 <FunctorSalad> (and not "no compiler errors")
11:12:41 <monochrom> >
11:12:48 <FunctorSalad> that's periodic.
11:12:57 <jmcarthur> > pi
11:12:59 <lambdabot>   3.141592653589793
11:13:02 <monochrom> hahaha
11:13:04 <jmcarthur> > pi::CReal
11:13:06 <lambdabot>   3.1415926535897932384626433832795028841972
11:13:32 <rovar> C - Obviously more real
11:13:42 <FunctorSalad> what is that?
11:13:43 <monochrom> haha
11:13:54 <FunctorSalad> oh, C as in computable I guess
11:13:57 <monochrom> CReal is "computable real"
11:14:11 <tromp> how about an aperiodic, infinite  [Bool] ?
11:14:16 <FunctorSalad> :)
11:14:29 <vixey> computable reals are closed under all the popular transendental functions
11:15:51 <EvilTerran> > exp (0 :+ pi)
11:15:53 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:15:53 <monochrom> map (doesItHalt . turnIntoProgram) [0..] :: [Bool] is aperiodic and infinite.
11:15:53 <vixey> :t replicateM
11:15:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
11:15:58 <EvilTerran> > exp (0 :+ pi) :: Complex CReal
11:16:00 <lambdabot>   (-1.0) :+ 0.0
11:16:03 <FunctorSalad> but < is undecidable ;)
11:16:17 <zachk> with an IDE for java and proper design done on paper and pencil I have gotten programs to compile with no mistakes. the only other language i have ever gotten a program to work the first time with was scheme.
11:16:39 * EvilTerran has only ever got programs to work first time in haskell, tbh
11:16:46 <vixey> > map (flip replicateM [False..]) [1..]
11:16:48 <lambdabot>   <no location info>: parse error on input `]'
11:16:55 <lament> proper design on pencil and paper is cheating
11:16:57 <vixey> > flip replicateM [False..] =<< [1..]
11:16:59 <lambdabot>   <no location info>: parse error on input `]'
11:16:59 <jmcarthur> EvilTerran, to compile, or just to run once compiled?
11:17:03 <zachk> lately its been a spelling mistake for me in a variable/function name
11:17:07 <vixey> > flip replicateM [False,True] =<< [1..]
11:17:08 <EvilTerran> > map (=='.') $ fix show
11:17:10 <lambdabot>   [[False],[True],[False,False],[False,True],[True,False],[True,True],[False,...
11:17:11 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
11:17:13 <vixey> > flip replicateM [False,True] =<< [1..]
11:17:15 <lambdabot>   [[False],[True],[False,False],[False,True],[True,False],[True,True],[False,...
11:17:18 <EvilTerran> > map (=='"') $ fix show -- even
11:17:19 <lambdabot>   [True,False,True,False,False,False,True,False,False,False,False,False,False...
11:17:53 <EvilTerran> jmcarthur, to compile on the first attempt, and then run correctly
11:18:15 <jmcarthur> ah
11:18:26 <tromp> cute
11:18:37 <zachk> @src fix
11:18:37 <lambdabot> fix f = let x = f x in x
11:18:59 <zachk> wth does that do
11:19:03 <zachk> @type fix
11:19:05 <lambdabot> forall a. (a -> a) -> a
11:19:10 <tromp> how about the thue morse sequence?
11:19:23 <dolio> > fix (1:)
11:19:24 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:19:30 <FunctorSalad> > map(=='1')$show(exp 1)
11:19:32 <lambdabot>   [False,False,False,True,False,False,False,True,False,False,False,False,Fals...
11:19:40 <vixey> > (fix (\this -> \x -> if x == 1 then 1 else x * this (x - 1)))  6
11:19:42 <lambdabot>   720
11:20:03 <FunctorSalad> (yes that isn't aperiodic without :: CReal ;))
11:22:45 <EvilTerran> FunctorSalad, except CReal's Show instance only produces finite output
11:22:56 <EvilTerran> > length . show . exp $ 1
11:22:57 <lambdabot>   17
11:23:07 <EvilTerran> > length . show $ (exp 1 :: CReal)
11:23:08 <lambdabot>   42
11:23:36 <vixey> without using show
11:23:58 <FunctorSalad> ok I admit defeat :-(
11:24:28 <Gracenotes> CReal shows 40 decimal places
11:24:33 <Gracenotes> up ta
11:24:37 <EvilTerran> what package is CReal in?
11:25:02 <dolio> numbers
11:25:20 <FunctorSalad> honorable mention: system "cat /dev/random"
11:26:09 <owned> http://www.youtube.com/watch?v=Hog9qGjT0Pw owned!!!!!!!!!!!!!!!!!!!!!
11:26:21 <Gracenotes> i think not!!!
11:26:22 <EvilTerran> ops?
11:26:23 <TomMD> Any ops here
11:26:27 <owned> http://www.youtube.com/watch?v=Hog9qGjT0Pw owned!!!!!!!!!!!!!!!!!!!!!
11:26:28 <owned> http://www.youtube.com/watch?v=Hog9qGjT0Pw owned!!!!!!!!!!!!!!!!!!!!!
11:26:30 <TomMD> @seen dons
11:26:31 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #yi, #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I last heard dons speak 2h 26m 20s ago.
11:26:39 <TomMD> grr
11:26:39 <FunctorSalad> @where ops
11:26:39 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:26:41 <vixey> when someone is spamming you could just /ignore
11:26:46 --- mode: ChanServ set +o glguy
11:26:48 <vixey> you really don't need to make a big fuss
11:26:55 <vixey> it just amplifies things 10x
11:27:08 <glguy> if the person already left, we don't need to announce it
11:27:11 --- mode: glguy set -o glguy
11:27:18 <TomMD> Yeah, I saw that afterward.
11:27:30 <FunctorSalad> glguy: I have join/hide messages hidden...
11:27:55 <FunctorSalad> join/part, even
11:29:05 <jmcarthur> > 10 ** fromIntegral (maxBound :: Int) :: CReal -- ???
11:29:08 <lambdabot>   0.0
11:29:19 <vixey> :t (**)
11:29:21 <lambdabot> forall a. (Floating a) => a -> a -> a
11:29:24 <Gracenotes> heh
11:29:29 <vixey> > fromIntegral (maxBound :: Int) ** 1
11:29:32 <lambdabot>   9.223372036854776e18
11:29:39 <Gracenotes> owned also showed up in ##c, ##c++, etc.
11:29:50 <jmcarthur> > 10 ^ fromIntegral (maxBound :: Int) :: CReal
11:30:02 <EvilTerran> ?type (^)
11:30:04 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:30:05 <lambdabot>   thread killed
11:30:19 <jmcarthur> > 10 ^ (maxBound :: Int) :: CReal
11:30:34 <lambdabot>   thread killed
11:30:34 <jmcarthur> :(
11:33:29 * edwardk wakes up and returns to spending his vacation mining for monoids ;)
11:33:45 <wy> I just found it interesting question: does Haskell have the notion of tail-calls?
11:33:50 <ppavelV6> ghc on rtems, anyone?
11:33:59 <vixey> wy: No tail calls
11:34:25 <vixey> wy: What inspired this question?
11:34:41 <wy> vixey: I guess it is just that the concept of tail-calls don't exist in call-by-need?
11:35:01 <edwardk> wy: sort of, but its not the killer it is in lisp. in haskell the concern is the length of the chain it has to pursue in order to eval something. so if everything is fully eval'd things that don't look like a tail call in, say, lisp, can be perfectly fine.
11:35:30 <wy> vixey: Because some programs normally thought of as tail-calls are not really tail-calls in Haskell for example let ls = [bot] in head ls.
11:35:55 <vixey> wy: I just throw away the idea of 'tail-call' if I do Haskell
11:36:15 <wy> vixey: yeah. It seems to only make sense in call-by-value
11:37:02 <wy> But if you think of it the same way as in scheme, it is reasonable for the program  let ls = [bot] in head ls to blow the stack.
11:37:29 <mle> there is a similar concept of "can this execute in constant memory?" but it isn't related to tail-calls in the same way.
11:38:16 <mle> heh, try writing a length that won't blow the stack.
11:38:19 <wy> bot would have been evaluated in a non-tail context [...], but it is only evaluated later when we see "head ls"...
11:38:29 <vixey> length [] = O ; length (x:xs) = S (length xs)
11:38:42 <mle> hahaha
11:38:50 <vixey> length = id -- easier version
11:39:25 <mle> :t length
11:39:28 <lambdabot> forall a. [a] -> Int
11:39:43 <dolio> edwardk: Someone posted a blog about a parser monoid for roman numerals to reddit.
11:39:45 <Olathe> You just need to redefine Int as [a].
11:40:10 <dolio> Although I don't think they mentioned that it was a monoid (well, two different monoids, I guess).
11:40:35 <dolio> (Er, a monoid in two different ways.)
11:41:54 <edwardk> dolio: nice. i'll go skim it right after i fix up my boolean rings
11:42:10 <vixey> @keal
11:42:10 <lambdabot> how bout i say ick no unicorn and daisy loving girl mathematician will ever enjoy this
11:42:11 <vixey> @keal
11:42:12 <lambdabot> evaluating expressions is ALL haskell does?????
11:42:13 <vixey> @keal
11:42:13 <lambdabot> they dumbified you
11:42:14 <vixey> @keal
11:42:14 <lambdabot> i want to invent white dye
11:42:23 <dolio> What do you call those, by the way? Dimonoids?
11:42:26 <dolio> Bimonoids?
11:42:34 <dolio> Prerings?
11:43:18 <wy> Is this a tail-call version of length?
11:43:19 <wy> length1 [] n = n
11:43:19 <wy> length1 (x:xs) n = length1 xs (n+1)
11:43:24 <edwardk> well, Booleans form a real ring if you change out addition. ;) they also form a Semiring or 'dioid' under  && and ||
11:43:29 <vixey> wy: No
11:43:39 <wy> vixey: why not?
11:43:45 <edwardk> so Data.Ring.Boolean is the mathematical 'Boolean Ring' with symmetric difference for addition.
11:43:47 <vixey> wy: There is no such thing as a tall-call
11:44:04 <dolio> No, I mean a type with two different monoid structures that distribute, like a parser.
11:44:06 <wy> > [1, 2, ...]
11:44:07 <lambdabot>   <no location info>: parse error on input `]'
11:44:14 <edwardk> and Data.Ring.Semi.Ord.Order Bool gives you effectively the && and || SemiRing
11:44:19 <omnihil> > [1, 2, ..]
11:44:19 <mle> well you can write code that looks structurally like a tail call, it just won't be used that way during evaluation
11:44:20 <lambdabot>   <no location info>: parse error on input `..'
11:44:28 <edwardk> dolio: most of those are seminearrings
11:44:31 <p0l0na1sE> [1,2..]
11:44:38 <mle> there can't really be a tail call if there is no real tail context
11:44:38 <p0l0na1sE> :-D
11:44:39 <edwardk> dolio: since they only distribute on the left or right
11:44:44 <wy> vixey: Can you remind me the way to make an infiite list?
11:44:53 <edwardk> dolio: Data.Ring.Semi.Near
11:45:03 <dolio> Heh.
11:45:03 <vixey> wy: let ying = 1 : yang ; yang = 0 : ying in  (ying,yang)
11:45:04 <iago_> >[1..]
11:45:10 <iago_> > [1..]
11:45:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:45:18 <vixey> , let ying = 1 : yang ; yang = 0 : ying in vacuum (ying,yang)
11:45:21 <lunabot>  [(0,[1,2]),(1,[3,2]),(2,[4,1]),(3,[]),(4,[])]
11:45:21 <edwardk> under there is where my regexps fall, and so do lists of monoids, fingertrees of monoids, and sequences of monoids.
11:45:28 <p0l0na1sE> > take 10 [1,2..]
11:45:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:47:13 <wy> vixey: You are right. It blows the stack!
11:47:24 <vixey> that wasn't what I meant
11:47:59 <wy> It is equivalent in some weird way I guess
11:48:10 <FunctorSalad> mle: so what's the solution? ;)
11:49:07 <FunctorSalad> (constant-memory length)
11:49:59 <vixey> constant-memory length is impossible, as I showed earlielr
11:50:03 <edwardk> dolio: i think what will be interesting is when i have Data.Ring.Semi.Near.Generators that can take advantage of that distributive law to abuse things like the regularity of their structure
11:50:19 <mle> oh it's possible, but you have to cheat.  Look how ghc and similar implement it
11:50:26 <mle> kinda disappointing, I agree
11:50:43 <FunctorSalad> IORefs? ;)
11:50:58 <edwardk> i.e. parsing LZ or run length encoded data with a monoid can cheat a lot
11:51:22 <mle> FunctorSalad: heh, no!
11:51:29 <mle> not That bad
11:52:19 <mle> FunctorSalad: they use Int#'s
11:52:53 <FunctorSalad> how does that avoid recursion?
11:53:22 <wy> vixey: I didn't understand your point. Why is it impossible?
11:53:43 <mle> they use an accumulator function and Int#'s, which are strict.  With strict datatypes like that, tail recursion works... so their accumulator consumes only constant stack
11:53:50 <iago_> @src length
11:53:50 <lambdabot> Source not found. It can only be attributed to human error.
11:53:51 <wy> vixey: I think length didn't blow the stack. It probably blew the heap because now we need to evaluate the list
11:54:19 <edwardk> dolio: hrmm, i really should add a nice run length encoding monoid, now that i'm thinking about ;)
11:54:39 <vixey> if the input list has size O(n) the output number has size O(n)
11:54:47 <mle> FunctorSalad: genericLength does it all in normal haskell, so it overflows
11:54:48 <vixey> that's why I said:  length = id
11:55:36 <wy> vixey: What is the way to get statistics from an evaluation?
11:55:53 <iago_> O(n) an Int?
11:56:24 <FunctorSalad> mle: similar to this? length1 [] !n = n; length1 (_:xs) !n = length1 xs (n+1)
11:56:50 <FunctorSalad> (avoiding the #Int)
11:57:00 <mle> for reference, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1994#a1994
11:57:38 <mle> hmmmm
11:57:58 <FunctorSalad> do you need unboxed types for the optimization or will strictness do?
11:58:52 <mle> I'm not sure, trying that out.
11:59:34 <leimy_> @users
11:59:34 <lambdabot> Maximum users seen in #haskell: 662, currently: 613 (92.6%), active: 25 (4.1%)
11:59:36 <wy> vixey: It's weird... they seem to behave the same way
11:59:50 <iago_> this explains the use of Int
12:00:33 <iago_> I would prefer length :: Integral b => [a] -> b
12:02:29 <vixey> iago_: It doesn't bother me much because I mostly just don't import Prelude
12:02:57 <iago_> and what length funtion do you use so?
12:03:20 <vixey> I hardly ever want to know the length of the list, Having the real thing is more useful
12:03:44 <iago_> well, who says length saids take, drop etc
12:03:48 <iago_> all defined in terms of Int
12:04:39 <iago_> working with Integers introduce lot of use of fromInteger
12:04:59 <cocon> what's in a thunk at runtime?
12:05:04 <cocon> I mean, how is it represented
12:05:18 <JohnnyL> what do haskeller's normally use to program web pages (anything better than templates in other languages) ?
12:05:23 <mle> FunctorSalad: seems to work nicely
12:05:38 <mle> so which is worse, bangpatterns or unboxed values?
12:06:26 <FunctorSalad> heh I'm a superstitious bangbattern user for numerical stuff ;)
12:06:27 <iago_> mle, so it isn't impossible
12:06:49 <vixey> I don't write numerics in Haskell
12:06:57 <vixey> If I did I think that I would put some serious work in
12:07:05 <FunctorSalad> mle: alternatively use Control.Parallel.Strategies's rnf
12:07:16 <vixey> that means learning assembly language
12:07:27 <mle> iago_: fair enough
12:08:13 <FunctorSalad> vixey: uhm it's not extremely high performance stuff
12:08:14 <rovar> is there a TLS package for haskell yet?  I saw some mention of it existing in http, and there is a link that points to a 403
12:08:19 <|jedai|> iago_: Do you know that there are generic version of length... in Data.List ?
12:08:33 <FunctorSalad> vixey: adding some bang patterns is way less painful than writing assembly
12:08:34 <mle> genericLength blows the stack
12:09:00 <vixey> oh sure, if it's not high performance stuff it doesn't really matter
12:09:04 <jedai> @src genericLength
12:09:05 <lambdabot> genericLength []    = 0
12:09:05 <lambdabot> genericLength (_:l) = 1 + genericLength l
12:09:12 <jedai> @src length
12:09:12 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:09:24 <iago_> jedai, why not the default?
12:09:30 <mle> jedai: see my previous paste for the length implementation in use
12:09:35 <FunctorSalad> vixey: there are degrees in between ;) I wouldn't even write casual numeric things in, say, an interpreted language
12:09:35 <iago_> GHC can define specialized versions
12:09:41 <vixey> > genericLength [1..] > (3000 :: Natural)
12:09:43 <lambdabot>   True
12:09:45 <vixey> > genericLength [1..] > (30000 :: Natural)
12:09:47 <lambdabot>   True
12:09:50 <FunctorSalad> vixey: but haskell with strictness is fine for it IME
12:09:53 <vixey> > infinity > (300000 :: Natural)
12:09:55 <lambdabot>   True
12:10:16 <mle> vixey: heh
12:10:27 <dolio> > genericTake infinity [1..]
12:10:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:11:03 <mle> :t infinity
12:11:05 <lambdabot> Natural
12:11:43 <jedai> mle: Well it makes sense that the implementation for genericLength be written to take advantage of eventual lazyness
12:12:06 <jedai> mle: There could be a specialized version for Integer though I guess
12:12:08 <vixey> infinity = fix Succ
12:12:11 <vixey> or something like that
12:12:52 <mle> jedai: right....
12:13:56 <BONUS> @pl (\x f -> fmap (replicate x) f)
12:13:56 <lambdabot> fmap . replicate
12:14:17 <BONUS> d'oh. lol
12:14:40 <Majost> I am hacking at some haskell code, and trying to learn a bit... I was wondering if someone could provide me an example of the use of the 'unless' monad
12:14:44 <ErhardtMundt> hey BONUS
12:14:51 <vixey> the 'unless' monad hu ?
12:14:54 <BONUS> hey michele, whats up!
12:15:11 <ErhardtMundt> haha, nothing bad
12:15:19 <ErhardtMundt> BONUS: and you?
12:15:19 <JohnnyL> i guess there is no solution
12:15:22 <Majost> vixey: http://www.zvon.org/other/haskell/Outputmonad/index.html
12:15:50 <vixey> Module:  	Monad
12:15:54 <vixey> Function:  	unless
12:15:59 <vixey> Type:  	Monad a => Bool -> a () -> a ()
12:16:10 <BONUS> i have a lot to study and im slacking off at the moment, so, just the usual i guess :)
12:16:10 <mle> JohnnyL: what are you looking for?
12:16:10 <mle> there are several web frameworks with various templating systems
12:16:39 <JohnnyL> mle the i'm trying to look for a non template solution, but lisp is the other one that offers it.
12:17:01 <ErhardtMundt> BONUS: hehe, same here
12:17:10 <BONUS> Majost: a <- getLine; unless (a == "quit") (putStrLn "blah")
12:17:26 <BONUS> its like when, only the opposite
12:17:35 <mle> JohnnyL: not something I really do, sorry.
12:17:36 <Majost> BONUS: ahh, thanks. =)
12:17:56 <JohnnyL> mle np
12:18:25 <asgaroth> Kinda off-topic, but: Does every regular polyhedron have a sphere on which all of its corner-points lie?
12:18:35 <FunctorSalad> > runState (unless True (put "foo!")) "bar!"
12:18:37 <lambdabot>   ((),"bar!")
12:18:42 <FunctorSalad> > runState (unless False (put "foo!")) "bar!"
12:18:44 <lambdabot>   ((),"foo!")
12:18:50 <FunctorSalad> ( Majost )
12:19:41 <rittyan1> any gentooers? I have problems with ghc-6.10.1... when I execute 'ghci' it complains that ghc is not build for interactive use
12:19:55 <rittyan1> the only flag I have enabled is "binary"
12:20:06 <FunctorSalad> I think it's defined as "unless b action = if b then return () else action"
12:20:14 <JohnnyL> mle what's a good web framework?
12:20:42 <ppavelV6> JohnnyL: Seaside is good :)
12:20:57 <mle> bearing in mind that I don't do much web development, I've been fiddling around with happstack a bit.
12:21:28 <mle> I recommend you look on hackage and see what else is out there that might suit you...
12:26:03 <JohnnyL> ppavelV6 yeah looks good, thanks!
12:27:42 <ppavelV6> JohnnyL: willing to port it to haskell? :)
12:32:30 <JohnnyL> ppavelV6 isn't it already haskell?
12:32:52 * ppavelV6 ashamed
12:32:56 <ppavelV6> JohnnyL:  sorry, it's smalltalk :(
12:33:25 <ppavelV6> it was a joke, sorry
12:33:50 <JohnnyL> ppavelV6 oh.
12:33:51 <JohnnyL> wow
12:33:59 <JohnnyL> my mind is going i can feel it!
12:52:41 <bremner> If I run interact inside ghci is there anyway to return to ghci top level? ctrl-D (on Linux) seems to exit the interpreter
12:53:23 <opqdonut> bremner: ^C
12:54:14 <bremner> ah cool. thanks.
13:01:41 <Baughn> ..only in Haskell do I write a 300-line program and have it work perfectly on first run
13:01:53 <Baughn> (Took me half an hour to fix the compile errors, mind)
13:04:06 <camio> Anyone know of a general function that does the following: Maybe (IO a) -> IO (Maybe a)?
13:05:44 <zachk> camio: i am a neophyte but you might want to read up on monad transformers
13:05:48 <zachk> > f c ==g c where f =sum.map (^3).enumFromTo 1; g n=((n^2+n)^2)`div`4 ;c=100
13:05:49 <lambdabot>   True
13:06:08 <zachk> two days and i got it . go me !!!
13:06:24 <tromp> maybe (return Nothing) Just
13:06:36 <tromp> :t maybe (return Nothing) Just
13:06:37 <lambdabot> forall a. Maybe (Maybe a) -> Maybe (Maybe a)
13:07:02 <monochrom> maybe (return Nothing) (liftM Just)
13:07:43 <camio> hrm
13:07:48 <arjanb> or sequence from Data.Traversable
13:07:51 <tromp> :t maybe (return Nothing) (liftM Just)
13:07:52 <lambdabot> forall a1 (m :: * -> *). (Monad m) => Maybe (m a1) -> m (Maybe a1)
13:08:48 <camio> :t maybe (return mempty) (liftM pure)
13:08:50 <lambdabot> forall a1 (f :: * -> *) (m :: * -> *). (Applicative f, Monad m, Monoid (f a1)) => Maybe (m a1) -> m (f a1)
13:09:23 <FunctorSalad> @tell conal why's the chain rule commented out in vector-space? :)
13:09:23 <lambdabot> Consider it noted.
13:09:39 <camio> :t maybe (return mempty) (pure. pure)
13:09:40 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Applicative f1, Applicative f, Monad f, Monoid (f1 a)) => Maybe a -> f (f1 a)
13:09:55 <camio> :t maybe (pure mempty) (pure. pure)
13:09:56 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Applicative f1, Applicative f, Monoid (f1 a)) => Maybe a -> f (f1 a)
13:10:13 <jmcarthur> :t Data.Traversable.sequence
13:10:14 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
13:10:20 <jmcarthur> ^^ camio
13:10:41 <c_wraith> Is Maybe traversable?
13:10:48 <jmcarthur> i thought so
13:10:52 <c_wraith> It probably is
13:11:00 <jmcarthur> pretty certain
13:11:08 <jmcarthur> @src Data.Traversable.sequence Maybe
13:11:08 <lambdabot> Source not found.
13:11:11 <jmcarthur> or something...
13:11:15 <jmcarthur> i never remember the syntax
13:11:30 <c_wraith> I just wish there was a convenient way to look up what packages define instances, indexed both by type and by class
13:11:33 <Baughn> @instances-importing Data.Traversable Traversable
13:11:33 <lambdabot> Maybe, []
13:11:35 <camio> > sequence (Maybe [33])
13:11:36 <lambdabot>   Not in scope: data constructor `Maybe'
13:11:36 <c_wraith> Err, modules
13:11:43 <camio> > sequence (Just [33])
13:11:44 <lambdabot>   Couldn't match expected type `[m a]'
13:11:44 <jmcarthur> there we go
13:11:46 <c_wraith> camio, use Just. :)
13:12:05 <jmcarthur> camio, Prelude.sequence is different from Data.Traversable.sequence
13:12:15 <jmcarthur> the Prelude one is less general
13:12:22 <camio> > Data.Traversable.sequence (Just [33])
13:12:23 <lambdabot>   [Just 33]
13:12:43 <camio> nice
13:13:21 <skorpan> jmcarthur: that's confusing?
13:13:33 <jmcarthur> skorpan, what is?
13:13:47 <skorpan> having a less general one in Prelude
13:13:54 <skorpan> why do they have that?
13:13:59 <jmcarthur> skorpan, i think Traversable came after Prelude was already defined by the spec
13:14:05 <opqdonut> everything is less general in the prelude
13:14:27 <skorpan> okay...  so *why* is everything less general in the prelude?
13:14:46 <opqdonut> because H98 is really conservative
13:14:48 <jmcarthur> because that's haskell98
13:14:51 <opqdonut> + all the cool stuff has popped up after it
13:15:20 <jmcarthur> (and some claim that it makes it easier for noobs because type errors won't refer to so many type classes, but i personally don't care about that)
13:15:26 <conal> FunctorSalad: (commented-out chain rule).  i think at the time, i hadn't figured out a fully general (polymorphic and infinite-depth), type-correct definition.  i got some new clarity when writing the paper.
13:15:26 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
13:15:56 <iago_> remove IO monad
13:16:03 <iago_> noobs will be happier too
13:16:04 <iago_> :P
13:16:17 <FunctorSalad> conal: just reading "/The Music of Streams/ by Doug McIlroy" you suggested in a comment in the file :)
13:16:25 <conal> FunctorSalad: lovely!
13:16:27 <FunctorSalad> begins hilarioiusly...
13:26:35 <dons> vacuum :: a -> IntMap HNode
13:26:40 <dons> is an unusual type :)
13:27:27 <Baughn> That's const, right? *Right*?
13:28:00 <dons> NO!!
13:28:08 <dons> it's EVIL
13:28:35 <conal> yummm ... evil
13:29:01 <jlouis> unsafeVacuumIO :: ...
13:29:04 <dons> remarkable code, http://moonpatio.com/vacuum/haddocks/src/GHC-Vacuum.html#vacuum
13:29:05 <Baughn> dons: What does it /do/?
13:29:17 <Baughn> ..buguuh
13:29:24 <jlouis> oh, it WAS unsafe
13:29:26 <jlouis> EVIL!
13:29:28 <dons> http://moonpatio.com/vacuum/dlist.html
13:29:45 <Baughn> What's this thing for, anyway?
13:29:50 <dons> drawing your heap
13:29:59 <jlouis> Come to the dark side. The imperative code awaits you. (along with a RED lightsaber of course)
13:30:03 <Baughn> Ah. So it's not really a, it's Hask a => a
13:30:33 <opqdonut> wow
13:32:15 <nolrai_East> Is there an easy way to turn a Set into a Map to undefined? Im using it for intersection.
13:32:47 <koeien> ? Set has intersection
13:32:51 <EvilTerran> ... that shouldn't be necessary
13:33:07 <koeien> really, it would be inefficient, wrong and unnecessary
13:33:16 <EvilTerran> ?type Data.Set.intersection
13:33:18 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
13:33:25 <EvilTerran> ?type Data.Set.intersectionWith
13:33:27 <lambdabot> Not in scope: `Data.Set.intersectionWith'
13:33:33 <rittyan1> anyone using ghc 6.10 on gentoo?
13:34:58 <nolrai_East> koeien: with a map.
13:35:10 <koeien> nolrai_East: what do you mean?
13:35:40 <EvilTerran> ah, you want to intersect a Set with a Map?
13:35:48 <nolrai_East> yes.
13:35:53 <koeien> ah, sorry
13:36:00 <koeien> in that case i would do it the other way around?
13:36:10 <koeien> what do you need as result, a Set or Map ?
13:36:15 <nolrai_East> I need the result to be a Map.
13:36:32 <koeien> M.filter (S.member yourSet) not enough?
13:36:39 <EvilTerran> that's what i'd do
13:36:47 <nolrai_East> That will work!! thanks!
13:36:47 <koeien> (save for a flip)
13:37:18 <koeien> perhaps not the most performant solution, but it'll do for most cases
13:37:20 <EvilTerran> altho that's O(size yourMap * log(size yourSet))
13:38:02 <EvilTerran> while (intersection x y) is O(size x + size y)
13:41:06 * EvilTerran is surprised that there isn't an efficient function :: Set a -> Map a ()
13:41:12 <EvilTerran> provided
13:41:36 <opqdonut> indeed
13:41:48 <opqdonut> but that would require knowledge of both implementations
13:42:16 <opqdonut> and one can do it in O(n) the naive way anyway
13:42:35 <opqdonut> and iirc the implementations for map and set were quite different tree-things
13:43:12 <EvilTerran> according to the haddock, they're both "size balanced binary trees"
13:43:20 <opqdonut> yeah, misremembered
13:43:43 <rovar> how do automatically derive instances of Data for GADTs so that I can import/export to JSON?
13:43:54 * EvilTerran would've just expected a pseudo-inverse to keysSet
13:43:57 <EvilTerran> ?hoogle keysSet
13:43:58 <lambdabot> Data.IntMap keysSet :: IntMap a -> IntSet
13:43:58 <lambdabot> Data.Map keysSet :: Map k a -> Set k
13:44:16 <Baughn> rovar: Have you tried hackage://Derive?
13:44:31 <EvilTerran> does Derive do *G*ADTs?
13:45:06 <Baughn> Now that's the question. Luckily, finding out is easy. ;)
13:46:56 <rovar> Baughn: yea, I have it.. i just can't figure out the syntax
13:47:11 <rovar> i tried $(makeData ''Foo)
13:47:39 <Saizan> rovar: $(derive makeData ''Foo)
13:49:25 <rovar> ?hoogle derive
13:49:25 <lambdabot> package derive
13:49:25 <lambdabot> Distribution.Extension DeriveDataTypeable :: Extension
13:49:25 <lambdabot> Language.Haskell.Extension DeriveDataTypeable :: Extension
13:50:14 <rovar> i have DeriveDataTypeable set as a language extetnsion, but it says derive is out of scope
13:50:22 <Saizan> rovar: from Data.DeriveTH
13:50:55 <Saizan> oh, for the Data class you can use deriving (Typeable,Data) with that extension
13:53:07 <rovar> that did it, thanks
13:56:13 <travisbrady> rovar: any chance you could paste an example using that with JSON?  I've wanted to do that too
13:56:31 <rovar> sure
14:00:11 <rovar> travisbrady: this is pretty much it
14:00:13 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1995#a1995
14:02:36 <travisbrady> rovar: cool, thank you
14:02:41 <travisbrady> how's the BSON parser coming?
14:02:49 <rovar> it's done
14:03:24 <rovar> the mongodb driver isn't really started yet.. but the bson parser passes all of the tests
14:05:52 <travisbrady> i'm confused, when i load up your example in ghci and do ":t main" i get main :: String, how is it not "IO String"?
14:08:52 <Eridius> travisbrady: probably because he said encodeJSON instead of return $ encodeJSON
14:09:34 <Eridius> although return doesn't actually make much sense, main shoudl be IO ()
14:09:40 <Eridius> so it should be printing the encoded form
14:10:43 <travisbrady> hmm, i was under the impression that any use of 'do' meant the return type was always a Monad
14:10:56 <opqdonut> it does
14:10:57 <omnihil> :t return
14:10:59 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
14:11:39 <Eridius> travisbrady: yeah I'm wondering why it's not, probably because no sequencing operations are actually used there
14:11:43 <rovar> odd.. i ran through it in ghci then pasted it. I never actually tested that file
14:11:46 <Chani> ContextCheck.hs:56:46: Not in scope: `!='
14:11:55 <Eridius> that code can be translated into (\foo -> encodeJSON foo) (MessageContent "username" "password")
14:11:58 <Saizan> ?type do undefined
14:11:59 <rovar> do putStrLn $ encodeJSON foo
14:11:59 <lambdabot> forall (t :: * -> *) t1. t t1
14:12:10 <Eridius> huh
14:12:11 <Chani> clearly haskell uses something else for !=, but what is it? :)
14:12:16 <Eridius> /=
14:12:20 <Chani> thanks
14:12:23 <jmcarthur> :t do "test"
14:12:24 <lambdabot> [Char]
14:12:27 <jmcarthur> huh
14:12:34 <Eridius> :t do 3
14:12:36 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
14:12:39 <Eridius> huh
14:12:46 <jmcarthur> woah
14:12:56 <Eridius> so do definitely forces a monadic-style type (although it doesn't have the Monad constraint itself)
14:13:05 <Eridius> but I guess this works because encodeJSON returns a list
14:13:10 <jmcarthur> so the do makes it of kind * -> * if it can, otherwise it just lets it slide...
14:13:11 <tromp> > join (/=) False
14:13:13 <lambdabot>   False
14:13:28 <jmcarthur> well, of form t t'
14:13:36 <rovar> putStrLn $ show $ encodeJson foo
14:13:44 <Eridius> jmcarthur: the do makes it always of form t t'
14:13:46 <rovar> ghci implicitly does the 1st two :)
14:13:51 <jmcarthur> oh list!
14:13:52 <jmcarthur> right
14:13:58 <jmcarthur> :t do 'f'
14:13:59 <lambdabot>     Couldn't match expected type `t t1' against inferred type `Char'
14:14:00 <lambdabot>     In the expression: 'f'
14:14:03 <jmcarthur> there we go
14:37:12 <gwern> heh. on the webcitation.org FAQ, one of the entries is 'develop a wikipedia bot which scans new wikipedia articles for cited URLs, submits an archiving request to WebCite, and then adds a link to the archived URL behind the cited URL'
14:37:25 <gwern> I already sort of did that in haskell :)
14:38:09 <gwern> but be a good project to use the galois rss lib to work on the rss feed for Recent Changes
14:38:12 <gwern> hm.
14:43:03 <centrinia> Hi bottom. :p
14:43:08 <_|_> :)
14:45:42 <monochrom> Devious project: Write a haskell program to edit wikipedia so that all citations (including "citation needed") are changed to self-citations.
14:46:30 <Eridius> so each wikipedia page is citing itself?
14:46:50 <ddarius> Only the ones with citations.
14:47:58 <monochrom> In practice, the citation-needed police goes out of their way to add "citation needed" to every article, so "each page cites itself" is a very likely outcome.
14:47:59 <centrinia> More devious project: create a random graph and edit Wikipedia so that the citation graph is isomorphic to it.
14:48:10 <monochrom> Hehe
14:48:44 <_|_> each page should reference the next in linked list fashion, and tie the knot at the end :)
14:48:48 <gwern> monochrom: self-citations how? citations to other wikipedia articles are removed on sight
14:49:25 <centrinia> Create a page. Have every citation point at that page.
14:49:45 <lament> put porn on it.
14:50:02 <monochrom> Have every citation point at slashdot.
14:50:13 <monochrom> "Slashdot is wikipediaed!"
14:51:04 <gwern> the problem with that is that slashdot only links to RSs, it isn't an RS itself on anything but slashdot
14:51:56 <opqdonut> don't you mean wikipedia links
14:52:52 <gwern> hm, I should be able to steal code from rss2irc for a wp bot
14:53:09 <gwern> @seen dons
14:53:10 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #yi, #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I last heard dons speak 1h 23m 22s ago.
14:53:42 <gwern> @ask dons any chance of rss2irc becoming a library so I could use it for a wikipedia bot without not-so-delicious copy-pasta?
14:53:42 <lambdabot> Consider it noted.
14:54:19 <centrinia> Create a "dual-pedia" that first turns the entry/hyperlink graph of Wikipedia into a planar graph. Create a dual graph of Wikipedia's graph. Replace Wikipedia with the dual graph.
14:54:48 <monochrom> haha
14:54:55 * gwern doesn't get it
14:55:13 <gwern> (I've noticed it seems like everyone here is conversant with graph theory but me)
14:57:34 <centrinia> gwern, a planar graph is a graph that can be drawn on a sheet of paper without edges intersecting each other. A dual graph simply replaces the partitioned regions of the sheet of paper into vertices and the edges separating two regions becoming the new edges.
14:58:47 <gwern> ok. but why would a suitably transformed wp be funny?
14:59:18 <ddarius> gwern: It wouldn't.
14:59:26 <centrinia> I guess that double transforming it would get back the original planar Wikipedia.
15:00:58 <ddarius> What makes you think the link graph of Wikipedia is planar?
15:01:16 <centrinia> ddarius, I don't. That's why one must make it planar.
15:01:59 <dolio> Sounds like next monday's XKCD or something.
15:05:50 <gwern> hm, rss2irc isn't very well written, although this reader stuff is clever
15:05:58 <gwern> the IRC functionality is pretty heavily embedded
15:06:28 <ddarius> Break out HaRe and have at it.
15:07:08 <gwern> does hare even work?
15:07:50 <ddarius> I don't think there's any reason why it should work much less now than it did before.
15:08:19 <__Ali__> is it possible to implement a DSL (domain specific language) in haskell where the syntax is different to haskell?
15:08:19 * gwern reflects that would be logically true if hare only worked a bit
15:08:26 <gwern> sure
15:08:37 <gwern> that's what quasiquotations are all about iirc
15:09:13 * ddarius assumes __Ali__ meant EDSL otherwise the answer is trivially "Yes."
15:10:27 <__Ali__> ddarius, what do you mean 'otherwise'?
15:11:00 <__Ali__> EDSL = embedded dsl = internal dsl, can we have external dsl based on haskell?
15:11:40 <gwern> hm, ironic. because I use secure.wikimedia.org, I can't get the rss feed URL of the normal wp site
15:11:48 <gwern> and haskell http stuff can't handle https
15:12:22 * gwern googles for an address
15:12:23 * ddarius has similar problems with freakin' Google Mail and Google Groups.
15:12:24 <chessguy> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car . car . car $ cons 1 (cons 2 ( cons 3 (cons 4 5)))
15:12:25 <lambdabot>       No instance for (Num (a2 -> a1 -> a -> t))
15:12:26 <lambdabot>        arising from the lite...
15:13:06 <gwern> ghci segfaulted. now that's unusual
15:13:15 <stepcut> my d/l from haskell.org is only going at 5k/s :(
15:13:24 <EvilTerran> chessguy, that's a rather odd tuple encoding
15:13:33 <chessguy> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car (cons 3 4)
15:13:35 <lambdabot>   3
15:13:54 <lament> __Ali__: http://augustss.blogspot.com/
15:13:56 <ddarius> EvilTerran: Have you never read SICP or watched the lectures?
15:13:56 <chessguy> EvilTerran:  it's data structures built on thin air :)
15:14:14 <EvilTerran> ddarius, haven't got round to it yet
15:14:30 <gwern> hm, I was supposed to be doing some sicp tonight but then I got sidetracked to this wp bot :)
15:14:38 <chessguy> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car . cdr . cdr $ cons 1 (cons 2 ( cons 3 (cons 4 5)))
15:14:39 <lambdabot>       No instance for (Num (a2 -> a1 -> a -> t))
15:14:39 <lambdabot>        arising from the lite...
15:14:44 <ddarius> EvilTerran: Go give yourself ten lashes.
15:14:45 <chessguy> EvilTerran:  it's well worth it
15:14:46 <EvilTerran> chessguy, i do recognise a resemblance to the church encoding of pairs
15:15:15 <chessguy> > let cons x y = \pick -> if (pick == 1) then x else y; car x = x 1; cdr x = x 2 in car . cdr $ cons 1 (cons 2 ( cons 3 (cons 4 5)))
15:15:16 <lambdabot>       No instance for (Num (a2 -> a1 -> a -> t))
15:15:17 <lambdabot>        arising from the lite...
15:15:32 <chessguy> oh right, car and cdr can't be combined
15:15:37 <chessguy> in this way
15:17:24 <EvilTerran> (x,y) := \f -> f x y -- kinda thing
15:19:31 <EvilTerran> chessguy, i think the problem is that you can't nest conses except as a perfectly balanced binary tree, because of the types
15:19:39 <chessguy> yeah
15:20:03 <EvilTerran> ?type \x y pick -> if (pick == 1) then x else y -- x and y must have the same type
15:20:04 <lambdabot> forall t a. (Num a) => t -> t -> a -> t
15:20:28 <chessguy> oh right
15:23:13 <ddarius> > let cons x y = \pick -> if pick == 1 then Left x else Right y; car x = fromLeft (x 1); cdr x = fromRight (x 2) in car . cdr $ cons 1 (cons 2 (cons 3 (cons 4 5)))
15:23:14 <lambdabot>   Not in scope: `fromLeft'Not in scope: `fromRight'
15:23:32 <ddarius> > Data.Either.fromLeft
15:23:33 <lambdabot>   Not in scope: `Data.Either.fromLeft'
15:23:38 <ddarius> @hoogle fromLeft
15:23:39 <lambdabot> No results found
15:23:42 <ddarius> Curses.
15:23:54 <EvilTerran> > let cons x y f = f x y; car = ($ curry fst); cdr = ($ curry snd) in car . cdr . cdr $ cons 1 (cons 2 ( cons 3 (cons 4 5)))
15:23:56 <lambdabot>   3
15:24:02 <ddarius> > let cons x y = \pick -> if pick == 1 then Left x else Right y; car x = either id undefined (x 1); cdr x = either undefined id (x 2) in car . cdr $ cons 1 (cons 2 (cons 3 (cons 4 5)))
15:24:04 <lambdabot>   2
15:24:17 <ddarius> EvilTerran: That's the easy way.
15:24:48 <EvilTerran> resorting to using another ADT is cheating :P
15:24:55 <ddarius> Of course, using fst and seccond is underwhelming.
15:25:11 <ddarius> Of course you can get rid of them.
15:25:43 <chessguy> @type iterate
15:25:44 <lambdabot> forall a. (a -> a) -> a -> [a]
15:26:06 <chessguy> @hoogle (a -> a) -> a -> Int -> a
15:26:06 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
15:26:07 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
15:26:07 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
15:26:23 <EvilTerran> ?type (!!) . iterate
15:26:24 <lambdabot>     Couldn't match expected type `[a]'
15:26:24 <lambdabot>            against inferred type `a1 -> [a1]'
15:26:24 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
15:26:31 <EvilTerran> ?type ((!!) .) . iterate
15:26:33 <lambdabot> forall a. (a -> a) -> a -> Int -> a
15:27:30 <chessguy> @hoogle (a -> a) -> Int -> (a -> a)
15:27:31 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
15:27:31 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
15:27:31 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
15:28:40 <chessguy> @type let r f 0 = f; r f n = f . r f (n-1) in r
15:28:41 <lambdabot> forall c t. (Num t) => (c -> c) -> t -> c -> c
15:28:47 <chessguy> :)
15:34:09 <tessier_> What was the name of that text editor implemented in Haskell which was recently announced? I think there was one other than Yi announced recently...
15:34:55 <EvilTerran> leksah.org?
15:37:18 <__Ali__> internal DSL is nothing but API, eg, how can you restrict the user to NOT use anything outside of the spesific domain?
15:39:22 <conal> __Ali__: why would you want to?
15:39:58 <__Ali__> conal, isn't it enough to just say it's ugly?
15:40:33 <__Ali__> your user needs a DSL with 10 commands, and the host language comes with 1000s of them
15:40:55 <glguy> if he is branching outside of those 10 commands, maybe he needs more
15:41:17 <conal> __Ali__: for me, one of the central principles of a DSEL is that it *complement* the host language and other types ("dsels").
15:42:06 <__Ali__> conal, and so does an API do the same thing
15:42:06 <conal> __Ali__: if you really want, you can tell your users not to import anything but your one module and to turn off implicit prelude import.
15:42:34 <conal> __Ali__: yes.  as you said.  dsel == api.
15:42:38 <Saizan> __Ali__: the difference between a good API and a DSEL is subtle
15:42:48 <__Ali__> conal, but it doesn't make sense to 'ask' the user not to use commands
15:44:08 <__Ali__> isn't it possible to have your very own external DSL which selectively inherits desired features of the host language, and nothing else?
15:44:46 <conal> __Ali__: you could write your own trivial preprocessor that inserts the module header, instead of asking your users to.
15:44:46 <__Ali__> (and not starting from scratch)
15:44:57 <goomba> isnt that called sandboxing?
15:46:03 <conal> i don't recommend it.  if __Ali__ does it, i expect he'll then decide not to bind & gag users after all.
15:46:18 <conal> but it's easier to just try than to argue about.
15:47:58 <osfameron> can you groupBy constructor?  for example if data ColouredInt = Red Int | Blue Int | Green Int, group together Reds, Blues, Greens separately ?
15:49:20 <__Ali__> cods, is it possible to embed haskell interpreter in c++?
15:49:56 <conal> osfameron: you could change your rep to type ColouredInt = (Color,Int) and then groupBy.
15:50:17 <conal> osfameron: may be more convenient for other reasons also.
15:50:43 <vininim> @type groupBy
15:50:44 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
15:50:46 <osfameron> conal: yes, in that instance.  I think I've shot myself in the foot by trying to simplify my problem :-)
15:50:56 <conal> osfameron: oh!  :)
15:51:01 <osfameron> what I *actually* want is data Cell = Blank | Number Int | Match Int
15:51:15 <__Ali__> conal, is it possible to embed haskell interpreter in c++?
15:51:19 <monochrom> Define sameColour (Red _) (Red _) = True etc. Then you can groupBy sameColour.
15:51:27 <conal> __Ali__: yes
15:51:33 <conal> __Ali__: even a compiler
15:51:52 <osfameron> perhaps I don't really want to groupBy arbitrary things.  I want to split on blanks, and then compare the a single Match with a list [Number]
15:52:01 <conal> @faq is it possible to embed haskell interpreter in c++?
15:52:01 <lambdabot> The answer is: Yes! Haskell can do that.
15:52:05 <osfameron> monochrom: yeah... the boilerplate makes mecry though
15:52:15 <__Ali__> conal, what's the difference between embedding haskell in c++ and wrapping c++ into haskell?
15:52:48 <Port2has> hi
15:53:01 <conal> __Ali__: i don't know what you mean by either.  and probably both are far from my expertise.
15:53:48 <__Ali__> wrapping = like what swig does, embedding = like what lua does
15:54:01 <conal> osfameron: maybe some trick with Data.Data
15:54:13 <vininim> @faq is it possible to solve SAT in O(log n) using monads?
15:54:14 <lambdabot> The answer is: Yes! Haskell can do that.
15:54:17 <Port2has> question: in monade jcIn x = do fData <- readData x
15:54:17 <Port2has>             putStrLn fData
15:54:25 <vininim> nice!
15:54:32 <conal> monads rule!  (except one)
15:54:38 <osfameron> conal: thanks I'll have a look
15:54:42 <Port2has> but i always get Stopped at <exception thrown>
15:54:42 <Port2has> _exception ::
15:54:42 <Port2has>   e = GHC.Exception.SomeException (GHC.Exception.:DException _
15:54:42 <Port2has>                                                              (GHC.Show.:DShow ...) ....)
15:54:42 <Port2has>                                   (GHC.IOBase.IOError Nothing GHC.IOBase.EOF ....)
15:54:50 <__Ali__> conal, the question is, when embedding haskell in c++, how can haskell interpreter access all c++ classes ?
15:54:51 <vininim> Port2has: hpaste.org
15:55:32 <conal> __Ali__: you want to call haskell code from c++ code?  vice versa?
15:55:41 <osfameron> @index on
15:55:41 <lambdabot> bzzt
15:55:44 <__Ali__> vice versa
15:55:48 <Port2has> what do you mean ?
15:56:25 <Port2has> has somebody a moment :) to talk with me?
15:56:50 <conal> __Ali__: oh okay.  i understood your "embedding" question to be the reverse.  check out haskell's FFI (foreign function interface) and the tools hsc2hs and c2hs.
15:58:29 <conal> __Ali__: i think gtk2hs and wxHaskell are huge examples of calling c/c++ libs from haskell.
15:59:12 <__Ali__> conal, the problem is that they manually wrap c++ to haskell
15:59:32 <conal> __Ali__: yes
15:59:40 <conal> __Ali__: well, wxhaskell doesn't
15:59:43 <__Ali__> it's tedious and hard to maintain
16:00:01 <conal> __Ali__: moreover, c++ libs are typically imperative.
16:00:17 <conal> a lot of work for something that still isn't functional.
16:01:29 <tessier_> dons: Is Yi multi-threaded? Would be a shame to get stuck without multi-threading like emacs has.
16:01:45 <gwern> tessier_: it is kind of
16:01:50 <tessier_> Multi-threaded with message-passing I would presume.
16:02:05 <gwern> tessier_: as in, ghci in one window will run separately from another. but I don't know if the implementation is different from emacs
16:02:14 <tessier_> Certainly not shared-state since it's haskell etc.
16:03:07 <augustss> __Ali__: Haskell doesn't really have a C++ interface, it has a C interface
16:03:56 <__Ali__> augustss, i was wondering if it's possible to embed haskell in c/c++ as lua can be embedded in c/c++
16:04:24 <__Ali__> embedding is a bit different to wrapping which is what the foreign interface does
16:04:54 <Cale> __Ali__: the answer is probably more or less that you can do it, but the trouble is such that you probably are best off just writing the outer part in Haskell anyway
16:05:07 <Cale> (because that will simplify things a good deal)
16:05:50 <augustss> __Ali__: well, possible, but there's no Haskell implementation supports embedding well
16:05:58 <osfameron> what's the idiomatic way to fold [Foo Int] -> Int ?
16:06:15 <quuxman> @seen quicksilver
16:06:16 <lambdabot> quicksilver is in #macosxdev, #haskell-soc, #haskell-blah, #ghc, #haskell-overflow and #haskell. I last heard quicksilver speak 6h 40m 27s ago.
16:07:55 <Cale> osfameron: foldr + something else maybe?
16:07:55 <Port2has> hi once more simplest program http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2961
16:08:07 <Port2has> but i always get EOF exception
16:08:16 <gwern> hm. why does my wp archiving bot seem to be doing nothing...
16:08:22 <augustss> osfameron: If you have a fold on Foo you can compose them
16:08:47 <Cale> Port2has: That's really strange.
16:08:48 <Port2has> what i has lost from my sight?
16:08:52 <osfameron> Cale: yeah... I'm just not sure whether to strip off the Foos, i.e go via [Foo Int] -> [Int], or whether I'm wanting to lift the (+) operation to work on Foo Int
16:09:00 <Cale> Port2has: That program ought to work.
16:09:04 <osfameron> augustss: compose?
16:09:25 <augustss> well, kinda compose
16:11:04 <augustss> osfameron: but then there's more than one way to do [Int]->Int, of course
16:11:37 <osfameron> sure.  I'm just wanting 'sum' in this case
16:12:50 <osfameron> @source nub
16:12:50 <lambdabot> nub not available
16:12:53 <Port2has> sorry it was becouse of :set -fbreak-on-exception. I missinterpret exception
16:24:33 <gwern> this is very frustrating. I've put an 'error' in my bot, but the dang thing keeps running
16:28:00 <Eridius> haha
16:37:36 <osfameron> @index  mempty
16:37:36 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
16:41:47 <Port2has> Hi, can i get "*** Exception: Error in array index" message from function which performs list operations?
16:42:13 <Cale> Port2has: Only if it also performs array operations.
16:42:33 <matthewp> Has anyone taken any of the Programming Collective Intelligence Book and ported any of the samples to Haskell?
16:42:43 <matthewp> from Python?
16:44:16 <Port2has> ok, but in :hist i don't see any functions which can contains arrays operations
16:44:45 <Port2has> can it be result of lazy calculation?
16:45:11 <Port2has> how to get information what exactly fire exception?
16:47:02 <chessguy> matthewp: there was a mailing group formed around that
16:47:23 <matthewp> chessguy: link?
16:47:39 * osfameron hugs Maybe
16:47:44 <chessguy> http://groups.google.com/group/pci-in-haskell
16:47:50 <chessguy> matthewp:
16:51:07 <matthewp> doesn't seem like people got very far
16:56:57 <chessguy> matthewp:  not really
17:08:02 <gnuvince_> dons: I'm toying with Data.Binary, and it's pretty neat :)
17:10:57 <dons> great.
17:10:58 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
17:13:40 <monochrom> Data.Binary is the best thing since sliced bread.
17:14:25 <vininim> is kolgomorov complexity the reason why generating optimal code is undecidable?
17:14:44 <vininim> or is there something more simple mapping to the halting problem
17:15:17 <vininim> *kolmogorov
17:17:16 <DarthArachides> for most problems, generating *any* code is undecidable
17:17:39 <DarthArachides> or atleast, recognizing the output of such generators is undecidable
17:18:05 <monochrom> kolmogorov complexity is simple to define and understand too. kolmogorov complexity talks about shortest code; if your "optimal" is shortest, that's kolmogorov complexity by definition, you can't be simpler.
17:19:15 <monochrom> If your "optimal" is not shortest, kolmogorov complexity is irrelevant.
17:21:27 <Sargun_Screen> What does the "read" function do?
17:21:53 <c_wraith> :t read
17:21:54 <lambdabot> forall a. (Read a) => String -> a
17:22:07 <c_wraith> Converts a string to something that implements the Read class
17:22:09 <omnihil> > read "3"
17:22:10 <lambdabot>   * Exception: Prelude.read: no parse
17:22:17 <monochrom> It's a parser.
17:22:28 <vininim> > read "3" :: Integer
17:22:30 <lambdabot>   3
17:22:30 <Sargun_Screen> Ah.
17:22:33 <monochrom> It's a lot of parsers, one per type.
17:23:23 <Sargun_Screen> Ok, can someone explain me the concept of "do" - I'm reading http://en.wikibooks.org/wiki/Haskell/Simple_input_and_output but it's still confusing the fuck out of me.
17:23:33 <Sargun_Screen> The only other functional language I've dealt with is Erlang.
17:24:15 <jedai> Sargun_Screen: the "do" introduce a section in monadic syntax
17:25:07 <jedai> Sargun_Screen: It's syntaxic sugar for the real code that use Monad's operation directly, there is a guide to translating the do-notation in the Haskell 98 Report
17:26:01 <Sargun_Screen> So, I shall read the section on monads first, then try to understand do.
17:26:02 <jedai> Sargun_Screen: For simple IO though you don't really need to understand all that, simply know that "do" introduce a block of monadic actions
17:26:41 <Sargun_Screen> Ok...
17:27:07 <jedai> Sargun_Screen: If you're after a in-depth understanding of the process this is indeed the way to go but don't let it stop you of doing some simple IO like printing some value and asking for user input on the command line
17:28:38 <Stephen|Edibles> Now here's something I just suddenly started pondering, and am wondering how to do in haskell. Somebody was discussing the BuzzFizz problem - a very minor problem in most languages (you output the numbers 1 to 100, but on every multiple of 3 you show fizz instead, 5 you show buzz, or on a 5and3 multiple you show FizzBuzz.)
17:28:52 <jedai> Sargun_Screen: In support of the value of in-depth understanding, Monads are pretty useful tools, not only for IO but for plenty of others nice computation gimmicks like non-determinism, function that may fail (exceptions), state transformers, delimited continuations ...
17:28:54 <blackh1> Sargun_Screen: Try this: http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html
17:28:56 <Stephen|Edibles> Now, for most languages, thats just loop, condition, print, loop, etc.
17:29:02 <Stephen|Edibles> But how about in haskell?
17:29:25 <jedai> Stephen|Edibles: well more or less the same
17:30:01 <Axman6> Stephen|Edibles: forM or forM_ will be helpful
17:30:15 <c_wraith> I'd just use map
17:30:15 <Axman6> blackh1: thanks for the linking btw :P
17:30:32 <c_wraith> map fizzbuzz [1..100]
17:30:42 <c_wraith> where fizzbuzz happens to do the right thing with each input
17:30:47 <c_wraith> and return a string
17:30:53 <monochrom> In haskell it's just recursion and pattern matching.
17:30:54 <blackh1> Axman6: I am your propaganda minister. :)
17:30:54 <Ralith> that's what I'd do, c_wraith
17:31:05 <jedai> > mapM_ putStrLn . map (\n -> (if n `mod` 3 == 0 then "fizz" else "") ++ (if n `mod` 5 then "buzz" else "") $ [1..100]
17:31:06 <lambdabot>   <no location info>: parse error on input `;'
17:31:18 <dolio> @seen Heffalump
17:31:18 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 18h 12s ago.
17:31:19 <jedai> > mapM_ putStrLn . map (\n -> (if n `mod` 3 == 0 then "fizz" else "") ++ (if n `mod` 5 then "buzz" else "")) $ [1..100]
17:31:20 <lambdabot>       No instance for (Integral Bool)
17:31:21 <lambdabot>        arising from a use of `mod' at <...
17:31:26 <Ralith> nice.
17:31:31 <jedai> > mapM_ putStrLn . map (\n -> (if n `mod` 3 == 0 then "fizz" else "") ++ (if n `mod` 5 == 0 then "buzz" else "")) $ [1..100]
17:31:33 <lambdabot>   * Exception: "<IO ()>"
17:31:34 <monochrom> if-then-else can be thought as a kind of pattern matching.
17:32:36 <Stephen|Edibles> Yeah, I was being silly
17:32:50 <Stephen|Edibles> Forgot to use show and got wrapped up in type errors
17:32:59 <patch-tag> How do I load an HSP module into ghci, such as the simple hello world module at http://www.nabble.com/ANNOUNCE:-Haskell-Server-Pages-v-0.4-td16286741.html ?
17:33:08 <patch-tag> I think I need to pass some flag.
17:33:35 <Ralith> patch-tag: :module +Module.You.Want
17:33:54 <patch-tag> er, I did ghci helloWorld.hs, it's a syntax error though.
17:34:25 <patch-tag> where helloWorld.hs was copy-pasted from that link.
17:34:30 <monochrom> import Module.You.Want  -- at the beginning of source code file
17:34:59 <monochrom> I guess you have that already.
17:35:20 <patch-tag> page :: HSP XML
17:35:31 <patch-tag> page = <html> ...
17:35:33 <patch-tag> doesn't parse
17:35:38 <jedai> > let ifDiv d s n = if n `mod` d == 0 then s else "" in putStr . unlines . map (\n -> ifDiv 3 "fizz" n ++ ifDiv 5 "buzz" n) $ [1..100]
17:35:39 <lambdabot>   * Exception: "<IO ()>"
17:36:07 <Ralith> jedai: don't bother with putStr
17:36:12 <Ralith> it's all wrapped in show iirc
17:36:17 <patch-tag> I'm going to ask this question at #happs as well.
17:36:30 <osfameron> @pl score (Match m: cs) = checkList cs >>= guard . (m==) . sum >> return m
17:36:31 <lambdabot> (line 1, column 21):
17:36:31 <lambdabot> unexpected "="
17:36:31 <lambdabot> expecting variable, "(", operator or end of input
17:37:41 <jedai> Ralith: It's just an example, I know that there are a hundred solutions to the question in Haskell, you can still find some discussion on old blogs ^^
17:44:02 <patch-tag> fwiw my hsp question was answered at happs: {-# OPTIONS_GHC -F -pgmFtrhsx #-}
17:46:21 <monochrom> I guess ancient Egyptian spells work afterall.
17:47:08 <vininim> monochrom: I believe that by turing encoding you can choose `optimal' to be something else, like time (your program + a universal turing machine that write 1, shift right, and encode transition)
17:47:38 <vininim> err ``turing encoding'' is possibly not what i'm talking about
17:47:54 <machack666> fizzbuzz n = case (n `mod` 3,n `mod` 5) of { (0,0) -> "fizzbuzz"; (0,_) -> "fizz"; (_,0) -> "buzz"; _ -> show n }
17:49:11 <vininim> and then kolmogorov strikes again
17:50:00 <olsner> all hail kolmogorov
18:10:55 <osfameron> is there a logical OR for Nothing?  where :   or' Nothing x = x   and or' (Just x) _ = x  ?
18:11:43 <mauke> @hoogle Maybe a -> a -> a
18:11:43 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:11:43 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:11:43 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
18:12:50 <osfameron> ah, thanks.  orElse looks like it
18:13:25 <sjanssen> osfameron: you want fromMaybe
18:14:22 <osfameron> ah... that could work too
18:14:28 <osfameron> the name was quite generic
18:21:14 <gwern> what the heck. openURL fails because WP bans requests without user agents?
18:21:24 <gwern> well. that's interesting
18:24:08 <gwern> hope network.http has an easy replacement for openURL...
18:28:19 <osfameron> another fizzbuzz: http://gist.github.com/86995
18:29:08 <osfameron> I couldnt' get fromMaybe.join to do TheRightThing so just wrote a joinMaybe
18:29:48 <osfameron> er, I mean join.listToMaybe
18:31:14 <gwern> frig, simpleHTTP gives me a 403
18:33:35 * gwern ponders
18:44:19 <jeffwheeler> I'd like to use CouchDB with a Haskell-generated pages. Is it reasonable to use Happstack, or is there another framework that'll work more comfortably with an external database?
18:44:45 <jeffwheeler> I'm hesitant to use Happstack because it seems like it would awkwardly conflict with the stuff already there as a database-alternative.
18:45:32 <gwern> now I'm even more confused
18:45:33 <gwern> 'Prelude> :browse Network.HTTP.UserAgent
18:45:34 <gwern> module `Network.HTTP.UserAgent' is not loaded
18:45:40 <gwern> what on earth does that mean?
18:45:56 <gwern> the same error occurs if I do module + it
18:48:07 <gwern> and ghc-pkg lists HTTP-4000.0.5 as installed and it compiles & installs fine
18:49:10 <gwern> hm. useragent is neither exposed nor used?
18:49:48 <gwern> and it doesn't compile
18:50:08 * gwern has a hard time believing the bullshit I am going through just to download some bloody wikipedia pages
18:50:11 <wy> I'm back :)
18:51:11 <wy> I want to continue to explore the question of tail calls
18:51:35 <gwern> I'd like to explore the question of why wikipedia blows off any requests without a user-agent
18:51:48 <gwern> and why the http lib doesn't make requests have user-agents in the first place
18:52:49 <jeffwheeler> gwern: they might do it to kill some lame spambots?
18:53:16 <gwern> but they're killing lame haskell libs!
18:53:33 <jeffwheeler> It would seem so.
18:54:15 <wy> add 0 s = s
18:54:15 <wy> add n s = add (n-1) (s+1)
18:54:40 <wy> Is there a nice way to prevent this program to blow the stack when given a large number?
18:54:45 <gwern> @hoogle Either a b -> b
18:54:46 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
18:54:46 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
18:54:46 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:54:50 <gwern> wy: make it stricter
18:55:18 <wy> gwern: How to do it nicely?
18:56:30 * gwern doesn't care enough to think about it
18:56:45 <sjanssen> wy: add bang patterns
18:56:53 <sjanssen> add !n !s = ...
18:57:09 <wy> sjanssen: I thought bang only works for data types
18:57:20 <sjanssen> wy: it's a GHC extension
18:57:26 <gwern> remove a ton of type sigs, slap in a NoMonomorphismRestriction, toss in some undefineds and fromJusts...
18:57:37 <gwern> (let's see whether this fricking useragent module would even work)
18:58:12 <gwern> Chunk "Please provide a User-Agent header\n" Empty
18:58:17 <wy> sjanssen: Is there a good reason why this program can be made tail recursive?
18:58:18 <sjanssen> wy: in Haskell '98 you can write: add n s = add (n-1) $! (s+1)
18:58:26 <wy> automaticall?
18:58:34 <sjanssen> wy: it is tail recursive
18:58:55 <sjanssen> it just happens to generate a thunk that is O(n) in size and will require that much stack to eventually allocate
18:59:02 <wy> sjanssen: I mean make it use constant space without change anything. Is there a reason this is not possible?
18:59:06 <sjanssen> wy: I bet ghc -O2 will fix the space leak automatically
18:59:17 <sjanssen> wy: this is called "strictness analysis"
18:59:31 <wy> sjanssen: that can be nice. I will try
18:59:58 <wy> sjanssen: It works! cool
19:01:50 <Nik_89> I'm using ghc 6.4.2 and I'm currently having an issue that the symbol "__stginit_ControlziMonadziState_" is undefined when I'm using the State monad, can someone tell me what I need to do to fix this?
19:02:16 <sjanssen> Nik_89: you forgot a -package flag/didn't compile with ghc --make
19:02:46 <gwern> good giref
19:02:49 <Nik_89> sjanssen whats the package one?
19:02:59 <sjanssen> Nik_89: -package mtl
19:03:00 <Nik_89> sjanssen sorry I mean the package name :)
19:03:09 * gwern loathes this day and the hacks I've put into http-4k
19:03:31 <Nik_89> sjanssen great! that worked, thank you :)
19:04:09 <sjanssen> I think Nik_89 and wy have asked the most frequently asked questions in the span of five minutes :)
19:04:48 <gwern> oh christ now I need lazy bs to string
19:05:07 <Nik_89> sjanssen I guess haskell has the tendency to make people lazy ;P
19:05:09 <gwern> if it's not one thing it's the other or bats with lasers on their heads
19:05:12 <wy> sjanssen: really that frequently asked?
19:05:23 <gwern> wy: yeah
19:05:31 <gwern> I sometimes think --make should be a default
19:05:41 <sjanssen> Nik_89, wy: no slight meant against either of you, of course
19:05:45 <wy> I didn't thought so many people care about tail recursion :p
19:05:58 <gwern> scheme has brainwashed people
19:06:12 <monochrom> education is brainwashing
19:06:20 <sjanssen> and all other strict FP languages
19:06:57 <wy> hehe. Then you guys are brainwashed by haskell :)
19:07:09 <Nik_89> gwern as far as I know, --make works only when you input haskell code to ghc whereas it is also possible to input compiled objects to ghc too (which is my case as I'm using haskell with a C program)
19:07:38 <gwern> Nik_89: so?
19:07:58 <wy> I have a tendency to resist any brainwash, so I'm not very welcomed anywhere :p
19:08:10 <monochrom> I have done ghc --make xxx.o just fine
19:08:36 <monochrom> I do not resist mouthwash anymore.
19:08:56 <Nik_89> well I don't know if that changed with new versions but version 6.4.2 won't allow any .o files to be input when you use the --make flag
19:09:03 <monochrom> (And since then I become welcomed everywhere!)
19:09:12 <gwern> 6.4.2 was, um, a while ago
19:09:30 <gwern> and now firefox crashes
19:09:35 <gwern> this has been a bad night
19:09:36 <wy> monochrom: It's kind of hard
19:09:45 <sjanssen> gwern: maybe you need a twitter or something
19:09:54 <wy> gwern: try chrome?
19:10:19 <gwern> sjanssen: the difference between twitter and here is that here someone might be able to help me
19:10:26 <gwern> deal with http's epic fail on user-agents
19:10:28 <wy> I just found that gmail stops to work in my firefox now and then, and I was forced to use chrome. Is Google playing a trick on us?
19:10:37 <sjanssen> gwern: use curl instead?
19:10:52 <gwern> wouldn't even know how to start with it
19:10:56 <monochrom> Oh! You wrote a web server to crash firefox?
19:11:00 <gwern> and I really do prefer native-haskell solutoins
19:11:03 <sjanssen> gwern: the haddocks, I suppose
19:11:08 <sjanssen> gwern: yes, I do as well
19:11:19 <sjanssen> but you can at least be confident that curl is fairly robust
19:11:32 <gwern> and now I have something to whine about to siggy
19:11:53 <gwern> also dons, I'm starting to get *really* annoyed with having to write lazy bytestring <-> strict bytestring conversion routines
19:12:10 <dons> sorry dude. you shouldn't be converting.
19:12:13 <dons> pick one.
19:12:29 <sjanssen> dons: it usually isn't the end user's choice
19:12:41 <gwern> ah right I'll just make every library I touch, and they touch, pick one -_-
19:12:53 <sjanssen> upstream A chooses strict, upstream B chooses lazy, user C gets a headache
19:13:08 <Cale> The solution is an ML style module system, or typeclasses.
19:13:11 <dons> the conversion api is intentional
19:13:20 <wy> Is there a summary what benefit laziness brings us?
19:13:20 <dons> to make sure  the user knows they're loosing efficiencies
19:13:36 <Cale> wy: Yeah, see the paper "Why Functional Programming Matters"
19:13:44 <dons> wy: hmm. not really. it's like saying "what benefits does data structures give us"
19:13:44 <sjanssen> the difference between the various ByteString modules is another very FAQ here
19:13:49 <dons> it's just something fundamental
19:13:51 <gwern> wy: like garbage collection, frees us from worrying about evaluation order (more or less)
19:13:56 <dons> sjanssen: we need an FAQ..
19:13:56 <Cale> wy: A good alternate title would be "Why Lazy Evaluation Matters"
19:14:05 <ddarius> gwern: Purity does that, not laziness.
19:14:56 <Cale> wy: The good thing about lazy evaluation is that if any evaluation order terminates, then outermost-first will, whereas that isn't true for strict evaluation. This basically allows us some more freedom in how we decompose problems into parts.
19:15:04 <gwern> ddarius: no, I think that's a fair formulation. if you're not making sure only what will fit in memory will be evaluated, then you're being lazy and free of worrying about evaluation order
19:15:23 <Cale> wy: and that makes library functions which are lazy more useful.
19:16:07 <ddarius> gwern: If you add side-effects, laziness will require caring about evaluation order far more.  Also, laziness has it's own worries about memory.
19:16:36 <gwern> and no one ever worried about garbe collection?
19:17:41 <Cale> A small toy example I like to give is the naive substring searching algorithm. Think for a moment how you'd write it in an imperative language -- most likely, you'd use a pair of nested loops.
19:18:58 <MyCatVerbs> Cale: I take it that in Haskell, you'd run (matchFromHere string . tails)?
19:19:14 <ddarius> @src isInfixOf
19:19:14 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
19:19:15 <Cale> MyCatVerbs: you'd use any, tails, and isPrefixOf
19:19:25 <Cale> like that ^^ :)
19:19:53 <gwern> dons: btw, I was looking at the rss2irc code. how is it prevented from running multiple times on a given rss entry?
19:20:25 <Cale> along with...
19:20:27 <Cale> @src any
19:20:28 <lambdabot> any p =  or . map p
19:20:45 <Cale> In a strict language, this would be stupidly constructing all the tails of the list and checking each one to see if the string is a prefix, and then taking the or of the results.
19:21:08 <Cale> But that's a lot of wasted work if the string occurs right at the beginning, say.
19:21:40 <Cale> So in a strict language, you end up turning the algorithm inside out to make up for that.
19:21:41 <Eridius> well, you can write any in an imperative language such that it doesn't have that behavior, but it can't be implemented using map
19:22:07 <Eridius> although the tails bit would have to be turned into a generator function
19:22:43 <Cale> Well, generators and laziness are closely related.
19:22:46 <ddarius> Eridius: It's lazy v. eager, not imperative v. declarative.
19:22:55 <Eridius> bah
19:23:07 <sjanssen> Eridius: the Turing tarpit argument says we can write anything in anything.  The difference is how, what is encouraged, what is the default
19:23:13 <Eridius> true
19:23:38 <Cale> But I agree, if the norm was to use generators more often, you'd get some of the benefits of lazy lists.
19:24:09 <Cale> (ignoring all the other possible lazy data structures, and lazy evaluation of plain functions)
19:25:02 <Cale> But if all your libraries are written in terms of strict lists, then you'll run into problems using them.
19:26:12 <Cale> I think encouraging things to be as lazy as possible all the time is the best way to get the maximum composability, at least in regard to selection of evaluation order.
19:26:45 <Cale> On the other hand, there are cases where you want strictness because you don't want large expressions building up in memory.
19:27:46 <Cale> Those are generally the points where you're taking some large (probably lazily constructed) structure and summarizing it down to a simple value which does not need to be partially evaluated.
19:28:12 <Cale> and those cases are more often than not covered by special folds on our data structures.
19:28:20 <Cale> (like foldl')
20:07:48 <Moosefish> I'm trying write a quick and dirty DNS tool -- and I'm stuck wondering: what's an efficient way to read a network-order Word16 "into" a record?
20:08:45 <ddarius> getWord16be
20:15:25 <juios> http://www.youtube.com/watch?v=Hog9qGjT0Pw !!!!!!!!
20:20:29 <ivanm> sure, I"ll watch that random youtube video that someone came in, pasted the link to and then left!
20:20:34 <ivanm> @quote toothpaste
20:20:34 <lambdabot> olliej says: <olliej> java is a great language <olliej> i like to eat toothpaste <olliej> :)
20:29:22 <kerlo> Safer link: http://www.google.com/search?q=Hog9qGjT0Pw
20:32:35 <ivanm> kerlo: my point was, why would someone come here and paste a link to a youtube video without saying what it is or why
20:34:06 * kerlo shrugs
20:36:49 <MarcWeber> join #happs
20:37:10 <ivanm> MarcWeber: a '/' at the beginning would fix that ;-)
20:50:44 <burninator> has anyone here ever used Data.Binary.Strict.IncrementalGet ?
20:56:31 <seydar> how can I do a fold over IO (Either ...) ?
20:56:51 <seydar> my main issue is removing the whole IO business
20:57:11 <vininim> :t liftM
20:57:12 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:58:50 <vininim> well, once you go IO Monad, you (can) never go back.
20:59:10 <vininim> so you can only lift and bind functions
20:59:50 <burninator> how do you pass more data into the conintuation function returned by runGet in Data.Binary.Strict.IncrementalGet?
21:01:20 <seydar> > putStrLn "1337h4x, vininim"
21:01:21 <lambdabot>   * Exception: "<IO ()>"
21:01:27 <seydar> you shitbag!
21:02:10 <vininim> wat
21:02:27 <int-e> burninator: case result of Partial cont -> ... cont <more data> ...
21:03:53 <seydar> vininim: can you give me some examples using liftM
21:04:26 <burninator> ah, I see, thanks
21:05:14 <int-e> burninator: in fact the result of  runGet foo  is already such a continuation (it has type ByteString -> Result a as well.)
21:07:38 <vininim> seydar: liftM (map toUpper) getLine
21:07:45 <seydar> vininim: and the shitbag commented was because lambdabot gave me an exception
21:07:56 <vininim> (needs Control.Monad Data.Char)
21:08:17 <seydar> vininim: how do i know which Control.Monad thing i have to import?
21:08:51 <vininim> uh, the Control.Monad one does the job
21:09:09 <seydar> when do i have to import _that_?
21:09:25 <vininim> @hoogle liftM
21:09:25 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
21:09:25 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:09:25 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
21:09:44 <vininim> when you deal with monads, I guess =P
21:09:46 <burninator> sweet, I got a test program working.  Thanks int-e
21:10:10 <int-e> np
21:12:27 <seydar> vininim: thanks!
21:51:38 <b\6> does some standard library function return the number of processor cores?
21:54:02 <Axman6> @hoogle capabilities
21:54:02 <lambdabot> No results found
21:54:10 <Axman6> @hoogle numcap
21:54:10 <lambdabot> No results found
21:54:14 <Axman6> hmm
21:59:08 <b\6> Axman6: GHC.Conc numCapabilities
21:59:17 <Axman6> that's the one
21:59:22 <b\6> Axman6: thanks for providing magic word "capabilities".
21:59:29 <b\6> didn't know they called it that.
21:59:33 <Axman6> no worries
22:18:48 <ivanm> I've suddenly gotten an email about "CFP: Sixth International Conference on Remote Engineering and Virtual Instrumentation"
22:19:25 <ivanm> is this a real CFP-related conference that I'm hearing about because of the haskell mailing lists (even though I get them digested) or spam?
22:19:44 * inimino wonders if there is any other way to get an email
22:20:23 <ivanm> inimino: rather than suddenly you mean? ;-)
22:20:32 <ivanm> OK, fine: "I've just gotten..." ;-)
22:20:32 <inimino> I got the same one and deleted it without reading, fwiw
22:20:34 <inimino> ivanm: yes :)
22:21:05 <inimino> ah, much better :-)
22:22:01 <ivanm> the email itself looks legit (apart from the unsubscribe link down the bottom): what I'm querying is if it is legit, why did I get it :s
22:22:09 <inimino> so the answer to your question might be "both"
22:22:39 <b\6> hmm. my ghc 6.10.1 doesn't recognize RTS option -N. that weird?
22:23:11 <ivanm> inimino: heh
22:23:28 <ivanm> according to qhois, it's registered by "domainprivacyguard.com" :s
22:23:43 * ivanm leaves it in the spam folder
23:26:08 <edwardk> ok, finally gutted all the Data.Monoid.Monad.* classes
23:28:19 <ivanm> what were they, thut you had to take their guts out?
23:28:20 <mjk> i want get the first 7 numbers of 71/2260 (3.14159), but 71/2260=3.1415929203539826e-2
23:28:27 <ivanm> some type of aquatic animal? :p
23:28:31 <ivanm> @seen matthew-1
23:28:31 <lambdabot> matthew-1 is in #haskell, #haskell-blah and #ghc. I don't know when matthew-1 last spoke.
23:29:00 <Gracenotes> mjk: digits?
23:29:03 <mjk> 3.1415929203539826e-2 != 0.314159
23:29:08 <mjk> how to do it?
23:29:09 <edwardk> ivanm: i had a ton of source files filled with instances for the MTL, i moved as many as i could into the source files that declared the classes, leaving only a half dozen or so orphans for things that could legitimately be moved back into the source dists
23:29:29 <ivanm> edwardk: ahhh, so this is your own code?
23:29:29 <mjk> Gracenotes: yes
23:29:47 <ivanm> mjk: do what?
23:29:56 <ivanm> oh, you want to limit the precision?
23:30:01 <Gracenotes> > showFFloat (Just 7) (71/2260) ""
23:30:03 <mjk> [(x, y)|x<-[1..10000], y<- [1..10000], (take 7 $ show (x/y)) == "3.14159"]
23:30:03 <lambdabot>   "0.0314159"
23:30:09 <edwardk> ivanm: http://comonad.com/haskell/monoids/dist/doc/html/monoids/
23:30:15 <ivanm> you could possibly do it the fewdigits thingy in the numbers package...
23:30:32 <Gracenotes> wait, why would 71/2260 be greater than one, for that matter?
23:30:53 <mjk> sorry!my english is very poor
23:30:56 <Gracenotes> anyway, showFFloat allows fine-tuned showing of floats
23:31:07 <ivanm> Gracenotes: hmmm, dind't know about showFFloat
23:31:10 <ivanm> @type showFFloat
23:31:12 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
23:31:25 <Gracenotes> mjk: no problem. perhaps you mean 7100/2260 though?
23:31:26 <ivanm> > showFFloat Nothing pi ""
23:31:27 <lambdabot>   "3.141592653589793"
23:31:34 <ivanm> > showFFloat Nothing pi "pi"
23:31:34 <mjk> Gracenotes: how to import showFFloat?
23:31:36 <lambdabot>   "3.141592653589793pi"
23:31:40 <ivanm> @hoogle showFFloat
23:31:41 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
23:31:58 <Gracenotes> there's also showEFloat
23:32:02 <Gracenotes> which forces e notation
23:32:09 <ivanm> there's a Numeric module? :s
23:32:26 <ivanm> mjk: looks like "import Numeric" will get it for you
23:32:41 <mjk> OK, i test
23:32:57 <Gracenotes> I'm not sure if a package is required... hrm
23:33:11 <Gracenotes> nope, it's in base, you're fine
23:33:38 <Gracenotes> the extra string argument at the end can be ignored. It's just for efficiency in showing, like shows.
23:33:48 <Gracenotes> at least, I think it is. :3
23:33:56 <ivanm> "GHCi runtime linker: fatal error: I found a duplicate definition for symbol waitForProcess whilst processing object file /usr/lib/ghc-6.10.1/process-1.0.1.0/HSprocess-1.0.1.0.o" <-- what's this mean? :/
23:33:57 <Gracenotes> ignored meaning put the empty string there
23:34:17 <ivanm> Gracenotes: it's for what you want on the end, AFAICT
23:34:42 <Gracenotes> yeah. if it's like shows, it's efficiency related :3
23:35:02 <ivanm> oh? for when you're doing a lot of them?
23:35:11 <ivanm> (so you don't then have to do ++ to strings, I presume)
23:35:17 <Gracenotes> yeah, iirc.
23:36:31 <mjk> Gracenotes: how to get 0.031415926 from 71/2260, not 3.1415929203539826e-2?
23:36:40 <Gracenotes> >  4 `shows` ('w' `shows` (Just 4 `shows` " is all"))
23:36:41 <lambdabot>   "4'w'Just 4 is all"
23:37:02 <Gracenotes> mjk: by using showFFloat to specify the number of digits you want
23:37:16 <Gracenotes> I'm assuming you want it for showing purposes
23:37:24 <mjk> Gracenotes: yes
23:37:41 <Gracenotes> all right. then that function, from Numeric, should do it.
23:37:53 <mjk> OK,thanks
23:39:10 <Gracenotes> haskell also has a printf module
23:40:32 <ivanm> grrr..... ghc-pkg check says chart has a missing dependency so I rebuild it... but then it apparently _still_ has the missing dependency! :@
23:42:35 <Gracenotes> @src shows
23:42:35 <lambdabot> Source not found. Are you on drugs?
23:42:42 <Gracenotes> well, now that you mention it...
23:42:50 <Gracenotes> uh no.
23:43:22 <Gracenotes> showPrecs 0. a shortcut for the more 'efficient' method
23:43:44 <ivanm> Gracenotes: it's in the class, IIRC
23:43:46 <ivanm> @src Show
23:43:46 <lambdabot> class  Show a  where
23:43:47 <lambdabot>     showsPrec :: Int -> a -> ShowS
23:43:47 <lambdabot>     show      :: a   -> String
23:43:47 <lambdabot>     showList  :: [a] -> ShowS
23:43:50 <ivanm> or not...
23:43:52 <ivanm> @hoogle shows
23:43:53 <lambdabot> Prelude shows :: Show a => a -> ShowS
23:43:53 <lambdabot> Text.Show shows :: Show a => a -> ShowS
23:43:53 <lambdabot> Prelude type ShowS = String -> String
23:43:57 <ivanm> *shrug*
23:44:08 <ivanm> Gracenotes: then again, @src is hand-made rather than using ghc source, etc.
23:44:12 <Gracenotes> yeah
23:44:19 <Gracenotes> showPrecs is what the base datatypes implement
23:44:32 <Gracenotes> and show-only is for the lazy among us :)
23:47:32 <Gracenotes> I wish more typeclasses had default implementations, instead of auxiliary functions
23:47:49 <Gracenotes> MonadState: because sometimes you *can* make modify atomic.
23:49:16 <glguy> but its no good having a generic modify function if one of them is atomic
23:49:32 <glguy> you can't write generic code that way that assumes it operates atomically, sometimes
23:49:41 <mjk> Gracenotes: strange!! showFFloat (Just 2) (71/2260) "" is "0.03", but showEFloat (Just 2) (71/2260) "" is "3.14e-2",why?
23:50:09 <mjk> sorry
23:50:12 <mjk> i see
23:51:01 <Gracenotes> glguy: well, you can't assume that it operates atomically, which would be silly in many cases, but you can make a default implementation that behaves non-atomically and can be overwritten.
23:53:23 <Gracenotes> i.e. the current modify implementation
