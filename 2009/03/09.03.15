00:04:44 <callen> ddarius: if I was a dog, I'd be pretty scared of a ferret too.
00:05:21 <Axman6> ferrets smell bad
00:05:29 <callen> Axman6: which is why I won't get one.
00:05:35 <Axman6> me either
00:05:38 <callen> Axman6: I've seriously considered a fennec fox though.
00:05:39 <Axman6> they are very cute though
00:07:28 <callen> Axman6: yes.
00:07:31 * Gracenotes would like to get an octopus one day...
00:08:19 <Gracenotes> they're intelligent and can be affectionate (in their own way). Quite the teeth, though.
00:09:24 * lament would like to get a girl one day
00:09:36 <lament> they're intelligent and can be affectionate (in their own way). Quite the teeth, though.
00:12:39 <ivanm> lament: heh
00:25:43 <twb> lament: but they're also wily and duplicitous
00:26:12 <mmorrow> omg this C macro just changed my life
00:26:15 <mmorrow> #define FROMUPTO(i,m,n,stmt)  if(m < n){int i = m; do{stmt;} while(++i < n);}
00:26:54 <mmorrow> int xs[20]; FROMUPTO(i,0,20,{xs[i] = i;});
00:27:34 <twb> mmorrow: I'd be more impressed if you'd ported LOOP or INTERATE to CPP.
00:28:06 <mmorrow> twb: i'm intrigued. what are LOOP and ITERATE?
00:28:23 <twb> Lisp macros.
00:28:27 <Mr_Giraffe> oh, that's what my problem was D:
00:28:29 <mmorrow> ahh
00:28:32 <Mr_Giraffe> i just wasn't using SrcColorKey
00:28:34 <Mr_Giraffe> iiii'm an idiot
00:28:59 <twb> mmorrow: they're about the same order of awesomeness as thingies... [x | y <- z]
00:29:04 <Axman6> mmorrow: probably want some more bracketing there, to be safe
00:29:18 <twb> comprehensions?
00:30:34 <twb> (iterate (for i from 2) (for j upto 7) (x across my-vector) (when (plusp x) (collect (cons i j))) (maximizing x)) or some shit.
00:30:45 <mmorrow> Axman6: :)
00:31:00 <twb> It's the opposite extreme of using a whole heap of HOFs
00:31:14 <mmorrow> twb: where's a good place to find the definition of these two macros?
00:31:24 <mmorrow> (googling is only turning up examples of their _use_)
00:32:42 <harblcat> I wish I could look at Lisp code and parse it...
00:33:10 <callen> harblcat: I find it easier to parse than haskell thus far.
00:33:13 <mmorrow> found it
00:33:13 <leadnose> heh, it's easy when you get it
00:33:18 <mmorrow> (int the sbcl source)
00:33:26 <leadnose> like every other language also
00:33:38 <leadnose> or at least every sane
00:33:41 <leadnose> lang
00:33:47 <mmorrow> oh dear, loop.lisp is 2045 lines
00:34:04 <twb> At least loop isn't tree-walking
00:34:11 <twb> Iterate is
00:34:44 <twb> ...which effectively means you can't combine iterate with any other tree-walker (preprocessor).
00:35:13 <twb> Aaaanyway
00:35:53 <mmorrow> heh
00:45:32 <pumpkin> moo
00:49:06 <callen> pumpkin: moo. So where'd the name pumpkin come from?
00:49:27 <pumpkin> not sure, it was a while ago and I picked something random
00:49:40 <pumpkin> I've never even eaten anything pumpkin-derived
00:53:59 <callen> pumpkin: I just asked, because I know people who use it as a sobriquet.
00:54:22 <pumpkin> now there's a word I don't hear often :P
00:56:20 <callen> pumpkin: well. it's just, when I hear pumpkin i think of either a cute girl or a pet.
00:56:30 <pumpkin> who says I'm not one of those
00:56:46 <ivanm> pumpkin is a cute girl kept as a pet? :o
00:56:54 <ivanm> *shudder*
00:56:59 <pumpkin> yeah, Gracenotes keeps me as his slave
00:57:05 <pumpkin>  / pet
00:57:30 * Gracenotes tightens the collar roughly
00:57:41 <mmorrow> it's really too bad you can't have CPP do actual computation
00:57:48 <ivanm> pumpkin: funny occupation for someone with the name of a Roman Emperor...
00:58:13 <Gracenotes> :(
00:58:22 * Gracenotes releases pumpkin's collar and lets him go free
00:58:27 <pumpkin> times have changed in the past 1829 years
00:58:31 <callen> pumpkin: I can't debate Gracenotes keeping a pet, but I would bet cash you're not a girl.
00:58:39 <pumpkin> besides, commodus murdered me, didn't you see the movie?
00:58:46 <pumpkin> and I came back as a slave
00:58:55 <pumpkin> (a female slave / pet)
00:58:57 <mmorrow> omg are you an orange slave?
00:59:02 <pumpkin> yeah
00:59:06 <mmorrow> :o
00:59:07 <pumpkin> racist :(
00:59:08 <ivanm> pfffffttt..... didn't really like Gladiator :s
00:59:19 * callen facepalms because he took Latin and knows Roman history.
00:59:37 <ivanm> callen: care to summarise the relevant parts?
00:59:37 <pumpkin> hey, I'm from rome
00:59:39 <Gracenotes> yeah, what else to read in Latin? :)
00:59:47 <Gracenotes> (I kid)
00:59:52 <ivanm> Gracenotes: non-Roman history?
00:59:55 <pumpkin> catullus and his rudeness
01:00:19 <lament> Gracenotes: carmina burana
01:00:33 <pumpkin> oh yeah, and you can understand all the lyrics to the requiems (which are all the same)
01:00:47 * pumpkin is a fan of Verdi's one
01:00:55 <callen> ivanm: it's not actually certain if Commodus killed his father, it just happened to be convenient. Aurelius was a neglectful father because of his stoic philosophy. etc etc
01:01:05 <pumpkin> callen: he didn't
01:01:17 <pumpkin> at least it's not documented anywhere that he did
01:01:23 <pumpkin> but commodus was a sick fuck anyway :)
01:01:25 <callen> pumpkin: well, not personally, but again, he had plenty of motive.
01:01:59 <ivanm> callen: yeah, wiki says something like that...
01:02:01 <pumpkin> I should've worn that pig intestine and saved everyone from him
01:02:01 <ivanm> ;-)
01:02:31 <callen> ivanm: Bertrand Russell's History of western philosophy gives it a fair treatment, which is where I'm pulling it from.
01:02:44 <callen> ivanm: I read some other undergrad material on the pax romana, so I can share other inforamtion about that if you like.
01:02:56 <callen> ivanm: or if you'd like to make snarky comments about wikipedia, you can do that without me.
01:03:21 <ivanm> callen: snarky? :o
01:03:23 <pumpkin> someone's really defensive today :o
01:03:41 <pumpkin> ivanm's always snarky!
01:03:56 <ivanm> heh
01:04:04 * ivanm prefers "sarcastic"
01:04:12 <pumpkin> snarkastic
01:04:21 <Gracenotes> snarkasm
01:04:27 <ivanm> @slap Gracenotes
01:04:27 * lambdabot places her fist firmly on Gracenotes' jaw
01:05:02 <callen> lambdabot is a girl?
01:05:07 <ivanm> yes
01:05:10 <ivanm> @where lambdabot
01:05:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:05:17 <ivanm> ^^ here pic should be there
01:05:19 <ivanm> *her
01:06:05 <Gracenotes> @ixen a/s/l
01:06:05 <lambdabot> 19/f/California
01:06:19 <lament> vixen != lambdabot
01:06:22 <ivanm> hmmm.... is lambdabot's server really in California?
01:06:34 <Gracenotes> lament: proof enough for me
01:06:49 <Gracenotes> @vixen Are you lambdabot?
01:06:49 <lambdabot> no, why? do i seem "botty"?
01:07:01 <Gracenotes> hrmm. fair enough.
01:07:08 <lament> @vixen what is your name?
01:07:08 <lambdabot> My name is Emily
01:07:15 <ivanm> Gracenotes: care to get a private room if you're going to continue your affair with @vixen?
01:07:15 <lament> vixen is emily
01:07:27 <lament> lambdabot is uhhh something else?
01:07:27 <Gracenotes> who says lambdabot's given name isn't Emily?
01:07:29 <ivanm> WHAT.... is your name?
01:07:41 <ivanm> WHAT.... is your quest?
01:07:44 <Gracenotes> oh look, a quote!
01:07:52 <ivanm> ;-)
01:07:55 <pumpkin> @quote lambdabot
01:07:56 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
01:08:36 <Gracenotes> @vixen what did you eat for dinner?
01:08:36 <lambdabot> yeah, and i'm hungry right now
01:08:49 <callen> ...
01:10:17 <mmorrow> this is handay
01:10:19 <mmorrow> #define SLIDE(sp,n,by) {int __n=(n), __by=(by);while(--__n>=0){(sp)[__n+__by]=(sp)[__n];}(sp)+=__by;}
01:10:31 <pumpkin> #define WRANGLE
01:10:35 <mmorrow> hehe
01:10:36 <pumpkin> you need one of those
01:10:42 <mmorrow> good idea
01:10:50 <mmorrow> (seriously ;)
01:10:59 <pumpkin> I'm always a great source of good ideas
01:11:05 <callen> @vixen dinner
01:11:06 <lambdabot> do you have toys?
01:11:12 <callen> ...?
01:11:14 <callen> @vixen toys
01:11:15 <lambdabot> Let's change the subject
01:11:21 <pumpkin> @vixen do you like toys?
01:11:21 <lambdabot> sure, i definitely don't hate
01:11:29 <callen> @vixen do you hate toys?
01:11:29 <lambdabot> hating doesn't get you anywhere, so no
01:11:50 <callen> @vixen what do you think of pumpkin?
01:11:50 <lambdabot> let's don't talk about that
01:11:54 <callen> LOL
01:12:17 <ski> @vixen what do you think about grothendieck toposes?
01:12:17 <lambdabot> i dunno, what about?
01:12:47 <pumpkin> @vixen how about zygohistomorphic prepromorphisms?
01:12:47 <lambdabot> how? it depends...
01:20:06 <mmorrow> omfg jackpot http://people.freebsd.org/~jasone/jemalloc/progs/rb.h
01:20:14 <callen> @eliza what's your name?
01:20:14 <lambdabot> WhAt'$ Your NA/\/\3?
01:20:24 <mmorrow> (i've seen this before, but found it again by accident)
01:20:29 <callen> @eliza what's your name?
01:20:29 <lambdabot> \/\/|-|A7'$ y0UR nAme?
01:20:56 <callen> @eliza how are you?
01:20:57 <lambdabot> H0\/\/ arE YOU?
01:21:00 <mmorrow> complete cpp'ed implem of red-black trees
01:21:05 <callen> @eliza what's with the leet speak?
01:21:05 <lambdabot> \/\/|-|AT'z0rz wit|-| 7HE 1EE+ zPEak?
01:21:16 <mmorrow> @. elite nixon
01:21:16 <lambdabot> your boy$ Wi|1 83 homE for c|-|rI5+/\/\az.
01:21:17 <callen> @eliza what do you think of pumpkin?
01:21:17 <Cale> That's @elite, if you spell it correctly ;)
01:21:17 <lambdabot> \/\/|-|47 D0 Y0u 7|-|INx oF PUMPxiN?
01:21:39 <wks> wow, doing everything at preprocessing time?
01:21:51 <callen> @vixen who is eliza?
01:21:51 <lambdabot> that's a good question, who?
01:22:33 <ivanm> @. elite quote
01:22:33 <lambdabot> nUmeRODix SAyz: TbH: P3oP1e WHO DO hASKE11 on 7|-|eIR oWn iNi+IA7IvE KInDa cREEP ME OuT :)
01:22:50 <callen> @quote
01:22:50 <lambdabot> YHC says: There is currently no debugging system available. Please write correct programs.
01:23:38 <pumpkin> mmorrow: rb_remove is terrifying
01:23:56 <daf> hmm, cabal seems confused:
01:23:57 <daf> cabal install --user json
01:23:57 <daf> Downloading 'base-4.0.0.0'...
01:24:18 <callen> pumpkin: I can honestly say that I have no idea what rb_remove is doing.
01:24:19 <ivanm> daf: do you have ghc-6.10.1 ?
01:24:30 <daf> yes
01:24:30 <pumpkin> removing from a red black tree, clearly ;)
01:24:40 <ivanm> because it looks like the latest version of json requires it :s
01:24:43 <callen> pumpkin: this is almost as bad as some of the C puzzles I see.
01:24:43 <mmorrow> pumpkin: yeah, rb deletion is epic
01:24:44 <callen> potentially worse.
01:24:55 <mmorrow> that's the particular thing i'm so happy about
01:24:59 <callen> mmorrow: is it really worth dealing with this code to implement RB trees?
01:25:07 <mmorrow> (my current C rbtree implem has no delete :(
01:25:12 <daf> ivanm: ghc-pkg lists base 4.0.0.0
01:25:23 <pumpkin> aw
01:25:26 <mmorrow> callen: it's that or implement delete myself
01:25:27 <wli> Is there a way to get 6.10.1 with the readline patch via cabal?
01:25:50 <mmorrow> callen: personally, i think that .h is particularly purdy :)
01:25:59 <osfameron> jrockway: hello there ;-)
01:26:11 <wli> mmorrow: It's a bit easier when the elements of the rbtree are furthermore linked into a sorted list. Some of the searches during deletion are made much easier.
01:26:23 <callen> mmorrow: yes but what are you using the tree for?
01:26:26 <osfameron> jrockway: yeah, tis much more complicated than i thought
01:26:33 <mmorrow> callen: many different things
01:26:58 <mmorrow> callen: also, that cpp implem is polymorphic in the type
01:27:07 <mmorrow> callen: i'm currently just using void* everywhere
01:27:15 <pumpkin> beautiful ;)
01:27:33 <wli> mmorrow: The list position for insertion is determined via tree search at insertion, and the immediate successors and predecessors in the tree to replace the node with are adjacent in the list to assist deletion from the tree.
01:28:13 <mmorrow> wli: hmm
01:28:16 <daf> dcoutts_: if you're around, any ideas re ^^^?
01:28:42 <wli> mmorrow: Rebalancing the tree remains a FPITA though.
01:29:19 <mmorrow> wli: heh, yeah totally
01:30:30 <mmorrow> hmm, i think i may just snake his delete, since my implem is a lot prettier ;)
01:31:53 <wli> mmorrow: I get killed trying to re-ascend from the root. I can never figure out where to orient the rebalancing or anything.
01:32:30 <wli> mmorrow: Or how to properly check or update the balance info.
01:33:02 <wli> Skylarovv
01:35:33 <mmorrow> gotta love function ptrs
01:35:37 <mmorrow> NODE *tadd(NODE *t,void*(*addk)(void*,void*),void*(*addv)(void*,void*),int(*cmp)(void*,void*),void *k,void *v);
01:35:51 <pumpkin> beautiful
01:35:55 <mmorrow> :)
01:35:58 <pumpkin> just leave out the actual definitions
01:36:00 <pumpkin> make it all void *
01:36:05 <pumpkin> not definitions, but the parameter types
01:36:43 <wli> mmorrow: There's the Linux trick where they rely on the caller to descend to a leaf and so the common code needs no comparisons.
01:37:24 <mmorrow> wli: oh cool
01:59:13 <wli> mmorrow: I think I should use the STG core language as the source language.
01:59:59 <wli> Interesting here is http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.96.5887
02:02:54 <wli> mmorrow: My register machine notions seem to have some justifications beyond merely their being what I can understand.
02:05:42 <flodin> anyone know what's up with the ordinary citeseer?
02:05:57 <wli> It's been decommissioned.
02:06:06 <wli> citeseerx is its replacement.
02:06:42 <Saizan> anyone know if there's a repo for the dotgen package?
02:06:44 <flodin> seems citeseerx is missing documents that citeseer had though
02:08:36 <wli> That is true.
02:11:24 <wli> Hmm. Tailcalls seem to have to do with strictly-known sequencing. I'm not sure where true calls come in.
02:11:40 <wli> That basically means forcing values via case.
02:11:48 <mmorrow> wli: yeah, i'm using a level above that as my input "core" lang, and then translate (Lvm is kinda == STG) Core -> Lvm -> Asm -> Asm -> Asm
02:11:54 <mmorrow> (where Asm is bytecode)
02:12:32 <wli> mmorrow: Did you see the speedups they got for using register-based JVM analogues?
02:12:54 <mmorrow> (the name "Lvm" is a hold-over from when i originally wrote that module, but it's been changed from its original form)
02:13:08 <pierre-> ?hoogle connectTo
02:13:08 <lambdabot> No results found
02:13:15 <mmorrow> wli: yes indeed, i have that paper printed out and in my at-hand stash :)
02:13:24 <pierre-> hmm, where could I find connectTo?
02:14:00 <wli> mmorrow: It appears there may be advantages to abstract register machines beyond merely being comprehensible to me.
02:14:02 <mmorrow> wli: malcolmw gave me this pdf which is a student of his's master's thesis, which details a modification of the yhc bytecode interp to be a register machine instead
02:14:05 <mmorrow> it's friggin great
02:14:13 <mmorrow> i'll put it up and link you..
02:14:15 <wli> mmorrow: DCC
02:14:40 <wli> I think ordinary calls that push stack frames etc. correspond to unwinding the spine!
02:15:30 <Saizan> since when default is a keyword?
02:15:31 <wjt> istr magnus therning was working on automatically debianizing packages from hackage, and had a repo somewhere, but i can't find mention of it in my -cafe archives. was i imagining it?
02:15:51 <wli> mmorrow: I think I've found the big answers I was looking for.
02:15:52 <ivanm> wjt: there's a tool for it on hackage IIRC...
02:16:00 <ivanm> @go therning debian haskell
02:16:01 <lambdabot> No Result Found.
02:16:06 <ivanm> @go debian haskell
02:16:07 <lambdabot> No Result Found.
02:16:11 <ivanm> hmmm.....
02:16:18 <ivanm> @go haskell
02:16:20 <lambdabot> http://www.haskell.org/
02:16:20 <lambdabot> Title: Haskell - HaskellWiki
02:16:22 <ivanm> *phew*
02:17:46 <mmorrow> wli: ah, i already stuck it up
02:17:49 <mmorrow> wli: http://moonpatio.com/repos/ans104_project.pdf
02:18:02 <wjt> ivanm: okay, i'll look
02:18:36 <wli> mmorrow: Fantastic!
02:18:44 <ivanm> @go hackage debian
02:18:45 <lambdabot> No Result Found.
02:18:50 <mmorrow> wli: it's been really super helpful
02:19:28 <ivanm> @hackage debian
02:19:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/debian
02:19:30 <ivanm> wjt: ^^
02:19:33 <mmorrow> wli: also, i have haddocks for ghc at http://moonpatio.com/docs/ghc
02:19:44 <mmorrow> (with source links!)
02:19:46 <ivanm> along with a few others there
02:19:52 <mmorrow> like, this might be interesting http://moonpatio.com/docs/ghc/ByteCodeInstr.html
02:21:22 <wli> cool
02:21:26 <mmorrow> wli: and here's the yhc bytecode defs/types for reference http://moonpatio.com/repos/LIBS/Language/yhc/src/compiler98/ByteCode/Type.hs
02:21:49 <mmorrow> (i put a bunch of stuff on moonpatio since it sends everything as text/plain)
02:25:20 <wli> mmorrow: Hmm. I think I'm moving in different directions from most of these things.
02:25:37 <mmorrow> wli: cool
02:26:28 <wli> mmorrow: I don't know if it's cool or not. I mostly have a lot of trouble understanding them.
02:26:35 <mmorrow> hehe
02:28:29 <wli> These abstract machines with states, instructions, etc. that are super-complex etc. completely lose me. I need operations that do less at a time.
02:29:28 <mmorrow> wli: here's the actual C code that interprets yhc's bytecode instrs http://moonpatio.com/repos/LIBS/Language/yhc/src/runtime/BCKernel/mutins.h
02:29:44 <mmorrow> (it's much more readable than ghc's equivalent)
02:30:08 <mmorrow> but here's that too http://moonpatio.com/repos/LIBS/Language/ghc/rts/Interpreter.c
02:30:19 <wli> mmorrow: My huge problem with control flow seems to be getting smacked down, though. Ordinary calls correspond to spine unwinding, and tailcalls correspond to forcing values.
02:31:52 <NameAlreadyInUse> is callCC like call/cc from scheme? i am having trouble understanding it
02:32:17 <ivanm> @hoogle callCC
02:32:17 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
02:32:28 <wli> Returns from a stack frame correspond to whatever happens when you reduce the far end of the spine (what's that called?) to a value.
02:32:31 * ivanm isn't quite sure what that does...
02:32:41 <Saizan_> callCC $ \currentContinuation -> ...
02:32:59 <mmorrow> wli: hmm, i'm not too familiar with the G-machine and its spine
02:34:33 <wli> mmorrow: This has nothing to do with the G-machine, this is just graph reduction.
02:34:35 <Saizan_> NameAlreadyInUse: afaiu scheme it should, but restricted to the Cont monad, http://www.haskell.org/all_about_monads/html/contmonad.html
02:40:12 <mmorrow> hmm, in that case i'd put it as.... all calls are tailcalls, and every function is O(1) (until you print it, or otherwise need to know its value)
02:41:29 <mmorrow> welllll, i guess it's a matter of perspective whether or not all calls are tailcalls
02:43:01 <wli> mmorrow: Ah, but you manually construct a stack in the heap when unwinding the spine.
02:43:17 <mmorrow> wli: yes
02:44:22 <wli> mmorrow: So function calls should be usable to construct that via activation records.
02:45:15 * wli doesn't know how to do quickcheck for that.
02:45:31 <mmorrow> heh
02:45:57 <wli> mmorrow: The quickcheck bit was Faulhaber formula stuff on #haskell-blah
02:51:46 <wli> I'm thinking that the code associated with the left child of an @ node needs to be able to find its right sibling.
02:53:10 <mmorrow> wli: that's what PAP heap nodes are essentially
02:53:33 <mmorrow> in the spineless G-machine, they can take more than one value
02:53:46 <NameAlreadyInUse> what is this "G-machine" anyway?
02:53:57 <mije> has somebody had an issue with installing terminfo form cabal on a ghc 6.10.1 ? i end up with a syntax error in ghc/include/Rts.h
02:54:20 <mmorrow> NameAlreadyInUse: it's an abstract machine that was thought up in the 80s for evaluating lazy functional languages
02:55:13 <NameAlreadyInUse> mmorrow: so is it like the lazy functional equivalent of asm?
02:55:26 <wli> It seems like every @ corresponds to a function call, where you call the left child with the right child as an argument.
02:55:34 <wli> NameAlreadyInUse: Basically yes.
02:56:00 <mmorrow> wli: every @ corresponds to building a PAP heap node
02:56:15 <mmorrow> actually a PAP is precisely an @
02:56:48 <mmorrow> and if you're going spineless, you move from binary trees of @ nodes to rose trees
02:57:45 <wli> Because not every function is unary?
02:57:48 <NameAlreadyInUse> is there a freely available resource that i can browse to learn more about these G-machines?
02:58:00 <mmorrow> wli: like, say you have
02:58:11 <mmorrow> f a b c d = a + b + c + d
02:58:13 <mmorrow> and then
02:58:30 <mmorrow> g f x = f x
02:58:41 <mmorrow> g (f 0 1 2) 3
02:58:49 <mmorrow> in the STG you'd build
02:59:31 <mmorrow> x <- PAP f [0,1,2]; y <- FUN g [x,3]
02:59:37 <mmorrow> in the G it'd be
03:00:18 <mmorrow> x <- PAP f 0; y <- PAP x 1; z <- PAP y 2; a <- PAP g z; b <- FUN a z
03:00:38 <ivanm> NameAlreadyInUse: wikipedia? :s
03:01:03 <ivanm> I take it back, wiki doesn't have it :s
03:01:04 <mmorrow> (where "x <- ..." means allocating a heap node for "...", and binding the corresponding ptr to "x")
03:01:20 <wli> mmorrow: That's pretty much what I thought.
03:01:30 <wli> mmorrow: b <- FUN a 3?
03:01:32 <mmorrow> (and it being implied that a literal number there is actually boxed)
03:01:44 <mmorrow> wli: the FUN means that it's fully applied
03:02:16 <mmorrow> (i kinda made up the name "FUN", and diff implems might call it something different. but the idea is the same)
03:02:31 <wli> Yeah, but it's g (f 0 1 2) 3, not g (f 0 1 2) (f 0 1 2)
03:02:47 <mmorrow> oops, yeah myt bad
03:03:20 <mmorrow> b <- FUN a 3
03:04:20 <mmorrow> NameAlreadyInUse: yes, there is
03:04:26 * mmorrow gets a link
03:04:45 <pumpkin> omg 6am!
03:04:47 <pumpkin> whe
03:04:48 <pumpkin> e
03:05:11 <mmorrow> NameAlreadyInUse: there are a bunch, but here's one that (i'm sure is findable via google, but i happen to have it here already) http://moonpatio.com/repos/implem_functlang.pdf
03:05:26 <Heffalump> pumpkin: up at 6am on a Sunday? How silly.
03:05:45 <pumpkin> Heffalump: I'll be sleeping in, don't worry :P
03:06:43 <Heffalump> ah. That's "up at 6am on a Saturday night" :-)
03:06:52 <Heffalump> I used to be able to do tha.
03:07:13 <pumpkin> I'll feel less justified pulling all nighters when I'm done with school
03:07:27 <pumpkin> maybe one day I'll have a normal sleep pattern
03:08:11 <Heffalump> I was planning on sleeping in but my son had different ideas
03:08:24 <NameAlreadyInUse> mmorrow: ok, thanks for the link
03:09:37 <ManateeLazyCat> I wrote 'module' code for export, i have data type named "Example", i wrote "Example (..)" in module block, what's "(..)"? I can't understand why need "(.."). Any help? Thanks.
03:10:05 <ManateeLazyCat> is "(..)"
03:11:48 <ManateeLazyCat> What's different between "Example" and "Example (..)"?
03:12:10 <pumpkin> that'll export all constructors for a type
03:12:13 <pumpkin> I think
03:13:30 <ManateeLazyCat> pumpkin: Which one can export all constructors?
03:13:36 <pumpkin> (..)
03:13:42 <pumpkin> actually
03:14:05 * pumpkin shrugs
03:14:10 <ManateeLazyCat> pumpkin: What is (..)?
03:14:10 <ManateeLazyCat> pumpkin: I can't understand ".."
03:14:52 <mmorrow> module Foo (Example) where    only exports the type name
03:15:08 <mmorrow> module Foo (Example(..)) where    exports the type name along with all constructor
03:15:34 <mmorrow> module Foo (Example(This)) where    exports the type name and only one of the constructors
03:15:43 <mmorrow> (the con called "This")
03:16:09 <ManateeLazyCat> mmorrow: So if i just want export "A" constructor, i can write like this "module Foo (Example (A)) where"?
03:16:13 <wli> Well, the redexes unwind so that you have %o0 <- closure f, {}, {#0, #1, #2, ?} ; %o1 <- #3 ; %l0 <- call g at the top level, then in g, %o0 <- ld 1(%i0), %o1 <- ld 2(%i0), %o2 <- ld 3(%i0) ; %o3 <- #3 ; %l0 <- call f
03:16:18 <mmorrow> ManateeLazyCat: yes
03:16:42 <ManateeLazyCat> mmorrow: So (..) is all constructors that along with name?
03:16:44 <Axman6> pumpkin: you know MATLAB?
03:16:48 <mmorrow> ManateeLazyCat: yes
03:16:48 <pumpkin> sadly
03:16:57 <ManateeLazyCat> mmorrow: Clear enough, thank you very much! :)
03:17:02 <mmorrow> :)
03:17:03 <Axman6> pumpkin: any chance i could ask you for help in the future?
03:17:19 <pumpkin> sure, but I abhor the language
03:17:28 <Axman6> heh
03:17:33 <pumpkin> and am not an expert by any means
03:18:02 <mmorrow> wli: that looks right. (but that would only happen when it comes time to actually force the value of course)
03:18:16 <wli> Maybe return values go in %o[0-9]+ etc.
03:18:29 <Axman6> well, as long as you know something about it :) (hopefully statistical stuff...)
03:20:40 <wli> %o0 <- closure f, {}, {#0, #1, #2, ?} ; %o1 <- #3 ; %o0 <- call g ; ret at the top level, then in g, %o0 <- ld 1(%i0), %o1 <- ld 2(%i0), %o2 <- ld 3(%i0) ; %o3 <- #3 ; %o0 <- call f ; ret ; and in f, %l0 <- %i0 + %l1 ; %l1 <- %i2 + %i3 ; %o0 <- %l0 + %l1 ; ret
03:21:31 <wli> in f, %l0 <- %i0 + %i1 ; %l1 <- %i2 + %i3 ; %o0 <- %l0 + %l1 ; ret
03:22:02 <Axman6> o.O
03:23:13 <wli> %i are input registers for function arguments, %l are local registers for temporary affairs, and %o are output values for values passed on to targets of control flow transitions, whether they be calls, tailcalls, or returns.
03:23:17 <Axman6> wli: what is that?
03:23:52 <wli> Axman6: Register windowed register machine abstract asm in SPARC-like syntax.
03:24:02 <Axman6> ooo, nice :)
03:24:41 <wli> I actually like using $ like Algorithmics' MIPS vs. %
03:25:44 <wli> And $t instead of %l
03:28:55 <mopped> > let f L = takeWhile (\x -> x == head $ L) L in f "aaaaabbc"
03:28:55 <lambdabot>   Not in scope: data constructor `L'Not in scope: data constructor `L'Not in ...
03:29:09 <mopped> > let f l = takeWhile (\x -> x == head $ l) l in f "aaaaabbc"
03:29:10 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
03:29:11 <mije> is it possible to remove an installed library using cabal ?
03:29:20 <wli> I actually need a $gp or some such for the closure environments.
03:29:51 <wli> I guess I could call it $e
03:30:46 <ski> > let f l = takeWhile (\x -> x == head l) l in f "aaaaabbc"
03:30:48 <lambdabot>   "aaaaa"
03:31:09 <mopped> Will head l be computed each time the predicate is tested?
03:31:25 <mopped> would it be best to bind head l to a value or
03:31:26 <wli> Or, I suppose, I could have a register class for the closure environments.
03:31:27 <ski> maybe
03:31:57 <mopped> > let f l = takeWhile (\x -> x == y) l where y = head l in f "aaaaabbc"
03:31:58 <lambdabot>   "aaaaa"
03:32:38 <ski> > let f l = takeWhile ((==) . head l) l in f "aaaaabbc"
03:32:39 <lambdabot>   Couldn't match expected type `Bool'
03:32:57 <ski> um
03:33:05 <ski> > let f l = takeWhile (== head l) l in f "aaaaabbc"
03:33:06 <lambdabot>   "aaaaa"
03:33:44 * ski tries to recall how sections was expanded
03:33:50 <Deewiant> > let f = (==) . head >>= takeWhile in f "aaaaabc"
03:33:51 <lambdabot>   "aaaaa"
03:34:15 <Deewiant> > let f l = takeWhile ((==) $ head l) l in f "aaaaabc" -- ski
03:34:16 <lambdabot>   "aaaaa"
03:35:02 <ski> ( Deewiant : i don't believe that's how that section is expanded ..)
03:35:23 <gio123> ski:hi
03:35:29 <Deewiant> ski: a == b  -->  (==) a b
03:35:48 <ski> yes, however i had `(== b)'
03:36:32 <Deewiant> Yes, so that's \a -> (==) a b
03:36:39 <ski> the question was whether `(== <expr>)' expands to `\x -> x == <expr>' or to `let y = <expr> in \x -> x == y'
03:36:53 <Deewiant> Same difference?
03:37:23 <ski> in the former, barring lambda-lifting or something, you will evaluate `<expr>' each time the function is called
03:37:27 <ski> not so in the latter
03:38:11 <Deewiant> That's irrelevant, leave it to the optimizer ;-P
03:38:44 <Deewiant> The report says only that '(op e)  =  \ x -> x op e'
03:38:59 <ski> aye
03:39:40 <Deewiant> If you want to be sure, write it as a let in the first place, I'd assume that it's not translated to that form
03:43:30 <Axman6> http://www.troubleshooters.com/codecorn/primenumbers/primenumbers.htm quite an excellent article
03:43:43 <pumpkin_> moo
03:43:55 <Axman6> hmm, not at all haskell related (except for my reasons for trying to find it), but still very good
03:44:49 <pumpkin_> :)
03:45:04 <povman> squark
03:50:22 <wli> It looks like it'd be much easier to do in Haskell up until it starts paging.
03:51:44 <yitz> wli: oneil has a more functional approach - she uses a lazy priority queue instead of the array.
03:52:30 <wli> I know all about it. I've got a one-liner monadic priority queue-based sieve floating around, albeit a relatively long line.
03:53:53 <yitz> wli: anything can be a one liner then
03:54:02 <wli> > let primeStep n = let cmpStep ((k, ps), m) | n /= k = tell [n] >> modify (Map.insertWith (++) (n*n) [n]) | otherwise = put . Map.unionWith (++) m . Map.fromListWith (++) $ [(k + p, [p]) | p <- ps] in gets Map.minViewWithKey >>= maybe (tell [n] >> put (Map.singleton (n*n) [n])) cmpStep in take 10 . flip evalState Map.empty . execWriterT $ mapM_ primeStep [2..]
03:54:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
03:54:40 <wli> I didn't do a wheel, though.
03:55:06 <wli> I couldn't quite cram a wheel into IRC line length limits.
03:55:20 <yitz> wli: take out 2 at least
03:55:24 <wli> Not atop of that anyway.
03:56:06 <yitz> > 2:[3,5..]
03:56:07 <wli> yitz: Pissing in the wind. A wheel would nuke all multiples of the first several primes.
03:56:08 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
03:56:44 <yitz> wli: taking out the evens is still a big help, even if you can't do a full wheel.
03:57:47 <wli> It's not illustrative of an extensible technique, where the priority queue maintained as state is.
03:58:58 <yitz> wli: do you have room for 2:3:5:[x+y|x<-[0,30..],y<-[7,11,13,17,19,23,29,31]]?
03:59:46 <yitz> wli: the full wheel doesn't do all that much better than that
04:00:01 <yitz> maybe 10%
04:00:36 <wli> I probably could, but I don't see it as much better than yanking out 2. It's really all purely pedagogical.
04:00:47 <pumpkin_> my wheel has chrome rims
04:00:52 <Peaker> I check out the Euler 31 solution page to see how elegant my solution is next to the others
04:01:03 <wli> Peaker: URL?
04:01:04 <Peaker> The first thing I see- is a dos DEBUG.EXE 20-line assembly solution. heh
04:01:16 <wli> heh
04:01:16 <TSC> http://projecteuler.net/index.php?section=problems&id=31
04:01:19 <Peaker> wli: I think access is restricted until you have the solution
04:01:26 <yitz> Axman6: that article doesn't go the next obvious step, which is the Atkin sieve.
04:01:49 <pumpkin_> I can't even remember how I did that one
04:01:56 <Axman6> i still found it interesting :)
04:01:56 <yitz> Axman6: but that's understandable, it was discovered around the same time that article was written
04:01:57 <pumpkin_> and it was only a couple of months ago :O
04:02:07 <Axman6> heh
04:02:49 <wli> If I did that one, I never submitted a solution.
04:03:13 <pumpkin_> p = 1/((1 - x)*(1 - x^2)*(1 - x^5)*(1 - x^10)*(1 - x^20)*(1 - x^50)*(1 - x^100)*(1 - x^200))
04:03:13 <pumpkin_> Series[p, {x, 0, 201}]
04:03:20 <pumpkin_> that one's quite elegant :)
04:04:36 <TSC> The newest problem looks interesting
04:06:17 <Taejo> @pl (\ x y -> (x-y) ^ 2)
04:06:17 <lambdabot> flip flip 2 . ((^) .) . (-)
04:07:07 <Deewiant> "flip flip <non-function>" always looks weird to me
04:07:13 <Taejo> me too
04:07:22 <Taejo> :t flip 2
04:07:23 <lambdabot> forall a b c. (Num (a -> b -> c)) => b -> a -> c
04:07:40 <yitz> @type flip flip
04:07:41 <Taejo> :t flip flip
04:07:42 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
04:07:42 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
04:08:10 <Taejo> :t (==) `on` fst
04:08:11 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
04:12:23 <Taejo> @where comparing
04:12:23 <lambdabot> I know nothing about comparing.
04:12:28 <Taejo> @hoogle comparing
04:12:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:12:28 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
04:13:56 <mopped> @src flip
04:13:56 <lambdabot> flip f x y = f y x
04:18:58 <Baughn> Axman6: There was a good reason, I swear
04:19:23 <pumpkin_> will I regret trying agda?
04:20:06 <Axman6> you're a dirty rotten liar. there can be no possible reason for that monstrosity!
04:20:10 <Axman6> :P
04:20:33 <pumpkin_> :o
04:20:51 <Axman6> > concat $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b) -- demonstration for my girlfriend
04:20:52 <lambdabot>   "(((5(,(9()2(252,292),(,5,,,9,)3(353,393))()5),)9))"
04:21:03 <pumpkin_> :o
04:21:30 <pumpkin_> forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
04:21:32 <pumpkin_> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
04:21:33 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
04:21:46 <Axman6> she says: you should have said my hot sexy naked girlfriend
04:21:48 <Heffalump> @type forM
04:21:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:21:55 <pumpkin_> she's naked :o
04:22:10 <Axman6> not yet >_>
04:22:25 <pumpkin_> lol
04:22:29 <Heffalump> presumably that code is doing something evil with the list monad, but I can't figure out what
04:22:49 <Axman6> > concat $ forM [(1,2), (2,1)] $ \(a,b) -> show (b,a+b) -- demonstration for my girlfriend
04:22:51 <lambdabot>   "(((1(,(3()2(212,232),(,1,,,3,)3(313,333))()1),)3))"
04:23:01 <Axman6> lame, not palindromic :
04:23:04 <Axman6> :(*
04:23:15 <pumpkin_> oh, I get it
04:26:12 <Baughn> @src forM
04:26:13 <lambdabot> forM = flip mapM
04:26:17 <Baughn> @src mapM
04:26:17 <lambdabot> mapM f as = sequence (map f as)
04:26:18 <ski> > forM [(1,2), (2,1)] $ \(a,b) -> show (b,a+b)
04:26:20 <lambdabot>   ["((","(1","(,","(3","()","2(","21","2,","23","2)",",(",",1",",,",",3",",)"...
04:26:44 <Baughn> > map (\(a,b) -> show (a,a+b)) [(1,2),(2,1)]
04:26:46 <lambdabot>   ["(1,3)","(2,3)"]
04:27:02 <pumpkin_> > mapM (\(a,b) -> show (a,a+b)) [(1,2),(2,1)]
04:27:04 <lambdabot>   ["((","(2","(,","(3","()","1(","12","1,","13","1)",",(",",2",",,",",3",",)"...
04:27:18 <Baughn> Could we call this a list-monad zen moment? :P
04:27:38 <ski> why ?
04:27:41 <pumpkin_> :)
04:27:49 <Baughn> > mapM show [(1,2),(2,1)]
04:27:50 <lambdabot>   ["((","(2","(,","(1","()","1(","12","1,","11","1)",",(",",2",",,",",1",",)"...
04:28:07 <Baughn> > concat $mapM show [(1,2),(2,1)]
04:28:08 <lambdabot>   "(((2(,(1()1(121,111),(,2,,,1,)2(222,212))()2),)1))"
04:28:38 <ski> > sequence ["(1,3)","(2,3)"]  -- ..
04:28:39 <lambdabot>   ["((","(2","(,","(3","()","1(","12","1,","13","1)",",(",",2",",,",",3",",)"...
04:28:45 <pumpkin_> how do I use agda?
04:28:51 <ski> with care
04:29:01 <pumpkin_> it's installed, but I can't seem to find anything to run :P
04:29:21 <pumpkin_> the .cabal file says it's a library
04:29:24 <ski> try running emacs with agda2-mode ?
04:29:38 <pumpkin_> I don't wanna run emacs, it makes me feel dirty :(
04:29:56 <ski> how so ?
04:30:27 <Taejo> are there Ubuntu debs for GHC 6.10 anywhere?
04:30:27 <pejo> pumpkin, you want some support from your editor, especially in the beginning.
04:30:38 <pumpkin_> ah :/ fine
04:30:39 <bremner> Taejo: there are debian ones....
04:30:51 <Taejo> bremner: where?
04:30:57 <bremner> in debian :-)
04:31:11 <bremner> Taejo: seriously, in the unstable repos
04:31:42 <Taejo> bremner: ok
04:32:19 * wli grinds out a quick solution to Project Euler #31.
04:32:21 <bremner> Taejo: whether that works for your flavour of Ubuntu, I dunno.
04:32:37 <Baughn> "When haskell does pushups, it doesn't bother with the pushups and just makes pushup-y sounds if someone asks."
04:37:05 <dcoutts> daf: what version of cabal-install are you using? The recent versions should not try to download base.
04:37:11 <daf> dcoutts: 0.6.2
04:37:35 <dcoutts> daf: hmm
04:37:38 <daf> dcoutts: when it tries, it then decides that rts, integer, etc are missing
04:37:46 <daf> dcoutts: and then gives up
04:38:08 <daf> dcoutts: it seems to only be looking at ghc-pkg --user list
04:38:32 <dcoutts> daf: could you paste the output of ghc-pkg list and cabal install --user json --dry -v
04:38:43 <dcoutts> @hpaste
04:38:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:38:54 <ImInYourMonad> ok so i have pure-fft installed now from hackage. what is a good example of fft, preferrably a practical application? could fft be used in encoding/decoding of music/movies?
04:39:06 <bremner> has anyone par-ized some sieve variant?  I saw a nice simple version based on a pipeline of sievers in Oz.
04:39:36 <wli> > let coins = [2,5,10,20,50,100,200] :: [Int] ; step c = do { st <- get ; k <- foldr1 interleave $ map return [0 .. st `div` c] ; guard $ st >= k * c ; put $ st - k * c ; return (c, k) } in length . observeAll $ do { cs <- flip evalStateT 200 $ mapM step coins ; guard $ sum (map (uncurry (*)) cs) <= 200 ; return cs }
04:39:40 <lambdabot>   73682
04:39:42 <daf> dcoutts: I've since installed json to ~/.cabal by hand, so perhaps I should try a different package
04:40:05 <bremner> ImInYourMonad: image compression is probably simpler to understand
04:40:06 <mk15> Im learning the following code but I cant figure out what the $ means. Google has failed me :S
04:40:07 <mk15> onClicked button $ do
04:40:17 <mauke> @src ($)
04:40:17 <lambdabot> f $ x = f x
04:40:36 <bremner> mk15: it's just notation for parentheses
04:40:38 <Heffalump> you need to read whatever follows the do to get the whole picture
04:40:42 <dcoutts> daf: it sounds like it thinks base is not installed, or is broken
04:40:46 <NameAlreadyInUse> bremner: that's one of its uses
04:40:47 <yitz> > let f c s=[s,s+c..200] in length . foldl (>>=) [0] . map f $ [200,100,50,20,5,2]
04:40:48 <lambdabot>   14699
04:40:55 <pumpkin_> ImInYourMonad: the fft converts a time-domain function to its frequency domain... so if you have a single sine wave in your input, you'll get one peak in your output
04:41:05 <daf> dcoutts: ok, similar results with other packages
04:41:06 <Heffalump> what is the status of mtl versus transformers? Is one the "standard" and the other not?
04:41:15 <NameAlreadyInUse> bremner: but you can use it like any other operator
04:41:18 <NameAlreadyInUse> > map ($5) [pred, id, succ]
04:41:19 <lambdabot>   [4,5,6]
04:41:33 <mauke> > map (flip id 5) [pred, id, succ]
04:41:34 <lambdabot>   [4,5,6]
04:41:37 <bremner> NameAlreadyInUse: ahhh, cool, thanks
04:41:44 <daf> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2415#a2415
04:42:16 <wli> yitz: The idea is slick enough.
04:42:36 <yitz> wli: just the wrong answer :)
04:42:44 <mk15> ok so its just synactic sugar...thanks
04:43:01 <bremner> mk15: but see NameAlreadyInUse
04:43:04 <bremner> 's comments
04:43:14 <dcoutts> daf: there's something weird there, it's not doing the --dry bit, also use -v3 not -v -v -v
04:43:30 <dcoutts> daf: are you sure it's version 0.6.2 ?
04:44:18 <mauke> ./bootstrap.sh just told me "Sorry, something went wrong."
04:44:36 <mauke> but I have a cabal executable in ~/.cabal/bin, so what's up with that?
04:44:58 <Baughn> Well, under which circumstances does it tlel you that?
04:45:18 <daf> dcoutts: oh, bother. ~/bin/cabal is not a symlink to ~/.cabal/bin/cabal
04:45:19 <dcoutts> mauke: it reports that if it is not the case that [ -x "$CABAL_BIN/cabal" ]
04:45:28 <daf> dcoutts: mea culpa
04:45:33 <yitz> wli: oh, I forgot the 10 pence coin
04:45:35 <dcoutts> daf: ok, what version is it then?
04:45:36 <mauke> then what does it think $CABAL_BIN is?
04:45:40 <yitz> > let f c s=[s,s+c..200] in length . foldl (>>=) [0] . map f $ [200,100,50,20,10,5,2]
04:45:40 <daf> dcoutts: 0.4 :)
04:45:41 <lambdabot>   73682
04:45:46 <dcoutts> daf: ahhh, phew
04:45:54 <yitz> yep, that's it
04:45:54 <dcoutts> daf: wow, that is seriously old :-)
04:46:34 <dcoutts> mauke: CABAL_BIN="$PREFIX/bin"
04:46:37 <daf> dcoutts: it was working well enough until I upgraded ghc, and I couldn't quite remember how I bootstrapped it, so I left it alone :)
04:46:49 <wli> yitz: wow
04:46:54 <mauke> dcoutts: does it take PREFIX from the environment or set it itself?
04:47:10 <dcoutts> mauke:
04:47:10 <dcoutts> # install settings, you can override these by setting environment vars
04:47:10 <dcoutts> PREFIX=${PREFIX:-${HOME}/.cabal}
04:47:25 <yitz> pumpkin_: maybe not as beautiful as the rational series, but much simpler
04:47:28 <dcoutts> mauke: the -x test is also checking it is executable
04:47:33 <yitz> and as for DEBUG.EXE...
04:47:37 <mauke> well, that part doesn't work then
04:47:56 <mauke> because I have PREFIX=$HOME/usr in my environment, but there's no ~/usr/.cabal/
04:47:57 <pumpkin_> yitz: ?
04:48:12 <yitz> the project euler problem
04:48:14 <pumpkin_> oh, the 31 solution
04:48:16 <pumpkin_> yeah
04:48:19 <wli> pumpkin: yitz has an ultra-golfed solution to Project Euler #31
04:48:31 <pumpkin_> :o
04:48:34 <pumpkin_> where?
04:48:44 <dcoutts> mauke: you mean you set PREFIX explicitly?
04:48:47 <wli> pumpkin: /last yitz*foldl
04:48:56 <mauke> dcoutts: yes, in my bashrc
04:49:02 <pumpkin_> I did most of my euler problems in ghci, so I don't have many of my solutions lying around
04:49:16 <pumpkin_> oh wow
04:49:21 <pumpkin_> that is pretty extreme golfage
04:49:23 <pumpkin_> I'm impressed
04:49:28 <dcoutts> mauke: oh, perhaps if that's a standard env var then I should use some other one
04:49:39 <dcoutts> mauke: what else does PREFIX control
04:49:49 <dcoutts> mauke: and you're right, it's not being used consistently
04:49:50 <mauke> I don't think it's standard, I just use it in ./configure --prefix=$PREFIX
04:50:30 <pumpkin_> alright, bedtime
04:50:57 <dcoutts> mauke: oh ok, well the fix in the script is to change line 135 to use --prefix=${PREFIX}
04:51:24 <dcoutts> mauke: lemme know if that works out ok and I'll update the bootstrap for the next release
04:51:33 <mauke> I actually like how it works now :-)
04:51:55 <mauke> .cabal should be in $HOME, not some other directory
04:52:16 <ski> @type observeAll
04:52:17 <lambdabot> forall a. Logic a -> [a]
04:52:36 <mauke> oh wait, you mean removing .cabal too
04:53:12 <dcoutts> mauke: yes, the default prefix is ~/.cabal but you could use some other
04:53:37 <dcoutts> mauke: currently that would not affect where cabal puts its other stuff that it installs
04:54:00 <dcoutts> mauke: it'd just install the packages needed for bootstrapping cabal-install under $PREFIX
04:54:03 <mauke> ok, I'm going to try this
04:55:38 <mauke> that seems to have worked
04:55:42 <dcoutts> ok
05:06:46 <mauke> I just got an internal compiler error while trying to build SHA
05:06:58 <mauke> RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
05:07:04 <dcoutts> yep, try it
05:07:28 <dcoutts> SHA is more or less the only Haskell code around that generates and significant register pressure
05:07:33 <dcoutts> and/any
05:07:39 <mauke> I have to wait for the other packages first :-)
05:10:38 <mauke> is it safe to run multiple instances of 'cabal' in parallel?
05:11:09 <dcoutts> mauke: not if they are installing to the same prefix and package db
05:11:19 <mauke> :-(
05:11:38 <dcoutts> eg they might decide they need to install the same deps
05:11:47 <dcoutts> and installing things is not atomic
05:12:17 <dcoutts> but if they're separate prefixes then yes it works fine, if you're using the very latest version of cabal-install
05:12:32 <dcoutts> I've built most of hackage in parallel this way
05:13:05 <mauke> btw, do you know what Data.Encoding.JISX0208 is doing that makes it take an eternity to compile?
05:13:16 <dcoutts> lots of static data probably
05:13:42 <mmorrow> dcoutts: hmm, that'd be pretty cool if installation was atomic
05:14:03 <dcoutts> mmorrow: with abi-slotted packages it is
05:14:15 <dcoutts> or at least could be
05:14:20 <mmorrow> hmm
05:14:27 <dcoutts> like nix
05:15:53 <McManiaC> hi
05:16:28 <McManiaC> where are haskell modules normally located?
05:16:49 <mauke> on hackage
05:17:02 <McManiaC> filepath?
05:17:50 <mauke> /usr/local/lib/ghc-6.8.3/lib/
05:18:22 <Deewiant> ~/.lib/ghc-6.10.1/
05:18:52 <mauke> ~/usr/local/lib
05:19:30 <tibbe> anyone here on windows? I need someone to check if the `network` library compiles after my changes. shouldn't take more than 10 mins
05:21:52 <Asztal^_^> I am
05:24:56 <tibbe> Asztal: would you have a few mins? I'll give you a new cabal package for the network package, you would only have to run cabal configure && cabal build
05:25:03 <ImInYourMonad> hmm but FFT.fft needs a list of Complex numbers, FFT.fft :: [C.Complex Double] -> [C.Complex Double]. how do I rep sin(x) as that?
05:25:14 <Asztal> tibbe: sure
05:25:55 <tibbe> Asztal: sec, let me upload it somewhere
05:26:21 <McManiaC> (=?) ::
05:26:21 <McManiaC>   (Eq a) => XMonad.Core.Query a -> a -> XMonad.Core.Query Bool
05:26:32 <McManiaC> how would you define (/=?) with that declaration?
05:26:44 <tibbe> Azstal: http://johantibell.com/network-2.2.1.tar.gz
05:26:56 <McManiaC> so that the final bool is the opposite of =?
05:26:57 <mauke> x /=? y = fmap not (x =? y)
05:27:35 <McManiaC> thx =)
05:27:56 <tibbe> Azstal: I hope I built it correctly
05:28:02 <tibbe> dcoutts: ping
05:28:09 <dcoutts> tibbe: pong
05:28:31 <tibbe> dcoutts: saw that you uploaded the last release of network, did you create the sdist as well?
05:28:47 <dcoutts> tibbe: I expect I did
05:29:36 <tibbe> dcoutts: it seems that I have to run cabal configure before doing the sdist or it'll complain about missing HsNetworkConfig.h, does that sound about right to you?
05:30:25 <dcoutts> tibbe: hmm, but HsNetworkConfig.h should not be included into the tarball right?
05:30:35 <tibbe> dcoutts: that's what I thought
05:30:39 <tibbe> dcoutts: so I'm confused
05:30:53 <dcoutts> ah, but that .h file does get installed
05:31:02 <dcoutts> but it's generated
05:31:05 <tibbe> dcoutts: ok
05:31:24 <tibbe> dcoutts: let me start from another direction, how would you prepare a release of network from the darcs repo?
05:31:38 <dcoutts> tibbe: so yes, it'll end up adding a generated one to the tarball but that doesn't actually cause any problems
05:31:49 <tibbe> dcoutts: ah ok
05:32:02 <tristes_tigres> I thought darcs id being phased out in favour of git ?
05:32:20 <ImInYourMonad> is it possible to program firefox to open up a new tab and do the search there when using the upper right corner search box? could I do soem javascript to do this?
05:32:23 <mauke> w.t.f.
05:32:24 <ImInYourMonad> wrong channel
05:32:39 <mauke> why does sqlite try to include a file called "sqlite3.6"?
05:32:44 <tibbe> tristes_tigres: GHC is switching, doesn't mean that every library author will
05:33:05 <tibbe> Azstal: is it working for you?
05:33:15 <dcoutts> mauke: it's a bug in the package I reported to the author
05:33:35 <mauke> dcoutts: is there an easy fix?
05:33:45 <Asztal> tibbe: I just got configure: WARNING: Unrecognized options: --with-hc
05:33:52 <Asztal> and then it stopped :(
05:33:56 <dcoutts> mauke: remove the "Includes:        sqlite3.6" line from the .cabal file
05:33:57 <tibbe> Azstal: I think that's fine, I get that too
05:34:17 <dcoutts> mauke: there are no actual include files in the package anyway
05:34:21 <tibbe> Azstal: configure: WARNING: Unrecognized options: --with-compiler is the last line of output for me but it still works
05:34:23 <mauke> hah
05:34:29 <mauke> dcoutts: well, that was easy. thanks :-)
05:34:49 <dcoutts> mauke: it might want to be Include-dirs:    includes
05:35:11 <tristes_tigres> wow, 600 users. someone keeps a graph of #haskell readership ?
05:35:13 <dcoutts> mauke: and incldues: sqlite3.h
05:35:50 <tibbe> tristes_tigres: I think dons does
05:36:05 <tristes_tigres> tibbe: online ?
05:36:09 <Asztal> the build doesn't work though: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2416
05:36:11 <tibbe> tristes_tigres: dunno
05:36:52 <mauke> /usr/home/mauke/usr/lib/sqlite-0.4.2/ghc-6.8.3/libHSsqlite-0.4.2.a(sqlite3.o)(.text+0x3f17): In function `findLockInfo': undefined reference to `pthread_create'
05:36:55 <mauke> oh joy
05:42:12 <tibbe> Asztal: thanks, that's the info I needed
05:42:30 <tibbe> Asztal: it's quite hard to test CPPed code when you're missing one of the platforms :/
05:42:50 <tibbe> Asztal: I'll fix those now
05:42:58 * tibbe really needs a windows machine to test on
05:43:01 <Heffalump> tibbe: I can provide VNC access to a Win2K machine if that'd help
05:43:11 <ivanm> tibbe: a virtual machine?
05:43:13 <Heffalump> (temporarily, though)
05:43:24 <ivanm> wine it?
05:43:29 <tibbe> Heffalump: that'll be nice, let me try to find a VNC client for mac os x first
05:43:42 <tibbe> ivanm: yes, I should work on getting that set up
05:43:52 <Heffalump> and you'll need to put ghc on it
05:44:09 <tibbe> Heffalump: right, give me a few mins to see how easy it would be to set up
05:44:50 <yitz> tibbe: Chicken of the VNC
05:45:10 <yitz> @go Chicken of the VNC
05:45:11 <tibbe> yitz: ok, downloading
05:45:12 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
05:45:19 <yitz> ach!
05:46:21 <mk15> regarding the $ operator....I was wondering what the following lines would look like without it
05:46:22 <mk15> c <- getContents
05:46:22 <mk15> putStr $ (unlines . myfilter filterfunc . lines) c
05:46:42 <BONUS> putStr ((unlines . myfilter filterfunc . lines) c)
05:47:42 <BONUS> also nice way to write that: putStr . unlines . myfilter filterfunc . lines $ c
05:48:25 <mk15> hmmm to me that seems way more readable, but i guess its because i come from an imperative language...
05:49:06 <yitz> mk15: I like what BONUS wrote last
05:50:09 <yitz> mk15: we used to write it this way, but now it's out of style: putStr $ unlines $ myfilter filterfunc $ lines $ c
05:52:06 <athos> is it forbidden to use let in a do block when using {...;...} layout?
05:52:17 <BONUS> nope
05:52:31 <athos> > flip runState 12345 $ do {a <- return 5; put a}
05:52:32 <mk15> interesting thanks
05:52:32 <lambdabot>   ((),5)
05:52:38 <athos> > flip runState 12345 $ do {let a=5; put a}
05:52:39 <lambdabot>   <no location info>: parse error on input `}'
05:52:54 <BONUS> > do {let a = 3; b <- [1,2,3]; c <- [3,4,5]; return (b,c*a)}
05:52:55 <lambdabot>   <no location info>: parse error on input `<-'
05:53:31 <athos> hmpf
05:53:34 <Asztal_> > do {let {a = 3}; b <- [1,2,3]; c <- [3,4,5]; return (b,c*a)}
05:53:35 <lambdabot>   [(1,9),(1,12),(1,15),(2,9),(2,12),(2,15),(3,9),(3,12),(3,15)]
05:53:43 <BONUS> oh snap, hmm
05:53:45 <athos> ah!
05:54:02 <tristes_tigres> http://www.reddit.com/r/haskell/comments/83zz7/why_does_alcohol_make_haskell_programming_more/
05:54:09 <athos> > flip runState 12345 $ do {let {a=5;b=3}; put a}
05:54:10 <lambdabot>   ((),5)
05:54:25 <athos> :)
05:56:37 <tibbe> Heffalump: just found an old XP Pro MSDN AA cd lying around, I'm gonna try that
05:57:05 <tibbe> Heffalump: I might still take you up on the offer if that doesn't work
06:01:15 <pax> hello, is there an easy way to convert IOString to String ?
06:01:59 <ivanm> @hoogle IOString
06:01:59 <lambdabot> No results found
06:02:08 <ImInYourMonad> isnt e in haskell?
06:02:10 <athos> :>
06:02:12 <ivanm> pax: you mean "IO String" ?
06:02:19 <ImInYourMonad> exp
06:02:20 <ivanm> ImInYourMonad: like this:
06:02:20 <pax> yes
06:02:22 <ivanm> > exp(1)
06:02:23 <lambdabot>   2.718281828459045
06:02:31 <ivanm> same as in most languages, there's no actual "e" value
06:02:36 <ImInYourMonad> ok
06:02:38 <athos> ivanm: yesterday was pi day
06:02:43 <athos> err, i mean ImInYourMonad
06:02:54 <athos> but it's not like today is e day
06:02:55 <Zao> athos: 3.142009 is a horrible approximation.
06:02:57 <athos> so:
06:02:59 <athos> @where e
06:02:59 <lambdabot> I know nothing about e.
06:03:06 <pax> ivanm: yes IO String
06:03:08 <athos> :)
06:03:29 <Zao> pax: IO String is an action that run will yield a String.
06:03:30 <athos> Zao: that's because some people tend to marry at certain times
06:03:32 <ivanm> pax: you can extract the String out inside the IO monad, yes
06:03:36 <athos> Zao: like 1:59pm ;)
06:03:46 <ivanm> same as for any monad
06:06:16 <pejo> pax, call your pure function from inside the do-block with the string as parameter. You don't want to remove the IO in IO String.
06:07:00 <pax> my pure function uses String as input
06:07:23 <tristes_tigres> no ghc for .net ?
06:07:34 <LeoD> iostr >>= purefun
06:07:48 <bremner> tristes_tigres: large enough disks do not exist yet
06:08:11 <tristes_tigres> bremner: how so ?
06:08:15 <bremner> :-)
06:09:49 <pejo> tristes_tigres, there's some .Net-interop layer by Sigbjorn Finne available.
06:13:31 <ImInYourMonad> if I want to do: zipWith f a b; and I have c=(a,b), how would I? zipWith f $ uncurry  c doesnt do that
06:14:07 <BONUS> umm a and b are lists?
06:14:13 <ImInYourMonad> yes
06:14:17 <BONUS> or is c like [(a,b),(a,b)]
06:14:29 <BONUS> uncurry (zipWith f) c
06:15:01 <BONUS> > uncurry (zipWith (+)) ([1,2,3,4],[3,4,5,6])
06:15:02 <lambdabot>   [4,6,8,10]
06:16:19 <ivanm> anyone know if it's possible to access the ghc-pkg stuff as a library?
06:17:07 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2418#a2418 , so what did i to there <-
06:17:22 <ImInYourMonad> i do fft on a function and get out some approximated value it seems
06:17:45 <ImInYourMonad> its from running test
06:17:51 <mopped> @src uncurry
06:17:51 <lambdabot> uncurry f p = f (fst p) (snd p)
06:17:54 <BONUS> hi vixey
06:18:04 <vixey> hi
06:32:34 <ImInYourMonad> I conclude that Clojure is ugly and Haskell pwns it.
06:33:11 <ImInYourMonad> @remember SPJ will be a legend after his death
06:33:11 <lambdabot> Done.
06:33:17 <ImInYourMonad> @SPJ
06:33:17 <lambdabot> Unknown command, try @list
06:33:25 <ImInYourMonad> @list SPJ
06:33:25 <lambdabot> No module "SPJ" loaded
06:33:38 <ImInYourMonad> @quote SPJ
06:33:38 <lambdabot> SPJ says: will be a legend after his death
06:35:04 <ImInYourMonad> @remember commone_sense_says : SPJ will be a legend after his death
06:35:04 <ImInYourMonad> @quite common_sense_says
06:35:04 <ImInYourMonad> @quote common_sense_says
06:35:04 <ImInYourMonad> > let areyouthere = 3 in 2 + areyouthere
06:35:04 <lambdabot> It is forever etched in my memory.
06:35:04 <lambdabot> No quotes match. You speak an infinite deal of nothing
06:35:04 <lambdabot> Maybe you meant: quit quote
06:35:08 <lambdabot>   5
06:35:13 <ImInYourMonad> @quote common_sense_says
06:35:13 <lambdabot> No quotes match. You untyped fool!
06:35:20 <ImInYourMonad> @quote commone_sense_says
06:35:20 <lambdabot> commone_sense_says says: : SPJ will be a legend after his death
06:35:31 <vixey> http://rafb.net/p/FyenZX81.html
06:36:20 <mauke> ImInYourMonad--
06:36:39 <ImInYourMonad> @remember legends the immortal heroes of Haskell, the simons, dons, quicksilver, Cale
06:36:39 <lambdabot> Okay.
06:36:45 <ImInYourMonad> @quote legends
06:36:46 <lambdabot> legends says: the immortal heroes of Haskell, the simons, dons, quicksilver, Cale
06:37:29 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2418#a2418 <- what did i do there, it seems to be some approximated value
06:37:57 <ImInYourMonad> or just the first one
06:40:02 <athos> , [$ty|if'|]
06:40:09 <lunabot>  luna: Exception when trying to run compile-time code:
06:41:51 <koeien> why does ghci eat my unicode characters?
06:42:06 <koeien> i'd like to use unicode symbols for  set difference and intersection
06:43:08 <mauke> is it ghc-6.10.1?
06:43:13 <koeien> mauke: yes.
06:43:21 <mauke> did you build it without readline support?
06:43:33 <Saizan> install ghci-haskeline
06:43:44 <koeien> mauke: i used the binary build. isn't that built with libedit ?
06:43:52 <mauke> yes
06:43:56 <mauke> which is the problem
06:44:15 <koeien> Saizan: this is readline-in-Haskell ?
06:44:22 <Martijn> :t flip flip flip
06:44:24 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
06:44:25 <Martijn> :t flip flip flip flip
06:44:26 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
06:44:42 <Saizan> koeien: yup
06:44:57 <koeien> Saizan, mauke: thanks, i'll try it :)
06:44:58 <Saizan> ?hackage ghci-haskeline
06:44:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghci-haskeline
06:48:29 <koeien> Saizan: this worked perfectly. thanks
06:49:06 <Martijn> :r
06:49:10 <Martijn> doh
06:49:11 <McManiaC> hi, im using the Graphics.X11.ExtraTypes.XF86 module
06:49:34 <McManiaC> but it doesnt recognize my media keys... any ideas?
06:52:04 <McManiaC> or can u define your own keysym? i know only the hexadecimal of the key
06:57:14 * shapr boings quietly
06:57:14 <mauke> haddock: internal Haddock or GHC error: Maybe.fromJust: Nothing
06:57:20 <mauke> haddock--
06:57:41 <yitz> @slap haddock
06:57:41 * lambdabot will count to five...
06:57:53 <mauke> encoding--
07:00:26 <chessguy> > concat . intercalate "... " . map show $ [1..5]
07:00:27 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
07:00:51 <chessguy> @type intercalate
07:00:52 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:01:15 <vixey> > intercalate "... " . map show $ [1..5]
07:01:16 <lambdabot>   "1... 2... 3... 4... 5"
07:02:13 <chessguy> that seems odd
07:03:49 <chessguy> @hoogle [a] -> [[a]] -> [[a]]
07:03:49 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:03:49 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
07:03:49 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
07:04:02 <vixey> :t intersperse
07:04:03 <lambdabot> forall a. a -> [a] -> [a]
07:04:13 <chessguy> aha
07:04:16 <vixey> you're getting confused with String vs [Char]
07:04:46 <chessguy> not really
07:05:17 <chessguy> i just wasn't looking for a general enough type
07:05:54 <chessguy> after all:
07:06:11 <chessguy> @type intersperse :: [a] -> [[a]] -> [[a]]
07:06:12 <lambdabot> forall a. [a] -> [[a]] -> [[a]]
07:08:48 <chessguy> @src intercalate
07:08:48 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
07:08:56 <chessguy> as i suspected
07:09:02 <chessguy> @src intersperse
07:09:02 <lambdabot> intersperse _   []     = []
07:09:02 <lambdabot> intersperse _   [x]    = [x]
07:09:02 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:12:41 <yitz> http://research.microsoft.com/ is down?
07:13:04 <vixey> yitz: No
07:13:27 <yitz> vixey: it's responding for you?
07:16:46 <Mr_Giraffe> @type intersperse
07:16:48 <lambdabot> forall a. a -> [a] -> [a]
07:17:37 <yitz> > intersperse ',' . map show $ [1..10]
07:17:39 <lambdabot>   Couldn't match expected type `Char' against inferred type `String'
07:17:59 <yitz> > intersperse "," . map show $ [1..10]
07:18:01 <lambdabot>   ["1",",","2",",","3",",","4",",","5",",","6",",","7",",","8",",","9",",","1...
07:18:17 <yitz> > intercalate "," . map show $ [1..10]
07:18:18 <lambdabot>   "1,2,3,4,5,6,7,8,9,10"
07:18:40 <Mr_Giraffe> oh, intercalate just runs concat over the list
07:18:53 <jlouis> yes!
07:19:12 <Mr_Giraffe> man, i miss my whiteboard :(
07:19:27 <vixey> @go virtual whiteboard
07:19:28 <lambdabot> http://www.virtual-whiteboard.co.uk/
07:19:45 <Mr_Giraffe> vixey: my tablet drivers aren't compiled for this kernel either
07:34:21 <blbrown> is there a home page for the haskell-llvm project.  Is it still being maintained
07:38:11 <mmorrow> blbrown: i think it's pretty new. check on its hackage page for a link
07:41:28 <NewbieOnMacOS> Hi. I am trying to install GHC on MacOS 10.5.6. I have XCode installed. When I start GHC-6.10.1-i386.pkg "Install" button is grayed out, only "Go Back" is available. There is no errors in installer log. Any idea what i should do ?
07:42:26 <pejo> NewbieOnMacOS, do you have an intel-mac, or ppc?
07:43:34 <NewbieOnMacOS> Intel - Macbook Air
07:47:14 <mmorrow> ImInYourMonad: hey. i just upload a (slightly improved) pure-fft http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pure-fft-0.2.0
07:48:27 <mmorrow> ImInYourMonad: also, here's a 4-liner in ghci to read in a .wav, compute its frequency spectrum, and graph  it
07:48:34 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=73
07:49:20 <cognominal> is there a way to display the current execution stack? is there such thing in haskell anyway?
07:49:32 <vixey> no
07:49:49 <cognominal> vixey, can you elaborate?
07:52:41 <Saizan> you won't get a standard call stack because of how laziness is implemented
07:53:03 <NewbieOnMacOS> pejo : i noticed that libgmp.3.dylib is required by binary installer, but no such library is present under /Developer. Is it also required for .pkg installer ? Maybe this is the problem ?
07:53:11 <Saizan> however you can trigger the profiler to get a similar result
07:53:20 <Saizan> or use the ghci debugger
07:53:28 <NewbieOnMacOS> I recently upgraded to latest XCode from apple (3.1.2)
07:53:29 <Saizan> s/trigger/trick/
07:53:35 <mk15> NewbieOnMacOS, im not too familiar with the mac, but perhaps you can try executing the package from a terminal window and checking to see if there is any error outputted back into the terminal
07:54:02 <cognominal> thx Saizan
07:54:06 <NewbieOnMacOS> no, there is no errors, i already did something similiar
07:55:03 <pejo> NewbieOnMacOS, I'm not sure what the story is for the binary packages, I use the one from macports myself. But gmp isn't included in your base operating system I think.
07:55:06 <cognominal> I try to picture how thunks affect the execution model but fail so far.
07:55:12 <vixey> don't think about it
07:56:35 <jajamana1> I am trying to use cabal to upgrade QuickCheck from 1.2 to 2.1 but cabal just rebuilds 1.2. Any ideas?
07:58:20 <Saizan_> jajamana1: cabal install QuickCheck-2.1
07:59:11 <jajamana1> Saizan: Great, that worked, thank You!
08:02:14 <dcoutts> jajamana: it's because the default version is 1.x, more generally you can use: cabal install 'quickcheck >= 2'
08:10:45 <eu-prleu-peupeu> hey ppl
08:10:50 <eu-prleu-peupeu> http://www.drugtext.org/library/articles/pordecrim.htm  check it out :D
08:10:56 <eu-prleu-peupeu> portugal is the best country in the world!
08:11:15 <eu-prleu-peupeu> http://www.salon.com/opinion/greenwald/2009/03/14/portugal/index.html
08:11:54 <EvilTerran> that's not really on-topic...
08:13:07 <bjorkintosh> he's from .pt
08:13:39 <Alpounet> really ?
08:13:41 <Alpounet> :-p
08:13:49 <aeolist> there is a portugal invasion in haskell channels in the past few days
08:14:08 <aeolist> somebody screaming portuguese in #haskell yesterday
08:14:19 <Alpounet> there may have been some conferences about Haskell in Portugal
08:14:29 <eu-prleu-peupeu> not that im aware
08:14:35 <eu-prleu-peupeu> the guy from yesterday was brazilian
08:14:44 <zachk1> sure it isnt brazil
08:15:34 <eu-prleu-peupeu> i intend to become an haskell evangelist here in portugal :)
08:16:03 <jotik> why do you like haskell=
08:16:33 <eu-prleu-peupeu> because it is very elegant, and allows me to think more about the problem and less about implementation details
08:16:54 <aeolist> he is yet to know the drain of energy programming in haskell entails
08:17:11 <zachk1> drain of energy wtf
08:17:12 <jotik> eu-prleu-peupeu: hmm... i've heard that sentence somewhere.
08:17:17 <eu-prleu-peupeu> in OO im always thinking about factories and stupid design patterns... that doesn't happen in haskell
08:17:42 <zachk1> eu-prleu-peupeu: you should get programming in haskell unless you are already a master
08:18:42 <eu-prleu-peupeu> practice makes perfect
08:19:02 <mmorrow> @tell ImInYourMonad here's a sample of using pure-fft http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1902#a1902
08:19:02 <lambdabot> Consider it noted.
08:20:56 <zachk1> mmorrow: that is wonderful but how do i play a wav :D
08:21:19 <mmorrow> actually, that program will work on any format that sox'll take as input
08:21:35 <mmorrow> zachk1: um, like any audio player :)
08:21:50 <mmorrow> $ ./wavspec nightlife_baby.ogg
08:21:54 <mmorrow> woohoo
08:22:17 <vixey> I think he meant from haskell :p
08:22:37 <mmorrow> i have no idea :)
08:22:50 <mmorrow> but that'll show you the frequency spectrum!!
08:22:59 <mmorrow> [m@ganon fft-wav]$ sox --help | grep "SUPPORTED FILE"
08:22:59 <mmorrow> SUPPORTED FILE FORMATS: 8svx aif aifc aiff aiffc al alsa au auto avr cdda cdr cvs cvsd dat dvms fssd gsm hcom ima ircam la lu maud nist nul null ogg ossdsp prc raw s3 sb sf sl smp snd sndt sou sph sw txw u3 u4 ub ul uw vms voc vorbis vox wav wve xa
08:23:06 <Philonous> Is there a walkthrough for the ghc typechecker source code?
08:25:20 <mmorrow> zachk1: if you figure out what /dev/dsp is expecting, you can use sox to convert it to that, then just cat foo.wav.soxified > /dev/dsp
08:26:06 <mmorrow> e.g.,  "-L -u -4" == little-endian, unsigned, 4byte samples
08:27:04 <mmorrow> i think /dev/dsp might be expecting a non-time-domain datastream too, so you might even be able to use fft to play the wav...
08:27:11 <mmorrow> which would be really cool
08:28:59 <skorpan> how come there is an instance of Monoid for Map?  we can't figure out how that works, because union can't be associative?
08:29:07 <Philonous> And would the following make sense: Suppose you could annotate types with predicates and functions with requirements, so that types match iff the underlying types match and the argument type has at least the predicates the functions requires
08:29:26 <conal> skorpan: can't be associative?
08:29:53 <skorpan> conal: well, we can't figure out how it can be, since it prefers the key-value pairs in the first argument
08:30:11 <Saizan> skorpan: associative /= commutative
08:30:21 <skorpan> i know
08:30:26 <zachk1> mmorow: and what if im not on linux. is there a haskell library for playing wav's like opengl doesw for graphics
08:30:42 <conal> skorpan: how might left-preference thwart associativity?
08:30:58 <Saizan> skorpan: do you have an example where associativity fails to hold?
08:31:12 <conal> skorpan: do you know about First and Last in Data.Monoid?
08:31:13 <skorpan> consider: x `union` (y `union` z) vs. (x `union` y) `union` z
08:31:22 <skorpan> no, conal, i'm trying to figure all of this out
08:31:23 <conal> k
08:31:45 <mmorrow> zachk1: ooh, that might be tough. iirc sw17ch wrote an ffi binding to libsndfile that works on windows too
08:31:54 <conal> skorpan: coincidentally, i discuss this very example in http://conal.net/papers/type-class-morphisms
08:32:17 <conal> skorpan: but please continue with your reasoning ("consider: ...")
08:32:37 <zachk1> mmorrow: so there is no nice "out of the box" solution?
08:32:44 <mmorrow> err, maybe it's not called libsndfile
08:32:52 <mmorrow> zachk1: what are you looking for?
08:33:19 <mmorrow> something that plays a .wav file written in haskell and on windows?
08:33:30 <zachk1> mmorrow: im on windows and im looking to just play wav files and maybe do a bit of wave file editing
08:33:42 <Saizan> x = [(1,a)]; y = [(1,b)]; z = [(1,c)]; x `union` (y `union` z) == x `union` [(1,b)] == [(1,a)] == [(1,a)] `union` z == (x `union` y) `union` z
08:34:05 <mmorrow> zachk1: ah, cool. there's an open source program called "audacity" that i've used before. it's nice.
08:34:30 <vixey> Philonous: that would probably interact in a very confusing and unpredictable way with other type system extensions
08:34:33 <zachk1> mmorrow: i want to roll my own :D
08:34:35 <mmorrow> zachk1: http://audacity.sourceforge.net/
08:34:41 <conal> skorpan: "If you can't solve a problem, then there's an easier problem you can solve: find it." - George Polya
08:35:31 <conal> skorpan: to understand the Map monoid, you might try simplifying it.  Hint: a Map is a composition of two ideas.
08:35:46 <pastah> conal: well, consider that you have this (key,value) are elements in respective sturture
08:36:07 <ImInYourMonad> C:\gnuplot\bin>echo plot sin(x) |pgnuplot -persist; works from the com prompt but: t = "C:/gnuplot/bin/echo plot sin(x) |pgnuplot -persist"
08:36:07 <ImInYourMonad> plot = do
08:36:07 <ImInYourMonad>   runCommand t ; *Plotting> 'C:' is not recognized as an internal or external command,
08:36:07 <ImInYourMonad> o
08:36:08 <lambdabot> ImInYourMonad: You have 1 new message. '/msg lambdabot @messages' to read it.
08:36:10 <pastah> so (k,v) is a map wich contains for key k value v
08:36:29 <mmorrow> zachk1: cool! you can use an fft (among other integral transforms) to filter/manipulate the audio
08:36:36 <pastah> oh
08:36:39 <pastah> shit
08:36:40 <skorpan> conal: i think we figured it out :)
08:36:45 <pastah> well, UNION is assiative
08:36:56 * pastah and skorpan is < 1 meter from each other
08:37:18 <pastah> but not if you would do it by inserts, it wouldn't be
08:37:30 <bremner> too much information!
08:37:35 <mmorrow> zachk1: just like you can blur an image in photoshop, you can do the analog to the audio
08:37:48 <mmorrow> (analog := analogous)
08:39:02 <conal> skorpan, pastah: you can always answer this sort of question (what does the Foo instance mean for the type Bar) by asking the the same question about the *meaning* of a type.
08:39:53 <conal> which is what http://conal.net/papers/type-class-morphisms is about.
08:39:55 * Saizan can't find a graph viewer that can handle the graphs he produces
08:40:21 <mmorrow> Saizan: i would kill for a nice graph viewer
08:41:13 <pao> Saizan: which kind of graphs? does graphviz apply?
08:41:52 <mmorrow> graphviz is friggin sweet. but not so much when you have thousand and thousands of nodes, and you want to zoom around them in 3D or something
08:41:53 <Saizan> i've them in .dot format but i can't find anything that renders them properly
08:42:11 <appletizer> isn't .dot format graphviz?
08:42:15 <Saizan> yes
08:42:39 <mmorrow> graphviz can't handle graphs above a certain size
08:43:44 <Philonous> vixey: I can already do that with newtypes, but for n predicates I need 2^n newtype declarations (and even more class instances).
08:43:52 <mmorrow> Saizan: piping them through "tred" makes them a lot less cluttered, which is nice in some situations
08:43:57 <conal> mmorrow: what happens above that size?
08:44:09 <mmorrow> conal: it just never finishes :)
08:44:16 <pao> Saizan: .... http://zvtm.sourceforge.net/zgrviewer/applet/ ... never tried though
08:44:22 <mmorrow> well, i usually kill it after about 30 minutes
08:44:23 <conal> mmorrow: wow.  bug?
08:44:38 <mmorrow> conal: i'm not sure, you think?
08:44:51 <pao> mmorrow: it never happened to me... maybe becouse I've got small graphs
08:44:54 <mmorrow> like, what's it doing? computing layout?
08:45:23 <mmorrow> i think it'd finish if i gave it long enough..
08:45:48 <Saizan> mmorrow: like cat graph.dot | tred | dot -Tsvg -o ..?
08:45:52 <conal> mmorrow: unless it's crippleware.  is there a commercial version?
08:45:54 <mmorrow> pao: like, try to render the dependency graph of hackage with dot (i killed it after 30 minutes)
08:46:01 <cognominal> I have done a .dot file of the Perl grammar and the rendering is unreadable
08:46:09 <mmorrow> Saizan: exactly
08:46:24 <mmorrow> conal: i don't think so
08:46:26 <cognominal> and the Perl  grammar is a simple one, that's the lexing that is complex in Perl
08:46:50 <ImInYourMonad> runCommand "C:/gnuplot/bin/echo plot sin(x) |pgnuplot -persist" ; why doesnt that work?
08:46:53 <conal> mmorrow: then probably just a bug.
08:47:00 <ImInYourMonad> *Plotting> 'C:' is not recognized as an internal or external command,
08:47:05 <pao> mmorrow: did you use neato or dot?
08:47:06 <mmorrow> conal: that's nice to hear
08:47:15 <mmorrow> pao: i used circo actually
08:47:22 <Saizan> mmorrow: it removes all my edges! :)
08:47:29 <mmorrow> Saizan: heh
08:47:37 <mmorrow> transitive reduction
08:48:19 <mmorrow> pao: i think i tried dot too though
08:48:58 <pao> mmorrow: dot and neato should be more "stable"...
08:49:13 <mmorrow> pao: true
08:49:31 <mmorrow> i'll have to try again
08:52:01 <Eiler> whats a good haskell editor in windows?
08:52:25 <conal> Eiler: emacs, for one.
08:52:35 <EvilTerran> i tend to use SciTE when on windows
08:52:56 <Eiler> dont like emacs
08:53:06 <conal> i haven't tried yi yet.  looks like it's getting pretty rad.
08:53:36 <Sekaino> conal, last time I tried to build yi (long time ago), it didn't build with newer ghc.  What's its current development status?
08:53:37 <Saizan_> (http://code.haskell.org/~Saizan/000300 <- this one of the graphs, if you can find a way to render it nicely :)
08:53:42 <Eiler> does yi exist for win?
08:53:47 <Eelis> Eiler: i'm so delighted to see you here! i can only hope geordi played a small part in that ;)
08:53:52 <ImInYourMonad> Eiler: i use emacs so i can use ghci, vim is also good.
08:53:55 <conal> Sekaino: there's a very recent release announcement.
08:54:03 <conal> @hackage yi
08:54:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yi
08:54:28 <Sekaino> conal: Excellent, I may have to give it a shot again soon.
08:55:01 <conal> Sekaino: cool.  good luck.
08:56:02 <Sekaino> Eiler, I'm a gvim advocate, which is also in Windows.
08:56:53 <Eiler> Eelis: heh, well not really i was here several years ago already, before i even saw you here. But i hardly get past hello world before i quit every time i do some haskell :)
08:57:07 <cgizmo> hello
08:57:09 <Heffalump> conal: re ghci and includes, I must have been using -package foo when it worked for me
08:57:23 <Heffalump> (as per the emails on whichever list you asked about it on)
08:57:25 <Eiler> mm, vim is okay, i'll take a look at scite also. Getting tired to use notepad
08:57:31 <conal> Heffalump: tried that a few minutes ago.  works great. :)
08:57:54 <conal> Heffalump: so now i've put -package applicative-numbers into my .ghci file
08:58:13 <conal> i.e., ":set -package applicative-numbers"
08:58:17 <Heffalump> ah, cunning
08:58:19 <cgizmo> Do you know a way to access an element in a list with an O(1) complexity, and not with the O(N) complexity the (!!) operator uses?
08:58:31 <Heffalump> cgizmo: if you want that, use an array
08:59:00 <cgizmo> Heffalump: i didn't know you could use arrays in a pure functionnal language
08:59:02 <edwardk> cgizmo: replace it with an array? =)
08:59:13 <Heffalump> cgizmo: you can, though there are various trade-offs
08:59:22 <Heffalump> for example you can make an immutable array and use that from pure code
08:59:25 <edwardk> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array.html
08:59:30 <Heffalump> or you can have mutable arrays that you use from IO/ST
08:59:43 <cgizmo> okay, thanks a lot
09:00:04 <edwardk> > array (1,3) [(1,1),(2,5),(3,6)] ! 2
09:00:06 <lambdabot>   5
09:00:12 <cgizmo> so if I wanted to make a Matrix data type, could I make a 2D array ?
09:00:16 <conal> cgizmo: Data.Seq will get you much better than O(N), but not quite O(1), and it's functional.
09:00:22 <Heffalump> just index a normal array with tuples
09:00:43 <athos> > fst (1,2,3)
09:00:44 <conal> make that Data.Sequence
09:00:44 <lambdabot>   Couldn't match expected type `(a, b)'
09:00:46 <edwardk> yeah any 'Ix' data type can be used for the range
09:01:06 <cgizmo> but a tupple can only have a fixed size, right ?
09:01:10 <edwardk> which includes pairs of Num instances. so a (Int,Int) is a valid index
09:01:17 <cgizmo> so that would make a weird matrix
09:01:39 <mauke> cgizmo: huh? do you want 5D matrixes or something?
09:01:43 <edwardk> you can have an array that runs from array ((0,0),(256,256))
09:01:47 <EvilTerran> > let a = listArray ((0,0),(2,2)) [1..9] in [a!(0,0), a!(0,1), a!(1,1), a!(2,2)]
09:01:48 <Heffalump> the tuples define the coordinates in the matrix
09:01:48 <lambdabot>   [1,2,5,9]
09:01:49 <conal> @hackage containers
09:01:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/containers
09:01:53 <conal> cgizmo: ^^
09:02:06 <athos> how to work with stuff like (a,b,c)?
09:02:10 <cgizmo> mauke: well, imagine I wan't to store a map in a matrix
09:02:11 <edwardk> or a 6 dimensional matrix of size ((0,0,0,0,0,0),(1,2,3,4,5,6) etc
09:02:16 <athos> i know it's a rather dumb question but
09:02:17 <athos> i wondered
09:02:21 <BONUS> athos: very carefully
09:02:23 <BONUS> just kididng
09:02:26 <BONUS> pattern match on it
09:02:28 <EvilTerran> cgizmo, that's what an array indexed by tuples looks like in use
09:02:38 <BONUS> let f (a, b, c) = c in f (1,2,3)
09:02:41 <BONUS> > let f (a, b, c) = c in f (1,2,3)
09:02:43 <lambdabot>   3
09:03:03 <BONUS> > (\(a,b,c,d) -> b+c/d) (1,2,3,4)
09:03:04 <lambdabot>   2.75
09:03:18 <edwardk> > array ('a','z') (zip ['a',..] [1..]) ! 'm'
09:03:19 <lambdabot>   <no location info>: parse error on input `..'
09:03:32 <edwardk> > array ('a','z') (zip ['a'..] [1..]) ! 'm'
09:03:32 <skorpan> > array ('a','z') (zip ['a'..] [1..]) ! 'm'
09:03:33 <cgizmo> EvilTerran: thanks, I'll check this out
09:03:34 <lambdabot>   * Exception: Error in array index
09:03:34 <lambdabot>   * Exception: Error in array index
09:03:46 <jajamana1> I am trying to use QuickCheck 2.1 with Monadic IO using System, but ghc-6.8.2 it is unable to load the package random-1.0.0.0 (link error about unknown symbol). Loading System and QuickCheck in ghci causes random-1.0.0.1 to be loaded successfully, can anyone explain why two difference versions of random would be used?
09:03:50 <edwardk> strange
09:03:56 <dolio> > listArray ('a','z') [1..] ! 'm'
09:03:57 <lambdabot>   13
09:04:10 <edwardk> ah i went too long
09:04:29 <edwardk> > array ('a','z') (zip ['a'..'z'] [1..]) ! 'm'
09:04:30 <lambdabot>   13
09:04:58 <edwardk> cgizmo: unlike most languages haskell arrays can be indexed by lots of things
09:05:06 <drhodes> (.*) = flip (*.)  --this just made my day
09:05:21 <conal> drhodes: yeah.  nice one!
09:05:37 <cgizmo> edwardk: the (!) operator is used to access an element of an array i'm guessing
09:05:53 <edwardk> cgizmo: yeah, array and listArray build the array from a list with a given set of bounds
09:06:33 <cgizmo> edwardk: then you have an immutable array that has a constant access time, right ?
09:06:38 <edwardk> yep
09:06:41 <cgizmo> okay
09:06:48 <cgizmo> i'll check this out then
09:06:49 <edwardk> there are also arrays that are mutable but can only be used in IO or ST, etc.
09:06:59 <cgizmo> okay
09:07:18 <edwardk> and ways to 'freeze' a mutable IO or ST based array to one that you can use in a pure way
09:07:21 <cgizmo> so i can build a list, then "convert" it to an array, then, use the array for fast access
09:07:57 <edwardk> freezing can be used when you can only come up with an imperative process to build the array
09:08:01 <edwardk> yeah
09:08:08 <edwardk> @type listArray
09:08:09 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
09:08:41 <cgizmo> earlier you said "unlike most languages haskell arrays can be indexed by lots of things"
09:08:56 <cgizmo> what do you mean by that ?
09:09:52 <edwardk> cgizmo: did you see above where i used an array indexed by chars?
09:10:15 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ix.html
09:10:15 <cgizmo> oh, sorry, missed that part
09:10:20 <cgizmo> just saw it now, thanks
09:10:33 <edwardk> anything that is a member of the Ix typeclass can be your index into the array
09:10:53 <EvilTerran> ?instances Ix
09:10:53 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
09:10:59 <EvilTerran> ?instances-importing Data.Array Ix
09:11:00 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
09:11:26 <tromp_> IX must have large overlap with class Enum
09:12:01 <tromp_> what's in one and not in the other?
09:12:02 <edwardk> tromp yeah, but it adds the requirement that you can generate a range as a list, check for the index of a value in a range and know the size of a range
09:12:15 <edwardk> > range ('a','z')
09:12:16 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
09:12:16 <cgizmo> and the indexation process is automatic, or do you have to specify that you wan't 'a' to point to the first element, 'b' to the second, etc, etc ?
09:12:26 <edwardk> > index ('a','z') 'm'
09:12:27 <lambdabot>   12
09:12:37 <edwardk> > inRange ('a','m') 'z'
09:12:38 <lambdabot>   False
09:12:43 <edwardk> > rangeSize ('a','z')
09:12:44 <lambdabot>   26
09:12:48 <tromp_> ic
09:12:55 <edwardk> and that its ordered
09:13:13 <cgizmo> hum
09:13:15 <cgizmo> thanks
09:13:15 <Petrosian`> Also, tuples aren't instance sof Enum
09:14:32 <edwardk> cgizmo: the Ix instance makes the indexing process automatic
09:15:17 <edwardk> cgizmo: you can think of it as building an underlying array based on the rangeSize of the range you give it, and looking up where to you put values using the index of the value according to the range you gave it
09:16:17 <cgizmo> so arrays in haskell pretty much work like in C
09:16:26 <cgizmo> after it's declared, it has a fixed size
09:16:29 <edwardk> yeah, under the hood, but they also know their bounds
09:16:46 <cgizmo> and you can access the element using the [n] in C and (!) in haskemm
09:16:58 <edwardk> > bounds (listArray ('a','z') [1..])
09:17:00 <lambdabot>   ('a','z')
09:17:03 <cgizmo> edwardk: the arrays in haskell store their own size ?
09:17:26 <edwardk> they remember the range associated with them, so they can use it to compute the index to the underlying slot
09:17:50 <edwardk> > listArray ('a','z') [1..] ! '*'
09:17:51 <lambdabot>   * Exception: Error in array index
09:18:00 <cgizmo> so the size of an array is actually the size of the rangze attached to it ?
09:18:00 <edwardk> and so they can yell at you for out of bounds accesses like that
09:18:06 <edwardk> yep
09:18:17 <edwardk> >rangeSize ('a','z')
09:18:30 <edwardk> > rangeSize ('a','z')
09:18:31 <lambdabot>   26
09:19:13 <tromp_> > rangeSize((0,0),(3,3))
09:19:15 <lambdabot>   16
09:19:28 <edwardk> it sneakily lets them build multi-dimensional arrays, etc. off of the basic machinery
09:19:45 <edwardk> > rangeSize ((0,'m'),(256,'z'))
09:19:46 <lambdabot>   3598
09:19:57 <cgizmo> that's pretty nice too :D
09:20:15 <edwardk> > rangeSize (LT,GT)
09:20:16 <lambdabot>   3
09:20:41 <edwardk> and if you have something bounded, you can always do something like
09:20:59 <edwardk> > rangeSize (minBound :: Ordering,maxBound)
09:21:00 <lambdabot>   3
09:21:09 <tromp_> > rangeSize((1,1),(1,2),(1,3),(1,4)) -- 4!
09:21:10 <lambdabot>   Couldn't match expected type `(a, a)'
09:21:21 <cgizmo> i just tried this in ghci :
09:21:30 <cgizmo> Prelude Array> let list = [1..20]
09:21:30 <edwardk> > rangeSize(((1,1),(1,2)),((1,3),(1,4)))
09:21:31 <cgizmo> Prelude Array> listArray (0, (length list)) list
09:21:31 <lambdabot>   9
09:21:41 <tromp_> > rangeSize((1,1,1,1),(1,2,3,4)) -- 4!
09:21:42 <lambdabot>   24
09:21:43 <edwardk> off by one ;)
09:21:49 <cgizmo> but it gives me an error
09:22:11 <cgizmo> should'nt it return an array ?
09:22:13 <mauke> length list - 1
09:22:13 <edwardk> > let list = [1..20] in listArray (0,length list - 1) list ! 4
09:22:14 <lambdabot>   5
09:22:29 <edwardk> > let list = [1..20] in listArray (0,length list - 1) list
09:22:30 <lambdabot>   array (0,19) [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),...
09:22:45 <cgizmo> ah, thanks !
09:23:12 <cgizmo> well, thank you for your time!
09:23:17 <edwardk> you can fix it by making it a '1' based array or by subtracting 1 from the length
09:23:24 <edwardk> > let list = [1..20] in listArray (1,length list) list
09:23:25 <lambdabot>   array (1,20) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)...
09:23:45 <cgizmo> thanks for the tip
09:23:57 <cgizmo> i have to go
09:23:59 <cgizmo> thanks again
09:29:55 <tromp_> hmm, cabal complains: cannot configure base-4.0.0.0. It requires ghc-prim -any and integer -any
09:29:55 <dcoutts_> tromp_: what version of the cabal program are you using?
09:29:55 <dcoutts_> sounds like it might be a little old
09:29:55 <dcoutts_> cabal --version
09:29:55 <tromp_> cabal-install version 0.6.2
09:29:55 <tromp_> using version 1.6.0.2 of the Cabal library
09:29:55 <tromp_> i just made it yesterday
09:29:55 <dcoutts_> tromp_: hmm, and what were you doing? It should never decide to download and install base.
09:29:55 <tromp_> cabal install yi-0.6.0 -fvty
09:29:55 <tromp_> cabal: cannot configure yi-0.6.0. It requires base >=4
09:29:55 <tromp_> For the dependency on base >=4 there are these packages: base-4.0.0.0. However
09:29:55 <tromp_> none of them are available.
09:29:55 <tromp_> base-4.0.0.0 was excluded because of the top level dependency base -any
09:29:55 <tromp_> then i tried cabal install base-4.0.0.0
09:29:55 <dcoutts_> ahh, ok
09:29:55 <dcoutts_> tromp_: I guess you're using ghc-6.8?
09:29:55 <tromp_> 6.8.2
09:29:55 <dcoutts_> right
09:29:55 <dcoutts_> what's confusing there is "base-4.0.0.0 was excluded because of the top level dependency base -any"
09:29:55 <tromp_> right; no idea what that means:(
09:29:55 <dcoutts_> what it actually is doing is excluding the available version of base-4 from hackage, because it requires an installed version
09:29:56 <dcoutts_> but the message does not say so
09:30:26 <dcoutts_> tromp_: this is the mechanism it used to prevent accidentally trying to upgrade base, by requiring an installed version.
09:30:33 <tromp_> can i see what version of base is installed, if any?
09:30:49 <dcoutts_> tromp_: ghc-pkg list base. It's version 3.something with ghc-6.8
09:31:06 <dcoutts_> tromp_: so if yi now requires base 4, then it only works with ghc-6.10
09:31:07 <tromp_>     base-3.0.1.0
09:31:28 <tromp_> ic, you can only upgrade base with ghc
09:31:53 <tibbe_> it's amazingly difficult to get a working GHC/Cabal setup on windows :/
09:32:18 <dcoutts_> tibbe_: is it? there's a cabal.exe on the cabal home page
09:32:24 <tromp_> the recent cabal bootstrap bash script posted on planet haskell was very helpful
09:32:27 <Bacta> Dear Haskell
09:32:28 <LeoD> tibbe_: really ;o seemed pretty straightforward to me :P
09:32:31 <Bacta> Please stop spamming Reddit
09:32:36 <Bacta> Thank you
09:32:47 <tibbe_> LeoD, well, it kinda worked until I tried to build the network package
09:32:54 <tromp_> but i had to replace the sudo by a private -prefix
09:33:00 <dcoutts_> tibbe_: ghc comes with network, no need
09:33:07 <tibbe_> LeoD. Setup.hs: sh: runGenProcess: does not exist (No such file or directory)
09:33:10 <tromp_> since i dont have sudo priviledge on this machine
09:33:24 <BONUS> Bacta: you're free to downvote stuff
09:33:24 <LeoD> tibbe_: oh..
09:33:27 <BONUS> you're welcome
09:33:33 <dcoutts_> tibbe_: do you need to build it yourself? why not just use the pre-built cabal.exe?
09:33:44 <dcoutts_> tibbe_: or use that to re-build it if you want
09:33:57 <tibbe_> dcoutts_: I'm testing my changes to network on a win machine ;)
09:34:15 <tibbe_> dcoutts_: I'm using the prebuilt cabal, see my error message above
09:34:28 <tibbe_> dcoutts_: Setup.hs: sh: runGenProcess: does not exist (No such file or directory)
09:35:10 <dcoutts_> tibbe_: ah, so you've got cabal installed, you're trying to build network which uses a ./configure script
09:35:45 <dcoutts_> tibbe_: so what was the difficulty in getting a working GHC/Cabal setup on windows?
09:36:07 <tibbe_> dcoutts_: well, OK. Get a general Haskell setup that lets my build cabal packages
09:36:15 <dcoutts_> tibbe_: ah ok.
09:36:32 <dcoutts_> tibbe_: so since network uses a ./configure script then it needs access to a sh.exe
09:36:46 <dcoutts_> eg run it from within an MSYS console session
09:36:56 <tibbe_> dcoutts_: right, I'm MinGW/MSYSing and grabbing random exes all over the web
09:37:23 <dcoutts_> tibbe_: what did you need beyond mingw/msys?
09:37:31 <dcoutts_> tibbe_: cabal.exe, darcs.exe, ...
09:38:47 <edwardk> @seen rdockins
09:38:47 <lambdabot> I haven't seen rdockins.
09:38:55 <tibbe_> dcoutts_: I'm trying to figure out what exactly mingw/msys encompasses
09:39:07 <tibbe_> dcoutts_: there's a large number of files on the website
09:39:20 <edwardk> er, what does he go by on here? =) both the shellac and lambda shell links on his site are dead
09:39:21 <dcoutts_> tibbe_: oh, get the all-in-one version, not all the little bits
09:39:32 <dcoutts_> tibbe_: you only need two downloads, msys and mingw
09:40:18 <dcoutts_> tibbe_: mingw gives you gcc. msys gives you the rest of the standard unix utils, enough to run ./configure, make.
09:40:36 <dcoutts_> tibbe_: the mingw/msys website is horribly confusing though
09:41:34 <dcoutts_> you install msys first, then you install mingw into a subdir of where you put msys
09:41:51 <dcoutts_> I think there are some instructions on the ghc dev trac
09:42:17 <dcoutts_> tibbe_: of course if you could manage to eliminate the ./configure script from the network package then we'd all be happy
09:42:19 <tibbe_> dcoutts_: OK thanks. I'll have a look.
09:42:39 <aleator> Would anyone have haskell code for calculating p-values for students t-test lying around?
09:42:42 <tibbe_> dcoutts_: Yes that would be great. My autotools skillz are somewhat lacking
09:42:45 <dcoutts_> tibbe_: that'll require more clever things in the Setup.hs and probably some help from Cabal in terms of helpful lib utils.
09:43:04 <tibbe_> dcoutts_: yes. a good first step would be to figure out what's needed
09:43:19 <dcoutts_> tibbe_: we can look at it at the hackathon
09:43:51 <dcoutts_> tibbe_: I'd like to see a survey of what the remaining ./configure scripts are actually doing and what we need to provide so they can be eliminated
09:44:00 <dcoutts_> there's a ticket on this
09:47:06 <tibbe_> dcoutts_: I can't attend the hackathon unfortunately. I will be in Thailand
09:47:18 <tibbe_> dcoutts_: But it would be a great thing to do
09:47:24 <dcoutts_> tibbe_: oh, well have fun there :-)
09:47:37 <tibbe_> dcoutts_: I will :) thanks
09:48:28 <ImInYourMonad> hmm, I have a question. I want to add some visualization to my KNN algorithm, anyone have good idea of how to plot it in an elightening way. I measure similarity between vectors with euclidean distance. I would then like to plot in some circle-like way. where the center is the <datum> im trying to classify and then the other datums are displayed on a distance away from it.
09:50:05 <tibbe_> dcoutts_: my win setup is working now. thanks. I can now confirm that my changes don't work on windows
09:50:21 <dcoutts_> tibbe_: yay, and doh! :-)
10:07:52 <ski> Evening was drawing near.
10:07:54 <x6a616e> help: is there a split function in haskell? sth. like split "a,b,c" ','
10:08:44 <skorpan> @hoogle [a] -> a -> [a]
10:08:45 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:08:45 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:08:45 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:08:45 <cnwdup> x6a616e, surprisingly there isn't. If efficiency isn't a concern, you could implement your own using splitAt.
10:09:16 <x6a616e> cnwdup: ic, thanks
10:09:19 <skorpan> cnwdup: what if efficiency is a concern?
10:09:35 <cnwdup> skorpan, then I've heard you shouldn't be using splitAt.
10:09:52 <x6a616e> @hoogle a -> [a] -> [a]
10:09:52 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:09:52 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:09:52 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:10:03 <Botje> x6a616e: look at Data.List.Split
10:10:22 <x6a616e> @src Data.List.Split
10:10:22 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:10:30 <Botje> on hackage
10:10:33 <skorpan> apparently there's Data.ByteString.split
10:10:43 <skorpan> it's O(n)
10:10:51 <x6a616e> Botje: thanks I'll check that
10:11:03 <skorpan> split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
10:11:04 <skorpan>  
10:11:13 <Botje> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
10:11:15 <skorpan> looks like that's exactly what you want, but as i said, that's for bytestrings
10:11:19 <protoscript> greetings folks..i've tried over and over and over again to install cabal on mac os. i always get stuck on zlib, which returns the following message:
10:11:19 <protoscript> Installing library in /usr/local/lib/zlib-0.5.0.0/ghc-6.10.1
10:11:19 <protoscript> Setup: Error: Could not find module: Codec.Compression.GZip with any suffix:
10:11:19 <protoscript> ["hi"]
10:11:24 <protoscript> any ideas?
10:11:30 <x6a616e> skorpan: yes
10:12:06 <dcoutts_> protoscript: what method are you using to build and install it?
10:12:26 <dcoutts_> protoscript: did you try the bootstrap.sh ?
10:12:30 <protoscript> no
10:12:40 <protoscript> i have tried port and http://book.realworldhaskell.org/read/installing-ghc-and-haskell-libraries.html#install.pkg.manual
10:12:48 <Bacta> haskell = gay
10:12:52 <Bacta> Is that a function?
10:12:54 <protoscript> what is bootstrap? when would i run it
10:13:11 <dcoutts_> protoscript: it's a .sh script in the cabal-install tarball
10:13:24 <bremner> Bacta: sure. technically a pointless function
10:13:34 <protoscript> ok. i'll try running that. thanks
10:13:39 <Bacta> haskell = gay()
10:13:40 <x6a616e> Data.List.Split looks great!
10:13:41 <Bacta> gay = 5
10:13:42 <Bacta> ?
10:13:49 <mauke> Bacta: that's a type error
10:13:53 <mauke> Bacta: 5 is not a function
10:13:54 <dcoutts_> protoscript: ok, if you're using runghc Setup, did you run build before running install?
10:14:02 <protoscript> yes
10:14:09 <Bacta> No no no
10:14:18 <Bacta> something = integer works?
10:14:20 <dcoutts_> protoscript: did the build step complete successfully?
10:14:24 <Bacta> I remember from uni
10:14:34 <protoscript> on closer inspection.. no ... sorry i missed that
10:14:48 <protoscript> ld: library not found for -lgmp
10:14:50 <protoscript> collect2: ld returned 1 exit status
10:14:53 <protoscript> linking dist/build/Codec/Compression/Zlib/Stream_hsc_make.o failed
10:14:54 <skorpan> Bacta: something = some integer works, that makes "something" a function which always returns the integer
10:15:03 <mauke> skorpan: no, it doesn't
10:15:04 <dcoutts_> protoscript: ahh, you need gmp installed. ghc needs that for everything
10:15:05 <skorpan> no?
10:15:08 <mauke> it makes 'something' a constant
10:15:21 <skorpan> hm...
10:15:40 <Bacta> haskell = gay()
10:15:41 <skorpan> so what is a function?
10:15:42 <Bacta> gay = "gay"
10:15:50 <mauke> skorpan: something with -> in its type
10:16:03 <mauke> Bacta: same problem, "gay" is not a function
10:16:03 <protoscript> thanks! iw ill try installing that with port
10:16:06 <protoscript> and see if it helps
10:16:10 <skorpan> mauke: i.e. a function always takes at least one argument?
10:16:19 <mauke> skorpan: s/at least/exactly/
10:16:29 * bremner wonders if someone can use gay in every example and not be trolling
10:16:34 <Bacta> No I can do gay = string literal
10:16:44 <mauke> Bacta: hmm?
10:16:48 <Bacta> correct?
10:16:48 <dcoutts_> protoscript: so you installed ghc via macports?
10:16:54 <skorpan> mauke: but iirc, in lambda calculus you can have an abstraction which takes no arguments
10:16:56 <mauke> Bacta: try it and see
10:17:05 <mauke> skorpan: I find that unlikely
10:17:08 <Philippa_> bremner: I could offer few alternate theories, but they're little nicer
10:17:20 <Bacta> does Linsucks have a built in Haskell interpretter?
10:17:28 <Bacta> Or will I need to download one?
10:17:31 <mauke> what's a Linsucks?
10:17:36 <Bacta> Sorry, Linux
10:17:44 <bremner> Philippa_: point for me, I think /ignoring
10:17:47 <protoscript> no that (installing ghc via macports) didnt work either.. unfortunately http://gmplib.org/macos.html makes it sound like i wont have much success doing it outside macports tho
10:17:53 <mauke> no, linux doesn't have any built-in interpreters
10:18:02 <Bacta> What's a popular one?
10:18:06 <mauke> perl
10:18:08 <Philippa_> mauke: except when you compile the GHC RTS into the linux kernel to get a haskell OS ;-)
10:18:14 <protoscript> dcoutts, should i try installing ghc thru macports and deal w the issues there instead?
10:18:18 <dcoutts_> protoscript: how did you install ghc? I thought the one from haskell.org/ghc came with gmp.
10:18:30 <mauke> modprobe ghc
10:18:44 <Bacta> goddammit
10:18:49 <Bacta> Why do you all have to bite so hard? :D
10:18:58 <protoscript> i used http://www.haskell.org/ghc/download_ghc_6_10_1.html#macosxintel
10:18:59 <dcoutts_> Bacta: get it here http://haskell.org/ghc/
10:19:03 <Bacta> Ok I'm going to stop now
10:19:06 <skorpan> this guy's trolling
10:19:09 <Bacta> I like the people in this chann
10:19:22 <SamB> lol
10:19:23 <mauke> skorpan: we're reverse trolling
10:19:41 <Bacta> What's the opposite of trolling?
10:19:44 <Philippa_> mauke: you missed a perfectly good opportunity to use the 'meta' prefix
10:20:20 <protoscript> i suppose it doesnt include gmp if zlib build is complaining.. or it isnt configured correctly... or something
10:20:37 <dcoutts_> protoscript: which one did you use? there are two there
10:20:43 <protoscript> the .pkg
10:21:14 <protoscript> it appeared to install succesfully
10:21:18 <protoscript> and i can run ghci
10:21:35 <dcoutts_> hmm, that must use gmp
10:22:06 <protoscript> hmmm the message specifically was "ld: library not found for -lgmp"
10:22:11 <protoscript> is lgmp something else?
10:22:15 <protoscript> or is that just a flag
10:23:11 <dcoutts_> protoscript: can you run ghc-pkg describe rts and paste the (long) output somewhere like hpaste.org
10:23:22 <protoscript> sure
10:23:31 <protoscript> (thanks so much for ur help btw)
10:23:35 <dcoutts_> np
10:24:48 <protoscript> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2420#a2420
10:26:33 <protoscript> (in case the other approach would be helpful, this is the error i get when installing ghc via port: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2421#a2421 )
10:26:50 <dcoutts_> protoscript: hmm, so what I'm wondering is where the gmp that comes with ghc actually lives, can you spot something like gmp.dynlib in /usr/local/lib/ghc-6.10.1 ?
10:27:02 <protoscript> checking
10:27:47 <dcoutts_> protoscript: the other interesting thing would be the contents of /usr/local/lib/ghc-6.10.1/extra-gcc-opts
10:28:08 <dcoutts_> if there's any -L flag there then that'd be a problem
10:29:52 <protoscript> macattax:ghc-6.10.1 rob$ cat extra-gcc-opts
10:29:52 <protoscript>  -fwrapv -mno-omit-leaf-frame-pointer -fno-unit-at-a-time
10:30:01 <dcoutts_> ok, that's fine
10:30:09 <protoscript> dont see a gmp
10:30:19 <dcoutts_> protoscript: it looks like what is happening is that ghc can find the gmp lib but when cabal calls hsc2hs for packages like zlib, it cannot find it.
10:30:40 <dcoutts_> protoscript: so that's what I'm trying to figure out, why ghc can find it and yet cabal cannot.
10:30:48 <protoscript> could it be something with ports?
10:31:02 <protoscript> when i tried to install gmp via ports it said one was alrady active
10:31:16 <protoscript> maybe ghc knows to look somewhere else but cabal doesnt
10:31:38 <dcoutts_> protoscript: right, but why, and where is that info kept.
10:31:56 <mk15> http://dl.getdropbox.com/u/256410/indentation.lhs
10:32:40 <dcoutts_> protoscript: I'm a bit confused though, you said you're using the .pkg version, but that installs into /Library/Frameworks/GHC.framework not /usr/local
10:32:52 <mk15> ok guys i read some indentation tutorials but im missing something...i reindented someones code because it was messy, but my "fixed code" wont compile and his does....what am I doing wrong?
10:33:01 <mk15> the link is posted two lines up
10:33:20 <protoscript> its def possible i had previously installed it elsewhere in one of my many many months long attempts
10:33:23 <protoscript> lemme check frameowrks
10:33:39 <protoscript> i have one there too
10:33:51 <skorpan> mk15: the last "do" construct is bad
10:33:54 <protoscript> hmm
10:33:55 <protoscript> \macattax:GHC.framework rob$ which ghc
10:34:11 <protoscript>  /usr/local/bin/ghc
10:34:20 <skorpan> mk15: "children" should be aligned with "labelSetText"
10:34:22 <dcoutts_> mk15: everything in a single do block has to be in the same column
10:34:31 <protoscript> so when i call ghci i am likely not calling the one i recently installed
10:34:45 <dcoutts_> protoscript: ok, that'd explain some things
10:35:03 <dcoutts_> protoscript: try using the .pkg version and see if that one works
10:46:43 <mk15> skorpan, dcoutts looking at it now..thanks
10:49:28 <protoscript> dcoutts :-/ same problem. i was sure to use the runghc included in frameworks..
10:49:29 <protoscript> Preprocessing library zlib-0.5.0.0...
10:49:29 <protoscript> ld: library not found for -lgmp
10:49:30 <protoscript> collect2: ld returned 1 exit status
10:49:30 <protoscript> linking dist/build/Codec/Compression/Zlib/Stream_hsc_make.o failed
10:49:44 <Glenjamin> hey guys, i'm having some issues with module importing
10:49:59 <Glenjamin> ghc-pkg says Hunit is available, but "import HUnit" in ghci fails
10:50:00 <dcoutts_> protoscript: ok, so can you repeat the thing with ghc-pkg describe rts
10:50:04 <protoscript> sure
10:50:34 <dcoutts_> Glenjamin: that's not the right module name. The relationship between package names and the modules they contain is not quite that simple.
10:50:34 <Saizan_> whats a good way to find all the compositions you can make with a set of "arrows" [(Dom,CoDom,Name)] ?
10:50:54 <Glenjamin> oh, the manual just says to "import HUnit" :s
10:51:07 <dcoutts_> Glenjamin: oh :-( it's sadly out of date.
10:51:12 <Glenjamin> ah
10:51:23 <vixey> Saizan_: Including infinite ones?
10:51:30 <Saizan_> it's Test.HUnit now
10:51:40 <dcoutts_> Glenjamin: you might like to email the person who maintains that page and complain that it's misleading. You're not the first to hit that one.
10:51:47 <ImInYourMonad> if I rep cusomers movieratings as a vector where grades are 1 to 5 and non-graded movies are 0s, like: customer1 = [0,0,4,0,0,3,0,0,3,0,4,0,3,0,0,0,0], how would I plot this? If I want it to beplotted as a proper vector not just a list of numbers? caluclate the euclidean distance? but how do I get the angle? I can get vectorLength by calculating, but direction ro angle?
10:51:50 <Glenjamin> good plan, thanks for the help
10:51:59 <dcoutts_> Glenjamin: I do recall now seeing that page and other people hitting that problem.
10:52:19 <Saizan_> vixey: in my application i can actually use each arrow only once
10:52:30 <Saizan_> vixey: in each composition
10:52:50 <protoscript> dcoutts http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2422#a2422
10:53:04 <Glenjamin> hrm, my sourceforge password has "expired"
10:53:12 <Glenjamin> how pointless
10:53:13 <vixey> Saizan_: I would use select/3 and write the prolog version in []
10:53:39 <vixey> select is a nice way to deal with the one use only
10:54:00 <dcoutts_> protoscript: ok, so does the directory listed there in the library-dirs: field contain libgmp.a ?
10:54:04 <Saizan_> what do you mean by "in []"?
10:54:30 <vixey> list monad
10:54:42 <Saizan_> ah, ok :)
10:54:50 <dcoutts_> protoscript: if it does the next step is to re-run the build step for zlib with -v2 and see how cabal is calling hsc2hs.
10:55:06 <protoscript> libgmp.a !
10:55:11 <protoscript> ok will try
10:56:27 <protoscript> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2423#a2423
10:56:44 <protoscript> its going to usr/local
10:56:59 <ski> select :: [a] -> [] (a,[a])
10:57:02 <protoscript> eh i dunno i just mean i see that
10:57:43 <EvilTerran> [] a = [a], in types
10:57:57 <protoscript> definitely doesn't look right to me tho dcoutts.. seems like i need to tell zlib where to look..
10:58:26 <tibbe_> .
10:58:45 <dcoutts_> protoscript: looks like it's finding the ghc that lives in /usr/local
10:58:53 <protoscript> yeah :/
10:59:15 <dcoutts_> protoscript: which would be because the 'ghc' on the $PATH is still the one in /usr/local
10:59:43 <dcoutts_> protoscript: you can tell it to use a different one, but really you should probably just get rid of the other one and use the framework one
11:00:13 <dcoutts_> protoscript: in the mean time you can use runghc Setup build --with-ghc=/path/to/ghc
11:00:35 <protoscript> ah ok. lemme try :D
11:01:02 <vixey> I would use <> for Maybe/option
11:01:48 <ski> interesting ..
11:01:52 <ski> why so ?
11:02:36 <vixey> it makes <a -> b> -> (a -> <b>) look impossible
11:03:27 <ski> @djinn Maybe (a -> b) -> (a -> Maybe b)
11:03:27 <lambdabot> f a b =
11:03:27 <lambdabot>     case a of
11:03:27 <lambdabot>     Nothing -> Nothing
11:03:29 <lambdabot>     Just c -> Just (c b)
11:03:55 <ski> maybe you were thinking of the converse ?
11:04:54 <felixc> hello all, I have a (hopefully) quick question regarding concurrent haskell. First of all, I just want to mention that I am extremely new to both Haskell and highly concurrent systems, so forgive me if (or rather when) I get concepts mixed up. I have been experimenting with Stackless Python, which is a Python that provides "microthreads" (extremely lightweight concurrency constructs that run entirely within the interpreter, allowing for Erlang-
11:05:02 <felixc> whoah that was longer than I thought!
11:05:20 <ski> cut off at ".. allowing for Erlang-"
11:05:20 <Zao> felixc: Haskell has lightweight green threads.
11:05:41 <vixey> yeah I was thinking about the converse
11:06:11 <felixc> Zao: forkIO? the second part of my question is in regards to that... or is there another set of tools I should look into?
11:06:56 <ski> i'm not sure why that notation in itself would make it look impossible, though ..)
11:08:08 <tibbe> ewww, Network.Socket does lazy initialization if withSocketsDo
11:08:24 <protoscript> dcoutts... it's still going to /usr/local for some stuff: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2424#a2424
11:09:09 <dcoutts_> protoscript: you'd need to runghc Setup configure again to get it to change which ghc it's using.
11:09:18 <protoscript> ah
11:09:28 <protoscript> sorry i'm sure that's obvious
11:09:42 <dcoutts_> protoscript: if you've got your $PATH set up right you should be able to just run runghc, without needing the massive long path name.
11:11:55 <protoscript> sheesh i have a lot of ghcs on this system
11:12:09 <protoscript> i moved that one out of the path, now theres another
11:12:10 <protoscript> heh
11:12:19 <Zao> felixc: Yes, forkIO. There's forkOS if you need a real OS thread.
11:12:38 <Zao> felixc: There's also `par` to spark off evaluation of a thunk.
11:12:45 <mauke> I don't think that's what forkOS does
11:12:49 <Zao> And Control.Parallel with strategies to fork things.
11:12:52 <Zao> mauke: Feel free to correct then.
11:13:52 <ImInYourMonad> how do I get the angle of a vector of movieratings? I can get the length but what is a meaningful way to define the angle for such a thing?
11:13:57 <Zao> Ah, OS creates a bound thread.
11:14:14 <mauke> forkOS just restricts the foreign calls coming from that haskell thread
11:14:45 <felixc> ah, thanks, yes, I'd been looking at forkIO, though there are still some things I'm unclear about that I brought up in the second half of my question -- any ideas on those?
11:15:05 <mauke> what question?
11:15:45 <felixc> mauke: the relevant part "I have been looking into Haskell's forkIO and related tools, and I just want to find out how similar these concepts are. Specifically, how lightweight is forkIO? Can I still have Erlang-style thousands of threads? Is scheduling just simple round-robin (like Stackless) and hence constant-time, or is the overhead more significant?"
11:16:20 <mauke> I don't know how it's implemented, but you can easily have hundred thousands of threads with forkIO
11:16:23 <dons> felixc: you can have a milllion forkIO threads
11:16:29 <felixc> fantastic :)
11:16:43 <dons> felixc: read the most recent paper on the haskell runtime, at simon marlow's home page
11:16:57 <dons> it explains the scheduling mechanism, the threads sparks, forkIO, and how they all map down onto multicore
11:17:07 <felixc> dons: I will google that right away, thanks
11:18:38 <mk15> how does ghc treat a tab? is it equal to one whitespace, 4 whitespace....etc
11:18:38 <protoscript> dcoutts! thank you thank you thank you
11:18:42 <protoscript> my months long quest is over
11:18:48 <protoscript> i wish i came in here earlier o_O
11:18:55 <dcoutts_> protoscript: great :-)
11:18:56 <mauke> a tab is one whitespace
11:19:02 <mauke> but that doesn't help you
11:19:08 <Mr_Giraffe> hmm, if i want to make a 2D learning simulation that involves mostly line-based graphics, should i be using openGL rather than SDL?
11:19:10 <dcoutts_> mauke: no, it's 8
11:19:19 <Mr_Giraffe> dcoutts_: implementation-dependent
11:19:23 <vixey> yes OpenGL
11:19:24 <mauke> > (length "\t", isSpace '\t')
11:19:24 <lambdabot>   (1,True)
11:19:28 <protoscript> now i can continue my real world haskell tutorial :] any cabal lib that is a must have that i should use to test it?
11:19:44 <Mr_Giraffe> vixey: thanks much
11:19:51 <trofi> @pl do { Just a <- act; Just b <- act; return (a+b) }
11:19:52 <lambdabot> (line 1, column 4):
11:19:52 <lambdabot> unexpected "{"
11:19:52 <lambdabot> expecting variable, "(", operator or end of input
11:20:11 <trofi> @undo do { Just a <- act; Just b <- act; return (a+b) }
11:20:11 <lambdabot> act >>= \ c -> case c of { Just a -> act >>= \ c -> case c of { Just b -> return (a + b); _ -> fail ""}; _ -> fail ""}
11:20:18 <dcoutts_> mauke: oh, sorry I thought you were talking about alignment in Haskell layout
11:20:23 <mauke> trofi: liftM2 (+) act act
11:20:35 <trofi> + == mplus?
11:20:44 <Mr_Giraffe> vixey: uh...is it poor form to be using a lot of do blocks in a graphics-based program?
11:20:49 <trofi> :t mplus
11:20:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:20:51 <Mr_Giraffe> it seems pretty much unescapable
11:21:16 <trofi> > Nothing + (Just 3) + (Just 2)
11:21:17 <lambdabot>       No instance for (Num (Maybe a))
11:21:17 <lambdabot>        arising from a use of `+' at <in...
11:21:34 <Mr_Giraffe> :t (+)
11:21:35 <lambdabot> forall a. (Num a) => a -> a -> a
11:21:41 <ski> > Nothing `mplus` Just 3 `mplus` Just 2
11:21:42 <lambdabot>   Just 3
11:21:56 <ski> > msum [Nothing,Just 3,Just 2]
11:21:57 <lambdabot>   Just 3
11:22:02 <LeoD> > Just 3 <$> Just 2
11:22:03 <lambdabot>   Couldn't match expected type `a -> b'
11:22:07 <LeoD> argh
11:22:10 <trofi> @src liftM2
11:22:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:22:28 <mk15> ok so thee final answer is that ghc treats a tab the same way as a whitespace? im looking at some code that mixes tabs and whitespace together and its hard to tell if the ghc is actually seeing the indentation the same way im seeing it in the editor
11:22:39 <mauke> mk15: "a whitespace" does not make sense
11:22:46 <seliopou> :t liftM2 (liftM2 (+)
11:22:47 <lambdabot> parse error (possibly incorrect indentation)
11:22:59 <seliopou> :t liftM2 (liftM2 (+))
11:22:59 <mauke> mk15: you can't mix tabs and whitespace because "whitespace" includes tabs
11:23:00 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m, Num a1) => m1 (m a1) -> m1 (m a1) -> m1 (m a1)
11:23:07 <mk15> when I say "whitespace" i mean pressing the spacebar
11:23:16 <mk15> as opposed to pressing the tab button
11:23:23 <mauke> that's just a space
11:23:28 <ski> > isSpace '\t'
11:23:29 <lambdabot>   True
11:23:54 <tibbe> what's Sigbjorn Finne's handle?
11:24:00 <ski> sj
11:24:02 <banbh> To get an instance of  (Monad ((->) a)) I thought (based on the docs) that it would enough to import Control.Monad, however it seems I need to import Control.Monad.Instances.  Am I missing something?
11:24:06 <ski> (er)
11:24:09 <trofi> :t darkspace
11:24:10 <lambdabot> Not in scope: `darkspace'
11:24:28 <mauke> banbh: no
11:24:36 <ski> banbh : you could also import `Control.Monad.Reader', iirc
11:24:51 <banbh> mauke: thx
11:24:59 <trofi> :t ap
11:25:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:25:10 <trofi> :t liftM2
11:25:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:25:19 <banbh> Just curious, why do the Control.Monad docs list that as an instance then?
11:25:26 <ddarius> > filter isSpace (map chr [0..255])
11:25:28 <lambdabot>   "\t\n\v\f\r \160"
11:25:32 <ski>   liftM2 f ma mb = return f `ap` ma `ap` mb
11:25:40 <tibbe> @seen sj
11:25:40 <lambdabot> I haven't seen sj.
11:26:14 <trofi> s/return/return\$/ ?
11:26:22 <ski> no
11:26:30 <trofi> :t return
11:26:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:26:35 <ski> @type let liftM2 f ma mb = return f `ap` ma `ap` mb in liftM2
11:26:36 <lambdabot> forall a a1 b (m :: * -> *). (Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
11:26:44 <ski> @type liftM2
11:26:45 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:27:52 <trofi> @src ap
11:27:52 <lambdabot> ap = liftM2 id
11:28:06 <trofi> %)
11:29:43 <trofi> > (return ^(2)) `ap` (Just 3)
11:29:44 <lambdabot>   Couldn't match expected type `a -> a1'
11:29:49 <trofi> > (return (^2)) `ap` (Just 3)
11:29:50 <lambdabot>   Just 9
11:30:04 <ski> > return (^ 2) `ap` Just 3
11:30:06 <lambdabot>   Just 9
11:30:08 <trofi> > (return (^2)) `ap` (Just 3) `ap` (Just 4)
11:30:09 <lambdabot>       No instance for (Num (a -> b))
11:30:09 <lambdabot>        arising from a use of `^' at <int...
11:30:12 <ImInYourMonad> how do I calc the angles to 6 axices for a 7dimensional vector?
11:30:16 <gnuvince_> How do I pass a Handle to a C function that expects a Ptr CFile?
11:30:25 <mauke> gnuvince_: you've lost
11:30:32 <ski> > return (^) `ap` return 3 `ap` return 4 :: Maybe Integer
11:30:33 <lambdabot>   Just 81
11:30:37 <gnuvince_> mauke: really?
11:30:44 <mauke> I think so
11:30:48 <Peaker> gnuvince_: can you get an FD out of the Handle?
11:30:51 <ski>   return f `ap` return x = return (f x)
11:31:03 <mauke> Peaker: not without closing the handle
11:31:13 <trofi> ap is smth like partial application?
11:31:25 <newsham> ap is like application
11:31:26 <vixey> trofi what
11:31:28 <newsham> hence the name
11:31:28 <Peaker> trofi: ap applies the result of left computation to the result of right computation
11:31:34 <ski> `ap' is idiom/applicative application
11:31:36 <newsham> its a lot like ($)
11:31:38 <gnuvince_> Peaker: I'm still just trying to figure out how I'm going to write the Haskell wrapper, so if a Handle is the wrong to do it, I don't mind going down another avenue.
11:32:08 <trofi> > (+) `ap` 1 `ap` 2
11:32:08 <lambdabot>       Overlapping instances for Show ((a -> b) -> b)
11:32:08 <lambdabot>        arising from a us...
11:32:24 <vixey> > [(+)] `ap` [1] `ap` [2]
11:32:25 <lambdabot>   [3]
11:32:37 <Peaker> gnuvince_: I don't know much about Handles.  If you have an fd and want a Ptr CFile you probably want to call fdopen
11:32:52 <conal> perhaps return, ap & liftM2 etc will someday be deprecated in favor of pure, (<*>), liftA2 etc.
11:32:53 <ski> > [(+),(*)] `ap` [1,2] `ap` [3,4]
11:32:55 <lambdabot>   [4,5,5,6,3,4,6,8]
11:33:04 <gnuvince_> This FFI is business is really complicated.
11:33:16 * ski prefers the name `ap' to the name `(<*>)'
11:33:19 <trofi> > [(f),(g)] `ap` [a,b] `ap` [c,d]
11:33:20 <ddarius> conal: When Applicative gets put as a superclass of Monad.
11:33:21 <lambdabot>   Add a type signature
11:33:23 <Peaker> gnuvince_: I think its simpler than in other languages, but I've only done basic stuff
11:33:27 <trofi> > [(f),(g)] `ap` [a,b] `ap` [c,d] :: [Expr]
11:33:28 <lambdabot>   [f a c,f a d,f b c,f b d,g a c,g a d,g b c,g b d]
11:33:29 <conal> ddarius: yeah.  that someday.
11:33:47 <newsham> > let (<*>) = liftM2 ($) in [(+)] <*> [1,2] <*> [3]
11:33:48 <lambdabot>   [4,5]
11:34:06 <ski> (trofi : is there a reason you're sprinkling all these extra brackets around ?)
11:34:06 <newsham> conal: that would be nice
11:34:39 <trofi> ski: nope, i just always forget op precedence
11:34:40 <gnuvince_> Peaker: the only other language I've done "cross language" work with is Clojure.
11:35:33 <Peaker> gnuvince_: I've done C<->Python, C<->x86/{32,64} asm, C++ horrors, and a bit of Haskell <-> C
11:35:46 <trofi> > [a,b] `ap` [c,d] :: [Expr]
11:35:47 <lambdabot>   Couldn't match expected type `a -> Expr'
11:35:59 <newsham> C `ap` Python
11:36:15 <trofi> :t [a] `ap` [a]
11:36:17 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
11:36:17 <lambdabot>     In the expression: a
11:36:17 <lambdabot>     In the first argument of `ap', namely `[a]'
11:36:31 <ski> @type \a -> a $ a
11:36:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
11:36:32 <lambdabot>     Probable cause: `a' is applied to too few arguments
11:36:32 <lambdabot>     In the second argument of `($)', namely `a'
11:36:34 <newsham> :t [f] `ap` [x]
11:36:35 <ski> > [f,g] `ap` [a,b] :: [Expr]
11:36:35 <lambdabot> forall b. (SimpleReflect.FromExpr b) => [b]
11:36:36 <lambdabot>   [f a,f b,g a,g b]
11:36:41 <gnuvince_> Peaker: I'm porting the Clojure library to see how easy it would be to do the same task in Haskell.  So far, just doing the FFI is harder than the entire thing in Clojure :-/
11:37:18 <ski> @type \(a :: forall a. a -> a) -> a $ a
11:37:19 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
11:37:37 <Peaker> gnuvince_: well, if its your first FFI attempt - maybe there are unexplored avenues for simplification? or the barriers are mainly ones of knowledge, rather than inherent difficulty?
11:38:07 <ddarius> Implementing a library is usually harder than using it.
11:38:16 <trofi> @redo m1 `ap` m2 `ap` m3
11:38:16 <lambdabot> m1 `ap` m2 `ap` m3
11:38:21 <newsham> ddarius: when done right.
11:38:32 <newsham> when done wrong the opposite can be true
11:38:55 <conal> especially the library aims at ease of use.
11:39:01 <ddarius> newsham: And then you reinvent the wheel.
11:39:07 <Mr_Giraffe> :t ($=)
11:39:07 <ski>   mabc `ap` ma `ap` mb = do abc <- mabc; a <- ma; b <- mb; return (abc a b)
11:39:08 <lambdabot> Not in scope: `$='
11:39:16 <Mr_Giraffe> is $= specifically an openGL thing?
11:39:27 <Mr_Giraffe> and if so, uh...what is it for?
11:39:29 <Mr_Giraffe> :t (=)
11:39:30 <lambdabot> parse error on input `='
11:39:43 <conal> Mr_Giraffe: yes.  for setting various pieces of  opengl state
11:39:49 <ddarius> Mr_Giraffe: It's an HOpenGL thing, but it's basically just a synonym for writeIORef
11:39:50 <trofi> @hoogle ($=)
11:39:50 <lambdabot> No results found
11:39:52 <ski> @index $=
11:39:52 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
11:40:03 <Mr_Giraffe> ahh, alright
11:40:04 <Mr_Giraffe> thanks!
11:40:21 <trofi> @help index
11:40:21 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
11:40:22 <conal> Mr_Giraffe: opengl has tons of state.  much of it is deprecated in opengl3, i hear.
11:40:25 <Peaker> How do I restrict quickcheck inputs to pass some predicate? For example, only positive inputs?
11:40:32 <ski> @index x
11:40:32 <lambdabot> bzzt
11:40:37 <Heffalump> Peaker: ==>
11:40:41 <Peaker> Heffalump: thanks
11:40:49 <Heffalump> or forAll if you have problems getting enough valid inputs
11:40:57 <ski> @check False ==> False
11:40:58 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:40:58 <lambdabot>           ...
11:41:01 <rovar> how do I convert a bool to a Word8?  Currently for a Binary instance I have :
11:41:03 <rovar> data BSONValue = BDouble Double
11:41:05 <rovar>                | BString ByteString
11:41:06 <rovar>                | BBool Bool
11:41:08 <rovar>                | BDate DateTime
11:41:09 <rovar>                | BInt Int
11:41:11 <rovar>                | BCode ByteString
11:41:12 <rovar>                | BRegEx ByteString
11:41:14 <rovar>                | BNull
11:41:15 <rovar>                | BArray [BSONValue]
11:41:17 <rovar>                | BObject [(ByteString, BSONValue)]
11:41:18 <rovar>                deriving(Eq, Show, Ord)
11:41:20 <Mr_Giraffe> mutable stuff in haskell makes me a little sad :(
11:41:20 <rovar> goddammit.. sorry
11:41:23 <conal> rovar: fromIntegral.fromEnum
11:41:26 <Mr_Giraffe> rovar: nice :P
11:41:30 <conal> @type fromIntegral.fromEnum
11:41:31 <lambdabot> forall b a. (Enum a, Num b) => a -> b
11:41:42 <ddarius> rovar: if b then whateverYouWantTrueToBe else whateverYouWantFalseToBe
11:41:42 <vixey> Mr_Giraffe: yeah and the excessive use of unsafe functions today
11:41:44 <conal> i got that trick from ivan tomac.
11:42:07 <newsham> rovar: bool2Word8 False = 0; bool2Word8 True = 1
11:42:12 <rovar> ddarius, that's what I have currently.. it's kind of ugly
11:42:25 <conal> rovar: give fromIntegral.fromEnum a try.
11:42:30 <rovar> sure thing
11:42:40 <conal> rovar: it's a nice general solution that works for similar situations.
11:43:09 <ddarius> If we had bool t f True = t; bool t f False = f; it would just be bool 1 0 or whatever.
11:43:23 <conal> yeah.  that's a nice one also.
11:43:26 <newsham> we should have that :(
11:43:35 <conal> indeed!
11:43:41 <ski> @src Bool
11:43:41 <lambdabot> data Bool = False | True deriving (Eq, Ord)
11:43:42 <newsham> I think haskell should generate those functions automatically for every data decl
11:43:54 <ski> the `False' case should come before the `True' one
11:44:20 <solidsnack> ski: Why?
11:44:27 <trofi> Enum
11:44:42 <ski> solidsnack : see that `data' definition just above .. ?
11:44:43 <ehird> 3.14 :: CReal
11:44:46 <solidsnack> oh
11:44:47 <trofi> @rc Ord
11:44:47 <lambdabot> Not enough privileges
11:44:51 <ehird> > (3.14 :: CReal)
11:44:52 <lambdabot>   3.14
11:44:53 <ehird> > (3.14 :: CReal) == (3.14 :: CReal)
11:44:54 <trofi> @src Ord
11:44:54 <lambdabot> class  (Eq a) => Ord a  where
11:44:54 <lambdabot>     compare      :: a -> a -> Ordering
11:44:54 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:44:54 <lambdabot>     max, min         :: a -> a -> a
11:44:55 <lambdabot>   True
11:45:01 <solidsnack> ski: Misunderstood what you were referring to.
11:45:21 <p_l> lol @ "New peak in #haskell@freenode : 666"
11:45:29 <solidsnack> ski: Er, wait, no.
11:45:41 <newsham> why not generate both data constructors and data deconstructors at the same time?
11:45:47 <ddarius> p_l: The current high (to my knowledge) is 699
11:45:54 <trofi> @users
11:45:54 <lambdabot> Maximum users seen in #haskell: 667, currently: 665 (99.7%), active: 34 (5.1%)
11:46:07 <solidsnack>  You're saying, the cases in the function definition should follow the order of the cases in the data declaration?
11:46:21 <yitz> @pl boolToWord8 x = if x then 1 else 0
11:46:21 <lambdabot> boolToWord8 = flip (flip if' 1) 0
11:47:13 <newsham> solidsnack: yes.   data Foo = Bar | Baz Int | Bum Char Char  =>  unFoo f g h Bar = f; unFoo f g h (Baz x) = g x; unFood (Bum x y) = h x y
11:47:23 <ski> solidsnack : do you have another proposition for a generic ordering, for automatically generated (or ones that could have been that) casing functions
11:47:27 <ski> ?
11:48:04 <rovar> yitz: yea, the problem is that I'm using this in the Binary monad, so it would be if x then put (1 :: Word8) else put (0 :: Word8)
11:48:10 <newsham> btw, Data.Derive can derive those functions for you using TH
11:48:45 <yitz> @pl boolToWord8 x = if x then put (1::Word8) else put (0::Word8)
11:48:46 <lambdabot> boolToWord8 = flip (flip if' (put (1 :: Word8))) (put (0 :: Word8))
11:49:05 <yitz> rovar: don't use that
11:49:12 <rovar> i'm not going to
11:49:18 <yitz> :)
11:49:20 <newsham> rovar:  putWord8 would fix the type to Word8
11:49:21 <conal> @type  \ t e -> ($ t).($ e).if'
11:49:22 <lambdabot> Not in scope: `if''
11:49:58 <rovar> there is a putWord8 ?
11:50:06 <newsham> yes, in Data.Binary.Put
11:50:48 <newsham> also things like putWord32be
11:50:50 <rovar> oh well. I like the fromIntegral . fromEnum idea, i made a boolToWord8 Function that uses that.
11:51:26 <newsham> why not   enumToNum = fromIntegral . fromEnum   ?
11:51:31 <conal> rovar: i mostly like that trick also.   the part i'm squeamish about is its implicit dependence on False<True.
11:51:32 <newsham> then   putWord8 . enumToNum
11:52:03 <newsham> conal: when defining protocol, explicitly naming enum vals is superior.
11:52:22 <rovar> newsham: I'll break it down as such if I need to. But that won't be necessary in the scope of this module. I'm just converting the types i accidentally posted above to Binary :)
11:52:36 <conal> newsham: which flavor of superior?
11:52:39 <Peaker> newsham: most of the protocols should be RPC's, instead
11:52:44 <newsham> rovar: when defining generic functions, its useful to keep them generic for later possible use
11:53:14 <newsham> conal: I dont know how to answer that :)
11:53:29 <mije> what's the difference between mtl and transformers ? sometimes both are needed, sometimes they overlap...
11:53:30 <conal> newsham: i don't know what "superior" means without a flavor.
11:54:13 <ddarius> newsham: I believe he's saying, "superior on what axes"
11:54:20 <newsham> conal: closer distance between code and specification.
11:54:56 <conal> newsham: thanks.  that helps me a bit.  how does naming enum values reduce that distance?
11:55:15 <newsham> I recommend:   putEnum putWord8 unBool $ ENUM 0 False :| ENUM 1 True :| ENDENUM
11:55:24 <Heffalump> mije: transformers is an attempt to refactor mtl to be more modular
11:55:28 <newsham> conal: because it makes it explicit what the encoding of each enum value is.
11:55:31 <newsham> rather than implicit
11:55:34 <Heffalump> (there are other packages you build on top of transformers to get the same functionality as mtl)
11:55:41 <newsham> according to some language-specific convention
11:55:45 <mije> ok thanks
11:55:52 <Heffalump> but it's not quite clear what the migration strategy is or even if there is one. I just asked about it on the libraries@ mailing list.
11:55:54 <conal> newsham: ints are enums.
11:56:02 <Heffalump> And someone else asked a similar question on haskell-cafe.
11:56:14 * ddarius agrees that in this case the encoding should be explicit, hence him suggesting using and 'if'
11:56:58 <newsham> consider query types in DNS.  data Query = A | NS | MD | MF | ... | AAAA | AXFR | MAILB
11:56:59 <mightybyte> Is there a way to unregister all packages in either user or global with ghc-pkg?
11:57:03 <mije> thanks for the info
11:57:29 <newsham> A, NS, MD = 0,1,2   but  AAAA is out of order at 28, and AXFR is 252!
11:57:30 <mije> maybe these informations should be made more easy to find
11:57:48 <newsham> the mapping between a protocol's value and how you define it in haskell are not necessarily linear
11:57:54 <idnar> newsham: hopefully you would never use a "closed" enumeration like that
11:57:54 <conal> isn't fromEnum itself a tight, unambiguous specification of the encoding?
11:58:12 <idnar> since DNS record types are explicitly extensible
11:58:50 <newsham> conal: I think a specification should have as little implicit convention as possible.  it should be readable by people who arent necessarily well versed in a particular language's conventions
11:59:51 <conal> newsham: you're separating "specification" from other uterances in the language?
12:00:06 <conal> *utterances*
12:00:27 <newsham> conal: I'm separating protocols, yes.  protocols are where custom implementation meets public agreed-upon standard.
12:00:37 <newsham> and are notoriously easy to get wrong
12:01:15 <conal> newsham: and you want your haskell code to be the protocol documentation, friendly to non-haskellers?
12:01:24 <newsham> conal: yes! as much as is possible.
12:01:39 <conal> newsham: thanks.  now i get where you're coming from.  makes sense to me.  :)
12:01:47 <newsham> thats why I use haskell, it is semantically high level.  coding can be very close to a specification
12:01:57 <Peaker> @pl \x r -> x + 10*r
12:01:58 <lambdabot> (. (10 *)) . (+)
12:02:04 <conal> newsham: me too.
12:03:22 <conal> newsham: there's perhaps an unfortunate consequence of your reasoning: your protocol specification (sub)language cannot be very powerful (composable, nicely typed, higher-order, ...).
12:03:36 <conal> since your customers would be perplexed.
12:03:40 <rovar> so if I want to write a 64 bit number to a binary stream meant to be used by C++, should I send a Word64, or a Foreign.C.Type CULLong ?
12:04:07 <newsham> conal: I dont agree.  If done right you can make combinators that match well known protocol constructs and work easily with your data
12:04:49 <conal> newsham: i suspect we do agree.  that well-known-ness means they won't exploit some very powerful capabilities.
12:05:15 <conal> newsham: it can be clean, simply-typed, and first-order.  that sort of thing.  simple & clean.
12:05:24 <newsham> I didnt say simply-typed :)
12:05:28 <conal> newsham: not mind-blowingly powerful.
12:05:39 <newsham> anyway, I think you can have something that is easy to read, but it may be more complex to write/debug.
12:05:41 <vixey> first order ? noooo
12:05:50 <newsham> to give you an idea of what I mean, see http://www.thenewsh.com/~newsham/x/machine/marsh/
12:05:51 <conal> newsham: you said "readable by people who arent necessarily well versed ..."
12:05:53 <newsham> still a work in progress.
12:06:13 <newsham> conal: yes, I believe my spec's are readable, but definitely not simply-typed
12:06:42 <conal> newsham: example?  (i suspect a communication glitch)
12:06:52 <newsham> examples in url above
12:07:26 <conal> newsham: thx.  missed it.
12:07:52 <conal> newsham: what in particular?
12:08:20 <newsham> the types for almost all of the combinators I'm using are very complex.  but the specifications you build with them are quite simple to read
12:08:42 <newsham> for example the defn of mTest in testEnum.hs
12:09:15 <conal> newsham: thanks.  that did clear up for me what you meant.
12:09:42 <Bacta> SEX!
12:10:27 <LeoD> what's that
12:10:30 <solidsnack> Bacta: Go to #haskell-blah, please.
12:10:53 <Bacta> ok :D
12:10:55 <rovar> i guess my question is: do I need to worry about boxed types when I'm putting to Binary?
12:12:09 <ddarius> rovar: "Boxing" is an implementation detail.
12:12:49 <tibbe> dons: ping
12:13:12 <rovar> ddarius: yea, but I'm writing to a binary stream meant to be read by C++, and I don't think it shares Haskell's philosophy in that matter
12:13:55 <ddarius> rovar: A byte stream is a byte stream.  You are not rendering the actual in-memory representation to that byte stream.
12:13:58 <solidsnack> I think binary does some weird stuff to the data, actually.
12:14:25 <solidsnack> There is this header and such.
12:14:30 <mightybyte> Is there a way to get cabal-install to give you a list of all packages that will be installed for a given cabal install command?
12:14:49 <solidsnack> rovar: However, there is no reason to worry about boxed or unboxed showing up in the serialization.
12:14:51 <dcoutts_> mightybyte: --dry-run
12:14:54 <kalo2> iii
12:15:02 <mightybyte> dcoutts_: Thanks
12:15:15 <dcoutts_> mightybyte: see the --help output
12:15:50 <ddarius> The Binary class uses a custom format which is only meant to be readable by the same Binary instance (albeit independently of implementation)
12:15:59 <solidsnack> A datatype has one Binary implementation, which operates on it the same way whether it is boxed or not.
12:16:04 <ddarius> If you want a specific format, don't use the Binary class.
12:16:11 <solidsnack> Aye.
12:16:18 <solidsnack> Just thought I should warn rovar.
12:16:19 <mightybyte> dcoutts_: Yeah, I was looking in the wrong place.  Thought it would be a top-level command.
12:16:25 <rovar> solidsnack: I'm trying to conform to a specific, predetermined wire protocol, does this mean Binary is a bad choice because it adds some additional stuff under the hood?
12:16:28 * mightybyte feels stupid
12:16:39 <solidsnack> rovar: Binary is a bad choice, yes.
12:16:49 <ddarius> rovar: The Binary class would be wrong, using the functions in Data.Binary.Get/Put would be right.
12:16:52 <solidsnack> rovar: You should write your own class.
12:16:53 <newsham> rovar: the Binary instance is.  you can still use Data.Binary.Put and Data.Binary.Get
12:17:16 <solidsnack> rovar: Yeah, Data.Binary has functions that will be helpful to you.
12:17:20 <newsham> bbl
12:17:21 <rovar> i see.
12:18:11 <kalo3> Enter text here...
12:18:18 <solidsnack> The thing I thought Binary was is basically "format for MMAP". That's Storable, though.
12:18:20 <kalo3> hi
12:18:26 <kalo3> hi
12:18:27 <solidsnack> kalo3: Hello.
12:18:28 <kalo3> hi
12:18:30 <vixey> hi
12:18:37 <solidsnack> kalo3: You are on the internet.
12:18:58 <rovar> I have my higher level class which will convert complex types to and from BSON Objects, but was hoping to keep that separate from a lower level class that converts BSon objects to and from binary
12:19:02 <kalo3> 0131 mhere
12:20:06 <ImInYourMonad> oes haskell have sin^(-1)
12:20:07 <ImInYourMonad> ?
12:20:18 <ddarius> :t asin
12:20:19 <lambdabot> forall a. (Floating a) => a -> a
12:20:24 <JsutiN> Hey guys, what's the official resolution to a module conflict?  " Could not find module `Control.Monad.Writer': it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2"
12:20:45 <ddarius> JsutiN: Hide the package you don't want.
12:20:52 <olsner> or (recip . sin) :P
12:21:30 <JsutiN> How do I know which one's better?  I assume one got pulled in with yi that's conflicting with the other.
12:22:03 <ddarius> JsutiN: It's not a matter of "better", it's the one you need/want v. the one you don't.
12:23:04 <JsutiN> ddarius, of course.  However, how do I know that the conjugate of the intersections of the modules is not empty?  I could need both.
12:23:19 <ImInYourMonad> angle a b = atan $ a / b, so do I get radians there?
12:23:24 <ddarius> JsutiN: If you need both, you're screwed.
12:23:27 <solidsnack> rovar: BSON ?
12:23:32 <ski> @type atan2
12:23:33 <lambdabot> forall a. (RealFloat a) => a -> a -> a
12:24:24 <ski> ImInYourMonad : use `atan2', not `atan' with `(/)'
12:24:41 <ImInYourMonad> ok
12:24:42 <ski> (that way, your `b' may be zero)
12:24:56 <ImInYourMonad> and the answer is the angle in radians?
12:25:12 <ski> (i forget the order of the parameter roles to `atan2')
12:25:16 <ImInYourMonad> vn of ghc to have so many mathfucntions
12:25:16 <ski> presumably, yes
12:25:26 <ddarius> ski: I'm pretty sure it's y x
12:25:53 <mjonsson> > atan 1 0
12:25:54 <lambdabot>       No instance for (Floating (t -> a))
12:25:54 <lambdabot>        arising from a use of `atan'...
12:25:58 <mjonsson> > atan2 1 0
12:25:59 <lambdabot>   1.5707963267948966
12:26:10 <mjonsson> looks like radians and y x order
12:30:48 <ImInYourMonad> atan (y-axis/x-axis) you mean?
12:33:59 <ImInYourMonad> and this is correct right?
12:33:59 <ImInYourMonad> > let degrees r = r * 180 / pi in degrees 3
12:34:00 <lambdabot>   171.88733853924697
12:36:40 <JsutiN> ddarius, okay I hid monads-fd since I think that was the new one.  Everything seems to work.
12:36:41 <Baughn> Has anyone tried to make an Applicative instance for Data.Map?
12:37:09 <JsutiN> ddarius, any reason there are conflicting packages in Hackage and/or any reason why cabal doesn't inform you of conflicts?
12:37:23 <pumpkin> Baughn: I imagine you can do something similar to the rmonad approach? How would the applicative behave though?
12:37:54 <ddarius> JsutiN: monads-fd is meant as a replacement for mtl (more or less).
12:37:58 <Baughn> pumpkin: Hm. I suppose, the most natural would be to start with a set-intersection - ignore any keys that don't exist in both maps
12:38:44 <JsutiN> ddarius, I also had to hide transformers.
12:44:12 <tehgeekmeister> has anyone here learned haskell as their first programming language?  if so how difficult did you find it to be?
12:44:53 <dons> it was my first language
12:45:05 <dons> seemed obvious after high school math
12:45:30 <ddarius> dons was a late-bloomer.
12:45:48 <amz> hrmm, is the syntax colouring of http://learnyouahaskell.com/ artificial, or is there any text editor that follows that?
12:45:53 <amz> It's so pretty :D
12:46:20 <tehgeekmeister> amz: oh wow, it is pretty.
12:46:27 <mle> might be interesting to have studies with Haskell and children, sorta like the Logo experiments.
12:46:31 <ddarius> amz: Looks like a potential vim default.
12:46:37 <ddarius> s/default/pre-define
12:46:39 <JsutiN> dons, seriously?  No wonder you're at the forefront of haskell promotion.
12:46:48 <rovar> i'm sure you can convert the css into a vim colorscheme :)
12:47:00 <JsutiN> Also dons, the newer yi looks great.
12:47:13 * amz pokes BONUS
12:48:17 <tehgeekmeister> see, i'm about to start a web app project, and i am worried that if i use happstack/haskell, i will be alienating various friends who were willing to learn python/django to help out with the project, but are scared by haskell.  also, while i love haskell, i have a hell of a time making code that runs decent in it.  haskell's made me smart enough to reason about strict, imperative code, but i don't always understand haskell pe
12:48:42 <amz> got cut at " but i don't always understand haskell pe"
12:49:06 <vixey> idfy ou want to use haskell do so
12:49:08 <vixey> teach them it
12:49:28 <rovar> i have a hard time convincing people to use haskell.
12:49:47 <tehgeekmeister> amz: but i don't always understand haskell performance issues yet.
12:49:53 <rovar> i show them all this cool stuff and they say "wow, this is really cool" then don't do anything
12:50:06 <amz> I think that Haskell syntax isn't particularly hard (at least, so far), but engineering something complex in Haskell is still something that I can't get my head around
12:50:08 <mle> rovar: that happens with most things...
12:50:28 <olsner> evangelism is hard, etc
12:50:36 <tehgeekmeister> haskell syntax is pretty nice and easy, but getting over the hump with monads etcetera is a bit meh
12:50:44 <amz> for example, I'm a game developer, and Haskell looks so WRONG for games, yet I feel tempted to try it anyway
12:50:48 <Baughn> amz: Haskell syntax is nice for people, but it's horrid for editors. Seriously, it's very nearly ambiguous even when *compilable*.
12:50:50 <amz> just because I could be completely wrong
12:50:52 <mle> amz: I found things made much more sense as a cohesive-whole after reading the STG machine paper
12:51:09 <amz> Baughn: so it suffers from the C++ syndrome? Also, how do you even debug Haskell code?
12:51:15 <JsutiN> tehgeekmeister, I can sympathize with your plight.  Doing simple things in Haskell is easy, but understanding the abstraction layers for large programs can be very tricky and require a lot of knowledge about how the compiler works.
12:51:18 <Baughn> amz: And considering the proliferation of Lua in newer games, I don't think using Haskell for scripting-type stuff would be an issue
12:51:24 <amz> STG machine paper, you say?
12:51:33 <mle> fetching an url...
12:51:36 <Baughn> amz: You don't. Haskell programs run without error the first time they compile.
12:51:42 <amz> Baughn: I mean writing the ENTIRE game in Haskell
12:51:47 <tehgeekmeister> JsutiN: it can yeah.  more of it is just figuring out laziness.
12:51:51 <amz> Baughn: unless your algorithm is flawed ;)
12:51:53 <Baughn> amz: ..more seriously, debugging haskell is still a work in progress, though there are very good tools already
12:51:56 <amz> which was my case yesterday
12:52:02 <Baughn> Um, hang on, let me find this blog post..
12:52:18 <amz> I'm going through the Project Euler problems in Haskell
12:52:23 <vixey> yeah I'd rather do the hole thing in Haskell
12:52:23 <mle> amz http://research.microsoft.com/copyright/accept.asp?path=/users/simonpj/papers/spineless-tagless-gmachine.ps.gz&pub=34
12:52:27 <amz> it's a very good exercise
12:52:29 <tehgeekmeister> i think part of it is that many people can make a mental model of the program doing this and then that and then the next thing, and how it modifies the data step by step, whereas haskell is really a mathematical approach;; order isn't necessarily important.
12:52:32 <vixey> C + lua works but C + Haskell seems horrible
12:52:40 <amz> C in general is a tragedy
12:52:46 <amz> the game industry is almost 100% C++
12:52:59 <idnar> which is also a tragedy
12:53:02 <amz> (which, while arguably still a tragedy, a much lesser tragedy)
12:53:04 <mle> c was a step forward.  It gave us portable vax assembly.
12:53:06 <idnar> heh.
12:53:15 <tehgeekmeister> is there a decent bridge between python and haskell?  i'm aware of missingpy but can't find any info about how stable it is
12:53:15 <bremner> mle: PDP-11
12:53:30 <amz> C++ is only my programming language of choice because it's the only one I know that really satisfies my requirements
12:53:36 <amz> for abstraction and performance
12:53:42 <amz> I'm hoping that Haskell will beat it there
12:53:45 <amz> but it's a hard road :)
12:53:57 <wli> I don't know. PL/I is probably closer to PDP-11 than C.
12:54:30 * bremner has programming in C, PDP-11, and PL/I and begs to differ
12:54:36 <bremner> programmed even
12:54:41 <Baughn> amz: http://raintown.org/?page_id=132 <-- Looks nice, eh?
12:54:54 <p_l> wli: PL/I was rather for machine like S/360 or PDP-10 :-)
12:54:56 <amz> mle, that link is broken
12:55:00 <wli> bremner: C doesn't have segment qualifiers for variables.
12:55:52 <bremner> wli: the PDP-11 does? I don't remember that. It was 20+ years ago, so...
12:56:07 * amz knows C, C++ and Java pretty well, and some Python, Lua, Pascal, PHP, x86 Assembly, Javascript and, of course, Haskell...
12:56:13 <amz> but I don't like dynamic typed languages
12:56:14 <p_l> afaik base PDP-11 didn't have segments...
12:56:15 <amz> and I hate C
12:56:15 <wli> bremner: Yeah, the PDP-11 had segments, but they were just the top few bits of addresses.
12:56:25 <amz> so C++ and Java are the only languages I know that I consider to be even remotely usable
12:56:25 <mle> eep
12:56:31 <amz> until I learn Haskell properly, that is.
12:56:33 <p_l> there was an addon board to give certain models a high/low moby segmentation
12:56:37 <erikc> amz: (im also a game dev), haskell (with its current implementations) is not suitable for the runtime portion of a game, but i use it for building pipeline components with great results
12:56:54 <amz> erikc: thoughts on Scala?
12:56:55 <wli> bremner: You could almost treat it as flat except for some system-level things I don't know/remember the details of.
12:57:11 <amz> Scala seems interesting because you can mix imperative/oo and functional
12:57:17 <amz> but it does run inside the JVM
12:57:26 <mle> amz: http://www.accela.net/emily/spineless-tagless-gmachine.ps.gz
12:57:29 <erikc> dont have an opinion on scala, havent looked at it significantly
12:57:53 <amz> thanks, mle
12:58:35 <Mr_Giraffe> wow
12:58:37 <raji> you have n buckets of different capacity and m holes (m>=n),each hole leaks at 1 litre/sec.
12:58:37 <raji> what is the minimal time T so that all the buckes are empty.example n=3 { 10,6,2  } m={9}, ans=2. holes={5,3,1 }. how do we solve this without linear programming?. n is huge like 10^4.For n=3 { 10,6,2} m={8} , T>=2.25 but actual answer is 2.5 by { 4,3,1}
12:58:40 <Mr_Giraffe> openGL in haskell is...surprisingly easy!
12:58:41 <wli> bremner: C is basically a flat treatment of it. Other things delved into segments for whatever reason.
12:59:03 <bremner> wli: they missed Multics :-)
12:59:26 <wli> bremner: Or came from it / inherited from it.
12:59:58 <dons> ddarius: well, to be fair, i did some basic, modula-2 and m68k in high school. but haskell was the first serious lang
13:00:02 <erikc> amz: i do think there a niche for a haskell implementation oriented towards portability + C integration that could replace Lua though
13:00:30 <Baughn> I see no particular reason not to use haskell for games. GC pauses are rarely long enough to cause any sort of stuttering..
13:00:49 <tehgeekmeister> hmm, are there any tutorials that assume you are STARTING with haskell?  it seems everything i'm finding assumes you already know how to program.
13:00:52 <amz> erikc: funny that you mention that... I develop a (free/oss) program that uses Lua (and experimentally Ruby/Perl) as a scripting language
13:00:56 <amz> and I wanted to give it Haskell support as well
13:01:03 <amz> but I couldn't find any sane ways to do it
13:01:17 <Baughn> tehgeekmeister: Not really, but you could combine one with SICP for that approximate effect
13:01:18 <amz> Baughn: I think that the problem is that games involve massive change of state
13:01:26 <Baughn> amz: Nah, they don't /need/ to do that
13:01:27 <amz> and are generally very CPU intensive, so they often require tight optimizations
13:01:32 <Mr_Giraffe> amz: this is true
13:02:10 <pejo> amz, the reason they involve massive change of state is that they're written in imperative languages
13:02:18 <amz> I recently implemented a Physics engine in Java, and it was pretty much functional.. THAT sort of stuff could work in Haskell
13:02:23 <amz> but for game logic in general, I don't know...
13:02:29 <Baughn> amz: There's another way to structure them. If you derive next-state from last-state, you can do without any mutation. Parallelism gets easier, too
13:02:40 <Mr_Giraffe> however, there's another way to look at them really
13:02:42 <amz> It could just be my lack of experience, but it does seem fairly difficult
13:02:44 <Mr_Giraffe> Baughn is right
13:02:53 <amz> yes, I figured that much out
13:02:59 <erikc> Baughn: the issues are all practical, my particular problems being ease of porting to embedded platforms and teaching haskell to game scripters, who are typically non-programmers
13:03:10 <Mr_Giraffe> i've actually done a little work with this, albeit in scheme
13:03:34 <Mr_Giraffe> essentially if you look at a world or environment holistically (or even a piece of it, whatever your choice may be)
13:03:47 <Mr_Giraffe> you can sort of pass the world along to the next "state" without mutation
13:03:49 <gnuvince_> Why is it that when I let Haskell infer a type declaration for a function, all is dandy, but when I copy this declaration in the code, I get an ambiguous type variable error?
13:04:10 <Mr_Giraffe> and if you think that's a bit ridiculous, look up the many-worlds interpretation of quantum physics :P
13:04:10 <ddarius> I haven't read HSOE, but I suspect that it doesn't require previous programming knowledge.
13:04:14 <tehgeekmeister> marmolak: it assumes you know how to program
13:04:17 <Baughn> erikc: So *that's* why game scripts are usually so horrible...
13:04:30 <amz> Mr_Giraffe: I have no problem with the concept, only with how it'd execute in practice
13:04:41 <Mr_Giraffe> amz: it's really not so bad...i'm sure haskell can optimize it
13:05:00 <amz> well, could it even reuse the old state instead of copying everything on every update?
13:05:08 <Baughn> amz: Typical haskell data structures are made so you can switch out just one part, and anything that doesn't change will point to the last one
13:05:09 <vixey> How can an experienced programmer write for someone with no programming exp.?
13:05:16 <amz> I mean, consider a system with tens of thousands of particles
13:05:20 <Mr_Giraffe> Baughn took the words out of my uh...fingertips
13:05:22 <Baughn> amz: That's an important design point for any persistent data structure, but mostly done for you at this point
13:05:23 <amz> and you need to check collisions between them
13:05:32 <Baughn> Well, you should be doing that on a GPU
13:05:38 <Baughn> With physx or something
13:05:45 <ddarius> ViaToR_SG: A lot better than someone with no programming experience can write for someone with no programming experience.
13:05:47 <erikc> vixey: ?
13:05:52 <ddarius> vixey
13:06:16 <Mr_Giraffe> who here is interested in group learning, btw? i'm starting on a project and i'm trying to think best of how to "haskellify" it
13:06:16 <ehird> is data parallel haskell included in ghc?
13:06:20 <amz> Baughn: in games, however, it's my experience that pretty much everything will change at every step
13:06:22 <ehird> ah yes
13:06:33 <ehird> can't see how to enable it though
13:06:37 <ehird> oh
13:06:39 <ehird> theere
13:06:40 <Baughn> ehird: Not the latest work, of course, but some of it is in 6.10
13:06:47 <Baughn> Read the changelog properly. :P
13:06:52 <ehird> :-)
13:06:58 <Mr_Giraffe> amz: it seems like you have the idea in your head that haskell data structures, when passed into other functions, completely copy themselves over
13:07:03 <Mr_Giraffe> amz: lemme show you something :P
13:07:29 <Mr_Giraffe> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=gcc&box=1 you'll have to forgive the pidigits one
13:07:32 <ehird> WOW, dph errors are ugly
13:07:34 <Baughn> amz: Even if that /is/ the case, it wouldn't be a major problem. Haskell programs can allocate tens of gigabytes per second without issues.
13:07:58 <amz> Mr_Giraffe: I'm well aware of those benchmarks ;)
13:07:59 <Mr_Giraffe> Haskell compiles to C, and it's optimized quite well
13:08:04 <Mr_Giraffe> amz: then what's the issue?
13:08:16 <idnar> actually, these days it compiles to native code
13:08:17 <amz> that none of them are like the stuff that happens in games
13:08:20 <Baughn> amz: It isn't, of course. Quite a lot of things won't change - art, for one thing, but it's also possible to do things like modelling a flying rocket not by where it is /this/ frame, but by where it started and how fast it's going
13:08:22 <Mr_Giraffe> idnar: really? wow.
13:08:28 <Mr_Giraffe> that's awesome
13:08:37 <Mr_Giraffe> Baughn is right!
13:08:46 <amz> Baughn: I'm talking about the game logic... not involving graphics, sound, or anything of the sort
13:09:00 <idnar> you can still use -fvia-c if you like, but the native code generator is the default now (if I'm not mistaken)
13:09:05 <Mr_Giraffe> amz: you're talking about how it's difficult to break out of state-based mentalities :P
13:09:06 <Baughn> amz: How much state are we talking about?
13:09:06 <amz> AI, updating positions, checking for collisions
13:09:15 <Mr_Giraffe> updating positions can be done without state
13:09:20 <Baughn> amz: Copying data is a *lot* cheaper in haskell than you're used to. malloc is *extensive*.
13:09:24 <Baughn> Er, expensive
13:09:26 <Mr_Giraffe> hahaha
13:09:30 <Mr_Giraffe> and extensive :P
13:09:37 <Mr_Giraffe> you weren't necessarily wrong!
13:09:39 <erikc> amz: you have a 'frame' data structure which is the state at frame n, and you create an endless stream of those
13:09:39 <idnar> and expansive
13:09:41 <idnar> ;)
13:09:41 <amz> yes, it is, which is why people use memory pools ;)
13:10:12 <ddarius> Not allocating at all is better than allocating at all.
13:10:21 <idnar> anyway, you can write stateful or "imperative" algorithms in Haskell if you really want to, so this all seems fairly irrelevant
13:10:30 <amz> well
13:10:34 <Mr_Giraffe> amz: you can envision a bunch of entities as a list (or something like that) and updating their positions as simply generating new positions
13:10:37 <amz> one day, I'll port one of my speedhack games to Haskell
13:10:39 <Baughn> amz: Right, but I'm sure you'll find that if you really /want/ to you can figure out ways not to mutate the data
13:10:44 <amz> so I get a better idea of how sane is this stuff
13:10:45 <vixey> it would be interesting to put substructural types into use
13:10:53 <vixey> for some kind of realtime things.. like games
13:11:01 <Mr_Giraffe> amz: it's all about flow
13:11:07 <idnar> if you can't find a way to express an algorithm functionally, you can just do it imperatively, you're not forced to give up on Haskell
13:11:18 <Mr_Giraffe> idnar: look out
13:11:27 <amz> Does anyone know of any good with examples of "how to port imperative/mutable algorithms into functional/immutable"?
13:11:27 <Mr_Giraffe> the ghosts of church and turing might have your head for that statement
13:11:29 <Baughn> amz: And if it ends up a little slower than mutation.. well, that's made up for by being able to easily parallelize your code
13:11:30 <amz> er
13:11:31 <amz> *good book
13:11:38 <idnar> Mr_Giraffe: well, you know what I mean :P
13:11:43 <Mr_Giraffe> hahaha i know
13:11:44 <Baughn> amz: Purely Functional Data Structures is the canonical one
13:11:57 <amz> I think that I have that on my Amazon wishlist
13:11:58 <Mr_Giraffe> amz: tao te ching
13:12:05 <Mr_Giraffe> think of the flow of the code
13:12:08 <idnar> as someone (I forget who) said, Haskell may be the best imperative programming language ever ;)
13:12:08 <Mr_Giraffe> and i'm only half-joking :P
13:12:15 <raji> does haskell memoize implicitly ?
13:12:22 <ehird> raji: not specified
13:12:23 <p_l> as for memory pools, isn't malloc usually done through mmaped memory pools anyway? :D
13:12:23 <vixey> raji, yes
13:12:24 <ehird> does ghc? no
13:12:29 <ehird> vixey: what
13:12:34 <ddarius> raji: No.
13:12:38 <raji> vixey, in that case it will be wasting lot of memory
13:12:44 <vixey> raji, what will?
13:12:45 <idnar> Ask a question in #haskell, get 5 different (and mutually exclusive) answers ;)
13:12:49 <raji> vixey, memoize
13:12:54 <Mr_Giraffe> i mean, am i wrong there? does programming functionally not lie significantly in structuring the flow as opposed to toggling states?
13:12:57 <vixey> raji, what?
13:13:06 <amz> eh, first google result is a pdf
13:13:10 <vixey> raji, you don't program in this way if you don't want to to do this
13:13:13 <amz> is that the full book, available for free?
13:13:15 <idnar> Mr_Giraffe: that's a stylistic issue
13:13:17 <dblick1> im still watching this, but so far this 1997 keynote talk by alan kay has been excellent; i think people interested in functional programming would enjoy it: http://video.google.com/videoplay?docid=-2950949730059754521
13:13:24 <mauke> amz: unlikely
13:13:34 <Mr_Giraffe> idnar: i mean in the broad sense, not specifically with haskell
13:13:34 <idnar> Mr_Giraffe: code written in an imperative style is generally all about /execution/ flow; code written in a functional style is generally all about /data/ flow
13:13:34 <amz> 162 pages, right author name
13:13:35 <pejo> amz, the book is a revised version of his dissertation
13:13:39 <amz> ah.
13:13:41 <Mr_Giraffe> idnar: right, right
13:13:52 <idnar> Mr_Giraffe: there's no underlying "true nature"
13:14:08 <ddarius> vixey: "memoization" means f 3 will store the result and then return the stored result next time f 3 is called.  While it is acceptable for a Haskell implementation to do this, none does.
13:14:13 <Mr_Giraffe> not for programming in general, i just meant how it seems like functional "feels" vs how imperative "feels"
13:14:20 <idnar> Mr_Giraffe: even if you go right down to the physical building blocks of the universe, you can still model things in functional or imperative styles
13:14:35 <Mr_Giraffe> well yeah :P
13:14:48 <raji> ddarius, python has something like @memo or something to memoize automatically
13:15:07 <ddarius> raji: Yes, there are combinators that you can use to memoize a function if you want.
13:15:21 <Mr_Giraffe> you know, i could never get into python...
13:15:42 <raji> ddarius, is it just reusing stored up results ?
13:15:55 <ddarius> raji: Is what that?
13:15:57 <mauke> yes, that's what "memoize" means
13:16:11 <raji> ddarius, i thought it would be doing something intelligent DP
13:16:18 <Mr_Giraffe> also idnar, have you read zen and the art of motorcycle maintenance?
13:16:30 <raji> like for fib(n) , only last 2 states are stored but if we memoize it stores the whole N values
13:17:01 <idnar> Mr_Giraffe: I haven't actually read it, but I must have seen half the book quoted by now
13:17:18 <Mr_Giraffe> idnar: you really should
13:17:25 <Mr_Giraffe> what you said about the universe is pretty much the whole premise of the book :P
13:17:48 <wli> O(lg(n)) steps via the duplication recurrences etc.
13:18:22 <vixey> ddarius: I rely on top level definitions acting like lazy lets.. that is values (such as infinite lists) being mutated instead of recomputed from scratch each time
13:18:49 <ddarius> vixey: That's not memoization any more than int x = 3 + 5; is in C.
13:19:05 <vixey> but .. that's assignment
13:19:44 <ddarius> That's a declaration.  In C++ there's even a difference.
13:19:56 <mauke> it's initialization
13:19:57 <solidsnack> idnar: It was Simon PJ who said "Haskell is, first and foremost, a functional language. Nevertheless, I think that it is also the worlds most beautiful imperative language.".
13:20:01 <ddarius> (Albeit not for 'int')
13:20:11 <idnar> solidsnack: ah, thanks
13:20:46 <trofi> > toUpper (`fmap` . `fmap`) (Just "hello")
13:20:47 <lambdabot>   <no location info>: parse error on input `.'
13:20:52 <trofi> > toUpper (`fmap`) (Just "hello")
13:20:53 <lambdabot>   <no location info>: parse error on input `)'
13:21:01 <Mr_Giraffe> so how many of you folks use xmonad?
13:21:05 <trofi> > toUpper `fmap` (Just "hello")
13:21:06 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
13:21:27 <glguy> vixey, memoization pertains to functions
13:21:35 <vixey> why glguy?
13:21:36 <ddarius> vixey: If you really want to you can view values as memoized functions () -> a.
13:21:41 <glguy> vixey, because that's what it is
13:21:49 <vixey> I don't know about that
13:22:00 <glguy> now you know to look
13:22:09 <vixey> what
13:22:37 <vixey> in wikipediat it says "In computing, memoization is an optimization technique used primarily to speed up computer programs by having function calls avoid repeating the calculation of results for previously-processed inputs."
13:22:45 <ehirdghost> What's the OPTIONS thing to unhide a package?
13:23:25 <tehgeekmeister> do i need to do cabal update before cabal upgrade?
13:23:28 <trofi> > (^2) `fmap` Just 3
13:23:30 <lambdabot>   Just 9
13:23:30 <tehgeekmeister> or does upgrade update for me?
13:23:37 <trofi> > (^2) `fmap` Just (Just 3)
13:23:38 <lambdabot>       No instance for (Num (Maybe t))
13:23:38 <lambdabot>        arising from a use of `^' at <in...
13:23:40 <vixey> so this term has come from the 60s
13:23:42 <gwern> don't think upgrade does update
13:23:46 <tehgeekmeister> okay
13:23:48 <vixey> Bletchley Park
13:23:49 <gwern> tehgeekmeister: but you know you shouldn't be using upgrade right
13:23:57 <tehgeekmeister> gwern: err nope
13:24:01 <tehgeekmeister> gwern: do now!
13:24:02 <trofi> @src fmap
13:24:02 <lambdabot> Source not found. Wrong!  You cheating scum!
13:24:10 <crem_> Why if I write "tail [1..] == tail [1..]" in ghci, it hangs? I thought it should return True, because of lazy evaluation.
13:24:19 <wli> When you declare a variable, you create a memo slot. The first time the variable's value is used, it gets computed and stored in the memo slot for the variable. Subsequent references just retrieve the already-computed value from the memo slot instead of recomputing it by checking whether it's already been computed.
13:24:45 <trofi> :t fmap
13:24:46 <gwern> tehgeekmeister: sometimes I think I shouldn't ask questions like that - whether you knew it or not, your answer would still be yes
13:24:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:24:47 <vixey> crem_: this program is the same as [2..] == [2..]
13:25:01 <wli> There are some subtleties involving partial forcing etc.
13:25:10 <tehgeekmeister> gwern: so what do you do instead?  reinstall each package?
13:25:23 <crem_> vixey, ok I agree, but don't understand why [2..] == [2..] hangs too
13:25:25 <ImInYourMonad> does haskell really compile to C? I thought ghc at least geenrated machinecode?
13:25:34 <ehirdghost> ImInYourMonad: it does both, like was said
13:25:37 <ehirdghost> -fvia-c enables c.
13:25:39 <gwern> tehgeekmeister: I do upgrade with dry-run, and I manually pick ones to reinstall
13:25:41 <vixey> crem_, it checks does 2 == 2 ? if yes then it checks if 3 == 3 if yes then .....
13:25:47 <gwern> I know to avoid any core or dangerous packages
13:25:59 <Eridius> via-c includes the EvilMangler :/
13:26:11 <defun> Hi, how would one go about writing a yaml parser in parsec. (aka how would one parse indentation to act as blocks of 'code')?
13:26:16 <ddarius> ImInYourMonad: Haskell is a language.  GHC can compile via C or not.  Hugs doesn't compile at all.  JHC/LHC compile to C.  NHC does something sort of like a bytecode interpreter.
13:26:17 <ImInYourMonad> how can isee the generated C-code?
13:26:24 <glguy> == is value equality, and not reference equality, and [2..] and [2..] are two different lists
13:26:38 <crem_> ok thanks
13:26:54 <gwern> defun: personally, I wouldn't - would use the hackage yaml libs
13:27:00 <gwern> just saying
13:27:00 <ddarius> crem_: If you want to understand such things, simply unfold the definitions and apply them.
13:27:03 <ehirdghost> Eridius: the evil mangler is hilarious
13:27:07 <ddarius> @src [] (==)
13:27:08 <lambdabot> []     == []     = True
13:27:08 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
13:27:08 <lambdabot> _      == _        = False
13:27:13 <ehirdghost> 20:26 glguy: == is value equality, and not reference equality, and [2..] and [2..] are two different lists
13:27:19 <ehirdghost> [2..] and [2..] are two different lists? what
13:27:34 <Eridius> defun: maybe you should develop bindings to libyaml instead of writing your own parser
13:27:34 <Eridius> ?
13:27:34 <Eridius> also, there's nothing special about whitespace in parsec. If you avoid lexeme, then you can treat whitespace as significant
13:27:34 <ehirdghost> I mean, it's obvious why [2..] == [2..] doesn't terminate, but
13:27:57 <crem_> ehirdghost, thanks, got it.
13:28:08 <ehirdghost> huh
13:28:09 <ehirdghost> ?
13:28:10 <defun> Is it that hard?
13:28:11 <crem_> or.. ddarius, thanks :)
13:28:13 <Eridius> glguy: what's interesting is that even if you have the same references it doesn't realize that
13:28:15 <gwern> ehirdghost: not so obvious actually, the first time I saw it I thought 'x == x, true by definition'
13:28:17 <Eridius> > let x = [2..] in x == x
13:28:32 <lambdabot>   thread killed
13:28:42 <Mr_Giraffe> hahahaha
13:28:58 <Cale> Even if they're the same list, it won't terminate, because == is defined to continue testing equality of the elements of the lists until it reaches the end.
13:29:19 <Eridius> gwern: last time I looked at hackage the only yaml on there was a reference parser and said it was not designed to be used as a real yaml library
13:29:27 <glguy> Eridius, "same reference" doesn't mean anything in this case
13:29:35 <Eridius> glguy: yes I understand why, I was just pointing that out
13:29:37 <tristes_tigres> hi
13:29:51 <tristes_tigres> what is this syntax ? instance BuildList a r => BuildList a (a->r) where ...
13:29:55 <ddarius> There is no -notion- of reference equality in Haskell, so there is no meaning to saying "the same list" except via observational or value equality.
13:30:09 <gwern> Eridius: really? iirc that yaml lib came from pugs and they had been using it for docs
13:30:13 <gwern> or something
13:30:15 <Cale> tristes_tigres: It's an instance declaration.
13:30:28 <tristes_tigres> Cale: I mran (a->r) part
13:30:33 <tristes_tigres> mean
13:30:37 <Cale> That's the type of functions from a to r
13:30:49 <tristes_tigres> oh that simple
13:30:52 <Eridius> gwern: I just looked again, there's a package YamlReference which is what I was talking about. it looks like there's a HsSync package too which I missed last time, which I think you're referring to
13:31:08 <Eridius> of course, Syck is now the "old" yaml library, libyaml is the "new" one, so it might be nice to have one based on that
13:31:24 <Eridius> or more specifically, Syck is YAML 1.0, libyaml is YAML 1.1
13:32:00 <Cale> tristes_tigres: It's saying that if there's an instance of BuildList for a and r, then there's an instance of BuildList for a and (a -> r)
13:33:02 <tristes_tigres> Cale: it's from http://okmij.org/ftp/Haskell/vararg-fn.lhs
13:33:08 <tristes_tigres> that guy is just too clever
13:33:36 <ddarius> tristes_tigres: That's a pretty old trick.
13:34:35 <Cale> tristes_tigres: In the class declaration, there's a functional dependency though, so that's not the same ->
13:34:35 <tristes_tigres> Can one teach a young dog  an old trick?
13:34:40 <Cale> > class BuildList a r  | r-> a where
13:34:41 <Cale> >     build' :: [a] -> a -> r
13:34:43 <lambdabot>   <no location info>: parse error on input `class'
13:34:43 <lambdabot>   Not in scope: `build''
13:34:54 <gwern> tristes_tigres: what other tricks are there?
13:34:57 <Cale> This means that the type r determines the type a uniquely
13:35:08 <tristes_tigres> Cale not the same -> as what ?
13:35:31 <Cale> "| r -> a"  is not the type constructor for functions.
13:35:44 <tristes_tigres> Cale: yes I realize that
13:35:49 <Cale> okay :)
13:36:37 <tristes_tigres> gwern: new ones, that you can't teach an old dog
13:37:30 <koeien> this is great. i spent 5 minutes adding `par` and `pseq` and now my program is three times faster!
13:37:44 <vixey> wow
13:38:00 <gwern> three? how many cores?
13:38:01 <koeien> well, maybe 10 minutes
13:38:15 <koeien> 4 cores, it seems that the program only uses 3 of them right now
13:38:18 <koeien> i need to do some tweaking
13:39:04 <koeien> it's a backtracking algorithm (with some clever tricks to minimize the branching)
13:39:22 <ddarius> @google proof-number search
13:39:24 <lambdabot> http://www.fdaw.unimaas.nl/education/4.2ZT/sheets/IST_pn_search.pdf
13:39:24 <lambdabot> Title: Intelligent Search Techniques Proof-Number Search
13:48:50 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2426#a2426 <- is that a correct way to normalize a vector?
13:51:04 <pumpkin> looks like it
13:51:10 <erikc> iminyourmonad: you might want to handle zero length vectors unless infinity is an ok domain
13:55:06 <rovar> erikc, i think a vector of 0 infinity values is acceptable :)
13:55:46 <erikc> :)
13:56:42 <erikc> the linear algebra lib i built at work has types for point, vector, nonzero vector and unit vector for this exact reason
13:57:48 <ddarius> Torsors, ho!
13:59:00 <wli> erikc: Is it polymorphic over the underlying field? What sorts of class constraints are there on the underlying field?
13:59:45 <pumpkin> wheat and corn only
13:59:52 <pumpkin> no barley
14:00:19 <wli> s/underlying/scalar/
14:00:22 <aeolist> humor has skyrocketed :P
14:00:39 <ddarius> Indeed, humor has left the building.
14:01:11 <erikc> wli: uhm no idea :), its just basic 3d linear algebra
14:01:32 <ddarius> erikc: Make it a 3D geometric algebra
14:02:00 <erikc> this is the part where i feel guilty and go read some math books
14:02:04 <dons> ?yow
14:02:05 <lambdabot> Wait ... is this a FUN THING or the END of LIFE in Petticoat Junction??
14:02:30 <Elly> EOL!?
14:02:39 <Elly> say it isn't so!
14:02:49 <erikc> wli: it just wraps sse/spu/vmx 4-way simd instructions, slots 0-3 are x,y,z, w slot is 1 for points, 0 for vectors
14:03:01 <erikc> so you can matrix multiply affine transforms  to translate points
14:03:20 <pumpkin> omg that is a fine transform
14:03:23 <vixey> like opengl
14:03:32 <ddarius> Okay, so you want a 4D geometric algebra.
14:03:47 <vixey> (x,y,z,w) means (x/w,y/w,z/w)
14:04:09 <erikc> and the functions preserve the constraints (e.g. you cant normalize a vector, only a nonzero vector, subtracting two points gives a vector) and choose better implemantations (if you project on a unit vector, it can be done faster cause you dont need to divide be length)
14:04:26 <erikc> implementations
14:04:40 <pumpkin> erikc: how do you deal with the fact  that subtracting two nonzero vectors can result in a zero vector, but you can still normalize that
14:04:58 <wli> Sounds Double only. No rational function fields themselves with base fields which are algebraic extensions of Q.
14:05:30 <erikc> pumpkin: cause subtracting nonzero vectors gives a vector, so you need to 'regenerate' the nonzero vector with the nonzero() function :)
14:06:29 <Peaker> erikc: nonzero() or nonzero function? :)
14:06:30 <pumpkin> aha
14:06:34 <rovar> I have a data type:  data BSONValue = Type1 | Type2 | etc
14:06:35 <pumpkin> nonzero0
14:06:37 <pumpkin> :P
14:07:25 <erikc> Peaker: i have a 'Maybe<NZVector> NonZero(Vector);' function
14:07:49 <erikc> then theres unsafe constructors for booting the whole type system out of the way if you know what you are doing
14:07:53 <Baughn> rovar: Okay..?
14:07:58 <Peaker> erikc: hey you have a Haskell library for C++ templates? :)
14:08:03 <rovar> i think i answered my own question :)
14:08:11 <pumpkin> lol
14:08:18 <erikc> i have a c++ library for haskell idioms
14:08:29 <Peaker> erikc: that's what I meant, yeah :)
14:08:33 <erikc> hehe, yes
14:08:41 <rovar> that's kind of the inverse of what you said :)
14:08:46 <ddarius> Maybe is a useful thing in any language.
14:09:00 <ddarius> C++ as an EDSL.
14:09:04 <rovar> sounds intriguing though.. I am forced to use c++ on a daily basis
14:10:37 <Peaker> C++ without classes could be nicer :)
14:11:08 <Peaker> existentials+type-classes would be much nicer than classes and virtual methods
14:11:36 <vixey> trying to improve C++ seems like a waste of time
14:11:47 <wli> Row types for variants are vastly underappreciated.
14:11:53 <erikc> i also have a whole family of higher order functions over statically bounded containers, e.g. template <T1, T2, N> array<T1, N> map(const array<T2, N>&, T1 (*)(const T2&));
14:11:53 <rovar> with concepts and intelligent template inheritance you can get typeclasses
14:11:57 <erikc> which looks like total gibberish
14:12:21 <rovar> erikc, you could use typelists to clean it up :)
14:13:42 <endojelly> anyone using agda?
14:13:58 <vixey> about half the people in #agda to
14:14:00 <vixey> do*
14:14:05 <endojelly> half? 8)
14:16:00 <wli> Hexadecimals are triggering lexical errors in comments?
14:16:33 <mauke> communist propaganda!
14:16:37 <LeoD> > 42 -- 0x123
14:16:38 <lambdabot>   42
14:17:44 <chessguy_> @users
14:17:44 <lambdabot> Maximum users seen in #haskell: 667, currently: 651 (97.6%), active: 25 (3.8%)
14:19:05 * SubStack thinks functional idioms would have fit in so much better with opengl from the start
14:19:23 <ddarius> SubStack: Quite likely.
14:19:28 <erikc> substack: oooo yes
14:20:08 <SubStack> pesky c
14:20:40 <mun> hi
14:20:41 <mun> if one is to unify x to a function application, e.g., foo(bar), will higher-order unification be needed?
14:20:56 <vixey> mun: huh....
14:20:57 <SubStack> the haskell glut bindings are certainly an improvement versus writing everything in c, but still seem very kludge
14:20:58 <wli> Yeah, it's puking on something in a verbatim environment.
14:22:50 <wli> #0xdeadbeef
14:23:10 <wli> Maybe # is special in a verbatim environment?
14:23:58 <romand> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1903#a1903
14:24:10 <romand> how can I divide Double by Int ?
14:24:27 <mauke> convert the Int to Double with fromIntegral
14:24:40 <romand> mauke: thanks!
14:25:20 <chessguy_> @quote fromintegral
14:25:21 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
14:26:04 * SubStack wishes fromIntegral were shorter
14:26:21 * Baughn sometimes spells it "coerce"
14:26:28 <wli> I wonder why ghc's barfing on these #'s
14:26:36 <chessguy_> cast?
14:27:12 <dons> {-# LANGUAGE MagicHash #-} ?
14:27:15 <Baughn> class Coerce where coerce :: a -> b
14:27:41 <wli> dons: It's in a verbatim environment outside any code block.
14:27:51 <chessguy_> you mean Coerce a b
14:27:57 <Baughn> Well, yes
14:28:16 <wli> It's at the beginning of a line, that's why.
14:28:21 <chessguy_> and it exists on hackage
14:28:34 <Baughn> Meh. Not invented here.
14:28:58 <chessguy_> I can't recall the name though
14:29:27 <chessguy_> cosmicray did it a few weeks ago
14:30:07 * wli gets annoyed with the C preprocessor hooks.
14:30:50 <tibbe> any windows users here who can confirm whether socket programming works without withSocketsDo?
14:31:08 <ImInYourMonad> how would you rep a Go-board? as an array or a Map?
14:31:31 <tromp_> array
14:32:21 <tromp_> unless you dont care about efficiency
14:32:38 <ImInYourMonad> hmm yeah i dont know how i thoguth Map would be efficient
14:32:40 <tromp_> then you can represent it as Point->Color
14:32:52 <ImInYourMonad> type Board = A.Array (Int, Int) Piece
14:32:55 <ImInYourMonad> is what  have
14:33:02 <ImInYourMonad> data Piece = White | Black | None deriving(Show)
14:33:03 <blackh> tibbe: I would not expect socket programming to work without withSocketsDo
14:33:09 <tromp_> Piece is strange name for what can be empty
14:33:12 <ImInYourMonad> yes
14:33:38 <tibbe> blackh: the thing is that I found some code in Network.Socket that does lazy initialization of WinSock
14:33:39 <ImInYourMonad> Square?
14:33:44 <tibbe> blackh: but that code looks broken
14:34:26 <tromp_> data Color = Empty | Stone Player deriving (Eq, Show)
14:34:27 <blackh> tibbe: Ah, OK - no - I can't answer that question.
14:34:36 <tibbe> blackh: ok, thanks anyway
14:34:38 <tromp_> is what i use
14:35:19 <wli> Maybe Bool anyone?
14:35:23 <ImInYourMonad> yeah that makes sense
14:35:31 <ImInYourMonad> maybe Alba?
14:35:37 <pumpkin> Maybe YourMonad
14:35:49 <tromp_> it's equivalent to Maybe Bool, but might as well give it nice names
14:36:21 <wli> Just True | Just False | Nothing, so Nothing corresponds to Empty, Just True corresponds to White or Stone White, Just False corresponds to Black or Stone Black.
14:36:22 <tromp_> i'd rather have players Black and White than players True and False
14:36:34 <pumpkin> yeah
14:37:01 <wli> The only reason I'd do it is so that library functions prepared to deal with True, False, and Maybe can be leveraged.
14:37:26 <chessguy_> dwfine white = True
14:37:45 <tromp_> that doesnt help when you show white:(
14:37:58 <wli> I might define variables, white = True, black = False, etc.
14:38:05 <tromp_> data Player = Black | White deriving (Eq, Show)
14:38:13 <wli> newtype with a custom show instance?
14:38:17 <tromp_> will show them as you want
14:38:34 <wli> newtype with custom Read and Show instances, even, I guess.
14:39:03 <ImInYourMonad> anyone know a good way to represent black | white | none in gtk2hs? I mean what kind of buttons would you use?
14:39:26 <wli> I forget if you can define projection functions a la records for newtypes.
14:40:14 <dcoutts> ImInYourMonad: you can put whatever content you like in the body of a button
14:40:18 <romand> faced with 'stack space overflow'... how can I profile the program?
14:41:17 <ddarius> romand: That likely indicates an error (or what I would consider an error).
14:42:05 <romand> can it be caused by using foldr on very large list?
14:42:23 <Baughn> romand: Depends. Do you use it to make a large or a small result?
14:43:02 <EvilMachine> hello there. can somebody (who implemented it) tell me, why it is impossible to get the original errno from the functions inside System.Posix.Files? because i have to clear something with that guy. ^^
14:43:12 <Baughn> romand: Er, that is.. foldr is the right thing if the result can be computed lazily, but it causes stack overflows if it can't. foldl' is the right thing in that case. foldl is not the right thing, ever.
14:43:17 <romand> result is even larger - it is Data.Map from ~50 string to ~3kk strings
14:43:26 <Gracenotes> @pl \s a -> ((s, a), f s a)
14:43:26 <lambdabot> ap (ap . ((,) .) . (,)) f
14:43:29 <Gracenotes> x.x
14:43:40 <EvilMachine> (i meant clarify. i'm no native english speaker)
14:43:44 <ehirdghost> :t replicate
14:43:45 <lambdabot> forall a. Int -> a -> [a]
14:44:04 <romand> Baughn: got it, thanks
14:44:06 <Baughn> romand: To be more precise, for foldr to work the computation has to be such that no dethunking that will actually happen ends up evaluating more than one (or a few) list elements
14:44:09 <Gracenotes> @pl \(s, a) -> ((s, a), f s a)
14:44:09 <lambdabot> uncurry (ap (ap . ((,) .) . (,)) f)
14:44:49 <Gracenotes> @type (id &&& uncurry ?f)
14:44:51 <lambdabot> forall a b c. (?f::a -> b -> c) => (a, b) -> ((a, b), c)
14:45:25 <Gracenotes> @type (id *** uncurry ?f)
14:45:26 <lambdabot> forall a a1 b c. (?f::a1 -> b -> c) => (a, (a1, b)) -> (a, c)
14:46:06 <rovar> is there a noop function for monads?
14:46:14 <Baughn> rovar: return
14:46:51 <Baughn> rovar: But if you're using it for an if branch, you should use Control.Monad.when/unless instead.
14:46:54 <tromp_> foo >>= return  is same as   foo
14:47:10 <EvilMachine> anyone? i would only like to implement a FUSE file system by leaving every function at the default, except for reading and writing files. but it seems, to do so, i need to call the posix-function (that could give me an exception), but return an errno. makes no sense. :(
14:47:11 <rovar> gotcha
14:47:19 <rovar> I'm using it for an empty list pattern
14:48:05 <Baughn> > (+) <$> return 2 <*> [2..4]
14:48:06 <lambdabot>   [4,5,6]
14:49:19 <Baughn> > (,,) <$> [1..3] <*> [1..3] <*> [1..3] -- Hmm, let's see..
14:49:21 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
14:49:24 <ehirdghost> Does GHC's gc run in parallel with the mutator?
14:49:36 <Baughn> ehirdghost: No, but it does run in parallel with itself
14:49:39 <sjanssen> ehirdghost: no, GHC's GC is stop-the-world
14:49:40 <ehirdghost> Right, kay
14:49:45 <ehirdghost> any work on repalcing that>
14:49:49 <Baughn> ehirdghost: Thread-local storage is on the plan for future releases, yes
14:50:03 <ehirdghost> you can do a parallel gc without that no?
14:50:12 <Gracenotes> @type liftA2 (>>) when unless
14:50:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:50:17 <Baughn> (The allocation arena is already thread-local, but anything that survives a GC there is promoted to global space)
14:50:18 <sjanssen> ehirdghost: I think you mean "concurrent GC"
14:50:21 <ehirdghost> er, right
14:50:24 <Gracenotes> there we go, an if/then for monads :)
14:50:45 <Baughn> ehirdghost: And yes, you can, but adding explicit thread-local allocation not only makes it easier, but also fits better with NUMA systems
14:50:50 <FunctorSalad> this package has a type: data Vec2 = Vec2 {-# UNPACK #-} !Float {-# UNPACK #-} !Float
14:50:56 <ehirdghost> OK
14:51:07 <FunctorSalad> why do many functions using that type have Strictness U(LL) rather than U(SS)?
14:51:24 <tristes_tigres> @vixen19 helloo
14:51:25 <lambdabot> I've gotta snake, man!
14:51:31 <FunctorSalad> (and is this bad? assuming you want maximum strictness)
14:51:46 <tristes_tigres> @vixen19 you single ?
14:51:46 <lambdabot> yup, i'm single. you?
14:52:01 <mkaemmer> does ghc need a compile flag to import Parsec?
14:52:10 <tristes_tigres> @vixen19 do you love haskell ?
14:52:10 <lambdabot> Ooh, functional programmers are so hot!
14:52:40 <tristes_tigres> @vixen19 you're my kind of girl !
14:52:40 <lambdabot> of course i'm female
14:52:52 <EvilMachine> yeah right ^^
14:53:29 <tristes_tigres> @vixen19 lol
14:53:29 <lambdabot> what's so funny?
14:53:41 <EvilMachine> inside joke
14:53:46 <EvilMachine> ^^
14:53:47 <tristes_tigres> @vixen19 are you blond ?
14:53:47 <lambdabot> yes, i am
14:54:17 <EvilMachine> poor lambdabot. got thrown in a cage with hungry tigres.
14:54:52 <tristes_tigres> @vixen19: do you have a lot of silicone ?
14:54:52 <lambdabot> Unknown command, try @list
14:55:04 <tristes_tigres> @vixen19 do you have a lot of silicone ?
14:55:04 <lambdabot> maybe. do you?
14:55:18 <EvilMachine> tigres means the electronic kind. he only had a typo :P
14:55:33 <pumpkin> anyway...
14:55:34 <kiris> preflex: be poppavic
14:55:34 <preflex>  no quotes found for poppavic
14:55:38 <rovar> is there some better way to call:    do  let _ = mapM_ putBSONElement o
14:55:40 <kiris> I am shocked and apalled
14:55:43 <romand> any function to swap arguments of other function?
14:55:46 <mauke> kiris: brainwipe
14:55:48 <pumpkin> maybe we should restrict @vixen use to #haskell-blah ?
14:55:57 <mauke> romand: flip
14:56:04 <kiris> mauke: moar liek ran out of alcohol, amirite
14:56:04 <romand> mauke: thx
14:56:05 <EvilMachine> wow. you all were quiet to listen to this?? what the
14:56:07 <FunctorSalad> pumpkin: yeah
14:56:18 <rovar> i basically want to execute putBSONElement  over o, but I don't want any results
14:56:37 <tristes_tigres> unhand vixen19? you brutes
14:57:07 <pumpkin> just saying that of the various lambdabot plugins, it's the least relevant to #haskell :P
14:57:30 <pumpkin> it almost requires anyone using it to be off-topic
14:58:08 <EvilMachine> does anyone here know something about the System.Posix.Files functions? (especially how to get the errno back again, when the fuctions only throw you IOErrors?)
14:58:13 <tristes_tigres> @vixen19 are functional dependencies useful ?
14:58:13 <lambdabot> I define fun
14:59:56 <koeien> how do i backtrack using a reasonable amount of space ? i.e. O(depth+result) instead of more
15:00:05 <monochrom> I defun fine
15:00:18 <EvilMachine> ok, how do i solve a problem where i searched google for hours, looked at the library source, and asked here, and still can't solve it? re-implement ghc?? ^^
15:00:37 <tristes_tigres> EvilMachine: try asking vixen19
15:00:42 <FunctorSalad> EvilMachine: haskell-cafe/ghc-users mailing list?
15:00:47 <mkaemmer> anyone know how to compile files that use Parsec?
15:00:48 <koeien> e.g.  go 512 = [1]; go (-512) = [-1]; go n = go (n-1) ++ go (n+1) -- keeps the n in memory
15:00:58 <rovar> mkaemmer: remember to use --make
15:01:02 <EvilMachine> thank you FunctorSalad. i will try that. :)
15:01:18 <mauke> EvilMachine: write your own C bindings
15:01:19 <rovar> EvilMachine: you could write a simple C function that returns you errno
15:01:28 <mauke> rovar: already exists
15:01:31 <mkaemmer> rovar: yeah... it gives : undefined reference to `parseczm2zi1zi0zi1_TextziParserCombinatorsziParsecziPrim_zdf2_closure'
15:01:45 <EvilMachine> is vixen19 a bot?
15:01:49 <pumpkin> can't you just make a single FFI binding to errno? without the ccall?
15:01:52 <koeien> mkaemmer: did you use --make ?
15:02:01 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Error.html
15:02:08 <EvilMachine> rovar: there is getErrno
15:02:11 <FunctorSalad> maybe --make should become the default? ;) we seem to get that issue every day recently
15:02:21 <jlouis> EvilMachine: vixen19 is a part of lambdabot
15:02:30 <rovar> oh
15:02:30 <jlouis> @vixen19 asl?
15:02:31 <lambdabot> 19/f/California
15:02:41 <rovar> use :  -package parsec
15:02:54 <EvilMachine> rovar: but it always returns null. i guess the throwing inside the functions already clears it.
15:02:55 <rovar> ghc - package parsec <everything else>
15:02:59 <jlouis> EvilMachine: though vixen is pretty simple code. You might want to study it
15:03:09 <mkaemmer> rovar: thanks! :)
15:03:39 <Axman6> --make should do that for you though
15:03:47 <tristes_tigres> jlouis: I wonder if there's somewhere a source code for rl girls
15:04:00 <Axman6> mkaemmer: if you import other libraries, you basically always want to use --make
15:04:11 <rovar> EvilMachine: I've no idea what exceptions in haskell does to the C stack. That's out of my league
15:04:16 <FunctorSalad> tristes_tigres: it's called dna, but it's slightly obfuscated
15:04:26 <EvilMachine> rovar: same problem here ^^
15:04:32 <jlouis> tristes_tigres: There is, I am not going to tell you where but that it includes the probability monad and the choose-different-from-males monad and the fail-fail monad
15:04:44 <EvilMachine> pumpkin_: there is a getErrno function. but, well. its useless. it always returns 0.
15:04:48 <rovar> although errno is global.. it shouldn't be effected.. especially if you could bind directly to that symbol
15:05:13 <Baughn> rovar: thread-local, actually
15:05:15 <EvilMachine> @vixen19: how do i convert from an IOError back to a Errno?
15:05:15 <lambdabot> Unknown command, try @list
15:05:29 <Baughn> rovar: Eg. you can only access it safely in bound threads
15:05:35 <rovar> errno is thread local?
15:05:38 <Baughn> It is
15:05:44 <Baughn> It makes sense, if you think about it
15:05:53 <rovar> well yea
15:05:57 <pumpkin> how is errno thread-local? is that platform-specific?
15:06:00 <rovar> but when did theye switch to that?
15:06:08 <ImInYourMonad> http://mathforum.org/library/drmath/view/52289.html <- i wonder what  happened to this guy, would eb onteresting since it is 10 ars later. Kiki Nwasokwa
15:06:14 <tristes_tigres> woo :: Chocolate -> Flowers -> Compliments -> Maybe Date
15:06:42 <Baughn> pumpkin: It is with relation to posix threads, at least. I don't know if it's actually /specified/ anywhere, but if it /wasn't/ thread-local, that would make threads /completely useless/...
15:06:56 <pumpkin> not really...
15:06:58 <romand> foldl' (flip . (Map.alter plus1)) Map.empty somelist
15:07:03 <romand> what is wrong here?
15:07:24 <Baughn> Okay, not completely useless, but it's nice to be able to call system functions in multiple threads
15:07:35 <rovar> Date = Head | Tails
15:07:52 <Baughn> @dice 1d2
15:07:52 <lambdabot> 1d2 => 2
15:08:00 <rovar> it would appear to have been added to glibc around 2005
15:08:08 <FunctorSalad> Date = (Fail,Date)
15:08:20 <tristes_tigres> rovar: firstBase | secondBase | Head | Tail
15:09:20 <monochrom> romand: Does plus1 have the right type? What seems wrong?
15:09:32 <EvilMachine> there is a errnoToIOError. but no no ioErrorToErrno. why not?
15:09:36 <pumpkin> Baughn: you can call them, you just can't reliably expect to query errno after the fact unless you acquire some sort of lock around it
15:09:42 <rovar> also.. it shouldn't be  -> Maybe Date.  it should be   -> Either (Order Restraining) Date
15:09:58 <romand> monochrom: plus1 :: Maybe Double -> Maybe Double
15:09:59 <Baughn> pumpkin: Yes, see, that's silly
15:10:32 <Baughn> rovar: You mean 'Either Date (Order Restraining)'
15:10:48 <EvilMachine> pumpkin: then how do you get the errno, in haskell, after all? if you really do not neet the content of the exception that you get out?
15:10:55 <rovar> Baughn: that entirely depends on your point of view
15:10:57 <romand> compiler says: expected type - b -> c, inf. type - Map.Map a1 a
15:11:01 <EvilMachine> t=d
15:11:15 <romand> and suggests 'Probable cause: `Map.alter' is applied to too many arguments'
15:11:25 <romand> but it is wrong
15:11:26 <pumpkin> Baughn: on mac os (and POSIX, I'd assume) it's just global, and it's silly, but it's hard to change things like that
15:11:55 <p_l> pumpkin: that's cause errno was created before threading :)
15:12:01 <pumpkin> I know :)
15:12:07 <p_l> threading didn't mix well with Unix model, anyway
15:12:27 <monochrom> @type foldl
15:12:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:12:30 <trofi> > map pred "sleep"
15:12:31 <lambdabot>   "rkddo"
15:12:39 <pumpkin> yeah, concurrency = fork :P
15:12:49 <p_l> pumpkin: it's not that stupid :D
15:12:50 <seliopou> errno is thread-local
15:13:00 <pumpkin> how?
15:13:16 <p_l> seliopou: If you are lucky and everything runs TLS well
15:13:21 <Baughn> > map pred "IBM"
15:13:23 <lambdabot>   "HAL"
15:13:28 <Axman6> :O
15:13:33 <Axman6> gtfo!
15:13:38 <monochrom> romand: I think you should use flip (Map.alter plus1) instead of flip . (Map.alter plus1)
15:13:38 <seliopou> not sure, but it is
15:13:42 <Axman6> more Baughn wizardry!
15:13:56 <pumpkin> for example, the __thread specifier on a variable only works on ELF-based platforms (in gcc)
15:13:59 <trofi> map succ hal respectively :p
15:14:05 <p_l> Axman6: Baughn is A Certain Scientific Wabbit
15:14:10 <monochrom> In fact flip (Map.alter plus1) is exactly your intention.
15:14:18 <Baughn> p_l: That's "cabbit"
15:14:27 <p_l> Baughn: ah, sorry, slipped :D
15:14:30 <Axman6> o.O
15:14:54 <p_l> pumpkin: __thread is actually added by libc
15:14:56 <romand> monochrom: it work, thanks!
15:15:11 <monochrom> nice
15:15:18 <pumpkin> p_l: ?
15:15:37 <p_l> pumpkin: __thread only marks variables, libc takes care of playing with registers
15:15:47 <pumpkin> oh, well sure
15:15:52 <pumpkin> the point is, it isn't cross-platform
15:15:55 <pumpkin> even on posix systems
15:15:55 <p_l> on x86 it does that by playing with segment registers during thread switch
15:16:25 <p_l> yeah
15:16:28 <pumpkin> apparently glibc uses errno in a threadsafe way, but not everything uses glibc
15:16:43 <p_l> and glibc is not the best idea either
15:16:44 <Baughn> Axman6: Haskell (well, lazy evaluation in particular) is very handy when simulating the physical laws of inter-dimensional or cross-temporal jumps.
15:16:58 <p_l> poor Axman6
15:18:08 <monochrom> lazy evaluation is very handy in making dynamic programming half as hard. very few people realize it, due to bad education.
15:19:00 <monochrom> the bad education is not just bad in limiting to imperative programming. that alone does not explain the full problem.
15:19:28 <EvilMachine> Baughn: Please, write us an interpreter for the movie Primer in Haskell then. ^^
15:19:49 <monochrom> the more subtle and major problem is that bad education depicts dynamic programming as difficult, mysterious, wizardry. student will not believe there is an easier way.
15:20:27 <ddarius> We should depict all of programming as difficult, mysterious wizardry to up our salaries.
15:20:53 <Baughn> EvilMachine: I'll do that, just as soon as I've watched it. Looks interesting.
15:21:30 <edwardk> ddarius: you mean some of us don't? who dropped the masquerade?
15:21:52 <EvilMachine> Baughn: Theres a paper/article about it, in case you do not understand the move. Which is only normal for 99% of the people. ;) ok. nuff offtopic.
15:21:54 <rovar> Primer is a cool movie
15:22:02 <rovar> it's what low budget scifi should be
15:22:09 <Baughn> EvilMachine: Yes, but I'm already in #haskell, so. :P
15:22:28 <EvilMachine> lol
15:23:43 <ddarius> edwardk: Bad educators apparently.
15:24:20 <Baughn> EvilMachine: Mind you, that it's apparently about error-checking devices.. somehow makes me think it's going to be about outcome pumps or something
15:24:28 <rovar> arg.. i'm really having an issue with type conversions
15:24:29 <Eridius> hrm, I think I've seen this movie
15:24:35 <Eridius> if it's the movie I think it is, it was really quiet good
15:25:01 <Eridius> *quite
15:25:07 <rovar> i have a Double, and i need to Put a (I'm guessing) CDouble
15:25:25 <rovar> so I need to convert a Double to a CDouble and then to a Word64le?
15:25:32 <edwardk> bah, if someone figures out that its not hard, then anyone with an MBA could replace us, all they would have to do is give up their jet-setting lifestyle and chain themselves to a cube.. oh i guess we're safe.
15:25:34 <EvilMachine> Baughn: i have seen it. it's about time machines, and transporting time machines inside time machines, and existing detached from causatity. thrice! ^^
15:25:43 <tromp_> :t lift
15:25:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
15:25:48 <Baughn> EvilMachine: Ooh. I *love* that sort of thing.
15:25:51 <tromp_> :t liftM
15:25:51 <p_l> Baughn: Your fact should spell  "Cabbit" ;-)
15:25:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:26:50 <Baughn> p_l: ..come now. I'm a perfectly normal-sized cabbit.
15:27:09 <p_l> Baughn: normal sized doesn't exclude you from being "big science" cabbit :P
15:27:33 <temoto-mobi> How to see generated C code?
15:27:49 * edwardk wonders if p_l and baughn have been rewatching tenchi muyo or something ;)
15:28:03 <EvilMachine> hmm... is cabbit a perfectly cromulent word? :P
15:28:20 <edwardk> EvilMachine: actually its a woman's name ;)
15:28:25 <p_l> edwardk: I had seen only two episodes of Tenchi Muyo long time ago. It's an in-joke about Baughn and carrots :D
15:28:37 <EvilMachine> temoto-mobi: look at the hsc file. if you can stand it. ^^
15:29:22 <Baughn> p_l: Well, at the moment I'm munching kohlrabi slices instead. What does that make me, a cowbit?
15:30:04 * p_l tries to unsee the mental image
15:30:35 <EvilMachine> p_l: of the hsc file?? :P
15:30:55 <p_l> EvilMachine: Of lazy-evaluated cowbit
15:31:01 <temoto-mobi> How to convert String IO to Int IO?
15:31:15 <temoto-mobi> or should it be IO String..
15:31:38 <temoto-mobi> basically, i want to have a number out of getLine.
15:31:44 <rovar> liftM read?
15:31:57 <ddarius> :t readLn
15:31:58 <lambdabot> forall a. (Read a) => IO a
15:32:17 <Eridius> @src readLn
15:32:17 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
15:32:34 <rovar> :t liftM read
15:32:35 <lambdabot> forall a (m :: * -> *). (Monad m, Read a) => m String -> m a
15:32:41 <temoto-mobi> @src readIO
15:32:41 <lambdabot> Source not found. Where did you learn to type?
15:32:54 <temoto-mobi> !!
15:33:00 <EvilMachine> :D
15:33:06 <monochrom> @quote String
15:33:06 <lambdabot> JaffaCake says: not all IOError -> String functions are created equal :)
15:33:23 <monochrom> You can use length to convert String to Int.
15:33:31 <EvilMachine> All IOError function suck
15:33:34 <EvilMachine> :P
15:33:34 <monochrom> > length "239849302"
15:33:36 <lambdabot>   9
15:33:42 <monochrom> That converts string to int.
15:33:45 <EvilMachine> lol
15:33:52 <EvilMachine> you can also use md5, i guess
15:34:01 <Eridius> you could also just use \_ -> 3
15:34:09 <monochrom> liftM length  will convert IO String to IO Int, as a corollary.
15:34:28 <Eridius> > liftM (\x -> 3) "foobar"
15:34:29 <lambdabot>   [3,3,3,3,3,3]
15:34:29 <Eridius> oops
15:34:32 <EvilMachine> Eridius:  best solutinon anyway. \_ -> 0
15:34:36 <Eridius> not quite the monad I meant
15:34:36 <temoto-mobi> uh i don't need string's length. I need to get number that's written as string. Controrary to show.
15:34:51 <Eridius> temoto-mobi: go back and read the first response you got
15:34:58 <monochrom> That should be what you should have said in the beginning.
15:35:04 <EvilMachine> temoto-mobi: that would be the function "read"
15:35:12 <Eridius> or as ddarius suggested, perhaps readLn
15:35:12 <temoto-mobi> Thanks.
15:35:14 <Eridius> or readIO
15:35:23 <EvilMachine> yes. readIO
15:35:27 <Baughn> Don't forget reads
15:35:54 <kerlo> What does readIO do?
15:36:03 <kerlo> Is it effectively return . read?
15:36:19 <monochrom> readIO does: if there is parse error, raise IO exception.
15:36:27 <Eridius> instead of terminating the program
15:36:32 <Eridius> although I do wonder why there's no equivalent readM
15:36:47 <rovar> anyone here familiar with interfacing Haskell with C? I'm having issues with Binary.Put and putting correctly formatted values
15:37:18 <Baughn> rovar: Not interfacing via FFI, then.. what sort of issues?
15:37:42 <Eridius> @src read
15:37:42 <lambdabot> read s = either error id (readEither s)
15:37:44 <monochrom> perhaps you have an endian mismatch?
15:37:52 <rovar> Baughn: I'm writing a binary protocol, where most of the types mirror C types.
15:38:03 <Eridius> @hoogle readEither
15:38:04 <lambdabot> No results found
15:38:05 <Eridius> huh
15:38:16 <Baughn> rovar: Okay..?
15:38:30 <rovar> my current issue is writing an 8 byte floating point number via Binary.Put
15:38:37 <Baughn> rovar: Of course you're aware that c types don't have an actual binary specification..
15:38:59 <Eridius> Baughn: I would assume in this case he wants the IEEE format for a Double
15:39:06 <temoto-mobi> rovar: i bet you're reinventing protocolbuffers.
15:39:10 <Baughn> Yes, probable. Hum..
15:39:16 <Eridius> temoto-mobi: Protocolbuffers just reinvented Thrift ;)
15:39:16 <rovar> yea.. which I assume would be   CDouble
15:39:44 <ImInYourMonad> how do I do a onadic action X tims?
15:39:44 <ImInYourMonad> do-x-times $ makeRow 9 board_btns
15:39:49 <rovar> temoto-mobi: I am writing a Haskell driver for BSON/MongoDB, which is a reinvention of such :)
15:39:52 <Eridius> ImInYourMonad: replicateM
15:40:22 <temoto-mobi> Eridius: i'm not that into differentiating those, but anyway i see no purpose in writing binary protocol since i heard of those.
15:40:27 <rovar> http://www.mongodb.org/display/DOCS/BSON
15:40:42 <Eridius> temoto-mobi: there's another one that I heard of not too long ago, trying to find it. Has some nice benefits vs Thrift/Protocolbuffers
15:40:51 <temoto-mobi> rovar: think mongo is for good?
15:41:03 <rovar> temoto-mobi: as opposed to?
15:41:04 <rovar> evil?
15:41:09 <rovar> awesome?
15:41:19 <temoto-mobi> rovar: as not opposed.
15:41:49 <rovar> it's pretty solid. It is designed much better than, say CouchDB
15:42:09 <rovar> I've looked through a lot of the source, and ran a bunch of tests.. It's already suitable for my needs
15:42:16 <rovar> (if it had haskell drivers) :)
15:42:31 <temoto-mobi> rovar: alright, thanks.
15:43:02 <rovar> it also has corporate sponsorship, there are like 3 full time devs devoted to it
15:43:30 * Baughn wonders why Binary doesn't already serialize in IEEE format
15:44:13 <rovar> dunno
15:44:16 <Eridius> Baughn: Maybe because the "native" Haskell numeric types don't necessarily match the traditional C ones? There's a reason CDouble and the other C* types exist
15:44:32 <rovar> maybe it does and I'm just doing something wrong
15:44:35 <rovar> Ralith: hey
15:44:41 <quicksilver> it definitely doesn't.
15:44:45 <quicksilver> Double might not be IEEE
15:44:52 <Ralith> rovar: hi
15:45:02 <quicksilver> (although it is, on the platforms most people care about)
15:45:29 <temoto-mobi> hm.. how to do     putStrLn $ "fact: " ++ show $ fact x     ?
15:45:32 <Baughn> FP is supposed to be inaccurate, but I don't suppose many people would enjoy having get . put /= id
15:45:32 <rovar> I don't want to count on that, I would prefer to explicitly write a CDouble (64 bit)
15:45:49 <p_l> quicksilver: doesn't x86 break IEEE?
15:45:52 <Baughn> rovar: Well, you can always write a Binary instance for CDouble
15:45:58 <quicksilver> p_l: only if you use the registers.
15:46:16 <quicksilver> p_l: GHC doesn't ;)
15:46:26 <quicksilver> well, it keeps storing back to memory, at least.
15:46:27 <rovar> is there an idiomatic way to do these casts?
15:46:30 <p_l> quicksilver: or something like 387 breaking IEEE, SSE being more compatible
15:46:48 <quicksilver> p_l: right. 387 is 80-bit, SSE is 32-bit
15:46:56 <quicksilver> p_l: (and SSE2 added 64-bit support)
15:47:09 <Eridius> ah hah, extprot is the newest tool I was thinking of in the vein of protocolbuffers, although it has a different overall goal: http://eigenclass.org/R2/writings/extprot-extensible-protocols-intro
15:47:11 <p_l> quicksilver: afaik you can also use 128bit format with SSE
15:47:12 <quicksilver> but 387 is "80 bit registers but 64 bit memory load/unload)
15:47:15 <quicksilver> it's a bit odd.
15:48:04 <temoto-mobi> > putStrLn $ "fact: " ++ show $ fact x     where fact stub = stub * 4, x = 2
15:48:05 <lambdabot>   <no location info>: parse error on input `,'
15:48:37 <rovar> Eridius: as you might guess, BSON is a binary compaction of JSON, with some added enhancements. MongoDB can inspect these objects and allow one to create indices on inner objects, and other nifty things
15:48:40 <quicksilver> temoto-mobi: putStrLn $ "fact: " ++ (show $ fact x)
15:49:00 <temoto-mobi> oh.. parenthesis
15:49:06 <Eridius> rovar: I'm not suggesting that he should switch to extprot, I just posted that because it was relevant to the earlier digression
15:49:17 <Eridius> rovar: I fully understand that what he's doing does not let him pick the binary format
15:50:16 <temoto-mobi> quicksilver: i'm starring at that ++ (show n) and i don't get why it needs parenthesis.
15:50:19 <Peaker> how do I get the ratio components out of the (%)?
15:50:20 <Peaker> > 50%60
15:50:22 <lambdabot>   5%6
15:50:22 <Eridius> > let fact stub = stub * 4; x =2 in "fact: " ++ show (fact x)
15:50:23 <lambdabot>   "fact: 8"
15:50:30 <Peaker> How do I get the (5,6) components there?
15:50:37 <Eridius> temoto-mobi: the $ makes the (fact x) become an argument to "fact: " ++ show
15:50:45 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2427#a2427 <- hmm, how do I show randomRIO tupl?
15:51:36 <temoto-mobi> Eridius: not just to show?
15:51:52 <Eridius> temoto-mobi: $ has a fixity of 0, ++ is undoubtedly higher
15:52:24 <temoto-mobi> oh... operator presedence
15:52:26 <Eridius> @pl \r -> (numerator r, denominator r)
15:52:27 <lambdabot> liftM2 (,) numerator denominator
15:52:44 <Eridius> Peaker: see what lambdabot just spit out. you can pass your Ration as an arg to that
15:52:51 <vixey> @let (&) = liftA2 (,)
15:52:52 <lambdabot>  Defined.
15:52:53 <Eridius> *Ratio
15:52:57 <vixey> :t (numerator & denominator)
15:52:58 <lambdabot> forall a. (Integral a) => Ratio a -> (a, a)
15:53:32 <RayNbow> :t (numerator &&& denominator)
15:53:33 <lambdabot> forall a. (Integral a) => Ratio a -> (a, a)
15:53:37 <Eridius> :t (numerator &&& denomina...
15:53:37 <Eridius> damn
15:53:38 <lambdabot> parse error (possibly incorrect indentation)
15:53:41 <vixey> &&& sucks
15:53:41 <Eridius> you beat me to it
15:53:47 <vixey> (btw)
15:53:54 <RayNbow> vixey: why's that?
15:53:56 <Eridius> vixey: too many symbols for you?
15:54:00 <Peaker> Eridius: thanks
15:54:11 <monochrom> &&& doesn't suck.
15:54:32 <ddarius> It's a crappy name, but it was chosen for consistency with the other operators which can't use shorter variants.  (Similarly for (&&).)
15:55:00 <vixey> basically nobody uses arrows
15:55:06 <vixey> (by that I mean, I don't use arrows)
15:55:20 <vixey> and there are many more useful applicatives than arrows
15:55:27 <vixey> so (&) has more applications
15:56:23 <rovar> :t (realToFrac :: a -> CDouble)
15:56:24 <lambdabot>     Not in scope: type constructor or class `CDouble'
15:56:57 <Baughn> :t (&&&)
15:56:57 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:57:18 <Peaker> Are there arrows that can't also be made applicatives (by applying them to an open type variable)?
15:57:38 <ddarius> @hoogle WrappedArrow
15:57:38 <lambdabot> Control.Applicative newtype WrappedArrow a b c
15:58:03 <ddarius> @instances-importing Control.Applicative Applicative
15:58:04 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
15:58:48 <temoto-mobi> Eridius: looking at that extprot.. does it looking insane to compare speed of binary protocol to XML only for me?
15:59:02 <Eridius> temoto-mobi: pardon?
16:00:20 <temoto-mobi> Eridius: you gave that extprot link. This is interesting. Though i think that statements like "X times smaller than XML or Y times faster than XML" is nothing.
16:00:29 <Eridius> temoto-mobi: why do you think that?
16:00:51 <temoto-mobi> Eridius: because it's like different magnitude - text format and binary.
16:01:07 <Eridius> "X time smaller than XML" is pretty easily measured. Talking about speed of serializing/deserializing is a bit harder, since that depends on the implementation of the XML serializer/deserializer, but I would assume that he's measuring against well-known XML libraries
16:01:19 <Eridius> temoto-mobi: so? it's still relevant
16:01:22 <temoto-mobi> It would make sense to compare extprot to Thrift or protobuffers.
16:01:53 <Eridius> temoto-mobi: he's comparing against XML because both are self-describing formats
16:02:09 <temoto-mobi> oh
16:02:10 <Eridius> and because XML is much more well-known than Thrift/protobuffers
16:02:31 <Eridius> he draws several parallels between extprot and XML
16:02:49 <rovar> thrift is self describing
16:03:07 <rovar> if you don't mind C style types :)
16:03:27 <Eridius> rovar: only as a sort of side-effect, and the libraries don't support deserializing arbitrary data without a protocol definition
16:03:36 <bremner> rovar: that reminds me I have to go the dentist
16:04:30 <monochrom> "GHC-compiled code is 100 times faster than Perl code" and "that's an unfair comparison" are both true. The world is unfair. Don't shoot down unfair comparisons. You want GHC-compiled code at the end of the day, unfair as it is.
16:05:30 <Philippa_> monochrom: yep, the part where perl /can't/ have a GHC-competing compiler is kinda important
16:05:49 <rovar> on a related note,  stabbing an icepick in your eye is 100 times more fun than writing or reading XML and Perl
16:06:13 <Eridius> rovar: and depending on your overall goal, potentially more productive too!
16:07:23 <monochrom> It always amuses me that the comment delimiters of X StyleSheet are (: and :)
16:07:26 <ddarius> Saying GHC is 100x faster than Perl doesn't mean you should use GHC, it just means you should use it over Perl. (Assuming performance is the primary criterion.)
16:07:40 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2428#a2428 <- creates m*n buttons, can it b simplified? (gtk2hs)
16:08:21 <bremner> Perl is at least fun to write, unlike XML, which isn't fun in either direction
16:08:26 <Eridius> ImInYourMonad: maybe you could use replicateM there?
16:08:26 <dcoutts> ImInYourMonad: yes, using sequence and list comprehensions
16:09:16 <monochrom> You're supposed to use HXT combinators to read and write XML rather than handwriting <'s and >'s.
16:10:14 <monochrom> But I admit I'm still handwriting them just yesterday.  http://www.vex.net/~trebla/homework/extended-euclid.html  my latest piece, shameless plug
16:10:35 <Eridius> what's HXT?
16:10:46 <rovar> argh
16:10:55 <monochrom> An XML library in Haskell. Uses Arrows.
16:11:11 <Eridius> at some point I really should learn more about Arrows
16:11:11 <monochrom> I suppose T suggests "tranforms".
16:11:22 <tristes_tigres> Is there a large, significant, useful, COMPLETED project in Haskell ? Perl 6 doesn't seem to be the latter
16:11:51 <Philippa_> tristes_tigres: define 'completed' - does darcs count?
16:11:52 <Eridius> you mean Pugs?
16:11:53 <Draconx|Laptop> tristes_tigres, define "COMPLETED".
16:11:54 <monochrom> If you want to avoid Arrows, you can try HaXML. But HaXML is not as comprehensive as HXT (I mean fewer utility functions).
16:12:01 <ddarius> tristes_tigres: Nope.  None at all.
16:12:02 <olsner> completed == obsolete
16:12:27 <Philippa_> from what I've heard there are definitely some in-house ones - stuff like bluespec
16:12:40 <tristes_tigres> Philippa: darcs doesn't seem to be much used outside Haskell commnity, and even GHC is switching to git
16:12:44 <Philippa_> the value of 'large' can be tricky to define
16:12:52 <tristes_tigres> Eridius: yes
16:12:56 <Eridius> how about xmonad?
16:13:04 <ehirdghost> tristes_tigres: Absolutely not. If you try and complete a Haskell application, the ninjas get you.
16:13:10 * Eridius notes that he knows next to nothing about xmonad
16:13:15 <rovar> aargh
16:13:20 <tristes_tigres> Draconx: Completed = used for actual work
16:13:26 <Philippa_> tristes_tigres: sure, I'm not saying there aren't better alternatives. To be fair though, much of darcs' problem is that it was a research project
16:13:26 <Draconx|Laptop> tristes_tigres, how about GHC?
16:13:33 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2429#a2429 <- whats wrong with that?
16:13:34 <monochrom> All Haskell projects are large, even though they each contain 100 times less code.
16:13:38 <rovar> so if something is an instance of Real, should it have a conversion method? oddly.. from another Real?
16:13:41 <Philippa_> right, darcs /is/ still used for actual work even if largely within the haskell community
16:13:42 <ddarius> Philippa: What makes you think that?
16:13:42 <Eridius> darcs is academically interesting, but I get really annoyed whenever I try and use it :/
16:14:20 <Philippa_> ddarius: for fairly loose values thereof. It's a big, partially-succesful experiment
16:14:22 <tristes_tigres> Draconx: I am thinking about something that can be pointed to with the words : "look, Haskell is useful because XXX is written in it"
16:14:39 <Eridius> ImInYourMonad: it's complaining that your Button object is not an instance of the LabelClass typeclass
16:14:46 <Eridius> ImInYourMonad: presumably labelSetText only works on LabelClass objects
16:14:48 <Philippa_> tristes_tigres: that's trickier, yeah
16:14:54 <monochrom> Haskell is useful because xmonad is written in it.
16:14:59 <Philippa_> xmonad is probably the best example
16:15:15 <Eridius> look, Haskell is useful because some Lawnmower company uses it to write all their scripts (srsly)
16:15:18 <Philippa_> though it's pretty small, being a haskell project is part of why it is
16:15:19 <tristes_tigres> Philippa: Pugs would be it, but it seems to be one-man project, for the most part
16:15:41 <rovar> if only XMonad was the "Tabbing Windows Manager That Rocks"
16:15:42 <tristes_tigres> and so far from finished
16:15:46 <ehirdghost> tristes_tigres: xmonad, ghc, darcs, ...
16:16:03 <Eridius> I want to rewrite MacPorts in Haskell but I know that would be a one-man project ;)
16:16:10 * ddarius has better things to do like watching a movie he doesn't feel like watching right now.
16:16:13 <tristes_tigres> ghc and darcs do not count, because they do not have much use outside Haskell community
16:16:19 <monochrom> If you take "large, significant, useful" too seriously and anally, you're pretty much left with bloatware.
16:16:23 <Eridius> and it would introduce a pretty extreme bootstrapping, because pretty much everybody who uses GHC on OS X gets it via MacPorts
16:16:26 <tristes_tigres> xmonad might be an example
16:16:32 <ehirdghost> Eridius: I compile it manually,.
16:16:40 <Eridius> ehirdghost: you're special :P
16:16:42 <tristes_tigres> mnonochrom: is Perl blotware ?
16:17:07 <ehirdghost> Eridius: mommy says so!
16:17:16 <Eridius> oh man, Pugs's goal is to provide a platform to allow Perl 6 to bootstrap itself?
16:17:28 <Eridius> I wasn't aware Perl 6 was trying to become a compiled language
16:18:18 <tristes_tigres> Eridius: and also it is trying to become a language defined by a standard, as opposed to "defined by implementation"
16:18:24 <Eridius> heh
16:18:31 <Eridius> well, isn't a Haskell implementation pretty much a standard? ;)
16:18:50 <tristes_tigres> Eridius: yes? but we all know that Haskell is special ^-)
16:18:54 <Eridius> :D
16:19:50 <archwild> Is there any construct that will apply a function to all the parameters of another function?
16:20:27 * tristes_tigres thinks experienced Haskell hackers could do much to advance the case for Haskell for helping to complete Pugs
16:20:31 <Eridius> archwild: technically speaking, a function has only one parameter
16:20:38 <tristes_tigres> by helping I mean
16:21:09 <Eridius> tristes_tigres: yes, that sounds like a wonderful idea. "See how useful Haskell is? We can help create another language, so that way it can then start bootstrapping itself and.. oh well that just obsoletes Pugs then, doesn'ti t?"
16:21:13 <Eridius> *doesn't it
16:21:37 <Eridius> and then you *still* don't have anything you can point to as a real-world use ;)
16:21:52 <Philippa_> *and* even "we sorted the bootstrap" isn't necessarily that big a deal
16:22:28 <Philippa_> honestly, we'd have better luck via the Next Big Webapp Framework
16:22:33 <Philippa_> and I'm skeptical about that
16:22:46 <archwild> eridius, I understand that, but the code I'm creating seems boilerplate
16:22:52 <Eridius> yes, let's all go contribute to happs(tack)
16:23:06 <bremner> tristes_tigres: you miss the point. The point is not to promote Haskell. The point is to do cool stuff. In Haskell, if that is the best tool.
16:23:06 <Eridius> archwild: what is the code you're creating?
16:23:24 <Eridius> you know what I'd love to see someone create? A Haskell version of WWW::Mechanize
16:23:27 * bremner boldly generalizes on  behalf of everyone :-)
16:23:33 <Eridius> too bad I don't have the time to spend on something like that
16:23:41 <tristes_tigres> bremner: The history of computing is littered with way cool projects gone to dust
16:23:59 <archwild> eridius, I'm calling a function like 'func a+x b+x c+x d+x', and then need to call it later like 'func a-x b-x c-x d-x'
16:24:13 <Philippa_> tristes_tigres: perl6 looks likely to become one
16:24:23 <archwild> eridius, one solution would be to pass x in as another parameter, but that's kind of breaking abstraction for this particular function
16:24:33 <tristes_tigres> Philippa: it does ? I am not following it
16:25:03 <Eridius> tristes_tigres: well, it's been 9 years since it was first proposed and it's gone through some pretty big changes
16:25:19 <Eridius> I thought several years ago we were supposed to get a functional Perl 6 using Parrot
16:26:03 <bremner> tristes_tigres: so? I don't see how that changes anything.  Either someone pays me, or I think it is cool. Preferably both.
16:27:02 * bremner just doesn't have the evangelism gene I guess
16:27:53 <Philippa_> *nod*. Incrementalism strikes
16:27:58 <tristes_tigres> bremner: if academia loses interest to Haskel as paper-gernerating tool, it (in its present state) dies, right ?
16:28:23 <p_l> tristes_tigres: I doubt
16:29:03 * bremner is not the right one to answer that. I don't know what motivates people writing ghc
16:29:21 <Philippa_> tristes_tigres: we're part that stage in terms of community. It would be an unfortunate thing for GHC itself at this point, but not insurmountable - though the stream of extensions would slow rather, the possibility of extensions is what makes the papers worthwhile
16:29:25 <Eridius> the HTML 5 project, despite having a ridiculously long timeline, at least *has* a timeline.
16:30:00 <Eridius> sometimes I wish I could be part of academia playing around with Haskell
16:30:23 <tristes_tigres> bremner: it goes beyond evangelism, actually. Being able to pull off a major project is a proof that Haskell is worth investing one's time in
16:30:40 <Eridius> unfortunately, my entire exposure to Haskell at my school was a single week in a 4000-level class that almost nobody takes where we looked at it strictly as a lazy evaluation language and ignored everything else
16:30:44 <Eridius> the class used Scheme the rest of the time
16:31:07 <Eridius> tristes_tigres: so maybe we should all start contributing to yi?
16:31:17 <Eridius> it's actually usable in its current form, at least in the terminal
16:32:01 <pejo> tristes_tigres, how big is "major"?
16:32:12 <tristes_tigres> Eridius: yet another text editor ?
16:32:18 <Janin> I'm new to Haskell; is there any way to define a function that will accept two possible types for a particular parameter, without allowing arbitrary types to be passed in?
16:32:27 <mauke> Janin: not really
16:32:31 <Eridius> tristes_tigres: perhaps, but it has some pretty neat goals
16:32:41 <p_l> I think darcs serves as a serious example of real-life project already
16:32:43 <Philippa_> Janin: use the Either type?
16:32:44 <bremner> Janin: define an appropriate type
16:32:47 <p_l> Also XMonad
16:32:56 <tristes_tigres> pejo: for instance Pugs or some application framework
16:33:01 <Eridius> Janin: I second Philippa_'s suggestion
16:33:12 <Philippa_> alternatively, use a type class. But that accepts arbitrary types that meet a shared interface
16:33:16 <pejo> tristes_tigres, how about the stuff bluespec has done, or Galois?
16:33:21 <tristes_tigres> p_l: not used outside haskell community
16:33:26 <Janin> bremner: How would I do so? Is there a way to define an "all values of this type are also values of X type" relation?
16:33:39 <Eridius> tristes_tigres: I actually used darcs when I first started using DVCS despite not being part of the Haskell community at that time
16:33:45 <Eridius> tristes_tigres: of course I switched to git a couple of months later
16:34:01 <p_l> tristes_tigres: XMonad and darcs are both used outside Haskell community
16:34:01 <bremner> Janin: I guess I meant Either like all the others :-)
16:34:02 <Philonous> Janin: Do you mean something like overloading in C++?
16:34:19 <Janin> One sec, I'll write up what I'm trying to do and paste on a pastebin.
16:34:27 <Philippa_> Janin: there's no subtyping. You'd need an explicit coercion function
16:34:29 <temoto-mobi> I run ghc --make fact.hs, it produced hi, and fact binary. No hsc. How to see generated C code?
16:34:30 <bremner> but darcs is not available in cygwin! o noes!
16:34:33 <Philippa_> Janin: but look at typeclasses
16:34:44 <mauke> temoto-mobi: hsc is not generated C code
16:34:48 <Eridius> temoto-mobi: it doesn't use C code unless you pass -fvia-c
16:34:51 <p_l> bremner: I used darcs on windows a long time ago, without cygwin... I don't see a problem
16:35:04 <p_l> also, cygwin should die >_>
16:35:05 <Eridius> temoto-mobi: in addition, the generated C can't be taken elsewhere and compiled, it still needs the EvilMangler
16:35:06 <ImInYourMonad> is it now possible to change text on a button(not label) in gtk2hs?
16:35:16 <Eridius> given that C needs EvilMangler, what's the actual purpose of -fvia-c?
16:35:22 <bremner> (was a reference to the recent dropping of darcs by ion's author)
16:35:26 <mauke> Eridius: wasn't the evil mangler just for optimization?
16:35:30 <Eridius> ImInYourMonad: I would assume so, but I don't know GTK
16:35:39 <Eridius> mauke: I don't know much about it but I was led to believe it makes changes that are necessary
16:35:47 <mauke> meh
16:36:19 <Philippa_> Eridius: via-asm is new
16:36:19 <tristes_tigres> pejo: that's more like it
16:36:19 <pejo> Eridius, Debian has unregistered builds of ghc for lots of architectures.
16:36:21 <temoto-mobi> Still only .hi, .o and binary.
16:36:23 <Eridius> hmm
16:36:58 <p_l> bremner: well, the main reason I heard for switching from darcs was due to some speed problems, with people switching mainly to git and sometimes to mercurial
16:37:00 <Eridius> when I asked the other day about the possibility of using -fvia-c to generate C code and then using gcc to compile that for the iPhone, I was told that wouldn't work because EvilMangler would need to learn how to work on ARM
16:37:25 <bremner> p_l: yeah, the author of ion is, uhh, interesting
16:37:27 <Eridius> p_l: really? I hate using darcs because it's so obtuse.
16:37:57 <rovar> i would prefer darcs if it had Mercurial's interface
16:37:58 <p_l> Eridius: I personally don't use darcs directly, but a lot of projects that I use uses darcs (completely outside Haskell)
16:38:03 <mauke> temoto-mobi: try -fvia-C -C
16:38:04 <Eridius> for example, to view the changes introduced by the latest patch, I have to use `darcs changes --last=1`, then copy the beginning of the patch name and pass that to `darcs diff --patch=`. I can't even use `darcs diff --last=1`, that just seems to do a diff of my filesystem against the repo
16:39:05 <p_l> the worst VCS I have to work with is cvs and svn
16:39:30 <tristes_tigres> p_l: TortoiseSVN is not so bad.
16:39:33 <Eridius> svn is not bad, for a centralized system
16:39:40 <Eridius> though learning git makes me chafe at svn's restrictions
16:39:48 <Eridius> of course, I usually just use git-svn these days if I have to work with svn
16:39:57 <Eridius> hell, I now maintain 4 git mirrors of svn repos just so I can use git
16:39:57 <p_l> My problems stem not from the model, but from it's performance and being ridden with bugs/problems
16:40:37 <temoto-mobi> Solution was -keep-hc-files
16:40:44 <tristes_tigres> I think that darcs is going to the dustbin of history
16:40:44 <Eridius> heh, I created 2 of those mirrors when github first opened its doors, back in beta - I was later informed that my account was being used to test "large" projects on github as my two svn mirrors totalled roughly 80MB and were the largest on github at that time
16:41:00 <Eridius> of course, github now hosts many far larger well-known projects
16:41:46 <Janin> OK, here's my question in code format: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1904
16:41:53 <temoto-mobi> The generated code is something :)
16:42:27 <Eridius> Janin: you should probably use a typeclass for that
16:42:55 <Eridius> class Signatured where getSignature :: String
16:43:07 <Eridius> then you can make an instance for both MyBasicType and MyContainerType
16:43:17 <Janin> Would using a typeclass allow additional implementations of getSignature in outside code? I'm concerned about calling getSignature for some value returning an invalid value.
16:43:38 <Alpounet> hi
16:43:41 <Janin> like getSignature WeirdOutsideType = "uh oh"
16:43:53 <Alpounet> when do you think it is best to do type-checking (functional language) stuffs in a compiler ?
16:43:57 <Eridius> Janin: that would only work if WeirdOutsideType was defined as an instance of Signatured
16:44:30 <Janin> Right. It would be possible for somebody to do that with a typeclass, right?
16:44:49 <Eridius> why are you worrying about this?
16:45:19 <Janin> I don't want to come across as one of those "use 'private' everywhere :tinfoil:" types, but I'm concerned that a well-meaning user could cause the library to generate invalid output (and then blame me).
16:45:51 <Eridius> Janin: why would somebody make an instance of Signatured if they're not explicitly trying to extend your library?
16:45:54 <Eridius> also, what's the purpose of getSignature?
16:46:14 <Janin> Eridius: the purpose is to generate a type signature for writing to a file.
16:46:33 <Philonous> @hoogle Typeable
16:46:34 <lambdabot> module Data.Typeable
16:46:34 <lambdabot> Data.Typeable class Typeable a
16:46:34 <lambdabot> Data.Typeable class Typeable1 t
16:46:36 <Janin> I'm concerned that somebody would try to extend it in a way it really shouldn't, break it subtly, and not realize until none of their files load.
16:46:42 <Eridius> Janin: does this have to conform to some outside format?
16:46:54 <Janin> Yes, an in-company file format.
16:46:58 <Eridius> if you're simply looking for something you can use to serialize and then deserialize, you should look into what Philonous just suggested
16:47:00 <Eridius> ah
16:47:13 <ehamberg> BONUS: yay for update :)
16:47:33 <Eridius> Janin: well, if you don't want the typeclass, you'll have to do something like data MyType = MyBasicType MyBasicType | MyContainerType MyContainerType
16:47:42 <Eridius> if that looks confusing, I'm just defining constructors named after the types they wrap
16:48:03 <Janin> Can typeclasses be restricted to the scope of the module in which they're defined, perhaps?
16:48:37 <Eridius> Janin: I don't actually know if you can export the name of a typeclass but not the methods it defines
16:49:01 <Eridius> of course, this is assuming you need to export getSignature. If you don't even need to export that, then you wouldn't have to export the typeclass at all
16:49:21 <Janin> I don't think getSignature needs to be exported.
16:49:57 <Eridius> in that case, I don't think you have to worry about malicious users defining their own instances
16:50:23 <Janin> For what it's worth, this is a small re-implementation of a project driven absolutely insane by c++ overloading.
16:50:32 <Eridius> hah
16:51:01 <Janin> So I'm trying to be very, very careful about not letting users get their grubby fingers on bits they shouldn't directly poke at.
16:51:54 <EvilMachine> uuum Is IOException deprecated?
16:53:59 <ehirdghost> Hmm... If, in types, (->) is the equivalent of logical implication, what would the equivalent of ^ (and) be?
16:54:12 <vixey> what is the meaning of "and"?
16:54:36 <ehirdghost> ...
16:54:46 <vixey> if you can't answer that, you wont be able to implement it in Hasklel
16:54:57 <dolio> How would you prove A and B?
16:55:29 <Eridius> Janin: btw, I just want to point out that your definition of MyContainerType doesn't match with its usage in getSignature
16:56:19 <Philonous> ehirdghost: Types are proofs. To Proof A and B you need a Proof for a and you need to proof for B. So, which type contains two types?
16:56:24 <Janin> Yeah, I probably flubbed something up in the pastebin.
16:56:35 <ehirdghost> Philonous: Aha, Either!
16:56:40 <Philonous> No
16:56:42 <vixey> try again
16:56:42 <ehirdghost> er, wait
16:56:43 <ehirdghost> (,)
16:56:52 <Philonous> Yeo
16:56:54 <Philonous> Yep
16:56:55 <dolio> Programs are proofs. Types are propositions. :)
16:56:58 <ehirdghost> Yay.
16:56:59 <Philonous> So what does Either stand for?
16:57:07 <ehirdghost> Philonous: |
16:57:11 * Philippa_ wonders what it would cost to be able to derive a Show that indents for tree structure
16:57:11 <Philonous> Right.
16:57:41 <Philonous> dolio: Right. My bad.
16:57:50 <ehirdghost> :t \(f,x) -> f x
16:57:50 <dons> http://code.haskell.org/~dons/images/dot.png
16:57:51 <lambdabot> forall t t1. (t -> t1, t) -> t1
16:57:55 <ehirdghost> (p -> q, p) -> q
16:57:57 <dons> graph sets of cabal files as pretty graphs
16:58:16 <vixey> Philippa_: that seems quite possible
16:58:46 <EvilMachine> I think I found a bug in the current GHC libraries. in http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html it says that IOException is declared, but when I import Control.Exception, and use IOException, I get Not in scope: data constructor `IOException'
16:59:04 <Philippa_> vixey: yeah, I should sit down and work out which tool to write the damn thing with I guess
16:59:13 <TomMD> EvilMachine: Are you using the latest GHC?  The exception library has changed drasticly recently.
16:59:38 <Philonous> @type uncurry ($)
16:59:39 <lambdabot> forall a b. (a -> b, a) -> b
16:59:52 <EvilMachine> TomMD: I use version 6.10.1
16:59:59 <tristes_tigres> Philippa: you mean, automatically derive pretty-printing Show for trees ?
17:01:05 <TomMD> EvilMachine: IOException is not a data constructor but a type.
17:01:06 <ehirdghost> Philonous: yep
17:01:32 <TomMD> EvilMachine: use ghci, load Control.Exception, and type :info IOException
17:01:35 <EvilMachine> TomMD: in the documentation, it is a data constructor. Is there a correct documentation? ^^
17:01:38 <TomMD> You should see it.
17:01:40 <ehirdghost> (p -> q) -> p -> q doesn't have the same meaning, unfortunately.
17:02:02 <TomMD> EvilMachine: That says its a type, yep.
17:02:12 <TomMD> EvilMachine: Doesn't say its a constructor.
17:02:55 <EvilMachine> TomMD:  no. it specifically says "data IOException" right in the synopsys
17:03:04 <TomMD> EvilMachine: Yes, which makes it a type
17:03:10 <EvilMachine> TomMD: ah i know what you mean
17:03:12 <Philonous> > (\f x -> f x) 2
17:03:13 <lambdabot>       No instance for (Num (t -> t1))
17:03:13 <lambdabot>        arising from the literal `2' at ...
17:03:30 <Eridius> > ($) 2
17:03:31 <lambdabot>       No instance for (Num (a -> b))
17:03:31 <lambdabot>        arising from the literal `2' at <...
17:03:44 <Eridius> *gasp* it's almost like ($) is the same as (\f x -> f x)!
17:03:52 <EvilMachine> TomMD: that's what you get for naming types and constructors with the same name. ^^
17:04:45 <EvilMachine> TomMD: but there must have been i IOException constructor. because i read old code, where it was used: bindExceptionHandler (IOException ioe) = 
17:05:10 <Eridius> EvilMachine: check out Control.OldException
17:06:00 <TomMD> EvilMachine: The constuctor is 'IOError'
17:06:16 <TomMD> EvilMachine: As I said, use ghci and type :info IOException once you load Control.Exception.
17:07:20 <EvilMachine> Eridius: THANK YOU. that solved it. ^^. I'm still too new to follow the changes in ghc. I have yet to learn all the weird extensions of it :D
17:07:26 <Eridius> heh
17:07:52 <Eridius> EvilMachine: I just got started myself, but I've run into plenty of weird extensions already when poking around in things like the yi code
17:08:14 <Eridius> EvilMachine: I should also note that your particular question could be solved with hoogle
17:08:14 <EvilMachine> the ghc compiler is just the most insane beast i have ever seen. like... well... emacs in BIG ^^
17:08:16 <Eridius> @hoogle IOException
17:08:16 <lambdabot> Control.Exception IOException :: IOException -> Exception
17:08:16 <lambdabot> Control.Exception data IOException
17:08:23 <Eridius> oh hrm, using the web interface ;)
17:08:33 <EvilMachine> Eridius: oh. that is an even more useful tip :D
17:08:44 <Eridius> the web interface will show many more results, including the Control.OldException one
17:08:53 <TomMD> Its also nice to have hoogle locally installed - you can set it up for easy access withing your dev environment.
17:09:01 <Eridius> also, if you see code that uses something you don't understand, it's helpful to look at the imports in the file as a hint to where that something may have comef rom
17:09:24 <TomMD> Note that Hoogle won't show any libraries outside of base and extras.  So to search hackage you currently have to use Hooya!
17:09:37 <Eridius> Hayoo
17:09:52 <EvilMachine> Eridius: Why is this mentioned in no book or tutorial? ^^
17:09:58 <Eridius> EvilMachine: I dunno
17:09:58 <TomMD> Yeah - I always flip that, thanks Eridius
17:10:08 <rovar> so anyone have any ideas yet as to how to write a CDouble with Data.Binary.Put? I'm still stumped
17:10:13 <Eridius> TomMD: Hooya! is an amusing name though
17:10:16 <rovar> Hooya actually sounds like a good name
17:10:19 <rovar> heh
17:10:41 <Eridius> TomMD: if you know the package you can use hoogle to get a link to the package's documentation
17:10:44 <EvilMachine> Eridius: I looked at the imports. thats how i got to the Control.Exception documentation link
17:10:56 <sw17ch> @seen dons
17:10:57 <lambdabot> dons is in #yi, #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 10s ago.
17:10:57 <Eridius> EvilMachine: ah, was this code that doesn't compile on 6.10?
17:11:02 <TomMD> Eridius: Sure, but that isn't nearly enough.  I've submitted a ticket requesting a +hackage flag.
17:11:03 <tristes_tigres> Eridius: especially to a rusian ear, he he he he
17:11:08 <dons> sw17ch: yo yo
17:11:14 <Eridius> TomMD: sure, I'd love to see searching of hackage like Hayoo! does
17:12:12 <EvilMachine> TomMD: set yourself a bind redirect from hooya to hayoo ^^
17:12:35 <TomMD> EvilMachine: Not a bad suggestion, I've proved to myself that I will never keep that straight.
17:12:54 <EvilMachine> Eridius: yes. it was
17:16:47 <TomMD> Does anyone know about efforts to pull the SHA package into Crypto?  Some consolidation would be good and there seems to be enough bytestring work now to make a proper crypto-bytestring package.
17:17:32 <Alpounet> good night
17:18:27 <tromp_> @hoogle tell
17:18:28 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
17:18:28 <lambdabot> System.IO hTell :: Handle -> IO Integer
17:18:54 <eu-prleu-peupeu> anyone here from frankfurt ?
17:19:12 <dons> TomMD: hmm. do we need consolidation?
17:19:24 <dons> i'd be more in favour of starting afresh without touching the Crypto package at all
17:19:28 <dons> its really a ref. implementation
17:19:40 <rovar> is there a Fractional -> Real function?
17:20:29 <TomMD> dons: I think starting new is good.  'crypto-bytestring' is as good a name as any.
17:20:58 <TomMD> dons: I've worked out what the typeclasses should be (Hash, Cipher, etc) but am hesitant to upload those at this point.
17:22:06 <monochrom> There is no Fractional -> Real function.
17:22:19 <rovar> monochrom: I figured as much
17:22:20 <EvilMachine> sure?
17:22:34 <rovar> everything seems to go the other direction
17:23:10 <dolio> Those aren't even types.
17:23:12 <EvilMachine> but you can certainly pass a fractional value to a function expecting a Real.
17:23:15 <EvilMachine> lol
17:23:19 * dons attempts to construct a graph of the haskell hierarchical namespace ...
17:23:29 <pumpkin> :o
17:23:44 <EvilMachine> will he return, before the end of the universe?
17:23:56 <rovar> My problem is that Word64 is a an instance of real, but I need to use it, or something to serialize a fractional value
17:23:57 <c_wraith> I'd love a consolidated description, somewhere, of what types have what typeclasses defined for them in what modules.
17:24:02 <dons> 27k modules
17:24:04 <TomMD> EvilMachine: Not if he's using C++
17:24:06 <dons> sound about right?
17:24:15 <Gracenotes> dons: well, we already have a tree of the Haskell hierarchical namespace :) at least in base
17:24:22 <dons> i want it of hackage
17:24:31 <Gracenotes> oooh.
17:24:33 <pumpkin> that's a lot, but it makes sense
17:24:43 <dons> xargs *.cabal | cabalgraph | dot -Tpng > /tmp/hackage.png
17:24:45 <dons> waiting...
17:24:55 <TomMD> dons: Would you post that somewhere?
17:24:57 <dons> yep
17:24:58 <pumpkin> dot isn't so good with giant graphs
17:25:03 <pumpkin> I've found many times
17:25:10 <dons> i have a giant graph
17:25:12 <dons> help plz :)
17:25:22 <EvilMachine> TomMD: well, I found C++ to be slow for getting something done. (=the time it takes to program something) but haskell is even slower. ^^
17:25:33 <dons> the dot file is 1.7M
17:25:36 <pumpkin> unfortunately I usually just gave up when dot failed me :P because I didn't really need the giant graph
17:25:37 <Gracenotes> :x
17:25:41 <monochrom> You need a 3D holographic display for huge graphs.
17:25:45 <pumpkin> let me see how giant the one I was trying to make was
17:25:54 <Gracenotes> there should be someone way to have various levels of detail
17:26:00 <Gracenotes> *some way
17:26:16 <sw17ch> dons: o_O
17:26:27 <rovar> is there some way to break a CDouble up into an array of Word8's?
17:26:29 <Gracenotes> i.e. an interactive tree that you can zoom in/out with
17:26:33 <dons> here's the raw namespace .dot file http://galois.com/~dons/tmp/hackage.dot
17:26:33 <c_wraith> well, it'd be easy to automate producing a serious of dot files, including ones that expand my module or expand by package name
17:26:45 <dons> if anyone wants to have a go at visualising it
17:26:47 <Gracenotes> heug
17:26:50 <c_wraith> The trick is that there's no good way to switch between them on the fly
17:26:57 <pumpkin> wow
17:27:19 <Gracenotes> I didn't know dot files where that simple, either :)
17:27:26 <pumpkin> dot is a nice format
17:27:38 <Gracenotes> :D  O:
17:27:43 <Gracenotes> :O
17:27:53 <Peaker> hmm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2432#a2432
17:27:59 <dons> well, i'm sure there are smarter ways, but that's enough to get started
17:28:07 <EvilMachine> Gracenotes: how about having a browser for a file system for graphs? like a file manager
17:28:17 <dons> here's, e.g., my major libraries, http://code.haskell.org/~dons/images/dot.png
17:28:30 <dons> the darcs namespace http://code.haskell.org/~dons/images/darcs.png
17:28:32 <Peaker> oh, I see
17:28:42 <dons> xmonad, http://code.haskell.org/~dons/images/xmonad-dot.png
17:29:07 <pumpkin> you could structure it with the top-level names having an unnamed parent
17:29:16 <pumpkin> and use a radial display
17:29:35 <dons> we might have to get Jeff Hurd in on this
17:29:40 <dons> (visualisation + haskell guru)
17:29:40 <EvilMachine> i say, create directories and files and symlinks for the graph, and then show it in konqueror, with the tree fully expanded. :P only a tree, but better than nothing
17:29:47 <pumpkin> yeah!
17:30:10 <Gracenotes> I mean, you can use something like baobab on a bunch of GHC folders
17:30:18 <Gracenotes> Haskell libraries
17:30:33 <Gracenotes> which visualizes by disk space used
17:31:13 <tromp_> hmm, i wanted to combine State and Writer monads
17:31:22 <tromp_> so a made a StateT Writer
17:31:33 <tromp_> and now i dont see how to get the writer result out:(
17:31:44 <tromp_> did i wrap them the wrong way around?
17:31:45 <dons> $ fdp -Tpng /tmp/hackage.dot > /tmp/hackage.png
17:31:45 <dons> fdp: failure to create cairo surface: out of memory
17:31:45 <dons> zsh: segmentation fault  fdp -Tpng /tmp/hackage.dot > /tmp/hackage.png
17:31:48 <dons> :(
17:31:51 <Gracenotes> o nos
17:32:16 <dons> the base libraries : http://code.haskell.org/~dons/images/base-libraries.png
17:32:18 <Gracenotes> tromp_: runStateT should return a Writer, which you can then runWriter on
17:32:42 <Gracenotes> dons: hm, interesting, but doesn't really give you a good idea about the size of specific branches
17:33:14 <dons> visualisation is hard for compiler people. let's go shopping
17:33:24 <eu-prleu-peupeu> sleeppyy time, buy
17:33:32 <Gracenotes> @type runStateT
17:33:33 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
17:33:54 <tromp_> @hoogle runState
17:33:54 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
17:33:54 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
17:33:54 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
17:33:54 <EvilMachine> i think radial graphs are stupid. they take up too much space, when you want to manage stuff. do it like this: imagine the whole graph in 3d space. now grab the current node, and turn on gravity in two dimensions. you will get a 1-dimensional list/tree. now cut the links that would usually be symlinks. and every time you go to a sub/super-node (which then is the same), you re-hang the graph. tadaa. you get a compact graph
17:34:15 <tromp_> thx Gracenotes, i'll try that
17:34:26 <rovar> putBSONValue (BDouble d) = do putWord8 bson_number_dbl
17:34:27 <rovar>                               putWord64le $ unsafeCoerce $ ((realToFrac d) :: CDouble)
17:34:32 <Gracenotes> tromp_: so Monoid w => StateT s (Writer w) a -> s -> Writer w (a, s)
17:34:43 <rovar> there is my ugly function, but I think it'll work.
17:34:46 <Gracenotes> something like that
17:35:06 <Gracenotes> tromp_: also, if you have a long list with appending mostly to the end, use DList :D
17:35:12 <EvilMachine> by the way: organizing modules in a tree in haskell is stupid. everything can depend on everything. so a real full graph would be better suited
17:35:18 <rovar> - one of those $
17:35:52 <dons> there's a difference between how we classify the nodes, and how they import each other
17:35:58 <dons> the classification tree is simpler than the import graph
17:36:15 <dons> for the former use graphmod (things quickly get out of hand too :)
17:36:32 <tromp_> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html doesn't show runState
17:37:13 <tromp_> oh wait, it does:)
17:38:01 <idnar> I read "ruinState"
17:38:13 <EvilMachine> lol
17:38:54 <EvilMachine> Exception: State of World ruined. Program terminated.
17:39:28 <Raynes> Exception: You have destroyed the work. Program terminated.
17:39:37 <Raynes> s/work/world/
17:39:57 <Gracenotes> if the world had to end somehow, I'd prefer to it be by Haskell-launched nuclear missiles
17:40:10 <tromp_> hmm, it doesn't seem to match though. using Writer (a,s) would require Monoid (a,s), right?
17:40:13 <Gracenotes> *it to
17:40:25 <Gracenotes> tromp_: Writer w (a, s)
17:40:37 <tromp_> ah
17:40:44 <Gracenotes> @type runWriterT
17:40:45 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
17:41:19 <EvilMachine> Gracenotes: Naah. Semi-biological nanobots, developed in haskell, and running on haskell code, would be way cooler.
17:41:20 <Gracenotes> that would be, WriterT w (State s) a -> State s (a, w)
17:41:25 <Peaker> arrg! something's still wrong here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2432#a2433
17:41:47 <Gracenotes> @pl \s -> unions $ map (\a -> findWithDefault empty (s, a) steps) alpha
17:41:47 <lambdabot> unions . flip map alpha . flip flip steps . (findWithDefault empty .) . (,)
17:42:08 <Gracenotes> @type flip filp ?f
17:42:09 <lambdabot> Not in scope: `filp'
17:42:12 <Gracenotes> @type flip flip ?f
17:42:13 <lambdabot> forall a b c. (?f::b) => (a -> b -> c) -> a -> c
17:42:19 <Peaker> this is supposed to be one of the easier eulers, but its actually costing me the most retries yet
17:42:53 <EvilMachine> /test
17:42:58 <EvilMachine> damn. what the
17:43:19 <Eridius> Peaker: which euler?
17:43:31 <Peaker> Eridius: 36
17:43:36 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2432#a2433
17:43:49 <Eridius> ah hrm, never did that one
17:44:03 <Peaker> Eridius: see anything obviously wrong in my solution?
17:44:09 <pumpkin> what was the question?
17:44:16 <Eridius> Peaker: haven't read it yet
17:44:16 <pumpkin> oh
17:44:19 <pumpkin> you have the link
17:44:22 <Peaker> find all the numbers under 1 million which are pallindromes in base 2 and 10
17:44:34 <Eridius> yeah I was reading the problem description
17:44:55 <Peaker> it finds: [0,3,9,33,585,717,9009,15351,39993,53235,53835,585585] -- but some are missing?
17:45:06 <pumpkin> > sum [0,3,9,33,585,717,9009,15351,39993,53235,53835,585585]
17:45:07 <lambdabot>   758355
17:45:46 <monochrom> Do you think your program is slow?
17:45:50 <pumpkin> you're missing at least two
17:46:31 <Eridius> well, maybe your problem is that you're misspelling palindrome in your function names :P
17:46:34 <Peaker> hmm.. the way I generate all binary pallindromes is somehow wrong
17:46:37 <sjanssen> hmm, 2023 unread mails in my Haskell folder
17:46:39 <Peaker> heh
17:46:42 <pumpkin> sarah pallin
17:46:45 <pumpkin> sjanssen: wow
17:46:54 <idnar> is that all?
17:47:06 <Eridius> Peaker: you're mirroring numbers that end in 0
17:47:16 <Eridius> Peaker: [1,1,0] gets turned into [0,1,1,1,1,0]
17:47:19 <Eridius> and that's not valid
17:47:44 <Eridius> maybe startSeqs = replicateM 9 [0,1] ++ [1]
17:47:47 <Peaker> Eridius: map ((\xs -> xs ++ reverse xs) . dropWhile (==0)) $ replicateM 10 [0,1]
17:47:49 <sjanssen> pumpkin: to be fair, it looks like the last time I went through it was Feb 12
17:48:03 <Peaker> Eridius: dropWhile should remove those that start/end with 0
17:48:20 <Eridius> Peaker: you're dropping leading zeroes from the original number, but if there are trailing zeros that makes the mirrored number invalid
17:48:33 <Eridius> because a number with trailing zeroes gets mirrored into one with leading zeroes
17:48:38 <Peaker> Eridius: I am missing numbers though, not generating invalid ones?
17:48:42 <pumpkin> he's still finding fewer thatn he needs to be finding
17:48:50 <Eridius> ok, I'm just pointing out this problem
17:48:58 <Eridius> you're generating binary palindromes that are invalid
17:49:12 <Eridius> you're also missing one-digit binary palindromes
17:49:28 <Peaker> Eridius: if there were "trailing" zeros, they won't be trailing any more because of the (++ reverse xs)
17:49:29 <pumpkin> all 1 of them?
17:49:41 <Peaker> aha, that must be it :)
17:50:05 <Eridius> Peaker: oh hrm, I misread it, I thought he was prepending the mirror, not appending
17:50:07 <Eridius> but you're right
17:50:09 * Peaker switches to the naive approach of filtering by isPallindrome
17:50:28 <Eridius> Peaker: or you could just add all 1-digit binary palindromes to the front of your binPallindromes function
17:50:58 <pumpkin> :o
17:50:59 <Eridius> anyway, I gotta head out
17:51:06 * Eridius idles
17:51:08 <Peaker> Eridius: k, thanks
17:51:13 <pumpkin> how many 1-digit binary palindroms are there? :o
17:51:28 <Eridius> (log2 1000000) of them
17:51:43 <pumpkin> hmm
17:51:44 <Eridius> > logBase 2 1000000
17:51:45 <lambdabot>   19.931568569324174
17:51:54 <Eridius> so 20
17:51:57 <pumpkin> hmm
17:52:00 <Eridius> anyway, idle for real
17:52:05 <sjanssen> > replicateM 1 "01"
17:52:06 <lambdabot>   ["0","1"]
17:52:18 <sjanssen> 2!
17:52:24 <pumpkin> that's what I'd have thought
17:52:25 <Peaker> Eridius: missing not just the 1-lengthed but all odd-lengthed pallindromes
17:52:30 * dmwit is with sjanssen
17:52:37 <Eridius> Peaker: yes, true
17:52:43 <Peaker> ok, using the naive approach is so much simpler and more effective :)
17:53:00 <Peaker> filter isPalindrome . map (dropWhile (==0)) $ replicateM 20 [0,1]  :)
17:53:02 <Eridius> you could just adjust the mirror to generate 3 versions - the straight mirror, the mirror with a 0 and the mirror with 1 inserted
17:53:06 <Eridius> anyway, idle for double-real
17:54:42 <dmwit> Except for 0, all binary palindromes are odd.
17:57:10 <Peaker> dmwit: but not odd-lengthed
17:57:11 <dmwit> > let palindromesUnbuffered = [] : [0] : [1] : concat [[0:xs ++ [0], 1:xs ++ [1]] | xs <- palindromesUnbuffered in palindromesUnbuffered
17:57:12 <lambdabot>   <no location info>: parse error on input `in'
17:57:20 <dmwit> > let palindromesUnbuffered = [] : [0] : [1] : concat [[0:xs ++ [0], 1:xs ++ [1]] | xs <- palindromesUnbuffered] in palindromesUnbuffered
17:57:21 <lambdabot>   [[],[0],[1],[0,0],[1,1],[0,0,0],[1,0,1],[0,1,0],[1,1,1],[0,0,0,0],[1,0,0,1]...
17:57:47 <dmwit> > let palindromesUnbuffered = [] : [0] : [1] : concat [[0:xs ++ [0], 1:xs ++ [1]] | xs <- palindromesUnbuffered]; palindromes = 0 : [1 : xs ++ [1] | xs <- palindromesUnbuffered] in palindromes
17:57:48 <lambdabot>       No instance for (Num [a])
17:57:48 <lambdabot>        arising from the literal `0' at <inter...
17:57:56 <dmwit> > let palindromesUnbuffered = [] : [0] : [1] : concat [[0:xs ++ [0], 1:xs ++ [1]] | xs <- palindromesUnbuffered]; palindromes = [0] : [1 : xs ++ [1] | xs <- palindromesUnbuffered] in palindromes
17:57:57 <lambdabot>   [[0],[1,1],[1,0,1],[1,1,1],[1,0,0,1],[1,1,1,1],[1,0,0,0,1],[1,1,0,1,1],[1,0...
17:58:04 <dmwit> You're welcome.
17:58:11 <pumpkin> lol
17:58:17 <Peaker> dmwit: :-)
17:58:33 <dmwit> =)
17:58:56 <Gracenotes> hm. So if someone finds out how to solve Tetris in polynomial time (given all the pieces in advance), then I suppose the boolean satisfiability problem becomes solvable in polynomial time? :)
17:59:11 <dmwit> "solve" Tetris?
17:59:22 <Gracenotes> "winning"
17:59:31 <dmwit> All 's' pieces is not winnable.
18:00:01 <Gracenotes> you can't calculate that in polynomial time, though
18:00:33 <edwardk> Gracenotes: i thought the tetris problem was obtaining the optimal number of row reductions given the piece configuration, not merely the survival of the game ;)
18:01:11 <Gracenotes> http://arxiv.org/abs/cs.CC/0210020
18:01:19 <tromp_> weird, for fun i changed from StateT .. Writer... to WriterT  .... State ... and the program still worked!
18:01:23 <Gracenotes> "it is NP-complete to maximize the number of cleared rows, maximize the number of tetrises (quadruples of rows simultaneously filled and cleared), minimize the maximum height of an occupied square, or maximize the number of pieces placed before the game ends"
18:01:40 <pumpkin> that's not winning!
18:01:43 <pumpkin> winning is getting the rocket ship
18:01:45 <tromp_> i expected i'd have to change the execWriter . (`evalStateT` init)
18:01:53 <pumpkin> :)
18:01:57 <Gracenotes> even if you get all s pieces, it's possible to clear rows
18:02:09 <Gracenotes> I'm pretty sure.
18:02:17 <pumpkin> are they all facing the same way?
18:02:28 <idnar> all 's' pieces lets you clear all rows except the bottom one, doesn't it?
18:02:36 <Gracenotes> you are allowed rotation, of course
18:02:54 <edwardk> yes
18:03:01 <Gracenotes> pumpkin: you mean z? :)
18:03:12 <pumpkin> ah, yes :P
18:03:24 <edwardk> now, given all 4-square blocks on a board of odd width, you'd be hard pressed to clear ;)
18:03:28 <idnar> I don't think it matters if it's 's' or 'z'
18:04:10 <pumpkin> edwardk: you just have to push hard
18:04:15 <edwardk> =)
18:04:45 <idnar> you just drop them from left to right in vertical position
18:05:46 <idnar> (or right to left, or... whatever)
18:06:36 <Peaker> ok, this is too slow: euler35 = filter (all (isPrime . read) . sortNub . perms . show) [1..999999]
18:06:50 <Chandon> Isn't the unwinnable case a random sequence of S and Z pieces?
18:07:08 <pumpkin> Peaker: I can imagine :P
18:07:45 <Eridius> Peaker: what is your isPrime?
18:08:09 <pumpkin> is perms permutations?
18:08:17 <pumpkin> you want rotations don't you?
18:09:36 <Eridius> perms xs = let n = length xs in map (take n) (take n (tails (cycle xs)))
18:09:40 <Eridius> that seems like a good definition that does rotatoins
18:09:43 <Eridius> *rotations
18:09:48 <Gracenotes> but, anyway, apparently solving tetris in polynomial time lets you solve SAT in polynomial time.
18:10:05 <Gracenotes> NP seems funny like that, it's a very high-stakes complexity class ;)
18:10:39 <pumpkin> you mean like minimum xs?
18:10:58 <Peaker> here's my isPrime: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2434#a2434
18:11:02 <Peaker> not a very clever one
18:11:23 <centrinia> Peaker, You can first filter out any number that has an even digit.
18:11:29 <Eridius> Peaker: http://github.com/kballard/projecteuler-haskell/blob/5c1aa8a768b4487038e4cd7731d2a96d4008083d/Sieve.hs might help
18:11:40 <centrinia> You can also filter out any number that is not a prime.
18:11:51 <defun> :t (!!)
18:11:52 <lambdabot> forall a. [a] -> Int -> a
18:11:55 <Eridius> anyway, time for me to leave
18:11:58 <Eridius> (again)
18:12:05 <centrinia> You can also filter out any number that has a five as a digit.
18:12:27 <pumpkin> and a 0?
18:12:33 * Gracenotes waves g'bye
18:13:14 <Peaker> Eridius: I'd rather not use any fancy stuff that isn't clear, if its not completely necessary
18:13:43 <Peaker> centrinia: how come all primes have no even digits?
18:13:51 <pumpkin> you have rotations
18:13:54 <pumpkin> at some point it'll be the last digit
18:14:04 <pumpkin> same with 5 and 0
18:14:06 <Peaker> oh, in light of this problem :)
18:14:16 <Peaker> I thought in general about generating primes
18:14:28 <pumpkin> ah, no :P
18:15:10 <centrinia> pumpkin, I made a program that converts lambda calculus expressions to SK combinatory logic expressions: http://centrinia.dyndns.org/lambda.html
18:15:31 <centrinia> pumpkin, zero is even. ;)
18:15:43 <centrinia> I already said that he should filter out the even digited numbers. :p
18:16:46 <solidsnack> dons: I think that whole C-is-everywhere thread on Reddit is not going well.
18:18:31 <Peaker> solidsnack: where?
18:19:46 <solidsnack> http://www.reddit.com/r/programming/comments/84udm/ask_proggit_every_day_i_read_dozens_of_posts/c0890h5
18:20:15 <solidsnack> I only bring it up because dons is a "standard bearer" for Haskell.
18:21:08 <dons> solidsnack: shrug
18:21:46 <dons> the internets are like that.
18:22:29 <solidsnack> dons: Fair enough.
18:23:14 <solidsnack> I am concerned that Haskell is going to peak soon, the same way Ruby did a couple of years ago.
18:23:30 <solidsnack> Ruby's reputation was really damaged by all those Rails goons.
18:23:45 <tromp_> :t chr
18:23:46 <lambdabot> Int -> Char
18:23:46 <centrinia> Rails goons?
18:23:47 <solidsnack> It was in everybody's faces all the time and they got to hate it.
18:23:53 <tromp_> > chr 0
18:23:54 <lambdabot>   '\NUL'
18:23:57 <tromp_> > chr 2
18:23:57 <callen_> solidsnack: the merge is going to improve things.
18:23:58 <lambdabot>   '\STX'
18:24:01 <dons> well, i'm not sure we've had a spike or anything
18:24:04 <tromp_> > chr 255
18:24:05 <lambdabot>   '\255'
18:24:07 <dons> we've just had a fairly steady growth in contributors
18:24:22 <dons> and its not like ghc has stopped
18:24:32 <solidsnack> dons: All true.
18:24:46 <solidsnack> callen_: Merge? Of Merb & Rails?
18:24:54 <dons> so until the new innovations in ghc stop, probably nothing's going to change - they'll be continued growth, with fits and bursts around books, new projects, and articles.
18:24:58 <nominolo> also, Haskeller's as such have a good reputation
18:25:14 <solidsnack> At present, sure.
18:25:16 <callen_> solidsnack: yes.
18:25:23 <Chandon> Is there anything clever I have to do to get a program that does 'import Control.Parallel' to build with GHC?
18:25:31 <shepheb> Haskell has hardy had the hype explosion Ruby did. Buzz, certainly, but not what Rails did two years ago.
18:25:40 <solidsnack> Sure.
18:25:43 <idnar> solidsnack: I don't think anyone that actually matters listened to the "Rails goons"
18:26:04 <callen_> idnar: Zed disagrees.
18:26:07 <solidsnack> People came to dislike the language and community as a whole, though.
18:26:21 <dons> Chandon: cabal install parallel
18:26:26 <sjanssen> Chandon: you need to install the parallel package
18:26:29 <sjanssen> @hackage parallel
18:26:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel
18:26:31 <callen_> solidsnack: I like ruby in spite of the community, even if it slower than frozen piss on a 5 degree incline.
18:26:41 <solidsnack> callen_: I like Ruby as well.
18:26:44 <idnar> callen_: the story he tells seems to confirm my conclusions, though
18:26:49 <solidsnack> I did watch people sour on it, though.
18:27:09 <idnar> callen_: if anything, his problem seems to be that he bought into a Ruby community that turned out not to exist (at least, not on the scale he thought it did)
18:27:35 <Chandon> dons: Apparently having cabal installed is a prerequisite for that strategy...
18:27:46 <idnar> IMO, the real problem with Ruby isn't Rails, but the "go after Java programmers" strategy
18:27:54 <shepheb> lurking the Ruby community has something of the flavour of watching a saloon fight. entertaining, perhaps, but you don't want to get involved.
18:28:01 <dolio> parallel should come with GHC, no?
18:28:01 <Valodim> Chandon: yeah but having cabal installed makes sense either way
18:28:21 <dolio> Unless it's meticulously split into a different package by your distro.
18:28:23 <sjanssen> Chandon: you don't necesarily need cabal-install, just use the usual 'runghc Setup' stuff
18:28:36 <solidsnack> Chandon: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
18:28:43 <sjanssen> dolio: parallel is not a bootlib, so most distros package it separately now
18:28:50 <dons> Chandon: it depends on your platform
18:28:51 <dolio> Ah.
18:28:57 <dons> you might have distro packages for the parallel library
18:28:58 <idnar> anyhow, I don't think anyone is trying to build a Haskell hypetrain yet, so there's not too much to worry about
18:29:05 <dons> short of distro support, the next step is to use cabal to get it yoursefl
18:29:23 <idnar> (there are some "hypeish" memes, but I think they're too abstract to be potentially damaging)
18:29:41 <sjanssen> Chandon: if you're on a Debian-like 'apt-get install libghc6-parallel-dev'
18:30:19 <solidsnack> idnar: Haskell has become dramatically more visible in the past year -- so much so, that people complain about it openly on Reddit.
18:30:28 <dolio> All haskellers are ex-lisp-using blogger who never really understood the greatness of macros. :)
18:30:32 <shepheb> that isn't new, either.
18:30:35 <dolio> Bloggers, even.
18:30:43 <johnw> dolio: is that a reference to me? ;)
18:30:57 <solidsnack> idnar: It is not really the presence of hype but the perception of it that is damaging, anyways.
18:31:03 <Chandon> sjanssen, I still had link errors after doing that. Now I'm trying with the latest GHC binary release.
18:31:10 <dolio> johnw: I don't know. That depends who you are.
18:31:11 <dons> solidsnack: yeah, shrug. those people can learn to use downmods. and anyway, the haskell community is big enough to produce a dozen releases a day, so 1 or 2 articles seems appropriate
18:31:24 <sjanssen> Chandon: link errors?  Sounds like you should be building with --make or a -package flag
18:31:27 <johnw> dolio: an ex-lisp using blogger who recently was scolded for not giving CL's macro system justice
18:31:42 <dons> i don't see why we should slink off into a corner because some java guy is pissed.
18:31:44 <dolio> Oh, did you write Goodbye Lisp...?
18:31:45 <sjanssen> Chandon: what sort of build system does this application use?
18:31:48 <johnw> dolio: In fact, I'm deeply aware of what CL's macros can do, I just didn't choose to go into depth in my blog entry
18:31:49 <idnar> solidsnack: if you don't climb onto a hypetrain, you can't fall off; it's the people who fall off a hypetrain that really get bitter about it
18:31:52 <johnw> dolio: yep
18:31:58 <Philippa_> idnar: I can think of a meme or two I'd happily ditch, FWIW
18:31:59 <idnar> solidsnack: the rest of the people whining about it don't matter
18:32:10 <pumpkin> centrinia: omg you're right! I'm gonna write a paper on that
18:32:12 <pumpkin> (bbl)
18:32:13 <solidsnack> Philippa_: Like?
18:32:13 <dolio> johnw: Ah, well then, yes it was a reference to you. :)
18:32:24 <Philippa_> @faq can Haskell do without self-congratulation via lambdabot?
18:32:24 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:25 <Chandon> sjanssen, The "application" is the program "import Control.Parallel; main = return ()'
18:32:25 <centrinia> pumpkin?
18:32:33 <johnw> dolio: well, point taken, I think CL's macros are fantastic btw, I didn't mind to demean them at all by my entry
18:32:35 <sjanssen> Chandon: how are you building it?
18:32:44 <idnar> Philippa_: oh, sure, I'm not disagreeing with that; I just think the "problematic" ones are too abstract to seriously burn people
18:32:53 <solidsnack> dons: I think it's gaining negative attention. I don't think that means anyone has done anything wrong. I just wanted to call attention to that.
18:33:01 <dolio> johnw: Well, it was more a jab at the people accusing you. I think macros tend to be over-sold.
18:33:06 <Philippa_> idnar: yeah, they're more the sort to annoy people and/or give certain impressions about the community
18:33:20 <Chandon> sjanssen, "ghc -o xx xx.hs"
18:33:21 <callen_> idnar: I more or less agree with Zed. doesn't mean I have to care.
18:33:24 <Philippa_> I wouldn't mind with @faq except just occasionally you see someone use it who doesn't /actually/ know the answer
18:33:25 <idnar> ultimately, it's the people actually doing stuff that matter, not the people who just talk about doing stuff
18:33:26 <dons> solidsnack: yeah, the comparative language posts in general don't help much, i suspect.
18:33:28 <ehirdghost> hi johnw, i liked the entry fwiw
18:33:30 <johnw> dolio: it just semed to me that Haskell removes the need of them in many cases, which I find wonderful in its own way
18:33:33 <sjanssen> Chandon: use -package parallel or --make
18:33:35 <johnw> ehirdghost: thanks!
18:33:38 <dons> they incite flames more than just explaining what we're doing does.
18:33:40 <Philippa_> idnar: mostly I'm one of the latter :-) Mostly, anyway
18:33:41 <dolio> johnw: People retort with stuff like, "you can write an ad-hoc type system with macros!" But I doubt such things are representative of what most people actually use macros for.
18:33:46 <dons> luckily they're mostly rare
18:34:05 <dons> it's a good reminder to get back to work churning out interesting apps and libs.
18:34:12 <Philippa_> dolio: that, and the obvious response is "yeah, and I can write a lisp interpreter in TH too"
18:34:14 <solidsnack> dons: No argument there :)
18:34:33 <idnar> that's not to say that discussion isn't of value, but it's the people actually /doing/ stuff that drive adoption / development / etc.
18:34:44 <goomba> as long as haskell is inspired by maths and logic it should theoretically be around forever
18:34:54 <idnar> so if the doers keep doing, it really doesn't matter if the talkers stop talking
18:34:56 <goomba> if people keep working on it, that is :p
18:35:00 <solidsnack> Well, even Ruby survived.
18:35:02 <dons> and i still feel that we should counter stereotypes and mistakes, with solid evidence, at every turn. no need to be backward in coming forward.
18:35:14 <Philippa_> goomba: eh, I don't know about that. One of the dependently-typed successor langs will eventually replace it outright
18:35:30 <Philippa_> dons: agreed
18:35:35 <ehirdghost> dons: it doesn't work; because then they claim you're obsessive/trying to paper over the shortcomings
18:35:36 <Chandon> sjanssen, That seems to work. Thanks.
18:35:43 <idnar> take a look at Python's growth; it doesn't have anywhere near the ridiculous levels of hype that Rails has going, and yet there's a pretty huge "silent" Python userbase just getting on with doing things
18:35:45 <goomba> Philippa_, i guess, but i wont complain when that happens...
18:35:48 <ehirdghost> that sentiment seems to be common on reddit thesedays
18:35:49 <solidsnack> dons: Discretion, however, is the better part of valor.
18:35:57 <ehirdghost> solidsnack++
18:35:59 <idnar> it seems to me that Haskell is starting to build the same kind of userbase, which is awesome
18:36:03 <dons> ehirdghost: well, advice is welcome.
18:36:30 <dons> if someone says something stupid/false, i'm probably always going to smack 'em down (hopefully politely). correct the misperceptions as we go.
18:36:32 <ehirdghost> dons: I don't think the people who flame haskell will ever turn into users... I think a majority of them are just trollish and not worth the effort
18:36:39 <dons> yes, certainly
18:36:42 <dons> not worth the effort.
18:36:42 <Philippa_> ehirdghost: that's okay, you're not trying to respond to those individuals. Though you want to be fairly careful about distinguishing between "it'll do" fixes, rock-solid general techniques and "actually, having used this I wouldn't want to do it your way anyway" (monads/monad transformers!)
18:36:57 <ehirdghost> Philippa_: mm
18:37:08 <centrinia> What kinds of flames does Haskell receive?
18:37:20 <callen_> centrinia: IT'S TOO HARD BAWWWWWWWWWWWWWWWWW
18:37:25 <centrinia> Oh.
18:37:26 <callen_> any other questions?
18:37:29 <Philippa_> centrinia: "zomg PHD!!1!" and "it's not real world" are the most common
18:37:32 <ehirdghost> centrinia: Nobody uses it! Duh.
18:37:36 <Philippa_> and yeah, that one
18:37:37 <solidsnack> I think the biggest now is "Why the Hell are there all these Haskell posts?".
18:37:38 <centrinia> Sorry I asked. :(
18:37:40 <ehirdghost> centrinia: Also, monads are a hack for its shortcomings.
18:37:41 <goomba> centrinia, i saw someone mocking the virtues of the short length of programs
18:37:45 <dolio> @quote qwe1234 haskell
18:37:45 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
18:37:51 <Raynes> "It's not practical and nobody uses it"
18:38:17 <solidsnack> It's the presence of "meta-flames" that worry me, I guess.
18:38:26 <dolio> @quote qwe1234 haskell
18:38:26 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
18:38:28 <solidsnack> They aren't even flaming Haskell with that.
18:38:34 <shepheb> I prefer the response of Perl people when "Perl is dead/dying comes up." "Yeah, yeah. I'm going to just carry on getting things done." same as dons' point about keeping on with making sweet libraries.
18:38:40 <dons> there's 1 - 2 haskell posts a day because people are doing new things in it.
18:38:49 <Philippa_> is there a good "when you have to write Haskell-as-a-better-Java/C++/C#/... rather than good Haskell..." resource yet?
18:38:50 <Peaker> dolio: is that an actual g uy?
18:38:52 <Valodim> people don't like the whole "think more, type less" deal
18:38:57 <ehirdghost> Peaker: yes
18:38:58 <Philippa_> a single point that covers the main techniques?
18:39:01 <ehirdghost> he's on reddi
18:39:01 <ehirdghost> t
18:39:04 <ehirdghost> he's also serious
18:39:11 <Peaker> C++ templates are duck-typed!
18:39:14 <solidsnack> dons: I'm not saying there isn't a good reason for those posts. I'm just saying, there is a side-effect of which we should be cognizant.
18:39:14 <dolio> Peaker: It's at least a facade.
18:39:30 <idnar> static duck-typing, woo!
18:39:37 <dons> yeah
18:39:39 <mauke> more like templates are untyped
18:39:46 <mauke> and unkind
18:39:50 <dons> the internets is a big swamp anyway
18:39:51 <Peaker> mauke: "duck" is the new "un"
18:39:54 <Philippa_> Valodim: they would more with better tool support, I suspect. On-the-fly typechecking could work wonders for some people's workflow
18:39:59 * idnar giggles at unkind
18:40:06 <solidsnack> dons: It's the swamp our little boat is on.
18:40:07 <Valodim> definitely
18:40:14 <Philippa_> heh. Yeah, unkind is cute :-)
18:40:31 <Philippa_> solidsnack: we move by, er, purifying the water around us though
18:40:37 <mauke> Peaker: http://www.albinoblacksheep.com/flash/llama
18:40:52 <idnar> the interswamps
18:40:58 <idnar> flow through the tubes
18:40:59 <solidsnack> idnar: LOLz.
18:41:31 <Valodim> hehe, tubes..
18:41:43 <solidsnack> It's not unreasonable to suppose that Haskell will remain a curiosity for the next ten years.
18:42:10 <Cale> solidsnack: Curiosity in what sense?
18:42:16 <solidsnack> I don't think most people will appreciate it.
18:42:17 <Peaker> mauke: :-)
18:42:28 <solidsnack> Cale: It'll be like fine green tea or something like that.
18:42:41 <Valodim> I doubt it will ever lose the reputation of being kind of an elite hobby..
18:42:43 <solidsnack> They'll like to hear about the mountains but they won't really know why it tastes good.
18:42:50 <Gracenotes> aww, the llama song. I haven't heard that in a good six months.
18:42:59 <mauke> s/months/years/
18:43:01 <Valodim> more like years
18:43:04 <Valodim> haha
18:43:15 <dons> well, reading over that thread, it's not that bad actually. there's lots of opinions, many good points made
18:43:22 <dons> and it'll all be forgotten tomorrow
18:43:35 <Gracenotes> heh. Yeah, first time I watched it /was/ a few years ago...
18:43:49 <solidsnack> dons: What is reinforced is what we'll remember.
18:43:51 <dons> at some point, just having new people know that haskell exists and is a programming language that might be interesting is useful.
18:44:14 <dons> i'm not sure how to summarise the message of the total thread. it's too diverse
18:44:24 <monochrom> mountains are supposed to be tasted?
18:44:38 <dolio> Really, complaining that there are two haskell posts a day is ridiculous. dons used to post every bit of haskell news to the programming reddit. :)
18:44:40 <solidsnack> monochrom: I mean, the beautiful mountains where the tea is grown.
18:44:54 <dolio> 2/day is way down from that.
18:45:04 <solidsnack> dolio: Actually, that's not how I initiated this conversation.
18:45:33 <dolio> I'm talking about the subject of the reddit posting.
18:45:49 <solidsnack> dolio: That's actually in the reddit thread?
18:45:49 <monochrom> I have doubts on people who use analogies so extensively.
18:45:50 * Cale completely fails to understand this discussion. Oh well :)
18:46:08 <solidsnack> monochrom: Well, okay.
18:46:23 <solidsnack> I mean, it takes some knowledge to appreciate Haskell.
18:46:28 <solidsnack> To really like it.
18:46:46 <solidsnack> People who don't have that knowledge, who don't appreciate it, will come to feel excluded.
18:46:50 <solidsnack> It's snobby.
18:46:53 <dolio> solidsnack: Oh, did you link to the C/C++ one? I hadn't seen that. I don't visit reddit much.
18:47:02 <solidsnack> dolio: Yes.
18:47:24 <shepheb> the community really couldn't be more welcoming of newbies, though.
18:47:44 <shepheb> so if it's intimidating at first, the ones who brave it have a wonderful experience.
18:47:46 <Valodim> even though it makes their brain asplode every once in a while
18:47:51 <monochrom> "People who don't have that knowledge, who don't appreciate it, will come to feel excluded."  This is leap of faith.
18:47:54 <solidsnack> shepheb: Well, a newbie is someone whose chosen to try, though.
18:48:19 <monochrom> Problem #1: How do you know how people feel.  Problem #2: How do you know that knowledge transfer is impossible.
18:48:22 <solidsnack> monochrom: I am not able to provide a proof :)
18:48:37 <solidsnack> It is not about impossible.
18:48:42 <solidsnack> They just don't have time.
18:49:16 <Valodim> or patience
18:49:56 <shepheb> and? if they're lacking time, there doesn't seem to be any difference we can make
18:50:23 <Valodim> still, the "feeling excluded" thing is kinda what humans do. all the time, actually..
18:50:31 <Philippa_> monochrom: #1, from having (however briefly) felt bits of it as a newbie. #2 we don't and that's not the issue at  all
18:50:42 <solidsnack> monochrom: Part of the reason that I made the remark about tea (or any other food) is because we see that sort of thing in our lives. Folks have hobbies we don't share. Depending on our experience of these people, we come to see these hobbies as harmless, positive or really annoying.
18:50:50 * Cale fails to see how it's snobby. If beginners come here and ask questions, are we not ever so happy to answer them?
18:50:51 <monochrom> Godawful. The most introductory programming class presupposes knowledge that some people don't already possess, too. You may as well conclude that programming is snobbish and non-programmers feel excluded and all that crap.
18:51:30 <solidsnack> monochrom: They do, don't they?
18:51:31 <Philippa_> monochrom: the problem's more that it's hard finding out what the shared knowledgebase looks like
18:51:41 <solidsnack> I have irritated a lot of people with my programming, actually.
18:51:53 <shepheb> the average person off the street has no conception of what programming is like. the scorn of other programmers is flatterin compared to blank ignorance.
18:51:59 <solidsnack> I had to learn to keep it sequestered so as not to irritate certain people.
18:52:05 <Valodim> monochrom: um, yes. they definitely do.
18:52:09 <Philippa_> by comparison, we can at least compare the contents of a typical education for beginners' classes
18:52:20 <Philippa_> solidsnack: easily done, that
18:52:24 <idnar> Valodim: there's nothing you can do about people like that, though
18:52:30 <solidsnack> Especially people who thought they should easily understood what I was talking about -- folks who had a little CS in college or whatever.
18:52:30 <Valodim> indeed
18:52:55 <solidsnack> idnar: You can make your interaction with them more smooth.
18:53:12 <Philippa_> solidsnack: that one's always tricky. The best language for communicating with programmers-in-general isn't the best language for eg thinking in
18:53:27 <idnar> solidsnack: I don't see how; we're talking about people who choose to feel excluded, because it's easier than learning
18:53:38 <Philippa_> even explaining constraint systems can be a pain - /especially/ if they never touched prolog
18:53:49 <Philippa_> idnar: human minds don't work that way
18:53:52 <solidsnack> idnar: Do not make what they are excluded from visible to them.
18:53:56 <Valodim> idnar: help them overcome their fault :)
18:54:04 <solidsnack> They don't see it, it doesn't bother them.
18:54:26 <idnar> solidsnack: that's hard to do without making it invisible to people who shouldn't be excluded; and I'd prefer to err on the other side of that dividing line
18:54:35 <Valodim> solidsnack: that sounds contraproductive
18:54:37 <Philippa_> there're plenty who respond to that feeling of exclusion by learning, but the feeling of exclusion is not, itself, a practical on-the-spot choice
18:54:41 <shepheb> I came to Haskell after hearing it mentioned a few times, with the tone of being a tough and rewarding intellectual challenge. the sort of programmer drawn by that is exactly the sort of people I want to work with.
18:54:51 <solidsnack> Philippa_: Aye, I agree with that.
18:55:21 <Philippa_> and honestly? Describing it as if it is - even if over time you can influence how strongly you're likely to feel it in such situation - really is snobby and elitist
18:55:24 <idnar> Philippa_: I actually mean "complain about it" not "feel"; I'll admit most people don't have much control over that feeling
18:55:51 <Philippa_> it's the choosing not to learn that's important
18:55:52 <solidsnack> shepheb: All I am saying is, there are way more programmers who aren't going to join. Their opinions matter, as well.
18:56:00 <Philippa_> and don't forget, people have a lot of things competing for their time
18:56:07 <idnar> Philippa_: but there's no point in complaining about being excluded from something when you're the only person who can change that
18:56:15 <solidsnack> The super-elite want the proles to feel happy :)
18:56:30 <solidsnack> idnar: It's not about what they should do, though.
18:56:35 <Philippa_> idnar: actually, the complaints have helped encourage us to refine our tutorial material no end
18:56:41 <solidsnack> It's about managing their reaction to be beneficial to us.
18:57:22 <solidsnack> Anyways, I fear that this really should go on #haskell-blah.
18:57:35 <shepheb> solidsnack: sure. most of them are ignorant, indifferent or dismissive.
18:57:36 <idnar> Philippa_: "I couldn't figure out this part of the tutorial" is a completely different scenario to "these Haskell guys are such a bunch of elitist wankers"
18:57:56 <solidsnack> shepheb: They are all God's children, too.
18:58:20 <Cale> solidsnack: If some people don't want to use the language, then let them. There are things more important than having lots of users, anyway.
18:58:23 <Philippa_> idnar: and there's a wide spectrum between, and even those last ones /where it can be traced back to things we could've done better/ are useful
18:58:27 <solidsnack> Anyways, let's continue this on #haskell-blah, eg?
18:58:43 <solidsnack> Cale: It's not about that/
18:58:49 <idnar> Philippa_: if newbies try to learn what's necessary to participate in a community, or a discussion, or whatever, and fail due to barriers to learning, or lack of support / assistance, then that's something that can be fixed
18:59:01 <Cale> I don't really understand this discussion...
18:59:05 <solidsnack> Cale: We want people to love the language or to think we're nice. If people hate us, that's the problem.
18:59:15 <Philippa_> *nod*
18:59:20 <Philippa_> we want the community to have a good rep
18:59:24 <idnar> Cale: quick, post on your blog about how you're being excluded from #haskell discussions!
18:59:26 <Cale> Well, yes, but doesn't it?
18:59:43 <Cale> The community, last I checked, had a great reputation.
18:59:57 <idnar> Philippa_: but if you have people who feel excluded because they don't know enough, but aren't interested in learning anything at all... then there's nothing you can do
18:59:59 <Philippa_> Cale: easy to say from within it :-)
19:00:04 <solidsnack> This language is becoming too popular and too much talked about.
19:00:05 <Valodim> indeed it does
19:00:08 <solidsnack> Danger, danger!
19:00:13 <Cale> Philippa_: Well, I've heard nothing but good things about it.
19:00:17 <idnar> Philippa_: the only thing that would satisfy them is to just eliminate any activity in the areas they're lacking in knowledge
19:00:31 <Valodim> @google "Why Haskell sucks"
19:00:32 <lambdabot> No Result Found.
19:00:36 <idnar> these are the kinds of people who want to pass laws defining pi = 3 or whatever
19:00:51 <Philippa_> idnar: frankly, that feels like a straw man. I'm far more worried about the people who merely aren't finding where to learn from sufficiently in a reasonable-to-them length of time
19:00:53 <Valodim> aw. well, the only hit is a rather ironic blog post :P
19:01:09 <Philippa_> which is a group that contains, say, Andrew Coppin
19:01:17 <monochrom> Please don't try to please everyone.
19:01:34 <Philippa_> monochrom: not advocating that :-)
19:01:36 <solidsnack> monochrom: It's not lack of pleasure but presence of spite that concerns me.
19:02:03 <Philippa_> *nod*. And the appearance that those who are spiteful have valid concerns
19:02:16 <solidsnack> Well, even if they have invalid ones.
19:02:28 <Philippa_> I chose my words carefully ;-)
19:02:35 <solidsnack> A lot of spiteful people all spiting the same thing is not good.
19:02:38 <shepheb> there's no way we'll eliminate negative criticism. the best we can do is provide evidence against straw man arguments and misconceptions, and get back to work.
19:03:08 <jlouis> especially when a negative critisism is just a blog-post away
19:03:13 <solidsnack> I fear that threads like the one I linked to are indicative of spite being built up by the Haskell community's actions/
19:03:24 <solidsnack> It's not criticism that concerns me.
19:03:29 <idnar> shepheb: and there's only value in engaging against straw men and misconceptions when there is a realistic chance of changing someone's perspective
19:03:30 <shepheb> solidsnack: can you provide a history of such sentiment growing?
19:03:46 <solidsnack> Like, with dates and stuff?
19:03:48 <solidsnack> No.
19:03:50 <idnar> shepheb: so, for example, there's no point in engaging a troll for non-recreational purposes, unless you feel that bystanders are being mislead
19:03:54 <shepheb> solidsnack: seems to me there was a statistical burst of Haskell posts to the main proggit
19:03:57 <Philippa_> idnar: there's always an audience. I've not really been arguing to convince you here, for example
19:03:59 <shepheb> solidsnack: and then a little backlash
19:04:03 <shepheb> a week, tops.
19:04:21 <solidsnack> I think it's been going back and forth like that for months.
19:04:52 <idnar> it's perfectly possible to string out an illogical debate forever; if you engage all the trolls, you'll get tired before they do (and there are more of them than there are of you)
19:05:07 <solidsnack> Right.
19:05:14 <solidsnack> Hide from the trolls.
19:05:47 <shepheb> even if we do want to address Haskell's "marketing", this is hardly the place, or the biggest problem.
19:05:58 <idnar> Philippa_: I think we're pretty much on the same page anyhow, just emphasising different things
19:06:06 <shepheb> allowing ourselves to be trolled just appears as zealotry
19:06:21 <solidsnack> shepheb: Perhaps you are right. My choice of venue is maybe inappropriate.
19:06:40 <shepheb> "Yeah, and it sucks for real world apps too. I'm going to get back to writing this audio library."
19:06:41 <solidsnack> However, dons was not in -blah, so I came here.
19:06:54 <shepheb> I didn't mean #haskell, I meant reddit.
19:07:33 <shepheb> one of the valid criticisms of Haskell is that its libraries up to the level of, say, Python's, or Perl's. so let's keep hacking away. that's a public impression we can do something about.
19:07:44 <shepheb> libraries aren't up to the level of, I mean
19:08:31 <solidsnack> I think I've said enough.
19:11:01 <solidsnack> Obviously, I don't think it's very nice to come in here and criticize dons for things that are happening on reddit.
19:11:13 <bogner> hmm, trying to upgrade gitit, but it requires datetime-0.1, which requires oldtime-1.0.0.1, which doesn't seem to be on hackage. anyone know where to go from there?
19:11:36 <solidsnack> Perhaps I am a victim of a certain self-importance that comes with social media.
19:12:04 <Philippa_> just don't build the tower of infinite meta out of that?
19:17:17 <FunctionalPath> Hello, maybe we could just explain to masses that if they learn Haskell, they will understand upcoming buzzwords... Java Closures, Microsoft LINQ, and whatever marketroids come up with...
19:17:46 <shepheb> there's orders of magnitude more scorn for buzzwords than for Haskell
19:17:51 <shepheb> at least on reddit.
19:18:25 <FunctionalPath> :( sad but true
19:19:11 <Philippa_> OTOH, what you do with the knowledge afterwards is up to you
19:19:37 <Philippa_> knowing what can be usefully done with them is useful, as is knowing what can't
19:19:57 <Philippa_> to put it another way, being reasonably buzzproof without shutting yourself off from exploiting advances
19:20:45 <Philippa_> in a sense, that actually makes knowing haskell /more/ important if you're in any kind of lead or management role and need to make decisions about 'mainstream' tech
19:33:58 <dons> anyone know of a tool to visualise very large .dot graphs effectively?
19:36:03 <MyCatVerbs> dons: er, isn't that what graphviz is for?
19:36:15 <dons> yeah, but it segfaults
19:36:24 <MyCatVerbs> Oh bummer.
19:36:37 <CakeProphet> ...can anyone help me understand discrete real fourier transforms?
19:36:41 <mreh> is there an integer division operator that does the rounding?
19:36:53 <monochrom> > 10 `div` 3
19:36:54 <lambdabot>   3
19:37:02 <mreh> however
19:37:10 <mreh> > 10 `div` 4
19:37:11 <lambdabot>   2
19:37:16 <mreh> bbbzzzzzzzzzzzzz
19:37:19 <mreh> = 3
19:37:21 <monochrom> That is the rounding I want.
19:37:22 <dolio> > round $ 10 % 3
19:37:23 <lambdabot>   3
19:37:29 <dolio> > round $ 11 % 3
19:37:30 <lambdabot>   4
19:37:42 <mreh> swwwweeeet
19:38:01 <Gracenotes> oh. that is a nice use of Ratio :D
19:38:24 <CakeProphet> :t %
19:38:26 <lambdabot> parse error on input `%'
19:38:29 <CakeProphet> :t (%)
19:38:30 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
19:38:42 <CakeProphet> is Ratio an Integral?
19:38:45 <mreh> is % in the prelude?
19:38:52 <monochrom> Data.Ratio
19:39:04 <monochrom> Ratio is not an Integral.
19:39:11 <mreh> you mean it's in Data.Ratio?
19:39:16 <monochrom> Yes
19:39:20 <mreh> ta
19:39:56 <mreh> how do i import an infix operator explicitly?
19:40:02 <mreh> import Data.Ratio (%)
19:40:13 <monochrom> import Data.Ratio((%))
19:40:17 <mreh> a
19:40:48 <Gracenotes> a Ratio is two Integrals
19:42:42 <Gracenotes> yay, my NFA->DFA converter now uses a minimal number of states :) Now to minimize the number of states even further...
19:42:56 <Gracenotes> hm, then I suppose it isn't minimal.
19:43:10 <Gracenotes> Minimal without analysis of states that can be consolidated
19:48:01 * gwern reads a review of TaPL. 'advanced type constructs such as monads'
19:48:21 <gwern> no wonder I don't really understand monads! if they're advanced for a guy that *teaches* TaPL! :)
19:51:23 <mreh> :t zipWith
19:51:25 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
19:52:51 <mreh> >let blah a b = (a,b) in zipWith blah [1..10] (cycle [1..10])
19:53:08 <mreh> will that exit?
19:53:20 <Lemmih> mreh: Yes.
19:53:33 <mreh> > let blah a b = (a,b) in zipWith blah [1..10] (cycle [1..10])
19:53:34 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
19:53:40 <mreh> schweet
19:53:56 <Lemmih> > zipWith (,) [1..10] (cycle [1..10])
19:53:57 <lambdabot>   [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
19:54:15 <mreh> >zipWith (,) [1..10] (cycle [1..3])
19:54:20 <mreh> > zipWith (,) [1..10] (cycle [1..3])
19:54:21 <lambdabot>   [(1,1),(2,2),(3,3),(4,1),(5,2),(6,3),(7,1),(8,2),(9,3),(10,1)]
19:54:34 <mreh> is there a function to cycle a list on one?
19:54:48 <CakeProphet> :t fft
19:54:48 <Lemmih> On one?
19:54:49 <lambdabot> Not in scope: `fft'
19:54:50 <CakeProphet> :(
19:54:54 <mreh> e.g. [1,2,3] => [2,3,1]
19:55:06 <idnar> I'd call that "rotating" a list
19:55:22 <mreh> yup
19:55:25 <idnar> > liftA2 (++) head tail [1,2,3]
19:55:26 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:55:26 <lambdabot>        Expect...
19:55:33 <idnar> whoops
19:56:05 <idnar> > liftA2 (++) ((:[]) . head) tail [1,2,3]
19:56:06 <lambdabot>   [1,2,3]
19:56:12 <MyCatVerbs> > let rotate n l = let (f,b) = splitAt n l in b ++ f in rotate 2 [1..10]
19:56:13 <lambdabot>   [3,4,5,6,7,8,9,10,1,2]
19:56:14 <idnar> > liftA2 (++) tail ((:[]) . head) [1,2,3]
19:56:15 <lambdabot>   [2,3,1]
19:56:29 <idnar> (don't do what I did, it's horrible)
19:56:37 <mreh> haha
19:57:31 <mreh> let rot xs = cycle $ (tail xs) ++ [head xs]
19:57:41 <mreh> let rot xs = cycle $ (tail xs) ++ [head xs] in rot [1..5]
19:58:07 <mreh> > let rot xs = cycle $ (tail xs) ++ [head xs] in zipWith (,) [1..5] rot [1..5]
19:58:08 <lambdabot>   Couldn't match expected type `[b]'
19:58:14 <mreh> > let rot xs = cycle $ (tail xs) ++ [head xs] in zipWith (,) [1..5] (rot [1..5])
19:58:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
19:58:20 <mreh> woot
19:59:17 <mreh> > let rot xs = (tail xs) ++ [head xs] in zipWith (,) [1..5] (cycle . rot [1..5])
19:59:18 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:59:36 <mreh> > let rot xs = (tail xs) ++ [head xs] in zipWith (,) [1..5] (cycle . rot $ [1..5])
19:59:36 <MyCatVerbs> @pl \x y -> f . g $ x y
19:59:36 <lambdabot> ((f . g) .)
19:59:37 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
20:00:25 <mreh> :t pl
20:00:26 <lambdabot> Not in scope: `pl'
20:00:31 <MyCatVerbs> > let rotate = ((uncurry (flip (++)) . splitAt) .) in rotate 2 [1..10]
20:00:31 <lambdabot>   Couldn't match expected type `([a], [a])'
20:00:35 <idnar> it's a bot command, not a Haskell function
20:00:51 <Gracenotes> @help pl
20:00:51 <lambdabot> pointless <expr>. Play with pointfree code.
20:01:15 <Gracenotes> @. unpl pl \x y -> f . g $ x y
20:01:16 <lambdabot> (\ a i -> f (g (a i)))
20:01:22 <MyCatVerbs> @pl \x y -> f . (g x) $ y
20:01:22 <lambdabot> (f .) . g
20:01:49 <MyCatVerbs> > let rotate = ((uncurry (flip (++)) .) . splitAt) in rotate 2 [1..10]
20:01:50 <lambdabot>   [3,4,5,6,7,8,9,10,1,2]
20:01:57 <idnar> > zipWith (,) [1..5] (tail . repeat $ [1..5])
20:01:59 <lambdabot>   [(1,[1,2,3,4,5]),(2,[1,2,3,4,5]),(3,[1,2,3,4,5]),(4,[1,2,3,4,5]),(5,[1,2,3,...
20:02:12 <idnar> > zipWith (,) [1..5] (tail . cycle $ [1..5])
20:02:14 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
20:02:23 <mreh> genius
20:02:37 <idnar> uhm
20:02:44 <Gracenotes> or drop n
20:02:49 <idnar> @pl \f g x -> f x (g x)
20:02:49 <lambdabot> ap
20:02:56 <Gracenotes> @type zipWith (,) `ap` drop 3
20:02:57 <lambdabot> forall b. [b] -> [(b, b)]
20:03:02 <Gracenotes> :)
20:03:17 <Gracenotes> @type zipWith ?f `ap` ?g
20:03:18 <lambdabot> forall a b c. (?g::[a] -> [b], ?f::a -> b -> c) => [a] -> [c]
20:03:36 <idnar> I think I prefer the <*> spelling
20:03:36 <mreh> is `ap` known as apply?
20:03:50 <idnar> but, hey, I think I'm finally getting the hang of <*> on functions!
20:03:56 <Gracenotes> idnar: yeah, although I more frequently have Control.Monad imported than Control.Applicative :)
20:03:58 <mreh> apply the arg to the function
20:04:14 <Gracenotes> @type ap
20:04:14 <idnar> I actually have no clue what "ap" stands for
20:04:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:04:22 <pumpkin> applyish?
20:04:25 <Gracenotes> a function is an instance of a monad
20:04:28 <idnar> but I suppose apply makes some sort of sense
20:04:36 <pumpkin> applicate!
20:04:48 <Gracenotes> mreh: so, for functions, the type signature of ap is: (s -> a -> b) -> (s -> a) -> (s -> b)
20:05:07 <Gracenotes> or (s -> a -> b) -> (s -> a) -> s -> b
20:05:14 <mreh> my head hurts
20:05:40 <idnar> mreh: yeah, that monad (or applicative) tends to have that effect on people
20:05:54 <Gracenotes> heh. all that it means is that you pass it two functions and an initial argument, and it transforms that argument and does something with it
20:06:01 <mreh> i only wanted to make asteroids in haskell!!
20:06:11 <idnar> woo, asteroids!
20:06:39 <idnar> my final high school computer studies project was an Asteroids clone in C++ / DirectX
20:06:44 <mreh> i read that paper by C Luth
20:07:03 <mreh> i bet you wish you had learned haskell earlier ;)
20:07:03 <Gracenotes> mreh: ap-for-functions is a convenient way to combine functions to do what you want. It's perfectly fine to combine everything by hand, and more readable sometimes.
20:07:05 <idnar> it was about 70 pages of code, but like 65 of those were a massive switch statement mapping DirectX error codes to strings describing the error
20:07:17 <pumpkin> lol
20:07:19 <pumpkin> sounds useful
20:07:28 <pumpkin> DirectX didn't have such a function already?
20:07:40 <idnar> pumpkin: nope; this was DirectX 5, I think they finally added it around DirectX 8 or so
20:07:44 <mreh> 5 pages of code, that's still too many
20:07:54 <pumpkin> wow
20:08:07 <idnar> pumpkin: the main reason I needed it was that DirectX functions tend to return all sorts of error values they're not documented as returning
20:08:12 <Gracenotes> I did a fake-asteroids in QBASIC a long time ago. It was just navigating a maze of static asteroids and not bumping into any :)
20:08:15 <pumpkin> lol
20:08:15 <idnar> and I got tired of trying to look the codes up in the headers
20:08:31 <Gracenotes> it wasn't even a proper maze, just randomly putting dots in a matrix
20:08:39 <Gracenotes> so in some cases there were no solutions and you had to start again
20:08:52 <pumpkin> dot matrix!
20:09:00 <Gracenotes> no.
20:09:01 <idnar> mreh: well, it was C++ after all, and I had stuff like pixel-level collision detection (which I think I borrowed from a Dr. Dobbs article)
20:09:16 <idnar> mreh: but, re "wish you had learned haskell earlier", you have noooooooo idea
20:09:20 <pumpkin> "[Ignored; begging the question]"
20:09:24 <pumpkin> wow
20:09:41 <Gracenotes> "[Ignored; epic fail]"
20:09:42 <idnar> pumpkin: that was a bit rough, albeit accurate
20:10:01 <pumpkin> yeah :) just not used to seeing that kind of attitude except with coppin or bulat
20:10:02 <mreh> idnar: don't I?
20:10:23 <idnar> mreh: well, maybe you do :)
20:10:44 <monochrom> Who? Who said "[Ignored; begging the question]"?
20:10:45 <idnar> mreh: but back then, I thought I was a really hardcore programmer for using C++ instead of these crummy "high level" languages
20:11:08 <mreh> fantastic article written by some guy skeptical of functional programming for games, without even trying it
20:11:14 <mreh> ill see if i can dig it out
20:11:35 <Gracenotes> I don't like the academic definition of begging the question, I say we use it to mean something that prompts a query
20:11:47 <monochrom> Please don't dig it out. Thanks. I don't want to overwork you. :)
20:11:49 <pumpkin> monochrom: on haskell-cafe, jonathan cast
20:11:58 <MyCatVerbs> idnar: C++ taught me how to get started in Haskell.
20:11:58 <idnar> monochrom: Jonathan Cast, <1237160847.6295.42.camel@jonathans-macbook>
20:12:28 <mreh> "The awakwardness of Functional Programming"
20:13:00 <idnar> MyCatVerbs: I guess I probably learned some stuff from C++, but mostly it just made programming hard enough that I could feel all elite about doing it
20:13:16 <MyCatVerbs> idnar: specifically, C++'s template metaprogramming is like a pure language where the only non-strict primitive is pattern matching. After using that for fun, Haskell seemed bloody simple and natural. :)
20:13:25 <idnar> MyCatVerbs: eventually someone in some IRC channel bashed my head into a wall hard enough to broaden my horizons a bit
20:13:48 <idnar> MyCatVerbs: so I ended up getting into Python, and from there, exploring a whole new world of languages that weren't x86 assembly, C, or C++
20:14:09 <mreh> what, Perl?
20:14:31 <idnar> no, I'd already tried and discarded Perl at that point
20:14:41 <mreh> heh, it's witchcraft
20:14:54 <mreh> what were they thinking...
20:15:00 <idnar> I was thinking more along the lines of Erlang or Haskell :P
20:15:24 <mreh> I dont know any Erlang
20:15:27 <MyCatVerbs> idnar: one of my favourite grumbles about C and C++ is that they give programmers a false sense of control.
20:15:31 <idnar> I did have quite a backlash against statically typed languages as a result of my "bad" experiences with C / C++ / Java, though
20:15:54 <idnar> which is probably one of the reasons it took me so long to give Haskell a proper look
20:16:07 <idnar> MyCatVerbs: heh
20:16:23 <pumpkin> I had always assumed statically typed meant something in the c sense, where you had to declare every type
20:16:42 <pumpkin> I had no exposure to type inference, so haskell made me happy
20:16:50 <idnar> MyCatVerbs: I often make the (somewhat deliberately provocative) claim that programming in x86 ASM + macros is easier than programming in C :P
20:17:00 <mreh> i have never done any dynamic typed programming you know, do you recommend it?
20:17:08 <blackh> idnar: I remember at university 20 years ago, I got shown how to implement Othello in Prolog and I thought ... why would you want to do it that way???  I don't remember a functional programming course, but I must have done one because I've got this book called "Functional Programming" on my shelf, covered in a thick layer of dust!
20:17:20 <gnuvince_> mreh: can't hurt to try it.  "Expand your horizons", I say.
20:17:43 <mreh> well, i know Java, Perl amn Haskell
20:17:47 <MyCatVerbs> idnar: srsly. You're running on a CPU which lies to you about what order your instructions get scheduled in, your address space is entirely made of lies and you have no idea whether any given page is even mapped in at any given time...
20:17:50 <mreh> what do you suggest?
20:17:58 <idnar> pumpkin: my view of static typing (coming from C / C++ / Java land) was basically that all it did was make me type stuff the compiler already knew, and made the compiler complain about stuff that wasn't a real error, while still not complaining about stuff that was a real error
20:18:01 <gnuvince_> mreh: oh, so you do know a dynamically-typed language (Perl)
20:18:05 <gwern> @quote chris
20:18:05 <lambdabot> ndm says: outside of haskell i know roughly as many satan worshipers as Christians.
20:18:09 <gwern> @quote done
20:18:09 <lambdabot> SamB says: <SamB> @. bf . id . pl . v . wn yow  <lambdabot> Done.
20:18:14 <gwern> @quote chrisdone
20:18:14 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
20:18:20 <pumpkin> idnar: sounds about right in those cases :)
20:18:21 <idnar> pumpkin: and then I discovered that Haskell was basically the opposite of that :P
20:18:31 <gwern> @remember chrisdone I think you mean Peyton `Simon` Jones.
20:18:31 <lambdabot> It is stored.
20:18:37 <gwern> @flush
20:18:39 <pumpkin> lol
20:19:09 <idnar> mreh: if I had to recommend a dynamically typed language, it would probably be Python
20:20:12 <idnar> mreh: but it's probably worth looking at other stuff like Erlang or E
20:26:11 <mreh> is sqrt (x^2 + y^2) = x + y
20:26:54 <bd_> if x = 0 or y = 0, sure
20:27:39 <idnar> mreh: only when 2xy = 0
20:28:23 <idnar> so what bd_ said
20:28:48 <mreh> i see
20:28:50 <Cale> mreh: Is the distance between two points equal to the sum of the differences in each coordinate?
20:28:52 <Cale> :)
20:29:29 <mreh> when they line on top of each other, yes
20:29:34 <bremner> it would be  nicer to ask about |x+y|, then you could make a nice picture
20:29:57 <mreh> anyone think of a clever way to check if a polygon intersects a circle
20:30:01 <bremner> and throw in max(x+y) for good measure
20:30:16 <bremner> mreh: convex or otherwise?
20:30:18 <Cale> sqrt(x^2 + y^2) = x + y if and only if (x,y) lies on either the positive x axis or the positive y axis.
20:30:27 <mreh> any polygon
20:30:32 <mreh> or circle
20:30:36 <blackh> Cale: That depends on whether you go round the fence, or climb over it and risk being chased by a bull
20:30:47 <bremner> mreh: triangulate, test each triangle
20:30:50 <Gracenotes> @index text
20:30:50 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
20:31:07 <idnar> checking if two circles intersect is easy
20:31:09 <mreh> why not just test each line segment?
20:31:23 <Gracenotes> @hoogle ByteString -> String
20:31:23 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
20:31:23 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
20:31:23 <lambdabot> Prelude show :: Show a => a -> String
20:31:26 <idnar> just compare the distance between the centres with the sum of their radii
20:31:36 <mreh> yeah, i got that
20:31:41 <bremner> mreh: what do you mean by intersect? boundary or interiors?
20:31:42 <mreh> thanks though ;)
20:31:46 <blackh> sqrt(x^2 + y^2) = x + y if there's a bull in the field
20:32:07 <idnar> blackh: sounds like a load of bull to me
20:32:11 <blackh> This shall henceforth be known as "Blackh's law"
20:32:53 <Honza> @pl \x y -> x + 1
20:32:54 <lambdabot> const . (1 +)
20:33:10 <monochrom> log(x+y)=log(x)+log(y) is every algebra flunker's dream.
20:33:40 <monochrom> It's the next best thing since the eraser.
20:34:24 <idnar> haha
20:34:24 <mreh> i was thinking earlier about fp in Flash
20:34:45 <mreh> i know it's alot like JScript, but is it anything like Haskell?
20:34:58 <mreh> with the expressiveness, and the types
20:36:23 <monochrom> JScript likely uses dynamic typing, but I don't mind that. It likely doesn't have monads.
20:37:00 <Cale> monochrom: (x^p + y^p) = (x + y)^p
20:37:12 <idnar> mreh: I think you mean JavaScript, although JScript is a lot like JavaScript :P
20:37:22 <mreh> yes,
20:37:30 <mreh> i was abrev.
20:37:31 <monochrom> That is some devious Frobenius trickery.
20:37:57 <pumpkin> will loeb/lb make it into a standard library?
20:37:59 <idnar> mreh: I just get antsy about that abbreviation, because JScript is not quite the same thing (it refers to Microsoft's implementation)
20:38:12 <idnar> which one is loeb again?
20:38:51 <pumpkin> "Yeah, that's the downside of Haskell. It's not completely Turing-equivalent -- it can't implement pretty graphics. Meh -- it's just like in Java where you can't implement fractions. Every language has an area of incompleteness; I think it's a law or something."
20:38:55 <pumpkin> lol @ reddit
20:39:22 <pumpkin> @let loeb x = fmap (\a -> a (loeb x)) x
20:39:23 <lambdabot>  Defined.
20:39:41 <mreh> you cant implement fractions in Java?
20:39:42 <gwern> pumpkin: has anyone pointed out his foolishness?
20:40:03 <pumpkin> gwern: certainly
20:40:06 <pumpkin> I didn't even bother
20:40:07 <mreh> public Class Fraction { int den; int num; }
20:40:15 <gwern> mreh: I guess there's a law against having an object with two integers
20:40:17 <pumpkin> mreh: nope, not enough expressive power
20:40:21 <bremner> pumpkin: impressive ratio of falsehoods per cubic character
20:40:25 <idnar> @pl f +++ g = \x -> f x ++ g x
20:40:25 <lambdabot> (line 1, column 9):
20:40:26 <lambdabot> unexpected "="
20:40:26 <lambdabot> expecting variable, "(", operator, "||", "+++", "|||" or end of input
20:40:32 <pumpkin> lol
20:40:39 <idnar> pumpkin: I wasn't sure, but I thought he might have been joking
20:40:42 <gwern> mreh: well, you need arbitrary size integers :)
20:41:01 <idnar> @pl \x -> f x ++ g x
20:41:01 <lambdabot> liftM2 (++) f g
20:41:04 <pumpkin> idnar: it's ridiculous enough to need to be a joke (or risk reducing my already low opinion of humanity)
20:41:05 <mreh> we could make those with arrays
20:41:26 <bremner> gwern: java has BigInteger
20:41:37 <mreh> bremner: correct
20:41:41 <mreh> good thinking
20:41:49 <idnar> what about HugeInteger?!
20:42:18 <johnw> idnar: I think it was supplanted by GiganticInteger, not long ago
20:42:20 <bremner> idnar: for that you need LaTeX
20:43:44 <mreh> is there a limit to the number of statements in a where blocks i can have in a function definition?
20:44:01 <mreh> is there a limit to the number of where blocks i can have in a function definition?
20:44:37 <MyCatVerbs> @src (.)
20:44:37 <lambdabot> (f . g) x = f (g x)
20:44:57 <MyCatVerbs> mreh: not until your computer runs out of RAM while trying to run the compiler.
20:45:10 <mreh> schweet
20:45:28 <mreh> i was thinking of the x = 1 case, where x is the number of where blocks
20:45:40 <mreh> or indeed the x > 1 case
20:45:51 <mreh> should i have expressed in with a guard for you?
20:45:55 <mreh> should i have expressed it with a guard for you?
20:48:34 <dons> here we go. the complete haskell namespace, visualised for the first  time :)
20:48:35 <dons>  http://donsbot.files.wordpress.com/2009/03/hackage-neato-thumb.png
20:49:04 <pumpkin> wow
20:49:16 <pumpkin> the big lump in the middle is Data.?
20:49:22 <dons> yeah
20:49:22 <Lemmih> Pretty.
20:49:29 <MyCatVerbs> dons: where'd one even *start* to read up on how to interpret that?
20:49:51 <MyCatVerbs> To me, it just looks like someone sledgehammer'd a bagful of coffee beans into a tabletop.
20:50:00 <dons> i'll finsih the post tomorrow.
20:50:05 <dons> here's the svg...
20:50:11 <pumpkin> *tremble*
20:50:13 <mreh> it broke my laptop
20:50:16 <dons> http://code.haskell.org/~dons/images/svg/
20:50:28 <dons> those svg will almost certainly break anything other than proper svg viewers
20:50:47 * callen trembles with pumpkin 
20:50:52 <pumpkin> let's see how webkit handles it
20:51:11 <pumpkin> webkit has half a gig of RAM and is running at 100% now :P
20:51:15 <glguy> aren't svg's supposed to be small?
20:51:15 <dons> hehe
20:51:24 <glguy> as they only contain the vectors and not a whole image :)
20:51:35 <pumpkin> yeah, but this is a big graph :P
20:51:35 <dons> glguy: 10k+ node graphs with 100k edges?
20:51:44 <glguy> does this use one vector for each pixel
20:51:47 <mreh> that's pretty
20:51:54 <dons> its a graph of the complete haskell hierarchical namespace
20:52:06 <MyCatVerbs> dons: is that all of Hackage?
20:52:07 <dons> learn those APIs!
20:52:10 <monochrom> Heh, it's the same as "isn't HTML supposed to be small?"
20:52:13 <dons> all of hackage + the core libs
20:52:14 <pumpkin> alright, I hereby declare webkit to have failed with that svg
20:52:24 <dons> works in inkscape fairly well, fwiw
20:52:28 <pumpkin> at least it didn't lock up
20:52:35 <MyCatVerbs> FF3 coped just fine for me.
20:52:53 <MyCatVerbs> I see here a *lot* of overlapping things.
20:53:02 <glguy> safari can show them, except that it doesn't scale them
20:53:11 <glguy> so you don't necessarily see "all" or "much" of it
20:53:26 <pumpkin> yeah, I was seeing a small amount of it and it was being slow at resizing
20:53:27 <pumpkin> so I gave up
20:53:27 <dons> here's a different rendering:
20:53:29 <dons>  http://donsbot.files.wordpress.com/2009/03/hackage-circo-thumb.png
20:53:36 <pumpkin> ooh
20:53:40 <pumpkin> I like that one more
20:53:44 <dons> you can see each distinct namespace a bit more
20:54:00 <pumpkin> got funky moir patterns showing up too
20:54:01 <dons> see those tiny projects hanging off Data -- each representing weeks of work :)
20:55:00 <pumpkin> you could render it as a giant image, and provide one of those cool "huge image" viewers that they have on some sites
20:55:17 <pumpkin> that'd probably be a lot of bandwidth though
20:57:22 <johnw> has anyone written anything that walks through Hackage and creates the Portfile entries that MacPorts requires?  I'm thinking it might make for an interesting "first Haskell program" for me
20:57:40 <johnw> real world enough, yet straightforward and not too large in scope
20:57:49 <pumpkin> do it!
20:57:52 <pumpkin> that'd be awesome
20:58:09 <johnw> cool, I'm excited :)
20:58:13 <idnar> hackage-neato-thumb.png looks like I need to adjust my TV set :P
20:58:17 <pumpkin> but for bindings to external libraries, it's hard for you to determine dependencies
20:58:36 <johnw> pumpkin: i might need to accept an external mapping file, then, to handle that
20:58:57 <pumpkin> johnw: beware of the matlab binding, 'sdeath to get working on mac os :P
20:58:58 <dons> johnw: i think portfiles there is a tool already
20:58:59 <dons> check on hackage
20:59:31 <johnw> i see "hackport", but that's for Gentoo
21:00:28 <johnw> pumpkin: also, if I parse the .cabal file, isn't there enough info there to discover dependencies?  If something is not support by MacPorts, I can defer those until the necessary ports appear
21:00:39 <pumpkin> not that I know of
21:00:46 <idnar> sigh, I closed iceweasel 10 minutes ago and it's still shutting down
21:02:51 <rovar> that's porn sites for ya
21:03:31 <Gracenotes> Alt+F2 pkill (blah)
21:03:41 <Gracenotes> on Ubuntu at least
21:06:24 <idnar> Gracenotes: heh, that's capslock+F3 in my ion3 config
21:06:35 <idnar> (I mean, instead of alt+F2)
21:06:48 <Gracenotes> capslock combination... :x
21:07:35 <idnar> my ion3 modifiers are mod4 (super / "windows key") and mod3 (which I have caps lock mapped to)
21:07:49 <idnar> anything else would interfere with other apps
21:08:06 <idnar> and caps lock is a useless modifier
21:08:42 <b\6> IDNAR: WHAT DO YOU MEAN
21:09:18 <idnar> B\6: CAPS LOCK IS CRUSIE CONTROL FOR COOL, but I'm so cool already that it's rendundant
21:09:21 <idnar> er, CRUISE
21:13:34 <monochrom> I miss the days of Usenet. People posted in all caps, you know. I made fun of them by quoting their post but converting to all smalls.
21:14:32 <hotaru2k3> actually, CAPS LOCK IS CRUISE CONTROL FOR COBOL
21:15:34 <idnar> hahaha
21:15:42 <monochrom> BASIC too.
21:16:28 <monochrom> @slap monochrom
21:16:28 <lambdabot> I won't; I want to go get some cookies instead.
21:16:40 <idnar> mmm, cookies
21:16:48 <hotaru2k3> a broken B key can turn COBOL into COOL, the same cannot be said of BASIC
21:17:36 <monochrom> a broken B can turn BASIC into ASIC. hardware acceleration. nothing beats it.
21:26:28 <FunctorSalad> a broken C can turn C into err nvm
21:30:34 <FunctorSalad> @remember hotaru2k3 actually, CAPS LOCK IS CRUISE CONTROL FOR COBOL
21:30:34 <lambdabot> Done.
21:31:09 <idnar> FunctorSalad: invisible C!
21:31:22 <FunctorSalad> hehe
21:40:10 <sarh> BASC
21:40:13 <sarh> in the freedom
21:51:59 <Gracenotes> heh. I think it's somewhat amusing that I'm parsing regex with Parsec, when Parsec is clearly a more powerful parsing tool than regex anyway :)
21:52:14 <Gracenotes> you can't even parse regex with regex >_>
21:53:19 <c_wraith> welll..  perl-compatible regexes (particular with capturing group matching references, like \1) aren't actually a regular language anyway
21:53:44 <monochrom> Indeed we use general-purpose computers to verify claims about finite-state machines. (see "model checking")
21:53:52 <Gracenotes> yes. They're not even context-free :) still, you can't parse regex with those regex
21:54:27 <Gracenotes> I mean by not context-free that they can handle things context-free can't, but the reverse is also true.
21:55:07 <monochrom> The latter is interesting.
21:55:28 * wli mutters something about GLR.
21:55:28 <monochrom> Nevermind. The whole is interesting.
21:56:27 <dolio> The first part is pretty mundane.
21:56:39 <dolio>  /(.*)\1/
21:56:41 <Gracenotes> maybe I should change my CFG-parser from convert-to-PDA-then-run to something that can detect what it's parsed. But then, there are classic LL/LR/LALR/etc models to do that...
21:57:01 <Gracenotes> well, it's not so much a CFG-parsing tool as a CFG-running one
21:57:14 <dolio> I'm not sure what the example of the second part is.
21:58:13 <Gracenotes> something that matches (0^n)(1^n), I think.
21:59:28 <mae> is there a way to tell ghci to automatically perform a :reload when a file that is loaded is changed?
22:00:09 <wli> Gracenotes: A CFG-running tool? Like a parser function taking a grammar and a string as input and producing a parse tree as output?
22:00:46 <Gracenotes> nope, nothing of the sort. Just something that takes a CFG, turns it into a PDA, and checks if a string matches
22:01:33 <Gracenotes> it's non deterministic, too, so it can get slow and huge
22:02:50 <wli> Close enough.
22:03:54 <Gracenotes> so it says if a parse tree exists, not saying what it is :)
22:04:25 <Gracenotes> although, you could probably look at a list of all configurations in a successful branch of the PDA to deduce a parse tree
22:05:04 <Gracenotes> it quits in success when just one branch has ended successfully
22:05:05 <wli> The PDA's can usually incrementally put together parse trees even in the absence of otherwise handling any semantic actions.
22:05:45 <Gracenotes> yeah. But only leftmost derivations
22:06:30 <wli> That's usually fine in the case where parses are considered to be either unique or nonexistant.
22:08:47 <Gracenotes> hm. well, there can be ambiguous parse trees for a given string, even if they're expanded only in a leftmost fashion. That's first and follow and other stuff I'll learn about in my school's compilers course, or hopefully earlier when I get the chance
22:09:13 <Gracenotes> at least, I hope the compilers course covers it
22:09:48 <Gracenotes> surely there are schools that have a full parsing theory course, though
22:10:18 <pumpkin> in linguistics maybe?
22:10:55 <c_wraith> cs programs tend to split it across automata theory and compilers courses
22:11:08 <c_wraith> but between them you can get a pretty good idea of the theory
22:11:11 <Gracenotes> pumpkin oh, yeah. Them linguistics people. But they're always arguing about how things relate to natural languages and so on :)
22:11:14 <pstickne> I wish it was all in automata :(
22:30:13 <mae> could someone point me to the place here where I can find the source code for ghci? : printInterpreterError
22:30:15 <gnut> is there any current work on getting ghc to work on the ARM processor?
22:30:16 <mae> http://darcs.haskell.org/ghc/
22:32:22 <zhwkfm> Hey, does anyone know a good web app visual basic framework?
22:34:12 <mmorrow> dons: omg this is sweet http://donsbot.files.wordpress.com/2009/03/hackage-neato-thumb.png
22:34:44 <bmh> mmorrow: what the devil is that?
22:34:46 <Cale> Ripples in a pond
22:34:52 <bmh> oh..
22:35:08 <Cale> It's actually the complete module hierarchy graph... with strange overlapping nodes.
22:35:10 <c_wraith> heh.  even zoomed out that far, it provides a decent visual summary.  that's cool
22:35:11 <mmorrow> in hindsight, i think graphviz might have defaulted to a huge image since i maybe didn't specify the dims when i tried to render a hackage graph
22:35:38 <bmh> I've been on a data structures binge lately. If my DNS has propagated, the source is in hg.bhickey.net
22:35:55 <bmh> I've got skew heaps, binomial heaps, binary heaps (boo.. hiss) and splay trees
22:35:57 <mmorrow> because everything seems to say it's no big deal... but i ^C'ed it after 30 minutes..
22:36:17 <bmh> (I make no promises about correctness at this time)
22:37:00 <mmorrow> bmh: nice. check out the datastructure that's used for Data.Map and see if you can't improve it :) (not that it's bad or anything)
22:37:56 <mmorrow> it seams like there's redblack trees, avl trees, that datastructure in Data.Map, and... that's it (for functional finite map implems)
22:38:13 <mmorrow> whereas there's like a billion functional sequence datastructure
22:38:38 <bmh> I don't see a mention of RBTrees in Data.Map
22:38:40 <bmh> link?
22:38:58 <mmorrow> Data.Map doesn't use rbtrees, but this other structure
22:39:16 <mmorrow> well, there's also patricia trees, but only for int maps
22:39:58 <zhwkfm> Hey, does anyone know a good web app visual basic framework?
22:39:59 <mmorrow> bmh: there're links to the respective papers on each hackage page
22:40:01 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/containers/Data-Map.html
22:40:07 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/containers/Data-IntMap.html
22:40:13 <zhwkfm> and does haskell support VB?
22:40:46 <pumpkin> lol
22:40:52 <mmorrow> bmh: that Data.Map structure is from '93. i feel like there has to some progress made since then
22:40:54 <bmh> ...It does if you make it?
22:41:07 <pumpkin> zhwkfm: does c support vb?
22:41:21 <pumpkin> I know that haskell supports regular basic
22:41:22 <bmh> mmorrow: reading through Data.Map  suggests to me that it's a whore of a data structure
22:41:27 <bmh> it looks like it's trying to please everyone.
22:41:36 <pumpkin> hah
22:41:48 <mmorrow> bmh: heh
22:41:58 <pumpkin> mmorrow: did you see the other graph structure?
22:42:02 <pumpkin> or rather, layout
22:42:15 <pumpkin> mmorrow: http://donsbot.files.wordpress.com/2009/03/hackage-circo-thumb.png is cooler, I think
22:42:20 <mmorrow> i'd say i probably import Data.Map in 75% of haskell modules i write
22:42:37 <bmh> and/or Data.Set
22:42:42 <dons> mmorrow: yeah, i like http://donsbot.files.wordpress.com/2009/03/hackage-neato-thumb.png
22:42:52 <dons> its like looking down on the hierarchy tree from above
22:43:00 <dons> so big subtrees look like tall mountains
22:43:16 <mmorrow> dons: yeah, that's crazy
22:43:45 <wli> I use tree-based data structures at every opportunity.
22:43:52 <dons> good image to use for 'what is haskell used for'
22:43:55 <mmorrow> they look like drops into a puddle
22:44:08 <bmh> the splay tree implementation is really strange. When I wrote my C version, I did the traditional "bubble up nodes". With this one, I shove the root down until I find what I'm looking for
22:44:16 <bmh> I /think/ they're the same.
22:44:43 <wli> I don't think they are.
22:44:45 <c_wraith> well, they're not the same transformation
22:44:58 <c_wraith> But they might have similar average performance characteristics
22:45:09 <bmh> right, but I think I've preserved the structural effect
22:45:20 <mmorrow> pumpkin: holy crap, i hadn't seen the circo one
22:45:27 <pumpkin> splay trees are neat :)
22:45:34 <pumpkin> mmorrow: both are really cool :D
22:45:37 <mmorrow> that's sooo frickin sweet
22:45:38 <bmh> dynamic trees are neat
22:45:45 <wli> They dirty too many cache lines.
22:46:04 <pumpkin> it's still a neat idea, regardless of implementation issues
22:46:20 <dons> i'm hoping someone makes some other nice images from the .svg and .dot srcs
22:46:24 <mmorrow> dons: did you stick any particular graph/edge/node [...attributes..]; in that circo .dot?
22:46:45 <bmh> I don't see why splaying should be restricted to so-called splay trees
22:46:57 <bmh> perhaps some of the time we don't want to splay, and other times we want to splay
22:47:02 <bmh> sure, it sullies the analysis
22:47:07 <dons> mmorrow: no, just the raw undirected graph
22:47:15 <mmorrow> the moire patterns in the circo one add to it
22:47:17 <wli> split and join operations are available for other kinds of balanced trees as well.
22:47:17 <dons> http://code.haskell.org/~dons/dots/
22:47:30 <wli> AVL trees and treaps I've done before.
22:47:31 <mmorrow> dons: ooh, nice
22:47:37 <dons> so circo is the graphviz rendering of the raw src, which i then rescale in inkscape, then export   to png
22:47:39 <bmh> wli: in haskell?
22:47:49 <wli> bmh: No, C.
22:47:50 <c_wraith> skew heaps essentially splay, also.
22:47:51 <mmorrow> dons: how long did the circo take to render?
22:47:59 <dons> oh, pretty quick when exporting to .svg
22:48:03 <dons> a few seconds
22:48:08 <mmorrow> ah, hmm.
22:48:14 <dons> very slow direct to .png
22:48:15 <bmh> I've been kicking around the idea of implementing a bunch of randomized data structures in haskell. I'm just now sure how to deal with the RNG
22:48:18 <dons> so i go via inkscape
22:48:30 <mmorrow> dons: ahh, ok. i was trying png before
22:48:46 <wli> bmh: I believe there are split and join algorithms for rbtrees, too.
22:49:11 <wli> It took me a long time to come around, but I favor rbtrees over most/all other binary trees nowadays.
22:49:22 <bmh> wli: pardon my confusion, it's late, but what does that have to do with anything? (rb supporting split/join)
22:49:42 <pumpkin> you need a 2-3-4-5-6-7-8-9 tree (that's actually an RB tree)
22:49:44 <wli> bmh: The "splay" operation is splitting the tree IIRC.
22:49:53 <dons> mmorrow: yeah, try -Tsvg ; then load in inkscape (if you're using graphviz)
22:50:03 <pumpkin> ooh actually, maybe I'll try rendering it
22:50:10 <pumpkin> I'm on a 30" display and it could look cool
22:50:20 <bmh> wli: no. Splay is promoting a node to the head via rotations. Useful for splitting, but orthogonal
22:50:46 <wli> bmh: The idea here being that most/all balanced binary trees have a splitting operation.
22:52:06 <wli> bmh: I think they by and large do it by promoting a sentinel node to the head via rotations.
22:52:44 <wli> bmh: At least that's how I wrote it every time.
22:54:11 <wli> Rotate, restore invariants in left and right subtrees, rotate again.
22:55:48 <wli> bmh: Treaps are more interesting as randomized structures anyway, and they don't necessarily even need to be all that random; you can have the priority used to heap order them related to e.g. frequency of lookup.
22:56:07 <bmh> hmm.. cute idea
22:57:15 <mmorrow> bmh: just use unsafePerformIO for the RNG
22:57:23 <bmh> *shudder* :)
22:57:56 <mmorrow> but realistically..
22:58:06 <wli> The cases where you innately need STRef's/IORef's/etc. are where it starts to get interesting.
22:58:11 <mmorrow> well, i guess you just need an initial seed, right?
22:58:16 <bmh> right
22:58:21 <bmh> don't lock the user into the IO monad
22:58:30 <bmh> the user is presumably smart
22:58:42 <mmorrow> bmh: oh nice, in that case it'd just be a quicky unsafePerformIO and be on your way :)
22:59:16 <bmh> to digress for a moment. I need to get used to being called `bmh`. I blame freenode.
22:59:21 <wli> bmh: That's another place where treaps with usage info shine. Just increment priorities and hand back fresh trees on every lookup, and whatever gets looked up the most gravitates toward the root.
23:00:01 <bmh> wli: cute. If I have time, I'll implement that tomorrow.
23:00:07 <bmh> (or before I go to bed)
23:00:12 <wli> (Never mind that that dirties cache lines too, but if you're opting for ease of coding plus randomization etc., there you go.)
23:00:18 <mmorrow> bmh: here's a nice and short mersenne-twister: http://www.augustsson.net/Darcs/MersenneTwister/
23:00:27 <mmorrow> < 100 lines iirc
23:00:31 <bmh> (all hail MT!)
23:00:43 <mmorrow> s/100/50/
23:00:46 <wli> That reminds me, we still don't have genuine hash tables, do we?
23:00:56 <bmh> Lennart must be a wizard.
23:01:07 <wli> There is something interesting called "tree hashing."
23:01:24 <pumpkin> whee, browsing that epicly large dot file now
23:01:31 <bmh> not to knock the suffix tree implementation on hackage, but it does n lg n construction
23:01:35 <wli> Normally people think of using doubly-linked (or maybe even singly-linked) lists to represent collision chains in hash tables.
23:02:01 <bmh> speaking of doubly-linked lists -- is (++) O(1) or O(n)?
23:02:06 <wli> There's no reason one couldn't use binary search trees.
23:02:11 <wli> bmh: O(n).
23:02:12 <mmorrow> bmh: heh, i think he's won the iocc more than once
23:02:32 <bmh> wli: that's unfortunate. Is there something I can use instead?
23:02:45 <mmorrow> *ioccc
23:02:45 <wli> bmh: Data.Sequence
23:03:08 * bmh comes out of the shadows
23:03:09 <bmh> thanks
23:03:18 <wli> Anyway, hashing by separate chaining where binary search trees are used for collision chains is called "tree hashing."
23:03:58 <wli> You get the large constant factor reduction in overall collision chain size plus O(lg(n)) asymptotics.
23:04:06 <pumpkin> http://pumpkinpat.ch/hackage.pdf large pdf version of dons' epic dot
23:04:22 <pumpkin> seems to have rendered differently :)
23:04:35 <bmh> I'm disappointed that I couldn't make it to the meetup thing near Boston maybe a month or so back
23:04:41 <bmh> I'm sure I was doing something important
23:05:45 <wli> Hashing by separate chaining requires STArrays/STRefs for sure.
23:05:47 <wli> ergh
23:06:10 <wli> I meant open addressing, but it's probably true of hashing by separate chaining, too.
23:06:44 <pumpkin> lol, I crashed preview by trying to save a huge png
23:07:06 <Gracenotes> o nos
23:07:10 <wli> You get something interesting called a "hash trie" when you recursively use hash tables as collision chains. I happen to like hash tries a lot, esp. for sparse keyspaces.
23:07:40 <dons> pumpkin: cute
23:08:04 <pumpkin> it's fun to zoom around in
23:08:49 <bmh> new xkcd. I saw the last panel coming from the first panel.
23:09:12 <bmh> oops -- off topic. so how 'bout those monads?
23:09:19 <wli> Let's say you're storing long strings of Haskell source code text for pointwise lookup, and break it up into "digits" of, say, 3 or 4 consecutive characters.
23:10:00 <wli> Not only will the overall space be sparse, but the space of k-th digits for each k will also be sparse.
23:10:27 * mmorrow just installed inkscape
23:11:09 <wli> So you could use a trie, but most of the space in each node will be wasted.
23:11:48 <wli> So use an open-addressed hashtable where if the k-th digit precisely matches, they chain, and otherwise use open addressing collision policy to compress the trie nodes.
23:13:40 <joga> pumpkin, how do you view that pdf file, I've tried xpdf, gv and evince, and not one of them manages to render anything ;)
23:13:52 <pumpkin> works fine in mac os preview?
23:13:56 <joga> (they try hard, though)
23:13:56 <pumpkin> no question mark
23:14:04 <pumpkin> you sure you aren't just seeing a corner of it?
23:14:05 <wli> Now, for digits of 3 consecutive characters you'd normally need (256^(4::Int) - 1) `div` (256 - 1) :: Integer == 16843009 array/finitemap/etc. elements at each node.
23:14:45 <joga> pumpkin, possibly, but if it takes minutes to actually render some visible part I'll pass :) (evince says: cairo context error: out of memory)
23:14:48 <wli> Compress the nodes via hashing by open addressing and you at worst double the number of elements actually used.
23:15:52 <wli> ... and for highly structured text, that's microscopic esp. compared to the actual key/digit space.
23:16:20 <wli> Even better, you can use it everywhere you would otherwise use a trie.
23:18:17 <wli> So in a "backtracking" search with a list/set/etc. of successes, you do just like you would with a trie regex search and enumerate the next several possible successor characters and form keys for search in the local node, etc., with much, much smaller nodes.
23:21:13 <wli> Hash tries are probably also good candidates for imperative analogues of IntMap.
23:21:53 <Gracenotes> nullary intersection... *mind blown*
23:22:16 <wli> Gracenotes: Empty set?
23:22:38 <wli> Gracenotes: Or maybe the universe.
23:22:45 <Gracenotes> apparently the intersection of no sets at all is in fact the universe
23:23:14 <wli> Gracenotes: It's the identity under intersection, in the case of having a universe.
23:23:32 <Gracenotes> mm, that makes more sense
23:24:01 <bmh> night
23:24:04 <Gracenotes> a form of Russell's paradox, it seems?
23:24:05 <wli> I guess when you complete the lattice, the top element.
23:25:30 <wli> Not a form of it, but an assumption that is IMHO vulnerable to it.
23:26:43 <Keith_M_> which compiler should I use?
23:26:47 <Gracenotes> constructing something that you could probably construct for free by just saying it's a universal set
23:26:51 <Gracenotes> :)
23:27:36 <wli> Well, if you get the usual |P(A)| > |A| affairs for powersets, universes don't make sense.
23:28:19 <Gracenotes> doesn't cantor enumeration of infinities have something to do with that?
23:28:23 <wli> There's some kind of logic contortion you can do to ram it down anyway, but given what Coq says about most things, I don't buy it.
23:28:43 <Gracenotes> Keith_M_: well, I use GHC and have had no problems with it :)
23:29:10 <Gracenotes> most people here do, it seems.
23:35:10 <Gracenotes> actually, no problems might be an exaggeration given apt-get troubles. But that's for stuff that I don't think would even be available if I used Hugs.
23:41:42 <mmorrow> inkscape is pretty nice
23:42:24 <mmorrow> this is an amusing graph:
23:42:27 <mmorrow> ls /usr/bin|grep -E "^[a-z0-9]*[^0-9-]2[^0-9-][a-z0-9]*[^0-9]$"|ghc -e"putStrLn.(++\"}\").(\"digraph{\"++).unlines.fmap(\(x,xs)->show x++\"->{\"++Data.List.intercalate\",\"(fmap(show)xs)++\"}\").Data.Map.toList.Data.Map.fromListWith(++).fmap(fmap((:[]).takeWhile(/='2').drop 1).span(/='2')).lines=<<getContents"|dot -Tsvg>to.svg
23:43:01 <mmorrow> "all programs in /usr/bin that are "...2..."
23:43:05 <Gracenotes> *runs code found on internet*
23:43:16 <mmorrow> password:
23:44:11 <Gracenotes> No instance for (Functor ((,) [Char]))
23:44:21 <mmorrow> Control.Monad.Instances
23:44:34 <mmorrow> ohh
23:44:36 <Gracenotes> yes, my ghc doesn't have it by default :x
23:44:38 <mmorrow> from that code
23:45:10 <Baughn> Are there any interesting instances of Arrow other than the (->) and Kleisli ones?
23:45:30 <mmorrow>  ls /usr/bin|grep -E "^[a-z0-9]*[^0-9-]2[^0-9-][a-z0-9]*[^0-9]$"|ghc -e"putStrLn.(++\"}\").(\"digraph{\"++).unlines.fmap(\(x,xs)->show x++\"->{\"++Data.List.intercalate\",\"(fmap(show)xs)++\"}\").Data.Map.toList.Data.Map.fromListWith(++).fmap((\f (a,b)->(a,f b))((:[]).takeWhile(/='2').drop 1).span(/='2')).lines=<<getContents"|dot -Tsvg>to.svg
23:45:36 <mmorrow> fixed
23:46:10 <mmorrow> svg is like lightning compared to -Tpng
23:46:38 <wli> I wonder why. I've no idea what the differences are.
23:47:23 <mmorrow> probably because svg is just txt, but it has to actually produce every last pixel of the png image
23:47:45 <Gracenotes> aww. dot doesn't like: context:  >>> "foo"->{"zjs", <<< "xqx","slx","qpdl","oak","lava","hp","hiperc"}
23:47:52 <mmorrow> it just warns
23:48:05 <wli> I guess it might avoid doing very much more than giving the spline parameters.
23:48:06 <mmorrow> (or it might error out if you have an older graphviz (??))
23:48:18 <mmorrow> wli: ah, true
23:48:26 <Gracenotes> I just installed it from apt-get, not having played with it much before
23:48:42 <Baughn> So, older graphviz, then.
23:48:43 <mmorrow> Gracenotes: did it fail due to syntax error, or did it just give you a warning?
23:48:43 <Gracenotes> yeah. It says error, but "firefox to.svg" displays it nicely
23:48:44 <pumpkin> mmorrow: I'd have expected that the time-consuming bit was laying out the graph though, not spitting out a bunch of pixels
23:48:56 <Gracenotes> hah. neat graph
23:48:59 <mmorrow> pumpkin: me too
23:49:16 <Gracenotes> I especially like the area around pdf/ps
23:49:17 <mmorrow> Gracenotes: :) yeah, i'm way amused by it myself
23:49:22 <Gracenotes> lots of action going on there
23:49:25 <mmorrow> Gracenotes: totally!
23:49:35 <Baughn> mmorrow: You're assuming the svg viewer doesn't have to do any of the layout work
23:50:00 <mmorrow> Baughn: but we're just talking about time graphviz spends to produce an output file
23:50:20 <Gracenotes> although it doesn't count everything
23:50:30 <mmorrow> Gracenotes: yeah, the regex could be better
23:50:36 <Gracenotes> for instance, pdftex pdflatex :)
23:50:41 <mmorrow> ah, true
23:50:43 <Baughn> mmorrow: Right, but if it manages to offload some of the layout work to the svg *viewer*, then png gets both the rendering cost and the layout cost
23:50:45 <Gracenotes> pdftotext
23:50:53 <Baughn> Not to mention the png compression cost
23:51:05 <mmorrow> Baughn: exactly
23:52:46 <Gracenotes> instead of trying to make a finite automata in Inkscape, I can use dot! :)
23:53:10 <mmorrow> Gracenotes: graphviz is right up there next to cereal and airplanes in my book
23:53:11 <pumpkin> *automaton ;)
23:54:01 <Gracenotes> pumpkin: fail, it's s/ a / / :X
23:54:11 <pumpkin> I don't do that
23:54:37 <pumpkin> leave regexen to sed/perl/ruby and leave them out of my irc client :P
23:55:42 <Gracenotes> 1c1
23:55:44 <Gracenotes> < instead of trying to make a finite automata in Inkscape, I can use dot! :)
23:55:48 <Gracenotes> ---
23:55:53 <Gracenotes> > instead of trying to make finite automata in Inkscape, I can use dot! :)
23:55:54 <lambdabot>   <no location info>: parse error on input `of'
23:56:03 <Gracenotes> happy? (clearly lambdabot isn't)
23:56:27 <pumpkin> :o
23:57:33 <pumpkin> if I do a ghc rewrite rule on id, does it allow my substitution to happen on anything?
