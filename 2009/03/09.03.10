00:03:15 <cads_> luqui, interesting to note that when we write f: R->R we mean "f (is the function) that maps from R to R", but when we further define f: x |-> x^2 we mean "f (is the function) such that x is mapped to x^2". I might be wrong in my interpretation, but both of those feel pretty natural
00:04:24 <luqui> I never write the latter
00:04:35 <luqui> I would write:  f : R -> R, such that f(x) = x^2
00:04:41 <QtPlaty[hireme]> cads_: Normally I see that written as f(x) = x^2
00:06:00 <QtPlaty[hireme]> The two forms describe things on diffrent levals of abstraction.
00:09:32 <c_wraith> http://kotaku.com/5167133/floating-cammy-head-is-here-to-frighten-you
00:09:37 <c_wraith> oops, wrong channel
00:09:38 <c_wraith> sorry
00:09:48 <dolio> You might see 'x |-> x^2' if giving a name to the function is a waste.
00:10:06 <dolio> But presumably if you were giving a name to something like that, you'd say 'f = x |-> x^2'.
00:12:51 <IminYourMonad> what does it mean Xk2 where 2 is like ^2 and k is on the bottom right?
00:12:51 <IminYourMonad> http://mathbin.net/6750
00:17:14 <cads_> IminYourMonad: in this case the subscript indexes the elements of the vector X, and the superscript 2 is an exponent
00:19:28 <cads_> so  sum_{k=1}^{n} X_{k}^2   means    X_1^2 + X_2^2 + ... + X_n^2
00:28:45 <IminYourMonad> what the hell is a window manager?
00:30:27 <thoughtpolice> IminYourMonad: it manages your graphical windows
00:30:32 <thoughtpolice> hence, 'window manager' :)
00:31:48 <IminYourMonad> im watchin battle of algiers, wtf did the french use giljotines in the 1950s to!?
00:32:02 <IminYourMonad> so it is a program, not a tool?
00:32:03 <pumpkin_> IminYourMonad: do you have ADD?
00:32:09 <IminYourMonad> add?
00:32:24 <Cale> IminYourMonad: The window manager is responsible for drawing the borders around windows, determining the keyboard focus, and various other similar things.
00:32:24 <pumpkin_> your questions tend to be all over the place :)
00:32:41 <thoughtpolice> pumpkin_: do you have pumpkin pie?
00:32:45 <thoughtpolice> :)
00:32:46 <pumpkin_> no :(
00:32:49 <thoughtpolice> :(
00:33:56 <pumpkin_> aw, I hope I didn't offend him
00:37:05 <dolio> Maybe he forgot you were asking him questions and decided to go do something else.
00:37:26 * AirCastle lol
00:37:27 <pumpkin_> lol
00:37:53 <temoto> Why separate operator for concating strings?
00:38:04 <pumpkin_> because operators are cheap
00:38:19 <pumpkin_> you mean why not use +?
00:38:23 <temoto> yes
00:38:29 <thoughtpolice> because + has a different type
00:38:30 <pumpkin_> because + is provided by the Num typeclass
00:38:48 <pumpkin_> and it'd be odd to make lists instances of Num
00:38:57 <thoughtpolice> + is only defined over those types which can be instances of the Num type class (e.g. float, double, int, etc.)
00:39:04 <thoughtpolice> String is not one of them
00:39:06 <temoto> It's a so-so excuse.
00:39:26 <pumpkin_> temoto: how about, because + is understood as being an operator over numerical quantities
00:39:30 <thoughtpolice> you're the one who thinks it's a problem.
00:39:31 <pumpkin_> and it makes no sense to do so on lists?
00:39:43 <thoughtpolice> i'm just telling you the truth
00:39:49 <pumpkin_> thus, to avoid ambiguity, we use a different operator
00:39:49 <dolio> (+) is clearly for commutative operations, which list concatenation isn't. :)
00:39:58 <temoto> commutative?
00:40:04 <pumpkin_> a + b == b + a
00:40:07 <thoughtpolice> commutative: a * b = b * a
00:40:09 <temoto> oh
00:40:21 <temoto> That makes sense.
00:40:54 <trofi^w> @check \x y -> x * y == y * x
00:40:56 <lambdabot>   "OK, passed 500 tests."
00:40:59 <pumpkin_> > [1,2,3] `mappend` [5,6,7]
00:41:00 <lambdabot>   [1,2,3,5,6,7]
00:41:04 <pumpkin_> > [1,2,3] `mplus` [5,6,7]
00:41:05 <thoughtpolice> trofi^w: thank god
00:41:05 <lambdabot>   [1,2,3,5,6,7]
00:41:08 <thoughtpolice> :)
00:41:29 <trofi^w> yes :]
00:41:35 <Gracenotes> o nos
00:41:45 <pumpkin_> o yess
00:42:10 <Saizan> @check \x y -> x * y == y * (x :: Double)
00:42:11 <lambdabot>   "OK, passed 500 tests."
00:42:30 <thoughtpolice> oh and for the record I remember why I like writing code in haskell so much: because there have been several instances over the past few days when I've been writing my garbage collector in C where I was fairly convinved that I had gone insane.
00:43:12 <dolio> Perhaps you have.
00:43:28 <pumpkin_> o nos
00:43:30 <thoughtpolice> and then it turns out i had a static var in an include file, or I forgot to take something into account. gotta love it.
00:43:35 <trofi^w> who can help me to setup Home/End keys in YI ? :]
00:43:37 <thoughtpolice> dolio: it's likely.
00:43:51 <dolio> What's the garbage collector for? lhc?
00:44:00 <dolio> I thought you guys were writing it in E or something. :)
00:44:06 <thoughtpolice> dolio: hehe.
00:44:25 <thoughtpolice> dolio: it's actually not for lhc
00:44:52 <trofi^w> which library does YI use to interpret ESC sequences?
00:45:02 <thoughtpolice> it's for another compiler I'm working on; I'm mainly using it to get a grip on the situation of writing one, what problems there could be, and what strategy might be good for LHC
00:45:13 <dolio> Ah.
00:45:24 <thoughtpolice> dolio: but the fact I started writing one indeed comes from lhc's need for one.
00:45:32 <pumpkin_> I wonder if I'm the only one in here who hasn't written his own language
00:45:41 <pumpkin_> (her)
00:46:51 <Gracenotes> hm. What's it about state that makes mutable testing correctness difficult?
00:46:59 <thoughtpolice> dolio: because the fact of the matter is I'm pretty sure I could realistically write a GC in C and hook it into LHC as-is with the C backend, but we just don't want that.
00:47:10 <Gracenotes> er, mutable state, specifically, and testing for that
00:47:36 <Gracenotes> I've heard talk about it before... something about combinations of data... blah. .x.
00:48:11 <thoughtpolice> I mean, this whole writing a GC story of mine would be over probably if I could use C as the target language instead of asm :p
00:48:35 <pumpkin_> why not c--? :P
00:48:53 <thoughtpolice> pumpkin_: actually you fit the bill, but not for LHC, for this thing I'm working on
00:48:54 <Gracenotes> o nos c--
00:48:59 <pumpkin_> o nos
00:49:05 <pumpkin_> how do I fit the bill?
00:49:09 <thoughtpolice> i would like to extend it to a full compiler someday in the far future, but the first order is to get this thing to go C-- -> asm
00:49:13 <Gracenotes> so, any ideas about state?
00:49:14 <pumpkin_> am I orange enough?
00:49:21 <thoughtpolice> oi, sorry. tired. :(
00:49:28 * thoughtpolice should watch what he types
00:49:48 <thoughtpolice> pumpkin_: if quickc-- was generally usable though I would much rather generate c-- in both lhc and this thing and use that, yes
00:50:00 <pumpkin_> I wonder if c-- would be a good way to approach decompilation
00:50:02 <dolio> Gracenotes: What kind of mutable state?
00:50:04 <thoughtpolice> unfortunately that's not the case.
00:50:05 <thoughtpolice> :(
00:50:29 <dolio> Global mutable state is a pain because you potentially have to set up the appropriate global conditions before each test.
00:50:32 <pumpkin_> thoughtpolice: ah :/
00:50:45 <thoughtpolice> pumpkin_: I still don't think I've quite got it working right, even
00:50:48 <Gracenotes> dolio: mutable states that are part of a value. for instance, the month value, day value and year value in a mutable date object
00:50:59 <thoughtpolice> (quickc--'s build system, that is)
00:51:24 <pumpkin_> thoughtpolice: hasn't someone pulled out ghc's c--/cmm codegen thing? it could do intel and sparc at least :P
00:51:35 <pumpkin_> would allow people to avoid writing their own codegens each time
00:51:44 <thoughtpolice> pumpkin_: but for this compiler i'm writing in SML, yeah, my first goal is to at least be able to go from C-- to ASM, even if I just have to feed it a raw C-- AST, and it does 0 optimization
00:51:49 <pumpkin_> or a cmm->llvm layer
00:51:59 <pumpkin_> ah
00:52:13 <pumpkin_> can't you rip the cmm code out of ghc then?
00:52:15 <thoughtpolice> fancy stuff can come later.
00:52:21 <Gracenotes> dolio: basically, I mean verifying program correctness in general with mutable objects instead of immutable ones
00:52:25 <thoughtpolice> i could. but this compiler is in SML. :)
00:52:33 <pumpkin_> oh you and your fancy languages
00:53:15 <thoughtpolice> i would say haskell is a little fancier than sml, personally (or at the very least ghc extensions)
00:53:24 <dolio> Gracenotes: State and mutability makes equational reasoning harder.
00:53:30 <thoughtpolice> sml/nj is afaik the only sml 97 compiler that actually implements *any* extensions at all
00:53:35 <pumpkin_> :)
00:53:40 <pumpkin_> fancy = I don't know it
00:53:45 <thoughtpolice> hehe
00:53:53 <thoughtpolice> moscow ml doesn't quite follow the standard, either
00:53:58 <thoughtpolice> mlton and poly/ml are pretty spot on
00:54:12 <pumpkin_> why not ocaml?
00:54:16 <thoughtpolice> what really sucks though is that SML-nj have a lot of great tools
00:54:25 <thoughtpolice> that use their extensions
00:54:33 <Gracenotes> dolio: hm. Equational reasoning generally is what? I've heard of it, at least.
00:54:33 <thoughtpolice> like ml-ulex and ml-antlr
00:54:59 <thoughtpolice> and i prefer MLton (because it's very optimizing and it generates executables)
00:55:00 <dolio> 'v = i++ ; foo v v' is different from 'foo (i++) (i++)', so you can't arbitrarily substitute things for their definitions and vice versa.
00:55:07 <thoughtpolice> so that throws them out the window
00:55:33 <thoughtpolice> i mean I could just use sml/nj, and just distribute a heap image and a shell script to start sml/nj with that heap file, but I don't know if I want to go that route yet
00:55:47 <thoughtpolice> and I think mlton will give me a faster code in terms of how fast the compiler is
00:56:03 <pumpkin_> ah
00:56:09 <thoughtpolice> mlton gets stomped on because it has a startup-time and NO benchmarks take any advantage of its good optimizations
00:56:48 <Gracenotes> dolio: hm, thanks. Seems like a corner case, but... I'll look into that sort of reasoning
00:57:23 <thoughtpolice> it's when your code is split up among tons and tons of signatures/functors etc. that mlton really shines, because it can do things it otherwise couldn't (cross-module inlining, unboxing, etc) across the entire program
00:57:34 <dolio> Gracenotes: There were (are) people out there a while back who advocated solving programming problems by first writing a naive solution, and then optimizing it by making use of correctness-preserving transformations.
00:57:41 <thoughtpolice> so I'm convinced for a compiler of reasonable size, by building with mlton I'll get a faster compiler
00:57:46 <dolio> Bird and whatnot. The Squiggol guys.
00:57:49 <thoughtpolice> AND make usage/distribution easier
00:58:04 <thoughtpolice> pumpkin_: also I don't like ocaml's syntax that much
00:58:09 <pumpkin_> ah
00:58:18 <ski> (thoughtpolice : you're writing the compiler in SML, then ?)
00:58:20 <pumpkin_> I don't know it well, I just know it's supposed to be fast :)
00:58:25 <Gracenotes> hm. Intereting, although correction-preservation transforms on a small scale can preclude larger ones
00:58:28 <thoughtpolice> ski: yeah
00:58:47 <dolio> Gracenotes: But that's easier if you have easy correctness preserving equations. And mutable state and side effects muddy that somewhat.
00:59:30 <ski> (thoughtpolice : it might be interesting to write a partial evaluator, and an interpreter, and partially evaluate the partial evaluator wrt to the interpreter, to synthesize a compiler ..)
00:59:42 <dolio> Gracenotes: Like, a simple one might be "map f (map g l) = map (f . g) l". That sort of fusion eliminates an intermediate list.
01:00:02 <thoughtpolice> ski: i have futamura's paper sitting on my desktop somewhere...
01:00:03 <dolio> But, it only holds if f and g perform no side effects.
01:00:04 <Gracenotes> yeah
01:00:15 <thoughtpolice> pumpkin_: but yeah, there's my reasoning.
01:00:17 <ski> thoughtpolice : hm, what's the name of the original paper(s) ?
01:00:30 <thoughtpolice> i guess i'll just have to use ml-lex and ml-yacc since they're sml98 compatible :(
01:00:37 <ski> (or maybe not original, if there's ones presenting the issues better ..)
01:00:46 <dolio> (Or if you don't care about the order of the side effects, I suppose.)
01:01:03 <thoughtpolice> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.10.2747
01:01:15 <thoughtpolice> ski: also http://www.itu.dk/people/sestoft/pebook/
01:01:20 <thoughtpolice> but i haven't really heard anything about that book
01:01:56 <Gracenotes> okay :)
01:02:12 <pumpkin_> can agda be compiled to native code?
01:02:14 <thoughtpolice> ski: but who knows, it's still in its infancy enough that might be neat to try :)
01:02:19 <thoughtpolice> pumpkin_: there's an FFI to haskell
01:02:30 <thoughtpolice> and you can then use the adga command to compile it
01:02:41 <pumpkin_> I'd like to get my hands wet with a dependently typed language but they look scary :P
01:02:46 <cads_> the futamura paper makes my head hurt
01:02:51 <thoughtpolice> pumpkin_: coq is pretty nice. :)
01:02:58 <cads_> that's what she said
01:03:02 <thoughtpolice> pumpkin_: also ATS is a little intimidating, but it's at least realistic
01:03:14 <thoughtpolice> www.ats-lang.org
01:03:19 <pumpkin_> coq looks nice, but I'd be embarrassed to talk about it ;)
01:03:31 <cads_> thoughtpolice: have you played around with ATS?
01:03:38 <thoughtpolice> a little
01:03:42 <ski> thoughtpolice : ty for the references
01:03:54 <thoughtpolice> the documentation seems to have improved since the last time I checked it out (few months ago.)
01:03:59 <thoughtpolice> there were tons of dead links
01:04:04 <thoughtpolice> i assume it was being written :)
01:04:41 <thoughtpolice> ski: neat idea though, thanks. that might be something worth toying with :)
01:05:22 <cads_> it looked like C mixed with terribly verbose types and I was too a'feared to try to understand it much, last time I gazed upon ATS
01:05:29 <ski> thoughtpolice : i was just mentioning it as something possibly fun. if you actually think you can toy with it, all the better :)
01:05:54 <thoughtpolice> ski: fun is good!
01:06:13 <cads_> though I'd like to understand about how a low level seeming language can support dependent types
01:06:16 <ski> (as long as it's actual fun, not just imagined possible fun)
01:06:37 <thoughtpolice> cads_: ATS is high level, it just has really good interoperability with C
01:06:42 <thoughtpolice> ATS is really just an ML
01:06:47 <cads_> maybe the C-ish syntax makes it look lower level than it is
01:06:48 <thoughtpolice> the author was also the creator of dependent ml
01:06:55 <cads_> ah
01:07:00 <pumpkin_> the syntax is kinda icky
01:07:00 <thoughtpolice> which was a form of sml with limited dependent types
01:07:01 <ski> DML ?
01:07:11 <thoughtpolice> in the form of numeric stuff in types
01:07:52 <thoughtpolice> but aside from that, ATS also has a good implementation
01:08:02 <thoughtpolice> the manual states how things like linear types lead to extremely efficient code
01:08:15 <ski> linear or uniqueness ?
01:08:15 <thoughtpolice> I mean, ATS was dominating the quad-core shootout entirely for a while there...
01:08:20 <pumpkin_> linear
01:08:32 <pumpkin_> that's the only reason I know of it
01:08:37 <pumpkin_> it looks awesome on the shootout
01:08:42 <ski> (so, not similar to Clean or Mercury, then ?)
01:08:49 <thoughtpolice> really ATS would be so much better
01:08:51 <pumpkin_> it's a good way to get people to notice you, to dominate shootout
01:08:57 <thoughtpolice> if there was just a few basic libs out there
01:09:10 <thoughtpolice> binding to C with ATS is so ridiculously easy it's almost pathetic
01:09:21 <pumpkin_> aren't linear types a similar concept to uniqueness types?
01:09:26 <thoughtpolice> i think if there was some time spent wrapping good interfaces
01:09:32 <aleator> Fun with quasiquotes: http://haskell.pastebin.com/m5454a4a6
01:09:37 <thoughtpolice> like perhaps things like libev or something
01:09:41 <thoughtpolice> then ats would get a lot more attention
01:09:48 <thoughtpolice> after all, it is designed as a systems programming language too
01:09:56 <thoughtpolice> the author intended it to be used for things like that.
01:10:38 <ski> pumpkin_ : a non-linear value can be converted into a linear one. a uniquely referenced value can be shared
01:10:46 <ski> pumpkin_ : it's opposite directions
01:10:54 <pumpkin_> ah :)
01:11:00 * pumpkin_ needs to read more
01:11:15 <ski> pumpkin_ : edwardk did some thinking in relating these to each other, istr
01:11:35 <thoughtpolice> linearity guarantees there are no more references to a value
01:11:42 <dolio> Linear types potentially give you nice information about when to allocate/deallocate things.
01:11:45 <ski> thoughtpolice : no
01:11:49 <procyon112> I've got a "Could not find module `System.Posix.Files'" error in cabal.  Says "it is hidden (in package darcs-2.2.1)"  any hints as to what that means and maybe how to fix it?
01:12:08 <ski> thoughtpolice : linearity guarantees that the reference *you* have can't be duplicated (or discarded)
01:12:13 <cads_> where the heck does the word "intercalate" come from?  "awright now son you just go out yonder-thar and intercalate those horses with the wagons, y'hear?"
01:12:23 <Saizan> aleator: how do you strip the right amount of whitespace from the lines?
01:12:25 <ski> thoughtpolice : there can still be other references
01:12:36 <pumpkin_> http://www.answers.com/intercalate
01:12:50 <pumpkin_> @wn intercalate
01:12:52 <lambdabot> *** "intercalate" wn "WordNet (r) 2.0"
01:12:52 <lambdabot> intercalate
01:12:52 <lambdabot>      v : insert (days) in a calendar
01:12:56 <ski> thoughtpolice : a reference of type `!a' can be duplicated many times, then such a copy can be converted into one of type `a', which can't be duplicated any more
01:13:12 <procyon112> cads_:  Now that we's married, I figgure we oughts ta intercalate the relationship and gets us some yunguns.
01:13:21 <thoughtpolice> ski: ah ok
01:13:24 <aleator> Saizan: Second line decides the indentation currently. (or next non-empty line)
01:13:55 <Saizan> aleator: i see
01:14:07 <thoughtpolice> ski: i must have got the wrong impression; i had a paper around earlier about a linear lisp...
01:14:12 <ski> thoughtpolice : Clean and Mercury implement uniqueness systems (ideas developed independently, i think)
01:14:18 <aleator> Saizan: quite a hack I think. I wonder if there is any real use for this.
01:14:18 <thoughtpolice> author wrote another article to i think
01:14:22 <temoto> Is it one of application of value dependant types, that they would allow define one (+) for Num and [] and behave appropriately in those different cases?
01:14:26 <thoughtpolice> ski: I was aware of clean, not of mercury
01:14:27 <ski> thoughtpolice : yes, there's some confusion around
01:14:45 <thoughtpolice> well, i wasn't aware mercury used uniqueness types, anyway
01:15:13 <thoughtpolice> temoto: dependent types give you proof-carrying code
01:15:13 <ski> thoughtpolice : Clean embeds uniqueness information into types, Mercury embeds it into instantiation( state)s
01:15:27 <thoughtpolice> ski: ah.
01:15:35 <thoughtpolice> ski: i haven't spent much time with clean, uh, at all
01:15:38 <thoughtpolice> i'm an OS X user
01:15:45 <thoughtpolice> :(
01:16:17 <cads_> thoughtpolice: was this the paper you were thinking of? http://home.pipeline.com/~hbaker1/ForthStack.html
01:16:26 <dolio> Does ATS still have the sort of 'limited' dependent types as DML?
01:16:42 <dolio> (Only, not just integers anymore?)
01:17:06 <pumpkin_> would having dependent types on ieee floats make sense?
01:17:54 <pumpkin_> is there a kind of typeclass of the types of values you can use in a dependently typed system?
01:18:00 <thoughtpolice> cads_: no, but same author actually!
01:18:02 <thoughtpolice> http://home.pipeline.com/~hbaker1/Use1Var.html
01:18:08 <thoughtpolice> http://home.pipeline.com/~hbaker1/LinearLisp.html
01:18:09 <ski> cads_ : possibly <http://home.pipeline.com/~hbaker1/LinearLisp.html> Lively Linear Lisp -- 'Look Ma, No Garbage!'
01:18:09 <thoughtpolice> those two
01:19:01 <thoughtpolice> dolio: it has like a full blown total proof language now too and in general things like termination guarantees etc. are verified by structural induction on a parameter, etc.
01:19:20 <dolio> Hmm.
01:20:11 <cads_> is it done yet?
01:20:14 <thoughtpolice> dolio: but what do you mean by limited if i might ask? when I said that I just meant 'dependent types' only extended as far as numbers
01:20:29 <cads_> when can I run untrusted code that comes with a proof of friendliness?
01:20:31 <thoughtpolice> ATS is way more advanced
01:21:03 <dolio> thoughtpolice: Well, I'm reading the basics page, and it still talks about stuff like "int(i)", which is a singleton type of integers inhabited by only i.
01:21:26 <ski> (pumpkin_),Botje,(benmachine,et al.) : i prefer to use `=' for equality, and specify otherwise whether this equality is meant as an assumption, or a definition (a special case), or a result
01:21:42 <dolio> But that's the kind of construction you use in Haskell with GADTs to fake dependent typing, not something you'd use in, say, Agda or Coq.
01:22:01 <thoughtpolice> yeah
01:22:57 <funktio> I think this is a pretty interesting example of what can be done in ATS: http://www.ats-lang.org/EXAMPLE/MISC/listquicksort.dats
01:23:03 <thoughtpolice> i dunno, but I think if you want at least a reasonbly realistic dependently typed programming language -today-, ats is probably your best choice. fast, multicore, dead-simple interfacing, simple compilation model.
01:23:19 <thoughtpolice> going the theorem prover route and extracting code works too
01:23:50 <pumpkin_> funktio: so that's a proved quicksort that's also wicked fast? :P
01:24:00 <pumpkin_> pity it's not pretty too :(
01:24:09 <funktio> pumpkin_: I don't know how fast it is :P
01:24:22 <thoughtpolice> funktio: it dominated the quad-core shootout, and is still pretty high up there
01:24:24 <thoughtpolice> afair
01:24:31 <pumpkin_> I wonder how painful the proof for introsort would be
01:24:44 <thoughtpolice> (ATS was top on the quad-core shootout for a pretty long time, really...)
01:24:50 <funktio> yeah, ATS programs tend to be quite verbose
01:25:16 <thoughtpolice> the shootouts in this case probably aren't all that unrepresentative of what actual code is going to look like
01:25:17 <cads_> I noticed they're around twice as large as the equivalent c programs
01:25:17 <funktio> thoughtpolice: yeah, I know, just not sure about the speed of that particular quicksort
01:25:38 <pumpkin_> http://shootout.alioth.debian.org/u32q/benchmark.php?test=mandelbrot&lang=all vs. http://shootout.alioth.debian.org/u64q/benchmark.php?test=mandelbrot&lang=all
01:25:47 <pumpkin_> why is GHC so much slower?
01:25:51 <thoughtpolice> like I said, if some libraries could get going that wrap up some good C code, it would be way more viable to develop in now
01:26:30 <thoughtpolice> until then you'll probably have to do a bit of inline C here there and everywhere
01:27:37 <cads_> has anyone here played around with Z-notation?
01:29:05 <cads_> it seems sufficiently mathy and pretty enough to help translate your math and refine it into an implementation
01:29:38 <cads_> but is it a mostly manual tool?
01:31:50 <cads_> mmm, I'd use it even if it was just a fancy notation convention for set theory and predicate logic
01:33:19 <dolio> thoughtpolice: That quicksort proof does the same thing, incidentally. It defines type-level (static) integer lists (intlist), and then defines a family of singleton list types (forgiving the Agda notation) list : intlist -> Set, and then defines a type of value-level lists as something like 'exists xs:intlist. list xs'.
01:34:12 <pumpkin_> anyone have any idea about why mandelbrot is so much slower on the 64-bit arch?
01:34:16 <dolio> The dependent typing in ATS seems a lot like what you'd get if you extended GHC with nicer type-level syntax and datakinds and such.
01:34:26 <cads_> what I read about Z sounds amazing, but then what Z code I read looks a little crappy, and I'd rather stick with my half baked set theory notations
01:38:13 <quicksilver> pumpkin_: odd. GHC typically produces better floating point code on x86_64 I thought.
01:38:31 <pumpkin_> yeah, it's 2x on 32, and 12x on 64
01:38:40 <pumpkin_> a bug?
01:38:50 <pumpkin_> or actually
01:39:10 <pumpkin_> do we explicitly mention a 32-bit arch in the ghc args?
01:39:31 <pumpkin_> oh actually I have it backwards
01:39:38 <pumpkin_> it's the 32-bit one that's too slow
01:39:53 <Axman6> it's compiled without -threaded right?
01:40:03 <pumpkin_> it's on the quad-core benchmark
01:40:07 <pumpkin_> but yeah, it's only using one core
01:40:19 <pumpkin_> seems odd
01:40:21 <osfameron> are hpastes persistent?
01:40:27 <pumpkin_> osfameron: mostly
01:40:29 <roel`> Are there any native Swedish speakers here?
01:40:54 <pumpkin_> roel`: #haskell.se maybe?
01:41:07 <osfameron> I'm writing up the grid discussion from yesterday, wanted to quote dolio's stuff... so I can probably link to the hpaste and hope for the best :-0
01:41:08 <roel`> I am writing a package that can 'speak' numbers in a number of languages
01:41:16 <roel`> Like 3 in english -> "three"
01:41:31 <pumpkin_> ah nice
01:41:31 <roel`> I need to know how you say negative numbers in swedish :-)
01:41:58 <Axman6> negabork
01:42:01 <Axman6> >_>
01:42:14 <pumpkin_> lol
01:42:17 <roel`> hehehe
01:42:18 <pumpkin_> @slap Axman6
01:42:18 * lambdabot pulls Axman6 through the Evil Mangler
01:42:25 <Axman6> yum
01:42:25 * pumpkin_ muahahahahas evilly
01:42:26 <roel`> negabork tv√•
01:42:38 <pumpkin_> shouldn't there be a diacritic of some sort on the bork?
01:44:31 <ski> roel` : "minus fyrtiotvÂ"
01:44:48 <ski> (pumpkin_ : no, please not)
01:44:53 <pumpkin_> ok :)
01:44:59 <roel`> ski: is simply prefixing "minus" enough for cardinal numbers?
01:45:14 <ski> (/me thinks "Motˆrhead" looks incredibly stupid ..)
01:45:35 <ski> roel` : cardinal numbers are usually not negative, no ?
01:45:52 <roel`> ski: Well, that is true
01:46:02 <roel`> ski: But I don't know how to call them
01:46:03 <dolio> osfameron: Quote whatever you like.
01:46:12 <roel`> ski: Most languages have some way to pronounce negative numbers
01:46:17 <ski> (though one could imagine a grothendieckization of bags ..)
01:46:47 <IminYourMonad> why havent anyone mentionded drawingcombinators before? seems very cool
01:46:47 <roel`> ski: When I say cardinal I am referring to the linguistic term
01:46:51 <tibbe> do we have someone that could be used as contact person between Google and Haskell during this year Google Summer of Code?
01:46:54 <osfameron> dolio: thanks :-)
01:46:59 <roel`> ski: Not that I know much about linguistics... :-)
01:47:18 <quicksilver> pumpkin_: well that's more sensible.GHC's fp code on x86 is nt good.
01:47:39 <pumpkin_> quicksilver: ah :/ but wouldn't via-C fix that?
01:47:56 <ski> roel` : (ianal, but) isn't cardinal numbers only used for specifying the total count of things
01:48:01 <quicksilver> pumpkin_: via-C has its own disadvantages.
01:48:04 <pumpkin_> ianal = I am not a linguist?
01:48:12 <ski> pumpkin_ : yes, obviously :)
01:48:15 <pumpkin_> yay
01:48:22 <quicksilver> pumpkin_: and the other languages may generate SSE code etc
01:48:28 <pumpkin_> yeah
01:48:48 <pumpkin_> still, 12x the top one makes me sad :(
01:48:49 <quicksilver> pumpkin_: also, ISTR the mandelbrot code uses Complex Double?
01:49:01 <pumpkin_> nope, didn't see that in it
01:49:22 <pumpkin_> it's doing the complex math explicitly
01:55:12 <roel`> ski: But if you have -123 euros on your bank account you could still pronounce that quantity in Swedish right?
01:57:12 <pumpkin_> no euros in sweden
01:57:12 <ski> "jag har minus hundra tjugo tre euro pÂ bankkontot"
01:57:12 <roel`> Oh yea, I should have remembered that
01:57:12 <ski> (pumpkin_ : not much, anyway)
01:57:12 <pumpkin_> :)
01:57:12 <Axman6> ha, just noticed the runtime for ruby here: http://shootout.alioth.debian.org/u64q/benchmark.php?test=mandelbrot&lang=all
01:57:12 <roel`> Hmm, my function produces "minus etthundratjugotre"
01:57:12 <pumpkin_> yeah, lol
01:57:12 <Axman6> 3h 23m XD
01:57:12 <pumpkin_> of course, speed isn't everything )
01:57:12 <Axman6> yeah, but that's pathetic
01:57:12 <ski> roel` : i'm not sure if the insertion of spaces inside the number proper is standardized ..
01:57:12 <Axman6> # For..in loops are faster than .upto, .downto, .times, etc.
01:57:12 <ski> (it possibly is, but i don't know about it)
01:57:12 <Axman6> # That's not true, but left it here
01:57:12 <Axman6> lol
01:57:12 <pumpkin_> awesome
01:57:12 <roel`> ski: I think I read something about dividing a numbers in groups of millons and separating the groups with spaces
01:57:12 <roel`> ski: Still, the spaces make it much more readable
01:57:12 <ski> roel` : yes, that's similar to writing "123,456" or "123 456" instead of "123456"
01:57:12 <ski> (obviously, in swedish proper, `,' is used for separating whole part from fraction part)
01:57:12 <roel`> ski: A fractions, partitive numerals are a TODO, but first the ordinals
01:57:12 <pumpkin_> I wonder if any programming languages allow you to switch to that convention
01:57:12 <roel`> I still need to invent an algorithm for ordinals
01:57:12 <ski> roel` : what is the ordinal corresponding to the cardinal "zero" ?
01:57:12 <roel`> nolleth? :-)
01:57:12 <roel`> nollte
01:57:12 * ski has considered "zero"-"first","one"-"second","two"-?,"three"-"third",et.c.
01:57:12 <opqdonut> zeroth ;)
01:57:12 <ski> there's also the "once","twice","thrice" sequence to extend for "zero" and "four",et.c.
01:57:12 <roel`> Just append "times" after the cardinal
01:57:12 <roel`> four times
01:57:12 <roel`> zero times
01:57:12 <roel`> Still english only has 3 of such numerals (multiplicative)
01:57:12 <roel`> Other languages may have more, or less. Like Dutch.
01:57:12 <roel`> I think we have none :-(
01:57:46 * ski spent some time looking for the single word corresponding to "zero times", when writing some code for church numerals
02:01:18 <roel`> It is really hard to find any information about negative numbers in foreign languages
02:01:27 <roel`> They all want to teach you to count [1..100]
02:01:34 <roel`> Noone counts below 0
02:02:22 <funktio> roel`: want help with Finnish? :)
02:03:02 <roel`> funktio: I have no support for Finnish yet
02:03:15 <roel`> funktio: To what language family or genus does it belong?
02:03:27 <roel`> funktio: Is it comparable with some other language?
02:04:26 <solidsnack> roel`: Basically, no.
02:04:38 <solidsnack> Karellian, I guess.
02:04:54 <roel`> solidsnack: Ah, that makes it a challenge :-)
02:05:42 <funktio> roel`: Estonian is similar, but I don't know about others really. Wikipedia says it's Uralic: http://en.wikipedia.org/wiki/Uralic_languages
02:06:16 <Baughn> roel`: "0"?
02:06:20 <roel`> Each new language 'type' is a test for the design of my package
02:06:33 <roel`> So new 'types' of languages are very interesting
02:06:52 <pumpkin_> do you do japanese yet?
02:06:54 <roel`> So fat Germanic and Romance languages are no problem
02:06:55 <Baughn> Hum. How about asian languages?
02:06:58 <roel`> Yes, I have japanese
02:07:01 <roel`> That was quite easy
02:07:01 <funktio> Thai?
02:07:03 <pumpkin_> that's a pretty easy one :)
02:07:04 <pumpkin_> yeah
02:07:07 <roel`> Nope
02:07:09 <roel`> Only japanese
02:07:16 <Baughn> Babylonian?
02:07:27 <pumpkin_> italian? ;)
02:07:31 <roel`> And for japanese that version that uses the latin alphabet
02:07:43 <pumpkin_> aw
02:07:46 <pumpkin_> that's no good
02:07:56 <roel`> Here are the language codes for what I have right now: nl, en, de, se, no, la, fr, it, sp, pt, ja, eo
02:07:59 <Baughn> roel`: Romanji
02:08:05 <pumpkin_> romaji :)
02:08:06 <roel`> Only cardinals for now
02:08:09 <pumpkin_> or roumaji, really
02:08:16 <roel`> I plan to release an initial version soon
02:08:26 <Baughn> Or romanji. Don't stick to a single system of romanization. :P
02:08:34 <pumpkin_> there just isn't an N in it :P
02:08:45 <Baughn> pumpkin_: It shouldn't be hard to add one using actual kana, though
02:08:45 <pumpkin_> but yeah, I'm not proposing a particular romanization :)
02:08:48 <Baughn> Er, *roel
02:09:01 <pumpkin_> ‰∫åÂçÅÂõõ
02:09:03 <roel`> Languages which use alphabets other that latin are quite hard for me to implement because I have no idea whether I do it correctly
02:09:23 <pumpkin_> roel`: luckily japanese counting is so regular, you just need to keep in mind that they count in ten-thousands
02:09:48 <roel`> pumpkin_: Yes, the myriad thing. But it seems to work
02:10:01 <Baughn> What's the japanese for hundred-million, anyway?
02:10:13 <roel`> ichi-oku
02:10:26 <pumpkin_> do you need the ichi there?
02:10:39 <Baughn> I've never heard anyone leave it off..
02:10:46 <roel`> testS ja Masculine [123456] => jk ni-man san-sen yon-hyaku go-jk roku
02:10:59 <roel`> the k's are u's with a diacritic mark
02:11:08 <roel`> Ghci has some problems displaying them in Emacs
02:11:12 <pumpkin_> for oku
02:11:13 <pumpkin_> ?
02:11:40 <roel`> I can only be reasonably sure of the correctness of nl, en, de and fr
02:11:49 <roel`> The other languages I barely know
02:11:49 <Baughn> pumpkin_: In general, rather
02:12:24 <PHO_> oh people talking about Japanese, the native language of mine
02:12:37 <pumpkin_> yay PHO_!
02:12:42 <chowmeined> haskell is interesting
02:12:44 <pumpkin_> PHO_: do you need ichi for oku?
02:12:52 <lstor> How can I insert a string between each character of another string? (As 'intersperse' only takes characters)
02:12:52 <pumpkin_> (when counting)
02:12:53 <chowmeined> they just said
02:12:54 <chowmeined> 24
02:12:57 <PHO_> yes. it cannot be dropped
02:13:01 <chowmeined> ER SHIR SI
02:13:01 <pumpkin_> ah ok
02:13:22 <roel`> Does Japanese have a system for naming really *LARGE* numbers?
02:13:25 <chowmeined> well, nevermind that r
02:13:28 <Baughn> > concat $ intersperse "Hey" $ map (:[]) "Foo the foo"
02:13:30 <lambdabot>   "FHeyoHeyoHey HeytHeyhHeyeHey HeyfHeyoHeyo"
02:13:30 <roel`> Like larger than 10 ^ 68?
02:13:34 <pumpkin_> lol
02:13:34 <chowmeined> roel`, arabic numerals
02:13:44 <lstor> Baughn: Thanks :)
02:13:48 * ski wonders how sumerian counting would sound
02:13:48 <chowmeined> roel`, 1 000 000
02:13:53 <PHO_> hmm... maybe but I don't know
02:14:07 <pumpkin_> PHO_: how do you say exponential numbers?
02:14:09 <Baughn> lstor: Probably not the best way to go about it.. hopefully the optimizer will fuse it.
02:14:12 <pumpkin_> like "10 to the power of 5"
02:14:19 <roel`> I read there was some controversy regarding large numbers in japanese because of some historic texts
02:14:19 <PHO_> ju no go jou
02:14:31 <pumpkin_> what character is that last jou?
02:14:36 <PHO_> ju = 10,  x no y jou means x to the power of y
02:14:37 <roel`> The largest my system 'knows' is mury≈çtais≈´
02:14:40 <ski> (roel` : btw, #linguistics might be useful)
02:14:46 <PHO_> ÂçÅ
02:14:49 <roel`> ski: Ah, thanks for the tip
02:15:05 <lstor> Baughn: I won't use it in a big program anyway, so speed really isn't important
02:15:12 <chowmeined> ÂçÅ
02:15:16 <pumpkin_> PHO_: that's juu isn't it?
02:15:23 <PHO_> ah, sorry
02:15:27 <PHO_> ‰πó
02:15:29 <pumpkin_> aha
02:15:31 <PHO_> 10„ÅÆ5‰πó
02:15:32 <chowmeined> yi er san si wu liu qi ba jiu shi
02:15:37 <pumpkin_> thanks :)
02:17:08 <PHO_> japanese has indeed a word ÁÑ°ÈáèÂ§ßÊï∞ (muryou-taisuu), but its actual value isn't defined well
02:17:22 <PHO_> because nobody really use it
02:17:54 <solidsnack> What exactly is being built that requires all these crazy numbers?
02:18:03 <Dessous> Btw what does it matter to what language family does a language belong if you are only using numbers?
02:18:05 <Baughn> Hm. I've heard it, but I figured it just meant "myriad", in the "indeterminately lots and lots" sense
02:18:09 <roel`> solidsnack: nothing really, just for fun
02:18:33 <Baughn> Dessous: Different families handle numbers quite differently
02:18:33 <PHO_> solidsnack: something related to Buddhism, but I don't know well
02:18:43 <roel`> PHO_: It' still fun to feed a number like 10 ^ 72 - 1 into my algorithm
02:18:45 <Dessous> Yea but not always
02:18:48 <PHO_> I'm not a Buddhist :)
02:18:53 <solidsnack> PHO_: Buddhism?
02:19:24 <roel`> Baughn: The different ways in which languages handle numbers is the main design challange
02:19:33 <PHO_> solidsnack: Buddhism is a religion... don't you know?
02:19:49 <solidsnack> PHO_: Yes, I know.
02:20:13 <solidsnack> Fear almighty Buddha!
02:20:19 <PHO_> haha
02:20:25 <solidsnack> What does any of this have to do with Lord Buddha?
02:21:00 <Dessous> English: one two three four sixty-four Swedish: ett tv√• tre fyra sexti√•tta or something Finnish: yksi kaksi kolme nelj√§ kuusikymment√§nelj√§ German: Ein Zwei Drei Vier Vier und Sechzig
02:21:16 <PHO_> sorry, my knowledge of English is too restricted to explain that
02:21:17 <Dessous> I don't sepak german or wedish so there may be errors, but they are all pretty similar
02:21:37 <ski> Dessous : s/sextiÂtta/sextifyra/
02:21:57 <Dessous> Oh yea my bad
02:22:00 <Dessous> I meant sextifyra
02:22:06 <ski> ("sextiÂtta" is "sixtyeight")
02:22:08 <Dessous> i know
02:22:22 <solidsnack> PHO_: Oh, you are saying the number ÁÑ°ÈáèÂ§ßÊï∞ has something to do with Buddhism?
02:22:42 <PHO_> solidsnack: yes
02:23:13 <pumpkin_> http://ja.wikipedia.org/wiki/ÁÑ°ÈáèÂ§ßÊï∞
02:23:29 <PHO_> ÈÇ£Áî±Â§ö (nayuta), ‰∏çÂèØÊÄùË≠∞ (fukashigi), and such like are also related to Buddhism
02:24:01 <solidsnack> ÁÑ°ÈáèÂ§ßÊï∞ ~= "vast number/fate without measure"
02:25:12 <quicksilver> pumpkin_: ok, I'm on a real link and I can look at the mandelbrot source.
02:25:18 <solidsnack> ‰∏çÂèØÊÄùË≠∞ ~= "beyond comprehension"
02:25:24 <pumpkin_> quicksilver: yay
02:25:26 <quicksilver> pumpkin_: it's supposed to be parallel but it's not being run in parallel.
02:25:30 <quicksilver> pumpkin_: it's only using one core
02:25:32 <PHO_> solidsnack: literally yes
02:25:33 <pumpkin_> yeah
02:25:38 <quicksilver> I guess the shootout isn't passing the -N6 option.
02:25:41 <solidsnack> PHO_: What is your nationality?
02:25:46 <PHO_> Japan.
02:25:50 <solidsnack> Ah.
02:26:03 <Axman6> japanese*
02:26:13 <quicksilver> pumpkin_: so, that accounts for a 4x difference, so in a sense GCC is 3x faster not 12x.
02:26:15 <pumpkin_> Êó•Êú¨‰∫∫*
02:26:24 <PHO_> yes, I'm a Êó•Êú¨‰∫∫
02:26:26 <IminYourMonad> groupByHomology :: [a] -> [[a]]
02:26:30 <pumpkin_> quicksilver: yeah, but it's the same program as the 64-bit one, which runs at 400%
02:26:30 <solidsnack> Yeah, your _nation_ is Japan, your _nationality_ is Japanese.
02:26:40 <pumpkin_> quicksilver: did someone just forget to pass +RTS -N6 to it
02:26:58 <PHO_> I see
02:27:07 <solidsnack> I would need more background to see the connection to Buddhism.
02:27:14 <quicksilver> pumpkin_: also, the GCC does contain direct asm.
02:27:19 <quicksilver> pumpkin_: you might call that cheating :)
02:27:25 <pumpkin_> I would indeed :P
02:27:45 <pumpkin_> but just getting it up to 400% would get us back up to a reasonable spot at least
02:27:48 <pumpkin_> 12x is pretty sad
02:27:49 <solidsnack> For example, ÊÄùË≠∞ might be the Buddhist term we translate as "discriminative thinking".
02:27:55 <IminYourMonad> what is cairo? a gui-lib?
02:27:59 <quicksilver> pumpkin_: it's manually vectorised to use SSE2, it looks like.
02:28:07 <quicksilver> pumpkin_: (the gcc one)
02:28:15 <pumpkin_> v2df delta = (v2df)__builtin_ia32_cmplepd( (Trv + Tiv), four );
02:28:15 <pumpkin_> 		mask = __builtin_ia32_movmskpd(delta);
02:28:16 <pumpkin_> lol
02:28:33 <pumpkin_> we should give ghc "functions" (primops) for all the x86 instructions
02:28:35 <quicksilver> right., where "typedef double v2df __attribute__ ((vector_size(16))); /* vector of two doubles */
02:28:38 <quicksilver> "
02:28:48 <quicksilver> i.e. that's an SSE2 128-bit word.
02:28:51 <pumpkin_> yeah
02:28:57 <ski> IminYourMonad : is that related to (co)homology groups ?
02:29:22 <PHO_> solidsnack: well, if I see a word "ÊÄùË≠∞" I can interpret so, but there's not really such word
02:30:03 <pumpkin_> quicksilver: the ATS one looks kinda cheaty to me too: http://shootout.alioth.debian.org/u32q/benchmark.php?test=mandelbrot&lang=ats&id=3
02:30:23 <pumpkin_> they have big chunks of c in it
02:30:43 <quicksilver> pumpkin_: well that's the nature of ATS.
02:30:47 <solidsnack> PHO_: How do you know these terms are related to Buddhism? Do they in fact show up in Japanese Buddhist texts?
02:30:47 <quicksilver> ATS is a "cheaty" language.
02:31:10 <pumpkin_> quicksilver: still, they could do those things without any explicit c in there
02:31:13 <quicksilver> pumpkin_: on my machine, the code gives a bus error.
02:31:20 <quicksilver> the C code, that is.
02:31:23 <pumpkin_> ah
02:31:55 <PHO_> solidsnack: hmm... likely.. but I'm not sure
02:31:55 <Axman6> ATS is supposed to be about theorum proving. htf do you use C to do that...
02:31:57 <pumpkin_> http://shootout.alioth.debian.org/u32q/benchmark.php?test=mandelbrot&lang=ats&id=1 is the only non-cheaty one
02:32:18 <solidsnack> I think ATS is "C with theorem proving".
02:32:21 <dolio> pumpkin_: You'll have to console yourself with the fact that the ATS looks absolutely terrible.
02:32:39 <IminYourMonad> what is a combinator? is it function composition, higher order functions?
02:32:44 <pumpkin_> dolio: can't I rat the ATS and gcc people out for cheating? :P
02:33:17 <quicksilver> pumpkin_: inline C is "the point of" ATS
02:33:23 <solidsnack> IminYourMonad: A combinator can be combined with other combinators to specify a computation.
02:33:25 <quicksilver> so, it's not cheating to use that feature.
02:33:34 <quicksilver> it's just a language designed for winning in benchmarks :P
02:33:39 <PHO_> lol
02:33:39 <pumpkin_> lol
02:33:45 <solidsnack> LOL
02:34:01 <pumpkin_> anyway, we can still rat out gcc
02:34:13 <pumpkin_> if we knock #1 out from top place, we can decrease our multiplier :P
02:34:21 <IminYourMonad> how would I do if I wanted to write a haskell program/library but I want people to be able to call the program from Python?
02:34:38 <Axman6> pumpkin_: what's up with the gcc stuff?
02:34:46 <solidsnack> IminYourMonad: I think Gamr7 did something for this, not too long ago.
02:35:07 <solidsnack> If you Google with their name in it, it might be easier to find it.
02:35:11 <Baughn> IminYourMonad: Probably it would involve pretending to be a C library
02:35:13 <HugoDaniel> :P
02:35:13 <pumpkin_> Axman6: "functions" like __builtin_ia32_cmplepd ... we might as well fill up ghc with primops for a bunch of native instructions and claim we're programming in haskell when we're writing asm :P
02:35:21 <quicksilver> Axman6: it contains GCC primops which are basically SSE2 assembly :)
02:35:30 <Baughn> IminYourMonad: You might run into trouble with the RTS requirements.. you definitely would, if you were to use *multiple* haskell libraries
02:35:43 <Axman6> not sure how that's cheating though
02:35:56 <pumpkin_> Axman6: it's a way to write inline asm in their program, without technically writing inline asm
02:36:37 <solidsnack> May be their ought to be a cross platform requirement along with a ban on conditional compilation.
02:36:43 <pumpkin_> if you're testing the compiler (language implementation), skipping it altogether seems like defeating the purpose
02:36:58 <Axman6> guess we could argue that if they can do that, we can use foreign imports of C
02:37:12 <pumpkin_> or even hand-optimized asm :P
02:37:14 <PHO_> I think shootout is a place where one can program his code with pure assembler. It's not a cheat
02:37:25 <quicksilver> PHO_: sure, but that should be the 'asm' entry.
02:37:28 <quicksilver> PHO_: which is fine.
02:37:32 <quicksilver> the idea is to comopare languages.
02:37:36 <PHO_> quicksilver: indeed
02:37:38 <quicksilver> so the C entry should be written in C.
02:37:42 <pumpkin_> an 'asm' entry seems kinda pointless too... this is to compare language implementations, and there isn't any variation in asm implementations
02:37:52 <quicksilver> pumpkin_: well, it's a baseline if nothing else.
02:37:56 <pumpkin_> fair enough
02:38:05 <pumpkin_> "this is the absolute best a human can write without the aid of a computer"
02:38:18 <Axman6> pumpkin_: i want to try writing the n-bodies program using just registers on a 64 bit machine
02:38:26 <quicksilver> In my tests, -RTS -N2 exhibits no useful parallelism
02:38:28 <pumpkin_> Axman6: have fun
02:38:38 <pumpkin_> +RTS?
02:38:40 <quicksilver> -RTS -N3 manages 67 seconds of user time in 45 seconds of real time.
02:38:45 <quicksilver> (yes +RTS)
02:38:57 <pumpkin_> +RTS -N6 does 400% on my machine, 32 bit
02:38:59 <quicksilver> the C version gets near-perfect paralleism
02:39:07 <quicksilver> 28 user, 14 real.
02:39:16 <quicksilver> still the difference is 3x
02:39:17 <quicksilver> not 12x
02:39:22 <quicksilver> (14 real vs 45 real)
02:39:26 <pumpkin_> yeah
02:39:37 <quicksilver> pumpkin_: the official shootout one wasn't even compiled with -threaded
02:39:43 <quicksilver> that's kind of a barrier for useing -RTS options ;)
02:39:46 <pumpkin_> oh
02:39:46 <pumpkin_> COMMAND LINE:
02:39:46 <pumpkin_> ./mandelbrot.ghc-2.ghc_run  16000
02:40:00 <pumpkin_> someone just forgot to tell them to call it with rts options
02:40:08 <solidsnack> Wow, they are only using GHC 2
02:40:15 <quicksilver> pumpkin_: well, pointless also if not using -threaded.
02:40:20 <pumpkin_> yeah, of course
02:40:55 <IminYourMonad> when using FFIs, do you then call a binary file in the other language? or does the called function from the FFI-ed language get compiled when the haskell-program is?
02:41:01 <pumpkin_> that'd be a really easy boost on the shootout
02:41:15 <pumpkin_> we just tell them to sync up the flags from the u64q to u32q
02:41:23 <quicksilver> IminYourMonad: you call the library/object file directly.
02:41:25 <Zao> IminYourMonad: You link it into your binary.
02:41:40 <quicksilver> pumpkin_: -N4 is no better than -N3 for me, btw
02:41:45 <quicksilver> 2-core machine, ghc 6.8
02:41:47 <pumpkin_> ah.
02:41:51 <pumpkin_> I'm on a quad-core 6.10
02:41:51 <quicksilver> it's not a completely idle machine though
02:42:01 <quicksilver> and I can't be bothered to quit everything.
02:42:28 <quicksilver> pumpkin_: try -fasm instead of -fvia-C?
02:42:42 <pumpkin_> I just used the flags they tell me to in the comments
02:43:06 <quicksilver> change the OPTIONS line to use asm
02:43:11 <quicksilver> I'm curioius if it's faster than via-C
02:44:16 <quicksilver> for me it's quite a bit worse.
02:44:21 <PHO_> Is -fvia-C still faster than -fasm?
02:44:25 <quicksilver> biut 6.10 has a better native backend.
02:44:27 <Axman6> depends
02:44:28 <quicksilver> PHO_: normally, no.
02:44:40 <Axman6> sometimes it is, sometimes it isn't
02:44:40 <quicksilver> PHO_: for floating point code on x86 (32 bit) perhaps it is.
02:44:48 <PHO_> heh
02:44:58 <dolio> Other than the floating point there isn't a lot of difference.
02:45:50 <pumpkin_> seems significantly slower
02:45:54 <quicksilver> what's the "-march=" value for core2 ?
02:45:55 <pumpkin_> still waiting for it to finish
02:46:09 <pumpkin_> real	0m51.667s
02:46:09 <pumpkin_> user	3m11.331s
02:46:09 <pumpkin_>  for -fasm
02:46:17 <pumpkin_> real	0m17.368s
02:46:17 <pumpkin_> user	1m3.696s
02:46:17 <pumpkin_> for -fvia-C
02:46:21 * quicksilver nods
02:46:25 <quicksilver> OK the FP code is the key.
02:46:55 <quicksilver> so the key question is just if gcc's auto-vectoriser is good enoguh to detect the possibility of vectorising complex multiplication + addition.
02:46:59 <quicksilver> and the answer is "no"
02:47:08 <quicksilver> that's why the GCC version cheats with SSE2 builtins ;)
02:47:34 <Axman6> pumpkin_: what program?
02:47:40 <pumpkin_> mandel
02:50:00 <quicksilver> odd. There is a "-march=core2" but the GCC with macos doesn't ahve it.
02:50:13 <ivanm> quicksilver: it's only since 4.3 IIRC
02:50:34 <quicksilver> pumpkin_: well, I'm pretty sure the key problem is that the GCC code is generating SSE2 and the GHC code isn't. Although there also seems like there might be a slight parallelism failing.
02:52:11 <pumpkin_> yeah
02:52:40 <pumpkin_> well, the key problem in u32q is just that we aren't running with -threaded and +RTS -N6
02:52:50 * quicksilver nods
02:52:53 <pumpkin_> if we had that, we'd at least be in the ~2x range like we are on u64q
02:53:01 <pumpkin_> well
02:53:04 <pumpkin_> ~3x :P
02:54:27 <quicksilver> slower than what?
02:54:32 <quicksilver> damn
02:54:37 <quicksilver> scrolled up, sorry.
02:54:41 <ivanm> lol
02:54:45 <pumpkin_> :)
02:55:28 <boegel> it's getting more and more likely we'll manage to get a Ms student interested in doing a deep analysis of the Shooutout
02:55:34 <boegel> I'll make sure he includes Haskell :)
02:55:54 <quicksilver> pumpkin_: -march=pentium4 improves things 25% for me, nearly.
02:56:06 <quicksilver> and parallelism is nearly perfect now.
02:56:30 <quicksilver> brings me down to only 2.5x the gcc speed
02:56:32 <pumpkin_> I was trying -march=nocona
02:56:37 <pumpkin_> didn't seem to make any difference
02:56:49 <pumpkin_> pentium4 doesn't either :(
02:56:57 <pumpkin_> maybe it's my crappy apple gcc :)
02:57:26 <quicksilver> interestingly with -march=pentium4, +RTS -N4 is much better than +RTS -N3
02:57:39 <quicksilver> woudl be a good application of dons' compilation options training stuff
02:57:52 <pumpkin_> yeah :)
02:58:04 <quicksilver> or, maybe it's not that interesting. I'm getting seriously inconsistent runtimes
02:58:08 <quicksilver> probably other stuff on my machine.
02:58:43 <boegel> you guys should make sure to be rigorous about your evaluation, otherwise you'll keep running in circles :)
02:58:58 <quicksilver> 10s difference between runtimes with same options.
02:59:00 <boegel> quicksilver: btw, dons didn't invent the use of GA to tune apps
02:59:11 <boegel> quicksilver: neither did I, but I did some work on it :)
02:59:21 <quicksilver> boegel: I know he didn't.
02:59:25 <boegel> quicksilver: out of how many in total?
02:59:29 <boegel> quicksilver: just kidding ;-)
02:59:33 <quicksilver> he references multiple sources ;)
02:59:39 <quicksilver> boegel: 10s out of 45s.
03:00:34 <PHO_> quicksilver: you should reboot your computer with single-user mode, and run the test :)
03:00:57 <quicksilver> PHO_: alternatively, I should go do some real work for which I get paid :)
03:01:07 <PHO_> haha
03:02:01 <PHO_> quicksilver: that should be "virtual work"
03:02:04 <ivanm> quicksilver: work? what's that?
03:02:24 <IminYourMonad> how do I do the eq of this regex in parsec? [a-zA-Z0-9]*\(
03:03:01 <pumpkin_> wow, 6 am, I should go to sleep
03:03:16 <boegel> quicksilver: that _a lot_
03:03:26 <MyCatVerbs> IminYourMonad: many (anyOf (['a'..'z']++['A'..'Z']++['0'..'9'])) >> char '('
03:03:34 <boegel> pumpkin_: lol
03:03:55 <boegel> PHO_: or use some proper statistics :)
03:04:13 <MyCatVerbs> IminYourMonad: or alternatively, (many alphaNum >> char '(')
03:04:25 <Fredrik> @pl \g s ->  case elemIndex ' ' s of Just i -> drop (i+1) s
03:04:26 <lambdabot> (line 1, column 41):
03:04:26 <lambdabot> unexpected ">" or "-"
03:04:26 <lambdabot> expecting variable, "(", operator or end of input
03:04:40 <Fredrik> @pl \g s -> (case elemIndex ' ' s of Just i -> drop (i+1) s)
03:04:41 <lambdabot> (line 1, column 41):
03:04:41 <lambdabot> unexpected ">"
03:04:41 <lambdabot> expecting variable, "(", operator or ")"
03:05:03 <Fredrik> @pl \s -> (case elemIndex ' ' s of Just i -> drop (i+1) s)
03:05:03 <lambdabot> (line 1, column 39):
03:05:03 <lambdabot> unexpected ">"
03:05:03 <lambdabot> expecting variable, "(", operator or ")"
03:05:29 <PHO_> @pl \ a -> a
03:05:29 <lambdabot> id
03:05:33 <PHO_> hmm?
03:05:36 <ivanm> Fredrik: wrap "Just i" in quotes
03:05:44 <ivanm> PHO_: why so suprised?
03:05:54 <Fredrik> @pl \s -> (case elemIndex ' ' s of 'Just i' -> drop (i+1) s)
03:05:54 <lambdabot> (line 1, column 32):
03:05:54 <lambdabot> unexpected "u"
03:05:54 <lambdabot> expecting variable, "(", operator or ")"
03:06:01 <Fredrik> @pl \s -> (case elemIndex ' ' s of "Just i" -> drop (i+1) s)
03:06:02 <lambdabot> (line 1, column 41):
03:06:02 <lambdabot> unexpected ">"
03:06:02 <lambdabot> expecting variable, "(", operator or ")"
03:06:06 <ivanm> Fredrik: ummm.... I meant brackets :s
03:06:07 <PHO_> ah, ok. I see what was wrong
03:06:07 <ivanm> sorry
03:06:13 <Fredrik> @pl \s -> (case elemIndex ' ' s of (Just i) -> drop (i+1) s)
03:06:14 <lambdabot> (line 1, column 41):
03:06:14 <lambdabot> unexpected ">"
03:06:14 <lambdabot> expecting variable, "(", operator or ")"
03:06:32 <ivanm> though I'm not sure if you can do a case statement in a one-liner like that :s
03:06:55 <IminYourMonad> where is anyOf? doesnt exist in parsec it seems
03:07:06 <PHO_> @pl \ a -> case a of _ -> undefined
03:07:06 <lambdabot> (line 1, column 18):
03:07:06 <lambdabot> unexpected "_"
03:07:06 <lambdabot> expecting variable, "(", operator or end of input
03:07:17 <PHO_> @pl \ a -> (case a of _ -> undefined)
03:07:17 <lambdabot> (line 1, column 19):
03:07:17 <lambdabot> unexpected "_"
03:07:17 <lambdabot> expecting variable, "(", operator or ")"
03:07:23 <ivanm> @hoogle anyof
03:07:23 <lambdabot> No results found
03:07:35 <ivanm> IminYourMonad: it should be... try using hayoo to find it
03:07:44 <PHO_> @hoogle anyOf
03:07:44 <lambdabot> No results found
03:07:51 <PHO_> @hoogle oneOf
03:07:51 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:07:51 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:07:51 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
03:08:04 <boegel> @hoogle any
03:08:04 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
03:08:04 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
03:08:04 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
03:09:22 <IminYourMonad> fact = (P.many P.alphaNum) >> P.char '(' works
03:09:56 <ski> (IminYourMonad : what are you parsing ?)
03:10:07 <IminYourMonad> for something like Prolog where the user adds clauses I must have some global state to keep track of facts right?
03:10:16 <IminYourMonad> IORef?
03:10:24 <IminYourMonad> im writing a parser for prolog-core
03:10:54 <ski> probably you want to insist on a (lower case) alphabetic character, in front of the `P.many P.alphaNum'
03:11:30 <MyCatVerbs> IminYourMonad: depends. Does your Prolog evaluator need to do IO?
03:11:56 <IminYourMonad> well it is an interpreter, not a compiler
03:12:01 <IminYourMonad> or will be insce i havent done much yet
03:12:03 <ski> IminYourMonad : one solution for the parsing is to have two lexical tokens for `(', one for when it's immediately preceded by an atom token, and one when it's not
03:12:21 <quicksilver> ivanm: you can certainly use a case statement in a one liner.
03:12:47 <quicksilver> but I don't think @pl knows it.
03:13:35 <HugoDaniel> my haskell code wasn't working, so i just inserted a few putStrLn's to quickly debug it, and now it works
03:13:35 <ahamay42> Hi, can someone explain me the meaning of this line?
03:13:35 <ahamay42> class (Monad m) => MyClass f m | m -> f where ..
03:13:35 <ahamay42> I just don't understand what | does in a class declaration...
03:13:46 <HugoDaniel> ...now im afraid to remove those putStrLn's :P
03:13:57 <boegel> HugoDaniel: :)
03:14:02 <MyCatVerbs> ahamay42: it's a functional dependency. It says that m completely determines f.
03:14:10 <boegel> HugoDaniel: remove them one by one, see what happens
03:14:20 <boegel> HugoDaniel: also, define "wasn't working"
03:14:24 <boegel> HugoDaniel: did it compile?
03:14:30 <ski> ahamay42 : the `m -> f' means that there can't be two instances `MyClass m f0' and `MyClass m f1', where `f0' and `f1' is different
03:14:43 <ahamay42> ah okay, thanks
03:14:49 <HugoDaniel> boegel: it compiled, but when i run it, an exception would blow the whole thing away (and im not throwing exceptions)
03:14:49 <ski> ahamay42 : so for each `m', there is at most one `f' such that `MyClass m f'
03:14:58 <ahamay42> all right
03:15:04 <MyCatVerbs> ahamay42: short version: it means that it's illegal to define two different instances of MyClass with different f but same m. This means the type checker can work out what f is just from knowing what m is.
03:15:16 <HugoDaniel> ghci would print this: *** Exception: (unknown)
03:15:41 <ahamay42> thank you both
03:16:29 <PHO_> I saw a horrible situation where putStrLn causes unsafePerformIO somehow, and makes a buggy program run as if it's sane
03:16:42 <HugoDaniel> but i guess it probably has to do with the database im using, and a few selects that get done when they shouldn't so that after two runs it works good :P
03:16:53 <boegel> HugoDaniel: seems weild
03:17:09 <boegel> HugoDaniel: heh
03:17:50 <HugoDaniel> ah, now i know what it was :P
03:17:51 <ski> heisenbugs, yay !
03:18:34 <HugoDaniel> i was inserting a date prior to the current date on the database and i threw an exception :P because my web bots test data was from yesterday
03:18:52 <HugoDaniel> :/
03:18:59 <HugoDaniel> my problem... as usual
03:19:25 <Axman6> PHO_: eh?
03:19:26 <PHO_> When I learned Haskell I thought like "Yay! Now I can live without heisenbugs"... until I began to use unsafe prims.
03:19:44 <Axman6> don't use unsafe prims :\
03:19:56 <quicksilver> PHO_: e.g. the ones misguidedly included in the standard library with innocent sounding names like 'getContents'.
03:19:57 <MyCatVerbs> PHO_: nobody is forcing you to use unsafe prims, silly.
03:20:09 <Axman6> they're mainly there for FFI code, and should only ever be used if you know what you're doing
03:20:17 <MyCatVerbs> quicksilver: oh aye that. Eep.
03:20:29 <HugoDaniel> what are unsafe prims ?
03:20:30 <HugoDaniel> :P
03:20:55 <IminYourMonad> how do I make a Parsec expression return a specific char? or do I need to regex-match against the Right token part?
03:21:22 <Axman6> HugoDaniel: things like unsafePerformIO
03:21:28 <HugoDaniel> ah ok
03:21:44 <MyCatVerbs> HugoDaniel: GHC primitives. The stuff that the nice bits of Haskell are implemented in terms of.
03:22:35 <MyCatVerbs> IminYourMonad: what are you trying to do? Also, pattern matching against a data constructor has nothing to do with regular expressions.
03:23:23 <ski> unsafe primes are primes `p' such that `2^p - 1' is not a prime
03:23:51 <PHO_> lol
03:24:05 <MyCatVerbs> IminYourMonad: if you want to make use of that character further along inside the parser, then get the return value with the <- operator. If you want to run a parser completely and then get its output, you need to use parse and match against Right (...).
03:24:16 <HugoDaniel> i like how haskell feels fast even though i use lots of bad coding patterns, like runing through a whole list 3 or 4 times when 1 should have been necessary, or rebuilding entire data structures when its not necessary :P
03:24:19 <ski> (the least unsafe prime is eleven)
03:24:21 <MyCatVerbs> (Or >>=, but I assume that you're using do notation. I hope.)
03:24:47 <HugoDaniel> i get getting this feeling of "thats what functional programming is all about"
03:30:49 <IminYourMonad> a parser that matches several tokens in a row, does it only return the last one?
03:31:30 * boegel disappears
03:31:43 <ski> IminYourMonad : you can return whatever you want
03:31:52 <ski>   do x <- token0
03:31:56 <ski>      y <- token1
03:32:00 <ski>      z <- token2
03:32:04 <ski>      return (x,y,z)
03:32:19 <ski> will return a triple of the previously read tokens
03:32:48 <ski> token2  might be  P.char '('  e.g.
03:33:00 <ski> if you only write
03:33:03 <ski>   do token0
03:33:06 <ski>      token1
03:33:07 <ski>      token2
03:33:21 <ski> then yes, you will only get the result of `token2'
03:41:21 <IminYourMonad> HugoDaniel: functional programming is about modularizing your code as much as you can and in several different ways. separate strustures from the functions operating on them, separating sideefectful code from pure code etc.
03:41:21 <IminYourMonad> if your programs use unnesseary amounts oflooping you a reprobably still coding imeratively
03:44:30 <aleator> How do I resolve Could not find module `Data.Generics.Aliases': it is a member of package base-3.0.3.0, which is hidden
03:44:34 <aleator> error?
03:44:43 <aleator> in a cabal package that is.
03:44:46 <dancor> i.e. one of the possibly more suprising things you can abstract in haskell is looping and control flow itself
03:45:13 <dcoutts> aleator: build the package against base 3 or add a dependency on syb
03:45:46 <dcoutts> aleator: or use cabal-install which will do the first
03:46:05 <dcoutts> aleator: you're looking at a package that has not been updated for ghc-6.10
03:46:13 <aleator> dcoutts: I'm trying to make my own package. But yes. I forgot syb.
03:47:11 <aleator> Is there an easy way to find out from which package each module comes from?
03:47:18 <mmorrow> hehe
03:47:20 <mmorrow> , [$bf|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
03:47:22 <lunabot>  "Hello World!\n"
03:47:28 <mmorrow> , [$bf2|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
03:47:30 <lunabot>  ("Hello World!\n",(4,Mem (fromList [(0,0),(1,87),(2,100),(3,33),(4,10)])))
03:48:01 <mmorrow> , [$ty| [$bf|.\|] |]
03:48:05 <lunabot>  String -> String
03:50:19 <aleator> What is the policy of hackage? Is it "upload everything" or "upload only polished stuff"?
03:50:56 <mmorrow> aleator: upload stuff you think would be useful
03:52:40 <aleator> mmorrow: How easy is it to update/remove stuff in there?
03:53:14 <mmorrow> aleator: a (hackish, but direct and the only i can think off off the top of my head) way to find out the package a module's from, would be to grep "$ ghc-pkg dump" in some appropriate way
03:53:46 * Saizan builds haskell code using ~187% CPU
03:53:52 <Saizan> i wish i had more cores
03:54:01 <mmorrow> aleator: as long as you don't want to change a package's name, it's easy (==> to add new pkgs and to update existing pkgs you own)
03:54:16 <Saizan> and that ghc hadn't a so high startup overhead
03:54:27 <aleator> mmorrow: and removing?
03:54:51 <mmorrow> aleator: i don't know if that's directly supported (but i'm sure someone would do it for you)
03:55:08 <Japsu> :t fmap fmap fmap
03:55:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
03:56:24 <mmorrow> , [$bf|.+[.+]|] ""
03:56:26 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
03:56:43 <mmorrow> , ['\0'..]
03:56:45 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
03:57:09 <Japsu> :t ap ap ap
03:57:11 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
03:57:11 <lambdabot>     Probable cause: `ap' is applied to too few arguments
03:57:11 <lambdabot>     In the second argument of `ap', namely `ap'
03:58:07 <Axman6> :t fmap `ap` fmap
03:58:09 <lambdabot> forall b (f :: * -> *). (Functor f) => (f b -> b) -> f (f b) -> b
03:58:23 <Axman6> ouch
03:58:45 <Axman6> > fmap `ap` fmap head [[1,2,3]]
03:58:46 <lambdabot>   Couldn't match expected type `(a -> b) -> [f a]'
03:59:49 <Axman6> > (fmap `ap` fmap) head [[1,2,3]]
03:59:51 <lambdabot>   1
03:59:55 <Axman6> > (fmap `ap` fmap) head [[1]]
03:59:57 <lambdabot>   1
03:59:59 <Axman6> > (fmap `ap` fmap) head [[]]
04:00:01 <lambdabot>   * Exception: Prelude.head: empty list
04:00:05 <Axman6> > (fmap `ap` fmap) head [[],[1]]
04:00:07 <lambdabot>   * Exception: Prelude.head: empty list
04:01:13 <elbar> brainfuck works now?
04:01:36 <Saizan> mmorrow's one
04:02:45 <elbar> , [$bf|++[-]|] ""
04:02:47 <lunabot>  ""
04:03:03 <kiris> Velociraptors: clever girl
04:03:16 <elbar> , [$bf|++[-]|] "x"
04:03:18 <lunabot>  ""
04:03:44 <mmorrow> , [$bf|,|]
04:03:46 <lunabot>  luna: No instance for (GHC.Show.Show
04:03:46 <mmorrow> , [$bf|,|] ""
04:03:48 <lunabot>  "*** Exception: bf blocked on input"
04:04:05 <mmorrow> , [$bf|,.|] "8"
04:04:07 <lunabot>  "8"
04:04:35 <mmorrow> `bf' splice to a :: (String -> String)
04:04:38 <Botje> @tell wli did you get your parser to work?
04:04:39 <lambdabot> Consider it noted.
04:04:39 <elbar> argument is for setting registers or only for input?
04:04:41 <Axman6> , [$bf|,+.|] "3"
04:04:43 <lunabot>  "4"
04:04:52 <Axman6> , [$bf|,[+.]|] "3"
04:04:53 <elbar> answerd =)
04:04:54 <lunabot>  "456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz...
04:04:56 <mmorrow> and if it ever needs input and doesn't have any left, it says "*** Exception: bf ..."
04:05:16 <mmorrow> elbar: yeah, i should have something to set regs
04:05:29 <mmorrow> it's super annoying to have to do it manually
04:05:33 <ManateeLazyCat> Looks GNU Emacs 23.0.91.1 is stable enough now.
04:05:37 * mmorrow was just messing around in a /msg
04:05:47 <ManateeLazyCat> sorry
04:05:48 <mmorrow> also, there's `bf2'
04:05:50 <ManateeLazyCat> wrong channel
04:05:59 <mmorrow> , [$bf2|,.|] "8"
04:06:00 <lunabot>  ("8",(0,Mem (fromList [(0,56)])))
04:06:03 <HugoDaniel> how do i know if a given string is a number ?
04:06:14 <daf> HugoDaniel: it's not, it's a string!
04:06:16 <mmorrow> , all isDigit "023432"
04:06:18 <lunabot>  True
04:06:22 <Axman6> , [$bf2|,[+.]|] "3"
04:06:25 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:06:29 <HugoDaniel> mmorrow: how about "123.23" ? :P
04:06:49 <mmorrow> , all (\c -> isDigit c || c == '.') "023432"
04:06:51 <lunabot>  True
04:06:52 <mmorrow> , all (\c -> isDigit c || c == '.') "0234.32"
04:06:53 <lunabot>  True
04:06:58 <HugoDaniel> eh
04:07:01 <HugoDaniel> ok
04:07:05 <mmorrow> HugoDaniel: for anything more, you'll have to write a parser
04:07:10 <mmorrow> well, actually not
04:07:13 <daf> , all (\c -> isDigit c || c == '.') "0234.32.23234"
04:07:15 <lunabot>  True
04:07:22 <mmorrow> , reads "42345.5432" :: [(Double, String)]
04:07:24 <lunabot>  [(42345.5432,"")]
04:07:28 <mmorrow> , reads "423.45.5432" :: [(Double, String)]
04:07:28 <daf> rads is probably what you want
04:07:30 <lunabot>  [(423.45,".5432")]
04:07:31 <daf> * reads
04:07:34 <mmorrow> , reads ".423.45.5432" :: [(Double, String)]
04:07:35 <lunabot>  []
04:07:38 <kiris> maybe False (const True) . listToMaybe $ (reads "123" :: [(Int,String)])
04:07:43 <sioraiocht> dcoutts: ping?
04:07:50 <kiris> > maybe False (const True) . listToMaybe $ (reads "123.3" :: [(Double,String)])
04:07:52 <lambdabot>   True
04:07:58 <HugoDaniel> :t reads
04:07:59 <lambdabot> forall a. (Read a) => String -> [(a, String)]
04:08:05 <quicksilver> kiris: you also want to check that the returned string is ""
04:08:08 <quicksilver> probably.
04:08:21 <quicksilver> assuming you're trying to check the whole string and not just a prefix of it
04:08:33 <HugoDaniel> , reads "123"
04:08:34 <lunabot>  []
04:08:43 <HugoDaniel> , reads "123" :: [(Double, String)]
04:08:45 <lunabot>  [(123.0,"")]
04:08:45 <mmorrow> you need to tell it what type
04:08:55 <mmorrow> , reads "123" :: [(Int, String)]
04:08:56 <lunabot>  [(123,"")]
04:09:00 <mmorrow> , reads "123" :: [(Float, String)]
04:09:00 <elbar> , [$bf2|++|] ""
04:09:01 <lunabot>  [(123.0,"")]
04:09:02 <lunabot>  ("",(0,Mem (fromList [(0,2)])))
04:09:19 <HugoDaniel> okey, let me try it on the code
04:09:20 <HugoDaniel> thanks
04:09:23 <mmorrow> np
04:09:25 <quicksilver> , let maybeRead s = case reads s of [(x,"")] -> Just x ; _ -> Nothing in maybeRead "1.234x" :: Maybe Double
04:09:27 <lunabot>  Nothing
04:09:32 <quicksilver> , let maybeRead s = case reads s of [(x,"")] -> Just x ; _ -> Nothing in maybeRead "1.234" :: Maybe Double
04:09:34 <lunabot>  Just 1.234
04:09:39 <quicksilver> that version checks for trailing junk
04:09:43 <quicksilver> depends what you want.
04:10:01 <elbar> , [$bf2|++>+|] ""
04:10:03 <lunabot>  ("",(1,Mem (fromList [(0,2),(1,1)])))
04:10:18 * mmorrow is suddenly motivated to learn some bf one-liners
04:10:24 <elbar> =)
04:10:24 <kiris> > not . null . fmap (null . snd) $ (reads "123.3" :: [(Double,String)])
04:10:26 <lambdabot>   True
04:10:35 <kiris> uh
04:10:38 <mmorrow> , [$bf|.+[.+]|] ""
04:10:40 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
04:11:05 <quicksilver> kiris: and that version permits multiple (ambiguous) parses. Not that any of the built in read instances ever use ambiguous parses.
04:11:14 <kiris> > fromMaybe False . listToMaybe . fmap (null . snd) $ (reads "123.3" :: [(Double,String)])
04:11:16 <lambdabot>   True
04:11:17 <kiris> > fromMaybe False . listToMaybe . fmap (null . snd) $ (reads "123.3g" :: [(Double,String)])
04:11:18 <lambdabot>   False
04:11:19 <ski> (mmorrow : pickup lines ?)
04:11:19 <kiris> there we go
04:11:35 <elbar> , [$bf|[.+]|] ""
04:11:36 <lunabot>  ""
04:11:38 <mmorrow> bf with a few extensions would be so much more useable.. like for one, allowing literal numbers, say surrounded by parens, which would mean to store that num at the current position
04:12:03 <dcoutts> sioraiocht: I'm just going into the lab, will be there soon
04:12:07 <sioraiocht> kk
04:12:08 <mmorrow> ski: pickup?
04:12:18 <ski> mmorrow : "bf one-liners"
04:12:22 <mmorrow> ski: ah, hehe
04:12:44 <elbar> i doubt that bf is about usabillity =)
04:13:13 <kiris> "if we could just add an FFI to LOLCODE..."
04:13:14 <mmorrow> but what if it could be? ;)
04:13:20 * ski tries to imagine someone saying `.+[.+]' at a bar ..
04:13:42 <mmorrow> ski: i wonder what it'd sound like
04:13:52 <mmorrow> probably the drunker the person saying it, the better
04:14:19 <ski> (mmorrow : possibly similar to the languages in kalahari with lots of click-sounds ..)
04:14:24 <mmorrow> lol
04:14:59 * kiris doesn't make a trepanning joke
04:15:02 <mmorrow> kiris: lolcode ffi FTW
04:15:41 <mmorrow> CAN HAS <SETJMP.H>?
04:15:45 <mmorrow> KTHX
04:16:15 <mmorrow> SETJMP; VISIBLE "IM OUTTA YER LOOP NOW"
04:16:23 <elbar> CAN HAS STDIO? ;)
04:16:36 <mmorrow> but now we have a lolcode ffi!
04:16:54 <mmorrow> err, i meant s/SETJMP/LONGJMP/
04:17:23 <mmorrow> elbar: oh, yeah true
04:17:53 <blathijs> Hmm, why is there a Control.Monad.State in the mtl library that comes with gch, and a separate Control.Monad.Trans.State in the containers library on hackage?
04:17:57 <kiris> SAYING WORDS "wat"
04:17:57 <kiris> OM NOM NOM
04:18:05 <mmorrow> heh
04:18:11 <blathijs> The interfaces look terribly alike, but they're different types...
04:18:33 <mmorrow> blathijs: in containers?!
04:18:43 <elbar> mmorrow: why does [.+] not produce the same output as your .+[.+] ?
04:19:00 <elbar> of i c
04:19:07 <mmorrow> elbar: because "[]" breaks on 0
04:19:14 <blathijs> mmorrow: Sorry, transformers
04:19:17 <blathijs> It's still early :-)
04:19:23 <mmorrow> and tests for 0 before (is this correct?)
04:19:27 <elbar> yeah...i thought the ] has the test but its done on [
04:19:35 <mmorrow> ah, ok cool
04:20:21 <quicksilver> blathijs: I believe "transformers" is an attempt to produce a haskell98-compatible library with an mtl-compatible interface.
04:20:23 <kiris> ah, State in the `transformers' package is a StateT transformer of Identity
04:21:37 <elbar> , [$bf|>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
04:21:38 <lunabot>  luna: lexical error in string/character literal at end of input
04:21:45 <elbar> oops
04:22:02 <elbar> , [$bf|>+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.|] ""
04:22:04 <lunabot>  "Hello world!\n"
04:22:08 <elbar> yay
04:22:34 <elbar> such an afford for something that simple =)
04:22:44 <mmorrow> hehe
04:22:57 <kiris> ‚òê The checkbox unicode character is rubbish.
04:22:57 <kiris> ‚òë The checkbox unicode character is awesome.
04:23:20 <mmorrow> kiris: that pretty much sums it up
04:23:23 <blathijs> kiris: Yeah, I saw that, which makes sense. I'm using the data-accessors package, which can use the StateT type to access parts of state, but that breaks since I'm currently using the mtl State type
04:23:47 <blathijs> I'm trying to use the transformer's State type now, to see where that leads me
04:24:08 <quicksilver> data-accessors is broken for using StateT directly, if that is indeed what it does.
04:24:30 <blathijs> I think it does. What should it do then?
04:24:50 <blathijs> It makes sense to use StateT AFAICS, so it works with StateT and State?
04:24:57 <blathijs> quicksilver: What should it use then?
04:25:11 <blathijs> From the docs: getA :: Monad m => Accessor r a -> StateT r m a
04:27:20 <ski> @type `get'
04:27:21 <lambdabot> parse error on input ``'
04:27:24 <ski> @type get
04:27:25 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
04:27:45 <ski> blathijs : is there an `askA' and a `localA' in there ?
04:28:04 <quicksilver> blathijs: if it uses StateT it will not work with State.
04:28:10 <quicksilver> (that's why it's a bad idea)
04:28:15 <blathijs> ski: Nope, putA, getA and modA
04:28:26 <blathijs> quicksilver: It actually seems to work fine with State here
04:28:33 <ski> blathijs : so no operators for `MonadReader', then ?
04:28:42 <blathijs> ski: Nope
04:28:48 <ski> sad
04:28:50 <blathijs> ski: http://hackage.haskell.org/packages/archive/data-accessor/0.2.0.2/doc/html/Data-Accessor.html
04:30:01 <blathijs> quicksilver: Though things still might blow up in my face, I have one file that now uses State and the data-accessor operations that use StateT compiling
04:30:13 <quicksilver> blathijs: only because "type State s = StateT s Identity"
04:30:14 <blathijs> The file that uses these functions is still broken (due to other reasons)
04:30:24 <blathijs> quicksilver: Yes, so that's fine, right?
04:30:25 <quicksilver> the transformers library make its visible that State is a StateT.
04:30:34 <quicksilver> the mtl definition is not like that.
04:30:40 <quicksilver> well, that's a library design question I guess?
04:30:46 <benmachine> `/t
04:30:50 <benmachine> oops
04:30:55 <quicksilver> is it an abstraction leak to expose the fact that State is just StateT Identiy
04:31:05 <quicksilver> yes, it is, but is it an important one? I don't know.
04:31:18 <blathijs> Sounds like an advantage of the transformers library to me?
04:31:42 <blathijs> For the mtl definition, can you define the getA/putA operations like this?
04:32:04 <blathijs> Or should you create a subclass of the MonadState class then?
04:32:33 <quicksilver> getA :: MonadState r m => Accessor r a -> m a
04:32:39 <quicksilver> no subclass needed.
04:33:10 <ski> askA :: MonadReader r m => Accessor r a -> m a
04:33:25 <mmorrow> , [$bf|,>++++++[<-------->-],[<+>-]<.|] "43"
04:33:27 <lunabot>  "7"
04:33:29 <quicksilver> indeed.
04:33:49 <ski>   localA :: MonadReader r m => Accessor r a -> ..  -- ?
04:34:16 <quicksilver> could be done, yes, since Accessors do have a setter.
04:34:19 <quicksilver> not sure if it's useful.
04:34:55 <blathijs> quicksilver: Ah, yes of course
04:35:20 <ski> if could be useful, if you're carrying an environment of variable bindings around, together with other configuration info ..
04:35:24 <ski> s/if/it/
04:37:07 <blathijs> Hmm, this MonadReader does sound rather useful. *puts that on the list of things to use in the future*
04:38:06 <ski> use environment (/reader) when you want to pass down information, and perhaps locally change some of it in a sub-context
04:38:32 <ski> use state when you want local changes to survive the computation, and be passed into the "next" one
04:39:39 <ski> (and use output/writer when you want to collect some output .. like summing, or a list of output things, et.c.)
04:40:14 <ski> (also .. use continuations when you want to do crazy control flow :)
04:48:37 <temoto-wd> Hello. What's wrong with:       main = do \n\t map olala [1..]   \n  olala x = do \n\t putStrLn $ show x
04:48:44 <temoto-wd> I'm trying to print infinite list to stdout.
04:48:51 <HugoDaniel> is there any way to do some kind of dirty macros in haskell, so that certain instructions are only executed when im debugging my code ?
04:48:56 <temoto-wd> Preferrably random numbers but that doesn't matter at the point.
04:49:02 <MyCatVerbs> temoto-wd: that's kinda hard to read. Easier to use { ; } when typing inline.
04:49:19 <temoto-wd> MyCatVerbs: i'm sorry fixing now
04:49:34 <temoto-wd> Hello. What's wrong with:       main = do { map olala [1..] }   ;  olala x = do { putStrLn $ show x }
04:49:37 <MyCatVerbs> temoto-wd: so, main = do { map olala [1..] } ; olala x = do { putStrLn $ show x }
04:49:46 <mmorrow> , foldl (\a b -> [$bf|,>++++++[<-------->-],[<+>-]<.|] (a++b)) "\0" ["1","9","a"]
04:49:48 <lunabot>  ";"
04:49:53 <MyCatVerbs> temoto-wd: you want mapM_, rather than just map.
04:50:09 <temoto-wd> aha! i knew it had to do with lifting, right?
04:50:18 <MyCatVerbs> temoto-wd: yes. The expression "map olala [1..]" has type [IO ()].
04:50:31 <temoto-wd> Like liftM map ... ?
04:50:50 <temoto-wd> :? mapM_
04:50:53 <MyCatVerbs> It's a list of IO actions. In order to run them, you have to (>>) through them all.
04:51:17 <temoto-wd> :info mapM_
04:51:40 <temoto-wd> How to get some description?
04:51:41 <MyCatVerbs> So, foldr (>>) (return ()). There's a shorthand for that in Control.Monad, called "sequence_". And there's a shorthand for (sequence . map) in Control.Monad called "mapM_".
04:51:48 <MyCatVerbs> :t mapM_
04:51:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:52:00 <MyCatVerbs> :t sequence_
04:52:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:52:07 <temoto-wd> No, human oriented description :)
04:52:09 <MyCatVerbs> :t foldr (>>) (return ())
04:52:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:52:11 <benmachine> :t sequence
04:52:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:52:39 <wli> Throwing in ErrorT and ContT atop MonadRWS could be a vaguely interesting exercise.
04:52:40 <lambdabot> wli: You have 3 new messages. '/msg lambdabot @messages' to read them.
04:52:41 <MyCatVerbs> temoto-wd: hit the Haddock docs. http://www.haskell.org/ghc/docs/latest/html/libraries/
04:53:43 <MyCatVerbs> temoto-wd: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3AmapM_ for example. Replace "latest" in that URL with whatever the oldest version of GHC that you need to target is. (e.g. I use http://www.haskell.org/ghc/docs/6.6.1/html/libraries/ because my university is, uh, conservative about upgrading software, sometimes).
04:53:44 <dcoutts_> sioraiocht: ping
04:53:50 <temoto-wd> MyCatVerbs: thank you very much.
04:54:47 <MyCatVerbs> temoto-wd: no problem. And if the description in the Haddock documentation doesn't make sense to you, well, ask here and people will (hopefully) at the very least be able to tell you what else you need to read in order to understand what's going on. (Though in practice they'll usually just explain it since that's often quicker. ^^)
04:55:23 <wli> There are a lot of cases where I've used ErrorT to do what I should've used ContT for.
04:55:30 <temoto-wd> ohmy... haskell performed 5 times better than python
04:55:45 <temoto-wd> i didn't use random numbers in haskell though
04:55:57 <wli> Basically I always returned the result via throwError and looped until throwError occurred.
04:56:13 <osfameron> can I use GADTs to get around the special case helper function right' here? : http://github.com/osfameron/misc-opensource/blob/bf54cd635d44d506a3166ef7d482f1b152a860fc/scratch/haskell/grid.hs
04:56:22 <maltem> temoto-wd: well, ghc is a compiler, python is usually (always?) just interpreted
04:56:58 <temoto-wd> I could use ghci, right?
04:57:36 <Cthulhon|> Python caches bytecode.
04:58:44 <temoto-wd> Is haskell right platform for building something like memcached, but holding list of sets of int/string/datetime and quering it?
04:58:46 <MyCatVerbs> Compilation to bytecode doesn't cost and interesting quantity of time. Python has an alarmingly fast parser.
04:59:37 <maltem> Cthulhon|: ah good to know
04:59:39 <wli> Parsing is usually an alarmingly slow component of code processing.
04:59:42 <temoto-wd> I'm inspired of In-memory data grid idea. I'm all realize how it can be done in python but i want more performance. MORE!
04:59:54 <daf> initialising lots of modules often does make Python startup comparatively slow though
05:00:05 <MyCatVerbs> temoto-wd: depends on the size of the dataset. If you're planning to seriously load that, then I'd say no. Haskell is not particularly good at being thrifty with memory.
05:00:41 <temoto-wd> MyCatVerbs: it is planned to hold like hundreds of megabytes.
05:00:47 <MyCatVerbs> temoto-wd: things like memcached are places where it's actually (IMO) entirely reasonable to do manual memory management and all the attendant pain, because the entire application revolves around making efficient use of RAM. :)
05:00:49 <quicksilver> osfameron: I'm not quite sure what you think is wrong with "right'"
05:01:11 <quicksilver> osfameron: but, did you consider removing the Nil case from Cell and using Maybe Cell?
05:01:18 <RayNbow> @hoogle newU
05:01:18 <lambdabot> Data.Unique newUnique :: IO Unique
05:01:28 <quicksilver> osfameron: then "right'" is just "fmap right"
05:01:43 <temoto-wd> MyCatVerbs: Yes but i'm afraid of memory management at all, and i don't believe i can do it better than haskell compiler.
05:01:45 <wli> I know iteration to convergence via ErrorT; maybe I should try it with ContT.
05:01:58 <MyCatVerbs> temoto-wd: not so much the absolute quantity of data, but how large the data set is relative to the quantity of RAM you have available. Caching 200 megs on a machine with 4 gigs of RAM is not a problem in any serious language.
05:01:59 <RayNbow> :t Data.Array.Vector.newU
05:02:00 <lambdabot> Couldn't find qualified module.
05:02:17 <osfameron> quicksilver: right' seemed a bit yucky if I could default it.  I don't really understand GADTs but from what I understood it sounded vaguely in the ballpark
05:02:43 <temoto-wd> MyCatVerbs: ah well i thing typical node could fill up to 70% of available RAM as it is well... main storage.
05:02:49 <osfameron> quicksilver: ah!  I started off with Maybe, but I got bogged down with it in the foldr, maybe I'll try that again
05:02:55 <temoto-wd> think*
05:03:25 <quicksilver> osfameron: one advantage of using Maybe Cell is that you also have the type 'Cell' available
05:03:39 <quicksilver> osfameron: (for the definitely-non-empty case)
05:03:43 <benmachine> Definitely Cell
05:03:51 <quicksilver> osfameron: my gut instinct is taht that is useful.
05:04:21 <osfameron> ok
05:06:18 <HugoDaniel> is there any way to do some kind of dirty macros in haskell, so that certain instructions are only executed when im debugging my code ??
05:06:43 <quicksilver> HugoDaniel: my not just (if debugmode then ... else ...)
05:06:52 <quicksilver> where debugmode is a top-level constant.
05:06:56 <quicksilver> debugmode = True
05:07:15 <HugoDaniel> hmm ok
05:07:16 <wli> HugoDanie: I throw in MonadWriter and then only output the log contents when debugging is on.
05:07:27 <quicksilver> when debugmode $ putStrLn "HugoDaniel r roxor"
05:07:32 <HugoDaniel> hmm thats interesting wli
05:07:46 <Eridius> quicksilver: that will only work in the IO monad though
05:07:58 <quicksilver> Eridius: the latter, yes, it was only an example.
05:08:14 <quicksilver> Eridius: you can use 'when' in any monad and you can use 'if' anywhere at all.
05:08:19 <MyCatVerbs> temoto-wd: well... I don't know. Just beware that it's not all that easy to make Haskell data structures very very compact.
05:08:23 <maltem> HugoDaniel: otherwise, there's the preprocessor, but I guess it isn't really appropriate for handling single debug info lines
05:08:23 <quicksilver> putStrLn was just one exacmple of the kind of thing you might do.
05:08:24 <ski> wli : oh .. that's another use of `eval :: Monad m => (a -> m a) -> (m a -> m b)' :)
05:08:31 <HugoDaniel> ok thanks
05:08:32 <Eridius> quicksilver: true
05:10:01 <wli> MonadWriter and you can throw in the debug flag at the command line or turn it on in your repl.
05:10:38 <ski> (the first case being expression monads, with substitution)
05:22:15 <wli> ski: Which is another use of eval?
05:25:38 <wli> HugoDaniel: Another thing I do is to write the monad constraints as MonadState s m, MonadError e m, etc., and in debug versions throw in MonadIO m and spew debug info.
05:35:53 <HugoDaniel> :) thats quite professional wli
05:36:00 <HugoDaniel> i should probably do that here
05:36:25 <ImInYourMonad> @faq can haskell conquer russia?
05:36:25 <lambdabot> The answer is: Yes! Haskell can do that.
05:36:49 <ImInYourMonad> what do I need from happstack to just serve simple html?
05:36:56 <ImInYourMonad> the cabal install faield for me
05:37:04 <osfameron> quicksilver: iterate wants (a->a) but (fmap right) gives me (Functor f) => f (Cell a) -> f (Maybe (Cell a))
05:37:30 <osfameron> I'd expect it to give Maybe (Cell a) -> Maybe (Cell a), given that that's the kind of lifting that fmap is doing
05:38:31 <EvilTerran> what type is "right"?
05:38:42 <osfameron> EvilTerran: right :: Cell a -> Maybe (Cell a)
05:40:01 <EvilTerran> osfameron, what about, say, iterate (>>= right)?
05:40:09 <osfameron> EvilTerran: eeek!
05:40:26 <osfameron> yes, that makes sense now you mention it
05:41:06 <EvilTerran> :)
05:48:40 <temoto-wd> How to allocate, say, 1 million of hashes of two items String->Int, String->String ?
05:48:48 <ImOuttaYourMonad> isn there any docs coming for happstack? how do I just open a port at 8080 and serve some basic html?
05:48:55 <temoto-wd> I didn't use hashes in haskell before.
05:49:08 <ivanm> most people don't, AFAIK
05:49:19 * ivanm certainly hasn't
05:51:28 <temoto-wd> ImOuttaYourMonad: basic html or static html?
05:51:28 <ImOuttaYourMonad> isn there any docs coming for happstack? how do I just open a port at 8080 and serve some basic html?
05:52:19 <ImOuttaYourMonad> basic
05:52:22 <ivanm> ImOuttaYourMonad: it appears that most people aren't here atm, especially the 3 people that have actually used happs[tack] ;-)
05:53:07 <temoto-wd> ImOuttaYourMonad: i believe i saw example of basic html templating at their website.
05:53:28 <Lemmih> main = simpleHTTP nullConf [ anyRequest $ ok "Hello world" ] -- It was something like this in HAppS.
05:56:48 <ImOuttaYourMonad> main = simpleHTTP nullConf $ return "Hello World!"
05:56:54 <Axman6> ImOuttaYourMonad: docs are on the todo list (rather high priority i think)
05:57:34 <wli> Hashtables in Haskell are awkward. I don't know how to get them past the typechecker. The array API's don't link up with other monads conveniently if at all.
05:57:35 <Axman6> temoto-wd: hashtables are not something that are very commonly used in haskell
05:59:13 <wli> I think it's mostly a problem with how the array API's are done.
05:59:13 <quicksilver> wli: well, they need to be monads with IO in, because that's where the array lives. (or ST)
06:00:05 <wli> No, the runSTArray etc. bits are problems, too.
06:00:24 <quicksilver> wli: how so?
06:00:30 <temoto-wd> Axman6: uh... say haskell service receives JSON object from client and it must store it. How is it done in haskell if not hashes?
06:00:31 <quicksilver> @hoogle runSTArray
06:00:31 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
06:00:46 <quicksilver> that's just a special case, you don't have to use it.
06:00:51 <ivanm> temoto-wd: lists, sets, trees, etc.
06:00:55 <Axman6> maps
06:00:57 <ivanm> use a tree if you want a lookup
06:00:59 <quicksilver> it's a special case of runST + freeze, or something.
06:01:01 <temoto-wd> (store in memory)
06:01:08 <jenner> guys, is there a recommended vim plugin for haskell source?
06:01:09 <ivanm> Axman6: isn't a map just a tree?
06:01:13 <Axman6> temoto-wd: you're new to haskell aren't you
06:01:28 <Axman6> ivanm: sure. but i meant Data.Map specifically
06:01:31 <dolio> No, it's a list of pairs.
06:01:31 <temoto-wd> Axman6: i thought map and hash and dictionary are synonyms.
06:01:44 <quicksilver> temoto-wd: no, hash is a particular implmentation technique.
06:01:48 <ivanm> jenner: try http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
06:01:56 <quicksilver> but if you want a map/dictionary then, yes, use Data.Map
06:02:01 <temoto-wd> Axman6: i'm very new to haskell. Written two working programs so far. One is xmonad config :)
06:02:04 <ivanm> dolio: was that to me?
06:02:08 <dolio> Yes.
06:02:10 <SamB> silly perl
06:02:14 <temoto-wd> quicksilver: thanks.
06:02:15 <ivanm> oh....
06:02:33 <ivanm> isn't a list of pairs a rather bad implementation for a Map?
06:02:33 <Axman6> temoto-wd: well, go find a tutorial. you'll soon find out you don't store things in memory explicitly ;)
06:02:45 <ivanm> or is it because you can get away with Eq rather than Ord?
06:02:58 * ivanm can't remember the specifics of Data.Map
06:02:59 <wli> A lot of the time, it doesn't seem to be possible to treat it like a normal ST monad problem.
06:03:14 <temoto-wd> Then rewind, how to allocate, say 1 million of maps of two items? I want to compare haskell memory allocation.
06:03:17 <dolio> It is a bad implementation, yes.
06:03:28 <SamB> Data.Map *is* done with trees
06:03:41 <dolio> Yeah, I didn't mean Data.Map.
06:03:51 <ivanm> dolio: oh.... don't scare me like that!
06:03:53 <Axman6> temoto-wd: you don't worry about allocation in haskell either
06:03:59 <quicksilver> wli: why not?
06:04:05 <wli> dolio: Arrays?
06:04:18 <quicksilver> wli: can you be any more specific at all? STArrays are just one of the features of the ST monad.
06:04:23 <temoto-wd> Axman6: i don't worry, i want to compare it to other platforms.
06:04:34 <dolio> What about arrays?
06:04:52 <MyCatVerbs> temoto-wd: you just construct a two-million element list. Or a two-million element array.
06:05:03 <Axman6> temoto-wd: well, there's a good chance that if you use a map or something, the whole thing won't be allocated at all.
06:05:18 <MyCatVerbs> > length [1..(2*1024*1024)] -- look ma, stupid quantities of elements!
06:05:20 <lambdabot>   2097152
06:05:49 <ImOuttaYourMonad> Loading package array-0.2.0.0 ... linking ... : unable to load package `array-0.2.0.0'
06:05:49 <ImOuttaYourMonad> what kind of package is that? a special array package or bundled with ghc?
06:06:12 <quicksilver> ImOuttaYourMonad: "special" ?
06:06:15 <MyCatVerbs> temoto-wd: pure structure are just values. You build them by writing expressions with constructors in them.
06:06:15 <wli> quicksilver: The  natural way to write it doesn't typecheck due to e.g. the hidden ST variable escaping.
06:06:27 <Axman6> > [(x,['\NUL'..chr x]) | x <- [1..2000000]]
06:06:27 <MyCatVerbs> ImOuttaYourMonad: that's the ordinary base package for arrays. You are, um, in trouble.
06:06:29 <lambdabot>   [(1,"\NUL\SOH"),(2,"\NUL\SOH\STX"),(3,"\NUL\SOH\STX\ETX"),(4,"\NUL\SOH\STX\...
06:06:36 <quicksilver> it's the package which contains arrays, yes
06:06:41 <quicksilver> it probably came with your ghc.
06:06:54 <temoto-wd> Axman6: that's why i asked for help. I believe there's some kind of eval function, like id or something that forces stuff to evaluate.
06:07:06 <quicksilver> wli: if you're making the point it sounds like you're making, you simply don't know how to use ST.
06:07:12 <Axman6> you can use seq
06:07:17 <MyCatVerbs> temoto-wd: seq. Which forces things to evaluate up to their outermost constructor.
06:07:22 <SamB> temoto-wd: id is NOT it ;-P
06:07:22 <quicksilver> you have to 'run' ST stuff, to strip off the "s"
06:07:27 <temoto-wd> Yeah, seq.
06:07:31 <quicksilver> and of course the thing you return must not mention s
06:07:44 <MyCatVerbs> quicksilver: oh it can mention s. Just happily.
06:07:59 <MyCatVerbs> quicksilver: you just can't ever do anything with it if it does, or it'll violate the (forall s. s) constraint. :)
06:08:13 <ivanm> MyCatVerbs: yes, but seq will create the list, not the elements in it
06:08:16 <SamB> MyCatVerbs: no, it can't ...
06:08:32 <Axman6> temoto-wd: but if you're as new to haskell as you say you are and you're using seq, you're doing something wrong
06:08:35 <temoto-wd> In python i often use dicts as elementary data holders. Like user = {'name': 'John', 'age': 12}, what's haskell idiom for that?
06:08:41 <quicksilver> temoto-wd: Data.Map
06:08:50 <quicksilver> or, more often, a custom data type.
06:09:05 <ivanm> well, you can't do it that way
06:09:14 <Axman6> data User = User {name :: String, age :: Int}
06:09:16 <ivanm> (with Data.Map)
06:09:25 <jenner> temoto-wd: here's a really nice tutorial, read it (I do right now), it's worth it - http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
06:09:27 <temoto-wd> i guess i must read at this point
06:09:38 <temoto-wd> thanks
06:09:49 <Axman6> ok, sleep time. night all
06:10:02 <MyCatVerbs> SamB: oh, I'm wrong. Huh, oh well.
06:10:10 <kiris> user = [("name","John"),("age","12")]
06:10:20 <wli> quicksilver: Maybe. I think it's the API. In my case I'm not returning the arrays, which are only intermediate values.
06:10:21 <ImOuttaYourMonad> so I have it but it didnt load?
06:10:30 <quicksilver> wli: then there is no problem.
06:10:38 <temoto-wd> Tuples! I must've think about it!
06:10:56 <quicksilver> ImOuttaYourMonad: I've never seen that exact error. Not sure what it means.
06:11:05 <SamB> wli: runSTArray is just a wrapper around unsafeFreeze or whatever it's called
06:11:11 <temoto-wd> I believe they're slower that data User, though.
06:11:16 <SamB> (and runST, of course)
06:11:23 <SamB> a *safe* wrapper
06:11:44 <quicksilver> ImOuttaYourMonad: normally there is a nother more helpful error nearby
06:11:52 <quicksilver> SamB: wli said he wasn't trygin to return the array.
06:11:59 <SamB> quicksilver: yeah
06:12:02 <quicksilver> SamB: so he shouldn't need runSTArray and he shouldn't be having any problem.
06:12:21 <SamB> my point being that you don't use it unless you wanted to return an STArray into an Array ;-P
06:12:27 * quicksilver nods
06:12:32 <ImOuttaYourMonad> when i compile and run i gt no complaint but it doesnt serve anythign at 8080
06:12:57 <Axman6> ImOuttaYourMonad: you're doing something wrong then. go find a tutorial
06:13:01 <SamB> ImOuttaYourMonad: does it keep running ?
06:14:57 <temoto-wd> FiniteMap looks like what i need.
06:15:27 <ImOuttaYourMonad> yes Main just sits there, is it supposed to write something liek: serving on port 8080?
06:15:49 <temoto-wd> > let fm = listToFM [("name","John"),("age",13)]
06:15:50 <lambdabot>   <no location info>: parse error on input `;'
06:15:56 <SamB> ImOuttaYourMonad: dunno!
06:16:11 <SamB> but you could run lsof -p on it to see what files it has open
06:16:27 <temoto-wd> > let fm = listToFM [(`name`,"John"),(`age`,13)]
06:16:29 <lambdabot>   <no location info>: parse error on input `,'
06:16:39 <Saizan> temoto-wd: you need an "in"
06:16:44 <Saizan> temoto-wd: and Finite
06:16:52 <temoto-wd> > fm = listToFM [(`name`,"John"),(`age`,13)]
06:16:54 <lambdabot>   <no location info>: parse error on input `='
06:16:54 <Saizan> FiniteMap is not in scope, i think
06:16:59 <ImOuttaYourMonad> i have libsvm in C:/libsvm, im trying to install the haskell interface but it complains not found, can I somehow supply thta info to cabal install?
06:17:18 <quicksilver> temoto-wd: even if you could get that syntax right, it won't type-check.
06:17:25 <dcoutts_> ImOuttaYourMonad: --extra-lib-dirs=C:/libsvm
06:17:41 <temoto-wd> i always confusing lambdabot, .hs sources and ghci for `let` usage
06:18:05 <dcoutts_> ImOuttaYourMonad: or it might be C:/libsvm/lib, wherever it is that the library files actually are. You might need --extra-include-dirs too to point to where the .h files live.
06:18:09 <quicksilver> temoto-wd: lambdabot is like .hs sources.
06:18:15 <quicksilver> temoto-wd: ghci is like let-in-a-monad
06:18:37 <quicksilver> temoto-wd: but the point is that lists of pairs have a fixed "value type"
06:18:39 <temoto-wd>  :m +FiniteMap
06:18:40 <temoto-wd> Could not find module `FiniteMap':
06:18:42 <temoto-wd>   it is a member of package ghc-6.8.2, which is hidden
06:18:44 <temoto-wd> ?
06:18:51 <quicksilver> temoto-wd: "John" and 13 are not the same type.
06:19:01 <quicksilver> Data.Map also has a fixed value type.
06:19:01 <temoto-wd> oh
06:19:09 <temoto-wd> That's bad.
06:19:21 <SamB> heh
06:19:26 <dolio> No, that's good.
06:19:40 <int-e> > "\./"
06:19:41 <lambdabot>   <no location info>:
06:19:41 <lambdabot>      lexical error in string/character literal at chara...
06:19:56 <temoto-wd> How to store real-world multitype data then?
06:20:00 <wli> quicksilver: Except it doesn't work as expected.
06:20:01 <quicksilver> temoto-wd: the right way to do this is data Person = Person String Int
06:20:21 <quicksilver> wli: look, if you're not going to be precise with your complaints, this is a really pointless conversation.
06:20:25 <dcoutts_> temoto-wd: btw, you don't want to use FiniteMap, you want the Data.Map module
06:20:34 <Saizan> or use a JSON datatype if you need to represent all of json
06:20:34 <quicksilver> wli: ST and IO arrays work. They work fine. Their restrictions make sense.
06:20:35 <temoto-wd> quicksilver: well the problem is that type is unknown at compile time and it even can vary at runtime.
06:20:54 <quicksilver> temoto-wd: then you need to decide how your application needs to model that varying type.
06:20:57 <SamB> temoto-wd: I admit there've been times I've wished it wasn't fixed-type, but in those times I actually would've wanted to store the type in the key ;-)
06:20:58 <quicksilver> and model accordingly.
06:21:06 <wli> I'm on my treo. the UI is very limited.
06:21:26 <quicksilver> you might decide to model it by string representation (i.e. just use String)
06:21:31 <quicksilver> you might decide to use an ADT
06:21:36 <temoto-wd> ADT?
06:21:37 <SamB> but of course Haskell's type system doesn't support such complicated things nicely
06:21:45 <quicksilver> data TemotosCoolValues = I Int | S String | D Double
06:21:51 <temoto-wd> Abstract Data Type?
06:21:57 <quicksilver> Algebraic.
06:22:01 <temoto-wd> oh
06:22:09 <temoto-wd> like case in C structs?
06:22:09 <SamB> I have to ask that sometimes too
06:22:25 <SamB> (if someone means Algebraic or Abstract)
06:22:33 <quicksilver> SamB: in any case what you're talking about is cleverer compile-time dynamism (which is an interesting topic) but what temoto-wd seems to want is run-time dynamism (which is simpler, really)
06:22:45 <SamB> quicksilver: I know!
06:22:47 <quicksilver> temoto-wd: it's like union in C structs, but safer.
06:22:56 <temoto-wd> yeah union
06:23:12 <quicksilver> it's safer because it knows which branch of the union is in use at a particular time
06:23:33 <quicksilver> for example, in C you might store a 'tag' which indicates which one it is
06:23:43 <quicksilver> hence some people call them 'tagged unions'
06:23:44 <temoto-wd> yeah that's idiom
06:23:57 <quicksilver> although tagged unions is an implementation technique, not the abstract idea.
06:24:24 <daf> also known as "sum types", I think
06:24:26 <quicksilver> ultimately your code is going to have to 'do something' with this variable data.
06:24:32 <temoto-wd> So JSON values are built like that x Type | y Type?
06:24:35 <quicksilver> so it's going to have to cope with all the possibilities you expect.
06:24:41 <daf> (as opposed to product types)
06:25:10 <ImOuttaYourMonad> it serves on 8000 not 8080 duh!
06:25:14 <quicksilver> temoto-wd: JSON is something like : data JSON = Num Integer | Str String | Array [JSON] | Dict (Map String JSON)
06:25:28 <temoto-wd> Dict!!
06:25:28 <quicksilver> temoto-wd: although to support the entire JSON spec is slightly more complex than that.
06:25:37 <quicksilver> that's just a constructor name
06:25:40 <quicksilver> I chose it.
06:25:42 <temoto-wd> oh
06:25:45 <quicksilver> you could call it Biscuit if you prefer
06:25:53 <temoto-wd> nah, Dict is fine :)
06:25:56 <wli> I should take a stab at a B+ tree or hash trie to really get fo try to do fancy array footwork.
06:26:18 <quicksilver> data JSON = Frog Integer | Amsterdam String | Beauty [JSON] | Biscuit (Map String JSON)
06:26:27 <quicksilver> ^^ constructor names are essentially arbitrary.
06:26:35 <quicksilver> but it is probably sensible to choose meaningful ones.
06:26:36 <temoto-wd> I believe that should be Dict (Map JSON JSON), though.
06:26:46 <quicksilver> I don't think so.
06:26:49 <quicksilver> but ICBW.
06:26:49 <temoto-wd> No?
06:27:03 <quicksilver> I don't think JSON permits complex data as dictionary keys.
06:27:11 <temoto-wd> Well it is irrelevant anyway.
06:27:18 <SamB> json.org seems to side with quicksilver
06:27:25 <temoto-wd> :)
06:27:31 <quicksilver> SamB: sensible website.
06:27:36 <quicksilver> json.org++ # good judgement
06:27:39 <SamB> I didn't even have to click on anything once I goth there
06:27:53 <temoto-wd> Yeah very good site.
06:28:09 <SamB> very succinct
06:28:56 <bmh1> hello -- I was wondering is there are 'best practices' for implementing randomized algorithms and data structures. Particularly with regard to where the rng should live.
06:29:14 * SamB adds it to his stumbleupon favorites for lack of a better way to indicate his appreciation for the site's design
06:29:43 <temoto-wd> You could write webmaster.
06:29:49 <temoto-wd> I do that sometimes.
06:30:12 <SamB> hmm. but webmaster already knows that this is a good design!
06:30:28 <int-e> The names within an object SHOULD be unique.
06:30:35 <ImOuttaYourMonad> C:/libsvm-2.88/svm.h , but it doesnt work either with just the dir or the file
06:30:38 <SamB> I want other people to see it and think "why don't I make my site about a format similarly easy to navigate"
06:30:54 <temoto-wd> Clicking on ads is a nice way to appreciate deeds, but they don't have ads on json.org.
06:31:14 <int-e> But what if they aren't? (this is from the RFC 4627)
06:31:33 <EvilTerran> int-e, then _|_! :P
06:31:46 <SamB> int-e: I think you get to pick one value arbitrarily ?
06:32:10 <SamB> or perhaps even combine them using an arbitrary function of your choice ;-)
06:32:32 <MyCatVerbs> @pl \a b -> f a + g b
06:32:32 <lambdabot> (. g) . (+) . f
06:33:13 <EvilTerran> ?type \a b -> ?f a + ?g b
06:33:16 <lambdabot> forall t a t1. (Num a, ?g::t1 -> a, ?f::t -> a) => t -> t1 -> a
06:33:31 <quicksilver> int-e: then you are permitted to behave in any sensible way, but not crash.
06:33:37 <quicksilver> int-e: (I think that's what SHOULD means)
06:33:41 <bmh1> anyone... randomized data structures?
06:34:05 <EvilTerran> MyCatVerbs, i think liftA2 (+) f g would work, too
06:34:09 <MyCatVerbs> bmh1: are fun! But not as pretty as amortized data structures, IMO. :)
06:34:25 <temoto-wd> So how could this be implemented... haskell listens network, serving CRUD requests to it's internal list of eh..Maps like list of JSON objects, but i don't want to stick to JSON really.
06:34:26 <SamB> bmh1: that wouldn't be a sensible way to do it in Haskell ;-P
06:34:43 <SamB> temoto-wd: what do you want ?
06:34:56 <bmh1> MyCatVerbs:  It depends. I have a good deal of affection for splay trees, but treaps are very pretty
06:35:05 <MyCatVerbs> bmh1: randomized data structures don't necessarily work too nicely in Haskell because getting the random numbers in is awkward.
06:35:08 <temoto-wd> SamB: well this is kinda what i really want. In-memory database.
06:35:15 <EvilTerran> bmh1, randomized structures work better in languages with unconstrained side-effects
06:35:16 <temoto-wd> uh datatable?
06:35:28 <quicksilver> EvilTerran: f <^(+)^> g
06:35:35 <quicksilver> EvilTerran: it's the goatse combinator!
06:35:57 <EvilTerran> quicksilver, ... i was about to say "that looks good" 'til you said that -.-
06:36:03 <SamB> the thing that bothers me about splay trees is that the lookup function returns a new one ... and to get the benefit, you have to use that one next, yes?
06:36:33 <SamB> temoto-wd: so what kind of clients do you have ?
06:36:34 <MyCatVerbs> temoto-wd: honestly, as you've described it, the solution to your problem is to keep the things you store in a Berkely DB. That's pretty fast, and will let your database grow as much as you like.
06:36:36 <bmh1> SamB: You can do some awesome graph algorithms with splay trees
06:37:03 <SamB> basically, splay trees seem awkward to use
06:37:10 <MyCatVerbs> temoto-wd: if you look on Hackage, you'll note that there are both http://hackage.haskell.org/cgi-bin/hackage-scripts/package/berkeleydb and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BerkeleyDB
06:37:28 <SamB> if you really have an algorithm where they improve performance, I'm happy for you
06:37:54 <SamB> but they aren't exactly useful if you just want clean code
06:38:03 <MyCatVerbs> temoto-wd: er, looking at the descriptions, I'd use the former.
06:38:05 <temoto-wd> MyCatVerbs: yes, but AFAIK on memcachedb example, BDB is k-v only? Is there like "list" in it?
06:38:19 <bmh1> SamB: That objection seems specious.
06:38:33 <MyCatVerbs> temoto-wd: BDB is key-value store only. You would have to work around that. Shouldn't be hard, though.
06:38:34 <bmh1> What do splay trees have to do with clean code?
06:38:40 <SamB> unless you use the State monad or similar ...
06:38:47 <SamB> I guess
06:39:19 <temoto-wd> MyCatVerbs: and the point is that the whole stuff is in memory. So BDB is Map in that case.
06:39:32 <temoto-wd> Map is obviously faster than BDB
06:39:57 <SamB> what the heck have I done with my copy of Okasaki ...
06:40:11 <bmh1> I don't recall seeing Splay Trees in there
06:40:23 <SamB> bmh: oh.
06:40:28 <SamB> then I must be very confused!
06:40:56 <quicksilver> temoto-wd: I doubt Map is faster than BDB.
06:40:57 <bmh1> SamB: You might not be! Though I am charmed by my ability to influence your perception of reality in this way.
06:41:07 <quicksilver> temoto-wd: especially not for the "very large data set" case.
06:41:15 <temoto-wd> quicksilver: what a claim.
06:41:17 <SamB> hmm, the wikipedia article seems to confirm my suspicions though
06:41:19 <SamB> I think it is in there
06:41:27 <MyCatVerbs> SamB: IIRC Okasaki recommended against using splay trees in functional settings. He did write an implementation in there, I remember reading it.
06:41:35 <quicksilver> temoto-wd: well BDB is a compact data structure designed for efficient lookup
06:41:49 <quicksilver> temoto-wd: compactness matters a lot on modern CPUs, which are frequenty memory bandwidth constrained.
06:41:56 <MyCatVerbs> temoto-wd: but anyway. The networking is pretty easy if you use TCP sockets. You have one thread that calls Network.accept on a bind()'d and listen()'d socket, and then forkIO's a new thread for every client, passing the socket that accept returned to the client's thread. Then the accepter thread just carries on, and the client threads do the communication with the client.
06:42:01 <quicksilver> but then again, that may be premature optimisation.
06:42:05 <SamB> MyCatVerbs: I don't know if he really needed to bother with the recommendation
06:42:32 <temoto-wd> MyCatVerbs: please, please, please say you meant some kind of green threads.
06:42:35 <jeltsch> Gtk2Hs question: I run a Gtk2Hs program without problems, a student of mine runs the same program but all widgets (buttons, list views) lack text, i.e., are empty. Did anyone experience similar problems?
06:42:41 <SamB> quicksilver: is BDB that really annoying thing that changes format like every release?
06:42:49 <MyCatVerbs> SamB: wellllll... yes. The book's all about data structures that are efficient in practice when implemented. It's probably not safe to just assume that people will just know.
06:43:04 <quicksilver> SamB: probably.
06:43:07 <J-roen> Hi. Does anybody know if Lamdabot currently uses hs-plugins? I can't find it being used in Lambabot's code.
06:43:18 <SamB> http://books.google.com/books?id=SxPzSTcTalAC&pg=PA46&lpg=PA46&dq=splay+trees+okasaki&source=bl&ots=DEmYXEDk1V&sig=75RN_i4FSTGwzYoHLMCU3ZXKHOQ&hl=en&ei=Dm62SZeDBtKCtgf5lfS3CQ&sa=X&oi=book_result&resnum=1&ct=result
06:43:28 <MyCatVerbs> temoto-wd: then if you need any global state, you have either a single thread that manages it, and to which all the client threads post requests, or a pile of MVars containing data structures that all the threads can see.
06:43:31 <SamB> google tells me that splay trees are in Okasaki ;-)
06:43:36 <MyCatVerbs> temoto-wd: yes. GHC implements userspace threading.
06:43:46 <bmh1> "splay heaps"! Blasphemer.
06:43:47 <MyCatVerbs> temoto-wd: quite nicely, too. =)
06:43:50 <quicksilver> J-roen: I think it is using mueval.
06:44:03 <J-roen> quicksilver: Thanks. I will have a look.
06:44:04 <SamB> now if only it would tell me where MY copy is!
06:44:31 <temoto-wd> MyCatVerbs: that means one OS thread is involved?
06:44:39 <MyCatVerbs> bmh1: oh, shush. Heaps are practically the only use for the things in a functional language where they might actually be useful. Otherwise you can't guarantee that the rebalanced version you get when you splay is actually being used.
06:44:40 <ertai_> @seen dons
06:44:41 <lambdabot> dons is in #haskell, #darcs, #concatenative, #xmonad, #ghc and #arch-haskell. I last heard dons speak 16h 24m 25s ago.
06:44:47 <EvilTerran> temoto-wd, a fixed number of OS threads are involved, which you can set, iirc
06:45:09 <EvilTerran> temoto-wd, and (again iirc) the green threads are scheduled across the OS threads
06:45:15 <temoto-wd> If more than one OS thread is involved in IO, it is done bad.
06:45:16 <MyCatVerbs> temoto-wd: if you compile without -threaded, then one OS thread is involved and all the synchronization operations turn into normal memory operations.
06:45:17 <bmh1> MyCatVerbs: Inside of a fold?
06:45:27 <SamB> lol @ "reverse solidus" in RFC 4627
06:45:42 <EvilTerran> temoto-wd, you're gonna need multiple OS threads if you want to be able to use multiple cores, though
06:45:52 <temoto-wd> EvilTerran: that's for sure.
06:46:06 <MyCatVerbs> temoto-wd: if you compile with -threaded, then a fixed (set at run-time with +RTS -N number) number of OS threads are started up, and the Haskell runtime multiplexes all of your Haskell threads across them.
06:46:24 <temoto-wd> MyCatVerbs: thanks. That looks very very nice.
06:46:28 <quicksilver> well there are actually two entire different runtimes
06:46:30 <quicksilver> (related, of course)
06:46:38 <quicksilver> the non-threaded runtime does purely user threads
06:46:41 <temoto-wd> I wish they had same threading in python.
06:46:54 <MyCatVerbs> quicksilver: I mentioned that first. :)
06:46:55 <quicksilver> and has an IO controller which uses select() to handle the "blocking" IO
06:47:08 <quicksilver> the second runtime actually uses multiple OS threads
06:47:18 <quicksilver> and has various interesting features.
06:47:43 <quicksilver> MyCatVerbs: you did, I was just trying to emphasise the extent to which they are different runtimes, not options controlling a single one.
06:47:52 <temoto-wd> I was really interested in storing and quering in-memory list of maps rather than networking, though.
06:48:09 <quicksilver> in particular "-threaded" with "+RTS -N1" is quite different from the non-threaded runtime
06:48:13 <quicksilver> but both only use 1 OS thread.
06:48:27 <temoto-wd> So one option is BDB and still i need to maintain indicies (lists of Value->BDB-key)
06:48:46 <MyCatVerbs> temoto-wd: or you just make the BDB keys the Values.
06:48:48 <temoto-wd> which is well Map (Something->String
06:49:11 <temoto-wd> MyCatVerbs: pardon?
06:49:42 <MyCatVerbs> BDB uses arbitrary data - anything that you can serialize - as keys.
06:49:49 <temoto-wd> That doesn't create a list.
06:50:24 <wli> data B t = B (Array Int (Either t (B t))) | Nil?
06:50:28 <MyCatVerbs> If you actually need sharing, then you need to do something almost like that.
06:50:35 <temoto-wd> I need a list to do stuff like   take 10 user_name_index
06:50:43 <MyCatVerbs> But if you just need collections, then you could just serialize whole lists into the values.
06:51:41 <MyCatVerbs> Or heck, you could serialize pairs of (Value,KeyForNextElementOrNull).
06:52:03 <Fredrik> @pl \board -> not $ any (vacant board) [1.._WIDTH]
06:52:03 <lambdabot> (line 1, column 36):
06:52:03 <lambdabot> unexpected "." or "["
06:52:03 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
06:52:05 <wli> Next, STArray somehow.
06:52:11 <Fredrik> @pl \board -> (not $ any (vacant board) [1.._WIDTH])
06:52:11 <lambdabot> (line 1, column 37):
06:52:11 <lambdabot> unexpected "."
06:52:11 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
06:52:38 <Fredrik> @pl \board -> (not $ any (vacant board) [1..9])
06:52:38 <lambdabot> not . flip any [1..9] . vacant
06:52:49 <temoto-wd> MyCatVerbs: i believe serializing list into one key-value is bad because it doesn't scale. Like concurent updates to list must deserialize-update-serialize back. First and last are seem artifical trouble.
06:53:15 <dcoutts_> jeltsch: windows or unix? it sounds like inconsistent versions of gtk libs.
06:53:34 <temoto-wd> And again whole stuff is in memory so i believe no additional backend must be used besides native datastructures.
06:53:44 <dcoutts_> jeltsch: eg on windows if the %PATH% is wrong then it might pick up the wrong set of gtk dlls
06:54:11 <dcoutts_> jeltsch: if the user had some other app that used gtk and installed the gtk dlls on the %PATH%
06:54:44 <temoto-wd> Maybe i'm wrong with actual k-v data at that, but indexes seem must reside in kind of native list.
06:55:27 <temoto-wd> So could i use Map with runtime unknown key type?
06:55:38 <wli> data B s t = B (Maybe (STArray s Int (Either t (B t)))) and pray, I guess.
06:56:15 <temoto-wd> Or any other map-like datastructure? With kinda tree or hash implementation behind.
06:56:22 <temoto-wd> wli: was it for me?
06:57:08 <EvilTerran> wli, i think you missed an "s" before the last "t" there :P
06:57:20 <quicksilver> temoto-wd: well, there is no such thing as unknown types, in haskell.
06:57:30 <quicksilver> all types are known to the compiler.
06:57:32 <quicksilver> there is 'Dynamic'
06:57:39 <quicksilver> but, frankly, Dynamic is pretty reliably code smell.
06:57:50 <wli> yeah
06:57:51 <quicksilver> If you're using it then, in the words of the internet 'ur doin it wrong'.
06:58:07 <temoto-wd> quicksilver: yeah i just realized there's a limited subset of types which could be possibly used as keys in indexes: Int, Float, Decimal, String, DateTime, Date, Time.
06:58:12 <quicksilver> OK.
06:58:26 <quicksilver> Which takes us back to my initial suggestion of an ADT enumerating the types you actually support.
06:58:41 <quicksilver> which my JSON type was an example of (supporting only Int, String, Array and Dictionary)
06:58:59 <temoto-wd> Alright and use Map OlaType String ?
06:59:00 <quicksilver> but obviously you can add to that list.
06:59:12 <quicksilver> Map String OlaType probably
06:59:45 <temoto-wd> index is say, John's age 13 -> UserJhon-storage-hash-string
07:00:35 <temoto-wd> uh.. one more.. i need order in Map
07:00:42 <temoto-wd> very important
07:00:59 <temoto-wd> is it preserved?
07:01:01 <quicksilver> no.
07:01:11 <quicksilver> you can patch order on afterwards by also having a list (or Seq) of keys
07:01:20 <quicksilver> which records the order.
07:01:39 <temoto-wd> hm
07:02:10 <temoto-wd> Isn't [Map] better in first place?
07:02:48 <quicksilver> that depends what you want :P
07:03:09 <temoto-wd> Does it even makes sense? [Map OlaType String]
07:04:53 <temoto-wd> quicksilver: let's say i have Map or BDB with some hash->JSON. Then i have [Map Int String] which is index for quering JSON objects based on one particular their Int field.
07:06:08 <temoto-wd> as i handle request, say "first 10 jsons", i do     take 10 that_map_int_string
07:07:01 <temoto-wd> then return   map (take_from_BDB_by_key) (that take 10 result)
07:07:38 <temoto-wd> That's what i want. Does it make sense to you?
07:08:00 <coco`> what's the best way to mimic SQL's "group by" in haskell with lists?
07:08:28 <temoto-wd> sort . group ?
07:08:43 <quicksilver> temoto-wd: sure.
07:08:50 <temoto-wd> I believe it must be awfauly slow though.
07:09:00 <quicksilver> temoto-wd: except surely it isn't [Map Int String]
07:09:04 <quicksilver> it's [Map Int JSON]
07:09:24 <temoto-wd> quicksilver: nah String is a hash to lookup BDB or Map
07:09:34 <pejo> coco, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html, section 8.3.8.
07:10:03 <jatqceer> how do I solve n from y = n * (n - 1) `quot` 2
07:10:40 <Botje> set y to zero, drop the quot, solve ?
07:10:43 <temoto-wd> quicksilver: it could be [Map Int JSON] if haskell did store only one JSON object for several [Map Int JSON], [Map String JSON]. Which i don't believe.
07:11:04 <quicksilver> temoto-wd: you need to believe more.
07:11:09 <quicksilver> temoto-wd: everything is shared in haskel
07:11:13 <temoto-wd> aha
07:11:16 <temoto-wd> that's good
07:11:19 <quicksilver> temoto-wd: that's the benefit of immutability.
07:11:20 <temoto-wd> like in python :)
07:11:24 <quicksilver> temoto-wd: nothing is ever copied.
07:11:33 <quicksilver> because there is no need to copy it
07:11:38 <quicksilver> since you know it can't change!
07:11:39 <temoto-wd> Yeah i adopted that way and i like it very much.
07:12:09 <jatqceer> Botje: what do you mean?  I need a function f::Int -> Int where n = f y
07:12:14 <Botje> oh :P
07:12:20 <Botje> i thought you wre just solving it on paper
07:13:41 <temoto-wd> quicksilver: but data may change that's the point in database :)
07:13:54 <jatqceer> i don't know how to get sqrt ( 1+8*y ::Int )
07:14:03 <quicksilver> temoto-wd: sure, but then you alter the Map so it points to a new JSON value
07:14:21 <Botje> sqrt (1 + 8 * fromIntegral y)
07:14:41 <temoto-wd> quicksilver: so i must alter all indexes even if that index key is not changed in pointed data?
07:14:43 <Botje> if you add "floor" you're back to Int
07:14:49 <J-roen> Could it be possible that Lambdabot doesn't support dynamic loading of plugins at all at the moment?
07:15:11 <SamB> eww, yuck!
07:15:30 <bmh1> J-roen: lambdabot is a perpetual disappointment to me. It won't even execute malicious shell commands!
07:15:47 <Botje> .. OR launch missiles !
07:15:54 <bmh1> sure it will
07:16:03 <bmh1> > launchMissiles
07:16:05 <lambdabot>   Not in scope: `launchMissiles'
07:16:06 <SamB> to escape a non-BMP codepoint in JSON, you have to escape the UTF-16!
07:16:30 <jatqceer> Botje: but i need something will warn me if 1+8x is not a square of int
07:16:52 <Botje> oh
07:17:07 <Botje> there's a way, but it's pretty slow
07:17:28 <Botje> x == (floor $ sqrt x)^2
07:18:11 <jatqceer> and floor is not good enough, it might break for inexact of floating point
07:19:11 <Botje> check if it belongs to the list of squares, then?
07:19:32 <quicksilver> temoto-wd: if you have multiple indices then yes, you want those indices to point to some kind of 'reference value' or 'pointer' instead of the actual JSON.
07:19:41 <quicksilver> temoto-wd: otherwise it's a wasted cost to update them all.
07:20:41 <jatqceer> Botje: i don't want to waste mem on this
07:20:47 <temoto-wd> yes! Reference value!
07:21:46 <Botje> then i'm out of ideas.
07:22:21 <jatqceer> thanks anyway
07:22:33 <temoto-wd> quicksilver: so is that reference provided to me by language as in python or must i explicitly create another Map String-pointer JSON ?
07:22:45 <coco`>  is there an "unwords" for comma-separated lists?
07:23:29 <Botje> intercalate "," ?
07:24:02 <Botje> > intercalate "," ["y", "hallo", "thar"]
07:24:04 <lambdabot>   "y,hallo,thar"
07:24:16 <coco`> sorry, I meant: is there a "words" for comma-separated lists?
07:24:24 <Botje> oh :P
07:24:31 <quicksilver> temoto-wd: well, something has to handle the "uniqueness" of the references.
07:24:39 <quicksilver> temoto-wd: something has to hand out fresh names all the time.
07:24:57 <Botje> fresh naames! get your fresh names heeeere! :)
07:25:03 <quicksilver> temoto-wd: you can either do that yourself, or you can use IORef / STRef which do that for you, at the cost of being in a certain monad.
07:25:11 <sebaseba> kjhakjhasjkd
07:25:12 <quicksilver> because they're using that monad to regulate the name supply.
07:25:13 <Botje> coco`: easiest is just to slap a [ and ] on and use read
07:25:23 <quicksilver> or you can write your own name supply monad.
07:25:26 <quicksilver> (not as hard as it sounds)
07:26:45 <swiert> name supply should be applicative though, not monadic.
07:27:11 <coco`> Botje: but that only works when the elements are in quotes
07:27:45 <quicksilver> swiert: sure, but that's not particularly relevant to what I said.
07:27:49 <Botje> coco`: then you have to split on , yourself; you can check Data.List.Split (iirc) for inspiration
07:27:55 <quicksilver> swiert: you can s/monad/applicative/ in all those commends if youlike.
07:30:32 <temoto-wd> Which of [Map Int STRef(JSON)]  vs. [Map Int String], [Map String JSON]  is less memory-wise?
07:32:10 <quicksilver> well STRefs use much less memory than Strings.
07:32:39 <temoto-wd> and uh.. how do i decide which one of IORef/STRef to use?
07:33:16 <quicksilver> by learning a bit more about monads and how they work.
07:33:28 <quicksilver> using them is imposing something of a burden on the rest of your code.
07:33:34 <quicksilver> You may not enjoy the experience.
07:33:39 <wli> How can I get ghci to show which modules I've done :m + on?
07:33:39 <temoto-wd> oh
07:33:50 <bmh1> quicksilver: though ST imposes less of a burden
07:33:57 <quicksilver> perhaps.
07:35:22 <Eridius> @pl \c -> isAlphaNum c || c == '_'
07:35:22 <lambdabot> liftM2 (||) isAlphaNum ('_' ==)
07:35:34 <Eridius> eh, that's just silly
07:36:10 <quicksilver> isAlphaNum <^(||)^> (== '_')
07:36:13 <benmachine> @src liftM2
07:36:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:39:02 <jeltsch> dcoutts_: Coming back to the Gtk2Hs probem. (I was away.)
07:39:18 <jeltsch> dcoutts_: The user in question runs Gentoo Linux.
07:39:46 <jeltsch> dcoutts_: And thinks that he has only one version of GTK+ installed and that he didn‚Äôt update it since he installed Gtk2Hs.
07:40:14 <Fredrik> \pl \(x, y) -> (x+a, y+b)
07:40:14 <dcoutts_> jeltsch: and they do not get this effect with any other gtk apps I suppose
07:40:19 <Fredrik> @pl \(x, y) -> (x+a, y+b)
07:40:19 <lambdabot> (a +) *** (b +)
07:40:28 <Fredrik> :t ***
07:40:28 <dcoutts_> jeltsch: it's easy on Gentoo to get libs out of sync. I know, I run gentoo too :-)
07:40:29 <lambdabot> parse error on input `***'
07:40:34 <Fredrik> :t (***)
07:40:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:41:14 <jeltsch> dcoutts_: They get these effects only with Gtk2Hs apps.
07:41:34 <jeltsch> dcoutts_: To be more precise: only with Grapefruit apps (whereby Grapefruit uses Gtk2Hs internall).
07:41:47 <jeltsch> dcoutts_: But on my machine, there are no problems.
07:42:14 <jeltsch> dcoutts_: I asked them to try some of the Gtk2Hs demos and check whether they have the same problems.
07:42:26 <dcoutts_> jeltsch: and you say it's on all gtk labels etc, not just things drawn directly using pango?
07:43:22 <dcoutts_> jeltsch: what did they report about the demos?
07:43:50 <dcoutts_> jeltsch: one test I'd try would be loading a glade UI with labels etc in haskell vs in C.
07:44:36 <temoto-wd> Is Map for keeping one k-v pair?
07:45:12 <dcoutts_> @seen sioraiocht
07:45:12 <lambdabot> sioraiocht is in #haskell. I last heard sioraiocht speak 3h 33m 4s ago.
07:45:24 <J-roen> Lambdabot's source code contains a file called DynModules.hs, which contains this "MODULES Base System Dynamic : Dict Dummy" (without quotes) followed by more plugin names. Is this valid Haskell?
07:46:12 <quicksilver> J-roen: no.
07:46:31 <J-roen> quicksilver: Thanks. I wonder why it the filename is .hs.
07:46:34 <J-roen> -it
07:46:45 <quicksilver> maybe it gets preprocessed somehow
07:47:20 <temoto-wd> Is Map for keeping one k-v pair?
07:48:34 <jeltsch> dcoutts_: In one app, all text is missing.
07:49:38 <jeltsch> dcoutts_: In another app, most of the text is there. It‚Äôs just that sometimes text in list view text cell renderers disappears and then appears when the mouse is hovering over them.
07:50:11 <jeltsch> dcoutts_: They didn‚Äôt try the demos out yet. They checked with a different graphics card but this didn‚Äôt solve the problem.
07:50:38 <jeltsch> dcoutts_: ‚Äúone test I'd try would be loading a glade UI with labels etc in haskell vs in C.‚Äù
07:50:44 <jeltsch> dcoutts_: I don‚Äôt understand this.
07:50:56 <dcoutts_> jeltsch: and gtk-demo works perfectly? I mean can we rule out the possibility that this person generally uses KDE and so would not notice if gtk was broken?
07:51:01 <jeltsch> dcoutts_: Do you mean, they should implement an app with Glade and then run it?
07:51:03 <Toxaris> I'm trying to cabal-install pandoc on windows, but run into problems with digest and zlib, because both seem to export the same symbol _adler32. The problem happens with digest-0.0.0.3, digest-0.0.0.4 misses zconf.h and zutils.h. Ideas?
07:51:07 <jeltsch> dcoutts_: Or just run Glade?
07:51:29 <jeltsch> dcoutts_: This person runs GNOME.
07:51:35 <dcoutts_> jeltsch: ok
07:51:44 <dcoutts_> jeltsch: right, a "hello world" glade program in C
07:51:55 <dcoutts_> jeltsch: and the same program again but in Haskell
07:52:09 <jeltsch> dcoutts_: Okay, I‚Äôll ask them.
07:52:22 <dcoutts_> jeltsch: it's an interesting test because in both cases it's glade loading the UI and calling gtk C code to render the text.
07:52:42 <dcoutts_> jeltsch: if that fails with Haskell it'd indicate some kind of memory clobbering or something weird.
08:00:34 <Fredrik> @pl take 4 . iterate
08:00:34 <lambdabot> take 4 . iterate
08:03:45 <orgroot1> Does anyone here know how Lambdabot works?
08:04:12 <quicksilver> yes.
08:04:17 <temoto-wd> Pretty well.
08:04:52 <orgroot1> can you explain the route through the source code that is taken when i tell it "@run 1+1", for example?
08:05:51 <orgroot1> I've been browsing the sources for hours now, but no luck yet.
08:09:08 <jeltsch> dcoutts_: The list view Gtk2Hs example seems to work without problems.
08:09:22 <jeltsch> dcoutts_: I asked myself whether it‚Äôs Grapefruit that causes the problems.
08:09:51 <jeltsch> dcoutts_: What happens if you insert rows with an out-of-bounds index and similar stuff. Could this lead to such strange behavior?
08:13:16 <Toxaris> I identified my problem. Both zlib and digest bundle part of the zlib c sources on windows "for the benefit of users of Windows (which does not have zlib
08:13:16 <Toxaris>  by default)". Now pandoc uses both, so I end up with everything defined twice. How to proceed?
08:19:49 <wli> http://pastebin.com/m5558da05 <-- pathetic attempt to use callCC productively
08:22:55 <Eridius> err, does ghci attempt to load any files by default when you just run `ghci`? I'm running into a weird problem where running `ghci` inside of the Yi dir errors out with "module `Prelude' is not loaded", but works fine in other dirs
08:22:55 <wli> I could just have easily used return there.
08:23:01 <EvilTerran> wli, does callCC.const actually do anything special?
08:23:19 <wli> EvilTerran: No, which is why I could figure out how to use it.
08:23:46 * EvilTerran has previously thought about writing a BF interpreter involving ContT
08:23:55 <EvilTerran> to handle the [...]s
08:23:59 <Eridius> ah, I bet ghci imports Main.hs by default if it's in the dir
08:24:03 <Fredrik> @pl \a (x, y) -> column (a ! x) ! y
08:24:03 <lambdabot> (`ap` snd) . (. fst) . (((!) . column) .) . (!)
08:26:55 <wli> EvilTerran: I'm still struggling to figure out how to use callCC.
08:27:19 <EvilTerran> newtype BF r a = BF { unBF :: StateT ([Word8],Word8,[Word8]) (ContT r (StateT [BF r ()] (EtatsT [BF r ()] IO))) a } -- or something
08:28:35 <wli> EvilTerran: State machine transitions?
08:29:25 <EvilTerran> i was thinking the StateT [BF r ()] would be a stack of continuations, one for each [
08:30:05 <EvilTerran> and the EtatsT [BF r ()] a stack of continuations for the ]s
08:30:07 <EvilTerran> or something
08:30:19 <EvilTerran> i don't know if it'd work, i just thought it might
08:32:33 <PeakerWork> I'd model the current instruction ptr as an index into a list or array, I think
08:32:55 <EvilTerran> i've done that before
08:34:44 <EvilTerran> the idea was to basically have a mapping "parseChar :: Char --> SomeMonad ()" and then parsing just being a case of "mapM_ parseChar"
08:37:00 <EvilTerran> or something ... it was just a random idea, anyway :P
08:50:14 <PeakerWork> EvilTerran: who gave you permission to have random ideas? :)
08:51:50 <ImOuttaYourMonad> how does a sparse hashmap make sense? what is sparse in that context(i mean you cant have a lot of zeros like in a sparse matrix)?
08:52:44 <quicksilver> one where you aren't filling your buckets very much, perhaps.
08:52:48 <PeakerWork> ImOuttaYourMonad: sparse typically means it is only populated with actual items, and not potential items
08:53:10 <dcoutts_> jeltsch: it's possible
08:53:49 <dcoutts_> jeltsch: in the past, I've noticed that any memory corruption is first found by segfaults in font rendering code. It seems most sensitive to it.
08:54:21 <dcoutts_> jeltsch: is grapefruit using the old ListStore etc rather than the new model where the data is kept on the Haskell side?
08:55:09 <goomba`> wouldnt all hash maps be sparse....otherwise you could just have a list
08:55:44 <goomba`> start calling lists 'dense hash maps' in everything
08:55:58 <goomba`> confuse everyone
08:56:05 <quicksilver> goomba`: no, a so-called "perfect hash" is 100% dense.
09:04:50 * EvilTerran tries to work out how to show that a given lambda-calc term (say, \x.xx) is not equal to any simply-typable term
09:08:36 <quicksilver> EvilTerran: by showing that type inference fails on it.
09:08:49 <quicksilver> EvilTerran: (it should be fairly clear that type inference respects equality)
09:09:04 <DevHC> hi
09:09:06 <DevHC> is there something like function overloading is haskell?
09:09:12 <quicksilver> yes. typeclasses.
09:09:48 <DevHC> i have defined operators +++, +/+, +^+, etc. for automatic parenthesing of simple mathematic expressions
09:10:08 <pumpkin_> onoes, overlap with ArrowChoice
09:10:47 <DevHC> so i can write X +++ B +^+ C +*+ Y, and it will evaluate as "(X+((B^C)*D))"
09:11:06 <DevHC> i have defined infixr/infixl for them
09:11:12 <pumpkin_> you can just write a Num instance for your symbolic type
09:11:18 <DevHC> no
09:11:21 <pumpkin_> a few people have done that before
09:11:21 <pumpkin_> oh
09:11:22 <DevHC> i mean i want a string
09:11:29 <DevHC> the problem is that the function returns a string
09:11:32 <pumpkin_> you can
09:11:36 <DevHC> and therefore the next argument must be a string
09:11:36 <pumpkin_> you can't use show?
09:11:47 <DevHC> i want to use chars like 'a' + 'b'
09:11:54 <DevHC> instead of ['a']
09:12:01 <vixey> DevHC, look at this:
09:12:05 <vixey> > x + b * y
09:12:06 <lambdabot>   x + b * y
09:12:16 <DevHC> lol
09:12:18 <vixey> lambdabot is implementing your idea
09:12:18 <pumpkin_> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html
09:12:32 <pumpkin_> DevHC: check out that blog post
09:12:41 <pumpkin_> DevHC: not reducing it to a string immediately also has other benefits
09:13:10 <b_jonas> :-)
09:14:23 <DevHC> it's a basic stringwise function that gives a string which expresses the precedence/evaluation order of a mathematical expression, not related to any real calculation or language
09:14:33 <DevHC> [looking @ teh blog..]
09:14:49 <b_jonas> > x + (b * y)
09:14:51 <lambdabot>   x + b * y
09:15:13 <ziman> > (x + b) * y
09:15:14 <lambdabot>   (x + b) * y
09:15:23 <pumpkin_> mmm @ http://personal.cis.strath.ac.uk/~conor/phds/
09:18:23 <quicksilver> pumpkin_: advantages : work with cool, clever, people in scotland on interesting stuff.
09:18:30 <quicksilver> pumpkin_: disadvantages : scotland.
09:18:44 <pumpkin_> lol, I like the parts of scotland I've visited!
09:19:57 <quicksilver> pumpkin_: actually I love scotland.
09:20:09 <quicksilver> but for a holiday, not to live there all the time.
09:20:13 <pumpkin_> yeah :)
09:21:39 <ray> pumpkin_: sco.wikipedia.org
09:21:50 <pumpkin_> ack!
09:22:29 <p_l> nice :3
09:22:49 * p_l applied to strathclyde but found requirements a little bit too high
09:24:16 <p_l> So I ended up even farther in scotland, in Aberdeen :D
09:25:41 * quicksilver force-feeds p_l deep fried haggis and mars bars.
09:26:58 <roconnor> can I have a deep fried mars bar?
09:28:07 <quicksilver> @faq can haskell give roconnor a depp fried mars bar?
09:28:08 <lambdabot> The answer is: Yes! Haskell can do that.
09:28:14 <EvilTerran> quicksilver, but, say, ki(\x.xx) = i, so ki(\x.xx) isn't typable, but is equal to a typable term
09:28:26 <p_l> quicksilver: hmmm.... I don't recall eating haggis :>
09:28:31 <BMeph>  @faq can haskell give roconnor a johnny depp-fried mars bar?
09:28:59 <p_l> quicksilver: Though I'm a big fan of mars bars, so if they are for free then gimme :3
09:29:38 <quicksilver> EvilTerran: oh, that's an interesting point.
09:30:30 <vixey> equal to a typable term.. also known as: reduces to a normal form
09:30:31 <quicksilver> EvilTerran: but it doesn't matter because that's the opposite way round to the property I need.
09:31:00 <quicksilver> EvilTerran: all I need is that if (\x.xx) was equal to a typeable term, it would have the type of that term.
09:31:06 <quicksilver> EvilTerran: the converse isn't important.
09:32:41 <Toxaris> so now I have patched digest to be linkable with zlib, now how do I tell cabal-install not to install digest from hackage (but satisfy the dependency by the already installed digest)?
09:33:11 <Toxaris> so I want   cabal install pandoc --do-not-install digest
09:33:49 <dcoutts_> Toxaris: you can constrain the version it picks
09:34:05 <dcoutts_> Toxaris: also make sure you're running the latest cabal-install version
09:34:06 <dcoutts_> 0.6.2
09:34:30 <dcoutts_> there was an improvement in that area, you may find it just works with 0.6.2 where it didn't with 0.6.0
09:37:45 <Toxaris> dcoutts_: thanks, both cabal install cabal-install   and cabal install pandoc   worked fine :)
09:37:56 <dcoutts_> Toxaris: great
09:39:25 <ziman> is there an easy way to determine which hackage packages a program depends on? I could grep & sed out the names of all modules the program imports
09:39:38 <dons> cabal can tell you, i think
09:39:46 <vixey> ziman, I think cabal deals with this sort of thing..
09:40:17 <vixey> I guess that doesn't mean much if you are making it into a cabal package right now
09:40:22 <dcoutts_> ziman: cabal info pkgname
09:40:28 <dcoutts_> that reports the dependencies
09:40:52 <dcoutts_> ziman: of course if you just want to install it and its deps then just cabal install pkgname
09:41:25 <dcoutts_> ziman: oh, if you mean a package you're writing, what it needs then that's different of course
09:42:10 <ziman> yes, i didn't put down the names of the packages I installed as I was writing it
09:43:02 <ziman> i did cabal list --installed and i think i'll be able to filter
09:43:46 <dcoutts_> ziman: if you're building it with cabal then all the deps have to be listed in the build-depends
09:43:47 <ziman> thanks
09:44:08 <dcoutts_> ziman: and you can find out what they are because if you start with none, ghc will tell you until you've got them all
09:44:25 <dcoutts_> so there's no need to go guessing or searching around
09:44:32 <dcoutts_> just use cabal to build your prog
09:45:48 <igel> what's the easiest way to run a buch of quickcheck functions?
09:45:59 <igel> i currently have sth like
09:46:24 <igel> putStr "first prop" >> quickcheck firstprop >> putStr "2nd prop" >> quickcheck sndprop
09:46:29 <igel> and so on
09:47:03 <igel> is there sth that takes a list of strings (descriptions) and properties and tests all of them?
09:47:22 <igel> i tried to use the 'label' function, but it only displays the given string if the test succeeds
09:47:22 <EvilTerran> quicksilver, ah, here's a tactic that seems to work in my head: because (\x.xx) is a normal form, anything equal to (\x.xx) must beta-reduce to it; beta-reduction *does* preserve typing, so anything equal to (\x.xx) having a type would imply that (\x.xx) had the same type
09:47:46 <igel> but it also needs to be displayed if the test fails...
09:48:04 <vixey> "beta-reduction *does* preserve typing" -- Haskell type system or which type system?
09:48:06 <igel> otherwise you don't know which test went wrong
09:48:20 <EvilTerran> vixey, simply-typed lambda calculus
09:49:33 <quicksilver> igel: it's not very hard to write the function with type [(String,Property)] -> IO ()
09:49:41 <quicksilver> igel: which behaves as you describe.
09:49:50 <igel> sure
09:50:00 <igel> but why is there no standard for that?
09:50:19 <igel> i think that's the usual use case :)
09:50:35 <igel> [(String, forall p. Property p => p)] i mean
09:50:56 * vixey wonders if beta reduction preserves typing holds for terms that don't have a type
09:50:58 <quicksilver> igel: well, quickcheck doesn't have any "harness" like tools at all, really.
09:51:41 <jeltsch> dcoutts_: Grapefruit uses the new ListStore (the one from ModelView).
09:51:44 <igel> but what is 'label' good for?
09:51:55 <quicksilver> well there is the Batch stuff.
09:52:02 <EvilTerran> vixey, the bit i need is that beta-reducting a term won't cause it to stop having a type it had already
09:52:06 <dcoutts_> jeltsch: ok, in that case I think all indexing is checked. I think.
09:52:09 <igel> quicksilver: what do you mean?
09:52:56 <jeltsch> dcoutts_: By the way, do row and column indices start with 0 or 1?
09:52:56 <mattam> vixey: no. (\x.xx) (\y.y) -> \y.y
09:53:13 <dcoutts_> jeltsch: I'm not sure OTTOMH
09:53:24 <jeltsch> dcoutts_: I assumed, they start with 0
09:53:36 <dcoutts_> jeltsch: I'd hope so too
09:54:13 <jeltsch> dcoutts_: Until now, we were only able to get these problems with Grapefruit, not with pure Gtk2Hs.
09:54:33 <jeltsch> dcoutts_: However, we only tried ‚ÄúHello world‚Äù and the list view example with plain Gtk2Hs.
09:54:51 <jeltsch> dcoutts_: It‚Äôs only text that‚Äôs missing.
09:54:57 <jeltsch> dcoutts_: And not always all text.
09:55:21 <dcoutts_> jeltsch: the text is missing in the plain gtk2hs demos too? or did you say the problem so far is only with Grapefruit?
09:55:26 <EvilTerran> vixey, although it may well cause it to gain types
09:55:30 <jeltsch> dcoutts_: For example, sometimes you move the mouse bottom-up over a list view and the texts disappear. You move it top-down then and the texts reappear.
09:55:55 <jeltsch> dcoutts_: You swap columns and everything is okay. You swap them back and the problems are there again.
09:56:13 <jeltsch> dcoutts_: The problems are only when using Grapefruit.
09:56:45 <dcoutts_> jeltsch: I suggest you post a minimal example to the gtk2hs devel list and see if anyone can reproduce it or spot if grapefruit is doing anything wrong
09:56:47 <jeltsch> dcoutts_: However, I thought that Gtk2Hs gives runtime errors when used incorrectly.
09:56:59 <dcoutts_> jeltsch: it should do, yes
09:57:04 <jeltsch> dcoutts_: A minimal example using Grapefruit?
09:57:08 <dcoutts_> jeltsch: yes
09:57:30 <jeltsch> dcoutts_: You can get some from the repository.
09:57:57 <dcoutts_> jeltsch: I'm afraid I don't have time to track it down myself at the moment.
09:58:19 <dcoutts_> jeltsch: hence my suggestion you try the gtk2hs-devel list
09:58:25 <jeltsch> dcoutts_: Okay.
09:59:14 <Fredrik> @pl \x -> length $ findIndices ((player ==) . (board `at`)) x
09:59:14 <lambdabot> length . findIndices ((player ==) . (board `at`))
10:00:00 <LeoD> ;p
10:03:16 <Fredrik> is there a function that converts [0,0,0,1,0,1,1,0,0,0,1] to [(0,7), (1,4)] ? eg counting occurences
10:03:34 <EvilTerran> > group  [0,0,0,1,0,1,1,0,0,0,1]
10:03:35 <lambdabot>   [[0,0,0],[1],[0],[1,1],[0,0,0],[1]]
10:03:59 <EvilTerran> > group . sort $ [0,0,0,1,0,1,1,0,0,0,1]
10:04:00 <lambdabot>   [[0,0,0,0,0,0,0],[1,1,1,1]]
10:05:13 <ddarius> :t insertWith
10:05:14 <lambdabot> Not in scope: `insertWith'
10:05:19 <ddarius> :t M.insertWith
10:05:20 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
10:05:21 <Fredrik> > map length $ group . sort $ [0,0,0,1,0,1,1,0,0,0,1]
10:05:22 <lambdabot>   [7,4]
10:05:38 <EvilTerran> > map (head &&& length) . group . sort $ [0,0,0,1,0,1,1,0,0,0,1]
10:05:39 <lambdabot>   [(0,7),(1,4)]
10:05:48 <skorpan> :t (&&&)
10:05:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:05:52 <skorpan> damn you arrows...!
10:06:31 <ddarius> > foldl' (\acc k -> M.insertWith' (+) k 1 acc) (M.empty) [0,0,0,1,0,1,1,0,0,0,1]
10:06:32 <lambdabot>   /tmp/1055416311887358118:70:98: Not in scope: `M.insertWith''/tmp/105541631...
10:06:46 <skorpan> EvilTerran: care to make the same thing using a list comprehension?
10:06:47 <ddarius> > foldl' (\acc k -> Data.Map.insertWith' (+) k 1 acc) (Data.Map.empty) [0,0,0,1,0,1,1,0,0,0,1]
10:06:48 <lambdabot>   /tmp/7317796626845081437:70:98:
10:06:48 <lambdabot>      Not in scope: `Data.Map.insertWith''/t...
10:07:00 <ddarius> > foldl' (\acc k -> Data.Map.insertWith (+) k 1 acc) (Data.Map.empty) [0,0,0,1,0,1,1,0,0,0,1]
10:07:01 <lambdabot>   /tmp/8363115298632192390:70:98: Not in scope: `Data.Map.insertWith'/tmp/836...
10:07:58 <whpearson> > foldl' (\acc k -> Map.insertWith' (+) k 1 acc) (Map.empty) [0,0,0,1,0,1,1,0,0,0,1]
10:07:59 <lambdabot>   fromList [(0,7),(1,4)]
10:11:58 <Fredrik> @pl \a x -> a + 69^x
10:11:58 <lambdabot> (. (69 ^)) . (+)
10:13:20 <snoobino> what does the algebraic mean in ADT ?
10:14:28 <vixey> II think it's because the data types are made up of sums and products of other types
10:14:53 <snoobino> ok
10:14:58 <snoobino> so most data types are ?
10:15:05 <vixey> maybe it's more to do with how the definitions correspond to initial algebras
10:15:20 <c_wraith> I'm pretty sure all data types in haskell are algebraic
10:15:39 <snoobino> ok thx
10:16:06 <dolio> They can have exponents, too.
10:17:30 <EvilTerran> c_wraith, well, apart from the builtin types, like numbers and whatnot
10:17:55 <EvilTerran> (although they could be expressed algebraically if anyone could be bothered)
10:17:58 <c_wraith> Ah, good point.  Everything defined with "data", then, to be safe?
10:18:38 <vixey> c_wraith there is also generalized ADTs
10:18:58 <Trafalgard> So I have something that's going "C stack overflow in generated code" and dying if I run the compiled exe, or appearing to freeze when executing a show statement if run in GHCi. I've tried running it with +RTS -xc -RTS and I get spammed with a ton of identical <> stuff, and I don't see how it could be screwing up in the functions it lists. Those functions are generating lists, which are of limited but randomly generated size, which a
10:18:58 <Trafalgard> re converted to strings and to another type which is what's later shown (that seems to freeze in GHCi)
10:20:45 <Trafalgard> so then I said, you know, I'll try the instructions in section 6.3 in here instead: http://www.haskell.org/haskellwiki/Debugging
10:20:52 <Trafalgard> since that should tell me where it's freezing
10:21:35 <Trafalgard> but when I press ctrl-c (and I am running it with ghcii.sh), instead of just ending the running code and going back to GHCi, it exits back to the shell
10:21:55 <dolio> I suppose any ADT with an exponential is just using the built-in exponential as one of its factors, though.
10:21:57 <Trafalgard> which makes it rather impossible to go to step 4 and use :history and :back
10:22:24 * Trafalgard is on windows xp
10:22:32 * Trafalgard is running ghcii.sh through msys
10:23:18 <Gracenotes> Trafalgard: uhm.. would rlwrap help? If that's available for windows
10:23:57 <Gracenotes> it seems one's available in cygwin
10:25:14 * Trafalgard hrms
10:26:07 <Gracenotes> rlwrap is really only a solution for the exiting-and-losing-history problem. Although it does have some nice history features in general
10:27:53 * Trafalgard will try running it in virtualbox first, since I have ubuntu and haskell set up in virtualbox already. Hmm, there's a new virtualbox version. Updating it will probably knock me offline momentarily...
10:29:43 <Fredrik> @pl \i -> (i, move board Computer i)
10:29:43 <lambdabot> ap (,) (move board Computer)
10:31:38 <swiert> @seen ddarius
10:31:38 <lambdabot> ddarius is in #haskell, #haskell-blah and #haskell-overflow. I last heard ddarius speak 23m 10s ago.
10:32:09 <ddarius> swiert: Yes?
10:32:28 <swiert> ddarius: Hiya. Are you Ok with the release candidate for TMR?
10:32:50 <ddarius> swiert: To be honest, I haven't looked at it yet.
10:33:46 <swiert> ddarius: np. If you could have a look at any edits I made (not much, if I remember correctly) and let me know if it's ok with you.
10:33:58 <swiert> I'm kind of hoping to release before the end of the week.
10:34:40 <ddarius> swiert: I can have an response this afternoon (for me).  You'll probably get it tomorrow.
10:34:51 <swiert> ddarius: that'd be perfect.
10:34:54 <swiert> thanks!
10:40:09 <Fredrik> @pl \(_, w) (_, v) -> compare w v
10:40:09 <lambdabot> (. snd) . compare . snd
10:40:47 <Fredrik> @pl \(i, w) -> (i, rating w Computer - rating w Human)
10:40:47 <lambdabot> second (ap ((-) . flip rating Computer) (flip rating Human))
10:46:39 <Baughn> @seen mbeddoe
10:46:39 <lambdabot> Last time I saw mbeddoe was when I left #debian-es, #dreamlinux-es, #friendly-coders, #gentoo-uy, #haskell, #haskell-hac07, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.
10:46:39 <lambdabot> hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru and #thunks 6m 26d 12h 20m 6s ago.
10:47:12 <Baughn> Ouch. Hm, what's the protocol for taking over an abandoned package?
10:47:26 <skorpan> http
10:47:31 <pumpkin_> ssh
10:47:39 <pumpkin_> tcp, maybe
10:47:50 * Baughn smacks the both of you with a paper fan
10:52:11 * Trafalgard hands Baughn a basket of angry sea kittens
10:59:03 <pumpkin_> ChilliX_: what's the status on gpugen? has there been anything since the draft?
11:06:56 <DCEmu_user68> Come visit my forum where you can watch the newest movies online for FREE: http://movieparadise.informe.com/
11:07:13 <EvilTerran> ops?
11:07:26 <pumpkin_> @where ops
11:07:26 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:07:28 <vixey> DCEmu_user68: no
11:07:52 --- mode: ChanServ set +o Igloo
11:07:54 <kerlo> If this violates freenode policy, we should get a freenode op.
11:08:07 --- mode: Igloo set +b *!*@ip-81-11-183-100.dsl.scarlet.be
11:08:10 --- kick: DCEmu_user68 was kicked by Igloo (Igloo)
11:10:48 <paper_cc> Fredrick: the first is (compare `on` snd) or (comparing snd)
11:11:16 <wli> Well, he's gone.
11:31:31 <BMeph> @src subtract
11:31:31 <lambdabot> subtract x y = y - x
11:32:09 <gnuvince> > flip (-) 2 3 = subtract 2 3
11:32:10 <lambdabot>   <no location info>: parse error on input `='
11:32:15 <gnuvince> > flip (-) 2 3 == subtract 2 3
11:32:16 <lambdabot>   True
11:32:33 <vixey> > (flip (-) x y, subtract x y)
11:32:34 <lambdabot>   (y - x,y - x)
11:33:32 <omnihil> @src flip
11:33:33 <lambdabot> flip f x y = f y x
11:33:43 <vixey> yuuck
11:33:50 <vixey> who wrote that def. of flip it sucks
11:34:09 <BONUS> vixey why
11:34:14 <dons> ?pl flip f x y = f y x
11:34:14 <lambdabot> flip = flip
11:34:16 <vixey> it should be
11:34:18 <dons> hehe
11:34:19 <vixey> flip y x = f x y
11:34:23 <vixey> flip f y x = f x y
11:34:30 <vixey> :t flip
11:34:31 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:34:31 <dons> suxors
11:34:38 <vixey> f :: (a -> b -> c)
11:34:38 <BONUS> haha
11:34:39 <dons> flip f b a = flip f a b
11:34:40 <vixey> y :: b
11:34:41 <vixey> x :: a
11:34:44 <vixey> yes
11:34:48 <dons> shrug
11:34:50 <dons> suxors. dude
11:34:52 <vixey> this definition is totally ridiculous
11:34:52 <dons> lolz
11:34:56 <dons> totally lol
11:35:09 <dons> omg can you believe it? wtf?
11:35:23 <vixey> will someone change it?
11:35:29 <dons> no.
11:37:23 <centrinia> @let rot3 f a b c = f c a b
11:37:25 <lambdabot>  Defined.
11:37:41 <pumpkin_> that looks useful ;)
11:38:05 <pumpkin_> @pl rot3
11:38:05 <lambdabot> rot3
11:38:16 <pumpkin_> @pl rot3 f a b c = f c a b
11:38:16 <lambdabot> rot3 = (flip .) . flip
11:38:24 <vixey> dons are you taking the piss?
11:38:41 <dons> lolz no.
11:38:43 <vixey> cause you don't normally sound like such an idiot
11:38:47 <pumpkin_> lol
11:39:04 <vixey> why not stop such a fucking dork and say something meaningful
11:39:06 <pumpkin_> I bet he was reading 4chan and his mind rotted
11:39:33 <dons> vixey: use appropriate language in a public forum, kthxby
11:39:34 <pumpkin_> vixey: I thought you were being silly too, tbh
11:39:48 <centrinia> @type rot3 . rot3 . rot3
11:39:49 <lambdabot> forall t2 t t1 t3. (t2 -> t -> t1 -> t3) -> t2 -> t -> t1 -> t3
11:40:00 <vixey> dons, don't provoke people then you idiot
11:40:04 <centrinia> That makes sense.
11:40:07 <pumpkin_> o.O
11:40:29 <dons> sigh.
11:41:08 <tromp_> what's your problem, vixey?
11:41:43 <centrinia> Wait, what does a set generators of an arbitrary symmetric group look like?
11:42:08 <rio> pumpkin_: what does @pl do?
11:42:18 <pumpkin_> rio: it removes mentions of arguments from function definitions
11:42:18 <centrinia>  @pl is pointless. ;)
11:42:36 <Cale> centrinia: Well, you can use (1,2,..,n) and (1,2)
11:42:38 <sjanssen> @. djinn type flip
11:42:40 <lambdabot> f a b c = a c b
11:43:09 <centrinia> @. djinn type rot3
11:43:10 <lambdabot> f a b c d = a d b c
11:44:09 <ziman> @. djinn type either
11:44:10 <lambdabot> f a b c =
11:44:10 <lambdabot>     case c of
11:44:10 <lambdabot>     Left d -> a d
11:44:10 <lambdabot>     Right e -> b e
11:44:34 <centrinia> Cale, alternating groups can be generated from a single generator?
11:44:58 <Cale> hmm?
11:45:00 <Cale> No...
11:45:06 <Cale> That would mean they're cyclic.
11:46:30 <Cale> I'm fairly sure you can always generate the alternating group with two odd cycles.
11:46:37 <Cale> (particular ones...)
11:47:05 <centrinia> Symmetric groups can be generated by three elements?
11:47:19 <Cale> Symmetric groups can also be generated with only two elements.
11:47:40 <jadrian> hello
11:47:45 <wli> ISTR similar from Galois theory.
11:47:58 <jadrian> is there any name for a type with no monomorphic terms?
11:48:18 <jadrian> monomorphic types
11:48:23 <Cale> jadrian: None at all? Like f (g a) (g b)?
11:48:27 <centrinia> constants?
11:48:30 <Cale> Not even -> ?
11:49:21 <jadrian> let me rephrase that then
11:50:10 <jadrian> is there any name for a type containing only type variables as primitive types
11:50:19 <jadrian> so the idea is
11:50:22 <jadrian> type variables
11:50:30 <jadrian> and type constructors
11:51:03 <Cale> jadrian: hmm...
11:51:10 <jadrian> so this would fit my definition     (a -> b) x b -> a
11:51:14 <Cale> jadrian: I haven't heard a term for it anyway.
11:51:27 <centrinia> What is the 'x' ?
11:51:34 <jadrian> even though I messed up and made it a stupid type :)
11:51:36 <Cale> Might call it a "fully polymorphic type"
11:51:37 <jadrian> product
11:51:45 <centrinia> (a -> b,b) -> a
11:51:56 <centrinia> @djinn (a -> b,b) -> a
11:51:57 <lambdabot> -- f cannot be realized.
11:52:04 <centrinia> Hmm, that doesn't make sense.
11:52:08 <plumpkin> nope
11:52:08 <jadrian> I know
11:52:10 <jadrian>  :)
11:52:25 <jadrian> (a -> b, a ) -> b
11:52:34 <plumpkin> that one's easy
11:52:34 <centrinia> @djinn (a -> b,a) -> b
11:52:35 <lambdabot> f (a, b) = a b
11:52:38 <jadrian> that's a bit more sensible :)
11:52:51 <jadrian> what does djinn do?
11:52:52 <centrinia> Modus ponens. :)
11:52:55 <plumpkin> Isomorphism a b -> Isomorphism b a
11:53:18 <plumpkin> jadrian: given a type, it'll try to write a function with that type
11:53:26 <jadrian> @djinn (a->a,a)->a
11:53:26 <lambdabot> f (a, b) = a b
11:53:44 <jadrian> plumpkin, I see nice
11:53:45 <Cale> centrinia: It seems that A_(2n) is generated by the cycles (1,2,3) and (2,..,2n), and A_(2n+1) is generated by (1,2,3) and (1,2,...,2n+1)
11:53:52 <centrinia> jadrian, generic inputs to @djinn are undecidable.
11:54:17 <centrinia> Cale, thanks. :)
11:54:18 <plumpkin> I want it to write all my functions for me :(
11:55:35 <centrinia> Is there a way to define two functions that perform those permutations on the arguments after the first?
11:55:53 <Cale> Well, there's a trivial way :P
11:55:59 <paper_cc> @type \f g -> (. g) . f
11:56:00 <lambdabot> forall b c a a1. (a1 -> b -> c) -> (a -> b) -> a1 -> a -> c
11:56:28 <b_jonas> centrinia: you can't make a vararg function so you can do it only for a fixed n
11:56:59 <plumpkin> not even with printf-like tricks?
11:57:00 <plumpkin> :(
11:57:02 <centrinia> Well, the cycle (1,2,3) should work.
11:57:09 <centrinia> The other cycle would be more difficult.
11:57:09 <Cale> Where by "can't" we mean you need to do lots of evil typeclass swindling to do it.
11:57:10 <paper_cc> plumpkin: no, there's a printf
11:57:21 <plumpkin> ?
11:57:26 <paper_cc> @ty printf
11:57:27 <lambdabot> forall r. (PrintfType r) => String -> r
11:57:31 <paper_cc> @index printf
11:57:31 <lambdabot> Text.Printf
11:57:33 <Cale> paper_cc: He's asking if the same trick applies ;)
11:57:58 <Cale> It might be harder to disambiguate the types here.
11:58:11 <Cale> You would probably have to give your cycle an explicit type.
11:58:14 <b_jonas> dunno but I don't care. if I want to handle permutations I'll just use lists. all the elts of a perm are of the same type so there's no wrappers so it's not as ugly as printf would be.
11:58:16 <centrinia> Well, the permutation functions will have type   (a -> ... -> a -> b) -> a -> ... -> a -> b
11:58:19 <plumpkin> ah
11:59:05 <centrinia> Any permutation of the arguments of the first argument can be obtained by suitable compositions of these two permutation functions. :)
11:59:17 <centrinia> It would be a generalization of flip. :)
11:59:23 <plumpkin> that'd be fun
11:59:31 <plumpkin> if only just to see if you can do it elegantly :P
11:59:39 <paper_cc> @pl \f z x y -> f x y z
11:59:40 <lambdabot> flip . (flip .)
11:59:55 <paper_cc> an unelegant way :(
12:00:07 <Cale> @pl \f a b c d e -> f e a b c d
12:00:07 <lambdabot> (((((flip .) . flip) .) . flip) .) . flip
12:01:11 * paper_cc remembers the (~>) trick for `on` generalization. it'd be great if someone invented something like this for flip...
12:01:30 <centrinia> Cale, flip and (.) require parentheses. Using those two generators will not require parentheses since the composition is associative.
12:02:25 <paper_cc> @ty let result = (.) in \f g -> result g . f
12:02:26 <lambdabot> forall b c a a1. (a1 -> a -> b) -> (b -> c) -> a1 -> a -> c
12:02:43 <paper_cc> @ty let result = (.) in \f g -> (result . result) g . f
12:02:45 <lambdabot> forall a b c a1 a2. (a2 -> a -> a1 -> b) -> (b -> c) -> a2 -> a -> a1 -> c
12:05:34 <Cale> centrinia: me?
12:05:37 <Cale> I know :)
12:10:40 <alinp> hi
12:10:52 <alinp> how can make a difference between types and type classes ?
12:10:58 <b_jonas> er what? doesn't that only work if you add an id to the end and define the generators as composition??
12:11:04 <b_jonas> ->centrina
12:11:15 <alinp> for instance, if I didn't know, how do you know if Num is a type class or a simple type ?
12:11:44 <Cale> Hmm, call a set of permutations S on a set X disconnected if there exists a partition (A,B) of X, and (U,V) of S such that all the permutations in U act on A and all the permutations in V act on B. Call it connected otherwise. I think that any connected set of 3-cycles whose union is {1,..,n} will generate A_n.
12:11:55 <Cale> alinp: Num is a typeclass.
12:12:00 <alinp> eg: someFunction :: Num -> Num
12:12:05 <alinp> this is not possible
12:12:06 <alinp> right ?
12:12:07 <Cale> alinp: right
12:12:08 <alinp> but
12:12:13 <Cale> alinp: It always occurs restricting a type variable
12:12:20 <Cale> (which is the purpose of type classes)
12:12:23 <alinp> someFunction :: Num a => a -> a
12:12:25 <alinp> this is ok
12:12:28 <Cale> yes
12:12:33 <alinp> and
12:12:39 <alinp> someFunction :: Int -> Int
12:12:44 <alinp> once again is ok
12:12:49 <Cale> yep
12:12:50 <alinp> so ... Int is a type
12:12:52 <Cale> yes
12:12:55 <alinp> Num is a typeclass
12:12:59 <Cale> That's right
12:13:19 <alinp> so, how can I make the difference between these 2 ? Int and Num
12:13:26 <alinp> how can I know which is which ?
12:13:37 <alinp> (I know which is which ... but if I didn't)
12:13:46 <Cale> You could :info Num from ghci
12:13:58 <Cale> Or look at how it's defined in the source code.
12:14:04 <MyCatVerbs> alinp: Int is a concrete, monomorphic, boring type. It represents a machine integer. Roughly, the size of your CPU's registers.
12:14:05 <alinp> oh, yes
12:14:10 <alinp> info is the trick
12:14:30 <alinp> MyCatVerbs: I know that
12:14:46 <jeltsch> MyCatVerbs: Not necessarily a machine integer.
12:15:03 <MyCatVerbs> alinp: (Num a) is a constraint that says that 'a' is some type upon which all the operations in the class "Num" are defined. As in, it's something that acts vaguely like a number.
12:15:18 <jeltsch> MyCatVerbs: I think, the only thing the Report says is that covers at least the range [-2^27+1..2^27-1].
12:15:29 <mle> > maxBound :: Int
12:15:30 <lambdabot>   9223372036854775807
12:15:31 <MyCatVerbs> jeltsch: yes it is. The H98 standard says it's signed, the width is implementation-defined, and it must be at least 29 bits wide. Three are allowed for tags.
12:15:59 <MyCatVerbs> jeltsch: that's a fixint, with some concessions given to possible implementation constraints.
12:16:41 <newsham> > log . fromIntegral $ (maxBound :: Int)
12:16:43 <lambdabot>   43.66827237527655
12:16:44 <jeltsch> MyCatVerbs: ‚ÄúImplementation defined‚Äù just means that it can vary from implementation to implementation. Not that it‚Äôs the native integer type of the respective machine.
12:16:49 <newsham> > log . fromIntegral $ (maxBound :: Int) / log 2
12:16:49 <alinp> MyCatVerbs: I thought that String is also a class
12:16:49 <lambdabot>       No instance for (Floating Int)
12:16:49 <lambdabot>        arising from a use of `log' at <i...
12:16:57 <alinp> but I saw that is a type
12:17:02 <Cale> > log (fromIntegral (maxBound :: Int)) / log 2
12:17:02 <jeltsch> MyCatVerbs: Of course, normally it is. But you cannot rely on it.
12:17:03 <lambdabot>   63.0
12:17:06 <alinp> :info from ghci is helping
12:17:10 <alinp> thanks guys
12:17:20 <newsham> > log (fromIntegral $ (maxBound :: Int)) / log 10
12:17:22 <lambdabot>   18.964889726830812
12:17:26 <Philonous> @hoogle Num
12:17:27 <lambdabot> Prelude class (Eq a, Show a) => Num a
12:17:27 <lambdabot> package numbers
12:17:27 <lambdabot> Data.Array.Base numElements :: (IArray a e, Ix i) => a i e -> Int
12:17:41 <centrinia> @let rot13 = join (liftM2 if' isAlpha (ap (ap ((chr .) . (. flip (13 +) 26) . (+)) . (-) . ord) (ord . flip (flip if' 'a' . isLower) 'A')))
12:17:42 <lambdabot>  <local>:2:21: Not in scope: `if''
12:17:42 <lambdabot>  
12:17:42 <lambdabot>  <local>:2:109: Not in scope: `if''
12:17:53 <Cale> > log 10 / log 2
12:17:54 <lambdabot>   3.3219280948873626
12:18:00 <Philonous> alinp: hoogle might be of further assistance if the class/type is part of a package on hackage
12:18:00 <centrinia> @let if' t a b = if t then a else b
12:18:01 <lambdabot>  Defined.
12:18:01 <Cale> 19 * 3.32
12:18:05 <centrinia> @let rot13 = join (liftM2 if' isAlpha (ap (ap ((chr .) . (. flip (13 +) 26) . (+)) . (-) . ord) (ord . flip (flip if' 'a' . isLower) 'A')))
12:18:05 <Cale> > 19 * 3.32
12:18:06 <lambdabot>  Couldn't match expected type `b -> Int' against inferred type `Int'
12:18:07 <lambdabot>   63.08
12:18:39 <newsham> the ole 10^3 aprox 2^10 trick
12:19:02 <alinp> Philonous: thanks, I know about hoogle
12:19:03 <newsham> > 10 / 3
12:19:03 <lambdabot>   3.3333333333333335
12:19:13 <MyCatVerbs> jeltsch: yes, yes you can rely on it. You can rely on it being at least just about wide enough, and you can rely on it being fast. This is why the H98 report calls it a fixint and not something random.
12:19:13 <alinp> 100000000000000000000000000 / 17
12:19:25 <alinp> > 100000000000000000000000000 / 17
12:19:26 <lambdabot>   5.882352941176471e24
12:19:35 <Cale> > 100000000000000000000000000 `div` 17
12:19:36 <lambdabot>   5882352941176470588235294
12:19:38 <MyCatVerbs> alinp: String is a type synonym for [Char]. You can make as many of those up as you feel like, should it please you.
12:20:03 <alinp> MyCatVerbs: yes, indeed
12:20:09 <centrinia> Well, (2^(10*n) - 10^(3*n)) / 2^(10*n) = 1 - (10^3/2^10)^n is not that significant.
12:20:24 <jeltsch> MyCatVerbs: What does ‚Äúwide enough‚Äù mean? Where does the report that Int is ‚Äúwide enough‚Äù?
12:21:12 <wli> 1 - 5^(3*n)/2^(7*n)
12:21:46 <wli> = 1 - (125/128)^n
12:21:57 <sbahra> jeltsch, same as C99 definition.
12:22:02 <sbahra> jeltsch, see section 6.4
12:22:08 <sbahra> jeltsch, of '98
12:25:41 <slukasser> Where is the difference between an algebraic data type and an abstrac data type?
12:25:43 <wli> = 1 - (1 - 3/128)^n = 1 - \sum_{k=0}^n \binom{n}{k} (3/128)^k = 1 - (3/128)*n - (3/128)^2*n*(n-1)/2 - (3/128)^3*n*(n-1)*(n-2)/6 + ... which bodes ill.
12:25:55 <b_jonas> slukasser: algebraic has constructors
12:26:00 <b_jonas> that you can pattern match to
12:26:23 <slukasser> hmm
12:26:35 <jeltsch> sbahra: Nothing about Int covering machine words in section 6.4, AFAICS.
12:26:46 <sbahra> No, there isn't.
12:26:57 <sbahra> I didn't imply it was.
12:27:14 <jeltsch> sbahra: But that‚Äôs what the discussion between MyCatVerbs and me was about.
12:27:43 <wli> Missing a -1 but anyway.
12:27:56 <sbahra> jeltsch, :)
12:27:57 <jeltsch> sbahra: MyCatVerbs claimed that Int represents a machine integer.
12:27:57 <ziman> i think the report requires Int to be at least 29 bits wide (or was it 28?)
12:28:20 <sbahra> jeltsch, according to the standard, it doesn't.
12:28:33 <sbahra> jeltsch, that is, not necessarily.
12:28:41 <tacotaco> im having some trouble using monads. anyone have a few?
12:29:04 <omnihil> The finite-precision integer type Int covers at least the range [ - 229, 229 - 1]. As Int is an instance of the Bounded class, maxBound and minBound can be used to determine the exact Int range defined by an implementation. seems pretty clear.
12:29:11 <jeltsch> sbahra: All I wanted to say is that, e.g., you cannot be sure that on a 64 bit plattform Int represents 64 integers.
12:29:27 <Saizan> tacotaco: any particular problem?
12:29:28 <centrinia> -229 and 228 are weird.
12:29:28 <tromp_> > maxBound:: Int
12:29:29 <lambdabot>   9223372036854775807
12:29:37 <tromp_> > 2^63-1
12:29:38 <lambdabot>   9223372036854775807
12:29:41 <jeltsch> sbahra: 64 bit integers, I meant, of course.
12:29:48 <tromp_> > maxBound:: Int32
12:29:48 <omnihil> centrina, that's -2^29 and 2^29-1. my copy/paste didn't get the exponents.
12:29:49 <lambdabot>   2147483647
12:30:01 <sbahra> > maxBound :: Int
12:30:02 <lambdabot>   9223372036854775807
12:30:23 <MyCatVerbs> jeltsch: "wide enough" is my own stupid informalism. The H98 report defines that Int is at least, oops, my bad, 30 bits unsigned. http://research.microsoft.com/en-us/um/people/simonpj/haskell98-revised/ grab the PDF, page 103.
12:30:28 <tacotaco> saizan: i want to use a case statement inside the do structure.  for example, do type1 <- typeof cntxt t
12:30:44 <tromp_> i would feel better if tag bits were kept out of ints
12:30:55 <tacotaco> where typeof returns either Raise String | Return Type
12:30:58 <snoobino> :t maxBound
12:30:59 <lambdabot> forall a. (Bounded a) => a
12:31:11 <jeltsch> tromp_: What do you mean with this? There is nothing said about Int‚Äôs representation.
12:31:25 <jeltsch> tromp_: It can use 2‚Äôs complement or whatever you want.
12:31:27 <tacotaco> what i want is to call a
12:31:28 <tacotaco> case type1 of
12:31:28 <tacotaco> (Return x) -> something
12:31:32 <MyCatVerbs> jeltsch: that is, however, wide enough for most practical purposes. If you need something wider, you're either doing crypto and should be using one of the explicitly sized Data.Word types, or your problem domain requires you to think about overflow and you should be using Integer.
12:32:03 <Cale> tacotaco: I am not sure that I understand what you are asking...
12:32:05 <jeltsch> MyCatVerbs: Of course.
12:32:08 <omnihil> the PDF at that url page 103 has an excepert from the Prelude. it doesn't have an Int type definition.
12:32:10 <tromp_> i want Int to guarantee a range of -2^31..2^31-1
12:32:10 <Cale> tacotaco: What's the type of typeof?
12:32:12 <MyCatVerbs> jeltsch: annoyingly, you are right in that a one's complement machine could well be considered compliant. Fortunately, no hardware company is crazy enough to build one's complement arithmetic. Thank Hell.
12:32:20 <omnihil> tromp, use Integer
12:32:21 <tromp_> rather than this 2^29 stuff
12:32:38 <tacotaco> typeof :: Gamma -> Term -> M Type, where M = Raise String | Return Type
12:32:42 <jeltsch> MyCatVerbs: Thank Hell? Hmm.
12:33:06 <Cale> tacotaco: Okay, and M happens to be a monad similar to the Either String monad.
12:33:09 <tromp_> is there a guarantee about the range of Int32?
12:33:12 <MyCatVerbs> tromp_: you can't. Import Data.Int and use Int32. Or, if you don't *want* overflow behavoir (surprisingly few problem domains do, IMO) use Integer.
12:33:25 <conal> @seen vincenz
12:33:25 <lambdabot> vincenz is in #haskell and #xmonad. I last heard vincenz speak 14h 9m 32s ago.
12:33:27 <tacotaco> Cale: yes, this is a small example for a school project
12:33:31 <jeltsch> tromp_: I think so.
12:33:34 <MyCatVerbs> tromp_: yes. Int8, Int16, Int32, Int64, are guaranteed to be of exactly those sizes, because they are explicitly sized.
12:33:37 <Cale> tacotaco: But you want to avoid using 'do' here for whatever reason.
12:34:00 <Cale> tacotaco: Note that if you write v <- x in a do-block and x :: M t, then v :: t
12:34:11 <tacotaco> Cale: we are supposed to be using  monads, to implement a small typechecker.
12:34:24 <MyCatVerbs> tromp_: if you were using a Haskell compiler targetting a hypothetical machine without 16-bit arithmetic support, the compiler would have to generate code to deliberately truncate in some cases in order to support it. :P
12:34:25 <tacotaco> Cale: ahhhhhh okay! that makes sense
12:34:39 <MyCatVerbs> tromp_: (er, I mean, if you were using Int16 on a...)
12:34:48 <Cale> Because it means to run x, and name its result v.
12:34:57 <tacotaco> Cale: let me see if i can work out with that stuff
12:35:07 <Cale> (whatever 'run' means for the given monad)
12:35:28 <tromp_> is there any haskell implementation using tag bits?
12:35:47 <tacotaco> Cale: making progress.  thanks for that pointer.
12:35:59 <Cale> tacotaco: I suspect that the most useful monad for a typechecker would be either the reader monad, to locally collect an environment of type constraints, or a state monad to do a similar job.
12:36:11 <Cale> (but less locally)
12:36:34 <dolio> You want errors, too.
12:36:45 <Cale> Well, yeah...
12:36:53 <MyCatVerbs> tromp_: not that I know of. But some historical Lisp implementations have done that. I believe the current implementation of OCaML does that, too. It's not unreasonable to think that a Haskell implementation might use the same techniques.
12:37:03 <tacotaco> our professor has some specifications we are supposed to adhere to.
12:37:07 <Cale> okay :)
12:37:15 <tacotaco> but thank you guys for the help. :D
12:37:29 <MyCatVerbs> tromp_: (though GHC does use pointer tagging for other, more nerfarious purposes. Like reducing branch misprediction overhead.)
12:37:34 <andrey_nado> hello haskell world!
12:37:40 <Cale> hello
12:37:49 <tromp_> at least pointer tagging doesnt shopw up in the languag spec
12:38:21 <Cale> I think Int should also not appear in the language spec, but that's just me :)
12:38:40 <tromp_> seeing -2^29..2^29 in a language spec is just ugly
12:38:46 <sbahra> :)
12:38:53 <Cale> Integer is good enough
12:38:56 <trofi> at least! :]
12:39:04 <b_jonas> Cale: heh
12:39:08 <MyCatVerbs> tromp_: AFAIK in practice, tagging integers isn't really necessary in Haskell anyway because always they're either boxed for laziness' and the garbage collectors' sakes, or they've been crushed into tiny little Int# by the glorious vicious compiler, and hence are passed around entirely in registers anyway.
12:39:13 <trofi> > (minBound, maxBound) :: (Int, Int)
12:39:14 <lambdabot>   (-9223372036854775808,9223372036854775807)
12:39:34 <trofi> they are sane on any sane implementation :]
12:39:56 <MyCatVerbs> tromp_: nah, not really. How else do you want to unambiguously define the minimum range of a numerical type?
12:40:08 <sbahra> > maxBound + minBound :: Int
12:40:10 <lambdabot>   -1
12:40:15 <Cale> MyCatVerbs: Don't set one?
12:40:47 <Cale> You could just leave that constraint out and say that the minimum Int value is minBound and the maximum is maxBound.
12:40:55 <MyCatVerbs> Cale: then Int would be allowed to have a width of one bit, and portable code would be required to assume that only the values 0 and -1 are safe to use.
12:41:07 <MyCatVerbs> (As Int literals, I mean.)
12:41:08 <Cale> It couldn't even assume that ;)
12:41:36 <dolio> Ints could be 0 bits!
12:41:40 <Cale> type Int = Void
12:41:49 <MyCatVerbs> No, Cale. You may have defined (.) as fmap, and that was a Good Thing, but you shall not be allowed to force us to use zero-bit-width integers.
12:41:50 <b_jonas> Cale: no, that woulnd't work
12:41:52 <mauke> even with 1 bit you can only assume 0 because two's complement isn't the only possibility
12:41:54 <tromp_> its not clear you have to specify a minimum range, but if you do, a 32 bit range wld be better than a 30bit one, since its not geared toward specific implementations
12:42:01 <b_jonas> Cale: () would though
12:42:10 <MyCatVerbs> tromp_: no, you have that backwards.
12:42:25 <b_jonas> tromp_: I agree with MyCatVerbs
12:42:31 <MyCatVerbs> tromp_: a 30 bit range which all implementations are allowed to exceed allows for implementations that do tag integers and implementations that do not tag integers.
12:42:47 <MyCatVerbs> tromp_: a 32 bit range allows only for implementations that do not tag integers.
12:42:54 <tromp_> right; and they disallow 3bit tags
12:42:57 <dolio> If the standard required 32 bit integers, then it'd be ruling out any implementation that uses tagging.
12:43:18 <b_jonas> tromp_: it disallows 3 bit tags of integers, it could still be that the tag has variable size
12:43:45 <MyCatVerbs> tromp_: that's just a mundane concession to practicality. It's very rare to find an implementation that actually uses two tag bits on integers.
12:43:52 <tromp_> a language spec shld not expose details of potential implementations
12:44:34 <wli> 16-bit systems may have trouble with 30-bit integers. ;)
12:44:50 <Cale> MyCatVerbs: Really though, I don't think Int should be in the spec at all.
12:44:54 <MyCatVerbs> wli: that's okay. Their address space wouldn't support Haskell's RAM-hungry data structures and thunks anyway.
12:45:13 <tromp_> agreed, Cale
12:45:16 <MyCatVerbs> Cale: that's a new one on me. Why not?
12:45:16 <wli> Even with nhc98?
12:45:48 <Philippa_> tromp_: there has to be something exposed here
12:45:51 <MyCatVerbs> wli: have you tried that, and had it work? If so, count me as impressed.
12:45:51 <Cale> MyCatVerbs: Because we have Integer, and it should always be the default. Int is a correctness-breaking premature optimisation.
12:45:54 <mauke> C demands 32-bit integers, so they have to deal with that first
12:45:55 <Philippa_> 30bit's a useful compromise
12:46:34 <wli> MyCatVerbs: nhc98 has very different space behavior from e.g. ghc.
12:46:51 <MyCatVerbs> mauke: er... no. The C standard defines an "int" as being at least sixteen bits wide, and signed.
12:46:54 <Cale> Int can be a library you can get from Hackage for all I care ;)
12:47:01 <MyCatVerbs> And the C standard gives an explicit numerical range, too. :P
12:47:02 <mauke> MyCatVerbs: yeah, but long ints are at least 32 bits wide
12:47:19 <MyCatVerbs> Yes... but that's a different type, mauke. :)
12:47:39 <dolio> Are long ints not in the C standard?
12:47:41 <sbahra> huh?
12:47:44 <mauke> it's not an optional type, so implementations have to support it :-)
12:48:14 <b_jonas> Cale: is your problem that Int is used in prelude things like length and fromEnum?
12:48:15 <MyCatVerbs> Cale: I'm mildly uncomfortable with the idea of all the Prelude functions returning numbers (length, splitAt, etc) being monomorphically defined on Integers, since those can't be unboxed.
12:48:17 <sbahra> dolio, they are.
12:48:20 <Cale> b_jonas: for one
12:48:25 * Badger prefers long long long ints.
12:48:35 <wli> Cae: For Haskell I think arbitrary precision should be the primary vehicle and limited precision types swept under the rug.
12:48:39 <b_jonas> Cale: I see, now that makes a bit of sense
12:48:39 <Cale> MyCatVerbs: I would have them be polymorphic.
12:48:45 <sbahra> wli, would be nice
12:48:47 <Cale> wli: Yes.
12:48:55 <MyCatVerbs> dolio: long ints *are* in the C standard. I misread mauke, and thought he said "C demands 32-bit ints, so...". Sorry.
12:48:58 <b_jonas> well, I'm not sure
12:49:03 <dolio> :)
12:49:13 <Cale> Optimisation is secondary. Elegance first.
12:49:42 <MyCatVerbs> Cale: I also like it when I don't have to wait around for my computer.
12:49:52 <wli> Cale: An arbitrary precision Natural type would help, too.
12:50:09 <vixey> efficient peano numbers?
12:50:10 <wli> Then again the numeric hierarchy is too screwed up to accommodate such.
12:50:18 <Cale> MyCatVerbs: But Integer really is quite practical, and if it's not sufficiently so, then we should work harder on its implementation.
12:50:21 <wli> vixey: Not Peano numbers at all.
12:50:45 <wli> vixey: Straight from gmp IIRC.
12:50:46 <Philippa_> wli: well, n+k patterns let you pretend they are
12:51:38 <wli> The "pretend and throw exceptions" model is the problem having an actual unsigned type is supposed to resolve.
12:52:23 <MyCatVerbs> Cale: I'm not with you on that one. Integers can't be squeezed into machine registers unless you can prove that the numbers that will be used will be strictly bounded, which is naturally infeasible.
12:52:37 <centrinia> Why don't we have Integer and dependent types such as (IntegersMod (2^32)) ?
12:52:52 <Cale> MyCatVerbs: Which is why Int exists, but not a reason for it to be in the standard.
12:53:19 <MyCatVerbs> Cale: sure, perhaps you could write specializations of all your Integer-passing functions for the case when the values fit within a register, but that seems like an awful lot of work to trade for a little elegance.
12:53:20 <Eridius> hey guys, how come '\xE9' doesn't get interpreted as the character for √©?
12:53:40 <Eridius> > '√©'
12:53:40 <lambdabot>   '\233'
12:53:46 <trofi> > '—ã'
12:53:47 <lambdabot>   '\1099'
12:53:55 <Eridius> hrm, that's right, but putStrLn '\xE9' shows as ? in my terminal
12:53:57 <Eridius> and my terminal is set to UTF-8
12:54:06 <mle> Eridius: the output isn't utf-8
12:54:09 <Eridius> ...oh
12:54:11 <Eridius> how do I fix that?
12:54:19 <trofi> import System.IO.UTF8
12:54:22 <MyCatVerbs> Cale: the other objection is that we're not talking about very *much* elegance being gained by using Integer everywhere, when the alternative is to just use Integral and make everyone import Data.Int.
12:54:30 <Eridius> what does it default input/output to?
12:54:38 <wli> Using Data.Int, Data.Word, and Data.Bits as a collective toilet for machine word -oriented bit twiddling efficiency hacks sounds fine to me.
12:54:50 <Cale> MyCatVerbs: Usually replacing Integer with Int will cause correctness to be lost. Maybe you don't actually care about those large cases, but when you suddenly do, it's a subtle problem.
12:55:03 <glguy> :t length
12:55:04 <lambdabot> forall a. [a] -> Int
12:55:13 <glguy> which pervasive use of Integer are we talking about?
12:55:34 <Cale> MyCatVerbs: Oh, whenever possible I would want things to be polymorphic of course.
12:55:38 <MyCatVerbs> Cale: but doing that *still* screws people who want to, say, write an implementation that puts a one-bit tag on its favourite fixint type. So IMO, Int stays. :P
12:55:48 <Cale> MyCatVerbs: huh?
12:56:08 <MyCatVerbs> Cale: removing Int and using Integer and explicitly-sized Ints exclusively instead.
12:56:08 <wli> glguy: Hoped for ones, not ones that actually exist now.
12:56:13 <Cale> MyCatVerbs: Why not just leave Int out of the standard altogether, and let implementations provide it as a library?
12:56:21 <Cale> (Implemented however they want)
12:56:50 <MyCatVerbs> Cale: because people will feel silly typing "import Data.Int" at the top of every module in order to get a normal fixint.
12:57:02 <Philippa_> MyCatVerbs: there's still occasional need for some flavour of "machine native int"
12:57:02 <Cale> Really?
12:57:07 <Cale> I wouldn't.
12:57:11 <seliopou> Cale: you can say that of just about any "built-in" type
12:57:27 <vixey> Cale, there are people that have trouble defining new combinators if they aren't already in a library..
12:57:41 <Philippa_> Cale: you wouldn't use it very often
12:57:49 <Cale> seliopou: Well, my argument is that Integer is good enough for almost all the tasks which you'd use Int for. We should discourage people from using Int a little.
12:57:57 <MyCatVerbs> seliopou: not all of them. Lists are practically a grand tradition for functional programming, and Maybe, Either and () are absolutely necessary if you want to wing polytypic programming in a dishonest and ad-hoc way.
12:58:10 <MyCatVerbs> Philippa_: that's what I'm whining about. :)
12:58:11 <seliopou> Cale: I could make a persuasive argument of the converse
12:58:23 <Cale> My view is that broken programs are worse than slow programs.
12:58:28 <dbelange> How do I get a monoid in Haskell?
12:58:45 <Cale> dbelange: Write an instance of the Monoid class from Data.Monoid
12:58:56 <Cale> dbelange: Or use one of the existing instances.
12:58:57 <seliopou> My view is that depends on what you're doing ;)
12:58:58 <wli> The performance of a program that crashes or produces incorrect outputs/effecs is 0.
12:59:12 <MyCatVerbs> dbelange: (Monoid m) is a constraint saying that 'm' is some type which mappend and mempty are defined on. There are several types that have Monoid instances. Does that help?
12:59:13 <dbelange> What if I want a monoid monad?
12:59:42 <Cale> dbelange: Writer?
13:00:14 <Cale> dbelange: Or do you mean the list (free monoid) monad?
13:00:36 <dbelange> Okay, what about a magma?
13:01:18 <MyCatVerbs> Haskell doesn't have a built-in typeclass for magmas. Apparently they don't come up often enough.
13:01:27 <Cale> dbelange: We don't have an existing class in the libraries. Magmas are not usually worth recognising as such, but if you really want to, it's easy enough to define a typeclass.
13:01:34 <wli> seliopou: In my vision the bit twiddling machine stuff would all still be around, just cordoned off in some module for those who want speed hacks at all costs etc.
13:01:36 <MyCatVerbs> You can always make one up. class (Magma m) where...
13:01:57 <Cale> MyCatVerbs: It's not that they don't come up often enough, it's that they don't have enough properties to be worth caring about.
13:02:09 <dbelange> Okay, what about Heyting algebras?
13:02:11 <Cale> You can usually just use (a -> a -> a)
13:02:19 <b_jonas> stupid question, but what is a magma?
13:02:30 <MyCatVerbs> Cale: magmas are monoids without the identity element, right? *refreshes memory*
13:02:34 <vixey> what about Heyting algebras?
13:02:35 <Cale> b_jonas: A set with a binary operator on it.
13:02:47 <b_jonas> MyCatVerbs: those are groups
13:02:50 <b_jonas> no wait
13:02:52 <b_jonas> semigroups
13:02:54 <b_jonas> sorry
13:02:54 <Cale> semigroups
13:03:01 <Cale> groups are nicer than monoids
13:03:05 <Cale> (they have inverses)
13:03:07 <MyCatVerbs> Yes. Semigroups are magmas where the binary operation is associative.
13:03:24 <wli> MyCatVerbs: Those would be semigroups. Magmas don't have associativity or cancellativity or anything else.
13:03:32 <MyCatVerbs> wli: that's... what I said.
13:03:34 <Cale> Heyting algebras... I don't know. Someone might have a library.
13:03:57 <b_jonas> Cale: they probably do. lots of that kind of thing is on hackage.
13:04:34 <MyCatVerbs> So: class (Magma m) where binop :: m -> m -> m -- no laws, no axioms.
13:04:59 <MyCatVerbs> That would have a lot of instances.
13:05:54 <wli> It'd be nice if there were some Eiffel-esque way to declare laws for classes.
13:06:32 <wli> I guess not all of them are easily expressible in the source language.
13:07:06 <Cale> Well, it's usually easy to express the laws... they're usually equational. It's just hard to enforce them.
13:07:29 <Eridius> hrm, there's no way to ask cabal to generate haddock documentation for an already-installed package without reinstalling it?
13:07:54 <Cale> Eridius: I don't think so. Reinstalling shouldn't be too bad though.
13:08:01 <Cale> Eridius: It should be cached.
13:08:01 <Eridius> yeah, it's just mildly irritating
13:08:21 <wli> Cale: Eiffel had a compiler flag where its declared invariants/etc. automatically got turned into assertions.
13:08:56 <seliopou> wli: sounds like contracts. There's actually contract work going on for Haskell
13:09:40 <greenrd> Any advice on implementing a multiple-readers/single-writer lock in Haskell? Is there already code for this?
13:09:43 <seliopou> wli: https://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm
13:09:48 <greenrd> I can't use STM because I need to do IO
13:10:05 <seliopou> the top paper is very nice to read
13:10:09 <Cale> greenrd: You need to do IO *inside* your transactions?
13:10:13 <wli> I'm not surprised people are looking at it, it's just special syntax.
13:10:16 <greenrd> Cale: yes
13:10:26 <MyCatVerbs> wli: Sounds like the quickest way to hack an equivalent in would be to specify QuickCheck properties that'd be instantiated for every instance of a typeclass.
13:10:39 <wli> MyCatVerbs: Yep.
13:10:45 <Cale> greenrd: Why not just return the IO you need to do from your transaction and do it immediately after?
13:11:02 <Cale> (Or does that make no sense?)
13:11:25 <MyCatVerbs> Oh that made sense. The question is whether it made sense to the intended recipient. :)
13:11:28 <greenrd> Cale: because the only purpose of the locking is to regulate access to a directory tree on disk
13:11:47 <MyCatVerbs> So is there any reason why you want to use STM there?
13:12:02 <greenrd> I don't want to use STM.
13:12:07 <Cale> greenrd: Okay, so you could just use an MVar ()
13:12:12 <greenrd> Right
13:12:14 <MyCatVerbs> Right. That's good, because it's not really appropriate.
13:12:18 <sbahra> Which doesn't allow handling multiple readers very well.
13:12:30 <MyCatVerbs> Haskell MVars can be used just like binary semaphores easily enough, and there's always Control.Concurrent.QSem.
13:12:31 <greenrd> Yes, I don't want writers to get starved.
13:12:33 <sbahra> greenrd, you could use a Chan of MVars.
13:12:44 <Eridius> hrm, anybody have an easy way to get `hoogle` to search my installed packages too?
13:12:55 <sbahra> greenrd, which guarantees FIFO behavior.
13:13:11 <MyCatVerbs> I would recommend grabbing a copy of the Little Book of Semaphores, and looking up how to implement a read-write lock using quantity semaphores. Then write the algorithm using QSems. Yay. ^_^
13:13:16 <wli> Most reader/writer primitives have some brief period of mutual exclusion to protect their own internals.
13:13:16 <jenner> just curious - why does an import statement (import IO e.g.) inject the functions defined in IO into top-level namespace of the importing module? I
13:13:31 <Cale> jenner: That's how it works, yes.
13:13:34 <Cale> jenner: Why?
13:13:40 <Cale> jenner: Because it's convenient.
13:13:51 <Gracenotes> it's not an issue until you define something with the same name
13:13:52 <jenner> Cale: that's namespace pollution imo
13:13:56 <BONUS> jenner: unlike, say, python, clashes can be resolved in compile time
13:13:56 <sbahra> wli, some longer than others :)
13:13:58 <goomba`> how do i pattern match on a list of alternatives? like what str == "1" || str == "2" would do in a boolean expressions.
13:13:59 <Gracenotes> and there two mechanisms to fix that: qualified and hiding
13:14:01 <MyCatVerbs> jenner: because it saves a lot of typing module names over and over. Haskell hackers took a page out of Unix and got lazy. Fortunately they never reached the stage of omitting random vowels.
13:14:06 <goomba`> particularly, using a case statement
13:14:12 <Cale> jenner: It's not pollution if you actually want the names in scope.
13:14:15 <BONUS> you can import qualified if you get name clashes
13:14:18 <greenrd> jenner: You can avoid it using import qualified, but we don't usually do that
13:14:23 <jenner> ok
13:14:31 <Cale> jenner: You can also import things qualified and even change the qualifying name.
13:14:36 <Gracenotes> import qualified System.IO as IO
13:14:44 <Gracenotes> then IO.ioFunc your args here
13:14:46 <MyCatVerbs> jenner: meh. Haskell has mechanisms for resolving namespace collisions nicely. If you don't want them to be brought into toplevel scope, import Foo qualified; or even import Foo qualified as Bar.
13:14:54 <Cale> You can also import only specific names from a module
13:14:59 <MyCatVerbs> Er, except put the "qualified" statement where Gracenotes said, not where I did.
13:14:59 <Cale> and you can combine these...
13:15:00 <b_jonas> MyCatVerbs: like fst/snd?
13:15:09 <jenner> yeah, but as a python coder I feel that qualified should be the same :) never mind, I was just curious
13:15:10 <Cale> import Data.Set (Set, empty)
13:15:19 <Cale> import qualified Data.Set as S
13:15:24 <wli> import qualified Data.Map as Map ; import qualified Data.Set as Set ; import qualified Data.List as List are my top 3 qualified imports.
13:15:26 <MyCatVerbs> b_jonas: nah. Those aren't the English words, contracted.
13:15:34 <b_jonas> MyCatVerbs: actually haskellers just spare the shortest names for the most general abstractions.
13:15:36 <MyCatVerbs> b_jonas: those are the English abbreviations, unmolested. =)
13:15:39 <Cale> wli: I never qualify Data.List
13:15:39 <greenrd> MyCatVerbs: Does the algorithm in the Little Book of Semaphores avoid writer starvation?
13:15:41 * sbahra uses single letters for some reason
13:15:42 <Gracenotes> do you believe in maaagic
13:15:47 <sbahra> import qualified Data.Map as M
13:15:48 <sbahra> etc...
13:15:54 <sbahra> Probably not a good thing.
13:16:09 <b_jonas> when we eventually find the ultimate abstraction that lets us write every program in an even more abstract way, we can put one-letter functions to the standard libraries.
13:16:18 <MyCatVerbs> greenrd: don't know, didn't bother to read that far. I suspect so, yes. It's well written and the author knows his stuff, so...
13:16:41 <jenner> import Prelude hiding(foldr) <- that sort of evolved from the fact, that import is unqualified by default
13:16:45 <MyCatVerbs> b_jonas: to one-up that: we won't be using letters at all.
13:16:48 <wli> Cale: I import Data.Set and Data.Map unqualified, too, and got tired of hiding half of Data.Map and Data.Set so I just import Data.List qualified to get map, filter, null, etc. on lists sans nameclashes.
13:16:59 <MyCatVerbs> b_jonas: witness Control.Arrow. It's already happening!
13:17:20 <Mark23> I have a binary tree and I need to tell if its balanced. What's the best way to do this?
13:17:31 * sbahra thinks all imports should be qualified :-P
13:17:44 <BONUS> Mark23: check the height of the left sub tree and the height of the right one
13:17:50 <b_jonas> MyCatVerbs: well, we'll have to use both letters and infixes, if you only use infixes you'll need too much parens, same if you use too much letters.
13:18:01 <Peaker> jenner: I agree with you, I think unqualified open imports are a misfeature
13:18:20 <jenner> Peaker: good to know I'm not alone :)
13:18:27 * sbahra likewise
13:18:27 <MyCatVerbs> b_jonas: I actually like Scheme, though. Parens have long since ceased to faze me.
13:18:56 <Cale> I think it'd be incredibly horrifyingly inconvenient to import everything qualified. Especially infix operators.
13:18:58 <Mark23> BONUS: would that be more efficient than figuring out the number of nodes in each and comparing them?
13:19:02 <sbahra> Cale, true.
13:19:09 <Mark23> also, did you write learnyouahaskell.com?
13:19:18 <BONUS> still writing it :]
13:19:23 <Mark23> It's great :)
13:19:27 <BONUS> thanks!
13:19:27 <Mark23> helped so much
13:19:31 <MyCatVerbs> Mark23: that's exactly what the weight is - the number of below a point in the tree.
13:19:34 <BONUS> well the number of nodes doesn't tell you much about the balanceness
13:19:37 <Eridius> Cale: can I put haddock-option in the .cabal/config file?
13:19:42 <wli> Open imports altogether, really. List what you import etc., be able to rename on a construct-by-construct basis, and so on.
13:19:51 <Peaker> jenner: but its also important to remember that names and namespaces are a syntactic, not semantic feature, and as such less important IMO :)
13:19:52 <Peaker> Cale: the choice isn't between all-qualified or what we have now, you can also have all-qualified-or-closed
13:19:53 <Cale> I can't personally imagine what kind of experience makes people think that importing everything qualified would be good... but I suppose some languages do it and people don't mind.
13:19:55 <Peaker> Cale: e.g: import Control.Applicative((<*>)) is allowed
13:19:56 <abbe> BONUS, I'm also one of learnyouahaskell.com reader, thanks for writing that :)
13:20:00 <Mark23> well see in my assignment i had to write a "size" function that figures out how many nodes are below a given node
13:20:05 <MyCatVerbs> Mark23: but you need to compare the weights at *every* branch to check.
13:20:06 <Peaker> Cale: but   import Control.Applicative is not
13:20:09 <BONUS> haha thanks guys, thats very nice to hear
13:20:16 <chowmeined> BONUS, <3
13:20:21 <sbahra> Hi abbe :)
13:20:22 <sjanssen> I think it's important to note that the largest open source Haskell project (GHC) explicitly prefers open non-qualified imports
13:20:26 <sbahra> Didn't see you.
13:20:34 <abbe> Hi sbahra :)
13:20:35 <BONUS> haha. you could keep track of how tall each tree is
13:20:43 <Mark23> so is there no way to work around visiting every node more than once?
13:20:49 <Eridius> hrm, apparently not
13:20:52 <Eridius> that's irritating
13:20:52 <Cale> Mark23: huh?
13:20:54 <Peaker> sjanssen: its so much harder to read code that way, unless you simply know the entire code base really well
13:20:54 <sjanssen> closed imports are a waste of programmer time
13:20:54 <c_wraith> you only need to visit each node once
13:21:00 <sbahra> sjanssen, why?
13:21:11 <BONUS> data Tree a = Tree a (Tree a) (Tree a) Int | Leaf, where Int is the height of the tree
13:21:15 <wli> Really it's all about the module system being effectively absent.
13:21:21 <c_wraith> It's a simple recursive traversal.
13:21:25 <Cale> Mark23: You should be able to construct a tree annotated with the sizes of its subtrees
13:21:25 <BONUS> and the height of Leaf is 1, by definition
13:21:27 <sjanssen> Peaker: use better tools
13:21:32 <MyCatVerbs> BONUS: I haven't done much more than skimmed it (YAHT casualty, a few steps up from the poor souls who had only the Gentle Introduction) but thanks for keeping Haskell crazy. =)
13:21:37 <Peaker> sjanssen: what tools do you use for this purpose?
13:21:54 <BONUS> hehe cool :D crazy = interesting, thats what i say
13:22:11 <sjanssen> Peaker: I don't really find it to be a problem.  grep or haddocks when I really need to know where an identifier comes from
13:22:16 <jenner> learnyouahaskell.com doesn't like me :(
13:22:28 <BONUS> jenner: why? :(
13:22:29 <Peaker> sjanssen: "use better tools" is a cop out when these better tools are hypothetical :)
13:22:31 * Cale bikesheds it up by demanding that the height of Leaf be 0.
13:22:40 <Botje> Cale: 0.5, surely.
13:22:48 <sjanssen> sbahra: the GHC team found that they spent lots of time rearranging imports when refactoring
13:22:49 <vixey> Cale, isn't 1 nicer?
13:22:52 <jenner> BONUS: Warning: include(404.php) [function.include]: failed to open stream: No such file or directory in /f1/content/learnyouahaskell/public/index.php on line 142
13:23:02 <vixey> (since it means that  height t = 0  is a contradiction)
13:23:02 <Cale> vixey: I would say only if Leaf took a parameter.
13:23:16 <sjanssen> Peaker: hasktags, Hoogle, Hayoo
13:23:20 <MyCatVerbs> Botje: y'know, AFAIK there *is* one place in the world where you can legitimately access the first element of an array with 0.5.
13:23:27 <BONUS> jenner: which URL specifically did you try to fetch that resulted in that error?
13:23:30 <Botje> perl?
13:23:34 <jenner> BONUS: index
13:23:51 <sbahra> jenner, http:// ... ?
13:24:01 <c_wraith> you don't even need to construct an annotated tree...  This can be done easily enough with a single recursive pass returning an Either type
13:24:05 <jenner> BONUS: ah, now it works, for some reason a '?' was at the end of the url
13:24:13 <BONUS> ah :]
13:24:19 <MyCatVerbs> Botje: not that I know of. But apparently, accessing pixels from textures when writing graphics shaders, well, you grab the first pixel by indexing its *centre* rather than one of its corners.
13:24:27 <sbahra> BONUS, PHP? :(
13:24:39 <jenner> "texas ranges" :)
13:24:39 <Botje> MyCatVerbs: heh. really? cool!
13:24:40 <Cale> Of course, if you really care about tree balance, you probably want to keep the tree annotated all the time.
13:24:41 <BONUS> yeah, i feel dirty about it but you know
13:24:54 <Botje> I should learn shaders, sometime.
13:24:55 <BONUS> all that the PHP does is include the pages into the main page template
13:25:03 <Botje> can't we write haskell on shaders yet?
13:25:04 <BONUS> the hosting had PHP already, so i went with that
13:25:15 <MyCatVerbs> Or possibly use a datatype that *only* allows complete trees, by the way that it is defined. :)
13:25:15 <Botje> MyCatVerbs: I was thinking of perl's $[ variable, which allows you to set the first array index
13:25:16 <c_wraith> of course, Mark23 is logged in from a .edu, meaning that he's asking us to do his homework.
13:25:18 <sbahra> You probably should hide those error messages. :-P
13:25:25 <sbahra> Use some error code instead or something.
13:25:27 <sbahra> Lots of information.
13:25:40 <BONUS> yeah hehe, thats somewhere on my todo list haha
13:25:41 <MyCatVerbs> Botje: oh dear, spooky action at a distance. I don't know.
13:25:44 <Botje> kaa% perl -le '$[ = 0.5; @a = qw(one two three); print $a[1.5]'
13:25:44 <Botje> two
13:26:00 <jenner> uh
13:26:09 <augustss> perl?
13:26:11 <MyCatVerbs> Botje: holy Hell. :(
13:26:15 <jenner> that's perl though, fuzzy logic, you know
13:26:32 <MyCatVerbs> Botje: you know, everybody always said lwall was mad. I've just never seen proof up 'til now.
13:26:38 <Eridius> huh, error message weirdness
13:26:49 <Botje> perl isn't too bad
13:27:06 <augustss> Larry is a fun character
13:27:07 <Botje> contexts sound crazy but are truly brilliant
13:27:10 <Eridius> > flip readFile
13:27:10 <lambdabot>   Couldn't match expected type `b -> c'
13:27:19 <Botje> i'm surprised there aren't more languages that use contexts
13:27:22 <Eridius> hrm, it truncated the error message. Still, it's weird that it's dropping the 'a ->' bit
13:28:15 <augustss> contexts sounds like some weak version of types
13:28:29 <Eridius> anybody know what causes atom sorting errors when linking? it's just a warning, but I have no idea what it means and I'd rather not have it
13:28:39 <augustss> I get them all the time
13:28:46 <augustss> tons and tons
13:29:05 <MyCatVerbs> Botje: ehhhh... well, Haskell has them. See QuickCheck, and Text.Printf. Both of which use clever typeclass constraints to behave appropriately according to context.
13:29:21 <Botje> i know :)
13:29:28 <Botje> but i was thinking more along the lines of really language design
13:29:44 <Botje> although using the typechecker to simulate contexts is decidedly awesome in my book, too
13:29:45 <wli> I thought contexts were just the sets of class constraints in qualified types.
13:30:07 <MyCatVerbs> Botje: I'm more comfortable with the idea of contexts being imposed via a beautiful type system hack than doing them Perl-style, all polymorphic-at-runtime, blargh.
13:30:22 <MyCatVerbs> s/blargh/aieeeeee/
13:30:35 <MyCatVerbs> Botje: even though the error messages you get are much, much worse.
13:30:45 <Botje> agreed :)
13:33:03 <Mark23> c_wraith: you mentioned above that I could do it with one recursive path using the either type - could you explain further?
13:35:50 <dons> bos: what's the status of epoll + haskell? any userland work?
13:45:46 <michaelcdever> hey, does forM have any performance decreases associated it?
13:46:09 <shockwave> Hello, I'm just starting with Haskell and I'm trying to print a string to the terminal. I tried: putStrLn "Something" -- but it doesn't work
13:46:17 <mauke> what do you mean by "doesn't work"?
13:46:22 <shockwave> I'm using GHC as the computer/parser
13:46:26 <shockwave> compiler*
13:47:10 <michaelcdever> are you in ghci shockwave?
13:47:21 <michaelcdever> or are you just trying this from the command line?
13:47:23 <shockwave> I hate the windows shell. I can't copy and paste for some reason. Basically, it says: parser error (possibly incorrect indentation)
13:47:34 <mauke> missing 'main = '
13:47:39 <pao> michaelcdever: have you got any problems with forM? you must be aware that it builds a list on "the background"
13:47:44 <shockwave> from command line, by calling the script directly
13:48:00 <shockwave> mauke, I'll try that.
13:48:25 <pao> > forM (print "foo") [1..3]
13:48:25 <lambdabot>   Couldn't match expected type `[a]' against inferred type `IO ()'
13:49:02 <pao> > forM (const . print $ "foo") [1..3]
13:49:03 <lambdabot>   Couldn't match expected type `[a]'
13:49:03 <michaelcdever> pao: no, no problems, i'm just using it atm to tidy up some code, 2 lines with forM as opposed to 16 with out, and was wondering would it have a negative effect on my code?
13:49:17 <mauke> michaelcdever: depends on what you're doing with it
13:49:20 <michaelcdever>  forM [1..3] (print "foo")
13:49:25 <shockwave> mauke, that looks like a good start. It doesn't have syntax error, but the string didn't print.
13:49:27 <michaelcdever> >  forM [1..3] (print "foo")
13:49:28 <lambdabot>   Couldn't match expected type `t -> m b'
13:49:46 <michaelcdever> >  forM [1..3] $ \_ (print "foo")
13:49:47 <lambdabot>   <no location info>: Parse error in pattern
13:49:56 <michaelcdever> >  forM [1..3] $ \_ -> (print "foo")
13:49:56 <mauke> shockwave: how did you run it?
13:49:57 <lambdabot>   * Exception: "<IO [()]>"
13:50:12 <pao> michaelcdever: the only, naive advice I can give you is to check if forM_ works in your case and use that (if you are not interested in the result of forM)
13:50:26 <shockwave> mauke, by typing the full path of to the file in cmd.exe
13:50:32 <michaelcdever> gives up. whats the difference pao?
13:50:34 <mauke> shockwave: what file?
13:50:47 <shockwave> mauke, The script file, .hs
13:50:53 <mauke> wtf?
13:50:58 <mauke> .hs is not a "script file"
13:51:15 <pao> michaelcdever: look at this lambdabot session
13:51:22 <pao> > forM [1..3] (\_ -> print "foo")
13:51:23 <lambdabot>   * Exception: "<IO [()]>"
13:51:49 <b_jonas> > print "foo"
13:51:50 <lambdabot>   * Exception: "<IO ()>"
13:51:57 <shockwave> mauke, I have registered GHC to handle file extensions with the '.hs.' extension. So, if I type the full path to any file, ending with the extension .hs, GHC will execute it. Get it?
13:52:10 <pao> > forM_ [1..3] (\_ -> print "foo")
13:52:11 <lambdabot>   * Exception: "<IO ()>"
13:52:14 <mauke> shockwave: no, ghc does not execute .hs file. get it?
13:52:18 <mauke> er, *files
13:52:28 <pao> michaelcdever: try both in ghci
13:52:59 <shockwave> mauke, I did it in the past, somehow. It it possible to do, or did I dream that?
13:53:01 <michaelcdever> ah ok, gotcha pao.
13:53:09 <mauke> shockwave: did you mean 'runghc'?
13:53:18 <mauke> because ghc itself will just compile the file
13:53:26 <shockwave> mauke, that was probably it. Let me try that.
13:53:28 <mauke> (you might have an 'a.exe' lying around now)
13:53:52 <shockwave> Yep, that was it. Thanks.
13:54:26 <shockwave> Obviously, I come from an imperative language background. This is like Japanese to me (and I'm not Japanese).
13:54:32 <shockwave> But it looks so sexy.
13:54:39 <mauke> do you know C?
13:54:43 <b_jonas> no, it's ruby that's japanese
13:54:43 <jenner> guys, is there a way to enable a decent readline support for ghci? the one that would e.g. (like in bash in emacs mode) delete one word at a time when CTRL+W is pressed?
13:54:46 <shockwave> mauke, amount others.
13:54:47 <michaelcdever> pao: so forM_ doesn't build up a list in the background
13:55:05 <c_wraith> Heh.  I'd love readline in ghci, too.  CTRL-R is awesome
13:55:23 <pao> michaelcdever: yep... forM_ doesn't collect the results of its "body"
13:55:23 <mauke> shockwave: because my development style with Haskell is more C like; i.e. I edit files, compile, and link them
13:55:32 <mauke> no "scripting"
13:55:40 <b_jonas> jenner: there was a trick for compiling it that way
13:55:41 <michaelcdever> pao: there by being quicker! deadly!
13:55:46 <b_jonas> jenner: are you compiling it from source?
13:55:55 <mauke> jenner: which version of ghc?
13:56:06 <jenner> b_jonas: no, I would though if I'd know the flags :)
13:56:10 <pejo> jenner, ghci-haskeline works for now.
13:56:11 <pao> michaelcdever: if the iteration is lengthy, and you don't need the final result... forM is overkill
13:56:21 <jenner> mauke: 6.10.1
13:56:31 <michaelcdever> ok cool, thanks pao!
13:56:31 <shockwave> mauke, at some point I will be doing that as well. I would like to implement some server stuff with Haskell for a project of mine. But until I get a good grasp of it, it's just more effecient for me to make quick edits and run it.
13:56:36 <pao> michaelcdever: np :-)
13:56:51 <pao> @src forM
13:56:51 <lambdabot> forM = flip mapM
13:56:55 <pao> @src forM_
13:56:55 <lambdabot> forM_ = flip mapM_
13:57:01 <mauke> shockwave: in that case, why not leave ghci open so you can try stuff interactively?
13:57:04 <jenner> pejo: ghci-haskeline?
13:57:06 <pao> @src mapM
13:57:06 <lambdabot> mapM f as = sequence (map f as)
13:57:11 <pao> @src mapM_
13:57:11 <lambdabot> mapM_ f as = sequence_ (map f as)
13:57:38 <pejo> @hackage ghci-haskeline
13:57:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghci-haskeline
13:57:44 <jenner> thnx
13:57:47 <shockwave> mauke, because I want to be creating scripts while I learn it. This way, I can put comments on it, commit it to source control, and sort of have a log as I learn.
13:57:56 <offender> hi everyone
13:58:06 <mauke> shockwave: sure, but you can still load the file into ghci and play around with it
13:58:07 <offender> i would like to discuss  about robert mugabe
13:58:24 <Heffalump> offender: not here
13:58:27 --- mode: ChanServ set +o mauke
13:58:34 <Gracenotes> did he donate ten billion Zimbabwean dollars to the development of Haskell or something?
13:59:02 <offender> robert mugabe is great and handsome leader of oppressed people and muslims!! he will bring down american tyranny!
13:59:06 --- kick: offender was kicked by mauke (mauke)
13:59:06 --- mode: mauke set +b *!*@host-212-149-240-71.kpylaajakaista.net
13:59:14 * Gracenotes will take that as a no
13:59:19 <LeoD> lolwut
13:59:24 <jenner> rofl
13:59:51 <shockwave> mauke: I could, but I'm just so used to doing it this way for other languages. I know Haskell is not those other languages, but I think it will be easier for me if I try keep doing a few of the things that work for me, so that everything is not completely new.
13:59:55 <BMeph> Chciken & ROFLs
14:00:03 <mauke> shockwave: ok :-)
14:00:05 <kerlo> @type iterate
14:00:07 <lambdabot> forall a. (a -> a) -> a -> [a]
14:00:08 <Itkovian> mauke: nice shot.
14:00:38 <shockwave> mauke, I'll keep the sudgestion in mind. I'm sure as I get more confortable, I'll be making use of it.
14:01:06 --- mode: mauke set -o mauke
14:01:36 <Gracenotes> so today my Java professor introduced SML to students as a means of having them comprehend recursion
14:01:53 <Gracenotes> the only problem being that all the examples he gave could have been solved just as easily with iteration
14:02:01 <mauke> :facepalm:
14:02:12 <shockwave> mauke: BTW, I'll probably be asking really noob, possibly stupid, questions for the next hour or so, while I go over some tutorials. Please, don't feel bad about ignoring me at any point.
14:02:20 <mauke> shockwave: hey, no problem
14:02:36 <shockwave> mauke: Thanks.
14:02:37 <kerlo> > let dropCount n f (x:xs) | f x = dropCount (n+1) f xs; dropCount n _ _ = n in dropCount 0 (=='a') "aaaap"
14:02:38 <Gracenotes> hopefully we'll be working with trees tomorrow. We started in on lists, and recursion with lists can be elegant
14:02:39 <lambdabot>   4
14:02:42 <mauke> shockwave: you sound sane and at least a bit intelligent :-)
14:03:15 <kerlo> > let dropCount n f (x:xs) | f x = dropCount (n+1) f xs; dropCount n _ _ = n in dropCount 0 (> 0) (iterate (\x -> x*1.005 - 2000) 80000)
14:03:17 <lambdabot>   45
14:03:25 <shockwave> mauke: You're giving me too much credit. I'm not that sane, or intelligent. But thanks.
14:04:43 <shockwave> So I take it that a file that will be run from GHC needs to have main function defined, similar to C/C++ programs, so that it can serve as an entry point?
14:05:00 <mauke> yes, execution starts at Main.main
14:05:13 <mauke> (or rather, execution *is* Main.main :-)
14:05:25 <shockwave> Module Main, function main. Got it.
14:05:56 <mauke> a module declaration is optional. it defaults to 'module Main (main) where ...' IIRC
14:06:30 <shockwave> ooh, "execution *is* Main.main". That sounds advanced. Once i'll understand what that means, I'll know I'm making progress.
14:06:50 <wli> Let's leave -main-is for later.
14:06:54 <shockwave> BTW, this is the tutorial I'll be trying to complete: http://www.hvergi.net/2008/06/parsing-json-with-haskell/
14:07:00 <shockwave> It looks well commented.
14:07:05 <omnihil> shockwave, execution is just evaluation of functions. it's not execution of a set of actions.
14:07:14 <mauke> omnihil: :/
14:07:15 <omnihil> so evaluating Main.main is your program
14:07:36 <mauke> here's my take on the purity/IO thing: http://mauke.ath.cx/stuff/haskell/how-to-io.html
14:08:09 <shockwave> omnihil: That has to something to do with the fact that once you define something, like: let i = 5 -- it is defined for good?
14:09:10 --- mode: ChanServ set +o mauke
14:09:11 --- mode: mauke set -b *!*@host-212-149-240-71.kpylaajakaista.net
14:09:24 <omnihil> shockwave, more like you're defining functions and objects and not actual actions to take. you can do let i = [1..] and haskell will not enter an infinite loop
14:09:38 <shockwave> mauke, thanks for the link. I'll definetly be going through that tutorial.
14:11:10 --- mode: mauke set -o mauke
14:11:33 <travisbrady> anyone know of a Haskell equivalent to Python's optparse?
14:12:01 <mauke> I don't know python but http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
14:12:32 <wli> I'm curious as to how that has anything to do with consoles.
14:12:51 <travisbrady> mauke: thanks
14:15:18 <Taejo> @faq Can Haskell become self-aware?
14:15:18 <lambdabot> The answer is: Yes! Haskell can do that.
14:15:26 <BMeph> jeltsch: ping
14:15:30 <Axman6> @quote lambdabot
14:15:31 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
14:15:56 <Axman6> @quote lambdabot
14:15:56 <lambdabot> lambdabot says: Nobody brings small problems into a laundromat.
14:18:37 <jeltsch> BMeph: pong
14:20:23 <BMeph> jeltsch: Are you hosting your algebra package somewhere, or is its only existence on hackage? :)
14:21:22 <jeltsch> BMeph: Hmm, the  package description still lists the softbase.org address, doesn‚Äôt it?
14:21:55 <jeltsch> BMeph: It‚Äôs now on http://community.haskell.org/~jeltsch/algebra/.
14:21:57 <BMeph> jeltsch: Correct.
14:22:57 <shockwave> How can I create multiline comments in Haskell? C++ equivant of /* ... */
14:23:02 <BMeph> jeltsch: Ah, I'll peruse there - would you please edit your hackage entry for it? :)
14:23:09 <vixey> {- ... -}
14:23:39 <shockwave> vixey, thanks.
14:23:40 <Gracenotes> {-.-}
14:23:40 <m0nkfish> {- _ -}
14:23:42 <m0nkfish> lol
14:24:01 <Axman6> {- o -}
14:24:13 <m0nkfish> {O________O}
14:24:15 <m0nkfish> wait
14:24:18 <jeltsch> BMeph: Hackage entries cannot be edited, to my knowledge. The pages are generated from the .cabal files.
14:24:29 <jeltsch> BMeph: These can only change with a new version.
14:24:40 <jeltsch> BMeph: The .cabal file is already updated in the repository.
14:24:52 <jeltsch> BMeph: So the next release of algebra will have the correct link.
14:26:15 <jeltsch> BMeph: Maybe I should just make a minor release for the hyperlink to be correct.
14:26:33 <BMeph> jeltsch: Then I  humbly await the next release. Will the fraction module have any changes?
14:27:11 <BMeph> jeltsch: Isn't that the purpose for having minor versioning? :)
14:29:07 <jenner> so if I define a datatype the number and order of type params in the type itself doesn't really matter much, the constructor is the one that matters, right?
14:29:23 <mauke> for the contents of values? yes
14:29:41 <mauke> data T a b c = FooledYou
14:30:08 <jenner> like `data Foo abc = FooConstr a c c b a a b b b' is perfectly valid, "a b c" are only there, so the compiler knows that we're talking about three deifferent types?
14:30:34 <jeltsch> BMeph: The next release: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/algebra :-D
14:30:44 <mauke> jenner: yes
14:30:49 <jenner> yipie
14:31:09 <Gracenotes> > let (^.^) = (.) in let (.) = (^.^ (:[])) ^.^ (:) in do {0 . 0}
14:31:11 <lambdabot>   [0,0]
14:31:11 <jeltsch> BMeph: The Data.Fraction module is in the fraction package. This package had a new release today.
14:31:19 <Gracenotes> [0,0]
14:31:35 <jenner> anime-haskell?
14:31:38 <jeltsch> BMeph: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fraction
14:31:41 <Gracenotes> ^.^
14:32:33 <jeltsch> BMeph: Are you checking Grapefruit at the moment?
14:33:50 <michaelcdever> does writeFile (System.IO) overwrite the contents of a file?
14:33:50 <BMeph> jeltsch: Not yet - should I? :)
14:34:28 <mauke> michaelcdever: yes
14:34:53 <mauke> O_WRONLY | O_TRUNC | O_CREAT
14:34:59 <jeltsch> BMeph: You were checking Grapefruit‚Äôs dependencies (algebra and fraction), so I thought you were looking at Grapefruit.
14:35:23 <michaelcdever> ok, cheers mauke
14:37:28 <BMeph> jeltsch: Oh, is that what fraction is for? I've just been looking for number reps, and 'fraction' was on the new releases page.
14:37:50 <BMeph> mauke: O_RLY? ;)
14:38:00 <mauke> open("/dev/owl", O_RLY)
14:39:27 <jeltsch> BMeph: I introduced Data.Fraction for using it in Grapefruit but put it in a separate package since it could be of general use.
14:39:51 <jeltsch> BMeph: A fractions is basically a number between 0 and 1. Or a percentage.
14:39:56 <BMeph> mauke FTW!
14:40:06 <shockwave> Alright, I tried a few different way of creating a string so that I can print it, and after reading a few websites I still can't do it. How do I create a literal string and then print it?
14:40:19 <shockwave> Currently, I have: let msg = "Hello, World!"
14:40:20 <mauke> putStr "I am a string"
14:40:28 <shockwave> But I know I have to define the type.
14:40:32 <mauke> no, you don't
14:40:40 <shockwave> err :/
14:40:43 <jeltsch> BMeph: Currently, I use fractions for specifying the ‚Äúlenght‚Äù of a progress bar and the red, green and blue intensities of colors.
14:40:45 <mauke> the compiler knows the type of everything anyway
14:40:54 <Cale> putStr and putStrLn should do it fine, no?
14:41:04 <mauke> let msg = "Hello, World!" in putStrLn msg
14:42:07 <Cale> :t putStrLn
14:42:08 <lambdabot> String -> IO ()
14:42:28 <shockwave> mauke: Ok, that work. How can I also make it so that I can print the string on another line.
14:42:37 <shockwave> works*
14:42:42 <mauke> hmm?
14:42:44 <Cale> putStrLn will add a newline after
14:42:54 <mauke> just output newlines
14:42:58 <michaelcdever> shockwave: putStrLN ( msg ++ "\n" )
14:43:10 <michaelcdever> *Ln
14:43:19 <shockwave> I tried: let msg = "Hello, World!" -- Then, in a new line, I typed: putStrLen msg
14:43:29 <mauke> wait, in a file?
14:43:29 <Cale> shockwave: In ghci?
14:43:38 <shockwave> mauke, yep
14:43:43 <mauke> in a do block?
14:44:00 <Cale> In a file, you'd just write  msg = "Hello, World", and then define, say,  main = putStrLn msg
14:44:03 <shockwave> mauke, next lines right after main =
14:44:07 <mauke> that won't work
14:44:11 <Cale> Or:
14:44:22 <mauke> if you're not in a do-block, you need an "in" after "let"
14:44:26 <Cale> main = let msg = "Hello, World!" in putStrLn msg
14:44:39 <Cale> Or:
14:44:44 <Cale> main = putStrLn msg
14:44:50 <Cale>   where msg = "Hello, World!"
14:45:09 <Cale> Or:
14:45:19 <Cale> main = do let msg = "Hello, World!"
14:45:27 <Cale>           putStrLn msg
14:45:36 <mauke> (warning: indentation matters if you use 'do' that way)
14:46:23 <Cale> Or you can even make the definition toplevel:
14:46:31 <shockwave> http://rafb.net/p/CEcDTX45.html
14:46:32 <Cale> msg = "Hello, World!"
14:46:37 <Cale> main = putStrLn msg
14:46:37 <shockwave> That's essentially what I have.
14:47:09 <mauke> holy imports, batman
14:47:20 <mauke> shockwave: change line 19 to 'main = do'
14:47:43 <shockwave> I see you guys/gals always place something after: main = -- That's not mandatory, right, because I was able to: putStrLn "hello" -- in the next line with having anything after: main =
14:47:43 <Cale> shockwave: First of all, configure your editor *not* to use tabs.
14:48:15 <mauke> shockwave: whitespace doesn't matter except when it does
14:48:16 <Cale> Tabs are pure evil, and will cause you nothing but pain if you use them.
14:48:28 <shockwave> I'll do it just for you, Cale.
14:48:32 <Cale> The reason is that exact indentation levels matter :)
14:48:53 <Cale> The compiler will always treat a tab as aligning to the next 8-space boundary.
14:49:01 <mauke> your current code parses as: main = let msg = "The message" putStrLn msg EOF?? WTF
14:49:12 <shockwave> (know, I just need to figure out how to convert tabs to chars in Vim)
14:49:17 <mauke> :set et
14:49:19 <Cale> :set expandtab
14:49:19 <mauke> :retab!
14:49:35 <jenner> :set ts=4 sts=4 sw=4 et
14:49:39 <Cale> and maybe :set smarttab as well
14:49:57 <Cale> (you can do this without the : in your .vimrc)
14:50:08 <mauke> also, :set ai
14:51:00 <shockwave> Cale, I'm currently using gVim, on windows. I'm sure there's some config file in there some where, but at first glance, I didn't see it.
14:51:15 <shockwave> I don't know what ':set ai' does, but I did that too.
14:51:19 <mauke> :h vimrc
14:51:25 <mauke> :h 'ai
14:51:57 <shockwave> the good 'ol RTFM
14:52:02 <shockwave> classic
14:52:25 <mauke> except a bit more specific :-)
14:52:41 <jenner> letmegooglethatforyou.com :)
14:52:46 <shockwave> mauke, true.
14:53:29 <shockwave> Ok, so the simplest change that I added to the paste I had was to add the 'do' keyword after: main =
14:53:41 <jenner> shockwave: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf that's one helluva tutorial, read it
14:54:09 * jenner is at page 51 currently
14:54:21 <shockwave> mauke: On a quick glance over your tut, I saw something about do's, some time agoin.
14:55:01 <luite> wow all advanced techniques on one page :)
14:55:08 <Cale> shockwave: Basically, do-blocks glue together simpler actions into more complicated ones.
14:56:51 <shockwave> You know, guys, I thought that I would be able to learn Haskell while following some practical tutorials. But I'm quickly finding  out that Haskell is trully a different language than the ole curly brace ones.
14:56:58 <Cale> shockwave: Each line of the do-block is either an action on its own (which means to run that action), something of the form v <- x where v is a variable and x is an action (which means give the name v to the result of running x), or let <some declarations>, which makes the declarations available in the rest of the do-block.
14:57:12 <boegel> yo
14:57:36 <Cale> shockwave: It's perhaps best to treat it as if it were your first ;)
14:57:59 <ddarius> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
14:58:03 <shockwave> I see that I'm gonna have to read some really basic introductions in order to accomodate appropriately.
14:58:16 <boegel> has anyone in here ever used Haskell to program a Microchip PIC embedded processor?
14:58:16 <Cale> Have you tried learnyouahaskell?
14:58:19 <shockwave> Cale, thanks for the explanations.
14:58:40 <Cale> shockwave: you might like http://www.haskell.org/haskellwiki/Introduction_to_IO
14:58:41 <shockwave> Cale: No, I havent.
14:58:46 <ddarius> boegel: Not directly.  I'm fairly confident it has been done indirectly.
14:58:56 <mauke> @where lyah
14:58:57 <lambdabot> www.learnyouahaskell.com
14:59:02 <Cale> shockwave: It's just a quick tutorial which should get you thinking in the right way about IO in Haskell.
14:59:15 <Cale> and yeah, LYAH is a good beginner tutorial :)
14:59:18 <erso> LYAH gets your feet wet nicely
14:59:28 <erso> Real World Haskell has a bit more meat
14:59:40 <Cale> @where rwh
14:59:41 <lambdabot> is http://www.realworldhaskell.org/blog/
15:02:01 <shockwave> I read the first three (I think) chapters of "Real World Haskell", published by O'Reilly, a couple of months ago. I stopped practicing in between because I was concentrating on work stuff.
15:03:01 <shockwave> I'm going through that LYAH tutorials, they look nice.
15:03:44 <shockwave> I'll do a couple of test prints and see if the examples on black backgrounds don't suck the life out of the printers' ink.
15:03:49 <Gracenotes> i needs mah LYAH update nao
15:03:51 <Gracenotes> :3
15:04:28 <BONUS> its coming! really soon! i pinky promise!
15:04:29 <shockwave> jenner also linked to a pdf book. Those are usually friendly to printers.
15:04:56 <BONUS> shockwave: yeah there's a pdf version of the content that's in LYAH so far, you can find it in the faq
15:05:03 * Gracenotes huegls BONUS
15:05:09 <BONUS> :3
15:05:18 <mauke> œâÃà
15:05:39 <ddarius> Œµ
15:05:52 <mauke> Œµ:
15:06:06 <leimy> @users
15:06:06 <lambdabot> Maximum users seen in #haskell: 658, currently: 635 (96.5%), active: 26 (4.1%)
15:06:16 <leimy> Oh it's been higher than 658 before
15:06:26 <shockwave> BONUS, Nice!
15:07:15 <BONUS> also yeah, the author of LYAH heartily recommends RWH, LYAH is kind of there so you can start exploring haskell without getting confused
15:07:54 * shockwave heads over to the printer for the first 9 pages
15:08:07 <jenner> shockwave: I'd read the pdf tutorial on screen since there are some exercises too
15:08:09 <ddarius> Why would RWH confuse you and how does LYAH avoid it?
15:08:17 <Botje> people still print stuff?
15:08:25 <boegel> ddarius: you mena by using -fvia-C or something? any references?
15:08:33 <conal> ChilliX_: ping
15:09:24 <BONUS> ddarius: mostly lack of colorful pictures :)
15:09:26 <ddarius> boegel: No, I mean more by generating C/assembly/whatever using Haskell.
15:09:36 <zakwilson> If I already have some FP experience, but don't know Haskell syntax or properly understand what a monad is, is LYAH a good start?
15:09:51 <Botje> it's a bit slow
15:09:59 <BONUS> zakwilson: try it, although it might be a bit too basic and slow for you yeah
15:10:01 <BONUS> if you already know FP
15:10:03 <Botje> but the examples will show you the syntax
15:10:10 <boegel> ddarius: generating assembly directly from Haskell?
15:10:18 <boegel> ddarius: GHC has support for PIC?
15:10:18 <Botje> and you can read some more about the crunchy bits
15:10:26 <zakwilson> I'm also not very used to static typing.
15:10:28 <shockwave> jenner, I know. Currently, I'm working about 75 hours per week in front of the computer, so reading non-light-emitting words is a good thing for me :-)
15:10:41 <Cale> zakwilson: It shouldn't be bad... you could try haskell.org/tutorial if you want something at a breakneck pace... I can only imagine that "Gentle" in the title is intended to be ironic.
15:11:03 <BONUS> you can also just skip my long-winded rambling paragraphs and just concentrate on the code examples for syntax
15:11:04 <Botje> I think the gentle refers to "gentler than the C programmer's introduction to haskell"
15:11:50 <ddarius> boegel: I'm talking EDSL type things.  As far as I know, no Haskell implementation's run-time would come remotely close to fitting on a PIC.
15:12:20 <boegel> ddarius: hmmk
15:12:22 <zakwilson> I'll spend a little time with both then and see. Thanks Cale and BONUS.
15:12:33 <boegel> ddarius: I know little about these things
15:12:34 <Cale> zakwilson: There's also RWH
15:12:48 <BONUS> np
15:12:52 <Cale> zakwilson: The full text of which is available freely online
15:12:59 <boegel> ddarius: just seemed cool to me to implement the algorithm my SumoBot will be using in Haskell ;-)
15:13:35 <zakwilson> I started wondering if I should read one text... and ended up with three!
15:13:44 <ddarius> boegel: Just do what most people do and make an EDSL and a small/simple compiler.
15:13:58 <BONUS> better get busy or we'll throw some more of them your way, haha
15:14:35 <boegel> ddarius: or I could use C, and the C compiler that is available... or just go with assembly for efficiency :)
15:14:36 <zakwilson> I've actually heard of all three before. I was drawn to LYAH because I found the style amusing.
15:15:01 <BONUS> i'm in a dilemma: should i even explain about handling and throwing exceptions from pure code?
15:15:14 <BONUS> on the one hand it's a part of haskell that people can use, on the other i consider it to be bad practice
15:15:26 <ddarius> boegel: Actually, using Haskell as an EDSL and very aggressively optimizing it, you could probably produce more efficient code faster than you could with assembly.
15:15:37 <ddarius> s/as an/and an/
15:15:55 <zakwilson> BONUS: If you're trying to make a comprehensive tutorial, you probably should, and say that you recommend against it.
15:16:21 <BONUS> yeah that's one argument
15:16:40 <Cale> BONUS: I wouldn't talk about catching them except in some more advanced chapter.
15:16:58 <zakwilson> The reason being that people may encounter it in code they're reading and go back to your text as a reference.
15:17:01 <Cale> BONUS: You can explain that error is to be used for conditions where you wouldn't mind the whole program dying.
15:17:09 <BONUS> hmm
15:17:14 <BMeph> Is making an MArray with the Identity monad, legal?
15:17:24 <ddarius> boegel: If you are interested in this general area you could look at the papers on embedded/real-time FRP.
15:17:41 <BONUS> that's a good middle ground yeah
15:17:43 <ddarius> boegel: Unfortunately, I don't think they were taken anywhere.
15:17:43 <glguy> put catching async exceptions next to unsafePerformIO
15:17:49 <boegel> ddarius: if I only had time... but thanks for the suggestions, I'll keep it in mind
15:17:55 <BONUS> haha
15:17:57 <byorgey> BMeph: does that even work?
15:18:00 <boegel> ddarius: taken?
15:18:12 <Cale> (as opposed to say, just failing to match a pattern)
15:18:38 <ddarius> boegel: On a completely different tack, there's a language called Virgil that illustrates one approach to having a high-level language that is capable of producing -very- compact code.
15:18:54 <shockwave> Thanks mauke, Cale, jenner, BONUS, and everyone else for the help. BONUS' resource should keep me busy for a while. I'll be dropping by here every now and then, asking noobish questions aas I digest LYAH. Hopefully, I'll be able to help others after that.
15:18:56 <ddarius> boegel: The researchers didn't pursue it, it seems.  Or at least I'm not aware of follow on work.
15:19:00 <byorgey> BMeph: there would have to be an instance of MArray blah foo Identity for suitable blah and foo.
15:19:12 <boegel> ddarius: hmm, k
15:19:12 <BONUS> shockwave: remember to have fun
15:19:12 <shockwave> See ya guys, I'm off to home.
15:19:48 <shockwave> BONUS, no doubt. :-0
15:20:08 <kniu> [43 of 47] Compiling Data.Encoding.JISX0208 ( Data/Encoding/JISX0208.hs, dist/build/Data/Encoding/JISX0208.o )
15:20:17 <kniu> It's been compiling this file for five minutes now.
15:20:22 <kniu> Should I be worried?
15:20:53 <mauke> kniu: it took a very long time here too
15:22:12 <kniu> oh?
15:22:34 <kniu> why would compiling take this long?
15:22:39 <Botje> big file, maybe
15:23:23 <mauke> maybe there's TH involved
15:23:28 <kniu> I'd trust GHC not to run into an infinite loop.
15:24:11 <Ferdirand> 0/wi16
15:24:13 <Ferdirand> oops
15:24:37 <idnar> I read /w 116 and thought "wow, that's a lot of windows"
15:24:54 <ddarius> kniu: There's a known infinite loop bug in GHC and no doubt plenty of unknown ones.  However, GHC does very poorly on large source files.
15:25:12 <byorgey> ddarius: what's the known one?
15:25:19 <gbacon> ?ty scanr
15:25:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
15:25:53 <ddarius> byorgey: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
15:26:07 <kniu> CPU's running at 85 degrees celsius; one core's completely occupied.
15:26:23 <mauke> trust me, it does finish :-)
15:26:37 * BMeph thinks kniu should get a bag of popcorn for those cores...
15:27:06 <byorgey> ddarius: hah, nice.  I didn't know about that.
15:29:32 <kniu> oh hey, it finished.
15:29:38 <kniu> now it's stuck on another file.
15:29:39 <kniu> :|
15:29:50 <mauke> yes, there's two of them
15:29:58 <mauke> was it 45 of 47?
15:31:57 <vincenz> Someone pinged?
15:32:18 <mauke> you started it :-)
15:32:18 <vincenz> conal: Hi
15:32:32 <conal> vincenz: hi
15:32:43 <vincenz> conal: So you live south or north of SF?
15:33:15 <conal> vincenz: east of SF, 3-4 hours by car
15:33:24 <vincenz> Nice area to visit?
15:33:55 <toliko_smoren> is it possible to run a C++ code inside haskell?
15:34:04 <rovar> is there a shortcut for fromEnum?
15:34:11 <conal> vincenz: we love it here.  far from cities.  we're between tahoe & yosemite.
15:34:19 <rovar> i guess I could hack something with TH
15:34:28 <Tobsan> toliko_smoren: http://www.haskell.org/haskellwiki/FFI_Introduction
15:35:24 <conal> are there any type-family wizards here?  i'm stuck on how to get around lack of injectivity.
15:35:43 <vincenz> conal: what's the issue?
15:36:04 <toliko_smoren> Tobsan: thanks but would that work with c++?
15:36:13 <conal> vincenz: do you know about the ambiguity issue in type checking with associated type synonyms?
15:36:18 <BONUS> usually when i have problems with type family injectivity i switch to data families
15:36:21 <vincenz> conal: I'm afraid not
15:37:20 <pchiusano> question about Monad/Applicative
15:38:13 <pchiusano> you know how there is an Applicative instance for lists in which pure a = const a and <*> is pairwise function application?
15:38:26 <opqdonut> yeah the ziplist
15:38:31 <pchiusano> can that be extended to a Monad?
15:38:34 <conal> pchiusano: functions or ziplists?
15:38:35 <opqdonut> except pure is different
15:38:48 <pchiusano> er, I meant pure a = repeat a
15:38:52 <opqdonut> yeah
15:39:00 <conal> pchiusano: yes.  diagonalization.
15:39:00 <opqdonut> well one probably could implement join as the diagonal or something
15:39:05 <opqdonut> :)
15:39:08 <conal> pchiusano: see wouter's stream library.
15:39:09 <pchiusano> is there also an implementation of join for Ziplist
15:39:17 <rovar> I need to enumerate a bunch of data types for parsing. http://www.mongodb.org/display/DOCS/BSON#BSON-ElementDataTypes  what would be the recommended approach?
15:39:24 <pchiusano> conal: what?
15:39:24 <Gracenotes> http://hackage.haskell.org/packages/archive/control-monad-omega/0.2/doc/html/Control-Monad-Omega.html
15:39:30 <Gracenotes> ^ diagonalizing monad
15:39:32 <BONUS> ziplists have to be infinite to be moanads i think, although i might be wrong
15:39:41 <conal> @hackage stream
15:39:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stream
15:39:47 <rovar> I was thinking about data .. deriving (Enum, Bounded) but the values aren't contiguous and start at -1
15:39:54 <conal> pchiusano: ^^
15:40:53 <pchiusano> what is the diagnolization of an infinite [[a]]
15:41:34 <conal> pchiusano: it's in the stream lib.
15:41:54 <conal> pchiusano: n-th element of n-th stream
15:42:22 <conal> pchiusano: semantically, the same as the function monad, since streams are functions from Nat.
15:42:53 <conal> join ss !! n == ss !! n !! n
15:43:15 <pchiusano> conal: I see
15:43:33 <ztirF> arg IOError is making my head hurt
15:43:40 <pchiusano> conal: and that is compatible w/ the definition of <*> for ziplist?
15:43:53 <conal> pchiusano: yes
15:44:09 <conal> pchiusano: stream and ziplist have consistent applicatives
15:44:29 <pchiusano> conal: very cool
15:44:47 <conal> :)
15:48:33 <gbacon> Say I have [1,3..10] and want to compute the differences at each gap (all 2s in this contrived example). It's not quite a scanr, but which primitive recursion pattern is this?
15:49:59 <blackh> gbacon: I don't know if this is the best answer, but I would use zipWith f x (tail x)
15:50:00 <Igloo> I think zipWith (-) xs (tail xs) is the nicest way
15:50:01 <byorgey> gbacon: you can do it with a zip.
15:50:11 <Zao> gbacon: zip with itself and tail.
15:51:35 <gbacon> thanks all
16:00:02 <mib_4325pbwl> MAKE EASY AND FAST CASH NOW! TRY IT > http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245 http://cashcrate.com/1173245
16:00:29 <mle> um
16:00:39 <mle> hm
16:01:33 <vixey> ohh fast cash
16:01:43 <vixey> that sounds legit
16:01:59 <MyCatVerbs> That sounds great. Inanimate coinage and banknotes are just too boring. I need FAST CASH.
16:02:02 <bd_> reported in #freenode
16:02:20 <bd_> nobody on /stats p, heh
16:02:21 <Philippa_> MyCatVerbs: you don't care if it's easy though?
16:02:33 <Philippa_> (want easy fast cash? Be rich)
16:02:47 <MyCatVerbs> Probably a bonus if it's not. I don't want my FAST CASH associating with undesirable people, like bankers.
16:03:37 <MyCatVerbs> gbacon: I kept finding myself using zipTail f xs = zipWith f xs (tail xs) over and over at one point.
16:04:11 <MyCatVerbs> gbacon: it's more like-er, common than you might think, if you're after anything that looks like differences between sequence elements.
16:05:06 <gbacon> ?src zip
16:05:07 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:05:07 <lambdabot> zip _      _      = []
16:05:13 <gbacon> ?src zipWith
16:05:14 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:05:14 <lambdabot> zipWith _ _      _      = []
16:05:27 <trofi> :t (,)
16:05:28 <lambdabot> forall a b. a -> b -> (a, b)
16:05:59 <gbacon> ?ty \f -> map (uncurry f) . zip
16:06:00 <lambdabot>     Couldn't match expected type `[(a, b)]'
16:06:00 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
16:06:00 <lambdabot>     Probable cause: `zip' is applied to too few arguments
16:06:10 <trofi> @check \xs1 xs2 -> zip xs1 xs2 == zipWinth (,) xs1 xs2
16:06:11 <lambdabot>   Not in scope: `zipWinth'
16:06:15 <trofi> @check \xs1 xs2 -> zip xs1 xs2 == zipWith (,) xs1 xs2
16:06:17 <lambdabot>   "OK, passed 500 tests."
16:06:37 <gbacon> ?ty \f -> map (uncurry f) $ zip
16:06:38 <lambdabot>     Couldn't match expected type `[(a, b)]'
16:06:38 <lambdabot>            against inferred type `[a1] -> [b1] -> [(a1, b1)]'
16:06:38 <lambdabot>     In the second argument of `($)', namely `zip'
16:06:54 <trofi> :t uncurry
16:06:56 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:07:06 <gbacon> ?ty \f -> map (curry f) . zip
16:07:07 <lambdabot>     Couldn't match expected type `[a]'
16:07:07 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
16:07:07 <lambdabot>     Probable cause: `zip' is applied to too few arguments
16:07:10 <trofi> map ?
16:07:22 <gbacon> ?ty \f -> map (curry f) $ zip
16:07:23 <lambdabot>     Couldn't match expected type `[a]'
16:07:23 <lambdabot>            against inferred type `[a1] -> [b] -> [(a1, b)]'
16:07:23 <lambdabot>     In the second argument of `($)', namely `zip'
16:08:20 <gbacon> ?ty \f a b -> map (uncurry f) $ zip a b
16:08:22 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
16:08:32 <gbacon> ?pl \f a b -> map (uncurry f) $ zip a b
16:08:32 <lambdabot> (. zip) . (.) . map . uncurry
16:09:22 <omnihil> . (.) .
16:10:23 <gbacon> ?ty (. (.) .)
16:10:25 <lambdabot> parse error on input `)'
16:10:45 <gbacon> ?botsnack
16:10:45 <lambdabot> :)
16:16:15 <Botje> if you want to report that spammer asshole, leave a friendly message at http://cashcrate.com/abuse.php :)
16:17:43 * vixey always wonders if they punish or reward people that get reported for spamming...
16:17:59 <omnihil> they publicly punish them and privately reward them.
16:18:58 <osfameron> can you use functions as keys for a Data.Map ?
16:19:58 <osfameron> for example to associate a function with its equal-and-opposite function
16:20:44 <kerlo> > (. . .)
16:20:45 <lambdabot>   <no location info>: parse error on input `.'
16:20:57 <mle> what are you trying to do?
16:21:12 <kerlo> I'm trying to determine whether (. . .) is an error or not.
16:21:13 <ChilliX> conal: Hey
16:21:41 <kerlo> So, can .hc files be compiled into executables?
16:22:12 <ChilliX> conal: I think you tried to ping me earlier.
16:22:17 <conal> ChilliX: hi.  i'm struggling with lack of injectivity in type families.  my family is injective, but i don't know how to say so.
16:23:09 <ChilliX> What kind of family is it?
16:23:27 <conal> an associated type synonym.
16:23:37 <ChilliX> (The most direct way to express injectivity is by super class equalities, which aren't implemnete dyet unfortunatly, but sometimes there are other ways.)
16:23:38 <conal> declared in a class.
16:24:01 <conal> ChilliX: i don't know that trick.
16:24:22 <ChilliX> conal: just a sec, crying baby
16:24:32 <conal> ChilliX: np
16:24:44 <mle> kerlo: use parens around each dot
16:24:58 <vixey> what is it about injectivity just curious..
16:25:08 <kerlo> mle: but that won't tell me whether (. . .) is an error or not.
16:25:24 <kerlo> Well, I ran "gcc -x c sillylisp.hc", and it gave me precisely 7,062 errors.
16:25:32 <kniu> The new Encoding package confuses me.
16:26:07 <kniu> System.IO.Encoding.hPutStr no longer takes an Encoding as a parameter.
16:26:09 <kerlo> GHC runs gcc, doesn't it? How does it get it to not give 7,062 errors?
16:26:26 <kniu> So how would I output a certain encoding?
16:26:40 <conal> vixey: during type-checking it helps a lot that F x == F y ==> x == y.  i.e., F is injective.
16:26:57 <conal> vixey: was always true until type families.
16:27:05 <kniu> http://hackage.haskell.org/packages/archive/encoding/0.3/doc/html/System-IO-Encoding.html
16:27:14 <kniu> that needs to be updated badly.
16:27:17 <vixey> oh I understand
16:27:36 <vixey> conal btw what you said about assumptions is still bugging me :)
16:27:43 <vixey> conal, I am reminded of the blind spot
16:27:43 <conal> vixey: good! :)
16:28:19 <kniu> wait...
16:28:25 <kniu> what are implicit parameters?
16:30:53 <conal> vixey: i suspect blind spots are nearly always behind claims of "necessary" or "impossible".
16:35:00 <olsner> kerlo: I think (I may be wrong though) that .hc files are not the same kind of file that ghc feeds to gcc
16:36:47 <kerlo> ghc --help suggests that it does pass .hc files to gcc.
16:37:29 <kerlo> Hmm, this is interesting.
16:37:30 <kerlo> ihope@normish:~$ ghc sillylisp.hc
16:37:30 <kerlo> ghc-6.8.2: unknown package: network-2.1.0.0
16:37:54 <kerlo> Should I find a .hc file for network-2.1.0.0?
16:40:35 <dons> kerlo: try ghc -O --make
16:40:44 <dons> it'd be curious to know if you can compile .hc files directly
16:44:05 <kerlo> Well, I want to some of it on one machine and the rest on another.
16:46:01 <kniu> guys, help.
16:46:06 <kniu> I'm so confused right now.
16:46:42 <kniu> it seems that System.IO.Encoding.hPutStr uses implicit parameters, but I don't know how to set those implicit parameters.
16:46:52 <kniu> This page: http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
16:47:09 <kniu> tells me to use ? in front of an identifier, but that doesn't seem to work.
16:48:04 <vincenz> conal: I'd love to visit
16:49:10 <conal> vincenz: please do.
16:49:18 <Botje> kniu: woah. that looks scary.
16:49:36 <osfameron> hmmm, I can't wrap my head around zipper'ing a {right=r, down=d} style grid.  It seems very impractical.
16:50:16 <osfameron> I like apfelmus's suggestion of just sticking all the cells in a Data.Map (Int,Int)...
16:50:58 <vincenz> conal: then I can also go take a look at yosemity
16:51:58 <conal> vincenz: it's lovely
16:52:28 <vixey> osfameron have you seen game of life using comonads
16:52:41 <kniu> Botje, you have any idea how to use encoding 0.5.0?
16:52:56 <Botje> none whatsoever :(
16:53:09 <osfameron> vixey: the cellular automata post?  I have that bookmarked, I'll have a read
16:53:47 <vixey> osfameron I don't knowhow to make it efficient though
16:55:49 <Botje> kniu: i think let ?enc = undefined in hPutStrLn stdout "foo" should at least compile
16:55:59 <kniu> it doesn't.
16:56:33 <Botje> boo
16:56:45 <Botje> are you using ghc 6.10?
16:56:48 <kniu> I tried let {?enc = ISO88591} in hPutStr ...
16:56:50 <Botje> because hackage says that doesn't work
16:57:01 <kniu> it tells me that '?' is not recognized.
16:57:12 <osfameron> vixey: I don't think I understand that at all.  All the words seem to be English up until "here's why U forms a Comonad" when he doesn't explain Comonad, or why U forms one...
16:57:12 <Botje> hmm
16:57:17 <ChilliX> conal: the above implication was never true for Haskell due to type synonyms
16:57:21 <Botje> did you hide the built-in hPutStr ?
16:57:36 <kniu> I imported qualified.
16:57:38 <conal> ChilliX: oh yeah.
16:57:39 <ChilliX> conal: why do you need the family to be injective?
16:58:02 <conal> ChilliX: for type inference.
16:58:04 <Botje> then you're calling it qualified too, right?
16:58:15 <kniu> yeah
16:58:29 <conal> ChilliX: i.e., the family *is* injective.   i'd like type inference to exploint injectivity.
16:58:58 <ChilliX> do you have an example where it is biting you that the compiler doesn't know about the injectivity?
16:59:03 <Botje> kniu: oh!
16:59:08 <kniu> ?
16:59:08 <Botje> did you enable Implicit param support?
16:59:13 <Botje> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
16:59:14 <conal> ChilliX: yeah.
16:59:27 <Botje> "Implicit parameter support is enabled with the option -XImplicitParams."
16:59:34 <Botje> that's maybe why it's dying :)
16:59:40 <osfameron> vincenz: ah wait, I'm looking at http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html which is about 1D automata, though the comments thread does talk about 2D
17:00:00 <vincenz> osfameron: wrong person?
17:00:10 <conal> ChilliX: i'm convverting between a GADT of unit/pair/primitive trees and a corresponding non-GADT representation.
17:00:12 <kniu> huh
17:00:15 <kniu> didn't do that.
17:00:46 <conal> ChilliX: the non-GADT is more convenient for users.  at least that's the idea.
17:01:42 <osfameron> vincenz: oops, sorry, was for vixey but he quid
17:02:14 <conal> ChilliX: btw, this happens to be for the gpu dsel compiler i'm working on.
17:03:34 <ChilliX> so, you are getting ambiguous signatures?
17:03:50 <vincenz> osfameron: she
17:05:14 <osfameron> vincenz: ah, thanks, bad assumption
17:05:20 <kniu> I used -XImplicitParams
17:05:39 <kniu> it still tells me "Not in scope: `?'"
17:08:19 <Botje> hmm
17:08:35 <Botje> try adding {-# LANGUAGE ImplicitParams #-} at the top of your file
17:08:44 <Botje> just to make sure it gets compiled with that
17:09:04 <Botje> if that doesn't work i don't know :(
17:11:47 <osfameron> ooo, I just got that "citeseer" is a pun...
17:11:52 <SamB> lol
17:11:56 <SamB> just got it!
17:11:59 <osfameron> :-)
17:12:28 * SamB 's always known it was some kind of pun, but isn't quite sure how
17:13:13 * ziman had to google it
17:15:06 <SamB> oh, so that's what the pun is
17:33:48 <conal> can anyone see what's going wrong here with GADTs + fundeps?   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2293#a2293
17:35:44 <Cale> conal: mm... I haven't looked yet, but GADTs basically don't interact much at all with fundeps, last I checked, but type families do.
17:35:57 <thoughtpolice> type families should work perfectly OK with gadts
17:36:14 <conal> same error if I use an existential constructor instead of a gadt.
17:36:14 <conal>   data Triple a' v o = forall v'. Foo v' v => Triple (a' -> v) (v' -> o)
17:36:19 <thoughtpolice> ChilliX wrote on the list somewhere about a week ago about the state of affairs
17:36:47 <conal> i tried first with a type family, but then i lose the symmetric fundep, resulting in lots of ambiguity. :(
17:37:25 <conal> i'd like to say that my type family is injective, but there doesn't seem to be a way.
17:37:48 <ChilliX> conal: yeah, fundeps and GADTs don't work together
17:38:12 <conal> oh, darn.
17:38:21 <conal> ChilliX: existential constructors also?
17:38:32 <conal> i'm stuck :(
17:38:47 <ChilliX> one solution would be to express the fundep with two TFs and superclass equalities, but those are not implemented yet
17:38:57 <ChilliX> but will be one of the next things
17:39:17 <ChilliX> yes, same prob with existentials, sry
17:40:03 <ChilliX> conal: if you can send me a cut down version of the TF code, I'll have a look at whether I can find a temporary workaround
17:40:38 <conal> ChilliX: i will.  thanks.
17:41:15 <ChilliX> sure, sorry for not having a direct answer
17:45:02 <conal> ChilliX: i'd like to say:  class Foo a | a -> FooT a where type FooT a
17:45:33 * c_wraith starts learning to use monad transformers. ErrorT, I will figure you out!
17:46:27 <ChilliX> conal: sry, got to dash off...can you write me an email please?
17:46:33 <ChilliX> thx
17:47:21 <conal> ChilliX: np
17:47:35 <Botje> hahaa
17:47:48 <Botje> if anyone remembers that cashcrate.com spammer: I got his account canceled :)
17:48:21 * Cale gives c_wraith some HaskeBalls to catch monad transformers in.
17:48:25 <idnar> Botje: cute
17:48:44 <c_wraith> thanks, Cale, I'm gonna need 'em
17:51:50 <shepheb> foldr evolved into catamorphism!
17:52:16 <Gracenotes> @insult $who
17:52:16 <lambdabot> Unknown command, try @list
17:56:20 <BMeph> conal: Have you figured out how 'on' fits into the SEC world? :)
18:05:30 <koninkje> Do Hugs or Cabal have their own chans, or is #ghc the only one for those sorts of details?
18:05:55 <Axman6> what sort of details?
18:06:34 <koninkje> Mainly getting cabal set up for hugs (e.g. dealing with issues like running ffihugs)
18:07:01 <koninkje> I use cabal for ghc, but I'm not sure how it's used over in hugs land
18:07:38 <thoughtpolice> cabal install --hugs ....
18:07:39 <thoughtpolice> ?
18:08:09 <koninkje> But where does that install to?
18:08:30 <thoughtpolice> i wouldn't know, run with -v3 as well
18:08:50 <koninkje> hmm
18:10:30 <koninkje> I was also thinking the `runhaskell Setup.hs` variety of cabal, rather than cabal-install
18:17:56 <koninkje> Is there a way to convince cabal --hugs to use normal cpp, instead of cpphs?
18:18:39 <koninkje> (--with-cpp=/usr/bin/cpp  yields errors about unknown flags)
18:39:20 <mxc> ?seen ndm
18:39:20 <lambdabot> I haven't seen ndm.
19:04:31 <stepcut> i can't remember the last time I wrote a program that used GADTs, am I doing it wrong?
19:04:57 <roconnor> nope
19:05:47 <ddarius> I don't think I've ever written a program using GADTs.
19:05:58 <roconnor> I've used GADTs once
19:06:17 <stepcut> roconnor: ok, just checking. I use associative types, and other extensions all the time, but not GADTs. Makes me wonder if I am missing something, or if GADTs just don't make anything better in the domains I am working in
19:06:45 <stepcut> The only time I used gadts was when I was trying to implement a strongly type, optimizing relational algebra
19:07:21 <roconnor> Oh right, I used GADTs as well when writing a lambda-mu-mu-tilde something
19:07:25 <roconnor> I'm not sure that counts
19:07:37 <stepcut> but, the fundep hackery was too strong. Might be able to do it with ATs now -- but I don't care much about relational algebra right now
19:14:52 * kerlo writes first-order logic and ZFC using GADTs
19:14:59 <kerlo> s/ZFC/ZFD/
19:15:19 <kerlo> I prefer ZFD to ZFC. The things ZFD disallows (e.g. ZFC) are just too icky.
19:16:00 <edwardk> stepcut: i've used them maybe a half dozen times tops. mostly interpreters
19:16:32 <stepcut> edwardk: yeah, that would be sensible
19:16:53 <edwardk> i think i have all of one in category extras. ;)
19:18:23 <ddarius> Certain GADTs would be fairly useful in category-extras...
19:18:47 <edwardk> ddarius: i used one for a discrete category iirc
19:19:08 <edwardk> i wanted to use one for a product category, but i couldn't make everything work to have functors to/from that category so i put it down
19:19:23 <edwardk> er to was the problem, iirc from works fine
19:23:42 <edwardk> data Prod p q x y where Prod :: p a b -> q c d -> Prod (a,c) (b,d) -- works fine, but can't have any functors to it because it has no inhabitants of the form Prod (f (a,c)) (f (b,d)) -- adding another constructor to handle that case to work around newtype noise doesn't seem to be viable
19:24:16 <edwardk> er Prod p q (a,c) (b,d)
19:24:35 <edwardk> and moreover would result in it being a different category, anyways ;)
19:28:14 <ddarius> When I was playing with one formulation of categorical ideas into Haskell recently, I came to the conclusion that a much richer kind system would be beneficial.
19:28:22 <edwardk> yeah
19:28:41 <edwardk> The need for crap like HFunctor gets under my skin
19:28:55 <kerlo> This is how far I got before going "eek": http://pastebin.ca/1357894
19:29:04 <kerlo> Now I guess I'll continue.
19:29:06 <edwardk> and its one of the reasons why i was driven from types back to kata ;)
19:29:48 <edwardk> i encoded a fair chunk in coq and agda (though in agda only with set-in-set)
19:30:15 <kerlo> And it's broken, even.
19:31:24 <kerlo> To paraphrase myself, "You mean Haskell still doesn't have dependent types?"
19:31:33 <ddarius> edwardk: I think a two-level language would do a good job of formulating (1-)category theory.
19:32:32 <edwardk> ddarius: 2 stage compilation?
19:33:11 <edwardk> ddarius: one thing i miss in kata is being able to define things like f-algebra homomorphisms or monad homomorphisms, because those really need an element of proof. =/
19:35:09 <ddarius> edwardk: I don't quite mean that, though I was aware that that is probably what it would sound like.  More along the "rich kind system" approach.  However, that and what I'm thinking of seem to match what Jonathan Sobel has claimed about "implementing" category theory.
19:36:23 <edwardk> when i first looked at it in nuel it seemed like i needed a kind of 'polysorted' function for a lot of things to avoid repeating stuff in different sorts and kinds.
19:37:12 <ddarius> edwardk: Yes.
19:37:25 <edwardk> you can get a lot (and maybe all) of that with universe polymorphism if you're more clever than I have been i guess
19:37:48 <edwardk> though, even with that you get prop/set duplication. i liked the erasure PTS stuff because that was gone
19:37:56 <ddarius> For example, functors and adjunctions form categories but aren't instances of Category because functors would need (* -> *) -> (* -> *) -> * and adjunctions (* -> *, * -> *) -> (* -> *, * -> *) -> *
19:38:10 <ddarius> edwardk: I.e. Category should really have the kind, forall k. k -> k -> *
19:38:10 <edwardk> exactly
19:39:30 <maurer1> Does anyone know how to get gtk2hs to build with profiling? I keep getting a missing build target error.
19:39:31 <edwardk> and if you break the code up into two compilation stages where one basically figures out where you are using the polysorted definitions and the other type checks those occurences, i haven't seen any problems with such a system
19:40:27 <ddarius> So the question is: does CT have a suitable amount of phase separation.
19:40:55 <edwardk> the easy stuff seems to anyways
19:42:16 <edwardk> neil ghani and patricia johann had a paper recently that ran smack dab into this problem, they had a nice generic definition but they couldn't give it because the kinds varied
19:44:29 <edwardk> i keep thinking in haskell i can get most of the way there using template haskell ;)
19:44:48 <edwardk> but its still not perfect
19:45:19 <Cale> kerlo: So you prefer having incomparable cardinals?
19:48:59 <plumpkin> why is bulat stuck on 6.6?
19:52:24 <Cale> kerlo: (I'm genuinely interested in how you view the consequences of AC failing)
19:52:49 <kerlo> Cale: sure. Of course, I ought to learn more about incompatible cardinals and unmeasurable sets before I really settle on one or the other.
19:53:46 * ddarius only cares about constructible bases for infinite-dimension vector fields.
19:54:11 <Cale> To me, it seems to go a bit against my view of what sets are to allow pairs of sets X and Y such that there's no injection from one to the other either way...
19:54:36 <Cale> That would sort of mean that sets have "shapes" such that they don't fit into one another somehow.
19:54:54 <Cale> But of course, you can do it.
19:55:55 <c_wraith> Hmm.  Ok, I'm drowning in MonadError and type declarations
19:56:28 <Cale> c_wraith: I recommend always newtyping the monad constructed using monad transformers.
19:56:42 <Cale> That is... you should use something like...
19:57:52 <Cale> newtype MyMonad a = MM (ErrorT ErrorType (ReaderT Env IO) a)
19:58:19 <Cale>   deriving (Functor, Monad, MonadError ErrorType, MonadReader Env)
19:58:39 <Cale> (possibly leaving the last two out so that you can write wrappers around the functionality)
19:59:09 * kerlo stumbles upon the proof of no incompatible cardinals given AC
19:59:21 <kerlo> Well-order the sets; there's your injection.
19:59:25 <Lemonator> @fl (\h -> mapM (flip join h) channels)
19:59:25 <lambdabot> Not enough privileges
19:59:32 <kerlo> That was easy.
19:59:35 <Lemonator> really?
19:59:35 <Cale> :)
19:59:43 <Cale> @pl (\h -> mapM (flip join h) channels)
19:59:43 <lambdabot> flip mapM channels . flip join
19:59:55 <Lemonator> oh, right.
20:00:38 <Cale> kerlo: You can also go the other way.
20:00:50 <Cale> kerlo: No incomparable cardinals -> AC
20:00:58 <kerlo> Hmm.
20:01:04 <Lemonator> so who wrote encoding-0.5.0?
20:01:06 <c_wraith> Meh.  I really dislike AC
20:01:20 <Cale> I don't understand this dislike for AC. It's a nice axiom :)
20:01:33 <Cale> Every surjective function has a right inverse.
20:01:34 <Lemonator> more specifically, why the hell use implicit parameters when the old way of passing in encodings manually worked fine?
20:01:43 <kerlo> Well, obviously, if a cardinal number can be well-ordered, so can everything of that cardinal number.
20:01:49 <c_wraith> it implies that there's a least number greater than 0.  I'm not ok with that.
20:02:03 <Cale> c_wraith: huh?
20:02:10 <Cale> c_wraith: "number"?
20:02:10 <kerlo> Not unless you define "greater" weirdly.
20:02:19 <kerlo> Or "number".
20:02:26 <Cale> c_wraith: You mean real number?
20:02:36 <c_wraith> isn't the axiom of choice equivalent to the well-ordered principle?
20:02:41 <Cale> Yes
20:02:51 <Cale> c_wraith: It implies you can *put* an ordering on the real numbers such that they become well ordered under that ordering
20:03:00 <Cale> It's not the usual ordering on the reals.
20:03:14 <Cale> (the usual ordering is total, but is not a well-ordering)
20:04:10 <c_wraith> Hmm.  Perhaps if it's a different ordering, I can live with it.
20:04:38 <c_wraith> Anyway, perhaps if I explain what I'm trying to do, you can give some advice.
20:05:08 <kerlo> Indeed, it must be a different ordering; otherwise, ZFC would be inconsistent because of precisely what you said.
20:06:08 <Cale> kerlo: What do you think about CH?
20:06:36 <Cale> (Is there a set whose cardinality lies between the naturals and the reals?)
20:07:04 <kerlo> Aleph_1 being the cardinality of the continuum would be nice.
20:07:39 <kerlo> Does aleph_1 even exist in ZFD?
20:07:40 <Cale> Yeah, it sometimes seems nice... but it also implies that there's a well-ordering of the reals such that every real number has a countable set of predecessors.
20:08:26 <Cale> (which isn't necessarily bad, it's just a little bit strange :)
20:08:35 <kerlo> Touche. :-)
20:08:45 <c_wraith> I'm starting with a function with this type:  Monad m => (Request -> m Response) -> String -> m (Either String [Data])
20:09:21 <c_wraith> I'm trying to figure out how to use ErrorT so that I can handle errors sanely, while still in an arbitrary monad.
20:09:47 <Cale> kerlo: Hmm, without AC, you do need to be a little careful what you mean about Aleph_1, yeah.
20:11:16 <Cale> Like, you want to change that into  Monad m => (Request -> m Response) -> String -> ErrorT String m [Data] ?
20:11:30 <c_wraith> essentially
20:11:44 <Cale> Shouldn't be too bad...
20:11:53 <Gracenotes> @instances ErrorT
20:11:54 <lambdabot> Couldn't find class `ErrorT'. Try @instances-importing
20:12:13 <Gracenotes> @instances Control.Monad.Error.ErrorT
20:12:14 <Cale> Instead of returning Left, you throw, and instead of returning Right, you just use plain return.
20:12:14 <lambdabot> Couldn't find class `Control.Monad.Error.ErrorT'. Try @instances-importing
20:12:37 <c_wraith> perhaps I'm just struggling with the advice that it's "trivial" to do by adding a MonadError constraint, and using runErrorT
20:13:39 <sarh> c_wraith: are you wanting something _other_ than replacing your function f with (\x s -> ErrorT (f x s))?
20:14:11 <c_wraith> I want to re-write the function so that I get to use the transformation Cale suggested
20:14:28 <c_wraith> because otherwise there are many nested case blocks, as I do several different operations that can return Left
20:14:57 <c_wraith> That's actually the prime motivation
20:15:03 <c_wraith> The ability to re-write without nested cases
20:15:23 <c_wraith> Everything else is a detail.  I have no issues with changing the type of the function.
20:39:01 <pumpkin> moo
20:40:24 <Gracenotes> *the sound of a shotgun rings in the air*
21:00:05 <mxc> ?seen ndm
21:00:05 <lambdabot> I haven't seen ndm.
21:00:42 <TomMD> lambdabot must be new around here...
21:02:34 <PHO_> ?seen lambdabot
21:02:34 <lambdabot> Yes, I'm here. I'm in #interplanetarylazers, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #
21:02:34 <lambdabot> haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd,
21:02:34 <lambdabot>  #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
21:03:18 <PHO_> ?seen PHO_
21:03:18 <lambdabot> You are in #haskell. I last heard you speak just now.
21:26:49 <maurer1> Hey, if the profiler is telling me that my cost center is MAIN from module MAIN using 100% of processing time, what does that mean? I've got most of the actual logic spread out.
21:27:00 <maurer1> Could this mean that my program is thrashing the RNG?
21:28:22 <bos31337> what flags are you compiling with?
21:28:37 <maurer1> I'm using cabal, and told cabal to make a profiling build
21:28:47 <maurer1> Would you like me to use ghc --make with some set of flags instead?
21:28:56 <bos> probably by default it's not compiling with -auto-all
21:29:05 <bos> which means you'll only get one cost center
21:29:11 <maurer1> no, that's not what I mean
21:29:13 <maurer1> Here, onesec
21:29:47 <maurer1> http://matthewmaurer.org/KArmedBandit.prof
21:29:52 <mae> Stephen Blackheath: doth thou exist hither on this IRC channel?
21:30:17 <maurer1> (I'll upload a longer run in a second)
21:30:44 <bos> mauke: did you compile with -auto-all?
21:30:57 <bos> er, maurer1, sorry
21:31:02 <bos> bad tab completion
21:31:14 <maurer1> bos: -Pa is available, does this not mean auto-all?
21:31:25 <bos> it's a *compilation* flag.
21:31:53 <bos> you need to recompile the program.
21:32:07 <maurer1> ok, will do
21:37:58 <maurer1> Oh, thanks, looks like -auto-all was required
21:38:00 <maurer1> Why is that?
21:38:25 <bos> because otherwise GHC assumes you'll manually annotate the cost centres you're interested in.
21:39:03 <maurer1> bos: How do I do that?
21:39:15 <bos> {-# SCC "hi_mom" #-}
21:39:27 <maurer1> Thanks.
21:43:46 <grantdai> hello
21:43:53 <koninkje> I have a Cabal package that uses CPP. In older versions of cabal (1.2.3.0 as ships with ghc-6.8.2) you need to set ghc-options: -D__BLAH__ because cpp-options: -D__BLAH__ doesn't work. Since last time I uploaded the package Hackage has decided this is grounds for rejection.
21:44:08 <koninkje> Is there a way to fix this without loosing backwards compatibility?
21:44:43 <bos> yes.
21:44:52 <grantdai> how are you
21:44:54 <bos> if impl(ghc >= 6.10):
21:45:09 <koninkje> bos: I still get the error with that
21:45:36 <bos> hmm. in that case, maybe bring it up with dcoutts.
22:01:01 <cads> what seems like more of a challenge for current artificial intelligence methods? Parsing a novel and composing a literary analysis of the book based some literary theory...
22:01:04 <cads> or
22:01:48 <cads> parsing a mathematician's notations and understanding the notions introduced in the a math document
22:02:09 <edwardk> the latter
22:02:19 <koninkje> doubtful...
22:02:37 <cads> and writing a software library implementing the theorems and algorithms introduced
22:02:46 <edwardk> i say so mainly because the former can be done convincingly enough by a cheesy little markov chain toy =)
22:03:17 <koninkje> I suppose it depends on how convincing it needs to be ;)
22:03:25 <stevenD> hi
22:03:43 <cads> hehe, I'd wager that people who toy around with markov chains don't hold a wonderful opinion of liberal arts pursuits :D
22:03:51 <Lemonator> Jesus Christ
22:04:02 <cads> Amen
22:04:07 <Lemonator> This Data.Encoding package is driving me nuts.
22:04:11 <edwardk> otoh, i ran into a guy last week that was doing the math side of things. http://safre.org/wiki/index.php?title=Main_Page
22:04:21 <Lemonator> /usr/lib/encoding-0.5.0/ghc-6.10.1/libHSencoding-0.5.0.a(Encoding.o): In function `s9BJ5_info':
22:04:22 <Lemonator> (.text+0x6d4): undefined reference to `get_system_encoding'
22:04:22 <Lemonator> collect2: ld returned 1 exit status
22:04:33 <Lemonator> the hell does that mean?
22:04:36 <edwardk> automatically parsing things like http://safre.org/wiki/index.php?title=Irrationality_of_the_square_root_of_two
22:04:49 <Lemonator> first time I ever encountered a linker error using GHC
22:07:07 <cognominal> how come I get this error?
22:07:09 <cognominal> Prelude> :m +Network.URI
22:07:09 <cognominal> :m +Network.URI
22:07:09 <cognominal> Prelude Network.URI> parseURI "http://haskell.org"
22:07:09 <cognominal> parseURI "http://haskell.org"
22:07:16 <koninkje> On the whole, mathematics seems far more regularly structured than novels, so the markov toys should be able to work better there. Though it also depends on what "novels" you're counting I suppose. SOme of them are quite banal and formulaic too
22:07:20 <cognominal> *** Exception: „™ß‚ÄÄÊºÄÁÄÄÊîÄÊ∏Ä‰òÄÊ§ÄÊ∞ÄÊîÄ„®Ä‚ÄÄÊêÄÊºÄÊîÄÁåÄ‚ÄÄÊ∏ÄÊºÄÁêÄ‚ÄÄÊîÄÁ†ÄÊ§ÄÁåÄÁêÄ‚ÄÄ‚†Ä‰∏ÄÊºÄ‚ÄÄÁåÄÁîÄÊåÄÊ†Ä‚ÄÄÊòÄÊ§ÄÊ∞ÄÊîÄ‚ÄÄÊºÄÁàÄ‚ÄÄÊêÄÊ§ÄÁàÄÊîÄÊåÄÁêÄÊºÄÁàÄÁ§Ä‚§Ä
22:07:25 <cognominal> oops
22:07:39 <cognominal>  openFile: does not exist (No such file or directory
22:07:52 <cognominal> emacs  cut and paste got confused
22:08:00 <ddarius> Ein bischen
22:08:19 <cognominal> I can't understand why parsing an URI would try to access a file...
22:08:59 <cognominal> can someone reproduce the problem?
22:09:01 <edwardk> koninkje: unfortunately the barrier was higher, understanding the notions was required of the mathematics, but i've seen many a literary analysis performed by someone who hadn't paid any attention to the material at all ;)
22:09:20 <cognominal> I use ghc 6.10.1
22:10:55 <koninkje> edwardk: and here I was assuming real analysis =)
22:12:14 <cads> koninkje: a lot depends on the nature of the critical theory applied... some of them are good at praising humanity for all it wonderful abstracts and goodness, some might tally the kinds of words and conclude that the piece was written by a bourgouise elitist
22:13:59 <cads> I think for the first one the algorithm would be able to pass a form of turing test
22:14:23 <cads> in that you wouldn't be able to tell if it had been written by a machine or a undergrad
22:14:34 <koninkje> sadly, turing tests are all too easy to pass
22:15:27 <cads> it doesn't bug me that the objective evidence of sentience isn't that hard to generate
22:16:30 <cads> still I haven't had any convincing talk about haskell with a robot unless you guys are not telling me something awesome
22:18:12 <cognominal> can someone help?
22:18:38 <cads> the problem with the math text would probably deal with the fact that even when a human is being very formal about his math, there are lots of notational shortcuts that are used to represent things, and they can be inconsistent, or certainly hard for a computer to decode
22:19:02 <Cale> cognominal: hmm
22:19:37 <mle> cognominal: I get Just http://haskell.org
22:19:38 <Cale> cognominal: well... I don't get that error here, at least...
22:20:09 <cognominal> ok
22:20:46 <cads> it's weird how you might think of the complexities of parsing natural language and understanding meaning from it... but the data format for the language is so simple, 1 dimensional.
22:21:17 <Cale> cognominal: what version of the network package do you have?
22:21:22 <koninkje> cads: Those sorts of shortcuts tend to be covered pretty well by backoff models and smoothing. The big trick has more to do with general issues of syntactic complexity and regularity. Math tends to have very simple syntaxes, even in prose; Novels are more varied
22:21:55 <cognominal> Cale :  network-2.2.0.1
22:22:09 <Cale> okay, same here
22:22:19 <koninkje> cads: That's just the serialization. The real data is far from one dimensional
22:23:03 <koninkje> cads: Consider, for instance, a hypergraph or other packed datastructure. What's in memory is much more interesting than what gets written to disk
22:23:39 <koninkje> (though translating from disk to memory without the decoding algorithm can be quite a pain)
22:23:42 <Cale> cognominal: I see nothing related to file I/O in Network.URI
22:23:51 <cognominal> Cale : I forced the reinstall and it works
22:23:58 <cognominal> strange
22:24:03 <Cale> okay, huh
22:24:26 <cognominal> thx for the moral support anyway, it helps
22:24:39 <cads> reading a math text invokes a math object in the aether, and describes its properties and interactions with other object... but you're dealing still with concrete mathematical objects..... in a sweeping scene of passionate romance on a dead night in paris, a lot more things are invoked
22:25:16 <kyagrd> Does anybody know what happens if there is a filename clash among Hackage packages? I doubt Hackage automatically checks it when we upload packages ...
22:25:40 <cads> if if they're mathatical objects, they are frighteningly complicated ones
22:26:33 <cads> i like that I'm in your monad guy
22:27:00 <cads> ImInYourMonad: hey man, how long have you been here?
22:27:07 <johnw> silly newb question: why isn't Num already part of Ord?
22:27:21 <pumpkin> not all Nums are Ord
22:27:26 <johnw> which kinds?
22:27:28 <pumpkin> think Complex
22:27:38 <johnw> ah, guess this is where my non-mathematical skills come into play
22:27:40 <johnw> I didn't know that
22:28:24 <johnw> thanks
22:28:33 <pumpkin> :)
22:28:37 <cads> can't we construct an order in the complex numbers?
22:28:50 <ddarius> cads: In one arbitrary way or another, sure.
22:28:52 <Cale> cads: Not one which agrees with the arithmetic opearations
22:28:54 <Cale> operations*
22:29:25 <Cale> That is, you can put an ordering on the complex numbers, but you can't turn them into an ordered-field.
22:29:41 <Cale> (http://en.wikipedia.org/wiki/Ordered_field)
22:32:23 <wli> Q_p
22:33:04 <cads> I see, cale
22:36:08 <cads> cale, when you give me a little tidbits of math goodness I am thankful
22:36:14 <Cale> :)
22:36:28 <cads> cale, what did you stufy?
22:36:34 <Cale> Pure mathematics
22:36:35 <cads> study*
22:38:07 <cads> have you moved past school now?
22:38:21 <Cale> My favourite branches are things which involve something algebraic mixed with something geometric or picturable in a nice way...
22:38:52 <ddarius> So all of math if you try hard enough.
22:39:01 <ddarius> (Usually hard enough isn't very hard.)
22:39:13 <Cale> Actually, I'm applying for CS graduate studies, since some profs at McMaster sent me an email.
22:39:33 <pumpkin> PhD?
22:39:47 <Cale> pumpkin: Master's to start with
22:39:48 <ddarius> roconnor cornering you?
22:39:52 <Cale> ddarius: Well, some areas are tricky. I had a very difficult time with number theory.
22:39:56 <Cale> Hm?
22:39:59 <pumpkin> ah
22:40:04 <Cale> (to picture)
22:40:59 <cads> yeah, give me horrible fourier analysis on crazy precise electromatic waves, as long as I can conceptualize how each thing contributed to something that can be seen
22:41:01 <ddarius> I'll give you elementary number theory, albeit with an interest in combinatorics, I would think you could apply something.
22:41:16 <ddarius> What you do is apply complex analysis to number theory.
22:41:24 <Cale> Well, there is that.
22:42:52 <Cale> I took a course in algebraic number theory, which was sort of applying Galois theory to number fields, and studying how factorisation works in their rings of integers.
22:43:39 * ddarius has only read (chapters of) books on algebraic number theory.  And that, quite a while ago.
22:43:40 <Cale> There are some lovely things there, but... just as often there's a horrible mess of case analysis to get even small scraps.
22:44:08 <Cale> Like, things breaking down into cases modulo 8 and such... it's just evil :)
22:44:32 <ddarius> The way those cases come up in number theory (not just algebraic) is intriguing.
22:46:16 <ddarius> Poor case analysis.  Mathematicians don't like it, programmers don't like it, nobody likes it.
22:46:23 <cads> I hate how the ephanies that people have when they explore a new field are deep inside... you always have to make your way through enless cruft because you hit upon the discovery that makes all the dull stuff you've been squezzning though turn into amazing gold
22:46:26 <Cale> Oh, and the ideal class group is a lovely concept, but flying spaghetti monster help you if you ever need to calculate one. (Though I think we actually missed out on developing some of the theorems which are supposed to make it simpler)
22:47:06 <maurer1> Hey, does splitting the RNG make it horribly slow? I'm running a simulator and 40-50% of the time is being spent generating random numbers for some reason.
22:47:57 <Cale> maurer1: I don't think the resulting generators should be any slower than the original, but System.Random's performance in general is kind of poor.
22:48:04 <maurer1> The function in question is at http://matthewmaurer.org/snip and is being fed an input of order 100
22:48:13 <maurer1> Cale: Is there another generator?
22:48:27 <Cale> There are some on Hackage...
22:48:30 <maurer1> OK
22:48:31 <maurer1> Thanks
22:49:21 <Cale> oh, the random-fu package looks neat
22:49:49 <Cale> hmm
22:49:49 <johnw> can I have multiple type signatures for the same function name?
22:50:01 <Cale> But... it doesn't seem to give instances of the Random class.
22:50:05 <Cale> er, RandomGen
22:50:19 <ddarius> johnw: Not in the way you probably mean.
22:50:25 <Pseudonym> Do you mean you want more than one function with the same name?
22:50:43 <johnw> like, one "foo" that takes Char -> Char, and another "foo" that takes [Char] -> [Char]?
22:50:49 <Pseudonym> Yes.
22:50:53 <Pseudonym> :t id :: Char -> Char
22:50:54 <lambdabot> Char -> Char
22:50:58 <Pseudonym> :t id :: [Char] -> [Char]
22:50:59 <lambdabot> [Char] -> [Char]
22:51:10 <johnw> how do I declare that?
22:51:15 <Pseudonym> :t id
22:51:15 <lambdabot> forall a. a -> a
22:51:17 <Pseudonym> Like that.
22:51:21 <Pseudonym> You don't need the forall.
22:51:23 <Pseudonym> id :: a -> a
22:51:26 <ddarius> Haskell people entertain me.
22:51:29 <johnw> ah, thanks
22:51:39 <Pseudonym> That's assuming that this is the real type that you want.
22:51:49 <Cale> johnw: uh... this is perhaps misleading
22:51:51 <Pseudonym> If what you want is actual overloading, then you need to be a bit more principled.
22:52:04 <Pseudonym> johnw, do you have a concrete example?
22:52:08 <johnw> i'm trying to write a function fro computing abjab notation
22:52:16 * ddarius thinks parametric polymorphism is quite a bit more principled than even Haskell's type classes.
22:52:23 <johnw> here's what I have: http://gist.github.com/77338
22:52:25 <Cale> johnw: If you give a polymorphic type like that, your function is not allowed to care about the values of that type as it works with them.
22:52:32 <Pseudonym> ddarius: Actually, no.  id is one function.
22:52:44 <Pseudonym> If you want more than one function with the same name, you need to be more principled.
22:52:46 <johnw> i want to pattern match on the chars to turn them into numbers, then on strings to turn it into a list of numbers
22:52:56 <Pseudonym> Writing one function with one name, you don't have to be so principled.
22:53:03 <ddarius> Pseudonym: I'd say you need to be less principled.
22:53:10 <Cale> johnw: I would probably just use 'map'
22:53:18 <johnw> ah, thanks
22:53:28 <Pseudonym> Another option here is type classes.
22:53:38 <Pseudonym> class Abjad a where
22:53:39 <ddarius> Though I guess you need to have more internal virtue to resist temptation in the former case.
22:53:43 <Pseudonym>   abjad :: a -> a
22:53:44 <Cale> johnw: That is just write the function for Chars, and apply map when you need to use it on strings.
22:53:48 <Pseudonym> instance Abjad Char where
22:53:50 <Pseudonym>   ...
22:53:54 <Pseudonym> instance Abjad String where
22:53:58 <Pseudonym>    abjad = fmap abjad
22:54:03 <Pseudonym> Or map, yeah.
22:54:05 <johnw> i was hoping for the ability to write: abjad "..." and abjad '.'
22:54:12 <johnw> this is more for my understanding, if it's possible
22:54:18 <Cale> Yeah, for that, you'll need a typeclass.
22:54:33 <Cale> (as Pseudonym just wrote)
22:54:34 <Pseudonym> There's nothing wrong with using the same name for a function which works on both things and lists of things.
22:55:03 <ddarius> Pseudonym: Does it then also work on lists of lists of things?
22:55:15 <Pseudonym> instance (Abjad a) => Abjad [a] where
22:55:19 <Pseudonym>     abjad = map abjad
22:55:20 <Pseudonym> Done.
22:55:47 <Pseudonym> But if you don't need it...
22:56:53 <ddarius> The last has the benefit of being Haskell 9.
22:56:55 <ddarius> er 98
22:57:00 <Pseudonym> Yes.
22:57:08 <Pseudonym> That's true.
23:03:37 <johnw> I'm getting this: http://gist.github.com/77341
23:04:23 <johnw> (gist is messing up the right-to-left a bit)
23:09:18 <Cale> johnw: Yeah, you can either add {-# LANGUAGE TypeSynonymInstances #-}  (and maybe FlexibleInstances too?) or change the instance to be  instance Abjad a => Abjad [a] where ...
23:09:28 <Cale> Also, (+) is the wrong operator there.
23:09:41 <Cale> You probably want :
23:10:04 <johnw> well, I want one functino to be Char -> Int, and the other to be String -> Int, so wouldn't + result in a sum?
23:10:24 <Cale> oh... I misread sorry
23:10:29 <johnw> if I do instance (Abjad a) => Abjad [a], isn't that going to turn a list of chars into a list of integers?
23:10:31 <Cale> yeah, that's appropriate then
23:10:43 <Cale> Yes
23:10:48 <Pseudonym> johnw: Not if you declare your class correctly.
23:10:48 <Cale> String = [Char]
23:10:49 <Pseudonym> Then you'd say:
23:10:54 <Pseudonym> class Abjad a where
23:10:58 <Pseudonym>     whatever :: a -> Int
23:11:05 <Cale> That's what he has.
23:11:08 <Pseudonym> Ah.
23:11:09 <Pseudonym> Sorry.
23:11:11 <Cale> Oh, into a list of integers? No.
23:11:18 <johnw> what are type synonym instances?
23:11:27 <Pseudonym> johnw: You don't need to know.
23:11:31 <johnw> k
23:11:39 <Cale> johnw: Well, I can explain anyway...
23:11:42 <johnw> i guess i don't understand what's wrong with my a = String instance
23:11:59 <Pseudonym> Well, yeah, but to be honest, I'd rather just tell people to -fglasgow-exts and do what comes naturally.
23:12:15 <Cale> johnw: There was a silly rule in Haskell 98 which said type synonyms can't be used in instance declarations, that option turns it off.
23:12:19 <Pseudonym> It's harder to explain what the H98 limitation is.
23:12:44 <lifflander> Hey everyone.
23:12:49 <Cale> Hello!
23:12:58 <johnw> hmm.. {-# LANGUAGE TypeSynonymInstances #-} changes nothing
23:13:14 <johnw> is my syntax incorrect?
23:13:14 <lifflander> Is there a standard library function for a Timer or Stopwatch?
23:13:27 <Cale> johnw: Exact same error?
23:13:29 <johnw> yeah
23:13:37 <johnw> i'm using GHC 6.10.1
23:14:50 <Pseudonym> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2294#a2294
23:14:58 <Pseudonym> I have no idea why that error appears.
23:14:58 <Cale> hmm, adding {-# LANGUAGE TypeSynonymInstances #-} to the top of the file works for me
23:15:00 <lifflander> Does anyone know of a function? I guess I can use getCurrentTime...and DiffTime
23:15:09 <Cale> lifflander: hmm
23:15:26 <Cale> lifflander: I don't think there's a standard one, but there's also :set +s  in ghci
23:15:30 <Cale> (if that's sufficient)
23:15:43 <johnw> ah, all I needed was instance (Abjad a) => Abjad [a] where
23:15:44 <Cale> It'll print timing and allocation stats.
23:15:48 <lifflander> I actually need to measure the time of a bunch of different operations in a program.
23:15:51 <johnw> apparently instance Abjad String where was incorrect
23:15:52 <Cale> johnw: yeah, that also will work
23:16:28 <lifflander> Individually...so that won't work
23:16:29 <Cale> johnw: Not so much incorrect as just forbidden by the usual standard's overly conservative rules.
23:16:32 <johnw> that did it: http://gist.github.com/77341
23:16:46 <Pseudonym> johnw: BTW, congratulations on being successfully brainwashed.  You are indeed thinking like a Haskell programmer.
23:16:50 <johnw> thanks guys, it makes sense now (and introduces me to type classes)
23:17:01 <johnw> Pseudonym: how so?
23:17:03 <Cale> lifflander: So yeah, probably getCurrentTime is your best bet.
23:17:09 <lifflander> Okay, thanks.
23:17:22 <Pseudonym> Because you figured that what you were doing was sensible and there should be a way to get away with it.
23:17:30 <wli> Hmm. When K contains Q and there's some algebraic extension E of K(x) the construction of an integral basis for E over K(x) is a bit vague.
23:17:37 <Pseudonym> The brainwashing was successful because what you were doing actually WAS sensible.
23:18:25 <johnw> hah, thanks
23:19:18 <Cale> wli: Was this prompted by my earlier comment about algebraic number theory?
23:19:37 <wli> The elements of K(x)\{0} that are supposed to premultiply the ordinary basis elements to yield an integral basis are only specified in terms of existence by Bronstein.
23:19:47 <Pseudonym> Could someone please try that paste in a GHC that's more recent than 6.8?
23:19:52 <Pseudonym> It seems like it might be a bug.
23:19:56 <Pseudonym> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2294#a2294
23:20:05 <wli> Cale: No, by conal's simplification of derivatives problem.
23:20:15 <Pseudonym> But it also seems like the sort of thing that might already be fixed.
23:22:15 <wli> Cale: You want the things to be integral over K(x) so Bezout works (NFI how I'm going to pull that off, if I ever get to it).
23:22:51 <Cale> Over the field of rational functions?
23:22:57 <Pseudonym> Gotta go.
23:22:58 <Pseudonym> Nytol.
23:23:04 <Cale> Or is x an algebraic thing?
23:24:06 <wli> Cale: x is an indeterminate (heck, you differentiate with respect to it) and K is an extension of Q.
23:24:26 <Cale> okay
23:24:39 <Cale> (I don't know anything about the surrounding context here ;)
23:25:17 <wli> conal had an article on automatic differentiation with difficulties surrounding simplification.
23:25:17 <Cale> Unfortunately, most of what I know about integral bases, I studied only over Q.
23:25:52 <Cale> (that is in algebraic extensions of Q)
23:26:51 <wli> "My" answer to the simplification problem is to reduce the symbolic simplification problem to finding coefficients of basis elements in the linear algebraic sense.
23:27:20 <wli> Albeit by restricting the forms of the functions considered somewhat.
23:27:24 <b\6> Data.Accessor.Template deriveAccessors doesn't seem to be generating type signatures for the accessor functions.
23:28:18 <wli> I'm mostly winging this by re-using various sub-results/sub-algorithms/etc. used for symbolic integration.
23:31:39 <wli> I'm not entirely sure why this would care about integral bases so long as you can rationalize denominators, but there are issues following the directions resolves, like how to find "best representations."
23:33:23 <Cale> hmm
23:33:28 <wli> I'm overcomplicating more basic things right now.
23:33:33 <Cale> Interesting to see it show up anyway :)
23:35:26 <wli> I'm already lost with respect to finding minimal polynomials for radical expressions anyway, so this is putting the cart before the horse by a longshot.
23:36:32 <wli> (e.g. minimal polynomials for ((x^2+1)/(x^3-3))^(1/2) + ((x^2-1)/(x^3+3))^(1/3))
23:37:51 <wli> My only guess is to just raise things to powers until a linear dependence is found.
23:38:03 <wli> i.e. brute force
23:39:45 <wli> Except that gets you into the circular dependence of having some sort of basis for everything to discover the linear dependence.
23:39:52 <harblcat> Conversion from base ten to an arbitrary base. Any ideas on how I could do so?
23:40:53 <pumpkin> an integer base?
23:41:00 <pumpkin> :P
23:41:11 <wli> Base 2i ;)
23:41:26 <pumpkin> omg!
23:41:35 * pumpkin tries to figure out how to write numbers in base 2i
23:41:54 <wli> pumpkin: Check Don Knuth's HS science project.
23:41:59 <pumpkin> :o
23:42:02 <harblcat> Yes, thankfully, an integer base. (240 to be exact)
23:42:31 <pumpkin> harblcat: what symbols will you use for the "digits"?
23:43:03 <pumpkin> it's a pretty standard procedure
23:43:04 <harblcat> What I am looking as is a function Int -> String, and I'll be using a list of vowel-consonant and consonant-vowel pairs as the digits.
23:43:40 <harblcat> Mainly just trying to turn a really big number into a pronouncable blob
23:44:41 <pumpkin> ah
23:44:51 <pumpkin> well, think about how you convert to more typical bases
23:45:44 <harblcat> Hmm..
23:49:29 <koala_man> harblcat: for identifying the number or for generating words?
23:49:46 <harblcat> generating words
23:50:03 <koala_man> have you considered markov chains?
23:50:22 <harblcat> I'm not that familiar with them, no...
23:51:22 <koala_man> it's a very simple concept. you build them from a dictionary or text and then you can use it to generate statistically similar words or texts
23:52:18 <SubStack> a markov algorithm would be good for that
23:53:01 <SubStack> they're easy to implement too
23:53:22 <harblcat> Mm, I'm not too worried about them sounding real. I'm using them in a space game :P
23:53:31 <SubStack> nifty
23:53:33 <harblcat> That is a nice idea, though.
23:53:46 <SubStack> just find some good space-sounding seed names
23:54:28 <SubStack> http://netlib.bell-labs.com/cm/cs/pearls/sec153.html
23:54:46 <SubStack> except for all of the ugly c code, a good place to start
23:56:44 <pumpkin> nmergeIO looks pretty cool
23:59:03 <harblcat> SubStack: thanks for the link
