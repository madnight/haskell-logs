00:01:54 * wli might even go so far as to splatter out a long list of US states as a big coproduct type etc.
00:02:26 <wli> Maybe fiddling around with Canadian addresses etc. as possibilities, too.
00:02:56 <rovar> where db_put takes a Db, but I have an IO Db.  how can I use that Db handle?
00:09:50 <rovar> i guess in order to avoid running everything inside of a single IO monad I need to return Db from IO Monad in which it's created
00:11:52 <Cale> rovar: Inside a do block, if you write v <- x where x :: IO t, then v :: t. It means to run the action x and name its result v.
00:12:18 <Cale> Of course, the do-block as a whole is an expression of type IO s for some type s.
00:12:29 <Cale> rovar: Does that make sense?
00:13:06 <Cale> For example...  getLine :: IO String. When it's run, it gets a line of text from the user.
00:13:35 <Cale> So  (do x <- getLine; putStrLn x) :: IO ()  will get a line of text from the user and print it back out.
00:13:43 <rovar> Cale, I think I understand that part, I'm just trying to figure out how to escape tho monad
00:13:58 <Cale> rovar: Well, what do you want to *do* with the Db handle?
00:14:32 <yitz> harblcat: sorry I was away. Yes, I think it is much better do declare a meaningful type rather than just aliasing a tuple. It will make your program much more readable.
00:14:37 <Cale> Presumably, you want to do some database queries and output something.
00:14:49 <Cale> (or do something else which is visible)
00:15:10 <yitz> good morning Cale. up early today I see. :)
00:15:35 <olsner> @localtime Cale
00:15:35 <lambdabot> Local time for Cale is Sun Mar  1 03:15:35
00:15:48 <Cale> Up late, really.
00:16:04 <Cale> I haven't gone to bed yet :)
00:16:04 <rovar> Cale, yes. However, I run these queries in separate functions.
00:16:24 <Cale> rovar: So these functions take a value of type Db as a parameter?
00:16:32 <Cale> rovar: and what's their result type?
00:17:03 <rovar> IO()
00:17:25 <Cale> rovar: Right, okay.
00:17:27 <rovar> however, I run them within my own functions which are generally type Net() which is a ReaderT
00:17:45 <Cale> Well, that's okay.
00:17:51 <Cale> You can liftIO
00:17:57 <rovar> right, i do that
00:18:30 <Cale> So it'll look something like...
00:18:51 <Cale> do db <- getDb; f1 db; f2 db; ...
00:19:09 <Cale> Where getDb :: IO Db
00:19:15 <Cale> and so db :: Db
00:21:12 <somnolence> :t chan
00:21:14 <lambdabot> Not in scope: `chan'
00:21:18 <somnolence> @t chan
00:21:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:21:23 <somnolence> @chat
00:21:23 <lambdabot>  @where <key>, return element associated with key
00:23:13 <yitz> @hoogle TChan
00:23:13 <lambdabot> module Control.Concurrent.STM.TChan
00:23:13 <lambdabot> Control.Concurrent.STM.TChan data TChan a
00:23:13 <lambdabot> Control.Concurrent.STM.TChan dupTChan :: TChan a -> STM (TChan a)
00:23:41 <yitz> @hoogle Chan
00:23:41 <lambdabot> module Control.Concurrent.Chan
00:23:41 <lambdabot> Control.Concurrent.Chan data Chan a
00:23:41 <lambdabot> package change-monger
00:27:07 <rovar> Cale, so I'm doing   db <- asks db, which gets the IO Db from the readerT
00:27:42 <rovar> I can't pass that into db_put
00:28:11 <Cale> It's very important to understand that an IO String is not at all like a String.
00:28:30 <rovar> right
00:28:44 <rovar> i guess the answer is that any function of mine that calls db_* needs to run in IO
00:28:48 <Cale> If you have an IO Db, all you have to do is run it to get a Db.
00:29:07 <Cale> and you can only do so inside of an IO action, yes.
00:29:11 <Cale> That's sort of the point ;)
00:29:18 <Cale> However!
00:29:38 <Cale> You can write a function which takes a Db as a parameter, and whose result is not in IO (potentially)
00:29:49 <Cale> and then simply pass the appropriate Db to it.
00:30:17 <rovar> Cale, right, the problem is that unless I'm in an IO monad, I can't get just Db
00:30:18 <Cale> However, just due to the nature of the names involved here, I doubt you have many functions which take a Db and don't produce something in IO
00:30:40 <Cale> rovar: You can if you simply take a Db as a parameter.
00:31:08 <Cale> At a higher level, you'll write an IO action which gets the Db value by running another IO action, and then passes that Db to your function.
00:31:28 <rovar> yea..
00:31:38 <rovar> that's kinda what I'm changing things around to do...
00:41:33 <rovar> arg.. okay.. i have a function which needs to run in Net() because it retrieves and updates state, but it also needs to call a db_* function
00:43:53 <rovar> insertPC' :: C8.ByteString -> IO Db -> PC -> IO ()
00:43:54 <rovar> insertPC' s db pc = db_put [] db Nothing s $ lazyToStrict (encode pc)
00:46:10 <Cale> rovar: Why does it take an IO Db as a parameter?
00:46:36 <rovar> because it's infeasible for me to pass it a Db parameter
00:46:40 <Cale> why?
00:46:58 <pumpkin_> I've never seen anything taking an IO as input
00:47:00 <Cale> Does db_put take an IO Db as a parameter? I thought it didn't.
00:47:01 <pumpkin_> other than unsafePerformIO
00:47:02 <rovar> this function is called by a chain of functions in the Net() monad
00:47:16 <Cale> pumpkin_: Lots of things do... but they're control-structure-like.
00:47:26 <Cale> rovar: So?
00:47:30 <pumpkin_> well, I've seen things take m a
00:47:36 <Cale> Isn't the Net monad a MonadIO?
00:47:36 <pumpkin_> but it's not IO-specific
00:47:42 <Cale> pumpkin_: Oh, there's forkIO
00:47:48 <pumpkin_> ah true :)
00:47:56 <rovar> Cale, Net is a ReaderT
00:47:59 <Cale> and bracket
00:47:59 <wli> What's PC?
00:48:06 <rovar> a record
00:48:11 <Cale> rovar: over IO?
00:48:16 <pumpkin_> @hoogle IO a -> b
00:48:16 <lambdabot> Foreign unsafePerformIO :: IO a -> a
00:48:16 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
00:48:16 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
00:48:18 <rovar> ultimately, yea
00:48:18 <wli> A record standing for what?
00:48:28 <Cale> rovar: "ReaderT" isn't a complete monad on its own.
00:48:35 <Cale> It's something which transforms other monads.
00:48:49 <rovar> type Net = ReaderT Bot (MS.StateT Stuff IO)
00:49:12 <Cale> rovar: Okay. So that will be an instance of MonadIO
00:49:16 <Cale> and so liftIO will work.
00:49:22 <Cale> So I don't see what your problem is.
00:49:44 <Cale> Suppose getDb :: IO Db, then  liftIO getDb :: Net Db
00:50:00 <Cale> (well, it's more general really, but it specialises to that type)
00:50:30 <Cale> So you can run that action inside a Net computation, and get the Db as a result.
00:50:33 <rovar> Cale, the problem is that I call loadDb once at the very start of the program and I wish to store the db handle i create for later use
00:50:54 <Cale> rovar: okay
00:51:07 <rovar> it's impractical to call more than once.
00:51:30 <yitz> @hoogle IO a -> t b
00:51:30 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
00:51:30 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
00:51:30 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
00:51:31 <Cale> exactly, which is why I'm wondering why you're passing IO Db's around
00:51:48 <Gracenotes> rovar: I'm wondering, why not StateT Stuff (ReaderT Bot IO)?
00:52:00 <Cale> Gracenotes: Those... are the same.
00:52:25 <Gracenotes> yes, but surely there's a reason to choose one over the other
00:52:30 <Cale> Not really.
00:52:44 <yitz> rovar: pass it around as a parameter, or put it into a Reader
00:52:44 <rovar> data Bot = Bot { socket :: Handle, db :: IO Db }
00:52:51 <Cale> They're not *exactly* the same of course.
00:52:55 <Gracenotes> I dunno. I'd have Bot closer to IO, since Bot does the more IO-y stuff :)
00:53:02 <Cale> The number of lifts needed are slightly different
00:53:05 <Gracenotes> instead of mucho lifting
00:53:11 <rovar> yitz, I could pass it around as a parameter, but I thought that this was the whole point of monads so that I don't have to
00:53:19 <Cale> But there's automatic lifting instances for MonadState and MonadReader
00:53:34 <rovar> and I can't put it into a Reader, afaik because I can't return just Db from loadDb
00:53:39 <yitz> rovar: yes, a reader monad abstracts that out of your code.
00:54:13 <rovar> i'd have to return IO Db to load it into the reader's state
00:54:14 <Cale> rovar: ...
00:54:17 <rovar> yar?
00:54:36 <Cale> loadDb will likely be of type IO Db, but *running* loadDb will give you a Db
00:54:47 <rovar> yes
00:54:50 <Cale> and once you have that, you can pass it as a parameter to anything which needs it
00:54:56 <rovar> true
00:55:01 <jfredett> ... I'm trying to avoid some unnecessary do-notation, I have a type m [Bool], and I want to apply (and) to the list... liftM doesn't fit, return/pure doesn't fit... I'm a bit lost, someone aim me in the right direction?
00:55:02 <yitz> rovar: so at the top level do db <- getConn; runReaderT doStuff db
00:55:03 <rovar> so can i runIO it?
00:55:08 <Cale> Including by sticking it into the ReaderT's environment
00:55:28 <Cale> rovar: Somewhere, perhaps in your definition for main
00:55:43 <jfredett> straight bind doesn't work out either... maybe I should just hoogle this. thats a good idea...
00:55:49 <Cale> rovar: You write...  do db <- loadDb "..."; doStuffWith db
00:56:07 <Cale> rovar: Then db :: Db
00:56:13 <Cale> rovar: Is that clear?
00:56:35 <jfredett> aha! <$> from applicative. hurrah for hoogle, hoogle++
00:56:50 <jfredett> oh- wait, thats the wrong type too.
00:56:52 <jfredett> frack.
00:57:22 <beelsebob> no, that's right
00:57:23 <Cale> and if for whatever reason, you don't know which parameters to loadDb you want to give until you've done some computation in the Net monad, then you can simply liftIO the call to loadDb, but that's slightly inconvenient if true, because it would probably be nice to stick the Db into the ReaderT environment.
00:57:35 <beelsebob> jfredett: and <$> myMonadicList
00:57:53 <beelsebob> <$> or fmap or liftM applies a function one level inside a functor
00:57:56 <Gracenotes> or, as they say elsewhere, map and myMonadicList
00:58:00 <jfredett> hrm... really? I can just flip around that... OH!
00:58:04 <jfredett> I see it not.
00:58:09 <jfredett> beelsebob: Thanks.
00:58:13 <beelsebob> Gracenotes: myMonadicList :: m [Bool] not [Bool]
00:58:15 <jfredett> now*
00:58:20 <Gracenotes> beelsebob: oh, alas
00:58:23 <beelsebob> [[Bool]] even
00:58:31 <Gracenotes> so fmap it is
00:58:36 <beelsebob> yes
00:58:42 <beelsebob> but then <$> *is* fmap
00:58:47 <Gracenotes> yeah
00:59:36 <Gracenotes> :x
01:01:06 <ImInYourMonad> what should I define to make an applicative? any good tutorials on applicatives?
01:01:10 <jfredett> <$> = my new favorite function.
01:01:29 <jfredett> ImInYourMonad: pure and something, no?
01:01:55 <beelsebob> jfredett: next on the block <*> for extending it to multi-argument functions
01:02:03 <yitz> Cale, rovar: if computation is needed before getting the db ref, then you really don't need the full Net monad environment for that computation. it should be possible to do it in just IO.
01:02:07 <jfredett> :t <*>
01:02:08 <lambdabot> parse error on input `<*>'
01:02:10 <jfredett> :t (<*>)
01:02:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:02:15 <beelsebob> Ingmar: pure only in theory
01:02:16 <jfredett> nifty.
01:02:22 <beelsebob> ImInYourMonad: even
01:02:23 <beelsebob> pure only
01:02:36 <beelsebob> functor: fmap; applicative: pure; monad: join
01:02:37 <beelsebob> that's it
01:02:51 <yitz> but it sounds like anyway the first step is getting the db connection, so it should be fine without that.
01:02:59 <jfredett> beelsebob: no 'return' for monads?
01:03:01 <jfredett> hmm
01:03:04 <beelsebob> return = pure
01:03:07 <rovar> Cale, yitz, yea, I moved it into   connect :: IO Bot
01:03:18 <jfredett> sure- so you would have to add an applicative context to monads
01:03:33 <Cale> yitz: Yeah, but I was thinking that it's possibly the case that it's inconvenient to determine which DB to load without doing some Net-monad computation first.
01:03:33 <beelsebob> yes
01:03:36 <beelsebob> jfredett: they should have it
01:03:39 <beelsebob> it's a bug in the prelude
01:03:43 <jfredett> the way you said it, it looked like you were saying thats all you needed.
01:03:44 <Gracenotes> @src Functor
01:03:44 <lambdabot> class  Functor f  where
01:03:44 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
01:03:44 <Cale> yitz: In which case, probably liftIO would do the trick.
01:03:51 <Saizan_> beelsebob: fmap and pure don't give you (<*>)
01:03:53 <rovar> where i was able to run   db <- loadDb  ; return (Bot h db)
01:03:56 <jfredett> beelsebob: i would have to agree.
01:04:02 <beelsebob> Saizan_: oh, neither they do
01:04:09 <beelsebob> lame
01:04:09 <yitz> Cale: yes. it's a pretty uncommon case though. Fortunately.
01:04:36 <Gracenotes> fmap and pure and join give you <*>, I think... if join is defined >_>
01:04:37 <yitz> rovar: great!
01:04:50 <beelsebob> yeh, what I meant was actually...
01:05:05 <beelsebob> Functor: fmap; pointed: pure; applicative: ap; monad: join
01:05:22 <Saizan_> Gracenotes: right, but fmap, pure and <*> don't give you join :)
01:05:38 <Gracenotes> righto
01:05:49 <Gracenotes> maybe someone should make a dependency chart :) or graph, for the brave
01:06:03 * beelsebob fires up dot
01:06:11 <dibblego> Gracenotes, an example of an Applicative that is not a Monad is given in Applicative Programming with Effects
01:06:24 <yitz> Gracenotes: how about byorgey's blog post?
01:06:35 <dibblego> "fmap, pure and <*>" == Applicative
01:06:59 <Cale> Gracenotes: Every monad is applicative.
01:07:00 <Gracenotes> yitz: which one?
01:07:08 <Gracenotes> Cale: and a functor
01:07:12 <Cale> Gracenotes: yes
01:07:13 <yitz> uhhh enclyclosomething....
01:07:20 <Cale> and every applicative is a functor too
01:07:30 <Gracenotes> oh. hm.
01:07:36 <Saizan_> @google typeclassopedia
01:07:37 <lambdabot> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
01:07:37 <lambdabot> Title: The Typeclassopedia — request for feedback « blog :: Brent -> [String]
01:07:44 <yitz> that's it!
01:07:44 <Gracenotes> fmap using just <*> and pure?
01:07:49 <Gracenotes> @type <*>
01:07:50 <lambdabot> parse error on input `<*>'
01:07:54 <Gracenotes> @type (<*>)
01:07:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:07:58 <Cale> Gracenotes: Applicative is a subclass of Functor.
01:08:10 <Gracenotes> ah.
01:08:24 <Cale> Monad should be too, but it's not, by accident.
01:09:00 <Cale> Monad could even be a subclass of Applicative... and quite possibly ought to be.
01:09:04 <yitz> Monad should be a subclass of Applicative. but it's not that either, by accident
01:09:17 <patchwork> #dog
01:09:29 <Gracenotes> and if you have Applicative and Functor, I suppose you just need join
01:09:31 <Cale> patchwork: no, this is #haskell...
01:09:54 <yitz> Gracenotes: right. or bind.
01:09:57 <Gracenotes> or >>=, to be trivial.
01:10:01 <Gracenotes> ish.
01:10:11 <beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/dep.pdf <-- one dependancy tree
01:10:16 <beelsebob> DAG even
01:10:34 <Gracenotes> oh, I've seen the dependency of typeclasses in terms of what-is-a-something-else
01:11:03 <Gracenotes> but not anything like "fmap and pure and join give you <*>" I suppose that's more CT-y.
01:11:11 <beelsebob> oh, I see
01:11:20 <beelsebob> hmm
01:11:27 <Gracenotes> I think the way to prove that is to write it :P
01:11:27 <beelsebob> I'm not sure how to do that
01:11:27 <patchwork> Cale:  trying to join without the /join :)
01:12:14 <rovar> Cale, thanks for your help
01:12:23 <rovar> and everyone else
01:12:25 <Cale> rovar: no problem :)
01:13:10 <Gracenotes> now, if we just have djinn the super undecidable powers of polymorphism...
01:13:13 <Gracenotes> *gave
01:15:35 <mmorrow> pumpkin_: haha, they must be super leet then
01:16:01 <mmorrow> pumpkin_: is one of them "catchfireandhalt"?
01:16:12 <Saizan_> ?src ap
01:16:12 <lambdabot> ap = liftM2 id
01:16:17 <Saizan_> ?src liftM2
01:16:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:16:22 <Saizan_> QED
01:16:23 <Cale> Gracenotes: I want Djinn to prove the Riemann hypothesis :(
01:16:24 <pumpkin_> mmorrow: nope :) but I think it's just a bug
01:16:27 <rovar> ?type words
01:16:28 <lambdabot> String -> [String]
01:16:47 <mmorrow> pumpkin_: weird. maybe they're as pseudo-instructions
01:17:04 <mmorrow> (as := gas, not the word "as" ;)
01:17:20 <Gracenotes> Cale: I have a better idea. I'll start looking for exceptions to the Riemann hypothesis, and if I halt, then it's false
01:17:26 <mmorrow> (dunno if that was ambiguous)
01:17:53 <Cale> Gracenotes: :) People have checked an awful lot of the roots.
01:18:22 <ImInYourMonad> is there a good graph library for testing ant colony optimization?
01:18:49 <mmorrow> ImInYourMonad: oh cool, i have a book that's kinda on that subject. interesting stuff
01:19:12 <rovar> hot damn it works :)
01:19:40 <mmorrow> ImInYourMonad: (answer being i don't think so, but i'm not positive what that would entail)
01:19:52 <rovar> i still can't get over the fact that I can struggle for a while getting haskell apps to compile but once it compiles, it just works.
01:19:57 <yitz> rovar: yay!
01:20:01 <rovar> even when mucking with berkeley db's :)
01:20:27 <mmorrow> rovar: after a while a split second glance at the error msg and you'll know exactly what happened
01:20:57 <rovar> mmorrow, what's sick is I can do that with template errors in c++
01:21:12 <rovar> i hope it wont take as long to learn that trick for haskell :)
01:21:15 <mmorrow> hehe, it's only a matter of time then
01:21:28 <rovar> my next project is to find out what
01:21:29 <rovar> -- Set up actions to run on start and end, and run the main loop
01:21:31 <rovar> main :: IO ()
01:21:32 <rovar> main = bracket connect disconnect loop
01:21:34 <rovar>     where
01:21:35 <rovar>     disconnect = hClose . socket
01:21:37 <rovar>     loop st    = do
01:21:38 <rovar>         catchIO (evalStateT (runReaderT run st) (Stuff (mkStdGen 100) [] )) (const $ return ())
01:21:40 <rovar> -- Connect to the server and return the initial bot state
01:21:40 <ImInYourMonad> to write a parser for a genetic algorith, language, would you use Parsec or is it to slow?
01:21:41 <rovar> connect :: IO Bot
01:21:43 <rovar> connect = notify $ do
01:21:44 <rovar>     h <- connectTo server (PortNumber (fromIntegral port))
01:21:46 <rovar>     hSetBuffering h NoBuffering
01:21:48 <rovar>     return (Bot h (loadDB) [])
01:21:50 <rovar>     where
01:21:52 <rovar>         notify a = bracket_
01:21:54 <rovar>             (printf "Connecting to %s ... " server >> hFlush stdout)
01:21:56 <rovar>             (putStrLn "done.")
01:21:58 <rovar>             a
01:22:00 <rovar> dammit.. sorry
01:22:02 <rovar> $(derive makeBinary ''PC)
01:22:03 <mmorrow> heh
01:22:04 <rovar> figure out what that is doing.
01:22:14 <rovar> ImInYourMonad:  have you looked at HGA?
01:22:37 <ImInYourMonad> what is an arrow? what does &&& *** etc do?
01:22:42 <mmorrow> ImInYourMonad: what is it you'd be parsing?
01:22:49 <wli> IMAP might be more interesting, but anyhow.
01:23:00 <wli> esp. the asynchronous bits.
01:23:00 <mmorrow> f *** g = \(x,y) -> (f x, g y)
01:23:09 <mmorrow> f &&& g = \x -> (f x, g x)
01:23:23 <mmorrow> basically
01:23:59 <mmorrow> if you're using another Arrow other than (->), it'd be analogous
01:24:03 <pumpkin_> mmorrow: nope, just wrong :)
01:24:10 <pumpkin_> found a bug report on them
01:24:11 <mmorrow> pumpkin_: hah
01:24:13 <pumpkin_> but no one's touched it
01:24:30 <mmorrow> why were they there in the first place?
01:24:42 <wli> Format strings are horrible.
01:24:48 <wli> I'd advise against using printf.
01:24:48 <yitz> pumpkin_: post a patch to fix the hardware
01:25:07 <wli> Or scanf
01:25:18 <pumpkin_> mmorrow: someone probably used a regex to change the big table and went too far
01:25:21 <ImInYourMonad> hga?
01:25:35 <Gracenotes> f <*> a = join (fmap (\f' -> join (fmap (\a' -> pure (f' a')) a)) f) -- <*> written using join, fmap, and pure
01:25:39 <pumpkin_> yitz: thankfully there will be no need for that :)
01:25:41 <ImInYourMonad> mmorrow: i need runtime dynamicism.
01:25:52 <rovar> ImInYourMonad: http://74.125.47.132/search?q=cache:ssapRszapVcJ:www.haskell.org/haskellwiki/GPLib+haskell+genetic+paul+berg&hl=en&ct=clnk&cd=1&gl=us&client=firefox-a
01:26:00 <Gracenotes> @type \f a -> join (fmap (\f' -> join (fmap (\a' -> pure (f' a')) a)) f)
01:26:01 <lambdabot> forall a a1 (m :: * -> *). (Monad m, Applicative m) => m (a -> a1) -> m a -> m a1
01:26:19 <rovar> I'm not sure how good that library is, but it might be a good starting point for GA
01:26:27 <rovar> (haskell.org wiki is down?)
01:26:40 <mmorrow> ImInYourMonad: dynamic wrt what?
01:26:43 <ImInYourMonad> create a bunch of functions at runtime, apply them to the args and eval, resample near the best ones, continue this for X amount of geenrations
01:27:05 <mmorrow> ImInYourMonad: ok, but at what level do you want to create these functions?
01:27:07 <wli> Eh? No sprintf?
01:27:12 <Gracenotes> haskell.org looks slow in general
01:27:20 <ImInYourMonad> but what is the point of arrows, that it just some convenience right`?
01:27:20 <mmorrow> (the lowest being you want to dynamically generate machine code)
01:27:37 <Gracenotes> it doesn't like my PING :(
01:27:49 <yitz> Gracenotes: yeah, I also noticed that. I wonder who to notify.
01:27:56 <mmorrow> ImInYourMonad: they're for adding some extra implicit stuff to functions (in a sense)
01:29:01 <mmorrow> ImInYourMonad: imagine you have a datatype that models the various things you'd want these functions to do
01:29:23 <mmorrow> data Exp = App Exp Exp | Lit Int | ....
01:29:27 <mmorrow> then just write a
01:29:43 <mmorrow> compile :: Exp -> (Int -> Int)  -- or whatever type
01:30:33 <mmorrow> compile (e `App` e') = \x -> (compile e) ((compile e') x)
01:30:34 <mmorrow> ..
01:31:12 <ImInYourMonad> mmorrow: what do you mean at what level? i did it in clojure already. then i did ont he form '(* :x :x :y) , '(+ 3 :x (- :y :z)) etc
01:31:42 <rovar> is it possible to do such things with template haskell?
01:31:50 <mmorrow> ImInYourMonad: ok, so you want to symbolically build expressions, then evaluate them
01:31:56 <ImInYourMonad> i read now
01:32:08 <mmorrow> so make an Exp datatype, + a compile/eval function :)
01:32:12 <ImInYourMonad> mmorrow: thats what i did, not sure it is the best way
01:32:28 <mmorrow> well, that's what you were doing in clojure
01:32:36 <mmorrow> the datatype was just implicit there
01:32:50 <mmorrow> (and it coincided with the datatype for the AST for clojure expressions)
01:32:59 <mmorrow> , [|\x -> x|]
01:33:02 <lunabot>  LamE [VarP x_0] (VarE x_0)
01:36:21 <rovar> http://www-users.cs.york.ac.uk/~mfn/hhi/hhi.pdf
01:37:00 <mmorrow> rovar: that's a cool one
01:37:18 <jfredett> hmm, one combinator library in 4 hours, thats a good nights work...
01:37:25 <jfredett> gnite folks, thanks again for the help beelsebob
01:37:31 <jfredett> et al
01:38:11 <mmorrow> ImInYourMonad: so what you're looking to do is to write an interpreter for some language, expression of which you'll be generating
01:39:52 <mmorrow> ImInYourMonad: in clojure, you happened to be using the same language you were programming in. this doesn't necessarily have to be the case, but in can be for sure. also, since quote/eval is built into lisp you essentially got that for free. that won't come for free in haskell, but it can definitely be done (although you probably don't want to do it ;)
01:40:39 <mmorrow> but if you for instance choose to use lambda calc, or SKI combinators, it'd be relatively easy to write an evaluator
01:41:04 <mmorrow> you could even use (some stripped down version of) lisp
01:42:15 <mmorrow> at the other extreme, you can use harpy to generate machine code for your expressions, and them run them on the metal.
01:42:30 <mmorrow> (that's what i meant by "at what level")
01:43:11 <rovar> that's kinda cool
01:43:54 <rovar> sigh..tonight  i've added 12 pdfs into my to-read list.. and removed 1
01:44:32 <mmorrow> a good nights work :)
01:45:08 <mmorrow> pumpkin_: i just put this here for reference http://moonpatio.com/repos/LIBS/Language/binutils/
01:45:20 <pumpkin_> yay, thanks
01:45:26 <pumpkin_> I hate the viewvc
01:45:42 <pumpkin_> well, I hate having anything to do with CVS :P
01:45:55 <rovar> time for sleep.. 'nite folks
01:50:02 <mmorrow> pumpkin_: all i see is  arm-dis.c
01:50:07 <mmorrow> is that it?
01:50:11 <pumpkin_> yup
01:50:36 <mmorrow> um, so gas doesn't assemble for arm?
01:51:00 <pumpkin_> oh, it does, but they have separate code for that I guess
01:51:16 <mmorrow> hmm
01:51:19 * mmorrow keeps looking
01:52:44 <pumpkin_> grep for something army like bxj
01:53:05 <pumpkin_> or setend
01:54:10 <pumpkin_> any elegant way to take four Ints and "concatenate" them to make a Word32?
01:54:22 <pumpkin_> without a fold and a list
01:54:38 <pumpkin_> or repeated shiftL and .|. :)
01:54:41 <mmorrow> hmm, i guess it's somewhere other than in opcodes/
01:54:55 <mmorrow> (which would be weird since every other arch has multiple files in there)
01:55:25 <mmorrow> pumpkin_: like as in you want the low 8bits of each?
01:55:33 <pumpkin_> yeah
01:55:37 <pumpkin_> and shiftL 24, 16, 8
01:55:56 <mmorrow> i'd just hardcode the unrolled version
01:55:57 <pumpkin_> I just wrote it out explicitly
01:56:00 <pumpkin_> yeah
01:56:04 <mmorrow> :)
02:02:05 <pumpkin_>  1 files changed, 786 insertions(+), 732 deletions(-)
02:14:35 <pumpkin_> mmorrow: end up finding the assembler?
02:16:13 <ManateeLazyCat> I download gtk2hs api "gtk.txt" from http://haskell.org/hoogle/res/gtk.txt, when i use "hoogle --convert=gtk.txt" to convert gtk.txt to gtk.hoo for api search, but when i move gtk.hoo to directory "~/.cabal/share/hoogle-4.0.0.5/", why hoogle can't work?
02:16:30 <mathijs> can someone please point me to a small overview of Functor, Applicative, Alternative, Monad, MonadPlus. I understand them all but I'm struggling with the relation between them. I can see that Monad and MonadPlus are 'stronger' than Applicative and Alternative, but sometimes (in case of parsec, which is monadic), it's not unusual to 'fall back' to applicative construction.
02:16:41 <pumpkin_> mathijs: typeclassopedia!
02:16:58 <pumpkin_> http://byorgey.wordpress.com/2009/02/16/the-typeclassopedia-request-for-feedback/
02:17:56 <kowey> dear #haskell - any comments on http://code.haskell.org/~kowey/tmp/confusion ?
02:18:12 <ManateeLazyCat> By default, hoogle search from .hoo file, i convert gtk.txt to gtk.hoo, why hoogle can't search string from gtk.hoo?
02:18:19 * kowey haves to gunther if he's hanging out here
02:18:19 <mathijs> pumpkin_: it's the pdf?
02:18:29 <pumpkin_> yes
02:18:55 <mathijs> pumpkin_: thanks, I heard about it, but expected it to be some wiki-like site :)
02:19:39 <kowey> the typeclassopedia makes pretty good use of its linearity
02:19:57 <kowey> and on his blog, byorgey said he would be open to its wikification when the final version comes out, I think
02:20:05 <pumpkin_> yup
02:20:12 <pumpkin_> and that he didn't want to do it himself, *wink*
02:20:16 <pumpkin_> mathijs ;)
02:23:05 <kowey> (i would also be interested to see what git-using Haskellers make of my reply to gunther above, re his version control indecision)
02:23:26 <pumpkin_> I like git a lot, but darcs is growing on me :)
02:23:57 <ImInYourMonad> which GUI lib comes with GHC?
02:24:03 <kowey> :-) may it continue to do so
02:24:04 <pumpkin_> I don't like that darcs seems to take linear time in the number of patches to get
02:24:25 <kowey> darcs get --lazy may help
02:24:38 <kowey> but it requires a hashed or darcs-2 repository on the remote end
02:24:54 <pumpkin_> ah, that's probably what's preventing it from being done on the GHC repo then?
02:25:04 <pumpkin_> cause GHC explicitly tells you not to actually get their repo
02:25:12 <pumpkin_> and to just download a recent tarball and then pull any changes
02:25:14 <kowey> no darcs 2 on darcs.haskell.org
02:25:20 <pumpkin_> because getting will take a bajillion years
02:25:39 <kowey> you can try this yourself maybe
02:25:45 <ManateeLazyCat> Someone help me, i generate gtk.hoo file, why hoogle can't search in it? I missing something?
02:25:47 <kowey> stick a hashed copy of GHC on code.haskell.org
02:25:51 <kowey> and see if it's any better
02:25:56 <pumpkin_> I don't have an account :)
02:25:59 <pumpkin_> but maybe sometime
02:26:10 <kowey> hmm...
02:26:53 <pumpkin_> but you also don't really go into many details about why darcs _over_ git
02:26:57 <pumpkin_> rather than just why darcs
02:27:05 <pumpkin_> you admit you don't know too much about git up front
02:27:14 <ray> i know about darcs already, i don't know about git, so that stuff doesn't do much for me
02:27:21 <kowey> thanks!
02:27:48 <ImInYourMonad> which gui lib should i use from hackage? or how do I import a GUI lib thta is already there in ghc?
02:27:55 <ImInYourMonad> i have 6.10.1
02:28:02 <kowey> hmm... so what I need most is somebody who knows about git (and a bit about darcs)
02:28:04 <ray> if someone wrote the inverse of that, then i'd be able to make an informed decision
02:28:06 <pumpkin_> ImInYourMonad: gtk2hs is the most common one, but it isn't on hackage
02:28:10 <ImInYourMonad> whoa re the people working on ghc? spj et al?
02:28:17 <ImInYourMonad> pumpkin: is it in ghc?
02:28:18 <pumpkin_> kowey: yeah, and ideally who prefers darcs :)
02:28:22 <ManateeLazyCat> ImInYourMonad: You can use gtk2hs
02:28:24 <kowey> right :-D
02:28:52 <ManateeLazyCat> ImInYourMonad: I use gtk2hs-0.10.0 with ghci-6.10
02:28:54 <kowey> ok, so I think my best bet is to send that and for somebody to write the inverse article
02:29:02 <kowey> all darcs patches require inverses after all
02:29:05 <pumpkin_> yeah :)
02:29:22 <ManateeLazyCat> ImInYourMonad: http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.10.0.tar.gz)
02:29:34 * pumpkin_ hides from sourceforge
02:30:16 <Gracenotes> heh. I have an unfinished project on Sourceforge. >_>
02:30:22 <pumpkin_> I hate sourceforge
02:30:25 <Gracenotes> hardly unique in that regard
02:30:38 <Gracenotes> look! Half a programming language! How useful!
02:30:45 <ray> depends on which half
02:30:52 <Gracenotes> :)
02:31:01 <ivanm> ray: they've had the idea to design a new language
02:31:06 <ivanm> surely that's the _hard_ part...
02:31:07 <ivanm> ;-)
02:32:03 <kowey> could somebody paste in the message-id of gunther's message? it hasn't yet appeared on the haskell cafe digest and I want to use the in-reply-to tag
02:33:29 <pumpkin_> Message-ID: <gocj0m$gc9$1@ger.gmane.org>
02:33:42 <pumpkin_> that one?
02:34:07 <kowey> thanks! (I don't know, but I'll trust you!)
02:34:23 <kowey> (I'm guessing this means he posted through gmane)
02:34:36 <ImInYourMonad> and then what do i do with gtk2hs? im using windows vista btw. does haskell have bindings to gtk2hs already i ghc?
02:35:46 <pumpkin_> kowey: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/53892
02:35:59 <pumpkin_> I can't really tell if the id is correct
02:36:06 <kryptiskt_> ImInYourMonad: there's an installer for windows on the Gtk2hs site
02:36:13 <kowey> hmm
02:36:22 <ImInYourMonad> if i want to make a GUI for wndows how do I?
02:36:24 <kowey> oh! I'd better just CC him to make sure he receives it
02:37:04 <pumpkin_> anyway, time for me to hit the hay
02:37:20 <kryptiskt_> ImInYourMonad: http://sourceforge.net/project/showfiles.php?group_id=49207&package_id=42440&release_id=659598
02:37:37 <kryptiskt_> ImInYourMonad: there's plenty of examples in gtk2hs
02:40:43 <CTA> if you know your just getting an integer inputted is it best to: lol :: (Integral a) => a -> a      or.. lol :: Int -> Int?
02:41:14 <mathijs> CTA: depends on how big you think the integers get.
02:41:41 <CTA> Is Integral bigger than Integer?
02:41:59 <mathijs> CTA: Int has maximum and minimum bounds, when you try to go beyond them, you get fault results. Integer doesn't have this problem, but is a bit slower.
02:42:02 <ivanm> CTA: Integral is just types of integer-based numbers
02:42:06 <ivanm> Integer is a type of Integral
02:42:13 <ivanm> s/type/instance of/
02:42:13 <CTA> ah kk
02:42:25 <CTA> I might just do Num a for all numbers now
02:42:29 <CTA> Is that "good" practise?
02:42:40 <ivanm> CTA: depends on what you want
02:42:42 <ivanm> @src Num
02:42:42 <lambdabot> class  (Eq a, Show a) => Num a  where
02:42:42 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:42:42 <lambdabot>     negate, abs, signum     :: a -> a
02:42:42 <lambdabot>     fromInteger             :: Integer -> a
02:42:56 <ivanm> ^^ with Num you only get these operations (and those based on them)
02:42:57 <mathijs> CTA: if you use Integral in your code, the user of your code (the part of the program that calls the function you mention) can in that case decide for himself what to put in and what to expect out
02:43:53 <CTA> I might get RWH the book soon
02:44:27 <mathijs> CTA: Num is a lot wider than integral. In many cases your code only works on integrals, in this case you will 'stricten' Num to Integral
02:46:01 <ImInYourMonad> to use &&& and *** to  have to import Arrows?
02:46:11 <pumpkin_> Control.Arrow, yup
02:46:27 <ivanm> ImInYourMonad: unless you define them yourself, yup ;-)
02:48:16 <ImInYourMonad> what are Arrows, soem form of monads?
02:48:31 <pumpkin_> nope
02:48:34 <ImInYourMonad> @faq arrows
02:48:34 <lambdabot> The answer is: Yes! Haskell can do that.
02:49:02 <pumpkin_> they're kind of like a more general kind of function
02:49:04 <ImInYourMonad> lambdabot: arrows?
02:49:32 <pumpkin_> but the most typical uses for the functions in Control.Arrow don't really make use of the generality
02:49:45 <CTA> pumpkin_ your on a vid tut online somewhere
02:49:50 <CTA> i saw it yesterday lol
02:49:53 <pumpkin_> ?
02:49:55 <CTA> something about haskell and pony's
02:49:59 <pumpkin_> lol
02:50:05 <pumpkin_> yup
02:50:15 <ImInYourMonad> morphism?
02:50:24 <pumpkin_> yup
02:51:32 <Gracenotes> ponomorphism?
02:51:48 <CTA> could you make a file convertor in Haskell>?
02:51:55 <pumpkin_> hippomorphism
02:52:16 <pumpkin_> CTA: sure, you can do most programs you can imagine (within reason) in haskell :)
02:52:25 <CTA> (:
02:52:40 <CTA> Ill learn the basics first (: hopefully getting RWH soon then ill be good (:
02:52:42 <CTA> 'er
02:54:25 <Gracenotes> > Data.Number.Natural.Z
02:54:26 <lambdabot>       Not in scope: data constructor `Data.Number.Natural.Z'
02:54:30 <Gracenotes> butbut
02:54:38 <Gracenotes> > Z
02:54:38 <lambdabot>   Not in scope: data constructor `Z'
02:54:44 <Gracenotes> .-.
02:54:44 <mathijs> Is there work underway (fork, special compile-flags) to 'clean up' cruft that is there because of following the haskell98 standard? In other words, is there a non-standard-compliant haskell-environment (testbed) that dares to do more radical changes like making monads functors by default and have some LANGUAGE flags be default? Like python had python3000 for a long time to eventually become a new standard?
02:55:10 <ivanm> mathijs: it's called GHC :p
02:55:17 <ivanm> though there's also Haskell'
02:55:55 <pumpkin_> but Haskell' is kinda conservative isn't it?
02:56:03 <ivanm> pumpkin_: relatively so, yes
02:56:13 <mathijs> ivanm: ghc still has a standards-compliant prelude and lots of cruft that people have realised should be done differently byt keep it there for 98 compliance.
02:56:15 <ivanm> IIRC, they're going more for evolutionary rather than revolutionary development
02:57:37 <pumpkin_> mmorrow: still up?
02:57:38 <ImInYourMonad> ok I installed gtk2hs, now how can I call it form ghc?
02:58:03 <mathijs> there's nothing wrong with conservative-ness for a stable platform, but I think having a bleeding-edge, breaks-your-code-every-month testbed around will work a lot better than waiting for some people to work out what should be added/removed from the standard, and start implementing that when they finish.
02:58:13 <wli> ivanm: Viva la revolution!
02:58:22 <ivanm> wli: heh
02:58:26 <pumpkin_> ción
02:59:46 <ivanm> mathijs: the main problem as I understand it is that 1) there aren't enough people with time/interest in doing so, 2) those that do don't have a full consensus on what to do (same as the original haskell standard), 3) they don't want to completely redefine the language in such a way that people have to relearn it
02:59:47 <mathijs> I think a better followup-standard will be there (more quickly) if people had some extreme playground to see how certain stuff works out.
03:00:30 <ivanm> mathijs: so you're volunteering to start this extreme playground? :p
03:00:33 <pumpkin_> mathijs: if your issue is with the numeric classes in the prelude (mine is, along with Enum), you might want to check out the numeric prelude (if you haven't already)
03:00:38 <pumpkin_> it's much more mathematically sound
03:00:42 <CTA> anyone here an accountant?
03:00:51 <ivanm> pumpkin_: what's wrong with Enum?
03:01:16 <pumpkin_> I mostly don't like the fromEnum/toEnum functions which granted aren't actually methods of the class
03:01:29 <ivanm> pumpkin_: yes they are
03:01:32 <ivanm> @src Enum
03:01:32 <lambdabot> class  Enum a   where
03:01:32 <lambdabot>     succ                     :: a -> a
03:01:32 <lambdabot>     pred                     :: a -> a
03:01:32 <lambdabot>     toEnum                   :: Int -> a
03:01:32 <lambdabot>     fromEnum                 :: a -> Int
03:01:32 <pumpkin_> oh
03:01:34 <lambdabot> [3 @more lines]
03:01:37 <pumpkin_> then yeah :)
03:01:38 <Cale> The use of Int is annoying.
03:01:40 <pumpkin_> the Int bothers me, and
03:01:44 <ivanm> Cale: rather than Integer?
03:01:47 <Cale> Yeah.
03:01:47 <pumpkin_> yup
03:02:02 <pumpkin_> and Double/Float's instance of Enum really bothers me
03:02:21 <Cale> I don't mind Double/Float instances, but there's a small problem with the current ones
03:02:27 <ivanm> pumpkin_: well, it's a bit of a hack
03:02:28 <Gracenotes> > let match ('(':xs) = modify succ >> match xs; match (')':xs) = modify pred >> match xs; match _ = return () in execState (match "()((") (0 :: Natural) -- this uses an implicit fromInteger, but could use toEnum
03:02:30 <lambdabot>   2
03:02:33 <pumpkin_> ivanm: exactly :)
03:02:52 <Cale> > [0,0.2..1.1]
03:02:53 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001,0.8,1.0,1.2]
03:02:59 * Gracenotes likes that example particularly :D
03:03:01 <ivanm> hmmm.... is there a way to get the instance def with lambdabot?
03:03:06 <pumpkin_> Enum should've been written with explicit rules saying toEnum . fromEnum = id
03:03:10 <Cale> This is a mistake. The 1.1 should be treated as an upper bound.
03:03:13 <Gracenotes> paren matchers--- what technology will do for ya nowadays
03:03:18 <Cale> and so the last element should be 1.0
03:03:22 <pumpkin_> Cale: yeah
03:03:28 <ivanm> what _really_ pisses me off is the [x,y..z] notation... I keep expecting y to be the step size, not x+step :s
03:03:40 <mathijs> pumpkin_: I don't have any issues :)  I just find it a bit scary that haskell doesn't have a development-version-that-will-eventually-become-standard. So my issue is more about release-strategy. But maybe it'll change when haskell keeps attracting more and more people.
03:03:52 <ivanm> Cale: then again, RWH says that this stuff is no dodgier than floating-point semantics in any other language ;-)
03:04:12 <pumpkin_> ivanm: well, the upper bound is pretty dodgy
03:04:13 <Cale> ivanm: Floating point is necessarily dodgy.
03:04:17 <pumpkin_> the 0.60000000000001 is normal
03:04:34 <Cale> Yeah, in fact, those numbers show up rounder here than they do on my machine
03:04:42 <ivanm> Cale: "necessarily"? is it part of the IEEE standard that floating point has to be dodgy?
03:04:43 <Cale> I get [0.0,0.2,0.4,0.6000000000000001,0.8000000000000002,1.0000000000000002,1.2000000000000002]
03:04:43 <ivanm> ;-)
03:04:45 <ImInYourMonad> link to pumpkin-video?
03:04:55 <pumpkin_> ivanm: yup!
03:05:02 <Gracenotes> pumpkin on video?
03:05:06 <pumpkin_> dodgyness required
03:05:11 <Gracenotes> how much?
03:05:12 <pumpkin_> dodginess?
03:05:13 <Cale> ivanm: Well, there's no way for operations to be associative, and you're basically going to get rounding problems.
03:05:19 <Gracenotes> money?
03:05:23 <Cale> ivanm: It's just how floating point works.
03:05:35 <ivanm> yeah, I know :(
03:05:42 <Gracenotes> :x
03:05:52 <pumpkin_> I don
03:05:55 <pumpkin_> t know the link :)
03:06:08 <pumpkin_> I'm mentioned on other videos too :o
03:06:16 <ivanm> @go pumpkin youtube
03:06:16 <lambdabot> http://www.youtube.com/watch?v=Q-1aui-wluE
03:06:16 <lambdabot> Title: YouTube - The Life and Death of a Pumpkin (the original)
03:06:17 <ivanm> ;-)
03:06:23 <ImInYourMonad> anyone can psot an example of using gtk2hs ?
03:06:25 <Gracenotes> which video are you talking about, by the way?
03:06:45 <Cale> What I'd really like to see is something like CReal, but which had performance which was within an order of magnitude of Float/Double when you're only requesting that much precision.
03:06:46 <Gracenotes> hopefully the one of the Boston meeting, if any...? :X
03:06:49 <cnwdup> ImInYourMonad, there are tutorials available from the official homepage afair.
03:07:00 <pumpkin_> Gracenotes: didn't go, was feeling kinda shitty
03:07:18 <cnwdup> ImInYourMonad, http://www.haskell.org/gtk2hs/documentation/. There are examples.
03:07:36 <Gracenotes> yes, I was feeling kinda on the other side of the Long Island sound
03:07:54 <pumpkin_> ?
03:07:57 <pumpkin_> I mean, I didn't go
03:08:28 <Gracenotes> yeah, didn't either. So I can't complain if there is no video.
03:08:40 <Gracenotes> how will we learn about, er, Haskell now
03:08:42 <pumpkin_> I think the video he's referring to is don's pony video
03:08:50 <Gracenotes> oh yes, on YouTube
03:08:56 <Gracenotes> http://youtube.com/donsbot
03:09:04 <Gracenotes> from memory... think it's correct
03:09:08 <ivanm> @go haskell pony
03:09:08 <ivanm> ;-)
03:09:08 <lambdabot> http://donsbot.wordpress.com/2009/02/22/can-haskell-give-me-a-pony/
03:09:08 <lambdabot> Title: Can Haskell give me a pony? « Control.Monad.Writer
03:09:19 <ivanm> waddaya know, google got it right for once! :o
03:09:58 <Gracenotes> @go haskell unicorn
03:10:01 <lambdabot> http://blog.tmorris.net/20-intermediate-haskell-exercises/
03:10:07 <Gracenotes> oh, heh
03:10:17 <Gracenotes> people giving cute names to common Haskell functions and typeclasses
03:10:57 <Gracenotes> huh... what happened to his site
03:11:02 <ivanm> @go haskell moby dick
03:11:04 <lambdabot> http://www.encyclopedia.com/doc/1G1-180945848.html
03:11:04 <lambdabot> Title: John Bryant and Haskell Springer, Eds.: Moby-Dick: A Longman Critical Edition.(B ...
03:11:08 <ivanm> lol
03:16:43 <ImInYourMonad> ah when using Gtk2hs i have to compile, doesn work in ghci?
03:20:36 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1907#a1907 <- why isnt that working?
03:21:24 <Gracenotes> ImInYourMonad: do you mean "<-" instead of "< -"?
03:34:08 <dcoutts> Saizan_: so you've been hacking on hbuild?
03:34:17 <dcoutts> btw, are you going to the hackathon?
03:37:07 <ImInYourMonad> Gracenotes: thanks now it works!
03:39:15 <Gracenotes> ImInYourMonad: sure :D after all, <- is just a token that's expected in making a do block into some chained monad stuffs
03:45:13 <ImInYourMonad> hmm it is too bad it took so long to "penetrate" haskell because now that I know it most things are actually easy to do. I think I will be superproductive in haskell once i have written some basic games, guis etc to have a good geenral feel for how to do things in haskell. the more mathoriented stuff already is very easy and elegant to write in haskell
03:46:37 <Saizan_> dcoutts: yeah, i've put together the pieces to make the compilation part work again
03:46:45 <dcoutts> great
03:47:57 <Saizan_> you can also use it to infer other-modules and build-depends :)
03:49:17 <dcoutts> Saizan_: yay :-)
03:49:38 <dcoutts> Saizan_: so what're the issues at the moment? speed of handling the cache data?
03:49:44 <dcoutts> untypedness of the cache data?
03:51:24 <Saizan_> untypedness is quite annoying, yeah
03:52:38 <Saizan_> wrt speed there's the [de]serialization and the fact that it's not exploiting all the parallelism available, because i've not implemented the required bookkeeping
03:53:28 <dcoutts> Saizan_: btw, I can give you an account on sparky and some time when ben is not doing benchmarks you can try it with -j 64
03:53:34 <Saizan_> also, calling ghc multiple times has its overhead i guess
03:53:47 <dcoutts> Saizan_: mainly the overhead is reading the package.conf
03:54:00 <dcoutts> because it's in a silly read/show format
03:54:19 <dcoutts> there's also someoverhead to opening the .hi files over and over
03:54:36 <Saizan_> heh, yeah, hbuild's Cache is silly like that too :)
03:54:37 <dcoutts> built packages should have a single combined .hi file with an index
03:54:48 <ImInYourMonad> this application has failed to start becayse libglib-2.0-0.dll was not found. re-installing the application may fix this problem.
03:54:57 <dcoutts> Saizan_: ah but I forgive you, it's early days yet :-)
03:55:13 <dcoutts> Saizan_: reading a ghc pkg db with 600 packages takes for ages
03:55:51 <Saizan_> dcoutts: maybe i should try testing with a smaller db then
03:56:40 <dcoutts> Saizan_: on a fast box, 660 packages in 2.2 seconds
03:56:50 <dcoutts> Saizan_: that's slower than compiling most .hs files
03:56:51 <ImInYourMonad> thats what i get now. so weird first time i did: ghc --make GUItest.hs -o hello;
03:56:51 <ImInYourMonad>  and it worked, then I got that it created no main and ow i did: ghc --make -O2 -main-is Main.main Main.hs
03:56:51 <ImInYourMonad> and I got ^^
03:57:11 <jaj> Hi, hmm I have ghc 6.10.1 which comes with base-4.0 and I want to compile HStringTemplate which wants Data.Generics which is part of base-3.0 but not 4.0 anymore
03:57:13 <Saizan_> dcoutts: ugh
03:57:41 <dcoutts> jaj: then build it using base 3. ghc-6.10 comes with both,
03:58:12 <dcoutts> Saizan_: however it does not skupper the batch mode approach, fixing the ghc-pkg db format is quite doable.
03:58:49 <mmorrow> pumpkin_: yes
04:00:16 <Saizan_> > 13.4 / 12.4
04:00:17 <lambdabot>   1.0806451612903225
04:00:23 <CTA> Are there any major well known programs coded in Haskell#@
04:00:26 <CTA> ?
04:00:30 <Cheshire> yes lol
04:00:36 <CTA> like what lol
04:00:37 <Cheshire> GHC
04:01:03 <Cheshire> or do you mean programs that our grandparents use on a daily basis?
04:01:49 <CTA> lol like games or whatnot
04:01:57 <CTA> and so a haskell compiler is coded in haskell? lol
04:01:59 <andun> i used darcs long before i'd heard of haskell
04:02:37 <Saizan_> dcoutts: only 8% slower with only 51 packages instead of 220 :)
04:02:44 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1907#a1907 <- why isnt it working?
04:02:51 <dcoutts> Saizan_: that's morel like it
04:03:07 <ImInYourMonad> opp ssorry wrong paste
04:03:07 <dcoutts> Saizan_: is that single threaded?
04:03:24 <CTA> why doesn't haskell use "loops"?
04:03:32 <Cheshire> what is "loops"?
04:03:43 <Axman6> it does
04:03:44 <Cheshire> CTA yes it's written in almost all haskell
04:03:49 <Axman6> i see functions called loop all the time
04:04:15 <Saizan_> dcoutts: no, that's with -j3
04:04:32 <Cheshire> 3 kinds of lies, lies, damn lies and loops
04:04:32 <CTA> I thought someone once told me it didnt, I mean like for (int i = 0; i < 10; i++) { cout << i; } or w.e
04:04:33 <Saizan_> > 20 / 13
04:04:34 <lambdabot>   1.5384615384615385
04:04:49 <Saizan_> single threaded is 53% :\
04:04:49 <CTA> > factorial 5
04:04:50 <lambdabot>   Not in scope: `factorial'
04:04:52 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1907#a1908 <- help!
04:04:52 <dcoutts> Saizan_: what is it like with -j1 ?
04:04:54 <Axman6> it doesn't have those sort of loops
04:05:06 <CTA> lambdabot not have factorial?
04:05:13 <Axman6> nope
04:05:15 <Cheshire> @let factorial = 12
04:05:15 <lambdabot>  Defined.
04:05:25 <Axman6> > factorial
04:05:26 <lambdabot>   12
04:05:29 <andun> > forM_ [1..10] print
04:05:30 <lambdabot>   * Exception: "<IO ()>"
04:05:31 <Axman6> has it now
04:05:42 <dcoutts> > factorial 5
04:05:43 <CTA> > factorial
04:05:44 <lambdabot>       No instance for (Num (t -> a))
04:05:44 <lambdabot>        arising from a use of `factorial'...
04:05:44 <lambdabot>   12
04:06:09 <CTA> > factorial x = product ([1..x])
04:06:09 <lambdabot>   <no location info>: parse error on input `='
04:06:32 <Axman6> > let fac n = foldl' (*) [1..n] in fac 100
04:06:32 <dcoutts> @let random _ = 4  -- picked by fair dice roll
04:06:33 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
04:06:33 <lambdabot>        arising from a use...
04:06:33 <lambdabot>  Defined.
04:06:44 <ImInYourMonad> CTA: darcs, ghc, xmonad, frag. nothing hugely successful I guess. learn it because it is fun, because it makes you a better programmer and makes you think about programming differently and because it influences other languages a lot(CSharp, Fsharp, clojure etc).
04:06:47 <Axman6> > let fac n = foldl' (*) 2 [3..n] in fac 100
04:06:48 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
04:07:06 <Saizan_> dcoutts: that's what i was referring to with single threaded, so 53% slower than ghc --make, i'm going to test with the real sequential JobControl now
04:07:19 <Axman6> > random 10
04:07:20 <lambdabot>       Ambiguous occurrence `random'
04:07:20 <lambdabot>      It could refer to either `L.random',...
04:07:27 <Axman6> broked
04:07:30 <dcoutts> doh
04:07:50 <dcoutts> Saizan_: ok
04:08:10 <Axman6> > [3..3]
04:08:12 <lambdabot>   [3]
04:09:49 <Saizan_> dcoutts: it's the same. i guess GHC's threads are really cheap :)
04:10:44 <ImInYourMonad> wait ti does work but i ahve to click the exe, cant run from emacs. weird but oh well
04:11:30 <dcoutts> Saizan_: :-)
04:11:40 <Cheshire> hi
04:11:51 <Cheshire> does anyone know where that program originates?
04:12:03 <dcoutts> Saizan_: with the new process lib, we do not need OS threads to be able to wait for a dozen external processes.
04:12:05 <Cheshire> I think it was Chuch maybe.. to define tail using foldr
04:12:25 <jaj> dcoutts: to do that I need to -hide-package base-4.0.0.0 -package base-base-3.0.3.0 ?
04:12:42 <dcoutts> Saizan_: oh, so were you linking with -threaded before?
04:12:49 <pk1> hey
04:12:57 <dcoutts> jaj: are you building the package using cabal?
04:13:07 <pk1> I have tried to build a program with glut
04:13:36 <jaj> dcoutts: yes
04:13:41 <pk1> but I get a linking error
04:13:48 <zachk1> i know on windows you need to stick glut32.dll into the directory
04:14:05 <pk1> unknown symbol `glutGet'
04:14:06 <Saizan_> dcoutts: yeah, i'm linking with -threaded, though just for non-blocking wait(), passing +RTS -Nn for n > 1 only degrades performance :)
04:14:07 <jaj> dcoutts: doing Setup configure, build, ... not cabal-install
04:14:11 <dcoutts> jaj: ok, well cabal install should pick base 3
04:14:20 <pk1> I'm on ubuntu
04:14:46 <dcoutts> Saizan_: yes sure, -N1 is sufficient, as you say it's just non-blocking wait()
04:15:04 <mathijs> typeclassopedia describes the type ((->) e) being a functor. Am I correct that (+1).read is a value of this type?
04:15:07 <jaj> dcoutts: during the build phase it says base 3 is hidden, even though ghc-pkg list doesn't show it as hidden by default
04:15:18 <dcoutts> jaj: if you're doing runghc Setup configure then add --constraint='base < 4'
04:16:07 <mauke> > fmap id ((+1).read) "123"
04:16:08 <lambdabot>   124
04:16:12 <mauke> mathijs: yes
04:16:42 <trofi> > read "hello" :: Int
04:16:43 <lambdabot>   * Exception: Prelude.read: no parse
04:16:51 <jaj> dcoutts: thanks, that does it!
04:16:51 <trofi> @src read
04:16:51 <lambdabot> read s = either error id (readEither s)
04:17:09 <dcoutts> jaj: or if you used cabal-install it would do it by magic
04:17:14 <ImInYourMonad> is there any plans for a VM for haskell?
04:17:16 <mathijs> mauke: ok, that's part 1 :)  since ((->) e) is also Pointed, it needs to have a 'pure' function. I can't figure out what that would be.
04:17:29 <Axman6> > readEither "hello" :: Int
04:17:29 <lambdabot>   Not in scope: `readEither'
04:17:36 <mauke> mathijs: const
04:17:57 <trofi> :t readEither
04:17:58 <lambdabot> Not in scope: `readEither'
04:18:05 <mauke> @hoogle a -> ((->) e) a
04:18:06 <lambdabot> Prelude return :: Monad m => a -> m a
04:18:06 <lambdabot> Control.Monad return :: Monad m => a -> m a
04:18:06 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
04:18:10 <mauke> hah
04:18:17 <mauke> @hoogle a -> (e -> a)
04:18:17 <lambdabot> Prelude const :: a -> b -> a
04:18:17 <lambdabot> Data.Function const :: a -> b -> a
04:18:17 <lambdabot> Control.Parallel par :: a -> b -> b
04:18:41 <ImInYourMonad> so lets say I make an mp3player and the player needs some state, like playlist, what is currently being played, threads etc. what should I use , just Refs?
04:19:24 <kniu> guys, I have a problem.
04:19:35 <mathijs> mauke: thanks, as usual it feels correct. I was once again thinking in too difficult directions :)
04:21:31 <kniu> As a C programmer, I debug my programs with the usual way of using gdb and valgrind, going through line by line, printing out intermediate values, and finding at which point the computation went wrong.
04:21:44 <kniu> I don't know how to do the equivalent in Haskell.
04:22:13 <trygvis> kniu: ghci has a built-in debugger
04:22:16 <Baughn> ImInYourMonad: Probably not..
04:22:26 <kniu> oh?
04:22:30 <trygvis> and there is the Debug.Trace package which might be useful
04:22:43 <ImInYourMonad> kniu: i had the same sproblem at first but I dont have it anymore, the way you code haskell it makes it very easy to debug since you can test each function and it doesnt depend on some hidden state
04:22:49 <Baughn> ImInYourMonad: Right now I think trying to write a complete mp3 player might be a bit premature, but if you want to try anyway, have a look at STM
04:23:09 <Baughn> ImInYourMonad: It provides a much nicer interface to shared mutable state than bare refs
04:23:13 <ImInYourMonad> Baughn: well i have written one in clojure using a library for decoding.
04:23:16 <kniu> alright then
04:23:26 <kniu> how do I invoke the debugger in ghci?
04:23:32 <Axman6> kniu: check the ghc docs
04:23:41 <Baughn> ImInYourMonad: Well, lisp is hardly haskell. :P
04:24:06 <mauke> kniu: don't expect too much, the ghci debugger is very bare bones
04:24:17 <ImInYourMonad> what would be so hard about writing an mp3layer? the way i vision it it will be simpler + i ahve the wisdom from my previous try. problem might be finding a decoding lib, maybe i have to FFI to some C-lib.
04:24:37 <Baughn> ImInYourMonad: For multiple threads, there are basically two ways to have them communicate - point-to-point chat, eg. message-passing, or blackboard-style shared mutable state. For the latter, STM is /much/ nicer than references
04:24:47 <Baughn> ImInYourMonad: Or MVars, for that matter
04:25:12 <Baughn> ImInYourMonad: It's mostly just that I'm worried you might end up writing lisp in haskell. But by all means, go ahead.
04:28:09 <ImInYourMonad> Baughn: there are things about my lisp/java code i didnt like, i envision a much clearer handling of state in haskell. I think I isolated and made my clojure-player modular but it still doesnt feel optimal.
04:28:42 <Baughn> ImInYourMonad: Well, I'm looking forward to seeing the result. ;)
04:28:59 <Baughn> ImInYourMonad: Remember to put it on hackage once it's marginally useful
04:30:24 <pejo> kniu, the problems you typically use valgrind to find are non-problems in haskell.
04:32:03 <pejo> kniu, if you have an idea which function that is buggy you can experiment with feeding it different inputs in ghci though, sometimes that's very useful.
04:32:47 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1909#a1909 <- Baughn, I cant figure otu what I ahve to do there, it is a basic example of trying to use STM
04:32:54 <Baughn> kniu: The most typical problems are space-time leaks. Fortunately we've got good profiling tools to handle that.. not as good as I'd like, but better than most languages.
04:33:08 <pk1> Anybody ever had the 'glutGet' unknown symbol error ?
04:33:09 <mauke> ImInYourMonad: use more parens
04:34:04 <Baughn> ImInYourMonad: Point of note, you should use strict (yep, there's a hackage package called that) when you want to just read the whole file into memory right away.
04:34:33 <CTA> anyone here got photoshop cs3?
04:34:35 <CTA> *cs4?
04:35:51 <Axman6> ImInYourMonad: why do you import everything qualified?
04:36:16 <Axman6> most of the things you're using it for it's quite obvious where they come from
04:37:26 <Baughn> ImInYourMonad: And.. you're just missing some parantheses
04:37:35 <Axman6> ImInYourMonad: also, you don't want to be mixing STM and IO in the same do blocks. what you do is make STM transactions, say taking x from one TVar and putting it into another TVar, and then running that action using atomically
04:38:11 <Baughn> ImInYourMonad: Well, not "just", but you're missing parantheses. You're passing STM.putTMVar to atomically instead of the STM action putTMVar constructs.
04:39:42 * Baughn wonders why STM primitives are stuck in GHC.Conc of all places
04:39:57 <mauke> why not?
04:40:21 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1909#a1910 <- still doesnt work
04:40:25 <Baughn> ..seems messy
04:40:50 <mauke> ImInYourMonad: missing argument in call to putTMVar
04:40:51 <Baughn> GHC.Conc is a bit of a grab-bag. Even if it's ghc-specific, there's too much there that's got nothing to do with STM
04:42:03 <Baughn> ImInYourMonad: putTMVar is supposed to put something in the TMVar.. but what, exactly?
04:42:05 <pejo> Baughn, isn't that for concurrency stuff in general?
04:42:28 <Axman6> (GC.atomically (STM.putTMVar s)) -> (\x -> GC.atomically (STM.putTMVar s x)) or (GC.atomically . STM.putTMVar s)
04:42:39 <toliko_smoren> hey why does this crash my program, stime + (round ((y-1)*500.0), where stime is gotten from timeGetTime ??
04:42:55 <Baughn> pejo: It exports the signalHandlerLock of all things
04:42:55 <mauke> define "crash"
04:43:07 <Baughn> pejo: In general, you don't want to export public interfaces in the same module as private ones
04:43:25 <toliko_smoren> it hangs, screen goes white and I after to al-ctrl-del to stop it
04:44:05 <mauke> screen goes white? are you writing an X server or something?
04:45:03 <mauke> and what is timeGetTime?
04:45:12 <toliko_smoren> i tested that part, I thought the bug must be there but it isnt
04:45:16 <toliko_smoren> thanks
04:45:35 <toliko_smoren> mauke: timeGetTime is from SOE library, gets current time in miliseconds as a word32
04:45:37 <Axman6> ImInYourMonad: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf read that
04:51:07 <Cheshire> nobody even saw the program ??
04:51:27 <Cheshire> > (\(x,y) -> x) (1,2)
04:51:29 <lambdabot>   1
04:51:54 <Cheshire> > foldr (\e (x,y) -> (y,e:x)) ([],[]) "wobble"
04:51:55 <lambdabot>   ("obe","wbl")
04:52:01 <Cheshire> > foldr (\e (x,y) -> (y,e:y)) ([],[]) "wobble"
04:52:02 <lambdabot>   ("obble","wobble")
04:52:10 <Cheshire> > fst (foldr (\e (x,y) -> (y,e:y)) ([],[]) "wobble")
04:52:11 <lambdabot>   "obble"
04:52:21 <Cheshire> this is tail implemented witha foldr
04:52:25 <Cheshire> but who invented it ?
04:52:33 <Cheshire> I wonder what is the origin of  this program
04:52:41 <Axman6> i like that
04:52:45 <Cheshire> the same way you can write  pred  on church numerals
04:53:57 <Cheshire> (btw through curry-howard this corresponds to strengthening an induction hypothesis from P(n) to P(n)/\P(n+1) for a proof..)
04:54:12 <Axman6> > foldr (\e (x,y) -> (y,e:y)) ([],[]) [a,b,c,d,e]
04:54:13 <lambdabot>   ([b,c,d,e],[a,b,c,d,e])
04:54:27 <Axman6> > foldr (\e (x,y) -> (y,e:x)) ([],[]) [a,b,c,d,e]
04:54:28 <lambdabot>   ([b,d],[a,c,e])
04:55:25 <Axman6> > foldr (\e (x,y) -> (y,e:x)) ([],[]) []
04:55:26 <lambdabot>   ([],[])
04:55:31 <Axman6> > foldr (\e (x,y) -> (y,e:x)) ([],[]) [a]
04:55:32 <lambdabot>   ([],[a])
04:58:19 <DBAlex> hey
04:59:24 <araujo> morning
04:59:44 <DBAlex> i'm trying to use QuickCheck with GHC, so I added Test.QuickCheck to the top of my .hs file... and I think its working but I still get these errors: C:\ghc\ghc-6.10.1.20090226\bin
05:00:01 <DBAlex> oops
05:00:02 <DBAlex> C:\Users\Alex\Desktop>ghci new.hs
05:00:02 <DBAlex> GHCi, version 6.10.1.20090226: http://www.haskell.org/ghc/  :? for help
05:00:02 <DBAlex> Loading package ghc-prim ... linking ... done.
05:00:02 <DBAlex> Loading package integer ... linking ... done.
05:00:02 <DBAlex> Loading package base ... linking ... done.
05:00:04 <DBAlex> [1 of 1] Compiling Main             ( new.hs, interpreted )
05:00:06 <DBAlex> new.hs:21:29: Not in scope: `intToDigit'
05:00:08 <DBAlex> new.hs:39:43: Not in scope: `digitToInt'
05:00:10 <DBAlex> Failed, modules loaded: none.
05:00:12 <DBAlex> thats the errors
05:00:20 <Axman6> @hoogle intToDigit
05:00:20 <lambdabot> Data.Char intToDigit :: Int -> Char
05:00:26 <DBAlex> (I'm used to using Hugs, I assume I need to import something?)
05:00:33 <Axman6> import Data.Char
05:00:33 <DBAlex> ok
05:01:02 <Axman6> also, use hpaste to paste large amounts of text like that (and usually just the error if you can)
05:01:49 <DBAlex> ok sorry, I didn't know whether I should or not, but it was quiet, won't happen again
05:02:22 <Axman6> s'ok
05:04:14 <DBAlex> ok, i'm getting these errors now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1911#a1911
05:05:11 <DBAlex> Axman6: Any reason why i'm getting them?
05:05:54 <Axman6> @hoogle Arbitrary
05:05:54 <lambdabot> Test.QuickCheck class Arbitrary a
05:05:54 <lambdabot> Test.QuickCheck arbitrary :: Arbitrary a => Gen a
05:05:54 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
05:06:05 <DBAlex> ?
05:06:16 <EvilTerran> @instances Arbitrary
05:06:17 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
05:06:17 <Axman6> @instances-importing Test.QuickCheck.Arbitrary
05:06:18 <lambdabot> .Arbitrary (), .Arbitrary Bool, .Arbitrary Char, .Arbitrary Double, .Arbitrary Float, .Arbitrary Int, .Arbitrary Integer
05:06:24 <Axman6> hmm
05:06:44 <yitz> @check \c -> c == (toLower . toUpper $ c)
05:06:45 <lambdabot>   "OK, passed 500 tests."
05:06:51 <Axman6> you have Test.QuickCheck imported right?
05:07:14 <DBAlex> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1911#a1912 <- I've added the code for inverse here
05:07:20 <DBAlex> Axman6: yes
05:07:25 <DBAlex> import Test.QuickCheck
05:08:05 <Axman6> try :m +Test.QuickCheck in ghci
05:08:12 <Axman6> :\
05:08:25 <DBAlex> http://forums.xkcd.com/viewtopic.php?f=11&t=29180
05:08:30 <DBAlex> Maybe the solution is here 1 sec
05:09:08 <DBAlex> Axman6: ok
05:09:23 <Axman6> i dunno. i've got to get to sleep. night all
05:09:46 <DBAlex> Axman6: Prelude Test.QuickCheck> :m +Test.QuickCheck
05:09:46 <DBAlex> Prelude Test.QuickCheck>
05:09:49 <DBAlex> ok
05:10:22 <ImInYourMonad> but doesnt reading >>= pass to putTMVar?
05:10:30 <Axman6> @botsnack
05:10:30 <lambdabot> :)
05:10:30 <lunabot>  :)
05:10:44 <Axman6> ImInYourMonad: not the way ypu were using it
05:10:44 <DBAlex> @botsnack
05:10:44 <lambdabot> :)
05:10:44 <lunabot>  :)
05:10:55 <DBAlex> wot?
05:10:56 <DBAlex> wot?
05:10:58 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1913#a1913
05:10:59 <DBAlex> @botsnack
05:10:59 <lambdabot> :)
05:10:59 <lunabot>  :)
05:11:02 <DBAlex> llo
05:11:04 <DBAlex> *lol
05:11:25 <Cheshire> what am I gonna do today
05:11:26 <Cheshire> :S
05:11:46 <DBAlex> Cheshire: ?
05:12:13 <yitz> DBAlex: hmm, you're right, QuickCheck does not have an Arbitrary instance for Char or String by default.
05:12:22 <DBAlex> yup
05:12:31 <yitz> DBAlex: I guess it depends on what kinds of strings you are expecting.
05:12:37 <DBAlex> yitz: the solution is here http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck#Testing_with_QuickCheck
05:12:45 <DBAlex> you don't need this with Hugs
05:12:59 <DBAlex> infact you don't need import Data.Char and Data.List either
05:13:19 <DBAlex> I need to boot into linux and test the speed of my code ;)
05:13:33 <whpearson> Would people recommend using Data.Generics?
05:13:35 <Cheshire> @yow invitation to love
05:13:35 <lambdabot> I have the power to HALT PRODUCTION on all TEENAGE SEX COMEDIES!!
05:13:57 <Cheshire> whpearson what for
05:14:23 <pejo> whpearson, it depends on your problem.
05:15:46 <whpearson> I'm mainly dealing with graphs at the moment, but not graphs defined by Data.Graph.  Graphs that are defined by a function that maps a Node onto all the possible Nodes you can reach.
05:15:49 <yitz> DBAlex: so what instance does Hugs provide? It actually makes sense not to provide any instance by default.
05:16:14 <whpearson> From that node, that is.
05:16:41 <DBAlex> yitz: not sure, it works though :P
05:17:00 <DBAlex> what do you mean "what instance" does it provide?
05:18:11 <whpearson> I want to do a variety of things with graphs, including finding a node that satisfies a predicate, listing all possible nodes reachable from a node. Etc.
05:18:31 <yitz> DBAlex: If a is a type, you define an instance of Arbitrary a to specify how elements of a should be chosen/constructed when testing.
05:18:54 <DBAlex> how to do I start a function when my module loads? I have this -> main = quickCheck inverse , but I still have to type main when GHCI loads the haskell file?
05:19:12 <piksi> BONUS: superior tutorial you got there! :->
05:19:31 <DBAlex> yitz: ok
05:20:00 <yitz> DBAlex: so for example, you may want to test against printable ASCII text, or Unicode in certain languages, or any binary 8-bits, or whatever.
05:20:27 <DBAlex> yeah
05:20:50 <EvilTerran> whpearson, i think Data.Generics would be excessive for that sort of thing
05:21:32 <yitz> DBAlex: so if Hugs locks you in to a specific instance of Arbitrary Char, it could be awkward to do anything else.
05:21:34 <EvilTerran> whpearson, btw, i've seen graphs represented in haskell as Map NodeId (Set NodeId); might that make things easier?
05:21:56 <EvilTerran> (for some appropriate NodeId type)
05:21:56 <DBAlex> yitz: hugs just takes a String, or [Char] I think
05:22:08 <DBAlex> String of course is just [Char]
05:22:23 <yitz> DBAlex: yeah but then what kinds of strings does it generate for testing?
05:22:33 <DBAlex> I'm not sure
05:22:47 <DBAlex> I don't know that much about Haskell yet
05:22:56 <DBAlex> i've only been programming in it for a couple of weeks...
05:23:22 <DBAlex> yitz: how do I run a function as main?
05:24:08 <EvilTerran> DBAlex, if you want to just load a .hs and run its "main", pass it to runhaskell instead of hugs/ghci
05:24:34 <DBAlex> EvilTerran: ok
05:24:51 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1914#a1914 <- what am i doing wrong? it is the takeTMVar that is the error
05:24:53 <DBAlex> EvilTerran: but I want to compile with ghc and run it?
05:25:32 <DBAlex> EvilTerran: whats wrong with this: module Main where
05:25:32 <DBAlex> main = quickCheck inverse ?
05:25:39 <DBAlex> (ignore the ?)
05:26:03 <EvilTerran> nothing wrong with that, as far as i can tell
05:26:29 <EvilTerran> "ghc --make whateverTheFilesCalled.hs" should compile it
05:27:05 <DBAlex> EvilTerran: when I load it with ghci I have to type main to run it tho?
05:27:08 <DBAlex> is that right?
05:27:15 <EvilTerran> yes
05:27:21 <EvilTerran> ghci is an interactive shell
05:27:34 <DBAlex> but when I compile and then run ./new_hs it will run main?
05:27:36 <ImInYourMonad> text <- (STM.takeTMVar s) , isnt that synatx correct? I should use <- right?
05:27:40 <EvilTerran> yes
05:27:50 <mauke> ImInYourMonad: the syntax is correct but the type is wrong
05:27:53 <EvilTerran> (@ DBAlex)
05:28:08 <whpearson> EvilTerran: I'm generating the links on the fly, because I'm looking at things like the graphs of repeated applications of regexs.
05:28:21 <zachk1> ok if i am "optimizing" and my cpu usage goes up is that a good thing?
05:28:48 <DBAlex> EvilTerran: ok, cool, it worked ! :)
05:28:56 <DBAlex> now I can try and test the speed in linux
05:28:59 <yitz> zachk1: do you own stock in the electric company?
05:29:06 <int-e> zachk1: depends. what are you optimizing for?
05:29:18 <zachk1> nbody gravitation
05:30:07 <zachk1> my method should have cut the number of floating point calculations in half but i increased my cpu usage by 50% it was at 30% now its at 45%
05:30:12 <yitz> zachk1: measure how long it takes to run. if it runs faster, it's worth the extra electricity for the extra cpu usage :)
05:30:26 <DBAlex> btw our lecturer said that ghc is one of the most optimized compilers in the world, is that right?
05:30:38 <DBAlex> I looked at some tests earlier and one had ghc faster than gcc ...
05:30:54 <EvilTerran> DBAlex, well, aside from the inherent difficulty of comparing compilers of different languages for "optimised-ness"
05:31:17 <DBAlex> yes
05:31:35 <DBAlex> my lecturer wrote the book "Programming in Haskell"
05:31:43 <yitz> aha
05:31:49 <DBAlex> although I have to admit I haven't read much of it yet... (theres lots of good stuff on the web)
05:32:12 <EvilTerran> DBAlex, ah, your lecturer's graham hutton?
05:32:14 <DBAlex> but it looks like a good book :)
05:32:20 <DBAlex> EvilTerran: yeah
05:32:37 <trofi> [:
05:33:43 <DBAlex> I bought it because I was worried i'd be really bad at haskell... since I don't do too well in maths modules
05:34:01 <DBAlex> but it isn't that difficult once you get used to the different style :)
05:36:18 <DBAlex> hmm, trying to find an equivalent to the unix time command for windows
05:36:32 <zachk1> ok from pidigits benchmark data F = F !Integer !Integer !Integer !Integer does strict. is there a way i can do that with record syntax?
05:36:39 <mauke> zachk1: yes
05:36:43 <zachk1> how
05:36:54 <trofi> data D = D { x :: !Int }
05:36:57 <mauke> data F = F { w, x, y, z :: !Integer }
05:37:17 <pejo> DBAlex, isn't a 'time' command available in cygwin?
05:37:28 <DBAlex> hmm
05:37:29 <DBAlex> maybe
05:37:32 * DBAlex checks
05:37:34 <trofi> @hoogle package time
05:37:34 <lambdabot> No results found
05:37:38 <trofi> @hoogle time
05:37:38 <lambdabot> package time
05:37:38 <lambdabot> module Data.Time
05:37:38 <lambdabot> Data.Time.LocalTime data TimeOfDay
05:39:10 <DBAlex> ok it worked
05:40:02 <DBAlex> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1916#a1916
05:40:04 <DBAlex> woot :)
05:41:14 <DBAlex> it converts "aaabbbccc" to "a3b3c3" etc and then back from "a3b3c3" to "aaabbbccc"
05:41:18 <ImInYourMonad> mauke: so what do i have to do to egt the type right?
05:41:22 <DBAlex> not very complicated really :)
05:41:33 <ImInYourMonad> Couldn't match expected type `GC.STM (IO String)'
05:41:33 <ImInYourMonad>            against inferred type `IO (IO String)'
05:42:35 <zachk1> ok it is getting noticeably faster, i cut the number of fpu calls down, added some strictness, and compiler flags. bam more cpu usage and visually faster. thank you
05:45:11 <Tigran> Is there anything convenient in the libs for something like: [Just 1, Just 2, Nothing] -> [1, 2] ?
05:45:28 <Saizan_> > catMaybes [Just 1, Just 2, Nothing]
05:45:29 <lambdabot>   [1,2]
05:45:42 <zachk1> in Data.Maybe maybe :-/
05:45:43 <Tigran> Super, thanks Saizan_ .
05:46:18 <trofi> @hoogle [Maybe a] -> a
05:46:18 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
05:46:18 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
05:46:18 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
05:48:06 <DBAlex> btw my exe is almost 1MB, is there a way to optimize GHC?
05:49:53 <EvilTerran> i suspect most of that will be runtime system
05:50:00 <EvilTerran> and so unavoidable
05:50:01 <yitz> DBAlex: that's about as small as it will get. the runtime gets linked in each time.
05:50:10 <DBAlex> ah ok
05:50:12 <DBAlex> I tried -O
05:50:15 <DBAlex> but nope
05:50:19 <ImInYourMonad> how do I take something out of a STM.TMVar and store it or print it somewhere?
05:50:25 <DBAlex> ah well, not too bad I suppose
05:52:10 <yitz> the GHC team is working on dynamic linking for a coming release.
05:53:22 <defun> this might be a dumb question, but why is a bug/beatle the haskell mascot for "Real World Haskell"?
05:54:19 <yitz> DBAlex: also - adding -O or -O2 optimizes speed. the executable may get bigger if you use them.
05:54:40 <DBAlex> yitz: ok
05:54:51 <DBAlex> defun: all o'reilly books have wierd animals on them
05:54:55 <DBAlex> *weird
05:55:45 <nlogax> defun: see here: http://book.realworldhaskell.org/
05:56:50 <ImInYourMonad> http://haskell.org/~shae/memory.pdf <- this seems to suggest using IORefs for GUIs, is STM really needed for basic stuff? an mp3player has 2 threads, main thread to tak e user-actions and side-thread to play music.
05:57:08 <DBAlex> btw i'm thinking of getting that book
05:57:11 <DBAlex> anyone got it?
05:57:26 <DBAlex> is it good?, I'm hoping its geared around more practical projects in haskell?
05:58:18 <bremner> DBAlex: the book is good, and online, so have a look?
05:58:20 <trofi> you can read it online
05:58:28 <DBAlex> really?
05:58:31 <DBAlex> all of it? :O
05:58:39 <EvilTerran> @where rwh
05:58:39 <lambdabot> is http://www.realworldhaskell.org/blog/
05:58:40 <trofi> http://book.realworldhaskell.org/read/
05:58:42 <dmwit> defun: That particular beetle is the strongest insect (most muscle per size).
05:58:47 <bremner> they really give away software :-)?
05:59:04 <dmwit> defun: It comes from a description of Haskell as "concise and powerful" or something like that. =P
05:59:21 <DBAlex> bremner: I know but, I always expected to have to pay for books
06:00:08 <bremner> yeah, I'm teasing, it is a bit radical. I hope it works out for them.
06:03:08 <ImInYourMonad> how do I take something out of a STM.TMVar and store it or print it somewhere?
06:03:10 <tibbe> anyone know who uses the handle sof?
06:03:52 <tibbe> @seen sof
06:03:52 <lambdabot> I haven't seen sof.
06:05:32 <quicksilver> ImInYourMonad: I disagree with Baughn, I would not use STM. I would use plain MVars for a simple program.
06:05:32 <sjanssen> ImInYourMonad: do x <- atomically (takeTMVar v); print x
06:06:04 <quicksilver> STM is useful when you have multiple threads and you need semantics to get multiple consistent reads
06:06:13 <quicksilver> I don't thin your mp3 player example needs that.
06:07:04 * EvilTerran would probably try Control.Concurrent.Chan for a first attempt
06:08:36 <ImInYourMonad> ah all stm-stuff needs atomically?
06:08:46 <EvilTerran> ?hoogle atomically
06:08:46 <lambdabot> Control.Exception NestedAtomically :: Exception
06:09:43 <EvilTerran> atomically :: STM a -> IO a
06:09:59 <EvilTerran> ImInYourMonad, so you need "atomically" to do STM things in an IO block
06:10:48 <ImInYourMonad> still get
06:10:49 <ImInYourMonad> No instance for (Show (IO String))
06:10:49 <ImInYourMonad>       arising from a use of `print'
06:11:04 <trofi> >>= print
06:11:25 <EvilTerran> ?type print
06:11:26 <lambdabot> forall a. (Show a) => a -> IO ()
06:11:31 <EvilTerran> ?type (>>= print)
06:11:32 <lambdabot> forall a. (Show a) => IO a -> IO ()
06:13:02 <EvilTerran> ImInYourMonad, "print" expects a String, not an IO action returning a String, so you need to run the action, bind its result, and then pass the result to print
06:14:19 <EvilTerran> in do-notation, that'd be do { ...; s <- whateverYourActionIs; print s }; more directly, you could write "print =<< whateverYourActionIs"
06:14:24 <ImInYourMonad> text >>= print
06:15:23 <ImInYourMonad> do is syntatic sugar for >>= ? and >>= is bind?
06:15:45 <EvilTerran> yes
06:15:49 <EvilTerran> pretty much
06:18:43 <EvilTerran> ImInYourMonad, the desugaring of do-blocks is described in the report
06:19:56 <EvilTerran> ImInYourMonad, see http://haskell.org/onlinereport/exps.html#sect3.14
06:33:32 <b0fh_ua> Hello! Is there any function in Haskell which can iterate over a list of tuples and pass each tuple to a function for processing?
06:33:40 <Cheshire> yes
06:33:55 <LeoD> map
06:33:58 <hallongrottan> @type map
06:33:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:34:02 <b0fh_ua> map would produce a list
06:34:04 <Cheshire> > let add (x,y) = x + y in   map add [(2,3), (5,1), (7,2)]
06:34:05 <lambdabot>   [5,6,9]
06:34:18 <int-e> b0fh_ua: what does "processing" mean?
06:34:19 <b0fh_ua> I would like to print the tuples
06:34:29 <int-e> b0fh_ua: then use mapM_
06:34:33 <int-e> @type mapM_
06:34:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
06:34:36 <int-e> @type mapM_ print
06:34:37 <lambdabot> forall a. (Show a) => [a] -> IO ()
06:34:52 <DBAlex> b0fh_ua: list comprehension?
06:35:12 <EvilTerran> ?bot
06:35:12 <lambdabot> :)
06:35:29 <EvilTerran> ?vixen how are you today?
06:35:29 <lambdabot> i'm good, you?
06:35:38 <DBAlex> not a function but the easiest way to do it I think (?)
06:35:47 <int-e> > forM_ [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
06:35:48 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
06:36:03 <int-e> > forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b) {- oops -}
06:36:05 <lambdabot>   ["((","(5","(,","(9","()","2(","25","2,","29","2)",",(",",5",",,",",9",",)"...
06:36:16 <int-e> funny
06:36:30 * Baughn blinkblinks
06:36:39 <EvilTerran> i think you've wound up in the [] monad there
06:36:52 <int-e> I know.
06:37:26 <Baughn> > concat $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
06:37:28 <lambdabot>   "(((5(,(9()2(252,292),(,5,,,9,)3(353,393))()5),)9))"
06:37:43 <Cheshire> lol
06:37:51 <idnar> haha what the heck
06:37:54 <int-e> > execWriter (forM_ [(1,2), (4,5)] $ \(a,b) -> tell (show (b,a+b)))
06:37:55 <lambdabot>   "(2,3)(5,9)"
06:38:01 <Cheshire> @remember concat $ forM [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
06:38:01 <lambdabot> I will remember.
06:38:17 <idnar> > (flip map) [(1,2), (4,5)] $ \(a,b) -> show (b,a+b)
06:38:18 <lambdabot>   ["(2,3)","(5,9)"]
06:38:22 <ziman> > mapM (
06:38:22 <lambdabot>   <no location info>: parse error on input `;'
06:38:24 <ziman> oops
06:38:39 <DBAlex> btw does lambdabot run ghci?
06:38:39 * Baughn goes looking for the () monad
06:38:41 <DBAlex> or hugs?
06:38:46 <mauke> DBAlex: no
06:38:52 <DBAlex> ?
06:39:10 <eagleuk> ok
06:39:10 <DBAlex> mauke: neither?
06:39:35 <yitz> > let isSquare x | n < 2 = False | odd n = False | otherwise = let (h, t) = splitAt (n `div` 2) x in h == t where {n = length x} in isSquare "abab"
06:39:36 <lambdabot>   True
06:39:43 <EvilTerran> Baughn, doesn't () have the wrong kind for that?
06:39:45 <yitz> > let isSquare x | n < 2 = False | odd n = False | otherwise = let (h, t) = splitAt (n `div` 2) x in h == t where {n = length x} in isSquare "abcd"
06:39:46 <lambdabot>   False
06:40:04 <Baughn> EvilTerran: I'm sure I can figure out a way to utterly ignore the type argument.
06:40:23 <Baughn> EvilTerran: I'll call it the unit monad
06:40:27 <EvilTerran> Baughn, sure; i think one of the monad libraries on hackage has a Const monad
06:40:35 <Cheshire> @hackage OneTuple
06:40:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OneTuple
06:40:37 <Baughn> Or perhaps the Monad That Makes No Difference
06:40:52 <DBAlex> what is a monad anyway?
06:40:57 <LeoD> noo
06:41:02 <yitz> eagleuk: to make it look nice, you would start a new line at each |, with the same indentation and put the "where { ... }" on the next line with out the { and }.
06:41:26 <EvilTerran> leather, ???
06:41:44 <leather> EvilTerran: EvilTerran???
06:41:55 <Baughn> DBAlex: A very, very loose algebraic class of types that has just enough structure to allow for a nice syntax and a rich combinator library
06:42:07 <yitz> for the other part you need the function "subsequences" that gives all sublists of a list.
06:42:20 <EvilTerran> leather, just wondering why you CTCP TIME, VERSION, and PING'd me
06:42:25 <Baughn> DBAlex: I could try giving an explanation about interpreters or whatever, but it'd be wrong. :P
06:42:26 <DBAlex> Baughn: ok that makes sense :S
06:42:29 <yitz> eagleuk: I've got to run now. good luck!
06:42:39 <DBAlex> Baughn: umm, ok
06:42:44 <eagleuk> ok, thx
06:42:52 <DBAlex> I heard that haskell basically has to have monads to do IO
06:42:57 <DBAlex> why is that ?
06:42:59 <leather> EvilTerran: Sorry, thought you might be somebody I know.
06:43:05 <int-e> DBAlex: lambdabot uses ghc-api via hint and mueval. ghci is implemented on top of ghc-api as well, so ghci isn't that far from the truth.
06:43:06 <Baughn> DBAlex: They're sufficient for IO, yes
06:43:11 <Baughn> DBAlex: They can also do a whole lot more.
06:43:45 <ImInYourMonad> how do I update a record?
06:43:45 <DBAlex> int-e: ok, I was going to say, if its built from scratch its a very nice haskell interpreter :)
06:43:50 <DBAlex> Baughn: ok
06:43:50 <Baughn> DBAlex: If you know any algebra.. it tends to turn out that even very small limitations on what you can do with.. things... produces a rich structure that can be reused elsewhere
06:44:02 <trofi> record{field=value}
06:44:05 <DBAlex> ok
06:44:35 <ImInYourMonad> DBAlex: not sure if this si correct but Monads is not a ahck to do IO, it is an elegant solution to contain side-effects. before Monads IO was done via files i think.
06:44:54 <Baughn> DBAlex: Anyway, I can't explain what monads are short of just stating the requirements for them, because they're too far removed from everyday experience to explain. Any analogies I try will limit them more than they actually are.
06:45:08 <Baughn> DBAlex: And yes, monads /can/ contain side-effects, but that's hardly the only thing they can do
06:45:29 <DBAlex> ImInYourMonad: ok
06:45:49 <DBAlex> what do you mean by side effects
06:45:54 <Baughn> DBAlex: This is not meant to sound zen. The problem is that they're too trivial. :P
06:45:55 <DBAlex> I don't understand what people mean
06:46:04 <DBAlex> when I write functions in other languages I make sure theres no side effects
06:46:11 <DBAlex> only lazy programmers wouldn't do that
06:46:20 <DBAlex> I suppose you can't program for every eventuality though
06:46:24 <DBAlex> so haskell stops that ?
06:46:31 <trofi> type system can force function not to have side effects
06:46:40 <mauke> DBAlex: a side effect is anything that's not related to calculating a return value from parameters
06:46:55 <DBAlex> ok
06:47:03 <pejo> DBAlex, people make mistakes, regardless of if they are lazy or not.
06:47:07 <ImInYourMonad> DBAlex: square x = x * x; if you put in 5 you get out 25, it is a pure fucniton beecause everytime you put in 5 you get 25 out. readFile path; is not pure, it is side-effectful because the file can have different content depending on when you access it
06:47:09 <DBAlex> trofi: but so can the e.g. Java type system?
06:47:17 <DBAlex> so what makes haskell's type system so special?
06:47:19 <Baughn> DBAlex: Haskell doesn't allow side-effects, period, but one use for monads is to collect up side-effects you /want/ to perform and return them in a structure that describes them
06:47:20 <Cheshire> DBAlex, java doesn't
06:47:20 <mauke> if you know C, printf/time/rand/malloc all have side effects
06:47:39 <trofi> DBAlex: java has global classes/vars you can't limit not t use them AFAIU
06:47:55 <DBAlex> ImInYourMonad: ah ok, I get that
06:48:05 <trofi> as they are all mutable
06:48:50 <DBAlex> trofi: but you can't return a different type to the one specified, so theres no side-effects really because of strict typing ?
06:48:55 <DBAlex> or is that not true?
06:49:04 <trofi> yes
06:49:06 <Baughn> Correct
06:49:16 <DBAlex> but java still has side effects?
06:49:27 <trofi> you have to write explicitely what you accept and return
06:49:36 <mauke> DBAlex: java has a return type of 'void'
06:49:38 <DBAlex> and you do with haskell too?
06:49:46 <mauke> DBAlex: 'void' doesn't make sense if you don't have side effects
06:49:55 <Baughn> Java never stops you from calling, say, unsafeBlowUpPlanet(), no matter what return type the function you're writing has
06:49:59 <DBAlex> mauke: true
06:50:04 <DBAlex> thats one thing I miss in haskell
06:50:09 <DBAlex> sometimes you want a void function
06:50:10 <Cheshire> neither does Haskell................
06:50:21 <mauke> DBAlex: actually, you don't
06:50:23 <Baughn> DBAlex: The Haskell equivalent of a void function is one with type IO ()
06:50:34 <trofi> a ()
06:50:34 <trofi> :]
06:50:43 <ImInYourMonad> how do I update a record? without doing a lot of taking it out and in? just updateIn someDataInstance position (+1)
06:50:47 <DBAlex> ok
06:50:49 <Baughn> DBAlex: Which means, more or less, "collection of actions that return nothing but presumably does plenty of side-effects"
06:51:03 <DBAlex> Baughn: can you give me an example?
06:51:11 <Baughn> @type putStrLn
06:51:12 <DBAlex> I suppose putStrLn is one right?
06:51:12 <lambdabot> String -> IO ()
06:51:18 <trofi> ImInYourMonad: record itself is immutable. you can construct new from existing proto
06:51:18 <DBAlex> oops you beat me to it
06:51:19 <DBAlex> ok
06:51:25 <DBAlex> so I can write void functions that way?
06:51:27 <trofi> ImInYourMonad: record{field=value}, no?
06:51:29 <Baughn> putStrLn isn't, really. putStrLn "foo" is. :P
06:51:42 <mauke> trofi: but you can't parameterize over field
06:51:48 <Baughn> DBAlex: Sure
06:51:59 <DBAlex> really though i'd like to be able to do this in haskell String -> Void ()
06:52:04 <DBAlex> but I know thats wrong and horrible etc
06:52:10 <DBAlex> I suppose IO () is the next best thing
06:52:22 <Baughn> DBAlex: For all practical purposes, when looking at function types in other languages, wrap every return type in IO
06:52:26 <mauke> type Void = IO
06:52:31 <Cheshire> DBAlex, Actually what the hell are you talking about?
06:52:33 <mauke> now you can use Void
06:52:39 <DBAlex> yup
06:52:44 <Cheshire> DBAlex, Why is IO 'the next best thing' to Void.. what is better about Void?
06:52:50 <Baughn> DBAlex: So your C print function doesn't return void, it returns IO void
06:53:01 <Baughn> DBAlex: And void, or rather no data, is just ()
06:53:05 <DBAlex> Cheshire: true, I don;t know
06:53:06 <pejo> ImInYourMonad, previousRecord {field = newExpression}
06:53:11 <Cheshire> ok
06:53:14 <DBAlex> It was just a term of speech
06:53:20 <DBAlex> I didn't mean it to sound like void was better
06:53:27 <DBAlex> it would just be nice if void was there from the start
06:53:43 <DBAlex> but I suppose that woild encourage the non-functional style so...
06:53:55 <DBAlex> *would
06:54:00 <trofi> main :: IO ()
06:54:14 <leadnose> well, what else is () if not "void"
06:54:33 <trofi> > length [(), ()]
06:54:35 <lambdabot>   2
06:54:48 <Baughn> DBAlex: I don't really understand what you mean by "there from the start"..
06:55:01 <DBAlex> Baughn: in the Haskell98 spec
06:55:17 <Baughn> DBAlex: The void side-effecting function type is just IO ()
06:55:29 <Baughn> DBAlex: That's in the Prelude. There from the start.
06:55:35 <DBAlex> ok
06:56:04 <Baughn> DBAlex: You don't even need to explicitly tell haskell it's a side-effecting function; the type inference engine will figure that out on its own. (Though you should, for cleanliness)
06:56:32 <Cheshire> Baughn, someone told me that if you put type signatures down your code is "safer" :p
06:56:38 <whpearson> @seen Peaker
06:56:38 <lambdabot> I saw Peaker leaving #haskell and #haskell-blah 1d 21h 15m 16s ago, and .
06:56:41 <Baughn> DBAlex: So no complaining that you have to write.. one more letter than in C, since you don't. :P
06:56:44 <Cheshire> I'm thinking.. yeah you only get type safety if you write the types down...
06:56:55 <Baughn> Cheshire: Nah, you get plenty of type safety regardless
06:57:28 <Baughn> Writing them down is safer in the way that it pins the compiler to your mental image of the program at certain points
06:57:51 <trofi> and less warnings from ghc -Wall
06:57:53 <Baughn> No point in pinning it too often, but doing so occasionally does help prevent it from wandering off into hyperspace if you get things a little wrong. ;)
06:57:57 <ImInYourMonad> i still dont get how to do a function on a record. what datastructure is a record?
06:58:03 <DBAlex> Baughn: ok, I get that now
06:58:12 <DBAlex> Cheshire: we've been told to write out types...
06:58:20 <DBAlex> it makes looking at your program easier imho
06:58:22 <Cheshire> such a weird doctrine
06:58:24 <DBAlex> *understanding
06:58:36 <Cheshire> I don't follow it
06:58:39 <DBAlex> Cheshire: you'd do it in C/C#/Java though
06:58:46 <DBAlex> I know Haskell is dynamically typed but still
06:58:49 <ImInYourMonad> wait i get it
06:58:50 <Cheshire> DBAlex, lol ...
06:58:54 <Baughn> DBAlex: Haskell is statically typed
06:58:59 <DBAlex> :(
06:59:06 <DBAlex> ok
06:59:07 <Baughn> It's just very smart about it
06:59:12 <DBAlex> the interpreter infers the type.. :)
06:59:15 <DBAlex> sorry :(
06:59:15 <Cheshire> DBAlex, because I do something in language A that has no bearing on what I do in language B
06:59:23 <Baughn> DBAlex: So does the compiler
06:59:28 <DBAlex> yup
06:59:37 <Cheshire> DBAlex, this is the whole point of using different programming languages
06:59:59 <DBAlex> yes
07:00:15 <DBAlex> I think its good practice to write out the types, but each to their own
07:00:19 <DBAlex> *it's
07:00:28 <Baughn> It's funny, though. After using haskell for a while.. whenever I write code in dynamic languages, even if it works, I feel like I'm walking on quicksand.
07:00:31 <Baughn> Haskell has spoiled me. :/
07:00:40 <Cheshire> Baughn, I feel like that with Haskell
07:01:03 <Cheshire> Baughn, (after dependently typed programming)
07:01:11 <galdor> hi; I"ve some problem with parsec
07:01:19 <galdor> I'm trying to parse negative integers
07:01:30 <galdor> but I also can have the "-" symbol
07:01:48 <galdor> (but no longer symbol with a "-" at the beginning)
07:01:53 <Cheshire> galdor, you could use a different symbol for unary negation
07:02:10 <galdor> Cheshire: that's kinda cheating, isn't it ?
07:02:22 <Cheshire> galdor, if you move the goalposts I'm not gonna tell anyone :p
07:02:27 <mauke> try (char '-' >> fmap (negate . read) (many1 digit))
07:02:29 <galdor> if I can do it in Yacc, I surely can do it in parsec
07:02:37 <Baughn> galdor: It's not exactly easy. Witness that GHC doesn't do it well. :P
07:02:58 <galdor> mauke: I used option, but gonna try this
07:03:33 <mauke> well yeah, if you can also have positive integers, you might want to change it
07:03:44 <galdor> mauke: yep
07:03:48 <galdor> it's a small lisp parser
07:04:10 <galdor> so I can have the "-" symbol (the substraction) and negative integers
07:04:41 <galdor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1917#a1917
07:04:47 <galdor> it's what I have for the time being
07:05:20 <galdor> it nearly works, it just has problem with things like: "`(+ 1 ,(- 4 2))"
07:07:51 <DBAlex> ok anyone know whats wrong with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1918#a1918
07:08:27 <DBAlex> this should read: otherwise = printchar ""
07:09:38 <whpearson> What happens if someone calls printChar [] ?
07:09:39 <Cheshire> galdor, it's odd to use EList [Expr] rather than ECons Expr Expr
07:09:42 <int-e> DBAlex: yes. (x:xs) matches a list of length at least 1. you need a  printchar [] (or printchar "") case.
07:09:53 <int-e> > "" == []
07:09:54 <lambdabot>   True
07:10:08 <DBAlex> int-e: ok, I tried printchar "" = ""
07:10:14 <DBAlex> but its printchar "" = [] ok
07:10:15 <mauke> DBAlex: length will never return negative values
07:10:23 <DBAlex> I tried printchar "" = IO () too
07:10:34 <mauke> DBAlex: it's "return ()"
07:10:45 <mauke> 'return' is IO's constructor, sort of
07:10:57 <DBAlex> ok
07:11:04 <int-e> DBAlex: printchar "" = return ()
07:11:26 <DBAlex> int-e: yes, just added it now, working perfectly now :) thanks
07:11:36 <DBAlex> int-e: is it bad to use a lot of recursion in haskell?
07:11:43 <galdor> Cheshire: I don't use cons cells
07:11:45 <int-e> DBAlex: no, not at all
07:11:50 <Cheshire> galdor, I can see that :p
07:11:51 <galdor> but you may be right
07:11:57 <galdor> I'm a haskell beginner
07:12:00 <mauke> DBAlex: well, we usually try to abstract it out :-)
07:12:04 <galdor> kinda lisp beginner too
07:12:10 <DBAlex> int-e: how come? does ghc optimize it?
07:12:12 <galdor> I try to learn and toy, so...
07:12:19 <Baughn> DBAlex: Most patterns of recursion can be done more easily with higher-order functions
07:12:23 <Cheshire> galdor, why are you parsing s-exps though?
07:12:32 <Baughn> DBAlex: Like map, or foldr, or scanl, or the Writer monad...
07:12:34 <DBAlex> Baughn: ok, thats my next haskell lecture so :)
07:12:36 <galdor> writing a small lisp interpreter is fun, nope ?
07:12:42 <Cheshire> galdor, ok
07:12:43 <DBAlex> Baughn: ok
07:12:48 <int-e> DBAlex: yes. also there just isn't any other way to accomplish what in other languages would be loops.
07:13:03 <int-e> @src mapM_
07:13:03 <lambdabot> mapM_ f as = sequence_ (map f as)
07:13:09 <int-e> @src sequence_
07:13:09 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:13:14 <int-e> @src foldr
07:13:14 <lambdabot> foldr f z []     = z
07:13:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:13:24 <DBAlex> int-e: yes, that was allways my main problem with haskell, I <3 my for loops ;), but it just forces me to think more recursively
07:13:28 <maxote> @src foldr'
07:13:28 <lambdabot> Source not found.
07:13:39 <maxote> @src foldl
07:13:39 <lambdabot> foldl f z []     = z
07:13:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:13:39 <int-e> DBAlex: see, after two levels of abstraction, mapM_ is a recursive function under the hood
07:13:45 <maxote> @src foldl'
07:13:45 <lambdabot> foldl' f a []     = a
07:13:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:14:09 <DBAlex> int-e: ok
07:14:19 <int-e> DBAlex: and mapM_ essentially captures what you did in printchar: printchar = mapM_ print   would work
07:14:34 <DBAlex> ok
07:14:44 <DBAlex> so its better to use mapM_ or recursion?
07:14:57 <Cheshire> galdor, I would actually write this completely differently
07:15:07 <DBAlex> recursion is less abstracted so, better?
07:15:31 <int-e> DBAlex: use what you're comfortable with. in the long run, learning about the various "loopy" functions like foldr, map, mapM_ and so on will save you a lot of effort
07:15:33 <Baughn> DBAlex: More abstraction is better
07:15:41 <Baughn> DBAlex: Trust the compiler to optimize it. ;)
07:15:53 <DBAlex> ok
07:16:11 <galdor> Cheshire: it's my third or fourth version anyway :p
07:16:18 <galdor> how differently ?
07:16:20 <DBAlex> int-e: and ok, I've briefly looked at map, but I think I have a few mor lectures before we use it properly
07:16:39 <Cheshire> galdor, if you ignore ' and ,@ for a moment,
07:16:40 <DBAlex> *more
07:16:43 <Cheshire> galdor, special symbols are: ( ) ` , |
07:16:54 <Cheshire> galdor, (and we ignore strings too)
07:17:27 <Cheshire> galdor, so you could start by having something to parse an arbitrary symbol,  that would a sequence of any characters that aren't special (or whitespace)
07:17:44 * EvilTerran would lex first
07:17:45 <Cheshire> galdor, (and once that it working, you could add in symbols like  |foo\|bar|)
07:18:19 <Cheshire> galdor, so then the s-exp parser just looks for sequences of symbols between ()'s
07:18:32 <Cheshire> galdor, (and once that works you can add in support for ` and ,)
07:18:51 <Cheshire> galdor, it seems like about 4 or 5 lines of code
07:19:01 <int-e> DBAlex: and being able to write those low level recursions is important, too; it's just that most of the time they follow some general pattern that is captured by combinators in the standard libraries.
07:19:48 <Cheshire> galdor, once you get a parse tree you can turn symbols called  4  into the *number* 4
07:20:13 <Cheshire> galdor, I mean that could happen inside teh 'symbol' parser, but still the concerns are separated
07:20:19 <galdor> yep, but it seems to me the prob is the same
07:20:26 <galdor> I found two aspects
07:20:29 <Cheshire> galdor, no, every problem disappears if you do it my way
07:20:41 <galdor> first idea, a symbol can't begins with a dash
07:20:41 <DBAlex> int-e: ok I see, sometimes they are un-necessary, why is it that languages like C try to persuade you not to use recursion? I know theres the for loop etc but recursion has always seemed more elegant to me...
07:20:54 <Cheshire> galdor, that's some horrendous R6RSism
07:20:56 <galdor> but then I can't have a - operator
07:21:05 <galdor> Cheshire: meaning ?
07:21:08 <galdor> scheme ?
07:21:35 <galdor> so in your way, - isn't a special symbol
07:22:17 <EvilTerran> DBAlex, because loops don't cause stack buildup, while naively-implemented recursion does
07:22:32 <DBAlex> ok
07:22:35 <galdor> so it parses "(- 2 1)" as [POpen, Token "-", Token "2", Token "3", PClose]
07:22:42 <DBAlex> EvilTerran: and using stack space is resource intensive?
07:22:47 <galdor> oh
07:22:54 <ImInYourMonad> how many LOC is ghc? is it a monster to understand?
07:22:59 <EvilTerran> DBAlex, well, stack space is limited
07:23:03 <EvilTerran> you might run out
07:23:19 <galdor> Cheshire: I think you're right
07:23:38 <DBAlex> EvilTerran: ok
07:23:57 <Baughn> DBAlex: The way haskell is implemented stops that two ways - first, compilers are /smart/ about recursion, second it normally handles recursion in heap space, so you won't run out of memory
07:24:17 <int-e> DBAlex: It's a matter of optimisation. C compilers optimize loops very well. On the other hand, C compilers took a long time to learn doing tail recursion elimination. If your algorithm is recusive (say, you're traversing a tree) then you should do it recursively in C as well, imho.
07:25:19 <DBAlex> Baughn: and heap space is larger than stack? Is the heap basically your current free memory?
07:25:32 <Baughn> DBAlex: Yep
07:25:33 <DBAlex> int-e: ok
07:25:37 <int-e> heap space is far easier to grow than stack space
07:25:49 <Baughn> DBAlex: Although, on a 64-bit machine, stack space should also be effectively unlimited. :P
07:25:59 <DBAlex> Baughn: ok, very nice, so I should have enough mem here (2GB) for recursion ;) (hehe joke)
07:26:13 <Baughn> DBAlex: Haskell still can't use it, though; using heap space then is more because lazy evaluation means it has to jump between multiple "stacks" more or less randomly
07:26:49 <Baughn> DBAlex: ..that, and its use sometimes fails to follow a stack discipline
07:26:53 <DBAlex> Baughn: so haskell does use the heap or not?
07:26:55 <ImInYourMonad> is a MVar global? meaning if i pass it to a function from main and then change it do i ahve to somehow reset it in main or I can sideeffect-change it outside?
07:27:02 <DBAlex> well not haskell but GHC
07:27:02 <Baughn> DBAlex: Er. It uses the heap.
07:27:09 <DBAlex> ok
07:27:20 <d_zone_clay> hmm i made my own irc client
07:27:26 <Baughn> DBAlex: It uses the stack only when calculating single thunks
07:27:35 <DBAlex> so why doesn't GCC do recursion on the heap too?
07:27:46 <Baughn> DBAlex: (Or chains of thunks that will collapse to a single value. Don't do that.)
07:28:12 <Baughn> DBAlex: Because GCC lacks automatic garbage collection
07:28:35 <Heffalump> and because a stack has lower overhead than a heap
07:28:35 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
07:28:44 <DBAlex> Baughn: ok
07:28:45 <maxote> the are malloc issues in 64-bit arch, it uses 32-bit limit too
07:29:08 <Baughn> DBAlex: And because a stack hs lower overhead than a heap, yes. Without GC, the overhead is a /lot/ lower.
07:29:20 <pejo> maxote, huh?
07:29:36 <DBAlex> ok
07:29:53 <int-e> ImInYourMonad: you can think of an MVar as a (constant) reference to some place in memory (a mutable variable) which can be changed (and some sort of lock associated with it). What you pass around is the reference. takeMVar and putMVar modify the mutable variable.
07:30:27 <int-e> ImInYourMonad: so I think the answer to your question is 'yes' but I didn't fully understand what you were asking.
07:31:01 <Baughn> DBAlex: Or to put it another way: GCC's memory model is adapted to typical C code. GHC's memory model is adapted to typical Haskell code.
07:31:06 <Baughn> DBAlex: Those are very different beasts.
07:31:33 <DBAlex> yeah
07:31:56 <DBAlex> you're going to expect a lot of recursion, list comprehensions vs loops and memory management in C i'm guessing
07:32:01 <int-e> Sadly processors are adapted to C's memory model ... and Haskell suffers.
07:32:10 <DBAlex> and it obviously makes sense to optimize to most used features
07:32:29 <DBAlex> int-e: maybe someone can make a cpu for haskell ;)
07:32:42 <DBAlex> isn't there a CPU based around the jvm?
07:32:53 <NameAlreadyInUse> int-e: operating systems too, i'd imagine
07:32:58 <Heffalump> there have been very few concrete suggestions about how you could actually make hardware optimised for Haskell
07:33:01 <int-e> (but it suffers less than people originally expected)
07:33:16 <Baughn> Heffalump: Well, hardware garbage collection?
07:33:24 <Baughn> Perhaps implemented in parallel on the memory chips
07:33:43 <ImInYourMonad> so is the reduceron very promising?
07:34:08 <ImInYourMonad> I have this annoying problem with gtk2hs that I can only use it when compiling, not from ghci. because of this I cant get the types of functions and I have a hard time inferring them myself which in turn makes debugging hard. is it no possible to use gtk2hs from ghci?
07:34:26 <pejo> Baughn, people are prepared to take the performance hit of gc nowdays, otherwise we wouldn't have it in all new languages.
07:34:30 <Heffalump> garbage collection is often tied very closely to the memory model
07:34:50 <Heffalump> ImInYourMonad: it works fine for me
07:34:56 <Baughn> Right, but for a cpu specifically adapted to haskell...
07:34:56 <PeakerWork> @type fix
07:34:57 <lambdabot> forall a. (a -> a) -> a
07:35:15 <EvilTerran> ?src fix
07:35:15 <lambdabot> fix f = let x = f x in x
07:35:19 <EvilTerran> meh
07:35:22 <Baughn> Might have a call instruction that looks up the typeclass dictionary, too
07:35:24 <Heffalump> Baughn: you mean specifically adapted for GHC's current memory model?
07:35:27 * EvilTerran prefers "fix f = x where x = f x"
07:35:39 <Baughn> Heffalump: I suppose
07:35:55 <ImInYourMonad> is gc slow anyway for big programs with large amount of collaborators? Meaning it can be written and debugged faster thus spend more time optimizing on a higher level -> faster program anyway?
07:36:00 <Baughn> Heffalump: The only way I see it ever happening is with nanofactories or something, in which case we could release updates at need
07:36:01 <opqdonut> EvilTerran: :)
07:36:03 <PeakerWork> I just read about the Curry-Howard isomorphism.  fix is the proposition that (a implies a) implies a -- but (a implies a) is always True, thus did I just prove that (forall a. a) is True?
07:36:10 <maxote> fix f x = x
07:36:10 <pejo> Baughn, Mark Jones specialized away a whole bunch of those things, and got a decrease of code size.
07:36:16 <DBAlex> hmm
07:36:17 <ErhardtMundt> hi
07:36:18 <Heffalump> since noone has considered hardware GC even for "mainstream" languages like Java/C#, I can't see it being feasible.
07:36:24 <DBAlex> how do I convert from Char -> String ?
07:36:26 <EvilTerran> PeakerWork, no, because fix isn't a well-founded recursion
07:36:27 <Heffalump> s/considered/seriously considered/
07:36:30 <ImInYourMonad> Heffalump: you use window vista? linux i suppose?
07:36:33 <Heffalump> DBAlex: \x -> [x]
07:36:33 <skorpan> DBAlex: f x = [x]
07:36:35 <PeakerWork> EvilTerran: I see, thanks
07:36:43 <DBAlex> ok
07:36:44 <Heffalump> ImInYourMonad: I don't use vista, correct
07:36:45 <skorpan> DBAlex: remember that [Char] is the same as String
07:36:47 <LeoD> > fix (+2)
07:36:51 <Heffalump> I do have XP but I'm not using gtk2hs on that
07:37:02 <lambdabot>   thread killed
07:37:06 <LeoD> :O
07:37:38 <DBAlex> skorpan: thats what I thought so I did this: do {putStrLn  [intToDigit x];printints xs;}
07:37:46 <DBAlex> but it still gave me an error
07:37:54 <Baughn> > fix (+2) :: Sym
07:37:55 <lambdabot>       `Sym' is not applied to enough type arguments
07:37:55 <lambdabot>      Expected kind `?', b...
07:37:57 <EvilTerran> PeakerWork, i'm not sure how that restriction's formalised in terms of curry-howard, though
07:38:12 <skorpan> DBAlex: what are you trying to accomplish?
07:38:26 <EvilTerran> PeakerWork, i guess it comes under "no bottoms"
07:38:29 <Heffalump> EvilTerran: doesn't the Curry-Howard isomorphism only apply to simply-typed lambda calculus?
07:38:34 <DBAlex> skorpan: printing a list of integers, E.g. [1..10]
07:38:37 <ehird> it occurs to me that "newIORef Nothing" breaks typesafety.
07:38:46 <PeakerWork> EvilTerran: yeah I understand
07:38:49 <skorpan> DBAlex: mapM_ (putStrLn . show) [1..10]
07:38:52 <EvilTerran> Heffalump, ah, yes, that would cover it
07:38:56 <Cheshire> Heffalump, and stronger typed calculus
07:38:57 <skorpan> or maybe just mapM_ print [1..10]
07:39:02 <Heffalump> ehird: you won't be able to do that without fixing the type of the Nothing
07:39:14 <ehird> hm, right
07:39:17 <ehird> works in ghci, though.
07:39:20 <Baughn> DBAlex: print [1..10] ....is cheating, I suppose
07:39:25 <DBAlex> skorpan: ok...
07:39:26 <Heffalump> that'll be defaulting to ()
07:39:39 <Heffalump> oh, well :t doesn't say it is
07:39:40 <DBAlex> Baughn:  I want to use putStrLn
07:39:51 <Baughn> DBAlex: putStrLn (show [1..10])?
07:39:52 <LeoD> putStrLn $ show [1..10]
07:39:58 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1919#a1919 <- my GUI crashes, probably doing something wrong when mutating MVar.
07:39:59 <Heffalump> but if you do x <- ... and then :t x, it defaults the variable to GHC.Prim.Any
07:40:27 <DBAlex> Baughn: ok
07:40:32 <DBAlex> LeoD: whats $ ?
07:40:55 <Cheshire> PeakerWork where did you read about it?
07:41:06 <Baughn> DBAlex: Printing lists is special-cased anyhow, so you can't really do it in any more code.. unless it's a /lot/ of more code
07:41:12 <mauke> @src ($)
07:41:13 <lambdabot> f $ x = f x
07:42:20 <DBAlex> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1920#a1920
07:42:27 <DBAlex> can't understand why that won't work though ?
07:42:37 <PeakerWork> Cheshire: http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
07:42:42 <PeakerWork> Cheshire: reddit submission, dons I think
07:43:00 <int-e> ImInYourMonad: getSong should use readMVar, I think.
07:44:57 <DBAlex> actually, it does work
07:45:02 <DBAlex> it was my other code that didn't
07:46:31 <ImInYourMonad> int-e: thanks that worked
07:47:58 <ImInYourMonad> Occurs check: cannot construct the infinite type: a = MVar a
07:47:58 <ImInYourMonad>     When generalising the type(s) for `playNext'
07:48:03 <ImInYourMonad> playNext :: MVar a -> IO a
07:49:00 <ImInYourMonad> ah
07:57:36 <ImInYourMonad> (Main.exe:5312): Gtk-WARNING **: Attempting to add a widget with type GtkButton
07:57:36 <ImInYourMonad> to a GtkWindow, but as a GtkBin subclass a GtkWindow can only contain one widget
07:57:36 <ImInYourMonad>  at a time; it already contains a widget of type GtkButton
07:57:47 <ImInYourMonad> so what do you use for several buttons? anyone know?
07:57:51 <defun> :t GenParser
07:57:52 <lambdabot> Not in scope: data constructor `GenParser'
08:00:40 <defun> :t many
08:00:41 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
08:00:58 <trofi> @src foldl'
08:00:58 <lambdabot> foldl' f a []     = a
08:00:58 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:05:38 <MiniCow> Is it possible to have a function A, that returns a function that is the same type as function A?
08:05:51 <opqdonut> yes, using recursive types
08:05:58 <EvilTerran> MiniCow, that would have an infinite type
08:06:20 <opqdonut> so something like "data Funny a = Funny (a -> Funny a) |Val a"
08:06:51 <opqdonut> which contains all types (a->)*n a
08:06:52 <EvilTerran> Mu Endo!
08:06:56 <opqdonut> indeed
08:07:08 <opqdonut> Mu Endo is just a bit useless as such :)
08:07:23 <MiniCow> Mu Endo?
08:07:30 <EvilTerran> ,src ''Mu
08:07:36 <lunabot>  newtype Mu f = Mu (f (Mu f))
08:07:37 <EvilTerran> ,src ''Endo
08:07:38 <lunabot>  luna: Not in scope: type constructor or class `Endo'
08:08:12 <kerlo> More fun is a function A that takes a function of the same type of A.
08:08:55 <MiniCow> EvilTerran: It wasn't going to return just the same function type, but it's part of what it'll return.
08:08:58 <EvilTerran> newtype Endo a = Endo (a -> a)
08:09:11 <MiniCow> There'll be a termination in there somewhere (I hope)
08:09:36 <kerlo> > let count x | odd x = 1 + count (x `div` 2); count 0 = 0; count x = count (x `div` 2) in concat (map (show . count) [0..])
08:09:37 <lambdabot>   "01121223122323341223233423343445122323342334344523343445344545561223233423...
08:09:47 <EvilTerran> MiniCow, you'll need a data or newtype somewhere in there to express the recursive type, then
08:10:00 <MiniCow> Ok, cheers. I'll have a play
08:10:05 <EvilTerran> MiniCow, making the return type an appropriate data would probably suit
08:10:35 <EvilTerran> (returning something like opqdonut's suggestion of "data Funny a = Funny (a -> Funny a) | Val a")
08:11:30 <DBAlex> btw what does let do ?
08:12:01 <DBAlex> > do { let x | x <- "Hello" ; print x;}
08:12:02 <lambdabot>   <no location info>: parse error on input `;'
08:12:07 <ImInYourMonad> http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/Data-Graph.html <- how do i actually make a graph? and can it be used for Travelling Salesman Problem?
08:12:07 <DBAlex> hmm
08:12:40 <DBAlex> > do {let x "hello"; print x}
08:12:41 <lambdabot>   <no location info>: parse error on input `;'
08:12:46 <DBAlex> > do {let x "hello"; print x;}
08:12:47 <lambdabot>   <no location info>: parse error on input `;'
08:12:56 <DBAlex> nope
08:13:17 <DBAlex> > do {x = "hello"; print x;}
08:13:18 <lambdabot>   <no location info>: parse error on input `='
08:13:29 <DBAlex> obviously not right :/
08:13:34 <kerlo> > do {let x = "hello"; print x}
08:13:35 <lambdabot>   <no location info>: parse error on input `}'
08:13:41 <kerlo> That's weird.
08:13:54 <kerlo> > do let x = "hello"; print x
08:13:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:14:00 <mauke> stop spamming plz
08:14:07 <DBAlex> > do { let x = "hello;print x;}
08:14:08 <lambdabot>   <no location info>:
08:14:08 <lambdabot>      lexical error in string/character literal at chara...
08:14:11 <kerlo> lambdabot doesn't like printing things anyway.
08:14:31 <DBAlex> kerlo:  that should work right?
08:14:53 <mauke> > do let {x = "hello"}; [x]
08:14:54 <lambdabot>   ["hello"]
08:15:04 <kerlo> DBAlex: pretty much, though it's not going to work without a closing quote.
08:15:16 <mauke> you're missing braces around the let bindings
08:15:16 <kerlo> > let a = b ++ b; b = c ++ c; c = d ++ d; d = e ++ e; e = f ++ f; f = "hi" in a
08:15:17 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi"
08:15:29 <DBAlex> kerlo: ok
08:16:39 <DBAlex> do {putStrLn (charToString ((intToDigit x)) ++ other; let {other = other ++ " "};printints xs;}
08:16:44 <DBAlex> whats wrong with this then?
08:17:04 <mauke> ((x)) better written as (x)
08:17:06 <DBAlex> > do let {other = other ++ " "}; print other
08:17:08 <lambdabot>   * Exception: "<IO ()>"
08:17:10 <DBAlex> > do let {other = other ++ " "}; print other;
08:17:11 <lambdabot>   * Exception: "<IO ()>"
08:17:18 <beelsebob> > fix ("hi"++)
08:17:19 <lambdabot>   "hihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihihi...
08:17:34 <DBAlex> ok
08:17:39 <mauke> DBAlex: unmatched '('
08:18:54 <kerlo> DBAlex: why are you doing let {other = other ++ " "}?
08:19:02 <DBAlex> trying to append a space to other
08:19:06 <ProdigySevenX> /msg nickserv identify centre
08:19:30 <DBAlex> other is just a blank string
08:19:30 <DBAlex> other :: String
08:19:30 <DBAlex> other = ""
08:19:34 <mauke> DBAlex: no, it isn't
08:19:39 <kerlo> Try using let {other' = other ++ " "} and then using other' instead of other from then on.
08:19:43 <mauke> DBAlex: 'other' is bound by that let statement
08:19:58 <DBAlex> ko
08:20:01 <DBAlex> *ok
08:20:32 <kerlo> let {other = other ++ " "} will define other recursively.
08:21:06 <ProdigySevenX> hm
08:21:07 <DBAlex> ok
08:21:09 <EvilTerran> > let xs = [1] in let xs = 2:xs in xs
08:21:09 <DBAlex> brb
08:21:10 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
08:21:42 <EvilTerran> (the inner "xs" hides the outer one, even in its own definition)
08:24:01 <DBAlex> what I really want to do is this
08:24:20 <DBAlex> each time printints is called I want to add " " to other
08:24:25 <DBAlex> ?
08:26:11 <ProdigySevenX> hmm
08:29:05 <mdmkolbe> Is there a way do the equivalent of pattern matching against "Left Just".  I.e. pattern match a constructor that hasn't yet been applied to it's argument.  (Solutions that involve representing constructor with other types are ok, but I shouldn't have write code for each constructor I want to match.)
08:29:37 <Heffalump> mdmkolbe: no
08:29:52 <Heffalump> unless you use TH to generate code for each constructor
08:29:52 <EvilTerran> ?type Just
08:29:53 <lambdabot> forall a. a -> Maybe a
08:30:12 <EvilTerran> "Just" on its own has a function type, so is wholly abstract
08:30:14 <Heffalump> a constructor that hasn't yet been applied is just a closure
08:31:28 <catalan88> hello
08:31:29 <catalan88> anyone giving away his warcraft account ? pm me
08:31:44 --- mode: ChanServ set +o Heffalump
08:31:57 <mdmkolbe> Heffalump: yes, which is the exact problem I'm trying to get around
08:32:14 --- mode: Heffalump set +b *!*@dxb-as72773.alshamil.net.ae
08:32:31 <mdmkolbe> Heffalump: how would TH solve this?
08:32:48 <Heffalump> mdmkolbe: well, you could generate a separate constructor to mirror the base ones
08:33:40 <DBAlex> EvilTerran: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1923#a1924 < so why doesn't this work?
08:33:48 <mdmkolbe> Heffalump: does TH have a way of inspecting types?  (I assume you mean something like that)
08:33:55 <DBAlex> it compiles but just prints them with no identation
08:34:04 <Heffalump> mdmkolbe: in the sense that it can inspect syntax and get definitions, yes
08:34:15 <DBAlex> (oops, missed the 3, should read printints [1,2,3,4,5]) - you get the idea...
08:35:08 <EvilTerran> DBAlex, well, we've already gone over what's wrong with let {other = other ++ " "}
08:35:20 <DBAlex> I know but what do I change so it does work?
08:35:29 <DBAlex> I understand that its in its own scope but..
08:35:34 <mdmkolbe> Heffalump: ah, so all the data types I want to use would have to be declared inside a TH macro (or what ever they are called).  I was hoping there might be a way to call the TH macro after the fact
08:35:45 <Heffalump> mdmkolbe: I think you can get hold of them afterwards from TH
08:35:48 <EvilTerran> mdmkolbe, you might be able to, with TH's "reify"
08:35:51 <Heffalump> in fact I'm sure you can
08:36:17 <EvilTerran> DBAlex, well, it comes down to "other" not being a mutable variable
08:36:19 <DBAlex> EvilTerran: how do I append " " to other and change other each time ?
08:36:30 <DBAlex> EvilTerran: ok ?
08:36:31 <EvilTerran> or anything else there being mutable, for that matter
08:36:48 <mdmkolbe> @index reify
08:36:48 <lambdabot> Language.Haskell.TH.Syntax, Language.Haskell.TH
08:36:57 <DBAlex> EvilTerran: so I can't do it?
08:37:09 <EvilTerran> DBAlex, if you want a name to be associated with a different value between one recursive call and the next, you need to pass it as a parameter to the recursing function
08:37:13 <Karloo> haskell
08:37:19 <EvilTerran> Karloo
08:37:19 <ImInYourMonad> so any get Data.graph ?
08:37:28 <DBAlex> EvilTerran: ok
08:37:36 <Karloo> haskell
08:38:35 <trofi> :\
08:38:37 <EvilTerran> DBAlex, i would suggest making the new version of "other" be ' ':other, rather than other++" "
08:38:56 <ImInYourMonad> there doesnt seem to eb an insert function either(in Data.Graph)
08:38:57 <EvilTerran> DBAlex, seeing as (:) is O(1) and (++) is O(n)
08:39:08 <Karloo> haskell
08:40:09 <EvilTerran> Karloo?
08:40:11 <DBAlex> pl
08:40:17 <DBAlex> *ok
08:40:29 <DBAlex> EvilTerran: I don't understand that but ok ( seeing as (:) is O(1) and (++) is O(n) )
08:40:29 <Karloo> yes?
08:40:46 <EvilTerran> Karloo, just wondering why you keep saying "haskell"
08:40:56 <Karloo> because it's correct
08:41:02 <NameAlreadyInUse> @src (++)
08:41:02 <lambdabot> []     ++ ys = ys
08:41:02 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:41:02 <lambdabot> -- OR
08:41:02 <lambdabot> xs ++ ys = foldr (:) ys xs
08:41:04 <EvilTerran> DBAlex, i mean, (:) takes a constant amount of time to run
08:41:17 <EvilTerran> DBAlex, but (xs ++ ys) takes an amount of time proportional to the length of xs
08:41:24 <DBAlex> k
08:41:30 <EvilTerran> (and the same applies for memory consumption)
08:41:40 <Karloo> haskell
08:41:56 <mauke> Karloo: please stop
08:42:48 <Karloo> stop what
08:42:53 <aluink> so i've read up on CT and how Monads fit into it and get it...now i'm missing the "why bother" part
08:43:09 <Heffalump> saying 'haskell' for no apparent reason repeatedl
08:43:10 <Heffalump> y
08:43:33 <Karloo> but haskell is correct
08:43:48 <Cheshire> @info Haskell
08:43:48 <lambdabot> Haskell
08:43:55 --- mode: ChanServ set +o mauke
08:44:02 <Heffalump> correct in what sense? Saying it certainly doesn't contribute to the conversation.
08:44:05 <Cheshire> nice move mauke
08:44:13 <NameAlreadyInUse> what is "ChanServ" anyway?
08:44:15 <Heffalump> does that differ from a kick?
08:44:20 <EvilTerran> "haskell" is not a predicate; correctness is not a well-defined property of it
08:44:21 <Heffalump> NameAlreadyInUse: the channel services
08:44:38 <mauke> Heffalump: yes, it's exactly like a /part except it doesn't originate at the victim's client
08:44:45 <NameAlreadyInUse> so who decides that ChanServ should +o mauke?
08:44:49 <Heffalump> mauke: interesting. What's the point
08:44:55 <Heffalump> NameAlreadyInUse: mauke would have requested it by messages
08:45:02 <NameAlreadyInUse> ah, i see
08:45:06 <EvilTerran> NameAlreadyInUse, i'm guessing mauke requested it in a private message to ChanServ
08:45:08 <Heffalump> he's on the ops list for the channel (as am I)
08:45:08 <mauke> Heffalump: some scripts aren't triggered by it (like rejoin-on-kick)
08:45:19 <Heffalump> mauke: cunning :-)
08:45:21 <EvilTerran> mauke, ah, cunning
08:45:25 <aluink> so did anyone process my question from above?
08:45:26 <Heffalump> how do you ask for it?
08:45:36 <Heffalump> aluink: CT?
08:45:42 * Heffalump doesn't really know either :-)
08:45:56 --- mode: mauke set -o mauke
08:45:56 <aluink> Heffalump: yes
08:46:00 <EvilTerran> aluink, why bother with what in what context?
08:46:03 <Zao> NameAlreadyInUse: You can  /query chanserv help  to learn more.  access #haskell list  should tell you who can do what.
08:46:03 --- mode: Heffalump set -o Heffalump
08:46:09 <EvilTerran> monads in programming? CT in general? ...
08:46:20 <aluink> Monads in programming
08:46:39 <mauke> Heffalump: /alias remove quote REMOVE $C $0 :$1-
08:46:51 <NameAlreadyInUse> Zao: thanks
08:47:12 <Heffalump> ah, so REMOVE is an extension to the IRC protocol?
08:47:21 <EvilTerran> aluink, well, they're an abstraction which fits a lot of constructs that come up in functional programming
08:47:25 <mauke> Heffalump: yeah
08:47:33 <sclv_> missing why haskell uses them, you mean, or missing why the fact that they relate to math is useful and they can't just be, e.g., an interface?
08:47:37 <Heffalump> definitely a better idea than bans, thanks
08:47:50 <DBAlex> EvilTerran: Hmm, *** Exception: basicio.hs:(19,0)-(21,31): Non-exhaustive patterns in function printints
08:49:05 <aluink> sclv_: why does Haskell care so much about them, i see why they related to math, clearly they are math ;)
08:49:07 <EvilTerran> DBAlex, you're doing something rather weird with the parameter to printints
08:49:37 <NameAlreadyInUse> wait, what is this CT business?
08:49:46 <EvilTerran> NameAlreadyInUse, Category Theory
08:49:58 <NameAlreadyInUse> oh, of course
08:50:02 <sclv_> aluink: the relationship to math can be worried about later. the main point is that, like EvilTerran said, they provide, especially with the syntactic sugar of do notation, a way to do lots of things simply.
08:50:34 <EvilTerran> DBAlex, the pattern-matching between [] and (x:xs) already distinguishes between the empty list and non-empty list cases, there's no need to take the length of the list
08:50:38 <DBAlex> EvilTerran: my updated code at the bottom: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1923#a1925
08:50:49 <DBAlex> umm ok
08:51:04 <sclv_> when you start using haskell, you may well use them only on occasion, and only for IO.
08:51:45 <sclv_> but as you start doing more complex things, you'll write code that, it turns out, can probably be expressed more simply with some monad or stack of monad transformers.
08:53:04 <aluink> sclv_: yeah, haven't gotten to MTs yes
08:53:15 <aluink> yet*
08:54:09 <sclv_> i don't think there's any need to rush and learn the math and all that at once, but rather just to start doing things in haskell, and the need for particular monads will arise pretty naturally.
08:54:26 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1926#a1926 <- can I bind that somehow? using >>= I mean to make it a 1-liner?
08:54:28 <EvilTerran> DBAlex, i'm afraid i've gotta head off; maybe someone else can help you out
08:54:38 <aluink> sclv_: i'm a math/cs student, the math is just as fun as the programming ;)
08:55:10 <aluink> EvilTerran: Just someone or Nobody ;)
08:55:11 <mauke> ImInYourMonad: why do you need to return state?
08:55:15 <DBAlex> EvilTerran: ok, well I got it working, it idents the numbers, still got the exception though, but i'll work through it :), thanks for your help ! :-)
08:55:23 <sclv_> @undo do {newState <- takeMVar state; putMVar state (newPos newState);  return state}
08:55:23 <lambdabot> takeMVar state >>= \ newState -> putMVar state (newPos newState) >> return state
08:55:31 <mauke> ImInYourMonad: your caller already has it since he gave it to you
08:55:37 <trofi> :t withMVar
08:55:38 <lambdabot> Not in scope: `withMVar'
08:56:08 <trofi> @hoogle withMVar
08:56:08 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
08:56:13 <sclv_> ImInYourMonad: lambdabot can almost always undo do notation^^
08:56:46 <DBAlex> EvilTerran: I think its the base case anyway
08:57:24 <sclv_> aluink: ah, ok then. but the trick then i guess is that the way that Haskell uses CT, in my understanding, gives little brain spasms to people who specialize in pure CT, at least some of them.
08:57:36 <ImInYourMonad> mauke: i dont
08:58:15 <sclv_> So, as is discussed periodically on -cafe, you need to gloss over some of the infelicities of the translation in order for these analogies and correspondences to hold.
08:58:37 <ImInYourMonad> what type does a functionr eturning nothing have?
08:58:39 <mauke> playNext state = takeMVar state >>= putMVar state . newPos
08:58:44 <mauke> ImInYourMonad: IO ()
08:58:58 <ImInYourMonad> playNext :: MVar PlayerState -> ()
08:58:58 <aluink> sclv_: in school we only studied as high as Abstract Algebra in the abstraction stack, so CT is new to me entirely. though I find it simpler than AA; seems to be a trend of things as you increase the abstraction
09:00:47 <aluink> sclv_: after a while, arithmetic is becomes the hardest to learn/teach/do in math, the part people dislike the most (generally).  the part that gives math it's bad name to those who dislike it.
09:01:17 <mmorrow> garrrhh, i forgot how tedious doing non-trivial datastructures in C is
09:01:39 <mauke> just use arrays!
09:01:43 <mmorrow> or maybe i should now, now that i know how non-tedious doing datastructures can be
09:01:46 * mauke runs off
09:01:48 <mmorrow> mauke: heh
09:01:54 <aluink> sclv_: i've always wondered what it's be like if math curricula would be taught top down, instead of bottom up, short of it's lack of usefulness IRL until you finally reach the bottom
09:02:05 <aluink> its*
09:02:11 <mmorrow> *or maybe i should say, now ....
09:02:51 <mmorrow> aluink: i think a combination would be ideal
09:03:03 <pk1> the human brain needs example in order to understand abstract concept
09:03:22 <aluink> pk1: good point
09:03:28 <maxote> pk1, as a car without wheels?
09:03:35 <mmorrow> but also needs context
09:03:46 <aluink> mmorrow: i would tend to agree
09:04:03 <pk1> maxote, what do you mean ?
09:04:23 <aluink> my advantage in math through my school years was that i was able to often abstract out patterns of what we were learning, hence supporting the combination claim
09:04:34 <maxote> i mean, i don't put wheels to the car because they are abstract, xDDD
09:05:40 <aluink> concrete math is useful in everyday life, but being able to abstract patterns out provides tools and methods for solving more complex problems
09:06:03 <pk1> I agree
09:06:20 <maxote> too abstractism yields a lack of primitives in the imagination
09:06:41 <aluink> often people who lack problem solving skills, in my humble experience, has been that they are unable to see the "bigger picture", the pattern behind it all
09:06:56 <pk1> but even if one's goal is to solve more complex problems, he should learn with concrete example
09:07:09 <aluink> pk1: for sure
09:07:21 <monochrom> I believe in Piaget's theory. From concrete to abstract. Throw a ton of examples at the brain. And it has to be really tons.
09:07:22 <pk1> aluink, I agree too
09:08:03 <pk1> I know when I was taught math we were just given formulas, and it was awfull
09:08:07 * monochrom now reads scrollback to see what this is about :)
09:08:15 <maxote> when it ocurrs, the abstractism in excess should be complemented with many examples using some primitives
09:09:02 <DBAlex> ok this is still giving me errors http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1923#a1927
09:09:04 <aluink> my favorite is the method of solving products of powers using the log/power homomorphism; ie: 32 * 64 = 2^5 * 2^6 = 2^(5+6) = 2^11 = 2048
09:09:11 <DBAlex> anyone know why? ;-(
09:09:51 <aluink> pk1: yes, but those formulas were abstract representations of patterns
09:10:05 <aluink> pk1: deriving those formulas was important to me
09:10:25 <monochrom> x+y=y+x is an abstract law. It doesn't feel abstract to you because when you were an unconscious kid you had had enough experience noticing that stacking up 2 blocks then 3 blocks is the same as stacking up 3 blocks then 2 blocks.
09:10:29 <defun> why would a "try" be useless for "\n" (this arguament) in this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1928#a1928
09:10:48 <defun> *(third argument)
09:11:20 <Valodim> DBAlex: well non-exhaustive pattern as the error says. the function printints is undefined for an empty array with a non-empty string
09:11:25 <mmorrow> maxote: i think it depends on the person. some like to use abstract primitives, and some don't
09:11:47 <DBAlex> Valodim: I tried to define that, but it still didn't work
09:11:47 <lilac> defun: because it's only parsing one character
09:11:55 <ddarius> bos: Keynote speaker, congratulations.
09:11:56 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1926#a1929 <- and that? I find using >>= being more elegant instead of creating loads of intermediate variables
09:11:59 <Valodim> printints [] _ = return ()
09:11:59 <Valodim> use the underscore if you don't care for an argument
09:12:02 <maxote> monochrom, x+y=y+x if the operator + is simmetric, otherwise it won't be an equation.
09:12:05 <DBAlex> Valodim: ok
09:12:06 <lilac> defun: try says, 'run this parser and retry from here if it fails'
09:12:07 <monochrom> defun: "try" is not useless there.
09:12:38 <lilac> defun: string "\n" == char '\n', and as such it'll retry there anyway
09:12:51 <mdmkolbe> Hmm, the TH library API documentation seems to be a little sparse (e.g. what is a RecC?).  Is there someplace better to look for documentation?
09:13:18 <defun> lilac: so \n is a char?
09:13:25 <mmorrow> , src 'RecC
09:13:28 <lunabot>  data Con = ... | RecC Name ([VarStrictType]) | ...
09:13:28 <lunabot>  infixl 9
09:13:43 <maxote> ?agda
09:13:43 <lambdabot> Unknown command, try @list
09:13:44 <mmorrow> mdmkolbe: :info Foo   in ghci is a life-saver
09:13:48 <lilac> > length "\n"
09:13:50 <lambdabot>   1
09:13:59 <defun> I see. Thanks.
09:14:00 <mmorrow> especially with TH / anything with huge datatypes
09:14:12 <mmorrow> (huge := lots of constructors)
09:14:22 <mdmkolbe> mmorrow: finding the type of RecC is easy, the problem is I don't understand what sort of program construct a RecC represents
09:14:23 <maxote> is there any agda-like in Haskell that has the same power of coq?
09:14:31 <Cheshire> maxote, what
09:14:33 <sw17ch> is there anything uber slick in the new c2hs?
09:14:41 <mmorrow> also, tab-complete-fishing in ghci is also super great here
09:14:41 <sw17ch> besides using the Language.C backend?
09:14:57 <maxote> i'm looking for an infinite-order polymorphic predicate type system
09:15:05 <mmorrow> mdmkolbe: another nice method is using TH to show you what things are
09:15:12 <mmorrow> like
09:15:14 <aluink> mmorrow: yes, but i've found that most often those who like the abstract primitives are those who enjoy math, and are able to thrive in it, those who dislike abstractions have been those who quickly see it as busy work and get fed up with it
09:15:21 <mmorrow> , [|\x->x|]
09:15:22 <lunabot>  LamE [VarP x_0] (VarE x_0)
09:15:38 <mmorrow> (lunabot has an instance of Show defined for ExpQ)
09:15:40 <mmorrow> in ghci that'd be
09:15:42 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1926#a1929 <- the bottom one
09:15:48 <mmorrow> runQ [|\x->x|]
09:15:52 <aluink> mmorrow: i'm of course leaving room for exceptions
09:16:07 <mmorrow> , [|Node{rootLabel=()}|]
09:16:09 <lunabot>  RecConE Node [(rootLabel,ConE ())]
09:16:09 <DBAlex> Valodim: yes that works perfectly
09:16:20 <DBAlex> Valodim: I was sure the base case was wrong, so that solves it :)
09:16:28 <mmorrow> , [d|data A = A {foo::()}|]
09:16:29 <lunabot>  DataD [] A [] [RecC A [(foo,NotStrict,ConT ())]] []
09:16:29 <ddarius> aluink: So people who enjoy math enjoy busy work?
09:16:37 <mmorrow> there we go :)
09:16:38 <mdmkolbe> mmorrow: heh, rec = Record not recursive like I thought
09:16:38 <lilac> ImInYourMonad: readMVar state >>= join (liftM2 (!!) playlist position)
09:16:58 <mmorrow> mdmkolbe: yeah, suffix "C" as in Con
09:17:03 <aluink> ddarius: NO! by using abstractions, it doesn't become busy work
09:17:04 <mmorrow> oh, i see how you mean
09:17:11 <lilac> ImInYourMonad: i'm guessing you're missing a 'return'?
09:17:24 <mdmkolbe> mmorrow: yeah I thought this was some sort of mu like recursive constructor or something
09:17:34 <mmorrow> heh
09:17:38 <lilac> ImInYourMonad: readMVar state >>= return <$> join (liftM2 (!!) playlist position)
09:18:29 <aluink> ddarius: when a particular subject starts to get very tedious, patterns are extracted and another layer of abstraction can be added
09:18:33 <mmorrow> aluink: and i'm sure vice-versa is true too :)
09:18:48 <mmorrow> (re: ....  who like the abstract primitives are those who enjoy math, ....)
09:18:56 <mdmkolbe> mmorrow: someone needs to go through the TH API and just put something like a one line example of code that would produce each sort of constructor, it would make understanding the TH types much easier
09:19:21 <mmorrow> mdmkolbe: someone really does.
09:19:25 <aluink> mmorrow: explain
09:19:31 <mmorrow> mdmkolbe: i'm going to try to do that.
09:19:55 <ddarius> There should be in the source.
09:20:01 <DBAlex> hmm intToDigit breaks with integers > 9
09:20:06 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1926#a1930 <- lilac
09:20:15 <DBAlex> how do you convert 25 to "25"?
09:20:16 <lilac> DBAlex: integers > 9 aren't digits
09:20:21 <aluink> DISCLAIMER: i'm not saying abstractions are the food for life, i'm saying they are useful tools for solving more complex problems
09:20:23 <mmorrow> aluink: as in, i'd bet that most people that like using X type of primitives get bored/fed up with dealing in Y type of primitives :)
09:20:25 <lilac> DBAlex: show
09:20:26 <DBAlex> lilac: exactly
09:20:31 <DBAlex> lilac: ok
09:21:01 <mmorrow> where X, Y `elem` [Abstract, Concrete]
09:21:04 <maxote> an A+ school should have A+ professors and A+ books in theirs A+ libraries for Z- students.
09:21:27 <DBAlex> > show 25
09:21:28 <lambdabot>   "25"
09:21:31 <lilac> ImInYourMonad: you're still missing the return. just use (...) >>= \s -> return (playlist s !!  position s)
09:22:31 <pk1> Are numbers considered abstractions ?
09:22:48 <lilac> pk1: i'd say so
09:22:52 <mdmkolbe> What is the meaning of the last arg (of type [Name]) in a DataD?
09:23:09 <pk1> so, what's a concrete primitive ?
09:23:10 <mmorrow> mdmkolbe: deriving (name1, name2, ...)
09:23:17 <mdmkolbe> mmorrow: thx
09:23:22 <lilac> pk1: a cat?
09:23:32 <aluink> mmorrow: ahh, you're saying those who like concrete math, quickly get bored with abstract math. yes, though unless we've got Rain Man, their abilities are quickly limited, yes?
09:23:33 <ImInYourMonad> getSong state = readMVar state >>= join (liftM2 (!!) playlist position) ; where should return be?
09:23:38 <mmorrow> , [d| data A a = A a b | B {one :: b} deriving (Eq,Show) |]
09:23:39 <lunabot>  luna: Not in scope: type variable `b'
09:23:44 <mmorrow> , [d| data A a b = A a b | B {one :: b} deriving (Eq,Show) |]
09:23:44 <lilac> ImInYourMonad: that was kinda a joke
09:23:45 <lunabot>  DataD [] A [a_0,b_1] [NormalC A [(NotStrict,VarT a_0),(NotStrict,VarT b_1...
09:23:58 <lilac> don't mix your monads, kids
09:23:59 <maxote> primitive and metaprimitive as an abstraction of a primitive (remember to Bertrand Russell)
09:24:04 <mmorrow> , [d| data (Num a) => A a b = A a b deriving (Eq,Show) |]
09:24:06 <lunabot>  DataD [AppT (ConT Num) (VarT a_0)] A [a_0,b_1] [NormalC A [(NotStrict,Var...
09:24:24 <mmorrow> , [d| data (Num a) => A b = forall a. A a b deriving (Eq,Show) |]
09:24:25 <lunabot>  luna: Not in scope: type variable `a'
09:24:26 <pk1> lilac, a cat is an abstraction over
09:24:31 <mmorrow> , [d| data (Num a) => A a = forall b. A a b deriving (Eq,Show) |]
09:24:32 <lunabot>  luna: Can't make a derived instance of `GHC.Classes.Eq (A a)'
09:24:39 <mmorrow> , [d| data (Num a) => A a = forall b. A a b |]
09:24:40 <lunabot>  DataD [AppT (ConT Num) (VarT a_0)] A [a_0] [ForallC [b_1] [] (NormalC A [...
09:24:41 <pk1> lilac, small, four legged feline
09:24:42 <mmorrow> nice
09:24:57 <mmorrow> hmm, ForallC... good to know
09:25:01 <lilac> pk1: not the notion of a cat, but a /specific/ cat :)
09:25:17 <DBAlex> lilac: whats the opposite? from String -> Int ?
09:25:32 <lilac> DBAlex: read
09:25:33 <mauke> read
09:25:36 <DBAlex> ok
09:25:45 <DBAlex> such odd names for that type of operation :P
09:25:45 <aluink> @hoogle read
09:25:45 <lambdabot> Prelude read :: Read a => String -> a
09:25:45 <lambdabot> Text.Read read :: Read a => String -> a
09:25:45 <lambdabot> module Text.Read
09:26:06 <pk1> lilac, yeah, that's pretty concrete
09:26:18 <pk1> we have so much to learn from animals
09:26:36 <lilac> pk1: http://rathergood.com/pigs
09:26:45 <maxote> e.g. an electron has its twin electron at 180 degrees, the electron's primitives have ones metaelectron's metaprimitives as its tangential address is dependent of its twin metaelectron
09:26:55 * mdmkolbe is disapointed by the absense of quasi-quote for individual constructors
09:27:13 <mmorrow> aluink: well, i guess that's true to an extent, but i was really talking about the full range of people, not just mathematicians/whatever
09:27:35 <ImInYourMonad> ok i see
09:27:35 <maxote> the metaprimitives don't exist in the reality
09:27:36 <ImInYourMonad> getSong state = readMVar state >>= \s -> return (playlist s !! position s)
09:27:45 <ImInYourMonad> but your liftM2 version doesnt seem to work
09:28:01 <aluink> mmorrow: ahh, right. ok
09:28:13 <lilac> ImInYourMonad: getSong state = readMVar state >>= return <$> (joinM2 (!!) playlist position)
09:28:18 <lilac> ImInYourMonad: if you want to do it that way
09:28:23 <Cheshire> maxote, "infinite-order polymorphic predicate type system" what?
09:28:33 * lilac wonders if the precedence of >>= and <$> is right for that
09:28:53 <cnwdup> Still, it's nicer without the return.
09:29:01 <maxote> Cheshire, i'm looking for its haskell implementation of this kind of type engine
09:29:16 <lilac> @type \a b c -> a >>= b <$> c
09:29:18 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a1 -> m b) -> (a -> a1) -> m b
09:30:03 <sioraiocht> dcoutts: ping?
09:30:06 <maxote> to reach to the level of coq written in OCaml
09:30:19 <lilac> ImInYourMonad: you'll need parentheses around the (return <$> ...) bit
09:30:37 <lilac> @type \a b c -> a >>= b `fmap` c
09:30:38 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m a -> (a1 -> m b) -> (a -> a1) -> m b
09:30:38 <Cheshire> maxote, can you describe what this means, it is not clear
09:30:40 <ddarius> For the love of Pete, liftM (\s -> playlist s !! position s) (readMVar state) or liftM (\s -> playlist s !! position s) . readMVar or liftM (liftM2 (!!) playlist position) . readMVar (I'd recommend the first)
09:31:06 <Cheshire> maxote, I know what type system and polymorphic means, but  infinite order  and  predicate  ?
09:31:09 <maxote> Cheshire, i want a proof assistant as coq but written in Haskell instead of OCaml
09:31:11 <chessguy> @pl \s -> playlist s !! position s
09:31:11 <lambdabot> liftM2 (!!) playlist position
09:31:48 <lilac> liftM2 (!!) playlist position <$> readMVar state
09:31:50 <dcoutts> sioraiocht: pong
09:32:00 <sioraiocht> dcoutts: quick question about stream fusion equivalence
09:32:13 <Cheshire> maxote do you refere to cumulative universese?
09:32:19 <dcoutts> sioraiocht: aye
09:32:29 <sioraiocht> stream _|_ /= _|_, but unstream . stream = id
09:32:30 <sioraiocht> right?
09:32:34 <dcoutts> sioraiocht: I've been writing proofs about that all week :-)
09:32:41 <lilac> playlist <^(!!)^> position <$> readMVar state
09:33:02 <maxote> Cheshire, yes, Hindley-Milner is less powerful as language recognizer than System-F, System-F (it's 2nd order) less than infinite-order type system.
09:33:09 <chessguy> @hoogle mvar
09:33:09 <lambdabot> module Control.Concurrent.MVar
09:33:09 <lambdabot> Control.Concurrent.MVar data MVar a
09:33:09 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
09:33:30 <dcoutts> sioraiocht: for skipping streams, unstream (stream xs) = xs, but stream (unstream s) ~~ s
09:33:33 <sioraiocht> because stream _|_ = Stream next _|_, and unstream (Stream next _|_) = _|_
09:33:46 <Cheshire> Plastic is implemented in Haskell and it has coercive subtyping... the source code is not available though...
09:33:53 <Cheshire> I would like to have it :p
09:33:59 <sioraiocht> okay
09:34:39 <Cheshire> @go Plastic what is a proof assistant made of
09:34:40 <lambdabot> http://www.dur.ac.uk/CARG/plastic.html
09:34:40 <lambdabot> Title: The PLASTIC Proof Assistant
09:34:51 <dcoutts> sioraiocht: and yes, it's stream (unstream s) ~~ s  for s /= _|_
09:35:00 <ImInYourMonad> and where is <$> ? and what is it? and isnt joinM2 in Control.Monad?
09:35:04 <sioraiocht> dcoutts: thanks =)
09:35:05 <dcoutts> sioraiocht: the ~~ is the equivalence relation on skipping streams
09:36:02 <dcoutts> sioraiocht: the problem with _|_ streams is only because the Stream pair adds an extra lift, so the Stream domain becomes one element bigger than the list domain
09:36:12 <ImInYourMonad> are u pulling mylegs?
09:36:22 <ImInYourMonad> <!""2i9))" -> moand:::SWW
09:36:37 <sioraiocht> dcoutts: ah!
09:37:06 <ddarius> @src (<$>)
09:37:06 <lambdabot> f <$> a = fmap f a
09:37:13 <ddarius> @index (<$>)
09:37:14 <lambdabot> bzzt
09:37:18 <ddarius> @hoogle (<$>)
09:37:18 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:37:39 <ImInYourMonad> and joinM2 ?
09:37:43 <dcoutts> sioraiocht: it's the difference between (f, x) and (unfoldr f x). The pairing adds a lift, an extra _|_ element.
09:37:47 <ddarius> joinM2 was probably a typo
09:37:49 <ImInYourMonad> @hoogle joinM2
09:37:49 <lambdabot> No results found
09:38:03 <sioraiocht> dcoutts: right, that makes sense
09:38:13 <ImInYourMonad> well it is unclear anyway
09:38:26 <Cheshire> maxote but I don't think your terminology is standard .. or at least I don't understadn it -- do you have a ref.?
09:38:35 <sioraiocht> dcoutts: also, is it saf to assume that "next" is always strict in its argument?
09:39:01 <dcoutts> sioraiocht: usually, but technically it's a side condition you'd need to enforce
09:39:07 <sioraiocht> right
09:39:24 <lilac> ImInYourMonad: s/joinM2/liftM2/
09:39:30 <dcoutts> sioraiocht: eg imagine a silly implementation of repeat that uses _|_ as the stream value
09:39:31 <maxote> Cheshire, yes, the best vertex of the lambda-cube
09:39:42 <Cheshire> hehe
09:39:57 <sioraiocht> hrm...
09:40:00 <Cheshire> best :p
09:40:00 <Cheshire> do you know of Pure Type Systems ?
09:40:01 <dcoutts> sioraiocht: repeat's next function doesn't need to inspect the state so one could write it to use _|_ as the state
09:40:07 * lilac lives in the centre of the lambda cube
09:40:12 <sioraiocht> bizarre, heh
09:40:27 <dcoutts> sioraiocht: but we can ban that. I don't think strict steppers are ever needed.
09:40:34 <dcoutts> erm lazy I mean
09:40:54 <sioraiocht> okay
09:41:04 <sioraiocht> yeah, i didn't think so
09:41:29 <dcoutts> sioraiocht: sounds like you've been reading Janis Voigtlander's papers
09:42:06 <sioraiocht> dcoutts: actually, no...
09:42:07 <dcoutts> sioraiocht: I still need to write a section on that in my theory chapter
09:42:20 <ddarius> sioraiocht: Sounds like you should.
09:42:31 <ImInYourMonad> now, has anyone used Data.Graph ? does it use some funky algebraic representation? because I dont get how to use it. at all...
09:42:32 <dcoutts> sioraiocht: so why are you wondering about the strictness of the stepper functions?
09:43:04 <sioraiocht> dcoutts: ralf keeps asking me about stream fusion, he wants to see if he can prove some things about build/foldr fusion
09:43:39 <maxote> the maximum is it i think http://en.wikipedia.org/wiki/Calculus_of_inductive_constructions
09:43:52 <dcoutts> sioraiocht: oh :-) I'm sure I'll discuss that with him in my viva :-)
09:43:56 <Cheshire> maxote, but inductive types are not part oof the cube
09:43:59 <maxote> an extension of CoC (Calculus of Constructions)
09:44:03 <sioraiocht> dcoutts: =p
09:44:22 <Cheshire> maxote, also the inductives types that CIC allows are not _every_ inductive type that you could allow
09:44:31 <sioraiocht> dcoutts: i'm happy, it's actually a lot more interesting than my theorectical dphil topic, which has been boring me to tears
09:44:36 <Cheshire> maxote, for example inductive-recursive definitions give a stronger theory
09:44:47 <dcoutts> sioraiocht: so yes, read the papers on how to repair theorems for free in the presence of seq
09:44:58 <sioraiocht> dcoutts: okay =)
09:46:05 <maxote> i will look for a superset of CoC
09:46:24 <maxote> if it exists, i think.
09:46:32 <Cheshire> maxote what for?
09:46:50 <Cheshire> do you plan to implement this?
09:46:51 <maxote> Cheshire, for automatic parsing
09:47:02 <Cheshire> parsing O_o
09:50:51 <mdmkolbe> Is there a shortcut for "groupBy f (sortBy f xs)"?
09:51:27 <skorpan> @pl groupBy f (sortBy f xs)
09:51:27 <lambdabot> groupBy f (sortBy f xs)
09:51:27 <Heffalump> nafaik
09:51:34 <skorpan> oh, right
09:51:35 <ImInYourMonad> ok all you abstract algebraics! Data.Graph is outabstracting me. How do I insert something into a graph?
09:51:56 <Heffalump> @type groupBy >> sortBy
09:51:57 <lambdabot>     Couldn't match expected type `Bool'
09:51:57 <lambdabot>            against inferred type `Ordering'
09:51:57 <lambdabot>     Probable cause: `sortBy' is applied to too few arguments
09:52:15 <Heffalump> @type groupBy =<< sortBy
09:52:16 <lambdabot>     Couldn't match expected type `[a]'
09:52:16 <lambdabot>            against inferred type `a1 -> a1 -> Ordering'
09:52:16 <lambdabot>     Probable cause: `sortBy' is applied to too many arguments
09:52:43 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1931#a1931 <- getting the vertices or edges reuslts in 0 and [0]. and how to isnert?
09:53:24 <Heffalump> mdmkolbe: of course, you can't even reuse the same f
09:54:49 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1931#a1932 <- and wtf it complains about types when they are the same
09:55:57 * Cale has a look
09:55:57 <cnwdup> ImInYourMonad, they are not. The expected type returns t2, the inferred returns Maybe G.Vertex.
09:56:51 <mdmkolbe> Heffalump: oh, now I see what you mean.  Yeah, I should have said "groupBy (\x y -> f x == f y) $ sortBy f xs"
09:56:59 <ImInYourMonad> t2 and t4 is the same no?
09:57:11 <ImInYourMonad> ah wait i missed
09:57:26 <ImInYourMonad> but dones anyoen see how to use Data.Graph? it seems very counterintuitive tio me
09:58:22 <mdmkolbe> baahh, I should reallylearn to read my types more carefully even that isn't what I want
09:59:59 <Heffalump> mdmkolbe: groupBy (\x y -> f x y == EQ) $ sortBy f xs
10:00:11 <mdmkolbe> Heffalump: yeah, that's what I'm after
10:04:48 <Goonia89> hello guys! ;)
10:05:49 <Cale> hello!
10:07:17 <osfameron> yay!  I have drafted submission for ICFP talk!
10:07:20 <osfameron> (just in time for tomorrow)
10:07:20 <Cale> ImInYourMonad: hmm... what's confusing about Data.Graph?
10:07:46 <osfameron> if anyone has time/tuits/interest to give me any suggestions, it's at http://greenokapi.net/misc/experience-report-monads-at-london-perl-workshop.pdf
10:07:46 <Cheshire> eep
10:10:28 <sioraiocht> osfameron: I'm still writing for ICFP as we speak =p
10:10:50 <osfameron> sioraiocht: well, I've just done the draft, so I can't have more than another 3 or 4 hours to go :-)
10:10:59 <sioraiocht> heh
10:11:10 <osfameron> (I haven't written an academic paper for 10 years... and that was for English Lit)
10:11:36 <osfameron> though it's only an "experience report" but I guess the submissions process will be rigorous for that too...
10:12:13 <Heffalump> sioraiocht: what are you writing about?
10:12:24 <sioraiocht> Heffalump: Data.Text
10:13:24 <osfameron> ooo, they want it in US/Letter format even though the conf is in Scotland
10:13:34 <Heffalump> osfameron: that's the ACM standard
10:13:48 <osfameron> ah
10:13:50 <ImInYourMonad> Cale: i dont get how to: 1. print the graph 2. how to insert into it.
10:14:00 <osfameron> eeeek!  It has to be in 2 columns
10:14:04 <ImInYourMonad> and also, is it good for representing travelling salesman problem?
10:14:17 <sioraiocht> osfameron: there's a LaTeX template
10:14:37 <osfameron> sioraiocht: yeah... I don't get LaTeX, so I'm munging it in OpenOffice.. I do hope that does columns
10:15:03 <sioraiocht> however, that 8.5 x 11 is required is quite annoying, as latex isn't always exactly flexible with changing paper sizes
10:15:23 <sioraiocht> and A4 is an international standard
10:15:28 <osfameron> and a good one
10:15:32 <sioraiocht> agreed
10:15:50 <Heffalump> osfameron: have you looked at past ICFP experience reports?
10:16:45 <osfameron> Heffalump: actually, I couldn't find any, and then gave up searching in favour of writing talk (which is dumb if I'm doing the wrong thing)
10:16:50 <Heffalump> and figured out how it fits in with what the CFP says about them
10:17:01 <osfameron> they seemed to be locked in the confusion of the ACM portal
10:17:08 <Heffalump> yeah, that's a pain
10:17:25 <Heffalump> http://urchin.earth.li/~ganesh/icfp08.pdf is one from last year
10:17:30 <osfameron> ta
10:18:21 <Cale> ImInYourMonad: To be honest Data.Graph isn't my favourite graph representation.
10:18:33 <Cale> ImInYourMonad: Map Vertex (Set Vertex) works *so* much better.
10:18:52 <Cale> ImInYourMonad: That is, have a map from vertices to their sets of neighbours.
10:19:05 <Cale> ImInYourMonad: It's very easy to add new vertices and new arcs/edges.
10:19:32 <Cale> ImInYourMonad: Also, that comes with a Show instance, but you might want to write something a little nicer if you're doing a lot of it.
10:24:36 * dcoutts announces tar 0.3.0.0
10:24:47 * Heffalump thinks more stuff should reach 1.0
10:25:33 <dcoutts> Heffalump: there's probably a lot of things that are just stable and can jump to 1.x versions
10:25:39 <p_l> stuff is 1.0 when it's bug free. Sometimes that extends to {pi}
10:25:39 <Heffalump> yeah
10:25:47 <BONUS> Cale: i didnt do any work with Data.Graph, but with Map Vertex (Set Vertex), how does updating work?
10:25:54 <Heffalump> (I'm not thinking of tar, just a general feeling)
10:25:58 <Heffalump> particularly the stuff that comes with GHC
10:26:06 * lilac thinks we should have a haskell package of polynomial-time algos for np-hard problems :)
10:26:07 <Cale> BONUS: Just insert into the map...
10:26:09 <BONUS> say you want to change one Vertex, do you have to go through all of them to change that Vertex in the neighbours as well?
10:26:19 <dcoutts> Heffalump: I've no idea why some of those started at 0.1 when they were split off
10:26:23 <Cale> BONUS: no
10:26:36 <Cale> BONUS: Well, depends on what you mean by "change" :)
10:26:54 <BONUS> haha yeah i mean like if you want a function Map Vertex (Set Vertex) -> Map Vertex (Set Vertex)
10:27:08 <Cale> And what should it do?
10:27:10 <BONUS> where one vertex changes
10:27:28 <BONUS> if vertices contain values, say you increase the value in one vertex
10:27:32 <Cale> Ah, you mean the name of the vertex changes?
10:27:38 <BONUS> yeah
10:27:40 <Cale> Oh, store labels separately
10:27:45 <Cale> as Map Vertex Label
10:27:47 <BONUS> aha
10:27:57 <BONUS> i see, cool
10:28:02 <NameAlreadyInUse> is there a good laymans explanation of the Curry-Howard isomorphism?
10:28:18 <ddarius> NameAlreadyInUse: "Types are propositions"
10:28:25 <ddarius> "programs are proofs"
10:28:46 <Cheshire> why is there so much noise about curry howard the past few days?
10:28:47 <NameAlreadyInUse> i don't entirely understand
10:29:03 <Igloo> dcoutts: Because I start things at 0.1 by default
10:29:04 <Cheshire> I layman wont understand Curry-Howard
10:29:08 <Cheshire> A layman wont understand Curry-Howard*
10:29:22 <lilac> Cheshire: won't*
10:29:28 <Cheshire> lilac, seriously/
10:29:29 <Cheshire> ?
10:29:34 <lilac> :D
10:29:48 <Cheshire> I should think it's  w'on't
10:29:54 <ddarius> Cheshire: Understanding the idea in broad strokes is simple enough, getting something out of it requires being knowledgeable about both programming and logic.
10:29:56 <NameAlreadyInUse> Cheshire: i'm not sure, i was reading in a blog entry that the Curry-Howard isomorphism guaranteed that programs could (theoretically) be statically checked for all possible errors
10:30:22 <Cheshire> NameAlreadyInUse, can you link to it?
10:30:22 <NameAlreadyInUse> ddarius: yes, i only want the "broat strokes" understanding
10:30:32 <NameAlreadyInUse> Cheshire: hang on
10:30:39 <ddarius> NameAlreadyInUse: What did you not understand about my six word description?
10:30:51 <Heffalump> so, how about Data.Strict?
10:31:07 <Heffalump> I guess I should make a proper library proposal.
10:31:18 <NameAlreadyInUse> Cheshire: it is the first comment, actually http://www.rawblock.com/2007/09/08/one-reason-static-typing-doesnt-suck/
10:31:28 <NameAlreadyInUse> i should have said bugs, not errors
10:31:41 <NameAlreadyInUse> ddarius: i'm not sure - how can a program be a proof?
10:32:15 <lilac> NameAlreadyInUse: curry-howard only really holds in total languages
10:32:19 <ddarius> NameAlreadyInUse: A type correct program proves that its type is inhabited.
10:32:49 <ddarius> lilac: It holds pretty much for every language (in some sense trivially).  It's just that most languages have trivial logics.
10:32:51 <Cale> lilac: It holds in Haskell, it's just the logic is an unusual one.
10:33:11 <NameAlreadyInUse> ddarius: by inhabited, you mean there is a value of that type? =\
10:33:26 <Cheshire> NameAlreadyInUse, in classical logic, to prove these sorts of statements  P => Q \/ ~Q  you can use truth tables?
10:33:28 <lilac> Cale: if you want to look at it that way, fine, but it's not helpful to say that "if everything is true, then..."
10:33:29 <ddarius> NameAlreadyInUse: Yes.  A program obviously is a constructive proof of that.
10:33:44 <Cale> The logic for Haskell is inconsistent, but that's only trivial if you're only interested in whether the theorems are true or not, and not what proofs of them exist.
10:34:46 <Cheshire> NameAlreadyInUse, just wonder if you saw these sorts of logical formula..
10:35:12 <lilac> Cale: NameAlreadyInUse was interested from a point of view of statically checking programs for errors...
10:35:42 <ImInYourMonad> ok but can soemone exaplin to em how to use Data.Graph?
10:36:07 <Cale> lilac: Well, yes, so *one* particular type of error can't be checked this way -- specifically nontermination.
10:36:38 <Cale> lilac: But most others still can, if you're willing to check termination yourself of course. So the logic can still usefully express things.
10:37:00 <Cheshire> Haskell also doesn't let you reflect programs into statements -- so you can't express statements about programs in Haskell
10:37:07 <Cheshire> that means you can't prove things about Haskell anyway ...
10:37:16 <Cheshire> (using it as a logic)
10:37:46 <Cale> ImInYourMonad: Are you comfortable with arrays?
10:38:10 <lilac> Cale: that's unsafisfying. you're saying, my proofs can be checked automatically, if i check bits of them by hand
10:38:19 <Cale> ImInYourMonad: If you have a graph that you're modifying often, Data.Graph's representation is pretty bad.
10:38:37 <ImInYourMonad> @seen boegel
10:38:37 <lambdabot> I saw boegel leaving #haskell and #haskell-blah 7m 13s ago, and .
10:38:45 <Cale> lilac: As long as I'm willing to check one thing about them, I get all the rest for free.
10:38:52 <ImInYourMonad> Cale: yes
10:38:58 <Cale> lilac: Which is okay, because I want general recursion. :)
10:39:12 <lilac> Cale: checking termination is the hardest bit, though...
10:39:13 <Cale> I'm willing to pay that price for it.
10:39:19 <ImInYourMonad> Cale: im not really, mostly I want to do traveling slaesman by ant colony optimization.
10:39:34 <ImInYourMonad> i jsut dont get the representation
10:39:39 <ImInYourMonad> how to traverse it
10:39:46 <Cheshire> Cale, if I wrote program p : A -> B,  then I can't write  proofPWorks : forall x, p x = q x
10:40:00 <lilac> Cale: i'd prefer a tool to check my proofs are well-founded than a tool to check that i've correctly applied modus ponens
10:40:03 <Cale> ImInYourMonad: Data.Graph represents the graph by an array from vertices to lists of vertices.
10:40:27 <Cale> ImInYourMonad: The list of vertices associated with each vertex are its neighbours.
10:40:48 <Cale> Cheshire: hm?
10:41:23 <Cheshire> Cale, so what I mean is that having a uniform notation for proofs and programs is not _useful_ in two senses .. even if we know the programs terminate, we can't prove things about them using Haskell a logic
10:42:19 <ImInYourMonad> Cale: so how would I do: A -> [B,C,D] ; B -> [C, E] ?
10:44:19 <lilac> Cheshire: right, you need dependent ttypes or similar to make use of CH easy
10:44:24 <Cale> array (1,5) [(1,[2,3,4]),(2,[3,5]),(3,[]),(4,[]),(5,[])]
10:44:49 <Cale> ImInYourMonad: ^^ like that
10:45:07 <Cheshire> lilac, so: strong normalization makes Curry-Howard meaningful, and dependent product makes it practical
10:49:20 <dons> ?check \x -> let y = x / 2 in y * 2 == x
10:49:21 <lambdabot>   "OK, passed 500 tests."
10:49:28 <dons> i find that surprising
10:49:34 <dons> ?check \x -> let y = x / 3 in y * 3 == x
10:49:35 <lambdabot>   "Falsifiable, after 35 tests:\n0.7777777777777778\n"
10:50:03 <trofi> :t /
10:50:04 <lambdabot> parse error on input `/'
10:50:07 <trofi> :t (/)
10:50:08 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:50:12 <Cheshire> ?check \x -> let y = x `div` 2 in y+y == x || y+y == x+1
10:50:13 <lambdabot>   "Falsifiable, after 0 tests:\n-3\n"
10:50:23 <Cheshire> ?check \x -> let y = x `div` 2 in x < 0 || y+y == x || y+y == x+1
10:50:24 <lambdabot>   "Falsifiable, after 3 tests:\n1\n"
10:50:35 <skorpan> okay we get it, floats are tricky in haskell...
10:50:45 <Cheshire> division by 2 is tricky...
10:50:48 <trofi> if mantissa is stored in binary form
10:51:08 <Cheshire> ?check \x -> let y = x `div` 2 in x < 0 || y+y == x || y+y+1 == x
10:51:09 <lambdabot>   "OK, passed 500 tests."
10:51:16 <trofi> 0.5 should be stored without loose of precision
10:51:42 <drhodes> :t (~>)
10:51:43 <lambdabot> Not in scope: `~>'
10:51:58 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1936#a1936 <- type system is kickin  my ass again, what do I need to do?
10:52:00 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1936#a1937
10:52:02 <ddarius> dons: Dividing by two is just subtracting one from the exponent and multiplying is adding one.  That will always hold except for the underflow case.
10:54:06 <dcoutts> Igloo: it's a reasonable default except for things that are already at 2.0 :-)
10:54:37 <ImInYourMonad> Cale: and how do I turn that array into a Graph? or how do I travrse it easily?
10:54:49 <broken_ladder> i cannot install haskell on leopard. :(
10:54:50 <broken_ladder> --->  Verifying checksum(s) for gmp
10:54:50 <broken_ladder> Error: Target org.macports.checksum returned: Could not open file: /opt/local/var/macports/distfiles/gmp/gmp-4.2.4.tar.bz2
10:54:50 <broken_ladder> Error: Status 1 encountered during processing.
10:55:02 <Cale> ImInYourMonad: It literally is a Graph, since Data.Graph just uses type synonyms.
10:55:25 * edwardk just used data.graph the other day for the first time. handy that
10:55:25 <pejo> broken_ladder, it can't open /opt/local/var/macports/distfiles/gmp/gmp-4.2.4.tar.bz2.
10:57:05 <ImInYourMonad> Cale: so how do I convert it to that type?
10:57:27 <ddarius> ImInYourMonad: id
10:58:09 <Cale> ImInYourMonad: It already is of type Graph
10:58:23 <Cale> Graph is a synonym for Array Int [Int]
10:59:31 <defun> :t liftA2
10:59:32 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:01:07 <drhodes> ImInYourMonad: expSquaring is recursive, it takes an Int but returns Double, which it will be taking for input, doesn't this present a problem?
11:02:31 <ImInYourMonad> drhodes: yes but i dont get how to fix it
11:02:57 <ImInYourMonad> Cale: yeah i see now but I stilll dnt get how to do Array -> Graph; id :: a -> a
11:03:37 <ddarius> :t id :: Array Int [Int] -> Graph
11:03:38 <Cale> ImInYourMonad: He said id because nothing needs to be done to make it a graph.
11:03:38 <lambdabot> Array Int [Int] -> Graph
11:03:52 <Cale> ImInYourMonad: Array Int [Int] = Graph
11:06:49 <ImInYourMonad> i see i can do the alogirthms on it without having teh type Graph attached to it. but if i wanted the type Graph attached to it, how would I do that?
11:06:52 <drhodes> ImInYourMonad: also squaring is misspelled as sqauring
11:07:45 <defun> :t (.)
11:07:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:07:52 <defun> :t ($)
11:07:53 <lambdabot> forall a b. (a -> b) -> a -> b
11:08:51 <ddarius> ImInYourMonad: Things are the type that they are.  They don't have types "attached" to them.  Graph is a type synonym which means it is just a shorthand way of writing Array Int [Int], it's not much different than a CPP macro.
11:10:37 <ImInYourMonad> expSquaring works now
11:10:47 <ImInYourMonad> and Graph too
11:14:03 <ispiked> I'm trying to understand this error: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1673#a1673
11:14:47 <ispiked> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Asqrt
11:15:09 <ispiked> the thing that confuses me is that I can do something like myLen (1,2) (3,4) with the first one
11:15:12 <ispiked> and it works
11:15:14 <lilac> ispiked: your second type signature says
11:15:24 <ispiked> but wouldn't those be Ints?
11:15:29 <lilac> "give me two pairs of the same type (any type at all) and i'll give you a double"
11:15:33 <ddarius> :t 1
11:15:34 <lambdabot> forall t. (Num t) => t
11:15:36 <ddarius> Not Int
11:15:49 <lilac> ispiked: which it obviously can't do
11:16:04 <lilac> ispiked: because (in part)...
11:16:06 <lilac> @type sqrt
11:16:07 <lambdabot> forall a. (Floating a) => a -> a
11:16:10 <ddarius> :t const (const pi)
11:16:11 <lambdabot> forall a b b1. (Floating a) => b1 -> b -> a
11:16:31 <ispiked> hmm
11:16:44 <lilac> ... sqrt produces the same type you give it (as does (-) and (^) on its LHS)
11:16:45 <defun> :t toEnum
11:16:46 <lambdabot> forall a. (Enum a) => Int -> a
11:16:58 <defun> toEnum 'F'
11:17:08 <lilac> ispiked: so (Double,Double) -> (Double,Double) -> Double would be ok
11:17:12 <trofi> > here
11:17:12 <lambdabot>   Not in scope: `here'
11:17:24 <defun> > toEnum 'F'
11:17:25 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
11:17:43 <lilac> > fromEnum 'F'
11:17:44 <lambdabot>   70
11:17:48 <defun> > toEnum 4
11:17:49 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
11:17:57 <ispiked> lilac: ok, that makes sense. thanks
11:18:07 <defun> fromEnum 'Q'
11:18:10 <ispiked> I misunderstood the type signature for sqrt
11:18:17 <trofi> :t sqrt
11:18:18 <lambdabot> forall a. (Floating a) => a -> a
11:18:22 <defun> > fromEnum 'Q'
11:18:23 <lambdabot>   81
11:19:23 <trofi> @src (++)
11:19:23 <lambdabot> []     ++ ys = ys
11:19:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:19:23 <lambdabot> -- OR
11:19:23 <lambdabot> xs ++ ys = foldr (:) ys xs
11:22:12 <ImInYourMonad> bag Graph sucks
11:22:18 <ImInYourMonad> http://en.wikipedia.org/wiki/Travelling_salesman_problem <- how do I best represent that?
11:22:29 <defun> :t (*>)
11:22:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
11:22:34 <Valodim> haha, "best"
11:22:38 <defun> :t (<*)
11:22:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
11:24:20 <defun> :t (<$)
11:24:21 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:24:22 <defun> :t ($>)
11:24:23 <lambdabot> Not in scope: `$>'
11:26:05 <JohnnyL> forall phreaks (f:: funkypsyhecdelia * -> *) bitchasspun. (funkycolmadena) => yoyo ->bap -> yoyo bap
11:26:31 <roconnor> does not kind-check
11:27:02 <ddarius> does not spell-check either
11:31:30 <ImInYourMonad> Cale
11:31:39 <ImInYourMonad> A.array (1,5) [(1, [(2,5),(3,6)]),                            (2, [(3,9),(4,12)])                           (3, [(4,1),(5,8)])                           (4, [])                           (5, [(1,4),(2,7)])]
11:31:52 <ImInYourMonad> thats basically your but added with costs between
11:31:56 <ImInYourMonad> but it dosnt work
11:32:02 <ImInYourMonad> Couldn't match expected type `t3 -> t4 -> t5 -> (t, [(t1, t2)])'
11:32:02 <ImInYourMonad>            against inferred type `(t6, [(t7, t8)])'
11:32:02 <ImInYourMonad>     In the expression:
11:32:03 <ImInYourMonad> why?
11:32:32 <Cale> uh, that's not a "Graph"
11:32:49 <Cale> er, also, you're missing some commas
11:33:18 <Cale> So you're applying (2, [(3,9),(4,12)]) as if it were a function to (3, [(4,1),(5,8)])
11:33:23 <Cale> and that's what the type errors are about
11:33:58 <ImInYourMonad> it is not a Data.graph but it is stilla  graph no?
11:34:13 <ImInYourMonad> those damn commas
11:34:33 <defun> how does liftA / liftM differ from fmap?
11:35:14 <Valodim> ..not
11:35:15 <edwardk> defun: liftM is a valid definition of fmap for a monad.
11:35:38 <defun> meaning that it is the same?
11:35:48 <edwardk> defun: but you might have a more efficient one available to you, and they didn't want people who implement monads to have to implement a third function, so they never made Functor a superclass of Monad.
11:36:13 <edwardk> defun: well, you can fmap over things that aren't monads or applicatives
11:36:30 <edwardk> defun: but they should be interchangeable where both are defined
11:36:41 <defun> I get it. Thanks.
11:39:37 <dons> shapr: http://www.tuxmachines.org/node/34732
11:40:07 <jfredett> hurrah!
11:41:58 <Nafai> dons: Nice!
11:42:21 <Nafai> dons: I will say #haskell is the only channel I've simultaneous felt not so smart yet wanted to stay
11:42:43 <Nafai> dons: Because there are a ton of smart people here, but none make me feel like I'm not good enough and are always willing to help
11:43:25 <pumpkin_> so I'd like to implement a zygohistomorphic prepromorphisms, any suggestions?
11:43:55 <pumpkin_> I don't need the generalized zygomorphism
11:43:59 <TomMD> pumpkin_: Use haskell
11:44:10 <jfredett> pumpkin_: write code.
11:44:14 <pumpkin_> oh ok
11:44:20 <jfredett> that is the best way to implement things
11:44:22 <jfredett> with code.
11:44:41 <Valodim> @faq can it be done without code as well?
11:44:41 <lambdabot> The answer is: Yes! Haskell can do that.
11:48:12 <shapr> dons: w00!
11:48:37 <shapr> dons: It's hard to believe we're the second largest programming channel on freenode1
11:49:48 <ImInYourMonad> really? bigger than java or c++?
11:50:08 <paper_cc> @users
11:50:08 <lambdabot> Maximum users seen in #haskell: 658, currently: 647 (98.3%), active: 24 (3.7%)
11:50:09 <pumpkin_> shapr: how was the CHUG? sorry I couldn't make it
11:50:19 <mauke> ##c++ is bigger than #haskell
11:50:41 <pumpkin_> we've been up to 699, even though lambdabot is forgetful
11:51:04 <jeffwheeler> 699 was recently; like, this week.
11:51:13 <pumpkin_> couple of weeks ago IIRC
11:51:23 <jeffwheeler> Oh, I thought I saw it recently. I could be wrong.
11:51:32 <jeffwheeler> @uptime
11:51:32 <lambdabot> uptime: 3d 1h 23m 37s, longest uptime: 1m 10d 23h 44m 29s
11:51:39 <jeffwheeler> Eh, who knows . . .
11:52:13 <jeffwheeler> If it can remember the longest uptime, it should be able to remember all else, too. ;)
11:54:51 <DBAlex> Anyone got a nice little File I/O example?
11:55:01 <shapr> pumpkin_: Neither could I, I was sick.
11:55:02 <pumpkin_> readFile "/etc/passwd"
11:55:09 <mauke> interact id
11:55:11 <shapr> DBAlex: Have you seen the unix utilities on the wiki?
11:55:14 <DBAlex> basically I want to read a whole file into a string, or line by line into a [String]
11:55:16 <pumpkin_> shapr: oh no
11:55:19 <DBAlex> shapr: nope
11:55:20 <Nafai> shapr!
11:55:23 <shapr> Nafai!
11:55:29 <Nafai> How's it going dude?
11:55:34 <shapr> pumpkin_: But I heard it went well, they had 16 people, and lots of fun stuff happened.
11:55:41 <pumpkin_> cool :)
11:55:44 <shapr> edwardk was substitute organizer :-)
11:55:54 <DBAlex> shapr: wiki.haskell.org ?
11:56:00 <pumpkin_> any tentative plans on when the next one will be?
11:56:04 * DBAlex looks
11:56:12 <shapr> I heard rumors that Tom Moertel is organizing the Philadelphia branch of the New England Haskellers.
11:56:26 <DBAlex> @hoogle wiki
11:56:26 <lambdabot> No results found
11:56:36 <DBAlex> @hoogle haskell wiki
11:56:36 <lambdabot> No results found
11:56:37 <shapr> DBAlex: getting url
11:56:44 <jfredett> new england excursionary force... :)
11:56:47 <DBAlex> shapr: ok
11:56:51 <pumpkin_> http://haskel.org/haskellwiki
11:56:52 <shapr> DBAlex: http://www.haskell.org/haskellwiki/Simple_Unix_tools
11:56:53 <pumpkin_> bah
11:56:58 <jfredett> D
11:57:00 <DBAlex> shapr: ok
11:57:02 <shapr> tmoertel: So, is that rumor true?
11:57:26 <ImInYourMonad> when doing TSP, should every city be connected to every city?
11:57:43 <jfredett> ImInYourMonad: no.
11:57:56 <shapr> DBAlex: Is that the sort of thing you wanted?
11:58:00 <jfredett> I think, anyway.
11:58:27 <pumpkin_> TSP?
11:58:32 <shapr> DBAlex: If that's not it, perhaps clicking on the "Tutorials" category link at the top of that page will help?
11:58:32 <|jedai|> DBAlex: To read a file line by line you can simply use "ls <- liftM lines (readFile "/etc/passwd")"
11:58:32 <DBAlex> shapr: yes, but this is much better: http://www.zvon.org/other/haskell/Outputprelude/readFile_f.html
11:58:38 <DBAlex> i'm going to try that now :)
11:58:40 <shapr> pumpkin_: Travelling Salesman Problem
11:58:42 <pumpkin_> oh :)
11:58:46 <DBAlex> shapr: ok :) thanks
11:58:50 <jfredett> Yah- you can do TSP on incomplete graphs. You can always 'complete' the graph, though, eg, if there is an edge a->b and b->c, with weights x and y resp. then the 'edge' from a->c has weight x+y
11:58:56 <pumpkin_> I don't like zvon.org
11:58:58 <Choko> ImInYourMonad: you can fix it with giving any nonexisting path the value infinity then it will never be feasible to take such path
11:58:59 <DBAlex> |jedai|: ok thanks
11:59:00 <pumpkin_> it pollutes my search results
11:59:01 <shapr> DBAlex: Ah, ok.. if you have any other questions, feel free to ask.
11:59:26 <DBAlex> shapr: ok :) thanks! what i'm going to try and do is, read a while file, split by newline and then process each line
11:59:34 <jfredett> that assumes a directed graph, but it works just as well for undirected graphs.
11:59:40 <DBAlex> just messing about and getting used to haskell I/O really :)
11:59:49 <shapr> DBAlex: Good idea!
11:59:58 <DBAlex> what I really want to do is build a wxHaskell text editor
12:00:05 <jfredett> Choko: thats another way to do it.
12:00:05 <shapr> Oh neat!
12:00:16 <jfredett> probably easier, codewise.
12:00:38 <tmoertel> shapr: what rumor?
12:00:42 <mdmkolbe> @type everything
12:00:43 <lambdabot> forall r a. (Data a) => (r -> r -> r) -> GenericQ r -> a -> r
12:00:52 <shapr> DBAlex: There are a few text editors built with Haskell, but I think your current approach is best.. get comfortable with Haskell first, once you understand the tradeoffs, then you can check out the existing approaches.
12:00:58 <DBAlex> shapr: yup, I only saw that someone made a command line editor not anything in wxhaskell, so should be fun :)
12:01:13 <shapr> tmoertel: I heard rumors that you were starting the second branch of New England Haskellers in PA?
12:01:14 <mdmkolbe> what term would you use to describe/name the first argument of 'everything'?  e.g. the second argument is the query
12:01:16 <DBAlex> shapr: yes, I'm more interested in practical things first
12:01:38 <jfredett> shapr: soon, soon we will take over the world!
12:01:43 <shapr> jfredett: Yes!
12:01:46 <tmoertel> shapr: I wish that rumor were true!
12:01:47 <shapr> And then we will... party?
12:01:55 <jfredett> tmoertel: then make it true
12:01:55 <drhodes> like it's 1999
12:02:18 <pumpkin_> for great justice
12:02:26 <tmoertel> jfredett: first I must move New England to PA.
12:02:28 <jfredett> shapr: party like it's last [1..]
12:02:40 <shapr> tmoertel: Oh, good point
12:02:53 <mdmkolbe> , src everything
12:02:54 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
12:03:02 <mdmkolbe> ,src everything
12:03:03 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
12:03:04 <jfredett> NE owns PA, it's a subsidiary.
12:03:06 <sjanssen> > last [1 ..] :: Int16
12:03:07 <lambdabot>   32767
12:03:34 <shapr> tmoertel: Have you written any cool code recently?
12:03:49 <mdmkolbe> @source Data.Generics
12:03:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/Generics.hs
12:04:10 <tmoertel> shapr: not much public code, I'm afraid.  I'm working for a startup now, and most of our code is considered secret sauce.
12:04:19 <DBAlex> main = do x <- readFile "basicio.hs"
12:04:19 <DBAlex> 	  putStr x < wow, and people say haskell I/O is difficult... ;)
12:04:22 <shapr> Ah, well.. if you ever get to release any of it...
12:04:23 <ImInYourMonad> hmm I need to learn graph theory. to compute the shortest path from x to y in a graph, then what is the normal approach? a greedy algorithm still needs to know which paths actually lead there right? or do i do at each turn: if can reach on next, then do so, else choose least weight else move backwards?
12:04:33 <LeoD> DBAlex: they do? :P
12:04:35 <DBAlex> once its in a string thats easy ;P
12:04:36 <tmoertel> shapr: but Haskell has been most helpful in many regards.  :-)
12:04:42 <shapr> tmoertel: Good to hear!
12:04:51 <shapr> DBAlex: Yeah, people say oop is difficult too.
12:04:51 <DBAlex> people should stop moaning, I had to write tons of code just to get file I/O in c working :P
12:05:06 <DBAlex> shapr: hehe
12:05:22 <shapr> DBAlex: Well, everybody starts at different points. Perhaps programming is really hard for accountants? I know accounting is really hard for me :-/
12:05:31 <jfredett> ImInYourMonad: look up djikstra's algo.
12:05:33 <mathijs> typeclassopedia references a blogpost by dan piponi called "The Trivial Monad". The blogpost seems to be unavailable. Is there a mirror of it, or an article discussing the same subject?
12:05:48 <DBAlex> shapr: yes, I suppose
12:05:54 <DBAlex> now brb I need to write a string split :)
12:06:04 <jfredett> ImInYourMonad: you need a dynamic approach. break the problem into overlapping subproblems, and then solve each smaller problem.
12:06:10 <mauke> DBAlex: is that a tab in your source code?
12:06:16 <mauke> DBAlex: you might want to stop using them
12:06:17 <pumpkin_> mathijs: http://74.125.47.132/search?q=cache:FsZdYXdhBVQJ:blog.sigfpe.com/2007/04/trivial-monad.html+the+trivial+monad&hl=en&ct=clnk&cd=2&gl=us&client=safari
12:06:23 <pumpkin_> not sure where it went
12:06:25 <DBAlex> mauke: umm ok
12:06:26 <shapr> hoi mathijs!
12:06:35 <mathijs> hoi :)
12:06:39 <shapr> Mathijs is my middle name, it's nice to meet another one!
12:06:52 <mathijs> shapr: also with 1 t?
12:06:56 <shapr> Yup
12:06:59 <DBAlex> mauke: it was from - http://www.zvon.org/other/haskell/Outputprelude/readFile_f.html
12:07:08 <mathijs> pumpkin_: thanks
12:07:15 <mauke> DBAlex: hah, evil
12:07:19 <shapr> mathijs: Exactly the same spelling... you don't have a cousin named Berber do you?
12:07:37 <mathijs> shapr: nope
12:07:46 <shapr> Whew, in that case, it's not your name that I stole :-)
12:08:01 <gwern> dcoutts: man you could've told me that the toplvel build-depends trick wasn't supposde to work!
12:08:09 * shapr hugs gwern
12:08:09 <gwern> or at least added it to cabal check or something...
12:08:27 <dcoutts> gwern: hrmmm
12:08:36 * gwern stiffens up and gazes into the distance above shapr's shoulder
12:08:38 <DBAlex> I find thats a very useful site though :)
12:08:46 <pumpkin_> I don't
12:08:46 <dcoutts> gwern: it works with the old-style .cabal format I think
12:08:50 <shapr> gwern: hah
12:08:52 <DBAlex> they give a lot of examples for each function... :)
12:08:59 <jfredett> hmm, is there a package for accessing environment variables, or will I need to come up with an alternate solution?
12:09:03 <DBAlex> pumpkin_ ?
12:09:11 <dcoutts> gwern: it has to to support old style files, I hope it does not work with new style files.
12:09:19 <jfredett> oh- getEnv seems like what I need
12:09:20 <pumpkin_> I've gone to great lengths to get it out of my google search results :P
12:09:35 <DBAlex> pumpkin_: what exactly is wrong with it?
12:09:37 <gwern> dcoutts: new style?
12:09:45 <dcoutts> gwern: with sections
12:10:00 <gwern> pretty sure it works
12:10:06 <gwern> I used it with xmonad-utils, at least
12:10:24 <ImInYourMonad> jfredett: is the problem Dijkstras algorithm solves in P=NP problem?
12:10:40 <pumpkin_> DBAlex: no indication of API version, no cross-referencing on individual types, and just the fact that haddock output is a lot better
12:10:49 <jfredett> ImInYourMonad: I'm not sure what you mean, Dijkstra's algo solves the shortest path problem, IIRC.
12:10:52 <dcoutts> gwern: that's an old style file
12:11:03 <jfredett> P vs NP is an open, very hard problem.
12:11:08 <DBAlex> ok
12:11:40 <ImInYourMonad> wait i see the diff
12:11:51 <jfredett> ImInYourMonad: The TSP is NP-complete, iirc, meaning that a good (polynomial) solution for it would prove P=NP. Shortest Path /= TSP though
12:12:04 <jfredett> TSP looks for the least _cycle_ through all nodes of a graph
12:12:12 <ImInYourMonad> i see
12:12:23 <PeakerWork> jfredett: Specifically, TSP is NP-complete for finding a solution that is shorter than some constant, IIRC -- otherwise how do you verify the result in P time?
12:12:58 <jfredett> PeakerWork: I have no idea- I don't know the complexity theory business, I just like dicking around with graphs sometimes. :)
12:13:21 <jfredett> PeakerWork: but that sounds about right.
12:13:40 <mdmkolbe> PeakerWork: yes.  and technicalally P and NP only apply to problems of the form "input -> Bool" so finding the sortest path isn't really a P/NP problem
12:13:45 <dcoutts> gwern: hmm, you're right though it still works after converting
12:13:47 <PeakerWork> jfredett: for it to be in NP-complete (I think for it to be in NP too) there needs to be a way to verify the result is correct in P time
12:14:01 <jfredett> PeakerWork: right-
12:14:26 <dcoutts> @seen Saizan_
12:14:26 <lambdabot> Saizan_ is in #xmonad, #ghc, #yi, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard Saizan_ speak 5h 24m 33s ago.
12:14:44 <PeakerWork> mdmkolbe: Whether the path is shortest is an input->Bool  problem though?
12:14:53 <mdmkolbe> PeakerWork: it is easy to make a function that calculates the length of the sortest path from a function that calculates whether there is a path shorter than "x"
12:15:00 <mdmkolbe> PeakerWork: yes
12:15:37 <mdmkolbe> PeakerWork: both asking whether a particular path is shortest and asking whether there exist any paths shorteer than some length are NP-complete (NPC)
12:16:04 <PeakerWork> mdmkolbe: how do you use  anyPathShorterThan   to build  shortestPath?  Binary search the space of possible path lengths?
12:16:10 <pumpkin_> I like how people in here will say input->Bool rather than decision
12:16:36 <dancor> if i'm importing Data.Foldable and Data.List, it makes more sense for me to go with the foldable version for the overlapping functions right?
12:17:03 <dancor> there's no perf penalty if you actually are using lists right?
12:17:28 <sjanssen> dancor: most likely not (but possibly)
12:17:32 <dancor> mm
12:17:58 <mdmkolbe> PeakerWork: I don't remember how.  Using a loop, it is easy to find out what the length of the shortest path is, but finding the actual path escapes me at the moment
12:18:23 <PeakerWork> mdmkolbe: what loop?
12:19:10 <mdmkolbe> PeakerWork: run anyPathShorterThan :: Length -> Graph -> Bool, on length=0,1,2... until you get True
12:20:35 <PeakerWork> mdmkolbe: that has a bad O()
12:20:36 <mdmkolbe> PeakerWork: if you want anyPathShorterThan to take an actual path.  We build a version that takes a length instead of a path by simply add to the graph with a path from start to end of exactly the length we are interested in.
12:20:47 <mdmkolbe> PeakerWork: but the O() is still polynomial
12:21:27 <mdmkolbe> PeakerWork: when thinking about P and NP, polynomial factors don't matter (they get swamped by the NP factor)
12:21:45 <PeakerWork> mdmkolbe: yeah, but w.r.t the actual values of the lengths in the graph, which may be arbitrarily large.. the solution isn't supposed to involved any O() of the length sizes themselves. Not to mention they may not even be whole
12:22:37 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1945#a1945 <- gtk2hs wizards out there, what windows do I use to have several buttons in one? seems fairly retarded that I can only have one...and how do I decide the layout?
12:22:55 <mdmkolbe> PeakerWork: path lengths are boudned by the size of the graph (assuming constant cost per edge)
12:23:13 <ImInYourMonad> mdmkolbe: but "both asking whether a particular path is shortest ", isnt that wahat disjktra does?
12:23:25 <PeakerWork> mdmkolbe: its actually not polynomial because the size of the input is just the graph, with the lengths, but your complexity is exponential to the size of the graph, because every digit I add to represent the length exponentially grows the time it takes your algorithm
12:23:42 <PeakerWork> mdmkolbe: ah, no constant cost per edge though
12:23:59 <mdmkolbe> ImInYourMonad: true, but TSP actually asks whether there is a shortest path that visits *every* node
12:24:07 <PeakerWork> ImInYourMonad: Dijkstra does that between 2 edges. TSP is for a whole cycle on the whole graph
12:24:40 <jfredett> mdmkolbe: TSP asks for a cycle, not a path, I thought
12:24:48 <mdmkolbe> PeakerWork: even with non-constant edge cost, I'm sure you can play some other games to get a good bound
12:25:18 <dcoutts> ImInYourMonad: see the gtk2hs tutorial on layout. A window is a single-child container. You're supposed to use layout container widgets.
12:25:39 <jfredett> theres an empircal estimate for the length of the shortest cycle... I think I have the paper hanging around...
12:25:50 <dcoutts> ImInYourMonad: http://home.telfort.nl/sp969709/gtk2hs/index.html
12:26:40 <jfredett> it's on jstor for sure... Stein, I think is the author...
12:26:46 <jfredett> paper was about bus routing
12:26:59 <DaBonBon> is there any way to download RWC for leisurely offline reading?
12:27:24 <wjt> Real World C? *fear
12:27:36 <jfredett> DaBonBon: Real World Haskell? I think it comes as an Ebook from Orielly.
12:28:15 <loop> you can download rwh via snail mail for offline reading .. :)
12:28:16 <ImInYourMonad> dcoutts: ah thats perfect
12:28:25 <DBAlex> hmm
12:28:31 <DBAlex> I'm really liking haskell now :)
12:28:34 <jfredett> loop: low speed, hi bandwidth for the win!
12:28:39 <jfredett> DBAlex: it's great, isn't it?
12:28:48 <DBAlex> I'm sure a lot of people who use python would be better of with haskell
12:28:54 <DBAlex> if they tried a bit at first
12:29:35 <DBAlex> jfredett: yeah but the learning curve is steep (sp?)
12:29:46 <m0nkfish> i have a friend who is an extremely talented programmer
12:30:00 <m0nkfish> he believes that you only need to know three languages: haskell, python and c
12:30:01 <DBAlex> I do like how you have to define a case for everything tho, as has been said before, no side effects
12:30:11 <DBAlex> its just like really advanced error checking :)
12:30:13 <jfredett> steep looks right, and yah- but it's a bit like lisp, you just have to break your brain a bit
12:30:17 <Cheshire> m0nkfish: sounds very stupid and closed minded to me
12:30:25 <jfredett> and then it's much easier.
12:30:28 <jfredett> Cheshire: agreed
12:30:29 <DaBonBon> jfredett: but that ebook is not free to download right?
12:30:32 <m0nkfish> i don't think he's closed minded
12:30:43 <DBAlex> m0nkfish: thats my current thinking, but don't tell anyone... ;p
12:30:46 <m0nkfish> he has written his own language and obviously did a lot of research in the process
12:30:47 <jfredett> DaBonBon: No, it's 30$ or soemthign
12:30:50 <DaBonBon> i am not sounding selfish here, but if the authors decided to put the content online, why not provide it as a downloadable ebook format?
12:30:52 <jfredett> but it's worth it, methinks
12:30:55 <m0nkfish> i cant think of any argument against it
12:30:55 <DBAlex> (we do Java here... I don't mind Java but you can do OO in python just as well)
12:30:56 <pumpkin_> m0nkfish: what was the point of telling us he's a talented programmer? that really doesn't mean much :)
12:31:02 <jfredett> I'm gonna get it for my kindle, when my kindle gets here
12:31:09 <dancor> m0nkfish: it seems like if you want to do heady math stuff you might want a lang with dependent types
12:31:13 <m0nkfish> i mean that he knows what he's on about
12:31:20 <pumpkin_> m0nkfish: reductio ad amicum
12:31:21 <jfredett> DaBonBon: Well, dons and the gang wrote it as an "open" book
12:31:41 <jfredett> DaBonBon: but certainly we should reward their work by paying a bit for it, right?
12:31:48 <pumpkin_> m0nkfish: if he can define "need", then maybe his sentence makes sense
12:32:14 <jfredett> I like free stuff as much as the next guy, but beggars can't be choosers. :P
12:32:16 <DaBonBon> jfredett: i would happily pay for it, but the problem is that $30 turns out to be very costly when converted to my native currency (indian ruppee)
12:32:21 <dancor> i guess i agree with that trifecta and that's the kind of fourth language i think i might "need" some day ;)
12:32:33 <Cheshire> what's trifecta
12:32:35 <DBAlex> DaBonBon: just print it with a pdf printer?
12:32:42 <DBAlex> if your that bothered about the cost
12:32:42 <m0nkfish> perhaps if you are doing advanced mathematics
12:32:44 <Cheshire> oh
12:32:52 <jfredett> DaBonBon: I imagine you could download each HTML page from the site.
12:32:53 <DaBonBon> DBAlex: it still wouldn't be as pretty..
12:32:53 <dancor> Cheshire: triple of things placing in some competition
12:33:06 <DBAlex> DaBonBon: if you want the nice version pay for it !
12:33:10 <DaBonBon> well basically i just wanted to find out whether it is available freely as an ebook or not.. guess not :(
12:33:29 <pumpkin_> @where RWH
12:33:29 <lambdabot> is http://www.realworldhaskell.org/blog/
12:33:36 <pumpkin_> DaBonBon: that one?
12:33:45 <jfredett> DaBonBon: only available online as an ebook, not as a downloadable thing
12:33:56 <DaBonBon> pumpkin_: real world haskell, yes
12:34:00 <jfredett> maybe someday in the future it will be released.
12:34:05 <pumpkin_> DaBonBon: that's the whole book
12:34:06 <pumpkin_> on that site
12:34:09 <pumpkin_> free
12:34:18 <DBAlex> maybe you can download it with some HTML archiver?
12:34:20 <jfredett> pumpkin_: he wants to be able to download it, though
12:34:23 <pumpkin_> ah
12:34:27 <pumpkin_> save the HTML :P
12:34:30 <jfredett> DBAlex: I imagine so.
12:34:30 <DBAlex> (is there a program that recursively saves HTML files?)
12:34:37 <jfredett> DBAlex: write one
12:34:37 <czShadoW> wget -R
12:34:38 <DaBonBon> that's what i am thinking of doing now
12:34:39 <jfredett> in Haskell!
12:34:42 <DBAlex> maybe write a python script?
12:34:49 <jfredett> DBAlex: Haskell!
12:34:50 <dons> there are very nice .pdf's and friends (but you have to buy them from oreilly)
12:34:52 <aleg> wget will do it
12:34:58 <DBAlex> czShadoW: yes ... that probably works
12:35:03 <czShadoW> s/R/r/
12:35:22 <DBAlex> I remember downloading a whole directory of MP3's doing that (they block bittorrent etc but not HTTP ... ;) )
12:35:45 <DBAlex> to be honest i'd always prefer a book to pdf anyways
12:35:46 <pumpkin_> m0nkfish: I'm not doing advanced mathematics and I still don't agree with that :) I definitely think the ones he listed should be part of a repertoire, but not "all you need". I'm probably not a talented programmer though ;)
12:35:53 <DBAlex> pdf isn't something you want to sit down and read is it
12:36:28 <DBAlex> plus £20 for a book isn't much
12:36:33 <DBAlex> think about how much you learn ...
12:36:43 <DBAlex> imagine how much I have to pay for university fees ...
12:36:44 <DBAlex> :P
12:37:00 <jfredett> DBAlex: hehe, college is expensive. :(
12:37:14 <DaBonBon> ya well i guess i'll get a hard copy of the book
12:37:19 * pumpkin_ haz big debt
12:37:31 <DBAlex> jfredett: very :(
12:37:33 <jfredett> DaBonBon: ... but the ebook is _cheaper_... certainly if cost is an issue...
12:38:52 <DaBonBon> well, the irony is that the print version is avaialable as an indian reprint, so for me it'd be cheaper than to buy the ebook from oreilly ;)
12:38:52 <filcab42> hi all
12:39:05 <jfredett> DaBonBon: That sucks...
12:39:48 <jfredett> filcab42: hiya
12:39:56 <drhodes> wget can recursively fetch web pages.
12:40:24 <erikc> yea, RWH was $30 canadian from amazon.ca, and ~$55 canadian online through oreilly
12:40:49 <filcab42> I'm having some problems compiling ghc (HEAD): package Cabal-1.7.0 is broken due to missing package array-0.2.0.1
12:40:50 <filcab42> any clues?
12:41:06 <dons> mm. i just grabbed the nightly build
12:41:33 <filcab42> but I wanted to try and tinker with it :-P
12:41:35 <pumpkin_> compiling GHC is a nightmare if you're doing something beyond the official configurations and are not a GHC guru
12:41:49 <pumpkin_> :)
12:41:58 <centrinia> Real World Haskell needs good illustrations like the ones in Teach You a Haskell Good Great. :)
12:42:04 <ImInYourMonad> assimilated methods of = methods of the same type?
12:42:06 <pumpkin_> lol
12:42:16 <ImInYourMonad> Learn you a haskell for great good
12:42:18 <jfredett> centrinia: it needs the haskell logo!
12:42:24 <centrinia> Sorry,.
12:42:34 <filcab42> the last time I tried in macosx... I didn't have a problem. (On windows it's another story, unfortunately...). But now I have this missing array-0.2.0.1 (but the latest available is array-0.2.0.0, in Cabal)
12:42:38 <jfredett> centrinia: *points at the logo of the haskell subreddit*
12:42:42 <dcoutts> pumpkin_, filcab42: there's pretty good docs on how to get and build ghc on the ghc dev wiki
12:43:00 <filcab42> ah, yes
12:43:02 <dcoutts> filcab42: array is one of the packages that get built with ghc
12:43:04 <centrinia> Building ghc takes a while. :(
12:43:17 <filcab42> I was looking into it for the windows problem... but not for this (this happened today)
12:43:24 <filcab42> takes a "BIG" while :P
12:43:49 <pumpkin_> dcoutts: yeah, but I've had a lot of trouble doing unsupported things :) (I know that they're unsupported though, so am not complaining about lack of support, just that it's dauntingly complex)
12:44:14 <pumpkin_> the docs have been helpful though
12:44:22 <roconnor> > let x = 2^^(-1023) in (x/2)*2 == x
12:44:23 <lambdabot>   True
12:44:31 <roconnor> > let x = 2^^(-1024) in (x/2)*2 == x
12:44:32 <lambdabot>   True
12:44:35 <roconnor> :/
12:44:52 <filcab42> dcoutts: yes, but something is going on and it's not getting built (or found, after building)
12:45:07 <centrinia> @type 2^^(-1024)
12:45:08 <lambdabot> forall t. (Fractional t) => t
12:45:23 <dcoutts> filcab42: when you did ./darcs-all pull -a, did you make distclean afterwards?
12:45:32 <filcab42> hmmm
12:45:41 <filcab42> I'll try that before restarting from scrath
12:45:44 <filcab42> I'll post back
12:45:49 <pumpkin_> distclean = starting from scratch :P
12:45:51 <pumpkin_> pretty much
12:46:03 <filcab42> normally ;-)
12:46:37 <centrinia> Starting from scratch means rm -rf the source tree, untaring the source package, and building from the source tree.
12:46:40 <filcab42> there are times when it doesn't clean thorougly, unfortunately
12:46:51 <filcab42> centrinia: indeed
12:48:09 <dcoutts> g'evening waern
12:48:13 <ImInYourMonad> hmm gtk2hs must have been an enormous amount of work, who does all the heavy stuff for Haskell? is Haskell financed at all by industry? I see a lot of packages on Hackage are by students and enthusiasts probably but some stuff like gtk2hs really must take a lot of work and thinking through.
12:48:39 <Zao> ImInYourMonad: Never underestimate the power of too much free time.
12:48:50 <ImInYourMonad> also, if one day you want to work with developing haskell(ghc i guess?) , what would you do? isit basically programming langauge research in academia? dons?
12:49:10 <ImInYourMonad> is neil mitchell here sometimes?
12:49:30 <arjanb> yes as ndm
12:49:49 <jfredett> Haskell is used a bit in industry, Galois is the typical example, but most of the packages are by enthusiasts/students
12:49:57 <jfredett> Haskell has some SoC projects, too
12:50:10 <dcoutts> ImInYourMonad: yes, gtk2hs took years. :-)
12:50:11 <DBAlex> yay!
12:50:12 <DBAlex> *Main> gettok "Elephantitus" 'a'
12:50:12 <DBAlex> ["Eleph","ntitus"]
12:50:16 <DBAlex> :)
12:50:16 <pumpkin_> jfredett: I think dons said a tenth of the packages were by galois employees :P
12:50:21 <dcoutts> ImInYourMonad: neil is not about much recently, since getting a job
12:50:26 <jfredett> pumpkin_: wow.
12:50:40 <pumpkin_> jfredett: can't remember though, I think I saw it on his twitter
12:50:42 <filcab42> btw... are most Haskell libraries like "most" Lisp libraries (yes, I'm generalizing a bit too much)? In the sense that most are "only 80% solutions"?
12:50:59 <filcab42> or do you feel that most libraries are very well done and complete?
12:51:00 <dons> jfredett: galois engineers wrote 10% of hackage :)
12:51:05 <dcoutts> ImInYourMonad: quite a few Haskellers use it professionally, we've even got a dedicated consultancy company :-)
12:51:06 <pumpkin_> there you go
12:51:11 <DBAlex> btw does the creator of xmonad ever chat here?
12:51:18 <pumpkin_> DBAlex: there's #xmonad
12:51:20 <DBAlex> thats a cool example of a real world haskell program :)
12:51:24 <dons> DBAlex: nope, those guys hang out in #xmonad
12:51:24 <pumpkin_> but most of them hang out in here too I think
12:51:35 <DBAlex> pumpkin_: ah ok, dons_: ok :)
12:51:37 <jfredett> dons: did they write it _while_ working there? or are they working there now, after having contributed? :)
12:51:52 <dons> mixture. mostly while at galois, i think
12:51:56 <DBAlex> i'm building up my own string library :) (I did the same for C)
12:52:07 <jfredett> if it's an implication - 1 out of 10 hackage contributers get hired to galois, I'm gonna start contributing... :)
12:52:10 <DBAlex> i'm going to try string strip now
12:52:15 <dons> jfredett: hehe
12:52:16 <DBAlex> that should be simple
12:52:16 <pejo> jfredett, Galois is old compared to Hackage.
12:52:33 <pumpkin_> jfredett: you on twitter btw? you should add yourself to the twitter wiki page if you are
12:52:36 <filcab42> ImInYourMonad: a friend of mine even got permission to use Haskell for a job he's doing... Even after telling his employers it would be hard to continue after he leaves: "We'll just get them to learn Haskell... It's just like any other language"
12:52:46 <dons> writing packages that galois ends up using is a good way to get an interview, i'd reckon
12:52:50 <jfredett> pumpkin_: I am, but i was not aware of the twitter wiki page
12:52:56 <jfredett> I don't talk about haskell much
12:52:57 <pumpkin_> http://haskell.org/haskellwiki/Twitter
12:52:58 <pumpkin_> ah
12:53:07 <jfredett> I mostly make lame jokes and complain about things... :)
12:53:26 <DBAlex> also Notepad++ has brilliant syntax highlighting for haskell :) what does everyone here use for haskell development?
12:53:45 <jfredett> DBAlex: vim + screen + ssh
12:54:07 <DBAlex> jfredett: hehe, wish screen worked on the uni servers, it breaks with curses apps :(
12:54:32 <DBAlex> vim does good haskell syntax highlighting tho
12:54:33 <gueux> hi :-)
12:54:38 <jfredett> DBAlex: I ssh to my server at home, run a screen session w/ irssi, some vim, and ghci
12:54:43 <DBAlex> jfredett: have you tried gvim ?
12:54:51 <DBAlex> ok
12:54:53 <jfredett> split the screen window, and use 2 buffers in vim proper
12:55:01 <pejo> DBAlex, export TERM=vt100, your school servers probably disagree about the definition of xterm.
12:55:04 <jfredett> it's a good system, methinks.
12:55:06 <gueux> is there already a function isIncludeIn :: Eq a => [a] -> [a] -> Bool
12:55:08 <DBAlex> jfredett: can you use ghci inside vim?
12:55:12 <gueux> (like isPrefixOf)
12:55:15 * tibbe wants a better name than Iteratee for Enumerator style programming. It's unpronouncable
12:55:22 <jfredett> DBAlex: no- I have one screen buffer w/ ghci
12:55:26 <jfredett> and another with vim
12:55:34 <DBAlex> pejo: ok... I think I tried it, they disabled screen but I found it in /opt
12:55:46 <gueux> it is not very hard to code it but I was wondering if such a function was already in a library
12:55:47 <jfredett> and I split the screen session, so I have a buffer holding vim and another holding ghci on the same screen.
12:55:51 <forkingYourIO> emacs like duh
12:55:52 <drhodes> DBAlex: emacs is another great editor for haskell.
12:56:04 <DBAlex> drhodes: ok
12:56:05 <jfredett>  ^a^S ftw.
12:56:20 <DBAlex> drhodes: I saw some guy give a lecture here with ghci and emacs on top
12:56:25 <DBAlex> I thought it was screen at first
12:56:30 <DBAlex> but I think it was just emacs ...
12:56:48 <forkingYourIO> also, if one day you want to work with developing haskell(ghc i guess?) , what would you do? isit basically programming langauge research in academia? dons?
12:56:50 <drhodes> there's an autocomplete add on that looks very slick
12:56:56 <centrinia> Is yi a good editor?
12:57:02 <forkingYourIO> go to cambridge or oxford?
12:57:13 <jfredett> forkingYourIO: I imagine it's as easy as downloading ghc (via darcs or whatever)
12:57:19 <jfredett> and hacking away.
12:57:21 <forkingYourIO> yes, can you run a repl in Yi? can Yi add types to your program?
12:57:26 <jfredett> take on a ticket or something
12:57:37 <jfredett> centrinia: it's a little young for my tastes, but it's very neat
12:57:38 <pumpkin_> there are some fairly low-hanging tickets on the GHC trac
12:58:03 <jfredett> the issue is that there is no good "get up to speed on hacking yi" document floating around
12:58:12 <DBAlex> centrinia: thats the editor I looked at... looks nice
12:58:17 <jfredett> so the only way to do it is to jump in the code and start swimming.
12:58:18 <DBAlex> not sure if anyone uses it though
12:58:25 <DBAlex> I just googled "haskell text editor"
12:58:28 <jfredett> DBAlex: theres a fairly active yi-dev list.
12:58:30 <DBAlex> and its one of the first results :)
12:58:36 <jyp> I do :)
12:58:37 <DBAlex> jfredett: ok
12:58:58 <DBAlex> ok anyway
12:59:00 <DBAlex> back to coding
12:59:01 <DBAlex> brb
12:59:01 <jfredett> dunno if theres a #yi channel, but there might be.
12:59:09 <pumpkin_> jfredett: if nothing else, you can follow people on that list when you're bored and want haskell goodness :P
12:59:17 <DBAlex> jfredett: there is
12:59:18 <jfredett> pumpkin_: hehe, yah.
12:59:24 <jfredett> DBAlex: is it populated?
12:59:26 <DBAlex> jfredett: and its on freenode.. :) (I just checked)
12:59:52 <forkingYourIO> so who are the biggest contributers? SPJ? else? dons?
13:00:19 <forkingYourIO> pumpkin_: link to low-hanging tickets k thnx
13:00:46 <jfredett> forkingYourIO: just google ghc trac
13:00:55 <mathijs> typeclassopedia mentions Applicative types can be composed easily, which isn't the case for Monads. Can someone point me to an example of this?
13:01:04 <forkingYourIO> http://www.haskell.org/ghc/download.html <- where is the actual source code?
13:01:24 <pumpkin_> forkingYourIO: on the GHC trac they explain how to get it
13:01:24 <jfredett> forkingYourIO: poke around, there are instructions on there somewhere for checking out the code.
13:01:39 <pumpkin_> you download a recent tarball of the darcs repo, and then pull the changes since then
13:01:56 <filcab42> forkingYourIO: check the "Developers (Wiki)" link ;-)
13:02:30 <filcab42> pumpkin_: if you're not altering ghc (and just want to check on it and not send patches), you can use only the partial gets with darcs
13:02:33 <solidsnack> forkingYourIO: you actually can't view the GHC source code
13:02:44 <solidsnack> forkingYourIO: it is secret :)
13:02:55 <pumpkin_> filcab42: yeah, but I was :) and he wanted to contributye
13:03:32 <pumpkin_> forkingYourIO: http://hackage.haskell.org/trac/ghc/ticket/2333 looks like it probably wouldn't be too hard :P but I haven't looked, obviously
13:04:06 <pumpkin_> http://hackage.haskell.org/trac/ghc/ticket/2816 maybe?
13:06:41 <filcab42> hmmm
13:06:59 <DBAlex> >:t putStr
13:07:01 <centrinia> Work on this: http://hackage.haskell.org/trac/ghc/ticket/915
13:07:03 <filcab42> what should I look for when debugging a segfault/access violation, in the with-stage2 make target?
13:07:10 <DBAlex> >:type putStr
13:07:42 <DBAlex> > :type putStr
13:07:43 <lambdabot>   <no location info>: parse error on input `:'
13:07:47 <DBAlex> > :t putStr
13:07:47 <lambdabot>   <no location info>: parse error on input `:'
13:08:01 <pumpkin_> centrinia: that'd be nice, and since the lib is already released, it shouldn't be that hard
13:09:11 <DBAlex> hmm
13:09:12 <DBAlex> main = do x <- readFile "basicio.hs"
13:09:12 <DBAlex> 	  gettok x '\n'
13:09:18 <centrinia> This is seriously something I can work on: http://hackage.haskell.org/trac/ghc/ticket/601
13:09:21 <DBAlex> this doesn't work, but gettok takes a string?
13:09:28 <pumpkin_> DBAlex: try lines x
13:09:30 <filcab42> but you're talking about changing the current [] implementation with that one?
13:09:40 <idnar> @hoogle gettok
13:09:40 <lambdabot> No results found
13:09:41 <DBAlex> pumpkin_: I want to use my own function tho
13:10:06 <pumpkin_> what is the type of gettok then
13:10:25 <pumpkin_> gettok in c is stateful even by c standards :P
13:10:30 <DBAlex> pumpkin_: gettok :: String -> Char -> [String]
13:10:48 <pumpkin_> strtok is what I was thinking of I guess :)
13:11:09 <pumpkin_> alright, can you expand on "doesn't work"?
13:11:16 <DBAlex> pumpkin_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1947#a1947
13:11:35 <DBAlex> pumpkin_: one second
13:11:49 <pumpkin_> [x] ++ y === x:y
13:12:15 <DBAlex> pumpkin_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1947#a1948
13:12:19 <filcab42> DBAlex: why the repetitions in droptok and gettok?
13:12:37 <pumpkin_> DBAlex: you're thinking in imperative terms
13:12:45 <pumpkin_> gettok returns something, and you're not doing anything with it
13:12:58 <DBAlex> pumpkin_: True
13:13:03 <filcab42> you're just printing x...
13:13:13 <pumpkin_> try print $ gettok x '\n'
13:13:15 <DBAlex> pumpkin_: Thats why I tried this, lines <- gettok x '\n'
13:13:23 <pumpkin_> no
13:13:36 <DBAlex> [lines] <- gettok x '\n' ?
13:13:43 <centrinia> putStr (gettok x '\n')
13:13:44 <pumpkin_> <- "runs" your monad
13:13:53 <DBAlex> hmm ok
13:13:57 <pumpkin_> in this case gettok does return a monad, but it's the wrong one
13:14:09 <centrinia> Yeah, IO a is not [a] :(
13:14:53 <DBAlex> print $ gettok x '\n' < works
13:15:03 <forkingYourIO> didnt they switch to git from darcs for ghc?
13:15:11 <pumpkin_> forkingYourIO: they will soon
13:15:13 <DBAlex> because $ distributes print over all the [String] elements?
13:15:20 <pumpkin_> DBAlex: no
13:15:28 <DBAlex> the other way round?
13:15:34 <pumpkin_> @src ($)
13:15:35 <lambdabot> f $ x = f x
13:15:44 <centrinia> Yeah, what lambdabot said.
13:15:46 <pumpkin_> the only trick is that $ has a really low precedence
13:15:49 <pumpkin_> it's as low as it gets
13:15:58 <pumpkin_> so it means that gettok x '\n' happens first
13:16:02 <centrinia> Why do we get only 10 levels of precedence?
13:16:04 <pumpkin_> and then finally, print is applied to the result of it
13:16:19 <DBAlex> ok
13:16:19 <pumpkin_> centrinia: precedence should be a CReal :P
13:16:20 <roconnor> centrinia: Coq has 100 levels, and it really isn't much better
13:16:33 <DBAlex> pumpkin_: if not it tries to print an empty list?
13:16:36 <centrinia> pumpkin, Ratio Integer is better.
13:16:47 <pumpkin_> DBAlex: if not what?
13:16:48 <forkingYourIO> solidsnack: are you serious? how can you contribute then?
13:16:58 <pumpkin_> he wasn't serious
13:17:00 <DBAlex> pumpkin_: if you don't add the $
13:17:12 <pumpkin_> DBAlex: then print tries to print gettok
13:17:21 <DBAlex> ok
13:17:36 <pumpkin_> and x '\n' are applied to the IO () result of the print
13:17:45 <pumpkin_> which will generate a nasty type error :)
13:17:45 <DBAlex> see usually I would do print (gettok x '\n')
13:17:46 <centrinia> That would be bad.
13:17:47 <DBAlex> and it works too
13:17:52 <DBAlex> but $ is probably better
13:18:00 <pumpkin_> they're equivaent
13:18:04 <DBAlex> ok
13:18:06 <pumpkin_> people just like to avoid too many parentheses
13:18:10 <DBAlex> I prefer () so i'll use that
13:18:20 <centrinia> @pl \x -> print (gettok x '\n')
13:18:20 <lambdabot> print . flip gettok '\n'
13:18:21 <pumpkin_> fair enough :)
13:18:23 <centrinia> Use that.
13:18:30 <DBAlex> pumpkin_: yes i've noticed that, sometimes they increase readability though
13:18:37 <DBAlex> for me at least, each to their own of course
13:18:40 <pumpkin_> yeah, you shouldn't avoid parens like the plague
13:18:45 <pumpkin_> sometimes they work nicely, others they don't
13:18:54 <centrinia> @pl  readFile "basicio.hs" >>= \x -> print (gettok x '\n')
13:18:54 <lambdabot> print . flip gettok '\n' =<< readFile "basicio.hs"
13:18:57 <DBAlex> yup
13:19:03 <centrinia> main = print . flip gettok '\n' =<< readFile "basicio.hs"
13:19:17 <pumpkin_> DBAlex: in general, I'd flip the argument order for gettok
13:19:22 <forkingYourIO> could writing a better Data.List.sort function be an acceptable contribution?
13:19:31 <pumpkin_> forkingYourIO: how would it be better?
13:19:37 <DBAlex> pumpkin_: um ok
13:19:40 <forkingYourIO> written in red
13:19:46 <centrinia> One should always use a pointfree expression in place of a point expression.
13:19:53 <pumpkin_> lol
13:19:59 <pumpkin_> DBAlex: just because it makes currying easier in the common case
13:20:09 <DBAlex> yes
13:20:24 <centrinia> I'm seriously considering working on replacing GMP for GHC.
13:20:28 <DBAlex> because of course gettok :: String -> Char -> [String] == gettok :: String -> (Char -> [String])
13:20:29 <roconnor> @pl \a b c e d f g = f b c d g a e
13:20:29 <lambdabot> (line 1, column 16):
13:20:29 <lambdabot> unexpected "="
13:20:29 <lambdabot> expecting pattern or "->"
13:20:34 <roconnor> @pl \a b c e d f g -> f b c d g a e
13:20:34 <lambdabot> (((flip . ((flip . (flip .)) .)) .) .) . flip (flip . ((flip . ((flip . (flip .)) .) . flip) .) . flip . flip id)
13:20:38 <DBAlex> returns a function
13:20:44 <pumpkin_> centrinia: with something with a better license?
13:20:52 <pumpkin_> centrinia: rewriting GMP sounds like a pain :)
13:21:08 <DBAlex> pumpkin_: ok thanks for the help and explanation, i'll code some more :)
13:21:11 <centrinia> I actually like working on large integer and polynomial libraries.
13:21:32 <roconnor> pumpkin_ let's use peano numbers!
13:21:39 <pumpkin_> lol
13:21:46 * centrinia will secretly replace Integer with Z_2[x] :)
13:22:58 <pumpkin_> DBAlex: interesting example btw
13:23:17 <DBAlex> pumpkin_: why? :P
13:23:23 <DBAlex> its just simple IO stuff
13:23:31 <pumpkin_> I think it's spelled Elephantiasis though
13:23:47 <DBAlex> lol
13:24:09 <DBAlex> how many elephant man's are there ? ;P
13:25:23 <pumpkin_> quite a few, depending on where you go, unfortunately
13:25:45 <DBAlex> ok
13:25:45 <centrinia> @pl \str token -> case (str,token) of { ([],_) -> []; otherwise -> [droptok str token] ++ gettok (drop (length (droptok str token)+1) str) token }
13:25:45 <lambdabot> (line 1, column 35):
13:25:45 <lambdabot> unexpected "{"
13:25:45 <lambdabot> expecting variable, "(", operator or end of input
13:26:08 <centrinia> @pl \str token -> case (str,token) of ([],_) -> []; otherwise -> [droptok str token] ++ gettok (drop (length (droptok str token)+1) str) token
13:26:08 <lambdabot> (line 1, column 38):
13:26:08 <lambdabot> unexpected ","
13:26:08 <lambdabot> expecting variable, "(", operator or ")"
13:27:00 <ufear> hi guys, anyone have an example of a keith-number generator in haskell?
13:27:18 <roconnor> @oesis keith
13:27:18 <lambdabot>  Repfigit (REPetitive FIbonacci-like diGIT) numbers (or Keith numbers).
13:27:18 <lambdabot>  [14,19,28,47,61,75,197,742,1104,1537,2208,2580,3684,4788,7385,7647,7909,3133...
13:28:36 <ufear> so how do I find the function that creates that list? :P
13:29:12 <roconnor> you will probably want something a little better than accessing the internet to download the sequence. :P
13:29:29 <roconnor> But I don't know how that list is generated
13:29:31 <ufear> yes :P
13:29:45 <ufear> well, I know the algorhytm
13:30:02 <ufear> more like I need a headstart on where to start with my haskell :P
13:30:20 <roconnor> oh
13:30:23 <roconnor> what is the algorithm?
13:30:32 <DBAlex> lstrip :: String -> String
13:30:33 <DBAlex> lstrip [] = []
13:30:33 <DBAlex> lstrip (x:xs) = if (x == ' ' || x == '\t') then
13:30:33 <DBAlex> 				lstrip xs else (x:xs)
13:30:35 <DBAlex> well that was easy :)
13:31:03 <roconnor> DBAlex: filter (`elem` " \t")
13:31:19 <jeffwheeler> > let lstrip = dropWhile (\x -> x == ' ' || x == '\t') in lstrip "  abc"
13:31:20 <lambdabot>   "abc"
13:31:35 <roconnor> oppos
13:31:38 <roconnor> blah
13:31:38 <DBAlex> ok
13:31:45 <ufear> ie, for the number 123 you say it consits out of 1, 2 and 3, and say length of the number is 3. Then the first elements of the list are 1,2,3 and each next element is found by adding up the last 3 numbers
13:31:51 <roconnor> > filter (`nottElem` " \t") "  a bc"
13:31:52 <lambdabot>   Not in scope: `nottElem'
13:31:54 <ufear> and if that lists contains the number it is made up from
13:31:55 <roconnor> > filter (`notElem` " \t") "  a bc"
13:31:56 <lambdabot>   "abc"
13:31:58 <ufear> then it is a keithnumber :P
13:32:06 <ufear> oh, and should be > 9 too
13:32:10 <roconnor> DBAlex: sorry, `notElem`  .. duh :P
13:32:31 <centrinia> > let sn' as = sum as:as; digits_of n = until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]) keith_sn = sn' . digits_of in take 10 (keith_sn 197)
13:32:32 <lambdabot>   <no location info>: parse error on input `='
13:32:38 <centrinia> > let sn' as = sum as:as; digits_of n = until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn = sn' . digits_of in take 10 (keith_sn 197)
13:32:39 <lambdabot>   Couldn't match expected type `[a]'
13:32:42 <centrinia> Hmm.
13:32:47 <forkingYourIO> could there be an official Vector and Matrix library for GHC or the representation of a Maatrix can be done in so many ways and it depends on the problem that it doesn't make any sense?
13:32:50 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn = sn' . digits_of in take 10 (keith_sn 197)
13:32:51 <lambdabot>   [17,1,9,7]
13:32:59 <centrinia> Cool. :)
13:33:08 <DBAlex> roconnor: ok
13:33:09 <pumpkin_> mmm my ARM disassembler is coming along nicely
13:33:11 <centrinia> > let sn' as = sn' (sum as:as); digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn = sn' . digits_of in take 10 (keith_sn 197)
13:33:12 <bolrod> let lstrip xs  = [x | x<-xs, x/=' ', x/='\t'] in lstrip " ok.. haha"
13:33:15 <bolrod> > let lstrip xs  = [x | x<-xs, x/=' ', x/='\t'] in lstrip " ok.. haha"
13:33:24 <bolrod> hm
13:33:36 <lambdabot>   thread killed
13:33:36 <lambdabot>   thread killed
13:33:42 <centrinia> Uh, why doesn't my function terminate? :(
13:33:50 <bolrod> why did you kill my thread!
13:33:51 <bolrod> :P
13:34:00 <DBAlex> hmm <interactive>:1:8:
13:34:01 <DBAlex>     lexical error in string/character literal at character '\t'
13:34:18 <pumpkin_> centrinia: cuz u fail, sry
13:34:18 <roconnor> DBAlex: show me the code
13:34:28 <DBAlex> lstrip [] = []
13:34:28 <DBAlex> lstrip (x:xs) = if (x == ' ' || x == '\t') then
13:34:28 <DBAlex> 				lstrip xs else (x:xs)
13:34:37 <bolrod> > let lstrip xs  = [x | x<-xs, x/=' ', x/='\t'] in lstrip " ok.. haha        o;"
13:34:38 <yitz> centrinia: sn' looks pretty bottommy to me
13:34:39 <lambdabot>   "ok..hahao;"
13:34:44 <roconnor> > map readDigit (show 123)
13:34:44 <lambdabot>   Not in scope: `readDigit'
13:34:54 <jeffwheeler> Isn't he trying to strip all spaces from the left, not tabs from the middle?
13:34:58 <roconnor> > map digitToInt (show 123)
13:34:59 <lambdabot>   [1,2,3]
13:35:12 <DBAlex> jeffwheeler: yes
13:35:14 <roconnor> ufear: ^^ will help get you started I think
13:35:40 <roconnor> DBAlex: oh oops
13:35:43 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn = fix sn' . digits_of in take 10 (keith_sn 197)
13:35:44 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[a]'
13:35:58 <DBAlex> roconnor: can you see any errors in my code?
13:36:13 <roconnor> DBAlex: my mistake, you want dropWhile not filter
13:36:23 <bolrod> > let lstrip xs = dropWhile ( == ' ' || == '\t') xs in lstrip "     Yez! this way?"
13:36:24 <lambdabot>   <no location info>: parse error on input `=='
13:36:26 <DBAlex> roconnor: yes but why the error in my code ? :(
13:36:26 <forkingYourIO> how big is ghc?
13:36:28 <roconnor> DBAlex: dropWhile (`elem` " \t")
13:36:34 <bolrod> > let lstrip xs = dropWhile ( (==) ' ' || (==) '\t') xs in lstrip "     Yez! this way?"
13:36:35 <lambdabot>   Couldn't match expected type `Bool'
13:36:36 <yitz> > map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10) $ 123
13:36:37 <lambdabot>   [3,2,1]
13:36:38 <jeffwheeler> DBAlex: that layout is very weird; move 'then' to the next line and then move the else to the next line and line it up with the 'then'
13:36:40 <pumpkin_> forkingYourIO: big how?
13:36:55 <forkingYourIO> MB
13:36:56 <roconnor> DBAlex: I didn't see your code :(
13:37:00 <DBAlex> jeffwheeler: ok
13:37:06 <DBAlex> oh
13:37:09 <DBAlex> roconnor:
13:37:10 <DBAlex> lstrip :: String -> String
13:37:10 <DBAlex> lstrip [] = []
13:37:10 <DBAlex> lstrip (x:xs) = if (x == ' ' || x == '\t') then
13:37:10 <DBAlex> 				lstrip xs else (x:xs)
13:37:12 <yitz> forkingYourIO: make sure to keep your back straight when lifting it
13:37:24 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn = map head . iterate sn' . digits_of in take 10 (keith_sn 197)
13:37:25 <lambdabot>   [1,17,34,68,136,272,544,1088,2176,4352]
13:37:50 <roconnor> DBAlex: looks fine, modulo indentation
13:38:04 <ufear> almost :P
13:38:04 <DBAlex> roconnor: but I get <interactive>:1:8:
13:38:04 <DBAlex>     lexical error in string/character literal at character '\t'
13:38:10 <roconnor> > '\t'
13:38:12 <lambdabot>   '\t'
13:38:27 <yitz> > map isSpace " \tabc"
13:38:28 <lambdabot>   [True,True,False,False,False]
13:38:46 <bolrod> > dropWhile isSpace "    ok ic"
13:38:47 <lambdabot>   "ok ic"
13:38:59 <roconnor> DBAlex: I see no error with it :(
13:39:05 <DBAlex> same
13:39:06 <DBAlex> :(
13:39:07 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = map head . iterate (take n sn') . digits_of $ n in take 10 (keith_sn 197)
13:39:08 <lambdabot>   Couldn't match expected type `[a]'
13:39:16 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = map head . iterate (take n . sn') . digits_of $ n in take 10 (keith_sn 197)
13:39:17 <lambdabot>   [1,17,34,68,136,272,544,1088,2176,4352]
13:39:20 <centrinia> Damn. :(
13:39:46 <ufear> close close :P
13:39:55 <burp> how can I add an inline signature for an lambda argument? for example this is in my exception handling: (const $ return Nothing)
13:40:20 <burp>  Ambiguous type variable `b' in the constraint: `Exception b' arising from a use of `catch'
13:40:33 <pumpkin_> hmm, I'm trying to figure out if a bunch of mask/value pairs unioned together form another mask/value pair
13:40:36 <burp> \ e :: SomeException -> like this?
13:40:45 <roconnor> (const $ (return Nothing:: MyMonad (Maybe MyType)))
13:41:04 <yitz> roconnor: then forget the $
13:41:08 <roconnor> DBAlex: there must be some other error somewhere
13:41:19 <roconnor> yitz: right
13:41:27 <pumpkin_> mmorrow: around?
13:41:40 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits of n in map head . iterate (take (length digits) . sn') $ digits in take 10 (keith_sn 197)
13:41:41 <lambdabot>   <no location info>: parse error on input `of'
13:41:49 <roconnor> burp: oh, you need to label the exception
13:41:50 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits_of n in map head . iterate (take (length digits) . sn') $ digits in take 10 (keith_sn 197)
13:41:51 <lambdabot>   [1,17,27,45,89,161,295,545,1001,1841]
13:41:59 <burp> roconnor: yes, how?
13:42:13 <roconnor> ((const $ return Nothing) :: MyException -> MyMonad (Maybe MyType))
13:42:19 <roconnor> is how you do it in Haskell 98
13:42:22 <burp> ok
13:42:35 <roconnor> burp: there are a couple of other hacks that would work
13:42:46 <roconnor> with GHC extensions you can do what you wanted to do
13:43:23 <burp> ok :)
13:44:01 <roconnor> burp: if this expression has type variables, then you will need to do one of the hacks
13:44:20 <roconnor> because you essentially cannot use type variables inline
13:45:01 <yitz> burp: it may make your code more readable to define the handler function as a separate item in your where clause, and give it an explicit type signature there.
13:46:04 <centrinia> ufear: Here:
13:46:07 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits_of n in iterate (sn' . take (length digits)) . reverse $ digits in take 10 (keith_sn 197)
13:46:08 <lambdabot>   [[7,9,1],[17,7,9,1],[33,17,7,9],[57,33,17,7],[107,57,33,17],[197,107,57,33]...
13:46:30 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits_of n in map head . iterate (sn' . take (length digits)) . reverse $ digits in take 10 (keith_sn 197)
13:46:31 <lambdabot>   [7,17,33,57,107,197,361,665,1223,2249]
13:46:38 <centrinia> Make use of that.
13:47:13 <ufear> looks useful, ill fiddle around with it, try to understand it for 100%
13:47:19 <ufear> okay if I ask you if i dont get a part?
13:47:29 <centrinia> Sure.
13:48:17 <burp> catch (return $ Just (read $ drop 8 x :: Int)) (simpleExcHandler Nothing) <- anything possible to get a "Just <exception>" here?
13:48:31 <burp> when x is "abc" for example read raises an exception
13:48:55 <burp> and I get Just Exception bla..
13:49:06 <burp> instead of Nothing
13:49:28 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits_of n in map head . iterate (sn' . take (length digits)) . reverse $ digits; is_keith n = (==n) . head . dropWhile (<n) . keith_sn $ n in filter is_keith [10..]
13:49:41 <burp> Just (read "abc" :: Int)
13:49:43 <centrinia> Sorry for killing another thead. :(
13:49:43 <lambdabot>   thread killed
13:49:57 <centrinia> > let sn' as = sum as:as; digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); keith_sn n = let digits = digits_of n in map head . iterate (sn' . take (length digits)) . reverse $ digits; is_keith n = (==n) . head . dropWhile (<n) . keith_sn $ n in take 10 $ filter is_keith [10..]
13:49:59 <lambdabot>   [14,19,28,47,61,75,197,742,1104,1537]
13:50:03 <burp> yields: Just *** Exception: Prelude.read: no parse
13:50:03 <centrinia> There. :)
13:50:50 <centrinia> Now, if only I can make a pointless recursive expression for the Keith numbers.
13:51:06 <yitz> burp: oh, is *that* why you're using catch? you should use reads instead
13:51:10 <ufear> rofl, you are the king
13:51:21 <ufear> but
13:51:31 <ufear> I wonder, how can one expect me to do this on my first haskell hand-in ever
13:51:34 <ufear> :P
13:51:45 <johnbs> Is there some form of conditional compilation I can use with GHC to use a different implementation of a function for a Windows build?
13:52:08 <yitz> ufear: doing homework on #haskell has its pluses and minuses :)
13:52:20 <centrinia> Okay, sn' just appends the sum of the input to the input and returns it.
13:52:35 <centrinia> > let sn' as = sum as:as in sn' [1,2,3]
13:52:37 <lambdabot>   [6,1,2,3]
13:52:47 <burp> yitz: I will look at it, thanks
13:53:02 <centrinia> digits_of produces a list of the digits of a positive integer.
13:53:22 <gueux> I want to print several lines into a handle but it seems like doing 'io $ hPrintf h "ooo\n"' in a loop takes a lot of time
13:53:27 <centrinia> > let digits_of n = snd $ until ((==0) . fst) (\(a,bs) -> (a`div` 10, (a `mod` 10):bs) ) (n,[]); in digits_of 1231
13:53:29 <lambdabot>   [1,2,3,1]
13:53:48 <gueux> should I do it in another way?
13:53:57 <ufear> yea I figure that much yitz, but ill try to understand it when im done with this other assignment, if I do then thats great
13:54:07 <jeffwheeler> Is that really that much faster than > map digitToInt (show 1231) or whatever?
13:54:10 <ufear> assistance isnt forbidden, as long as you really understand whats happening and why :)
13:54:13 <jeffwheeler> > map digitToInt (show 1231)
13:54:15 <lambdabot>   [1,2,3,1]
13:54:42 <Axman6> > digitToInt 'A'
13:54:44 <lambdabot>   10
13:54:48 <Axman6> > digitToInt 'B'
13:54:50 <lambdabot>   11
13:54:56 <Axman6> > digitToInt 'G'
13:54:58 <lambdabot>   * Exception: Char.digitToInt: not a digit 'G'
13:55:04 <yitz> > let maybeRead x = listToMaybe [y | (y,z) <- reads x, null z] in maybeRead "123" :: Maybe Int
13:55:06 <lambdabot>   Just 123
13:55:09 <roconnor> > isDigit 'G'
13:55:11 <lambdabot>   False
13:55:16 <roconnor> > isDigit 'F'
13:55:18 <lambdabot>   False
13:55:25 <yitz> > let maybeRead x = listToMaybe [y | (y,z) <- reads x, null z] in maybeRead "123" :: Maybe Int -- <= burp
13:55:26 <roconnor> > isHexDigit 'F'
13:55:28 <lambdabot>   Just 123
13:55:28 <lambdabot>   True
13:55:31 <gueux> in fact I do a: 'io $ hPrintf h "ooo\n' and then 'io $ printf "ooo\n"' in the same loop
13:55:35 <yitz> > let maybeRead x = listToMaybe [y | (y,z) <- reads x, null z] in maybeRead "123a" :: Maybe Int -- <= burp
13:55:37 <lambdabot>   Nothing
13:55:40 <DBAlex> wierd I even get the errors on this: Prelude> let lstrip = dropWhile (\x -> x == ' ' || x == '\t') in lstrip "       abc"
13:55:40 <DBAlex> <interactive>:1:64:
13:55:40 <DBAlex>     lexical error in string/character literal at character '\t'
13:55:45 <Axman6> > map digitToInt (['0'..'9']++['a'..'z']++['A'..'Z'])
13:55:46 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,* Exception: Char.digitToInt: not a ...
13:55:56 <Axman6> > map digitToInt (['0'..'9']++['a'..'f']++['A'..'F'])
13:55:58 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,10,11,12,13,14,15]
13:56:03 <gueux> and the first part takes a lot of time to be printed into the handle
13:56:08 <centrinia> keith_sn first computes the digits of the input. Then it produces the infinite list of the iterates of sn' compose (take (length digits_of n)).
13:56:26 <DBAlex> Haskell doesn't like windows' tabs?
13:56:30 <yitz> > digitToInt 'g'
13:56:31 <lambdabot>   * Exception: Char.digitToInt: not a digit 'g'
13:56:44 <Axman6> it's nice that it does hex digits
13:57:01 <DBAlex> anyone?
13:57:19 <burp> yitz: thanks
13:57:30 <centrinia> The iterates of that function takes the previously formed list, truncates it so that the sums are over lists of the same length, appends the sum to the previous iterate, and calls that the new iterate.
13:57:40 <jeffwheeler> DBAlex: doesn't Windows use standard \t's? I thought it just screwed up newlines.
13:57:44 <yitz> ufear: it's really the best way if you do that. only be careful not to use stuff that looks *too* cool, that's all. :)
13:57:46 <DBAlex> maybe a bug in GHC version 6.10.1.20090226 ?
13:57:53 <ufear> yea I know :P
13:58:00 <DBAlex> jeffwheeler: me too, I dunno :S
13:58:29 <drhodes> > last $ take 8 $ iterate (\x -> x ++ [sum $ take 3 $ reverse x]) [1, 17, 27]
13:58:31 <lambdabot>   [1,17,27,45,89,161,295,545,1001,1841]
13:58:45 <johnbs> DBAlex: Windows does use normal tabs. Could it be an editor screwing around with them before it gets to GHC?
13:59:10 <centrinia>  > last $ take 8 $ iterate (\x -> x ++ [sum $ take 3 $ reverse x]) [9,7,1]
13:59:14 <centrinia> > last $ take 8 $ iterate (\x -> x ++ [sum $ take 3 $ reverse x]) [9,7,1]
13:59:16 <lambdabot>   [9,7,1,17,25,43,85,153,281,519]
13:59:18 <DBAlex> johnbs: well the '\t' is written in Notepad++
13:59:32 <DBAlex> but when I add the tabs I do it inside GHCI running under the command prompt
13:59:42 <DBAlex> *are
14:00:08 <centrinia> > last $ take 8 $ iterate (\x -> x ++ [sum $ take 3 $ reverse x]) $ map digitToInt 197
14:00:11 <lambdabot>       No instance for (Num [Char])
14:00:11 <lambdabot>        arising from the literal `197' at <...
14:00:16 <centrinia> > last $ take 8 $ iterate (\x -> x ++ [sum $ take 3 $ reverse x]) $ map digitToInt $ show 197
14:00:18 <lambdabot>   [1,9,7,17,33,57,107,197,361,665]
14:00:20 <centrinia> Hmm.
14:00:23 <centrinia> That's cleaner.
14:01:01 <DBAlex> brb
14:01:08 <ImInYourMonad> in gtk2hs: how do I make the buttons not extend themselves when I resize the window?
14:01:52 <DBAlex> http://209.85.229.132/search?q=cache:MV4zMtyeIzgJ:www.mail-archive.com/glasgow-haskell-users%40haskell.org/msg07632.html+haskell+lexical+error+in+string/character+literal+at+character&hl=en&ct=clnk&cd=3&gl=uk&client=firefox-a
14:01:54 <DBAlex> hmm
14:02:00 <DBAlex> I'll try a different ghc version
14:02:02 <DBAlex> brb anyway
14:02:38 <pumpkin_> DBAlex: I doubt you're using GHC 6.2
14:03:05 <monochrom> That message is completely informationless anyway.
14:03:31 <pumpkin_> DBAlex: that message sounds really ominous, but I really doubt it's a compiler error
14:03:52 <pumpkin_> DBAlex: what's your source again?
14:04:01 <monochrom> "Hi ubuntu 8 livecd didn't install"
14:04:35 <wli> qsieve is spending a lot of time on ECM
14:04:43 <wli> (for 2^(2^9) + 1)
14:04:50 <gnut> hi
14:05:01 <Cheshire> @go Proofs and Types
14:05:05 <lambdabot> http://net.shams.edu.eg/www.maththinking.com/5/prot.pdf
14:05:05 <lambdabot> Title: PROOFS AND TYPES
14:05:06 <gnut> is there any way to make ghc use a different compiler from gcc?
14:05:26 <monochrom> I think ghc is heavily invested in gcc.
14:05:29 <Zao> gnut: It'd be rather painful, but probably possible.
14:05:44 <Zao> Most likely not worth it though.
14:06:12 <gnut> Zao: I want to try to get haskell working on the ps3
14:06:13 <monkfish> gunt
14:06:19 <gnut> it needs ppu-gcc
14:06:24 <gnut> and spu-gcc
14:06:36 <Zao> gnut: Doesn't sony's toolchan use gcc?
14:06:48 <Zao> Well, one of them at least.
14:06:51 <centrinia> Do game developers use Haskell?
14:06:59 <gnut> I don't know about that, but IBM's SDK says to use ppu-gcc and spu-gcc
14:07:21 <pumpkin_> gnut: I think I saw some mention of it on the ghc dev wiki
14:07:26 <gnut> centrinia: heh. I don't know. I'm not one.
14:07:26 <b_g> clayyyyyy where r u
14:07:29 <b_g> oh shit
14:07:38 <b_g> sorry everybody
14:08:13 <gnut> pumpkin: something about the ps3?
14:08:23 <b_g> can anyone see me?
14:08:29 <pumpkin_> yeah
14:08:32 <aeolist> no, you are invisible
14:08:36 <aeolist> you finally made it
14:08:37 <b_g> just checking
14:08:38 <yitz> @vixen can you see b_g?
14:08:38 <lambdabot> i sure can
14:08:43 <aeolist> the formula was correct
14:09:52 <ImInYourMonad> in gtk2hs: how do I make the buttons not extend themselves when I resize the window?
14:10:08 <ImInYourMonad> http://github.com/ghc-hq/ghc/tree/master is it that or the ghc dir I should clone?
14:10:23 <ProdigySevenX> /msg nickserv identify centre
14:10:25 <b_g> clay
14:10:28 <ProdigySevenX> fuck
14:10:30 <ProdigySevenX> sup bg
14:10:31 <ProdigySevenX> lol
14:10:32 <thorkilnaur> wli, It should. 2^(2^9) + 1 = p7 * p49 * p99, where pn is n-digit prime (Math Comp 1993, pp 319-349).
14:10:32 <b_g> gawd
14:10:49 <ProdigySevenX> i have to fix tons of shit
14:10:52 <ProdigySevenX> like the way its red
14:10:54 <ProdigySevenX> and all
14:10:55 <ProdigySevenX> lol
14:11:01 <ProdigySevenX> let me send u the update
14:11:03 <ProdigySevenX> haha
14:11:07 <b_g> i cant change my font color? and everybody's color on my side is red n the same size
14:11:13 <b_g> when i first typed my font was huge
14:11:24 --- mode: ChanServ set +o Heffalump
14:11:29 <ProdigySevenX> lol yea we im working on all that
14:11:31 <inimino> is this related to Haskell?
14:11:35 <ProdigySevenX> no
14:11:40 <ProdigySevenX> we prob abotu to get kicked
14:11:41 <monochrom> @ops
14:11:41 <lambdabot> Maybe you meant: docs oeis pl
14:11:41 <ProdigySevenX> lol
14:11:44 <inimino> please take it elsewhere
14:11:46 <roconnor> @where ops
14:11:46 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:11:53 <b_g> kicked for what? talking
14:11:55 <Cheshire> woah
14:11:59 <Cheshire> woah
14:12:04 <Cheshire> what's going on
14:12:09 * Heffalump is testing the new command mauke taught me :-)
14:12:15 <monochrom> neato
14:12:19 <inimino> thanks :-)
14:12:37 <Heffalump> looks like we should get hte ops list expanded a bit
14:12:39 <yitz> Heffalump: is that supposed to be more polite?
14:12:51 <monochrom> Please add the @batsign command to lambdabot or something. :)
14:12:58 <Heffalump> yitz: mauke's point was that it is more likely to avoid auto-rejoin scripts
14:13:07 <drhodes> @let fibs3 = 1 : 17 : 27 : [ a + b + c | (a, b, c) <- zip3 fibs (tail fibs) (tail.tail $ fibs)]
14:13:07 <inimino> what that the "requested by" bit?
14:13:09 <lambdabot>  <local>:4:54: Not in scope: `fibs'
14:13:09 <lambdabot>  
14:13:09 <lambdabot>  <local>:4:65: Not in scope: `fibs'
14:13:09 <lambdabot>  
14:13:09 <lambdabot>  ...
14:13:14 <drhodes> grrrr.
14:13:15 <yitz> got it
14:13:15 <roconnor> The trick is that ops is just one thing that you can lookup with where
14:13:37 * Heffalump wonders what the procedure for declaring new ops is
14:13:53 <Cheshire> oh ok
14:13:53 <Cheshire> yeah
14:13:53 <Cheshire> there's too many people in here gotta start culling :p
14:13:58 <shapr> Heffalump: What's the new command?
14:14:06 <Cheshire> :(
14:14:08 <Cheshire> I want to read this entire book
14:14:08 <Heffalump> it's a REMOVE
14:14:15 <Heffalump> it makes the server pretend the client PARTed the channel
14:14:20 <shapr> oh, nifty
14:14:29 <Heffalump> remove     quote REMOVE $C $0 :$1-
14:14:31 <monochrom> What does the client side see?
14:14:33 <shapr> Wow cool
14:14:39 <Heffalump> monochrom: no clue. I can test it on you if you like :-)
14:14:50 * monochrom trembles
14:14:56 <Heffalump> only if you want..
14:15:08 <monochrom> OK, actually, please do. It shouldn't hurt.
14:15:30 <inimino> heh
14:15:34 <Cheshire> is monochrom coming back ????
14:15:36 <mauke> the client sees a normal PART
14:15:49 <monochrom> Interesting.
14:16:00 <ImInYourMonad> http://github.com/ghc-hq/ghc/tree/master is it that or the ghc dir I should clone?
14:16:07 <ImInYourMonad> in gtk2hs: how do I make the buttons not extend themselves when I resize the window?
14:16:14 <yitz> oh so you can do /remove idiot "get lost chump"
14:16:14 <roconnor> what is BDD?
14:16:33 <pejo> roconnor, binary decision diagrams
14:16:35 <mauke> yitz: without the quotes
14:16:55 <Heffalump> the server added the quotes
14:17:12 <monochrom> BDD = binary decision diagram?  binary tree (actually acyclic graph, sharing is important) to represent and help evaluate propositional formulas.
14:17:50 <mathijs> roconnor: also, it might refer to Behavior Driven Development
14:18:04 <roconnor> mathijs: oh, what is that
14:18:06 <ufear> whats the purpose of (&&&)
14:18:11 <yitz> monochrom: did you see the message when you parted, or only we saw it?
14:18:12 <monochrom> It's binary because for each variable there are two cases. Example: a&b becomes if a then (if b then True else False) else False.
14:18:15 <roconnor> that sounds more likely in this case
14:19:05 <centrinia> @type (&&&)
14:19:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
14:19:09 <monochrom> yitz: Oh, right, I got "You have left channel #haskell (requested by Heffalump: "it won't hurt a bit!")". That's an interpretation by xchat, I suppose it corresponds to an IRC protocol command.
14:19:15 <BitingTreeFerret> is there a FLV to MP4 (iPod) video format converter written in Haskell?
14:19:39 <roconnor> mathijs: ah, they just said " Behavior Driven Development"
14:19:55 <yitz> monochrom: on more gui things you might not see it then.
14:19:56 <monochrom> Brain Dead Development
14:20:02 <centrinia> ufear, think of it as taking two functions of the same argument and producing a tuple.
14:20:20 <mauke> monochrom: at the protocol level it looks like you did '/part #haskell requested by Heffalump: "it won't hurt a bit!"' yourself
14:20:30 <centrinia> > (+1) &&& (*5) $ 6
14:20:32 <lambdabot>   (7,30)
14:20:40 <ufear> ah
14:20:42 <ufear> makes sense
14:20:44 <Heffalump> you can imagine a client getting a bit confused given that it never sent it
14:20:46 <mathijs> roconnor: some variant of test-driven-development. I only know it from Ruby. It means you write tests first, and code afterwards, test have the form of 'age_should_return_a_number_of_years' , and you write some code that checks for a user-object if age returns the current date - birthday. After that you start implementing the user class/object
14:21:02 <yitz> roconnor: edwardk (who just left) was discussing bdd on in-depth a while ago. that was probable the binary decision thing.
14:21:07 <centrinia> @typeof  (+1) &&& (*5)
14:21:08 <lambdabot> forall b. (Num b) => b -> (b, b)
14:21:36 <ufear> okay, think i get it :)
14:21:42 <ufear> thanks
14:21:47 <centrinia> No problem.
14:21:58 <mathijs> roconnor: the idea is that you first write how a class/object _should_ behave, you run the tests - all fail, then you start implementing just the minimum nessecaire to make the tests succeed. This way, you guarantee full test coverage
14:22:00 <ufear> you rock!
14:22:00 <ufear> :D
14:22:16 <roconnor> mathijs: isn't that TDD rather than BDD
14:22:24 <ImInYourMonad> isnt test-driven-development just retarded? so many of these methodologies in software just seems like astrology to me.
14:23:24 <monochrom> test-drivien development is not retarded. if you take it to the limit (number of tests -> oo) you write formal specifications and prove your program conformant. I embrace it.
14:23:29 <yitz> ImInYourMonad: it doesn't need to be a religion, but tdd is actually useful in many situations.
14:23:36 <mathijs> roconnor: it's almost the same. BDD just mandates that tests are put in a should-context. That way you make sure you are working on a specification (what should happen when...) instead of just testing all kinds of things
14:23:49 <roconnor> mathijs: ok
14:23:51 <Cheshire> is there any language based on HORPO?
14:24:09 <Cheshire> astrology??
14:24:14 <arjanb> what's HORPO?
14:24:19 <monochrom> In fact QuickCheck and SmallCheck do a bit of that. They just don't do full proofs; but they do let n->oo and you write formal specifications.
14:24:30 <ImInYourMonad> oo?
14:24:36 <pumpkin_> poor man's infinity?
14:24:45 <monochrom> ∞ if you like
14:24:46 <mathijs> roconnor: BDD really isn't anything special compared to TDD. I did notice however that most customers are very willing to let you work on 'getting the specs done', while 'writing tests' doesn't have this effect.
14:25:14 <roconnor> mathijs: Thanks
14:25:15 <pejo> arjanb, higher order recursive path ordering? :-)
14:25:23 <monochrom> n→∞ :)
14:25:32 <mathijs> roconnor: especially because most customers think that testing is something that should be done afterwards.
14:26:23 <roconnor> right
14:27:27 <monochrom> "test" and "behaviour" are in principle the same. People tend to call values "test" and side effects "behaviour".
14:27:43 <yitz> mathijs: mistakes are your fault, tests are on your time.
14:27:52 <mathijs> ImInYourMonad: TDD and BDD are very useful on non-pure languages. They make you think about an implementation before actually writing code. Also they make sure that - if you change something in the future - stuff will keep working without errors popping up in unexpected places.
14:28:07 -ChanServ(ChanServ@services.)- glguy set flags +vVoOtsriRfA on roconnor.
14:28:14 -ChanServ(ChanServ@services.)- glguy set flags -VO on roconnor.
14:28:41 <Alpounet> But Haskell's type system, mostly, take care of possible errors
14:28:45 <Cheshire> I would like to be skilled and write progframs that fit formal specification
14:28:50 <pumpkin_> nah
14:29:02 <Alpounet> (non logical errors, though)
14:29:07 <pejo> Alpounet, no.
14:29:08 <pumpkin_> tests are still meaningful in haskell, you just don't have to test all the boring stuff you do in dynamic languages
14:29:30 <Alpounet> pumpkin, and even in non dynamical languages
14:29:40 <monochrom> QuickCheck and Smallcheck subsumes TDD.
14:29:44 <mathijs> yitz: but 'getting the specs straight' is something that customers like, especially if they can agree to them and even change them. there are quite some interresting developments in this area. check 'cucumber' for ruby. It enables customers to input their 'conformance tests' in plain english, and let the system generate tests for it.
14:29:58 <pumpkin_> it's not quite plain english
14:30:00 --- mode: Heffalump set -o Heffalump
14:30:12 -ChanServ(ChanServ@services.)- glguy set flags -iA on dennisb.
14:30:16 -ChanServ(ChanServ@services.)- glguy set flags -iA on emu.
14:30:17 <pumpkin_> and cucumber still uses real numbers
14:30:19 <Hasbro> ...
14:30:22 -ChanServ(ChanServ@services.)- glguy set flags -iA on Riastradh.
14:30:31 <Cheshire> arjanb, it seems to  be a way to show simple typed (beta reduction) and rewriting rules terminate
14:30:31 <Cheshire> arjanb, I am wondering if it's like the Charity of rewrite languages
14:30:31 <yitz> mathijs: yep
14:31:16 <adekoba> is there a function in ghc-base that has a type signature like: a -> [(a -> b)] -> [b] ?
14:31:25 <Cheshire> Alpounet not really
14:31:39 <Cheshire> Alpounet you have to write sensible programs too
14:32:07 <pumpkin_> > let fn a fs -> map ($a) fs in fn 5 [(+1), (*5), (^2)]
14:32:07 <lambdabot>   <no location info>: parse error on input `->'
14:32:13 <pumpkin_> > let fn a fs = map ($a) fs in fn 5 [(+1), (*5), (^2)]
14:32:14 <lambdabot>   [6,25,25]
14:32:27 <mathijs> pumpkin_: it's getting closer :)  all I was saying is that this is an interresting development. It can be seen in a different context than 'testing that your stuff won't break'. Speccing beforehand and having customers agree to it, can really save you and the customer some time (and disappointment), and can speed-up development when applied the right way.
14:32:32 <MarcWeber> adekoba: ask http://haskell.org/hoogle/
14:32:34 <bogner> is it possible to use jhc with cabal? I see that the option's there, but most packages require base 3, but i'm pretty sure that refers to ghc's base
14:32:36 <Alpounet> yeah, but type system as a beautiful impact on such stuffs, once got used to it
14:32:40 <Alpounet> has*
14:32:46 <pumpkin_> mathijs: yeah, it's true :)
14:32:48 <johnbs> let the customer write specs in "plain english" and generate tests automatically?  sounds like a disaster waiting to happen
14:33:02 <Alpounet> I've written a lot of C++ code, and was obliged to write tests
14:33:12 <Alpounet> I've even written some sort of Unit Testing lib
14:33:28 <Alpounet> things are much different in Haskell... quite much better.
14:33:43 <Lemmih> bogner: The jhc support in cabal is fairly broken.
14:33:46 <monochrom> Perl is "plain English", remember?
14:34:45 <monochrom> More seriously, you can design a formal language to be a tiny subset of English and it may suffice for your purposes.
14:34:48 <bogner> Lemmih: "broken, can be fixed" or "broken, lost cause just compile it yourself"?
14:35:01 <johnbs> if the customer can program he most likely won't enjoy using this "plain english" programming language. if he can't, then expecting him to write comprehensive and correct specifications is stupid
14:35:29 <pejo> Alpounet, I have a small module that is type correct but I'm still debugging and finding errors in it every week.
14:35:34 <mathijs> yitz: so I have to agree that 'mistakes are my fault', but this doesn't mean that tests/specs aren't a tool for the customer too. It offers a way to communicate changes. Other than just changing some part of the code when customers ask (which might go wrong in certain situation you and the customer didn't think of), you can just ask the customer what specification should change.
14:35:36 <Cheshire> a tiny subset of English: and, or, not, all, some
14:35:53 <Lemmih> bogner: The latter.
14:36:04 <monochrom> No, you need temporal operators too. "x when y" for example.
14:36:19 <yitz> mathijs: i didn't mean that statement. it was a representation of customer attitude, typically.
14:37:16 <dons> mm....... messing with inlining can happily change a program's runtime by a good 10x factor
14:37:28 <pumpkin_> yeah
14:37:38 <TomMD> dons: Is there a particular case you are going to share?
14:37:40 <pumpkin_> it's awesome :)
14:37:42 <yitz> mathijs: but we know that testing is an essential part of the development process. Customers typically don't realize the cost of integration either. we just build it all into the price quote.
14:37:54 <dons> TomMD: i'm using a GA to evolve optimal inline flags for a benchmark :)
14:38:02 <dons> idea: ghc is too complex to solve by hand
14:38:12 <dons> soln: use a genetic algorithm to breed inlining sites
14:38:23 <TomMD> dons: Has this lead to a generic Haskell GA library?
14:38:23 <mathijs> johnbs: specifications can be more like "when I login and click 'latest invoices', I expect to see the 20 latest invoices and 10 that are overdue". Also asking him what his definition of "overdue" is, might help. Maybe it means "14 days late, except for international customers"
14:38:24 <dons> results: lots of inlining combinations suck
14:38:29 <dons> TomMD: i'm reusing a C lib
14:38:36 <pumpkin_> you might need to put a sticker on it  saying "evolution is only a theory" if you intend to distribute that in certain US states
14:38:37 -ChanServ(ChanServ@services.)- glguy set flags +votsriRA on monochrom.
14:38:58 <Cheshire> what is going on in #haskell
14:39:07 <dons> i actually had a dream about 6am this morning how to program the inliner this way :)
14:39:16 <dons> and it turns out to be relatively easy to get something running
14:39:25 <dons> we'll see if we get a good solution (better than ghc's defaults)
14:39:27 <pejo> dons, how much time does it take to find something usable?
14:39:31 <pumpkin_> can TH generate GCC pragmas like INLINE?
14:39:36 <pumpkin_> GHC
14:39:41 <dons> pejo: well, depends on how many generations you want to run...
14:39:46 <pejo> dons, (I assume you just set the computer to .. compute?)
14:39:48 <dons> pejo: a few hours
14:40:07 <pejo> Ouch. Ok, so not really useful for anything but the production release.
14:40:09 <Heffalump> Cheshire: going on in what sense?
14:40:32 <dons> pejo: yeah. core algorithms i think. you'd determine the inlining offline
14:40:52 <dons> you can program arbitrary flags this way, actually
14:40:55 <TomMD> dons: What are your benchmarks?
14:41:02 <TomMD> HALVM RTS?
14:41:03 <dons> just using nbody from the shootout currently
14:41:04 <jfredett> hmm, is there any way to dynamically import a file? eg, I want to check to see if a file needs to be recompiled, if needbe, recompile it, and then import it as a module.
14:41:04 <johnbs> mathijs: if they're at that level, how does it automatically generate tests (or rather: how does it generate tests in a way that actually helps me as programmer)?
14:41:10 <dons> TomMD: thinking of some crypto stuff further down the line
14:41:22 <dons> TomMD: in that context, yes.
14:41:27 <jfredett> and ideally, store the location of the file in another file. :P
14:41:55 <dons> "Announcing the version 1.0.0 release of regex-tdfa.
14:41:55 <dons> I am proud of this release.
14:41:55 <dons> This is not just a bug fix release.
14:41:56 <dons> It is a serious improvement in the asymptotic running time."
14:41:58 <dons> go chris!
14:42:09 <Gracenotes> :D
14:42:13 <Gracenotes> @hackage regex-tdfa
14:42:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-tdfa
14:42:26 <Gracenotes> tagged?
14:42:59 <tromp_> :t foldr
14:43:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:43:51 --- mode: ChanServ set +o glguy
14:43:52 --- mode: glguy set -ob glguy *!*@d83-181-37-120.cust.tele2.at
14:44:07 <Gracenotes> well, lemme see what this tagging is all about, get me some finite automata sauce
14:44:28 <dons> http://aur.archlinux.org/packages.php?ID=18227 packaged.
14:44:31 --- mode: ChanServ set +o Heffalump
14:44:56 --- mode: Heffalump set -bb *!*n=andy@*.brnt.cable.ntl.com *!*@dxb-as72773.alshamil.net.ae
14:46:07 <ImInYourMonad> in gtk2hs: how do I make the buttons not extend themselves when I resize the window?
14:46:25 <ImInYourMonad> dons: what is it that you do in general? PhD?
14:46:40 <Zao> ImInYourMonad: Read the GTK2 docs to find a container to put them in or a property that you can set?
14:47:05 <mathijs> johnbs: the first example (about clicking and seeing stuff) doesn't help very much, it will only trigger an error if at a certain stage, you change list sizes or stuff like that. the second one can't be automatically generated, but will help in getting the 'domain' straight. I noticed that most customers have a vocabular that's tuned to their business-type, and people just understand each other. When translating that to code, some things that se
14:47:14 <mathijs> cut off? :)
14:47:56 <Botje> "some things that se"
14:48:06 --- mode: ChanServ set +o glguy
14:48:07 --- mode: glguy set -od glguy cdr03-84-91-10-32.netvisao.pt
14:48:09 <mathijs>  some things that seem trivial can have more to it. (take financial business
14:48:09 <mathijs>                  companies for instance). In that case, you want to make sure that every word the customer uses to explain
14:48:12 <mathijs>                  his needs is clear and can be explained in code (specification). So when you start coding, you know how
14:48:15 <mathijs>                  certain stuff should behave.
14:48:23 <mathijs> oops... sorry, wrong cut-n-paste
14:48:30 <Botje> mathijs: try hitting your enter key more often :)
14:48:48 <mathijs> that might help :)
14:49:43 <dons> ImInYourMonad: http://donsbot.wordpress.com/about/
14:49:46 --- mode: Heffalump set -bbbb *!*n=mendoza@89.254.131.* *!*=afrodozi@217.149.186.* *!*=IceChat7@201.170.132.* *!*@dyn56-188.res-hall.ndsu.NoDak.edu
14:49:58 <yitz> mathijs: watch your step, this place is bristling with ops today.
14:50:14 --- mode: Heffalump set -o Heffalump
14:50:22 <Botje> don't disturb the wildlife and you'll be fine ;)
14:50:41 <mathijs> yitz: I know, but most ops will be able to see that it wasn't on purpose or to spam or anything :)
14:50:59 <dcoutts> ImInYourMonad: the packing chapter of the gtk2hs tutorial describes it, but I suggest you play with glade for a bit, get a feel for how the packing parameters affect the way widgets respond as you change the size of the window.
14:51:22 --- mode: ChanServ set +o glguy
14:51:22 --- mode: glguy set -ob+b glguy *!*Gast*@* *!*Gast*@*!#haskell-ops
14:51:26 <Heffalump> I think you'll find it's bristling with ops normally, they're just normally low profile
14:51:36 <dcoutts> @arr!
14:51:36 <lambdabot> Keelhaul the swabs!
14:51:54 <johnbs> right, i agree the customer should be involved in creating the spec, but it can only work as a discussion (a long one :P) between the customer and implementor. the customer can't write the formal spec himself, he doesn't have the experience -- that's part of your job as the programmer
14:54:09 <trygvis> does anyone have any experience with the JSON package?
14:54:26 <Raevel> a little bit
14:54:27 <trygvis> I'm getting UTF-8 issues when trying to post some data to a server
14:54:29 <gnut> woohoo!
14:54:34 <Raevel> not that much.
14:54:35 <gnut> I got haskell code to compile on the ps3
14:54:57 <trygvis> the input is from an xml document, not sure how I can check if it was properly read
14:55:06 <yitz> gnut: that's great!
14:55:37 <gnut> yitz: yeah.. the trick is to use -fvia-C to bypass the native code generator
14:55:48 <gnut> and force it to use the sdk's gcc
14:55:55 <mathijs> johnbs: I agree. Well, not fully though. In my team, we have some people doing customer relations(with some technical background) that write specs together with the customer. This is part of 'consultancy'. The specs are given to 'software architects' who think of the high-level strategy and order of implementation. The specs are cut into pieces and written as BDD-tests. then a team of (lower level) implementators/programmers can start. All they 
14:56:12 <mathijs> implementators/programmers can start. All they need to do is get every BDD-test succeed.
14:56:38 <yitz> gnut: i've heard there was more to it than just that. glad to hear that it worked for you. bring this up on #ghc also.
14:57:00 <Alpounet> pejo, I don't say it keep from putting errors into code
14:57:04 <Alpounet> But it helps
14:57:12 <gnut> yitz: well, there may be more to getting the latest ghc up and running.
14:57:25 <yitz> gnut: what did you use?
14:57:34 <gnut> yitz: I am using 6.8.3... I was just stuck on all my code not compiling at all
14:57:38 <mathijs> anyway... enough of BDD/TDD and stuff :)  It's one of the reasons I'm learning FP (what something _is_ instead of how it should work).
14:57:50 <gnut> but I got a haskell "hello world" running.
14:58:25 <gnut> yitz: I hope to be able to use ffi to get the spu code working
14:58:36 <johnbs> mathijs: sounds good. but it would be better to describe cucumber as a tool for letting the programmer (or technical customer relations guy) write formal specs that can still be read directly by the customer, not as a tool to let the customer write formal specs.
14:59:00 <johnbs> mathijs: in that context i can see it possibly being useful
14:59:25 <gnut> yitz: I still can't get ghc-6.10.1 running though. it just won't configure.
15:00:05 <monochrom> I now agree with johnbs.
15:00:22 <mathijs> can someone point me to some tutorials of translating everyday problems into haskell? I read RWH and understand (mostly) everything in there. I was a bit confused about functor/applicative/monad and stuff, so I read typeclassopedia, which will take some time to become natural to me.
15:00:50 <bremner> mathjis: what is your idea of an everyday problem?
15:01:33 <bremner> mathijs: did you do the exercises in RWH? it doesn't seem like just sitting down and reading it from cover to cover would be that helpful
15:01:35 <mathijs> LYAH has 2 nice examples of 'functionally solving problems', but I would like to see more. RWH has some too, but what I need to learn is when to use what tool/typeclass and why.
15:01:54 <mathijs> bremner: I did quite a few of them. not all, I admit :)
15:02:00 <roconnor> mathijs: you should solve the puzzles in the 2006 ICFP contest in Haskell
15:02:18 <bremner> but are those "everyday" ?
15:02:21 <roconnor> mathijs: well, except for the UM implemenation, you should do that in C.
15:02:31 <roconnor> mathijs: then solve the rest in Haskell
15:02:42 <roconnor> then rewrite the UM in Haskell. :P
15:02:52 <bremner> mathjis: full disclosure: I have down hardly any of the exercises
15:03:01 <bremner> s/down/done/
15:03:09 <ImInYourMonad> man I can sit and just look at my haskell programs and admire their elegance. the last 3 days have just blown me away. i will neve rgo back
15:03:18 <pumpkin_> yay
15:03:20 <kniu> how do I break out of a damn complex recursive function without putting it in a monad?
15:03:21 <pumpkin_> another convert :)
15:03:25 <wli> The ICFP contest problems are mostly beyond me.
15:03:26 <roconnor> ImInYourMonad: http://r6.ca/blog/20081116T213644Z.html
15:03:43 <Botje> kniu: refactor the damn complex recursive function into something easier first ;)
15:03:46 <wli> I need something a bit more basic for pedagogical purposes.
15:04:02 <bremner> wli: what about euler problems?
15:04:04 <Botje> wli: projecteuler.net and the ACM problem sets are nice
15:04:19 <roconnor> kniu: you can't without a monad, but you might be able to simplify your complexity until it is manageable.
15:04:22 <mathijs> bremner: well, it's not really about "everyday". What I mean is 'how to approach a problem in haskell'. In OOP I start by getting my classes clear (what instance variables are there, what methods), then look at how classes interact.
15:04:25 <kniu> Botje, by damn complex, I mean that there are three functions recursively calling each other.
15:04:31 <Botje> kniu: brr :)
15:04:37 <wli> I don't like Project Euler for pedagogical purposes. I've not seen the ACM problem sets.
15:04:39 <kniu> hm
15:04:50 <wli> Project Euler is about math, not programming.
15:05:10 <kniu> if only I had global variables.
15:05:10 <bremner> wli: there is a book by Skiena with selected acm problems, with discussion
15:05:13 <johnbs> unless you use all brute-force solutions: then it's about raw computing power :P
15:05:22 <sciolizer> mathijs: the main difference between Haskell programming and other languages, in terms of how to approach a problem, is exploiting laziness
15:05:28 <Botje> wli: http://icpcres.ecs.baylor.edu/onlinejudge/index.php?option=com_onlinejudge&Itemid=8&category=3
15:05:37 <roconnor> mathijs: I usually think about what data types I need, and then, on occasion, what monad properties I will need.
15:05:38 <kniu> if (iter > 100000) return; iter++;
15:05:44 <wli> johnbs: If you do that you aren't doing it in any useful way.
15:05:45 <Botje> i solved the first 9 i believe
15:05:56 <Botje> the ACM problems are really about finding a good algorithm
15:06:05 <Botje> not obscure mathematical properties of obscure numbers :)
15:06:13 <mathijs> roconnor: I didn't study maths (still good at it though), so I was hoping to learn how to approach non-mathematical problems. I did some tries at the collatz-problem (3N+1) which was very helpful.
15:06:27 <roconnor> mathijs: the most important thing is finding the pure way, of looking at your data, which can be very tough at times, but very worthwhile.
15:06:33 <johnbs> wli: i know, i wasn't serious (sorry, should've used a ":P")
15:06:41 <bremner> there is (IMHO) an unfortunate amount for futzing around with I/O in the ACM problems
15:06:52 <Botje> meh
15:07:03 <roconnor> mathijs: I like the some of the ICFP contest puzzles because they are not all math oriented.
15:07:06 <Botje> you just skip the IO parts
15:07:13 <mathijs> sciolizer: I noticed that. I found that using infinite structures can be very helpful
15:07:20 <bremner> Botje: not if you want to use the online judges
15:07:48 <mathijs> roconnor: I'll look at them.
15:08:00 <Botje> bremner: do they accept haskell?
15:08:05 <Botje> they didn't when i first made that bookmark :)
15:08:09 <bremner> good point
15:08:17 <BONUS> what the heck is this http://icfpcontest.org/
15:08:24 <BONUS> looks like some random company site
15:08:30 <mathijs> I guess it takes time getting used to FP. looking at problems from a different angle.
15:08:31 <roconnor> mathijs: http://boundvariable.org/task.shtml
15:08:40 <wli> The ACP problem set looks a little better.
15:08:52 <mathijs> BONUS: please please, when will you continue LYAH? :)
15:08:54 <wli> bremner: That's a good thing.
15:08:57 <roconnor> mathijs: I found that year particularly fun, but don't do the UM in Haskell.
15:09:06 <abuiles> Hi everyone, if I want to have the second value of this (Result Response_String) , how can I do it ? case ?
15:09:11 <BONUS> mathijs: agh! soon! i know, i'm terrible!
15:09:24 <BONUS> so much stuff going on right now :(
15:09:45 <bremner> wli: I mean that it can be frustrating for students getting the output format exactly right. Depends what you want of course.
15:09:52 <roconnor> kniu: paste?
15:10:20 <roconnor> abuiles: HTTP?
15:10:21 <Botje> abuiles: uh, do you mean (Result, Response_String) ?
15:10:21 <kniu> @hpaste
15:10:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:10:24 <Botje> if so, snd.
15:10:32 <kniu> Not found?
15:10:39 <mathijs> BONUS: no problem :)  I was just talking about the 'functionally solving problems' part. those examples are very helpful to me.
15:10:43 <abuiles> roconnor: yes , HTTP
15:10:55 <BONUS> really? thats good to know, i wondered if those would help anyone
15:10:59 <abuiles> is not a tuple
15:11:04 <Botje> bremner: you just give the students a function signature and some sample calls / results to it. No need for IO :)
15:11:05 <BONUS> i'm thinking of adding more of those, i just need ideas for problems though
15:11:34 <abuiles> pair*
15:11:38 <roconnor> abuiles: what do you want to do with the result, and what do you want to do if there is an error?
15:12:17 <mathijs> BONUS: yeah they are helpful. Most stuff from RWH learned me how stuff works, but I need to learn to translate problems into FP.
15:12:27 <kniu> roconnor, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1949#a1949
15:12:38 <BONUS> mathijs: yeah that's a hurdle for a lot of people. project euler helped me get over the fence in that area
15:12:38 <abuiles> roconnor: I want to get the body from the result if error, just print somethings..
15:12:51 <BONUS> although some people don't recommend it, it helped me get the "feel" of haskell
15:13:01 <roconnor> @src either
15:13:01 <lambdabot> either f _ (Left x)     =  f x
15:13:01 <lambdabot> either _ g (Right y)    =  g y
15:13:06 <roconnor> @type either
15:13:07 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
15:13:10 <mathijs> BONUS: from ICFP ?
15:13:23 <BONUS> uh no, www.projecteuler.net
15:13:33 <Botje> mathijs: check the link I gave wli for some more interesting problems
15:13:42 <Botje> ooh
15:13:45 <abuiles> roconnor : is that type either ?
15:13:51 <Botje> time for dexter
15:13:53 <Botje> <<
15:14:01 <roconnor> abuiles: either (const (print "Error")) (bodyHandler) yourResult
15:14:20 <roconnor> abuiles: where bodyHandler :: Response_String -> IO ()
15:14:32 <sciolizer> mathijs: it depends widely on what type of application you are writing, but in my experience, the top level of a Haskell program is usually a pipeline of functions
15:14:43 <roconnor> abuiles: type Result a = Either ConnError a
15:14:49 <mathijs> Botje: checking... thanks
15:14:59 <sciolizer> mathijs: e.g. return . foo . bar =<< baz . bleh
15:15:07 <roconnor> kniu: looking now
15:15:44 <roconnor> kniu: you want to bail out if depth gets too big, right?
15:15:54 <kniu> yea
15:15:58 <mathijs> sciolizer: well that's the problem... I'm not writing an application :)  I'm thinking of porting parts of code I did in ruby to haskell, especially parser stuff and transformations.
15:16:31 <dons> mmm. did my littler evolver find a new magic inlining trick? 2.09767s mmm
15:16:37 <dons> whoa. yes.
15:16:40 <roconnor> kniu: the first thing that comes to mind is to use the clock (monad)
15:16:42 <dons>      Acovea's Best-of-the-Best: ******************************                        (2.1532)
15:16:45 <dons>        Acovea's Common Options: ******************************                        (2.1165)
15:16:49 <dons>                       -optc-O3: **************************************************    (3.5264)
15:17:00 <dons> modify inlining -- 2.1s vs 3.5s. mmmm
15:17:00 <abuiles> roconnor: what is the name of that , I mean, putting types in that style ? type Request_String = Request String ?
15:17:24 <roconnor> abuiles: that is a type synonym.  Is that what you are asking?
15:17:36 <Cheshire> dons, "evolver"? huh sounds cool
15:17:36 <roconnor> kniu: this is the clock (monad):
15:17:37 <kniu> the clock monad?
15:17:46 <sciolizer> mathijs: in that case, I would start with defining the data structures, write some functions which convert the types (e.g. String -> MyType), and then stitch them together at the top with a pipeline
15:17:51 <Cheshire> dons some kind of brute force optimization thing ..?
15:17:56 <roconnor> kniu: data Partial a = Tick | Value a
15:18:00 <dons> genetic algorithm, yeah, to find inline points
15:18:09 <Cheshire> cool
15:18:14 <roconnor> kniu: have all your function return Partial Color
15:18:22 <dons> i think that's just found a 30% speedup on our shootout entry..
15:18:28 <roconnor> kniu: at each recursion step, insert a Tick constructor
15:18:31 <sciolizer> mathijs: its analogous to: define your classes/components first, and then stitch them together using some IoC framework
15:18:50 <roconnor> kniu: then you can write a function Int -> Partial Colour -> Maybe Colour
15:18:53 <abuiles> roconnor : no. what I mean, is when you put in the synonym two types,
15:19:09 <roconnor> kniu: that consumes a certain number of Ticks before failing
15:19:14 <roconnor> kniu: does that make sense?
15:19:25 <sciolizer> mathijs: although IoC may not be a big thing coming from Ruby
15:19:27 <kniu> laziness takes care of the rest?
15:19:27 <ImInYourMonad> roconnor: cool but isnt that circular recursive without a absecase?
15:19:33 <kniu> it kind of makes sense.
15:19:38 <ImInYourMonad> oh wait now i read properly
15:19:45 <mathijs> sciolizer: ok I might try that. It's very similar to what I'm used to, so somehow that gives me the feeling I'm not exploiting haskell's power that way.
15:19:49 <roconnor> ImInYourMonad: pulling out the 2 gives a base case :P
15:19:56 <roconnor> kniu: right
15:20:13 <roconnor> abuiles: I'm afraid I don't understand the question. Can you rephrase it?
15:20:18 <abuiles> Request_String =( Request String  ) -> note the types separated  inside the parenthesis
15:20:56 <roconnor> abuiles: in that case Request is a type constructor, like Maybe is.
15:20:59 <roconnor> @kind Maybe
15:21:00 <lambdabot> * -> *
15:21:07 <roconnor> @kind String
15:21:08 <lambdabot> *
15:21:15 <jeffwheeler> @kind Either
15:21:16 <lambdabot> * -> * -> *
15:21:56 <roconnor> kniu: there are many ways to deal with the problem, but what I said is the first solution that come to my mind.
15:22:13 <abuiles> roconnor : thanks
15:22:23 <sciolizer> mathijs: the power comes from the laziness and the purity. Purity means you don't have to work around your own code as often (e.g. backtracking in a parser is easy, because there's nothing to "unwind"), and laziness means you don't need as much initialization (e.g. You don't need to initialize your components with the size of the data structures that you're going to be working with)
15:22:31 <ImInYourMonad> wli: where are the ifcp problems?
15:22:56 <roconnor> kniu: and ya, this solution makes essential use of laziness
15:23:35 <sciolizer> mathijs: Ruby is a very functional language, so the Haskell win isn't going to be smaller than if you were coming from, say, Java. But it's still big. :)
15:23:45 <roconnor> kniu: oh I totally wrote the datatype wrong
15:23:57 <roconnor> kniu: data Partial a = Tick (Partial a) | Value a
15:24:06 <roconnor> kniu: sorry if I confused you.
15:24:15 <Cheshire> Ruby is the same as Java
15:24:21 <Alpounet> gn all
15:24:27 <sciolizer> Cheshire: closures?
15:24:52 <roconnor> kniu: so it contains values such as, Value 5, Tick (Value 5), Tick (Tick (Tick (Value 5), and even Tick (Tick ...)
15:25:03 <Cheshire> sciolizer ...
15:25:04 <yitz> @remember Cheshire Ruby is the same as Java
15:25:04 <lambdabot> I will never forget.
15:25:18 <mathijs> sciolizer: ok so you're saying that if I approach stuff the 'data first, conversion functions second' way, I will see where/how to exploit laziness naturally?
15:26:22 <ImInYourMonad> is there a shuffle algorithm in Data.List ?
15:26:33 <ImInYourMonad> > Data.List.shuffle [1..10]
15:26:34 <lambdabot>   Not in scope: `Data.List.shuffle'
15:26:37 <pumpkin_> nope, though there have been several discussions on it
15:26:44 <roconnor> kniu: hmm, now that I look more carefully at your problem, I fear my solution won't work :(
15:26:48 <yitz> > permutations "abcde"
15:26:49 <lambdabot>   Not in scope: `permutations'
15:26:52 <kniu> oh?
15:27:01 <yitz> well, it was added lately, not on lambdabot yet
15:27:03 <ImInYourMonad> > perm [1..3]
15:27:04 <lambdabot>   Not in scope: `perm'
15:27:04 <pumpkin_> ImInYourMonad: the simplest way is probably to zip the list with a random sequence and sort it by that
15:27:07 <ImInYourMonad> > perms [1..3]
15:27:08 <lambdabot>   Not in scope: `perms'
15:27:10 <roconnor> kniu: because you aren't returning just one colour in the end, but blending different recursive calls.
15:27:12 <pumpkin_> ImInYourMonad: but there are better ways
15:27:16 <kniu> yes
15:27:24 <roconnor> kniu: ya, sorry about that.
15:27:30 <yitz> ImInYourMonad: it is in the latest version of Data.List. lambdabot doesn't have it yet.
15:27:31 <roconnor> kniu:  let me rethink
15:27:42 <kniu> mayhaps something with unsafePerformIO
15:27:49 <yitz> ImInYourMonad: but do you want a random shuffle, or all shuffles?
15:27:54 <Cheshire> kniu, probably not
15:28:14 <dons> ahah, the genetic algorithm broke the unsafePerformIO inline rule
15:28:17 <dons> and things got faster -- but wrong :)
15:28:24 <pejo> dons, but fast!
15:28:25 <roconnor> kniu: oh no.  Don't use unsafePerformIO here.
15:28:28 <roconnor> kniu: :)
15:28:37 <dons> inneresting.
15:28:38 <kniu> :|
15:28:40 <yitz> dons: drat
15:28:47 <pejo> dons, does the ga have access to the inlining decisions in the core somehow?
15:28:49 <Cheshire> In Prolog when people are faced with a difficult problem they go... Oh I guess cut !/0 will help me here
15:28:54 <roconnor> kniu: there is always the solution of passing down the recursion depth, but that solution is inelegent.
15:28:57 <Cheshire> and in Haskell, they say the same about unsafePerformIO
15:29:22 <dons> pejo: not in core. but it can turn them on and off at the src level
15:29:46 <sciolizer> mathijs: yes and no. For example, if you are writing your own serializer, but the protocol requires that the size of the data being serializes is stored at the front of the output stream, then you won't really have a streaming protocol
15:29:53 <pejo> dons, oh, you're permuting the source?
15:30:02 <sciolizer> mathijs: so decisions about your data structure are important
15:30:03 <kniu> I increased the stack space and reduced the resolution.
15:30:03 <pejo> dons, (with inline-pragmas?)
15:30:07 <dons> yeah, its switching on and off {-# INLINE #-} pragmas
15:30:14 <kniu> the program finished, but after a REALLY long time.
15:30:17 <SamB> Cheshire: not as often!
15:30:26 <sciolizer> mathijs: but even if you are working with "non-lazy" data structures, you will still see other cases of laziness arise naturally
15:30:45 <kniu> I guess none of the rays had the right vector to bounce infinitely.
15:30:59 <dons> i think this points to a new transformation i can make on the code though to speed things up
15:31:41 <roconnor> kniu: ya, it is unlikely you'd hit one that bounces forever, but you still want to be able to limit the recursion depth.
15:32:36 <roconnor> kniu: I have a few ideas, similar to the Clock (monad), I'm just trying to see if there is a simpler way to do it than I'm imagining.
15:32:49 <yitz> dons: besides the timings, maybe through in a few quickcheck properties there
15:32:55 <yitz> *throw
15:33:00 <roconnor> kniu: the rough idea I have in mind is to return a list of colours, [Color]
15:33:17 <kniu> and then just fold them together afterwards?
15:33:21 <dons> yitz: yeah, i think i can validate the output, and assign infinite cost to optimiations which break the program :)
15:33:27 <yitz> heh
15:33:27 <dons> yitz: we might find ghc bugs this way, ...
15:33:34 <yitz> there you go
15:33:46 <mathijs> sciolizer: yeah I found that when working at the 3N+1 problem, in the end I could just generate a tree using unfoldTree and stop worrying about when to calculate a next level.
15:33:54 <roconnor> kniu: and the idea would be that the further down the list the colour is, the deeper the recursive depth that it was found
15:34:01 <lilac> if anyone wants a challenge:http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1679
15:34:16 <roconnor> kniu: so you'd do sum (take 100 (rayTrace foo bar))
15:34:18 * dons fires up the evolver
15:34:28 <kniu> hmm
15:34:45 <sciolizer> mathijs: ah, yeah that's a good example
15:35:49 <ImInYourMonad> i have 6.10.1, it doesnt have shuffle. also, is it a monad?
15:36:06 <roconnor> kniu: you'd have to write special function to merge the lists of colours in rayTrace
15:36:09 <pumpkin_> @src ap
15:36:09 <lambdabot> ap = liftM2 id
15:36:11 <ImInYourMonad> yitz: i want random shuffle, it is for a playlist to an mp3player
15:36:32 <yitz> ImInYourMonad: ah ok, then that permutations function isn't what you want.
15:36:41 <mathijs> sciolizer: well thanks for helping. I'll try some of the project euler problems and the ones Botje pointed me too, and try your approach.
15:36:56 <yitz> ImInYourMonad: random stuff works out nice in a monad, yes
15:37:01 <sciolizer> mathijs: cool. have fun :)
15:37:21 <roconnor> kniu: did what I say make sense.  Is it enough for you to go on?
15:37:40 <roconnor> kniu: (or perhaps you are skeptical of this approach)
15:37:45 <whpearson> roconnor: Are your rays branching? If so are you depth first searching?
15:37:59 <kniu> It amkes sense.
15:38:01 <ImInYourMonad> but using randomRIO or something then i egt the same permuation each time? also it cant rturn soemthing it alreadyd di then i could have potetnail forverlooping
15:38:12 <kniu> I'll try to implement.
15:38:36 <yitz> ImInYourMonad: there was a discussion of various tree-based solutions to this on haskell-cafe recently. but I personally have a function that just uses a Data.Map in a State monad (or MonadRandom from hackage)
15:38:39 <roconnor> whpearson: it is not so much of a search.
15:38:52 <roconnor> whpearson: but, ya it is branching
15:39:14 <pumpkin_> @src (<$>)
15:39:14 <lambdabot> f <$> a = fmap f a
15:39:25 <pumpkin_> @src (->) <*>
15:39:25 <lambdabot> Source not found. Take a stress pill and think things over.
15:39:36 <yitz> ImInYourMonad: I don't like the random*IO functions. You don't need to force an entire calculation into the IO monad just because it has randomness.
15:39:39 <pumpkin_> @src (->) (<*>)
15:39:39 <lambdabot> (<*>) f g x = f x (g x)
15:41:05 <whpearson> roconnor: Traversing is the same issue, unless you do breadth first you'll get the deep left or right collisions of ray and object  before shallow ones (depending upon the order of recursion)
15:42:20 <roconnor> whpearson: ah no, I think this will end up effectively as a breadth first traversal
15:42:33 <ray> why are you colliding me into objects?
15:43:29 <roconnor> because kniu will write a function something like: merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) = (x+y):merge xs ys
15:43:34 <pumpkin_> you know how in Data.Binary.Get it's typical to do liftM2 Constructor get get?
15:43:48 <pumpkin_> (it is, right?)
15:43:49 * roconnor wonders if mergeWith is in the standard libs somewhere
15:44:13 <pumpkin_> :t liftM2
15:44:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:44:14 <johnbs> roconnor: isn't that just zipWith?
15:44:17 <yitz> ImInYourMonad: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1680#a1680
15:44:46 <johnbs> :t zipWith
15:44:47 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:45:01 <roconnor> johnbs: this result has length equal to (max (length xs) (length ys)) rather than min
15:45:07 <johnbs> oh, i see
15:45:08 <johnbs> ok
15:46:52 <pumpkin_> say I would normally be doing liftM3 Constructor get get get, but instead of having a constant Constructor there, I want a function too, something like \x -> [Cons1, Const2] !! x (as a lame example)
15:47:17 * roconnor wonders if merge needs some strictness.
15:47:25 <pumpkin_> I feel like I should be playing with ap, but can't get it to work
15:47:51 <Cheshire> \x -> liftM3 ([Cons1, Const2]!!x) get get get
15:47:52 <Saizan> you can have an arbitrary function in place of the Constructor there
15:48:07 <pumpkin_> I mean
15:48:14 <pumpkin_> a function that also depends on a get
15:48:24 <Saizan> ah
15:48:25 <Cheshire> use do notation
15:48:27 <Saizan> non-pure
15:48:28 <pumpkin_> (I'm not using binary here, but it's mostly analogous)
15:48:44 <pumpkin_> Cheshire: good idea, then I can figure out what I mean, and use that :P
15:48:57 <Saizan> liftM3 f x y z = f <$> x <*> y <*> z
15:49:10 <pumpkin_> yeah, I tried to play with the applicative ones too
15:49:18 <Saizan> in your case you want <*> in place of <$> probably
15:49:20 <pumpkin_> but it didn't work in the way I expected it to
15:49:43 <Saizan> it really depends on the type of f
15:52:40 <pumpkin_> oh wow
15:52:59 <pumpkin_> it would help if I made my constructors take the right type before trying this :P
15:53:02 * pumpkin_ kicks himself
15:57:18 <mmorrow> @type \f a b c -> join (liftM3 f a b c)
15:57:18 <lambdabot> forall a1 a2 a3 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
15:58:38 <pumpkin_> :o
15:58:49 <roconnor> @pl \f a b c -> join (liftM3 f a b c)
15:58:49 <lambdabot> (((join .) .) .) . liftM3
15:59:16 <roconnor> @type liftM (liftM (liftM join)) liftM3
15:59:17 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a3)
15:59:17 <lambdabot>     Probable cause: `liftM3' is applied to too many arguments
15:59:17 <lambdabot>     In the second argument of `liftM', namely `liftM3'
15:59:34 <roconnor> @type liftM (liftM (liftM (liftM join))) liftM3
15:59:35 <lambdabot> forall a a1 a2 a3 (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
15:59:40 <roconnor> heh, needed more liftM
15:59:50 <mmorrow> liftM is the new cowbell
16:00:12 <roconnor> @type (liftM `liftM` liftM `liftM` liftM `liftM` liftM join) liftM3
16:00:13 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) (m2 :: * -> *) a2 a3 r (m3 :: * -> *). (Monad m3, Monad m2, Monad m1, Monad m) => m (m1 (m2 (a2 -> a2 -> a3 -> r))) -> m (m1 (m2 (m3 a2 -> m3 a3 -> m3 r)))
16:00:32 <roconnor> @type (liftM `liftM` liftM `liftM` liftM `liftM` liftM) join liftM3
16:00:33 <lambdabot> forall a a1 a2 a3 (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> m a) -> m a1 -> m a2 -> m a3 -> m a
16:00:46 <roconnor> much more clear
16:00:52 <ImInYourMonad> could there be an official Vector and Matrix library for GHC or the representation of a Maatrix can be done in so many ways and it depends on the problem that it doesn't make any sense?
16:01:03 <pumpkin_> beware of the meatrix
16:02:00 <edwardk> hrmm. why when i cabal install parsec do i get 2.1.0.1 when there is 3.0.0.0 up on hackage?
16:02:24 <dcoutts> edwardk: the default version is 2.x
16:03:10 <Saizan> dcoutts: pong, should i mail waern about haddock's defines?
16:03:12 <amaron_> how would you format numbers in style "$1,200,334.22"?
16:03:16 <edwardk> dcoutts: because the change was backwards incompatible?
16:03:24 <ski_> (Cheshire : "... Oh I guess cut !/0 will help me here" Now they have two problems ?)
16:03:59 <mmorrow> amaron_: with many reverses (/me has had to do this and it's slightly trickier than you'd first think)
16:04:17 <DBAlex> rstrip (x:xs) = do {let xs = reverse xs;dropWhile (== ' ') xs;let xs = reverse xs;}
16:04:23 <DBAlex> anyone tell me whats wrong with this?
16:04:39 <johnbs> where's the x gone in the output?
16:04:41 <ski_> > let xs = reverse xs in xs
16:04:51 <DBAlex> true
16:04:56 <lambdabot>   thread killed
16:05:14 <DBAlex> johnbs: fileio.hs:29:57: parse error on input `;'
16:05:17 <ski_> `let'-bindings are recursive
16:05:30 <DBAlex> > rstrip xs = do {let xs = reverse xs;dropWhile (== ' ') xs;let xs = reverse xs;}
16:05:31 <lambdabot>   <no location info>: parse error on input `='
16:05:32 <pumpkin_> w00t jfredett is following me
16:05:45 <ski_> `dropWhile (== ' ') xs' is not a proper binding
16:05:45 <edwardk> ah figured it out, cabal install 'parsec >= 3' worked
16:05:51 <johnbs> DBAlex: reverse . (dropWhile (== ' ')) . reverse
16:06:07 <DBAlex> johnbs: whats the . for?
16:06:15 <johnbs> function composition
16:06:21 <DBAlex> ok
16:06:37 <johnbs> (f . g) param  ==  f (g param)
16:06:49 <ski_>   rstrip (x:xs) = reverse (dropWhile (== ' ') (reverse xs))
16:07:00 <johnbs> but using (f . g) means you don't have to refer to param at all
16:07:12 <johnbs> ski_: you've still made the first character vanish
16:07:22 <dcoutts> edwardk: right
16:07:32 <ski_> johnbs : yes .. it's not clear whether that was intended or not
16:07:38 <johnbs> fair enough
16:07:47 <ski_> DBAlex : why did you have `do', there ?
16:08:07 <DBAlex> ski_: to group more than one function?
16:08:18 <DBAlex> > rstrip xs = reverse . (dropWhile(== ' ')) . reverse
16:08:19 <lambdabot>   <no location info>: parse error on input `='
16:08:27 <DBAlex> heh
16:08:30 <ski_> DBAlex : what do you mean ?
16:08:37 <ImInYourMonad> goodnight
16:08:53 <dcoutts> edwardk: parsec-3 was initially a somewhat experimental generalisation.
16:09:01 <DBAlex> ski_: if you need to do more than one unrelated thing you have to use do, right?
16:09:09 <ski_> DBAlex : no
16:09:19 <ski_> you use `do' if you want to use a monadic computation
16:09:27 <dcoutts> Saizan: yes, please
16:09:39 <DBAlex> hmm ok
16:09:49 <ski_> if you just want to name several (possibly) independent expressions, you use plain `let' (or `where')
16:09:57 <dcoutts> Saizan: in the mean time we should not -D__HADDOCK__ for 2.x
16:10:13 <DBAlex> ok
16:10:22 <dcoutts> Saizan: do you want to send a patch for that or should I do it?
16:10:33 <ski_>   rstrip (x:xs) = let {xs1 = reverse xs; xs2 = dropWhile (== ' ') xs1; xs3 = reverse xs2} in xs3
16:11:01 <DBAlex> ski_: this version you posted works fine rstrip xs = reverse (dropWhile (== ' ') (reverse xs))
16:11:08 <DBAlex> ski_: what does in mean?
16:11:21 <ski_> > let x = 8 in x * x
16:11:23 <lambdabot>   64
16:11:25 <DBAlex> > let x = [1..10] print in x
16:11:26 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:11:33 <ski_> > let {x = 8; y = 1} in x * x + y
16:11:34 <lambdabot>   65
16:11:35 <mmorrow> amaron: maybe this could be simpler, but it works: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1951#a1951
16:11:43 <DBAlex> ok
16:11:44 <mauke> preflex: quote tac-tics
16:11:44 <preflex>  <tac-tics> Haskell is 50% style and 60% research... and -10% code bloat
16:12:06 <ski_> DBAlex : the names bound by the bindings after the `let' are visible in the expression after the `in'
16:12:26 <ski_> DBAlex : .. also, you should consider whether  isSpace  would be better than  (== ' ')
16:12:37 <ski_> > isSpace ' '
16:12:38 <lambdabot>   True
16:12:39 <ski_> > isSpace 'A'
16:12:40 <lambdabot>   False
16:12:43 <ski_> > isSpace '\n'
16:12:44 <lambdabot>   True
16:12:49 <DBAlex> ski_: It wouldn't, because I want to do || (== '\t')
16:12:58 <DBAlex> > isSpace '\t'
16:13:00 <lambdabot>   True
16:13:02 <DBAlex> ah
16:13:06 <mmorrow> , let x = 0 : y; y = [1..4] ++ x in zip x y
16:13:07 <DBAlex> so which character can it detect?
16:13:08 <lunabot>  [(0,1),(1,2),(2,3),(3,4),(4,0),(0,1),(1,2),(2,3),(3,4),(4,0),(0,1),(1,2),...
16:13:11 <ski_> > isSpace '\v'
16:13:12 <lambdabot>   True
16:13:14 <DBAlex> *characters?
16:13:19 <pumpkin_> mmorrow: my disassembler started out based on the arm-dis from binutils, but has changed so much that it's barely recognizable now... do you think I'm bound as a derivative work and must follow their GPL?
16:13:22 <kerlo> > filter isSpace [minBound..maxBound]
16:13:23 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
16:13:26 <DBAlex> > isSpace '\b'
16:13:27 <lambdabot>   False
16:13:31 <DBAlex> > isSpace '\tab'
16:13:31 <lambdabot>   <no location info>:
16:13:31 <lambdabot>      lexical error in string/character literal at chara...
16:13:35 <ski_> > isSpace '\f'
16:13:36 <lambdabot>   True
16:13:38 <amaron> mmorrow: nice, thank you! it wasn't so simple after all :)
16:13:49 <DBAlex> ok cool
16:13:50 <kerlo> I wonder what the \8192 series is.
16:14:01 <mmorrow> pumpkin_: naw, aren't you just using it for the instruction info? ;)
16:14:07 <mmorrow> amaron: np
16:14:07 <pumpkin_> yup
16:14:11 <whpearson> @hoogle (m a -> m a) -> [m a]
16:14:12 <lambdabot> No results found
16:14:15 <ski_> ('\v'  is vertical tab,  '\f'  is form feed)
16:14:17 <mauke> U+2000 (e2 80 80): EN QUAD [ ]; U+2001 (e2 80 81): EM QUAD [ ]; U+2002 (e2 80 82): EN SPACE [ ]; U+2003 (e2 80 83): EM SPACE [ ]; U+2004 (e2 80 84): THREE-PER-EM SPACE [ ]
16:14:23 <whpearson> No monadic iterate :(
16:14:32 <DBAlex> still getting this error: <interactive>:1:13:
16:14:33 <DBAlex>     lexical error in string/character literal at character '\t'
16:14:38 <DBAlex> I might go and try ghc in linux
16:14:39 <DBAlex> brb
16:14:56 <defun> would "(++) <$> string "HT" <*> (string "TP" <|> string "ML")"   be the same as  "fmap (++) (string "HT" ((string "TP" <|> string "ML"))"
16:15:21 <pumpkin_> mmorrow: so, different language, same fundamental "list of mask/values to check + operand readers", but broken away from strings, with semantic information, and typesafe instruction representation, as well as several other changes
16:15:36 <ski_> DBAlex : don't use  '\tab'  , use  '\t'  for tab
16:15:54 <DBAlex> ski_: I do but ghc still screws it up
16:16:02 <ski_> @paste
16:16:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:16:59 <pumpkin_> although once I have the list of instructions completed, I'm probably going to preprocess it into a faster structure
16:17:52 <bombshelter13> Is I have a relation like 'x R y' where x and y could be, say, numbers, for one example, and R could be a relation like > | < | == | /=, is there a generic word to refer to the first and second elements in such a relation?
16:18:17 <defun> what has more precedence <$> or <*>?
16:18:31 <dcoutts> defun: ask ghci
16:18:34 <dcoutts> :info
16:18:41 <pumpkin_> they're the same
16:19:10 <defun> thanks
16:19:48 * ski_ finds this book's description of `foldr' as executing a "program / list of instructions" funny
16:19:59 <pumpkin_> which book?
16:20:33 <bolrod> @src foldr
16:20:33 <lambdabot> foldr f z []     = z
16:20:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:20:49 <ski_> pumpkin_ : "Sketches of an Elephant: A Topos Theory Compendium, Volume 2" by Peter T. Johnstone
16:20:54 <pumpkin_> :o
16:20:58 <pumpkin_> sounds scary :)
16:21:31 <ski_> it's more or less a brick book (or two)
16:21:59 <sciolizer> $420.48 on Amazon!
16:22:01 <shapr> emacs uses the C-h correspondence to prove itself helpful.
16:22:03 * ski_ is browsing it for fun and prof^Weducation
16:22:10 <pumpkin_> lol
16:23:44 <ski_> (shapr : you invoke the correspondence by `C-h c', eh ?)
16:26:35 <ski_> @djinn (forall a b. (a -> b) -> (f a -> f b)) -> (() -> f ()) -> (a -> f a)
16:26:35 <lambdabot> -- f cannot be realized.
16:26:38 <edwardk> did 'on' ever find its way into the prelude or a standard library somewhere?
16:26:44 <ski_> @index on
16:26:44 <lambdabot> bzzt
16:26:49 <pumpkin_> Data.Function
16:26:50 <pumpkin_> iirc
16:26:56 <edwardk> guess not ;)
16:27:02 <ski_> @djinn ((() -> a) -> (f () -> f a)) -> (() -> f ()) -> (a -> f a)
16:27:02 <lambdabot> f a b c = a (\ _ -> c) (b ())
16:27:10 <pumpkin_> edwardk: yup it did
16:27:15 <pumpkin_> in 6.10
16:27:56 <shapr> ski_: Yes exactly!
16:28:28 <ski_> shapr : so which side is the proof/proposition side, and which is the program/type side ?
16:29:39 <ski_> @djinn (forall a b. (a -> b) -> (f a -> f b)) -> (forall a b. (f a,f b) -> f (a,b)) -> (forall a b. f (a -> b) -> (f a -> f b))
16:29:40 <lambdabot> Error: kind error: (KVar 4,KStar)
16:29:47 <ski_> oh, that's a new one
16:30:50 <ddarius> @djinn a. -> a.
16:30:50 <lambdabot> f a = a
16:31:00 <mmorrow> pumpkin_: ooh, sounds sweet
16:31:07 * ski_ doesn't see a kind error, though
16:31:12 <ddarius> ski_: It's parsing forall as a type constructor applied to a, b., (a -> b)
16:31:22 <ski_> oh
16:31:42 <ski_> i thought it would parse `forall' right .. just refuse to work properly with it
16:32:07 <ddarius> It apparently doesn't even parse variables correctly.
16:33:19 <ski_> @djinn (((a -> b,a) -> b) -> (f (a -> b,a) -> f b)) -> ((f (a -> b),f a) -> f (a -> b,a)) -> (f (a -> b) -> (f a -> f b))
16:33:19 <lambdabot> f a b c d = a (\ (e, f) -> e f) (b (c, d))
16:38:50 --- topic: set to '#haskell moderators : http://haskell.org/haskellwiki/IRC_channel/Management - newest ops: roconnor, monochrom' by ChanServ
16:38:57 <glguy> :(
16:38:59 <glguy> oops :)
16:39:15 <roconnor> wrong chan
16:39:20 <glguy> anyone have the old topic handy?
16:39:37 <roconnor> ["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]
16:39:50 --- topic: set to '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by ChanServ
16:40:01 <ski_> @djinn (() -> f ()) -> (() -> f ())
16:40:01 <lambdabot> f a = a
16:40:08 <ski_> @djinn ((a -> b -> (a,b)) -> f (a -> b -> (a,b))) -> (f (a -> b -> (a,b)) -> (f a -> f (b -> (a,b)))) -> (f (b -> (a,b)) -> (f b -> f (a,b))) -> ((f a,f b) -> f (a,b))
16:40:09 <lambdabot> f a b c (d, e) = c (b (a (\ f g -> (f, g))) d) e
16:40:18 <ski_> hm
16:41:00 <psygnisfive> good god what are you DOING ski_
16:41:22 <psygnisfive> stop this noonsense at once!
16:41:27 * psygnisfive hits ski_ with a rolled up newspaper
16:42:00 <monochrom> That's an astonishing short proof of an astonishing theorem :)
16:42:11 <ski_> .. just trying to coerce poor lambdabot into my schemes
16:42:11 <monochrom> err, astonishing long theorem :)
16:42:57 * ski_ hits psygnisfive back with a rolled up `foldr'
16:43:07 <psygnisfive> >O
16:43:15 <roconnor> ski_: djinn doesn't do f (a -> b -> (a,b)) AFAIK
16:43:32 <ski_> it just did, above
16:43:36 <roconnor> @type f a b c (d, e) = c (b (a (\ f g -> (f, g))) d) e
16:43:37 <lambdabot> parse error on input `='
16:43:46 <roconnor> @type \a b c (d, e) -> c (b (a (\ f g -> (f, g))) d) e
16:43:47 <lambdabot> forall t t1 t2 t3 t4 t5 t6. ((t2 -> t3 -> (t2, t3)) -> t4) -> (t4 -> t -> t5) -> (t5 -> t1 -> t6) -> (t, t1) -> t6
16:43:59 <ski_> i'm pondering whether i can avoid using `return' in the proof ..
16:45:32 <McManiaC> anyone here using emacs?
16:45:47 <ski_> probably several
16:46:02 <McManiaC> ^^
16:46:37 <kerlo> @djinn a -> f a
16:46:37 <lambdabot> -- f cannot be realized.
16:46:42 <McManiaC> what command do i need to some "intelligent" indention? my current is totally stupid...
16:46:49 <Tobsan> are arrays considered unsafe?
16:46:55 <McManiaC> << emacs noob tho
16:47:00 <Tobsan> the ones in Data.Array
16:47:05 <Botje> McManiaC: use ctrl-j instead of enter to start a new lin
16:47:05 <Botje> e
16:47:10 <kerlo> @docs Data.Array
16:47:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
16:47:15 <ski_> kerlo : hm, maybe that's an idea .. if djinn likes polymorphic methods, i.e.
16:47:20 <Botje> there's a way to make enter behave like ctrl-j, but don't ask me how
16:47:24 <pumpkin_> I had a friend who had an eMac, and we used to have some at school, so I guess I used to use eMacs
16:48:15 <kerlo> Tobsan: if they were considered unsafe, surely the docs would say so somewhere.
16:48:24 <kerlo> Let me see if I can find an eMan.
16:48:55 <kerlo> Yep. There's an eMac over here.
16:48:57 <Tobsan> kerlo: because my program segfaults when i'm trying to create an array
16:49:05 <ski_> @djinn ((a -> b -> (a,b)) -> (f a -> f (b -> (a,b)))) -> (f (b -> (a,b)) -> (f b -> f (a,b))) -> ((f a,f b) -> f (a,b))
16:49:05 <lambdabot> f a b (c, d) = b (a (\ e f -> (e, f)) c) d
16:49:08 <ski_> yes !
16:49:10 <kerlo> Oh my.
16:49:36 <kerlo> Sounds like a bug, unless you're doing it with unsafeCoerce or something.
16:49:46 <Tobsan> well i'm not
16:49:55 <Tobsan> arr = array (0x8000, 0x7FFF) [(i,i) | i <- [0x8000..0x7FFF]]
16:50:02 <Tobsan> that is all that is done
16:50:10 * wli discovers he needs RankNTypes more often than expected.
16:50:23 <Tobsan> the entire program consists of the array being printed
16:50:23 <ski_> > [0x8000..0x7FFF]
16:50:25 <lambdabot>   []
16:50:31 <centrinia> I thought so.
16:50:31 <Tobsan> :x
16:51:00 <ski_> Tobsan : what is the index type ?
16:51:02 <centrinia> > array (2,1) [2,1]
16:51:03 <lambdabot>       No instance for (Num (t, e))
16:51:03 <lambdabot>        arising from the literal `2' at <in...
16:51:06 <Tobsan> ski_: Int16
16:51:25 <ski_> > [0x8000..0x7FFF] :: [Int16]
16:51:26 <lambdabot>   [-32768,-32767,-32766,-32765,-32764,-32763,-32762,-32761,-32760,-32759,-327...
16:51:45 <roconnor> Tobsan: what are you using to compile or interpret?
16:51:53 <Tobsan> roconnor: ghc --make
16:52:03 <roconnor> Tobsan: GHC had an array bug at some point, that I understand was fixed
16:52:08 <Tobsan> :o
16:52:09 <ski_> > array (2,1) [(i,i) | i <- [2,1]]
16:52:10 <lambdabot>   array * Exception: Error in array index
16:52:15 <lilac> > rangeSize (0x8000::Int16, 0x7FFF)
16:52:15 <roconnor> Tobsan: although you would need a "bad" Ix instance to hit the bug
16:52:16 <lambdabot>   65536
16:52:27 <ski_> > array (1,2) [(i,i) | i <- [1,2]]
16:52:28 <lambdabot>   array (1,2) [(1,1),(2,2)]
16:52:31 * roconnor wonders if the Ix Int16 instance is bad.
16:52:39 <lilac> > array (0x8000, 0x7FFF) [(i,i) | i <- [0x8000..0x7FFF]]
16:52:40 <lambdabot>   array (32768,32767) []
16:52:49 <lilac> > array (0x8000, 0x7FFF) [(i,i) | i <- [0x8000..0x7FFF::Int16]]
16:52:50 <lambdabot>   array (-32768,32767) [(-32768,-32768),(-32767,-32767),(-32766,-32766),(-327...
16:53:09 <Tobsan> ah, brb
16:53:16 <lilac> huh?
16:53:27 <centrinia> > array (0x8000::Int16,0x7fff) [ (i,i) | i <- [0x8000..0x7fff :: Int16]]
16:53:27 <lilac> @type array (0x8000, 0x7FFF) [(i,i) | i <- [0x8000..0x7FFF::Int16]]
16:53:28 <lambdabot>   array (-32768,32767) [(-32768,-32768),(-32767,-32767),(-32766,-32766),(-327...
16:53:28 <lambdabot> Array Int16 Int16
16:53:39 <Tobsan> the compilation was done on a remote computer...which would explain the error now
16:53:45 <lilac> umm wtf?
16:53:45 <roconnor> heh
16:53:46 <Tobsan> ghc --version
16:53:46 <Tobsan> The Glorious Glasgow Haskell Compilation System, version 6.4
16:53:48 <Tobsan> :/
16:53:52 <pumpkin_> wow
16:53:55 <pumpkin_> olde
16:54:09 <lilac> that is /broken/
16:54:12 <Tobsan> i suppose it would be fine if i did it on my laptop
16:54:18 * centrinia remembers using GHC 6.4 back when he started.
16:54:18 <Tobsan> which has ghc 6.10.1
16:54:21 <lilac> correction: i need sleep
16:54:28 <Tobsan> how old is 6.4?
16:54:41 <roconnor> that seems old enough to have the bug.  Now all we need is a bad Ix instance.  ... unless the problem is moving an executable across machines.
16:54:51 <centrinia> Was it around in 2006?
16:55:05 <ski_> @when 6.4
16:55:05 <lambdabot> Maybe you meant: seen what where wn
16:55:14 <centrinia> @where ghc
16:55:14 <lambdabot> http://haskell.org/ghc
16:56:08 <centrinia> Now I remember, I was starting to learn Haskell in the Fall of 2006.
16:56:32 <centrinia> GHC 6.6 was released a little after I started. :>
16:56:36 <Tobsan> centrinia: cool, me too!
16:57:16 * wli started right before H98 happened.
16:57:22 <edwardk> @tell bos that text module rocks
16:57:22 <lambdabot> Consider it noted.
16:57:22 <centrinia> My first Haskell program computed Fibonacci numbers.
16:57:28 <roconnor> http://article.gmane.org/gmane.comp.lang.haskell.libraries/5903/
16:57:40 <roconnor> Subject: The Data.Array.* hierarchy is unsafe (or, Segfaulting for fun and profit)
16:57:55 <roconnor> ``
16:57:56 <roconnor> The issue is that the array operators trust the Ix instance to manage
16:57:58 <roconnor> boundaries correctly.  The solution is to double check the value
16:57:59 <roconnor> returned by index with the actual length of the array.
16:58:02 <wli> I don't remember my first Haskell program.
16:58:10 <pumpkin_> I'm a post 6.10-er
16:58:22 <roconnor> AFAIK this was fixed sometime, probably in GHC 6.8 or GHC 6.10
16:58:23 <centrinia> Is anyone a Goferer?
16:58:32 <pumpkin_> I look forward to looking back on the "good ol' 6.10 days"
16:58:37 <pumpkin_> when we're at GHC 7
16:58:40 <Tobsan> roconnor: good, then I can sleep safe (hoho)
16:58:49 <wli> ISTR actually using Gofer at some point.
16:59:30 <centrinia> Gofer is old school. :)
16:59:56 <centrinia> pumpkin, when did you start using Haskell?
17:00:00 <dons> centrinia: i seriously hope not :)
17:00:18 <pumpkin_> I started working on it seriously on december 5th or something last year
17:00:20 <centrinia> Does anyone still use Gofer?
17:00:32 <pumpkin_> before then I'd just fooled around with it because my gf was taking a haskell course
17:00:54 <centrinia> What are you seriously doing now?
17:01:17 <pumpkin_> well, by seriously, I meant an actual effort to learn it
17:01:24 <wli> My first Haskell experiences were ca. 1997-1998, though I primarily used ocaml and sml for some time after that.
17:01:34 <wli> As FP languages, anyway.
17:01:48 <wli> I've always been primarily a C programmer.
17:01:51 <pumpkin_> centrinia: but I'm mostly doing machine learning stuff in it these days
17:02:05 * roconnor tries to find evidence that this bug was fixed in GHC
17:02:27 <wli> Not even C++ or Java, but plain old C.
17:02:36 <pumpkin_> I prefer c to either of those
17:02:41 * centrinia tries to invoke the bug.
17:03:50 <pumpkin_> centrinia: what do you do with it?
17:04:02 <pumpkin_> it'd be nice to create a "haskell experiences page" of what people like to do with their haskell
17:04:47 <dons> that's what i was trying to do with the library tag cloud
17:04:57 <pumpkin_> yeah :)
17:04:59 <dons> ?go what is haskell good for?
17:05:00 <lambdabot> http://donsbot.wordpress.com/2009/01/24/what-is-haskell-good-for/
17:05:00 <lambdabot> Title: What is Haskell good for? « Control.Monad.Writer
17:05:04 <dons> good hit.
17:05:37 <centrinia> pumpkin, I haven't used Haskell in a while. I used to just make parsers for static data formats in the past.
17:05:53 <pumpkin_> but a collection of little stories from various people about what they individually like to do with it
17:06:02 <pumpkin_> would also be interesting, I think :) but would require more participation
17:06:11 <centrinia> Okay, it appears that the array implementation doesn't trust Ix instances as much anymore. :)
17:06:15 <pumpkin_> centrinia: omg noes, don't stop using haskell!
17:06:23 <centrinia> pumpkin, I won't.
17:06:33 <centrinia> I just used it less.
17:07:09 <ddarius> @google what is haskell bad for?
17:07:10 <lambdabot> http://scienceblogs.com/goodmath/goodmath/programming/haskell/
17:07:10 <lambdabot> Title: Good Math, Bad Math
17:08:20 * centrinia wonders where else the runtime gives too much trust in typeclass instances. Hmm.
17:08:27 <dons> i believe markCC proposed that it was bad for concurrency.
17:08:40 <dons> which i don't think is plausible.
17:08:48 <pumpkin_> that seems like a weird one to choose as a "bad"
17:08:53 <ski_> (is `markCC' some prompt marking continuation operation ?)
17:08:58 <ski_> @hoogle markCC
17:08:58 <lambdabot> No results found
17:09:02 <dons> hehe. no, but he did start using xmonad  this weekend
17:09:08 <lilac> haskell is bad for writing programs which don't leak space ever ;-)
17:09:26 <dons> tell that to the xmonad team
17:09:34 <centrinia> pumpkin: http://donsbot.wordpress.com/2009/02/22/can-haskell-give-me-a-pony/ :O
17:09:41 <pumpkin_> lol
17:09:51 <pumpkin_> my fame in the haskell community :(
17:10:02 <lilac> dons: not saying it's impossible, just harder than in a language with, say, linear typing
17:10:08 <dons> hah.
17:10:30 <ddarius> lilac: Also harder than in a language without allocation.
17:10:36 <pumpkin_> one day I'll be known for something else around here
17:10:45 <lilac> ddarius: more importantly, it's harder than in a strict language, IMO
17:10:55 <pumpkin_> probably as the dude who talks about StrictAnal on the GHC bugtracker
17:11:08 <dons> space leaks in strict languages are time leaks
17:11:14 <ddarius> "pumpkin: Known for StrictAnal"
17:11:17 <dons> yep.
17:11:23 <centrinia> That doesn't sound right.
17:11:24 <dons> pumpkin_: you really had to bring this module name issue up, eh?
17:11:25 <pumpkin_> strictanal and ponies
17:11:39 <dons> we've been happily ignoring the odd naming convention for aa while now. :)
17:11:42 <lilac> dons: really?
17:12:06 <pejo> dons, "time leaks"?
17:12:13 <dons> things not terminating.
17:12:17 <dons> > head [1..] --
17:12:19 <lambdabot>   1
17:12:19 <pumpkin_> dons: well, as I was compiling GHC it came across my screen and I happened to notice it, so I chuckled and mentioned it :) then philippa encouraged me to submit at ticket :)
17:12:37 <dons> or copying O(n) data around instead of suspending and running in constant space
17:12:41 <rovar> i'm using the Text.JSON library and I'm tring to do:  deriving (Typeable, Data) on my two objects and am getting
17:12:51 <rovar> src/AppState.hs:17:2:
17:12:52 <lilac> dons: let f x = let (huge, tiny) = g x in tiny; [f 1, f 2, f 3]
17:12:53 <rovar>     Overlapping instances for Typeable GuestBook
17:12:54 <rovar>       arising from the 'deriving' clause of a data type declaration
17:12:56 <rovar>                    at src/AppState.hs:17:2-38
17:12:57 <rovar>     Matching instances:
17:12:59 <rovar>       instance Typeable GuestBook -- Defined at src/AppState.hs:17:2-38
17:13:00 <rovar>       instance Typeable GuestBook -- Defined at src/AppState.hs:17:2-38
17:13:02 <rovar>     When deriving the instance for (Data GuestBook)
17:13:03 <lilac> dons: or something like that
17:13:18 * lilac fails at constructing example
17:13:25 <rovar> why is it executing instance Typeable GuestBook twice?
17:14:40 <rovar> ah.. i think it might have something to do with  $(deriveAll [''Show, ''Eq, ''Ord] model)
17:15:42 <gwern> slow upload to c.h.o drives me mad when uploading 30meg executables...
17:15:51 <gwern> @quote ddarius
17:15:51 <lambdabot> ddarius says: "pumpkin: Known for StrictAnal"
17:15:58 <shapr> 30mb executables?
17:15:59 <pumpkin_> lol
17:16:05 <pumpkin_> and ponies
17:16:12 <gwern> shapr: gitit links in a *lot*
17:16:17 <lilac> dons: how about "let x = hugeList in (last x, head x)" (suppose snd is forced first) -- point is, it's much more obvious when you leak like this in a strict language
17:16:20 <pumpkin_> is there a darcs blame?
17:16:25 <gwern> shapr: pandoc, ghc, happs...[30 other libraries]
17:16:26 <pumpkin_> I want to see who created that file
17:16:27 <shapr> Wasn't there some work towards split libraries?
17:16:30 <gwern> pumpkin_: nah, this is just scp
17:16:39 <shapr> gwern: 7zip the binary?
17:16:42 <pumpkin_> ?
17:16:44 <lilac> s/snd/fst/
17:16:48 <gwern> does c.h.o even have 7zip?
17:17:06 <SamB> gwern: rsynch maye ?
17:17:21 <gwern> doubt rsync on a binary would help much
17:17:23 <SamB> er. rsync, sorry, I can't even misspell propery
17:17:42 <SamB> well, it might compress or something
17:17:46 <gwern> popery? HERETIC
17:17:56 <gwern> burn the papist!
17:18:02 <SamB> almost anything's got to be faster than scp ;-P
17:18:22 <gwern> ...doesn't rsync go over scp?
17:18:32 <roconnor> scp -C
17:18:33 <pumpkin_> it can go over ssh
17:18:37 <SamB> no, it just goes over ssh
17:18:42 <SamB> but it's not nearly as stupid as scp
17:19:09 <gwern> (oh the irony. gzip got it done to 5.6meg, but now my upload speed has dropped to 6 kb/sec)
17:19:12 <pumpkin_> what annoys me about scp is that I need to double up my backslashes when I need to escape a character in the path
17:19:48 <monochrom> Yeah escaping is evil.
17:20:10 <lilac> pumpkin_: i believe you can mount scp over fuse
17:20:21 <pumpkin_> I use sshfs sometimes
17:21:05 <gwern> (woo 22kb/s)
17:21:09 <monochrom> sshfs is indeed scp over fuse
17:21:20 <pumpkin_> yup
17:21:21 <jberryman> how would I create a set of quickCheck tests based on some seed, so that I can benchmark different versions of my code with the same set of random data?
17:21:48 <SamB> I like rsync because it doesn't need me to retype my password since it re-uses the same link for all files transferred
17:21:55 <shapr> jberryman: http://www.scannedinavian.com/~shae/qc-tdd.tgz
17:22:07 <shapr> jberryman: But you'll need to make a few changes.
17:22:38 <ispiked> I can't figure out this error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1954#a1954
17:23:05 <ispiked> findP's signature is very similar
17:23:08 <ispiked> but it doesn't complain
17:23:33 <pumpkin_> SamB: eww, password auth :P
17:23:36 <ispiked> oops, I cut off some of convexHull
17:24:18 <ski_> ispiked : better use `compare' in `pointCmp'
17:24:20 <ispiked> ok, fixed
17:24:40 <ski_> (or even `instance Monoid Ordering')
17:25:13 <SamB> pumpkin: well, I guess it also saves roundtrips if you want a less evil excuse ;-P
17:25:23 <pumpkin_> :D
17:25:25 <pumpkin_> that's better
17:25:36 <ispiked> ski_: ok. any ideas about the error?
17:25:44 <ski_>   pointCmp (x0,y0) (x1,y1) = (y0 `compare` y1) `mappend` (x0 `compare` x1)
17:25:44 <monochrom> tanToX returns single number (not pair), but is used to build list of pairs.
17:26:02 <monochrom> "a = (a,a)" says it all, really.
17:26:27 <ispiked> monochrom: oh, true
17:26:44 <SamB> I *do* need to use password authentication a lot since I have no way of reliably carrying around my key, but I don't usually run rsync from the windows clients I tend to use anyway, so I guess that's not really much of an excuse ...
17:27:08 <SamB> (never mind carrying a key around securely!)
17:27:15 <ispiked> monochrom: thanks
17:27:28 <SamB> now, I know someone will recommend a USB key ...
17:27:48 * SamB waits for it
17:28:06 <monochrom> nothing wrong with usb key
17:28:14 <SamB> well, not for most people
17:28:23 <SamB> but the thing is I *will* lose it
17:28:44 <monochrom> Don't put plaintext on it.
17:29:01 <SamB> I was talking about the "reliable" bit
17:29:12 <pumpkin_> put it on your keychain
17:29:17 <SamB> hmm.
17:29:17 <Saizan> write your IP on it, so that they can send it back to you
17:29:27 <monochrom> You can't remember a password?
17:29:28 <SamB> wouldn't I just lose my keys then too ?
17:29:30 <pumpkin_> and use a secure usb key for key storage
17:29:38 <pumpkin_> rather than a regular file storage usb key
17:29:38 <SamB> Saizan: what, by email ?
17:29:44 <pumpkin_> "a token"
17:30:02 <SamB> monochrom: I can!
17:30:15 <ispiked> ski_: can you explain how mappend works?
17:30:23 <SamB> pumpkin: those are even more expensive to lose than regular ones!
17:30:29 * pumpkin_ makes the shape of a monoid in the air
17:30:41 * pumpkin_ picks two elements from the monoid he drew
17:30:45 * pumpkin_ sticks them together
17:30:46 <monochrom> Memerize a master password to decrypt encrypted files on usb key. You can lose the usb key now. Bring several such usb keys.
17:30:55 <pumpkin_> SamB: they're not too bad
17:31:07 <SamB> monochrom: I don't think I can afford that
17:31:16 <pumpkin_> I'll let you wonder what the shape of a monoid looks like
17:31:27 <ski_>   LT `mappend` _ = LT
17:31:30 <ski_>   GT `mappend` _ = GT
17:31:32 <ski_>   EQ `mappend` c = c
17:31:40 <jberryman> shapr: thanks. btw, can 'variant' be used to supply a seed that will produce the same results each time?
17:31:43 <monochrom> Can't afford, in the money sense?
17:31:50 <ski_> would be the instance of `mappend' for `instance Monoid Ordering'
17:31:54 <SamB> monochrom: yeah
17:32:06 <monochrom> Alright, cool.
17:33:11 <ispiked> ski_: how do I get an instance of that?
17:33:28 <ski_> (ispiked : however .. if you flipped your pairs around, you could probably use `minimum' directly, instead of `minimumBy')
17:34:25 <ski_> ispiked : probably the `instance Monoid Ordering' is in `Data.Monoid'
17:34:28 <ski_> try importing that
17:36:01 <mmorrow> SamB: you only need like a 1MB usb key for your key
17:36:19 <mmorrow> i'd say smaller, but i don't think even 1MB usb keys exists
17:36:26 <ispiked> ski_: thanks
17:36:55 <ski_> ispiked : for other fun stuff about `instance Monoid Ordering', see <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> by Cale
17:37:08 <mmorrow> SamB: just use LUKS on it, then stick your key in there
17:38:38 <ispiked> ski_: thanks, I'll check it out
17:39:00 <mmorrow> (so you'll have a passwd which decrypts your luks key which decrypts the usb key which holds your whatever key ;)
17:39:05 <monochrom> The problem with "hardware is cheap!" is that only the ratio is cheap. The minimum expense is ridiculously high.
17:39:46 <mmorrow> i think 4MB usb keys come in McDonalds(r) happy meals
17:39:47 * roconnor caries a usb key on his keychain
17:39:57 <roconnor> my computer won't boot without my USB key and password
17:40:15 <monochrom> Haha you're making it like a car.
17:40:21 <roconnor> yep
17:40:37 * p_l needs to add memory encryption to suspend-to-ram
17:40:38 <mmorrow> roconnor: do you make a car-turning-on-noise with your mouth when you boot?
17:40:43 <chessguy> monochrom:  your car has a password?
17:40:46 <roconnor> mmorrow: sometimes
17:40:50 <mmorrow> roconnor: nice!
17:41:08 <roconnor> p_l: ya, I use suspend to ram a lot, which only does xlock
17:41:09 <monochrom> "like"
17:41:15 <SamB> what's the cheapest price for a USB key anyway ?
17:41:19 <centrinia> Who uses a key ignition system for their computers?
17:41:48 <ac> eagles: ...
17:41:50 <roconnor> SamB: probably free
17:41:58 <centrinia> roconnor: It could be less.
17:42:01 <SamB> free with what ?
17:42:06 <roconnor> SamB: if you fill out someone's stupid survey
17:42:08 * monochrom doesn't understand the logic behind reading "like" and interpreting as "same".
17:42:10 <roconnor> or something like that
17:42:27 <roconnor> SamB: I got a free key for going to the SCSS conference
17:42:35 <SamB> centrinia: people will PAY me to take a key ?
17:42:42 <centrinia> Possibly.
17:42:44 <SamB> roconnor: didn't they charge admission ?
17:42:48 <roconnor> SamB: possibly
17:42:56 <monochrom> The cheapest price of USB key I saw recently is about $10 CAD.
17:43:06 <roconnor> I got a free key for entering a real number software implementation contest
17:43:26 <SamB> that's not free!
17:43:34 <roconnor> and then my last key I bought like 5 years ago.
17:43:37 <chessguy> @quote
17:43:38 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
17:43:52 <roconnor> but I bet you can get a free USB key somehow
17:43:58 <roconnor> they are soooo cheap
17:44:14 <roconnor> people like putting logos on them and giving them away
17:44:34 <monochrom> It requires networking. Social networking.
17:44:40 <mmorrow> SamB: 32MB (couldn't find anything smaller) http://cgi.ebay.com/NEW-USB-Flash-Drive-32MB-hi-speed_W0QQitemZ360135024869QQcmdZViewItemQQptZUK_Computing_FlashDrives_SM?hash=item360135024869
17:44:43 <mmorrow> 	GBP 1.99
17:44:47 <mmorrow> wow
17:44:51 <centrinia> Oh, some companies sell software with the USB keys as the medium.
17:44:52 <roconnor> wow 32MB
17:45:03 * centrinia has a 32MB SD card.
17:45:12 <roconnor> that is much smaller than the free USB keys I have
17:45:28 <roconnor> heh
17:45:37 <roconnor> starting bid Approximately US $2.84
17:45:50 <mmorrow> the only place to get anything smaller than 512MB seems to be on ebay or for free
17:46:01 <edwardk> @hpaste
17:46:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:46:50 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/new seems to be the new paste url
17:47:42 <mmorrow> err
17:48:05 <mmorrow> rwbarton suggested i set that to point to the new one
17:48:08 * mmorrow does that
17:49:10 <Twey> Why can't we replace the old with the new?
17:49:20 <Twey> What does hpaste2 use for storage?
17:49:34 <pumpkin_> whee, I have most memory accesses encoded correctly now too
17:49:44 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1956#a1956
17:50:03 <SamB> what's with the long urls anyway ?
17:50:05 <edwardk> what am i missing? that seems to keep resetting the state. each constructor should get a new id. (hence fresh)
17:50:21 <pumpkin_> yeah, a rewrite rule or two on hpaste would be nice
17:50:24 <edwardk> but when you run it, they both get 0
17:50:48 <SamB> pumpkin: wouldn't you just end up at the long url again if it was that thin a layer ?
17:50:49 * shapr hugs edwardk
17:51:00 <edwardk> heya shapr
17:51:03 <pumpkin_> SamB: rewrite rules don't have to redirec
17:51:04 <shapr> hiya edwardk!
17:51:06 <edwardk> don't want a hug, i want a fix ;)
17:51:09 <shapr> :-P
17:51:12 <pumpkin_> they just rewrite the url before processing it
17:51:15 <SamB> pumpkin: but when you clicked on the next ink
17:51:18 <SamB> er. link
17:51:32 <pumpkin_> SamB: well, the internal links could be updated to reflect the rewrites too
17:51:48 <shapr> edwardk: write a QC test? ;-)
17:51:53 <SamB> do you even need mod_rewrite in the first place ?
17:52:58 <mmorrow> @haspte
17:52:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:53:01 <mmorrow> works
17:54:18 <SamB> preview doesn't
17:54:22 <mmorrow> hmm, so how would that be done
17:54:28 <SamB> nor does save ...
17:54:30 <mmorrow> yeah, i only did /new
17:54:33 <mmorrow> sigh
17:54:40 <edwardk> i'm rather completely baffled by why i'm not getting my updated state. i can check with unsafePerformIO and it updates it briefly, but something happens and then it forgets it
17:54:50 <edwardk> maybe i don't understand how state and parsec interact
17:55:40 <edwardk> i had originally tried using it with parsec's internal 'user state' but that gave me the same problem
17:56:24 <Saizan> weird MonadState instance, probably
17:56:25 <monochrom> That is odd. Parsec user state works.
17:56:35 <ac> has anybody gotten chalkboard working?
17:57:03 <edwardk> monochrom: it seems like it should anyways.
17:57:20 <edwardk> monochrom: noto bene, i'm using parsec 3, but i doubt there would be a breaking change of this magnitude
17:57:41 <edwardk> so i presume the error is in my code
17:59:40 <pumpkin_> is there a simple symbolic math package for haskell? I just need to be able to store expressions in terms of a couple of variables, and simplify basic arithmetic of numbers
18:00:37 <edwardk> pumpkin: lennart blogged something a while back, and i suppose you can use the Expr thing.
18:00:45 <pumpkin_> the simple-reflect?
18:00:48 <edwardk> yeah
18:01:08 <mmorrow> SamB: ok, i think i got all of the hpaste api wired to hpaste.org/whatever
18:01:09 <edwardk> > x + y
18:01:09 <pumpkin_> I guess I could remove all the predefined variables, which I don't need
18:01:10 <lambdabot>   x + y
18:01:20 <edwardk> looks like symbolics to me ;)
18:01:41 <pumpkin_> > 1 + 2 + x + y -- I want this to be 3 + x + y
18:01:43 <lambdabot>   1 + 2 + x + y
18:01:45 <pumpkin_> :P
18:01:51 <edwardk> thats where you have to write the simplifier ;)
18:02:01 <centrinia> > 1+2
18:02:02 <lambdabot>   3
18:02:11 <centrinia> > (1+2)+x+y
18:02:12 <lambdabot>   1 + 2 + x + y
18:02:15 <centrinia> Damn.
18:02:24 <edwardk> > fromIntegral (1 + 2) + x + y
18:02:25 <lambdabot>   3 + x + y
18:02:51 <centrinia> > fromIntegral $ (1+2)+x+y
18:02:52 <lambdabot>   * Exception: not a number
18:02:59 <edwardk> @type x
18:03:00 <lambdabot> Expr
18:03:07 <edwardk> @type fromIntegral
18:03:07 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:03:14 <pumpkin_> that sounds like something someone wrote in by hand in the Num instance of Expr
18:03:35 <mmorrow> > fix error
18:03:36 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:03:44 <centrinia> That's mean.
18:04:02 <Axman6> bleh, converting from decimal to IEEE 32 bit floating point sucks -_-
18:04:27 <edwardk> http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html
18:04:50 <edwardk> at least does constant folding, etc.
18:09:13 <pumpkin_> edwardk: thanks, looks good
18:09:23 <pumpkin_> now to find part 2 :P
18:09:47 <chessguy_> @bot
18:09:47 <lambdabot> :)
18:09:47 <lunabot>  :)
18:11:34 <ispiked> I want to use sortBy to sort a list, but I need to modify each pair of elements to be compared
18:11:56 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1956#a1959 i included the output. note that both constructors show up as C 0 ...
18:11:57 <ispiked> I am trying something like sortBy (compare (+1) (+1)) [2,1]
18:12:01 <ispiked> but that's not working
18:12:13 <chessguy> i don't think you can use sortBy for that
18:12:27 <ispiked> chessguy: so I have to write my own sort function?
18:12:44 <chessguy> well...it's not really a sort function if you're modifying the list as you go
18:12:44 <edwardk> @type on
18:12:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:13:01 <edwardk> > sortBy (compare `on` (+1)) [2,1]
18:13:02 <monochrom> modify?
18:13:02 <lambdabot>   [1,2]
18:13:20 <edwardk> which is kinda silly
18:13:40 <chessguy> or are you only calling the function on the elements for the sake of the comparison and then throwing the result away?
18:13:46 <ispiked> well, I'm doing something more complex than (+1)
18:13:57 <ski_> @type fix $ liftM (const ()) . Control.Concurrent.forkIO
18:13:58 <lambdabot> IO ()
18:14:06 <ispiked> chessguy: yes
18:14:11 <monochrom> Please show an example of input and correct output.
18:14:17 <edwardk> sortBy (compare `on` crazyModificrationProcess)
18:14:20 <chessguy> monochrom: good call
18:14:30 <ispiked> who are you speaking to?
18:14:34 <edwardk> on (*) f x y = f x * f y
18:14:35 <ispiked> monochrom:
18:14:37 <monochrom> Mr. Speaker.
18:14:43 <chessguy> @type sortBy (compare `on` ?modifierFunc)
18:14:44 <lambdabot> forall b a. (?modifierFunc::a -> b, Ord b) => [a] -> [a]
18:14:52 <pumpkin_> on is in Data.Function
18:15:01 <pumpkin_> on 6.10
18:15:09 <edwardk> chessguy: neat trick with the implicit param to extract typing =)
18:15:11 <pumpkin_> there's also comparing in Data.Ord
18:15:23 <roconnor> the chair recongnizes monochrom from toronto
18:15:26 <chessguy> edwardk:  old trick :)
18:15:35 <SamB> the chair is overintelligent!
18:15:44 <monochrom> Heh
18:15:47 <roconnor> SamB you are out of order
18:15:47 <SamB> we better get that fixed
18:15:53 <chessguy> SamB:  the chair can't even spell 'recognizes'
18:15:58 <ispiked> where is `on` located?
18:16:03 * edwardk doesn't want the chair to recognize me, only to let me sit in it.
18:16:06 <pumpkin_> Data.Function :P
18:16:20 <SamB> chessguy: even a chair that can misspell is too intelligent!
18:16:27 * monochrom wishes to talk to the chair
18:16:51 <chessguy> monochrom:  don't be silly, the chair wooden talk to you....
18:16:53 <roconnor> monochrom: sorry, you may only talk to the hand
18:16:57 <edwardk> i mean, it'd be kinda cool if it was smart enough to go grab me a beer from the fridge or something, but then, where would I sit?
18:16:57 <chessguy> (rim shot)
18:17:05 <roconnor> chessguy++
18:17:07 <monochrom> haha
18:17:37 <chessguy> sorry, i'm in a silly mood :)
18:17:55 <Twey> ispiked: Data.Function in GHC
18:17:56 <chessguy> i think i'm entitled -- it's my anniversary!
18:18:04 <Twey> In others you might have to reimplement
18:18:08 <Twey> chessguy: Congrats!
18:18:12 <Twey> First one?
18:18:25 <chessguy> indeed
18:18:48 <roconnor> pft, you probably aren't the only one in here with an anniversary today.
18:20:13 <chessguy> maybe not
18:20:21 <roconnor> still
18:20:22 <roconnor> :)
18:20:28 <roconnor> \o/
18:20:45 <ispiked> this is what I'm working on btw: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1960#a1960
18:20:48 <SamB> anniversary of what ?
18:20:55 <pumpkin_> marrying haskell?
18:21:29 <chessguy> SamB:  the smartest decision i ever made, marrying my wife :)
18:22:00 <monochrom> I guess picking up Haskell is the second smartest.
18:22:06 <Twey> chessguy: Awesome :)
18:22:49 <sykopomp> maybe I should just join at this point
18:23:24 <pumpkin_> join sykopomp
18:23:48 <mmorrow> @pl (.)
18:23:48 <lambdabot> (.)
18:23:58 <pumpkin_> > join sykopomp
18:23:59 <lambdabot>   "yay"
18:24:28 <mmorrow> > help
18:24:29 <lambdabot>   Segmentation fault
18:24:41 <chessguy> yikes
18:24:41 <pumpkin_> haskell fails
18:24:45 * pumpkin_ goes and learns VB
18:24:46 <chessguy> @list
18:24:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:24:48 <sykopomp> haha
18:24:50 <chessguy> > help
18:24:51 <lambdabot>   Segmentation fault
18:24:59 <pumpkin_>  @
18:25:08 <chessguy> @type help
18:25:09 <lambdabot> Doc
18:25:09 <pumpkin_>  @let help = text "Segmentation fault"
18:25:24 <mmorrow> chessguy: ok ok, you got me
18:25:30 <chessguy> cute
18:25:33 <chessguy> mmorrow:  eh?
18:25:34 <mmorrow> ;)
18:26:01 <pumpkin_> we need mmorrow on twitter
18:26:03 <chessguy> mmorrow:  wasn't me
18:26:06 * pumpkin_ applies peer pressure
18:26:22 <chessguy> pumpkin:  nah, only the cool kids are on twitter (hint, hint)
18:26:24 <mmorrow> chessguyL (re: @let help = text "Segmentation fault")
18:26:33 <chessguy> mmorrow:  yeah, twasn't me
18:26:41 <mmorrow> chessguy: it was me :)
18:26:51 <chessguy> oh!
18:27:00 * pumpkin_ is actually just mmorrow's bot
18:27:09 * pumpkin_ is a more advanced form of Luna
18:27:15 <mmorrow> pumpkin_: i'll manage twitter one of these days maybe
18:27:17 <edwardk> aha, it was my fault as expected =)
18:27:26 <chessguy> pumpkin_:  not much more advanced...
18:27:34 <edwardk> i was grabbing the environment before calling fresh, then restoring it
18:27:44 <pumpkin_> I'm advanced enough to have feelings, you insensitive clod :(
18:28:57 * chessguy giggles a bit
18:29:26 <edwardk> pumpkin: this explains a lot
18:29:46 <pumpkin_> my inappropriate sense of humor regarding StrictAnal? that's all mmorrow's doing
18:30:09 * Axman6 thought that was his fault
18:31:08 <pumpkin_> nope sorry
18:31:24 <Axman6> lame
18:40:22 <pumpkin_> http://www.youtube.com/watch?v=9fohXBj2UEI is really clear
18:46:00 <ispiked> is there any way to get an item's index inside a list comprehension?
18:46:32 <roconnor> (i,x) <- zipWith [0..] xs
18:46:44 <roconnor> er
18:46:46 <roconnor> just zip
18:46:58 <ispiked> ok
18:47:21 <ispiked> thanks
18:47:41 <wolverian> or, with a GHC extension, [ ... | x <- xs | i <- [0..] ]
18:51:07 <lispy> > [ (x,y,z) | x <- [1..3] | y <- "abc" | z <- [7..10]]
18:51:08 <lambdabot>   [(1,'a',7),(2,'b',8),(3,'c',9)]
18:57:16 <TomMD> Why oh why does the pretty package not have hex?
18:57:24 <TomMD> grrr
19:03:42 <ispiked> are there no nice ways to avoid divide by 0 exceptions besides to use Fractional (where you get Infinity)
19:03:45 <ispiked> ?
19:04:14 <roconnor> dividing by 0 doesn't raise an exception
19:04:18 <roconnor> > 1/0
19:04:19 <lambdabot>   Infinity
19:04:23 <ispiked> sorry
19:04:26 <ispiked> I meant (/)
19:04:30 <ispiked> er
19:04:33 <roconnor> > (/) 1 0
19:04:34 <lambdabot>   Infinity
19:04:35 <ispiked> I meant the div
19:04:38 <roconnor> oh
19:04:48 <ispiked> integral division
19:04:53 <pumpkin_> > 1 `div` 0
19:04:54 <lambdabot>   * Exception: divide by zero
19:04:56 <pumpkin_> BAM
19:04:56 <roconnor> right
19:05:04 <roconnor> nothing can be done about that
19:05:10 <roconnor> except checking for 0
19:05:12 <ispiked> infinity is nice since it sorts correctly
19:05:39 <sw17ch> > [1..Infinity]
19:05:39 <lambdabot>   Not in scope: data constructor `Infinity'
19:05:42 <sw17ch> :(
19:05:48 <ispiked> even if I check for 0, I'm going to have to assign it some arbitrarily large value so it is greater than all the other elements
19:05:50 <whoppix> > [1..Inf]
19:05:51 <lambdabot>   Not in scope: data constructor `Inf'
19:05:59 <whoppix> huh.
19:06:00 <dolio> > sort [0,1,0/0,1/0,-1/0]
19:06:02 <lambdabot>   [-Infinity,0.0,1.0,Infinity,NaN]
19:06:02 <roconnor> ispiked: you can make a new datatype
19:06:04 <ispiked> > [1..]
19:06:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:06:07 <dolio> > sort $ sort [0,1,0/0,1/0,-1/0]
19:06:08 <lambdabot>   [NaN,-Infinity,0.0,1.0,Infinity]
19:06:19 <sw17ch> > [1,2..(1/0)]
19:06:20 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
19:06:23 <sw17ch> woot
19:06:38 <Saizan> > floot (1/0)
19:06:39 <lambdabot>   Not in scope: `floot'
19:06:42 <Saizan> > floor (1/0)
19:06:44 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
19:06:53 <ispiked> roconnor: oh...
19:07:06 <ispiked> roconnor: how can I use Infinity in it?
19:07:08 <whoppix> Saizan, that is interesting.
19:07:26 <roconnor> data WithInfinity a = NotInfinity a | Infinity
19:07:45 <roconnor> deriving (Eq,Ord)
19:07:51 <ispiked> roconnor: and sortBy will know about Infinity?
19:07:59 <roconnor> sort will
19:08:03 <ispiked> roconnor: or rather WithInfinity :S
19:08:14 <ispiked> no, I guess it's Infinity
19:08:53 <Saizan> you can also write an instance of Num for it
19:09:16 <Saizan> (maybe you want NegativeInfinity too?)
19:09:27 <pumpkin_> we need a floot function
19:09:27 <whoppix> Saizan, do you mind explaining why floor() actually returns some value for infinity?
19:09:29 <pumpkin_> it's a cute name
19:09:45 <whoppix> that doesn't really make sense to me.
19:09:52 <gilbert> hi guys...
19:10:23 <gilbert> i'm on Ubuntu Hardy; trying to import module "Text.Regex.Posix", but ghci says module says module not found
19:10:28 <Saizan> whoppix: a bug, i'd say
19:10:29 <solidsnack> pumpkin_: what is floot ?
19:10:43 <pumpkin_> I don't know, but I bet it's pretty awesome with a name like that
19:10:50 <solidsnack> gilbert: can you tell us what GHC you have?
19:11:01 <Saizan> whoppix: though i'm not sure if an exception is much better
19:11:09 <gilbert> solidsnack: i'm using ghci 6.8.2
19:11:22 <whoppix> Saizan, does Infinity classify as Int/Num/whatever?
19:11:36 <Saizan> > 1/0 :: Double
19:11:37 <lambdabot>   Infinity
19:12:10 <Saizan> it's how the Show instance represents that value
19:12:14 <solidsnack> the Posix regexen were part of the standard library back then, i think
19:12:18 <whoppix> hm.
19:12:28 <Saizan> infinity is in the IEEE 754 standard
19:12:50 <gilbert> hmm, i didn't know 6.8.2 is an old version
19:12:51 <solidsnack> anywho
19:12:57 <solidsnack> yes
19:13:21 <Saizan> gilbert: do you have a libghc6-regex-posix-dev package?
19:13:44 <Saizan> ?hackage regex-posix
19:13:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-posix
19:13:48 <solidsnack> gilbert: i am not sure why it is not working for you
19:14:00 <Saizan> otherwise you can install it from hackage ^^^
19:14:05 <solidsnack> gilbert: you could try installing it -- with cabal install or by hand
19:14:08 <gilbert> i don't have libghc-6-regex-posix-dev
19:14:11 <gilbert> gonna try installing it now
19:14:24 <gilbert> icic
19:15:52 <gilbert> okay, after the libghc-6-regex-posix-dev instllation
19:15:53 <gilbert> it works now
19:15:55 <gilbert> thx everyone!
19:16:13 <gilbert> i've just gotten the impression that (after some google search)
19:16:20 <gilbert> that there's a big difference b/t 6.10 and 6.8
19:16:38 <gilbert> should i just try to build and compile 6.10 for future conveniences?
19:17:13 <solidsnack> gilbert: you don't need to build it
19:17:22 <solidsnack> gilbert: just download the linux binary
19:18:20 <solidsnack> http://www.haskell.org/ghc/download_ghc_6_10_1.html#binaries
19:18:37 <solidsnack> however, you must rebuild all your libraries
19:19:52 <solidsnack> you can download this to make installing libs easy:
19:19:53 <solidsnack> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
19:20:25 <solidsnack> cabal is like rubygems or CPAN
19:23:00 <solidsnack> gilbert: you need not feel any compulsion to upgrade; but you know what the cool kids are using :)
19:23:33 <glguy> I still use 6.8 for work
19:23:44 <glguy> if you have to ask if you need 6.10
19:23:47 <glguy> you probably don't  ;)
19:24:54 <maxote> solidsnack, what's rubygems?
19:25:20 <pumpkin_> the ruby packaging system
19:26:20 <sykopomp> maxote: and CPAN is perl's
19:27:07 <maxote> cabal is haskell's, and godi is ocaml's, right?
19:35:37 <gwern> apparently it's spelled GODI
19:38:02 <f4hy> If I compile a binary on my machine with GHC, how portable is that binary? Does it compile for my specific processor or can I move it to my webserver?
19:38:42 <gwern> depends on your setup
19:39:46 <f4hy> Hmm.. ok well then is it possible to compile something that I could run on a server which does not have a haskell compiler?
19:40:05 <f4hy> How do I make my setup so the depends beocmes yes
19:40:29 <pumpkin_> you compile it on the same architecture and OS as your webserver
19:40:34 <pumpkin_> same as any compiled binary
19:40:36 <pumpkin_> :)
19:40:58 <sykopomp> pumpkin_: same as any compiled standalone binary*
19:40:58 <gwern> basically. god help you if it uses the ghc api though
19:41:22 <gwern> I discovered that the hard way when I tried to use my plugins-enabled gitit binary on c.h.o :(
19:44:08 <f4hy> pumpkin_: when we say architecture how fine grained?
19:44:21 <f4hy> pumpkin_: like any x86?
19:44:26 <pumpkin_> depends how many features you enable during compilation
19:44:42 <pumpkin_> if you enable SSE2, you're going to need an SSE2 cpu
19:46:45 <tromp_> > 2872-1636
19:46:46 <lambdabot>   1236
19:46:59 <tromp_> > 2872-1481
19:47:00 <lambdabot>   1391
19:47:18 <ispiked> > takeWhile (/= (0,0)) [(0,0),(1,0),(1,1)]
19:47:19 <lambdabot>   []
19:47:30 <tromp_> > 2104-1481
19:47:31 <lambdabot>   623
19:47:31 <ispiked> > (0,0) \= (1,1)
19:47:32 <lambdabot>   Not in scope: `\='
19:47:38 <ispiked> > (0,0) /= (1,1)
19:47:39 <lambdabot>   True
19:47:42 <ispiked> I don't get it
19:47:52 <pumpkin_> ?
19:48:12 <ispiked> oh
19:48:23 <ispiked> I think I want filter
19:48:25 <pumpkin_> > takeWhile (/= (1,0)) [(0,0),(1,0),(1,1)]
19:48:26 <lambdabot>   [(0,0)]
19:48:32 <tromp_> > 1391/1481
19:48:33 <lambdabot>   0.9392302498311952
19:49:27 <tromp_> > 623/1481
19:49:29 <lambdabot>   0.42066171505739364
19:50:42 <f4hy> using functions inline or not is just a matter of style yes? For every function there is no real difference is there?
19:51:04 <gwern> I think there can be optimization differences, but as ever one should do the right thing
19:51:08 <gwern> and worry abotu performance later
19:51:24 <Iispy> "Make it work now, optimize later."
19:51:59 <MyCatVerbs> f4hy: for an exceedingly naive compiler, it could in theory make a difference to performance. In practice though, GHC's aggressive enough that it doesn't make observable difference.
19:52:20 <wli> Hmm.
19:52:35 <jfredett> ... plugins 1.4.0 requires ghc >= 6.10, I have 6.10.1... what the deuce?
19:53:33 <gwern> plugins is broken
19:53:38 <jfredett> ahh
19:53:39 <jfredett> shit.
19:53:41 <gwern> don't even bother with non 6.8
19:53:50 <jfredett> but I have 6.10
19:53:53 <MyCatVerbs> f4hy: if you ever get really really curious about just how mean and ornery the optimizer is,
19:53:53 <f4hy> Ok since I care little of performance, they are the same?
19:54:02 <jfredett> gwern: is there an alternative?
19:54:07 <jfredett> or am I stuck hacking around it?
19:54:15 <gwern> try hint
19:54:22 <jfredett> hint. gotcha.
19:54:25 <MyCatVerbs> f4hy: you can check up on what the optimizer does to your code with -ddump-simpl.
19:55:32 <f4hy> MyCatVerbs: I honestly dont care, I am still learning the language and just wanted to make sure they meant the same thing for all function and that max 1 2 vs 1 `max` 2 wasnt just becuase max was magic in some way
19:55:50 <MyCatVerbs> f4hy: but it makes essentially no difference. In fact, there are a surprisingly large number of transformations that you can perform for laughs that make no difference whatsoever to GHC's output, provided you have the optimizer turned all the way up. :)
19:56:08 <gwern> f4hy: actually, 1 `max` 2 will desugar to max 1 2 anyway
19:56:11 <MyCatVerbs> f4hy: oh yeah sure, that's just syntactic sugar. No difference whatsoever.
19:56:17 <gwern> that's just syntax
19:56:20 <f4hy> My only confusion is why can't I do + 1 2
19:56:32 <gwern> > (+) 1 2
19:56:33 <roconnor> > (+) 1 2
19:56:33 <lambdabot>   3
19:56:34 <MyCatVerbs> f4hy: (+) 1 2.
19:56:34 <lambdabot>   3
19:56:43 * gwern snickers. too slow
19:56:47 <f4hy> gwern: cool, ya thats want I was asking, i thought it was just suger but doulbe checking there was not some subtle difference
19:57:02 <ManateeLazyCat> How to use hoogle generate database for gtk2hs?
19:57:07 <MyCatVerbs> f4hy: Wrap it in parens, so that the parser will know how to handle it.
19:57:12 <f4hy> Sweet. So if i hate backticks I can just do everything before hand
19:57:14 <centrinia> @let add = (+)
19:57:15 <lambdabot>  Defined.
19:57:23 <centrinia> > add 1 2
19:57:24 <lambdabot>   3
19:57:29 <centrinia> > 1 `add` 2
19:57:29 <MyCatVerbs> f4hy: indeed you can.
19:57:30 <lambdabot>   3
19:57:37 <f4hy> @let (!@#$) = (+)
19:57:38 <lambdabot>  Defined.
19:57:45 <f4hy> 1 !@#$ 2
19:57:46 <gwern> ManateeLazyCat: it's kind of involved. you need to add an option to the haddock step, retrieve the package.txt from somewhere in dist/, and then run hoogle on it to get a .hoo
19:57:48 <f4hy> > 1 !@#$ 2
19:57:49 <lambdabot>   3
19:57:51 <f4hy> sweet
19:57:55 <gwern> ManateeLazyCat: personally I'd stick to grep
19:58:17 <f4hy> so what is the rule for what things can be infixed without backticks?
19:58:35 <gwern> f4hy: anything defined that way
19:58:36 <f4hy> since !@#$ didnt need them. It is special characters?
19:58:48 <MyCatVerbs> f4hy: yes. Operators go infix without backticks.
19:59:15 <f4hy> oh so (somefunction) = x + 1  would not require backticks?
19:59:24 <gwern> !@#$ got away with it since + is defined infix
19:59:36 <f4hy> oh
19:59:38 <MyCatVerbs> f4hy: nothing else does. Also, you can only throw backticks around single identifiers (IIRC there was a proposal to extend the language so that you could put backticks around arbitrary expressions, but I don't think it got anywhere. Too messy and not all that compelling, really. :)
19:59:42 <ManateeLazyCat> gwern: I know how to convert .txt to .hoo, but i don't know how to generate .txt file
19:59:57 <gwern> ManateeLazyCat: as I said, it's an option to runhaskell setup haddock
20:00:11 <jfredett> hint looks way cooler than plugins...
20:00:16 <f4hy> @let (@@@) x = x+1
20:00:17 <lambdabot>  Defined.
20:00:17 <centrinia> What if I defined an operator to be the same as something that is not defined to be infix?
20:00:20 <gwern> works better, anyway
20:00:31 <f4hy> > @@@ x
20:00:32 <lambdabot>   <no location info>: parse error on input `@@@'
20:00:34 <centrinia> @let ($$) = foldl1
20:00:34 <f4hy> > @@@ 1
20:00:35 <lambdabot>  Defined.
20:00:35 <lambdabot>   mueval: Prelude.read: no parse
20:00:35 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
20:00:36 <jfredett> hmm, now I get a weird error wrt process...
20:00:49 <jfredett> it wants versions 1.0.1.1 and 1.0.1.0...
20:00:52 <centrinia> Not a hom....
20:01:01 <ManateeLazyCat> gwern: runhaskell? install gtk2hs? I install use make.
20:01:02 <f4hy> Meh infixing confuses me. I will just avoid it
20:01:06 <f4hy> Thank everyone
20:01:16 <gwern> ManateeLazyCat: you begin to understand why I advise judicious use of grep
20:01:18 <ManateeLazyCat> gwern: How to use runhaskell install gtk2hs
20:01:19 <centrinia> @let ($$) = (flip foldl1) 0
20:01:20 <lambdabot>  <local>:5:0:
20:01:20 <lambdabot>      Multiple declarations of `L.$$'
20:01:20 <lambdabot>      Declared at: <local>:...
20:01:33 <centrinia> :t ($$)
20:01:34 <lambdabot>     Ambiguous occurrence `$$'
20:01:34 <lambdabot>     It could refer to either `L.$$', defined at <local>:4:0
20:01:34 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.$$', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
20:01:43 <centrinia> @let ($$$) = foldl1
20:01:43 <lambdabot>  Defined.
20:01:54 <centrinia> :t ($$$)
20:01:55 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:02:10 <ManateeLazyCat> gwern: Can you give me your grep *regexp* ?
20:02:11 <gwern> ManateeLazyCat: one thing you could try is to hack the autotool scripts to add the hoogle option, build gtk2hs with docs, and then grovel through the various dists/ and extract the .txts...
20:02:24 <centrinia> > add $$$ [1,2,3,4]
20:02:26 <lambdabot>   10
20:02:26 <mdmkolbe> 18 hours left
20:02:42 <ManateeLazyCat> gwern: Ok, thanks!
20:02:44 <centrinia> What is the fixity of foldl1?
20:03:37 <mdmkolbe> @type foldl1
20:03:37 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
20:03:42 <mdmkolbe> centrinia: 2
20:04:29 <Gracenotes> arity?
20:04:44 <centrinia> 2
20:04:56 <centrinia> @let ($$$$) = foldl
20:04:57 <lambdabot>  Defined.
20:05:09 <mdmkolbe> centrinia: sorry I thought you meant arity.  if you mean fixity then it is what ever the default fixity for functions is
20:05:10 <centrinia> What the fsck?
20:05:13 <gwern> Gracenotes: arity refers to argument, fixity is about parsing what arguments go to what
20:05:39 <Gracenotes> isn't the fixity the same for any home-made symbol? :)
20:05:41 <centrinia> I guess (foo $$$$ bar) :: [a] -> b
20:05:43 <gwern> and arity is easy in haskell - everything takes 0 or 1 :)
20:05:48 <gwern> Gracenotes: no, you can set different fixities
20:05:52 <gwern> darn good thing too
20:06:05 <mdmkolbe> Gracenotes: you can add fixity declarations (e.g. "infixr 3 ($$)")
20:06:06 <gwern> what was it, infixl/infixr 0-9?
20:06:45 <Gracenotes> gwern: yeah, although arity can easily be applied many times...
20:06:50 <mdmkolbe> @info (:*:)
20:06:50 <lambdabot> (:*:)
20:06:59 <mdmkolbe> @info ($)
20:06:59 <lambdabot> ($)
20:07:16 <mdmkolbe> (Someone needs to fix @info to show more lines)
20:07:24 <centrinia> Couldn't one argue that (a -> b) has arity 0? :p
20:07:27 <broken_ladder> i no can has haskell on mac osx leopard.
20:07:29 <broken_ladder> Error: Target org.macports.checksum returned: Could not open file: /opt/local/var/macports/distfiles/gmp/gmp-4.2.4.tar.bz2
20:07:53 <bremner> broken_ladder: sounds like a macports question.
20:07:59 <mdmkolbe> Gracenotes: running e.g. ":info $" in ghci will show you the fixity
20:08:04 <centrinia> broken_ladder, try removing gmp-4.2.4.tar.bz2 and reinstall it.
20:08:06 <wli> Defining arity in the presence of currying is "interesting."
20:08:13 <Gracenotes> mdmkolbe: yes, I know :)
20:08:18 <bremner> wli: answer=1
20:08:23 <Gracenotes> :i is my best friend and my sekrit lover
20:08:43 <sbahra> @faq Can Haskell rock?
20:08:43 <lambdabot> The answer is: Yes! Haskell can do that.
20:08:45 <wli> What is the arity of ($1)?
20:09:06 <sbahra> 1?
20:09:08 <centrinia> @faq Can Haskell be used to define an expression of fixity -42?
20:09:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:09:10 <jfredett> this is really weird, process-1.0.1.0 and process-1.0.1.1 are installed and registered, disabling either claims to break Cabal/haddock etc, and even if I unregister one, it complains about wanting ghc >6.6...
20:09:10 <mdmkolbe> wli: polymorphic
20:09:16 <wli> Yes.
20:09:19 <jfredett> this is when installing hint
20:09:22 <sbahra> Ah, yes. Of course.
20:09:23 <wli> Polymorphic arities...
20:09:24 <jfredett> via sudo cabal install.
20:09:44 * sbahra hasn't written any Haskell for almost 3 weeks now
20:09:45 <bremner> broken_ladder: I don't anything about macos, but it sounds like you need to "update ports" or something like that
20:09:57 <Gracenotes> there must be a way to formulate the arguments until an expression no longer returns a function
20:10:02 <centrinia> @type ($ 1)
20:10:03 <lambdabot> forall a b. (Num a) => (a -> b) -> b
20:10:20 <Gracenotes> I'm pretty sure partial application's internals aren't as pretty as the theory
20:10:22 <centrinia> It looks like ($ 1) has arity 1
20:10:43 <wli> centrinia: ($1) (+)
20:10:54 <mdmkolbe> @type ($1) (\x y z w -> 3)
20:10:55 <lambdabot> forall t t1 t2 t3. (Num t3) => t -> t1 -> t2 -> t3
20:10:56 <centrinia> @type ($1) (+)
20:10:57 <lambdabot> forall a. (Num a) => a -> a
20:11:26 <wli> @type ($1) (+) 1
20:11:27 <lambdabot> forall a. (Num a) => a
20:11:32 <centrinia> Is arity well defined?
20:11:35 <wli> There ($1) seems to have arity 2.
20:11:41 <wli> centrinia: Yes, but nontrivial.
20:12:34 <lstor> What does '$=' mean/do?
20:12:44 <wli> @type let add3 x y z = x + y + z in ($1) add3 1 1
20:12:44 <mdmkolbe> @type ($=)
20:12:44 <lambdabot> forall a. (Num a) => a
20:12:45 <lambdabot> Not in scope: `$='
20:12:47 <centrinia> @type ($=)
20:12:48 <lambdabot> Not in scope: `$='
20:12:53 <mdmkolbe> @index ($=)
20:12:53 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
20:12:57 <wli> So ($1) has arity 3 there.
20:13:13 <Axman6> :t Graphics.UI.GLUT.($=)
20:13:14 <lambdabot> Couldn't find qualified module.
20:13:24 <lstor> Ah, it's OGL specific. That explains it. Thanks :)
20:13:34 <lstor> I just wondered if I'd missed an entire operator...
20:13:51 <ddarius> ($=) is basically writeIORef
20:14:29 <Gracenotes> it's so easy to Google for $=, for course
20:15:10 <centrinia> @hoogle ($=)
20:15:10 <lambdabot> No results found
20:15:16 <lstor> Gracenotes: Exactly. "Your search - $= - did not match any documents."
20:15:17 <centrinia> @hoogle $=
20:15:17 <lambdabot> No results found
20:15:38 <centrinia> Hoogle is of no use either. :(
20:16:13 <mdmkolbe> lstor: basically you say something light "lighting $= Enabled" to set OpenGl lighting to enabled
20:16:41 <mdmkolbe> lighting :: StateVar Capability, Enabled :: Capability
20:17:22 <lstor> mdmkolbe: I see. That corresponds pretty well to the code I'm browsing too. Thanks :)
20:17:35 <lstor> (E.g. currentColor $= courtCol )
20:24:27 <pumpkin_> > read "0x50" :: Int
20:24:28 <lambdabot>   80
20:27:03 <kerlo> @hoogle StateVar
20:27:03 <lambdabot> No results found
20:27:19 <mdmkolbe> @index StateVar
20:27:19 <lambdabot> Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
20:27:59 <kerlo> Did someone say Graphics.UI.GLUT.($=)?
20:28:09 * wli notices Data.List.unfoldr Data.Map.minViewWithKey
20:28:12 * kerlo frowns
20:28:32 <ddarius> kerlo: That's (Graphics.UI.GLUT.$=)
20:28:33 <mdmkolbe> kerlo: look in Graphics.Rendering.OpenGL.StateVar, but that doesn't list the constructors.  You'll have to poke around other places (e.g. Graphics.Rendering.OpenGL.Colors) to find the variables of type StateVar
20:29:01 * kerlo furrows and raises his eyebrows, tilts his head slightly, and shrugs
20:29:06 <mdmkolbe> kerlo: it's in Graphics.Rendering.OpenGL.StateVar
20:30:27 <wli> @type unfoldr Map.minViewWithKey
20:30:28 <lambdabot> Couldn't find qualified module.
20:30:43 <mdmkolbe> @type minViewWithKey
20:30:44 <lambdabot> Not in scope: `minViewWithKey'
20:30:48 <kerlo> You know, that particular piece of body language doesn't really work well when you omit the mouth movement.
20:30:52 <ddarius> :t M.minViewWithKey
20:30:52 <mdmkolbe> @index minViewWithKey
20:30:52 <lambdabot> bzzt
20:30:53 <lambdabot> forall k a (m :: * -> *). (Monad m) => M.Map k a -> m ((k, a), M.Map k a)
20:31:29 <wli> > unfoldr Map.minViewWithKey $ Map.fromList [(1,2),(2,3)]
20:31:30 <lambdabot>   [(1,2),(2,3)]
20:31:36 <wli> There's something odd about lambdabot
20:32:01 <mdmkolbe> You've only just now noticed that lambda bot is odd?
20:32:50 <kerlo> > odd x
20:32:51 <lambdabot>   True
20:32:58 <mdmkolbe> > x
20:32:59 <lambdabot>   x
20:33:06 <mdmkolbe> @type x
20:33:07 <lambdabot> Expr
20:33:13 <Axman6> > even x
20:33:14 <lambdabot>   False
20:33:19 <Axman6> > even y
20:33:20 <lambdabot>   False
20:33:23 <mdmkolbe> > odd y
20:33:24 <lambdabot>   True
20:33:34 <mdmkolbe> > x + y
20:33:35 <lambdabot>   x + y
20:33:41 <kerlo> > odd (x + y)
20:33:42 <lambdabot>   True
20:33:50 <mdmkolbe> > odd (x / 2)
20:33:51 <lambdabot>   True
20:33:52 <kerlo> > [odd x, odd y, odd (x + y)]
20:33:54 <lambdabot>   [True,True,True]
20:33:57 <kerlo> Aiee.
20:34:01 <mdmkolbe> > odd (x - x)
20:34:02 <lambdabot>   True
20:34:13 <mdmkolbe> > x == 0
20:34:14 <lambdabot>   False
20:34:20 <kerlo> > x - x == 0
20:34:21 <lambdabot>   False
20:34:30 <kerlo> Well, there you have it.
20:34:42 <kerlo> Straight from the words of the lambda bottle herself.
20:37:09 <pumpkin_> > [1,2,3,]
20:37:09 <lambdabot>   <no location info>: parse error on input `]'
20:37:13 <pumpkin_> > [,1,2,3]
20:37:14 <lambdabot>   <no location info>: parse error on input `,'
20:37:19 <pumpkin_> it doesn't allow extra commas :(
20:38:15 <kerlo> > [",",",",",,,,,,,,,",",",",",",,,",",",",",","]
20:38:16 <lambdabot>   [",",",",",,,,,,,,,",",",",",",,,",",",",",","]
20:38:24 <kerlo> Extra commas for you.
20:39:02 <quuxman> ack that list of strings hurts my eyes
20:41:58 <f4hy> I have a question. Is haskell supposed to blow my mind?
20:42:05 <f4hy> Becuase it does
20:42:16 <lstor> @faq Can Haskell blow your mind?
20:42:17 <lambdabot> The answer is: Yes! Haskell can do that.
20:42:17 <mdmkolbe> f4hy: yes, but only in a good way
20:42:29 <mdmkolbe> > odd (x)
20:42:30 <lambdabot>   True
20:42:33 <mdmkolbe> > odd (x * 2)
20:42:34 <lambdabot>   True
20:42:41 <mdmkolbe> @src odd
20:42:41 <lambdabot> odd = not . even
20:42:44 <mdmkolbe> @src even
20:42:44 <lambdabot> even n = n `rem` 2 == 0
20:42:53 <f4hy> I am halfway through a tutorial and already want to rewrite my current project in it
20:42:53 <mdmkolbe> > x `rem` 2
20:42:54 <lambdabot>   x `rem` 2
20:43:07 <lstor> @src rem
20:43:07 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:43:22 * sykopomp would rather not have all this syntax, but likes the declarativeness.
20:43:24 <mdmkolbe> f4hy: have you ever used a functional programming language before?
20:43:43 <f4hy> mdmkolbe: no
20:43:52 <f4hy> mdmkolbe: python has functional parts though.. kinda right?
20:43:56 <kerlo> > x `rem` 2 == 0
20:43:57 <lambdabot>   False
20:44:01 <jfredett> f4hy: functional languages, in general, are mindblowing
20:44:04 <mdmkolbe> f4hy: ah, then it will really blow your mind
20:44:15 <jfredett> f4hy: python is functional, in the sense that java is succint.
20:44:22 <kerlo> So @src is lying.
20:44:29 <pumpkin_> @src lies a lot
20:44:29 <lambdabot> Source not found. There are some things that I just don't know.
20:44:37 <pumpkin_> @src sort
20:44:37 <lambdabot> sort = sortBy compare
20:44:42 <pumpkin_> @src sortBy
20:44:42 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:44:49 <kerlo> Python can be used as a functional language.
20:44:50 <f4hy> I just got to partial application and curried fuctions and there was a small explosion in my head
20:44:55 <mdmkolbe> f4hy: most langauges contain functional subests in that you can do or fake functional programming in them, but that is like saying that C (not C++) is OOP b/c you can do OOP in C with a bit of work
20:45:18 <jfredett> f4hy: that is, you can certainly write 'short' java code, and you can do functional code in python, but it's not the standard.
20:45:20 <wks> @src insertBy
20:45:20 <lambdabot> insertBy _   x [] = [x]
20:45:20 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
20:45:20 <lambdabot>                                  GT -> y : insertBy cmp x ys'
20:45:20 <lambdabot>                                  _  -> x : ys
20:45:27 <wli> > let primeStep n = let cmpStep ((k, ps), m) | n /= k = tell [n] >> modify (Map.insertWith (++) (n*n) [n]) | otherwise = put . Map.unionWith (++) m . Map.fromListWith (++) $ [(k + p, [p]) | p <- ps] in gets Map.minViewWithKey >>= maybe (tell [n] >> put (Map.singleton (n*n) [n])) cmpStep in flip evalState Map.empty . execWriterT $ mapM_ primeStep [2..]
20:45:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
20:45:36 <ManateeLazyCat> I config gtk2hs, "sourceview" not pass, I miss something depend? I use Debian testing
20:45:36 <f4hy> mdmkolbe: true. But I think I have used some of the functional parts of python, sortof.
20:45:43 <wli> f4hy: Witness!
20:46:10 <f4hy> wli: witness what?
20:46:22 <mdmkolbe> f4hy: fortunately once you get the part of your mind that were blown put back together, you will have a new way of looking at things that at times will translate back to other languages you use
20:46:27 <wli> f4hy: The monadic sieve of Eratosthenes.
20:46:35 <wks> So it means the built-in sort function uses insert sort.
20:47:20 <f4hy> wli: I cant parse it well enough yet to see what that is doing, but I see those primes and will come back and look at the Eratosthenese function when done with my tutorial
20:47:26 <mdmkolbe> wli: be nice to the new comer.  even I wouldn't want to read through that code you just pasted
20:47:33 <jfredett> f4hy: one of the really neat things to do with haskell in particular is doing things with infinite lists, really shows the power of lazyness and functional code.
20:47:39 <wli> f4hy: Monad transformer stacks will rock your world.
20:47:45 <jfredett> f4hy: among my favorites is the following:
20:47:54 <wli> mdmkolbe: Well, when properly formatted, it's good.
20:48:08 <jfredett> > let fib = 0 : 1 : zipWith (+) fib (tail fib)
20:48:09 <lambdabot>   <no location info>: parse error on input `;'
20:48:15 <jfredett> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
20:48:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:48:19 <jfredett> my bad.
20:48:31 <f4hy> jfredett: ya lazyness seems like a win. Also infinte lists. In python i always thought of generators as being infinte lists, but now I really have them.
20:49:11 <mdmkolbe> @src fix
20:49:11 <lambdabot> fix f = let x = f x in x
20:49:28 <f4hy> does lamdabot just do a 'take' when given infinte lists?
20:49:51 <mdmkolbe> f4hy: I think it does a 'take' of the resulting string from a 'show'
20:50:06 <jfredett> > [1..]
20:50:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:50:11 <jfredett> > [2..]
20:50:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
20:50:29 <mdmkolbe> > let x = ("a", x) in x
20:50:30 <lambdabot>       Occurs check: cannot construct the infinite type: t = ([Char], t)
20:50:30 <lambdabot>      ...
20:50:42 <jfredett> yah, I think so, it looks like it takes the same number of characters each time...
20:50:46 <kerlo> > cycle "10--------"
20:50:47 <f4hy> mdmkolbe: wait you can do a show on an infinte list?! (I am starting to think haskell is not a programming language, it is evil wizardry)
20:50:49 <lambdabot>   "10--------10--------10--------10--------10--------10--------10--------10--...
20:51:06 <kerlo> 75.
20:51:13 <jfredett> @remember wait you can do a show on an infinte list?! (I am starting to think haskell is not a programming language, it is evil wizardry)
20:51:13 <lambdabot> Nice!
20:51:29 <kerlo> > replicate 74 'a' ++ undefined
20:51:30 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:51:32 <jfredett> shit. I meant to tack your name on that
20:51:36 <f4hy> > cycle ["White's turn", "Black's turn"]
20:51:37 <lambdabot>   ["White's turn","Black's turn","White's turn","Black's turn","White's turn"...
20:51:41 <jfredett> can I edit a @remember?
20:51:44 <wli> f4hy: If you want evil wizardry...
20:51:51 <wli> > let cantor= let zip' [] yss = yss ; zip' xs@(_:_) [] = map return xs ; zip' (x:xs) (ys:yss) = (x:ys) : zip' xs yss ; f []= [] ; f ([]:xss) = f xss ; f ((x:xs):xss) = [x] : zip' xs (f xss) in concat . f in cantor [[(i, j) | j <- [0..]] | i <- [0..]]
20:51:51 <jfredett> wli: play nice. :P
20:51:52 <mdmkolbe> f4hy: it works b/c it is lazy all they way down.  The show only computes what parts of the string are actually used
20:51:52 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
20:51:54 <f4hy> wli:  no I am not ready!
20:52:13 <jfredett> wli: cantor dust or diagonal argument?
20:52:19 <kerlo> wli: now come up with one that enumerates the Cantor set.
20:52:24 <kerlo> jfredett: a bijection between N and NxN.
20:52:30 <jfredett> ah
20:53:04 <jfredett> f4hy: I can't read those things without some work first either, and I've been at this for 2 years.
20:53:14 <wli> jfredett: It does Cantor-style diagonalization to make a flattened list from an infinite list of infinite lists.
20:53:27 <jfredett> f4hy: it's a hard language, but it's fun, and very rewarding.
20:53:29 <mdmkolbe> f4hy: on occation the lazeness does hurt though.  It gets hard to put delay loops in your program ;-)
20:53:33 <jfredett> wli: I recognize it now.
20:54:21 <wli> I had a typeclass-based version that did similar flattening on arbitrarily nested listsof lists of lists of ... with the good ordering properties, too.
20:54:28 <f4hy> Stop blowing my mind ok. It is blown enough already. It needs to recover before being exploded more
20:54:51 <kerlo> Delay loops as in let delay 0 = (); delay n = delay (n-1) in seq (delay 1000000) stuff?
20:55:13 <mdmkolbe> f4hy: if you want revenge you can always make GHC's brain explode.  (Anyone got a good example laying around to show.)
20:55:28 <mle> > fix error
20:55:29 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:55:59 <pumpkin_> it's sad that fix error does the opposite of what it says it does
20:56:08 <wli> For instance, if you had [[[(i, j, k) | k <- [0 ..]] | j <- [0..]] | i <- [0 ..]] you would get the elements in ascending order of i + j + k, albeit to arbitrary degrees of list nesting.
20:56:09 <mdmkolbe> mle: no, I mean the famous error message
20:56:15 <jfredett> f4hy: a really good way to learn haskell, at least for me, was to get xmonad running on a linux box, and just hack up stuff for it. build programs to create a Dzen statusbar, mess around w/ the config
20:56:21 <kerlo> @ghc
20:56:21 <lambdabot> ghc says: Oops!  Entered absent arg
20:56:43 <wli> I'll probably never be able to write that again.
20:56:45 <mdmkolbe> @quote exploded
20:56:45 <lambdabot> ghc says: My brain just exploded.
20:57:08 <jfredett> it's a really nice way to find project ideas, and also be able to finish projects and get results immediately
20:57:19 <mdmkolbe> that's a real error message if you can outwith the GHC type checker
20:57:27 <mdmkolbe> s/outwith/outwit/
20:58:13 <kerlo> Does this still make GHC angry? data Ehird a = Ehird (Ehird a -> a); y x = (\(Ehird z) -> x (z (Ehird z))) (Ehird (\(Ehird z) -> x (z (Ehird z))))
20:58:33 * dancor wonders if there are theoretical limits on the quality of compiler error messages
20:58:38 <jfredett> kerlo: what the hell?
20:58:52 <mdmkolbe> dancor: Rice's theorem
20:59:11 <kerlo> jfredett: it's something that, if I remember correctly, used to make GHC freeze.
20:59:16 <kerlo> And may still.
20:59:27 <dancor> mdmkolbe: but how does it apply exactly
20:59:39 <kerlo> @djinn-add data Loophole a = Loop (Loophole a -> a)
20:59:39 <lambdabot> Error: Recursive types are not allowed: Loophole
20:59:40 <mdmkolbe> kerlo: no, GHC is ahppy with that
20:59:46 <kerlo> Aww.
20:59:54 <kerlo> mdmkolbe: has it always been?
21:00:28 <mdmkolbe> kerlo: well it compiles in GHC 6.10, I don't know about anything else
21:00:36 <f4hy> OMG i just wrote the akermann function
21:00:46 <Axman6> :o
21:00:47 <jfredett> f4hy: do you feel dirty?
21:01:02 <Axman6> :t even
21:01:03 <lambdabot> forall a. (Integral a) => a -> Bool
21:01:03 <f4hy> seeing as I didnt know anything about the language a few hours ago i just was hit by a rush of adrenalin
21:01:09 <jfredett> its so fun.
21:01:26 <jfredett> the ackermann function just seems so innocent in haskell
21:01:28 <Axman6> f4hy: want to paste it? we might be able to give you pointers
21:01:30 <kerlo> > even (0.5 :: Expr)
21:01:32 <lambdabot>   False
21:01:39 <kerlo> > odd (0.5 :: Expr)
21:01:40 <lambdabot>   True
21:01:40 <jfredett> just a little Integer -> Integer -> Integer type. iirc
21:01:51 <kerlo> > odd (2/3 :: Expr)
21:01:52 <lambdabot>   True
21:01:55 <f4hy> how do I paste multi line stuff here?
21:01:58 <jfredett> and then... BANG! giant ass evil numbers.
21:02:01 <mdmkolbe> @paste
21:02:01 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:02:02 <kerlo> I'll give it 0.5, but 2/3 is definitely even.
21:02:04 <jfredett> f4hy: hpaste.org
21:02:24 <jfredett> tell it to "announce" and it should link here, if hpaste-bot is alive and kicking
21:02:36 <Axman6> it's not
21:02:41 <Axman6> hasn't been for months
21:02:44 <jfredett> aww
21:02:47 <f4hy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1973#a1973
21:03:18 <jfredett> maybe you should try it w/ pattern matching
21:03:33 <f4hy> jfredett: alright I could do that
21:03:40 <f4hy> but it seemd like guards were the way to go
21:04:02 <jfredett> you give it a shot, and I'll modify what you have, edit yours first, then look at mine, we'll see how you do. :)
21:07:13 <shapr> f4hy: Yay for writing cool Haskell after only a few hours!
21:07:37 <pumpkin_> w00t, I have almost all the arm instructions covered now
21:07:48 <Axman6> for what?
21:07:54 <shapr> ARM?
21:08:04 <f4hy> shapr: thanks, I am only like 4 pages into a tutorial. but math -> haskell is an easy translation
21:08:06 <ddarius> shapr: We were supposed to be writing cool Haskell?  Is that what I've been doing wrong all these years...
21:08:11 <jfredett> f4hy: I modified what you had with what I would do, I like to think I write pretty idiomatic haskell. at least, thats what I see.
21:08:20 <shapr> ddarius: Hah, you do write cool Haskell code!
21:08:21 <jfredett> f4hy: are you doing RWH or soemthing else?
21:08:35 <f4hy> jfredett: nah that sounded to professional
21:08:42 <f4hy> http://learnyouahaskell.com
21:08:50 <jfredett> RWH == way awesome
21:09:01 <shapr> Truly, Real World Haskell r0xx0rs
21:09:05 <shapr> And it's freely available online
21:09:12 <shapr> But hey, read whatever works for you.
21:09:17 <jfredett> learnyouahaskell is a good start. RWH is really comprehensive though, everything gets covered
21:09:27 <jfredett> the authors hang around here, too.
21:09:42 <ddarius> RWH didn't help me one bit when I was learning Haskell.
21:09:47 <f4hy> I will read RWH after wards
21:09:49 <jfredett> dons, bos, jgoerzen (is that his handle, I don't remember.)
21:09:55 <jfredett> f4hy: that would be my suggestion.
21:09:56 <f4hy> but I like to be called a lier in my tutorials
21:09:56 <ddarius> jfredett: CosmicRay
21:10:02 <jfredett> ddarius: shit, I knew that.
21:10:05 <shapr> yeah, CosmicRay
21:10:25 <jfredett> too many names... my brain can't handle it.
21:10:28 * Axman6 didn't. makes a note
21:10:53 <shapr> Perhaps I should write a cheat sheet to the cool people on #haskell?
21:10:58 <jfredett> freaking hint... why won't you install!
21:11:26 <f4hy> jfredett: I will rewrite my function in a bit, I am on the phone with a friend so will get back to hacking in a few mins
21:13:19 <Ansible> Hmmm, ok trying to install 6.10.1 on ubuntu.  Compiled it, installed it, can type ghc and etc.  Now trying to install cabal, but this fails:
21:13:27 <Ansible> sudo runhaskell Setup install
21:13:32 <dancor> what should i use instead of (run ("wget", [url, "-O", "-"]))
21:13:46 <Ansible> it gives me
21:13:47 <jfredett> Ansible: shouldn't it be Setup.*hs?
21:13:59 <Cale> Ansible: for the future, installing 6.10.1 is *much* easier if you just use the generic linux binary.
21:14:12 <Ansible> sudo: runhaskell: command not found
21:14:23 <jfredett> also, whoever daniel fischer is, you rock.
21:14:26 <Cale> (and faster)
21:15:10 <Ansible> I added "/usr/local/ghc-6.10.1/bin" to my PATH, but sudo doesn't see that i guess
21:15:10 <shapr> dancor: curl bindings?
21:15:10 <mdmkolbe> Cale: what do you mean by generic linux binary?  One from haskell.org instead of from the distro (e.g. Ubuntu)?
21:15:23 <shapr> dancor: I know darcs uses curl bindings.
21:15:27 <Cale> mdmkolbe: Ubuntu doesn't even have 6.10.1
21:15:27 <mdmkolbe> Ansible: "hash runhaskell"
21:15:33 <shapr> Or you can shell out to wget...
21:15:38 <Cale> mdmkolbe: I mean instead of the source.
21:15:56 <dancor> shapr: ok bindings is at least not a subprocess.  there is nothing cool in like HTTP?
21:16:10 <dancor> i guess libcurl is pretty cool
21:16:11 <shapr> Oh yeah, I think HTTP can do wget stuff as well.
21:16:28 <Ansible> hmmm, still the same result.  should that have fixed it?
21:17:27 <te> hello
21:17:48 <te> I'm trying to buiild and install this Yi text editor
21:17:52 <te> build*
21:18:05 <te> cabal: cannot configure syb-0.1.0.0. It requires base >=4.0
21:18:05 <te> There is no available version of base that satisfies >=4.0
21:18:26 <Cale> te: That means you need 6.10.1 and have something earlier
21:18:28 <Cale> (GHC)
21:18:30 <mdmkolbe> te: what version of GHC do you have? 6.10?
21:18:34 <ManateeLazyCat> te: I have build 0.5.3 with ghc 6.10
21:18:44 <ManateeLazyCat> te: You need ghc 6.10
21:18:49 <mdmkolbe> te: "ghc --version"
21:19:06 <ManateeLazyCat> te: If you want gtk frontend support, you need install gtk2hs-0.10.0
21:19:42 <mdmkolbe> anyone know why gtk2hs isn't in cabal?
21:20:39 <ManateeLazyCat> mdmkolbe: Because gtk2hs need speical thing to build, but now gtk2hs can't install by cabal
21:20:43 <gwern> mdmkolbe: too difficult
21:20:50 <Ansible> maybe putting /usr/local/ghc-6.10.1/bin in my path is not the way to go?
21:20:58 <te> ManateeLazyCat: there area number of libghc6
21:20:59 <gwern> the current gtk2hs is a strange mixture of cabal and autotools
21:21:20 <gwern> te: darcs yi doesn't work with anything but 6.10
21:21:24 <ManateeLazyCat> te: You can download ghc-6.10 with binary package
21:21:33 <te> im on ubuntu hardy
21:21:38 <gwern> te: you need to look for older yis on hackage if you have an old ghc
21:21:40 <te> trying to figure out which gk2hs packages i need
21:21:54 <ManateeLazyCat> te: http://downloads.sourceforge.net/gtk2hs/gtk2hs-0.10.0.tar.gz)
21:22:12 <ManateeLazyCat> te: So ubuntu have source for ghc 6.10?
21:22:21 <te> yes
21:22:36 <ManateeLazyCat> te: Oh, sweet... Debian's source is too old
21:22:44 <mdmkolbe> te: really?
21:22:48 * mdmkolbe goes to look
21:22:48 <te> nevermind
21:22:52 <te> i think that's a false alarm
21:22:55 <gwern> debian and ubuntu are very bad about their haskell support
21:22:55 <ManateeLazyCat> te: Ubuntu stable? Maybe i will switch to ubuntu
21:23:13 <ManateeLazyCat> gwern: So which better?
21:23:14 <te> im on 6.8.2
21:23:20 * mdmkolbe uses Ubuntu and has always had to use 6.8
21:23:31 <ManateeLazyCat> gwern: I install binary package in Debian
21:23:48 <te> so im sorry but ManateeLazyCat if i build and install gtk2hs i should be okay?
21:24:17 <mdmkolbe> te: you still need 6.10.  The Yi you have probably wont work with 6.8
21:24:27 <mdmkolbe> s/wont/won't/
21:24:35 <te> or do i need to compile ghc 6.10 from scratch
21:24:38 <ManateeLazyCat> te: You need install Ghci 6.10 first, you just need install gtk2hs when you want use Yi Gtk frontend
21:24:41 <gwern> ManateeLazyCat: they're both bad. ubuntu takes most of its stuff from debian, so that follows
21:25:11 <ManateeLazyCat> gwern: So which system that you use?
21:25:45 <ManateeLazyCat> gwern: I agree, i think need someone maintain Debian Haskell support.
21:25:56 <ManateeLazyCat> gwern: Debian's source is too old
21:26:39 <ManateeLazyCat> gwern: Now still is 6.8 even i use 6.10 long time.
21:27:19 <gwern> ManateeLazyCat: I use ubuntu, but I bypass apt for anything haskell-related
21:27:29 <ManateeLazyCat> te: Install GHC 6.10 binary package
21:27:31 <gwern> just install ghc/cabal-nstall stuff into ~/bin
21:27:53 <Ansible> gwern did you compile 6.10 yourself on ubuntu?
21:28:05 <te> la la la la
21:28:05 <te> building 6.10
21:28:07 <gwern> Ansible: no, I used the i386 binary release of ghc
21:28:07 <f4hy> jfredett: ok back. So I should use pattern matching? would I use a where?
21:28:33 <jfredett> f4hy: so, take a look at the code I posted after yours on hpaste.
21:28:43 <jfredett> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1973#a1974
21:28:44 * ManateeLazyCat I try to compile ghc 6.10, but failed, so i use binary package 
21:29:13 <Ansible> I was able to compile and install ok, but sudo doesn't see ghc or runhaskell...
21:29:51 <jfredett> the benefit of the way I did it, is that it looks _almost precisely_ like the mathematical definition, which is really nice, because math definitions tend to be very pretty,
21:29:58 <wli>     Inferred type is less polymorphic than expected
21:29:59 <wli>       Quantified type variable `m' is mentioned in the environment:
21:30:00 <wli> ugh
21:30:08 <jfredett> whats more, it tells me exactly what the base cases are
21:30:25 <wli> This is getting really foggy really fast.
21:30:38 <ManateeLazyCat> jfredett: You can try to use my Emacs extension at http://www.emacswiki.org/cgi-bin/emacs/Paste2
21:30:48 <ManateeLazyCat> jfredett: hpaste have file size limit
21:30:57 <ManateeLazyCat> jfredett: So you can't paste big code
21:30:57 <jfredett> ManateeLazyCat: I don't use Emacs...
21:31:11 <jfredett> ManateeLazyCat: does my code not show up?
21:31:14 <ManateeLazyCat> jrockway: I consider you use hpaste.el
21:31:24 <ManateeLazyCat> jfredett: Sorry
21:31:27 <jfredett> np.
21:32:22 <ManateeLazyCat> gwern: Ubuntu stable? Maybe i need a switch, i hate old source.
21:32:30 <jfredett> f4hy: your version requires me to look and interpret each guard condition, which is a bit more cognitive load.
21:32:41 * wli runs into trouble.
21:33:19 <mdmkolbe> f4hy: generally haskell programmers favor pattern matching over guards
21:33:29 <jfredett> neither is _wrong_, per se, but afaik, mine is more idiomatic. However, it's good that you've got a hang of guards right off the bat, they took me a little while to understand.
21:35:45 <wli> Type trouble en route: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1975#a1975
21:35:52 <f4hy> jfredett: I am still trying to figure out yours but I think i get it
21:36:52 <sykopomp> wli: looks like they're trying to obfuscate the code? :)
21:36:54 <f4hy> jfredett: I dunno to me using pattern matching just seems like defineing a bunch of different functions
21:37:06 <jfredett> f4hy: thats exactly what you're doing, in a sense.
21:37:19 <jfredett> f4hy: do you know about peicemeal functions?
21:37:32 <f4hy> jfredett: peicewise functions?
21:37:42 <jfredett> f4hy: right, thats what I meant
21:37:58 <jfredett> in a sense, peicewise functions are many subfuctions, operating as one big function
21:37:58 <f4hy> jfredett: haha yes. I jsut wrote an ackermann function....
21:38:13 <wli> sykopomp: eh?
21:38:25 <jfredett> in the same way- pattern matching defines many small subfunctions (with the same name) that operate as one big function
21:38:32 <sykopomp> wli: it looks like obfuscation, that mess :P
21:38:37 <ddarius> (Either a b -> c) ~ (a -> c, b -> c)
21:38:46 <f4hy> jfredett: ya I understand that, I just dont see why that is prefered to guards?
21:39:03 <f4hy> Also I should start it with ackermann :: Integer -> Integer -> Integer  right?
21:39:09 <wli> sykopomp: Certainly not what I had in mind.
21:39:14 <mdmkolbe> f4hy: have you gotten to "data" type declarations?
21:39:17 <jfredett> f4hy: thats good practice, yes
21:39:28 <sykopomp> wli: oh, I thought you were pasting joke code.
21:39:29 <sykopomp> my bad
21:39:32 <jfredett> f4hy: once you get to data types, you'll understand it
21:39:33 * sykopomp goes back to reading.
21:39:56 <f4hy> I dunno... guards seem pretty cool
21:40:03 <mdmkolbe> f4hy: when you get to those, it will become clear that pattern matches are much easier to work with, for Int one could go either way
21:40:04 <jfredett> I suggested in the paste that you try (when you get to them) to define a datatype for the natural numbers
21:40:15 <f4hy> Pattern matching is cool too, but guards seem to make more sense for comparisons
21:40:26 <wli> jfredett: moi?
21:40:27 <mdmkolbe> jfredett: are you suggesting a Peano numbers?
21:40:36 <jfredett> wli: no, f4hy
21:41:07 <jfredett> mdmkolbe: yes, particularly. there a nice simple example that shows why guards < pattern matching.
21:41:42 <f4hy> I think I have had enough haskell fun for today actually. I need to do my homework and study for a test
21:41:53 <jfredett> f4hy: hehe, fair enough.
21:41:54 <f4hy> But learning haskell is more fun than crypto homework!
21:42:05 <jfredett> f4hy: aww, Crypto is way fun
21:42:10 <f4hy> it is
21:42:31 <pumpkin_> do the homework in haskell!
21:42:35 <ManateeLazyCat> Now have special command-line tool to search Haskell code completion candidate, hoogle can't support regexp search.
21:42:43 <f4hy> pumpkin_: Maybe at the end of the semester
21:42:50 <jfredett> I'm stuck with undergrad number theory and our unfortunately aenemic 1 semester real analysis course... no fun crypto for me...
21:43:03 <ddarius> Do your crypto homework in Cryptol!
21:43:31 <jfredett> ddarius: better yet, write a haskell program, which writes a cryptol program, which does your homework!
21:43:38 <f4hy> So far all my crpyto homework has been done in python, which if funny since half the class is pure math students who use a TI83
21:43:56 <f4hy> And paper
21:44:09 <jfredett> f4hy: pah, they're bad mathematicians, real mathematicians ought to know how to write code.
21:44:20 <jfredett> complex ones write haskell!
21:44:25 <f4hy> jfredett: we are mathematicians in training though
21:44:41 <jfredett> hehe, are you a grad or undergrad?
21:45:05 <f4hy> I am in a masters program in computational science, but I hang out with the math gradstudents
21:45:21 <SamB> what about hypercomplex or quaternian mathemeticians ?
21:45:31 <f4hy> computational science /= computer science
21:45:33 <jfredett> SamB: they don't count.
21:45:46 <jfredett> f4hy: coolbeans.
21:45:49 <SamB> I was just wondering what they wrote in
21:46:28 <jfredett> SamB: curiously enough, MIPS assembly.
21:46:39 <f4hy> Ya, I laugh at all of my peers who do their compuations by hand when I can write three lines of code to solve things. And I am anything but a good programmer
21:46:46 <SamB> both of them ?
21:46:51 <jfredett> SamB: yep.
21:47:01 <jfredett> Surreal mathematicians use Malboge
21:47:04 <SamB> no THUMB ?
21:47:08 <pumpkin_> thumb ftw
21:47:20 <pumpkin_> I'm going to start adding that to my disassembler soon
21:47:30 * jfredett hasn't heard of THUMB
21:47:41 <SamB> it goes with ARM, strangely enough
21:47:46 <pumpkin_> it's like ARM's little bro
21:47:55 <jfredett> makes sense.
21:47:56 <mdmkolbe> SamB: is there a HAND do?
21:47:58 <SamB> HAND might seem more sensible, but ...
21:48:16 <jfredett> haven't learned ARM though, it's been a while since I've had a reason to play with Assembly.
21:48:41 <SamB> I don't know any THUMB myself, and I don't really remember much about ARM either
21:48:52 <SamB> except I remember thinking it was pretty cute
21:48:54 <pumpkin_> THUMB is almost a subset of ARM
21:49:12 <pumpkin_> minus the built-in conditionals, and you have smaller immediates, and half the registers at your disposal
21:49:14 <pumpkin_> basicall
21:49:16 <pumpkin_> y
21:49:35 <f4hy> Alright so I recently wrote a chinese chess engine in python, but now that I am learning haskell I want to rewrite it in haskell since it seems more fun. How long does it take before one becomes profficnet in haskell and can actually produce working applications
21:49:42 <pumpkin_> (each instruction is 16 bits instead of 32)
21:49:57 <SamB> pumpkin: so is it just more compact or is it faster too ?
21:49:59 <ddarius> f4hy: That entirely depends on you.
21:50:08 <pumpkin_> more compact
21:50:13 <pumpkin_> probably not faster, but depends what you do
21:50:21 <wli> pumpkin: Your ARM stuff kinda-sorta inspired this idiot interpreter.
21:50:24 <SamB> imagine it depends on the CPU ...
21:50:27 <jfredett> f4hy: depends on how much you work at it, if you keep going at the rate you're going, could be a few weeks, could be a few months.
21:50:32 <pumpkin_> wli: :o
21:50:45 <pumpkin_> wli: what idiots does it interpret?
21:50:56 <jfredett> f4hy: just start thinking about how to implement it functionally, and try to learn haskell with that project goal in mind.
21:51:00 <SamB> interpreting idiots is an ambitious project
21:51:20 <pumpkin_> SamB: more on what you're trying to do... if you do floating point, you can't do it in thumb, so you have to call emulation functions which are deathly slow
21:51:27 <wli> pumpkin: Basically I couldn't hammer out an interpreter for a real language, so I interpreted an ARM-ish asm-like thing.
21:51:38 <jfredett> f4hy: took me about 2 months to get to the point where I could do everything but monads, another 2-3 before I really had a grasp of them (They aren't as hard as I thought)
21:51:45 <pumpkin_> often because of the more restricted regs and stuff, it'll end up being a bit slower because you need to workaround the limitations
21:51:52 <pumpkin_> wli: sounds like fun :)
21:51:57 <pumpkin_> an emulator!
21:52:08 <jfredett> once you understand that, the rest is pretty straightforward
21:52:13 <ddarius> Working around limitations is my favorite programming activity.
21:52:19 <wli> pumpkin: It'd be an emulator if I actually worked with formats.
21:52:22 <SamB> pumpkin: well, I meant do the instructions themselves run faster
21:52:29 <SamB> i.e. with more bogomips ;-P
21:52:36 <pumpkin_> lol, haven't actually checked
21:52:40 <pumpkin_> but I sort of doubt it
21:52:52 <pumpkin_> they're typically just fronts to the same back-end processing
21:53:00 <pumpkin_> the same CPU runs both thumb and arm
21:53:12 <SamB> they would if the CPU had a 16-bit data bus ;-P
21:53:12 <f4hy> Ok next question. Interfacing haskell with web apps. Is there a neat way to do that?
21:53:15 <wli> I keep getting quantified type variables escaping.
21:53:15 <pumpkin_> it just has a flag that tells it what to interpret whatever's at the PC as
21:53:18 <jfredett> f4hy: if you're dealing with that though, you'll definitely find RWH more helpful.
21:53:24 <wli> f4hy: hApps
21:53:33 <jfredett> f4hy: Uhm, I'm not entirely sure, but hApps seems to be the standard
21:53:36 <jfredett> I'm not a web guy...
21:53:44 <wli> pumpkin: Jazelle ...
21:53:48 <f4hy> jfredett: me either.
21:53:51 <ddarius> HAppS is certainly not "the standard"
21:53:53 <pumpkin_> wli: shh, it's secret!
21:53:56 <pumpkin_> wli: what about it though?
21:54:11 <jfredett> ddarius: what is then, it's the only one I've heard of substantially...
21:54:23 <wli> pumpkin: There's a third format, so there's more than one bit floating around.
21:54:31 <pumpkin_> yeah :)
21:54:34 <ddarius> jfredett: There is none.
21:54:38 <pumpkin_> but we don't speak about jazelle
21:54:46 <SamB> wli: why isn't it caled HAND?
21:54:46 <pumpkin_> cause ARM is too secretive about it
21:54:59 <jfredett> ddarius: well, by standard, I meant to imply that it was the most commonly used.
21:55:07 * wli comes to the conclusion that he can't even write interpreters for languages approximately as stupid as assembly.
21:55:08 <ddarius> jfredett: That's not the case either.
21:55:13 <jfredett> obviously it was just a poor choice of words.
21:55:27 <jfredett> ddarius: not judging by the haskell subreddit.
21:55:40 <ddarius> jfredett: Don't believe what you read on the internet.
21:55:50 <f4hy> But this is the internet, and I am reading it
21:55:53 <SamB> ddarius: so where should he believe what he reads about it ?
21:55:55 <wli> SamB: It needed a 'J' in the name because it's Java bytecode.
21:55:56 <pumpkin_> wli: why not?
21:56:03 <SamB> wli: oh
21:56:04 <jfredett> ddarius: I don't believe you.
21:56:09 <pumpkin_> it's supposed to be awesomely fast
21:56:11 <wli> pumpkin: Because I just tried and failed.
21:56:12 <SamB> that's a pretty strange thing for a CPU to read
21:56:26 <pumpkin_> but you need to pay big bucks to get the specs to write bxj code
21:56:39 <pumpkin_> or rather, to figure out how the callbacks etc. work
21:56:48 <pumpkin_> SamB: yup :)
21:57:07 <wli> pumpkin: It's even less complex than ARM, e.g. no barrel shifting.
21:57:32 <pumpkin_> well yeah, the instructions themselves are just java bytecode, but java needs to call you back sometimes
21:57:43 <pumpkin_> you need to give it information
21:58:09 <pumpkin_> and ARM (the company) charges lots of money for information on how that works
21:58:43 <f4hy> jfredett: does one need to understand monads to write useful code? or is it just like an amazing tool that will make everything easier if you did use it
21:58:48 <wli> I'm apparently too big of a dunce wrt. the type system to write a parser for the asm.
21:58:55 <wli> f4hy: Amazing tool.
21:59:16 <jfredett> f4hy: yes and no- at the very least, to write code which can stand alone, you need to be able to work in the IO monad a bit
21:59:22 <wli> All kinds of quantified type variables escaping on me.
21:59:46 <f4hy> wli: jfredett: thanks!
21:59:57 <jfredett> f4hy: np
22:00:01 <jfredett> happy to help.
22:00:06 <ddarius> Oh for the days when people didn't think of monads as some special magical thing.
22:00:41 <jfredett> ddarius: I don't think they're all that magical (anymore), they are pretty cool, but certainly not magical.
22:00:45 <f4hy> ddarius: I think lots of things in haskell are deep evil magic and I have not even gotten to monads
22:01:01 <wli> It took me 10 years to get a grip on them, so I don't hold it against people.
22:01:17 <f4hy> but I run xmonad, so thats the same thing as understanding moands, right?...
22:01:32 <jfredett> f4hy: oh- we all are satanists, you learn about that in chapter 13 of RWH.
22:01:41 <wli> (granted I wasn't trying very often over the course of those 10 years)
22:01:48 <jfredett> f4hy: you have to sell your soul to satan to use Arrows.
22:01:51 <f4hy> jfredett: data structures?
22:01:55 <ddarius> jfredett: I'm more complaining about the mystique they have acquired.
22:02:50 <jfredett> f4hy: data structures in haskell are like kittens with machineguns. Freaking Awesome.
22:03:11 <jfredett> ddarius: I suppose.
22:04:23 <pumpkin_> I really need to split up this file
22:04:29 <pumpkin_> it's just under 1000 lines now
22:04:47 <ddarius> pumpkin: I had a function once that was just under 1000 lines.
22:04:53 <pumpkin_> wow :)
22:05:20 <jfredett> ddarius: holy shit.
22:05:41 <pumpkin_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1976#a1976 w00t, the output of my "pretty" printer
22:06:33 <pumpkin_> soon I can start adding more logic to it
22:06:50 <pumpkin_> so it won't gobble up the data at the end of the function as code, for example
22:07:30 <jvogel> nice
22:08:44 <srush_> so I'm having an issue with Reactive
22:08:58 <srush_> mappend eating events
22:09:12 <pumpkin_> mmorrow: you around?
22:09:15 <B_G> haha clay
22:09:22 <sweets69694u> it suppose to show every on the right
22:09:26 <sweets69694u> i dont know why it doesnt
22:09:34 <sweets69694u> i seee bg
22:09:37 <B_G> i dont seeu on the side but i see u typin
22:09:47 <pumpkin_> @where ops
22:09:47 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
22:09:47 --- mode: ChanServ set +o shapr
22:09:48 <sweets69694u> imma have to fix that glitch
22:09:54 <sweets69694u> let me open voice
22:09:55 --- kick: sweets69694u was kicked by shapr (Kicked by shapr)
22:09:59 --- kick: B_G was kicked by shapr (Kicked by shapr)
22:14:13 <Gracenotes> well then.
22:16:06 <jfredett> Gracenotes: well then indeed.
22:16:20 <dolio> That was new.
22:16:20 --- mode: ChanServ set +o glguy
22:16:20 --- mode: glguy set -o+d glguy Jesus?Christ
22:16:49 <pumpkin_> what's +d?
22:17:14 <glguy> ban on gecos name
22:20:31 <jberryman> can anyone point me to information about the "hedge-union" algorithm used in Data.Map?
22:27:29 <dancor> there is no function to go from tagSoup tags back to an html string?  am i doing-it-wrong for wanting that?
22:28:25 <srush_> stop doing it wrong
22:29:07 <dancor> omg
22:30:00 <Twey> dancor: I think TagSoup is meant to be one-way
22:30:09 <lispy> dancor: tell us why you need it, and maybe we can suggest a better way?
22:30:27 <Twey> It's like Python's BeautifulSoup: it's designed for quick scraping, to help you 'get the data and get out'
22:30:46 <dancor> i'm making a page highlighter, it takes some url and some word as get params, grabs the url page, and highlights where the word appears
22:31:01 <dancor> tagsoup seemed good since the url could be wack
22:31:21 <Twey> I think you probably just want a string replace there
22:31:38 <Twey> You don't really care about the content or structure of the page
22:31:40 <dancor> Twey: well i wanted to not mangle the html..
22:31:59 <Twey> You wouldn't be mangling it (TagSoup would modify it more)
22:32:06 <dancor> if the word is a or br
22:32:25 <Twey> Oh, yeah, point
22:32:36 * Twey ponders.
22:32:55 <dancor> i'm ok with tagsoup doing (probably-)non-page-changing source-mangling
22:33:20 <Twey> Well, if it's buggered up enough that you need TagSoup, there's no telling what a change might do to browsers really
22:33:25 <dancor> i guess i'll write an untagsoup :: [Tag] -> String and see what happens..
22:34:58 <Twey> I think it would be easier and better to make a lightweight parser that does nothing except determine whether or not you're currently inside a tag
22:35:09 <Twey> At a given point in the stream
22:40:04 <srush_> so no reactive people in
22:40:11 <MyCatVerbs> Don't forget to make sure you recognize SGML comments and CDATA sections properly, lest unpleasant things happen.
22:40:21 <srush_> I'll send an email I guess
22:40:41 <f4hy> I think haskell broken my brain I cant do my real work now
22:42:57 <pumpkin_> is there a limit to the number of parameters a data constructor can take?
22:43:07 <pumpkin_> or could I in theory make one that takes 1000 parameters?
22:43:16 <pumpkin_> I assume it just makes something struct-like out of it?
22:43:25 * dancor knows a way to find out..
22:43:48 * dancor is now racing against ppl-already-knowing
22:49:07 * dancor should have doubled the number each iteration..
22:49:25 <jfredett> dancor: yep. :P
22:49:38 <jfredett> binary search ftw.
22:50:58 <int-e> hehe. okay ... something like that had to happen eventually. (with data X a = X a a ... {64k copies of a} ... a a, ghci complains about a BCO becoming too large)
22:51:13 <pumpkin_> wow :)
22:51:19 <jfredett> hehe. cool.
22:51:45 <jfredett> perhaps it indexes constructors w/ a 16bit word?
22:51:59 <jfredett> I mean, 64k ~ 2^16, right?
22:52:06 <pumpkin_> yup
22:52:21 <pumpkin_> but that might just be a ghci bytecode issue
22:52:38 <jfredett>  pumpkin_ maybe...
22:53:06 <dancor> it's funny, compiler gets a slower earlier with data A = A1 | A2 | .. than with data X = X a a ..
22:53:11 <jfredett> what about different types ? eg data X a0, data X a0 a1, ...
22:53:27 <dancor> gets pretty slow with 32k, still waiting to get past it
22:53:42 <pumpkin_> you using TH?
22:55:23 <dancor> it's clearly doing a lot more than just making an enum..
22:55:40 <dancor> not sure what tho
22:57:04 <jfredett> I hope they have a snow day tomorrow, I don't want to wake up... :/
22:57:40 <jfredett> in any case, goodnight folks, have fun attempting to break GHC in new and evil ways.
22:57:44 <int-e> dancor: it will be creating a function for each constructor.
22:57:50 <dancor> oh ya
23:09:51 <te> Hello all
23:09:54 <te> I am trying to install yi
23:10:03 <te> I have 6.10
23:12:26 <te> Anyone there?
23:13:07 <dancor> te: i used cabal-install to install yi on ghc 6.10>(
23:13:12 <dancor> 6.10.1 rather
23:14:16 <te> ah that might be the best optin
23:14:18 <te> option
23:14:25 <te> i was trying to use the Darcs repo
23:14:37 <te> im compiling gtk2hs right now
23:16:08 <maxote> ?roadmap
23:16:08 <lambdabot> Unknown command, try @list
23:16:20 <te> cabal: alex version >=2.0.1 && <3 is required but it could not be found.
23:16:37 <te> cabal install alex?
23:16:48 <te> ah there we go
23:17:03 <te> d'oh
23:17:09 <te>     Module `Text.Regex.TDFA.TDFA' does not export `patternToDFA'
23:17:47 <mle> that package just updated btw
23:18:01 <te> any ideas on what i should do?
23:19:10 <mle> yeah, after updates I'm seeing the same problem... hmmmm
23:19:20 <mle> let's try the previous one...
23:19:27 <te> how do i roll back?
23:19:59 <mle> cabal install regex-tdfa==0.97.4
23:20:13 <mle> may need a --reinstall in there
23:20:39 <mle> hm, doesn't fix it for me
23:20:41 <te> here goes...
23:20:48 <te> yah, no dice
23:20:59 <te> ls
23:21:08 <te> ^^xmonad casualty
23:21:27 <mle> xmonad casualty?
23:21:43 <te> just making light of the autofocus on a window depending on where my cursor is
23:21:51 <te> i am constantly typinng ls in my irc window :)
23:21:55 <mle> ahhhhh, right
23:21:55 <te> typing*
23:22:37 <kniu> what's that thing that turns expressions into point-free form again?
23:22:48 <te> mle: if you figure out what's going on please let me know
23:23:00 <te> i loved the idea of yi and just got a little time to sit down and install it
23:23:04 <wli> This stupid assembly interpreter is really mindless.
23:23:19 <mle> te: sure... just starting to look at it myself
23:25:24 <int-e> kniu: @pl
23:25:33 <kniu> ah
23:25:34 <wli> The entire thing is boilerplate.
23:25:55 <kniu> @pl filter (not . or . (\x -> [isNaN x, isInfinite x, x < magic]) . fst)
23:25:55 <lambdabot> filter (not . or . liftM2 (:) isNaN (liftM2 (:) isInfinite (return . (< magic))) . fst)
23:26:01 <kniu> oy
23:26:16 <wli> Most of the code is me being an idiot about how to abstract things meaningfully.
23:26:26 <kniu> no way to get rid of that lambda, eh?
23:26:50 <wli> lambdabot just showed you how.
23:26:58 * maxote in home, i want a supercomputer of 1000 processors at 10 GHz, 100 TFTs 1920x1200, many hundreds of TiB of RAMs and many thousands of hard disks. I only want an easy visualization of a DFA in real time :)
23:27:16 <int-e> @type sequence [isNaN, isInfinite, (< magic)]
23:27:17 <lambdabot> Not in scope: `magic'
23:27:21 <Cale> You could use sequenc...
23:27:22 <int-e> @type sequence [isNaN, isInfinite, (< ?magic)]
23:27:23 <lambdabot> forall a. (?magic::a, RealFloat a) => a -> [Bool]
23:27:29 <Cale> (too late ;)
23:29:45 <int-e> @type flip map ?fs . flip id
23:29:46 <lambdabot> forall a c. (?fs::[a -> c]) => a -> [c]
23:29:52 <kniu> :t sequence
23:29:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:30:00 <kniu> whuh
23:30:11 <wli> Regexes and CFL's are too simplistic. CSL's might be a more interesting project.
23:30:38 <kniu> but those functions aren't monads.
23:31:23 <int-e> kniu: (->) r   is a monad: you can think of it as doing computations in a read-only context (r). It's called the reader monad.
23:31:34 <te> mle im stumped man
23:31:40 <wli> I'm not even sure how one would start on a CSL/CSG parser.
23:32:00 <mle> te: not familiar with that lib; thought they might have meant patternToRegex
23:32:01 <kniu> huh
23:32:09 <int-e> kniu: and for that monad, sequence has type [r -> a] -> r -> [a]
23:32:43 <te> mle: oh well nevermind
23:32:46 <int-e> (the instance is exported from Control.Monad.Instances module, and from Control.Monad.Reader)
23:33:04 <wli> OTOH I probably can't write DFA stuff anymore, never mind stack machine bits.
23:33:06 <mle> te: there is a #yi channel...
23:34:23 <te> mle: do you have gtk2hs installed?
23:35:29 <mle> te: no; i've been using the vty version
23:35:34 <wli> I'm on elliptic curve #17/50000 for 2^(2^9)+1
23:35:47 <mle> as building gtk is a can of worms I'm not eager to tackle
23:36:53 <f4hy> > [1..]
23:36:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:40:36 <ski_> > [0,1 .. 1 / 0]
23:40:37 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
23:40:58 <ski_> > [0,1 .. (-1) / 0]
23:40:59 <lambdabot>   []
23:41:04 <ski_> > [0,1 .. 0 / 0]
23:41:06 <lambdabot>   []
23:41:32 <ski_> interesting
23:41:42 <dolio> > sort [0,1,0/0,1/0,-1/0]
23:41:43 <lambdabot>   [-Infinity,0.0,1.0,Infinity,NaN]
23:41:46 <dolio> > sort $ sort [0,1,0/0,1/0,-1/0]
23:41:47 <lambdabot>   [NaN,-Infinity,0.0,1.0,Infinity]
23:41:54 <dolio> > sort . sort $ sort [0,1,0/0,1/0,-1/0]
23:41:55 <lambdabot>   [-Infinity,0.0,1.0,Infinity,NaN]
23:42:31 <ski_> `sort' is not `id' on sorted lists, apparently
23:42:43 <maxote> > reverse [0..]
23:42:49 <dolio> Thanks, IEEE!
23:42:54 <ski_> see what trouble objects which are not identical to themselves bring !
23:43:19 <maxote> > reverse [0..]
23:43:43 <ski_> > [1/0,1/0 - 1 .. 0]
23:43:53 <lambdabot>   []
23:44:04 <ski_> ?
23:44:17 <ski_> > [1/0,1/0 - 1 ..]
23:44:25 <lambdabot>   [Infinity,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,N...
23:44:34 <maxote> > reverse [0..]
23:44:35 <ski_> !
23:44:38 <dolio> > [5, 5 .. 0]
23:44:44 <Gracenotes> > reverse [LT ..]
23:44:58 <dancor> more like lagbot
23:44:58 <lambdabot>   [GT,EQ,LT]
23:45:26 <ski_> @load
23:45:32 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
23:45:42 <Gracenotes> lambdabot + lag = lagdabot
23:45:46 <dolio> Anyhow, [5,5..0] = [].
23:45:52 <ski_> Gracenotes : agda ?
23:45:56 <dancor> > NaN < -Infinity
23:46:02 <lambdabot>   Not in scope: data constructor `NaN'Not in scope: data constructor `Infinity'
23:46:12 * ski_ thinks an agdabot might be fun
23:46:23 <dancor> it was allfornan.
23:46:30 <ski_> > 0/0 < (-1)/0
23:46:31 <pumpkin_> that would be fun
23:46:32 <lambdabot>   False
23:47:01 <ski_> > 0/0 >= (-1)/0
23:47:02 <dancor> as long as it's not also agdanizingly slow
23:47:02 <lambdabot>   False
23:47:22 <Twey> *groooan*
23:47:27 <ski_> > 0/0 `compare` (-1)/0
23:47:28 <lambdabot>       No instance for (Fractional Ordering)
23:47:28 <lambdabot>        arising from a use of `/' ...
23:47:37 <ski_> > (0/0) `compare` ((-1)/0)
23:47:39 <lambdabot>   GT
23:47:40 <maxote> > [0..]
23:47:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:47:50 <ski_> > 0/0 > (-1)/0
23:47:51 <lambdabot>   False
23:47:53 <ski_> !
23:49:02 <ski_> @check \x y -> x > y && GT /= (x `compare` (y :: Double))
23:49:04 <lambdabot>   "Falsifiable, after 0 tests:\n-1.5\n-1.5\n"
23:49:57 <ski_> @check \x y -> (x > y) == (GT == (x `compare` (y :: Double))) -- i meant
23:49:58 <lambdabot>   "OK, passed 500 tests."
23:50:50 <f4hy> Yay, I just checked and my web host has GHC installed
23:51:12 <pumpkin_> that's nice of them
23:51:14 <pumpkin_> what version?
23:51:42 <Gracenotes> 500 tests? Nay, we shall test until there is a false result.
23:52:21 * Gracenotes determines this with his halting machine
23:52:29 <pumpkin_> nice
23:52:42 <pumpkin_> let oracle x = ...; profit
23:53:15 <ski_> (surely s/;/ in/ ?)
23:53:26 <pumpkin_> oh yeah
23:54:32 <pumpkin_> what's a good namespace/module hierarchy for my ARM library?
23:56:36 <Gracenotes> anything that doesn't cost you an ARM and a leg
23:57:09 <wli> pumpkin: Maybe there are oracle.com employees about. ;)
23:57:30 * pumpkin_ groans
23:57:34 <pumpkin_> at both!
23:57:50 <wli> Control.Monad.ARM?
23:58:29 <pumpkin_> not sure it's a monad
23:58:31 <Gracenotes> it's not just a general monad though...? It also has rather specific logic
23:58:41 <wli> Data.ARM?
23:58:41 <pumpkin_> I haven't made it into a monad, anyway
23:58:43 <Gracenotes> from what I understand of pumpy talkin bout it
23:58:48 <pumpkin_> I was thinking of that
23:59:01 <ski_> Body.ARM.Left
23:59:06 <pumpkin_> Data.Architecture.ARM? but it feels weird to make a new level
23:59:12 <pumpkin_> but it'd be nice to see more of them start appearing
23:59:16 <wli> Sounds reasonable as well.
23:59:26 <Gracenotes> what other Architecture modules would we have?
23:59:42 <Gracenotes> assembly stuff?
23:59:46 <pumpkin_> x86 :P MIPS, SPARC, PPC?
23:59:49 * wli is beyond stumped as to what his typechecking troubles with parsing are.
23:59:52 <Gracenotes> would that go in Language.ARM?
23:59:52 <pumpkin_> who knows!
23:59:56 <mathijs> I have a list of tuples(Integer, Integer) that I need to turn into a list of Integers. the order is a bit strange though: [(a,b),(c,d),(e,f)] -> [a,c,e,f,d,b]. is there a nice way to do this? I currently use "map fst xs ++ reverse (map snd xs)", but I would like to do this without ++ and walking the list 3 times.
23:59:57 <ski_> 6502 !
