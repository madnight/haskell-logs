00:01:43 <quicksilver> although they're partial ds not real ds
00:02:12 <ski> no difference, here
00:02:37 <ski> (since `x0',`x1',`x2' are local, with no relations constraining them)
00:03:57 <quicksilver> sure; cads_'s version was less unambigous though.
00:04:42 <ski> (imnsho) cads_'s version was ambiguous/wrong
00:05:01 <ski> where does `x1',`x2',`x3' come from ?
00:05:42 <cads_> it was
00:05:50 <cads_> completely made up notation
00:06:10 <cads_> where did R^3 come up for example
00:06:24 <ski> that in itself is not so bad as not containg the required information
00:07:34 <cads_> d f x0 =  d f (x0,x1,x2) / d x0
00:07:36 <ski> (the main problem stems from lots of math teaching being very wavy on the difference between an expression, depending on some variables, and a function)
00:08:16 <cads_> throw operators into the mix and things get trickier :D
00:09:28 <ski> cads_ : please compute `d (x2^2 - x1*y3^3) x0' for me
00:09:54 <ski> cads_ : or take `d ((y3,y3) |-> (x2^2 - x1*y3^3)) x0', if you want `f' to be a function
00:10:00 <toliko_smoren> if i call the same function with the same parameters in two different places in my code will the compiler optimize that, that is it ok to do that?
00:10:11 <ski> (sorry, s/(y3,y3)/(y3,y4)/, i meant)
00:10:23 <Pip> Which tutorial or book is the best start for a novice
00:10:34 <cads_> ski, in the first part, x0 is not used in the function
00:10:35 <ski> toliko_smoren : it may, and it may not
00:10:43 <toliko_smoren> ski:what does it depend on?
00:11:11 <ski> cads_ : so ?  i can define `f(x0,x1,x2) = x1 + 3*x^2' (for all `x0',`x1',`x2')
00:12:29 <ski> i can also define `f(x1,x0,x2) = x0 + 3*x^2' (for all `x0',`x1',`x2') .. in fact, this defines the *same* function `f'
00:12:36 <quicksilver> toliko_smoren: if the parameters are 'statically the same'
00:12:47 <quicksilver> toliko_smoren: for example, they are themselves top-level constants
00:12:49 <cads_> also I am confused about you use of y in the first one
00:12:55 <quicksilver> and don't depend on dynamic parameters of functions
00:13:09 <quicksilver> then it is overwhelming likely GHC will float the whole call to the top and share it.
00:13:13 <ski> cads_ : `y3' there is what is termed a "parameter"
00:14:30 <ski> cads_ : my examples are meant to show why talk of differentiating a function wrt `x0', or for that part, taking the derivative of an expression, is nonsense
00:14:47 <cads_> ski, in your exacmple, x should not be there alone, it needs to be one of {x0,x1,x2}
00:15:27 <cads_> yeah the d function in this case must be the partial derivative operator
00:15:35 <ski> cads_ : you can differentiate an expression wrt a variable (which may or may not occur in the expression, and which may or may not have variables depending on it in the expression). e.g. `d (x^2*y - 3*x* y^3) / d x'
00:16:17 <ski> cads_ : you can also take the derivative of a function, such as `D f' or `D (\x -> x^2*y - 3*x* y^3)'
00:17:35 <ski> cads_ : why would `x' need to be one of `x0',`x1',`x2' ?
00:17:58 <styx_mp> map $ succ "trofi^w"
00:18:02 <cads_> we're taking that f is a scalar field, which is function of multiple variables, which we note (x1,x2,x3,...,xn)
00:18:18 <styx_mp> map succ "trofi^w"
00:19:34 <cads_> we can take the partial derivative.   partial f/ partial x1
00:19:40 <ski> and why can't i use `x', as an additional parameter ?
00:20:53 <styx_mp> > map succ "trofi^w"
00:20:55 <lambdabot>   "uspgj_x"
00:21:32 <ski> (cads_ : btw, i agree with your notation here, so far ..)
00:22:39 <cads_> so we could write f = x1 + x2 - 3*x_3^666.        f + x?   or f = x1 + x2 - 3*x_3^666 + x
00:23:21 <cads_> ski, I think I am getting where you're going with it
00:23:43 <ski> (is that so ?)
00:24:29 <cads_> I'd say that for the definiton of your scalar field f, if you wanted an additional parameter it would be name x_{n+1}
00:25:03 <cads_> eee, the definition of _my_ scalar field f
00:25:47 <cads_> the field has it own set of parameters built in
00:26:21 <cads_> but is of whatever dimensionality that you want it to be
00:28:41 <ski> well, maybe i wanted to name my parameter something that doesn't imply some connection to the existing `x_i' for `i' in `{1..n}'
00:29:20 <lispy> I just heard about dobblego
00:29:31 <lispy> Does anyone here know him and is able to help find him?
00:29:39 <lispy> http://www.nabble.com/-scala--URGENT%3A-Please-read-if-you-have-any-information-about-Tony-Morris-to22462911.html
00:30:09 <lispy> I know he frequented this channel a lot
00:31:33 <ski> lispy : NickServ says last seen yesterday
00:32:07 <ski> (cads_ : if you were to claim that your `f' is a function, i would protest)
00:36:04 <cnwdup> @pl (\fn -> (catMaybes `fmap`) $ forM fns $ \(fn -> return (Just fn)))
00:36:04 <lambdabot> (line 1, column 46):
00:36:04 <lambdabot> unexpected "-"
00:36:04 <lambdabot> expecting operator or ")"
00:36:30 <cnwdup> @pl (\fn -> (catMaybes `fmap`) $ forM fns (return . Just))
00:36:30 <lambdabot> const (catMaybes `fmap` forM fns (return . Just))
00:36:42 <cnwdup> @pl (\fns -> (catMaybes `fmap`) $ forM fns (return . Just))
00:36:42 <lambdabot> (catMaybes `fmap`) . flip forM (return . Just)
00:41:03 <cads_> I am looking at some of the acrobatics the del operator goes through
00:41:54 <Pip> Anyone uses Scite editor ?
00:41:57 <cads_> curl v = del X v
00:42:38 <cads_> more like curl v = del `X` v
00:43:46 <cads_> in this case del has to be a vector that can do the vector product
00:48:46 <cads_> div = del `dot` v
00:49:58 <cads_> I thihnk I need to create some vector calculus types
00:51:36 <quicksilver> cads_: you should investigate automatic differnentiiation, it's neat
00:51:43 <quicksilver> there should be a couple of blog posts about it.
00:52:02 <cads_> yeah, I've read a bit about it :D
00:52:20 <ski> (i think to make sense of those equations, one possibly needs to talk about vector spaces over other fields than reals (or complices))
00:52:25 <cads_> i think there are even methods for partial differential equations which is pretty cool
00:53:50 <cads_> but I don't think i have the type for a vector of operators that I can dot-product with a vector of functions
00:54:43 <quicksilver> arguably that's more of a "dot-apply" than a dot product.
00:54:55 <quicksilver> note that vectors are a natural Applicative.
00:55:16 <quicksilver> (f,g,h) <*> (x,y,z) = (f x,g y, h z)
00:55:42 <cads_> nice
00:56:16 <cads_> what is <*>? a kind of construction apply?
00:56:58 <cads_> http://en.wikipedia.org/wiki/Del check out this pages for a some the stories of del's super abilities
00:57:05 <cads_> quite a charachter, I think
00:58:06 <Trinithis> Is there a better way to do this: @ty \x y -> if ((&&) `on` isJust) x y then Just ((max `on` fromJust) x y) else x `mplus` y
00:58:24 <cads_> I'm wondering if we can well type these behaviours, or if it's just a slightly methodical madness
00:58:28 <Trinithis> (w/o the ty i left in there)
00:59:24 <ski> @type (<*>)
00:59:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:00:40 <Trinithis> > Just max <*> Just 3 <*> Just 5
01:00:41 <lambdabot>   Just 5
01:00:45 <Trinithis> thanks
01:00:50 <Trinithis> > Just max <*> Just 3 <*> Just 1
01:00:51 <lambdabot>   Just 3
01:01:10 <Trinithis> > max <$> Just 3 <*> Just 14
01:01:11 <ski> (Trinithis : that was inadvertent ..)
01:01:12 <lambdabot>   Just 14
01:01:29 <Trinithis> ahha
01:01:46 <ski> also
01:01:52 <ski> > Just max <*> Just 3 <*> Nothing
01:01:53 <lambdabot>   Nothing
01:01:58 <ski> which was not what you wanted
01:02:01 <Trinithis> oh
01:03:19 <ski> > [msum [liftM2 max x y,x,y] | x <- [Nothing,Just 3] , y <- [Nothing,Just 14]]
01:03:20 <lambdabot>   [Nothing,Just 14,Just 3,Just 14]
01:03:55 <Eridius> Trinithis: if a is bounded you could try something like (max `on` maybe minBound id)
01:04:09 * ski wonders whether `ieither' can be related to this
01:04:15 <Eridius> @ty max `on` maybe minBound id
01:04:17 <lambdabot> forall a. (Bounded a, Ord a) => Maybe a -> Maybe a -> a
01:04:21 <Trinithis> a is bounded
01:04:24 <Trinithis> for me
01:04:29 <Eridius> although that will always return a number
01:04:33 <Eridius> even if both x and y are Nothing
01:04:55 <ski> (also, it will not give a result in `Just a' ..)
01:05:07 <Eridius> ski: that's what I just said
01:05:22 <ski> (sorry, `Maybe a', i meant)
01:07:10 <Eridius> you could use a newtype and declare an instance of Monoid?
01:07:29 <Trinithis> Ill just define a custom mplusOn function or something
01:07:46 <Trinithis> or mplusBy rather
01:08:22 <ski> how would you write the expression above, given such a `mplusBy' ?
01:08:50 <Trinithis> errr... I guess just for Maybe and give it a better name
01:10:02 <ski> (the question was not rhetoric)
01:11:15 <Eridius> \x y -> case (x, y) of (Just x', Just y') -> Just $ max x' y'; otherwise -> x `plus` y
01:11:29 <Trinithis> :t \chooser x y listToMaybe $ chooser $ maybeToList x ++ maybeToList  y
01:11:30 <Eridius> not much cleaner, but at least theres' no if
01:11:30 <lambdabot> parse error on input `$'
01:12:03 <Trinithis> :t \chooser x y -> listToMaybe $ chooser $ maybeToList x ++ maybeToList  y
01:12:04 <lambdabot> forall a a1. ([a1] -> [a]) -> Maybe a1 -> Maybe a1 -> Maybe a
01:12:16 <Pip> Is the 1st item of videos available ?
01:12:21 <Pip> http://haskell.org/haskellwiki/Video_presentations
01:13:24 <Trinithis> > (\chooser x y -> listToMaybe $ chooser $ maybeToList x ++ maybeToList  y) (if' null (const []) maximum) (Just 3) (Just 5)
01:13:25 <lambdabot>   Not in scope: `if''
01:13:43 <Trinithis> gah
01:13:58 <Eridius> that seems fairly berbose
01:14:10 <Eridius> rather, it seems even worse than your original ;)
01:14:11 <ski> @let if' false true False = false; if' false true True = true
01:14:12 <lambdabot>  Defined.
01:14:13 <Trinithis> i know
01:14:48 <Trinithis> oh well.
01:15:18 <Eridius> @pl \f a b c -> f c a b
01:15:18 <lambdabot> (flip .) . flip
01:15:36 <Eridius> @pl \f a b c -> f c b a
01:15:36 <lambdabot> flip . (flip .) . flip
01:23:07 <swiert> Is it me, or can you no longer upload files to the haskell wiki?
01:24:11 <Pip> swiert, I found I couldn't reach this video: http://blip.tv/file/324976 ,can you ?
01:24:51 <swiert> Pip: seems to work for me.
01:25:02 <Pip> How large is it please ?
01:25:16 <Pip> Then it's the domain problem to me
01:26:03 <Pip> swiert, And do you use Scite editor for haskell ?
01:26:38 <swiert> I've never used SciTe.
01:26:56 <wli> I've never even heard of it.
01:27:44 <Pip> wli, Emacs ?
01:28:06 <ski> wli : SYN
01:28:29 <wli> ski: Beg pardon?
01:28:37 <wli> Pip: nvi, old-school vi.
01:28:48 <Pip> I see
01:29:07 <wli> Pip: Sometimes ed when nvi isn't behaving faithfully enough.
01:29:25 <ski> (wli : you're supposed to answer `SYN ACK', and then i say `ACK', thereby establishing a communication link)
01:29:29 <ski> <wli> ski: Which is another use of eval?
01:30:07 <wli> ski: You mentioned something to do with eval I've since forgotten?
01:30:24 <p_l> ski: on IRC I'd think you rather used terminal signals...
01:30:33 <ski> <ski> wli : oh .. that's another use of `eval :: Monad m => (a -> m a) -> (m a -> m b)' :)
01:31:12 <wli> ski: I'm not entirely enlightened.
01:31:14 <ski> wli : consider a language which has variables, represented by a data type like
01:31:20 <ski>   data Expr var = Var var
01:31:21 <wli> Sure.
01:31:36 <ski>                 | Add (Expr var) (Expr var)
01:31:42 <ski>                 | Lit Integer
01:31:50 <ski> then you can define
01:31:56 <ski>   return :: var -> Expr var
01:31:59 <quicksilver>  /win 37
01:32:00 <ski>   return v = Var v
01:32:02 <quicksilver> :(
01:32:12 <ski>   join :: Expr (Expr var) -> Expr var
01:32:21 <ski>   join (Var expr) = expr
01:32:37 <ski>   join (Add expr0 expr1) = Add (join expr0) (join expr1)
01:32:42 <ski>   join (Lit n) = Lit n
01:32:55 <ski> so (checking laws) you get a monad `Expr'
01:33:02 <ski> this is called an "expression monad"
01:33:07 <wli> I remember that monad from springschool95.ps
01:33:17 <ski> if you define
01:33:25 <ski>   eval :: Monad m => (a -> m a) -> (m a -> m b)
01:33:32 <ski>   eval subst ma = do
01:33:37 <ski>     a <- ma
01:33:51 <ski>     eval subst (subst a)
01:33:58 <swiert> ski: is that type signature right? where do you get the b from?
01:34:09 <ski> then that replaces `Var' nodes by the substitution, in this monad
01:34:23 <ski> swiert : it is polymorphic in the monadic result type
01:34:49 <ski> because the resulting expression doesn't contain any `Var' nodes, it doesn't matter what variable type `b' you use
01:35:32 <ski> wli : you mentioned iterating over something until you get an exception. i realized that was also a use of this `eval' function
01:35:42 <swiert> ski: so why does this terminate?
01:35:56 <ski> it doesn't always terminate
01:36:01 <ski> it depends on `subst'
01:36:07 <wli> When there are unbound variables, it doesn't.
01:36:21 <ski> but if after repeatedly substituting, you get expressions without variables, it terminates
01:36:43 <ski> monadically, `a <- ma' here means "enumerate all the free variables `a' in `ma' for me"
01:37:01 <ski> if there's no free variables in `ma', it short-circuits
01:37:24 <ski> just like the list-, maybe-, either- monads short-circuits in similar situations
01:37:46 <ski> swiert : clear ?
01:38:54 <ski> (it's just that for `Maybe',`[]', `eval' is not very useful .. wli made me realize/remember that for `Either e' it is useful)
01:39:41 <ski> (btw, if you have a better suggestion for name than `eval' i would like to hear it)
01:40:06 <quicksilver> marshmallow?
01:40:21 <ski> *"better"*, i said :)
01:41:39 <p_l> dwim? :P
01:41:45 <quicksilver> it may not be useful to [], but it can be useful for monads over []
01:41:53 <ski> ("do what i mean")
01:41:55 <ski> *nod*
01:42:38 <p_l> though I think "vodka" is better :>
01:42:40 <quicksilver> given a monad over [], it means " keep running subst over all live sparks until there are none left"
01:43:06 <swiert> ski: so in this monad >>= corresponds to substitution;
01:43:10 <quicksilver> ...the point being to accumulate whatever sideffects are caused by the running
01:43:22 <ski> swiert : aye
01:43:25 <swiert> ski: and eval is taking the fixed-point of substitution.
01:43:30 <ski> right
01:43:33 <wli> I've still not figured out Okasaki's breadth-first labeling algorithm.
01:43:40 <ski> (more or less)
01:44:03 <ski> (you could have defined `eval :: Monad m => (a -> m a) -> (a -> m b)' instead ..)
01:44:13 <wli> fix (>>= subst)
01:44:30 <ski> @type \subst -> fix (subst =<<)
01:44:31 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
01:44:52 <ski> oh, right
01:45:03 <ski> not quite fixed-point
01:45:08 <quicksilver> ski: I wonder if it's more natural as an operation on arrows?
01:45:19 <wli> fix . (=<<)
01:46:01 <quicksilver> eval :: (a -> m a) -> (b -> m a) -> (b -> m c)
01:46:05 <Trinithis> > (\subst -> fix (subst =<<)) (const [4,5])
01:46:05 <ski> `\subst -> fix (subst =<<)' doesn't start from an existing expression, like my version did
01:46:07 <lambdabot>   * Exception: stack overflow
01:46:16 <Trinithis> > (\subst -> fix (subst =<<)) (const [])
01:46:17 <lambdabot>   * Exception: stack overflow
01:46:21 <quicksilver> eval :: (a ~> a) -> (b ~> a) -> (b ~> c)
01:46:45 <ski> quicksilver : here i was thinking you meant `(a ~> a) -> (a ~> b)' ..
01:46:46 <quicksilver> it means "keep sticking substs on the end of any free 'a's until there are no ne left"
01:46:53 <swiert> quicksilver: no. substitution is definitely monadic.
01:47:27 <osfameron> ah, I was looking at http://blog.sigfpe.com/2006/11/variable-substitution-gives.html precisely yesterday :-)
01:47:45 <swiert> monads where used to describe this kind of thing (syntax of terms with free variables) long before Moggi used them in the semantics of effects.
01:48:53 <ski> hm .. can you reconcile this idea with bound variables, as well ?
01:49:18 <ski> i.e., how do i stick a `Let' construction into the data type above ?
01:49:22 <wli> Yes. springschool95.ps shows how in detail.
01:49:31 <ski> where is that ?
01:49:51 <wli> The filename googes. citeseer has it, too.
01:50:13 <swiert> ski: yes. but you'd need nested data types.
01:50:34 <swiert> | Let Body (Expr (Maybe a))
01:50:44 <wli> Functional Programming with Overloading and Higher-Order Polymorphism
01:50:55 <swiert> where Nothing now refers to the most freshly bound var;
01:50:59 <ski> Functional Programming with Overloading and Higher-Order Polymorphism <http://citeseer.ist.psu.edu/jones95functional.html>
01:51:01 <quicksilver> swiert: well the only point I was making is that a substituation (a -> m a) is an object in the kleisli category
01:51:19 <quicksilver> swiert: and you can recast eval itself into the kleisli cat if you want to
01:51:38 <ski> s/Body/Expr a/ ?
01:51:43 <wli> I'm all ears.
01:52:19 <swiert> quicksilver: it's a morphism in the kleisli category (my point was, not to look into arrows - I'm pretty sure it's monadic)
01:52:26 <ski> quicksilver : how is it an object ?
01:52:32 <swiert> ski - yep. sorry.
01:52:42 <wli> I did something like data Expr var = VarExpr var | AppExpr (Expr var) (Expr var) | LamExpr var (Expr var) | LetExpr (Map var (Expr var)) (Expr var) | ...
01:52:59 <hcube> Hi!
01:53:19 <ski>  Lo?
01:53:21 <hcube> I have a question: Is it possible to use HXT with ByteString?
01:53:35 <blackh> hcube: I don't think so.
01:53:57 <hcube> so i have to convert it back to String right?
01:54:40 <blackh> hcube: Yes.. Do you know the trick with w2c and c2w (Char to/from Word8)?
01:55:03 <blackh> hcube: It's been a little while so I hope I am giving you the right advice.
01:55:48 <blackh> hcube: Also I am biased because I maintain hexpat, an enemy XML library. :)
01:56:26 <hcube> blackh: now I'm checking hxt source if is it refers to ByteString
01:56:58 <hcube> blackh: thanks the w2c c2w tip! :)
01:59:43 <ImInYourMonad> any indians or knowledgeable people in here ? im watching slumdog millionaire but it you never get to heat what it says under the statue. i would guess "the truth alone triumphs". anyone knwo for sure?
02:06:39 <wli> I'm a little uncertain about the best way to represent tuples, records, and cases. Thus far I have:
02:07:09 <toliko_smoren> is there a way to do foldl with a function that takes just 1 argument?
02:07:24 <wli> | TupExpr [Expr var] | PrjExpr Int (Expr var) | ConExpr String [Expr var] | CasExpr (Expr var) (Map String ([var], Expr var))
02:08:36 <ski> toliko_smoren : what would you want as result ?
02:12:07 <ski> (wli : i would separate out the arguments from the `TupExpr',`PrjExpr',`ConExpr' .. but that's just me)
02:12:17 <toliko_smoren> I was wrong, I dont need that, thanks for your time, I have these 'I'm an idiot' phases
02:12:26 <wli> ski: I don't know what you mean by that.
02:12:49 <ski>   | TupExpr Int  | PrjExpr Int  | ConExpr String
02:13:02 <ski> and then use application of those on expressions
02:13:45 <ski> (i'm not sure whether that would be better or not in your case)
02:14:48 <wli> The big alternative I was considering was to get rid of separate treatment of tuples and constructors in favor of something like ConExpr String (Map var (Expr var)) | CasExpr (Expr var) (Map String (Map var var, Expr var))
02:15:58 <ImInYourMonad> why are functional langauges so popular in finance? because it is mostly about programming mathematics?
02:16:01 <ski> and then use "numeric field names" for the tuples ?
02:16:34 <wli> ski: Yeah, something disalowed except as special syntax.
02:17:36 <wli> e.g. #0, #1, #2, etc.; with row types/kinds the "nameclashes" shouldn't be problems.
02:18:25 <ski> wli : how about positional variant types ?
02:18:48 <wli> I was hoping for qualified types, higher-order H-M, plus row types for the type system.
02:19:10 <ski> ( "abc" | ) :: ( String | a )
02:19:18 <wli> ski: I was going to ignore that. Actually I'm even thinking of ignoring the anonymous tuples for the first pass.
02:19:29 <ski> ( | 'x' | | ) :: ( a | Char | b | c )
02:19:47 <ski> ok
02:19:51 <wli> ski: I have no idea what you're writing.
02:20:18 <ski> `( Foo | Bar )' would be a type similar to `Either Foo Bar'
02:20:30 <ski> except that you naturally can use as many cases as you like
02:20:40 <ski> (without having to invent new types all the time, i mean)
02:21:01 <ski> consider
02:21:02 <wli> ski: The value notation is weirder for me.
02:21:08 <ski>   data Pair a b = P a b
02:21:09 <ski> then
02:21:27 <ski>   `(,)' : `Pair' :: `(|)' : `Either'
02:21:35 <wli> I see what the value notation does. That defeats the point.
02:21:44 <ski> for a tuple value, you need to fill in all the places
02:21:53 <ski> for a variant value, you just need to fill in one of them
02:22:08 <ski> wli : defeats which point ?
02:22:32 <wli> Yeah, that part I get. The notation with |'s for values was not obvious to me.
02:23:04 <wli> ski: Being able to reuse things defined on supersets of alternatives on types with subsets of alternatives etc.
02:23:44 <ski> ok
02:23:54 <ski> (but current tuples doesn't allow that either)
02:24:15 <wli> ski: That's what the row types I'm trying to figure out are supposed to help with.
02:24:34 <wli> Or row kinds. Or whatever they are (I've still not figured that out.)
02:24:39 <ski> i'm not sure if one could have something like this work for *unlabeled* variants/tuples
02:24:51 <ski> (*labeled* is another thing, of course)
02:25:37 <wli> I'm happy to stick with labeled variants like everyone else. Unlabeled tuples are just implicitly positionally named.
02:25:59 <ski> (and unlabeled variants are just implicitly positionally named)
02:26:27 <wli> Actually they're not unless that's externally imposed.
02:27:11 <ski> you need to connect the *position* of the branches in a `case' with the variant values
02:28:43 <ski> (that probably sounded cryptic ..)
02:30:21 <wli> Use Gaussian integers as labels.
02:30:24 <ImInYourMonad> why are functional langauges so popular in finance? because it is mostly about programming mathematics?
02:31:18 <blackh> ImInYourMonad: Did you read the article called "Caml Trading" in one of the Monad Readers?
02:31:32 <ski> (wli : why ? :)
02:31:58 <wli> Anyway, I've got "Typing Haskell in Haskell" and "A Polymorphic Type System for Extensible Records and Variants" and am trying to march through it.
02:32:03 <p_l> blackh: for some reason I imagined haskell nomads on camls trading across the desert...
02:33:01 <blackh> p_l: I like that image
02:33:38 <wli> ski: The label set doesn't necessarily have a structure naturally corresponding to positions. And, for that matter, disjoint unions/coproducts can essentially dispatch on type.
02:34:50 <HugoDaniel> hi
02:35:20 <wli> The major obstacle now is figuring out what on earth row types/kinds/etc. are and how to handle them. And, I guess, decent ways to handle type schemes for qualified types.
02:35:38 <HugoDaniel> today i feel highly motivated to code in haskell... i dont know why, must be because its a sunny day and the living is easy
02:36:51 <blackh> HugoDaniel: Howza going, mate! I feel the same way, only it's got to a fairly advanced stage, and I'm addicted to Haskell.
02:37:35 <HugoDaniel> :D
02:38:19 <blackh> I've re-discovered the old magic from when I first learnt to program!
02:38:28 <HugoDaniel> eheheh
02:38:40 * wli 's brain is fried and he can't get anything done anymore.
02:38:47 <RayNbow> hmm, planet.haskell.org down?
02:39:22 <ski> (wli : i'm not sure i agree with "disjoint unions/coproducts can essentially dispatch on type" ..)
02:39:36 <ski> HugoDaniel : it is cloudy
02:40:08 <HugoDaniel> oh
02:40:11 <HugoDaniel> where are you from ski ?
02:40:32 <HugoDaniel> here is like a summer day, im planning on going to the beach in the afternoon
02:41:06 <HugoDaniel> but im from portugal... we can go surfing every single day of the year
02:41:21 <ImInYourMonad> Monad Readers?
02:41:35 <wli> ski: If they're disjoint, you can tell which case it is by which set they belong to.
02:42:07 <ski> wli : consider `A + A' .. how is that dispatching on type ?
02:42:26 <wli> ski: Not disjoint, so vacuously true.
02:42:41 <ski> `+' there is a disjoint union
02:42:41 <blackh> ImInYourMonad: http://www.haskell.org/sitewiki/images/0/03/TMR-Issue7.pdf  <-- read this - it should give some answers to your question about FP in finance
02:43:34 <wli> ski: Not the disjoint union operator. A coproduct of disjoint sets.
02:43:56 <ski> the coproduct in `Set' *is* the disjoint union operator
02:44:14 <blackh> HugoDaniel: Keep telling me about the warm weather! It's cold and dark here in New Zealand.
02:45:09 <ski> (HugoDaniel : i'm from sweden. and to be frank, i prefer it being cloudy to it being sunny)
02:45:11 <wli> ski: What I referred to by "disjoint union/coproduct" was not the operator (why would I bother mentioning it if so?) but the fact the summands in the coproduct were disjoint.
02:45:25 <HugoDaniel> ahhh, i would love to go to new zealand
02:45:44 <wli> ski: You're just being dense at this point.
02:45:44 <blackh> HugoDaniel: You can stay at my house.
02:46:16 <HugoDaniel> new zealand is The country
02:46:30 <ski> wli : (quite possibly) .. then, i'm just not seeing why the summands being disjoint is relevant here ..
02:46:32 <quicksilver> ski: yes, I misspoke, I meant morphism.
02:46:59 <blackh> HugoDaniel: Steady on! :)  Anyway, come over and we'll think of some Haskell hacking to do.
02:48:13 <HugoDaniel> :D yehh
02:48:34 <Badger> new zealand Is the country
02:49:09 <blackh> new zealand is the Country. Baaa!
02:49:30 <Badger> baa, humbug.
02:50:47 <ski> (wli : i honestly don't know what you were after. but if you prefer, we can drop it)
02:51:10 <wli> ski: Recover the labels by defining a function from the union to the label set whose restriction to each summand is its corresponding label.
02:53:05 <ErhardtMundt> hello there
02:53:52 <ErhardtMundt> i have a little trouble with my dumb server script
02:54:00 <ErhardtMundt> just moving first steps :)
02:54:21 <ErhardtMundt> http://www.mibbit.com/pb/GdNxZk
02:54:44 <ErhardtMundt> what's wrong with that?
02:54:52 <ski> wli : ok
02:55:05 <ski> (that requires being able to form the union in the first place, though ..)
02:55:48 <ski> @hoogle listenOn
02:55:49 <lambdabot> No results found
02:55:59 <ski> ErhardtMundt> :t listenOn
02:56:02 <blackh> ErhardtMundt: This one got me confused at first - you have to use a fromIntegral to convert an Int to a port number.
02:56:25 <ski> blackh : or just write a literal directly
02:56:26 <wli> data TypeScheme tyVar = TypeApp (TypeScheme tyVar) (TypeScheme tyVar) | TypeVar tyVar deriving (Eq, Ord, Read, Show) appears to be grossly insufficient.
02:57:03 <ski> why ?
02:57:14 <blackh> ski: Of course!  It's all clear to me now - I was doing let port = X (monomorphism restriction!)
02:57:17 <wli> ski: No rows, no predicates.
02:57:41 <wli> Probably also no type constructors.
02:57:54 <ski> why couldn't a `TypeVar tv' stand for a row ?
02:58:18 <blackh> ErhardtMundt: I think sendTo is going to want to work with the handle, not the port.  Is it working at all?
02:58:24 <ski> (you could have both type variables and constructors as `TypeVar tyVar', differentiating between them elsewhere)
02:59:28 <wli> There needs to be some description of the multiplicands of the row.
02:59:41 <ErhardtMundt> blackh: just from haskell.org: sendTo :: HostName -> PortID -> String -> IO ()
02:59:43 <ErhardtMundt> :)
03:00:15 <wli> This row type stuff looks messy with weird on-the-fly predicates for side conditions.
03:00:47 <blackh> ErhardtMundt: There must be two sendTo's, then. The one in Network.Socket takes a Socket
03:00:51 <Fredrik> anyone wanna play connect4 against the computer? :) http://haskell.pastebin.com/m764cc521
03:01:15 <wli> Subtyping is cleaner in every way except inference working. :(
03:01:15 <blackh> ErhardtMundt: There are two sendTo's. I'm confused now.
03:01:16 <ErhardtMundt> blackh: i see
03:01:22 <Baughn_> Fredrik: Is winning actually possible?
03:01:29 * quicksilver arrests Fredrik for abuse of the Show typeclass.
03:01:29 <Fredrik> yes
03:01:36 <Fredrik> human starts, if you're smart, you always win
03:01:44 <Fredrik> and the AI is not very advanced
03:01:51 <Baughn_> "infinite-search library: Exhaustively searchable infinite sets." <-- Wait, what? How does this work?
03:02:22 <quicksilver> Baughn_: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
03:02:23 <Fredrik> Ah yes, Show is intended for serialization or something, right?
03:02:27 <quicksilver> computability is clever.
03:02:40 <quicksilver> Fredrik: Show is intended to produce haskell syntax which can be copy/pasted into code.
03:02:42 * ski plays as player `Empty'
03:02:48 <Fredrik> really? LOL
03:02:50 <blackh> ErhardMundt: I think that sendTo is (probably) used for packets - maybe you want the one in Network.Socket that takes a socket. You can just treat the socket as a normal handle, though, and do hPutStrLn and so on
03:03:02 <Fredrik> I thought it was something like Java's toString()
03:03:16 <quicksilver> blackh, ErhardtMundt : Network.sendTo is for UDP datagrams I think.
03:03:29 <quicksilver> for normal usage you should not use Network.Socket
03:03:35 <quicksilver> Network.Socket is the 'low-level' interface.
03:03:47 <quicksilver> for normal tasks you should use Handles, it's simpler.
03:04:12 <Baughn_> UDP is pretty normal. Anyhow..
03:04:30 <quicksilver> Baughn_: Sure. That's what I said.
03:04:35 <ski> Fredrik : point being, why not remove `Empty' from `Player', and use `Maybe Player' when you need the extra alternative ?
03:04:37 <wli> Baughn: cantor :: [[t]] -> [t] ; cantor = concat . f where zip' [] yss = yss ; zip' xs@(_:_) [] = map return xs ; zip' (x:xs) (ys:yss) = (x:ys) : zip' xs yss ; f [] = [] ; f ([]:xss) = f xss ; f ((x:xs):xss) = [x] : zip' xs (f xss)
03:04:39 <quicksilver> Baughn_: UDP = Network.sendTo = high level interface.
03:04:50 <quicksilver> Baughn_: Network.Socket = low-level = not normally needed.
03:04:51 <blackh> ErhardtMundt: What quicksilver said. Use hPutStrLn with the handle returned by accept.
03:04:57 <Baughn_> quicksilver: Hm? Oh!
03:05:07 <Fredrik> Yeah, that would be more clean, but it seemed more simple for now not to do that :)
03:05:15 <Fredrik> but thanks
03:05:24 <quicksilver> Fredrik: show is "something like" Java's toString.
03:05:29 <quicksilver> Fredrik: the devil is in the details.
03:05:33 <wli> Baughn: Compose with itself as needed to flatten infinite lists of infinite lists of infinite lists etc.
03:05:34 <ski> > cantor [[0,1,2,3],[4,5,6],[7,8],[9]]
03:05:35 <lambdabot>   [0,1,4,2,5,7,3,6,8,9]
03:05:36 <ImInYourMonad> ski: didnt know you were swedish, whered o you live/study?
03:05:37 <Fredrik> as always i guess :)
03:05:49 <quicksilver> Fredrik: Java's toString doesn't really have a precisely defined purpose, it's mostly "something vaguely useful for debugging"
03:05:52 <ski> ImInYourMonad : Göteborg
03:06:03 <Baughn_> quicksilver: The lack of documentation threw me. Though I wonder, what is Network.ByteString for when ByteString can read from handles just fine?
03:06:19 <ImInYourMonad> HugoDaniel: do you surf normally or windsurf?
03:06:28 <wli> Baughn: Then Data.Traversable for enumerating contained elements in a list etc.
03:06:39 <quicksilver> Baughn_: it's low-level, it exists for the same reasons as Network.Socket.
03:06:52 <quicksilver> Baughn_: in unix terms, it's an interface to recv() and send()
03:07:11 <quicksilver> Baughn_: where the Handle stuff is more like read() and write()
03:07:25 <quicksilver> obviously it's more abstract to pretend Sockets are 'just another kind of file handle'
03:07:32 <quicksilver> but occasionally that's too abstract :)
03:07:36 <quicksilver> depends how clever you're trying to be.
03:07:42 <ImInYourMonad> si: chalmers?
03:07:56 <ski> (more or less)
03:08:22 <ski> @type ap id
03:08:23 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
03:08:28 <HugoDaniel> ImInYourMonad: neither... i just keep thinking about it, how im blessed by being portuguese, but i dont have a car or a driving license to go to the beach and do it :(
03:10:12 <ImInYourMonad> lol
03:10:12 <ImInYourMonad> to bad
03:10:12 <ImInYourMonad> but yes you are blessed, i want out of sweden, australia or california...
03:11:10 <wli> ski: My first refinement is data TypeScheme tyCon tyVar = TypeApp (TypeScheme tyCon tyVar) (TypeScheme tyCon tyVar) | TypeCon tyCon | TypeVar tyVar | TypeGen Integer, but I'm thinking something more explicit needs to be done with record and variant constructors.
03:12:18 <Fredrik> that crappy connect4 AI always beats me lol, i suck at this game
03:12:26 * Maddas is amused by the fact that two people sitting next to him are now using XMonad despite not knowing any Haskell and never having tried tiling WMs :-)
03:12:54 <Maddas> (Whereas I tried for many hours to get it to work properly and eventually gave up :-)
03:12:55 <ski> (Maddas : you being the culprit ? ;)
03:13:13 <blackh> Maddas: I want to try it but I don't have the patience to get it working with Gnome. I want it to "just work"
03:13:19 <Maddas> ski: Partly, yes :-)
03:13:57 <ski> wli : do you want light-weight or heavy-weight records,variants ?
03:14:02 <BONUS> blackh: isn't there a special gnome configuration thing
03:14:06 <Maddas> blackh: After giving up on half a dozen other WMs, dwm just worked out of the box for me. (This is entirely because I'm on a terribly outdated Debian system, so dependencies always broke)
03:14:18 <ski> (light-weight, i presume, since you were talking about rows ..)
03:14:19 <BONUS> i know that on my laptop i have it working perfectly with gnome and i only have like 2 lines of configuration
03:14:32 <Maddas> BONUS: Maybe dwm is a good start :-)
03:14:38 <blackh> BONUS: I will try! Do I use the cabal version? If I go offline, you will know why.
03:14:49 <wli> ski: I don't really care so long as I get the code reuse effects esp. wrt. variants. I don't know what this light vs. heavy -weight stuff is.
03:14:52 <BONUS> haha yeah i think i'm using 0.8
03:15:21 <BONUS> blackh: http://www.haskell.org/haskellwiki/Xmonad/Basic_Desktop_Environment_Integration
03:15:46 <ski> heavy-weight just means that you must define the type (usually giving it a name) before using it. light-weight is the other
03:16:04 <ski> `data' is heavy-weight. tuples is light-weight
03:16:06 <wli> ski: Light.
03:17:02 <ski> (/me wonders whether Pascal fits somewhere on that scale)
03:18:41 <wli> Whatever I'm doing with these (expr, env) pairs terrifies me. I barely understand it.
03:19:09 <wli> I don't understand it at all, even.
03:20:24 <bastl1> hello, i built some parsers using bnfc and want to package the results up using cabal. what would be the right place in the module hierarchy for my custom parsers !?
03:21:16 <tomh> hey, are there any errors in the reader monad, i cant get it to compile: http://www.haskell.org/all_about_monads/html/readermonad.html
03:21:16 <guenni> hi, is there a hs2pdf, I wonna pretty print some haskell code
03:21:29 <quicksilver> bastl1: what do they parse?
03:21:29 <ski> (wli : what are you doing with them ?)
03:21:41 <wli> I'l paste.
03:21:52 <tomh> i got this error: Couldn't match expected type `e -> a' against inferred type `Reader e b' In the expression: f (r e) e
03:22:05 * ski 'll fetch drink
03:22:50 <bastl1> quicksilver: java in the first place, other may follow
03:23:17 * bastl1 thinks of something next to language-c and language-sh
03:23:33 <wli> ski: http://pastebin.com/m2b79735d
03:23:34 <bastl1> so its probably Language.myLang, right?
03:24:13 <ski> tomh : that should be
03:24:14 <ski>       Reader r >>= f = Reader $ \e -> f (r e) `runReader` e
03:24:42 <blackh> BONUS: It works! Well, at least, it's doing something - I'm not sure what!
03:25:31 <BONUS> haha cool. i'm a big noob when it comes to xmonad and cabal and packages though, if you have any problems best to ask on #xmonad
03:26:16 <bastl1> are there any guidelines howto layout a parser package? e.g. language-c, language-sh and haskell-src-exts share a lot of similar modules, but are structured quite differently ...
03:33:08 <HugoDaniel> is there a better way to do this: reverse $ drop 2 $ reverse  ?
03:33:44 <ski> not much better
03:33:51 <ski> you could do
03:33:52 <Fredrik> drop "hello"
03:33:55 <Fredrik> > drop "hello"
03:33:57 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
03:33:58 <osfameron> inits.inits ?
03:34:02 <Fredrik> > drop 2 "hello"
03:34:04 <lambdabot>   "llo"
03:34:04 <osfameron> er, init.init
03:34:12 <Fredrik> :t init
03:34:13 <lambdabot> forall a. [a] -> [a]
03:34:20 <Fredrik> > init 3 "hello"
03:34:21 <lambdabot>   Couldn't match expected type `[Char] -> t'
03:34:30 <osfameron> > init.init $ "hello"
03:34:31 <lambdabot>   "hel"
03:34:33 <HugoDaniel> i want to drop 2 characters from the end of the list
03:34:37 <wli> Different behavior on short lists.
03:34:48 <wli> > init . init $ [1]
03:34:50 <lambdabot>   * Exception: Prelude.init: empty list
03:34:58 <HugoDaniel> but the best sollution i find is to reverse the list twice! which seems to me like a big waste of computations
03:35:06 <wli> > reverse . drop 2 . reverse $ [1]
03:35:07 <lambdabot>   []
03:35:39 <ski> > let foo (_:xs@(_:_:_)) = foo xs; foo _ = [] in foo "hello"
03:35:40 <lambdabot>   []
03:35:51 <ski> erm
03:35:54 <titusg> haskell-mode has stopped working after upgrading ubuntu - when trying to load a file I get 'Symbol's function definition is void: inferior-haskell-load-file'
03:35:56 <ski> > let foo (x:xs@(_:_:_)) = x:foo xs; foo _ = [] in foo "hello"
03:35:57 <lambdabot>   "hel"
03:36:02 <HugoDaniel> my problem is having to reverse the list twice :/
03:36:11 <Fredrik> @pl \x -> take (length x - 2) x
03:36:12 <lambdabot> take =<< subtract 2 . length
03:36:20 <titusg> I tried to add the load path manually, still no luck
03:36:39 <Fredrik> > take =<< subtract 2 . length $ "hello"
03:36:40 <lambdabot>   "hel"
03:36:43 <ski> HugoDaniel : if you want, you can probably uglify that so that you only match at most once on each cons ..
03:36:45 <Fredrik> there you are ;)
03:36:58 <ski> > take =<< subtract 2 . length $ [0..]
03:37:17 <lambdabot>   mueval: Prelude.read: no parse
03:37:18 <ski> > let foo (x:xs@(_:_:_)) = x:foo xs; foo _ = [] in foo [0..]
03:37:23 <Fredrik> shaving two elements off at the end from an infinite list doesnt make much sense, does it?
03:37:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:37:38 <ski> Fredrik : depends on what HugoDaniel wanted
03:38:16 <HugoDaniel> hehe
03:38:18 <ski> (but, yes, using `reverse' on infinite lists will hit the bottom)
03:38:31 <HugoDaniel> im working out dynamic arguments on sql queries
03:38:58 <HugoDaniel> in hdbc i need to pass arguments as "(?, ?, ? .. ,?)"
03:39:17 <HugoDaniel> i solved it with two reveserses :/
03:39:24 <wli> > let initM [] = Nothing ; initM (_:xs) = Just xs in map (join . maybeToList . join . liftM initM . initM) $ inits [1..4]
03:39:25 <lambdabot>   [[],[],[],[3],[3,4]]
03:39:58 <wli> HugoDaniel: There's one possible answer.
03:40:07 <ski> join . liftM f = (f =<<)
03:40:44 <wli> I wasn't golfing.
03:42:37 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2332#a2332
03:42:47 <wli> > let initM [] = Nothing ; initM (_:xs) = Just xs in map (join . maybeToList . (initM =<<) . initM) $ inits [1..4]
03:42:47 <HugoDaniel> here is my solution, not the most efficient i guess :/
03:42:48 <lambdabot>   [[],[],[],[3],[3,4]]
03:43:09 <wli> HugoDaniel: I keep pasting an efficient solution.
03:43:39 <wunki> damn, chapter 3 from RWH (Parameterised types) is difficult..
03:44:23 <HugoDaniel> wli that is too much hardcore haskell for me, ill try to understand it
03:45:05 <osfameron> wli: that doesn't seem to do what he wants does it?
03:45:21 <wli> ugh, no, sorry.
03:45:32 <doserj> > let f [x,y] = [] ; f (x:xs) = x:f xs in f [1..10] -- very naive
03:45:33 <lambdabot>   [1,2,3,4,5,6,7,8]
03:45:53 <ski> (wli : you know you could probably write `bindEnv' simpler directly with `local' .. ?)
03:46:01 <wli> > let initM [] = Nothing ; initM xs@(_:_) = Just $ init xs in map (join . maybeToList . (initM =<<) . initM) $ inits [1..4]
03:46:03 <lambdabot>   [[],[],[],[1],[1,2]]
03:46:14 <ski> > let f [x,y] = [] ; f (x:xs) = x:f xs in f []
03:46:15 <lambdabot>   * Exception: /tmp/2490372073023776972:71:36-67: Non-exhaustive patterns in ...
03:46:20 <wli> ski: It's to cram things into 10 columns.
03:46:38 <ski> what is ?
03:46:41 <bastl1> > ((Data.List.inits xs) !! ((length xs) - 2)) [1,2,3,4,5]
03:46:42 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
03:46:50 <wli> ski: bindEnv
03:47:22 <bastl1> > let hd xs = (Data.List.inits xs) !! ((length xs) - 2) in hd [1,2,3,4,5]
03:47:23 <lambdabot>   [1,2,3]
03:47:35 <wli> ski: local would be shorter if scrutinizing Env didn't require pattern matches.
03:47:38 <ski>   bindEnv v x = local (\m -> fix (\m' -> Map.insert v (x, Env m')))
03:47:45 <ski> oh, right
03:47:47 <ski> i forgot that
03:48:19 <ski>   bindEnv v x = local $ \(Env m) -> Env . fix $ \m' -> Map.insert v (x, Env m')
03:49:05 <osfameron> > let {init' []=Nothing; init' xs = Just $ init xs} in init' ("hello") >>= init
03:49:05 <lambdabot>   Couldn't match expected type `Maybe b'
03:49:09 <osfameron> > let {init' []=Nothing; init' xs = Just $ init xs} in init' ("hello") >>= init'
03:49:10 <lambdabot>   Just "hel"
03:49:23 <osfameron> what's a better way of applying monadic init' twice ?
03:49:30 <osfameron> istr something with join
03:49:32 <wli> > let f [] = [] ; f [_] = [] ; f [_,_] = [] ; f (x:xs@(_:_:_)) = x : f xs in f "hello"
03:49:33 <lambdabot>   "hel"
03:49:46 <wli> osfameron: (init' =<<) . init'
03:49:48 <ski> @type let twiceM f = (f =<<) . f in twiceM
03:49:50 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m b) -> b -> m b
03:50:25 <osfameron> wli: ah, but you still have to type the function name twice
03:50:35 <osfameron> ski: ah, handy.  is that in std lib?
03:50:41 <ski> i don't think so
03:51:03 <wli> @pl \f -> (f =<<) . f
03:51:04 <lambdabot> (.) =<< (=<<)
03:51:19 <osfameron> :t (=<<)
03:51:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:51:38 <ski> hm .. there should be a name for `(Integral n,Monad m) => n -> (a -> m a) -> (a -> m a)'
03:51:46 <ski> not `iterateM'
03:51:50 <ski> and not `replicateM'
03:51:54 <osfameron> @pl  init' ("hello") >>= init'
03:51:54 <lambdabot> init' =<< init' "hello"
03:52:07 <wli> osfameron: ((.) =<< (=<<)) init' will do.
03:52:07 <ski> @type replicateM
03:52:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:52:31 <ski> @type replicateM_
03:52:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
03:52:39 <wli> > let init' [] = Nothing ; init' xs@(_:_) = init xs in ((.) =<< (=<<)) init' "hello"
03:52:40 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[t]'
03:52:50 <wli> > let init' [] = Nothing ; init' xs@(_:_) = init xs in ((.) =<< (=<<)) init' $ "hello"
03:52:51 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[t]'
03:53:03 <wli> > let init' [] = Nothing ; init' xs@(_:_) = Just $ init xs in ((.) =<< (=<<)) init' $ "hello"
03:53:04 <lambdabot>   Just "hel"
03:53:26 <wunki> lambdabot is an interpreter?
03:53:43 <ski> lambdabot is an interface to a haskell implementation
03:54:06 <wunki> nice
03:54:50 <blackh> wunki: Your comment about Ch3 of RWH brings back wonderful memories of the sore head that I got when I was learning Haskell.
03:54:52 <ski> ("interpreter"/"compiler" is unrelated to whether there is an "interactive toplevel")
03:55:11 <osfameron> wli: you don't really need @(_:_) do you?  as you already know it's not []
03:55:52 <wli> osfameron: To prevent pattern match overlap, which triggers warnings with -Wall and is occasionally a source of bugs.
03:56:03 <osfameron> ah
03:56:39 <MyCatVerbs> osfameron: eh, it's still nice to have that in there. Hypothetically, imagine refactoring a piece of code and accidentally changing its semantics by reordering cases when you didn't mean to.
03:56:45 <wli> I stay in the habit of keeping -Wall quiet.
03:56:47 <wunki> blackh: Yeah, when
03:56:58 <wunki> I see the code it makes me feel dumb.
03:57:14 <blackh> wunki: I learnt it about six months ago but I have been using it quite intensively since.
03:57:20 <osfameron> wli, MyCatVerbs good points
03:57:27 <pejo> wli, doesn't ghc figure out that you have all patterns matched when you have [] and "xs"?
03:57:39 <wunki> blackh: easy to code in now?
03:58:14 <wli> pejo: It won't warn about inexhaustive pattern matches in such a case because it knows that.
03:58:14 <wunki> blackh: more important, *fun* to code in?
03:58:15 <ski> (pejo : the issue was `overlap', not `exhaustiveness')
03:58:20 <pejo> MyCatVerbs, do you often have that problem?
03:59:11 <wli> I keep -Wall quiet. The warnings are good wrt. code hygiene.
03:59:21 <blackh> wunki: I have used OO languages for years. It took a few months but now I can program in it much faster. I describe Haskell as pleasant to program in. All the frustration is taken away. All the _debugging_ is taken away - and that's the really horrible bit.
03:59:47 <wli> I don't mind not having had problems from what it flags. So long as I follow directions, I never will.
04:00:25 <wunki> blackh: thanks for the motivational talk :) Diving back in again...
04:00:26 <blackh> wunki: Also, there are so many amazing ways to do things. For example,...
04:01:12 <MyCatVerbs> pejo: no. But never overlapping patterns means that I can't by definition, so it's one less thing to think about. Plus it's clearer to be explicit, IMO.
04:02:16 <pejo> ski, doh. Of course.
04:02:49 <blackh> wunki: In my web app, I want a footnote to appear every time certain text appears. I've worked out that I can easily add state to my code that outputs text, with a "remember <something>" and a "do_later <something>" - so that all the remembers get processed first, and the "do_later" stuff can assume all have been done. The point is, you can do this in any language, but in Haskell you can easily make it almost impossible to make silly mistak
04:03:23 <wunki> blackh: nice, you also write webapps, nice
04:04:13 <wunki> blackh: that's also what I want to do with it, now writing in Python. Secondly I want to create a game (who doesn't?).
04:04:14 <blackh> wunki: The whole "safety" aspect translates into getting the job done quicker - debugging time is reduced considerably.
04:05:17 <wli> I wonder if I could use subtyping solely for width relationships between records and variants and still have useful type inference.
04:06:28 <blackh> wunki: I started my web application in Python, and I am very glad that I chose to re-write it in Haskell. It's about 17,000 lines of code.
04:06:42 <wli> It seems so much cleaner than the row stuff.
04:07:06 <Saizan> 18klocs?
04:07:13 <wunki> blackh: did you use a framework?
04:07:17 <Saizan> in haskell?
04:10:00 <blackh> wunki: No, I didn't use a framework, mainly because it's a big application, so I get total control for the relatively small cost of writing my own framework.
04:10:51 <wunki> blackh: is the application open for public viewing?
04:10:53 <blackh> wunki: Also I have a pathological dislike of SQL
04:11:44 <ski> (blackh : cut off at ".. almost impossible to make silly mistak")
04:11:45 <blackh> wunki: No - I want to start a business with a friend, and we're keeping it all secret.
04:11:56 <ski> blackh : why's it pathological ?
04:12:40 <blackh> ski: There were two more letters... "es."
04:12:44 <cads_> hello
04:13:55 <wunki> blackh: thanks for the heads up and the best of luck with your startup. Gonna dive back into RWH..
04:14:04 <ski> > let foo (x:xs@(_:_:_)) = x:foo xs; foo _ = [] in foo "hello cads_"
04:14:06 <lambdabot>   "hello cad"
04:14:07 <cads_> hey are there any illustrated guides to haskell where people put together some kind of technical crazy 3d continuum mechanics integrator engine and simulated a galaxy with viscious flow and turbulence?
04:14:13 <blackh> ski: I go into violent fits whenever I see so much as the word "SELECT". Frfrfrfrffrrfrrfrffrfr!
04:14:28 <kiris> blackh: from table as t1
04:14:33 <ski> blackh : but how do you know this is pathological ?
04:14:49 <wunki> pathologuncontrolled or unreasonable
04:14:52 <ski> (as opposed to, e.g., sane)
04:14:56 <wunki> pathological: uncontrolled or unreasonable
04:15:35 * ski isn't convinced it is unreasonable
04:15:43 <blackh> ski: I suppose I could be sane and the SQL-using world could be looney - that's a good point!
04:16:05 <MyCatVerbs> SQL is close enough to fine. Implementations of it often aren't.
04:16:13 <ski> blackh : well, the SQL-world is looney for sure .. the only question is whether you are too
04:16:29 <cads_> I read a similar guide to the n-body problem and all the advanced solution techniques, each lesson introducing a new concept in the solution of advanced partial differential equations
04:16:38 <cads_> it used ruby as the language though
04:16:47 <ski> (MyCatVerbs : fsvo "close enough" ..)
04:17:12 <cads_> which made it a lot more comfortable to write algorithms in than c
04:22:22 * blackh is not just coping with this new fangled "tiling window manager" xmonad thing.
04:23:48 <ski> @let times :: Integral n => n -> (a -> a) -> (a -> a); times n f = compose (genericReplicate n f)
04:23:48 <lambdabot>  Defined.
04:24:08 <ski> @let timesM :: (Integral n,Monad m) => n -> (a -> m a) -> (a -> m a); timesM n f = composeM (genericReplicate n f)
04:24:08 <lambdabot>  Defined.
04:25:09 <wli> {| \ell : \tau_\ell | \ell \in L |} \preceq {| \ell : \tau_\ell' | \ell \in L' |} iff L \supset L', (\forall\ell) \ell\in L' \tau_\ell \preceq \tau_\ell' or some such.
04:25:13 <ski> @let twiceM :: Monad m => (a -> m a) -> (a -> m a); twiceM = timesM 2
04:25:14 <lambdabot>  Defined.
04:26:39 <wli> Maybe \precsim would be better.
04:26:50 <wli> How do I get those brackets?
04:26:53 <MyCatVerbs> > runState (timesM 4 $ \n -> get >>= \s -> put (s+n) >> return (s+n)) 1
04:26:55 <lambdabot>   Couldn't match expected type `State s a'
04:27:20 <MyCatVerbs> > runState (timesM 4 (\n -> get >>= \s -> put (s+n) >> return (s+n)) 1) 1
04:27:21 <lambdabot>   (16,16)
04:29:16 <ski> is `\preceq' subtyping ?
04:29:22 <wli> Looks like I have to roll my own with \{| or some such.
04:30:01 <wli> ski: Yeah, albeit only used on records and variants width-wise.
04:30:26 <ski> (but nested on other type constructions, i hope)
04:30:49 <ski> (for co- respectively contra- variant type arguments, i mean)
04:31:39 <ski> (why `\supset' instead of reversing into `\subset' ?)
04:31:40 <wli> I presumed that to be obligatory.
04:32:09 <wli> ski: No particular reason.
04:32:25 <ski> imho, it would read nicer the other way
04:33:37 <ski> in  \tau_\ell'  is the prime displayed on the  \ell  or on the  \tau  ?
04:33:57 <wli> ski: I'm about to find out. The \tau was intended.
04:34:59 <wli> ski: \tau as desired
04:35:46 <ski> ok
04:39:15 * wli tries to define \{\!\vert and \vert\!\} as math delimiters somehow so they typeset nicely.
04:41:00 <quicksilver> wli: use mathlig.tex
04:41:11 <quicksilver> wli: then you can make {| magically turn into what you want.
04:42:13 <wli> googling
04:43:09 <quicksilver> possibly the expansion string you want is \left\{\left\| and \right\|\right\}
04:43:16 <quicksilver> although my LaTeX is more that a little rusty.
04:43:33 <quicksilver> sorry, you don't \ the |
04:43:38 <quicksilver> \left| and \right| is enough
04:44:23 <wli> The mathlig.tex is to abbreviate it, not to scale with the height of the bracketed expression.
04:44:58 <quicksilver> correct.
04:45:09 <quicksilver> the \left and \right stuff is the scaling part
04:45:15 <quicksilver> my explanation was in two parts :)
04:46:12 <wli> It won't turn out right when scaled separately because the spacing between the \{ and \} and |'s changes wrongly as the expression height changes.
04:47:13 <wli> There's a way to declare new delimiters somewhere.
04:47:32 * quicksilver nods
04:47:35 * quicksilver can't remember
04:47:56 <ski> wli : why `_ -> retEnv e' in `reduce e@(AppExpr f x) = ...' ?
04:48:41 <wli> ski: So the program doesn't crash with pattern match failures.
04:49:31 <ski> yes, but why not return an application where `f' has been reduced ?
04:50:41 <ski> (if `f' reduces to `VarExpr v', it would be nice to insert this into the `AppExpr .. x', no ?)
04:50:46 <wli> ski: All returns must be paired with the contexts. There's no way to store the context for f after it's reduced because it's not the top-level expression.
04:51:17 <ski> possibly the contexts could be merged
04:51:27 <ski> (or possibly you could decorate with contexts .. hmm)
04:52:32 <wli> Decorate what with contexts? They're needed/used for every subexpression.
04:53:06 <ski> .. decorate each expression node
04:53:50 <wli> How?
04:54:17 <wli> There's no room for it in the types (or type system, really).
04:54:17 <ski>   data DecoratedExpr var
04:54:25 <ski> er
04:54:28 <ski>   data DecoratedExpr dec var
04:54:31 <ski>     = VarExpr dec var
04:54:44 <ski>     = LamExpr dec var (DecoratedExpr dec var)
04:54:51 <ski> (s/=/|/)
04:54:54 <ski>     | ...
04:55:10 <ski> or you could do IndirectComposite directly
04:56:08 <wli> All this is super-fragile because I don't understand the Env stuff.
04:56:27 <ski> @wiki Indirect_composite
04:56:27 <lambdabot> http://www.haskell.org/haskellwiki/Indirect_composite
04:57:27 <ski> (i'm not sure about your envs, too ..)
04:58:49 <wli> They're supposed to handle recursion and/or mutual recursion by some sort of knot-tying.
04:59:37 <ski> you mean `bindEnv' and the `LetExpr' case ?
04:59:57 <wli> Yes.
05:00:22 <wli> There's also supposed to be some sort of cleanness to the way they handle scoping, variable capture, etc.
05:00:59 <wli> It's looking more like mysteriousness from my end.
05:01:41 <ski> what is supposed to be cleanness ?
05:02:28 <wli> I have no idea.
05:04:42 <JuanDaugherty> unspecified adherence to the wli-aesthetic.
05:05:00 <wli> Handling variable capture in other ways turned out to be rather verbose. This ended up rather compact but so mysterious I can't touch it because I don't actually understand how it works.
05:05:12 <wli> It was someone else's idea.
05:05:19 <ski> i suppose if `n >= 0' doesn't hold for the `PrjExpr' case, you could give an error/exception for malformed/illegal expression
05:06:13 <wli> I originally didn't have MonadError. The plot was just not to reduce when something was wrong.
05:06:58 <ski> i suppose the question is what is inadmissible, and what is merely wrong
05:07:35 <ski> e.g. `AppExpr (VarExpr v) e' is arguably not wrong, just open
05:08:18 <ski> `AppExpr (TupExpr es) e' is maybe wrong, and maybe inadmissible
05:08:43 <ski> `PrjExpr n e' for negative `n', to me, seems clearly inadmissible
05:08:47 <wli> Applications only reduce when the term to be applied is a lambda.
05:09:18 <ski> yes .. but if you provide a larger environment later, the `VarExpr v' may reduce further, even if it didn't before
05:09:26 <wli> I'm probably going to have to dump this entire codebase because I can't figure out the Env trick suggested to me later.
05:09:32 <ski> (while a `TupExpr es' should never reduce to a lambda)
05:09:58 <ski> is the "Env trick" the tying-the-knot ?
05:10:17 <wli> Not just that. There is something to do with variable capture also.
05:10:26 <ski> aha
05:10:37 <ski> the `flip Map.union m' thing
05:11:03 <ski> @type Data.Map.union
05:11:04 <wli> Yes, because Map.union is left biased.
05:11:04 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
05:11:09 <ski> *nod*
05:11:43 <ski> so, what part of the code contains the things you can't figure out ?
05:12:11 <wli> Almost everything to do with the Env's, which is just about all of it.
05:12:35 <wli> I kind of got to where I could work with it while I was writing it, and now it might as well be hieroglyphics.
05:12:39 <ski> it sounded to me that you understood the heretoforth mentioned things
05:13:24 <wli> I only remember bughunting on the Map.union issue for a long time and someone else on the channel spotted it.
05:14:02 <ski> but you succeeded in explaining the issue now ..
05:14:45 <wli> I'm only regurgitating what was told to me.
05:15:37 <wli> I can't, for instance, tell you why it needs to be flip Map.union vs. Map.union, only that that fixed the bug.
05:16:22 <ski> `flip Map.union m' passes `m' as the "right" argument to `Map.union'
05:16:33 <ski> maybe it would be clearer if written as
05:16:34 <wli> Superficially it makes the bindings in the let override ones inherited from above.
05:16:48 <ski>   = (`Map.union` m)
05:16:51 <ski>   $ ...
05:16:52 <ski> ?
05:17:23 <ski> (yes, that's what it does)
05:17:42 <wli> I have no idea how this does anything useful regarding variable capture.
05:20:00 <ski> say `m' is an environment mapping `v' to `(exp,env)', then if the `...' above (left argument to `Map.union') maps `v' to something else, this will override the previous mapping of `v' to `(exp,env)' .. so, if the expression which the `LetExpr' scopes over refers to the variable `v' that will not see the earlier binding, but the new one instead
05:23:01 <toliko_smoren> I am trying to use FTGL, and the docs say that before I call it I need to set a pen color using OpenGL. How do I do that?
05:23:35 <wli> The trouble comes when an argument to lambdas with free variables not bound by any enclosing scope gets substituted into a lambda body's sub-scope where variables by those names are bound.
05:25:24 <wli> Since it's a program error where it makes a real difference, maybe it's not so important.
05:26:09 <wli> The indirect composite looks rather interesting.
05:27:11 <wli> I can't figure out what hash consing is but having subexpressions tabulated out in an IntMap looks very promising.
05:28:26 <temoto> Suppose, i have list of lists, how do i get list of all first-items in each sublist? Is this any good? map (!!0) [[1,2,3],[4,5,2],[5,6,3]] ?
05:29:32 <toliko_smoren> map head
05:29:36 <wli> > catMaybes . map listToMaybe $ [[1,2,3],[4,5,2],[],[5,6,3]]
05:29:37 <lambdabot>   [1,4,5]
05:30:06 <ski> cf. <http://web.archive.org/web/20070614083507/http://www.haskell.org/hawiki/DecoratingStructures>
05:30:29 <wli> temoto: I'd use catMaybes . map listToMaybe because map head will crash if any sublist is empty.
05:30:59 <temoto> wli: maybes must be slower, right?
05:31:58 <temoto> toliko_smoren: it must be like map (head 1) the-list ?
05:32:31 <ivanm> > map head [[1,2,3],[4,5,2],[5,6,3]]
05:32:32 <lambdabot>   [1,4,5]
05:32:36 <wli> temoto: If it crashes the performance is 0.
05:32:40 <ivanm> > map head [[1,2,3],[4,5,2],[5,6,3],[]] -- this will fail
05:32:41 <lambdabot>   [1,4,5,* Exception: Prelude.head: empty list
05:32:55 <Shurique> > [ x | (x:_) <- [[1,2,3],[4,5,2],[5,6,3],[]] ]
05:32:57 <lambdabot>   [1,4,5]
05:33:05 <ski> wli : hash-consing is when you memoize all the conses you've created (in some context) in some `Map', so that if you cons an element unto some list, you first check if you've already made that consing before in the map ..
05:33:05 <toliko_smoren> yeah you are right
05:33:05 <ivanm> laziness: you'll never know when it'll crash!
05:33:06 <ivanm> ;-)
05:33:23 <ski> .. if you have, you just return an index to it .. if not, you add it to the map, and return the new index
05:33:48 <temoto> Thanks. Looks nice.
05:34:11 <jeltsch> Hello, the impossible happened once again.
05:34:18 <ski> so, it's besically just memoizing on `cons'
05:34:32 <ski> jeltsch : you leaving #haskell ?
05:34:58 <jeltsch> ski: What does âyou leaving #haskell ?â mean?
05:34:59 <wli> ski: Sounds like using indices based on hashing the contents of the expressions vs. just using dfs to assign numbers to subexpressions.
05:35:14 <ski> jeltsch : "-!- jeltsch [n=wolfgang@pscbgast1.informatik.tu-cottbus.de] has left #haskell []"
05:35:32 <jeltsch> ski: Do you mean âare you leaving #haskellâ or âYou should leave #haskellâ?
05:35:54 <ski> jeltsch : no .. you mentioned the impossible happening yet again
05:36:12 <ski> jeltsch : i wondered if you referred to you just leaving #haskell 2 minutes ago
05:36:12 <jeltsch> ski: I had entered #haskell, then accidentally left but then entered again.
05:36:24 <jeltsch> ski: 2 minutes???
05:36:33 <jeltsch> ski: Okay, on topic now:
05:36:40 <jeltsch> ski: The impossible happened again.
05:36:46 <jeltsch> ski: You know what that means?
05:37:07 <ski> i thought you knew what you meant by saying that ..
05:37:15 <jeltsch> ski: You donât?
05:37:31 <jeltsch> ski: Itâs this error message from GHC that drives me crazy.
05:37:40 <ski> it might mean that a program discovered an internal bug
05:37:55 <jeltsch> ski: Yes, I know.
05:37:56 <ski> if GHC, it's a compiler bug
05:38:04 <jeltsch> ski: I know that.
05:38:23 <jeltsch> What I donât know is: What does âinitC: srt_lblâ mean?
05:38:23 <ski> now, it could say that for a lot of reasons
05:38:29 <ski> hard to say without seeing the code
05:38:45 <ski> (and probably hard to say much constructive, if one isn't a GHC hacker ..)
05:38:52 <wli> I don't like the knot tying.
05:39:00 <jeltsch> I hoped to find some ghc hackers here.
05:39:05 <ski> JaffaCake might be able to help you
05:39:10 <jeltsch> ski: But wait, isnât there a GHC channel?
05:39:16 <ski> you can also try #ghc
05:39:26 <ski> and there's a mailing list (i forget the exact name)
05:39:41 <jeltsch> ski: Mailing lists are slow. I need quick help.
05:39:52 <wli> The overriding isn't so bad.
05:40:18 <ski> (btw, you don't need to attribute me all the time, unless there's a floodage of other messages here)
05:40:31 <ivanm> ski: awww....
05:40:32 <ivanm> ski: why not?
05:40:39 <ivanm> ski: maybe it's fun to use your nick all the time!
05:40:40 <ivanm> :p
05:41:16 <jeltsch> Personally, I like to be attributed if a message is primarily intended for me.
05:41:17 <ski> ivanm: ivanm: because my client sees fit to highlight the messages, making it harder to follow conversation in these circumstances
05:41:32 <jeltsch> It makes it easier for me to find those messages in the transcript.
05:41:39 <ivanm> ski: yeah, so does mine
05:41:50 <ivanm> jeltsch: yes, but who cares about you? :p
05:42:02 <ski> (presumably jeltsch does)
05:42:10 <ivanm> heh
05:42:13 <jeltsch> ivanm: Okay, good bye then.
05:42:58 <ivanm> :o
05:43:13 <wli> I think I sort of understand it again now.
05:43:56 <HugoDaniel> i keep stumbling upon these kind of IO monad errors: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2334#a2334
05:44:03 <HugoDaniel> can someone help me with a clear solution for this ?
05:44:47 <ivanm> HugoDaniel: let sdatlist_lst = map ...
05:44:48 <ski>   let sdataids_lst = map (\(infoid, _, _, _) -> (infoid, getDataIds infoid)) sinfo_lst
05:45:12 <wli> I may want to rewrite this just about from scratch.
05:45:19 <ski> you need to be away when you're dealing with an `IO'-action returning some value .. and when you're dealing with that value, plain
05:45:28 <ski> s/away/aware of/
05:45:55 <jethr0> ski: i think being away when you're dealing with IO is also a good approach ;)
05:45:55 <HugoDaniel> okey
05:45:59 <toliko_smoren> so, does anyone knows how to use FTGL properly?(at all?)
05:46:31 <HugoDaniel> then sdataids_lst = [Int, IO [Int]], and how do i change it to IO [Int, [Int]] ?
05:46:59 <wli> The big debate right now is whether I want to refer to subexpressions with contexts i.e. (Int, env) or whether I want to have (expr, env) sitting around in the subexpression's entry in the IntMap.
05:47:01 <ski> presumably you mean `sdataids_lst :: [(Int, IO [Int])]' ?
05:47:14 <HugoDaniel> yes that, sorry
05:47:16 <HugoDaniel> :)
05:47:52 <ivanm> jeltsch: do you forgive me? :o
05:48:05 <jeltsch> ivanm: Yes. :-)
05:48:20 <ski> mapM (\(number,action) -> do list <- action; return (number,list)) listOfPairsOfNumbersAndActionsOfLists
05:48:28 <ivanm> \o/
05:48:29 <ski> (possibly using `forM' instead of `mapM')
05:48:34 <jeltsch> ivanm: Sorry for quickly leaving the channel. However, Iâm a bit sensitive concerning such kind of humor.
05:48:41 <jeltsch> #ghcâs topic: âGHC Development | Please ask user questions in #haskellâ
05:48:44 <HugoDaniel> :(
05:48:45 <HugoDaniel> ouch
05:48:50 <HugoDaniel> that seems overly complicated
05:48:57 <jeltsch> So it seems that I need to ask my GHC questions here.
05:49:32 <ski> @hoogle strength
05:49:32 <lambdabot> No results found
05:49:34 <ski> bah
05:49:39 <HugoDaniel> isnt't there a magic function that always puts IO on top ?
05:49:47 <jeltsch> Okay, GHC hackers: Can you tell me what âinitC: srt_lblâ means?
05:49:53 <HugoDaniel> topIO :P
05:50:24 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength (a,fb) = fmap (\b -> (a,b)) fb
05:50:25 <lambdabot>  Defined.
05:50:42 <Axman6> jeltsch: that would entirerly depend on the context
05:50:59 <ski> HugoDaniel : using that, you can do `mapM strength yourList'
05:51:04 * wli had a module that liftIO'd every function in System.IO
05:51:24 <ski> @type mapM strength
05:51:25 <lambdabot> forall a (f :: * -> *) b. (Monad f, Functor f) => [(a, f b)] -> f [(a, b)]
05:51:37 <Deewiant> wli: Is it on Hackage?
05:51:41 <jeltsch> Axman6: The âimpossibleâ happend. With this error message.
05:51:49 <jeltsch> Axman6: Do you need more context?
05:51:56 <ski> yes
05:52:08 <Axman6> the program would be rather useful
05:52:37 <jeltsch> GHC.
05:52:57 <jeltsch> Only GHC is able to let the impossible happen. :-D
05:53:00 <Axman6> ...
05:53:08 <ski> the program you used to provoke this behaviour out of GHC ..
05:53:33 <ski> @faq Can GHC let the impossible happen?
05:53:33 <lambdabot> The answer is: Yes! Haskell can do that.
05:54:06 <ski> (this gives a whole new sound to that ..)
05:54:12 <Deewiant> HugoDaniel: One reason there's no generic 'topIO' is that if you have for instance an [(IO Int,IO Char)] there are essentially an infinite amount of ways of turning that into IO [(Int,Char)], and even two 'obvious' ones
05:54:34 <ski> wli : why `Int' in `(Int, env)' ?
05:54:58 <wli> ski: Using Fortran pointers for subexpressions in an IntMap
05:55:33 <ski> (ok, hash-consing)
05:55:36 <jeltsch> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2335#a2335
05:55:47 <jeltsch> You need grapefruit-frp to compile it.
05:56:02 <jeltsch> With the darcs version of grapefruit-frp and GHC 6.10.1, the impossible happens.
05:56:02 <Alpounet> bye all
05:56:18 <jeltsch> It does not happen when I comment out consume and produce in the export list.
05:56:33 <wli> ski: Well, I'm not hashing for CSE-like effects or hashing at all. Simple dfs/etc. traversal numberings of subexpressions in the expression tree are all.
05:56:49 <Axman6> well, sounds like a GHC bug to me, try asking in there. if they tell you to file a ticket, then do so
05:58:03 <wli> ski: With the Fortran pointers in place I can do decorate :: IntMap (Expr Int) -> IntMap (Expr Int, Env)
05:59:37 <HugoDaniel> hmm
05:59:47 <HugoDaniel> what for the simple case of [IO a] ?
06:00:13 <Axman6> sounds like you want sequence
06:00:18 <Axman6> or sequence_
06:01:32 <HugoDaniel> ok
06:01:32 <HugoDaniel> thanks
06:01:33 <ski> sequence :: [IO a] -> IO [a]
06:01:34 <HugoDaniel> lunch time
06:01:35 <HugoDaniel> buy
06:01:38 <ski> sequence_ :: [IO a] -> IO ()
06:01:38 <HugoDaniel> ***
06:01:55 <ski> mapM :: (a -> IO b) -> ([a] -> IO b)
06:02:01 <ski> mapM_ :: (a -> IO b) -> ([a] -> IO ())
06:02:50 <ski> (er, s/IO b/IO [b]/ ..)
06:02:51 <toliko_smoren> anyone know of any ftgl example for haskell?
06:03:02 <ivanm> toliko_smoren: what's ftgl?
06:03:22 <ski> wli : with `Env' defined how ?
06:03:39 <toliko_smoren> ftgl is a binding that offers true type fonts through OpenGL
06:04:03 <toliko_smoren> which i have no idea how to use
06:04:11 <ivanm> never heard of it
06:04:17 <ivanm> @go haskell ftgl
06:04:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FTGL
06:04:17 <lambdabot> Title: HackageDB: FTGL-1.1
06:04:28 <ivanm> waddaya know!
06:04:32 <ivanm> hackage++
06:05:15 <toliko_smoren> i went all over that link, but functions defs. are not much help if i dont know how to use them
06:06:03 <ivanm> toliko_smoren: there's a sample in the docs...
06:07:06 <toliko_smoren> which consist of three lines without any instruction of where or how to use them...
06:09:10 <ski> (wli : well, `newtype Env = Env (IntMap (Expr var, Env))' i suppose .. ok)
06:09:30 <ski> (s/ var//)
06:10:30 <Zao> When in doubt, read the docs for the bound library.
06:10:58 <ivanm> connect-the-types
06:10:59 <ivanm> ;-)
06:11:02 <ski> (and when the docs is the trivial docs, read the source)
06:12:52 <wli> ski: No, newtype Env var = Env (Map var (Int, Env var)) but possibly also newtype Env var = Env (Map var Int) with an IntMap (Expr var, Env var) on the side.
06:13:34 <wli> In the first case it's an IntMap (Expr var) on the side.
06:13:58 <ski> i meant for your `decorate :: IntMap (Expr Int) -> IntMap (Expr Int, Env)'
06:15:07 <wli> That would definitely be newtype Env var = Env (Map var Int) with the Env's stored alongside the Expr's in the IntMap.
06:16:08 <ski> what will `AppExpr (AppExpr (LamExpr "x" (LamExpr "y" (VarExpr "x"))) (VarExpr "y")) (VarExpr "z")' reduce to ?'
06:16:17 <ski> (assume empty initial environment)
06:17:01 <wli> (VarExpr "y",fromList [("x",VarExpr "y")])
06:18:17 <wli> Doesn't look like the environment management is working very well.
06:19:29 <wli> Never mind, maybe it is.
06:24:09 <ski> for some reason, i keep wanting to change your `MonadReader' into `MonadState' .. i'm not sure this would be appropriate, however
06:35:58 <toliko_smoren> anyone can help me ftgl or openGL?
06:41:29 <blackh> toliko_smoren: I can give you a working OpenGL program.
06:41:44 <quicksilver> toliko_smoren: I know plenty about haskell/opengl. I know nothing about ftgl.
06:49:56 --- mode: irc.freenode.net set +o ChanServ
06:50:12 <quicksilver> toliko_smoren: well, you change the current transformation matrix.
06:50:12 <quicksilver> which changes how coordinates get transformed.
06:50:12 <quicksilver> that's different from having a cursor position, but it is a similar effect.
06:50:32 <toliko_smoren> hm, ok
06:50:47 <toliko_smoren> still no idea how to get the text to show up in the first place though
06:51:18 <toliko_smoren> any other good font library?
06:53:08 <quicksilver> toliko_smoren: opengl isn't going to "just work"
06:53:21 <toliko_smoren> ?
06:53:31 <quicksilver> toliko_smoren: you'll have to start with some simple opengl code, get that work, learn about matrices and vertices and colour.
06:53:40 <quicksilver> there is a substantial learning curve.
06:53:58 <quicksilver> if your objective is just to draw some text, perhaps gtk2hs or wxWidgets is more useful?
06:54:54 <toliko_smoren> get2hs was way too high and an overkill
06:55:06 <toliko_smoren> i basically just want font manipulation and to be able to put it where I want
06:55:56 <quicksilver> opengl is much more overkill than gtk2hs :P
06:56:21 <toliko_smoren> hm, i searched hackage for fonts, and this was the only thing i found
06:56:37 <quicksilver> font manipulation is a property of gui libraries.
06:56:40 <ski> (there should be a one-word superlative of `overkill' ..)
06:56:56 <quicksilver> the one I have used in wxWidgets. It's fine.
06:57:01 <quicksilver> other people like gtk2hs.
06:57:02 <ski> (and `comparative' too, of course)
06:57:26 <toliko_smoren> i will look at wxWidgets than
06:57:27 <toliko_smoren> thanks
06:57:55 <wli> ski: Is the scoping looking okay?
06:58:56 <ski> wli : i'm currently in the process of trying to rewrite it to `MonadState' to see whether that makes it clearer ..
06:59:30 <wli> I highly doubt it. You'll just end up resetting the state all over the place.
07:01:32 <ski> (i'm not sure whether your current `AppExpr' case is correct or not ..)
07:16:18 --- mode: irc.freenode.net set +o ChanServ
07:46:02 <tomh> Can I use monad laws to proof that x <- return x is worthless?
07:46:48 <BONUS> well yeah
07:46:58 <BONUS> that's right identity, it's one of the monad laws
07:47:04 <BONUS> i mean left identity
07:47:15 <BONUS> although you probably mean
07:47:18 <BONUS> x' <- return x
07:47:34 <BONUS> wait hm
07:47:44 <tomh> well i guess you can name the outcome whatever you want
07:48:01 <BONUS> return x >>= f = f x
07:48:10 <tomh> ye
07:48:21 <byorgey> do {x' <- return x; y x'} desugars to  return x >>= \x' -> y x', which by the left-identity law is equal to y x
07:48:40 <tomh> what if there is stuff between those two lines?
07:48:59 <tomh> or what if y doesn't use x
07:49:13 <tomh> then the law can't be applied right
07:49:13 <byorgey> doesn't matter.
07:50:02 <BONUS> even if you have {x' <- return x; z; y x'} then it's return x >>= \x' -> z >> y x', which is ((z >>) . y) x
07:50:06 <byorgey> if you wanted to be technical I think you could show by induction on the structure of foo that  do { x' <- return x; foo }  is always equivalent to  foo' where foo' is foo with all free occurrences of x' replaced by x.
07:50:17 <smg> hey
07:50:27 <BONUS> if x is not used at all then it doesn't even have to be evaluated
07:50:33 <smg> i i use deriving Show, instead i want do define the Show stuff myself
07:50:35 <smg> possible?
07:50:40 <BONUS> @pl \x' -> z >> y x'
07:50:40 <lambdabot> (z >>) . y
07:51:17 <byorgey> smg: sure, just don't say 'deriving Show' and then say  'instance Show MyType where ...'
07:51:22 <tomh> mm ok I will try those tips thanks
07:51:27 <smg> ah i need instance
07:51:31 <byorgey> and in the ... part you could just define the 'show' function
07:51:53 <byorgey> instance Show MyType where show somethingOfMyType = "Some string"
07:51:54 <byorgey> and so on
07:52:18 <smg> ty
07:52:31 <ski> do {x <- return e; foo}  =  do {let {x = e}; foo}  -- assuming `x' doesn't occur in `e'
07:52:57 <EvilTerran> ski, and assuming "x" is an irrefutable pattern, shurely?
07:53:32 <smg> can i use also a class?
07:53:42 <byorgey> smg: what do you mean?
07:53:42 <smg> i mean instance Show MyClass where show ... ?
07:54:20 <byorgey> smg: you mean you want to make anything which is an instance of MyClass also an instance of Show?
07:54:22 <ski> EvilTerran : assuming `x' is a variable :)
07:54:54 <smg> byorgey: yeah
07:55:48 <byorgey> smg: well, you can do that, but unfortunately, you will have to use a newtype wrapper
07:56:13 <byorgey> newtype MyClassShowable a = MCS a
07:56:14 <BONUS> smg: i don't know the problem at hand, but maybe you could make your class a sub-class of Show?
07:56:29 <byorgey> instance (MyClass a) => Show (MyClassShowable a) where  show (MCS x) = ...
07:56:45 <BONUS> so that you make it that a type must be in Show first before it can be in your class
07:57:10 <byorgey> BONUS: that's not quite the same thing, although I guess I am not sure exactly what smg wants
07:57:14 <BONUS> byorgey: would you advise against using FlexibleInstances to do instance (MyClass a) => Show a where ...
07:57:21 <jenner> the choice of "a" as an argument name or type name is really bad when it comes to explaining haskell in english
07:57:22 <BONUS> byorgey: yeah i know, that's why i asked him
07:57:47 <byorgey> jenner: that's true, sorry about that =)
07:57:54 <byorgey> BONUS: generally, yes
07:58:06 <ski> (jenner : you should pronounce it as `aih', not as 'uh')
07:58:08 <dancor> that's why x is such a popular variable
07:58:11 <dancor> in math and stuff
07:58:27 <smg> byorgey: it was just for my information if it's possible to make anything which is an instance of MyClass also an instance of Show
07:58:29 <ski> (or possibly `alpha', in case of type variables)
07:58:47 <BONUS> ugh, multiletter type variables
07:58:49 <BONUS> haha
07:58:59 <byorgey> smg: right, you want to show something using only the methods in MyClass?
07:59:28 <ski> (BONUS : well, i was only talking about pronounciation, here ..)
07:59:30 <jenner> ski: it doesn't matter how you pronounce it -- e.g. I'm reading YAHT right now, and although all "a"s and "as"'s are emphasized, they are not really distinguishable from regular text
07:59:41 <BONUS> ski: aha i see
07:59:51 <smg> byorgey: yes
08:00:13 <ski> jenner : would it be better if YAHT displayed `a' as minuscle greek letter "alpha" ?
08:00:22 <ski> (as some papers do)
08:00:35 <jenner> ski: I'd replace "a" with "x"
08:00:50 <dancor> the thing is that a/alpha is more idiomatic..
08:01:04 <jenner> ski: you should still be able to cpy&paste examples from the pdf, so alpha is a poor choice imho :)
08:01:18 <BONUS> x is usually used for data variables
08:01:27 <BONUS> like values
08:01:49 <jenner> well, take some other letter that's not used as a standalone word or article
08:02:03 <dancor> there aren't that many alphabet sections ;)
08:02:08 <BONUS> i dont know, it seems like most people get used to it
08:02:08 <jenner> how about "w" or "q"? :)
08:02:21 <ski> jenner : if i'm not mistaken, one can use (minuscle greek letter) "alpha" in code (and some people do)
08:02:56 <dancor> it's common to see things up to c..   like a -> b -> c
08:03:20 <dancor> and x,y,z for vars
08:03:37 <dancor> f,g,h for functions.  etc
08:03:59 <jenner> right, and they do look fine in declarations, but when it comes to an explanation in regular english you have to pay attention... especially if you're a non-native speaker like I am
08:04:05 <dancor> i,j,k for counters.. not too many of those in haskell tho ;)
08:04:07 <BONUS> in lyah i use a different background color for anythign that comes from code
08:10:35 <mait> hello
08:11:34 <BONUS> hlo
08:13:35 <ImInYourMonad> "it seems you might be connecting through a proxy server" is whta i get from joost. that means im connecting joost through another sevrer rather than directly? how cna i fix that?
08:21:16 <ski> kill, kill, KILL !
08:21:25 <ski> .. er, did i say that aloud ?
08:21:35 * ski glances around nervously
08:21:57 <ImInYourMonad> hmm i was thinking, a recursion is basically induction. which means you prove the function when you write it. so basically as you write a functional program you prove it at the same time, at least to a higher degree than an imperative one where writing a loop certainly isnt proving. true?
08:22:10 <ImInYourMonad> ski: you said love love love as far as i could hear
08:22:28 <ski> ah, ty
08:22:30 <opqdonut> well yeah, recursive algorithms tend to be more "definitional"
08:23:17 <lilac> ImInYourMonad: as long as your recursion is well-founded, it corresponds to a proof in some sense
08:23:21 <ski> ImInYourMonad : consider the recursive definition `ones = 1 : ones' ..
08:24:11 <lilac> ImInYourMonad: conversely, the mere fact that a function is recursive doesn't prove it terminating
08:25:46 <ehird> how do you range downwards?
08:25:47 <ehird> [10..0]
08:25:58 <ski> > [10,9..0]
08:26:00 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:26:23 <ehird> ah, thanks :)
08:26:33 <ehird> what about if 10 is a var?
08:26:37 <ehird> [x,x-1..0]?
08:26:40 <ehird> that's kinda ugly :(
08:26:42 <ski> aye
08:27:01 <ski> you can s/x-1/pred x/, if you prefer
08:27:15 <trofi^w> :t enumFromThenTo
08:27:16 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
08:27:22 <trofi^w> :t enumFromTo
08:27:23 <lambdabot> forall a. (Enum a) => a -> a -> [a]
08:27:36 <osfameron> >enumFromTo 10 1
08:27:42 <BONUS> @pl \x -> enumFromThenTo x (pred x)
08:27:43 <lambdabot> ap enumFromThenTo pred
08:27:55 <trofi^w> > reverse [0..10]
08:27:56 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:28:00 <ski> ah, `ap' to the rescue !
08:28:20 <ski> > (enumFromThenTo `ap` pred) 10 0
08:28:20 <BONUS> > ap enumFromThenTo pred 5 1
08:28:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:28:22 <lambdabot>   [5,4,3,2,1]
08:28:44 <BONUS> > ap zip tail $ ap enumFromThenTo pred 5 1
08:28:45 <lambdabot>   [(5,4),(4,3),(3,2),(2,1)]
08:28:49 <conal> S combinator
08:28:57 <osfameron> :t ap
08:28:57 <BONUS> gotta love the S combinator
08:28:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:29:12 <conal> :t (<*>)
08:29:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:29:13 <trofi^w> > let rev_list from to = [to, to-1..from] in rev_list 10 0
08:29:14 <lambdabot>   []
08:29:17 <ImInYourMonad> lilac: sure it doesnt mean you prove it totally, i was just meaning a haskell program is kind of a sketch proof to some extent and they way they are written make them a lot easier to verify(doesnt mean you cant eff things upp though)
08:29:31 <BONUS> (r -> a -> b) -> (r -> a) -> r -> b
08:29:52 <ski> trofi^w : s/rev_list/enumFromDownto/
08:30:12 <ski> (after flipping the argument order/names)
08:30:21 <trofi^w> :t enumFromDownto
08:30:22 <lambdabot> Not in scope: `enumFromDownto'
08:30:30 <trofi^w> heh :]
08:30:36 <idnar> enumThisNameREallySucks
08:31:00 <ski> > enumFromDownto 10 0  where  enumFromDownto = enumFromThenTo `ap` pred
08:31:01 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
08:31:30 <trofi^w> where word didn't work with runplugs
08:31:44 <ski> > enumFromDownto 10 (0 :: Double)  where  enumFromDownto = enumFromThenTo `ap` pred  -- hm
08:31:45 <lambdabot>   [10.0,9.0,8.0,7.0,6.0,5.0,4.0,3.0,2.0,1.0,0.0]
08:32:08 <ski> trofi^w : lambdabot quirk :)
08:32:19 <ski> (and in `Hugs', too, i think)
08:33:14 <trofi^w> mueval beats runplugs eval here
08:33:24 <trofi^w> > bad_var
08:33:24 <lambdabot>   Not in scope: `bad_var'
08:33:28 <trofi^w> > bad_var -- :]
08:33:29 <lambdabot>   Not in scope: `bad_var'
08:33:34 <ehird> Is there a `div` for Integers?
08:33:40 <trofi^w> :t div
08:33:41 <lambdabot> forall a. (Integral a) => a -> a -> a
08:33:45 <ehird> Oh. Huh.
08:33:47 <ski> (.. ah, now i see .. disabled DMR foiled my evil scheme ..)
08:33:56 <BONUS> > (6 :: Integer) `div` 3
08:33:57 <lambdabot>   2
08:34:04 <ehird> oh, right, it's just
08:34:05 <ehird> :t replicate
08:34:06 <lambdabot> forall a. Int -> a -> [a]
08:34:07 <ehird> annoying
08:34:10 <ehird> :t genericReplicate
08:34:11 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
08:34:29 <ski> *nod*
08:37:35 <ehird> newsham: I updated my Sierpinski program, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2336
08:37:45 <ehird> Now it's centered (using your trick) and the "right way up"
08:37:56 <ehird> Turns out the oddness on some (w,h) combinations is that it works best with powers of two.
08:37:59 <ehird> Everything else goes odd,
08:38:45 <daf> in more than one sense? :)
08:38:59 <BMeph> ehird: You should ask mauke - he put up a one-liner for that sometime last year. :)
08:39:08 <ehird> BMeph: did it use this algorithm though?
08:39:14 <ehird> "(x,y) is in the mandelbrot set if (x&y)==0"
08:39:35 <ehird> I had a oneliner for it, but then I centered it and flipped it, and added command line args
08:39:38 <ImInYourMonad> anyone know a good computer program that can teach you how to make circuits?
08:39:41 <ehird> but I really like the algorithm
08:39:46 <ehird> it's not immediately obvious why it works
08:40:33 <BMeph> ehird: Looks possible. I think he had it on "the original" hpaste, otherwise, I'd look for it.
08:41:00 <ehird> Mm. I wasn't aiming for shortness, just nice code using that neat algorithm :-)
08:41:15 <ehird> Say, what's the rage as far as rendering graphics does? It'd be nice to make a PNG instead of text
08:41:38 <wli> ehird: I recommend Graphics.GD
08:41:59 <ehird> OK. Is it high-level? :P
08:45:14 <wli> ehird: Not sure what you want out of high-level. I can draw lines from point to point, which is enough for me.
08:45:35 <ehird> I meant mainly in the "Write a PNG to file" sort of thing; the actual image is just plotting individual pixels
08:46:05 <wli> Yeah. That part keeps me happy and oblivious to details.
08:46:41 <ehird> yay
08:50:57 <ImInYourMonad> can pattern-exhaustion-verifiction not be done at compile time?
08:51:31 <ImInYourMonad> like could you some enforce it in some restricted subset of all patternoverlappings
08:51:57 <pejo> Im, if you don't want to write all the constructors every time it's undecidable, but "Catch" can tell when you have enough constructors for example.
08:52:21 <trofi^w> case x of _ | log(asin(x)) == y -> x1; _ | asin(log(x)) == y -> x2
08:52:24 <wli> It can be done some of the time. Some incomplete pattern matches get missed by -Wall
08:52:40 <temoto> Are there like hash functions that gives M or less bits produce M bits one way without collisions?
08:52:45 <temoto> given*
08:52:59 <wli> Some are spuriously flagged.
08:53:32 <quicksilver> temoto: perfect hashes
08:53:40 <drdozer1> hi
08:53:45 <quicksilver> temoto: (perfect hashes have no collisions, see 'gperf' for one implementation)
08:53:48 <drdozer1> I have a weird typeclass problem
08:53:49 <temoto> quicksilver: are there any existant?
08:53:52 <temoto> oh thanks
08:54:04 <ImInYourMonad> i emant can something like:
08:54:09 <ImInYourMonad> --mymap _ []     = []
08:54:09 <ImInYourMonad> mymap f (x:xs) = f x : mymap f xs
08:54:15 <wli> You have to construct a hash function for your particular data set.
08:54:19 <drdozer1> there are 2 lines in the same main method that need to use the same typeclass instance
08:54:20 <ImInYourMonad> be caught? if the mympa _ [] case isnt here?
08:54:40 <drdozer1> the 2nd use of the instance is discovered, but the first is not
08:55:03 <drdozer1> is there a standard reason why this may happen, or for debugging it?
08:55:07 <temoto> quicksilver: uh.. "given list of string it produces hash function an hash table".... uh so it can't be used for storing, e.g. user passwords?
08:55:11 <quicksilver> ImInYourMonad: yes, warnins will catch that case.
08:55:15 <temoto> like user password hashes
08:55:24 <quicksilver> temoto: perfect hashes need to know the data upfront
08:55:28 <quicksilver> this is obvious if you think about it
08:55:37 <ImInYourMonad> quicksilver: how? when compiled? i dotn egt a warning in ghci
08:55:51 <trofi^w> hash data | data < M = data; | otherwise = really_hash data M
08:55:51 <quicksilver> ImInYourMonad: warnigs aren't on by default.
08:55:59 <ImInYourMonad> how do iset them on?
08:56:00 <quicksilver> ImInYourMonad: check the fine manual :)
08:56:06 <pozic> Does this work for anyone? darcs get http://code.haskell.org/reactive/
08:56:06 <quicksilver> -Wall for all of them
08:56:07 <temoto> quicksilver: hm i thought that input data is equal or less than output data size is enough to avoid collisions.
08:56:44 <ImInYourMonad> quicksilver: how does ghc check those things anyway? how does it now if it should be exhaustive? or it doesnt it just checks eerything that isnt and reports it
08:56:49 <pozic> http://code.haskell.org/reactive/ returns nothing either.
08:56:59 <quicksilver> ImInYourMonad: it checks everything and gives warnigs if not
08:57:08 <quicksilver> ImInYourMonad: sometimes this is annoying, which I guess is why it isn't on by default.
08:57:38 <temoto> well thanks i see
09:00:10 <ImInYourMonad>  Warning: This binding for `init' shadows the existing binding
09:00:14 <ImInYourMonad> what does that mean?
09:00:53 <quicksilver> it means there was already something called 'init'
09:00:58 <quicksilver> and then you bound a new one.
09:01:19 <quicksilver> as in "let init = 3 in let init = 4 in let init = 5 in []"
09:02:11 <ImInYourMonad> i dont want allt he type signature warnings
09:03:25 <pozic> ImInYourMonad: that is why there are these things called options.
09:03:41 <ImInYourMonad> -W makes most sense
09:03:51 <ImInYourMonad> then i get warnings for non overlapping instances.
09:03:55 <ImInYourMonad> -Wall is a bitch
09:04:05 <dons> ?yow
09:04:05 <lambdabot> I want a WESSON OIL lease!!
09:04:13 <pozic> ImInYourMonad: you can enable every kind of warning on a per case basis.
09:04:21 <ImInYourMonad> ok
09:05:07 <pozic> man ghc RET/WarningRET
09:05:38 <pejo> dons, congrats to the RWH price!
09:06:06 <quicksilver> RWH price?
09:06:15 <dons> hehe
09:06:19 <dons> thanks :)
09:06:35 <dons> http://www.realworldhaskell.org/blog/2009/03/12/we-won-a-jolt-award/ <-- he means this
09:06:35 <pozic> Who was the competition? ;)
09:06:40 <pejo> http://www.earthtimes.org/articles/show/techweb-announces-winners-of-the,746892.shtml
09:06:56 <dons> well, it's an open field. any tech/prog. book, afaik
09:08:46 <pozic> Yes, I read the press release just now.
09:14:39 <drdozer1> can ghci be given search paths for :load?
09:14:49 <drdozer1> I have source spread over ./src and ./apps
09:15:04 <quicksilver> preusmably the same was that ghc does
09:15:04 <drdozer1> and need to step through one of the apps
09:15:12 <quicksilver> commandline options
09:15:17 <quicksilver> (it's the same program really)
09:16:06 <drdozer1> -i doesn't seem to help
09:19:36 <drdozer1> a, it was -i after all: ghci -isrc:apps
09:20:13 <swiert> Is it me, or can you no longer upload files to the haskell wiki?
09:22:16 <dons> swiert: do you have an account?
09:24:04 <ImInYourMonad> doe smake wrninsg fatal emn the compilation will fail?
09:24:15 <swiert> dons: yes.
09:24:25 <quicksilver> ImInYourMonad: yes, that's what fatal means in this context.
09:24:39 <swiert> dons: the upload just hangs. I've tried different browsers and different machines.
09:24:42 <dons> mm
09:24:48 <dons> might be a haskell.org bug
09:24:59 <dons> file size too big?
09:25:18 <swiert> nope.
09:25:30 <swiert> I e-mail Ashley, but no response.
09:25:43 <swiert> is he on irc?
09:25:44 <dons> he'll be waking up soon
09:25:53 <dons> he's in my timezone, and is usually quite responsive
09:27:27 <swiert> ok. thanks anyhow dons.
09:29:09 <C-Keen> I am trying to rewrite http://www.haskell.org/haskellwiki/Library/PNG into a lazy form...but I don't know whether that is possible due to the dependency on the length of a row...
09:30:41 <ImInYourMonad> to do something like skype, would it be feasible to do everything i  haskell or would the signalprocessing and p2p-ing have to be done in C?
09:31:09 <tomh> is >> usually implemented as a >> b = b ?
09:31:22 <ImInYourMonad> Werror should be fatal but isnt, it compile when W gives errors(and compiles)
09:32:28 <ehird> so, anyone got a fix to inferior-haskell.el's repetition
09:32:59 <BONUS> tomh: no, that would mean that >> is just \_ a -> a
09:33:10 <augustss> Haskell is just inferior, there's no fix for that.
09:33:12 <BONUS> e.g. const id
09:33:17 <tomh> so what is the default implementation of >>?
09:33:28 <tomh> I can't find an example they all seem to omit it
09:33:36 <BONUS> m >> n = m >>= \_ -> n
09:33:43 <lilac> tomh: a >> b = a >>= const b
09:33:43 <doserj> @src (>>)
09:33:43 <lambdabot> m >> k      = m >>= \_ -> k
09:33:46 <dons> ImInYourMonad: no, you'd do it all in Haskell.
09:33:54 <tomh> ok thanks
09:34:02 <dons> remember: if we can write a kernel in haskell, you can write any systems code in it.
09:34:17 <BONUS> it's like binding the monad to a name and then discarding that name
09:34:33 * abbe points ehird to a fix he posted in gnu.emacs.help at http://groups.google.com/group/gnu.emacs.help/browse_frm/thread/d4b1fa8deebf01c4/bff7bc6610bd5f29?lnk=gst&q=haskell+mode#bff7bc6610bd5f29
09:34:40 <BONUS> also in Applicative it's m >> k = fmap (const id) m <*> k
09:34:45 <drdozer1> dons: there;s a kernel in haskell?
09:35:00 <dons> several.
09:35:14 <tomh> i see ok thanks
09:35:16 <ehird> abbe: that's not it.
09:35:28 <ehird> Prelude> 2+2
09:35:28 <ehird> 2+2
09:35:30 <ehird> 4
09:35:32 <ehird> the input line is duplicated
09:35:58 <abbe> ehird, oh, okay.
09:36:10 <ehird> others have that problem
09:36:14 <ehird> haven't seen a solution
09:36:28 <cads__> morning folks
09:36:36 <ski> ehird : (no idea what you're asking about, but) have you tried kuribas-mode ?
09:36:49 <ehird> kuribas-mode?
09:36:56 <ski> @where kuribas
09:36:56 <lambdabot> I know nothing about kuribas.
09:36:56 <ehird> oh, is that the indentation thing?
09:36:57 <ehird> I have that.
09:36:59 <ski> @where kuribas-mode
09:36:59 <lambdabot> I know nothing about kuribas-mode.
09:37:07 <ski> @slap lambdabot
09:37:07 * lambdabot slaps lambdabot with a slab of concrete
09:37:08 <ehird> I'm talking about inferior-haskell breakage.
09:37:28 * lilac suspects that "a >> b = b" implies the monad is isomorphic to Identity
09:37:47 <bremner> ehird: that link talks about inferior, haskell, no?
09:38:04 <ehird> it's a fix to the wrong problem.
09:38:04 <ski> @where+ kuribas-mode http://kuribas.hcoop.net/haskell-indentation.el
09:38:04 <lambdabot> Okay.
09:38:07 <Saizan> lilac: reader
09:38:36 <lilac> Saizan: hmm. also 'data MinMax a = MinMax a a'
09:38:38 <bremner> ehird: oh, I see. Sorry, in fact I was having the ^J issue
09:38:44 <ehird> :)
09:39:03 <ImInYourMonad> dons: how much work is it to use any of the mp3-decoders in C in haskell? i had a look at your mp3player but it seemed like a lot of work. im interested in signalprocessign though and this seems like a good way in.
09:39:16 <doserj> > (+2) >> (*3) $ 5
09:39:17 <lambdabot>   15
09:40:11 <lilac> Saizan: seems like there should be something interesting / nonobvious one can say about such monads though :)
09:40:25 <ehird> > 5*3
09:40:26 <lambdabot>   15
09:40:32 <ehird> doserj: you need some >>=
09:40:41 <centrinia> > (+2) >>= (*3) $ x
09:40:41 <ehird> > (+2) >>= (*) $ 5
09:40:43 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> b
09:40:43 <lambdabot>      Proba...
09:40:43 <lambdabot>   35
09:40:45 <ehird> > (+2) >>= (*) $ 5
09:40:46 <lambdabot>   35
09:41:04 <abbe> ehird, okay, so we've to disable ghci's echo functionality
09:41:04 <centrinia> > (+2) >>= (*) $ x
09:41:05 <lambdabot>   (x + 2) * x
09:41:05 <ehird> > 5*(5+2)
09:41:07 <lambdabot>   35
09:41:15 <ehird> centrinia: yeah
09:41:19 <ehird> > f >>= g $ x
09:41:20 <lambdabot>   Add a type signature
09:41:21 <ImInYourMonad> how doe sghc check for missing patternmatches? if there is an argument that uses (:) there has to eb anrgument [] ont he same place somewhere?
09:41:27 <centrinia> > (+y) >>= (*) $ x
09:41:28 <lambdabot>   (x + y) * x
09:41:30 <ehird> :t f
09:41:30 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
09:41:33 <ehird> hmm
09:41:37 <ehird> why doesn't
09:41:42 <ehird> (f >>= g $ x) work?
09:42:01 <ehird> > ((f >>= g) x) :: Expr
09:42:02 <lambdabot>   Add a type signature
09:42:37 <ehird> > (((f :: (SimpleReflect.FromExpr a,SimpleReflect.FromExpr b) => a ->b) >>= (g :: (SimpleReflect.FromExpr a,SimpleReflect.FromExpr b,SimpleReflect.FromExpr c) => a -> b -> c)) x) :: Expr
09:42:38 <lambdabot>       Not in scope: type constructor or class `SimpleReflect.FromExpr'    Not...
09:42:57 <ehird> > let f' = f :: Expr -> Expr; g' = g :: Expr -> Expr -> Expr in (f >>= g) x
09:42:58 <lambdabot>   Add a type signature
09:43:14 <ehird> hmph
09:44:39 <wjt> @pl \xs -> sqrt . mean . map (square . (subtract $ mean xs)) $ xs
09:44:39 <lambdabot> ((sqrt . mean) .) =<< map . (square .) . subtract . mean
09:45:08 <wjt> daf: ^^ is clearly more legible :)
09:45:22 <ehird> whhhhhhhaaat
09:45:24 <ehird> no way
09:45:26 <ehird> :P
09:45:45 <daf> wjt: :D
09:46:19 <centrinia> > (((sqrt . mean) .) =<< map . (square .) . subtract . mean) [1..10]
09:46:20 <lambdabot>   Not in scope: `mean'Not in scope: `square'Not in scope: `mean'
09:46:39 <centrinia> @let square = ^2
09:46:39 <lambdabot>   Parse error
09:46:44 <centrinia> @let square x = x^2
09:46:45 <lambdabot>  Defined.
09:47:00 <centrinia> @let mean xs = sum xs / fromIntegral (length xs)
09:47:00 <lambdabot>  Defined.
09:47:03 <centrinia> > (((sqrt . mean) .) =<< map . (square .) . subtract . mean) [1..10]
09:47:04 <lambdabot>   2.8722813232690143
09:48:19 <ImInYourMonad> why the hell is jane street using ocaml and not haskell? seems like a terribel choice
09:49:08 <bremner> ImInYourMonad: could be worse
09:49:12 <daf> shrug. OCaml has a decent compiler. if it's what you're used to, why change?
09:50:40 <dons> ImInYourMonad: you're making no sense.
09:51:06 <ImInYourMonad> why not?
09:51:18 <ImInYourMonad> ive tried ocaml and haskell wins in every way
09:51:22 <dons> great!
09:52:51 <centrinia> @faq Can Haskell beat Ocaml in a fight to the death?
09:52:51 <lambdabot> The answer is: Yes! Haskell can do that.
09:53:18 <jenner> :)
09:53:41 <ImInYourMonad> @faq Can Haskell lose to Ocaml in a fight to the death?
09:53:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:53:45 <ImInYourMonad> pwnd
09:54:07 <nlogax> only if it wants to
09:54:26 <centrinia> @faq Can Haskell ignore the law of the excluded middle?
09:54:26 <lambdabot> The answer is: Yes! Haskell can do that.
09:55:30 <jenner> @faq Can Haskell compute an infinite recursion in finite amount of time?
09:55:30 <lambdabot> The answer is: Yes! Haskell can do that.
09:55:38 <jenner> awesome
09:55:52 <te> Can Haskell do my laundry?
09:56:21 <jenner> @faq Can Haskell force te to do his laundry?
09:56:21 <lambdabot> The answer is: Yes! Haskell can do that.
09:56:24 <jenner> see
09:56:33 <te> Oh my god!
09:56:59 <te> @faq Can Haskell's lambdabot fail?
09:56:59 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:26 <Eridius> @faq Can Haskell save the world from a terrible fiery death?
09:57:26 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:29 <Eridius> phew!
09:57:33 <jenner> what a relief
09:57:38 <foo-nix> Where can sourceLanguageManagerGuessLanguage be found?
09:57:43 <foo-nix> i.e. what ahskell package?
09:57:44 <goomba`> @faq Can Haskell mess with Texas and get away with it?
09:57:44 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:52 <te> lol
09:57:55 <Eridius> foo-nix: Hayoo! can search within hackage packages
09:58:05 <C-Keen> @go hayoo
09:58:06 <lambdabot> No Result Found.
09:58:07 <Eridius> although it finds nothing for sourceLanguageManagerGuessLanguage
09:58:09 <centrinia> > let f x = f (x+1) in const "foobar" (f 0)
09:58:10 <lambdabot>   "foobar"
09:58:10 <foo-nix> Eridius: Hayoo.org?
09:58:11 <te> @faw Can Haskell beat Bruce Scheier in a duel of awesomeness?
09:58:11 <lambdabot> The answer is: Yes! Haskell can do that.
09:58:14 <Eridius> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:58:59 <centrinia> @let const' x y = seq y x
09:59:00 <lambdabot>  Defined.
09:59:04 <centrinia> > let f x = f (x+1) in const' "foobar" (f 0)
09:59:08 <foo-nix> Eridius: what is yahoo?
09:59:12 <foo-nix> *hayoo
09:59:25 <Eridius> it's a search engine like hoogle, but it searches hackage packages too
09:59:36 <lambdabot>   thread killed
09:59:38 <foo-nix> Eridius: hoogle?
09:59:43 <Eridius> ...
09:59:58 <foo-nix> Eridius: most browsers aren't case sensitive, but they are character sensative.
10:00:02 <Badger> @hoogle Data.Map
10:00:02 <lambdabot> module Data.Map
10:00:02 <lambdabot> Data.Map data Map k a
10:00:02 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
10:00:15 <jenner> centrinia: omg, you hax0red lambdabot
10:02:31 <ski> @botsnack
10:02:31 <lambdabot> :)
10:02:31 <lunabot>  :)
10:02:40 <Badger> :)
10:02:42 <te> :)
10:02:54 <C-Keen> :)
10:02:57 <LeoD> :)
10:03:05 <ski> (:
10:03:10 * te tilts his head and visualizes the graph
10:03:21 <te> ski, you've just made us non-continuous
10:03:22 <ski> (someone think of the brackets !)
10:03:30 <Gracenotes> (>^.^)>
10:03:34 <Gracenotes> <(^.^<)
10:05:10 <LeoD> @faq Can Haskell fix those brackets?
10:05:10 <lambdabot> The answer is: Yes! Haskell can do that.
10:06:05 <Eridius> @faq Can Haskell be used to build iPhone apps?
10:06:05 <lambdabot> The answer is: Yes! Haskell can do that.
10:06:07 <Eridius> LIAR!
10:06:12 <BONUS> oooh
10:06:14 <LeoD> haha
10:06:16 <BONUS> const id = flip const
10:06:33 <shepheb> Eridius: why not? bundle Hugs
10:06:39 <C-Keen> > printLn "@botsnack"
10:06:40 <lambdabot>   Not in scope: `printLn'
10:06:41 <bremner> Eridius: I have hugs on my iPhone.
10:06:43 <quicksilver> Eridius: sure it can. First write an iphone backend to GHC (in haskell)
10:06:51 <quicksilver> Eridius: then write your app in haskell.
10:06:55 <quicksilver> step 3. profit.
10:07:37 <Eridius> shephe, bremner: that goes against the SDK agreement
10:07:57 <jenner> 1) sell your iphone 2) buy an android-based smartphone 3) ... x) profit.
10:08:18 <quicksilver> bundling hugs only goes against the agreement if you actually allow the user to execute arbitrary code.
10:08:27 <quicksilver> having hugs running behind the scenes to run your code is fine, AFAIK.
10:09:18 <ski> @check forAll openingBracket $ \o -> exists closingBracket $ \c -> matches o c
10:09:19 <lambdabot>   Not in scope: `openingBracket'Not in scope: `exists'Not in scope: `closingB...
10:09:28 <quicksilver> jenner: don't "applications" on the android have to be written in some java stack?
10:09:48 <quicksilver> jenner: so you can't write haskell apps for android either.
10:09:49 <daf> you can ship .so files
10:09:53 <Ferdirand> one could argue that haskell code is not arbritary code :)
10:09:57 <daf> and link them into a Java wrapper
10:09:58 <LeoD> how about symbian? :>
10:09:58 <jenner> they don't _have_ to
10:10:25 <daf> quicksilver: so I think it's possible to use anything that you can compile to a library; it's just a pain
10:11:01 <ski> quicksilver : how about "considering" arbitrary data ?
10:11:24 <quicksilver> ski: I guess the fine distinctions are between you and the app store approval team :)
10:11:26 <Eridius> quicksilver: unless the code is already compiled, then it's against the SDK agreement
10:11:34 <Eridius> you can't bundle hugs and bundle haskell source and have hugs execute that
10:11:46 <quicksilver> ski: if it doesn't look like a programming tool, it will probably be fine.
10:11:55 <ski> quicksilver : data to manipulate can be considered code to interpret (or compile)
10:12:01 <quicksilver> I know.
10:12:05 <quicksilver> I appreciate the point you're making.
10:12:06 <shepheb> use jhc to build portable C, compile it.
10:12:17 <quicksilver> I'm saying this is a soft rule, administered by humans.
10:12:19 <shepheb> app store, I don't know. but it runs.
10:12:31 <quicksilver> not a hard rule you could arbitrate by a system.
10:12:51 <ski> "hey, surely there's no problem letting the user evaluate mathematical expressions on this fine calculator ?"
10:13:06 <quicksilver> Eridius: are you sure? most games these days have game logic in a scripting language.
10:13:11 <quicksilver> Eridius: 'cube' for example
10:13:15 <quicksilver> (And that's on the iPhone)
10:13:40 <quicksilver> I'm be surprised if that technique wasn't used by plenty of the games on teh store.
10:14:15 <elliottt> dcoutts__: i've got a cabal question for you :)
10:15:01 <Eridius> quicksilver: actually I just realized it's not an SDK limitation, it's a technical one - you can't bundle a separate executable and call it, you're not allowed to fork.
10:15:06 <Eridius> so you can't bundle hugs
10:15:33 <proq> of course you can bundle hugs.  if you can bundle torquescript and lua, you can bundle any scripting language within reason
10:15:38 <ImInYourMonad> if i have a module RedBlackTree and I want to make a module HuffmanTree that uses redblacktree as its base, can I inherit allt he operatins somehow? i mean i want all operations but just have type HuffmanTree = RedBlackTree instead...
10:15:44 <quicksilver> Eridius: you don't need to fork to bundle hugs
10:15:48 <quicksilver> (are you trying to be stupid?)
10:15:52 <quicksilver> you can just link it directly.
10:16:17 <Eridius> quicksilver: I'm not familiar with hugs, does it not operate the same way as ghc?
10:16:22 <Eridius> e.g. a compiler?
10:16:23 <quicksilver> it's an interpreter.
10:16:33 <Eridius> oh, huh
10:16:33 <quicksilver> written in portable C.
10:16:38 <Eridius> I did not know that
10:16:50 <quicksilver> that's why people are suggesting it woudl be easier to get it on the iPhone :)
10:17:06 <quicksilver> ImInYourMonad: modules don't inherity.
10:17:16 <quicksilver> ImInYourMonad: but you can certainly write type HuffmanTree = RedBlackTree if you want.
10:17:25 <Eridius> well, being written in C means it can be compiled for the iPhone itself, but I didn't realize that it was an interpreter. I assume that means it can be compiled into a library?
10:17:30 * quicksilver nods
10:17:50 <Eridius> huh
10:17:58 <b\6> in TH, can i construct the name of a function in a normalB [| ... |] ?
10:18:02 <quicksilver> in principle, at least.
10:18:12 <quicksilver> I'm not sure if anyone maintains a particular distribution of 'hugs as a library'
10:18:20 <quicksilver> but it would be a simple case of replacing the main() function.
10:18:27 <elliottt> ImInYourMonad: does making a type alias work for you?  type HuffmanTree = RedBlackTree
10:19:40 <ImInYourMonad> yes
10:19:46 <ImInYourMonad> but that doesnt inherit all themethods
10:19:55 <elliottt> i'm not sure what you mean by inherit
10:20:09 <tomh> If I have some function bla::SomeMonad Int is there any way I can use System.Random.randomR in it ?
10:20:16 <elliottt> all of those functions will work on your new HuffmanTree type
10:20:22 <elliottt> as long as it's an alias
10:21:40 <elliottt> you can always re-export the RedBlackTree module from your HuffmanTree module, so that you can use the HuffmanTree module alone
10:21:54 <quicksilver> ImInYourMonad: haskell doesn't have inheritance.
10:22:02 <quicksilver> ImInYourMonad: asking for a module to inherit things doesn't mean anyhing.
10:22:02 <Eridius> tomh: randomR takes a RandomGen as input.
10:22:13 <quicksilver> ImInYourMonad: since the types would be the same, you'd be able to use all the functions.
10:22:18 <tomh> ye, but I mean about the IO
10:22:37 <sw17ch> hello
10:22:37 <quicksilver> ImInYourMonad: (they're not called methods, that name is reserved for typeclass methods)
10:22:50 <tomh> if I want to use the random number I will need to stay in IO right?
10:23:06 <elliottt> tomh: no, you'll just need to thread around a StdGen
10:23:19 <tomh> what do you mean with thread around?
10:23:36 <elliottt> well, randomR produces an a, and a new StdGen
10:23:49 <elliottt> you keep re-using the StdGen to get new numbers
10:24:01 <elliottt> but you have to use the new one each time, or else you'll get the same number
10:24:09 <tomh> ah k
10:24:28 <tomh> I will need my custom StdGen then i think
10:24:32 <Eridius> tomh: you only have to use IO if you use something like randomRIO or getStdGen/newStdGen
10:25:11 <ImInYourMonad> it ti just that i want functions to have the type annotation HuffmanTree and i dont want to do: singleton :: a -> HuffmanTree a
10:25:11 <ImInYourMonad> singleton v = RBT.singleton v
10:25:14 <elliottt> tomh: are you just trying to get a function that produces a random number inside of some monad, and tracks the StdGen for you?
10:25:14 <ImInYourMonad> for every fucntion...
10:27:19 <tomh> elliottt: ye, i am supposed to build it using reader and monad reader style monads
10:27:51 <elliottt> tomh: ah.
10:27:58 <Eridius> could you claim state is reader-style?
10:31:25 <ddarius> type State s a = forall st. ReaderT (STRef st s) (ST st) a
10:32:32 <b\6> if f = "foo", can i use a function fooX in normalB [| ... |]? i'm not sure if i'm supposed to be doing stuff like $(f ++ "X") in there or what.
10:32:39 <jeffersonheard> so I cabal-installed a bunch of packages, and now when I try to rebuild a package of mine using runhaskell Setup.hs ..., it complains that it can't find any of the packages I installed
10:32:58 <Botje_> did you upgrade ghc?
10:33:02 <jeffersonheard> says "at least the following dependenceis are missing" and lists two packages i know are installed
10:33:08 <jeffersonheard> Yes, and then installed the packages
10:33:13 <jeffersonheard> just started using GHC 6.10
10:33:20 <Botje_> you'll have to reinstall those packages
10:33:25 <Botje_> check what ghc-pkg list says
10:33:30 <jeffersonheard> thought I would use the cabalized version of everything
10:33:48 <jeffersonheard> they're there
10:33:58 <Botje_> that should work then =(
10:34:00 <jeffersonheard> heck, I just cabal installed the package I'm trying to rebuild
10:34:10 <jeffersonheard> so I know all its dependencies are there
10:34:27 <jeffersonheard> /home/jeff/.ghc/x86_64-linux-6.10.1/package.conf:
10:34:28 <jeffersonheard>     FTGL-1.1, GLFW-0.3, GLUT-2.1.1.2, HTTP-4000.0.4, Hieroglyph-1.2,
10:34:30 <jeffersonheard>     Hipmunk-0.2.1, IfElse-0.85, OpenGL-2.2.1.1, colour-2.2.1,
10:34:31 <jeffersonheard>     parsec-3.0.0, pngload-0.1, zlib-0.5.0.0
10:34:49 <ImInYourMonad> does haskell have priority queus?
10:35:01 <ImInYourMonad> queues
10:35:44 <doserj> jeffersonheard: runhaskell Setup.hs --user
10:35:55 <jeffersonheard> ImInYourMonad: you can make them using Data.Map or Data.IntMap since keys are ordered.  I believe there is a removeLowest or something ike that
10:36:28 <quicksilver> that's not always convenient, though
10:36:41 <quicksilver> and doesn't have quite the best complexity
10:36:56 <quicksilver> I'm pretty sure tehre is a fingertree-based pqueue implementation around somewhere.
10:37:06 <fR0D> hi everyone
10:37:15 <fR0D> i am new to haskell programming
10:37:22 <fR0D> i am still learning it
10:37:24 <abbe> hi fR0D
10:37:25 <Botje_> hello, fR0D!
10:37:43 <dolio> Edison has at least one, too.
10:37:43 <fR0D> can anybody around here tell me how to take n number of inputs
10:37:59 <Botje_> inputs from where?
10:38:01 <ddarius> data Tree a = Leaf a | Branch (Tree a) (Tree a); data P a = P { leaf' :: a -> Either (Tree a) (P a), branch :: P a }
10:38:06 <Botje_> commandline? standard input? a file? network?
10:38:10 <fR0D> standard input
10:38:24 <Botje_> how are they separated?
10:38:30 <Botje_> spaces , newlines or something else?
10:38:32 <fR0D> newline
10:39:01 <fR0D> i mean first line specifies n and then there are n lines each contaning a single integer
10:39:07 <Botje_> oh
10:39:30 <fR0D> i need to take all these inputs and process them
10:39:37 <ddarius> makeTree = right Left where left f = P (Right . right . f . Leaf) (left (\ll r -> Right (right (\lr -> f (Branch ll lr) r)))); right f = P (f . Leaf) (left (f .: Branch))
10:39:43 <Botje_> getInputs = do { num <- read `liftM` getLine; map read `liftM` replicateM num getLine }
10:39:56 <Botje_> that has type signature IO [Int]
10:40:45 <fR0D> i suppose this will store all the inputs at once
10:41:01 <BONUS> no, haskell has lazy I/O
10:41:02 <fR0D> what if i wish to take a input process it and then take another input
10:41:14 <fR0D> k
10:41:14 <BONUS> what you can also do us to take all the input with getContents
10:41:21 <Botje_> then you call getInputs again
10:41:29 <BONUS> and then break it up into lines by using the "lines" function from Data.List
10:41:48 <BONUS> basically you can treat the input like one whole string but haskell will read it one line at a time
10:42:01 <fR0D> ok
10:42:15 <tomh> you can also get it to read it in other ways
10:42:25 <jeffersonheard> doserj, thanks, that worked
10:42:26 <fR0D> like?
10:42:34 <tomh> like per block
10:42:58 <fR0D> what would be the faster way?
10:43:06 <doserj> jeffersonheard: good :) you could also call cabal install instead of runhaskell Setup.hs ... cabal uses --user by default, runhaskell Setup.hs doesn't
10:43:22 <fR0D> i mean which handles input output more faster
10:43:45 <Botje_> fR0D: you shouldn't focus on speed
10:43:48 <BONUS> eh, don't think about the speed just yet
10:44:04 <Botje_> horrible atrocities have been committed in the name of performance.
10:44:07 <fR0D> ok ok
10:44:09 <jeffersonheard> doserj, I thought that always pulled it from the server.
10:44:20 <fR0D> let me try it out
10:44:34 <jeffersonheard> I'm debugging the FTGL library, so I don't want to upload every bad version to the server until I"m done with it
10:44:35 <fR0D> i will let you guys know if i have more trouble
10:44:40 <fR0D> thanks anyways
10:45:12 <proq> Botje_: ha ha
10:45:18 <doserj> jeffersonheard: just "cabal install" not "cabal install FTGL". if there is a .cabal file in the current directory, it will build it
10:45:28 <jeffersonheard> doserj, thanks again
10:45:45 <jeffersonheard> I know this is documented somewhere, but I continue just to crash course my way thorugh things
10:47:36 * Saizan is not sure that it's actually documented
10:47:54 * p_l mistakenly read FTGL as FTL. Certainly not yet acquired through haskell :D
10:47:56 <Saizan> someone should blog on the proper use of cabal-install!
10:49:46 <ImInYourMonad> on instance for show IntMap, how do id eclar eone?
10:50:00 <Eridius> @faq Can Haskell achieve Faster-Than-Light Travel?
10:50:00 <lambdabot> The answer is: Yes! Haskell can do that.
10:50:33 <doserj> cabal install --help mentions it, but there really should be a proper user-guide
10:51:03 <jeffersonheard> @faq Is Haskell ready for quantum computing?
10:51:03 <lambdabot> The answer is: Yes! Haskell can do that.
10:52:00 <jeffersonheard> actually... Haskell's laziness could be understood in terms of quantum physics...
10:52:36 <jeffersonheard> obv. it's not really a quantum computer on top of a traditional one, but you don't incur the cost of a lazy computation until you evaluate it, so you could potentially have infinite possibliitles
10:52:46 <jeffersonheard> so long as you only evaluate some of them
10:53:24 <MyCatVer1s> You appear conflating quantum physics with the lonesome idea of many-worlds.
10:53:51 <jeffersonheard> possibly.  I'm not a physicist
10:54:06 <sw17ch> ah, i disagree
10:54:16 <MyCatVerbs> I really can't think of any Haskell features that look even remotely like entanglement, for example.
10:54:24 <sw17ch> the lazy out come has some predefined result
10:54:27 <sw17ch> and it will always be that result
10:54:35 <sw17ch> there really isn't a "whatif" situation about it
10:54:37 <MyCatVerbs> sw17ch: precisely.
10:54:45 <MyCatVerbs> Haskell works more like a grad student's whiteboard.
10:54:49 <sw17ch> you either whack the thunk or you don't
10:55:20 <MyCatVerbs> A grad student can describe infinite structures, so long as she doesn't attempt to write out the whole structure onto the blackboard simultaneously, and so long as her definition of that structure fits into finite space.
10:55:25 <jeffersonheard> fair enough.
10:55:29 * lilac thinks that @faq should print 'No, Haskell can't do that' one time in a hundred, just to freak people out
10:55:40 <MyCatVerbs> Plus, everybody knows that grad students are just as lazy as Haskell is. ^_^
10:55:53 <dolio> unsafeInterleaveIO can get you stuff that looks more like entanglement. :)
10:56:01 <ski> hm .. might it be nice if there were an `hParseContents :: Handle -> (String -> Maybe (a,String)) -> IO a' function ?
10:56:03 <MyCatVerbs> lilac: and, "Yes, Haskell can do that to your mum." every ten thousandth.
10:56:24 <jeffersonheard> dolio, that was actually what I was thinking about
10:56:46 <jeffersonheard> like...  type of Schrodinger's Cat = IO (Either DeadCat AliveCat)
10:56:56 <jeffersonheard> implemented internally with unsafeInterleaveIO
10:57:10 <MyCatVerbs> jeffersonheard: forkIO. Look into futures, perhaps.
10:57:15 <lilac> jeffersonheard: how would you tell?
10:57:16 <ski> (hm .. probably s/IO a/IO (Maybe a)/, then .. but possibly deterministic parser would be better anyway)
10:57:33 <ImInYourMonad> how is priority in an Queue supposed to be done. i mean it doesnt need to be in the implementation just done by the user but it seems weird to have to specify more weird priorities like 1.4 1.42 etc the whoel time if you get a lot of them
10:58:09 <MyCatVerbs> ski: I'm not sure how you could write that and make it better than hGetContents.
10:58:14 <jeffersonheard> ImInYourMonad, you could create a combinator, "before" that establishes order between an item and another item on the queue
10:58:29 <lilac> jeffersonheard: unsafePerformIO (randomChoice [Left DeadCat, Right AliveCat]) -- the cat isn't dead or alive until someone forces the thunk. no interleave needed
10:58:44 <Saizan> there's an implementation of such a queue in the Adaptive package
10:58:52 <jeffersonheard> lilac: perfect
10:58:59 <ski> MyCatVerbs : the returned `String' would be accessible through `getChar', et.c., "after" the call to `hParseContent'
10:59:33 <awarrington> so I read in RWH that Data.Traversable could be used to combine monads (an alternative to monad transformers maybe?)...are there any good resources that would explain how that would work?
10:59:35 <jeffersonheard> but yeah, entanglement still not part of Haskell
10:59:38 <jeffersonheard> too bad
10:59:43 <MyCatVerbs> ski: ...getChar? getChar :: IO Char, for pulling characters from stdin. Sure you didn't mean something else?
10:59:46 <lilac> jeffersonheard: sure it is :-)
10:59:58 <ski> MyCatVerbs : probably if you call `getChar' before the parse has been forced, that would in itself force the parse, so as to know from where the input stream was relinguished by the parsing
11:00:02 * lilac comes up with example
11:00:06 <ImInYourMonad> it says o wikipedia a heap is normally used to imp a Pri Queue but that selfbal BSTs are used often if those are already available
11:00:14 <ImInYourMonad> so i can use my rbt then
11:00:16 <ski> MyCatVerbs : sorry, `hGetChar' (on the same handle)
11:00:36 <ImInYourMonad> why doesn IntMap have a show defined for it?
11:00:41 <dolio> lilac: unsafePerformIO is more powerful than unsafeInterleaveIO, so saying the latter isn't needed isn't that surprising.
11:01:10 <MyCatVerbs> ski: you can achieve that, for read-only files on disk, just by opening a second handle on the same file.
11:01:12 <ski> MyCatVerbs : `hGetContents' makes the handle unusable for other read operations .. i don't want that
11:01:29 <ski> MyCatVerbs : and network streams ? :)
11:01:42 <sw17ch> sw17ch_cat :: Both Alive Dead
11:01:53 * sw17ch wonders if there's a Both type
11:02:09 <MyCatVerbs> ski: don't do lazy IO on network streams. Read strict ByteStrings in.
11:02:35 <ski> i.e. i want the handle to return from "semi-closed" (or whatever the term was) to "open"
11:02:47 <ski> MyCatVerbs : why ?
11:03:27 <ski> sw17ch : `(,)' ?
11:03:49 <sw17ch> ski: i was thinking more along the lines of "both a Tree and an Int"
11:03:56 <sw17ch> as in, this can be represented as either of these things
11:04:01 <sw17ch> i dunno
11:04:06 <sw17ch> it's a little odd
11:04:34 <ski> @type (Node 'a' [],42 :: Int)
11:04:35 <lambdabot> (Tree Char, Int)
11:04:36 <lilac> jeffersonheard: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2341#a2341
11:04:42 <ski> there you go
11:05:02 <ski> oh .. "this can be represented as either of these things"
11:05:13 <ski> so, `Either (Tree Char) Int' ?
11:05:28 <MyCatVerbs> ski: for starters, you need to be able to hClose file handles so you don't hit the file descriptor limit.
11:05:39 <lilac> jeffersonheard: the MR can be seen as entanglement in some sense :)
11:05:58 <ski> MyCatVerbs : one would need to `hClose' the handle manually, of course .. that's expected
11:06:31 <ski> MyCatVerbs : for `hGetContents' one wouldn't, but for `hParseContents', one would
11:06:40 <ski> (that's part of the point)
11:07:03 <MyCatVerbs> ski: except that you can't do that, because there might be unevaluated parts of the structure that hParseContents hasn't forced yet.
11:07:11 <ski> (sw17ch : .. or maybe you're after intersection or union types ?)
11:07:41 <MyCatVerbs> Er... *thinks*, unevaluated parts of the structure that depend on parts of the input that haven't been forced yet.
11:07:43 <ski> MyCatVerbs : i'm saying that would force those parts :)
11:08:15 <MyCatVerbs> ski: are you saying you'd force the entire structure immediately before returning, ala rnf?
11:08:16 <largos> how do you uninstall a package that was installed with cabal install?
11:08:22 <ski> no
11:08:39 <largos> (I'm trying to use yi-gtk, and didn't realize that I wasn't supposed to install that cabal package)
11:08:56 <Eridius> largos: well, you could just `ghc-pkg unregister yi-gtk` but that will still leave the files on-disk
11:09:05 <ski> just that trying to do any read operation on the handle afterwards would have to force the parse, so as it would know from what position to relinguish to manual management again
11:09:24 <largos> Eridius: ah, thanks -- that's definitely better than what I have currently
11:09:43 <Eridius> largos: you can locate the files (use `ghc-pkg describe yi-gtk` and look in the dirs it talks about) and rm them by hand
11:10:03 <Eridius> at least ghc-pkg records the dirs, so you can find them later, unlike most unix tool installation ;)
11:10:03 <jeffersonheard> lilac: I like it
11:10:04 <ski> (it wouldn't necessarily have to force the parsing itself .. but the parsing would have to decide exactly what characters it wants to eat)
11:10:13 <largos> hehe.. yeah..
11:10:31 <jeffersonheard> does anyone know of performance differences between the latest HaXml and the 1.13 series?
11:10:40 <largos> well, unregistering didn't fix the yi problem (can't find Yi.UI.Gtk), so I have some reading/searching to do anyway..
11:10:51 <ski> MyCatVerbs : i'm not saying this will work .. i'm saying it might work
11:10:56 <Eridius> largos: head over to #yi and I'll help you
11:11:01 <Eridius> I'm pretty sure I know your problem
11:11:03 <MyCatVerbs> ski: are you saying you'd keep the entire portion of the input that has been read but hasn't been discarded by the parser yet.
11:11:08 <MyCatVerbs> s/./?/
11:11:21 <ski> i'm not sure
11:11:39 <MyCatVerbs> ski: because there's no reason why you could possibly do that with hParseContents but not with hGetContents.
11:12:01 <ski> probably we need some more abstract interface to parsing than `String -> Maybe (a,String)', though
11:12:25 <MyCatVerbs> In fact, you'd *have* to do that for hGetContents, and then hParseContents becomes trivial.
11:12:37 <ski> MyCatVerbs : i want to be able to do `do x <- hParseContents parser; l <- hGetLine; ..'
11:13:19 <MyCatVerbs> ski: in actual application code, right now? do { content <- hGetContents; let x = parser content; let l = head . lines $ x; }
11:13:36 <MyCatVerbs> *facepalm*. head . lines $ content, sorry.
11:14:13 <ski> MyCatVerbs : can i convert a `String' to a `Handle' ?
11:14:30 <ski> (without going via a temporary file, obviously)
11:15:12 <MyCatVerbs> ski: No, not by any good method. You could use socketPair and lazily write into one end, but that's disgusting beyond all mortal comprehension.
11:15:17 <ski> instead of `hGetLine h' i may call a library which calls `hGetLine' somewhere
11:15:59 <MyCatVerbs> ski: the only answer is "don't". If the library only does pure computation, then it should be written as (String ->...) rather than (Handle ->...), for the love of Pete.
11:16:13 <ski> .. and if it doesn't ? :)
11:16:26 <MyCatVerbs> If not, then, eh, you have issues anyway. What library are you talking about?
11:16:41 <ski> i want *composable* code, damnit ! :)
11:16:45 <MyCatVerbs> No.
11:17:21 <ski> (and no, i don't have any example right now .. but i think i've seen some)
11:17:36 <MyCatVerbs> GHC devs probably won't give you infinitessimal composability gains when the tradeoff involves losing speed for every single Handle-using function in all of Haskell.
11:18:03 <MyCatVerbs> Libraries should, generally speaking, not do IO on Handles. That's for applications to do.
11:18:25 <MyCatVerbs> (Not expect you to pass them Handles for them to do IO on, I mean. Using Handles internally, sure whatever.)
11:18:31 <Saizan> i think the new implementation of GHC IO actually let you convert strings to Handles
11:18:36 <davidL> how do I make [a] be [Int] in: randoms `fmap` getStdGen ?
11:18:54 <Eridius> davidL: with a type annotation?
11:18:57 <Eridius> :: [Int]
11:19:05 <Eridius> well, getStdGen actually returns IO StdGen
11:19:08 <davidL> I get an error
11:19:30 <Saizan> the one that is going to support encodings.
11:19:35 <Eridius> yeah I think you want :: IO [Int]
11:19:36 <ski> @type randoms `fmap` getStdGen
11:19:37 <lambdabot> forall a. (Random a) => IO [a]
11:19:47 <davidL> ah right
11:19:50 <davidL> thanks
11:20:44 <ski> (if it wasn't clear, "and if it doesn't" referred to "If the library only does pure computation")
11:23:43 <lilac> ski: tying the library interface down to Handles seems inferior to the library exposing an ADT which happens to contain a Handle (unless using Handles is somehow a requirement of the library's purpose)
11:24:37 <lilac> ski: that is, unless your library's purpose is to mess with Handles, Handles should probably not cross between lib and app
11:25:17 <jeffersonheard> Has anyone written a Binary derivation for fingertrees containing Binary types?
11:25:33 <sw17ch> ski: i guess i'm thinking about something like this...
11:25:43 <jeffersonheard> Wondering about creating a B-Tree index using FingerTrees
11:25:52 <sw17ch> Both Int [Char] ByteString
11:25:53 <jeffersonheard> Or an R-Tree index
11:25:59 <sw17ch> where the ByteString is the backing type
11:26:06 <sw17ch> so, it looks more like this
11:26:19 * lilac wonders if his 'entanglement' example could be written without unsafePerformIO by filling a pipe and doing a lazy read on one end of it
11:26:20 <sw17ch> Both (ByteString -> Int) (ByteString -> [Char]) ByteString
11:26:54 <sw17ch> data Both a b c = Both (c -> a) (c -> b) c
11:27:03 <MyCatVerbs> lilac: no. Without IO being involved, all expressions are guaranteed to give exactly the same result every single time you evaluate them.
11:27:30 <lilac> MyCatVerbs: IO /is/ involved
11:27:39 <MyCatVerbs> lilac: you *need* unsafePerformIO if you want nondeterministic behavoir outside of the IO monad. And you probably don't, anyway.
11:27:51 <lilac> MyCatVerbs: have you seen the example?
11:28:07 <Deewiant> MyCatVerbs: or unsafeInterleaveIO
11:28:13 <davidL> dons: do you own a mac?
11:28:16 <MyCatVerbs> lilac: probably not, I look away from my IRC client once in a while. Which one?
11:28:30 <lilac> MyCatVerbs: the point is that lazy IO has the same property that an IO action is delayed until some pure code forces a result
11:28:39 <lilac> and i'm wondering if that can be exploited somehow
11:28:48 <lilac> MyCatVerbs: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2341#a2341
11:29:23 <MyCatVerbs> lilac: er, yess...
11:29:39 <MyCatVerbs> lilac: you asked if there was any way to do something like that without unsafePerformIO. I said "no".
11:29:45 <lilac> indeed
11:29:49 <lilac> and i think it can be done
11:30:04 <lilac> @hoogle pipe
11:30:04 <lambdabot> package Pipe
11:30:04 <lambdabot> package shell-pipe
11:30:12 <lilac> @hackage Pipe
11:30:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Pipe
11:30:37 <MyCatVerbs> Oh! Yeah, that's kind of trivial, in the IO monad. Only thing is you need the datatypes to be NFData instances, otherwise it won't do what you want.
11:31:13 <MyCatVerbs> Er, think, brain, think. No.
11:31:26 <MyCatVerbs> No, that's still impossible without unsafePerformIO.
11:31:35 <ski> lilac : what is the difference between "tying the library interface down to Handles" and "the library exposing an ADT which happens to contain a Handle", there ?
11:31:36 <MyCatVerbs> (Or unsafeInterleaveIO, pedants! ;D)
11:31:53 <ImInYourMonad> doesnt Maps has an invert function, ie turns keys int values?
11:32:09 <lilac> ski: the fact that the users of the library can use the Handles if you expose them, meaning your library implementation can't change away from Handles without potentially breaking your clients
11:32:09 <MyCatVerbs> lilac: the problem is that, by the time you've done (a,b) <- pair, a and b appear to be pure values.
11:32:17 <centrinia> Is it a good idea to convert lambda expressions to SK combinatory logic expressions and evaluate that?
11:32:23 <lilac> MyCatVerbs: indeed.
11:32:43 <MyCatVerbs> lilac: subsequent code can use them as if they were pure values. Now if Pair had the type (IO Bool,IO Bool) then I think you could.
11:32:49 <lilac> MyCatVerbs: in order to get this to work, you need forcing a pure value to have side effects
11:33:03 <lilac> MyCatVerbs: you can achieve that with unsafePerformIO. but you can also achieve that with lazy IO
11:33:21 * MyCatVerbs slaps lilac upside the head with a clue by four.
11:33:40 <lilac> MyCatVerbs: why so hostile?
11:33:57 <MyCatVerbs> Lazy IO is implemented in terms of unsafePerformIO, you, you, you silly bipedal carbon-based organism.
11:33:59 <crayer> hi :)
11:34:05 <lilac> MyCatVerbs: what's your point?
11:34:15 <sw17ch> @quote MyCatVerbs Lazy IO is implemented in terms of unsafePerformIO, you, you, you silly bipedal carbon-based organism.
11:34:15 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
11:34:19 <sw17ch> wait, shoot
11:34:21 <sw17ch>  how doeso ne do that
11:34:21 <MyCatVerbs> You still haven't eliminated unsafePerformIO from it.
11:34:51 <lilac> MyCatVerbs: no, of course not. the point is to show that lazy IO is broken
11:34:58 <MyCatVerbs> And you'll probably introduce a file descriptor leak in the process, trying to do it!
11:35:00 <jeffersonheard> I see I've introduced an interesting problem
11:35:07 <MyCatVerbs> lilac: oh. Why didn't you say?
11:35:08 <lilac> MyCatVerbs: it would be /surprising/ if lazy IO allowed you to write unsafePerformIO
11:35:18 <lilac> MyCatVerbs: you never asked
11:35:20 <Eridius> sw17ch: @remember, IIRC
11:35:25 <Eridius> or maybe @record
11:35:44 <MyCatVerbs> lilac: I really shouldn't have to. It wasn't obvious.
11:35:53 <sw17ch> @remember MyCatVerbs Lazy IO is implemented in terms of unsafePerformIO, you, you, you silly bipedal carbon-based organism.
11:35:53 <lambdabot> Okay.
11:36:02 <sw17ch> @quote carbon-based
11:36:02 <lambdabot> MyCatVerbs says: Lazy IO is implemented in terms of unsafePerformIO, you, you, you silly bipedal carbon-based organism.
11:36:17 <lilac> MyCatVerbs: I said, basically: I have this code which does something weird. It uses unsafePerformIO. I wonder if I can get the same effect by using lazyIO and not explicitly using unsafePerformIO
11:36:21 <crayer> i have to tell what the general types for (\x y -> fst x y) (\y -> y, (+)) are. now what does \x y -> fst x y mean? is it the same as \x . y -> fst x y  ? and how about (\x (y -> fst x y)) ?
11:36:25 <lilac> MyCatVerbs: was that not clear?
11:36:49 <byorgey> hi crayer
11:37:00 <crayer> hi :)
11:37:48 <lilac> MyCatVerbs: in any case, the goal of the exercise was irrelevant to determining whether the exercise was possible
11:38:11 <sw17ch> :t \x y -> fst x y
11:38:12 <lambdabot> forall t b t1. (t -> t1, b) -> t -> t1
11:40:52 <crayer> yeah I know the solution :) but it was rather intuitively "guessed", but i was asked for an explanation :)
11:41:21 <ski>   unsafeId a = unsafePerformIO (return a)
11:41:28 <MyCatVerbs> lilac: no, I'm afraid it wasn't at all. Sorry.
11:41:33 <crayer> unfortunately I can't really tell what the left part of    \x y -> fst x y  stands for :) (i mean i know what it does, but isn't it a shortcut for something longer?)
11:41:50 <Deewiant> crayer: \x -> (\y -> fst x y)
11:41:57 <crayer> thank you! :D
11:41:59 <jethr0> > fst ((+), undefined) 3 4
11:42:00 <lambdabot>   7
11:42:04 <MyCatVerbs> lilac: you said... blah, from which I thought you meant it'd be an improvement to use lazy IO instead of unsafePerformIO.
11:42:21 * MyCatVerbs waves an olive branch with a cookie on the end of it at lilac.
11:42:27 <ski> lilac : so how would a "library exposing an ADT which happens to contain a Handle" not tie the library to `Handle's ?
11:42:44 <ski> lilac : maybe you're talking about multiple interfaces ?
11:42:58 <lilac> ski: by ADT i mean abstract data type here. that is, you don't expose the data constructors
11:43:10 <metaperl_work> i would like to see the implementation of the haskell scan function...
11:43:15 <lilac> @src scan
11:43:15 <lambdabot> Source not found. Wrong!  You cheating scum!
11:43:33 <lilac> metaperl_work: you mean scanl / scanr?
11:43:36 <lilac> @src scanl
11:43:37 <lambdabot> scanl f q ls = q : case ls of
11:43:37 <lambdabot>     []   -> []
11:43:37 <lambdabot>     x:xs -> scanl f (f q x) xs
11:44:01 <lilac> MyCatVerbs: alas, our communication medium is inefficient and flawed :)
11:44:11 <metaperl_work> thank you lilac
11:44:23 <MyCatVerbs> lilac: yes, but, uh... your entire matrilineal ancestry! :D
11:44:30 <ski> lilac : oh .. by "exposing an ADT" i thought you meant the abstract data type had exposed operations (not necessarily the internal constructors), whose type signatures mentioned `Handle'
11:44:45 <lilac> MyCatVerbs: in any case, i would think that most people would not think of using 'hGetContents' as being 'using unsafePerformIO' :-)
11:45:07 <lilac> ski: it seems i'm communicating badly on all fronts today :-(
11:45:21 <MyCatVerbs> Metnal note, Haskell' needs to remove hGetContents from the spec. x_x
11:45:25 <Eridius> is there any Haskell equivalent to WWW::Mechanize?
11:45:40 <MyCatVerbs> lilac: nah, I'm tired as Heck an really not getting things today anyway.
11:46:30 <MyCatVerbs> Eridius: check hackage. I don't think so offhand, just HTTP libraries.
11:46:31 <ski> (lilac : i for one don't think that of `hGetContents' ..)
11:46:36 <ImInYourMonad> what do you think is the right thing to do if 1. you insert something before X in a priority queue and X doesnt exist. throw an error? 2. insert something into a priority queue with priority P and something else already has priority P? just put it in with P+1 or throw an error or dump the other item with priority P from the queue?
11:46:38 <Eridius> MyCatVerbs: yeah, I haven't been able to find one
11:46:56 <Eridius> MyCatVerbs: I have a ruby script that scrapes a site and I want to rewrite it in Haskell, but I think I'm going to have to stay with ruby because of Mechanize :/
11:47:16 <MyCatVerbs> Eridius: is it broken?
11:47:47 <Eridius> MyCatVerbs: no, but it's tied to a Rails app that was developed in a different environment and I want to avoid dealing with that if possible
11:47:52 <MyCatVerbs> Eridius: then don't fix it!
11:47:59 <Eridius> well the script itself needs changing
11:48:18 <Eridius> I need to re-scrape the site, because the guy who wrote this made a bad choice that threw out important data
11:48:44 <ski> (lilac : i'm not convinced of this : "you need forcing a pure value to have side effects","you can also achieve that with lazy IO")
11:48:51 <byorgey> ImInYourMonad: 1. yes.  2. it depends.  but generally speaking, priority queues can hold multiple items with the same priority.
11:49:01 <MyCatVerbs> ski: lilac isn't either.
11:49:47 <Eridius> @quote carbon-based
11:49:47 <lambdabot> MyCatVerbs says: Lazy IO is implemented in terms of unsafePerformIO, you, you, you silly bipedal carbon-based organism.
11:50:03 <Eridius> still as applicable today as when it was first said, over 13 minutes ago!
11:50:07 <dolio> Lazy IO isn't implemented in terms of unsafePerformIO.
11:50:08 <ski> afiacs, the "blame I/O" solution is enough to explain the apparent demonic nondeterminism of pure values extracted with `hGetContents'
11:50:12 <Eridius> ;)
11:50:16 * Eridius just finds that quote amusing
11:50:38 <ski> (if someone can invent a more accurate explanation model, all the better ..)
11:50:41 <MyCatVerbs> I am going to get in soooooo much troule for that if/when that gets repeated in front of one or more amputees.
11:50:42 <Eridius> although dolio, while I admit I don't know much about lazy IO, if it doesn't use unsafePerformIO what does it use?
11:50:52 <dolio> It uses unsafeInterleaveIO.
11:50:56 <MyCatVerbs> *trouble, I'm typing like an AOL user today. :(
11:51:12 <ski> (sorry, s/hGetContents/unsafeInterleaveIO/, i meant to say)
11:51:22 <MyCatVerbs> dolio: meh, no less troublesome, that.
11:51:42 <Eridius> dolio: oh of course, I'm forgetting that hGetContents is IO String and not just String ;)
11:51:42 <dolio> Technically you could probably define 'unsafeInterleaveIO m = return (unsafePerformIO m)', but that's not the actual definition.
11:51:51 <dolio> MyCatVerbs: It is less troublesome.
11:52:17 <jenner> could someone explain me the third monad law?
11:52:29 <goomba`> no monad can harm another human
11:52:34 <jenner> :)
11:52:39 <lament> @quote law
11:52:39 <lambdabot> lament says: three laws of robotics: 1) don't do anything unless you ABSOLUTELY HAVE TO 2) ...other laws to be written as they become required
11:53:38 <MyCatVerbs> jenner: it just says that it doesn't matter whether you bracket to the left or the right doesn't matter.
11:53:41 <dolio> Which is the third law?
11:53:59 <ski> jenner : do {(a,b) <- do {a <- m0; b <- m1 a; return (a,b)}; m2 a b}  =  do {a <- m0; b <- m1 a; m2 a b}
11:54:11 <Eridius> m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
11:54:12 <MyCatVerbs> (m >>= f) >>= g = m >>= (\x -> f x >>= g)
11:54:18 <ImInYourMonad> Eq a =>, what am i helping the typeinferencer to do when i add that?
11:54:27 <ski> jenner : do {b <- do {a <- m0; m1 a}; m2 b}  =  do {a <- m0; b <- m1 a; m2 b}  -- equivalently
11:54:44 <MyCatVerbs> ImInYourMonad: you're telling it that 'a' is required to be some type which (==) and (/=) are defined on.
11:54:49 <pumpkin> y'all know your monad laws too well
11:54:50 <Eridius> ImInYourMonad: you're putting a constraint on the type of a
11:54:59 <Eridius> pumpkin: pfft, I just hoogled for Monad and looked it up
11:55:06 <pumpkin> :)
11:55:32 <lilac> ski, MyCatVerbs: my idea was as follows: unsafeInterleaveIO' a = read . drop 4096 $ do { h1, h2 <- pipe; forkIO $ hPutStr h1 (repeat 4096 'x') >> a >>= hPutStr . show; hGetContents h2 }
11:55:35 <jenner> ski: uh, let me put that into my $EDITOR and do a layout
11:55:51 <lilac> ski, MyCatVerbs: (unsafeInterleaveIO' :: (Read a, Show a) => IO a -> IO a
11:56:36 <ski> lilac : s/$ do/`liftM` do/ ?
11:56:51 <lilac> the point being that the writing side is blocked until the read happens, allowing recovery of unsafeInterleaveIO semantics from lazy IO
11:56:54 <lilac> ski: yep, oops
11:57:22 <ImInYourMonad> if i have a function: next :: PriorityQueue a -> (a, PriorityQueue a) , how can i easily change sveral calls of it together?
11:57:43 <lilac> ImInYourMonad: looks like the State monad
11:57:46 <pumpkin> you can keep applying second on it
11:57:46 <pumpkin> :P
11:57:55 <lilac> @type State
11:57:56 <ski> (lilac : also, you wany s/hPutStr/hPutStr h1/)
11:57:56 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:58:01 <Eridius> pumpkin: (a, (a, (a, PriorityQueue a))) might be silly
11:58:09 <Eridius> ImInYourMonad: what's your goal? to throw away the intermediate a's?
11:58:09 <pumpkin> yeah, I was being silly too :P
11:58:19 <Eridius> you could apply snd to throw away the a and get the PriorityQueue a back
11:58:21 <MyCatVerbs> Or the Writer monad, happily enough.
11:58:21 <lilac> ski: sure. i also want a 'pipe :: IO (Handle, Handle)' to exist, and brackets around (h1, h2)
11:58:33 <Eridius> next . snd . next . snd . next
11:58:38 <ski> ImInYourMonad : `State' monad appears to be made just for you
11:58:44 <ImInYourMonad> change -> chain
11:59:02 <ImInYourMonad> Eridius: yes discard them
11:59:38 <jenner> ski: sorry, still don't get it :( I know that it basically means, that >>= is associative, but I don't really understand that... I'll go google a bit
11:59:38 <ski> ok, if you're just going to discard, then you can use
11:59:41 <ski> @type compose
11:59:42 <lambdabot> forall a. [a -> a] -> a -> a
11:59:50 <ski> compose = foldr (.) id
11:59:53 <lilac> @type let next :: [a] -> (a, [a]); next = undefined in do v1 <- State next; v2 <- State next; return $ v1 + v2
11:59:54 <lambdabot> forall a. (Num a) => State [a] a
12:00:03 <ski> (or, just a chain of `.', yes)
12:00:10 <seliopou> @type iterate
12:00:11 <lambdabot> forall a. (a -> a) -> a -> [a]
12:01:01 <lilac> > (let next :: [a] -> (a, [a]); next (x:xs) = (x,xs) in do v1 <- State next; v2 <- State next; return $ v1 + v2) `runState` [1,2,3,4,5]
12:01:02 <lambdabot>   (3,[3,4,5])
12:01:34 <lilac> jenner: it's easier to think about in terms of (>=>)
12:01:38 <mnislaih> Heffalump: there ? I have a question about the rmonad library
12:01:44 <dolio> > let next :: [a] -> Maybe (a, [a]) ; next (x:xs) = Just (x,xs) ; next [] = Nothing in unfoldr next [1..10]
12:01:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:02:11 <Heffalump> mnislaih: I am here, but I have to disappear v. shortly
12:02:20 <lilac> jenner: f >=> g = \x -> do { y <- f x; g y }
12:02:39 <lilac> jenner: the third monad law says (f >=> g) >=> h == f >=> (g >=> h)
12:02:53 <mnislaih> Heffalump: quick question, have you tried a MonadT version of the Set monad ? is there any reason the MonadTrans class is missing in the package?
12:02:55 <lilac> jenner: (>=>) is basically composition for functions of type a -> m b
12:02:56 <jenner> lilac: what does >=> mean?
12:03:06 <lilac> @type (>=>)
12:03:07 <ski> @type (>=>)
12:03:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:03:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:03:08 <mnislaih> Heffalump: my goal is to combine the Set monad with the IO monad
12:03:08 <Heffalump> stuff is mainly missing because I haven't written it yet
12:03:10 <ski> @type flip (.)
12:03:11 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
12:03:23 <dolio> The fish operator and join are clearly the best ways of presenting that law.
12:03:23 <Heffalump> but I think for MonadTrans etc, I will make separate packages
12:03:26 <mnislaih> Heffalump: then I'll probably write it and send you a patch
12:03:31 <Heffalump> to mirror the separate packages these can be found in
12:03:40 <ski> mnislaih : `MonadT' ?
12:03:42 <Heffalump> but I haven't thought it through in detail
12:03:52 <mnislaih> a Monad transformer version of the Set monad
12:04:01 <ski> @where MonadT
12:04:01 <lambdabot> I know nothing about monadt.
12:04:09 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2342#a2342 <- popSeveral. also, is it good to catch and rethrow with a different error message when using another datastructure behind the scenes?
12:04:10 <jenner> lilac: well, I mean basically the explanation is the same as if we'd be talking about (*) instead of >>=, what I don't get is, why it's special and what have monads to do with it :)
12:04:28 <mnislaih> Heffalump: I don't know if the embed/unembed trick will carry over, but at least it should be possible to define a custom MonadTrans class to work with restricted monads, right ?
12:04:28 <Heffalump> mnislaih: if I have time later I'll have a think
12:05:00 <lilac> jenner: metafoo.co.uk/practical-monads.txt
12:05:06 <jenner> thx
12:05:49 <lilac> jenner: it basically means that "do { a <- x; b <- f a; g b }" is unambiguous
12:06:18 <mnislaih> Heffalump: thanks. Is there an official darcs/git repo for the code ?
12:06:24 <ImInYourMonad> @src compose
12:06:24 <lambdabot> Source not found. Wrong!  You cheating scum!
12:06:34 <pumpkin> lol
12:06:40 <lilac> jenner: it could mean the same as either "do { b <- do { a <- x; f a }; g b }" or "do { a <- x; do { b <- f a; g b } }"
12:06:51 <lilac> jenner: the third monad law says that these two interpretations mean the same thing
12:06:56 <seliopou> ImInYourMonad, I'd write a function iterateN :: Int -> (a -> a) -> a -> that just composes the function passed in N times, and then just iterate (snd . next)
12:07:09 <seliopou> sorry, the type was Int -> (a -> a) -> a -> a
12:07:41 <pumpkin> what's wrong with just take n . iterate?
12:07:43 <lilac> jenner: that is, "doing A then (doing B then doing C)" is the same as "(doing A then doing B) then doing C"
12:08:00 <seliopou> pumpkin, that too
12:08:01 <jenner> lilac: ok, I think I got it now
12:08:08 <jenner> lilac: thanks :)
12:08:24 <dolio> Theoretically it gives you a means of optimizing your program.
12:08:44 <dolio> If one way of associating the operations is faster, then you can fiddle them around like that, and know the programs still do the same thing.
12:09:45 <Eridius> does anybody have any opinions regarding HDBC vs HSQL?
12:11:17 <ski> dolio : e.g., you need to use the associative law to show that using `ContT o m' (with polymorphic `o') gives the same result as just using `m'
12:12:04 <ski> @type times
12:12:05 <lambdabot> forall n a. (Integral n) => n -> (a -> a) -> a -> a
12:12:09 <ski> seliopou : ^
12:12:28 <ski> times n f = compose (genericReplicate n f)
12:13:06 <ski> also, there's an
12:13:11 <ski> @type timesM
12:13:13 <lambdabot> forall n a (m :: * -> *). (Monad m, Integral n) => n -> (a -> m a) -> a -> m a
12:13:15 <dolio> Yeah, I'm sure they make use of it in edwardk's go-to paper on the codensity (or whatever it's called) monad.
12:13:18 <ski> (i defined in lambdabot)
12:13:22 <ImInYourMonad> iterate + take doesnt seem very good, i think my explicit one is clearer and iterate + take invoels lsits
12:13:25 <Heffalump> mnislaih: code.haskell.org/rmonad
12:13:52 <cgizmo> hello everyone
12:13:54 <mnislaih> Heffalump: got it (but code.haskell.org seems to be down)
12:14:17 <cgizmo> i have a small question for you guys : do you knwo if a wiimote library exists for haskell ?
12:16:02 <ImInYourMonad> also, if a function will loop forever given a negative input, should one check if the input is negative and then throw an error? or thats doing to much ?
12:16:44 <pumpkin> can't hurt
12:17:04 <pumpkin> well I guess it can if you're sure it'll never go negative, and you don't want to waste time with an additional check
12:17:15 <pumpkin> but most of the time, it's worth the extra safety
12:17:26 <ski> ImInYourMonad : if the list fuses, it may not actually handle lists in the execution, even though it looks like that
12:17:29 <psygnisfive> anyone here students/professors/whatever at University of Maryland?
12:17:47 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2343#a2343 <- example
12:17:54 * pumpkin does the fusion dance
12:18:07 <psygnisfive> cause if so, we should totally hang out in the fall.
12:18:30 * ski wonders what "fission" would be, wrt to code optimization ..
12:18:48 <pumpkin> SPECIALIZE pragmas, maybe?
12:19:14 <pumpkin> it's a bit of a stretch :)
12:19:18 <ski> or maybe spotting patterns and inventing new temporary patterns for them, for some reason ..
12:19:28 <ski> maybe defunctionalization
12:19:39 <ski> s/patterns/data types/
12:19:50 <ski> (not sure how that happened ..)
12:20:57 <ImInYourMonad> what are pragmas in general and specialize in particular?
12:21:11 <pumpkin> they're notes to the compiler
12:21:52 <Philippa_> ski: I don't know that it'd be an optimisation, I effectively do it for purposes of explanation/understanding a lot though
12:21:53 <pumpkin> things like LANGUAGE allow you to specify what language extensions you're going to use in your source file
12:22:18 <Philippa_> it may sometimes open up optimisations, of course
12:22:40 <Philippa_> but the range of possible fissions is huge, because you don't know which intermediates to generate
12:22:43 <pumpkin> SPECIALIZE tells the compiler to produce a copy of the function in question for the specified type, to avoid using a dictionary
12:23:47 <ImInYourMonad> and is that commonly used? name some exmaples of things people use
12:24:00 <pumpkin> INLINE is more common
12:24:28 <pumpkin> OPTIONS and OPTIONS_GHC are pretty common
12:25:24 <jenner> @source (!!)
12:25:24 <lambdabot> (!!) not available
12:26:33 <rio> @source id
12:26:33 <lambdabot> id not available
12:27:02 <lilac> ski: fission is presumably adding in unnecessary temporary data structures
12:27:50 <vininim> ,source (!!)
12:27:52 <lunabot>  luna: Not in scope: `source'
12:28:25 <lilac> ski: {-# RULES "read/show fission" (.) = \f g -> f . read . show . g #-}
12:30:10 <Eridius> hrm, you can't ask darcs to query a remote repo for changes?
12:30:59 <Baughn> byorgey: You wrote the typeclassopedia, right?
12:31:07 <byorgey> Eridius: just do a 'darcs pull' and look through the changes that come up.  you don't have to apply them.
12:31:10 <byorgey> Baughn: yep
12:31:21 <Baughn> byorgey: Thank you. It really ought to be more widely publicized. :)
12:31:38 <paper_cc> , src (!!)
12:31:40 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
12:31:46 <paper_cc> , src '(!!)
12:31:48 <Eridius> byorgey: I don't have a local repo
12:31:50 <lunabot>  (!!) :: forall a . [a] -> Int -> a
12:32:00 <paper_cc> vininim: ^^
12:32:00 <byorgey> Baughn: thanks. =)  I'm waiting for the revised version to be published in the Monad.Reader.
12:32:01 <Eridius> oh hey, I need to keep reading the typeclassopedia. Thanks for the reminder!
12:32:18 <byorgey> Eridius: ok, then I don't understand what you mean by 'query a remote repo for changes'.
12:32:38 <Eridius> byorgey: for a list of patches in the repo
12:32:48 <Eridius> more specifically, I want to ask --last=1 and look at the date
12:32:50 <BMeph> Specialize is usually seen when your function uses Integral types - that way, the Int version is really fast.
12:32:57 <vininim> paper_cc: thanks :)
12:33:31 <paper_cc> ahem, that "source code" was a bit unhelpful :(
12:33:46 <vininim> (for the lunabot sintax)
12:33:57 <vininim> well, that is more like some introspection library
12:34:00 <byorgey> Eridius: ah, I see.  I don't know a way to do that.
12:34:01 <BMeph> Eridius: Have you checked out (no pun intended) patch-tag?
12:34:12 <vininim> , src 'fmap
12:34:14 <lunabot>  Class op from Functor: fmap :: forall f . Functor f => forall a b . (a ->
12:34:14 <lunabot>                                                                       b) ->
12:34:14 <lunabot>                                                                      f a -...
12:34:17 <Eridius> BMeph: I don't use darcs myself.
12:34:36 <vininim> owat
12:34:59 <jeffersonheard> @Hoogle Int -> UTCTime
12:34:59 <lambdabot> Maybe you meant: google hoogle
12:35:10 <jeffersonheard> @hoogle Int -> UTCTime
12:35:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:35:10 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:35:10 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
12:35:19 <BMeph> Eridius: git? :)
12:35:23 <jeffersonheard> that was unhelpful
12:35:28 <Eridius> BMeph: yeah, that's my current VCS of choice
12:35:41 <jeffersonheard> Posix timestamp to UTC Time...
12:35:51 <jeffersonheard> ah
12:35:52 <jeffersonheard> found it
12:36:18 <rio> Eridius: seen torvalds speech on git at google?
12:36:40 <Eridius> rio: I think I watched a tiny bit of that, but really, nobody should ever watch that. Torvalds is a complete jackass
12:36:51 <Eridius> Randal Schwartz's talk is much better
12:39:31 <rio> Eridius: his speeches are funny :D
12:39:54 <Eridius> rio: perhaps, but in that case you should watch the video as a comedy, not as promotional material for git
12:40:15 <jeffersonheard> many of the open source luminaries are complete jackasses
12:40:18 <bremner> s/git/a git/ ?
12:40:39 <rio> bremner: hm?
12:40:59 <bremner> promotion for a git
12:41:00 <Eridius> bremner: yes, that is the common explanation for the name. I think Torvalds himself gave that one
12:42:35 * bremner has no real opionions on Torvalds. Don't get me started on GNU/whatever
12:43:18 <bremner> i.e. /me finds the naming discussion embarrasing, not the software :-)
12:44:16 <Baughn> One question. Does it make sense to put any haskell (well, ghc, more like) library under the LGPL?
12:44:18 <b\6> do i have to do something strange to get -ddump-splices to actually show something?
12:44:25 <Baughn> What with the lack of dynamic linking
12:44:54 <bremner> Baughn: but there _could_ be dynamic linking in the future, no?
12:45:22 <Baughn> bremner: And until there is, you wouldn't legally be able to use it for much of anything
12:45:53 <Baughn> I never quite saw what the technology used for linking had to do with anything, anyhow
12:46:26 <lilac> Baughn: it's about being able to replace the LGPL library being used by proprietary code
12:47:11 <lilac> or modify it or whatever
12:47:18 <djahandarie> Has anyone looked into doing an implementation of the TrueSkill algorithm in Haskell?
12:47:21 <monochrom> Analogy. There was a time the technology used for taking your passport photo was important.
12:47:36 <pejo> Baughn, static linking doesn't violate the LGPL, does it? You just need to distribute the object files as well so the user can re-link it?
12:48:22 <Baughn> pejo: Sadly, no. See section 4d - http://www.gnu.org/licenses/lgpl.html
12:48:54 <Baughn> pejo: Well. Maybe. I'd have to ask a lawyer, which I'd rather not do.
12:49:00 <Baughn> ..guess it's BSD this time
12:49:03 <lilac> Baughn: 4d0 specifically allows it
12:49:50 <Baughn> lilac: But what does such source look like for a haskell program using the library?
12:50:04 <Baughn> Due to inlining, etc., it seems to me that you'd have to provide the /entire/ source
12:50:42 <lilac> Baughn: yeah, inlining is a problem. but you can turn that off (right?)
12:51:42 <Baughn> lilac: Which of course would ruin performance. Yay.
12:52:04 <lilac> ruin? seems a bit strong.
12:52:08 <Baughn> I suppose it's worth looking into, at least
12:52:36 <Baughn> lilac: Well, one of the functions in this library has the inner-loop nature. ;)
12:52:51 <lilac> oh. that's not good :(
12:52:53 <paper_cc> Inlining and constant folding/unrolling... isn't it the second important optimization for functional programs after tail-call?
12:52:59 <pejo> Baughn, you need to provide the .hi-files to have a usable library, and those contain the information for the inliner.
12:53:19 <Baughn> To be clear.
12:53:29 <Baughn> The /library/ is open-source, either lgpl or bsd
12:53:57 <CalJohn_> 1
12:54:18 <Baughn> But applications linking against it, if it were lgpl, would need to provide pretty much their entire source to be able to relink against a newer version of the library; I'm not aware of any way to compile a haskell file without having the .hi files for the modules it uses available at compilation time
12:54:58 <paper_cc> so why not bsd or boost?
12:55:27 <pejo> Baughn, so you're saying that the applications would be considered derived works, and therefore fall under the same license?
12:55:55 <Heffalump> Baughn: .hi files at -O0 probably don't contain that much of the code
12:55:59 <Baughn> pejo: I'm saying the applications would be forced to supply full source, somewhat destroying the point of using lgpl in the first place
12:56:25 <lilac> supplying full source isn't the same as supplying permission to make derived works of the full source
12:56:46 <Baughn> Heffalump: I'm not worried about that. The problem is that, if you change the library code, the .hi files might change and so .o files of a library-using app produced earlier would no longer be functional
12:56:47 <lilac> (however, i agree that it's far from ideal)
12:57:10 <Heffalump> Baughn: oh, yeah. I had the requirements backwards.
12:57:29 <Baughn> Amusingly, I'd personally prefer to make the library AGPL and be done with it, but that wouldn't be allowed by the policies of my university
12:57:59 <Baughn> So it's bsd or lgpl.. I have /issues/ with bsd, but lgpl apparently can't work
12:58:05 <Heffalump> actually, I'd still hope for stable .hi files at -O0
12:58:22 <Baughn> And then there's the inner-loop thing. :P
12:58:24 <pejo> Baughn, your scenario isn't a problem with bsd though.
12:58:32 <Heffalump> also, if you're the one doing the licensing, you don't need to enforce it
12:58:40 <Baughn> THough I suppose there's really no solution for that one. Haskell just /allows/ there to be one, when legalities don't get in the way
12:58:56 <Baughn> pejo: I know.
12:58:56 <lilac> Baughn: can you wrap your inner-loop thing in such a way that it's not inefficient in common cases?
12:59:03 <lilac> that is, move the loop into the librar
12:59:30 <monochrom> ghc -XStrictGPLCompliant
12:59:33 <Baughn> lilac: Eh, possibly. I suppose I could provide a specialized version of fmap, and hope that's what they want.
13:00:05 <Baughn> pejo: No, the only problem with BSD is my dislike of BSD
13:01:19 <jeffersonheard> so here's something I've never tried... can I pass a constructor as a parameter to a function?
13:01:26 <jeffersonheard> Just the bare constructor
13:01:38 <monochrom> Yes.
13:01:40 <Baughn> Sure, it's just another function
13:01:42 <MyCatVerbs> Yes. Constructors are functions too.
13:01:47 <jeffersonheard> That's what I thought.
13:01:52 <Baughn> You can't pattern-match on it, though
13:01:52 <jeffersonheard> Intuitively it made sense
13:01:55 <monochrom> map Just [1]
13:02:01 <MyCatVerbs> e.g. (:), the list constructor, has type (a -> [a] -> [a]).
13:02:18 <jeffersonheard> Baughn: I knew that, which is why I wasn't sure
13:03:33 <jeffersonheard> actually, I guess I have done that before
13:03:37 <jeffersonheard> using Just
13:03:42 <skorpan> @pl \x y -> operator x <|> y
13:03:42 <lambdabot> (<|>) . operator
13:03:57 <Baughn> @type operator
13:03:58 <lambdabot> Not in scope: `operator'
13:04:22 <skorpan> Baughn: my own function
13:06:02 <ray> @pl \steak cheese -> get steak and cheese
13:06:02 <lambdabot> flip get and
13:06:50 <Baughn> @pl \a b c d e -> b c h e l a a d (e,a) <$> a
13:06:52 <lambdabot> flip =<< ((flip . ((flip . ((flip . ((<$>) .)) .)) .)) .) . ap (flip . ((flip . ((flip . (ap .) . flip) .)) .) . (flip =<< ((flip . (flip .)) .) . flip (flip . (flip .) . flip flip l . (flip .) .
13:06:52 <lambdabot> flip flip h))) (flip (,))
13:07:59 <osfameron> ouch
13:08:13 <osfameron> do you do these as little logic puzzles?
13:08:24 <augustss> @pl \ a -> b b b b b b b a b b b b b b
13:08:24 <lambdabot> flip (flip (flip (flip (flip (flip (b b b b b b b) b) b) b) b) b) b
13:08:45 <Baughn> osfameron: Actually, no, just to confuse people
13:08:50 <osfameron> :-)
13:08:59 <Baughn> @pl \a -> a a
13:08:59 <lambdabot> join id
13:09:06 <augustss> @pl \ a -> a b a b a b a b a b a b a
13:09:06 <lambdabot> join (flip (join (flip (join (flip (join (flip (join (flip (join ($ b)) b)) b)) b)) b)) b)
13:09:11 <Baughn> Now that one looks simple, doesn't it? ;)
13:09:36 <Baughn> @pl \a b c d e f g (h,i,j,k,l) m n o p q r s t u v w x y z -> h e l l o (,) w o r l d (.)
13:09:36 <lambdabot> (line 1, column 20):
13:09:36 <lambdabot> unexpected ","
13:09:36 <lambdabot> expecting letter or digit, operator or ")"
13:09:36 <lambdabot> ambiguous use of a non associative operator
13:09:52 <ray> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> m e r r y x m a s
13:09:52 <augustss> \ join -> join join
13:09:55 <Baughn> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> h e l l o (,) w o r l d (.)
13:09:55 <lambdabot> const . const . const . ((const . const . const . const) .) . (const .) . (const .) . (const .) . ((const .) .) . ((const .) .) . ((const .) .) . ((const .) .) . ((((const .) .) .) .) . ((((const .)
13:09:55 <lambdabot> .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . ((((((const .) .) .) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . join . (
13:09:55 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip flip id . (ap .) . flip id)
13:09:55 <lambdabot> optimization suspended, use @pl-resume to continue.
13:09:58 <lambdabot> const (const (const ((const .) . (const .) . ((const .) .) . ((const .) .) . ((const .) .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . ((((const .) .) .) .) . (((((const .) .) .
13:09:59 <lambdabot> ) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . ((((((const .) .) .) .) .) .) . flip
13:10:02 <lambdabot> flip (.) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip flip
13:10:04 <Eridius> wow
13:10:05 <lambdabot> id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . flip flip (,) . (flip .) . ((flip .) .) . flip
13:10:08 <lambdabot> flip id . (ap .) . flip id))))
13:10:10 <lambdabot> optimization suspended, use @pl-resume to continue.
13:10:13 <augustss> @pl \ join -> join join
13:10:13 <lambdabot> join id
13:10:17 <Baughn> ..okay, enough of that. ^^;
13:10:22 <ray> @pl-dont-resume
13:10:22 <lambdabot> Unknown command, try @list
13:10:29 <icee> @pl-resume
13:10:29 <lambdabot> pointless: sorry, nothing to resume.
13:10:44 <icee> :<
13:11:05 <b\6> seems like there should be a 'flop'. dunno what it would do, though.
13:11:26 <augustss> flop should be .
13:12:19 <osfameron> so the boobies operator would become:  flop `flop` flop
13:12:19 <b\6> just like if you define blip, you have to define bloop.
13:12:24 <osfameron> which is much more readable
13:13:15 <augustss> and then ap could be flap
13:13:46 <augustss> @pl f g x -> (f x) (g x)
13:13:47 <lambdabot> (line 1, column 7):
13:13:47 <lambdabot> unexpected ">" or "-"
13:13:47 <lambdabot> expecting variable, "(", operator or end of input
13:14:03 <augustss> @pl \ f g x -> (f x) (g x)
13:14:03 <lambdabot> ap
13:14:46 <augustss> @pl \ c f g x -> c (f x) (g x)
13:14:46 <lambdabot> liftM2
13:20:50 <jethr0> @type<*>
13:20:50 <lambdabot> Unknown command, try @list
13:20:57 <jethr0> @type <*>
13:20:58 <lambdabot> parse error on input `<*>'
13:21:18 <Eridius> @type (<*>)
13:21:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:21:38 <Eridius> hrm, I can't figure out what build actually does. Can anybody enlighten me?
13:21:50 <pumpkin> in the fusion sense?
13:22:14 <Eridius> I'm not particularly familiar with fusion, but reading the type signature of build I can't see what it does
13:22:28 <stepcut> Eridius: is this related to varags?
13:22:32 <Eridius> I can see that it gets simplified when used with foldr, but how do you even call it?
13:22:47 <Eridius> stepcut: err no, I was just doing some light reading of the haskell user's guide and came to the rewrite rules section
13:23:42 <stepcut> Eridius: ah
13:24:48 <seliopou> Eridius, I don't think build is exported
13:24:57 <Eridius> GHC.Exts
13:25:01 <Eridius> @type GHC.Exts.build
13:25:02 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
13:25:12 <Eridius> I mean, just looking at that type signature gives me a headache
13:25:19 <seliopou> Ah, I meant from Data.List
13:25:46 <romand> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1857
13:25:57 <romand> what is wrong and how to do it right?
13:26:55 <jeyxz> HOLA ,  BUSCO  CHICAS PARA  CYBER SEX ..  fusionxx@hotmail.com
13:27:00 <jeyxz> HOLA ,  BUSCO  CHICAS PARA  CYBER SEX ..  fusionxx@hotmail.comHOLA ,  BUSCO  CHICAS PARA  CYBER SEX ..  fusionxx@hotmail.comHOLA ,  BUSCO  CHICAS PARA  CYBER SEX ..  fusionxx@hotmail.comHOLA ,  BUSCO  CHICAS PARA  CYBER SEX ..  fusionxx@hotmail.com
13:27:07 <Eridius> yay spam
13:27:11 <jmcarthur> @op
13:27:11 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc v wn yow
13:27:14 <jmcarthur> ?
13:27:16 <jmcarthur> i don't know it
13:27:37 <blackh> romand: Take the 'in' out.  In a do block, 'let' doesn't have an 'in'
13:27:41 <roconnor> @where ops
13:27:41 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
13:28:11 <romand> blackh: thanks!
13:28:37 --- mode: ChanServ set +o Heffalump
13:28:46 <skorpan> @pl\x -> not $ elem x "})]"
13:28:46 <lambdabot> (line 1, column 1):
13:28:46 <lambdabot> unexpected "-"
13:28:46 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:28:53 <skorpan> @pl \x -> not $ elem x "})]"
13:28:53 <lambdabot> not . flip elem "})]"
13:29:08 <skorpan> is that the same as `notElem` "})]"?
13:29:30 <skorpan> i think it is..
13:30:34 <Gracenotes> @type notElem
13:30:36 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:30:43 <Gracenotes> o rly :O
13:30:48 <tomh> is there any point in using a state monad when you already use MVar?
13:30:50 <Gracenotes> @index notElem
13:30:50 <lambdabot> Data.List, Prelude
13:31:29 <kiris> > unfoldr (fmap (second $ dropWhile (==',')) . listToMaybe . reads) "\"hello\",\"wor\nld\"" :: [String]
13:31:30 <lambdabot>   ["hello","wor\nld"]
13:31:34 <lilac> @type GHC.Exts.build
13:31:35 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
13:31:45 <Gracenotes> tomh: well, not *the* State monad.
13:31:56 <kiris> csv reader ftw?
13:32:00 <Gracenotes> but you can do something with MonadState
13:32:21 <Gracenotes> tomh: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1858#a1858
13:32:59 <Gracenotes> so you can get and put if you need to. And access the MVar normally with ask
13:33:10 <lilac> Eridius: so, you give build a function and a type 'a'. it picks a type 'b' and gives your function a function of type a -> b -> b, and a value of type b. you're expected to return a value of type b.
13:33:47 <lilac> Eridius: so your function has to construct a value of type b. it can do this either by using the value of type b it was given, or by calling the function it was given (which in turn requires a value of type b, and also a value of type a)
13:34:03 <Eridius> hmm
13:34:12 <Gracenotes> tomh: the only problem being that MonadState's modify already has an implementation, so calling it might introduce a race condition.
13:34:31 <tomh> mm ok
13:34:32 <lilac> Eridius: imagine instead it looked like this: forall a. ((a -> [a] -> [a]) -> [a] -> [a]) -> [a]
13:34:35 <Gracenotes> you can just define your own modify, though, that interfaces MVar's
13:34:48 <Eridius> lilac: yeah, I'm staring at the g (:) [] definition
13:34:58 <lilac> Eridius: so it gives you a 'cons' function and an 'empty list' value
13:35:26 <lilac> Eridius: except that instead of being 'cons' and 'empty list' for type [a], it's for type 'b' (which build gets to choose for itself)
13:35:40 <Eridius> yeah, what's been confusing me is the generic "b" and how that relates to the eventual [a] result value
13:36:22 <Eridius> but I guess it's defined that way because, while if you use the result of build directly, b really is [a], but when it's used in fusion that may no longer be true
13:37:14 <lilac> Eridius: if 'build' is ever run, 'b' really is '[a]'
13:37:19 <Eridius> yeah
13:37:25 <lilac> Eridius: using 'b' instead means two things:
13:37:44 <Eridius> it forces the argument function to be more generic, right?
13:37:59 <lilac> 1) it means that your function builds a list in a well-behaved manner (it can't be, for instance, \f as -> reverse as)
13:38:02 <Eridius> as it can no longer make any assumptions about what it's handed (besides the original type a, which it defines)
13:38:06 <lilac> exactly
13:38:24 <Eridius> ok, this clears things up, thanks
13:38:25 <hallongrottan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2344#a2344 how can i solve that?
13:38:36 <Eridius> hallongrottan: pass -hide-package monads-fd
13:38:57 <hallongrottan> do i need both packages?
13:39:08 <Eridius> hallongrottan: no, monads-fd redefines much of mtl
13:39:12 <lilac> 2) if fusion happens, 'b' might not be '[a]'
13:39:32 <hallongrottan> Eridius: so i could basically delete monads-fd?
13:39:37 <Eridius> hallongrottan: you're supposed to use one or the other, not both. I don't offhand know the purpose for monads-fd
13:39:46 <hallongrottan> hmmm
13:39:51 <Eridius> hallongrottan: well, it's probably there because it's a dependency for something else (for example it's an indirect example of yi)
13:39:56 <Eridius> you could try hiding it with ghc-pkg, I don't know if that will affect anything
13:40:05 <hallongrottan> ok
13:40:43 <hallongrottan> Eridius: can deletion be made using cabal?
13:41:09 <Eridius> hallongrottan: you can unregister, but if anything depends on it that will cause problems
13:41:21 <hallongrottan> :x
13:42:14 <Eridius> haha, `mueval -h` prints out the help message twice
13:42:20 <skorpan`> hallongrottan: the standard procedure for me is ghc-pkg unregister and then remove it in .cabal
13:42:35 <hallongrottan> I see, thanks skorpan` and Eridius
13:42:56 <Eridius> skorpan`: yi depends (indirectly) on monads-fd, so if you want to use yi you have to haev it
13:42:57 <Eridius> *hvae
13:42:58 <Eridius> *have
13:44:14 <drdozer1> evening all
13:58:04 <tomh> in ghci, how do you kill all threads?
13:58:53 <bastl> why is my "darcs get --partial http://code.haskell.org/bnfc" so terribly slow ?
13:59:34 <Eridius> code.haskell.org is working? Earlier today it was totally unresponsive
13:59:52 <byorgey> bastl: code.haskell.org seems to be down, or at least under very heavy load
14:00:11 <travisbrady> can anyone lend a hand with a failed cabal install yi? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1859#a1859
14:01:02 <bastl> travis: version of ghc ?
14:01:11 <bastl> is it compatible?
14:01:19 <travisbrady> bastl: version 6.10.1
14:01:27 <Eridius> travisbrady: that's actually a failed cabal install of array
14:01:55 <Eridius> travisbrady: yi-0.5.0.1? Run `cabal update`
14:01:56 <travisbrady> Eridius: i saw that, but i'm not sure how to fix it
14:02:06 <Eridius> your cabal package list is pretty out of date
14:02:37 <byorgey> yeah, array-0.1.0.0 is kind of old
14:03:46 <byorgey> yi 0.5.0.1 is kind of old too, actually
14:03:55 <Eridius> yeah
14:04:16 <byorgey> a 'cabal update' is definitely called for =)
14:06:14 * byorgey tries installing yi again
14:06:15 <travisbrady> ok, i did that and it was downloading and installing loads of stuff but then failed with "cabal: alex version >=2.0.1 && <3 is required but it could not be found."
14:06:42 <Badger> <3
14:06:56 <travisbrady> btw, would you say 'Yee' or "why-eye"?
14:07:11 <byorgey> travisbrady: well... do you have alex installed?  what happens when you type 'alex --version'?
14:07:13 <mle> Yeeeeeeee!
14:07:13 <Badger> yee!
14:07:34 <Eridius> travisbrady: alex is a build tool. cabal doesn't handle dependencies for those yet
14:07:38 <travisbrady> i don't have alex
14:07:40 <Eridius> as the Yi page on the haskellwiki says: Currently, Cabal doesn't track programs, just libraries, so it won't warn you if you are missing Alex (as many people are). The solution here is to just cabal install alex first. (Yi uses Alex to generate code for parsing stuff with syntax, like Haskell source.)
14:07:54 <travisbrady> Eridius: thank you
14:07:55 <byorgey> travisbrady: just 'cabal install alex' ought to do it
14:13:00 <Heffalump> byorgey: withSize in diagrams has a performance problem, because if you use a diagram twice, once as the size reference and once inside the returned diagram from the function, its size gets evaluated twice. Nest things, and this blows up exponentially.
14:13:42 <Heffalump> I fixed it by adding a cacheSize combinator to introduce a Sized constructor with the first result of sizeAndPos, but it feels a bit hacky
14:17:07 <byorgey> Heffalump: ah, that sucks, thanks for the report =)
14:17:48 <Eridius> does anybody have any experience with using HDBC vs HSQL?
14:17:59 <byorgey> Heffalump: actually, I think I may end up needing to rework things to add size caching anyway, to support labels
14:19:31 <byorgey> Heffalump: could you send me an example program that exhibits the exponential blowup? that would be helpful
14:20:00 <Heffalump> well, the program I'm working on relies on a recent GHC HEAD
14:20:15 <byorgey> ok, don't worry about it then
14:20:26 <travisbrady> dang, it appears to have nearly finished but then failed with: "yi-0.6.0 failed during the building phase. The exception was: exit: ExitFailure 9"
14:20:35 <Eridius> travisbrady: it doesn't say anything at all besides that?
14:21:35 <Heffalump> it probably won't be hard to make a simple test case. I made a grid combinator that I should send you for inclusion, too (and it's when nesting lots of grids that I get trouble, because it uses withSize)
14:21:39 <travisbrady> Eridius: here are the last few bits: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1860#a1860
14:22:03 <Eridius> travisbrady: huh
14:22:35 <travisbrady> not a terribly helpful error, is there a log somewhere?
14:22:36 <Eridius> travisbrady: maybe try installing again but verbosely?
14:22:43 <Eridius> cabal instal --verbose=3 yi
14:22:52 <dons> bos, note that hexpat now builds on top of text
14:23:51 <byorgey> Heffalump: excellent, a grid combinator is something I've wanted to add
14:23:58 * BMeph thinks that an IDE based off of Yi should be made, called ... Yi-HAW!
14:24:21 <Heffalump> it's quite easy if you use ContT
14:25:23 * byorgey boggles
14:25:34 <Heffalump> sorry, not ContT, just Cont.
14:26:10 * byorgey decides to take Heffalump's word for it
14:26:22 <Heffalump> well, otherwise it's really fiddly to collect up all the sizes of the grid elements
14:26:37 * Heffalump goes to make a patch :-)
14:28:44 <travisbrady> Eridius: installing with verbose=3 has worked, it installed correctly, very confusing
14:28:50 <travisbrady> Eridius: thanks for your help
14:29:14 <Eridius> travisbrady: well that's bizarre
14:30:23 <travisbrady> wow and it really does act like vim, i just need to figure out how to configure its use of tabs properly
14:31:46 <Eridius> vim? bah, I use the Emacs keymap ;)
14:32:57 * byorgey has now installed yi too, thanks to travisbrady's prompting!
14:33:12 * Eridius has been having fun submitting patches for the Emacs keymap
14:33:15 <skorpan`> i'm surprised you guys find yi usable at all
14:33:25 <Eridius> skorpan`: the vty interface is reasonably usable
14:33:27 * Elly uses vim
14:33:37 <Eridius> Elly: yeah I get the feeling most yi hackers use the vim keymap
14:33:43 <malsyned> Does anybody know where I can find a PDF of "how to replace failure by a list of successes" ?
14:33:46 <Elly> I mean I use vim, not yi :P
14:33:48 <skorpan`> Eridius: it's not that, it's just that it doesn't have very many commands...
14:33:59 <Eridius> skorpan`: submit patches! ;)
14:34:02 <Eridius> Elly: bah
14:34:15 <skorpan`> Eridius: i'm currently writing a javascript mode for it as my master thesis
14:34:15 <Elly> I can try installing yi I guess
14:34:22 <Eridius> skorpan`: neat
14:34:42 <Eridius> I have noticed that there are a bunch of actions (most notably the ones from Yi.Keymap.Emacs.Utils) that aren't exposed via M-x
14:34:55 * Elly installs yi maybe...
14:35:17 <sjanssen> will yi require gobs of RAM to compile and link?
14:35:28 <Eridius> I still haven't seen the so-called "tabs" that yi apparently has, but I'm wondering if they're only available to GUI's (as I use vty)
14:35:50 <Eridius> sjanssen: it compiles reasonably fast on my quad-core Mac Pro
14:36:07 <Ornedan> How does one generate unified documentation from multiple cabal packages? As in like the one at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:36:15 <ImInYourMonad> isnt there a Yi exe for windows?
14:36:33 <travisbrady> Eridius: i'm using them just fine, just do :tabe in vim mode, not sure of the emacs equiv
14:36:38 <pejo> Eridius, that machine is sureloy representative. :-)
14:36:56 <Eridius> travisbrady: yeah, I'm also wondering if it's only available to Vim
14:37:04 <AllNight^afk> malsyned - the mortage loan risk assesment at most major banks? :)
14:37:10 <Eridius> pejo: what, you don't all have 4-core 2.8GHz machines?
14:37:28 <Elly> malsyned: can you reformulate your question?
14:37:45 <malsyned> Elly, AllNight: I'm talking about the paper by Phillip Wadler.
14:38:27 <malsyned> I google but all I find are citations.  I was just wondering if that paper was available online somewhere that people knew of.
14:38:58 <byorgey> malsyned: it appears to be available on Google books.
14:39:08 <byorgey> malsyned: I just did a search for it in Google Scholar and it came up.
14:40:18 <malsyned> byorgey: I'd never heard of Google Scholar.  Thanks!
14:42:32 <travisbrady> anyone know how to configure Yi to use spaces instead of tabs? (and make them be 4 spaces wide)?  the yi examples page won't load for me
14:43:11 <Eridius> travisbrady: unfortunately I think you have to define your own mode to override the space settings for a given mode
14:43:18 <Eridius> I could be missing something though, I haven't looked myself
14:43:27 <Eridius> travisbrady: anyway, any more questions should be taken to #yi
14:43:29 <ehird> newsham: I modified my sierpinski program to output a PNG :-)
14:43:39 <travisbrady> Eridius: oh thanks, didn't know that existed
14:43:53 <ehird> newsham: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2345
14:44:36 <newsham> boo.  ascii uber alles
14:44:56 <ehird> newsham: yeah, but the centered ascii had problems
14:45:14 <ehird> in that it was uneven like so:
14:45:15 <ehird> *
14:45:17 <ehird> **
14:45:49 <newsham> map True to "**" and False to "  "
14:45:59 <ehird> hmm
14:46:01 <ehird> that could work
14:46:02 <chessguy> is there a nice package for PNG?
14:46:04 <ehird> it'd be stretched, though
14:46:10 <ehird> goatsierpinski
14:46:12 <Heffalump> byorgey: sent
14:47:32 <ehird> @hoogle Int->CInt
14:47:32 <lambdabot> Prelude toEnum :: Enum a => Int -> a
14:47:32 <lambdabot> Data.Bits bit :: Bits a => Int -> a
14:47:32 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
14:47:45 <pumpkin_> fromIntegral should do it shouldn't it?
14:48:44 <newsham> http://codepad.org/RGd0d7oH
14:48:51 <newsham> looks good to me
14:49:55 <ehird> newsham: hmm, true
14:50:14 <ehird> I might put that in my version
14:54:26 <Eridius> hrm, why does `cabal info` show all the dependency lists unioned, instead of doing like hackage and showing that there's multiple choices?
14:54:39 <Eridius> it's rather weird to see a package claim to require base<3 and base>=3
14:55:43 <ImInYourMonad> yi not on windows? depends on unix failed to isntall
14:57:06 <Ornedan> How does one generate unified documentation from multiple hackage packages? As in like the one at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:59:04 <crayer> hm how can I find out what the most general type for Ord a => a -> b -> a -> b is? (please try not to give the final answer) all i know so far is: 1. a must be comparable, so there's probably <,>,<=,>= involved and 2. Ord a => a -> b -> a -> b == Ord a => a -> (b -> (a -> b))
15:00:00 <ddarius> crayer: That question doesn't make sense.  You can't find a most general type of a type.
15:01:03 <crayer> ddarius: sorry, wrong question :) i meant: how can I find a function that has that as its most general type
15:01:32 <mauke> that doesn't look like a useful function
15:01:33 <ddarius> crayer: You use djinn and call it a day.
15:02:07 <ehird> What's the cabal install package on Ubuntu? Asking for a friend.
15:02:08 <crayer> mauke, it's a Funcitonal Programming course, so don't expect too much :)
15:02:22 <crayer> \functional
15:02:30 <mauke> I can't think of a useful definition
15:02:34 <ddarius> There is, incidentally, only one (total) function that fits that type.
15:03:33 <pumpkin_> I can only think of a lame one :P
15:03:34 <ddarius> crayer: Anyway, just write, f :: Ord a => a -> b -> a -> b; f = <fill in the blank> and use logic, intuition and experimentation to find out the answer.
15:04:16 <ddarius> (Technically, all you need is logic which is why djinn exists.)
15:04:17 <pumpkin_> in fact, I'm pretty sure my lame one is the only one that's possible
15:04:20 <pumpkin_> yeah
15:06:18 <crayer> interesting :)
15:06:25 <pumpkin_> crayer: did you figure it out?
15:06:30 <crayer> not yet no
15:06:40 <mauke> :t flip liftM return . flip fmap . (>)
15:06:41 <lambdabot> forall b a. (Ord a) => a -> b -> a -> b
15:06:42 <pumpkin_> you can try to step through some more reasoning with us, like what you said earlier
15:06:51 <crayer> this is mean
15:06:52 <pumpkin_> lol
15:07:00 <mauke> wait, does that count as a final answer?
15:07:17 <ddarius> Deriving functions from types (or at least restrictions) is a good exercise in understanding parametricity.
15:07:38 <crayer> pumpkin_, was that your solution ?
15:07:41 <mauke> (I hope you didn't understand that)
15:07:57 <tomh> what would be the problem with this error: Couldn't match expected type `State s a' against inferred type `SomeType' where type SomeType = State Int Int for example?
15:08:07 <pumpkin_> crayer: well think about what Ord gives you, and where you can get b from
15:08:14 <Botje_> tomh: can you show code?
15:08:26 <tomh> yeah
15:09:01 <tomh> moment
15:09:09 <pumpkin_> crayer: mauke's one is deliberately complicated-looking, btw :P
15:09:14 <ImInYourMonad> yi not on windows? depends on unix failed to isntall
15:09:21 <crayer> phew :)
15:09:37 <tomh> Botje_:  http://mibbit.com/pb/t8umSH
15:09:45 <crayer> Ord gives back a Bool... >,<,>=, <=
15:09:53 <pumpkin_> alright
15:09:56 <crayer> I'm a little confused about the ordering
15:09:57 <pumpkin_> now, you need to return a b
15:10:01 <pumpkin_> where do you get a b from?
15:10:11 <Botje_> tomh: uh
15:10:11 <Cale> tomh: You missed a parameter to runState
15:10:13 <Botje_> that looks weird
15:10:15 <crayer> \x y -> x < y or something :)
15:10:21 <pumpkin_> crayer: nope
15:10:25 <tomh> even if i add another param, still same error
15:10:25 <Botje_> are you sure you want to store the _COMPUTATION_ and not just the state?
15:10:29 <pumpkin_> crayer: there's only one place you can get a b from
15:10:40 <crayer> interesting... hmmmmmmm
15:10:41 <ddarius> :t undefined :: b
15:10:42 <lambdabot> forall b. b
15:10:49 <Cale> tomh: Also it's really strange that you have a State computation inside an MVar.
15:10:49 * ddarius sows confusion.
15:10:50 <pumpkin_> well :P
15:10:54 <tomh> Botje_: I have no idea what I am doing, but I need to use a state monad :P
15:11:01 <pumpkin_> ddarius: that was your qualification of "only one TOTAL function", right?
15:11:15 <pumpkin_> you can make a slightly more interesting one with undefined, I guess
15:11:21 <Botje_> tomh: you have a function of type State s a
15:11:30 <ddarius> pumpkin_: You can make many more using undefined.
15:11:31 <Botje_> you store the s somewhere
15:11:34 <tomh> Cale: you mean I better store only the result of state change?
15:11:36 <Cale> tomh: You should also be aware that "let foo = bar" never takes any time.
15:11:37 <pumpkin_> yeah :)
15:11:40 <Botje_> you then do runState tick s
15:11:47 <Botje_> and get back an updated state, and an a
15:12:01 <tomh> mm ok
15:12:05 <Botje_> you do with the a what you want, but you keep the updated state for the next iteration
15:12:11 <Botje_> so GameState should be just GameEnv
15:12:14 <pumpkin_> crayer: you see where it's going?
15:12:18 <tomh> alright thanks
15:12:34 <crayer> nope, not at all..... \x y -> something that doesn't use y :)
15:12:41 <pumpkin_> crayer: only one source of b, and you don't know anything about the type of b
15:12:41 <Botje_> if you're not going to return something useful from your stateful computation, use execstate to only get the updated state
15:13:30 <pumpkin_> crayer: which means... how many values of type b do you know of? which ones could you return?
15:14:39 <tomh> So if I understand correctly you never really build a type for a State s a?
15:14:52 <crayer> pumpkin_, everything but the ones of type a?
15:15:06 <crayer> \anything
15:15:08 <pumpkin_> crayer: not really...
15:15:12 <crayer> darn :)
15:15:17 <pumpkin_> crayer: if I asked you for a function of type b -> b
15:15:21 <crayer> id
15:15:22 <pumpkin_> how many options would you have?
15:15:26 <Botje_> tomh: you have a monadic function of type State s a
15:15:36 <crayer> pumpkin_, \x -> x, id
15:15:45 <pumpkin_> crayer: the only options are f a = a, or f a = undefined or some other form of bottomness
15:16:05 <crayer> oh ok, that's what you meant
15:16:22 <pumpkin_> you see that id isn't just _an_ option, but the only total option?
15:16:36 <Botje_> a very simple one would be do { st <- get; put (st + 1) }
15:16:41 <Botje_> if your state was a simple integer
15:16:50 <Botje_> That has type State Int ()
15:16:55 <crayer> pumpkin_, to be honest, that "total option" thing is new to me :)
15:16:59 <ddarius> pumpkin_: id, const undefined, undefined
15:17:08 <pumpkin_> yeah
15:17:19 <ImInYourMonad> why no Yion windows?
15:17:20 <mauke> crayer: "total" basically just means that it has to return a real value :-)
15:17:39 <Saizan> for every input
15:17:46 <Saizan> (total input)
15:17:48 <crayer> ah ok
15:17:58 <pumpkin_> crayer: real value != undefined, and return != run forever :P
15:17:59 <mauke> and not do stupid things like f x = f (f x)  -- off to never-never land
15:19:00 <crayer> but how do i have to see these things? in a specific order like  Ord a => a -> (b -> (a -> b)) ?
15:19:08 <mauke> no
15:19:09 <crayer> (right associative)
15:19:10 <pumpkin_> you don't have to, that's implicit
15:19:16 <mauke> three inputs, one output
15:19:24 <mauke> think of it as (a, b, a) -> b
15:19:24 <pumpkin_> but the basic point is that it returns a b (that you know nothing about) and that it only takes one b in
15:19:27 <crayer> oh ok
15:19:42 <pumpkin_> crayer: there aren't that many options of where you can grab that b to return
15:20:22 <Axman6> > let blah f x = f (blah f x) in blah ("blah "++) ""
15:20:23 <lambdabot>   "blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah...
15:20:54 <pumpkin_> @remember Axman6 let blah f x = f (blah f x) in blah ("blah "++) ""
15:20:54 <lambdabot> I will never forget.
15:21:09 <crayer> this sucks :)
15:21:11 <mauke> in fact, here's another exercise: write ((a, b, c) -> d) -> (a -> b -> c -> d)
15:21:13 <mauke> :-)
15:21:21 <crayer> \x y z -> if x > z then y else y
15:21:23 <pumpkin_> crayer: if it feels simple, it's because it is
15:21:28 <pumpkin_> crayer: sounds good :P
15:21:30 <mauke> crayer: bingo
15:21:40 <pumpkin_> crayer: you can express that even more simply though
15:21:40 <crayer> stupid :)
15:21:44 <crayer> heheh
15:21:52 <crayer> what was your solution?
15:21:59 <pumpkin_> f _ x _ = x
15:21:59 <tomh> botje_: what does 'get' get its argument from?
15:21:59 <Axman6> > let blah f x = f (blah f x) in blah (\x -> "blah (f "++x++")") ""
15:22:01 <lambdabot>   "blah (f blah (f blah (f blah (f blah (f blah (f blah (f blah (f blah (f bl...
15:22:05 <tomh> what = where
15:22:07 * ddarius would just write \x y z -> const y (<some uses of x, z and a method from Ord>)
15:22:08 <mauke> @unpl flip liftM return . flip fmap . (>)
15:22:09 <lambdabot> (\ i -> liftM (\ f -> fmap f ((>) i)) return)
15:22:14 <mauke> blargh
15:22:19 <pumpkin_> I guess mine doesn't impose an Ord
15:22:24 <mauke> apply liftM=fmap=(.) and return=const
15:22:25 <crayer> haskell geeks :P
15:22:32 <mauke> @unpl flip (.) const . flip (.) . (>)
15:22:32 <lambdabot> (\ p f m -> f)
15:22:33 <crayer> heheh
15:22:40 <mauke> too clever :-|
15:22:51 <crayer> wow
15:22:51 <pumpkin_> mine wasn't clever enough :(
15:22:58 <Axman6> > let blah f x = f (blah f x) in blah (\x -> "blah f ("++x++")") ""
15:22:59 <lambdabot>   "blah f (blah f (blah f (blah f (blah f (blah f (blah f (blah f (blah f (bl...
15:23:06 <crayer> :D :D :D
15:23:07 <mauke> crayer: the original form of that was \a b c -> const b (a > c)
15:23:09 <ddarius> pumpkin_: Yeah, that was the solution I thought of too.  The Ord stuff was silly.
15:23:31 <mauke> crayer: then I pl'd it manually
15:23:36 <pumpkin_> in terms of a function, I guess it just means that the type signature given is too specific
15:23:49 <pumpkin_> and that no total function can exist with specifically that signature?
15:24:21 <crayer> and what's the total function?
15:24:31 <Botje_> tomh: i'm kind of watching dexter right now :)
15:24:44 <Botje_> but that's what the state monad does
15:24:52 <pumpkin_> crayer: the one you gave is total
15:25:09 <Axman6> > iterate (\x -> "blah f ("++x++")") "x"
15:25:10 <pumpkin_> but something more interesting could be if x > z then y else undefined or something
15:25:10 <lambdabot>   ["x","blah f (x)","blah f (blah f (x))","blah f (blah f (blah f (x)))","bla...
15:25:21 <mauke> our functions are total, they're just useless because the Ord constraint is effectively unused
15:25:24 <Botje_> if you call runState f st, calling get inside f will give you st
15:25:24 <pumpkin_> there are lots of options
15:25:46 <tomh> Botje_ ok, I guess i need to mess some more with it thanks
15:25:49 <Botje_> yeah
15:25:54 <crayer> but you were right again... not very useful :)
15:25:56 <Botje_> bash your head against the type errors a bit
15:25:56 <pumpkin_> crayer: you could probably count the number of functions involving undefined on two hands too
15:25:58 <crayer> very geeky though...
15:25:59 <crayer> :)
15:26:01 <Botje_> it'll work out in the end :)
15:26:17 <ddarius> crayer: You could mechanically derive the answer as well.
15:26:18 <tomh> too bad i dont have type errors when doing exams :/
15:26:23 <ddarius> In fact
15:26:32 <ddarius> @djinn f :: Ord a => a -> b -> a -> b
15:26:32 <lambdabot> Cannot parse command
15:26:39 <pumpkin_> don't think it takes constraints
15:26:40 <ddarius> @djinn (Ord a) => a -> b -> a -> b
15:26:40 <lambdabot> Error: Class not found: Ord
15:26:45 <ddarius> pumpkin_: It does.
15:26:49 <pumpkin_> ah
15:26:51 <ddarius> @djinn (Eq a) => a -> b -> a -> b
15:26:51 <lambdabot> f _ a _ = a
15:26:56 <pumpkin_> ah
15:26:59 <crayer> hehe
15:26:59 <comex> let's say I want to (somewhat pointlessly) define a function as
15:27:03 <comex> f x 0 = x; f x a = f (x + a)
15:27:24 <mauke> can't
15:27:36 <comex> ghci complains about infinite types
15:27:49 <mauke> missing argument in recursive call to f; expected 2, got 1
15:28:03 <crayer> f _ a _  = a  how do I type that into hugs :t ?
15:28:09 <crayer> i get an error if i do that
15:28:12 <Axman6> mauke: was that off the top of your head?
15:28:17 <mauke> crayer: :t let f _ a _ = a in f
15:28:18 <pumpkin_> can we go so far as to say that type signature is overly specific, and that a -> b -> c -> b is the most general form of it?
15:28:21 <mauke> Axman6: yes
15:28:24 <crayer> ah ok
15:28:24 <comex> wrong error :p
15:28:28 <comex>     Occurs check: cannot construct the infinite type: a = a -> a
15:28:30 <comex>     Probable cause: `f' is applied to too few arguments
15:28:31 <Axman6> heh, nice work
15:28:38 <quicksilver> if you use 'allocaBytes' you have to make sure you keep that Ptr explicitly reachable, don't you?
15:28:42 <pumpkin_> ddarius/mauke?
15:28:43 <quicksilver> otherwise it can be GCed?
15:28:44 <mauke> crayer: what
15:28:54 <comex> why isn't this possible?
15:28:57 <Botje_> tomh: bash your head long enough and you can bash yourself at the exam ;)
15:29:11 <mauke> comex: didn't I just tell you?
15:29:13 <Heffalump> comex: what would you expect it to do?
15:29:18 <quicksilver> no, that's not right.
15:29:24 <quicksilver> alloca is block-scoped not GCed
15:29:25 <comex> actually, I don't know what I was thinking about the f x 0 part
15:29:25 <quicksilver> hmm
15:29:33 <ddarius> pumpkin_: It's not overly specific for the answers we've given, but yes, as far as the actual semantic value is concerned, there exists a syntactic form with a more general type (namely the one you list).
15:29:57 <comex> but simpler, f x = f
15:30:08 <comex> so I can (maybe pointlessly) call f 1 2 3 4 5 ...
15:30:15 <Axman6> :t let f x = f in f
15:30:16 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t
15:30:16 <lambdabot>     Probable cause: `f' is applied to too few arguments
15:30:16 <lambdabot>     In the expression: f
15:30:25 <mauke> comex: what would be the type of f there?
15:30:42 <Heffalump> comex: you can play that kind of game with type classes
15:30:44 <Heffalump> but not directly
15:30:46 <ddarius> mauke: Clearly it would be t where t = a -> t
15:30:55 <mauke> f :: a@(b -> a)
15:30:59 <mauke> ^ my preferred syntax
15:31:06 <comex> mauke: is that actually valid haskell?
15:31:11 <mauke> comex: no
15:31:22 <comex> Heffalump: how?
15:31:31 <Heffalump> something like
15:31:54 <Heffalump> class Foo t where foo :: t
15:32:01 <Heffalump> instance Foo Int where foo = 0
15:32:19 <quicksilver> newtype Infinite = MkInfinite (b -> Infinite)
15:32:35 <c_wraith> So...  Why doesn't parsec's ParseError instance Error?  That'd be so... convenient
15:32:39 <quicksilver> (but then you can't write literally what comex wanted, you have to intersperse wrappers and unwrappers
15:32:45 <Heffalump> instance Foo t => Foo (Int -> t) where foo n = n + foo
15:32:47 * ddarius wonders if anyone reacted to my makeTree value from five hours ago.
15:32:56 <crayer> wow, i was fast with: \x -> x (\y -> y)  for ((a->a)->b)->b)
15:33:22 <ddarius> @djinn (a -> a) -> b) -> b
15:33:22 <lambdabot> Cannot parse command
15:33:31 <ddarius> @djinn ((a -> a) -> b) -> b
15:33:31 <lambdabot> f a = a (\ b -> b)
15:34:04 <mauke> :t flip id id
15:34:05 <lambdabot> forall c a. ((a -> a) -> c) -> c
15:34:17 <crayer> heheh
15:34:48 <pumpkin_> crayer: reasoning about types gets easier quite quickly, I think :)
15:34:53 <pumpkin_> and it's quite fun
15:35:02 <Ornedan> How does one generate unified documentation from multiple hackage packages? As in like the one at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:35:28 <mauke> so how about that ((a, b, c) -> d) -> (a -> b -> c -> d) thing?
15:35:36 <crayer> wow
15:35:46 <crayer> hm
15:35:48 <pumpkin_> mauke: isn't that one already named?
15:35:56 <mauke> not sure
15:35:59 <mauke> :t curry3
15:36:00 <lambdabot> Not in scope: `curry3'
15:36:04 <pumpkin_> guess not :P
15:36:32 <crayer> does it curry (or is it called uncurry) the tuple?
15:36:45 <c_wraith> :t curry
15:36:46 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:36:48 <pumpkin_> crayer: think about it in the same terms as we did earlier
15:36:49 <mauke> it curries the function
15:36:49 <ddarius> Tuples aren't curried or uncurried.
15:36:53 <c_wraith> that'd be curry
15:37:00 <mauke> (the first parameter is a function)
15:37:13 <comex> that... doesn't work
15:37:14 <crayer> ddarius, sorry about that, they look quite alike :P
15:37:24 <comex> though I suppose I'm being very mean to ghc and I shouldn't expect it to :u
15:37:33 <bbuszard> Hello all. A quick question about foldr: I've completed an exercise to rewrite map using foldr. My solution is this: map' func = foldr (\x -> (:) (func x)) []
15:37:50 <bbuszard> It works fine, but I was wondering if it was possible to write this without the lambda.
15:37:58 <pumpkin_> you already almost have
15:38:04 <ddarius> @pl foldr (\x -> (:) (func x)) []
15:38:05 <lambdabot> foldr ((:) . func) []
15:38:16 <mauke> bbuszard: \x -> f (g x) is f . g
15:38:23 <bbuszard> Thanks: let me try that in ghci for a sec...
15:38:32 <ddarius> Machines are so useful for doing mechanical things...
15:38:35 <ehird> @faq
15:38:35 <lambdabot> The answer is: Yes! Haskell can do that.
15:38:56 <ehird> > "The answer is: " ++ fix ("Yes! ") ++ "Haskell can do that."
15:38:56 <crayer> pumpkin_, but that's a tuple now, isn't it?
15:38:57 <lambdabot>   Couldn't match expected type `a -> a'
15:39:02 <ehird> > "The answer is: " ++ fix ("Yes! " ++) ++ "Haskell can do that."
15:39:03 <lambdabot>   "The answer is: Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes!...
15:39:10 <ehird> ...virginia
15:39:32 <ehird> > "The answer is: " ++ cycle "Yes! " ++ "Haskell can do that."
15:39:34 <lambdabot>   "The answer is: Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes! Yes!...
15:39:38 <pumpkin_> crayer: yeah, it's the same idea though... think about the output and what options you have to get it
15:40:00 <bbuszard> Sure enough. I tried various permutations but couldn't get the parentheses correct, so gave up and used a lambda.
15:40:14 <bbuszard> I find ghci's error messages downright opaque. Is that a common experience?
15:40:19 <comex> yes.
15:40:29 <pumpkin_> I found them quite informative actually :)
15:40:38 <pumpkin_> a lot more than most compilers
15:40:39 <mauke> it gets better with time :-)
15:40:44 <ehird> Treat ghc's errors like random things to pattern match on.
15:40:48 <ehird> They're not _English_, after all...
15:41:07 <bbuszard> Heh. Well, I'm trying to learn a new language, after wll.
15:41:07 <mauke> just keep learning stuff and ghc will magically improve the quality of its error messages
15:41:25 <Axman6> bbuszard: you get used to them. i agree, they could be much more helpful
15:42:30 <comex> at least it's not like the C compiler which outputs "Huh ?"
15:42:57 <Axman6> yeah. can't wait for clang to be finished, should make life to much easier
15:42:58 <mauke> +[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.]
15:43:00 <bbuszard> Or a c++ compiler with templates. Yick.
15:43:06 <comex> that too
15:43:26 <jethr0> > id id id (+) 2 3
15:43:27 <mauke> ^ found in a file called ed.bf
15:43:28 <lambdabot>   5
15:43:38 <pumpkin_> templateful c++ is horrible
15:43:43 <thomashartman1> is there an easy way to see what package a module is defined in, in ghci?
15:43:46 <pumpkin_> although trying to figure out cmm errors is also quite horrible
15:44:49 <ehird> mauke: times out in #esoteric's fungot
15:44:51 <ehird> what does it do?
15:45:06 <ddarius> ehird: You should be able to tell from the file name.
15:45:14 <jethr0> C++ STL errors are the absolute worst
15:45:15 <ehird> I'm assuming it's not a complete implementation of ed.
15:45:21 <mauke> run it locally :-)
15:45:28 <ehird> Don't have an interp to hand.
15:45:36 <ddarius> ehird: Write one.
15:45:44 <ehird> Bleh.
15:45:48 <pumpkin_> we should compile haskell to bf
15:45:50 <newsham> http://www.bdsoft.com/tools/stlfilt.html
15:46:00 <ehird> pumpkin_: a friend has made gcc-bf
15:46:01 <ddarius> You should be able to write a bf interpreter in < 10 minutes.
15:46:02 <ehird> which is near-complete
15:46:03 <crayer> hmmm that's a tough one
15:46:05 <ehird> so just use -fvia-C
15:46:12 <ehird> ddarius: I can but I won't for irc :)
15:46:16 <ehird> I'll just install egobfi
15:46:20 <mauke> ehird: http://mauke.ath.cx/stuff/c/bfi.c
15:46:21 <crayer> ((a, b, c) -> d) -> (a -> b -> c -> d)
15:46:44 <crayer> \(a,b,c) d -> d
15:46:44 <pumpkin_> crayer: you'll be kicking yourself when you figure it out
15:46:52 <jethr0> writing anything in 10 minutes is tough. but bf was indeed designed to be interpreted/compiled easily
15:46:54 <crayer> yes, i know :)
15:47:05 <mauke> crayer: already wrong because the first argument is a function, not a triple
15:47:16 <Axman6> , +[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.]
15:47:17 <lunabot>  luna: parse error on input `,'
15:47:36 <Axman6> , [$bf|+[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.]|] ""
15:47:38 <lunabot>  "*** Exception: bf blocked on input"
15:47:40 <ehird> OK, I'll try it now
15:47:44 <Axman6> , [$bf|+[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.]|] "hello"
15:47:45 <lunabot>  "*** Exception: bf blocked on input"
15:48:04 <ehird> agh
15:48:06 <ehird> it just outputs ?
15:48:06 <ehird> every newline
15:48:08 <ehird> :-)
15:48:13 <crayer> \a b c d -> a b c d
15:48:18 <ehird> mauke: :-D
15:48:26 <crayer> hmmm
15:48:28 <ehird> mauke: Unfortunately for you, I've used TECO -- and liked it.
15:48:36 <mauke> crayer: not quite; 'a' takes a triple, not three separate args
15:48:57 <wli> Someone's implementing TECO and/or ed in Haskell?
15:49:04 <Axman6> \a b c d -> a (b,c,d)
15:49:09 <ehird> wli: no; mauke wrote "ed" in Brainfuck
15:49:12 <pumpkin_> evil Axman6
15:49:16 <ehird> which just outputted ? on every newline
15:49:21 <Axman6> @ pl \a b c d -> a (b,c,d)
15:49:23 <pumpkin_> @djinn ((a, b, c) -> d) -> a -> b -> c -> d
15:49:23 <lambdabot> f a b c d = a (b, c, d)
15:49:24 <ehird> TECO in haskell sounds fun though; someone do that :-)
15:49:35 <crayer> unbelievable
15:49:37 <jethr0> curry/uncurry
15:49:43 <crayer> \a b c d -> a (b,c,d)
15:49:46 <Axman6> @pl \a b c d -> a (b,c,d)
15:49:46 <lambdabot> (. (,,)) . (.) . (.)
15:59:42 <pumpkin_> @hoogle @djinn ((a, b, c) -> d) -> a -> b -> c -> d
15:59:42 <lambdabot> Parse error:
15:59:42 <lambdabot>   --count=20 "
15:59:42 <lambdabot>              ^
15:59:42 <Axman6> obviously...
15:59:42 <pumpkin_> @hoogle ((a, b, c) -> d) -> a -> b -> c -> d
15:59:42 <lambdabot> No results found
15:59:42 <Axman6> o.O
15:59:42 <pumpkin_> so no curry3 in the standard libs?
15:59:42 <mauke> apparently not
15:59:42 <wli> I have a tough time writing ed in Haskell. I have to believe he used some kind of codegen from another language.
15:59:42 <ehird> @pl \a b c d e -> a (b,c,d,e)
15:59:42 <lambdabot> (. (,,,)) . (.) . (.) . (.)
15:59:42 <ehird> hmm
15:59:42 <ehird> increase the , and add another . (.)
15:59:42 <ehird> :-D
15:59:42 <ehird> wli: er, no
15:59:42 <ehird> brainfuck is easy
15:59:42 <ehird> and all the codegens for it output huge code
15:59:42 <ehird> wli: y'know, there's a mandelbrot set generator in BF
15:59:42 <ehird> and a game of life simulator
15:59:42 <mauke> wli: the code was "+[[,----------]>+++++++++[<+++++++>-]<.[-]++++++++++.]"
15:59:42 <crayer> unfortunately, i was just guessing... how could I find that out systematically?
15:59:42 <pumpkin_> crayer: how about (a -> b, a) -> b ? :P
15:59:42 <crayer> pumpkin_, piece of cake:
15:59:42 <ddarius> uncurry id
15:59:42 <crayer> \x -> (fst x) (snd x)
15:59:42 <crayer> i guess..
15:59:42 <pumpkin_> hrrmpf, we already know ddarius can do it :)
15:59:42 <ddarius> @. pl djinn (a -> b, a) -> b
15:59:42 <lambdabot> f = ap fst snd
15:59:42 <ehird> ddarius: are you a djinn by any chance?
15:59:42 <wli> Between regexes, line addresses, buffer yanking, moving, marks, undo, etc. I have my doubts that's a complete implementation.
15:59:42 <ehird> wli: I just said it outputs ? on every line and nothing else. It's a joke. :P
15:59:42 <pumpkin_> @djinn (a -> b, a) -> b
15:59:42 <lambdabot> f (a, b) = a b
15:59:42 <mauke> crayer: yeah, or \(f, x) -> f x
15:59:42 <pumpkin_> ap fst snd is cute though
15:59:42 <crayer> mauke, ah i see
15:59:42 <crayer> like pattern matching :)
15:59:42 <mauke> yep
15:59:42 <ddarius> It is pattern matching.
15:59:42 <pumpkin_> crayer: isn't this fun!
15:59:42 <ehird> TECO is actually quite powerful/easy after a few minutes of usage
15:59:42 <mauke> crayer: now write (a -> b) -> a -> b
15:59:42 <crayer> \x y -> x y
15:59:42 <ddarius> curry (uncurry id)
15:59:42 <pumpkin_> (a -> a) -> a
15:59:42 <ehird> ddarius: hahahaa
15:59:42 <pumpkin_> ::P
15:59:42 <mauke> crayer: correct, but there's a simpler solution: \x -> x
15:59:42 <mauke> explain why :-)
15:59:42 <ehird> ddarius: I think you mean curry (ap fst snd)
15:59:42 <crayer> hmmmmm
15:59:42 <ddarius> I meant what I said and said what I meant.
15:59:42 <pumpkin_> crayer: remember that the -> is right-associative
15:59:42 <ehird> pumpkin_: haha, look what you've done to the poor newbie now!
15:59:42 <ehird> you don't just lop around that kind of type.
15:59:42 <crayer> pumpkin_, yes
15:59:42 <pumpkin_> crayer: (a -> b) -> (a -> b)
15:59:42 <jethr0> > fst <*> snd $ ((+1), 2)
15:59:42 <lambdabot>   mueval: Prelude.read: no parse
15:59:42 <lambdabot>  mueval: UnknownError "GHC reported errors a...
15:59:42 <ehird> crayer: you have not done (a -> a) -> a yet!
15:59:42 <crayer> ehird sorry
15:59:42 <crayer> hmm
15:59:42 <jethr0> lambdabot simply doesn't like me anymore ;(
15:59:42 <ehird> (mwahahaha)
15:59:42 <mauke> ehird: ahh, delicious
15:59:42 <ehird> crayer: call me when you are done ;-)
15:59:42 <pumpkin_> crayer: don't let ehird scare you
15:59:42 <ehird> <_<
15:59:42 <pumpkin_> :)
15:59:42 <wli> I usually use uncurry $ flip (,) to swap pairs' elements.
15:59:42 <pumpkin_> I do snd &&& fst
15:59:42 <ddarius> (\(x,y) -> (y,x))
15:59:42 <pumpkin_> cause it's cute
15:59:42 * pumpkin_ wins the shortest **** competition
15:59:42 <ehird> ddarius: a -> b
15:59:42 <Axman6> pumpkin_: reads nicely... second and first
15:59:42 <Philonous> @hoogle (a,b) -> (b,a)
15:59:42 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
15:59:42 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
15:59:42 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
15:59:42 <pumpkin_> I guess I should've abbreviated that to co** for maximum ambiguity
15:59:42 <pumpkin_> or rather
15:59:42 <pumpkin_> more targeted ambiguity
16:00:00 <pumpkin_> crayer: you get why mauke's \x -> x works?
16:00:29 <crayer> pumpkin_, actually I'd say that's  of type  a->a only          so i guess I don't :)
16:00:39 <pumpkin_> you'd be right
16:00:44 <mauke> crayer: it's 'a -> a' for all types a
16:00:54 <pumpkin_> let a be (b -> c)
16:00:54 <mauke> which means I can specialize it for any a
16:01:15 <pumpkin_> and you get (b -> c) -> (b -> c) === (b -> c) -> b -> c
16:01:39 <mauke> > (\f x -> f x) sqrt 2
16:01:40 <lambdabot>   mueval: Prelude.read: no parse
16:01:40 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:01:44 <mauke> wat
16:01:47 <mauke> , (\f x -> f x) sqrt 2
16:01:50 <lunabot>  1.4142135623730951
16:01:54 <pumpkin_> lol
16:01:59 <mauke> , (\f -> f) sqrt 2
16:02:00 <lunabot>  1.4142135623730951
16:02:06 <wli> I think \(x,y,z) -> (z,x,y) and \(x,y,z) -> (y,x,z) are sufficient to generate all the permutations of 6 elements.
16:02:24 <wli> All 6 permutations of 3 elements.
16:02:45 <Axman6> wli: you should prove it )
16:02:48 <Axman6> :)*
16:03:23 <sm> is there a bug in ghc's handling of cpp conditionals and -Wall ? I see a warning that an import is not used, but it is used - if I remove the import it squawks at me
16:03:32 <mauke> @djinn ((x,y,z) -> (z,x,y)) -> ((x,y,z) -> (y,x,z)) -> ((x,y,z) -> (z,y,x))
16:03:32 <lambdabot> f a _ (b, c, d) =
16:03:32 <lambdabot>     case a (b, c, d) of
16:03:32 <lambdabot>     (e, f, g) -> (e, g, f)
16:03:44 <mauke> pfft
16:03:51 <pumpkin_> aw
16:04:36 <yav> sm: you could get a warning that an import is not used, if it is only used in things that are not used (e.g., they are defined but not expoerted or used for anything locally)
16:04:45 <Saizan> sm: it's a known bug that warnings about redundant imports are not accurate
16:05:07 <pumpkin_> crayer: wanna tackle that (a -> a) -> a one?
16:05:31 <pumpkin_> crayer: once you do that, your haskell-fu will be level 1
16:05:39 <crayer> i'm trying :)
16:06:03 <Philonous> wli: Those two might be enough for pemutations of any number of elements. rotate to the left and flip the leftmost is enough for "bubblesort"
16:06:19 <crayer> so far \a -> a . a  but that's one a too much
16:06:20 <mauke> (warning: deep magic ahead)
16:06:34 <mauke> lambda alone won't help you
16:07:23 <pumpkin_> someone should make a haskell tutorial that plays like an RPG, with levels and skill points :P
16:07:29 <pumpkin_> maybe we could attract all the RPG gamers
16:07:47 <sm> thanks! yav, that was it
16:07:58 <crayer> hmmmmm
16:08:45 <pumpkin_> you could have all sorts of funky tests: recursion, arrows, monads, monad transformers, parsers, GADTs, and so on :P and get scores and skill points :P
16:08:48 <jethr0> or something like "typing of the dead" only with small problems that require you to write a (pointless) oneliner in haskell under time pressure to kill the bad guys ;)
16:08:53 <Philonous> Like "You killed the Cont monad. You recieve fundeps and a GADT. You reach level 10"
16:09:02 <pumpkin_> lol
16:09:19 <mauke> type system of the dead
16:10:12 <wli> let f (x,y,z) = (z,x,y) ; g (x,y,z) = (y,x,z) then f, g, f . g, f . f . g, g . f . g, and g . g generate 6 distinct permutations, which must be all of them.
16:10:13 <jethr0> "get the 10th element of a list" (15 seconds)
16:10:17 <pumpkin_> http://www.c-jump.com/ o.O
16:10:18 <crayer> hm no idea
16:10:23 <crayer> looks so easy, but no idea
16:10:26 <mauke> (!! 9)
16:10:31 <jethr0> hehe
16:10:33 <pejo> One of the reasons Tetris was so successful is that you get a very visible negative feedback when you do a mistake.
16:10:46 <pumpkin_> crayer: so you have a function and you need to return the output of the function, right?
16:10:47 <pejo> Having a game of Haskell seems like an excellent idea.
16:10:57 <crayer> pumpkin_, yup
16:11:09 <pumpkin_> crayer: what's the only thing you could ever pass into the function
16:11:15 <pumpkin_> given that you have nothing but the function
16:11:22 <jethr0> i like the idea as well. i've seen some tutorials like that. wasn't there an online quiz for python in this style?
16:12:04 <crayer> pumpkin_, the function itself? (causing something ... malicious? )
16:12:13 <pumpkin_> not quite the function itself
16:12:23 <jethr0> or like one of the old-school text adventures. "go north; You are in a large cave and have to compute 'factorial of 20'" ;)
16:12:27 <pumpkin_> the function is of type a -> a
16:12:31 <crayer> pumpkin_, yes
16:12:34 <pumpkin_> but you could pass the output of the function to itself ;)
16:12:41 <mauke> the solution involves time travel
16:12:43 <crayer> pumpkin_, how do i do that?
16:12:53 <Sekaino> jethr0, I could get behind a Haskell Zork.
16:12:57 <pumpkin_> well then of course you need to figure out how to get the output
16:13:04 <mauke> steal the return value from the future, give it to the function, receive return value, send into past
16:13:05 <pumpkin_> since to get the output you need to pass the output to the function
16:13:19 <crayer> mauke, great, I have to find that flux capacitor!
16:13:24 <pumpkin_> crayer: it's called let
16:13:26 <mauke> it's called 'let'
16:13:29 <pumpkin_> lol
16:13:29 <mauke> haha
16:13:35 <Philonous> pumpkin_: Y doesn't typecheck, unfortunately.
16:14:11 <Philonous> But then again there is one element that is member of every type.
16:14:13 <crayer> mauke, pumpkin_: time traveling is dangerous
16:14:20 <mauke> yes
16:14:27 <yav> Philonous: it actually kind of does, if you use a "data" declaration
16:14:34 <mauke> you may cause a paradox
16:14:47 <mauke> this also makes your function "not total"
16:14:47 <wli> I forget how TECO differed from ed. I've not seen TECO very many times.
16:14:53 <Philonous> yav: Mind to elaborate?
16:15:01 <pumpkin_> yeah, but it's still fun :)
16:15:05 <crayer> mauke, yeah, something like two individuals saying the same thing at the same time :)
16:15:07 <wli> There was a simulator with TOPS-20 disk images around I saw TECO on.
16:15:16 <pumpkin_> :t fix
16:15:17 <lambdabot> forall a. (a -> a) -> a
16:15:20 <mauke> :t \f -> let x = f x in x
16:15:21 <lambdabot> forall t. (t -> t) -> t
16:15:31 <BMeph> You are in a maze of twisty programs, all alike. There is a lambda here.
16:15:31 <jmcarthur> yav, but that is dependent on the data type itself being recursive, so there is still some hidden type system magic going on there
16:15:47 <pumpkin_> BMeph: lol
16:15:54 <Philonous> @type \f -> f undefined
16:15:55 <lambdabot> forall a t. (a -> t) -> t
16:16:12 <mauke> :t \f -> f (f undefined)
16:16:13 <lambdabot> forall a. (a -> a) -> a
16:16:17 <pumpkin_> crayer: that function can actually be used to do some moderately interesting stuff
16:16:21 <crayer> mauke, pumpkin_ do you have another example for time traveling?
16:16:22 <mauke> :t \f -> f (f (f undefined))
16:16:22 <xs> hi. do the LLVM bindings for haskell support multicore stuff?
16:16:23 <lambdabot> forall a. (a -> a) -> a
16:16:34 <idnar> BMeph: you may be eaten by bottom?
16:16:45 <mauke> crayer: all cases of time travel can be written in terms of 'fix'
16:16:45 <pumpkin_> that sounds hot
16:16:53 <jmcarthur> :t fix (:)
16:16:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a] -> [a]
16:16:54 <lambdabot>     Probable cause: `:' is applied to too few arguments
16:16:54 <lambdabot>     In the first argument of `fix', namely `(:)'
16:16:59 <mauke> crayer: 'fix' encapsulates recursion
16:17:01 <jmcarthur> err, i'm stoopid today
16:17:05 <pumpkin_> > fix (1:)
16:17:06 <lambdabot>   mueval: Prelude.read: no parse
16:17:06 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:17:09 <pumpkin_> :(
16:17:32 <jmcarthur> :t fix (1:)
16:17:33 <lambdabot> forall t. (Num t) => [t]
16:17:35 <mauke> crayer: a recursive function uses a benign form of time travel by referring to itself before its definition is complete
16:17:37 <pumpkin_> , fix (1:)
16:17:39 <lunabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:17:41 <pumpkin_> what's up with lambdabot today?
16:17:50 <jmcarthur> > fix (1:) :: [Int]
16:17:51 <lambdabot>   mueval: Prelude.read: no parse
16:17:51 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:17:54 <jmcarthur> hmm
16:18:04 <pumpkin_> works fine in pumpkinbot
16:18:24 <BMeph> Bah, time for home - see ya in a few...
16:18:52 <crayer> interesting
16:18:58 <pumpkin_> crayer: try (b -> b -> c) -> (a -> b) -> a -> a -> c
16:18:58 <pumpkin_> :P
16:19:01 <crayer> hmmmmmm
16:19:02 <pumpkin_> it's not recursive or anything
16:19:10 <yav> Philonous:
16:19:11 * wli tries to figure out how to cabal uninstal
16:19:12 <yav> data T a = Mk (T a -> a)
16:19:12 <yav> fix :: (a -> a) -> a
16:19:12 <yav> fix f = it (Mk it)
16:19:12 <yav>   where it (Mk x) = f (x (Mk x))
16:19:14 <pumpkin_> but it's a handy function
16:19:29 <Sekaino> > 1
16:19:30 <lambdabot>   mueval: Prelude.read: no parse
16:19:30 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:19:33 <jmcarthur> pumpkin_, are you turning crayer into djinn? ;)
16:19:46 <pumpkin_> jmcarthur: it's part of our exclusive haskell type training camp
16:19:49 <yav> jmcarthur: yeah, magic doesn't really exist :)
16:19:53 <pumpkin_> only 1000 dollars to sign up
16:20:02 <Sekaino> I was getting those same errors on my lambdabot.  After making sure the State directory was available and running the program from the correct directory so it could find L.hs, it was fine.
16:20:18 --- mode: ChanServ set +o mauke
16:20:19 --- mode: mauke set +b %lambdabot!*@*
16:20:24 <pumpkin_> oh no
16:20:34 <pumpkin_> where's Cale?
16:20:42 <Botje_> what's \bot done?
16:20:47 <mauke> break
16:20:54 <pumpkin_> I can join pumpkinbot in the mean time
16:20:56 <Botje_> that's harsh :p
16:21:06 <jmcarthur> ?bot
16:21:26 <Sekaino> Is @ the lambdabot command character?
16:21:28 <Axman6> @bot
16:21:28 <pumpkinbot> :)
16:21:28 <lunabot>  :)
16:21:31 <pumpkin> > fix (1:)
16:21:33 <pumpkinbot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:21:35 <jmcarthur> ?bot
16:21:35 <pumpkinbot> :)
16:21:49 <Philonous> yav: I see. Thanks.
16:21:57 <jmcarthur> okay so lunabot doesn't respond to ?bot, just @bot
16:22:19 --- mode: mauke set -o mauke
16:22:25 <crayer> pumpkin, that's tough. How can I solve that systematically?
16:22:25 <Sekaino> I'm thinking maybe an @undefine will clean out L.hs with Pristine.hs to fix the problem, but that's a guess.
16:22:41 <pumpkin> crayer: think about the types of the indvidual parameters
16:22:55 <mauke> crayer: I think of it as connecting pipes
16:23:02 <mauke> that are color coded or whatever
16:23:06 <pumpkin> think in terms of (b -> b -> c) -> (a -> b) -> (a -> a -> c), maybe
16:23:15 <pumpkin> you have two as, and need to be a single c
16:23:24 <pumpkin> and you have a way from two bs to a c
16:23:28 <pumpkin> and a way from an a to a b
16:23:39 <pumpkin> there's only one way to connect them up that makes sense
16:24:01 <mauke> I need a 'c'; the only way to generate a 'c' is from two 'b's; the only way to generate a 'b' is from an 'a'; I have two 'a's; BAM!
16:24:15 <mauke> that gives me four possible solutions
16:24:22 <pumpkin> fair enough :)
16:24:45 <pumpkin> although for two of them that type would be too specific wouldn't it?
16:24:57 <mauke> yeah
16:25:08 <mauke> unless I insert pointless calls to asTypeOf
16:25:14 <pumpkin> :P
16:25:27 <Philonous> @type undefined :: (b -> b -> c) -> (a -> b) -> (a -> a -> c) -- *cough*
16:25:29 <pumpkinbot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:25:30 <crayer> hold on a minute, do I have to parse it from right to left?
16:25:40 <pumpkin> crayer: not necessarily
16:26:08 <pumpkin> oh no, Philonous ruined our happy little story :(
16:26:22 <mauke> you just have to identify the return type and the argument types
16:26:38 <mauke> possibly recursively if some of them are function types themselves
16:26:56 <wli> I need to cabal remove stuff so I can get rid of conflicts.
16:27:01 <crayer> mauke, ok but what are the arguments here? or better, where are they? :)
16:27:18 <pumpkin> crayer: you have two function arguments and two arguments of type a, and return a value of type c
16:27:20 <mauke> crayer: the last top-level arrow separates the arguments from the result
16:27:28 <mauke> crayer: the other top-level arrows separate the arguments
16:27:55 <Philonous> mauke: That's not quite true.
16:27:58 <mauke> so basically we have '(b -> b -> c), (a -> b), a, a' and a result of 'c'
16:28:09 <Philonous> (But I am nitpicking, sorry)
16:28:09 <mauke> Philonous: but it's how I think
16:28:29 <pumpkin> Philonous: he's already indicated that he knows that all functions have one argument,so I think the abstraction doesn't hurt here
16:28:36 <mauke> hey, let's uncurry it all up
16:28:45 <jmcarthur> you can also think of your two a's as inputs and the two function inputs as building blocks to use in your final solution... so you have f :: b -> b -> c and g :: a -> b, which you can use to transform x :: a and y :: a into something of type c
16:28:52 <mauke> (((b, b) -> c), (a -> b), a, a) -> c
16:29:54 <kolmodin_> I guess someone has already reported that http://code.haskell.org/ seems down?
16:30:09 <pumpkin> kolmodin_: I think someone's hogging all the CPU on the box
16:30:16 <pumpkin> and just making it go obscenely slowly
16:30:18 <mauke> \(f :: (b, b) -> c, g :: a -> b, x :: a, y :: a) -> f (???, ???)  -- need to call f to get a result of type c
16:30:34 <pumpkin> we need an IRC-based whiteboard
16:30:39 <crayer> heh
16:30:41 <pumpkin> with the pipe diagram on it
16:30:42 <mauke> \(f :: (b, b) -> c, g :: a -> b, x :: a, y :: a) -> f (g ???, g ???)  -- need to call g to get a value of type b
16:31:12 <mauke> \(f :: (b, b) -> c, g :: a -> b, x :: a, y :: a) -> f (g y, g x)  -- arbitrary placement of x and y, which have type a
16:31:15 <crayer> f (g x, g y)
16:31:33 <mauke> ok, now to curry it back
16:31:55 <kolmodin_> pumpkin: load average: 0.05, 0.05, 0.07
16:32:05 <pumpkin> kolmodin_: guess that isn't the case anymore :)
16:32:05 <mauke> \(f :: b -> b -> c) (g :: a -> b) (x :: a) (y :: a) -> f (g y) (g x)
16:32:11 <kolmodin_> pumpkin: :)
16:32:34 <jmcarthur> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
16:32:34 <pumpkinbot> f a b c _ = a (b c) (b c)
16:32:48 <jmcarthur> not the most useful one, djinn :P
16:32:51 <pumpkin> it picked one of the four possibilities
16:32:52 <mauke> djinn doesn't care about my 'y'; it simply uses 'x' twice
16:32:55 <augustss__> bummer
16:33:12 <endojelly> is code.haskell.org down or something?
16:33:32 <augustss__> needs a bigger search space probably
16:33:36 <jmcarthur> @pl \f g x y -> f (g y) (g x)
16:33:37 <pumpkinbot> join . (((.) . flip) .) . (.)
16:33:43 <kolmodin_> endojelly: seems so
16:33:55 <jmcarthur> @pl \x y -> f (g y) (g x)
16:33:56 <pumpkinbot> flip (f . g) . g
16:34:06 <jmcarthur> @pl \x y -> f (g x) (g y)
16:34:06 <pumpkinbot> (. g) . f . g
16:34:07 <mauke> :t on
16:34:08 <pumpkinbot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:34:21 <kolmodin_> Igloo: c.h.o seems down
16:34:22 <jmcarthur> @src on
16:34:22 <pumpkinbot> (*) `on` f = \x y -> f x * f y
16:34:42 <ddarius> pumpkin: If we were all used to J, this would be second nature.
16:35:14 <pumpkin> J in the sense of that APL-like almost esoteric language?
16:35:15 * jmcarthur still hasn't integrated on into his everyday toolbox
16:35:22 <Philonous> > compare `on` fst $ (4,3) (3,4) -- that's what it is good for
16:35:23 <pumpkinbot>       precedence parsing error
16:35:23 <pumpkinbot>          cannot mix `on' [infixl 0] and `($)' ...
16:35:25 <Axman6> @djinn (b -> b -> c) -> (a -> b) -> (a -> a -> c)
16:35:25 <pumpkinbot> f a b c _ = a (b c) (b c)
16:35:35 <mauke> :t comparing
16:35:36 <pumpkinbot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:35:39 <pumpkin> I've never looked at APL or J much, but I've seen their syntax and been scared
16:35:44 <wli> I think J was APL revised for ASCII character sets.
16:35:49 <Philonous> > (compare `on` fst ) (4,3) (3,4)
16:35:51 <pumpkinbot>   GT
16:36:02 <mauke> > comparing fst (4,3) (3,4)
16:36:04 <pumpkinbot>   GT
16:36:10 <Axman6> @src comparing
16:36:10 <pumpkinbot> Source not found. My pet ferret can type better than you!
16:36:18 <bbuszard> Another lambda question: I'm now trying to express filter through foldr. I have a working solution with lambda: filter' p = foldr (\x -> if (p x) then (x:) else id) []
16:36:34 <bbuszard> My question (again) is if it's possible to write this one without the lambda.
16:36:40 <Axman6> pretty sure comparing f = compare `on` f
16:36:42 <mauke> hmm, tougher
16:36:55 <idnar> @type comparing
16:36:56 <pumpkinbot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
16:37:01 <idnar> @type (compare `on`)
16:37:02 <pumpkinbot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
16:37:08 <mauke> @pl (\x -> if (p x) then (x:) else id)
16:37:08 <pumpkinbot> flip (liftM2 if' p (:)) id
16:37:15 <Axman6> @pl (\x -> if (p x) then (x:) else id)
16:37:16 <pumpkinbot> flip (liftM2 if' p (:)) id
16:37:20 <Axman6> bleh
16:37:26 <mauke> bbuszard: lambdabot recommends to write your own function for 'if' first
16:37:29 <chessguy> @bot
16:37:30 <pumpkinbot> :)
16:37:30 <lunabot>  :)
16:37:48 <vincenz_> @bot
16:37:48 <pumpkinbot> :)
16:37:48 <lunabot>  :)
16:37:53 <vincenz_> > 1
16:37:55 <pumpkinbot>   1
16:38:06 <vincenz_> Is there a reason we have so many bots?
16:38:24 <antirobotrobot> hello
16:39:04 <mauke> just as planned
16:39:18 --- mode: ChanServ set +o mauke
16:39:18 --- mode: mauke set -b %lambdabot!*@*
16:39:22 <idnar> heh
16:39:29 <mauke> lambdabot: @run 2
16:39:35 <lambdabot>   mueval: Prelude.read: no parse
16:39:40 <Cale> oh
16:39:41 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:39:42 <pumpkin> pumpkinbot: @part #haskell
16:39:45 <bbuszard> Write my own 'if"?? I vaguely recall doing similar things in scheme once, but this is an early exercise in a haskell text.
16:39:47 <mauke> pumpkin: :-[
16:39:51 <pumpkin> ?
16:39:55 <Cale> bbuszard: It's trivial.
16:39:56 <pumpkin> oh, I thought lambdabot  was back
16:40:00 <pumpkin> sorry
16:40:00 <mauke> lambdabot is still broken
16:40:08 <ddarius> vincenz_: They're a RAID array.
16:40:09 <pumpkin> mauke: you should actually be an admin of pumpkinbot
16:40:25 <bbuszard> Ok, back to the woodshed...
16:40:26 <Cale> bbuszard: Just pattern match on the Bool and return the appropriate argument :)
16:40:31 <mauke> pumpkin: do you use lambdabot's online.rc?
16:40:41 <pumpkinbot> I am the lord of all pumpkins, who has summoned me?
16:40:51 <pumpkin> mauke: yeah, I just added myself to it
16:41:04 <mauke> then I can simply make myself an admin
16:41:04 <pumpkin> but I kept the original one around in case someone else needed pumpkinbot when lambdabot was offline
16:41:11 <pumpkin> yup, you already are
16:41:18 <Cale> bbuszard: Parameters to a function will only ever be evaluated if needed. In scheme, you need to go to some trouble to avoid that.
16:41:18 --- mode: mauke set -o mauke
16:41:18 <mauke> even if I wasn't
16:41:22 <pumpkin> ah :)
16:41:42 <pumpkin> epic l33thax?
16:41:59 <t345> how do I specify a build flag to cabal
16:42:03 <ddarius> lambdabot doesn't have the most advanced security ever...
16:42:09 <pumpkin> sure doesn't seem like it :)
16:42:15 <Cale> hm?
16:42:18 <t345> cabal install foobar flag
16:42:21 <t345> does not work
16:42:22 <pumpkin> it's just doing a string check on the nick
16:42:27 <Axman6> pumpkin: is that like anthrax?
16:42:44 <pumpkin> Axman6: anthax?
16:42:58 <Axman6> with a lisp
16:43:06 <Cale> > 2
16:43:07 <lambdabot>   mueval: Prelude.read: no parse
16:43:07 <lambdabot>  mueval: UnknownError "GHC reported errors a...
16:43:08 <pumpkinbot>   2
16:43:14 <Cale> hmm, I wonder what's wrong.
16:43:20 * Axman6 makes note of the slight contextual oun there, being in a functional programming channel
16:43:23 --- mode: ChanServ set +o mauke
16:43:23 --- mode: mauke set +b %lambdabot!*@*
16:43:28 <Philonous> Btw. does ghc-head use the root or the weak strategy to gc sparks atm?
16:43:30 <t345> I got it
16:43:55 <crayer> alright then, gotta go now
16:43:57 <crayer> thanks for the lesson :)
16:44:07 <crayer> I'll see you guys tomorrow :)
16:44:14 <mauke> we like to learn you a haskell
16:44:28 <pumpkin> crayer: no prob, come back soon!
16:44:28 <pumpkin> :P
16:44:38 <crayer> heh bye :)
16:45:09 --- mode: ChanServ set +o Cale
16:45:13 --- mode: Cale set -b %lambdabot!*@*
16:45:17 <Cale> > 2
16:45:18 <lambdabot>   2
16:45:18 <pumpkinbot>   2
16:45:23 --- mode: mauke set -o mauke
16:45:28 <lament> but can it do 3??
16:45:30 <Cale> It was just something that someone had @let
16:45:35 <Axman6> > "botrace!"
16:45:36 <lambdabot>   "botrace!"
16:45:36 <mauke> oh wow
16:45:37 <pumpkinbot>   "botrace!"
16:45:39 <ddarius> lament: It goes all the way to 11!
16:45:44 <Axman6> > "botrace 2!"
16:45:44 <Cale> @undefin
16:45:45 <lambdabot>   "botrace 2!"
16:45:45 <pumpkinbot>   "botrace 2!"
16:45:46 <pumpkin> what kind of @let breaks lambdabot?
16:45:48 <skorpan`> > trace "lol" "lol"
16:45:48 <lambdabot>   Not in scope: `trace'
16:45:49 <pumpkinbot>   mueval: Prelude.read: no parse
16:45:49 <Cale> @undefine fixed it
16:45:50 <Axman6> > "botrace 3!"
16:45:51 <mauke> lambdabot needs better diagnostics then
16:45:51 <lambdabot>   "botrace 3!"
16:45:51 <pumpkinbot>   "botrace 3!"
16:45:54 <Cale> I don't know.
16:45:59 <mauke> pumpkinbot: @part
16:45:59 <pumpkinbot> Not enough privileges
16:46:00 <Axman6> pumpkin: your bot lost three nil
16:46:03 <mauke> o rly
16:46:05 <pumpkin> :(
16:46:09 <Cale> pumpkinbot: @part
16:46:09 <pumpkinbot> Plugin `system' failed with: Prelude.last: empty list
16:46:19 <Cale> pumpkinbot: @part #haskell
16:46:28 <pumpkin> mauke: guess you aren't on the cool kids list, sorry
16:46:34 <bbuszard> Side question: what were the @pl prefixes? Do they mean something in Haskell or in IRC-speak?
16:46:36 <mauke> Cale is :-)
16:46:41 <pumpkin> only the coolest of the cool can control the lord of all pumpkins
16:46:43 * pumpkin bows
16:46:48 <mauke> bbuszard: lambdabot commands
16:47:02 <idnar> bbuszard: @ is the bot command character, pl is the name of a command (short for "pointless")
16:47:15 <Sekaino> Woo, my theory about lambdabot was right.
16:47:22 <pumpkin> Axman6: that's cause I let people use my machine to do all sorts of heavy computation
16:47:23 <pumpkin> :(
16:47:28 <mle> is botrace some sort of speed benchmark?
16:47:35 <ddarius> Don't listen to them.  lambdabot is just a neurotic member of the community.
16:47:55 <mauke> @let show _ = ":("
16:47:56 <lambdabot>  Defined.
16:47:58 <mauke> > 42
16:47:59 <Philonous> ddarius: And a really fast typist.
16:47:59 <lambdabot>   42
16:48:00 <Axman6> it is not mle
16:48:07 <Axman6> now*
16:48:33 <Axman6> > show me the money
16:48:34 <lambdabot>   Not in scope: `me'Not in scope: `the'Not in scope: `money'
16:48:39 <Axman6> > show "me the money"
16:48:40 <lambdabot>   "\"me the money\""
16:48:43 <bbuszard> Ah, so is there a guide (somewhere) to lambdabot commands? They sound quite useful.
16:48:44 <Axman6> :o
16:48:47 <pumpkin> now I'm curious about what kind of @let can DOS lambdabot
16:49:03 <ddarius> Philonous: A couple of macros and you are set.  All you need is a few special cases e.g. the (truncated) infinite list of fibonnaci numbers, etc.
16:49:33 <bbuszard> Scratch last question. I googled it.
16:50:38 <Sekaino> @penis 1,1,1
16:50:39 <lambdabot>  Pascal's triangle read by rows: C(n,k) = binomial(n,k) = n!/(k!*(n-k)!), 0<=...
16:50:39 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,10,10,5,1,1,6,15,20,15,6,1,1,7,21,35,35,2...
16:51:01 <mauke> haha
16:51:40 <Philonous> ddarius: About right. All a haskell compiler needs to implement is fibonaccy numbers and pseudo quicksort as a one liner. No one is ever going to know the difference :>
16:51:59 <jethr0> @penis 1, 1, 2, 3, 5, 8
16:52:00 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
16:52:00 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:52:53 <m0nkfish> lol what
16:53:10 <skorpan`> > let { f 0 = 1; f 1 = 1; f n = f (n - 1) * f (n - 2) } in f 34
16:53:22 <skorpan`> no?
16:53:26 <lambdabot>   thread killed
16:53:30 <skorpan`> what the...
16:53:37 <Cale> m0nkfish: It spell corrected to oeis
16:53:38 <skorpan`> > let { f 0 = 1; f 1 = 1; f n = f (n - 1) * f (n - 2) } in f 3
16:53:39 <lambdabot>   1
16:53:44 <skorpan`> > let { f 0 = 1; f 1 = 1; f n = f (n - 1) * f (n - 2) } in f 5
16:53:45 <lambdabot>   1
16:53:53 <skorpan`> oh, geez
16:54:33 <skorpan`> > let { f 0 = 1; f 1 = 1; f n = f (n - 1) + f (n - 2) } in f 34
16:54:49 <lambdabot>   thread killed
16:54:53 <skorpan`> > let { f 0 = 1; f 1 = 1; f n = f (n - 1) + f (n - 2) } in f 10
16:54:54 <lambdabot>   89
16:55:23 <Cale> That is a pretty slow way to compute fibs, because old results get recomputed over and over.
16:55:28 * bremner crashed his laptop demoing parallel fibonacci today: spawn a thread for f(n-1).  It worked fine on my desktop
16:55:47 <jethr0> > iterate (\(x,y) -> (y, x+y)) (1,1)
16:55:48 <lambdabot>   [(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),(89,1...
16:56:02 <jethr0> > map fst . iterate (\(x,y) -> (y, x+y)) $ (1,1)
16:56:03 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
16:56:04 <bremner> my way is the second stupidest!
16:56:09 <pumpkin> jethr0: or use unfoldr
16:56:15 <Cale> > fix ((0:) . scanl (+) 1)
16:56:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:56:24 <Cale> > fix ((0:) . scanl (+) 1) !! 34
16:56:25 <lambdabot>   5702887
16:56:27 <jethr0> i know, just takes me longer to wrap my head around unfoldr...
16:56:28 <FunctorSalad> use matrices and linear recursion o_O
16:56:53 <FunctorSalad> (someone install a linear algebra package on lambdabot already ;))
16:57:23 <FunctorSalad> (even better, square and multiply of course)
16:57:24 <bremner> I was trying to figure out if there is some clever divide and conquer way of computing factorials (like power). Anyone know?
16:57:48 <Pseudonym> bremner: Yeah, it's the obvious method.
16:57:51 <FunctorSalad> bremner: there's stirling's approximation if you don't need the exact result
16:57:59 * bremner blushes
16:58:06 <bremner> ok, so, give...
16:58:11 <Pseudonym> product [1..n] = product [1..n `div` 2] * product [n `div` 2 .. n]
16:58:15 <FunctorSalad> (not divide-and-conquer directly, but it reduces it to exponentiation)
16:58:18 <Pseudonym> product [1..n] = product [1..n `div` 2] * product [n `div` 2 + 1 .. n]
16:58:20 <Pseudonym> Actually.
16:58:24 <Philonous> :t unsignedBits
16:58:25 <lambdabot> Not in scope: `unsignedBits'
16:58:29 <Pseudonym> Really, that's it.
16:58:51 <bremner> Pseudonym: ahh, ok. thanks
16:59:08 <Pseudonym> There are even cleverer methods, but that's actually surprisingly faster than product [1..n].
16:59:18 <Pseudonym> And if you can work out why, y ou are a true maths nerd.
16:59:30 <bremner> I was hung up by not generalizing enough
16:59:46 <Pseudonym> bremner: http://andrew.bromage.org/darcs/numbertheory/
16:59:50 <Pseudonym> Look at Math.Combinatorial.
17:00:04 <wli> > execWriter . flip evalStateT (0, 1) $ let m = do { (a, b) <- get ; tell [a] ; put (b, a + b) ; m } in m
17:00:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:00:08 <Philonous> Pseudonym: Is it because you avoid using bigInts?
17:01:43 <Pseudonym> Philonous: No.
17:01:49 <Pseudonym> Quite the opposite, in fact.
17:02:02 <Philonous> Really? That puzzles me
17:02:22 <Pseudonym> Philonous: What do you know about big integer multiplication?
17:02:35 <Philonous> It takes longer than simple integer multiplikation
17:02:43 <Pseudonym> Do you know what its complexity is?
17:02:44 <Philonous> At least that's what I'd suspect
17:03:08 <endojelly> anyone here using agda?
17:03:36 <Philonous> O(n^2)? I'm not sure
17:03:50 <Pseudonym> It depends on the algorithm.
17:03:58 <Philonous> Of course
17:04:04 <Pseudonym> Karatsuba algorithm is O(n^1.5) or so.
17:04:12 <Philonous> Bad enough
17:04:12 <Pseudonym> FFT algorithm is O(n log n).
17:04:31 <Philonous> So avoiding it as long as possible should buy some speed uo, shouldn't it?
17:04:35 <Pseudonym> But the thing is, these algorithms are horribly inefficient if the two numbers being multiplied are of ver different magnitude.
17:04:42 <olsner> Pseudonym: and 'n' is the number of bits?
17:04:49 <Pseudonym> Yeah.
17:05:26 <Pseudonym> The reason why divide and conquer works better is precisely because the faster algorithms kick in when the numbers are of a similar size.
17:05:31 <Philonous> Ah I see. that's why divide and conquer is better
17:05:35 <Pseudonym> Yeah.
17:06:11 <Pseudonym> Divide an conquer is the fastest naive algorithm.
17:06:12 <bremner> Pseudonym: but divide and conquer is exponentially better for exponentiation, so it is not quite as big a win I guess.
17:06:21 <Pseudonym> Sure, but it's noticable.
17:06:28 <Pseudonym> O(n log n) beats O(n^2)
17:06:42 <Pseudonym> There are also algorithms that put off big integer arithmetic as long as possible.
17:06:43 <Pseudonym> Example:
17:06:47 <Pseudonym> @let s p 0 = 0
17:06:48 <lambdabot>  Defined.
17:06:49 <cognominal_> @src io
17:06:50 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:06:58 <cognominal_> @type io
17:06:58 <Philonous> You could, however, use simple integer multiplication as long as the numbers are reasonably small. And you get more of them in divide at impera as well
17:07:00 <lambdabot> Not in scope: `io'
17:07:04 <Philonous> That's what I meant in the first place
17:07:06 <Pseudonym> @let s p n = let (qm,r) = n `divMod` p in s p q + r
17:07:06 <lambdabot>  <local>:2:37:
17:07:06 <lambdabot>      Ambiguous occurrence `s'
17:07:06 <lambdabot>      It could refer to either `L...
17:07:11 <Pseudonym> @let s p n = let (q,r) = n `divMod` p in s p q + r
17:07:11 <lambdabot>  <local>:2:36:
17:07:11 <lambdabot>      Ambiguous occurrence `s'
17:07:11 <lambdabot>      It could refer to either `L...
17:07:18 <Pseudonym> @let s p n = let (q,r) = n `divMod` p in L.s p q + r
17:07:19 <lambdabot>  Defined.
17:08:24 <Pseudonym> @let primesUpTo n = let sieve (p:ps) = p : filter (\n -> n `mod` p /= 0) ps in takeWhile (<= n) (sieve [2..])
17:08:25 <lambdabot>  Defined.
17:08:29 <Pseudonym> > primesUpTo 10
17:08:30 <lambdabot>   [2,3,5,7,9]
17:08:32 <Pseudonym> OK.
17:09:07 <mauke> Extended Primesâ¢
17:09:11 <Pseudonym> > let n = 100 in [ (p, (n - L.s p n) `div` (p-1)) | p <- primesUpTo n ]
17:09:12 <lambdabot>   [(2,97),(3,48),(5,24),(7,16),(9,12),(11,9),(13,7),(15,6),(17,5),(19,5),(21,...
17:09:19 <Pseudonym> That's the prime factorisation of 100!
17:09:27 <Pseudonym> 2^97 * 3^48 * ...
17:09:28 <endojelly> so 9 is prime now? %)
17:09:32 <Pseudonym> Erm.
17:09:37 <Pseudonym> Ah.
17:09:56 <skorpan`> jesus the scanl solution for fibonacci was fast
17:10:06 <Pseudonym> @let primesUpTo' n = let sieve (p:ps) = p : primesUpTo' (filter (\n -> n `mod` p /= 0) ps) in takeWhile (<= n) (sieve [2..])
17:10:06 <lambdabot>  <local>:4:107:
17:10:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
17:10:24 <Pseudonym> @let primesUpTo' n = let sieve (p:ps) = p : sieve (filter (\n -> n `mod` p /= 0) ps) in takeWhile (<= n) (sieve [2..])
17:10:25 <lambdabot>  Defined.
17:10:28 <Pseudonym> > primesUpTo' 10
17:10:30 <lambdabot>   [2,3,5,7]
17:10:33 <Pseudonym> Better.
17:10:38 <Pseudonym> > let n = 100 in [ (p, (n - L.s p n) `div` (p-1)) | p <- primesUpTo' n ]
17:10:39 <lambdabot>   [(2,97),(3,48),(5,24),(7,16),(11,9),(13,7),(17,5),(19,5),(23,4),(29,3),(31,...
17:10:46 <Pseudonym> > let n = 10 in [ (p, (n - L.s p n) `div` (p-1)) | p <- primesUpTo' n ]
17:10:47 <lambdabot>   [(2,8),(3,4),(5,2),(7,1)]
17:10:48 <Pseudonym> That's simpler.
17:11:00 <Pseudonym> > 2^8 * 3^4 * 5^2 * 7
17:11:01 <lambdabot>   3628800
17:11:03 <Pseudonym> > product [1..10]
17:11:04 <lambdabot>   3628800
17:11:06 <Axman6> > primesUpTo 100
17:11:07 <lambdabot>   [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:11:18 <Pseudonym> @let oddNumbersUpTo = primesUpTo
17:11:19 <lambdabot>  Defined.
17:11:26 * wli threatens to paste the monadic Eratosthenes again.
17:11:27 <Axman6> i wrote a somewhat efficient prime finder in C the other day
17:11:39 <Pseudonym> Yeah, this is inefficient, but it's a one-liner.
17:11:42 <Axman6> > primesUpTo' 100
17:11:43 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
17:11:57 <bbuszard> Fun with if': I've cribbed together an if on this pattern: if' :: Bool -> a -> a -> a
17:12:07 <m0nkfish> i think c++ is the most efficient language ive been able to use
17:12:11 <wli> The monadic Eratosthenes is a one-liner too, just a long line. ;)
17:12:12 <bbuszard> It works, but I'm having trouble employing it in filter'
17:12:24 <Pseudonym> m0nkfish, there are no efficient languages, just efficient implementations.
17:12:35 <Pseudonym> Though there are inherently inefficient languages.
17:12:36 <bbuszard> My filter' implementation is on this pattern: filter' :: (a -> Bool) -> ([a] -> [a])
17:12:52 <m0nkfish> right so there are no efficient languages but there are inefficient languages
17:12:56 <m0nkfish> everything is relative, einstein
17:13:05 <skorpan`> don't feed...
17:13:11 <bbuszard> So the trick (for me) is to get an if' that takes (a -> Bool), not simply Bool.
17:13:15 <bbuszard> I think...
17:13:28 <Pseudonym> I happen to be a very happy C++ programmer, FWIW.
17:13:36 * Pseudonym knows of what he speaks
17:13:44 <m0nkfish> did i ask
17:13:55 <p_l> Pseudonym: So, you drink/smoke a lot? :D
17:13:55 <m0nkfish> im pretty sure i didnt
17:14:13 <bremner> @src foldr1
17:14:13 <lambdabot> foldr1 _ [x]    = x
17:14:13 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:14:13 <lambdabot> foldr1 _ []     = undefined
17:14:32 <Pseudonym> C++ can be very poorly written.  Especially by C programmers.
17:14:48 <m0nkfish> wow thats a great critique
17:14:54 <skorpan`> but so can any code written in any other language
17:14:55 <Igloo> kolmodin_: Ta, I've restarted apache
17:14:57 <Pseudonym> Of C programmers?  Yes, I thought so.
17:15:18 <skorpan`> the language itself can do very little to help the programmer write "good code"
17:15:23 <m0nkfish> all these years ive been thinking that you just snap your fingers and you learn a lanuage
17:16:23 <bbuszard> Perhaps my previous helpers have gone off to dinner...
17:16:31 <bbuszard> I'm trying to re-write filter through foldr.
17:16:57 <bbuszard> The suggestion was to write my own if, which I've done, but I'm having trouble employing it in my version of filter'
17:17:09 <bbuszard> My if' looks like this:
17:17:09 <mauke> bbuszard: just use it instead of normal 'if'
17:17:34 <bbuszard> if' :: Bool -> a -> a -> a
17:17:38 <bbuszard> if' True x _ = x
17:17:43 <bbuszard> if' False _ y = y
17:17:56 <mauke> if' c t e = if c then t else e  -- fewer lines
17:18:00 <Axman6> it's usually written: if' p t f = if p then t else f
17:18:05 <Philonous> @type bool
17:18:06 <lambdabot> Not in scope: `bool'
17:18:21 <bbuszard> mauke: when I try that in my filter' I get a "couldn't match expected type" error.
17:18:29 <mauke> then you're doing it wrong
17:18:35 <bbuszard> Doubtless.
17:18:41 <bbuszard> My filter' is thus:
17:18:51 <bbuszard> filter' :: (a -> Bool) -> ([a] -> [a])
17:19:03 <bbuszard> filter' p = foldr (if' p (:) id) []
17:19:20 <mauke> wait, what happened to x?
17:19:59 <mauke> :t let if' c t e = if c then t else e in  \p -> foldr (\x -> if' (p x) (x :) id)) []
17:20:00 <lambdabot> parse error on input `)'
17:20:07 <mauke> :t let if' c t e = if c then t else e in  \p -> foldr (\x -> if' (p x) (x :) id) []
17:20:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:21:46 <bbuszard> I'm a bit confused. I have a working version with lambda, but am trying to write it without lambda; I'm trying to write filter' with partial application. I may have royally screwed it up, of course.
17:22:16 <mauke> well, step 2 here is to remove the lambda from (\x -> if' (p x) (x :) id)
17:22:25 <mauke> which is going to get a bit hairy because it's used twice
17:22:57 <Axman6> @let if'' t f p = if p then t else f
17:22:58 <lambdabot>  Defined.
17:23:37 <jenner> flip ftw :)
17:24:39 <bbuszard> Hmm. Perhaps I'm trying to do something kludgy and the lambda expression is the best way to go.
17:25:21 <mauke> :t let if' c t e = if c then t else e in  \p -> foldr (ap (ap ((ap (const if') p) (:)) (const id)) []
17:25:23 <lambdabot> parse error (possibly incorrect indentation)
17:25:47 <mauke> :t let if' c t e = if c then t else e in  \p -> foldr (ap (ap (ap (const if') p) (:)) (const id)) []
17:25:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:25:53 <mauke> there we go
17:26:12 <jenner> what's ap?
17:26:29 <Philonous> @src ap
17:26:29 <lambdabot> ap = liftM2 id
17:26:47 <jenner> oh, haven't used lift* yet
17:27:08 <Cale> Or, ap f x = do g <- f; y <- x; return (g y)
17:27:09 <bbuszard> Me either. I thinke mauke's answer just shot right over my head.
17:27:13 <bbuszard> Thanks, though.
17:27:34 <Cale> It's using the (->) e monad
17:27:53 <mauke> see http://en.wikipedia.org/wiki/SKI_combinator_calculus
17:28:17 * jenner whimpers
17:28:45 * bbuszard laughs.
17:28:53 <Philonous> ap [(
17:29:07 <Cale> :t let if' c t e = if c then t else e in  \p -> foldr (do b <- p; u <- (:); return (if' b u id)) []
17:29:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:29:23 <Philonous> > ap [(+2),(+5),(*7)] [1,5,100]
17:29:25 <lambdabot>   [3,7,102,6,10,105,7,35,700]
17:29:59 <Philonous> > ap (Just (+2) ) (Just 7)
17:30:00 <lambdabot>   Just 9
17:30:15 <Cale> hmm
17:30:18 <jenner> ist that part of glasgow extensions?
17:30:31 <mauke> no
17:30:41 <Philonous> Just monads
17:31:08 <mauke> http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
17:31:19 <jenner> <interactive>:1:0: Not in scope: `ap'
17:31:29 <mauke> ^ complete algorithm for getting rid of lambdas
17:31:32 <Philonous> @hoogle ap
17:31:33 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:31:33 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
17:31:33 <lambdabot> Language.Haskell.TH AppE :: Exp -> Exp -> Exp
17:31:43 <Philonous> you need to import Control.Monad
17:31:49 <jenner> ah
17:31:51 <mauke> and Control.Monad.Instances
17:32:20 <Cale> :t let if' c t e = if c then t else e in  \p -> foldr (($ id) . liftM2 if' p (:)) []
17:32:22 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:32:50 <mauke> pfft, you probably used your *brain*
17:32:57 <Axman6> @pl \p -> foldr (($ id) . liftM2 if' p (:)) []
17:32:58 <lambdabot> flip foldr [] . (($ id) .) . flip (liftM2 if') (:)
17:33:03 <dolio> :t let if' c t e = if c then t else e in \p -> foldr (if' <$> p <*> (:) <*> return id) []
17:33:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:37:53 <nominolo> hm, is there a way to force writeFile to complete?
17:38:15 <bd_> what do you mean by that?
17:38:29 <nominolo> I have the strange feeling that writeFile f ... >> functionThatUses f does not see the modified f
17:38:53 <mauke> I don't trust your feelings
17:38:58 <Cale> nominolo: nope, it completes before continuing
17:39:03 <nominolo> hm, it could be a timestamp issue
17:39:08 <bd_> f is a FilePath, you don't modify f itself :)
17:39:13 <bd_> where FilePath = String
17:39:24 <monochrom> haha
17:39:28 <nominolo> bd_: i'm no newbie
17:39:48 <nominolo> bd_: i mean the function eventually reads that file
17:41:25 <bd_> nominolo: hard to tell whether people are new at times :) But it should be finished before writeFile returns... running the program under strace or something might give some interesting hints :/
17:41:46 <mauke> strace++
17:42:05 <nominolo> Yeah, I think the problem is that the function that uses f, actually checks the timestamp before trying to load it
17:42:24 <nominolo> and timestamps are in seconds, iiuc
17:42:29 <jenner> @source seq
17:42:29 <lambdabot> seq not available
17:42:37 <mauke> @src seq
17:42:37 <lambdabot> Source not found. Maybe you made a typo?
17:42:40 <pumpkin> a dtrace provider for haskell would be cool
17:43:36 <Axman6> indeed
17:43:48 <Axman6> though, what would it provide?
17:43:58 <chessguy> > takeWhile (not . even) [1,2,3,4,5]
17:44:00 <lambdabot>   [1]
17:44:10 <pumpkin> Axman6: statistics, function entry/exit introspection, and so on?
17:44:19 <chessguy> @src takeUntil
17:44:19 <lambdabot> Source not found. Wrong!  You cheating scum!
17:44:50 <chessguy> @hoogle (a -> Bool) -> [a] -> [a]
17:44:51 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
17:44:51 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
17:44:51 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
17:44:59 <b1> is there an equivalent of Data.Map's unionWith for Data.Set?
17:45:00 <chessguy> @hoogle+
17:45:00 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
17:45:00 <lambdabot> Data.List filter :: (a -> Bool) -> [a] -> [a]
17:45:00 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
17:45:06 <Axman6> pumpkin: i was thinking that, but the compiler's free to totally rearrange your code right? so telling where a function is entered may be difficult
17:45:08 <chessguy> hmph
17:45:30 <Philonous> jenner: a `seq` b = b, but is strict on both arguments
17:45:33 <pumpkin> Axman6: true, but you already get something like that (to a lesser degree) in c code
17:45:41 <chessguy> i'd like to take everything in a list up to and including the first element where the predicate is true
17:45:53 <pumpkin> you could only ever trace on exported functions with well defined boundaries
17:46:17 <pumpkin> things with tail calls already don't work in dtrace
17:46:48 <chessguy> so > takeThrough even [1..5] -- would give [1,2]
17:46:53 <chessguy> or takeThrough odd, either way
17:46:53 <pumpkin> you could still get a fair number of interesting things out of it I think
17:47:00 <jenner> Philonous: I found it in the Report, however I was wondering why some other source defined seq as a monad
17:47:02 <Axman6> what is a tail call exactly anyway? i think i know, but i'd like to make sure
17:47:20 <jenner> Philonous: seq am bm = do { am; bm }
17:47:20 <m0nkfish> it returns the list without the first item
17:47:21 <m0nkfish> xD
17:47:34 <b1> Axman6: It's a call in tail position.
17:47:45 <Axman6> meaning...
17:47:50 <pumpkin> in the c case, if you call a function and return its value directly, compilers will tend to jump straight into the other function
17:47:50 <b1> loosely speaking "The last thing"
17:48:09 <Axman6> (a C example would be nice, pretty sure i get the haskell way)
17:48:27 <pumpkin> int x() { return y(); }
17:48:36 <pumpkin> it'll jump straight into y
17:48:37 <Axman6> ah, righto
17:48:37 <Philonous> jenner: the second one is actually (>>). I dont know why they call it seq
17:48:41 <b1> does g++ do tail call optimization?
17:49:03 <chessguy> > let takeThrough _ [] = []; takeThrough p (x:xs) | p x = [x] | otherwise = x : takeThrough p xs in takeThrough even [1..5]
17:49:04 <pumpkin> b1: not sure, but I think so
17:49:05 <lambdabot>   [1,2]
17:49:19 <jenner> Philonous: it's an old prelude from an ancient gofer script
17:49:25 <pumpkin> b1: I've definitely seen it in generated code on mac os, and I think they mostly use gcc/g++
17:49:41 <chessguy> > let takeThrough _ [] = []; takeThrough p (x:xs) | p x = [x] | otherwise = x : takeThrough p xs in takeThrough even [1,3,7,6]
17:49:42 <lambdabot>   [1,3,7,6]
17:49:51 <b1> I feel like a Banana in Pajamas with this login. Bloody nickserv.
17:50:15 <pumpkin> b1: ooh haskell at brown? :o
17:50:17 <Axman6> b1: G'day?
17:53:54 <jenner> sheesh, there's even a chapter about TkGofer, I think I'll just leave it out
17:57:53 <Sekaino> >  nubBy (\a b -> even (a + b)) [1..10]
17:57:55 <lambdabot>   [1,2]
17:59:09 <Sekaino> (joking)
17:59:54 <chessguy> @pl \a b -> even (a+b)
17:59:54 <lambdabot> (even .) . (+)
18:01:07 <chessguy> > fmap even . (+) $ 2 3
18:01:08 <lambdabot>       Overlapping instances for Show (a -> Bool)
18:01:08 <lambdabot>        arising from a use of...
18:01:25 <chessguy> > fmap even . (+) 2 3 4
18:01:26 <lambdabot>       Overlapping instances for Show (a1 -> f Bool)
18:01:26 <lambdabot>        arising from a use...
18:02:52 <Sekaino> @pl (\(a,b) -> case b of (x:xs) -> a++[x]; _ -> a) $ span (not.even) [1,3,7,6]
18:02:52 <lambdabot> (line 1, column 29):
18:02:52 <lambdabot> unexpected ">"
18:02:52 <lambdabot> expecting variable, "(", operator or ")"
18:03:10 <b1> ok -- so I've implemented a binomial heap. I'm representing the subtrees in a list. I think my merge operation is killing my performance
18:03:30 <pumpkin> b1: how are you implementing the merge?
18:03:39 <b1> poorly.
18:03:44 <pumpkin> also, are you using !! ?
18:03:58 <b1> I'm not. Should I be?
18:04:05 <pumpkin> nope, it's bad :)
18:04:17 <b1> the subtrees are in sorted order by rank
18:04:32 <b1> if the heads are of equal rank, I merge them
18:04:41 <Sekaino> > let f t = (\(a,b) -> case b of (x:xs) -> a++[x]; _ -> a) $ span (not.t) in f even [1..10]
18:04:42 <lambdabot>   Couldn't match expected type `([a], [a])'
18:05:29 <chessguy> amusing blog by Wadler today
18:05:55 <chessguy> on sproggles and glorps
18:06:07 <pumpkin> I love glorps
18:06:08 <chessguy> ( i think they're advanced new data structures)
18:06:09 <pumpkin> what are sproggles?
18:06:20 <b1> the trouble is if merging two subtrees generates a subtree with rank equal to one of the elements remaining in my subtree lists
18:06:27 <chessguy> pumpkin:  he doesn't define them
18:06:32 <pumpkin> oh :(
18:06:48 <chessguy> http://wadler.blogspot.com/2009/03/nonreferential-this.html
18:07:38 <pumpkin> aha
18:08:22 <b1> anyone? anyone? Bueller?
18:08:41 <chessguy> b1:  umm...42?
18:08:51 <pumpkin> b1: seems like you hit an idle spot, and I'm not sure how to help without seeing code :)
18:09:03 <Sekaino> > (\(a,b) -> a++(take 1 b)) $ span (not.even) [1..10]
18:09:04 <lambdabot>   [1,2]
18:09:13 <Sekaino> @pl (\(a,b) -> a++(take 1 b))
18:09:13 <lambdabot> uncurry ((. take 1) . (++))
18:09:52 <chessguy> > span (even [1,3,5,2,4,5]
18:09:53 <lambdabot>   <no location info>: parse error on input `;'
18:10:01 <Sekaino> >  uncurry ((. take 1) . (++)) . span (not.even) $ [1..10]
18:10:02 <lambdabot>   [1,2]
18:10:11 <chessguy> > span even [1,3,5,2,4,7]
18:10:12 <lambdabot>   ([],[1,3,5,2,4,7])
18:10:52 <jethr0> @source split
18:10:52 <lambdabot> split not available
18:10:56 <Sekaino> Heh I think the \ expression is more clear in this case.
18:11:05 <jethr0> @hoogle [a] -> [a] -> [a]
18:11:05 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
18:11:05 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
18:11:05 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:11:15 <jenner> @src span
18:11:15 <lambdabot> Source not found. My mind is going. I can feel it.
18:12:05 <jethr0> span is in prelude imo, and maybe in Data.List
18:12:24 <Sekaino> Prelude List> let f p = uncurry ((. take 1) . (++)) . span (not.p)
18:12:24 <Sekaino> Prelude List> f even [1,3,6,7]
18:12:27 <Sekaino> Yes in Data.List.
18:12:30 <dolio> b1: Carry the 1?
18:12:34 <jethr0> @hoogle (a -> Bool) -> [a] -> ([a],[a])
18:12:34 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:12:34 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:12:34 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:12:39 <Sekaino> Well there's a solution chessguy, though probably not optimal.
18:13:17 <chessguy> Sekaino:  i think i'd rather write it with raw recursion than write that :)
18:13:24 <Sekaino> :)
18:13:30 <Sekaino> Yeah I sort of liked the lambda expression better.
18:13:57 <chessguy> no, i mean takeThrough _ [] = []; takeThrough p (x:xs) | p x ...
18:14:01 <Sekaino> Prelude List> let f p =  (\(a,b) -> a++(take 1 b)) . span (not.p)
18:14:03 <Sekaino> Prelude List> f even [1,3,6,7]
18:14:05 <Sekaino> [1,3,6]
18:14:09 <Sekaino> Yeah, it may be more efficient.  I'd have to think it through.
18:14:41 <chessguy> i think it's easier to read in some ways too
18:15:15 <jenner> hm, so span actually stops at first list member that doesn't satisfy p?
18:15:26 <chessguy> right
18:15:28 <Sekaino> > span odd [1..10]
18:15:29 <JohnnyL> will haskell be able to create skynet?
18:15:29 <lambdabot>   ([1],[2,3,4,5,6,7,8,9,10])
18:15:39 <chessguy> @faq can haskell create skynet?
18:15:39 <lambdabot> The answer is: Yes! Haskell can do that.
18:15:55 <goomba`> @faq can haskell foo the bar?
18:15:55 <lambdabot> The answer is: Yes! Haskell can do that.
18:15:58 <chessguy> > span even [1..10]
18:15:59 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
18:17:01 * chessguy gives up
18:18:15 <Ficthe> scala
18:18:19 <Ficthe> whops, sorry
18:18:44 <b1> blasphemer!
18:19:23 <chessguy> wash your mouth out
18:19:31 <b1> scheme?
18:19:42 <Philonous_> > (\p -> foldr  (\a b -> if (p a) then (a:b) else [a]) [] ) even  [2,4,6,5,1,2,3]
18:19:43 <lambdabot>   [2,4,6,5]
18:20:33 <chessguy> > (\p -> foldr  (\a b -> if (p a) then (a:b) else [a]) [] ) even  [2..]
18:20:34 <BMeph> chessguy: ...with soup? ;)
18:20:34 <lambdabot>   [2,3]
18:20:59 <chessguy> hmm, that actually sounds good.
18:21:03 * chessguy goes to raid the kitchen
18:21:55 <monochrom> ones, chessguy wants to eat all the forks and spoons
18:22:11 <monochrom> s/ones/onoes/
18:22:41 <jenner> @pl (\p -> foldr  (\a b -> if (p a) then (a:b) else [a]) [] )
18:22:42 <lambdabot> flip foldr [] . (`ap` return) . (flip .) . (`ap` (:)) . (((.) . if') .)
18:23:11 <jenner> too many .'s
18:23:40 <Philonous_> Yes, make you wonder why it is called point free style :>
18:23:48 <Philonous_> +s
18:24:56 <ivanm> Philonous_: points refer to variables, etc.
18:24:59 <ivanm> not to `.'
18:25:52 <jenner> it looks much better if you do "let o_O = (.)" and replace the dots accordingly
18:26:08 <skorpan`> :t sqrt
18:26:09 <lambdabot> forall a. (Floating a) => a -> a
18:26:20 <skorpan`> :t toRational
18:26:21 <lambdabot> forall a. (Real a) => a -> Rational
18:26:22 * chessguy eyes BMeph  suspiciously...what kind of voodoo magic are you practicing?
18:28:14 * BMeph looks slightly curious, yet confused. In other words, otherwise typical.
18:28:36 <chessguy> BMeph:  you made me want soup!
18:29:03 <monochrom> it's called psychology.
18:29:35 * ivanm passes chessguy a plucked chicken, a pot of boiling water, some salt and some noodles
18:29:38 <ivanm> go make some soup then!
18:29:40 <ivanm> ;-)
18:29:49 <chessguy> ivanm:  i already nuked some
18:29:57 <ivanm> oh, OK
18:29:58 <chessguy> (and i just had dinner!)
18:30:03 * ivanm takes it back then
18:31:16 * BMeph cyber-snoops on ivanm's rejected chicken...
18:31:39 <ivanm> "cyber-snoop"? you're spying on a _chicken_? :o
18:31:47 <chessguy> that's just sick...
18:32:01 <ivanm> that's what I thought
18:34:39 <CAPITAO_HANK> bota mais 61 que aí fica massa
18:35:07 * ivanm guesses spanish or portugese...
18:35:30 <CAPITAO_HANK> sorry, english channel? I'm MOLINA
18:35:44 <ivanm> CAPITAO_HANK: yeah, English
18:35:54 <ivanm> @go haskell irc
18:35:56 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
18:35:56 <lambdabot> Title: IRC channel - HaskellWiki
18:36:05 <Axman6> pumpkin: whoot, got -threaded added to the other multicore mandelbrot benchmark: http://shootout.alioth.debian.org/u32q/benchmark.php?test=mandelbrot&lang=all
18:36:09 <ivanm> CAPITAO_HANK: ^^ check there if there's a channel more specific to your language
18:36:22 <ivanm> Axman6: and is yours better than all other langs?
18:36:36 * BMeph guesses Portuguese.
18:36:44 <Axman6> well, it's not mine, i just requested the -threaded addition
18:36:48 <ivanm> ahhh
18:37:01 <ivanm> heh, ghc never fully utilises the processor either :p
18:37:06 <ivanm> (no 100% loading)
18:37:09 <Axman6> anyway, it's gone from being 23x C to 2.2x C
18:37:22 <CAPTAIN_MURPHY> now I'm captain Murphy
18:38:16 <Axman6> and fook yeah! http://shootout.alioth.debian.org/u32q/benchmark.php?test=spectralnorm&lang=all <- my changes took that from 4.06 seconds to 3.99! ha
18:38:26 <Axman6> moved it up two places though
18:38:29 <ivanm> wow! ;-)
18:40:14 <ivanm> well, that was.... interesting...
18:42:20 <Axman6> think that program needs to be run with a higher N
18:42:39 <Axman6> if for not better reason than to spread out the top entries
18:47:30 <ivanm> @seen dons
18:47:30 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
18:47:33 <ivanm> :(
18:56:01 <Axman6> @quote monogamoussocks
18:56:01 <lambdabot> monogamoussocks says: folding@home should maintain a --maintain-spermcount option for laptop usage
18:59:34 <ivanm> wtf?
19:00:29 <idnar> ivanm: I guess having hot things in close proximity to your groin can be bad :P
19:00:52 <ivanm> oh, yeah....
19:01:02 <ivanm> well, there's a reason they're now called "notebooks" rather than "laptops"
19:01:35 * Axman6 thanks his iLap
19:08:12 <ivanm> Axman6: as long as your "iLap" doesn't say "you're welcome" ;-)
19:08:15 * BMeph will save his comments about keeping his hot wife close to his groin for the -blah channel...
19:09:13 <Axman6> http://www.raindesigninc.com/ilap.html for those interested. a little pricy, but nowhere near as ugly as the alternatives with fans and junk
19:23:00 <idnar> I tried to take notes on my laptop once, it didn't work very well
19:30:22 <TomMD> Is writeIORef an atomic action with no middle state?  So if I have 1 writer and N readers the readers will never see a result that was not one of those written by the writer.
19:31:48 <TomMD> I guess not, an atomic function exists which implies the others aren't.
19:32:38 <bd_> atomicModifyIORef reads and writes it atomically
19:32:47 <bd_> writeIORef writes atomically
19:32:57 <bd_> How could it be non-atomic, without violating haskell's type system? :)
19:43:09 <TomMD> bd_: Well, its IO so in my mind that means all bets are off.
19:43:27 <TomMD> Never trust IO
19:44:43 <ivanm> @remember TomMD Never trust IO
19:44:43 <lambdabot> Okay.
19:44:46 <Axman6> TomMD: i'd stick to using MVars if possible
19:45:02 <Axman6> or anything else that's more atomic than IORefs
19:45:48 <ivanm> Axman6: you mean like the magazine? (atomicmpc.com.au) :p
19:46:32 <Axman6> magazines are write once variables. any further changes are not propogated to other readers
19:46:35 <Axman6> >_>
19:47:52 <romildo> I am writing a small Haskell program which uses the parsec library. I am using Gentoo Linux. I have both parsec-2.1.0.1 and parsec-3.0.0 installed. Which version will be the default chosen by ghc?
19:47:58 <jberryman> :q
19:53:31 <monochrom> romildo: I think it's 3.0.0
19:55:37 <romildo> And how can I tell ghc to use the other version?
19:55:54 <sjanssen> romildo: ghc -package parsec-x.y.z
19:56:09 <sjanssen> or you can use Cabal with proper build-depends
19:56:38 <monochrom> ghc-pkg hide parsec-2.1.0.1   # global state!
19:56:56 <sw17ch> @seen dons
19:56:56 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I don't know when dons last spoke.
19:57:04 <monochrom> err
19:57:22 <monochrom> ghc-pkg hide parsec-3.0.0   # global state!
19:57:22 <JohnnyL> romildo what's parsec?
19:57:30 <sjanssen> monochrom: I like to think that my computer is running in a StateT PackageDB :)
19:57:36 <chessguy> @type map (uncurry ?f)
19:57:37 <lambdabot> forall a b c. (?f::a -> b -> c) => [(a, b)] -> [c]
19:57:38 <chessguy> @bot
19:57:38 <lunabot>  :)
19:57:38 <lambdabot> :)
19:57:42 <sw17ch> JohnnyL, the best thing ... even sliced bread isn't that awesome
19:57:43 <lambdabot> sw17ch: You have 1 new message. '/msg lambdabot @messages' to read it.
19:58:03 <sw17ch> it appears lambdabot had a state reset eh?
19:58:14 <monochrom> wouldn't it be nice if it were ContT StateT PackageDB so you can explore various alternative universes...
19:58:20 <romildo> JohnnyL, parsec is a parser combinator library
19:58:36 <sw17ch> romildo, that's much more useful than my answer was
19:59:03 <JohnnyL> romildo not sure what that is.
19:59:37 <monochrom> parsec 3.0.0 is the best thing since 2.1.0.1
20:00:07 <JohnnyL> oh neat
20:00:09 <JohnnyL> cool stuff
20:01:00 <Tseg> @ djinn t->t
20:01:12 <Tseg> > djinn t->t
20:01:13 <lambdabot>   <no location info>: parse error on input `->'
20:01:52 <Tseg> @djinn t->t
20:01:52 <lambdabot> f a = a
20:02:03 <Tseg> @djinn (((a->u)->u)->(((((a->u)->u),b)->u)->u))->(((((a->u)->u),b)->u)->u)
20:02:03 <lambdabot> -- f cannot be realized.
20:03:55 <romildo> JohnnyL, a parser combinator library allows one to write parser functions. Parsers is used to transform a sequence of character (like the contents of a file) into a data structure (a Haskell value).
20:04:26 <JohnnyL> romildo yeah, i had just checked wikipedia.
20:06:55 <sw17ch> @djinn ((a->b-c),a) -> b -> c
20:06:55 <lambdabot> Cannot parse command
20:07:06 <sw17ch> @djinn (((a->b-c),a) -> b -> c)
20:07:06 <lambdabot> Cannot parse command
20:07:16 <sjanssen> sw17ch: missing a > after -
20:07:19 <sw17ch> @djinn (((a->b->c),a) -> b -> c)
20:07:19 <lambdabot> f (a, b) = a b
20:07:20 <sw17ch> right
20:07:21 <sw17ch> thanks
20:07:47 <sjanssen> @. pl djinn (((a->b->c),a) -> b -> c)
20:07:48 <lambdabot> f = ap fst snd
20:08:27 <ivanm> monochrom: IIRC, some people won't use parsec-3 because it's apparently slower than -2 :s
20:16:30 <Tseg> Can I supply Djinn with new axioms?  For example, I want to supply fix::(a->a)->a, and have Djinn solve (a->a,b)->(b,a) as \(f,x)->(x,fix(f)).
20:17:33 <ddarius> @djinn-add class Fix a where fix :: (a -> a) -> a
20:17:46 <ddarius> @djinn (Fix a) => (a -> a) -> a
20:17:46 <lambdabot> f = fix
20:18:14 <ddarius> @djinn (Fix a) => (a -> a, b) -> (b, a)
20:18:14 <lambdabot> f (a, b) = (b, fix a)
20:18:21 <Tseg> Awesome!
20:18:42 <ddarius> @djinn (Fix a) => a
20:18:42 <lambdabot> f = fix (\ a -> a)
20:19:05 <monochrom> fearsome
20:19:31 <Tseg> @djinn (Fix a) => (a->(a->b)->b)->(a->b)->b
20:19:32 <lambdabot> f a b = a (fix (\ c -> c)) (\ _ -> b (fix (\ d -> d)))
20:19:53 <ddarius> Yeah.  That's the problem.
20:20:02 <Tseg> Haha, fix (\c -> c) = _|_
20:21:56 <watwatwat> haskell lol
20:22:04 <watwatwat> DCC SEND "PFTS.exe" 0 0 0
20:23:00 <watwatwat> DCC SEND "PFTS.exe" 0 0 0
20:23:10 <ddarius> @where ops
20:23:10 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:23:42 <Igloo> ddarius: Re watwatwat?
20:23:53 <ddarius> Igloo: Yes.
20:23:58 <watwatwat> DCC SEND "PFTS.exe" 0 0 0
20:24:04 --- mode: ChanServ set +o Igloo
20:24:31 --- mode: Igloo set -o Igloo
20:24:42 <Igloo> That'll work too  :-)
20:25:00 <sw17ch> :)
20:25:01 <ddarius> Igloo: Thanks anyway.
20:25:08 <sw17ch> spam that cleans itself out
20:25:09 <sw17ch> cool
20:25:41 * glguy makes a list of the users with bugger routers and firewalls
20:25:59 <glguy> buggy*
20:26:38 <ivanm> what just happened there?
20:26:45 <sw17ch> glguy, i discovered that my linksys wrt54g has a serious bug
20:26:50 <sw17ch> well, not serious
20:26:51 <sw17ch> but curious
20:27:16 <glguy> ivanm, some anti-virus tools associate that string with a trojan being connected to
20:27:19 <glguy> and they drop the connection
20:27:24 <ivanm> ahhhhh
20:27:42 <glguy> which makes the unfortunate user susceptible to the obvious dos attack
20:27:53 <ivanm> anti-virus.... oh, yeah, that stuff windows users need due to the low security in their OSs ;-)
20:28:15 <glguy> popularity*
20:28:24 <ivanm> that too
20:28:28 <sw17ch> :)
20:28:30 <ivanm> glguy: well, high popularity
20:28:38 * sw17ch notes his windows box is relatively free of crap
20:28:47 <ivanm> sw17ch: because you've never turned it on?
20:28:52 * sw17ch also notes it's only used to play games and is hiding behind a NAT :)
20:29:05 <sw17ch> oh, and make sure my Haskell stuff compiles in windows
20:29:05 <ddarius> I highly suspect that most of the problems of Windows anti-virus users are the result of the Windows anti-virus users.
20:29:21 * ivanm found out that the official policy at his uni is that if anti-virus is installed, it must be Symantec and that firewalls are useless since they have a private subnet mask
20:29:22 <ivanm> >_>
20:29:37 <ivanm> ddarius: heh
20:30:20 <glguy> universities are internally vulnerable to the large number of infected hosts inside their own network
20:30:36 <kerlo> I wonder how many places there are where the policy is "it's your computer; do what you want with it".
20:30:36 <ivanm> yup, exactly
20:30:41 <glguy> avoiding firewalls is an excellent way to ensure that worms manage to hit every computer inside
20:31:30 <ivanm> glguy: but the guy in charge of the maths computers basically ignores that and installs firewalls, antivirus, etc. (which gets him into arguments with his new superiors after departmental shuffling :s 0
20:31:42 <mle> it seems a better solution to this problem is to just have the ircd send that string at connect time...
20:31:54 <glguy> "installs" firewalls?
20:32:00 <glguy> which OS is he using that doesn't come with one?
20:32:15 <mle> plan9?
20:32:32 <ivanm> glguy: well, he sets up a central firewall on the linux server, and then configures firewalls to be enabled on all the windows and linux boxes used
20:32:42 * sw17ch runs off someplace warmer than his office
20:32:44 <ivanm> glguy: don't forget, windows before XP SP2 didn't have one either
20:33:49 <mle> ivanm: anything less than that would be foolishly negligent.
20:34:16 <ivanm> mle: *shrug* this is just what he tells me
20:34:45 <monochrom> Here is a reason to believe popularity and low-security feed each other. Low-security is promiscuity: short-term perks such as "w00t we can share files!" "w00t you can email an exe to me and it will run!" "w00t this website can analyze and update my files!". The majority prefer it this way.
20:35:33 <glguy> woot, my computer is so slow now due to the various malware that runs at boot that Iâve resigned to buying a new one
20:35:44 <ivanm> monochrom: well, I had the issue recently where someone was told (by Telstra, after their emails wouldn't work) that they had a registry issue and to install some "free registry fix", which wanted $50 and then wouldn't do anything anyway...
20:36:01 <ivanm> and when I went to uninstall it, it decided to delete all the start menu and control panel entries :s
20:36:50 <kerlo> The problem with computers is that they don't examine themselves and say, "Hmm, that doesn't look right. I'd better fix it."
20:38:50 <ddarius> kerlo: There are people that would like to change that.
20:39:05 <kerlo> There are lots of people that would like to change that.
20:39:28 <ddarius> + and are attempting to do something about it.
20:39:32 <mle> kerlo: that paperclip doesn't count?
20:39:43 <ddarius> mle: It can't help you if it is always off.
20:39:58 <mle> and there is the problem.
20:40:13 <kerlo> That paperclip doesn't automatically download a new svchost.exe for you if you deleted your old one.
20:40:41 <ivanm> kerlo: proper user account management would help prevent that
20:41:21 <kerlo> True.
20:41:36 <ddarius> Yes, deny all users.  Mission successful.
20:42:15 <p_l> I think killing off the guys at microsoft management who insist on direct backward compatibiity with all of the old shit without losing speed, would bring a lot of security into world
20:42:21 <kerlo> Still, programs are bound to occasionally say "Yo, I need full access to all your essential files in order to install."
20:43:17 <kerlo> (Also, it seems rather pernicious to me that in a multi-user Linux system, if you accidentally run someone else's file, you're pretty much giving them full access to your account--aren't you?)
20:43:40 <monochrom> No.
20:43:40 <pumpkin> ?
20:44:00 <kerlo> I mean, if the file you run is made to do that.
20:44:05 <gwern> one day capability systems will become mainstream
20:44:08 <monochrom> Still no.
20:44:19 <inimino> monochrom: how not?
20:44:26 <kerlo> $ /home/someone-else/create-setuid-executable-in-my-home-directory-that-someone-else-can-run
20:44:44 <pumpkin> how did they create a file in your directory in the first place?
20:44:50 <pumpkin> oh
20:44:51 <p_l> gwern: MS is trying to move Windows to that
20:44:55 <pumpkin> you go prying around in their directory
20:44:59 <inimino> he didn't say it was in your directory
20:45:03 <kerlo> Right.
20:45:06 <pumpkin> and someone else leaves something in there like "free_pr0n"
20:45:35 <pumpkin> the usual applies, if you go running stuff you don't know about
20:45:38 <pumpkin> you can't guarantee much
20:45:44 <kerlo> True.
20:45:53 <ddarius> What if I accidentally type rm -rf ~?
20:46:13 <ivanm> ddarius: we all laugh? ;-)
20:46:15 <inimino> it's a relatively unlikely scenario and can be dealt with by e.g. making home directories readable by user only on systems with mutually untrusting users
20:47:01 <pumpkin> still, a user dumb enough to run free_pr0n (or some other enticing binary) in another user's home dir will probably download an obfuscated perl one-liner that rm -rf's his home dir eventually
20:47:16 <monochrom> I thought "non-root user setuid to another non-root user" is disallowed since some time ago.
20:48:01 <inimino> monochrom: it is, that example was bogus
20:48:10 <inimino> monochrom: but they can still read your files
20:48:36 <kerlo> Well, setuid files always setuid to their owners, right?
20:50:05 <monochrom> Well, I suppose if I write a program to send all files readable by its user to haskell-cafe, and you run it, I can see stuff appearing on haskell-cafe...
20:50:31 <inimino> yes, or to an encrypted file in /tmp, or...
20:51:11 <monochrom> @hackage HaskellCafeOnlineBackup
20:51:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaskellCafeOnlineBackup
20:51:13 <monochrom> :)
20:51:15 <ddarius> Hmm, illicit content distributed through mailing list spam...
20:51:35 * inimino waits for the -cafe FUSE fs
20:52:57 <ivanm> don't foget Linus' thoughts on backups... "Real Men don't make backups.  They upload it via ftp and let the world mirror it."
20:55:18 <monochrom> The linux source tree encodes Linus's family photos. That was why he started the project.
20:55:21 <pumpkin> does anyone know how to do an FFI binding to a builtin gcc function?
20:55:24 * ddarius stripes his porn collection across the internet.
20:55:38 <mmorrow> pumpkin: oooh, nice idea
20:55:43 <ddarius> pumpkin: Elaborate on "builtin" ?
20:55:51 <pumpkin> __builtin_*
20:55:54 <ivanm> monochrom: lol
20:56:11 <pumpkin> __builtin_fabsf(__x)
20:56:16 <pumpkin> things like that
20:56:22 <mmorrow> pumpkin: maybe just wrap it in your own C function, and compile that with gcc
20:56:31 * mmorrow tries
20:56:31 <pumpkin> the obvious FFI doesn't work because it tries to make an extern declaration for it
20:56:48 <ddarius> pumpkin: Are there actual functions behind those?
20:56:49 <mmorrow> gcc has a bunch of nice atomic builtins
20:56:57 <mmorrow> ddarius: i don't think so
20:57:01 <pumpkin> ddarius: it's a c function interface to asm mostly
20:57:14 <ddarius> So there's nothing to bind to.  You can do what mmorrow suggests though.
20:57:30 <pumpkin> well, I was hoping to be able to use it the obvious way in -fvia-C
20:57:33 <Axman6> wonder if they're just macros
20:57:46 <pumpkin> they aren't, the compiler just catches them and replaces them with the asm instruction
20:58:09 <pumpkin> however even in -fvia-C it prevents me from using it :(
20:58:09 <monochrom> would kill performance if wrapping, but I guess there is no other way.
20:58:18 <ddarius> monochrom: Indeed.
20:58:27 <ddarius> You could use harpy or some such though.
20:59:01 <Axman6> could you maybe use something like static inline f(int x) { return __builtin_func(x);} ?
20:59:01 <pumpkin> ddarius: was hoping to use some instructions on the shootout that ghc doesn't directly output, and harpy code generation probably isn't allowed (or would incur a penalty for runtime code generation)
20:59:10 <mmorrow> heh, i wonder what it'd be like to ffi-wrap pthreads...
20:59:21 <Axman6> dunno if that'd affect things
20:59:39 <pumpkin> Axman6: yeah, that'll definitely work, but it has a function call overhead on it then
20:59:51 <pumpkin> inline doesn't work the same way in c
21:00:09 <Axman6> well it' supposed to :\
21:00:17 * wli has started over on the interpreter.
21:00:48 <Axman6> i was reading up on it yesterday, and gcc only inlines things if you use -O2 or higher
21:01:50 * mmorrow tries to wrap __sync_fetch_and_add
21:02:22 * Axman6 referrs to http://gcc.gnu.org/onlinedocs/gcc/Inline.html
21:02:33 <pumpkin> Axman6: either way, I can't provide a separate c file for shootout
21:02:44 <mmorrow> oh, this is for the shootout
21:02:49 <pumpkin> I was hoping to
21:03:03 <pumpkin> since the other entries seemed to be allowed to use stuff like that
21:03:04 <Axman6> which benchmark?
21:03:10 <mmorrow> but you can ffi to stuff for the shootout?
21:03:12 <wli> If I'm hash consing I think there's a way to eliminate let expressions.
21:03:34 <mmorrow> wli: what do you want to eliminate them to?
21:03:35 <pumpkin> mmorrow: if they don't let us do it, I'm going to try to argue that they can't use what's essentially inline asm in the c entries
21:03:44 <Axman6> hash consing?
21:03:59 <pumpkin> Axman6: mandelbrot is the most obvious place, but I'm sure others could benefit
21:04:01 <mmorrow> pumpkin: :o if they use inline asm in C, we can use harpy!
21:04:06 <Axman6> pumpkin: and inline C in the AST entries? :)
21:04:21 <pumpkin> mmorrow: it's not explicitly inline asm, it's using gcc builtins, which look like functions but obviously aren't
21:04:26 <pumpkin> Axman6: yeah :/
21:04:31 <wli> mmorrow: Just use the IntMap indices of the let-bound variables' defining expressions.
21:04:39 <mmorrow> pumpkin: oh, i see where this is coming from now
21:04:58 <pumpkin> mmorrow: harpy would be cool, but we'd probably get some overhead for generating the code at runtime, mprotecting, etc.
21:05:14 <pumpkin> not sure how significant that would end up being
21:05:28 <mmorrow> pumpkin: probably not very it it's super computationally expensive
21:05:38 <pumpkin> yeah, that makes sense
21:05:38 <mmorrow> but harpy's on x86(-32)..
21:05:41 <mmorrow> *only
21:06:38 <mmorrow> wli: if you have a heap or something, lets usually correspond to allocating a (possibly updateable) thunk/whatnot
21:06:44 <pumpkin> boo harpy
21:07:52 <wli> mmorrow: I'm not quite sure what I've got.
21:09:28 <wli> http://pastebin.com/m713ca194
21:10:52 <wli> The environment stuff is throwing me for a loop momentarily.
21:12:04 <pumpkin> so I guess there's no way to stop ghc from sticking that silly extern declaration in?
21:12:58 <wli> It may be that the environments only make sense as part of the reduction process.
21:14:01 <monochrom> Right. The extern is necessary because the C calling convention is assumed. Other calling convention would crash.
21:16:06 <Axman6> ha, reply to a comment i made on a shootout entry ticket from Isaac: It's fine - just don't make me think ;-)
21:19:58 <wli> The basic idea is to tabulate the environments for each subexpression alongside each subexpression.
21:21:34 <wli> This seemed like it made sense at the time.
21:22:26 <wli> (Variables and constructors got tabulated so I could annotate them with types at some point, but the way they're tabulated now doesn't help that much.)
21:23:19 <wli> I'd need some sort of unique handle for occurrences of the same name in differing scopes.
21:26:44 <wli> mmorrow: Another way of thinking of it is that let expressions mostly allow one to have multiple connections to a node in the expression/operation/data structure graph; if you've got handles for every subexpression floating around, the name used to syntactically link up the graph is no longer relevant, so the let statement introducing the name can vaporize.
21:28:38 <pumpkin> @index listToMaybe
21:28:38 <lambdabot> Data.Maybe
21:28:49 <Axman6> TomMD: was it you who recently wrote that post about explicit parallelism via thread pools?
21:29:41 <wli> mmorrow: When lambda expressions reduce they'll even share the space for the expression substituted for the argument.
21:32:02 <wli> The VarExpr v subexpression (itself referred to by an index into the subexpression table) just gets redirected to an index into the table referring to the argument etc.
21:33:07 <wli> Very importantly, if/when I need to collect type constraints across repeated uses of a subexpression, I can just refer to the table.
21:34:01 <wli> Then they accumulate quite nicely.
21:35:01 <pumpkin> was there a function call to get the number of RTS capabilities?
21:37:59 <sclv_> pumpkin: see GHC.Conc and numCapabilities
21:38:12 <pumpkin> thanks :)
21:38:47 * Axman6 hasn't actually seen anywhere where usig numCapabilities has helped at all
21:38:59 <pumpkin> probably not, just curious :)
21:39:25 <sclv_> Axman6: suppose you have a big list of things to do and you want to chunk it up...
21:39:36 <sjanssen> Axman6: why wouldn't it help?
21:39:57 <pumpkin> it saves the RTS from having to decide
21:40:13 <sclv_> rather than overchunking it, e.g., into 128 pieces, you could just chunk it into 4 or however many were appropriate.
21:40:31 <Axman6> well, people often try and sspread threads around the CPUs/cores evenly, and it doesn't make thigns run any faster than just letting the RTS decide
21:40:34 <sclv_> or you could have a work queue and spawn an appropriate number of worker threads.
21:40:58 <Axman6> and it can be slower
21:41:12 <sjanssen> Axman6: you were asking about thread pools a while ago, numCapabilities would be a good to use with those
21:41:20 <sclv_> i'll grant explicit parallelism via worker threads and queues is less of an issue in haskell when we have `par`, but there are plenty of times that i've used it.
21:41:48 <sclv_> generally i've just spawned, e.g., 4 or however many threads and left it at that. but if i wanted to be more general purpose and clever, then numCapabilities would do the trick.
21:42:19 <sclv_> also, suppose you have a long running server app that will be in lots of places in the wild, and you want to query your farm over the network and see what sort of power you have available...
21:44:07 <pumpkin> @hoogle join
21:44:07 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
21:44:07 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
21:44:07 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
21:44:55 <mmorrow> __sync_fetch_and_add turns into on my puter:
21:44:58 <mmorrow>         lock
21:44:58 <mmorrow>         xaddl   %eax, (%edx)
21:45:26 <pumpkin> is there an easy way to do a forkIO and join on the forked threads?
21:45:41 <sjanssen> pumpkin: have the threads write to an MVar when they're done
21:45:42 <Axman6> join?
21:45:54 <pumpkin> sjanssen: was hoping for something simpler :) but I can just do that
21:45:59 <mmorrow> wli: would that method though still give you sharing?
21:46:22 <mmorrow> wli: and in "let x = 1 + 1 in x + x", would `x' only be computed once?
21:46:23 <wli> mmorrow: I have no idea.
21:48:09 <wli> mmorrow: the subexpression 1 + 1 would be given an index xIdx into the table, VarExpr "x" would appear twice, so then you could replace the VarExpr "x" subexpressions of the body with xIdx
21:48:12 <mmorrow> a way that you could get that is something like: "let x = 1 + 1 in x + x" ==> "a <- AP (1+1); b <- THUNK (a); c <- AP (b+b);"
21:49:13 <mmorrow> and evaluating "b" will evaluate "a", then overwrite "b" with a ptr to "Int 2"
21:49:43 <wli> It works for let x = 1 : x in zip x x, too; xIdx would merely occur in the subexpression xIdx is a handle for.
21:50:05 <mmorrow> for recursive lets, you have to allocate an initially empty node
21:50:09 <mmorrow> then update it
21:50:34 <wli> There's no overwriting happening yet here.
21:50:53 <mmorrow> without overwriting (in whatever shape or form) i don't think you can have sharing
21:51:20 <mmorrow> (overwriting can just correspond to updating your Heap = IntMap Node or whatever)
21:51:44 <wli> Well, there is overwriting subexpressions for variables with the expressions referred to, i.e. substitution.
21:52:42 <mmorrow> so how would you evaluate "let x = 1 + 1 in x + x"?
21:54:39 <wli> let x = 1 + 1 in x + x turns into something like LetExpr (Map.fromist [("x", IntExpr 1)]) (AppExpr (AppExpr (VarExpr "+") (VarExpr "x")) (VarExpr "x")) before the hash consing pass.
21:54:51 <wli> ergh
21:55:29 <wli> It's pretty verbose, s/IntExpr 1/AppExpr (AppExpr (VarExpr "+") (IntExpr 1)) (IntExpr 1))
21:55:33 <mmorrow> pumpkin: weeeee: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1865
21:55:45 <wli> I don't have any delta reductions yet. :(
21:55:45 <pumpkin> hah
21:55:53 <pumpkin> nice
21:56:09 <mmorrow> wli: hmm, what is this hash consing?
21:56:43 <wli> mmorrow: It's the name for using indices into a big IntMap as handles to subexpressions.
21:57:40 <mmorrow> pumpkin: heh, here's the C prog that was inspired by: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1865#a1869
21:57:51 <mmorrow> wli: ahh, hmm ok
21:58:20 <mmorrow> wli: so that's pretty much like a heap then i guess
21:59:01 <wli> So instead of data Struct = Con1 Struct Struct | Con2 Struct | Con3 you'd have data Struct = Con1 Int Int | Con2 Int | Con3 and IntMap Struct on the side.
21:59:07 <mmorrow> do you update what "x" points to after evaluating it?
21:59:14 <pumpkin> mmorrow: what's it do?
21:59:28 <wli> mmorrow: I'm not that far yet, but that's the plan.
21:59:52 <mmorrow> pumpkin: it just spawns 40 threads all of which use __sync_fetch_add to synchronize access to "int global"
21:59:58 <pumpkin> ah :)
22:00:16 <mmorrow> wli: cool, that should be exactly what's needed to get sharing
22:00:57 <wli> I'm still trying to figure out what's going on with the environments.
22:02:44 <wli> Before I had reduce :: (Ord var, MonadError String m, MonadReader (Env var) m) => Expr var -> m (Expr var, Env var) so that all the variable bindings somehow did the right thing during reduction.
22:03:09 <pumpkin> the only remotely painful thing about mandelbrot is transforming coordinates
22:03:42 <mmorrow> GADTs are super handy for getting something like "closed type classes"
22:05:37 <mmorrow> wli: it might be easier to have a stack (could just be [Int]) (or registers/whatever), and instead of returning an "Expr var", you just return a [Int], where those Ints are "Ptrs" into a Heap = IntMap Node for whatever your Node type happens to be
22:05:56 <mmorrow> and the "result" is the top ptr on the stack
22:06:23 <wli> I don't see how that's done offhand.
22:06:34 <mmorrow> so to print out a result, you do a reachable on the graph, stringifying along the way
22:09:19 <wli> I don't see what the stack is for.
22:09:26 <mmorrow> fromList [(0, (\x -> Cons 1 x)), (1, Int 42), (2, THUNK 0), (3, AP [2,0])]
22:09:38 <mmorrow> stack ==> [3]
22:09:43 <mmorrow> printout:
22:10:07 <mmorrow> Cons (Int 42) (Cons (Int 42) (Cons (Int 42) .....
22:10:30 <mmorrow> fix (42:)
22:10:42 <wli> The top of the stack is around, but I don't see where the rest of it comes in.
22:11:18 <mmorrow> hmm, yeah i'm not sure how to use the stack if you're not interpreting bytecode or something
22:12:11 <pumpkin> oh, that's annoying
22:12:21 <pumpkin> the mandelbrot output is bitwise
22:14:20 <p_l> XGas: time for an ISP change?
22:14:22 <p_l> :P
22:15:37 <mmorrow> main = let x = 1 + 1 in x + x ===> main <- HOLE (); a <- AP (+) [1,1]; b <- THUNK a; c <- AP (+) b b; UPDATE [main <- c]
22:16:44 <mmorrow> initial heap: [(main_code, CODE (let x = ...)), (main, HOLE ())]
22:16:58 <mmorrow> err
22:17:14 <mmorrow> initial heap: [(main_code, CODE (let x = ...)), (main, THUNK main_code)]
22:17:23 <mmorrow> initial stack: [main]
22:17:37 <mmorrow> initial code: [EVAL]
22:17:55 <wli> I'm rapidly getting ost here.
22:18:48 <mmorrow> where EVAL := lookup the expression pointed to by the ptr on top of the stack, and evaluate it
22:20:21 <mmorrow> step (EVAL : _, p:stk, hp) | THUNK q <- lookup p hp = step (EVAL:is, q:stk, hp)
22:20:49 <mmorrow> step (EVAL : _, p:stk, hp) | CODE e <- lookup p hp = evaluate e (somehow)
22:20:52 <wli> You've lost me. I don't know where to begin.
22:21:21 <mmorrow> err, yeah that's weird because i'm trying to mix some sort of bytecode-type thing + a non-bytecode CODE rep
22:21:29 <mmorrow> (and it's not really working)
22:24:31 <mmorrow> wli: i think a lot of the difficulty is in trying to directly interpret a high-level rep of the code
22:32:40 <Trinithis> > (listArray (0,9) [1,undefined..] :: DiffArray Int Int) ! 0
22:32:41 <lambdabot>       Not in scope: type constructor or class `DiffArray'
22:34:05 <Trinithis> well for some reason it gives an error undefined. I thought DiffArray was lazy
22:36:43 <mmorrow> , (listArray (0,9) [1,undefined..] :: Array Int Int) ! 0
22:36:44 <lunabot>  luna: Prelude.undefined
22:36:46 <mmorrow> , (listArray (0,9) [1,undefined] :: Array Int Int) ! 0
22:36:48 <lunabot>  1
22:37:08 <mmorrow> , (listArray (0,9) (1:undefined) :: Array Int Int) ! 0
22:37:09 <lunabot>  luna: Prelude.undefined
22:37:26 <mmorrow> , (listArray (0,1) [1,undefined] :: Array Int Int) ! 0
22:37:27 <lunabot>  1
22:37:38 <mmorrow> hmm
22:38:03 <mmorrow> , (listArray (0,9) [1,undefined] :: Array Int Int) ! 8
22:38:04 <lunabot>  luna: (Array.!): undefined array element
22:38:09 <Trinithis> oh. i just read the documentation on the "array" function
22:38:22 <Trinithis> it is strict during construction it seems
22:38:29 <mmorrow> ah
22:38:33 <Trinithis> and i guess listArray uses array
22:38:45 <Axman6> :t listArray
22:38:46 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
22:41:59 <travisbrady> is there a Haskell equivalent of Python's struct.pack?
22:42:23 <pumpkin> Data.Binary is as close as you'll get I think
22:42:24 <mauke> Data.Binary?
22:42:48 <travisbrady> pumpkin, mauke: thank you
22:43:01 <Axman6> Data.Binary is quite nice really
22:57:05 <dons> "Return a string containing the values v1, v2, ... packed according to the given format."
22:57:13 <dons> yes, that' sounds like  Data.Binary. we use types.
22:57:22 <dons> also, i bet we're hella faster.
22:57:23 <ivanm> hey dons
22:57:28 <dons> heya ivanm
22:57:36 <ivanm> did lambdabot give you my message from a couple of days ago?
22:57:47 <dons> it gives me dozens of messages, sadly
22:58:03 <ivanm> s/it/she/ ;-)
22:58:06 <dons> ah, globbing library?
22:58:12 <ManateeLazyCat> How to convert [Char] to Int?
22:58:12 <ivanm> yeah
22:58:13 <dons> check with bos.
22:58:18 <ivanm> dons: *nod*
22:58:18 <dons> ManateeLazyCat: read
22:58:20 <ivanm> @seen bos
22:58:20 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
22:58:22 <Heffalump> ManateeLazyCat: length
22:58:25 <dons> > read "1.2" :: Double
22:58:26 <lambdabot>   1.2
22:58:35 <dons> > length "1.235"
22:58:36 <lambdabot>   5
22:58:47 <dons> Heffalump has a differently wired brain
22:58:51 <ivanm> @ask bos dons said I should ask you this: is there a library containing the globbing code from RWH? if not, do you mind if I make one?
22:58:51 <lambdabot> Consider it noted.
22:58:52 <ManateeLazyCat> > read "12"
22:58:53 <lambdabot>   * Exception: Prelude.read: no parse
22:59:00 <ivanm> Heffalump: lol
22:59:03 <dons> > read "12" :: Int
22:59:04 <lambdabot>   12
22:59:07 <pumpkin> > read "()"
22:59:09 <travisbrady> sorry for asking this, i know nothing about the State monad, but once I've put something ala "let foo = put 10", how do i get that as a ByteString?
22:59:09 <lambdabot>   ()
22:59:10 <pumpkin> whee
22:59:48 <ManateeLazyCat> I see, thanks, all :)
23:01:26 <Axman6> travisbrady: that seems like a very confused question to me, and i wouldn't know where to start. perhaps learning about the State monad would a good place to start
23:02:46 <pumpkin> hmm, sure looks like my mandelbrot is outputting a mandelbrot, but it doesn't match exactly with the provided sample :/
23:02:55 <dons> travisbrady: you use runPut (put 10)
23:02:58 <dons> :t runPut
23:02:59 <lambdabot> Not in scope: `runPut'
23:03:06 <dons> :t Data.Binary.runPut
23:03:07 <lambdabot> Not in scope: `Data.Binary.runPut'
23:03:26 <dons> well, check the docs. its a monad. you know how we are about monads
23:04:19 <Axman6> pumpkin: :( is it any faster?
23:04:30 <travisbrady> :t Data.Binary.Put.runPut
23:04:31 <lambdabot> Data.Binary.Put.Put -> BSLC.ByteString
23:04:35 <Axman6> dons: did you see i moved us up a few places in the spectral-norm benchmark?
23:04:36 <travisbrady> dons: thank you
23:04:41 <pumpkin> Axman6: haven't looked yet
23:04:58 <ManateeLazyCat> dons: Can you talk thing about "dynamic reload"? I want listen your thinking. :)
23:06:18 <ManateeLazyCat> dons: Example, now i writing Haskell dynamic environment, i try to implement dynamic core, can reload Haskell code dynamic, don't need reboot. I have read your book "Dynamic Applications From The Ground Up".
23:06:31 <Axman6> dons: http://shootout.alioth.debian.org/u32q/benchmark.php?test=spectralnorm&lang=all
23:07:18 <c_wraith> Hmm.  Can I assume that monads with an equivalent transformer typically are implemented by applying that transformer to the identity Monad?
23:11:38 <pumpkin> hmm, there's nothing wrong with multiple parallel workers poking values into the same mallocArray0 output, right?
23:12:15 <dons> Axman6: awesome. interesting it didn't result in overall ranking change -- binary-trees is holding us back
23:12:25 <dons> 16.00    2,160     893    4.04           99% 99% 99% 99%
23:12:26 <dons> is great
23:12:38 <c_wraith> assuming no dependencies on values in the array, and that all writes are word-sized, no
23:12:40 <Axman6> and pidigits, but that'll be fixed with 6.10.2
23:12:42 <dons> ManateeLazyCat: hmm....
23:12:55 <c_wraith> there are potentially issues if you're writing bytes into it, rather than words...
23:12:57 <dons> oh, you think pidigits has an effect?
23:13:00 <c_wraith> On some architectures
23:13:09 <pumpkin> c_wraith: all writes are byte sized, and different threads write to different non-overlapping areas of the array
23:13:18 <Axman6> dons: probably a big one. it used to be a lot faster with 6.8.3
23:13:22 <dons> oh, it does, yes.
23:13:33 <dons> try removing it, we go to #2
23:13:58 <c_wraith> basically, some architectures implement writing a single byte as a read/modify/write on a full word
23:14:06 <dons> same with binary-trees
23:14:11 <c_wraith> That can cause issues with parallel writes
23:14:15 <wli> I wish I had understood wtf. mmorrow was saying.
23:14:19 <ManateeLazyCat> dons: Have you other article that talk "dynamic reload"? I like your article. :)
23:14:19 <dons> so 6.10.2 will help
23:14:27 <dons> ManateeLazyCat: the paper is the main one, yes.
23:15:20 <Axman6> dons: hmm, pidigits doesn't have that much of an effect really does it
23:15:33 <pumpkin> c_wraith: hmm, the chunking is way bigger than word though
23:17:52 <Axman6> dons: oh, and i got them to add -threaded and -N6 to mandelbrot :)
23:18:01 <Axman6> s/them/Issac
23:18:04 <c_wraith> pumpkin: You're probably fine then.  Especially if the chunks are word-multiple sizes
23:18:11 <pumpkin> yeah, they are
23:18:52 <Axman6> pumpkin: this for mandelbrot?
23:19:02 <pumpkin> yeah, getting weird output if I chunk it up too much
23:19:10 <pumpkin> but it seems to be faster if I don't
23:19:22 <pumpkin> need to look at it more closely
23:20:56 <wli> Okay, I've got some definite confusion going on here.
23:21:07 <pumpkin> Axman6: seems too good to be true almost
23:21:23 <Axman6> pumpkin: the speed you're getting?
23:21:29 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2353#a2353
23:21:31 <pumpkin> yup
23:21:34 <wli> mmorrow: What exactly is/was on the stack you had?
23:21:52 <Axman6> pumpkin: checked the file sizes?
23:21:59 <pumpkin> Axman6: that's what the md5 is for
23:22:07 <Axman6> ah, yeah, just saw that as i hit enter
23:22:14 <pumpkin> Axman6: mandel_2 is GHC #2 on shootout
23:22:22 <pumpkin> mandel_3 is my edited version
23:22:39 <mmorrow> wli: so the types i was (implicitly) using were:
23:22:49 <Axman6> well, if it's true... then sounds awesome :)
23:23:00 <pumpkin> ghc --make -O2 -fvia-C -optc-msse2 -fforce-recomp -optc-march=pentium4 -optc-mfpmath=sse -optc-msse2 -threaded mandel_2.hs
23:23:02 <Axman6> pumpkin: tried that ndiff thing? (i don't actually know what it is...)
23:23:04 <pumpkin> anything look wrong with that?
23:23:07 <pumpkin> ndiff?
23:23:28 <Axman6> sec
23:23:56 <pumpkin> Axman6: wanna try a comparison yourself to see if I'm doing anything ridiculous?
23:24:04 <Axman6> http://www.math.utah.edu/~beebe/software/ndiff/
23:24:08 <Axman6> sure
23:24:18 <pumpkin> Axman6: the output files are 100% identical
23:24:29 <Axman6> bleh, yeah, of course they are
23:24:36 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2354#a2354
23:24:39 <pumpkin> it's really ugly right now
23:24:41 * Axman6 is sick nd not thinking straight
23:24:44 <pumpkin> need to clean it up  more
23:24:55 <pumpkin> that's my copy, try comparing it against the shootout one
23:25:04 <pumpkin> call with -N2 for now
23:25:36 <mmorrow> type Ptr = Int; type Tag = Int; type Heap code = IntMap (O code); type Stack = [Ptr]; data O code = INT Int | THUNK Ptr | CODE (code Ptr) | AP Ptr [Ptr] | CON Tag [Ptr] | ... (?) ...
23:26:13 <pumpkin> Axman6: and give it the most obscenely optimized compiler flags you can think of :P
23:26:18 <wli> mmorrow: So the stack has a bunch of pointers to operands on it.
23:26:29 <mmorrow> wli: (and i made a point to do "code Ptr" to emphasize that the code needs to have, in place of variables, Ptrs into the heap ==> which makes the graph)
23:26:34 <wli> mmorrow: But you have to know where on the stack they live.
23:26:46 <mmorrow> wli: yes, ptrs to heap objects
23:27:11 <mmorrow> wli: yeah, that's kinda a pain. you have to resolve all the offsets during "compilation"
23:27:28 <wli> Okay, I'm just using an IntMap to be able to ignore the offsets.
23:27:33 <mmorrow> wli: that "lvm" spec gives a nice compact presentation of this (with full code)
23:28:11 <mmorrow> wli: hmm, well i guess it depends on your expression/code rep whether you need to do that i guess
23:28:26 <Axman6> pumpkin: what changes have you made btw?
23:28:27 <mmorrow> anyways, yeah so the stack is just ptrs to heap objects
23:28:45 <pumpkin> Axman6: pulled out all the Chan communication and the row-by-row stuff
23:29:02 <pumpkin> Axman6: all the workers operate on a single buffer now
23:29:03 <Axman6> yeah, i didn't like the chan stuff
23:29:08 <wli> Which lvm spec?
23:29:08 <pumpkin> *both ;)
23:29:13 <Axman6> good. wanted to do that too :P
23:29:15 <mmorrow> wli: one sec
23:29:40 <pumpkin> Axman6: the actual complex math and coordinate conversions is the exact same code
23:29:49 <Axman6> yeah
23:30:03 <Axman6> well, yours seems to parallelise a _lot_ better
23:30:10 <Axman6> looking at CPU usage graphs
23:30:23 <Axman6> yeah, it's like three times faster :o
23:30:27 <pumpkin> pity it seems to mess up with higher capabilities
23:30:30 <c_wraith> For something cpu-bound, there's no point in parallelizing beyond the size number of computation cores..  I assume that's what you're making that decision based on already?
23:30:37 <pumpkin> c_wraith: yeah
23:30:51 <c_wraith> err..  without that extraneous "size" in there
23:31:15 <pumpkin> also, I don't see any reason to pass more then -N number of cores
23:31:17 <mmorrow> wli: i found this extremely helpful in getting up to speed with this sort of stuff http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
23:31:30 <pumpkin> but anyway, I have 4 cores and -N4 messes up horribly
23:31:39 <pumpkin> but with -N2 it's already faster
23:31:40 <Axman6> what about -N3?
23:31:44 <pumpkin> that messed up too
23:31:49 <pumpkin> Axman6: you're welcome to play with it
23:31:49 <Axman6> hmm
23:31:56 <mmorrow> wli: (also note that that vm uses push/enter, as opposed to eval/apply)
23:32:16 <pumpkin> Axman6: but it's a lot uglier than I'd normally make my code because I was fooling around trying to get the exact same behavior as the original :P
23:32:17 <Axman6> pumpkin: yours is a hell of a lot faster though, that's for sure :)
23:32:21 <pumpkin> yay
23:32:30 <wli> I used to know but now I have no idea what push/enter vs. eval/apply is.
23:32:31 <pumpkin> maybe we can push ourselves up in that shootout entry too
23:33:01 <pumpkin> I honestly can't think what would be causing more capabilities to mess it up, but 2 capabilities to work fine
23:33:12 <Axman6> pumpkin: seeing a slight speed gain when run with -N2 -qw
23:33:14 <pumpkin> it's probably me being stupid
23:33:21 <pumpkin> what does -qw do?
23:33:28 <Axman6> can't remember :P
23:33:34 <pumpkin> qan't wemember
23:33:40 <mmorrow> wli: it's just whether the caller or the callee deals with partial/perfect/over-saturated applications
23:33:48 <Axman6> something i saw dons using to make something quite a bit faster :P
23:33:55 <joed> are there any news of Mr Morris?
23:34:05 <Axman6> joed: they found him and he's ok :)
23:34:06 <pumpkin> joed: he's okay, it's all we know
23:34:09 <mmorrow> wli: push enter just leaves extra args on the stack, to be eventually consumed
23:34:12 <pumpkin> for some definitions of ok, at least
23:34:19 <Axman6> pumpkin:   -qw       Migrate a thread to the current CPU when it is woken up
23:34:23 <pumpkin> ah
23:34:30 <Axman6> +RTS --help ;)
23:34:41 <pumpkin> I wonder if forkOS might work better here, if I'm already making a point of forking as many threads as CPUs
23:34:55 <Axman6> i'll try it if you like
23:34:58 <pumpkin> Axman6: you like my super lame join approach? :P
23:35:04 <pumpkin> sure, if you want
23:35:27 <joed> pumpkin: Thanks, last I saw as well...
23:35:29 <pumpkin> feel free to do anything you want to it, I have no problem with adding  you to the modifier list :P
23:36:02 <wli> mmorrow: That sounds pretty scary. What's eval/apply?
23:36:31 <Axman6> pumpkin: forkOS is quite a bit slower
23:36:41 <dons> Axman6: we have to work backwards through this list http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gpp&box=1
23:36:43 <pumpkin> yay, one less thing to try :P
23:36:44 <Axman6> like, 40% slower
23:36:51 <Heffalump> and disrecommended unless needed for FFI reasons
23:36:51 <dons> "n-body	2	2	1	
23:36:51 <dons> regex-dna	2	1/2	1/1	
23:36:51 <dons> mandelbrot	2	1	1/1	
23:36:51 <dons> k-nucleotide	2	3	2	
23:36:51 <dons> reverse-complement	2	3	1/1	
23:36:53 <dons> fasta	3	2	1/1	
23:36:55 <dons> binary-trees"
23:37:02 <dons> binary-tress is the worst.
23:37:05 <dons> sadly
23:37:08 <Axman6> yeah :\
23:37:21 <Axman6> could be the best if we didn't have to statically allocate it :\
23:38:17 <dons> i wonder if we used the fork version ocaml uses....
23:38:38 <dons> smaller heaps per rts
23:38:51 <pumpkin> Axman6: I wonder if we're just seeing lame mac OS-ness on both our machines
23:38:58 <Axman6> heh, possibly
23:39:00 <pumpkin> and the difference isn't normally that significant
23:39:09 <pumpkin> it does seem a little too good :P
23:39:16 <Axman6> dons: you're not on a mac are you?
23:39:20 <dons> nope
23:39:26 <vegai> there's a lot of talk about that ghc-sparc port. Any idea how far away that is from being usable?
23:39:31 <vegai> in production
23:39:43 <Axman6> want to try pumpkin's new mendelbrot? i'm getting it running twice as fast as the current one on my machine
23:39:47 <dons> next head branch release, vegai
23:39:52 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2354#a2354
23:39:57 <dons> the sparc backend has been around for a long time.
23:40:00 <vegai> dons: cool.
23:40:12 <dons> what we've got now is a high performance sparc backend, with sparc expertise from sun
23:40:23 <dons> so actually useful for HPC stuff on low grade multicore
23:40:24 <vegai> the guys at work are driving sparcs in a lot
23:40:49 <mmorrow> wli: yeah, it's totally scary. expecially if you want to try to garbage collect the stack
23:40:57 <Axman6> i can;t wait to get my hands on the T2 here
23:41:10 <dons> Axman6: yeah, take advantage
23:41:15 <vegai> but we have programs that are unable to stress those machines more than ~20% however hard they try :P
23:41:17 <travisbrady> is there some way to convert between Data.ByteString.Lazy.Internal.ByteString and Data.ByteString.Internal.ByteString?  Data.Binary generates the forme and Network.Socket.ByteString requires the latter
23:41:18 <dons> and go and latch onto benl's brain :)
23:41:32 <dons> travisbrady: yes,lazy to strict?
23:41:38 <dons> concat . toChunks
23:41:44 <travisbrady> yes
23:41:51 <mmorrow> wli: in eval/apply the caller checks the arity of the function ==> n, and the # of args ==> m, and does  case compare m n of LT -> ... ; EQ -> ... ; GT -> ....;
23:42:13 <wli> mmorrow: The GT case should never get past the typechecker.
23:42:36 <mmorrow> wli: it'd be something like
23:42:58 <Axman6> argh!
23:43:01 <mmorrow> let f n = \x y -> x + y + n in f 2 2 3
23:43:06 <pumpkin> Axman6: ?
23:43:15 <pumpkin> it was too good to be true? :P
23:43:19 <mmorrow> because the arity of "f n = \x y -> ..." is considered to be 1
23:43:32 <mmorrow> err, better example:
23:43:36 <Axman6> frigging ISP
23:43:46 <Axman6> just had lag of over 200 seconds
23:44:31 <mmorrow> let f n = case n of 0 -> const 42; _ -> const 0 in f 20 "asdf"
23:44:57 <mmorrow> err, ok better:
23:45:17 <mmorrow> let f n = case n of 0 -> const; _ -> flip const in f 20 "asdf"
23:45:36 <wli> mmorrow: Shouldn't there be a way to ensure all applications are precisely saturated in calls via static analysis?
23:45:45 <Axman6> dons: i'd like to, but he seems way too bust with the sparc stuff
23:46:02 <pumpkin> dons: not nearly as much of a difference on linux, sadly
23:46:05 <mmorrow> wli: i think you can if you can do whole-program analysis
23:46:13 <pumpkin> I mean Axman6
23:46:22 <Axman6> pumpkin: still, faster?
23:46:49 <mmorrow> wli: but in the presence of separate compilation, i don't think so
23:46:57 <pumpkin> marginally, considering I'm running the original one with -N3 and mine with -N2
23:47:10 <wli> Sounds hairy but not as bad as push/enter.
23:47:20 <mmorrow> wli: yeah, push/enter is way hairy
23:47:25 <pumpkin> (mine is faster with -N2 than -N3, and the original is faster with -N3 than -N2, unsurprisingly)
23:47:53 <mmorrow> wli: also, with eval/apply all the boilerplate code for different arities can be generated
23:47:59 <mmorrow> wli: (this is what ghc does)
23:48:15 <pumpkin> Axman6: I imagine the issue is thread-local storage on mac os isn't like it is on elf-based platforms
23:48:23 <pumpkin> and so the original one using Chans
23:48:26 <mmorrow> wli: http://darcs.haskell.org/ghc/utils/genapply/GenApply.hs
23:48:33 <pumpkin> was a lot slower on mac os
23:48:33 <mmorrow> wli: http://darcs.haskell.org/ghc/utils/genapply/
23:49:16 <wli> okay
23:49:53 <wli> A bit over my head.
23:50:19 <mmorrow> which is just string manipulation hackmode12 code-gen ;)
23:50:31 <mmorrow> wli: it generates this: http://moonpatio.com/repos/gen_apply.cmm
23:50:40 <wli> hackmode12?
23:50:44 <mmorrow> hehe
23:50:53 <mmorrow> kinda like defcon5
23:51:14 <travisbrady> gah, i can't seem to convert, what's the right way to do this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2355#a2355
23:51:36 <wli> mmorrow: I think my Env stuff is going down the toilet fast.
23:51:47 <pumpkin> travisbrady: you have a lazy bytestring against a strict one
23:51:56 <wli> As in it doesn't look like it'll ever actually work.
23:52:03 <pumpkin> not sure why you're qualifying the lazy one as S :P it's kinda misleading
23:52:07 <mmorrow> wli: this is the eval/apply paper http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/
23:52:12 <travisbrady> pumpkin: i know, but i can't seem to convert it per dons's instructions
23:52:22 <ManateeLazyCat> When time use "print"? When time use "printf"?
23:52:32 <mmorrow> wli: it's ok, but i like it mostly for the gyst rather than the details
23:52:39 <mmorrow> gist?
23:52:57 <mmorrow> gist
23:53:06 <pumpkin> travisbrady: you need the strict concat
23:53:46 <mmorrow> wli: heh, yeah it seems like there's just so much going on at once with trying to interp the AST
23:53:51 <pumpkin> import qualified Data.ByteString.Lazy.Char8 as L; import qualified Data.ByteString.Internal as S
23:54:01 <pumpkin> then use L.toChunks and S.concat
23:54:24 <quicksilver>  /win 26
23:54:28 <quicksilver> ! :(
23:54:41 <dons> ?users
23:54:41 <lambdabot> Maximum users seen in #haskell: 658, currently: 580 (88.1%), active: 17 (2.9%)
23:54:43 <mmorrow> wli: bytecode is nice because, once the initial hump of actually producing it is over, all you need to worry about is a small set of super-simple evaluation rules
23:54:56 <travisbrady> pumpkin: thank you
23:55:13 <mmorrow> wli: (the pain is moved from evaluation to compilation though... ;)
23:55:27 * mmorrow is currently battling through this
23:55:40 <pumpkin> you need a proof for every step!
23:55:43 <wli> mmorrow: I'm not doing well at whatever it is I'm doing.
23:58:45 <pumpkin> Axman6: actually it does work with -N4
23:58:52 <pumpkin> it just needs to evenly divide the input size :P
23:58:58 <pumpkin> (good software engineering, that there is)
23:59:06 <Axman6> o.O
23:59:26 <mmorrow> pumpkin: yeah, a proof for every step would be nice
23:59:39 <pumpkin> put your mathematician's hat on then!
23:59:51 * mmorrow puts on his wizard hat
