00:00:37 <wli> Then it moves on and lets you put constraints on type parameters which require that certain functions be defined for the type parameter.
00:00:52 <wli> sort :: Ord t => [t] -> [t]
00:01:38 <wli> Type parameters can also represent functions from types to types.
00:02:07 <wli> So, for instance, Maybe is a function from types to types, as is [ ] (lists).
00:03:34 <wli> You can use parameters that are type functions, too, though most of the time you need constraints on those type functions to do anything useful.
00:04:22 <wli> Which brings us to the point that you can constrain type functions so that operations have to be defined on types using that type function somewhere in them.
00:04:49 <wli> Like Functor f with fmap :: (t -> t') -> (f t -> f t')
00:06:10 <wli> The next big thing is that the Monad constraint on type functions is used to deal with IO and also other useful things.
00:07:18 <wli> It's not the only way to put constraints on type functions in a way that gets good things. Control.Arrow and Control.Applicative are two "alternatives" to Monads for using constraints on type functions to abstract things.
00:08:35 <wli> Maybe the closest thing to the constraints on types and type functions in OO is Java interfaces.
00:09:05 <wli> There are also C++ templates, which are a little like type functions.
00:10:59 <wli> If you could have something like a C++ template in Java where you can furthermore say the template parameter is required to support a Java interface, that would be a little like Haskell.
00:12:05 <wli> (I may only be familiar with too ancient of revisions of the C++ and Java languages and they already support something similar.)
00:12:41 <Botje> java has templates nowadays
00:12:48 <Botje> and i believe you can add subtyping constraints
00:14:49 <wli> Botje: I didn't know they actually integrated that. Last I heard, Wadler's proposals on that front got rejected.
00:15:24 <scwizard> "Having a static type system means that the compiler knows the type of every value and expression at compile time, before any code is executed." <- I'm still trying to figure out why some programming language creators thought that they should move away from that, it just doesn't seem worth it to me
00:15:43 * wli continues trying to get somewhere with http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1733
00:16:11 <dolio> The really early type systems were pretty crappy, no?
00:16:28 <wli> dolio: As I recall yes.
00:16:32 <Botje> scwizard: for rapid prototyping, some people think the type system just gets in the way
00:16:38 <scwizard> Botje: oh
00:16:40 <vegai> scwizard: not having that requirement allows a lot more flexibility
00:16:43 <dolio> And lisp, one of the first languages out there didn't have a type system, so there was nothing to go away from there.
00:16:58 <vegai> in haskell land, we have to resort to hackery to get the same
00:17:15 <scwizard> vegai: err, I'm not so sure about that
00:17:24 <dolio> Even with Church's lambda calculus he started untyped, I believe.
00:17:30 <wli> I'm very uncomfortable in untyped settings. I use types rather heavily.
00:17:43 <vegai> scwizard: hs-plugins.
00:17:58 <scwizard> vegai: the only problem I can think of where knowledge of type at runtime is of importance is logging
00:18:09 <wli> For me, modelling anything so as to be able to put it into code starts with classification into types.
00:18:40 <wli> I'm lost without them.
00:18:59 <scwizard> vegai: if you can think of any other problems that require types known at runtime to solve to avoid hacking then I'm all ears
00:19:56 <vegai> scwizard: well, as I said... plugins
00:20:01 <Baughn> @hoogle cast
00:20:01 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
00:20:02 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
00:20:02 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
00:20:11 <Baughn> @hoogle castPtr
00:20:11 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
00:20:11 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
00:20:11 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
00:20:22 <scwizard> vegai: I don't understand
00:21:22 <scwizard> vegai: a library is a plugin, the haskell library doesn't use any dynamic typing
00:21:55 <scwizard> well a library and a plugin work in the same way
00:21:57 <scwizard> except reversed
00:22:08 <scwizard> hmm let me think about it
00:22:37 <vegai> Well, I'm not sure about it either. It's just a feeling that arises from doing a certain thing in scheme in one line
00:22:46 <vegai> and needing a whole lib to do it in here
00:22:57 <vegai> or alternatively, putting a knife in ghc
00:23:37 <wli> Different people operate differently.
00:24:19 <wli> I'm still spinning on the same thing I've been spinning on all night.
00:24:50 <wli> And last night, too.
00:25:39 <Saizan> vegai: that has more to do with the fact that scheme is interpreted
00:26:07 <Saizan> vegai: so it's easier to compile+link code on the fly
00:26:11 <scwizard> oh vegai
00:26:13 <scwizard> that's what I was thinking
00:26:19 <Saizan> fsvo compile
00:26:25 <scwizard> good pluginable programs support binary plugins
00:26:29 <scwizard> such as foobar2000
00:26:32 <vegai> hey, a language isn't interpreted or compiled, only its implementations :P
00:26:49 <vegai> besides, isn't chicken a compiler?
00:26:51 <scwizard> and bytecode has no concept of a type obv
00:27:16 <vegai> well, chicken probably puts in the interpreter in the binary
00:27:42 <scwizard> so while I'm not sure the general way to go about making your program support binary plugins (it's very difficult and project specific), I'm pretty certain that it's the best design decision
00:28:13 <scwizard> limiting plugin support to a single language isn't a good idea if you plan on having people write stuff for your program
00:31:03 <wli> I'm at least trying to translate to a machine-esque IR for the purposes of interpretation, but can't seem to get past various language complexity barriers.
00:31:56 <wli> I basically can't figure out how to cope with any sort of branching at all.
00:32:42 <wli> Neither functions nor conditionals/case statements.
00:32:55 * Saizan only knows how to compile to jump tables
00:33:43 <wli> My current sadder-than-sad attempt to build up from the stupidest possible mini-language is at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1733
00:35:50 <wli> It was a pretty big stretch for me to get let expressions going. It's almost like I'm too mentally exhausted to do anything more than flop in helpless indecision about doing anything else.
00:37:21 <wli> The output looks like, given input >> LetExpr "x" (LitExpr 5) (PrmExpr "add" [VarExpr "x", PrmExpr "neg" [VarExpr "x"]])
00:37:21 <wli> Right (3,[(ImmOp,[Right 1,Left 5]),(NegOp,[Right 2,Right 1]),(AddOp,[Right 3,Right 1,Right 2])])
00:37:21 <wli> fromList [(1,5),(2,4294967291),(3,0)]
00:37:21 <wli> 0
00:39:12 <wli> So there I've got a sequence of pseudo-instructions as the primary result, then I walk through executing them to fill up a map from temporary names (numbers) to values, and at the end pull out the one holding the value of the whole expression.
00:39:50 <wli> The hope is that I can figure out how to build up the language into something more full-featured, e.g. with lambdas, types, modules, etc.
00:40:14 <Saizan> is it strict?
00:41:11 <wli> I'm hoping for lazy, but if strict makes it more feasible than lazy, so be it.
00:42:01 <scwizard> god damn, I'm mad at my comp sci teacher now
00:42:27 <wli> I'm a bit too desperate to be very picky about the specific form of the language apart from getting beyond the level of infix calculators.
00:42:29 <scwizard> we're doing linked lists in java (which I'm not happy with, but that's an aside) and he's calling the first element the head and the last element the tail
00:42:51 <scwizard> and of course, if anyone from that class tries to learn a functional programming language, they'll be confused, because they'll think the tail is the last element
00:43:07 <scwizard> I mean if you think about it visually, in terms of a snake or something, it makes perfect sense
00:43:26 <yottis_> scwizard: that sounds sort of familiar from an imperative context
00:43:54 <scwizard> yottis_: it's best to use front and back, completely unambiguous and it reads just as well (if not better)
00:44:05 <scwizard> although I'd use "FirstNode" and "LastNode"
00:44:29 <wli> Saizan: At the moment I'm really going nuts trying to figure out how to get anywhere in terms of enriching the language. Everything I can think of to go about doing I'm completely lost as to how to do.
00:46:34 <Saizan> wli: uhm, well, a let-expression is a lot like a lambda and an application together, let x = e1 in e2 == (\x -> e1) e2
00:47:43 <scwizard> "If you are familiar with C, () is somewhat similar to void."
00:47:43 <wli> I can't figure out how to translate the calls to lambdas or the returns from them or anything.
00:47:50 <scwizard> I'm familiar with C and that makes no sense
00:48:41 <wli> Basically any sort of control flow. I end up with indefinitely-growing stacks for case statements etc.
00:49:09 <yottis_> well it does in the sense that you're not interested in the () because you know it'll be ()
00:50:17 <scwizard> so it's similar to void as a return value?
00:50:40 <yottis_> i thought of it that way when learning haskell
00:50:47 <scwizard> ok
00:51:43 <Saizan> wli: indefinitely growing stacks?
00:51:43 <yottis_> if you have to return something, but are only interested in the side effects, like in a void
00:51:49 <wli> I'm also pretty lost on the type front because I've only really figured out how to handle the case where all temporaries are of the same type. e.g. all of the infinite number of registers are integers. I'd have to somehow smoke out how to cope with more than one set of registers for different types of values in the presence of functions.
00:53:16 <wli> Saizan: I can't figure out how to do jumps or calls or anything.
00:55:38 <scwizard> "Haskell's type system prevents us from accidentally mixing pure and impure code." <- woah seriously? I think I may be sold
00:56:23 <wli> The code sequence that jumps elsewhere wants to put operands in and get operands back, but it can't get operands back because it ends at the jump, plus the code it jumps to wants data prearranged somehow I can't figure out how to arrange.
00:56:31 <Baughn> scwizard: Oh, sure. That's one of its simplest uses. ;)
00:57:04 <Saizan> wli: you might introduce a stack, and pass those things there
00:57:24 <scwizard> I would s/simplest/most fundamental/
00:57:46 <Saizan> wli: though i've almost no experience in compiling to an asm-like directly
00:58:20 <wli> There's no memory, and there are too many different types of things to pass. Mixing the types really screws it up.
00:59:53 <scwizard> wli: this sounds like a very unusual problem you're trying to solve (even though I'm not quite sure what exactly that problem is), are you sure Haskell is the best tool for solving that problem?
01:00:32 <wli> It shouldn't need a stack with an infinite number of temporaries to play with.
01:01:22 <Saizan> wli: i think you want to reserve some registers to establish some kind of calling convention
01:01:27 <wli> The trouble with the temporaries is when I try to build up more complex values.
01:01:56 <Saizan> and you can use a sum type to hold different types of values
01:02:02 <wli> There's basically no limit on the number of "register files" required to cope with them.
01:02:55 <wli> I hear that there are solutions, but I have trouble understanding them.
01:09:42 <wli> A lot of how this is done in low-level cases is with tag bits and hardwired memory formats (e.g. C structs where some position is interpreted as an integer and another is interpreted as a memory address)..
01:11:36 <wli> Algebraic data types are "discriminated unions" which look like struct { enum tag tag; union { fmt1 f1; ... fmtN fN; } contents; };
01:13:28 <wli> So it looks like you either deal with dependent types or go untyped to some extent.
01:16:25 <wli> If the temporary types are limited in precision to more closely match machine semantics, the larger constructs have to go through memory. Except you get the same sort of packing and unpacking affair when e.g. splitting a 64-bit temporary into two 32-bit temporaries where one contains the high bits and the other the low bits.
01:17:46 <f4hy> Alright so a) why is partially applied functions so freaking amazing and blowing my mind. and b) why are they not in every language
01:17:57 <gour> anyone know if there are some news about turbinado web framework? (no commits since feb 13th)
01:18:37 <gour> f4hy: well, haskell is designed by smart heads
01:19:31 <wli> It *looks like* the way to go is to split up the temporary stores by their types so ones that are small enough can go into registers and the ones too big go into memory, and then use packing and unpacking primitives to assemble larger values from gobs of smaller ones or to splatter the pieces of a larger value across numerous smaller ones.
01:23:47 <f4hy> Hmm lets say I want to do: data Rect = Rect {H :: Int, W :: Int}
01:23:48 <wli> This requires a temporary namespace subdivided by type.
01:23:54 <f4hy> And then I wanted to make a sqaure
01:23:59 <f4hy> type
01:24:40 <Cale> f4hy: That's fine except that H and W ought to be lowercase (names starting with an uppercase letter are reserved for data constructors)
01:24:46 <Saizan> f4hy: field names need to start with a lowecase letter, btw
01:26:16 <f4hy> ahh ya ok. I knew that
01:26:35 <f4hy> anyway, how do I make a square type using a my rect type? or am I thinking wrongly
01:26:53 <Cale> Well...
01:27:39 <Cale> Haskell doesn't have subtypes, and you'd probably be better off just with a separate type, but, let's say you *really* want to put the Rect type to use
01:27:57 <Cale> Then you could  newtype Square = S Rect
01:28:08 <Cale> and put that in a separate module, along with something like:
01:28:09 <f4hy> Or lets say I wanted a Rectofwidththree type
01:28:18 <tbq> I would say... don't even use a seperate type
01:28:19 <Cale> square x = S (Rect x x)
01:28:24 <tbq> just use a psudoconstructor
01:28:35 <tbq> but I guess that gives you fewer proofs about your program
01:29:20 <f4hy> hmm so I need to learn what a psudoconstructor is
01:29:31 <tbq> it's a function
01:29:33 <tbq> that constructs something
01:29:34 <Cale> f4hy: Just a function ;)
01:29:37 <tbq> like Cale just showed
01:29:48 <tbq> it's not actually a data constructor – they start with capital letters
01:29:52 <f4hy> oh ok so like rectofwidththree = Rect 3
01:29:59 <tbq> but it has the same effect (just ocasionally with more cleverness)
01:30:01 <Cale> yeah, you could do that.
01:30:25 <f4hy> but then I cant make a function that works on rectofwidththree
01:30:30 <f4hy> it would just work on rects
01:30:34 <Cale> f4hy: right.
01:30:58 <Cale> Well, you could make a newtype from Rect and hide that newtype's data constructor behind a module
01:31:06 <f4hy> what if I wanted fuction f to do something different on rectofwidththree than on regular rect
01:31:33 <tbq> then you would need to newtype it
01:31:45 <f4hy> alright, I need to learn newtype
01:31:57 <Cale> and not only would you need to newtype it, you'd need separate functions, or a typeclass
01:31:57 <f4hy> I am probably just not there yet
01:32:11 <Workybob> yeh, what Cale said
01:32:24 <Workybob> f4hy: in general, that is a pretty rare thing to want though
01:32:28 <Saizan> you could just foo (Rect 3 h) = ..; foo (Rect w h) = ..
01:32:40 <Workybob> it's very rare to have an A that *is* a B
01:32:46 <Workybob> and want to do something entirely different with A
01:32:47 <wli> This creates a whole host of new problems I don't have solutions to, mostly centered around pack/unpack.
01:32:47 <f4hy> really?
01:32:50 <Cale> Yes, it's important to realise that's possible as well.
01:33:01 <Cale> If you just want to check that the width is 3, just do that.
01:33:06 <Workybob> f4hy: yes, because a rect of width 3 *is* a rect – so why should it behave any differently
01:33:24 <Cale> But you can't tell that the Rect was constructed with your rectOfWidthThree function.
01:33:27 <f4hy> I guess I am still stuck in the thinking of classes, and want to subclass things. But I guess types dont work like that
01:33:37 <Cale> (or if it just happens to have width 3)
01:33:43 <Workybob> well, class hierarchies are just a different type system
01:33:44 <Cale> Haskell doesn't have subtypes.
01:34:04 <f4hy> Cale: Alright. :-(
01:34:23 <Cale> Type inference is way harder and less convenient to use with subtypes.
01:34:26 <Cale> It's a tradeoff.
01:34:45 <wli> There aren't any ways to do this one thing at a time.
01:34:50 <doserj> square is not a subtype of rectangle, anyways
01:35:02 <Workybob> doserj: sure it is – a square *is* a rectangle
01:35:09 <Workybob> that's exactly the behavior that OO is meant to model
01:35:14 <Workybob> it's just not what it's usually used for
01:35:16 <doserj> no. it behaves differently
01:35:20 <Workybob> does it?
01:35:20 <Workybob> how?
01:35:32 <f4hy> So basically I shouldnt make rectofwidth3, just the function I wanted to do something different on it I should just use rectangles and patern match to see if it has a width of three
01:35:32 <doserj> if you change the width of a square, the height changes too
01:35:47 <Workybob> doserj: no, if you change the width of a square, it stops being a square
01:35:56 <Workybob> that doesn't stop the square being a rectangle
01:36:02 <Cale> f4hy: It depends on what problem you're trying to solve...
01:36:11 <Workybob> the result of the "change width" operation just isn't a square
01:36:18 <pejo> Cale, have you actually used a language with both type inference and subtyping?
01:36:46 <wli> It's more a question of what sort of language having both can exist.
01:36:51 <doserj> Workybob: in what OO programming language can you do that?
01:37:01 <Cale> pejo: Not extensively.
01:37:03 <wli> You lose a lot to get subtyping and type inference to coexist.
01:37:12 <pejo> wli, such as?
01:37:13 <quicksilver> ocaml's extensible records, or whatever they call them
01:37:22 <Cale> pejo: There are a few of them now.
01:37:22 <quicksilver> extensible variants, I mean
01:37:28 <quicksilver> are a certain kind of subtyping.
01:37:36 <Workybob> doserj: plenty – here's the definition in Obj-C - (Rectangle *)stretchWidth:(float)amount
01:37:52 <wli> pejo: The error messages coming out of it are horrendous for instance.
01:37:57 <pejo> Cale, I fully agree that Haskell doesn't have subtyping, but I'm not convinced that the type inference is less convenient when you have subtyping.
01:38:08 <Workybob> { return [Rectangle rectangleWithWidth:[self width] * amount height:[self height]];
01:38:10 <Workybob>  }
01:38:16 <quicksilver> doserj, Workybob : normally I think of subtyping as a static property; in that view square is *clearly* a subtype of rectangle.
01:38:18 <wli> pejo: A lot of the types inferred are enormous, too.
01:38:25 <quicksilver> you're talking about dynamic behaviour
01:38:30 <quicksilver> which is always going to be fiddly.
01:38:31 <Workybob> quicksilver: indeed
01:38:34 <wli> pejo: Check out Dilip Siquiera's thesis.
01:38:39 <pejo> wli, you can make the inference sound but not complete.
01:40:09 <doserj> Workybob: does that change the type of self? or does it return a new object? I was talking about the former.
01:40:21 <pejo> wli, have a link? Scholar gives me 0 hits.
01:40:42 <f4hy> Note to self, types are not classes, stop trying to think of them as the same. Subclasses normally good. Subtypes = don't exist
01:40:47 <wli> pejo: Not anymore. I'm destitute.
01:41:00 <wli> I used to have it sitting around for easy web access by others.
01:41:07 <doserj> quicksilver: if you have something like object identity, and references, you have to think about dynamic behaviour of these objects.
01:41:20 <quicksilver> doserj: I don't denying it.
01:41:25 <doserj> :)
01:41:25 <Workybob> doserj: well no, but that's simply a case of the programmer writing it wrong
01:41:34 <Workybob> changing the width is not an operation on squares
01:41:48 <quicksilver> doserj: I'm just saying that dynamic behaviour and subtyping is a fiddly match
01:41:51 <quicksilver> typing is a static property.
01:41:58 <Workybob> and that begins to flag up why OOP doesn't work
01:42:03 <wli> pejo: Here it is
01:42:06 <wli> pejo: http://www.lfcs.inf.ed.ac.uk/reports/98/ECS-LFCS-98-403/
01:42:08 <Workybob> because it doesn't let you remove behavior from your specialisations
01:42:33 <f4hy> Hmm.. I think I am confusing type and typeclass.
01:44:33 <f4hy> Hmm wait...  data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Ord)   How does it know which is greater than annother? the order in which they are entered?
01:46:29 <Saizan> yes
01:47:31 <wli> f4hy: deriving (Eq, Ord, Read, Show, Bounded, Enum, Ix) is possible for such a type with only nullary constructors.
01:48:30 <f4hy> wli: define nullary
01:48:49 <wli> f4hy: Taking zero arguments.
01:49:17 <pejo> wli, ok, thanks. Have to catch the bus now, will read later.
01:50:24 <ski_> wli : ty for the link .. (the only thing i found for "Dilip Siquiera" was you pointing to his thesis on irc in 2007 ;)
01:50:51 <wli> heh
01:51:07 <wli> I found it by searching for "Helly posets"
01:51:22 <Baughn> mmorrow: Oh, and I tracked the ghc 6.10.2 build error to a very recent patch to ghc
01:53:12 <Baughn> mmorrow: "Fix Trac #3066: checking argument types in foreign calls" <-- This one. I'm writing a bug report.
01:54:15 <Baughn> mmorrow: ..then again, someone already did so
01:56:39 <wli> Check page 137 according to pdf readers' page numberings, page 132 according to the document's own page numbering for an example of what type inference produces with subtyping on Standard ML polymorphism.
02:00:28 <JavaBeginner> hi, does anyone in here know Java programming?
02:01:27 <Saizan> you should go to #java (or was it ##java ?)
02:01:33 <wli> This channel is mostly about Haskell, but maybe someone knows less antique of Java standards than I.
02:01:53 <JavaBeginner> ok ill go to #java, thank you
02:02:04 <wli> I'm still at a loss as to where to begin on my issues.
02:02:12 <JavaBeginner> i havent used mirc in forever, is it /join #java?
02:02:13 <dolio> I stopped paying much attention to Java many years ago.
02:02:22 <Saizan> yeah
02:02:44 <wli> Pack and unpack have some problems. Unpack, for instance, uses multiple destination temporaries.
02:03:06 <wli> It's also not clear up-front what the types of their operands are.
02:03:17 <JavaBeginner> ahhh i need to be identified to join #java :(
02:03:34 <wli> Set it up with NickServ.
02:04:02 <JavaBeginner> would any of you happen to just know how to do a loop with arraylists in java
02:04:20 <JavaBeginner> i know loops and arraylists, but i dont know the command to type
02:04:41 <wli> There also needs to be some sort of weird type representation and temporary sets for values of various types need to be instantiated on the fly.
02:04:41 <JavaBeginner> like when using "i" or whatever name for a loop, how do i put that in to the arraylist.add() method?
02:04:48 <inimino> this is not the place for Java questions.
02:05:01 <osfameron> I guess 'H' does come earlier in the alphabet than 'J' ;-)
02:05:08 <JavaBeginner> arraylist.add(item1);  works
02:05:15 <JavaBeginner> but i need to loop it so 1 can change
02:05:26 <inimino> JavaBeginner: learn how to register, then ask in the appropriate place
02:05:35 <JavaBeginner> k
02:05:45 <osfameron> JavaBeginner: array ++ [item1]    # if you wanted to do it in haskell
02:06:28 <wli> JavaBeginner: Witness the following:
02:06:30 <wli> > let primeStep n = let cmpStep ((k, ps), m) | n /= k = tell [n] >> modify (Map.insertWith (++) (n*n) [n]) | otherwise = put . Map.unionWith (++) m . Map.fromListWith (++) $ [(k + p, [p]) | p <- ps] in gets Map.minViewWithKey >>= maybe (tell [n] >> put (Map.singleton (n*n) [n])) cmpStep in flip evalState Map.empty . execWriterT $ mapM_ primeStep [2..]
02:06:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
02:07:11 <wli> JavaBeginner: This uses a WriterT monad transformer over a State monad.
02:07:23 <inimino> hehe
02:08:02 <earthy> that's nasty :)
02:08:28 <wli> It's prettier when not golfed onto one line.
02:08:56 <earthy> even then it's nasty :)
02:09:19 <osfameron> why for the love of monad, why?
02:09:25 <earthy> to pull on an unsuspecting javahead. :)
02:09:26 <osfameron> (apart from to scare Java programmers)
02:09:37 <wli> JavaBeginner: The state is a priority queue represented as the Haskell library's Data.Map and it outputs (via tell) a list of integers.
02:10:03 <JavaBeginner> that is all above my head :D
02:10:21 <earthy> good. shows you there is much to be learned. :)
02:10:54 <JavaBeginner> im still struggling with simple syntax here so i can do a mere loop with arraylist objects
02:10:58 <wli> I don't know. I thought this "monadic Eratosthenes" was actually good stuff.
02:12:12 <earthy> wli: yeah, though golfed it looks *really* obscure
02:12:31 <wli> I'm trying to figure out a way to incrementally get the codebase I've got for expression linearization to do anything more than what it already does.
02:13:17 <JavaBeginner> thanks for the help, im registered and in ##java now
02:13:41 <wli> It's not really that obscure; it just does what the sieve of Eratosthenes wants to do: maintain state consisting of a priority queue and emit integers that it believes to be prime when it finds them.
02:14:40 <wli> It is, in some sense, a perfect use case for monads and monad transformers.
02:14:50 * earthy nods
02:15:13 <earthy> could do with longer names for the arguments though
02:16:45 <wli> The arguments don't really have meanings lending themselves to more descriptive names. Maybe cmpStep could be more descriptively named.
02:17:48 <earthy> what, ps couldn't be primecandidates?
02:17:54 <earthy> c couldn't be candidate?
02:17:58 <earthy> m couldn't be multiplier?
02:18:37 <wli> ps isn't primeCandidates, though. Maybe it's knownPrimesWithCurrentMultipleToCheckOfK
02:19:42 <f4hy> "Typeclasses have pretty much nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now." This is what I needed to read
02:20:39 <wli> m isn't a multiplier; maybe it's priorityQueueKeyedByCurrentMultiplesOfKnownPrimesWithListsOfKnownPrimesAssociatedWithMultiplesAsElements
02:21:03 <Baughn> f4hy: They're almost, but not quite, entirely unlike classes
02:21:10 <f4hy> Baughn: perfect
02:21:27 <f4hy> I will just make a Tea type and be set
02:21:33 <earthy> you know, the original sieve was much easier to understand :)
02:21:49 <osfameron> Baughn: I've never quite understood that... I think of them as quite similar to classes, and don't find much cognitive dissonance there
02:22:32 <osfameron> well, maybe as 'roles', but then again I pretty much think of those as classes too...
02:22:42 <Sandios> hi there
02:23:03 <Sandios> uu?
02:23:31 <f4hy> wait what?! # class Eq a where
02:23:32 <f4hy> #     (==) :: a -> a -> Bool
02:23:34 <f4hy> #     (/=) :: a -> a -> Bool
02:23:36 <f4hy> #     x == y = not (x /= y)
02:23:43 <f4hy> #     x /= y = not (x == y) yes
02:25:39 <f4hy> ok nm, I get it now
02:31:11 <wli> Sorry, I had to cry.
02:31:43 <Jabal_al_Lawz> Jabal al Lawz
02:33:09 <wli> I'm really stumped as to how or whether it's possible to incrementally extend this idiot interpreter.
02:34:37 <wli> It looks like the only things left to do would require such violence to be done to it that it doesn't really help to hang onto the codebase anymore, at which point I'm lost.
02:37:28 <wli> Multiple assignment at the expression level is really killing me, too.
02:38:13 <wli> A fair amount of the design revolves around the assumption of a single temporary representing the value of an expression subtree.
02:38:49 <quicksilver> you mean things like let [x,y,(a,b),c] = [1,2,(3,4),5] ?
02:39:09 <wli> quicksilver: More basic, like (q, r) = n `divMod` d
02:39:22 <quicksilver> the same problem in general, I suppose.
02:40:01 <wli> Well, the restriction of only a single nesting depth of constructor being considered is there.
02:40:29 <wli> It'd be like t1 <- n `divMod` d ; (q, r) <- unpack t1
02:41:10 <wli> WIth data X = X1 Int Int | ... you'd get something similar, but even more confusing for me.
02:41:56 <quicksilver> I don't really understand why that's "(q,r) <- unpack t1"
02:42:02 <quicksilver> and not just "(q,r) <- t1"
02:42:10 <wli> quicksilver: For a quick rundown on what I'm working with, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1733
02:42:37 <wli> quicksilver: Because pattern matching doesn't exist. Explicit projections are required.
02:44:48 <wli> I guess pack/unpack are only for product types. Coproduct types have to have case, where I can't do case because I can't figure out branches.
02:46:44 <wli> At that point you could just have projections for the n-th components.
02:46:51 <quicksilver> wli: if explicit projects are required then its' q <- fst t1; r <- snd t1
02:47:00 <quicksilver> it's the unpack thing I was objecting to.
02:47:20 <quicksilver> the possibility of writing (q,r) <- unpack t1 suggests that patterns exist.
02:47:27 <quicksilver> just a notational complain that's all
02:47:34 <wli> Projections solve it for product types. It's coproducts that are Hell.
02:48:33 <wli> Maybe you could consider coproducts to be uncurried so they're always unary.
02:49:01 <wli> That gets rid of the multiple destinations there, too.
02:49:50 <wli> There's an impedance mismatch with the machine without multiple destinations, though.
02:53:19 <wli> nullary constructors in the source language wreck the uncurried coproduct constructor hope.
02:54:57 <wli> It has to be at least 0 or 1.
02:57:10 <wli> It takes more violence than is obvious to add tuples and projections because I have to have a potentially infinite family of temporary stores / register files, one for each type.
03:01:02 <opqdonut> coproducts are kind of like Either?
03:01:14 <wli> Yeah.
03:01:27 <opqdonut> kinda or exactly?
03:01:39 <wli> Either is an instance of a coproduct.
03:01:53 <opqdonut> yeh of course it's a general concept
03:01:53 <wli> WHen you have type alternatives separated by |'s it's a coproduct.
03:01:59 <dolio> Except not really.
03:02:37 <opqdonut> are type unions and discriminated unions both coproducts?
03:02:58 <wli> Discriminated unions are coproducts.
03:03:05 <wli> Undiscriminated unions are not.
03:04:05 <wli> There are more problems with uncurried coproducts, like distinguishing Constructor (t, t') from Constructor t t'
03:09:34 <HugoDaniel> is there a version of (!!) that returns Maybe ? (so i can stop worrying about those out of range indices)
03:10:04 <dolio> @hoogle index
03:10:05 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
03:10:05 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
03:10:05 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
03:10:24 <HugoDaniel> for lists :P
03:10:54 <dolio> Yeah, I thought that might be it.
03:10:57 <pejo> HugoDaniel, it sounds like there is something wrong with your design from the start if you have to use !! a lot.
03:11:12 <HugoDaniel> pejo, i could use head . tail . tail ...
03:11:48 <dolio> Apparently there isn't. You can use 'listToMaybe . drop n' though.
03:12:00 <wli> Looks like you have to do something like \n xs -> Data.List.lookup n (zip [0..] xs)
03:12:02 <pejo> HugoDaniel, it sounds like there is something wrong with your design if you have to do that.
03:12:18 <HugoDaniel> i have no chance
03:12:19 <wli> listToMaybe . drop n is better.
03:12:25 <HugoDaniel> im trying to parse down a list of strings
03:12:43 <HugoDaniel> hxt returns a lst of strings...
03:12:53 <HugoDaniel> that i now need to parse into a few data structures
03:13:08 <HugoDaniel> so im opting by explicit recursion
03:13:21 <HugoDaniel> are there any better options ?
03:14:18 <pejo> What does each string contain?
03:15:34 <HugoDaniel> it can be 3 diff things, a name, a value and a comment, depending on the position of the lst
03:16:07 <HugoDaniel> the list is like this: [name, value, comment, value comment, name, value, comment, name, value, comment, value comment, value comment] ...
03:16:49 <HugoDaniel> im sorry, it is the other way arround
03:16:56 <HugoDaniel> [name, comment, value, comment value ... ]
03:17:08 <HugoDaniel> after each name there can be 0 or more comment, value
03:17:43 <HugoDaniel> so i know a name on the list by "not . isValue $ lst !! 1"
03:18:01 <pejo> HugoDaniel, does it always come in "comment, value", never "value, value, comment"?
03:18:37 <HugoDaniel> yes, it is always comment, value
03:19:01 <HugoDaniel> there is a comment associated with each value, or else there is a hxt error
03:19:16 <pejo> HugoDaniel, and how do you tell the difference between name, comment, value, comment, value and name, comment, value, name, comment, value?
03:20:00 <HugoDaniel> with: isName lst = not . isValue $ lst !! 1
03:20:14 <HugoDaniel> or i dont know
03:20:50 <pejo> HugoDaniel, how is isValue defined?
03:21:11 <HugoDaniel> all isDigit
03:22:21 <HugoDaniel> at least thats what im thinking of :/
03:26:33 <pejo> HugoDaniel, that doesn't sound at all like what http://www.haskell.org/haskellwiki/HXT/Practical lists.
03:28:22 <HugoDaniel> well, hxt groks web pages, right ?
03:28:34 <HugoDaniel> and returns the result in a list, right ?
03:28:35 <pejo> HugoDaniel, and http://en.wikibooks.org/wiki/Haskell/XML says "We see that HXT represents an XML document as a list of trees, where the nodes can be constructed as an XTag containing a list of subtrees, or an XText containing a string."
03:29:12 <HugoDaniel> well yes, but im using xpath filters in hxt
03:29:52 <HugoDaniel> because the pages im groking are a bit complex and change often
03:30:37 <pejo> HugoDaniel, the example at the bottom of the wikibooks page seems to give an Ntree back as reslut.
03:31:12 <HugoDaniel> yes it does, and what will you do when the tree keeps changing ? change your arrows ?
03:31:32 <HugoDaniel> or keep a very simple set of arrows that are run through the tree several times trying to get the expected values ?
03:31:38 <HugoDaniel> or use xpath filters ?
03:31:53 <HugoDaniel> ...i chose the xpath filters option
03:32:10 <pejo> HugoDaniel, doesn't the last example use Xpath?
03:33:49 <HugoDaniel> the webSpider ?
03:34:18 <pejo> HugoDaniel, the one at the bottom of http://en.wikibooks.org/wiki/Haskell/XML
03:38:38 <HugoDaniel> ok, let me see if i can get the tree to parse right
03:41:36 <HugoDaniel> im using a getText in the end, so i can stop handling the tree
03:42:38 <pejo> HugoDaniel, so you get rid of all the structure?
03:46:25 <HugoDaniel> yes, because then i have that list, wich i thought it would be simpler to parse, than a sparse tree filled with empty sibblings
03:53:20 <fasta> Is there a compiler option to replace the implicit import Prelude by import MyPrelude?
03:54:09 <koeien> fasta: -XNoImplicitPrelude
03:54:11 <doserj> LANGUAGE NoImplicitPrelude, but you still have to import MyPrelude
03:54:33 <fasta> That means the answer is no.
03:54:50 <fasta> I already use NoImplicitPrelude of course.
03:55:33 <fasta> It's just a bit silly to do import MyPrelude in _every_single_module_.
03:56:13 <koeien> what's the difference between, {-# LANGUAGE NoImplicitPrelude, CustomPrelude=MyPrelude #-}
03:56:25 <koeien> vs {-# LANGUAGE NoImplicitPrelude #-} import MyPrelude
03:56:33 <Cheshire> koeien not much
03:57:09 <Cheshire> koeien, if you passed LANGUAGE flags at the compile line instead of inside the source code maybe that would be a bigger difference
03:57:22 <koeien> that would be a bit opaque
03:57:29 <Cheshire> not sure how that works for multiple files
03:57:34 <koeien> you will get bitten by that sometime
03:57:41 <Cheshire> how?
03:57:52 <koeien> you forget it, or you redistribute it and somebody else forgets it
03:58:01 <koeien> it's a little bit too magical imo
03:58:05 <Cheshire> I doubt that but yeah ok
03:58:13 <Cheshire> it's a valid concern
03:59:21 <pejo> HugoDaniel, I would try to parse the tree instead to avoid the !!'s.
03:59:54 <quicksilver> I think the goal is to make .hs files standalone
03:59:59 <fasta> koeien: suppose you want to find a symbol. Do :i symbol and you should get "defined in implicit module Foo". No magic, just GHC which doesn't do this.
04:00:09 <quicksilver> I mean, not dependent on exotic compiler options which live outside the hs file.
04:00:37 <Cheshire> quicksilver I wish it actually worked that way
04:00:48 <Cheshire> it's a great /idea/
04:00:57 <Cheshire> but look at the size of GHC makefiles
04:00:57 <cizra> Hmmm. So main = putStrLn "foo" >> putStrLn "bar" is equivalent to main = do putStrLn "foo"; putStrLn "bar" ?
04:01:06 <koeien> cizra: yes
04:01:06 <Cheshire> cizra, yes
04:01:06 <quicksilver> Cheshire: it does actually work that way (in every program I've ever written)
04:01:14 <quicksilver> Cheshire: which is quite a lot of code, in total.
04:01:53 <koeien> cizra: the second example is in fact syntactic sugar for the first
04:01:59 <Cheshire> quicksilver, all my haskell is like that too. but some reason people feel the need for cabal and ./configure makefile scripts
04:02:48 <quicksilver> very few people use ./configure makefile scripts
04:02:53 <Cheshire> GHC
04:02:59 <cizra> koeien: thanks
04:03:03 <quicksilver> cabal mostly serves a purpose which is not in conflict with what I said.
04:03:11 <quicksilver> mostly it's about specifying package dependencies.
04:03:16 <quicksilver> Cheshire: GHC is 1 person.
04:03:37 <Axman6> wait... ghc's a person now?
04:03:39 <quicksilver> and it is still true that the *huge* majority of .hs files in it satisfy the property I'm describing.
04:03:49 <fasta> Axman6: it's a little known secret.
04:03:52 <Axman6> crap, i've had my laptop in my bag all day, i probably killed it!
04:03:56 <quicksilver> that everything you need to know about how to compile them is in the .hs
04:07:27 <ivanm> Axman6: nice improvement on the shootout ;-)
04:07:34 <Axman6> ta :)
04:07:53 * Axman6 is quite proud indeed with it actually :P
04:08:03 <cizra> koeien: I figured out the analogous thing for passing around data: getStr >>= putStrLn works nicely.
04:08:22 <cizra> koeien: Are these two + return enough to rewrite everything in do-blocks?
04:08:36 <Axman6> yep
04:10:09 <cizra> mmkay. Back to RWH then.
04:10:37 * cizra is pretty comfortable around pure code by now, but IO still wants regular virgin sacrifices.
04:12:42 <ivanm> cizra: do you still qualify? :p
04:14:06 <cizra> ivanm: What, you need virgins too? Sorry, but the shipping cost for me would be prohibitive. Suggest getting a couple of local CS students.
04:14:39 <ivanm> cizra: nah, mathematicians are easier, since I work in the maths building...
04:14:42 <Cheshire> I dreamp that I was doing two PhD simultaneously :SSS  .. I wake up exausted
04:14:50 <ivanm> then there's always the new first-year science students I'm tutoring...
04:14:54 * ivanm stops being macabre
04:15:17 <cizra> ivanm: Are matematicians as virginal as CS geeks?
04:15:26 <ivanm> cizra: I'd guess even more so...
04:15:37 <ivanm> though there are more female mathematicians than CSers...
04:15:44 <Workybob> Cheshire: bloody hell, that would be exhausting
04:16:19 <ivanm> Cheshire: yes, but how similar were the theses?
04:17:00 <Cheshire> I think one was about induction and the other was about recursion
04:17:09 <Cheshire> (lol)
04:17:10 <ivanm> so similar...
04:17:17 <ivanm> that reduces the work load down a tad
04:18:26 * ivanm wonders if Velociraptors is an xkcd fan...
04:18:54 <Cheshire> but my dream was so tiring that I slept in :(
04:19:19 <ivanm> Cheshire: you slept in the dream? :o
04:19:20 <ivanm> ;-)
04:19:31 * Velociraptors are.
04:19:50 <Velociraptors> but dromaeosaurs way before xkcd.
04:20:11 <ivanm> heh
04:20:50 <ivanm> hmmm.... whatever happened to OzHaskell anyway?
04:22:35 <HugoDaniel> pejo: i have no option, i knew there was a reason for the list, the thing is that xpath parser returns a list of trees, each tree is just a text node, so im down to the same problem... parsing a list :/
04:24:48 <HugoDaniel> ill try diff xpath functions to see if can i get a single tree outpu
04:36:23 <polveroj> Can anyone here help with a cabal problem?  I'm having trouble building regex-posix on windows.  It says it can't find regex.h, but I have no idea where that's even supposed to be.
04:37:31 <dcoutts> polveroj: it's most likely not installed unless you're using mingw/cygwin
04:37:35 <EvilTerran> polveroj, .h is a C header; it probably comes with the C regex library
04:37:56 <EvilTerran> which may not work on windows without mingw/cygwin, yeah, considering it's got "posix" in the name
04:38:46 <polveroj> is there a way to tell cabal to stop trying to install it whenever I tell it to upgrade?
04:39:18 <Axman6> i don't think you can use the posix stuff on windows
04:41:58 <dcoutts> polveroj: you don't want to upgrade core packages anyway
04:42:03 <p_l> Axman6: install SUA? :)
04:42:15 <Axman6> SUA?
04:42:26 <p_l> Services for Unix Applications
04:42:30 <dcoutts> polveroj: upgrade your cabal-install version, it disables global upgrade because people keep using it to shoot themselves in the foot.
04:42:44 <dcoutts> polveroj: cabal install Cabal cabal-install
04:42:44 <Axman6> no idea. i've never owned a windows machine in my life :)
04:43:04 <HugoDaniel> Axman6: you are pure, like haskell
04:43:09 <p_l> Windows NT Posix environment (the base libs are included in Vista Ultimate and can be installed with purchased version)
04:43:12 <Axman6> yep
04:43:25 <HugoDaniel> btw, nice post about main thread Axman6
04:43:35 <p_l> HugoDaniel: Unless that means he used Macs, then he is impure :>
04:43:40 <HugoDaniel> ahah :D
04:44:02 <p_l> to be pure, no Windows nor MacOS for you!
04:44:06 <Axman6> p_l: it does indeed, and that make me super pure. none of this linux BS, BSD all the way
04:44:08 <polveroj> dcoutts: "cabal upgrade cabal" says I have the latest version
04:44:20 <p_l> Axman6: Never ever? Wow :)
04:44:24 <HugoDaniel> :D
04:44:28 <HugoDaniel> im using bsd now
04:44:32 <HugoDaniel> kind of liking it
04:44:50 <Axman6> technically that's a lie, there's a few virtual machines lying aroud my external drive, and a friend gave me a pentium 4, which did have windows on it... for about an hour after i got it :P
04:45:13 <dcoutts> polveroj: what does cabal --version say? 0.6.0 or 0.6.2?
04:45:24 <Axman6> p_l: yep. never needed it. MS Office for mac has always been better than for windows imo, so no problems there, and there's never been anything else i've needed
04:45:31 <polveroj> dcoutts: 0.6.0.
04:45:37 <Axman6> HugoDaniel: which one?
04:45:45 <dcoutts> polveroj: the cabal command line tool is provided by the cabal-install package. The Cabal package provides the library.
04:45:59 <C-Keen> hm, why can't I say:
04:46:06 <dcoutts> polveroj: so you still want to: cabal install cabal-install
04:46:12 <polveroj> dcoutts: aha.
04:46:25 <C-Keen> case y of ; 0 -> foo; _ -> bar;
04:46:33 <HugoDaniel> Axman6: freebsd 7.1
04:46:38 <C-Keen> I get a patterns overlap error
04:46:42 <Axman6> good work :)
04:46:42 <C-Keen> which is of course right
04:46:56 <Axman6> well, any BSD is good ;)
04:48:17 <p_l> Well, I don't have a machine to put BSD on right now, too many uncertain drivers (at least from what I heard)
04:48:20 <HugoDaniel> i also like linux, and windows, just not that much macOS :P
04:48:35 <HugoDaniel> p_l: drivers are great... if you get the supported hardware
04:49:12 <p_l> the os itself is quite nice, I used NetBSD3.0 in one server in the past
04:49:24 <Axman6> OS X dominates everything as a desktop OS
04:50:36 <Axman6> it's places like IRC where people disagree with that, but that's because they are not typical desktop users. they're on IRC, they're geeks
04:51:01 <bremner> so? perhaps your definition of desktop OS needs qualification
04:51:28 <HugoDaniel> :D
04:51:38 * p_l agrees with bremner
04:51:39 <Axman6> well, geeks like to hack things. they often like playing with the command line, and are quite happy building software from source
04:51:44 <HugoDaniel> im a typical desktop user...
04:52:04 <Axman6> your average 'deaktop user' is scared by the mere thought of either thing
04:52:07 <bremner> chacun son goat
04:52:16 <p_l> Axman6: Experimental data shows that there is no such thing as "intuitive, desktop OS". The only intuitive interface is the nipple, after that, everything is learned
04:52:25 <Axman6> heh
04:52:33 <HugoDaniel> im building the next generation interfaces :)
04:52:44 <HugoDaniel> they will be intuitive
04:52:49 <HugoDaniel> and in haskell
04:53:00 <p_l> Axman6: If you get someone who never used computers and gave them CLI, they will have around the same amount of problems as with GUI
04:53:01 <Axman6> p_l: that's fine, but it's not just how intuitive an OS is. consistency has a lot to do with it (something which MS are patheric at)
04:53:22 <p_l> Axman6: Also, CLI actually has psychologically better interface :)
04:53:22 <HugoDaniel> but more on that later, now i have to make a living coding in haskell... thats my premise "i only code in haskell"
04:54:17 <HugoDaniel> i got a *very* nice offer for coding in python, which i rejected :P
04:54:20 <bremner> Is there a built in way to compute n-th roots?  I'd rather not install packages because I want to send someone the script
04:54:20 <Axman6> i was reminded of this fact the other day when a lecturer tried to download his lecture slides in IE. instead of opening them in powerpoint, which would make perfect sense, it opened them inside the browser window.
04:54:23 <HugoDaniel> oh well
04:54:28 <HugoDaniel> lunch time, buy*
04:54:33 <Axman6> bremner: x ** (-n)
04:54:42 <Axman6> > 2 ** (-4)
04:54:43 <lambdabot>   6.25e-2
04:54:45 <polveroj> dcoutts: is there a safe way to remove installed packages?  I seem to have process-1.0.1.0 and process-1.0.1.1, and GHC is not happy with that.
04:54:47 <bremner> Axman6: well, that certainly rocks!
04:54:51 <Axman6> > (2 ** (-4)) ^ 4
04:54:52 <lambdabot>   1.52587890625e-5
04:55:01 <EvilTerran> Axman6, shouldn't that be x ** (1/n)?
04:55:01 <Axman6> um
04:55:01 <bremner> ehh?
04:55:05 <Axman6> yes
04:55:06 <dcoutts> polveroj: ghc-pkg unregister --user process-1.0.1.1
04:55:10 <Axman6> > (2 ** (1/4)) ^ 4
04:55:11 <lambdabot>   1.9999999999999996
04:55:12 <polveroj> dcoutts: thanks
04:55:14 <bremner> ohh, right.
04:55:14 <Axman6> > (2 ** (1/4))
04:55:16 <lambdabot>   1.189207115002721
04:55:19 <dcoutts> polveroj: use --force if necessary and rebuild other borken packages
04:55:23 <Axman6> ta EvilTerran, brain fart :)
04:55:26 <EvilTerran> , (2 ** (1/4)) ^ 4 :: CReal
04:55:28 <lunabot>  luna: Not in scope: type constructor or class `CReal'
04:55:33 <Axman6> phail
04:55:54 <EvilTerran> huh... i thought lunabot had the computable reals lib
04:55:56 <dcoutts> polveroj: check for duplication between global and user packages, eg, is Cabal-1.6.0.1 registered in both user and global sections? see ghc-pkg list
04:58:10 <Petrosian> @users
04:58:10 <lambdabot> Maximum users seen in #haskell: 658, currently: 591 (89.8%), active: 12 (2.0%)
04:59:19 <Axman6> the max maximum i've seen was 699
04:59:31 <Axman6> i do wish that was persistent in \bot :\
04:59:46 <C-Keen> hm, can I use guards with \lambda-> ?
05:00:53 <Axman6> > (\x -> | even x = "even" | odd x = "odd | otherwise = "oh noes!") 3
05:00:53 <lambdabot>   <no location info>: parse error on input `|'
05:01:02 <Axman6> > (\x  | even x = "even" | odd x = "odd | otherwise = "oh noes!") 3
05:01:03 <lambdabot>   <no location info>: parse error on input `|'
05:01:06 <Axman6> guess not
05:03:41 <C-Keen> And I cannot use '_' as a wildcard in case of I guess
05:04:21 <daf> yes you can
05:04:21 <Axman6> i think that depends on how you're using it
05:04:28 <C-Keen> > (\x -> case x of; 1->"one";_-> "something";)
05:04:29 <lambdabot>       Overlapping instances for Show (t -> [Char])
05:04:29 <lambdabot>        arising from a use ...
05:04:58 <C-Keen> something like this
05:05:07 <daf> > (\x -> case x of; 1->"one";_-> "something";) 2
05:05:08 <lambdabot>   "something"
05:05:32 <C-Keen> wtf
05:05:57 <daf> why wtf?
05:06:18 <C-Keen> daf: I don't see the difference
05:06:32 <idnar> C-Keen: daf applied the function to a param, you didn't
05:06:48 <idnar> so you got an error trying to "show" a function, and daf got a result :)
05:07:15 <C-Keen> hm, so it is really a ghci issue not a haskell issue at all
05:07:47 <Axman6> C-Keen: there's no easy way to show "(\x -> case x of; 1->"one";_-> "something";)"
05:07:56 <Axman6> you have to apply it and get a result
05:07:59 <Axman6> > (\x -> case x of; 1->"one";_-> "something";)
05:08:00 <lambdabot>       Overlapping instances for Show (t -> [Char])
05:08:00 <lambdabot>        arising from a use ...
05:08:02 <Axman6> > (\x -> case x of; 1->"one";_-> "something";) 1
05:08:02 <C-Keen> alright!
05:08:03 <lambdabot>   "one"
05:08:03 <Axman6> > (\x -> case x of; 1->"one";_-> "something";) 2
05:08:04 <lambdabot>   "something"
05:08:14 <C-Keen> thank you daf Axman6 and idnar :)
05:09:15 <Axman6> @let nthroot n x = x ** (1/n)
05:09:16 <lambdabot>  Defined.
05:09:18 <Philonous> It would be great if you had access to the type names at runtime. Than you could do something like instance Show (a->b) where show _ = "function: " ++ a ++ "->" ++ b
05:09:19 <Axman6> :t nthroot
05:09:20 <lambdabot> forall a. (Floating a) => a -> a -> a
05:09:35 <Axman6> > nthroot 10 1024
05:09:36 <lambdabot>   2.0
05:10:14 <Philonous> Or rather: If the compiler would substitute the variable for the type name at compile time
05:11:46 <aleator> I have multithreaded program. No input, each thread appends to its own file, and I still get "openFile: resource busy (file is locked) " errors. How can this happen?
05:14:47 <ImInYourMonad> what do you use? MVar STM? they all read from the same file?
05:16:19 <aleator> ImInYourMonad: STM. They don't read files. They each append to different file.
05:23:57 <pejo> Philonous, that wouldn't work well with read.
05:24:53 <quicksilver> Philonous: instance (Typeable a,Typeable b) => Show (a -> b) where show f = "function : " ++ (show . typeOf $ (undefined :: a)) ++ " -> " ++ (show . typeOf $ (undefined :: b))
05:24:54 <Philonous> Right. Is Read a prerequisite for Write?
05:25:37 <quicksilver> indeed, that instance is visible to lambdabot
05:25:51 <quicksilver> but lambdabot is broken somehow and it overlaps with another instance
05:25:54 <quicksilver> > ord
05:25:55 <lambdabot>       Overlapping instances for Show (Char -> Int)
05:25:55 <lambdabot>        arising from a use ...
05:29:42 <Philonous> quicksilver: Ah, ok. This is indeed solveable with classes (and apparently already done). Good to know. Thanks.
05:29:45 <ImInYourMonad> does a crosscompiler for haskell exist?
05:30:01 <civ> hello, i've got linking problem when trying to compile a simple program using Netwok.HTTP module
05:30:05 <civ> (.text+0x5295): undefined reference to `networkzm2zi2zi0zi1_NetworkziSocket_a349_info'
05:30:05 <civ> /usr/lib/HTTP-4000.0.4/ghc-6.10.1/libHSHTTP-4000.0.4.a(TCP.o): In function `HTTPzm4000zi0zi4_NetworkziTCP_a21_srt':
05:30:05 <civ> (.data+0x374): undefined reference to `networkzm2zi2zi0zi1_NetworkziSocket_a349_closure'
05:30:05 <civ> /usr/lib/HTTP-4000.0.4/ghc-6.10.1/libHSHTTP-4000.0.4.a(TCP.o): In function `HTTPzm4000zi0zi4_NetworkziTCP_a22_srt':
05:30:06 <civ> (.data+0x3c4): undefined reference to `networkzm2zi2zi0zi1_NetworkziSocket_a349_closure'
05:30:08 <civ> /usr/lib/HTTP-4000.0.4/ghc-6.10.1/libHSHTTP-4000.0.4.a(TCP.o): In function `HTTPzm4000zi0zi
05:30:25 <civ> does anybody have a clue, what went wrong?
05:30:26 <Philonous> civ: Did you ghc --make ?
05:30:30 <civ> yep
05:31:53 <civ> ghci "that file" stops with the very same problem
05:31:59 <Cheshire> civ use a paste site
05:32:21 <civ> Cheshire,  ok, sorry
05:37:14 <ImInYourMonad> *RedBlackTree> map (+(-1)) [1,2,3]
05:37:14 <ImInYourMonad> [0,1,2]
05:37:14 <ImInYourMonad> *RedBlackTree> map (-1) [1,2,3]
05:37:19 <ImInYourMonad> why doesnt th e second work?
05:37:50 <Workybob> ImInYourMonad: because - is annoying
05:37:57 <Workybob> -1 is the integer negative one
05:38:02 <Workybob> not the function that subtracts one from things
05:39:26 <Axman6> ImInYourMonad: you want...
05:39:37 <Axman6> > map (subtract 4) [1..10]
05:39:38 <lambdabot>   [-3,-2,-1,0,1,2,3,4,5,6]
05:39:57 <Workybob> note – subtract may not do what you think it does
05:40:04 <Workybob> subtract x y = y - x
05:40:05 <Workybob> not x - y
05:40:10 <Workybob> it subtracts x from y
05:40:40 <Axman6> subtract x is the function that subtracts x from its argument
05:41:27 <Philonous> :t (- 1)
05:41:28 <lambdabot> forall a. (Num a) => a
05:41:56 <daf> :t ((-) 1)
05:41:57 <lambdabot> forall t. (Num t) => t -> t
05:42:26 <Philonous> > ((-) 1) 3
05:42:27 <lambdabot>   -2
05:42:29 <daf> @check \x -> (-) x 1 == substract 1 x
05:42:29 <lambdabot>   Not in scope: `substract'
05:42:33 <daf> @check \x -> (-) x 1 == subtract 1 x
05:42:34 <lambdabot>   "OK, passed 500 tests."
05:43:16 <toliko_smoren> hey how can I user < and > in patterns, something like   case x of
05:43:16 <toliko_smoren>                                                            <0 -> Just (Key 'j' True)
05:43:27 <daf> toliko_smoren: use guards instead
05:43:45 <daf> toliko_smoren: or if/else
05:44:07 <toliko_smoren> this is inside a function, not at the beggining so I dont think I can use guards?
05:44:20 <toliko_smoren> I just thought case of would look nicer than bunch of nested if/elses
05:44:37 <idnar> toliko_smoren: defined a helper function with a where clause, or something
05:44:37 <daf> then use: case x < 0 of; True -> ...
05:44:46 <daf> :)
05:44:54 <idnar> *define
05:45:02 <idnar> is "where clause" the proper name for that?
05:45:12 <toliko_smoren> ah thanks
05:45:20 <toliko_smoren> havent thought of that
05:45:24 <Philonous> or case compare x 0
05:46:49 <doserj> > let x = 3 in case x of _ | x < 0 -> False | x > 0 -> False
05:46:50 <lambdabot>   False
05:51:15 <toliko_smoren> is there a function that takes (Maybe a) and returns an a, or a way to do that?
05:51:38 <idnar> toliko_smoren: what do you want it to do with Nothing?
05:51:42 <idnar> @type fromMaybe
05:51:43 <lambdabot> forall a. a -> Maybe a -> a
05:52:01 <toliko_smoren> well its never going to be nothing
05:52:07 <idnar> > fromMaybe 10 Just 5
05:52:08 <lambdabot>   Couldn't match expected type `Maybe t'
05:52:11 <idnar> > fromMaybe 10 (Just 5)
05:52:12 <lambdabot>   5
05:52:15 <idnar> > fromMaybe 10 Nothing
05:52:17 <lambdabot>   10
05:52:27 <Cheshire> toliko_smoren don't put it in Just then
05:52:32 <ImInYourMonad> what can I do with Applicative? if i have a module Vector for example, doe sit allow me to define mroe things like fmap?
05:52:38 <toliko_smoren> i'll paste you what i get an error with so you understand
05:52:43 <Cheshire> toliko_smoren or program in Maybe monad
05:54:11 <toliko_smoren> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2094#a2094 here, see getFurtherAI returns a maybe, and i take care of nothing, but then cant do compare on something that is always just
05:54:17 <toliko_smoren> i dont know monads yet
05:54:28 <Cheshire> toliko_smoren don't put it in Just then
05:54:37 <toliko_smoren> it has to be
05:54:41 <Cheshire> no it doesn't
05:54:46 <toliko_smoren> because sometimes i will not get a result
05:54:49 <toliko_smoren> check the paste i put
05:54:54 <Cheshire> I did
05:55:08 <toliko_smoren> so the function returns a maybe
05:55:12 <toliko_smoren> i deal with nothing
05:55:32 <Ferdirand> use pattern matching
05:55:56 <toliko_smoren> i think fromMaybe does the thing i want
05:55:57 <Ferdirand> ah no, sorry
05:55:59 <Cheshire> toliko_smoren why don't yop paste the intere thing
05:56:13 <Cheshire> I don't think fromMaybe does ...
05:56:40 <doserj> toliko_smoren: you can pattern match on Just x instead of otherwise
05:57:45 <toliko_smoren> doserj: thanks thats brilliant, havent thought of that
05:58:38 <doserj> (the pattern match on otherwise doesn't do what you probably think it does, anyways...)
05:59:39 <Cheshire> toliko_smoren, you only pasted half hthe function
06:00:40 <toliko_smoren> it works now, thanks for the effort
06:00:53 <Cheshire> what works?
06:01:29 <toliko_smoren> the function, when i use pattern matching on Just x instead of otherwise
06:01:39 <Cheshire> paste it ?
06:02:11 <toliko_smoren> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2095#a2095
06:02:57 <Cheshire> you can do getFurtherAI board piece 0 y rather than (((getFurtherAI board piece 0 y)))
06:03:28 <pozic> But then you are throwing away parentheses!
06:04:09 <EvilTerran> similarly, "case compare m x of"
06:06:02 <ImInYourMonad> instance (Num v) => Num (Vector v) ; when declaring that then v1*v2 must be a resulting vector not a Double?
06:06:30 <toliko_smoren> i do know that, but I overuse parenthesess because most of my errors are a result of lack of them, I do periodically clean up my code
06:06:40 <EvilTerran> ImInYourMonad, yes; the Num class isn't really suitable for vectors if you want * to be dot-product
06:10:47 <byorgey> more to the point, * is not a suitable operator name for dot-product, because it is in the Num class.
06:13:52 <chessguy_work> @let result = (.)
06:13:53 <lambdabot>  Defined.
06:14:00 <chessguy_work> @let argument = flip (.)
06:14:01 <lambdabot>  Defined.
06:14:15 <chessguy_work> @type result (\c -> 3)
06:14:16 <lambdabot> forall b t a. (Num t) => (a -> b) -> a -> t
06:14:49 <chessguy_work> @type result (+1) (\c -> 3)
06:14:50 <lambdabot> forall b a. (Num b) => a -> b
06:15:18 <chessguy_work> @type argument (+1) (\c -> 3)
06:15:19 <lambdabot> forall a t. (Num t, Num a) => a -> t
06:15:42 <EvilTerran> > (result (+1) . argument (*2)) f x :: Expr
06:15:43 <lambdabot>   f (x * 2) + 1
06:16:25 <EvilTerran> > result (argument (+1)) f x y :: Expr
06:16:27 <lambdabot>   f x (y + 1)
06:17:06 <chessguy_work> @type argument (+1) (\c -> 3) $ 5
06:17:07 <lambdabot> forall t. (Num t) => t
06:17:14 <chessguy_work> > argument (+1) (\c -> 3) $ 5
06:17:16 <lambdabot>   3
06:17:41 <chessguy_work> > argument (+1) (\c -> c * 3) $ 5
06:17:43 <lambdabot>   18
06:18:05 <chessguy_work> why does that seem so bizarre to me?
06:20:45 <doserj> does it?
06:20:56 <chessguy_work> i feel like i must not have ever truly understood the power of (.) before
06:21:29 <Cheshire> > (+1) . (* 3) $ 5
06:21:30 <lambdabot>   16
06:21:36 <Cheshire> > (* 3) . (+1) $ 5
06:21:37 <lambdabot>   18
06:21:44 <Cheshire> I think it's a pig in zebra clothing
06:21:53 <Cheshire> @farmer
06:21:54 <lambdabot> Hold your cool!
06:22:02 <chessguy_work> @help farmer
06:22:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:22:11 <chessguy_work> @help farber
06:22:12 <lambdabot> Farberisms in the style of David Farber.
06:22:35 <pejo> "Data Flow optimization made simple", another interesting paper: http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/dfopt.pdf
06:22:40 <chessguy_work> Cheshire, why do you say that?
06:31:53 <toliko_smoren> is there a function that returns a IO() and pauses the program for set amount of miliseconds?
06:32:05 <opqdonut> ?hoogle sleep
06:32:06 <lambdabot> No results found
06:32:20 <chessguy_work> @hoogle snore
06:32:20 <lambdabot> Data.Generics.Basics isNorepType :: DataType -> Bool
06:32:27 * chessguy_work does a doubletake
06:32:27 <opqdonut>  there is threadsleep or something
06:32:29 <MyCatVerbs> toliko_smoren: in Control.Concurrent, I just forgot the name.
06:32:47 <opqdonut> threadSleep or somethintg
06:35:09 <chessguy_work> @brows Control.Concurrent
06:35:09 <lambdabot> Unknown command, try @list
06:35:13 <chessguy_work> @browse Control.Concurrent
06:35:13 <lambdabot> Unknown command, try @list
06:35:45 <ImOuttaYourMonad> if I mke a computer game and I need separate threads for playing music and sound effects, what would I use? would I handle that in in OpenAL instead of in my own threads?
06:36:01 <Cheshire> use OpenAL then you don't have to futz with threading
06:36:17 <toliko_smoren> threadDelay
06:37:04 <chessguy_work> > (second.result.first) (3,\c -> ("abc",4))
06:37:05 <lambdabot>   Couldn't match expected type `(->)' against inferred type `(,)'
06:37:22 <chessguy_work> @type (second.result.first) (3,\c -> ("abc",4))
06:37:23 <lambdabot>     Couldn't match expected type `(->)' against inferred type `(,)'
06:37:23 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
06:37:23 <lambdabot>     In the first argument of `(second . result . first)', namely
06:37:25 <toliko_smoren> but threadDelay makes my program hang
06:37:46 <chessguy_work> @type (second.result.first) reverse (3,\c -> ("abc",4))
06:37:47 <lambdabot> forall d a d1. (Num d1, Num d) => (d, a -> ([Char], d1))
06:38:07 <chessguy_work> @type (second.result.first) reverse
06:38:09 <lambdabot> forall d a d1 a1. (d, a -> ([a1], d1)) -> (d, a -> ([a1], d1))
06:38:35 <chessguy_work> @type (second.result.first)
06:38:36 <lambdabot> forall d a b c d1. (b -> c) -> (d, a -> (b, d1)) -> (d, a -> (c, d1))
06:40:38 <chessguy_work> > fmap (+1) (2,3)
06:40:39 <lambdabot>   (2,4)
06:41:02 <chessguy_work> hm, that's an interesting Functor instance
06:41:32 <gnuvince> @src fmap (a, b)
06:41:32 <lambdabot> Source not found. My pet ferret can type better than you!
06:41:41 <EvilTerran> chessguy_work, well, it's the only one that'd work for non-newtyped pairs
06:41:50 <Cheshire> @src fmap (,)
06:41:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:41:52 <Cheshire> @src fmap (,) e
06:41:52 <lambdabot> Source not found. There are some things that I just don't know.
06:41:58 <Cheshire> @src (,) fmap
06:41:58 <lambdabot> fmap f (x,y) = (x, f y)
06:41:58 <EvilTerran> seeing as it'd have to be "instance Functor (a,)" for the kinds to work out
06:42:11 <chessguy_work> mm, good call
06:42:39 <EvilTerran> fits nicely with the anonymous writer monad, too
06:43:28 <ImOuttaYourMonad> to really do an mp3decoder, is that a huge project? i want to learn more about signal processing. and i am making an mp3player(just not usign my own decoder). but is it like 2 uni-courses to really grok how to make a good decoder?
06:43:41 <gnuvince> @src Maybe compare
06:43:41 <lambdabot> Source not found. :(
06:45:01 <dmwit> ImOuttaYourMonad: No, it's doable.  There's even an article about it, complete with code and everything.
06:45:47 <dmwit> ?go haskell mp3 decoder
06:45:52 <lambdabot> http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
06:45:52 <lambdabot> Title: blog.bjrn.se: Let’s build an MP3-decoder!
06:47:53 <quicksilver> depends how you define "grok" I guess.
06:48:12 <quicksilver> to really grok all the maths involved certainly involves material from several university level courses
06:48:21 <quicksilver> to just write the code based on a description, not so much.
06:49:18 <pozic> I think passing exams for said subjects is much easier than writing a working decoder _and_ being able to explain why it works.
06:50:24 <chessguy_work> @type (.)
06:50:25 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:51:01 <pozic> Exams are an artificial situation in which only relatively simple questions can be asked, because there is a small finite amount of time only available to answer the questions. Anything involving creativity can take much longer than that.
06:51:58 <chessguy_work> @type (result.first)
06:51:59 <lambdabot> forall a b c d. (b -> c) -> (a -> (b, d)) -> a -> (c, d)
06:52:01 <toliko_smoren> hey, why does ran <-  randomRIO (0,1000)    if ran==0 throw an ambigous type variable error?
06:52:40 <doserj> what type did you expect ran to have?
06:53:03 <toliko_smoren> any Num will do
06:53:22 <chessguy_work> @type randomRIO
06:53:23 <lambdabot> forall a. (Random a) => (a, a) -> IO a
06:53:31 <doserj> yes, that's the point. But randomRIO has to know, which one
06:53:49 <chessguy_work> can semantic editor combinators be used to actually _extract_ values at particular paths?
06:54:03 <toliko_smoren> but cant it deduce from the 0,1000 i used as arguments?
06:54:03 <Cheshire> semantic editor combinators is a silly name btw
06:54:16 <toliko_smoren> how do i i tell its its an Int for example
06:54:24 <doserj> @type 0
06:54:25 <lambdabot> forall t. (Num t) => t
06:54:39 <chessguy_work> Cheshire, if you have something of substance to say, i wish you'd just say it instead of just taking the annoying potshots at the idea
06:54:50 <Cheshire> i'll just /ignore you
06:54:50 <fasta> Cheshire: they are semantic, so they surely mean something.
06:55:19 <fasta> Cheshire: (that was a joke btw) ;)
06:55:23 <doserj> ran <- (randomRIO (0,1000)::Double), for example
06:55:37 <chessguy_work> your loss
06:55:56 <toliko_smoren> thnkas
06:55:58 <toliko_smoren> thanks
06:56:21 <quicksilver> Cheshire: I second chessguy_work's opinion. Please try to be constructive.
06:57:08 <Cheshire> quicksilver: no it's a lot easier to just /ignore someone then I don't talk to them and they have no reason to bitch at me
06:57:33 <titusg> When I switched to ghc 6.10 haskell-mode started acting up. In the ghci buffer it now echoes what I type in in a weird way. The response to 'id 1' is id 1^J1. Anyone else?
06:57:35 <chessguy_work> yeah, that's clearly the mature solution
06:57:35 <EvilTerran> Cheshire, you seem to misunderstand the character of this channel
06:57:46 <quicksilver> Cheshire: Who you /ignore or don't /ignore is none of my business.
06:58:05 <quicksilver> Cheshire: however I am requesting you to aim to be constructive in your comments.
06:58:16 <titusg> I'm using emacs 23 on ubuntu btw
06:58:50 <pejo> titusg, http://blog.ox.cx/2009/02/06/ghci-and-emacs/
06:59:00 <fasta> Cheshire can do whatever he wants. He just expressed his opinion.
06:59:09 <chessguy_work> @djinn (a -> (b, c)) -> b
06:59:09 <lambdabot> -- f cannot be realized.
06:59:46 <idnar> chessguy_work: do you mean a -> (a -> (b, c)) -> b ?
06:59:56 <chessguy_work> idnar, nope
07:00:24 <idnar> I don't see how you can get b out of (a -> (b, c)) without having a way to get an a
07:00:38 <chessguy_work> but maybe i mean (a -> (b, c)) -> (a -> b)
07:00:39 <titusg> pejo: thanks, I didn't think anyone would have a solution so quickly! :-)
07:00:41 <wjt> (a -> (b,c)) can't depend on a
07:00:54 <quicksilver> @djinn (a -> (b,c)) -> (a -> b)
07:00:55 <lambdabot> f a b =
07:00:55 <lambdabot>     case a b of
07:00:55 <lambdabot>     (c, _) -> c
07:00:55 <idnar> @type (fst .)
07:00:56 <lambdabot> forall a b a1. (a1 -> (a, b)) -> a1 -> a
07:00:58 <quicksilver> tada ;)
07:01:08 <wjt> @type (fst . ($ undefined))
07:01:09 <lambdabot> forall a b a1. (a1 -> (a, b)) -> a
07:01:13 <chessguy_work> @unpl (fst .)
07:01:13 <lambdabot> (\ a d -> fst (a d))
07:05:05 <lokathor> I'm using parsec, and I regularly want to try one of several strings, so I wrote: oneOfStr vals = foldr1 (<|>) (map (\a -> (try (string a))) vals)
07:05:37 <lokathor> so my question is, since it's a foldr, wouldn't it end up trying each option in the list in reverse order of the list?
07:06:08 <quicksilver> lokathor: no.
07:06:19 <quicksilver> association isn't operation order.
07:06:35 <quicksilver> (a <|> (b <|> (c <|> d))) is assoicated to the right
07:06:39 <ImOuttaYourMonad> man i really have a hard time with inserting into red black trees in haskell. in C using pointer sit would be easy but in haskell i still dont get how to really match uncle and grandparent
07:06:41 <quicksilver> but that doesn't mean d gets tried first.
07:06:58 <lokathor> ah ha, okay
07:08:16 <lokathor> I read a bit about folds last night and it seems that foldr is way better than foldl, but i've only really used foldl' for math stuff, so i'm still not familiar with the greatness of foldr
07:08:43 <chessguy_work> lokathor, it depends on what you're doing
07:09:22 <chessguy_work> > foldl' f [1,2,3]
07:09:23 <lambdabot>       Overlapping instances for Show ([b] -> [t])
07:09:23 <lambdabot>        arising from a use o...
07:09:31 <pejo> ImO, have you read suitable parts of Okasaki's thesis?
07:09:41 <chessguy_work> > foldl' f 0 [1,2,3]
07:09:41 <lambdabot>   Add a type signature
07:09:42 <pejo> Imo, (or the book).
07:09:45 <MyCatVerbs> ImOuttaYourMonad: I'd recommend, if you can find a copy, Okasaki's book "Purely Functional Data Structures". Or his thesis, which is a much smaller version of the same.
07:09:49 <chessguy_work> > foldl' f 0 [1,2,3] :: Expr
07:09:51 <lambdabot>   f (f (f 0 1) 2) 3
07:09:59 <chessguy_work> > foldr f 0 [1,2,3] :: Expr
07:10:00 <lambdabot>   f 1 (f 2 (f 3 0))
07:10:55 <MyCatVerbs> ImOuttaYourMonad: turns out it's actually much easier than the C version, but it's not an entirely direct transformation, because the Haskell version uses copying exclusively, whereas the C version modifies pointers in-place.
07:11:08 <lokathor> I guess.. doesn't foldl' use up less stack space?
07:11:11 <MyCatVerbs> ImOuttaYourMonad: well, somewhat easier, anyway. There are a few less cases to consider in a couple of places.
07:11:30 <lokathor> or, er.. memory, because you accumulate fewer thunks
07:12:11 <MyCatVerbs> lokathor: foldl' doesn't build large thunks, provided WHNF is enough to completely evaluate the data structure that you're using for your accumulator. The stack space problem is where the RTS uses an extra stack frame for every nested thunk. :)
07:12:22 <MyCatVerbs> s/large thunks/long chains of thunks/
07:15:09 <quicksilver> general rule is foldl' for folds to a single summary value and foldr for folds which produce a complex structure which you can consume lazily
07:16:11 <lokathor> I also looked up WHNF; who came up with such a strange term
07:17:53 <quicksilver> I think it "evolved"
07:18:05 <quicksilver> from Normal Form, which is a fairly natural term
07:18:31 <lokathor> i guess
07:18:40 <lokathor> "weak head" seems strange
07:19:11 <MyCatVerbs> It is a bit. Ah well.
07:19:43 <MyCatVerbs> Presumably there really ought to be a foldl'' which uses rnf instead of rwhnf (i.e. seq) at every step.
07:19:58 <lokathor> that, to me, is one of haskell's failing points;; I'm not very math literate, so many things seem needlessly bizarre, and the explanations on haskell.org and such often times just don't help
07:21:02 <quicksilver> MyCatVerbs: in general overuse of rnf pushes up the complexity of your program though
07:21:13 <quicksilver> MyCatVerbs: seq is O(1), at least. rnf is O(n).
07:21:16 <quicksilver> "typically"
07:21:30 <lokathor> wait wait, what's RNF?
07:21:31 <quicksilver> so your foldl'' is likely to be quadratic, depending exactly what you're doing.
07:21:42 <quicksilver> lokathor: reduce to normal form
07:21:43 <MyCatVerbs> lokathor: the 'r' is just 'reduce'. NF is normal form.
07:21:49 <quicksilver> @hoogle rnf
07:21:50 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
07:22:14 <MyCatVerbs> lokathor: as opposed to seq, which just does rwhnf. Reduce to Weak Head Normal Form. :)
07:22:32 <lokathor> lambdabot is knowledgeable, but oft inscrutable
07:22:58 <pejo> lokathor, it's the curse of knowledge: the people who wrote this don't remember what it was like to not know all the stuff they have absorbed.
07:23:03 <MyCatVerbs> lokathor: the signatures in Control.Parallel.Strategies *all* look like that. Fortunately they're easier to use in practice than you might expect.
07:23:11 <MyCatVerbs> (from the type signatures, I mean)
07:23:15 <pejo> lokathor, isn't it a wiki though, so you could improve it when you find things out?
07:23:25 <ertai_> I'm trying to play with DPH and can't make a 'enumFromTo x y' neither a [: x..y :]
07:23:25 <lokathor> yeah, haskell.org could use a lot of "use case" examples
07:23:55 <MyCatVerbs> quicksilver: yeah, but if your goal is to eliminate thunks... seq-ing a data structure with several lazy fields gives you k-thunks, as opposed to just the one for the data structure's top.
07:24:25 <MyCatVerbs> lokathor: agreed. The Haddock docs, even more.
07:24:48 <quicksilver> MyCatVerbs: true. Typically in that case the data structure shouldn't be lazy.
07:25:10 <quicksilver> MyCatVerbs: if the data structure actually *is* supposed to be lazy, then you probably want a correct Strategy which describes what you wanted.
07:25:15 <ImOuttaYourMonad> i cant find the rb-trees in okasakis paper, what page?
07:25:18 <quicksilver> MyCatVerbs: so we want foldl'withStrategy ;)
07:32:33 <MyCatVerbs> quicksilver: ooooh yes, very good idea indeed.
07:42:12 <pozic> What does this error message mean exactly?  Non-exhaustive patterns in record update I had a similar error before, but then it mentioned exactly which field was not initialized.
07:48:15 <Herald> hi, im trying to write a test data generator for quickcheck, and im totally baffled by this 'arbitrary', 'gen' business. i just want a generator to build an Int list of length n - any examples someone could offer me?
07:53:45 <doserj> pozic: sounds like you are using a record update x { y = ... }, where the field y is not defined for all of the variants of x
07:54:05 <alinp> hi
07:54:13 <alinp> how is possible to unload prelude ?
07:54:23 <Cheshire> import qualified Prelude
07:54:24 <doserj> import Prelude ()
07:54:33 <alinp> oh, I see
07:55:12 <alinp> (maybe a stupid q: ) ghc REPL can run without prelude ?
07:55:29 <alinp> I mean, running ghci without loading prelude is possible ?
07:55:34 <Cheshire> not stupid
07:56:09 <alinp> the thing is that I want to learn some stuff, and the examples are something like defining "." function
07:56:15 <alinp> or map function
07:56:15 <alinp> etc
07:56:35 <alinp> and I can't do this without writing other module
07:56:46 <doserj> alinp: load a haskell file which includes "import Prelude ()"
07:57:12 <alinp> oh, ok
07:57:17 <alinp> thank you doserj
07:59:47 <alinp> is it possible to include Prelude but when doing it, to exclude a specific function ?
08:00:04 <alinp> (from Prelude module, ofc)
08:00:09 <LeoD> import Prelude hiding (foo)
08:00:12 <weihsiu> @src groupBy
08:00:12 <lambdabot> groupBy _  []       =  []
08:00:12 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:00:12 <lambdabot>     where (ys,zs) = span (eq x) xs
08:00:43 <alinp> oh
08:00:49 <alinp> hiding is the catch
08:00:53 <alinp> thanks weihsiu
08:01:18 <roconnor> @ask kniu did that list of colours idea work out for you?
08:01:18 <lambdabot> Consider it noted.
08:02:18 <dons> wrote about speeding up the binary trees benchmark by parallelising it http://www.reddit.com/r/programming/comments/8221u/playing_with_ghc_haskells_parallel_runtime/
08:09:37 <cjb> dons: aw, I wanted it to end with an even better number for n=16 :)
08:10:09 <alinp> I have 2 files: FileOne.hs and FileTwo.hs
08:10:17 <alinp> both of them: module FileOne where ...
08:10:22 <alinp> module FileTwo where ...
08:10:32 <alinp> in FileTwo how can I import FileOne module ?
08:11:00 <alinp> import FileOne, doesn't work
08:11:04 <ImOuttaYourMonad> i cant find red black trees in okasakis paper
08:11:06 <alinp> it seems that is not finding it
08:11:26 <ImOuttaYourMonad> how do you people use QuickCheck, where di you get it? pull it with apt-get?
08:11:38 <pejo> dons, couldn't the entire tree be deforested away, or is that illegal under the rules?
08:11:57 <chessguy_work> ImOuttaYourMonad, it's in the standard library
08:12:05 <quicksilver> alinp: it shuold work if they're both in the same directory.
08:12:11 <alinp> hmmm
08:12:13 <quicksilver> (and that's the directory you're running ghc from)
08:12:22 <MyCatVerbs> ImOuttaYourMonad: me either. I think it's just in the book, sorry.
08:12:23 <alinp> shouldn't I specify the file ?
08:12:42 <quicksilver> ImOuttaYourMonad: apt-get install libghc6-quickcheck-dev
08:12:55 <quicksilver> alinp: it always looks for 'Foo.hs' for the module Foo
08:13:03 <alinp> module needs to have the exact name (case sensitive) as the file ?
08:13:05 <quicksilver> or 'Foo/Bar.hs' for the module Foo.Bar
08:13:07 <quicksilver> yes.
08:13:11 <alinp> oh, I see
08:13:12 <alinp> thanks
08:13:50 <quicksilver> the "standard library" which chessguy_work refers to is really the extralibs
08:14:00 <quicksilver> they're bundled in the big installer packages, but separate in most distros.
08:14:00 <MyCatVerbs> ImOuttaYourMonad: anyway. Data.Map has a pretty well-tuned search tree implementation.
08:14:29 <chessguy_work> oh, huh.
08:14:31 <chessguy_work> didn't know that
08:20:58 <dons> cjb: oh, for N=16?
08:23:40 <dons> cjb: good point. updated.
08:27:08 <ImOuttaYourMonad> chessguy_work: so how do you import QuickCheck?
08:27:28 <Gracenotes> :O
08:27:56 <Gracenotes> with sugar and spice and everything Test.QuickCheck
08:28:10 <ImOuttaYourMonad> what do i need to read .ps?
08:28:57 <quicksilver> ImOuttaYourMonad: ghostscript.
08:30:21 <bremner> ImOuttaYourMonad: it is not a big deal, but the changing nicks thing gets a bit old at least IMHO. Unless all those other ImInX or ImOutOfY nicks are not really you :-)
08:31:23 <ImOuttaYourMonad> should a red-black-tree be a set? ie no duplicates? or is that an implementation choice? same question for BSTs?
08:32:56 <ImOuttaYourMonad> bremner: i have 2 nicks, mirc forcs you to sepcify an altenrativ,e i guess it happens when you lose connectin and reconncet. those are chosen so i am easily recognized as the same person. why does anyone care about an irc nick anyway?
08:33:25 <Baughn> ImOuttaYourMonad: A set; no key duplicates.
08:33:35 <Baughn> ImOuttaYourMonad: If you want to store multiple values for one key, /use a list/
08:34:11 <Baughn> (It might be useful to have that abstraction too, but you can build it very easily on top of the no-duplicate tree. There's no reason the tree should care.)
08:35:06 <ImOuttaYourMonad> and that si true for BST too? no duplicates?
08:35:28 <Baughn> Duplicate keys just wouldn't make sense..
08:36:18 <quicksilver> Baughn: there are reasons to prefer B-tree like structures which permit duplicate keys
08:36:23 <quicksilver> Baughn: (over those with key-chaining)
08:36:35 <quicksilver> but they're moderately obscure and relate to particular use cases.
08:36:50 <Baughn> Hmm. I'd love to see it, if you've got a link at hand.
08:37:15 <quicksilver> basically it's when you want fast access and you don't care which answer you get
08:37:27 <quicksilver> (between duplicate keys)
08:37:42 <quicksilver> where it's more important to have predictable access speed
08:37:52 <quicksilver> and chaining techniques slow down access speed.
08:38:02 <ImOuttaYourMonad> why wouldnt duplicate keys make sense, when do you use a BST?
08:38:26 <Baughn> ImOuttaYourMonad: Well, how would the tree look?
08:38:37 <Baughn> quicksilver: ..I can just about see that... but not quite
08:38:41 <Gracenotes> @pl \f v c -> (f v) + c
08:38:42 <lambdabot> ((+) .)
08:38:49 <pumpkin> you just decide on <= being left and > being right, or something
08:38:54 <quicksilver> Baughn: like I say, it's an obscure care, not a common one.
08:38:57 <bremner> ImOuttaYourMonad: well, for example, highlighting works better if the alternative nick contains the primary as a substring.  It also helps befuddled people like me keep track of who they are talking to. Anyway, let's drop it.
08:39:18 <pumpkin> bremner: I tend to agree :P
08:39:41 <chessguy_work> hmm, i'm trying to figure out of you can use semantic editors to modify pipelines like "f . g . h"....like i wonder if you could somehow replace g in that expression with g'
08:40:02 <quicksilver> chessguy_work: not with (.) as it is defined, no.
08:40:10 <quicksilver> functions are not destructurable.
08:40:25 <quicksilver> but you could lift the (.) to an abstract, inspectable version
08:40:28 <quicksilver> and then edit that.
08:40:30 <chessguy_work> quicksilver, hm, even if you wrote it out?
08:41:01 <quicksilver> f . id . g is the same function as f . g
08:41:06 <quicksilver> that's referential transparency.
08:41:11 <quicksilver> there is no way of distinuishing them
08:41:21 <quicksilver> so tere is no way to write a function which 'edits' the middle component.
08:41:30 <quicksilver> but you could have an AST-type representation, which was editable.
08:41:40 <quicksilver> Compose [f,id,g]
08:41:47 <Gracenotes> can RULES be used here?
08:42:01 <Cheshire> you want to use something like a thrist rather than list
08:42:13 <quicksilver> interpret (Compose fs) = foldr (.) id fs
08:42:38 <quicksilver> yes, that's true Cheshire
08:42:49 <quicksilver> but I was simplifying for ease of explanation.
08:42:49 <idnar> what's a thrist?
08:42:57 <quicksilver> "domino-rule" list
08:43:12 <quicksilver> (a b) must compose with (b something)
08:43:46 <Cheshire> data R (^) a z where Cons :: x ^ y -> R y z -> R x z ; Nil :: R x x
08:43:50 <Cheshire> idnar
08:44:12 <Cheshire> (dunno if ^ is valid but the idea is that it's any type * -> * -> *, for example (->))
08:44:43 <ImOuttaYourMonad> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#jfp99 <- ok i foudn the red black treee but it only seems to have the first side, can you see the rest?
08:45:03 <conal> chessguy_work: the "semantic" in semantic editor combinators refers to acting on meanings/values themselves, rather than constructions/recipies for meanings/values.
08:45:17 <ImOuttaYourMonad> *BinarySearchTree> treeFromList [1,2,1]
08:45:17 <ImOuttaYourMonad> Node 1 (Node 1 Leaf Leaf) (Node 2 Leaf Leaf)
08:45:19 <chessguy_work> oh, the man himself :)
08:45:47 <idnar> Cheshire: hmm
08:45:58 <conal> chessguy_work: so to replace g in f . g . h, you'd have to do something like compose with the inverse of h and the inverse of g
08:46:04 <ImOuttaYourMonad> ^^ whats wrong with that bst?
08:46:08 <ImOuttaYourMonad> dup keys
08:46:21 <idnar> Cheshire: interesting
08:46:22 <conal> chessguy_work: consider replacing 4 in *value* of 3 + 4 + 5
08:47:04 <chessguy_work> well of course replacement is just one type of editing
08:47:23 <chessguy_work> generally, i'd like to *modify* g, not just replace it
08:47:50 <conal> chessguy_work: which subsumes replacement, so even more ambitious.
08:48:26 <chessguy_work> but we would indeed be editing the semantics in the process
08:50:24 <chessguy_work> so really semantic editor combinators are sort of editing the structure of the semantics in some way
08:50:57 <conal> yeah
08:51:14 <conal> and syntax has more structure than semantics.
08:51:25 <conal> i.e., it makes more distinctions
08:51:48 <chessguy_work> hm
08:52:21 <conal> e.g., it distinguishes between 3+4 and 7, while semantics doesn't.
08:52:57 <chessguy_work> ah, which is why semantic editors can't editthem differently. gotcha
08:53:06 <conal> yeah!
08:53:34 <conal> and it's why syntax has no non-trivial equational properties.
08:54:14 <chessguy_work> hm. i don't get that statement
08:54:47 <conal> e.g., "3+4" /= "4+3"
08:55:06 <chessguy_work> ok
08:55:41 <conal> and i'm using strings here, but i really mean trees.
08:55:51 <chessguy_work> sure
08:55:51 <quicksilver> conal: well, haskell syntax satisfies "3+(4*5)" = "3+4*5" and "(1+(2+3))" = "1+2+3"
08:56:05 <quicksilver> conal: at least, the common implementation does.
08:56:17 <quicksilver> conal: so sometimes we push a few equations down to the syntax
08:56:20 <conal> quicksilver: you're talking about concrete syntax, right?
08:56:20 <quicksilver> but not much.
08:56:46 <quicksilver> well, the abstract syntax makes equal some things which appear different at the level of concrete syntax.
08:57:42 <ImOuttaYourMonad> what is the word for male gay?
08:58:00 <conal> "concrete" & "abstract", "syntactic" & "semantic" are not really properties of a thing.  more like roles in a relationship.
08:58:45 <quicksilver> ImOuttaYourMonad: out of topic in this channel.
08:58:46 <Cheshire> text --(extra ()'s and whitespace)--> ast --(reduction rules and variable lookup)--> semantics
08:59:05 <Cheshire> variable lookup/unfolding definitions
09:00:11 <Cheshire> so semantics is to syntax as  syntax can be to textual representation ?
09:00:24 <Nafai> Is hpaste hard to deploy?
09:00:29 <Cheshire> we're just quotienting by a different relation
09:00:31 <Nafai> I want to have my own pastebin somewhere
09:00:42 <conal> Cheshire: yeah.
09:01:19 <conal> as another example: define an algebraic data type.  its values are both meanings of syntax and syntax for other meanings.
09:01:22 <gnut> if I want to have some global information carried around, should I make constant functions? or use the State monad?
09:02:11 <conal> gnut: there's rarely a use for constant functions in haskell.
09:02:11 <chessguy_work> that would be an AST, wouldn't it?
09:02:11 <Cheshire> a nice property we seem to get is that if you go from    ast --> semantics --> ast,, you get an equivalent term in normal form
09:02:29 <quicksilver> Cheshire: yes, although the text/ast layer is somehow trivial, while the ast/semantic layer is somehow deeply important :)
09:02:37 <Cheshire> should just say  syntax --(eval)--> semantics --(quote)--> syntax
09:03:06 <Cheshire> quicksilver, at the moment it seems more cool to think about semantics and stuff yeah
09:04:25 <Cheshire> (my guess is because people think syntax means if you write (LAMBDA (X) ..) or \x -> ... which is not true)
09:05:50 <conal> i'm suggesting that "syntax" and "semantics" as *properties* is a short-hand only for syntax & semantics as roles in relationships.  and that as properties everything is syntax and everything is semantics.
09:06:13 <gnut> conal: I'm writing some haskell that interfaces with C, and the C functions annoyingly want the size of the matrix to be passed... I don't want to make that an argument for every function... so I'm torn between just making the global function n = 12 (for example), or using the State monad to carry all this and all my other constants around
09:06:20 * quicksilver has no idea what conal meant by that sentence.
09:06:23 <conal> meaning holds that role in relationship to something else.
09:06:35 <quicksilver> For me, syntax is a formal language which is easy to reason about from one perspective.
09:06:59 <quicksilver> and semantics is a model which relates somehow to the thing you were trying to predict or compute.
09:07:05 <conal> gnut: first, by "global function", do you mean a global definition?  i'm confused about the "function" part.
09:07:12 <ImOuttaYourMonad> we hacking gods should realyl get together on something huge and gamechanging in haskell. now i can even write red black trees some im ready for greatness!
09:07:21 <ImOuttaYourMonad> what big cool project is there?
09:07:47 <gnut> conal: yeah. I just mean something as simple as "n :: Int; n = 12"... I shouldn't have said global since it's all global.
09:08:21 <gnut> conal: basically, just a constant function. (no arguments)
09:08:23 <conal> gnut: yeah.  i'd use a global, non-function definition.
09:08:38 <chessguy_work> ImOuttaYourMonad, well if you ask some people, haskell won't be ready for prime time until we have an industrial-strength message-queuing library, so why don't you just go knock that out for us
09:09:04 <conal> gnut: are you coming from the everything-is-a-function perspective?
09:09:32 <gnut> conal: yeah. n(x) = 12 is the constant function..
09:09:51 <conal> gnut: you could as easily say everything is a pair.
09:09:59 <conal> n = (12,undefined)
09:10:08 <quicksilver> or everything is a set, or a category, or a hamster.
09:10:19 <conal> quicksilver: exactly.
09:10:21 <quicksilver> foundationalism can be absurd.
09:10:37 <conal> gnut: i've been curious where the everything-is-a-function idea came from.  do you know where, for you?
09:10:59 <conal> i can see how that idea could maintained but not arrived at.
09:11:20 <conal> gnut: and i realize it's off the question you were asking about.
09:11:28 <chessguy_work> it's sort of an extension of "every function is a function with a single input and a single output
09:11:31 <gnut> conal: hmm... well
09:11:57 <gnut> conal: simple math but not advanced enough to think of them as categories or hampsters
09:12:12 <conal> chessguy_work: yes, every *function* is.  but it's gone further, to every *value*.
09:12:39 <gnut> conal: I don't really care too much about calling it constant function or just constant non-function...
09:12:51 <Cheshire> n () = 12
09:12:54 <Cheshire> () -> Integer
09:13:06 <Cheshire> non-generalized element of Integer
09:13:10 <conal> (12, bottom) :: (Int, a)
09:13:26 <chessguy_work> lol
09:13:46 <gnut> I remember in my algebra class, the prof said the way of modern mathematics was to think of everything as functions
09:13:55 <chessguy_work> @type 3
09:13:56 <Cheshire> M -> Integer generalized element of Integer
09:13:57 <lambdabot> forall t. (Num t) => t
09:14:07 <gnut> he was probably alluding to category theory
09:14:08 <chessguy_work> hey look, it sorta kinda looks like a function, so it must be one!
09:14:11 <Cheshire> gnut, an Algebraist would say that :p
09:14:37 <conal> i'm happy with saying everything is a function, if we also say everything is a pair, and everything is a list.
09:14:43 <conal> and so on.
09:14:45 <gnut> Cheshire: heh
09:14:48 <chessguy_work> lol
09:15:18 <gnut> we could say that... and in one of my other classes, they treat functions as subsets
09:15:21 <Cheshire> in SET the category of sets, the objects are not functions they are sets
09:15:30 <doserj> But Haskell is based on lambda-calculus, and everything is a function in lambda-calculus, so everything must be a function in Haskell
09:15:33 <gnut> Cheshire: hehehe... yeah.
09:15:34 * doserj is kidding
09:16:09 <therp> I hope arch doesn't explode if I take away the arch kernel patch :)
09:16:17 <therp> sorry wrong channel
09:16:18 <conal> doserj: that story could well be the origin of everything-is-a-function.  from church's original lambda calculus.
09:16:58 <conal> doserj: and then "12 == \ _ -> 12" becomes a rationalization.
09:17:13 <Cheshire> then where is the everything-is-a-tape crowd?
09:17:14 <conal> since in church's story, 12 *already* is a function.
09:17:26 <Baughn> Thunks == nullary functions, more like
09:17:33 <Baughn> Memoized nullary functions. :P
09:17:42 <Cheshire> Baughn that seems like a lispy way to view it
09:17:52 <Baughn> Cheshire: I'm a lispy sort of guy
09:17:53 <iago_> all is a function in \-calculus???
09:17:55 <Cheshire> :p
09:17:56 <doserj> conal: it might, but I have no idea really
09:18:10 <conal> Baughn: i think the thunk thing is indeed another contributor, especially when people don't clearly separate semantics from implementation.
09:18:51 <conal> think thunk thing ....
09:19:22 <doserj> the practice of treating constants as special cases of functions (with 0 arguments) in algebraic theories, or logics, might also be related.
09:19:29 <tomh> if I do head $ words (readFile location), is the file only readed till i can get the first words?
09:19:31 <conal> again, i wonder if the thunk story is more about arriving the story or about hanging onto it.
09:20:04 <iago_> tomh, this won't work
09:20:21 <conal> doserj: first-order logics i imagine.  with higher-order systems, like haskell, i don't know when to stop wrapping const.
09:20:35 <quicksilver> conal: to imperative programmers 'function' means 'subroutine'
09:20:52 <tomh> iago_: ok, then with correct notation: do txt<- (readFile "text.txt");putStrLn (head $ words txt)
09:20:54 <doserj> But of course, this notions crash horribly if you internalize the concept of "function of 1 argument" as you do in lambda-calculus
09:20:54 <quicksilver> conal: since any thunk is capable of doing work, any thunk is a 'subroutine' and hence a 'function'
09:21:04 <quicksilver> conal: that's yet another path by which the terminology might arise.
09:21:18 <conal> quicksilver: makes sense to me.
09:21:39 <iago_> tomh, I'm not an expert but I don't see anything that fuck laziness so should be true
09:21:49 <tomh> ok
09:21:58 <tomh> maybe i should try it on a 5gb file
09:22:01 <tomh> or something
09:22:20 <quicksilver> tomh: yes, it will work
09:22:33 <quicksilver> it works because readFile uses the hacky interleaved IO execution kind of laziness
09:22:37 <quicksilver> but it can be useful.
09:22:41 <tomh> ok
09:22:53 <tomh> is there any way to see what happens under the hood?
09:24:26 <Baughn> tomh: strace can be surprisingly useful, once you filter out the timer stuff
09:24:51 <tomh> ok, gonna see how that works
09:25:38 <quicksilver> strace -etrace=file
09:25:43 <quicksilver> (if memory serves me correctly)
09:25:46 <quicksilver> something like that, anyway.
09:27:18 <tomh> ok thanks
09:28:43 <te> how does haskell match up to c?
09:28:48 <dons> not much
09:28:51 <dons> ?
09:29:01 <dons> but you can call into C, and C can call into Haskell...
09:29:19 <Nafai> Anyone else having problems "cabal install"ing hpaste?
09:29:20 <te> I didn't know that dons
09:29:30 <Nafai> It says it couldn't find an appropriate version of HApps
09:30:08 <mercury^> What do you mean with "match up to"?
09:33:30 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2098#a2098 <- ok why is ghc bitchin?
09:33:34 <ImOuttaYourMonad> rbt insert
09:33:48 <ImOuttaYourMonad> i mean ti says why
09:33:53 <ImOuttaYourMonad> but i dont get how to fix it
09:37:29 <Baughn> ImOuttaYourMonad: I suggest you start by typing out explicit types for your functions
09:41:49 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2098#a2099 <- done adding types
09:44:02 <doserj> ImOuttaYourMonad: your second line of the definition of balance doesn't match that type. and the calls to balance in ins do not match that type
09:48:20 <ImOuttaYourMonad> yeah it was a little z
09:48:26 <ImOuttaYourMonad> that was a punk
09:50:37 <ImOuttaYourMonad> so
09:50:38 <ImOuttaYourMonad> *RedBlackTree> insert (insert (insert empty 10) 20) 100
09:50:38 <ImOuttaYourMonad> Node Black 20 (Node Black 10 Leaf Leaf) (Node Black 100 Leaf Leaf)
09:50:41 <ImOuttaYourMonad> is thay ok?
09:51:09 <ImOuttaYourMonad> having black root and then the first children black too
09:51:26 <ImOuttaYourMonad> shoudltnt they be red? or that is jsut an impemntation choice that deosnt really matter
09:52:28 <Baughn> "Dwave systems is at 128 qubits now and could be at 2048 by the end of the 2009." <-- So much for RSA. We got any options?
09:52:47 <ImOuttaYourMonad> uh?
09:52:49 <dons> hah
09:53:07 <wli> Baughn: What's Dwave?
09:53:48 <wli> Baughn: Elliptic curve stuff gets more mileage per bit.
09:56:04 <Baughn> wli: A company working on adiabatic quantum computers. Or so they claim.
09:56:25 <Baughn> Mind you, by the time they get to 2048 qubits it should be extremely easy to demonstrate the claims
09:57:50 <lament> 128 qubits??
09:58:17 <lament> that's pretty neat!
09:58:32 <Baughn> lament: If it's trie. :P
09:58:35 <Baughn> *true
10:17:09 <toliko_smoren> hey, is there an mp3 library for haskell, and if not mp3 than an ogg or any other music format for that matter?
10:17:44 <toliko_smoren> i dont need anything fancy, just to play
10:18:21 <mle> toliko_smoren: there are libraries for wav and midi at least
10:19:15 <ImOuttaYourMonad> toliko_smoren: funny im doing the same, llokign for one, there is a toy-decoder on hackage and some mp3players, dons made one, it uses mpg321.
10:19:30 <ImOuttaYourMonad> im looking to use perhaps ffmpeg myself(C lib) and use it via FFI
10:20:09 <ImOuttaYourMonad> I havent found an obvious easy way to play an mp3 though
10:20:27 <toliko_smoren> i do not have much time, is there anything simple enough, like openFile "blabla.whatever" playFile: File -> IO ()
10:20:37 <toliko_smoren> any music format that has this level of simplicity?
10:20:59 <toliko_smoren> or a way to use a non-haskell library?
10:22:07 <araujo> ImOuttaYourMonad, stop going through channels and trolling
10:22:10 <araujo> about haskell
10:29:49 <Cheshire> araujo, that's not going to work he's been doing it for almost a year
10:30:14 <Cheshire> I had asked this guy to not do that several times already
10:31:53 <ImOuttaYourMonad> what the hell are you talking about?
10:32:04 <Cheshire> you
10:32:37 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2098#a2100 <- there is my rbt, just missing deletion now.
10:32:45 <ImOuttaYourMonad> im not trolling, im trying to learn
10:32:59 <ImOuttaYourMonad> why do you guys care so much what other people do anyway?
10:33:25 <araujo> ImOuttaYourMonad, because I think haskell doesn't need that kind of advertisement
10:33:29 <ImOuttaYourMonad> it is a lot faster than the BST but it still is kinda slow for worstcases
10:33:38 <dons> toliko_smoren: you want to bind to libsndfile or something?
10:33:40 <ImOuttaYourMonad> araujo: 1 example of what i ahve said...
10:33:51 <dons> ImOuttaYourMonad: is this on topic?
10:34:36 <araujo> ImOuttaYourMonad, you know what you have said, I just think it makes look bad to our community
10:35:39 <ImOuttaYourMonad> dons: im on topic, im giving advice on possible ways to play mp3s in haskell and im discussing red black trees in haskell
10:35:50 <ImOuttaYourMonad> araujo; no i dont know what i have said
10:36:10 <Cheshire> ImOuttaYourMonad, you're also playing games with people in #haskell
10:36:17 <Cheshire> ImOuttaYourMonad, would be good to stop doing that
10:36:50 <Alpounet> Hi all.
10:37:05 <ImOuttaYourMonad> Cheshire: huh, wtf?
10:37:14 <ImOuttaYourMonad> hi Alpounet
10:40:04 <pumpkin_> ImOuttaYourMonad: I think picking a single nick and one that didn't sound mocking (whether intentional or not) would go a long way to easing your interaction with the rest of the channel
10:41:56 <ImOuttaYourMonad> lol, how the hell is my nick mocking and can I help that mirc forces to nicks? i dont change it myself, mirc does ti when i deoccect reconnect or whatever
10:42:26 <maltem> Please, people
10:42:34 <maltem> Can't you move that discussion to #haskell-social or something
10:43:40 <pumpkin_> ImOuttaYourMonad: can you come to #haskell-blah ?
10:43:42 <ImOuttaYourMonad> they cant spell social so that would be hard
10:43:50 <dons> ImOuttaYourMonad: not appropriate. take it to #haskell-blah
10:45:00 <piksi> ImOuttaYourMonad: don't use mIRC, it's a horrible client.
10:45:56 <Alpounet> is there a function for getting the last N elts of a list ?
10:46:17 <maltem> Alpounet: reverse . take n . reverse
10:47:12 <wli> You have to traverse the entire list unless you have the length cached somewhere.
10:47:56 <asgaroth> Alpounet: drop (length lst - n) lst might be more efficient than reversing twice
10:48:07 <Alpounet> yeah, I had this in mind
10:48:18 <Alpounet> (the drop using the length)
10:48:34 <Alpounet> But I would like to know if there was a better way...
10:48:40 <Alpounet> It seems there aren't.
10:48:44 <Alpounet> Thanks all :)
10:48:55 <maltem> hm, as to which is more efficient, that should depend on how large n is wrt the list?
10:49:19 <Alpounet> it's a little list btw
10:55:39 <toliko_smoren> so yeah I was asking of a simple way to play music in a haskell program, any help?
10:55:49 <pumpkin_> toliko_smoren: if you're on linux
10:55:55 <pumpkin_> you can send samples directly to /dev/dsp
10:56:03 <pumpkin_> not sure what sampling rate or how to set it though
10:56:18 <toliko_smoren> linux-only not an option
10:56:51 <Alpounet> there are libs for such purposes
10:57:02 <pumpkin_> I think that's what he's asking about :P
10:57:02 <toliko_smoren> i am looking for one
10:57:08 <toliko_smoren> exactly :)
10:57:17 <Alpounet> like this : http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound
10:57:19 <Alpounet> ?
10:57:20 <Alpounet> :-p
10:58:52 <toliko_smoren> i cant find anything there that is not MIDI playing?
11:00:14 <Alpounet> hsSDL contains a module named mixer that lets you play sounds, e.g
11:00:21 <kryptiskt_> toliko_smoren: you could use the SDL bindigns
11:00:29 <kryptiskt_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL
11:00:35 <kryptiskt_> oops
11:00:35 <Alpounet> the openal binding is much more powerful but probably much more complicated
11:00:48 <Alpounet> However, don't know anything about CSound
11:00:58 <Alpounet> Neither Jack and Alsa bindinds
11:01:02 <Alpounet> +about
11:02:31 <alinp> hi
11:02:40 <alinp> Not in scope: `isLower'
11:02:48 <alinp> this is happening using Prelude
11:02:56 <alinp> any idea why ?
11:03:04 <alinp> should I import other module ?
11:03:15 <augustss> Data.Char
11:03:23 <toliko_smoren> sdl appears also to support only waw,
11:04:15 <alinp> augustss: thanks
11:04:33 <kryptiskt_> toliko_smoren: no, it suupports mp3s, at least libSDL itself does
11:04:53 <toliko_smoren> hm, I will look at it again
11:04:54 <toliko_smoren> thanks
11:05:19 <NameAlreadyInUse> is there any way to define a function that returns itself?
11:05:25 <Cheshire> yes
11:05:32 <Cheshire> thisFunctionHasNoName = thisFunctionHasNoName
11:06:13 <NameAlreadyInUse> i mean something like f x = f
11:06:32 <Cheshire> yes
11:06:50 <Cheshire> you must use data types to subvert the type checker in that case
11:07:12 <Cheshire> data YouNeverSawMe a = SawWho (YouNeverSawMe a -> a)
11:07:28 <kryptiskt_> toliko_smoren: http://www.libsdl.org/cgi/docwiki.cgi/Mix_LoadWAV the namee of the function is confusing... but it can load other formats too
11:07:35 <NameAlreadyInUse> hmm
11:07:41 <Cheshire> stuff like that anyway
11:07:48 <Cheshire> @go r6 Y combinator
11:07:49 <lambdabot> No Result Found.
11:07:50 <NameAlreadyInUse> i sort of see
11:07:52 <Cheshire> humf
11:08:12 <Cheshire> yeah this one http://r6.ca/blog/20060919T084800Z.html
11:14:05 <Cheshire> anyone know that comonad trick to do cellular automata?
11:14:15 <Cheshire> can you do that for trees as well (instead of grids)?
11:17:14 <aleator> I have computation a :: Int -> IO (), that writes stuff in a file and exhibits 90% load in cpu. If I forkIO two of those (with different params) I get two cores at 55% load. What might cause this?
11:18:18 <ddarius> aleator: That sounds perfectly reasonable.
11:18:36 <augustss> aleator: what was your expectation?
11:19:19 <aleator> ddarius: to load both cores at 90. That happens if I run two copies of the same program, which I thought pretty much equivalent
11:19:36 <augustss> GC?
11:20:29 <aleator> Maybe, but 40% is quite big hit..
11:20:30 <augustss> aleator: did you use +RTS -N2
11:20:40 <aleator> Sure.
11:21:10 <int-e> aleator: try +RTS -sstderr  and look at the line saying %GC time?
11:21:12 <aleator> I know I can work around this by spawning several processes, but that is bit ugly
11:22:42 <aleator> int-e: Ah. Takes a minute to run..
11:23:27 <Jiten> Is there a library for Haskell that can load png files (and preferably also write them)?
11:23:37 <aleator> hmm 54.5 (68.1% elapsed)..
11:24:02 <Jiten> I only succeeded in finding library for writing.
11:24:05 <kryptiskt_> Jiten: if you have gtk2hs you can use the cairo bindings
11:24:34 <aleator> and single thread with 52.4 and 51.7...
11:25:38 <aleator> Does this report sum of gc time in both cores or just the amount of runtime spend on gc?
11:26:26 <maltem> Jiten: what are you going to do with the files? For standard image processing, I'd mention hsmagick
11:27:55 <ImOuttaYourMonad> is a red-black-tree allowed to be : Black v (Black ...) (red ...) ?
11:28:04 <ImOuttaYourMonad> all the operations work so...but
11:29:08 <Olathe> ImOuttaYourMonad: Sure (from http://en.wikipedia.org/wiki/Red-black_tree#Properties)
11:29:17 <int-e> aleator: out of curiosity, which ghc version are you using?
11:29:23 <Cheshire> If a program is a solution to a problem than knowing that it terminates
11:29:32 <Jiten> maltem: that sounds more like what I could use ...
11:29:48 <aleator> int-e: 6.10.1
11:30:14 <Jiten> maltem, mostly I just want the image data loaded into haskell data structures so I can write code to do things to it and then save the result :)
11:30:34 <aleator> int-e: Should I even expect to have performance close to two processes with forkIO?
11:30:58 <int-e> aleator: (there are some interesting changes to the garbage collector in the current development head, which will be in 6.12 (when it comes out). In particular, there's a change to allow worker threads to do garbage collection in their own nursery, while right now the RTS has to stop all workers in order for them to do that work)
11:31:25 <int-e> aleator: oh you could try playing with +RTS -A to make those GCs less frequent, perhaps.  +RTS -A10M or so?
11:32:17 <koeien> what is the minimal complete definition of Enum ?
11:32:25 <aleator> I will try and see if I can play with the options, but currently safest bet for me would be to spawn a new process for each computation to get the maximum throughput?
11:32:28 <mauke> .oO( deriving Enum )
11:32:54 <maltem> Jiten: oh I'm not sure if hsmagick will give you some presentation of the pixel data
11:32:55 <koeien> mauke: no, i'm TH'ing at the moment
11:33:27 <int-e> koeien: fromEnum and toEnum
11:33:38 <koeien> int-e: ok thanks
11:34:03 <int-e> aleator: I'm afraid so.
11:34:10 <Jiten> maltem: well, it looks like it allows me to write code to do things with it so it's good enough :)
11:34:13 <augustss> aleator: if you need to spawn new processes I'd regard it as a bug
11:35:15 <aleator> augustss: Yes, it is much uglier, but what can I do?
11:36:07 <augustss> aleator: file a bug report
11:36:15 <aleator>  :/
11:36:25 <int-e> aleator: try the development version of ghc and if that is still that bad, report it on the bug tracker.
11:37:08 <aleator> I would like to check other possible causes as well. Like writing to file in forked thread, does this cause other reads to stop?
11:37:12 <int-e> (the first step is optional but would be helpful, because this is an area that GHC HQ (Simon Marlow mainly) has worked on in the past months)
11:37:46 <int-e> aleator: are you writing to different files?
11:37:47 <koeien> what is the difference between quotRem and divMod? I know the difference in the Int case, but does it matter for my own types?
11:38:06 <aleator> int-e: Yes, each thread to its own
11:38:09 <int-e> koeien: divMod has a guarantee that the remainder is not negative.
11:38:24 <pumpkin_> I want modExp
11:38:26 <int-e> koeien: as far as I know defining quotRem = divMod is permitted.
11:38:30 <pumpkin_> from gmp
11:38:32 <koeien> int-e: in my type there is no "negative" defined
11:38:36 <kmeyer> :t pseq
11:38:37 <lambdabot> forall a b. a -> b -> b
11:38:45 <koeien> int-e: i can't order my set
11:39:15 <int-e> aleator: then they should not interfere with each others on IO, I think.
11:39:31 <kmeyer> > 5 `pseq` 6
11:39:32 <lambdabot>   6
11:39:32 <koeien> int-e: oh. i need Ord anyway to do Integral
11:39:39 <aleator> int-e, augustss: Do you think of anything else other than gc that could be the cause?
11:39:50 <pumpkin_> kmeyer: pretty exciting function, eh :)
11:40:06 <kmeyer> seems so, yeah :)
11:41:20 <augustss> aleator: I'm not sure how system calls are done these days.  perhaps they can interfere with each other
11:41:40 <pumpkin_> augustss: did you ever package up that symbolic manipulation code you put on your blog?
11:42:18 <augustss> pumpkin_: which symbolic manipulation?  tracing?  numbers?
11:42:32 <aleator> Hah. -A10m seems to be doing really a lot for this. The hit on performance from gc is down by 30%
11:42:47 <pumpkin_> augustss: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html that one
11:43:18 <augustss> pumpkin_: it's in the numbers package
11:43:23 <pumpkin_> aha
11:43:51 <pumpkin_> great!
11:43:54 <pumpkin_> thanks :)
11:44:06 <aleator> Any other good trs options if I'm just caring about throughput performance and nothing else?
11:44:33 <aleator> rts
11:45:03 <mmorrow> aleator: not sure exactly the relevance to your stuff, but -C seems like it could be fun to play with (set the context-switch interval (in seconds))
11:46:21 <wli> hpaste.org's frame crud is horrible. My window is 3 times the width of the code and it's putting some horizontal scrollbar in a frame that's a fifth the width of my window.
11:46:26 <mmorrow> pumpkin_: have you looked at PrimOps.cmm? maybe you could manage adding it without too much trouble?
11:46:32 <mmorrow> pumpkin_: (modExp)
11:46:41 <toliko_smoren> hey i am trying to install the ghSDL binder and I get an error, Graphics\UI\SDL\General.hsc:1:17:  SDL.h: No such file or directory can anyone help me with this
11:46:44 <pumpkin_> mmorrow: was thinking of it, dolio said he was also looking around there
11:46:44 <aleator> mmorrow: Heh I think I can make it totally freeze with that :)
11:46:55 <pumpkin_> mmorrow: but yeah, I don't think it should be too hard at all
11:46:58 <mmorrow> aleator: heh
11:47:19 <aleator> mmorrow: What range of values are reasonable?
11:47:26 <mmorrow> pumpkin_: yeah, there's on or two other files that need to know about a new primop iirc
11:47:37 <pumpkin_> yeah, I've seen them
11:47:48 <mmorrow> aleator: i'm not really sure, but it'd be interesting to find out :)
11:47:57 <mmorrow> pumpkin_: nice
11:49:09 <int-e> mmorrow, pumpkin_: one of them is compiler/prelude/primops.txt.pp
11:49:31 <aleator> mmorrow: For this case, it seems anything less than 5 gives equal performance and 5 makes it hang sometimes.. :)
11:49:33 * int-e doesn't know whether there are more places
11:49:48 <pumpkin_> int-e: yeah, I think that's the one I've seen... it autogenerates code based on that
11:50:03 <pumpkin_> and I'd probably want to give a nice higher-level interface to it
11:53:40 <int-e> aleator: heh. I'm pretty sure it shouldn't hang :/
11:54:24 <aleator> Can't get it to hang now that I'm trying..
11:54:42 <aleator> But I've already found out that disabling generational gc is not helping performance :)
11:55:28 <witkamp> How do I convert Data.ByteString.Internal.ByteString -> Data.ByteString.ByteString
11:55:35 <int-e> aleator: did the -A option help with the overall runtime, or did it just reduce the percentage of GC time?
11:56:19 <MyCatVerbs> There isn't anything like -ddump-simple for gcc, is there? Just wondering how some ugly C macros I've been writing look like by the time they hit the instruction scheduler or so.
11:56:38 <mmorrow> pumpkin_: it looks like various files in ghc/compiler/prelude/ are relevant
11:56:48 <int-e> witkamp: hmm aren't they the same?
11:56:59 <witkamp> That is what I thought
11:57:08 <pumpkin_> yeah :) I'll poke around there sometime, after making sure I'm not duplicating dolio's work
11:57:08 <pejo> MyCat, there's -E or something similar to get the output after the preprocessor has run, but that shows the (ugly) C code
11:57:15 <witkamp> I guess I am a bit confused
11:57:30 <pumpkin_> I don't really need an efficient modexp as I'm not doing much crypto :P
11:57:33 <pumpkin_> but it would be nice to have
11:57:38 <aleator> int-e: run time went down from ~40s to ~13s in multithreaded case
11:57:54 <MyCatVerbs> pejo: jah, and -s. -E is still too high level and -s, well, just a little hard to read. :)
11:57:56 <int-e> aleator: ah, good.
11:58:11 <mmorrow> pumpkin_: also, here too possibly ghc/utils/genprimopcode/
11:58:22 <int-e> aleator: so we can be fairly certain that GC is the bottleneck
11:58:26 <pumpkin_> mmorrow: yeah, I think that's what takes the file int-e mentioned
11:58:39 <mauke> MyCatVerbs: grep the gcc manual for -fdump
11:58:56 <MyCatVerbs> mauke: oh sweet, thank you!
11:59:37 <aleator> int-e: Excellent in fact. In singlethreaded case it takes 22sec, so there is some overhead, but not really that much.
12:00:14 <aleator> I need to try this with the 8 core machine, if I can coax 6.10 to install on fedora 4.
12:01:49 <mmorrow> pumpkin_: and finally here ghc/compiler/codeGen/CgPrimOp.hs
12:02:00 <mmorrow> those are all the places i know of that i've seen
12:02:05 <pumpkin_> thanks :)
12:02:08 <mmorrow> :)
12:04:08 <toliko_smoren> hey, anyone actually used the hsSDL thing, because it does not come with any examples and the docs are empty?
12:04:18 <toliko_smoren> I simply want to play a music file, cant be that hard
12:04:38 <conal> twanvl: i made a variation of your Expr module that generates a pretty-printing Doc instead of a ShowS.
12:04:49 <sm> toliko_smoren: bah.. you must be new here
12:05:06 <toliko_smoren> I am
12:05:07 <toliko_smoren> :(
12:05:07 <twanvl> conal: that seems like a nice improvement
12:05:41 <witkamp> It would be really wonderful if GHC would give the full module name of a function or type in an error message
12:05:44 <sm> I'm just joking. It probably isn't hard in haskell. :) But I remember the days when playing music was not expected to be EASY
12:06:15 <toliko_smoren> well there should be libraries with proper docs
12:06:24 <witkamp> I am new and keep getting burned by namespace uses
12:06:28 <sm> yes indeed
12:06:47 <SubStack> import qualified Quux as Q
12:07:02 <SubStack> and other such constructions
12:07:12 <chessguy_work> i thought Quux was deprecated?
12:07:28 <conal> what's Quux?
12:07:47 <SubStack> conal: metasyntactic variable
12:08:17 <conal> SubStack: thx
12:08:17 <SubStack> a term made up to describe made-up terms
12:08:35 <conal> i didn't know that one.
12:08:43 <chessguy_work> Quux has long bben deprecated in favor of Foo
12:08:53 <SubStack> Foo Bar Baz Quux
12:08:56 <SubStack> I like to skip ahead
12:08:58 <int-e> import qualified Data.ByteString.Char8 as BC
12:09:01 <int-e> Xyzzy!
12:09:23 <chessguy_work> conal, don't mind me, i'm in a silly mood
12:09:25 <SubStack> the first three are way overused
12:09:29 <alinp> where to find "times" function ?
12:09:33 <alinp> which module ?
12:09:58 <augustss> alinp: use hoogle
12:09:59 <SubStack> alinp: like replicate?
12:10:08 <chessguy_work> SubStack, what really gets me is when someone names something "x", as they're describing it, but then never calls it by that name again
12:10:14 <SubStack> in the ruby sense of "times"
12:10:20 <conal> chessguy_work: lol
12:10:41 <int-e> > concat (replicate 10 "abc")
12:10:41 <alinp> SubStack: yes, the ruby sense
12:10:42 <lambdabot>   "abcabcabcabcabcabcabcabcabcabc"
12:10:50 <SubStack> chessguy_work: the compiler should optimize those away anyways
12:11:02 <chessguy_work> "so there's this thing, call it 'x', and our module calls that thing, but that thing's not very fast..."
12:11:22 <SubStack> although it is annoying and misleading to have dangling variables
12:12:16 <int-e> alinp: oh you want replicateM_  I guess ...  replicateM_ 10 $ putStrLn "Hello, world!"
12:12:29 <int-e> (from Control.Monad)
12:12:36 <alinp> oh, I see
12:12:38 <alinp> thanks
12:15:18 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
12:15:18 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
12:19:59 <alexsuraci> I'm tweaking my guessing/branching sudoku solver and trying to work parallelism into it to increase the guessing speed - is there any way to use parMap in such a way that it will stop when one succeeds (via a boolean "valid" function)
12:20:21 <alexsuraci> forgot my question mark: ?
12:21:29 <olsner> I think a better solver will always do better - rumor has it the J version solves sudokus in milliseconds
12:22:04 <olsner> but to answer your question, I think (any (parMap  ...)) with laziness would avoid unnecessary work
12:22:23 <olsner> > or (True : repeat False)
12:22:23 <alexsuraci> Hmm
12:22:25 <lambdabot>   True
12:22:29 <olsner> I meant
12:22:29 <kmeyer> on that subject, what's pseq do?
12:22:36 <olsner> 'or' not 'any'
12:22:59 <alexsuraci> http://github.com/vito/sudoku.hs My solver. Written for understandability, not necessarily speed. Wrote it to help learn the language.
12:24:24 <pumpkin_> kmeyer: http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html (mostly like seq, but they explain the difference on that page)
12:24:55 <alexsuraci> > or (False : True : repeat False)
12:24:57 <lambdabot>   True
12:25:05 <kmeyer> pumpkin_: thanks
12:25:19 <f4hy> Could someone explain how fibs = 1 : 2 : zipWith (+) fibs (tail fibs) works?
12:25:35 <alexsuraci> hm, except I'll be applying that "valid" function on the grids, not necessarily a list of booleans
12:25:46 <alexsuraci> f4hy: It basically layers upon itself infinitely
12:26:08 <pumpkin_> f4hy: think of it in terms of "only asking for stuff when it's needed" :P
12:26:13 <alexsuraci> like two semitransparent identical ribbons with numbers printed on them, with one layered on the other and offset by one digit
12:26:16 <alexsuraci> :P
12:26:21 <f4hy> I dont fully understand tail
12:26:28 <pumpkin_> > tail [1,2,3,4]
12:26:28 <Cheshire> f4hy I can explain it
12:26:29 <lambdabot>   [2,3,4]
12:26:35 <f4hy> oh ok
12:26:44 <alexsuraci> tail = everything but the first element, head = first element
12:26:45 <pumpkin_> that's what takes care of adding adjacent numbers
12:27:08 <Cheshire> looks like a few other people already started so I will not though
12:27:10 <alexsuraci> init is everything but the last, and I think the last element is just "last"
12:27:12 <alexsuraci> > last [1, 2, 3]
12:27:14 <lambdabot>   3
12:28:43 <f4hy> Hmm I am still not fully sure why that fibs expression works
12:29:25 <Cheshire> why not describe it in #haskell-overflow
12:29:26 <wli> Keep substituting fibs and keep reducing.
12:29:45 <wli> Or really, just keep reducing.
12:29:53 <kmeyer> pumpkin_: ok, thanks makes sense.
12:29:57 <Cheshire> this #haskell channel is too noisy to have a train of thought
12:30:38 <pejo> Cheshire, are you sure you're not taking out your bad mood on #haskell?
12:30:40 <alexsuraci> zipWith (+) [(1, 1), (1, 2), (2, 3), (3, 5)] => [1, 3, 5, 8]
12:30:47 <Cheshire> pejo, I am sure
12:30:50 <alexsuraci> > zipWith (+) [(1, 1), (1, 2), (2, 3), (3, 5)]
12:30:51 <lambdabot>       Overlapping instances for Show ([(t, t1)] -> [(t, t1)])
12:30:51 <lambdabot>        arising ...
12:31:00 <alexsuraci> er, woops.
12:31:14 <f4hy> I think I am starting to get it. But not sure I would ever be able to write it.
12:31:24 <alexsuraci> oh, duh
12:31:29 <chessguy_work> > zipWith (+) [1,1,2,3] [1,2,3,5]
12:31:30 <lambdabot>   [2,3,5,8]
12:31:31 <alexsuraci> yea I got that wrong, ignore that :P
12:31:36 <Cheshire> pejo, do you think a channel with 600 people is suitable to describe something as subtle as this...?
12:32:08 <chessguy_work> it's not that busy in here...
12:32:13 <alexsuraci> f4hy: zip takes [1, 2, 3, 4] and [4, 3, 2, 1] and turns it into [(1, 4), (2, 3), (3, 2), (4, 1)]
12:32:26 <f4hy> OH I get it now, thanks alexsuraci
12:32:26 <trofi> @src zip
12:32:27 <alexsuraci> zipWith just takes a function to operate on the elements of the tuple
12:32:27 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
12:32:27 <lambdabot> zip _      _      = []
12:32:44 <chessguy_work> zip = zipWith (,)
12:32:47 <pumpkin_> > zip [1..5] (tail [1..5])
12:32:48 <Cheshire> pejo, I don't think so but f4hy didn't go to overflow so that doesn't work either
12:32:48 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
12:33:05 <trofi> > fix zip
12:33:07 <lambdabot>   Couldn't match expected type `[a]'
12:33:17 <alexsuraci> f4hy: just don't try to do "last fibs".
12:33:20 <alexsuraci> ;)
12:33:27 <Cheshire> pejo, (no response from you.. I guess you run out of remarks to say)
12:33:30 <DBAlex> hey, small question, how would you get the position of a player in a game written in haskell without storing the position explicitly?
12:33:49 <chessguy_work> DBAlex, board game? FPS?
12:33:51 <f4hy> alexsuraci: Haskell cant give me aleph_0?
12:33:54 <Dybber> Hi. I'm trying to understand the "forall"-keyword and why it is used. I found this in some code I'm reading: "onezero :: forall a . Reify a => S a -> S Float" does the forall add anything? Isn't it implicit?
12:33:58 <pumpkin_> DBAlex: by implicitly calculating it from other information, I guess? :P
12:34:00 <DBAlex> chessguy_work: A game like say space invaders
12:34:06 <pumpkin_> DBAlex: that's all you've left yourself with it seems :)
12:34:18 <DBAlex> pumpkin_: true but what other information?
12:34:29 <pumpkin_> DBAlex: I dunno :)
12:34:30 <chessguy_work> DBAlex, this is a pretty vague question
12:34:30 <DBAlex> unless you scan the display
12:34:32 <tromp_> history of movemnents?
12:34:43 <pumpkin_> DBAlex: why are you avoiding storing explicit location?
12:34:44 <alexsuraci> f4hy: is that what it said when you tried it?
12:34:48 <DBAlex> tromp_: history? how without destructive updates
12:34:59 <f4hy> alexsuraci: no. you told me not to try it
12:35:03 <Cheshire> pejo, maybe you misinterpreted me but are too proud to admit it
12:35:06 <alexsuraci> ah
12:35:09 <DBAlex> pumpkin_: I'm not, i'm thinking about how i'd write a game without static positions in haskell
12:35:15 <DBAlex> pumpkin_: how can I store it ?
12:35:26 <alexsuraci> f4hy: fibs is an infinite list, so if you try to get the last element it'll basically keep going and going until it crashes.
12:35:38 <pejo> Cheshire, I think it's a great educational resource, I need to learn a lot more about basically everything.
12:35:45 <f4hy> alexsuraci: Well I just need a faster computer then. I want aleph_0
12:35:51 <alexsuraci> haha
12:35:53 <pumpkin_> DBAlex: hmm? there's nothing wrong with storing it explicitly
12:36:01 <DBAlex> pumpkin_: how can I store it more than once though
12:36:06 <Cheshire> pejo non sequiter
12:36:18 <pumpkin_> DBAlex: you pass along a modified version every time it changes
12:36:30 <DBAlex> lets say, I have a space ship that starts at the middle (256) and moves 5 spaces left, how can I get the new position?
12:36:43 <pumpkin_> you storing it as a single flattened coordinate?
12:36:48 <DBAlex> pumpkin_: even if its not needed
12:36:55 <DBAlex> *?
12:37:05 <pumpkin_> > second (+5) (10, 16)
12:37:07 <lambdabot>   (10,21)
12:37:32 <pumpkin_> > second (+5) (10, 256)
12:37:33 <lambdabot>   (10,261)
12:37:35 <jpcooper> @src second
12:37:35 <lambdabot> Source not found. That's something I cannot allow to happen.
12:37:50 <pumpkin_> > second f (a, b)
12:37:50 <DBAlex> pumpkin_: but I can't update 256 so whats the point?~
12:37:51 <lambdabot>   Add a type signature
12:37:57 <pumpkin_> > second f (a, b) :: (Expr, Expr)
12:37:58 <lambdabot>   (a,f b)
12:38:05 <DBAlex> it will allways just move one position
12:38:26 <DBAlex> then be un-movable as it looks at 256 and adds 5 again and again
12:38:26 <pumpkin_> DBAlex: sure you can, your future state iterations don't have to look at the old coordinate
12:38:46 <pumpkin_> you can think of your state updater as folding the initial state with user input
12:39:06 <DBAlex> pumpkin_: hm ok
12:39:15 <Gracenotes> > (f *** g) (a, b) :: (Expr, Expr)
12:39:16 <lambdabot>   (f a,g b)
12:39:40 <DBAlex> but if the user presses the right key and the new positon is 261, how do we know this the next time we press the right key?
12:40:06 <Gracenotes> > (join (&&&) f) a :: (Expr, Expr)
12:40:07 <lambdabot>   (f a,f a)
12:40:22 <f4hy> 1234 to "1234" or '1':'2':'3':'4':[] I am sure there is a built in function to do this yes? Numbers to strings?
12:40:22 <DBAlex> it would be easy in a board game
12:40:28 <DBAlex> but not something like space invaders
12:40:50 <alexsuraci> > toChar 1
12:40:51 <lambdabot>   Not in scope: `toChar'
12:40:54 <alexsuraci> maybe not
12:40:55 <SubStack> > show 1234 :: String
12:40:56 <lambdabot>   "1234"
12:41:03 <Gracenotes> DBAlex: in games, you might have to use something like IORefs
12:41:09 <trofi> :t showHex
12:41:11 <lambdabot> forall a. (Integral a) => a -> String -> String
12:41:14 <alexsuraci> > toDigit 1
12:41:16 <lambdabot>   Not in scope: `toDigit'
12:41:21 <alexsuraci> bah, I know that one exists
12:41:22 <DBAlex> Gracenotes: ok
12:41:34 <DBAlex> Gracenotes: don't iorefs break the functional model tho?
12:41:48 <pumpkin_> > read "1234" :: Int
12:41:49 <lambdabot>   1234
12:41:53 <pumpkin_> > read "1234" :: Double
12:41:54 <lambdabot>   1234.0
12:41:55 <Gracenotes> they're messy, but IO is entirely within the functional model via monads
12:42:11 <f4hy> pumpkin_: ya, what is the inverse of read
12:42:13 <pumpkin_> haskell is 100% pure
12:42:16 <pumpkin_> > show 1234
12:42:18 <lambdabot>   "1234"
12:42:19 <Gracenotes> DBAlex: just make sure to keep the IO relatively constrained, instead of sprawling
12:42:20 <alexsuraci> > read "1" :: Char
12:42:21 <f4hy> Ok
12:42:21 <lambdabot>   * Exception: Prelude.read: no parse
12:42:24 <pumpkin_> haskell - unsafe*
12:42:39 <Gracenotes> DBAlex: modifyIORef allows you to change an IORef in a pure function
12:42:47 <DBAlex> ok
12:43:11 <sanity-> is there an IDE that runs on the Mac which supports Haskell code-completion?
12:43:30 <Gracenotes> functional reactive programming might interest you -- in fact, there's a sample space invaders game written in it
12:43:39 <Gracenotes> except I can't comprehend it whatsoever, and the variable names don't help
12:44:01 <DBAlex> heh ok
12:44:12 <DBAlex> so games in haskell is really a no-no?
12:44:23 <trofi> @go frag haskell
12:44:24 <DBAlex> haskell is best suited to string and list processing I think
12:44:25 <lambdabot> http://www.haskell.org/haskellwiki/Frag
12:44:25 <lambdabot> Title: Frag - HaskellWiki
12:44:27 <Gracenotes> I wouldn't say so ... in fact, someone wrote a 3D shooter :)
12:44:38 <Gracenotes> albeit, using functional reactive-style programming
12:44:38 <DBAlex> I know i've seen Frag
12:44:50 <pumpkin_>  DBAlex: I wouldn't say that at all :)
12:45:10 <SubStack> I write 3d simulations in haskell
12:45:16 <DBAlex> pumpkin_: fair enough, its just my opinion
12:45:17 <pumpkin_> might as well say "haskell is best suited to useless contrived performance benchmarks dons uses to piss off Bulat"
12:45:22 <SubStack> glut bindings are pretty nice
12:45:24 <DBAlex> maybe i'd prefer to use something like C#
12:45:26 <pumpkin_> DBAlex: one's gotta be able to support an opinion :)
12:45:39 <DBAlex> mainly procedural with some functional parts...
12:45:52 <Gracenotes> DBAlex: I can post a quick Tetris game I wrote, if you're interested
12:45:54 <trofi> unless you have to port it somewhere
12:45:59 <DBAlex> Gracenotes: ok
12:46:02 <pumpkin_> DBAlex: I've done a lot of heavy number crunching in it
12:46:05 <pumpkin_> been very pleasant
12:46:17 <SubStack> my next 3d project is a wildfire simulator
12:46:21 <SubStack> should be pretty fun
12:46:24 <DBAlex> its good for anything that can rely on previous calculations/operations
12:46:26 <pumpkin_> SubStack: pyro!
12:46:29 <DBAlex> games aren't like that :P
12:46:29 <SubStack> it's true
12:46:43 <SubStack> thankfully other people have already done all the maths
12:46:46 <pumpkin_> DBAlex: you should speak to conal :) I'm sure he'd disagree
12:47:06 <DBAlex> pumpkin_: I don't not like haskell and the functional style
12:47:09 <DBAlex> I can see the power
12:47:09 <Gracenotes> DBAlex: it doesn't use modifyIORef, just reads and writes. I've been meaning to refactor it.. but you get the idea :)
12:47:29 <DBAlex> reads and writes to disk?
12:48:19 <Gracenotes> no, explicit reads and writes to IORefs, instead of modifyIORef, which is a good function for separating pure/impure.
12:48:26 <Gracenotes> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2101#a2101
12:49:09 <Gracenotes> it doesn't have any score-keeping or winning or so on (incomplete), yet...
12:49:16 <cjb> dons: hey, I just noticed that Joe Hurd is at Galois now!  We used to drink/play chess together at Cambridge.
12:49:27 <DBAlex> ok
12:50:09 <mmorrow> SubStack: oh cool. are you using that level-set thing?
12:50:33 <Gracenotes> I can't say Haskell is amazing when it comes to games, but I definitely wouldn't say it's out of its problem domain.
12:50:35 <SubStack> I'm not familiar.
12:50:57 <SubStack> I've mostly based my simulations off of the red book translations
12:51:21 <dons> cjb: oh cool. yes. he works here.
12:51:22 <DBAlex> Gracenotes: very cool example i'll munch over that for a while
12:51:29 <mmorrow> SubStack: ah. i was at one point going to help this one prof with some research that invloved simulating wildfires, but didn't end up doing that. but iirc he was using this "level-set" method for doing so.
12:51:40 <DBAlex> I also have an asteroids example someone wrote here, but I can't get wxHaskell to install
12:51:49 <DBAlex> well, I can't get cabal to install on ubuntu
12:51:54 <DBAlex> complains about zlib.h ?
12:51:58 <SubStack> ah
12:52:05 <DBAlex> it complained about various other things but I fixed those
12:52:18 <mmorrow> SubStack: it's basically a numeric algo for solving a pde, which propogates a front in a plain based on various info
12:52:29 <SubStack> mmorrow: http://modzer0.cs.uaf.edu/~substack/school/cs480/wildfires.html
12:52:30 <mmorrow> *plane
12:52:31 <DBAlex> anyone any idea how to install cabal properly?
12:52:37 <DBAlex> I need to install cabal to install wxhaskell...
12:52:41 <SubStack> my topic paper for this class project
12:52:52 <dons> DBAlex: should already be installed if you're using ghc 6.10.x
12:52:52 <SubStack> code isn't even a deliverable but I'd really like to play with this stuff
12:53:00 <dons> DBAlex: you may want cabal-install as well
12:53:08 <dons> if so, get it from your distro, or use the bootstrap script
12:53:15 <chessguy_work> Gracenotes, is that a working tetris?
12:53:16 <SubStack> mostly I just want to get rothermel working and then add in a few other fancy factors
12:53:22 <DBAlex> dons: I am using 6.10 on windows
12:53:27 <DBAlex> but no cabal command?
12:53:42 <Gracenotes> chessguy_work: it doesn't know when you lose or how to keep scope, but it does have falling blocks and eliminating lines
12:53:42 <DBAlex> dons: That was the issue (cabal-install)
12:53:45 <Gracenotes> *score
12:53:53 <foo-nix> I am trying to install base, but I get this error: http://dpaste.com/6355/ (base; http://hackage.haskell.org/cgi-bin/hackage-scripts/package/base-4.0.0.0) (help please)
12:53:56 <dons> ah, there's a cabal.exe on the cabal home page
12:53:57 <dons> for windows
12:53:58 <Gracenotes> and standard tetris rotation logic using the SMS
12:54:05 <foo-nix> I'm running gentoo linux
12:54:32 <Gracenotes> DBAlex: Ubuntu is a bit behind on Haskell dependencies.. er, Haskell everything
12:54:39 <DBAlex> yeah :(
12:54:42 <SubStack> mmorrow: looks like it's based on WRF... I've used that
12:54:53 <chessguy_work> > reverse . transpose $ [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]
12:54:54 <lambdabot>   [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]
12:55:00 <DBAlex> Gracenotes: do you use Linux?
12:55:31 <foo-nix> runhaskell seems to have the same filesize/md5 as runghc, so I assume both are the same
12:55:45 <chessguy_work> > transpose . reverse $ [[0,1,1],[1,1,0],[0,0,0]]
12:55:47 <lambdabot>   [[0,1,0],[0,1,1],[0,0,1]]
12:55:51 <Gracenotes> try apt-get install libghc6-mtl-dev libghc6-http-dev libghc6-network-dev libghc6-parsec-dev
12:55:58 <chessguy_work> nice
12:56:00 <Gracenotes> ..and you might want to install more :)
12:56:01 <chessguy_work> Gracenotes++
12:56:18 <mmorrow> SubStack: here's that prof. he was pretty into the wildfire thing iirc. he was working to actually improve firefighter's ability to predict their paths. http://www.columbia.edu/~kd2112/
12:56:30 <Gracenotes> search libghc6 in the Synaptic Package Manager and install what looks interesting
12:56:45 <mmorrow> SubStack: and here's some related http://www.cs.cmu.edu/~caliente/
12:56:50 <f4hy> How do I get the cartesian product of two lists?
12:56:57 <DBAlex> foo-nix: they are...
12:56:58 <seydar> can someone explain what list zippers are?
12:56:58 <lambdabot> seydar: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:57:05 <Gracenotes> for zlib, I don't recall whether you have to manually install that or not..
12:57:09 <Cheshire> seydar in what respect?
12:57:09 <cjb> seydar: this is the best explanation I've seen:
12:57:10 <DBAlex> Gracenotes: I did all those
12:57:23 <cjb> seydar: http://community.livejournal.com/evan_tech/262357.html
12:57:27 <DBAlex> that was when I got the zlib error, after i'd fixed all the other errors by installing those packages
12:57:28 <foo-nix> DBAlex: not by definition, I assume there is a pretty good change runhaskell is the same as runhugs.
12:57:35 <Gracenotes> hrm.
12:57:42 <SubStack> mmorrow: nifty, thanks
12:57:57 <mmorrow> SubStack: this is the book he had me get http://www.amazon.com/Level-Methods-Fast-Marching-Computational/dp/0521645573/ref=pd_bbs_2?ie=UTF8&s=books&qid=1236200249&sr=8-2
12:58:03 <seydar> Cheshire: just like what it is and how to use it
12:58:05 <mmorrow> SubStack: np
12:58:14 <seydar> how do I leave a message for someone?
12:58:25 <foo-nix> Do I need base-4.0.0.0, is it a set of datatype definitions and library calls on top of haskell ?
12:58:30 <Gracenotes> then download http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib and install with http://www.haskell.org/ghc/docs/latest/html/Cabal/builders.html I suppose
12:58:31 <DBAlex> seydar: /msg name message_here
12:58:48 <DBAlex> ok
12:58:53 <mauke> seydar: we have two bots that can store messages
12:58:59 <DBAlex> it does download zlib
12:59:09 <DBAlex> it just doesn't seem to "see" its own zlib.h
12:59:21 <DBAlex> even if I specify it with the path to lib thingies
12:59:21 <seydar> mauke: how do i use lambdabot?
12:59:29 <pumpkin_> @list
12:59:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:59:30 <Gracenotes> ..are you sure you have zlib installed too? :)
12:59:35 <mauke> seydar: @tell NAME MESSAGE
12:59:37 <DBAlex> yes!
12:59:46 <Gracenotes> odd. hm.
12:59:48 <Cheshire> @tell MAUKE HELLO
12:59:48 <lambdabot> Consider it noted.
12:59:48 <DBAlex> I even install zlib in ubuntu
12:59:51 <Cheshire> :)
12:59:51 <DBAlex> *ed
12:59:54 <mauke> gee
12:59:54 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
13:00:33 <Dude4Sale> https://affiliates.izea.com/event/1260-129-1325
13:00:40 <DBAlex> @tell lambdabot HELLO!
13:00:40 <lambdabot> Nice try ;)
13:00:41 --- mode: ChanServ set +o mauke
13:00:42 <seydar> @tell chessguy yea that all makes sense
13:00:43 <lambdabot> Consider it noted.
13:00:59 <DBAlex> @tell seyday hello!
13:00:59 <lambdabot> Consider it noted.
13:01:04 <DBAlex> @tell seydar hello!
13:01:05 <lambdabot> Consider it noted.
13:01:11 <vav> foo-nix: base is installed with ghc, for base-4, I'm not positive, but think you need ghc-6.10.1 instead of 6.8.* . You could use haskell overlay for that. Also is #gentoo-haskell channel where might be people to help.
13:01:11 <seydar> shoot, how do i see old messages?
13:01:12 <pchiusano> hello
13:01:12 <lambdabot> seydar: You have 1 new message. '/msg lambdabot @messages' to read it.
13:01:21 <DBAlex> lol
13:01:26 <DBAlex> why can't people just use /msg !
13:01:30 <Gracenotes> @ask lambdabot Have you stopped beating your wife?
13:01:30 <lambdabot> Nice try ;)
13:01:37 <foo-nix> vav: thanx
13:02:08 <seydar> mauke: how do i check old messages?
13:02:14 <foo-nix> vav: va
13:02:18 <mauke> define "old"
13:02:26 <foo-nix> sorry, that was a clock in my internet pipe :)
13:02:27 <Gracenotes> @ask lambdabot May I have your wallet?
13:02:27 <lambdabot> Nice try ;)
13:02:41 --- mode: mauke set -o mauke
13:02:41 <seydar> mauke: i checked my messages, then i realized i didn't click a link and i need to
13:02:51 <mauke> well, they're gone
13:02:54 <foo-nix> lambdabot: May I not have your wallet
13:03:10 <foo-nix> vav: But I can also download the sources of course?
13:03:16 <Gracenotes> lambdabot is a lady; she carries around a purse, not a wallet
13:03:32 <SubStack> @ask lambdabot I heard you like monads.
13:03:32 <lambdabot> Nice try ;)
13:03:34 <mauke> preflex clears your messages when you ask for them; I assume lambdabot works the same way
13:03:40 <Cheshire> ". A zipper can be defined for any data structure systematically by computing the derivative (in the calculus sense, kinda) of its data type!"
13:03:43 <Cheshire> I don't believe that to be true
13:03:50 <Cheshire> what is the zipper for  a -> b
13:04:02 <Gracenotes> well, so long as you have a b -> a ;)
13:04:15 <seydar> @ask lambdabot for sex
13:04:17 <lambdabot> Nice try ;)
13:04:20 <seydar> shucks
13:04:30 <vav> foo-nix: yeah, can user install, or use cabal-install binary cabal to install, however I still think you'd need ghc-6.10.1.
13:04:34 <Gracenotes> -_-
13:04:53 <foo-nix> vav: yes, but I mean: I can install ghci by tar.gz.
13:04:57 <foo-nix> ^^
13:05:03 <foo-nix> Thank you for your help
13:05:19 <mmorrow> Cheshire: (a -> b) isn't a data structure
13:05:42 <Cheshire> data Arrow a b = Whoosh (a -> b)
13:05:42 <mmorrow> s/structure/type/
13:06:03 <mmorrow> Cheshire: in that case, i guess you'd just apply the rules! :)
13:06:12 <Cheshire> there is no rule for (->)
13:06:15 <chessguy_work> Whoosh? and this from the guy who thought 'semantic editor combinators' was a silly name
13:06:19 <mmorrow> Cheshire: but iirc it doesn't work for functions
13:06:22 <mmorrow> Cheshire: yeah
13:06:32 <Cheshire> chessguy_work yikes that moment I took you off /ignore
13:06:48 <Cheshire> didn't know you were still saying stuff about me
13:07:01 <vav> foo-nix: yes, there are misc linux binaries for ghc and ghc extras, although I'm not familiar with them. Also is a 'binary' USE flag for gentoo ghc packages for many architectures at least, so don't have to compile it.
13:07:01 <chessguy_work> yes, i'm quite obsessed
13:07:38 <DBAlex> also why are all haskell users mac users :S
13:07:55 <SubStack> mac and cheese
13:07:56 <DBAlex> :(
13:07:58 <chessguy_work> haha. i wouldn't call myself a mac user, though i do have a mac. i split my time about evenly
13:08:01 <DBAlex> very worrying !
13:08:08 <DBAlex> ok
13:08:14 * SubStack uses debian the most
13:08:24 <mstr> but obv mac
13:08:34 <foo-nix> vav: I dunno, it compiled here in mere seconds where the targz file is 70M, I saw no errors and make returned 0.
13:08:46 <foo-nix> I assume all worked, let met test
13:08:56 <DBAlex> whats the point of using unix with a proprietary gui slapped on top
13:08:59 <DBAlex> use the real deal :)
13:09:07 <mstr> ah, u suck :)
13:09:08 <f4hy> How do I do the cartesian product of two lists?
13:09:24 <jpcooper> DBAlex, what is wrong with it being proprietary?
13:09:30 <jpcooper> IT MUST BE SHIT
13:09:35 <Gracenotes> f4hy: a nice convenient way is a list comprehension
13:09:38 <mauke> f4hy: liftM2 (,)
13:09:40 <DBAlex> jpcooper: nothing, I just don't see the point ...
13:10:11 <Gracenotes> or a function you can import from Control.Monad
13:10:23 <mstr> omg proprietary. richard stallman is turning is his grave
13:10:40 <seydar> rms is still alive
13:10:45 <DBAlex> lol
13:10:50 <seydar> but yea he's probably irking somewhere
13:10:56 <SubStack> spinning somewhere
13:10:59 <f4hy> Gracenotes: thanks, ya that works
13:11:12 <SubStack> somebody attach a turbine to this corpse!
13:11:18 <DBAlex> lol
13:12:28 * mmorrow loves how the sound card driver is locked in a 4 meter thick concrete buncker in osx
13:12:36 <mmorrow> bunker
13:12:59 <Gracenotes> @pl \a b -> a + o b
13:12:59 <lambdabot> (. o) . (+)
13:13:22 <mstr> mmorrow: that's what i'm thinking too when I listen to music
13:13:23 <mstr> ;)
13:14:29 <mmorrow> mstr: you mean while listening to quadruple-encrypted-communicating-back-to-the-mothership-your-favorite-color-and-credit-card-numbers audio files? ;)
13:14:56 <pchiusano> question about monads
13:15:31 <pchiusano> in the alternative formulation, in terms of fmap/join, a return/unit/pure function is still needed, right?
13:15:48 <mauke> yes
13:16:22 <pchiusano> ok
13:17:07 <DBAlex> c:\>cabal update
13:17:07 <DBAlex> Downloading the latest package list from hackage.haskell.org
13:17:07 <DBAlex> cabal: connect: failed (Connection timed out (WSAETIMEDOUT))
13:17:17 <DBAlex> is there some special way I need to configure cabal?
13:17:28 <DBAlex> i'm behind a proxy, could that be the issue ?
13:17:47 <Cheshire> yes
13:18:10 <seydar> how does @pl work?
13:18:32 <Heffalump> if the proxy isn't set in the registry, get the latest cabal-install and use the http_proxy environment variable to set it
13:18:38 <Gracenotes> @hackage pointfree
13:18:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
13:18:44 <Gracenotes> ^ pl stuffs
13:18:52 <seydar> thanks
13:19:03 <Gracenotes> it's also included in the lambdabot source
13:19:30 <DBAlex> ok
13:19:50 <DBAlex> I just set up an exception in windows firewall, seein if that helps
13:20:13 <DBAlex> Heffalump: theres no "cabal-install" for windows
13:20:23 <DBAlex> and that didn't work :(
13:21:00 <Saizan> DBAlex: cabal-install is the package with the cabal executable
13:21:23 <DBAlex> ok
13:21:28 <DBAlex> can I set the proxy in my config?
13:21:39 <Heffalump> DBAlex: cabal-install is the thing that gives you the cabal binary
13:21:56 <Heffalump> so you already have it, though quite likely not a recent enough version
13:22:02 <Heffalump> and no, you can't set it in your config
13:22:13 <Saizan> "cabal --version" to see the version
13:22:13 <DBAlex> Heffalump: I just download cabal.exe from http://www.haskell.org/cabal/download.html
13:22:36 <DBAlex> c:\>cabal --version
13:22:36 <DBAlex> cabal-install version 0.6.2
13:22:36 <DBAlex> using version 1.6.0.2 of the Cabal library
13:22:38 <Heffalump> oh, that version should support the http_proxy variable
13:22:44 <DBAlex> in my config?
13:22:47 <DBAlex> how do I set it
13:22:50 <Heffalump> no, in your environment
13:22:56 <Heffalump> set http_proxy=...
13:22:59 <DBAlex> ok
13:23:02 <DBAlex> in ghci or cabal?
13:23:10 <Heffalump> at the command prompt, before running cabal
13:23:27 <DBAlex> ah ok
13:23:52 <Heffalump> there is also somewhere you can put it in the registry
13:23:57 <Heffalump> but I can't remember where
13:26:01 <DBAlex> Heffalump: how long should the update take?
13:27:31 <Heffalump> DBAlex: I think the file it's downloading is about 1MB
13:27:39 <Heffalump> so however long that should take on your net connection
13:27:43 <DBAlex> ok
13:27:47 <DBAlex> shouldn't take this long...
13:28:27 <Heffalump> the format of the environment variable is http://proxy.host:port
13:28:28 <Heffalump> (I think
13:28:50 <DBAlex> ok
13:28:53 <DBAlex> c:\>set http_proxy=http://128.243.253.119:8080
13:28:58 <DBAlex> it was probably downloading before then
13:29:07 <DBAlex> i'll let it have 10 minutes and see if it work
13:29:08 <DBAlex> *s
13:32:56 <ImInYourMonad> OK i found a redblack tree in Java and I insert 100K elems and then query for the 50Kth, it is instant. and it is in Haskell also. them redblack them be goody goody compared to ordinary BSTs.
13:33:29 <ImInYourMonad> what is the worst case for a RBT?
13:34:03 <mauke> logarithmic
13:36:10 <ImInYourMonad> i meatn what kind of input? or it doesnt matter for RBT?
13:36:26 <ImInYourMonad> i tired 10million elems and it really takes a while but finishes
13:36:33 <ImInYourMonad> but javas versions seems to so
13:38:01 <skabooty> @src repeat
13:38:01 <lambdabot> repeat x = xs where xs = x : xs
13:38:13 <Cheshire> = fix (x:)
13:38:15 <ImInYourMonad> muaahaah java ran out of heap space
13:39:57 <ImInYourMonad> we should write a competitior for Joost!
13:40:01 <ImInYourMonad> or wait
13:40:09 <ImInYourMonad> we should write a better pirate bay!
13:40:56 <mauke> better how? :-)
13:41:07 <LeoD> unsueable!
13:41:08 <mstr> more pr0n
13:41:24 <Botje> ImInYourMonad: the big difference between red-black trees and normal BSTs: RB trees auto-balance
13:41:38 <Botje> so you always have O(lg n) lookups
13:41:55 <Botje> whereas BSTs can devolve into ordinary linked lists if you feed them a sorted ist
13:41:56 <ImInYourMonad> yeah i ahve done both of them myself in haskell
13:42:15 <ImInYourMonad> i was thinking about worst case for inserts
13:42:30 <Botje> in the worst case for RB trees you have to rotate every node you touch
13:42:34 <ImInYourMonad> because for BST i have O(n^2), for RBT it seems a lot better though
13:42:35 <Botje> i think
13:42:41 <ImInYourMonad> which i O is?
13:43:00 <Botje> still O(lg n)
13:43:04 <Botje> but it's spotty, for me
13:43:41 <mauke> you only touch nodes along the path from the root, whose length is O(log) if the tree is initially balanced
13:45:16 <Botje> ... which should be the case if you grew the tree from an empty one
13:46:02 <ImInYourMonad> ok
13:46:07 <ImInYourMonad> RBTs are cute
13:54:53 <Cheshire> @w80 emblematic
13:54:56 <lambdabot> *** "emblematic" wn "WordNet (r) 2.0"
13:54:56 <lambdabot> emblematic
13:54:56 <lambdabot>      adj 1: serving as a visible symbol for something abstract; "a crown
13:54:56 <lambdabot>             is emblematic of royalty"; "the spinning wheel was as
13:54:56 <lambdabot>             symbolic of colonical Massachusetts as the codfish"
13:54:58 <lambdabot> [4 @more lines]
13:57:17 <ImInYourMonad> how much overhead does Algebraic datastructures have? if i have a 100million Integer REDblack tree where red black tree:
13:57:18 <ImInYourMonad> data Color = Red | Black deriving(Show)
13:57:19 <ImInYourMonad> data RedBlackTree a =
13:57:19 <ImInYourMonad>     Leaf | Node Color a (RedBlackTree a) (RedBlackTree a)
13:57:19 <ImInYourMonad>            deriving(Show)
13:57:25 <ImInYourMonad> how much memory would that use?
13:57:40 <sm> readFile seems to be stripping \n's from file with standard unix line endings. Why is this ?
13:58:03 <Cheshire> ImInYourMonad: perhaps the easiest way is to actually measure it
14:00:05 <tibbe_> sm: readBinaryFile?
14:00:25 <sm> readFile in ghci works fine, but not in my script
14:01:55 <ImInYourMonad> Cheshire: more than my RAM :)
14:03:49 <tibbe> ImInYourMonad: check the space profiling so you know where the memory is going
14:04:14 <sjanssen> ImInYourMonad: algebraic data structures are really no different from anything else
14:04:47 <tibbe> sjanssen: how much overhead is the constructor tag? 1 byte?
14:04:51 <sjanssen> there will be one word taken up for the tag, a word for each data pointer, and a tag at the front for the garbage collector
14:05:05 <sjanssen> tibbe: a word, I don't think GHC bothers packing things into bytes
14:05:25 <tibbe> sjanssen: so 6 words for Node
14:05:34 <tibbe> sjanssen: and 3 for Leaf
14:05:49 <tibbe> sjanssen: does it unpack Color
14:05:52 <sjanssen> tibbe: possibly a couple more, I don't remember the exact layout
14:05:56 <tibbe> sjanssen: ok
14:06:26 <ImInYourMonad> how do I set maximum memory usage for ghc? it is annoying when you accidentally eat up all memory and make the computer unreponsive
14:06:26 <sjanssen> no, Color won't be unpacked because it isn't ! and is probably a sum type, which can't be unpacked
14:07:11 <tibbe> sjanssen: couldn't you unpack a sum type without data in it if it was strict?
14:07:20 <sjanssen> tibbe: GHC doesn't do it
14:07:37 <tibbe> sjanssen: hmm, not even with UNPACK? Color is just an enum
14:08:10 <sjanssen> tibbe: I'm pretty certain GHC never unpacks types with more than one constructor, but feel free to double check
14:08:57 <tibbe> sjanssen: I trust you
14:09:02 <tibbe> sjanssen: although I'm suprised
14:09:02 <beelsebob> tibbe: unpack means remove the tag
14:09:09 <beelsebob> how does it tell which one it is if there's no tag?
14:10:14 <tibbe> hmm
14:10:21 <sjanssen> tibbe: yeah, it could probably be a big gain in some cases, eg. Bool
14:10:27 <tibbe> sjanssen: yes
14:10:29 <Heffalump> I thought UNPACK means put the data in the same word as the tag
14:10:45 <tibbe> sjanssen: I don't want to emulate Bool with an unpacked int
14:11:06 <beelsebob> Heffalump: maybe I miss read the docs, but I read them a few days ago – I certainly read it as "just don't encode the tag"
14:11:31 <Heffalump> it doesn't actually say "don't encode the tag", but you're right that it only applies to single-constructor data according to the docs
14:11:41 <Heffalump> and I can't see why it would encode the tag under those circumstances
14:12:45 <beelsebob> would probably be an interesting few research projects – encoding types in a much more compact/efficient to decode way
14:13:03 <beelsebob> so that ghc could do stuff like encode 8 bools in a byte
14:13:31 <mmorrow> ghc doesn't even let you have anything smaller than a machine word currently
14:13:35 <beelsebob> yep
14:13:59 <ziman> not even Word8?
14:14:04 <mmorrow> nope
14:14:11 <mmorrow> Word8 = W8# Word#
14:14:19 <ziman> i see.
14:14:20 <mmorrow> Word32 = W32# Word#
14:15:43 <beelsebob> when you think about it – it's insane that haskell's performance is 2-3 times slower than Cs
14:15:52 <beelsebob> where there are some *really* dumb optimisations that could be done
14:16:19 <Heffalump> get to it :-)
14:16:35 <mmorrow> that makes me think that there should be an unpackW :: ByteString -> [Word32]
14:16:54 <mmorrow> because unpack :: ByteString -> [Word8] is wasting 3 bytes per byte
14:16:57 <tibbe> I guess you could use a ByteArray# to encode things in increments of a byte but it probably has some overhead
14:17:28 <tibbe> mmorrow: I guess the list is wasteful enough already
14:17:35 <Heffalump> mmorrow: just arrange to consume the list well
14:17:42 <tibbe> mmorrow: if you're going to fuse the unpack the element type probably doesn't matter
14:17:49 <mmorrow> yeah, i suppose
14:25:08 <ImInYourMonad> is Data.Graph a DAG?
14:25:18 <ImInYourMonad> how would you rep a dag?
14:25:20 <sbahra> roconnor, ping?
14:25:38 <beelsebob> ImInYourMonad: mutable, or constant?
14:27:50 <sjanssen> ImInYourMonad: Data.Graph is a general graph library, it can represent DAGs
14:27:55 <mmorrow> ImInYourMonad:  Map a (Set a)
14:27:59 <mmorrow> or faster:
14:28:02 <ImInYourMonad> data DAG v = Edge v [DAG v] | Vertex v ?
14:28:06 <mmorrow> ImInYourMonad:  IntMap IntSet
14:28:21 <beelsebob> ImInYourMonad: that only works for constant DAGs
14:28:32 <beelsebob> because otherwise you don't get sharing
14:28:35 <mmorrow> ImInYourMonad: that's a Tree
14:28:44 <beelsebob> mmorrow: no, it's a DAG
14:28:47 <beelsebob> as long as it's constant
14:28:54 <mmorrow> , src ''Tree
14:29:00 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
14:29:17 <Cheshire> , src ''Forest
14:29:19 <lunabot>  type Forest a = [Tree a]
14:29:23 <beelsebob> > let a = Vertex "jam" in Edge "ham" [a,a] -- definately a DAG
14:29:25 <lambdabot>   Not in scope: data constructor `Vertex'Not in scope: data constructor `Edge'
14:29:28 <mmorrow> the sharing isn't observable
14:29:28 <Cheshire> nice simple type
14:29:34 <sjanssen> that type is not a DAG because DAGs can have multiple source nodes
14:29:37 <beelsebob> mmorrow: true
14:29:47 <beelsebob> sjanssen: oh, fair point
14:29:51 <sjanssen> and cross edges
14:29:59 <mmorrow> , levels $ fix (\me -> Node () [me,me]) {- i like this one -}
14:30:00 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
14:30:14 <sjanssen> well, I suppose you could still represent cross edges.  It wouldn't be pretty
14:30:17 <beelsebob> newtype DAG a = [Tree a] would work as a DAG then
14:30:27 <sbahra> For the interested, http://www.reddit.com/r/logic
14:30:30 <beelsebob> but only for constant ones
14:31:10 <ImInYourMonad> with constant you mean?
14:31:19 <ImInYourMonad> you construc tit once and never insert?
14:31:26 <beelsebob> I mean, as long as you don't want to change it
14:31:27 <mae_work> dcoutts: is something wrong with the hackagedb upload? I am getting a 400 bad request.
14:31:28 <ImInYourMonad> cross edge?
14:31:31 <beelsebob> or make duplicates with changes in them
14:31:36 <beelsebob> because you can't keep the sharing
14:31:53 <beelsebob> if you want to keep sharing, you need Map a (Set a)
14:31:56 <mae_work> dcoutts: nm disregard
14:32:19 <sjanssen> ImInYourMonad: the graph A -> B, C -> B has two sources and a cross edge
14:32:39 <sjanssen> cross edges are what make a DAG not a tree
14:33:06 <mmorrow> beelsebob: but by that same logic you can call any recursive haskell type a graph
14:33:17 <beelsebob> mmorrow: yes... they are
14:33:21 <mmorrow> , fix (\me -> 0 : me)
14:33:23 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:33:38 <beelsebob> that's rather the same logic as prolog gives you one algorithm: deapth first search though
14:33:39 <mmorrow> , fix id
14:33:41 <lunabot>  luna: out of memory (requested 2097152 bytes)
14:33:42 <mmorrow> , [(0,[0])]
14:33:44 <lunabot>  [(0,[0])]
14:34:05 <mmorrow> i think he want to rep a graph at the haskell level instead of the rts level
14:34:33 <beelsebob> well yeh – and that type does at the haskell level – because Haskell gives you explicit sharing
14:35:05 <mmorrow> beelsebob: but if you're handed one of those, you can't tell whether there's any sharing or not
14:35:07 <sjanssen> ImInYourMonad: anyway, probably the easiest representation for a graph in Haskell is Map node (Set node)
14:35:31 <mmorrow> and what if the haskell implem doesn't even implement sharing?
14:35:33 <beelsebob> mmorrow: true, and that's what means that it only works for constant DAGs
14:35:33 <mmorrow> ;)
14:35:45 <beelsebob> mmorrow: IIRC the spec requires that constants are evaluated at most once
14:36:04 <Cheshire> morrow that is the nightmare
14:36:11 <mmorrow> beelsebob: i thought that sharing wasn't required to be implem
14:36:12 <sjanssen> beelsebob: the Edge v [Dag v] representation also allows invalid graphs
14:36:22 <beelsebob> sjanssen: does it?
14:36:22 <mmorrow> anyways, i'm just playing devil's advocate
14:36:27 <beelsebob> oh, cyclic ones, yes
14:36:29 <mmorrow> Cheshire: heh
14:36:34 <beelsebob> but so do all other types I've seen for DAGs
14:36:42 <sjanssen> beelsebob: not just cycles, graphs that make no sense too
14:36:47 <beelsebob> sjanssen: really?
14:37:12 <beelsebob> example?
14:37:13 <ImInYourMonad> http://en.wikipedia.org/wiki/Bayesian_network <- what i wanna do
14:37:44 <sjanssen> beelsebob: Edge 'a' [Edge 'b' Node, Edge 'c' [Edge 'b' [Edge 'd' Node]]
14:37:51 <ImInYourMonad> with sharing you mean optimized sharing by ghc?
14:38:09 <beelsebob> sjanssen: where did Node come from?
14:38:13 <sjanssen> beelsebob: what are the out-edges of 'b'?
14:38:22 <beelsebob> sjanssen: 'b' is not the node
14:38:26 <beelsebob> Edge 'b' is
14:38:30 <beelsebob> and they're not shared
14:38:36 <beelsebob> so there are two nodes in this DAG, which contain the data 'b'
14:38:39 <sjanssen> beelsebob: oh, node means no out edges (alternative is Edge x [])
14:38:49 <beelsebob> ah, okay
14:38:58 <beelsebob> then yeh, there are two nodes containing the data 'b'
14:39:03 <beelsebob> one of them has no out edges
14:39:06 <sjanssen> I don't think you're making sense
14:39:11 <beelsebob> one has 1 out edge to a node containing 'd'
14:39:11 <beelsebob> sec
14:39:13 <mmorrow> ImInYourMonad: yes, in the sense that  "fix (\me -> 0 : me)"  is a heap node  with a ptr to "0" and a ptr to itself
14:39:17 <beelsebob> I'll sketch that one
14:39:45 <mmorrow> ImInYourMonad: so although it's an "infinite list" it only takes up two words of storage (plus a header or whatever)
14:39:45 <Gracenotes> > (if False then "a" else "b" ++ "suffix", (if False then "a" else "b") ++ "suffix")
14:39:46 <lambdabot>   ("bsuffix","bsuffix")
14:39:53 <pumpkin_> moo
14:39:55 <Gracenotes> hrm.
14:40:15 <Gracenotes> probably should have picked an example that would actually be helpful
14:40:17 <Gracenotes> > (if True then "a" else "b" ++ "suffix", (if True then "a" else "b") ++ "suffix")
14:40:18 <lambdabot>   ("a","asuffix")
14:40:22 <Gracenotes> oic
14:41:15 * beelsebob waits for graphviz to install
14:42:01 <pumpkin_> > fix ("moo" ++)
14:42:02 <lambdabot>   "moomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomoomo...
14:42:41 <beelsebob> > unlines . fix $ ("moo" :)
14:42:43 <lambdabot>   "moo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\nmoo\...
14:42:58 <pumpkin_> fail
14:43:02 <beelsebob> :(
14:43:03 <pumpkin_> you're mooning
14:43:06 <pumpkin_> I was mooing
14:43:09 <pumpkin_> you'
14:43:14 <pumpkin_> re a drunk dude, I'm a cow
14:44:05 * mmorrow thought pumpkin_ was a kangaroo
14:44:19 * mmorrow 's world is shattered
14:44:25 <pumpkin_> I like to hang out in kangaroo pouches occasionally
14:44:31 <dolio> I'm not sure beelsebob is the one who's likely drunk in this scenario.
14:44:31 <pumpkin_> but I've never been a kangaroo, nope :/
14:44:35 <beelsebob> hehe
14:44:47 <ImInYourMonad> type BayesianNetwork a = M.Map a (S.Set a)
14:44:52 <ImInYourMonad> bn :: BayesianNetwork a
14:44:56 <ImInYourMonad> could not deduce ord
14:45:03 <pumpkin_> that sounds like Graph to me
14:45:14 <ImInYourMonad> bn :: (Num a, Ord a) => BayesianNetwork a
14:45:14 <mmorrow> bn :: (Ord a) => BayesianNetwork
14:45:15 <ImInYourMonad> !
14:45:18 <mmorrow> + a
14:45:34 <mae_work> dcoutts: are you around?
14:47:31 <EvilTerran> > map (chr.(111-).(`mod`4).ord) $ fix show
14:47:32 <lambdabot>   "momooomooooooomooooooooooooooomooooooooooooooooooooooooooooooomooooooooooo...
14:47:51 <beelsebob> hehe, nice EvilTerran
14:47:51 <EvilTerran> :D
14:49:00 <pgs31> evenin' all
14:49:06 <pgs31> Got a newb question for you all
14:49:14 <TuringTest> shoot
14:49:24 <pgs31> Is it possible to derive only cetain methods of a class.
14:49:37 <pgs31> For example, I have something which is mostly an enum
14:49:56 <pgs31> Except I want to provide my own 'succ' method
14:50:05 <whpearson> Nope, although you can leave them = undefined if you are sure nothing will use them....
14:50:06 <pgs31> The autogenerated ones are fine for everything else
14:50:22 <pgs31> ah okay :)
14:50:51 <pgs31> What I am trying to do is make a data type which is almost like an enum but which wraps around
14:50:59 <TuringTest> NOOOOO
14:51:01 <beelsebob> sjanssen: this is the dag you encoded... http://www.cs.kent.ac.uk/people/rpg/tatd2/dag.pdf
14:51:06 <pgs31> so if you keep calling succ it will start again at the end..
14:51:11 <pgs31> Am I going about this the right way?
14:51:23 <TuringTest> pgs31:  Uh....maybe
14:51:28 <pgs31> My plan is to write an instance of enum
14:51:50 <whpearson> @src Enum
14:51:50 <lambdabot> class  Enum a   where
14:51:50 <lambdabot>     succ                     :: a -> a
14:51:50 <lambdabot>     pred                     :: a -> a
14:51:50 <lambdabot>     toEnum                   :: Int -> a
14:51:50 <pgs31> Where succ and pred wrap around
14:51:51 <lambdabot>     fromEnum                 :: a -> Int
14:51:55 <lambdabot> [3 @more lines]
14:51:55 <TuringTest> You must NOT also define a Bounded instnace
14:52:08 <pgs31> sure
14:52:13 <pgs31> That would be silly :)
14:52:28 <EvilTerran> an Ord instance might also muddy things
14:52:43 <sjanssen> beelsebob: oh, so node labels are meaningless?
14:52:46 <pgs31> hmmm yes
14:52:47 <adamvo> pgs31: you could write a regular function for wrapping around for things with bounded and enum
14:52:51 <beelsebob> they're the data encoded at the node sjanssen
14:52:52 <pgs31> yes
14:52:54 <TuringTest> pgs31: Why can't you derive Enum and define a circSucc and circPred ?
14:52:55 <pgs31> that might be better
14:52:56 <sjanssen> beelsebob: also, this means the representation can't encode cross edges (ie. is a tree)
14:53:00 <beelsebob> sure it can
14:53:11 <pgs31> Sounds like the sort of thing that should already exist
14:53:22 <pgs31> I keep writing these things and finding them later in the standard library ;)
14:53:27 <sjanssen> beelsebob: remember that sharing is not detectable in Haskell
14:53:28 <pgs31> Good practice at least
14:53:32 <beelsebob> let b = Edge "b" [Edge "c" []] in Edge "a" [b,b] -- like this sjanssen
14:53:40 <beelsebob> sjanssen: that doesn't mean it doesn't encode them
14:53:54 <beelsebob> I admit there are reasons why you might not want to use that
14:54:10 <sjanssen> there are also legal implementations of Haskell which do not use sharing
14:54:11 <beelsebob> but if all you need to do is traverse it, then meh – this works fine as a DAG
14:54:18 <TuringTest> pgs31: When we need to iterate over a wrap-around sequence we use "cycle"
14:54:22 <beelsebob> sjanssen: really?
14:54:35 <TuringTest> pgs31: but that does not give "pred" like movement
14:54:36 <beelsebob> I thought constants had to be evaluated at most once in Haskell
14:54:53 <sjanssen> beelsebob: nope, Haskell is only non-strict, not necessarily lazy
14:55:04 <beelsebob> oh wait no
14:55:05 <pgs31> TuringTest: cheers - I thought that was just for lists
14:55:10 <beelsebob> it's only if they're CAFs
14:55:15 <sjanssen> beelsebob: case in point, GHC will duplicate evaluations under the right circumstances
14:55:20 <pgs31> TuringTest: But I will play, I don't need pred actually
14:55:23 <sjanssen> beelsebob: that is also not guaranteed in Haskell '98
14:55:24 * EvilTerran is a big proponent of the Map NodeId (Set NodeId) approach
14:55:24 <beelsebob> okay – so it's a DAG – iff, you use CAFs for the sharing
14:55:36 <beelsebob> really?
14:55:40 <beelsebob> I was sure that was
14:56:10 <EvilTerran> the report doesn't say anything WRT how you evaluate things, IIRC
14:56:19 <EvilTerran> just that you've got to wind up with non-strict semantics
14:56:35 <sjanssen> the report avoids operational semantics almost entirely
14:57:57 <ImInYourMonad> when combining Map and Set etc, if the combined types are Showable arent they Showable combined?
14:58:06 <EvilTerran> ?instances-importing Data.Map Show
14:58:07 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Map k a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
14:58:12 <beelsebob> sjanssen: so... why the monomorphism restriction
14:58:15 <EvilTerran> ?instances-importing Data.Set Show
14:58:15 <pumpkin_> someone should make a MultiMap
14:58:16 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Set a, Sum a, [a]
14:58:22 <EvilTerran> ImInYourMonad, yes
14:58:27 <pumpkin_> Maps of Sets are too common
14:58:28 <beelsebob> I thought that was only there to guarentee CAFs could be evaluated at most once
14:58:53 <sjanssen> beelsebob: because sharing CAFs is an anticipated implementation strategy, but it isn't mandated
14:59:02 <beelsebob> oh, lame that the MR is then :(
14:59:17 <vovik> pl sum
14:59:20 <vovik> @pl sum
14:59:20 <lambdabot> sum
14:59:24 <ImInYourMonad> add an instance declaration for (Show ([k] -> [a] -> M.Map k a))
14:59:29 <ImInYourMonad> what does it want there?
14:59:31 <pumpkin_> @. pl src sum
14:59:31 <lambdabot> (line 1, column 1):
14:59:31 <lambdabot> unexpected end of input
14:59:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:59:35 <vovik> @pl \x -> x+1
14:59:36 <lambdabot> (1 +)
14:59:36 <pumpkin_> @src sum
14:59:36 <lambdabot> sum = foldl (+) 0
14:59:36 <sjanssen> ImInYourMonad: you can't show functions
14:59:41 <pumpkin_> ah
14:59:41 <mauke> ImInYourMonad: my crystal ball says: use more parens
15:00:50 <ImInYourMonad> bn :: (Num a, Ord a) => [a] -> [a] -> BayesianNetwork a
15:00:54 <ImInYourMonad> type BayesianNetwork a = M.Map a (S.Set a)
15:00:59 <ImInYourMonad> cant i show that?
15:01:31 <sjanssen> ImInYourMonad: you can show "bn [] []" but you can't show "bn"
15:03:40 <gbacon> ?google does this plugin still work?
15:03:41 <lambdabot> http://groups.google.com/group/publicity-tools/browse_thread/thread/a496b6301880e42c/57ced215873185ac?lnk=gst&q=
15:03:41 <lambdabot> Title: Does Feedsmith Plugin Still Work After Move? - Publicity Tools | Google Groups
15:03:49 <gbacon> hmmm
15:06:39 <TuringTest> I have a performance glitch.  Some detail is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2106#a2106
15:07:07 <TuringTest> Has anyone else ever seen code (compiled with -O2) go faster with -prof than without -prof?
15:07:24 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2107#a2107 <- what i use now, so good?
15:08:24 <pumpkin_> TuringTest: are you human?
15:08:28 <TuringTest> ImInYourMonad: look okay to me
15:08:33 <TuringTest> pumpkin_: No
15:09:30 <ehird> Wha tis "buildPrograms"'s replacement in recent Cabal?
15:11:57 <Gracenotes> , help
15:11:59 <lunabot>  type of an expression:      , [$ty| \x -> x |]
15:11:59 <lunabot>  get info for a type/class:  , src ''Monad
15:11:59 <lunabot>  get info for a var/con:     , src 'fix
15:13:03 <tromp_> @src sum
15:13:03 <lambdabot> sum = foldl (+) 0
15:26:40 <ImInYourMonad> euclideanDistance = sqrt . fromIntegral . sum . zipWith (\x y -> (x - y)^2)
15:26:53 <ImInYourMonad> why isnt that allowed?
15:26:54 <ImInYourMonad> euclideanDistance xs ys = sqrt $ fromIntegral $ sum $
15:26:54 <ImInYourMonad>                           zipWith (\x y -> (x - y)^2) xs ys
15:26:58 <ImInYourMonad> i ahve to do that
15:27:15 <pumpkin_> zipWith takes two arguments
15:27:29 <mauke> euclideanDistance = ((sqrt . fromIntegral . sum) .) . zipWith (\x y -> (x - y) ^ 2)
15:27:31 <pumpkin_> you'd need (sqrt . fromIntegral . sum .) . zipWith (\x y -> (x - y) ^2
15:27:40 <pumpkin_> damn
15:27:47 <pumpkin_> you beat me and typed it right too
15:27:51 <pumpkin_> I fail
15:27:57 <travisbrady> is "let ll = sortBy ((. snd) . flip compare . snd) $ M.toList freqFold" the preferred way of converting a Map to a list of pairs sorted by the second in descending order?  i find the sortBy bit sort of tough to read
15:29:07 <BONUS> how about
15:29:16 <BONUS> sortBy (flip compare `on` snd)
15:30:13 <EvilTerran> or "sortBy cmp ... where cmp ... = ..." :)
15:30:50 <travisbrady> @src on
15:30:50 <lambdabot> (*) `on` f = \x y -> f x * f y
15:33:22 <BONUS> ahaha
15:33:42 <BONUS> http://twitter.com/sigfpe/status/1280908708
15:35:23 <ddarius> Whew.  That reminded me to check Catsters.
15:35:42 <Cheshire> is there any sensible order to watch the catsters videos in?
15:35:50 <ddarius> Cheshire: The order they were posted.
15:38:30 <travisbrady> @help
15:38:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:38:39 <travisbrady> @list
15:38:40 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:39:05 <travisbrady> @hoogle on
15:39:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:39:06 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
15:39:06 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
15:46:36 <TomMD> sw17ch: You made scurry, right?
15:46:37 <ImInYourMonad> machinelearning is @dead
15:46:56 <TomMD> @tell sw17ch scurry: user error (Pattern match failure in do expression at src/Scurry/Comm.hs:71:8-12)
15:46:56 <lambdabot> Consider it noted.
15:47:19 <ImInYourMonad> for 2 vectors of movieratings or songratings, lets say rated 1-5 or like/dislike,  what is the best way to determine similarity? euclidean distance, cosineSimilarity, tanimotoCoefficient? or: abs $ zipWith (-) ?
15:51:29 <ImInYourMonad> is it really ok that head [] throws an exception?
15:52:00 <ImInYourMonad> if creating a language in haskell, how do I define a function?
15:52:07 <ImInYourMonad> i mean a lambda
15:52:12 <ImInYourMonad> a genera notion of a function
15:53:07 <kiris> yo
15:53:11 <Cheshire> it is ok that head [] throws, the alternative is that every program you write in haskell terminates in finite time
15:53:32 <Cheshire> (or produces a steady stream of things)
15:53:44 <osfameron> or safeHead :: [a] -> Maybe a
15:54:02 <Cale> ImInYourMonad: You'd generally include some kind of constructor or case in the syntax of your language for a lambda.
15:54:48 <wli> :t listToMaybe
15:54:49 <lambdabot> forall a. [a] -> Maybe a
15:54:56 <wli> There's your safeHead
15:55:08 <chrisdone> I got myself a new four core PC, yay!! now I can actually use Haskell's concurrency stuff ^___^
15:55:15 <Cale> ImInYourMonad: You can use higher order abstract syntax if you want, using functions to represent functions, it's more convenient or less convenient in different circumstances.
15:55:43 <Cheshire> more convenient or less convenient? ;p
15:56:52 <Cale> On the one hand, you don't have to muck about with explicitly representing variables and worrying about substitution yourself, on the other hand, functions are opaque, so if you need to transform the code, it's not as handy.
15:57:11 <edwardk> Cheshire: depends on what you want to do. if you want dependent types, it can be really really inconvenient
15:57:33 <Cheshire> the biggest problem I had with is:   (a -> Maybe b) -> (Maybe (a -> b))
15:57:44 <Cheshire> you can't implement that
15:57:53 <Cheshire> (other that const Nothing)
15:58:50 <edwardk> yeah, that comes back to the length of costrength for ->
16:00:15 <edwardk> http://comonad.com/reader/2008/deriving-strength-from-laziness/ talks about that problem. (though I use Either rather than Maybe)
16:02:15 <pumpkin_> edwardk: you should write more blog entries :)
16:03:23 <edwardk> pumpkin_: i've been busy lately, and was caught in a bit of a coding slump or so for a couple of months. i'm motivated again, so you might see some new stuff ;)
16:03:32 <pumpkin_> yay
16:03:57 <edwardk> found a nice catamorphism knol in russian today
16:04:03 <pumpkin_> :o
16:04:11 <pumpkin_> meow!
16:04:29 <edwardk> http://knol.google.com/k/dark-magus/-/35awqcg5z1brp/276#
16:05:55 <pumpkin_> unfortunately I don't read russian :) luckily the haskell is in haskell
16:13:09 <Gracenotes> @hoogle Int -> Int -> [Char]
16:13:09 <lambdabot> Distribution.Simple.Command commandShowOptions :: CommandUI flags -> flags -> [String]
16:13:10 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
16:13:10 <lambdabot> Data.Fixed div' :: (Real a, Integral b) => a -> a -> b
16:13:14 <Gracenotes> XO:
16:13:53 <pumpkin_> nice
16:14:48 <Gracenotes> > showIntAtBase 2 intToDigit 43920
16:14:49 <lambdabot>       Overlapping instances for Show (String -> String)
16:14:49 <lambdabot>        arising from a...
16:14:55 <Gracenotes> :X
16:15:07 <Gracenotes> @type showIntAtBase
16:15:08 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:15:20 <Gracenotes> oh... :\
16:15:26 <Gracenotes> > showIntAtBase 2 intToDigit 43920 ""
16:15:27 <lambdabot>   "1010101110010000"
16:15:52 <Gracenotes> so much just for a binary show
16:16:01 <mauke> preflex: calc '2 pi
16:16:01 <preflex>  11.001001000011111101101010100010001000010110100011
16:16:48 <mauke> (let's see you do that in haskell!)
16:17:07 <skorpan> > putStr "11.001001000011111101101010100010001000010110100011"
16:17:09 <lambdabot>   * Exception: "<IO ()>"
16:17:12 <skorpan> aw shit
16:17:44 <omnihil> haha
16:17:59 <omnihil> > "11.001001000011111101101010100010001000010110100011"
16:18:01 <lambdabot>   "11.001001000011111101101010100010001000010110100011"
16:18:07 <skorpan> > 11.001001000011111101101010100010001000010110100011
16:18:08 <lambdabot>   11.001001000011112
16:18:15 <skorpan> it's actually harder than i thought :|
16:18:15 <whoppix> :)
16:18:22 <skorpan> > 11.001001000011111101101010100010001000010110100011 :: Double
16:18:23 <lambdabot>   11.001001000011112
16:18:27 <skorpan> no, that didn't do it...
16:19:02 <skorpan> > show $ read 11.001001000011111101101010100010001000010110100011
16:19:04 <lambdabot>       No instance for (Fractional String)
16:19:04 <lambdabot>        arising from the literal `11...
16:19:39 <mauke> > 11.001001000011111101101010100010001000010110100011 :: CReal
16:19:40 <lambdabot>   11.0010010000111111011010101000100010000101
16:19:45 <mauke> almost
16:20:02 <MyCatVerbs> What on Earth is a CReal, anyway?
16:20:11 <skorpan> isn't that a C "real number"?
16:20:20 <mauke> it's a breakfast creal
16:20:26 <MyCatVerbs> Well yes, but a double or a float?
16:20:30 <mauke> (a computable number)
16:20:31 <skorpan> maybe they meant creol
16:20:48 <mauke> also, arbitrary precision
16:20:50 <MyCatVerbs> It seems... not entirely sane, to use the term "Real" when C uses the terms "double" and "float". Especially when Haskell uses Double and Float too!
16:21:05 <pumpkin_> it deal with all the computable reals
16:21:08 <pumpkin_> *deals
16:21:26 <skorpan> mauke: what language is preflex written in?
16:21:29 <MyCatVerbs> Oh, it's something other than just a Foreign.C.Types type?
16:21:43 <pumpkin_> MyCatVerbs: it's arbitrary precision floating
16:21:43 <newsham> mycat: the Double and Float are closely related to C double and float, no?  whats the problem?
16:21:44 <mauke> skorpan: haskell
16:21:56 <pumpkin_> > showCReal pi
16:21:57 <lambdabot>       Overlapping instances for Show (CReal -> String)
16:21:57 <lambdabot>        arising from a ...
16:21:57 <newsham> CReal is not closely related to those.
16:22:04 <pumpkin_> > showCReal 100 pi
16:22:05 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:22:37 <newsham> > last $ showCReal 10000
16:22:38 <lambdabot>   Couldn't match expected type `[a]'
16:22:49 <aluink> would it be considered redundant to say "haskell objects and functions"?
16:22:53 <MyCatVerbs> newsham: nothing. I had assumed (oops) that *all* types prefixed with 'C' were part of the C FFI.
16:23:00 <newsham> ahh
16:23:13 <pumpkin_> MyCatVerbs: it's not a standard library, so the naming may be a bit nonstandard :)
16:23:14 <mauke> yeah, the name is unfortunate
16:23:17 <MyCatVerbs> aluink: "values and functions" would be better. Or even just "values", because functions are values too.
16:23:21 <pumpkin_> MyCatVerbs: but it stands for ComputableReals
16:23:33 <MyCatVerbs> Uhuh. How do you set the precision?
16:23:48 <skorpan> mauke: so how did it perform the "calculation"?
16:23:49 <mauke> Char is a C har!
16:23:50 <MyCatVerbs> Or is it based on Cauchy numbers or something?
16:23:54 <newsham> > last $ showCReal 1000 pi
16:23:55 <lambdabot>   '9'
16:23:56 <Gracenotes> newtype CReal = CReal (Int -> Integer)
16:24:00 <Gracenotes> iirc
16:24:05 <mauke> skorpan: that part is actually written in C
16:24:09 <aluink> MyCatVerbs: expand on how functions are values
16:24:16 * BMeph|away snatches the Category class away from the newsh, before he does something...unsavory
16:24:17 <Gracenotes> don't be such a Creal killer, MyCatVerbs! :O
16:24:39 <newsham> bmeph: what did I do now?
16:24:42 <mauke> skorpan: http://mauke.ath.cx/preflex/ext/wcalc.c
16:25:11 <pumpkin_> MyCatVerbs: the number itself is "infinite precision" but you ask for specific numbers of digits with the showCReal function
16:25:38 <skorpan> mauke: C code using 8 spaces of indentation? i think i'll pass :)
16:25:40 <aluink> @type showCReal
16:25:41 <Gracenotes> the Show instance for CReal calls showCReal with a smallish amount
16:25:41 <lambdabot> Int -> CReal -> String
16:25:51 <mauke> skorpan: not 8 spaces. 1 tab.
16:26:00 <skorpan> mauke: so even worse!
16:26:09 <mauke> no, because now it's user configurable
16:26:12 <Gracenotes> feel free to take a peek: http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/src/Data-Number-CReal.html
16:26:13 <BMeph|back> newsham: Whoops, missed the front of the convo, Carry On! ;p
16:26:25 <MyCatVerbs> aluink: you can pass them around like any other value. You can put them in lists, in arbitrary data structures...
16:26:36 <skorpan> mauke: i'm sure eight spaces are just as configurable
16:26:47 <mauke> how?
16:26:59 <MyCatVerbs> pumpkin_, Gracenotes: ah, that's handy.
16:27:06 <mauke> and is it as easy as :set ts=3?
16:27:16 <pumpkin_> it'd be nice to get an infinite list of digits from a CReal
16:27:22 <pumpkin_> that you can then trim using standard list functions
16:27:34 <skorpan> mauke: i have no idea how difficult it is. i'm just pretty darn confident that such things exist.
16:27:40 <MyCatVerbs> mauke: :set sw=3 too. You want both tabstop and shiftwidth. Also, set expandtab or noexpandtab appropriately.
16:27:58 <mauke> ts is sufficient for viewing
16:28:09 <Gracenotes> > read "59.897088787983485972365892736587236945287693485" :: CReal
16:28:11 <lambdabot>   59.8970887879834859723658927365872369452877
16:28:14 <mauke> (code was written with ts=4 sw=4 noet)
16:28:21 <Gracenotes> > read "59.897088787983485972365892736587236945287693485" :: Double
16:28:22 <lambdabot>   59.897088787983485
16:28:46 <MyCatVerbs> mauke: IIRC, ts sets how many spaces vim equates a tab with, sw sets how many spaces you make when you hit the tab key. Setting ts and sw to different values produces bizarre and (if noexpandtab is set) evil results.
16:29:01 <mauke> no
16:29:16 <mauke> sw is how much to indent
16:29:31 <mauke> vim normally uses a mix of spaces and tabs to reach the current indentation level
16:30:06 <mauke> if et is on, it's spaces only; if sw is an exact multiple of ts, it's tabs only
16:30:47 * skorpan awaits the emacs users' responses
16:30:59 <Spark> it's just an endless list of useless features!
16:31:06 <Spark> oh, wait, that was hypocrisy
16:31:07 <Spark> damn
16:31:10 <MyCatVerbs> mauke: yyyyes... that's what I said. Mixing tabs and spaces is bizarre and evil.
16:31:18 <Spark> i just use spaces
16:31:22 <Spark> tabs are just a pain in the arse
16:31:22 <mauke> sw has nothing to do with the tab key
16:31:23 <Spark> constantly
16:31:48 <Spark> sw is used when you shift with >> and <<
16:31:57 <Spark> and is presumably used in any autoindenting that it does
16:32:02 <mauke> right
16:32:03 <Spark> which i have disabled because it's annoying
16:32:05 <augustss> They are, especially since some systems have corrupted tabs to not be every 8 characters.
16:32:25 <mauke> Spark: depends on the language
16:32:28 <Spark> the whole point is that they are variable
16:32:30 <Gracenotes> > text "qrs\tuv"
16:32:31 <lambdabot>   qrs        uv
16:32:35 <Spark> platform-dependent
16:32:37 <Spark> that was their design goal
16:32:46 <mauke> I can't stand vim's autoindenting for javascript, but for C it's perfect
16:32:48 <Spark> unfortunately who the hell wants text files that look different everywhere
16:32:58 <Spark> pasting becomes a pain though
16:32:59 <Gracenotes> it seems lambdabot likes converting em to spaces
16:33:03 <mauke> Spark: nope
16:33:12 <skorpan> mauke: i'm sure you'll enjoy my yi javascript mode when i'm done with it! :)
16:33:32 <Spark> tabs and irc don't mix very well
16:33:36 <Spark> too many clients can't display them
16:34:02 <skorpan> my emacs just showed eight spaces for some reason
16:34:05 <Spark> 	
16:34:12 <skorpan> okay, that's a tab
16:34:17 <gwern> @remember AchimSchneider Finite automata don't go bottom in any case, at least not if you don't happen to shoot them and their health drops below zero.
16:34:17 <lambdabot> It is stored.
16:34:20 <gwern> @flush
16:34:23 <gwern> @quote bottom
16:34:24 <lambdabot> KetilMalde says: No, those are quite outdated by now.  The new horsemen of the programming apocalypse are, of course, IO, MutableState, LazyMemoryLeak, and Bottom.
16:34:41 <Spark> it just renders as a special 'I' for me
16:34:55 <skorpan> you mean like ^I?
16:35:00 <Spark> yeah but in one char
16:35:03 <skorpan> oh
16:35:10 <skorpan> makes sense though
16:35:11 <Gracenotes> >:O
16:36:41 <Spark> mauke: i have to wonder, is set paste implemented via timing? because it seems to break when there is a lot of 'ssh' and 'screen' going on
16:37:00 <mauke> uh, no idea
16:37:31 <mauke> I set mouse=a and don't worry about 'paste'
16:37:42 <Spark> what does that do
16:37:57 <mauke> :h 'mouse
16:38:01 <Spark> ah it interacts with x
16:38:08 <Spark> that won't work over ssh and screen will it
16:38:33 <Spark> it appears not
16:39:20 <omnihil> you can run gvim through ssh/screen
16:39:25 <omnihil> and connect back to your $DISPLAY
16:39:48 <Spark> that assumes the destination system has lots of extra software installed
16:39:57 <Spark> i have never actually used gvim
16:40:00 <Spark> i just use xterms and vim
16:40:49 <Spark> i have to compile vim on some of the servers i'm working with now, there's no way i'm compiling X and gtk and god knows what else
16:41:00 <omnihil> have to compile vim?
16:41:03 <omnihil> that's unfortunate
16:41:11 <Spark> it's not the end of the world
16:41:21 <Spark> the lack of xterm-256color is annoying thoguh
16:41:22 <omnihil> at least you aren't stuck with ed.
16:41:24 <Spark> not sure what i can do about that
16:41:37 <Spark> the problem is usually that there is a vim installed but it's from 1999 or somethign
16:42:30 <Wi_> @type map
16:42:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:44:17 <BMeph|back> Spark: Yeah, I remember that show, it was pretty neat, despite the odd 70's things thrown in. ;)
16:57:52 <ImOuttaYourMonad> if i have a 3-tuple or 3-elem-list, how do I sort on the 3rd one?
16:58:12 <ImOuttaYourMonad> i now on 2tupeli can do: sortBY (O.comparing snd) xs
16:58:18 <Botje> sortBy (compare `on` trd)
16:58:25 <Botje> where trd is a function you wrote yourself :)
16:58:29 <Botje> comparing works too
16:58:48 <ImOuttaYourMonad> what happened to boegel? did he win the netflix prize
17:01:06 <Gracenotes> I'm not sure if anyone has one the netflix prize yet
17:02:51 <Gracenotes> won. homophone schmomophone.
17:02:59 <pumpkin_> :o
17:03:43 <centrinia> ImOuttaYourMonad, Try sortBy (on compare (\(_,_,z) -> z))
17:03:55 <centrinia> You will have to import Data.Function
17:03:56 <Gracenotes> don't be such a homophone, pumpkin_
17:05:05 <pumpkin_> I'm a heterophone, thank you very much
17:05:54 <Gracenotes> ring ring ring ring ring ring heterophone
17:07:17 <ImOuttaYourMonad> where is on?
17:07:30 <pumpkin_> Data.Function
17:07:31 <Gracenotes> Data.Functionp
17:07:35 <Gracenotes> -p
17:07:39 <pumpkin_> sorry Gracenotes, just give up
17:08:05 <Gracenotes> You just have an answer, I have an answer *and* a diff file
17:08:06 <centrinia> (\(_,_,x) (_,_,y) -> compare x y) also works.
17:08:19 <pumpkin_> centrinia: but it's so much more obvious
17:08:26 <pumpkin_> why would you want to do something in a clear manner??
17:08:29 <pumpkin_> being obscure is fun
17:08:39 <pumpkin_> and on happens to also sound good in english
17:08:43 <centrinia> @pl \(_,_,x) (_,_,y) -> compare x y
17:08:43 <lambdabot> (line 1, column 6):
17:08:43 <lambdabot> unexpected ","
17:08:43 <lambdabot> expecting operator or ")"
17:08:43 <lambdabot> ambiguous use of a non associative operator
17:09:08 <Gracenotes> in this case, "on" can be reduced to pattern matching (there is no third function), but that's not always the case
17:09:26 <centrinia> That sucks, I think @pl doesn't deal with triples. :(
17:09:31 <pumpkin_> guess not :)
17:09:35 <centrinia> @pl \(_,_,x) -> x
17:09:36 <lambdabot> (line 1, column 6):
17:09:36 <lambdabot> unexpected ","
17:09:36 <lambdabot> expecting operator or ")"
17:09:36 <lambdabot> ambiguous use of a non associative operator
17:09:44 <centrinia> @pl \(x,y,z) -> x y z
17:09:45 <lambdabot> (line 1, column 6):
17:09:45 <lambdabot> unexpected ","
17:09:45 <lambdabot> expecting letter or digit, operator or ")"
17:09:45 <lambdabot> ambiguous use of a non associative operator
17:10:01 <centrinia> @pl \(x,(y,z)) -> x y z
17:10:01 <lambdabot> uncurry ((`ap` snd) . (. fst))
17:10:08 <centrinia> Now that's clear. :)
17:10:19 <pumpkin_> oh wow, someone's actually talking about a beowulf cluster in a non-joking way on cafe
17:10:43 <pumpkin_> that's got to be the first serious beowulf cluster mention I've ever seen
17:10:54 <centrinia> Imagine a Beowulf cluster of non-joking Beowulf cluster references.
17:11:01 <pumpkin_> omg
17:11:22 * Gracenotes :x
17:16:25 <dons> pumpkin_: serious in that there is no content? :)
17:16:58 <pumpkin_> serious in that it wasn't someone making a joke about making a beowulf cluster out of <insert ridiculous thing to make a beowulf cluster out of here> :P
17:17:05 <pumpkin_> but yeah
17:17:08 <SubStack> potatoes
17:20:32 <pumpkin_> dons: btw, if you do try to merge from my patch-tag uvector repo, be aware that you probably the most recent patch... it was my experimentation with a Binary instance of UArrs, with that epic hackage we were talking about earlier (making a ByteString from UArr in O((1))... I'm probably going to settle on a memcpy both ways, as it's weird to have O(1) in one direction and O(n) the other
17:20:46 <pumpkin_> *be aware that you probably don't want
17:20:53 <pumpkin_> I accidentally the verb
17:21:11 <dons> mm
17:21:16 <dons> well.
17:21:17 <centrinia> pumpkin_, you are correct in adverbing a verb.
17:22:04 <pumpkin_> I find that I accidentally whole parts of speech sometimes, it's weird
17:22:13 <pumpkin_> I think I caught a bug online
17:22:33 <centrinia> Which direction is O(n)
17:22:47 <pumpkin_> ByteString to UArr
17:22:57 <asdgasd> how's my favorite programming channel doing
17:23:23 <pumpkin_> oddly enough, my unit tests for the tame Binary instance don't pass, but the unit tests for the insanely unsafe hacky approach do
17:23:45 <pumpkin_> so that module attempt fails pretty hard for now :P
17:24:22 <pumpkin_> given that the UArr is on unpinned memory, you have to cross your fingers that the GC doesn't choose to move it around (and put something else where it was) when you still have your ByteString pointing at the old memory
17:33:22 <shukhov> is it possible to add a class constraint to a data type say Test (Show a) = T a?
17:34:24 <newsham> its best to put class constraints only on those functions that require it
17:34:28 <Draconx|Laptop> shukhov, yes, using existential quantification: data Test = forall a . Show a => T a
17:35:22 <Draconx|Laptop> shukhov, unless you meant: data Show a => Test a = T a
17:36:17 <shukhov> I think the second one is what I want
17:36:24 <shukhov> I'm going to try it
17:37:58 <shukhov> seems to have worked, thank you
17:46:11 <ImOuttaYourMonad> anyone good with machine learning?
17:46:33 <ddarius> Sorry.  Only aardvark learning here.
17:46:49 <ImOuttaYourMonad> is running KNN on Netflix(yeah i know knn isn't the best algorithm for it but it is an easy one) to expensive?
17:52:10 <MyCatVerbs> ImOuttaYourMonad: how big's the Netflix data set? I would guess that it depends on how you're finding neighbours. Naive knn is quadratic, but you can do better than that with spatial data structures.
17:55:50 <MyCatVerbs> ImOuttaYourMonad: what distance metric are you using for knn, anyway?
17:56:46 <Gracenotes> @type runState
17:56:47 <lambdabot> forall s a. State s a -> s -> (a, s)
17:57:52 <aluink> dcoutts: ping
17:58:11 <MyCatVerbs> aluink: it's about 2am. I suspect he's asleep.
18:03:35 <tromp_> iterate (*2) 0.166015625
18:03:40 <tromp_> > iterate (*2) 0.166015625
18:03:42 <lambdabot>   [0.166015625,0.33203125,0.6640625,1.328125,2.65625,5.3125,10.625,21.25,42.5...
18:06:54 <ImOuttaYourMonad> is there a function for deleting an elemtn once from a list?
18:07:10 <ddarius> delete
18:07:13 <roconnor> > [3,3]\\[3]
18:07:15 <lambdabot>   [3]
18:07:30 <roconnor> ImOuttaYourMonad: (\\)
18:07:33 <tromp_> > [3,3,3] \\ [3,3]
18:07:34 <lambdabot>   [3]
18:07:41 <ddarius> > delete 3 [3,3]
18:07:42 <lambdabot>   [3]
18:07:51 <roconnor> delete aparently
18:09:32 <centrinia> If n>m, is length ((replicate n ()) \\ (replicate m ())) == n-m ?
18:10:24 <centrinia> > (\n m -> length ((replicate n ()) \\ (replicate m ())) == n - m) 5 3
18:10:26 <lambdabot>   True
18:10:37 <Saizan> @check (\n m -> length ((replicate n ()) \\ (replicate m ())) == n - m)
18:10:39 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n0\n"
18:10:52 <Cale> @check (\n m -> n > m ==> length ((replicate n ()) \\ (replicate m ())) == n - m)
18:10:52 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:10:53 <lambdabot>           ...
18:10:55 <Cale> er...
18:10:56 <Gracenotes> @check (\n m -> n < m || length ((replicate n ()) \\ (replicate m ())) == n - m)
18:10:58 <lambdabot>   "Falsifiable, after 0 tests:\n3\n-1\n"
18:11:05 <centrinia> Oh, m>= 0
18:11:07 <Gracenotes> oh, darn negatives
18:11:17 <Gracenotes> @check (\n m -> n < 0 || m < 0 || n < m || length ((replicate n ()) \\ (replicate m ())) == n - m)
18:11:19 <lambdabot>   "OK, passed 500 tests."
18:11:22 <centrinia> Yay!
18:11:25 <Gracenotes> :D
18:11:37 <centrinia> I think n < 0 is redundant.
18:12:07 <Gracenotes> well, let's see :)
18:12:11 <Cale> @check (\n m -> m < 0 || n < m || length ((replicate n ()) \\ (replicate m ())) == n - m)
18:12:12 <lambdabot>   "OK, passed 500 tests."
18:12:18 <Gracenotes> making an instance Num [()] is rather interesting. Trivial, but interesting.
18:12:47 <Gracenotes> it's isomorphic-ish to Natural, which is Z | S Natural, iirc
18:13:42 <ddarius> It -is- isomorphic to that.
18:13:58 <Gracenotes> indeed, sir
18:14:02 <ddarius> Well, I guess you can have stupidity like [undefined] v. [()]
18:14:11 <ddarius> So you could use [Void] instead if you want to avoid that.
18:14:23 <ImOuttaYourMonad> @src Data.List.delete
18:14:23 <lambdabot> Source not found. Take a stress pill and think things over.
18:16:00 <centrinia> I thought Natural = Z | S [Natural]
18:16:47 <centrinia> succ Z = S [Z]; succ a@(S as) = S (a:as)
18:17:27 <pumpkin_> what's that advantage of doing that?
18:17:30 <mmorrow> N = Z | S N === [()]
18:18:33 <centrinia> pumpkin_, Ask von Neumann.
18:20:09 <mmorrow> centrinia: how would you interpret in your rep something like S (repeat Z)
18:21:23 <centrinia> mmorrow, you don't.
18:21:40 <centrinia> The list is supposed to have only unique elements.
18:23:46 <mmorrow> so then what's the advantage of using that over [()] or N = Z | S N, where you can't build invalid numbers
18:23:47 <mmorrow> ?
18:24:27 <Fredrik> @pl \x y -> head x : y
18:24:28 <lambdabot> (:) . head
18:24:29 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all :)
18:24:31 <pumpkin_> ask von neumann, apparently
18:24:40 <dons> and still not even close to being done with the parallel benchmarks.
18:24:46 <pumpkin_> yay
18:27:35 <Gracenotes> oh wow
18:27:46 <mae> FYI: Happstack 0.2 Released - http://blog.happstack.com/2009/03/04/happstack-02-released
18:29:06 <dons> parallelism for the win.
18:29:18 <asdgasd> VERY IMPORTANT
18:29:21 <asdgasd> http://www.youtube.com/watch?v=wtOW1CxHvNY
18:29:35 <dons> i doubt it
18:29:36 --- mode: ChanServ set +o dons
18:29:38 --- mode: dons set +b *!*n=asdgas@*.syr.edu
18:29:38 --- kick: asdgasd was kicked by dons (dons)
18:29:42 --- mode: ChanServ set -o dons
18:30:03 <pumpkin_> wow
18:30:09 <pumpkin_> that syr.edu really has nothing better to do
18:30:13 <pumpkin_> dude
18:30:27 <centrinia> You were accidentally dropping words again. :(
18:30:31 <pumpkin_> yeah
18:30:35 <pumpkin_> I need more sleep :)
18:31:06 <centrinia> Sleeping is bad for late night hacking marathons.
18:31:35 <MyCatVerbs> On the contrary. Sleep tonight, late night hacking marathon tomorrow.
18:31:44 <Philippa_> ...heh, I was about to say similar
18:31:56 <ImOuttaYourMonad> hmm i dont know if the laziness is tricking me. i have a n algorithm which i want to test but it might laziness that makes it fast. how do i foce it to evaluate? i can enver remember the syntax
18:32:53 <ImOuttaYourMonad> genTest n len = zip [0..] $ take n $ repeat [1..len]
18:32:57 <pumpkin_> rnf
18:33:04 <ImOuttaYourMonad> how do I force it to really create the whole thing?
18:33:10 <mmorrow> rnf
18:33:10 <pumpkin_> Control.Parallel.Strategies
18:33:38 <ImOuttaYourMonad> rnf?
18:34:13 <mmorrow> , let x = [0..9] in rnf x `seq` x
18:34:17 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
18:34:20 <mmorrow> , let x = [0..] in rnf x `seq` x
18:34:22 <lunabot>  luna: out of memory (requested 1048576 bytes)
18:34:41 <mmorrow> @type rnf
18:34:42 <lambdabot> forall a. (NFData a) => a -> Done
18:34:54 <mmorrow> @src Done
18:34:55 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:34:58 <mmorrow> , src ''Done
18:35:01 <gwern> hm, oleg strikes again, although I guess people already knew lazy io wasn't really good in theory
18:35:03 <lunabot>  type Done = ()
18:35:52 <ImOuttaYourMonad> rnf?
18:36:01 <mmorrow> nerf?
18:36:09 <dons> gwern: yeah, i think we already knew this in practice.
18:36:14 <mmorrow> reduce to normal form
18:36:25 <dons> it's no mystery that unevaluated pure values hanging on to IO actions can be messed with
18:36:33 <dons> whether this matters in practice, i don't know.
18:37:06 <ImOuttaYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2108#a2108 <- tell me, im running KNN on 10000 customers who each have a 10000 elem list of grades. it is instant, can that eb correct?
18:37:08 <kohwj> idoes an
18:37:16 <kohwj> typo
18:37:41 <ddarius> dons: I've wanted to make mutable variables using lazy IO, but that would require call-by-name.
18:38:26 <kohwj> i've been trying to learn FRP (reactive) via google, etc for the past few hours without much progress. does anyone know where one can find the simplest example of a program that uses reactive?
18:38:58 <Saizan> ImOuttaYourMonad: x `seq` x == x
18:39:12 <MyCatVerbs> kohwj: try Conal Elliott's blog and papers?
18:39:50 <MyCatVerbs> kohwj: http://conal.net/ and http://conal.net/blog/. I find the former easier to follow.
18:40:10 <pumpkin_> the rotating children are awesome
18:40:31 <kohwj> MyCatVerbs: thanks, but where do i start?
18:40:45 <ImOuttaYourMonad> Saizan: ?
18:41:07 * pumpkin_ is building PETSc
18:41:16 <pumpkin_> one of these days I'll write bindings for it
18:41:51 <ispiked> http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
18:42:07 <ispiked> search for "group ::"
18:42:18 <ispiked> what is the order of evaluation for group?
18:42:52 <pumpkin_> order of evaluation?
18:42:59 <ispiked> is the infix `Union` constructor called before flatten x?
18:43:20 <pumpkin_> oh you mean how is it parsed?
18:43:29 <pumpkin_> (flatten x) `Union` x
18:43:35 <ispiked> operator precedence is the term I'm looking for maybe?
18:43:39 <ispiked> ok
18:43:50 <pumpkin_> function application is higher than anything else
18:44:12 <ispiked> ok. I didn't know if there was an exception for infix notation like that or not. thanks
18:44:31 <MyCatVerbs> kohwj: I dunno. Maybe start at his earlier papers on Fran, then read up through all the more modern systems in roughly chronological order?
18:44:58 <kohwj> MyCatVerbs: sure :)
18:45:24 <MyCatVerbs> kohwj: conal is sometimes around here, perhaps you should beg for an introduction over IRC. ;)
18:45:44 <gwern> what does one do about an error like: 'Yi/IReader.hs:169:9:
18:45:45 <gwern>     Duplicate instance declarations:
18:45:45 <gwern>       instance Binary Char -- Defined at Yi/IReader.hs:169:9-19
18:45:45 <gwern>       instance Binary Char -- Defined in Data.Binary
18:45:49 <xo230342k2> [AmsG'D] If you can host a free IRCd, or know of a free host, please PM me
18:46:19 --- mode: ChanServ set +o Pseudonym
18:47:44 <ImOuttaYourMonad> is flatten = foldl1 (++) really bad?
18:48:15 <Pseudonym> Grrr.
18:48:17 <Pseudonym> I need to fix that bug.
18:49:11 <pumpkin_> ImOuttaYourMonad: it's not good
18:49:14 <pumpkin_> for more than one reason
18:50:25 <MyCatVerbs> ImOuttaYourMonad: yes. Left-associative concatenation makes baby someoneorother cry.
18:51:50 <MyCatVerbs> ImOuttaYourMonad: concat is O(n) written as foldr (++), but potentially O(n^2) as foldl (++). Left-associative applications of (++) require the whole list to be copied out repeatedly in order to add elements to the end.
18:52:17 <pumpkin_> so basically, don't use foldl1 unless you're sure the input list isn't empty, and use a foldr in this case
18:52:34 <juhp> has anyone built libHSbase.so ?
18:52:35 <MyCatVerbs> (When I say "potentially quadratic" here I mean "actually quadratic, unless all but the final list are empty for some bizarre reason, in which case the problem was trivial anyway :P")
18:56:00 <Gracenotes> > foldr (++) [] [a,b,c,d,e] :: [Expr]
18:56:01 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
18:56:20 <Gracenotes> > foldr (++) [] [[a,b],[c,d],[e]] :: [Expr]
18:56:21 <lambdabot>   [a,b,c,d,e]
18:56:32 <MyCatVerbs> Gracenotes: not *quite* what you wanted, heh. :)
18:56:52 <centrinia> > foldl1 (++) [[a,b],[c,d],[e]] :: [Expr]
18:56:53 <lambdabot>   [a,b,c,d,e]
18:57:18 <Gracenotes> Expr and lists are of limited use ;)
18:57:31 <centrinia> > foldl1 (++) [] :: [Expr]
18:57:32 <lambdabot>   * Exception: Prelude.foldl1: empty list
18:57:46 <centrinia> > foldr1 (++) [[a,b],[c,d],[e]] :: [Expr]
18:57:47 <lambdabot>   [a,b,c,d,e]
18:57:48 <Gracenotes> unless, of course, we can make [] an instance of Expr, which would introduce some havoc
18:58:00 <Gracenotes> er, not Expr, the Expr class, whatever it's called
18:58:20 <desp> @cookie
18:58:21 <lambdabot> Unknown command, try @list
18:58:32 <centrinia> @botsnack
18:58:32 <lunabot>  :)
18:58:32 <lambdabot> :)
18:59:04 <Gracenotes> either that, or ExprList = Nil | Cons a (ExprList a)
18:59:20 <desp> @hoogle a -> [a] -> [a]
18:59:21 <MyCatVerbs> > let a +=+ b = "(" ++ (show a) ++ "++" ++ (b) ++ ")" in foldr (+=+) "[]" ['a','b','c','d','e'] -- hack, but should convey the idea.
18:59:21 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:59:21 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
18:59:21 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:59:22 <lambdabot>   "('a'++('b'++('c'++('d'++('e'++[])))))"
18:59:45 <MyCatVerbs> *facepalm* should've made show individual characters lists, but oh what the Hell.
19:01:02 <ImOuttaYourMonad> i see thanks
19:01:23 <ImOuttaYourMonad> why doesnt anyone make foldl' available as foldl and kick out foldl?
19:01:33 <ImOuttaYourMonad> how does foldl1 work anywya?
19:01:35 <Gracenotes> Haskell 98, I'd think
19:01:37 <ImOuttaYourMonad> @src foldl1
19:01:37 <lambdabot> foldl1 f (x:xs) = foldl f x xs
19:01:37 <lambdabot> foldl1 _ []     = undefined
19:01:39 <Gracenotes> @src foldl1
19:01:39 <lambdabot> foldl1 f (x:xs) = foldl f x xs
19:01:39 <lambdabot> foldl1 _ []     = undefined
19:01:40 <Gracenotes> :O
19:01:46 <ImOuttaYourMonad> ah ofc
19:02:01 <MyCatVerbs> > let a +=+ b = "(" ++ (a) ++ "++" ++ (show b) ++ ")" in foldl (+=+) "[]" [a::Expr,b,c,d,e] -- another hack, this time showing the actual problem instead. :)
19:02:03 <lambdabot>   "((((([]++a)++b)++c)++d)++e)"
19:02:33 <MyCatVerbs> ImOuttaYourMonad: I'm not sure if even the people writing GHC are entirely sure whether it's a good idea or not. ;)
19:03:00 <MyCatVerbs> ImOuttaYourMonad: but the issue is that the definition of foldl is specified as part of the Haskell 98 standard, and people are really reluctant to mess with it.
19:03:29 <centrinia> foldl1 is for legacy applications?
19:03:33 <ImOuttaYourMonad> > 450000*17770
19:03:34 <lambdabot>   7996500000
19:03:41 <ImOuttaYourMonad> > 450000*17770 / 1000000000
19:03:42 <lambdabot>   7.9965
19:03:57 <MyCatVerbs> centrinia: well, that's the thing. I don't think anyone can actually think of any programs for which foldl works but foldl' doesn't. :)
19:04:40 <sjanssen> MyCatVerbs: there is exactly one function where foldl is called for: reverse
19:05:02 <ImOuttaYourMonad> > foldl (:) [] [1..10]
19:05:03 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:05:03 <lambdabot>        Expect...
19:05:04 <Gracenotes> well, foldl' would work there too.
19:05:18 <Gracenotes> it doesn't matter so much because it's all one big unpreventable thunk :)
19:05:28 <sjanssen> Gracenotes: it's wasteful, though
19:05:28 <MyCatVerbs> Actually thinking of it, if you had a function that was lazier in its first argument than its second, and always fed finite lists in...
19:06:23 <ImOuttaYourMonad> > foldl (:) [] [1..10]
19:06:24 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:06:24 <lambdabot>        Expect...
19:06:26 <ImOuttaYourMonad> @src reverse
19:06:27 <lambdabot> reverse = foldl (flip (:)) []
19:06:30 <pumpkin_> sjanssen: and sum/product
19:06:39 <pumpkin_> oh
19:06:40 <pumpkin_> called for
19:06:45 <pumpkin_> I thought you said called :)
19:06:47 <sjanssen> pumpkin_: sum/product should use foldl'
19:06:52 <pumpkin_> they should, eah
19:06:53 <pumpkin_> yeah
19:08:42 <ddarius> MyCatVerbs: It's easy enough to think up programs where foldl will work and foldl' will fail.  It's hard to think up meaningful/compelling ones though.
19:09:15 <centrinia> > foldl' (const (const [])) [1..] [1]
19:09:17 <lambdabot>   []
19:09:21 <centrinia> > foldl (const (const [])) [1..] [1]
19:09:22 <lambdabot>   []
19:09:23 <dolio> There is a difference. "foldl (flip (:)) [] [1,2,3] = flip (:) (flip (:) (flip (:) [] 1) 2) 3", "foldl' (flip (:)) [] [1,2,3] = 3 : 2 : 1 : []".
19:09:48 <dolio> Or something like that.
19:11:00 <ddarius> The difference between foldl (flip (:)) [] and foldl' (flip (:)) [] is very slight and not semantically distinguishable.
19:11:21 <ImOuttaYourMonad> one cool thing about haskell is that a lot of prelude/stl functions are very close to how I would write them. meaning writing simple elegant haskell is often also very efficient. while as in C fast code generally isnt so pretty
19:11:48 <ImOuttaYourMonad> why is foldl better for reverse than foldl'?
19:12:05 <ImOuttaYourMonad> reverse is not lazy anyway right?
19:12:14 <MyCatVerbs> ddarius: assuming that all the thunks in question were going to get evaluated by your program eventually anyway, is there any overhead from using seq?
19:12:15 <dolio> It's just one case where foldl' isn't better.
19:12:21 <centrinia> > foldl (\ z x = if not (null z) then [1] else z) [1..] [1]
19:12:22 <lambdabot>   <no location info>: parse error on input `='
19:12:24 <adu> hi
19:12:29 <centrinia> > foldl (\ z x -> if not (null z) then [1] else z) [1..] [1]
19:12:30 <lambdabot>   [1]
19:12:33 <centrinia> > foldl' (\ z x -> if not (null z) then [1] else z) [1..] [1]
19:12:34 <lambdabot>   [1]
19:12:42 <ddarius> ImOuttaYourMonad: There's no semantic difference.  There may be a very slight difference in performance, but as far as I can see, it could go either way.
19:12:50 <Gracenotes> :X :X :X
19:12:56 <sjanssen> ImOuttaYourMonad: reverse-via-foldl folds with a constructor application, so the extra seq is not necessary
19:13:03 <Cale> It's possible to see the difference by evaluating by hand.
19:13:07 <ddarius> MyCatVerbs: seq is not free necessarily.
19:13:08 <Cale> yeah
19:13:10 <adu> :t seq
19:13:11 <lambdabot> forall a t. a -> t -> t
19:13:15 <sjanssen> it won't hurt anything, semantically, but it's wasteful
19:13:19 <Cale> The extra seq'ing will do nothing.
19:13:26 <adu> :t ($)
19:13:26 <lambdabot> forall a b. (a -> b) -> a -> b
19:13:28 <sjanssen> Cale: semantically
19:13:32 <adu> :t (<$>)
19:13:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:13:39 <adu> :t fmap
19:13:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:13:53 <Cale> sjanssen: Right, in practice it'll probably check that each cons is really a constructor, which it will be.
19:14:16 <Cale> But, after optimisation, it makes no difference anyway.
19:14:27 <Gracenotes> interestingly, foldl' is somewhat faster on my computer here :/
19:14:46 <pumpkin_> ghci or ghc?
19:15:00 <sjanssen> Cale: that might be assuming too much
19:15:02 <Gracenotes> ghci, only. Grain of salt should be taken either way here
19:15:08 <Cale> sjanssen: maybe...
19:15:13 <sjanssen> @src foldl'
19:15:13 <lambdabot> foldl' f a []     = a
19:15:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:15:17 * adu does not like salt
19:15:21 <sjanssen> bah, I want the real defn.
19:15:24 <jmcarthur> foldl and foldl' compile to the same code with -O in all the cases i have seen myself
19:15:27 <Gracenotes> foldl' is consistently in the 20s. foldl is consistently in the 30s and 40s (in ms)
19:15:36 <jmcarthur> when it makes sense to be the same code, that is
19:15:59 <Cale> I suppose I tend to think of performance in terms of graph reduction and usually don't look any deeper than that.
19:16:26 <adu> I think of performance in terms of superopt
19:16:33 <Gracenotes> actually, in hundredths of seconds
19:16:39 <Cale> It would be really really nice if someone wrote a graph reduction visualiser for Haskell.
19:16:44 <sjanssen> Cale: yeah, I think GHC will optimize the foldl and foldl' versions to the same code
19:16:53 <jmcarthur> Yes, a visualizer would be _awesome_.
19:17:05 <adu> Cale: in OpenGL maybe? :)
19:17:09 <Cale> adu: hehe :)
19:17:20 <Cale> I'd be happy enough with plain 2D :)
19:17:21 <monochrom> Do it in javascript on a web page.
19:17:35 <monochrom> Add SVG for 3D
19:17:39 <adu> well, the only graphics programming I know are QBasic and OpenGL
19:17:51 <Gracenotes> how in-depth of an emulator would this be?
19:18:17 * adu <3 SVG
19:18:30 * adu <3 GL
19:18:41 <byorgey> hey adu!
19:18:43 <monochrom> For now the GHCi debugger suffices, actually.
19:18:48 <adu> byorgey!
19:18:52 * shapr </3 Python
19:18:56 <adu> lol
19:19:02 <ddarius> shapr: What happened?
19:19:05 <monochrom> Heart break? :)
19:19:11 <shapr> ddarius: I <3 Haskell more.
19:19:14 <byorgey> omg Velociraptors!! run!!!
19:19:15 <p_l> shapr: Which Python? :P
19:19:27 * adu <3 <3 Haskell
19:19:34 <monochrom> He broke up with python after arguing over baby plans.
19:19:44 <adu> matrimony
19:19:44 <p_l> lol
19:19:46 <adu> :P
19:19:51 <shapr> Actually, I </3 C#
19:20:00 <shapr> I'm thinking of writing a parody language called D-flat
19:20:07 <adu> shapr: what about ILAsm?
19:20:14 <monochrom> D♭
19:20:16 <shapr> I haven't played with it yet.
19:20:30 <p_l> what would be a smiley for scissor-armed velociraptor with rocket pack?
19:20:40 <shapr> hmm
19:21:00 <adu> >(-#-)<
19:21:08 <p_l> xD
19:21:14 * p_l notes it somewhere
19:21:15 <ddarius> C# is actually a pretty good rendition for what it is.  It could use some better library design in places (this is with regards to .NET Framework 2.0, perhaps 3.0+ is better)
19:21:37 <monochrom> D♭ major has 5 flats!
19:21:55 <p_l> C# is certainly better than java. the funny thing is that it's better partially thanks to being more "closed" than java
19:21:58 <jmcarthur> I've been using C# a bit lately at work and have also been pleasantly surprised by it.
19:21:59 <shapr> ddarius: 3.0 is a nicer language than 2.0
19:22:10 <shapr> Still, it's not Haskell.
19:22:19 <ddarius> shapr: I know the language is nicer, I'm talking about the library designs.
19:22:19 <adu> but theres F#
19:22:20 <shapr> My coworkers freak out when they see 'var'
19:22:36 <adu> shapr: is that a C# thing?
19:22:59 <shapr> adu: var means "please do type inference here, I don't want to put in an explicit type"
19:23:20 <adu> oh, I thought you were talking about js
19:23:25 <p_l> shapr: I hope they are "coworkers" not "cow-orkers" :)
19:23:40 <Pseudonym> In Haskell, "var" is spelled "".
19:23:44 <adu> lol
19:24:02 <p_l> the same in CL :3
19:24:07 <ddarius> Pseudonym: I thought that was how application was spelled.
19:24:10 <Fredrik> C++ will have "auto" soon :)
19:24:19 <ddarius> C++ should already have auto.
19:24:22 <Pseudonym> ddatius: Overloading!
19:24:25 <ddarius> (It just means something else...)
19:24:26 <Fredrik> But now it means a different thing
19:24:33 <Fredrik> there you go
19:24:54 <jmcarthur> C++ is horrible. I know it's popular to say so, but C++ is seriously the worst language I have ever, ever used for a serious project.
19:25:09 * ddarius likes C++.
19:25:25 * Pseudonym also likes C++
19:25:31 <ddarius> But I can understand the gripes most people have with it.
19:25:36 <Pseudonym> I hated it _until_ I used it for a serious project.
19:26:10 * p_l decided to learn about garbage collection in C/C++ before going on a big project in C/C++ :D
19:26:22 <jmcarthur> I almost liked it until I used it for a serious project.
19:26:30 <Fredrik> What is C/C++, a new language? :)
19:26:31 <MyCatVerbs> Gyuh. I'm merely disdainful when I'm not using it. Actually working with it induces hatred.
19:26:51 <centrinia> I think I found a case where foldl' fails while foldl works. :(
19:27:12 <ddarius> centrinia: There's an example on the Stack_overflow wiki page.
19:27:23 <MyCatVerbs> centrinia: I'd like to hear it. :)
19:27:31 <centrinia> > foldl (\z x -> case x of 1 -> let f = f in f; 2 -> 2; ) 3 [1..2]
19:27:31 <Pseudonym> Fredrik: That also annoys the hell out of me.
19:27:32 <lambdabot>   2
19:27:36 <centrinia> > foldl' (\z x -> case x of 1 -> let f = f in f; 2 -> 2; ) 3 [1..2]
19:27:36 <adu> does Agda allow both tagged unions and untagged unions?
19:27:40 <Fredrik> I would like C++ if it weren't for the lack of a module system, slow compilation, horrible syntax and too much undefined behavior.
19:27:50 <ddarius> centrinia: If they weren't semantically different, there'd be little point in having two versions.
19:27:51 <lambdabot>   thread killed
19:27:58 <Pseudonym> C++ has a module system.  "Module" is spelled "class".
19:28:12 <Fredrik> erm, no.
19:28:13 <Pseudonym> In that respect, it's better than Haskell's module system.
19:28:14 <p_l> C++ frightens me with overloaded negation operator...
19:28:15 <jmcarthur> Fredrik: and library writers who don't think like I do! ;)
19:28:33 <centrinia> H# .NET
19:28:34 <centrinia>  :)
19:28:38 <adu> p_l: why is that scary?
19:28:40 <Fredrik> Every C++ expert agrees that C++ lacks a module system
19:28:53 <Fredrik> If C++ had modules, we wouldnt need headers
19:29:15 <monochrom> C/C++ = 1/++
19:29:26 <Fredrik> oh and i absolutely hate to defined functions in the order they are needed.
19:29:29 <jmcarthur> I think the intent here is for modularization, not for compilation speed. Multiple source files and headers are not C++'s module system.
19:29:35 <p_l> adu: Imagine that you wanted to do negation on a pointer.... only to find that some wiseass decided to implement base cases using insane templating and overloading....
19:29:35 <Pseudonym> I'm making a point, though.  Objects are instantiable modules.
19:29:39 <adu> one divided by increment...
19:29:46 <Pseudonym> Conceptually, anyway.
19:29:49 <centrinia> One modulo increment.
19:30:09 <adu> p_l: oh
19:30:20 <kohwj> i found an example reactive program, but it doesn't compile- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2109#a2109
19:30:32 <Pseudonym> C/C++ == 1, and also increments C.
19:30:41 <kohwj> it's the source for the Less Sugar/More Meat reactive tutorial
19:30:45 <p_l> adu: said thing broke an _if_ statement....
19:30:55 <adu> I personally thing overloadable operators only makes sense if they are arbitrary identifiers (like Haskell) and are pretty stupid when you only have 20 ops to choose from...
19:31:05 <Zao> Pseudonym: It's undefined in C++ as there's no sequence point between C and C++.
19:31:09 <Fredrik> C/C++ is actually undefined bevavior.
19:31:38 <ddarius> Pseudonym: That's the one bad thing about C++.  Lots of language lawyering.
19:32:19 <MyCatVerbs> Fredrik: no it isn't. It evaluates to 1 iff (C != 0) and causes a divide-by-zero error otherwise. And then increments C.
19:33:07 <Fredrik> C/C++ is undefined behavior. Read the language spec.
19:33:22 <Pseudonym> MyCatVerbs: They're talking about the case where C is an object and post-increment is overloaded.
19:33:29 <Fredrik> You are not allowed to modify c and read it again in the same expression without a sequence point in between.
19:33:36 <Pseudonym> If C is a POD numeric type, then it does what you say.
19:34:54 * centrinia thinks that (C == C++ ? 0 : 0) == 0
19:35:32 <Fredrik> C == C++ is also undefined behavior
19:35:59 <Saizan> does C++ have a formal semantic?
19:36:06 <centrinia> Well, does (<undefined> ? 0 : 0) also become undefined?
19:36:18 <Pseudonym> Saizan: No.
19:36:58 <dolio> Undefined behavior just means that the compiler can do whatever it wants, no?
19:37:09 <Zao> dolio: Kittens tend to appear.
19:37:11 <Fredrik> Yes, he could launch the missiles.
19:37:41 <centrinia> if (C != C++) { launch_missiles(); }
19:37:53 <Pseudonym> dolio: There are two kinds of undefined behaviour.
19:37:55 <dolio> So (C == C++ ? 0 : 0) probably is 0 (and increment C) in most compilers.
19:38:00 <Pseudonym> There's "anything reasonable" and "nasal demon".
19:38:25 <Pseudonym> I'm pretty sure that it's "anything reasonable" in this case.
19:38:33 <zachk> > "C"++"C++"
19:38:35 <lambdabot>   "CC++"
19:38:58 <Fredrik> To be honest, I'm not 100% sure if "C == C++" is undefined or unspecified.
19:39:02 <bd_> it's undefined
19:39:22 <bd_> can result in anything up to and beyond summoning demons through your nasal passages, as the example usually goes
19:39:44 <p_l> and you are lucky if it's demons through nasal passages....
19:39:48 <centrinia> Shouldn't (foo ? 0 : 0) be zero?
19:39:49 <kohwj> i found an example reactive program, but it doesn't compile- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2109#a2109 it's from a reactive tutorial from http://netsuperbrain.com/blog/posts/introducing-reactive-events/
19:40:00 <zachk> this one time at a party. this guy summoned demons. and i saw them. they didnt have horns D:
19:40:08 <jmcarthur> > if undefined then 0 else 0
19:40:09 <lambdabot>   * Exception: Prelude.undefined
19:40:22 <centrinia> Hmm.
19:40:35 <bd_> centrinia: only if evaluating foo is defined
19:40:57 <ddarius> There are some people that think that if undefined then x else x should be x.
19:41:35 <jmcarthur> implying that undefined is distinct from _|_?
19:42:01 <jmcarthur> oh, wait, nevermind
19:42:03 <bd_> well, last I checked ? : wasn't Haskell, so I'm going by the C definition of undefined behavior. :)
19:42:32 <jmcarthur> bd_: the C definition of undefined behavior is usually a security problem
19:43:10 <bd_> well, the C standard makes provisions for things like trap values in integer types - if such a value is in an integer and you so much as sneeze at it, anything can happen. So, uninitialized foo -> foo == 0 -> trap
19:43:15 <Fredrik> section 5, paragraph 4 of the ISO C++ standard:
19:43:15 <Fredrik> Except where noted, the order of evaluation of operands of
19:43:15 <Fredrik> individual operators and subexpressions of individual
19:43:15 <Fredrik> expressions, and the order in which side effects take place,
19:43:15 <Fredrik> is unspecified. Between the previous and next sequence
19:43:16 <Fredrik> point a scalar object shall have its stored value modified at
19:43:18 <Fredrik> most once by the evaluation of an expression. Furthermore,
19:43:22 <Fredrik> the prior value shall be accessed only to determine the value
19:43:24 <Fredrik> to be stored. The requirements of this paragraph shall be met
19:43:26 <Fredrik> for each allowable ordering of the subexpressions of a full
19:43:28 <Fredrik> expression; otherwise the behavior is undefined.
19:43:41 <Fredrik> there you go, C == C++ is undefined
19:43:46 <bd_> Not all machines will actually have such trap values, of course. But the C standard defines such things as undefined precisely to allow /anything to happen
19:46:21 <Fredrik> Anyone care to read my introduction to Haskell and give feedback? :) http://www.file-upload.net/download-1501625/Haskell090305.pdf.html
19:46:22 <p_l> bd_: That's why some firmwares helpfully filled memory with 0xdeadbeef as part of hw init :)
19:46:50 <bd_> p_l: hopefully there's nothing important at 0xDEAD or 0xBEEF ... :)
19:47:27 <p_l> bd_: Better yet, have OS actually mark those pages as no-access and give you SIGBEEF :>
19:47:41 <bd_> p_l: well, I was assuming from 'firmware' we were talking about some embedded thing :)
19:47:56 <p_l> bd_: I heard that about RS/6000 :D
19:48:03 <centrinia> > let (=?=) :: Bool -> a -> Maybe a; (=?=) t x = if t then return x else mzero; (=:=) r y = fromJust (r `mplus` (return y)) in (2==3) =?= 1 =:= 3
19:48:04 <lambdabot>   3
19:49:14 <p_l> firmwares are also in bigger stuff, and often more advanced than Basic Input-Output System :)
19:49:17 <Gracenotes> Fredrik: looks cool :) the only possible harm would be going too fast
19:49:31 <bd_> > let (=?=) b t f = if b then t else f; (=:=) = ($) in True =?= 1 =:= 2
19:49:33 <lambdabot>   1
19:49:35 <Gracenotes> I'm not a good judge of that, though. Is it for a class you're teaching?
19:49:49 <jmcarthur> Fredrik: first critique: I think you should make a distinction between strong typing and static typing. Also, the difficulty of having a list for both strings and integers is only there because of a _combination_ of strong, static typing and the particular design of the list data type, no?
19:49:51 <Fredrik> It's for an online community :)
19:49:56 <bd_> p_l: fair enough, but at that point might as well just push it into the OS... :)
19:50:13 <p_l> bd_: it's memory test routine, before we start OS :)
19:50:29 <Fredrik> Thanks for the critqiue, I'm no expert on typing and will think about that!
19:50:33 <bd_> fair enough then :)
19:50:52 <p_l> though when you meet a multitasking (and possibly multiprocessor-capable) firmware ^_^;
19:51:05 <bd_> sounds like an OS to me ;)
19:51:07 <jmcarthur> it might also be good to point out that haskell's type system is not manifest typing like most statically typed imperative languages and thus isn't as annoying
19:51:25 <p_l> bd_: it had filesystem and executables, too :D
19:51:27 <bd_> I hear that some systems come with a xen hypervisor burned into their firmware these days, actually
19:51:32 <jmcarthur> although that might inflate to a rather long discussion of type theory which might be out of scope
19:51:40 <Fredrik> What is manifest typing? :)
19:52:10 <Philippa_> where the types are made manifest in the code. AKA explicit typing
19:52:13 <p_l> bd_: and it was afaik still much simpler than EFI - IIRC it gave away any control after OS established it's own routines, unlike EFI or modern BIOS stuff
19:52:29 <Gracenotes> Philippa_: which languages use that paradigm?
19:52:29 <bd_> SMM is evil indeed :|
19:53:14 <Philippa_> Gracenotes: historically, most statically-typed languages. C, Pascal, Java...
19:53:15 <p_l> bd_: indeed... SRM or OpenFirmware, now we are talking about something nice :3
19:53:27 <Gracenotes> many languages require mentions of types, although (for instance, Java) doesn't require them for temporary values used in expressions
19:53:39 <bd_> p_l: Are you sure OF on x86 doesn't use any SMM traps? :)
19:53:54 <Philippa_> sure. I didn't say "all terms explicitly annotated with types"
19:53:56 <jmcarthur> Fredrik: call-by-name and call-by-need are not equivalent
19:53:58 <p_l> bd_: I have yet to see OF on PC :)
19:54:05 <bd_> p_l: Intel macs?
19:54:09 <p_l> bd_: EFI
19:54:12 <Fredrik> Thanks, I will look into that :) What is it haskell uses? name?
19:54:12 <bd_> ah
19:54:17 <jmcarthur> need
19:54:37 <Fredrik> thx
19:54:51 <ddarius> Implementations use call-by-need.  The language doesn't specify.
19:55:11 <Fredrik> So it's best not to mention it at all?
19:55:35 <jmcarthur> i would mention it just because call by need is less scary to optimization freaks
19:56:12 <jmcarthur> in call by name, x*x will evaluate x twice
19:56:18 <ddarius> It's call-by-need (or some very close variant) in practice.
19:56:42 * Fredrik goes to the toilet
19:57:12 * jmcarthur wishes IRC was call by need. I didn't need that information.
19:57:23 <monochrom> haha
20:00:13 <jmcarthur> Fredrik: "Looking at the second line, shouldn't it be obvious that the function works on Integers?" --- No, because it works on any instance of Num. :)
20:00:45 <Fredrik> That's the point, read on ;)
20:00:48 <jmcarthur> a reader could be confused trying :t square after loading that example into ghci
20:00:58 <jmcarthur> ah, type classes is next, i see
20:01:38 <Gracenotes> I don't think there's a way to generate random numbers in the range 0 to 2 (3 values) just with bits, right?
20:02:24 <centrinia> Gracenotes, how many bits?
20:02:52 <Gracenotes> unbounded number of them, randomly distributed
20:02:54 <jmcarthur> Gracenotes: you could reject numbers outside a certain range, repeating as necessary to get numbers within range
20:02:57 <TomMD> Gracenotes: Sure, if you are willing to accept a bias or function without termination certainty.
20:03:45 <Gracenotes> yeah. The bias can be arbitrary small, I think, but it'll always be there.
20:03:49 <centrinia> You could keep around a growing state.
20:04:27 <TomMD> Gracenotes: you could get an even-number of random bits and have an odd-number of regions for mapping to the final number.
20:04:44 <Philippa_> TomMD: is there no possible PRNG that combines both? or will they all have cycle lengths that don't divide by 3?
20:05:03 <jmcarthur> Gracenotes: you could collect three bits, interpret them each as one or zero, then add them together
20:05:15 <TomMD> As you said, the bias will be there but could be so extremely small that the chance your RNG is already biased to an order of magnitude greater extent is large.
20:05:29 <Philippa_> ah, actually random...
20:05:31 <Gracenotes> jmcarthur: that would be skewed, Gaussian
20:05:50 <Philippa_> also, it has the wrong range
20:06:21 <centrinia> You could collect three bits, accept them if and only if exactly one of them is equal to one, and use the index of that bit as the pseudorandom number.
20:06:23 <TomMD> > maxBound :: Word32
20:06:24 <lambdabot>   4294967295
20:06:48 <TomMD> > [0,maxBound `div` 3,maxBound] :: [Word32]
20:06:49 <lambdabot>   [0,1431655765,4294967295]
20:06:53 <Philippa_> centrinia: possibly non-terminating if your source is genuinely random
20:07:05 <TomMD> > 4294967295 - 1431655765
20:07:06 <lambdabot>   2863311530
20:07:18 <Philippa_> I mean, exceedingly unlikely, sure...
20:07:31 <TomMD> hum, what did I do wrong.
20:07:34 <Gracenotes> oh, that'd work. I'm not concerned about non-termination so much
20:07:42 <Gracenotes> (it's theoretical anyway)
20:08:21 <TomMD> oh - well then recursion is your friend.
20:08:43 <centrinia> The most that can happen is something like this: http://xkcd.com/221/
20:08:45 <jmcarthur> silly me, forgetting everything i learned in my probability class years ago
20:08:47 <Gracenotes> not sure why I didn't think of repetition... you can use it to get a fair decision from an unfair coin :)
20:09:11 <tromp_> repeatedly flip 3 bits until not all equal
20:09:33 <TomMD> xor, get 1
20:09:37 <tromp_> then return rotation giving lexigraphic minimum
20:09:43 <shukhov> anyone have tips on how to resolve "rigid typ var" errors?
20:10:12 <tromp_> works for generating any random number mod a prime
20:10:31 <tromp_> for non-prime just repeat for all prime factors
20:11:12 <Gracenotes> what do you mean by 'equal' and 'rotation' there? :)
20:11:34 <tromp_> all3 bits are equal: 000 or 111
20:12:14 <Gracenotes> okay, and rotation?
20:12:15 <tromp_> 101 needs to be (left)rotated by 1 to get the lexicographic minimum 011
20:12:32 <centrinia> Okay, how do you decide when to flip a bit?
20:13:09 <centrinia> Wait, why doesn't this work for composite length bit-strings?
20:13:18 <Gracenotes> tromp_: ah, I see
20:13:59 <tromp_> expected number of bitflips is p / (1-2^{-p})
20:14:15 <tromp_> which is 4 in case of p=3
20:14:33 <tromp_> oops, i mean p / (1-2^{1-p})
20:15:07 <tromp_> because the pattern could repeat by a factor
20:15:18 <centrinia> Oh.
20:15:34 <tromp_> e.g. 011011
20:15:37 <Gracenotes> flipping? why not just generating new bits?
20:15:41 <tromp_> which would favor the small rotations
20:15:58 <Gracenotes> unless I'm confused. I really need to take some kind of formal probability theory before I graduate...
20:16:05 <tromp_> i call that flipping:)
20:16:23 <Gracenotes> :)
20:16:24 <tromp_> you only need 1 coin to generate many bits
20:16:29 <tromp_> :)
20:17:25 <centrinia> Okay, your method wastes less bits than mine. :)
20:18:02 <Gracenotes> tromp_: and a last question: the result is the number of rotations?
20:18:22 <tromp_> yes
20:19:03 <centrinia> How about the rank of the generated bit-sequence among the sorted list of all p rotations?
20:20:16 <tromp_> works too
20:20:32 <tromp_> just need any bijection between rotations and 0..(p-1)
20:22:56 <Fredrik> Well, thanks for the feedback and goodbye!
20:23:14 <Fredrik> > 'G':'O':O':'D':'B':'Y':'E':'!':[]
20:23:16 <lambdabot>   Not in scope: data constructor `O''
20:23:34 <Fredrik> Hm?
20:23:40 <Fredrik> > 1:2:3:[]
20:23:42 <lambdabot>   [1,2,3]
20:23:44 <centrinia> Missing quote.
20:23:48 <Gracenotes> mismatched O'
20:23:54 <Fredrik> > 'G':'O':'O':'D':'B':'Y':'E':'!':[]
20:23:55 <lambdabot>   "GOODBYE!"
20:23:57 <Fredrik> ah :)
20:24:48 <Gracenotes> :)
20:27:05 <Gracenotes> @. run run text $ "'" ++ intercalate "':'" (map return "GOODBYE!") ++ "':[]"
20:27:08 <lambdabot>   "GOODBYE!"
20:27:15 <Gracenotes> :D
20:28:41 <Gracenotes> @. run run text $ "'" ++ intercalate "':'" (map return "yes\nno") ++ "':[]"
20:28:43 <lambdabot>   <no location info>:
20:28:43 <lambdabot>      lexical error in string/character literal at chara...
20:28:47 <Gracenotes> :(
20:29:12 <Fredrik> let foo = "orat et lab" ++ foo
20:29:14 <Fredrik> > let foo = "orat et lab" ++ foo
20:29:15 <lambdabot>   <no location info>: parse error on input `;'
20:29:45 <Gracenotes> > let foo = "orat et lab" ++ foo in foo
20:29:46 <lambdabot>   "orat et laborat et laborat et laborat et laborat et laborat et laborat et ...
20:29:51 <Fredrik> ah
20:29:55 <Fredrik> thanks :)
20:33:35 <Gracenotes> @src cycle
20:33:35 <lambdabot> cycle [] = undefined
20:33:35 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
20:34:18 <ddarius> cycle = fix . (++)
20:36:03 <kohwj> i found an example reactive program, but it doesn't compile- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2109#a2109 it's from a reactive tutorial from http://netsuperbrain.com/blog/posts/introducing-reactive-events/
20:37:07 <glguy> What function will operate like POSIX’s read(2) on Handles? I want to read up to N bytes, but if the read returns fewer, then that’s fine
20:37:41 <ddarius> getBuf (or whatever it's called)
20:37:58 <glguy> hGetBuf?
20:38:10 <ddarius> You can probably do it with a higher level interface (e.g. take n =<< readFile "foo")
20:38:31 <glguy> no, I need all of the data
20:38:36 <glguy> but the boundaries of the read are important
20:39:25 <glguy> hGetBuf will continue to call read, as far as I can tell
20:39:30 <glguy> to try filling the buffer provided
20:40:47 <dolio> hGetBufNonBlocking, then?
20:43:05 <glguy> My goal was to read from the file descriptor wrapped in a Handle so that it would make use of GHC's RTS's existing select loop
20:43:22 <glguy> since I need all of the data in the file descriptor, I'd have to loop calling that over and over, right?
20:43:37 <glguy> hWaitForInput blocks when you aren't using -threaded
20:44:31 <sjanssen> glguy: really?
20:44:40 <sjanssen> did it always do that?
20:44:43 <glguy> that's what the haddocks say
20:44:51 <kbateman> How about System.IO.Posix.fdRead?
20:45:04 <glguy> that calls directly to c_read
20:45:13 <glguy> which would block the rest of the program, right?
20:45:46 <kbateman> I thought the FFI handles blocking external calls.
20:45:47 <bd_> Doesn't the threaded RTS pass off blocking calls to a seperate native thread?
20:46:15 <glguy> I thought that only happend with -threaded
20:46:22 <sjanssen> bd_, kbateman: only in -threaded
20:46:37 <sjanssen> foreign calls block the whole runtime without -threaded
20:47:03 <bd_> ah
20:47:12 <sjanssen> glguy: oh, read the whole haddock on hWaitForInput
20:47:19 <glguy> kk
20:47:29 <sjanssen> "hWaitForInput t where t >= 0 will block all other Haskell threads for the duration of the call."
20:47:32 <kbateman> Well, either use -threaded or non-blocking IO then
20:47:35 <bd_> incidentally, how much of a performance difference does haskell's lightweight threading actually give over using native threads?
20:47:42 <sjanssen> glguy: you haven't mentioned needing a timeout
20:47:47 <ddarius> bd_: A huge one.
20:48:04 <bd_> ddarius: I mean, are there actual benchmarks anywhere? :)
20:48:55 <glguy> sjanssen, yeah, without -threaded, it blocks for t seconds
20:49:21 <sjanssen> glguy: hWaitForInput (-1)
20:49:45 <sjanssen> glguy: do you actually need to block for t milliseconds, or just until some input is available?
20:49:47 <ddarius> bd_: Probably.  Certainly there are very indirect ones.
20:50:00 <glguy> I don't have a timeout
20:50:15 <sjanssen> glguy: so hWaitForInput (-1) will work for you
20:51:48 <sjanssen> glguy: alternatively, you can use threadWaitRead directly on the Fd
20:52:28 <glguy> sjanssen, where is threadWaitRead?
20:52:35 <sjanssen> glguy: Control.Concurrent
20:53:33 <glguy> sjanssen, actually, threadWaitRead is a call to hWaitForInput :)
20:53:45 <glguy> (if you aren't using -threaded)
20:53:55 <glguy> so this would work in both cases
20:54:03 <sjanssen> I'm sure they use the same machinery in the end
20:54:08 <glguy> ew
20:54:11 <glguy> only works on stdin
20:54:14 <glguy>                   _ -> error "threadWaitRead requires -threaded on Windows, or use System.IO.hWaitForInput"
20:54:30 <glguy> is the case otherwise
20:54:35 <glguy> OH
20:54:36 <glguy> ha
20:54:38 <glguy> that's mingw32
20:54:42 * glguy continues reading
20:55:13 <sjanssen> glguy: yeah, was just reading that
20:55:38 <sjanssen> scary that isn't documented :/
20:56:01 <glguy> no one does seroius development any windows anyway, right?
20:57:08 <rovar> windows is only for people who like money
20:57:37 <glguy> spending it on the license?
20:57:55 <Pseudonym> Yeah, for people who like throwing away money more like.
20:58:12 <Pseudonym> Windows is for people who are forced to use it.
20:58:46 <aluink> windows is more suited for enterprise work now
20:58:51 <kerlo> Windows is for people who have forgotten why Linux is better.
20:59:04 <rovar> that's true for people who know and love linux (or mac)
20:59:09 * glguy hopes no one at work finds out that windows is where the money is
20:59:16 <glguy> would suck if they made us use it
20:59:32 <aluink> windows doesn't have anything useful out of the box
20:59:36 <rovar> i never said anything about using it.. just writing software for that platform :)
21:00:41 <Pseudonym> The real money is in writing sotware for embedded systems.
21:01:07 <sjanssen> I thought it was botnets
21:01:18 <rovar> that's why I'm learning haskell
21:01:25 <rovar> the choice of botnet programmers everywhere.
21:01:45 <ddarius> @botattack
21:01:45 <lambdabot> Unknown command, try @list
21:01:45 <lunabot>  :)
21:01:57 <rovar> actually.. i'd have to pick erlang just for the live upgrade feature.
21:02:51 <Pseudonym> According to Ramone, the Brazilian who successfully attacked a server that I administered some time ago, the language of choice is anything written by someone else.
21:02:54 <rovar> the only thing better than a botnet is a botnet with 5 9's uptime through software upgrades :)
21:02:58 <Gracenotes> @botsuck
21:02:58 <lambdabot> :)
21:02:58 <lunabot>  :)
21:03:17 <rovar> hehe
21:03:42 <rovar> i'd like to think that the owners of the more pristigious botnets are more savvy than script kiddies
21:04:51 <Pseudonym> I'd like to think that my machines attracted a better class of hacker.
21:05:02 <Pseudonym> But apparently not.
21:05:37 <rovar> back in the late 90's. I was working on a game project with a few guys. The founder of the project had just left his job as director of IT security for ATT worldnet.
21:06:44 <rovar> some kiddie hacked our server.. this guy pinned his ass to the wall.  Basically tracked him down. Then hired a "consultant" for 10,000 in damages to asses the situation. Because at that level of damage. the FBI will get involved
21:07:03 <rovar> given his current position, he happened to know who to call.
21:10:35 <p_l> rovar: I'll have to note that method
21:11:02 <p_l> as for updating botnet... Wasp Lisp was basically designed for this :>
21:11:10 <rovar> :)
21:11:35 <p_l> Or more like it's a special platform for distributed, secure ;-) botnets
21:11:53 <rovar> i'm in the wrong business
21:12:08 <rovar> I want to make a grid computing cluster that I can sell time on.
21:12:13 <rovar> for very cheap
21:12:41 <p_l> could have also interesting usage as defense tool... imagine that attacker suddenly finds that _every_ machine on your network is a carefully orchestrated bot :)
21:13:25 <shapr> How would you use Haskell for grid computing?
21:13:29 <p_l> rovar: if you can live with MIPS64, get SiCortex stuff... at that kind of power usage it should be possible :)
21:13:36 <jeffwheeler> p_l: what symptoms would that show?
21:13:50 <p_l> jeffwheeler: Depends on how devious you are...
21:14:15 <inimino> shapr: isn't that basically what Google's doing?
21:14:24 <inimino> not Haskell, but sawzall
21:14:45 <rovar> shapr: p_l,   A botnet automaton could be easily built in haskell.
21:14:51 <shapr> rovar: How?
21:14:59 <p_l> afaik google's core software is written in C++
21:15:06 <rovar> that's the kind of grid computing that's best.. where I don't own the computers.
21:15:10 <Gracenotes> botnets can be written in Haskell with the power of @faq
21:15:28 <shapr> Yeah, but I want details.
21:15:33 <shapr> And, I want code :-)
21:15:45 <inimino> heh
21:15:58 <p_l> so impatient ;-)
21:16:01 <rovar> shapr, just install a lightweight udp listener that processes instructions.  Installing it should be a matter of your favorite trojan installer.
21:16:08 <rovar> ask a script kiddie for that.
21:16:13 <shapr> rovar: Do you have Haskell code that does this?
21:16:35 <rovar> no.. I'm still learning haskell.. but even with my meager skills I could probably do it.
21:16:42 <Pseudonym> > unsafeRootkit
21:16:43 <lambdabot>   Not in scope: `unsafeRootkit'
21:16:43 <shapr> Ok! I want to see it!
21:16:56 <Gracenotes> rovar: would you ensure reliability on top of the UDP?
21:17:07 <shapr> rovar: What Haskell libs would you use?
21:17:16 <jeffwheeler> Why have reliability insured on a botnet?
21:17:23 <inimino> if it's a map-reduce type thing you don't need to care about reliability
21:17:27 <p_l> jeffwheeler: reliability + security
21:17:28 <rovar> Gracenotes:  volume over reliability.
21:17:43 <Gracenotes> okay, just wondrin
21:17:46 <inimino> you just restart the tasks that fail on a different node
21:17:46 <shapr> rovar: Yeah, but which libs would you use?
21:18:10 <p_l> shapr: to make it good you would probably have to write a small haskell implementation :P
21:18:44 <ddarius> Yes!  You need to make it so that you can infect washing machines with Haskell.
21:18:59 <pumpkin_> infected washing machines :o
21:19:00 <inimino> naw, just use LLVM
21:19:15 <jeffwheeler> My washing machine isn't connected to my network, but my fridge might be. ;)
21:19:16 <shapr> Does llvm run on most arches?
21:19:17 <rovar> shapr: i'd use http for the automaton so that it could covertly read my instructions embedded in the cryptic messages posted on myspace comment boards
21:19:19 <inimino> no need to install Haskell remotely, treat them like embedded devices
21:19:25 <rovar> which i think most of them are
21:19:36 <shapr> ah
21:19:49 <Gracenotes> or, even better, install Haskell on their machines and force them to learn it
21:20:37 <ddarius> Gracenotes: That's xmonad's plan.
21:35:10 <p_l> ddarius: And it works!
21:36:53 <desp> Can someone point me to an example of using the Haskell standard pretty printing library with binary operators with a precedence table?
21:37:00 <desp> I had it somewhere in my crap folder...
21:37:06 <desp> Can't find it.
21:38:28 <roconnor> desp: you mean like the read show instances documented in the Haskell 98 report?
21:40:09 <desp> Actually, ha.
21:40:11 <desp> I'm wrong.
21:40:36 <desp> I didn't have it anywhere; the precedence table I had was used for parsing, not pretty printing.
21:41:05 <desp> roconnor: so, could you point me towards the right section?
21:48:25 <_dolio> @remember xahlee my fav is Emacs Lisp. Because it is practical. More or less the most widely used lisp today.
21:48:26 <lambdabot> Done.
21:48:59 <roconnor> desp: section 10.5
21:50:15 <desp> roconnor: aha
22:07:02 <dons> ?yow
22:07:02 <lambdabot> I hope I bought the right relish ... zzzzzzzzz ...
22:07:22 <dons> dolio: wow
22:08:01 <dolio> Eh?
22:08:34 <dons> the xah quote
22:08:49 <dolio> Oh yeah. Heh.
22:08:56 * Axman6 doesn't know enough about the lisps to get it :(
22:09:18 <pumpkin_> where do you get these xah lee quotes?
22:09:27 <dolio> comp.lang.functional
22:09:30 <pumpkin_> ah
22:09:36 <pumpkin_> he gave up on IRC?
22:09:42 <Axman6> @quote xahlee
22:09:42 <lambdabot> xahlee says: i do wonder, if any reputable computer scientist would blub out such idiotic things as this thread's lispers have been.
22:09:52 <dolio> He never spoke much here. And now he's banned apparently.
22:09:57 <Axman6> heh
22:10:24 <pumpkin_> it must take a lot of work to get banned from here
22:10:39 <Axman6> doesn't take that much...
22:10:48 <pumpkin_> that .syr.edu guy and xah lee are the only people who aren't spammers I know who are banned
22:11:04 <dolio> @palomer
22:11:04 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
22:11:05 <Axman6> "hey, check out this girl's hot tits!!!! http://somethig.com/index.php?user=234fv31t43fwE"
22:11:13 <pumpkin_> lol
22:11:23 <pumpkin_> spam!
22:11:27 <pumpkin_> somethig.com has ads on it
22:11:29 <Axman6> :O
22:16:00 <dolio> @remember xahlee This thread, illustrates, how often comp lang fanatics propagate patently false things, in their fanaticism.
22:16:00 <lambdabot> I will remember.
22:16:33 <pumpkin_> I loved his rant about tail recursion
22:17:33 <dolio> @remember xahlee I would like to see Common Lisp and or Scheme Lisp die a miserable, horrid, deaths, due to fanaticism as exhibited by Common Lisp and Scheme Lisp regulars in newsgroups.
22:17:34 <lambdabot> I will never forget.
22:17:44 <dons> ah newsgroups
22:19:40 <Gracenotes> @hoogle a -> State a -> Bool
22:19:40 <lambdabot> Did you mean: a -> State a a -> Bool /count=20
22:19:40 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
22:19:40 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:19:47 <Gracenotes> @hoogle a -> Set a -> Bool
22:19:48 <lambdabot> Data.Set member :: Ord a => a -> Set a -> Bool
22:19:48 <lambdabot> Data.Set notMember :: Ord a => a -> Set a -> Bool
22:19:48 <lambdabot> Data.Foldable elem :: (Foldable t, Eq a) => a -> t a -> Bool
22:20:39 <Gracenotes> @type Set.filter
22:20:40 <lambdabot> Couldn't find qualified module.
22:20:43 <Gracenotes> @type Data.Set.filter
22:20:44 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> S.Set a
22:27:39 <dons> i think its interesting that the shootout now uses a log scale, and language implementations pretty much fall into a straight line on this scale. http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
22:30:34 <pumpkin_> I think all the fractions they use now are best written as ^(-1)
22:30:44 <pumpkin_> all the 1/ are distracting
22:31:12 <Axman6> bleh, i'm going to totally have to rewrite this mandelbrot function -_-
22:31:19 <Axman6> uh, program
22:31:50 <mmorrow> @pl \c (a, b) -> f a b c
22:31:51 <lambdabot> (`ap` snd) . (. fst) . flip (flip . f)
22:31:52 <dons> i'm playing with knuc
22:32:06 <mmorrow> @pl \c a b -> f a b c
22:32:07 <lambdabot> flip (flip . f)
22:32:20 <mmorrow> @type (\f -> `ap` snd) . (. fst) . flip (flip . f)
22:32:21 <lambdabot> parse error on input ``'
22:32:26 <mmorrow> @type \f -> (`ap` snd) . (. fst) . flip (flip . f)
22:32:27 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> b -> (a, a1) -> c
22:32:38 <mmorrow> @type uncurry (flip (flip . f))
22:32:40 <lambdabot> forall a b c b1. (SimpleReflect.FromExpr c, Show b, Show a, Show b1) => (b, b1) -> a -> c
22:32:45 <mmorrow> @type \f -> uncurry (flip (flip . f))
22:32:47 <lambdabot> forall a b c b1. (b1 -> a -> b -> c) -> (b, b1) -> a -> c
22:33:07 <mmorrow> wut
22:33:16 <lokathor> thems some nasty lookin' type signatures you got there
22:33:53 <mmorrow> yeah. i hate when a function's arg order happens to be the worst possible it could be in a particular situation
22:34:39 <pumpkin_> betterfuncF a b c d f = funcF d b a c f
22:34:47 <mmorrow> especially when you want the code to be symmetric looking wrt another case where the order happens to be perfect
22:35:02 <mmorrow> pumpkin_: that'd kill my symmetry :(
22:35:04 <pumpkin_> maybe even funcF'
22:35:07 <mmorrow> whatever, i'm over it :)
22:35:11 <pumpkin_> just define it globally
22:35:13 <pumpkin_> :P
22:35:21 <pumpkin_> then the symmetry will only be broken by the apostrophe
22:35:26 <pumpkin_>  / prime
22:36:22 <lokathor> as odd a thing as it may seem to be to say: symmetry should lose to readability.
22:37:08 <pumpkin_> being able to show symmetry of two similar things can add to readability
22:37:16 <pumpkin_> if they are similar but the language can't express that
22:37:27 <pumpkin_> then you should hack around it :p
22:37:40 <Gracenotes> @hoogle [Maybe a] -> [a]
22:37:40 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:37:40 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
22:37:40 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:38:37 <mmorrow> woot, just found an acceptable solution
22:38:40 <mmorrow> deview (VI (i :<| t)) = uncurry (B i) (detailify t)
22:38:40 <mmorrow> deview (VO (h :|> o)) = flip (uncurry B) o (deheadify h)
22:38:54 <pumpkin_> mmorrow: whatcha doing?
22:39:57 <mmorrow> pumpkin_: http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html
22:40:05 <mmorrow> almost done
22:40:14 <pumpkin_> :o
22:40:50 <pumpkin_> looks scary to me
22:41:01 <mmorrow> it's pretty cool. Pseudonym linked to it the other day, and it's also what ghc uses (in some form) for Cmm dataflow stuff
22:41:10 <mmorrow> pumpkin_: it's actually pretty simple
22:41:18 <mmorrow> which is why it's coool
22:41:53 <pumpkin_> :o
22:42:14 <mmorrow> pumpkin_: here're the datatypes http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1759#a1759
22:42:56 <pumpkin_> interesting
22:43:00 <pumpkin_> what are you gonna do with it?
22:43:56 <mmorrow> since i want to use a register-based abstractmachine for the interpreter i'm writing, turns out i need to do a dataflow analysis on the control-flow-graph to figure out live-vars in order to allocate registers.. :/
22:44:14 <pumpkin_> ah
22:44:16 <mmorrow> at first i was like "oh shit"
22:44:21 <pumpkin_> make it reusable kthx
22:44:26 <pumpkin_> I'm sure this is handy going the other way too
22:44:26 <pumpkin_> :P
22:44:31 <mmorrow> but it actually seems do-able now that i know wtf i have to do :)
22:44:54 <mmorrow> pumpkin_: yeah, that's what i'm shooting for (generality/reusability)
22:45:01 <pumpkin_> yay
22:45:24 <pumpkin_> one of these days I'm going to try to see how readable ghc-generated code is
22:45:31 * wli was tryingto do a register-based abstract machine but wasn't getting very far.
22:45:33 <pumpkin_> I'm sure it looks quite different from what I'm used to
22:45:50 <JohnMeacham> pumpkin_: not very.
22:46:13 <mmorrow> wli: i'll paste the links to stuff that edumacated me about this
22:46:57 <pumpkin_> JohnMeacham: the assembly it spits out?
22:47:40 <wli> mmorrow: I got as far as http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1751
22:47:41 <JohnMeacham> ah, I am not sure about the assembly actually, but the C code is nothing like normal C code.
22:47:43 <pumpkin_> calling conventions between functions, tail calls, etc.
22:47:54 <pumpkin_> oh yeah, I've looked at the "c"
22:47:56 <pumpkin_> :)
22:48:14 <Axman6> dons: hmm, after taking a closer look at the mandelbrot code, it seems it's basically doing what i was proposing, but using mallocArray0 instead of one IOUArray
22:48:16 <mmorrow> pumpkin_: the Cmm would probably be a lot more tolerable, and it's basically the same thing (wrt layout/etc) as the asm
22:48:25 <mmorrow> pumpkin_: (i was peeking at that the other day)
22:48:29 <wli> mmorrow: What killed me was control flow.
22:48:29 <pumpkin_> mmorrow: oh, I'm talking in terms of reversing
22:48:35 <pumpkin_> I've read a fair amount of cmm
22:49:14 <pumpkin_> not that much haskell tends to be closed-source these days
22:49:15 <pumpkin_> but who knows
22:49:17 <pumpkin_> :)
22:50:30 <mmorrow> wli: it looks like there's not really any way to branch
22:51:02 <pumpkin_> not really any way to branch?
22:51:13 <mmorrow> like as in a "case" expression
22:51:31 <pumpkin_> yeah, but where is there no way to branch?
22:51:40 <mmorrow> pumpkin_: in wli's AST
22:51:43 <pumpkin_> oh
22:51:53 <pumpkin_> somehow I missed that url :P
22:52:10 <pumpkin_> [01:51:13] <mmorrow> like as in a "case" expression
22:52:12 <pumpkin_> lol
22:52:16 <mmorrow> :)
22:53:09 <pumpkin_> projection?
22:53:13 <wli> mmorrow: I never added one because I couldn't come up with a plan for how to generate the 3AC IR for it.
22:53:24 <pumpkin_> oh
22:53:47 <pumpkin_> PrjOp = lookup?
22:53:51 <mmorrow> wli: hmm, i'm not sure. i'm eyeing cps myself
22:54:02 <Gracenotes> @hoogle (k -> a -> a -> b) -> [(k, a)] -> Map k b
22:54:02 <lambdabot> Data.Map fromListWithKey :: Ord k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
22:54:02 <lambdabot> Data.Map fromAscListWithKey :: Eq k => (k -> a -> a -> a) -> [(k, a)] -> Map k a
22:54:11 <Gracenotes> :'[
22:54:46 <wli> mmorrow: CPS would be great if I understood it at all. :(
22:54:50 <mmorrow> pumpkin_: i think it's projection from a tuple
22:55:19 <pumpkin_> which means getting the nth element out of a tuple?
22:55:29 <mmorrow> wli: from what i understand all cps is is instead of pushing frames on the stack, you heap allocate a cont frame
22:55:50 <mmorrow> wli: and do s/return-addr/cont-addr/
22:56:07 <mmorrow> (or you could put them on the stack i guess too)
22:56:57 <wli> PrjOp is extracting the n-th element of a tuple.
22:57:15 <pumpkin_> fine, I call it lookup :P
22:57:20 <mmorrow> put for case expressions, you basically just (say you're casing on a con tag) have a  (Int, Ofs, [(Tag, Ofs)])
22:57:26 <mmorrow> (Tag = Int, Ofs = Int)
22:57:47 <mmorrow> (the first Ofs is the default  offset if nothing matches)
22:57:56 <wli> My plot there was to have case expressions do some sort of n-way multiway jump.
22:57:56 <mmorrow> and the first int is the number of cases
22:58:29 <mmorrow> then you run down the list checking the Tag you get handed against the tags in the list, and jump to the associated offset when you find a match
22:59:15 <quicksilver> jump table is better than running down list
22:59:20 <quicksilver> if the number of cases is > N
22:59:26 <quicksilver> where N is quite a small number (4?)
23:00:03 <pumpkin_> I jumped off a table as a kid
23:00:06 <mmorrow> quicksilver: yeah, i'm conflicted though, because then you need to require that every case has number of cases equal to the number of constructors for a type
23:00:07 <pumpkin_> I bit through my lip
23:00:12 <mmorrow> which could possibly be huge
23:00:52 <mmorrow> whereas if you have a type with 40 cons, and you just want to check for one of them, or default to something if that's not the case, you only need two case arms
23:00:58 <wli> I was going to insist on exhaustive pattern matching and ignore the issue.
23:01:30 <mmorrow> quicksilver: but otoh, a jump table would be so much prettier (and easier)
23:01:42 <quicksilver> mmorrow: that's true. Although even 38 wasted words is not a huge problem.
23:01:51 <mmorrow> yeah, that's true to
23:02:02 <quicksilver> mmorrow: I wouldn't bother optimising for code size and that's not going to fill a cache.
23:02:04 <wli> Someone was saying they thought my monad code was somehow obfuscated.
23:02:27 <mmorrow> quicksilver: hmm, ok i think you just changed my mind :)
23:02:28 <quicksilver> mmorrow: 398 wasted words might be more of an issue, but that's one hell of a data type :)
23:02:39 <wli> Codesize can matter depending on when and how your code is invoked.
23:02:46 <quicksilver> it's true, wli
23:02:58 <quicksilver> but I'd probably make execution speed my first priority ;)
23:03:03 <quicksilver> people can always buy new hard disks.
23:03:19 <wli> Kernels, for instance, almost always run cache cold. You get the same sort of issue with servers that wait for some event to trigger actions most of the time.
23:04:04 <wli> I thought what I had for 3AC bytecode translation was decent modulo how crippled of a source language.
23:04:46 <quicksilver> wli: I'm pretty clueless about modern CPUs, but even if you're cache cold, your code still gets loaded in chunks > 512 bytes, doesn't it?
23:05:00 <quicksilver> "loaded" -> into the instruction cache, I mean.
23:05:37 <wli> Cacheline size and instruction cache behavior varies, the latter more so than the former and without a whole lot of documentation.
23:05:53 <quicksilver> I understand that GHC uses both conditionals and jump tables, I wonder how they decide which to use when.
23:07:30 <wli> What I really wanted was a graph IR that could model how e.g. various instructions have multiple effects, like condition codes on x86.
23:08:05 <wli> I couldn't figure out how to do that, either.
23:11:14 * pumpkin_ is playing with the convolution theorem
23:11:22 * pumpkin_ wants to go to sleep
23:11:34 <wli> Which convolution theorem?
23:11:50 <pumpkin_>  I didn't know there was more than one
23:12:05 <wli> Fourier, Mobius, etc.
23:12:07 <pumpkin_> convolution = multiplication in frequency domain
23:12:16 <wli> Most of the integral transforms have one.
23:12:19 <pumpkin_> ah, fourier then
23:12:36 <wli> There's a number theoretic one, too.
23:12:42 <pumpkin_> yeah, I've played with that one too
23:13:00 <wli> (which, in principle, is an integral transform in counting measure)
23:14:32 <mmorrow> quicksilver: interesting, i didn't know they used both
23:14:50 <wli> mmorrow: Maybe some sort of analogue of register windowing for the bytecode/3AC IR is the way to go.
23:15:16 <pumpkin_> seems like jump tables are only convenient/possible if whatever you're jumping over is compact enough
23:15:24 <mmorrow> wli: hmm, how does register windowing work?
23:16:32 <wli> mmorrow: There are input registers for function arguments, %i0, %i1, .. %i7 (obviously you need not limit it to 8 registers in an IR), some number of locals %l0, %l1, ..., and some number of output registers %o0, %o1, ...
23:17:48 <wli> mmorrow: On function calls, %o0, ... automatically get moved to %i0, ... and the hardware performs register spilling in some lazy manner.
23:17:58 <mmorrow> pumpkin_: i'm not sure exactly what you have in mind, but i'm thinking of ... say PC=here and "case (Con {tag = i}) of [93,42,200...]" ==> jmp *(here + i)
23:18:19 <mmorrow> modulo other misc that would be going on
23:18:54 <pumpkin_> I'm saying if you do case x of 1 -> ...; 100000 -> ...; _ -> ...;
23:19:03 <pumpkin_> that's not a good case to use a jumptable
23:19:04 <wli> I was thinking a variadic n-way jump primitive in the IR and hoping that if something lower-level ever happens that the lower-level translation resolves it.
23:19:31 <mmorrow> pumpkin_: ohhh, yeah for casing on literals you couldn't use a jumptab
23:19:37 <pumpkin_> well
23:20:02 <pumpkin_> case x of 1 -> ...; 2 -> ...; 3 -> ...; 8 -> ...; _ -> ... is reasonable
23:20:15 <wli> For a large coproduct of nullary alternatives you might, actually.
23:20:17 <pumpkin_> probably just some heuristic
23:20:35 <wli> Pretty much how many different cases there are to consider.
23:20:35 <mmorrow> wli: interesting, so you know where the registers get spilled to, right? or does it not matter because they get restored on a ret?
23:21:08 <mmorrow> wli: also, are register windows a moot point if you're not using call/ret ?
23:21:10 <wli> mmorrow: The hardware only spills registers from stack frames above the current one.
23:21:27 <mmorrow> wli: ohh, ok. spill to the stack
23:21:49 <wli> mmorrow: They are on the hardware implementations, but it's not difficult to envision a sort of automatic renaming scheme for tailcalls.
23:21:54 <mmorrow> pumpkin_: yeah, that'd be a total pita though to identify
23:22:04 <mmorrow> wli: hmm
23:22:13 <pumpkin_> I know some c compilers do it :)
23:22:25 <pumpkin_> but that's just because the switch statement is the only way to get there
23:22:35 <pumpkin_> and you can calculate how much wasted space you'd have quite easily
23:22:49 <pumpkin_> and decide how much of the jumptable is fallthrough and how much is good
23:23:34 <mmorrow> pumpkin_: hmm, yeah it'd be interesting to read a quick summary/overview of how C compiler's do switch stmts
23:23:35 <wli> For enormous but sparsely populated case spaces, there's always binary search in a tagged jumptable.
23:23:47 <mmorrow> ah, true
23:23:49 <pumpkin_> yeah
23:23:52 <wli> (which IIRC gcc does in some instances)
23:23:54 <mmorrow> cool
23:23:55 <pumpkin_> I haven't seen that pattern before
23:24:01 <pumpkin_> but sounds reasonable
23:24:21 <pumpkin_> not sure how much benefit you'd get over a suitable explciit "decision tree" though
23:24:30 <mmorrow> which reminds me, gcc's computed gotos are friggin sweet for an interpreter
23:24:31 <pumpkin_> of just cmp/jmp
23:25:04 <wli> They originally implemented it to support some extension involving specifying ranges in case statements.
23:25:15 <pumpkin_> ah ok
23:25:17 <mmorrow> goto *lbls[*pc++];
23:25:43 <mmorrow> eat that switch!!
23:25:47 <pumpkin_> :P
23:25:56 <mmorrow> :)
23:26:25 <pumpkin_> I've never looked much at how compilers make their choices
23:26:34 <pumpkin_> only at the choices they make
23:26:51 <wli> mmorrow: In the register windowing analogue for IR's, a tailcall would just bulk rename the output registers to the input registers (e.g. swap the Data.Map.Map structure elements) and not bother saving anything on the stack.
23:28:37 <wli> With single assignment like I had I think all you can do there is dump a list of registers to pass as inputs to the call and tailcall primitives, but I never got that far.
23:29:57 <mmorrow> wli: this is interesting http://www.cs.princeton.edu/~appel/papers/ssafun.pdf
23:30:08 <wli> I was (and still am) pretty confused as to whether I really wanted a graph or a linear 3AC IR.
23:32:15 <mmorrow> this is good too: http://www.cs.utexas.edu/users/pingali/CS380C/2007fa/papers/p66-chaitin.pdf
23:33:44 <wli> Trying to follow, but my abilities are quite limited.
23:34:34 <wli> I'm not even going to attempt register allocation.
23:34:59 <mmorrow> which one? i just briefly skimmed that SSA one, but the graphcoloring one is pretty elementary (in terms of anything you need to know going into it)
23:35:32 <wli> Dude, I'm struggling to get the most basic of basics going.
23:35:38 <wli> This is way beyond me.
23:36:10 <mmorrow> wli: no way, dude.
23:36:12 <mmorrow> :)
23:36:44 <pumpkin_> wli: did you do math in college?
23:37:16 <wli> mmorrow: Just look at how badly I have to cripple the source language to do anything in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1722#a1751
23:37:25 <wli> pumpkin: yes.
23:41:45 <wli> mmorrow: It's pretty sad. :(
23:42:59 <wli> Now that I've proved I can't handle translating to 3AC I'm busy proving I can't handle reducing untyped lambda terms.
23:43:15 <wli> via tree reduction
23:47:54 <wli> mmorrow: Still there?
23:57:18 <JohnMeacham> new release of jhc out. enjoy.
23:58:06 <opqdonut> :)
