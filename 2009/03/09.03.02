00:00:05 <pumpkin_> Language feels too human-readable
00:00:08 <Gracenotes> pumpkin_: we do have a Language hierarchy. If that fits
00:00:12 <pumpkin_> I know some people are crazy and can read assemblies
00:00:18 <pumpkin_> in hex
00:00:43 <wli> mathijs: concatMap (\(x,y) -> [x,y]) sounds reasonable.
00:00:44 <ski_> (istr `20' was `jmp' .. or maybe `jsr')
00:00:53 <Gracenotes> the only things in the Language hierarchy are BASIC and Haskell, though, as far as I know >_>
00:01:00 <pumpkin_> and c
00:01:05 <pumpkin_> Language.C
00:01:07 <Gracenotes> oh. yes, that.
00:01:10 <pumpkin_> there are the obvious ones like 0x90 = nop on x86
00:01:14 <Gracenotes> that's actually useful though ;)
00:01:27 <pumpkin_> and anything starting with 0xe in ARM is unconditional :P
00:01:33 <mathijs> wli: that doesn't give me the order I want :)
00:01:37 <pumpkin_> that's about the extent of my hexreading skillz
00:01:46 <Gracenotes> oddly enough, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hjs isn't in language.javascript
00:02:02 <pumpkin_> I'm thinking of calling the package itself charm
00:02:04 <Gracenotes> it's its own thing, though
00:02:05 <erikc> Data.ISA.ARM
00:02:10 <pumpkin_> ISA?
00:02:16 <erikc> instruction set architecture
00:02:27 <wli> Or Language.ISA.ARM
00:02:31 <Gracenotes> Architecture sounds nice
00:02:40 <pumpkin_> naming is always the hardest part
00:02:43 <Gracenotes> Language.Architecture :)
00:02:43 <erikc> hehe
00:02:47 <Workybob> Architecture.ARM surely
00:02:55 <pumpkin_> not Data.Architecture?
00:03:07 <ski_> (surely `ARM' ISA `BodyPart' ?)
00:03:15 <pumpkin_> the only other package that would belong in Architecture is Harpy, which doesn't use any of that
00:03:23 <Workybob> I don't see how an Architecture is any more Data than a Monad is
00:03:26 <Workybob> i.e. they both are
00:03:31 <pumpkin_> fair enough
00:03:33 <Workybob> but neither of them is used for data
00:03:37 <Gracenotes> Data.Network.Monad.ARM.Lazy
00:03:42 <pumpkin_> lol
00:03:45 <Workybob> haha
00:03:55 <pumpkin_> Data.Control.Architecture.Monad.ARM
00:04:03 <pumpkin_> Data.Control ftw
00:04:14 <Gracenotes> muahahahaha
00:04:16 <pumpkin_> I like Architecture.ARM
00:04:24 <erikc> ya, thats good
00:04:35 <int-e> > let f xs = go [] xs; go ys [] = ys; go ys ((a,b):xs) = a : go (b:ys) xs in f [(1,2),(3,4),(5,6)]
00:04:36 <pumpkin_> is calling the package charm too cheesy?
00:04:37 <lambdabot>   [1,3,5,6,4,2]
00:04:43 <pumpkin_> harm is already taken
00:04:55 <Gracenotes> maybe you can take harm
00:05:01 <Gracenotes> but it'll cost you an arm and a leg
00:05:03 <pumpkin_> besides, it's negative
00:05:04 <pumpkin_> lol
00:05:09 <pumpkin_> you mean an arm and a thumb?
00:05:13 <Gracenotes> oh snap, second arm+leg joke in a few minutes
00:05:37 <pumpkin_> Architecture.ARM or Architecture.Arm?
00:06:06 <pumpkin_> I hate naming with abbreviations
00:06:16 <erikc> does ARM write and read?
00:06:20 <erikc> or just read?
00:06:20 <pumpkin_> only read for now
00:06:29 <pumpkin_> I'll eventually make it write
00:06:33 <Gracenotes> Arch.ARM
00:06:43 <pumpkin_> but my main interest is static analysis of programs
00:06:44 <int-e> pumpkin_: definitely ARM
00:06:48 <wli> I'm going to have to write off this asm as completely screwed up.
00:06:57 <wli> Or whatever.
00:07:09 <pumpkin_> Gracenotes: not a fan of abbreviating a module name
00:07:16 <Gracenotes> A.A
00:07:26 <pumpkin_> Architecture.AdvancedRiscMachine?
00:07:27 <wli> It's 807 LOC, which is enormous.
00:07:39 <pumpkin_> wli: almost as much as my decoder :P
00:07:40 <mathijs> ?pl filter ((== 0).(y `mod`))
00:07:41 <lambdabot> filter ((0 ==) . (y `mod`))
00:07:56 <wli> pumpkin: Yeah, but for what this does, it's huge.
00:07:59 <pumpkin_> just being silly about AdvancedRISCMachine btw
00:08:00 <mathijs> ?pl \x -> (y `div` x, x)
00:08:00 <lambdabot> (,) =<< (y `div`)
00:08:01 <Gracenotes> C.M.S.L.runState (C.M.S.L.modify (+1)) 10
00:08:18 <pumpkin_> wli: how many instructions does it deal with?
00:08:33 <wli> pumpkin: Let me count...
00:08:40 <Gracenotes> mathijs: see also first
00:08:44 <Gracenotes> @type first
00:08:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
00:09:06 <Gracenotes> for function arrows, (b -> c) -> (b, d) -> (c, d)
00:09:22 <Gracenotes> so "first (y `div`)" :) If you want to import Control.Arrow
00:09:29 <Gracenotes> oh wait, no. :(
00:09:59 <Gracenotes> oh darn. Well, it's ((4 `div`) &&& id)
00:10:15 <Gracenotes> second only applies to things that are already tuples.
00:10:39 <Gracenotes> @type (join (,) >>> first (?y `div`))
00:10:39 <pumpkin_> @let tuplize x = join (&&&) id
00:10:40 <lambdabot> forall a. (Integral a, ?y::a) => a -> (a, a)
00:10:41 <lambdabot>  Defined.
00:10:48 <pumpkin_> > tuplize 5
00:10:49 <lambdabot>       Overlapping instances for Show (c -> (c, c))
00:10:49 <lambdabot>        arising from a use ...
00:10:52 <pumpkin_> boo
00:10:54 <pumpkin_> I fail epicly
00:10:56 <Gracenotes> I like join (,)
00:11:13 <Gracenotes> > (join (,) >>> first (10 `div`)) 4
00:11:14 <lambdabot>   (2,4)
00:11:20 <pumpkin_> @undefine
00:11:26 <wli> pumpkin: Looks like somewhere around 115.
00:11:27 <pumpkin_> @let tuplize = join (&&&) id
00:11:28 <lambdabot>  Defined.
00:11:32 <pumpkin_> > tuplize 5
00:11:33 <lambdabot>   (5,5)
00:11:38 <Gracenotes> :D
00:11:40 <pumpkin_> wli: are they officially thumb instructions?
00:11:48 <pumpkin_> or just modeled after them?
00:11:59 <int-e> > ap (,) id 5
00:12:00 <lambdabot>   (5,5)
00:12:08 <pumpkin_> that's cuter
00:12:15 <ski_> tuplize = diagonal
00:12:18 <wli> pumpkin: No, I just made up my own crap. Whatever ARM inspiration there is is very, very loose.
00:12:23 <pumpkin_> ah :)
00:12:30 <Gracenotes> what? "join (,)" is so cute, it's already on a pay site
00:12:35 <pumpkin_> wli: call it a VM and make a compiler to it
00:12:42 <kniu> @pl (\ hit -> lighted scene hit + refracted scene ray hit + reflected scene ray hit)
00:12:42 <lambdabot> ap ((+) . ap ((+) . lighted scene) (refracted scene ray)) (reflected scene ray)
00:12:54 <pumpkin_> Gracenotes: too simplistic, sry
00:12:57 <pumpkin_> *2
00:13:00 <kniu> :t ap
00:13:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:13:02 <wli> pumpkin: I'm too stupid to make compilers so I did this instead.
00:13:12 <kniu> :t ($)
00:13:14 <lambdabot> forall a b. (a -> b) -> a -> b
00:13:23 <pumpkin_> wli: you sure don't sound stupid, you just sound self deprecating :)
00:13:48 <int-e> > liftM3 (\a b c -> a + b + c) ?lighted ?refracted ?reflected
00:13:49 <lambdabot>       Unbound implicit parameters (?lighted::m a3,
00:13:49 <lambdabot>                           ...
00:14:06 <Gracenotes> ap: (s -> a -> b) -> (s -> b) -> (s -> a)
00:14:06 <int-e> :t liftM3 (\a b c -> a + b + c) ?lighted ?refracted ?reflected
00:14:07 <lambdabot> forall a3 (m :: * -> *). (Monad m, ?reflected::m a3, ?refracted::m a3, ?lighted::m a3, Num a3) => m a3
00:14:08 <Gracenotes> =<<: (a -> s -> b) -> (s -> a) -> (s -> b)
00:14:08 <wli> pumkin: I'm having too much trouble with interpreters, never mind compilers, to do much more than I have. And what I have doesn't really work.
00:14:30 <Gracenotes> er, actually, switch (s -> b) and (s -> a)
00:15:00 <int-e> @pl \a b c -> a + b + c
00:15:00 <lambdabot> ((+) .) . (+)
00:15:07 <kniu> :t sequence
00:15:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:15:20 <pumpkin_> so did we settle on Architecture.ARM?
00:15:29 <pumpkin_> I guess I can always change it if someone comes up with something better
00:15:48 <int-e> @type sum . sequence [(*2)]
00:15:50 <lambdabot> forall a. (Num a) => a -> a
00:16:20 <pumpkin_> does anyone know if augustss put up his symbolic stuff on hackage?
00:16:29 <Gracenotes> BASIC?
00:16:35 <Gracenotes> -.-
00:16:45 <pumpkin_> nope, http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-1.html
00:16:57 <pumpkin_> I'd prefer to just depend on it rather than including it
00:17:09 <Gracenotes> simple-reflect won't do?
00:17:31 <kniu> @pl (\x -> f x + g x + h x)
00:17:31 <lambdabot> ap ((+) . liftM2 (+) f g) h
00:17:49 <pumpkin_> Gracenotes: I need to manipulate more than simple-reflect exposes
00:17:57 <pumpkin_> I want to be able to simplify the expressions
00:18:06 <kniu> :t (\x -> f x + g x + h x)
00:18:07 <lambdabot> forall t a. (Num a, SimpleReflect.FromExpr (t -> a)) => t -> a
00:18:34 <kniu> :t sum . sequence [f, g, h] ?f ?g ?h
00:18:35 <lambdabot>     Couldn't match expected type `t -> t1 -> a -> [a1]'
00:18:35 <lambdabot>            against inferred type `[a2]'
00:18:35 <lambdabot>     Probable cause: `sequence' is applied to too many arguments
00:18:57 <wli> pumpkin: What I've got floating around might make sense as a 3AC IR.
00:19:14 <pumpkin_> 3ac?
00:19:22 <kniu> :t sum . sequence [f::a->b, g::a->b, h::a->b]
00:19:23 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
00:19:23 <lambdabot>       from the context ()
00:19:23 <lambdabot>       arising from a use of `f' at <interactive>:1:16
00:19:30 <wli> pumpkin: 3 Address Code
00:19:33 <Gracenotes> @type liftA3 (((+) .) . (+)) ?f ?g ?h
00:19:34 <lambdabot> forall a (f :: * -> *). (Applicative f, ?h::f a, ?g::f a, ?f::f a, Num a) => f a
00:19:37 <kniu> I'm getting more and more confused.
00:19:54 <Gracenotes> > liftA3 (((+) .) . (+)) (+1) (+2) (+3) $ 100
00:19:55 <lambdabot>   306
00:20:16 <pumpkin_> erikc, int-e, anyone else interested: should I make Architecture.Thumb separate, or do Architecture.ARM.ARM and Architecture.ARM.Thumb?
00:20:34 <Gracenotes> > liftA3 (\a b c -> a+b+c) (+1) (+2) (+3) $ 100
00:20:35 <pumpkin_> it shares a great deal with ARM so it makes sense to put them together, I guess
00:20:35 <lambdabot>   306
00:21:04 <Gracenotes> > liftA3 (\a b c -> a+b+c) (+1) (+2) (+3) $ x
00:21:06 <lambdabot>   x + 1 + (x + 2) + (x + 3)
00:22:03 <Gracenotes> kniu: it's a problem with Exprs. Any arbitrary letter, a to z, is an Expr
00:22:06 <Gracenotes> @type a
00:22:07 <lambdabot> Expr
00:22:17 <Gracenotes> it's useful for introspection.
00:22:23 <Gracenotes> > a^8
00:22:25 <lambdabot>   a * a * (a * a) * (a * a * (a * a))
00:22:46 <pumpkin_> although it doesn't show reuse very clearly there
00:23:06 <erikc> i'd put em together
00:23:19 <Gracenotes> > 2^8 :: Expr
00:23:20 <lambdabot>   2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))
00:23:29 <Gracenotes> > iterate reduce (2^8)
00:23:30 <lambdabot>   [2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)),4 * (2 * 2) * (2 * 2 * (2 * 2)),4 * 4 ...
00:23:32 <pumpkin_> erikc: yeah, so Architecture.ARM.ARM and Architecture.ARM.Thumb ?
00:23:55 <erikc> sure
00:23:59 <int-e> pumpkin_: Architecture.ARM and Architecture.ARM.Thumb? But I see why you want Architecture.ARM.ARM instead.
00:24:03 <maxote> is there ARM 64-bit?
00:24:15 <pumpkin_> I'd prefer not using ARM.ARM, but didn't want to smack ARM into the next level up
00:24:18 <pumpkin_> maxote: nope
00:24:31 <pumpkin_> the devices they target don't typically have much memory :)
00:24:58 <maxote> no? is Terminator a device?
00:25:20 <erikc> now im gonna wanna do Architecture.PowerPC, Architecture.Altivec and Architecture.SPU :)
00:25:27 <pumpkin_> erikc: yes!
00:25:51 <pumpkin_> although shouldn't Altivec be under PowerPC?
00:25:56 <erikc> i guess it should yea
00:26:34 <Cale> http://imgur.com/BLA6
00:26:50 <maxote> so Architecture.PowerPC.Altivec ?
00:26:57 <pumpkin_> seems reasonable
00:27:08 <pumpkin_> although they like to capitalize the V
00:27:11 <maxote> so Architecture.PowerPC.SPU ?
00:27:25 <erikc> spu isnt powerpc
00:27:36 <erikc> altivec made it into the power specification a few years ago
00:27:38 <pumpkin_> http://www-01.ibm.com/chips/techlib/techlib.nsf/techdocs/76CA6C7304210F3987257060006F2C44/$file/SPU_ISA_v1.2_27Jan2007_pub.pdf
00:28:21 <pumpkin_> as much as I like high-level programming, looking through an instruction set reference makes me feel in touch with my computer somehow :P
00:28:34 <pumpkin_> it helps if it's the same architecture as the computer though
00:28:40 * pumpkin_ closes the SPU reference
00:30:40 <beginner> hey guys
00:30:55 <beginner> can i get some help?
00:30:59 <pumpkin_> sure thing
00:31:07 <pumpkin_> well, we'll know better once you ask the question :)
00:31:16 <beginner> Num a => (a, a) -> (a, a) -> Double
00:31:25 <Gracenotes> indeed
00:31:26 <beginner> how am i supposed to convert it?
00:31:29 <beginner> :)
00:31:39 <Gracenotes> what does it do? :)
00:31:49 <beginner> distance :: Num a => (a, a) -> (a, a) -> Double
00:31:51 <pumpkin_> beginner: distance between points?
00:31:53 <pumpkin_> aha!
00:31:55 <beginner> yes
00:31:58 * pumpkin_ is the prophet!
00:32:32 <beginner> i am searching for hours now the way to convert Num to double
00:32:40 <Gracenotes> er
00:32:42 <beginner> but as you can see i am really new to this :(
00:32:58 <pumpkin_> @hoogle (Num a) => a -> Double
00:32:59 <lambdabot> Prelude abs :: Num a => a -> a
00:32:59 <lambdabot> Prelude negate :: Num a => a -> a
00:32:59 <lambdabot> Prelude signum :: Num a => a -> a
00:33:04 <Gracenotes> well, not every Num can be converted to a double
00:33:07 <pumpkin_> shame on you, hoogle
00:33:22 <Gracenotes> @type 0 :+ 3
00:33:23 <lambdabot> forall t. (RealFloat t) => Complex t
00:33:36 <beginner> sec i try
00:33:36 <Gracenotes> that's a complex number, but it can't be easily converted to a Double
00:33:38 <pumpkin_> but the distance between two complexes is still real
00:33:48 <Gracenotes> it is, but it's a different algorithm :)
00:34:03 <int-e> @type realToFrac
00:34:04 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
00:34:22 <Gracenotes> in Haskell, anyway; one uses the constructor (:+), the other one uses the constructor (,)
00:35:22 <beginner> erm
00:35:25 <pumpkin_> is there a standard pretty printing framework?
00:35:32 <beginner> i am lost allready
00:35:45 <Baughn> pumpkin_: Well, Text.PrettyPrint?
00:36:12 <pumpkin_> aha
00:36:26 <Gracenotes> beginner: sorry :) The thing is, you can't always convert from any given number to a Double
00:36:36 <beginner> oh
00:36:51 <beginner> so what can i do?
00:37:36 <beginner> i think i was supposed to find an easy answer
00:37:55 <beginner> because this is our 2nd homework after 3 haskell classes
00:37:59 <Baughn> Hm. Considering that the distance between two N-dimensional points is /always/ real.. what sort of math do you get by assuming it isn't?
00:38:40 <beginner> i know it is allways real
00:38:52 <pumpkin_> something without an inner product?
00:38:53 <beginner> but simply when i used the
00:38:59 <Gracenotes> Baughn: it is real, but what's considered a Num for Complex is two components, whereas two components of an Int form two Nums
00:39:37 <Gracenotes> anyway, the typeclass Real might be useful to you. (The haskell numerical typeclasses are a bit complicated)
00:39:39 <Gracenotes> @src Real
00:39:40 <lambdabot> class  (Num a, Ord a) => Real a  where
00:39:40 <lambdabot>     toRational      ::  a -> Rational
00:39:54 <Gracenotes> @instances Real
00:39:54 <lambdabot> Double, Float, Int, Integer
00:40:10 <Gracenotes> hopefully that's all the types you need to use in this case :)
00:40:28 <Baughn> Gracenotes: I was thinking more along the lines of weird math than haskell. Guess I'll ask in #math, though. :P
00:40:47 <Gracenotes> Baughn: oh, oops, I meant that at beginner
00:41:12 <beginner> ty for your help
00:41:15 <Gracenotes> so what toRational does is convert a Double, Float, Int, or Integer to a rational number. Then, to convert back, use this:
00:41:18 <Gracenotes> @src fromRational
00:41:18 <lambdabot> Source not found. My mind is going. I can feel it.
00:41:23 <Gracenotes> @type fromRational
00:41:23 <lambdabot> forall a. (Fractional a) => Rational -> a
00:41:40 <Gracenotes> which can convert a Rational into a Double
00:41:44 <Gracenotes> @instances Fractional
00:41:45 <lambdabot> Double, Float
00:41:54 <Gracenotes> oh god. My mind is going too. Sleeeeep
00:42:51 <pumpkin_> onoes
00:43:08 <beginner> : ))))
00:46:40 <beginner> so if i want to change one of the input to rational i use
00:46:43 <beginner> fromRational x
00:47:09 <beginner> then i convert to double with Fractional x?
00:48:20 <beginner> sorry for being dumb :(
00:49:41 <pumpkin_> I'd avoid rational
00:50:01 <beginner> is there any easy way then?
00:51:22 <maxote> can Haskell generate SSE instructions?
00:51:35 <pumpkin_> that's more of a per-compiler question, but yes
00:51:39 <pumpkin_> GHC can
00:51:54 <Gracenotes> pumpkin_: avoiding rational?
00:52:44 <beginner> Fractional (fromRational x) <- this should work for me?
00:52:48 <pumpkin_> I thought he was going to use Rational as the types of his pairs
00:53:01 <beginner> do i need to import something to make it work?
00:53:41 <Gracenotes> beginner: Fractional is a typeclass... are you familiarish with those?
00:53:50 <beginner> no
00:53:56 <beginner> i am really new to all of this
00:54:35 <beginner> well i have some exp with other languages
00:55:18 <Gracenotes> types can be instances of typeclasses -- that's the relationship
00:55:41 <Gracenotes> so a Fractional isn't a type in itself, but a Double is an instance of a Fractional
00:55:55 <beginner> yes
00:56:11 <Gracenotes> all that you have to do to make your type an instance for a typeclass is implement some functions
00:56:21 <Gracenotes> @src Fractional
00:56:21 <lambdabot> class  (Num a) => Fractional a  where
00:56:21 <lambdabot>     (/)             :: a -> a -> a
00:56:21 <lambdabot>     recip           :: a -> a
00:56:21 <lambdabot>     fromRational    :: Rational -> a
00:56:33 <Gracenotes> @instances Fractional
00:56:33 <lambdabot> Double, Float
00:57:06 <Gracenotes> so if 490.32 is a Double or a Float, you can divide it, or take the reciprocal, or convert a Rational to it
00:57:27 <beginner> so if i simply use fromRational would to the trick for me
00:57:32 <Gracenotes> hm. Well, the last method is kinda special. Since a Double is a Fractional, it can be Rational -> Double
00:57:43 <Gracenotes> replacing the a's with Double
00:57:52 <Gracenotes> @go gentle haskell typeclass
00:57:54 <lambdabot> http://www.haskell.org/tutorial/classes.html
00:57:54 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
00:57:59 <Gracenotes> ^ out little tutorial on them
00:58:01 <Gracenotes> *our
00:58:28 <Gracenotes> now, there's another typeclass called real
00:58:32 <Gracenotes> @src Real
00:58:32 <lambdabot> class  (Num a, Ord a) => Real a  where
00:58:32 <lambdabot>     toRational      ::  a -> Rational
00:58:51 <Gracenotes> that just allows you to convert Ints, Floats, Doubles, etc. into Rationals.
00:59:05 <Gracenotes> so Rational is the intermediate type you use to convert to a Double
00:59:22 <Gracenotes> the neat thing about typeclasses is that you don't have to specify whether something is an Int, Float, Double, or Integer
00:59:34 <Gracenotes> just say it's a Real, and you can use toRational with it
00:59:51 <Gracenotes> so, distance :: Real a => (a, a) -> (a, a) -> Double. This method can work
01:00:07 <beginner> ty very much
01:00:14 <Gracenotes> I'm not sure if it's what your constructor is looking for, but as far as I know it can't be defined for any Num
01:00:16 <beginner> but i cant change that part of the code
01:00:19 <Gracenotes> *instructor. Jeez.
01:00:45 <pumpkin_> > abs (1 :+ 1)
01:00:47 <lambdabot>   1.4142135623730951 :+ 0.0
01:00:55 <beginner> moment
01:01:13 <pumpkin_> given that, it should be possible to define distance :: (Num a) => (a, a) -> (a, a) -> A
01:01:18 <pumpkin_> -> a
01:02:10 <Gracenotes> Well. Double is a specific-y type
01:03:09 <Gracenotes> pumpkin_: am I being somewhat crazy, or don't you need to do something Pythagorean to get the distance between two arbitrary points?
01:03:17 <pumpkin_> it would've been nice if they had made abs :: (Num a, RealFloat b) => a -> b
01:03:25 <Gracenotes> brain fried. fryyyyy
01:03:55 <pumpkin_> yeah, you do
01:04:27 <Gracenotes> for which sqrt would be a good idea
01:04:40 <beginner> Inferred type is not general enough
01:05:35 <beginner> Gracenotes pumpkin_ ty very much for your help
01:05:56 <pumpkin_> Gracenotes: but it works with complex numbers too
01:06:08 <pumpkin_> you just get a complex out of it
01:06:10 <Gracenotes> well, if you have a RealFloat
01:06:12 <pumpkin_> because abs is wrong
01:06:16 <beginner> i will ask my teacher for the easiest
01:06:26 <beginner> have a nice day ;)
01:06:50 <Gracenotes> beginner: sure :) the Haskell Gentle Introduction has a section of numbers, by the way
01:06:59 <beginner> (i can post the answer they were looking for if you are interested)
01:07:02 <Gracenotes> and most other parts of Haskell
01:07:12 <Gracenotes> beginner: sure, I'd be curious
01:07:26 <beginner> then i will
01:07:28 <beginner> cu soon
01:07:39 * Gracenotes waves
01:11:14 <ImInYourMonad> [1 of 7] Compiling Actor.Timeout    ( Actor\Timeout.hs, dist\build\Actor\Timeout
01:11:15 <ImInYourMonad> .o )
01:11:15 <ImInYourMonad> Actor\Timeout.hs:16:35:
01:11:15 <ImInYourMonad>     Not in scope: data constructor `AsyncException'
01:11:22 <ImInYourMonad> configure worked
01:11:33 <Gracenotes> :o
01:11:36 <ImInYourMonad> but when building ^^
01:11:45 <Gracenotes> o:
01:12:02 <ImInYourMonad> : o os
01:12:15 <ImInYourMonad> reverse $ o : os
01:12:32 <Gracenotes> @quote 0.0
01:12:32 <lambdabot> roconnor says: life lesson from today: 1 closure is nice, 500 000 closures sucks
01:12:38 <Gracenotes> @quote 0.0
01:12:38 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
01:12:51 <Gracenotes> @quote o_o
01:12:51 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
01:13:03 <Gracenotes> :)
01:13:50 <ImInYourMonad> shuffle :: (RandomGen g, MonadState g m) => [a] -> m [a] ; *Shuffle> shuffle [1,2,3]
01:13:51 <ImInYourMonad> <interactive>:1:0:
01:13:51 <ImInYourMonad>     Ambiguous type variable `g' in the constraint:
01:13:51 <ImInYourMonad>       `RandomGen g'
01:14:02 <ImInYourMonad> but i only have to pass shuffle [1,2,3] right?
01:14:59 <ImInYourMonad> whya re you quoting sutff implying ima moron
01:15:20 <Gracenotes> try execState (shuffle [1,2,3]) (mkStdGen 42)
01:16:23 <Gracenotes> does it work ImInYourMonad :X
01:16:38 <mjrosenb> the issue is that they type of number that the generator generates is not determined by anything
01:16:58 <pumpkin_> ImInYourMonad: the quotes are pulled randomly :) so if anything lambdabot is implying that :)
01:17:01 <mjrosenb> you need to convince it to have a single type
01:17:41 <mjrosenb> anyone know of a binary tarball of ghc for either ppc or ppc64?
01:18:02 <pumpkin_> linux?
01:18:15 <Gracenotes> I wuv lamp
01:18:40 <Gracenotes> haskell is my lamp sometimes. Is it late or what.
01:19:04 <mjrosenb> yes
01:19:07 <mjrosenb> err
01:19:08 <mjrosenb> pumpkin_: yes
01:19:16 <pumpkin_> nope :/
01:19:26 <mjrosenb> there are osx binaries on the website
01:19:50 <pumpkin_> now you just need an osx emulator :P
01:20:48 <mjrosenb> indeed.
01:30:30 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1980#a1980 <- i got thsat from someone yesterday.
01:30:48 <ImInYourMonad> how do i use it?
01:31:55 <blackh> ImInYourMonad: What are you wanting to do?
01:35:34 <ImInYourMonad> shuffle a list, shuffle [1,2,3,4,5] -> [2,3,5,1,4]
01:36:18 * Workybob would suggest shuffle (some random generator) [1,2,3,4,5] -> [2,3,5,1,4] instead
01:36:27 <Workybob> rather than making the output have to live in a monad
01:37:35 <blackh> If you want to keep generating random numbers, you'll need to pass your random number generator round the program...
01:37:45 <blackh> The code you've been given takes the approach of using a state monad to do that for you.
01:37:56 <Workybob> true
01:38:02 <blackh> So, the code to use this would be something like...
01:38:29 <Workybob> but I find passing the state monad everywhere to be equally objectionable to passing a random generator to functions that really can be random
01:38:35 <Workybob> if not more so
01:39:34 <blackh> g <- getStdGen; flip evalState g $ do {x <- shuffle [1,2,3,4,5] ; ... }
01:39:59 <dancor> Control.Monad.Random and monad transformers ftw
01:40:03 <blackh> I'm squishing this all onto one line... replace ; with newline
01:40:12 * Workybob finds do {g <- getStdGen; return $ pureStuff g} much much nicer
01:41:15 <blackh> ImInYourMonad: Personally I don't think there's anything wrong with this approach, so go ahead and play with it and draw your own conclusion.
01:42:08 <blackh> ImInYourMonad: An alternative to evalState is evalStateT if you want to interleave your random code with I/O code.
01:42:09 <ImInYourMonad> Parsec is an industrial strength; really? industrial strength?
01:42:12 <Workybob> ImInYourMonad: blackh is right – play around and make your own decission – personally, I use functional programming because not doing thing statefully has significant advantages, so I don't tend to use the state monad as most of the advantages are lost
01:42:23 <pumpkin_> ImInYourMonad: I hate that expression
01:42:31 <Workybob> ditto
01:42:38 <pumpkin_> and have commented on parsec's use of it before :P
01:42:40 <Workybob> it means nothing
01:42:55 <ImInYourMonad> i have heard very split opnions about Parsec
01:42:56 <pumpkin_> at best, it means well tested
01:43:00 <Workybob> it means "insert gratuitous unrefutable claim here"
01:43:01 <pumpkin_> at worse, nothing
01:43:05 <blackh> I quite like state monads, but I tend to use them for very short periods.
01:43:31 <Workybob> ImInYourMonad: my experience of it is that it's nice to use... but results in slow parsers
01:43:41 <Workybob> it's especially nice if you use the applicative interface, not the monadic one
01:43:44 <ImInYourMonad> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.1/doc/html/Control-Monad-Random.html <- better?
01:45:39 <blackh> ImInYourMonad: I haven't used this monad but by the look of it it does the same job as the state monad, but is specific to managing random number generator state.
01:45:59 <psygnisfive> ImInYourMonad: I put a monad in your monad so you can be pure while you be pure
01:47:59 <psygnisfive> and i suppose thats actually literally true...
01:48:17 <pumpkin_> if you put a monad in my monad, I'm tempted to join it
01:48:34 <ski_> MonadMonad ftw !
01:48:42 <psygnisfive> Nomads!
01:48:50 * psygnisfive clears throat
01:48:55 <psygnisfive> goodness, i turned into ehird for a moment there
01:48:58 <psygnisfive> terribly sorry
01:49:04 <pumpkin_> ?
01:49:11 <psygnisfive> from #esoteric
01:49:16 <pumpkin_> he hangs out in here too :)
01:49:18 <psygnisfive> monads and nomads are a special thing for him
01:49:25 <Workybob> instance Monad a => (Monad (Monad a)) where {return = join; join = }?
01:49:29 <Baughn> > join [[1,2],[3,4,5]]
01:49:30 <lambdabot>   [1,2,3,4,5]
01:49:39 <ski_>   return :: Monad m => m a -> t m a
01:49:41 <ski_>   (>>=) :: (Monad m,Monad n) => t m a -> (forall a. m a -> t n a) -> t n a
01:49:58 <psygnisfive> > join [[1,2],[3,[4,5],6]]
01:49:59 <lambdabot>       No instance for (Num [t])
01:49:59 <lambdabot>        arising from the literal `1' at <inter...
01:50:05 <psygnisfive> oh haha
01:50:06 <psygnisfive> right
01:50:09 <psygnisfive> pure lists
01:50:11 <psygnisfive> lulz
01:50:13 <pumpkin_> homogeneous
01:50:35 <psygnisfive> well that certainly has its benefits
01:50:44 <psygnisfive> in simplifying things at least
01:52:41 <Baughn> > fix (join :: [[a]] -> [a])
01:52:42 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
01:52:42 <lambdabot>        Expect...
01:55:13 <Baughn> Expect? Expect /what/? The legions of hell to ride through a portal and make me pay for my insolence?
02:00:15 <Baughn> > fix id
02:00:17 <lambdabot>   * Exception: stack overflow
02:01:00 <opqdonut> Expect stack overflow
02:01:20 <ski_> > fix (In . join . map out . out)
02:01:21 <lambdabot>       No instance for (Show (Mu []))
02:01:21 <lambdabot>        arising from a use of `show' at <...
02:01:30 <opqdonut> ^_^
02:01:46 <ski_> (i'd feed that into lunabot, if i knew if/where `Mu' lived there)
02:02:38 <Baughn> > fix (/2)
02:02:53 <lambdabot>   thread killed
02:03:48 <ski_> > fix (*0)
02:04:00 <Baughn> > fix fix
02:04:01 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
02:04:01 <lambdabot>      Proba...
02:04:03 <lambdabot>   thread killed
02:04:12 <ski_> > fix (const fix) (1:)
02:04:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:05:42 <osfameron> @index fix
02:05:43 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
02:06:02 <osfameron> why's fix in Control.Monad ?
02:07:29 <int-e> osfameron: you can also import it from Data.Function (since base 3.0 I think)
02:08:32 <osfameron> ah
02:08:46 <int-e> osfameron: As for why it's in Control.Monad, I don't know; I assume it has something to do with mfix being there.
02:10:01 <int-e> well, Control.Monad.Fix really.
02:11:23 <osfameron> yeah, I mean in that hierarchy I guess
02:15:07 <ski_> "A programming language is not a spoken language."
02:15:12 <ski_> discuss
02:15:15 <pumpkin_> orly?
02:15:35 <pumpkin_> (that's my valuable contribution for the day)
02:22:36 * wli devises a relatively similar IR of observable type.
02:23:20 <wli> I have no idea how to really design IR's.
02:24:42 <raxas_> ski_: english is actually just a tiny subset of prolog http://www.nyu.edu/pages/linguistics/anlcbk.html
02:25:47 <Philonous> Is it generally recommendable to use ADTs rather than Synonyms for (nested) tuples?
02:26:14 <ImInYourMonad> who is ehird? is he only 13? and hacking haskell?
02:26:33 <ImInYourMonad> what time complexity deos genAllPermutations xs have?
02:26:46 <lilac> ski_: when communicating with others, being able to speak source code would be very handy
02:27:10 <lilac> hence being a spoken language is a desirable feature
02:27:30 <pumpkin_> ImInYourMonad: I don't think he's 13
02:27:44 <pumpkin_> ImInYourMonad: hang around in here for a while and I'm sure you'll meet him
02:27:55 <ImInYourMonad> someone said: "hes 13 and knows more about computer sciecne than you(not refrring to me but somen else)"
02:28:38 <ski_> (fyi, the aforementioned quote comes from the allmighty WP)
02:28:43 <ImInYourMonad> anyway, i want to shuffle my mp3 playlist. i will do it in main i guess so monad this that isnt so bad. i pass in a seed and do soemthing with it...
02:29:35 <pumpkin_> he doesn't sound 13
02:29:57 <ImInYourMonad> im 8
02:30:15 <ImInYourMonad> ^2
02:30:23 <pumpkin_> *2
02:30:33 <ImInYourMonad> div 4
02:30:37 <ImInYourMonad> div x 4
02:33:16 <wli> aI have this vague idea that nodes in expression dags/graphs correspond to register names in infinite register set IR's.
02:34:56 <Cthulhon> FWIW, ehird claimed to be 10 when I knew him 3 years ago.
02:35:03 <wli> You get something like repeated use of the register names from things like let expressions.
02:35:18 <Cthulhon> But he lied about his age before that.
02:36:23 <wli> let i = 1 in i + i gets labeled as register 1 for the whole expression, 2 for i, and you do add $1, $2, $2 to connect the dots.
02:37:38 <wli> One could use a syntax like $2 <- #1 ; $1 <- add $2, $2 I guess.
02:38:31 <wli> That makes the dependencies clearer for multiple returns like ($1, $2) <- div $3, $4
02:39:53 <wli> I'm not really sure how the quotient and remainder of div are connected with the divisor and dividend in any graph representation, though.
02:40:53 <wli> Or even add, for that matter; what I want to be an edge in $1 <- add $2, $3 has two sources.
02:43:46 <wli> It's like the single source, single destination edges in graphs are inadequate, and you need analogues of edges with multiple sources and destinations.
02:45:18 <wli> And for that matter, the different sources and destinations in the connecting elements need to be positionally distinguishable.
02:45:59 <ski_> "positionally distinguishable" ?
02:46:27 <wli> Say that these generalized edges are called "connecting elements."
02:47:47 <wli> The connecting elements will have inbound and outbound connections to actual ground elements, and say that inbound element 1 is a dividend, inbound element 2 a divisor, outbound element 1 is a quotient, and outbound element 2 is a remainder.
02:49:28 <wli> It's kind of like a graph with two classes of vertices in some respects, where vertices of class 1 are data, and vertices of class 2 are operations.
02:52:52 <ski_> by "positionally distinguishable" you mean that you don't have a *set/bag* of inbound (respectively. outbound) connections of a "multi-edge", but rather a list of them (or labelled) ?
02:53:11 <wli> The difference being that even such a graph with two classes of vertices doesn't have the distinctions between the different inbound and outbound edges.
02:53:20 <wli> ski: yes, they're labelled.
02:53:55 <wli> A graph with two classes of vertices and labelled edges can represent it.
02:54:09 <ski_> hm
02:54:51 <ski_> a normal directed graph (with possibly multiple edges between two nodes, and possibly self-edges) can be represented by
02:55:00 <ski_> type Node
02:55:02 <ski_> type Edge
02:55:10 <ski_> source :: Edge -> Node
02:55:15 <ski_> target :: Edge -> Node
02:55:47 <ski_> can you figure out any similar way of representing your graphs with "multi-edges" ?
02:56:01 <ben_h> hi folks
02:56:34 <ben_h> i've got a question about pattern matching re this example: http://learnyouahaskell.com/recursion#maximum-awesome
02:57:06 <ben_h> i understand the process, but in the recursive case -- maximum' (x:xs) -- how does it know to split a list into head and tail with x:xs?
02:57:17 <wli> data MultiEdge = MultiEdge { inputs, outputs :: [(Node, Label)] }
02:57:21 <ben_h> i.e. the first element seems to automatically be a instead of [a]
02:57:33 <wli> Not good enough
02:57:35 <ski_> > 4 : [2,8,5,7,1]
02:57:36 <lambdabot>   [4,2,8,5,7,1]
02:57:42 <wli> data MultiEdge = MultiEdge { inputs, outputs :: [(Node, Label)], label :: Label }
02:57:49 <ski_> ben_h : because that's that `:' does
02:57:52 <ben_h> ski_: aah
02:58:07 <wli> ski: I think that will do it.
02:58:11 <ben_h> is that called the 'cons' operator?
02:58:15 <ski_> yes
02:58:30 <ski_> @type (:)
02:58:31 <lambdabot> forall a. a -> [a] -> [a]
02:58:49 <ben_h> but in this case it seems to apply in reverse
02:59:27 <ski_> yes
02:59:37 <ski_> because `:' is a (data) *constructor*
02:59:53 <ski_> data constructors can be run "backwards", by pattern-matching
03:00:02 <ski_> `[]' is also a constructor
03:00:05 <ben_h> god that's awesome
03:00:11 <ski_> as is `False',`True'
03:00:18 <ski_> @src not
03:00:19 <lambdabot> not True   =  False
03:00:19 <lambdabot> not False  =  True
03:00:23 <ski_> @src (&&)
03:00:23 <lambdabot> True  && x = x
03:00:23 <lambdabot> False && _ = False
03:00:33 <HugoDaniel> the record syntax is not very elegant to handle :/
03:01:02 <wli> Record syntax is okay except for record updates.
03:01:39 <ski_> wli : hm .. i'm wondering if you just want to describe any graphs with multi-edges (labelled, as you say) .. or whether you want to described *kinds* of multi-edges, too ?
03:02:05 <wli> ski: Kinds of multi-edges are there, too.
03:02:43 <ben_h> so (x:xs) in that case says "set x and xs to what they would have had to be to assemble the input"
03:02:44 <ben_h> ?
03:03:10 <ben_h> ski_: can any reversible operator be considered a constructor?
03:03:24 <ski_> i.e. do you want to describe the concept of a "divMod" edge, as independent of / opposed to any incarnations of it in a particular (multi-edge) graph ?
03:03:39 <wli> ski: For instance, multiplication with overflow wants a "low word" for the part of the product that fits in a word, and a "high word" for the part that overflows. e.g. if you have two 32-bit numbers, the product is in theory a 64-bit number where you stuff the low 32 bits in one register and the high 32 bits in another.
03:04:15 <ski_> ben_h : only ones that have been defined to be (data) constructors in the type definition. (but see views and view patterns and transformational patterns)
03:04:17 <Alpounet> Hi all
03:04:18 <wli> ski: I have no idea what you just said in the "do you want to describe..." line.
03:04:36 <ben_h> ok ski_ i'll check them out
03:04:41 <ben_h> thanks mate
03:04:52 <ben_h> this language is :O awesome
03:04:58 <Alpounet> I'm under linux and have installed the libghc6-network module.
03:05:12 <ski_> even though `not' is invertibe in some sense, you cannot define
03:05:13 <Alpounet> Can I now just import it in some Haskell code and use its functions ?
03:05:23 <ivanm> yes
03:05:34 <ivanm> (assuming your distro does things properly)
03:05:40 <ski_>   my_not (not x) = x
03:05:47 <Alpounet> Debian :)
03:06:02 <ivanm> yeah, guessed it was something like that with that mangled package name ;-)
03:06:04 <Alpounet> Ok great, thanks.
03:06:38 <ski_> , let my_not (not -> x) = x in (my_not False,my_not True)
03:06:39 <lunabot>  (True,False)
03:07:05 <ski_> (beware that this example sporting view patterns isn't running `not' backwards, though .. it's running it forwards)
03:07:32 <wli> Well, my thought here is splattering an expression dag into a graph-like object that can then be linearized by enumerating things in topologically sorted order.
03:08:19 <wli> There is trouble in representing various things at various phases.
03:09:29 <wli> I also have no idea if it's even possible to topologically sort these graphs with "multi-edges."
03:10:39 <ski_> wli : well, your `MultiEdge' allows me creating `MultiEdge {label = "mult_overflow",inputs = [(node0,"divisor"),(node1,"radicand"),(node2,"exponent")],outputs = []}'
03:10:40 <wli> Well, okay, an ordering is induced from the directions of the connections.
03:11:03 <ski_> (assuming `Labal = String' for the sake of example)
03:11:17 <wli> No, it goes like this
03:12:21 <wli> MultiEdge { label = "div", inputs = [(node0, "divisor"), (node1, "dividend")], outputs = [(node2, "quotient"), (node3, "remainder")] }
03:12:39 <ski_> yes
03:12:49 <ski_> but i *can* create the above nonsense, still
03:13:11 <wli> ski: There's a substantial lack of static checking.
03:13:34 <ski_> right. i was merely wondering if there was some way of improving this
03:14:15 <ski_> (that's why i asked about "*kinds* of multi-edges")
03:14:41 <wli> Hardwiring the multi-edges as a coproduct of products and distinguishing inbound and outbound edges by the components of the products.
03:16:11 <ski_> (hm "coproduct of products" ?)
03:16:14 <wli> There's a point to the multi-edge POV, which is to view the problem at a higher level of generality, e.g. more abstract than a concrete operation set.
03:16:51 <ImInYourMonad> so what is the easiest way to shuffle/scramble a list?
03:17:08 <wli> ski: data X = X1 T1_1 T1_2 ... T1_N | X2 T2_1 ... T2_n | X3 T3_1 ...
03:17:14 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1980 <- how do I actually use that?
03:17:52 <wli> ski: data X = X1 T1_1 T1_2 ... T1_N1 | X2 T2_1 ... T2_N2 | X3 T3_1 ... T3_N3 | ...
03:18:35 <wli> ski: TI_J are positionally distinguished as to whether they're inbound or outbound connections.
03:19:24 <ski_> ImInYourMonad : decide on some `m',`g' satisfying `(RandomGen g, MonadState g m)' ?
03:19:24 <wli> And they're all the same type, anyway, namely whatever your unique vertex labels are.
03:19:29 <ski_> such as `m = State StdGen',`g = StdGen'
03:20:29 <blackh> ImInYourMonad: g <- getStdGen ; flip evalState g $ do ; out <- shuffle [1,2,3,4] ; ...
03:20:46 <ski_> wli : so is an element of `X' a multi-edge ?
03:20:50 <blackh> ImInYourMonad: I think that will work.
03:20:59 <ski_> or representing a kind of multi-edge ?
03:21:18 <blackh> ImInYourMonad: import System.Random and Control.Monad.State
03:21:40 <ski_> > do ; [()]
03:21:41 <lambdabot>   [()]
03:23:42 <wli> ski: Yes.
03:24:05 <ski_> (:
03:24:12 <ski_> which of them ?
03:24:43 <wli> ski: All values of type X represent multi-edges.
03:25:34 <ski_> hm
03:26:48 <wli> You can say that V1 precedes V2 if V2 is reachable from V1 along the directed multi-edges, so you'd order the instructions to assign V1's value before V2's if so.
03:27:20 <ski_>   data MultiEdgeType inputs outputs
03:27:24 <ski_>     where
03:27:44 <ski_>     Div :: MultiEdgeType (Node,Node) (Node,Node)
03:27:46 <ski_>     ...
03:28:23 <wli> Yeah, GADT's could come in handy.
03:28:24 <ski_>   data MultiEdge = forall inputs,outputs. ME (MultiEdgeType inputs outputs) inputs outputs
03:28:34 <ski_> s/,/ /
03:28:54 <NameAlreadyInUse> i know this is pretty OT, but what is the general method of processing a parse tree into a syntax tree?
03:29:06 <ski_> but how to regain the labels ?
03:29:25 <wli> ski: Positional is already good enough there.
03:29:49 <wli> ski: The constructors already serve to label the multi-edges.
03:30:00 <ski_> also, it might be nice to "enforce" use of `Node' in `MultiEdgeType' .. maybe by passing it as a parameter .. but it can still be an index in the GADT ..
03:30:34 <ben_h> heh.. just tried a 'cabal install YamlRefernce' and got about 10k lines of errors from the build
03:30:41 <wli> There might even be a way to do graphs and expressions in the same type.
03:31:20 <ski_> (also, it might be nice to use `MultiEdgeType's with something else instead of `Node's .. e.g. some temporary computation result in some graph algorithm)
03:31:29 <ski_> one could try
03:31:53 <ski_>   data MultiEdgeType node inputs outputs
03:31:56 <ski_>     where
03:32:09 <ski_>     Div :: MultiEdgeType node (Node,Node) (Node,Node)
03:32:18 <ski_> but one could still fix `node' in constructors
03:32:21 <ski_> i'd like to say
03:32:35 <ski_>     Div :: MultiEdgeType (\node -> (Node,Node)) (\node -> (Node,Node))
03:32:40 <ski_> but that's not possible ..
03:32:57 <ski_> er, these should of course have s/Node/node/
03:33:36 <ski_> (so you'd pass in `Node' inside the definition of `MultiEdge')
03:33:53 <wli> I can't figure out how to even say what I want here.
03:34:08 <ski_> "expressions" ?
03:34:51 <ski_> NameAlreadyInUse : often a parse tree is usually more or less a syntax tree, no ?
03:35:41 <wli> No, that's the thing to be taken as input, this graph I'm considering built from that, then a linearized sequence of operations computed from that.
03:36:33 <ski_> ok (i was attempting to query what kind of "expressions" you meant in this context)
03:37:44 <NameAlreadyInUse> ski_ not in my case
03:38:33 <wli> Every time I break down an expression constructor, I generate node names for each of the subtrees in the arguments of the constructor.
03:38:51 <wli> But there's also names bound via let.
03:39:03 <ski_> with possible cycles
03:39:03 <wli> Or maybe even other ways.
03:39:04 <ImInYourMonad> to do proper shuffling, do you need to generate all permutations and then randomly choose one? or can you shuffle without permutations(and still make a proper shuffle)?
03:39:06 <NameAlreadyInUse> ski_ for example, my parser parses lists and constructs something like (List (ListM (ListM (ListM Expr) , Expr) , Expr))
03:39:13 <ImInYourMonad> anyone seen good will hunting, what the hell is that he is foing when he proves the second theorem? it is jsut a bunch of connected lines?
03:39:16 <NameAlreadyInUse> ski_ what'd i'd want is (List Expr Expr Expr)
03:39:37 <ski_> ImInYourMonad : i believe oleg has a some info on shuffling
03:39:54 <wli> ski: I'm not to where there are cycles until let or function bindings are considered.
03:40:22 <ski_> (yes, i was referring to your mentioning of `let')
03:40:33 <ski_> @where oleg
03:40:33 <lambdabot> http://okmij.org/ftp/
03:41:04 <wli> I'm clueless as to what to do when there are cycles in a let expression.
03:41:12 <ski_> NameAlreadyInUse : `List' is a constructor taking three arguments ?
03:41:28 <ski_> why not just create a cyclic graph ?
03:41:48 <ski_> let (x,z) = op (y,z) in y
03:41:52 <wli> ski: It can't be topologically sorted when cyclic.
03:42:11 <ski_> the graph has `x' as "input" node, `y' as "output" node, and `z' as "internal" node
03:42:25 <NameAlreadyInUse> ski_: list is just an expression of a list like (1, 2, ...)
03:42:32 <ski_> ok, right. forgot about the top-sorting
03:42:54 <ski_> `(1,2)' is not a list (in haskell)
03:43:15 <NameAlreadyInUse> i know, but it is in my parser :P
03:43:31 <wli> If I can't topologically sort to get a sequence of pseudo-instructions out of the multiedged graph, what can I do?
03:43:55 <NameAlreadyInUse> the grammar looks something like this: Expr -> num | List; ListM -> Expr | ListM ',' Expr; List -> '(' ListM ')'
03:44:04 <ski_> but presumably `List Expr Expr Expr' is meant as haskell ? (i'm not sure whether it would be a value expression or a type expression)
03:44:35 <NameAlreadyInUse> ski_ i meant "List Expr Expr Expr" as the way it (ideally) would be represented in memory
03:44:47 <ski_> wli : why do you want to top-sort ?
03:45:57 <ski_> NameAlreadyInUse : you could possibly convert into `[Expr]'
03:45:59 <wli> ski: It's needed to know what order to carry out the operations in so that a variable has already been initialized when you use its value elsewhere.
03:46:57 <wli> let x = 1 : x in x OTOH is nasty.
03:46:58 * ski_ imagines a strange VM which has a "fringe" of instructions it considers at any point, and makes local progress for each step
03:47:45 <wli> ski: I don't completely understand that idea.
03:48:09 <ski_> (well, you could construct cyclic values like that .. `let x = 0 * x in x' is more problematic)
03:48:45 <wli> Sure, but let x = 1 : x in x has some sort of resolution since it's usable.
03:49:09 <ski_> (O'Caml (which is a strict language) lets you do `let rec ones = 1 :: ones')
03:50:16 <ski_> (i'm not sure the "fringe of instructions" VM would be what you're after .. it would be a "fringe VM", maybe)
03:50:42 <wli> ski: Well, I'm trying to smoke out how let x = 1 : x in x is represented at all.
03:51:34 <pejo> wli, check http://www.ittc.ku.edu/~andygill/papers/RecBinds.pdf, it describes implementation at the end of the paper.
03:51:50 <ski_> if `x' is represented as a pointer to some storage cell, then you could allow using `x' by storing that pointer somewhere, before `x' is initialized
03:51:56 <pejo> wli, it's just a struct with a next-pointer pointing to itself.
03:52:04 <ski_> as long as you don't follow that pointer before `x' is initialized
03:52:09 <pejo> wli, oh, and the element: '1'.
03:53:06 <ski_> (or you could allow initializing `x' by a value which is not yet fully initialized ..)
03:53:24 <wli> As data it looks like struct list { int val; struct list *next; }; then struct list x = { .val = 1, .next = &x };
03:55:54 <wli> This may not be a very useful example, since it just ends up being static data structures. I may have to go as far as recursive functions.
03:58:27 <wli> I'm nowhere near able to consider any sort of branching or jumps or whatever, never mind functions and especially not recursive functions.
04:01:28 <wli> case statements are probably the first sort of branch to consider.
04:03:29 <ski_> (right, for recursion/loops you need to handle cycles somehow)
04:04:56 <NameAlreadyInUse> does haskell do recursion on the heap?
04:05:17 <NameAlreadyInUse> well, ghc rather
04:16:10 <ImInYourMonad> i found this shuffling algorithm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1984#a1984 that si good right then just randomly choose one
04:18:18 <temoto-wd> How is it possible to dynamically reload config w/o stopping program?
04:18:29 <lilac> ImInYourMonad: doesn't look very good to me
04:18:33 <temoto-wd> I believe xMonad window manager does it.
04:18:48 <lilac> ImInYourMonad: i suspect that's periodic with a very low period
04:18:54 <temoto-wd> It has haskell .hs config.
04:19:04 <lilac> temoto-wd: there's a paper on that somewhere
04:19:24 <temoto-wd> lilac: yeah i mostly hoped for link on that kind of paper :)
04:20:30 <ski_> ImInYourMonad : Provably perfect random shuffling and its pure functional implementations <http://okmij.org/ftp/Haskell/misc.html#perfect-shuffle> is not good enough for you ?
04:20:51 <lilac> @go Don Stewart Dynamic applications from the ground up
04:20:55 <lambdabot> http://portal.acm.org/citation.cfm?id=1088352
04:20:55 <lambdabot> Title: Dynamic applications from the ground up
04:21:36 <lilac> temoto-wd: www.cse.unsw.edu.au/~dons/papers/yi.pdf
04:25:50 <temoto-wd> lilac: thank you so much.
04:29:28 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1984#a1985 <- what does mapM_ do? does it thread osmehting through the computation? because hwn i dont use it nothing happens
04:29:45 <Zao> @src mapM_
04:29:45 <lambdabot> mapM_ f as = sequence_ (map f as)
04:30:08 <Zao> sequence_ runs a list of IO actions in sequence and returns nothing.
04:30:17 <Zao> sequence runs a list of IO actions and returns a list of results.
04:30:41 <Zao> Well, it's generic I guess, so substitute "IO actions" to "monadic actions"
04:31:04 <Gracenotes> it's not terribly useful without side effects, tohugh
04:31:06 <Gracenotes> though
04:31:26 <Gracenotes> sequence_ and mapM_ that is :)
04:31:40 <Zao> You could use it with STM actions inside an atomically block, I reckon.
04:31:44 <ImInYourMonad> oh wait yeah fo it is abd the old one lol
04:37:31 <chessguy_work> @src Maybe >>=
04:37:31 <lambdabot> Source not found. :(
04:37:45 <chessguy_work> @src >>= Maybe
04:37:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:38:30 <doserj> @src Maybe (>>=)
04:38:31 <lambdabot> (Just x) >>= k      = k x
04:38:31 <lambdabot> Nothing  >>= _      = Nothing
04:38:40 <chessguy_work> silly bot
04:39:10 <Gracenotes> @src Maybe (<*>)
04:39:10 <lambdabot> (<*>) = ap
04:39:15 <Gracenotes> :O
04:39:34 <Workybob> wow, that's a nice chunk of indirection
04:41:05 <Alpounet> Hi all
04:41:18 <EvilTerran> Just f <*> Just x = Just (f x); _ <*> _ = Nothing
04:41:28 <blackh> Hi there, Alpounet
04:41:53 <Cheshire> hi
04:41:57 <Alpounet> Is there an easy way to execute a shell command (compilation in my case) and to get back the output of the program (the compiler in my case), if any ?
04:42:28 <EvilTerran> Alpounet, System.Process has that kinda thing
04:42:32 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/popenhs perhaps?
04:42:49 <Alpounet> I tried to redirect the output to a file (mycompiler filetocompile > result.txt), it didn't work
04:42:56 <blackh> Alpounet: If you get stuck, I can give you some code that works.
04:43:13 <Zao> Ah, System.Process.readProcess
04:43:20 <Workybob> Alpounet: that's because the compiler doesn't output on stdout
04:43:23 <Workybob> use the -o flag
04:44:27 <Alpounet> the -o flag is just for giving a name to the generated file... in my case, at least
04:44:46 <Workybob> and that isn't what you want to do?
04:44:50 <Alpounet> System.Process.readProcess should do the job... Just have to figure out how it works.
04:44:54 <chessguy_work> @type const (?f::a -> b)
04:44:54 <lambdabot>     Could not deduce (?f::a -> b) from the context ()
04:44:55 <lambdabot>       arising from a use of implicit parameter `?f'
04:44:55 <lambdabot>                    at <interactive>:1:7-8
04:45:02 <Workybob> oh, sorry, I misread the question
04:45:02 <Workybob> sorry
04:45:09 <chessguy_work> @type const ?f
04:45:10 <lambdabot> forall a b. (?f::a) => b -> a
04:45:11 <Alpounet> Workybob, nope, I want to get the compilation error log, if any
04:45:26 <Workybob> oh, okay then
04:45:32 <Workybob> you need to be careful to read its stderr then
04:45:34 <chessguy_work> @type const
04:45:35 <lambdabot> forall a b. a -> b -> a
04:45:50 <ski_> @type const id
04:45:51 <lambdabot> forall a b. b -> a -> a
04:46:01 <ski_> @type const const
04:46:02 <lambdabot> forall a b b1. b1 -> a -> b -> a
04:46:03 <Alpounet> blackh, your code makes use of readProcess ?
04:47:25 <blackh> Alpounet: I have just dug it up. Be warned - this is the second Haskell program I ever wrote, but it does work...
04:48:13 <blackh> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=1689#a1689
04:49:16 <Alpounet> No problem, I'm not gonna copy/paste it, it's for figuring out how those things work
04:49:20 <Alpounet> Thanks :)
04:50:10 <ski_> (catching every error/exception isn't really a good thing to do)
04:51:38 <dcoutts> except at the top level
04:56:45 <ImInYourMonad> "ska-p","jam","*** Exception: C:\ghc\ghc-6.10.1\progs\Shuffle\ShuffleTheory.hs:(222,6)-(234,34): Non-exhaustive patterns in function extract_tree
04:56:45 <ImInYourMonad>  <- when im trying to use the perfect shuffle
04:57:37 <dblhelix> hoogle? down or slow?
04:58:51 <ski_> <http://downforeveryoneorjustme.com/q?domain=hoogle.com>
04:59:23 <ski_> (or maybe it should be s/com/org/ .. i forget)
04:59:24 <dblhelix> ski_: cool service, never saw it before
05:00:15 <jeffz`> hoogle lives on haskell.org though
05:00:30 <dblhelix> indeed
05:00:35 <dblhelix> @where hoogle
05:00:35 <lambdabot> http://haskell.org/hoogle
05:00:39 <blackh> ImInYourMonad: Maybe it's not quite perfect. :)
05:00:46 <Zao> Never let mere details like that stop you from being a wanker :)
05:01:01 <jeffz`> dblhelix, sometimes haskell.org doesn't respond to requests, usually recovers after awhile
05:01:01 * ski_ usually harasses lambdabot instead of going through the web site
05:01:23 <dblhelix> that's what she likes best anyway
05:01:48 <dblhelix> "It's not just you! haskell.org looks down from here."
05:02:19 <ski_> @vixen do you like when people harass you?
05:02:20 <lambdabot> sure, i definitely don't hate
05:02:38 <blackh> ImInYourMonad: I can't see that function in the paste of your code that I have here.
05:02:40 <ski_> @botsmack
05:02:40 <lunabot>  :)
05:02:40 <lambdabot> :)
05:03:25 <Axman6> heh
05:03:40 <ski_> (the smack was for not hating it)
05:03:47 <Gracenotes> @botbludgeon
05:03:47 <lunabot>  :)
05:03:47 <lambdabot> Unknown command, try @list
05:04:15 <Gracenotes> Well, lunabot enjoyed it, at least
05:04:35 <ski_> well, lunabot's a lunatic
05:04:51 <p_l> or masochist
05:07:08 <dblhelix> @hoogle (a, b) -> (b, a)
05:07:09 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
05:07:09 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
05:07:09 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
05:07:21 <aleator> http://haskell.pastebin.com/d4f1331d2 <- Hi! Is this doing what I expect it is doing?
05:07:32 <jeltsch> Hello, does anyone know what’s wrong with the Haskell webserver? I cannot contact it at the moment.
05:07:35 <ski_> @type uncurry (flip (,))
05:07:36 <lambdabot> forall b a. (a, b) -> (b, a)
05:07:42 <ski_> @type snd &&& fst
05:07:43 <lambdabot> forall a b. (a, b) -> (b, a)
05:08:14 <EvilTerran> ?type \ ~(x,y) -> (y,x)
05:08:16 <lambdabot> forall t t1. (t, t1) -> (t1, t)
05:08:35 <Axman6> aleator: it's doing what you coded...
05:08:36 <jeffz`> jeltsch, transient failure
05:08:56 <aleator> Axman6: Yeah, did I code what I think I did? Ie. does it work?
05:09:10 <Axman6> i wouldn't know actually
05:09:38 <lilac> aleator: if you think it's going to make you a delicious spaghetti carbonara, then you made a typo
05:10:01 <ski_> (aleator : it might help if you tell us what you expect/think it is doing ..)
05:10:01 <Axman6> unless you're appending to the end of the spaghetti
05:10:49 <lilac> @type demanding
05:10:51 <lambdabot> forall a. a -> Done -> a
05:11:09 <aleator> well, Perhaps strictAppendFile is indeed not self documenting enough.. I want thing that forces input before starting to write it in the file.
05:11:18 <jeltsch> jeffz`: Any idea how long it will take to fix it?
05:11:50 <jeffz`> jeltsch, sometimes it comes back within an hour, it's happened several times before
05:11:55 <lilac> @type seq
05:11:55 <ski_> (lilac : .. you're thinking in lines of `evaluate' ?)
05:11:56 <lambdabot> forall a t. a -> t -> t
05:12:03 <blackh> aleator: I believe it will force the input before starting to write it in the file. I don't know the strictness behaviour of hPutStr and so on, though.
05:12:03 <lilac> demanding == flip seq?
05:12:18 <ski_> type Done = ()
05:12:20 <lilac> @src demanding
05:12:20 <lambdabot> Source not found. You type like i drive.
05:12:25 <ski_> demanding x () = x
05:12:27 <ski_> iirc
05:12:44 <jeffz`> jeltsch: seems to be fine now
05:12:54 <aleator> I was having errors "openFile: resource busy (file is locked)" with ordinary append so..
05:13:04 <lilac> ski_: looks like flip seq
05:13:16 <lilac> (admittedly for a restricted type)
05:13:28 <jeltsch> jeffz`: Thanks.
05:13:33 <blackh> aleator: If you've already opened the file with readFile or similar, then it probably hasn't closed it.
05:13:46 <blackh> aleator: If you want to read from a file, then write back to the same file, readFile breaks everything for you.
05:14:14 <lilac> Hey kids, remember: Lazy IO: Just Say No.
05:14:35 * ski_ ponders lazy output ..
05:14:36 <blackh> aleator: The best way I know to fix this is to read it as a ByteString (using the functions in the ByteString module), then convert it to a string.
05:18:21 <piksi> how should i use algebraic stuff like modulo with lists ?
05:18:22 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1986#a1986 <- maybe im calling it wrong
05:18:55 <aleator> blackh: But I only write. Never read in any way.
05:19:30 <blackh> aleator: Are you writing the same file more than once?
05:19:57 <aleator> blackh: Yes, appendfile is called several times.
05:21:41 <blackh> aleator: The lazy IO concept has some unpleasant side effects, and I think you may be looking at one of them.  I suggest you just use writeFile out of Data.ByteString, but convert your string to a ByteString first with 'pack'.
05:22:39 <blackh> ...well, Data.ByteString.appendFile should do it.  The point is that this function is 100% strict and doesn't do any funny business.
05:29:03 <aleator> blackh: Thanks. Probably better than trying to hax it myself.
05:33:25 <ImInYourMonad> isnt ' used for strict functions? or is it also used for helperfunctions for tailrecursive functions ?
05:34:00 <Cheshire> not tail recursive,  strict functions
05:34:15 <daf> ' is not strictly for strict functions
05:34:24 <Cheshire> heh
05:34:30 <ski_> there's not standard convention, i think
05:34:49 <ski_> i know i've seen/used it for various "variants" before seeing it used for strict variants
05:35:03 <daf> yeah
05:37:05 <bastl> hiho.
05:37:27 <ski_>  loli?
05:37:42 <bastl> Who was it who said first "Haskell is good to formulate DSL (domain specific laguages), e.g. like Haskore for Music
05:37:44 <bastl>  ?
05:38:04 <bastl> can i cite that from somewhere?
05:39:09 <shapr> Hudak has talked about DSLs lots, perhaps he said it?
05:41:45 <Cheshire> @go The Monad and Free Will
05:41:47 <lambdabot> http://www.friesian.com/leibniz.htm
05:41:47 <lambdabot> Title: Gottfried Wilhelm Leibniz
05:42:26 <ski_> @go The Comonad and Cofree will
05:42:27 <lambdabot> No Result Found.
05:42:33 <ski_> ):
05:42:38 <Cheshire> > 4 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 + 4/13 - 4/15 + 4/17 - 4/19 + 4/21 - 4/23 + 4/25
05:42:40 <lambdabot>   3.2184027659273333
05:43:09 <McManiaC> that haskell mode indention for emacs works soooo strange :S
05:43:20 <ski_> (hm .. what's the dual of `will' ?)
05:43:25 <McManiaC> any tips for improving it? :S
05:43:26 * chessguy giggles at ski_
05:43:34 <NameAlreadyInUse> > 4 - 4/3 + 4/5 - 4/7 + 4/9 - 4/11 + 4/13 - 4/15 + 4/17 - 4/19 + 4/21 - 4/23 + 4/25 - 4/27 + 4/29 - 4/31 + 4/33
05:43:36 <lambdabot>   3.200365515409549
05:43:42 <Cheshire> > zipWith (*) [1..] (iterate negate 2)
05:43:43 <lambdabot>   [2,-4,6,-8,10,-12,14,-16,18,-20,22,-24,26,-28,30,-32,34,-36,38,-40,42,-44,4...
05:43:46 <NameAlreadyInUse> not a good way to approximate pi =\
05:45:04 <kapil> these are very slow series. have a look at Pi and the AGM by Borwein and Borwein on better ways
05:45:14 <Cheshire> > (map ((4/) . (+1) . (*2)) . zipWith (*) [0..] . iterate negate) 1
05:45:15 <lambdabot>   [4.0,-4.0,0.8,-0.8,0.4444444444444444,-0.4444444444444444,0.307692307692307...
05:45:42 <ski_> hm .. if `will_x A' means that the agent `x' wills/wants `A', then a dual could maybe be constructed by `not (will_x (not A))'
05:46:02 <NameAlreadyInUse> i never really understood what free will was meant to be anyway
05:46:04 <piksi> could anyone give me hint on how to use lists correctly with algebraic functions like mod in this situation: http://pastebin.com/m1d8e8456 ?
05:46:32 <ski_> to not emphatically want the negation of a proposition .. would that maybe be to `allow' the proposition ?
05:46:33 <byorgey> ski_: perhaps 'may'?
05:46:43 <piksi> my purpose is *only* to add an element to the list if modulo with the whole list equates to True
05:47:05 <piksi> and i'm still a bit confused with the syntax
05:47:12 <byorgey> ski_: oh, you mean in the sense of want, I was thinking in the sense of 'definite future action'
05:47:26 <McManiaC> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1987 << why is the indention of "do" so different each time? :S
05:47:31 <McManiaC> *after
05:47:53 <ski_> (byorgey : yes. `will' as in `free will')
05:48:04 <byorgey> ah, right =)
05:48:48 <chessguy_work> ski_ emotions?
05:49:10 <ski_> (where the `free' obviously means that there's a left adjoint to an underlying functor lurking somewhere)
05:49:40 <Cheshire> a′ ⊂ a ∈ A ⇒ F (a′ ) ⊂ F (a)
05:49:43 <ski_> chessguy_work : um .. where ?
05:49:54 <byorgey> piksi: (a) is a type error, since 'mod' takes a number as its second argument, not a list
05:49:56 <chessguy_work> ski_ as the dual to free will
05:50:12 <byorgey> piksi: (b) looks good.  what is it you're confused about?
05:50:57 <ski_> (byorgey : unless lists are numbers ..)
05:51:18 <byorgey> ski_: hush! ;)
05:51:47 <chessguy_work> hehe
05:51:56 <ski_> the truth (semantics), the whole truth (completeness), and nothing but the truth (soundness)
05:52:04 <piksi> byorgey: well b produces the output i want (checks every number 1..1000 for modulo between 1..20) but it adds an element for each modulo found, and my purpose is to produce an entry to the list *only* if the entry has a modulo of 0 with all the numbers between 1..20 :-)
05:52:12 <Cheshire> lol
05:52:21 <Cheshire> @remember <ski_> the truth (semantics), the whole truth (completeness), and nothing but the truth (soundness)
05:52:21 <lambdabot> I will remember.
05:52:29 <byorgey> piksi: oh, I see
05:52:36 <piksi> byorgey: so in a way, i got the right answer but in a way i did not mean to...
05:52:51 <piksi> byorgey: still learning, change of paradigm is smoking my brains but i like it already :->
05:52:59 <byorgey> piksi: hehe, great =)
05:53:11 <byorgey> piksi: ok, you just need something like  [x | x <- [1..1000], condition ]
05:53:19 <McManiaC> nobody using emacs ??
05:53:26 <byorgey> where 'condition' expresses the condition that the modulo of x with all the numbers from 1..20 gives 0.
05:53:30 <chessguy_work> McManiaC, i use emacs
05:53:31 <ski_> chessguy_work : so you're claiming that not emoting (in some way, maybe positively ?) towards the negation of a proposition would be the same as willing that proposition ?
05:53:32 <byorgey> the question is how to write that condition.
05:53:42 <piksi> byorgey: yep, exactly. formulating the condition part is bothering me.
05:54:00 <byorgey> piksi: the 'all' function might be helpful
05:54:01 <byorgey> @type all
05:54:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:54:04 <chessguy_work> ski_ err, i hadn't actually considered it in technical terms
05:54:16 <byorgey> it takes a predicate, a list, and says whether the predicate holds for every element in the list.
05:54:24 <byorgey> > all even [1..10]
05:54:25 <lambdabot>   False
05:54:30 <byorgey> > all even [2,4,6,22]
05:54:30 <ski_> if we don't do it, who will !?
05:54:31 <lambdabot>   True
05:54:33 <McManiaC> chessguy_work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1987 << how can i get indention to work with the "do" term??
05:55:14 <chessguy_work> sometimes the emacs indenter sucks
05:55:21 <byorgey> piksi: would you like more hints or is that enough to get started?
05:55:52 <chessguy_work> > all even [2,4,..]
05:55:53 <lambdabot>   <no location info>: parse error on input `..'
05:55:57 <chessguy_work> > all even [2,4..]
05:56:06 <byorgey> piksi: note that a 'predicate' is just a function that returns True or False, so you can also write your own with lambda-notation
05:56:13 <lambdabot>   thread killed
05:56:18 <byorgey> > all (\x -> x > 16) [29, 35]
05:56:19 <lambdabot>   True
05:56:43 <chessguy_work> @pl \x -> x > 16
05:56:43 <lambdabot> (> 16)
05:56:47 <piksi> byorgey: the "all" was a function i wasn't aware of and i was trying to construct the condition in some cumbersome traditional way.. i think with that i'll be able to cope now, thanks a lot :-)
05:56:56 <chessguy_work> @src all
05:56:57 <lambdabot> all p =  and . map p
05:57:04 <byorgey> piksi: ok, great =)
05:57:06 <chessguy_work> @src and
05:57:06 <lambdabot> and   =  foldr (&&) True
05:57:07 <McManiaC> so u gotta do it by hand chessguy_work ?
05:57:16 <chessguy_work> McManiaC, quite possibly
05:57:27 <piksi> byorgey: i'm solving the euler project challenges as an introduction to haskell
05:57:44 <byorgey> piksi: there are tons of useful functions like that in the standard Prelude, at some point it may be worth finding a list of them and going through it to see what's in there
05:57:57 <McManiaC> ok =(
05:58:17 <byorgey> piksi: ah, excellent =)
05:58:46 <piksi> byorgey: you're right, i have to take on that challenge next and try to find excercises in which i can apply those functions so that i can learn to use them in practice
05:59:31 <chessguy_work> is there some concept of 'generators' in haskell?
05:59:39 <Cheshire> []
06:00:12 <chessguy_work> like, we should be able to write 'all even foo' for some foo that represents [2,4..] and have it terminate. that would be cool
06:02:42 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1989#a1990 <- why is that?
06:02:49 <ski_> chessguy_work : well, it is possible to do it for predicates over streams
06:03:08 <NameAlreadyInUse> chessguy: lazy lists
06:03:32 <mdmkolbe> Is there a way to make GHC recognize "exists" or "exist" as an alias for "forall" in existential context?
06:04:10 <ski_> ImInYourMonad : probably someone called `extractTree n (Leaf e)' for some `n',`e'
06:04:28 <ski_> mdmkolbe : hopefully not ..
06:04:48 <mdmkolbe> ski_: in an existential context "forall" really means "exists"
06:04:59 <Cheshire> oh what is an existential context ?
06:05:08 <ski_> (i don't believe that) but define "existential context"
06:05:12 <Alpounet> How can I convert an IO String to a String ?
06:05:28 <mdmkolbe> Cheshire: "data X = forall a. Foo a", that is really an existential type
06:05:38 <TomMD> Alpounet: An IO string is just an action that will GET a string
06:05:39 <Cheshire> data Ex t where Witness :: t -> Ex t
06:05:41 <ski_> Alpounet : no. use `do ...; myString <- myIOString; ...' instead
06:05:50 <Cheshire> data Ex' where Witness' :: t -> Ex'
06:05:54 <NameAlreadyInUse> Alpounet: unsafePerformIO, technically
06:06:01 <Alpounet> Ok.
06:06:03 <Alpounet> Thanks.
06:06:04 <Cheshire> mdmkolbe, but is there e.g. a syntactic definition of existential context?
06:06:08 <ski_>   Witness' :: forall t. t -> Ex'
06:06:17 <NameAlreadyInUse> Alpounet: you shouldn't be using it, though
06:06:26 <TomMD> alpounet: So if you are in an IO routine (such as Main) then just call the action to get a string:
06:06:26 <TomMD> a <- getString
06:06:26 <TomMD> There, "getString" is of type IO String while "a" is of type String
06:06:57 <mdmkolbe> Cheshire: yes, if I instead did "data X = Foo (forall a. a)" then that would be a univeral
06:06:59 <ski_> mdmkolbe : `data X = forall a. Foo a' would be equivalent to `data X = Foo (exists a. a)', would the latter be permitted syntax
06:07:02 <ImInYourMonad> is haskell cafe the standard mailing list? what about comp.lang.fa or comp.lang.haskell ?
06:07:18 <TomMD> No, the cafe is the standard ml
06:07:20 <ski_> mdmkolbe : note the different placement of the quantifier word wrt the data constructor. that is *essential*
06:08:12 <Alpounet> TomMD, in fact, I'm doing some File I/O, and then want to give a string back to the calling function
06:08:13 <Cheshire> ski_, exissential
06:08:23 <ski_> hehe
06:08:37 <mdmkolbe> ski_: I understand that.  Are you claiming that "data X = exists a. Foo a" would be wrong?
06:09:19 <ski_> yes, it would be wrong, imo
06:09:48 <ski_> (of course concrete syntax is in some sense not wrong or right, just more or less useful .. i think it is misleading, though)
06:09:59 <mdmkolbe> ski_: (this is all for documentation purposes anyway b/c when my code gets formatted "forall" prints as inverted "A" and it looks really funny to be talking about existential types when there is an inverted "A" sitting there)
06:10:44 <pejo> Alpounet, call that function with the string as parameter from inside your do-block instead.
06:10:53 <lilac> mdmkolbe: if you want an exists, you need to put it somewhere else.
06:11:07 <Alpounet> pejo, I can't.
06:11:13 <Alpounet> :(p
06:11:17 <lilac> mdmkolbe: since "data X = exists a. Foo a" is a universal, not an existential
06:11:21 <TomMD> Alpounet: Perhaps you could paste your code?
06:11:23 <TomMD> @where hpaste
06:11:24 <lambdabot> http://hpaste.org/
06:11:30 <Alpounet> yep
06:11:40 <ski_> mdmkolbe : consider `data Stack a = forall x. S x (a -> x -> x) (x -> Maybe (a,x))
06:11:59 <ski_> mdmkolbe : if you want to use `exists' here, you'd need to tuple the arguments first
06:12:02 <ski_> i.e.
06:12:15 <ski_>  data Stack a = forall x. S (x,a -> x -> x,x -> Maybe (a,x))
06:12:15 <NameAlreadyInUse> Alpounet: what you are trying to do violates referential transparency
06:12:18 <ski_> then you can say
06:12:27 <ski_>  data Stack a = S (exists x. (x,a -> x -> x,x -> Maybe (a,x)))
06:12:39 <Cheshire> what is:   existential context,   exists,   ?
06:12:41 <lilac> mdmkolbe: "data X = exists a. Foo a" means "Foo :: exists a. a -> X" which means "(forall a. a) -> X"
06:13:10 <ski_> so, we only say `data Stack a = forall x. S x (a -> x -> x) (x -> Maybe (a,x))' is an "existential datatype" out of convenience
06:13:12 <Cheshire> data Exists f where Witness :: f a -> Exists f
06:13:14 <Cheshire> there
06:13:18 <Cheshire> data X = Exists Foo
06:13:45 <Cheshire> data Stack a = S (Exists (\x -> a -> x -> x, x -> Maybe (a,x)))
06:13:58 <Cheshire> yuck this (->) notation in the lambda is horrible
06:14:05 <Alpounet> NameAlreadyInUse, in fact, I try to do some IO stuffs, and then get a string as a result
06:14:30 <lilac> mdmkolbe: exists and forall are dual. you can get the same effect as 'exists' by putting 'forall' in a contravariant position
06:14:43 <ski_> for the first `Stack' we get `S :: forall a. forall x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Stack a' (note how the `forall x. ' here corresponds to the one in front of the data constructor in the definition)
06:15:08 <lilac> mdmkolbe: i think it might be nice to have exists as a keyword, but 1) not as a synonym for forall, and 2) it's technically unnecessary
06:15:39 <Cheshire> hm
06:15:40 <NameAlreadyInUse> Alpounet: it doesn't work like that
06:15:41 <ski_> (Cheshire : indeed):
06:15:46 <Cheshire> S (a :: *) :: forall x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> Stack a
06:15:57 <ski_> for lilac's `data X = exists a. Foo a' we would get `Foo :: exists a. a -> Foo' .. which is far from `Foo :: forall a. a -> Foo'
06:16:17 <ski_> (but closer to `Foo :: (forall a. a) -> X')
06:16:25 <ski_> (s/-> Foo/-> X/)
06:16:35 <w0lter> Hey, What 's difference between type [string] and [a] ? Thanks
06:16:53 <lilac> w0lter: with string in lowercase? very little
06:16:59 <ski_> w0lter : `[a]' is the type of lists of elements of type `a' (which might be any type)
06:17:04 <Cheshire> w0lter, did you mean [String]?
06:17:15 <w0lter> sorry, [String]
06:17:16 <ski_> w0lter : `[String]' is the type of lists of elements of type `String' (aka strings)
06:17:55 <ski_> w0lter : if `a' is `String', then the two types are the same .. but `a' could possibly be other types (also/as well/instead)
06:18:19 <w0lter> ski:understand now, thanks
06:19:12 <ski_> in a polymorphic function like `foo :: Int -> [a] -> [a]', one can use this function both when `a' is `String' and when it's another type
06:19:29 <Alpounet> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1993#a1994
06:19:38 <ski_> > (length :: [String] -> Int) ["","a","bc","def"]
06:19:40 <lambdabot>   4
06:19:44 <w0lter> got it
06:19:46 <Cheshire> I don't think datakinds make sense
06:19:51 <ski_> > (length :: [Int] -> Int) [0,1,2,3]
06:19:52 <lambdabot>   4
06:19:54 <Cheshire> was there something like
06:20:10 <Cheshire> datakind N = Z | S N
06:20:32 <Cheshire> type add :: N -> N -> N ; add Z m = m ; add (S n) m = S (add n m) ?
06:22:19 <NameAlreadyInUse> Alpounet: you are not meant to be able to do something like that. what you want to do is write the function for handling the string, and then invoke it in the body of foo
06:22:47 <Alpounet> ok
06:22:49 <ski_> lilac : i've sometimes wanted to use an `exists' in `foo :: Foo a => F a -> exists b. Bar a b *> G a b'
06:23:04 <ski_> lilac : writing in CPS is not always so fun ..
06:23:07 <NameAlreadyInUse> Alpounet: i am sorry if i am not very clear. i am still learning as well :)
06:24:02 <Alpounet> No problem :-)
06:24:13 <ski_> Cheshire : why would they / would they not make sense ?
06:24:17 <Alpounet> I quite understand, it is just tricky to rearrange everything
06:24:33 <ski_> the idea is to use them for indexing other types, yes ?
06:24:40 <Cheshire> yes
06:24:45 <TomMD> Alpounet: Annotated, many times
06:24:46 <ski_> (or use as values, as well ?)
06:25:08 <Alpounet> TomMD ?
06:25:45 <TomMD> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1993#a1994
06:26:00 <TomMD> I annotated it a couple times, but it looks like others laready helped you.
06:27:19 <ski_> hm, if `N :: data*', then one could maybe consider a primitive type constructor `AsValue :: data* -> *' with a primitive construction for wrapping constructors of the former into normal data constructors ..
06:27:34 * ski_ wonders if this would be bad for some universe/size reasons ..
06:28:02 <ski_> (also, `data*' is probably a bad name since it's one the level "above" `*')
06:37:05 <NameAlreadyInUse> why isn't Data.Set a monad?
06:37:20 <Alpounet> Thanks all, after some thoughts, I've understood that I had to give responsibility to foo for some more operations, and now everything is fine
06:37:23 <NameAlreadyInUse> i remember reading that it has something to do with type classes but i forget the specifics
06:37:43 <Alpounet> I'm only doing IO stuffs in foo, and call some functions, it works.
06:38:02 <TomMD> good news, Alpounet
06:40:19 <ziman> NameAlreadyInUse, each monad must be a Functor; a Set cannot be a Functor because it cannot hold functional values, namely, there cannot be an implementation for `fmap (const id)', for example. (there's the Ord constraint on the values a Set can contain and functions aren't comparable)
06:41:15 <idnar> you could define an Ord constraint for functions; the problem is simply that Set has restrictions that are not included in the Functor typeclass
06:41:26 <NameAlreadyInUse> ziman: got it.
06:41:27 <idnar> er, *an Ord instance for functions
06:42:18 <ziman> NameAlreadyInUse, in other (maybe simpler) words, you cannot have `return id' in the Set monad
06:49:05 <LeoD> @hoogle (a -> b -> c) -> (c -> d) -> a -> b -> d
06:49:06 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
06:49:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:49:06 <lambdabot> Data.Generics.Basics gmapQr :: Data a => (r' -> r -> r) -> r -> (a -> r') -> a -> r
06:49:43 <bjorkintosh> does haskell have a win32ole library?
06:50:09 <Zao> There is a COM lib.
06:50:33 <bjorkintosh> what's it called?
06:50:47 <Zao> Can't remember. Search hackage.
06:50:55 <Zao> <cue clever use of lambdabot>
06:51:15 <Zao> "com", unsurprisingly :P
06:51:16 <Zao> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/com
06:51:25 <bjorkintosh> lambdabot, whither the COM library?
06:52:21 <bjorkintosh> how rude. it said nothing!
07:05:23 <shapr> Hm, there's hs-dotnet
07:05:23 <Zao> shapr: I fetched that last night. I'm a bit scared by the  x <- invoke "System.Foo.Bar.Baz" ()
07:05:23 <Zao> Looks horribly inefficient :)
07:05:23 <shapr> Zao: How would you improve it?
07:05:23 <Zao> shapr: The other .NET library "Salsa" seems to have a different approach.
07:05:23 <Zao> Going with something more along the lines of _System # _Foo # _Bar # _Baz  or something.
07:05:23 <shapr> Does that allow more type checking?
07:05:23 <HugoDaniel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1998#a1998
07:05:23 <HugoDaniel> help please
07:05:23 <HugoDaniel> :/
07:05:23 <Zao> I have only given this a cursory glance though, secrets may lie with the mystical "hswrap.exe" that supposedly generates Haskell modules.
07:05:23 <Zao> I believe so, yes.
07:05:23 <shapr> HugoDaniel: How much have you used monad transformers?
07:05:23 <HugoDaniel> shapr: not that much
07:05:23 <HugoDaniel> as you can probably tell
07:05:23 <HugoDaniel> i just thought it would fit nicely here
07:05:23 <paper_cc> what is the type of search?
07:05:23 <paper_cc> HugoDaniel: ^^
07:05:23 <HugoDaniel> paper_cc its there
07:05:23 <paper_cc> oops, sorry =)
07:05:23 <paper_cc> then you probably need lift instead of liftM
07:05:23 <paper_cc> @ty lift
07:05:23 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
07:05:23 <paper_cc> or rather, lift $ search state
07:05:23 <HugoDaniel> yeh
07:05:23 <HugoDaniel> it works
07:05:23 <HugoDaniel> with lift
07:05:24 <HugoDaniel> ouch, i should have been able to catch that one :/
07:05:24 <HugoDaniel> sometimes haskell frustrastes me
07:05:24 <paper_cc> HugoDaniel: also, the last statement of 'do' isn't neccesarily 'return'
07:05:24 <paper_cc> so you can do { state <- get; lift $ search state; } as well
07:05:24 <paper_cc> @ty StateT
07:05:24 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
07:05:24 <shapr> HugoDaniel: Don't worry, it'll get easier.
07:05:24 <HugoDaniel> yes, this is not my final code
07:05:24 <HugoDaniel> paper_cc: im just doing this because now ill need to foo aroudn with the searchdata before im finished :/
07:05:24 <HugoDaniel> thanks for the help :D
07:05:24 <HugoDaniel> i should start reading my wet real world haskell
07:05:24 <paper_cc> HugoDaniel: nevermind =)
07:05:24 <paper_cc> wet?
07:05:51 <paper_cc> @ty \f get >>= lift . f
07:05:53 <lambdabot> parse error on input `>>='
07:06:00 <paper_cc> @ty \f -> get >>= lift . f
07:06:02 <lambdabot> forall a (m :: * -> *) a1 (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t, MonadState a (t m)) => (a -> m a1) -> t m a1
07:06:37 <shapr> HugoDaniel: Your book got wet?
07:06:38 <HugoDaniel> paper_cc: yes, the guys at amazon screw up with the order :P it got here with the pages wet
07:06:41 <shapr> I'm not sure I want to know.
07:06:57 <shapr> HugoDaniel: oi!
07:06:59 <HugoDaniel> they send the book in a package without any accomodation
07:07:05 <shapr> Wow, that sucks.
07:07:10 <HugoDaniel> just a cardbox with the book in it
07:07:14 <HugoDaniel> yeh :/
07:07:23 <shapr> I hope you were able to dry it out.
07:07:37 <HugoDaniel> yes, i did :) but the pages like doubled the size eheh
07:07:54 <HugoDaniel> oh well
07:07:55 <HugoDaniel> back to code
07:07:57 <HugoDaniel> thanks
07:07:57 <paper_cc> "dry out your Real World Haskell. remember, it's the real world =)"
07:08:01 <HugoDaniel> :D
07:08:50 <Zao> The monad space suit containing an ocean with floating apples leaked.
07:09:10 <NameAlreadyInUse> since when did the lambda become a symbol for LGBT rights?
07:09:28 <shapr> NameAlreadyInUse: I think it's been that way for a bunch of years.
07:10:30 <NameAlreadyInUse> shapr: really? go figure. i never knew until i saw it on a wikipedia template
07:10:36 <NameAlreadyInUse> what is it meant to represent?
07:13:39 <shapr> NameAlreadyInUse: No clue, sorry. If you find out, I want to know.
07:13:59 <NameAlreadyInUse> shapr: i found this page: http://www.lambda.org/symbols.htm
07:14:12 <NameAlreadyInUse> "The reasoning was that the lambda would easily be mistaken for a college fraternity symbol and ignored by the majority of the population."
07:14:20 <Cheshire> # Simply, the Greek letter "L" stands for "liberation."
07:15:09 <shapr> Huh, why not go for something that wouldn't be mistaken?
07:15:44 <Cheshire> what is it with these frat guys and their lambda-kappa-delta clubs ?
07:15:53 <Philippa_> because it dates from a time when that was likely to get your head kicked in, AIUI
07:16:28 <Cheshire> you just see in films where they have all these ridiculous initiation rituals
07:16:55 <shapr> Philippa_: How long ago was that?
07:17:16 <NameAlreadyInUse> shapr: 1960's, it seems
07:17:28 <dcoutts> ImInYourMonad: see the gtk2hs tutorial, it has a section on packing and explains the packing parameters
07:17:42 <dcoutts> ImInYourMonad: I also suggest you play around with the glade gtk UI designer
07:17:50 <ImInYourMonad> Im tryong to find out how to prevent buttons from resizing themselves in gtk2hs when you resize the window but cant fidn it, anyone know?
07:18:25 <dcoutts> ImInYourMonad: that will give you some experience of how the packing parameters affect how widgets resize as you resize the top level window
07:18:48 <Philippa_> anyway, it's no big deal and it's far from unknown for queer functional programmers to play with it either
07:21:16 <NameAlreadyInUse> Philippa_: you are right; i am just so used to seeing the lambda in a maths or functional programming context that it seemed an odd choice of symbol for LGBT rights
07:24:13 <defun> :t (=<<)
07:24:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:24:23 <defun> :t (<*>)
07:24:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:24:46 <defun> :t ($)
07:24:47 <lambdabot> forall a b. (a -> b) -> a -> b
07:24:53 <defun> :t (.)
07:24:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:25:55 <HugoDaniel> is there a function that works like zip, but gives me the possible combinations ? like: f [0 .. 10] [0 .. 2] -> [(0,0), (0,1), (0,2), (1,0), (1,1), (1,2), (2,0) ... ?
07:26:29 <Cheshire> liftA2 (,) does that
07:26:44 <gnuvince> HugoDaniel: use a comprehension: [(x, y) | x <- [0..10], y <- [0..2]]
07:26:45 <Draconx|Laptop> > [(x,y) | x <- [0..10], y <- [0..2]]
07:26:47 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(4...
07:26:53 <opqdonut> or liftM2 (,) ;)
07:27:07 <HugoDaniel> oh ok, i keep forgetting that comprehensions exist :D
07:27:10 <HugoDaniel> thanks
07:27:17 <gnuvince> > liftM2 (,) [0..10] [0..2]
07:27:18 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(4...
07:27:25 <gnuvince> opqdonut: you win
07:27:54 <sw17ch> > [Just x | x <- [1..10]]
07:27:55 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
07:28:01 <sw17ch> > map Just [1..10]
07:28:03 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
07:28:10 <edwardk> > (,) <$> [0..2] <*> [1..10]
07:28:12 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,1),(1,2),(...
07:28:20 <pejo> Allocate a list of 10M elements, compare the list to itself with two different functions, and print out the result of the comparison. Suppose that one of the comparison functions allocate 160M more memory (according to +RTS -s). Is there an obvious reason why "time" on these two programs would not show any difference? (Nor did augustss's timeIt package).
07:28:25 <shapr> edwardk: ooh, applicative?
07:28:55 <HugoDaniel> you guys sure know haskell :)
07:29:33 <edwardk> f <$> x <*> y <*> z -- can be used like liftMn and is generally easier on the eyes ;)
07:29:37 <sw17ch> HugoDaniel: actually, i just smash the keys until something comes out that happens to compute what i want :D
07:29:43 <HugoDaniel> :D
07:29:50 <edwardk> yeah, when it type checks i claim my work is done
07:30:03 <opqdonut> edwardk: but that's ugly and pointful
07:30:05 <edwardk> an infinite number of monkeys with a typechecker
07:30:24 <edwardk> opqdonut: guess it depends on the eyes and the goal =)
07:30:31 <opqdonut> ;)
07:36:46 <HugoDaniel> is there any kind of "failure maybe" that allows to return a given error datatype once things go wrong ?
07:36:55 <opqdonut> Either
07:36:58 <opqdonut> ?src Either
07:36:59 <lambdabot> Source not found. Where did you learn to type?
07:36:59 <HugoDaniel> thanks
07:37:18 <opqdonut> it has an appropriate monad instance, too
07:37:42 <ski_>   data Either a b = Left  a
07:37:44 <ski_>                   | Right b
07:37:53 <ski_> opqdonut : *in*appropriate !
07:37:59 <opqdonut> ?src Either (>>=)
07:38:00 <lambdabot> Left  l >>= _ = Left l
07:38:00 <lambdabot> Right r >>= k = k r
07:38:13 <gnuvince> Either is a monad?
07:38:15 <opqdonut> ski_: well appropriate for the error-like usage HugoDaniel wanted
07:38:16 <ski_>   instance Error e => Monad (Either e)
07:38:21 <ImInYourMonad> is this correct? :: if I have 2 ways(2 datastructures) to represent a problem, a Functor is a definition of how to transform one of them to the other without losing information. or perhaps how to traverse them  where traversing A means the same things as traversing B, ie in the same order.
07:38:26 <gnuvince> Does something need to be imported for that to happen?
07:38:27 <ski_> (damn that `Error w' constraint ..)
07:38:34 <opqdonut> yeah it's a bit silly
07:38:37 <Philonous> gnuvince Yes, jus like maybe, but it returns Left l instead of Nothing
07:38:42 <ski_> gnuvince : probably `Control.Monad.Error'
07:39:35 <ski_> opqdonut : i have used `Either' as a monad, where i "failed" with a value of some type including an arbitrary type variable `a'
07:39:49 <ski_> (possibly it was just plain `a', i don't remember)
07:40:28 <ski_> (i think `a' was `Integer' or `Char' in the actual use i had for it)
07:41:44 <opqdonut> mhmm
07:41:55 <ski_> ImInYourMonad : not really .. a `Functor' instance gives a way of executing any function you want on each "element" in a datastructure, where the datastructure type is *parameterized* over the type of the "element"s
07:44:17 <ski_> ImInYourMonad : e.g. for the `[a]' (lists) datatype (whose type parameter `a' represents the type of "element"s), you can convert `[String]' into `[(Integer,Bool)]' provided you have a function of type `String -> (Integer,Bool)' that you want to run on every element
07:45:32 <ski_> similarly, if you define a `Tree a' datatype for some kind of trees, you can convert from `Tree MyFrob' into `Tree MyBlob', by letting `fmap' run your `MyFrob -> MyBlob' function on every element of the tree
07:46:36 <ski_> also, an `IO'-action of type `IO a' may be thought of as having "an element" of type `a', so here `Functor' allows you to run a pure function to transform the `a' into anything you like
07:49:09 <ski_> @type getLine
07:49:10 <lambdabot> IO String
07:49:23 <ski_> @type fmap (read :: String -> Integer) getLine
07:49:25 <lambdabot> IO Integer
07:49:35 <h0tzenpl0tz> cabal.exe(!!) install http -> gcc: installation problem, cannot exec 'as' ? anyone an idea?
07:51:28 <Draconx|Laptop> h0tzenpl0tz, wild guess: your toolchain has an installation problem, and cannot find 'as'.
07:51:42 <h0tzenpl0tz> its windows. is "as" an unix-command?
07:52:13 <ziman> assembler, i guess
07:52:19 <Ferdirand> yes, it's the assembler
07:52:25 <ziman> lrwxrwxrwx 1 root root 20 2008-07-11 10:33 /usr/bin/as -> i686-pc-linux-gnu-as
07:52:32 <ziman> part of the gcc toolchain
07:53:02 <h0tzenpl0tz> gnu c compiler? does cabal.exe (<- win!) need gcc as weel do build hackage-packages?
07:54:37 <maltem> h0tzenpl0tz: Well if there's C code in the package
07:54:51 <h0tzenpl0tz> argh... booting linux-vm .... thanks ;)
07:55:21 <maltem> Er, the need of a C compiler makes you switch OS?
07:56:03 <ziman> there's mingw for gcc on windows
07:56:19 * dcoutts announces The Industrial Haskell Group
07:56:21 <dcoutts> http://industry.haskell.org/
07:56:35 <fasta> maltem: is that so odd? Gcc on Linux is easy, mingw is slow and doesn't work perfectly :)
07:56:56 <fasta> The last time I installed mingw, the installer had two segmentation faults.
07:57:01 <maltem> ok I never used gcc on Windows
07:57:22 <maltem> uh
07:57:25 <fasta> It was a complete nightmare to install it.
07:58:42 <Zao> dcoutts: Well-Typed?
07:58:46 <shapr> dcoutts: awesome!
07:59:00 <jfredett> dcoutts: just read that, looks pretty nifty.
07:59:05 <dcoutts> shapr: yeah :-)
07:59:16 <dcoutts> Zao: that's our Haskell consultancy company.
07:59:52 <Zao> dcoutts: So I deduced from the text, but it's a bit surprising to see the term appear out of nowhere in the middle of the document.
08:04:41 <shapr> dcoutts: One question, who's the third partner?
08:05:20 <dcoutts> shapr: sorry, cannot say.
08:05:25 <shapr> oh
08:05:35 <shapr> I thought maybe it was an error on the page.
08:05:45 <jfredett> shapr: it's Lex Luthor.
08:05:58 <Cheshire> that's what I was thinking too :p
08:06:01 <dcoutts> shapr: you know what companies are like
08:06:19 <shapr> yes I do
08:08:32 <DBAlex> hello
08:09:47 <DBAlex> Hi, I know theres no such thing as "variables" in haskell, but lets say I want to do the following, define a linked list with the function createLinkedList (E.g. myLL = createLinkedList) and now I want to add an entry to the list with addToList and then return this to myLL, isn't this basically impossible in Haskell?
08:10:15 <DBAlex> as in once you've created something you can't change it :/
08:10:16 <Botje> DBAlex: you need to stop thinking imperatively
08:10:22 <Botje> that's the key to getting haskell
08:10:27 <Botje> instead of /altering/ myLL
08:10:29 <DBAlex> Botje: I know but I can't see a way round this example
08:10:33 <Botje> you merely return a new version of myLL
08:10:42 <jfredett> DBAlex: 1 : 2 : 3 : []
08:10:42 <Cheshire> > let list = "foo" ; addition = 'x' in  addition : foo
08:10:43 <lambdabot>   Not in scope: `foo'
08:10:47 <Botje> and you pass that along to where it's needed
08:10:48 <Cheshire> oop
08:10:51 <DBAlex> heh
08:11:21 <Saizan> DBAlex: if you do need mutable cells, you can have them: IORef, but they are rarely needed in idiomatic haskell
08:11:52 <DBAlex> ok
08:11:56 <DBAlex> Hmm
08:12:03 <DBAlex> but still the return will be temporary
08:12:14 <Botje> you don't need to use return in haskell
08:12:19 <DBAlex> when I add something else that will just add a value?
08:12:19 <Botje> at least not for pure functions
08:12:29 <DBAlex> *add at the same position
08:12:38 <DBAlex> it won't append it
08:12:45 * jfredett pokes DBAlex, "Stop thinking in C!"
08:12:46 <Botje> values don't change in haskell, no
08:12:54 <DBAlex> jfredett: lol sorry, its hard ;)
08:13:02 <Botje> all you can do is construct new values out of old ones
08:13:05 <Botje> that's the trick
08:13:16 <DBAlex> but the old values won't be stored?
08:13:18 <jfredett> DBAlex: it's okay, it'll happen all at once, and it'll be _awesome_. :)
08:13:19 <DBAlex> so how can you
08:13:24 <Botje> instead of adding an element to a list, you construct a new list that contains the new element
08:13:39 <DBAlex> Botje: but then where is the new list stored?
08:13:44 <DBAlex> its not
08:13:47 <Botje> don't think about "stored"
08:13:55 <DBAlex> ok
08:13:55 <Botje> think about results and values
08:14:10 <Botje> don't think about function calls, think about consuming and constructing values
08:14:31 <jfredett> DBAlex: Storage is for C programmers, we think about Structure, Patterns, Values. Not bits and bytes and pointers.
08:14:42 <DBAlex> ko
08:14:44 <Cheshire> don't think of a black cat
08:14:44 <DBAlex> *ok
08:14:45 <Cheshire> :p
08:14:54 <fasta> DBAlex: if you want to program with locations, instead of values, use the ST or IO  monad. I don't think you will find it more easy, though.
08:15:05 <Cheshire> > let list = "foo" ; addition = 'x' in  addition : list
08:15:07 <lambdabot>   "xfoo"
08:15:09 <Cheshire> DBAlex, look ^
08:15:12 <Cheshire> push = (:)
08:15:33 <jfredett> pop = head
08:15:41 <jfredett> yes, you can treat a conslist like a stack
08:16:05 <jfredett> or like a linked list, for that matter... head is the head node, tail is the rest of the list.
08:16:07 <h0tzenpl0tz0r> anybody having a working HTTP-Get example?
08:16:14 <jfredett> usually you access it like:
08:16:18 <earthy> pop is not head
08:16:19 <h0tzenpl0tz0r> the HTTP hackage linked get.hs does not work
08:16:31 <McManiaC> whats the best way to add to "Left" of type Either a [Char]?
08:16:37 <DBAlex> fasta: ok
08:16:41 <earthy> because pop has the connotation of removing the element from the stack
08:16:42 <McManiaC> Left "a" ++ Left "b" wont work
08:16:48 <jfredett> > let f (x:xs) = (("head", x), ("tail, xs)) in f [1,2,3,4,5]
08:16:49 <lambdabot>   <no location info>:
08:16:49 <lambdabot>      lexical error in string/character literal at chara...
08:16:59 <Cheshire> > let list = ([],'f',"oo bar") ; left (x,o,e:y) = (o:x,e,y) ; right (o:x,e,y) = (x,o,e:y) ; edit o (x,_,y) = (x,o,y) in left . left . edit '!' . right . right $ list
08:17:00 <jfredett> > let f (x:xs) = (("head", x), ("tail", xs)) in f [1,2,3,4,5]
08:17:01 <lambdabot>   * Exception: /tmp/8102141847567962651:71:92-118: Non-exhaustive patterns in...
08:17:02 <lambdabot>   (("head",1),("tail",[2,3,4,5]))
08:17:02 <DBAlex> Cheshire: ok thanks
08:17:07 <ski_> > [Left "a"] ++ [Left "b"]
08:17:08 <lambdabot>   [Left "a",Left "b"]
08:17:09 <paper_cc> liftM (++) (Left "a") (Left "b")
08:17:10 <seliopou> h0tzenpl0tz, what do you mean?
08:17:19 <paper_cc> > liftM (++) (Left "a") (Left "b")
08:17:19 <ski_> > [Left 42] ++ [Right "b"]
08:17:20 <lambdabot>   Couldn't match expected type `Either [Char] b -> t'
08:17:21 <lambdabot>   [Left 42,Right "b"]
08:17:23 <LeoD> > fmap (++) (Left "a") (Left "b")
08:17:23 <jfredett> earthy: you're correct, head is peek.... :/
08:17:24 <lambdabot>   Couldn't match expected type `Either [Char] b -> t'
08:17:28 <paper_cc> > liftM2 (++) (Left "a") (Left "b")
08:17:30 <lambdabot>   Left "a"
08:17:30 <earthy> so pop is (head &&& tail)
08:17:37 <paper_cc> oops ...
08:17:42 <jfredett> earthy: hehe, Arrows! Yay!
08:17:45 <ski_> paper_cc :D
08:17:49 <h0tzenpl0tz0r> seliopou: http://darcs.haskell.org/http/test/get.hs this does not work ... "`Request' is not applied to enough type arguments"
08:17:49 <Cheshire> > let list = ([],'f',"oo bar") ; left (x,o,e:y) = (o:x,e,y) ; right (o:x,e,y) = (x,o,e:y) ; edit o (x,_,y) = (x,o,y) in right . right . edit '!' . left . left $ list
08:17:51 <lambdabot>   ("",'f',"o! bar")
08:17:52 <earthy> plus, that is unsafe. :)
08:18:00 <Cheshire> DBAlex, ^ here in another example
08:18:14 <fasta> DBAlex: to put it in other terms: AFAIK, the locations based way of programming is more efficient than the value based one, but it's also a lot more error prone and more difficult to debug (this one could be solved by tools, though). So, unless you need location based programming, use values.
08:18:18 <DBAlex> Cheshire: but how do you add something else to the new list
08:18:20 <Cheshire> > let list = ([],'f',"oo bar") ; left (x,o,e:y) = (o:x,e,y) ; right (o:x,e,y) = (x,o,e:y) ; edit o (x,_,y) = (x,o,y) ; freeze (r,o,x) = o:x++reverse r in freeze (right . right . edit '!' . left . left $ list)
08:18:21 <lambdabot>   "fo! bar"
08:18:41 <McManiaC> whats the best way to add to "Left" of type Either a [Char]? sth like Left "a" ++ Left "b"
08:18:45 <Cheshire> DBAlex, maybe that ^ is a bit condensed but if you look at it all on separated lines it'll probably be clearer
08:18:57 <ski_> McManiaC : what value do you want as a result ?
08:19:02 <jfredett> DBAlex: among other ways, you can just do "abc"++"def" (++ catenates two lists)
08:19:04 <McManiaC> Left "ab"
08:19:05 <maltem> h0tzenpl0tz0r: try and remove the relevant type signature
08:19:06 <McManiaC> ski_:
08:19:09 <LeoD> McManiaC: 17:17:28 < paper_cc> > liftM2 (++) (Left "a") (Left "b")
08:19:13 <DBAlex> Cheshire: basically you just pass in what you want each time
08:19:18 <ski_> McManiaC : `[Left "a",Left "b"]' ? or `Left "ab"' ?
08:19:20 <paper_cc> LeoD: McManiaC: I'm wrong
08:19:28 <Draconx|Laptop> McManiaC, pattern match off the Left and construct a new value.
08:19:36 <h0tzenpl0tz0r> maltem: what to "remove"?
08:19:38 <h0tzenpl0tz0r> Prelude Network.HTTP> :t Request
08:19:38 <h0tzenpl0tz0r> Request :: Network.URI.URI
08:19:38 <h0tzenpl0tz0r>            -> RequestMethod
08:19:38 <h0tzenpl0tz0r>            -> [Header]
08:19:38 <h0tzenpl0tz0r>            -> a
08:19:39 <h0tzenpl0tz0r>            -> Request a
08:19:43 <Botje> DBAlex: you don't. you construct a new list which contains the element
08:19:45 <h0tzenpl0tz0r> request uri = Request { rqURI = uri,
08:19:45 <h0tzenpl0tz0r>                        rqMethod = GET,
08:19:45 <h0tzenpl0tz0r>                        rqHeaders = [],
08:19:47 <h0tzenpl0tz0r>                        rqBody = "" }
08:19:48 <paper_cc> LeoD: because the liftM2 version only handles Right values
08:19:52 <Botje> h0tzenpl0tz0r: aargh!
08:19:55 <ski_> McManiaC : what do you want to do if one or both of the values are `Right' ones ?
08:19:55 <Saizan> h0tzenpl0tz0r: use a pastebin.
08:19:56 <h0tzenpl0tz0r> sorry ...
08:19:56 <maltem> h0tzenpl0tz0r: in the example file you linked to
08:19:57 <jfredett> DBAlex: the trick, here, is to realize every time you change a value, the old value still exists, right where it was, with the same name
08:19:57 <LeoD> paper_cc: ah
08:20:10 <paper_cc> @ty Either a b -> a
08:20:12 <lambdabot> parse error on input `->'
08:20:18 <LeoD> right...
08:20:18 <LostMonarch> how can I add type signature for a function in ghci??
08:20:28 <paper_cc> @hoogle Either a b -> a
08:20:29 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
08:20:29 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
08:20:29 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
08:20:29 <McManiaC> ski_: i actually wanted to use "either" with it
08:20:34 <DBAlex> jfredett: thats the problem
08:20:37 <h0tzenpl0tz0r> maltem: why remove the relevante signature?
08:20:42 <ski_>   let foo :: Int -> Bool; foo x = x > 0  -- LostMonarch
08:20:46 <h0tzenpl0tz0r> i dont get what you mean ...
08:20:48 <Saizan> LostMonarch: let f :: <type>; f = ...
08:20:52 <LostMonarch> ok thx guys
08:21:08 <jfredett> DBAlex: so when you want to use foo, you manipulate it and name it something new -- or, more likely, not name it at all.
08:21:32 <paper_cc> McManiaC: if you're sure your values are Left ones, just pattern match on them
08:21:38 <Draconx|Laptop> > let dostuff f (Left x) (Left y) = Left (f x y) in dostuff (++) (Left "a") (Left "b")
08:21:39 <lambdabot>   Left "ab"
08:21:46 <seliopou> h0tzenpl0tz, I think you might be looking at an old version of that package
08:21:46 <McManiaC> kk
08:21:50 <paper_cc> McManiac: or like this:
08:22:00 <seliopou> try looking at this repo: http://code.haskell.org/http/
08:22:05 <h0tzenpl0tz0r> seliopou: i installed the newest 4.x using cabal
08:22:11 <pejo> DBAlex, why is that a problem?
08:22:15 <paper_cc> > let fromLeft = either id undefined in ((++) `on` fromLeft) (Left "a") (Left "b")
08:22:15 <h0tzenpl0tz0r> seliopou: but i cant find any working example
08:22:17 <lambdabot>   "ab"
08:22:30 <seliopou> yeah, that example assumed an older version
08:22:31 <paper_cc> > let fromLeft = either id undefined in (Left . (++) `on` fromLeft) (Left "a") (Left "b")
08:22:32 <lambdabot>   Couldn't match expected type `[a] -> c'
08:22:33 <h0tzenpl0tz0r> seliopou: as a haskell-newbie its pretty hard to get it "bootstrapped" ....
08:22:38 <seliopou> see if there's an up-to-date one in that repo
08:22:38 <DBAlex> pejo: brb let me test something
08:22:42 <paper_cc> > let fromLeft = either id undefined in Left $ ((++) `on` fromLeft) (Left "a") (Left "b")
08:22:44 <lambdabot>   Left "ab"
08:23:08 <Cheshire> > liftM2 (++) (Right "a") (Right "b")
08:23:09 <lambdabot>   Add a type signature
08:23:13 <Cheshire> > liftM2 (++) (Right "a") (Right "b") :: No
08:23:14 <lambdabot>   Not in scope: type constructor or class `No'
08:23:26 <paper_cc> > liftM2 (++) (Right "a") (Right "b") :: Either a [Char]
08:23:27 <lambdabot>       Could not deduce (Error a) from the context ()
08:23:27 <lambdabot>        arising from a us...
08:23:35 <paper_cc> > liftM2 (++) (Right "a") (Right "b") :: Either String [Char]
08:23:37 <lambdabot>   Right "ab"
08:23:41 <McManiaC> paper_cc: what is `on`?
08:23:53 <paper_cc> McManiaC: a wonderful thing =)
08:23:56 <paper_cc> @src on
08:23:56 <lambdabot> (*) `on` f = \x y -> f x * f y
08:24:01 <h0tzenpl0tz0r> seliopou: there is no newer example. in the cabal-package arent any tests either
08:24:02 <paper_cc> in Data.Function
08:24:13 <LeoD> is (*) a function which is passed to on?
08:24:20 <maltem_> h0tzenpl0tz0r: sorry I got cut off, again: well because that's where you get the error, don't you? At least you said so ("Request is not applied to enough type arguments")
08:24:21 <paper_cc> LeoD: yes
08:24:22 <jfredett> paper_cc: on = glorified arrow, no? hmm
08:24:22 <maltem_> h0tzenpl0tz0r: so remove the type signature involving "Request"
08:24:23 <LeoD> ok
08:24:55 <jfredett> :t (&&&)
08:24:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:24:58 <paper_cc> jfredett: didn't understand actually =(
08:25:07 <McManiaC> ok thx!
08:25:11 <jfredett> :t on
08:25:12 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:25:16 <DBAlex> jfredett: when you say not name it all, you mean lambda's?
08:25:26 <h0tzenpl0tz0r> maltem_: the Request is part of the HTTP-package and the example is outdated
08:25:31 <jfredett> DBAlex: Not even, hang on, I'll cook up an example.
08:25:40 <DBAlex> ok
08:25:59 <maltem_> h0tzenpl0tz0r: I got that, I was suggesting how the example might be updated
08:26:05 <seliopou> h0tzenpl0tz0r, in get.hs, if you remove the type signature for the function request, it should work
08:26:13 <seliopou> h0tzenpl0tz0r, git clone git://code.galois.com/HTTPbis.git
08:26:21 <seliopou> this is the latest repo with the most up-to-date-example
08:26:29 <seliopou> $ diff http_1/test/get.hs HTTPbis/test/get.hs
08:26:29 <seliopou> 7a8
08:26:29 <seliopou> > import Network.Stream
08:26:29 <seliopou> 41c42
08:26:29 <seliopou> < request :: URI -> Request
08:26:30 <seliopou> ---
08:26:30 <lambdabot>   <no location info>: parse error on input `import'
08:26:32 <seliopou> > request :: URI -> Request_String
08:26:33 <lambdabot>   Not in scope: `request'Not in scope: type constructor or class `URI'    Not...
08:26:34 <seliopou> (sorry for the paste)
08:26:44 <seliopou> that's all that's changed
08:27:39 <h0tzenpl0tz0r> hrhr, youre right. thanks a lot!
08:27:41 <fasta> Can anyone recommend an XML beautifier? I currently have a file with extremely long line, and I would rather just see something which looks like a tree.
08:27:47 <fasta> a*
08:28:06 <h0tzenpl0tz0r> maltem_, seliopou: thanks!
08:28:26 <seliopou> np
08:29:34 <idnar> fasta: tidyxml?
08:29:48 <idnar> er, or whatever it's called
08:29:54 <idnar> just "tidy" I guess
08:29:58 <fasta> idnar: does that work without taking any options?
08:30:34 <idnar> well, you probably have to pass -xml, but I think that should be it
08:31:00 <fasta> Conglomerate (GUI) also works, although a bit slowly.
08:35:45 <ImInYourMonad> how hard would it be to prove something like gtk2hs layout being used correctly statically? like now it compiels sometimes when it gets error at runtime(this isnt really a problem, im merely curious)?
08:36:19 <dcoutts> ImInYourMonad: I think you'd need something much more high level, using well designed combinators
08:39:09 <BMeph> ImInYourMonad: I'd say that since gtk2hs is a binding, that you could never
08:40:05 <BMeph> ImInYourMonad: ... "prove" it correct, except to a very shallow point.
08:40:05 <maltem_> Well you'd need something that involves more Haskell code, rather than binding code
08:41:08 <Cheshire> @go saffire static analysis
08:41:09 <lambdabot> http://www.cs.umd.edu/~furr/saffire/
08:41:09 <lambdabot> Title: Type Checking Foreign Function Calls
08:41:22 <maltem_> Write your own toolkit in OpenGL or Cairo or something, give it a nice algebraic structure, and there you go :)
08:48:41 <HugoDaniel> is there any way to switch the order of the function arguments ? like change f1 :: a -> b -> c into f2 :: b -> a -> c
08:48:57 <Cheshire> yes
08:49:13 <Cheshire> use a function that has type (a -> b -> c) -> (b -> a -> c)
08:49:35 <idnar> @hoogle (a -> b -> c) -> (b -> a -> c)
08:49:36 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
08:49:36 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
08:49:36 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
08:49:42 <HugoDaniel> ahh nice
08:49:46 <dons> it's alive! http://www.reddit.com/r/programming/comments/81gp5/haskell_now_has_commercial_backing_the_industrial/
08:49:47 <HugoDaniel> you gotta love haskell :D
08:52:17 <jfredett> DBAlex I might have to start tazing you if you keep treating haskell like C. :)
08:52:37 <jfredett> oops, supposed to be a /msg... :/
08:54:13 <roconnor> dons: is it just me, or do those three gear in the logo look locked together in an unmovable state? :)
08:54:34 <dons> hehe
08:54:42 <Cheshire> looks like a squished ubuntu logo
09:04:26 <McManiaC> is there a "map" for IO [a] ?
09:05:20 <dons> mapM
09:05:25 <dons> ?src mapM
09:05:26 <lambdabot> mapM f as = sequence (map f as)
09:27:04 <whpearson> Does @hackage work?
09:27:11 <Cheshire> not really
09:27:20 <whpearson> I tried it on fusion and got a 404.
09:27:35 <Cheshire> @hackage whpearson-replica
09:27:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/whpearson-replica
09:28:10 <doserj> @hackage haltingproblem-solver
09:28:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haltingproblem-solver
09:28:15 <whpearson> Woot my own package!
09:28:35 <Cheshire> @hackage what-it-was-i-forget
09:28:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/what-it-was-i-forget
09:28:43 <Botje> whpearson: strange, your link doesn't appear to load >:)
09:28:56 <whpearson> @faq Can haskell replicate whpearson?
09:28:57 <lambdabot> The answer is: Yes! Haskell can do that.
09:29:10 <jfredett> > replicate 100 "whpearson"
09:29:12 <lambdabot>   ["whpearson","whpearson","whpearson","whpearson","whpearson","whpearson","w...
09:29:17 <dons> ?hackage solve-the-halting-problem-in-the-type-system
09:29:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/solve-the-halting-problem-in-the-type-system
09:29:20 <dons> cool
09:29:34 <jfredett> dons: wow, hackage really _is_ growing...
09:29:43 <ski_> > @. hackage . vixen arr
09:29:44 <lambdabot>   <no location info>: parse error on input `@.'
09:29:49 <ski_> @. hackage . vixen arr
09:29:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/girls masturbate too you know... probably more than guys. we can do it anywhere discretely
09:30:03 <ski_> ehrms ..
09:30:03 <jfredett> ... awesome...
09:30:14 <dons> vixen is not so sfw
09:30:18 <jfredett> sounds like an aisha tyler joke... :/
09:30:21 <jfredett> hehe
09:30:33 <jfredett> @. hackage . yow
09:30:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Not enough arguments to @.
09:30:36 <jfredett> @. hackage . yow arr
09:30:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Where does it go when you flush?
09:30:46 <jfredett> @. hackage . yow arr
09:30:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
09:30:46 <lambdabot> in a $200,000 MALIBU BEACH HOUSE!!
09:30:50 <dons> back on topic, peoples
09:31:34 <ski_> yes, anyone had any ideas to contribute to the concept of comonads wrt cofree cowill ?
09:31:50 <Cheshire> ski_, cofree wont
09:32:01 <jfredett> cowhatthefuh?
09:32:33 * ski_ was tentatively assuming that the dual of `will' would be `allow'
09:35:05 <ImInYourMonad> dons: im looking at your mp3player but i dont get what you use to decode? basically you wroteyour own decocer? lexer+fastio ?
09:35:30 <ImInYourMonad> if i want to write a decoder, is parsec of any use? or even if it is it would be to slow?
09:35:40 <dons> hmp3 doesn't use its own decoder
09:35:46 <dons> it uses mpg321
09:36:02 <dons> there is an example mp3 decoder on hackage though
09:36:19 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mp3decoder designed for teaching
09:37:08 <ImInYourMonad> yes
09:37:16 <ImInYourMonad> mpg321 is a C lib?
09:37:20 <dons> yeah
09:37:44 <Philippa_> ImInYourMonad: the bulk of the work in mp3 decoding isn't in the structure recognition anyway
09:43:16 <ImInYourMonad> where is it then?
09:44:04 <HugoDaniel> threadDelay uses Int instead of Integer :/
09:45:29 <jpcooper> how do I enable an extension in a file?
09:45:51 <jfredett> language pragma?
09:46:11 <jfredett> {-# LANGUAGE -YourExtensionHere #-}, iirc.
09:46:40 <jfredett> err, I think the '-' isn't in there. i don't remember though
09:46:44 <jpcooper> thanks
09:46:46 <jpcooper> that was it
09:50:02 <HugoDaniel> and editor with code refactoring would be a nice tool to have :)
09:54:11 <paper_cc> HugoDaniel: http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html - a standalone refactoring tool
09:54:27 <paper_cc> and don't forget Leksah, of course
09:54:46 <FalconNL> I don't suppose there's any GHC extensions that allows me to write things like [1, 'a', "b"] :: forall a. Show a => [a] ? (I know about HList but its syntax is... somewhat less than pretty)
09:55:09 <paper_cc> FalconNL: that type is wrong
09:55:18 <Cheshire> FalconNL, to what end ?
09:55:31 <paper_cc> practically you want [1, 'a', "b"] :: [exists a. Show a => a]
09:55:37 <Cheshire> :t [show 1, show 'a', show 'b']
09:55:37 <Cheshire> ^ this works
09:55:38 <lambdabot> [String]
09:55:40 <Cheshire> but what you are doing?
09:55:55 <Cheshire> (in strict language you make it [() -> String])
09:56:08 <HugoDaniel> thanks paper_cc
09:56:14 <FalconNL> basically just slightly prettier code. You can obviously wrap it in a constructor or repeat the show for each element, but the shorter the better
09:56:25 <Cheshire> "shorter the better" no
09:58:04 <paper_cc> "Explicit is better than implicit." The Zen of Python, PEP 20
09:59:07 <ddarius> paper_cc: Python should be purely functional then.
09:59:08 <Nafai> paper_cc: Is Hare being developed at all?
09:59:17 <ski_> (paper_cc : s/=>/*>/ (or however you want to denote it))
09:59:24 <Nafai> It looks kind of dead
09:59:32 <FalconNL> Personally I'd say map show [1, 'a', "b"] is plenty explicit, but I guess tastes vary
10:00:24 <ski_> FalconNL : as paper_cc said, you'd want a type like `[exists a. Show a *> a]' .. however, that doesn't exist in current haskell
10:00:41 <ski_> you can get a similar effect by
10:00:42 <HugoDaniel> how do i do recursion on functions wrapped by a state monad ?
10:00:59 <seliopou> FalconNL, you'd have to do something like: data Shower = forall a. Show a => Shower a
10:01:01 <seliopou> or something like that
10:01:03 <ski_>   data Showable = forall x. Show x => MkShow a
10:01:14 <ddarius> ski_: What are you intending by *> ?
10:01:21 <ski_> and then use `[MkShow 1, MkShow 'a', MkShow "b"]'
10:01:57 <FalconNL> ski_: yeah, that's what I'm currently using. I'm guessing existential typing is not planned for Haskell Prime either?
10:02:19 <ski_> ddarius : in the dictionary-translation, i want `Foo a *> F a' to be translated into `(FooDict a,F a)', instead of into `FooDict a -> F a' (which is what `Foo a => F a' would translate into)
10:02:26 <HugoDaniel> help please: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2001#a2001
10:02:37 <paper_cc> Nafai: don't know. that was a quick Google search actually =)
10:02:52 <Nafai> :)
10:03:45 <paper_cc> HugoDaniel: you don't need to pass the state explicitly
10:03:58 <HugoDaniel> oh :/
10:04:12 <HugoDaniel> its because i was doing runStateT previously but i forgot to remove it :/
10:04:20 <HugoDaniel> i guess this is a sign i should stop coding
10:04:34 <HugoDaniel> thanks :)
10:04:42 <ski_> FalconNL : afaiui, mostly "tried-and-true" extensions are considered fomr haskell-prime (i'm not sure how much this is actually true)
10:04:45 <paper_cc> HugoDaniel: btw, it looks like your function will always return []
10:05:09 <HugoDaniel> yes, i need to change its type to IO () or whatever is appropriate
10:05:12 <glguy> Is GHC development still using darcs?
10:05:17 <HugoDaniel> what do you recommend ?
10:05:37 <dons> glguy: nope
10:05:52 <paper_cc> HugoDaniel well... if you don't return anything that's () ...
10:06:01 <glguy> dons, The GHC wiki tells people to get the source via darcs
10:06:03 <FalconNL> ski_: ExistentialQuantification is in the accepted proposal list. Not sure if they just mean forall or if exists is planned as well though. http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
10:06:09 <glguy> dons, is that just old cruft?
10:06:16 <paper_cc> HugoDaniel: StateT BotState IO () that is =)
10:06:22 <ddarius> FalconNL: "forall" is universal quantification.
10:06:26 <dons> glguy: actually: "Getting a GHC source tree using git ¶
10:06:27 <dons> NOTE: This is not yet supported. We currently recommend you use darcs to get a source tree"
10:06:27 * SubStack wonders if darcs tells people to get the source using darcs
10:06:30 <dons> mmm
10:06:34 <dons> i've been git.
10:06:43 <SubStack> and also ghc using darcs to build darcs to build ghc to build darcs
10:06:53 <dons> glguy: check with igloo
10:07:19 <Igloo> GHC development still uses darcs, yes
10:07:37 <Igloo> Someone changed the wiki to put the git instructions at the top, but I changed that when I noticed it
10:07:50 <dons> ah
10:07:57 <dons> yes, that's what i encountered.
10:08:05 <dons> Igloo: how does the ghc.git stay in sync?
10:08:23 <roconnor> how much sharing does IntMap.insert result in?
10:08:52 <Igloo> dons: nominolo made a post hook for it
10:09:07 <dons> Igloo: ah so it is expected to be an up to date repo?
10:09:20 <dons> the issue will be pushing back patches
10:09:32 <dons> but fine as a read-only distribution mechanism
10:10:02 <Igloo> dons: You certainly shouldn't push patches to git
10:10:06 <dons> yeah
10:10:36 <HugoDaniel> why is git prefered to darcs ?
10:11:20 <gnuvince> HugoDaniel: cause people get a hard-on when you tell them that something is BLAZING FAST
10:11:49 <Botje> does it spontaneously catch fire?
10:12:09 <gnuvince> Botje: if only the fanbois would
10:12:14 <Botje> :)
10:12:32 <ddarius> roconnor: It should be almost everything.
10:12:38 <ddarius> roconnor: It's a trie.
10:12:40 <HugoDaniel> well, as i see it, darcs is better than git because: 1. its haskell; 2. Linus free
10:12:58 <bremner> HugoDaniel: and slower, so you have more time to get coffee
10:12:59 <paper_cc> Can anyone describe what Yi actually is? I've installed it but I don't get the idea: the whole thing is made so extensible that I can't understand it ... Also, any links?
10:13:07 <dons> emacs in haskell
10:13:11 <roconnor> ddarius: oh, it isn't a tree?  Is this specific to IntMap?
10:13:22 <HugoDaniel> yes, slower, but linus free ;)
10:13:36 <dons> it's a big endian patricia trie
10:13:49 <dons> the bits in the key are the path down into the trie
10:14:16 <Japsu> darcs' user interface is a lot nicer than git's
10:14:23 <paper_cc> dons: but it does have Vim emulation. does it have a native mode?
10:14:40 <ImInYourMonad> can you run a REPL in Yi?
10:14:49 <roconnor> Hmm
10:14:51 <dons> paper_cc: it sure does have vim emulation
10:15:01 <dons> there's no concept of native mode. just whatever parser you use
10:15:03 <roconnor> I ought to figure this out
10:15:47 <paper_cc> dons: also, does it have M-x in the Vim mode?
10:16:02 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/liboleg-0.1
10:16:16 <dons> paper_cc: don't think so.
10:16:21 <roconnor> dons: so inserting shares everything except the nodes along the path to the insertion point?
10:16:50 <dons> roconnor: let's see...http://citeseer.ist.psu.edu/okasaki98fast.html
10:16:58 <dons> -- | /O(min(n,W))/. Insert a new key\/value pair in the map.
10:17:13 <dons> looks like it, roconnor
10:17:17 <bremner> Japsu: could well be darcs interface is nicer. But I invested the time in learning git, so now it doesn't bug me.
10:17:19 <dons>   = case t of
10:17:19 <dons>       Bin p m l r
10:17:26 <dons> ...         | otherwise     -> Bin p m l (insert k x r)
10:17:37 <dons> it has to rebuild the path down to the insertion site
10:17:39 <paper_cc> dons: thank you
10:17:42 <Japsu> bremner, I first learned darcs and only then git
10:17:45 <roconnor> dons: okay.  I was trying to understand how oleg's claimed his doubly linked list impl had sharing
10:17:59 <roconnor> dons: Data.Map does not have this property, correct?
10:18:02 <Japsu> and I came to darcs from a subversion background
10:18:18 <dons> well, it's a zipper, so you share the path up too? or zippers at least have maximal sharing
10:18:54 <roconnor> dons: was that zipper comment directed at me?
10:20:09 <dons> yeh
10:21:03 <roconnor> dons: The implementation isn't really a zipper
10:21:19 <roconnor> data DList a = DList{dl_counter :: Ref,	    -- to generate new Refs
10:21:21 <roconnor> 		     dl_current :: Ref,     -- current node
10:21:22 <roconnor> 		     dl_mem :: IM.IntMap (Node a)} -- main `memory'
10:21:31 <roconnor> it's just a counter, and index, and a heap
10:21:46 <roconnor> as his abstract said, it is very imperative
10:22:11 <roconnor> moving in the list is done by updating the dl_current value, and that is it
10:22:24 <roconnor> inserting is done by inserting into dl_mem
10:22:34 <roconnor> which I though would totally break sharing
10:22:39 <roconnor> but apparently not.
10:22:56 <roconnor> Am I right that Data.Map doesn't / can't use a Trie?
10:23:06 <dons> ah oops. you're right.
10:23:26 <Saizan> doesn't Data.Map share everything apart from O(log n) nodes too?
10:23:26 <BONUS> roconnor: it would have to use lists for keys imho
10:23:37 <BONUS> or something isomorphic to them
10:23:39 <dons> Data.Map is a size balanced binary tree
10:25:35 <roconnor> Saizan: what about rebalancing?
10:25:38 <bombshelter13> Hey, I'm having a problem understanding how to derive Eq for a parameterized datatype... basically I have something like 'data Thing a = ThingLabel1 a | ThingLabel2 a'  and want to derive an eq such that ThingLabel1 "first"==ThingLabel2 "first", i.e, equality is not affected by which constructor was used. I've posted my attempt to make this work at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2002#a2002, but can't seem to quite get i
10:25:46 <roconnor> Saizan: or does that still only affect upto log n?
10:27:07 <byorgey> bombshelter13: that looks ok to me.  what doesn't work?
10:27:34 <Saizan> roconnor: i think so, but i don't know the details of size-balancing
10:27:42 <_dolio> I imagine rebalancing only effects a small area around the updated path in general.
10:27:48 <bombshelter13> saiam: loading the file provides this error -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2004#a2004
10:27:49 <_dolio> So it would stay O(log n).
10:27:52 <byorgey> bombshelter13: oh, you probably have to write  'instance Eq a => Eq (Thing a)'
10:28:16 <byorgey> bombshelter13: since to compare two Thing a's for equality, you need to be able to compare the underlying a's for equality
10:29:14 <byorgey> bombshelter13: actually, this is exactly what the error message is telling you, although that may not be obvious
10:29:18 <bombshelter13> byorgey: hm, replacing my instance line outright with yours gets me a 'malformed instance header'?
10:29:29 <ski_> bombshelter13 : consider doing `data Thing a = Thing Label a' and `data Label = Label1 | Label2', then `instance Eq a => Eq (Thing a) where Thing _ p == Thing _ q = p == q'
10:29:30 <bombshelter13> byorgey: yeah, it sounded like that was what it was telling me, i just wasn't sure how to satisfy it
10:29:31 <byorgey> bombshelter13: well, you still need the 'where'
10:29:34 <whpearson> I've been thinking about functions that iterate through the nodes of functionally defined complex data structures (graphs, trees). Based on the basic pattern of gIterate :: (a -> [a]) ->a -> [a]. Is it worth expanding it to something other people will use (e.g. making efficient stream fusion versions/packaging it)?
10:29:38 <Philonous> Instance (Eq a) => Eq (Thing a)
10:30:02 <bombshelter13> byorgey: *slaps forehead*
10:30:07 <bombshelter13> that does the trick. :)
10:30:31 <byorgey> Philonous: the parens are only required if you have more than one class constraint.
10:30:41 <ski_> bombshelter13 : or maybe your actualy code is complex enough that my suggestion doesn't work ?
10:30:58 <ski_> (byorgey : ty)
10:31:05 <Philonous> byorgey: Oh ok. Good to know.
10:31:16 <bombshelter13> ski_: I'm considering your option as well, it might end up being the way to go if I end up having more than two constructors
10:31:37 <ski_> ok
10:32:10 <byorgey> yeah, otherwise the instance code is quadratic in the number of constructors! yikes! =)
10:33:18 <bombshelter13> it seems, for now, like I'm probably only going to have two, though, so this might make the individual instances less verbose since i don't have a seperate label and constructure
10:33:31 <byorgey> sure
10:34:03 <bombshelter13> basically the actual types are 'facts, i.e, thing learned through direct observation.' and 'conjencture, i.e., things inferred from facts'... and I can't really think of a third type of information, so i might be alright :)
10:34:13 <ski_> byorgey : well, one could define a `fromThing :: Thing a -> a' function and use that in `(==)', too ..
10:34:26 <byorgey> ski_: good point.
10:36:38 <Philonous> Isn't that even an application for view patterns?
10:37:11 <ski_> you could use them here, yes .. but they doesn't really buy much here
10:37:20 <ski_> (since `a' is still abstract)
10:37:54 <ski_> hrm
10:38:12 <ski_> maybe not actually
10:38:37 <byorgey> I think view patterns would work fine here.
10:38:49 <byorgey> I'm just not sure they buy you all that much in general. =)
10:38:50 <vincenz> @seen bringert
10:38:50 <lambdabot> I saw bringert leaving #haskell.se, #ghc and #haskell 3m 2d 20h 37m 8s ago, and .
10:39:02 <ski_>   (fromThing -> p) == (fromThing -> (p ==) -> b) = b
10:39:32 <seliopou> whpearson, check out Data.Data
10:39:37 <byorgey> woah, can you do that?
10:39:40 <Philonous> Right. I just read up on them and they appear to be somwhat differen from what I remembered
10:40:00 <ski_> , let eq (fst -> x) (fst -> (x ==) -> b) in zipWith eq "aabb" "abab"
10:40:02 <lunabot>  luna: parse error on input `->'
10:40:10 <ski_> , let eq (fst -> x) (fst -> ((x ==) -> b)) in zipWith eq "aabb" "abab"
10:40:11 <lunabot>  luna: parse error on input `in'
10:40:20 <ski_> um
10:40:24 <ski_> , let eq (fst -> x) (fst -> ((x ==) -> b)) = b in zipWith eq "aabb" "abab"
10:40:25 <lunabot>  luna: Couldn't match expected type `(a, b)'
10:40:51 <ski_> , let eq (fst -> x) (fst -> ((x ==) -> b)) = b in zipWith eq (zip (repeat ()) "aabb") (zip (repeat ()) "abab")
10:40:52 <lunabot>  [True,True,True,True]
10:41:04 <ski_> , let eq (snd -> x) (snd -> ((x ==) -> b)) = b in zipWith eq (zip (repeat ()) "aabb") (zip (repeat ()) "abab")
10:41:05 <lunabot>  [True,False,False,True]
10:41:11 <ski_> ty
10:41:29 <ski_> byorgey : so, apparently, yes
10:41:31 <byorgey> crazy, I didn't realize you can have nested view patterns
10:42:02 <Philonous> let eq (fromJust -> a) (fromJust ->b) = a==b in eq (Just 1) (Just 1)
10:42:03 <seliopou> Am I the only one here that dislikes view patterns?
10:42:03 <lilac> in this case, isn't it clearer to write (fromThing -> p) == (fromThing -> q) = p == q ?
10:42:05 <Philonous> > let eq (fromJust -> a) (fromJust ->b) = a==b in eq (Just 1) (Just 1)
10:42:06 <lambdabot>   <no location info>: parse error on input `->'
10:42:14 <Philonous> , let eq (fromJust -> a) (fromJust ->b) = a==b in eq (Just 1) (Just 1)
10:42:15 <lunabot>  True
10:42:18 <Philonous> , let eq (fromJust -> a) (fromJust ->b) = a==b in eq (Just 1) (Just 2)
10:42:19 <lunabot>  False
10:42:23 <Philonous> Ok, works
10:42:24 <ski_> Philonous : you need to bother lunabot, lambdabot doesn't do view patterns
10:42:27 <byorgey> lilac: definitely.
10:42:57 <lilac> ... or even p == q = fromThing p == fromThing q
10:43:02 <byorgey> seliopou: I doubt it.  I am ambivalent.
10:43:05 <lilac> ... or (==) = (==) `on` fromThing
10:43:20 <ski_> lilac : yes .. but `(fromThing -> p) == (fromThing -> q) = p == q' is arguably roughly as clear as `p == q = fromThing p == fromThing q' (which you just wrote)
10:43:23 <ImInYourMonad> i think i just got what a closure is. in Clojure I can pass #(f x y) meaning apply f to x and y but not yet. if i write (f x y) I am evaling it right there
10:43:27 <Philonous> byorgey: AFAIK view patterns are just nice sugar for guards. It's like writing multiple function definitions instead of case expressions.
10:43:35 <Philonous> So no, they don't add much.
10:43:40 <byorgey> Philonous: right.
10:43:48 <ImInYourMonad> so #(f x y) is a closure, but it is also a lambda. so isnt it a closure?
10:43:51 <lilac> Philonous: i like pattern guards, but i'm not too fond of view patterns
10:44:00 <ski_> i was wondering whether using a view pattern with a view into an "abstract" type `a' would be "serious use"
10:44:02 <idnar> ImInYourMonad: that's more of a description of a thunk or function, and less of a description of a closure
10:44:14 <ImInYourMonad> ok
10:44:24 <ski_> and since we had an (abstract) function `(==) :: a -> a -> Bool', it turned out it was
10:44:30 <whpearson> seliopou: Not quite the same, I think. That defines the data structures with data, I'm interested in functions. E.g. you might have a game AI that generates all possible next states from a game. E.g Game -> [Game] and you want to see what possible game states you can get to.
10:44:43 <byorgey> ImInYourMonad: if # is a way to delay evaluation, then it lets you create thunks
10:45:03 <idnar> ImInYourMonad: I'd say a closure is simply something that captures variables / values from the surrounding scope along with the code that references them
10:45:12 <ski_> ImInYourMonad : what does "not yet" mean ?
10:45:24 <ski_> ImInYourMonad : how do you "eval" it later ?
10:45:41 * gwern sighs
10:45:48 <gwern> sometimes I feel like a human buildbot for yi
10:46:37 <byorgey> gwern: do you feel that way only when building yi, or at other times as well?
10:46:47 <byorgey> gwern: if the latter you may want to seek professional help
10:46:52 <idnar> heh
10:48:20 <whpearson> seliopou: E.g. by iterating that function.
10:48:52 <toliko_smoren> hey, why cant i use let inside an if statement, basically I have a do... if(condition) then let a = someFunction else let a= somethingElse, and it throws me a parser error at else
10:49:22 <seliopou> whpearson, yeah, I thought you mean doing traversals of data structures that you've already constructed
10:49:47 <ski_> toliko_smoren : `let' normally wants an `in' and an expression after that
10:49:47 <BONUS> toliko_smoren: let a = if condition then foo else bar
10:50:14 <ski_> toliko_smoren : at "top level" inside a `do' you can use `let' without an `if' .. that's a `let' "command" inside the `do'
10:50:33 <Philonous> @type (>>=)
10:50:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:50:43 <ski_> toliko_smoren : but inside the `if'-`then'-`else' there are just expressions, not commands
10:51:47 <toliko_smoren> BONUS: i tried that as well, I get an indentation error
10:51:50 <ski_> (btw, this is something which could be useful at times .. allowing commands inside an `if' or a `case', if that is directly embedded inside a `do')
10:52:10 <toliko_smoren> ski_: so how do you suggest i do the if assigment of variables
10:52:33 <jberryman> toliko_smoren: if you want to post the code, someone can sort it out for you, but I would guess you want to do: let f = if b then someFunc else someOtherFunc in f x  ?
10:52:37 <toliko_smoren> this is my current code
10:52:38 <toliko_smoren> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2005#a2005
10:52:42 <BONUS> > let x = if 5 > 3 then "haha" else "hoho" in "x is: " ++ x
10:52:43 <toliko_smoren> and that is inside a do
10:52:43 <lambdabot>   "x is: haha"
10:52:44 <ski_> toliko_smoren : well, it depends a little on what you have in the branches of the `let'
10:53:00 <ski_> toliko_smoren : do you have just pure code, or do you have monadic code, too
10:53:09 * ski_ looks at paste
10:54:00 <ski_> toliko_smoren : that code looks like it should "work"
10:54:18 <ski_> but you don't have anything similar to "do... if(condition) then let a = someFunction else let a= somethingElse", in there
10:54:18 <Cale> toliko_smoren: The only parens you need there are the ones around the subtraction, in any event.
10:54:43 <Cale> toliko_smoren: What's the type of maybeGetAIEvent board piece ?
10:54:43 <Philonous> "let a = someFunction else" I don't think that should work. (let a=b) is not an expression, or is it?
10:55:11 <toliko_smoren> it gives an error of parse error(possible identation) at the first letter of then
10:55:15 <ski_> toliko_smoren : if you could paste any `if'-expression which has these (non-working) `let a = someFunction' things inside, we could try to show what to write instead
10:55:46 <Cale> toliko_smoren: In order to decide why, we would need more context.
10:55:52 <toliko_smoren> maybeGetAIEvent is type of Board->Region->(Maybe Event)
10:56:00 <toliko_smoren> i will paste more code then
10:56:03 <ski_> ty
10:56:05 <Cale> toliko_smoren: Okay, so it typechecks anyway
10:56:10 <gwern> byorgey: usually just for yi. gitit doesn't break nearly as often
10:56:22 <ski_> (toliko_smoren : btw, please annotate the existing paste)
10:57:00 <toliko_smoren> i modified the paste
10:58:10 * wli returns.
10:58:44 <ski_> toliko_smoren : you still have nothing resembling "do... if(condition) then let a = someFunction else let a= somethingElse" in that paste ..
10:58:45 * wli is still rather stumped as to where control flow comes into things.
10:59:00 <wli> e.g. jump/branch instructions
10:59:18 <toliko_smoren> ah, it used to be liked that previously, i will change it back to how it was
11:00:05 <toliko_smoren> its there
11:00:14 <ski_> ty
11:00:57 <ski_> ok, you have only pure code inside the `if'-expression, so this is not that hard
11:01:13 <toliko_smoren> so, how do I make this work
11:02:14 <ski_> pasted "lift `let' out of `if'" at <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2005#a2008>
11:03:07 <ski_> also note that (as Cale said), you can simplify `(((time - stime) `mod` 1000)==0)' into plain `(time - stime) `mod` 1000) == 0', there
11:03:14 <ski_> er
11:03:21 <ski_>   (time - stime) `mod` 1000 == 0
11:03:34 <toliko_smoren> i tried that
11:03:37 <toliko_smoren> it does not work
11:03:40 <ski_> (inadvertenyly copied an extra bracket)
11:03:57 <ski_> oh, sorry
11:04:01 <ski_> i forgot a small point
11:04:01 <toliko_smoren> parse error on then
11:04:08 <wli> Recursive data doesn't really loop, it just has pointer cycles. Case statements and conditionals don't loop.
11:04:15 <ski_> you need to indent the `then' and `else' more than the `e' in the `let e'
11:04:21 <ski_> (mea maxima culpa)
11:04:27 <toliko_smoren> thanks
11:04:47 <ImInYourMonad> for something like: onClicked playBtn (next playerstate 1) , how do I do sveral things there? with >>= ?
11:05:16 <ski_> wli : functions loop
11:06:00 <ski_> ImInYourMonad : possibly `onClicked playBtn (do next playerstate 1; ...)'
11:06:07 <ski_> (you could also use `>>', then)
11:06:10 <ImInYourMonad> can you run a REPL in Yi?
11:06:11 <wli> I'm still having a fair amount of trouble smoking out how functions operate wrt. linearized IR's.
11:06:47 <ski_> wli : not sure, but maybe you want to make explicit that functions take continuation parameters ?
11:07:15 <Cale> toliko_smoren: The basic idea of indentation is that if something is inside something else, then it should be indented more, and if two things are at the same level, then they should start in the same column.
11:07:28 <wli> I've lost enough brain cells I need to get it more specific.
11:07:32 <Cale> (If that helps)
11:07:48 <wli> Continuations sound rather reasonable.
11:07:49 <ski_> (so, to return from a function, you maybe have a multi-edge that has two input nodes : the thing to return, and the return continuation; and no output nodes)
11:08:16 <toliko_smoren> Cale: i thought i understood it, but I didnt know there is a difference in the amount of indentation you do, I though even small ones would work
11:08:40 <wli> ski: Well, in CPS nothing ever returns.
11:09:20 <ski_> wli : you can still have a "local" return in your graph .. thay returns to some place your graph doesn't statically know about
11:09:30 <Taejo> @pl transposeClass c d = (c + d) `mod` 12
11:09:31 <lambdabot> transposeClass = flip flip 12 . (mod .) . (+)
11:09:38 <ski_> statically known prefixes of generally only dynamically known continuations are useful
11:09:39 <Taejo> :t flip flip 12
11:09:40 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
11:09:48 <Cale> toliko_smoren: they will...
11:09:53 <ski_> toliko_smoren : the point to note there it that after the `let' in `let e = ...' there, you could define *several* things like `e' after each other ..
11:09:55 <wli> That's where there are cycles in the control flow graph, sure.
11:10:10 <aconbere> anyone here know much about Yi? I've been trying to write a custom color scheme but failing :)
11:10:30 <ski_> toliko_smoren : hence, the `then' and `else' need to be indented "inside" the `e' to show that they're not part of some latter definition inside the `let'
11:10:38 <Cale> toliko_smoren: However, the first non-whitespace character after 'let', 'of', 'where', or 'do' sets the indentation level for the remainder of the block
11:11:05 <ski_> (wli : right, the dynamic cycles you don't see in the graph)
11:12:34 <ski_> toliko_smoren : if you had wanted do perform any actions as well inside the `then' and `else' .. or if you had wanted to do `e <- ...' inside them .. then the rewriting would have been similar, but slightly more involved
11:13:15 <lstor> Hello, I'm following a tutorial, but I can't get the source to compile. The complete source is at [ http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source ]. In 'main', on the line   loop st    = catch (runReaderT run st) (const $ return ())  I get:
11:13:27 <lstor> nolstor.hs:25:14:
11:13:28 <lstor>     Ambiguous type variable `b' in the constraint:
11:13:28 <lstor>       `Exception b' arising from a use of `catch' at nolstor.hs:25:14-58
11:13:29 <lstor>     Probable fix: add a type signature that fixes these type variable(s)
11:13:41 <Cale> lstor: The tutorial code uses the old exceptions library...
11:13:48 <Cale> lstor: let's see...
11:15:01 <Cale> hmm, I thought there was a package with the old version...
11:15:30 <dmwit> Seems like high-level GUI libraries are the new monad tutorials. =P
11:15:35 <Cale> Well, I suppose I can see about fixing this error instead.
11:15:42 <BONUS> loop st = catch (runReaderT run st) ((const $ return ()) :: SomeException -> ReaderT IO ())
11:15:45 <BONUS> maybe this?
11:15:57 <BONUS> uh wait no
11:16:20 <Cale> You have to give an explicit type to the exception handler
11:16:46 <BONUS> yeah lol i always confuse the handler and the handlee
11:16:51 <lstor> BONUS: By the way, I *love* your tutorial :)
11:16:57 <BONUS> hey thanks :]
11:17:10 <todos> .йгше
11:17:16 <ski_>     do {<pat> <- if <expr01> then {<command0> ; ... ; <expr0>} else {<command1> ; ... ; <expr1>} ; <command> ; ... ; <expr>}
11:17:20 <ski_>   = do {(<var> , ... , <pat>) <- if <expr01> then do {<command0> ; ... ; x0 <- <expr0>; return (<var> , ... , x0)} else do {<command1> ; ... ; x1 <- <expr1>; return (<var> , ... , x1)}; <command> ; ... ; <expr>}
11:17:43 <lstor> BONUS: Can't wait for new content. And I especially like the drawings, and the references, like the one with Gordon Freeman on lambdas, and "Guards! Guards!", for example. It's brilliant!
11:17:59 <BONUS> hahaha thank you so much :) new stuff is coming soon
11:18:03 <ski_> where `<var> , ...' is the intersection of the variables bound by `<command0> ; ...' and `<command1> ; ...'
11:18:33 <ski_> what would you think about this kind of extension to `do'-syntax ?
11:18:37 <BONUS> Cale: do you think loop st = catch (runReaderT run st) ((const $ return ()) :: (SomeException -> IO ()) would work?
11:19:08 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2009#a2009 <- gtk2hs, if I want a button from makeButtonsBox to refer to a button from makePlayinfoBox, do I have to return them to the main when created then have a Map of them? or can I refer to a button/widget through its parent window? does the parent window keep some sort of list of its widget s that is accessible?
11:19:24 <lstor> BONUS: It doesn't :(
11:19:43 <BONUS> gah! :[
11:20:28 <Cale> huh?
11:20:30 <Cale> It does.
11:20:35 <Cale>     loop st    = catch (runReaderT run st)
11:20:35 <Cale>                        (const $ return () :: SomeException -> IO ())
11:20:39 <Cale> This works.
11:21:03 <lstor> Oh, I missed on the parentheses
11:21:18 <ski_> this syntax would (almost) allow something like what toliko_smoren initially wrote
11:21:32 <lstor> Yeah, it compiled now. Thanks, both of you :D
11:22:26 <ski_> (one would need to add the possibility of omitting `<pat> <- ' together with ` ; <expr0>' and ` ; <expr1>' from the syntax extension)
11:22:53 <wli> The weird thing about control flow is that it doesn't fit into the operation graphs cleanly if at all.
11:23:21 <ski_> wli : maybe you want to have another graph of control flow, which refers to expression graphs ..
11:23:26 * ski_ doesn't really know
11:23:55 <Cale> There ought to be some convenience function for this kind of thing -- like id with a specific type.
11:24:12 <PeakerWork> As an educational exercise, helping someone write a tokenizer in Haskell with pure recursive code (no fancy parsec stuff)
11:24:14 <PeakerWork> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2011#a2011
11:24:20 <gwern> 'I've done some benchmarking of ICC and GCC and typically you find that recent GCC (4.3+) optimizes code at a high level better than ICC. With large messy codebases with lots of useless function calls with no side effects, GCC will often times reduce the code to a simple compile time constant.'
11:24:22 <Cale> The new exceptions library is nice in principle, but a pain to actually use.
11:24:40 <PeakerWork> I can't find an elegant way to get rid of empty words at the beginning, if the string starts with whitespace
11:24:49 <PeakerWork> (could wrap the tokenizer to drop it, but is there any nicer way?)
11:25:03 <Taejo> is there a GHC option to check whether a file would compile, without producing any output?
11:25:05 <wli> ski: I'm still pretty stumped. I can't even do calculator-like things without case statement jumps.
11:26:00 <Cale> PeakerWork: you might have a look at 'words'
11:26:12 <sw17ch> Taejo: i'm fairly sure such a task is equivelant to just compiling th efile
11:26:18 <PeakerWork> Cale: I know words, it doesn't handle " strings properly
11:26:26 <PeakerWork> Cale: also, its an educational thing :)
11:26:32 <dons> gwern: that's bizarre
11:26:35 <Taejo> sw17ch: I don't want code generation
11:26:41 <dons> -fno-code
11:26:54 <Taejo> dons: thanks
11:27:04 <PeakerWork> Cale: oh you mean how it handles the same problem?
11:27:06 <Cale> yeah
11:27:14 <PeakerWork> Cale: oh, sorry, thanks
11:27:53 <wli> ski: Maybe it's a third kind of node?
11:28:07 <gwern> dons: I guess haskell encourages messy codebases
11:28:10 <PeakerWork> Cale: dropWhile isSpace on its input
11:28:14 <Cale> Once you've written the library this way, the writing your own combinators way is also fun and educational :)
11:28:22 <ski_> wli : "it" being ?
11:28:24 <Cale> ah, so it puts that first.
11:28:35 <wli> ski: Control flow.
11:29:34 <ski_> wli : i was thinking a "separate" graph (referring to expression graphs, possibly) .. but maybe you can make it into a "single" graph
11:29:36 <Cale> PeakerWork: Ah, yeah, it's using dropWhile and break
11:29:54 <PeakerWork> Cale: yeah, I just added a dropWhile (=="") on my output
11:30:55 <ski_> wli : i mean, you can consider "sequence points" as nodes in the graph, and multi-edges for transitions. i.e. some multi-edges have multiple (or no) out-nodes .. i'm not sure if anything else than one in-node is meaningful, though
11:31:20 <wli> ski: It could be separate, as it seems to have some sort of over-arching characteristics. The control flow nodes are wired up with expression affairs between tehm.
11:32:42 <ski_> m
11:33:29 <wli> ski: It's basically something like there are control flow nodes for every jump, and their inbound edges are the arguments passed by the caller, and outbound edges are arguments as accessed by the the callee.
11:34:29 <wli> ski: So the control flow nodes "set the environment." All of the expression nodes act as a sort of mesh connecting two (maybe more?) control flow nodes.
11:34:56 <ski_> that might be useful, yes
11:35:26 <ski_> (and, yes, having several alternative return adresses can be useful)
11:35:46 <ski_> (as well as having several alternative entry points)
11:36:24 <ski_> (basically `Either a b -> Either c d')
11:36:35 <Valodim> is there any way to have an Ord instance for an existential type?
11:36:54 <Valodim> the compare function doesn't work just like that because I can't match and compare the types as usual :|
11:36:55 <Cheshire> what's an existential type?
11:37:07 <Valodim> one with a forall thingie :P
11:37:22 <edwardk> Valodim: you could at most have a partial order, no? because you don't have an ordering on types themselves
11:37:22 <ski_> Valodim : in the general case, i think no
11:37:58 <Valodim> What I basically want is a type (list or set or whatever) with an additional class constraint
11:38:00 <ski_> Valodim : in specific cases, you might be able to acces the whole behaviour of the hidden data by the deconstructors, and do comparision on that
11:38:01 <Valodim> can't be that difficult >_<
11:39:03 <wli> ski: In C you could write it as switch (x) { case 1: return f_1(a1_1, ..., a1_n1); case 2: return f_2(a2_1, ..., a2_n2); ... case n: return f_n(an_1, .., an_nn); } etc. as multiple outbound affairs. Multiple inbound ones in any nontrivial sense are stranger.
11:39:19 <edwardk> you could _make_ a quantified container that had a constraint that its type was a member of some sort of a OrdTypeable class which gave you the ability to ask for a typerep that was ordered, then you could compare on the order of your ordered typerep then the value of the type if ==
11:39:34 <ImInYourMonad> if i want to insert 4 things into a Set, can I somehow use monads or soemthing to thread Set.insert s a b c d ?
11:39:36 <ski_> wli : or in gcc you could `goto' to some labels passed in arguments
11:39:37 <wli> ski: (Assuming they're all translated into tailcalls.)
11:40:09 <wli> ski: This is probably more like one huge main with everything done via goto.
11:40:23 * ski_ recalls the `entry' keyword in K&R C, which, iirc, never got around to be used for multiple entry points
11:40:27 <pumpkin_> ImInYourMonad: just fold?
11:40:42 <abuiles> HI guys,  does anyone know about a library for parsing a JSON object represented as String, just to a JSON Object ?
11:40:52 <edwardk> you could also cheat using some unsafePerformIO hacks to make an ordering on TypeReps so that was invisible, by storing an IORef [TypeRep] or other updatable container that provided your ordering on Types, and updating it to include a new entry every time you encounter a new type.
11:41:04 <ski_> wli : "this" being your version with tail calls, or my with label parameters ?
11:41:04 <Valodim> can't be that difficult to replicate the simple interface behavior from oop
11:41:04 <ziman> ImInYourMonad, you can use Data.Set.union with Data.Set.fromList, or foldr Data.Set.Insert your_set [elm1, elm2, elm3, ...], for example
11:41:23 <Valodim> edwardk: that sounds awfully.. awful :|
11:41:45 <wli> ski: "This" referred to the more abstract graph affair.
11:41:56 <ski_> Valodim : "simple interface behavior from oop" referring to ?
11:41:57 <edwardk> then you could use that to get an existential order on say data CrazilyOrdered = forall a. TypeRep a. => Crazy a
11:42:12 <ski_> wli : ok. aye then
11:42:21 <edwardk> er s/TypeRep/Typeable/
11:42:28 <gwern> gah, data.binary broke my ireader yi mode :(
11:42:35 <gwern> (bad data.binary)
11:42:37 <wli> The thing about all this is that at a lower level there's really only one entry or exit.
11:42:49 <Valodim> ski_: having a heterogenous list of objects that implement a specific interface (ie, class)
11:42:53 <wli> But maybe that's not how the IR should work.
11:43:31 <PeakerWork> Cheshire: a type variable can be "forall a" in which case its "universally quantified" -- and the code that uses it gets to choose whether a=String or a=Int.  A value of this type must not assume anything about the type because it can be anything, but the code that uses it may assume everything about the type because it chooses it.  a type variable can be "exists a" (not in this syntax, though), -- which means it is "existential
11:43:32 <PeakerWork> ly quantified". A value of this type may assume everything about the type because it chooses it, but this means the user of this type doesn't know anything about the type, so cannot assume anything about it
11:43:36 <edwardk> yes, but the problem is the notion that a type can define its own equivalence is what is at fault. ;) you have a covariant occurence in a position that can only specialize contravariantly ;)
11:43:49 <edwardk> just because they always _do_ it doesn't mean they should ;)
11:44:06 <wli> ski: I can't see how multiple entrypoints get wired up without alternative input sources in operation nodes.
11:44:07 <Valodim> gah
11:44:19 <ski_> Valodim : and how do you get ordering on that ?
11:45:01 <wli> ski: Like operation nodes' inputs are no longer unique, but only one can be used at a time.
11:45:24 <Valodim> ski_: well that's the point
11:45:44 <PeakerWork> Cheshire: blah :: a -> a ; actually means:  blah :: forall a. a -> a   -- this means that the code inside blah cannot assume anything about "a".  But you can call blah with any specific type you want.   blah :: exists a. a -> a (not specifiable in Haskell, afaik) means that the code inside blah decides which "a" it is and uses that.  The user of blah doesn't get to choose "a" so in effect cannot actually give an arg to blah
11:45:58 <Cheshire> thanks
11:46:34 <monochrom> Heterogenous list can be done by existential type. See the haskell wiki on existential type, has example of heterogenous list.
11:46:43 <lilac> ImInYourMonad: if you want something monadic for dealing with Sets, you can do something like this:
11:46:47 <lilac> > let at k = do {v <- get; return (v!k)}; set k v = modify (// [(k,v)]); runArray = flip execState in  runArray (array (1,3) $ zip [1..] [1,5,9]) $ do v1 <- at 2; set 1 v1; set 3 (2*v1)
11:46:49 <lambdabot>   array (1,3) [(1,5),(2,5),(3,10)]
11:46:52 <Valodim> what I basically want is a heterogenous priority queue
11:47:00 <ski_> wli : "operation nodes" being ?
11:47:17 <ski_> wli : hm, like `div', right
11:47:23 <wli> ski: Add, div, etc.
11:47:24 * ski_ is slightly tired
11:47:33 <edwardk> Valodim: if you find yourself having to have a heterogeneous bag without an outside notion of ordering, then you're basically lost. its like asking everyone in a world to have to know everyone else in the world for comparison purposes. Now, if Haskell had a partial order typeclass you could probably express it that way much more reasonably
11:47:41 <lilac> ImInYourMonad: though i'm pretty sure it was you i cooked that example up for a week ago ;-)
11:47:42 <PeakerWork> Cheshire: to actually create an existential type in Haskell (since "exists" does not exist in Haskell), you can use for example "forall" on the RHS of a data-declaration: data Obj = forall a. Obj a ;  this means that Obj :: forall a. a -> Obj ;  but in  case Obj x of ...     the type of x is (exists a. a)
11:47:55 <monochrom> Some people say heterogenous list when they mean downcasting. Downcasting is another story and different from abstract interface. Downcasting is also morally wrong.
11:48:00 <Valodim> edwardk: you kinda lost me there :(
11:48:18 <wli> ski: Things more faithful to hardware always have one entry and exit.
11:48:24 <ski_> Valodim : i meant : how do you ge orderings on that in Java or C++ or C# or whatever "oop" language you're considering ?
11:48:25 <PeakerWork> monochrom: downcasting is OO's way to do closed type sums -- but we have true closed type sums, instead
11:48:30 <ski_> s/ge/get/
11:48:48 <C-Keen> http://haskell.org/ghc/docs/latest/html/libraries/base-3.0.0.0/Control-Concurrent-Chan.html does this work for you?
11:48:51 <Valodim> ski_: PriorityQueue<Whatever>, public interface Whatever extends Comparable
11:48:53 <Valodim> for java
11:48:55 <monochrom> You should address this to the whole channel, not just me.
11:49:02 <PeakerWork> whole channel: downcasting is OO's way to do closed type sums -- but we have true closed type sums, instead
11:49:07 <piksi> http://pastebin.com/m7eca2c7a <-- i'm trying to find out the smallest number which is divisible by numbers 1..20, i know the syntax is awkward but it works if i cap the max value (which is not what i want if i'm looking for an unknown number which i can't know will fall in to the capped range). how could i improve the code ?
11:49:15 <Cheshire> This just in: Downcasting is the new black
11:49:15 <skorpan> gwern: did you just save me hours of headache in the yi repo?
11:49:19 <wildean> thank you, PeakerWork
11:49:29 <wli> ski: No, exactly one entry in every sense, and always commit to a single exit.
11:49:48 <lilac> PeakerWork: disagree; downcasting is also sometimes used for open type sums. we have existential wrappers for that
11:49:54 <edwardk> Valodim: take c# as an example. it has a notion of Equals and GetHashCode that every object has to supply right? lets ignoring ordering and just going to delegated equivalence
11:50:17 <Valodim> can you use java as example? not familiar with c# :|
11:50:35 <lilac> Valodim: same example but the first letters are in lowercase iirc
11:50:35 <PeakerWork> lilac: existential wrappers?
11:50:35 <Valodim> but yes I can follow that far
11:50:39 <Cheshire> Valodim, pretty much the same
11:50:43 <Cheshire> hehe lilac
11:50:52 <PeakerWork> lilac: usually you pass along a typeclass or a function/record with the existential -- and use that.  That's not really downcasting though
11:51:21 <lilac> PeakerWork: that only works if you don't need a uniform represetation for such things
11:51:36 <PeakerWork> lilac: when do you downcast for open type sums?
11:51:37 <monochrom> Object.equal(Object o) is blatantly wrong.
11:51:55 <edwardk> Valodim: it does this by asking the first object if it is equal to the second one, which is supplied as an untyped reference. but unfortunately no matter where you go in the tree your object is hopelessly outclasses. it can know if it is equal to objects of exactly the same class as it, but thats it. subclasses add more fields i can't even know about
11:51:58 <wli> ski: Hmm, one _could_ jump into the middle of a basic block.
11:52:09 <lilac> PeakerWork: usually it's a workaround for the expression problem.
11:52:15 <ski_> Valodim : what happens when person `pA' implements `A' as a `Whatever', and person `pB' implements `B' as a `Whatever', and person `pC' try to combine persons `pA's and `pB's libraries into a single application, and ends up mixing `A's and `B's in the queue .. what happens when an `A' is compared with a `B' ?
11:52:29 <edwardk> subclasses change non-final members in ways i can't even guess, so i can't use field based equality unless i'm final.
11:52:35 <wli> ski: No idea how to represent that, though.
11:52:59 <PeakerWork> edwardk: implementation inheritance is wrong.. no real reason to use it :)
11:53:01 <pumpkin_> wli: jumping into the middle of a basic block is an oxymoron isn't it?
11:53:02 <gwern> skorpan: maybe. what would've caused you hours of headaches?
11:53:03 <lilac> PeakerWork: basically when you have an extensible set of types and an extensible set of operations
11:53:12 <pumpkin_> wli: if you can jump into the middle of it, it aint no basic block no mo'?
11:53:28 <wli> pumpkin: Not sure how else to express the idea.
11:53:32 <Valodim> ok the solution just came to me: add a priority :: a -> Int to Whatever, and compare by that
11:53:36 <edwardk> but every object is required to provide this delegated notion of equivalence. fortunately for == you have the notion of pointer equivalence to fall back on.
11:53:38 <PeakerWork> lilac: that's a conflict though -- adding operations without fixing all the types would break
11:53:39 <edwardk> thats fine =)
11:53:44 <Valodim> I see your point(s)
11:54:01 <PeakerWork> lilac: and vice versa, depending on which set is assumed closed
11:54:04 <lilac> PeakerWork: implementation inheritance is only wrong if you think the only abstraction barriers are around the type and not internal to it
11:54:08 <ski_> wli : yes .. one only needs to ensure that every node accessible from that only refers to this that will be initialized in time .. iow, each node must know that the things it uses are initialized whatever way one enters the graph
11:54:22 <edwardk> class HasPriority a where priority :: a -> Int   -- and then require that everything you put in the queue HasPriority works dandy
11:54:30 <wli> pumpkin: But you have an important point: you can always subdivide the things until you get a single entrypoint invariant.
11:54:37 <gwern> gahhh... this stack overflow error with data.binary just won't go away
11:54:38 <lilac> PeakerWork: there is a conflict (that's basically what th expression problem is) but you may wish to solve it by saying "this algorithm does special things on types X Y and Z and normal things on all other types"
11:54:42 <PeakerWork> lilac: What does implementation inheritance give me over using the superclass as a member?  Overriding vtables? If so, why not use an interface instead?
11:54:42 <skorpan> gwern: for some reason i can't push the changes that fix the build in Yi.Config.Default. it tells me something about conflicts and i can't by my life figure out what the problem is. would you mind helping me out?
11:54:52 <pumpkin_> yup
11:54:56 <pumpkin_> @users
11:54:56 <lambdabot> Maximum users seen in #haskell: 658, currently: 641 (97.4%), active: 33 (5.1%)
11:55:01 * Valodim tries
11:55:05 <pumpkin_> that's a lot of active users
11:55:06 <Valodim> thanks for the help :)
11:55:17 <Valodim> and yes indeed
11:55:18 <PeakerWork> lilac: Any real life examples of when you'd want to do that?  How is it possible to know that X,Y,Z are the only ones that deserve that treatment?
11:55:33 <gwern> skorpan: dunno. I don't understand darcs conflicts well
11:55:39 <lilac> PeakerWork: in real life it happens all the time at my place of work ;-)
11:55:49 <PeakerWork> lilac: can you give examples?
11:55:50 <edwardk> PeakerWork: bah, i _like_ implementation inheritance ;)
11:56:03 <skorpan> gwern: i see... well, thanks anyways! :)
11:56:04 <wli> The structure of outbound nodes is more difficult.
11:56:10 <PeakerWork> edwardk: what does it give you over just using the superclass as a normal member?
11:56:11 <edwardk> PeakerWork: kata's numerical types would explode in size exponentially without it
11:56:23 <wli> Outbound data etc. rather.
11:56:23 <lilac> PeakerWork: let's say you're writing a compiler and you want to traverse your SSA form and do special things with jump instructions
11:56:27 <ski_> edwardk : do you have coinheritence, too ?
11:56:40 <edwardk> PeakerWork: all of the work of plumbing the interfaces down to their blackbox composed members' fields for EVERY case.
11:56:48 <PeakerWork> lilac: what about jump instructions with a form you don't know about yet?
11:57:08 <PeakerWork> edwardk: just expose the whole member
11:57:08 <lilac> PeakerWork: you can't possibly write code which is correct in the presence of all poissible changes to the source code
11:57:13 <PeakerWork> edwardk: and voila
11:57:27 <edwardk> ski: not exactly =)
11:57:33 <ImInYourMonad> gtk2hs problem: im trying to put all Buttons in a Set but then I get no instance for Ord. So how do I define that? or what could I use nstead
11:57:48 <ImInYourMonad> I should use a Map String Button instead?
11:57:50 <PeakerWork> lilac: you can write code that gives a compilation error when it becomes incorrect though :)
11:58:02 <edwardk> PeakerWork: yes, but now you've made it more work for anyone that wants to use your field class, they have to violate the law of demeter and ask it for something to ask for something
11:58:35 <lilac> PeakerWork: at the cost of making your code much harder to maintain. what was the point again?
11:58:38 <edwardk> PeakerWork: you are morally correct that it is sufficient, but it is by no means convenient
11:58:46 <ski_> edwardk : you might find a few of Erik Poll's papers on inheritence and coinheritence interesting (maybe i have mentioned this before, not sure)
11:58:58 <PeakerWork> edwardk: if you were exposing its interface anyway -- its okay to expose it via a member, less namespace pollution. If its an actual interface rather than an actual class, even better
11:59:18 <ski_> edwardk : s/convenient/modular/ ?
11:59:27 <edwardk> ski: let me go look it up and see if it corresponds to how i deal with covariant and contravariant traits in the presence of generics
11:59:36 <PeakerWork> lilac: I think that either the set of types, or the set of operations, ought to be closed
11:59:46 <PeakerWork> lilac: if they're both open, something's wrong here :)
12:01:11 <monochrom> they should be both closed.
12:01:29 <edwardk> peaker: my counterexample has to do with how pedantic you want to be. the blackbox model you propose and to which i one subscribed requires that you apriori know the grain to which you want to cut up your hierarchy of interfaces into establish what members you want to expose.
12:02:53 <gwern> any advice on how I can strictify this? 'readDB = io $ (dbLocation >>= decodeFile r) `catch` (λ_ →  return empty)'
12:03:05 <mdmkolbe> ZERO HOURS REMAINING! THE DOOM BELL HAS RUNG!
12:03:06 <gwern> I'm unsure how to use $! here
12:03:21 <edwardk> class functor with { map } ; class monad with { bind; return; functor } -- works fine. but when you want to retroactively add class pointed-functor with { return; functor }  you run into the same library rigidity that haskell's typeclasses have.
12:03:49 <ski_> edwardk : <http://www.cs.ru.nl/~erikpoll/papers/index.html>, "Subtyping and Inheritance for Categorical Datatypes" <http://www.cs.ru.nl/~erikpoll/papers/kyoto97.ps.gz>, "Subtyping and Inheritance for Inductive Types" <http://www.cs.ru.nl/~erikpoll/papers/durham97.ps.gz>, "A Coalgebraic Semantics of Subtyping" <http://www.cs.ru.nl/~erikpoll/papers/ita01.ps.gz>, "A Coalgebraic Semantics of Subtyping" <http://www.cs.ru.nl/~erikpoll/papers/cmcs00.ps
12:04:15 <ski_> (edwardk : the abstract links doesn't appear to work now, but it appeared like the paper links still worked)
12:04:18 <edwardk> you can go to the logical extreme of making every single method into an interface and blackbox composing them, but not life sucks for both your library implementors and your users.
12:04:20 <mdmkolbe> @seen Cheshire
12:04:21 <lambdabot> Cheshire is in #haskell-blah, #haskell and ##logic. I last heard Cheshire speak 13m 38s ago.
12:05:08 <Cheshire> hi
12:05:21 <ski_> edwardk : istr those were the most interesting to me, when i browsed around some time ago (and of those, the first two were most interesting, at the time)
12:05:26 <edwardk> implementation inheritance is much reviled because of artifacts in the languages that have provided it. there do exist languages where it works very very well, however. eiffel does wonders using multiple implementation inheritance, by providing extensive renaming/hiding tools
12:05:52 <gwern> ok, maybe my issue is not the strictness of reading, but that doesn't explain where my stack overflow is coming from
12:05:55 <gwern> hm
12:06:35 <edwardk> there it plays the same purpose of blackbox inheritance, but provides intrinsically a lot of the plumbing from the interface to the box
12:06:55 <gwern> if I do: 'Prelude Control.Monad Data.Char Data.List Data.Binary Data.Sequence> foo <- ((decodeFile "foo.db") :: IO (Seq String))
12:07:01 <gwern> then
12:07:03 <gwern> Prelude Control.Monad Data.Char Data.List Data.Binary Data.Sequence> Data.Sequence.length foo
12:07:06 <gwern> *** Exception: stack overflow
12:07:13 <edwardk> the ability to limit exposure to features prevents the brittle base class problem, because you can expose just a portion of it in the flattened rep of your derived class
12:07:16 <defun> Hi. I just tried to compile a parser that imports a module called ApplicativeParsec. Then GHC spits an error about an illegal instance declaration. I'm not sure what's wrong. Here is the code, the module, and the error message (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2010#a2010).
12:07:58 <monochrom> gwern: Perhaps decodeFile needs to be rewritten.
12:08:01 <edwardk> and then derive new functionality in new features, so existing code that uses you in a 'grey box' manner doesn't break. it further aids encapsulation, rather than detracts from it
12:08:02 <ImInYourMonad> I should use a Map String Button instead?
12:08:10 <gwern> 'seq foo (Data.Sequence.length foo)' doesn't work either, not that I expected it too
12:08:22 <ski_> edwardk : interesting .. is this an opinion you've formed yourself, or is there any papers (you know about) arguing this case ?
12:08:35 <gwern> and just 'foo' doesn't work either!
12:08:48 <edwardk> partially an opinion formed by myself but its also fairly prevalent in the eiffel community.
12:09:20 <ski_> how about the covariant argument types of methods ?
12:09:27 <edwardk> they are really just about the only community to throw themselves fully on the 'multiple inheritance as the secret sauce' grenade ;)
12:09:28 <ski_> is it used much ?
12:10:04 <edwardk> the covariant argument crap is unfortunately just a bit of miswiring in bertrand meyer's brain ;)
12:10:28 <ski_> (and how does this compare with O'Caml's solution to binary and recursive method types ?)
12:11:09 <defun> anyone?
12:11:45 <edwardk> the 'self type stuff they use? practically most eiffelers never really use the boilerplate inheritance stuff they get from covariant subtyping of method arguments. the goal is the same.
12:12:40 <ski_> defun : `GenParser' is a type-synonym. Haskell98 doesn't allow instancing classes on type-synonyms
12:13:26 <defun> ski_: then how did this guy get it to work? (http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/)
12:13:26 <ski_> defun : GHC (at least) relaxes this restriction. try giving `-XTypeSynonymInstances' as argument to GHC, to enable this relaxation
12:13:49 <defun> oh.
12:13:55 <defun> ok.
12:13:55 <ski_> defun : alternetively, you could add `{-# LANGUAGE TypeSynonymInstances #-}' to the top of the file
12:13:57 <paper_cc> defun: or {-# LANGUAGE TypeSynonymInstances #-} on the top of the source file
12:13:59 <ziman> defun, this issue is around only since Parsec 3, GenParser is a type synonym for backwards compatibility, iirc
12:13:59 <paper_cc> oops =0
12:14:17 <edwardk> btw- i really like parsec 3
12:14:24 <Cheshire> oh geeez
12:14:35 <defun> ok. thanks.
12:14:38 <Cheshire> I invented "scrap your boilerplate" instead of just reading the paper ...
12:14:41 <ski_> (edwardk : first "they" being O'Camlers ?)
12:14:52 <idnar> You Could Have Scrapped Your Boilerplate?
12:15:03 <edwardk> instance (Monad m) => Stream Text m Char where uncons = return . Data.Text.uncons -- made me very happy
12:15:29 <edwardk> i can now have utf-8 source files _and_ decent performance
12:16:46 <edwardk> ski: i meant that the major use for the covariant typing in eiffel was to do the same thing as the 'self type occurences used in ocaml for binary functions (like ==, etc.)  and that in general the extra functionality that they provide over and above what you can get with the ocaml model is rarely if ever used.
12:16:59 * gwern fulminates against data.binary. screw you and your laziness!
12:17:17 <edwardk> Cheshire: ouch
12:17:23 <pumpkin_> gwern: there's a strict one too isn't there?
12:17:42 <gwern> pumpkin_: that one is useless in several different ways
12:17:48 <pumpkin_> oh
12:17:51 <ski_> (edwardk : the potentially unsafe extra functionality that you get from covariant argument types, yes ?)
12:18:01 <edwardk> yeah
12:18:03 <pumpkin_> gwern: how so? I've been tempted to try it a couple of times but never ended up doing so
12:18:18 <edwardk> the humans eat food, babys as a subtype of human eat baby-food a subtype of food, etc.
12:18:22 <tomh> anyone here uses gtk2hs on a mac?
12:18:44 <gwern> pumpkin_: unmaintained and so out of date, not depended upon by yi, so unusuable, and it doesn't supply the high level IO functions
12:18:45 <edwardk> the covariantly extending an entire hierarchy of classes by analogy
12:18:55 <edwardk> which i think is really a perspective problem
12:19:04 <gwern> geez, my gmail account has no less than 5 or 6 threads complainig about stack overflows tih data.binary
12:19:09 <ski_> edwardk : hm, is there known a "right" way to model that situation ?
12:19:15 <edwardk> i even wrote an article on the idea once after tim sweeney went on a rant about it
12:19:38 <pumpkin_> oh
12:20:48 <ImInYourMonad> in a list of tuples, can the tupel elems have varying type? I want to amke a Map of String Button but then I  cant have progressBar and if i do Widget well Button isnt a Widget.
12:20:52 <edwardk> he was complaining that you often have things like worlds, textures, renderers, etc that are all connected the same way but all subclassed in concert. i pointed out that you can get that common connection machinery out of some intelligent use of generics
12:20:58 <ski_> (maybe this is an instance of <http://caml.inria.fr/pub/docs/manual-ocaml/manual007.html#toc39> 5.3  The subject/observer pattern)
12:21:05 <edwardk> http://comonad.com/reader/wiki;mode=category&item=pattern is a copy of my reply the original site is now defunct
12:21:09 <pumpkin_> ImInYourMonad: no
12:21:17 <ImInYourMonad> ain.hs:10:60: Not in scope: type variable `a'
12:21:36 <pumpkin_> ImInYourMonad: lists are homogeneous, so you'll need to make a wrapper type or something
12:21:52 <edwardk> it didn't reformat for my wiki very well though ;)
12:22:23 <edwardk> http://www.flipcode.com/harmless/issue03.htm apparently also has it
12:22:29 <ImInYourMonad> so anyone using gtk2hs: if I create buttons in different do-methods and then I want to be able to access all buttons later on, how do Ir efer to them? becuase I want to avoid having one huge GUI-declaration in the main.
12:22:44 <edwardk> the pattern is listed in a bunch of pattern repositories and stuff for those who slavishly follow design patterns
12:23:23 <edwardk> nowadays, i wouldn't advocate it quite as written, because it was brittle in that style.
12:23:27 <seliopou> gwern, getting or putting?
12:23:42 <gwern> seliopou: getting. I haven't even gotten up to putting yet...
12:24:16 <EvilTerran> ImInYourMonad, well, you have to return them from the functions that contain the commands creating them
12:24:22 <edwardk> the template <class Baseclass, class Renderer> wrappers on the various Templates would be better served as a reference off to a traits class, so you could extend the overall hierarchy without breaking existing code
12:24:56 <ImInYourMonad> EvilTerran: yes thtas what im trying by putting them in a Map
12:25:06 <edwardk> ski: but yeah in general its mostly a pub/sub issue like you said
12:27:06 <ski_> edwardk : so, could one say you're talking about `parallel hieararchies' problem, there ?
12:27:14 <edwardk> yeah
12:27:26 <lukeo05> I solved the problems I had just by trying to think how to phrase a question to get help on them... Strange...
12:27:52 <ski_> (`parallel inheritance hieararchies', i meant)
12:29:02 <ImInYourMonad> arent there(or could you make) some Monadic datstructure that can contain anything? ie no type checking, a Monadlist [1,"hello",5.0] for example?
12:29:33 <Botje> there's HList
12:29:42 <Botje> but it's not as pretty as normal lists
12:29:46 <edwardk> in any event the name was fairly googleable until around 2003 when the scrap your boilerplate papers started pouring out ;)
12:29:47 <ski_> (edwardk : "pub/sub" meaning ?)
12:29:55 <Cheshire> data Pudding = Useless
12:29:57 <edwardk> publish subscribe
12:30:00 <ski_> (which name ?)
12:30:02 <Cheshire> [Useless,Useless,Useless]
12:30:03 <Cheshire> there
12:30:38 <ski_> edwardk : aha. i hadn't heard that term before
12:32:02 <monochrom> [Golem,Golem,Golem]
12:32:33 <Botje> [Nom, Nom, Nom]
12:35:22 <lukeo05> how can I map 2 functions onto a list, and have the result be a list a tuples?
12:35:47 <pumpkin_> map (f &&& g) list
12:36:00 <opqdonut> zip (map f list) (map g list)
12:36:03 <blackh> ImInYourMonad: You can't put things of different types into a list, but you can use Data.Dynamic for this purpose.  However, whenever you're tempted to use Data.Dynamic, there's usually (but not always) a better way to do it.
12:36:12 <Botje> map (\x -> (f x, g x)) list
12:36:18 <gwern> screw this, I'm just going to use an old yi >.< one which doesn't use data.binary 0.5
12:36:56 <lukeo05> ah, opqdonut: thanks! pumpkin: &&& wasn't in scope, is it not in standard prelude?
12:37:03 <pumpkin_> Control.Arrow :)
12:37:17 <pumpkin_> > map ((+1) &&& (^2)) [1..5]
12:37:18 <lambdabot>   [(2,1),(3,4),(4,9),(5,16),(6,25)]
12:40:48 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2013#a2013 <- my mp3player, I could put everything into main but then it will be a bit ugly in my opinion. so how can I store a list(or some datastructure) of all buttons and widgets so I can access them? are they accessible by querying their parent?
12:40:58 <ImInYourMonad> wait, I can just use a tuple!?
12:41:39 <monochrom> Yes.
12:42:31 <ImInYourMonad> and how do I insert into a tuple?
12:42:54 <monochrom> A tuple is not meant to be inserted.
12:42:59 <blackh> ImInYourMonad: You can't - you have to make a new tuple.  You can use a 'data' but that's no different to a tuple.
12:43:13 <blackh> ...just more convenient because you can name the fields.
12:43:41 <ImInYourMonad> but i need some way to store a progressBar a wdiget and a Button in the same structure
12:43:56 <ImInYourMonad> or I have to use different structure which is fien to i guess but a little bit mesiier
12:44:29 <monochrom> (myProgressBar, myButton)
12:44:39 <ImInYourMonad> duh
12:44:42 <ImInYourMonad> oh no
12:44:47 <blackh> I would probably use a data with named fields, and do this: widgets = Widgets { myPB = ... ; myButton = .... }
12:44:48 <ImInYourMonad> wait because i hav to in
12:44:50 <ImInYourMonad> or wait yes
12:44:54 <blackh> You don't have to insert...
12:44:55 <ImInYourMonad> man im stupid
12:45:09 <monochrom> You have been brainwashed by imperative programming.
12:45:15 <blackh> Remember Haskell doesn't have "statements" - your widgets = line can be really long if you want it to.
12:45:16 <cantor> why is that wrong:
12:45:17 <cantor> count :: Integer -> Float
12:45:17 <cantor> count n = 2n+2+(n(n-1)/2)
12:45:42 <Cheshire> @let count n = 2n+2+(n(n-1)/2)
12:45:43 <lambdabot>  <local>:2:16:
12:45:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -...
12:45:45 <EvilTerran> cantor, because math operators in the prelude return the same type as their parameters
12:45:55 <Cheshire> @let count n = 2n+2+(n*(n-1)/2)
12:45:56 <blackh> cantor: Try:  count n0 = let n = fromIntegral n0 in 2n+2+(n(n-1)/2)
12:45:56 <lambdabot>  Defined.
12:46:00 <Cheshire> > count 4352
12:46:01 <lambdabot>       No instance for (Num (t -> t))
12:46:01 <lambdabot>        arising from a use of `count' at ...
12:46:04 <Zao> Cool. Trying to compile Salsa makes GHC eventually gobble up 2 GiB of memory and keel over.
12:46:08 <EvilTerran> cantor, also because you need a * between numbers to do multiplication
12:46:14 <Cheshire> @let count' n = 2*n+2+(n*(n-1)/2)
12:46:16 <lambdabot>  Defined.
12:46:17 <Cheshire> > count' 4352
12:46:19 <lambdabot>   9476482.0
12:46:28 <Cheshire> cantor, you have to write * for multiplication
12:46:37 <monochrom> There are two reasons you think in terms of "I need to create a data structure and then change its contents and even size". One is a good reason and one is a bad reason.
12:47:10 <cantor> thanks for quick answers
12:47:13 <monochrom> The good reason is you have a loop and you need to make changes every iteration. When you use Haskell you still have to do that.
12:47:30 <SamB> monochrom: sometimes
12:48:09 <monochrom> The bad reason is you need a write-once-read-many thing. Since it's write-once there is no need for general arbitrary unlimited mutation.
12:48:14 * edwardk finally had a use for Data.Dynamic today ;)
12:48:42 <Cheshire> oh what is it?
12:49:19 <edwardk> for maintaining facts in the strongly typed version of my datalog interpreter.
12:49:24 <blackh> My use for Data.Dynamic was an extensible cache, wrapped to make it type-safe.
12:49:43 <mathijs> I have a list of tuples(Integer, Integer) that I need to turn into a list of Integers. the order is a bit strange though: [(a,b),(c,d),(e,f)] -> [a,c,e,f,d,b]. is there a nice way to do this? I currently use "map fst xs ++ reverse (map snd xs)", but I would like to do this without ++ and walking the list 3 times.
12:50:30 <dolio> There is.
12:50:40 <edwardk> Cheshire: it lets me say things like (with a couple of other combinators): instance (Body a, Body b) => Body (a,b) where match facts f = do x <- appropriate facts; y <- appropriate facts; f (x,y)
12:51:43 <mathijs> dolio: I thought so. just couldn't figure it out :)
12:51:44 <edwardk> where appropriate walks through the list of Dynamics and tries to convert them to the right type.
12:51:51 <dolio> Is this a homework problem?
12:52:16 <Botje> mathijs: walk the list and keep the snd elements on a stack
12:52:26 <Botje> when you get to the end of the list, return the stack
12:52:30 <mathijs> dolio: nope, it's something I came across while looking to optimise some of my code.
12:52:44 <dolio> Anyhow, you should fold over the list, and build a function that prepends the fst parts, and prepends the snd parts in the appropriate order.
12:52:55 <dolio> And then apply them appropriately to an empty list at the end.
12:52:57 <edwardk> cheshire: then you can state the inference rules for the engine just using hoas
12:53:17 <dolio> Er, those should be two functions you're building, not one.
12:53:36 <mathijs> dolio: I'm trying in that direction, I'll figure it out I think. Just needed to know that the composition-method would work in this case
12:53:40 <dolio> Although I suppose you could do it with one in this case.
12:53:56 <ImInYourMonad> > foldl (:) [1,2,3] [4..9]
12:53:57 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:53:57 <lambdabot>        Expect...
12:54:00 <mathijs> Botje: the stack thing is still a fold right?
12:54:18 <ImInYourMonad> > foldr (:) [1,2,3] [4..9]
12:54:20 <lambdabot>   [4,5,6,7,8,9,1,2,3]
12:54:25 <dolio> [a,c,e,b,d,f] would need two.
12:55:01 <mathijs> yeah, and then apply an empty list to the second, and apply that to the first
12:55:34 <Gracenotes> ImInYourMonad: looks like you got some concatenation goin' on... yeahrrr..
12:55:35 <mathijs> dolio: so for building the 2 functions, I can keep them in a tuple right?
12:57:11 <Zao> Where does one begin to troubleshoot compiler memory usage regressions?
12:57:50 <monochrom> As in "GHC uses 10GB to compile my 3-char file"? :)
12:58:10 <Zao> From GHC 6.8.3 to 6.10.1 building Salsa's samples go from 35 MiB private bytes to crashing as it hits 2 GiB.
12:58:26 <Zao> There seems to be lots of type magic going on there.
13:00:00 <dons> start by checking against a ghc 6.11 snapshot
13:00:05 <Zao> On my way :)
13:00:08 <dons> since it may be one of the known type family regression bugs
13:02:44 <pejo> "Runtime Support for Multicore Haskell": http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/multicore-ghc.pdf
13:05:12 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2015#a2015 <- how does adding song :: Label cause that error?
13:08:55 <Gracenotes> ImInYourMonad: which song?
13:08:55 <Gracenotes> what type would it be otherwise?
13:08:59 <blackh> ImInYourMonad:   playerstate <- newMVar (PlayerState pl 0 [])  <-- this needs an extra argument
13:09:04 <ImInYourMonad> add ing: song :: Label to the data turns PlayerState to a fucntion instead of a data
13:09:14 <ImInYourMonad> oh duh
13:09:25 <ImInYourMonad> and how do I pass null?
13:09:26 <blackh> PlayerState pl 0 [] is of type Label -> PlayerState
13:09:37 <Gracenotes> ImInYourMonad: make it a Maybe Label, perhaps
13:09:38 <blackh> ImInYourMonad: Use type 'Maybe Label' instead of just Label
13:10:44 <Gracenotes> ImInYourMonad: hm, regarding setting the position to 0... what if there are no songs in the playlist?
13:11:09 <ImInYourMonad> i will check that somehow?
13:11:27 <ImInYourMonad> i still dont know how to play an mp3 anyway :P
13:11:52 <blackh> ImInYourMonad: Use System.Process and start up madplay - yeah!
13:12:04 <Gracenotes> ImInYourMonad: hm, Maybe Label might not be a good idea
13:12:19 <Gracenotes> why don't you try songLabel <- labelNew Nothing
13:12:28 <Gracenotes> and then you can modify it as you change the song
13:12:30 <whpearson> > let test f xs = iterate (concatMap f) xs in take 3 $ test (\x -> (x+1):[x-1])
13:12:32 <lambdabot>   Couldn't match expected type `[a]'
13:12:38 <whpearson> > let test f xs = iterate (concatMap f) xs in take 3 $ test (\x -> (x+1):[x-1]) [1]
13:12:40 <lambdabot>   [[1],[2,0],[3,1,1,-1]]
13:12:51 <Gracenotes> ImInYourMonad: and after you extract songLabel, you can create your playerstate
13:12:57 <Zao> dons: 6.11.20090301 seems to run away with memory too. It differs from 6.10.1 as it required -XGADTs to build Salsa, but otherwise same thing it seems.
13:13:05 <whpearson> I found a nice function for breadth first search :)
13:13:16 <ImInYourMonad> blackh: madplay? some linux player? yeah i guess I could use System.Process over soemthing
13:13:21 <Gracenotes> well, extract is a bad word. After you can use it as a Label in the IO monad
13:14:03 <blackh> ImInYourMonad: There are several command-line players, most are available on Linux/Windows/Mac. Also try mpg321.
13:14:26 * Gracenotes pokes ImInYourMonad :)
13:14:53 <Gracenotes> if you want to use an empty label in the initial state, just initialize it first
13:15:18 <whpearson> I'm not sure how to avoid cycles with this way of doing things though.
13:15:36 <Gracenotes> you might also want to consider StateT PlayerState IO sometime down the line...
13:22:30 <lukeo05> I'm being told I can't use the pattern ((x,y):(xs,ys)) when my input is [(Char, Int)]. What's the problem with that...?
13:22:47 <Cheshire> lukeo05, you unzipped the list
13:22:58 <Cheshire> it' sreally (x,y):xys
13:23:14 <lukeo05> ahah! thanks :D
13:23:49 <ImInYourMonad> takeMVar playerstate >>= putMVar playerstate .
13:23:49 <ImInYourMonad>                (playerstate { song = songName } )
13:23:54 <ImInYourMonad> Couldn't match expected type `PlayerState -> PlayerState'
13:23:54 <ImInYourMonad>            against inferred type `PlayerState'
13:25:15 <blackh> This might do it: modifyMVar playerstate $ \playerstate -> playerstate {song = songName}
13:25:41 <blackh> Thought probably best not to shadow the variable name..
13:25:42 <Zao> Oh well, I've got the discrete workaround of using 6.8.3, but that's not quite a solution :)
13:25:45 <ImInYourMonad>    Couldn't match expected type `IO (PlayerState, b)'
13:25:46 <ImInYourMonad>            against inferred type `PlayerState'
13:25:58 <ImInYourMonad> can i do it just a s a statement though?
13:26:05 <Gracenotes> hrm
13:27:00 <whpearson> take 5 $ test (\(x,y) -> if member x y then [] else ((x+1), insert x y):[(x-1, insert x y )]) [(1, empty)]
13:27:05 <whpearson> > take 5 $ test (\(x,y) -> if member x y then [] else ((x+1), insert x y):[(x-1, insert x y )]) [(1, empty)]
13:27:06 <lambdabot>   Not in scope: `test'Not in scope: `member'    Ambiguous occurrence `empty'
13:27:06 <lambdabot> ...
13:27:11 <Gracenotes> ...
13:27:43 <whpearson> > let test f xs  = iterate (concatMap f) xs in take 5 $ test (\(x,y) -> if member x y then [] else ((x+1), insert x y):[(x-1, insert x y )]) [(1, empty)]
13:27:45 <lambdabot>   Not in scope: `member'    Ambiguous occurrence `empty'
13:27:45 <lambdabot>      It could refer ...
13:28:02 <Gracenotes> > Map.empty
13:28:03 <lambdabot>   fromList []
13:28:13 <Gracenotes> @type Map.member
13:28:14 <lambdabot> Couldn't find qualified module.
13:28:36 <Gracenotes> > Map.member 5 Map.empty
13:28:38 <lambdabot>   False
13:28:44 <ImInYourMonad> gah im close to jsut chucking everything into 1 huge GUI declaration, i dont need that much more anyway so it wont be that messy
13:29:01 <whpearson> > let test f xs  = iterate (concatMap f) xs in take 5 $ test (\(x,y) -> if Map.member x y then [] else ((x+1), Map.insert x y):[(x-1, Map.insert x y )]) [(1, Map.empty)]
13:29:02 <lambdabot>   Couldn't match expected type `M.Map t a'
13:29:14 <Gracenotes> ImInYourMonad: how about modifyMVar_?
13:29:28 <Gracenotes> modifyMVar expects some extra stuff
13:29:29 <blackh> ImInYourMonad: I should have said: modifyIORef playerstate $ \ps -> ps {song = songName}
13:29:48 <Gracenotes> if you just want to change it, use the underscore version
13:30:14 <Gracenotes> @hoogle modifyMVar
13:30:15 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
13:30:15 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
13:30:35 <blackh> Maybe it would be better to have one Label widget, and change its text.
13:30:40 <Twey> Why don't records expose setters?  :-\
13:31:06 <whpearson> > let test f xs  = iterate (concatMap f) xs in take 5 $ test (\(x,y) -> if Set.member x y then [] else ((x+1), Set.insert x y):[(x-1, Set.insert x y )]) [(1, Set.empty)]
13:31:07 <lambdabot>   [[(1,fromList [])],[(2,fromList [1]),(0,fromList [1])],[(3,fromList [1,2]),...
13:31:24 <blackh> Twey: The closest I have managed to get to an answer to this question is: Everyone seems to agree that it's annoying, but it's never been annoying enough for anyone to actually do anything about.
13:31:51 <Gracenotes> having only one Label widget: unpopular when I suggested it 20 minutes ago, still unpopular now
13:32:00 <whpearson> Doh, I meant Set not Map. It travereses this functional graph making sure it doesn't get stuck in loops.
13:32:05 <EvilTerran> it doesn't seem worthwhile to just fix the lack of pointsfree setters, but we can't agree on what else to do
13:32:11 <blackh> Twey: There are all sorts of magic solutions.  I just fill my code with  xyzLens = (xyz, \xyz v -> v {xyz = xyz})
13:33:03 <Twey> 0Haha
13:33:38 <EvilTerran> blackh, that looks suspiciously like a functional reference
13:34:23 <blackh> EvilTerran: Is a 'lens' the same as a 'functional reference'?
13:36:39 <EvilTerran> blackh, i'm not sure; the standard "functional reference" type is "data FRef r a = FRef { get :: r -> a, set :: r -> a -> r }"
13:37:10 <ImInYourMonad> yeah i have one label (widget?) and i want to change its text
13:37:27 <ImInYourMonad> but i construct this label otuside main and i need a reference to it
13:37:46 <blackh> EvilTerran: Ah - I've got my args on 'set' swapped.  I have not reached a final conclusion on which order is neatest.
13:38:16 <EvilTerran> blackh, well, i don't think there's a consensus on that
13:38:32 <Gracenotes> ImInYourMonad: why not construct it in main?
13:38:44 <Gracenotes> then use labelSetText as appropriate
13:39:13 <ImInYourMonad> gracenotes, well i could :) but i wanted to make it more modular. and anyway if u have a more complicated GUI then having everyhting in main is to messy, isnt there a decent solution for this?
13:39:14 <blackh> I also only knew this concept as a 'lens'.  I like (a -> r -> r) better because it's easy to compose a series of modifications.
13:40:38 <ski_> blackh : the `r -> (a,a -> r)' can be more efficient
13:40:45 <ski_> s/can/formulation can/
13:40:56 <Gracenotes> ImInYourMonad: well, I suppose you could have a GUI 'god object' (at first, anyway) that delegates to more specific controls. MVC-ish.
13:41:02 <ski_> you could always define derived composition operators
13:41:09 <EvilTerran> blackh, the page i'm going by is http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
13:41:12 <ski_> (possibly as an instance of `Control.Category' ?)
13:41:57 <EvilTerran> ImInYourMonad, sure, have a utility function of type IO Label (or whatever the type of labels / label handles is) that creates it and returns it
13:42:16 <blackh> ski_: interesting - hadn't considered that
13:42:17 <Gracenotes> EvilTerran: I don't a utility function is needed -- it's newLabel Nothing
13:42:34 <EvilTerran> Gracenotes, well, if that's all there is to it, then i agree
13:42:37 <ski_> EvilTerran : is that twanvl's blog ?
13:42:55 <EvilTerran> ski_, er, i think so
13:43:44 <ispiked> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2017#a2017
13:44:30 <Gracenotes> ImInYourMonad: well, you can get it working by initializing PlayerState with a newLabel. You can pass it around. It's good to have it working first.
13:44:39 <ispiked> I'm not sure what's goingon there?
13:44:47 <Gracenotes> Also, there are other working gtk2hs apps on the internet. Try hackage
13:44:48 <ispiked> s/?//
13:45:40 <Twey> Can one use the GtkHtml widget with gtk2hs?
13:46:10 <dcoutts> Twey: it's not bound, but the mozilla embedding widget is
13:46:16 <blackh> ispiked: It means that it inferred [a] in one place and a in another place - so look for the bit where it's inferring one where you meant the ohter
13:47:18 <ski_> ispiked : `[x] ++ (splitWith f xs)' is the same as `x : (splitWith f xs)'
13:47:19 <ispiked> blackh: it seems like I always return a list
13:47:23 <Twey> dcoutts: Blast.  Thanks :)
13:47:37 <Twey> Gecko's a bit heavy really, I just wanted a formattable text-area
13:47:44 <ispiked> ski_: hmm
13:47:50 <blackh> ispiked: I think the return type of that function is [a] not [[a]]
13:47:58 <dcoutts> Twey: you can get away with an TextView much of the time, it's fairly flexible.
13:48:06 * Twey nods.
13:48:17 <ski_> ispiked : it's not clear whether you actually want to have `[[a]]' as return type ..
13:48:20 <dcoutts> Twey: or if you're prepared to do the work you can use the gtk2hs code gen to get a binding for gtkhtml
13:48:39 <ImInYourMonad> i put everything in one, ugly but easier
13:48:41 <ImInYourMonad> onClicked playBtn (do next playerstate 1;
13:48:42 <ImInYourMonad>                         labelSetText songName >>= getSong playerstate)
13:48:45 <ImInYourMonad> how do i do that really?
13:48:54 <dcoutts> Twey: the code gen gets you perhaps 2/3rds of the way to a binding
13:49:06 <Twey> Interesting
13:49:23 <Twey> I think I just need to look more deeply at TextView, then.  Thanks :)
13:49:45 <ImInYourMonad> =<<
13:49:58 <Gracenotes> ImInYourMonad: why mix do notation and >>=s?
13:50:33 <Twey> Sometimes it makes sense
13:50:40 <opqdonut> yeah
13:50:59 <opqdonut> "a <- foo >>= bar" does when you don't need the value returned by foo
13:51:13 <eu-prleu-peupeu> hello Hppl
13:51:13 <Twey> If you have a <- b; foo a in the middle of a do block and you're not using it anywhere else, you might as well write b >>= foo
13:52:47 <Twey> Yeah, that's a common one too
13:52:47 <eu-prleu-peupeu> anyone here uses fieldTrip ?
13:52:47 <ski_> opqdonut : i prefer `a <- bar =<< foo' ..
13:52:47 * EvilTerran prefers "a <- bar =<< foo" for that, because the <-...=<< looks arrow-y
13:52:47 <Twey> Yeah, looks nice
13:52:47 <opqdonut> yeah that's better
13:52:47 <EvilTerran> visions of piping "foo" through "bar" to get "a"
13:52:47 <ski_> EvilTerran : also, it's no mixed reading order, there
13:52:47 <EvilTerran> indeed
13:53:04 <Gracenotes> I dunno. I'd prefer consistency over terseness. :3
13:53:50 <Twey> Gracenotes: *shrugs* It's consistent really
13:54:14 <Twey> The uses of >>= are very firmly 'within' the do block
13:54:27 <Twey> Semantically speaking.  It doesn't feel like mixing and matching.
13:54:35 <Gracenotes> visually, it does. That's all :)
13:54:53 <Twey> I don't agree :)
13:55:04 <lukeo05> Is there a function like repeat which you can give a number of times to repeat your value?
13:55:22 <Gracenotes> lukeo05: to repeat a function on a value?
13:55:23 <arjanb> :t replicate
13:55:24 <lambdabot> forall a. Int -> a -> [a]
13:56:03 <lukeo05> ah, replicate is perfect. thanks!
13:56:03 <Twey> replicate = take .: repeat, I think
13:56:08 <Twey> @src replicate
13:56:08 <lambdabot> replicate n x = take n (repeat x)
13:56:14 <Twey> Yeah
13:56:40 <Gracenotes> if you're looking for multiple application there's foldr (.) id (replicate n f).. er x.x
13:57:24 <Gracenotes> hm. What would that function be called? It'd be nice in prelude.
13:58:33 <Twey> I can't see it being that useful
13:59:13 <bos> sigh. i get stupider when i pay attention to proggit.
13:59:13 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
13:59:35 <bos> @tell edwardk thanks!
13:59:35 <lambdabot> Consider it noted.
14:00:02 <ImInYourMonad> well: onClicked playBtn (do next playerstate 1; getSong playerstate >>= labelSetText songName) //// first i dont know what the alternative is and I think ti looks clean, do 2 unrelated things and in the second of them chain 2 computations together
14:08:56 <Cheshire> > 1=1
14:08:57 <lambdabot>   <no location info>: parse error on input `='
14:09:27 <EvilTerran> > 1 == 1
14:09:29 <lambdabot>   True
14:10:58 <Gracenotes> > let x = x in let x = x in let x = x in let x = x in let x = x in let x = x in let x = x in let x = x in let x = x in let x =x in let x = x in let x = x in let x = x in let x = x in let x = x in let x = 5 in x
14:11:00 <lambdabot>   5
14:11:49 <blackh> ImInYourMonad: That code looks clean to me.
14:14:27 <ImInYourMonad> blackh: which one?
14:14:42 <blackh> do next playerstate 1; getSong playerstate >>= labelSetText songName
14:14:53 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2019#a2019 <- what i have now
14:15:34 <blackh> I like the =<< and >>= - it's very poetic.
14:17:37 <ImInYourMonad> you mean that i have different ones for the same?
14:17:41 <ImInYourMonad> or just in general?
14:18:17 <eu-prleu-peupeu> anyone here uses the fieldtrip ?
14:18:19 <blackh> ImInYourMonad: The way that you use one for play and one for prev.
14:18:27 <ImInYourMonad> i also like haskell imperative style, functional code always looks prettier but having <- and >>= looks a lot better than: a = a + 2
14:18:30 <Nafai> eu-prleu-peupeu: Never heard of it, what's that?
14:19:03 <eu-prleu-peupeu> its a generator of 3d geometry implemented in a functional style
14:20:39 <eu-prleu-peupeu> i gues ill just subscribe to their mailing list and see if it is still alive
14:20:43 <dons> blackh: join #haskell-in-depth for shootout planning :)
14:22:39 <gwern> anyone have any idea about my stack overflow here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2020
14:22:54 <gwern> I tried the $! thing recommended for binary 0.5 and it seems to have made no difference
14:25:22 <gwern> I find overflow on Seq not a little strange; the Data.Binary read function has seqs all over it
14:25:29 <gwern> so it should be completely strict
14:26:41 <rio> sure youre mixing do-notation and >>= right?
14:26:49 <gwern> rio: it compiles, yes
14:27:26 <eu-prleu-peupeu> i need to look at fieldtrip :/
14:27:34 <gwern> dons: you know a lot about binary, don't you? why might reading in a Seq cause stack overflow?
14:28:29 <gwern> (or maybe I should just go back to Read/Show. even if I fix the binary stuff right now, I'll be way behind on net time expenditure (dealing with Binary vs. waiting for the file to be parsed))
14:31:42 <ImInYourMonad> it would be nice if hackagepackages were viewable i  html without downloading them
14:32:37 <EvilTerran> ImInYourMonad, you can browse the haddocks for packages that have them
14:33:12 <ImInYourMonad> ok i dont know anything about signal processing really. if i want to play an mp3 i need what? a decoder and an interface to hardware?
14:33:15 <EvilTerran> the module names at the bottom of a package's page links to them
14:35:04 <blackh> ImInYourMonad: You can even browse the source code online via the 'source code' links.
14:35:18 <jeffwheeler> I remember there's some name for this funky syntax: "undefined reference to `yizm0zi5zi3_YiziSyntaxziJavaScript_parse_closure'" --- what's that called, and how can I read it?
14:35:56 <tomh> hmm how can I use my own state monad? I use a type MyStateName a = State MyState a ?
14:39:58 <ImInYourMonad> ok i dont know anything about signal processing really. if i want to play an mp3 i need what? a decoder and an interface to hardware?
14:40:11 <ImInYourMonad> if i use the decoder from hackage
14:40:19 <ImInYourMonad> liek what do i do to actually play the file
14:40:44 <pumpkin_> I'm having déjà vu
14:40:45 <shukhov> does anyone have an opinion on Data.Graph?
14:40:57 <pumpkin_> shukhov: it's pretty basic
14:41:08 <ImInYourMonad> shukhov: yeah i hated it
14:41:22 <shukhov> hmm
14:41:26 <shukhov> fgl any good?
14:41:27 <jeffwheeler> shukhov: I found it completely sufficient for simple tasks.
14:41:38 <jeffwheeler> shukhov: (Data.Graph)
14:41:41 <EvilTerran> depending on what you need in a graph representation, Map NodeId (Set NodeId) may be a good option
14:41:42 <pumpkin_> fgl is huge and daunting
14:43:20 <EvilTerran> and it extends nicely to Map NodeId (Label, Set NodeId) for labelled nodes, and Map NodeId (Set (Label, NodeId)) for labelled edges
14:44:40 <shukhov> I just need something todo a weighted nondirected graph
14:45:23 <EvilTerran> ah; the Map Id (Set Id) approach is distinctly directed
14:45:56 <seliopou> speaking of view patterns, it'd be cool to see fgl ported to use view patterns
14:45:59 <EvilTerran> although you could newtype-wrap it up in a module with an appropriate exposed interface to make it work as an undirected graph
14:46:27 <seliopou> that's about the most legitimate of view patterns I can think of
14:46:34 <seliopou> legitmate use
14:46:40 <seliopou> legitimate :(
14:47:19 <pumpkin_> :)
14:47:26 <shukhov> EvilTerran: that's a good idea but I was hoping there might be a really simple solution hiding in some library.
14:47:39 <EvilTerran> (enforce some invariant like the edge pairs all being lower-number-first)
14:48:59 <bombshelter13> Okay, two questions, the latter due to the dificulty I'm having looking up the answer to the first myself. Firstly, I have 'data OrdBox = OrdBox a', how can I make it actually only accept ordinal as? Assuming I have to put a '(Ord a) => ' i a type for it somewhere, but I can't seem to work out the extact syntax. Secondly, can someone recommend a (paper) Haskell book that serves well as a reference manual, for things like this? RWH has
14:50:28 <monochrom> 'data OrdBox = OrdBox a' is not valid haskell. Please clarify.
14:50:55 <ddarius> Abort, Retry, Fail?
14:51:05 <bombshelter13> er, sorry, 'data OrdBox a'
14:51:55 <chessguy_work> @tell boegel you're writing the AI for your sumo bot in haskell, right?? :)
14:51:55 <lambdabot> Consider it noted.
14:52:51 <monochrom> You can do 'data Ord a => OrdBox a = OrdBox a' but it is discouraged. The reason I am unable to articulate.
14:53:08 <monochrom> Also 'Ord' stands for ordered, not ordinal.
14:53:16 <seliopou> also requires -fglasgow-exts, yes?
14:53:27 * bombshelter13 stands corrected on that part.
14:53:27 <monochrom> No it's Haskell 98.
14:53:34 <Riastradh> The reason is that it doesn't add much except a compiler-enforced requirement that all functions accepting an argument of type OrdBox a must have a context of Ord a.
14:54:00 <tomh> Why can't I use 'type A = State X' ?
14:54:02 <dolio> The reason is that matching on OrdBox doesn't provide evidence that the type of its contents is in Ord.
14:54:07 <ddarius> Tomas: You can.
14:54:21 <Riastradh> Even those operations that do not use methods of Ord are required to have the extra context.
14:54:21 <tomh> I imported Control.Monad.State and it said there is no such constructor
14:54:38 <ImInYourMonad> im trying to build mp3player from hackage, the turorial oe and on step 10 out of 0 it gets stuck linking forever, what could be the problem?
14:54:47 <British0zzy> Is there a place where I can find papers on converting declarative code into imperative code? (as in during compilation)
14:54:47 <tomh> oh wait
14:54:51 <tomh> im doing something stupid
14:55:25 <ddarius> Riastradh: That's inaccurate.  All it means is that the data constructor OrdBox has type Ord a => a -> OrdBox a.
14:57:08 <British0zzy> I've heard that GRIN is the part of the compiler which does this.
14:57:09 <Gracenotes> <o-o>
14:57:26 <British0zzy> I haven't been able to find it's paper yet
14:58:12 <ddarius> British0zzy: GRIN is described in Boquist's thesis
14:58:53 <pejo> British0zzy, there's a book about compiling functional languages on Simon Peyton Jones homepage.
14:59:05 <British0zzy> ah, cool thanks
15:00:21 <ddarius> British0zzy: In practice, many compilers for imperative languages convert the code into a purely functional form (as far as local mutations are concerned.)
15:00:29 <tomh> anyone knows a good article about building your own state monad?
15:00:39 <tomh> i mean using the state monad?
15:00:49 <tomh> with your own data type
15:01:07 <ddarius> tomh: There isn't anything special to say.
15:01:29 <ddarius> or I don't understand what you are asking.
15:02:53 <tromp_> :t foldl
15:02:54 <tomh> ddarius: im very confused about the way i have to use state monads
15:03:08 <tromp_> > ()
15:03:22 <tomh> im looking for some more background litarature where they don't expect you to know how to use it by providing the types
15:04:01 <ddarius> Read any monad introduction/tutorial.  I recommend Wadler's "The Essence of Functional Programming"
15:04:36 <tomh> i know how to use the monadic parts of it
15:04:50 <tomh> but not how I can get my datatype A to be acting as state monad
15:05:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:05:01 <lambdabot>   ()
15:05:29 <tomh> damn netsplit
15:05:33 <Tobsan> :o
15:05:38 <Tobsan> yeah that was quite a big one
15:06:37 <ImInYourMonad> how amny frames is an mp3?
15:06:48 <ddarius> tomh: State is a particular monad, it's not an interface.  There's a MonadState class which you can make instances of and all you have to do is provide the methods, but in some sense there is only one "state" monad.
15:07:28 <tomh> mm ok
15:09:50 <pumpkin_> ImInYourMonad: that depends on the mp3...
15:10:21 <tomh> ddarius: What is the best way for a multithreaded environment?
15:11:03 <seliopou> ImInYourMonad, I belive that frame size is always the same, but the number of frames does vary
15:11:16 <ddarius> tomh: I have no idea what you are talking about or what you mean?  "Best way" of doing what?  "Best" in what way?
15:11:43 <ImInYourMonad> sure but i mean roughly...a song is on average 3-4mins, how many frames would that be?
15:11:58 <pumpkin_> depends on bitrate I think
15:12:12 <seliopou> each frame is like 20 ms or something
15:12:26 <seliopou> http://www.mp3-converter.com/mp3codec/frames.htm
15:12:54 <monochrom> A song is on average 10 minutes in my collection.
15:13:02 <pumpkin_> same here :P
15:13:02 <seliopou> 26
15:13:25 <ImInYourMonad> monochrom: stop smoking dope and listening to rave
15:13:33 <tomh> ddarius: If i want to preserve a state between threads, is the best way to do that using the State monad, or build my own instance using MonadState ?
15:13:33 <pumpkin_> o.O
15:13:53 <monochrom> No. Classical music. Beethoven's 9th symphony 4th movement is one track 30 minutes.
15:14:04 <seliopou> so many copies of sandstorm...
15:14:26 <skorpan> pink floyd can beat that...
15:14:27 <monochrom> Now you stop smoking dope and listening to hippies.
15:15:28 <ImInYourMonad> i dont smoke pot but i listen to reagge
15:15:32 <ImInYourMonad> reggae
15:15:47 <skorpan> i don't listen to reggae, but i... oh wait.
15:16:33 <dolio> @yow!
15:16:34 <lambdabot> Am I elected yet?
15:16:49 <ddarius> tomh: State monads won't help at all for that.  And as I said, there is really only one "state" monad.  The MonadState class is for monads that support State-like operations (and usually some other stuff).  Particularly, things like StateT SomeState SomeOtherMonad.
15:17:13 <ddarius> tomh: Look up a read the paper titled "Tackling the Awkward Squad"
15:17:20 <tomh> ok
15:21:29 <tomh> seems MVar is kinda what I want
15:21:36 <tomh> feels so dirty to use that :/
15:21:45 <Twey> Hehe, why?
15:22:01 <dolio> You could use TVars instead. Those are all fancy, and use a different monad.
15:22:15 <tomh> it makes my code impure again
15:22:23 <tomh> lemme lookup TVar
15:22:34 <monochrom> It's ok to be impure like that.
15:23:02 <dolio> Or TMVars, which are different from TVars (and more like MVars) in ways that I've never bothered to learn.
15:23:16 <tomh> ok
15:23:27 <tomh> the TVars use stm
15:23:30 <tomh> what is the benefit?
15:23:39 <dolio> STM is awesome?
15:23:45 <tomh> i dunno, im a noob
15:24:06 <Twey> tomh: STM allows backtracking and stuff
15:24:13 <Twey> As I understand it
15:24:20 <Twey> (it's much slower though)
15:25:23 <tomh> hmm
15:27:03 <Cale> Basically, STM gives you a way to express that certain bits of code should happen as if atomically with respect to other threads. The current implementation of it will do reads automatically, but write changes to variables into a transaction log. Then, when the transaction finishes running, it checks if any of the variables it read from have had their values changed by other transactions which completed in the meantim
15:27:03 <Cale> e. If not, it locks and commits the changes, then unlocks (but the locking is an internal thing you can't see)
15:27:44 <pejo> tomh, STM is supposedly composable
15:28:09 <Cale> In addition to atomic blocks, it gives transactions a way to express that the transaction shouldn't happen now, and should be retried later. It will retry when any value that the transaction read from up to that point has changed.
15:28:57 <Cale> On top of that, there's a way to compose two transactions by saying that the first one not to 'retry' should occur. If they both retry, then the combination retries.
15:29:29 <tomh> ah that STM
15:29:40 <tomh> software transactional memory right
15:29:43 <Cale> yes
15:30:02 <Cale> STM also interacts nicely with exception
15:30:03 <tomh> ah yeah had a talk about it in class, just realized it :0
15:30:03 <Cale> s
15:30:28 <dolio> Whether or not it's much slower probably depends on what exactly you're doing.
15:30:52 <Cale> and on the implementation, of course, which can always improve.
15:30:57 <gwern> > 18 * 3
15:30:58 <lambdabot>   54
15:31:02 <dolio> Yeah.
15:31:32 <Cale> The current implementation is a bit naive.
15:31:58 <tomh> well i can try it
15:32:13 <tomh> probably not that much of a performance problem
15:32:15 <dolio> I don't know if there's much work being done on it currently, though. So it might not be realistic to expect it to get faster very soon.
15:32:27 <ddarius> tomh: Concurrency is impure.
15:32:44 <tomh> i know
15:33:10 <Twey> It's something like 10× slower
15:33:25 <Twey> Nice if you need it, of course, but I would avoid it if not
15:33:37 <ImInYourMonad> does a real mp3player decode while playing? or do they first decode and then load something up in memory?
15:33:52 <Botje> gah
15:33:54 <Botje> i'm stuck
15:34:08 <Botje> anyone care to remind me how you CPS-transform a (begin ...) block?
15:34:18 <Botje> a link to a paper that features it is good too
15:34:20 <ddarius> Botje: The people in #scheme?
15:34:26 <ddarius> Botje: readscheme.org
15:34:58 <blackh> ImInYourMonad: They generally decode while playing.
15:35:46 <ddarius> They do both.  Buffering is the way of the world.  It's the secondary magic after adding a level of indirection.
15:36:14 <Botje> ddarius: i checked some of those papers, but so far haven't found one that explicitly shows how to handle begin...
15:36:49 <ddarius> Botje: This is still not #scheme.
15:37:27 <Botje> sorry. i'll read some more first
15:38:25 <debianguyTFL> so i'm a newb, what does the : operator do?
15:38:32 <debianguyTFL> trying to teach myself
15:38:56 <omnihil> debianguy, given an element 'a' and a list 'b' (a:b) is the list with a at the head and b as the rest of it.
15:38:57 <mornfall> A list constructor.
15:39:00 <mornfall> Ie, cons.
15:39:05 <mornfall> debianguyTFL: ^
15:39:07 <mornfall> Anyway, goodnight.
15:39:08 <debianguyTFL> ah ty ty
15:39:14 <lament> debianguyTFL: if you are trying to teach yourself, as opposed to having #haskell teach you, you're doing something wrong.
15:39:15 <Twey> debianguyTFL: [a, b, c] means a : b : c : []
15:39:27 <debianguyTFL> yea, it's just alot to cram in :P
15:39:28 <Twey> (which is a : (b : (c : [])))
15:39:50 <Twey> I recommend RWH
15:39:58 <Twey> http://book.realworldhaskell.org/read/
15:40:39 <debianguyTFL> thanks
15:40:54 <ispiked> :t (:)
15:40:56 <lambdabot> forall a. a -> [a] -> [a]
15:41:13 <dolio> Botje: Write begin ... like "m >> n >> o >> ..." and then use the Cont monad. :)
15:41:14 <Twey> My goodness
15:41:19 <Twey> ozy` has absquatulated
15:41:43 <Botje> dolio: heh :)
15:43:29 <conal> twanvl: ping.
15:43:42 <twanvl> conal: pong
15:44:03 <conal> twanvl: i'm using simple-expr and want to add some new operators with precedence specs.  it it possible without breaking your module abstraction?
15:46:23 <twanvl> conal: you can define new functions with fun, but the function for making operators (op) is not exported
15:46:44 <conal> twanvl: i wouldn't get infix, right?
15:46:54 <conal> twanvl: without breaking into op?
15:47:21 <twanvl> I could make a new version that does export op
15:47:44 <conal> twanvl: that'd be great.
15:50:45 <ImInYourMonad> the mp3decoder has a c interface, to use ffi, can i do that in ghci?
15:50:56 <ImInYourMonad> i cant right since C is static
15:51:13 <ImInYourMonad> or i can since it just calls the bianries or soemthing?
15:54:16 <drhodes> @let absquatulated = "To depart in a hurry; To die; 2. To argue."
15:54:17 <lambdabot>  Defined.
15:54:46 <pumpkin_> that's an awesome verb
15:56:26 <ImInYourMonad> @faq absqualated
15:56:27 <lambdabot> The answer is: Yes! Haskell can do that.
15:56:36 <ImInYourMonad> @src absqualated
15:56:37 <lambdabot> Source not found. stty: unknown mode: doofus
15:58:51 <twanvl> conal: done, simple-reflect 0.2 is now on hackage
15:59:53 <Peaker> are you supposed to use QuickCheck when your tests are planned, and not really fuzzy?
16:00:39 <ddarius> Unit tests are just nullary properties.
16:01:09 <ImInYourMonad> does QuickCheck come with ghc?
16:01:51 <pumpkin_> twanvl: what's new in it?
16:01:52 <conal> twanvl: hurray!  i'll grab it now.  thanks a bunch.
16:02:19 <twanvl> pumpkin_: the only change is that I export 'op' which allows you to define new infix operators
16:02:24 <pumpkin_> ah :)
16:03:39 <conal> i'm unparsing my expression types to string via Expr.  twanvl saved me the work of mucking with precedences & parens.
16:05:10 <pumpkin_> cool
16:05:33 <Peaker> ddarius: not sure what you're saying there? :)
16:07:21 <yav> Peaker: if you don't need to generate random values, then you probably do not need quick-check.
16:07:32 <McManiaC> haha
16:07:36 <Peaker> yav: ah, thanks
16:07:50 <ImInYourMonad> so does QUickCheck come with ghc or not(6.10)?
16:08:01 <McManiaC> just cut 19 lines of code down to one single line
16:08:08 <dolio> Did it ever come with it?
16:09:44 <edwardk> ‎/nick edwardk
16:09:44 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
16:09:54 <edwardk> hah woops
16:10:38 <ImInYourMonad> Module QuickCheck (distributed with Hugs and GHC).
16:10:42 <ImInYourMonad> http://www.cs.chalmers.se/~rjmh/QuickCheck/
16:11:02 <pumpkin_> there you go
16:11:49 <drhodes> :t (~)
16:11:51 <lambdabot> parse error on input `)'
16:12:21 <ImInYourMonad> where is chr and ord?
16:12:27 <drhodes> Data.Char
16:12:31 <skorpan> @hoogle chr
16:12:31 <lambdabot> Data.Char chr :: Int -> Char
16:12:31 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
16:12:31 <lambdabot> System.Posix.Internals c_s_ischr :: CMode -> CInt
16:13:05 <ImInYourMonad> well the module doesnt work
16:13:20 <pumpkin_> ?
16:13:38 <skorpan> what doesn't work?
16:13:46 <pumpkin_> IRC clients should catch "doesn't work" before you type it and blink it in red
16:13:57 <h0tzenpl0tz> i need a light xml-lib for amazon's rest-api-responses. is HaXml the right choice? when using xmlParse('), how do I omit the required error-log-filepath? thanks!
16:14:10 <pumpkin_> s/type/send/
16:14:39 <ImInYourMonad> http://www.cs.chalmers.se/~rjmh/Software/h++.html <- why the hell do people do stuff like that, did OO have such a grip on the world that it "had to be in there" in a "real language"?
16:15:58 <ispiked> "Last modified: Mon Mar 26 11:24:51 MET DST 2001 "
16:17:33 <flippo> Oh good.  Now that it has OO, I can use it.
16:22:58 <h0tzenpl0tz> is it normal that a "cabal install HaXml" prints hundreds of warnings when building?
16:23:08 <pumpkin_> yup
16:24:07 <h0tzenpl0tz> are the ghc-warnings so strict that avoiding them is a burden or such?
16:27:22 <edwardk> @pl do x <- foo; y <- bar; f (x,y)
16:27:23 <lambdabot> (line 1, column 12):
16:27:23 <lambdabot> unexpected ";"
16:27:23 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
16:27:38 <edwardk> @pl \f -> do x <- foo; y <- bar; f (x,y)
16:27:38 <lambdabot> (line 1, column 18):
16:27:39 <lambdabot> unexpected ";"
16:27:39 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
16:27:57 <edwardk> @pl \f -> do { x <- foo; y <- bar; f (x,y) }
16:27:58 <lambdabot> (line 1, column 10):
16:27:58 <lambdabot> unexpected "{"
16:27:58 <lambdabot> expecting variable, "(", operator or end of input
16:28:08 <edwardk> oh wait undo
16:28:21 <edwardk> @undo do { x <- foo; y <- bar; f (x,y) }
16:28:21 <lambdabot> foo >>= \ x -> bar >>= \ y -> f (x, y)
16:28:33 <edwardk> @pl \f -> foo >>= \ x -> bar >>= \ y -> f (x, y)
16:28:33 <lambdabot> (foo >>=) . ((bar >>=) .) . (. (,)) . (.)
16:28:41 <edwardk> yeah i think i'll pass on that one lambdabot
16:28:49 <ddarius> @. pl undo do x <- foo; y <- bar; f (x,y)
16:28:49 <lambdabot> (bar >>=) . (f .) . (,) =<< foo
16:29:53 <ddarius> liftM2 (curry f) foo bar
16:30:04 <ddarius> Almost.
16:30:16 <ddarius> join (liftM2 (curry f) foo bar)
16:31:26 <edwardk> @. pl undo \facts f -> do x <- appropriate facts; y <- appropriate facts; f (x,y)
16:31:27 <lambdabot> ap ((.) . (>>=) . appropriate) ((. ((. (,)) . (.))) . (.) . (>>=) . appropriate)
16:41:08 <h0tzenpl0tz> is runProcess some linux-cmd? cabal.exe fails when installing HXT
16:41:38 <dcoutts> it's a function in the System.Process module
16:41:47 <dcoutts> used to invoke external programs
16:42:18 <h0tzenpl0tz> is it posix-only? working under vista
16:42:29 <dcoutts> h0tzenpl0tz: it's portable
16:42:51 <dcoutts> h0tzenpl0tz: you'll have to give more details on the problem, eg an hpaste of the build log
16:43:12 <dcoutts> and I'm afraid you'll have to get someone else to help, I'm off to bed! :-)
16:43:15 <dcoutts> g'night
16:43:20 <h0tzenpl0tz> thank you
16:43:31 <h0tzenpl0tz> good night
16:43:48 <ImInYourMonad> runCommand is what i use on windows
16:46:46 <ImInYourMonad> when implementing findMinimum on a binary search tree, i need some way to rep neg infinity as starting min value, how?
16:48:06 <robothass> is anyone familiar with the ID3 tree algorithm?
16:48:48 <robothass> decision tree induction...
16:49:10 <mmorrow> ImInYourMonad: (Ord a) => Maybe a
16:49:20 <mmorrow> ImInYourMonad: Nothing := -oo
16:50:56 <ImInYourMonad> huh?
16:51:27 <pumpkin_> represent neg infinity with Nothing
16:51:31 <ImInYourMonad> ah duh
16:51:33 <pumpkin_> and anything else with Just
17:01:13 <ImInYourMonad> binary search tree: finding the minimum is just going the lef tutil you meet a leaf?
17:01:34 <skorpan`> yes, i think so
17:03:04 <bremner> ImInYourMonad: yes
17:04:26 <ImInYourMonad> makeTree = Node 10 (Leaf 5) (Node 10 (Leaf 6) (Leaf 7))
17:04:33 <ImInYourMonad> thats not a bst, just a bt?
17:04:57 <skorpan`> that's right
17:05:15 <ImInYourMonad> or wait it is ok right?
17:05:24 <ImInYourMonad> root is 10 so right can be 10
17:05:28 <ImInYourMonad> and lef tis smaller
17:05:32 <skorpan`> oh, right, heh
17:05:39 <skorpan`> no, wait
17:05:45 <skorpan`> the rightmost leaf is greater than its parent
17:05:51 <skorpan`> in a binary search tree, that can't be
17:06:05 <ImInYourMonad> it is not greater
17:06:28 <ImInYourMonad> p 10 left 6 left 7
17:06:41 <ImInYourMonad> p 10 left 6 right 7
17:06:42 <skorpan`> i'm confused
17:06:45 <ImInYourMonad> lol
17:06:45 <skorpan`> that's not a binary search tree.
17:06:49 <skorpan`> at all!
17:06:53 <ImInYourMonad> why not?
17:07:15 <skorpan`> the top-most node is fine, it's left child is less than itself and its right child is equal to it
17:07:25 <skorpan`> but (Node 10 (Leaf 6) (Leaf 7)) doesn't make sens
17:07:33 <wolverian> ImInYourMonad: http://en.wikipedia.org/wiki/Binary_search_tree
17:07:33 <ImInYourMonad> oh wait right must be bugger than node
17:07:40 <wolverian> right.
17:07:47 <skorpan`> yes, and the 6 doesn't make sense either, i think
17:07:55 <ImInYourMonad> now it is: makeTree = Node 10 (Leaf 5) (Node 10 (Leaf 6) (Leaf 17))
17:08:03 <wolverian> that's wrong as well.
17:08:07 <ImInYourMonad> you mean the 6 is wrong
17:08:18 <wolverian> everything to the right of root must be greater than the root.
17:08:53 <ImInYourMonad> makeTree = Node 10 (Leaf 5) (Node 10  (Leaf 11) (Leaf 17))
17:08:53 <skorpan`> Node 10 (Leaf 5) (Node 11 (Leaf 10) (Leaf 17))
17:09:29 <wolverian> skorpan's is correct.
17:09:57 <skorpan`> ImInYourMonad: now your Leaf 11 is greater than its parent
17:10:28 <wolverian> left leaf.
17:10:57 <mmorrow> here's a short RedBlack tree implem (despite the module name) http://darcs.haskell.org/yhc/src/compiler98/Util/Tree234.hs
17:11:17 <pumpkin_> oh I remember that
17:11:20 <mmorrow> hehe
17:13:02 <mmorrow> i translated that to C pretty easily actually (which is why it's fresh in my mind)
17:13:34 <pumpkin_> I like how flat that code is
17:13:51 <mmorrow> yeah, me too
17:14:40 <seliopou> robothass: I know a little about decision trees
17:15:00 <mmorrow> one thing though is that it doesn't have treeDelete..
17:15:16 <mmorrow> (and i haven't bothered looking up how the delete from rbtrees)
17:15:16 <lispy> > let ones = 1 : ones in sum ones
17:15:27 <lambdabot>   mueval: Prelude.read: no parse
17:15:34 <lispy> no parse??
17:15:43 <lispy> > let ones = 1 : [] in sum ones
17:15:47 <lambdabot>   1
17:15:52 <mmorrow> , let ones = 1 : ones in sum ones
17:15:56 <lunabot>  luna: out of memory (requested 1048576 bytes)
17:16:25 <mmorrow> , let ones = 1 : ones in scanl (+) 0 ones
17:16:25 <lispy> > sum (fix (1:))
17:16:26 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
17:16:44 <lispy> oh scanl
17:16:46 <mmorrow> , scanl (+) 0 (fix(1:))
17:16:47 <lispy> nice
17:16:47 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
17:16:53 <mmorrow> scanl++
17:17:04 <pumpkin_> did you kill lambdabot?
17:17:09 <mmorrow> , fix ((0:) . scanl (+) 1)
17:17:11 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
17:17:18 <mmorrow> > 42
17:17:22 <lambdabot>   42
17:17:44 <dons> pumpkin_: probably useful to point people to the actual uvector repo, otherwise we won't know if bugs are closed in the head or not.
17:17:46 <lispy> She's just being slow
17:18:04 <lispy> Hey dons, how's it going?
17:18:13 <dons> hey
17:18:13 <bjorkintosh> does haskell have a set of primitives similar to lisp and scheme's?
17:18:23 <dons> what kind of primitives?
17:18:29 <pumpkin_> dons: I didn't know I was pointing people to the other one... I've told people that I've put a few changes in mine, but never claimed it was an official one :)
17:18:40 <bremner> bjorkintosh: sure, if you mean car and cdr
17:18:40 <dons> k.
17:18:41 <pumpkin_> but I'll try to avoid it :)
17:18:44 <lispy> bjorkintosh: Haskell isn't as circularly defined if that's what you're after
17:19:20 <lispy> > let car = head in car [1..10]
17:19:21 <lambdabot>   1
17:19:29 <lispy> > let cdr = tail in cdr [1..10]
17:19:31 <lambdabot>   [2,3,4,5,6,7,8,9,10]
17:19:37 <bjorkintosh> lispy, yeah.
17:19:57 <bjorkintosh> that's what i was after.
17:20:20 * bremner hates it when he answers the question by mistake
17:20:35 <lispy> bremner: heh
17:21:25 <lispy> bjorkintosh: In Haskell, you can get things like short curcuit evaulation for "free" due to the laziness.  So that means you don't need lisp's macro system to define "special forms"
17:21:55 * SubStack lazily evaluates lispy
17:22:18 <lispy> bjorkintosh: for example, you could just define "if" as a normal Haskell function and the evaluation of the guard would automacially happen in the lazy language without needing to add a layer or macro
17:22:47 <lispy> bjorkintosh: so in a sense, haskell is actually more primitive
17:22:49 <pumpkin_> dons: but I can try to open tickets on the trac for bugs I find (and provide patches where I can)... what I've been doing mostly is just mentioning bugs I find in the commit messages
17:23:00 <pumpkin_> (bugs I find and squash, that is)
17:23:20 <mmorrow> you can simulate lazy eval to an extent in a functional language by wrapping everything in: e ==> (\() -> e)
17:23:36 <dons> pumpkin_: ok. i'll just have to resync from git somehow
17:23:42 <mmorrow> e.g. in sml or javascript
17:23:43 <pumpkin_> git?
17:24:16 <wli> lispy: Not exactly the general case. For sorting by comparisons and exchanges.
17:24:57 <dons> pumpkin_: aren't you hosting your patches in github?
17:25:00 <bremner> mmorrow: true, I demoed infinite lists in Oz the other day using cons pairs of ints and functions
17:25:27 <mmorrow> bremner: yeah, it works fairly nicely
17:25:29 <pumpkin_> dons: oh, Manlio's email is what made you mention this, I see. Nope, I'm doing it on patch-tag and kept the repo as darcs-1 to be easily pullable back if you wanted to
17:25:41 <bremner> It's a bit like OO in perl, all the wires and knobs are showing
17:25:57 <dons> ah cool
17:26:13 <mmorrow> bremner: heh, yeah that's a way to put it
17:26:32 <pumpkin_> dons: fwiw, I did mention to him that it was fixed on your repo too :) just that the fix was a little broken for 32-bit archs
17:26:39 <pumpkin_> so I fixed the fix in my copy
17:29:40 <dons> could you send me a patch - i don't like the head branch being broken
17:30:22 <pumpkin_> sure, of just the fix to the fix?
17:31:17 <dons> for now. i'll have to review the other patches too. pulling those from a darcs repo will be easiest.
17:32:11 <pumpkin_> okay, let me see if I can figure out how to pull something specific like that out of my darcs copy :)
17:58:01 <robothass> anyone explain input arguements for adecision tree to me? They are Examples, Target_attributes and Attributes.
17:58:31 <robothass> I am confused as to what Examples represents and how its used in the tree
18:03:28 <chessguy> robothass, are you looking at some particular code?
18:11:26 <pumpkin_> dons: sent
18:14:25 <mmorrow> heh, "liboleg"
18:15:10 <pumpkin_> mmorrow: did you see my pretty printed disassembler output?
18:15:26 <robothass> chessguy: not particular code, but an explanation of those 3 inputs
18:15:41 <mmorrow> pumpkin_: no, hpaste?
18:15:57 <pumpkin_> mmorrow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1976 isn't it purty? soon I'll start adding logic to avoid interpreting the two words of data at the end as code
18:16:16 <mmorrow> rad!
18:16:18 <robothass> chessguy: as far as i understand, Target_att and att are the attributes in an input file (of type arff)
18:16:34 <pumpkin_> yeah!
18:16:39 <robothass> chessguy: however, I do not understand what examples do ? and what they are...
18:16:52 <pumpkin_> I'm going to make sure I meet the ARMv7 spec though
18:17:08 <pumpkin_> apparently they have UAL, which uses all the same mnemonics for thumb and arm
18:17:08 <mmorrow> pumpkin_: so you're writing an assembler too, correct?
18:17:18 <pumpkin_> eventually, although I'm not as interested in that direction :P
18:17:24 <mmorrow> ah, gotcha
18:17:26 <robothass> chessguy: http://en.wikipedia.org/wiki/ID3_algorithm
18:17:32 <pumpkin_> but I'd like to make it complete that way
18:17:55 <pumpkin_> I may be more tempted to once I (or anyone else) gets GHC running on the iphone
18:18:24 <mmorrow> pumpkin_: that'd be so cool to have a "generic-harpy-ish" framework/model for (runtime) assemblers
18:18:32 <pumpkin_> yeah, it would
18:18:51 <pumpkin_> it would be nice to tie into harpy somehow, but I really didn't like how their disassembler for x86 was structured
18:18:54 <pumpkin_> so I did it differently
18:18:55 <mmorrow> then you just fill in a `Mach' record for whatever machine and go
18:19:22 <pumpkin_> but having an abstraction layer sitting on top of this package and harpy
18:19:26 <mmorrow> pumpkin_: i'm thinking more to take harpy's good ideas, drop the "bad", and do it from scratch
18:19:30 <pumpkin_> that dealt with the differences
18:19:31 <mmorrow> yeah, totally
18:19:32 <pumpkin_> yeah :)
18:19:49 <pumpkin_> and erikc said he was tempted to do PPC now that I was doing ARM
18:19:55 <mmorrow> sweet
18:19:56 <pumpkin_> then we'd have the "big 3" out of the way :P
18:20:18 <mmorrow> that'd be awesome
18:20:47 <mmorrow> then we juts need an analogous generic linker/loader framework and it's ON!
18:20:49 <pumpkin_> my main interest is to have something similarly generalized sitting on top of those same archs
18:20:53 <pumpkin_> but for disassembly
18:21:00 <pumpkin_> having a higher-level static analysis package
18:21:13 <mmorrow> oh cool, i see
18:21:23 <pumpkin_> that can take any of the object formats that erikc made, and take any of the archs that sit within
18:21:29 <pumpkin_> and do some fun analysis on them
18:21:48 <mmorrow> you could also do all kinds of cool stuff like on-the-fly mach code rewriting
18:21:54 <mmorrow> or something
18:22:01 <pumpkin_> yeah :) sounds difficult though
18:22:03 <pumpkin_> but could be fun
18:22:05 <mmorrow> heh
18:22:15 <mmorrow> yeah, i have no idea a use case off the top of my head
18:22:32 <mmorrow> i guess vmware is the only i can think of
18:22:51 <mmorrow> which (as i understand it) rewrites kernel code on the fly
18:22:58 <pumpkin_> ah, I've never looked into it
18:23:33 <mmorrow> there's a paper that i've been meaning to read over
18:23:41 <mmorrow> don't recall where though
18:23:51 <pumpkin_> about virtualization?
18:24:01 <mmorrow> about vmware's method(s) in particular
18:24:20 <mmorrow> how they rewrite kernel code to run on the metal in usermode
18:24:37 <mmorrow> or something like this
18:25:00 <mmorrow> and they insert instructions to jump back to vmware control, etc
18:25:05 <mmorrow> (or something)
18:25:16 <pumpkin_> ah
18:25:56 <chessguy> robothass, have you looked at http://hackage.haskell.org/packages/archive/DecisionTree/0.0/doc/html/src/Data-DecisionTree.html ?
18:27:08 <robothass> chessguy: no I haven't, let me check it now. Thanks alot mate
18:27:31 <twb> Terminology brainfart: what do you call the constructors F and G that create values of type T where datatype T x = F x | G x?
18:27:43 <twb> Are they called "constructors" or something else?
18:28:09 <chessguy> yes, they're data constructors
18:28:12 <twb> Thanks.
18:30:14 <pumpkin_> http://code.haskell.org/~dons/code/ ghc-core is the bomb
18:30:41 <twb> pumpkin_: hoho, "core bomb"
18:30:50 <twb> That is a pune or play on words.
18:31:03 <pumpkin_> you think that's why the icon is there?
18:31:56 <twb> The HIGs tell you not to use puns as icons, because they aren't portable to other (human) languages.
18:32:24 <robothass> chessguy: did you check out wikipedia, ID3 algorithm?
18:32:38 <mmorrow> pumpkin_: i had to search the #haskell logs for the link, this is the paper (i think) i'm thinking of (x86-specific) http://www.vmware.com/pdf/asplos235_adams.pdf
18:32:52 <mmorrow> i think there's another paper, but i can't remember where
18:33:11 <pumpkin_> cool, thanks :)
18:43:11 <mmorrow> pumpkin_: it'd be cool if your prettyprinter also had "aligned columns" mode that did the equiv of "column -tx"
18:43:28 <pumpkin_> yeah, I'm going to give it a few options eventually
18:43:41 <pumpkin_> and will probably have aligned columns by default
18:44:15 <mmorrow> the only sucky thing with that though is you have to scan the entire output before you can output anything..
18:45:27 <pumpkin_> oh, I was just going to do it the dumb way and approximate :)
18:45:41 <mmorrow> ahh ;)
18:51:11 <TomMD> Is there already Parsec code for IPv6 addresses?
18:51:34 <mmorrow> dons: is there any reason (that you know of) that Data.Map uses "Efficient sets -- a balancing act." from 1993 rather than some okasaki structure/algo ?
18:51:52 <mmorrow> (other than that it already exists)
18:56:36 <lstor> Is there a built-in delay/sleep function? I'm browsing http://www.haskell.org/ghc/dist/current/docs/libraries/ but can't seem to find what I'm looking for
18:56:47 <dons> mmorrow: it already existed
18:56:47 <Zao> dons: It seems that the runaway memory usage was known by the library author, as a fix is in darcs to disable his "Array" for 6.10
18:58:21 <brool> if i'm benchmarking a function, is there an easy way of ensuring that the code actually gets executed n times?  Haskell's optimizer keeps pulling the function out of the loop...
18:59:15 <dons> brool: yeah, in general, http://haskell.org/haskellwiki/Timing_computations
18:59:24 <dons> its easier if your code is side effecting
18:59:29 <dons> otherwise you can lift it into IO with 'evaluate'
18:59:39 <dons> remember to use 'rnf' or 'seq' to evaluate it the result deeply enough as well
18:59:46 <dons> then you can defeat both the optimiser, and laziness
19:00:04 <brool> dons: tyvm!  will read up
19:00:11 <wli> Printing it does wonders as well.
19:00:26 <wli> Assuming it's of observable type, anyway.
19:00:31 <brool> wli: yah, but then the printing is counted in the timing
19:01:48 <wli> Depends on how big the result is, sure. Or if the thing you're doing is a modification of a preexisting huge structure vs. building up all its own structures from scratch.
19:03:26 <mmorrow> dons: i see
19:28:17 <kerlo> @type all
19:28:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:29:43 <kerlo> What's the latest version of GHC that apt-get will get?
19:30:20 <pumpkin_> 6.8
19:30:23 <Cale> kerlo: In Ubuntu, 6.8.3
19:30:29 <SubStack> in what?
19:30:34 <pumpkin_> debian/ubuntu
19:33:25 <SubStack> looks like 6.10 is floating around in experimental
19:35:19 <kerlo> I'm still waiting for a fix for #2063.
19:35:28 * kerlo shrugs
19:37:14 <NameAlreadyInUse> i don't really understand the halting problem
19:37:37 <pumpkin_> NameAlreadyInUse: do you get russell's paradox?
19:37:42 <NameAlreadyInUse> yeah, i do
19:37:55 <kerlo> NameAlreadyInUse: is there anything in particular you don't understand about it?
19:38:10 <pumpkin_> NameAlreadyInUse: it's pretty much the same issue as russell's paradox
19:38:16 <NameAlreadyInUse> and i have read the Dr Seuss explanation, but at the end it says "So we users must find our own bugs"
19:38:29 <NameAlreadyInUse> but surely if a human can spot a bug in some source code, a computer should be able to as well?
19:38:34 <kerlo> Well, the halting problem itself is just a question.
19:38:57 <kerlo> Indeed, if a human can tell that something won't halt, a computer ought to be able to.
19:39:16 <pumpkin_> NameAlreadyInUse: just write a program that neither halts nor doesn't
19:39:19 <pumpkin_> :P
19:39:36 <kerlo> If a computer can't tell it won't halt, why should a human be able to do the same?
19:39:38 <Pegazus_> kerlo: halting problem is just for computeres...
19:39:42 <wli> They can. Any single program can't do it for all possible programs.
19:39:56 <Pegazus_> there is no proof a human can't tell for each single program, if it finishes or doesn't :p
19:40:02 <pumpkin_> putStrLn "can you please read my source code and determine if I'm going to halt? Tell me Y/N" and then go do the obvious
19:40:22 <kerlo> Can I say "N" for "no, I can't"?
19:40:31 <pumpkin_> nope, just no you won't halt
19:40:35 <NameAlreadyInUse> wli: but that is the relevance of that? surely the programs that are truly undecidable would be rare, right?
19:40:35 <wli> putStrLn "Sure, why not?"
19:40:40 <kerlo> Pegazus_: no proof a human can't, but I invite you to try. :-P
19:40:54 <wli> NameAlreadyInUse: No idea.
19:41:04 <kerlo> NameAlreadyInUse: that's kind of an interesting question, really.
19:41:04 <pumpkin_> NameAlreadyInUse: right, so while it's impossible in the general case, people are still trying to do it for certain classes
19:41:19 <pumpkin_> http://research.microsoft.com/en-us/um/cambridge/projects/terminator/
19:41:35 <kerlo> If I had to make a rough estimate right now, I'd say that 10% of non-halting programs due so unprovably.
19:41:52 <pumpkin_> is that part of the 80% of statistics that are pulled out of one's ass? :P
19:41:52 <NameAlreadyInUse> interesting link pumpkin_
19:41:53 <Pegazus_> <NameAlreadyInUse> but surely if a human can spot a bug in some source code, a computer should be able to as well? ---> can you say given a photograph, if a woman is pretty or she isn't?
19:42:02 <kerlo> Yes, it is.
19:42:27 <NameAlreadyInUse> Pegazus_: no, i can only say if she is pretty to me
19:42:33 <Pegazus_> ok
19:42:35 <kerlo> Give me a formal definition of "is pretty" and I'll tell a computer how to determine it...
19:42:42 <NameAlreadyInUse> Pegazus_: but the halting problem is undecidable for humans as well
19:42:49 <Pegazus_> and can you make a program that tells if a woman is pretty to you? given a jpg file? :)
19:43:01 <Pegazus_> NameAlreadyInUse: is not....
19:43:10 <pumpkin_> what about my program?
19:43:10 <kerlo> Just a moment, let me upload my brain and check.
19:43:24 <kerlo> pumpkin_: your program takes input, quite unfortunately.
19:43:26 <NameAlreadyInUse> Pegazus_: if the human was used as the procedure P in that example, for instance
19:43:36 <pumpkin_> kerlo: what's wrong with that?
19:43:45 <NameAlreadyInUse> the program just asks its user to tell it whether it will halt or not, then do the opposite
19:43:49 <kerlo> The halting problem only concerns programs that don't. :-P
19:43:58 <kerlo> Pegazus_: you believe that humans can solve the halting problem in general?
19:44:12 <adamvo> hi, are the pattern guard extensions for ghc (manual 8.3.4. Pattern guards) matched top to bottom, left to right?
19:44:12 <pumpkin_> kerlo: you can abstract away from it, and consider the human being asked the question as a function
19:44:25 <Pegazus_> there are things that a human can do, and not computer to the date can... (at least as far as i know :p)
19:44:55 <NameAlreadyInUse> Pegazus_: a computer could be programmed to recognize an attractive female
19:45:04 <drhodes> adamvo: top to bottom order of execution, AFAIK
19:45:11 <Pegazus_> NameAlreadyInUse: the halting problem is based on turing machines... you can't model an "interactive program" with a turing machine...
19:45:23 <kerlo> The halting proof isn't about today's computers, though; it's about computers from now until someone disproves the Church-Turing thesis.
19:45:25 <Pegazus_> NameAlreadyInUse: prove it :)
19:45:35 <NameAlreadyInUse> if it had some sort of advanced facial recognition technology, it might check for facial traits that make females appear attractive to me
19:45:46 <NameAlreadyInUse> such as nose/chin/brow ratio etc
19:45:57 <wli> Well, the Church-Turing thesis isn't a theorem per se.
19:45:57 <Pegazus_> and the program will always give the same opinion as you? with 100% accurracy?
19:46:12 <altmattr> can anyone tell me about tak.hs from no-fib?
19:46:13 <adamvo> I thought that it was as normal: I just have some a small doubt because I don't get warnings about overlapped patterns
19:46:22 <altmattr> I mean, I have the code, but what is it about?
19:46:23 <NameAlreadyInUse> no, because there are other factors that might influence my decision
19:46:23 <Pegazus_> kerlo: i surely don't... but it hasn't been proved :)
19:46:27 <NameAlreadyInUse> like my current mood
19:46:36 <altmattr> I mean, I see what it does, but why is it included?
19:46:40 <altmattr> that sort of thing :)
19:46:41 <Pegazus_> so you can do something, a computer can't...
19:46:54 <Pegazus_> a computer can't simulate with 100% accurracy your behavior...
19:46:55 <kerlo> I'd call the Church-Turing thesis a theory.
19:47:02 <Pegazus_> so you might be able to do some things a computer can't....
19:47:10 <NameAlreadyInUse> in order to get 100% accuracy, i would have to encode the entirety of my experience into it
19:47:15 <kerlo> Though I may need to be reminded of the definition of "theory".
19:47:17 <Pegazus_> exactly
19:47:29 <Pegazus_> and up to this date, no one i know has been able to do that...
19:47:31 <NameAlreadyInUse> Pegazus_: but that doesn't mean that it is impossible
19:47:41 <Pegazus_> so up to this date, humans intelligence beats computers :p
19:47:46 <Pegazus_> (with enought time :p)
19:48:02 <TomMD> Namely because the human can leverage the computer.
19:48:05 <NameAlreadyInUse> Pegazus_: up until a few decades ago, no one had made the internet
19:48:28 <Pegazus_> NameAlreadyInUse: i agree... and that a computer can't solve the halting problem, doesn't mean either than a human can't...
19:48:42 <pumpkin_> the general halting problem?
19:48:59 <NameAlreadyInUse> i think the halting problem is undecidable in general
19:48:59 <pumpkin_> the question itself is paradoxical, in the general case, isn't it?
19:49:00 <Pegazus_> for any arbitrary algorithm tell if it's halts or not...
19:49:14 <Pegazus_> <NameAlreadyInUse> i think the halting problem is undecidable in general --> by a turing machine or equivalent computer
19:49:16 <kerlo> I think the Church-Turing thesis is falsifiable; would you guys agree?
19:49:23 <adamvo> the last case would ovelap the other ones if it was first here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1703#a1703
19:49:47 <pumpkin_> isn't it paradoxical? or am I just misunderstanding things?
19:50:02 <NameAlreadyInUse> Pegazus_: it doesn't make sense that the halting problem is decidable for humans
19:50:06 <kerlo> pumpkin_: what's this about the question being paradoxical?
19:50:12 <kerlo> Every Turing machine either halts or doesn't.
19:50:22 <pumpkin_> in the same way russell's paradox works
19:50:50 <pumpkin_> you write a program that has access to a hypothetical function halts(p), and have it call halts on itself, and do the opposite
19:51:00 <pumpkin_> it neither halts nor doesn't
19:51:02 <monochrom> A human can't even prove whether he's sane or insane. Forget proving some other program terminates.
19:51:16 <roconnor> kerlo: what do you mean by a machine that doesn't halt?
19:51:22 <kerlo> The thing is, though, that hypothetical function is hypothetical.
19:51:25 <tromp_> if any human can solve halting problems, i'd like to give him the program looking for counterexamples to Goldbach's conjecture
19:51:33 <pumpkin_> kerlo: it's just the decider function that the halting problem describes
19:51:39 <Pegazus_> NameAlreadyInUse: the halting problem is a theorem that says something about turing machines and equivalent's computers powers...
19:51:46 <Pegazus_> it doesn't say anything about human beings...
19:51:46 <pumpkin_> if such a function existed, then such a program could exist too
19:51:50 <pumpkin_> which violates logic :P
19:51:51 <Pegazus_> it doesn't say anything about monkeys...
19:51:54 <Pegazus_> not about E.T.s...
19:52:02 <wli> tromp: Try the Generalized Riemann Hypothesis
19:52:04 <pumpkin_> the halting problem isn't a theorem
19:52:06 <Pegazus_> it's just says that a computer with the power of a turing machine, can't solve that problem
19:52:07 <kerlo> The halting problem is a problem, and there is pretty much one important theorem about it.
19:52:09 <pumpkin_> it's a decision problem
19:52:25 <pumpkin_> that implies a boolean function
19:52:34 <Pegazus_> so maybe monkeys can given an arbitrary algorithm, say always if it finishes or not....
19:52:39 <wli> Entscheidungsproblem
19:52:41 <monochrom> Unfortunately the theorem has no name.
19:52:41 <Pegazus_> the theorem doesn't say anything about that....
19:52:47 <pumpkin_> ...
19:52:48 <NameAlreadyInUse> Pegazus_: but the question remains, given a program and an input, could a human being always figure out, given enough time, whether the program will terminate on that input or not
19:52:51 <kerlo> Anyway, I'll wait for experimental results before concluding that monkeys can solve the halting problem.
19:52:53 <tromp_> but i think turing demonstrated convincingly that humans are no more powerful than computers
19:53:05 <Pegazus_> NameAlreadyInUse: no idea :)
19:53:07 <roconnor> NameAlreadyInUse: that seems highly unlikely
19:53:15 <wli> Depends on the definition of power.
19:53:18 <pumpkin_> wait, so is my question baseless?
19:53:29 <roconnor> also depends on what you mean by 'figure out'
19:53:32 <gwern> tromp_: humans are demonstrably inconsistent, so I'm not sure that's true
19:53:43 * roconnor isn't even sure that PA is consistent
19:53:43 <monochrom> The Turing test is really to ridicule humans.
19:53:52 <gwern> inconsistent logical systems iirc are more powerful than consistent ones
19:53:57 <monochrom> "What is 1+1?" "2." "You're machine"
19:54:04 <kerlo> pumpkin_: I don't see the halting problem as being paradoxical in the absence of a solution to it.
19:54:08 <NameAlreadyInUse> roconnor: i think it is very unlikely. even if you couldn't encode the process by which the hypothetically accurate human being decides whether the program halts or not
19:54:17 <NameAlreadyInUse> there is still a limit to reason
19:54:22 <wli> I think there can be differences in the asymptotic running time of algorithms vs. feasibility of a terminating algorithm.
19:54:24 <monochrom> "What is 1+1?" "Uh... 2? 3? is that a trick question? wait, I need my calculator..." "You're human!"
19:54:37 <gwern> monochrom: I was reading Shane Legge's thesis on AIXI and related stuff, and he mentioned that one judge failed a human during a turing test for knowing too much about shakespeare
19:54:40 <NameAlreadyInUse> the program might loop until some condition is satisfied, which may not be satisfiable or not but is unknowable
19:54:50 <monochrom> hehe
19:54:59 <roconnor> NameAlreadyInUse: the more intresting question is, what do you mean by figure out?  Usually that means prove in ZFC, but perhaps that isn't what you mean.
19:55:00 <pumpkin_> kerlo: I'm just saying if the problem were possible in some way or another, for any conceivable mechanism, it would result in a function halts :: Program -> Boolean that always returns, and if that function exists, we can construct a paradoxical program. In that sense, the function cannot exist
19:55:21 <kerlo> My favored Turing test question thingy is "Every time I say the word 'purple', I want you to tell me what two plus two is."
19:55:40 <NameAlreadyInUse> NameAlreadyInUse: reason their way to the conclusion, i mean
19:55:40 <MyCatVerbs> kerlo: and you're assuming that the human will forget?
19:55:41 <kerlo> pumpkin_: that is correct.
19:55:50 <NameAlreadyInUse> bah
19:55:59 <kerlo> MyCatVerbs: no, assume the computer won't understand.
19:55:59 <NameAlreadyInUse> did i just address that to myself?
19:56:03 <gwern> (AIXI itself is pretty darn cool, but I found that failure kind of amusing - if a machine knows that much about shakespeare...)
19:56:11 <NameAlreadyInUse> roconnor, i meant
19:56:24 <roconnor> NameAlreadyInUse: ya but reason ... that is very very vague
19:56:26 <pumpkin_> kerlo: ergo, the very formulation of the general problem is paradoxical, just like russell's formulation of a set that contains all sets that don't contain themselves was paradoxical
19:56:28 <MyCatVerbs> kerlo: why shouldn't it? It's a fairly straightforward instruction. Hell, it parses unambiguously.
19:56:34 <roconnor> NameAlreadyInUse: unless you mean something specific.
19:56:47 <monochrom> Definitions. Someone who asks questions in #haskell is a human. Someone who answers them is a machine.
19:56:48 <kerlo> MyCatVerbs: well, do you know of any computer programs that will understand it?
19:57:15 <MyCatVerbs> kerlo: no, but I could write one fairly easily.
19:57:20 <Pegazus_> tromp_
19:57:21 <roconnor> NameAlreadyInUse: usually reasoning begins with as assumption equivalent to stating that certain relations are well founded: most famous of is the less-than relation on natural numbers
19:57:22 <kerlo> pumpkin_: the answer to a question being "false" doesn't mean that the very formulation of it is paradoxical, does it?
19:57:25 <NameAlreadyInUse> roconnor: yeah, it is. there is really no other way to describe it
19:57:40 <Pegazus_> tromp_: what do you mean by that?
19:57:50 <kerlo> MyCatVerbs: make sure it also does other types of arithmetic and also recognizes other signals. :-P
19:58:02 <pumpkin_> kerlo: what question is false? the point is that given such a function that always returns true/false, you can construct a case that causes it to return neither true or false, which is a "violation of logic", which we call a paradox
19:58:11 <roconnor> NameAlreadyInUse: but it actually isn't necessarily the case that the natural numbers are well founded.  We simply intuition it.
19:58:23 <tromp_> a tm can compute anything a human can
19:58:24 <kerlo> pumpkin_: given such a function, yes; the thing is, though, we aren't given such a function.
19:58:35 <pumpkin_> kerlo: that's what the halting problem defines though
19:58:36 <pumpkin_> such a function
19:58:59 <mattge> from what i understand, it's a proof by contradiction, not a paradox
19:59:06 <kerlo> It certainly doesn't define such a function as a Turing machine.
19:59:19 <MyCatVerbs> kerlo: er, yes, yes it does.
19:59:27 <kerlo> The reason Russell's paradox is a paradox is that the axioms of naive set theory do in fact imply that Russell's crazy set exists.
19:59:29 <Pegazus_> the formulation of the halting problem isn't paradoxical.....
19:59:44 <pumpkin_> Pegazus_: so can you resolve my issue?
19:59:50 <Pegazus_> what issue?
19:59:52 <kerlo> MyCatVerbs: what I meant is that the halting problem does not provide an actual example of a Turing machine that solves the halting problem.
19:59:57 <pumpkin_> the one I've been going on about for the past 20 minutes :P
20:00:05 <Pegazus_> no idea what your issue is....
20:00:05 <roconnor> kerlo: to be fair the axioms also imply that the crazy set doesn't exist
20:00:12 <kerlo> roconnor: quite correct.
20:00:13 <Pegazus_> what's your issue?
20:00:19 <MyCatVerbs> kerlo: that's because you can't build one, silly. :)
20:00:44 <kerlo> MyCatVerbs: just pointing out that, as far as I can tell, you misunderstood me when you said "er, yes, yes it does".
20:01:09 <pumpkin_> Pegazus_: the halting problem essentially is looking for a decider called halts :: Program -> Bool. Assume such a function exists, constructed in some magical way. Now I construct a program that calls halts on itself, and enters an infinite loop if it returns True, and halts otherwise...
20:01:29 <pumpkin_> Pegazus_: it's almost exactly the same construction as russell's set
20:01:44 <MyCatVerbs> kerlo: what you've zipped past here is that to say that the halting problem is decidable is to say that there exists a Turing machine that decides it.
20:01:56 <kerlo> Halting problem proof: There is a Turing machine that solves the halting problem => False
20:02:04 <NameAlreadyInUse> pumpkin_: i think it's closer to halts :: Program -> Input -> Bool
20:02:14 <pumpkin_> true, but you can bundle the input with the program
20:02:17 <pumpkin_> in the turing sense
20:02:40 <NameAlreadyInUse> that is true
20:02:48 <kerlo> pumpkin_: do you see a paradox to be derived from "There is a Turing machine that solves the halting problem => False"?
20:02:50 <pumpkin_> so I haven't made any ridiculous jumps there, have I? in that case, must not the premise that there exists a halts function, be false?
20:02:56 <Pegazus_> pumpkin_: if the function halts existed, then halts(halts) would give true....
20:03:05 <kerlo> Indeed, the premise that there exists a halts function must be false.
20:03:08 <pumpkin_> kerlo: I haven't used turing machine anywhere, I'm just saying more abstractly
20:03:18 <kerlo> Mm, okay.
20:03:29 <pumpkin_> Pegazus_: I'm not asking for halts(halts), I'm asking for halts(the program I described above)
20:04:00 <pumpkin_> that is, if the halting function says I halt, to spite it I won't halt
20:04:01 <kerlo> You ought to say "Turing-complete" or "Turing-decidable" or "Pumpkin-decidable" or something somewhere, though, or else you're solving an ill-defined problem.
20:04:06 <pumpkin_> and if the halting function says I don't halt, to spite it, I will
20:04:20 <Pegazus_> that's why it's a contradiction :p
20:04:26 <pumpkin_> Pegazus_: I know :P
20:04:28 <pumpkin_> that's my whole point
20:04:33 <Pegazus_> but if you could get a real halt prorgam, in a paralell universe
20:04:48 <Pegazus_> then halt(prorgam of halt with halt parameter) would return true
20:05:03 <pumpkin_> I've constructed such a program using pretty standard steps, and the only real assumption is that there exists a halts function. Thus the assumption that such a function exists is false?
20:05:18 <monochrom> A proof of "there are infinitely many primes" begins with "suppose just finitely many of them". This is not paradoxical.
20:05:35 <Pegazus_> not realy assumptions count's too :)
20:06:03 <pumpkin_> monochrom: you're right, I'm "proving" halts doesn't exist by finding a contradiction when I assume it does
20:06:05 <MyCatVerbs> pumpkin_: yes. A fairly normal proof by contradiction. Classic technique. Works out great.
20:06:10 <pumpkin_> MyCatVerbs: I know :)
20:06:14 <NameAlreadyInUse> i'm sure you could have a halts :: Program -> Input -> Maybe Bool
20:06:27 <MyCatVerbs> pumpkin_: I don't understand why you stuck a question mark on the end of it, in that case. :)
20:06:32 <kerlo> pumpkin_: indeed, there is no such function.
20:06:37 <tromp_> here's a totally different proof: for a binary string x, define K(x) as the length of the shortest haskell progream that outputs x
20:06:43 <Pegazus_> NameAlreadyInUse: sure... you could implement it like halts x y = Nothing xD
20:06:46 <MyCatVerbs> NameAlreadyInUse: yes. But (const . const Nothing) suffices.
20:06:51 <pumpkin_> omg trompogorov
20:06:57 <tromp_> if you can decide halting problem, then this function K is computable
20:07:11 <pumpkin_> MyCatVerbs: I was just taking issue with people talking about the function as if it could potentially exist, maybe if a human tried to think of it
20:07:21 <kerlo> Are you sure you don't want K(x) = the highest integer that can be output by a Haskell program of length x?
20:07:25 <tromp_> but now write a program that finds the first x for which K(x) > 1 billion
20:07:25 <NameAlreadyInUse> Pegazus_: i mean in the sense that it returns Nothing when it is undecidable
20:07:32 <pumpkin_> tromp_: the trompogorv complexity?
20:07:36 <tromp_> yes
20:07:54 <tromp_> then you have a contradiction, since this program is way shorter than 1 billion bits
20:08:01 * kerlo nods
20:08:09 <monochrom> I also want to note that proving "not exist" by contradiction is allowed by intuitionistic/constructive logics. You can write the proof in Haskell's type system.
20:08:19 <pumpkin_> :)
20:08:46 <kerlo> My K(x) lets you do K(6)+1, of course. Assuming that K is a built-in Haskell function and all. :-P
20:08:57 <monochrom> @hackage TypeLevelProofOfTuringTheorem
20:08:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeLevelProofOfTuringTheorem
20:09:06 <monochrom> To appear soon!
20:09:52 <pumpkin> :o
20:10:04 <kerlo> I once tried to use GHC as a theorem prover by having a class of all types that are true, and an instance declaration for every rule of inference.
20:10:07 <kerlo> It didn't work.
20:10:41 <MyCatVerbs> monochrom: no, seriously. How on Earth do you do negation in Haskell's type system? Not fundep hackery or anything like that, is it?
20:11:23 <kerlo> data Void; type Not a = a -> Void
20:11:32 <monochrom> -XEmptyDataDecls
20:11:42 <monochrom> Then what kerlo says.
20:12:17 <MyCatVerbs> Doesn't that just give you types that can't be occupied by any value other than _|_, rather than types that cannot be put together at all?
20:12:30 <monochrom> @djinn Not p
20:12:31 <lambdabot> -- f cannot be realized.
20:12:47 <kerlo> There are no types that can't be put together at all; undefined will give you a value of any type.
20:12:56 * monochrom wonders what it's called in djinn.
20:13:52 <jfredett> kerlo: so the notion is that if the type = bottom, then it is false -- in some sense?
20:14:02 <kerlo> jfredett: pretty much.
20:14:12 <kerlo> If there's a total value with that type, it's true; otherwise, it's false.
20:14:48 <jfredett> kerlo: thats what I always thought, but I've not had a lot of opportunity to learn about theorem proving and stuff...
20:14:48 <MyCatVerbs> Right, hence my whining that you shouldn't be able to prove negations in Haskell's type system, since (yay, laziness!) every single damn term X is replaced by (X+1).
20:15:35 <monochrom> You can add a separate proof of termination.
20:15:51 <kerlo> @djinn Not Void
20:15:51 <lambdabot> f a = a
20:15:57 <kerlo> There's a negation you can prove. :-P
20:16:12 <monochrom> Oh! Right, Not p is unprovable. :)
20:16:39 <kerlo> For p = (), certainly.
20:17:11 <sw17ch> Is there a good way to make a bytestring of a specific length without calling into the Base stuff?
20:17:58 <monochrom> @djinn (p, Not p) -> Void
20:17:58 <lambdabot> f (a, b) = b a
20:18:09 <sw17ch> i've been using Data.ByteString.Internal.create, and i'm not sure if that's the best way
20:18:17 <MyCatVerbs> > fix ('A':)
20:18:18 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
20:18:30 <pumpkin> sw17ch: what do you need a fixed-length bytestring for?
20:18:46 <sw17ch> pumpkin, i like using bytestrings as opposed to malloc
20:18:52 <kerlo> MyCatVerbs: that's why Djinn doesn't have recursive data declarations.
20:19:00 <pumpkin> sw17ch: lol, fair enough
20:19:07 <sw17ch> i make a fixed length bytestring, and then when i need to chuck something out to C land, i use the pointer
20:19:18 <sw17ch> then it plays nicely with Binary instances and whatnot
20:19:20 <kerlo> @djinn-add data Procrastinate = Tomorrow Procrastinate
20:19:20 <lambdabot> Error: Recursive types are not allowed: Procrastinate
20:19:24 <pumpkin> I think the internal is the best way to do it then
20:19:31 <sw17ch> yeah, that's how i did it before
20:19:35 <sw17ch> just wasn't sure if it was best :)
20:20:28 <kerlo> Hmm. I'm going to add LFP and GFP types to Djinn.
20:20:35 <pumpkin> sw17ch: libdnet!
20:20:35 <MyCatVerbs> sw17ch: er¸ I'd rather use Foreign.C.* than that.
20:20:44 <sw17ch> pumpkin, wow that was fast
20:20:51 <pumpkin> sw17ch: twitter is speedy :P
20:20:53 <sw17ch> what, is twitter plugged into your brain directly?
20:20:57 <sw17ch> :P
20:21:08 <pumpkin> I just have twitterrific with notifications :)
20:21:11 <sw17ch> it uses unions! :X
20:21:16 <MyCatVerbs> sw17ch: AFAIK there have been rumblings that, at some point in the future, people might want to switch out the ForeignPtr implementation of ByteString for something based on STUArrays instead.
20:21:18 <sw17ch> and i'm not sure how i want to handle that
20:21:37 <sw17ch> MyCatVerbs, i'm not sure if that will affect what i'm doing now...
20:21:41 <MyCatVerbs> sw17ch: just because ForeignPtr allocation and deallocation is so un-sexily slow.
20:22:06 <sw17ch> that it is
20:22:10 <kerlo> @djinn-add type GFP a = Either (a ()) (a Void)
20:22:18 <MyCatVerbs> sw17ch: I think it might mean that the memory backing ByteStrings wouldn't necessarily be pinned.
20:22:33 <sw17ch> MyCatVerbs, i don't think that's at all a problem for me
20:22:39 <sw17ch> at last, not at this point
20:22:56 <pumpkin> if it isn't pinned, that could be a problem
20:23:09 <sw17ch> ... oh wait, right
20:23:13 <sw17ch> pinned means the GC won't touch it, right?
20:23:15 <kerlo> @djinn-add type LFP a = (a (), a Void)
20:23:16 <sw17ch> or is it that it won't move it
20:23:20 <pumpkin> won't move it
20:23:26 <sw17ch> yes, see, that is important
20:23:26 <pumpkin> bytestring uses foreignptrs though
20:23:43 <sw17ch> well, thank goodness cabal can put an upperbound on packages :)
20:23:55 <pumpkin> sw17ch: it just uses malloc and a foreignptr to it
20:23:58 <pumpkin> so you should be safe
20:24:11 <sw17ch> that still leaves the question of how to handle C unions...
20:24:23 * sw17ch mulls over it
20:24:28 <kerlo> @djinn-add type Id a = a
20:24:34 <kerlo> @djinn LFP Id
20:24:34 <lambdabot> Interrupted (IntMap.find: key 1 is not an element of the map)
20:24:38 <kerlo> Weird.
20:27:05 <MyCatVerbs> pumpkin: that's what I was poking at. ByteString uses ForeignPtrs *now*, but people were vaguely rumbling at the last AngloHaskell about the idea of using an implementation that didn't use pinned memory at all.
20:27:20 <pumpkin> ah
20:27:29 <pumpkin> but things like the bytestring mmap
20:27:33 <pumpkin> needs a foreignptr
20:28:28 <sw17ch> what does pinning do to the generational collector?
20:28:29 <pumpkin> I guess that could just be allowed to break though
20:28:53 <MyCatVerbs> sw17ch: buggery. :)
20:29:04 <sw17ch> hah!
20:29:13 <pumpkin> rude!
20:29:14 <sw17ch> but really, doesn't that just frick everything up?
20:29:19 <pumpkin> sounds like a job for strictanal
20:35:20 <jfredett> @. pl undo do {b <- (return True); if b then return 1 else return 0}
20:35:20 <lambdabot> if' True (return 1) (return 0)
20:35:30 <jfredett> what the hell is if', and where is it defined?
20:35:52 <jfredett>  @where doesn't find it.. I forget the command
20:36:22 <jfredett> @src if' --maybe?
20:36:23 <lambdabot> Source not found. There are some things that I just don't know.
20:36:27 <jfredett> hmm
20:36:32 <pumpkin> jfredett: it doesn't exist
20:36:35 <pumpkin> but you can write it trivially
20:36:43 <jfredett> sure-
20:36:51 <Axman6> if' p t f = if p then t else x
20:37:06 <jfredett> but I was wondering where it came from...
20:37:09 <Axman6> i think it's in Data.Bool
20:37:10 <jfredett> evidently, it's hardcoded.
20:37:12 <pumpkin> along with bool f t p = if' p t f
20:37:17 <jfredett> hmm
20:37:24 <pumpkin> nope
20:37:24 <Axman6> @hoogle if'
20:37:25 <lambdabot> No results found
20:37:31 <Axman6> maybe not
20:37:33 <pumpkin> it doesn't exist
20:37:45 <pumpkin> except pretty much everyone writes their own copy of it
20:37:49 <Axman6> but it does, it's right there!
20:37:51 <Axman6> i can see it!
20:38:05 <pumpkin> your eyes, they lie
20:38:27 <Axman6> i kinda like the ? operator in the LLVM stuff (i think?) p ? (t,f) = if p then t else f
20:40:13 <ispiked> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2026#a2026
20:40:29 <ispiked> it seems like I should always be returning a list
20:40:55 <Axman6> otherwise = [] ++ acc === otherwise = acc
20:41:01 <Axman6> to begin with
20:41:12 <ispiked> true
20:41:18 <Saizan> ?type foldr
20:41:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:41:28 <Axman6> foldr doesn;t really have an accumulator
20:41:45 <Saizan> and the element of the list is the first argument for step
20:42:36 <ispiked> oh, hmm. I didn't realize the type signatures for foldl/foldr were that different
20:42:51 <Axman6> yep
20:43:00 <Axman6> > foldl f z [a,b,c,d]
20:43:02 <lambdabot>   f (f (f (f z a) b) c) d
20:43:03 <Axman6> > foldr f z [a,b,c,d]
20:43:05 <lambdabot>   f a (f b (f c (f d z)))
20:43:21 <Axman6> > foldr `f` z [a,b,c,d] -- work...
20:43:23 <lambdabot>   Couldn't match expected type `[Expr] -> t'
20:43:27 <Axman6> bah
20:43:36 <Axman6> > foldr (`f`) z [a,b,c,d] -- work...
20:43:38 <lambdabot>   <no location info>: parse error on input `)'
20:43:41 <Axman6> lame
20:45:52 <ispiked> Axman6: I'm just following the examples in RWH, fwiw
20:46:01 <sw17ch> well, gnight
20:48:38 <davidL> > foldr (flip f) z [a,b,c,d]
20:48:40 <lambdabot>   f (f (f (f z d) c) b) a
20:50:48 <pumpkin> > text "x\ny"
20:50:51 <lambdabot>   x
20:50:51 <lambdabot>  y
20:51:04 <pumpkin> > text "x\n, \"moo\""
20:51:06 <lambdabot>   x
20:51:06 <lambdabot>  , "moo"
20:51:26 <pumpkin> is there a space in the second one?
20:51:31 <Axman6> yeah
20:51:40 * pumpkin kicks his IRC client
20:51:44 <Axman6> heh
20:52:17 <Gracenotes> no fun loops
20:52:52 <Twey> -funroll-loops instead?
20:53:13 <davidL> , text "moo"
20:53:16 <lunabot>  moo
20:53:29 <davidL> , text "> 2+2"
20:53:30 <lunabot>  > 2+2
20:53:56 <Axman6> , text "blah\n> 2+2"
20:53:58 <lunabot>  blah
20:53:58 <lunabot>  > 2+2
20:54:05 <Axman6> , text "blah\n\d> 2+2"
20:54:06 <lunabot>  luna: lexical error in string/character literal at character '>'
20:54:10 <Axman6> lame
20:54:13 <SamB> hahaha
20:54:16 <Axman6> , text "blah\n\b> 2+2"
20:54:17 <lunabot>  blah
20:54:17 <lunabot>  > 2+2
20:54:24 <SamB> you didn't realy think you could delete the preceding character, did you ?
20:55:24 <Axman6> i was hoping :P
20:55:56 <davidL> > text "preflex: seen davidL"
20:55:57 <lambdabot>   preflex: seen davidL
21:16:57 <pumpkin> mmorrow: so what is moonpatio?
21:18:02 <mmorrow> pumpkin: i was trying to think up a domain name and that's what i came up with
21:18:08 <pumpkin> ah
21:18:23 <mmorrow> so it's not anything in particular, although i may use it as such at some point
21:23:25 <mercurysquad> Hi, does anyone know which operator to use for modulus of non-integral numbers?
21:24:12 <mercurysquad> I'd like to wrap around a Float to 360 degrees, but e.g. 361.5 `mod` 360 complains that 361.5 is not integral :-\  I expect 1.5
21:25:11 <cnwdup> > let func n = if n > 360 then func (n - 360) else n in func 361.5
21:25:12 <lambdabot>   1.5
21:25:24 <cnwdup> Not really an answer, but maybe a work-around for now.
21:25:42 <mercurysquad> but if it's > 720 that's another problem :)
21:25:54 <cnwdup> > let func n = if n > 360 then func (n - 360) else n in func 720
21:25:55 <lambdabot>   360
21:26:04 <cnwdup> > let func n = if n >= 360 then func (n - 360) else n in func 720
21:26:05 <lambdabot>   0
21:26:08 <cnwdup> Which?
21:26:17 <pumpkin> 0 is better
21:26:20 <mercurysquad> 2nd one
21:26:51 <pumpkin> unfortunately that's O(n) :P
21:26:54 <Gracenotes> mod-ed 360 is probably clear
21:27:09 <mercurysquad> alternatively, is there a quick way to get integer and fractional part of a float? then i can do modulus of the integer part and add the fractional part
21:28:01 <wli> properFraction
21:28:10 <kapil> integer part == floor
21:28:14 <wli> > properFraction pi
21:28:15 <lambdabot>   (3,0.14159265358979312)
21:28:31 <dolio> > 361.5 `mod'` 360
21:28:32 <wli> @type properFraction pi
21:28:34 <lambdabot>   1.5
21:28:34 <lambdabot> forall a b. (Integral b, RealFrac a, Floating a) => (b, a)
21:28:37 <cnwdup> mercurysquad, there's mod' in Data.Fixed which works on fractionals.
21:28:55 <wli> Use properFraction
21:28:57 <kerlo> > phi
21:28:58 <lambdabot>   Not in scope: `phi'
21:29:09 <kerlo> > (sqrt 5 + 1)/2
21:29:10 <lambdabot>   1.618033988749895
21:29:19 <kerlo> > ((sqrt 5 + 1)/2)*360-360
21:29:20 <lambdabot>   222.49223594996215
21:29:33 <mercurysquad> cnwdup: awesome! thanks, that works :)  (mod' from Data.Fixed)
21:29:41 <kerlo> > 720 - ((sqrt 5 + 1)/2)*360
21:29:42 <lambdabot>   137.50776405003785
21:30:01 <wli> mercurysquad: properFraction does everything you want in one shot.
21:31:24 <dolio> No, mod' does. properFraction was just his question about implementing it himself.
21:31:44 <mercurysquad> yes. mod' does it
21:32:11 <dolio> > 5 `mod'` pi
21:32:13 <lambdabot>   1.8584073464102069
21:32:50 <Twey> @let by = (/)
21:32:51 <lambdabot>  Defined.
21:32:55 <Twey> > pi `by` 4
21:32:57 <lambdabot>   0.7853981633974483
21:33:19 * Twey has always loved that pronunciation
21:33:44 <wli> > take 10 $ unfoldr (Just . second recip . properFraction)  (pi :: Double) :: [Integer]
21:33:46 <lambdabot>   [3,7,15,1,292,1,1,1,2,1]
21:33:55 <wli> Witness continued fractions.
21:34:18 <pumpkin> that's awesome
21:35:17 <wli> Sadly I can't quite smoke out how to go about calculating convergents in similarly golfed fashion.
21:38:19 <Pseudonym> @pl (\c1 c2 n -> numerator c1 * n + numerator c2 :% denominator c1 * n + denominator c2)
21:38:20 <lambdabot> (`ap` denominator) . ((flip . ((+) .)) .) . ap ((.) . ap . ((+) .) . (*) . numerator) (((*) .) . flip ((:%) . numerator) . denominator)
21:38:27 <Pseudonym> No, it's not as succinct, is it.
21:42:36 <Pseudonym> :msg lambdabot @pl (\((p1,q1),(p2,q2)) n -> ((p2*n+p1,q2*n+q1),(p1,q1)))
21:44:24 <Pseudonym> scanl (\(p1,q1,p2,q2) n -> (p2*n+p1,q2*n+q1,p1,q1)) (1,0,0,1) [3,7,15,1,292,1,1,1,2]
21:44:38 <Pseudonym> > scanl (\(p1,q1,p2,q2) n -> (p2*n+p1,q2*n+q1,p1,q1)) (1,0,0,1) [3,7,15,1,292,1,1,1,2]
21:44:40 <lambdabot>   [(1,0,0,1),(1,3,1,0),(8,3,1,3),(23,48,8,3),(31,51,23,48),(6747,14067,31,51)...
21:44:57 <Pseudonym> Hrm.
21:45:45 <wli> Golfing it properly probably needs arrows.
21:46:00 <Pseudonym> > scanl (\(p1,q1,p2,q2) n -> (p1*n+p2,q1*n+q2,p1,q1)) (1,0,0,1) [3,7,15,1,1,1,2]
21:46:02 <lambdabot>   [(1,0,0,1),(3,1,1,0),(22,7,3,1),(333,106,22,7),(355,113,333,106),(688,219,3...
21:46:02 <Pseudonym> Yeah.
21:46:09 <Pseudonym> 688/219
21:46:13 <Pseudonym> > 688/219
21:46:15 <lambdabot>   3.141552511415525
21:46:53 <Pseudonym> It's possible that lambdas are shorter here.
21:47:45 <wli> > > take 10 . tail . snd $ mapAccumL (\((p, q),(p', q')) a -> (((p',q'), (p'*a + p, q'*a+q)), p' % q')) ((0, 1), (1, 0)) $ unfoldr (Just . second recip . properFraction) (pi :: Double) :: [Rational]
21:47:46 <lambdabot>   <no location info>: parse error on input `>'
21:47:58 <wli> > take 10 . tail . snd $ mapAccumL (\((p, q),(p', q')) a -> (((p',q'), (p'*a + p, q'*a+q)), p' % q')) ((0, 1), (1, 0)) $ unfoldr (Just . second recip . properFraction) (pi :: Double) :: [Rational]
21:47:59 <lambdabot>   [3%1,22%7,333%106,355%113,103993%33102,104348%33215,208341%66317,312689%995...
21:48:22 <wli> mapAccumL usually means MonadState is called for.
21:48:55 <wli> That is, with an ignored accumulator parameter.
21:49:40 <wli> s/parameter/return component/
21:51:32 <f4hy> > o
21:51:33 <lambdabot>   o
21:52:14 <Gracenotes> >:o
21:52:23 <f4hy> > (o) . (o) $ ":-)"
21:52:24 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Expr'
21:52:48 <travisbrady> anyone know the options i need to pass to cabal install when installing pcre-light to point it at the location of my pcre stuff?
21:53:32 <Saizan>     --extra-include-dirs=PATH      A list of directories to search for header
21:53:32 <Saizan>     --extra-lib-dirs=PATH          A list of directories to search for external
21:53:34 <wli> I don't know of anything offhand that makes things needing access to the history easy.
21:54:41 <travisbrady> Saizan: do you know which files it is looking for?
21:57:04 <f4hy> > let randomNumberByDice _ = 4
21:57:04 <lambdabot>   <no location info>: parse error on input `;'
21:57:44 <f4hy> why did that not work. I dont understand lambdabot
21:58:38 <Saizan> travisbrady: libpcre.a or .so and pcre.h, i'd think
22:01:08 <travisbrady> hmm, i can see the files in the dirs i'm pointing at but still getting an error, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1708#a1708
22:01:10 <travisbrady> dang
22:04:28 <Saizan> it looks like it can find them, but they aren't of his taste
22:04:41 <wli> > let picf = unfoldr (Just . second recip . properFraction)  (pi :: Double) :: [Integer] ; cvgts cf = let mix = zipWith3 (flip . ((+) .) . (*)) cf in drop 2 $ (zipWith (%) `on` fix) (\ps -> 0 : 1 : mix ps (tail ps)) (\qs -> 1 : 0 : mix qs (tail qs)) in take 10 $ cvgts picf
22:04:43 <lambdabot>   [3%1,22%7,333%106,355%113,103993%33102,104348%33215,208341%66317,312689%995...
22:05:05 <wli> Still kind of sucky.
22:08:58 * wli thinks it may be better to do cvgts cf = let mix (u, v) = let xs = u : v : zipWith3 (\a x x' -> a * x' + x) cf xs (tail xs) in xs in drop 2 $ (zipWith (%) `on` mix) (0, 1) (1, 0)
22:15:38 <travisbrady> got it to find the includes and libs, but now having this problem http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1709#a1709
22:15:54 <travisbrady> the file it mentions is empty
22:16:22 <mae> does hFileSize evaluate strictly, and make the file handle read forward?
22:18:41 <wli> I can't smoke out a better way than the zipWith3 crud.
22:20:44 <wli> Hmm, 103993/33102 < pi < 104348/33215 with 104348/33215 - 104348/33215 ~= 9.095184406364544e-10
22:20:50 * pumpkin is the proud owner of whyhaskell.org
22:20:56 <glguy> mae, you don't need to read to the end of a file to check its size
22:20:57 <wli> That's smoking.
22:21:12 <glguy> mae, so I'd suspect it might not
22:21:35 <mae> i'm talking handles though
22:21:36 <mae> hmm
22:21:56 <glguy> hFileSize on a Handle calls fdFileSize on the underlying file descriptor
22:22:03 <glguy> in C you can call fstat to find such a size
22:22:04 * wli usually uses 333/106 and 355/113 with an interval narrowed down to only ~= 8.348639171814995e-5
22:22:26 <glguy> I don't know how fdFileSize is implemented, but it isn't beyond reason that it would not need to read to the end
22:22:54 <jfredett> are there any good tutorials on Template Haskell hanging around? Hint needs me to give a Typeable instance for one of my classes... :/
22:23:24 <glguy> mae: http://darcs.haskell.org/packages/base/System/Posix/Internals.hs
22:23:32 <glguy> fdFileSize does call to fstat
22:26:37 <jfredett> nvm, I think I fixed it, though -- I suppose simply to satisfy my curiousity, if someone stumbles across a TH tutorial, I'd be interested.
22:38:35 <lstor> Is there a way to get line number inside a source file? For example having a function printing "I am on line x", where x is determined at compile-time?
22:38:40 <jfredett> ... damn -- maybe I should rethink this... Reader has no typable instance, I get the feeling thats likely because one can't create one, that makes things difficult.
22:38:54 * wli is trying to understand CPS.
22:39:16 <jfredett> wli: I gave up on Continuation Passing when I found monads, they are the one true religion.
22:39:23 <dolio> You can create one. mlt just doesn't have them.
22:39:31 <dolio> mtl, even.
22:39:43 <dolio> They're a pain to write by hand, though.
22:39:50 <jfredett> dolio: yes, the issue is that I don't know how, so my entire plan is to show "deriving Typeable" all over the place
22:39:54 <jfredett> and pray.
22:40:06 <jfredett> so far, it's worked.
22:40:16 <wli> jfredett: It's so I can read CPS-transformed lambdacalc in order to debug things automatically transforming such into CPS.
22:41:10 <jfredett> but now I'm stuck, and thinking that maybe it's easier to make the user do something different -- as it stands, the only thing required to be in the Config.hs is a function "filterMain" which has a Reader Type.
22:41:39 <jfredett> perhaps I can just unwrap the runReader part and make them return something w/o the Reader monad...
22:41:42 <jfredett> hmm.
22:41:44 <jfredett> wli: interesting.
22:42:58 <jfredett> perhaps I ought to just leave it till morning... :/ gnite folks.
22:46:03 <wli> jfredett: Basic blocks are basically in CPS.
22:52:30 <f4hy> What is the difference between f $ f and (f . f) ?
22:53:01 <cnwdup> You can write f $ g x but not f . g x. I think the only difference is preceeding.
22:53:16 <mjrosenb> f4hy: f $ f is exquivalent to f (f)
22:53:21 <cnwdup> You should be able to write (f . g) x, though.
22:53:23 <f4hy> wait.. they di different things
22:53:34 <mjrosenb> whereas f . f is equivalent to \x -> f (f x)
22:53:46 <Gracenotes> well, (f . g x) is possible if g takes 2 arguments before returning a value
22:54:11 <mjrosenb> Gracenotes: that statement made me cringe
22:54:55 <f4hy> mjrosenb: well then as a follow up, what is the difference between f (f) and \x -> f (f x)
22:55:05 <Gracenotes> mjrosenb: there's no nice way to talk about "taking multiple arguments", because arity <= 1
22:55:30 <Gracenotes> but it still does have to be talked about at times :/
22:55:35 <mjrosenb> f4hy: if you say let g = f (f) in g x, then the entire thing looks like (f f) x
22:55:46 <axman6m> f $ g x -> f (g x), f . g x -> \y -> f (g x y)
22:56:00 <axman6m> bad choice of symbols there...
22:56:33 <f4hy> mjrosenb: I dont fallow what is "the entire thing"
22:56:48 <mjrosenb> so
22:57:20 <mjrosenb> so in general, if f is a function, then f is equivalent to \x -> f x
22:57:28 <Gracenotes> (mjrosenb: if you have a better way of saying that g is of the form a -> b -> c, go ahead...)
22:57:43 <mjrosenb> so f (f) is equivalent to \x -> (f f) x
22:58:12 <mjrosenb> Gracenotes: g returns a non-function type
22:58:41 <f4hy> ... but when you compared f $ f to (f . f) you said the first was f (f) and the later was \x -> f (f x)  and now you say those two things are the same?
22:58:49 <Gracenotes> that would be a -> b.
22:58:49 * mjrosenb is used to arrow types, but the nice people at haskell is for category theory inc. have made that word mean something else as well :(
22:58:58 <mjrosenb> f4hy: no
22:59:09 <mjrosenb> (f f) x is not f (f x)
22:59:25 <f4hy> explain
22:59:36 <pumpkin> (f . f) x === f (f x)
22:59:40 <mjrosenb> the one on the left is not likely to typecheck
22:59:46 <pumpkin> f f is not allowed
23:00:05 <mjrosenb> pumpkin: sure it is, if f = id
23:00:07 <axman6m> > f $ f x
23:00:08 <lambdabot>   Add a type signature
23:00:12 <f4hy> (f . f) 5 and f $ f 5 give me the same thing.
23:00:22 <pumpkin> ah, fair enough
23:00:24 <mjrosenb> f4hy: what is f?
23:00:24 <axman6m> > f $ f x :: Expr
23:00:25 <lambdabot>   Add a type signature
23:00:32 <axman6m> -_-
23:00:54 <f4hy> mjrosenb: f x = x + 1 just as my own example
23:00:59 <cnwdup> f4hy, because it does the same thing. Its just different ways of writing apply f first and then apply f to that result.
23:01:03 <Gracenotes> > (id id) 5
23:01:04 <lambdabot>   5
23:01:17 <pumpkin> > (is ea id) 5
23:01:18 <lambdabot>   Not in scope: `is'Not in scope: `ea'
23:01:27 <f4hy> cnwdup: ok so they are the same thing then?
23:01:45 <Baughn> So.. this NativeCode thing...
23:01:47 <axman6m> no
23:01:52 <Baughn> Haskell in the browser, anyone?
23:01:56 <cnwdup> f4hy, I think so. Just different style of notation. But I think someone would disagree. (:
23:02:09 <pumpkin> I bought whyhaskell.org but haven't put anything up on it yet
23:02:28 <mjrosenb> f4hy: wait, in your original question, you did not apply either one to anything
23:02:31 <f4hy> cnwdup: Well that is what I am trying to figure out, is it just different syntax, or is it differnet somehow, like for some other function
23:02:41 <f4hy> mjrosenb: so?
23:03:02 <mjrosenb> when you applied it to something, you changed it's interpretation
23:03:04 <axman6m> (f . g) => \x -> f (g x),  (f . g x) => \y -> f (g x y),  f $ g x => f (g x)
23:03:05 <cnwdup> f4hy, once you apply it, it's the same. Since (f . g) x === f (g x) === f $ g x
23:03:28 <f4hy> wait functions change what they are when they are applied? now someone is lieing
23:03:38 <cnwdup> I didn't know you could use $ without applying it to a value.
23:03:39 * mjrosenb was taking f $ f as a single value
23:03:46 <mjrosenb> not a part of an expression
23:04:46 <mjrosenb> since f $ f as a single value is very much different from (f . f)
23:04:47 <axman6m> f4hy: you usually use . and $ together like f . g . h x . t y $ z, which corresponds to f (g (h x (t y z)))
23:05:12 * axman6m hust head home
23:05:20 <mjrosenb> however as part of an expression, f $ f bar and (f . f) bar are the same
23:05:58 <f4hy> mjrosenb: alright then clearly I am missing something more fundemental
23:06:49 <f4hy> Because that does not make much sense to me. Two things are very different, but when applied to something are the same?
23:07:12 <mjrosenb> f4hy: originally, you asked about (f . f) and f $ f
23:07:21 <mjrosenb> if you take them as values
23:07:34 <cnwdup> :t ((f::b -> c) $ (g::a -> b))
23:07:35 <lambdabot>     Could not deduce (SimpleReflect.FromExpr c, Show b)
23:07:35 <lambdabot>       from the context ()
23:07:35 <lambdabot>       arising from a use of `f' at <interactive>:1:2
23:07:43 <mjrosenb> you can say \ x -> let g = f $ f in g x
23:07:55 <mjrosenb> which is equivalent to (f f) x
23:07:58 <mjrosenb> *but*
23:08:06 <mjrosenb> if you take it as part of an expression
23:08:07 <cnwdup> :t (+1) $ (+2)
23:08:09 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
23:08:11 <cnwdup> :t (+1) . (+2)
23:08:13 <lambdabot> forall a. (Num a) => a -> a
23:08:16 <mjrosenb> then \x -> f $ f x
23:08:18 <cnwdup> :t show . (+2)
23:08:20 <lambdabot> forall a. (Num a) => a -> String
23:08:21 <cnwdup> :t show $ (+2)
23:08:23 <lambdabot> String
23:08:29 <mjrosenb> you've changed the way it gets parsed
23:08:40 <mjrosenb> so you now have f $ ( f x )
23:08:52 <mjrosenb> = f ( f x )
23:08:58 <f4hy> mjrosenb: ahh ok I get it
23:09:03 <cnwdup> > show $ (+2)
23:09:05 <lambdabot>       Overlapping instances for Show (a -> a)
23:09:05 <lambdabot>        arising from a use of `s...
23:09:07 <f4hy> so (f $ f) x would break
23:09:15 <mjrosenb> unless f = id
23:09:16 <f4hy> that is the difference
23:09:26 <mjrosenb> let f = id in (f $ f) 6
23:09:31 <mjrosenb> >let f = id in (f $ f) 6
23:09:32 <cnwdup> Why is (show $ (+2)) of type String?
23:09:37 <mjrosenb> > let f = id in (f $ f) 6
23:09:39 <lambdabot>   6
23:09:42 * mjrosenb fails
23:10:11 <f4hy> > let o = 0
23:10:12 <lambdabot>   <no location info>: parse error on input `;'
23:10:33 <f4hy> I dont get this lambdabot thing
23:10:42 <cnwdup> > let o = 0 in o
23:10:43 <lambdabot>   0
23:10:48 <f4hy> ahh
23:10:54 <f4hy> why do i need the in?
23:11:13 <cnwdup> Because without it you don't have a expression which can be evaluated.
23:11:13 <mjrosenb> f4hy: let foo = bar is to introduce new bindings in the ghci toplevel
23:11:31 <f4hy> mjrosenb: lamdbabot /= ghci ?
23:11:32 <mjrosenb> f4hy: lambdabot doesn't really let you introduce new bindings
23:11:37 <mjrosenb> at least not in that way
23:11:40 <mjrosenb> f4hy: correct
23:11:55 <f4hy> ic
23:12:12 <mjrosenb> lambdabot also does lots of other random neat things
23:12:15 <f4hy> I just want to define things so I can make funny symbols with (0)(o)
23:12:24 <mjrosenb> but i can never remember the triggers for them
23:13:00 <mjrosenb> @pl \f x y -> f (f x y x) y
23:13:01 <lambdabot> flip flip id . (ap .) . liftM2 (.) (.) (flip =<<)
23:13:43 <mjrosenb> @pl \x y z -> (x y) x z
23:13:44 <lambdabot> join flip
23:13:52 <raxas_> > let 1 + 1 = 3 in 1 + 1
23:13:54 <lambdabot>   3
23:14:29 <f4hy> wait so how do I define a function in lambdabot?
23:14:42 <mjrosenb> > let f x = x+1 in f 10
23:14:44 <lambdabot>   11
23:15:05 <f4hy> > f 1
23:15:06 <lambdabot>   Add a type signature
23:15:16 <f4hy> oh it does not save anything?
23:15:25 <mjrosenb> > let fib 0 = 1; fib 1 = 1; fib x = fib (x-1) + fib (x-2) in f 5
23:15:26 <lambdabot>   Add a type signature
23:15:34 <mjrosenb> > let fib 0 = 1; fib 1 = 1; fib x = fib (x-1) + fib (x-2) in fib 5
23:15:35 <lambdabot>   8
23:15:43 <mjrosenb> f4hy: correct.  no new bindings
23:15:50 <f4hy> mjrosenb: lame ok
23:16:06 <Baughn> @let f x = x + 3
23:16:07 <lambdabot>  Defined.
23:16:15 <Baughn> > f 42
23:16:16 <lambdabot>       Ambiguous occurrence `f'
23:16:16 <lambdabot>      It could refer to either `L.f', defined a...
23:16:23 <Baughn> @undefine
23:16:24 <f4hy> > let o 0 = "lol" in (o) (0)
23:16:25 <lambdabot>   "lol"
23:16:36 <mjrosenb> f4hy: i'd imagine that lambdabot would soon die from a lack of memory if it did that
23:16:44 <Baughn> @let o 0 = "foo"; o 1 = "bar"
23:16:45 <lambdabot>  Defined.
23:16:48 <Baughn> > o 1
23:16:48 <lambdabot>       Ambiguous occurrence `o'
23:16:48 <lambdabot>      It could refer to either `L.o', defined a...
23:16:52 <cnwdup> :D
23:16:52 * Baughn groans
23:16:53 <mjrosenb> f4hy: also, let foo = bar in baz is scoped only to baz.
23:17:20 <Baughn> mjrosenb: Nah. It does allow you to define things, and it won't run out of memory anytime soon - they're stored on disk.
23:17:22 <f4hy> > let o 0 = "boobs" in (o)(0)
23:17:23 <lambdabot>   "boobs"
23:17:28 <Baughn> Unfortunately... there are collision problems...
23:17:54 <f4hy> Baughn: ic. the @let is the way to go
23:18:10 <moozilla> hey all, what is the prefered way to do graphics
23:18:14 <moozilla> simple 2D stuff
23:18:18 <Baughn> moozilla: SDL?
23:18:32 <Baughn> There are a myriad of higher-level drawing libs, too
23:18:57 <moozilla> well I'm mostly looking for a way to just set pixels of bitmaps and draw them to the screen
23:19:37 * mjrosenb  has used the raw x librares in the past
23:19:47 <Baughn> moozilla: Yeah, SDL.
23:20:02 <Baughn> cabal install SDL
23:20:04 <moozilla> ok, thanks
23:25:40 <moozilla> Baughn, I'm on windows, what SDL library should I get?
23:25:55 <moozilla> it looks like it just has them for C++
23:26:33 <Cale> moozilla: There's an SDL binding for Haskell on Hackage. You'll also need the proper SDL library, but I have no idea how it works on Windows.
23:27:18 <moozilla> yeah, the SDL binding fails to install because I don't have the library
23:27:24 <moozilla> it says to download it from libsdl.org
23:27:33 <moozilla> these are all they have:
23:27:34 <moozilla> SDL-devel-1.2.13-VC6.zip (Visual C++ 6.0)
23:27:34 <moozilla> SDL-devel-1.2.13-VC8.zip (Visual C++ 2005 Service Pack 1)
23:27:34 <moozilla> SDL-devel-1.2.13-mingw32.tar.gz (Mingw32)
23:28:33 <Cale> It's probably the mingw one which is expected, but if you don't have mingw, this is perhaps a lot of trouble to go to.
23:29:01 <moozilla> I have MingW
23:29:12 <moozilla> so I'll try that
23:32:26 <Baughn> That's one thing I never figured out about windows - how are you supposed to point the compiler at the libraries? What's the correct equivalent of /usr/local/lib?
23:34:56 <Baughn> I usually just end up stuffing it in c:/windows, but that *can't* be right
23:35:58 <mathijs> Baughn: I know that most posix-like tools (cygwin, most programming languages/compilers) like to create their own directory in c:\ to tackle this. According to microsoft's guidelines software should go in Program Files. (/usr). Non-standard software for all users might go in (Documents and Settings / Users)/All users/something, and the stuff from homedir (.cabal for example) should go in Documents and Settings\YourUser\Application Data
23:36:44 <Baughn> mathijs: So, no directory for app-independent libraries?
23:37:35 <mathijs> Baughn: but because windows doesn't have a well-thought-out loadpath many stuff ends up in c:\windows and c:\windows\system32 to be shareable between all apps. Larger corporations that have their own libs shared betweens apps usually do something like C:\Program Files\Symantec Shared
23:38:02 <mathijs> Baughn: basically most people put them in the same dir as their apps (so a dir in program files)
23:38:32 <solidsnack> i think you are not supposed to actually share libs in windows
23:38:38 <mauke> you know you want 20 copies of the same dll (in possibly incompatible versions)!
23:38:39 * wli wonders where the low-level X libs are.
23:39:06 <solidsnack> they designed something into the OS to prevent it
23:39:08 <solidsnack> hmmm
23:39:14 <mathijs> Baughn: Many posix ports on windows use a dir in program files and create a posix-like structure below. so c:\program files\MyApp\(bin/lib/share)
23:39:17 <solidsnack> oh, DLL hell, that's righ
23:40:22 <moozilla> I'm using the Win32 instructions in the package file but it's not working
23:40:36 <moozilla> it still says I don't have SDL after pointing it to it
23:41:08 <moozilla> bah, nevermind, I typed the wrong version
23:41:43 <mathijs> That means that if you have 3 ported applications on windows, you probably have some base libraries installed 3 times. If you use many ports, you are probably better of using cygwin, since that tries to create a posix-like filesystem on 1 spot (c:\cygwin) and keep everything below there. But cygwin is kind of like a no-go if you want to distribute your software eventually
23:44:01 <Baughn> mathijs: It's.. really just as well that haskell tends to compile things statically, then.
23:44:25 <Baughn> mathijs: At least in my case, since I'm not using non-haskell libraries much. THis sounds just as messy as I was afraid it might be.
23:45:45 <mathijs> Baughn: there might be some tools out there that can bundle everything in 1 binary, but you should watch out for licensing issues in that case.
23:46:21 <solidsnack> Baughn: GHC compiles Haskell statically -- but you need to pass extra options to get C stuff linked in statically
23:46:45 <Baughn> mathijs: I'm fine with providing source, too. ;)
23:48:11 <mathijs> Baughn: even then... it can mean your source cannot be a certain license
23:48:40 <Baughn> mathijs: Well, there isn't much on hackage that isn't either bsd or gpl, is there?
23:49:23 <Baughn> The bsd stuff I'll steal, but I'll make sure to provide source when I use gpl'd libraries
23:51:20 <mathijs> Baughn: it doesn't have to be a problem, but statically linking everything means you have to do some investigation (when distributing), because some licenses just don't accept being statically linked into code with another license.
23:53:01 <Baughn> mathijs: There are no problems with combining bsd and gpl, are there?
23:53:18 <Baughn> I have to admit I'm hopelessly naive when it comes to licenses; mostly I just want to write interesting software
23:53:38 <moozilla> omg
23:53:44 <moozilla> this is ridiculous
23:53:50 <moozilla> none of the instructions work
23:53:55 <mathijs> I'm not sure, not a lawyer :)  but it might be that if your own code is bsd, and you statically link it to gpl stuff, it counts as a derived work so your code will become gpl.
23:54:18 <dmwit> moozilla: for what?
23:54:39 <moozilla> dmwit I'm trying to set up SDL on windows
23:55:17 <Baughn> mathijs: Well, no, my own code is gpl..
23:55:34 <moozilla> I have MinGW and msys
23:55:48 <moozilla> I have the SDL dev libraries
23:55:55 <moozilla> I have the haskell package
23:56:00 <mathijs> Baughn: in that case you are safe I guess
23:56:15 <moozilla> Configuring SDL-0.5.5...
23:56:15 <moozilla> checking for sdl-config... no
23:56:15 <moozilla> checking for sdl11-config... no
23:56:15 <moozilla> configure: error: *** SDL not found! Get SDL from www.libsdl.org.
23:56:15 <Gracenotes> > (sqrt (2501-100), sqrt (2501+100))
23:56:16 <lambdabot>   (49.0,51.0)
23:56:19 <moozilla> I keep getting that
23:56:28 <moozilla> even though I pointed it to the right place
23:56:50 <Baughn> moozilla: You could check config(ure).log to see how it's checking
23:57:03 <mathijs> Baughn: just as a personal note... you might want to concider AGPL3. it means people can't improve your work and put it behind some web-app without sharing back the improvements.
23:57:28 <moozilla> Baughn, will check
23:57:31 <Baughn> mathijs: I'm using GPL3, sure. AGPL?
23:57:45 <Baughn> Ah
23:58:33 <mathijs> AGPL3 is GPL3 compatible, but doesn't protect against web-apps (they don't distribute code, so GPL doesn't apply). AGPL3 is just a small extension that covers it, and should in my opinion just be made the default GPL3
23:59:00 <Baughn> Yes, it sounds appropriate, but apparently it's incompatible with GPLv2
23:59:13 <Baughn> ..well, that might not be an issue. I'm not sure yet.
23:59:20 <dmwit> moozilla: Does Windows have environment variables?  ...like LD_LIBRARY_PATH?
23:59:20 <mathijs> Baughn: that's because GPL3 is incompatible with GPL2
23:59:28 <mathijs> Baughn: http://itmanagement.earthweb.com/osrc/article.php/3803101/Bruce-Perens-How-Many-Open-Source-Licenses-Do-You-Need.htm
23:59:40 <solidsnack> dmwit: registry, i think
23:59:41 <dmwit> moozilla: (You can tell I'm going to be a lot of help by how much I know about Windows. ;-)
23:59:46 <moozilla> dmwit, yes
23:59:52 <moozilla> it has environment variables
23:59:59 <mathijs> Baughn: that's a good read, essentially saying all open source should just need 2 or 3 licenses.
