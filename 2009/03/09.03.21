00:01:39 <solidsnack> So basically, my issue comes from thinking of `List x y` as a supertype of `List x Empty` and `List x NonEmpty`.
00:01:48 <solidsnack> Which it is not.
00:02:08 <solidsnack> Damn, I was hoping to have some slick subtyping style magic.
00:03:38 <solidsnack> I guess a lot of typeclasses can not be defined for GADTs, then.
00:03:58 <dolio> I'm not sure how people formally define subtyping...
00:04:19 <dolio> But you can sort of set up an instantiation ordering or something.
00:04:38 <solidsnack> I remember once, Wadler gave a talk in SF and said that "Subtyping is evil."
00:04:55 <dolio> (forall e. List a e) can be instantiated to any e, so it can be used as either List a Empty or List a NonEmpty.
00:05:15 <dolio> And if you have either of those, it can be used as (exists e. List a e).
00:05:26 <dolio> Assuming you have first-class existentials.
00:06:26 <dolio> So I guess you could call either one of the concrete ones subtypes of the existential.
00:07:09 <dolio> But when you see type variables in Haskell/GHC, they're pretty much always universally quantified.
00:09:03 <dolio> First-class existentials and type classes could even get you what looks a bit like OO subtyping.
00:09:36 <dolio> A function that takes an argument of type (exists a. Class a => a) could be called with any type that is an instance of Class.
00:10:11 <dolio> Which looks a lot like, say, a Java interface.
00:11:13 <solidsnack> We can do that already, though, right?
00:11:46 <solidsnack> So I tried a rather small change and get a new error.
00:11:48 <solidsnack> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2709#a2710
00:11:50 <dolio> You can do it in GHC, but you have to create a new type to wrap the existential.
00:12:20 <solidsnack> dolio: Maybe I don't understand what you mean.
00:12:30 <solidsnack> Illegal polymorphic or qualified type: forall y. List x y
00:12:42 <dolio> You shouldn't need that forall y. Just (List x y) should be fine.
00:12:58 <solidsnack> dolio: Yes.
00:13:10 <solidsnack> I don't understand the error, though.
00:13:18 <solidsnack> It's illegal in instances or ... ?
00:13:50 <dolio> Yeah, you can't expicitly quantify like that in instances.
00:13:52 <catface> can lambdabot simplify an expression instead of pointfreeing it?
00:14:06 <catface> simplify = smaller AST
00:14:07 <dolio> instance Eq (List x y) already declares instances for all ys.
00:14:30 <dolio> (forall y. List x y) is actually a different type.
00:14:46 <dolio> It's the type of lists that can be instantiated to either Empty or NonEmpty.
00:14:55 <dolio> Which is... just bottom.
00:14:56 <solidsnack> As for your earlier remarks -- isn't `(Class a) => a` just the same as `exists a. Class a => a` ?
00:15:12 <solidsnack> dolio: Oh, interesting.
00:15:14 <dolio> No.
00:15:22 <solidsnack> Please explain.
00:15:32 <dolio> Well, where are we putting it.
00:15:49 <dolio> foo :: (Class a) => a is short for foo :: forall a. (Class a) => a.
00:16:12 <dolio> Which means foo is a value that inhabits any type that is an instance of class Class.
00:16:33 <solidsnack> yes
00:16:58 <dolio> foo :: exists a. (Class a) => a is a value of some particular type that is an instance of class Class.
00:17:02 <dolio> But we don't know what that type is.
00:17:39 <solidsnack> Backing up a bit: "A function that takes an argument of type (exists a. Class a => a) could be called with any type that is an instance of Class."
00:18:04 <dolio> Yes.
00:18:07 <solidsnack> Is it not also true that: "A function that takes an argument of type (Class a => a) could be called with any type that is an instance of Class."
00:18:43 <dolio> Oh, yes. But the types are slightly different.
00:19:06 <dolio> foo :: (exists a. Class a => a) -> b versus foo :: (forall a. Class a => a -> b).
00:19:30 <solidsnack> Ah.
00:19:37 <dolio> They function similarly.
00:19:46 <solidsnack> So their proofs are in a sense, different.
00:20:02 <solidsnack> The first one only needs to work for one such `a`.
00:20:05 <dolio> But that's because of the arrow. With the arrow there, you can convert between them.
00:20:22 <solidsnack> The arrow? The `->` or the `=>` ?
00:20:57 <dolio> Because (for instance) it's a theorem in intuitionistic logic that "((exists a. P a) -> b) -> (forall a. P a -> b)".
00:21:02 <dolio> The ->
00:21:19 <dolio> But, on its own, as the type of a particular value, they're different.
00:21:40 <solidsnack> Okay, I need to think about this a minute.
00:22:27 <dolio> Saying "let x :: (exists a. C a => a) ; x = valueOfSomeType" in haskell is similar to saying "Interface x = new ConcreteType()" in Java.
00:22:44 <dolio> Or, it would be if you could have first-class existentials.
00:23:11 <solidsnack> Does AGDA have these things?
00:23:48 <dolio> Sort of. It has dependent typing generalizations of them.
00:24:15 <dolio> Well, strictly speaking, it still doesn't have first-class existentials, exactly.
00:25:31 <dolio> But you can make a type that serves as them due to its increased capacities for type-level programming.
00:25:47 <dolio> Which I suppose would be first class, just not built-in.
00:26:12 <solidsnack> Interesting.
00:27:29 <solidsnack> So the implicit quantification, I need to think about that.
00:29:11 <solidsnack> foo :: (exists a. Class a => a) -> b    can be read as "`foo` is of a type such that, when there exists `a` in `Class` there is a `b`"
00:30:11 <dolio> Given a value of some type a, where a must be an instance of Class, it gives back a b.
00:30:21 <solidsnack> Right.
00:30:39 <solidsnack> Which is just the same as the other one; just differently stated.
00:30:51 <dolio> Yeah.
00:31:07 <solidsnack> Okay, this has been educational, thank you.
00:31:23 <solidsnack> I am mulling over approaches to programs over streams.
00:31:25 <dolio> If in GHC today you make a type: "data E = forall a. Class a => E a" which is the datatype equivalent of that...
00:31:36 <solidsnack> Please, go ahead.
00:31:50 <dolio> You can write: "bar :: (E -> b) -> (forall a. Class a => a -> b)"
00:32:03 <dolio> bar f a = f (E a)
00:32:51 <dolio> And "baz :: (forall a. Class a => a -> b) -> (E -> b) ; baz f (E a) = f a"
00:33:47 <dolio> Also, that's the reason for the weird notation GHC uses.
00:33:59 <FunctorSalad> you can also simulate it with: exists a. C a => a   =   forall r. (forall a. C a => a -> r) -> r
00:34:00 <solidsnack> Which weird notation?
00:34:01 <FunctorSalad> :)
00:34:48 <dolio> Because with first-class existentials you could write: 'data E = E (exists a. Class a => a)', and the constructor would have type 'E :: (exists a. Class a => a) -> E' which is equivalent to 'E :: forall a. Class a => a -> E' which is the type GHC uses for it.
00:35:31 <solidsnack> Hmm.
00:35:33 <dolio> And so you put "forall a. Class a =>" on the left side of the constructor instead of "exists a. Class a =>" on the right side.
00:35:55 <dolio> Which frequently causes confusion about why they're called existential types and such.
00:36:22 <solidsnack> Wait, what is this about the left and right side?
00:36:47 <dolio> The GHC existential type declaration is "data E = forall a. Class a => E a".
00:37:12 <mofmog> how do i do something like (someMonadFunction =<< ) . return
00:37:16 <solidsnack> Ah.
00:37:23 <kosmikus> just use GADT syntax
00:37:26 <mofmog> i want to have a list of monadic computations that i will map over
00:37:49 <solidsnack> Okay.
00:38:03 <solidsnack> So let's revisit the `(==)` again.
00:38:03 <dolio> Yeah, as a GADT that's "data E where E :: forall a. Class a => a -> E" which makes more sense if you know the equivalence in bar and baz above.
00:39:10 <solidsnack> There is just no way to make a single instance that works over the two constructors of `List`, because there is no type to which both constructors can simultaneously instantiated?
00:40:11 <solidsnack> If there were first class existentials, how would this be different? Wouldn't the definition of `eq` have to be changed to accomodate it?
00:40:15 <dolio> Well, there sort of is. You made an instance that was using both constructors at first.
00:40:38 <solidsnack> Oh.
00:40:51 <dolio> When you write "instance Eq (List x y)" you're then trying to define "(==) :: forall x y -> List x y -> List x y -> Bool".
00:41:07 <dolio> Er, make that first -> a .
00:41:14 <solidsnack> Yes.
00:42:18 <solidsnack> I could lump them together but any attempts to test `Nil == Cons _ _` would result in a static error, not False.
00:42:39 <dolio> Yes.
00:42:40 <solidsnack> (A runtime `False`, I mean.)
00:43:06 <dolio> You'd get 'can't match Empty with NonEmpty' or something.
00:43:25 <dolio> Incidentally, your eq function is more complex than need be, I think.
00:43:29 <solidsnack> So the big question is, how of a problem is this in practice?
00:43:35 <solidsnack> dolio: Oh ?
00:43:39 <dolio> The reason I told you to define it was that eq takes lists of possibly different emptiness.
00:43:46 <solidsnack> Please explain how it is more complex.
00:44:10 <dolio> So when you get to the "eq (Cons x l) (Cons x' l')" case you can just call "eq l l'", because they don't have to have the same type.
00:45:16 <dolio> The thing I mentioned about doing case analysis on l and l' was only if you wanted to define things within (==).
00:45:36 <dolio> Because matching against them can tell you what type they have, and whether you're allowed to recursively call (==).
00:46:20 <solidsnack> Aye, I fixed it.
00:47:06 <solidsnack> In practice, though, I will never find myself testing the equality of lists that I don't know what their type is.
00:47:22 <solidsnack> Statically, it is know whether they are empty or nonempty.
00:47:24 <dolio> That, by the way, is the essence of GADTs.
00:47:30 <solidsnack> s/know/known/
00:47:46 <dolio> Matching against a GADT can give you information about the types you're working with.
00:49:08 <idnar> are GADTs covered in RWH?
00:49:38 <dolio> When you first have l, it has type List x b, for some unknown b. But when you do case analysis and find out that l = Cons _ _, it tells the type system that b = NonEmtpy.
00:49:39 <solidsnack> Okay, so my little subtyping dreams are shattered. I'm not sure I needed them, anyways.
00:51:06 <dolio> Well, if Wadler says subtyping is evil, who are we to argue? :)
00:52:06 <idnar> does he say why it's evil? ;P
00:53:08 <dolio> Dunno. solidsnack brought it up earlier. I don't know the reference.
00:53:14 <lepassive> what is onTextChanged equivalent in Gtk2HS ?
00:53:27 <dolio> Oleg has a page about (at least) how almost every language gets subtyping wrong, as I recall.
01:14:19 <lepassive> i have sql result set [string, string] i want to extract each as string any help ?
01:27:13 <mofmog> IT WORKS! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2711#a2711
01:31:55 <jekor> I'm trying to figure out how to diagnose a crash. Any time I try to access a certain variable (for lack of a better name) I get the crash. This happens even when trying to trace it.
01:32:17 <jekor> Is there anything easier than, say, trying to gdb a dump?
01:34:34 <wli> dolio: What page?
01:34:59 <dolio> I'd have to search for it.
01:35:14 <wli> dolio: Remember the gist of the subtyping critique?
01:35:18 <dolio> http://okmij.org/ftp/Computation/Subtyping/
01:35:24 <dolio> Luckily, google works well.
01:36:56 <mofmog> dolio: changing the data structure saved me 1000000x the headache
01:37:16 <wli> Okay, this is a better way to explain what's wrong with OOP.
01:37:18 <dolio> Not super surprising, I suppose.
01:37:36 <wli> Weirdly I think subtyping is potentially useful and OOP is garbage.
01:38:25 <dolio> mofmog: Using arrays is probably way more efficient, too, since moving around just changes the distinguished coordinate.
01:39:09 <dolio> Yeah. I couldn't remember the specifics of it, but you typically only see subtyping in OO languages, so I think my description of it stands. :)
01:40:02 <wli> dolio: Mark Jones has a very spiffy paper on getting unbelievable mileage out of extensible variants + monad transformers.
01:42:29 <wli> I think the way to formalize strictness is by graph coloring.
01:43:45 <wli> You get interference from non-strict edges and edges from multiple colors at once.
01:44:21 <lepassive> i have sql result set [ [string, string] ] i want to extract each as string any help ?
01:50:50 <wli> That's not graph coloring, but anyway.
01:52:05 <lepassive> okay rephrasing, i want to iterate on List of lists any help ?
01:53:35 <TSC> lepassive: Maybe you just want to concat them all?
01:54:02 <lepassive> TSC nope because each are a rows in a table
01:54:03 <TSC> > concat [ ["one", "two"], ["three", "four"] ]
01:54:04 <lambdabot>   ["one","two","three","four"]
01:54:26 <wli> I can start by assigning each node a unique label, then iterating until I reach a fixpoint re-labeling every node with strict in-edges from nodes with only one label and no non-strict in-edges to the label of the unique strict demander.
01:54:44 <TSC> lepassive: What exactly do you want?
01:55:07 <lepassive> i have sql result set [ [string, string] ] i want to handle each string in each row
01:57:22 <mofmog> making a comonad with an array?
01:57:38 <mofmog> wouldn't i have stick an array inside an array everytime i cojoin?
01:58:02 <mofmog> oh wait i can get around that couldn't i, hm
01:58:07 <mofmog> just write =>> directly
01:58:27 <catface> :t map . map
01:58:29 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
01:58:48 <lepassive> any simple example?
02:02:22 <catface> > map (map reverse) [ ["one", "two"], ["three", "four"] ]
02:02:23 <lambdabot>   [["eno","owt"],["eerht","ruof"]]
02:03:19 <lepassive> catface, thanks alot :)
02:04:48 <adimit> Saizan_: I didn't see your comment last night, but did now. Thanks, I think cabal upgrade has indeed wrecked my setup (it seems to be disabled in this version.) I have two versions of Cabal in both the user and system repo, so four overall. I'll try to clean it up. Thanks again.
02:07:50 <adimit> yup. unregistering the user's Cabal and haskell98 versions did help, however, I can't unregister processes-1.0.1.1, since xmonad and a few other depend on it.
02:09:44 <wli> The next question is how unique this label assignment is and how I should go about looking for one...
02:17:59 <wli> When the smoke clears, every component has either a non-strict edge connecting it or at least two distinct strict in-edges. You can turn this into a biconnected component problem by counting each non-strict edge twice.
02:28:53 <lepassive> hqs2: cellLayoutSetAttributeFunc: attempt to set attributes of CellRenderer from different model. any hints ?
02:46:54 <wli> Any node with a non-strict in-edge is necessarily the root of a component, so you can sort of start from there and let the labels flow outward.
02:49:06 <lepassive> how can i apply "    mapM_ New.listStoreInsert store rows" ?
02:49:24 <lepassive> as New.listStoreInsert takes 2 arguments the ListStore and the element ?
02:50:37 <ivanm> lepassive: what are you mapping over?
02:50:42 <ivanm> store or rows?
02:50:47 <lepassive> ivanm, a list of rows
02:50:52 <lepassive> ivanm, rows
02:51:00 <ivanm> mapM_ (New.listStoreInsert store) rows
02:51:11 <ivanm> ^^ that'll do it
02:51:21 <wli> Since it's an expression, you can start with the whole expression as if it had a non-strict in-edge, and whenever you encounter a a non-strict edge, queue up the target as a root. For strict edges, check for any other incoming edges on the target at all. If it's uniquely forced by the current component, then merge it with the current component. Otherwise queue it as a fresh root of a new component.
02:52:17 <lepassive> ivanm, i tried and it raises     Couldn't match expected type `IO' against inferred type `(->) a' <NL> Probable cause: `New.listStoreInsert' is applied to too few arguments
02:53:06 <ivanm> what's the type of New.listStoreInsert ?
02:53:32 <wli> When there are no more out-edges from the current component to consider, emit the component and move to the next root in the queue, choose a fresh label, and label from there. When the queue empties, you're done.
02:53:39 <lepassive> ivanm, http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/Graphics-UI-Gtk-TreeList-ListStore.html#v%3AlistStoreInsert
02:54:08 <lepassive> ivanm, no sorry, http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/Graphics-UI-Gtk-ModelView-ListStore.html#v%3AlistStoreInsert
02:55:26 <ivanm> lepassive: and the type of store and rows?
02:55:53 <ivanm> @type mapM_
02:55:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:56:08 <lepassive> ivanm, store <- New.listStoreNew  and rows are just [string, string]
02:56:44 <ivanm> @hoogle listStoreInsert
02:56:44 <lambdabot> No results found
02:57:00 <ivanm> lepassive: listStoreInsert expects Int...
02:57:16 <ivanm> lepassive: oh, and [String, String] isn't a valid type...
02:59:01 <ivanm> lepassive: oh, and listStoreNew is meant to take params...
03:04:27 <wli> I believe I have my answer wrt. closures.
03:05:58 <spx2> is there a cut operator in haskell ?
03:06:06 <spx2> like the green/red cut in prolog ?
03:06:29 <wli> No, Haskell isn't a logic language.
03:06:36 <eu-prleu-peupeu> hello gang
03:06:37 <spx2> doesn't have to be
03:06:54 <spx2> how does it cut trees from a recursive call predicate/function ?
03:07:00 * ivanm is part of no-one's gang!
03:07:09 * Heffalump conscripts ivanm
03:07:11 <spx2> wli: so what does haskell use instead of the cut ?
03:07:24 * ivanm runs
03:07:27 <ziman> spx2, if you have two declarations, like { f (x:xs) = 0; f _ = 1 }, haskell chooses the first one, so it's like there's always a cut
03:07:33 <Heffalump> ivanm: too late
03:07:36 <eu-prleu-peupeu> yesterday a friend of mine told me "you should already have grown past the 'what computer language to use' question, because they are all the same, as long as you get work done"
03:07:44 <wli> spx2: Conditional expressions, or case statements.
03:08:17 <eu-prleu-peupeu> i trolled "compared to haskell they are all the same: deprecated"
03:09:00 <maltem> Today's inane wondering: Why did they choose {,} for record syntax, instead of layout, as for everything else?
03:09:00 <ivanm> eu-prleu-peupeu: tell him to only use brainfuck then
03:09:12 <eu-prleu-peupeu> eh
03:09:17 <ivanm> maltem: they do use {,} for layout
03:09:20 <ivanm> in do-blocks
03:09:24 <eu-prleu-peupeu> he is also working on a 3d rendering engine, in c++
03:09:28 <ivanm> actually, it's {;}
03:09:29 <eu-prleu-peupeu> im doing it in haskell
03:09:30 <maltem> ivanm: {;} you mean
03:09:31 <spx2> oh ok then
03:09:33 <spx2> thanks wli
03:09:35 <eu-prleu-peupeu> so we usually "collide" :/
03:09:35 <ivanm> maltem: yeah
03:09:38 <spx2> thx ziman
03:09:45 <maltem> ivanm: I meant the question the other way around though
03:09:56 <catface> is there some monad where i can do:  do [putStr "a", putStr "b"]; [putStr "c", putStr "d"] and get "acadbcbd"?
03:09:59 <wli> spx2: The pattern matching bit is an alternative way to write case expressions.
03:10:20 <ivanm> maltem: why use {} for records if its' already being used for do-blocks? is that what you meant?
03:11:05 <maltem> ivanm: Rather, why do records not just use layout (optionally, {;}) instead of special {,} syntax?
03:11:38 <wli> Okay, I'm screwed on lambdas and applications. I guess I can always consider applicatoins non-strict in the argument and lambdas non-strict in the body.
03:11:51 <maltem> ivanm: I realize one would have another keyword then
03:11:57 <ivanm> maltem: well, records existed before do-blocks...
03:12:10 <maltem> ivanm: But not before let and where, I suppose
03:12:37 <dobblego> catface, your question is a little unclear in terms of the function required; perhaps start with the simpler pure function that you desire?
03:13:01 <dobblego> catface, [["a", "b"], ["c", "d"]] -> "acadbcbd"?
03:13:08 <ivanm> maltem: yeah
03:13:23 <dobblego> catface, there is always forM if the values are in IO
03:13:26 <dobblego> @type forM
03:13:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
03:13:28 <ivanm> we need new bracket-types on our keyboards!
03:13:44 <catface> thanks
03:15:17 <wli> Actually lambdas have the VarExpr expression for their bound variable which may end up as part of the strict component of the body or not, at which point I get strictness on the bound var.
03:16:17 <Saizan_> > concat $ do x <- ["a","b"]; y <- ["c","d"]; return (x++y)
03:16:19 <lambdabot>   "acadbcbd"
03:17:29 <Gilly> in ghci (6.10.1) there seems to be a bug with the autocompletion: one new 'it' appears in the autocompletion list after each command
03:17:32 <wli> Then if I apply a naked lambda, strictness in its bound var translates to strictness in the argument. So it gets hairy and needs special-casing.
03:17:41 <dobblego> > (++) <$> ["a", "b"] <*> ["c", "d"]
03:17:42 <lambdabot>   ["ac","ad","bc","bd"]
03:18:01 <dobblego> > (++) =<< ["a", "b"] <*> ["c", "d"]
03:18:02 <lambdabot>   Couldn't match expected type `[a] -> a1 -> [a]'
03:18:20 <catface> i guess i want to combine lists of State monads in all possible ways by writing do a;b;c;d where a,b,c,d are lists of State monads
03:19:18 <catface> i guess it doesn't have to be 'do'
03:19:52 <dobblego> > join $ (++) <$> ["a", "b"] <*> ["c", "d"]
03:19:53 <lambdabot>   "acadbcbd"
03:19:58 <Saizan_> State "actions", the monad is State
03:20:02 <beelsebob> > ["a","b"] <^(++)^> ["c","d"]
03:20:03 <lambdabot>   ["ac","ad","bc","bd"]
03:20:37 <Saizan_> catface: you can use sequence [a,b,c,d] to get lists of all the combinations
03:20:51 <wli> I think the unique forcing bits only work when there are no lambdas or applications, so I have to smoke out something to handle those.
03:21:08 <Saizan_> catface: then you can "map sequence" to transform each list of actions into a single action
03:21:17 <beelsebob> aka mapA
03:21:31 <Saizan_> sequenceA?
03:21:47 <beelsebob> well sequence just has the wrong type signature ;)
03:21:59 <beelsebob> (and shouldn't be in Control.Monad)
03:22:03 <catface> @hoogle <^
03:22:03 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
03:22:15 <beelsebob> catface: infix applicative on hackage
03:22:25 <Saizan_> i don't see where mapA applies
03:22:33 <beelsebob> mapA = map sequence
03:22:47 <beelsebob> sequence = foldr (liftA2 (:)) (pure [])
03:23:06 <Saizan_> really? i'd expect mapA f = sequence . map f
03:23:16 <beelsebob> oh, sorry
03:23:17 <beelsebob> >.<
03:23:19 <beelsebob> yes
03:24:17 <Saizan_> catface: the bottom line is that sequence in the list monad computes the cartesian product
03:27:05 <augustss> Is there a library that provides sequence functions for tuples, i.e.,  (m a1, m a2, ... m an) -> m (a1, a2, ... an)?
03:27:14 <catface> thanks
03:27:44 <beelsebob> augustss: uncurry liftAn?
03:27:52 <beelsebob> not quite
03:27:53 <beelsebob> but close
03:27:59 <idnar> you need uncurryN
03:28:02 <idnar> or something
03:28:03 <beelsebob> yeh
03:28:18 <augustss> yes, is there a library with uncurryn?
03:28:37 <idnar> @type uncurry
03:28:38 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
03:29:00 <idnar> @pl \f (a, b, c) -> f a b c
03:29:00 <lambdabot> (line 1, column 9):
03:29:00 <lambdabot> unexpected ","
03:29:00 <lambdabot> expecting letter or digit, operator or ")"
03:29:00 <lambdabot> ambiguous use of a non associative operator
03:29:18 <beelsebob> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
03:29:19 <lambdabot> No results found
03:29:22 <augustss> Maybe I should make one.
03:29:28 <beelsebob> could be a plan
03:29:37 <idnar> @pl uncurry3 f (a, b, c) = f a b c
03:29:37 <lambdabot> (line 1, column 22):
03:29:37 <lambdabot> unexpected "="
03:29:37 <lambdabot> expecting variable, "(", operator or end of input
03:29:41 <idnar> blahrg
03:30:36 <dolio> @seen mofmog
03:30:36 <lambdabot> I saw mofmog leaving #haskell 1h 29m ago, and .
03:30:41 <augustss> A tuple library, with things like uncurryN, and selN (generalization of fst and snd).
03:31:47 <dolio> @tell mofmog I tweaked your original CA stuff, and defined cojoin: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=2708#a2717
03:31:47 <lambdabot> Consider it noted.
03:34:36 <trofi> @pl a -> (a,a)
03:34:36 <lambdabot> (line 1, column 3):
03:34:37 <lambdabot> unexpected ">" or "-"
03:34:37 <lambdabot> expecting variable, "(", operator or end of input
03:34:40 <trofi> @pl \a -> (a,a)
03:34:40 <lambdabot> join (,)
03:39:34 <catface> > sequence $ [putStr "a"] <**> (map (>>) [putStr "b", putStr "c"])
03:39:35 <lambdabot>   * Exception: "<IO [()]>"
03:40:07 <catface> > map sequence [[putStr "a", putStr "b"],[putStr "c", putStr "d"]]
03:40:08 <lambdabot>   [* Exception: "<IO [()]>"
04:10:30 <catface> >  mapM sequence_ $ sequence [[putStr "a", putStr "b"],[putStr "c", putStr "d"]]
04:10:31 <lambdabot>   * Exception: "<IO [()]>"
04:10:48 <catface> >  mapM sequence $ sequence [[putStr "a", putStr "b"],[putStr "c", putStr "d"]]
04:10:49 <lambdabot>   * Exception: "<IO [[()]]>"
04:11:07 <catface> >  sequence $ mapM sequence $ sequence [[putStr "a", putStr "b"],[putStr "c", putStr "d"]]
04:11:08 <lambdabot>   Couldn't match expected type `[]' against inferred type `IO'
04:11:16 <catface> >  sequence $ map sequence $ sequence [[putStr "a", putStr "b"],[putStr "c", putStr "d"]]
04:11:18 <lambdabot>   * Exception: "<IO [[()]]>"
04:30:12 <byorgey> quicksilver: I'm not aware of any way of writing the axioms so that one of them essentially is induction; can you elaborate?
04:53:49 <mlesniak> How do I force evaluation in this very simple piece of code (Being a blockhead at the moment ;-))? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1956#a1956
04:54:32 <Deewiant> mlesniak: let s = sum [start..end] in s `seq` writeChan chan s
04:54:37 <Deewiant> Or pseq, or whatever
04:54:55 <mlesniak> Deewiant: Yes, right. Thanks
04:55:16 <byorgey> mlesniak: (x `seq` x) is always useless, since the first x will never be evaluated until the second one is.
04:55:25 <byorgey> I assume the same is true of pseq although I am not sure.
04:55:38 <MyCatVerbs> @src sum
04:55:39 <lambdabot> sum = foldl (+) 0
04:56:01 <insane_> is there any way to uninstall package using cabal?
04:56:21 <Deewiant> Nope.
04:56:21 <byorgey> insane_: no, but you can unregister it with ghc.
04:56:25 <MyCatVerbs> insane_: not at the moment. You can make the package invisible to ghc by using ghc-package unregister, though.
04:56:27 <byorgey> ghc-pkg unregister packagename
04:56:34 <insane_> thanks
04:56:40 <byorgey> or ghc-pkg unregister --user packagename
04:56:42 <Deewiant> If you want to free up disk space, you have to do it manually.
04:56:45 <byorgey> if it's installed locally
04:57:05 <insane_> i suppose that there is also no way to locate all the installed files after the installation?
04:58:00 <Deewiant> insane_: 'ghc-pkg describe packagename' shows the binaries, but not documentation and such
04:58:45 <Deewiant> ~/.cabal/packages/hackage.haskell.org/ is the most likely place for the latter, on *nix
05:00:57 <insane_> and is there anyone responsible for cabal and google summer of code
05:01:11 <insane_> i know that there is dcoutts but i can't reach him recently
05:06:58 * blackdog_ is writing heinous, explicitly recursive code, and not factoring out common patterns. suggested punishment?
05:07:40 <wli> blackdog: Implementing prolog technology theorem provers.
05:07:55 <MyCatVerbs> Having to debug the code you're writing will suffice.
05:08:11 <blackdog_> wli: you're a cruel man.
05:09:35 <wli> How does Haskell handle record expressions like "var { l1 = e1, l2 = e2, ... }" when var is a variant record with more than one constructor? Like data Rec = Con1 { lab1 :: Int } | Con2 { lab2 :: Int } ?
05:11:16 <ahamay42> wli: the record-notation is just a shortcut for an own accessor
05:11:30 <wli> let x = Con1 { lab1 = 1 } in x { lab2 = 2 } --> *** Exception: <interactive>:1:29-42: Non-exhaustive patterns in record update
05:11:44 <wli> ahamay42: I have my answer, yeah.
05:13:55 <ahamay42> hm, the {} notation is used just for declaring a type (and updating, but let's ignore this for now)
05:14:19 <wli> Well, I did in a file:
05:14:20 <ahamay42> let x = Con1 1 is still the constructor
05:14:33 <wli> data Rec = Con1 { lab1 :: Int } | Con2 { lab2 :: Int }
05:14:45 <wli> Then in ghci I did:
05:14:45 <ahamay42> yes, so now you have:
05:14:46 <wli> let x = Con1 { lab1 = 1 } in x { lab2 = 2 }
05:15:14 <ahamay42> Con1 :: int -> Rec
05:15:14 <ahamay42> lab2 :: Rec -> int
05:15:14 <ahamay42> etc
05:15:33 <ahamay42> these are the functions you declared with the definition
05:15:45 <ahamay42> what is your let x line supposing to do?
05:16:06 <wli> x { lab2 = 2 } must desugar to case x of { Con2 { lab2 = _ } -> Con2 { lab2 = 2 } | _ -> error ... }
05:16:34 <wli> ahamay42: Figure out if "updates" of labels inappropriate for the case are ignored or throw errors.
05:17:04 <ahamay42> they throw errors, I guess
05:17:53 <ahamay42> but then you should try
05:17:53 <ahamay42> let x = Con1 1 in x {lab2 = 2}
05:19:13 <wli> That's what I just did, isn't it?
05:19:38 <ahamay42> ah, maybe you aren't even allowed to declare different accessors for an "or-Type"
05:19:49 <ahamay42> does your type declaration already fail?
05:20:11 <wli> No, it works.
05:20:38 <ahamay42> ok, but that's not exactly what you did, as you try to use {} for building an instance
05:20:41 <wli> Now I have to figure out the syntax I want for record update/extension in my mini-language since it works differently.
05:20:58 <ahamay42> the Cons1 {lab1 = ..} is wrong
05:21:24 <wli> data Expr expr con lab var = ... |  ConExpr con (Map lab expr)  |  ExtExpr expr (Map con (Map lab expr))
05:21:37 <ahamay42> right: let x = Cons1 1
05:21:37 <ahamay42> wrong: let x = Cons1 {...}
05:22:44 <wli> I started there from the premise that updates/extensions would be tagged, but "var { lab1 = ..., lab2 = ..., ...}" doesn't give a way to qualify the labels with constructors.
05:22:52 <byorgey> ahamay42: that doesn't make a difference, it's the same thing.
05:24:57 <wli> extend expr with { Con1 { lab1_1 = ..., lab1_2 = ..., ...} ; Con2 { lab2_1 = ..., lab2_2 = ..., ...} ; ... } seems vaguely plausible.
05:25:22 <NameAlreadyInUse> @src fix
05:25:22 <lambdabot> fix f = let x = f x in x
05:25:39 <NameAlreadyInUse> is there a way to define fix that isn't recursive?
05:25:44 <wli> Where only the new or updated labels need to be specified, and only the constructors where label sets are manipulated need to be enumerated.
05:29:11 <ahamay42> sorry, I was wrong - though I don't see a point in using {} for building objects :)
05:29:36 <wli> I'm mostly trying to ape Haskell syntax for all this.
05:31:47 <wli> I guess I need to smoke out a primitive case expression.
05:33:12 <ahamay42> yes, so you're not allowed to update lab2 for something that didn't define lab2
05:33:36 <ahamay42> how about http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1958#a1958
05:33:51 <ahamay42> does that what you want?
05:33:59 <ahamay42> or didn't I understand something
05:34:21 <wli> In my mini-language's scheme updates would always be qualified with the constructor under whose case the label is supposed to occur, so it's another story.
05:34:45 <ahamay42> ok, so just use that syntax then =)
05:35:37 <wli> I was trying to figure out if Haskell had some way of doing updates that implicitly discriminated between cases or not. I wouldn't want to be less convenient in that instance.
05:36:20 <ahamay42> yes it does discriminate cases, but you should not update something your object doesn't have :)
05:36:29 <ahamay42> see my example
05:36:42 <ahamay42> the update works for Cons1 and Cons2
05:38:14 <insane_> why is it so that i can do ghc-pkg describe on some package, but when i try to do ghc-pkg expose on the same package it complains that it can't find that package
05:38:53 <wli> ahamay42: That is actually moderately interesting. I hadn't considered letting label names overlap like that. Now I'm concerned about the generality of my scheme.
05:39:54 <insane_> by the way the ghc-pkg describe of that package says that it is already exposed
05:40:46 <insane_> but trying to install a package that depends on one of the first package modules fails because it is hidden
05:43:31 <wli> ahamay42: I guess I can let each label set take a list of constructors.
05:45:19 <wli> ahamay42: And allow constructor sets to overlap within the case of the extension expression provided the label sets don't overlap with other label sets given to those constructors, so it can desugar to the sort of thing I laid out.
06:00:41 <FunctorSalad> did someone already write a TH macro for generating folds/eliminators from a data decl? (like foldr for List, either for Either, maybe for Maybe etc.)
06:03:14 <FunctorSalad> the advantage over pattern matching would be the pointlessness...
06:04:08 <byorgey_> FunctorSalad: not to my knowledge.  It would be a neat little project though.  Maybe I'll do it sometime. =)
06:05:12 <Saizan> FunctorSalad: mmorrow did
06:05:40 <FunctorSalad> Saizan: cool, is it on hackage?
06:05:57 <byorgey_> oh, did he?  I remember him talking about it, I didn't realize he had actually done it
06:06:16 <Saizan> not sure if it's on hackage
06:06:52 <FunctorSalad> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/th-fold
06:11:22 <FunctorSalad> yay it works \o/
06:34:51 <FunctorSalad> lol I solved my typechecking problem... forgot that I overrode (.) o_O
06:36:02 <ZsoL> hi
06:39:35 <byorgey> hi ZsoL
06:40:21 <byorgey> @remember FunctorSalad lol I solved my typechecking problem... forgot that I overrode (.)
06:40:22 <lambdabot> It is forever etched in my memory.
06:40:56 <vixey> hi
06:43:26 * wli screams because parsec sucks.
06:43:41 <Botje> in what way?
06:43:47 <Botje> i seem to have gotten a non-sucky version :)
06:44:09 <wli> It screws up parsing things with common prefixes.
06:44:19 <Botje> it doesn't screw up, it simply doesn't backtrack :)
06:44:26 <zachk> wli: i hate to say this but you are probably messing something up
06:44:28 <vixey> wli I think you gotta use try  for that
06:44:45 <stepcut> wli: that's a feature :)
06:44:50 <wli> That's called sucking. The class of grammars is grossly restrictive.
06:45:01 <vixey> hmm parsec is turing complete
06:45:16 <byorgey> no, it works for grammars where things have common prefixes.  You just have to put in explicit calls to "try".
06:45:34 <byorgey> so that it will backtrack.
06:45:35 <wli> That's retarded.
06:45:46 <vixey> wli: ReadP works the other way
06:45:50 <stepcut> wli: all parsers suck, they just suck in different ways
06:46:20 <byorgey> wli: I agree to some extent, but it allows greatly increased efficiency.
06:47:15 * wli may end up writing an LR parser out of sheer rage.
06:47:39 * vixey gets into the bunker
06:48:28 <stepcut> wli: you could use frisby, which has unlimited look ahead and linear time guarantees. But it has no way to report where a parse error occured.
06:50:19 <wli> I'm going to fight parsec for now. This try crap is going to end up peppered all over the place and the parser will end up grossly inefficient anyway because it backtracks instead of having states for common prefixes.
06:50:37 <Botje> factor the common prefixes out yourself?
06:51:33 <wli> ... and then modifying the language turns into a nightmare of rewriting it from scratch for every fresh construct.
06:54:45 <vixey> @seen jkff
06:54:45 <lambdabot> I haven't seen jkff.
06:56:14 <trofi> @uptime
06:56:14 <lambdabot> uptime: 15h 17m 32s, longest uptime: 1m 10d 23h 44m 29s
06:58:14 <wli> Every time I ram anything nontrivial through parsec I'm astounded. My reaction is something like "You've got to be kidding me... this is all this does? I could've hammered it out via recursive descent in less code."
07:12:31 <NameAlreadyInUse> do LL parsers typically require more tokens of lookahead than LR parsers for similar grammars?
07:13:49 <wli> omfg this is really bad ... the token stuff is getting floating point numbers wrong; time to junk parsec and just hammer it all out by hand with LogicT or some such.
07:15:06 <wli> NameAlreadyInUse: My horror and revulsion at LL parsers is too great to stop and explain
07:17:37 <killerstorm2> hi. is there a functionality like C #ifdef for Haskell (GHC)?
07:20:04 <ZsoL> killerstorm2: I can't really imagine how would that fit into the language
07:20:16 <vixey> You can use C #ifdef
07:20:27 <vixey> just run haskell code through c pre-processer
07:20:36 <vixey> this is clearly the worst possible solution to anything
07:20:51 <ZsoL> well yeah, obviously that'd work
07:20:59 <bremner> oh cmon, TeX as a preprocessor must be worse
07:21:34 * wli attempts to recover from being shaken/etc. by fury at parsec for long enough to hammer out a parser.
07:22:05 <vixey> wli what kind of thing are you parsing?
07:22:19 <wli> expressions in some mini-language.
07:22:29 <vixey> so like + - * / stuff?
07:22:57 <trofi> @package alex
07:22:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/alex
07:22:59 <wli> constructors, case, lets, record update/extension, etc.
07:23:09 <vixey> oh a bit more complex
07:23:12 <wli> Floating point, character, and integer literals.
07:23:25 <wli> String literals, too, I guess.
07:25:27 <killerstorm2> i need to make several slightly different variants of the program, i thought that conditional compilation is the best way to do this. yep, i know i can use an external preprocessor, but then it won't work smoothly with ghci, won't it?
07:26:18 <Deewiant> killerstorm2: GHC supports running the C preprocessor over your code 'transparently'
07:26:28 <Deewiant> Just put {-# LANGUAGE CPP #-} in the file
07:26:37 <Deewiant> And it will work with GHCi as well.
07:27:01 <killerstorm2> thanks
07:27:06 <chessguy> what does this mean?
07:27:08 <chessguy> sudo cabal install Game_tree
07:27:10 <chessguy> cabal: Failed to parse package dependency: "Game_tree"
07:28:05 <trofi> cabal install -v might say more
07:28:39 <chessguy> nope
07:29:08 <c_wraith> Maybe a syntax error in the .cabal file?
07:29:17 <cocon> is there a way to determine the mount of memory a particular object occupies (at runtime)?
07:29:28 <chessguy> c_wraith:  that's my guess
07:29:34 <vixey> cocon: Not really, even that doesn't make much sense
07:29:50 <chessguy> dcoutts:  ?
07:29:56 <vixey> cocon: e.g. how much memory does an infinite object take?
07:30:34 <cocon> vixey: it would be an impure function indicating how much of the infinite object has been un-thunked
07:30:34 <dcoutts_> @seen insane
07:30:34 <lambdabot> I saw insane leaving #haskell 15h 38m 53s ago, and .
07:32:43 <cocon> I don't understand the nfib example in section 6.1 of the manual (http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html)
07:33:05 <cocon> in the second call graph, why does all cost go to g, nothing to f?
07:35:47 <mk15> cocon: dont you mean why does it all go to f?
07:36:14 <wli> I'm choking on trying to come up with the basic organization for a nondeterministic parser with LogicT.
07:38:29 <wli> You feed the idiot thing a token and the thing either accepts, returning some value, rejects, or hands back a continuation. And I'm at a complete loss to represent this adequately.
07:42:08 <gwern> heh. 'Don Steward'
07:42:29 <gwern> (well, he wouldn't make a bad steward)
07:49:24 <wli> newtype Parser tok ast = Parser { runParser :: tok -> Logic (Either ast (Parser tok ast)) } ?
07:53:29 <laz0r> hi, i know about :t and :i which are very nice tools to verify the compiler inferes the expected type of an expression, and i was wondering, is there maybe a way to get compiler to tell me the types of 'buried' or nested expressions (for example a do expression inside another do expression)?
07:55:49 <drhodes> this recent interview @ http://www.se-radio.net/ might be of interest to some, regarding F#
07:57:08 <laz0r> i am just curious about that because i did just see the post about leksah on reddit, of which i used version 0.3, and i remembered that i liked the automatic type inference for every function that it shows very much, but i also thought it would be even cooler if it could be somehow possible to show the types of more or less arbitrary expressions and not only functions
08:00:29 <dancor> laz0r: ghci can't do nested expression types
08:00:33 <dancor> unfortch
08:00:57 <|jedai|> laz0r: It's not perfect but you can get the inferred type of a subexpression by passing it as a parameter
08:01:07 <laz0r> ok, but in theory it could, or am i wrong with that assumption?
08:01:29 <|jedai|> laz0r: like ":t \t -> 1 + t"
08:02:21 <FunctorSalad> Cafe: "I agree that the current badge is horrid (it looks like something that rolled down a hill and collected some rubbish on the way)"
08:02:22 <|jedai|> The type of the first parameter of the function type you get as a result is the inferred type of the subexpression
08:03:03 <FunctorSalad> (the logo)
08:03:20 <gwern> @quote dimensional
08:03:20 <lambdabot> ray says: three dimensional zippers make my scalp hurt when i get my hair caught in them
08:03:20 <|jedai|> laz0r: Or you can use the implicit parameter extension to this effect like this : ":t map (+5) ?a"
08:03:28 <gwern> @quote cracking
08:03:29 <lambdabot> dolio says: [regarding a paypal spam message on #haskell] Take that, Harrop! Does OCaml have illegal cracking utilities?
08:03:37 <|jedai|> @type map (+5) ?a
08:03:38 <lambdabot> forall a. (?a::[a], Num a) => [a]
08:03:42 <gwern> @quote absolutely.*horrible
08:03:42 <pejo> Does anyone else get "You are not authorized to access this page" on LtU?
08:03:42 <lambdabot> lament: says: I think I speak for everyone in this channel when I say haskell is absolutely horrible and nobody would ever want to use it
08:03:57 <gwern> pejo: no, ltu is up for me
08:04:03 <gwern> wasn't yesterday, but is now
08:04:15 <laz0r> |jedai|: ?a::[a] is completly new to me
08:04:16 <wli> This can't be this difficult.
08:04:29 <pejo> gwern, are you logged in?
08:04:36 <gwern> (hm. vmkit compiles jvm and .net to llvm? BUZZWORD OVERLOAD BZZT)
08:04:41 <gwern> pejo: no
08:04:47 <FunctorSalad> I think implicit params are considered evil, but I'm not sure how evil.
08:04:59 <Saizan> laz0r: internally a type is assigned to every subexpressions/declaration, you'd have to investigate the ghc-api to see if that information is exposed
08:05:05 <gwern> @quote stopped.*the
08:05:05 <lambdabot> MiguelMitrofanov says: The first glimpse of this [logo] vote scared me so much that I've closed the page, stopped the browser, and shut my computer down.
08:05:22 <gwern> @quote sew.*them
08:05:23 <lambdabot> osfameron says: <ImInYourMonad> can I store gtk2hs-Buttons in a datastructure? <osfameron> ImInYourMonad: I think you have to sew them on with gtk2hs-Thread
08:05:24 <pejo> gwern, odd. I can only view pages if I'm logged in.
08:05:35 <gwern> @quote \`
08:05:35 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
08:05:36 <laz0r> Saizan: ok, good, thats how i assumed things to be
08:05:38 <wli> Handcoding nondeterministic parsing can't be this hard to figure out.
08:05:42 <gwern> @quote `
08:05:42 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
08:05:46 <gwern> @quote `
08:05:46 <lambdabot> lambdabot says: Plugin `quote' failed
08:05:58 <gwern> @forget lambdabot Plugin `quote' failed
08:05:58 <lambdabot> Done.
08:06:14 <gwern> I really don't know why all those stupid lb and ghc error messages are in there
08:06:22 <gwern> @quote chrisdone
08:06:22 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
08:06:33 <gwern> @flush
08:06:40 <FunctorSalad> @help flush
08:06:40 <lambdabot> flush. flush state to disk
08:06:46 <vixey> @quote
08:06:47 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
08:07:04 <vixey> @quote
08:07:04 <lambdabot> glguy says: this is like Web 5GL. I like it
08:07:17 <vininim> wat
08:09:31 * FunctorSalad is still having a laughing fit from the "current logo looks like something that rolled down the hill and collected some rubbish on the way" thing
08:09:48 <Botje> katamari lambdacy!
08:09:50 <gwern> a katamari would be an improvement...
08:10:01 <gwern> katamari curracy?
08:12:48 <MyCatVerbs> FunctorSalad: what? Where on Earth did you find that?
08:13:28 <gwern> iirc -cafe
08:13:29 <FunctorSalad> correction: *a* hill
08:13:35 <FunctorSalad> yes, haskell-cafe MyCatVerbs
08:18:47 <|jedai|> laz0r: The type of the subexpression are available in the ghc-api but not easily... ?a is an implicit parameter, an extension available in GHC.
08:23:26 <ImInYourMonad> so Im doing a naturla number module. i have everything except for div working. div can be done 2 ways which are similar if i see t correctly. div a b, have c and d for counter and accumulator. add b to d until d >= a then return c. this deowsnt work for me though
08:23:32 <ImInYourMonad> isnt it correct?
08:23:45 <chessguy> is there some way of looking at a .cabal file locally to see if cabal can parse it?
08:23:53 <chessguy> s/looking at/testing/
08:23:59 <dcoutts_> chessguy: cabal check
08:24:24 <dcoutts_> that does a whole bunch of QA checks, though it also looks at other local files
08:26:42 <vininim> hmm... bio package doesn't read secondary structure info from pdb files?
08:27:11 <mikem`> hi, i'm a haskell beginner, trying to write a small app to do some analysis of the packages installed on my linux system. I'm trying to parse the version number from a package spec. the package name follows the format "<name>-<major>.<minor>-r<release>" and some other cases. What would be the best way to extract this from a string? I'm trying to do this with pattern matching, but I'm not sure this is the right way to go. any thoughts?
08:28:03 <mjb> mikem`: If the different options don't get too complex you can use a regex.
08:28:23 <ImInYourMonad> you could use bytestring + split,regexps,parsec isprobably overkill
08:28:35 <dcoutts_> mikem`: I'd recommend looking at simple parsing libraries, like parsec
08:28:38 <MyCatVerbs> Kidding? Parsec is the easy way.
08:28:59 <mjb> Bryan O'Sullivan just posted a regex intro the other day: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
08:29:18 <dcoutts_> mjb: learning something like parsec will be useful for this problem and other more tricky parsing problems. It's really useful to know.
08:29:26 <ddarius> The "other day" being over two years ago?
08:29:27 <dcoutts_> oops
08:29:27 <byorgey> Feburary 2007 is "the other day"? o.O
08:29:38 <dcoutts_> I meant to direct that comment to mikem` not mjb
08:29:42 <MyCatVerbs> Roughly, it'll look like, do { name <- word; char '-'; major <- integer; char '.'; minor <- integer; char '-'; char 'r'; release <- word; return (name,major,minor,release); }
08:29:57 * wli just dumped parsec out of frustration with its numerous "quirks."
08:30:23 <MyCatVerbs> If you run into ambiguity problems, use ReadP instead, which is slower but less annoying.
08:30:34 <dcoutts_> wli: there's also ReadP and polyparse. Those are more compositional. No 'try'.
08:30:53 <mikem`> MyCatVerbs: yeah, that's the algorithm I had in mind, except in reverse, since the names could potentially have dashes
08:31:13 <ImInYourMonad> to use my own Bool type id need to write a parser right?
08:31:14 <mikem`> mjb: i'm looking through the regex blog post too :)
08:31:17 <MyCatVerbs> mikem`: the names potentially have dashes? Forget Parsec, use ReadP.
08:31:17 <chessguy> dcoutts:  what would cause "cabal check" to not give any fatal errors, but when i try to "cabal install" the package, i get "abal: Failed to parse package dependency:"
08:31:19 <dcoutts_> mikem`: see for example the package name parser in Cabal
08:31:39 <mikem`> dcoutts_: ah, that's probably a great example right there :)
08:31:41 <mikem`> good idea
08:31:50 <FunctorSalad>  @type splitAt
08:31:51 <dcoutts_> chessguy: what makes you think that error is from parsing the .cabal file?
08:31:55 <FunctorSalad> @type splitAt
08:31:56 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:31:58 <chessguy> dcoutts:  just a guess
08:32:19 <MyCatVerbs> mikem`: Parsec is really only any good at LL(1) grammars. It *can* do LL(infinity), but in practice you shouldn't try to use Parsec for anything with ambiguity.
08:32:26 <chessguy> dcoutts_: it's not?
08:32:33 <ddarius> MyCatVerbs: That's ridiculous.
08:32:50 <dcoutts_> chessguy: what was the command line?
08:33:05 <chessguy> sudo cabal install packagename
08:33:14 <chessguy> is that what you're asking?
08:33:18 <Fran_73> help me plissssss
08:33:19 <Fran_73> help me plissssss
08:33:41 <dcoutts_> Fran_73: just ask your question
08:33:58 <Fran_73> i need shell linux plis......
08:33:58 <Botje> Fran_73: forty-two, red, no.
08:34:10 <jmcarthur> umm
08:34:11 <JanglerNPL> ?src mplus
08:34:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:34:26 <ski> @src [] mplus
08:34:27 <lambdabot> mplus = (++)
08:34:30 <Botje> Fran_73: this is not the right channel to beg for linux shell accounts. Unless you are going to develop haskell programs on them
08:34:32 <ski> @src Maybe mplus
08:34:32 <lambdabot> Nothing `mplus` ys = ys
08:34:32 <lambdabot> xs      `mplus` ys = xs
08:34:48 <FunctorSalad> class (Monad m) => MPlus m where mplus :: m a -> m a -> m a
08:34:57 <dcoutts_> chessguy: so it just says "Failed to parse package dependency:"
08:35:02 <FunctorSalad> hmm too slow for reverse turing test
08:35:06 <dcoutts_> chessguy: as if it is trying to parse "" as a dependency?
08:35:16 <ski> (s/MPlus/MonadPlus/)
08:35:30 <FunctorSalad> oops
08:35:37 <chessguy> dcoutts_:  sorry, let me just copy/paste
08:35:39 <chessguy> andrew-wagners-macbook:Game_tree awagner$ sudo cabal install Game_tree
08:35:40 <chessguy> cabal: Failed to parse package dependency: "Game_tree"
08:36:01 <MyCatVerbs> ddarius: how so? It's designed for constructing predictive parsers. Using try is often tricky, and generally slow as old beans.
08:36:05 <dcoutts_> chessguy: oh, hmm, is _ valid in package names, lemme see
08:36:12 <dcoutts_> Fran_73: I've no idea what question you're asking, if you're serious, try explaining what you mean.
08:36:37 <ZsoL> awww, too shy for that
08:36:39 <chessguy> i guess he wasn't serious
08:36:46 <jmcarthur> sounds like somebody wanting to try some hacking or something
08:37:16 <chessguy> sounds like somebody on drugs or something to me :)
08:37:17 <trofi> socially engineerered remote shell exploit
08:37:33 <jmcarthur> pretty bad social engineering though
08:37:33 <|jedai|> jmcarthur: Sounds like someone who hasn't a clue of what he's doing to me...
08:37:41 <jmcarthur> |jedai|: exactly
08:37:47 <dcoutts_> chessguy: seems _ isn't valid in package names.
08:37:51 <Botje> most "hacking" tutorials start with "get a linux shell account"
08:37:55 <chessguy> dcoutts:  aha, that would explain it
08:38:13 <chessguy> dcoutts_: i'm surprised cabal allowed it to be uploaded though
08:38:13 <ImInYourMonad> can I declare my own Bool isntance?
08:38:15 <dcoutts_> chessguy: the format is alpha-numeric components separated by -
08:38:21 <jmcarthur> most hacking tutorials are extremely outdated
08:38:57 <jedai> ImInYourMonad: Unfortunately Bool doesn't have a typeclass
08:38:58 <ddarius> MyCatVerbs: I don't think I've ever used Parsec on anything that was only LL(1).  Using try appropriately requires some simple rules of thumb, but it is certainly less complicated to understand than understanding parsing in the first place.  Using a normal LL(infinity) recursive descent parser is like using 'try' everywhere.  It isn't going to faster.
08:39:33 <dcoutts_> chessguy: I don't think Game_tree has been uploaded to hackage, there's game-tree though.
08:39:46 <ImInYourMonad> when defining the naturla number sim using haskells environemnt, sint that cheating alreayd ahving Bool etc?
08:39:59 <chessguy> holy cow
08:40:03 <chessguy> did i really typo the name?
08:40:05 <jedai> ImInYourMonad: It would be pretty useful for small embedded language sometimes
08:40:13 <chessguy> wow
08:40:19 <wli> I'm not all that interested in speed. The weird LL/whatever issues are just far beyond infuriating to me.
08:40:31 <chessguy> Game_tree is the module name, not the package name :(
08:40:36 <FunctorSalad> @whereis hashell
08:40:36 <lambdabot> Maybe you meant: where where+
08:40:40 <chessguy> i'm an absolute moron
08:40:41 <FunctorSalad> ;)
08:40:46 <dcoutts_> chessguy: perhaps we can make the error message clearer that it's the specification of the dependency itself that's bad, not the .cabal package that it might be referring to.
08:40:55 <dcoutts_> cabal: Failed to parse package dependency: "Game_tree"
08:41:08 <dcoutts_> on it's own is possibly slightly ambiguous
08:41:19 <jedai> ImInYourMonad: You'll have to restate your latest message with correct letter ordering if you want help... ^^
08:42:09 <ImInYourMonad> When defining the natural numbers I'm using GHC's environment, isn't that cheating already having Bool etc?
08:42:09 <dcoutts_> chessguy: how about: cabal: "Game_tree" is not valid syntax for a package name or package dependency.
08:42:20 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2726#a2726 <- my nat module.can i be imroved?
08:42:34 <chessguy> dcoutts_: sounds good to me, but you might just be manufacturing a bigger moron :)
08:42:49 <chessguy> i.e., fool-proof methods just create worse fools
08:42:58 <dcoutts_> heh
08:43:30 * chessguy considers banning himself from computers for a year as penance
08:43:57 <ImInYourMonad> wait,lt is wrong
08:43:58 <zachk> chessguy just quit watching tv
08:43:58 <jedai> ImInYourMonad: I don't know what you mean by "cheating" in this context... If you're encoding natural arithmetic based on Church I don't see what having Bool in your language has to do with anything
08:44:04 <chessguy> zachk:  i don't
08:44:24 <zachk> chessguy: have a library card or friends you can get wasted with?
08:44:35 <chessguy> zachk:  i'm just naturally this dumb :)
08:44:49 <chessguy> i can get wasted with a library card?
08:44:58 * chessguy scratches his head
08:45:00 <jedai> s/Church/Peano/ in your case
08:45:14 <zachk> chessguy: thats a BIG (||)
08:45:54 <chessguy> zachk:  function application binds very tightly :)
08:46:03 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2726#a2727 <- why isnt that working?
08:47:24 <jedai> ImInYourMonad: there is a gt in your latest definition of lt... I'm guessing it's a typo
08:48:43 <jedai> ImInYourMonad: Also the first two lines can be summed by "lt _ 0 = False"
08:51:14 <ImInYourMonad> duh
08:51:25 <ImInYourMonad> thnx
08:52:23 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2728#a2728 now done
08:52:34 <ZsoL> hmm, graph rewriting is fun
08:53:11 <ImInYourMonad> natural numbers are fun!
08:53:20 <ImInYourMonad> my naturals are more natural than yours!
08:54:06 <wli> Parsing monads are an SOB.
08:54:14 <ski> (ImInYourMonad : next time, please annotate the original paste with updates)
08:55:46 <ImInYourMonad> @src odd
08:55:46 <lambdabot> odd = not . even
08:56:02 <ImInYourMonad> @src even
08:56:02 <lambdabot> even n = n `rem` 2 == 0
08:56:08 <wli> (>>=) for parsing monads is throwing me for a loop
08:56:09 <ImInYourMonad> @src rem
08:56:10 <lambdabot> Source not found. You untyped fool!
08:56:56 <ski> (wli : left-recursion .. ?)
08:57:43 <wli> ski: LogicT should deal with that I hope; I just can't figure out how to write (>>=) at all.
08:57:59 <RayNbow> ImInYourMonad: what do you want to know about rem?
08:58:06 <ski> are you implementing a parsing monad, on top of `LogicT' ?
08:58:19 <wli> ski: Yes.
08:58:45 <wli> I got sick of crippling limitations in essentially everything else.
08:58:51 <FunctorSalad> > (-1 `rem` 5, -1 `mod` 5)
08:58:52 <lambdabot>   (-1,-1)
08:58:53 <ski> (i don't know the details on `LogicT', but i'd be surprised if it handled left-recursion always)
08:59:17 <zachk> ack: how do i get zlib for cabal-install working on ubuntu
08:59:26 <FunctorSalad> uh I thought at least one of the two was properly normalizing :p
08:59:39 <ski> wli : is your attempt available anywhere ?
08:59:51 <FunctorSalad> > -1 `divMod` 5
08:59:52 <lambdabot>       No instance for (Num (t, t))
08:59:52 <lambdabot>        arising from a use of `negate' at <...
09:00:05 <FunctorSalad> @type divMod
09:00:06 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:00:10 <wli> momentarily
09:00:11 <ski> > (-1) `divMod` 5
09:00:12 <lambdabot>   (-1,4)
09:00:24 <FunctorSalad> :)
09:00:30 <ski> (unary minus strikes again !)
09:00:51 <wli> http://wli.pastebin.com/m1022b1d8
09:01:53 <ski> why `Maybe' ?
09:02:06 <wli> Nothing stands in for $
09:02:17 <wli> End of input $ from parsing that is.
09:03:06 <wli> Maybe that's stupid. No idea.
09:03:53 <ski> hmhm
09:04:15 <RayNbow> > let {toBase base 0 = [0] ; toBase base n = unfoldr (\x -> case x `quotRem` base of {(0,0) -> Nothing ; (q,r) -> Just (r,q)}) n} in toBase 2 24
09:04:16 <lambdabot>   [0,0,0,1,1]
09:05:07 <FunctorSalad> @src Integral
09:05:08 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:05:08 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:05:08 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:05:08 <lambdabot>     toInteger           :: a -> Integer
09:05:10 <ski> wli : since you usually not only call `return' at the "end", i'm trying to interpret sending `Nothing' to mean feeding a parser with no inputs
09:05:35 <wli> By Nothing I mean end of input.
09:05:43 <wli> Not no input.
09:05:56 <wli> The "dollar" symbol from parsing.
09:06:11 <ski> then how would `return a >>= k' work ?
09:06:22 <ski> according to a monad law, it should be the same as `k a'
09:06:37 <wli> I don't know that I've done it correctly.
09:06:55 <ski> your implementation will ask for maybe a token, pass it to `return a', which will barf if there actually was a token passed
09:06:57 <ImInYourMonad> divide 3 2 -> 2, that siw rong for them naturals to rightie man?
09:07:09 <ski> > div 3 2
09:07:11 <lambdabot>   1
09:07:19 <ImInYourMonad> RayNbow: timecompelxity of rem
09:07:22 <LeoD> > rem 3 2
09:07:24 <lambdabot>   1
09:07:32 <wli> The parsers should fail upon encountering unexpected ends of input.
09:07:49 <FunctorSalad> . o O ( what's the equivalent of (>>=) for ordinary monoids? )
09:08:08 <ski> FunctorSalad : `mappend', sortof
09:08:14 <ImInYourMonad> data Nat = O | S Nat deriving(Eq, Ord, Show) , what base is that really?
09:08:23 <zachk> im getting strange errors attempting to install cabal-install. here is the current error message http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2729#a2729
09:08:44 <FunctorSalad> ski: I mean, considering a monad as a monoid in Hask -> Hask (there mappend is join)
09:09:05 <ski> wli : so assume the parser `lbracket' accepts only the (single) character `(', and you call the parser `return () >>= \_ -> lparen' with input just containing the (single) character `('
09:09:05 <jedai> ImInYourMonad: Unary if any
09:09:06 <ddarius> FunctorSalad: That question is like asking "Given the additive monoid on naturals, what's the equivalent of (*) for other monoids?"
09:09:15 <ImInYourMonad> unary?
09:09:24 <ski> (s/lparen/lbracket/ :)
09:09:33 <Botje> zachk: sounds like a linking error with zlib
09:09:38 <ski> wli : what will your code do ? what should your code do ?
09:10:24 <vixey> isn't Hask -> Hask a functor
09:10:33 <ski> it's a functor category
09:10:56 <ImInYourMonad> what's Hask?
09:10:59 <zachk> botje: what do i do to fix it
09:11:00 <wli> ski: The end of input isn't involved so lbracket need only reject it.
09:11:02 <jedai> ImInYourMonad: Well yes
09:11:18 <zachk> ImInYourMonad: it has to do with category theory. its the category of haskell types i believe
09:11:19 <FunctorSalad> ddarius: I'm not stupid, I know it doesn't make sense :p I was just wondering whether there unexpectedly is some back-translation
09:11:23 <wli> ski: It sees one token, accepts if it's lbracket, rejects if it's anything else.
09:11:26 <jedai> ImInYourMonad: Hask is the Haskell types category
09:11:46 <ski> wli : your code first passes a (maybe) token to the left argument to `(>>=)', namely, `return ()', no ?
09:12:08 <ski> in the parser `return () >>= \_ -> lbracket', i mean
09:12:14 <Botje> zachk: i'm not sure. check what symbols your libz offers?
09:12:24 <Botje> what platform are you on?
09:12:36 <wli> ski: Sure.
09:13:05 <ski> wli : and `return ()' refuses to accept it, so your whole parser will fail, in that case, no ?
09:13:32 <ski> (refuses to accept it, in case it was `Just ...', which it was in this case, because it was the `(' character being passed)
09:13:35 <wli> ski: Why would return () refuse to accept it?
09:14:16 <chessguy> anyone seen the ESC/Haskell stuff for more compile-time error checking? looks interesting
09:14:23 <chessguy> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
09:14:26 <ski>   return x = Parser step where
09:14:32 <ski>           step (Just _) = fail ""
09:14:33 <ski>           step Nothing = return $ Left x
09:14:43 <RayNbow> gaaaaaaaah *kicks browser*
09:14:49 <ski> `step' will fail, if given any actual token
09:15:02 <wli> Yeah, once you've generated an AST you're done.
09:15:05 <RayNbow> it entered a paste to hpaste prematurely :/
09:15:09 <pejo> chessguy, there's a popl paper from this year as well, and I guess a thesis about it.
09:15:26 <ski> wli : look again at the `return () >>= \_ -> lbracket' parser
09:15:42 <ski> wli : do you see how trying to get this parser to accept the `(' token will fail ?
09:15:45 <chessguy> looks like a more detailed paper here too: http://pop-art.inrialpes.fr/~naxu/research/dana-phd.pdf
09:15:57 <vixey> I try to write a parser too
09:16:00 <wli> ski: I guess it would fail.
09:16:01 <ski> wli : even though, this parser *ought* to be the same as just `lbracker' ?
09:16:04 <vixey> but putting a specification in the type
09:16:08 <ski> (according to a monad law)
09:16:28 <vixey> it makes things like accumulator parameters very awkward
09:16:33 <wli> Maybe Nothing has to stand for en epsilon transition.
09:16:36 <ski> wli : this indicates to me that something is wrong .. here
09:16:44 <ski> yes, that might work
09:16:49 <wli> an epsilon transition
09:19:11 <ski> wli : anyway, i find it somewhat strange that the parser itself doesn't decide directly whether it wants to accept a new token, or not .. rather the caller decides to feed it with either an actual token, or nothing, when calling it
09:19:42 <wli> ski: I'm all ears for better designs.
09:19:49 <drdozer1> I have a problem with types :(
09:20:49 <ski> wli : i suppose i might ask the parser whether it can succeed immediately, or whether it wants to look-at / eat a token, before possibly deciding (or looping around)
09:20:50 <vixey> drdozer me too
09:20:52 <drdozer1> I have [String] and (forall b . Either a b) that I need to zip into [(String, a)]
09:21:06 <vixey> drdozer: what the heck is forall b . Either a b
09:21:19 <ski> @type Left ()
09:21:20 <lambdabot> forall b. Either () b
09:21:34 <vixey> juts use a in the first place
09:21:35 <drdozer1> hum, an Either where all the 'a' components are the same, but the 'b' components can be different
09:21:44 <vixey> 'b' components can be different -- is wrong
09:21:55 <ski> drdozer1 : no, that's not what that type says
09:22:06 <drdozer1> ah, that could be part of my problem then
09:22:16 <vixey> drdozer: it's more like  there is no valid b component, except _|_
09:22:30 <drdozer1> so how do I say what I meant to say?
09:22:47 <ski> drdozer1 : `forall b . Either a b' is a type where any `Left' component has to be of type `a' (a given type), and any `Right' component has to be of *every* type `b', at the *same*time* !
09:22:51 <vixey> drdozer1: It  doesn't make sense
09:23:03 <drdozer1> ski: ah, ok
09:23:22 <vixey> you should just zip [String] an [a] to get [(String, a)]
09:23:31 <ski> drdozer1 : you might (or might not) want `exists b. Either () b' .. which must be rendered in haskell packed into an "existentially quantified data type"
09:24:18 <quicksilver> but the information content of exists b . Either a b
09:24:25 <quicksilver> is precisely the infromation content of 'a'
09:24:25 <drdozer1> ski: so I could make my own 'either' type that uses the gadt notation to 'hide' the type of b, perhaps?
09:24:31 <quicksilver> so you might as well just use 'a'.
09:24:36 <ddarius> quicksilver: Not true.
09:24:51 <quicksilver> ok, Maybe a
09:24:58 <ImInYourMonad> data Nat = O | S Nat deriving(Eq, Ord, Show) <- what base is that?
09:24:58 <ddarius> There you go.
09:25:08 <wli> ski: http://wli.pastebin.com/m25ddb47e
09:25:08 <ski> ImInYourMonad : no
09:25:14 <ImInYourMonad> no?
09:25:25 <ski> it's not numerals in a positional system
09:25:28 <ddarius> In particular, exists b. Either a b <=> Either a (exists b. b) <=> Either a () <=> Maybe a
09:25:32 <ksf> is there already a package that provides basic list-ops on top of a single, read-only Ptr region, or do I have to roll my own?
09:25:35 <ImInYourMonad> so it is numerals in?
09:25:45 <ksf> (or at least something I could steal from)
09:25:48 <ski> it's sometimes called "unary", but that's a misnomer
09:25:58 <drdozer1> can I say exists in haskell code?
09:26:12 <ddarius> Yes and no.
09:26:19 <drdozer1> as in the keyword
09:26:23 <ski> drdozer1 : you can in some cases in jhc (maybe lhc,nhc (yhc ?) too ?)
09:26:23 <ddarius> No.
09:26:38 <ddarius> hbc has free existentials.
09:26:40 <vixey> data Exists p where Witness :: forall x. p x -> Exists p
09:26:50 <vixey> data Exists p where Witness :: x -> p x -> Exists p
09:26:56 <vixey> various sorts of things like this work
09:27:02 <vixey> mostly they are useless
09:27:56 <ski> (wli : sorry i'm getting distracted)
09:28:28 <drdozer1> I'm not even trying to do anything with the Right component of Either! It shouldn't be so hard to ignore it
09:28:44 <drdozer1> kk, I will find another solution
09:29:03 <EvilTerran> ImInYourMonad, i'd call that "peano numerals"
09:29:18 <EvilTerran> ImInYourMonad, as in http://en.wikipedia.org/wiki/Peano_axioms
09:29:21 <ski> (`[forall b. Either a b] -> [a]' should work, btw)
09:30:18 <EvilTerran> ImInYourMonad, as "data Nat = O | S Nat" could be read as "there exists O :: Nat; forall x :: Nat, exists S x :: Nat"
09:31:08 <ddarius> map (\ab -> case ab[Void] of Left a -> a; Right v -> void v)
09:31:41 <vixey> = map (\ab -> case ab[Void] of Left a -> a)
09:31:45 <vixey> hopefully
09:33:28 * ski managed to freeze up his screen attach ..
09:33:39 <ImInYourMonad> what is the diff between rem and mod?
09:34:18 <ski> wli : consider the same parser `return () >>= \_ -> lbracket' .. now `return ()' will eat a token, without telling whether it actually used it, or not
09:34:41 <wli> That doesn't sound very hopeful. :(
09:35:38 <ski> the "traditional" parser monad is `newtype Parser tok ast = P ([tok] -> [] (ast,[tok]))'
09:35:55 <ski> here the parser will return the tokens it didn't eat
09:36:02 <ImInYourMonad> @src mod
09:36:02 <lambdabot> Source not found.
09:36:09 <ImInYourMonad> @src rem
09:36:09 <lambdabot> Source not found. Take a stress pill and think things over.
09:36:14 <ImInYourMonad> @src div
09:36:15 <lambdabot> Source not found. It can only be attributed to human error.
09:36:20 <cocon> is Parsec lazy?
09:36:25 <ski> possibly you'd rather pass one token at a time, than a list (or whatever) of tokens
09:36:33 <vixey> cocon: Haskell is lazy :p
09:36:47 <ski> but i think you either want to return unused tokens, or make sure unwanted tokens are never passed in
09:36:50 <vixey> cocon: Parsec you don't know if you get Left or Right (failure/success) until the entire thing parsec (or not)
09:37:17 <vixey> until the entire thing parsed**
09:37:29 <cocon> vixey: so if I do 'seq' on the result I'm sure it's done?
09:37:34 <vixey> no
09:37:40 <vixey> seq doesn't really do anything interesting
09:37:53 <ski> wli : i guess it depends somewhat on what you're after
09:38:32 <ski> cocon : you know the parse is done as soon as the parsing action monadically return
09:38:47 <wli> Fewer headaches than dealing with the parsing combinators out there.
09:38:56 <ski> (:
09:39:08 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2728#a2733 , ok si added modulo and is Prime, does it look ok?
09:39:29 <cocon> ski: the top-level parse function is not monadic
09:39:43 <cocon> vixey: let r = parse p "" s in r `seq` x
09:39:51 <cocon> vixey: this doesn't do the trick?
09:39:54 <ski> cocon : then you just need to check whether the "run" function for the parser gives a success or not
09:40:03 <ski> cocon> :t parse
09:40:07 <vixey> cocon: Don't use seq
09:40:15 <cocon> vixey: why?
09:40:32 <vixey> it doesn't do anything interesting
09:40:38 <drdozer1> kk, I've found another way to do this, by converting Either a b into Maybe a - it's more ugly, but at least it compiles
09:40:51 <ImInYourMonad> wtf why does 3*3return 12!=
09:41:03 <cocon> vixey: I'm having memory issues
09:41:03 <ski> > 3*3
09:41:05 <lambdabot>   9
09:41:10 <cocon> vixey: so I want to force eval
09:41:11 <ski> > 3*3  where _ * _ = 12
09:41:12 <lambdabot>   12
09:41:53 <ski> (drdozer1 : maybe i missed it, but do you have a paste that hopefully eludicates about what you're trying to achieve ?)
09:43:16 <drdozer1> ski: It doesn't really matter now - the uglyness can only be seen within a module - it's not exported, and it's only on 7 lines
09:43:22 <Olathe> ImInYourMonad: Your definition of multiplication is wrong.
09:43:32 <Olathe> ImInYourMonad: Do 3*3 by hand with it.
09:43:43 <drdozer1> nameErrors ["child", "continuation"] [etm ea, etm eb]   vs    nameErrors ["child", "continuation"] [ea, eb]
09:43:58 <drdozer1> etm is converting eithers to maybes to make that list well-behavied
09:44:03 <ski> drdozer1 : but maybe we can improve it to not be ugly .. if only we (read : i) could understand what you're after
09:44:04 <Olathe> ImInYourMonad: You have 3*3 = 2*6 = 1*12
09:44:10 <vixey> is upside down ampersand actually a unicode symbol?
09:44:27 <ski> wli : .. anyway, it looks to me like you want to feed parsers one token at a time, for whatever reason. so it seems to me that the parser telling whether it needs to eat another character or not, might be a working choice
09:44:57 <c_wraith> vixey: turned ampersand, codepoint 214B
09:45:13 <ski> vixey : Girard uses it. we must not question the authorities
09:45:15 <Olathe> ImInYourMonad: But do it by hand anyway, since that's a good debugging method.
09:45:25 <vixey> thank you 
09:45:28 <vixey> how did you know?
09:45:38 <c_wraith> looked it up in the mac character palette
09:45:45 <c_wraith> it's really good for finding random unicode characters
09:46:01 <zachk> has anyone had problems installing cabal-install on ghc-10.1
09:46:16 <wli> ski: I don't actually care about feeding them one token at a time.
09:47:04 <Olathe> ImInYourMonad: Also, if you'd like: lt _ 0 = False; lt 0 _ = True; lt (S a) (S b) = lt a b; gt a b = lt b a
09:47:14 <vixey> , , 0, 1, , &, , ,
09:47:19 <ski> wli : since a nondeterministic parser might want to either succeed right away, or eat another token, one might do something like `newtype Parser tok ast = P (Logic (Either ast (tok -> Parser tok ast)))'
09:47:34 <cocon> Is 'seq' associative (operationally)?
09:47:41 <Igloo> vixey: Searching for "ampersand" in gucharmap would find it
09:48:50 <Olathe> cocon: Nope.
09:48:58 <vixey> I thought seq was associative
09:49:00 <vixey> why isn't it?
09:49:01 <Olathe> cocon: If you only look at the final result, sure.
09:49:26 <ski> (wli : btw, i'm not here considering how hard it would be to create space leaks ..)
09:49:28 <Olathe> cocon: But while it's computing, it uses everything seqed to the left in the function that's running on the right.
09:49:38 <cocon> (a `seq` b) `seq` c
09:49:48 <ksf> is there a way to specify definitions from the current module qualified?
09:49:55 <cocon> a `seq` (b `seq` c)
09:49:56 <Olathe> cocon: So, a function in the middle can be slow or fast depending on the order.
09:50:10 <cocon> isn't it a, b, then, c in both cases?
09:50:24 <wli> ski: Weird, I tried that at some point.
09:50:26 <ksf> IMHO, importing the current module just shouldn't result in a cycle.
09:50:27 <ski> wli : if you prefer passing all the tokens to the parser, instead, you could do `newtype Parser tok ast = P ([tok] -> Logic (ast,[tok]))', no ?
09:50:29 <Olathe> cocon: Sure.
09:50:36 <ski> (returning the uneater tokens)
09:50:48 <cocon> Olathe: so where's the difference?
09:50:51 <Olathe> cocon: With five, I think you get differences, though I could be wrong.
09:51:12 <wli> ski: That seems kind of foul since it duplicates the entire input stream.
09:51:14 <cocon> how is five different from three?
09:51:28 <ski> wli : for the former case, `return' would always succeed immediately, without demanding to eat any token at all
09:51:35 <c_wraith> cocon, have you ever thrown a holy hand grenade? :)
09:51:37 <ski> wli : "duplicates", in what sense ?
09:51:39 <Igloo> cocon: If you actually want more control over order of evaluation with GHC then you should use pseq
09:51:44 <drdozer1> cocon: ask two
09:51:49 <ski> wli : wrt space leaks ?
09:52:05 <cocon> c_wraith: ?
09:52:10 <wli> ski: Every time there's a nondeterministic choice you get a new list.
09:52:27 <c_wraith> cocon: bad reference to a monty python joke.  if you haven't seen the movie, don't worry about it
09:52:27 <ski> ok
09:52:42 <Olathe> cocon: Hmm, I think you're right.
09:52:44 <cocon> Igloo: what's pseq?
09:52:50 <Olathe> cocon: It can't matter.
09:53:00 <ski> ("It *is* the rabbit !")
09:53:38 <cocon> Igloo: I read that pseq is for parallelism
09:53:45 <Olathe> cocon: The thing on the far left always has to go first.
09:53:56 <Olathe> cocon: Then the next leftmost has to go, and so on.
09:54:13 <cocon> Olathe: so it looks associative...
09:54:19 <Olathe> cocon: Yeah, it is.
09:54:24 <ddarius> Olathe: seq does not guarantee any order of evaluation.
09:54:35 <ski> wli : so, what do you think about the former one, then ?
09:54:39 <vixey> this bits Synthetic connectives
09:54:43 <vixey> cool
09:54:49 <ski> vixey ?
09:54:51 <Olathe> ddarius: It doesn't ?
09:54:56 <wli> ski: Probably workable.
09:55:07 <Igloo> cocon: See http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html#v%3Apseq
09:55:32 <Olathe> ddarius: Ahh, I looked it up. You're right.
09:55:46 <wli> ski: I'm trying to hammer out (>>=) for it, which seems difficult.
09:55:46 <ddarius> Olathe: The semantics are: _|_ `seq` x = _|_ and a `seq` x = x.  That doesn't keep x from being evaluated first and then a.  pseq does guarantee an order (is my understanding)
09:56:06 <Olathe> ddarius: Ahh.
09:56:36 <Olathe> Hmmm...
09:56:47 <cocon> ddarius: the documentation of pseq seems to suggest that they have the same semantics
09:56:54 <cocon> ddarius: only an operational difference
09:56:59 <ddarius> They do have the same semantics.
09:57:08 <ddarius> You can't tell the difference semantically.
09:57:37 <cocon> so what is seq good for?
09:57:46 <ski> hm
09:58:01 <ispiked> if I have a function that needs to do random operations that's deeply nested from main (like four function calls deep), is there any alternative but to pass the random number(s) through all these parent functions?
09:58:03 <vixey> cocon: nout
09:58:05 <ahamay42> http://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Arrow_limitations mentions some problems people had when trying nasty stuff with arrows. Could anyone give me a pointer to more information about that?
09:58:10 <cocon> the pseq doc says the difference is that seq is strict in its second argument
09:58:15 <ispiked> that is, after I've calculated the random numbers in main
09:58:18 <ddarius> cocon: Forcing things that wouldn't otherwise be forced.  Not giving a specific order.
09:58:29 <cocon> vixey: ?
09:58:49 <EvilTerran> cocon, the semantics of seq allows things to be forced sooner than would be allowed otherwise
09:58:52 <vixey> @src seq
09:58:52 <lambdabot> Source not found. That's something I cannot allow to happen.
09:59:11 <EvilTerran> cocon, so the use of seq *allows* a certain order of evaluation that wouldn't otherwise be possible
09:59:14 <cocon> EvilTerran: which things? first or second arg?
09:59:18 <EvilTerran> (because of risk of nontermination etc)
09:59:26 <jedai> cocon: I think the difference between pseq and seq may only be seen by impure observation (and performance difference)
10:00:05 <cocon> EvilTerran
10:00:10 <cocon> : interesting
10:00:11 <jedai> cocon: The first argument is forced in weak head normal form as soon as the expression itself is forced
10:00:40 <ski> wli : something like `P p >>= amb = P (p >>= \e -> case e of {Left a -> unP (amb a); Right tp -> return (Right (\t -> tp t >>= amb))})' ?
10:01:05 * wli wtf's
10:01:08 <cocon> EvilTerran: is pseq different in that respect?
10:01:22 <EvilTerran> cocon, that's beyond my knowledge, i'm afraid
10:01:33 <ddarius> cocon: pseq is semantically identical to seq.
10:01:43 <michaelcdever> hey, was reading that Text.Regex.Posix is quite inefficient, and that there are more efficient libraries, but I couln't find a link to them, anyone know what they are?
10:01:46 <ski> @src (>=>)
10:01:46 <lambdabot> Source not found. Take a stress pill and think things over.
10:02:22 <jedai> cocon: The only difference between pseq and seq is the optimization the compiler could do on them, which could affect the order in which the arguments are evalued
10:02:23 <ski> wli : `(\t -> tp t >>= amb)' can be replaced with `tp >=> amb', if i'm not mistaken
10:02:36 <ski> (well, still wrapped in brackets)
10:02:40 <dons> byorgey++ http://www.reddit.com/r/programming/comments/86fpp/haskell_weekly_news_what_a_week_ghc_jhc_facebook/
10:02:40 <RamzaB> I have a question, is haskell translated directly to assembly, or is it translated to C and then to assembly?
10:02:49 <EvilTerran> (f >=> g) x = (x >>= f) >>= g -- iirc
10:02:53 <ddarius> RamzaB: Yes.
10:02:53 <Botje> RamzaB: both!
10:02:56 <dons> RamzaB: both and more
10:02:56 <ski> hmhm
10:03:08 <RamzaB> what do you mean both?
10:03:08 <EvilTerran> sometimes it's translated into javascript...
10:03:09 <ski> @type \f g x -> f x >>= g
10:03:10 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
10:03:10 <jedai> cocon: which in turn could affect the performances (especially when there are uses of `par` in the mix)
10:03:13 <Botje> RamzaB: recent versions of GHC have a very efficient backend that translates directly to assembly
10:03:21 <Botje> but there's still the option of going through C
10:03:22 <RamzaB> oh
10:03:28 <ski> @type \f g x -> (x >>= f) >>= g
10:03:29 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> m a1) -> (a1 -> m b) -> m a -> m b
10:03:30 <cocon> ddarius: semantically, but operationally?
10:03:43 <ddarius> cocon: They may or may not be operationally identical.
10:03:48 <ski> EvilTerran : so, nope
10:03:53 <ddarius> seq = pseq is a completely valid definition of seq.
10:04:00 <RamzaB> is there an flag for ghc to compile directly to assembly?
10:04:03 <EvilTerran> ?type (>=>)
10:04:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:04:08 <ddarius> RamzaB: -fasm
10:04:09 <EvilTerran> ah
10:04:14 <RamzaB> ok thanks
10:04:19 <EvilTerran> (f >=> g) x = f x >>= g -- in that case
10:04:22 <cocon> ddarius: well, for them to be really useful we want to know something about their operational semantics, no?
10:04:22 <ddarius> RamzaB: However, it is the default in most recent versions of GHC.
10:04:23 <jedai> cocon: As said in the doc of pseq, a seq b could be optimized so that b is evalued before a while a `pseq` b couldn't
10:04:30 <ski> EvilTerran : right :)
10:04:36 <ddarius> cocon: Usually it doesn't matter.
10:04:43 <RamzaB> cool
10:05:06 <jedai> cocon: You shouldn't see any differences... Except if you use `par`, maybe
10:05:17 <cocon> ddarius: well, I'm fighting against memory leak, so I want to make sure that a thunk gets normalized so the GC can see that it doesn't retain anythintg
10:05:42 <cocon> jedai: I actually notice considerable differences in memory usage
10:05:53 <jedai> cocon: for this kind of use, seq or pseq should work as well
10:06:21 <wli> ski: I've no idea what amb or P or unP are.
10:06:24 <jedai> cocon: I mean between seq and pseq, not between seq/pseq and nothing
10:06:56 <ski> wli : `amb' is just a local variable name, you called it `g' .. `P',`unP' is your `Parser',`runParser'
10:07:13 <cocon> I retain that seq = pseq, but they have different operational semantics
10:07:42 <cocon> so 'pseq' doesn't have to do anything with parallelism?
10:07:55 <jedai> cocon: Indirectly it have
10:08:03 <ddarius> cocon: pseq has a specific operational semantics, seq does not.  For current versions of GHC, there is usually a(n unobservable) difference.
10:08:31 <cocon> ddarius: seq does not??
10:08:32 <jedai> cocon: It's better to use pseq than seq when you mix it with par.
10:09:01 <cocon> jedai: I'm interested in 'par' at the moment
10:09:22 <jedai> cocon: But really if you come to have this kind of preoccupation you should be using the strategy library directly
10:09:30 <cocon> ddarius: is this based on the Haskell 98 def?
10:09:44 <ddarius> cocon: No.  pseq isn't in Haskell 98.
10:10:00 <ddarius> cocon: The semantics I gave for seq though, do come straight from the Report.
10:10:18 <ddarius> There's just more than one way to implement seq's semantics.
10:10:20 <idnar> @type (liftM .) . retrun
10:10:21 <lambdabot> Not in scope: `retrun'
10:10:21 <idnar> er
10:10:23 <idnar> @type (liftM .) . return
10:10:24 <lambdabot> forall a1 r (m :: * -> *) a. (Monad m) => (a1 -> r) -> a -> m a1 -> m r
10:10:34 <ddarius> pseq picks one particular way.
10:11:05 <idnar> @type liftM . return
10:11:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => r -> m a1 -> m r
10:11:11 <idnar> hmm, no
10:11:29 <cocon> ddaruis "it says it's usually introduced to improve performance"
10:11:41 <zachk> ok if i have cabal-install working it should just be cabal install frag    correct?
10:11:48 <cocon> "by avoiding unnecessary laziness"
10:11:55 <vixey> Every connective is definable in terms of every other + negation (in linear logic)
10:12:22 <dcoutts_> zachk: right
10:12:31 <vixey> s/every other/any other/
10:13:04 <idnar> @type (return .)
10:13:05 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
10:13:24 <idnar> oh, duh
10:13:25 <ski> idnar : might you tell what type you're after ?
10:13:46 <idnar> (a -> b) -> a -> m b was what I wanted
10:13:59 <vixey> idnar: that's pretty much just return
10:14:17 <ski> @type runKleisli . arr
10:14:18 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> c) -> b -> m c
10:15:06 <ddarius> :t \f -> fmap f . return
10:15:07 <lambdabot> forall a b (f :: * -> *). (Monad f, Functor f) => (a -> b) -> a -> f b
10:15:32 <ddarius> Go, go naturality.
10:18:02 <cocon> what does it mean that the second argument of "pseq" is non-strict?
10:18:41 <ski> @free return :: a -> M a
10:18:41 <lambdabot> $map_M f . return = return . f
10:19:33 * ski would have assumed `pseq' was strict in both arguments ..
10:19:41 <ddarius> ski: It is semantically.
10:19:50 <ddarius> cocon: It's referring to the way pseq is implemented in GHC.
10:20:29 <cocon> ddarius: so the term "strictness" here is different from what is it usually?
10:20:33 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2734#a2735 <- ok fixed, had to go shopping. now is natural number sok?
10:21:42 <ddarius> cocon: No, the statement is "In contrast to seq, pseq is only strict in its first argument (as far as the compiler is concerned)"  It is talking about what the compiler knows.
10:22:09 <singintime> hello everybody
10:22:17 <cocon> how can I observe an operational difference between seq and pseq? (without using par)
10:22:36 <vixey> hi singintime
10:22:49 <zachk> cabal install frag failed D:
10:22:55 <singintime> is there anybody who has some experience with HaXml
10:22:56 <singintime> ?
10:22:56 <vixey> I wonder why this happens: 1, 0, ,
10:23:01 <vixey> one of them should be upside down
10:23:15 <vixey> very odd
10:23:22 <ski> (is that supposed to be a one-sided sequent ?)
10:23:24 <vixey> do you have something in TeX to flip a symbol
10:23:28 <ddarius> cocon: You can try to use unsafePerformIO, but even then you may not see anything.  pseq has operational guarantees that seq does not, seq could be implemented as pseq in which case there would be no operational difference.
10:23:29 <vixey> so just a list of symbols
10:23:56 <cocon> ddarius: I tried to use unsafePerformIO, but couldn't find a discerning example
10:24:58 <ski> (i can't see what the last symbol is, though ..)
10:25:13 <wli> I'm getting wrong answers from sequencing. :(
10:25:34 <idnar> "UP TACK"?
10:25:40 <ImInYourMonad> so what kind of fund can id o with the natural numbers?
10:25:54 <idnar> how many symbols were suppoed to be there?
10:26:03 <ski> (wli : paste .. ?)
10:26:28 <wli> let parse (Parser p) [] = do { Left x <- p ; return x } ; parse (Parser p) (c:cs) = parse (Parser $ do { Right q <- p ; runParser $ q c }) cs ; letter x = Parser . return . Right $ Parser . fmap Left . guard . (== x) in observeAll $ parse (letter 'c' >> letter 'a') "ca"
10:26:42 * ski wonders if "UP TACK" is the "top" symbol
10:26:55 <wli> Parser p >>= f = Parser $  p >>= return . Right . ((const . f) `either` ((f =<<) .))
10:29:20 <vixey> I just noticed I'm reading about "hypersequentialized calculus "
10:29:22 <vixey> wtf..
10:30:59 <ski> wli : your `(>>=)' differs from mine in the `Left' case ..
10:31:35 <wli> ski: I can't tell how.
10:31:42 <ski> wli : in mine, when `p' succeed, i continued directly with `f', but you consume another token (and ignore it), first
10:32:11 <ski> wli : because you always return something of form `Right ..'
10:33:03 <ski> (after the running of `p', i mean)
10:33:26 <wli> Okay...
10:33:53 <ski> you could, i suppose, insert an extra dummy step in between, if you wanted .. but then you'd have to change the type definition
10:34:38 <ski> (such a dummy step might perhaps be useful for executing parsers in parallel .. i'm not sure)
10:34:58 <wli> trying
10:35:05 <ski> (in any case, that `const' there is wrong)
10:38:50 <rovar> is there a bytestring equivalent of show?
10:39:06 <Deewiant> pack . show
10:39:13 <wli> Parser p >>= f = Parser $  p >>= either (runParser . f) (return . Right . ((f =<<) .))
10:39:17 <wli> That seems to work.
10:39:36 <ski> that looks better
10:39:53 <rovar> i thought pack.show would have worked, but i'm getting
10:39:55 <rovar>     Couldn't match expected type `Word8' against inferred type `Char'
10:39:56 <rovar>       Expected type: [Word8]
10:39:58 <rovar>       Inferred type: String
10:40:00 <rovar>     In the first argument of `pack', namely `(show (i))'
10:40:01 <rovar>     In the expression: (pack (show (i)))
10:40:15 <Deewiant> pack . map c2w . show
10:40:23 <rovar> ah ha!
10:40:35 <wli> ski: I also get correct results from sequencing now.
10:40:36 <Deewiant> If you can assume that 'show' outputs only ASCII
10:40:41 <Deewiant> If not, use utf8-string.
10:40:56 <ski> Happy Happy Joy Joy.
10:41:27 <jedai> rovar: Use ByteString.Char8
10:41:51 <jedai> Or utf8-string if you're not working with 8bit encodings
10:49:59 <trofi> is there mechanism to hide some packages from mueval? (like ghci's -hide-package)
10:54:35 <wli> ski: There are problems.
10:54:45 <jekor> Speaking of UTF8 oddities, I'm having a very strange one.
10:55:30 <ski> wli : elaborate ?
10:55:55 <jekor> I changed Text.XHtml.Strict's stringToHtmlString to not encode characters > 0xFF. Now something Text.Formlets is crashing my program. And there's no non-ASCII characters on my page...
10:56:00 <wli> ski: runPred :: (tok -> Bool) -> Parser tok (Seq tok) is unimplementable.
10:57:20 <wli> ski: It has to make an epsilon transition. :(
10:57:24 <ski> where `Seq' is some sequence type and you want to parse as many tokens as possible, yes ?
10:57:31 <wli> Yeah.
10:57:38 <jekor> Could it be a problem with Text.Formlets using bytestrings somewhere?
10:57:45 <ski> you need look-ahead for this .. the parser doesn't provide that, atm
11:00:08 <Saizan_> why is transformers + monads-fd better than mtl?
11:00:09 <wli> Or maybe I need to think in terms of sentential forms.
11:00:42 <vininim> it would be so awesome if pdb already had dssp entries
11:07:12 <wli> ski: I would think a better option is to return whether the input was consumed or not.
11:07:18 <man3x> !country man3x
11:07:43 <ski> hm .. maybe
11:09:14 <wli> This is rapidly turning into a nightmare.
11:09:44 <catface> does base>=4 imply ghc 6.10?
11:10:27 <ski> i guess one first needs to ask whether it would suffice with the parser telling beforehand whether it succeeded, or whether it wants to consume a token, or whether it wants to look at a symbol ..
11:10:51 <ski> .. vs. getting a symbol, and only telling afterwards whether it wants to consume it or not
11:12:28 <dons> catface: no, but ghc 6.10 ships with base 4.0.x
11:12:40 <catface> thanks
11:13:56 <ski> .. and i suppose the answer would be that the former would not suffice
11:16:21 <wli> You can't know until you see a "wrong token" that you're handing back a result.
11:16:28 <ski> right
11:16:40 <ski> so, do you just want one token in look-ahead
11:16:41 <ski> or more ?
11:17:21 <ski> (well, you can, if you accept that some solutions will eat less tokens than possible .. but i think you didn't want that)
11:17:33 <wli> Lookahead is bad in interactive environments.
11:18:51 <ski> seeing a "wrong token" and deciding that enough is enough, is lookahead
11:19:42 <wli> I'm working in terms of processing. You can't demand to look at tokens ahead of the cursor.
11:20:45 <ski> then how would `runPred :: (tok -> Bool) -> Parser tok (Seq tok)' work ?
11:22:32 * Baughn wonders if it's safe to use unsafePerformIO on the HsOpenSSL rsakey-to-string function
11:23:01 <wli> It would have to return a pair of (Bool, ast) with the fst False to show that it failed to consume a token, at which point the driver re-runs it and feeds the un-consumed token and the AST to the continuation somehow.
11:23:38 <ski> how could it return an `ast' if it hasn't finished parsing ?
11:24:23 <ImInYourMonad> is it easy to do a church numerals module as i did one for natural numbers? maybe I should make a basic lambda calculus interpreter
11:24:26 <wli> The rejected token triggers the return of an AST. The Boolean flag indicates rejection of the token.
11:27:09 <ImInYourMonad> is there no way to have multimethods in Haskell? they have to be of the same data then?
11:28:26 * bremner has no idea what multimethods are
11:28:32 <ski> CLOS
11:28:50 <Baughn> ImInYourMonad: Plenty of ways, actually, all depending on exactly what you're trying to do
11:29:19 <ImInYourMonad> well lets say I want (^) for my Nat, I cant import hide Prelude but then I cant do 2^3
11:30:01 <Baughn> @type (^)
11:30:02 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:30:13 <sarh> but you can have (^) for your Nat
11:30:30 <Baughn> ImInYourMonad: You can't change the type of an already existing function (though you can hide it), but there's a multi-method right there, wouldn't you say?
11:30:37 <Baughn> It works on any Integral type
11:31:06 <Baughn> Or rather, any combination of Integral and Num parameters
11:31:17 <ski> wli : should a parser, when fed a token, be allowed to say that it actually didn't want to eat that token, and *also* didn't want to eat the *n* previous tokens ?
11:31:32 <ski> wli : or should it just be able to refuse this last token ?
11:32:27 <wli> ski: Only the last one, because you can't unwind the previous ones. You can only try to catch up with the ones that made progress.
11:32:35 <ImInYourMonad> ok
11:32:41 <ImInYourMonad> is it easy to do a church numerals module as i did one for natural numbers? maybe I should make a basic lambda calculus interpreter
11:32:56 <wli> ski: Because you can't unwind the ones that consumed their input, that is.
11:32:57 <ImInYourMonad> is that a smallproject?
11:33:03 <ImInYourMonad> liek a brianfuck interpreter?
11:33:46 <zachk> ImInYourMonad: do scheme in 48 hours
11:34:19 <ski> wli : ok, so just one token lookahead, then
11:35:04 <wli> It's turning into a disaster. Having to hand-write lexing for oodles of escape sequences is going to take aeons.
11:35:25 <ski>   newtype Parser tok ast = MkParser {unParser :: Logic (Either ast (tok -> Either ast (Parser tok ast)))}  -- hm ?
11:36:05 * ski wonders
11:36:22 <wli> This stuff about lookahead is a disaster, too. Hand-writing the parser is not going well.
11:38:34 <ImInYourMonad> zachk: i dont like jsut following along a tutorial
11:38:54 <ImInYourMonad> but data Lambda = Lambda Lambda ?
11:39:39 <ski> (vertical natural numbers)
11:39:51 <ImInYourMonad> data Lambda = Var | Lambda Lambda deriving(Show)
11:39:51 <Saizan_> "I should add that mentioning "equality" is the
11:39:52 <Saizan_> best way to start a fight at a gathering of more than
11:39:54 <Saizan_> zero type theorists."
11:40:00 <wli> alex and happy are sounding attractive compared to this.
11:40:09 <zachk> iminyourmonad: no get a stopwatch and see if you can write an r5rs scheme without the tutorial in 48 hours
11:40:18 <singintime> can somebody help me with HaXml?
11:40:18 <Saizan_> that means that a type theorist will fight with himself?
11:40:27 <singintime> please?
11:40:47 <ski> Saizan_ : obviously, yes
11:41:09 <vixey> hehe
11:41:22 <vixey> sounds like you are reading something by Conor
11:44:26 <Saizan_> yup
11:46:02 <jekor> OK. I've narrowed this down more. showHtml' has type HtmlElement -> ShowS. If I return `(++) ""' the program crashes, but if I return `(++) "anything here"' the program runs successfully (and the "anything here" shows up nowhere in my output!). This is really strange.
11:46:04 <wli> ski: The parsing algorithm has to work an entirely different way. Whatever I've come up with is complete crap.
11:46:46 <ski> how should it work ?
11:47:11 <ImInYourMonad> what does the symbol E mean in logic? it is not quite an E but a soft E
11:47:28 <wli> ski: If I knew I'd start on that.
11:47:42 <ski> ImInYourMonad : you might be looking at an "elementhood" symbol
11:48:05 <ski> then `a E A' would mean that `a' is an element of the set `A'
11:48:14 <ddarius>  ?
11:50:05 <wli> ski: Preferably something like ordinary parsing where things like viable prefixes, handles, sentential forms, etc. are dealt with.
11:50:39 <ImInYourMonad> ddarius: yes that one
11:51:54 * ski goes shopping
11:52:27 <wli> Yeah, it's time for alex and happy.
12:01:31 <ImInYourMonad> Parsec.char, is there Parsec.string?
12:01:43 <dejones> I'm having issues creating a cabal package --  Setup.lhs: Distribution/Simple/GHC.hs:151:6-51: Irrefutable pattern failed for pattern Data.Maybe.Just ghcPkgVersion
12:01:51 <dejones> Any suggestions on how to fix that error?
12:01:54 <dejones> Or what may be causing it?
12:02:23 <dejones> dcoutts_: you around?  help me with cabal.  :)
12:02:43 <dcoutts_> dejones: looks like ghc is not there
12:03:13 <dcoutts_>   let Just ghcPkgVersion = programVersion ghcPkgProg
12:03:23 <cschneid> is the guy behind lhc in here?  (or somebody who knows ghc pretty well?)
12:03:31 <dcoutts_> dejones: ghc-pkg is not configured, but it should always be configured
12:04:49 <dcoutts_> cschneid: Lemmih and SamB
12:05:37 <cschneid> really, I am trying to meld ruby + haskell :)  Call haskell code from ruby.  An abomination, I know. I got fairly far w/ ghc, but it doesn't like running w/o a main() function defined (linkage errors).
12:06:10 <dcoutts_> dejones: ah, no, it is configured but we don't know its version, which should also be impossible
12:06:15 <SamB> cschneid: I really wouldn't suggest trying to do anything useful with LHC right now ;-)
12:06:32 <dcoutts_> dejones: since we used requireProgram with (orLaterVersion (Version [0] [])) so that should fail if the version is not known
12:06:43 <dejones> dcoutts_: odd.  $GHC_DEV/bin/runhaskell Setup.lhs configure --with-hc=$GHC_DEV/bin/ghc --prefix=$GHC_DEV
12:06:46 <dejones> that's the command I'm using
12:07:03 <SamB> but if you want to talk anyway, maybe #lhc-compiler would be a better place to do it ?
12:07:04 <dcoutts_> dejones: and is ghc-pkg in the same dir as ghc?
12:07:18 <dejones> dcoutts_: I am trying to build with GHC HEAD.  Yes, ghc-pkg is in same dir as ghc
12:07:38 <dcoutts_> dejones: run with -v3 and see what version it thinks ghc-pkg is
12:08:27 <dejones> dcoutts_:  $GHC_DEV/bin/ghc-pkg -V
12:08:27 <dejones> GHC package manager version 6.11.20090221
12:08:39 <dejones> dcoutts_: -v3 didn't work...?
12:09:05 <dcoutts_> dejones: what do you mean it didn't work?
12:09:31 <dejones> dcoutts_: $GHC_DEV/bin/ghc-pkg -v3
12:09:31 <dejones> ghc-pkg: unrecognized option `-v'
12:09:31 <dejones> unrecognized option `-3'
12:10:08 <dcoutts_> dejones: I mean pass -v3 to the Setup.lhs configure  call, not pass it to ghc-pkg
12:10:19 <dcoutts_> dejones: what command are you running exactly?
12:10:19 <dejones> dcoutts_: Oh.  :)
12:11:27 <dcoutts_> dejones: if you have time to track it down I'd appreciate it. It should be impossible since requireProgram checks the version if the requested version range is not AnyVersion
12:11:38 <dcoutts_> see Distribution/Simple/Program.hs requireProgram
12:12:30 <dejones> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2739#a2739
12:12:34 <edwardk> @seen lispy
12:12:34 <lambdabot> lispy is in #haskell-blah, #darcs and #haskell. I last heard lispy speak 12h 10m 17s ago.
12:13:18 <dcoutts_> dejones: you're passing -v3 to runhaskell
12:13:49 <dcoutts_> I mean it as a parameter to the Setup.hs program, not a parameter to the Haskell interpreter
12:14:13 * vixey wishes programmers would stop 'considering' things
12:14:24 <dejones> dcoutts_: fixed -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2739#a2741
12:14:28 * edwardk considers stopping.
12:14:50 <adityam> Can ghci print utf8 characters?
12:15:18 <adityam> I am using putStr from System.IO.UTF8 but I get things like "\372" on ghci
12:15:24 <Zao> adityam: Grab utf8-string
12:15:24 <ImInYourMonad> hwo can I parse a wholestirng in Parsec? ie make it return "lambda" bot just 'a'?
12:15:33 <newsham> adit: try putStr/putStrLn
12:15:42 <newsham> err, oops, you did that
12:15:46 <dcoutts_> dejones: ok, I see why now, but it should still be impossible
12:16:02 <ddarius> ImInYourMonad: By reading the documentation.
12:16:03 <dejones> dcoutts_: any suggestions on what I can do to fix?  :)
12:16:34 <dejones> dcoutts_: Is it because of my multiple versions of GHC?
12:16:36 <dcoutts_> dejones: specify --with-compiler instead of the --with-hc-pkg flag
12:16:49 <newsham> Prelude> putStrLn "'\xce\xbb'"
12:16:49 <newsham> ''
12:16:54 <newsham> works over here.  *shrug*
12:16:59 <dcoutts_> dejones: there is no --with-hc flag, but it auto-completes to --with-hc-pkg
12:17:08 <dcoutts_> dejones: so you're telling it to use ghc as ghc-pkg
12:17:38 <dcoutts_> dejones: subtle eh? :-)
12:17:38 <edwardk> newsham: isn't that cheating?
12:17:47 <goomba``> ImInYourMonad, you want to parse a string but return something other than the string?
12:17:49 <newsham> ed: how so? he asked if it can print utf8.
12:17:51 <dejones> dcoutts_: ah yes!  I confused options... I did mean --with-compiler, thanks!  Quite subtle.
12:17:52 <newsham> thats utf8.
12:18:24 <dejones> dcoutts_: Nice catch.  :)
12:18:40 <edwardk> newsham: yes, but its encoded as a string of chars, since chars are at least 21 bits, it seems kinda silly ;)
12:18:43 <Saizan_> dcoutts_: still weird that requireProgram didn't throw an error
12:18:55 <dcoutts_> Saizan_: indeed, I'm looking at that now
12:19:04 <newsham> edwardk: utf8 is a string of 8-bit characters.  I dont understand your point.
12:19:08 <dcoutts_> Saizan_: if you can spot it first you win a biscuit :-)
12:19:24 <Saizan_> :D
12:19:28 <newsham> I had assumed he already has utf8 from his question.
12:19:52 <edwardk> newsham: i was presuming he meant something like getting '\372' to display the unicode character when putstrln'd automatically as utf8
12:20:22 <newsham> oh, he's asking for a utf8 encoder?
12:20:43 <edwardk> not sure
12:20:51 * edwardk shrugs
12:21:03 <dcoutts_> Saizan_: ah hah! I bet I know
12:21:44 <dejones> dcoutts_: what was it?  :)
12:21:52 <dejones> (other than my confusion of options!)
12:22:37 <dcoutts_> dejones: isAnyVersion (orLaterVersion (Version [0] []))  is True
12:22:52 <dcoutts_> so it short-cuts and doesn't look at the ghc-pkg version
12:23:09 <dcoutts_> it used not to be true, but it is now
12:23:15 <dejones> hmm
12:23:29 <dcoutts_> the reason is that isAnyVersion is no longer a syntactic check
12:23:40 <dcoutts_> it's a semantic check.
12:23:51 <newsham> Codec.Binary.UTF8.String.encodeString from utf8-string?
12:24:12 <dcoutts_> dejones, Saizan_: and semantically >=0 is the same as True, as a version range predicate
12:24:31 <edwardk> that reminds me, i have my cheesy utf8 parsing monoid, but i guess i also need one that can generate utf8 bytes from chars
12:24:31 <dcoutts_> find me a package version that satisfies one and not the other
12:24:36 <dejones> lol
12:24:54 <dcoutts_> version numbers are bounded below at 0
12:25:22 <dejones> dcoutts_: interesting.  Funny that my confusion exposed that subtleness.
12:25:23 <dejones> ;)
12:25:28 <dcoutts_> dejones: indeed
12:25:51 <dcoutts_> dejones: I realised this thing about version ranges when I was writing QC tests of their properties
12:26:24 <dcoutts_> and so had to adjust their model so that instead of considering ranges being unbounded below, they're bounded by 0
12:27:18 <dons> i love manlio's throw-away line today, "Since it provides an infinite stream of random data, things should be ok"
12:27:38 <SamB> dcoutts: huh. In debian, they aren't bounded below at all
12:27:46 <SamB> you can always make them lower by adding ~ at the end
12:28:19 <dcoutts_> SamB: huh? 0~ < 0 ?
12:28:27 <SamB> yes
12:28:34 <dcoutts_> those crazy debian folks :-)
12:28:48 <SamB> hey, it's actually useful for pre-releases or things like that
12:28:59 <Igloo> They are bounded below, but it's an open bound
12:29:09 <SamB> Igloo: hmm ?
12:29:14 <dcoutts_> for fudging things when upstream are foolish with their version numbers
12:29:20 <dcoutts_> Igloo: right
12:29:28 <Igloo> You cannot make a version smaller than -1, for example
12:30:00 <Igloo> dcoutts_: It's so that you can have 6.10.2~rc1 rather than having to fudge 6.10.1.999.2rc1 or something
12:30:20 <SamB> yeah, so-called epochs are for when upstream mess up
12:30:25 <dcoutts_> Igloo: gentoo uses some funny ordering on pre,rc,blah,blah
12:30:55 <dcoutts_> so 6.10.2-rc1 is considered < 6.10.2
12:31:01 * Igloo prefers Debian's approach  :-)
12:31:05 <SamB> me too
12:31:16 <dcoutts_> pre < rc < {} < patch < something else I can't remember
12:31:28 <SamB> though I wish the policy manual gave more tips (or pointers to such) about how to use the mechanism it defines
12:31:28 <Igloo> So presumably o-rc1 < 0 in gentoo too?
12:31:39 <Igloo> Sorry, 0-rc0 < 0
12:31:40 <dcoutts_> Igloo: I guess so
12:31:50 <sundaymorning> shouldn't 6.10.2-rc1 be considered less than 6.10.2?
12:32:10 <sundaymorning> after all 6.10.2 looks like a final release
12:32:12 <dcoutts_> sundaymorning: yes, exactly
12:32:33 <sundaymorning> hm, guess I missunderstood you then
12:32:51 <SamB> sundaymorning: special-casing on certain strings after the dash isn't the nicest way to do that
12:33:36 <dons> what's the preferred programmable chart library these days? haskell-charts? haskell-gnuplot?
12:33:55 <sundaymorning> it's better that the maintainer follows a distro standard, I suppose
12:34:29 <Zao> My favourite drawing library now is TikZ for LaTeX.
12:34:39 <Zao> It'd be nice to have a library for Haskell with similiar syntax.
12:34:50 <eu-prleu-peupeu> hi
12:34:56 <ddarius> Zao: Make it.
12:35:10 <rovar> is there a directory traversal lib in haskell?
12:35:11 <Zao> ddarius: My free time quota is out :(
12:35:27 <sundaymorning> you have a free time quota on saturdays? :(
12:35:34 <dons> rovar: i think so. dig around on hackage.
12:35:37 <ddarius> Zao: You should talk to the system administrator.
12:35:47 <dons> Zao: i'll check it out.
12:35:52 <dcoutts_> rovar: depends what you're looking for exactly
12:36:17 <rovar> dcoutts_,  what I want is basically   FilePath -> [FilePath]
12:36:32 <ddarius> (:[])
12:36:41 <dcoutts_> rovar: so recursive dir listing
12:37:01 <rovar> yea, not even recursive, a single dir is fine as well.
12:37:02 <dcoutts_> rovar: if you don't find anything on hackage, there's code to do this in the tar package that you could extract
12:37:24 <dcoutts_> rovar: ohh, if it's just a single dir then you just use System.Directory.getDirectoryContents
12:37:28 <rovar> getDirectoryContents :: FilePath -> IO [FilePath]
12:37:32 <rovar> yea, just found it
12:37:48 <dcoutts_> @hoogle FilePath -> [FilePath]
12:37:49 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
12:37:49 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
12:37:49 <lambdabot> System.FilePath.Posix splitPath :: FilePath -> [FilePath]
12:37:54 <dcoutts_> @hoogle FilePath -> IO [FilePath]
12:37:54 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
12:37:54 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
12:37:54 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
12:39:05 <dcoutts_> ah, the full hoogle search result for FilePath -> [FilePath] does give getDirectoryContents with the IO in the result
12:39:13 <rovar> yep
12:39:31 <dcoutts_> yay for hoogle
12:39:33 <rovar> i just hoogled for directory and it was the top result
12:43:20 <jberryman> Is there any code out there that is used to benchmark Data.Map? like a regression test suite? or can anyone recommend an application that makes heavy use of Map?
12:45:25 <dons> the avl tree libs have benchmarks
12:45:38 <dons> including for the reimplementation of finite maps)
12:45:56 <dons> all rumours seem to be that Map can be improved with better structures, but there's been no clear champion to push through the complexity
12:46:20 <dons> a simple, obivously faster replacement for just Data.Map out of all that avltree work would be a great result
12:48:29 <ImInYourMonad> Char -> String
12:48:47 <dons> (:[])
12:49:09 <ImInYourMonad> thnx
12:49:13 <dons> robot monkey is irrepresible!
12:49:48 <Saizan> ?quote eat.a.comment
12:49:48 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
12:50:05 <dons> he also likes bananas
12:50:29 <ImInYourMonad> fun :: Text.Parsec.Prim.ParsecT
12:50:29 <ImInYourMonad>          String u Control.Monad.Identity.Identity Char
12:50:29 <ImInYourMonad> can that be simplified ?
12:50:32 <dons> dcoutts_: i want to send threatening emails to people who don't constrain 'base' versions
12:50:33 <ImInYourMonad> the typeI mean
12:50:54 <dcoutts_> dons: I want to make hackage enforce it, but I've had other things at the top of my TODO
12:50:59 <dons> dcoutts_: to bring runhaskell Setup.hs configure in line with cabal-install
12:51:21 * dons builds some more packages, and starts sending "hey, you need base >= 4 mails"
12:51:27 <dcoutts_> dons: if you want to write the patch, see this ticket...
12:51:32 <ImInYourMonad> what datastruxcture is normally used for abstract syntax tree? bst?
12:51:36 <dons> or base < 4 actually, is mooore common
12:51:54 <dancor> ImInYourMonad: type Parsec s u = ParsecT s u Identity
12:51:57 <dancor> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Prim.html#v:ParsecT
12:52:18 <dcoutts_> dons: http://hackage.haskell.org/trac/hackage/ticket/435
12:52:24 <dons> k.
12:52:45 <pejo> ImInYourMonad, the tutorials for making an interpreter are actually great and well worth your time.
12:52:50 <dcoutts_> dons: it should be easy now using the new VersionIntervals stuff. I just have not had time.
12:53:05 * dancor surprised he hasn't seen more "all your base" jokes with cabal-install, i guess it's too groan even for the internet
12:53:10 <dons> oh heh
12:53:45 <Heffalump> could hackage have an everything package?
12:54:05 <dcoutts_> dons: ah, I know why I stopped. I was half way through implementing it when I realised it was a bit more tricky than I thought.
12:54:27 <dons> Heffalump: seems like a good idea! would help test compilers...
12:54:33 <dcoutts_> dons: it's a property that we're checking holds in all possible configurations
12:54:39 <dons> ghc 6.10.2 comes out -> "please cabal install everything"
12:54:42 <Igloo> Heffalump: Do you mean a package that depends on everything? It wouldn't be installable
12:54:43 <dcoutts_> Heffalump: you mean all of hackage?
12:54:56 <dcoutts_> it's not possible to install all of hackage consistently
12:54:57 <dons> it'd have to be a maintained set of package list
12:55:00 <Heffalump> yes, I do, and while it wouldn't install successfully, it'd try everything under it, first, wouldn't it?
12:55:02 <dons> that is consistent
12:55:03 <jberryman> dons: thanks, I'll have a look at the AVL tree lib
12:55:04 <dancor> also the package would change so much it might as well not be a package?
12:55:05 <dons> the largest possible set
12:55:08 <Heffalump> or would it stop at the first failure?
12:55:10 <dcoutts_> maximal subset is around 90% of hackage
12:55:19 <Igloo> Heffalump: No, it would fail to make an installation plan
12:55:20 <dancor> and instead a "list"
12:55:23 <dons> yeah, that's about right. i think arch is up to 86%
12:55:25 <Heffalump> oh, right
12:55:27 <dons> and we exclude some haxml stuff
12:55:50 <dcoutts_> Heffalump: I have tested this for the 90% that where we can actually construct an install plan.
12:55:51 <dons> it doesn't have to be kept live though
12:55:56 <dons> it could just be a set at each ghc release
12:55:58 <dons> for testing purposes
12:56:01 <dcoutts_> Heffalump: and it doesn't stop on the first failure.
12:56:09 <dancor> or it could be live just to be kwlr
12:56:09 <dons> actually, it kind of complements the platform idea
12:56:15 <dons> the platform is the minimal useful set
12:56:19 <dcoutts_> Heffalump: it uses the dep tree to keep going for things that did not depend on the failing one
12:56:21 <dons> the everuthing package is ... everything
12:56:38 <Heffalump> so the key thing is regression testing, obviously
12:56:42 <dcoutts_> right
12:56:48 <dons> would it make sense to have other meta-packages?
12:56:49 <dons> the 'windows' package
12:56:50 <dcoutts_> I'm about to blog about what I did for Cabal
12:56:52 <dons> the 'macosx' package
12:57:00 <Heffalump> one problem is things like gtk2hs
12:57:13 <Heffalump> i.e. outside hackage but with things in hackage that depend on it
12:57:16 <dcoutts_> Heffalump: yes, it just has to be installed first
12:57:28 <Heffalump> doesn't it also depend on things in hackage?
12:57:33 <dcoutts_> Heffalump: we can generate machine readable reports and then use a simple query (list comp) to select all regressions
12:57:48 <dcoutts_> I did that for Cabal-1.6.0.1 vs Cabal-1.6.0.2
12:57:58 <dcoutts_> and we can do the same for ghc-6.10.2, haddock releases etc
12:58:47 <Heffalump> mtl changes
12:59:30 <dons> cabal has made CPP less important
12:59:41 <dcoutts_> dons: the everything package is really the maximal consistent subset of hackage, anything bigger is not very useful.
12:59:45 <dons> remember how we used to really care about, e.g. cpphs, for consistent substitutions?
12:59:51 <dons> now i hardly ever touch cpp
12:59:57 <Heffalump> darcs is still using it
13:00:38 <Heffalump> on a tangent: we need a good solution to the Windows C library problem
13:00:57 <dons> i wonder how we get a windows team.
13:01:05 <dons> sigbjorn's doing lots of great windows work  atm
13:01:21 <dcoutts_> I could do more if I had a Windows license
13:01:25 * dcoutts_ should get one
13:01:30 <chessguy> @type map ?f . filter ?p
13:01:31 <lambdabot> forall b a. (?p::a -> Bool, ?f::a -> b) => [a] -> [b]
13:01:37 <dons> dcoutts_: ihg could buy one, i guess.
13:01:53 <dons> e.g. galois needs windows stuff specifically under IHG work
13:02:01 <Igloo> Isn't the problem that there is no good solution for Windows C libraries?
13:02:19 <dcoutts_> in simple cases Cabal can build the C lib
13:02:22 <dcoutts_> from source
13:02:27 <dcoutts_> eg zlib
13:02:43 * Heffalump likes the zlib solution, but presumably it doesn't work in complex cases?
13:02:46 <Igloo> That's not a good solution, but it does make it convenient for the average user
13:02:54 <dons> is bulat using haskell commercially?
13:02:55 <ImInYourMonad> is there an irc channel for people doing mods for comuputer games?
13:02:59 <dcoutts_> Igloo: aye
13:02:59 <dons> i get the impression he is?
13:03:07 <chessguy> @type minimum []
13:03:08 <lambdabot> forall a. (Ord a) => a
13:03:12 <dons> ImInYourMonad: please stay on topic.
13:03:18 <chessguy> > minimum []
13:03:19 <lambdabot>   * Exception: Prelude.minimum: empty list
13:03:21 <dcoutts_> Heffalump: for C libs that need configure scripts and tricky makefiles it's a bit harder
13:03:57 <dons> Heffalump: did you see what got some ghc download stats?
13:04:05 <dons> afternoon, TomMD
13:04:10 <TomMD> Good afternoon.
13:04:14 <Heffalump> "what got"?
13:04:17 <chessguy> hiya TomMD
13:04:20 <dons> we got.
13:04:24 <Heffalump> no, where?
13:04:38 <dons> oh, in #ghc. last 4 weeks of logs. 65k windows .exe downloads of ghc, for example
13:04:48 <Heffalump> 65k in 4 weeks??
13:04:51 <dons> sadly, the logs are so ginormous they don't go back father
13:04:52 <Heffalump> lol
13:04:57 <dons> further
13:05:11 <dons> Heffalump: pretty cool, huh? :)
13:05:50 <dons> so i'm thinking popcon is waaay off the actual downloads. it'll be interesting to try to superimpose both sets of stats
13:05:51 <TomMD> 96 downloads an hour?
13:05:54 <dcoutts_> btw, if anyone wants to help with the Cabal FAQ then darcs get http://haskell.org/cabal/
13:06:30 <Heffalump> actually, that doesn't sound plausible
13:06:40 <dons> have to extract unique ips from that
13:06:41 <Heffalump> did you check that they weren't aborted or partial downloads?
13:06:44 <dons> see how many are crawlers
13:06:54 <Heffalump> crawlers surely won't download a large .exe?
13:07:02 <dcoutts_> Heffalump: heh, you say that
13:07:10 <dons>   61621 /ghc/dist/6.10.1/ghc-6.10.1-i386-windows.exe
13:07:19 <Heffalump> that's bytes, right?
13:07:23 <dons> from Feb 22 to Mar 15
13:07:25 <Heffalump> oh, a count
13:07:36 <dcoutts_> Heffalump: there are crawlers getting old builds of ghc 5.03 for alpha/osf
13:07:48 <Heffalump> GET, not just HEAD?
13:07:55 <Igloo> dons: What makes you think popcon is "waaay off"? If you mean Debian's, there are only 80000 people submitting data
13:08:12 <dons> Igloo: oh, "much smaller" :)
13:08:15 <Heffalump> Igloo: any idea out of how many Debian installs?
13:08:26 * Heffalump thinks Igloo should rewrite his popcon graphs in Haskell :-)
13:08:29 <Igloo> Heffalump: What do you mean?
13:08:47 <dons> dcoutts_: those logs are for a 3 week period
13:08:47 <Heffalump> Igloo: 80000 is some subset of the total Debian installs. Any idea how small a subset?
13:09:02 <Igloo> None at all
13:09:03 <dons> 22 feb -> mar 15 is 21 days
13:09:19 <dcoutts_> dons: no, the first log file ends on feb 22, not starts
13:09:23 <michaelcdever> is there a 6.10 package for ubuntu, and will gtk2hs0.10 build with it???
13:09:30 <dcoutts_> Heffalump:
13:09:30 <dcoutts_>   97686	GET
13:09:30 <dcoutts_>   28052	HEAD
13:09:30 <dcoutts_>       1	POST
13:09:36 <dons> dcoutts_: oh yes.
13:09:41 <Heffalump> someone tried to POST to ghc? :-)
13:10:00 <dcoutts_> [14/Mar/2009:18:38:18 -0400] POST /ghc/dist/6.8.2/ghc-6.8.2-src.tar.bz2 HTTP/1.1
13:10:03 <dcoutts_> craizy
13:10:12 <dons> hehe
13:10:16 <Igloo> dcoutts_: Do you know what the user agent was?
13:10:24 <TomMD> Backdoored ghc-6.8.2
13:11:07 <Igloo> And the referer?
13:11:28 <dons> 1812 ghc.exe downloads a day
13:11:41 <hallongrottan> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
13:11:41 <hallongrottan> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
13:11:43 <hallongrottan> say what?
13:11:44 <dons> haha
13:11:59 <dons> you have to send dcoutts $1 internet dollar now, hallongrottan
13:12:01 <dcoutts_> hallongrottan: a lemme just upload the Cabal FAQ :-)
13:12:12 <hallongrottan> okay :)
13:13:27 <jedai> Can you use Glade with Haskell ? Is it really easier than hand coding the GUI ?
13:13:35 <dons> Heffalump: do you know if jdh has ever speculated on say, ghc user base, or hackage users? other than "10s of users"
13:13:45 <dcoutts_> Igloo: "Entropy/0.24.6 (compatible; Entropy; ghc-6.8.2-src.tar.bz2: Linux i686 2.6.27-sabayon)"
13:14:00 <Heffalump> dons: not sure
13:14:01 <Igloo> dcoutts_: Any referer?
13:14:03 <dons> mmm. distro support for happs roxors.
13:14:34 <dcoutts_> hallongrottan: http://haskell.org/cabal/FAQ.html  I'd appreciate any feedback on the organisation or layout or whatever about that new FAQ page.
13:15:00 <hallongrottan> dcoutts_: thanks, I'll look at it
13:15:01 <dcoutts_> Igloo: is that the proceeding "-" ?
13:15:16 <dcoutts_> proceeding/preceding
13:15:44 <Igloo> In access.log.1, from 6194 lines containing ghc-6.10.1-i386-windows.exe, 1044 were from a single IP (which looks up as something inside bris.ac.uk)
13:15:55 <dons> ooh
13:16:08 <dons> a build bot?
13:16:17 <Igloo> Then there are a few IPs with 200+ lines, and about 10 with 100+
13:16:26 <Igloo> Buildbots shouldn't be downloading the .exe...
13:16:48 <dons> a bank with 1044 haskell users? :)
13:16:50 <Igloo> 931 unique IPs downloaded it, but some of those may be proxies
13:16:57 <Heffalump> dons: in bris.ac.uk?
13:17:09 <dons> ah, bristol
13:17:16 <Heffalump> .ac.uk = a uni
13:17:20 <Heffalump> or similar
13:17:25 <dcoutts_> they certainly don't have that many CS students
13:17:31 <Igloo> dcoutts_: It's the other URL. I don't remember where exactly it goes
13:18:08 <dcoutts_> Igloo: there's only one url the only other string entry is user agent and "-"
13:18:18 <Igloo> Those 1044 "users" all downloaded it within a 30min timeframe, too  :-)
13:18:37 <hallongrottan> dcoutts_: I don't really understand the proposed solution for the dependency stuff
13:18:40 <Igloo> dcoutts_: OK, so no referer
13:18:41 <Heffalump> and did they actually get the whole file each time?
13:18:46 * dons is surprised to see 16 votes for haskell-transformers
13:19:06 <dons> ah, yi needs it.
13:19:54 <Heffalump> dons: URL?
13:20:05 <Heffalump> I can't spot it on the reddit page if that's what you're referring to
13:20:21 <Igloo> Does "206 25198656" mean 25198656 bytes of partial content?
13:20:33 <Igloo> Or is that the start offset requested?
13:20:36 <dons> Heffalump: ? oh votes?
13:20:43 <dons> i mean: http://aur.archlinux.org/packages.php?ID=23088
13:20:49 <Heffalump> oh, right.
13:20:57 <Igloo> Anyway, they're all "206 <random number>"
13:22:41 * dons wonders what the complete xmonad download stats will look like...
13:22:47 <dons> since it has always been hosted on hackage
13:22:52 <dons> so we have the full logs for the 2 years
13:24:03 <edwardk> dons is becoming a visualization junkie
13:24:11 <dons> i have to admit it
13:24:22 <dons> need to team up with jeff heard and write some cool libs
13:24:31 * ddarius likes dons' overloaded graphs.
13:24:33 <ImInYourMonad> what i dont get with turing-completeness. you can compute every computable function. ok but how do I extend brainfuck? can i really write a parser for c in brainfuck? i guess i could in theory?
13:24:33 <chessguy> @type \p -> foldr (\x y -> if (p x) then y else (x:y)) []
13:24:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:24:37 <ispiked> is there an equivalent to javascript's toFixed() function in haskell?
13:25:00 <chessguy> ImInYourMonad:  in theory
13:25:02 <dons> ispiked: what's its type?
13:25:09 <ispiked> dons: Double
13:25:17 * edwardk needs to introduce dons to the idea of a poincare projection of hyperbolic half-plane. it makes walking enormous trees a lot easier and would make those big black spots in your graphs go away.
13:25:46 <chessguy> edwardk:  how does it make walking the tree easier
13:25:52 <dcoutts_> hallongrottan: I've added a bit more detail to the solution, take a look, is that better, is that enough for you to get it working? could it be clearer still?
13:26:35 <edwardk> chessguy you don't have to deal with horrific spatial fanout, and the result is nicely conformal, with enough accuracy you can mouse to any point in the tree and see whats around you smoothly
13:26:41 * Saizan needs a lib to visualize huge dependency graphs keeping the labels readable
13:26:55 <Heffalump> what's happening with the Haskell Platform? Is everything that needs to be done before it's ready listed somewhere (e.g. the trac)?
13:27:04 <hallongrottan> dcoutts_: that was a lot clearer, thanks. I understood it immediately, so it should be clear enough :)
13:27:08 <dons> yeah, i think we just have to come up with the inclusion process now
13:27:11 <chessguy> @hoogle Int -> Double -> Double
13:27:11 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
13:27:11 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
13:27:11 <lambdabot> Control.Parallel par :: a -> b -> b
13:27:21 <Heffalump> that doesn't block v1 though, does it?
13:27:25 <dons> nope
13:27:27 <dcoutts_> Heffalump: the packages to go in the first version are known
13:27:38 <dons> v1 is just hte meta-package starting with extralibs, no?
13:27:46 <ispiked> dons: I'm just printing it, so I think I'll truncate the string after I show it
13:27:47 <dcoutts_> Heffalump: it's the practical issues of building and testing installers
13:28:02 <Heffalump> is IHG going to fund some of the work?
13:28:10 <dcoutts_> Heffalump: that's not yet clear
13:28:43 <edwardk> http://www.sigchi.org/chi96/proceedings/videos/Lamping/hb-video.html is an old write up on the topic but there is a lot more modern work in the area, including some java clientside libs
13:29:01 <chessguy> is there a better way to write this? addEachThat p = foldr (\x y -> if (p x) then y else x:y) []
13:29:23 <Botje> uh
13:29:25 <chessguy> oh good golly, that's just filter
13:29:31 <Botje> that sounds like filter (not . p)
13:29:35 * chessguy sighs
13:29:36 <dcoutts_> Heffalump: to be honest, I think that's not such a high priority for existing industrial users, because they've already got it installed. It's a much bigger issue for us a the community trying to push it to new and casual users.
13:29:43 <Heffalump> fair enough
13:29:55 <Heffalump> so where is the todo list, is it just the trac?
13:30:37 <dcoutts_> Heffalump: hmm, the trac doesn't really have the installer issues in it
13:30:53 <dcoutts_> Heffalump: those tickets are all future wishlist items
13:31:03 <Heffalump> ok, so what are the installer issues?
13:31:27 <dcoutts_> Heffalump: just building them, automating building them and getting them tested. On Windows and OSX.
13:32:00 <dcoutts_> and something for Unix users
13:32:14 <dcoutts_> Heffalump: got some time to help?
13:32:22 <Heffalump> I was just trying to figure out if I can help.
13:32:43 <Heffalump> most of my spare time is in short blocks on the train, though
13:32:44 <hallongrottan> dcoutts_: when rebuilding the packages that were broken, is there a way to register them only system-wide and not to the user-packagelist
13:32:45 <dons> distro packaging is an issue though for IHG
13:32:45 <sundaymorning> isn't haskell on macports?
13:32:51 <dons> if you need to ship apps
13:32:57 <dcoutts_> Heffalump: for unix what we want to do is prepare a tarball containing all the other packages, then we bootstrap it by building cabal-install and using that to install all the other packages.
13:33:07 <dons> cabal create --windows --mac --rpm --dep
13:33:17 <gio123> is here a elan user?
13:33:26 <dcoutts_> hallongrottan: yes, though there's no particular advantage to doing that.
13:33:42 <Heffalump> is the haskell-platform metapackage on hackage yet?
13:33:52 <hallongrottan> dcoutts_: but if i unregister a package, and then rebuilds the dependent package, what is the point?
13:33:56 <dcoutts_> Heffalump: no, darcs get http://code.haksell.org/haskell-platform/
13:34:02 <Heffalump> could it go on hackage?
13:34:04 <chessguy> ok
13:34:10 <hallongrottan> then the unregistered package appears in the user package list again
13:34:12 <dcoutts_> Heffalump: when it's the final list yes.
13:34:14 <chessguy> so this is what i'm really trying to write more clearly:
13:34:16 <chessguy> mapmax [] = []
13:34:16 <chessguy>           mapmax (xs:xss) = maximum xs : omit (maximum xs) xss
13:34:23 <hallongrottan> I'm not sure i have understood this correctly
13:34:23 <dons> so, we appear to have 45k source users of xmonad.
13:34:40 <dons> which sounds good, i think, for a linux binary app packaged in all the distros
13:34:41 <Heffalump> dons: is that 45k downloads, or what?
13:34:46 <dcoutts_> hallongrottan: the point is, you no longer have process-1.0.1.0 installed per-user. Rebuilding other packages will use the global one.
13:34:49 <Heffalump> xmonad is in Debian?
13:34:51 <dons> 45k downloads of xmonad source from hackage
13:34:52 <dons> yep
13:34:57 <hallongrottan> dcoutts_: aha, I see
13:35:02 <dons> it's been in the distros for almost its entire life
13:35:04 <Heffalump> dons: that doesn't mean 45k source users
13:35:07 <dons> no.
13:35:12 <dons> 45k downloads of the source alone
13:35:19 <Heffalump> dcoutts_: how hard is fixing the cabal problem with dependencies on applications? That would make the automation job easier.
13:35:29 <Heffalump> dons: I mean that some of those will be duplicates, e.g. of 0.7, 0.8
13:35:29 <dcoutts_> Heffalump: I'm a bit nervous of releasing the meta-package on hackage before we release it generally.
13:35:37 <dons> Heffalump: oh, yes.
13:35:50 <dcoutts_> Heffalump: you mean that it doesn't pull in build-tools like alex, happy?
13:35:55 <pjb3> Hello
13:35:59 <Heffalump> (which is what is also nonsensical about jdh's crap - the more releases something has, the more downloads it will have)
13:36:03 <Heffalump> dcoutts_: right
13:36:26 <Heffalump> dcoutts_: since cabal-install is a tool in itself, it would have to be special cased in a big-tarball-building-script if this isn't fixed first.
13:36:27 <pjb3> In learn you a haskell, they have an example of using a fold to implement a function that searches a list for a sublist
13:36:34 <pjb3> the meat of it is
13:36:39 <pjb3> foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)
13:36:59 <pjb3> needle is what you are looking for, haystack is the whole list
13:37:04 <dcoutts_> Heffalump: it's a bit tricky, probably a couple weeks to generalise the resolver properly to handle multiple kinds of dependencies (C libs, OS, compiler, language extensions, programs etc)
13:37:12 <pjb3> nlen is the length of the needle
13:37:16 <Heffalump> another question: has anyone automated making bamse installers out of hackage packages?
13:37:26 <Heffalump> dcoutts_: ah, ouch.
13:37:28 <pjb3> So my question is that isn't this an inefficient way to do a search?
13:37:33 <dcoutts_> Heffalump: the reason to special-case it is to use it to install the other things
13:37:47 <pjb3> If you have a large list, even after this function finds a match
13:37:49 <dcoutts_> Heffalump: never heard of bamse
13:37:54 <pjb3> it will continue to process the whole list
13:38:02 <Heffalump> it's sigbjorn's windows installer builder
13:38:10 <tromp> @hoogle readP_to_S
13:38:10 <lambdabot> Text.ParserCombinators.ReadP readP_to_S :: ReadP a -> ReadS a
13:38:40 <dcoutts_> Heffalump: ah, found it
13:38:46 <dons> Heffalump: i don't believe so
13:38:54 <dons> dcoutts_: it's what galois uses
13:38:59 <dons> e.g. for cryptol
13:39:01 <dcoutts_> Heffalump: the hard part is for libs, packaging exes is a good deal easier
13:39:31 <dcoutts_> Heffalump: but perhaps that's the useful case anyway
13:39:56 <dcoutts_> to build fully self-contained installers for deploying Haskell apps
13:40:11 <dcoutts_> ignore the problem of distributing libs to Haskell developers
13:40:45 <jmcarthur> pjb3: it appears to me that this is inefficient, yes
13:41:20 <Heffalump> dcoutts_: the two problems I see are (a) C libs and (b) overlapping deps, i.e. two different installers adding the same lib
13:41:39 <Saizan> ?src isInfixOf
13:41:39 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
13:41:55 <dcoutts_> Heffalump: for self-contained exe programs that's no problem
13:41:58 <Saizan> pjb3: a more efficient version ^^
13:42:09 <Heffalump> dcoutts_: why, would the libs go in different places?
13:42:09 <dcoutts_> Heffalump: we just bundle everything in the one dir, or subdirs
13:42:22 <luite_> is it safe to call malloc/free without extra locking in foreign code called from haskell? I'm doing some experiments with the multithreaded RTS, -N4, calling a function via FFI in parallel, but I get some hard to reproduce segfaults
13:42:29 <Heffalump> actually, I guess you don't even need the libs
13:42:31 <Heffalump> the exe is just there
13:42:50 <cocon> how much space does a no-arg constructor use in memory?
13:42:50 <dcoutts_> Heffalump: yes, even if we move to a model using dlls for haskell libs
13:43:02 <dcoutts_> cocon: 1 word, shared between all values
13:43:09 <dcoutts_> ie nothing at all
13:43:21 <Heffalump> well, and 1 word to point to it
13:43:25 <cocon> cocon: what does shared between all values mean?
13:43:27 <dcoutts_> well, yes
13:43:58 <dcoutts_> cocon: there is only one [] object in the program address space, all [] values point to that one heap object
13:44:10 <cocon> so a 1000-element list on a 32-bit machine takes 8000 bytes?
13:44:27 <dcoutts_> no, more
13:44:34 <dcoutts_> and it depends what it's a list of
13:44:54 <mle> and how far it gets evaluated
13:44:58 <dcoutts_> list of Int would be 20 bytes per element
13:45:10 <dcoutts_> 5 words, 3 for the (:) and 2 for the Int
13:45:26 <cocon> 2 words for an Int??
13:45:45 <mle> Int is boxed.
13:45:51 <dcoutts_> cocon: every heap object has a 1 word overhead
13:45:51 <cocon> oh
13:45:52 <cocon> right
13:46:04 <pjb3> Saizan: that's nice, I'm trying to implement it with pattern matching and recursion
13:46:12 <pjb3> Here's what I've got, but it doesn't compile:
13:46:13 <pjb3> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2744#a2744
13:46:21 <dcoutts_> cocon: which is why it is advantageous sometimes to unbox small types like that into constructors
13:46:22 <pjb3> Occurs check: cannot construct the infinite type: a = [a]
13:46:40 <cocon> dcoutts_: it totally breaks abstraction, no?
13:46:54 <cocon> dcoutts_: or is there an Unboxable type class?
13:46:58 <dcoutts_> cocon: nope
13:47:17 <dcoutts_> cocon: data Foo = Foo {-# UNPACK #-} ! Int
13:47:25 <cocon> can I tell ghc to unbox stuff without modifying my code?
13:47:27 <cocon> oh
13:47:31 <dcoutts_> cocon: portable and does not break the abstraction about Int implementation
13:47:33 <cocon> interesting
13:47:35 <Saizan> pjb3: you meant search' :: Eq a => [a] -> [[a]] -> Bool i guess
13:47:57 <Saizan> pjb3: and search needle list = search' needle (tails list)
13:48:04 <dcoutts_> cocon: any single-constructor type can be unpacked if it's used in a strict field
13:48:05 <cocon> dcoutts_: I have data Foo a = Foo {-# UNPACK #-} ! a
13:48:12 <dcoutts_> cocon: that will not work
13:48:13 <cocon> and then later Foo Int
13:48:16 <dcoutts_> cocon: the type is unknown
13:48:30 <dcoutts_> you have to specialise to be able to unpack
13:48:32 <cocon> can't I say "whenever a is unboxable, go for it"
13:48:43 <cocon> specialize with a pragma?
13:48:46 <dcoutts_> sadly not
13:48:55 <cocon> :(
13:49:05 <pjb3> Saizan: Why [a] -> [[a]]? It's supposed to take a possible sublist and a list, not a list of lists
13:49:05 <cocon> that would make sense though, wouldn't it?
13:49:15 <dcoutts_> cocon: it'd have to be a different type really
13:49:15 <Heffalump> cocon: no, because a polymorphic client needs a uniform representation
13:49:24 <pjb3> so search [1,2] [1..5] would be True
13:49:34 <Heffalump> if you are code that doesn't know what 'a' is, you still need to be able to manipulate a 'Foo a'.
13:49:41 <dcoutts_> cocon: eg newtype Bar = Bar (Foo Int) {-# SPECIALISE #-}
13:50:03 <cocon> Heffalump: I see
13:50:09 <Saizan> pjb3: because you're using the elements of your second parameter as if they were lists, there
13:50:12 <cocon> too bad...
13:50:41 <Saizan> pjb3: did you see how i've defined "search" with "search'"?
13:52:08 <pjb3> Saizan: Ok, now I get it, you have to process through a list of lists, so by doing it recursively, you would have to take a list of lists are the 2nd param
13:52:43 <pjb3> But in the original example, it's not recursive, just uses foldl to process the list of lists
13:53:02 <cocon> dcoutts_, Heffalump: why does unpacking only work for single-constructor types?
13:54:11 <cocon> UNPACK, that is
13:54:30 <Saizan> it works for multiple constructors too
13:54:41 <Heffalump> Saizan: not according to the docs
13:55:19 <cocon> it says "Any single-constructor data is eligible for unpacking"
13:55:19 <Saizan> so my memory is failing about seeing it in Data.Map?
13:55:32 <Heffalump> well, you can use the pragma, but the docs imply it won't work
13:55:32 <Saizan> @source Data.Map
13:55:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
13:56:26 <Saizan> data Map k a  = Tip  | Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
13:56:43 <Saizan> i guess it needs a bug report
13:56:57 <cocon> "If a field cannot be unpacked, you will not get a warning"
13:57:05 <cocon> is the doc broken or is Data.Map broken?
13:57:40 <ddarius> Even if the documentation is correct, Data.Map is not broken.
13:58:05 <cocon> by broken I mean containing an unused pragme
13:58:15 <Saizan> well, it's less efficient than the developer thought
13:58:50 <Saizan> not sure if you can do anything about that..
13:59:05 <cocon> can anyone see a reason why this is only done for single-cons types?
14:04:03 <michaelcdever> hey all, wheres the documentation for the missingh library, google is failing me!
14:05:01 <Saizan> ?hackage MissingH
14:05:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingH
14:05:34 <Saizan> i guess you've to build it with cabal haddock yourself
14:06:22 <michaelcdever> ah ok, cool thanks, i could have sworn i saw haddock for it before
14:09:27 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingH-1.0.0 <- this version has them built
14:10:03 <pjb3> So in reference to my earlier examples about search using foldl being inefficient,
14:10:14 <michaelcdever> cheers Saizan! :D
14:10:28 <Heffalump> the haddock lag on hackage is annoying because I see things in the RSS feed and want to read about them immediately
14:10:30 <pjb3> Learn You A Haskell seems to recommend using fold over recursion as a general rule:
14:10:39 <pjb3> "It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they're easier to read and identify. Everyone knows it's a fold when they see the foldr call, but it takes some more thinking to read explicit recursion."
14:11:11 <Saizan> yeah, but you've to use foldr in that case, not foldl
14:11:14 <pjb3> So I guess the idea is that additional clarity is worth the cost of possible extra processing?
14:11:45 <pjb3> Saizan: doesn't foldr have the same problem?
14:11:48 <SubStack> I would think that the compiler would have an easier time dealing with more explicit functional patterns
14:12:00 <SubStack> since they have other properties which could help with optimization
14:12:06 <Saizan> pjb3: no, because foldr is enough lazy
14:12:13 <SubStack> but pure optimizations are crazy
14:12:19 <pjb3> If you use foldr or foldl to check if something is a list matches a predicate, doesn't it always process the whole list?
14:12:35 <thoughtpolice> foldr can process infinite lists
14:12:56 <Botje> pjb3: depends on the function you pass
14:12:59 <pjb3> Ok, I think that's what I'm not understanding about foldr
14:13:03 <pjb3> In this example:
14:13:04 <pjb3> findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
14:13:12 <Saizan> pjb3: if you define a function recursively with a shape like fun [] = z; fun (x:xs) = f x (fun xs); then you can rewrite it equivalently as foldr f z
14:13:36 <pjb3> It doesn't stop processing the list once it finds the first True?
14:13:38 <pjb3> or does it?
14:13:48 <Saizan> it does stop
14:13:55 <Saizan> since you're not using acc in that case
14:13:56 <ddarius> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey 100 [1..]
14:13:57 <lambdabot>       No instance for (Enum (t, t1))
14:13:57 <lambdabot>        arising from the arithmetic seque...
14:14:11 <Saizan> laziness is giving you the short-circuiting necessary, for free
14:14:23 <ddarius> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey 100 $ map (join (,)) [1..]
14:14:25 <lambdabot>   Just 100
14:14:41 <pjb3> ddarius: wow, so that proves that it is lazy
14:14:57 <pjb3> I just don't understand why
14:15:05 <Saizan> ?src foldr
14:15:06 <lambdabot> foldr f z []     = z
14:15:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:15:45 <Saizan> if 'f' there doesn't use its second argument than the recursive 'call' won't happen
14:15:57 <Saizan> than/then
14:17:28 <chessguy> i like this a lot, but it still seems like there's some duplication here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2745#a2745
14:18:10 <soares> Is there any immutable hash in haskell?
14:18:32 <soares> I just want key-value pairs with O(1) access and no need to mess around with IO
14:18:34 <soares> is that possible?
14:20:56 <Saizan> soares: maybe StableName? using unsafePerformIO though
14:21:32 <byorgey> soares: just use an immutable array.
14:21:50 <byorgey> there are no immutable hash table implementations that I know of, as such.
14:23:20 <soares> byorgey: yeah, I could get away with an unsafePerformIO and hack something up
14:23:27 <jedai> There's no good reason there shouldn't be though
14:23:28 <soares> wanted to see if there was a not-unsafe way, though.
14:23:36 <byorgey> what do you need unsafePerformIO for?
14:23:47 <byorgey> immutable arrays are perfectly safe.
14:24:04 <Saizan> byorgey: i guess his keys are not Ints or similar
14:24:07 <byorgey> and don't involve IO.
14:24:21 <jedai> it would be trivial to hack Data.Hash to get something like that (though it seems Data.Hash is a pretty bad hashtable implementation so...)
14:24:45 <soares> byorgey: I could probably get away without it. It might be easiest to wrap HashTable with UnsafeIO and just not wrap the insert/update/delete functions
14:25:00 <soares> until a better implementation comes around
14:25:32 <rittyan> I am a naive haskell noob... http://pastebin.ca/1367505 <- can you help me to make it to compile? :)
14:26:17 <Zao> rittyan: So what error do you get?
14:26:48 <rittyan> Zao, Couldn't match expected type `IO' against inferred type `[]` / Expected type: IO t / Inferred type: [IO ()] / In the expression: map processFile files
14:27:09 <Zao> mapM / mapM_ ?
14:27:09 <c_wraith> rittyan: Even though it's not required by the language, you're often well-served by explicitly specifying the type of your top-level declarations
14:28:08 <jedai> rittyan: Use mapM_ instead of map
14:28:34 <rittyan> oh wow, it compiled
14:28:40 <Zao> @src mapM
14:28:41 <lambdabot> mapM f as = sequence (map f as)
14:28:49 <rittyan> thanks! (now will proceed with reading about mapM)
14:28:55 <Saizan> rittyan: map processFile files produces a list of IO actions, while you want a single action that it's the sequence of those
14:29:05 <jedai> Though you seriously could make it prettier by reducing the IO portion
14:29:59 <rittyan> maybe
14:30:14 <rittyan> I am trying to convert my python stuff into haskell
14:30:28 <Zao> Haskell code doesn't tend to be pythonic.
14:30:40 <jedai> like so : processFile f = readFile f >>= mapM putStrLn . filter (=~ "GET") . lines
14:30:49 <jedai> or something like that
14:31:06 <rittyan> wow :O
14:31:15 <rittyan> I couldn't write it myself but I could read it w/o any problems
14:33:48 <gwern> Unfortunately Neo, no one can be *told* what the Monad is.
14:34:52 <rittyan> yes I already know about it
14:35:06 <Gracenotes> heh
14:35:14 <Gracenotes> @remember gwern Unfortunately Neo, no one can be *told* what the Monad is.
14:35:15 <lambdabot> Done.
14:35:25 <c_wraith> The problem is that knowing what a monad is doesn't really help. :)
14:35:43 <rittyan> my coworker who is a haskell-lover told me that I should not try to understand monads, but rather learn how to use them, and that will be enough
14:35:48 <rittyan> c_wraith, yes!
14:35:53 <rittyan> that is what I have been told
14:35:57 <gwern> rittyan: that strategy has worked well enough for me so far
14:36:25 <c_wraith> I have some functional understanding of how to use them.  I'll get back to category theory when it's a bit more functional. :)
14:36:27 * gwern figures one day enough will have sunk in by osmosis I'll wake up knowing monads
14:36:42 <Badger> Haskell = water?
14:36:53 <Gracenotes> of eternal youth
14:37:04 <gwern> one is a universal solvent, t'other a universal language
14:38:18 <mle> just don't drink it or you'll be a tree.
14:43:39 <singintime> damn, I hate xml!!!
14:43:52 <singintime> and overall I hate xml parsers!
14:44:03 <sundaymorning> why?
14:44:18 <singintime> because I can't get them to work!
14:44:31 <singintime> tried pxp on ocaml
14:44:37 <singintime> haxml and hxt on haskell
14:45:08 <singintime> and still I have problems
14:45:28 <singintime> actually, I have problems with functional programming
14:45:38 <singintime> :)
14:45:52 <singintime> but that's a secondary issue :)
14:46:19 <byorgey> yeah, xml sucks.
14:46:25 <singintime> yeah
14:46:38 <singintime> I wonder why I gave my thesis on it...
14:47:36 * Gracenotes imagines a world where we used sexprs instead of XML
14:48:06 <Gracenotes> hm.. can't say I like that thought either :\
14:48:10 <vixey> it's all the same except SXML is slightly smarller and easier to deal with ...
14:50:03 <singintime> maybe I'll just give up and parse this f***in document without validating it
14:50:50 <singintime> hoping that its generator did a good job
14:50:56 <rittyan> how to write 'filter (=~ "GET" :: Bool) . list_of_string'? Compiler complains about :: Bool part
14:51:28 <FunctorSalad> should be String -> Bool
14:52:20 <c_wraith> you don't need the :: Bool part
14:52:32 <c_wraith> the first argument to filter is always of type a -> Bool
14:52:42 <c_wraith> The compiler will automatically derive it
14:52:46 <Gracenotes> > filter (=~ "GET") ["GET", "POST", "BEGET"]
14:52:47 <rittyan> oh, hm
14:52:48 <lambdabot>   ["GET","BEGET"]
14:53:07 <FunctorSalad> GET
14:53:13 <Gracenotes> IT?
14:54:24 * Badger wonders what @ does.
14:54:50 <ImInYourMonad> you did a thesis on xml?
14:54:58 <Botje> I'm doing a thesis _IN_ xml
14:55:05 <Botje> (docbook, that is)
14:55:17 <FunctorSalad> > let p@(x,y) = (1,2) in [p,x,y]
14:55:18 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t1)
14:55:18 <lambdabot>        Ex...
14:55:21 <FunctorSalad> meh
14:55:25 <FunctorSalad> > let p@(x,y) = (1,2) in (p,x,y)
14:55:26 <lambdabot>   ((1,2),1,2)
14:55:32 <sbahra> Botje, why?
14:55:33 <FunctorSalad> @Botje
14:55:34 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
14:55:39 <c_wraith> :t (=~ "GET")
14:55:41 <lambdabot> forall source1 target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target) => source1 -> target
14:55:42 <sbahra> Botje, why not LaTeX?
14:55:56 <Botje> I hate latex with a burning passion
14:55:59 <Botje> because it hates me.
14:56:26 <sbahra> Botje, ok.
14:56:40 <singintime> ImInYouMonad: not exactly
14:56:43 <Zao> LaTeX with TikZ is awesome for spending time on drawing shiny figures instead of writing boring text :P
14:57:04 <singintime> but it was a work on a format based on xml
14:57:58 <singintime> it's a musical information description format
14:58:04 <Badger> oh thanks FunctorSalad
14:58:12 <singintime> in some way similar to MusicXML
14:58:21 <singintime> but much cooler :)
14:59:36 * SubStack tosses FunctorSalad 
15:04:29 <luite_> allocGroup: free list corrupted (GHC version 6.10.1.20090314 for x86_64_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
15:04:35 <luite_> hm, this is not good, right? ;)
15:04:52 <luite_> is something like this known for 6.10.2-rc1
15:05:48 <Heffalump> that's definitely not good
15:05:50 <tromp> @src readFile
15:05:51 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
15:05:52 <Heffalump> check the GHC trac
15:06:12 <tromp> @src openFile
15:06:12 <lambdabot> Source not found. :(
15:06:25 <tromp> can openFile open stdinput?
15:06:45 <rittyan> I have a question about regexes... I am using Text.Regex.Posix, is there a way to specify 'i' or 'x' options to regexes?
15:06:46 <FunctorSalad> you can hGetContents on stdin
15:06:54 <FunctorSalad> @type stdin
15:06:55 <lambdabot> Not in scope: `stdin'
15:07:02 <FunctorSalad> meh
15:07:15 <tromp> but there's no convention for readFile that - means stdin?
15:07:22 <FunctorSalad> don't know :)
15:07:29 * singintime plays a bit with his new jyo
15:08:00 <FunctorSalad> :o
15:08:37 <luite_> hm, I don't see an open ticket about this
15:09:30 <Heffalump> how big is the program that produces it?
15:09:37 <dancor> tromp: if there were, how would you read a file called '-'
15:09:56 <tromp> good point:)
15:10:16 <luite_> the problem is that I find it extremely hard to reproduce, it only happens when using the threaded runtime, the program is probably 1000 lines of haskell, about 100 lines of C, called through FFI, and my program crashed after about 2 hours of computation
15:10:18 <dancor> it could like take Maybe FilePath instead
15:11:05 <Heffalump> ah :-(
15:11:30 <Heffalump> can you provoke it quicker with more OS threads (e.g. +RTS -N8 -RTS)?
15:11:34 <Vq^> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
15:11:34 <Vq^> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
15:11:41 <Vq^> that was fun
15:11:56 <dcoutts> Vq^: http://haskell.org/cabal/FAQ.html#dependencies-conflict
15:11:58 <luite_> Heffalump: hm, I'll try, I used -N4
15:12:03 <dancor> conflict-ed
15:12:45 <luite_> I just ran memtest86+ for half an hour, to make sure that it isn't my hardware
15:12:56 <luite_> before this, the program just segfaulted
15:13:23 <tromp> is there a way to associate a filename with stdin?
15:13:57 <tromp> this program expects a filename but i want to use it with stdin
15:14:03 <Vq^> dcoutts: thanks, it got a lot less cryptic now
15:14:35 <tromp> i guess /dev/stdin will work
15:15:05 <dcoutts> Vq^: great, I'm glad I finally made a FAQ :-)
15:16:23 <FunctorSalad> dancor: "./-" ? ;)
15:17:51 <ImInYourMonad> how do i get type of something in emacs in a buffer not in ghci?
15:19:01 <luite_> Heffalump: I do get some errors from the garbage collector, branches depending on uninitialized values
15:19:07 <FunctorSalad> ImInYourMonad: C-t C-i
15:19:11 <rittyan> is 'filter' lazy?
15:19:13 <luite_> but I think that's not the problem
15:19:39 <FunctorSalad> ImInYourMonad: err nvm I'm crazy
15:19:47 <tromp> ues, rittyan
15:19:51 <tromp> yes
15:20:47 <FunctorSalad> ImInYourMonad: M-x where-is RET inferior-haskell-type RET
15:21:06 <FunctorSalad> will print whatever key it is bound to on your system...
15:21:53 <FunctorSalad> (/me put it on  comma t... saving my poor wrists)
15:22:55 <Heffalump> luite_: I've never heard of those kinds of errors before, do you mean that you are using valgrind or something?
15:23:29 <ImInYourMonad> what does the incompleteness theorem mean for physical theories like Max Shapiro who believes the universe is enitrely mathematical(http://space.mit.edu/home/tegmark/).
15:23:31 <luite_> Heffalump: oh, sorry, forgot to mention valgrind
15:24:00 <Heffalump> does valgrind report errors from trivial executables too?
15:24:14 <FunctorSalad> ImInYourMonad: http://www.sm.luth.se/~torkel/eget/godel.html
15:24:22 <FunctorSalad> sorry could not resist ;)
15:25:48 <luite_> internal error: freeGroup: block size is zero (GHC version 6.10.1.20090314 for x86_64_unknown_linux) Please report this as a GHC bug
15:26:02 <luite_> got a new one :)
15:26:33 <ImInYourMonad> can a haskelllambda take 0 args?
15:27:03 <rittyan> http://pastebin.ca/1367559 <- that function in the end of paste, will it break 'filter' after getting its first elem? or filter will process everything and only then `take` will do something?
15:27:11 <goomba``> you are going to break the universe ImInYourMonad
15:27:27 <Heffalump> luite_: I guess all you can do is try to make this as easy to repro as possible and report it.
15:28:04 <luite_> Heffalump: busy doing just that. I can now reproduce it when I skip all the FFI code, except 4 malloc/free's
15:28:20 <ImInYourMonad> FunctorSalad: haha, thanks. im not trolling though im just trying to understnad what it really means
15:28:40 <Heffalump> also, check over the FFI spec in case you're mismanaging memory
15:28:49 <Heffalump> or doing something else dodgy in that regard
15:28:53 <iago> ImInYourMonad, what is the sense of a \-abstraction without arguments?
15:30:23 <FunctorSalad> ImInYourMonad: I don't think you're trolling, I just find that page kinda cute ;)
15:31:56 <seliopou> :t fromMaybe
15:31:57 <lambdabot> forall a. a -> Maybe a -> a
15:32:09 <momon> h
15:32:27 <bremner> > fromMaybe Nothing
15:32:28 <lambdabot>       Overlapping instances for Show (Maybe (Maybe a) -> Maybe a)
15:32:28 <lambdabot>        aris...
15:33:03 <bremner> > (fromMaybe Nothing) :: Int
15:33:04 <lambdabot>   Couldn't match expected type `Int'
15:34:37 <jedai> bremner: fromMaybe takes a default in case of Nothing
15:34:54 <jedai> > fromMaybe 0 Nothing
15:34:56 <lambdabot>   0
15:34:59 <bremner> jedai: thanks
15:35:05 <jedai> > fromMaybe 0 (Just 5)
15:35:06 <lambdabot>   5
15:35:40 <eyeris> Is there any way to fix this beyond upgrading GHC?
15:35:43 <eyeris> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2746#a2746
15:35:51 <bremner> jedai: Indeed, I read the type wrong
15:36:26 <roconnor> people in Cafe talk like transformers is compatable with mtl, but the mtl has a broken StateT Cont
15:39:03 <jedai> rittyan: It will work incorrectly since length need to see the whole list before returning anything
15:39:47 <rittyan> jedai, but there is a take
15:39:58 <jedai> rittyan: To get something that stops at the first match, you should have used "not . null" instead of "length ... > 0"
15:40:21 <jedai> rittyan: Oh right, the take will stop the filter after the first match
15:40:41 <rittyan> jedai, but you have a nicer idea than length+take combined, right? :)
15:40:49 <jedai> rittyan: it will work but it's pretty horrible, really the right function to use here is any
15:40:53 <jedai> @type any
15:40:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
15:41:12 <jedai> any (\re -> line =~ re) patterns
15:41:24 <jedai> will replace the whole thing
15:42:02 <rittyan> jedai, thank you
15:42:29 <jedai> rittyan: length + take + filter will work though, well spotted :)
15:43:21 <rittyan> jedai, but that's more... through-ass solution (pardon mon francais) I suppose
15:43:42 <jedai> matchesPattern line = any (\re -> line =~ re) patterns
15:44:05 <osfameron> @pl \re -> line =~ re
15:44:05 <lambdabot> (line 1, column 13):
15:44:05 <lambdabot> unexpected "="
15:44:05 <lambdabot> expecting variable, "(", operator or end of input
15:45:54 <jedai> matchesPattern line = any (line =~) patterns
15:46:42 * rittyan struggles with pcre-light :(
15:58:29 <temoto> @hoogle [Char] -> ByteString
15:58:29 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
15:58:29 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
15:58:29 <lambdabot> Prelude read :: Read a => String -> a
15:59:03 <temoto> rittyan: see
15:59:33 <temoto> i used second and it worked
16:06:41 <abbe> hi everyone
16:06:53 <byorgey> hi abbe
16:06:59 <abbe> i'm having a problem understanding state monads declared using newtype
16:07:04 <abbe> hi byorgey
16:07:19 <abbe> or simply newtype declarations.
16:08:36 <abbe> e.g. newtype T1 = T1 { t2 :: String } . Creates a function t2 :: T1 -> String. And (T1 "abbe") returns a value of type T1
16:09:02 <abbe> now if execute: t2 (T1 "abbe")  -- i get "abbe"
16:09:29 <abbe> so i'm wondering what is the significance of t2, there is no implementation of t2
16:09:55 <RayKiD> hi all, i have a very basic problem with haskell. For a hello world app i need to enter the following in the ghci prelude:   H:e:l:l:o:[]   but then it tells me:    :1:0: lexical error at character '\8217'  can anyone help me what i have to type instead?
16:09:55 <byorgey> abbe: t2 just lets you remove the T1 constructor.
16:10:09 <byorgey> abbe: I'm not sure what you mean by 'there is no implementation of t2'?
16:10:16 <byorgey> t2 is sort of magically generated for you.
16:10:19 <abbe> okay, i thought t2 is a function
16:10:25 <byorgey> it is a function.
16:10:43 <pejo> RayKid, why not "Hello"?
16:11:03 <byorgey> RayKiD: you are using weird Unicode single quotes
16:11:13 <idnar> RayKiD: you would need to type 'H':'e':'l':'l':'o':[], but "Hello" is a lot shorter
16:11:24 <RayKiD> pejo because it is a tutorial about Lists and it says i can include Hello in the list
16:11:43 <idnar> RayKiD: note that "Hello" and 'H':'e':'l':'l':'o':[] are exactly the same thing
16:12:07 <idnar> assuming (:) hasn't been redefined
16:12:08 <byorgey> RayKiD: ah, did you copy and paste that from the tutorial?  maybe that's why you got weird Unicode single quotes  instead of normal ones '
16:12:36 <abbe> byorgey, so in monads such magic functions are used to evaluate computation wrapped in a monad, right ?
16:12:40 <RayKiD> byorgey, yes i did. Thanks all for the answers
16:13:31 <byorgey> abbe: but most monads are not newtypes.
16:13:44 <jedai> abbe: They're used to extract the value inside the newtype, sometimes that just happen to coincide with the "run" function for the corresponding monad
16:14:07 <abbe> okay jedai and byorgey
16:14:24 <byorgey> abbe: when you create a data type using record syntax,  data Foo = Bar { a :: X, b :: Y, c :: Z },  you automatically get functions a, b, and c
16:14:29 <jedai> Their implementation doesn't have anything magical though
16:14:36 <byorgey> these functions extract the fields from something of type Foo.
16:14:53 <byorgey> you could write them yourself though:  a (Bar x y z) = x, and so on
16:15:09 <byorgey> so maybe 'magic' was too strong of a word =)
16:16:03 <abbe> and what about this '()' ?
16:16:09 <abbe> is that an empty tuple ?
16:16:14 <abbe> or what ?
16:16:23 <byorgey> abbe: yes.  it is called 'unit'.
16:16:32 <byorgey> the type () has only one value, which is also called ()
16:17:06 <abbe> okay, and what is its purpose ?
16:17:06 <byorgey> so having a value of type () is really like having nothing at all, since it conveys no information.
16:17:10 <jedai> byorgey: I wasn't using "magic" in response to your description, it's just that sometimes when the field function just happen to correspond to the "run" function of  monad beginners thinks that their implementation must be somehow complicated
16:17:44 <byorgey> jedai: I was referring to my own description, I was the one who used the word 'magic' first =)
16:18:08 <byorgey> jedai: I agree though.
16:18:24 <jedai> abbe: Generally it isn't too useful... But you'll often see value of type "IO ()" since some IO actions are only useful for their side-effect and not for anything they may return
16:19:14 <byorgey> it's useful for any "effectful" monad (like State, Writer, IO), for making monadic computations that only have an effect and don't return a value.
16:19:33 <byorgey> abbe: if you know C, you can think of () sort of like 'void'
16:20:22 <abbe> okay, initially I thought () are supposed to mean actions or some kind of function pointers.
16:20:28 <abbe> thanks jedai and byorgey :-)
16:20:34 <byorgey> sure =)
16:20:44 <jedai> you're welcome ^^
16:26:34 <marcot> > [-1.0, 0.1 .. 1.0]
16:26:36 <lambdabot>   [-1.0,0.10000000000000009,1.2000000000000002]
16:26:37 <luite_> hm, even when I return directly in my ffi code, the problem occurs
16:27:22 <marcot> Bug in GHC?
16:27:56 <luite_> don't know, I do use uvector a lot in this program, which is unchecked, I think, that might cause some problems
16:27:57 <jedai> marcot: Not really, just messed up semantics for the floats
16:28:09 <luite_> oh, sorry, you were referring to something else
16:28:41 <jedai> marcot: Just don't use the Enum instance for Float or Double
16:28:45 <BMeph> marcot: Technically, you could say it's a "bug" in Haskell. ;p
16:28:56 <sundaymorning> > [-4,1 .. 4]
16:28:57 <lambdabot>   [-4,1]
16:28:58 <jedai> (that means not the .. syntax either)
16:29:02 <temoto> How to install PCRE.Light on ubuntu?
16:29:08 <sundaymorning> shouldn't use it for integers either
16:29:27 <jedai> sundaymorning: No integers are perfectly fine
16:29:27 <marcot> BMeph: is this a bug in the language definition?
16:29:52 <BMeph> marcot: I'm not absolutely sure, but I think it is, yes.
16:29:52 <sundaymorning> > [0,1 .. 4]
16:29:54 <lambdabot>   [0,1,2,3,4]
16:29:58 <glguy> class Funktor m where funk :: (x -> y) -> (m a a x -> m a a y)
16:29:58 <sundaymorning> looks funny to me
16:30:07 <Gracenotes> *funky
16:30:24 <Gracenotes> well, Funktor x.x
16:30:28 <sundaymorning> why does it work for >0 but not for <0?
16:30:33 <jedai> sundaymorning: Why ? It's an arithmetic sequence with a step of 1 from 0 to 4 included
16:30:47 <Gracenotes> > [-4,-3..4]
16:30:49 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4]
16:30:50 <jedai> Because 1 - (-4) = 5
16:30:51 <sundaymorning> > [-4,1..4]
16:30:53 <lambdabot>   [-4,1]
16:30:57 <jedai> and 1 + 5 = 6 > 4
16:31:06 <sundaymorning> oh
16:31:06 <sundaymorning> I see
16:31:24 <sundaymorning> I was thinking of it wrong
16:31:45 <jedai> marcot: Technically you can't have a "bug" in the language description... You can have something you dislike though
16:31:47 <BMeph> sundaymorning: [-4,1..4] does not mean "count from -4 to 4 by 1", but "count from -4 to 4, but the difference between -4 and 1". :)
16:31:56 <sundaymorning> yeah, I see
16:32:01 <dolio> glguy: m a b x -> m a b y?
16:32:01 <jedai> > [-4..4]
16:32:03 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4]
16:32:04 <BMeph> *by the diff....
16:32:21 <glguy> dolio, yup
16:32:23 <marcot> jedai: ok, but where in the definition is this problem?
16:32:25 <glguy> dolio, I was careless :(
16:32:27 <jedai> @src Float enumFromThenTo
16:32:27 <lambdabot> Source not found. My mind is going. I can feel it.
16:32:41 <jedai> @src Float enumFromThen
16:32:42 <lambdabot> Source not found. :(
16:32:53 <jedai> @src Int enumFromThen
16:32:53 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:32:56 <jedai> @src Int enumFrom
16:32:57 <lambdabot> Source not found. Sorry.
16:33:17 <tromp> :t showIntAtBase
16:33:18 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:33:26 <tromp> showHex 414
16:33:33 <tromp> > showHex 414 ""
16:33:34 <lambdabot>   "19e"
16:33:48 <sundaymorning> I could map - in a [0.0,0.1 .. 1.0] list to work around that problem
16:33:55 <jedai> marcot: I think the Enum instance for the floating point types is specified so that the latest point in the sequence must be less than end + 0.5
16:34:00 <jedai> or something like that
16:34:00 <sundaymorning> how do I specify the unary op - and not the binary one, though?
16:34:13 <glguy> negate
16:34:41 <luite_> could accessing an invalid index of an immutable uvector (which I believe is not range checked) corrupt the heap in some way?
16:35:08 <glguy> edwardk, you about?
16:35:12 <jedai> > takeWhile (<= 1.0) . iterate (+ 1.1) $ (-1.0)
16:35:14 <lambdabot>   [-1.0,0.10000000000000009]
16:35:19 <Gracenotes> > (-2) :: Natural
16:35:20 <jedai> Works too
16:35:20 <lambdabot>   * Exception: Natural: (-)
16:35:34 <Gracenotes> > negate 2 :: Natural
16:35:36 <lambdabot>   * Exception: Natural: (-)
16:36:02 <edwardk> glguy: yeah
16:36:35 <Gracenotes> so, in useless-use-of-applicative news...
16:36:38 <Gracenotes> > fix $ (0:) . (1:) . (=<< [1..10]) . ((<*>) . ((return .) . (+) <$>) <*> (. subtract 1)) . (!!)
16:36:39 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
16:36:47 <Gracenotes> > fix $ (0:) . (1:) . (=<< [1..]) . ((<*>) . ((return .) . (+) <$>) <*> (. subtract 1)) . (!!)
16:36:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:36:57 <glguy> edwardk, is there anything like this in category-extras or similar?http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2747#a2747
16:37:29 <marcot> jedai: very strang specification... why 0.5?
16:37:49 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Indexed.html
16:37:50 <jedai> marcot: There's a method in the madness though, since floating point means that you could always be surprised even if the test was strict (a lot of addition from small amount easily mess up with some boundaries)
16:37:51 <Gracenotes> anyone else have a more obfuscated fib..? .-.
16:38:04 <edwardk> and Control.Monad.Indexed
16:38:05 <marcot> jedai: makes sense..
16:38:19 <glguy> edwardk, thanks
16:38:32 <jedai> marcot: I'm not sure if it is actually 0.5, the point is that using this kind of sequence with floating points nums is a bad idea in the first place
16:38:45 <marcot> jedai: good to know, thanks.
16:39:14 <edwardk> glguy: no problem, it was one of the two notions of parameterized monad i threw in, since it was originally referred to as an indexed monad by someone i kept that terminology
16:39:45 <glguy> edwardk, I've heard the same terminology, so I'm not having any trouble accepting your use :)
16:40:23 <edwardk> there are indexed Cont and State monads in there. i should add the Indexed Writer over any Category as well
16:40:47 <wli> What's an indexed monad?
16:42:39 <edwardk> wli: think of a state monad that can change the type of the state as it goes through. return leaves it unchanged, but a monadic action could bind (a -> m j k b) into (m i j a -> m i k b)
16:42:53 <edwardk> so return : a -> m i i a
16:43:54 <dcoutts> dons, Igloo: http://blog.well-typed.com/2009/03/regression-testing-with-hackage/
16:43:57 <dcoutts> @seen waern
16:43:57 <lambdabot> I saw waern leaving #yi, #ghc and #haskell 2h 22m 41s ago, and .
16:44:10 <luite_> Heffalump: I can now fairly reliably reproduce the problem in about a minute, without any FFI code or related memory management.
16:44:10 <edwardk> wli: you can also build up delimited continuations out of them.
16:44:17 <dcoutts> @tell waern http://blog.well-typed.com/2009/03/regression-testing-with-hackage/
16:44:18 <lambdabot> Consider it noted.
16:44:22 <luite_> got a new error btw: internal error: scavenge: unimplemented/strange closure type 2140330078 @ 0x7f92a0c2f030GraphCol: internal error: scavenge: unimplemented/strange closure type 2140330078 @ 0x7f92a0c2f030 (GHC version 6.10.1.20090314 for x86_64_unknown_linux)
16:44:24 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-Cont.html
16:44:26 <luite_> :)
16:44:39 <wli> edwardk: Sounds useful.
16:44:50 <dcoutts> Heffalump: oh and you were talking about this earlier too, ^^
16:45:26 <jre21> is there a good parser library for indentation-sensitive code?
16:45:31 <Igloo> dcoutts: Great
16:45:42 <edwardk> wli: and if you view category as a generalized monoid, you can generalize writer as well, but the typeclass constraint can't be expressed in terms of the same typeclass as the other two iirc
16:46:14 <edwardk> oh wait it can
16:46:16 <edwardk> neat i'll ad it
16:46:17 <edwardk> er add
16:47:15 <dolio> Oh, Category c => Writer c a b x?
16:47:22 <BMeph> edwardk: So, what's the generalized version of a semi-group? Or is a semi-group the generalized version? :)
16:47:36 <dolio> Neat.
16:47:59 <edwardk> bmeph: it would be a category without the identity arrows
16:48:17 <BMeph> edwardk: Is that legal? :)
16:48:18 <edwardk> bmeph: assuming you mean the same generalization, a monoid is just a category with one object
16:48:27 <edwardk> BMeph: not as a category ;)
16:48:40 <dolio> Clearly a category is a generalized groupoid, not a generalized monoid. :)
16:49:07 <BMeph> dolio: "Obviously"? ;p
16:49:18 <ddarius> BMeph: Indeed obviously.
16:49:26 <ddarius> (well, minus the "not")
16:49:56 <edwardk> BMeph: you can trivially construct a category from any such pre-category by sketching in the identity arrows and pretending they exist. actually the construction of a category from a more traditional pre-category proceeds much that way, though it uses paths of arrows, and adds the null path instead of using the associative operation directly
16:50:06 <dolio> It's kind of like a groupoid and a monoid had babies.
16:50:21 <ddarius> Not really.
16:50:32 <ddarius> A groupoid is a category where all arrows are isomorphisms.
16:50:33 <dolio> :)
16:51:02 <FunctorSalad> group is the baby of monoid and groupoid with the category ancestor glued together... or something :)
16:51:19 <FunctorSalad> hell maybe it's actually a pushout in CAT
16:51:48 <FunctorSalad> (no I didn't think that through at all)
16:52:46 <gwern> hm, maybe I shouldn't've installed a ghc nightly: compiling cabal gives me messages like: 'WARNING: file simplCore/SimplCore.lhs line 545
16:52:48 <gwern> Simplifier still going after 4 iterations; bailing out.  Size = 5071
16:53:39 <edwardk> functorsalad in kata group inherits from both ;)
16:53:52 <FunctorSalad> kata?
16:53:56 <edwardk> my toy
16:54:12 <FunctorSalad> cat-extras?
16:54:12 <gwern> FunctorSalad: a set sequence of martial arts moves, intended to exercise and edify
16:54:44 <gwern> 'Interesting!  A join var that isn't let-no-escaped [$j{v s3ncg} [lid]]
16:54:47 <edwardk> not quite, another toy, untyped haskell with a kinda category-extras as the bulk of the prelude
16:54:50 <gwern> man, ghc nightly sure is chatty
16:55:02 <dolio> @seen mofmog
16:55:02 <lambdabot> I saw mofmog leaving #haskell 14h 53m 26s ago, and .
16:55:25 <FunctorSalad> edwardk: cool, apparently I'm not the only one obsessed with getting categories into the damned machine ;)
16:55:54 <dolio> FunctorSalad: You should take up maintainership of Charity.
16:56:06 <temoto> Is there parMapM_ ?
16:56:37 <ImInYourMonad> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2748#a2748 <- are those supposed to be  just passed around as functions? lambda calculus is jsut functions and 0 and 1 and 2 are just functions not values?
16:56:46 <FunctorSalad> dolio: too burned out from the coq and haskell attempt (including a current project ;))
16:57:02 <byorgey> ImInYourMonad: functions *are* values =)
16:57:04 <ImInYourMonad> is haskell lambda calculus extended with stuff that doesnt give more power just convenience?
16:57:14 <edwardk> functorsalad: yeah category-extras is what drove me to write kata, basically gutting my previous dependently typed toy language in the process
16:57:21 <gwern> ImInYourMonad: which lambda calculus? :)
16:57:39 <glguy> edwardk, why the rank 2 type on shift?
16:57:41 <byorgey> ImInYourMonad: for the most part, yes.  but the real answer is much more complicated.
16:58:04 <fynn> OK, this might be a misguided concept, but is there such a thing as a recursion calling itself recursively?
16:58:17 <pejo> gwern, the nightlies are built with debugging info iirc.
16:58:24 <fynn> sort of a meta-recursion, so to speak?
16:58:38 <edwardk> glguy: without it it permits some funny business, oleg wrote a post on it forever ago
16:58:52 <gwern> pejo: that would explain it
16:59:17 <jedai> temoto: parMap and the Strategy stuff is for pure code where ordering don't matter, there is a certain number of boss/worker libraries around that could have something you would like
17:00:02 <jedai> temoto: IIRC Control.Engine could have what you're looking for
17:00:14 <dolio> glguy: It's probably for a similar reason you'd want a rank-2 type on callCC.
17:00:38 <ddarius> "Funny business" is why I would be using the library in the first place.
17:01:03 <glguy> the preventing of funny business seemed to prevent what I was doing :)
17:01:52 <jedai> ImInYourMonad: More or less... though the addition of a type system does strange thing to the lambda-calculus
17:02:21 <rittyan> http://pastebin.ca/1367642 <- why matchesPattern complains about type? 'any' returns Maybe [B.ByteString] but... shouldn't "/= Nothing" part make that whole function body a Bool?
17:02:25 <jedai> ImInYourMonad: But the lambda calculus is definitely at the core of the language
17:03:58 <jedai> rittyan: The /= Nothing is not in the right place...
17:04:07 <temoto> @hoogle Maybe [a] -> Bool
17:04:07 <lambdabot> Prelude null :: [a] -> Bool
17:04:08 <lambdabot> Data.List null :: [a] -> Bool
17:04:08 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
17:05:03 <jedai> rittyan: But first we have another problem... why do you do all your IO with String and then convert them to ByteString just to do your regex checking, that's pretty messed up
17:05:40 <jedai> rittyan: If you need speed you should do everything with ByteString, it would simplify the whole mess too...
17:05:42 <temoto> jedai: that's his first haskell program.
17:06:11 <rittyan> temoto, he already knows I think :)
17:06:24 <jedai> temoto: Ok, but then String is enough (except if he wants very good performance)
17:06:43 <temoto> jedai: he wants performance.
17:06:51 <temoto> Performance is always wanted.
17:06:56 <rittyan> I'd like to get a very good performance, because I need to "do" 60+ G of data
17:07:06 <jedai> Then we write the whole thing with ByteString
17:07:36 <temoto> jedai: does it mean replace readLine with B.readLine ?
17:08:17 <rittyan> I don't have any readLines... only readFile and lines, that's all
17:08:32 <jedai> temoto: Yes, and if the files are big it would be better to use ByteString.Lazy
17:08:57 <jedai> I'll try to rewrite it here and see
17:09:22 <rittyan> (and fix my matchesPattern function too, please :-3)
17:10:14 <temoto> :t Char8.readFile
17:10:15 <lambdabot> Couldn't find qualified module.
17:10:23 <temoto> :t Data.ByteString.Char8.readFile
17:10:24 <lambdabot> FilePath -> IO BSC.ByteString
17:10:45 <luite_> Heffalump: I can't reproduce the crash when compiling with 6.10.1, but 6.10.2-rc1 crashes. Just tried 5 runs with both, 6.10.1 all 5 ok, 6.10.2-rc1 all 5 segfaulted or hung within 2 minutes (2x segfault, 2x hang, 1x internal error)
17:10:59 <temoto> :t readFile
17:11:01 <lambdabot> FilePath -> IO String
17:12:05 <dons> xmonad download statistics (aka who uses haskell!?? ) http://xmonad.wordpress.com/2009/03/22/xmonad-download-statistics/
17:14:54 <TomMD> Super, now we need to gather statistics about who uses existential quantification.
17:15:11 <dons> hehe
17:15:13 <ddarius> TomMD: That would be relatively easy to do.
17:15:16 <dons> and how that varies with time? :)
17:15:19 <TomMD> There was once a proposal (and I thought work by Duncan) on getting the extentions from cabal.
17:15:26 <luite_> does anyone here know about changes to the garbage collector in 6.10.2-rc1, that could cause my program to crashe?
17:15:30 <bos> i think the number of people who use existentials is pretty small.
17:15:45 <luite_> the parallel garbage collector
17:15:47 <ddarius> bos: Write a script to trawl hackage and find out.
17:15:57 <TomMD> The point it gathering all LANGUAGE * statistics from hackage.
17:15:57 <bos> ddarius: aye.
17:16:01 <dcoutts> it's easier than that
17:16:30 <dcoutts> however, packages do not properly declare their language extensions in their .cabal files
17:16:38 <TomMD> Yep, thats an issue.
17:16:47 <TomMD> Is that a warning these days?  Or does it pass silently?
17:17:51 <dcoutts> TomMD: it's silent, because we do not look at LANGUAGE pragmas in source code
17:17:55 <Boney> you'll miss out on the people that use xmonad say through their package manager.
17:18:06 <dcoutts> TomMD: anyone using -fglasgow-exts or similar gets a warning
17:18:06 <Boney> so you'll have to hook into the debian popcon scores.
17:18:16 <Boney> which reminds me,  I should run popularity contest.
17:18:35 <dons> Heffalump: if we say that xmonad + xmc has 10k lines (about right). and its been downloaded 75k times. that's 750 million lines of haskell code flung across the internet (bizarre statistic of the day :)
17:19:35 <TomMD> dcoutts: Would a patch to look at LANGUAGE pragma be considered for merging?
17:19:52 <shepheb> preflex: join #xmonad
17:19:59 <dcoutts> TomMD: yep, take a look at the code in Cabal already that the hugs support uses.
17:20:02 <temoto> jedai: any luck?
17:20:05 <dons> dcoutts: so i'll munge the hackage logs now. maybe doing similar breakdowns for all of hackage (e.g. percent by category over time), totals for categories, packages. top 100 packages
17:20:20 <dcoutts> TomMD: the trick is it being robust but also using the info in the right way
17:21:02 <dcoutts> dons: aye, think about which stats are most useful for users, what stats would we put on each package page in the new server? file a ticket with those ideas.
17:21:18 <dons> i've got to look at the python one, it has stats
17:21:19 <TomMD> dcoutts: Using the info in the right way? I am under the impression that if a LANGUAGE is found then a warning could be reported, no other requirements needed.
17:21:23 <dons> and rss feeds for each packages' checkout
17:21:53 <dcoutts> TomMD: you mean if a module uses a language pragma that is not declared in the .cabal file
17:22:05 <TomMD> Dcoutts: Yes
17:22:08 <dcoutts> TomMD: so, these warnings would be generated at build time?
17:22:13 <gwern> @qquote #haskell
17:22:13 <lambdabot> LoganCapaldo says: madness? This is #haskell!
17:22:22 <TomMD> dcoutts: And as warnings on hackage.
17:22:31 <TomMD> dcoutts: i.e. when the package is uploaded.
17:22:40 <gwern> hm. I wonder how many 300 parodies there are in @quote
17:22:42 <dcoutts> TomMD: ah yes, but that's harder
17:22:44 <gwern> @quote madness
17:22:44 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
17:22:48 <gwern> @quote madness
17:22:49 <lambdabot> shepheb says: unsafePerformIO :: IO a -> Madness
17:22:54 <TomMD> dcoutts: Would it be easier if the happs Hackage were working?
17:22:58 <dcoutts> TomMD: because you'd have to pre-process all the modules
17:23:09 <gwern> @quote madness
17:23:09 <lambdabot> LoganCapaldo says: madness? This is #haskell!
17:23:15 <rittyan> :-D
17:23:27 <dcoutts> TomMD: no, not much easier. It would have to be done by a QA build client. It could not be done synchronously at upload time.
17:23:33 <p_l> tunite, we compute in hellz? :)
17:24:01 <gwern> p_l: unfortunately, there is no tonight quote
17:24:04 <dcoutts> TomMD: and we have to add a new field for extensions that are used but not applied.
17:24:10 <TomMD> dcoutts: Shucks, I was hoping so.  I suppose this fits in the category of e-mailing warn and error conditions to the maintainer automatically.
17:24:15 <gwern> and just 2 madness quotes!
17:24:18 <dcoutts> TomMD: I don't want to discourage you! :-)
17:24:33 <dcoutts> TomMD: it's just a tad harder than it looks
17:24:58 <TomMD> dcoutts: I'll look at spending some time on happs-hackage.
17:25:00 <dcoutts> TomMD: the ability to have that warning would be really useful, even if it's not on by default for casual builds.
17:25:01 <gwern> p_l: but there's no really funny tonight parody - 'Haskellers! Tonight we compile in Malbolge!'
17:25:02 <jedai> temoto: maybe, depending on the level of performance of regex-pcre
17:25:08 <dcoutts> TomMD: that'd also be extremely useful
17:25:13 <gwern> maybe tonight we write in Malbolge?
17:25:53 <dcoutts> TomMD: I was working on doc uploads last time I had any time to work on the hackage-server. Another useful thing would be porting to happstack-0.2
17:26:00 <temoto> jedai: can we have a look?
17:26:17 * p_l half-expects to see some weird warning in 4chan style sometime in GHC's output
17:26:29 <TomMD> dcoutts: That should probably be the first order of business, porting to happs-stack.
17:26:37 <gwern> what do y'all think of 'Haskellers! Tonight we write in Malbolge!'
17:27:03 <dcoutts> TomMD: I ported to version 0.1, so it's just the 0.1 -> 0.2 to do. They've got good upgrading instructions linked from the release notes.
17:27:13 <ddarius> gwern: I think trying to manufacture a quote is pointless.
17:27:50 <gwern> ddarius: nonsense. half the quote db is people who sat down to try to write something good
17:27:55 <TomMD> dcoutts: Ohh, sounds like a good first task.
17:27:55 <gwern> not all of them are off the cuff
17:27:55 <jedai> temoto: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2749#a2749
17:28:02 <goomba``> @quote
17:28:02 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
17:28:07 <goomba``> uhm ok
17:28:26 <dcoutts> TomMD: yes, it'll also give you a reasonable overview of the code.
17:28:30 <jedai> But the main point is that pcre-light may be used but only if the individual files aren't too big
17:28:31 <ddarius> gwern: You're assuming that greater than half the quote db isn't crap.
17:28:51 <gwern> ddarius: assuming? I know
17:29:21 <dons> pcre-light should be ok for large things, no?
17:29:28 <dons> well, i guess if it doesn't fit in memory
17:29:29 <jedai> rittyan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2749#a2749
17:29:39 * gwern wishes I hadn't accidentally blown away my ghc installation and been forced to reinstall
17:30:00 <jedai> dons: Well yes but you have to cut it yourself since it needs Strict Bytestring
17:30:21 <dons> yeah
17:30:29 <jedai> dons: or do some really painful coercing
17:30:54 <jedai> dons: but I guess it's the fastest of the pcre packages, no ?
17:31:05 <rittyan> jedai, let me see, thanks
17:31:13 <dons> probably similar to regex-pcre
17:31:25 <dons> pcre performance will dominate, not the marshalling
17:32:20 <jedai> rittyan: Tell me how it performs
17:32:28 <rittyan> jedai, where are you using isJust?
17:32:42 <jedai> rittyan: Oops, this version doesn't
17:33:00 <jedai> rittyan: You can delete this line, it was for pcre-light
17:33:12 <rittyan> jedai, plus your regexes don't compile
17:33:32 <dons> i think i can summarise the xmonad download stats. given the popcon installs keep growing, the decline in source installs is what it looks like to get into all the distros.
17:33:32 <jedai> rittyan: you don't have ghc6.10 ?
17:33:49 <rittyan> jedai, no I don't, because it had troubles with xmonad
17:33:49 <dons> distribution is taken out of the developers hands, and it becomes hard to see where the code is flying to.
17:34:00 <jedai> rittyan: Then add a "map B.pack" before the list of patterns
17:34:04 <rittyan> jedai, 11s for ~600mb file
17:34:18 <jedai> patterns = map B.pack ["GET']
17:34:22 <pejo> dons, but that is a good thing though - makes it accessible to more users.
17:34:26 <dons> yeah.
17:34:32 <dons> that's a good thing. very good.
17:34:33 <gwern> dcoutts: I noticed something today. bootstrap doesn't compile profiling in
17:34:36 <dons> just makes it hard to estimate installs :)
17:34:59 <jedai> jedai: That's pretty bad, that means a very long time for your total data set...
17:35:22 <dcoutts> gwern: do you think it should not install the libs?
17:35:23 <jedai> How did the Python performs by the way ?
17:35:26 <rittyan> jedai, thank you for your help
17:35:41 <dcoutts> gwern: just build them locally and build the executable against them in-place?
17:35:51 <adamvo> dons: have we kept track of the number of people in #xmonad?
17:35:52 <temoto> How to install Text.Regex.PCRE?
17:35:58 <gwern> dcoutts: well I just noticed that after I bootstrapped and went to install cabal install, I then had to reinstall all the bootstrapped libs with profiling
17:36:03 <dons> it shouldn't take long to get 1M hackage downloads these days. there's 1k packages. download each 1k times. 1M downloads. :)
17:36:06 <jedai> temoto: cabal install regex-pcre
17:36:14 <dons> adamvo: some of the irc channel servers do. yes. let me see.
17:36:26 <gwern> dcoutts: I'm not sure not-installing them is wrong, but presumably there's no way installing them profiled can be bad
17:36:49 <jedai> rittyan: If you could tell me how it compares with the Python equivalent that would be a useful data point for me
17:36:49 <gwern> dcoutts: oh yes, and this all arose because bootstrap ignored my .cabal/config and installed to ~/.cabal/bin
17:37:07 <dons> adamvo: http://gogloom.com/FreeNode/xmonad/
17:37:24 <kolmodin> c.h.o seems down?
17:37:44 <gwern> it was up when I was pulling not long ago
17:37:46 <dons> just ssh'd in.
17:38:02 <dons> apache might be down
17:38:09 <dons> Igloo: ping
17:38:12 <rittyan> jedai, haskell version is very far from python one... in python one regular expressions are compiled sql/xss attacks patterns... and instead of printing lines into stdout it serializes data into a file on a disk... plus it processes files in parallel
17:38:17 <temoto> How to get cabal on ubuntu? :)
17:38:18 <kolmodin> aye, that's works for me, but not the gentoo overlay users
17:38:47 <kolmodin> a user reported to me
17:38:56 <temoto> jedai: yeah he needs parMap in some way.
17:39:15 <jedai> rittyan: I meant as for the performance, adding parallelism to this should be pretty easy
17:39:38 <dons> temoto: hmm. what ghc and cabal version does ubuntu come with?
17:39:44 <dons> we should have an ubuntu-haskell channel
17:39:49 <jedai> Do you estimate 60MB/s a good performance basis or do you need much better ?
17:40:05 <rittyan> jedai, I am reading through Text.Regex.PCRE help, trying to figure out how to compile regexes with 'i' options... then we will try to compare it
17:40:36 <gwern> dons: jaunty is 6.8.2
17:40:56 <gwern> as ever...
17:41:01 <temoto> dons: there is no cabal in my system. GHC is 6.8.2
17:41:24 <temoto> That's what i want - cabal :)
17:41:28 <Igloo> kolmodin: Should be fixed now
17:41:46 <dons> temoto: ok. that should be enough to install a newer cabal from hackage.haskell.org, and then cabal-install
17:41:52 <kolmodin> Igloo: cool, thanks!
17:45:11 <jedai> rittyan: You need to use compile() if you want to add options to your regexes
17:45:46 <dcoutts> gwern: I'm not sure you can expect the bootstrap to look at an existing ~/.cabal/config file
17:45:59 <dcoutts> gwern: building profiling libs means it takes twice as long
17:46:16 <dcoutts> gwern: the bootstrap does have a prefix variable you can set
17:46:21 <gwern> dcoutts: why shouldn't I? it's there, after all
17:46:54 <dcoutts> gwern: presumably it should still work if you've got a borked cabal install
17:47:17 <dcoutts> gwern: and the choice of where to put the cabal binary is somewhat independent of the settings in ~/.cabal/config
17:47:31 <dcoutts> gwern: especially if we do not install the dependent libs
17:48:04 <Gracenotes> hm, I wonder if using @pl to help in an obfuscation is considered cheating.. :/
17:48:17 <dcoutts> gwern: but mainly I'm grumbling because using the ~/.cabal/config from a portable /bin/sh script is a pita.
17:48:29 <gwern> lovely, ghc head is borked on some of xmc
17:49:49 <_roconnor_> @src dropWhile
17:49:49 <lambdabot> Source not found. Maybe you made a typo?
17:50:00 <gwern> '[  1 of 149] Compiling XMonad.Layout.MultiToggle ( XMonad/Layout/MultiToggle.hs, dist/build/XMonad/Layout/MultiToggle.o )\nghc: panic! (the 'impossible' happened)\n  (GHC version 6.11.20090320 for i386-unknown-linux):\n ASSERT failed! file typecheck/TcUnify.lhs line 1003\n a{tv a1jG} [box]'
17:50:28 <gwern> hm, and derive also needs to be updated
17:51:02 <Botje> ghc did the impossible again! yaaay
17:51:25 <Badger> @src (>>>)
17:51:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:51:40 <Botje> not really a source to it
17:51:43 <Badger> @hoogle (>>>)
17:51:43 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
17:51:44 <Botje> it just hooks up two arrows
17:52:09 <Botje> for (->) it's flip (.)
17:52:09 <jedai> rittyan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2749#a2750
17:52:26 <rittyan> jedai, you eased my pain :<
17:52:39 <jedai> rittyan: In fact most of the interface is exposed in regex-base
17:53:16 <Badger> Botje: I'll have to go look up arrows, but thanks. :P
17:53:19 <jedai> rittyan: it's a module that presents an interface to a lot of regex engines (like pcre, posix, tre, ....)
17:53:26 <Badger> @hoogle (-<)
17:53:26 <lambdabot> No results found
17:54:01 <jedai> rittyan: You'll probably need to add a pack() somewhere since you're on the 6.8
17:55:07 <_roconnor_> is there a binary version of readFile
17:55:13 <jedai> Now that I think about it... 60MB/s is probably pretty good, no ? I mean I'm pretty sure it's not far from the limits of the HDD...
17:55:18 <_roconnor_> something returning IO [Word8] ?
17:55:19 <rittyan> jedai, yup... and fill patterns list
17:55:43 <p_l> jedai: nowadays laptop drives reach ~100MB/s
17:55:45 <syntaxfree> this is way off-topic, but what's the way to go for Lush support? can't get it to compile.
17:56:09 <gwern> what's lush?
17:57:04 <jedai> p_l: Given that it's a treatment line by line with a regex test, I would consider reaching 60% of the reading performance of my HDD pretty good, probably
17:58:03 <p_l> jedai: Well, as far as I scrolled up, I got the impression it was about IDS thingy... and I'd expect one of those to have RAID-0 with at least two 15k drives :>
17:58:31 <rittyan> jedai, my python is 185 seconds
17:59:10 <syntaxfree> gwern google "lush lisp".
17:59:15 <syntaxfree> @google lush lisp
17:59:16 <lambdabot> http://lush.sourceforge.net/
17:59:16 <lambdabot> Title: Lush: Lisp Universal SHell
17:59:20 <ImInYourMonad> Is this statement correct(though a matter of taste perhaps): Lambda calculus and imperative programming might be equivalent as far as power goes, but in the same way that radians and degrees are equal in what you can measure with them and choosing radians makes so many things more elegant, choosing lambda calculus as the base makes programming languages more elegant and creates a much more elegant language where ideas fit better to
17:59:21 <jedai> _roconnor_: Well ByteString reads the file binary
17:59:27 <gwern> ah. that is rather off-topic then
17:59:30 <rittyan> \%3 <- is it some special sequence in a string?
17:59:39 <syntaxfree> gwern yes, so I said.
18:00:21 <Cale> ImInYourMonad: It got cut off.
18:00:22 <jedai> _roconnor_: And if you don't use the Char8 version, you can unpack them into [Word8] yes
18:00:30 <Cale> ImInYourMonad: around "ideas fit better"
18:00:31 <gwern> ImInYourMonad: I think I would try to focus on the idea that FP languages trash many fewer laws and invariants than imperative ones, and so they are much easier to reason about/be confident in/manipulate/trust
18:02:02 <jedai> rittyan: When you say 185s you mean on the same amount of data that you tested the Haskell script on or on the total (60GB) ?
18:02:04 <rittyan> is there some "raw" strings in haskell?
18:02:15 <jedai> rittyan: ByteString is it
18:02:21 <rittyan> jedai, same amount, though full set of regexes...
18:02:28 <marcot> :t runState
18:02:29 <lambdabot> forall s a. State s a -> s -> (a, s)
18:02:30 <rittyan> jedai, I mean strings that need no escaping of slashes etc
18:02:42 <jedai> rittyan: Yeah, ok, we'll see how well Haskell do with the full set
18:02:56 <rittyan> yes, once I fill that thing with regexes
18:03:08 <blackdog_> rittyan: so you want literal strings in haskell source, you mean?
18:03:09 <jedai> rittyan: Ah I see, like the string between ' ' in Perl/Python ?
18:03:36 <rittyan> yes, in perl
18:03:42 <rittyan> python escapes in '' and "" :)
18:03:46 <rittyan> blackdog_, yup
18:04:11 <Cale> It should only be backslashes you need to escape.
18:04:25 <rittyan> okay
18:04:27 <Cale> and of course, special characters and quotes
18:04:32 <rittyan> it is just... you know, regexes are fugly by themselves
18:04:35 <Cale> (double quotes :)
18:04:36 <rittyan> and escaped regexes are even fuglier
18:04:44 <jedai> rittyan: I think that may be done with some of the extension in 6.10, but in 6.8, I don't think so
18:04:49 <Cale> Well, don't use regexes then :)
18:05:03 <Cale> We have nice proper parsing libraries :)
18:05:30 <jedai> rittyan: Well in fact there is a module that use this extension to allow nice looking regexes
18:05:43 <jedai> rittyan: Only works in 6.10 though, sorry
18:06:16 <rittyan> jedai, oh I just recalled that I need to write extracode for line parsing... benchmarking is delayed for a bit more time
18:06:28 <Cale> line parsing?
18:06:50 <rittyan> words line
18:06:52 <rittyan> + take eight element
18:07:04 <rittyan> eightth
18:08:07 <Cale> ah, something like map (\x -> words x !! 7) . lines
18:08:33 <glguy> Does it make sense that >=> and <=< have the same fixity?
18:08:39 <rittyan> what is !! operator?
18:08:54 <Cale> It gets the nth element of a list
18:09:00 <rittyan> oh, right
18:10:44 <ImInYourMonad> ...together
18:11:14 <BMeph> glguy why would they have different fixities?
18:11:51 <jedai> BMeph: So that you could put both in the same expression and write even more ofuscated code !! ^^
18:12:02 <glguy> BMeph, I would expect  a >=> b >=> c  to nest identically as c <=< b <=< a
18:12:17 <Mr_Giraffe> :t (>=>)
18:12:18 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:12:32 <ddarius> BMeph: In logic languages beyond Prolog, => and <= have different precedences.
18:12:43 <jedai> Oh you mean that they have the same fixity direction, right that seems pretty strange
18:12:46 <Mr_Giraffe> :t (<=>)
18:12:47 <lambdabot> Not in scope: `<=>'
18:12:49 <Mr_Giraffe> aww
18:12:53 <glguy> jedai, actually, as it stands now you can use them in teh same expression
18:13:23 <syntaxfree> that's why polish notation was invented.
18:13:29 <syntaxfree> not for lisp. for logic.
18:13:34 <jedai> glguy: Right, it's pretty bad...
18:18:26 <rittyan> hmm I am doing something really wrong
18:19:22 <jedai> rittyan: ???
18:20:40 <temoto> like coding at 04:22
18:21:04 <temoto> (AM)
18:21:50 <blackdog_> temoto: too true. just looked back at what i was doing last night and it looks like a first year student's homework...
18:22:40 <monochrom> haha
18:22:51 <temoto> Well first year students at least do their homework.
18:22:57 <glguy> I love how shift and reset make it seemingly impossible to know what's going on without seeing the whole picture :-)  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2751#a2751
18:23:00 <rittyan> I wasn't doing my homework
18:23:07 <blackdog_> seriously. cut-and-pasted code, explicit recursion, functions with numbers after them...
18:23:09 <rittyan> (though look what has become of me)
18:23:16 <ddarius> glguy: You've been programming in Haskell too long.
18:23:24 <temoto> rittyan: ^^^ shift/reset
18:23:40 <blackdog_> rittyan: oh, me either. that's the sad bit.
18:23:55 <glguy> OOPS
18:24:01 <glguy> I changed the numbers of the values
18:24:08 <glguy> but didn't recreate the output
18:24:17 <glguy> man, I'm making a confusing topic more confusion
18:24:19 <glguy> ing*
18:25:17 <gwern> I'm always amazed at how long highlighting-kate takes to compile
18:26:04 <glguy> ddarius, I'm not sure what you mean :)
18:27:16 <ddarius> glguy: If you programmed in Visual Basic regularly, you'd be used to side-effects flying around.
18:28:29 <EvilTerran> glguy, where's this "shift" & "reset" from?
18:28:44 <gwern> ddarius: that's like saying, if you were molested regularly, you'd be used to fluids flying around
18:28:52 <temoto> ddarius: VB is student homework?
18:28:59 <ddarius> gwern: Would you not?
18:29:31 <glguy> EvilTerran, similar to this: http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
18:29:44 <EvilTerran> ta
18:29:58 <ImInYourMonad> so is leksah any good? i couldnt even compile it on windows
18:30:12 <gwern> I've heard it is. but I can't even compile gtk2hs, so dunno
18:30:52 <jedai> temoto: I think ddarius is alluding to the fact that glguy is now surprised when he needs to read the whole program to understand what goes on in one function whereas in imperative language (especially one as wild as VB) it is common occurence
18:31:27 <dons> gwern: what's your problem?
18:31:29 <temoto> jedai: i understood that.
18:31:31 <dons> ImInYourMonad: yeah, i think it's neat.
18:32:00 <gwern> dons: it's just a strange problem with the build script not finding the glibstring stuff
18:32:15 <gwern> dons: it's very odd, it's dogged me across multiple ghc and os installs
18:32:22 <dons> maybe it's you then?
18:32:33 <gwern> that does seem to be the only common factor!
18:32:47 <dons> scary.
18:33:01 <gwern> (not that I've seen any other ubuntu users claim success, tho)
18:33:02 <dons> have someone else type 'make' for you.
18:33:16 <jedai> gwern: I claim success !!
18:33:20 <dons> you could switch to Arch, and type 'pacman gtk2hs'
18:33:25 <Nafai> gwern: Which version of gtk2hs?
18:33:30 <gwern> darcs
18:33:33 <ddarius> I built gtk2hs just the other day.
18:33:38 <gwern> I tried the last release as well
18:33:42 <jedai> gwern: well not the darcs version though
18:33:51 <gwern> (and I'm retrying now with 6.11 just to see)
18:33:54 <Nafai> I was able to build darcs a while back on ubuntu, but then agian, I've installed GHC 6.10 from source
18:34:06 <jedai> ddarius: 0.10 on ghc6.10.1, with Ubuntu intrepid
18:34:58 <ddarius> jedai: I'm using Hardy Heron.
18:35:08 <Nafai> I did so on Intrepid as well
18:35:22 <luite_> I did have a problem building the profiled version of gtk2hs 6.10, --enable-profiling would only work with --disable-dependency-tracking, is that a known problem?
18:35:29 <Botje> @pl \ast -> f (isThunk ast) ast
18:35:29 <lambdabot> f =<< isThunk
18:36:26 <jedai> Botje: Cool ! Since when does @pl know about the function monad ?
18:37:03 <gwern> maybe it always knew
18:37:16 <ddarius> jedai: For over a year at least.  Years, I think.
18:37:37 <gwern> you're out of date, jedai. way out of date
18:37:44 <jedai> Damn, I thought it was new... :(
18:37:47 <Botje> @pl \ast -> f ast (isThunk ast)
18:37:47 <lambdabot> ap f isThunk
18:37:51 * gwern consigns jedai to the trash heap of history. we will bury you!
18:38:50 * jedai looks around and confortably installs itself in the trash heap
18:39:10 <rittyan> :<
18:39:19 <dons> jedai: yeah, forever. it introduced Monad (-> a) to us
18:39:31 <gwern> hm. it occurs too late to me that 'we will GC you!' would've been a better kruschev parody
18:39:44 <gwern> alas! l'espirit d'escalier strikes again
18:41:38 <jedai> Well the (k ->) monad is a great contribution to the obfuscation of the Haskell world, @pl is definitely a key of this effort
18:42:31 <ImInYourMonad> are church numerals basically defined as natural numbers? f^n
18:42:53 <Philippa_> ImInYourMonad: they're an encoding of them
18:43:06 <Philippa_> and yes
18:43:43 <rittyan> jedai, my regexes don't work (strangely enough) or there is something else
18:44:15 <Philippa_> another way of looking at them: they're the fold function for the corresponding number
18:44:21 <jedai> rittyan: The program I pasted works (the regex is properly insensitive to the case)
18:44:33 <jedai> rittyan: what is the problem exactly
18:46:39 <rittyan> jedai, prolly my bad copyying of regexes... trying to run atm
18:46:48 <rittyan> (the app)
18:48:19 <jedai> To combine options you have to use the .|. operator (binary or)
18:48:40 <jedai> I'm not sure at all that using + would work correctly
18:49:47 <rittyan> thanks for tip
18:54:03 <ImInYourMonad> it sjust i dnt quite understand how to work with church numerals, how to do arithmetic etc, i wsant to see the results :)
18:54:20 <ImInYourMonad> at leat with Peano Arithmetic I gt S (S (S (S O)))
18:54:39 <ImInYourMonad> pita for big nbrs but visual feedback
18:54:40 <rittyan> ok, it matches stuff fine... it is just terribly slow
18:56:11 <rittyan> jedai, http://pastebin.ca/1367696 <- here's the code we've written so far...
18:56:16 <rittyan> waiting for results
18:59:04 <jedai> rittyan: several things wrong with the regexps
18:59:21 <rittyan> ?
18:59:23 <jedai> starting with the .* at the beginning and end
18:59:53 <jedai> They're useless and potentially devastating for the performances (if they're not optimized away by the engine)
19:00:14 <jedai> Also % is not a special character so you don't need to escape it
19:00:25 <rittyan> I am not
19:00:37 <rittyan> I need \%n in regex
19:00:48 <rittyan> *I do not
19:01:01 <jedai> You mean there really is an antislash in the text ?
19:01:03 <rittyan> to match hex stuff
19:01:16 <rittyan> or not
19:01:18 <rittyan> it is 5am :S
19:01:26 <rittyan> jedai, right I don't need it
19:02:01 <jedai> Do you want to match the character % or the character corresponding to the hex code ?
19:02:09 <ImInYourMonad> if you were to make a proper basic lambda calculus interpreter, how would you do numbers? if using church numerals would you use a show function that would show the numeral-function as a number somehow?
19:02:23 <jedai> Yeah, here it's just 3am so I'm much fresher ;)
19:03:35 <rittyan> "((%3D)|(=))[^\\n]*((%27)|(')|(--)|(%3B)|(;))" and "((%3C)|<)[^\\n]+((%3E)|>)" <- that's how it looks now
19:03:54 <ImInYourMonad> Use -XTypeSynonymInstances if you want to disable this.)
19:04:08 <ImInYourMonad> how exactly? {- -XTypeSynonymInstances -} ?
19:04:26 <monochrom> onoes
19:05:08 <jedai> Yes, much better probably, you can also use makeRegex instead of "makeRegexOpts compBlank execBlank"
19:05:32 <rittyan> jedai, code itself looks acceptable to you? Maybe there is a slow part with no relation to regexes
19:05:35 <monochrom> one way: ghc -XTypeSynonymInstances
19:05:58 <monochrom> another way: {-# LANGUAGE TypeSynonymInstances #-}
19:05:59 <jedai> Also I'm not sure what [^\\n] is supposed to do but I think you may as well put . instead
19:06:10 <jedai> since we're matching lines anyway
19:06:17 <rittyan> [^\n] in the end
19:06:32 <rittyan> wait
19:06:41 <jedai> I think that the getQuery part isn't optimal
19:09:05 <rittyan> any ideas on improving it?
19:09:38 <rittyan> maybe there could me that maybe thing with just/nothign so we won't be checking length twice?
19:10:02 <ImInYourMonad> prove SPJ!
19:10:15 <luite_> hasn't anyone else seen this kind of errors (or just segfaults) when running -N2 or -N4 with 6.10.2-rc1? I don't think my program does anything special: internal error: scavenge_one: strange object 0 (GHC version 6.10.1.20090321 for x86_64_unknown_linux)
19:10:26 <ImInYourMonad> @faq can haskellprove SPJ's existence?
19:10:26 <lambdabot> The answer is: Yes! Haskell can do that.
19:10:52 <ImInYourMonad> @faq can haskell murder lambdabot?
19:10:53 <lambdabot> The answer is: Yes! Haskell can do that.
19:11:01 <gwern> amazing. ghc 6.11 seems to've finally broken my gtk curse
19:11:14 <ImInYourMonad> @src murderLambdabot
19:11:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:11:15 <dons> luite_: means a GC bug
19:11:16 <dons> report it!
19:11:23 <gwern> first thign I'll try is leksah, inasmuch as yi doesn't compile because derive doesn't
19:11:34 <gwern> dag nabit! 'cabal: cannot configure leksah-0.4.3. It requires gtksourceview2 >=0.10.0
19:12:10 <rittyan> jedai, it runs over nine minutes already, I'm ^Cing it :)
19:12:19 <luite_> dons: yeah, I'm a bit behind on my project because of having to deal with segfaults, but I'll have to make a smaller test case
19:12:46 <luite_> dons: I hope I have some time later, to do that
19:12:57 <luite_> because the program is more than 1000 lines
19:13:27 <luite_> but 6.10.1 doesn't have this problem, fortunately
19:15:38 <luite_> dons: I do use some immutable uvector things in my program. do you know if an indexU on an invalid index could cause heap corruption of any kind?
19:15:43 <rittyan> jedai, actually it'd be great to save query along with some other information into some structure, all this processing is done to serialize it later, anyway
19:15:59 <rittyan> so maybe there's a need it different approach
19:17:00 <jedai> rittyan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2749#a2755
19:18:10 <jedai> rittyan: So you would need to parse the line into another data structure before you do some test, is that it ?
19:19:30 <rittyan> jedai, yes... what i need exactly is to get query, date time and source ip... it all can be done with the '!!' operator
19:20:27 <jedai> But that would probably be a bad idea to use (!!) three times like that, there is probably a better approach, like for exemple a regex ?
19:21:28 <rittyan> accessing index should be faster than making a regex for extracting data from a line
19:21:36 <rittyan> plus it is easier
19:22:28 <jedai> Depends, anyway did you try my proposition, is it any faster ?
19:22:48 <rittyan> trying right now
19:23:57 <jedai> delete all the parens too, that's likely to slow things down
19:24:16 <rittyan> don't we use a libpcre?
19:24:27 <rittyan> 111 seconds
19:24:49 <jedai> "(%3D|=).*(%27|'|--|%3B|;)" and "(%3C|<).+(%3E|>)"
19:24:52 <ImInYourMonad> ill now goand program in python!
19:25:41 <rittyan> ImInYourMonad, :)
19:25:41 <jedai> the capturing parens always slow things down, whatever the engine and here you have many of them that don't serve any purpose
19:25:52 <rittyan> true
19:26:01 <rittyan> however it shouldn't be dramatic
19:26:11 <rittyan> anyway your code is already faster than my python :)
19:26:19 <rittyan> by a minute I think?
19:26:19 <jedai> rittyan: You would be surprised
19:26:33 <jedai> rittyan: But your python does more, no ?
19:26:42 <rittyan> hmm let me look up in logs
19:27:03 <lepassive> is there #-*- coding:utf-8 -*- like in haskell ?
19:27:11 <rovar> [ runGet getBSONObject (L.readFile x) | x <- files , (C8.pack "bson") `isInfixOf` (C8.pack x)]
19:27:31 <rittyan> python was 185 seconds
19:27:41 <rovar> L.readFile returns IO ByteString, I need a ByteString,  how can I run the 1st part of the list comprehension in the IO monad?
19:28:56 <jedai> lepassive: ghc can accept utf8 code, you can use utf8 in the name of your variables and so on, also use utf8-string to do utf8 aware IO
19:29:28 <lepassive> jedai, hmmm then why can't i use UTF8-strings in Gtk2hs 's TreeView ?
19:30:14 <jedai> lepassive: Don't know, maybe a limitation of Gtk2Hs, you would have to ask the maintainers
19:31:01 <lepassive> jedai, well thanks, is there a gtk2hs channel ?
19:31:16 <jedai> rovar: results <- sequence [ liftM (runGet getBSONObject) (L.readFile x) | x <- files , "bson" `isInfixOf` x]
19:31:28 <dons> luite_: try compiling uvector with -fsafe
19:31:33 <dons> to catch any invalid indexU's
19:31:48 <dons> if you're seeing a GC crash between 6.10.1 and 6.10.2 you need to report i
19:32:28 <jedai> lepassive: I don't know, there is a mailing list anyway http://www.haskell.org/gtk2hs/development/
19:32:42 <lepassive> jedai, okay thanks so much
19:32:53 <rovar> jedai: thanks
19:32:56 <rovar> that worked
19:33:27 <jedai> rittyan: "(?:%3D|=).*(?:%27|'|--|%3B|;)" and "(?:%3C|<).+(?:%3E|>)"
19:33:44 <luite_> dons: ah, thanks for the tip
19:34:15 <dons> luite_: also, make sure you're using the latest uvector from darcs
19:34:18 <dons> there were some bug fixes.
19:34:22 <jedai> rittyan: But if you parse the line before hand, we should concentrate on making that efficient
19:34:22 <dons> uvector is alpha software.
19:35:41 <rittyan> jedai, I think so.
19:36:31 <luite_> dons: yes I run the latest version. should reinstalling using 'cabal install --reinstall -fsafe uvector' do the trick?
19:37:04 <dons> oh, using the darcs version?
19:37:05 <rittyan> jedai, we are down to 92 seconds :)
19:37:13 <dons> luite_: yes, that will reinstall, if you're in the darcs repo
19:37:13 <ImInYourMonad> http://podularraludop.appspot.com/ <- how should I redo that? does anyone here listen to podcasts a lot? im thinking once a week use Yahoo's search service and go out and collect new podcasts and then instead have a 1-5 voting system ro just rank on most clicked.
19:37:30 <luite_> dons: no I just use the latest from hackage
19:37:55 <dons> luite_: try the darcs version, it has bug fixes. darcs get http://code.haskell.org/~dons/code/uvector/
19:38:01 <dons> then build that with the command you specified
19:39:05 <jedai> rittyan: Also if you have a multicore, we can probably improve that performance easily with a little bit of parallelism
19:39:22 <dons> jedai: i like this kind of talk :)
19:39:37 <dons> get the new guys doing multicore on day one, and they'll be hooked
19:39:40 <rittyan> jedai, yup, my py version is parallel :<
19:40:09 <dons> then we get to see by how many magnitudes better the haskell scales... :)
19:40:40 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=python&lang2=ghc&box=1
19:43:50 <rittyan> jedai, is there a parFilter? :)
19:45:23 <dons> split into chunks. filter each chunks. combine
19:45:43 <rittyan> oh, even more agressive mapreduce
19:46:20 <jedai> rittyan: It seems to me the easiest way to do this parallelisation is to handle files in parallel (if there is enough files, if not you have to go the chunk road like dons said)
19:47:03 <rittyan> jedai, my existing app processes few files at once... without any chunking... and i think that this is good enough
19:48:07 <ddarius> dons: So replace Hello World and fib with a concurrent web server.
19:48:22 <O_4> Are there any haskell libs for doing POP3 with SSL and SMTP with TLS?
19:48:26 <dons> yeah. that's actually pretty easy. mostly demonstrates only forkIO though
19:48:26 <jedai> Ok, that should be really easy, two/three lines at most
19:48:36 <dons> O_4: i think so. look on hackage.haskell.org
19:49:00 <O_4> dons: I've seen a few on there, but none appear to support secure comms.
19:49:03 <dons> ddarius: (not that i think its a bad idea. i think its a good one)
19:49:09 <dons> O_4: maybe not then. time to write a binding!
19:49:33 <O_4> dons: there's also haskellnet which isn't on there, but again it doesn't appear to support secure comms.
19:49:36 <ddarius> dons: Make "the Real Monad Transformer".  That adds regexes and potentially parallelism.
19:49:39 <O_4> dons: heh.
19:50:47 <jedai> rittyan: Though as it is now it will produce garbage, you should output in different files to be sure that the different files don't get mixed
19:51:33 <luite_> dons: I can still reproduce the problem with the new uvector from darcs, compiled with -fsafe. I'll try to make a test case that does not depend on uvector later, when I have a bit more time
19:51:42 <dons> ok. great.
19:51:48 <dons> that means probably not uvector's fault
19:51:59 <dons> and it is a GC bug. so you should maybe try it with a snapshot from the head
19:52:07 <dons> (which has different rts stuff going on)
19:52:33 <luite_> hehe, all those ghc snapshots are filling up my hard drive quickly
19:52:53 <rittyan> jedai, existing code works like that: 1) parse a file 2) get key-value information about source ip, date time etc from log for matching lines 3) serialize them into file on disk after reading a file... and... if I processed file "foo", it will be "foo_somesuffix" then... after all files are processed - one big serialized file is created
19:53:00 <rittyan> jedai, maybe there are better approaches
19:53:37 <rittyan> jedai, I mean that each file has its own small serialized file
19:54:02 <jedai> rittyan: That seems easy to implement and robust
19:54:14 <rittyan> yay \o/
19:54:22 <jedai> I would go with that unless there was a big performance problem
19:54:32 <rittyan> jedai, no that is done once in a day in cron
19:54:43 <jedai> rittyan: Is that what the python application does in 185s ?
19:54:50 <rittyan> jedai, yes
19:54:57 <jedai> And how many cores do you have ?
19:55:00 <rittyan> two
19:55:14 <rittyan> (and still python has more regexes)
19:55:20 <rittyan> is there a dehexify function in haskell?
19:55:24 <jedai> We can try 4 threads
19:55:28 <rittyan> to find all "%n" and turn them into normal text?
19:55:31 <jedai> rittyan: dehexify ?
19:55:58 <ImInYourMonad> regexen
19:56:09 <jedai> No, shouldn't be too hard to write though
19:56:28 <jeffwheeler> > do { x <- [1..3], y <- [4..6], guard (x*y==8), return (x, y) }
19:56:29 <lambdabot>   <no location info>: parse error on input `,'
19:56:29 <rittyan> that way I would make regexes really small
19:56:42 <jeffwheeler> > do { x <- [1..3]; y <- [4..6]; guard (x*y==8); return (x, y) }
19:56:43 <lambdabot>   [(2,4)]
19:56:55 <jeffwheeler> Could that be rewritten using the LogicT monad?
19:57:03 <jeffwheeler> . . . and if so, when would it make sense to do that?
19:57:27 <_roconnor_> why is C so fast?
19:57:29 <_roconnor_> It's not fair
19:57:49 <jeffwheeler> For example, I was trying to replicate the Cryptol sudoku thing, but it seems like just using guard is wrong.
20:00:40 <Ralith> Is there a way to use hint or a similar ghc-based haskell interpreter without requiring ghc installed on the machine running the compiled program?
20:00:58 <gwern> nooo... I finally get sourceview installed with gtk2hs, and then a leksah compile errors on a ghc flaw
20:01:11 * gwern can has leksah?
20:02:12 <Ralith> basically I want to compile everything necessary into the program and/or provide whatever extra datafiles it needs directly, rather than having it try to find a system ghc to get them from
20:02:39 <gwern> Ralith: I don't think so, unless you avoid loading anything except the prelude
20:03:17 <gwern> and maybe not even then, since a ghc api user needs to load modules, and that info is only accessible in a ghc pkg.conf, which gives file addresses etc of the compiled libs
20:03:34 <Ralith> can I provide package.conf then?
20:03:38 <ImInYourMonad> http://podularraludop.appspot.com/ <- how should I redo that? does anyone here listen to podcasts a lot? im thinking once a week use Yahoo's search service and go out and collect new podcasts and then instead just rank on most clicked.
20:04:06 <Ralith> the runtime-loaded code won't be calling anything that's not already built into the binary
20:04:25 <gwern> Ralith: are you sure? I'm not sure even the prelude is built in
20:04:49 <Ralith> gwern: ldd tells me it doesn't dynamically load anything at all.
20:05:39 <gwern> and iirc you need a path to the ghc library directory just to even get in the ghc monad, although hint covers this up with use of the ghc-paths lib
20:06:24 <Ralith> so what's the absolute minimum I have to provide to get it to work, and how can I provide it w/o installing to the system?
20:08:14 <gwern> I don't think you really can
20:08:51 <Ralith> so it's impossible to use hint or similar without having root access on the target system to install ghc?
20:09:06 <gwern> you can install non-root...
20:09:07 <rovar> is there an append for [] ?
20:09:18 <gwern> ++ ?
20:09:26 <rovar> does that work with scalars?
20:09:33 <rovar> hoogle didn't mention it
20:09:37 <Ralith> gwern: then that's not really to the system.
20:09:47 <Ralith> rovar: it works with lists.
20:09:58 <rovar> i wish to append a scalar to a list
20:10:00 <ddarius> :t (++)
20:10:01 <lambdabot> forall a. [a] -> [a] -> [a]
20:10:11 <jeffwheeler> > [2..4] ++ [7]
20:10:12 <lambdabot>   [2,3,4,7]
20:10:14 <rovar> moh
20:10:18 <gwern> > [] ++ []
20:10:19 <lambdabot>   []
20:10:29 <gwern> > 5 : []
20:10:30 <lambdabot>   [5]
20:10:30 <Ralith> gwern: so what's the bare minimum I need to provide?
20:10:40 <rovar> is the compiler smart enough to remove the listOf ? I mean I'm converting something to a list so that I can add it to a list
20:10:48 <gwern> Ralith: your questions as formulated don't make sense to me, so I have no idea
20:10:51 <Ralith> if it can be installed as non-root, it can surely be installed in an arbitrary path, which means it can be packaged with the tool.
20:11:49 <Ralith> gwern: what do I need to do to make hint work on a system with nothing haskell-related on it, taking the most self-contained route possible at all times?
20:12:48 <gwern> you could do some dance with installing ghc to tmp/; then installing ghc-paths to tmp/ as well; then compiling your little hint-user against this tmp/ setup. but I've no idea whether ghc-paths does relative paths (probably doesn't), which could screw you up
20:14:03 <gwern> (you might be able to do something like loading all the modules from source, at which point you could distribute your binary with a directory of the source files)
20:14:44 <Ralith> 'all the modules' being everything that hint-loaded code imports?
20:14:58 <gwern> yes
20:15:41 <Ralith> no way to use any sort of prebuilt object file instead?
20:15:55 <gwern> if your desired evaluation is prelude-only, you might even be able to just include one file, at which point you could presumably do some trick (I know I've seen it in the past) to link the file into the binary itself
20:16:10 <gwern> dunno. the ghc api is a very complex and hairy and generally poorly understood beast
20:16:21 <Ralith> :/
20:16:26 <gwern> I've never even contemplated how to run a binary compiled on one box on another
20:16:39 <Ralith> that's kind of a common use case :P
20:17:05 <jedai> rittyan:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2749#a2756
20:17:23 <gwern> not really. most haskell users are compiling for their private use, and use of the ghc api is pretty rare
20:17:35 <jedai> rittyan : This is a tentative to make it more parallel
20:17:46 <gwern> off the top of my head, I can name just ghci, mueval, yi, and gitit
20:17:58 <Ralith> hm.
20:18:03 <jedai> rittyan : But really the important part now is the parsing of the lines
20:18:08 <Ralith> does cabal-install depend on ghc?
20:18:31 <jedai> rittyan: also don't forget to compile it with "ghc -02 -threaded --make ..."
20:18:33 <gwern> and ghci almost by definition wouldn't be used elsewhere, mueval is not of interest to anyone not running lambdabot, and ghc api use is optional and uncommon in yi and gitit - neither of which are particularly popular
20:18:33 <jeffwheeler> I think it's intended to work with other compilers; I don't know if it does.
20:18:40 <jeffwheeler> (cabal-install, that is)
20:18:56 <gwern> there's support, yes, but as jeffwheeler says, who knows how well nhc/yhc/jhc support it
20:19:00 <jedai> rittyan : and run it with the "+RTS -N4" option
20:19:07 <gwern> jeffwheeler: not that it matters - I mean, how many packages work with non-ghc?
20:19:26 <jeffwheeler> gwern: indeed, although I like the idea of jhc's thought of running on embedded systems
20:19:32 <jeffwheeler> might be neat to finally get it on the iPhone
20:20:17 <rittyan> jedai, won't it conflict with the getArgs function?
20:20:31 <gwern> jeffwheeler: a nice thought, but I don't put any hope in a 1-man compiler
20:20:33 <rovar> woo! it's alive! and passes all of its test cases!
20:20:44 <jedai> dons: Surprisingly, it seems Data.ByteString.Lazy.Char8 lacks a hPutStrLn
20:20:45 <rovar> I'm officially a Haskell Novice
20:20:47 <gwern> even if meachem has all of a sudden started working on it again
20:21:04 <jeffwheeler> gwern: I haven't played with it, and I don't know any of the context of the project
20:21:05 <rovar> just graduated from Haskell Peon
20:21:23 <jedai> rittyan: No, it's an instruction to the Haskell runtime (use 4 real threads) it won't make it to getArgs
20:21:28 <gwern> lhc was more promising, but there hasn't been a single commit in about 2 weeks. so definitely a case of over-enthusiasm
20:22:04 <jedai> rittyan: I would like to know if it makes a difference
20:22:36 <gwern> jeffwheeler: jhc is pretty old. and pretty neglected. in part because it can't compile anything interesting and what it can compile requires massive resource usage (I recall people mentioning that on small programs it could use over a gig of ram)
20:22:58 <jeffwheeler> gwern: that is the one that just came out with a release though, right?
20:23:17 <gwern> yes
20:23:40 <rittyan> jedai, i will try... however i will need to convert it to protocol buffers later
20:24:00 <jedai> protocol buffers ?
20:24:24 <gwern> google thing for fast serialized objects over the network
20:24:28 <rittyan> yes
20:24:34 <rittyan> except the "over the network" part
20:24:55 <rittyan> jedai, what package has this Concurrent.ThreadPool?
20:25:02 <rittyan> s/Concurrent/Control/
20:25:08 <jedai> Control-Engine
20:25:30 <jedai> cabal install Control-Engine should do the trick
20:25:45 <jedai> it isn't a big piece of software anyway
20:26:03 <rittyan> I am afraid of cabal... synce ghc-updater and other gentoo stuff won't know about it
20:26:04 <TomMD> No, its perhaps 100 lines
20:26:05 <rittyan> hmm~
20:27:09 <jedai> You can just put it in your project if you really don't want to install it (it's an user local installation by default though so you're not risking much)
20:27:47 <jedai> It's pure Haskell anyway, you can just download the archive and put the Haskell module in a Control/ directory
20:28:28 <rittyan> okay
20:28:49 <TomMD> jedai: You've used Control-Engine for a project?
20:29:17 <jedai> TomMD: Well it's not really my own and it was just threadPoolIO...
20:30:54 <jedai> rittyan: The function threadPoolIO itself is just 9 lines
20:31:19 <cocon> is there a way to type foldr instead of Foldable.foldr?
20:31:55 <rittyan> jedai, okay, I am runming the code
20:31:57 <jedai> cocon: Yes, you have to hide the foldr from the Prelude and import the foldr from Data.Foldable
20:31:58 <rittyan> *running
20:32:14 <cocon> thanks
20:32:42 <rittyan> jedai, same sh1t :) 112s
20:32:43 <jedai> rittyan: Note that if you only give it one file it won't really test the parallelism...
20:32:44 <rittyan> AHJ
20:32:49 <rittyan> I forgot to run it with the magic arguments
20:33:07 <jedai> rittyan: Don't forget to compile it with -threaded too
20:34:06 <rittyan> unknown RTS option: -N4
20:34:30 <jedai> rittyan: Did you compile it with -threaded ?
20:34:33 <rittyan> yes
20:34:44 <rittyan> % ghc seccheck.hs --make -threaded -O2
20:34:46 <rittyan> that's my command
20:35:20 <jedai> That's pretty strange, -Nn is a pretty normal RTS option
20:35:53 <tromp> :t split
20:35:54 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:36:03 <tromp> @hoogle split
20:36:04 <rittyan> jedai, it is not even in listing of help
20:36:04 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
20:36:04 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
20:36:04 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
20:36:22 <jedai> I really would like to have some sample so that I could run the bench here but I suppose it's confidential data ?
20:36:27 <tromp> hmm, i thought Data.List had a split
20:36:59 <tromp> @src words
20:37:00 <lambdabot> words s = case dropWhile isSpace s of
20:37:00 <lambdabot>     "" -> []
20:37:00 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:37:02 <jedai> rittyan: Try ghc -threaded -O2 --make seccheck.hs
20:37:07 <tromp> @src lines
20:37:08 <lambdabot> Source not found. My brain just exploded
20:37:10 <rittyan> jedai, I suppose it is a 600 megabyte file
20:37:36 <rittyan> jedai, the same
20:37:42 <jedai> rittyan: Send me just a portion of it
20:37:45 <rittyan> btw I am using 6.8.something
20:38:05 <jedai> I know but 6.8 shouldn't be a problem for that
20:38:34 <jedai> Are you sure it recompiled correctly, did you delete the old file ?
20:38:46 <Ralith> How do I tell cabal to install in a custom path?
20:38:56 <Ralith> via runhaskell Setup.hs
20:39:29 <jedai> Ralith: during the configure phase you can give it some options, try --help for more information
20:39:36 <Ralith> kk
20:39:40 <rittyan> jedai, ah, threadpool wasn't recompilled with the new options
20:40:15 <rittyan> yay, it works!
20:40:35 <rittyan> jedai, 13 seconds
20:40:43 <rittyan> (what!)
20:40:53 <jedai> That seems a little bit radical... Worrying
20:41:01 <rittyan> yes it doesn't match
20:41:08 <rittyan> or, wait
20:41:16 <jedai> check the content of the reports files
20:41:16 <rittyan> jedai, it matches
20:41:20 <rittyan> yup
20:41:25 <rittyan> forgot about them... it matches stuff
20:42:15 <jedai> If it really works then it's pretty good, no ? :)
20:42:31 <rittyan> ok it is not 13s :) the file was weirdly small
20:42:42 <rittyan> now I am processing two files at once
20:42:43 <jedai> Damn !
20:43:01 <rittyan> yeah, the site was down at that day or I have no ideas
20:44:17 <rittyan> jedai, watching at htop, 4 threads don't keep my cores busy :)
20:44:37 <rittyan> even though I feel that system is less responsive, ouch
20:44:42 <edwardk> hrmm, can anyone think of a compelling reason against evaluating character-based monoids in parallel at the chunk level over lazy bytestrings?
20:44:44 <jedai> Well if you're only processing two files
20:45:03 <rittyan> jedai, nah it didn't match anything so I made it process a bit more files to be sure... because it is weird
20:45:16 <edwardk> :1
20:45:27 <edwardk> woops
20:45:42 <jedai> edwardk: No, that seems a good idea
20:45:57 <jedai> if it's really a character-based monoids
20:46:12 <edwardk> yeah
20:46:44 <edwardk> technically those are byte based monoids, i have a layer in between to upconvert using utf8 to let you run char based monoids on top ;)
20:47:13 <edwardk> so i should say can anyone thing of a compelling reason against evaluating Word8 based monoids in parallel at the chunk level over lazy bytestrings ;)
20:47:13 <rittyan> jedai, it matched a lot of stuff and was running for 165s
20:47:14 <rittyan> cool!
20:47:32 <edwardk> i'm thinking something like
20:47:37 <jedai> A lot of stuff being approximately ?
20:47:54 <jedai> To see if we're IO bounded or computation bounded
20:48:22 <rittyan> jedai, we just processed 5G of data
20:48:24 <rittyan> nine files
20:48:59 <jedai> 5G in 165s ==> 30MB/s
20:49:23 <rittyan> sounds ok to me
20:49:31 <rittyan> if you are talking about disk speed
20:49:32 <edwardk> digest = fold . parMap rwhnf digest . toChunk -- where the outer digest is for lazy bytestrings and the inner one is for strict
20:50:28 <edwardk> not sure that wins a whole heck of a lot, might need something stronger
20:50:54 <jedai> rittyan: Yep, not too bad, now we just have to do the real work, which will probably slows us to a crawl in the end... ;)
20:52:14 <rittyan> jedai, the real work is like... accessing a list by its index few times... accumulating somewhere (instead of hPut) reports... then dumping them to disk? it doesn't sound so performance-penalty-ful
20:52:20 <Ralith> I'm trying to install cabal, but I keep getting:
20:52:21 <Ralith> Setup.hs: Error: Could not find module: Distribution.Compiler with any suffix:
20:52:26 <Ralith> ["hi"]
20:54:36 <TomMD> So Distribution.Compiler wasn't compiled or the intermediate file is missing, humm.  I've heard of a similar problem in which a work-around was to compile the installer then run the binary.
20:59:10 <rittyan> jedai, I am thankful for your dedication... but, forgive me my sleepness, sun is shining (7am) and I can't do anything but sleep
21:01:11 <jedai> rittyan: Yeah, it's 5am over here and I think sleep is a wonderful idea too...
21:01:19 <jedai> Good... day ^^
21:01:59 <rittyan> same to you o/
21:03:30 <quaggoth> anyone know a good networking tutorial? currently just fumbling through the APIs
21:05:38 <ImInYourMonad> murder :: Person -> Weapon -> Time -> Death; murder Lambdabot Axe Now
21:05:42 <TomMD> quaggoth: Use Beejees guide.
21:06:13 <TomMD> ImInYourMonad: Murder should be a type class with at least three parameters, not a function.
21:06:44 <fsanches> what has poor lambdabot done to deserve such a horrible death? =(
21:07:07 <ImInYourMonad> its a verb not a noun
21:07:44 <TomMD> quaggoth: its C specific, but berkeley sockets are berkeley sockets.  See http://beej.us/guide/bgnet/
21:08:00 * TomMD Runs off to play
21:08:13 <ImInYourMonad> murder :: Person -> Weapon -> Time -> Motive -> Death; murder Lambdabot Axe Now Arrogance
21:08:38 <quaggoth> TomMD: Thanks :)
21:08:43 <fsanches> ImInYourMonad, oh, much better now.
21:11:30 <Gracenotes> :o
21:11:35 <rovar> i think I may have a problem with laziness in Data.Binary.Put
21:12:07 <rovar> i call:  let _ = mapM_ putBSONElement o
21:12:36 <rovar> the net effect of that call is that a bunch of put* calls are made.
21:12:50 <rovar> but since I'm not using _, I don'th think the list is actually being generated.
21:13:12 <rovar> anyone know a way to ensure that mapM_ putBSONElement o   gets run?
21:16:26 <Axman6> seq?
21:16:45 <mikem`> hi, what does the variable "id" mean in a function? as in the first comment here: http://www.elbeno.com/haskell_soe_blog/?p=47
21:16:49 <jedai> rovar: This is a IO action, it shouldn't be in a let like that
21:16:56 <byorgey> rovar: why do you have the 'let _ =' ?
21:16:59 <mikem`> ah, id is a function itself
21:17:12 <Axman6> :t id
21:17:14 <lambdabot> forall a. a -> a
21:17:15 <jedai> mikem`: id is the identity function
21:17:16 <Axman6> @src id
21:17:16 <lambdabot> id x = x
21:17:19 <byorgey> rovar: just remove the let and it ought to work
21:17:39 <jedai> mikem`: it's useful sometimes
21:17:45 <mikem`> yep, it just dawned on me -- a second too late, though hehe
21:19:18 <rovar> yea i remove let _ =  and it works
21:19:20 <rovar> thanks
21:19:41 <rovar> not sure why I had that. I think I was mucking with some type related stuff earlier
21:20:52 <wy> Hi, is there a way to write two random number generators such that they generate disjoint sets of random numbers that cover the whole range?
21:21:32 <rovar> what's wrong with using a random number generator to generate 1 set and then separate it?
21:22:40 <wy> rovar: because it is too expensive to store them :)
21:23:42 <jedai> wy: Not to my knowledge, especially the "disjoint" part
21:23:56 <fsanches> wy: I guess you can't just use one generator for odd and other for even numbers
21:24:27 <wy> fsanches: If I know one set is odd and another is even, then they are not very random
21:24:43 <jedai> wy: except if you can project the elements from this set into two complimentary subsets I guess
21:24:50 <wy> the less we can know about them, the better
21:25:06 <fsanches> wy: yes, I agree. but if you know set A and set B are dusjoint, they aren't very random either.
21:25:14 <fsanches> I see
21:25:27 <jedai> wy: what you ask doesn't seem very compatible with "*randomness" either
21:25:47 <wy> jedai: hehe. I want to have this for a purpose
21:25:58 <fsanches> well, I have no idea on how to do this - It would require some heavy number theory, I think
21:26:17 <jedai> Well sure, but maybe you could achieve your goal without that instead
21:26:39 <wy> I want to make two sets of things such that it is impossible to have a function to tell you a number is in which set
21:26:55 <jedai> Because I don't think what you want is even really possible without compromising the "randomness" of your generators
21:27:40 <kerlo> I think it sounds simple enough.
21:28:07 <jedai> wy: then you can keep the set of things already produced by the generators and only accept a newly generated number if it isn't in this set
21:28:08 <kerlo> Well, I just realized that my one thought reduces trivially to my other thought.
21:28:11 <rovar> you make a random number generator which inserts numbers into 1 of two lists, the decision of into which list you insert is also random
21:28:49 <kerlo> Find a random function that maps from the range to itself.
21:28:58 <kerlo> (Assuming that it's a range of integers or something.)
21:29:00 <jedai> rovar: You realize that random generators sometimes repeat themselves ? They wouldn't be random if they didn't
21:29:09 <rovar> but since you wish to cover the whole range.. you just need [1..]
21:29:18 <rovar> [1..n]
21:29:27 <rovar> then randomly place into a list from that..
21:29:50 <pstickne> if the PRNG is, well, P, why do the operations on the results do more than add obscurity?
21:30:18 <pstickne> and if it's not P, what does it add?
21:30:53 <kerlo> Alternatively, come up with a random filter.
21:30:56 <jedai> partitions ((== 1) . fst) . zip (randomRs (0,1) gen) $ [1..n]
21:31:23 <jedai> Or something like that ?
21:31:31 <kerlo> filter (odd . shaHash . perturb) rands
21:32:42 <mikem`> can someone help me understand how the third comment is the equivalent of the original function at the top? http://www.elbeno.com/haskell_soe_blog/?p=47
21:33:05 <Gracenotes> jedai: looks good :)
21:34:10 <Gracenotes> > foldr (.) id [(+1), (*2), (negate)] $ a
21:34:11 <lambdabot>   negate a * 2 + 1
21:34:29 <Gracenotes> > foldr (.) id [negate, (*2), (+1)] $ a
21:34:30 <lambdabot>   negate ((a + 1) * 2)
21:34:52 <jedai> let cut gen n = (map snd *** map snd) . partition ((==1) . fst) . zip (randomRs (0,1::Int) gen) $ [1..n]
21:35:37 <mikem`> Gracenotes: so id is being applied to what, the list? actually, i guess I'm having trouble understanding what are the arguments to foldr in these cases
21:36:03 <Gracenotes> it's a list of functions
21:36:13 <JsutiN> Gracenotes, how is lambdabot just spitting back an expression without complaining about a not being defined?
21:36:23 <Gracenotes> in the latter case, it makes a function (negate  . (*2) . (+1)) composed from the list
21:36:27 <jedai> mikem`: In fact foldr just construct a composition of the functions in the list
21:36:28 <Gracenotes> > (negate  . (*2) . (+1)) a
21:36:29 <lambdabot>   negate ((a + 1) * 2)
21:37:10 <jedai> JsutiN: Magic ! (Not really, there's some Typeclass trickery at play here, you can find an explanation somewhere on the web)
21:37:12 <Gracenotes> this is the same as first applying (+1), then applying (*2), then applying negate, as the function in the blog post does
21:37:59 <mikem`> jedai: aha i think i get it
21:38:02 <Gracenotes> @src foldr
21:38:02 <lambdabot> foldr f z []     = z
21:38:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:38:09 <JsutiN> jedai, I've been looking (not very hard) for a way to get Haskell to just spit out simplified symbolic expressions, so this interests me.
21:38:27 <Gracenotes> mikem`: in this case the function f is (.)
21:38:28 <mikem`> so foldr takes three arguments, (.), id and [...], which returns a composition of functions. that composition of functions is then applied to a
21:38:44 <psygnisfive> wait wait so lambdabot isnt bitching about a not being bound for WHAT reason, exactly?
21:38:47 <psygnisfive> > a + b
21:38:48 <lambdabot>   a + b
21:38:56 <psygnisfive> ...
21:38:56 <Gracenotes> @type a
21:38:57 <lambdabot> Expr
21:38:58 <psygnisfive> ::shifty eyes::
21:39:18 <Gracenotes> from Debug.SimpleReflect
21:39:20 <jedai> psygnisfive: Because a is bound, in the environment that comes with lambdabot, a is bound to something like Var "a"
21:39:39 <psygnisfive> ::shiftier eyes::
21:40:02 <psygnisfive> adimit runs lambdabot right?
21:40:03 <jedai> Which is an instance of a certain number of nifty typeclass that gives the illusions that symbolic computation happens
21:40:30 <JsutiN> That is seriously cool.
21:40:48 <mikem`> > foldr (.) id [(+1), (*2), (negate)]
21:40:49 <lambdabot>       Overlapping instances for Show (a -> a)
21:40:50 <lambdabot>        arising from a use of `s...
21:40:57 <mikem`> > foldr (.) id [(+1), (*2), (negate)] $ a
21:40:59 <lambdabot>   negate a * 2 + 1
21:41:24 <JsutiN> > (1 + a)^2
21:41:26 <lambdabot>   (1 + a) * (1 + a)
21:41:36 <JsutiN> > reduction $ (1 + a)^2
21:41:37 <lambdabot>   Not in scope: `reduction'
21:41:49 <Gracenotes> > let applyAll [] = id; applyAll (f:fs) = f . applyAll fs in applyAll [(+1), (*2), (negate)] a
21:41:50 <lambdabot>   negate a * 2 + 1
21:42:05 <Gracenotes> that's what applyAll looks like if written more like the foldr
21:42:08 <Gracenotes> @src foldr
21:42:08 <lambdabot> foldr f z []     = z
21:42:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:42:15 <Gracenotes> in this case z is id, and f is (.)
21:42:20 <jedai> JsutiN: There's even a way to make apparent the sharing (it's impure of course)
21:42:31 <jedai> > (a + 1) ^ 4
21:42:32 <lambdabot>   (a + 1) * (a + 1) * ((a + 1) * (a + 1))
21:42:58 <jedai> JsutiN: But I must admit I don't remember the magic word
21:43:50 <psygnisfive> thats an only thing to return for ..^4
21:43:50 <psygnisfive> hmm
21:43:51 <JsutiN> Hm.  Why is "reduction" not in scope if the Debug.SimpleReflect library is loaded?
21:43:53 <psygnisfive> whats the definition for ^?
21:44:00 <Gracenotes> > let value = foldr (.) id [(+1), (*2), (negate)] $ 10 in iterate reduce value
21:44:01 <lambdabot>   [negate 10 * 2 + 1,(-10) * 2 + 1,-20 + 1,-19,-19,-19,-19,-19,-19,-19,-19,-1...
21:44:13 <Gracenotes> ^ shows the evaluation as a list
21:44:40 <mikem`> Gracenotes: ok, I think I get it. It'll probably take a little to completely sink in, but I think I know what's happening :) thanks!
21:45:25 <Gracenotes> > iterate reduce (foldr (+) 0 [1, 2, 3])
21:45:27 <lambdabot>   [1 + (2 + (3 + 0)),1 + (2 + 3),1 + 5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
21:45:35 <Gracenotes> > iterate reduce (foldr (+) 0 [1, 2, 3, 4, 5])
21:45:36 <lambdabot>   [1 + (2 + (3 + (4 + (5 + 0)))),1 + (2 + (3 + (4 + 5))),1 + (2 + (3 + 9)),1 ...
21:45:46 <Gracenotes> > iterate reduce (foldl (+) 0 [1, 2, 3, 4, 5])
21:45:48 <lambdabot>   [0 + 1 + 2 + 3 + 4 + 5,1 + 2 + 3 + 4 + 5,3 + 3 + 4 + 5,6 + 4 + 5,10 + 5,15,...
21:46:19 <Gracenotes> :)
21:46:25 <mikem`> can i run reduce in GHC?
21:46:28 <mikem`> er, GHCi?
21:47:21 <Gracenotes> it's from the Hackage packge simple-reflect
21:47:43 <Gracenotes> which you can install with the cabal installer (which must be first installed, though)
21:48:04 <Gracenotes> @where cabal
21:48:04 <lambdabot> http://www.haskell.org/cabal
21:48:21 <mikem`> Gracenotes: I installed that earlier today :) so this'll be the first package I install this way
21:49:05 <JsutiN> > reduction $ (1 + a)^4
21:49:07 <lambdabot>   Not in scope: `reduction'
21:49:13 <JsutiN> > reduce $ (1 + a)^4
21:49:14 <lambdabot>   (1 + a) * (1 + a) * ((1 + a) * (1 + a))
21:49:16 <JsutiN> Hm.
21:49:38 <mikem`> @where simple-reflect
21:49:38 <lambdabot> I know nothing about simple-reflect.
21:49:47 <Gracenotes> it can't reduce 1 + a, because that's as simple as it's gonna get. it's not very flexible in terms of symbolic manipulation
21:50:10 <Gracenotes> > iterate reduce $ (1 + 2)^3
21:50:11 <lambdabot>   [(1 + 2) * (1 + 2) * (1 + 2),3 * (1 + 2) * (1 + 2),3 * 3 * (1 + 2),9 * (1 +...
21:50:52 <JsutiN> Well I meant that the documentation for simple-reflect seems to contain a function "reduction" that does the full derivation, but it's not loaded here.
21:51:02 <Gracenotes> that isn't actually how exponentiation works for Ints or Integers either :x
21:52:13 <Gracenotes> yeah, not sure why reduction is missing
21:53:23 <jedai> Gracenotes: Maybe the version of SimpleReflect is just a little old
21:54:08 <jedai> Also there is Debug.Traced which can keep the sharing and so show the real way exponentiation (for instance) is evaluated
21:54:43 <mikem`> Gracenotes: ok, this is making sense. thanks!
21:55:32 <Gracenotes> yay :)
21:58:07 <jedai> Example of Debug.Traced output :
21:59:42 <jedai> showAsExp . reShare $ 5 ^ 7
21:59:42 <jedai> "let _2 = 5 * 5; _1 = _2 * _2; _3 = _2 * 5; _0 = _1 * _3; in  _0"
22:00:19 <Gracenotes> I knew 2 was 5*5!
22:00:34 <jedai> In this you can clearly see that (^) share a lot of the computation, while Debug.SimpleReflect don't really show it :
22:00:51 <jedai> > a ^ 7
22:00:53 <lambdabot>   a * a * (a * a) * (a * a * a)
22:01:24 <jedai> Gracenotes: Ok, the names of the variables aren't very sexy... ^^
22:02:29 <Gracenotes> @. run run text $ "let a = 5 in " ++ show (a ^ 7)
22:02:31 <lambdabot>   78125
22:07:27 <Gracenotes> blah> showAsExp . reShare $ 1
22:07:29 <Gracenotes> "let in  1"
22:07:56 <Gracenotes> hrm! surprisingly, syntactically correct
22:09:29 <Elly> should it not be?
22:09:56 <asdfqwer> Does M1 and M2 @ http://en.wikipedia.org/wiki/Lambda_calculus#Substitution basically represent an occurance of x?
22:09:58 <Gracenotes> well, ungrammatical :) other than that, no reason
22:10:27 * asdfqwer is trying to learn how lambda works in programs
22:10:40 <asdfqwer> so ##math told me to come here
22:10:44 <Gracenotes> in the lambda calculus, "M1 M2" is syntax for applying M2 to M1
22:10:50 <asdfqwer> go to #haskell, those fan boys are so rabid they would, to a (nominal) man, stand in line 3 weeks without showering to see "Haskell the Movie". um, the not showering isn
22:10:59 <Gracenotes> :\
22:11:00 <asdfqwer> Oh ok.
22:11:05 <Gracenotes> > negate 10
22:11:06 <lambdabot>   -10
22:11:11 <asdfqwer> lol
22:11:11 <Elly> did they say anything about the fangirls? :P
22:11:14 <Gracenotes> so M1 is negate, M2 is 10
22:12:03 <asdfqwer> Gracenotes, so basically it says [operate on] [this]
22:12:07 <asdfqwer> ?
22:12:57 <Gracenotes> yes. The substitution operation in the wikipedia article means taking an application, and changing the internals so that a substitution occurs
22:14:08 <rovar> i'm getting a non-exhaustive patterns in function error. is there any way I can debug what pattern it's failing to match?
22:14:30 <rovar> it's based on a GADT, not sure how to do a catchall for that
22:14:44 <Gracenotes> asdfqwer: basically there are only three things you can do in the untyped lambda calculus: using a variable, making a 'lambda abstraction' from a variable to an expression, and applying an expression to an expression
22:15:43 <jedai> rovar: Well _ or x still catch everything
22:16:00 <solidsnack> rovar: It isn't printing out the unmatched patterns?
22:16:13 <Gracenotes> and Google has no information on showtimes for Haskell the Movie! Shame! :P
22:16:49 <jedai> rovar: Normally it should print what patterns isn't caught though IIRC
22:17:17 <rovar> *** Exception: BSONValues.hs:(103,0)-(113,47): Non-exhaustive patterns in function putElementType
22:17:45 <michaelcdever> hey all, im having a problem with hGetContents, basically what i want to do is get the contents of a file, split it to words then search it for a pattern, now if i do it line by line via ghci it works, but when i put it into a function, it doesn't work
22:17:49 <michaelcdever> any ideas?
22:17:56 <jedai> rovar: Apparently not, well if you have a Show instance, you can use error and a catch all to show what's missing
22:18:05 <solidsnack> michaelcdever: Ah, yes.
22:18:06 <rovar> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1959#a1960
22:18:24 <solidsnack> michaelcdever: Please paste bin the code you are trying to use.
22:18:32 <Gracenotes> rovar: oh, you want to see what matching you're missing?
22:18:42 <solidsnack> You are about to discover what the IO monad is for.
22:18:43 <Gracenotes> try the -Wall command line option
22:18:50 <rovar> kay
22:18:51 <Gracenotes> like gcc's
22:19:01 <rovar> can I start up ghci with it?
22:19:02 <michaelcdever> solidsnack: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2757
22:19:36 <Gracenotes> rovar: yeah. It'll (possibly) complain if you load a file, about some other potential errors as well
22:19:48 <Gracenotes> for instance, loading a file with just r 0 = "blah"
22:19:53 <solidsnack> michaelcdever: Okay, seems fine.
22:19:56 <Gracenotes> Warning: Pattern match(es) are non-exhaustive in the definition of `r': Patterns not matched: #x with #x `notElem` [0#]
22:20:03 <solidsnack> When you say it doesn't work, what is happening?
22:20:26 <michaelcdever> if i type the lines into ghci, with a pattern, one by one, it returns true
22:20:32 <michaelcdever> in the exact same order
22:20:40 <TomMD> michaelcdever: What error are you getting?  I think you need to introduce some strictness.
22:20:50 <michaelcdever> but if i try to call checkFile it returns False
22:21:02 <TomMD> michaelcdever: let !b = ...
22:21:06 <michaelcdever> calling checkFile with the exact same pattern
22:21:15 <rovar> jedai: when I try to add a catchall with x, it errors as indicated in the paste
22:21:16 <michaelcdever> but it shouldn't be !b
22:21:22 <TomMD> michaelcdever: Otherwise the handle will close before you desire.
22:21:27 <solidsnack> Oh, you are closing the handle.
22:21:30 <TomMD> Yep
22:21:36 <TomMD> That is why I'm suggesting the bang pattern.
22:21:37 <rovar> actually.. i know why that is..
22:21:37 <jedai> michaelcdever: replace your searchFile by "any (=~ pattern)"
22:21:41 <michaelcdever> i close the handle after i do the search though?
22:21:51 <TomMD> michaelcdever: Haskell is Lazy
22:21:52 <solidsnack> michaelcdever: Well, no.
22:22:17 <solidsnack> b is evaluated at the return statement
22:22:24 <TomMD> michaelcdever: You open the file, construct a thunk, close the file... then some day try and evaluate the thunk and it fails.
22:22:42 <michaelcdever> i know its lazy, but when it's being compiled/interpreted, shouldn't it realise that i need the result of b later on?
22:22:42 * solidsnack Says statement with "air quotes".
22:23:22 <michaelcdever> jedai: whats this any?
22:23:22 <TomMD> michaelcdever: It doesn't, add the bang pattern and all will be well.
22:23:39 <asdfqwer> Gracenotes, does making a 'lambda abstraction' essentially mean storing a lambda expression into memory?
22:23:42 <jedai> michaelcdever: No, you shouldn't close the handle, hGetContents will close it for you once it has read to the EOF
22:24:19 <TomMD> Ah yes, that too - I always forget that.
22:24:23 <michaelcdever> so, tom will !b still = True cause it has found the pattern, or because !False = True?
22:24:45 <michaelcdever> but jedai, it doesn't neccessarily read to EOF, so then it wouldn't close the file
22:24:48 <jedai> michaelcdever: Though here the bang pattern is better
22:25:03 <jedai> Yes it doesn't always goes to the EOF I agree
22:25:21 <Gracenotes> asdfqwer: it's declaring an anonymous function that takes a single argument, and returns something else, possibly using that argument. Since you don't know what the argument will be, it'll have to be in memory, I suppose, like a function in most other languages.
22:25:32 <jedai> michaelcdever: any is a function from Data.List :
22:25:36 <michaelcdever> so, i need to close it explicitly, because otherwise i get a too many open files error in my search
22:25:37 <jedai> @type any
22:25:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:25:54 <TomMD> michaelcdever: ! is not the 'not' operator, but a strictness value.
22:26:02 <TomMD> err, symbol.
22:26:07 <jedai> "any p xs" is True is p is true for at least one element of xs
22:26:12 <TomMD> @where bangpatterns
22:26:12 <lambdabot> I know nothing about bangpatterns.
22:26:18 <michaelcdever> ah! I see
22:26:19 <TomMD> @google Haskell bange patterns
22:26:19 <lambdabot> No Result Found.
22:26:26 <TomMD> @google Haskell bang patterns
22:26:28 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
22:26:28 <lambdabot> Title: 8.11.Bang patterns
22:26:30 <TomMD> there
22:26:37 <michaelcdever> so it means evaluate it here?
22:26:41 <TomMD> Yes
22:27:20 <michaelcdever> and it says there i need to enable a flag for it?
22:27:58 <Gracenotes> asdfqwer: I mean, you could simply \x . y, assuming y is a simple variable, to just 'y'. When evaluating, though, there are quite a few options. You can evaluate the arguments before looking at the insides of the function (like most imperative languages), in a left-to-right order (Java) or unspecified (C); evaluating them when they're first named in the function or when they're needed...
22:28:00 <michaelcdever> ah ok, i dont
22:28:00 <Gracenotes> ...(Haskell)... Wikipedia has an article about evaluation strategies
22:28:56 <Gracenotes> *simplify
22:29:04 <jedai> michaelcdever: You could use withFile instead of this open/close pair, it would be a bit more beautiful I think
22:30:17 <michaelcdever> whats withFile?
22:31:01 <jedai> michaelcdever: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2757#a2758
22:31:15 <jedai> withFile is in System.IO
22:32:31 <asdfqwer> Gracenotes, Yeah I'm sort of going about this to generally, but it seems like each lambda expression behaves much like a function stored as, something like, a macro
22:32:36 <michaelcdever> ah ok, have it here
22:33:11 <asdfqwer> except that accepts other *macros* or variables as arguments
22:33:44 <asdfqwer> i could very well be way off base, but i'm just sorta thinking aloud
22:34:04 <Gracenotes> that makes sense. not to mention, something in the lambda calculus doesn't have to accept all of its arguments for it to be completely evaluated.
22:34:08 <michaelcdever> thanks jedai
22:34:10 <jedai> michaelcdever: There are a certain number of those "with*" functions around, they handle the resource management and ensures the proper release of the resource after their use, even if there are exceptions.
22:34:27 <Gracenotes> because, well, there's no real notion of multi-arguments in the lambda calculus
22:34:40 <Gracenotes> multi-argument functions, that is. Just one-argument functions nested on top of each other.
22:34:47 <mmorrow> @src bracket
22:34:47 <lambdabot> bracket before after thing = block $ do
22:34:47 <lambdabot>     a <- before
22:34:47 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
22:34:47 <lambdabot>     after a
22:34:47 <lambdabot>     return r
22:34:51 <Gracenotes> the same's true in Haskell
22:35:01 <asdfqwer> cool
22:35:08 <asdfqwer> to be continued tho
22:35:12 <asdfqwer> bbl
22:35:15 <Gracenotes> see ya
22:36:03 <jedai> michaelcdever: Also ($!) will ensures that the result is evaluted before the file is closed, it doesn't any extension
22:36:17 <jedai> it's just an operator defined in the Prelude
22:36:58 <mmorrow> @src ($!)
22:36:59 <lambdabot> f $! x = x `seq` f x
22:37:09 <Gracenotes> do { contents <- readFile "/dev/zero"; putStrLn $! contents }
22:37:14 <Gracenotes> ^ good luck with that >_>
22:37:32 * JsutiN chuckles.
22:37:47 <mmorrow> cat /dev/urandom | od
22:38:00 <mmorrow> # screensaver
22:39:28 <Gracenotes> although, 'readFile "/dev/zero" >>= putStrLn' hangs forever
22:40:00 <michaelcdever> ah ok jedai, but like i said, im writing a recursive search so i can't leave files open, or it crashes, so I need to close the files!
22:40:16 <Gracenotes> mmorrow: what'll they think of next? asciiview slide shows?
22:40:20 <mmorrow> Gracenotes: um, it works for me
22:40:33 <mmorrow> $ ghc -e 'readFile "/dev/urandom" >>= putStrLn' | od
22:40:44 <Gracenotes> in ghci, at least
22:40:48 <michaelcdever> ahh silly me, missed the bit about withFile closing the handle
22:40:58 <mmorrow> why would compiled code be any different?
22:41:06 <Gracenotes> mmorrow: urandom works fine in ghci, not zero though
22:41:30 <mmorrow> Gracenotes: heh, i think it's working but '\0' is just invisible!
22:41:41 <Gracenotes> aha! good point :)
22:41:45 <mmorrow> hehe
22:42:00 <Gracenotes> adding ". show" works nicely
22:42:12 <mmorrow> @src print
22:42:12 <lambdabot> print x = putStrLn (show x)
22:42:16 <mmorrow> ;)
22:42:18 <Gracenotes> that too
22:42:47 <Gracenotes> I already have a solution with putStrLn, there's no need to implement a switch like that with my current funding
22:44:19 <mmorrow> geez, this solid-state harddrive is lightning fast
22:44:35 <centrinia> @pl \x -> putStrLn (show x)
22:44:35 <lambdabot> putStrLn . show
22:46:06 <Gracenotes> @. pl src isInfixOf
22:46:06 <lambdabot> (line 1, column 1):
22:46:06 <lambdabot> unexpected end of input
22:46:06 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:46:10 <Gracenotes> :x
22:46:38 <Gracenotes> @src isInfixOf
22:46:38 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
22:46:45 <Gracenotes> @pl isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
22:46:46 <lambdabot> isInfixOf = (. tails) . any . isPrefixOf
22:46:56 <Gracenotes> hrm. mmhrm.
22:47:22 <Gracenotes> @. pl src print
22:47:23 <lambdabot> (line 1, column 1):
22:47:23 <lambdabot> unexpected end of input
22:47:23 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:47:44 <Gracenotes> oddish.
22:48:03 <jedai> michaelcdever: withFile close the file for you, better than you
22:48:20 <dons> cumulative hackage downloads since hackage went live, http://galois.com/~dons/hackage/hackage.png
22:48:33 <dons> i.e. people typing 'cabal-install' (for the last few months), or manually downloading
22:48:39 <jedai> michaelcdever: and I missed the bit where you found that out...
22:50:21 <jre21> has anyone used Gema (http://gema.sourceforge.net/new/index.shtml) for parsing haskell? particularly the blocks by indentation (eg where, case, etc)
22:50:29 <jedai> dons: We can probably consider that hackage is a success :)
22:51:31 <TomMD>  Soon to be a bandwidth issue - we could use a P2P solution imo.
22:52:39 <michaelcdever> i used hackage for the first time today :d
22:53:00 <michaelcdever> sorry, no i used it before, but didn't know i was using i
22:53:05 <dons> i think it's go exponential once cabal-install hits every distro
22:53:18 <dons> then there'll be a period where it will be easy to try things, but they won't have distro packages
22:53:28 <dons> we need a cabal-install alongside every ghc
22:53:42 <dons> it's still kind of boggling that cabal-install isn't packaged everywhere.
22:54:04 <michaelcdever> cabal-install is a great tool tbh
22:54:09 <ImInYourMonad> from __future__ import haskell
22:54:31 <michaelcdever> its good to have a uniform tool for installing packages on all distros, cuts out a lot of hassle
22:55:41 <Elly> > a ^ 12
22:55:42 <lambdabot>   a * a * (a * a) * (a * a * (a * a)) * (a * a * (a * a))
22:55:58 <Elly> aw, I thought it was doing fibbonaci expansion :P
22:56:32 <jedai> Elly: What do you mean fibonnaci expansion ?
22:56:54 <jedai> Do you want to see the sharing in this expression ?
22:57:00 <Elly> a * a * (a * a) * (a * a * a) * ((a * a) * (a * a * a))
22:57:04 <Elly> or something similar to that
22:57:17 <TomMD> Alright, "cabal install happstack" using ghc-6.10.2-rc1 :-)
22:57:22 <jedai> In this case you have to use Debug.Traced
22:57:27 <TomMD> Not done, but progressing nicely.
22:57:32 <Gracenotes> Elly: powers of two are quite convenient
22:57:56 <jedai> Elly: (^) use the classic algorithm, it works quite well even if it's not optimal
22:58:06 <Elly> I have no idea if the fib expansion is optimal
22:58:09 <jedai> @src Int (^)
22:58:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:59:14 <jedai> Elly: It isn't, I think the optimal algorithm is still a mistery (well we can always find an optimal solution we just don't have a systematic algorithm that would generate this solution without exploring the space of solution)
23:00:35 <Gracenotes> this is how GHC does it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=2759#a2759
23:00:37 <Gracenotes> (^)
23:01:19 <Elly> jedai: wait, really? o_O
23:01:27 <Elly> actually, I guess that makes sense
23:01:36 <Elly> given that the optimal algorithm for integer multiplication is still unknown
23:03:03 <centrinia> I thought the optimal addition chain is only twice as good as the base two log of the target.
23:03:34 <Gracenotes> #multiplications = log base 2 + the number of 1s in the binary string
23:03:51 <Gracenotes> somewhere around
23:09:17 <michaelcdever> right, night all, thanks for the help.
23:10:28 <TomMD> dcoutts: Ping
23:20:26 <ImInYourMonad> http://images.google.com/images?hl=en&q=simon+peyton+jones&btnG=Search+Images&gbv=2 <- look it is simon peyton jones everywhere!
23:22:03 <dons> i think hackage is behaving like a "new market" displaying a classic long tail of use.
23:25:16 <Elly> dons: hm?
23:26:09 <xpika> how do i get > map 1 [(+1),(-1)] to work?
23:26:33 <centrinia> xpika, What do you want to do?
23:26:50 <xpika> map 1 to multiple  functions
23:26:59 <centrinia> You could have (map (+ 1) [1,-1])
23:27:08 <centrinia> (map 1) really doesn't make sense.
23:27:29 <jml> xpika: you mean apply multiple functions to a single value?
23:28:13 <xpika> jml: yes
23:28:30 <centrinia> > map (\x -> x 1) [+1, subtract 1]
23:28:31 <lambdabot>   [2,0]
23:28:54 <Gracenotes> mm, -1 means negative one.
23:29:19 <dons> hackage downloads are pretty much obeying Zipf's law
23:30:40 <xpika> > map ($1) [(+1),(subtract 1)]
23:30:41 <lambdabot>   [2,0]
23:30:55 <xpika> i forgot the subtract
23:31:41 <_roconnor_> @wn quixotic
23:31:44 <lambdabot> *** "quixotic" wn "WordNet (r) 2.0"
23:31:44 <lambdabot> quixotic
23:31:44 <lambdabot>      adj : not sensible about practical matters; unrealistic; "as
23:31:44 <lambdabot>            quixotic as a restoration of medieval knighthood"; "a
23:31:44 <lambdabot>            romantic disregard for money"; "a wild-eyed dream of a
23:31:46 <lambdabot>            world state" [syn: {romantic}, {wild-eyed}]
23:35:56 * asdfqwer pokes Gracenotes 
23:36:02 <Gracenotes> hallo
23:36:03 <asdfqwer> Hey, have you heard of COLA
23:36:12 <Gracenotes> don't think so..?
23:36:14 <asdfqwer> http://en.wikipedia.org/wiki/COLA_(software_architecture)
23:36:43 <Gracenotes> never heard of, no
23:40:08 <ImInYourMonad> lol at cola
23:40:14 <ImInYourMonad> ghc ftw
23:40:33 <ImInYourMonad> spj will die unknown and be a legend in 100 years
23:42:37 <Gracenotes> :\
23:44:35 <dibblego> what's the website where you can execute source?
23:44:58 <ImInYourMonad> www.obamaa.com
23:45:02 <ImInYourMonad> www.obama.com
23:45:07 <ImInYourMonad> www.whitehouse.gov
23:45:35 <dibblego> oh yay, we have a dick head!
23:45:53 <Gracenotes> codepad
23:46:14 <ImInYourMonad> @faq can haskell put a needle in a d--k head and make it explode?
23:46:14 <lambdabot> The answer is: Yes! Haskell can do that.
23:46:15 <asdfqwer> cola reminds me of alan kay :D
23:46:16 <ImInYourMonad> ouch
23:46:25 <ImInYourMonad> it is done by alan kay...
23:46:50 <asdfqwer> really?
23:47:10 <asdfqwer> that would...explain why it...reminds me of him..?
23:47:51 <ImInYourMonad> http://en.wikipedia.org/wiki/COLA_(software_architecture)
23:47:57 <ImInYourMonad> http://vpri.org/html/work/ifnct.htm
23:48:28 <asdfqwer> Ah yes, and the Viewpoints reference
23:48:45 <asdfqwer> :O
23:49:06 * asdfqwer is sucha noob
23:49:24 <ImInYourMonad> who woudl win in a fight to the death between spj and alan kay?
23:50:08 <asdfqwer> hrm.
23:50:18 <asdfqwer> they should fight so we can find out.
23:50:44 <asdfqwer> i've never heard of spj until 10 seconds ago.
23:50:47 <ImInYourMonad> is spj ever on here?
23:50:53 <ddarius> Yes.
23:50:56 <ImInYourMonad> simon  peyton jones
23:51:37 <asdfqwer> does he have any lectures or demos available online?
23:51:44 <ddarius> Yes.
23:51:55 <TomMD> Lots
23:52:02 <xpika> how do i find the height of a character in xlib
23:52:24 <asdfqwer> ddarius, TomMD thanks google ;)
23:52:49 <pumpkin> thoughtpolice: yo!
23:53:34 <asdfqwer> http://www.youtube.com/results?search_type=&search_query=simon+peyton+jones
23:53:39 <asdfqwer> spj is adorable
23:54:17 <xpika> spj++
23:54:51 <solidsnack> I think SPJ would never actually come on this channel.
23:54:52 <dons> huh. i think i can quantify the "distro effect". we can actually see where a packages download popularity drops once it becomes sufficiently popular, due to moving into the distros
23:55:02 <solidsnack> It would be too weird.
23:55:15 <solidsnack> dons: Interesting.
23:55:36 <solidsnack> What is the download rate for Haskell stuff? Thousands a month?
23:55:43 <dons> hang on ...
23:55:54 <solidsnack> We'd all be like, we love you SPJ.
23:56:10 <solidsnack> We'd @quote everything he says and all that.
23:56:55 <ivanm> solidsnack: IIRC, he's been here before...
23:56:58 <ivanm> @seen sjp
23:56:58 <lambdabot> I haven't seen sjp.
23:57:00 <ivanm> @see spj
23:57:01 <lambdabot> I haven't seen spj.
23:57:07 <ivanm> or not...
23:57:14 <solidsnack> ivanm: I heard that about a year and a half ago.
23:57:19 <Axman6> @quote spj
23:57:19 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:57:26 <Axman6> @quote spj
23:57:27 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:57:29 <centrinia> @seen pwadler
23:57:29 <lambdabot> I haven't seen pwadler.
23:57:30 <Axman6> :(
23:57:32 <solidsnack> However, I have **never** seen spj on here.
23:57:38 <dons> ddarius: around?
23:57:42 <ivanm> just very rarely
23:57:46 <solidsnack> @quote spj
23:57:46 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
23:57:51 <dons> ok. so here is the hackage download stats, we looked at earlier: Hackage, along with the Cabal infrastructure has been sponsored by Galois since it's inception. We use Cabal on most of our projects, and run our own Hackage instance internally.
23:57:55 <dons> For the community library hosting, we've noticed some interesting traffic growth over the past year or so, to hackage.haskell.org.
23:57:55 <solidsnack> @quote pwadler
23:57:55 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
23:57:58 <dons> grr.
23:58:05 <dons> http://galois.com/~dons/hackage/hackage.png
23:58:13 <dons> so that graph. which makes sense and looks fun
23:58:21 <dons> but now, if we rank packages by popularity,
23:58:28 <dons> http://galois.com/~dons/hackage/zipfs-law.png
23:58:31 <dons> we get a very interesting graph.
23:58:44 <ImInYourMonad> @seen spj
23:58:44 <lambdabot> I haven't seen spj.
23:58:46 <dons> double log scale since I thought it was a classic "long tail"
23:58:49 <ImInYourMonad> @seen SPJ
23:58:50 <lambdabot> I haven't seen SPJ.
23:58:58 <dons> but note how the popular end of the graph flattens out?
23:59:06 <dons> i.e. xmonad, pandoc et al, all move into distros
23:59:16 <dons> so they are downloaded less often than a classic long tail would predict
23:59:25 <Gracenotes> preflex: seen spj
23:59:26 <preflex>  Sorry, I haven't seen spj
23:59:35 <dons> guys, spj isn't here. stop asking for him.
23:59:41 <Gracenotes> :)
23:59:53 <mmorrow> setting up a new computer is such a pita
