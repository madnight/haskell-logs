00:16:08 <Prpl> Anyone know of any good books from the eighteenth century (1700's)?
00:17:15 <mmorrow> "Teach yourself Windows(R) 3.1(R) in 24 Hours"?
00:17:22 <smtms> Prpl, mathematical books?
00:17:30 <Gracenotes> oh, I have a midterm tomorrow
00:17:33 <Gracenotes> better not oversleep
00:18:09 <mmorrow> doctormach: i wouldn't think so. maybe it's a bug in vacuum-cairo?
00:18:37 <mmorrow> doctormach: err, what do you mean "cycles through" ?
00:18:47 <Prpl> Any, smtms.
00:19:19 <Prpl> I know of Edward Cocker.
00:19:46 <mmorrow> Prpl: if my life depended on an answer to your question, i'd be so dead.
00:20:30 <Prpl> lol
00:21:22 <Prpl> I wasn't aware they had Windows back then though. :p
00:23:29 <mmorrow> doctormach: hmm, it seems to work ok here.
00:23:50 <mmorrow> Prpl: ;)
00:26:56 <mmorrow> doctormach: oh, i think i might know what you mean now. it looks like a minor bug somewhere in the rendering.
00:37:32 <pumpkin> alright, I have a graph and a fractal, and I need a third image that says "computer science" and that (please) has nothing to do with strings ones and zeros or computer screens :)
00:37:35 <pumpkin> the glider would be nice but I can't get it to look right
00:38:21 <pumpkin> any ideas?
00:38:48 <pumpkin> I'm tempted to just put a tree in and go to sleep, but I already have a graph and it feels cheap
00:40:59 <pumpkin> interesting, wikipedia lists category theory as a subfield of computer science in http://en.wikipedia.org/wiki/Computer_science
00:41:49 <smtms> isn't it?
00:42:39 <pumpkin> it seemed a bit like a theory of functions/structures/everything to me, but it can certainly apply to CS among other things
00:43:41 <doctormach> mmorrow: It seems to drop the last element each time until it's just drawing the first, then it draws the complete list
00:45:25 <mmorrow> doctormach: yeah, it's weird. i think it's a bug somewhere in the rendering of the .svg to the gtk canvas or something. i'd give dons an @tell or something about it.
00:45:44 <dobblego> lambdabot's src nubBy is incorrect
00:45:59 <mmorrow> doctormach: it seems to happen with most everything in one way or another
00:46:24 <mmorrow> dobblego: @src just reads some txt file in the lambdabot repo
00:46:40 <dobblego> or maybe it isn't
00:46:57 <dobblego> > nubBy (==) ['a', 'a', 'b', 'b', 'a', 'a', 'c'] -- ['a', 'b', 'a', 'c'] ?
00:46:59 <lambdabot>   "abc"
00:48:19 <pumpkin> that matches my ghci
00:48:36 <dobblego> I thought nub did something else
00:48:39 <mmorrow> dobblego: hmm, maybe it reads its data from somewhere else now actually (i can't seem to find the src file), but i'm pretty sure it's just some txt file
00:48:48 <dobblego> no, it's my mistake
00:48:53 <mmorrow> ah
00:48:53 <pumpkin> dobblego: like the uniq unix command?
00:48:58 <pumpkin> I assumed that too
00:49:24 <pumpkin> > map head . groupBy (==) $ ['a', 'a', 'b', 'b', 'a', 'a', 'c'
00:49:25 <lambdabot>   <no location info>: parse error on input `;'
00:49:26 <Twey> uniq = unlines . nub . lines
00:49:26 <pumpkin> > map head . groupBy (==) $ ['a', 'a', 'b', 'b', 'a', 'a', 'c']
00:49:27 <lambdabot>   "abac"
00:49:28 <Twey> Surely
00:49:35 <pumpkin> nope
00:49:39 <ejt> morning
00:49:44 <Twey> Or interact (unlines . nub . lines)
00:49:57 <pumpkin> uniq only removes adjacent identical elements
00:50:10 <pumpkin> nub n^2ishly does them all
00:50:36 <pumpkin> that's why people sort | uniq
00:51:48 <mmorrow> sort -u
00:51:51 <mmorrow> !! :)
00:51:51 <Twey> Ah, yes, of course
00:52:02 <Twey> So, uniq = map head . group
00:52:12 <pumpkin> yup
00:52:37 <pumpkin> zomg sort -u
00:52:45 <pumpkin> I never kn-u
00:52:52 <Twey> *grooooan*
00:53:09 <pumpkin> I've been awake for too long :P
00:53:18 <mmorrow> pumpkin: ooh, a glider would be perfect
00:53:42 <pumpkin> hmm, I'll work harder at making it fit in nicely then!
00:53:59 <mmorrow> pumpkin: http://catb.org/hacker-emblem/
00:54:13 <pumpkin> omg i can haz leet hax 2? :D
00:54:31 <mmorrow> u can haz!
00:54:50 <pumpkin> yay
00:56:17 <mmorrow> sort -nru
00:56:35 <mmorrow> are the only flags i know, and i've nevar needed any others
00:57:11 <mmorrow> (well, i always mean to learn how to use the key designation flags, but never get around to it)
01:51:47 <J-roen> Hi. Is it possible to catch a hGetLine failure when the connection is closed? I get this message, but can't catch it with the 'catch' function: hGetLine: failed (No error)
02:02:26 <HugoDaniel> i have a doubt about performance in haskell
02:02:37 <HugoDaniel> i have this huge array (mutable, ST)
02:03:16 <HugoDaniel> that is calculated some 20 times per second
02:03:35 <HugoDaniel> through several foldrs
02:04:37 <HugoDaniel> what is better, to calculate the array like im doing, or to keep a static array of Double->Double, and run through it with the value im calculating (possibly saving on the foldrs, im not sure how haskell handles this on the background) :/
02:04:55 <ibid> boxed array?
02:04:58 <HugoDaniel> yes
02:05:09 <ibid> that is likely to cause a performance penalty
02:05:20 <HugoDaniel> thats another question, with boxed array i can have Double->Double
02:05:29 <HugoDaniel> with unboxed i can't
02:05:47 <quicksilver> HugoDaniel: I don't know what you mean by "calculated some 20 times per second"
02:06:00 <quicksilver> you mean you're updating every value in the array 20 times per second?
02:06:34 <HugoDaniel> no, recreating a new array with a function: f :: Double -> STArray Int Double
02:06:59 <quicksilver> if you're creating a new array why does it need to be mutable?
02:07:10 <ibid> HugoDaniel: by double->doubvle do you mean that the index is double?
02:07:18 <HugoDaniel> my question is, what is better: f :: Double -> STUArray Int Double, or f :: STArray Int (Double->Double)
02:07:29 <HugoDaniel> ibid: what i said now :/
02:07:46 <ibid> HugoDaniel: ah, so you are storing functions!
02:08:01 <ibid> HugoDaniel: i'm not surprised that's slow
02:08:04 <HugoDaniel> quicksilver: because the calculation is done with several foldrs, changing the values on the array by acummulation (when it is needed)
02:08:24 <HugoDaniel> ibid: im not storing functions
02:08:45 <ibid> HugoDaniel: then what are you doing?
02:08:49 <HugoDaniel> im thinking if storing functions is faster than building an array each time i need it :/
02:09:02 <HugoDaniel> im building an array :P
02:09:28 <HugoDaniel> the input is [0.0, 0.00001 .. 1.0]
02:09:30 <quicksilver> HugoDaniel: I still don't understand.
02:09:44 <quicksilver> HugoDaniel: if you are just generating an array, you don't need to return a mutable array
02:09:51 <quicksilver> bcause you're not planning to change it again.
02:09:56 <ibid> HugoDaniel: are you trying to memoize some function?
02:09:57 <quicksilver> how big is the array?
02:10:10 <HugoDaniel> yes, im trying to memoize the array creation
02:10:30 <quicksilver> there is nothing stopping using foldrs for 'accumulation' (whatever you mean by that) with an immutable array
02:10:31 <HugoDaniel> quicksilver: it can be small as 3 or 4 positions, or as big as 100
02:10:36 <quicksilver> 100 is nothing.
02:10:51 <quicksilver> for 100 I wouldn't bother to unbox, or use an array at all.
02:10:58 <quicksilver> use an IntMap.
02:11:02 <quicksilver> or Data.Map
02:11:23 <HugoDaniel> quicksilver: 100 that are calculated thousands of times
02:11:33 <HugoDaniel> its a small array, that is calculated thousands of times
02:12:12 <quicksilver> that is no reason to use an array.
02:12:12 <HugoDaniel> through foldrs inside foldrs that change it in the creation
02:12:36 <quicksilver> there are two main reasons to use an array - (1) saving memory with unboxing
02:12:54 <HugoDaniel> accessing time O(1) ?
02:13:43 <HugoDaniel> when im creating it i have to access it and change some of its positions in the inned foldr
02:14:06 <ibid> HugoDaniel: for small datasets asymptotic behavior is irrelevant
02:14:39 <HugoDaniel> even if they get accessed thousands of times per second ?
02:15:28 <ibid> HugoDaniel: for that you want hard real time guarantees
02:15:41 <ibid> HugoDaniel: and again aymptotic behavior is irrelevant
02:16:22 <HugoDaniel> so i could just create lists, and let it be utterly slow :P
02:16:41 <ibid> HugoDaniel: does that guarantee hard real time?
02:16:48 <HugoDaniel> i dont need hard real time
02:17:05 <HugoDaniel> i just need "the fast, the better"
02:17:10 <ibid> HugoDaniel: you do if you need an access to take less than one microsecond
02:17:29 <ibid> (which is what you need for "thousand times per second")
02:17:41 <ibid> HugoDaniel: in any case, if your accesses far outnumber mutations, what does it matter how long building it takes?
02:17:43 <quicksilver> HugoDaniel: forget O(1), it's rubbish.
02:17:58 <quicksilver> HugoDaniel: IntMap and Data.Map are fast.
02:17:59 <ibid> HugoDaniel: in that case, the array access is indeed that matters
02:18:11 <HugoDaniel> ibid: precisely, i dont care about initialization
02:18:28 <ibid> HugoDaniel: okay, what have we been discussing then?
02:18:51 <HugoDaniel> i would paste the code if i had it here :/
02:20:27 <HugoDaniel> func = do {arr1 <- array..; arr2 <- array..; arr3 <- array..; (res, _ , _) <- foldM f (arr1, arr2, arr3) [0..10]; return res}
02:20:49 <HugoDaniel> f is another function with another fold on another function (g)
02:21:13 <HugoDaniel> the final result is an immutable array (im runing it with the runSTArray)
02:22:53 <HugoDaniel> i need them to be mutable, because of the accumulation going on (inside f and g)
02:23:14 <HugoDaniel> this would be fine, but what i have in reallity is this:
02:23:33 <HugoDaniel> func u = do {arr1 <- array..; arr2 <- array..; arr3 <- array..; (res, _ , _) <- foldM f (u, arr1, arr2, arr3) [0..10]; return res}
02:24:28 <HugoDaniel> and u is a Double with the range [0.0, 0.00001 .. 1.0]
02:25:15 <HugoDaniel> i was thinking if it was faster to have an type of Int (Double->Double), instead of Int Double
02:25:44 <HugoDaniel> because then i would only need one run through the final array, and i could skip the initialization part of func
02:25:50 <HugoDaniel> :/
02:26:47 <quicksilver> yes, almost certainly
02:26:57 <quicksilver> if the (double->double) function is constant (per index)
02:27:03 <quicksilver> then it's stupid to keep repeating the calculation.
02:27:50 <HugoDaniel> okey
02:28:31 <quicksilver> but I still don't think the use of an array is warranted :)
02:28:43 <HugoDaniel> what i really REALLY have is func i n u = ...
02:29:08 <McManiaC>                  case run of
02:29:08 <McManiaC>                       ('y'||'Y'||'j'||'J'):_ -> runAndSave
02:29:15 <McManiaC> any way to do it like that?
02:29:39 <HugoDaniel> func :: Int -> Int -> Double -> arr..
02:30:11 <HugoDaniel> so im thinking about using an IntMap of arrays of (Double->Double)
02:30:16 <luqui> McManiaC, if run `elem` "yYjJ" then ... ?
02:30:28 <McManiaC> ah, right :)
02:34:47 <HugoDaniel> anyone planing on going to the hackaton ?
02:55:29 <ErhardtMundt> hello
02:55:42 <Twey> Hail!
02:55:59 <ErhardtMundt> is there any library which allows me to take a snapshot from an imaging device (eg. webcam)?
02:56:07 <ErhardtMundt> hey twey :)
02:56:44 <ErhardtMundt> Twey: i bet you're english
02:56:48 <ErhardtMundt> aren't you? :)
02:56:50 <Twey> I am
02:57:00 <Twey> List says no
02:57:19 <Twey> But the Haskell FFI bindings are nice.  You can probably link to the C code to do so in about ten lines.
02:57:27 <quicksilver> webcams tend to have rather OS-specific bindings
02:57:37 <ErhardtMundt> Twey: i think we met previously
02:57:37 <quicksilver> I wonder if there is a (C) library which is cross-platform for them
02:57:49 <Twey> ErhardtMundt: It's possible.  You do look quite familiar.
02:57:57 <ErhardtMundt> in #lojban or whatever :)
02:58:03 <Twey> Ah, la'a
02:58:14 <ErhardtMundt> hahaha
02:58:31 <ErhardtMundt> you told me the origin of your nick
02:58:38 <Twey> There seems to be a wide overlap between the Haskell and Lojban communities.  :)
02:58:49 <luqui> wide?
02:58:54 <ErhardtMundt> that's quite natural
02:59:30 <quicksilver> http://sourceforge.net/projects/libvidcap/
02:59:39 <quicksilver> doesnt look mature though
03:00:05 <Twey> luqui: Think Venn :)
03:00:41 <ErhardtMundt> thank you anyway quicksilver
03:01:16 <ErhardtMundt> Twey: i didn't imagine you were an haskeller
03:01:23 <ErhardtMundt> how long do you master haskell? :)
03:01:54 <Twey> Um, I've been competent for a while now, but I'm no expert :)
03:02:28 <ErhardtMundt> do you know Learn You A Haskell?
03:07:25 <Twey> ErhardtMundt: I do
03:07:49 <ErhardtMundt> Twey: i'm the gui of the PDF :D
03:07:55 <ErhardtMundt> *guy
03:08:19 <Twey> Er, pardon?
03:09:12 <ErhardtMundt> Twey: i'm the guy which made the PDF
03:09:19 <Twey> Oh, there's a PDF?
03:09:25 <ErhardtMundt> yeah
03:09:34 <ErhardtMundt> look at the  FAQ
03:09:36 <ErhardtMundt> :D
03:09:54 <SirLancer> gui mm
03:10:01 <ErhardtMundt> it's full of errors and typos
03:10:20 <ErhardtMundt> but the reviewed version is coming soon
03:11:28 <SirLancer> I've been reading Yet Another Haskell Tutorial
03:11:29 <ErhardtMundt> SirLancer: haha, sorry, i'm aphasic today :)
03:11:41 <ErhardtMundt> oh really?
03:11:49 <ErhardtMundt> i love that site
03:12:40 <SirLancer> no GUI in this
03:13:24 <cognominal> is there a globbing function  in some module (a la shell :  ls *.hs)?
03:13:27 <ErhardtMundt> but LYAH is more simple to understand
03:13:29 <ErhardtMundt> imho
03:13:53 <SirLancer> hmm
03:14:00 <cognominal> System.FilePath.Glob!
03:14:09 <Twey> LYAH is too simple, IMO
03:14:22 <Twey> Maybe it would be OK for a complete beginner, just to get started
03:14:27 <ErhardtMundt> Twey: what do you mean by 'too'
03:14:29 <ErhardtMundt> ?
03:15:34 <ErhardtMundt> Twey: consider that's an unfinished tutorial
03:15:40 <ErhardtMundt> some things are still to come
03:15:51 <ErhardtMundt> such as a monad section
03:16:18 <Twey> True
03:16:26 <Twey> Monads are pretty important :)
03:16:33 <ErhardtMundt> hehe, yup
03:17:05 <ErhardtMundt> i asked the author to write a section about monads
03:17:24 <ErhardtMundt> he told me it's already in progress :)
03:17:38 <luqui> Twey, eh, kinda
03:17:46 * beelsebob wonders why people put such great importance on monads
03:17:50 <ErhardtMundt> Twey: the author is here, he's BONUS
03:17:59 <beelsebob> the only ones I ever actually use as monads are IO and Ghc
03:18:19 <luqui> they're nice for interpreters
03:18:28 <beelsebob> hmm?
03:18:45 <luqui> i usually use reader + state when i write interpreters
03:19:19 <Twey> beelsebob: Because IO is important
03:19:26 <Twey> ErhardtMundt: Yes, I'm aware :)
03:19:50 <beelsebob> Twey: sure – but I don't quite see why that means it has to go under the grand title of "now we're gonna teach you a super complex nasty thing with a scary name called Monad"
03:20:00 <beelsebob> it should just be "here's how you do IO in Haskell"
03:20:17 <beelsebob> and much much later (after covering functor, pointed, applicative) say "oh, that IO thing – that is a general concept"
03:20:25 <Twey> Well, and monads are handy anyway
03:20:27 <Twey> That's true
03:20:38 <Twey> It does make more sense to explain it in terms of those
03:20:44 <luqui> beelsebob, i wholeheartedly agree that functor should come first
03:20:49 <luqui> and is much, much more important
03:21:23 <luqui> i don't know about the other two, in terms of optimal presentation order
03:21:38 <beelsebob> pointed I'm not sure about – because we don't actually use it alone in the current Prelude
03:21:51 <beelsebob> Applicative though I think is just as simple a concept as Functor
03:21:55 <beelsebob> and almost as important
03:22:16 <luqui> monad is almost as simple as functor, as a concept
03:22:16 <beelsebob> and gives a nice grounding for exactly when Monad is necessary, and when it's not
03:22:28 <luqui> the thing is usage
03:22:34 <luqui> so, yeah you're probably right
03:22:43 <luqui> monads have more styles of usage than applicatives
03:22:53 <luqui> so cover the applicative style first
03:22:56 <beelsebob> yeh
03:23:02 <luqui> and say "you can also use that with a monad, and also you can ..."
03:23:09 <beelsebob> yeh
03:23:19 <beelsebob> hmm
03:23:23 <beelsebob> I needed a new blog post
03:23:25 <beelsebob> maybe this is it
03:23:27 <luqui> :-)
03:23:31 <beelsebob> bob's monad tutorial
03:23:33 <beelsebob> done in the right order
03:23:43 <luqui> and not actually covering monads :-)
03:23:48 <beelsebob> no, it'll cover monads
03:23:51 <luqui> aww...
03:23:53 <beelsebob> I have nothing against monads
03:24:01 <beelsebob> they're just less important than most people think
03:24:06 <beelsebob> and used in the wrong places
03:24:10 <luqui> yeah, i figure though, that people have more than enough places to look for those
03:24:14 <beelsebob> true
03:24:18 <Twey> beelsebob: What is pointed?
03:24:26 <beelsebob> Twey: things that have point
03:24:27 <beelsebob> aka pure
03:24:29 <beelsebob> aka return
03:24:33 <Twey> Ah
03:24:44 <drdozer> hi
03:25:01 <quicksilver> I'm not sure Pointed is such a good name for that.
03:25:07 <beelsebob> nor am I
03:25:10 <beelsebob> but I'm not sure what is
03:25:16 * beelsebob doesn't know the maths to go with it
03:25:18 <Twey> 'Wrapped'
03:25:20 <quicksilver> to me, Pointed most naturally names the Nullary version
03:25:21 <Twey> 'Container'
03:25:24 <quicksilver> i.e. mempty
03:25:29 <drdozer> I have a function in the list monad, and if part way down I do "v <- [1..1000]" it works fine, but if I do "v <- [1..]" it hangs - is the list monad being overly eager?
03:25:30 <beelsebob> Twey: you could argue that for Functor too though
03:25:42 <beelsebob> and Applicative in fact
03:25:42 <quicksilver> the higher-kinded version is an obvious lifting
03:25:44 <beelsebob> and Monad in fact
03:25:46 <Twey> Functor also allows operations on the thing in the container
03:25:49 <SirLancer> "Repeating yourself while programming is about as desirable as getting kicked inna head."
03:25:54 <Twey> (and Applicative, and Monad)
03:25:56 <quicksilver> but it's not the *most* obvious meaning of Pointed
03:25:59 <quicksilver> (to me)
03:26:00 <Twey> The bare container is just Pointed
03:26:07 <ErhardtMundt> SirLancer: haha
03:26:09 <Twey> You put something in
03:26:11 <Twey> That's it
03:26:13 <beelsebob> true
03:26:24 <luqui> (and map, because Functor => Pointed)
03:26:30 <beelsebob> no
03:26:35 <beelsebob> you don't need functor for pointed
03:26:40 <ErhardtMundt> SirLancer: what a wise sentence
03:26:42 <ErhardtMundt> :O
03:26:42 <beelsebob> but the two do usually go hand in hand
03:26:46 <quicksilver> drdozer: the list monad doesn't hang with infinite lists, no
03:26:54 <quicksilver> drdozer: it doesn't work particularly well with them but it doesn't hang.
03:26:57 <Twey> ErhardtMundt: Thank Detritus
03:26:57 <luqui> hmm, category-extras requires functor for Pointed, IIRC
03:27:02 <beelsebob> hmm
03:27:04 <beelsebob> :/
03:27:12 <quicksilver> > [ (x,y) | x <- [1..], y <- [2,4..] ]
03:27:14 <lambdabot>   [(1,2),(1,4),(1,6),(1,8),(1,10),(1,12),(1,14),(1,16),(1,18),(1,20),(1,22),(...
03:27:25 <SirLancer> ErhardtMundt: It's from Learn You A Haskell
03:27:26 <quicksilver> drdozer: ^^ notice, you'll never get (2,anything)
03:27:26 <drdozer> quicksilver: weird
03:27:31 <quicksilver> which is why I say it doesn't work particularly well
03:27:34 <quicksilver> but it shouldn't hang.
03:27:44 <Twey> It's from Pratchett
03:27:47 <ErhardtMundt> SirLancer: yeah, i knew it :)
03:27:48 <Twey> (eventually)
03:27:53 <luqui> > [ (x, y) | x <- [1..], y <- [2,4..], x == 2 ]
03:28:07 <lambdabot>   mueval: Prelude.read: no parse
03:28:14 <ErhardtMundt> Twey: who's Detritus?
03:28:16 <luqui> what a helpful error message...
03:28:27 <mmorrow> , [ (x, y) | x <- [1..], y <- [2,4..], x == 2 ]
03:28:34 <lunabot>  Killed.
03:28:50 <drdozer> mmorrow: that looks like an identical symptom :)
03:29:23 <luqui> that is one sense in which the list monad "hangs"... but.... that has very little to do with the monad and more to do with the computation
03:29:25 <mmorrow> the x==2 never happens..
03:29:45 <ErhardtMundt> why?
03:30:02 <Twey> 'Nossir.  Just a warning shot inna head, sir.'
03:30:07 <luqui> ErhardtMundt, because it has to go through all the y's before it can change x
03:30:07 <mmorrow> , [ (x,y) | x <- [1..], y <- [2,4..] ]
03:30:08 <lunabot>  [(1,2),(1,4),(1,6),(1,8),(1,10),(1,12),(1,14),(1,16),(1,18),(1,20),(1,22)...
03:30:23 <mmorrow> , zip (repeat 1) [2,4..]
03:30:25 <lunabot>  [(1,2),(1,4),(1,6),(1,8),(1,10),(1,12),(1,14),(1,16),(1,18),(1,20),(1,22)...
03:30:27 <luqui> er, s/change/try another/
03:30:48 <mmorrow> you probably want the diagonalize
03:31:13 <ErhardtMundt> luqui: so you can't put more than an infinite list into a list comprehension, right?
03:31:24 <luqui> ErhardtMundt, more than?
03:31:28 <luqui> oh more than one
03:31:32 <Twey> You mean, like, a twice-infinite list?
03:31:33 <luqui> uh... you could...
03:31:42 <Twey> Sure you can
03:31:46 <Twey> You just never reach it
03:31:55 <ErhardtMundt> luqui: i mean expecting your code works :)
03:31:55 <mmorrow> the list comp isn't enumerating them how you want them enumerated in this case
03:31:58 <luqui> , [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:32:04 <lunabot>  Killed.
03:32:10 <quicksilver> Control.Monad.Omega diagonalises, I think.
03:32:10 <luqui> what?
03:32:15 <luqui> > [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:32:17 <quicksilver> although I'm not really convinced that's the right word.
03:32:20 <Twey> luqui: It finds that the first three are < 4
03:32:28 <Twey> luqui: But it can't be sure that there isn't a 2 at the end of the list
03:32:31 <lambdabot>   thread killed
03:32:37 <luqui> Twey, sure, so it should output a few...
03:32:38 <Twey> filter has to go through the whole list
03:32:47 <luqui> > take 10 [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:33:02 <Twey> Well, no, because it tries to get all the xs before getting the ys
03:33:03 <lambdabot>   thread killed
03:33:12 <luqui> ....
03:33:13 <Twey> And it can't construct a value until it has an x and a y
03:33:18 <Ferdirand> > take 2 [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:33:18 <Twey> (I think)
03:33:20 <lambdabot>   [(1,1),(1,2)]
03:33:24 <luqui> ah there we go
03:33:31 <luqui> i thought i was starting from 0 so there would be 16
03:33:31 <Twey> Oho
03:33:37 <luqui> > take 9 [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:33:49 <luqui> oh right
03:33:53 <lambdabot>   thread killed
03:33:54 <luqui> yeah it can't be sure it's done with the ys
03:33:59 <luqui> so 3 is the most
03:34:03 <luqui> > take 3 [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:34:06 <lambdabot>   [(1,1),(1,2),(1,3)]
03:34:11 <luqui> > take 4 [ (x,y) | x <- [1..], x < 4, y <- [1..], y < 4 ]
03:34:21 <luqui> righto. ok, i am satisfied.
03:34:25 <mmorrow> @let diag :: (a -> a -> b) -> [[a]] -> [b]; diag = let go f [] [] = [];go f q [] = go f [] q;go f ([]:q) xss = go f q xss;go f q ([]:xss) = go f q xss;go f [] [xs] = [];go f [](xs:xss)= go f [xs] xss;go f ((x:xs):q) (ys@(y:_):xss) = f x y : go f (q++[ys,xs]) xss in flip go []
03:34:26 <lambdabot>  Defined.
03:34:27 <ErhardtMundt> haha
03:34:27 <lambdabot>   thread killed
03:34:38 * mmorrow had that one already written somewhere ... ;)
03:34:40 * Twey sneezes.
03:34:57 * ErhardtMundt sneezes too
03:35:12 <luqui> mmorrow, that signature...
03:35:27 <luqui> doesn't make sense to me.
03:35:40 <mmorrow> > filter ((==2) . fst) $ diag (,) [[1..],[2,4..]]
03:35:53 <luqui> why does the func take two args?
03:35:55 <lambdabot>   thread killed
03:35:58 <mmorrow> oops
03:36:09 <mmorrow> > diag (,) [[1..],[2,4..]]
03:36:14 <lambdabot>   [(1,2),(2,2),(2,4),(4,3),(3,6),(6,4),(4,8),(8,5),(5,10),(10,6),(6,12),(12,7...
03:36:29 <luqui> > diag (,) [[1,2,3],[4,5,6],[7,8,9]]
03:36:34 <lambdabot>   [(1,4),(4,7),(2,7),(7,5),(3,5),(5,8),(8,6),(6,9)]
03:36:38 <mmorrow> luqui: the first arg is the combining function
03:36:44 <luqui> what does it combine?
03:36:47 <mmorrow> so to enumerate Q, you'd do
03:36:58 <drdozer> ok, well in my application, I think I have an upper bound on how big my list can actually be
03:37:07 <mmorrow> > diag (,) (fmap (\n -> [n..]) [1..])
03:37:11 <lambdabot>   [(1,2),(2,3),(2,4),(3,5),(3,6),(4,7),(3,8),(5,9),(4,10),(6,11),(4,12),(7,13...
03:37:15 <luqui> > diag (,) (map repeat [1..])
03:37:19 <lambdabot>   [(1,2),(2,3),(1,4),(3,5),(2,6),(4,7),(1,8),(5,9),(3,10),(6,11),(2,12),(7,13...
03:37:52 <mmorrow> err, i can't remember which one enumerates Q, the one i did or the one you just did
03:38:00 <mmorrow> but it's one of those (maybe both)
03:38:20 <mmorrow> ahh, i think yours does it
03:38:27 <drdozer> ensuring termination with infinitely large data-structures is fun :)
03:38:30 <luqui> i still think it's weird that it takes a two-arg combining function
03:38:36 <luqui> i don't have an intuition for that...
03:39:03 <mmorrow> luqui: it's modeled after enumerating Q..
03:39:10 <lilac> > diag (,) [[1..],[100..],[10000..]]
03:39:11 <lambdabot>   [(1,100),(100,10000),(2,10000),(10000,101),(3,101),(101,10001),(4,10001),(1...
03:39:20 <mmorrow> there's a slight variation that produces lists
03:39:36 <mmorrow> (but i don't have that one on me at this computer..)
03:39:42 <lilac> > fst <$> diag (,) [[1..],[100..],[10000..]]
03:39:44 <lambdabot>   [1,100,2,10000,3,101,4,10001,5,102,6,10002,7,103,8,10003,9,104,10,10004,11,...
03:40:16 <lilac> ok, so the fst looks like a fair enumeration; what's the snd?
03:40:40 <mmorrow> as i said, it's for enumerating Q :)
03:40:57 <mmorrow> (actual answer: i have no idea ;)
03:41:42 <luqui> @let diagonal = concat . stripe where { stripe [] = []; stripe ([]:xss) = stripe xss; stripe ((x:xs):xss) = [x] : zipCons xs (stripe xss); zipCons [] ys = ys; zipCons xs [] = map (:[]) xs; zipCons (x:xs) (y:ys) = (x:y) : zipCons xs ys }
03:41:43 <lambdabot>  Defined.
03:41:48 <luqui> :t diagonal
03:41:49 <lambdabot> forall a. [[a]] -> [a]
03:42:02 <lilac> > diagonal [[1..],[100..],[1000..]]
03:42:04 <lambdabot>   [1,2,100,3,101,1000,4,102,1001,5,103,1002,6,104,1003,7,105,1004,8,106,1005,...
03:42:30 <Kvasir> are there things like float and double in haskell?
03:42:39 <luqui> > 42 :: Double
03:42:41 <lambdabot>   42.0
03:42:44 <Kvasir> or int and long
03:42:57 <Kvasir> > 42 :: Long
03:42:58 <lambdabot>   Not in scope: type constructor or class `Long'
03:43:00 <luqui> uh, no long in the prelude...
03:43:04 <luqui> just Int and Integer
03:43:05 <quicksilver> @let diagon alley = ["Flourish & Blotts","Ollivander's","Gringotts"]
03:43:06 <lambdabot>  Defined.
03:43:16 <Kvasir> how big are they?
03:43:16 <luqui> Integer = arbitrary precision, Int = at least 28 bit
03:43:17 <quicksilver> > 42 :: Int64
03:43:17 <lilac> > 100^^100 :: Integer
03:43:19 <lambdabot>   42
03:43:19 <lambdabot>       No instance for (Fractional Integer)
03:43:19 <lambdabot>        arising from a use of `^^' ...
03:43:21 <mmorrow> , foldr interleave [] (repeat [1..])
03:43:22 <lunabot>  [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,1...
03:43:24 <lilac> > 100^100 :: Integer
03:43:25 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
03:43:35 <mmorrow> , foldr interleave [] [[1..],[100..],[1000..]]
03:43:36 <lunabot>  [1,100,2,1000,3,101,4,1001,5,102,6,1002,7,103,8,1003,9,104,10,1004,11,105...
03:43:37 <quicksilver> Kvasir: Int is probably a similar size to C int
03:43:47 <mmorrow> , 'interleave
03:43:48 <lilac> luqui: Int seems to lose a bit each time i hear about it :)
03:43:49 <Kvasir> > 42 :: Float
03:43:49 <lunabot>  Control.Monad.Logic.Class.interleave
03:43:50 <lambdabot>   42.0
03:44:05 <luqui> lilac, hehe.  i'm not sure of the exact number :-)
03:44:14 <luqui> it's a few less than 32
03:44:37 <lilac> luqui: well, i'm sure you're correct, since i thought it was 30 and conal's most recent blog said 29
03:44:49 <luqui> lol!
03:45:18 <opqdonut> tag bits :)
03:45:38 <opqdonut> > logBase 2 . fromIntegral $ (maxBound :: Int)
03:45:40 <lambdabot>   63.0
03:46:12 <opqdonut> ah, 64bit system
03:46:46 <opqdonut> hmm, whole 64bit signed range seems to be in use...
03:47:01 <quicksilver> yes
03:47:09 <quicksilver> GHC doesn't reserve any bits at all.
03:47:14 <TSC> The report says it has to be at least 30 bits, but GHC uses the whole 32/64 bits
03:47:16 <mmorrow> luqui:
03:47:17 <doserj> luqui: Int is at least 30 bits, so maxBound::Int is at least 2^29-1, according to the report.
03:47:18 <mmorrow> > diag const $ [[1..],[100..],[1000..]]
03:47:19 <lambdabot>   [1,100,2,1000,3,101,4,1001,5,102,6,1002,7,103,8,1003,9,104,10,1004,11,105,1...
03:47:27 <opqdonut> quicksilver: didn't it use to do tagging?
03:47:33 <luqui> doserj, ok
03:47:39 <quicksilver> opqdonut: no, it never did.
03:47:40 <luqui> i probably won't remember that
03:47:43 <opqdonut> ok
03:47:48 <quicksilver> opqdonut: it actually does more tagging than it used to
03:47:51 <mmorrow> i remember now, so it gives you (\x y -> f x y : f y x : ...)
03:47:53 <quicksilver> but it still doesn't tag unboxed values.
03:48:12 <opqdonut> ok, sweet
03:48:13 <luqui> my brain:  Int = "pretty small" ; Integer = "everything else"
03:48:48 <quicksilver> opqdonut: GHC was originally designed using "the spineless tagless G-machine"
03:48:51 <quicksilver> hence, no tags :)
03:48:57 <opqdonut> ah :D
03:49:04 <quicksilver> but they added a very limited kind of tagging back in 6.8
03:49:09 <lilac> my brain: Int = "almost anything" ; Integer = "fibonacci and project euler"
03:49:10 <luqui> for what purpose?
03:49:12 <quicksilver> but it only ever tags the indirection pointers
03:49:19 <SamB> now it's spined, tagged, and apparantly R-rated
03:49:23 <opqdonut> i've read implementation of funct. lang. but i'm still not quite sure about ghc really works
03:49:33 <quicksilver> luqui: they added tagging back for what purpose?
03:49:37 <luqui> yeah
03:49:42 <opqdonut> performance presumably
03:49:47 <quicksilver> luqui: to be able to choose the right case branch without following the pointer
03:49:52 <quicksilver> avoid a cache miss sometimes.
03:49:57 <luqui> ah makes sense
03:51:25 <quicksilver> there should be a paper about why they did it
03:51:47 <quicksilver> luqui: https://research.microsoft.com/en-us/um/people/simonpj/papers/ptr-tag/index.htm
03:52:13 <quicksilver> I could be wrong about cache misses
03:52:15 <drdozer> is there library code for manipulating jpg (and other) images?
03:52:21 <quicksilver> looks like the main reason is mispredicted branches.
03:54:29 <doserj> drdozer: hsmagick for example
04:01:07 <drdozer> hsmagick it is then :)
04:01:30 <luqui> drdozer, codec-image-devil does too...
04:01:40 <luqui> but it's very rudimentary
04:01:51 <wunki> last night I had a "nightmare" about Haskell.. talk about being geeky..
04:02:14 <drdozer> I think for my app I need to read in a jpeg, do stuff with it and then write out an animated gif of the resulting slide-show
04:02:30 <drdozer> from a brief read through ImageMagick, I think it supports that
04:02:44 <quicksilver> what kind of "stuff" ?
04:03:14 <drdozer> quicksilver: I'm computing cellular automata that converge to a steady-state that is the image
04:03:37 <lilac> wunki: aagh, the lambdas, they're attacking and i'm trapped in the cheese monad!
04:03:50 <drdozer> drdozer: I met someone on the train the other day that said you could do it and handed me a paper - he works in nanotech :)
04:04:29 <luqui> ... what if the image is not a steady state?
04:04:51 <luqui> or do you get to choose your rules?
04:05:17 <drdozer> luqui: the algorithm only produces CAs that converge to a steady state - it computes the rules so that a tiled-array of identical CAs will compute the image
04:05:43 <luqui> hmm
04:06:16 <luqui> oh i see.  that's cool.
04:06:38 <drdozer> I thought so :)
04:06:42 <wunki> lilac: haha, I dreamt for a full hour that my [] wouldn't arrange as I wanted them to... :)
04:06:43 <luqui> so it actually has the potential to compress
04:07:00 <drdozer> he showed me 'transformer' style robots self-assembling from these CAs, and switching between multiple configurations - neat stuff
04:07:15 <luqui> wow
04:07:16 <lilac> wunki: yow! i had a nightmare once about a space leak
04:07:42 <wunki> lilac: haskell does that to you...
04:11:39 <raji> any help on counting the number of hamiltonian paths in  a rectangular lattice with blocked cells?
04:12:19 <raxas_> drdozer: that "steady state" issue sounds to me like a halting problem. good luck with "only produce CA that converge to steady state" for any given image
04:13:51 <Axman6> hmm, there's an idea. i wonder if it's possible to write a programming language that you can always prove it'll halt or not, while keeping it useful
04:14:27 <Axman6> i reckon you couls use a subset of haskell to do it
04:16:18 <luqui> Axman6, well, in some sense, no
04:16:34 <luqui> there are programs which do not halt, but for which that cannot be proven
04:17:04 <Axman6> yeah... you could't write those in this language :P
04:17:29 <luqui> ah, so you're just talking about a total language
04:17:36 <luqui> like any of the popular DT languages
04:17:42 <Axman6> DT?
04:17:46 <luqui> dependent type
04:17:54 <luqui> agda, coq, epigram  (the "big three" :-)
04:18:02 <Axman6> ah, righto
04:18:25 <Axman6> ok, sounds like i;m getting into stuff that will hurt my brain in its current overworked state
04:18:56 <luqui> it's good hurt, whenever you're ready :-)
04:20:29 <Axman6> well it's 10:19PM, i started uni at 10AM, and finished at 7, with 5 hours of tutorials, ad 2 hours of lectures, spending all free time i had finishing off various pieces of assignment. so, brain's pretty mush right now... maybe when i get my two week break (with one one major assignment due in the missle of it)
04:21:32 <luqui> long day
04:22:45 <xkb> How do you like my game of life implementation? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3135#a3135
04:22:49 <Eridius> what is the purpose of Comonad?
04:23:35 <luqui> Eridius, it's the copurpose of monad
04:24:17 <Eridius> I recognize that it's basically the inverse of monad, but what's it's use?
04:25:00 <luqui> Eridius, good question!  dan piponi recognized that cellular automata (to stay on topic) have a very cool comonadic encoding
04:25:47 <luqui> it's possible that they form a nice framework for "dataflow programming" (only in applicative style)
04:26:06 <luqui> i mean... stuff.  what is "the use" of monads?
04:26:12 <Eridius> hrm, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html ?
04:26:20 <Eridius> well, you can point to many practical applications of monads
04:26:30 <luqui> yeah, comonads are a bit less explored
04:26:38 <Eridius> ah
04:27:44 <SamB> there is no "the use"
04:27:53 <SamB> what's the use of fields? rings?
04:28:07 <Eridius> SamB: "the use" here means a practical application
04:28:24 <SamB> there are many different uses
04:28:30 <Eridius> and I'm talking specifically about the Comonad as exists in Haskell, not the math theory behind it. I'm not equipped to evaluate the math theory ;)
04:29:04 <Eridius> I just wish the standard library documentation actually had examples of uses of the stuff it documents
04:29:05 <SamB> Eridius: oh, you were asking about comonads!
04:29:09 <Eridius> yes
04:29:12 <SamB> sorry
04:29:15 * Eridius chuckles
04:29:22 <SamB> I saw luqui's question ...
04:29:30 <SamB> that's what I was responding to ;-P
04:29:37 <Eridius> ah
04:31:04 <SamB> I guess I thought he was going through a phase like I once did, where I was trying to figure out what to say that monads *were* even though I actually already knew ...
04:31:24 <Eridius> heh
04:32:10 <quicksilver> I've not seen really 'integrated' convincing comonad exaples
04:32:11 <vixey> (reads backlog) but how do you make the CA efficient?
04:32:19 <quicksilver> it's certainly true that co-join is sometimes useful
04:32:25 <quicksilver> and no doubt extract is sometimes useful
04:32:29 <vixey> after 3 iterations on a 5x7 board that comonadic implementation is horribly slow
04:32:44 <quicksilver> but examples where the relationship between cojoin and extract is vital seem less frequent.
04:32:52 <SamB> vixey: maybe you need a better 2d zipper?
04:33:08 <SamB> or maybe it really only works well for 1-d CAs
04:34:13 <solidsnack> Eridius: I think if a monad sequences effects...a comonad must effect sequences!
04:34:25 <Eridius> hah!
04:34:27 <vixey> there is a comonad:
04:34:47 * shapr boings
04:34:51 <vixey> gensym :: Gemsym a -> a ; split :: Gensym a -> (Gensym a, Gensym a)  I think ..
04:34:57 <vixey> hi hi shapr
04:35:02 <shapr> hi vixey!
04:35:04 * shapr hugs vixey 
04:35:16 <quicksilver> solidsnack: you mean a comonad is the russian reversal of a monad?
04:35:19 <quicksilver> interesting.
04:35:29 <solidsnack> quicksilver: LOLz.
04:35:30 <quicksilver> in soviet comonad, effects sequence YOU
04:35:40 <solidsnack> In Russia, monad joins you!
04:35:46 <solidsnack> yes, right
04:35:50 <luqui> i thought that was called the smirnov transform
04:35:50 <solidsnack> yours is better
04:35:53 <vixey> shapr, I write a juggling sim. in haskell/opengl/glut
04:36:01 <shapr> cool! using siteswap notation?
04:36:05 <vixey> yes
04:36:12 <shapr> nifty!
04:36:25 <vixey> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2003
04:36:38 <vixey> I was trying to do frp but I think I didn't :p
04:37:08 <quicksilver> to lazy to compile can haz screenshot?
04:37:56 <EvilTerran> > map digitToInt $ ['0'..'9'] ++ ['a'..'f']
04:37:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
04:38:56 <luqui> > digitToInt 'g'
04:38:58 <lambdabot>   * Exception: Char.digitToInt: not a digit 'g'
04:39:09 <vixey> doesn't really work still but,  http://img24.imageshack.us/img24/9580/picture8y.png
04:39:35 <solidsnack> quicksilver: So I guess this leads us to a new mathematical terminology. We now have Russian Monad, Russian Induction, &c.
04:39:54 <Eridius> wow ok, I'm done reading that blog post bout comonadic CA. While that looks really cool, it also sounds highly inefficient
04:40:08 <luqui> Eridius, really?
04:40:12 <Eridius> it ends up re-constructing shifted versions of the exact same universe, a brand new copy for every cell that's evaluated
04:40:15 <luqui> what is being recomputed?
04:40:22 <Eridius> the structure of the universe
04:40:26 <vixey> Eridius: yeah that's what I am moaning about too
04:40:39 <vixey> do you know how to fix it?
04:40:44 <vixey> also my gensym monad uses unsafePerformIO
04:40:47 <Eridius> if you look at a 20-cell-long slice of the universe, evaluating the rules requires constructing 20 identical (but offset) universes and then combining them to form the 21st
04:40:59 <vixey> I have this feeling like we could probably fix all these problems in one go
04:41:00 <Eridius> I think fixing it requires losing the comonadic aspect
04:41:07 <vixey> sorry gensym comonad
04:41:36 <vixey> Eridius: well I'm guessing it's like --- you could givea  pure implementation of ST but it would not be as efficient as the real implementation of ST
04:41:46 <Eridius> perhaps
04:41:51 <quicksilver> vixey: cool :)
04:41:54 <luqui> Eridius, how would you make it more efficient?
04:41:59 <vixey> Eridius: maybe the co-situation is like that too, can't tell
04:42:01 <luqui> Eridius, and still be infinite?
04:42:01 <vixey> thanks :)
04:42:13 <Eridius> if you could figure out how to have a single mutable universe (where the focus can move but the elements themselves are immutable), then you could make it more efficient but I'm not sure how to put that into the framework of a comonad
04:42:18 <luqui> obviously it doesn't recompute the _entire_ structure of the universe
04:42:23 <luqui> only the bits that are demanded
04:42:29 <luqui> which is a little 3x3 chunk
04:43:24 <wunki> what can I do about: Ambiguous occurrence `Maybe'. It's used in Prelude and Main?
04:43:34 <Eridius> wunki: stop defining Maybe in Main?
04:43:46 <luqui> if you're not used to laziness, you might think it is O(n^2)...
04:44:06 <Eridius> luqui: no, I realize it's lazy, but it still has to recompute the structure of the universe (if not the contents) for every single cell
04:44:18 <luqui> Eridius, how much structure?
04:44:24 <Eridius> the U
04:44:29 <luqui> the U is infinite
04:44:32 <luqui> how much of it?
04:44:47 <Eridius> the focus, and as much of each of the two lists as the rule itself evaluates
04:44:53 <vixey> I can't find my comonad impl. of life based on that post
04:44:58 <luqui> so 3x3 in the case of conway
04:45:01 <vixey> but it *is* really really slow
04:45:07 <Eridius> luqui: sure
04:45:25 <luqui> ok
04:45:37 <luqui> it's practically inefficient
04:45:37 <wunki> i'm trying to build a recursive type constructor with Maybe: data Maybe a = Point a (Maybe a) (Maybe a). Wrong approach?
04:45:40 <luqui> asymptotically fine
04:45:42 <Eridius> but if you're evaluating a 5x7 grid, that's 35 new 3x3 copies of the universe
04:45:46 <vixey> Eridius: and afaict there is no OI (co-IO) monad that isn't fundamentally phracked
04:46:01 <Eridius> so it's recomputing 315 cells (and 35 U structures) when it really only needs 35 cells and 1 U structure
04:46:09 <luqui> yeah, OI is lamesauce.
04:46:10 <vixey> wunki: not really recursive..
04:46:16 <Eridius> vixey: I can't even think of what OI would even mean
04:46:26 <vixey> instead of   print :: String -> IO ()
04:46:31 <vixey> um..
04:46:34 <vixey> something else ^^
04:46:51 <Eridius> well, Comonad isn't the dual of one particular Monad
04:46:52 <vixey> maybe OI String -> ()
04:46:57 <Eridius> so it doesn't make much sense to try and produce the dual of IO
04:47:01 <Eridius> what's the dual of [] ?
04:47:02 <Eridius> or Maybe?
04:47:04 <luqui> Eridius, well the cells would be memo'd, so it's the structures
04:47:05 <vixey> no
04:47:31 <Eridius> luqui:  well no, it has to build thunks for the U lists and then evaluate them
04:47:44 <Eridius> so evaluating the thunk to produce a cell is what I mean by evaluating a cell
04:47:58 <vixey> Eridius: it's not the 'dual' in some formal sense.. the idea is to produce a co-monad for IO
04:48:03 <Eridius> ah
04:48:18 <Eridius> vixey: I still don't think that makes any sense :P
04:48:32 <Eridius> IO is magical. You can't strip away the IO aspect (e.g. coreturn)
04:48:38 <Eridius> unless you mean unsafePerformIO
04:48:45 <vixey> what's the type of coreturen
04:49:07 <Eridius> w a -> a
04:49:25 <vixey> so if we had:  unsafePeformIO :: IO a -> a
04:49:37 <vixey> it seems that:  unsafePeformOI :: OI a -> a
04:49:41 <vixey> but I don't see why that's unsafe
04:49:56 <luqui> well it'd better not have any effects...
04:50:08 <Eridius> What's OI? If we're talking about producing a Comonad, then that would be instance Comonad IO
04:50:21 <vixey> do you see how the gensym comonad works?
04:50:27 <EvilTerran> wunki, the name "Maybe" is already taken by a Prelude type, and "data Maybe a = ..." is re-defining it
04:50:33 <vixey> it's like each time you split it, they are still able to communicate in secret
04:50:45 <Eridius> where's the gensym comonad?
04:52:49 <vixey> gensym will print a new (fresh) symbol out, and you can also split generators
04:52:55 <vixey> there's an obvious pure implementation (split into 2n & 2n+1) but you get huge numbers that way
04:53:01 <vixey> so there's an evil implementation which uses (inline assembly in the old old article) or unsafePerformIO in category extras for the implementation
04:55:50 <alx`> Hi all ! I need a parMapM_ function. I found the following on Internet :
04:55:51 <alx`> parMapM_ :: (a -> IO ()) -> [a] -> IO ()
04:55:51 <alx`> parMapM_ f []     = return ()
04:55:51 <alx`> parMapM_ f (x:xs) = (f x >>= return ()) `par` (parMapM_ f xs)
04:55:59 <alx`> But it doesnt not compile :
04:56:06 <alx`> parHLCM.hs:50:36:
04:56:06 <alx`>     Couldn't match expected type `IO b' against inferred type `()'
04:56:06 <alx`>     In the first argument of `return', namely `()'
04:56:06 <alx`>     In the second argument of `(>>=)', namely `return ()'
04:56:08 <alx`>     In the first argument of `par', namely `(f x >>= return ())'
04:56:13 <alx`>  
04:56:20 <alx`> Could you help me to understand why ?
04:56:44 <Axman6> don't paste on here please...
04:56:56 <alx`> Where should I do it ?
04:57:07 <Axman6> @where hpaste
04:57:07 <lambdabot> http://hpaste.org/
04:57:10 <Axman6> ^^
04:57:18 <Saizan_> ?type (>>= return ())
04:57:19 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
04:57:20 <lambdabot>     In the first argument of `return', namely `()'
04:57:20 <lambdabot>     In the second argument of `(>>=)', namely `return ()'
04:57:56 <Saizan_> however that doesn't do what you want at all
04:58:18 <alx`> really ? Sorry I'm a bit new to monads...
04:58:38 <luqui> alx`, par and IO don't mix
04:58:47 <luqui> if you're doing IO, you want to be using forkIO and friends
04:59:06 <luqui> par is for pure computations
04:59:19 <alx`> That's what I wanted to avoid...I wanted to use semi-implicit parallelism
04:59:39 <luqui> alx`, then build some semi-implicit parallelism combintors
05:00:17 <luqui> parIO a b = forkIO a >> b, for example ?
05:00:36 <Axman6> alx`: you probably wanted (f x >> return ()) btw
05:00:39 <mib_58a9om5l> I want to do web programming using Haskell, who can tell me which tools are needed?
05:00:57 <Axman6> happstack, or any of the other web frameworks
05:01:37 <mib_58a9om5l> should some web server be prepared?
05:01:53 <Axman6> happstack has its own webserver
05:01:57 <Axman6> it's quite fast too
05:02:16 <Axman6> up there with apache in static content serving apparently
05:02:16 <mib_58a9om5l> thank you for kind advice
05:03:09 <andun> why doesn't ./Setup.hs configure --help list all the flags in foo.cabal? for instance the 'hacking' flag in Yi.
05:03:20 <alx`> Axman6 -> thanks, it compiles ! But there must be a problem with the sparks created because it doesn't use more than 1 core even with +RTS -N4
05:04:08 <Axman6> you almost certainly want to be using forkIO for what you're doing
05:04:41 <alx`> I am investigating it with the code given by luqui
05:09:12 <mib_58a9om5l> Is there any haskell web server for windows platform?
05:09:17 <alx`> I have implemented parMapIO with the parIO given by luqui : parMapIO f (x:xs) = (f x) `parIO` (parMapIO f xs)   and a simple base case
05:09:52 <alx`> It's strange because it gives me the same result as the corrected parMapM_ : the program immediately stops without evaluating !
05:10:12 <luqui> what is your test case?
05:10:58 <alx`> It's someting like : parMapIO (someFunction) [0..someInteger] with someInteger>=20
05:11:10 <luqui> what is someFunction?
05:12:37 <alx`> it's a bit complicated for pasting here (and I don't understand hpaste...) but it's a recursive function itself calling a parMapIO (itself) list. The function prints some results (return type IO ()) but here nothing is printed : it seems it's not entered in
05:12:55 <luqui> sounds like an infinite loop
05:13:16 <luqui> your program terminates if you use mapM_ instead of parMapIO?
05:13:25 <luqui> i mean works
05:13:27 <luqui> (not terminates)
05:13:31 <alx`> hum...yes, no problem with mapM_
05:13:35 <luqui> hmm...
05:13:41 <luqui> that's peculiar
05:14:07 <luqui> paste please.  go to hpaste.org, and click new at the top
05:14:16 <luqui> then just copy/paste to the text box
05:14:36 <luqui> push save at the bottom and give us the url
05:15:55 <alx`> Do you want everything (300 lines) or just the main (for calling) and the parMapped function ?
05:16:27 <luqui> enough to run it
05:16:52 <vixey> ltu is advertising new lisp dialects and 'Internet Casino - Internet Casino'
05:17:12 * vixey got to find a new homepage
05:17:32 <Twey> vixey: *laughs*
05:17:35 <alx`> OK, everything. I also have to find you a place with a dataset, else it won't do anything...
05:17:40 * wli needs to get holomorphy.com back online.
05:20:22 <alx`> Here is a link to the code : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3136#a3136
05:20:34 <alx`> A dataset : http://fimi.cs.helsinki.fi/data/mushroom.dat
05:21:04 <alx`> running : ./hlcm mushroom.dat 3000 +RTS -N<your number of cores>
05:21:05 <vixey> that's really long and complicated a1x
05:21:29 <alx`> yeah I know, sorry...The interesting part is when using parMapIO
05:21:30 <Twey> Can we not have the runtime detect the number of cores automatically?
05:21:48 <Twey> It seems silly to have to pass +RTS -N$numcores to get it to use more than one core
05:21:55 <mib_58a9om5l> Is there any haskell web server for windows platform?
05:22:03 <Eridius> Twey: well, detecting number of cores isn't very useful when some of those cores are already running other things
05:22:18 <Eridius> this is why Apple's new Grand Central technology in Snow Leopard is so damn awesome
05:22:21 <Twey> Of course, but the kernel can work around that
05:22:36 <Twey> mib_58a9om5l: happstack can run on Windows, I think...
05:22:46 <Twey> So can that other one, BrownSugar or something
05:22:49 <Twey> Started with a T
05:22:56 <Eridius> if you run 4 processes that each try and use all 4 cores, that's 16 threads waiting on 4 cores and that's simply going to be worse than 4 processes each running one thread
05:23:24 <luqui> alx`, "createNewCDB" isn't defined...
05:23:51 <alx`> arg ! I didn't pasted enough ! sorry...
05:23:56 <Twey> Ah, Turbinado
05:24:15 <luqui> um
05:24:18 <luqui> i have a different idea
05:24:25 <luqui> why don't you try to prune it down to a minimal test case
05:24:37 <luqui> that exhibits the difference between mapM_ and parMapIO
05:25:00 <alx`> Here is the new link : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3137#a3137
05:25:04 <luqui> i.e. make sure parMapIO print [1,2,3] works...
05:25:05 <alx`> But you are right
05:25:14 <alx`> I will try that
05:27:21 <alx`> I tried :  parMapIO print [(show 1),(show 2),(show 3)]
05:27:27 <alx`> It doesn't work
05:27:30 <alx`> (no output)
05:28:02 <alx`> mapM_ does the job correctly however
05:31:40 <alx`> Got a progress with the more complicated : parIO2 a b = do
05:31:41 <alx`>   forkIO a
05:31:41 <alx`>   mv <- newEmptyMVar
05:31:43 <alx`>   forkIO (b >> putMVar mv())
05:31:47 <alx`>   takeMVar mv
05:31:53 <alx`> It now writes only 1 value out of the three...
05:34:47 <ibid> parMapIO print [(show 1),(show 2),(show 3)] works here, for some values of "work"
05:35:17 <alx`> what do you mean ? Did you have all numbers displayed ?
05:35:30 <ibid> yes, just garbled because of thread scheduling :)
05:35:40 <ibid> Prelude Control.Concurrent> parMapIO print [(show 1),(show 2),(show 3)]
05:35:41 <ibid> "1"""23
05:35:41 <ibid> ""
05:35:56 <ibid> (that's in ghci)
05:35:59 <alx`> really ? I have just one of them with parIO2, and zero with parIO
05:36:14 <ibid> i'm using the code from http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3137#a3137
05:36:49 <ibid> (well, just parIO and parMapIO)
05:38:10 <alx`> OK, same result in ghci
05:38:16 <Saizan_> the problem with parMapIO is that it doesn't wait for the threads to finish
05:38:41 <alx`> Which would explain the "no output" outside of ghci, right ?
05:38:53 <Saizan_> right
05:39:01 <ibid> alx`: same result as i did or the same result as outside?
05:39:09 <alx`> as you did
05:39:12 <ibid> right
05:39:20 <Saizan_> i think there's a parMapIO on hackage
05:39:21 <alx`> ghci must wait for the threads to finish
05:39:34 <alx`> ah that would be nice
05:39:39 <Saizan_> if you're keeping ghci open they have time to finish
05:39:56 <ibid> the finish before repropmpt for me
05:40:14 <ibid> *they
05:40:21 <Workybob> luqui: you still up?
05:46:05 <nzeh> Hi folks, I'm trying to write some code that works with mutable arrays but should also be able to throw errors.  I tried to do this using an STArray inside an ST monad inside an ErrorT monad transformer.  To get the result computation, I tried to use "runST . runErrorT $ comp", but ghc complains about a quantified typevariable that escapes from the application of runErrorT.  So I'm at a loss.  I keep thinking this cannot be so hard.  Any pointers?
05:46:47 <zachk> nzeh: try maybe or maybeT for errors
05:46:55 <Saizan_> zachk: that's not relevant.
05:47:06 <zachk> :-/
05:47:25 <nzeh> I really want ErrorT because I want to return information about the type of error, and as Saizan_ says, I don't think it will resolve the issue.
05:47:37 <Saizan_> nzeh: the problem is the quantified 's' in the type signature of runST
05:47:52 <nzeh> That's what I thought.  How do I fix it?
05:48:06 <Saizan_> not using $, i think
05:48:22 <nzeh> Ah, so runST (runErrorT comp)?
05:48:23 <Saizan_> ?type runST . runErrorT
05:48:24 <lambdabot>     Inferred type is less polymorphic than expected
05:48:24 <lambdabot>       Quantified type variable `s' escapes
05:48:24 <lambdabot>       Expected type: ErrorT e (ST s) a -> forall s1. ST s1 (Either e a)
05:48:36 <Saizan_> nzeh: yeah
05:48:42 <nzeh> Okay, I'll try that.
05:48:46 <nzeh> Thanks.
05:49:01 <nzeh> But before I do that, do you know an easier way to do this?
05:49:09 <nzeh> It seems like an awful lot of rigging.
05:49:16 <Saizan_> to do what?
05:49:32 <kadaver> -<>-
05:49:40 <nzeh> To build a computation that works with mutable arrays and can throw errors in an orderly fashion.
05:49:57 <Saizan_> the only alternative for mutable arrays is IO
05:50:01 <alx`> GOT IT GUYS !
05:50:03 <zachk> doesn't a mutable ST array have built in state?
05:50:29 <alx`> Thanks to your idea of looking for a parMapIO, I googled and found it : http://vis.renci.org/jeff/2009/01/17/simple-futures-in-haskell/
05:50:38 <vixey> aw I'm too slow
05:50:38 * vixey would say: runST (runErrorT comp)
05:50:51 <alx`> The solution is in the third comment
05:51:05 <nzeh> Well, the problem is that if you use runSTArray, you can only return something of type array
05:52:25 <nzeh> So another part of the rigging will be to declare the transformed ST monad together with STArray to be an instance of MArray, but this only boils down to lifting the appropriate functions.
05:52:50 <vixey> > System.Info.os
05:52:51 <lambdabot>   /tmp/2837570861076185541:70:32: Not in scope: `System.Info.os'
05:52:59 <vixey> , System.Info.os
05:53:00 <lunabot>  luna: Not in scope: `System.Info.os'
05:53:01 <Saizan_> nzeh: you can use freeze to get an array and then runST to exit from the ST computation
05:53:31 <nzeh> Yes.  My last two comments were more in reply to what zachk said.
05:53:49 <nzeh> Anyways, thanks Saizan_.  I'll try your suggestion.
05:55:12 <tomh> @src delete
05:55:13 <lambdabot> delete = deleteBy (==)
06:02:50 <luqui> Workybob, yes
06:03:10 <nzeh> Alright, Saizan_, the problem persists even using runST (runErrorT comp)
06:05:01 <Twey> @hoogle a -> [a] -> Int
06:05:02 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
06:05:02 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:05:02 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:14:14 <zachk> ok, ghci > :module +IO. and it says IO is not loaded and refuses to load IO. did IO get a new name?
06:15:20 <ziman> weird, it works here (ghc 6.10.1); how about `import System.IO' ?
06:16:03 <zachk> ziman: thank you it loads now :D
06:16:09 <Axman6> yeah, i believe System.IO is preferred to just IO (things like IO, List etc are fairly old ways of doing things)
06:16:52 <Athas> In a *ghci* buffer in Emacs, whenever I enter an expression to be evaluated, it will echo the expression back at me, followed by ^J, followed by the actual result.
06:16:54 <doserj> IO is the haskell98 name, before the hierarchical modules addendum. It needs the haskell98 package.
06:17:13 <Athas> This does not happen in a terminal-run ghci, and I use GHC 6.10.1.
06:17:43 <Saizan_> Athas: libedit failure
06:17:48 <zachk> athas: i find emacs evil. long live vim ;-)
06:18:00 <bremner> @quote emacs^J
06:18:00 <lambdabot> emacs^J says: Problems with emacs and ghci6.10.1? try  (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
06:18:15 <Saizan_> or install ghci-haskeline
06:18:39 <kadaver> any swedes here? what time is it?
06:18:40 <bremner> right, whichever is easiest :-)
06:18:41 <vixey> I think that should be a fact or something not a quote
06:19:03 <bremner> vixey: sorry, didn't know how to make facts. feel free...
06:19:08 * vixey neither
06:19:26 <Athas> Thanks.
06:19:27 <Axman6>  @fact+ i think
06:19:31 <Axman6> @fac
06:19:31 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
06:19:43 <Axman6> fact-cons i guess
06:19:53 <Axman6> @help fact-cons
06:19:53 <lambdabot> cons information to fact
06:19:59 <Axman6> @help fact-set
06:20:00 <lambdabot> Define a new fact, guard if exists
06:20:08 <Axman6> ^^
06:20:56 <bremner> ok, here I go
06:21:27 <bremner> @fact-set ^J problems with emacs and ghci6.10.1? try  (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
06:21:28 <lambdabot> Fact recorded.
06:21:42 <bremner> @help forget
06:21:43 <lambdabot> forget nick quote.  Delete a quote
06:21:54 <bremner> @forget emacs^J
06:21:54 <lambdabot> Incorrect arguments to quote
06:22:18 <bremner> @forget emacs^J  Problems with emacs and ghci6.10.1? try  (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
06:22:18 <lambdabot> No match.
06:22:43 * bremner gives up
06:23:47 <vixey> @fact emacs^J
06:23:47 <lambdabot> I know nothing about emacs^j
06:24:46 <wahjava> @fact ^J
06:24:46 <lambdabot> ^j: problems with emacs and ghci6.10.1? try (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
06:26:43 <kadaver> @src concatMaybe
06:26:44 <lambdabot> Source not found. I am sorry.
06:26:49 <kadaver> is there such a function?
06:26:54 <kadaver> foldMaybe?
06:27:02 <Saizan_> catMaybes
06:27:03 <kadaver> @src foldMaybe
06:27:03 <lambdabot> Source not found. That's something I cannot allow to happen.
06:27:16 <Saizan_> well, depends on what you want
06:27:25 <Saizan_> which type should it have?
06:30:03 <kadaver> nevermind that
06:30:29 <Workybob> :) done, I think... http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
06:31:03 <kadaver> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3138#a3138 <- can I use StateMonad for that?
06:31:03 <kadaver> since it is [a] -> ([a],[a]) ?
06:31:13 <linuxhippy> hi
06:31:13 <linuxhippy> is there a useable haskell implementation for the JVM / Java?
06:31:37 <wli> Workybob: I had a feeling someone would eventually cite my code.
06:32:09 <Workybob> wli: ah, is it citable now?
06:32:13 <Workybob> citeable*
06:32:25 <Workybob> this is a post that I've been wanting to do for a while
06:32:29 <jlehto> http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
06:32:30 <Workybob> and you pushed me a little
06:32:43 <Botje> kadaver: you could, but you won't gain much
06:32:47 <wli> Workybob: I figured "how you shouldn't use monad" had to have somethng to do with my code.
06:32:52 <Botje> kadaver: a quicksort, otoh ..
06:32:53 <Workybob> wli: it does
06:33:00 <Workybob> in that it's roughly the point you were making
06:33:01 <Botje> kadaver: try writing it with arrays first
06:33:19 <Botje> then you can take that implementation and write it in State
06:33:21 <Workybob> wli: is there something I can link to as a further reading for your code?
06:33:43 <wli> Workybob: Which in particular?
06:34:02 <Workybob> a blog entry about your applicative parser code or something?
06:34:48 <idnar> I thought parsec already had Applicative instances
06:34:57 <Workybob> it may do in its latest incarnation
06:35:03 <Workybob> it didn't last time I abused it though
06:35:04 <wli> Workybob: There was noise about how bad http://wli.pastebin.com/m581a0765 was, probably others, too.
06:35:23 <kadaver> why quicksort? imtalking about mergesort
06:35:32 <wli> Workybob: I never did any applicative parser code.
06:35:44 <Workybob> wli: oh? maybe it wasn't you
06:35:45 <Workybob> hmm
06:35:47 <Botje> kadaver: yeah, sorry. it just makes more sense to write quicksort using arrays and then state
06:35:50 <Workybob> it was someone with 3 letters
06:36:23 <Botje> you COULD write mergesort using state but it will be pretty ugly
06:36:48 <kadaver> Botje: ok
06:37:01 <Botje> whereas quicksort will become nicer if you write it using state
06:38:20 <vixey>     let ones = 1 :< (ones =>> (extract >>> id))
06:38:20 <vixey>     ones ≡ 1 :< 1 :< 1 :< 1 :< 1 :< ...
06:38:26 <vixey> using comonad really helps there ...
06:38:34 <kadaver> so anyone want to write a browser in haskell and crush chrome and firefox?
06:38:41 <kadaver> :P
06:38:44 * Twey wishes arrays had more convenient APIs
06:38:49 <idnar> oh please not another browser
06:38:59 * Twey think the world has more than enough browsers
06:39:04 <Twey> thinks**
06:39:10 <Twey> ... for this Web, anyway
06:39:11 <Botje> we should've stopped at links
06:39:14 * kadaver thnsk the world has enough browsers too
06:39:25 <Twey> If someone wants to get working on the next generation of the Web, I'm all ears
06:39:32 <Twey> I think it will involve Lua.
06:39:35 <orbitz> who wants to write a lynx-kille rin haskell?
06:39:39 * kadaver wants to come up with a good haskell project
06:39:43 <vixey> lets just go back to sleep nothings happening today -_-
06:39:52 <Twey> kadaver: Could join happstack
06:40:05 <kadaver> lynx?
06:40:09 <kadaver> im gonna write a game
06:40:09 <zachk> who thinks tcp/ip is garbage over crappy wifi connections and would prefer a nice udp system,
06:40:20 <vixey> zachk: I'd rather just have a wire
06:40:23 <orbitz> kadaver: plz tell me you knwo what lynx i
06:40:25 * Twey concurs.
06:40:30 <ckiesch> I've written a sudoku solver in haskell
06:40:33 <ckiesch> That was interesting
06:40:41 <zachk> we would be better off writing a safe-haskell plugin for firefox and overthrow javascript
06:40:41 <Twey> Sudoku solvers are easy with the list monad
06:40:44 <orbitz> i did once too. it was fairly ugly
06:41:00 <Twey> Eh
06:41:03 * kadaver sits and thinks about a game, it will involve levels released one at a time and players will be excited they cant wait to buy the next one. kadaver will be rich, prosperous and a haskell icon.
06:41:04 <Twey> Array of cells
06:41:04 <ckiesch> Ours wasn't brute force either
06:41:08 <vixey> ckiesch: how did you do that?
06:41:17 <ckiesch> It wasn't hard it just took a while :)
06:41:28 <Twey> Apply rules to each cell in turn to reduce the possibilities until there's only one left
06:41:39 <vixey> I like this cryptol sudoku solver
06:41:42 <kadaver> unix textbrowser?
06:41:50 <orbitz> yesm
06:41:52 <ckiesch> vixey: what do you mean how?
06:41:54 * zachk tells kadaver that there is already free to play games that release new levels all the time for free
06:42:05 <vixey> ckiesch: well maybe paste the code I don't know
06:42:11 <vixey> http://www.galois.com/blog/2009/03/18/solving-sudoku-using-cryptol/
06:42:28 <ckiesch> vixey: I don't have it on this machine, that code is at home somewhere
06:43:21 <ckiesch> Though I'm pretty sure we had a structure of [ (row,col,num,[numbers]) ]
06:43:34 <ckiesch> And had methods to get boxes, rows, and columns
06:44:30 <Twey> A list?
06:46:02 <ckiesch> I know ours found all possible solutions on a sudoku puzzle of arbitrary size
06:46:27 <ckiesch> (I had a partner it was a school project)
06:46:50 <wli> I did one but it was so slow it couldn't solve realistic problems.
06:47:24 <vixey> write a sokoban solver
06:47:26 <vixey> that sounds fun
06:47:41 <ckiesch> I know ours was among the fastest in the class.  The faster ones used bit fields rather than lists of possible numbers I think
06:48:57 * Twey sees an application for Bloom filters
06:49:26 <wli> I don't remember much about what my solution looked like. I doubt I could write a solver anymore no matter how slow.
06:49:43 <vixey> wli, for sokoban?
06:49:55 <chessguy_work> by the way, if anyone hasn't seen the video version of SICP (shame on you!) there's a positively brilliant discussion of laziness and purity embedded in it
06:50:19 * kadaver kicks zachk in the groin and tells him those games aint awesome like kadaver-games
06:50:38 <kadaver> chessguy_work: which episode?
06:51:02 <kadaver> i thought sokoban was np-compelte or soemthing
06:51:05 <Twey> Ooooh, video SICP?!
06:51:06 <chessguy_work> 6a and 6b
06:51:08 * zachk begs to play kadaver games if that kick that much ass 
06:51:12 <kadaver> but i guess you could solve some
06:51:17 <chessguy_work> Twey, kadaver : http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
06:51:46 * Twey saves.
06:51:47 <chessguy_work> Twey, kadaver (download links on that page don't seem to work, but the ones on the archive site do)
06:51:48 <wli> I've no idea what sudoku's complexity is, never mind sokoban.
06:52:17 <pao> also "imperative" programming in haskell is fun and robust... :-)
06:52:28 <vixey> I like declarative programming
06:52:34 <Twey> I'd probably get the torrents anyway
06:52:39 <zachk> i like programming
06:52:39 <Twey> vixey: Don't we all
06:52:39 <ckiesch> I only gave my solver an empty starting board once :P  That took a long time
06:52:40 <kadaver> sure
06:52:46 <kadaver> but which epoisode is the laziness in?
06:52:50 <chessguy_work> i remember being quite perplexed when i watched SICP a year or two ago. having studied haskell though makes it much easier
06:53:07 <chessguy_work> kadaver, i told you the lecture numbers
06:53:42 <kadaver> Explicit-control Evaluator ?
06:53:46 <zachk> ckiesch: if you made your solver right that would give back a list of every possible and complete sudoku boards :-D
06:53:51 <kadaver> ah
06:53:54 <ckiesch> Yes it did
06:53:55 <ckiesch> lol
06:54:06 <millz> chessguy_work, good stuff. shame they are on full load atm
06:54:09 <chessguy_work> looks like it's also in the book version, starting at http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5
06:54:12 <zachk> did you run a length on it to see how many there were?
06:54:24 <chessguy_work> millz, pesonally, i just streamed it and watched it there
06:54:31 <ckiesch> No I might have cancelled it some way in
06:54:35 <chessguy_work> millz, (from the archive site)
06:54:43 <millz> ah
06:54:44 <millz> ye thanks
06:55:06 <millz> im not remotely itnerested in lisp
06:55:11 <millz> but other topics seem fun
06:55:20 <zachk> ckiesch: im writing a solver to find the shorcut polynomials to f p=sum.map (^p).enumFromTo 1
06:55:20 <chessguy_work> the whole series is of course very much worthwhile, but i was practically on the edge of my seat during the streams lectures
06:55:27 <chessguy_work> millz, why is that?
06:55:49 <millz> oh come on
06:55:59 <andyou> lisp<3
06:56:00 <millz> who would like to write in programming languazge that is over half century opld
06:56:02 <millz> :P
06:56:07 <chessguy_work> heh
06:56:11 <millz> sides logic programming is good for robots
06:56:11 <zachk> ckiesch: at p=4 it is taking at least half an hour. so i need a faster method if i want to get past 10
06:56:13 <millz> and im not one  ;P
06:56:23 <chessguy_work> uh
06:56:23 <zachk> millz: whats sides logic
06:56:25 <ckiesch> haha ouch
06:56:30 <chessguy_work> lisp is not logic programming....
06:56:32 <millz> do you mean that hey were so itneresting by 'edge of seat' chessguy_work ?
06:56:32 <ckiesch> I have no idea :)
06:56:40 <millz> ofc it is
06:56:49 <millz> i had some parts of it on computation and logic course
06:57:02 <millz> the lecturer showed sudoku solver
06:57:07 <millz> written as FSM
06:57:11 <millz> looked so crap
06:57:18 <millz> ill just stick to haskell :P
06:57:19 <Twey> chessguy_work: Depends what you build on top of it :)
06:57:36 <chessguy_work> Twey, no argument there. i'm talking about intrinsic nature of course
06:58:01 <Twey> It doesn't really have an intrinsic nature... I think that was the design ideal
06:58:31 <orzo> hello
06:58:36 <chessguy_work> well it doesn't ship with operations that are specifically for doing logic programming
06:58:39 * Twey waves.
06:58:45 * Botje particles
06:58:45 <Twey> chessguy_work: Depends on the Lisp
06:58:47 * kadaver slpas millz, Lisp has brought so many ideas to the programming world and there are new Lisps, like Clojure(that in turn is inspired by haskell to some extent)
06:58:50 <chessguy_work> Twey, really?
06:58:51 <orzo> so i want to build ghc as 64 bit
06:58:53 <orzo> for os x
06:58:56 * Twey is Botje?
06:59:01 <orzo> that might take some doing i understand
06:59:05 <millz> I know it did kadaver
06:59:11 <chessguy_work> Twey, got an example?
06:59:13 <Botje> Twey: ask our observer(s) :]
06:59:18 <millz> I agree it is a  base for modern programming languages
06:59:19 <alx`> Workybob : did you write the "How you shouldn't use a monad" blog entry ?
06:59:21 <orzo> anybody willing to help with that?
06:59:24 <Workybob> alx`: yes
06:59:27 <millz> but I disagree about its usefulness in current era
06:59:41 <Twey> chessguy_work: There's nothing stopping someone from building a Lisp with declarative functions in the standard libraries
06:59:50 <alx`> It's very interesting, but you loose me with : "f <*> a = f >>= (\fv -> a >>= (pure . fv))"
06:59:55 <Twey> I don't know if there's one already out there... I would imagine there probably is
06:59:58 <chessguy_work> Twey, i'm not talking about what's _possible_
07:00:06 <chessguy_work> i'm talking about what _is_
07:00:08 <Workybob> alx`: it might be easier if you look at the version in do notation just below
07:00:23 <chessguy_work> i don't know of a popular lisp that ships with such operations, taht's all i'm saying
07:00:25 <orzo> i understnad i need ghc to build ghc, can i use 32bit ghc to build 64 bit ghc?
07:00:26 <alx`> it's just putting a "box" around (f v) ?
07:00:26 <vixey> preflex: seen jkff
07:00:36 <alx`> sorry, (f a)
07:00:45 * Twey points out that Liskell has a list monad
07:00:49 <Workybob> alx`: it's taking f and a out of their boxes, apply them, and putting them back in a box
07:00:59 * chessguy_work sighs
07:01:21 <chessguy_work> seems like #haskell is going the way of other IRC channels
07:01:28 <vixey> seems like chessguy is whining
07:01:30 <alx`> ah ! the "fv <- f" is not obvious, there is a "get out of the box" operation there...
07:01:39 <Twey> chessguy_work: How's that?
07:02:10 <chessguy_work> more noise and trolls than serious conversation
07:02:27 <alx`> Thank you for your exlanation...I guess I will need time to get used to the "non-do" version of things
07:02:29 <chessguy_work> it's not there yet, but moving that direction
07:02:31 <Twey> x.x
07:02:32 <Workybob> alx`: every (>>=) is essentially a "take it out of its box" operation
07:02:43 * Twey was conversing seriously — sorry if he's not smart enough :)
07:02:57 <vixey> looked to me like people didn't bend over backwards for you, so you threw a fit
07:03:08 <chessguy_work> no serious computer scientist would really disagree that lisp isn't inherently functional
07:03:11 <chessguy_work> err
07:03:16 <chessguy_work> isn't inherently a logic programming language
07:03:37 <p_l> chessguy_work: isn't inherently "wtf programming language"
07:04:02 <Workybob> chessguy_work: tbh, what makes me enjoy #haskell is that you're allowed to challenge assumptions like that without getting told "no serious xyz would thing abc"
07:04:02 <Twey> chessguy_work: That's because Lisp isn't inherently a programming language
07:04:03 <alx`> Workyboy: and we want to take things out of boxes just because if we don't, it gets very inconvenient to write, right ? (I am thinking about programmation with Maybe)
07:04:11 <p_l> chessguy_work: aka, you'll get wtf language you want after some time :)
07:04:32 <Twey> It is a family of languages, or perhaps it's better to call it a language-building philosophy
07:04:34 <Workybob> alx`: well, we want to colapse stacks of boxes down into one box
07:04:48 <Workybob> we don't want to end up dealing with a Maybe (Maybe (Maybe (Maybe (Int)))))
07:05:00 <Workybob> join lets us just make that a Maybe Int
07:05:00 <Twey> And it's a philosophy which is as much declarative as it is functional or procedural
07:05:01 <alx`> of course :-)
07:05:14 <Twey> It's just a matter of providing the right functions
07:05:19 <p_l> I found a book lately that taught FP using a strictly functional variant of lisp, with a compiler attached at the end. type it into a CL system and you got your FP langauge :D
07:05:30 <chessguy_work> declarative is different from a logic programming language
07:05:39 <vixey> cool
07:06:16 <chessguy_work> Twey, i understand that, as i've said several times. i'm talking about what ships with most popular lisps
07:06:57 <p_l> chessguy_work: define "most popular". Elisp?
07:07:37 <chessguy_work> elisp is domain-specific
07:07:54 <p_l> chessguy_work: it's also the most popular along with AutoLISP
07:08:43 <p_l> then you get the fractured world of scheme and CL, where stepping outside standard can have weird effects :P
07:08:54 <wchogg> I'm assuming chessguy_work meant something like SBCL implementation of CL?
07:09:25 <Twey> Presumably
07:10:02 <chessguy_work> sure
07:10:25 <millz> Workybob, nice article. however, are you sure that putting things in order in do notation doesnt oblige the runtime to evaluate them in this manner?
07:10:34 <Workybob> yes
07:10:38 <drdozer> Loading package hsmagick-0.3 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
07:10:48 <drdozer> and I thought I had done so well :(
07:10:56 <millz> hmm, that would pretty much kill all the imperativeness of it
07:10:58 <millz> ;o
07:11:06 <Workybob> > let c = do { a <- undefined; b <- Just 5; return b } in c
07:11:08 <lambdabot>   * Exception: Prelude.undefined
07:11:12 <Workybob> oh duh
07:11:14 <Workybob> it does in Maybe
07:11:17 <Workybob> which monad is lazy
07:11:18 <Workybob> ...
07:11:26 <zachk> @src <*>
07:11:26 <lambdabot> Source not found. Maybe you made a typo?
07:11:27 <drdozer> millz: haskell will run things out of order even from do blocks - it only forces an order if the underlying monad chooses to
07:11:32 <millz> Maybe is lazy?
07:11:38 <Workybob> no, the Maybe monad isn't
07:11:41 <millz> i dont mean the state encapsulation
07:11:42 <Workybob> which is why that came  back undefined
07:11:49 <millz> i mean the bidning of functions
07:11:57 <millz> ah
07:12:07 <zachk> > [(^2)] <*> [1..5]
07:12:09 <lambdabot>   [1,4,9,16,25]
07:12:10 <millz> that makes sense
07:12:57 <kadaver> was Prolog ever really used for real pplications? a lot of expert systems?
07:12:58 <drdozer> any idea what my linking exception means?
07:13:22 <Workybob> millz: the classic example that people fall into is that the IO monad is lazy
07:13:26 <drdozer> kadaver: it's being used in systems biology now to reason about large biological systems e.g. all the chemistry that goes on in a single cell
07:13:33 <Workybob> so if you ask that b <- getContents "someFile"
07:13:37 <zachk> > (map (\p->(^p) [1..3]) <*> [1..5]
07:13:38 <lambdabot>   <no location info>: parse error on input `;'
07:13:39 <Workybob> that file won't be closed
07:13:45 <Workybob> until all your computation is finished
07:13:48 <Workybob> because it's not read then
07:13:54 <Workybob> it's read only when the data in it is needed
07:13:58 <zachk> > (map (\p->(^p)) [1..3]) <*> [1..5]
07:13:59 <lambdabot>   [1,2,3,4,5,1,4,9,16,25,1,8,27,64,125]
07:14:23 <millz> hmm
07:14:25 <millz> itneresting
07:14:30 <zachk> > nub $ sort $ (map (\p->(^p)) [1..3]) <*> [1..5]
07:14:31 <lambdabot>   [1,2,3,4,5,8,9,16,25,27,64,125]
07:14:33 <millz> i didnt know they could make monad's lazy
07:14:43 <vixey> millz: the whole LANGUAGE is lazy
07:14:52 <Workybob> millz: well, the point of that article is to point out that Monads are not special
07:14:54 <drdozer> millz: most monads are vanilla haskell, so lazy is the default option
07:14:55 <Workybob> they're not magical either
07:14:56 <millz> does it work like, keeping the state inside the monad, and just dealing with laziness outside it in normal haskell way?
07:14:57 <ckiesch> I'm lazy
07:14:58 <Workybob> they're just functions
07:15:04 <zachk> millz: the laziness lets you do things like this
07:15:16 <millz> I know ST monad is written in C
07:15:22 <millz> because it cant be written in haskell :P
07:15:27 <Workybob> yes it can
07:15:30 <Workybob> it's just not very efficient
07:15:35 <zachk> > take 10 $ map (^2) [0..]
07:15:36 <lambdabot>   [0,1,4,9,16,25,36,49,64,81]
07:15:37 <millz> really?
07:15:43 <Workybob> ofc
07:15:44 <millz> how would you emulate state ?
07:15:56 <Workybob> store it in a record that I pass along with the currently evaluated value
07:16:49 <millz> also, is binding moer than one operations taht are done inside monad, or only after getting the value of them?
07:17:19 <millz> ah true, but then the state has to be passed to all functions
07:17:25 <millz> good stuff, thanks
07:17:27 <Workybob> binding is just another function
07:17:51 <vixey> millz: you could use State monad to implement ST monad
07:17:51 <vixey> millz: but the direct implementation uses mutation for better efficienc
07:18:00 <drdozer> millz: http://cat.inist.fr/?aModele=afficheN&cpsidt=17413611
07:18:00 <Workybob> a `bind` f = join (fmap f a) -- as I pointed out in the article
07:18:16 <zachk> > join [[1..3],[5..10],[12,2..20]]
07:18:18 <lambdabot>   [1,2,3,5,6,7,8,9,10]
07:18:20 <Workybob> I'm glad
07:18:29 <zachk> Workybob: that was a good article
07:18:38 <Workybob> I appear to have hit the nail on the head with the response I wanted
07:18:49 <Workybob> some people realising that Monads are not special or magical :)
07:18:54 <zachk> > join [[1..3],[5..10],[12..20]]
07:18:56 <Workybob> zachk: thanks :)
07:18:56 <lambdabot>   [1,2,3,5,6,7,8,9,10,12,13,14,15,16,17,18,19,20]
07:19:27 <zachk> > join [[1..3],[5..10],[12,14..20]]
07:19:28 <lambdabot>   [1,2,3,5,6,7,8,9,10,12,14,16,18,20]
07:20:07 <millz> but if you hold a list in a monad, and then get it using <-, it woul dreturn whole list, not just the head and lazily evaluate the tail right?
07:20:14 <alx`> I agree with zachk, that was a good article ! As a beginning Haskell programmer, I definitely need such resources to "demystify" this Monad thing which looks a bit confusing at first...
07:20:17 <zachk> Workybob: i thought haskell was pure magic for about a year. till i was getting NaN and Inf on floating points, and i just had to change the order of my operations and they went away
07:20:21 <vixey> monads are special
07:20:21 <vixey> some of them are magical
07:20:21 <vixey> (IO and ST)
07:20:51 <zachk> alx`: learn the io monad first, then learn the maybe, then the list
07:20:55 <Workybob> IO and ST aren't magical – they just involve foreign calls (sometimes into the runtime)
07:20:57 <kadaver> Workybob: please post your article again
07:21:08 <Workybob> kadaver: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
07:21:38 * kadaver hugs chess_guy and tells him thinsg will be alright, the trolls will be converted toupstanding member sof the haskell community
07:21:40 <koala_man> I really like how there are several examples of each (and with actual output)
07:22:00 <Workybob> :)
07:22:05 * kadaver hugs chess_guy and tells him things will be alright, the trolls will be converted to upstanding members of the haskell community. (and kadaver will also learn to spell).
07:22:43 <millz> what I love in haskell, besides the language, is this channel - where after asking a simple question you get answers ranging from cathegory thoery, through theoretical CS, ending with some badass examples
07:22:47 <millz> ^^
07:22:53 <zachk> > nub $ sort $ (map (\p->(^p)) [1..3]) <*> [1..5]
07:22:54 <lambdabot>   [1,2,3,4,5,8,9,16,25,27,64,125]
07:25:30 <zachk> @src sort
07:25:31 <lambdabot> sort = sortBy compare
07:25:41 <zachk> @src sortBy
07:25:41 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
07:25:57 <zachk> @src nub
07:25:58 <lambdabot> nub = nubBy (==)
07:26:08 <zachk> interesting
07:26:15 <millz> foldr ftw
07:26:29 <zachk> millz: ftw?
07:26:52 <vixey> foldr uber alles
07:27:10 <zachk> > sum [1..10]==foldr (+) 0 [1..10]
07:27:12 <lambdabot>   True
07:28:29 * zachk welcomes kadaver back
07:36:35 <bastl> hi. what is the state-of-the-art tool(package to generate nice latex code from haskell-sources ?
07:36:37 * kadaver jumps on his bike with a shotgun, planning to take out my ISP.
07:36:45 <wli> bastl: lhs2TeX?
07:40:51 <vixey> so did anyone do an efficient comonadic impl. of life?
07:41:25 <bastl> wli: but i dont have literate haskell ..
07:42:12 <wli> bastl: There is no distinct "literate Haskell." If you have ghc or any other Haskell compiler, you have literate Haskell.
07:42:36 <quicksilver> I assume he means his hs doesn't contain any literate comments.
07:42:44 <quicksilver> if you just want to embed some hs source and have it look nice
07:42:49 <bastl> yup.
07:42:52 <quicksilver> then I think the listings environment has some haskell support.
07:42:58 <quicksilver> and whatever lhs2TeX uses does.
07:43:07 <bastl> ok, then thats easiest
07:47:35 <millz> zachk, for the win
07:47:38 <kadaver> lhs2TeX , wher eis this program?
07:48:11 <C-Keen> > 1/0
07:48:12 <lambdabot>   Infinity
07:48:22 <C-Keen> :t Fractional
07:48:23 <lambdabot> Not in scope: data constructor `Fractional'
07:48:27 <Anthraxx> kadaver: http://people.cs.uu.nl/andres/lhs2tex/
07:49:25 <MiniCow> Any idea why I get "Not in scope: type variable 'a'" for this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3140#a3140
07:49:46 <quicksilver> MiniCow: because the type variable a is not in scope!
07:49:48 <quicksilver> (I win)
07:49:59 <MiniCow> No, hadn't guessed that ;-)
07:50:05 <MiniCow> How should I write it
07:50:05 <quicksilver> MiniCow: maybe you meant 'Box a' on the left of the equal sign?
07:50:15 <millz> C-Keen, i believe that type is called RealFrac
07:50:19 <millz> or something lik e that
07:50:25 <vixey> MiniCow: data Box a = Box {size, weight :: a} deriving (Show)
07:50:42 <C-Keen> :t RealFrac
07:50:43 <lambdabot> Not in scope: data constructor `RealFrac'
07:50:44 <MiniCow> Ok, cheers people. I get it
07:50:49 <C-Keen> :t RealFraction
07:50:50 <lambdabot> Not in scope: data constructor `RealFraction'
07:50:54 <quicksilver> MiniCow: it's also true that contraints on data types are not recommended.
07:50:57 <quicksilver> they don't really work.
07:51:00 <C-Keen> ah no RealFloat it is
07:51:03 <millz> http://www.zvon.org/other/haskell/Outputprelude/RealFrac_c.html
07:51:05 <quicksilver> and they're a bad idea more often than not :)
07:51:05 <millz> RealFloat is a class
07:51:28 <MiniCow> quicksilver: So best to lock it down to a proper type?
07:51:36 <quicksilver> no.
07:51:44 <quicksilver> best to leave it fully polymorphic.
07:51:49 <quicksilver> as in vixey's version.
07:52:00 <MiniCow> ok
07:52:27 <MiniCow> quicksilver: is there a long drawn out explanation for that? :-)
07:52:40 <vixey> MiniCow:  data Box a = ...  is good
07:52:40 <vixey> any functions that make use of Floating a will have that thank to type inference
07:53:33 <kadaver> Haskell is the first language to get error handling right
07:54:10 <quicksilver> MiniCow: haskell doesn't give you the type class "back" ewhen you destruct a box
07:54:22 <quicksilver> MiniCow: so you end up needing the constraint anyway.
07:54:34 <quicksilver> GHC does, if you put the constraint on the constructor not the whole type
07:54:41 <quicksilver> that's technically part of the GADT extension.
07:54:55 <quicksilver> as a design point, it's normally useful to have these things be fully polymorphic
07:55:06 <quicksilver> you may later find a use for Box (Maybe Float)
07:55:11 <quicksilver> or Box(Float -> Float)
07:56:36 <MiniCow> quicksilver: Certainly see the usefulness of leaving it fully polymorphic.
07:56:56 <MiniCow> Not sure about the destructing part, but I guess it's something ou run into when you write code that way.
08:03:57 <vixey> > 1+1
08:04:06 <lambdabot>   2
08:08:47 <Badger> > 1 + 0.5
08:08:48 <lambdabot>   1.5
08:10:19 <quicksilver> > 1000000000 + 0.0000000001
08:10:21 <lambdabot>   1.0e9
08:10:40 <kadaver> anyone here heard of Jim Penelope-Simons?
08:11:20 <Badger> @type 1 + 0.5
08:11:21 <lambdabot> forall t. (Fractional t) => t
08:11:42 <vixey> :t 1
08:11:43 <lambdabot> forall t. (Num t) => t
08:11:44 <vixey> :t 0.5
08:11:45 <lambdabot> forall t. (Fractional t) => t
08:12:06 * Badger hugs lambdabot.
08:14:07 <quicksilver> kadaver: sounds like it ought to be an anagram of Simon Peyton Jones. It isn't though.
08:18:51 <wli> Anagram generators sound like integer linear algebra.
08:19:49 <aivuk> argh! why some modules the types appear like libname-version:Type instead of just Type?
08:20:37 <quicksilver> they're always like that, underneath
08:20:44 <quicksilver> GHC hides it from you unless it needs to show you
08:20:54 <quicksilver> -- to explain an error which otherwise wouldn't make sense.
08:21:34 <kadaver> hmm, to make anagrams out of names, how would you do? create all permutations of a name and match against a name-dictionary?
08:21:50 <quicksilver> yes.
08:21:55 <quicksilver> that's what /usr/games/an does
08:23:42 <kadaver> is there permutations in haskell already?
08:23:49 * kadaver goes to hackage
08:24:12 <wli> I'd make equivalence classes of words and phrases out of letter count, then generate all partitions of the letter count using dictionary matching to prune the search.
08:24:41 <dolio> Permutations of what? Lists?
08:24:45 <dolio> @hoogle permutations
08:24:45 <lambdabot> No results found
08:24:56 <Ignatyeva> it's easy to write
08:25:08 <dolio> It's in base4, I think.
08:25:23 <wli> So it's basically multiset partitions.
08:25:24 <Ignatyeva> @type Data.List.permutations
08:25:25 <lambdabot> Not in scope: `Data.List.permutations'
08:25:25 <paolino> Data.List.Permutations
08:25:41 <kadaver> permute a string
08:25:42 <dolio> > permutations [1..3]
08:25:43 <lambdabot>   Not in scope: `permutations'
08:25:56 <kadaver> wli->wil,iwl...liw
08:25:56 <dolio> , permutations [1..3]
08:25:57 <lunabot>  luna: Not in scope: `permutations'
08:26:09 <dolio> Huh.
08:26:32 <Ignatyeva> a `isAnagramOf` b = (sort a) == (sort b)
08:26:46 <aivuk> quicksilver: but the problem is, ghc isn't correctly type checking when the types appear with the version.
08:27:27 <wli> > Map.fromListWith (+) . map Map.singleton 1 . filter (not . isSpace) $ "simon peyton jones"
08:27:28 <lambdabot>   Couldn't match expected type `b -> c'
08:27:29 <paolino> ... someone eliminated permutations function from bots to force exercising
08:27:30 <Ignatyeva> anagrams x = filter ((== (sort x)) . sort) dictionary
08:27:34 <aivuk> but when i copy excatly the same code of the lib in my code, the types checks ok
08:27:46 <wli> > Map.fromListWith (+) . map (Map.singleton 1) . filter (not . isSpace) $ "simon peyton jones"
08:27:47 <lambdabot>   Couldn't match expected type `(k, a)'
08:28:15 <wli> > Map.unionsWith (+) . map (Map.singleton 1) . filter (not . isSpace) $ "simon peyton jones"
08:28:16 <lambdabot>       No instance for (Num Char)
08:28:16 <lambdabot>        arising from a use of `+' at <interac...
08:28:39 <wli> Okay, sure.
08:29:54 <QtPlaty[HireMe]> Is there any way to step through or trace haskell code (i'm using ghc)
08:30:47 <paolino> :trace
08:31:27 <QtPlaty[HireMe]> When did that get introduced?
08:32:23 <paolino> 6.8.x I guess
08:32:32 <QtPlaty[HireMe]> Thanks.
08:36:05 <kadaver> Construct a permutation from a list of elements. listPermute n is creates a permutation of size n with the ith element equal to is !! i. For the permutation to be valid, the list is must have length n and contain the indices 0..(n-1) exactly once each.
08:36:10 <kadaver> listPermute :: Int -> [Int] -> Permute
08:36:17 <kadaver> listPermute 10 [1..10]
08:36:23 <kadaver> listPermute *** Exception: invalid permutation
08:36:24 <kadaver> huh?
08:36:29 <kadaver> http://hackage.haskell.org/packages/archive/permutation/0.4.1/doc/html/Data-Permute.html#v%3AlistPermute
08:37:13 <wli> Anyway, you have a linear algebraic basis for the space of new words to try. I'd search within the span of that basis for sub-multisets of the remaining portion of the word to find anagrams of, then recurse on the orthogonal complement of the new word and the remaining portion of the multiset.
08:38:24 <wli> The initial basis would be (of course) singletons of one letter for each letter.
08:38:27 <rio> kadaver: listPermute 10 [0..9]
08:38:41 <quicksilver> aivuk: no.
08:38:49 <quicksilver> aivuk: the problem is it has two different versions of the package.
08:39:07 <rio> kadaver: For the permutation to be valid, the list is must  have length n and contain the indices 0..(n-1) exactly once  each.
08:39:12 <quicksilver> probably
08:39:19 <quicksilver> two different types with the same name, certainly.
08:41:28 <draq1587> how do I add two lists together?
08:41:40 <draq1587> [1, 2] + [2, 3] = [1, 2, 2, 3]
08:41:41 <draq1587> ?
08:41:42 <wli> At each step you'd need to not just find a solution to the integer linear inequalities but also check against the dictionary.
08:41:45 <ejt> draq1++
08:41:46 <Petrosian> draq1587: (++)
08:41:51 <draq1587> thanks
08:41:54 <Petrosian> > [1..5] ++ [1,2,3]
08:41:56 <lambdabot>   [1,2,3,4,5,1,2,3]
08:42:21 <plash_> > [1,2] `mappend` [2,3]
08:42:22 <lambdabot>   [1,2,2,3]
08:42:27 <Ignatyeva> @type mappend
08:42:29 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:42:34 <Ignatyeva> @describe Monoid
08:42:34 <lambdabot> Unknown command, try @list
08:42:38 <Ignatyeva> bah
08:44:54 <wli> If your dictionary is small enough, the initial linear space may not be the whole space of N^26 (or whatever).
08:50:34 <wli> I guess you could also factor out common factors of multiplicities. I'm thinking you get a sort of multiset of multisets.
08:53:30 <drdozer> does Tim Chevalier hang out here?
08:59:12 <kadaver> rio: 10 [0..9] doesnt owrk
08:59:23 <rio> kadaver: hm
08:59:27 <kadaver> oh it did
09:01:37 <kadaver> so i think i have a need for some State abstraction
09:02:37 <kadaver> call next on xs,fromMaybe it and next again
09:02:44 <kadaver> i can loop that
09:03:04 <kadaver> butsomething like: take n $ repeat $ permuteState xs
09:03:05 <kadaver> possible?
09:09:15 <pumpkin> kadaver: ?
09:09:44 <kadaver> well if monads are s great cant the bastards solve my problem?
09:10:16 <kadaver> next $ next $ next Permute
09:10:21 <quicksilver> probably yes
09:10:26 <quicksilver> but we didn't understand the question
09:10:30 <kadaver> instead I want some abstraction
09:10:37 <kadaver> repeat 5 $ next Permute
09:10:40 <quicksilver> which pumpkin eloquently but briefly expressed with the ideograph '?'
09:10:53 <pumpkin> quicksilver: !
09:11:17 <quicksilver> you could make something like runMyMonad { next ; next ; next; } work
09:11:18 <kadaver> !?
09:11:32 <quicksilver> that syntax isn't right ;)
09:11:32 <wli> Yeah, you're basically finding inverses of Map.unionsWith (+) . Map.elems . Map.mapWithKey (\m k -> Map.map (*k) m)
09:11:34 <pumpkin> kadaver: 肛
09:11:43 <quicksilver> runMyMonad ( do { next ; next ; next ; ) }
09:12:10 <pumpkin> lol
09:12:39 <pumpkin> kadaver: I guess I joined too late
09:12:43 <pumpkin> but I have no context
09:12:59 <quicksilver> pumpkin: no context? you need a comonad!
09:13:02 <quicksilver> maybe conal has a spare one.
09:13:03 <pumpkin> lol
09:13:07 <kadaver> can haskell beat Sylar in a fight?
09:13:15 <kadaver> @faq can haskell beat Sylar in a fight?
09:13:15 <lambdabot> The answer is: Yes! Haskell can do that.
09:13:39 <mmorrow> @faq can haskell's dad beat up anybody else's dad?
09:13:39 <lambdabot> The answer is: Yes! Haskell can do that.
09:13:56 <wli> The linear algebraic thing is wrong. Multiples are not equivalent.
09:15:17 <wli> It's only exact matches that matter.
09:16:09 <quicksilver> conal: that's a very interesting thing about joinE and catMaybesE
09:16:15 <quicksilver> conal: I will try it in my reactive implementation
09:16:54 <conal> :)
09:17:02 <seliopou> join #thrift
09:17:07 <Badger> no
09:17:12 <seliopou> erm
09:17:13 <seliopou> sry
09:17:15 <Badger> :P
09:17:15 <pumpkin> lol
09:18:22 <seliopou> really should join channels automatically
09:23:09 <pumpkin> http://www.hxa.name/minilight/#comparison mmm this needs some lambda
09:25:32 <quicksilver> pumpkin: ocaml 2.7x slower than C smells wrong, too
09:26:23 <quicksilver> as in, not very cleverly written ocaml
09:26:23 <pumpkin> http://eigenclass.org/R2/writings/minilight-cleanup too
09:26:27 <draq1587> if I have a list of a self-defined type say [One, Two, Three, Four]
09:26:34 <draq1587> how do I get a random value of it?
09:26:49 <pumpkin> quicksilver: that post made it faster than c++
09:27:13 <pumpkin> it's tempting to start a haskell version
09:27:29 <dmhouse> Hey all. I'm getting some errors trying to install X11 using cabal-install: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3145#a3145
09:27:32 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
09:28:15 <erikc> i took a look at that minilight stuff this weekend coincidentally, both the C++ and Ocaml code are pretty naive
09:28:16 <dmhouse> "Could not find module `Data.Generics': it is a member of package base-3.0.3.0, which is hidden" -- anyone got any idea what could cause this?
09:28:51 <doserj> dmhouse: if you use base-4, you have to use syb
09:29:22 <dmhouse> doserj: so if I hid base-4 it'd likely work?
09:29:38 <doserj> yes
09:29:43 <Badger> dmhouse: X using cabal? o_O
09:29:44 <pumpkin> erikc: yeah, apparently the ocaml one was using big ifs instead of pattern matching, and making it prettier with pattern matching also made it faster than the c++ version
09:30:06 <pumpkin> doesn't sound like the people involved were terribly aware of performance issues for their languages
09:30:24 <dmhouse> doserj: well doing "ghc-pkg hide base-4.0.0.0" then "cabal install X11" gives the same error.
09:30:30 <dmhouse> Badger: that not work?
09:30:31 <quicksilver> surely there is no way changing an if to a case gives a 2.7x speedup?
09:30:42 <quicksilver> maybe if it was in a tight inner loop?
09:30:44 <draq1587> would anyone answer my humble question?
09:30:51 <pumpkin> quicksilver: he changed a few other things too, but nothing too substantial I could see
09:30:56 <Badger> dmhouse: no ide
09:30:56 <Badger> a
09:31:07 <quicksilver> draq1587: pick a random number from 0 to length of list
09:31:10 <quicksilver> draq1587: select element
09:31:12 <quicksilver> draq1587: profit!
09:31:13 * Badger didn't know cabal was an allpurpose package manaer?
09:31:15 <proq> sure, I've gotten better speedups than that changing even simpler things
09:31:17 <doserj> dmhouse: what does ghc-pkg list base give? and how does the .cabal file for X11 look like?
09:31:28 <draq1587> how do I pick a random number?
09:31:33 <draq1587> randomR g a
09:31:44 <draq1587> as far as I have read in the api
09:31:54 <draq1587> and what is the random number generator g?
09:32:01 <Badger> ah-ha
09:32:04 <proq> such as if foo then begin bar end vs. if foo then bar
09:32:05 <quicksilver> you can get one in IO using 'getStdGen'
09:32:06 * Badger gets it.
09:32:07 <doserj> @hoogle StdGen
09:32:07 <lambdabot> System.Random data StdGen
09:32:07 <lambdabot> System.Random getStdGen :: IO StdGen
09:32:07 <lambdabot> System.Random mkStdGen :: Int -> StdGen
09:32:11 <pumpkin> quicksilver: the if version constructed an object, did a comparison with the known object, and branched based on that... that invovles the GC and generally quite a bit more work than is needed... just pattern matching reduces that a lot
09:32:12 <quicksilver> or you can make your own as in "mkStdGen 424242"
09:32:21 <dmhouse> doserj: /usr/local/lib/ghc-6.10.1/./package.conf:    base-3.0.3.0, (base-4.0.0.0)
09:32:24 <proq> gave me a 5x speedup
09:32:27 <quicksilver> (then your numbers will be the same each run, of course)
09:32:32 <pumpkin> @src StdGen
09:32:32 <lambdabot> Source not found. My brain just exploded
09:32:36 <proq> with a certain compiler which shall remain nameless
09:32:45 <pumpkin> @src getStdGen
09:32:45 <lambdabot> Source not found. My mind is going. I can feel it.
09:32:53 <pumpkin> is it just mkStdGen with the current time?
09:32:53 <draq1587> quicksilver: thanks
09:33:10 <quicksilver> pumpkin: no; it accesses a global variable from within IO
09:33:15 <pumpkin> :o
09:33:18 <dmhouse> doserj: "base >= 3 && < 4" from X11.cabal
09:33:28 <quicksilver> pumpkin: mkStdGen with the current time is roughly what newStdGen does though
09:33:35 <pumpkin> ah
09:33:43 <pumpkin> too much stdGenning for me
09:35:17 <doserj> dmhouse: hmmm. that looks strange. who hides base-3.0.3.0?
09:36:14 <dmhouse> doserj: hmm, interestingly, it seems to be installing X11-1.4.2, when the latest version available is 1.4.5
09:38:52 <doserj> X11-1.4.2 doesn't have version constraints in its dependencies...
09:39:21 <dmhouse> Also:
09:39:22 <dmhouse> cabal install X11-1.4.5
09:39:22 <dmhouse> Resolving dependencies...
09:39:22 <dmhouse> cabal: There is no available version of X11 that satisfies ==1.4.5
09:40:11 <doserj> dmhouse: you did cabal update?
09:41:42 <dmhouse> doserj: ah, that's done the trick, thanks!
09:45:26 <conal> i'm getting a reality check on a blog comment.  what do you mean when you label a Haskell module as "portable"?  and what do understand the author to have meant when you read the label "portable" on a module?
09:45:56 <beelsebob> Oh yay, top of the Haskell reddit today :)
09:45:59 <quicksilver> conal: works on windows, mac and osx
09:46:08 <wli> There's a Haskell reddit?
09:46:16 <beelsebob> quicksilver: I assume one of them was meant to be linux
09:46:21 <beelsebob> there is wli http://www.reddit.com/r/haskell/
09:46:22 <quicksilver> beelsebob: yes, thanks.
09:46:32 <conal> quicksilver: thx.  do you expect any kind of consistency?
09:47:19 <mmorrow> conal: i read "portable" as "portable across haskell compilers"
09:47:20 <FunctorSalad> conal: apparently in haddock it means "works on all compilers/haskell 98 only"
09:47:22 <quicksilver> conal: althoguh I suspect what it's supposed to indicate is ability to compile under various haskell dialects.
09:47:30 <FunctorSalad> (I found that confusing at first)
09:47:35 <quicksilver> conal: in other words, my interpretation is wrong ;)
09:47:47 <inimino> "windows, mac and osx"?
09:47:59 <pumpkin> conal: I understand portable as "behaving the same way across compilers/implementations/OSes" and not just "working"
09:48:04 <conal> quicksilver, mmorrow:  any interpretation of consistency between platforms.
09:49:13 <quicksilver> inimino: that was a typo ;)
09:49:28 <inimino> quicksilver: oh ;)
09:49:36 <mmorrow> conal: not particularly
09:49:45 <conal> mmorrow: thx.
09:49:47 <inimino> conal: isn't it context dependent?
09:49:51 <mmorrow> conal: well, i always assume the target platform is unix.
09:50:19 <conal> inimino: yeah, thanks.  the context i mean is the portability field for a module.  the one that haddock uses.
09:50:27 <pumpkin> a library isn't much use if it claims to be cross-platform but unsafeHelloWorld means putStrLn "Hello world!" on one platform and unsafeLaunchICBM on another
09:50:42 <inimino> "Foo is written in portable Haskell 98" probably doesn't mean the same thing as "portable FilePath implementation"
09:51:22 <conal> pumpkin: yeah.  that distinction what i've started to call standard in form (signature) vs standard in substance (meaning).
09:51:57 <conal> inimino: yeah.  the FilePath thing is an interesting example.  the implementation differences are about getting to the same semantics.
09:53:55 <pumpkin> anyone have the link to base haddock with source links?
10:00:18 <mightybyte> ghc: My brain just exploded.
10:00:25 <mightybyte> That's hilarious
10:01:12 <bremner> > let x = 3 in 3*x where x=4
10:01:14 <lambdabot>   9
10:03:13 <erikc> conal: i agree with your post :)
10:04:15 <conal> erikc: :)
10:04:17 <lilac> bremner: mueval expands that to "let random_name = let x = 3 in 3*x where x = 4 in random_name"
10:04:23 <bremner> > let x =3 in 3*x where x=4 in x
10:04:24 <lambdabot>   <no location info>: parse error on input `in'
10:04:57 <lilac> > let random_name = let x = 3 in 3*x where x = 4 in random_name
10:04:58 <lambdabot>   9
10:05:19 <lilac> > x * 32 where x = 8
10:05:20 <lambdabot>   256
10:05:34 <jeffersonheard> going to be one of those days...
10:06:13 <jeffersonheard> program was working every time.  I added a line, then it froze up.  I took that line out and it's still frozen up
10:06:31 <jeffersonheard> already deleted all the trace code, because it was working
10:07:04 <FunctorSalad> jeffersonheard: keep it in and redefine trace = id
10:07:13 <FunctorSalad> (I know that's not helpful now, sorry :))
10:07:28 <FunctorSalad> trace = const id actually
10:07:30 <jeffersonheard> FunctorSalad, yeah I've done that before.  Don't know why I didn't do that now, except for aesthetic purposes
10:07:36 <jeffersonheard> yeah, I was going to say
10:07:38 <jeffersonheard> but yes
10:07:48 <jeffersonheard> damn aesthetics, trace everything
10:08:12 <jeffersonheard> haha.  okay.  I was compiling the wrong copy of the file
10:08:16 <FunctorSalad> =)
10:08:16 <jeffersonheard> I think that calls for lunch
10:08:36 <conal> jeffersonheard: i've done that one!
10:09:11 <jeffersonheard> =)
10:10:48 <jeffersonheard> is there something like a SampleVar out there that supports nonblocking read?
10:11:10 <jeffersonheard> tryReadSampleVar :: SampleVar a -> IO (Maybe a) in other words?
10:12:51 <jeffersonheard> suppose I could emulate the SampleVar's writing style by using MVars with tryTakeMVar and on Just _, put.  Then I could use tryTakeMVar
10:17:19 <jeffersonheard> or rather... throw away the result of tryTakeMVar
10:27:04 <jeffersonheard> yep. that worked.  I now have something which is almost but not entirely unlike FRP.
10:28:14 <latitude> what's \x -> x+1 mean?
10:28:34 <latitude> i mena i understand this is inc, but how to read it literally?
10:28:36 <bremner> > (\x-> x+1) 78
10:28:38 <lambdabot>   79
10:29:12 <dolio> It's a function literal. \variables -> expression
10:29:13 <bremner> latitude: lambda x = x + 1
10:29:38 <latitude> the gentle intro gives this \x notation bluntly, what's the meaning of it?
10:30:23 <jeffersonheard> latitude: the backslash is a lambda
10:30:26 <dolio> \x -> e is a function that takes a parameter named x and returns e.
10:30:28 <jeffersonheard> an anonymous function
10:30:38 <Zao> \ looks like a lambda without the small leg.
10:30:45 <latitude> is \x y z -> x + y + z correct?
10:30:53 <dolio> Yes.
10:31:00 <jeffersonheard> and if you use Yi, you can get the lambda character to come out as well :-)
10:31:05 <Zao> @type \x y z -> x + y + z
10:31:06 <dkcl> dolio: The beauty of Haskell.
10:31:06 <lambdabot> forall a. (Num a) => a -> a -> a -> a
10:31:16 <arjanb> latitude: the gentle intro is not a good one to start with
10:31:27 <jeffersonheard> latitude: look at Yet Another Haskell Tutorial
10:31:33 <latitude> ah, good then
10:31:41 <dkcl> dolio: I'm only a beginner in Haskell but I'm a Lisper with a background of lambda calculus and, to be honest, I'm falling in love with it. </rant>
10:31:49 <latitude> well, i somewhat comprende but not so fast
10:31:50 <jeffersonheard> the gentle intro is a mathematician's gentle introduction for other mathematicians, as far as I can tell, not for programmers
10:32:01 <latitude> sure i'll read that to
10:32:09 <dolio> dkcl: I like it, too. :)
10:32:27 <abbe> latitude, you would like reading that after you've acquired some basic haskell knowledge :-)
10:39:08 <Gracenotes> hm. In dons's vacuum video, how can the two []s in [[42]] be shared? Aren't they of different types?
10:39:22 <dolio> All []s are shared.
10:39:40 <dolio> So are all Nothings.
10:39:45 <dolio> In GHC, that is.
10:39:54 <Gracenotes> hm. I suppose they are all different types, but they have no type constants to distinguish them
10:39:58 <Gracenotes> type vars
10:40:19 <Gracenotes> interesting though
10:40:25 <dolio> Yeah, all nullary constructors are the same, even if they're polymorphic.
10:40:31 <dolio> So you can share them.
10:41:54 <monochrom> "Nothing can be shared" XD
10:43:25 <kadaver> if you wanna be my IO, you gotta get with mah monads, lovin is so easy but monadism never e-ends!
10:43:46 <bavardage> kadaver: oh dear
10:43:48 <bavardage> :P
10:44:51 <FunctorSalad> why would you want to share Nothing?
10:45:12 * Gracenotes snocs inappropriately
10:45:19 <FunctorSalad> > (Nothing,Nothing,Nothing,Nothing,Nothing)
10:45:20 <lambdabot>   (Nothing,Nothing,Nothing,Nothing,Nothing)
10:45:54 <Vq^> a large bunch of nothing?
10:45:56 <Gracenotes> I always snoc when no one's home.
10:46:17 <Gracenotes> One time my mom walked in on my while I was snocing.
10:46:20 <Gracenotes> *me
10:46:25 <Gracenotes> >_>
10:46:29 <Gracenotes> I dunno, snoc just sounds dirty.
10:46:50 <bavardage> Gracenotes: does it atually have a meaning?
10:47:26 <Gracenotes> it's like snoc but at the end of a list.
10:47:31 <bavardage> or is this just a made up dirty word
10:47:35 <bavardage> riight
10:47:54 <monochrom> > reverse "snoc"
10:47:55 <lambdabot>   "cons"
10:48:03 <monochrom> No pun intended.
10:48:12 <Gracenotes> a snoc list: data RList a = Nil | (RList a) `Snoc` a
10:48:26 <Gracenotes> data List a = Nil | a `Cons` (List a)
10:48:40 <latitude> so it is possible to define any sorts of crappy operators in haskell?
10:48:46 <Vq^> can i and if so how do i use Data.Generics to implement binary operations for my datastructures
10:48:54 <Gracenotes> some lists have support for both consing and snocing
10:49:17 <jmcarthur> latitude, what a loaded question!
10:49:18 <Vq^> they have quite a few number of fields and it causes a lot of boilerplate :(
10:49:20 <Gracenotes> Data.Sequence for instance. doubly-linked lists in imperative languages, perhaps.
10:49:25 <jmcarthur> latitude, the answer is yes, technically
10:49:32 <jmcarthur> latitude, but overloading is tightly controlled
10:49:49 <bremner> latitude: yes, in particular you can define operators that look like comments
10:50:20 <Vq^> i tried looking at gzip and gzipWithT but i mostly just managed to confuse myself
10:50:32 <jmcarthur> > let (--) = (-) in 4 -- 5
10:50:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:50:35 <latitude> jsut created +-+, my imagination scares me :)
10:50:45 <jmcarthur> you can't make operators that look like comments...
10:50:52 <jmcarthur> > let (---) = (-) in 4 --- 5
10:50:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:50:54 <bremner> mueval can't
10:50:57 <jmcarthur> oh
10:51:07 <bremner> (--@) x y = 0
10:51:20 <dolio> > let (--|) = (-) in 4 --| 5
10:51:21 <lambdabot>   -1
10:51:38 <jmcarthur> dolio, oh that one is pretty gross
10:51:45 <latitude> what is the `let` thing?
10:51:51 <FunctorSalad> Vq^: couldn't get it to work at first try either (these pesky type variables "escaping")
10:52:12 <jmcarthur> latitude, it allows you to define functions or constants to be used later in the expression
10:52:17 <bremner> (>--|-|-|-|-|-|-|-|-|-|-:>) x y = 0
10:52:22 <Vq^> FunctorSalad: you got it on the second try?
10:52:28 <FunctorSalad> Vq^: no :)
10:52:32 <Vq^> aw :(
10:52:46 <Vq^> my datastructure is fairly flat
10:53:02 <FunctorSalad> Vq^: just didn't want to sounds like "I tried it over 9000 times, but still don't get it"
10:53:14 <Gracenotes> > let (------@) = text.("*gives "++).(++ " a rose*") in ("latitude" ------@)
10:53:15 <lambdabot>   *gives latitude a rose*
10:53:15 <Vq^> data H = H Integer Integer Integer Integer Integer
10:53:34 <Vq^> FunctorSalad: and now you did :P
10:58:05 <latitude> and what's `in` ?
10:59:22 <monochrom> 'in' is part of the syntax of 'let'
10:59:41 <FunctorSalad> :(
11:00:13 <monochrom> My favourite way of putting it is " 'in' is punctuation"
11:02:10 <Gracenotes> > let in ":O"
11:02:11 <lambdabot>   ":O"
11:02:13 <Eridius> what's text?
11:02:35 <bavardage> >let in (3+3)
11:02:43 <bavardage> > let in (3+3)
11:02:44 <lambdabot>   6
11:02:47 <bavardage> STRANGE
11:02:55 <Eridius> oh text made lambdabot not put the quotes
11:05:09 <monochrom> «let in (3+3)» is as strange as «""».  Don't you need something between let and in?  Don't you need something between the two quotation marks?
11:05:22 <latitude> so when i define add = \x y -> x + y, i need to call it add 4 5
11:05:25 <yakov> hey
11:05:28 <pumpkin> > let in the dog
11:05:28 <lambdabot>       Overlapping instances for Show (t -> [Char])
11:05:28 <lambdabot>        arising from a use ...
11:05:31 <pumpkin> :(
11:05:46 <mercury^> :t the
11:05:47 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:05:47 <pumpkin> > let in the dog (1,1)
11:05:48 <lambdabot>   "woof!"
11:05:53 <latitude> and when i define it like (+++) = \x y -> x - y, i need to call it 5 +++ 4
11:05:57 <Eridius> > let (ಠ_ಠ) = text "\001ACTION gives everyone a look of disapproval" in ಠ_ಠ
11:05:58 <lambdabot>   <no location info>: lexical error at character '\3232'
11:05:59 <bavardage> pumpkin: now.. wtf?
11:06:00 <Eridius> damn
11:06:02 <bavardage> > dog
11:06:03 <lambdabot>       Overlapping instances for Show ((t, t1) -> ([Char], t1))
11:06:03 <lambdabot>        arising...
11:06:08 <bavardage> > the dog
11:06:08 <latitude> infix vs prefix form
11:06:09 <lambdabot>       Overlapping instances for Show (t -> [Char])
11:06:09 <lambdabot>        arising from a use ...
11:06:12 <Eridius> > text "\001ACTION tests"
11:06:14 <lambdabot>   ACTION tests
11:06:15 <Eridius> BAH
11:06:19 <mdmkolbe> @type read
11:06:20 <lambdabot> forall a. (Read a) => String -> a
11:06:24 <bavardage> > the dog (3,4)
11:06:24 <mercury^> :t dog
11:06:25 <lambdabot>   "woof!"
11:06:26 <lambdabot> forall t t1. (t, t1) -> ([Char], t1)
11:06:28 <pumpkin> bavardage: I figured I'd be a little more interesting than just const "woof!"
11:06:37 <bavardage> but who the hell defined dog?
11:06:43 <bavardage> and what does it do?
11:06:45 * pumpkin whistles innocently
11:07:26 <monochrom> Dog was evoluted not intelligently defined.
11:07:36 <pumpkin> lol
11:07:42 <bavardage> har har har
11:07:44 * pumpkin puts a sticker on monochrom
11:07:53 <bavardage> fine
11:07:58 <bavardage> "WHO THE HELL LET THIS DOG IN"
11:09:04 <pumpkin> > let in the dog please
11:09:05 <idnar> o/` who let the dogs out o/`
11:09:05 <lambdabot>   "woof!"
11:09:12 <Eridius> what's the? hoogle suggests GHC.Exts, but that the doesn't fit with the usage here
11:09:13 <pumpkin> there we go
11:09:26 <bavardage> > let in the cat
11:09:27 <lambdabot>   Couldn't match expected type `(b, d)' against inferred type `[Doc]'
11:09:34 <bavardage> > :t the
11:09:34 <lambdabot>   <no location info>: parse error on input `:'
11:09:35 <Gracenotes> > please
11:09:36 <lambdabot>   (* Exception: Prelude.undefined
11:09:37 <FunctorSalad> @t doc
11:09:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:09:40 <Eridius> :t the
11:09:40 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:09:41 <bavardage> @type the
11:09:42 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:09:44 <FunctorSalad> :t doc
11:09:45 <lambdabot> Not in scope: `doc'
11:09:46 <FunctorSalad> :t dog
11:09:47 <lambdabot> forall t t1. (t, t1) -> ([Char], t1)
11:09:53 <bavardage> I don't understand
11:09:57 <bavardage> is this built into the stdlib?
11:10:01 <pumpkin> no :P
11:10:02 <bavardage> or just some hilarityi into lambabot
11:10:03 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3148#a3148 <- thats what i mean, that must be possible to simplify that a lot
11:10:05 <pumpkin> I'm being sneaky
11:10:16 <FunctorSalad> bavardage: probably defined with @let
11:10:19 <Gracenotes> Eridius: _ can't be in symbols :x
11:10:22 <pumpkin> yup
11:10:24 <Eridius> Gracenotes: BAH!
11:10:25 <FunctorSalad> > kitten_supply
11:10:26 <monochrom> dog built into stdlib? hahahah, you would have a better chance with cat built into stdlib.
11:10:26 <lambdabot>   Not in scope: `kitten_supply'
11:10:34 <FunctorSalad> hmm that one got undefined already
11:10:36 <Gracenotes> however, '.' can be
11:10:58 <monochrom> let in the . please ?
11:11:04 <bavardage> FunctorSalad: oh right
11:11:09 <pumpkin> monochrom: :o
11:11:10 <FunctorSalad> monochrom: the dog in the stdlib is for protection against crackers
11:11:13 <pumpkin> monochrom: I don't think that would work
11:11:39 <monochrom> > not . [True]
11:11:40 <lambdabot>   Couldn't match expected type `a -> Bool'
11:11:49 <pumpkin> the = loop, dog = ???, please = profit (I mean, (undefined, undefined))
11:11:56 <Eridius> :t dog
11:11:57 <lambdabot> forall t t1. (t, t1) -> ([Char], t1)
11:12:09 <flazz> is it plausible to say that in haskell one could make a regex parser that is ((String -> NFA) . (NFA -> DFA)) -> Bool and that via lazy evaluation only the worst case space allocation will occur when applying a regex string against it?
11:12:40 <Eridius> dog = first (const "woof"!)
11:12:49 <pumpkin> :)
11:13:03 <Eridius> :t the
11:13:05 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:13:17 <Gracenotes> flazz: depends on NFA->DFA, if you only include reachable states (instead of the powerset), and then optionally minimize
11:13:23 <monochrom> I don't understand the . in ((String -> NFA) . (NFA -> DFA)) -> Bool. (Who let the . in?)
11:13:25 <Gracenotes> and you need some extra extensions too
11:13:37 <Gracenotes> like possibly tagged epsilons
11:13:56 <Gracenotes> and converting back-and-forth from NFAs and DFAs to implement things like complementation, possibly
11:14:09 <Gracenotes> there's a paper on converting directly Regex -> DFA too. Anyway, some resources around the internet, etc.
11:14:13 <Gracenotes> but gotta go to class nao/.
11:15:15 <inimino> http://swtch.com/~rsc/regexp/regexp1.html
11:15:52 <Eridius> where does this `the` function come from? hoogle is useless, and hayoo is even *more* useless
11:16:00 <flazz> Gracenotes: yes, reachable states.
11:16:04 <kadaver> anyone know where you can download a hgue dictiornary?
11:16:09 <bavardage> Eridius: someone defined it I think
11:16:35 <Eridius> what's its definition?
11:16:42 <idnar> :t the
11:16:43 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:16:49 <Eridius> yes I see the type
11:16:51 <pumpkin> Eridius: I just @let it in a pm :)
11:16:54 <Eridius> oh hrm... I think it == loop
11:16:55 <idnar> @hoogle (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:16:55 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
11:16:56 <Eridius> pumpkin: BAH!
11:17:08 <pumpkin> Eridius: and yeah, it is loop (I said so above :P)
11:17:11 <Eridius> heh
11:17:17 <pumpkin> just a red herring to confuse the const "woof" ness
11:17:19 <Eridius> why is the and dog defined so oddly?
11:17:19 <idnar> who looped the dog in
11:17:22 <Eridius> ahhhh
11:17:34 <Eridius> meh, the const "woof" was pretty easy coming from the type of dog
11:17:35 <Eridius> :t dog
11:17:36 <lambdabot> forall t t1. (t, t1) -> ([Char], t1)
11:17:43 <pumpkin> and I made please = (undefined, undefined) just to make it harder to play with
11:17:43 <Eridius> the [Char] had to be present in the definition of dog
11:17:53 <Eridius> :t please
11:17:54 <lambdabot> forall a a1. (a, a1)
11:17:55 <pumpkin> Eridius: yeah :(
11:18:14 <pumpkin> Eridius: next time I'll make it less obvious
11:18:17 <Eridius> heh
11:19:06 <Eridius> does anybody have a good resource for understanding Arrow and its related classes?
11:19:17 <pumpkin> there's a good paper
11:19:23 <Eridius> I mean, I can figure out how to use (***), (&&&), first, and second from the types, but I still don't understand Arrow
11:19:23 <pumpkin> written like a tutorial
11:19:31 <Eridius> got a link? or a title?
11:19:34 <pumpkin> let me dig it up
11:20:23 <maltem> There's more to Arrow than golfing in #haskell, is there?
11:20:30 <pumpkin> http://www.cs.chalmers.se/~rjmh/afp-arrows.pdf pretty much cleared it all up for me
11:20:34 <Eridius> pumpkin: thanks
11:21:58 <pumpkin> :t mfix
11:21:59 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:23:31 <BMeph> It was a sad day in Haskell history, when whoever(s) decided "we're going to make a Functor out of pairs, where the function just operates on the second part." Very sad - and frustrating. :\
11:23:31 <Eridius> @src mfix
11:23:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:23:56 <Eridius> BMeph: well, how else would they have done it?
11:24:23 <BMeph> Eridus: Uh, the /first/ part, obviously. :)
11:24:29 <Eridius> BMeph: ok, what's the type signature?
11:24:46 <pumpkin> make FirstFunctor (a, b), SecondFunctor (a, b) and define Functor instances for those?
11:24:54 <pumpkin> a bit like Sum and Product for Monoid
11:24:58 <BMeph> (a -> b) -> (a, c) -> (b, c)
11:25:07 <beelsebob> BMeph: no, how do you define the instance
11:25:10 <pumpkin> making (a, b) itself into a functor seems a little artificial
11:25:13 <Eridius> BMeph: no the instance declaration
11:25:17 <beelsebob> instance Functor ??? where
11:25:20 <beelsebob> what goes in the ??
11:25:35 <BMeph> ...
11:26:05 <BMeph> Well, if I knew that, I'd just jump straight to 4)PROFIT!, now wouldn't I? ;p
11:26:08 <Eridius> hah
11:26:13 <beelsebob> hehe
11:26:25 <pumpkin> type First a b = (a, b), type Second a b = (b, a) or something
11:26:25 <jmcarthur> BMeph, why would it make more sense for the functor to operate on the first element of the pair?
11:27:36 <BMeph> jmcarthur: I'm not saying that it makes /more/ sense, so much as that the way that it /is/ defined is done because it's easy, not because it's superior.
11:27:52 <Eridius> I would argue it's the only possible Functor instance for (,)
11:28:16 <jmcarthur> BMeph, it's just due to the kind of (,), just as it is for any other functor instance
11:28:36 <BMeph> Eridius: It is, given the way the type definition goes. It's not anything inherent in the pair, though.
11:28:41 <Eridius> I suspect (,) is a Functor not because someone thought the semantics were useful, but just because it was trivial to make it so
11:29:18 <jmcarthur> i wish there was a writer monad defined for (,) like there is a reader for (->)
11:29:51 <jmcarthur> instance Monoid e => Monad ((,) e) where ...
11:30:22 <Eridius> so write one :P
11:30:55 <jmcarthur> i wish there was one in the standard libs already :P
11:31:02 <Eridius> heh
11:31:13 <idnar> BMeph: you could make the same complaint about Either
11:31:16 <BMeph> Not blaming him, but conal's talk - and blog post - got me to thinking about some of the "rough spots" of Haskell, and how some of the things in it - and in GHC's implementation, but that's another story - were done because it was easy to figure out, but not because it's particularly "true".
11:33:16 <dolio> There is one, defined in the same place as the Monad instance for (->) e.
11:33:29 <BMeph> idnar: Of course, and I do. Along with the point that Sequences and Arrays must be specified with a particular size, but Lists can't even be specified by length at all, except by ad hoc.
11:34:01 <dolio> > tell (Sum 1) >> tell (Sum 5) :: (Sum Int, ())
11:34:02 <lambdabot>       No instance for (MonadWriter (Sum t) ((,) (Sum Int)))
11:34:02 <lambdabot>        arising fr...
11:34:16 <BMeph> jmcarthur: Isn't that definition you posted, the one for Writer? :)
11:34:22 <dolio> Or there should be, unless it was removed.
11:34:46 <BMeph> jmcarthur: Oh, wait, it's the other way; NM.
11:34:46 <andrey22> guys
11:34:55 <andrey22> who of you have your own websites?
11:35:43 <BMeph> andrey22: Own websites for what? I think everyone had a blog, whether they post to it or not. Or do you mean a webserver site? :)
11:35:46 <dolio> > (Sum 1, ()) >> (Sum 5, ())
11:35:47 <lambdabot>       No instance for (Monad ((,) (Sum t)))
11:35:47 <lambdabot>        arising from a use of `>>'...
11:35:57 <BMeph> s/had/has/
11:36:05 <andrey22> bmeph: i mena a personal site or blog
11:36:54 <BMeph> andrey22: I have a blog site, but I hardly post to it, and I don't think I've posted anything Haskell-related yet.
11:36:58 <andrey22> i am looking to buy some ads space so if you have site or blog on your own domain you can paste it to me privately and i'll tell you for how much i will buy ads
11:37:03 <trofi> @pl \f -> f a b c d
11:37:04 <lambdabot> flip (flip (flip ($ a) b) c) d
11:37:09 <andrey22> i need simple text links, not banners or similar things
11:37:35 <ehird> cairo/Graphics/Rendering/Cairo.hs.pp:245:7:
11:37:35 <ehird>     Could not find module `Control.Monad.Reader':
11:37:36 <ehird>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
11:37:38 <ehird> :-S
11:37:46 <ehird> andrey22: spammer?
11:37:51 <andrey22> nope?
11:39:04 <BMeph> @info Writer
11:39:04 <lambdabot> Writer
11:39:06 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3149#a3149 <- using Data.Permute but there must be a better way to permute a lsit right?
11:39:09 <maltem> “flip ($ a)” :o
11:39:25 <BMeph> @type runWriter
11:39:26 <lambdabot> forall w a. Writer w a -> (a, w)
11:39:39 <trofi> @pl \f -> f a
11:39:39 <lambdabot> ($ a)
11:39:47 <BMeph> @src return Writer
11:39:47 <lambdabot> Source not found. Are you on drugs?
11:40:14 <trofi> @pl \(f, (a,b,c,)) -> f a b c
11:40:15 <lambdabot> (line 1, column 10):
11:40:15 <lambdabot> unexpected ","
11:40:15 <lambdabot> expecting letter or digit, operator or ")"
11:40:15 <lambdabot> ambiguous use of a non associative operator
11:40:17 <trofi> @pl \(f, (a,b,c)) -> f a b c
11:40:18 <lambdabot> (line 1, column 10):
11:40:18 <lambdabot> unexpected ","
11:40:19 <lambdabot> expecting letter or digit, operator or ")"
11:40:21 <lambdabot> ambiguous use of a non associative operator
11:40:24 <maltem> By now, it makes sense.
11:40:58 <saml> @pl \f (a,b,c) -> f a b c
11:40:58 <lambdabot> (line 1, column 8):
11:40:58 <lambdabot> unexpected ","
11:40:58 <lambdabot> expecting letter or digit, operator or ")"
11:40:58 <lambdabot> ambiguous use of a non associative operator
11:41:48 <dolio> @pl \f p -> f (fst p) (snd p)
11:41:49 <lambdabot> (`ap` snd) . (. fst)
11:41:58 <dolio> @pl \f (x,y) -> f x y
11:41:58 <lambdabot> (`ap` snd) . (. fst)
11:42:05 <Eridius> huh, this paper that pumpkin linked has Kleisli as a type but in Control.Arrow it's actually a newtype. This makes it more irritating to play around with..
11:42:08 <yorirou> hi
11:42:11 <vixey> @unpl uncurry f
11:42:12 <lambdabot> uncurry f
11:42:16 <vixey> @unpl \x -> uncurry f x
11:42:17 <lambdabot> \ x -> uncurry f x
11:42:29 <vixey> @unpl \\\\\
11:42:29 <lambdabot> (\\\\\)
11:42:36 <yorirou> I am a haskell newbie, and I have a lame question :)
11:42:47 <yorirou> lines (readFile filename)
11:42:51 <yorirou> this is not works
11:43:01 <yorirou> because the readFile returns IO String
11:43:01 <dolio> @type readFile "foo"
11:43:02 <lambdabot> IO String
11:43:06 <ehird> is there a gtk2hs channel?
11:43:13 <vixey> if you want a String out of IO String you can do this inside a do notation
11:43:22 <trofi> l <- lines `fmap` readFile filename
11:43:29 <vixey> e.g.   do  content <- readFile filename ;  return (lines content)
11:43:47 <Eridius> @src (->) arr
11:43:47 <lambdabot> arr f = f
11:43:53 * mux waits for someone to mention the liftM and <$> alternatives
11:44:01 <Eridius> @src (Kleisli m) arr
11:44:02 <lambdabot> Source not found. Wrong!  You cheating scum!
11:44:04 <Eridius> bah
11:44:11 <ehird> Hmm... I upgraded haddock, is there a way to regenerat the .haddock files? It won't load them because they're the wrong version
11:44:18 <saml> yorirou, content <- readFile filename;  lines content
11:44:34 <vixey> saml what is that
11:44:44 <saml> @type readFile
11:44:45 <lambdabot> FilePath -> IO String
11:44:49 <saml> @type lines
11:44:51 <lambdabot> String -> [String]
11:45:03 <saml> i think it will work
11:45:06 <vixey> I don't
11:45:34 <saml> oh crap
11:45:39 <mux> every "line" in a do block must have type m a for the same m in the Monad typeclass
11:45:42 <saml> return $ lines content
11:45:49 * mux nods
11:46:18 <latitude> ok, what about infixr? it's not a function, how is that?
11:46:39 <saml> latitude, it's like import. keyword
11:46:53 <Eridius> runKleisli (Kleisli readFile >>> arr length) filename
11:46:54 * beelsebob notes that this whole discussion is the perfect example of what his blog entry was talking about
11:46:57 <beelsebob> no need for do notation here
11:47:05 <Eridius> beelsebob: what blog entry?
11:47:08 <beelsebob> lines <$> readFile "filename"
11:47:09 <Petrosian> Can anyone recall the name of (or has a link to!) the paper that Djinn is based upon?
11:47:27 <vixey> I tohught djinn is based on this horrendous prolog code
11:47:27 <beelsebob> Eridius: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
11:47:29 <latitude> ok, saml, got that
11:47:32 <Eridius> liftM lines $ readFile "filename"
11:47:44 <Eridius> beelsebob: ah, I saw that on reddit but didn't actually read it
11:47:49 <vixey> the prolog code mentoins a paper
11:48:03 <beelsebob> I much prefer lines <$> readFile "filename" there – no need to pretend you need a monad just to use fmap
11:48:28 * Eridius likes <$> too
11:48:37 <BMeph> Petrosian: ask augustss, since he wrote them both. :)
11:48:40 <vixey> lines . readFile "filename"
11:48:55 <vixey> I write things like
11:49:02 <vixey> do ... ; x <- lines . readFile "filename" ; ..
11:49:24 <saml> i like do notation
11:49:32 <beelsebob> vixey: that won't typecheck
11:49:35 <beelsebob> needs a fmap in there
11:49:39 <vixey> it does typecheck
11:49:52 <vixey> I'm using (.) = fmap
11:49:58 <beelsebob> fmap on IO
11:50:00 <saml> fmap is for professionals. it's hard to understand
11:50:08 <jmcarthur> ...
11:50:09 <beelsebob> @type (lines . readFile "filename")
11:50:10 <lambdabot>     Couldn't match expected type `a -> String'
11:50:10 <lambdabot>            against inferred type `IO String'
11:50:10 <lambdabot>     In the second argument of `(.)', namely `readFile "filename"'
11:50:12 <beelsebob> see
11:50:30 <jmcarthur> @type lines <$> readFile "filename"
11:50:31 <lambdabot> IO [String]
11:50:32 <beelsebob> @type (lines <$> readFile "filename")
11:50:34 <lambdabot> IO [String]
11:50:34 <saml> do { content <- readFile filename; return $ lines content }   i think this reads better
11:50:44 <beelsebob> really?
11:50:46 <beelsebob> o.O
11:50:47 <vixey> @type let (.) = fmap in  (lines . readFile "filename")
11:50:48 <lambdabot> IO [String]
11:50:49 <saml> i mean, to C programmers
11:50:52 <beelsebob> I think it reads like crappy imperative code
11:50:53 <vixey> see ?
11:50:54 <Eridius> saml: that looks needlessly verbose
11:51:00 <jmcarthur> that's horrible
11:51:08 <yorirou> the do <- content readFile filename; return (lines content) returns IO String
11:51:09 <beelsebob> vixey: oh, you mean you rebind (.) to be more general than it normally is?
11:51:24 <beelsebob> yorirou: no it doesn't
11:51:26 <saml> @type (<$>)
11:51:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:51:29 <jmcarthur> (.) is already a part of Category now though
11:51:36 <vixey> yes it does
11:51:43 <bavardage> beelsebob: that tutorial you linked uses 'pure'
11:51:46 <vixey> well you put the (<-) in the wrong place
11:51:48 <beelsebob> @type do {x <- readFile "filename"; return (lines content) }
11:51:49 <lambdabot> Not in scope: `content'
11:51:50 <bavardage> what's the difference between return and pure?
11:51:53 <beelsebob> @type do {x <- readFile "filename"; return (lines x) }
11:51:54 <lambdabot> IO [String]
11:51:57 <beelsebob> see... list of string
11:52:02 <vixey> bavardage: they are equal in a lot of situations
11:52:04 <beelsebob> bavardage: return = pure = point
11:52:15 <vixey> compare the types though
11:52:19 <jmcarthur> bavardage, pure is more general since it's Applicative and not Monad, but that's it
11:52:26 <bavardage> riight
11:52:34 <beelsebob> return's existance is merely an artifact of history
11:52:39 <beelsebob> as is pure's in fact
11:52:43 <jmcarthur> Pointed ftw
11:52:47 <beelsebob> but Haskell doesn't have point in it's standard librarys
11:53:19 <jmcarthur> :t Control.Category.(.)
11:53:20 <lambdabot> Couldn't find qualified module.
11:53:27 <paolin1> @src Applicative
11:53:27 <lambdabot> class Functor f => Applicative f where
11:53:27 <lambdabot>     pure  :: a -> f a
11:53:27 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
11:53:28 <jmcarthur> lambdabot out of date?
11:53:31 <Eridius> :t Category.(.)
11:53:32 <lambdabot> Not in scope: data constructor `Category'
11:53:35 <Eridius> heh
11:53:47 * RayNbow doesn't understand pointed functors yet... (not in CT that is)
11:54:10 <beelsebob> Raynes: Pointed just lets you put things in boxes
11:54:20 <beelsebob> as oppesed to Functor that lets you apply functions to things in boxes
11:54:31 <beelsebob> and Applicative which lets you apply functions in boxes to things in boxes
11:54:39 <Raynes> Say huh?
11:54:55 <vixey> the boxes metaphor isn't good
11:55:01 <beelsebob> no, not ideal
11:55:13 <beelsebob> it brings up boxed/unboxed types too much
11:55:15 <Raynes> beelsebob: I think you mean the RayNbow. Sorry I'm stealing your tab-completion thunder.
11:55:20 <latitude> what
11:55:21 <beelsebob> I did mean RayNbow
11:55:27 <latitude> what's bot?
11:55:48 <beelsebob> @bot
11:55:49 <lunabot>  :)
11:55:49 <lambdabot> :)
11:55:50 <BMeph> latitude: It's it. ;)
11:55:52 <saml> (readFile filename).apply(lines)  -- java style
11:56:04 <vixey> that isn't java style
11:56:06 <jmcarthur> saml, please, you're hurting me
11:56:12 <___> @botsnack
11:56:13 <lambdabot> :)
11:56:13 <lunabot>  :)
11:56:14 <RayNbow> beelsebob: I understand how they work in Haskell... but when I looked up the CT definition, it mentioned something about natural transformations... and I have yet to study those :p
11:56:19 <sbahra> @botcrack
11:56:19 <lambdabot> :)
11:56:19 <lunabot>  :)
11:56:24 <beelsebob> RayNbow: ah, I see
11:56:26 <Eridius> @botsmack
11:56:26 <lambdabot> :)
11:56:26 <lunabot>  :)
11:56:41 <___> oh dear, look what I've started
11:57:46 <dixie> :t lines
11:57:46 <lambdabot> String -> [String]
11:57:57 <saml> > lines "\n\n\n"
11:57:58 <lambdabot>   ["","",""]
11:58:10 <latitude> i don't get at all, he (in tutorial) says _|_ is the value of non-terminating expression, so bot stands a non-terminating expr ?
11:58:20 <jmcarthur> latitude, yes
11:58:34 <RayNbow> > error "bottom"
11:58:35 <lambdabot>   * Exception: bottom
11:58:43 <saml> how would you quick check that length (lines s)  == number of \n in s ?
11:58:44 <___> > let x = x in x
11:58:58 <Eridius> lines "\n\n\n "
11:59:00 <lambdabot>   thread killed
11:59:00 <Eridius> > lines "\n\n\n "
11:59:01 <jmcarthur> > show $ [1,2,3,4,5,6,7,8,undefined,9,10,11,12]
11:59:01 <lambdabot>   ["","",""," "]
11:59:02 <lambdabot>   "[1,2,3,4,5,6,7,8,* Exception: Prelude.undefined
11:59:08 <vixey> saml: I would inspect the souce code rather than use quickcheck
11:59:10 <Eridius> saml: it's number of \n's, possibly plus 1
11:59:27 <bavardage> @hoogle Functor
11:59:27 <lambdabot> Prelude class Functor f
11:59:27 <lambdabot> Control.Monad class Functor f
11:59:27 <lambdabot> Control.Monad.Instances class Functor f
11:59:34 <saml> oh crap
11:59:53 * ___ thinks splitting on '\n' would be a better definition for lines
11:59:53 <bavardage> so Maybe is a functor?
11:59:58 <Eridius> @src lines
11:59:58 <lambdabot> Source not found.
12:00:08 <Eridius> bavardage: yes
12:00:13 <bavardage> kk
12:00:14 <Eridius> > fmap succ (Just 3)
12:00:14 <TomMD> @check \s -> length (lines s) == length (filter (== '\n') s)
12:00:15 <lambdabot>   Just 4
12:00:16 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\846081\"\n"
12:00:18 <___> that way intercalate "\n" would be lines' inverse.
12:00:19 <TomMD> there
12:00:34 <dixie> :t fmap
12:00:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:00:48 <jmcarthur> @check \n -> length (lines (take n $ repeat '\n')) == n
12:00:49 <lambdabot>   "Falsifiable, after 2 tests:\n-2\n"
12:00:54 <beelsebob> ___: or in fact unlines would be lines' inverse
12:01:11 <TomMD> @check \s -> let n = length (lines s) in let x = length (filter (== '\n') s) in n == x || n == x + 1
12:01:14 <lambdabot>   "OK, passed 500 tests."
12:01:19 <Eridius> ___: true, though (length . lines) would then give unexpected results
12:01:40 <yorirou> how can I "convert" IO String to String?
12:01:50 <___> yorirou: (>>=)
12:01:53 <TomMD> We need an FAQ for that question.
12:02:06 <vixey> yorirou: I showed you already
12:02:13 <jmcarthur> yorirou, you don't, but there are many functions to help you convert pure functions to accept IO parameters
12:02:22 <vixey> yorirou: I dont' blame you if you missed what I said because about 100 people went mad right after
12:03:08 <jmcarthur> fmap :: (a -> b) -> (m a -> m b); (<*>) :: m (a -> b) -> (m a -> m b); (=<<) :: (a -> m b) -> (m a -> m b)
12:03:28 <bavardage> I now just need something to code in haskell :|
12:03:31 <beelsebob> jmcarthur: bind is so much nicer that way round, isn't it :)
12:03:33 <Duqicnk> you can't; you can only pass it as a String into a function which itself returns an IO type
12:03:36 <jmcarthur> i guess for consistency i could have used (<$>) instead of fmap
12:03:41 <Eridius> @check \s -> length (lines s) == length (filter (== '\n') (init s))
12:03:42 <omnihil> :type unsafePerformIO
12:03:42 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\1072915\"\n"
12:03:43 <jmcarthur> beelsebob, sooooo much nicer
12:03:46 <beelsebob> Duqicnk: you can do more than that
12:03:49 <Eridius> oh heh, got that backwards
12:03:52 <beelsebob> you can fmap functions over it for example
12:04:00 <Eridius> oh well, it's irreelvant
12:04:02 <Duqicnk> which can be expressed in terms of (>>=), right?
12:04:13 <beelsebob> it can
12:04:19 <Duqicnk> i mean it's the only required Monad class member other than return
12:04:25 <beelsebob> doesn't mean that conceptually that's what you're doing
12:04:31 <Duqicnk> okay
12:05:00 <ehird> :t (<$)
12:05:01 <ehird> :t (<$>)
12:05:01 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:05:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:05:06 <ehird> :t (<*>)
12:05:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:05:16 <Eridius> <$> == fmap
12:05:23 <___> @src <$>
12:05:24 <lambdabot> f <$> a = fmap f a
12:05:25 <jmcarthur> == liftA == liftM
12:05:29 <ehird> Hrm.
12:05:33 <beelsebob> interesting
12:05:39 <ehird> what is <*> useful for?
12:05:48 <ehird> (return putStrLn) <*> (return "hello") :-P
12:06:02 <Eridius> > (+) <$> [1,2,3] <*> [4,5,6]
12:06:03 <jmcarthur> > (+) <$> [1..3] <*> [4..6]
12:06:03 <lambdabot>   [5,6,7,6,7,8,7,8,9]
12:06:04 <lambdabot>   [5,6,7,6,7,8,7,8,9]
12:06:08 <jmcarthur> lol
12:06:08 <Eridius> haha
12:06:13 <beelsebob> awesome :)
12:06:19 <dixie> :)
12:06:27 <ehird> x_x
12:06:34 <beelsebob> notably, that's more consistant if you do this...
12:06:48 <beelsebob> > (pure (+)) <*> [1..3] <*> [4..6]
12:06:49 <lambdabot>       Ambiguous occurrence `pure'
12:06:49 <lambdabot>      It could refer to either `Control.Appl...
12:06:55 <beelsebob> > (Control.Applicative.pure (+)) <*> [1..3] <*> [4..6]
12:06:57 <lambdabot>   [5,6,7,6,7,8,7,8,9]
12:07:03 <beelsebob> then you can see the currying going on :)
12:07:05 <___> @hoogle pure
12:07:05 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
12:07:05 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
12:07:05 <lambdabot> package pureMD5
12:07:05 <jmcarthur> > getZipList $ (+) <$> ZipList [1..3] <*> ZipList [4..6]
12:07:07 <lambdabot>   [5,7,9]
12:07:13 <beelsebob> (though the fmap version is a lot shorter)
12:07:20 <ehird> but seriously, when would you use <*>
12:07:30 <beelsebob> ehird: that's a genuine example
12:07:34 <Eridius> why does lambdabot's @hoogle come up with a result that haskell.org/hoogle doesn't?
12:07:34 <jmcarthur> ehird, i use it a lot, but can think of no specific examples
12:07:43 <RayNbow> > let infixl 1 «, »; («) = flip (<$>); (») = (<*>)   in   [1,2,3] «(+)» [4,5,6]
12:07:44 <lambdabot>   [5,6,7,6,7,8,7,8,9]
12:07:46 <___> ehird: generally when you have a function inside an Applicative action :P
12:07:48 <beelsebob> ehird: also, look at the end of my blog post
12:07:54 <jmcarthur> jmcarthur, generalized zipWith would be one case as shown above
12:07:56 <BONUS> like if you have 3 Maybe values or something
12:07:59 <beelsebob> it has a real world example that uses it
12:08:03 <BONUS> and a function on 3 things
12:08:13 <beelsebob> ehird: http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
12:08:18 <beelsebob> take a look at the parseRecord example
12:08:21 <beelsebob> at the bottom
12:08:23 <McManiaC> whats the sqrt function in haskell???
12:08:23 <ehird> Hrm.
12:08:31 <beelsebob> McManiaC: sqrt
12:08:33 <vixey> McManiC: it takes the square root
12:08:35 <___> > sqrt 4
12:08:36 <lambdabot>   2.0
12:08:44 <Eridius> RWH has examples that use <*> in applicative parsing
12:09:01 <jmcarthur> > sqrt 2 :: CReal
12:09:02 <lambdabot>   1.4142135623730950488016887242096980785697
12:09:04 <BONUS> > (+) <$> Just 3 <*> Just 33
12:09:05 <lambdabot>   Just 36
12:09:06 <McManiaC> O.o
12:09:11 <McManiaC> :t sqrt
12:09:12 <lambdabot> forall a. (Floating a) => a -> a
12:09:26 <___> @instances Floating
12:09:27 <lambdabot> Double, Float
12:09:39 <BONUS> > (++) <$> Just "haha" <*> Nothing
12:09:40 <lambdabot>   Nothing
12:09:58 <dixie> :t <$>
12:10:00 <lambdabot> parse error on input `<$>'
12:10:02 <travisbrady> are all Haskell programs pure by definition provided they don't use IORef's or mutable arrays?  even something that is doing loads of IO?
12:10:14 <beelsebob> ehird: another use I had for it was when using Reactive – it's common to build up an Event of functions, and then apply them to an Event of arguments
12:10:27 <McManiaC> st = sqrt $ foldr step 0 <--- anything wrong with that? step sums up all elements of a list
12:10:28 <ehird> mm
12:10:33 <beelsebob> travisbrady: yes, but at the same time, no
12:10:39 <ehird> McManiaC: st = sqrt . sum
12:10:40 <beelsebob> IO is "pure" in the same way as C is pure
12:10:41 <vixey> use . instaed of $
12:10:44 <lament> travisbrady: all haskell programs are pure by definition, even if they use arrays and iorefs. The definition is rigged.
12:10:47 <BONUS> travisbrady: the part doing the IO isn't pure
12:10:48 <ehird> McManiaC: And, what vixey said
12:10:52 <beelsebob> you write a C Pre processor program that generates an imperative program
12:10:52 <McManiaC> ah
12:10:55 <jeffersonheard> travisbrady: to a limited extent, even IORefts and mutable arrays are pure
12:10:56 <McManiaC> nasty points :)
12:11:03 <beelsebob> or you write a Haskell program that generates a Haskell runtime program
12:11:08 <McManiaC> its not exactly sum tho ;)
12:11:11 <travisbrady> hmmm, i'm confused
12:11:30 <BONUS> although you could think of it as pure if you think of the IO part as just glueing together IO actions and the only impure part is when "main" is performed
12:11:35 <jeffersonheard> unsafeInterleaveIO isn't pure, or at least, it's not possible to give a well-defined operational semantics for it.
12:11:48 <jeffersonheard> or maybe that discussion has resolved differently since last I looked
12:12:06 <beelsebob> jeffersonheard: it's easy to give a well defined operational semantics for it – the implementation
12:12:16 <beelsebob> it's not possible to give it a *simple* well defined operational semantics
12:12:22 <beelsebob> and deffinately not a denotational semantics
12:12:36 <jeffersonheard> beelsebob: ah yes...  right
12:12:51 <jeffersonheard> I *meant* to say denotational semantics
12:13:06 <kadaver> listPermute 6 [1,0,2,3,4,5]; that isnt a type or a data right, what is it?
12:13:07 <beelsebob> but it's not possible to give denotational semantics for any of IO
12:13:10 <beelsebob> so *shrug*
12:13:22 <beelsebob> kadaver: it's a function application
12:13:29 <beelsebob> two function applications in fact
12:13:36 <kadaver> yeah
12:13:51 <Duqicnk> travisbrady: conceptually, when you execute a bunch of IO stuff you are actually just building up a description of how to do IO
12:13:55 <monochrom> functions are data
12:14:02 <Duqicnk> "read this IORef, pass it to f, print the result"
12:14:06 <kadaver> can I patternamtch on a function?
12:14:07 <jeffersonheard> beelsebob: right, which is why I'm reticent to release my new "almost entirely unlike FRP" library to the world, since there are FRP libraries out there
12:14:31 <monochrom> No, can't pattern-match on a function.
12:14:31 <conal> kadaver: if your pattern is very, very simple.
12:14:38 <beelsebob> jeffersonheard: from my observations of FRP, there's very little that's actually decided in terms of the right way to do it
12:14:44 <Duqicnk> building that description is pure; you are just composing functions of type IO a = RealWorld -> (a, RealWorld)
12:14:48 <travisbrady> Duqicnk: i guess that's the thing i'm trying to understand, is how it is that "blah = do c <- getContents; print c" is pure
12:14:52 <beelsebob> so atm it's pretty much the more the merrier until it gets tdistilled
12:14:52 <jmcarthur> beelsebob, agreed
12:15:01 <jeffersonheard> beelsebob: I'm pretty sure I just defined the wrong way to do it :-)
12:15:06 <Duqicnk> people here will say it's not pure in the sense that its type has "IO" in it
12:15:17 <beelsebob> jeffersonheard: so blog about it and see what the masters like Henrik and Conal say :)
12:15:20 <conal> for me, the really important thing about FRP is just that it has a simple & useful denotational semantics.
12:15:21 * Cale doesn't like the RealWorld description
12:15:26 <mauke> travisbrady: the same way 'cmd = "rm -rf ~"' is harmless
12:15:31 <jeffersonheard> beelsebob: been writing a blog post on it for the last hour
12:15:34 <beelsebob> hehe :)
12:15:40 <Eridius> why does Parsec have two different namespaces (namely, Text.Parsec and Text.ParserCombinators.Parsec)?
12:15:42 <monochrom> the RealWorld is not enough :)
12:15:42 * jmcarthur was recently convinced of the evils of the RealWorld description
12:15:47 <mattam> shapr: coming back tomorrow.
12:15:53 <Cale> Eridius: the latter is for backward compatibility
12:15:54 <jmcarthur> monochrom, good blog post title
12:15:55 <conal> jeffersonheard: so if you define something else that is also useful and denotationally precise, i'd say definitely put it out there.
12:15:56 <Duqicnk> all right, why is it evil?
12:15:59 <jeffersonheard> jmcarthur: I remember that discission
12:16:00 <ehird> Cale: no, former?
12:16:06 <Cale> Text.Parsec is the new one
12:16:11 <Eridius> Cale: oh? I've seen sample code using the ParserCombinators namespace
12:16:12 <ehird> o_O
12:16:12 <Eridius> huh
12:16:27 <Eridius> is there any practical difference, or it just purely a namespace change?
12:16:31 <jmcarthur> Duqicnk, the RealWorld received by an action may not be the RealWorld that was created by the previous action
12:16:31 <monochrom> I don't blog actually.
12:16:47 <Duqicnk> because other stuff can happen in between?
12:16:50 <jmcarthur> Duqicnk, since the world keeps changing
12:16:51 <jmcarthur> yup
12:16:57 <travisbrady> so are actions of type IO sort of generated by the compiler from the description I provide and they take the RealWorld as an implicit param?
12:16:57 <kadaver> fromPermute (listPermute _ xs) = xs ; fail
12:16:58 <Cale> Duqicnk: The RealWorld depiction of IO? I just think it's not so great because there's no appropriate RealWorld type you could actually define.
12:17:01 <jmcarthur> so it's not actually like a state monad
12:17:07 <jeffersonheard> I wish we could use pattern variables for type constructors in pattern matching.
12:17:15 <Cale> Duqicnk: and yes, it doesn't fit well with concurrency
12:17:23 <vixey> jeffersonheard: what does that mean?
12:17:26 <Duqicnk> travisbrady: that's a decent way to think about it, at least initially
12:17:28 <monochrom> RealWorld -> (a, RealWorld) is a gimmick.
12:17:37 <jmcarthur> Cale, where "concurrency" includes things not in the control of the haskell program
12:17:42 <Cale> right
12:17:48 <Duqicnk> you can patch this up by demanding that the rest of the Universe is also written in Haskell
12:17:56 <vixey> like  swap (m x y) = m y x  would flip a (,) or flip a (:) ? ..
12:18:12 <Eridius> Duqicnk: well, no, Haskell itself has concurrency that doesn't fit with the RealWorld view
12:18:21 <jmcarthur> Duqicnk, which still leaves the issue of concurrency within a single Haskell program
12:18:35 <travisbrady> Duqicnk: how do you typically describe the notion that IO actions are about building up a computation which you don't directly call?  and is that even correct?
12:18:43 <Cale> I think it's best to just think of values of type (IO t) as being programs which when run will produce a value of type t after doing arbitrary I/O.
12:18:50 <jeffersonheard> vixey: f (x _ _ _ _) where x is some type constructor and the parenthesized expression is some instance of a type.  since type constructors are themselves merely functions, it'd be useful to be able to pattern match on them and compose with them.  After all, you can bind any normal function to a variable
12:18:55 <Cale> and we have a bunch of ways to connect those programs together
12:18:55 <Eridius> I just tend to think of them as "computations"
12:18:56 <kadaver> so how can i egt the list form the function back again?
12:19:11 <jmcarthur> travisbrady, that is not *technically* correct, but is the closest approximation to what the IO monad represents that i have heard
12:19:16 <vixey> jeffersonheard: Seems impossible to typecheck though
12:19:31 <Cale> and just as loading the source code of a program into your text editor won't cause that program to run, evaluating a value of type (IO t) won't cause its effects to occur
12:19:37 <___> jeffersonheard: s/type constructor/data constructor/g.  Type constructors are different things entirely.
12:19:51 <travisbrady> jmcarthur: ok, i've read things along that line and haven't really understood, because main always looks like plain old imperative programming to me
12:20:08 <jeffersonheard> <___>: yes, sorry.  data constructors.   vixey: Oh, I know that's why we can't.  You certainly couldn't do type inference on it, but you might be able to check it given that an explicit type constructor was used
12:20:13 <Cale> travisbrady: Well, it's a bit of a conspiracy to look that way without actually being quite like that :)
12:20:19 <jmcarthur> travisbrady, the IO monad is imperative programming
12:20:24 <jeffersonheard> no type inference in the general sense, anyway
12:20:32 <monochrom> . o O ( Loading the binary code of a virus into your computer won't cause it to run... until tomorrow. XD )
12:20:34 <jeffersonheard> certain special cases could be inferred
12:20:37 <Cale> travisbrady: main is an action which the RTS is actually going to run -- in a compiled program, you could even say it's the only action which runs
12:20:39 <Eridius> jmcarthur: but only because of do syntax and the fact that the IO monad imposes ordering on embedded actions
12:20:55 <Cale> travisbrady: and it, in turn, is pieced together from simpler actions
12:20:57 <vixey> it seems useless to me though,  rather than  F x y z & G x y z & ..., why not use  U F x y z & U G x y z & ... ?
12:21:16 <jeffersonheard> vixey: that's usually how i work around it
12:21:22 <vixey> but is it worse?
12:21:43 <vixey> it seems natural to me, rather than being some kind of work around
12:22:10 <jmcarthur> Eridius, no. the do syntax just makes it _look_ more imperative, and the ordering is no more important that for a noncommutative binary operation. the real reason the IO monad is imperative is because it is modeled after a state monad, encouraging things like mutation and explicit steps
12:22:18 <mdmkolbe> Does anyone know of a good lazy directory reader (in the spirit of getContents or Data.ByteString.Lazy.readFile) for Haskell?  (A glance through Hackage didn't turn up anything but maybe I missed it.)
12:22:26 <conal> World -> (World,a) is a fine denotational semantics for *non-concurrent* imperative computation.
12:22:44 <vixey> does IO Tree handle concurrency
12:22:45 <Cale> conal: Supposing that you can actually choose a World.
12:22:45 <vixey> ?
12:22:48 <jeffersonheard> vixey: no, not at face value.
12:22:49 <Eridius> jmcarthur: fair enough
12:23:09 <jeffersonheard> you're probably right.  there've been a few times when dealing with other large libraries where it seems more convenient, e.g. GTK
12:23:13 <Cale> conal: It's the construction of this "World" type which usually troubles me :)
12:23:14 <conal> Cale: yes.  generalize World to any state type.
12:23:17 <monochrom> The world changes behind your program's back, too.
12:23:38 <jmcarthur> monochrom, i think conal is limiting the scope to cases where the world can't change behind your brack
12:23:41 <jmcarthur> *back
12:23:42 <conal> Cale: yeah -- me too.  "world" is *way* to small.  There are lots of worlds out there that are influencing things here.
12:23:43 <jeffersonheard> monochrom: that's why conal said *non-concurrent*
12:23:51 <Eridius> mdmkolbe: why did you qualify readFile with Data.ByteString.Lazy? The Prelude readFile is also lazy
12:24:35 <conal> jmcarthur: right.  when i say non-concurrent, i mean not even the world and my program share a single thread.
12:24:54 <conal> jeffersonheard: ^^ for you
12:24:54 <Cale> conal: Well, if you want to make it large enough, usually it becomes intractably large -- are you really going to involve a description of the local universe just to discuss the semantics of your program? :)
12:24:57 <monochrom> That's so sad.
12:25:08 <mdmkolbe> Eridius: I didn't know that Prelude had readFile (When I looked for it I think I incorrectly searched for "getFile".)
12:25:09 <jeffersonheard> conal: right
12:25:18 <Eridius> @hoogle readfile
12:25:19 <lambdabot> Prelude readFile :: FilePath -> IO String
12:25:19 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
12:25:19 <lambdabot> System.IO readFile :: FilePath -> IO String
12:25:29 <jmcarthur> RealWorld is not even as referentially transparent than the temperature of your CPU. ;)
12:25:33 <conal> Cale: in order to to give a precise denotational semantics to IO, yeah.  though the exercise is more to show that IO is denotationally intractable than a suggestion to do so.
12:25:47 <conal> that's why IO is called "the sin bin".
12:25:49 <jmcarthur> grr, i hate it when i change a part of a sentence that completely throws off the grammar
12:26:09 <___> jmcarthur: happens to me all the time
12:26:20 <conal> says the invisible person
12:26:24 <Cale> conal: However, I think other kinds of semantics can easily be given to IO actions.
12:26:34 * conal always thinks there's a ghost in the room when ___ talks.  fun!
12:26:57 <___> ooooooooOOOOoooOO
12:27:09 <___> BEHIND YOU!
12:27:10 <conal> Cale: probably more easily than denotational semantics.  still i wonder what a precise & complete operational semantics would look like for the whole sin bin.
12:27:16 <conal> yipes!
12:27:29 <monochrom> jmcarthur: goes a long way to tell you how mutation-evolution won't work.
12:27:42 <Cale> Well, yeah, it may even be machine dependent depending on how much you want to include.
12:27:54 <Eridius> why doesn't Parsec have an Applicative instance defined in the libs?
12:27:56 * jeffersonheard s/nh/n h/ the ghost howl
12:28:13 <Cale> But, a large subset of it is fairly tractable, otherwise nobody would be able to write programs using the IO monad. :)
12:28:24 <___> Eridius: hysterical raisins.
12:28:28 <vixey> conal: I am not sure what is the difference between operational and denotational when you consider IO ..
12:28:28 <Heffalump> Cale: or C
12:28:34 <Eridius> ___: o_O
12:28:35 <Cale> Heffalump: or C, yes
12:28:43 <jmcarthur> vixey, one exists and the other doesn't? ;)
12:28:59 <vixey> conal: If I was giving operational semantics it would be some kind of state transition I guess .. if it was denotation it would seem like a CPS version of the operational one
12:29:12 <conal> vixey: same as usual, i guess.  denotational semantics would start with a precise mathematical model for values of type IO a.
12:29:19 <Eridius> beelsebob: your blog post is damaged. You're missing the "do" keyword on your Monadic parseRecord sample
12:29:23 <Cale> I think it's a bit unfair calling IO imperative though. Monadic I/O is almost its own paradigm. :)
12:29:33 <conal> vixey: while operational semantics would define some kind of transition system.
12:29:37 <Cale> It sits somewhere in between imperative and functional programming.
12:29:56 <jmcarthur> I don't think it's unfair at all. Just because it's very *good* for imperative programming doesn't mean it's somehow "above" imperative programming.
12:30:08 <vixey> conal: would the GADT model of IO count as denotation semantics?
12:30:22 <MonadKadaver> come on if I have funcitoonf f that is applied to soemthing: andprinting gives (f a b), how can I get b ?
12:30:25 <vixey> that is   data IO :: * -> * where Return :: a -> IO a .. etc
12:30:38 <MonadKadaver> unapply?
12:30:42 <MonadKadaver> @src unapply
12:30:43 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:30:46 <monochrom> reversible computing?
12:30:49 <MonadKadaver> yes?
12:30:53 <Cale> MonadKadaver: What?
12:30:53 <___> MonadKadaver: f is a data constructor?
12:30:54 <MonadKadaver> the info is there
12:30:54 <monochrom> No.
12:31:01 <jmcarthur> MonadKadaver, not possible without you making your own DSL or something
12:31:05 <MonadKadaver> sicne it can print it
12:31:10 <Cale> MonadKadaver: Is f a data constructor?
12:31:13 <jmcarthur> wait, what?
12:31:16 <conal> vixey: more what i mean by a "representation".  also, you'd have to have enough constructors to handle all the FFI stuff.
12:31:19 <Cale> MonadKadaver: If not, then there's no way to do it.
12:31:24 <___> If you can print it I'd guess it's a data constructor.  Pattern match against it
12:31:31 <monochrom> Use a programming language that lets you examine source code during runtime and find out.
12:31:34 <conal> statistically, almost all IO calls are FFI.
12:31:44 <Cale> hmm...
12:31:49 <MonadKadaver> but then what good is the friggin thing if I cant get the lsit back out?
12:31:49 <Heffalump> conal: really??
12:32:03 <Cale> I would expect most IO actions to be binds actually :)
12:32:04 <Heffalump> what are you counting over?
12:32:09 <___> MonadKadaver: answer the question.  Is f a data constructor?
12:32:09 <jmcarthur> MonadKadaver, what is the type of the function?
12:32:09 <conal> Heffalump: i mean of the primitives of type IO,  i.e., not differentiable vi haskell.
12:32:17 <MonadKadaver> f is not a dataconstructor
12:32:22 <MonadKadaver> f is a function as f implies
12:32:29 <MonadKadaver> *Anagram> next $ listPermute 3 [0..2]
12:32:29 <MonadKadaver> Just listPermute 3 [0,2,1]
12:32:30 <Heffalump> well, the primitives of IO are either compiler/RTS implemented or FFI.
12:32:30 <jmcarthur> MonadKadaver, would you expect a C function to be able to do the same thing?
12:32:41 <Heffalump> Are you conflating those two classes?
12:32:43 <___> @paste your code, MonadKadaver
12:32:43 <Cale> MonadKadaver: Then all you can do is inspect the result of f and hope to recover what f must have been applied to.
12:32:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:32:48 <conal> sry.  "IO calls" doesn't capture what i meant.  "primitive API entry points"
12:32:59 <Heffalump> I'm lost again.
12:33:06 <MonadKadaver> @faq can haskell cracks Cs head open with only te power of ghc thoughts?
12:33:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:33:12 <Cale> MonadKadaver: wait, whoa
12:33:14 <Cale> MonadKadaver: What's going on there?
12:33:17 <conal> Heffalump: yes, and a few are from Functor, Applicative, Monad.
12:33:26 <Cale> MonadKadaver: Do you have a bunch of weird Show instances?
12:34:02 <MonadKadaver> http://hackage.haskell.org/packages/archive/permutation/0.4.1/doc/html/Data-Permute.html#v%3AlistPermute <- one of those functions must be able to tak it out right?
12:34:08 <Heffalump> conal: so you are including compiler-implemented primitives into the FFI bucket?
12:34:09 <MonadKadaver> ah elems ofc
12:34:40 <Heffalump> anyway, clearly IO will consistent almost entirely of external primitives, however you classify them
12:35:00 <conal> Heffalump: yeah.  i'm using the term "ffi" to mean calls into a language other than haskell, i.e., "foreign" function calls.  sorry i wasn't clearer the first time.
12:35:06 <Heffalump> I don't think this is an obstacle to the GADT model since you can just use strings and enumerate the possible types.
12:35:10 <Cale> MonadKadaver: ah, yeah, that's pretty specific to the library, since Permute is otherwise an abstract type
12:35:31 <Heffalump> clearly the GADT model isn't very useful as a denotational semantics, though..
12:35:33 <Cale> MonadKadaver: Normally, there's no way to recover the parameters to a function once it's been applied.
12:35:57 <Cale> MonadKadaver: Even if you're sure it hasn't been evaluated yet, it would break referential transparency to let you know if it had.
12:36:00 <conal> Heffalump: i agree.  it's a nice reference point in the space, to get a feel of the surroundings.
12:36:34 <conal> a helpful way of understanding what we don't mean by denotational semantics.
12:36:45 <Heffalump> btw, there I found some references to old threads on the subject of modelling IO
12:37:00 <Cale> MonadKadaver: Moreover, compilation does a lot of transformations to code which would be invalid if this sort of thing was to be relied upon.
12:37:00 <conal> Heffalump: yeah?
12:37:14 <Heffalump> http://mailman.science.ru.nl/pipermail/clean-list/1999/000915.html
12:37:17 <monochrom> "how to make use of (f a b :: Permute)" is a completely different question from "how to recover b in (f a b)".
12:37:27 <conal> Heffalump: thx.
12:37:37 <Heffalump> well, one reference, anyway
12:37:41 <pumpkin> I still want to be able to match on the number of arguments of a constructor :P
12:37:51 * Heffalump disappears to feed and change a small about-to-be-screaming thing
12:38:01 <pumpkin> good luck
12:39:46 <MonadKadaver> ok
12:39:47 <MonadKadaver> it works!
12:39:47 <MonadKadaver> now
12:40:04 <MonadKadaver> I need a dictionary with names
12:42:25 <mdmkolbe> Does anyone know of a good lazy directory reader (in the spirit of getContents or readFile but for directory trees instead of file contents) for Haskell?  (A quick glance through Hackage didn't turn up anything but maybe I missed it.)
12:44:11 <cocon> @ uncurry encodeFloat $ decodeFloat (0.0/0.0)
12:44:11 <cocon>  
12:44:33 <monochrom> use > in place of @
12:44:44 <cocon> thanks
12:44:46 <cocon> > uncurry encodeFloat $ decodeFloat (0.0/0.0)
12:44:47 <lambdabot>   -Infinity
12:44:51 <cocon> scandal?
12:44:51 <vixey> imagine if IO was strict (like readFile and so on read the whole thing)
12:44:56 <mauke> use sugar in place of salt
12:45:03 <vixey> how do you implement LazyIO using that?
12:45:11 <monochrom> yes, scandal it seems
12:45:14 <vixey> it's not possible is it, you have to have some new primitive ?
12:46:06 <monochrom> I need getChar. I need something else. Maybe continuations?
12:46:38 <monochrom> Maybe I just ask for getChar and unsafeInterleaveIO
12:46:48 <Eridius> monochrom: huh?
12:46:55 <blackh> mdmkolbe: I don't know of anything, but it would be easy to write using unsafeInterleaveIO.
12:48:58 <mdmkolbe> blackh: maybe, but I worry about consistency issues.  e.g. someone deletes or renames the directory in the middle of your interleaved IO reading
12:55:31 <mmorrow> mdmkolbe: what if you did "$ find / > foo.txt &", then started randomly deleting files?
12:56:38 <mmorrow> well, semi-bad example, but imagine if find was being piped into something that was doing stuff
12:56:44 <osfameron> @index maybeToBool
12:56:45 <lambdabot> bzzt
12:56:46 <mmorrow> i don't see how it's any different
12:56:47 <osfameron> meh
12:57:42 <osfameron> is there a good reason that's not defined?
12:57:46 <mmorrow> (otoh, using lazy IO for sockets or file handles when you are opening/(hopefully closing) a crapload of them scares me)
12:57:59 <dolio> > isJust (Just 5)
12:58:00 <lambdabot>   True
12:58:05 <dolio> > isJust Nothing
12:58:05 <mdmkolbe> mmorrow: yeah, I agree.  I guess I was kind of hopeing that someone had already thought about how to deal with that issue already so I don't have to
12:58:05 <lambdabot>   False
12:58:12 <mmorrow> mdmkolbe: :)
12:58:14 <osfameron> dolio: ah, thanks
12:58:18 <MonadKadaver> god guteneberg doesnt have one
12:58:26 <flazz> given that a function uses the IO monad, any function that calls it must also use it too? in other words if a function has IO in its type the entire callstack back to main does too?
12:58:34 <MonadKadaver> where would eb a good place to find jsut a lsit of names(in an easily parsed format preferrably)
12:58:52 <mdmkolbe> flazz: yes (unless you use unsafe hacks)
12:59:11 <pumpkin> > isJust life
12:59:13 <lambdabot>   False
12:59:24 <mdmkolbe> > life
12:59:25 <lambdabot>   Nothing
12:59:31 <pumpkin> (I'm a nihilist)
12:59:35 <flazz> mdmkolbe: so normally IO functions can call "pure" functions but not the other way around
12:59:38 <Eridius> flazz: yes
12:59:43 <mdmkolbe> flazz: yes
12:59:46 <Eridius> IO "taints" the type signature of the entire call stack
12:59:48 <Eridius> and it does so deliberately
12:59:54 <Eridius> ...it's like the GPL
12:59:57 <pumpkin> you can never escape!
12:59:57 <sioraiocht> hrm, why is any equaliser of any category a monomorphism?
13:00:03 <pumpkin> unless you know the backdoor
13:00:09 <flazz> Eridius, mdmkolbe: thanks clears it up
13:00:10 <Eridius> pumpkin: unfortunately GPL has no backdoor
13:00:15 <orzo> we should provide a means for people to interract deeply with the garbage collector
13:00:22 <Eridius> flazz: think of it as a non-referential-transparency taint
13:00:22 <orzo> ofr haskell code
13:00:23 <pumpkin> Eridius: but RMS does
13:00:41 <orzo> such as making explicitly managed buffers where pure values can reside
13:00:46 <mdmkolbe> flazz: intutitively this is reasonable.  after all, a function is impure if it contains effects anywhere
13:00:46 <flazz> Eridius: like a scarlet letter of side effect
13:00:51 <Eridius> flazz: exactly
13:01:05 <Duqicnk> it should be noted that not all monads are "tainting"
13:01:07 <orzo> and retiring the bufferes while rescuing values from them
13:01:08 <Eridius> any function with IO in the signature says "hey, I might be doing side effects! I'm not pure! I have no referential transparency!"
13:01:18 <Duqicnk> and in fact the IO monad is one of the weirder monads
13:01:19 <Eridius> Duqicnk: well no, usually you can escape the monad
13:01:23 <flazz> so when they say think of it as a map from World to World` its just a way to make the syntax functional not really the execution?
13:01:24 <vixey> yeah I wish people would use IO instead of unsafePerformIO
13:01:35 <Eridius> flazz: yeah. Ignore the RealWorld stuff
13:01:46 <mdmkolbe> Eridius: actually there is a backdoor to the GPL: negotiate a license from the copyright holders ;-J
13:01:46 <Eridius> flazz: that stuff is just type trickery to establish data dependencies
13:01:47 <vixey> most people seem to think if you proved that it's a safe use then it's fine
13:01:52 <Eridius> mdmkolbe: hah
13:01:59 <flazz> but with other modads i can extract the things inside the container and have those not be 'tainted' right?
13:02:04 <monochrom> You need ComplexWorld.
13:02:16 <mdmkolbe> flazz: yes and no
13:02:21 <pumpkin> QuaternionWorld
13:02:49 <___> > case Just 1 of Just x -> x -- indeed you can.
13:02:51 <lambdabot>   1
13:03:13 <___> just because some type constructor is in the Monad typeclass doesn't mean you can no longer match against it.
13:03:31 <mdmkolbe> flazz: most other monads provide a "run" method to encapsulate running the entire monad.  This sort of "untaints" the code.  But other than the "run" methods, you generally can't untaint your monads (for the same intutitive reasons you can't untaint IO)
13:03:52 <mdmkolbe> flazz: for example Reader has the runReader method
13:03:55 <mdmkolbe> @type runReader
13:03:56 <lambdabot> forall r a. Reader r a -> r -> a
13:04:15 <___> IO is abstract, it's implementation has not been exposed so you can't deconstruct IO actions.
13:04:22 <MonadKadaver> what is the complexity of best algorithm for permuting?
13:04:24 <monochrom> If M is a monad designed to be interesting, «M Int» is likely something way more complex than Int, and to say "get the Int out" is defeating the purpose. Take [Int] for example: "the" Int? It may have none, or it may have many, who's "the" Int in [1,2,3]?
13:04:29 <roconnor> @where TTFP
13:04:29 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
13:04:36 <dmhouse> Right, to unpack something with monadic type requires more structure than just the Monad typeclass provides, and hence may or may not be possible.
13:04:47 <monochrom> The same goes for Cont Int, Writer Int, ...
13:05:17 <flazz> ___: so IO has the types exposed but not he constructors?
13:05:20 <mdmkolbe> MonadKadaver: probably the complexity of the output relative to the input (i.e. exponential)
13:05:25 <___> flazz: indeed.
13:05:33 <flazz> this is so clean
13:05:35 <mdmkolbe> Flazz: not the deconstructors rather
13:05:38 <___> It is thus that referential transparency is enforced.
13:05:46 <mdmkolbe> (or the constructors I guess)
13:05:48 <___> by the implementation of IO.
13:06:05 <dolio> sioraiocht: If e is the equalizer of f and f', and h = e . g = e . g', then f . h = f . e . g = f' . e . g = f' . h, so there is a unique k such that e . k = h, but this means that g = g' = k.
13:06:06 <Duqicnk> "return" is sort of a constructor.  In the case of the Maybe monad it is just the constructor Just.
13:06:12 <MonadKadaver> should permuting simonpeytonjones be really expensive?
13:06:25 <beelsebob> Eridius: oh, so I am, thanks
13:06:29 <pumpkin> MonadKadaver: what are you trying to do?
13:06:33 <Duqicnk> But that's up to the Monad typeclass instance and there's no rule about how these things are implemented in terms of datatypes -- that's an invisible implementation detail
13:06:33 <blackh> mdmkolbe: On the question of consistency issues with directory contents. I don't think the operating system is capable of giving you the guarantee that it won't change as soon as you observe it.
13:06:34 <MonadKadaver> hmm i guess 40000000 combos is a lot
13:06:36 <pumpkin> , permutations "simonpeytonjones"
13:06:38 <lunabot>  luna: Not in scope: `permutations'
13:06:39 <beelsebob> I spent ages trying to find all the <*>s it had taken out thinking they were dodgy html
13:06:42 <dmhouse> Duqicnk: I think we mean actual data constructor when we say "constructor"
13:06:46 <___> > return 1 :: ((->) Char) Int -- (->) Char is the Monad in this case
13:06:48 <lambdabot>       Overlapping instances for Show (Char -> Int)
13:06:48 <lambdabot>        arising from a use ...
13:06:57 <MonadKadaver> the nbr of permutaions is: fac (length word) right?
13:07:00 <___> heh, and functions aren't really printable :)
13:07:09 <sioraiocht> dolio: thank you =)
13:07:12 <Eridius> flazz: monads aren't special, with the exception of the IO monad. You can usually "untaint" your monadic code by "running" the monad in some fashion, but with some datatypes even that doesn't make sense, like [] or Maybe
13:07:14 <___> > (return 1 :: Char -> Int)  'c'
13:07:15 <lambdabot>   1
13:07:17 <Eridius> but they provide their own ways to reach inside the box
13:08:11 <jmcarthur> Maybe's "run" function is probably maybe, if you really want to pinpoint one
13:08:12 <jmcarthur> :t maybe
13:08:13 <mdmkolbe> blackh: as you say, it probably can't.  but it would be nice to have a clean interface to deal with recovery from that in a way that models some sort of consistency even if that means just detecting the inconsistency and backing out
13:08:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:08:15 <dmhouse> There's also no common way to "run" a monad. I.e. for Reader you need to provide an environment, but for Cont you need to provide a final continuation. For Maybe and [] you don't need to provide anything at all, but you may get nothing or lots of things back.
13:08:16 <monochrom> It is unhealthy to be obsessed with "getting it out". The point of monads is not to get it out.
13:08:37 <jmcarthur> and []'s is probably something like foldr or something
13:08:50 <monochrom> If the point were to get it out, you would be using a collection not a monad.
13:08:58 <MonadKadaver> what complexity is O(fac n) ?
13:09:02 <Eridius> jmcarthur: although in general these types expose their constructors so you don't even need a "run"
13:09:05 <flazz> so about monads, they are pure for the most part, IO is a special case where interaction is limited, but other than that they simulate mutable state?
13:09:11 <Eridius> so with [] and Maybe you can just match on the constructor
13:09:19 <___> flazz: the State monad does, yes.
13:09:19 <Duqicnk> flazz, they can simulate lots of different things
13:09:23 <Eridius> flazz: well, State simulates mutable state
13:09:30 <Eridius> but Monad in general says nothing about state
13:09:34 <EvilTerran> MonadKadaver, that's superexponential; i think it's equivalent to O(n*(2^n))
13:09:40 <___> @unmtl State a b
13:09:41 <lambdabot> a -> (b, a)
13:09:43 <Eridius> hell, Monad doesn't even necessarily impose an order on actions, even though the IO monad does
13:09:53 <dmhouse> The most general thing you can say is that Monads simulate a type of computation with "a bit more going on".
13:10:14 <dolio> n! ~ n^n
13:10:15 <dmhouse> (In the case of Reader it's that you can pull from an environment, in the case of Maybe it's that the computation may fail, etc.)
13:10:18 <Duqicnk> the most general thing you can say is some gibberish involving the word "endofunctor" :)
13:10:20 <Eridius> Monads just wrap actions with extra invisible structure
13:10:25 <jmcarthur> monads in a nutshell: (<$>) :: (a -> b) -> (m a -> m b); (<*>) :: m (a -> b) -> (m a -> m b); (=<<) :: (a -> m b) -> (m a -> m b)
13:10:29 <mdmkolbe> flazz: monads are a way of simulating impurity in a pure language.  Technically even IO is pure as far as the upper levels of the compiler understand (at the lower levels they hack it a bit).
13:10:29 <EvilTerran> dolio, ah, n^n, right. thought it was something like that.
13:10:45 <Duqicnk> flazz: if you want to understand monads in general, start with Maybe
13:11:00 <dmhouse> mdmkolbe: monads can be used to do that, but I wouldn't say that's all they're used for.
13:11:04 <jmcarthur> ^^ just lifting pure functions to work in contexts where something more, hidden can also happen
13:11:22 <flazz> is it more like a normal function has input and output, but with a monad you can have a structure where function composition is no longer serial? (in a way)
13:11:42 <jmcarthur> flazz, monads are far less specific
13:11:49 <___> flazz: it depends on how you define (>>=) for your Monad instance.
13:11:51 <dmhouse> Sort of. You have extra "plumbing" which the monadic structure hides
13:11:51 <jmcarthur> it's all about the types and the laws, and that's it
13:12:10 <dmhouse> jmcarthur: yet that's a very poor way to understand why monads are useful.
13:12:14 <flazz> so the type is like a bucket, is that a good way to thin about it?
13:12:22 <flazz> and return puts something in the bucket
13:12:25 <Duqicnk> ah analogies
13:12:35 <flazz> Duqicnk: sorry :)
13:12:42 <jmcarthur> dmhouse, of course, but there really isn't another way to say it that is as precise. large numbers of examples are useful for learning
13:12:42 <BONUS> flazz: check this out http://www.haskell.org/haskellwiki/Monads_as_Containers
13:12:50 <flazz> >>= is the part i have trouble with
13:12:51 <Duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
13:12:54 <BONUS> i'm not so against explaining moands with analogies
13:13:02 <mdmkolbe> dmhouse: I would disagree with your disagreement with me, but maybe we just have different definitions of "impure".  e.g. I consider non-determinism to be impure
13:13:07 <BONUS> it helps people get them and after some use they see what they really are
13:13:16 <dmhouse> flazz: that's because >>= is more akin to "monads as computations" rather than "monads as containers"
13:13:28 <___> @remember Duqicnk a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
13:13:28 <lambdabot> Done.
13:13:30 <mauke> preflex: remember <Duqicnk> a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
13:13:44 <monochrom> Philip Wadler's http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf is still the most scientific way to learn about monads.
13:13:47 <BONUS> the thing is if you want to give a precise explanation of what monads are, you just have to describe them as a triple with a type constructor, return, >>=, satisfying these laws blah blah
13:13:54 <dmhouse> flazz: this might help: an equivalent way to declare something as a monad is to give a function return :: a -> M a and join :: M (M a) -> M a. Then return puts something into a bucket and join takes a bucket full of buckets and empties the inner buckets into the outer one.
13:13:54 <jmcarthur> flazz, i like (=<<) :: (a -> m b) -> (m a -> m b) more than (>>=) because it makes it feel more like a lifting function
13:14:03 <BONUS> but from that it's very hard to gain some intuition
13:14:54 <flazz> BONUS: does the intuition come?
13:15:00 <MonadKadaver> so to find all permutations of simonpeytonjones will not work and there jsut isnt an algorithm for it? so I have to limit the way I permute somehow tomake it work practically?
13:15:04 <BONUS> yeah, just start using them
13:15:08 * jmcarthur hates container metaphors. specific examples are better than misleading general metaphors
13:15:21 <flazz> besides IO, what is a good one to play with?
13:15:24 <Duqicnk> Maybe
13:15:26 <mdmkolbe> MonadKadaver: what are you actually trying to do?
13:15:28 <Duqicnk> IO is *not* a good one
13:15:28 <BONUS> Maybe, List ...
13:15:30 <jmcarthur> @instances Monad
13:15:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:15:33 <Duqicnk> people only learn it because it's useful
13:15:37 <MonadKadaver> Maybe is the greatest thing since slicedbread
13:15:39 <monochrom> I am against all analogies because people spend time on the analogies and postpone using the monads.
13:15:40 <sioraiocht> dolio: is it accurate to say that f factors through g iff the range of f lies within the image of g?
13:15:42 <jmcarthur> Either, Maybe, Reader, State
13:15:42 <Duqicnk> IO is the most confusing and bad-intuition-building monad
13:15:47 <mdmkolbe> flazz: Maybe, Error, Reader, and State
13:15:52 <jmcarthur> and []
13:15:55 <sioraiocht> or is that not biconditional?
13:15:56 <jmcarthur> and ZipList
13:15:59 <Duqicnk> learn to use Maybe, then implement it yourself (3 lines of code)
13:16:02 <BONUS> Writer is also pretty cool if you take 2 minutes to understand monoids
13:16:04 <jmcarthur> actually, ZipList isn't a monad is it?
13:16:05 <jmcarthur> woops
13:16:05 <EvilTerran> Cont if you want to melt your brain
13:16:11 <dmhouse> flazz: in the alternative "monads as computations" analogy, return makes a computation which ignores the plumbing, whatever it may be in your speicfic case, and m >>= f runs the computation m, extracts the value from it (magically! As there is no other way to extract a value out of a monad), then feeds it into the function f, which produces another computation.
13:16:13 <flazz> i have this idea in my head that the do notation is to be used for every monad, is that true?
13:16:15 <BONUS> infinite ZipLists are a monad i think
13:16:18 <orzo> why is IO not a good one?
13:16:25 <monochrom> And I have already cited what I think is a superior, productive way in its stead.
13:16:30 <BONUS> my problem with "computation" is that it's so vague
13:16:31 <Duqicnk> flazz, do notation is notational sugar for use of "return" and ">>="
13:16:35 <BONUS> i mean even if you take
13:16:36 <BONUS> > 3
13:16:37 <lambdabot>   3
13:16:39 <BONUS> that's a computation
13:16:43 <monochrom> @quote nothingness
13:16:44 <lambdabot> monochrom says: "Monad is about computation." "Our company is about synergy." "iPod is about coolness."  Godawful postmodernism nothingness.
13:16:47 <BONUS> in a way
13:16:54 * mdmkolbe will someday write up his "monads are a way to redifine semi-colon" analogy
13:16:55 <Duqicnk> BONUS: there's an Identity monad
13:17:03 <BONUS> yeah
13:17:05 <MonadKadaver> mdmkolbe: a program that finds the anagrams of a name. so I egenrate all permutations of the name and check against a name-dictionary(thatn Imyet to find). but the nbr of combos is to big.
13:17:10 <Duqicnk> mdmkolbe: that's exactly what i tell C++ people when they claim every opr can be overloaded in C++
13:17:20 <___> > runState (put "a" >> return 1 >>= \n -> modify (++ show n) >> get) ""
13:17:20 <lambdabot>   ("a1","a1")
13:17:20 <MonadKadaver> mdmkolbe: a program that finds the anagrams of a name. so I egenrate all permutations of the name and check against a name-dictionary(thatn Imyet to find). but the nbr of combos is to big.
13:17:38 <mauke> Duqicnk: except ; is not an operator in C++. tell them about sizeof instead :-)
13:17:38 <Flugan> how do I apply foldM_ to get hanging lambda layout or is there a better way?
13:18:04 <Duqicnk> orzo, IO is not expressible in Haskell, its semantics are complicated to write down, you can't get a pure value back out, and it's considered a moral failing to use it when not necessary
13:18:09 <jmcarthur> flazz, i strongly discourage do notation whenever possible, but there is certainly no universal agreement about that
13:18:11 <Duqicnk> none of which is true for most other standard Monads
13:18:11 <vixey> Our company is about synergy  is my favorite
13:18:16 <mdmkolbe> MonadKadaver: odd, considering, I have to think through all the anagrams of your messages (j/k) (you have lots of swapped letters)
13:18:34 <orzo> moral failing heh
13:19:11 <mdmkolbe> MonadKadaver: maybe a better solution would be to prune your permutation generator as it goes based on the dictionary
13:19:33 <orzo> Duqicnk, do you discourage do notation for IO also?
13:19:37 <Duqicnk> whereas other monads are primarily used to take things that are already in Haskell-without-monads and make them more concise and easy to read/write/maintain
13:19:46 <Duqicnk> i like do notation
13:19:51 * sioraiocht like do notation
13:19:52 <Duqicnk> i don't know where jmcarthur is coming from
13:19:54 <jmcarthur> i think do notation is acceptable for IO
13:19:56 <Duqicnk> you just should understand how it works
13:19:57 <sioraiocht> *likes
13:20:00 <jmcarthur> just not for monads in general
13:20:02 <mdmkolbe> MonadKadaver: for example if the permutation generator starts to generate strings starting with "zzz", it could stop searching because there are no words starting with "zzz"
13:20:05 <MonadKadaver> prune?
13:20:10 <sioraiocht> Duqicnk: yes, it's important to realise it IS just syntactic sugar
13:20:27 <jmcarthur> not all monads are imperative, but do notation tries to make it appear to be so
13:20:48 <orzo> Duqicnk: sorry, i meant jmcarthur
13:20:51 <dmhouse> A lot of them are, though, State, Reader...
13:20:58 <EvilTerran> MonadKadaver, sounds like you could use an anagram dictionary
13:20:58 <orzo> jmcarthur, do you discourage do notation for IO also?
13:21:01 <EvilTerran> (see http://en.wikipedia.org/wiki/Anagram_dictionary)
13:21:03 <dmhouse> Most monads in practice are transformers based on one of those, too.
13:21:05 <jeffersonheard> jmcarthur: this is why I try to define an Applicative instance for any monad that isn't imperative and use that in my programs to differentiate
13:21:05 <MonadKadaver> you check if letetr exist then put in front?
13:21:05 <MonadKadaver> mdmkolbe:well the inpiut will be names which kind iof eliminates such things anyway
13:21:07 <mdmkolbe> MonadKadaver: "prune", term from search trees, it means to stop searching down one path (i.e. you cut a branch off)
13:21:09 <Duqicnk> jmcarthur: but all monads are about sequencing actions with (>>=)
13:21:18 <jmcarthur> orzo, "<jmcarthur> i think do notation is acceptable for IO"
13:21:26 <Duqicnk> which gives a natural bijection with do notation
13:21:27 <jmcarthur> Duqicnk, that's where you're wrong
13:21:32 <Duqicnk> esp. because it's associative
13:21:39 <jmcarthur> Duqicnk, what does sequencing have to do with the list monad, for example?
13:21:41 <jeffersonheard> Duqicnk: or at least that's one "view" of a monad
13:21:42 <BONUS> i think do notation is cool for monads with a sense of sequencing
13:22:10 <orzo> is do notation not one of the points of using monads?
13:22:20 <jmcarthur> well, perhaps you can contort your brain into seeing the list monad as sequencing...
13:22:22 <BONUS> scratch that. i think it's cool for monads where you'd usually end up just binding to lambdas anyway
13:22:24 <Duqicnk> orzo: do notation exists to make monads easier to use
13:22:27 <jmcarthur> orzo, not in my opinion
13:22:39 <jeffersonheard> for example, consider the RWH examples of the Parsec parser.  I think that the Applicative view of Parsec is much more natural to read and much more semantically accurate than the "do" or "sequencing" view of Parsec
13:22:52 <Duqicnk> using monads requires writing expressions that involve "return" and ">>=" or things derived from them; do notation is a simpler syntax for such expressions
13:23:06 <jmcarthur> jeffersonheard, of course, there are some things you can do with monadic Parsec that you can't with applicative Parsec
13:23:11 <Duqicnk> they really are expressions unlike most other languages where there is a statement / expression distinction
13:23:11 * wli suggests Data.MultiSet Char (cf. cabal/hackage for Data.MultiSet).
13:23:28 * jmcarthur doesn't think do is simpler at all
13:23:44 <jeffersonheard> jmcarthur: I'm aware, but on the other hand, I think it's fair to say that any RG or CFG can be parsed with applicative Parsec
13:23:53 <jeffersonheard> not that I've tried to prove this
13:24:00 <jmcarthur> do { x <- foo; bar x } ... bar =<< foo
13:24:10 <EvilTerran> jeffersonheard, the proof is pretty straightforward, i think
13:24:21 <jmcarthur> jeffersonheard, probably the case
13:24:51 <jeffersonheard> EvilTerran: I suspect so, just haven't ventured to try
13:25:28 <___> jeffersonheard: you must remember that if 'x' is a refutable pattern, do notation isn't quite that simple.
13:26:18 <Hunner> whoa, ___ is a valid nick
13:26:22 <___> @undo do { Cons x <- exp1; exp2 }
13:26:22 <lambdabot> exp1 >>= \ a -> case a of { Cons x -> exp2; _ -> fail ""}
13:26:24 <mdmkolbe> is there a type synonym for [Word8] similar to the type synonym (String) for [Char]?
13:26:25 <jmcarthur> ___, i think you mean to direct that at Duqicnk ?
13:26:50 <___> er, jmcarthur, rather
13:26:52 <Eridius> mdmkolbe: you could define one
13:27:16 <mdmkolbe> Eridius: yes, but if there is already a standard one, I'd prefer to use that
13:27:24 <Eridius> mdmkolbe: I don't believe there is
13:27:26 <jmcarthur> ___, oh, you mean to point out that my example could be made worse ;)
13:28:48 <MonadKadaver> so whats the best way to parse a website in haskell?
13:28:53 * wli 's anagram implementation sucks.
13:29:15 <jmcarthur> what's with the anagram stuff lately?
13:29:33 <jmcarthur> i wrote one a few weeks ago, but it wasn't as fast as it could be
13:29:43 <jmcarthur> this was also a multiword anagram finder though
13:29:45 <kynky> if website in well formed xml use haxml ?
13:30:21 <mdmkolbe> tagsoup?
13:30:24 <EvilTerran> if it's std internet broken XML, try tagsoup
13:30:31 <Eridius> Haskell has no analogy to WWW::Mechanize unfortunately
13:30:58 <MonadKadaver> did dons write tagsoup?
13:31:12 <MonadKadaver> jmcarthur: paste yours?
13:31:27 <jmcarthur> MonadKadaver, it isn't on this computer, unfortunately
13:31:39 <orzo> what do people want for haskell
13:31:49 <MonadKadaver> orzo: ?
13:32:07 <orzo> should it get hugely popular and take over
13:32:08 <jmcarthur> MonadKadaver, long story short, though, this implementation uses a combination trie/kd-tree to store known words in
13:32:08 * pumpkin wants to implement DAWGs in haskell, but it's hard
13:32:20 <wli> http://wli.pastebin.com/m39222eed <-- crappy anagram generator
13:32:44 <jmcarthur> MonadKadaver, i also have written a faster one that uses fingertrees in a way that is completely twisted and should never work
13:32:48 <Eridius> orzo: if haskell got hugely popular it would start to suck :{
13:32:49 <Eridius> *:P
13:32:52 <jmcarthur> but it does somehow
13:32:57 <orzo> Eridius: why?
13:33:04 <Eridius> popularity involves lots and lots of compromise
13:33:09 <wli> pumpkin: What's a DAWG? Directed Acyclic Weighted Graph? Wouldn't it be more like some sort of algorithm on DAWG's?
13:33:10 <Duqicnk> yay elitism
13:33:20 <jmcarthur> sup dawg
13:33:23 <pumpkin> wli: well yeah, but constructing a DAWG in the first place is hard :)
13:33:37 <pumpkin> wli: once you have one, finding anagrams isn't very hard
13:33:41 <pumpkin> or shouldn't be
13:34:03 <pumpkin> DAWGs also just have a cool name, and are a very nice compact representation of a dictionary
13:34:15 <Adamant> please do not do the meme
13:34:18 <Adamant> you know the one
13:34:21 <Adamant> it's been done
13:34:22 <pumpkin> and then
13:34:23 <Adamant> don't do it
13:34:24 <pumpkin> if you have a DAWG
13:34:30 <pumpkin> you could make a DAWG of DAWGs ;)
13:34:39 <Adamant> pumpkin: nooooooooooo
13:34:44 * pumpkin grins
13:34:44 <bavardage> then you could make a function WASSUP
13:34:53 <bavardage> and then you could be like
13:34:56 <bavardage> wassup DAWG
13:35:02 <jmcarthur> bavardage, you just killed it
13:35:05 <wli> pumpkin: Give vertices Int labels, give edges Int labels, make vertices IntMap IntSet where IntSet is the set of edges attached to a node, then tabulate edges in IntMap (Int, Int, WeightType)
13:35:13 <orzo> What about comercial uses?
13:35:22 <pumpkin> wli: oh, I misread your comment
13:35:28 <orzo> do we want haskell used widely for comercial purposes?
13:35:29 <pumpkin> DAWG = directed acyclic word graph
13:35:35 <bavardage> jmcarthur: :(
13:35:43 <pumpkin> wli: basically a prefix/suffix trie in one graph
13:35:45 <Duqicnk> nobody is going to force anyone to stop implementing useless cool things
13:36:03 <conal> as long as they type-check ;)
13:36:05 <wli> I think most of where I'm getting killed is dictionary construction, but anyway.
13:36:10 <blackh> wli: fwiw http://wli.pastebin.com/m5af9543
13:36:20 <blackh> wli: My implementation of the same thing
13:37:10 <jmcarthur> mine had a binary tree where each branch has a letter. all the words on the left have that letter, all the words on the right do not
13:37:22 <jmcarthur> that was my slower one
13:37:23 <McManiaC> how can i use "length l" with Floating numbers? i always get "expected Float against inferred Int" or sth like that
13:37:26 <Heffalump> orzo: well, it makes work more fun :-)
13:37:36 <pumpkin> jmcarthur: you should try a DAWG then :P
13:37:43 <Heffalump> though F# is ok in its own way
13:37:47 <pumpkin> jmcarthur: if you can make a haskell DAWG implementation, I'll love you long time
13:37:51 <wli> blackh: Yeah, I should've been using IntMap Int etc.
13:37:54 <Eridius> is there any sort of online repository for Haskell papers?
13:38:22 <wli> pumpkin: A DAWG is then a trie with common suffixes combined?
13:38:23 <orzo> Heffalump: i agree, i vote for popularity and commercial use
13:38:28 <pumpkin> wli: yup
13:38:28 <orzo> heh
13:38:55 <jmcarthur> my faster one had a fingertree indexed by letter sets (bitfields), with the words sorted such that those containing the most common letters appeared first
13:39:22 <jmcarthur> and i split the fingertree at the first word that only contained letters not used yet
13:39:44 <orzo> has a record type other than haskell98's found its way into multiple compilers?
13:40:01 <Heffalump> I don't think any has found its way into any compiler.
13:40:12 <orzo> not even ghc?
13:40:24 <wli> Well, I'm not really intelligently handling the dictionary.
13:40:49 <wli> So the biggest pain here is loading the dictionary at every turn.
13:40:51 <Heffalump> orzo: nope
13:40:59 <monochrom> McManiaC: fromIntegral (length xs)  does it help?
13:41:16 <Duqicnk> @type \xs -> fromIntegral $ length xs
13:41:16 <wli> Data.List.genericLength
13:41:17 <lambdabot> forall b a. (Num b) => [a] -> b
13:41:19 <orzo> Heffalump: do you like it that way?
13:41:20 <monochrom> > fromIntegral (length [True]) + 2.3
13:41:22 <lambdabot>   3.3
13:41:38 <McManiaC> thx! monochrom
13:41:41 <Heffalump> orzo: nope
13:41:52 <Heffalump> records are one of the suckiest things about Haskell
13:42:50 <orzo> i agree heh
13:42:50 <monochrom> @quote fromIntegral
13:42:51 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
13:43:07 <jmcarthur> yeah i pretty much only use record syntax to define simple "getter" functions
13:43:19 <jmcarthur> i almost never use them as setters
13:43:22 <Heffalump> data-accessor makes things a bit better
13:43:29 <wli> @type genericLength
13:43:30 <lambdabot> forall b i. (Num i) => [b] -> i
13:43:30 <Heffalump> but extensible records would be really nice
13:43:45 <Eridius> http://www.haskell.org/haskellwiki/Research_papers references haskell.readscheme.org but that site doesn't seem to exist
13:43:48 <wli> extensible variants are more important
13:45:23 <mdmkolbe> @hoogle hex
13:45:23 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
13:45:24 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
13:45:24 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
13:49:06 <MonadKadaver> friggin elegant
13:49:29 <MonadKadaver> wli: what kind of dict do you have?
13:49:54 <wli> MonadKadaver: Map (MultiSet Char) (Set String)
13:51:18 <vixey> would anyone help me with this program please ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2015#a2015
13:51:37 <vixey> I want to write parse, that somehow gets a Parens out from a String (unless there isn't one in there)
13:51:54 <vixey> but also would like to be able to prove that it is correct (in that it always gives a good parse, and that it never gives a bad parse)
13:52:23 <vixey> so what are good ways to implement it that would help make that possible? and how would you actually go about doing it?
13:53:04 <MonadKadaver> vixey: you mean "he(llo" -> "hello"?
13:53:14 <MonadKadaver> just geenrallyeliminate all paerns?
13:53:16 <pumpkin> BONUS: omg how did it get there??
13:53:17 <___> vixey: you could match character-by-character, but that's a bunch of legwork.  Try Parsec.
13:53:48 <BONUS> get what who where
13:53:57 <pumpkin> the dingo
13:53:59 <vixey> ___: Say I implement a mini-parsec and write the parser using that, how could I go about giving a correctness proof of this?
13:54:00 <pumpkin> like, duh
13:54:01 <___> MonadKadaver: nah, vixey wants to generate Parens values given a String.
13:54:14 <BONUS> ah hehe. turns out its a ghost
13:54:50 <pumpkin> oh no
13:56:28 <vixey> I know lots of way to write a parser though, the problem is that not one of them can I actually /prove/ correct
13:56:49 <dolio> How can it always yield a good parse if there are strings that don't correspond to any Parens?
13:57:34 <vixey> dolio: well the type might be like  String -> Maybe Parens,  if it's Nothing then the string should be invalid, if it's Just x then the string should be print x
13:57:58 <vixey> this is basically the formal specification I would like to prove, but atm I'm not sure Maybe Parens is the best -- so I left it as a ?
13:59:09 <cocon> > maxBound :: Char
13:59:10 <lambdabot>   '\1114111'
13:59:17 <cocon> what does this mean?
13:59:28 <vixey> cocon: it's a very large unicode char
13:59:42 <Gracenotes> the largest!
13:59:46 <___> > '\65'
13:59:47 <lambdabot>   'A'
13:59:56 <Gracenotes> well, at least in this scheme
14:00:00 <dmhouse> Chars have finite size. That's the Show representation for the largest number that will fit in a Char,
14:00:18 <cocon> so what encoding is used in String?
14:00:30 <dmhouse> String is [Char].
14:00:32 <pumpkin> none
14:00:37 <pumpkin> it's UCS4 I guess
14:00:58 <Gracenotes> I suppose Char is like wchar?
14:01:06 <vixey> maybe my example of parens is too complicated for someone to teach me about over IRC .. but in that case are there any texts or books which cover proving this sort of thing?
14:02:11 <Gracenotes> @hoogle Word8
14:02:11 <lambdabot> Data.Word data Word8
14:02:11 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
14:02:23 <wli> How big are the dictionaries you're using?
14:03:04 <saml> > id ((((((((((((((((((((((()))))))))))))))))))))))
14:03:05 <lambdabot>   ()
14:03:14 <wli> Or (better yet) what dictionaries are you using?
14:03:18 <saml> wow parenthesis matched!
14:03:47 <___> > () -- this is a special value called 'unit'
14:03:49 <lambdabot>   ()
14:03:57 <___> > (()) -- this is unit in a pair of parentheses
14:03:58 <lambdabot>   ()
14:04:14 <dmhouse> There is no 1-tuple in Haskell.
14:04:23 <___> Identity :)
14:04:44 <mdmkolbe> @hoogle Word8 -> Int
14:04:44 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
14:04:44 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
14:04:44 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
14:05:05 <travisbrady> > fmap (+1) (1,2)
14:05:07 <lambdabot>   (1,3)
14:05:08 <MonadKadaver> how do I filter or on a constructor?
14:05:18 <orzo> bytestrings are nice
14:05:28 <travisbrady> that use of fmap on tuples doesn't work for me in ghci, this is from http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
14:05:56 <dmhouse> travisbrady: I think lambdabot has a couple of extra Functor/Monad instances.
14:05:57 <___> it's probably in Data.Monad.Instances
14:06:07 <travisbrady> dmhouse: ahh, thank you
14:06:08 <dmhouse> Try importing Control.Monad.Instances, they're in there IIRC.
14:06:28 <travisbrady> ahh, there we go
14:06:30 <___> er, Control, right
14:06:50 <kadaver> <__> get a name
14:07:34 <___> I have a name.
14:08:06 <ziman> how do you pronounce it? :)
14:08:08 <kadaver> what use is id of?
14:08:21 <dmhouse> > (id *** show) (2,3)
14:08:22 <lambdabot>   (2,"3")
14:08:33 <Gracenotes> there was a question about id the other day too :)
14:08:35 <dmhouse> For example.
14:08:47 <___> > either id show (Left 1)
14:08:47 <mdmkolbe> ___: how do you pronounce your name?
14:08:48 <lambdabot>       No instance for (Num String)
14:08:48 <lambdabot>        arising from the literal `1' at <in...
14:08:48 <ziman> > zipWith id [(+1), (*2), (/9)] [1..3]
14:08:50 <lambdabot>   [2.0,4.0,0.3333333333333333]
14:09:00 <___> mdmkolbe: any way you like :)
14:09:05 <kadaver> identity?
14:09:09 <ziman> ($) is id in disguise :)
14:09:25 <dmhouse> ziman: up to types and fixity.
14:09:32 <___> > either id show (Left "blah")
14:09:33 <lambdabot>   "blah"
14:09:40 <___> > either id show (Right 5)
14:09:41 <lambdabot>   "5"
14:09:47 <ziman> dmhouse, right.
14:09:57 <kadaver> id __
14:09:57 <kadaver> > id __
14:09:58 <lambdabot>   Not in scope: `__'
14:10:15 --- mode: Heffalump set -o Heffalump
14:11:07 <vixey> > let __ = id __ in id __
14:11:08 <lambdabot>   * Exception: stack overflow
14:11:31 <___> identifiers starting with _ are ignored.
14:11:40 <travisbrady> why does fmap operate only on the second element of a pair?
14:11:43 <vixey> > let __ = 3 in id __
14:11:44 <lambdabot>   3
14:11:59 <___> hmm, guess I was wrong
14:12:02 <travisbrady> and why does the following not work?
14:12:03 <vixey> travisbrady: there's only a function instance for the second half of the tuple
14:12:07 <travisbrady> > fmap (+1) (2, 2, 2)
14:12:08 <lambdabot>       No instance for (Functor ((,,) t t1))
14:12:09 <lambdabot>        arising from a use of `fma...
14:12:11 <saml> > let _ = 3
14:12:12 <lambdabot>   <no location info>: parse error on input `;'
14:12:18 <vixey> > fmap (+1) ((2, 2), 2)
14:12:20 <lambdabot>   ((2,2),3)
14:12:27 <saml> > let _ = 3 in 3
14:12:28 <lambdabot>   3
14:12:30 <vixey> > (fmap fmap fmap) (+1) (2, (2, 2))
14:12:32 <lambdabot>   (2,(2,3))
14:12:46 <Gracenotes> > let (__) = const{-ant-} fail in "Can anyone pronounce"  `__`  "?"     >[]
14:12:47 <lambdabot>   False
14:12:47 <___> travisbrady: Functor only applies to types of kind * -> *
14:12:48 <travisbrady> vixey: is the idea that it's a proplist or something and so you'd only ever want to touch the value?
14:12:58 <Gracenotes> see, even lambdabot thinks no one can pronounce __
14:13:04 <vixey> n
14:13:05 <vixey> o
14:13:09 <vixey> it's just a limitation of haskell
14:13:28 <travisbrady> thank you
14:13:49 <saml> > (fap fap fap) boobies yay where fap = fmap; boobies = (+1); yay = (2,(2,2))
14:13:50 <lambdabot>   Couldn't match expected type `(->) (a -> a)'
14:13:51 <kadaver> so how can I filter out a tag from a lsit
14:13:51 <kadaver> I want all TagText
14:13:51 <kadaver> filter (==TagText _) xs
14:13:51 <kadaver> fail!
14:14:00 <lament> @nickometer ___
14:14:00 <lambdabot> Unknown command, try @list
14:14:08 <lament> !nickometer ___
14:14:09 <jeffersonheard> okay, blog post on the not-FRP.  Feel free to recoil in horror now: http://vis.renci.org/jeff/2009/03/31/almost-but-not-quite-entirely-like-frp/
14:14:13 <jeffersonheard> heading home
14:14:24 <lament> preflex: nickometer ___
14:14:25 <preflex>  ___ is 97.05% lame
14:14:32 * vixey wonders if they started a non-frp trend
14:14:45 <___> kadaver: filter isTagText xs where isTagText (TagText _) = True; isTagText _ = False
14:15:00 <olsner> preflex: nickometer olsner
14:15:00 <preflex>  olsner is 0% lame
14:15:04 <olsner> :D
14:15:10 * Gracenotes is 0% lame too
14:15:27 <wli> I'm not sure how a DAWG would help generate anagrams. Mostly I see anagram dictionaries coming up. Maybe they'd be more space efficient methods of representing the entries in anagram dictionaries than Set String.
14:15:30 * ___ defies anyone else to have a lamer nick
14:15:38 <vixey> preflex: nickometer ___
14:15:39 <preflex>  ___ is 97.05% lame
14:15:46 <vixey> preflex: nickometer ____
14:15:46 <preflex>  ____ is 99.8470% lame
14:15:49 <vixey> preflex: nickometer _____
14:15:49 <preflex>  _____ is 99.931998% lame
14:15:53 <vixey> preflex: nickometer ________________________________________________
14:15:54 <preflex>  ________________________________________________ is 99.99646044% lame
14:16:01 <vixey> this isn't working ..
14:16:12 <Gracenotes> preflex: nickometer 0
14:16:12 <preflex>  0 is 22% lame
14:16:15 <vixey> is it possible t oget 100%?
14:16:27 <lament> perhaps you need an infinitely long nickname
14:16:31 <___> preflex: nickometer .
14:16:32 <preflex>  . is 14% lame
14:16:36 <Gracenotes> preflex: nickometer s8xx0r5
14:16:37 <preflex>  s8xx0r5 is 99.8477% lame
14:16:42 <kynky> just define one in haskell
14:16:53 <mdmkolbe> nickometer: spjones
14:17:00 <Gracenotes> all characters = 100
14:17:10 <Gracenotes> er, = 0
14:17:11 <Debugger> preflex: nickometer /0\_-
14:17:11 <preflex>  /0\_- is 99.7581% lame
14:17:14 <mdmkolbe> preflex: nickometer spjones
14:17:15 <preflex>  spjones is 0% lame
14:17:32 <mdmkolbe> well at least it got that one right ;-J
14:17:34 <vixey> @tell jeffersonheard  type Diff a = Insertion (Event a) | Deletion (Event a) -- what
14:17:34 <orzo> what's @: mean in a makefile rule?
14:17:35 <lambdabot> Consider it noted.
14:23:04 <olsner> orzo: perhaps that's the rule for an output file called '@'
14:23:21 <olsner> (ot for #haskell though)
14:24:27 <_dls> hey guys, I seem to have hit a wall re: type classes, and have chased the problem down to a six line test case. Can anyone shed some light on http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2016#a2016 ?
14:25:01 <dolio> String = [Char]
14:25:21 <dolio> So [a] overlaps with it.
14:25:21 <tibbe> we need more gsoc projects!
14:25:24 <___> _dls: look at :type check
14:25:32 <tibbe> web servers, data structures etc!
14:26:17 <___> I don't think check = "String" typechecks with check :: (StringSwitch a) => a -> String
14:26:28 <sm> it sure doesn't
14:26:47 <dolio> Yeah, that too.
14:27:04 <___> I suppose it could.  Aren't string literals polymorphic nowadays?  :3
14:27:08 <orzo> olsner: no, it's in teh body of a rule.  @ usually means no echo and i notice that : actually works at the commadn prompt
14:27:09 <FunctorSalad> oh sorry I'd been typing on my keyboard while in "face on thedesk"" mode, sorrt if I spammed #haskel thtatway :(
14:27:16 <orzo> so maybe it's invoking : at the prompt
14:27:18 <_dls> so there's now way to do separate instances for list types?
14:27:42 <olsner> orzo: ah, then it means not to print the command before running it
14:28:05 <orzo> olsner: yes, but now i'm wondering what the colon command is at the prompt
14:28:14 <orzo> its a bash builtin apparently
14:28:21 * wli suspects the dictionary he's using is full of junk and too big.
14:28:32 <olsner> and nm me, that's exactly what you said just now :P yeah, colon has some kind of meaning that has always eluded me
14:28:33 <tibbe> I would be willing to mentor anyone working on network related stuff (or iteratee I/O). perhaps an implementation of Amazon's Dynamo? :)
14:28:50 <___> _dls: add a parameter to both of your check implementations.
14:29:01 <___> you probably want _
14:30:31 <_dls> ___: sorry about that, you're right the code I pasted is invalid, however the same error occurs after the fix
14:30:32 <___> : [arguments]     No effect; the command does nothing beyond expanding arguments and performing any specified redirections. A zero exit code is returned.
14:31:42 <orzo> "Do nothing beyond expanding arguments and performing redirections. The return status is zero. "  -- bash colon command
14:31:57 <orzo> sounds similar to true then
14:32:12 <orzo> thanks
14:33:09 <orzo> thanks ___
14:33:32 <wli> Every letter of the alphabet by itself and a bunch of vowel-less abbreviations are cropping up.
14:34:31 <___> _dls: you could use {-# LANGUAGE OverlappingInstances #-}
14:34:56 <_dls> ___: I fixed the code, and pasted the error at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2016#a2017
14:36:20 <___> _dls: either add the extension the message tells you to or change "instance StringSwitch String" to "instance StringSwitch [Char]"
14:36:52 <SirLancer> Hey I was thinking of making a quiz-sort-of-thing with Haskell. I'd have the questions and answers in a text file, so does anyone have a source code I could "borrow" to read a specific line from a file?
14:37:04 <ddarius> ___: The latter also requires an extension.
14:37:18 <ddarius> :t getLine
14:37:20 <lambdabot> IO String
14:37:58 <ddarius> Unless it's huge, just read in all the lines and index into some structure.
14:38:16 <SirLancer> good idea!
14:38:29 <SirLancer> Like a list
14:38:47 <MonadKadaver> Parsec.letter means any letter as in 'abc..z' right?
14:38:50 <wli> I'm hitting something that's too big for that and polluted with a whole bunch of garbage.)
14:39:23 <MonadKadaver> not nums?
14:39:50 <ddarius> I wasn't talking to you, wli.
14:40:12 <TSC> monochrom: "Parses a letter (an upper case or lower case character). Returns the parsed character."
14:40:17 <wli> Is there a moderately complete word listing not polluted with huge numbers of abbreviations, single letters by themselves, etc.?
14:40:23 <TSC> (from http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Char.html#v%3Aletter)
14:40:36 <lament> there aren't very many single letters by themselves
14:41:05 <wli> It's just one example of crud that shouldn't be there.
14:41:40 <TSC> (of course my above message is to MonadKadaver, not monochrom)
14:41:50 <wli> (single letters by themselves make the algorithm's running time explode)
14:43:42 <marcot> Is there a good way to get f :: (a -> b -> m c) -> m a -> m b -> m c?
14:44:19 <marcot> I'd use <$> <*> if the function was (a -> b -> c).  I thought about using it with join, but it's so pretty.
14:44:21 <SirLancer> I get "configure: error: C compiler cannot create executables" when trying to configure ghc
14:44:24 <monochrom> IIRC it's liftM2
14:44:42 <dolio> join . liftM2 with some extra dots.
14:45:07 <vixey> :t liftM3
14:45:08 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:45:14 <kadaver> so how do I say each part of the stirng must succees parsing
14:45:19 <vixey> :t ((join .) .) . liftM2
14:45:20 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:46:23 <kadaver> (P.many P.letter) parses "hello1", i dont want that
14:47:38 <marcot> Thanks.
14:47:57 <___> MonadKadaver: the doc tells me letter parses only alphabetics.  Perhaps you want many1 letter?
14:48:28 <MonadKadaver> i want it to fail if it doesnt parse the whoelstirng...
14:48:52 <___> then many is definitely what you don't want.
14:49:05 <___> follow it by eof
14:49:07 <MonadKadaver> *Anagram> let n = "hello1" in P.parse (P.many P.anyChar) n n
14:49:07 <MonadKadaver> Right "hello1"
14:49:09 <MonadKadaver> fail
14:49:22 <___> why anyChar?
14:50:04 <_dls> ___: okay, I tried added the X flags to get it to compile, and now am getting a runtime error to the same effect :-(  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2016#a2018
14:50:43 <SirLancer> Is it as easy to make a indexed table in Haskell as it is in Java?
14:51:00 <blackh> dls: Better if you say {-# LANGUAGE FlexibleInstances TypeSynonymInstances #-} in your source file and drop the -X optios
14:51:06 <blackh> _dls: ^
14:51:14 <Cale> SirLancer: I suspect it's easier. What exactly do you mean by "indexed table" though?
14:51:18 <SirLancer> Or does it have to be a list with tuplets or something
14:51:31 <MonadKadaver> > let n = "hello1" in P.parse (P.many P.letter) n n
14:51:31 <MonadKadaver> is what i use
14:51:31 <MonadKadaver> *Anagram> let n = "hello1" in P.parse (P.many P.letter) n n
14:51:31 <MonadKadaver> Right "hello"
14:51:31 <MonadKadaver> i want fail isntead
14:51:32 <lambdabot>       Failed to load interface for `P':
14:51:33 <lambdabot>        Use -v to see a list of the fi...
14:51:37 <Cale> SirLancer: I would usually use a Data.Map, if I'm thinking the same thing that you're thinking.
14:51:38 <blackh> SirLancer: Does Data.Map do the trick? That's equivalent to java.util.Hashtable
14:51:50 <SirLancer> hmm
14:51:50 <blackh> SirLancer: ...except that it's a map not a hash table. :)_
14:52:05 <SirLancer> Data.Map, eh...
14:52:17 <Cale> Data.Map is more scalable than a hashtable would be anyway :)
14:52:27 <ddarius> For this you could use IntMap.  Though, for this you could probably get away with just using lists.
14:52:29 <kynky> lovely buckets
14:52:36 <cads> can you guys refer me to a guide on defining polymorphic types through type classes and deriving functions?
14:52:41 <_dls> blackh:  thanks, will do from now on :)
14:52:47 <travisbrady> anyone know of any examples of sorting really big files/lists of records using Haskell?
14:52:50 <TSC> MonadKadaver: Add "eof" to the end
14:53:03 <ddarius> travisbrady: There's an external sort on Hackage, I believe.
14:53:14 <Cale> travisbrady: By "really big" do you mean "doesn't fit in memory"
14:53:15 <kynky> quicksort
14:53:22 <travisbrady> Cale: yes
14:53:24 <TSC> MonadKadaver: You need to specify that after you've matched some letters, you want to match "end of input"
14:54:05 <Cale> travisbrady: I suspect it's nearly as awkward as in any other language, though if someone's already written one as ddarius mentioned, then perhaps your problem has already been solved :)
14:54:09 <monochrom> cads: I learn that from "A Gentle Introduction to Haskell"
14:54:21 <kynky> quicksort is fast for sorting randomly sorted lists
14:54:32 <Cale> Mergesort would probably be better here.
14:54:56 <cads> thanks monochrom
14:55:07 <kynky> lovely encapsulation
14:55:12 <travisbrady> requires Edison which I'm not familiar with
14:55:16 <Cale> Break the list to be sorted into many small files, sort each of those in memory, and then start merging them.
14:55:24 <MonadKadaver> P.many P.letter >> P.eof
14:55:27 <kynky> reducemap
14:55:56 <monochrom> See Knuth's book first volume
14:56:01 <Cale> So you just need to write a streaming-I/O merge.
14:56:10 <ddarius> @google k-funnel sort
14:56:12 <lambdabot> http://theory.csail.mit.edu/classes/6.895/fall03/projects/final/youn.ppt
14:56:13 <SirLancer> I was trying to install ghc the hard way, when all I needed was ghc6 from Synaptics...
14:56:42 * wli is seeing slowness even with outputting MultiSet (MultiSet Char)
14:56:47 <Cale> SirLancer: Never try to compile ghc yourself unless you're working on it :)
14:57:01 <ray> avoid it even then?
14:57:04 <Cale> SirLancer: The generic linux binary also should work.
14:57:26 <cads> lancer, depending on your repos, lots of times that'll get you an old ghc
14:57:27 <Cale> ray: Well, if you can ;)
14:57:42 <ray> there should be a designated compiler of the month
14:57:46 <SirLancer> cads: I'm fine with an old ghc
14:58:06 <SirLancer> Besides this can't be too old if it's version 6
14:58:14 <Cale> SirLancer: It's okay if you're learning, but a lot of the stuff on Hackage will require 6.10
14:58:26 <Cale> (as opposed to 6.6 or 6.8)
14:58:46 <kynky> Cale, have little choice in gentoo :)
14:58:47 <cads> I ran into that last night
14:58:57 <SirLancer> Hacka... what?
14:59:00 <Cale> The version goes up by 0.2 about once a year.
14:59:08 <Cale> Or is it twice?
14:59:16 <cads> kynky: is installing gentoo just for the haskell package worth it ? :d
14:59:18 <cads> :D*
14:59:21 <wli> 6.8.3 seems to be good for much of hackage.
14:59:22 <SirLancer> It goes 0.1 twice
14:59:29 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
14:59:29 <ray> seems like once to me
14:59:56 <Cale> ^^ hackage
15:00:11 <kynky> no but emerging haskell in gentoo is worth it :)
15:00:28 <Cale> kynky: Not if you have to compile it yourself.
15:00:32 <SirLancer> what's in ghc6-prof?
15:00:40 <Cale> SirLancer: profiling libraries
15:00:52 <SirLancer> Cale: like wha?
15:00:54 <Cale> SirLancer: For measuring the performance of code precisely
15:01:00 <kynky> Cale, you pretty much compile everything from source in gentoo
15:01:18 <Cale> kynky: Which is a tremendous waste of time and energy, which is why I don't use gentoo.
15:01:38 * pumpkin steps away from DistroWars
15:01:43 <kynky> hehe
15:01:45 <Cale> SirLancer: GHC has a profiler, which you can use to see various useful statistics about the performance of your code.
15:01:55 <SirLancer> aa
15:02:04 <SirLancer> doubt I'll be using that though
15:02:12 <ray> i always thought that was for profiling ghc
15:02:40 <Cale> SirLancer: for example, things like how many times a function gets called, how much time and allocation it takes, how much memory is being used for various things at various points in the program's execution, and so on.
15:03:31 <Cale> It's also handy for tracking down some kinds of bugs, like infinite loops. :)
15:04:05 <jeffwheeler> @type fmap
15:04:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:04:25 <jeffwheeler> Oh, wow; I'm _way_ behind, back on the fmap of tuples thing.
15:05:03 <___> @src (,) fmap
15:05:03 <lambdabot> fmap f (x,y) = (x, f y)
15:05:12 <pumpkin> lame :)
15:05:22 <Cale> How is that lame?
15:05:30 <Cale> It's the only thing it possibly could be :)
15:05:38 <lament> it could be (f x, y)...
15:05:42 <pumpkin> I brought up something earlier, not sure how ridiculous it was
15:05:47 <Cale> lament: Not in Haskell. :)
15:05:49 <EvilTerran> lament, not with the right types
15:05:50 <pumpkin> of wrapping tuples with a type like First and Second
15:05:56 <pumpkin> like Sum and Product Monoid instances on Int
15:06:01 <jeffwheeler> > fmap (+1) (1, 2, 3)
15:06:02 <lambdabot>       No instance for (Functor ((,,) t t1))
15:06:02 <lambdabot>        arising from a use of `fma...
15:06:11 <___> Cale: couldn't you fudge it with a Flip type?
15:06:15 <pumpkin> where First a b = (a, b) and Second a b = (b, a)
15:06:21 <pumpkin> and making both of those into Functor
15:06:24 <MonadKadaver> we need a killer app forlinux written in ahskell
15:06:27 <Cale> ___: you could, with a newtype
15:06:27 <MonadKadaver> is there some tool any of you need or some generally used tool that suck?
15:06:43 <jeffwheeler> MonadKadaver: feed-reader.
15:07:03 <jeffwheeler> MonadKadaver: I very much want a beautiful Haskell one, but I haven't gotten to implementing it well yet.
15:07:33 * EvilTerran notes a newtype Flip f x y = Flip { getFlip :: f y x } would let you write a Functor instance equivalent to the one for pumpkin's Second
15:07:41 <jeffwheeler> MonadKadaver: NetNewsWire on OS X is perfect, and Liferea (I pronounce it like diarrhea) for Linux crashes twice per minute
15:07:50 <pumpkin> Cale: I'd just argue that just like we don't have Monoid for raw Num, it doesn't make sense to have a Functor on a raw pair, without specifying which part you're working with
15:08:15 <Cale> pumpkin: I don't mind the bias in this case.
15:08:31 <jeffwheeler> Isn't it arbitrary, though?
15:08:33 <Cale> pumpkin: You just have to be careful when using pairs that the *second* element is the main one.
15:08:40 <Cale> and the first element is the "tag"
15:08:58 <ddarius> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d; instance Bifunctor (,) where bimap = (***)
15:09:10 <___> @unmtl State s a
15:09:11 <lambdabot> s -> (a, s)
15:09:15 <___> ^ how unfortunate
15:09:26 <___> @unmtl Writer w a
15:09:27 <lambdabot> (a, w)
15:09:38 <ddarius> Just start writing (a,b) as Σ_:a.b
15:09:53 <pumpkin> Cale: yeah, it just seems unfortunate to make a bias like that... I mean, we could do the same and say Monoid Int = Sum, and if you want Product, do it yourself
15:09:56 <dolio> > (id *** id) undefined
15:09:58 <lambdabot>   (* Exception: Prelude.undefined
15:11:02 <Cale> pumpkin: In the case of pairs, the two spots are otherwise equivalent, which means we might as well just pick one.
15:11:14 <wli> It just finished generating anagrams in the form MultiSet (MultiSet Char) for "Simon Peyton Jones" and the results are enormous, like > 1MB.
15:11:15 <ddarius> pumpkin: Again, there's only one that is doable in Haskell.
15:11:18 <Cale> pumpkin: Whereas with multiplication and addition, it's not so easy just to swap them
15:11:27 <ddarius> log/exp
15:11:33 <EvilTerran> pumpkin, i think the thing is that "Functor ((,) e)" is the only one that's natural to write in haskell
15:11:33 <pumpkin> ddarius: I know, I'm arguing against doing either without wrappers
15:11:46 <EvilTerran> while either instance Monoid Int would be natural to write
15:11:51 <ddarius> pumpkin: That's a big difference from the Monoid case though.
15:12:11 <Cale> I like the writer instance for (w,a)
15:12:27 <pumpkin> well in the Monoid case, someone decided it would be silly to force a particular monoid onto numeric types, so didn't do either
15:12:33 <pumpkin> and wrapped them both
15:12:47 <pumpkin> in the pair case, one of the cases was easy, so we got that one
15:12:50 <EvilTerran> pumpkin, the two (pseudo-)possible instances of Functor for (,) are isomorphic anyway, so it's not like it matters much :P
15:12:55 <ddarius> pumpkin: That's because -both- were possible and natural.  For pairs and functors, only one is possible even if both are natural.
15:13:38 <ddarius> pumpkin: The other case isn't "hard," it's impossible.  You have to use a different type if you want the effect of fmap acting on the first component of the pair.
15:15:41 <pumpkin> I realize that
15:23:00 <MonadKadaver> jeffwheeler: RSS-feeds?
15:24:40 <MonadKadaver> S.Set String, size 109 elements. List String, size 720 elements. looking up 720 elems in a 1809elem set should be quick right?
15:24:56 <MonadKadaver> 109 elem that is
15:25:13 <jeffwheeler> MonadKadaver: exactly.
15:25:40 <jeffwheeler> MonadKadaver: If I remember correctly, the feed package (from Galaois, I think) is flat-on hot
15:26:15 <MonadKadaver> flat-on hot?
15:26:33 <jeffwheeler> MonadKadaver: beautiful, hehe :)
15:29:01 <BONUS> hmm. i think Monad.Writer.pass could be implemented in terms of listen, tell and return
15:29:25 <MonadKadaver> and you eman build a GUI on top of that or what+
15:30:15 <jeffwheeler> MonadKadaver: yeah, that with Gtk2Hs and/or Vty would be nice
15:36:01 <comex> dumb question: is there any syntax (like {'a': 'b'...} from other languages) to make a hash table?
15:36:32 <vixey> what's dumb about that?
15:36:36 <___> > Data.Map.fromList [(1, 'a'), (2, 'b')]
15:36:36 <lambdabot>   /tmp/8660393805440406152:70:40: Not in scope: `Data.Map.fromList'
15:36:45 <MonadKadaver> iqMap = Map.fromList [("comex", 120),("kadaver",200)]
15:37:21 <MonadKadaver> Vty?
15:37:45 <pumpkin> comex: hashtables aren't very popular in haskell
15:37:45 <MonadKadaver> hmm maybe ill throw soemthing together in gtk
15:38:08 <pumpkin> comex: but there isn't dedicated syntax for creating maps/associative arrays
15:38:30 <comex> thanks
15:38:30 <MonadKadaver> problem with Anagrams of names is...veyr few of them are anagrams fo each other
15:39:21 <MonadKadaver> i need lastname to mix things up then prune the search somehow
15:45:44 <travisbrady> anyone have any thoughts on what the motivation for CHP is and what sorts of problems it would solve?
15:45:58 <pumpkin> CHP?
15:46:56 <monochrom> Chinese Haskell Programs? Yeah, in ten years everyone will have to use Chinese!
15:47:34 <travisbrady> oh sorry, Communicating Haskell Processes
15:47:47 <pumpkin> is that something like MPI?
15:47:50 <travisbrady> http://blogs.kent.ac.uk/crg-group/2009/03/chp-120-now-with-clocks/
15:47:58 <MonadKadaver> dont worry imwo working on a trnaslation progrma in haskell
15:49:41 <monochrom> I only know "communicating sequential processes" from Hoare. I guess CHP is similar.
15:52:41 <monochrom> Here is how the very barebone "communicating sequential processes" looks like. You can use these constructs: read (and wait for) message and bind to a variable (not mutable), write message, recurse.
15:53:50 <monochrom> You write several recursive things using those, and then at the outermost you say "let them all run in parallel".
15:54:52 <monochrom> There is likely also a "wait for and read a very specific message" or "wait for and read a message satisfying a specific criterion".
15:55:30 <jeffersonheard> the RealWorld, annoyed by the slander, tried to remove a Haskell programmer from itself today
15:55:31 <lambdabot> jeffersonheard: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:42 <EvilTerran> monochrom, the parallel's not necessarily at the outside
15:55:52 <EvilTerran> i believe
15:56:18 * EvilTerran looks at Control.Concurrent.CHP.Parallel.(<||>) :: CHP a -> CHP b -> CHP (a, b)
15:56:43 <jeffersonheard> someone ran into me on my bike on the way home.  totally wrecked, but I'm not
15:56:48 <monochrom> Then that's what CHP does but not what CSP does.
15:56:52 <jeffersonheard> and vixey: What's odd about the Diff type?
15:57:19 <EvilTerran> monochrom, i mean, there's a CSP equivalent, too
15:57:38 <monochrom> I know because my supervisor always say "everyone else except me force the <||> to be outermost, that's stupid", and I recall checking that he's right about everyone else.
15:59:14 <Saizan> so they have an n-ary parallel operator?
15:59:53 <monochrom> They have a binary associative commutative parallel operator, strictly speaking.
16:01:39 <mstr> how do I divide integer and get an integer?
16:01:41 <monochrom> If you write axioms, the binary version is easier to write for. Otherwise it doesn't matter.
16:02:09 <monochrom> > 50 `div` 17
16:02:10 <lambdabot>   2
16:02:21 <mstr> ah `div` not /
16:02:32 <monochrom> There is also quot
16:03:10 <poucet> ]
16:03:11 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
16:03:12 <poucet> ;;;;;;;;;;;;;;;;;;;;;;
16:06:41 <facedownW> *grabs hold of shield*
16:06:50 <facedownW> what practical applications make use of haskell?
16:06:56 <facedownW> *blocks*
16:07:04 <jeffwheeler> facedownW: Yi!
16:07:24 <facedownW> if I were to say, inform someone of what Haskell is used for as opposed to other mainstream languages
16:07:28 <facedownW> what can I say
16:07:37 <Saizan> darcs, ghc, xmonad, himerge,
16:07:50 <jre2> readFile "~/.vimrc" reports no such file/directory. Is there different (required) way of getting a path relative to the user's home directory?
16:07:51 <Saizan> "yi" was the name of a program, there :)
16:07:55 <facedownW> so it's used more for applications and not web apps
16:07:57 <facedownW> right
16:08:19 <Saizan> there's a facebook webapp written with happstack
16:08:33 <jeffwheeler> And Happstack is surprisingly clever in places.
16:08:41 <facedownW> so like.. web servers, text editors, dcvs
16:08:43 <facedownW> heh
16:08:45 <monochrom> More web apps will appear.
16:08:48 <facedownW> uhm
16:08:52 <facedownW> ive never heard of darcs
16:08:56 <facedownW> always git / hg
16:08:59 <jre2> source control
16:09:02 <Shimei> Does anybody know if any other languages, obscure or not, use type classes like they are implemented in Haskell? Doing a bit of research about them. (I read that SML can emulate them with its module system, but that's the closest I've found so far)
16:09:06 <facedownW> for dcvs recommendations
16:09:14 <kadaver> Parsec isnt used to parse haskell right? I mean in ghc
16:09:17 <facedownW> ok so basically, not much web apps now?
16:09:19 <monochrom> More web apps will appear because we have just recently got the frameworks going such as happstack.
16:09:19 <facedownW> its not practical
16:09:23 <facedownW> i mean sure it *can* be used for them
16:09:27 <facedownW> but its not popular by far
16:09:28 <Saizan> Shimei: Clean, i hear
16:10:03 <monochrom> Isabelle is a theorem prover using typeclass.
16:10:11 <Saizan> it's not popular by far in a lot of things, i guess?
16:10:11 <jre2> facedownW: popular: not yet, practical: very much so
16:10:20 <travisbrady> facedownW: it's not popular in the way that python/ruby/php are, but i've done it and it's easy
16:10:24 <kadaver> facedownW: i made my own webserver in 50 LOC
16:10:33 <ray> haskell is as practical as it is delicious
16:10:37 <conal> do strict fields work with GADTs?  if so, what's the syntax for the strictness annotations?
16:10:51 <facedownW> heh
16:11:01 <Saizan> but yeah, haskell webframeworks surely are not as mature as in other langs
16:11:02 <monochrom> You can try !a, if it works.
16:11:08 <facedownW> travisbrady: did you use a framework
16:11:47 <travisbrady> facedownW: no, i just used the FastCGI bindings, i use Django and Pylons at work and wanted to try something simpler
16:12:00 <facedownW> oh
16:12:09 <facedownW> so are most frameworks for haskell relient upon fastcgi?
16:12:13 <travisbrady> facedownW: but you can give Turbinado, or HAppstack a try.  or roll your own with Hyena, UrlDisp and HStringTemplate
16:12:17 <facedownW> cgi is where you access the file directly, right?
16:12:21 <travisbrady> facedownW: i don't think any of them are
16:12:37 <facedownW> or is it completely different
16:12:44 <facedownW> i'm using django atm w/ mod wsgi
16:12:46 <jeffwheeler> Most seem to provide their own server, although I suspect all are available as CGI or similar.
16:13:55 <facedownW> can you reiterate again, what the diff between CGI and non CGI is
16:14:19 <facedownW> CGI is basically what, the opposite of how django works?
16:14:41 <jeffwheeler> Django can run under (fast)cgi, can't it?
16:14:45 <facedownW> sure
16:14:50 <travisbrady> facedownW: it's not the opposite no, CGI is where a web server, say apache sort of rewrites requests to another protocol called CGI, you get all the same vars and such
16:14:51 <facedownW> but its preferred to use mod wsgi or a python handler
16:14:58 <facedownW> hm
16:15:17 <travisbrady> but these days it's more common for frameworks to run their own mini web server that speaks normal http
16:15:25 <vixey> jefferson; the |
16:15:41 <facedownW> So.. in a way frameworks sort of have their own implementation of a CGI
16:15:41 <travisbrady> both methods are available with Turbinado and Happstack I believe
16:15:47 <Shimei> Saizan: Ah yeah, it appears Clean does have type classes. Their feature page lists it. Apparently F# also uses type classes. Interesting.
16:15:47 <facedownW> like Django?
16:15:52 <facedownW> ( Not using FastCGI )
16:16:14 <travisbrady> facedownW: i think you're missing the point here, the goal is for you process, say "hello.py" to communicate with Apache or whatevr
16:16:25 <facedownW> Ok
16:16:44 <Shimei> Nevermind, F# doesn't seem to have type classes. It's just a requested feature.
16:16:52 <travisbrady> you need some standard way of getting and receiving messages, a common way is for you program to understand HTTP, but another way is CGI
16:17:13 <facedownW> Ah
16:17:17 <facedownW> Kinda makes sense now
16:17:37 <kadaver> is there bindings for apache for haskell?
16:17:41 <travisbrady> facedownW: but for what you'd be doing you can assume the stuff we're talking about is behind the scenes in the same way it is now for you with Django, as i assume you're not parsing raw html
16:17:44 <travisbrady> raw http rather
16:18:01 <facedownW> yeah .. behind the scenes and more smartly programmed or whatever
16:18:56 <travisbrady> you'd basically get a request type object ala Django and you can pull stuff out of it, use params to grab stuff from your db and then you'd return a similar-ish Response object kinda sorta though Haskell doesn't have objects in the same sense
16:19:48 <jeffersonheard> vixey: oh.  that should be a data decl not a type decl
16:19:53 <jeffersonheard> will fix.  it's correct in the code
16:20:01 <jeffersonheard> just not in the post
16:21:03 <jeffersonheard> fixed
16:21:12 <travisbrady> facedownW: here's a very simple Haskell web app I wrote just to experiment that uses the FastCGI bindings, http://github.com/travisbrady/sayit/blob/123fac4b57d2ccd1eb64c431626da54b4e4b7421/Main.hs
16:21:17 <kadaver> No instance for (Text.Parsec.Prim.Stream s m Char)
16:21:17 <kadaver> bah!
16:21:26 <kadaver> what type should it have?
16:21:32 <travisbrady> facedownW: you can see it running here http://70.87.222.160:3001/sayit
16:21:42 <monochrom> Text.Parsec.Prim.Stream [Char] m Char
16:21:43 <facedownW> interesting
16:21:55 <monochrom> But it ought to be inferred just fine.
16:22:05 <facedownW> thanks travisbrady for that, bookmarked and ill study this in later detail as i learn more haskell
16:22:18 <monochrom> Perhaps even that is wrong.
16:22:42 <monochrom> Bah, insufficient information for a meaningful answer.
16:24:38 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3154#a3154
16:26:55 <kadaver> monochrom ^^
16:27:56 <monochrom> parseWord :: P.Parser Char
16:29:34 <kadaver> and to return (String, String)?
16:30:08 <monochrom> parseWord :: P.GenParser Char st Char   if you prefer
16:30:30 <pumpkin> @hoogle fixIO
16:30:30 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
16:30:32 <monochrom> parseWord :: P.GenParser Char st (String,String)
16:30:33 <pumpkin> :o
16:30:46 <pumpkin> how does that differ from mfix, and what are real use cases for it?
16:31:16 <kadaver> and if i want to return (String,String) from it?
16:31:28 <monochrom> parseWord :: P.CharParser st (String,String)   is another equivalent form.
16:31:48 <monochrom> I'm exactly answering that.
16:35:41 <pumpkin> what's going on with PArrows?
16:35:49 <pumpkin> no maintainer, site link is broken
16:37:00 <ultrakrankerhamp> @src ($)
16:37:01 <lambdabot> f $ x = f x
16:37:23 <ultrakrankerhamp> :t ($)
16:37:25 <lambdabot> forall a b. (a -> b) -> a -> b
16:44:43 <MyCatVerbs> @hoogle Rational -> Double
16:44:44 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
16:44:44 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
16:44:44 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
16:45:47 <kadaver> requestParser :: Text.Parsec.Prim.ParsecT P.SourceName
16:45:47 <kadaver>                    u mtl-1.1.0.2:Control.Monad.Identity.Identity
16:45:47 <kadaver>                    (String, [Char])
16:46:05 <kadaver> could parsec types be a little simplerperhaps?
16:47:24 <kadaver> the types even gives a parse error
16:47:45 <kadaver> ok same type as before worked
16:48:59 <pumpkin> ?
16:49:04 <kadaver> nada
16:49:06 <Cale> That package name annotation I don't think is actually valid syntax.
16:49:14 <kadaver> pumpkin: where are you from?
16:49:16 <Cale> (the "mtl-1.1.0.2:" bit)
16:49:22 <kadaver> Cale: it wasnt
16:49:35 <pumpkin> kadaver: tough question :P I go to school in the US :)
16:49:43 <kadaver> but it was what ghci spitted out when asked for :t
16:53:00 <Philippa_> kadaver: Parsec - especially version 3 - could definitely be simpler. It's a tradeoff against power
16:57:10 <Botje> tits
16:59:10 <dolio> @yow!
16:59:10 <lambdabot> CHUBBY CHECKER just had a CHICKEN SANDWICH in downtown DULUTH!
16:59:33 <pumpkin> what's with the @yow ?
17:00:12 <dolio> It's awesome?
17:00:19 <pumpkin> aha
17:05:36 <kadaver> woot i made a english->esperanto translator webapp in haskell in 1 hour
17:05:36 <kadaver> to bad google appengine doesnt work with haskell
17:06:23 <Nafai> kadaver: What framework?
17:09:38 <kadaver> my own hack
17:10:17 <McManiaC> data CurlResponse_ headerTy bodyTy
17:10:24 <McManiaC> what is headerTy standing for???
17:10:45 <McManiaC>     response <- perform_with_response curl
17:10:53 <McManiaC> is this wrong? :)
17:11:38 <kadaver> where is toLower again?
17:11:49 <conal> Data.Char, i think
17:11:55 <conal> @type Data.Char.toLower
17:11:56 <lambdabot> Char -> Char
17:11:59 <kadaver> Philippa: I find it very simple to use, awesome indeed. jsut the types are a bit weirdo and hard to memorize
17:14:59 <MyCatVerbs> @hoogle Array i e -> [(i,e)]
17:14:59 <lambdabot> Data.Array.Base assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
17:14:59 <lambdabot> Data.Array.IArray assocs :: (IArray a e, Ix i) => a i e -> [(i, e)]
17:14:59 <lambdabot> Data.Array.Base getAssocs :: (MArray a e m, Ix i) => a i e -> m [(i, e)]
17:15:43 * wli was hoping to get a hold of the same dictionaries as others are using for anagram generation.
17:16:13 <MyCatVerbs> wli: /usr/share/dict/words?
17:16:31 <wli> wordnet doesn't seem to have that.
17:17:19 * jeffersonheard hates wordnet
17:18:44 <ddarius> @wn wordnet
17:18:47 <lambdabot> *** "wordnet" wn "WordNet (r) 2.0"
17:18:47 <lambdabot> wordnet
17:18:47 <lambdabot>      n 1: any of the machine-readable lexical databases modeled after
17:18:47 <lambdabot>           the Princeton WordNet
17:18:47 <lambdabot>      2: a machine-readable lexical database organized by meanings;
17:18:49 <lambdabot>         developed at Princeton University [syn: {Princeton WordNet}]
17:19:08 <BMeph> @type (.).(f?)
17:19:09 <lambdabot> Not in scope: `?'
17:19:16 <BMeph> @type (.).(?f)
17:19:17 <lambdabot> forall b c a a1. (?f::a1 -> b -> c) => a1 -> (a -> b) -> a -> c
17:19:59 <McManiaC> cant u use patternmatching for like: (a,b) <- f... where f :: ..-> IO (a,b) ?
17:20:23 <BMeph> McManiaC: Can't U? ;)
17:20:55 <McManiaC> german-englisch :S sorry
17:21:27 <McManiaC> "is there a way to..." or "is it possible? or am i just doing it wrong?" ^^
17:21:36 <Cale> McManiaC: you can
17:22:02 <BMeph> McManiaC: Man kann! ;)
17:22:14 <McManiaC> :D
17:22:23 <McManiaC> damn
17:22:26 <McManiaC> so im doing it wrong =(
17:23:03 * BMeph resists the impulse to give in to the Meme. Resist, resist, resist...
17:25:58 <byorgey> McManiaC: if you're getting an error message you can't figure out, you could paste the code and error message somewhere
17:26:01 <byorgey> @where hpaste
17:26:02 <lambdabot> http://hpaste.org/
17:26:11 <BMeph> mmorrow: ping
17:26:39 * wli tries web1913
17:27:17 <McManiaC> byorgey: thx :) i think i figured it out tho... its late, i should probably go to bed
17:27:20 <McManiaC> :)
17:27:45 <byorgey> =)
17:31:05 <kadaver> wli: i didnt find such a site but i used http://www.thinkbabynames.com/popular/0/United+States
17:31:10 <kadaver> to get some names
17:31:30 <kadaver> anyoen know where to get a english-spanish dictionary?
17:32:32 <travisbrady> kadaver: http://espanolify.com/#___1__
17:35:49 <kadaver> but  i want the dictionary
17:35:49 <kadaver> not the service
17:36:38 <BMeph> kadaver: I use Google. ;p
17:36:42 * BMeph ducks
17:39:05 <kadaver> have you seen the family guy episode when Stewie beats the shit out of briran over a debt and Stewie is scared to death for Brian's revenge because he doesn't knw hwen it is going to happen and he even aska Brian to end the misery and punish him? That's what you have in front of you...
17:39:49 <byorgey> kadaver: have you tried googling 'spanish-english dictionary'?
17:40:16 <lament> kadaver: ...in a book store
17:40:25 <kadaver> yes ofc
17:40:25 <kadaver> only gives translators not downloadable datasets
17:40:43 <kadaver> i found one for esperanto where it is just a huge textfile
17:40:52 <kadaver> thats what i want
17:41:10 <lament> you want word-to-word correspondence? sounds pretty useless.
17:41:33 <kadaver> also, lets say you want to make an executable and obv you dont want to reparse the whole datasets everytime you start the app, what is the best way to store the data if I dont want to use a database?
17:41:36 <kadaver> serialize it?
17:44:09 <BMeph> kadaver: I use Google. ;p
17:46:14 * kadaver picks out an old rusty scissor, dips it in acid and carefully wraps it in plastic and starts swimming towards USA
17:48:17 <kadaver> http://lmgtfy.com/?q=spanish+english+dictionary
17:48:20 <byorgey> kadaver: do you mean you want to store the data as part of the executable? or do you mean it requires some expensive processing to build some data structure, and once you have that data structure you'd like to be able to load it up quickly?
17:48:42 <byorgey> if the latter, try using Data.Binary to serialize the data structure to disk, then read it back in on startup
17:49:02 <p_l> kadaver: I suggest that what you just described is building a database, just not necessary using a RDBMS :>
17:49:23 <p_l> you could use a mmap() wrapper
17:51:00 <kadaver> mmap?
17:52:17 <kadaver> i got an overflow when i tried to deserialize a reasonably big datasets the last time(part of the netflix dataset)
17:56:07 <wli> I've not noticed the data sets being quite that bad yet.
17:56:21 <wli> OTOH I just started using some bigger ones, so...
17:57:04 <kadaver> wli: you on chalmers?
17:57:15 <wli> Yeah, I think it's turned into a problem.
17:57:21 <kadaver> William Lee Irwin III, really?
17:57:31 <wli> kadaver: No, I'm using some dictionaries for anagrams.
17:57:35 <kadaver> wli: what has? being on chamers?
17:57:42 <wli> kadaver: Yes. Have you heard of me or something?
17:58:06 <wli> kadaver: No. I never said anything about chalmers. The size of the dictionaries has become a problem.
17:58:21 <kadaver> you hack the linux kernel?
17:58:21 <kadaver> maybe i ran into you hear before
17:58:21 <kadaver> jvla gteborgare
17:58:21 <kadaver> oh i see
17:58:40 <wli> kadaver: Yes. I work on Linux.
17:58:50 <kadaver> kernel?
17:58:57 <wli> Yes.
17:59:03 <kadaver> paid?
17:59:15 <wli> Yes.
17:59:33 <kadaver> how did you get into it?
18:00:49 * wli sees if Data.Binary works with 6.8.3
18:00:53 <wli> It does.
18:02:33 <gwern> the linux kernel? real programmers hack the gibson
18:04:04 <kadaver> there has only lived one real programmer, Dijkstra. Only coded on paper and proofed hs programs. A real man-
18:04:06 <chessguy> > sum [1.5, 2]
18:04:07 <lambdabot>   3.5
18:04:48 <kadaver> map murder murdocks
18:05:01 <chessguy> > sum [1.5, 2, 3, 5.9]
18:05:03 <lambdabot>   12.4
18:05:28 <kadaver> > foldl (+) 0 [2.5,3]
18:05:29 <lambdabot>   5.5
18:05:34 <kadaver> > foldl (+) 0.0 [2.5,3]
18:05:36 <lambdabot>   5.5
18:05:40 <kadaver> > foldl (+) 0.0 [2.5,3::Int]
18:05:41 <lambdabot>       No instance for (Fractional Int)
18:05:41 <lambdabot>        arising from the literal `0.0' ...
18:05:48 <kadaver> > foldl (+) 0 [2.5,3::Int]
18:05:49 <lambdabot>       No instance for (Fractional Int)
18:05:50 <lambdabot>        arising from the literal `2.5' ...
18:06:32 <kadaver> > foldl sum [] [[1,2,3],[4,5,6]]
18:06:33 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> [a]
18:06:33 <lambdabot>      Pro...
18:06:49 <kadaver> > foldl (\x y -> x + sum y) [] [[1,2,3],[4,5,6]]
18:06:50 <lambdabot>       No instance for (Num [a])
18:06:50 <lambdabot>        arising from a use of `sum' at <intera...
18:07:06 <kadaver> > foldl (\x y -> x + sum y) 0 [[1,2,3],[4,5,6]]
18:07:07 <lambdabot>   21
18:07:15 <kadaver> > foldl (\x y -> x + sum y) 0 [[1,2,3],[4,5,6]]
18:07:17 <lambdabot>   21
18:07:27 <kadaver> > foldl (\x y -> x ++ [sum y]) [] [[1,2,3],[4,5,6]]
18:07:28 <lambdabot>   [6,15]
18:07:46 <kadaver> map sum [[1,2,3],[4,5,6]]
18:07:52 <kadaver> > map sum [[1,2,3],[4,5,6]]
18:07:53 <lambdabot>   [6,15]
18:08:26 <gwern> kadaver: actually, djikstra did program on actual computers
18:08:33 <gwern> it's just that he never *owned* one
18:08:49 <gwern> for example, for THE he and and his grad students did plenty of programmingon their minicomputer
18:10:08 <wli> Data.Binary is stack overflowing on me.
18:12:25 <kadaver> yes but he wrotw the code on paper first right sand proved it?
18:20:46 <wli> How do I get decodeFile via strict bytestrings?
18:21:39 <wli> Hmm. The bigger the dictionary the slower this all gets. :(
18:25:29 <cwyang> net
18:26:24 <jre2> is there a good library for creating an SSL connection? hsopenssl says that feature is incomplete
18:27:58 <codebliss> I'm trying to install leksah, a haskell ide written in haskell.  I've installed all of the base programs needed, but I'm getting 15+ dependencies missing.
18:28:06 <codebliss> Anybody have experience with leksah?
18:29:01 <codebliss> Should I take an hour and do them all manually?  =P
18:31:55 <MonadKadaver> haskell is truth!
18:32:10 <thoughtpolice> codebliss: you need to install gtk2hs
18:39:07 <mightybyte> What's the best way to generate 64 bits of randomness in haskell?
18:49:17 <p_l> mightybyte: Do you need to have it done in hHaskell or do you simply need 64bits of randomness?
18:49:38 <codebliss> Randomness and Haskell are basically mortal enemies.
18:50:02 <codebliss> Functional programming prides itself in returning the same output given the same arguments every time.
18:50:08 <p_l> mightybyte: if the second one, just read 8 bytes from /dev/urandom :D
18:55:54 <gwern> 'I started Leksah June 1997 and work on it in my
18:55:55 <gwern> spare time for fun.'
18:55:57 <gwern> wow
18:56:16 <gwern> that puts leksah in a pretty elite category, for longevity
18:56:42 <gwern> you have the haskell compilers, and... not much else which dates that far back and is still actively developed/used
18:58:17 <gwern> I mean, darcs didn't even come around till... 2001?
18:58:22 <mightybyte> p_l: I wanted to use haskell.  I think I'll just generate a list of hex digits.
18:58:26 <ksf> hell is freezing over. I just wrote my first "(fmap foo .) . bar"
18:59:14 <codebliss> I just installed gtk2hs and it didn't effect my leksah Setup.lhs configuration
18:59:17 <p_l> mightybyte: Well, welcome to reading on how to write a random number generator :)
18:59:41 <mightybyte> p_l: Heh
19:00:08 <ksf> :t (((fmap id .) .) .)
19:00:09 <lambdabot> forall a (f :: * -> *) a1 a2 a3. (Functor f) => (a3 -> a2 -> a1 -> f a) -> a3 -> a2 -> a1 -> f a
19:00:19 <ksf> That's just insane.
19:01:09 <hamishmack> codebliss: what OS are you installing on?
19:01:54 <codebliss> Ubuntu 8.10 64bit amd
19:02:26 * ksf just remembered that . is fmap on -> and feels one half of himself being intrigued, the other one fleeing in panic.
19:03:11 <ksf> In fact, it makes sense unless I try to understand it.
19:03:27 <hamishmack> Which packages is it complaining about?
19:03:56 <codebliss> base >=4.0.0, binary >=0.4.4, containers >=0.2.0.0, directory >=1.0.0.2, etc..
19:04:02 <codebliss> If you need more ill pastebin
19:04:34 <codebliss> I checked and I have base 3.0?
19:04:52 <ksf> leksah needs ghc 6.10 iirc
19:05:02 <codebliss> I just installed it days ago...hm
19:05:08 <ksf> ...base 3.0 is 6.8
19:05:12 <codebliss> kk
19:05:21 <codebliss> * base             (library)     Synopsis:      Basic libraries     Latest version available: 4.0.0.0     Latest version installed: 3.0.1.0
19:05:35 <codebliss> from cabal info base
19:05:38 <codebliss> I'll check site
19:05:49 <hamishmack> Ah you need ghc 6.10.1
19:06:09 <ksf> Well, I think cabal is smart enough not to pull base 4 if you don't have ghc 6.10.
19:06:26 <codebliss> Ah, I installed with apt.
19:06:37 <codebliss> I'll do manually up to 6.10
19:06:56 <mmorrow> BMeph: pong
19:06:56 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
19:07:16 <hamishmack> It is a good idea to build it from source if you can.  THat way you can point Leksah at the source tree.
19:07:49 <mmorrow> BMeph: lunabot privmsg works. (i think. it works for me.)
19:08:09 <mmorrow> could someone try to /msg lunabot ?
19:08:34 <mmorrow> (w/ a ", <somthing>")
19:08:35 <hamishmack> It will then be able to locate the function comments and put them in the auto-complete window
19:08:43 <BMeph> mmorrow: Is this a new development, because I know I've tried, and failed, to get a response in private on things.
19:08:57 <mmorrow> BMeph: weird, no it's always done /msg
19:09:12 <mmorrow> i have a lunabot /msg window open always
19:09:14 <ksf> doesn't seem to work, it doesn't reply.
19:09:21 <mmorrow> hmm, odd.
19:09:26 <inimino> not /query?
19:09:32 <codebliss> Where is ghc installed by default?  I'm still quite new to linux
19:09:35 <mmorrow> try "/msg , 42"
19:09:44 <mmorrow> (you need the ",")
19:09:59 <mmorrow> inimino: /query ?
19:10:16 <inimino> don't you need a username too?
19:10:18 <ksf> ah, there it is.
19:10:30 <mmorrow> inimino: heh, yeah that too :/
19:10:36 <hamishmack> Packaged version is probably in /usr
19:10:36 <BMeph> mmorrow: It's working now, so I'll quit bugging out about it and play now - thank you! :)
19:10:37 <mmorrow> ksf: ah, nice
19:10:42 <mmorrow> BMeph: :)
19:10:56 * ksf is missing something in pointless style and wth he needs to use (foo .)
19:11:09 <hamishmack> If you build from source I imagine it defaults to /usr/local
19:11:14 <codebliss> ran "ls /usr/bin/ | grep ghc" and it is indeed there.
19:11:17 <mmorrow> , [$pl| \a b c -> g (f a b c)|]
19:11:18 <codebliss> Thanks.  Linux is awesome =O
19:11:19 <lunabot>  ((g .) .) . f
19:11:33 <mmorrow> , [$bf|.+[.+]|] ""
19:11:35 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
19:11:36 <ksf> that is, I use pointfree quite often and didn't ever have to use it before.
19:11:38 <inimino> mmorrow: /query lunabot WFM
19:12:17 <mmorrow> inimino: i don't know what query looks like raw, but lunabot responds to /msg, so if it's the same thing it'll work
19:12:43 <mmorrow> (lunabot's bot shell is hackish to say the least)
19:13:19 <mmorrow> oh, WorksForMe ?
19:13:22 * BMeph needs to remember to look up info on BF at home, where the corporate filter won't flip out.
19:13:30 <mmorrow> BMeph: heh
19:13:33 <codebliss> "If you have neither, then you need to install editline. Try looking for a package called something like libedit2 or libedit. ".  I checked and I have libedit2.
19:13:57 <codebliss> Generic amd64 Linux for libedit2. If you have a file /usr/lib/libedit.so.2 (expected on Debian and derived distributions) then use this bindist. This is a complete build, including interactive system, profiling libraries and documentation.      * .tar.bz2 (70 MB) -- This what I should use even though I don't have that file?
19:14:19 <BMeph> Well, off to pick up groceries - see y'all in a few...
19:14:19 <inimino> mmorrow: ah, apparently it's just a convenience feature for the same thing
19:14:28 * BMeph salutes the channel
19:14:41 <mmorrow> inimino: ah, cool. (it took me a second to figure out what WFM meant :)
19:15:42 <mmorrow> codebliss: what linux distro do you have?
19:15:44 <hamishmack> codeblis: sudo apt-get build-dep ghc
19:16:16 <hamishmack> that will install all the dev packages needed to build ghc 6.8
19:16:32 <hamishmack> I imagine the same ones are needed for 6.10
19:16:39 <codebliss> E: Unable to find a source package for ghc
19:16:50 <codebliss> ubuntu 8.10 64bit amd
19:17:14 <mmorrow> codebliss: did you say you already have a ghc?
19:17:16 <mmorrow> ran "ls /usr/bin/ | grep ghc" and it is indeed there.
19:17:30 <codebliss> I have ghc 6.8 i thnk
19:17:34 <codebliss> since I installed with apt
19:17:37 <ksf> hmmm... I'm quite sure I used pointless on more than one argument, before, without (foo .).
19:17:40 <codebliss> but leksah requires 8.10
19:17:54 <mmorrow> ok, so you want to either get the bindist or build it.
19:17:58 <ksf> but I guess I'm mistaken.
19:18:25 <mmorrow> codebliss: what does "ls /usr/lib*/libedit.so.*" say?
19:18:56 <hamishmack> codebliss: sorry.. sudo apt-get build-dep ghc
19:19:00 <hamishmack> sudo apt-get build-dep ghc6
19:19:18 <ksf> is there a standard way to get around all these .) .) .) .) .) if things get extreme?
19:19:34 <hamishmack> The ghc package is just an alias
19:19:42 <mmorrow> getting a bindist might be the way to go if it's your first go-around
19:19:50 <mmorrow> haskell.org/ghc
19:20:28 <edwardk> does someone feel up to proofreading http://comonad.com/reader/2009/incremental-folds/ before it hits planet haskell?
19:20:39 <mmorrow> @pl \a b c d e -> g (f a b c d e)
19:20:39 <lambdabot> ((((g .) .) .) .) . f
19:20:52 <hamishmack> So you need to have do build-deps on the actual package "ghc6"
19:21:07 <codebliss> I can't find libedit anything in /usr/lib
19:22:02 <mmorrow> heh, the "rememberful" functor :)
19:22:08 <ksf> edwardk, i would, but i'd have to read up on incremental folds first.
19:22:12 <edwardk> =)
19:22:28 <codebliss> acceleration due to grav is -16
19:22:30 <codebliss> aksfekf
19:22:46 <codebliss> wrong paste lol.  /usr/lib64/libedit.so.2     /usr/lib/libedit.so.2 /usr/lib64/libedit.so.2.11  /usr/lib/libedit.so.2.11
19:23:01 <edwardk> ksf: the gist of the idea is to keep updating a fold as you add to a data structure
19:23:40 <edwardk> i just noticed that you can move the 'memory' into the fixed point operator
19:23:53 <sbahra> "*One* macro can turn Scheme into a lazily-evaluated language - my CS145 course had us do so"
19:23:53 <wli> YTF am I getting stack overflows trying to Data.Binary.decodeFile ?
19:24:03 <sbahra> Could this be true?
19:24:19 * sbahra is not familiar with scheme and the author of the comment isn't exactly reliable 
19:24:31 <edwardk> sbahra: yes and no. its probably a hell of a macro ;)
19:25:10 <sbahra> edwardk, I thought something along those lines :)
19:26:13 <dolio> They're probably thinking of delay/force.
19:26:21 <hamishmack> codebliss: So is configure working now?  It may have been missing the header files not the libs
19:26:37 <dolio> Which doesn't make the language lazily evaluated, but lets you add explicit laziness in a somewhat non-terrible fashion.
19:26:40 <ksf> laziness shouldn't be hard, but impurity is going to shoot you on every second invocation.
19:26:49 <codebliss> Hm?  Try leksah Setup.lhs again?
19:27:25 <hamishmack> No ghc configure
19:27:30 <edwardk> mmorrow: like?
19:28:09 <codebliss> sudo apt-get build-dep ghc Reading package lists... Done Building dependency tree        Reading state information... Done E: Unable to find a source package for ghc
19:28:13 <mmorrow> codebliss: i do. it looks interesting.
19:28:27 <hamishmack> no ghc6
19:28:30 <hamishmack> not ghc
19:28:39 <codebliss> 30mb.  trying
19:28:43 <mmorrow> that's sounds like it could be interesting... a stable ptr -> type via a typeclass somehow
19:29:04 <edwardk> mmorrow: and the best part is that it cleans up the stable pointer immediately
19:29:08 <dolio> Making the language lazily evaluated in general would, I can only imagine, involve rewriting the entire text of your program inserting delay/force calls, which is a big job for a macro.
19:29:37 <edwardk> mmorrow: i use it to make it so i can have a monoid over a regex, where the regex is a term that gets lifted into a type by 'reify' and reflected back down as needed inside the monoid
19:30:09 <edwardk> that'll probably be a part 2 of any sort of 'reflecting on ...' series
19:30:11 <mmorrow> cool
19:30:52 <codebliss> Gone.
19:30:54 <codebliss> *done
19:31:21 <codebliss> I tried leksah Setup.lhs and of course same error =)
19:31:22 <mmorrow> (just out of general curiosity), is it just personal preference you use "data Tree a r = Bin r a r | Tip" instead of "Tree a x = Tip a | Bin x x" ?
19:31:37 <edwardk> the other is non-empty only
19:31:45 <mmorrow> ahh
19:31:46 <mmorrow> true
19:31:58 <edwardk> i started with the other definition because it was cleaner ;)
19:31:58 <hamishmack> codebliss: wget http://www.haskell.org/ghc/dist/6.10.1/ghc-6.10.1-src.tar.bz2
19:32:09 <hamishmack> wget http://www.haskell.org/ghc/dist/6.10.1/ghc-6.10.1-src-extralibs.tar.bz2
19:32:31 <dolio> Tip a | Bin x x has no internal elements, either.
19:32:31 <edwardk> then i realized i couldn't make the clean one into a monoid, and then i cut the monoid instance from the post anyway, hrmmf.
19:32:35 <edwardk> yeah
19:32:36 <codebliss> Thanks mate.  wgotten
19:32:44 <hamishmack> tar xjf ghc-6.10.1-src.tar.bz2
19:32:45 <mmorrow> edwardk: yeah, i've always used that other one, but that's really nice that you get empty for free by shuffling where your val is
19:32:55 <codebliss> I thought it was xfc?  =P
19:33:02 <ksf> ./configure --prefix=/home/codebliss/ghc
19:33:02 <hamishmack> tar xjf ghc-6.10.1-src-extralibs.tar.bz2
19:33:04 <ksf> make
19:33:07 <ksf> make install
19:33:07 <mmorrow> dolio: ah, yeah
19:33:28 <ksf> export $PATH=$PATH:/home/codebliss/ghc/bin
19:33:32 <ksf> ...and then just go on.
19:34:49 <mmorrow> hmm, i bet something cool could be done with those two diff tree datatypes. they they seem like perfectly fitting puzzle pieces without a puzzle
19:37:28 <codebliss> libtool: install: warning: remember to run `libtool --finish /usr/local/lib' ../utils/mkdirhier/mkdirhier /home/brandon/ghc/lib/ghc-6.10.1 make[1]: ../utils/mkdirhier/mkdirhier: Command not found make[1]: *** [install] Error 127 make: *** [install] Error 1
19:37:29 <codebliss> oh god
19:37:41 <ksf> ...Choose rotting away at the end of it all, pishing your last on some miserable irc channel, nothing more than an embarrassment to the selfish, fucked up lusers ubuntu spawned to replace the lfs-literate
19:37:43 <ksf> SCNR
19:38:57 <codebliss> Hating on the fact I took an interest in linux and picked an OS that's highly developed with a good community?
19:39:16 <codebliss> If you want me to leave, express to me your opinion.
19:39:27 <codebliss> Yelling needlessly achieves nothing.
19:40:04 <ksf> no, it's the back-when-i-was-young-we-had-to-grind-grain-ourselves-if-we-wanted-to-eat - thing.
19:40:08 <ksf> nothing personal.
19:40:20 <codebliss> I'm a really hard worker.  Don't worry =)
19:40:33 <codebliss> I just am a bit relaxed since I got into linux.  Great community.  Help and get helped.
19:40:55 <codebliss> Life is just life, I can't go back and make life harder for myself.  I just take what I get and make the best of it.
19:41:46 <ksf> ...in fact, back when i first met people that actually used linux, they just gave me a half-way current lfs manual and told me to follow it.
19:42:14 <lament> ...to follow it in a snowstorm, 40 miles, uphill...
19:42:16 <codebliss> lfs?  Sorry.
19:42:18 <hamishmack> codebliss: sudo apt-get install xutils-dev
19:42:28 <ksf> ...not forgetting to mention that even if you do everything exactly as written, you're not going to have a workable linux the first run around.
19:42:34 <codebliss> At newest version
19:42:54 <codebliss> Hey, I followed the command-line-only-for-the-first-week plan and it really helped with bash =P
19:42:55 <ksf> it's kinda related to schroedingbugs.
19:43:09 <ksf> http://www.linuxfromscratch.org/
19:43:28 <codebliss> Cool beans, thanks =)
19:44:47 <ksf> btw, what i said was a paraphrase of http://www.adminspotting.org/index.html .
19:44:59 <lament> I had a similar experience, when I was just learning how to eat, I ate nothing but live rats for a week
19:49:51 <hamishmack> codebliss: did you re run configure after doing the apg-get build-dev ghc6?
19:50:27 <codebliss> Just did.  Same thing
19:51:16 <ksf> debugging init scripts is an invaluable experience.
19:51:24 <codebliss> Configuring leksah-0.4.3... Setup.lhs: At least the following dependencies are missing: base >=4.0.0.0, binary >=0.4.4, containers >=0.2.0.0, directory >=1.0.0.2, filepath >=1.1.0.1, ghc >=6.10.1, gtksourceview2 >=0.10.0, mtl >=1.1.0.2, old-time >=1.0.0.1, pretty >=1.0.1.0, process >=1.0.1.0, regex-posix ==0.72.0.3, utf8-string >=0.3.1.1
19:51:26 <codebliss> There ya go.
19:51:50 <ksf> what does ghc --version say?
19:52:30 <ksf> ghc-pkg list could also prove interesting.
19:52:38 <codebliss> The Glorious Glasgow Haskell Compilation System, version 6.8.2
19:52:40 <codebliss> le sigh.
19:52:43 <codebliss> lol
19:52:44 <codebliss> no wonder
19:52:47 <hamishmack> By configure I mean ./configure --prefix=/home/codebliss/ghc
19:53:04 <hamishmack> Not the Leksah configure
19:53:54 <ksf> ...and if you still have a system-wide ghc installed, you're going to prepend /home/codebliss/ghc to the path, not append, otherwise it's going to find the wrong one.
19:53:54 <codebliss> Oh that's cool.
19:54:12 <codebliss> Finished.
19:54:52 <codebliss> make; make install ?
19:54:59 * edwardk turns to trying to figure out why gtk2hs isn't wanting to install on his machine
19:55:13 <ksf> yep.
19:55:42 <edwardk> anyone have the shiny new vacuum cairo thing handy and want to make a picture for me? =)
19:55:50 <thoughtpolice> edwardk: sure
19:56:04 <thoughtpolice> well actually i'd have to start my linux box...
19:56:17 <ddarius> edwardk: Do you have any categorical calculations/rationalizations behind you post, beyond what you mention?
19:56:20 <edwardk> thoughtpolice: http://comonad.com/reader/2009/incremental-folds/ example about halfway down where i mention that it should share well but i couldn't get it installed ;)
19:56:24 <ksf> i'd have to install it, but my gtk2hs is already up and running
19:56:49 <thoughtpolice> edwardk: you can just output a .dot file if you need to; the quality might be bad on this picture
19:57:33 <edwardk> ddarius: its pretty light from a category theory perspective, just the bit about it being a use of the cofree comonad. i noticed i could do that with the cofree comonad some time back and never bothered to explain it to anyone
19:57:51 <ksf> hmmm... no executable?
19:57:58 <edwardk> then i saw sean's post popping up with a variant on it as a new idea, so i figured i'd better write something up
19:58:06 <edwardk> thoughtpolice: good point, now to figure out how to do that ;)
19:58:16 <hamishmack> codebliss: yes make; make install; export $PATH=/home/codebliss/ghc/bin:$PATH
19:59:33 <wli> Okay, now that I'm back after having been torn from the terminal from over an hour after begging for help with Data.Binary stack overflowing...
19:59:37 <codebliss> Okay thanks =)
19:59:51 <wli> Data.Binary.decodeFile is stack overflowing on me.
20:00:01 <wli> What the f*** hit me?
20:00:08 <hamishmack> codebliss: Then you need to build gtk2hs from source again.
20:00:10 <codebliss> *throws a wrench*
20:00:18 <codebliss> Woohoo.
20:00:53 <ksf> where can i get data,monoid.reducer from?
20:00:57 <ddarius> Well, though it's a totally different can of worms, I'm starting to wonder if reify and reflect can viewed as functors, perhaps adjoint or something, possibly vertical-ish ones in a fibration.
20:01:30 <hamishmack> codebliss: oh and cabal :-)
20:02:07 <ksf> doesn't ghc come with cabal?
20:02:16 <edwardk> ddarius: well, there is an end or limit in there somewhere due to the rank-n type
20:03:30 <hamishmack> ksf: sorry yes
20:04:00 <ksf> edwardk, Incremental.hs:184:21:
20:04:00 <ksf>     Not in scope: type constructor or class `Reflects'
20:04:19 <codebliss> hamishmack: Dang.  All that stuff took like an hour lol.  Thanks  =)
20:04:24 <wli> Is Data.Binary broken or something?
20:04:26 <codebliss> Still not even done with make =X
20:04:36 <edwardk> ksf: make sure you got 0.1 of reflection
20:04:44 <edwardk> if you have 0.0 from the other day the names are slightly different
20:04:52 <edwardk> you may need to cabal update
20:05:13 <wli> There's some kind of Data.Binary.Strict around but it has no obvious decodeFile
20:05:23 <codebliss> cabal-install version 0.6.2 using version 1.6.0.2 of the Cabal library
20:05:51 <edwardk> thoughtpolice: generating dot file, figured it out. good idea
20:06:56 <chessguy> what's the difference between saying that a data structure is immutable and saying that it's persistent?
20:07:16 <ksf> how do i activate a language extenison in ghci?
20:07:21 <ksf> ...interactively?
20:07:26 <ddarius> chessguy: Depends on the context, but you can use mutation to implement persistent data structures.
20:08:04 <ddarius> In fact, usually some kind of logging/caching is used to implement persistent data structures, e.g. DiffArrays.
20:08:10 <chessguy> mmm, how are you defining persistent?
20:08:18 <ksf> edwardk, i've got an image.
20:08:37 <edwardk> ksf: woot. url or way to get it to me? =)
20:08:37 <gwern> wli: binary-strict is incomplete and largely abandoned, so not very surprising
20:08:43 <ddarius> Persistent means you can (usually efficiently) get at old versions of the structure.
20:08:47 <ksf> ...and no idea where it's saved before displayed.
20:08:53 <edwardk> hah
20:08:55 <chessguy> oh
20:08:56 <chessguy> ok
20:09:09 <wli> gwern: Any idea what to do about the stack overflow with Data.Binary.decodeFile?
20:09:42 <gwern> wli: well, first use darcs binary since I dunno if the recent strictness fixes made it into a release
20:09:53 <gwern> then I'd apply the various seq tricks and stuff from -cafe
20:10:14 <wli> gwern: omfg time to revert to Read/Show
20:11:13 <ksf> ...it only seems to display the svg, not save it anywhere.
20:11:19 <ksf> i'm just going to take a snapshot.
20:11:42 <gwern> wli: yeah, that was a common reaction of mine when messing with it
20:12:48 <wli> I'm not messing with it, I'm attempting to use it.
20:13:40 <codebliss> Configuring ghc-6.10.1... cabal-bin: At least the following dependencies are missing: Cabal -any, base <3, filepath >=1 && <1.2, haskell98 -any, hpc -any, template-haskell -any, unix -any make[2]: *** [boot.stage.2] Error 1 make[2]: Leaving directory `/home/brandon/ghc-6.10.1/compiler' make[1]: *** [stage2] Error 2 make[1]: Leaving directory `/home/brandon/gh
20:13:56 <codebliss> I...have...cabal =X.  Argh.  I'll just use vim lol
20:14:04 <ksf> edwardk, http://imagebin.ca/view/vEzdP56.html
20:14:38 <hamishmack> codebliss: It might be a good idea to remove the 6.8 versions of ghc and all its dependants
20:14:46 <hamishmack> sudo apt-get remove ghc6
20:15:16 <edwardk> much obliged
20:15:20 <hamishmack> then run make again
20:15:53 <wli> I vaguely wonder if the "readline patch for 6.10 restores readline support in the ghci repl or does something else involving readline.
20:16:22 <ksf> I am, I wouldn't have tried vacuum and found out how cool it is otherwise.
20:18:12 <wli> I keep on hearing the readline patch is there, "upgrading" to 6.10, discovering ghci's repl lacks cmdline editing support (or is not invoking readline so any keybindings I can use work), and then rolling back to 6.8.3 in a panic and losing half of everything I've gotten from cabal in the process.
20:19:11 <kerlo> > "wli, you did one of these
20:19:12 <lambdabot>   <no location info>:
20:19:12 <lambdabot>      lexical error in string/character literal at chara...
20:19:22 <wli> (a fair amount of which I can never get back because attempting to reinstall will pull down a 6.10.x-only version)
20:19:26 <codebliss> And I just did remove...lol
20:20:35 <codebliss> I think I'll just use 6.8 again.  I wasn't exactly doing anything..innovative 0.o
20:22:54 <NameAlreadyInUse> what is a "space leak"? is it an alternate name for a memory leak?
20:23:04 <edwardk> yes
20:23:08 <ksf> nope
20:23:41 <gwern> 'go not to the haskellers for advice, for they will say both yes and nay'
20:23:44 <ksf> that is, in imperative programming, what's usually called a memory leak is inacessible memory, and haskell doesn't have such stuff.
20:23:45 <edwardk> in one sense, yes, it means your app is using more memory than expected, in a pedantic sense no, because you may still reclaim it
20:24:27 <gwern> woo, disabling citeproc means I can compile pandoc in under 4 gigs of ram!
20:24:32 <ksf> you can also space-leak in an imperative lang, that is, allocating more than necessary for your task without messing up memory management.
20:24:42 <gwern> (those split-objs can be a real bitch in ld)
20:25:48 <NameAlreadyInUse> are there common causes of space leaks in haskell?
20:26:04 <ksf> also, space- and timeleaks are closely related: as an extreme example, "reverse [1..]" leaks both space and time.
20:26:13 <monochrom> You can write a program that prints "hello" infinitely many times and it uses infinitely much memory. You can do it in any language. This is perhaps a memory leak.
20:26:43 <ikkebr> http://www.google.com.au/intl/en/gball/
20:26:44 <ksf> things like not using foldl'/foldr come to mind.
20:27:01 <wli> So Data.Binary has a space leak?
20:27:17 <ksf> that is, building up thunks unecessarily.
20:27:20 <ksf> dunno.
20:27:23 <ksf> i don't think so.
20:27:35 <NameAlreadyInUse> but isn't foldl' tail recursive?
20:27:43 <monochrom> There are further hair-splitting definitions of leak that insist on implementational details e.g. some say if you don't call malloc it is not considered.
20:27:53 <wli> I get a stack overflow with decodeFile
20:28:32 <ksf> tail recursiveness doesn't imply O(1) memory usage in a lazy language.
20:28:41 <wli> It sounds like it's building up a thunk graph whose spine is too deep.
20:29:22 <ksf> ...foldr isn't tail recursive, but still runs in O(1), as it doesn't build up thunks.
20:29:35 <NameAlreadyInUse> so what do people mean when they refer to foldl' as being strict?
20:29:48 <ksf> :t foldl'
20:29:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:29:57 <ksf> the first a and b are strict.
20:30:01 <edwardk> ksf: updated post with image, but i wound up using one i generated from dot in the meantime because it was 'flatter'
20:30:34 <ksf> that doesn't matter if you pass e.g. (+), as it's strict in both arguments, anyway, but does if you pass e.g. (,).
20:30:41 <monochrom> See http://www.haskell.org/haskellwiki/Stack_overflow , NameAlreadyInUse. Or Richard Bird's book "An Introduction to Functional Programming using Haskell" 2nd edition.
20:30:53 <wli> ksf: Actually it does, it's just that the spine is shallow along any step in evaluation.
20:30:59 <ksf> ...the strictness implying that thunks don't build up, as they're forced, right away.
20:31:15 <codebliss> http://www.youtube.com/watch?v=kKgBdrsqvjs <- If you can watch this and not laugh, I feel sorry for you.  Just an FYI.
20:31:28 <ksf> wli, "runs in O(1) thunks"?
20:32:25 <wli> ksf: The thunks are built up by having all the deep paths consisting of left-only links or right-only links be of right-only links.
20:32:51 <gwern> oh wow. gitit's segfaulting on me
20:32:53 <gwern> lovely
20:33:00 <monochrom> 1+(1+(1+(1+(... is a deep thunk.
20:33:05 <wli> ksf: Unwinding the spine follows left-only links.
20:33:34 <wli> > foldr (+) 1 (replicate 99 1) :: Expr
20:33:35 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
20:33:37 <gwern> segfaulting even without plugins...
20:33:38 <NameAlreadyInUse> @src ($!)
20:33:38 <lambdabot> f $! x = x `seq` f x
20:34:09 <wli> ksf: As monochrom says, it's a deep thunk, but the depth always leans right.
20:34:58 <monochrom> Since + is strict in both operands for Int for example, 1+(1+(1+(1+(... still takes much stack when evaluated.
20:35:04 <ksf> I should really re-read the stg paper, i've learned too much in the meantime.
20:35:13 <sm> evening all
20:35:25 * ksf smells dangerous half-knowledge.
20:36:31 <wli> ksf: I'm not surprised the stench of that emanates from me and quitely strongly.
20:36:57 <monochrom> If you have an operator with different strictnesses in different operands, some deep thunk directions won't cause trouble and some other directions will.
20:37:14 <pumpkin> > replicate 100 replicants
20:37:15 <lambdabot>   Not in scope: `replicants'
20:37:27 <pumpkin> @let replicants = "onoes "
20:37:28 <lambdabot>  <local>:12:0:
20:37:28 <lambdabot>      Multiple declarations of `L.replicants'
20:37:28 <lambdabot>      Declared at:...
20:37:32 <pumpkin> > replicate 100 replicants
20:37:33 <lambdabot>   ["onoes ","onoes ","onoes ","onoes ","onoes ","onoes ","onoes ","onoes ","o...
20:37:34 <sm> http://gist.github.com/88523 contains some real-world hunit test code. Current problem is that one of the tests is failing and I can't immediately tell which one. I'm looking for advice on this and generally tips on applying hunit effectively
20:37:49 <ksf> we shall combine our forces and incantate dons!
20:37:52 <rovar>     Could not find module `Control.Monad.State':
20:37:54 <rovar>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
20:37:55 <monochrom> Absolutely everyone should absolutely read Richard Bird's book "An Introduction to Functional Programming using Haskell" 2nd edition. This issue is completely calculated in the book.
20:37:57 <rovar> how do I address this?
20:38:37 <ksf> whith -package options on the ghc command line
20:39:25 <ksf> ...or a .cabal file
20:39:46 <monochrom> Imperative solution: use ghc-pkg hide. Functional solution: what ksf says. (Isn't the imperative solution so much more tempting? :) )
20:40:38 <rovar> which one should be hidden?
20:40:46 <ksf> the one you don't want to import?
20:40:57 <rovar> i'm guessing the monads-fd seems much more unstable
20:41:44 <ksf> ...I don't ever heard of it and mtl is standard, so I guess that's what you want.
20:42:36 <monochrom> Haha, so you've chosen to go down the road of peril of the imperative way.  WELCOME TO THE DARK SIIIIIIIDE.........
20:43:52 <wli> I can't figure out where the gross inefficiency in my algorithm is offhand.
20:44:47 <ksf> I fear my textbook budget is quite limited right now, especially in the >20 euros area.
20:45:11 * edwardk kind of likes the monads-tf version
20:45:18 <ksf> (which includes about anything cs-related)
20:45:48 <monochrom> Yeah, would be nice if Bird's book becomes free.
20:46:19 <ksf> ...or cost less than 2G ram.
20:46:29 <sbahra> It doesn't. :-)
20:47:06 <monochrom> Hmm how many Big Macs have the same cost as 2G of RAM? :)
20:47:35 <monochrom> (Big Mac price index vs RAM price index :) )
20:48:55 <wli> Farmer's Bureau price indices / series could come in handy for analogous things.
20:51:45 <Eridius_> @pl \(a,b) -> (b,a)
20:51:45 <lambdabot> uncurry (flip (,))
20:52:13 <wli> Hmm, there could be an RMonad instance for MultiSets, too.
20:54:12 <monochrom> MultiSet actually makes a better RMonad than Set.
20:54:48 <wli> join :: MultiSet (MultiSet t) -> MultiSet t ; join = MultiSet.unionsMap id
20:55:28 <Eridius_> @src take
20:55:28 <lambdabot> take n _      | n <= 0 =  []
20:55:28 <lambdabot> take _ []              =  []
20:55:28 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:57:53 <Eridius_> @check \xs ys -> take (length xs) (xs ++ ys) == xs
20:57:54 <lambdabot>   "OK, passed 500 tests."
20:59:44 <wli> monochrom: How so?
21:00:44 <sm> there's something.. my "helpers" were hiding the option of attaching to a label to an assertion. Just what I need here
21:00:57 <monochrom> For Set there is something about fmap (const 0) {1,2,3} = {0} that breaks some axiom.
21:01:07 <wli> type Dictionary = Map (MultiSet Char) (Set String) ; anas :: Dictionary -> MultiSet Char -> Set (MultiSet (MultiSet Char))
21:03:27 <sm> but I should be able to attach a label to some arbitrary IO action I've built up.. assertNoFail ".." ... or something
21:09:18 <travisbrady> anyone know of examples using Haskell to read a file in chunks and then process it in a few different threads?  i'm thinking widefinder-ish things
21:10:22 <ksf> mmap-bytestring and forkio?
21:10:54 <ksf> ... i think it was bytestring-mmap.
21:11:36 <travisbrady> ksf: i was just looking at mmap-bytestring actually
21:12:33 <ksf> otoh, you can open multiple fd's and seek a couple of them further into the file, but it's gonna be more work and slower, anyway.
21:20:31 <ksf> mmmmmhhhh... you could do a parallel grep using bytestring-search and annoy the gnu guys by massively outperforming them...
21:23:58 <wli> http://wli.pastebin.com/m2018433b <-- performance sucks for some reason
21:30:25 * jmcarthur is tempted to try and revive his somewhat fast fingertree anagram program
21:31:31 <monochrom> Oh it's April 1st already. Where is the virus/worm destruction?
21:31:44 <wli> I suspect I'm not really capable of high-performance programming.
21:32:59 <rovar> is there a guid module?
21:33:02 * ksf checks again if the rfc is already out
21:33:41 <jmcarthur> wli: finding anagrams can be a tough algorithm
21:35:17 <jmcarthur> dang, i must be looking at an old version of the program. this is freaking slow
21:44:10 <wli> jmcarthur: A lot of the badness has to do with how much garbage is in the dictionary. Abbreviations and single letter words really slow it down.
21:44:23 <pumpkin> wassup DAWG?
21:48:10 <wli> Okay, http://wli.pastebin.com/m50d6a8eb <-- slightly faster since it's not generating mountains of garbage (i.e. non-anagrams)
21:50:24 <rovar> is it possible to put a record update in a lambda?
21:50:46 <rovar> I.adjust (λp →  p { pl_session = sess, pl_class = NoClass, pl_name = nm } ) cid players
21:50:56 <ksf> you can even thread a camel through a lambda.
21:51:23 <wli> jmcarthur: Is the crap I'm doing even remotely in the right direction?
21:51:25 <rovar> what am I doing wrong there? It's not happy with me.
21:51:56 <ksf> what does it say?
21:52:03 <BMeph> ksf: "I'd walk a mile to smoek a Caml..." ;p
21:52:04 <ksf> @where hpaste
21:52:04 <lambdabot> http://hpaste.org/
21:52:40 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3163#a3163
21:53:28 <ksf> the update is working fine, your types are messed up.
21:53:32 <rovar> Players is an intmap or Player
21:53:40 <rovar> intmap of
21:57:04 * ksf is off doing what he already intended to do three hours ago: get insulted in some spring game instead of working.
21:57:21 <wli> It takes 2 minutes to do a simple lookup on web1913 read back via Data.Binary
21:58:12 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3163#a3165
21:59:50 <monochrom> Oh funky symbols!
22:00:02 <rovar> i broke all of the pieces out to try to isolate the problem.. didn't really help...
22:00:23 <rovar> for some reason it thinks it's evaluating to a function instead of a type
22:00:34 <rovar> those are yi's doing.
22:02:21 <wli> Essentially constructing the big Data.Map even from a Data.Binary dump takes 2 minutes.
22:02:28 <monochrom> @type getStdRandom
22:02:29 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
22:02:41 <monochrom> @type randomR (1,100)
22:02:42 <lambdabot> forall t g. (RandomGen g, Random t, Num t) => g -> (t, g)
22:03:39 <monochrom> So far so good.
22:03:54 <wli> Once the big Data.Map is built it all runs comparatively smoothly.
22:04:04 <mib_ly5vrgb3> I meet a problem on installing HStringTemplate-0.4.3, says  Could not find module `Data.Generics.Aliases':  it is a member of package base-3.0.3.0, which is hidden ,who can tell me how to solve
22:04:18 <monochrom> "lb lb_players" implies that lb is a function, doesn't it?
22:04:52 <wli> That's not to say it doesn't take several minutes on longer strings even so.
22:05:02 <ksf> yeah, i think you mean lb_players lb
22:05:02 <rovar> monochrom: ha! that's it
22:05:07 <rovar> ya
22:05:11 <rovar> that fixed it
22:05:33 <monochrom> lb_players lb is the intention I guess.
22:05:39 <rovar> i really need to find a better time to code. sleep deprivation + haskell == more sleep deprivation
22:05:59 <ksf> ...the problem was again not types, but haskell actually making sense of nonsensical types.
22:06:03 <monochrom> Java and Python are what taught you to think "lb.lb_players" die die die.
22:06:38 <ksf> ...and haskell is what teaches you to think lb>>=lb_players
22:06:53 <ksf> record monad...
22:06:56 <rovar> heh
22:07:00 <wli> Yeah, I'm seeing the first lookup take 2 minutes and the second take 1s or so.
22:08:14 <mib_ly5vrgb3> I meet a problem on installing HStringTemplate-0.4.3, says  Could not find module `Data.Generics.Aliases':  it is a member of package base-3.0.3.0, which is hidden ,who can tell me how to solve
22:09:00 <seliopou> install base with major version number 4
22:09:03 <ksf> ghc 6.10?
22:09:34 <mib_ly5vrgb3> yes
22:09:40 <seliopou> hmmm
22:10:40 <ksf> uhhhhh.
22:11:42 * ksf clears the field for someone with greater cabal-foo.
22:11:49 <mib_ly5vrgb3> It means the ghc 6.10 lack of this module?
22:12:24 <ksf> indeed, but hstringtemplate compiles fine with 6.10, i've got it installed myself.
22:13:16 <wli> I'm trying to think of where I could be getting redundant searches from.
22:13:18 <mib_ly5vrgb3> my ghc is also 6.10. why it cannot be compiled
22:13:37 <seliopou> try the small-base flag?
22:13:56 <seliopou> that should be the default
22:14:53 <wli> What if I try words w then w' in one branch and w' then w in another? The order of appearance contributes nothing to the end enumeration.
22:16:28 <mib_ly5vrgb3> I install it by run "runhaskell setup.hs build" in hstringtemplate directory, then the problem occurs, but "runhaskell setup.hs confure" is OK.
22:17:45 <wli> Enumerate sub-words in lex ascending order.
22:19:04 <seliopou> mib_ly5vrgb3: if you change base >= 3 to base >= 3 && base < 4 in the .cabal file, it should work
22:20:31 <mib_ly5vrgb3> let me try
22:26:04 <mib_ly5vrgb3> great. it works ,but at last I change base >= 3  into base < 4, base >= 3 && base < 4 results some parse time error
22:32:39 <Heffalump> try base >=3 && <4
22:34:20 <seliopou> ^ that's the one. I mistyped it before, sorry about that
22:34:27 <mib_ly5vrgb3> thank you all. it works now
22:35:46 <mib_ly5vrgb3> I do this for to install happstack ,there are too many dependent packages...
22:38:15 <mib_ly5vrgb3> Is there a tool like maven that can download these dependencies automatically now?
22:39:31 <mib_ly5vrgb3> the job for searching these packages drives me crazy
22:42:36 <blackh> mib_ly5vrgb3: cabal will do it all automatically (if you don't get another problem)
22:45:00 <mib_ly5vrgb3> I am sorry for my naive question , is the command runhaskell driven by cabal?
22:45:06 <bos> no
22:48:52 <mib_ly5vrgb3> the ghc's document says the cable is intergrated into ghc, then how can I run cable without a standalone cabal installation
22:49:06 <quicksilver> it's a library
22:49:09 <quicksilver> you don't "run" it
22:49:11 <quicksilver> it just is.
22:49:22 <quicksilver> cabal-install is a program you can run.
22:49:27 <quicksilver> cabal is a library.
22:49:30 <quicksilver> cabal comes with GHC
22:49:35 <quicksilver> cabal-instlal does not.
22:49:42 <dancor> mib_ly5vrgb3: 'cabal install' takes a .cabal file which has the dependencies specified
22:49:46 <dancor> and does everything
22:50:08 <quicksilver> the "cabal" command is part of the cabal-install program, not the cabal library.
22:50:10 <monochrom> runhaskell is an instance of the interpreter in GHC.
22:50:12 <quicksilver> (yes, this is very confusing!)
22:50:52 <dancor> mib_ly5vrgb3: it sounds like you want something to tell you the dependencies just from the .hs file?
22:51:11 <dancor> i think http://code.haskell.org/hbuild/ does that..
22:51:45 <mib_ly5vrgb3> I want it to search and install these dependencies transparently
22:51:59 <dancor> mib_ly5vrgb3: starting from just a .hs file, correct?
22:52:06 <mib_ly5vrgb3> yes
22:53:21 <dancor> i think you could combine hbuild and cabal-install to get something that usually did that, and i've even started writing something that does that and some other mundane tasks (adding missing imports and type signatures to a whole file etc).  however my stuff isn't finished, and there is some guessing necessarily involved
22:53:23 <mib_ly5vrgb3> you all are so nice , I am a newcomer of haskell. thank you for your patient guides
22:53:35 <monochrom> That's more difficult. But if you have even one package in mind, cabal-install digs up the rest.
22:54:06 <dancor> for example it's hard to tell if the .hs would need a certain version of something..
22:54:28 <dancor> or two different packages could give you the same library
22:57:32 <dancor> what should i do when i get: (.text+0x117d): undefined reference to `containerszm0zi2zi0zi0_DataziIntMap_lvl44_closure'
22:57:36 <dancor> while building hbuild
22:58:48 <sm> hypothesis: I suspect you can be productive with smalltalk (eg) across a wider range of tired <-> alert states, than haskell; and even though the code may not be as clearly thought through as each line of haskell, I suspect it may be a net win, for many kinds of app
22:58:55 <monochrom> Looks like Data.IntMap
22:59:23 <sm> am I wrong ?
22:59:45 <dancor> monochrom: that's in containers right?  i've tried reinstalling that from hackage..
23:00:06 <pumpkin> dancor: you used --make?
23:00:15 <pumpkin> I guess so :P
23:00:18 <pumpkin> didn't read scrollbac
23:00:18 <pumpkin> k
23:00:35 * sm is working too hard to write hunit tests for bits of hledger. I'm not at my best right now, but still. Smalltalkers (in particular) doing test driven development don't slow down like this..
23:00:38 <pumpkin> preflex: zdec containerszm0zi2zi0zi0_DataziIntMap_lvl44_closure
23:00:41 <monochrom> The build script or make file or cabal file forgets to say "containers-x.y.z"
23:00:41 <preflex>  containers-0.2.0.0_Data.IntMap_lvl44_closure
23:00:42 <mib_ly5vrgb3> I want to know how to install a package through the "cabal-install" problem, how to make it work? by a command like what?
23:01:12 <mib_ly5vrgb3> I want to know how to install a package through the "cabal-install" program, how to make it work? by a command like what?
23:02:10 <dancor> mib_ly5vrgb3: "cabal install --global --root-cmd=sudo parsec" would install the parsec library for all users
23:03:44 <mib_ly5vrgb3> thank you
23:04:08 <monochrom> When I'm tired I can still follow a calculational proof but not an English-paragraph proof.
23:06:14 * dancor can never follow paragraph proofs
23:06:25 <dancor> and i cannot wait for agda to take over math
23:06:53 <dancor> i give it 10 to 100 years
23:07:26 <wli> I just need to be able to make up a type system and formalize it with sequent calculus etc.
23:07:49 <wli> Mutatis mutandis for module systems.
23:08:34 <monochrom> agda has a slightly less chance than isabelle of taking over math. of course the chance of isabelle is small too. I say this because more people are working on using isabelle to formalize math already --- more people and they have already started.
23:08:54 <dancor> i guess i'm fine with either
23:09:10 <monochrom> Fun fact: isabelle has typeclass just like haskell. even better, isabelle typeclass lets you add axioms, not just methods.
23:10:05 <wli> Like the monad laws?
23:10:06 <ksf> that'd be a cool feature for h'.
23:10:08 <monochrom> The syntax is strikingly similar too. I guess isabelle and haskell looked over each other's shoulder.
23:10:26 <monochrom> Yes! Like the monad laws! You write them as part of your typeclass declaration.
23:10:29 <ksf> ...and we can fake it 'till we make it with quickcheck.
23:10:54 <wli> monochrom: I've been wishing for that.
23:11:11 <wli> monochrom: Does isabelle have a module system worth speaking of?
23:11:16 <ksf> thinking of it, can quickcheck work on all visible instances of a typeclass?
23:11:31 <monochrom> So for example you can write like "class Ring r where <ring operators and ring axioms here".  Pretty handy.
23:11:59 <dancor> now if i could use SDL from isabelle..
23:12:14 <monochrom> I don't know about isabelle's module system. Probably not.
23:13:10 <dancor> my ring-algebra shoot-em-up mashup will never take off
23:13:18 <monochrom> isabelle is also not just one theorem prover, but a whole family. there is isabelle/hol, isabelle/somethingElse...  module system may depend on the variations. isabelle/hol likely has a boring module system.
23:13:53 <ksf> note: don't call something a theorem prover if you want me to use it.
23:14:08 <ksf> call it a dependently typed language.
23:14:13 <monochrom> but typeclass kinds of make up for it. really, you don't want a "ring module" no matter how powerful it means; you want a "ring typeclass" because it's operator overloading that make math works.
23:15:46 <monochrom> I guess sometimes you don't want operator overloading.
23:16:27 <wli> That's not what modules help with.
23:16:37 <Gracenotes> whenever I hear 'operator overloading' I thnk 'dirty hack' :/
23:16:43 <Gracenotes> +i
23:16:59 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3166#a3166
23:17:12 <rovar> is there a trick to getting that to output over the socket?
23:17:21 <dolio> The problem with that is that you want, for instance, monoid modules, not a monoid typeclass.
23:17:23 <rovar> i verified that the handle is valid.
23:17:39 <monochrom> Yes I just realized that.
23:17:42 <dolio> Because otherwise you get into the nonsense like Sum and Product.
23:18:34 <Gracenotes> dolio: hm... suppose you want to use both at the same time? If I understand what you're saying
23:20:35 <monochrom> Right, you don't want to say "Integer is a monoid". Even in math you know to say "Integer,+ is a monoid; Integer,* is a monoid". Haskell doesn't let you do the latter. Now let me check if isabelle/hol is better than that.
23:20:36 <FunctorSalad_> does the base lib have optimization {-# RULES #-} for arithmetic?
23:20:44 <FunctorSalad_> (like 0*x=0)
23:20:50 <rovar> hFlush is the ticket.
23:20:55 <rovar> hurray for buffering
23:21:01 <FunctorSalad_> (if not, is there any particular reason not to? even if it eliminates bottoms)
23:21:47 <dolio> > 0 * undefined
23:21:49 <lambdabot>   * Exception: Prelude.undefined
23:21:59 <pumpkin> I wonder why arrows aren't more popular
23:22:11 <ksf> they are.
23:22:19 <ksf> look at all those -> in code.
23:22:23 <pumpkin> :)
23:22:42 <FunctorSalad_> pumpkin: they're nice as long as >>> and &&& suffice, but  IMHO with arrowApply and friends it becomes a mess
23:23:01 <pumpkin> yeah, the main four or five functions on the -> arrow are quite common
23:23:04 <FunctorSalad_> (if choice of arrow depends on results of previous arrows)
23:23:37 <pumpkin> but even ArrowChoice, which is quite similar to first/second, is virtually unused
23:23:41 <pumpkin> (from what I've seen)
23:23:47 <wli> I can't figure out how to do anything with Arrows apart from usng (***), (&&&), (|||), (+++), left, right, first, and second as convenience functions on pairs and Either.
23:24:23 <FunctorSalad_> pumpkin: or "level jumping", like HXT's listA being of type ListArrow a b -> ListArrow a [b] (you can't "grasp" the fanout internally and make a ListArrow b [b])
23:24:25 <pumpkin> custom arrow instances, ArrowApply, ArrowLoop, and ArrowPlus I've never seen used outside of the paper
23:24:35 <pumpkin> HXT?
23:24:43 <FunctorSalad_> haskell xml toolkit
23:24:44 <wli> pure, arrowApply, ArrowLoop, (>>>), etc. I'm clueless about.
23:24:54 <pumpkin> arr?
23:25:05 <pumpkin> I think pure is from applicative isn't it?
23:25:06 <wli> arr too.
23:25:19 <FunctorSalad_> wli: >>> is composition with args reversed
23:25:22 <pumpkin> wli's a pirate!
23:25:26 <wli> That must be a change to dodge a namespace clash.
23:25:34 <hotaru2k3> what is if'?
23:25:44 <ksf> :t if'
23:25:45 <pumpkin> hotaru2k3: if' p a b = if p then a else b
23:25:45 <lambdabot> Not in scope: `if''
23:25:48 <ksf> @src if'
23:25:48 <lambdabot> Source not found. Sorry.
23:25:52 <ksf> argh.
23:25:56 <pumpkin> hotaru2k3: it isn't defined anywhere standard
23:25:59 <ksf> it's the same as if then else, but as a function.
23:26:03 <pumpkin> but @pl uses it as it's a nice function
23:26:21 <ksf> if' p c a = if p then c else a
23:26:37 <FunctorSalad_> @type ArrowApply
23:26:37 <wli> if' p t f = if p then t else f
23:26:38 <lambdabot> Not in scope: data constructor `ArrowApply'
23:26:43 <FunctorSalad_> @type appA
23:26:44 <lambdabot> Not in scope: `appA'
23:26:47 <FunctorSalad_> @type apply
23:26:48 <lambdabot> Not in scope: `apply'
23:26:50 <FunctorSalad_> :(
23:26:55 <pumpkin> it's app
23:26:57 <pumpkin> :t app
23:26:58 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
23:27:01 <Gracenotes> :OX
23:27:07 <pumpkin> :COW
23:27:07 <ksf> wli, it's predicate, consequent, alternative, you should know that since having read the wizard book.
23:27:10 <mmorrow> @type uncurry id
23:27:11 <lambdabot> forall b c. (b -> c, b) -> c
23:27:51 <pumpkin> is it really a predicate?
23:28:01 <wli> ksf: I recognize the words upon seeing the mnemonics expanded. I'd stick to 't' and 'f' for most people.
23:28:04 <FunctorSalad_> pumpkin: right. app is confusing, isn't it :(
23:28:17 <mmorrow> @type flip (uncurry (flip id))
23:28:18 <Gracenotes> @type let (?)=(?) in (?wheretehbeef?)
23:28:18 <lambdabot> forall a b c. b -> (a, a -> b -> c) -> c
23:28:19 <pumpkin> FunctorSalad_: it's not that bad actually
23:28:19 <lambdabot> forall t t1. (?wheretehbeef::t) => t1
23:28:29 <pumpkin> FunctorSalad_: it's what mmorrow just typed for functions
23:28:31 <wli> pumpkin: ap still confuses me.
23:28:54 <Gracenotes> lambdabot just uses ap as a cute shortcut :\
23:29:27 <FunctorSalad_> wli: ap is cool as a replacement for liftMx
23:29:32 <wli> ap is incomprehensible. Every time @pl craps it out I am forced to derive the pointfree affair by hand.
23:29:59 <mmorrow> haha
23:30:02 <FunctorSalad_> > (*) <$> [1,2] <*> [4,5,6]
23:30:04 <lambdabot>   [4,5,6,8,10,12]
23:30:10 <bos> ap is easy once you grok it.
23:30:19 <Gracenotes> of course, you don't need pl to make ap nonsense
23:30:20 <mmorrow> wlirants++
23:30:24 <Gracenotes> a homebrew: putStrLn.unlines.(!!5).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
23:30:31 <wli> I don't have enough of a mind left to ever figure ap out.
23:30:34 <Gracenotes> <*> being ap ocourse
23:30:37 <pumpkin> > grok ap
23:30:38 <lambdabot>   Add a type signature
23:30:46 <Gracenotes> haha fail :\
23:30:46 <pumpkin> :(
23:31:19 <mmorrow> aww crap, someone beat me to it
23:31:22 <wli> @pl let rep m = m >> rep m in rep
23:31:22 <lambdabot> fix (ap (>>))
23:31:25 <FunctorSalad_> > ?grok `ap` dog
23:31:26 <mmorrow> > grok grok
23:31:27 <lambdabot>       Unbound implicit parameter (?grok::(t, t1) -> ([Char], t1) -> b)
23:31:27 <lambdabot>       ...
23:31:27 <lambdabot>   yay, I get it now
23:31:28 <pumpkin> wli: I found it easiest to get ap when I was playing with the -> monad
23:31:32 <FunctorSalad_> @type ?grok `ap` dog
23:31:33 <lambdabot> forall b t t1. (?grok::(t, t1) -> ([Char], t1) -> b) => (t, t1) -> b
23:31:37 <FunctorSalad_> :)
23:31:39 * mmorrow did @let grok _ = text "Segmentation fault"
23:31:46 <pumpkin> mmorrow: aw
23:31:46 <wli> pumpkin: That's the case where it always blows me away.
23:32:00 <pumpkin> mmorrow: yours is so much cooler, sorry I ruined it
23:32:06 <mmorrow> pumpkin: :)
23:32:11 <wli> Explain how let rep m = m >> rep m in rep == fix (ap (>>))
23:32:38 <mmorrow> @free ap
23:32:39 <lambdabot> Expected variable or '.'
23:33:12 <pumpkin> freedom fail
23:33:14 <Gracenotes> wli: in this case, what you're fixing is rep
23:33:35 <Gracenotes> the m is made unnecessary by the ap. the rep is made unnecessary by the fix. afaik.
23:34:02 <mmorrow> @free zip7
23:34:03 <lambdabot> $map ($map_Tuple7 f g h k p q f1) . zip7 xs ys zs us vs as = zip7 ($map f xs) ($map g ys) ($map h zs) ($map k us) ($map p vs) ($map q as) . $map f1
23:34:06 <mmorrow> heh
23:34:16 <wli> I know how fix works. fix (\rep m -> m >> rep m) is one of the ways to accomplish letrec.
23:35:14 <Gracenotes> which is requivalent to: \rep -> (>>) `ap` rep
23:35:20 <wli> Duplicating args I generally deal with via join.
23:35:22 <pumpkin> wli: is it a general problem with the monad instance for (->)? or do you get what liftMx is doing?
23:35:35 <wli> Gracenotes: Eh? How the fsck?
23:35:48 <FunctorSalad_> the monad instance for (->) is sneaky...
23:36:19 <Gracenotes> > ((,) `ap` show) 100
23:36:20 <lambdabot>   (100,"100")
23:36:24 <FunctorSalad_> it messes with type errors because it lets ghc make more sense out of your code than it has ;)
23:36:25 <Gracenotes> > ((,) =<< show) 100
23:36:27 <lambdabot>   ("100",100)
23:36:33 <Gracenotes> > join (,) 100
23:36:34 <FunctorSalad_> (than the code has)
23:36:35 <lambdabot>   (100,100)
23:36:48 <Gracenotes> all of the above using a function instance
23:37:00 <Gracenotes> in the case of ap, it modifies the second argument
23:37:26 <Gracenotes> well. it modifies the 'reader' (environment) argument with show before feeding them both to (,)
23:37:37 <pumpkin> wli: for example, one common thing I've been doing recently is liftM2 MyDataConstructor (+1) (*5), which is equivalent to \x -> MyDataconstructor (x+1) (x*5)... does that make sense?
23:37:40 <Gracenotes> =<< does the same thing, but feeds it to (,) in the reverse order
23:37:45 <trofi^w> @src fix
23:37:45 <lambdabot> fix f = let x = f x in x
23:38:22 <Gracenotes> it's more idiomatic than anything, in the case of ap and =<< for function instances, in many cases, I think
23:38:39 <wli> pumpkin: Sort of like `on` except you get a different choice for each arg.
23:38:43 <pumpkin> wli: exactly
23:38:46 <Gracenotes> yeah :)
23:38:55 <pumpkin> wli: now, say you have two data constructors, but you want to choose which one to use based on the argumen too
23:38:56 <pumpkin> something like
23:39:11 <wli> And `ap` is like `on` except it only puts the function on the second argument?
23:39:25 <pumpkin> \x -> (if x > 5 then MyFirstDataConstructor else MySecondDataConstructor) (x+1) (x*5)
23:39:28 <Gracenotes> in (>>) m (rep m), you're feeding m to (>>) in two ways, but modifying the second version of it with rep. So idiomatically, that becomes (>>) `ap` rep
23:39:48 <pumpkin> wli: in that case, you can use ap, which is just liftM2 id
23:40:23 <pumpkin> so yeah, it allows you to have your input affect the function itself as well as the parameters to it
23:40:35 <pumpkin> not sure if that's any clearer than @pl :P
23:40:46 <wli> (>>) m (rep m) == liftM2 (>>) id rep m = ((>>) `ap` rep) m
23:40:46 <pumpkin> it's quite similar with Data.Binary.Get too
23:41:02 <pumpkin> you'll often see liftM2 MyConstructor get get
23:41:23 <pumpkin> which is almost the same use pattern as the one I presented above
23:41:27 <mmorrow> , (uncurry zip . fix) (\a -> (0:snd a,1:fst a))
23:41:29 <lunabot>  [(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),...
23:41:32 <mmorrow> works, but
23:41:43 <mmorrow> , (uncurry zip . fix) (\(a,b) -> (0:b,1:a))
23:41:45 <lunabot>  luna: out of memory (requested 2097152 bytes)
23:41:45 <mmorrow> doesnt
23:41:49 <mmorrow> i don't know why
23:42:04 <pumpkin> , (uncurry zip . fix) (\~(a,b) -> (0:b,1:a))
23:42:05 <lunabot>  luna: parse error on input `->'
23:42:11 <pumpkin> is that not allowed?
23:42:14 <mmorrow> , (uncurry zip . fix) (\ ~(a,b) -> (0:b,1:
23:42:15 <lunabot>  luna: parse error (possibly incorrect indentation)
23:42:17 <mmorrow> parser fail
23:42:20 <Gracenotes> > fix $ (0:) . (1:) . (=<< [1..]) . ((<*>) . ((return .) . (+) <$>) <*> (. subtract 1)) . (!!) -- more ap (<*>) confusion, by the way, for those with a strong stomach >_>
23:42:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:42:25 <pumpkin> , (uncurry zip . fix) (\ ~(a,b) -> (0:b,1:a))
23:42:25 <mmorrow> , (uncurry zip . fix) (\ ~(a,b) -> (0:b,1:a))
23:42:26 <lunabot>  [(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),...
23:42:27 <lunabot>  [(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),...
23:42:30 <pumpkin> there we go :)
23:42:31 <mmorrow> oh nice!
23:42:38 <wli> Okay, so I understand `ap` as like `on` except it only applies the function to the second argument.
23:43:02 <pumpkin> yup
23:43:08 <pumpkin> very handy in certain binary formats too
23:43:28 <FunctorSalad_> heh... D a := formal power serieses with coeffs in a is a monad, isn't it :)
23:43:45 <wli> Which Applicative operator is ap? (<*>)?
23:43:53 <FunctorSalad_> wli: yep
23:43:53 <Gracenotes> yeah
23:43:58 <FunctorSalad_> <*> is prettier :)
23:44:03 <pumpkin> mmorrow: I'm guessing that means that the excessive strictness was evil
23:44:09 <Gracenotes> wli: see also http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ for a great example of them in the non-function case
23:44:28 <mmorrow> pumpkin: why the desugaring rule for mfix needs ~ suddenly becomes clear to me :)
23:44:30 <Gracenotes> it helped me understand them pretty well
23:44:42 <wli> @type fix ((>>) <*>)
23:44:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
23:44:43 <pumpkin> mmorrow: I can't say I understand mfix yet :P
23:45:03 <Gracenotes> mdo, the dark secret of Haskell
23:45:11 <mmorrow> pumpkin: i pasted the desugaring rule a while ago.
23:45:13 * mmorrow finds it
23:45:16 <Gracenotes> sealed up in an ancient tomb and guarded with traps
23:45:34 <mmorrow> once you see how it desugars, you're like "oh."
23:45:45 <pumpkin> :o
23:45:50 <Gracenotes> yes, and no one's told me! O:
23:46:00 <FunctorSalad_> Gracenotes: it's not even syntax highlighted
23:46:24 <Gracenotes> actually, I like "sealed up in an ancient tomb and guarded with tarps" better
23:46:48 <pumpkin> I haven't seen Axman6 recently
23:46:54 <Gracenotes> It's a tarpaulin!
23:46:58 <pumpkin> actually, I've never seen him
23:46:59 <Axman6> you have now
23:47:01 <pumpkin> but I meant on IRC
23:47:11 <pumpkin> Axman6: omg
23:47:19 <pumpkin> my summoning powers work
23:47:19 <Axman6> been extremely busy with uni
23:47:49 <wli> My anagram generator finally terminated on "simon peyton jones", albeit after taking an hour.
23:47:54 <pumpkin> :o
23:48:03 <pumpkin> you need the power of the DAWG
23:48:04 <Axman6> darcs failed:  Directory or file named '.' already exists.
23:48:06 <Axman6> -_-
23:48:11 <pumpkin> one of these days I'll write a dawg library
23:48:13 <monochrom> In practice "isabelle" now refers to isabelle/isar, and "isabelle/hol" refers to isabelle/isar/hol. (It gets complicated, doesn't it? :) )  The isar part has a parametric module system.  That solves the "Integer,+ is a monoid; Integer,* is a monoid" problem.
23:48:17 <pumpkin> so I can stop being so annoying about it
23:48:24 <wli> pumpkin: I'm not sure how a DAWG would help.
23:48:32 <monochrom> The module system is called "locales" there.
23:48:46 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1282
23:49:21 <Gracenotes> pumpkin: hey now, watchyaself. I made a dawg joke about DAWGs a few months ago. O:
23:49:22 <pumpkin> wli: take a look at http://code.msdn.microsoft.com/anagrams for example... I've thought through it but have never tried implementing it
23:49:38 <pumpkin> Gracenotes: it was probably related to me asking about existing dawg libraries :P
23:49:41 <Axman6> can DAGs be implemented in haskell? i founf out wht they are today, and was thinking about how you
23:49:46 <Axman6> you'd do it*
23:49:52 <pumpkin> Axman6: sure thing!
23:50:02 <pumpkin> Axman6: some representations might be harder than others though :P
23:50:06 <FunctorSalad_> Axman6: fgl supports arbitrary graphs
23:50:06 <monochrom> isabelle typeclass is syntactic sugar over isar locales.
23:50:13 <Axman6> fgl?
23:50:17 <Gracenotes> if you can start from the sink and work towards the source, DAGs would be pretty easy
23:50:22 <FunctorSalad_> the package, Axman6
23:50:23 <pumpkin> Axman6: functional graph library
23:50:27 <wli> pumpkin: How would a DAWG help http://wli.pastebin.com/m55a4864c ?
23:50:27 <Gracenotes> otherwise... you might need Int references
23:50:28 <harovali> hi , what does it mean when a function signature has a leading    =>    ?
23:50:30 <Gracenotes> or something like that
23:50:46 <FunctorSalad_> I don't know fgl in detail but apparently purely functional graphs are quite nontrivial
23:51:00 <FunctorSalad_> (if you don't want horrible performance)
23:51:01 <Gracenotes> Int indexing. It's the only way, man. like totally.
23:51:20 <Axman6> (+) :: Num a => a -> a -> a -- says that plus takes two things that instances of Num, and returns one of the same type
23:51:33 <mmorrow> mdo {stmts; f x1 .. xn} <==> do {(x1,..,xn) <- mfix (\~(x1,..,xn) -> do{stmts; return (x1,..xn)}); f x1 .. xn}
23:51:34 <wli> Gracenotes: DAWG basically is using a DAG to enable sharing between substrings.
23:51:41 <pumpkin> wli: so in a dawg, you have a few instances of each letter in the graph... retain a way of getting each of those letter nodes, jump into one of the letters you have, and only take paths that walk along letters you have
23:51:48 <FunctorSalad_> (*) _ _ = failure assert "no componentwise vector multiplication for you :p"
23:51:57 <Gracenotes> wli: yes, I've implemented one of them imperatively
23:51:59 <mmorrow> pumpkin: err, right so i mixed up that we were talking about mfix itself, and not mdo
23:52:13 <Gracenotes> they require a lot of intermediate stuffs :\
23:52:18 <harovali> Axman6: so => is sort of a declaration of type for the a ?
23:52:18 <pumpkin> mmorrow: aha
23:52:24 <FunctorSalad_> (it's needed once in a blue moon, the risk of confusing it with matrix mult is higher imho)
23:52:26 <pumpkin> Gracenotes: yeah, they're hard to implement, I've done a simple one in ruby
23:52:33 <Axman6> yeah, says a must be an instance of Num
23:52:37 <pumpkin> Gracenotes: but I bent my mind on how to do it nicely in haskell
23:52:40 <monochrom> => is sort of a punctuation
23:52:57 <Gracenotes> pumpkin: finger trees, how else!
23:53:00 <harovali> monochrom: you mean one could do without it ?
23:53:01 <Gracenotes> oh wait.
23:53:03 <Gracenotes> >_<
23:53:05 * pumpkin tries to pronounce mdo for mmorrow
23:53:11 <pumpkin> Gracenotes: fingerDAGs
23:53:13 <pumpkin> :P
23:53:15 <mmorrow> mmmmmmmuhdoooo
23:53:16 <wli> pumpkin: I can't figure out where that's supposed to fit into the algorithm.
23:53:20 <Gracenotes> sounds delicious.
23:53:31 <monochrom> No, one must always need punctuations otherwise you're unparsable don't you think
23:53:33 <Axman6> so you could have foo :: (Num a, Integral a) => a -> Bool -> a or something, meaning that a must be a Num and an Integral
23:53:34 <FunctorSalad_> what is this finger stuff I keep hearing about on here? ;)
23:53:34 <monochrom> Err
23:53:39 <monochrom> No one must always need punctuations otherwise you're unparsable don't you think
23:53:45 <monochrom> (To make the point better)
23:53:48 <Gracenotes> pumpkin hey jimbob, get me done one of them fingerdags from Walmart, I'm hungry!
23:54:46 <harovali> Axman6: (Num a, Integral a)  is kind of type union?
23:55:04 <mmorrow> pumpkin: while yer there, gitme a lawnchair and a shotgun too
23:55:08 <harovali> Axman6: sorry, intersection
23:55:15 <Axman6> yeah, i guess so
23:55:27 <Axman6> just says that a must implement the Num and Integral classes
23:55:35 <harovali> Axman6: where can I look it up?
23:55:41 <FunctorSalad_> harovali: you can read it as "if these constraints are satisfied, then (=>) this function has the following type:"
23:55:42 <Axman6> look what up?
23:55:44 * monochrom does not understand why people do not think like "what does the syntax (True,1) stand for?" but like "what does ( mean? what does T mean? what does r mean? ..."
23:55:45 <wli> pumpkin: About all I can see it getting used for is to compress the Set String values in the dictionary.
23:56:13 <pumpkin> wli: that author I linked to has written a fair amount on how to use DAWGs for anagrams and scrabble, but your input word is just a set of letters... given the set of letters and a DAWG representing your dictionary, you jump into all nodes (not very many due to the shared structure) for your first letter, and look at their neighbors... cut out all the ones that you don't have in your input set, and walk
23:56:38 <Gracenotes> DAWGs can be pretty effing huge iirc too.
23:56:49 <pumpkin> Gracenotes: they're smaller than most other things
23:56:59 <harovali> FunctorSalad_: so, let's say it's kind of pattern matching, but for types?
23:57:19 <Gracenotes> well, the number of nodes, but the complexity of the edges can be whooooa
23:57:20 <pumpkin> Gracenotes: http://dotnetperls.com/Content/Directed-Acyclic-Word-Graph.aspx more info (and check that site for other articles on it)
23:57:39 <FunctorSalad_> harovali: no sorry I was ambiguous there, you can't have multiple => clauses
23:57:44 <pumpkin> Gracenotes: overall though, you can store a big dictionary in very little space compared to naive representations or even compared to prefix or suffix tries
23:57:57 <pumpkin> and you get prefix and suffix matches for free
23:57:58 <Gracenotes> yes quite true.
23:58:13 <pumpkin> it's an attractive structure, but rather difficult to implement
23:58:16 <FunctorSalad_> harovali: it's a constraint that has to be satisfied to apply the function
23:58:20 <Axman6> harovali: it's just a constraint on the types that can be used
23:58:37 <harovali> FunctorSalad_: Axman6: thanks
23:59:03 <wli> pumpkin: I have Map (MultiSet Char) (Set String) as the dictionary, and basically just nondeterministically decompose a MultiSet Char as an ascending sequence of MultiSet Char dictionary keys according to the Ord instance on MultiSet Char to generate anagrams.
23:59:34 <pumpkin> wli: yeah, but that's bound to be exponential isn't it?
23:59:39 <pumpkin> in your input string
