00:14:18 <chrisdone> :t mconcat
00:14:19 <lambdabot> forall a. (Monoid a) => [a] -> a
00:14:22 <chrisdone> :t mconcat
00:14:23 <lambdabot> forall a. (Monoid a) => [a] -> a
00:14:27 <chrisdone> :t foldr mconcat
00:14:28 <lambdabot> forall b. (Monoid b) => b -> [[b -> b]] -> b
00:15:13 <chrisdone> :t mappend
00:15:14 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:15:23 <chrisdone> :t foldr mappend
00:15:24 <lambdabot> forall a. (Monoid a) => a -> [a] -> a
00:15:40 <chrisdone> could foldr mappend be considered a backtracking function?
00:16:52 <chrisdone> :t mplus
00:16:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
00:16:58 <chrisdone> or mplus?
00:19:02 <chrisdone> :t mplus id
00:19:03 <lambdabot> forall a. (MonadPlus ((->) a)) => (a -> a) -> a -> a
00:22:21 <chrisdone> just reading the LogicT paper, and it's talking about MonadPlus as a simple non-deterministic computation. I think I did something similar a while ago to try to place a word around another word in my wordcloud thing: http://github.com/chrisdone/wordcloud/blob/master/Graphics/WordCloud.hs#L121 not sure if that counts thought
00:22:40 <dolio> Backtracking would, I think, be considered an implementation technique for nondeterminism.
00:23:13 <dolio> Although what qualifies might be kind of vague.
00:47:41 * hackagebot upload: time-extras 1.1.4 - Data instances for the time package (AshleyYakeley)
00:55:37 <lowlycoder> i don't understand haskell; but I just wnat to understand haskell's type inference algorithm; is there a godo paper (with part on how to implement it) available somewhere?
00:56:36 <ivanm> it's based on the Hindley-Milner type system
00:56:40 <ivanm> so maybe look up their papers
00:57:06 <Lemmih> lowlycoder: http://en.wikipedia.org/wiki/Type_inference#Hindley-Milner_type_inference_algorithm
00:58:05 <lowlycoder> nice; thanks
00:58:54 <Axman6> lowlycoder: i thinnk understanding it would be easier if you understood haskell somewhat though :)
00:59:08 <azathoth99> so could one progam a world of warcraft clone in haskell but do it beter since haskell is so powerful?
00:59:49 <Axman6> it's not impossible, but unlikely. haskell's still not at the low level speec that C and C++ provide to game developers yet
01:00:17 <ivanm> azathoth99: sure, if you spend enough time on it
01:00:23 <ivanm> you could also do the same in Assembly
01:00:26 <ivanm> doesn't mean you _should_
01:00:29 <azathoth99> can oen program stuff to stay in ram for speeed?
01:00:54 <Axman6> that's generally how programming works :\
01:01:17 <dolio> @go well-typed programs can't go wrong
01:01:17 <lambdabot> Maybe you meant: google googleit do
01:01:18 <ivanm> azathoth99: depending on how much RAM you have, yes
01:01:21 <Lemmih> azathoth99: Languages are to programmers as paint is to artists. You can easily write horrible programs in Haskell.
01:01:24 <azathoth99> gosh I used 500m ram pc with archlinux, and it was swapping all over until i made opera take less mem for cache and disbaled java scipt , then the 30 porn page i had open not cause box to crawl
01:01:28 <ivanm> @google well-typed programs can't go wrong
01:01:30 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/blame/blame.pdf
01:01:30 <lambdabot> Title: Well-typed programs can’t be blamed
01:01:49 <ivanm> azathoth99: too much information IMHO
01:01:52 <azathoth99> I saw on www.prevayler.org site that 512G ram box are around now
01:01:57 <Axman6> @where ops
01:01:58 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
01:02:03 <ivanm> yes, for _supercomputers_ and _servers_
01:02:08 <ivanm> not for home PCs
01:02:09 --- mode: ChanServ set +o dcoutts
01:02:20 <azathoth99> happstack is really cool looking
01:04:33 <azathoth99> anyone here dev a game in haskell?
01:04:38 <azathoth99> even simple one?
01:04:42 <ivanm> azathoth99: see the games section on hackage
01:04:45 <ivanm> @where hackage
01:04:45 <lambdabot> http://hackage.haskell.org/package/
01:04:46 <azathoth99> but with sound and graphic elements?
01:05:27 <merehap> yes indeed
01:05:37 * ivanm has an ongoing game called "guess the next generated Partial Latin Square"... :p
01:05:43 <ivanm> *game project
01:06:11 <Axman6> man, applicative style is awesome
01:06:15 <ivanm> wow, you can tell yi is really advanced... it even has highlighting support for _whitespace_!
01:06:23 --- mode: ChanServ set -o dcoutts
01:06:38 <ivanm> Axman6: eh, never really had much of a reason to even learn/use it to be able to become a fan
01:07:55 <Axman6> it's really nice for things like parsers, were you can say getFoo = Foo <$> getBar <*> getBaz, instead of liftM2 Foo getBar getBaz (which is a little more ugly
01:08:38 <dibblego> we did that in BFPG
01:09:49 <dolio> Lots of other good stuff.
01:10:02 <dolio> Con <$ string "Con"
01:10:29 <Axman6> dolio: that'[s like fmap (const Con) (string "Con")?
01:10:38 <dolio> Foo <$> parseBar <* parseSep <*> parseBaz
01:10:44 <dolio> Yes.
01:11:07 <Axman6> what's that do?
01:11:25 <dibblego> ignores the separator when applying to the Foo constructor
01:11:37 <dolio> It parses something like "bar , baz", where you want the bar and the baz in the Foo constructor, but not the comma.
01:11:48 <Axman6> ah, how nice
01:12:14 <Gracenotes> the associativity and precedence of that expression is somewhat confusing
01:12:34 <dibblego> Scala makes you use parentheses
01:12:34 <Gracenotes> the ops therein
01:13:25 <dolio> I think it's all left associative.
01:13:32 <dolio> Like you'd expect function application to be.
01:13:54 <dolio> ((Foo <$> bar) <* baz) <*> quux
01:14:38 <copumpkin> Gracenotes: confusing?
01:16:16 <Dashkal> Anybody familiar with Graphics.X11?  I'm getting a strange error: http://paste.pocoo.org/show/159066/
01:17:09 <Gracenotes> copumpkin: you might even say confuzzling
01:17:14 <copumpkin> lol
01:18:30 <Gracenotes> the intuitive grouping happens to match the paren-free associativity. but assuming precedence can be nasty. if (x & 1 == 0)
01:25:10 <HugoDaniel> how do i handle exceptions ?
01:25:40 <Jedai> HugoDaniel: with Control.Exception
01:25:41 <Axman6> using Control.Exception i think
01:25:47 <HugoDaniel> i find it hard to see the point in having exceptions in haskell :(
01:26:07 <Cale> HugoDaniel: What type of exception?
01:26:08 <Jedai> HugoDaniel: well you can only catch them in IO
01:26:15 * copumpkin coughs
01:26:29 <nooob> Hi.. I wrote a function right now, which seems to badly written.. I am not sure how to make it more compact but I feel it should be done.. could you please look at it? http://pastebin.com/dc46be7d  it has ~3 lines
01:26:33 <Jedai> HugoDaniel: but that's still useful to handle exceptional conditions
01:26:52 <azathoth99> has anyone written a database in haskell?
01:27:08 <Axman6> azathoth99: happstack has a sort of database built in
01:27:09 <azathoth99> not a driver for postgresql but a replacement?
01:27:10 <Jedai> HugoDaniel: as opposed as foreseeable failure which should rather be handled at the pure code level with Maybe and or Either
01:27:11 <Cale> Dashkal: Looks like you need a fromIntegral to convert from CLong to Word32
01:27:20 <azathoth99> macid?
01:27:22 <Cale> Dashkal: (sorry, your paste took a long time to load here)
01:27:27 <Axman6> :t find
01:27:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:27:31 <copumpkin> nooob: it looks like find
01:27:40 <Axman6> nooob: looks like you have reinvented find :)
01:27:48 <Axman6> @src find
01:27:48 <lambdabot> find p          = listToMaybe . filter p
01:28:14 <nooob> ha
01:28:23 <nooob> there is thing for that?
01:28:26 <nooob> :)
01:28:31 <Axman6> of course :)
01:28:33 <Cale> find ((\Module m c) -> m == mname)
01:28:40 <nooob> heeeeeee
01:28:42 <nooob> :) thx
01:31:28 <azathoth99> anyone using haskell not bash as login shell?
01:31:50 <merehap> wow, after what felt like running an hour of its dependencies through yaourt, yi decides to fail to build, naturally
01:32:02 <merehap> guess I'll be sticking with vi for now...
01:32:25 <azathoth99> vim
01:32:34 <luite> merehap: what was the error, perhaps it's easy to fix?
01:32:51 <merehap> looks relatively easy to fix, duplicate instances
01:33:04 <merehap> in the Yi Prelude
01:33:28 <lpsmith> egads,   I was hoping to read about lzma internals,  and instead found the most moronic compression benchmarks I've ever seen.
01:34:00 <elly> lpsmith: oh?
01:34:01 <copumpkin> lol
01:34:05 <Cale> merehap: yaourt?
01:34:15 <Cale> merehap: Not cabal install?
01:34:16 <merehap> the arch wrapper for pacman
01:34:24 <merehap> no, that failed previously
01:34:26 <merehap> might work now
01:34:26 <Cale> hmm
01:34:32 <merehap> i'll check
01:34:43 <lpsmith> Yeah,  some kid thinking it sucks after turning it up to maximum compression and running it on 512M of zeros,  and 100 some megabytes of JPGs
01:34:47 <HugoDaniel> azathoth99: why dont you use postgresql or mysql ?
01:35:03 <HugoDaniel> the exception im having: *** Exception: ldapSimpleBind: LDAPException LdapInvalidCredentials(49): Invalid credentials
01:35:14 <HugoDaniel> i dont see the point in exceptions in haskell
01:35:17 <lpsmith> Because it took a lot of time and it didn't compress very well.
01:35:19 <merehap> Cale: there is a version problem with Template Haskell when installing through cabal
01:35:23 <elly> how did LZMA suck on 512M of zeroes?
01:35:31 <HugoDaniel> i like the Maybe monad, and the Either datatype
01:35:33 <azathoth99> well then I have to learn postgresql.
01:35:42 <HugoDaniel> exceptions can go awfully wrong :(
01:35:47 <azathoth99> I was hoping to learn a programming language and simply use its data structures.
01:35:55 <lpsmith> It took a long time and the result was only 75k,  whereas bzip was much shorter and took 402 bytes
01:36:07 <lpsmith> (shorter in terms of cpu time)
01:36:12 <HugoDaniel> azathoth99: then go for haskell :)
01:36:17 <Cale> HugoDaniel: Think of it as a big Either mushed into IO
01:36:40 <HugoDaniel> and is there a way to know what exceptions a given module can throw ?
01:36:50 <HugoDaniel> without looking at the source code :P
01:37:16 <copumpkin> nope
01:37:24 <merehap> HugoDaniel: write a giant quicktest test and run it indefinitely on the code. see what crash you get
01:37:25 <copumpkin> it's ugly
01:37:29 <lpsmith> but who cares?  Why the heck are you compressing zeros?  it's a meaningless benchmark.   And complaining that it's slow when you tell the program to spend as much time as it wants, basically, trying to compress your bits,  ughh
01:37:33 <HugoDaniel> :(
01:37:37 <lpsmith> Or compressing jpegs.  Great move there
01:37:53 <copumpkin> lpsmith: should've tried compressing random data too, while they were at it
01:38:47 <lpsmith> So the one meaningful benchmark,  where it produces 1.5M of text,  whereas bzip produced 2.5M versus gzips 4.0M,  he basically ignores that
01:39:06 <copumpkin> them zeros be important man
01:39:16 <lpsmith> lol
01:39:20 <merehap> copumpkin: my awesome compression algorithm almost always compresses random data by a byte except about 1% of the time where it doubles the file size :)
01:39:40 <lpsmith> I should have been to bed hours ago.  Oh well
01:39:47 <Cale> HugoDaniel: Well, there is a checked exceptions library, but I guess part of the point of that sort of exception is that you can throw new exceptions without affecting the types.
01:40:16 <HugoDaniel> :(
01:40:45 <HugoDaniel> i just dont like them... as much as i didn't like java always requiring me to catch all the exceptions
01:40:58 <HugoDaniel> they just would end up wrapped in empty try catches
01:41:18 <Cale> Well, there's no point in writing an empty try or catch here
01:41:39 <Cale> You only catch when there is a purpose in catching the exception
01:41:45 <HugoDaniel> but this way is really awfull wrong :(
01:41:53 <HugoDaniel> because the code exits
01:41:59 <HugoDaniel> and things can go very unstable
01:42:11 <Cale> Would you prefer that it go into an infinite loop? ;)
01:42:24 <HugoDaniel> i would prefer to have explicit type for this
01:42:26 <HugoDaniel> like maybe
01:42:29 <HugoDaniel> or either
01:42:34 <Cale> Okay
01:42:54 <Cale> It's easy enough to write something that catches any exception and turns IO t into IO (Maybe t)
01:42:59 <HugoDaniel> yes, i can write it around the exception, but that still requires me to audit all the code in the modules that i import
01:43:06 <HugoDaniel> ah ok
01:43:08 <HugoDaniel> in that case :)
01:44:02 <HugoDaniel> ill just wrap all functions that are not mine and require IO with it :P
01:44:38 <Cale> In fact, that's practically the type of try
01:44:51 <Cale> try :: Exception e => IO a -> IO (Either e a)
01:45:02 <Cale> If e = SomeException, then you'll catch everything.
01:45:05 <merehap> HugoDaniel: or require a proof from the library author with respect to pattern match safety :)
01:45:24 <Cale> There's also spoon
01:45:30 <HugoDaniel> eheh yes
01:46:06 <Cale> spoon is a slightly unsafe library which catches exceptions thrown from pure code and turns them into Maybe
01:47:16 <PeakerWork> RMonad is more intricate than I thought...
01:47:33 <HugoDaniel> "slightly unsafe" :)
01:47:37 <Cale> But exceptions aren't that bad, just think of them as an additional control mechanism built into the IO monad.
01:47:56 <PeakerWork> I was on the train with no wifi and wanted to toy with it -- so I decided to write it (couldn't download) and its not trivial at all :)
01:48:00 <Cale> Well, it's slightly unsafe in the sense that it kind of breaks equational reasoning.
01:48:07 <HugoDaniel> that can make your code exit :P
01:48:38 <copumpkin> PeakerWork: once you know the trick it isn't that bad
01:48:48 <copumpkin> PeakerWork: but it's not terribly pleasant to work with
01:48:49 <HugoDaniel> i guess ghc warnings would be nice
01:48:55 <PeakerWork> copumpkin: Well, the AsMonad wrapper is another trick
01:49:02 <HugoDaniel> whenever an exception could pop up
01:49:21 <PeakerWork> copumpkin: I'm still not entirely sure how it works - in the sense that it allows intermediate unrestricted monads
01:49:58 <PeakerWork> copumpkin: fmap (*) . embed $ Set.singleton 1
01:50:08 <Cale> RMonad is probably the closest thing to a nice solution to the restricted monad problem I've seen yet.
01:50:12 <PeakerWork> liftM, actually, because AsMonad is missing Functor/Applicative instances
01:50:23 <copumpkin> but it's not too pretty still
01:50:40 <PeakerWork> Cale, copumpkin: Can you explain what happens when you do something like: fmap (*) . embed $ Set.singleton 1
01:50:42 <sinelaw> PeakerWork, hey
01:50:44 <PeakerWork> sinelaw: hey
01:50:51 <copumpkin> the case to bring the context into scope is annoying
01:50:54 <PeakerWork> Cale, copumpkin: It seems to create a Set of non-Ords
01:50:56 <Cale> We really need a mechanism to avoid having to write Suitable constraints.
01:51:10 <copumpkin> PeakerWork: embed?
01:51:11 <sinelaw> @type embed
01:51:12 <lambdabot> Not in scope: `embed'
01:51:17 <PeakerWork> copumpkin: the AsMonad thing
01:52:16 <PeakerWork> now, unEmbed refuses (correctly) to unpack it into a Set of non-Ords, but I'm wondering what happens to these intermediates
01:52:18 <Cale> PeakerWork: That's still in the AsMonad monad, isn't it?
01:52:23 <PeakerWork> Cale: Yeah
01:52:34 <Cale> PeakerWork: So it's effectively representing the fmap as data.
01:52:46 <Cale> Look at the definition of AsMonad
01:53:18 <Cale> It has explicit constructors for Bind and Return
01:53:21 <PeakerWork> ah, unEmbed does a sort of big simplification
01:53:25 <copumpkin> I've gotta run, but can talk more when I get back
01:53:40 <Cale> PeakerWork: It's like an evaluator for abstract monad syntax :)
01:53:46 <PeakerWork> Cale: cool! :)
01:54:09 <dibblego> is there a canonical method for providing example usage code for a cabal package (such that it comes up on haddock)?
01:54:27 <dcoutts> dibblego: yes, put it in the haddock docs
01:54:47 <dibblego> just surrounded by @ ?
01:54:56 <dcoutts> if you want it in the haddock docs you'd better put it in the haddock docs :-)
01:54:58 <dibblego> er I meant hackage not haddock
01:55:40 <dcoutts> well hackage doesn't like to any other docs directly, unless you host them on your packages own homepage, which of course hackage links to
01:55:48 <dcoutts> like/link
02:09:49 <mistermattaway> hi guys, forgive me for using pastebin, but hpaste is down. I have some code from Real World Haskell that I have a question about: http://pastebin.com/m2b59602d
02:10:20 <mistermattaway> It has to do with the Maybe type. could someone explain the usage of the 'Just', and 'Nothing' value constructors in that code snippet?
02:10:57 <ivanm> mistermattaway: if the balance is less than the reserve, then Nothing is returned
02:11:17 <ivanm> if there is sufficient money, then the value is returned wrapped in Just
02:11:35 <ivanm> presumably, this is so that no loan is made if there are insufficient funds for the loan
02:12:47 <mistermattaway> I understand the flow of the code, but I am not sure why the maybe type is being used
02:13:07 <ivanm> mistermattaway: OK, how else would you indicate "no, we can't make a loan"?
02:13:22 <ivanm> as well as returning the newbalance in the account if and only if a new loan is approved
02:14:12 <mistermattaway> so the maybe type is being used to observe failure instead of having the program crash
02:14:25 <Twey> mistermattaway: Hint: paste.lisp.org
02:14:38 <Twey> Doesn't mangle your Unicode ;)
02:14:52 <mistermattaway> thank you twey
02:15:36 <mistermattaway> I'm just beginning to wrap my head around the usefulness of the maybe type
02:15:49 <Twey> mistermattaway: Are you a programmer of other languages?
02:16:07 <mistermattaway> Yes, very very green with Haskell
02:16:14 <Twey> Which other languages?
02:16:19 <mistermattaway> C++
02:16:40 <Twey> Then Maybe is used wherever you might be tempted to return a null pointer in C++
02:17:02 <PeakerWork> s/return/use
02:17:22 <Twey> Mm.
02:18:02 <Twey> In addition, it has some handy features for chaining a series of computations that rely on the value being present.
02:19:48 <mistermattaway> thanks guys
02:24:12 <mistermattaway> also, I'd write the type signature of that function I posted as lend :: Int -> Int -> Maybe a?
02:26:14 <mistermattaway> rather, Maybe Int
02:27:30 <merehap> try ":t lend" in ghci to find out
02:27:55 <PeakerWork> mistermattaway: "Maybe a" would mean that it can return any "a" at all
02:28:17 <PeakerWork> mistermattaway: which means the values you put in "Just" can be any type at all.. is that true? Can a String, for example, be in a Just?
02:28:29 <mistermattaway> gotcha, my second idea was the right one
02:33:38 <mistermattaway> I like that you can tell almost exactly what the function does by looking at the type signature
02:34:12 <HugoDaniel> i have a string "this is a test" how do i add the char '%' to the start and ending of each word ?
02:34:14 <PeakerWork> mistermattaway: yeah, its an awesome feature of combining genericity (maximized polymorphism) with purity (no effects in the function that you don't know about)
02:34:15 <merehap> mistermattaway: one of my favorite features of Haskell, made possible by lack of side effects
02:34:22 <Twey> Hear hear
02:34:23 <PeakerWork> merehap: and genericity
02:34:26 <HugoDaniel> lik "%this% %is% %a% %test%" ?
02:34:31 <merehap> indeed
02:34:50 <PeakerWork> @let inWords f = unwords . f . words
02:34:51 <lambdabot>  Defined.
02:35:03 <HugoDaniel> :D
02:35:09 <PeakerWork> > inWords (('%' :) . (++"%")) "this is a test"
02:35:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
02:35:10 <lambdabot>         against inferred ty...
02:35:21 <PeakerWork> @let onWords = inwords . map
02:35:22 <lambdabot>  <local>:6:10: Not in scope: `inwords'
02:35:25 <PeakerWork> @let onWords = inWords . map
02:35:26 <lambdabot>  Defined.
02:35:34 <PeakerWork> > onWords (("%"++) . (++"%")) "this is a test"
02:35:36 <lambdabot>   "%this% %is% %a% %test%"
02:35:50 <HugoDaniel> :D
02:35:55 <HugoDaniel> great
02:36:04 <HugoDaniel> elegant and beautifull
02:36:07 <PeakerWork> :-)
02:36:15 <merehap> ok, what's the next problem? I'll beat PeakerWork this time...
02:36:20 <merehap> :)
02:36:25 <HugoDaniel> :D
02:36:46 <HugoDaniel> this is for sql string matching
02:39:21 <PeakerWork> @src liftM2
02:39:21 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:47:49 <ivanm> preflex: seen malcolmw
02:47:50 <preflex>  malcolmw was last seen on #haskell 14 days, 17 minutes and 1 second ago, saying: fasta: well, thanks for walking through it with me this far
02:48:25 <malcolmw> ivanm: I just left a message for you with lambdabot
02:48:36 <ivanm> yes, I noticed ;-)
02:48:43 <ivanm> you could have just told me rather than @tell me ;-)
02:48:52 <malcolmw> wasn't sure if you were around
02:48:59 <ivanm> preflex: seen ivanm
02:48:59 <preflex>  ivanm was last seen on #haskell 16 seconds ago, saying: you could have just told me rather than @tell me ;-)
02:49:00 <ivanm> ;-)
02:49:03 <ivanm> hmmm.... your bytestring parser looks tempting...
02:49:09 <ivanm> but I think I'll stick with plain string
02:49:09 * malcolmw forgets all the lambdabot commands
02:50:22 <Raynes> If lambdabot only had one command, I think I'd want it to be @pl
02:52:09 <Azstal> I'd want it to be @.
02:52:16 <Azstal> @. . . . . .
02:52:17 <lambdabot> Plugin `compose' failed with: Unknown command: "Not"
02:52:26 <ivanm> Azstal: even though it'd be useless on its own?
02:58:57 <ttt--_> hi, does anyone know of any work that represents SQL expressions as haskell data structures?
02:59:15 <mux> doesn't HaskellDB do just that?
02:59:22 <Twey> Don't most of the existing SQL libraries do that?
03:00:13 <ttt--_> I dont know.. I'll look at that, thanks
03:02:43 <ttt--_> http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB-Sql.html
03:02:45 <ttt--_> it does
03:07:26 <merijn> Is it possible to define a typeclass to be a superset of one or more other typeclasses?
03:07:57 <Twey> class (Foo a, Bar a) => Baz a where …
03:08:27 <merijn> Nice, thanks.
03:33:17 <ketil> Haskell as the fixpoint of programming language development? http://phxbsd.com/langs.jpg
03:34:05 <pozic> How can I compute a hash for a file in Haskell? I don't really care about which one, as long as it is at least as good as md5.
03:34:57 <dibblego> pozic, there are MD5 and SHA packages on hackage; they both work well
03:35:52 <pozic> dibblego: but they work on bytestrings.
03:36:04 <pozic> dibblego: I have not seen a function taking a filepath.
03:36:11 <dibblego> right, you can read a file into a ByteString
03:36:42 <Lemmih> pozic: Enter the world of function composition. (:
03:36:53 <pozic> dibblego: yes, I know, still, I was weary of stack overflows/memory overflows, etc.
03:37:11 <dibblego> pozic, as we all are, but I'm not sure why you even mention it
03:37:31 <pozic> That is, I want it to work for 4GB files.
03:37:44 <dibblego> why wouldn't it?
03:37:46 <pozic> In theory it should work within constant space.
03:37:55 <pozic> Because the libraries might suck.
03:38:05 <pozic> If they don't, then great.
03:40:30 <mux> use lazy bytestrings
03:41:55 <dibblego> the hackage libraries do
03:41:59 <ivanm> preflex: seen sinelaw
03:42:00 <preflex>  sinelaw was last seen on #haskell 1 hour, 50 minutes and 49 seconds ago, saying: @type embed
03:42:14 <sinelaw> ivanm, i'm here
03:42:20 <sinelaw> saw your message too
03:42:29 <ivanm> OK, waddaya think?
03:42:50 <sinelaw> the short answer is that whatever will allow me to get access to those attributes is ok
03:43:14 <sinelaw> your experience is an order of magnitude larger than mine, so however you do it is ok with me :)
03:43:33 <ivanm> heh
03:45:29 <Twey> Haha, I've seen that image about three times in the past couple of days
03:45:54 <Twey> I bet when I get back to college my computing teacher will go, ‘hey, James, I saw this cool image online; what do you think?’
03:46:19 <lpsmith> what's a good way to navigate haddock documentation?   There is documentation all over /usr/local/share/doc/
03:46:29 <Twey> lpsmith: Start at the index.html page?
03:46:49 <ivanm> yup
03:47:39 <lpsmith> but there is an index file for each package
03:47:54 <Twey> lpsmith: Yep
03:47:59 <lpsmith> can you generate an index file for all packages easily?
03:48:10 <Twey> Hm
03:48:14 <Twey> Oh, I see
03:48:19 <Twey> Pass on that…
03:48:26 <ivanm> there's a python hack someone once made to do that...
03:48:33 <ivanm> or else IIRC cabal-install 0.8 does that for you
03:48:43 <lpsmith> I don't think so
03:48:52 <lpsmith> Well, not automagically anyway
03:48:59 <lpsmith> maybe there is a way to do it
03:49:22 <pozic> Couldn't match expected type `Data.ByteString.Internal.ByteString' against inferred type `BS.ByteString'
03:49:31 <Saizan> lpsmith: for those there there is a global index
03:49:42 <pozic> I imported Data.ByteString.Lazy qualified as BS.
03:49:58 <pozic> The md5sum function requires a "ByteString".
03:50:01 <lpsmith> saizan:  global index?
03:50:06 <ivanm> pozic: looks like you're using two different versions of bytesting
03:50:22 <ivanm> what does "ghc-pkg list bytestring" say?
03:50:26 <Saizan> lpsmith: /usr/local/share/doc/ghc/libraries/index.html
03:50:52 <pozic> ivanm: bytestring-0.9.1.4
03:50:52 <Saizan> pozic: md5sum wants the strict ones.
03:51:13 <pozic> Saizan: right, so that will take a lot of memory.
03:51:24 <pozic> Is there anything that does work lazily?
03:51:25 <ivanm> pozic: OK, so it's not a clash then...
03:51:38 <lpsmith> Saizan,  right,  but that doesn't have links to other packages I've installed globally
03:51:38 <mux> it's not really clever to use strict bytestrings for computing a hash
03:51:42 <ivanm> pozic: sure you're not using lazy bytestrings when a library wants strict or vice versa?
03:51:58 <ivanm> mux: yeah, since you need to compress the entire thing
03:52:03 <pozic> ivanm: I want to compute the hash of >4GB files.
03:52:09 <ivanm> *shudder*
03:52:24 <ivanm> well, its obviously possible, since people hash ISOs, etc.
03:52:38 * hackagebot upload: control-monad-exception 0.8.0.3 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
03:52:40 * hackagebot upload: kangaroo 0.1.0 - Random access binary combinator parser. (StephenTetley)
03:52:44 <pozic> I can also just read the first 1000 bytes of the files and use that, I guess.
03:52:50 <Saizan> lpsmith: no, for those you can make the new cabal-install regenerate an index everytime it installs a package by setting the right option in the ~/.cabal/config file
03:53:08 <pozic> But then if the headers are the same or something similar it will still blow up.
03:53:09 <lpsmith> ahh...
03:53:09 <ivanm> that's a weird looking package, and I fail to see the relevance of the name...
03:53:12 <Saizan> documentation: True
03:53:13 <Saizan> doc-index-file: $datadir/doc/index.html
03:53:29 <lpsmith> that's what i've been looking for
03:53:38 * hackagebot upload: control-monad-exception-mtl 0.8.0.3 - MTL instances for the EMT exceptions monad transformer (PepeIborra)
03:53:52 <lpsmith> is there a way to have cabal install manually regenerate the index?
03:53:57 <PeakerWork> @hackage control-monad-exception
03:53:57 <lambdabot> http://hackage.haskell.org/package/control-monad-exception
03:54:43 * hackagebot upload: control-monad-exception-monadsfd 0.8.0.3 - Monads-fd instances for the EMT exceptions monad transformer (PepeIborra)
03:55:19 <Saizan> lpsmith: no
03:55:45 * hackagebot upload: hurdle 0.2.0 - Extract function names from Windows DLLs. (StephenTetley)
03:55:47 * hackagebot upload: control-monad-exception-monadstf 0.8.0.3 - Monads-tf instances for the EMT exceptions monad transformer (PepeIborra)
03:58:47 <mreh> > foldr1 (++) $ replicate 2 [1..3]
03:58:48 <lambdabot>   [1,2,3,1,2,3]
03:58:49 <dcoutts> lpsmith: it's regenerated each time a new package is installed I think, right Saizan ?
03:58:59 <pozic> What does hGet do when you ask more bytes than available?
03:59:10 <mreh> > [1,2,3] >> [1,2]
03:59:10 <lambdabot>   [1,2,1,2,1,2]
03:59:31 <ivanm> pozic: probably a crash
04:00:04 <mreh> how to cycle a list n times?
04:00:24 <Lemmih> pozic: Doesn't it block until the data is available?
04:00:40 <mreh> any better suggestions, I thought those two weren't particularly idiomatic
04:01:14 <ivanm> mreh: concat . replicate ?
04:01:34 <mreh> of course, cheers ivanm
04:01:42 <ivanm> no worries
04:02:03 <pozic> Lemmih: I just read the source, I think it doesn't block and just returns whatever is available.
04:02:15 <pozic> This stuff should be in the documentation.
04:02:31 <Twey> fmap concat . replicate
04:02:49 <mreh> :t concat . replicate
04:02:50 <lambdabot>     Couldn't match expected type `[[a]]'
04:02:50 <lambdabot>            against inferred type `a1 -> [a1]'
04:02:50 <lambdabot>     Probable cause: `replicate' is applied to too few arguments
04:02:59 <Twey> :t fmap concat . replicate
04:03:00 <lambdabot> forall a. Int -> [a] -> [a]
04:03:21 <mreh> :t concat
04:03:22 <lambdabot> forall a. [[a]] -> [a]
04:03:31 <Twey> > (fmap concat . replicate) 3 "hi"
04:03:33 <lambdabot>   "hihihi"
04:03:35 <Lemmih> pozic: Which hGet is this?
04:03:45 <ivanm> does anyone have a suggestion on how I can term a "generic" DotGraph representation that doesn't care about ordering?
04:03:46 <pozic> Lemmih: this one came from the Lazy variant.
04:03:53 <mreh> I don't understand why concat . replicate doesn't work
04:04:04 <mreh> :t concat . replicate 3
04:04:04 <pozic> Lemmih: I expect the strict byte strings version to behave the same.
04:04:05 <lambdabot> forall a. [a] -> [a]
04:04:07 <mreh> right
04:04:12 <Axman6> > replicate 3
04:04:13 <lambdabot>   {()->[(),(),()]}
04:04:20 <ivanm> > (concat . replicate 3) "hi"
04:04:21 <lambdabot>   "hihihi"
04:04:23 <Axman6> > replicate 3 2
04:04:25 <lambdabot>   [2,2,2]
04:04:27 <ivanm> mreh: ^^ get the types right ;-)
04:04:44 <Saizan_> lpsmith: worked?
04:04:47 <mreh> lambdabot can show functions!
04:05:03 <Twey> Well, parts of them
04:05:05 <Lemmih> pozic: I'm quite sure it blocks.
04:05:08 <lpsmith> I'm working on it,  just in the process of cleaning 6.12.0 off my system
04:05:28 <Lemmih> pozic: It should behave just like System.IO.hPutBuf.
04:05:53 <Twey> > show (+ 1) == show (\x -> if abs x < 5 then x + 1 else x + 15)
04:05:54 <lambdabot>   True
04:06:01 <Lemmih> pozic: hGet is different from hGetNonBlocking.
04:06:36 <Lemmih> pozic: Oops, I meant System.hGetBuf, of course.
04:06:41 <Saizan_> lpsmith: the index is updated only for user installs, since there wasn't a consensus on how to manage an updating global index
04:06:53 <Saizan_> lpsmith: though it contains all the non-hidden libs
04:07:19 <lpsmith> aye,  it works
04:08:24 <Saizan_> nice
04:08:41 <Lemmih> pozic: This describes the behavior in more detail: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/System-IO.html#v%3AhGetBuf
04:11:11 <zenzike> I'm trying to load some information from a binary file (SGI format), and have written a Binary interface for it. part of my code is eating up a lot of time according to the profiler, and it's not obvious to me if it can be improved, any suggestions?  here's the code in question: http://codepad.org/43WHBRkM
04:12:57 <Saizan_> zenzike: how big is streak going to be?
04:13:13 <zenzike> it's at most 256 i believe
04:14:10 <zenzike> (limited by the size of a byte ... oh, minus 1 bit, so at most 128, but it's usually going to be a lot less than that)
04:14:21 <zenzike> I'm wondering if I'mdoing something bad with the ++ in the return
04:14:43 <Saizan_> well xs ++ ys takes O(length xs)
04:15:03 <Saizan_> though overall it should be linear
04:15:15 <Saizan_> since you're nesting it right-associatively
04:15:45 <Saizan_> how do you run your Get parser btw?
04:16:07 <zenzike> I'm using runGet (getRowN getWord8)
04:17:15 <zenzike> I tried to make it faster by replacing ++ with :, and using concat on the resulting Get [[a]], but that didn't seem to improve anything
04:18:02 <Saizan_> it's basically already doing concat
04:18:28 <Saizan_> maybe you should put {-# SCC .. #-} annotations inside that function to pin down the source further
04:18:50 <zenzike> i looked at those briefly, and got a bit scared since I've never used them before
04:19:09 <lpsmith> thanks Saizan!
04:19:28 <zenzike> maybe I ought to give them a bash though. seems like I just sprinkle wherever I want to know how often an expression is evaluated right?
04:19:37 <Saizan_> zenzike: btw, are you compiling with -O2 ?
04:19:37 <pozic> Lemmih: thanks, but the ByteString documentation should say that. Just because it depends on some other function is no reason to leave it out.
04:19:52 <Saizan_> zenzike: and how much it takes
04:20:00 <Lemmih> pozic: Yes, it should. Send a patch (:
04:20:04 <Saizan_> zenzike: though they also affect optimizations
04:20:05 <zenzike> oh, nope, I'm not. I'm just using -Wall and profiling
04:20:05 <pozic> That said, my program is now running :)
04:20:44 <Saizan_> zenzike: at least -O is a must if you want performance, but we usually go with -O2
04:21:39 <zenzike> thanks. I've just tried it with optimszations on; the cost centre is till 42% on that function
04:22:23 <zenzike> obviously that's where most of the work is being done, but I don't expect it to take a few seconds to decode an image that's only 1024*1024
04:22:34 <pozic> I feel like a web-developer now ;) (IO bound stuff)
04:23:39 <Twey> pozic: Oh dear
04:24:00 <Twey> Don't worry — use some functional GUI toolkit for a bit.  The feeling will soon go away.  ;)
04:25:10 <pozic> Meh, out of memory and not a single reason in sight for that to happen.
04:26:45 <zenzike> Saizan_: I've tried to add some SCC's but it isn't compiling. I must be doing something silly, but I'm not familiar with what's allowed, got a suggestion?  http://codepad.org/ZDR64wO9
04:28:07 <ivanm> for my graphviz library, does anyone have a suggestion on how I can term a "generic" DotGraph representation that doesn't care about ordering?
04:28:27 <pozic> ivanm: ordering of what?
04:29:10 <ivanm> the items in the DotGraph
04:29:20 <ivanm> basically, I'm replaceing DotStatements here with a Seq: http://hackage.haskell.org/packages/archive/graphviz/2999.7.0.0/doc/html/Data-GraphViz-Types.html#t%3ADotStatements
04:29:59 <Saizan_> zenzike: i think you've to put them on the right of <-
04:30:37 <Saizan_> zenzike: but i'd remeasure the time using -O2 and without profiling, to see if it's acceptable now
04:30:56 <pozic> ivanm: DotStatementSet?
04:31:25 <ivanm> yeah, but I'd have to have a new name for all the other data structures that use it as well
04:31:55 <zenzike> Saizan: I'll give that a go. the compiler isn't happy with the first SCC, which is in a let expression. I can't imagine why that would break
04:32:54 <ivanm> Baughn: at least now I can get some info from haskell-indent about what the parse errors are...
04:32:55 <zenzike> ah, it's now incredibly fast with O2. must have been that all along. thanks :-)
04:35:24 <pozic> Is there a way to just install the profiling libraries, if you already have the normal ones?
04:36:34 <luite> pozic:  unfortunately not, you can do cabal install --reinstall
04:36:51 <luite> but you'd have to do it for all packages manually
04:37:29 <pozic> luite: it is 20 minutes work to change Cabal such that it is more intelligent in that way :(
04:37:56 <pozic> luite: that's with a lot of things that way, unfortunately.
04:37:59 <luite> it is a planned feature to track profiling packages separately
04:38:12 <luite> you're probably welcome to submit a patch :p
04:40:41 <Baughn> ivanm: Hm?
04:41:22 <ivanm> Baughn: when I first used haskell-indent (before you integrated it in), I could never tell why it didn't like my code
04:41:37 <Baughn> ivanm: I don't recall doing anything to change that
04:41:45 <ivanm> this time I eventually got it to admit that my code was missing -> in a lambda statement (I had = in there)
04:41:55 <Baughn> Ah.
04:42:08 <ivanm> Baughn: OK, so it must just be fortuitous that it now came up, and you should keep quiet so I keep thinking you're brilliant ;-)
04:42:20 <Saizan_> zenzike: np, GHC did all the work :)
04:42:52 <Baughn> ivanm: Depending on when "first used" was. haskell-indentation.el has always had that sort of error message, even before I released 2.5.
04:42:54 <mstevens> bonjour
04:43:09 <Baughn> ivanm: It just wasn't part of haskell-mode as such back then, so if you didn't go looking for it..
04:43:24 <Saizan_> pozic: until recently Cabal had no good way to tell if the profiling version was installed, 6.12 should have changed things but it needs an interested dev
04:43:30 <ivanm> Baughn: yeah
04:43:46 <ivanm> Baughn: admittedly, I had to hit enter in the right spot before it said what the parse erorr was... >_>
04:44:39 <Baughn> ivanm: It usually doesn't need that
04:44:58 <Baughn> ivanm: Hm. I could make it skip to where the error is, for a moment, when it throws a parse error
04:45:45 <ivanm> Baughn: maybe make it an option for people that don't want it though...
04:45:57 <Baughn> Sure.
04:46:38 <zenzike> Saizan_: ha. that would have been true, except it wasn't actually any faster; my build failed really quickly and I thought it was the program loading and exiting fast, so I'm still investigating
04:49:00 <Saizan_> zenzike: reading the docs, it seems you've to use quotes for the SCC name
04:49:17 <Saizan_> e.g. stretch = {-# SCC "testBit" #-} testBit pixel 7
04:49:19 <zenzike> yup, I got that working, sorry, should've said
04:50:44 <Axman6> dons: you arround by any chance?
04:50:51 <Axman6> -r -_-
04:51:13 <Saizan_> @arr
04:51:13 <lambdabot> Har de har har!
04:51:49 * Axman6 really wishes that the Data.Binary package implemented MonadPlus for the Get monad
04:52:52 <PeakerWork> I wish Get actions that failed were in MaybeT or EitherT
04:53:11 <Axman6> i wish there was some way of handling their failure
04:53:13 <Saizan_> you wish you were using a different lib :)
04:53:17 * smiler wishes he had a clue
04:53:32 <vy> Hi! Can anybody help with that printf error: http://codepad.org/U0Tq3rLd
04:53:37 <PeakerWork> Saizan_: is there one that handles failures nicely?
04:53:45 <Twey> Axman6: What would mplus mean?  ‘Parse this, then this’?
04:54:04 <Axman6> PeakerWork: the one in HCodecs seems to, which i'm planning on releasing as a separate package
04:54:18 <Twey> @index Monoid
04:54:18 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
04:54:22 <Axman6> Twey: it would mean, if this fails, try this
04:54:44 <Saizan_> PeakerWork: there are other parsing libs that work on bytestring
04:54:53 <Axman6> even adding a try primitive would be fantastic
04:55:03 <Axman6> Saizan_: can you name any?
04:55:04 <Saizan_> well, binary is not really a parsing lib
04:55:15 <Saizan_> Axman6: attoparsec, OTOH
04:55:25 <Axman6> i'll have to look at those
04:55:41 <Twey> Hmm
04:55:50 <Twey> What's the semantic difference between Monoid and MonadPlus?
04:56:06 <Saizan_> Monoid doesn't talk about Monads
04:56:36 <Saizan_> and it's not required to work in the same way for ever 'a' if you make an instance Monoid (m a)
04:56:39 <Axman6> argh, attoparsec has no haddocs!
04:56:49 <Twey> Ah
04:57:35 <Saizan_> well, if you build it locally it should
04:57:41 <PeakerWork> Twey: Hypothetically:  class (forall a. Monoid m a) => MonadPlus m where <laws about mzero/bind/etc here)
04:58:00 <Twey> Yes, I see
04:58:13 <Twey> Also Monad m, no?
04:58:16 <PeakerWork> oops, ya
04:58:17 <Saizan_> there's binary-strict, even
05:03:06 <ivanm> Baughn: I'm noticing though that if I have a where statement attached to a function with an if statement, it wants to make the where part of the if
05:04:18 <Twey> ‽
05:04:52 <Twey> > f x = if y > 5 then True else False where y = x + 3 in f 2
05:04:53 <lambdabot>   <no location info>: parse error on input `='
05:04:56 <Twey> Huh.
05:04:59 <Twey> Oh
05:05:02 <Twey> > let f x = if y > 5 then True else False where y = x + 3 in f 2
05:05:03 <lambdabot>   False
05:05:08 <Twey> > let f x = if y > 5 then True else False where y = x + 3 in f 3
05:05:09 <lambdabot>   True
05:06:56 <ivanm> Baughn: (in terms of how it indents)
05:07:27 <Twey> Oh!  haskell-mode.
05:07:35 <ivanm> yeah
05:07:36 <Baughn> ivanm: I've noticed. Of late, I've been trying to implement a smarter partial parser, in haskell this time around.
05:07:45 <Baughn> ivanm: The haskell-indentation elisp code is pretty impenetrable. :/
05:07:51 <ivanm> heh
05:08:01 <ivanm> Baughn: kuribas seems to be around for pinging purposes... >_>
05:08:03 <ivanm> ;-)
05:08:06 <lpsmith> Oh,  is hackage/cabal init going to support the Affero GPL any time soon?
05:08:20 <Baughn> lpsmith: You can always use a custom license
05:08:37 <ivanm> preflex: seen sinelaw
05:08:37 <preflex>  sinelaw was last seen on #haskell 1 hour, 25 minutes and 23 seconds ago, saying: your experience is an order of magnitude larger than mine, so however you do it is ok with me :)
05:08:44 <dcoutts> lpsmith: probably not
05:08:51 <sinelaw> still here :)
05:08:53 <ivanm> dcoutts: not popular enough in haskell-land?
05:09:02 <dcoutts> lpsmith: if you think it's important then file a ticket
05:09:15 <ivanm> sinelaw: OK, I'm pushing what might be what you want to the darcs repo; have a look and tell me what you think
05:09:24 <sinelaw> that's great, thanks
05:09:31 <ivanm> the augmentGraph function is what I mean
05:09:46 <ivanm> note it only works if you don't have multiple edges... >_>
05:10:03 <sinelaw> oh. why?
05:11:29 <ivanm> sinelaw: atm, to determine which edge to augment, it only uses the node IDs
05:12:01 <sinelaw> ivanm, ah. In my program i change the edge labels from a to (id, a)
05:12:17 <sinelaw> so if you'd use the label too, it would be fine
05:12:22 <ivanm> if you really need it, I can make it use the actual label (but it will still require unique labels to get the proper list of attributes, and will add a constraint to the functions involved)
05:13:01 <ivanm> sinelaw: I'd rather not, as it means I'd need to add Ord b to all the graphToGraph, dotizeGraph and associated functions :s
05:14:09 <sinelaw> i know it's more work, but maybe you can allow for just that kind of label in a separate version of the function
05:14:24 <sinelaw> by that kind i mean (id, a) (Ord id)
05:14:26 <ivanm> it won't be (id,a)
05:14:39 <ivanm> it'd just be the entire label
05:14:55 <ivanm> since I'm definitely not going to specialise it that much just for you! ;-)
05:15:18 <sinelaw> ivanm, heh, but it isn't just for me. what if the 'a' isn't ord-able?
05:15:26 <sinelaw> for anyone who wants double labels
05:15:33 <ivanm> that's why I'm not really wanting to do this...
05:15:52 <sinelaw> ivanm, actually it'd be ok to be the entire label
05:16:06 <sinelaw> i can "fmap" my graph edge labels first to leave only the id
05:16:10 <ivanm> yeah... it's not likely someone is going to have a non-Ord edge label that I can think of
05:16:27 <ivanm> sinelaw: or, use a custom type rather than a tuple and define a custom Ord instance...
05:16:39 <ivanm> sinelaw: so you have/want multiple edge support? (just making sure)
05:16:44 <sinelaw> ivanm, well, that's where my inexperience shows :)
05:16:51 <ivanm> heh
05:17:16 <sinelaw> ivanm, yes i do, but the current reason is only to not have it limited
05:17:23 <ivanm> realistically (and this is why FGL really sucks), you should _never_ use tuples for anything except quick and dirty data passing
05:17:26 <sinelaw> i want the user to be able to edit any sort of graph
05:17:31 <ivanm> yeah
05:18:02 <ivanm> I don't really want to specialise this function....
05:18:33 <ivanm> I _might_ provide a (Graph gr, Ord c) => (b -> c) -> gr a b ... variant, and a primed version that defaults the function to id ...
05:18:38 <lpsmith> ivanm:  I don't like the FGL because it doesn't feel right... the tuple thing barely registers in my opinion
05:18:45 <lpsmith> The primitives don't have nice properties
05:18:50 <sinelaw> ivanm, don't tell anyone (except the hundreds present) but my plan is to make this a code-graph editor combined with another semantic editor, and then when it can edit itself, take over the universe
05:18:50 <ivanm> how doesn't it feel right?
05:18:58 <ivanm> heh
05:19:16 <lpsmith> E.g.  when I write something down,  how do I even know it's a well-defined function?
05:19:35 <ivanm> how do you know for anything else?
05:19:50 <ivanm> lpsmith: or are you complaining about the quality of the code rather than the API itself?
05:19:59 <lpsmith> noj, the API
05:20:09 <sinelaw> ivanm, that sounds ok
05:20:23 <sinelaw> but then the primed version will have Ord b
05:20:34 <sinelaw> actually that's ok
05:21:02 <ivanm> yeah, it'd be better off not to, but it's probably better to allow multiple edges
05:21:31 <PeakerWork> How do you identify in "dot"s output graph -- which node/edge are which?
05:21:55 <sinelaw> i guess he passes unique ids as edge/node labels
05:22:03 <sinelaw> that's what i did back in the day :)
05:22:15 <ivanm> sinelaw: actually, I can't do that...
05:22:27 <ivanm> because I have a map of (node,node) -> attributes
05:22:29 <PeakerWork> sinelaw: ya, we had trouble with that approach though, too
05:22:29 <sinelaw> well, each node has a number
05:22:37 <sinelaw> in FGL
05:22:40 <ivanm> so unless I arbitrarily align them up... :s
05:23:27 <sinelaw> holy falafel
05:23:39 <ivanm> (that is, I have a list of edges and a list of edge attributes, I arbitrarily zip them together)
05:23:51 <ivanm> but that's probably what most people consider to be _bad_ ...
05:23:57 <sinelaw> ivanm, yeah, I meant for the nodes
05:24:07 <ivanm> sinelaw: oh, nodes are no problem
05:24:12 <ivanm> since each one has an ID
05:24:17 <lpsmith> well defined in the sense,  that when I deconstruct a graph and put it back together again,  that the result does not depend on the order in which the FGL decided to deconstruct my graph for me
05:24:26 <ivanm> but I can't safely allow augmenting multiple edges
05:24:51 <ivanm> since there's no way of working out which [Attribute] belongs to which LEdge
05:24:56 <sinelaw> ivanm, you can't even using the ord instance on the label?
05:25:03 <ivanm> sinelaw: nope
05:25:15 <ivanm> because I create a lookup map from _dot edges_
05:25:37 <sinelaw> ivanm, but the dot edges have a label attribute which identifies which edge it was originally
05:25:43 <ivanm> no they don't
05:25:50 <sinelaw> so how did I do it?
05:26:00 <sinelaw> lemme checkout
05:26:08 <ivanm> there is the chance of having a Label attribute; but it takes a String (or a URL)
05:26:12 <ivanm> not an arbitrary value
05:26:36 <sinelaw> ivanm, ok so have Show a
05:26:42 <sinelaw> ugly, but it will work
05:26:47 <ivanm> no it won't
05:26:54 <ivanm> since I don't use Show! ;-)
05:27:01 <ivanm> and I know in my own code, I don't use Show
05:27:10 <ivanm> I use custom functions depending on the situation
05:27:42 <ivanm> sinelaw: so there's two options: atm, every LEdge will get the same [Attribute]
05:28:22 <ivanm> the other option is to try to zip the lists of LEdges and DotEdges together and assign [Attribute] that way
05:28:41 <mreh> i am being lazy: how can I quickly render some Haskore.Music.T into a midi file, I'm not bothered about performance, I just want to render something literally
05:29:01 <ivanm> mreh: no idea; never looked at haskore
05:29:07 <PeakerWork> ivanm: can't you use a unique identifier String for that?
05:29:10 <ivanm> I guess I can't help you in your quest of being lazy
05:29:21 <ivanm> PeakerWork: where would I get this magic unique identifier string from?
05:29:24 <mreh> ivanm: it's confusing, I'd like to talk to someone who does it alot
05:29:30 <sinelaw> ivanm, the label!
05:29:36 <mreh> preflex: seen mmorrow
05:29:36 <preflex>  mmorrow was last seen on ##c 2 hours, 31 minutes and 10 seconds ago, saying: trupheenix: if you're not using autoconf or such, i'd write a program that determines endianess (and whatever else might be needed while we're at it), then spits out a my_config.h on stdout. endianess determination through cpp defines can't be relied on unfortunately
05:29:52 <PeakerWork> ivanm: generate them
05:30:03 <sinelaw> exactly
05:30:17 <sinelaw> i think that's how i did it...arbitrarily generated unique id's
05:30:23 <ivanm> that's stupid
05:30:25 <sinelaw> then i formatted them into strings
05:30:29 <ivanm> the Label is what the user uses
05:30:30 <sinelaw> then i read them back in
05:30:43 <ivanm> and gets printed
05:30:52 <sinelaw> ivanm, not in my case! i render the graph.
05:31:03 <sinelaw> also i think there may be a way around that
05:31:05 <ivanm> sinelaw: right, but not everyone is you ;-)
05:31:12 <sinelaw> ivanm, that's an example
05:31:13 <PeakerWork> "dot" is annoying for not letting you specify your own "hidden" label
05:31:27 <PeakerWork> how hard is it to reimplement dot's algorithms?
05:31:29 <sinelaw> if all you want is to get dot's layout info, which is my case, it will be ok
05:31:32 <ivanm> PeakerWork: and even so, I can't think of a nice sane way of providing a custom label
05:31:56 <ivanm> sinelaw: what complicates it is how you want the global attributes as well
05:31:56 <sinelaw> though there is then the problem of laying out the graph according to edge/node label length
05:32:11 <sinelaw> i'll go and check now how i ended up doing it
05:32:12 <ivanm> if it wasn't for that, I'd be happy with trying to do some kind of hidden label thingy
05:32:21 <sinelaw> how do i want it?
05:32:25 <sinelaw> i just want it _somehow_
05:32:34 <sinelaw> don't care how
05:32:45 <ivanm> but since the best way I could think of to have global attributes returned is to split out augmentGraph, that means that I have to be able to use "real" DotGraphs as well
05:33:15 <ivanm> sinelaw: why do you want global attributes?
05:33:23 <ivanm> just to get the bounding box size?
05:33:30 <sinelaw> ivanm, currently that's the only one
05:33:49 <sinelaw> i'm not sure but maybe there are other important ones for layout
05:34:41 <ivanm> hmmm....
05:34:56 <sinelaw> ivanm, for nodes i didn't have to make it the label, because you can do: a -> b; a [label="Hooray"];
05:35:03 <sinelaw> ivanm, for the edges, i did end up using the label
05:35:09 <ivanm> right
05:35:15 <sinelaw> so a and b were unique ids
05:35:24 <sinelaw> but for edges, the label was
05:36:46 <ivanm> so, the problem is that that'd be OK if no-one ever knew about that hidden label...
05:37:06 <ivanm> sinelaw: see, if all I had was the dotize* functions, I'd be OK doing that
05:37:40 <ivanm> since they don't allow for custom attributes, so I could use attributes to do that kind of stuff
05:37:54 <sinelaw> ivanm, you don't like it that when they go back to graphs they get those balues?
05:38:01 <ivanm> but since I allow users to provide custom attributes (to tweak layouts, etc.) then I can't :(
05:38:04 <sinelaw> *values
05:38:12 <sinelaw> hmm
05:38:13 <ivanm> sinelaw: hmmm?
05:38:33 <ivanm> so your best bet in that sense would be to do copy-pasta :(
05:38:46 <sinelaw> i guess you library isn't exactly meant for what i'm doing
05:38:55 <sinelaw> sadly
05:39:01 <Twey> Looks pretty fun
05:39:02 <sinelaw> *your
05:39:21 <ivanm> sinelaw: not that part of it, no
05:39:36 <ivanm> sinelaw: so, the printing and parsing suits what you want...
05:39:43 <ivanm> it's just the high-level stuff doesn't do what you want
05:40:09 <sinelaw> yah, maybe i can print, hack some stuff in, then parse
05:40:17 <ivanm> sinelaw: so what you'd need to do is define your own version of dotizeGraph
05:40:37 <kuribas> ivanm: I am here ....
05:40:59 <ivanm> kuribas: I was just pointing out your presence to Baughn since he said he had trouble understanding your elisp ;-)
05:41:13 <ivanm> sinelaw: do it before you print: get your graph, assign unique edge IDs, create the DotGraph, parse it, use the unique IDs to augment the graph
05:41:39 <ivanm> sinelaw: so you'd need custom versions of graphToGraph, dotAttributes and augmentGraph
05:41:43 <sinelaw> yeah
05:41:50 <kuribas> ivanm: I have trouble understanding it myself :)
05:41:59 <sinelaw> well thanks for the help!
05:42:05 <ivanm> dotAttributes would be almost identical to how it is currently (just use your replacement for augmentGraph)
05:42:08 <ivanm> sinelaw: no worries!
05:42:15 <ivanm> kuribas: heh, fair enough
05:42:25 <sinelaw> i'll call you when i take over the universe (don't charge your phone too soon)
05:43:11 <ivanm> heh
05:43:15 * hackagebot upload: usb 0.3.0.1 - Communicate with USB devices (BasVanDijk)
05:43:43 <ivanm> sinelaw: lemme have a quick look through the attributes again to see if there's any way of having a hidden ID somewhere...
05:43:58 <Baughn> kuribas: There are insufficient comments, and it isn't written the way I'd write it. Also, too many weird lists, too few explicit data structures - but I suppose that's just elisp being elisp.
05:44:15 * hackagebot upload: regions 0.1.0.1 - Provides the region monad for safely opening and working with  scarce resources. (BasVanDijk)
05:44:20 <Baughn> "It isn't written the way I'd write it" has to be one of the best excuses of all time..
05:44:23 <sinelaw> ivanm, k
05:44:41 <ivanm> Baughn: heh
05:44:44 <sinelaw> comment doesn't come back after running dot, does it?
05:44:56 <ivanm> sinelaw: doubt it...
05:45:01 <ivanm> let me do a quick test
05:45:16 <Baughn> kuribas: Well, my largest problem with it is that it requires emacs to re-parse a good chunk of the file every time you do something with indentation. It becomes noticably slow on, er, fifty-line functions..
05:45:42 <sinelaw> ivanm, from the dot documentation: "Comments are inserted into output. Device-dependent "
05:45:54 <kuribas> Baughn: I see... So don't write fifty-line functions ?
05:46:18 * hackagebot upload: regions-monadsfd 0.1.0.1 - Monads-fd instances for the RegionT monad transformer (BasVanDijk)
05:46:23 <ivanm> sinelaw: yeah
05:46:34 <adu> 50-line functions ?!?
05:46:35 <Baughn> kuribas: Arguably.
05:46:37 <kuribas> Baughn: It was the only solution I found to find the real indentation spots...
05:47:04 <ivanm> sinelaw: it does! \o/
05:47:06 <Baughn> adu: I'm slowly cutting it to pieces and abstracting out. Problem is, it /works/ already..
05:47:09 <sinelaw> ivanm, heh
05:47:11 <ivanm> sinelaw: I'll try hacking that in tomorrow
05:47:20 * hackagebot upload: regions-monadstf 0.1.0.1 - Monads-tf instances for the RegionT monad transformer (BasVanDijk)
05:47:23 <ivanm> but it looks like the dot output keeps output in there! \o/
05:47:51 <adu> Baughn: what is "it"?
05:47:54 <sinelaw> ivanm, great
05:48:12 <sinelaw> :P
05:48:15 <Baughn> adu: A connection negotiation function. Sets up cryptography, exchanges session keys, etc. etc.
05:48:30 <adu> i see
05:48:31 <ivanm> sinelaw: so, it'd basically be "oi! stupid! you want this to work? don't set a comment!"
05:48:39 <Baughn> adu: It's basically fifty lines of IO code.
05:48:50 <sinelaw> ivanm, that's plausible
05:48:51 * ivanm wishes haddock had support for bold markup just for cases like this
05:49:16 <Baughn> adu: ..things are made worse by my habit of sticking any functions that I possibly can stick in wheres, in wheres.
05:49:19 * hackagebot upload: usb-safe 0.4.1 - Type-safe communication with USB devices. (BasVanDijk)
05:49:22 <sinelaw> maybe we should hack haddock too
05:49:30 <kuribas> Baughn: I am not particularly proud of it, but I it still is elisp.  If I had closures it would have been much cleaner.
05:49:37 <Baughn> kuribas: *nod*
05:50:01 <Baughn> kuribas: It's still much better than I could write. Hopefully, the parser I'm writing in haskell will work better though.
05:50:01 <kuribas> Baughn: It is basicly a recursive descend parser, setting the state iteratively.
05:50:13 <Baughn> kuribas: I've tracked it that far
05:50:21 <adu> Baughn: I was just thinking 'where's would clean that up
05:50:56 <Baughn> adu: Oh, it's already mostly wheres. It's just that haskell-indentation parses the /entire/ function; it can't skip over where clauses.
05:51:28 <adu> Baughn: how does Yi do on it?
05:51:45 <Baughn> Not sure. I should take a look.
05:51:54 <Baughn> Once gtk2hs works with 6.12. ^^;
05:52:15 <Baughn> ..or, indeed, yi.
05:52:16 <mux> how often does hackage try to build packages? I hope it's not just when it is uploaded
05:52:29 <Baughn> mux: They're built in batch.. every few hours, I think
05:52:33 <Baughn> But not without reason
05:52:45 <Baughn> (Ie. /something/ has to change)
05:53:08 <mux> well that's annoying - my package failed to build but only because the build bot on hackage seems broken
05:53:29 <kuribas> Baughn: It does, because a layout can be ended by an illegal token.
05:53:43 <kuribas> Skipping indentation would be incorrect.
05:54:10 <Baughn> kuribas: Such code would also fail to compile
05:54:19 <Baughn> I would prefer for the indenter to skip it anyhow, trying to recover
05:54:41 <Baughn> ..perhaps coloring that spot as broken in the editor
05:55:26 <kuribas> No, it can be valid code too.
05:55:47 <Baughn> ..how does that work?
05:56:16 <Baughn> What definition of "illegal token" is this?
05:56:29 * hackagebot upload: repr 0.3.2 - Render overloaded expressions to their textual representation. (BasVanDijk)
05:57:21 <kuribas> Baughn: illegal for the expression containing the layout.
05:57:37 <kuribas> Baughn: I'll try to find an example.
06:00:31 * hackagebot upload: explicit-iomodes 0.1.2 - File handles with explicit IOModes (BasVanDijk)
06:02:38 <kuribas> Baughn: It maybe contain a closing paren from an outer expression for example.
06:02:46 <raceRider> are there any examples showing use of Data.Set?
06:03:00 <mmorrow> Baughn: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5536#a5536
06:03:38 <mmorrow> since the layout context is a stack, an inner context's indent doesn't necessarily need to be w/in that of any outer context
06:05:52 <Baughn> mmorrow: That indentation can't possibly be a good idea, but I'll accept that it's legal.
06:05:56 <Baughn> Back to the drawing-board.
06:07:13 <kuribas> Baughn: I doubt my mode can be faster without sacrificing correctness.
06:07:40 <Baughn> kuribas: Well - caching, for one
06:08:25 <Baughn> It needs to parse the file up to point A to indent something at A. Fine, but why would it then need to re-do the work when I edit the line beneath?
06:08:43 <Baughn> ..I'll see if I can implement that. Sounds like the kind of thing that should be doable.
06:09:11 <vy> How can I apply `mod` to a Real (or Num)?
06:09:36 <Baughn> @type mod
06:09:37 <lambdabot> forall a. (Integral a) => a -> a -> a
06:10:00 <Baughn> Hm. It's not like the first parameter being a real would make no sense..
06:10:19 <Baughn> Or the second, for that matter. There should be a more permissive one somewhere.
06:11:27 * Alpounet about to release hnn on hackage
06:12:02 <ivanm> Alpounet: what's hnn?
06:12:07 <Baughn> haskell neural networks?
06:12:07 <kuribas> Baughn: You can find a comment "Dynamically scoped variables", which contain the state of the parser.
06:12:13 <mmorrow> Baughn: err, in case that paste link got through, ignore it because it doesn't even work :)
06:12:20 <Axman6> preflex: seen ChilliX
06:12:20 <preflex>  ChilliX was last seen on #ghc 11 days, 2 hours, 10 minutes and 58 seconds ago, saying: sorry, bundled with gmp
06:12:27 <mmorrow> i must have just done ":r" or something
06:12:27 <Baughn> kuribas: Surely that state includes the /call stack/
06:12:32 <Baughn> Could be a bit troublesome.
06:12:42 * Baughn wonders if elisp has continuations
06:12:50 <ivanm> how does it differ from hfann?
06:12:51 <Alpounet> ivanm, see Baughn's answer.
06:12:54 <kuribas> Baughn: No, because that is done by the dynamic scoping...
06:12:55 <ivanm> pure haskell rather than just a binding?
06:12:59 <Alpounet> ivanm, yep
06:13:05 <ivanm> cool
06:13:05 <Alpounet> UArr-based.
06:13:14 <Alpounet> http://www.haskell.org/haskellwiki/HNN
06:13:17 <Baughn> kuribas: Nice. Well, then, I won't hold back.
06:13:32 <Alpounet> this is 0.1, so any feedback, feature request, whatever of any sort is very welcome.
06:15:23 * Alpounet triple checks everything before pressing the "upload" button :p
06:15:50 <kuribas> It's ugly, but so is elisp :)
06:16:02 <Saizan_> Alpounet: 3.2 just "cabal install"
06:16:16 <Saizan_> Alpounet: cabal configure and cabal build are implied
06:16:29 <Alpounet> Saizan_, ok :-)
06:16:35 <Alpounet> thanks
06:17:16 <dcoutts> Alpounet: "'base' (>= 3 && <= 5)" is essentially the same thing as saying ghc 6.8 or later
06:18:14 <dcoutts> Alpounet: and if you're doing "cabal install" in one go, then you can use --enable-documentation rather than a separate cabal haddock step
06:18:17 <kuribas> Baughn: Did you byte compile the haskell-indentation.el ?
06:18:36 <Alpounet> dcoutts, these were my first steps with cabal files, and I read somewhere that such constraints were the most used, instead of constraints on ghc.
06:18:50 <Alpounet> dcoutts, ok thank you ! I'll write that on the wiki
06:18:51 <Baughn> kuribas: Um, no. I assumed emacs does that when it loads the file.
06:19:03 <Baughn> kuribas: ..you're going to tell me it doesn't, aren't you?
06:19:09 <kuribas> yes :)
06:19:18 <Baughn> Well, then go ahead.
06:19:24 <dcoutts> Alpounet: yes, in .cabal files we want to be precise, in a wiki page you can be informal and say you need ghc-6.8 or later.
06:20:05 <kuribas> Baughn: "M-x byte-compile-file" will do the job.
06:20:46 <Baughn> kuribas: Or the haskell-mode makefile will, at that.
06:20:59 <kuribas> Possibly.
06:21:15 <Alpounet> dcoutts, agreed
06:21:35 <kuribas> Baughn: The byte-compiled file is named haskell-indent-nocycle.elc.
06:21:50 <kuribas> haskell-indentation.elc actually.
06:21:55 <kuribas> (I have renamed it)
06:22:01 <Baughn> Yes, especially since I restored the cycling.
06:22:42 <kuribas> If you want to use the cycling mode, then I cannot help you.
06:23:15 <Alpounet> dcoutts, Saizan_: I just updated the page according to your suggestions. Thanks.
06:23:18 <Baughn> No, I mean, I fixed haskell-indentation.el so it no does cycling as well. So using the old name would've been a problem. :P
06:23:36 <Alpounet> well, trying to.
06:23:38 <Alpounet> crappy connection.
06:23:50 <kuribas> You "fixed" it??? :-)
06:24:35 <Alpounet> haha
06:24:40 <Alpounet> time to upload now, come on :p
06:24:42 <Baughn> Lots of people wanted the feature. It can be turned off, but it's on by default.
06:25:05 <Baughn> ..well, actually it prints a warning by default, and /then/ cycles on the next tab.
06:25:34 <kuribas> Baughn: Where did you download it from?
06:25:51 <Baughn> kuribas: Your site.
06:26:00 <kuribas> Ah
06:26:07 <jav_> Can someone help me with some type massaging? I would like to go from [(a, b)] to ([a], [b])
06:26:27 <Baughn> @type unzip
06:26:28 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
06:26:37 <kuribas> Baughn: So I should rename it again to haskell-indent-maybe-cycle?
06:26:46 <Baughn> kuribas: Urk. haskell-indentation is fine.
06:26:52 <mreh> @pl \x y -> f x y z
06:26:52 <lambdabot> flip flip z . f
06:26:53 <Axman6> Lemmih: you around?
06:27:05 <jav_> Baughn: cool, thx :-)
06:27:07 <Baughn> kuribas: Oh, you mean the function. Um. No. Besides, I wouldn't accept the patch. :P
06:27:19 <kuribas> Baughn: ok.  I wanted to avoid confusion with haskell-indent.el
06:27:43 <mreh> @pl \x -> f x x
06:27:43 <lambdabot> join f
06:28:34 <mreh> @pl \x -> f x y
06:28:34 <lambdabot> flip f y
06:31:04 <mreh> :t flip flip
06:31:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:31:20 <Axman6> urgh!
06:31:45 <Axman6> :t let flip f x y = f y x in flip flip
06:31:46 <lambdabot> forall t t1 t2. t1 -> (t -> t1 -> t2) -> t -> t2
06:32:18 <Axman6> :t let flip :: (a -> b -> c) -> b -> a -> c; flip f x y = f y x in flip flip
06:32:19 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
06:32:58 <mreh> what is the type * -> *?
06:33:07 <Beelsebob> mreh: it's not a type – it's a kind
06:33:19 <mreh> f :: * -> * is a Class?
06:33:20 <Beelsebob> Axman6: notably – that's the type lambdabot gave you for :t flip flip
06:33:23 <Beelsebob> just less general
06:33:39 <Beelsebob> mreh: no, that indicates that f is a type which takes a type as an argument and returns a new type
06:33:42 <opqdonut> mreh: * is the kind of types
06:33:54 <opqdonut> * -> * is the kind of one-parameter type constructors
06:33:59 <opqdonut> :kind Maybe
06:34:08 <opqdonut> ?kind Maybe
06:34:09 <lambdabot> * -> *
06:34:14 <Axman6> mreh: Maybe has kind * -> *, but Maybe Int has kind *
06:34:17 <opqdonut> ?kind Int
06:34:18 <lambdabot> *
06:34:20 <opqdonut> ?kind Maybe Int
06:34:21 <lambdabot> *
06:34:24 <mreh> hmm
06:34:27 <opqdonut> ?kind RWST
06:34:28 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
06:34:28 <Beelsebob> ?kind Int -- for completeness
06:34:29 <lambdabot> *
06:34:43 <Axman6> already been done Beelsebob ;)
06:34:43 <opqdonut> glorious stereo once again :)
06:34:47 <mux> the kinding system is like type checking but for types, it allows to reject non-sensical types such as Maybe Int Double
06:34:47 <Saizan_> kinds are in fact types of types
06:34:49 <Beelsebob> Maybe Int has type * because Int has kind * and Maybe has kind * -> *
06:34:59 <mux> :k Maybe Int Double
06:35:00 <lambdabot>     Kind error: `Maybe' is applied to too many type arguments
06:35:07 <zygoloid> :t flip
06:35:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:35:10 <mreh> there are too many people talking
06:35:19 <zygoloid> huh. caleskel again?
06:35:22 <Axman6> ?kind Mu Maybe
06:35:22 <b_jonas> :k Maybe Maybe
06:35:23 <lambdabot> *
06:35:23 <lambdabot>     `Maybe' is not applied to enough type arguments
06:35:23 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
06:35:29 <b_jonas> @kind Maybe Maybe
06:35:29 <Beelsebob> zygoloid: I think so, yeh
06:35:30 <lambdabot>     `Maybe' is not applied to enough type arguments
06:35:30 <lambdabot>     Expected kind `*', but `Maybe' has kind `* -> *'
06:35:31 <Axman6> ?kind Mu
06:35:32 <lambdabot> (* -> *) -> *
06:36:24 <mreh> it looks like the old Miranda polymorphic type variables, but clearly, it has nothing to do with them
06:36:49 <Saizan_> mreh: the kind system is a simpler type system, without polymorphism, all types for which you can have values have kind *
06:37:08 <jav_> golfing question: I'd like to write this in one statment: tmpResult <- mapM f list; let (a, b) = unzip tmpResult ... do I need to 'lift' or 'fmap' unzip or something? I'm still not really getting that
06:37:14 <Saizan_> mreh: then a type with kind A -> B, takes a parameter of kind A and returns a type of kind B
06:37:42 <Saizan_> mreh: it has nothing to do with them, in miranda * ** *** were just type variable names, no?
06:37:46 <opqdonut> jav_: tmpResult is to the left of a "<-" so it should be nonmonadic
06:37:53 <mreh> Saizan_ yup
06:38:05 <opqdonut> jav_: or would you like to merge those two lines into one?
06:38:13 <Alpounet> dcoutts, I guess package need some time to appear on the pkg-list ?
06:38:14 <jav_> opqdonut: yes, that's what I want to do
06:38:17 <Alpounet> packages*
06:38:22 <opqdonut> well
06:38:28 <zygoloid> jav_: mapM f list >>= g . unzip tmpResult, where g is your ...
06:38:46 <dcoutts> Alpounet: sorry I missed the context, what do you mean?
06:38:48 <Beelsebob> jav_: (a,b) <- unzip <$> mapM f list
06:38:53 <mreh> Saizan_ I don't know why they decided a unary alphabet was a good thing
06:38:59 <opqdonut> jav_: or "fmap unzip $ mapM f list"
06:39:07 <Saizan_> mreh: in Miranda? no idea.
06:39:19 <opqdonut> but anyway
06:39:22 <opqdonut> look at the types
06:39:24 <opqdonut> :t mapM
06:39:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:39:32 <opqdonut> :t liftM unzip
06:39:32 <Saizan_> mreh: in Haskell's kind system we've only *, not **, *** and so on
06:39:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [(a, b)] -> m ([a], [b])
06:39:34 <Alpounet> dcoutts, I just uploaded my library there. I guess it takes some time to appear on the pkg-list page, and to generate the online documentation
06:39:40 <zygoloid> jav_: it really depends on which monad you're in and what the ... is :)
06:39:51 <mreh> Saizan_ right
06:39:57 <Beelsebob> zygoloid: it doesn't depend on that at all
06:40:07 <zygoloid> Beelsebob: for the list monad, comprehension syntax is often fewer keystrokes
06:40:14 <Beelsebob> true
06:40:26 <zygoloid> and if the ... is just a 'return' then you don't need a >>= at all
06:40:34 * Beelsebob nods
06:40:44 <Beelsebob> that statement didn't need a >>= at all
06:40:45 <Beelsebob> just a <$>
06:40:51 <jav_> ok, thx zygoloid, Beelsebob and opqdonut .. I think I should be able to figure it out now ... sorry, the '...' was misleading. I meant to end the code there and continue with my sentence
06:41:18 <Axman6> Beelsebob: i was thinking the same thing...
06:41:22 <jav_> :t <$>
06:41:23 <lambdabot> parse error on input `<$>'
06:41:27 <Beelsebob> jav_: take a look at http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
06:41:31 <Axman6> :t (<$>)
06:41:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:41:37 <zygoloid> Beelsebob: yeah, true, to reduce the code to one stmt you don't need to know anything else, but golfing is usually more global than that ;-)
06:41:38 <dcoutts> Alpounet: pkg-list doesn't appear to be there
06:41:39 <Axman6> <$> == fmap
06:41:44 <Beelsebob> it explains the bits that lead up to monads that aren't always explained to people jav_
06:41:49 <dcoutts> Alpounet: it would appear on the recent list
06:41:57 <Twey> (<$>) = fmap
06:42:11 <Alpounet> dcoutts, what do you mean by "recent list" ?
06:42:19 <dcoutts> Alpounet: "what's new"!
06:42:22 <Alpounet> ah
06:42:23 <Alpounet> yeah
06:42:27 <dcoutts> oops, misstyped "!"
06:42:35 * dcoutts didn't mean to exclaim :-)
06:42:40 <Alpounet> :D
06:42:46 <Alpounet> dcoutts, it isn't there yet
06:42:52 * hackagebot upload: hnn 0.1 - A minimal Haskell Neural Network Library (AlpMestanogullari)
06:42:57 <Alpounet> hackagebot, cheers
06:43:19 <dcoutts> Alpounet: there's one failure case where it uploads successfully but the stuff isn't regenerated properly, in that case if it doesn't let you upload again then it's there and it'll appear next time someone else uploads.
06:43:43 <Alpounet> dcoutts, I have some connection issues for few days
06:43:54 * hackagebot upload: usb-id-database 0.4.0.2 - A database of USB identifiers (RoelVanDijk)
06:43:56 <mmorrow> hpaste.org works now
06:44:12 <Alpounet> so it uploaded -- looks so, doesn't it ? -- but didn't load any page after that, just stayed in a blocking state.
06:49:44 <lispy> Good morning!
06:49:54 <milaz> hi!
06:50:02 <lispy> How is code?
06:50:20 <Alpounet> hackage documentation generation crons are executed every day ?
06:50:23 <milaz> i am in struggle with the language :)
06:50:36 <lispy> milaz: uh oh
06:50:38 <Axman6> lispy: it is good!
06:50:48 <lispy> > fix show -- Don't fix what's not broken!
06:50:49 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
06:51:06 <b_jonas> > fix var
06:51:07 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
06:51:07 <lambdabot>         against inferred ty...
06:51:11 <lispy> > fix f
06:51:12 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:51:13 <lambdabot>    `SimpleReflect.FromExpr ...
06:51:24 <Axman6> > fix (f :: Expr -> Expr)
06:51:25 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
06:52:10 <lispy> > map length . group . fix $ show
06:52:16 <lambdabot>   mueval-core: Time limit exceeded
06:52:16 <lambdabot>  mueval: ExitFailure 1
06:52:25 <lispy> > take 10 . map length . group . fix $ show
06:52:27 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
06:52:43 <lispy> OMG cryptic code!
06:53:00 <medfly> ???
06:53:05 <poucet> erm not really
06:53:16 <Axman6> :t interleve
06:53:18 <lambdabot> Not in scope: `interleve'
06:53:20 <medfly> leave
06:53:23 <medfly> :t interleave
06:53:24 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
06:53:26 <Axman6> bta
06:53:28 <jleedev> lispy: http://www.research.att.com/~njas/sequences/A094024
06:53:30 <poucet> f x | even x = 1; | otherwise = ((x `div` 2) - 1) * 2 + 1
06:54:07 <poucet> f x | even x = 1; | otherwise = ((x `div` 2)) * 2 + 1
06:54:14 <lispy> jleedev: did you know lambdabot can find those sequences too?
06:54:27 <lispy> ?oeis 1 1 3 1 7 1 15 1 31
06:54:28 <lambdabot>  Expansion of (1+2x)/((1+x)(1-2x^2)).
06:54:28 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
06:54:28 <b_jonas> > 1 : intersperse 1 (iterate (\x->2*x+1) 1)
06:54:29 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1...
06:54:29 <Axman6> @oeis 1,1,1,3,1,7,1,15,1,31
06:54:30 <lambdabot>  Expansion of (1+2x)/((1+x)(1-2x^2)).
06:54:30 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
06:54:42 <jleedev> @lambdabot i see
06:54:42 <lambdabot> Unknown command, try @list
06:54:44 <b_jonas> Axman6: it's intersperse
06:54:52 <poucet> :t intercalate
06:54:52 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:55:03 <Axman6> :t intersperse
06:55:04 <lambdabot> forall a. a -> [a] -> [a]
06:55:30 <lispy> The funny part about lambdabot's auto correction and @oeis is this...
06:55:35 <Axman6> > intersperse 1 (map ((-1) . (2^)) [1..]
06:55:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:55:40 <lispy> ?penis 1 1 2 3 5
06:55:40 <Axman6> > intersperse 1 (map ((-1) . (2^)) [1..])
06:55:40 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
06:55:40 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
06:55:41 <lambdabot>   No instance for (GHC.Num.Num (a -> t))
06:55:41 <lambdabot>    arising from a use of syntactic n...
06:55:50 <b_jonas> heh
06:55:51 * lispy giggles
06:56:07 <nomeata> I’m getting: Setup.hs: No (or multiple) ghc rts package is registered! when trying to use Cabal under windows, with the platform installer. any ideas?
06:56:12 <b_jonas> by the way, buubot has a more powerful plugin composition system than lambdabot
06:56:27 <Axman6> > intersperse 1 (map ((subtract 1) . (2^)) [1..])
06:56:29 <lambdabot>   [1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,1...
06:56:33 <b_jonas> but lambdabot's is powerful too, you can @@ @oeis @run stuff too
06:56:37 <b_jonas> in either
06:56:38 <nomeata> "ghc-pkg list" shows one rts package
06:56:40 * Axman6 has cr4acked the code!
06:57:04 <lispy> Axman6: the tricky part (but it has been done here) is to transform the sequence I did into powers of 2 without using any obvious numerical operations
06:57:16 <mreh> :t ()
06:57:17 <lambdabot> ()
06:57:21 <mreh> hmm
06:57:38 <mreh> :t (a,b)
06:57:39 <lambdabot> (Expr, Expr)
06:57:45 <mreh> i see
06:57:53 <Axman6> :t (,)
06:57:54 <lispy> nomeata: never heard of this problem, I wish I could offer advice
06:57:54 <lambdabot> forall a b. a -> b -> (a, b)
06:58:13 <mreh> I thought () was only a constructor, it is also a type!
06:58:25 <Twey> Indeed
06:58:26 <lispy> data () = (), essentially
06:58:29 <Axman6> nomeata: it would be worth asking in #ghc, as now is a rare time when there are people awake in there :)
06:58:50 <dcoutts> nomeata: and is there no rts registered?
06:58:53 <Twey> deriving (Enum, Show, Read)
06:58:59 <Twey> I think that's about it
06:59:02 <milaz> i'll be back :)
06:59:07 <lispy> Twey: bounded?
06:59:12 <lispy> ?instances ()
06:59:13 <lambdabot> Couldn't find class `()'. Try @instances-importing
06:59:15 <nomeata> dcoutts: there is, according to ghc-pkg
06:59:23 <lispy> @instances-importing ()
06:59:24 <lambdabot> Couldn't find class `()'. Try @instances-importing
06:59:24 <nomeata> dcoutts: (i should add that I’m running all this under wine)
06:59:27 <lispy> on
06:59:30 <Twey> lispy: Is it Bounded?
06:59:36 <Twey> I thought Bounded had to be a Num
06:59:38 <lispy> Twey: I don't actually know
06:59:44 <Twey> > maxBound :: ()
06:59:45 <lambdabot>   ()
06:59:48 <Twey> I guess so
07:00:06 <Twey> Oh
07:00:07 <lispy> and Eq
07:00:17 <lispy> and Ord
07:00:20 <Twey> deriving (Bounded, Enum, Eq, Ord, Read, Show, Monoid)
07:00:29 <Twey> Yeah, I just did :info :þ
07:00:32 <dcoutts> nomeata: ohh :-)
07:00:40 <b_jonas> @info ()
07:00:40 <lispy> Ghci didn't tell me about monoid, but it makes sense
07:00:40 <lambdabot> ()
07:00:51 <b_jonas> lispy: depends on what you import
07:00:54 <lispy> > () > ()
07:00:55 <lambdabot>   False
07:00:59 <lispy> > () < ()
07:01:00 <lambdabot>   False
07:01:02 <Twey> Needs Data.Monoid imported, yeah
07:01:19 <lispy> > group [(),(),()]
07:01:20 <lambdabot>   [[(),(),()]]
07:01:45 <copumpkin> @check \x -> length (group x) == 1
07:01:46 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
07:01:48 <lispy> > () > () || () < () -- ascii art?
07:01:50 <lambdabot>   False
07:01:59 <copumpkin> @check \x -> length (group x) <= 1
07:02:00 <lambdabot>   "OK, passed 500 tests."
07:02:22 <Axman6> lispy: lambdabot's a pretty mean art critic :(
07:02:24 <copumpkin> damn right
07:02:30 <lispy> heh
07:02:40 <lispy> ?vixen you don't like my masterpiece?
07:02:41 <lambdabot> yeah, i like
07:02:45 <lispy> phew...
07:02:49 <Axman6> lol
07:02:52 <copumpkin> ?vixen do you hate lispy?
07:02:52 <lambdabot> no, i never hate
07:03:02 <Twey> lispy: Hahaha
07:03:41 <Twey> ?vixen Ar tu kalbi lietuviškai?
07:03:42 <lambdabot> let me answer that later, okay?
07:03:46 <Axman6> @vixen map (+1) [1..10]
07:03:47 <lambdabot> how's the weather over there?
07:03:47 * Twey laughs.
07:03:48 <lispy> ?vixen would you ever date a Java programmer?
07:03:48 <b_jonas> @faq can ghc decide which pieces of ascii art are nice?
07:03:48 <lambdabot> the question isn't would i, but should i
07:03:49 <lambdabot> The answer is: Yes! Haskell can do that.
07:04:53 <b_jonas> I tried '/msg buubot call 8ball Can ghc decide which pieces of ascii art are nice?' and it says 'It is decidedly so.' confirming the output of @faq
07:05:26 <Twey> Well, it's definite then
07:05:31 <lispy> ?. vixen keal
07:05:32 <lambdabot> like those damn porn spam bots?
07:05:49 <Jafet> ?. vixen nixon
07:05:50 <lambdabot> can't do much better than great
07:05:55 * lispy read that as "porn star bots"
07:08:09 <b_jonas> lispy: that's only one step from http://www.galactanet.com/comic/view.php?strip=309
07:08:42 <joe______> i wrote my first ffi interface (to libftdi) using hsc2hs. can you please eyeball the code to let me know if you would do something better/differently?
07:08:45 <joe______> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14842#a14842
07:09:15 <Axman6> joe______: do you know you have a huge erection there?
07:10:08 <lispy> b_jonas: hah, nice
07:10:08 <mreh> @hoogle (a -> b -> c) -> [a] -> [b] -> [c]
07:10:09 <joe______> Axman6: mental erection, maybe.
07:10:10 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:10:10 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
07:10:10 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
07:11:09 <Axman6> joe______: jesus, that's massive :o
07:11:18 <Axman6> the code i mean. nice work
07:11:23 <Axman6> heh
07:11:30 <EvanR-work> its getting hot in here
07:11:34 <copumpkin> that's a ridiculous number of underscores
07:11:41 <Axman6> hmm, looks like hsc2hs is something i should learn
07:11:57 <c0w_____________> moo
07:12:05 <Axman6> nice udder
07:12:25 <joe______> i tried c2hs and i just could not understand it. hsc2hs was simpler as i could use bindings-libusb as an example to work from.
07:12:39 <Axman6> nice
07:12:56 <c0w_____________> joe______: mine is so much longer
07:13:04 <Axman6> i should write a binding to the Accelerare framework on OS X sometime
07:13:15 <Axman6> there's some damn useful stuff there
07:13:15 <c0w_____________> Axman6: that'd be nice
07:13:45 <Axman6> maybe that can be my next project after this bit torrent client that jlouis is writing
07:13:47 <b_jonas> > repeat '_'
07:13:48 <lambdabot>   "__________________________________________________________________________...
07:14:24 <Axman6> joe______: does it all need to be in IO btw?
07:14:48 <Alpounet> twanvl, ping ?
07:14:57 <twanvl> pong
07:15:00 <joe______> yes, i think so.
07:15:14 <burp> there might be already so many joe's on freenode
07:15:15 <Axman6> i don't know anything about the library, so i thought i'd ask
07:16:34 <mreh> @moo
07:16:34 <lambdabot> Maybe you meant: do map more msg todo yow
07:16:54 <mreh> heh
07:17:13 <EvanR-work> @src yow
07:17:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:17:22 <mreh> @list
07:17:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:17:47 <mreh> strange
07:18:07 <mreh> lambdabot does not have special cow powers
07:18:25 <EvanR-work> gem activated
07:19:11 <mreh> super cow powers I should say
07:20:24 <sinelaw> @karma c
07:20:24 <lambdabot> c has a karma of 0
07:20:36 <roconnor> c++
07:20:40 <Axman6> how odd
07:20:45 <burp> you can't give c karma :(
07:20:54 <Axman6> @karma c
07:20:54 <lambdabot> c has a karma of 0
07:21:00 <Axman6> @karma c++
07:21:00 <lambdabot> c++ has a karma of -4
07:21:03 <Axman6> heh
07:21:04 <roconnor> @karma+ c
07:21:05 <lambdabot> c's karma raised to 1.
07:21:13 <burp> oh :)
07:21:52 * Axman6 devises an evil plan to change his nick to Axman6++ and become really popular to whore karma 
07:22:17 <benmachine> c++--
07:22:39 <Botje> except + is not allowed in nicks :)
07:22:50 <Axman6> foiled!
07:24:21 <mreh> @karma mreh
07:24:21 <lambdabot> You have a karma of 1
07:24:24 <mreh> w00t
07:24:36 <benmachine> @pl \x -> Axman6 ++ x
07:24:37 <lambdabot> (Axman6 ++)
07:24:43 <mreh> lol
07:25:06 <Alpounet> @karma+ c++
07:25:06 <lambdabot> c++'s karma raised to -4.
07:25:08 <Alpounet> :-p
07:25:11 <mreh> > "Axmann" ++ "++"
07:25:13 <lambdabot>   "Axmann++"
07:25:13 <joe2> anyone familiar  with Bindings-libusb?
07:25:19 <mreh> > "Axman6" ++ "++"
07:25:20 <lambdabot>   "Axman6++"
07:25:43 <joe2> why are the c files inlines.c and core.c in the src directory?
07:25:53 <joe2> they seem to the c source code for the library?
07:27:05 <benmachine> do people think there should be a TLS library in naitve Haskell, or is that sort of thing better to FFI?
07:27:27 <Axman6> benmachine: i'd like to see it done in haskell
07:27:35 <benmachine> hmm
07:27:55 <benmachine> what scale of task do you think it would be?
07:29:11 <benmachine> probably beyond me
07:29:28 <benmachine> but maybe I can start something that someone else can finish
07:29:46 <Alpounet> :D
07:31:33 <roconnor> what is TLS?
07:31:52 <Zao> Thread Local Storage?
07:32:10 <Zao> Or the SSL-like crypto thingie session doohickey?
07:32:11 <jfischoff> hey this is my first time using irc chat so I apologize in advance for a faux pas
07:32:12 <benmachine> transport layer security
07:32:14 <Zao> Leaning towards the latter.
07:32:21 <benmachine> the latter yes
07:32:28 <Zao> jfischoff: You will burn in heck for five minutes. :)
07:32:28 <jfischoff> what's the context?
07:32:34 <jfischoff> hehe
07:32:36 <benmachine> jfischoff: hi have a seat
07:32:37 <Zao> 16:26 < benmachine> do people think there should be a TLS library in naitve Haskell, or is that sort of thing better to FFI?
07:32:57 <jfischoff> bernmachine: thanks
07:33:03 <roconnor> there should be a native TLS library *and* it is the sort of thing that would be better to FFI.
07:33:03 <Jafet> FFI for obvious reasons
07:33:18 <benmachine> roconnor: hah
07:33:19 <Jafet> Haskell is too high level to do TLS
07:33:28 <osfameron> TLS?
07:33:41 <Jafet> Especially if you're doing a server end
07:33:58 <Zao> Jafet: Never hurts to have both.
07:34:00 <jfischoff> Has anyone had trouble install the 2.4.0.0 version of template-haskell?
07:34:00 <benmachine> Jafet: mm, most of the reason I'm wondering is because we have the HTTP package in pure Haskell
07:34:05 <Jafet> No, it will hurt.
07:34:07 <Zao> Having to rely on hard to build third party libraries is bothersome.
07:34:08 <Jafet> Badly.
07:34:23 <benmachine> jfischoff: yeah I did, I think you need to get the new GHC to get new TH
07:34:26 <Zao> Especially on Windows, I'd say.
07:34:38 <jfischoff> bernmachine: cool thats what I thought
07:34:40 <Jafet> Especially if there is someone who doesn't like your server.
07:34:46 <Jafet> And has some smarts.
07:34:48 <benmachine> Jafet: you think Haskell will be too slow?
07:35:16 <benmachine> (fwiw, I'm thinking about client, not server, although both'd be nice)
07:35:18 <sinelaw> what's the easiest way to visualize .prof output?
07:35:20 <jfischoff> bernmachine: dumb question. So after I install the new version of ghc, should I uninstall the old version and re-install all packages
07:35:42 <benmachine> jfischoff: I doubt you'll need to do all that
07:35:45 <Jafet> Haskell does not allow you to control swapping, memory usage, or a bunch of other things essential to security on a real-life system
07:35:46 <benmachine> most things will work fine
07:36:08 <j4cbo> Jafet: what does that have to do with writing a TLS implementation?
07:36:18 <roconnor> whoa! you can have multiple patterns share one branch in an ocaml match statement!
07:36:19 <Jafet> Not to mention you'll have to blind everything unless you use custom numeric libraries
07:36:22 <poucet> Jafet: nor does C or C++, that is usually the job of the operating system.  With syscalls you can affect that.
07:36:30 <j4cbo> Jafet: you're working about resource exhaustion attacks, or what?
07:36:31 <benmachine> jfischoff: by the way, my name doesn't have an r in it :P you can save typing people's names by doing the first few letters and pressing tab, usually
07:36:36 <j4cbo> worrying*
07:36:47 <Jafet> poucet, practically speaking, you can do those much better in C and C++
07:36:48 <Axman6> "instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b)" :o
07:37:05 <benmachine> :o
07:37:10 <roconnor>  "instance (CoArbitrary a, Arbitrary b) => Arbitrary (a -> b)"
07:37:13 <jfischoff> benmachine: so I should just install the new ghc and I'll be good, or is there another step
07:37:16 <Jafet> Someone mentioned speed too. I don't think that will be a difficult to solve issue, but it's there.
07:37:26 <jfischoff> benmachine: thanks for the pointer :)
07:37:28 <benmachine> jfischoff: I don't know because I haven't done it yet, but I think that's all you have to do
07:37:39 <jfischoff> benmachine: cool
07:37:44 <benmachine> jfischoff: oh but wait, I think I heard it's easier to install cabal-install 0.8 before you do so
07:37:44 <j4cbo> Jafet: what *are* you going on about?
07:37:55 <Axman6> j4cbo: what are you trying to do?
07:38:03 <Axman6> uh, jfischoff, not j4cbo
07:38:09 <j4cbo> yeah, him, not me :P
07:38:19 <Jafet> Security against side channel attacks.
07:38:31 <jfischoff> Axman6: Trying to get template-haskell 2.4.0.0 to work
07:38:40 <Jafet> Resource exhaustion as a DOS sounds unlikely
07:38:43 <Axman6> jfischoff: and you need to update ghc?
07:38:48 <Axman6> to 6.12.1?
07:38:52 <j4cbo> Jafet: that's an interesting point, but does your average C implementation of TLS get that right too? :P
07:38:53 <jfischoff> Axman6: appearantly
07:39:04 <Jafet> Of course not. That's why you just use openssl or gnutls.
07:39:08 <jfischoff> Axman6: never updated before
07:39:12 <Jafet> That is not from the debian repo.
07:39:21 <Axman6> jfischoff: well, if you're going to do that, i strongly recommend running `cabal install 'cabal-install >= 0.8'` first
07:39:25 <Adamant> Jafet: you have to add that caveat now
07:39:32 <jfischoff> Axman6: cool
07:39:32 <j4cbo> Jafet: and, side channel attacks are only a concern if there are people attacking you with access to a close enough side channel.
07:39:34 <Jafet> Yes, yes I do.
07:39:36 <Adamant> yay static analysis
07:39:44 <Jafet> j4cbo, and there always are.
07:39:50 <Jafet> It's cheaper than the alternatives.
07:40:15 <jfischoff> Axman6: Will cabal switch over to installing into the new version after the update?
07:40:16 <j4cbo> Jafet: are there attacks that need nothing more than the timing of the packets going out over the wire? O_o
07:40:19 <benmachine> there is a gnutls FFI package but I think it is decidedly naff
07:40:32 <Jafet> Sure. That's a timing attack.
07:40:40 <Axman6> j4cbo: it'll use whatever ghc you have installed. but cabal-install 0.8 is needed to work with 6.12.1
07:40:53 <j4cbo> Jafet: as opposed to the timing behavior of other processes on the machine.
07:41:26 <Jafet> Timing of Haskell is difficult to control in a fine-grained way, as far as I know
07:41:26 <j4cbo> in any case, i agree with you in principle; there are 347592384759238475 reasons not to implement crypto code yourself, and the risk of side-channel attacks is just one (albeit important) one.
07:41:35 <Adamant> basically unless higher-level languages provide explicit hooks for it, doing secure cryptography in them is hard. C has included most of these more or less by luck
07:41:40 <jfischoff> Axman6: can 6.12.1 use the 6.10.3 cabal packages?
07:43:08 <Jafet> Even if Bruce were to implement TLS in Haskell (which he probably wouldn't, because it's silly as I mentioned), I would view it with suspicion due to how it will inevitably be mangled by, say, the next GHC version
07:43:22 <Jafet> Ie. Haskell isn't stable enough to do this sort of crypto in.
07:43:26 <Jafet> Yet.
07:43:47 <Axman6> jfischoff: no
07:43:50 <Saizan_> jfischoff: you've to rebuild them
07:44:02 <jfischoff> alright
07:44:24 <Axman6> Jafet: why do you say that?
07:44:40 <Jafet> Say what?
07:44:49 <jfischoff> Axman6, Saizan_ is there an automated or easy way to do that?
07:44:55 <Axman6> that newer version of ghc will break them
07:45:28 <Jafet> It might include new optimizations, or schedule evaluation differently, or vindaloo knows what
07:46:05 <Kim^Walkman> How do I troubleshoot a segmentation fault that occurs when running “cabal update”?
07:46:26 <Saizan_> jfischoff: no, but "cabal install"-ing as you need them is not that problematic
07:46:40 <lispy> Kim^Walkman: start by getting more info, cabal update -v3
07:46:49 <Adamant> Axman6: a persistent problem with crypto code is compilers becoming too smart for their own good and either optimizing things out, or ignoring hints to the compiler that should really be mandatory in security terms.
07:46:54 <Saizan_> jfischoff: there's a patch to record the user-installed packages so you can rebuild them with a new ghc, but i'm not sure if it got merged yet
07:47:06 <lispy> Kim^Walkman: you can also benefit from 'strace', possibly
07:47:09 <Axman6> Adamant: huh, did not know that :)
07:47:13 <jfischoff> Saizan_: true, but cabal -update-to-new-version would be better :)
07:47:25 <Kim^Walkman> “cabal update -v3” gives no difference; the same “Segmentation fault” line
07:47:47 <lispy> Kim^Walkman: hmm...maybe, cabal -v3 update?
07:47:52 <jfischoff> Saizan_: cool, how can I find out more about that?
07:47:55 <lispy> cabal should be more verbose
07:48:02 <Kim^Walkman> lispy: Hehe, no change there either
07:48:02 <j4cbo> "compilers getting too smart for their own good" is also a problem in kernels written in C, by the way
07:48:03 <lispy> Kim^Walkman: do any cabal commands work?
07:48:07 <Axman6> lispy: in some ways, and less in others
07:48:15 <Kim^Walkman> lispy: Trying them all atm
07:48:17 <Saizan_> jfischoff: either the cabal trac or the cabal-devel mailing list
07:48:18 <Adamant> j4cbo: yup, and even C is bad enough
07:48:30 <jfischoff> Saizan_: thanks
07:48:32 <lispy> Axman6: Hehe, I just meant with -v3
07:48:57 <Jafet> It's a much smaller problem in C, j4cbo, for both technical and cultural reasons
07:49:05 <lispy> Kim^Walkman: well, when in doubt, 'strace cabal update' and try to see where it segfaults at
07:49:34 <j4cbo> Jafet: it becomes a bigger problem when the current definition of "the one true c compiler" changes
07:49:43 <Saizan_> what sort of optimizations?
07:50:01 <Jafet> Different C compilers usually produce similar behaving object code
07:50:21 <Saizan_> do crypto really care about the evaluation order when there aren't side effects?
07:50:41 <Kim^Walkman> No cabal commands work, trying to read some sense from the trace (never used it before)
07:50:47 <j4cbo> Saizan_: the problem is that sometimes you have to have a *much* broader definition of 'side effect' than most languages recognize
07:50:52 <Kim^Walkman> (--version and --help does work, however)
07:51:07 <Saizan_> j4cbo: such as?
07:51:09 <j4cbo> memory allocated, time taken, power consumed, cache lines hit... those are all side effects
07:51:23 <lispy> Kim^Walkman: it gives you all the system calls that are made
07:51:23 <j4cbo> and recognizable from "outside" under certain circumstances
07:51:26 * hackagebot upload: Agda 2.2.6 - A dependently typed functional programming language and proof assistant (NilsAndersDanielsson)
07:51:31 <lispy> Kim^Walkman: generally you want to work backwards
07:51:34 <Saizan_> i see
07:51:54 <Kim^Walkman> Syscalls and their arguments plus return values I see
07:52:26 * hackagebot upload: Agda-executable 2.2.6 - Command-line program for type-checking and compiling Agda programs (NilsAndersDanielsson)
07:52:39 <copumpkin> omg a new agda
07:52:57 <Adamant> should renick yourself happycopumpkin
07:53:09 <Adamant> :P
07:53:20 <Twey> Haha
07:57:24 <Kim^Walkman> The segfault has something to do with the cabal configuration file: as long as it exists every command fails instantly with segfault (my guess is some error reading it)
07:57:28 <Alpounet> copumpkin, here is your xmas gift
07:57:30 <Alpounet> :-p
07:57:39 <Kim^Walkman> If I remove the file, all commands work (just installed network library)
07:58:01 <Kim^Walkman> Naturally, after the install a new config file was written and the same segfaults appear ^.-
08:00:32 <Saizan_> Kim^Walkman: does readFile works in a program compiled on your machine
08:00:51 <Kim^Walkman> Saizan_: regular haskell function?
08:01:09 <Saizan_> ?hoohle readFile
08:01:09 <lambdabot> Prelude readFile :: FilePath -> IO String
08:01:09 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
08:01:09 <lambdabot> System.IO readFile :: FilePath -> IO String
08:01:18 <Saizan_> Kim^Walkman: yeah, the first one there ^^^
08:02:08 <jlouis> Axman6: I am around now :)
08:02:09 <Kim^Walkman> Saizan_: No issues with readFile whatsoever
08:02:16 <Axman6> o/ jlouis
08:02:49 <jlouis> I am on the CET timezone btw
08:03:21 <Axman6> i've soend a fair amoount of time today trying to (again) rewrite the BCode module to use Data.Binary, without jmuch luck sadly
08:03:33 <Axman6> no idea where CET is :\
08:04:01 <jlouis> Denmark, Germany, ...
08:04:10 <FauxFaux> 5pm ish.
08:04:27 <jlouis> I'd guess most of Europe is on CET
08:04:32 <Axman6> ah ok
08:04:43 <copumpkin> Alpounet: :)
08:04:45 <FauxFaux> Assumably Central Europe, given the name. =p
08:06:40 <jlouis> Axman6: what makes it hard to use Data.Binary?
08:06:50 <Axman6> no support at all for failure
08:07:08 <Axman6> if a parser fails, you don't have any chance to recover
08:07:39 <Axman6> i can see why it's implemented like that though, the parser type is something like ByteString -> (# a, ByteString #)
08:08:13 <Axman6> so, should be damn fast, but needs to be used in the right situation (ie, what it was designed for: serialising and deserialising haskell types)
08:08:40 <copumpkin> deserializing from trusted sources, I guess ;)
08:08:42 <lispy> Axman6: this is why cerial exists.
08:08:51 <jlouis> Speed is not of the essence when it comes to torrent files
08:09:00 <lispy> Axman6: some people were not happy with the way errors happen in Data.Binary
08:09:01 <jlouis> For the wire protocol however...
08:09:25 <Axman6> i thought it exiisted to just use for use with strict bytestrings. i'll take another look at it :)
08:09:37 <jfischoff> any graphics people here?
08:09:42 <HugoDaniel> me
08:09:49 <HugoDaniel> jfischoff: 'sup ?
08:09:54 <Axman6> jlouis: yeah, it was your blog post on parsing the wire protocol that got me really interested in the project :)
08:10:01 <jlouis> and a fail in the wireproto equals disconnect per specification, so it might be easier
08:10:08 <lispy> Axman6: cerial does assume your data is small enough to fit in memory, unlike binary which likes to use streams
08:10:09 <jfischoff> HugoDaniel: just interested in how you are doing development
08:10:21 <HugoDaniel> in haskell ?
08:10:27 <jfischoff> HugoDaniel: are you doing 2d or 3d stuff
08:10:30 <HugoDaniel> 3d
08:10:31 <jfischoff> HugoDaniel: yeah
08:10:35 <Axman6> lispy: that'd probably be ok here, since we're working with data usually less than 1MB
08:10:44 <jfischoff> HugoDaniel: any in haskell
08:10:52 <HugoDaniel> but im not getting paid for it :P just hobby right now
08:10:59 <HugoDaniel> yes, in haskell
08:11:03 <jfischoff> what are you working on?
08:11:11 <HugoDaniel> parallel rendering with haskell
08:11:14 <HugoDaniel> real-time
08:11:17 <HugoDaniel> rasterization
08:11:18 <Axman6> my largest torrent file i could find was 90KB
08:11:24 <jfischoff> using opengl?
08:11:25 <lispy> Axman6: I don't know much about either library, except I went to a lightning talk recently where dons described binary and tselliot described cerial
08:11:25 <jlouis> Axman6: I was pretty happy with the fact that an applicative made it as small as my Erlang code
08:11:28 <HugoDaniel> yes
08:12:00 <jfischoff> do you have a non realtime rasterizer that you use to test?
08:12:10 <HugoDaniel> no
08:12:14 <jfischoff> me either
08:12:33 <jfischoff> but I feel like having one would simplify my development process
08:12:35 <Axman6> lispy: cereal looks very nice indeed. i'll have to give it a go
08:12:42 <HugoDaniel> i just have some ideas that i would like to see implemented, and currently haskell is "the right thing" to put them working fast
08:12:57 <HugoDaniel> jfischoff: i use openscenegraph quite a lot, but thats c++
08:13:03 <jfischoff> right
08:13:07 <lispy> Axman6: ah,I keep mispelling it...Yeah, I guess it's not that different from Binary in api
08:13:24 <jfischoff> I feel like haskell needs a better raytracer for rasterization
08:13:30 <Axman6> yeah, but it has alternative instances
08:13:31 * lispy would like to someday make a scene graph for haskell
08:13:35 <jfischoff> to test algo before going real time
08:13:37 <Axman6> and monadplus
08:13:48 <HugoDaniel> i dont like scene graphs that much :)
08:14:01 <HugoDaniel> but i like the open scene graph approach, even though its quite bloated
08:14:27 <jfischoff> yeah they have their place
08:14:31 <lispy> Programming at the level of a state machine (OpenGL) is not what FP and Haskell are all about though :)  We should come up with ways to describe what we want to render and use those representations
08:14:34 <jfischoff> I would like a collada importer
08:14:49 <jfischoff> lispy: exactly
08:14:52 <Twey> lispy: Like FieldTrip!
08:15:06 <lispy> Twey: I'm not familiar with FieldTrip
08:15:08 <jfischoff> Twey: but that still renders to opengl right?
08:15:10 <jlouis> Axman6: mmm, monadplus implies monad implies Applicative :)
08:15:20 <HugoDaniel> jfischoff: want to work on a collada importer in haskell ? it should be easy
08:15:30 <Axman6> well, i'm not all that up on my class hierarchy :)
08:15:30 <jfischoff> HugoDaniel: yeah
08:16:00 <maltem> lispy, sounds like the description of a … renderer
08:16:02 <jfischoff> I already am importer some data using tagsoup
08:16:12 <jfischoff> maltem: yep, that
08:16:13 <jfischoff> s
08:16:16 <jfischoff> what we need
08:16:19 <Twey> jfischoff: Well, you've got to render it eventually
08:16:35 <jfischoff> Twey: no doubt, but I would like a pure version
08:16:50 <Twey> To which I say, ‘‽’
08:16:58 <Twey> Oh, you mean a function from Scene -> Image?
08:17:10 <jfischoff> Twey: yep
08:17:13 <Twey> I see
08:17:15 <Twey> Hmm
08:17:18 <jfischoff> for testing
08:17:33 <jfischoff> then optimization, i.e. opengl or whatever
08:17:39 <Twey> (I think such a thing would still want to use the graphics card in the background)
08:17:47 <HugoDaniel> i currently have a half baked parallel renderer, that abstracts opengl and IO, and all those impure nonsenses common in renderers
08:17:50 <jfischoff> not initially
08:17:51 <Twey> (though of course it could be unsafePerformIO'd)
08:18:11 <maltem> Btw, the suggestion to (attempt to) re-implement iteratee yourself, in order to understand what it's all about, turned out to be quite applicable :)
08:18:26 <lispy> maltem: cool
08:18:36 <HugoDaniel> unsafePerformIO is ugly :(
08:18:43 <jfischoff> I think by trying to go to opengl right away we are jumping the gun
08:18:43 <lispy> maltem: Will you be posting some articles / tutorials to help us? :)
08:18:53 <maltem> lispThe very problem for me was to get used to
08:18:57 <maltem> oops
08:19:01 <HugoDaniel> i keep getting haunted by the fact that we are going to pay the price of unsafePerformIO in the future
08:19:09 <jfischoff> HugoDaniel: have you worked with collada before?
08:19:22 <HugoDaniel> no, but i have heard ugly things about it
08:19:27 <jfischoff> yes
08:19:27 <Berengal> HugoDaniel: We are already paying the price for it now
08:19:31 <jfischoff> they are all true
08:19:56 <jfischoff> one thing I tried was to convert the xsd to a dtd to use the DtdHaskell app
08:20:00 <Axman6> is there any way to take a string bytestring and make it a lazy bytestring?
08:20:02 <jfischoff> didn't really work
08:20:08 <HugoDaniel> :/
08:20:16 <nomeata> hmm, it seems that cabal does not know about any packages known to ghc-pkg. (still trying to use cabal under wine). any hints?
08:20:20 <jfischoff> yeah, but something like that is the way to go
08:20:22 <HugoDaniel> why dont you use HaXml ?
08:20:22 <ben0x539> Axman6: Well, split it up into a list of strict bytestrings and use fromChunks
08:20:36 <Axman6> ah that's right
08:20:38 <jfischoff> DtdToHaskell is part of haxml
08:20:42 <HugoDaniel> ah :) sorry
08:20:55 <jfischoff> Haxml is a bitch
08:21:15 <Axman6> @hoogle ByteString -> ByteString
08:21:15 <lambdabot> Data.ByteString copy :: ByteString -> ByteString
08:21:15 <lambdabot> Data.ByteString init :: ByteString -> ByteString
08:21:15 <lambdabot> Data.ByteString reverse :: ByteString -> ByteString
08:21:15 <jfischoff> or I just don't know what I am doing...or both
08:21:26 <maltem> lispy, maybe, even though I fear to initiate an everyone-writes-an-iteratee-tutorial wave. The very problem for me was to get used to the names they give to things: iteratee, enumerator, and so on. I may have called them processes/states, folds, things like that.
08:21:27 <Axman6> @hoogle L.ByteString -> BS.ByteString
08:21:27 <lambdabot> Parse error:
08:21:27 <lambdabot>   --count=20 "L.ByteString -> BS.ByteString"
08:21:27 <lambdabot>               ^
08:21:30 <Axman6> :\
08:21:41 <nomeata> Actually, no, cabal info shows some packages as installed, but not rts
08:21:50 <Axman6> @hoogle Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString
08:21:50 <lambdabot> Parse error:
08:21:50 <lambdabot>   --count=20 "Data.ByteString.Lazy.ByteString -> Data.ByteString.ByteString"
08:21:50 <lambdabot>                  ^
08:21:51 <ben0x539> @hoogle fromChunks
08:21:52 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
08:21:52 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
08:21:55 <nomeata> Hmm, same on linux, so that is not it.
08:22:21 <Axman6> ben0x539: not sure that helps me at all
08:22:36 <ben0x539> @hoogle toChunks
08:22:36 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
08:22:36 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
08:22:37 <ben0x539> Oh well
08:22:47 <Axman6> oh maybe it does
08:22:53 <jlouis> Axman6: you could go with strict bytestrings all over I think
08:23:06 <Axman6> sha1 seems to need a lazy one
08:23:13 <jfischoff> HugoDaniel: Haskell also needs a Mesh class
08:23:14 <jlouis> ah, yes
08:23:17 <jlouis> nogo then
08:23:20 <jfischoff> with some standard mesh ops
08:23:26 <Axman6> but, this is not necessarilly a problem
08:23:45 <HugoDaniel> jfischoff: i have done a incomplete nurbs module in haskell, ill try to hackage it up when its more or less stable
08:23:54 <jfischoff> interesting
08:23:57 <HugoDaniel> yes, we need to get together and build these stuff
08:24:02 <jfischoff> yes
08:24:17 <jfischoff> how should we contact each other?
08:24:29 <HugoDaniel> when i think about meshes, specially triangular ones, i usually end up spending the rest of the day reading crazy papers from the 90's about the subject :/
08:24:32 <jfischoff> never used irc before
08:24:34 <Axman6> ok, now i need a way to go from lazy back to strict...
08:24:43 <jfischoff> hehe
08:24:54 <Axman6> oh no i don't
08:25:10 <jfischoff> is it kosher to just write our emails?
08:25:16 <HugoDaniel> jfischoff: do you plan to hang around here ?3
08:25:23 <jfischoff> yeah
08:25:37 <jfischoff> I'm at work, so I'll just stayed signed it
08:25:39 <jfischoff> in
08:25:42 <HugoDaniel> ok, we can meet around here, or perhaps gather in a special ##
08:25:45 <maltem> lispy, here's something that might go into a tutorial: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14847
08:25:46 <Axman6> jlouis: ... you got any problems with hashInfoDict being the only function returning a lazy bytestring?
08:25:52 <jfischoff> cool
08:26:01 <jfischoff> I would like to get a group together
08:26:34 <mreh> preflex: seen mmorrow
08:26:34 <preflex>  mmorrow was last seen on #haskell 1 hour, 42 minutes and 38 seconds ago, saying: hpaste.org works now
08:26:42 <jfischoff> there is a wiki page devoted to 3D. Still waited for access to the wiki :(
08:26:54 <mreh> mmorrow: speak to me
08:27:08 <jlouis> Axman6: not really, unless it messes up the rest of the code too much. hashInfoDict is used to get a Digest type so we can process infohashes
08:27:31 <jlouis> and infohashes will be sent over the wire
08:27:33 <Axman6> not sure what you mean
08:27:39 <HugoDaniel> i think haskell is definetly going to win with the upcoming many-core cpu paradigm
08:27:42 <Axman6> well, shouldn't be too much of a problem
08:27:51 <jfischoff> yep, totally agree
08:28:08 <jlouis> Axman6: Try it. We can always decide it was bad later
08:28:10 <jfischoff> that's way I think moving away from opengl is a good idea
08:28:22 <HugoDaniel> jfischoff: software ftw! :)
08:28:24 <jlouis> if it turns out to be
08:28:40 <eldragon> jfischoff, yes, due to impedance mismatch
08:28:45 <Axman6> jlouis: yeah, my experience has been that these changes are really easy to fix and implement, so we shouldn't have a problem
08:28:55 <jfischoff> eldragon: ?
08:29:17 <jfischoff> HugoDaniel: what's ftw?
08:29:37 <Axman6> for the win
08:29:44 <jfischoff> oh
08:29:46 <jfischoff> got it
08:29:51 <HugoDaniel> for the win
08:29:57 <jfischoff> :)
08:30:24 <jlouis> Axman6: Try it. We can always decide it was bad laterls
08:30:31 <lispy> maltem: so in your version, you load the whole stream at once?
08:30:34 <jlouis> bah, mistype
08:30:47 <mreh> is there a haskell scripting extension?
08:31:01 <Axman6> i'm liking this whole having yopur own branch and being able to mess around with it thing
08:31:11 <maltem> lispy, how do you mean?
08:31:22 <Twey> mreh: You mean like HsLua?
08:31:23 <lispy> mreh: if you use literate haskell you can include #! runghc at the top
08:31:43 <HugoDaniel> yeah, #! is great :)
08:31:43 <mreh> more like, running external binaries from a haskell program and capturing output
08:31:48 <lispy> mreh: and then you can have haskell files that are treated like scripts by your shell
08:31:57 <mreh> lispy: but that is quite cool
08:32:01 <lispy> mreh: ah that's in the process package, IIRC
08:32:26 <lispy> maltem: oleg's streams have Chunk as a constructor
08:32:36 <benmachine> runghc has quite a high startup overhead though, doesn't it?
08:32:54 <lispy> maltem: and when an iteratee looks at a stream it has to handle about 3 cases.  EOF, Chunk [], and Chunk normal
08:33:05 <maltem> lispy, in my code it's "Symbol"
08:33:24 <lispy> maltem: So you have Symbol "" as a case?
08:33:35 <maltem> I consider the fact that a symbol is a chunk as an implementation detail ;)
08:34:12 <lispy> maltem: I think this is one of the great hurdles of writing correct code with the iteratees
08:34:28 <lispy> IMO, we need to make the three cases of a stream separate and enforce the handling of them at the type level
08:34:30 <maltem> lispy, I probably will have when I pursue this further
08:34:49 <lispy> I was talking to John Lato about this
08:35:02 <lispy> Using a gadt for Stream might be appropriate
08:35:08 <maltem> At the moment I'm not sure why I need Symbol "" as a case
08:35:40 <lispy> maltem: that's the empty chunk case.  But it isn't eof, so you should have the iteratee request more
08:35:49 <lispy> (potentially anyway)
08:35:52 <jlouis> Axman6: even better. git can rewrite the history as you see fit, so you usually just mess around and then prepare a digestible patch set for others
08:37:20 <maltem> lispy, I suppose that's not important as long as I'm processing merely files, and not have to explicitly wait for data (from the network, ...)?
08:37:31 <lispy> data EOF; data GoodStream; data Stream e state where { SEOF :: Stream e EOF; Symbol :: e -> Stream e GoodStream } -- just some thoughts
08:38:07 <lispy> maltem: Well, imagine that your enumerator doesn't read the file all in one go.  It just gives you 4k as the first Symbol
08:38:44 <maltem> Well that's what I'm doing?
08:38:44 <lispy> maltem: what you have is a good start, and what I'm asking for is actually pretty advanced as far as iteratees go
08:39:37 <pmurias> what's a good/recommended/sane way of using a C++ library from haskell?
08:39:51 <Twey> pmurias: Abandon Hope, All Ye Who Enter Here
08:39:52 <Zao> Build C wrappers?
08:40:05 <EvanR-work> i was going to say, 'probably by not doing it'
08:40:11 <Twey> Linking to C++ is a nightmare
08:40:38 <Axman6> jlouis: "do {logMsg logC "Incorrent length in receiver, dying!"; undefined}" heh
08:41:18 <Zao> pmurias: I believe the canonical way is to wrap all member functions in free functions and make a create/destroy free function per type you would new/delete from a C++ context.
08:41:24 <Zao> C-ify the interface.
08:41:28 <HugoDaniel> C++0x is the death of the artist :)
08:43:23 <lispy> maltem: I forget off the top of my head what oleg would do in the case of an empty Symbol when counting bytes
08:43:24 <Eelis> someone should write a C++ <-> Haskell interop library using all kinds of fancy metaprogramming trickery, in the style of Boost.Python
08:45:02 <Twey> Eelis: I believe that the problem is that each compiler (and each compiler version) has its own ABI
08:45:19 <Twey> So you'd have to build one for each…
08:45:42 <Eelis> Twey: i have no idea what the details would look like, but they pulled it off for Boost.Python
08:45:49 <lispy> maltem: my main point is that since streams appear to have a 2-3 distinct states, it would be really nice if we could capture that with types
08:46:03 <Twey> Eelis: Only, I think, because it relies on the two being compiled with the same compiler suite
08:46:15 <Twey> (i.e. there are C interfaces in there)
08:46:39 <Eelis> Twey: GHC can also work with C interfaces
08:46:57 <lispy> maltem: An iteratee might take functions, (Stream e EOF -> a), (Stream e More -> a), and (Stream e EmptyChunk -> a), (not sure if those are the right types) so that people have to provide the right bits to make it work
08:47:01 <Twey> Yes, but it would then depend on a C compiler
08:47:05 <Twey> Wait, does it already?
08:47:10 <Eelis> beats me
08:47:23 <EvilTerran> it depends on perl <.< >.>
08:47:42 <Twey> EvilTerran: Shh :þ
08:47:57 <EvilTerran> and that depends on a C compiler, so indirectly... :P ... but i'm guessing that's not the sort of dependency you had in mind
08:48:21 <maltem> lispy, ok. I'll still have to find out what the special rôle of the empty chunk is, though.
08:48:28 <Twey> maltem: I love you
08:48:32 <Twey> <3
08:49:07 <Badger> But... but Twey... you said we'd be together forever.
08:49:35 <Twey> Badger: Hah!  You haven't the courage to use a circumflex on ‘role’ in public.  :þ
08:49:51 * EvilTerran notes that there's nothing inherent about the evil mangler that makes it un-implementable in haskell
08:50:08 <EvilTerran> i guess the problem would be regression testing
08:50:15 <Badger> Twey: I was going to do it, honest!
08:50:19 <Twey> EvilTerran: How so?
08:50:20 <EvilTerran> (or proof of equivalence-or-refinement)
08:50:21 <maltem> Twey, oops. Is there a special connotation to doing that?
08:50:26 <Twey> maltem: No, no.
08:50:32 * maltem is relieved
08:50:34 <Twey> maltem: It's just very rare these days.
08:50:38 <Twey> maltem: I thoroughly approve.  :þ
08:50:44 <maltem> heh
08:51:09 <EvilTerran> Twey, "how so" with regard to the "nothing inherent", or the "problem = regression testing"?
08:51:23 <Twey> EvilTerran: With regards to regression testing
08:51:56 <lispy> maltem: I think ultimately it's just a way for the enumerator and the iteratee to communicate
08:52:09 <lispy> maltem: I'm interested in what you learn about it
08:52:38 <EvilTerran> Twey, i guess that wasn't quite the phrase i wanted... i meant that any cross-language re-implementation could have countless subtle differences to the original regardless of what you're re-implementing, and the evil mangler seems particularly fragile wrt edge cases already
08:52:50 <Twey> EvilTerran: Ah, I see
08:53:18 <EvilTerran> particularly when you're going from perl, which is mostly edge cases :P
08:53:25 <maltem> lispy, communicate what?
08:53:41 <Twey> Haha, yes
08:55:06 <lispy> maltem: The enumerator is trying to fetch data and the iteratee wants to process one step of the stream.  And I think sometimes you need to have clear communication between those stages
08:55:24 <lispy> "Hey, I need more data!"  "Okay, here you go!"
08:55:33 <lispy> I could be wrong
08:55:42 <lispy> I'm also still learning iteratees
09:00:10 <maltem> You know, I don't grant my k functions the right to "want" something. They just get chunks of data to process. If the chunk is, by accident, empty, they should handle it appropriately. If they're interested in the first 17 bytes, but the next chunk has only 2, why then they should return an appropriate continuation. - I'm interested when I'll be bitten :)
09:00:18 <EvanR-work> doesnt haskell also use mangling for linking purposes
09:00:28 <EvanR-work> s/haskell/ghc/
09:01:08 <Axman6> Mortomes: what's this ins reference to?
09:01:40 <pikhq> EvilTerran: Yeah, absolutely nothing about the mangler that prevents in being in Haskell.
09:01:44 <Axman6> uhm maltem, not Mortomes
09:01:50 <pikhq> However, what sort of person is crazy enough to touch the mangler again?
09:01:58 <sinelaw> when when running time profile, does a cost center include the time wasted on lazily evaluating things that are outside this expression?
09:02:08 <lispy> Axman6: maltem and I are discussing iteratees
09:02:23 <lispy> Axman6: have you understoond them?
09:02:24 <maltem> Axman6, - ahem, what lispy just said
09:03:06 <Axman6> ha, nope. i think i once got the very basic general idea, but the code is far too confusing for me
09:03:41 <lispy> Axman6: this is a common view to hold
09:03:52 <lispy> and that's kind of frightening for using them
09:04:00 <lispy> "Will anyone be able to maintain this code?"
09:04:14 <lispy> "How will we reason about the correctness if simple things are hard to grok?"
09:04:38 <Axman6> "... what the hell has Oleg been smoking!"
09:04:42 <maltem> Axman6, hence my initial remark that I consider the suggestion to toy-reimplement them quite helpful. I mainly find the chosen names confusing
09:05:36 <lispy> I found that using continuations is confusing :)
09:06:07 <mreh> @hoogle Rational a, Real b => a -> b
09:06:07 <lambdabot> Parse error:
09:06:07 <lambdabot>   --count=20 "Rational a, Real b => a -> b"
09:06:07 <lambdabot>                        ^
09:06:18 <maltem> My analogy for continuations is an automaton with a functional state ;)
09:06:25 <Twey> @hoogle (Rational a, Real b) => a -> b
09:06:25 <lambdabot> Warning: Unknown class Rational
09:06:26 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:06:26 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:06:35 <Axman6> maltem: yeah, i think academics often misname things, and this creates mental barriers to entry to the concept
09:07:19 <mreh> academics are poo-poo heads
09:07:23 <jlouis> Axman6: dying is a problem right now. We need to control what happens when a thread dies
09:07:51 <mreh> > 2 % 1
09:07:52 <lambdabot>   2 % 1
09:07:56 <mreh> what does that mean?
09:07:56 <jlouis> &21
09:07:58 <mreh> 2?
09:08:16 <mreh> semantically
09:08:29 <EvanR-work> > 2 `mod` 1
09:08:30 <lambdabot>   0
09:08:38 <Zao> mreh: The rational number 2/1.
09:08:52 <Zao> http://www.haskell.org/onlinereport/ratio.html
09:08:58 <Axman6> jlouis: dies from an exception?
09:09:13 <EvanR-work> > (3%4) + (5%8)
09:09:14 <lambdabot>   11 % 8
09:09:19 <EvanR-work> \o/
09:09:42 <bgs100> Hi, I installed the Haskell Platform, and ran cabal update. It said there was a newer version, and to run cabal install cabal-install. So I did. I tried running cabal update again, and it still said there was a newer version. Do I need to add something to my $PATH or run something as root?
09:09:44 <EvanR-work> now we can compute US measurements
09:09:54 <lispy> > 4 % 6
09:09:55 <lambdabot>   2 % 3
09:10:14 <PeakerWork> > 123456789 % 987654321
09:10:15 <lambdabot>   13717421 % 109739369
09:10:34 <lispy> bgs100: when you type, cabal --version, do you get the latest one from hackage or the one from before?
09:11:06 <Axman6> bgs100: ah, yes, you probably do. you'll need ~/.cabal/bin before whereever you have the haskell platform installed
09:11:08 <PeakerWork> bgs100: Run "which cabal"
09:11:24 <PeakerWork> or you can "sudo cabal install cabal-install --global"
09:11:30 <bgs100> lispy, I didn't check before, but I get the version that Haskell Platform says it has in the distribution.
09:11:35 <Axman6> that too
09:11:56 <bgs100> PeakerWork, /usr/local/bin/cabal
09:12:13 <PeakerWork> bgs100: cabal install puts binaries in ~/.cabal/bin  by default
09:12:18 <bgs100> Ah.
09:12:28 <PeakerWork> bgs100: if you use --global it might put them in /usr or /usr/local, I'm not quite sure
09:12:31 <jlouis> Axman6: that too, I think each process must be able to cope with that
09:12:40 <Axman6> indeed
09:12:45 <mmorrow> mreh: hey, what's up
09:12:53 <Axman6> jlouis: so what sort of dying are you talking about?
09:13:10 <jlouis> Axman6: exceptions or hitting undefined :)
09:13:34 <jlouis> Error handling needs improvementation :)
09:13:46 <Axman6> heh
09:14:37 <bgs100> Also, if I do add ~/.cabal/bin to my $PATH, could/should I remove the old cabal?
09:14:49 <Axman6> i wouldn't
09:15:02 <PeakerWork> bgs100: if you put it in the PATH before /usr/local/bin, it'll take precedence
09:15:07 <PeakerWork> bgs100: and you'll have a backup :)
09:15:10 <Axman6> but you want .cabal/bin there anyway, because any binaries you install will be put there
09:16:03 <bgs100> Well, thanks.
09:16:09 <roconnor> @src length
09:16:10 <lambdabot> Source not found. Do you think like you type?
09:16:24 <roconnor> eh?
09:17:32 <joe2> anyone here who is a fan of c2hs?
09:17:53 <bgs100> Okay, added it to my path before /usr/local/bin, works now, thanks :)
09:18:29 <joe2> i tried to use c2hs, but could not get far. I could get the job done with hsc2hs, but am still curious to break into c2hs.
09:20:39 <mmorrow> roconnor: iirc it's a manually unboxed explicitly recursive loop in ghc (length)
09:20:43 <jfischoff> anyone know a good way to generate haskell data types from a xsd?
09:22:02 * mmorrow cat $(find ghc/libraries/base/GHC/ | grep -E "\.l?hs$" | xargs) | grep -A 4 -E "^length "
09:22:24 <mmorrow> aka /bin/sh-oogle
09:23:08 <mmorrow> grep is probably one of the best things evar
09:23:44 <Jafet> jwz rolls in his... nightclub. Nevermind.
09:23:44 <Twey> Hehe
09:23:56 <jcapper> I want a fast, pure matrix data type storing ints, what's the best representation? The docs seem to suggest DiffUArray
09:24:02 <mmorrow> i love when you lose your keys and your first thought is to grep -E "...er, blast!
09:24:32 <Twey> Hahaha
09:24:33 <mmorrow> jcapper: i'd use uvector if you want a pure one
09:24:41 <mmorrow> @hackage uvector
09:24:41 <lambdabot> http://hackage.haskell.org/package/uvector
09:26:20 <jmcarthur> <3 uvector
09:26:22 <Axman6> mmorrow: i do that when looking for things in books, i always go to hit cmd-space (spotlight)
09:26:40 <jmcarthur> control-F
09:27:24 <Axman6> that too
09:27:35 <maltem> lispy, one itch I'm having right now, maybe in the same direction as yours: I'm sure that there's lots of data processing that cannot fail (e. g. line count), but this is not captured in the type system: Even those have to be "run"
09:27:40 <Jafet> data WhereAreMyKeys = OnTheShelfOf Furniture | InThePocketsOf Clothing | LeftInMyCar | LeftInOtherCar Vehicle | UnderTheBigHeavyCouch | LOST
09:28:50 <maltem> Those iteratees would have in common that feeding EOF to them always succeeds with a result.
09:29:17 <mmorrow> Axman6: it's such a bummer the split second after you realize that you can't grep real life
09:29:36 <PeakerWork> I dislike that you have to compose Iteratees with EOF before feeding them to something, too
09:29:37 * jmcarthur often wants to sed real life
09:29:44 <Axman6> jlouis: ok, well, i managed to get everything... compiling. broke something in FS, which i'll take a look at tomorrow. it's 4:30AM now, so i'm off to sleep
09:29:49 <Axman6> mmorrow: man, i hear ya
09:29:57 <HugoDaniel> jmcarthur: i find myself missing 'diff' quite a lot
09:30:17 <jmcarthur> HugoDaniel: diff man woman?
09:30:21 <HugoDaniel> :D
09:30:25 <Axman6> 8===D
09:30:28 <Axman6> >_>
09:30:34 <Jafet> Penis.
09:30:39 <jcapper> mmorrow: I'll take a look, cheers
09:30:46 <mmorrow> jcapper: np
09:30:48 <jmcarthur> diff manBrain womanBrain
09:30:49 <PeakerWork> I hate that "diff" on source code is so stupid
09:30:59 <Axman6> yeah :\
09:31:01 <maltem> I experimented with   Cont a (a -> Stream s -> State s a)   instead of   Cont (a -> Stream s -> State s a);  but that makes the monad instance dubious.
09:31:15 <PeakerWork> things like changing the order of two functions are not recognized, and then cause unnecessary conflicts, etc..
09:31:31 <EvanR-work> @src replicate
09:31:31 <lambdabot> replicate n x = take n (repeat x)
09:31:33 <Axman6> PeakerWork: OS X's File Merge app does a decent job, but it's not much smarter than diff
09:31:33 <Jafet> Depends on which diff you use
09:31:38 <Phyx-> Hi, I was wondering why these instance are overlapping. http://phyx.pastebin.com/d5681dca4 IO () isn't an instace of Num is it?
09:31:48 <EvanR-work> @src repeat
09:31:49 <lambdabot> repeat x = xs where xs = x : xs
09:31:49 <Jafet> VCSes use specialized ones I imagine
09:31:55 <mmorrow> PeakerWork: "meld" diff viewer is actually really really handy, i came across it by accident and it's awesome
09:31:58 <EvanR-work> (i need this function in javascript ;)
09:32:22 <Zao> Phyx-: Equally bad matches?
09:32:25 <mmorrow> PeakerWork: it goes well beyond the standard diff algo (although i'm not really sure just what it does, but it's nice)
09:32:27 <kmc_> > () + ()
09:32:28 <lambdabot>   No instance for (GHC.Num.Num ())
09:32:28 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
09:32:28 <PeakerWork> Phyx-: only the "head" is matched
09:32:28 <Jafet> You already have an implementation of unbounded lazy lists, I imagine
09:32:50 <PeakerWork> mmorrow: Well, "meld" doesn't have 3-way merge, which is what I usually want from a GUI diff'er
09:33:12 <Axman6> hmmmmm, what problems would arise form implementing instance Num a => Num (IO a)?
09:33:25 <PeakerWork> Axman6: Eq instance
09:33:37 <Axman6> ah, touché
09:33:38 <mmorrow> PeakerWork: you can n-way compare files with visual blobs connecting the various differing pieces and other color coding
09:33:40 <ziman> why is repeat not defines as "repeat x = x : repeat x" ?
09:33:46 <Axman6> and with that, i'm off to sleep. night all
09:33:47 <Phyx-> PeakerWork: hmm ok, I think i know how to work around it then
09:33:56 <maltem> PeakerWork, that's just an argument against our bad class hierarchy :P
09:33:56 <Jafet> That is also a valid definition
09:34:01 <mmorrow> PeakerWork: i'd imagine you can do automated merging stuff with it to, but i've never used it for that
09:34:03 <Axman6> ziman: more efficient the other was i think
09:34:12 <EvanR-work> if i used that def i get an infinite loop in javascript :(
09:34:18 <EvanR-work> its strict
09:34:18 <Axman6> xs = x:xs is pretty space efficient
09:34:21 <Jafet>  @src has nothing to do with efficiency sir
09:34:23 <Axman6> i think...
09:34:25 <ziman> to get it memoized into a circular list?
09:34:25 <mmorrow> PeakerWork: (it'd have to be able to do that given the other crap it does i've gotta believe)
09:34:34 <Jafet> EvanR, perhaps you should have realized this sooner
09:34:39 <EvanR-work> heh
09:34:39 <maltem> Axman6, right, it will be represented as a cyclic list
09:34:57 * EvanR-work looks for another way
09:35:10 * Axman6 waits for take 5 to finish then goes to bed
09:35:11 <EvanR-work> just so many things missing from ajvascript
09:35:28 <mmorrow> PeakerWork: (if you open up 3 non-trivially differing files, it'll spin for like a minute computing stuff)
09:35:39 <Jafet> Such as a consistent implementation
09:36:24 <poucet> :t maybe
09:36:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:36:49 <Phyx-> PeakerWork: if there a way to tell it which instance to pick?
09:37:32 <mmorrow> , let rep x = x : rep x in vacuum (rep 0)
09:37:40 <lunabot>  Killed.
09:37:45 <EvanR-work> Jafet: yeah. that
09:37:58 <mmorrow> , let rep x = let xs = rep x in x : xs in vacuum (rep 0)
09:38:04 <lunabot>  Killed.
09:38:06 <mmorrow> gah
09:38:21 <mmorrow> , let rep x = let xs = x : xs in xs in vacuum (rep 0)
09:38:23 <lunabot>  [(0,[1,0]),(1,[])]
09:38:28 <mmorrow> @src fix
09:38:28 <lambdabot> fix f = let x = f x in x
09:38:46 <Jafet> , :t vacuum
09:38:46 <lunabot>  luna: Couldn't match expected type `(a1
09:38:53 <Jafet> Hum
09:38:53 <mmorrow> , let rep = fix . (:) in vacuum (rep 0)
09:38:55 <lunabot>  [(0,[1,0]),(1,[])]
09:38:57 <maltem> In   fold f z xs,  does f have a prettier name than "the function that is being folded over the list"?
09:39:27 <Jafet> Folder? Foldend? Foldee?
09:40:10 <EvanR-work> Foldimeister, Foldino, Foldiminator
09:40:14 <maltem> Yeah. All didn't sound too familiar to me when I thought the same.
09:40:18 <mmorrow> ziman: without the recursive let, it doesn't create a cycle of pointers in the heap
09:40:38 <mmorrow> ziman: so it'll evaluate to a list of unbounded size
09:40:52 <ziman> mmorrow, yes, i see
09:40:56 <ziman> thanks
09:41:08 <pmurias> mberends:  did you manage to get mildew to run?
09:42:34 <mreh> mmorrow: i'm just working on some haskore things
09:43:08 <mreh> wrote a very rudimentary improvising soloist
09:43:12 <mmorrow> ziman: this is a neat one http://moonpatio.com/vacuum/gallery/dlist.html
09:43:28 * pmurias confused channels :(
09:43:31 <mmorrow> mreh: cool
09:43:47 <mreh> mmorrow: what are your interests mainly with haskore?
09:44:02 <mmorrow> mreh: what rules/algo is it using to do this?
09:44:24 <mmorrow> mreh: i've never used haskore myself
09:44:32 <mreh> mmorrow: just a stochastic search through a range of notes, I figured any instrument will have a range to restrict itself to
09:44:34 <mmorrow> mreh: although it sounds interesting
09:45:28 <mreh> mmorrow: it's nothing impressive, just very rudimentary random lines so far, no real rhytmic or melodic embellishments yet, I was going to use some of your ideas from your theory module for that
09:45:45 <Phyx-> ooooohh i get it!
09:45:46 <sinelaw> @type runReaderT
09:45:47 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
09:47:30 <mmorrow> mreh: you just reminded me of something i stumbled across the other week which is pretty cool. it'd be cooler too if it wasn't just using random frequencies too http://cessu.blogspot.com/2009/10/megahurtz-for-your-ears.html
09:47:58 <mmorrow> hearing gcc and yacc is amusing
09:49:13 <mmorrow> mreh: oh nice, yeah that'd definitely be interesting to hook up a little dsl for high-level description of what to play to a (non-pcspkr ;) way to play it
09:49:57 <mreh> mmorrow: i'm currently rendering it to MIDI and converting it to a simple score
09:50:01 <mreh> with lilypond
09:50:48 <mmorrow> mreh: nice, do you have any webspace that you put your code repos or anything like that?
09:50:56 <maltem> yay for pretty lilypond scores
09:51:22 <mmorrow> mreh: (if not you can request a code.haskell.org account too)
09:51:32 <mreh> mmorrow: I have a hackage account
09:51:49 <mreh> I'll start using darcs as soon as it gets beyond the prototyping stage
09:52:00 <joe2> i am getting the below warning when I upload my bindings package to hackage. I understand the Bindings module name is not in the "hierarchial module names". the bindings-dsl and bindings-libusb seem to follow this approach. any suggestions, please?
09:52:04 <joe2> Exposed modules use unallocated top-level names: Bindings
09:52:31 <mmorrow> mreh: you can also get a shell account of code.haskell.org w/ code.haskell.org/~mreh wired to ~/html
09:52:55 <mmorrow> mreh: but you have to fill out a different request form
09:53:04 <mmorrow> s/of/on/
09:53:44 <mreh> mmorrow: a public http interface for reading the code?
09:53:59 <koeien37> mreh: yes
09:54:35 <koeien37> e.g. http://code.haskell.org/network/
09:54:49 <mreh> how is "open" different from "free"
09:54:59 <koeien37> in "software"?
09:55:01 <mreh> ya
09:55:22 <koeien37> i prefer "free software", but "open source software" is more common nowadays i guess. or "free open source software"
09:55:26 <Phyx-> PeakerWork: thanks, solved it :)
09:55:35 * hackagebot upload: text 0.7.0.1 - An efficient packed Unicode text type (BryanOSullivan)
09:55:51 <sinelaw> my program is so slow....
09:55:53 <open> open is just that the source is available. free stresses that certain rights are given to a user when that open software is released (you can look up these in particular on the fsf website)
09:55:53 <koeien37> "free" in English is a bit ambiguous, "free software" *could* mean "software without cost"
09:56:00 <sinelaw> 50% spent on opengl rendering
09:56:03 <ane_> libre software <3
09:56:13 <sinelaw> is there any silly thing i'm missing?
09:56:15 <koeien37> in lots of other languages it's not so ambiguous :(
09:56:28 <jmcarthur> open means the source is available to you. free often means you must make your version of the source available to end users. it also could mean you don't have to pay money for it. it could also mean a million other things. that's why i avoid the word "free"
09:56:34 <EvanR-work> a lot of open source projects are 'open' because the source is available AND they are willing to talk to you about problems you found
09:56:38 <EvanR-work> or accept patches even
09:56:39 <koeien37> "open source" != "the source is available to you"
09:56:44 <mreh> meh, I'm not so moved by the free software crusade,
09:56:58 <koeien37> open source is more than that
09:57:07 <EvanR-work> free software just means the source is available and you can modify it
09:57:12 <jmcarthur> koeien37: that is not my understanding
09:57:14 <ane_> floss (free, libre and open source software) is a pretty common term nowadays isn't it
09:57:16 <EvanR-work> and redistribute it
09:57:22 <mreh> doesn't free software mean you can change it and redistribute
09:57:27 <koeien37> (and run it)
09:57:43 <bos> offtopic, folks. #haskell-blah please.
09:57:49 <jmcarthur> koeien37: my understanding is that you can call something open source if you have access to the code even if you can't do anything with it
09:57:49 <eldragon> GPL is virical, it does that you're not free to do with it.
09:58:05 <koeien37> jmcarthur: OSI disagrees
09:58:31 <EvanR-work> microsoft stuff is available, but you must sign an NDA
09:58:36 <EvanR-work> i wouldnt call that open
09:58:48 <bos> EvanR-work: offtopic, thank you.
09:58:56 <mreh> please
09:59:04 <EvanR-work> youre welcome
10:03:21 <EvanCarroll> hahahah
10:03:26 <EvanCarroll> Google is so amusing
10:03:34 <EvanCarroll> erg m/t
10:05:43 <sinelaw> damn, performance problems are killing me
10:06:00 <koeien> sinelaw: did you profile your program?
10:06:13 <joe2> is anyone interested in the haskell bindings to libftdi?
10:06:22 <kmc_> hackage is
10:06:29 <sinelaw> koeien, i am. it spends 49% of its time inside luqui's library that wraps opengl
10:06:35 <sinelaw> drawing stuff
10:06:57 <koeien> i wouldn't know how C functions show up on the profiler
10:07:16 <koeien> i wouldn't be surprised if the time would be reported as being spent in the haskell bindings, though
10:07:32 <sinelaw> Time spent in foreign code (see Chapter 8, Foreign function interface (FFI) ) is always attributed to the cost centre in force at the Haskell call-site of the foreign function
10:07:38 <sinelaw> (quote from ghc manual)
10:07:43 <koeien> ah yes, that makes sense
10:08:10 <sinelaw> maybe it's cause i'm running mesa? :)
10:08:16 <koeien> heh.
10:08:19 <sinelaw> but the graphics are really really lightweight
10:08:27 <koeien> if you could share your code, i can try it here
10:08:30 <joe2> is there an anonymous upload to hackage?
10:08:39 <sinelaw> koeien, of course
10:08:40 <koeien> joe2: you will have to request an account
10:08:48 <sinelaw> http://github.com/sinelaw/graphui
10:09:00 <sinelaw> koeien, are you ok with git?
10:09:10 <joe2> koeien: can it be any name that I want or are they pretty strict with the name?
10:09:30 <sinelaw> koeien, actually they have a 'download' button if you're not
10:09:40 <koeien> joe2: I wouldn't know. I just have FirstnameLastname
10:10:01 <koeien> sinelaw: one moment
10:10:25 <sinelaw> wait, let me push updated version
10:10:31 <koeien> k
10:10:56 <sinelaw> ok done
10:11:54 <sinelaw> koeien, once you have it, you can run: cabal install --enable-executable-profiling -O2 -p
10:12:08 <sinelaw> (the -O2 is redundant actually)
10:12:15 <sinelaw> or run without profiling, just cabal install
10:15:01 <koeien> meh, i miss some C libs
10:15:49 <lament> i miss my ex, but my aim is getting better
10:16:18 <Cale> sinelaw: That's somewhat interesting. The other day there was someone here with a program which spent most of its time doing apparently nothing. I suppose it doesn't count the time being spent blocked on I/O.
10:16:22 <Cale> (in system calls)
10:17:17 <Cale> Or maybe it's just the time spent waiting for select?
10:17:24 <sinelaw> Cale, or i don't know how to profile
10:17:58 <Cale> Well, I mean the quote from the GHC manual
10:18:11 <sinelaw> oh
10:18:43 <sinelaw> lament, heh
10:20:02 <sinelaw> koeien, any ideas?
10:20:14 <koeien> not really, sorry
10:20:49 <sinelaw> koeien, did you build it?
10:21:01 <sinelaw> i'd like to know at least if it's Mesa
10:21:03 <koeien> sinelaw: no, too lazy to find the C libs
10:21:08 <koeien> ok let me try it then
10:21:16 <sinelaw> what C libs?
10:21:21 <koeien> some sdl stuff
10:21:24 <sinelaw> cabal should do the work
10:23:35 <koeien> what should i do when running?
10:23:56 <koeien> it follows my cursor?
10:24:22 <koeien> except at the right and bottom edge
10:24:24 <koeien> correct?
10:24:40 <koeien> and now it crashes with a pattern match failure after pressing some keys
10:25:21 <c_wraith> you pressed the wrong keys.  don't do that.
10:25:27 <koeien> heh
10:25:40 <sinelaw> koeien, really?
10:25:41 <raceRider> how do I force a list generator to become strict?
10:25:42 <sinelaw> which keys
10:25:45 <Zao> Base cases are for the weak.
10:25:50 <koeien> sinelaw: let me try
10:25:58 <koeien> it's the 'a'
10:25:59 <sinelaw> only 'a' should do something
10:26:01 <sinelaw> ah
10:26:03 <sinelaw> heheh
10:26:05 <jmcarthur> sinelaw: try building with -Wall and it should warn you about incomplete patterns
10:26:09 <koeien> well, at least it does something :)
10:26:15 <sinelaw> jmcarthur, I do
10:26:17 <koeien> graphui: user error (Pattern match failure in do expression at Data/GraphViz.hs:173:9-22)
10:26:27 <sinelaw> oh, that's not my code :)
10:26:34 <jmcarthur> aha!
10:26:37 <koeien> but what exactly do you want me to test?
10:26:40 <sinelaw> try cabal update; cabal install --reinstall graphviz
10:26:41 <koeien> it seems to work pretty well
10:27:04 <sinelaw> koeien, it lets you build graphs. once you have a large graph with many edges, performance degrades quickly
10:27:15 <sinelaw> it SHOULD let you build them, but it's crashing on the 'add node' key
10:27:20 <koeien> ah. I see
10:27:42 <sinelaw> maybe you're running an older version of graphviz
10:27:53 <koeien> 2999.7.0.0
10:28:33 <sinelaw> same as i
10:28:49 <sinelaw> so how does your fail and mine doesn't? weird
10:29:10 <koeien> there is a partial pattern match there, yeah
10:29:30 <sinelaw> koeien, yeah i'm looking too
10:30:23 <sinelaw> koeien, maybe you don't have graphviz (dot) installed?
10:30:35 <koeien> i don't. in fact
10:30:40 <sinelaw> ah :)
10:30:43 <koeien> i thought i had it, but that's on my laptop
10:31:01 <sinelaw> how do you send a message via lambdabot again?
10:31:04 <calsaverini> I'm trying to learn how to use the state monad but I'm having a problem when importing Control.Monad.State
10:31:07 <calsaverini>     Could not find module `Control.Monad.State':
10:31:07 <calsaverini>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.0.0.1
10:31:07 <calsaverini> Failed, modules loaded: none.
10:31:07 <calsaverini>  
10:31:25 <benmachine> calsaverini: ghc-pkg hide monads-fd if I remember correctly
10:31:30 <koeien> sinelaw: i only seem to be able to add 9 nodes
10:31:31 <calsaverini> (oops... sorry for the flood, I thought it would paste in a single line)
10:31:36 <benmachine> (or ghc-pkg hide mtl)
10:31:47 <sinelaw> koeien, once you have a few nodes, click on one and then another to connect them
10:31:49 <benmachine> (but I think mtl is more common)
10:31:59 <benmachine> (so hide the rarer one)
10:32:07 <calsaverini> I have to do this in the top of my program?
10:32:13 <benmachine> no
10:32:17 <sinelaw> try building a big graph and tell me how the performance is (the mouse-following box will start skipping, cpu usage going all the way up)
10:32:20 <benmachine> you have to do it once on the command line
10:32:25 <calsaverini> Ah, I should run the program
10:32:30 <sinelaw> koeien, i should have the documentation in the program :)
10:32:35 <benmachine> ghc-pkg controls where ghc looks for stuff
10:32:49 <benmachine> your problem is that Control.Monad.State is in two packages and it doesn't know which to use
10:32:53 <benmachine> so you hide one of the packages
10:32:54 <koeien> i only have a pretty small screen
10:32:58 <Zao> You can also provide the packages to use as part of your Cabal .cabal file, if building with it.
10:33:00 <calsaverini> I sww
10:33:02 <calsaverini> see
10:33:04 <koeien> room for about 9x9 squares
10:33:14 <calsaverini> it worked
10:33:16 <calsaverini> thanks
10:33:35 <mreh> still no lilypond backend for haskore then?
10:33:40 <sinelaw> koeien, that's how it is, but even then i get bad performance
10:33:44 <sinelaw> make many many ocnnections
10:33:49 <sinelaw> between the nodes you can DO have
10:33:52 <koeien> yeah, i have it now
10:34:03 <sinelaw> damn. are you running mesa too perhaps? :)
10:34:10 <koeien> not that i know of :)
10:34:45 <sinelaw> koeien: glxinfo  | grep renderer
10:35:04 <koeien> sinelaw: no, i use the nonfree ati drivers
10:35:13 <sinelaw> ok, case closed
10:35:18 <sinelaw> it's in the haskell :(
10:36:21 <Cale> sinelaw: Isn't that actually a good thing, because it means you can expect to have some control of the problem without having to modify C code?
10:36:39 <Cale> (though I don't know what the problem is :)
10:36:47 <sinelaw> Cale, if i knew how to solve it, then yes
10:36:59 <sinelaw> Cale, it's opengl binding wrappers running slowly
10:37:09 <sinelaw> (apparently)
10:37:13 <koeien> or there is just a lot of time spent there
10:37:20 <koeien> because you call it often
10:37:48 <sinelaw> koeien, i limit the framerate, but you have a point
10:38:11 <sinelaw> i think i can test that hypothesis
10:39:42 <Cale> what function is it which you call a lot/seems slow?
10:39:48 <Cale> This is in the graphui thing?
10:40:30 <sinelaw> Cale, yeah
10:40:33 <Cale> Or graphui is what you're writing?
10:40:39 <sinelaw> graphui is what i'm writing
10:40:42 <sinelaw> and it's in it :)
10:40:47 <Cale> okay
10:41:03 <sinelaw> Cale, actually i'm calling a function from graphics-drawingcombinators
10:41:19 <sinelaw> the function that renders the opengl, 'draw'
10:42:53 <Cale> ah
10:43:07 <Cale> Are you doing an animation or something?
10:44:04 <Cale> draw does a bunch of setting of GL variables which would probably be unnecessary after the first frame
10:44:17 <Cale> (though I don't know GL all that well)
10:44:34 <sinelaw> Cale, true, i tried the other version (runDrawing) that doesn't do that and also doesn't clear the screen
10:44:38 <sinelaw> and it's still like that
10:47:18 <sinelaw> Ok, when I turn off rendering the big graph the performance goes back to normal (animating the mouse quickly), so it's not just because i'm calling it often
10:48:05 <jfischoff> does anyone know if there is a simple haskell (non-opengl) solution for rendering a 3d mesh?
10:48:27 <jfischoff> hray seems to only work with planes and spheres
10:49:07 <kmc_> write a file and call POV-Ray?
10:50:02 <sinelaw> :)
10:50:35 <sinelaw> btw, we're trying to run povray here on a condor cluster with over 100 computers, should be fun when it actually works
10:50:45 <jfischoff> simple, err I meant pure :)
10:52:11 <jfischoff> as in Mesh -> Image
10:54:31 <kmc_> jfischoff, well, wrap it in unsafePerformIO ;)
10:54:45 <sinelaw_> bleh
10:54:45 <lambdabot> sinelaw_: You have 1 new message. '/msg lambdabot @messages' to read it.
10:55:01 <jfischoff> ah, problem solved :)
10:55:30 <Cale> sinelaw_: hmm, this drawing library looks like it doesn't try very hard to cache things about geometry. Does this get any faster when you, say, hand-apply the Draw.scale inside of 'box'?
10:55:39 <patch-tag> in compiling pathc-tag I get...
10:56:07 <Cale> sinelaw: (that is, just start with smaller coordinates for the vertices of the square)
10:56:39 <sinelaw> Cale, that's a good point, i'll try that
10:56:43 <patch-tag> *** Renamer/typechecker:    /home/thartman/bin/ghc returned ExitFailure 15
10:56:51 <patch-tag> anyone know what exitFailure 15 is?
10:56:52 <Cale> Of course, it's just calling GL to do the scaling.
10:58:10 <sinelaw> shouldn't such a call be fast enough?
10:58:12 <Cale> patch-tag: That looks like a ghc bug?
10:58:22 <sinelaw> do ffi calls have an overhead?
10:58:23 <Cale> sinelaw: Well, one would hope
10:58:35 <Cale> Some.
10:59:00 <Cale> Well, less if they've been marked 'unsafe' (which just means that they promise not to call back into Haskell code)
10:59:01 <patch-tag> Cale: I have ghc 6.10.3 both on local and remote, but I only get the error on remote
10:59:29 <Phyx-> is there any other way to solve overlapping instances than this rather complicated way http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap using functional dependencies?
11:00:01 <Cale> sinelaw: But it appears to scale one way and then back again
11:00:18 <sinelaw> that's how opengl works, iirc
11:00:23 <sinelaw> there's a stack
11:00:40 <kmc_> Phyx-, depends on what your overlapping instances are, and what you want them to do
11:00:43 <Cale> sinelaw: and has to convert the inverses of the x and y scaling factor and convert their numeric type
11:00:54 <Cale> (which it does twice each)
11:01:16 <Phyx-> kmc_: my instances are http://phyx.pastebin.com/d5681dca4 just a general instance for Num instances and for Functor instances
11:01:21 <Philonous> Phyx-: This doesn't even get rid of overlapping instances, does it?
11:01:27 <sinelaw> Cale, so how do haskell apps get good opengl performance
11:01:31 <Cale> I wouldn't normally expect it to be much, but I haven't seen your .prof, so I'm looking for anything which looks slower than it ought to be
11:01:32 <kmc_> Phyx-, i don't even understand why those overlap
11:02:17 <Phyx-> kmc_: i wouldn't expect them to either, but well PeakerWork said that only the heads are matched
11:02:34 <Phyx-> Philonous: well, it's supposed to, if i read it correctly, it's a way around it
11:02:36 <Cale> sinelaw: I wonder if convReal is killing things.
11:02:43 <sinelaw> Cale, i'll try building it with -auto-all
11:02:55 <kmc_> Phyx-, you should be able to turn on some GHC extension and it will simply accept the most specific one
11:03:07 <kmc_> OverlappingInstances i think
11:03:19 <Phyx-> kmc_: already have it on
11:04:20 <HugoDaniel> is there any effort on haskell in android ?
11:04:40 <Phyx-> kmc_: the IncoherentInstance is the problem
11:05:13 <Philonous> Phyx-: : "These instances do make use of overlapping instances, but they do not rely on the *context* to distinguish which one to pick, just the instance *head*"
11:05:57 <kmc_> Phyx-, this works fine for me: http://codepad.org/h4J47zVy
11:06:00 <Phyx-> Philonous: oh, guess that won't work either
11:06:01 <Cale> sinelaw: Actually, I wonder if since box is a constant, all the stuff inside it only gets computed once anyway. That's possible.
11:06:03 <dons> HugoDaniel: people have discussed how to approach it.
11:06:38 <sinelaw> Cale, i've finally learnt how to build properly for profiling, so only now i'm looking at real profiling results...
11:06:54 <Cale> ah
11:06:56 <kmc_> apps on non-rooted android have to target their special JVM, yes?
11:07:06 <Cale> sinelaw: hpaste?
11:07:18 <sinelaw> Cale, yip - convReal is second, fourth, fifth, etc.. in terms of time
11:07:41 <Phyx-> kmc_: well, i have to enable IncoherentInstances due to it not liking these instances http://phyx.pastebin.com/d603c7edf
11:07:50 <Cale> sinelaw: lovely.
11:07:58 <kmc_> Phyx-, can you paste the code of the instances?
11:08:05 <sinelaw> pasting...
11:08:07 <Phyx-> kmc_: sure, one sec
11:09:43 <Phyx-> kmc_: http://phyx.pastebin.com/d871902d
11:14:03 <Phyx-> kmc_: seems to be due to the instance "FFIType (f a) (Ptr (f b))"
11:14:25 <kmc_> ah
11:14:30 <kmc_> yes, why is that needed in context of the others?
11:16:28 <Phyx-> kmc_: well, i wanted to make only 1 call and be able to convert a functor type to a Ptr, i could do it in 1, the first one uses the (f a) (f b) instance and the second the a (Ptr a) instance i think. But i just wanted an instance which, depending on which type is expected does it automatically
11:16:43 <kmc_> that might be trouble
11:16:52 <kmc_> i'd create a helper function instead of an overlapping instance
11:17:35 <Phyx-> even removing the instance, i still get the overlapping instance error on (f a) (f b) and num a => a a
11:17:49 <EvanR-work> @src (.)
11:17:49 <lambdabot> (f . g) x = f (g x)
11:18:17 <Phyx-> whoops
11:18:18 <Phyx-> wrong button
11:18:19 <sinelaw> Cale, http://www.ee.bgu.ac.il/~noamle/_downloads/graphui_profile.html
11:18:26 <EvanR-work> so (.) is a trinary operator?
11:18:27 <Phyx-> kmc_: got my last message?
11:18:36 <kmc_> Phyx-, don't think so
11:18:38 <sinelaw> Cale, or the original output http://www.ee.bgu.ac.il/~noamle/_downloads/graphui.prof
11:18:41 <kmc_> EvanR-work, not syntactically
11:18:49 <kmc_> syntactically it's a binary operator
11:18:52 <sinelaw> (the html is sorted and i cut off most of the file to make it smaller)
11:18:55 <Phyx-> kmc_: i said, even removing the instance, the overlapping instance error still persists
11:19:00 <kmc_> it happens that the return value of that binary operator is also a function
11:19:04 <Cale> sinelaw: Wow, my prediction came true
11:19:09 <sinelaw> precisely
11:19:16 <EvanR-work> kmc_: is there a way to define it that way?
11:19:22 <kmc_> EvanR-work, which way?
11:19:32 <EvanR-work> :t (.)
11:19:33 <kmc_> EvanR-work, semantically, every function in Haskell takes exactly one argument, so "binary operator" is merely a syntactic notion
11:19:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:19:39 <kmc_> EvanR-work, that's the crazy version of (.)
11:19:42 <kmc_> :t Prelude.(.)
11:19:43 <lambdabot> Not in scope: data constructor `Prelude'
11:19:43 <sinelaw> Cale, what's an easy way to fix that?
11:19:45 <kmc_> :t Prelude..
11:19:46 <lambdabot> parse error on input `Prelude..'
11:19:49 <kmc_> gr
11:19:51 <EvanR-work> heh
11:19:52 <sinelaw> Cale, and hwo did you know??
11:20:02 <kmc_> :t let (f . g) x = f (g x) in (.)
11:20:03 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
11:20:06 <Cale> sinelaw: So the problem is that the GL library wants to work with its own floating point type, and the drawingcombinators library tries to shield you from that by doing lots of numeric conversions everywhere.
11:20:07 <kmc_> ^^^^^ EvanR-work
11:20:11 <Phyx-> kmc_: not i get http://phyx.pastebin.com/d17dada68
11:20:32 <Phyx-> now*
11:20:39 <sinelaw> Cale, I see
11:20:49 <EvanR-work> kmc_: so is there a way to define it with only two free variables ;)
11:20:53 <sinelaw> and these are expensive (not just 'casts')
11:20:57 <Cale> yes
11:21:03 <kmc_> EvanR-work, there aren't really any free variables there
11:21:12 <kmc_> f,g,x are all binding occurrences
11:21:19 <sinelaw> Cale, what can i do?
11:21:30 <EvanR-work> compose f g = ?
11:21:38 <Cale> sinelaw: Well, not only that, but it's actually outright wasteful in some places
11:21:43 <Cale> scale x y = TransformGL $
11:21:43 <Cale>     cong (lift $ GL.scale (convReal x) (convReal y) 1)
11:21:43 <Cale>          (lift $ GL.scale (1/convReal x) (1/convReal y) 1)
11:21:58 <Cale> ^^ computing each of convReal x and convReal y twice
11:22:00 <kmc_> :t let compose f g = \x -> f (g x) in compose
11:22:01 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
11:22:04 <kmc_> EvanR-work, ^^^^
11:22:11 <EvanR-work> ah
11:22:21 <kmc_> :t let compose f g x = f (g x) in compose
11:22:22 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
11:22:25 <sinelaw> Cale, oy
11:22:29 <kmc_> :t let compose = \f g x -> f (g x) in compose
11:22:30 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
11:22:34 <kmc_> :t let compose = \f -> \g -> \x -> f (g x) in compose
11:22:35 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
11:22:45 <EvanR-work> i like the lambda version ;)
11:23:23 <Twey> Hmm
11:23:33 <Twey> I wonder if it's possible to implement compose without mentioning x?
11:23:42 <Twey> (or ., obviously)
11:23:43 <EvanR-work> what is it in lambda calculus
11:23:49 <sinelaw> Cale, is there a way to somehow hide 'Double' and set: type Double = GL.GLdouble
11:23:50 <EvanR-work> Twey: thats what im getting at
11:23:50 <Cale> sinelaw: It probably wouldn't be too hard to remove the convReals altogether, and switch the types in DrawingCombinators to using GL's types.
11:23:54 <kmc_> the compose operator?
11:23:59 <EvanR-work> yeah
11:24:04 <kmc_> \f -> \g -> \x -> f (g x)
11:24:09 <Twey> Without mentioning x
11:24:34 <kmc_> another question is, what is it in the SK calculus
11:24:38 <kmc_> wikipedia probably knows
11:24:39 <EvanR-work> seems thats the irreducible representation
11:25:00 <kmc_> if you have a universal basis of combinators like SK you can write it without abstraction
11:25:16 <Twey> Doesn't seem to
11:25:50 <tromp__> what do you want in SK calculus?
11:26:00 <EvanR-work> its slightly different from \f -> \g -> f g, because the application is out of order...
11:26:09 <Twey> tromp__: Composition
11:26:12 <EvanR-work> maybe in terms of flip or something
11:26:27 <lispy> :t fix $ \f m -> m >> f m -- unsafe coerce on monads?
11:26:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:26:45 <lispy> I guess the b is okay because it's _|_?
11:26:50 <Twey> I guess
11:27:19 <tromp__> S (K S) K
11:27:30 <kmc_> :t let unsafePerformIO :: IO a -> a; unsafePerformIO _ = error "bzzt" in unsafePerformIO
11:27:31 <lambdabot> forall a. IO a -> a
11:27:43 <Twey> Interesting
11:27:51 <Twey> Now how about λ-calculus?  :þ
11:28:01 <kmc_> :t let s = ap; k = const in s (k s) k
11:28:02 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
11:28:07 <kmc_> nice
11:28:07 <monochrom> (fix $ \f m -> m >> f m) = Control.Monad.forever
11:28:23 <kmc_> @djinn (b -> c) -> (a -> b) -> (a -> c)
11:28:23 <lambdabot> f a b c = a (b c)
11:28:32 <lispy> monochrom: right, that's where I got it :)
11:28:44 <Twey> (fix $ \f m -> m >> f m) = Control.Monad.forever >> return ()
11:28:45 <Twey> No
11:28:49 <Twey> Er
11:28:51 <Twey> Vice versa :þ
11:28:58 <EvanR-work> what just happened? >_< ;)
11:29:06 <Twey> (fix $ \f m -> m >> f m >> return ()) = Control.Monad.forever, no?
11:29:13 <monochrom> (fix $ \f m -> m >> f m) >> return () = Control.Monad.forever
11:29:22 <Twey> Oh, yes — that's the one
11:29:31 <lispy> The forever I have here, doesn't include >> return ()
11:29:37 <Twey> :t forever
11:29:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:29:40 <Twey> Oh
11:29:43 <Twey> Maybe not, then
11:29:48 <lispy> ?src forever
11:29:48 <lambdabot> Source not found. I feel much better now.
11:29:50 <monochrom> @src Control.Monad.forever
11:29:51 <lambdabot> Source not found. You untyped fool!
11:30:08 <lispy> Anyway, the b is odd
11:30:09 <Cale> One place in the libraries where we actually take advantage of what HM gives us in terms of dependency tracking
11:30:15 <lispy> It can't have a vlue
11:30:15 <monochrom> You can omit "return ()" and just use a type signature to force b=()
11:30:17 <lispy> value*
11:30:49 <lispy> :t forkIO
11:30:50 <lambdabot> Not in scope: `forkIO'
11:30:54 <Cale> I really despise the overuse of () in types.
11:30:55 <Twey> monochrom: I suppose
11:30:57 <lispy> :t Control.Concurrent.forkIO
11:30:58 <lambdabot> IO () -> IO GHC.Conc.ThreadId
11:31:04 <Cale> ^^ especially there
11:31:17 <kmc_> :t forkIO . (>> return ())
11:31:18 <lambdabot> Not in scope: `forkIO'
11:31:19 <Twey> Yeah… it's inconvenient
11:31:23 <monochrom> It is an unconstrained b because there is no constrained. "most general type".
11:31:26 <kmc_> :t Control.Concurrent.forkIO . (>> return ())
11:31:27 <lambdabot> forall a. IO a -> IO GHC.Conc.ThreadId
11:33:59 <monochrom> Notice the type of "const []" is similar.
11:34:10 <kmc_> :t const []
11:34:11 <lambdabot> forall a b. b -> [a]
11:34:24 <sinelaw> Cale, i've converted my entire application to use GL's double
11:34:30 <sinelaw> wait, i haven't.
11:34:31 <monochrom> An unconstrained a.
11:34:48 <monochrom> b->[a] is a special case of b -> m a
11:36:36 <EvanR-work> kmc_: SK calculus blows my mind. ix = xSK??? so if x = i you can define everything as iiiiiiiiiiiiiiiii?
11:36:50 <EvanR-work> guess you need to keep x
11:36:52 <kmc_> don't think so
11:37:02 <kmc_> i don't see how that follows
11:37:20 <kmc_> :t let s = ap; k = const; i x = x s k in i
11:37:21 <lambdabot> forall (m :: * -> *) a b a1 b1 t. (Monad m) => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
11:37:24 <kmc_> oh dear
11:37:26 <EvanR-work> it just says that a complete system can be defined with only one combinator
11:37:31 <jmcarthur> EvanR-work: that equation means that you can use S and K to make I, not the other way around
11:37:38 <EvanR-work> oh
11:38:00 <kmc_> EvanR-work, yes, but even with one combinator your language is tree shaped:  data Term = Comb | App Term Term
11:38:03 <jmcarthur> there are combinators that can make entire turing complete systems though, iirc
11:38:21 <jmcarthur> with just one combinator, i mean
11:38:31 <EvanR-work> kmc_: right because we still have parentheses
11:38:40 <EvanR-work> ok out of mind blown zone
11:39:00 <kmc_> EvanR-work, of course you can define a Turing-complete unary language
11:39:09 <sinelaw> Cale, ok, it does help
11:39:09 <EvanR-work> the preceding sentence said 'I' is merely syntactic sugar, so i thought it was saying that S and K were also
11:39:11 <sinelaw> but not enough
11:39:12 <kmc_> but not simply as a single combinator
11:39:23 <Cale> sinelaw: new profile?
11:39:24 <sinelaw> Cale, but now I know how to fix it, thanks!
11:39:27 <Cale> okay
11:39:46 <sinelaw> Cale, if you're interested, the new profile shows that my own function is killing it
11:40:04 <sinelaw> i wrote a nice version of bezier splines
11:40:12 <EvanR-work> kmc_: im thinking that all you need is a bunch of balanced parenthese?
11:40:14 <EvanR-work> s
11:40:38 <sinelaw> which is pretty but very wasteful, i guess. it calculates binomial coefficents (of only 3rd degree, but still) each time you calculate a point
11:40:40 <Cale> sinelaw: You might want to let Luke Palmer know about the performance issue
11:40:52 <sinelaw> instead i can just do the direct formula
11:40:55 <Cale> yeah
11:40:55 <sinelaw> Cale, i will
11:41:01 <sinelaw> but it's ugly code then :(
11:41:09 <Cale> Is it?
11:41:34 <Cale> Oh, with regard to putting binomial coefficients in place?
11:41:35 <bos> tibbe: hey
11:41:46 <kmc_> EvanR-work, well... any countable set can be used as a programming language
11:41:47 <tibbe> bos: yo
11:41:49 <jmcarthur> EvanR-work: http://esolangs.org/wiki/Iota and http://esolangs.org/wiki/Jot
11:41:56 <kmc_> in that it can be put into bijection with the turing machines or the lambda terms
11:41:58 <Cale> You could also, say, use memocombinators to memoise them, but it'd still be slower than putting them in place.
11:42:02 <sinelaw> Cale yes and putting the polynomial args in to
11:42:04 <bos> tibbe: been looking at your event code. seems like a nice start.
11:42:13 <bos> tibbe: i really wish you were using darcs though :-)
11:42:16 <kmc_> possibly we should require that it is RE
11:42:28 <tibbe> bos: we can move it over to darcs even though I prefer git
11:42:40 <tibbe> bos: I'll get to the questions in your email after dinner
11:42:40 <Cale> sinelaw: Given that they're just binomial coefficients, it would be questionable that memoisation even makes sense.
11:42:42 <bos> tibbe: i just sent mail to you and gregory about it
11:42:46 <tibbe> bos: we're about to sit down
11:42:46 <bos> ok
11:43:02 <tibbe> bos: I'd love to hack on it together, everything is open for change
11:43:16 <bos> tibbe: right on
11:43:25 * Cale goes to look at the definition of binomial
11:43:30 <jmcarthur> EvanR-work: ah this is what i was actually looking for http://web.archive.org/web/20061105204247/http://ling.ucsd.edu/~barker/Iota/
11:43:32 <tibbe> bos: the callback mechanism was one way to get around that the way GHC current does event handling is O(#watched fds)
11:43:37 <sinelaw> Cale, yeah i'll revert to the original version :(
11:43:52 <tibbe> bos: I'll drop you a response and if you feel like hacking on it I'll get a repo on code.haskell.org
11:43:59 <tibbe> bos: now dinner!
11:44:01 <tibbe> bos: ttyl
11:44:06 <bos> ok
11:44:09 <sinelaw> Cale, http://github.com/sinelaw/graphui/blob/master/src/Math/Bezier.hs
11:44:14 <EvanR-work> jmcarthur: reading now. this is must-know info
11:44:26 <Cale> sinelaw: ah, hmm
11:44:46 <sinelaw> Cale, the way it is now makes it easy to understand what a bezier4 is
11:44:58 <jmcarthur> EvanR-work: of course. my primary language where i work is jot
11:45:06 <Cale> sinelaw: indeed, that's pretty
11:45:06 <sinelaw> it's not how i wrote it, Peaker code-review it to perfection :)
11:45:13 <sinelaw> *code-reviewed
11:45:30 <EvanR-work> jmcarthur: where do you work?
11:45:51 <jmcarthur> EvanR-work: (i hope you realized it was a joke)
11:46:08 <sinelaw> Cale, somehow i expected ghc to optimize that pretty well
11:46:17 <EvanR-work> jmcarthur: i sort of did
11:46:20 <sinelaw> being 'just calculations
11:46:47 <Cale> sinelaw: If you were to at least make binomialPoly monomorphic in its first parameter, then you could use memocombinators to ensure that the coefficients get saved after the first use
11:46:57 <jmcarthur> EvanR-work: but to answer more directly http://pikewerks.com/
11:47:17 <EvanR-work> does iota have parentheses
11:47:26 <Cale> something like...
11:47:32 <jmcarthur> EvanR-work: i think the asterisks replace the parens
11:47:41 <EvanR-work> cool
11:47:53 <EvanR-work> ( ) and too straight forward
11:47:53 <sinelaw> Cale, in fact, i only need to calculate once the value of 'coeffs'
11:47:58 <EvanR-work> very high level constructs
11:48:01 <Cale> sinelaw: right
11:48:10 <sinelaw> including mu
11:48:11 <Cale> import qualified Data.MemoCombinators as Memo
11:48:33 <sinelaw> because my program uses the same mu values all the time (about 10 different ones)
11:49:02 <Cale> hmm, so it may even be profitable to memoise both
11:49:17 <sinelaw> both?
11:49:23 <sinelaw> oh
11:49:35 * hackagebot upload: libexpect 0.2.0 - Library for interacting with console applications via pseudoterminals. (StephenRoantree)
11:49:52 <Cale> Except that it's presently hard to memoise wrt floating point types
11:50:08 <bos> tibbe|away: i found a hg-git plugin that will let me pretend that git doesn't exist
11:50:21 <Cale> (not for any good reason, but I think the Bits instances are missing)
11:50:38 <EvanR-work> the parentheses operator, *, was treated syncategorematically.
11:50:41 <sinelaw> Cale, i can fix that
11:51:12 <Cale> But let's say you just wanted to memoise on that first parameter
11:51:14 <sinelaw> because i can take instead of mu, two values (number of samples and sample number)
11:51:32 <Cale> ah, that'd work :)
11:52:31 <pragma_> YOU WOULD THINK THAT!
11:52:46 <Cale> pragma_: ?
11:52:52 <jmcarthur> wut
11:53:01 * pragma_ coughs and clears his throat.
11:53:06 <pragma_> carry on, gentlemen.
11:53:20 <poucet> Anyone know nicolas pouillard's nick
11:53:40 <pragma_> "syncategorematically" -- is this really a common word in Haskell?
11:53:59 <Cale> sinelaw: At which point, it's as easy as applying Memo.memo3 Memo.integral Memo.integral Memo.integral to the whole thing
11:54:01 <ziman> yes, along with zygohistomorphic prepromorphisms
11:54:13 <ziman> :)
11:54:15 <kmc_> i have never heard that word before in my life
11:54:16 <Cale> sinelaw: (to the function itself)
11:54:31 <sinelaw> binomialCoeffSample n i sampNums =  binomialPoly n (1-mu) mu    where mu = i!!samps ; samps = iterate (+1/(fromIntegral n - 1)) 0
11:54:36 <jmcarthur> pragma_: yeah
11:54:56 <sinelaw> oops, that second n  in the end should sampNums, but you get the idea
11:55:01 <sinelaw> Cale, great, i'll try all this
11:55:05 * jmcarthur is a center for disinformation
11:58:06 <Cale> binomialCoeffSample = Memo.memo3 Memo.integral Memo.integral Memo.integral binomialCoeffSample' where binomialCoeffSample' n i sampNums = binomialPoly n (1-mu) mu; mu = i!!samps ; samps = iterate (+1/(fromIntegral n - 1)) 0
11:58:20 <Cale> Er, sorry, that really does need to be a nested where
11:58:22 <sinelaw> Cale, ironically the memo combinators is also by Luke
11:58:27 <Cale> hehe
11:58:31 <sinelaw> :)
11:59:08 <Cale> The idea behind memocombinators is really clever.
12:00:30 <Cale> It hijacks the lazy evaluation mechanism in a way, to do memoisation.
12:00:49 <poucet> Cale: unsafeperformioI?
12:00:50 <poucet> IO
12:00:52 <Cale> no
12:01:02 <Cale> There's no impure stuff in it at all
12:01:10 <Cale> and yet memo has a pure type :)
12:01:14 <poucet> impressive
12:01:47 <poucet> Cale: it does a lazy map over the entire domain of the input?
12:01:51 <Cale> It starts out by memoising boolean values
12:02:02 <poucet> Cale: Where is that code defined?
12:02:05 <Cale> bool :: Memo Bool
12:02:05 <Cale> bool f = cond (f True) (f False)
12:02:05 <Cale>     where
12:02:05 <Cale>     cond t f True  = t
12:02:05 <Cale>     cond t f False = f
12:02:18 <kmc_> it's the same trick as:  let fib = (fibs !!) where fibs = 1:1:zipWith (+) fibs (tail fibs)
12:02:21 <kmc_> but generalized
12:02:25 <poucet> kmc_: right
12:02:41 <poucet> kmc_: but to make that work efficiently is hard, !! is not exactly efficient.
12:02:44 <poucet> (fingertree?)
12:02:46 <kmc_> right
12:02:50 <kmc_> it's a tree of some kind
12:03:02 <poucet> Where's the code?
12:03:08 <kmc_> don't think you need a finger tree if you're not making modified versions
12:03:12 <kmc_> poucet, hackage, data-memocombinators
12:03:21 <poucet> kmc_: thanks
12:03:23 <Cale> If  f :: Bool -> b, then  cond (f True) (f False)  will be a function which is the same as f, but since lazy evaluation never recomputes the parameter to a function, the evaluations of f will be kept
12:03:48 <Cale> (once they get computed the first time, that is)
12:03:59 <Cale> and then there's a function
12:04:02 <Cale> list :: Memo a -> Memo [a]
12:04:07 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
12:04:07 <Cale>     where
12:04:07 <Cale>     table nil cons [] = nil
12:04:07 <Cale>     table nil cons (x:xs) = cons x xs
12:04:17 <Cale> this is basically the same idea, though a bit more complicated
12:04:32 <Cale> But once you have these two, you can memoise anything that you can turn into a string of bits
12:04:42 <poucet> That is pretty impressive
12:04:47 <Cale> There's a sort of implicit tree in the function structure.
12:04:55 <poucet> sick almost =)
12:05:12 <poucet> (And sadly, completely untestable, due to the way the laziness is hacked)
12:05:16 <Cale> oh, btw, type Memo a = forall r. (a -> r) -> (a -> r)
12:05:30 <kmc_> how is it untestable? you have two functions, you can test them for extensional equality
12:05:42 <poucet> kmc_: how do you test whether caching works?
12:05:58 <Cale> I suppose you do timing.
12:06:08 <poucet> or maybe you can go under the hood and look at unevalled thunks
12:06:12 <Cale> yeah
12:06:14 <kmc_> you can count evaluations by using unsafePerformIO to increment an IOVar
12:06:19 <kmc_> or yeah, you could use vacuum
12:06:24 <poucet> completely untestable is perhaps an overstatement
12:06:27 <poucet> definitely dirty to test
12:06:30 <kmc_> yes
12:06:36 <poucet> the way to test it is dirtier than the implementation itself =)
12:06:58 <Cale> One of these days, I might actually cross the threshold of wanting a stepwise evaluator of Haskell that I might actually start working on one.
12:07:11 <kmc_> is the performance contract specifically "never reevaluates a function app" or simply "makes your code a lot faster"
12:07:14 <Cale> It would be nice to have at least a stepwise evaluator for a simple core-like language.
12:07:14 <kmc_> the latter is easy to test
12:07:47 <Cale> Which displays the expression in textual form, and shows the stack as a sequence of case expressions, and the heap as a bunch of let-bound variable bindings :)
12:08:06 <poucet> Cale: no, make it nice and graphicy =)
12:08:15 <poucet> bubbles popping and being created
12:08:19 <poucet> or mybe crocodiles
12:08:28 <Cale> Well, expression graphs would also be nice
12:08:37 <Cale> Like HOPS
12:08:53 <Cale> Actually I *really* wish Dr. Kahl would publish HOPS on the web.
12:09:21 <poucet> Cale: not sure how well that scales beyond simple examples
12:09:35 <Cale> Well, simple examples are really what you want it for.
12:09:39 <poucet> even filter is already getting dirty
12:10:09 <Cale> It's handy for debugging space usage, for instance.
12:12:26 <Cale> My evaluator would mostly be intended as a toy for learning functional programming and evaluation mechanisms.
12:12:40 <Cale> But also might be useful for debugging things.
12:13:08 <Cale> It's just too bad that instrumenting GHC to do the obvious thing seems so insurmountable.
12:13:18 <benmachine> I once tried making one but I was surprised by the amount of language you have to implement to make it work
12:13:36 <benmachine> pattern matching etc.
12:13:46 <Cale> Well, there is that, yes.
12:14:06 <Cale> You could start with simple patterns at first though
12:14:21 <Cale> (ones in which only a single constructor appears in each case)
12:14:48 <Cale> You'd want lambda calculus + let + case, at least.
12:16:03 <Cale> The reason for wanting let is mostly to represent sharing accurately.
12:16:24 <Cale> But also if you end up doing types later, you need it for polymorphism.
12:17:01 <nomeata> Are there alternatives to System.Posix.IO.setLock that work probably?
12:18:04 <ziman> how do you need let for polymorphism?
12:18:18 <Cale> ziman: let-bindings are where the generalisation step occurs
12:18:46 <Cale> ziman: So you go from undetermined type variables to forall'd type variables there.
12:18:55 <sinelaw> Cale, how can i know if it really memoizes it?
12:19:06 <Cale> sinelaw: Well, your program should be much faster.
12:19:16 <Cale> sinelaw: check the profile :)
12:19:19 <ziman> isn't there a proposal for monomorphic let's (or am i confusing something)?
12:19:24 <Cale> ziman: Yes.
12:19:29 <jmcarthur> yeah if it isn't faster then you don't need the memoization anyway ;)
12:19:35 <Cale> ziman: At which point only the top-level would have that generalisation step
12:19:45 <ziman> Cale, ah, i see, thanks
12:19:48 <sinelaw> Cale, it is a little bit faster, i think, but the profile shows that the memoized function takes up most of the time
12:19:49 <Cale> ziman: But traditionally, one thinks of the top-level as one big let
12:19:59 <sinelaw> COST CENTRE                    MODULE               %time %alloc
12:19:59 <sinelaw> binomialPolySample             Math.Binomial         38.9   40.2
12:20:17 <Cale> sinelaw: okay, hmm
12:20:33 <Cale> sinelaw: let's see the line for it lower down in the profile list?
12:20:44 <sinelaw> the updated binomial module is
12:20:45 <sinelaw> module Math.Binomial where
12:20:45 <sinelaw> import qualified Data.MemoCombinators as Memo
12:20:45 <sinelaw> choose :: (Integral a) => a -> a -> a
12:20:45 <sinelaw> choose n k = product [(n-k+1)..n] `div` product [1..k]
12:20:45 <sinelaw>   
12:20:47 <kmc_> ziman, you would still be able to do polymorphic let with an explicit signature, i believe
12:20:47 <sinelaw> binomialCoefs :: (Integral a) => a -> [a]
12:20:49 <sinelaw> binomialCoefs n = map (choose n) [0..n]
12:20:51 <sinelaw> (.*.) :: (Num a) => [a] -> [a] -> [a]
12:20:53 <sinelaw> (.*.) = zipWith (*)
12:20:56 <sinelaw> binomialPoly :: (Integral a1, Num a) => a1 -> a -> a -> [a]
12:20:56 <Cale> hpaste.org
12:20:58 <sinelaw> binomialPoly n a b = binCoefs .*. aPoly .*. bPoly
12:20:59 <sinelaw>     where binCoefs = map fromIntegral (binomialCoefs n)
12:21:01 <sinelaw>           bPoly = map (b^) [0..n]
12:21:03 <sinelaw>           aPoly = map (a^) [n,n-1..0]
12:21:07 <sinelaw> binomialPolySample :: (Fractional c, Integral b) => Integer -> Int -> b -> [c]
12:21:09 <sinelaw> binomialPolySample = Memo.memo3 Memo.integral Memo.integral Memo.integral binomialPolySample'
12:21:11 <sinelaw>   where binomialPolySample' n i sampsNum = binomialPoly (n::Integer) (1-mu) mu
12:21:13 <sinelaw>             where mu = (uniformSamples sampsNum)!!i
12:21:15 <sinelaw>                   
12:21:16 <Cale> ouch
12:21:17 <sinelaw> uniformSamples :: (Fractional b, Integral a) => a -> [b]
12:21:19 <sinelaw> uniformSamples sampsNum = iterate (+1/(fromIntegral sampsNum - 1)) 0
12:21:21 <sinelaw> oh crap.
12:21:23 <sinelaw> I intended to paste, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14862#a14862
12:21:25 <sinelaw> emacs copied the wrong thing :(
12:22:01 <Cale> I've been having all sorts of annoying problems with X losing my primary selection lately, so I understand :)
12:22:44 <sinelaw> maybe i should just do the bezier in C
12:22:49 <sinelaw> but it feels stupid
12:22:55 <Cale> (Select something -> switch windows -> middle click -> oops, it's gone! -> go back -> use the clipboard instead)
12:23:59 <Cale> sinelaw: waaait, how could that be typechecking...
12:24:01 <jmcarthur> sinelaw: what you doing with bezier?
12:24:15 <sinelaw> jmcarthur, rendering graphs laid out by dot
12:24:16 <Cale> sinelaw: Make binomialPolySample monomorphic
12:24:30 <jmcarthur> sinelaw: with what api? opengl?
12:24:57 <Cale> sinelaw: You can't really memoise polymorphic functions because they're functions of extra parameters
12:25:05 <sinelaw> jmcarthur, yeah, via graphics-drawingcombinators
12:25:24 <Cale> sinelaw: So drop the Fractional and Integral constraints, and pick monomorphic types there
12:25:28 <sinelaw> ok
12:26:00 <Cale> (I'm guessing  Int and GLdouble  or something)
12:27:19 <sinelaw> yah
12:27:34 <jmcarthur> sinelaw: http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL-GL-Evaluators.html
12:27:57 <jmcarthur> sinelaw: you will need to find some documentation on it, but that will do what you want fairly simply and quickly
12:28:09 <increpare> hmm; has anyone here tried out getting openGL up and working w/ 6.12?  I'm just trying it out now - a lot of packages to install : P  (there's no cabal-install that works yet with 6.12, right?)
12:28:23 <sinelaw> Cale, can't i leave the return type polymorphic?
12:28:26 <jmcarthur> sinelaw: maybe http://glprogramming.com/red/chapter12.html
12:28:29 <Cale> sinelaw: sbsolutely not
12:28:33 <Cale> absolutely*
12:28:34 <sinelaw> jmcarthur, thanks!
12:28:51 <Cale> sinelaw: typeclass polymorphic things get reevaluated every time they're used
12:29:28 <ACSpike[Work]> I would like to use a package from hackage on win32. where do I start?
12:29:30 <Cale> sinelaw: (because they're not really constants -- under the covers, they're functions of the typeclass dictionary)
12:29:43 <Cale> ACSpike[Work]: Start by getting a copy of cabal-install
12:29:49 <sinelaw> Cale, it makes it pretty ugly to stick GL.GLdouble in there....
12:29:52 <Cale> ACSpike[Work]: Then  cabal install <packagename>
12:30:02 <sinelaw> super-non generic library
12:30:13 <sinelaw> super non-generic that is :)
12:30:14 <Cale> sinelaw: Well, it doesn't matter where you put the monomorphic version, as long as there is one.
12:30:19 <jmcarthur> sinelaw: if you are going for pretty code, the opengl way is not it ;)
12:30:29 <jmcarthur> but it will be fast
12:30:31 <Cale> sinelaw: It should be wherever you put the memoisation step though
12:30:32 <sinelaw> jmcarthur, this isn't directly related to opengl
12:30:38 <increpare> What're you guys up to in opengl?
12:30:43 <dcoutts_> ACSpike[Work]: there's an cabal.exe to download on the cabal website
12:30:52 <Cale> Well, *maybe* it could be elsewhere... I'd have to think hard about that.
12:30:58 <sinelaw> dcoutts_, you mean virus.exe
12:31:08 <sinelaw> increpare, implementing a visual graph editor
12:31:13 <Cale> sinelaw: But essentially, memoisation + polymorphism is nonsense.
12:31:26 <increpare> sinelaw: cool; how's it going along?
12:31:38 <nomeata> Hi. Was anyone successfull in using pcre-light on Windows?
12:31:55 <dcoutts_> sinelaw: I built it myself and I've used it on a win2k3 box with a virus scanner, so I'd be pretty surprised.
12:31:57 <sinelaw> increpare, performance issues main problem
12:32:06 <increpare> sinelaw: really? how big are these graphs?
12:32:10 <sinelaw> dcoutts_, me is kidding
12:32:15 <sinelaw> increpare, tiny
12:32:16 <dcoutts_> sinelaw: I know
12:32:23 <nomeata> I could compile and install the package, but when compiling a package that needs it, I get C:\Programme\Haskell\pcre-light-0.3.1\ghc-6.10.4/libHSpcre-light-0.3.1.a(Light.o):fake:(.text+0x79c): undefined reference to `pcrezmlightzm0zi3zi1_TextziRegexziPCREziLightziBase_Regex_con_info' etc.
12:32:25 <increpare> sinelaw: you drawing them with a vertex array or with immediate-mode calls?
12:32:39 <Cale> sinelaw: I'm interested to hear how it performs when you make that function monomorphic
12:32:57 <sinelaw> inclement, i'm doing it through a wrapper lib that does immediate-mode calls if i understand what you mean (i know very little opengl)
12:32:57 <ACSpike[Work]> Cale: dcoutts_: to I need a bunch of tarballs to go with that exe?
12:33:03 <sinelaw> Cale, working on it
12:33:06 <ACSpike[Work]> er, s/to/do/
12:33:09 <Cale> increpare: All the time is currently spent computing Bezier coefficients
12:33:12 <benmachine> nomeata: are you using --make?
12:33:21 <increpare> Cale: ah! right so : )
12:33:23 <Cale> increpare: We're fixing that :)
12:33:29 <nomeata> benmachine: I’m using cabal
12:33:42 <dcoutts_> ACSpike[Work]: if you just grab the cabal.exe that's it, you can then "cabal update" to get the package list and "cabal install blah" to install things.
12:33:44 <benmachine> oh
12:33:49 <benmachine> *shrug* then
12:34:26 <Beelsebob> is it just me, or is Haskell totally fucked on OS X at the moment
12:34:32 <Beelsebob> due to GHC's inability to produce 64 bit binaries
12:34:40 <Cale> Beelsebob: That is true.
12:34:42 <jmcarthur> oh so the bottleneck isn't in computing the output of bezier but the input for it?
12:34:47 <ACSpike[Work]> Ahhh, relief.
12:34:49 <Beelsebob> and the non-existance of 32 bit zlib
12:34:51 <Beelsebob> you can't even compile cabal for it!
12:34:58 <Beelsebob> (well, cabal-install)
12:35:09 * edwinb has avoided this problem by still running Leopard
12:35:18 <Cale> Beelsebob: GHC 6.10.x is completely broken on Snow Leopard, apparently
12:35:23 <dcoutts_> Beelsebob: there's no need for ghc to produce 64bit binaries. It works fine making 32bit ones.
12:35:26 <Beelsebob> Cale: 6.12 is too
12:35:42 <dcoutts_> 6.10 needs a tweak to work on OSX 10.6
12:35:45 <dcoutts_> 6.12 works
12:35:47 <Beelsebob> dcoutts: when compiling zlib (to get cabal-install) I get that the library is of the wrong architecture
12:35:49 <Beelsebob> with 6.12
12:35:58 <sinelaw> jmcarthur, what do you mean by 'inputs'?
12:36:01 <dcoutts_> Beelsebob: 6.12.1 or an earlier RC?
12:36:06 <Beelsebob> 6.12.1
12:36:14 <jmcarthur> sinelaw: the control points
12:36:21 <sinelaw> jmcarthur, no they are given
12:36:33 <sinelaw> jmcarthur, the sample points along the curve are the problem
12:36:35 <dcoutts_> Beelsebob: do you perhaps have a local zlib from macports that is hiding the system one that comes in both 32 and 64bit flavours?
12:36:39 <jmcarthur> sinelaw: ah. the opengl stuff i linked you to shoudl handle that
12:36:46 <sinelaw> jmcarthur, i'll try that later
12:36:49 <Beelsebob> dcoutts: hmm, perhaps
12:36:49 <jmcarthur> opengl has bezier built in
12:36:51 <Beelsebob> let me check
12:36:55 <sinelaw> right now i'm curious to see how it performs
12:36:58 <Cale> jmcarthur: His code spent all its time computing binomial coefficients, but we should have that fixed.
12:37:06 <jmcarthur> sinelaw: gotcha
12:37:27 <dcoutts_> Beelsebob: we've certainly seen problems recently on OSX with C libs from macports overriding the system ones and causing problems, eg iconv.
12:37:30 <Cale> It's nice to do things in Haskell when it's reasonable to :)
12:37:37 <jmcarthur> agreed
12:37:50 <Beelsebob> dcoutts: for reference – this is because apparently cabal didn't get updated with ghc – is this normal?
12:38:06 <Beelsebob> I currently have a cabal-install that just goes "wtf came out of ghc-pkg dump?"
12:38:07 <dcoutts_> Beelsebob: right, they're distributed separately
12:38:47 <dcoutts_> Beelsebob: yep, that's what 0.6.2 or older reports. 0.6.4 reports "please upgrade to 0.8" and 0.8 works.
12:38:51 <Cale> I think it's a bit of a shame. Even if the rest of platform is in platform, I think cabal install should come with GHC
12:39:08 <Beelsebob> dcoutts: ah cool – you were right – I had a zlib hiding in /opt
12:39:13 <Beelsebob> compiled now – many thanks
12:39:17 <dcoutts_> the simpler upgrade path is to upgrade cabal-install first
12:39:20 <Cale> Because it'd just be so convenient, and who uses GHC that doesn't also use cabal install?
12:39:22 <edwinb> Mmm, I was slightly surprised by that cabal problem when I upgraded
12:39:27 <edwinb> it'd be great if it came which ghc
12:39:31 <edwinb> with*
12:39:35 <dcoutts_> Cale: it means synchronising releases.
12:39:45 * jmcarthur is happy with pacman -S cabal-install
12:39:49 <Beelsebob> yeh, it would
12:39:51 <Beelsebob> cabal has become near-critical to ghc
12:39:54 <Beelsebob> especially given that it doesn't come with many libraries any more
12:40:01 <Beelsebob> the first thing you do is cabal install lots of stuff
12:40:06 <Cale> dcoutts_: Well, you can always put intermediate releases on hackage, no?
12:40:10 <nomeata> benmachine: its reproducible with a small "import Text.Regex.PCRE.Light; main = return ()" file that I compile with ghc --make
12:40:51 <Cale> dcoutts_: It's not like it actually needs to get hardwired into GHC in any major way, it just needs to be installed when GHC is installed.
12:40:51 <c_wraith> dcoutts: is that significantly different from the current case?  Right now, only the people who are willing to do a lot of work are using 6.12.  everyone else is waiting for the cabal release.  That's pretty similar to what would happen if releases were synchronized
12:41:09 <dcoutts_> Cale: not that easily, not if we want to stop the masses immediately upgrading and hitting bugs
12:41:45 <dcoutts_> Beelsebob: I think it's a perception change that we need. We don't immediately install a new gcc 4.0 release, we wait for things to catch up.
12:41:48 <tibbe|away> bos: I'll get to your patch tomorrow morning
12:42:00 <dcoutts_> Beelsebob: having the haskell platform come out later than ghc is a deliberate thing
12:42:08 <Cale> I'm thinking that the GHC installer would look like a super-miniature version of platform which just installs GHC and the stuff necessary for one particular version of cabal-install.
12:42:15 <tibbe|away> bos: we could potentially kill the callback code if we return a list of events given that that list gets fused away
12:42:33 <Beelsebob> dcoutts: right, but for me getting a (more) supported GHC on 10.6 was rather critical
12:42:35 <dcoutts_> Cale: but who is that for?
12:42:48 <Cale> dcoutts_: People who don't want to wait 6 months for the latest GHC?
12:42:57 <tibbe|away> bos: it's not enough to replace just the select call in Conc.lhs though since the whole algorithm implemented in that module is O(watched fds) as it loops through all fds (and timers)
12:43:01 <dcoutts_> Beelsebob: 6.10.4 will work as well as 6.12 with a tweak to a couple wrapper scripts. There are instructions.
12:43:03 <Cale> Just bundle whatever version of cabal install is available.
12:43:11 <Cale> as a convenience
12:43:13 <nomeata> Can someone on windows please run cabal install pcre-light for a moment and see if it works for him?
12:43:26 <dcoutts_> Beelsebob: 6.12.1 is not aimed at users, it's for package maintainers to get their stuff updated in time for 6.12.2 and the Haskell Platform.
12:44:03 <c_wraith> then why isn't it a release candidate?
12:44:07 <Beelsebob> dcoutts: perhaps it should be called 6.12.1 pre-release then
12:44:11 <Beelsebob> not 6.12.1
12:44:25 <dcoutts_> but then nobody would go and update their packages
12:44:38 <dcoutts_> there's a gradation from RC through stable
12:44:55 <Beelsebob> well yes they would, if you explicitly said on the announcement "we've just released 6.12.1 RC 1 – please upgrade your packages before we make the release to the general public"
12:44:59 <dcoutts_> the first "real" release is a signal for maintaiers that they should go update their packages
12:45:13 <dcoutts_> but it's only the second release that we want to encourage users to use
12:45:15 <sinelaw> Cale, still
12:45:15 <sinelaw> COST CENTRE                    MODULE               %time %alloc
12:45:16 <sinelaw> binomialPolySample             Math.Bezier           48.2   36.2
12:45:20 <sinelaw> it's monomorphic now
12:45:30 <sinelaw> binomialPolySample :: Integer -> Int -> Integer -> [GL.GLdouble]
12:45:33 <Cale> sinelaw: How many times is it called?
12:45:38 <Beelsebob> dcoutts: certainly that's not the way that either the website or announcement emails read
12:45:53 <dcoutts_> Beelsebob: the website certainly tells end users to hold off
12:45:53 <Beelsebob> the ghc website reads as "6.12.1 is the latest, download it" to anyone going there to grab ghc
12:46:00 <dcoutts_> click on the link
12:46:00 <Cale> sinelaw: (look in the table under the 'entries' column)
12:46:13 <Beelsebob> dcoutts: you go to download, and what do you see - a list of releases, with 6.12.1 at the top
12:46:14 <sinelaw> Cale, 0??
12:46:17 <dcoutts_> Beelsebob: notice the big disclamers?
12:46:18 <Cale> sinelaw: hmm
12:46:20 <Beelsebob> that's all that most people will ever see
12:46:29 <boris__> it seems I've spotted a bug in GHC. I give option -N2 to make runtime parallel, it complains about unknown RTS option but execution time decreases twicefold, which shows it recognized the option.
12:46:30 <Cale> sinelaw: can I see the .prof file?
12:46:32 <dcoutts_> Beelsebob: not if they actually click through to download it
12:46:43 <sinelaw> it has two entries in the list, on says 0 the other 82
12:46:49 <Cale> hmm
12:46:50 <sinelaw> only the first takes up any time
12:47:01 <Beelsebob> dcoutts: all you see there is "use the Haskell platform, not ghc" – it doesn't say "this is not aimed at users yet" in any way
12:47:13 <Beelsebob> all you do is click the haskell platform link
12:47:15 <Cale> sinelaw: This is with -O2 on I guess?
12:47:16 <Beelsebob> go "oh, it's out of date"
12:47:20 <Beelsebob> press the back button
12:47:20 <boris__> yes
12:47:21 <sinelaw> sure
12:47:25 <Beelsebob> and install 6.12.1
12:47:38 <dcoutts_> Beelsebob: "Stop! For most users, we recommend installing the Haskell Platform instead of GHC."
12:47:40 <dixie> aaaaaaaaaaaaaaaaaaaaaaaaaaa
12:47:42 <Cale> sinelaw: Sometimes optimisation can make for confusing profiling results
12:47:43 <dons> boris__: did you compile with -threaded ?
12:47:43 <dcoutts_> that seems fairly clear
12:47:57 <sinelaw> Cale, well i have:   ghc-options : -O2 -Wall       Ghc-Prof-Options:  -prof -auto-all
12:47:59 <dcoutts_> Beelsebob: if you want to suggest improved wording I'm sure they'd apreciate it
12:48:09 <BMeph> So, why not call it 6.12.0? :)
12:48:14 <boris__> dons: no, I compiled with -O2
12:48:19 <sinelaw> Cale, http://www.ee.bgu.ac.il/~noamle/_downloads/graphui.prof
12:48:20 <Beelsebob> dcoutts: right it seems fairly clear that you should use Haskell platform – and again, the behavior of the average user would be to click the link, and then go "oh, it's out of date, I'll install  ghc instead"
12:48:30 <dcoutts_> BMeph: because then you cannot have any RC's with a 6.12.x version number.
12:48:37 <Beelsebob> BMeph: because most users would read that the same way – I certainly expect version numbers to be 0 based
12:49:00 <medfly> ?
12:49:09 <Beelsebob> realistically, the way to sort this is to (a) name it 6.12.1 Release Canditate (b) inform package manitaners
12:49:25 <Beelsebob> because informing package manitainers is a *lot* easier than informing all present and future users of ghc
12:49:39 <dcoutts_> you have to do it publicly
12:49:48 <dcoutts_> there are too many package maintainers
12:49:48 <Beelsebob> you do
12:49:52 <dcoutts_> we do not know who they are
12:49:56 <c_wraith> if it said "do not use this" in red where it currently says "stop", that would help.
12:50:13 <Beelsebob> so put it on the mailing list "Announce – GHC 6.12.1 release to package maintainers"
12:50:39 <Cale> sinelaw: oh, er, how does bezier4 look now?
12:50:46 <Beelsebob> and say very clearly "please check your packages work with 6.12.1 – users, please hold off until it's out of release candidate status"
12:50:51 <boris__> dons: I've tried with -threaded. The error is still shown
12:51:02 <dons> you compile with -threaded, and the +RTS -N2 doesn't work?
12:51:46 <sinelaw> Cale, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14863#a14863
12:51:49 <lispy> boris__: you can check if foo is using  the threaded rts by running, foo +RTS --info, and looking at the output
12:51:50 <dcoutts_> Beelsebob: I agree, it could have been noted in the announcement. It's been fairly well explained elsewhere like in ghc status updates, HCAR etc.
12:52:06 <Beelsebob> dcoutts: not noted – said, in big bold letters in the subject line
12:52:18 <Beelsebob> i.e. don't get users excited by saying [Announce] GHC 6.12.1
12:52:19 <Cale> sinelaw: aha, okay, try this...
12:52:32 <boris__> dons: no, it works (execution time decreases twicefold), but it complains about unknown RTS option. I don't think it is RTS issue, rather option processing one.
12:52:42 <lispy> dcoutts: actually, I have to admit, I missed the "wait for the next HP release" bit too
12:52:59 <dcoutts_> Cale: the problem with making a super-convenient-package-on-every-platform immediately is that then people expect everything to work, which it's not going to.
12:53:30 <dcoutts_> Cale: it's all about the smooth path from development version to stable release. It cannot happen in a bang.
12:53:32 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14863#a14865
12:54:00 <dcoutts_> you need to give people the right signals to get them to try it out, but not push it too hard when you still expect some troubles.
12:54:27 <c_wraith> by the way, dcoutts_: we love your work.  Please don't think otherwise. :)
12:54:32 <Cale> Well, giving them cabal-install makes it easier for them to try things out ;)
12:54:54 <Cale> sinelaw: I have no idea why that pasted twice.
12:55:01 <Cale> (they ought to be the same)
12:55:04 <sinelaw> let me see
12:55:21 <Cale> er, d'oh
12:55:36 <Cale> sinelaw: That code has scoping problems :)
12:55:44 <sinelaw> why should that solve it, btw?
12:55:48 <dcoutts_> Cale: in some ways it's a benefit. The maintainers of core packages can do this with or without cabal-install, and they're the people we really want to target in the first release.
12:56:07 <dcoutts_> and if it puts up a barrier for casual users, that's probably a good thing
12:56:40 <Cale> sinelaw: because we want the computation of bezier4 with a fixed i and sampsNum to save the coefficients and not recompute them for each v1 .. v4
12:57:06 <sinelaw> Cale, ok
12:57:20 <dcoutts_> c_wraith: turns out release management is hard. Who'd have thought. :-)
12:57:25 <Cale> sinelaw: And GHC never lifts bindings in such a way that it would split up a lambda
12:57:30 <Cale> sinelaw: even if it can
12:57:42 <sinelaw> Cale, btw, i'm pretty silly. I just sped the whole program up with a trivial optimization - calculating the bezier only when laying out the graph
12:57:48 <sinelaw> instead of when rendering
12:57:52 <boris__> when I was recompiling with -threaded I forgot to delete old files. Now it is ok :)
12:57:54 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14863#a14866
12:57:57 <sinelaw> that was DUMB
12:58:34 <sinelaw> Cale, ok trying (i'll revert my optimization to make it easier to see if this helps)
12:58:38 <Cale> sinelaw: well, there's a should-be-not-broken version anyway :)
13:01:15 <Cale> tsk, I just realised that the parameter order on bezier4 seems silly
13:01:19 <sinelaw> Cale, wow. i did ctrl-c on my program and it crashed Xorg
13:01:25 <Cale> and so that's probably not the right ordering
13:02:13 <Cale> Unless somehow you're computing the ith point in each spline all at once.
13:02:31 <sinelaw> Cale, i'll be back in about 10 minutes, using that preemption as an excuse to do some stuff
13:02:37 <Cale> okay
13:02:41 <sinelaw> then i'll check out the new version of bezier4
13:03:06 <Cale> sinelaw: Something to remember about functions: the parameters should always go in ascending order of expected rate of change
13:03:18 <Cale> sinelaw: This is not just a style thing, but a performance thing too.
13:03:57 <Cale> sinelaw: Whether my change of bezier4 will have any effect is dependent on how you partially apply it elsewhere :)
13:04:41 <CalJohn> Is there a nice way to avoid having "function _ = Nothing" as a second equation on every maybe function?
13:04:52 <Cale> Use fmap instead maybe?
13:04:58 <koeien37> :t fmap
13:04:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:05:11 <koeien37> > fmap (+1) (Just 37)
13:05:12 <lambdabot>   Just 38
13:05:17 <koeien37> > fmap (+1) Nothing
13:05:18 <lambdabot>   Nothing
13:05:25 <koeien37> > (+1) . Just 37 -- Cale's magic
13:05:27 <lambdabot>   Just 38
13:05:56 <Cale> Also, Maybe is a monad, which allows for convenient chaining of Maybe-producing functions, when you want any Nothing along the way to result in Nothing overall
13:06:52 <koeien37> fmap "lifts" a function a -> b to a function f a -> f b, for functors f. Maybe is a Functor (and a Monad, as Cale pointed out). Another example of a functor are lists
13:06:58 <koeien37> > fmap (*2) [1,2,3]
13:07:02 <lambdabot>   [2,4,6]
13:07:03 <Cale> > let dict = [(0,1),(1,2)] in do x <- lookup 0 dict; y <- lookup x dict; return y
13:07:04 <lambdabot>   Just 2
13:07:17 <Cale> > let dict = [(0,1),(1,2)] in do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return z
13:07:18 <lambdabot>   Nothing
13:07:46 <CalJohn> mmm, fmap is a good idea, thanks
13:07:50 <kmc_> :t maybe Nothing
13:07:51 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
13:08:16 <kmc_> CalJohn, I like to write fmap infix as <$>, from Control.Applicative
13:08:22 <kmc_> > succ <$> (Just 7)
13:08:23 <lambdabot>   Just 8
13:08:25 <kmc_> > succ <$> Nothing
13:08:26 <lambdabot>   Nothing
13:08:47 <kmc_> > succ <$> [1,2,4,7]
13:08:48 <lambdabot>   [2,3,5,8]
13:08:50 <CalJohn> yes, so do I, I'm thinking about how to do that for what i want to do
13:09:35 <gwern> fun. I can no longer install criterion because templatehaskell barfs on 6.10.2, and going via regular cabal instead of cabal-install yields 'Registering criterion-0.4.0..Setup: internal error: unexpected package db stack'
13:10:12 <dcoutts_> gwern: I think that db stack bug is fixed in the darcs version of cabal-install, lemme know
13:10:40 <BMeph> Hmm, I never thought of it that way, but functions are a good example to explain the difference between identity and equality.
13:11:03 <kmc_> is there a single global difference between those terms?
13:11:10 <mux> is there someone to con
13:11:11 <kmc_> they seem to mean something different in each language or system
13:11:27 <mux> is there someone to contact beside ross paterson to request a package to be rebuilt?
13:11:56 <mux> it would be lame to have to bump the version number just because the build bot had issues or something
13:12:13 <dcoutts_> mux: I suggest ignoring it
13:12:14 <CalJohn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14867#a14867 <-- here was the code i was golfing, if anyone is interested
13:12:27 <mux> dcoutts_: that's an option, but it makes the thing look bad
13:12:29 <dcoutts_> mux: your package isn't the only one where the buildbot does stupid things
13:12:47 <BMeph> kmc_: I think of it the same way I do the difference between voltage and (electric) potential; one is "absolute", while the other is relative. :)
13:12:47 <mux> oh well, it's not like anyone uses it anyway. :-)
13:12:56 <dcoutts_> displaying the info does almost as much harm as good, sadly :-(
13:13:01 <dcoutts_> since it's low quality
13:13:16 <mux> dcoutts_: maybe it would be nice to only show it when people have authenticated
13:14:04 <dcoutts_> mux: in the new server the data will be much more reliable, since it'll be collected from multiple bots
13:14:12 <dcoutts_> and actual end user reports
13:14:17 <mux> dcoutts_: new server? cool!
13:14:26 <dcoutts_> though then we need to use stats to work out any useful info
13:14:45 <dcoutts_> to boil down 100+ build reports across a dozen platforms
13:14:58 * dcoutts_ isn't so good with the stats
13:15:48 <mux> dcoutts_: what annoys me most with this build failure is that there is no online documentation now
13:16:25 <dcoutts_> yeah
13:16:42 <dcoutts_> so that's the other improvement in the new server
13:16:56 <sinelaw> Cale, ok i'm back
13:17:24 <dcoutts_> mux: since there can be multiple bots, better chance of a successful build, and also suitably authenticated clients can upload docs.
13:17:32 <dcoutts_> mux: eg the package maintainer
13:17:43 <mux> dcoutts_: sounds good
13:18:03 <ACSpike[Work]> what do I call it when the parameters of the value constructors have names?
13:18:28 <kmc_> record?
13:18:38 <kmc_> data Foo = Foo { bar :: Int} -- like this?
13:20:06 <Cale> sinelaw: Did you catch my comments above?
13:20:21 <Cale> sinelaw: (about parameter ordering)
13:20:34 <ACSpike[Work]> kmc_: yes, thanks!
13:20:40 <sinelaw> Cale, I think so, yes
13:20:47 <sinelaw> unless you had more after I quit
13:21:35 <Cale> Nope :)
13:21:40 <gwern> so I was thinking of benchmarking 'sort'. what's a good variety of material?
13:22:07 <dons> a random sample of 10^7 values?
13:22:33 <Cale> The already-sorted and already-reverse-sorted list, also
13:22:36 <gwern> yes, but random of what? Chars are common enough
13:22:36 <koeien37> and some special cases
13:22:43 <mux> you also need to benchmark it against already sorted values, nearly sorted values and inversely sorted ones
13:22:44 <koeien37> yeah, what Cale said
13:22:51 <gwern> is there no commonly accepted set of cases?
13:23:03 <dons> Doubles, Ints.
13:23:16 <dons> not Chars, too small a range (unless you're testing some kind of bucket sort)
13:23:21 <dons> or unicode, that'd be ok.
13:24:07 <vic_> Ok, this is confusing. I've downloaded haskell-platform-2009.2.0.2.tar.gz and it says I need to install ghc. But here http://www.haskell.org/ghc/download_ghc_6_12_1.html it says that "The Haskell Platform includes a recent GHC as well as some other tools (such as cabal), and a larger set of libraries that are known to work together". So...
13:24:39 <dcoutts_> Beelsebob: sorry to return yet again to an earlier conversation, but one reason beyond me/us being obstinate about not bundling is that it would mean "core" ghc releases would need 6 (and soon to be 7) extra non-core packages.
13:24:44 <Cale> maybe some things like a list whose minimum value is right in the middle, and when split up into two lists not including that middle element, each recursively has that same property
13:25:15 <koeien37> Data.List.sort is merge sort?
13:25:22 <mux> isn't that quicksort's worse case scenario?
13:25:25 <gwern> koeien37: yeah, but yhc has a faster one
13:25:29 <Cale> (or various other lists where the minimum elements occur nice fractions of the way through the list)
13:25:31 <Beelsebob> mux: no
13:25:39 <vic_> Hm, just finished downloading ghc-6.12.1. Let's see if I break my box.
13:25:39 <Beelsebob> mux: mergesort is always O(log n)
13:25:42 <dcoutts_> vic_: the source bundle for the HP doesn't include ghc itself, your distro probably has it, otherwise you can get a binary from the ghc site.
13:25:43 <xerox> ?docs Data.List
13:25:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:25:46 <Cale> Well, for some implementations of quicksort it might be
13:25:46 <mux> Beelsebob: I said quicksort
13:25:47 <Beelsebob> quicksort's worst case is O(n^2)
13:25:51 <mux> yes
13:25:54 <vic_> dcoutts_: thanks
13:25:55 <dcoutts_> vic_: the binary installers for various platforms include a binary of ghc
13:26:04 <gwern> Cale: any clean way of generating those minimum lists?
13:26:05 <dave_r5> if i have a few monad transformers wrapped around STM, is there a clean way to read/write TVars within my new monad? (i'm a newbie with monad transformers)
13:26:09 <mux> Beelsebob: and I was asking Cale if that was the O(n^2) case he was describing
13:26:10 <Beelsebob> mux: the point being that quicksort's worst case is worse than mergesort's worst case
13:26:12 * Twey wants a construct that can Maybe match a pattern.
13:26:25 <vic_> Well, I just purged 6.8.2 from my Ubuntu and going to install 6.12.1
13:26:26 <Cale> gwern: I'd probably do it by generating a binary tree and then flattening it
13:26:28 <Beelsebob> mux: oh sorry, I associated your reply with the wrong comment
13:26:33 <mux> Beelsebob: yeah no problem
13:26:35 <vic_> Hope this goes well
13:26:39 <Cale> mux: It depends on how it selects a pivot
13:26:41 <mux> I should have been more specific
13:26:41 <dcoutts_> vic_: I'd hold off and use ghc-6.10 and the HP
13:26:42 <xerox> koeien37: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/Data-List.html#sort
13:26:50 <koeien37> vlc_: I'd use 6.10.4 for now
13:26:54 <gwern> Cale: I was hoping not to spend more than an hour on this :)
13:27:00 <dcoutts_> vic_: ubuntu packages alsmost all the component parts of the HP
13:27:01 <vic_> 6.12 is too bleeding edge?
13:27:05 <dcoutts_> vic_: yes
13:27:07 <koeien37> until HP for 6.12 comes out
13:27:12 <vic_> Thought so
13:27:14 <vic_> Ok
13:27:19 <Cale> gwern: ah, then don't worry about it unless you have a sorting algorithm for which it would seem like the worst case
13:27:25 <dibblego> if I want a module to export a bunch of other modules, then what more do I need than to list the imports?
13:27:30 <sinelaw> Cale, still takes a lot of time
13:27:37 <gwern> Cale: well, you saw the discussion of the yhc algo didn't you?
13:27:42 <gwern> see http://neilmitchell.blogspot.com/2008/03/sorting-at-speed.html as well
13:27:57 <vic_> I've installed Haskell Platform and ghc 6.10 on another Ubuntu box and it worked like  charm
13:28:00 <Cale> sinelaw: Yeah, I'm betting that you don't actually use bezier4 with a fixed i and sampsNum but changing vectors
13:28:07 <vic_> *6.10.4
13:28:11 <sinelaw> Cale, http://www.ee.bgu.ac.il/~noamle/_downloads/graphui.prof
13:28:16 <sinelaw> Cale, i'll check that with trace
13:28:26 <Twey> maybeMatch pattern value transformation = case value of resultingBindings@pattern -> Just $ transformation resultingBindings; _ -> Nothing
13:28:29 <gwern> is readFile lazy?
13:28:35 <sinelaw> Cale, but i don't think so
13:28:40 <Twey> And patterns could be first-class functions to sets of bindings…
13:28:44 <Cale> sinelaw: The version that I gave is sort of optimised for something like zipWith4 (bezier4 i n) vs1 vs2 vs3 vs4
13:29:03 <Cale> sinelaw: Whereas that's probably not actually what you're doing
13:29:21 <sinelaw> you can see what i'm doing in hpaste, in bezierN
13:29:34 <sinelaw> Cale, how is it optimized for that?
13:29:45 <sinelaw> isn't it memoized anyway?
13:30:00 <sinelaw> I mean isn't binomialPolySample memoized?
13:30:15 <Cale> I suppose that it is memoised anyhow
13:30:27 <Cale> But this avoids even doing the memo table lookup.
13:30:37 <sinelaw> sow why does it take 48% time
13:30:40 <sinelaw> *so
13:30:46 <Cale> Well, only if it gets used in the right way
13:30:58 <sinelaw> which is
13:31:00 <sinelaw> ?
13:31:12 <mux> dcoutts_: do you intend to reenable "cabal upgrade" if GHC doesn't ship with extra packages and only use ghc-foo bundled packages?
13:31:27 <Cale> which is calling it in one place with a constant i and sampsNum, but allowing the vectors to vary
13:31:40 <gwern> dcoutts_: no, darcs cabal and cabal-isntal  still have thatdb stack error
13:31:51 <gwern> i'll try cleaning though
13:32:02 <dcoutts_> gwern: ok, thanks, can you file a ticket with enough details for me to reproduce it?
13:32:02 <gwern> (maybe the old build had the error)
13:32:09 <dcoutts_> gwern: ok
13:32:16 <ACSpike[Work]> I started globbing in python, but then I thought it might be fun if I could glob lazily... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14868#a14868 am I doing this right? from the runtime I expect it has to produce the whole list anyway.
13:32:18 <Cale> sinelaw: See, after it's applied to i and sampsNum, the way it's written, it'll turn into let coeffs = ... in ...
13:32:20 <gwern> nope, cleaned and criterion still as the error
13:32:27 <dcoutts_> mux: I intend to eliminate upgrade as a separate command and make it a flag for install. People get confused between install and upgrade.
13:32:40 <Cale> sinelaw: and then as that function gets used, the coeffs table will become fixed
13:32:49 <sinelaw> i see
13:32:52 <dcoutts_> mux: as for upgrading "everything" I think perhaps the new "world" feature might help there.
13:32:55 <sinelaw> and that is exactly what you did
13:33:01 <sinelaw> but it still takes up time
13:33:29 <Cale> sinelaw: It just happens to be an optimisation that doesn't help here because of the way it gets called.
13:33:31 <mux> dcoutts_: what is this feature if I may ask?
13:34:26 <dcoutts_> mux: if you've ever used gentoo, it's got a thing where you "emerge world" which is a short hand for building all the packages that you ever explicitly asked to build (ie not including uninteresting dependencies)
13:34:41 <dcoutts_> mux: so the usual gentoo thing is "emerge --update --deep world"
13:35:07 <mux> alright then
13:35:09 <sinelaw> Cale, well, what else can i do before abandoning the memoization and using only my trivial optimization (which is really good, because it eliminates most of the calls to bezier in the first place)
13:35:10 <dcoutts_> mux: meaning don't reinstall the same version, and also try to upgrade dependencies.
13:35:26 <mux> dcoutts_: I'm more of a "make buildworld" kinda guy (command ot build all of FreeBSD's userland ;-)
13:35:39 <dcoutts_> mux: and what are the semantics of that exactly?
13:35:48 <mux> entirely unrelated really
13:35:57 <mux> it just builds stuff, like a good old "make"
13:36:15 <dcoutts_> mux: the main benefit should be to make it easier to rebuild packages when switching ghc versions, since the world list will be global.
13:36:23 <mux> I only mentioned it to hilight my preference twoards this OS
13:36:35 <mux> dcoutts_: yes, that would be just fine
13:36:56 <Cale> sinelaw: Well, just go with the trivial optimisation.
13:36:59 <mux> now cabal only needs to borrow from Nix I guess - it's a shame that Haskell doesn't have the first "functional" package management
13:37:16 <Cale> sinelaw: It's kind of hairy thinking about how to rework this to make that memoisation help.
13:37:17 <dcoutts_> mux: that's my long-term plan, to steal all the good ideas out of nix.
13:37:24 <mux> dcoutts++
13:37:26 <sinelaw> Cale, too bad. after all the time spent :)
13:37:29 <mux> @karma dcoutts
13:37:29 <lambdabot> dcoutts has a karma of 12
13:37:29 <sinelaw> @karma dcoutts
13:37:30 <lambdabot> dcoutts has a karma of 12
13:37:34 <Cale> sinelaw: It's okay :)
13:37:47 <Cale> sinelaw: Well, the memoisation is helping
13:37:57 <dcoutts_> mux: so the tricky thing with upgrade as-is, is which packages we try to upgrade and whether or not we try to do it consistently.
13:37:58 <Cale> sinelaw: But there could be a touch more of it
13:38:20 <sinelaw> Cale, :) for future generations of bezier users, it could be nice. but for my program i think it's not important
13:38:31 <sinelaw> Cale, it doesn't seem to help at all
13:38:37 <sinelaw> still 48% time
13:38:44 <dcoutts_> mux: eg if you've got A and B and they're not the latest versions, we might be able to make an install plan for A, and we might be able to make one for B, but that's no guarantee we can make one for A & B simultaneously.
13:38:45 <Cale> sinelaw: hmm, I wonder if the memo table is being thrown away
13:38:50 <vic_> "Installation of ghc-6.10.4 was successful". Nice. Too bad I forgot about the old checkinstall -y trick
13:39:04 <Cale> sinelaw: Perhaps it would have been smarter just to memoise on the first parameter of binomialPoly alone
13:39:14 <dcoutts_> mux: and of course unlike a normal install, when you're trying to upgrade all the packages you've got, that situation is much more likely.
13:39:20 <mux> dcoutts_: yeah; I think most package management tools silently ignore that problem and just sequentially try to upgrade all the upgradable packages
13:39:33 <Cale> hmm, I don't know
13:39:35 <sinelaw> Cale, i may have been running a wrong version the last few tests...wait :(
13:39:38 <dcoutts_> mux: you'll have installed A and B at different times and there was no necessecity for them to have consistent deps.
13:39:49 <mux> dcoutts_: in an ideal world, there should never be a problem updating all the packages because if we haev a Nix-like system, we can have as much parallel installs as we want
13:40:14 <dcoutts_> mux: right, they could have inconsistent deps and it'd be fine (though nothing could depend on both
13:40:18 <mux> I mean having several versions of the same package without conflicts
13:40:22 <jfischoff> newb question: is there a built in way to do Double eq comparision that takes in a tolerance?
13:40:43 <Cale> jfischoff: abs (x - y) < epsilon
13:40:48 <mux> dcoutts_: for library packages that sounds just easy; for binary packages it's probably more complex
13:41:00 <dcoutts_> mux: so atm, the solver would have to be extended to allow partially inconsistent plans (though with a preference for consitent ones).
13:41:09 <sinelaw> Cale, nope, it was the right version.
13:41:17 <jfischoff> Cale: so there is nothing built in?
13:41:31 <Cale> jfischoff: Not that I'm aware of
13:41:39 <sinelaw> Cale, as a last attempt i'll trace the parameters passed to those functions
13:41:44 <kmc_> let close :: (Num a) -> a -> a -> a -> Bool; close eps a b = abs (a - b) < eps; myCmp = close 0.000000001
13:41:49 <Cale> jfischoff: But it's not hard to write as a lambda
13:42:01 <sinelaw> Cale, if I trace inside a memoized function, will it still be memoized?
13:42:11 <Cale> sinelaw: yes
13:42:21 <jfischoff> is it possible to rediffine the Eq instance for Double?
13:42:21 <sinelaw> Cale, can i use the lack of traces to conclude that memoization is working?
13:42:31 <kmc_> jfischoff, not easily
13:42:33 <lispy> jfischoff: yes if you use a newtype
13:42:40 <kmc_> ah that is a good suggestion
13:42:44 <lispy> newtype MyFloat = MF Float
13:42:45 <Cale> sinelaw: yes, if you were to trace on the inner thing which you're applying the memo combinator to
13:42:49 <jfischoff> lispy: cool
13:42:53 <sinelaw> ok
13:42:55 <mux> extended newtype deriving makes that easy
13:43:03 <dcoutts_> mux: also, with a slightly cleverer solver we could mostly avoid the problem of trying to upgrade core packages, since the non-upgradable ghc package would pin down the core packages.
13:43:09 <mux> otherwise you'd have to rewire all the Num, Floating, etc type classes
13:43:12 <lispy> jfischoff: the downside is that you need to manually wrap/unwrap it
13:43:16 <Cale> sinelaw: You should only see a trace for a given set of parameters once
13:43:16 <kmc_> jfischoff, if you're trying to use some Prelude list function, there are more general versions in Data.List
13:43:23 <sinelaw> Cale, ok trying that
13:43:24 <kmc_> that will take the comparison function as an arg
13:43:34 * kmc_ wishes we had local instances
13:43:38 <jfischoff> lispy: what do you mean?
13:43:38 <dcoutts_> mux: but if you want a short answer, I don't expect to re-enable it any time soon, and when we do it'll look rather different.
13:43:38 <mux> dcoutts_: would't it make sense to flag them as "not upgradable"?
13:43:52 <dcoutts_> mux: the question is where that info is kept
13:44:27 <mux> I'd say, the same place where the hidden flag is kept - and no worries, we can let people shoot themselves in the foot by allowing them to disable it
13:44:38 <lispy> {# LANGUAGE GeneralizedNewtypeDeriving #-} newtype MyFloat = MF Float deriving (Enum, Eq, Floaating, Fractional, Ord, Read, Real, RealFloat, RealFrac, Show)  <-- that's a start, then add your own instance for Num
13:44:40 <mux> that can even come in handy some day
13:44:48 <dcoutts_> mux: it's a possibility
13:45:11 <Cale> sinelaw: Actually, I think probably it would have been smarter to memoise on the binomial coefficients in a separate step from the parameters.
13:45:13 <sinelaw> Cale, it is being memoized then
13:45:19 <Cale> sinelaw: oh, good
13:45:28 <lispy> jfischoff: Well, when you pattern match on a MyFloat, you'll have to say, foo (MF x) = ..., if you want to examine the floating point value x that is stored in your MyFloat
13:45:47 <jfischoff> oh right
13:45:51 <Cale> sinelaw: Maybe even the memo lookup is slow enough that it's not any better than recomputing the thing
13:45:51 <dpratt71> I've recently come across a paper "Functional Reactive Animation" by C. Elliot and P. Hudak; has this been "realized" as a library?
13:45:53 <sinelaw> Cale, I guess the time is spent looking up the table?
13:45:54 <jfischoff> bleh
13:45:57 <jfischoff> I'll pass
13:45:58 <sinelaw> yeah
13:46:11 <sinelaw> dpratt71, are you kidding?
13:46:13 <lispy> jfischoff: but, once you define Num you won't deal with that often
13:46:27 <dpratt71> sinelaw: um...no
13:46:35 <lispy> (MF x) + (MF y) = MF $ x + y -- or whatever you want
13:46:37 <jfischoff> hmm
13:46:45 <sinelaw> dpratt71, http://www.ee.bgu.ac.il/~noamle/resources.html
13:46:47 <jfischoff> food for thought
13:46:47 <lispy> then you can just add MyFloats
13:46:56 <pozic> dpratt71: there are a gazillion "FRP" libraries. Everyone has a different idea of what FTP is.
13:47:07 <pozic> dpratt71: See hackage
13:47:15 <c_wraith> But conal quit because you mentioned him.  I think.  :)
13:47:24 <sinelaw> heh
13:47:27 <kmc_> good strategy
13:47:47 <pozic> FRP*
13:47:55 <sinelaw> dpratt71, the most recent paper is http://conal.net/papers/push-pull-frp/
13:47:57 <dpratt71> sinelaw, pozic: thanks; I did see an FRP category in hackage, but I wasn't sure if the paper was referring to a specific implementation of FRP
13:48:25 <dpratt71> sinelaw: nice; thanks again
13:49:02 <sinelaw> Conal Elliot
13:49:26 <sinelaw> c_wraith, you were wrong
13:50:00 <c_wraith> happens more often than not, in here. :)
13:50:00 <sinelaw> oops i missed a t in the last name again. sorry :(
13:50:20 <dpratt71> which implementation would most closely relate to the original paper I referenced?; Or is that so outmoded, I should forget it?
13:50:35 <sinelaw> dpratt71, that's outdated. read the push-pull paper
13:50:39 <sinelaw> or at least parts of it
13:50:51 <sinelaw> dpratt71, Reactive is conal's own up-to-date implementation
13:51:01 <c_wraith> I'd guess that since FRP is conal's thing, his library is closest to his original idea.
13:51:02 <dpratt71> sinelaw: consider it forgotten; thanks
13:51:04 <sinelaw> dpratt71, but i think it has a few problems
13:51:18 <sinelaw> leaks maybe
13:51:33 <sinelaw> that's what i heard - i didn't try it myself
13:52:01 <dpratt71> sinelaw: I was more interested in the concept than the actual implementation anyway
13:52:11 <sinelaw> dpratt71, alternatively try Yampa, it's been used more but seems a little abandoned lately
13:52:23 <sinelaw> dpratt71, ok then Reactive is what you should look at
13:53:14 <dpratt71> sinelaw: ok, thanks
13:53:22 <gwern> :t foldr
13:53:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:53:31 <sinelaw> dpratt71, i just _happen_ to be doing my final project on FRP, so no problem
13:53:40 <gwern> > foldr (<) 0 [1..10]
13:53:41 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
13:53:41 <lambdabot>    arising from the literal `0'...
13:54:11 <Cale> > foldr (+) 0 [1..10]
13:54:12 <lambdabot>   55
13:54:25 <sinelaw> 110/2?
13:54:39 <EvanR-work> 25+30 !
13:54:48 <sinelaw> c_wraith, maybe it's a delayed response
13:54:58 <Cale> 10(10+1)/2
13:55:00 <c_wraith> vindication! :)
13:55:51 <dave_r5> if i have a few monad transformers wrapped around STM, is there a clean way to read/write TVars within my new monad? (i'm a newbie with monad transformers)
13:56:06 <Cale> I'm sure that efficient general FRP is possible, but I'm not sure that it's possible without more language primitives and compiler support.
13:56:09 <EvanR-work> > take 104 (replicate 55 "1+")
13:56:10 <lambdabot>   ["1+","1+","1+","1+","1+","1+","1+","1+","1+","1+","1+","1+","1+","1+","1+"...
13:56:11 <gwern> @hoogle Ordering -> [a] -> Bool
13:56:11 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
13:56:11 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
13:56:11 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
13:56:32 <EvanR-work> > take 104 (cycle "1+")
13:56:33 <lambdabot>   "1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+...
13:56:48 <conal> sinelaw: i read the intro section of your project report.  i like it a lot!
13:57:10 <gwern> oh well. I'll just do 'x == sort x'
13:57:12 <Cale> dave_r5: write lifted versions of the STM functions which work in your new monad.
13:57:18 <sinelaw> conal, thanks! in retrospective there's a lot missing, it's intended for people with no background in FP
13:57:41 <c_wraith> dave_r5: You are probably best off...  doing what cale says.  I'm always slow with the obvious suggestions.
13:58:06 <Cale> dave_r5: and please wrap a newtype around it -- monad transformers get ugly if they're not newtyped so you can't tell there are any
13:58:10 <dave_r5> hah thanks guys. can you give a hint of what the type signature of (for example) the lifted readTVar function would be?
13:58:18 <Cale> :t readTVar
13:58:19 <lambdabot> Not in scope: `readTVar'
13:58:33 <conal> sinelaw: i'm amazed at how well you get right to the heart of things so clearly.  it doesn't at all sound like an undergrad senior thesis.  or even a new phd.
13:58:38 <Cale> Well, it'd be  TVar a -> MyMonad a
13:58:39 <c_wraith> It would be something like Tvar a -> MyMonadStack a
13:58:49 <Cale> Don't write all the transformers in place though!
13:58:51 <c_wraith> And Cale's still faster than me.  drat.
13:58:58 <sinelaw> conal, heh i've had hours of discussions with Peaker here, and he's a deep thinker
13:59:02 <dave_r5> got it. thanks again
13:59:20 <sinelaw> conal, also i have a little more software background than most undergrads, namely 10 years...
13:59:21 <Cale> always always  newtype MyMonad a = MM (FooT (BarT m) a)  or whatever
13:59:46 <Cale> you can use newtype deriving to derive instances for Functor, Monad, and whatever other typeclasses you need
13:59:53 <dave_r5> Cale: i'm ok with that part (i have Real World Haskell on the desk here)
13:59:57 <Cale> okay
14:00:43 <Cale> dave_r5: Implementing the lifted version should typically just be a few applications of lift, and applying the data constructor for your newtype
14:00:45 <vic_> Configuring the editline-0.2.1.0 package failed
14:00:46 <vic_> Damn.
14:01:00 <Cale> vic_: editline sucks anyway
14:01:05 <conal> sinelaw: oh!  well, good job.  and what kind of input on your report would be helpful to you?
14:01:24 <vic_> I know, but make fails with that message. I'm tryin to install Haskell Platform
14:01:37 <vic_> I forgot what package I need here..
14:01:41 <Cale> vic_: Don't compile it yourself, I guess.
14:01:55 <Cale> vic_: Are you on linux?
14:02:01 <dave_r5> Cale: so, i would e.g. lift from STM into ReaderT, then again into WriterT, and maybe again into StateT, then wrap with return?
14:02:02 <vic_> Ubuntu 9.04
14:02:29 <Cale> vic_: Install the generic linux binary GHC (probably 6.10.4 for now) from the GHC website
14:02:39 <Cale> vic_: and then grab cabal install from hackage
14:02:45 <vic_> Hmm, I might have found the solution.
14:02:51 <c_wraith> dave_r5: there'd be no return there.  it'd be just like: myReadTvar = lift . lift . lift . readTVar
14:03:15 <Cale> dave_r5: with MM -- whatever you called the data constructor when you defined the newtype
14:03:16 <vic_> Installing from source is kinda sucky. Reminds me of my Slackware days
14:03:27 <kmc_> vic_, Cale, why not Haskell Platform?
14:03:39 <Cale> kmc_: Because on linux it's more trouble than it's worth.
14:04:04 * vic_ concurs
14:04:16 <sinelaw> conal, officially, unfortunately my mentor is more interested in seeing something 'work'.  But for myself, I'd like to know if I'm missing any big point (esp. concerning denotational design and such) and more importantly, what are the current _problems_ with FRP
14:04:33 <sinelaw> conal, i like to have problems defined precisely
14:04:37 <vic_> Solution here  http://sporkcode.wordpress.com/2009/07/11/installing-the-haskell-platform-in-ubuntu/  I needed libedit-dev
14:04:47 <Cale> vic_: ah, okay
14:04:53 <Cale> I suppose you would
14:05:06 <Cale> It's ridiculous of it to depend on editline.
14:06:00 <c_wraith> Platform doesn't install cleanly on 6.10.4 anyway.  It crashes when you try to install it, because mtl is already installed.
14:06:22 <Cale> editline was the stupid library which GHCi used for a couple versions until it was realised that it was probably worse than nothing and rewritten properly in Haskell :)
14:06:23 <c_wraith> I had to alter the shell script make install calls before it would install
14:06:24 * vic_ cracks his knuckles 
14:06:38 <vic_> Ah, I remember that part.
14:06:43 <vic_> Ugly hack
14:07:13 <Cale> editline has some of the most embarrasingly stupid bugs I've ever seen.
14:07:27 <vic_> "It slightly resembles GNU readline" heh
14:07:31 <Cale> I wouldn't have even released it in its existing condition.
14:08:16 <vic_> * Now do "sudo make install"
14:08:17 <ziman> why did ghc abandon readline in favor of editline?
14:08:24 <vic_> Oh, boy. Here we go...
14:08:25 <Cale> ziman: licensing.
14:08:35 <ziman> ah, i see
14:08:40 <ben0x539> readline was actually working, cannot have that >:I
14:08:43 <Cale> ziman: readline is technically GPL, so using it is not really okay
14:08:56 <vic_> The mtl-1.1.0.2/Setup script does not exist or cannot be run
14:08:58 <Cale> as GHC is not GPLed.
14:08:59 <vic_> Awesome.
14:09:22 <Cale> (it's more sanely BSD licensed)
14:09:46 <ben0x539> Surely the BSD license is GPL-compatible enough :(
14:09:54 <vic_> Haha
14:10:00 <kmc_> Cale, why is Platform more trouble?
14:10:04 <kmc_> i had relatively little trouble
14:10:15 <kmc_> until i did "cabal install cabal-install" and now my cabal-install is fuxored
14:10:16 <c_wraith> in that you can incorporate BSD code into a GPL project, sure.  The other way around is a no-go.
14:10:16 <kmc_> :/
14:10:39 <Cale> ben0x539: Nope, use a GPL licensed library and your program essentially must be GPL.
14:10:41 <vic_> And here is the solution http://trac.haskell.org/haskell-platform/ticket/84
14:10:43 <EvanR-work> c_wraith: yes it is, you can switch your license to gpl ;)
14:10:49 <CalJohn> (the same readline problem happened with clisp, btw)
14:11:13 <Cale> Switching to GPL would be a silly thing to do over readline.
14:11:30 <c_wraith> EvanR-work: without getting either permission or a copyright assignment from every contributer, that's not something that's feasible on a large project.
14:11:36 <Cale> Instead, we now have Haskeline :)
14:11:37 <vic_> Yeah, somebody should work on editline
14:11:39 <ben0x539> Split ghci away from ghc and license only that as gpl? :v
14:11:45 <Cale> pff
14:11:51 <vic_> Too much hasskel for GPL
14:11:59 <vic_> *hassle
14:12:05 <ziman> hasskle :)
14:12:13 <vic_> Haskell GPL Hassle
14:12:16 <Cale> Why, when we can easily reimplement readline in Haskell and BSD license it?
14:12:30 <vic_> Indeed!
14:12:35 <ben0x539> Haskeline was rather shitty with regards to vi mode last I checked
14:12:50 <vic_> Is there a Haskell readline.. ?
14:12:56 <ben0x539> Also it does not support/respect the readline rc file
14:13:02 <Cale> vic_: Haskeline
14:13:07 <vic_> Ah, ok
14:13:20 <c_wraith> somehow, ubuntu's packaging of 6.10.4 breaks haskeline, too
14:13:33 <vic_> The wonders of ubuntu
14:13:59 <Cale> Ubuntu has just gotten worse and worse for the last few releases.
14:14:05 <Cale> Almost since I can remember.
14:14:16 <vic_> Heard 9.10 is kinda buggy
14:14:24 <vic_> But I'm happy with 9.04
14:14:49 <kmc_> Cale, what are your main complaints about Ubuntu?
14:14:54 <kmc_> (may be OT)
14:14:55 <vic_> I'm too lazy to switch to another distro. Like Fedora, OpenSuse or Arch
14:15:06 <Cale> 9.10 broke audio for me in a way which was much more complicated than just uninstalling pulseaudio, since they didn't bother to compile alsa support into the panel applets or volume control.
14:15:11 <Saizan> ben0x539: it has its own .haskeline file though
14:15:26 <ben0x539> That does not really help
14:15:28 <Cale> kmc_: pulseaudio has to be at the very top of the list
14:15:34 <vic_> Ah, the audio problems are meh
14:15:45 <vic_> But the rest just works
14:15:46 <gwern> gosh. criterion is hard to work with
14:15:50 <c_wraith> yeah, pulse audio is awful.  I don't know why ubuntu insists upon it.
14:15:56 <c_wraith> I *still* don't have audio working on this box.
14:16:00 <gwern> apparently it supports functions return IO (), but not [a] o.0
14:16:01 <kmc_> vic_, switching to Debian is a good choice if you like the basic structure of Ubuntu (the package manager, etc.) but you want to install only the packages you want
14:16:15 <gwern> I really hope that's just because criterion 0.2 sucks and that that was fixed later on...
14:16:17 <conal> sinelaw: (was afk.)  got it.  i'm making some notes on my copy of your report and will pass on comments in chunks.
14:16:21 <Saizan> ben0x539: you can add the missing keybindings etc.. but you can also report them to be added by default
14:16:26 <vic_> I like apt
14:16:28 <Cale> The 9.10 upgrade didn't have anything new that was cool in it, and basically just broke a bunch of stuff, requiring me to spend about 2 days recompiling packages by hand and repairing things
14:16:39 <Cale> It also broke Japanese input support for me.
14:16:43 <vic_> But I don't like the old packages that come with Debian
14:16:48 <Cale> (and replaced it with Russian?!0
14:16:58 <ben0x539> Saizan: Keybindings are not really of any use when haskeline cannot keep track which of them to use for which mode
14:17:04 <sinelaw> conal, i really appreciate that, great
14:17:18 <nomeata> I get a "segmentation fault/access violation in generated code" with my code on windows... how would I start debugging that?
14:17:24 <gwern> nor does it have Benchmarkable Bool instance...
14:17:31 <nomeata> The code works fine under wine
14:18:19 <vic_> I wonder how's FreeBSD nowadays
14:18:19 <Cale> So I had to fix that. Also, the basic desktop has no more functionality in 9.10 for me than it did before, but my machine uses consistently much more memory. The version of X it uses has absolutely awful memory leaks in it, it seems.
14:18:29 <vic_> Haven't tried it since 6.2
14:18:48 <dmhouse_> The big win for 9.10 for me would be Firefox 3.5.
14:18:59 <dmhouse_> Shame I don't have the disk space to make the upgrade.
14:19:02 <Cale> dmhouse_: Yeah, but I had that before the upgrade.
14:19:12 <Cale> Just install firefox by hand.
14:19:29 <Cale> It works fine if you just unpack it into a directory somewhere.
14:20:01 <gwern> or download the dpkgs
14:20:04 <Cale> Also, if you do that, it can auto update itself, so it's more useful.
14:20:28 <Cale> Ubuntu purposefully cripples firefox and prevents it from autoupgrading.
14:20:31 <lhoersten> Is it possible to use a type variable and then pattern match on that variable-type argument?
14:20:46 <pozic_> I run ./App +RTS -K1G -hc -xc -L40 -p -RTS , but I only get an empty App.prof file when it fails because of an out of memory error.
14:20:48 <lhoersten> ghc is saying it's a rigid type
14:21:07 <pozic_> Cale: Java also doesn't work in Ubuntu firefox.
14:21:08 <Cale> lhoersten: Uh, if you mean what I think you do, then no.
14:21:22 <Saizan> autoupgrading and package management doesn't mix well i'd guess, however i'd just use a distro that updates packages regularily instead of having each up update itself
14:21:25 <lhoersten> why is that?
14:21:30 <Cale> lhoersten: But I'm not quite sure what you mean.
14:21:34 <dmhouse> pozic_: works fine for me
14:21:42 <Saizan> s/up/program/
14:21:47 <dibblego> "Ubuntu firefox"? Java works fine in firefox
14:21:55 <pozic_> dmhouse: Java applets work fine for you?
14:22:04 <Cale> lhoersten: A type variable is basically a promise not to look inside that value -- the function must be entirely independent of the representation of values of that type.
14:22:23 <pozic_> dmhouse: I have all the defaults and it doesn't, while in Opera it works out of the box.
14:22:26 <lhoersten> Cale: excellent description. that's exactly what I wanted to know
14:22:28 <lhoersten> thanks Cale
14:22:40 <vic_> Yeah, Java works http://gregegan.customer.netspace.net.au/
14:22:43 <Cale> So, for example, if you write  map :: (a -> b) -> [a] -> [b], it's impossible to forget to apply the function to the list
14:22:46 <lhoersten> i suspected that was the case but didn't know how to phrase it to google =)
14:22:57 <Cale> Like...
14:23:00 <Cale> map f [] = []
14:23:05 <Cale> map f (x:xs) = x : map f xs
14:23:10 <Cale> ^^ this is a type error now
14:23:37 <Cale> also, if you were to say, try to do something different if a was Integer, that's not allowed
14:23:54 <dmhouse> pozic_: yeah, it works. No idea whether I've got the default setuo or not. I've been on Ubuntu for about 5 years without reinstallation.
14:24:21 <pozic_> dmhouse: ok, apparently I was wrong. It depends on crappy networking setup.
14:24:43 <pozic_> dmhouse: still odd that Opera didn't have any issues.
14:24:49 <kmc_> lhoersten, however, if your type variable is constrained by a typeclass, you can use the operations in that typeclass
14:24:59 <pozic_> One would expect it not to work in both systems then.
14:25:10 <kmc_> and we do have a typeclass with an operation "give me a runtime representation of the actual type of this value"
14:25:14 <pozic_> On this particular network that particular applet works for me, though.
14:25:15 <kmc_> so various hacks can be had that way
14:25:40 <pozic_> kmc_: Dynamic probably can do that.
14:25:48 <kmc_> if you allow "Typeable" into your constraints, you basically lose all parametricity
14:25:49 <Cale> Yeah, if you want to do generic/polytypic programming, there are a variety of libraries to help with that.
14:26:02 <kmc_> whereas, frex, I think "map" is no less parametric if you constrain a and b to Num
14:26:13 <kmc_> well, hmm, you can use fromIntegral
14:26:26 <kmc_> hmm, yes, you can still do funny stuff
14:26:27 <Cale> kmc_: and you can strangely multiply everything by 7
14:27:01 <pozic_> Does anyone know how to get a guaranteed profile?
14:27:22 <pozic_> Or something which gives profiling information while the program runs?
14:27:45 * hackagebot upload: OSM 0.1 - Parse OpenStreetMap files (TonyMorris)
14:27:55 <Cale> Saizan: Well, I agree to some extent, though I wouldn't mind combining the two when programs do have auto-upgrading.
14:28:23 <Cale> Saizan: If the firefox developers decide that there's a critical update that everyone should have, I'd like to have it as soon as possible.
14:28:42 <Cale> I guess that applies much more to things like my web browser than the average program.
14:29:19 <gwern> 'collecting 100 samples, 1 iterations each, in estimated 5485.920 s' :(
14:29:47 * medfly uses firefox 3.0.11, the most up to date version on the package system for me.
14:30:15 <vic_> * Installation completed successfully. Finally!
14:30:19 <gwern> 90 minutes is a longtime to wait
14:30:19 <vic_> I can has HP
14:30:32 <Saizan> just switch to arch :P
14:30:41 <vic_> Heard good things about Arch
14:30:56 <Saizan> 3.5.6 here
14:31:03 <pozic_> Nobody with an idea of how to get a profile?
14:31:11 <medfly> what's a profile
14:31:21 <kmc_> you've tried the profilers built into ghc?
14:31:25 <pozic_> ./App +RTS -K1G -hc -xc -L40 -p -RTS
14:31:29 <dcoutts> kmc_: you say your "cabal-install is fuxored", any idea why? is there a bug that needs fixing?
14:31:38 <pozic_> foo.prof files are profiles.
14:31:38 * gwern brings it down to 10^6 for an est 364s
14:31:44 <vic_> Saizan: how does an ArchLinux install go? Smooth stuff?
14:31:58 <pozic_> vic_: it was relatively easy a few years ago.
14:32:04 <kmc_> dcoutts, it's a bug i've run into earlier, don't remember how i resolved it then.  :/ i've also seen it mentioned online
14:32:06 <Saizan> vic_: yes, if you follow the guide on the wiki
14:32:06 <pozic_> vic_: I expect it to be trivial today.
14:32:06 <Twey> It's still pretty easy
14:32:13 <vic_> Cool
14:32:16 <Twey> Yeah, just follow the step-by-step
14:32:20 <kmc_> dcoutts, sec, i will find the mention online
14:32:26 <dcoutts> kmc_: ta
14:32:30 <vic_> I'm an ex-Gentoo user, so... I'm used to hard shit
14:32:38 <pozic_> Hard is bad.
14:32:51 <Twey> Hard is good, tedious is bad
14:33:02 <pozic_> Having all the knobs is good.
14:33:10 <vic_> You learn stuff from "hard"
14:33:19 <kmc_> dcoutts, this one: http://www.mail-archive.com/haskell-cafe@haskell.org/msg64031.html
14:33:33 <pozic_> For example that it is hard to profile doesn't buy me anything.
14:33:44 <pozic_> I could modify the program, such that it stops after a minute or so.
14:33:46 <kmc_> dcoutts, every op such as "cabal update" or "cabal install foo" dies with "cabal: ?: openFile: does not exist (No such file or directory)" -- where ? is some random and sometimes nonprintable character
14:33:55 <pozic_> But by doing that hack, have I learned anything? No.
14:33:59 <dcoutts> kmc_: oh that. Gah. We have no idea what causes it. It's not reproducible.
14:34:15 <dcoutts> kmc_: rebuilding cabal-install to debug it makes it disappear
14:34:15 <Saizan> pozic_: what happens if you ^C it?
14:34:24 <vic_> How can I check if I have Parsec or Alex installed?
14:34:28 <kmc_> i have tried removing ~/.cabal and it comes back after an update
14:34:41 <vic_> *from ghci
14:34:44 <pozic_> Saizan: nothing useful.
14:34:48 <kmc_> dcoutts, that's unfortunate :/ anything i can do to help?
14:34:50 <pozic_> Saizan: I already tried that.
14:35:11 <kmc_> dcoutts, thanks for the suggestion to rebuild as debug; i will try that
14:35:14 <Saizan> vic_: :! ghc-pkg list parsec, :! which alex
14:35:15 <pozic_> Saizan: the program terminates correctly probably using the standard ghc handlers.
14:35:44 <dcoutts> kmc_: if you can build your current cabal version from source, see if you can reproduce it. If you can still then we want to add more tracing annotations.
14:36:00 <kmc_> dcoutts, okay.  thanks again
14:36:11 <dcoutts> kmc_: sadly it usually then goes away and we're left with a mystery
14:36:11 <vic_> Saizan: cool, works
14:36:23 <kmc_> it goes away with tracing, even on a non-debug build?
14:36:36 <dcoutts> kmc_: I just mean a normal build
14:36:43 <kmc_> then i would say we should trace it at the system level :)
14:36:53 <kmc_> perhaps gdb or valgrind could be of use?
14:36:56 <dcoutts> kmc_: sure, keep your current copy of the binary
14:37:02 <vic_> This is going to be a long blog post
14:37:11 <kmc_> i imagine valgrind might flip out over various things that ghc produces, though
14:37:12 <dcoutts> kmc_: it's just rather easier if we can get it reproducible from source
14:37:16 <kmc_> yeah
14:37:31 <dcoutts> kmc_: but you're probably right that we have to go beyond that
14:38:03 <dcoutts> kmc_: if you've got the skills to do that, we'd much appreciate it. It's been happening for a while now.
14:38:27 <dcoutts> kmc_: are you on Ubuntu too?
14:38:32 <kmc_> Debian
14:39:22 <kmc_> @tell kmc poke at cabal-install
14:39:23 <lambdabot> Consider it noted.
14:41:06 <pozic_> Do any of the heap profiling tools that were developed during the SoC work?
14:42:56 <Saizan> if you got a mangled .hp you can usually remove the last incomplete section and get hp2ps to understand it
14:44:06 <kmc_> "Valgrind is only useful because C and C++ are such crappy programming languages." -- Julian Seward
14:44:25 <kmc_> author of valgrind and, apparently, contributor to the GHC x86 backend
14:46:14 <pozic_> Saizan: I got hp2ps output, but it was not helpful. Profiles are much more precise.
14:46:41 <Philonous> > (\y -> do { (x:xs) <- return y ; return x} :: Maybe [Int] ) [] -- Twey, do you still need the pattern that maybe matches ?
14:46:42 <lambdabot>   Nothing
14:47:06 <pozic_> Now, I got a profile. I don't like to be lucky to get a profile.
14:47:32 <Twey> Philonous: Oh, but I wanted it for convenience purposes.
14:48:12 <Jackdaw> _
14:48:18 <Twey> A simple ‘tryMatch (x:xs) y id’
14:48:25 <pozic_> It almost seems that the md5 library leaks memory.
14:48:27 <Philonous> Well, it's an ugly hack anyway. I still think we should get rid of fail in Monad
14:48:33 <Twey> Er
14:48:43 <Twey> ‘tryMatch (x:_) id’
14:48:49 <Twey> It's not possible, of course ☺
14:48:55 <Twey> Maybe some TH
14:49:51 <Philonous> @type id
14:49:52 <lambdabot> forall a. a -> a
14:50:01 <Philonous> @type Control.Category.id
14:50:02 <lambdabot> forall (cat :: * -> * -> *) a. (Control.Category.Category cat) => cat a a
14:50:39 <kmc_> yeah, seems like a good simple use of TH
14:51:41 <c_wraith> err.  The template-haskell 2.4.0.0 package appears to be broken.
14:51:57 <c_wraith> And syb-with-class 0.6.1 depends on it.
14:52:13 <Philonous> > (proc () -> do {(x:xs) <- Control.Category.id -< []; returnA -< ()}) ()
14:52:14 <lambdabot>   Pattern syntax in expression context:
14:52:14 <lambdabot>      proc () -> do (x : xs) <- Contro...
14:52:14 <c_wraith> Are those "will work in 6.12" changes?
14:52:16 <Saizan> c_wraith: use 0.6 if you don't have template-haskell 2.4
14:52:31 <Saizan> c_wraith: template-haskell can't be upgraded.
14:52:41 <c_wraith> Saizan: ah, I see.
14:53:14 <c_wraith> Saizan: I just ran into something with a 'syb-with-class >= 0.6" constraint, which blew up as it tried to use the newest version it could find on hackage
14:53:35 <Philonous> Ahh, do I need an "arr (\pattern -> expr) " to get pattern matching in Arrow syntax ?
14:56:42 <Saizan> c_wraith: yeah, the tools don't deal with this in the best way currently
15:01:34 <sm> hey all
15:02:04 * hackagebot upload: ldif 0.0.1 - The LDAP Data Interchange Format (LDIF) parser (RadoslavDorcik)
15:05:20 <sm> I had haskell-platform-2009.2.0.2 installed on mac, then I ran the ghc 6.12.1 installer, and now cabal-install is broken (can't parse ghc-pkg dump output). What's the quickest way to get things working ?
15:06:12 <Saizan> sm: download the cabal-install-0.8 tarball and install it
15:07:14 <sm> Saizan: thanks, where is it ? I'm at http://www.haskell.org/cabal/download.html
15:08:20 <sm> get from darcs I guess
15:08:59 <dcoutts> sm: oh, it's not linked from the cabal homepage yet. It's there and on hackage.
15:09:46 <sm> thanks
15:11:21 <sm> dcoutts: is there something stopping you upgrading the darcs repo ? I'd love to darcs get --lazy
15:11:25 <sm> this is slow
15:11:40 <dcoutts> sm: upgrading the darcs repo?
15:11:54 <dcoutts> sm: there are released versions you can use, you don't need the darcs version.
15:11:55 <sm> yes: Fetching a hashed repository would be faster.  Perhaps you could persuade
15:11:55 <sm> the maintainer to run darcs optimize --upgrade with darcs 2.4.0 or higher?
15:12:01 <sm> ok, where ?
15:12:02 <dcoutts> oh, no
15:12:19 <gwern> suppose I do something like 'if x then "" else ""', will x not be calculated?
15:12:26 <dcoutts> sm: on hackage, and also on the cabal site, though not directly linked.
15:12:45 <dcoutts> sm: I cannot update to darcs 2 format unilaterally
15:13:19 <sm> why not ? when will be a better time ?
15:13:26 <dcoutts> also darcs 2.4 isn't released yet is it?
15:13:34 <merijn> Ok, I can create a type which is a superset of Eq via "class (Eq a) => Mytype a where" is there also a way for me to specify a default implementation of == for Mytype or is that impossible?
15:13:48 <dcoutts> sm: I have to coordinate it with the other people who use the repo, and need to get all outstanding patches reviewed and applied.
15:14:01 <copumpkin> merijn: subset?
15:14:26 <sm> ok. It would be nice to be able to get new versions quickly. You're right that 2.4 isn't released (bad message from darcs) but it should be needed
15:14:30 <sm> thanks!
15:14:34 <copumpkin> merijn: that's impossible
15:14:42 <sm> s/should/shouldn't/
15:14:45 <merijn> copumpkin: I said superset, not subset
15:14:48 <Saizan> merijn: that's a type class btw
15:14:54 <dcoutts> sm: and I guess I'd have to wait 'til I no longer need the stable 0.8.x branch
15:15:06 <merijn> Saizan: Err, right I mean typeclass
15:15:24 <dcoutts> sm: since I'll not be able to merge patches between the head and 0.8 branch, right?
15:15:25 <gwern> oops
15:15:30 <dibblego> merijn, you're not creating a type, but a class of types and the relationship is around the other way (i.e. subset)
15:15:32 <copumpkin> merijn: I guess I was correcting you
15:15:35 <gwern> apparently ghc is smart enough to optimize my if-then :(
15:16:58 <merijn> dibblego: Can you elaborate? I don't really get what you mean.
15:16:59 <Zao> gwern: I'd see that as a good thing.
15:17:07 <Zao> Is the thunk ever evaluated?
15:17:38 <dibblego> merijn, "class (Eq a) => Mytype a where" says that the set of types that are in the class Mytype is a subset of the set of types in Eq
15:17:50 <sm> dcoutts: probably. couldn't you convert all the branches and let the patches be resubmitted
15:18:21 <merijn> dibblego: Ah, yeah. What I meant was the my type class should define a superset of Eq. (i.e. == AND some other functions)
15:18:39 <merijn> It depends whether you mean the superset of functionality or the superset of members
15:18:50 <copumpkin> merijn: oh, a superset of the requirements is a subset of the possible instances :)
15:18:57 <copumpkin> I see what you meant
15:19:30 <gwern> oh, that's just great. apparently there's some caching going on somewhere so everything is finishing too fast!
15:19:52 <Zao> gwern: Unique problem, I'd say.
15:20:01 <Zao> "my code runs too fast"
15:20:11 <gwern> hush you
15:20:28 <gwern> it doesn't run too fast, it's just lazines defeating the 'run function 1000 times to get a decent benchmark'
15:21:02 <Philonous> gwern: IIIRC haskell was leading the shootout for some time exactly because of that.
15:21:08 <gwern> yes, it was
15:21:34 <dcoutts> sm: yes for the outstanding patches but not for the branches as I understand it. You cannot convert branches independently and then merge between them.
15:22:06 <merijn> copumpkin: But is there a way I can specify a default implementation of Eq for Mytype? i.e. there is a reasonable default implementation of == which relies on another function of Mytype so I want that == to be used for instances of Mytype that don't explicitly implement Eq
15:22:45 <copumpkin> not really, but you could do a massive hack
15:23:04 <copumpkin> remove the superclass constraint of Eq on Myclass (I'm going to rename it)
15:23:08 <sm> true. You'd get as many patches as possible into head, convert it, throw away the branches and re-get them from head. But, this will be awkward because darcs convert forgets old tags :/
15:23:20 <copumpkin> and then write an undecidable instance Myclass a => Eq a
15:23:28 <copumpkin> but other than that, no
15:23:36 <merijn> That doesn't sound worth it, it was more of a nice to have bonus in any case.
15:23:55 <sm> so waiting for that to be fixed might be smart
15:23:56 <zygoloid> merijn: sadly no. largely the problem is "what if two people did that?". if Theirtype also implicitly defined (==) somehow and a type were an instance of both, that could lead to inconsistent choices of (==) in different modules
15:24:18 <zygoloid> (re: is there a way i can sepcify a default implementation of Eq)
15:25:36 <merijn> zygoloid: Ah, yeah. I'll just not bother then
15:26:32 <pozic_> gwern: regarding the ""-example. A compiler might decide to do that.
15:26:57 <jfischoff> anyone know how the GHC -> LLVM work is going?
15:28:59 <Twey> 23:20:38 < Philonous> gwern: IIIRC haskell was leading the shootout for some time exactly because of that.
15:29:06 <Twey> Should be a fair win IMO
15:30:05 <Philonous> Twey: I like that. "I can give you the term papers in 10 minutes if you promise not to look at them"
15:30:47 <gwern> hm. looks like a noinline may fix the issue
15:31:19 <merijn> Philonous: I should try that for my next deadline :p
15:32:01 <pozic> I was using 9999% CPU according to top.
15:32:19 <pozic> Too bad I don't actually have a deca-core.
15:36:53 <jfischoff> what's a function like f (a, b) - > (f a, b) ?
15:37:02 <jfischoff> is there a name for that?
15:37:11 <yitz> jfischoff: first
15:37:18 <jfischoff> that's what I thought
15:37:18 <yitz> @type first
15:37:20 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:37:21 <jfischoff> where is
15:37:23 <jfischoff> it
15:37:33 <yitz> @hoogle first
15:37:33 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:37:34 <lambdabot> Data.Monoid newtype First a
15:37:34 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:37:40 <jfischoff> thanks
15:38:35 <kmc_> hmm, i got a copy of "Concurrent Haskell" by Peyton Jones, Gordon, Finne off of CiteSeer... section 4 is missing and replaced with a short note referring to "the full paper"
15:38:42 <kmc_> anyone know if that's available somewhere?
15:40:13 <yitz> kmc_: perhaps here: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
15:40:23 <pozic> When I ask for a profile, I only get a profile of the first 0.4 seconds; the program runs over 50 seconds.
15:40:31 <kmc_> dead link :/
15:40:38 <yitz> darn
15:40:59 <sm> installing HUnit with latest ghc & cabal, I get this iconv link error. I have port installed libiconv. Any ideas ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14870
15:41:03 <kmc_> pozic, how much user CPU (as opposed to real clock time) does it take?
15:41:20 <kmc_> is it perhaps stuck in blocking system calls most of the time?
15:41:20 <dcoutts> sm: yes, the macports iconv is getting in the way
15:41:21 <pozic> kmc_: more than 0.4 seconds.
15:41:29 <sm> aha
15:41:35 <kmc_> you can run with: /usr/bin/time -v ./myprog +RTS -s
15:41:40 <kmc_> that will give you a lot of timing info
15:41:55 <dcoutts> sm: because it's on the linker path first. The base lib is built against the system iconv.
15:43:08 <sm> got to run.. thanks dcoutts
15:43:42 <pozic> kmc_: ah, that does help a bit. It is just that I have no clue why the system uses so much memory.
15:44:16 <pozic> It is trivial to prove that it should use not more than about 8MB of memory.
15:44:37 <kmc_> pozic, then you probably have runaway laziness
15:44:42 <pozic> Except it uses >2.5GB.
15:44:44 <kmc_> is it spending most of its time garbage collecting?
15:45:28 <pozic> kmc_: I didn't run it with -s yet. Doing so now.
15:45:31 <kmc_> pozic, i don't see how it could be trivial to prove *anything* about the space usage of a Haskell program, since every computation may end up at some point as an unevaluated thunk in the heap, and whether or not it actually does depends on compiler optimizations
15:46:01 <pozic> kmc_: I wrote the program; I understand what it should be doing, but maybe I am arrogant.
15:46:02 <kmc_> is 2.5GB the high-water mark or the total amount of allocation?
15:46:37 <kmc_> pozic, maybe you do know; i wasn't sure if your idea of it using only 8 MB was based on a deep analysis of laziness
15:46:37 <pozic> kmc_: well, actually, I set the heap to 3GB, so that is not odd. I will first lower it again, but it crashed at the same point with an out of memory error.
15:47:04 <sjanssen> pozic: is the code reasonable small?  Have you pasted it yet?
15:47:06 <pozic> kmc_: I didn't write a formal model of the Haskell heap and then used a theorem prover to prove it.
15:48:00 <pozic> kmc_: but I did think about what the code should d ;)
15:48:03 <pozic> do*
15:49:24 <jfischoff> lispy: If your still there the newtype for CloseDouble worked, but there were many more classes to write instances for beyond Num
15:49:28 <pozic> GC time is about 50%.
15:49:48 <jfischoff> lispy: let me know if you want the code for any reason
15:49:55 <pozic> sjanssen: I can post the code, but without data, you won't see bad behaviour.
15:50:14 <ivanm> preflex: seen sinelaw
15:50:14 <preflex>  sinelaw was last seen on #haskell 1 hour, 33 minutes and 10 seconds ago, saying: conal, i really appreciate that, great
15:50:25 <lispy> jfischoff: For the instances other than Num, were you able to use the generalized newtype deriving?
15:50:33 <jfischoff> ?
15:50:37 <sjanssen> pozic: it might be a good idea to post it, let people look for any obvious pitfalls
15:50:42 <jfischoff> is that an extenstion?
15:50:48 <ivanm> @tell sinelaw yeah, I know; but I can't help it if they don't have it.  I should probably make a better error message though
15:50:48 <lambdabot> Consider it noted.
15:50:50 <lispy> jfischoff: Oh, I guess you missed us suggesting that :)
15:50:57 <lispy> jfischoff: yes it is
15:51:00 <jfischoff> haha maybe i missed it
15:51:16 <jfischoff> I ended up righting some ruby code to generate the unboxing for me
15:51:25 <jfischoff> wasn't that bad
15:51:39 <jfischoff> thanks for the tip though :)
15:51:39 <ivanm> that sounds like a match made in hell...
15:51:40 <lispy> (2009-12-23 13:44:14) lispy: {# LANGUAGE GeneralizedNewtypeDeriving #-} newtype MyFloat = MF Float deriving (Enum, Eq, Floaating, Fractional, Ord, Read, Real, RealFloat, RealFrac, Show)  <-- that's a start, then add your own instance for Num
15:51:52 <jfischoff> ah
15:51:55 <jfischoff> cool
15:51:59 <pozic> sjanssen: http://paste.debian.net/hidden/1f297d27/
15:52:08 <jfischoff> I'll try that real quick
15:52:38 <pozic> You need a bunch of libraries and you need to define two variables that should point at two directories.
15:53:39 <sjanssen> pozic: is files_that_might_be_removed very long?
15:53:44 <jfischoff> lispy: dope
15:53:59 <pozic> sjanssen: <2000
15:54:45 <pozic> sjanssen: it could use some better data structures, but IO time was dominating anyway.
15:55:09 <lispy> jfischoff: Cool.  Sorry I didn't bonk you on the head with that earlier!
15:55:39 <pozic> sjanssen: I have the impression that computing the md5sum does not run in constant space.
15:56:03 <pozic> sjanssen: that is, I expect that it takes about 7million times some constant + some small constant.
15:56:29 <sjanssen> pozic: I think you're not actually evaluating the md5 sums
15:56:50 <pozic> sjanssen: right, so the library already allocates stuff.
15:57:14 <pozic> sjanssen: because 2000 times 100 bytes for md5state is still nothing.
15:57:36 <sjanssen> pozic: remember that it also has to keep the file in memory
15:57:39 <pozic> sjanssen: 2000 times 7MB however, is a big number.
15:58:22 <medfly> it's funny you're discussing this so much. I have this guess that if you just went for the inefficient way straight away, instead of having this conversation, you'd be done sooner
15:58:30 <medfly> :)
15:58:37 * medfly hasn't read the entire conversation
15:58:56 <sjanssen> pozic: on line 26, change "return (md5sum bs)" to "return $! md5sum bs"
16:00:23 <jfischoff> lispy: no worries, you probably mentioned it and I didn't understand :)
16:00:25 <pozic> sjanssen: I think that solved it.
16:00:27 <sjanssen> pozic: I don't know if you're interested in general style critique, but really_long_identifiers_with_underscores isn't typical Haskell style.  Makes things a bit difficult to read, IMO
16:00:43 <pozic> sjanssen: veryLongIdentifiers is.
16:01:18 <pozic> sjanssen: thereAreBigDiscussions between_various_people about-this-and-whether-or-not-we-should-also-allow-this?
16:01:36 <sjanssen> pozic: top level identifiers are sometimes several words long, but arguments and local variables are very rarely this long
16:01:41 <sjanssen> usually they're not even words
16:01:41 <pozic> Some people also advocate hello'world.
16:02:19 <pozic> For some purposes xs is nice. I like it to encode invariants in them.
16:02:36 <pozic> How do you keep track of complex invariants?
16:02:37 <sjanssen> pozic: the underscores aren't a big deal, but things like "list_of_candidates_with_md5sums" are not typical
16:02:46 <sjanssen> pozic: make the type system do it?
16:02:53 <jfischoff> Hey is there a haskell equavilent of the 'if __FILE__ == $0 ' ruby idiom?
16:03:05 <pozic> sjanssen: yes, but sometimes it is nice to be able to see it by the name too.
16:03:06 <sjanssen> for example, "list" and "with_md5sums" in that example would both be covered by types
16:03:24 <pozic> sjanssen: md5sums could cover it sure.
16:03:33 <sjanssen> jfischoff: what does that do?
16:04:07 <pozic> sjanssen: it was also a work in progress, but tagging stuff as candidates is useful, imho.
16:04:14 <medfly> I think it compares if $0 is what is in __FILE__.
16:04:17 <jfischoff> sjanssen: its a way to include a main function in every module, but it is only executed if the current file is the main file
16:04:22 <medfly> to what
16:04:33 <pozic> sjanssen: I have the impression that you can understand what I wrote easily, no?
16:04:50 <jfischoff> I want to be able have a main function in every file for quick and dirty testing
16:05:07 <jfischoff> but have other files ignore those main files
16:05:15 <lispy> jfischoff: you'd use CPP
16:05:16 <jfischoff> main functions I mean
16:05:24 <sjanssen> pozic: I hadn't really tried.  Some parts seem like walls of text
16:05:31 <lispy> jfischoff: I've seen HUnit examples that do this
16:05:34 <sjanssen> jfischoff: I think the closest equivalent is GHC's main-is
16:05:55 <Saizan> jfischoff: have a main function, and then use ghc -main-is TheModule.main TheModule.hs
16:06:02 <zygoloid> jfischoff: just include a main function in every moddule? ;-)
16:06:33 <sjanssen> pozic: anyway, does that little bit of strictness I suggested magically fix things?
16:06:33 <zygoloid> (plus -main-is)
16:07:06 <jfischoff> Saizan: does that work with runhaskell too?
16:07:17 <lispy> jfischoff: really, I'm more likely to use quick check and write properties that can be built together or just load the module in ghci and test something
16:07:23 <pozic> sjanssen: yes
16:07:40 <sjanssen> excellent
16:07:42 <jfischoff> lispy: I like both
16:08:31 <pozic> sjanssen: since I don't use my utility library, the code could be a lot shorter. I think really short variable names, e.g. without candidates in them, obfuscate what the intention of the code is.
16:08:51 <lispy> jfischoff: I think to really do this well, you probably need a new feature in cabal
16:09:04 <jfischoff> huh
16:09:18 <CESSQUIPEDALIAN> kmc: he left you're a hero
16:09:27 <lispy> cabal load Foo.hs -- it figures out which other modules to loads and then looks for "cabalMain" or something to execute
16:09:54 <jfischoff> lispy: Too much work
16:09:56 <kmc_> were you already trying to get rid of him
16:10:01 <pozic> sjanssen: e.g. the liftIO stuff is also a hack.
16:10:08 <jfischoff> lispy: I'll stick with quickcheck :)
16:10:16 <CESSQUIPEDALIAN> kmc: nobody cried when he left
16:10:24 <kmc_> okay
16:10:29 <kmc_> i mean i feel sort of like a jerk now
16:10:31 <sjanssen> pozic: yeah, liftIO is annoying.  The first thing I do in my applications is "io = liftIO"
16:10:49 <dcoutts> or just avoid liftIO in the first place
16:11:17 <sjanssen> dcoutts: use a library of functions already liftIO'd?
16:11:21 <dcoutts> ie don't use layered monads in an open way
16:11:31 <ivanm> I don't know if you guys have come across this, but it's an interesting article on someone "proving" a bug was fixed: http://thedailywtf.com/Articles/The-Proven-Fix.aspx
16:11:34 <tensorpudding> on the one hand, you were a jerk, but you didn't lie either
16:11:36 <tensorpudding> and he knows that
16:11:45 <lispy> jfischoff: well, a way to load specific modules in ghci and have all their deps automatically be loaded is a cabal feature I still want for other reasons
16:11:55 <dcoutts> lispy: aye
16:12:00 <tensorpudding> ^ to kmc_
16:12:01 <gwern> on an ascending list, the yhc sort certainly is faster. ghc is 3.255010s mean, 283.2719ms stdev, while yhc is 1.819930s mean, and 6.026500ms stddev
16:12:03 <jfischoff> ah
16:12:13 <sjanssen> dcoutts: this can get pretty ridiculous though, eg. in xmonad where we call X11 functions left and right
16:12:29 <jfischoff> lispy: yeah that would be convinent
16:13:06 <jfischoff> lispy: seems like the heavy lifting is already there for the installs to work?
16:13:06 <dcoutts> sjanssen: I'm just generally sceptical of the "make a state monad over IO" approach
16:13:25 <lispy> and, your question made me realize that maybe when we get that feature cabal should #define a CPP symbol so code can know it's loaded that way
16:13:41 <dcoutts> lispy: I'm dubious
16:13:52 <dcoutts> lispy: if you've loaded it, you can just call the function!
16:13:59 <dcoutts> if you call that main, that's ok
16:14:10 <dcoutts> you can have a main in each module
16:14:20 <dcoutts> the only requirement is that there be a main in Main
16:14:56 <lispy> dcoutts: but, you probably only want that main to be defined when you're loading this special way.  Like in the ruby/python trick
16:15:12 <lispy> Think about modules that don't explicitly export
16:15:26 <lispy> And then multiple mains getting imported
16:15:42 <dcoutts> lispy: ghci gives you the context inside a module, so you can see main even if it's not exported
16:16:35 <lispy> Imagine you have Foo and Bar in your project and each defines main.  Then Baz imports both and tries to define main.  Now you've imported Foo.main, Bar.main, and tried to define main.
16:16:57 <Twey> 00:12:43 < dcoutts> sjanssen: I'm just generally sceptical of the "make a state monad over IO" approach
16:16:58 <dcoutts> then don't export them
16:16:59 <lispy> dcoutts: with the ruby/python trick, only Baz has a definition of 'main' when you load Baz this way
16:17:07 <Twey> Oh, someone else?
16:17:15 <Twey> It always seemed horrible to me
16:17:25 <pozic> sjanssen: that's also what I have. Unfortunately, the overhead of pointing at the Util module I have in some other dir is too large. Maybe I should turn it into a package some day.
16:17:32 <dcoutts> lispy: a code fragment that does something different in different module contexts is somewhat antithetical to the pure approach
16:18:35 <dcoutts> Twey: right, imho, monad transformers are to make it easier to make your own monad, not as a programming style.
16:18:45 <nomeata> @tell dons: FYI: The pcre-light package works under windows if you remove the "-viaC" option from the cabal file.
16:18:46 <lambdabot> Consider it noted.
16:19:10 <nomeata> arbtt now works on windows as well... and I could develop it without touching windows (thx to wine and the nicely packaged platform)
16:19:47 <dcoutts> @tell dons oh and pcre-light does not need a ./configure script either
16:19:47 <lambdabot> Consider it noted.
16:20:33 <necroforest> If i have a typeclass T, can I write a function that takes a list of types that instance T but are different types?
16:20:55 <necroforest> i.e, A and B are subclasses of T, and a is A and b is B, can i make a list [a, b] ?
16:21:00 <dcoutts> lispy: it seems like a perfectly reasonable trick, to define a main in various modules but not export it. Doesn't that do basically the same as the ruby trick?
16:21:13 <simplicio> A and B are instances, not subclasses
16:21:20 <necroforest> err, yeah
16:21:23 <simplicio> and no, you can't (directly)
16:21:26 <necroforest> hmm
16:21:36 <simplicio> there's a trick involving existential types
16:21:51 <dcoutts> necroforest: you can make a wrapper that can hold anything that's an instance of T
16:21:55 <lispy> dcoutts: Can I write:  module Foo( ... hiding (bar, baz) ) where ... ?
16:22:03 <increpare> you could make a list [Either A B], but that maybe wouldn't be satisfactory?
16:22:05 <necroforest> dcoutts: ok
16:22:18 <necroforest> increpare: no it wouldn't
16:22:28 <dcoutts> necroforest: however that's only any good if you do not need to get them out again. You cannot downcast.
16:22:46 <increpare> necroforest: why not?
16:22:49 <Twey> Heh, http://thedailywtf.com/Articles/The-Do-Not-Click-Button.aspx reminds me of the time in primary school I labelled a shortcut to DOS mode ‘do not click’ and left it on the desktop… it lasted about five minutes before someone started yelling that the computer was broken…
16:23:01 <Twey> Humans are truly strange creatures
16:23:27 <dcoutts> lispy: I'm not sure if there's a way to say "export everything except blah", I expect not.
16:23:37 <dcoutts> lispy: time to add an export list
16:23:52 <necroforest> well, say i have a class Shape with function 'draw', and a bunch of instances Circle, Square, etc, and I want to write a function that takes a list of arbitrary shapes and draws them (but doesn't do anything besides calling the Shape functions)
16:24:11 <dcoutts> necroforest: ok then the wrapper approach works
16:24:34 <dcoutts> necroforest: the wrapper approach is essentially OO encoded in a FP system
16:24:39 <necroforest> dcoutts: so i'd have to create a type like data MyShape = Circle Circle | Square Square ?
16:25:00 <pozic> necroforest: the only thing you have to decide is whether or not you want people that don't have access to your source code to be able to create Shapes.
16:25:11 <dcoutts> no, data SomeShape where SomeShape :: Shape s -> SomeShape
16:25:19 <dcoutts> oops
16:25:24 <dcoutts> data SomeShape where SomeShape :: Shape s => s -> SomeShape
16:26:03 <dcoutts> necroforest: alternatively you make a data type that's a record of methods, and provide functions to convert from your Shape instances to that.
16:26:15 <dcoutts> that's another mostly-equivalent OO encoding
16:26:16 <pozic> necroforest: if you want them to be able to create their own shapes, you need some kind of encoding of objects for that. There are several.
16:26:44 <lispy> ?hoogle forever
16:26:47 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
16:27:51 <necroforest> dcoutts: right now i have something like class Shape and data Cirlce = {..}, data Square = {..}, etc... would it make more sense to jsut ahve  'data Shape = Circle {..} | Square {..}' ?
16:28:08 <necroforest> dcoutts: I don't need to worry about external code extending this
16:28:55 <dcoutts> necroforest: ok then yes, the simpler method in that case is a single data Shape = ... | ... | ...
16:29:30 <Philonous> That gets you pattern matches all over the place where you really want closures
16:29:49 <dcoutts> the OO style is needed when it's important to be able to extend the number of alternatives (while keeping the number of methods fixed)
16:30:15 <dcoutts> the data alternative style is good when the number of alternatives is fixed and adding more methods is important
16:30:48 <dcoutts> which to pick depends on the task at hand
16:30:49 <increpare> dcoutts: or when you are indifferent
16:31:16 <dcoutts> increpare: yes, the data alternative style is easier in most FP languages.
16:31:43 <increpare> dcoutts: right - i certainly wouldn't recommend it as a default in c
16:32:01 <necroforest> hmm
16:32:42 <increpare> I remember the last time I had to do a shape-style library: I ended up having a data structure that stored basic shape info (position/orientation/scale), and each 'shape' was a function type Shape = ShapeInfo -> DisplayData
16:33:11 <increpare> that allowed me to put them all in a list together, but can have some odd inflexibilities...
16:33:26 <necroforest> 'data SomeShape where SomeShape :: Shape s -> SomeShape' - how does this actually work? I've never seen that notation; just data X = A { } | B { }
16:34:19 <Botje> necroforest: that's a GADT
16:34:28 <Philonous> necroforest: That is GADT syntax. There you can give explicit types annotations to the constructors
16:34:30 <pozic> Are GADTs even in H2010?
16:35:27 <kmc_> nope
16:35:30 <kmc_> nothing that fancy is :/
16:35:45 <Philonous> necroforest: And btw. that doesn't work.. What you want is the second one dcoutts gave you: "data SomeShape where SomeShape :: Shape s => s -> SomeShape"
16:35:47 <kmc_> i prefer the GADT syntax for non-GADT types (that one isn't)
16:36:03 <pozic> Explicit kinds...
16:36:15 <pozic> MPTCs...
16:36:17 <kmc_> hmm but it's existential
16:36:22 <pozic> And the list continues.
16:36:33 <kmc_> list of what?
16:36:53 <pozic> kmc_: of stuff that everyone is already using, but is not in H2010.
16:37:01 <Philonous> necroforest: What it says is basically "The SomeShape constructor takes any s as a parameter and forgets what types it whas, but it makes sure it implements the Shape class, so you still have access to the class functions"
16:37:11 <increpare> kinds aren't in properly yet, are they? (only * and *->* last time I checked)
16:37:14 <gwern> oh wow. the descending-ints case is really terrible for ghc
16:37:16 <kmc_> pozic, sure, but a lot of things in that category are still relatively controversial
16:37:22 <kmc_> for example fundeps
16:37:36 <increpare> gwern: descending-ints?
16:37:39 <gwern> runtime goes from 3 to 4 seconds, but for yhc, runtime - which was better than ghc for ascending ints - goes *down*
16:37:46 <kmc_> it's not clear that fundeps and asstypes should both be supported
16:37:55 <gwern> increpare: I'm using criterion to benchmark yhc and ghc's sorts
16:38:10 <increpare> gwern: ah right.  interesting results?
16:38:10 <gwern> kmc_: I agree, ass is often not as fun as the alternative
16:38:11 <dcoutts> Philonous: and then you need to make SomeShape and instance of Shape
16:38:27 <gwern> increpare: well, that *is* a interesting result
16:38:45 <Philonous> dcoutts Well, you could just pattern match on it
16:38:56 <gwern> yhc is kicking ghc's arse on sorted lists (ascending and descending); it's just now starting the random runs
16:39:00 <increpare> gwern: yes.  you going to forage + figure out why?
16:39:04 <gwern> if yhc is on par or better than ghc...
16:39:06 <Philonous> dcoutts But throwing in a generalized newtype deriving surely makes things easier
16:39:31 <gwern> then the discussion is, shall we say, over
16:39:47 <lispy> is there a way to build only one executable that is listed in the cabal file?
16:39:52 <gwern> (and I will have gotten rid of one of ndm's old identified inefficiencies in the base libs)
16:40:03 <gwern> lispy: set all the others to buildable: false?
16:40:16 <lispy> gwern: on the commandline?
16:40:39 <gwern> lispy: edit it to use flags, then
16:40:52 <lispy> oh okay, bummer!
16:40:55 <lispy> thanks though
16:41:09 <gwern> add flags setting buildable false or true, and then you can do it from the cli]
16:41:17 <lispy> What is a minimal curl example....
16:41:31 <gwern> 'estimated 1138.413 s' arggh, so long to wait to know
16:41:46 <lispy> gwern: Yes, I understood that, I just was hoping I wouldn't have to add a new flag :)
16:41:57 <gwern> no one is ever satisfied
16:42:01 <dcoutts> Philonous: I'm not sure you can derive it, it's not a newtype.
16:42:27 <dcoutts> lispy: sadly no, that's another feature request.
16:42:49 <noblethrasher> Hello.
16:42:52 <zygoloid> dcoutts: sounds like we need a -XGeneralizedExistentialDeriving? ;-)
16:43:04 <dcoutts> lispy: in principle it's not that hard a change, it's something I'd like to see done, matter of hacking time.
16:43:07 <gwern> dcoutts: seems like an excessive feature
16:43:27 <gwern> are we going to add a feature where you can set per executable ghc-options from the cli?
16:43:31 <dcoutts> gwern: really? it's rather useful for developers
16:43:49 <dcoutts> gwern: like targets in a makefile
16:43:59 <gwern> if not, why favor the buildable: field?
16:44:02 <dcoutts> zygoloid: or just allow existentials in newtypes.
16:44:18 <dcoutts> gwern: I don't favour the buildable field, it's a pita.
16:44:35 <dcoutts> it's not clear what it means in the presence of conditionals
16:44:42 * hackagebot upload: convertible-text 0.2.0.2 - Typeclasses and instances for converting between types (MichaelSnoyman)
16:44:45 <gwern> dcoutts: isn't that feature request tantamount to singling out one single possible option for an Executable section?
16:45:00 <dcoutts> gwern: I don't follow
16:45:02 <zygoloid> dcoutts: if the existential is constrained with a typeclass, can you still use the same representation as the wrapped type? i would think not :(
16:45:33 <gwern> dcoutts: specifying a executable to build, on the cli, is overriding one particular field in that Executable section
16:45:38 <dcoutts> zygoloid: indeed not, but newtype is about semantics too. The fact that the optimisation is not available is not really a problem.
16:45:50 <gwern> namely, 'buildable'
16:45:53 <dcoutts> gwern: oh I don't see it that way
16:46:09 <gwern> what other way is there to see it?
16:46:29 <noblethrasher> I recently read an article (http://blog.lab49.com/archives/3011) on discussing the relationship between ADTs, differential calculus and one-hole contexts and I'm hoping to get some clarification...
16:46:29 <dcoutts> gwern: imagine if we allow several .cabal packages in a single directory. It's useful then to say "build them all!", "build that one" etc by naming them
16:46:31 <zygoloid> fair point. but i thought GHC internally did generalized newtype deriving by reusing the dictionary, so you'd need to reimplement it anyway?
16:46:53 <gwern> (ooh, ghc's performance on random lists is 8.500204. ouch.)
16:47:20 <dcoutts> zygoloid: sure, but I don't mind so much what the compiler is doing. It's the syntax and semantics that's really relevant.
16:47:45 <gwern> dcoutts: and how would these hypotheical .cabals building different sets of Executables exist in actuality? as the same .cabal, with differing buildable fields
16:47:48 <dcoutts> zygoloid: the meaning of deriving is fairly clear for newtypes, and conceptually this case is a newtype.
16:48:49 <dcoutts> gwern: I'd like to allow multiple .cabal files in the same dir, allow the dev to specify build targets including: packages, libs, exes (other equivalent future components like tests) and even modules.
16:48:54 <dcoutts> gwern: like make blah
16:49:47 <gwern> but what does that have to do with being able to say something like 'cabal install -don't-build=package-tester'?
16:50:03 <dcoutts> gwern: very little
16:50:43 <zygoloid> dcoutts: i think i see it somewhat the opposite way -- that newtype only exists to allow control over operational semantics (who really cares about the top-level _|_?), and that generalized newtype deriving is likewise about reusing the operational (and not just denotational) semantics of the underlying type
16:50:52 <dcoutts> gwern: lispy wasn't asking for that, he wanted to build just one of the components while he's hacking on it
16:51:30 <dcoutts> zygoloid: newtype has different denotational semantics too of course
16:51:44 <zygoloid> dcoutts: right. but who really cares about the top-level _|_?
16:52:04 <dcoutts> it's not frequently important, that is true
16:52:08 <lispy> What was that trick for waiting on an mvar ?
16:52:18 <dcoutts> lispy: take
16:52:21 <lispy> m <- newMVar undefined; m' <- takeMVar m
16:52:22 <lispy> ?
16:52:37 <dcoutts> lispy: newEmptyMVar
16:52:38 <lispy> Then I should expect the takeMVar to block?
16:52:39 <lispy> ah
16:52:40 <zygoloid> i'll admit there may be some cases where that's important. but most times, people change 'data' to 'newtype' because 1) they can and 2) it (probably) generates better code
16:52:53 <dcoutts> lispy: it only blocks if it's empty
16:53:01 <zygoloid> [and 3) they want generalized newtype deriving ;-)]
16:53:13 <dcoutts> zygoloid: or because it expresses an intention
16:53:21 <dcoutts> zygoloid: where they could have used data
16:53:27 <lispy> dcoutts: wow, the RTS detected that it would block indefinitely and aborted it!
16:53:46 <dcoutts> @arr!
16:53:46 <lambdabot> Arrr!
16:55:32 <zygoloid> dcoutts: i think i'm missing some subtext when reading (and writing) newtype versus data then ;-) what should i be 'reading between the lines' when i see newtype or data?
16:55:52 <increpare> @arrr!
16:55:53 <lambdabot> I want me grog!
16:56:13 <zygoloid> @yarrp
16:56:13 <lambdabot> Where d' all t' pirates come from?
16:56:13 <lambdabot> Great Yarrmouth!
16:56:19 <lispy> dcoutts: I don't know if I told you, but I'm still dealing with Solaris 8 segfaults.  Right now I'm trying to determine if it's curl that is the evil segfaulter
16:56:39 <lispy> dcoutts: I did discover that tab completion in ghci-6.8.3 is an instant segfault everytime!
16:56:50 <gwern> random ints: ghc 8.500204s; yhc 6.185154s
16:56:52 <gwern> woot!
16:57:39 <gwern> one last set of tests, the shakespeare corpus, but I can guess yhc will win there too
16:57:40 <syntaxglitch> I actually managed to get some sort of "GHC has crapped itself, this is a bug, please report it" error the other day
16:57:43 <lispy> dcoutts: but I doubt that's a bug report you'd guys would be interested in having
16:57:48 <gwern> syntaxglitch: oh that's easy
16:57:53 <gwern> just use the ghc api
16:58:23 <syntaxglitch> Happened while trying to load a file with ":l Foo.hs" in ghci I think
16:58:28 <Philonous> zygoloid: I think say "newtype" instead of data is a great way of expressing that you didn't actually want a new data type, but just wanted to go seomwhere else instannce vise. For example Monoid Instances for Int with (+) or (*) as mappend
16:58:39 <dcoutts> lispy: yes I got the same with 6.8
16:59:04 <dcoutts> lispy: it's not something that will be fixed, unless it's still happening in 6.12
16:59:30 <lispy> dcoutts: do you know of any issues with ghc-6.8.3 on solaris 8/sparc related to threaded vs. non-threaded rts and random crashes?
16:59:34 <dcoutts> which it probably isn't, since we switched from readline to a pure Haskell line editing solution
16:59:50 <lispy> dcoutts: 6.12 can't be compiled on solaris 8 :( due to a lack of thread local storage
17:00:19 <dcoutts> lispy: I'm not aware of anything. I got 6.8.3 using -threaded working on Solaris 10
17:00:42 <gwern> dcoutts: email on -cafe asking why MIT isn't a valid license:
17:00:46 <dcoutts> lispy: you could just not use -threaded.
17:00:50 <gwern> dcoutts: we junked it because it's ambiguous, right?
17:00:59 <lispy> okay.  It's probably a library I'm using, but the crashes stop when I disable the threaded RTS
17:01:10 <dcoutts> gwern: no, it's supported in 1.8, and you can use it from 1.6 onwards.
17:01:59 <dcoutts> gwern: as in, you'll get a warning with 1.6 but it'll work ok and it's ok to upload to hackage
17:02:00 <gwern> http://hackage.haskell.org/packages/archive/Cabal/latest/doc/html/src/Distribution-License.html#License seems to disagree
17:02:05 <gwern> --    -- | The MIT license, similar to the BSD3. Very free license.
17:02:05 <gwern> --  | MIT
17:02:15 <zygoloid> Philonous: thanks, that's an interesting perspective. perhaps i can spin that around and say: it's a newtype if the type's invariants are the same, and it's a data if they might be stricter?
17:02:17 <gwern> TODO '--      * add MIT license'
17:02:44 <dcoutts> gwern: no, that doesn't disagree. As I said, with 1.6 you'll get a warning that it's not a known license. But that's ok.
17:02:56 <dcoutts> and you can upload it to hackage
17:03:03 <dcoutts> and as of 1.8 there's no warning for it
17:03:16 <zygoloid> that is, you'd write 'data IntBetween0And100 = C Int' not 'newtype IntBetween0And100 = C Int'
17:03:30 <lispy> dcoutts: AFAICT, it's hard to say with certainty that a program developed and testing with -threaded will still behave correctly if you remove -threaded
17:03:51 <dcoutts> lispy: right, you'd have to audit your FFI calls
17:03:53 <lispy> dcoutts: so I'm not just changing it without needing to get up to speed on the code base and test it adequately
17:04:05 <dcoutts> lispy: see if there are any that must be run concurrently
17:05:07 <dcoutts> lispy: depends how much work you're prepared to put in, I think 6.12 does work on other platforms without thread local storage, it's just slower.
17:05:59 <Philonous> zygoloid: Yes. Except you probably would still use newtype because of less overhead and deriving. But in principle that's what I'd read in that.
17:06:02 <dcoutts> lispy: so you might need to implement the non-TLS support in ghc for that platform.
17:06:09 <ivanm> anyone know of a way I can apply a unique ID to all edges in an FGL graph? AFAICT, my best bet is to rip it all apart, use zipWith on the list of edges and then re-construct the graph
17:06:55 <dcoutts> zygoloid: I disagree, I'd definately use "newtype IntBetween0And100 = C Int" for semantic and clarity reasons (not just operational reasons)
17:08:25 <zygoloid> dcoutts, Philonous: i'm confused, i think. if we (as is my experience) just use newtype wherever it's legal, and don't usually deliberately exploit the lack of a top-level _|_, isn't it just an optimization?
17:09:04 <lispy> dcoutts: Hehe, as cool as that would be, I seriously doubt I have the budget :)
17:10:10 <zygoloid> and if not, what is it that i should be thinking when i see 'newtype' (or when i see 'data' in a place where 'newtype' could have been used)?
17:10:11 <dcoutts> zygoloid: that's missing the point about code as human communication, as communicating intention.
17:10:44 <Philonous> dcoutts where would you use a data declaration instead of a newtype?
17:11:20 <zygoloid> dcoutts: what intention is it communicating? as far as i can tell all it /reliably/ means is 'newtype was legal here'
17:11:45 <dcoutts> Philonous: if it were a type that I might expect to be extended with more fields, where I think of it as being a single-place record.
17:12:59 <c_wraith> zygoloid: it means "this is different from other places I want something with the same hardware representation.  Don't mix them up"
17:13:12 <zygoloid> c_wraith: not type versus newtype, data versus newtype
17:13:21 <dcoutts> zygoloid: that this named type is distinct from the underlying type, with some different or restricted semantic view, rather than an open type alias.
17:14:14 <c_wraith> Oh, vs data?  It's mostly about efficiency.  The lack of the extra bottom means the whole wrapper is optimized out at compile time.
17:14:53 <dcoutts> zygoloid: ok so clearly half of us think of it purely operationally :-)
17:14:57 <zygoloid> hehe :)
17:15:40 <zygoloid> dcoutts: i think your 'it's a single-place record' explanation is quite helpful. but i think record notation communicates that. perhaps 'it might have other constructors later'?
17:16:17 <c_wraith> dcoutts: But " named type is distinct from the underlying type, with some different or restricted semantic view, rather than an open type alias" is equally true of a data declaration with a single constructor that takes one argument.
17:17:09 <EvilTerran> zygoloid, note that, given "newtype Foo <args> = Foo <type>", you then have a one-to-one correspondence between values of type <type> and values of type Foo <args>
17:17:38 <EvilTerran> that comes in handy when you need multiple instances of the same class that would otherwise overlap
17:18:41 <zygoloid> EvilTerran: sure. and if newtypes were only used in that case i would not be confused :)
17:19:04 <EvilTerran> i think of "newtype" as self-documenting my code to mean "i'm giving an existing type a new name (that the typechecker can see), not really making a novel type"
17:19:28 <zygoloid> EvilTerran: so you're in the 'IntBetween0And100 is data not newtype' camp?
17:20:01 <EvilTerran> hm... i haven't really thought about it. i'd probably make that a strict data and let the optimiser deal with it
17:20:37 <pastah_rhymez> is HaskellLove still annoying or can i come back as a regular here
17:20:37 <zygoloid> i think i'm forced to conclude that 'newtype' communicates nothing, in general, because different people intend for it to communicate different things :(
17:20:48 <pastah_rhymez> oh snap...
17:20:48 <zygoloid> summoned?
17:21:38 <EvilTerran> zygoloid, yeah, true. i guess, if you want to imply something by your use of newtype, you should make a note of what you mean by it in your docs somewhere
17:21:41 <merehap> wow, the power of foresight is strong in this one
17:21:49 <pastah_rhymez> merehap: indeed
17:21:50 <c_wraith> zygoloid: there are cases where newtype has unambiguous meaning...  Particularly when GeneralizedNewtypeDeriving is enabled.
17:22:17 <zygoloid> EvilTerran: on the other hand it means that if i pick a convention i can make my own code communicate -to me- better, and that's something :)
17:22:26 <jfischoff> Started a google project for creating haskell data types and xml serialization from XSD http://code.google.com/p/xsdtohaskell/
17:23:29 <EvilTerran> zygoloid, sure - and I find writing that convention down helps me formalise it and make sure i understand it fully myself, as well as helping other people (who RTFM) follow my code
17:24:01 <EvilTerran> (not that i've put that much code in places others are likely to read it - well, hpaste aside :P)
17:24:22 <merehap> pastah_rhymez : coast is clear, though I'm hoping that account isn't just a practical joke you've been playing on us...
17:24:55 <lispy> EvilTerran: I thought glguy did hpaste?
17:25:34 <zygoloid> EvilTerran: that sounds like an excellent idea (and not just in haskell). kind of a coding standard on steroids :)
17:25:38 <pastah_rhymez> merehap: me? wut?
17:25:50 <merijn> I'm reading Real World Haskell and a detail it skims over in the I/O chapter is safety of hGetContents. Am I right in assuming that this may return garbage if I don't have exclusive access to the file? And someone modifies it during processing of the data it returns?
17:25:52 <pastah_rhymez> dude, he's been PMing me
17:26:17 <merehap> Haskell love letters, I take it?
17:26:21 <dons> merijn: if someone else on the system modifies the file
17:26:22 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:26:29 <dons> merijn: its threadsafe in haskell land
17:26:38 <dons> glad you're finding the book useful :)
17:26:52 <pastah_rhymez> merehap: he was all like "i wanna learn monads! if you can't explain it so that i understand then you suck ballz"
17:26:55 <lispy> dons: How are you here??
17:26:57 <lispy> :)
17:27:18 <dons> lispy: chillin like a villain at pdx. boarding in 20.
17:27:30 <lispy> dons: ah, enjoy your flight
17:27:32 <zygoloid> *shudder* unsafeInterleaveIO *shudder*
17:27:37 <pastah_rhymez> so i asked him to make me find :: a -> [(a,b)] -> Maybe b
17:27:49 <dons> :t lookup
17:27:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:27:55 <ivanm> dons: you heading down under now?
17:27:56 <pastah_rhymez> i gave him ~ 1 hour... still couldn't do it
17:27:58 <merehap> pastah_rhymez: wow, it seems I missed out on a lot, I only saw the discussion when he first joined the channel. good luck keeping your sanity
17:27:59 <dons> ?src lookup
17:27:59 <lambdabot> lookup _key []          =  Nothing
17:27:59 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
17:27:59 <lambdabot>                         | otherwise = lookup key xys
17:28:10 <dons> ivanm: damn straight!
17:28:27 <merijn> dons: ok, that's what I thought
17:28:38 <dons> merijn: well, it needs the Eq constraint, obv.
17:28:44 <ivanm> dons: cutting it a bit fine to be with your family for Christmas, aren't you?
17:28:51 <dons> landing on xmas day :)
17:28:56 <pastah_rhymez> dons: it was not about using standard functions...
17:29:07 <dons> the usa likes to work right up to xmas, and there's no freaking' boxing day.
17:29:16 <pastah_rhymez> it was about haskelllove proving that he could write recursive list functions
17:29:20 <Philonous> Computer crashed. Are there logs of the chat?
17:29:27 <pastah_rhymez> @logs
17:29:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:29:32 <merehap> I never even knew what boxing day was until a few years ago
17:29:36 <Philonous> Silly me. Should read the topic -.-
17:29:46 <pastah_rhymez> merehap: i still don't know...
17:29:47 <ivanm> dons: and you just want to see if they give you anything fancier than usual for christmas dinner or something, don't you ;-)
17:29:55 <dons> its when all the aussies and kiwis fight each other for left over christmas cake.
17:30:04 <lispy> haha
17:30:07 <merehap> thats what I was always hoping for
17:30:07 <ivanm> merehap: well, down here most people think it's a day off to watch the cricket... >_>
17:30:11 <simplicio> KICKBOXING DAY
17:30:13 <merehap> it was a bit let down in the end...
17:30:16 <ivanm> @slap simplicio
17:30:17 * lambdabot pulls simplicio through the Evil Mangler
17:30:26 <pastah_rhymez> dons: "kiwis"?
17:30:33 <merehap> new zealanders
17:30:35 <zygoloid> @where logs
17:30:35 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
17:30:41 <ivanm> IIRC, it was from the tradition of palming off leftovers to the "little people"
17:30:58 <dons> our less endowed friends in the antipodes. (viv isn't here, is he??)
17:31:12 <merehap> ivanm: well today I can say I learned something on the Haskell channel :)
17:31:17 <ivanm> heh
17:31:22 <ivanm> preflex: seen viv
17:31:22 <preflex>  Sorry, I haven't seen viv
17:33:28 <ivanm> dons: so, how long are you going to be basking in the warmer weather?
17:33:40 <dons> got about a month. and at least a week in syd.
17:34:05 <ivanm> *nod*
17:34:21 <ivanm> well, enjoy!
17:34:29 <dh_> Merry Christmas guys. a quick question, is there a way in Haskell to represent a list (or other type) of functions , while each of them have different type?
17:34:42 <lispy> dh_: yes
17:34:54 <ivanm> but not easily and it isn't recommended
17:34:59 <dh_> lispy: what is it  ?
17:35:01 <ivanm> (if you want a list)
17:35:06 <ivanm> heterogenous lists
17:35:21 <lispy> dh_: You can use HList, GADTs, or Existential wrappers
17:35:23 <dh_> : not necessary a list . I need a just a containter.
17:35:28 <lispy> And possibly other things
17:35:49 <ivanm> dh_: tuples?
17:36:01 <dh_> ok, thanks. I'll do some reading on that. the problem of haskell is : too many new stuff :)
17:36:03 <ivanm> @type (succ, (*), show, read, not)
17:36:04 <lambdabot> forall a a1 a2 a3. (Enum a, Num a1, Show a2, Read a3) => (a -> a, a1 -> a1 -> a1, a2 -> String, String -> a3, Bool -> Bool)
17:36:15 <lispy> dh_: I'd skip HList
17:36:40 <ivanm> unless you _want_ bad things to happen ;-)
17:36:45 <dons> no serious haskell program needs hlist.
17:36:49 <dh_> tuple is not good , because the (list ) is not fixed length.
17:37:06 <dh_> I don't think list of function is bad  things.
17:37:38 <Philonous> dh_: What do you want to do with the functions in the list?
17:37:48 <dh_> I can compose [ inc , double, string ] , each of them is a function.
17:37:49 <lispy> dh_: if the list of functions represents a chain that can be applied, data FList a c where Nil :: FList a a; Cons :: (a -> b) -> FList b c -> FList a c, GADT solution
17:38:05 <tensorpudding> > map ($ 5) [(+ 5), (* 5)]
17:38:06 <lambdabot>   [10,25]
17:38:34 <dh_> I want to use a list to represent a list of functions that can be composed.
17:38:47 <dh_> [A->B, B->C, C->D, ...]
17:39:18 <Philonous> dh_: But there is nothing much that you can do with them but compose them. So why not compose them right away?
17:39:49 <dh_> I can trace them, by adding debug information between each of them.
17:39:55 <tensorpudding> @type foldr (.) id
17:39:57 <lambdabot> forall b. [b -> b] -> b -> b
17:40:08 <lispy> dh_: the type I just gave can do exactly that
17:40:36 <dh_> lispy: the Flist ?
17:40:41 <lispy> dh_: aye
17:40:50 <dh_> lispy: thanks :)
17:41:27 <lispy> dh_: The pdf linked here has more details and explanation: http://ir.library.oregonstate.edu/jspui/handle/1957/11180
17:41:44 <lispy> dh_: IIRC, one of the appendix sections does the function list example
17:42:36 <merijn> btw, values such integers are Haskell are secretly just nullary functions returning themselves, aren't they?
17:42:47 <tensorpudding> no
17:43:03 <dh_> lispy: thanks. it's the second time that this darcs thesis hits me :)
17:43:27 <lispy> dh_: well, I wrote it, so if you have questions let me know :)
17:43:31 <merijn> tensorpudding: So what's the difference then?
17:43:34 <merehap> @src ord
17:43:34 <lambdabot> Source not found. You untyped fool!
17:43:47 <merehap> wow, interesting insult
17:43:48 <lispy> dh_: there is also thrists by gabor
17:43:52 <ivanm> merijn: you can think of them that way, but technically speaking it's not correct
17:43:57 <merehap> @src Data.Char.ord
17:43:57 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:44:01 <lispy> dh_: same exact idea, thrist == type threaded list
17:44:03 <ivanm> and there are some differences in how they're used/treated
17:44:09 <lispy> dh_: I think gabor even put a library for it on hackage
17:44:10 <dh_> lispy: oh really ? great thanks. I'll read it .
17:44:17 <ivanm> merehap: @src only knows the code which people have given it
17:44:30 <merehap> ah, my mistake
17:44:34 <lispy> dh_: http://hackage.haskell.org/package/thrist
17:44:39 <merijn> ivanm: Well obviously they're not actually functions as that'd be a silly way to implement.
17:45:09 <tensorpudding> what is the conceptual difference between a nullary function and a value anyway
17:45:37 <dibblego> _|_
17:45:39 <zygoloid> tensorpudding: i guess you can give a nullary function an empty arg list or _|_? ;-)
17:45:47 <dh_> lispy: thanks. I'm wondering that by putting so many new , hard material in haskell, will prevent people learning it.
17:45:47 <merijn> tensorpudding: Well, that was kind of my point
17:45:53 <tensorpudding> nullary functions don't take arguments?
17:46:01 <tensorpudding> i thought that was the definition of a nullary function
17:46:20 <zygoloid> tensorpudding: depends who you ask. lambda calculus folks will tell you all functions take exactly one argument
17:46:34 <lispy> dh_: well, historically graduate students and researchers have enjoyed the difficult material and have mulled over it and reiterated it in simpler forms over time
17:46:37 <tensorpudding> yes, which means that there aren't nullary functions in the lambda calculus
17:46:49 <dh_> I'm have a feeling that haskell is becoming playground of mathematician, scientist,.
17:47:16 <tensorpudding> dh_: becoming?
17:47:18 <ben0x539> It was kind of intended as that, no?
17:47:20 <lispy> dh_: I think the trend is actually going the other way.  Haskell gets easier to use over time :)
17:47:21 <merijn> dh_: Becoming? Wasn't that how Haskell got started in the first place?
17:47:28 <dh_> yes : becoming.
17:47:35 <dh_> oh, my fault :)
17:48:04 <jfischoff> newb compliation question, have data SimpleMesh a = SimpleMesh [Triangle a] and
17:48:10 <jfischoff> getPointList :: SimpleMesh a -> [Triangle a];
17:48:10 <jfischoff> getPointList (SimpleMesh triangles) = triangles :: [Triangle a]
17:48:13 <EvanR> merijn: stuff like f = a b c arent functions either
17:48:14 <zygoloid> tensorpudding: is "f :: () -> a" a nullary function? is "f :: (a, b) -> c" a binary function? again depends who you ask :)
17:48:15 <tensorpudding> Haskell isn't the lambda calculus though
17:48:28 <jfischoff> won't compile
17:48:34 <EvanR> merijn: in haskell all functions take one argument
17:48:40 <jfischoff> expects a1 is getting a
17:48:43 <merijn> zygoloid: No, (a, b) -> c is a unary argument taking a tuple
17:48:53 <zygoloid> merijn: ask a mathematician :)
17:49:08 <lispy> jfischoff: that's because type variables are not lexically scoped
17:49:12 <pastah_rhymez> is it reasonable to reason about data placement and caches when talking about haskell code?
17:49:25 <pastah_rhymez> (using unboxed and # all over the place, of course)
17:49:27 <lispy> jfischoff: you can make it so with an extension by the same name
17:49:37 <merijn> EvanR: Yeah I got that far already.
17:49:52 <lispy> jfischoff: but, more than likely we just want to remove the ":: [Triangle a]" since it's redundant but causing a problem
17:49:53 <jfischoff> lispy: cool, is there a downside to using the extension beside portability?
17:50:06 <lispy> jfischoff: It's completely safe
17:50:21 <tensorpudding> mathematics has many definitions of functions
17:50:28 <lispy> jfischoff: you do have to add a "forall a." at the start of the sig once it's enabled though
17:50:44 <lispy> getPointList :: forall a. SimpleMesh a -> [Triangle a]
17:50:50 <zygoloid> merijn: my point is: if you want to talk about 'nullary functions' meaningfully, you need to say what you mean by 'function' since haskell has no nullary functions.
17:50:53 <tensorpudding> a function A -> B can be represented as an element in A x B
17:50:54 <jfischoff> lispy: I added the type :: [Triangle a] for this simple test case
17:50:56 <Philonous> dh_: I bet there are just as many hard to understand papers using C as a language as there a are for Haskell. Haskell just makes is particularly easy to express sophisticated ideas, whereas C programmers are trying to translate shakespeare to babytalk
17:51:10 <jfischoff> lispy: my actually function is more complicated
17:51:28 <lispy> jfischoff: and often you can use asTypeOf
17:51:31 <jfischoff> lispy: nice
17:51:42 <lispy> foo a = ... a `asTypeOf` bar ...
17:52:02 <jfischoff> lispy: huh never seen that
17:52:05 <lispy> ?src asTypeOf
17:52:06 <lambdabot> asTypeOf = const
17:52:11 <dh_> Philonous: agree on Haskell make it easy to express sophisticated ideas, but I don't think there are hard papers using C, because , they are busy at debugging :)
17:52:28 <merijn> zygoloid: Well it does when you consider a value as a function since a value doesn't take arguments. All of which is a rather moot discussion as my primary question trying to construct a memory of all this has been answered :p
17:53:21 <zygoloid> merijn: there's at least two generalizations of the notion which give arities to functions. one is that a -> b -> c is arity 2, another is that (a, b) -> c is arity 2. if we wish to compare them in the nullary case, we're comparing "a" with "() -> a", where the latter is a slightly larger type since it can distinguish () from _|_
17:53:52 <sauf> hi, I want to return Nothing as soon as one of my numerous function applications (Num a => a -> Maybe a) find one. Otherwise I want to return a simple sum with all the a. What is the best (simple) design ?
17:54:07 <pastah_rhymez> sauf: maybe monad
17:54:52 <pastah_rhymez> sauf: hang on... i'm gonna find you a good link :)
17:55:11 <zygoloid> @type \x -> join . listToMaybe . map ($x)
17:55:12 <lambdabot> forall a a1. a1 -> [a1 -> Maybe a] -> Maybe a
17:55:34 <pastah_rhymez> sauf: http://www.haskell.org/all_about_monads/html/index.html
17:55:35 <sauf> pastah_rhymez: I'm all ear !
17:55:40 <sauf> pastah_rhymez: thx
17:55:52 <pastah_rhymez> the first example they bring up is the maybe monad with code and all
17:56:00 <EvanR> sauf: Maybe has >>= installed. so you can link a bunch of 'fight return Nothing' things together and get Nothing if any of them fails
17:56:10 <EvanR> s/fight/might/
17:56:38 <pastah_rhymez> sauf: do you have a lot of 'case mbVal of Nothing -> Nothing; Just x -> Just (f x);' as it is now?
17:56:40 <dh_> Is it possible in Haskell to replace a function's definition when a system is running? for example, a opengl haskell programm is running?
17:56:57 <EvanR> dynamic haskell!
17:56:58 <sauf> pastah_rhymez: no
17:57:07 <pastah_rhymez> sauf: paste some :)
17:57:09 <pastah_rhymez> @paste
17:57:10 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
17:57:17 <lispy> dh_: isn't that what hsplugins allows?
17:57:25 <zygoloid> dh_: yi and lambdabot both do something like that iirc. there's a paper on it somewhere.
17:57:44 <ivanm> well, that's a quick recompilation and a reload
17:57:49 <ivanm> so not a replacement in the erlang sense...
17:57:55 <sauf> pastah_rhymez: all my Nothing comes from if isNaN result || isInfinite result then Nothing else Just result
17:58:02 <dh_> I'm new to haskell, only write about 100 line of code or something, :)
17:58:05 <dh_> thanks !
17:58:07 <zygoloid> dh_: this is the paper: http://www.cse.unsw.edu.au/~dons/papers/SC05.html
17:58:38 <Axman6> dh_: seems to me that would break referencial transparency
17:59:05 <dh_> zygoloid: thanks! it seemed that everything comes with a paper.
17:59:06 <pastah_rhymez> sauf: well, using the maybe monad would be a bit more high level
17:59:08 <zygoloid> dh_: if you have some 'soft' replaceable parts and some 'hard' parts, you could probably get something working using the ghc api
17:59:09 <pastah_rhymez> :)
17:59:49 * lispy heads out for the holiday, Cheers!
18:00:16 <dh_> referencial transparency is not that important. In the process of developing , it's convient to replace a piece of code without restart the system.
18:00:18 <ivanm> have a good one lispy
18:01:18 <dh_> can we use haskell with iphone?
18:01:30 <ivanm> dh_: there's work ongoing for that
18:01:38 <ivanm> @google ghc iphone
18:01:38 <lambdabot> No Result Found.
18:01:41 <ivanm> bah
18:01:47 <dh_> ivanm: thanks.
18:02:02 <zygoloid> dh_: trouble is, haskell cares about referential transparency, and may do strange things if you manage to violate it (like continue using the old result, perhaps)
18:02:48 <sauf> EvanR: something like (lift (+)) >>= myMaybe ?
18:03:52 <merijn> Anyone know a good link about what return actually does? The explanation I'm reading now is very vague and unclear.
18:04:08 <dh_> zygoloid: thanks, I did a lot of dynamic replace in python, and it's convinient.
18:04:12 <tensorpudding> @type return
18:04:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:04:27 <pastah_rhymez> merijn: what are you reading?
18:04:42 <merijn> pastah_rhymez: Real World Haskell
18:04:55 <pastah_rhymez> merijn: it depends on the monad...
18:05:00 <tensorpudding> return takes some value, and wraps it in the monad, so to speak
18:05:11 <pastah_rhymez> it takes a value and wraps it in the monad you're working in
18:05:17 <tensorpudding> > return "foo" :: Maybe String
18:05:18 <lambdabot>   Just "foo"
18:05:27 <pastah_rhymez> > return "lol" :: [String]
18:05:28 <lambdabot>   ["lol"]
18:05:40 <tensorpudding> > return () :: Maybe ()
18:05:41 <lambdabot>   Just ()
18:05:54 <tensorpudding> > return () :: IO ()
18:05:55 <merijn> I'm assuming the confusion comes from the fact the he's explaining return without actually having covered monads, then
18:05:55 <lambdabot>   <IO ()>
18:06:24 <pastah_rhymez> merijn: maybe... it'll get easier once you start worknig with real values :)
18:06:35 <pastah_rhymez> the Maybe monad is a good place to start :)
18:06:52 <tensorpudding> @src join
18:06:52 <lambdabot> join x =  x >>= id
18:06:57 <tensorpudding> hmm
18:07:24 <merijn> After the amount of tip-toeing and hiding away of monads they better be harder then quantum mechanics or else I'll be disappointed by all the hype...
18:07:29 * pastah_rhymez hasn't read RWH yet, so he doesn't know what examples it uses
18:07:31 <tensorpudding> > join [[1..10],[20..30]]
18:07:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,20,21,22,23,24,25,26,27,28,29,30]
18:08:04 <merehap> merijn: they are easy to understand, hard to explain. I really wish monad tutorials weren't visible until someone has done Haskell for 3+ months
18:08:08 <pastah_rhymez> haha, concat :)
18:08:43 <tensorpudding> monads aren't hard, but people need to understand types and typeclasses pretty well before they tackle them
18:08:45 <merijn> It'd be hard to do 3+ months of coding without needing IO...
18:09:03 <merehap> merijn: you don't need to know about monads to do IO
18:09:07 <pastah_rhymez> merijn: you don't need an understanding of monads to do io
18:09:14 <pastah_rhymez> merehap: smurf!
18:09:16 <merehap> merijn: just learn do notation
18:09:22 <Philonous> do notation for IO is pretta straight forward. No need to understand scary operators like (>>=)
18:09:25 <dh_> lispy: I'm reading your paper,  may I have your email if I have question?
18:09:35 <merehap> pastah_rhymez: :-)
18:09:35 <tensorpudding> do notation makes the monadic aspect of IO completely obfuscated
18:09:49 <merehap> tensorpudding: oh well
18:09:53 <pastah_rhymez> merehap: ok, you can talk again...
18:10:01 <tensorpudding> (>>=) isn't hard to understand but it's got a scary type
18:10:07 <Philonous> tensorpudding: That's the point of it, isn't it?
18:10:21 <merijn> pastah_rhymez: Well, that assumption is what's causing a broken mental representation as he's covering stuff like return and mentioning monads and functions in the IO chapter without explaining how they actually relate to IO
18:11:15 <pastah_rhymez> merijn: using monadic stuff + IO isn't really that desirable at first
18:11:28 <tensorpudding> before you get to monads you should be able to be able to reason somewhat about what a function you've never seen before does, based solely on its type
18:11:32 <pastah_rhymez> just learn the do-notation and focus on the list and Maybe monad when learning
18:12:01 <tensorpudding> err, should be able to reason*
18:12:41 <merijn> tensorpudding: It might just be me, but the type class and type stuff seems pretty easy to me...
18:12:56 <pastah_rhymez> merijn: http://www.haskell.org/all_about_monads/html/index.html <-- i'd recommend this for getting an understanding on monads... works its way up from the bottom, showing you the reasons for having monads etc.
18:13:17 <jfischoff> still spinning my wheels trying to compile...
18:13:23 <jfischoff> what does Occurs check: cannot construct the infinite type: a = Point3' a typically mean?
18:13:52 <pastah_rhymez> jfischoff: you missed an argument somewhere, or a parentheses
18:14:15 <pastah_rhymez> at least that's how i get that :)
18:14:48 <merehap> pastah_rhymez: when I was first learning Haskell, pretty much all of the error messages made me want to tear my hair out
18:15:12 <jfischoff> pastah_rhymez: naw, don't think so
18:15:18 <pastah_rhymez> merehap: yeah... same here
18:15:25 <merehap> now I just understand, ok, this jibberish means I left an argument off
18:15:27 <pastah_rhymez> jfischoff: paste it (datatype + code)
18:15:43 <Saizan> jfischoff: well, it means you're using an 'a' where it expects a "Point3' a" or vice versa
18:15:48 <jfischoff> getPointList :: forall a. SimpleMesh a -> [(Point3' a)]
18:15:48 <jfischoff> getPointList (SimpleMesh triangles) =
18:15:48 <jfischoff> 	List.nub $ List.concat $ map toList triangles
18:15:54 <pastah_rhymez> jfischoff:
18:15:56 <pastah_rhymez> @paste
18:15:56 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:16:09 <Colours> hello! I am very confused by this: http://pastebin.com/m63231cec
18:16:12 <jfischoff> @paste?
18:16:12 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:16:40 <merehap> yes, what lambabot said in response to you :)
18:16:40 <jfischoff> pastah_rhymez: totally newb to irc, first day, what's pastebin?
18:17:01 <pastah_rhymez> jfischoff: click on what lambdabot linked to
18:17:05 <pastah_rhymez> then click on NEW
18:17:10 <pastah_rhymez> dump your code
18:17:20 <pastah_rhymez> then click DONE (or whatever)
18:17:25 <pastah_rhymez> then paste link to your code here
18:17:40 <Luke> anyone know how to set up a local multicast channel on my desktop? I want to test a multicast app.
18:17:44 <Saizan> Colours: it prints F (F (F (F (F .... right?
18:17:47 <Colours> yes
18:17:50 <jfischoff> pastah_rhymez: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5552#a5552
18:18:30 <jfischoff> that won't compile...let me try again
18:18:36 <pastah_rhymez> jfischoff: click on Add Revision and paste your error
18:18:43 <Saizan> Colours: well the show instance is something like show (F x) = "F (" ++ show x ++ ")"
18:18:48 <jfischoff> pastah_rhymez: cool, one sec
18:19:06 <Saizan> Colours: but pattern matching against F doesn't really cause any evaluation, because F is a newtype
18:19:17 <pastah_rhymez> jfischoff: just shout out when you've pasted it so i can reload the page :)
18:19:19 <Saizan> Colours: so it goes on indefinitely
18:20:20 <pastah_rhymez> jfischoff: also, DoubleType is missing :(
18:20:27 <Philonous> Colours: Thanks for the code. It's pretty insightful.
18:20:30 <jfischoff> pastah_rhymez: pasted and updated the code it should compile now
18:20:45 <Colours> oh I didn't write that
18:20:52 <Colours> I was just confused by it
18:20:55 <jfischoff> pastah_rhymez: opps missing the constructor for Point3'
18:20:56 <Saizan> jfischoff: toList :: Triangle a -> a, not Triangle a -> Point3' a
18:21:14 <jfischoff> ah
18:21:23 <jfischoff> pastah_rhymez: ah
18:21:47 <Saizan> err
18:22:08 <Saizan> toList :: Triangle a -> [a], not Triangle a -> [Point3' a]
18:22:14 <Saizan> but you see my point :)
18:22:33 <Saizan> ?type Data.Foldable.toList
18:22:34 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
18:22:47 <jfischoff> so the toList function is from foldable yeah
18:22:57 <jfischoff> so I should redefine it?
18:23:19 <Saizan> you should define your own function to extract the Point3' a
18:23:53 <jfischoff> ok
18:24:15 <Saizan> points (Triangle p0 p1 p2) = [p0, p1, p2]
18:24:17 <pastah_rhymez> jfischoff: what's that forall a. doing there?
18:24:29 <pastah_rhymez> that's a good way to fuck shit up...
18:24:58 <jfischoff> pastah_rhymez: haha yeah that was lispy helping me based on bad information from me
18:25:06 <Saizan> no, the forall a. doesn't change anything here.
18:25:06 <pastah_rhymez> hehe
18:25:17 <jfischoff> pastah_rhymez: good advice for the problem I explained
18:25:32 <pastah_rhymez> jfischoff: forall is for nasty typehacks when you need to hide stuff
18:25:37 <Saizan> the only thing that would have helped was to remove the signature and look at the one ghci inferred for you
18:25:57 <Saizan> forall as used there is for ScopedTypeVariables
18:26:00 <pastah_rhymez> jfischoff: paste your code for 'toList'
18:26:05 <Saizan> which has little to do with hiding stuff
18:26:17 <jfischoff> what's weird si the function worked put I couldn't composite it
18:26:20 <pastah_rhymez> Saizan: what about the s in ST?
18:26:26 <jfischoff> pastah_rhymez: one sec
18:26:41 <Saizan> toList is the one from Foldable, no?
18:27:21 <Saizan> pastah_rhymez: that has little to do with the use here, since for ST we're using an higher-rank type
18:27:21 <pastah_rhymez> Saizan: i'm guessing 'toList t = [p0 t, p1 t, p2 t]'
18:27:45 <pastah_rhymez> Saizan: and hiding nasty shit
18:28:08 <Saizan> pastah_rhymez: toList from Foldable explains the type error, your definition doesn't
18:28:37 <pastah_rhymez> well, my definition is what it should be, isn't it?
18:28:52 <Saizan> yes
18:29:08 <pastah_rhymez> jfischoff: you haven't imported Data.Foldable, have you?
18:29:12 <jfischoff> pastah_rhymez: pasted http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5552#a5555
18:29:30 <jfischoff> pastah_rhymez: my bad I didn't include the whole file
18:29:40 <jfischoff> pastah_rhymez: but I did in my file
18:29:41 <gwern> aw yeah!
18:29:50 <gwern> it took 2 hours and 18 minutes, but my criterion run is done
18:29:55 <Saizan> jfischoff: are you still getting an error?
18:30:00 <gwern> and the victor... yhc, in every benchmark
18:30:56 <jfischoff> Saizan: yeah, but with centroid :: DoubleMesh -> Point3
18:30:56 <jfischoff> centroid mesh = averageVec $ getPointList mesh
18:31:51 <Saizan> type of averageVec?
18:32:12 <jfischoff> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5556#a5557
18:32:38 <jfischoff> Saizan: one sec...
18:33:18 <jfischoff> Saizan: 	SG-1.0: Small geometry library for dealing with vectors and collision detection	Source code	Contents	Index
18:33:18 <jfischoff> Data.SG.Vector
18:33:18 <jfischoff> Description
18:33:18 <jfischoff> The module with all the different type-classes for vectors. Generally, the main functions you might need from this function are:
18:33:19 <jfischoff> magSq and mag (defined for all vectors).
18:33:21 <jfischoff> getX and getY (defined for all vectors) as well as getZ (defined for all vectors with 3 or more dimensions).
18:33:25 <jfischoff> dotProduct, unitVector, averageVec, averageUnitVec, sameDirection, projectOnto, projectPointOnto, distFrom (defined for all vectors).
18:33:28 <jfischoff> iso, which is defined for all combinations of vectors with the same number of dimensions.
18:33:30 <jfischoff> The rest of the functions are mainly just wiring necessary for other functions, but must be exported.
18:33:32 <jfischoff> As to the vector types, there are two methods to use this library. One is to use the types from the Data.SG.Vector.Basic library, which support basic vector operations. The other is to use the types from the Data.SG.Geometry.TwoDim and Data.SG.Geometry.ThreeDim modules, where a position vector is differentiated from a relative vector (to increase clarity of code, and help prevent errors such as adding two points together). Both systems can be used wi
18:33:37 <jfischoff> th various useful functions (involving lines too) from Data.SG.Geometry.
18:33:39 <jfischoff> Synopsis
18:33:41 <jfischoff> class IsomorphicVectors from to where
18:33:43 <jfischoff> iso :: Num a => from a -> to a
18:33:46 <jfischoff> class Foldable p => Coord p where
18:33:47 <jfischoff> getComponents :: Num a => p a -> [a]
18:33:49 <jfischoff> fromComponents :: Num a => [a] -> p a
18:33:51 <jfischoff> magSq :: Num a => p a -> a
18:33:55 <jfischoff> dotProduct :: Num a => p a -> p a -> a
18:33:57 <jfischoff> class Coord p => Coord2 p where
18:33:59 <jfischoff> getX :: p a -> a
18:34:01 <jfischoff> getY :: p a -> a
18:34:03 <jfischoff> class Coord2 p => Coord3 p where
18:34:05 <jfischoff> getZ :: p a -> a
18:34:07 <jfischoff> origin :: (Coord p, Num a) => p a
18:34:07 <gwern> jfischoff: maybe you could take this to -indepth or a pastebin?
18:34:07 --- mode: ChanServ set +o Saizan
18:34:09 <gwern> srsly
18:34:09 <jfischoff> mag :: (Coord p, Floating a) => p a -> a
18:34:11 <jfischoff> unitVector :: (Coord p, VectorNum p, Ord a, Floating a) => p a -> p a
18:34:11 --- mode: Saizan set +b *!*=jfischof@66.218.169.*
18:34:32 <gwern> anyway....
18:34:39 <gwern> the criterion output is here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14873#a14874
18:34:40 <Saizan> he probably pasted by error
18:34:52 <holmak> too bad, sounded like a neat library
18:34:55 --- mode: Saizan set -b *!*=jfischof@66.218.169.*
18:35:02 <gwern> notice that yhc wins on every benchmark, somtimes quite significantly
18:35:09 <Saizan> jfischoff: still there?
18:35:21 <gwern> 25s v 29 is pretty good, but 1.8 v 4 is even better!
18:35:38 <jfischoff> saizan: yeah
18:36:12 <jfischoff> saizan: sorry about that. The whole page above the hdoc was selected could't see it
18:36:31 <Saizan> jfischoff: k, it's fine
18:36:45 --- mode: Saizan set -o Saizan
18:37:26 <Saizan> though we still don't know what the type of averageVec is :) i suspect something like Num a => [a] -> [a]
18:37:33 <Saizan> err, Num a => [a] -> a
18:37:40 * increpare is finding arrays to be a bit sordid to deal with...wonders why they always feel so ugggly
18:37:58 <jfischoff> saizan: no hold I'll put it on hpaste...
18:38:18 <jfischoff> saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5556#a5558
18:40:01 <Saizan> jfischoff: ok, so the problem is exactly that it requires (p a) to be a Num and Point3' DoubleType is your "p a" here, but there's no Num instance for it, not sure if you want to make that instance or modify averageVec here
18:44:50 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2143
18:44:57 <gwern> one could spend a night in much worse ways
18:45:02 <jfischoff> Saizan: my bad, I don't know why I thought Point3' was already and instance of Num
18:45:55 <dh_> I have a bug when cabal install template-haskell
18:46:02 <gwern> so do I
18:46:07 <dh_> Language/Haskell/TH/Syntax/Internals.hs:20:7:
18:46:08 <dh_>     Could not find module `Data.Data':
18:46:08 <dh_>       it is a member of the hidden package `base'
18:46:08 <dh_>       Use -v to see a list of the files searched for.
18:46:12 <dh_> any help?
18:46:23 <Saizan> you can't upgrade the template-haskell package
18:46:39 <dh_> the Yi edtior depends on that.
18:46:54 <Saizan> (or downgrade, you've to use the one that comes with ghc)
18:47:06 <Saizan> dh_: not really, but we need to give hints to cabal
18:47:14 <calsaverini> @src replicateM
18:47:14 <lambdabot> replicateM n x = sequence (replicate n x)
18:47:23 <calsaverini> @src replicate
18:47:23 <lambdabot> replicate n x = take n (repeat x)
18:47:36 <calsaverini> hummmm
18:47:39 <dh_> saizan : do you know how  ? or what should I google?
18:47:43 <merehap> dh_: thats exactly the error I got
18:47:59 <calsaverini> I love lambdabot
18:48:02 <calsaverini> just LOVE it
18:48:29 <calsaverini> I wanna marry it
18:48:52 <Gracenotes> @vixen You have another stalker, lambdabot
18:48:52 <lambdabot> liverwurst gets me really gassy...
18:48:57 <ivanm> calsaverini: s/it/she/
18:49:02 <DarthShrine> I have a simple program (http://pastie.org/755211) which reads the lines of a file, one number per line and sorts them according to their absolute value. Problem is, it's exceptionally slow. Could this be because of read/show? (There are at most 10^6 values)
18:49:03 <ivanm> @vixen a/s/l
18:49:04 <lambdabot> 19/f/California
18:49:07 <Gracenotes> @vixen TMI
18:49:07 <lambdabot> Let's change the subject
18:49:10 <chrisdone> I am so incredibly drunk yet I still have the capability to type touch type
18:49:22 <chrisdone> I'm like steven hawking
18:49:24 <Gracenotes> muscle memory, right?
18:49:25 <j4cbo> but can you write code that typechecks?
18:49:30 <ivanm> chrisdone: just not to make understandable sentences...
18:49:31 <chrisdone> evxcept my ramblinhs are worthless
18:49:34 <Saizan> dh_: sorry, got disconnected
18:49:36 <ivanm> "type touch type"?
18:49:43 <ivanm> and steven hawking doesn't type...
18:49:50 <dcymbala> Anyone up for a newbie question about building a list of Doubles from a text file?
18:49:59 <chrisdone> ivanm: are you trying to antagonize me?
18:50:05 <Gracenotes> what does the text file look like?
18:50:09 <ivanm> antagonize? no
18:50:13 <ivanm> make fun of? maybe...
18:50:16 <Saizan> dh_: --constraint="data-accessor-template < 0.2.1.2" --constraint="data-accessor < 0.2.1"
18:50:17 <dh_> Saizan: np, how can I tell Yi to don't upgrade template-haskell?
18:50:18 <dcymbala> just a float on each line?
18:50:21 <chrisdone> ~_~
18:50:22 <Gracenotes> dcymbala: it can probably be done as a one liner
18:50:23 <Baughn> DarthShrine: That sort function is incredibly slow. Use the built-in sort instead.
18:50:26 <chrisdone> oh god
18:50:27 <dh_> saizan: thanks!!
18:50:28 <Baughn> DarthShrine: It /looks/ nice, but..
18:50:46 <dh_> I'm kind of hate templates because of c++.
18:50:50 <DarthShrine> Baughn: Okay :)
18:50:51 <chrisdone> I wish I could go to sleep safe in the nowledge that I owuld wake up not covered in puke
18:51:09 <j4cbo> drink water
18:51:19 <sjanssen> gwern: your numbers might not be relevant because the sort functions are defined in the same module as main
18:51:25 <ivanm> chrisdone: then fall asleep with your head resting over the bowl of a toilet
18:51:31 <j4cbo> or that.
18:51:34 <Saizan> dh_: template-haskell is much saner than those, tbh :)
18:51:39 <sjanssen> gwern: and unsafePerformIO? :(
18:51:55 <dh_> saizan: I'll give it try later. c++ is a shit
18:52:04 <chrisdone> I feel so ulnerable
18:52:07 <holmak> chrisdone: I like cereal and water, myself
18:52:13 <dh_> c++ deprived all my pleasure of programming.
18:52:17 <holmak> always makes me feel better
18:52:20 <Gracenotes> dcymbala: do { str <- readFile "text"; print (map read . lines $ str :: [Double]) }. take the string, split it up into a list of lines, then read each element therein
18:52:39 <chrisdone> sooo sick
18:52:43 <sjanssen> gwern: another big problem is that you don't evaluate the lists to be sorted before running the benchmarks
18:52:48 <Gracenotes> the [Double] is needed because it needs to know what to read it to
18:52:49 <chrisdone> why do I allow tjios tp ha[[em
18:52:50 <calsaverini> HAHAHAHAHAHAA, I didn't knew about lambdabot's conversation abilities!
18:52:54 <dcymbala> right
18:53:21 <calsaverini> I thought it was... I mean, she was just a haskell evaluator on steroids.
18:53:31 <Baughn> @girl
18:53:32 <lambdabot> nobody can catch me
18:53:37 <sjanssen> gwern: GHC sort goes first, so it gets all the work of creating and allocating those lists
18:53:44 <calsaverini> so, now I definitely wanne marry she.
18:53:55 <calsaverini> aheuhauheuahe
18:53:58 <Gracenotes> there are more pithy ways to put it, but the need for the type annotation doesn't make it /too/ much shorter
18:53:58 <chrisdone> technicalaly I already puked up in the taxi
18:54:11 <chrisdone> ffs
18:54:17 <Gracenotes> e.g. you don't need the do block
18:54:20 <holmak> Why marry, when you can "cabal install"?
18:54:28 <Saizan> chrisdone: you should move that on #haskell-blah :)
18:54:33 <merehap> @boy
18:54:33 <lambdabot> Maybe you meant: bf bid bug do yow
18:54:40 <chrisdone> sorry I thought that was where I wasw
18:54:46 <chrisdone> O_o
18:55:58 <holmak> drunkVision channelName = takeWhile (/= '-') channelName
18:56:13 <medfly> hehe
18:56:19 <holmak> er perhaps the reverse
18:56:40 <dcymbala> Gracenotes: And how do I write a function that returns the resulting list of Doubles?
18:56:43 <medfly> it's not off topic if written in the form of Haskell!
18:57:37 <holmak> we are doing type-level Blood Alcohol Level metrics
18:57:55 <holmak> chrisdone is just doing field research
18:57:56 <sauf> here is what I want
18:58:02 <sauf> > let lift f y = case y of Just x -> fmap Just (f x);_ -> \_ ->Nothing in Just 8 >>= (lift (+)) (Just 9) >>= (lift (*)) (Just 3)
18:58:03 <lambdabot>   Just 51
18:58:10 <sauf> > let lift f y = case y of Just x -> fmap Just (f x);_ -> \_ ->Nothing in Just 8 >>= (lift (+)) Nothing >>= (lift (*)) (Just 3)
18:58:11 <lambdabot>   Nothing
18:58:15 <sauf> > let lift f y = case y of Just x -> fmap Just (f x);_ -> \_ ->Nothing in Just 8 >>= (lift (+)) (Just 9) >>= (lift (*)) Nothing
18:58:16 <lambdabot>   Nothing
18:58:23 <sauf> > let lift f y = case y of Just x -> fmap Just (f x);_ -> \_ ->Nothing in Nothing >>= (lift (+)) (Just 9) >>= (lift (*)) (Just 3)
18:58:24 <lambdabot>   Nothing
18:58:37 <medfly> I wonder under the effects of what drugs it is possible to program :)
18:58:58 <Luke> > lift
18:59:00 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a),
18:59:00 <lambdabot>                    GHC.Show...
18:59:06 <bd_> :t lift
18:59:06 <Luke> > :t lift
18:59:07 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:59:08 <lambdabot>   <no location info>: parse error on input `:'
18:59:15 <bd_> Luke: no > for :t
18:59:20 <Luke> ty
18:59:22 <Luke> :t lift
18:59:23 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:59:41 <Luke> :t liftM
18:59:44 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:59:50 <bd_> Luke: lift takes a monad value from one monad, and turns it into one in a monad transformer based on the former monad
19:00:32 <Luke> so it lifts from a monad into a monad transformer?
19:00:55 <Gracenotes> dcymbala: well, the type of that would be String -> IO [Double], say: taking a file name and returning a list of doubles, with the IO type (since IO is done in it). then you'd have blah path = do { str <- readFile path; return (map read . lines $ str :: [Double]) }. and use multiline do block, which might look better than curly braces. return is nothing like imperative languages, incidentally.. it
19:00:57 <Gracenotes>  just transforms a [Double] to an IO [Double], since it's what's required for the do block
19:01:17 <Philonous> Luke: into the transformed monad
19:01:31 <Luke> cool thanks
19:01:40 <bd_> Luke: pretty much. For example, in a StateT whatever IO ...., you could do lift (putStrLn "Hello world!")
19:01:54 <bd_> there's liftIO as a convenience too - it'll drill down however many layers it needs to get to IO
19:02:01 <Luke> i still haven't wrapped my head around transformers yet =) haven't read that chapter yet
19:02:02 <bd_> but essentially just keeps applying lift
19:02:14 <Luke> nice
19:02:45 <DarthShrine> Baughn: I've updated it to use sortBy (http://pastie.org/755313 - excuse my terrible code), but it's still very slow
19:03:04 <Gracenotes> dcymbala: transformating is very simple and efficient, no IO is actually done.. it just gives it the right type. And as a one liner, btw, it might be:
19:03:06 <Gracenotes> @type liftM (map (read :: String -> Double) . lines) . readFile
19:03:07 <lambdabot> FilePath -> IO [Double]
19:03:08 <monochrom> You got it wrong. Transformers are wrappers, not wrappees.
19:04:29 <dh_> is there any user manual for the yi editor?
19:06:31 <holmak> http://www.nobugs.org/developer/yi/, maybe
19:07:00 <dh_> holmak: thanks. I guess I have to read the source.
19:07:17 <trie> Can someone help me understand why the following code refuses to compile with a "Ambiguous type variable" error
19:07:27 <trie> code at: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14893
19:08:53 <c_wraith> trie: the compiler can't figure out what type _ is in that lambda
19:08:58 <c_wraith> trie
19:09:05 <mreh> i'm going to attempt to make a lilypond to haskore module, does anyone have any doubts or concerns before I begin, because it seems to be a simple one to one translation of recursive data types into simple lilypond data structures
19:09:31 <c_wraith> trie: there are many options it could be, and it requires that you specify one specific one, regardless of whether it actually matters in that context
19:09:51 <mreh> it seems many people have tried and failed/hudak and theilmann are too busy doing other things to collect the results
19:09:58 <trie> c_wraith: why does it need to? since the argument is always ignored and the return type is clear?
19:10:26 <c_wraith> trie: part of compilation is finding a concrete type for everything.  Even if it isn't strictly necessary
19:10:28 <Saizan> trie: depending on the type of the argument handle will catch different sets of exceptions
19:10:43 <Saizan> trie: so, depending on the type you get a different semantic
19:11:24 <monochrom> There are many instances of typeclass Exception. It is unclear which instance you want.
19:11:39 <Saizan> trie: if you want to catch everything you can import Control.Exception (handle, SomeException(..)) and rewrite the lambda as (\(SomeException _) -> ..)
19:11:48 <trie> I want all of them regardless of type - hence the wildcard
19:12:14 <Saizan> the wildcard only says you don't care about the value, it says nothing about the type
19:12:23 <Saizan> and the exceptions are subdivided by type
19:13:17 <trie> But in this case I really don't care about the type either? But each expression needs to be typed so It makes sense.
19:13:22 <Saizan> using the SomeException constructor you pick a type, which is the one that's at the top of the hieararchy here, so you catch them all
19:13:28 <monochrom> If you wrote code that didn't involve any typeclass, you would be right about no one caring about the type.
19:13:46 <Saizan> you care about the type, because that's how you say it which exceptions you want
19:14:34 <sjanssen> why is it Control.DeepSeq and not Data.DeepSeq?
19:15:09 <trie> How did you figure out which is the most general exception type?
19:15:53 <Saizan> from the Control.Exception documentation
19:16:02 <Saizan> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Exception.html#t%3ASomeException
19:16:48 <trie> hoogle being down sucks. I get it now. thanks guys!
19:16:58 <Saizan> np :)
19:17:17 <bd_> sjanssen: because it's a control flow operation (forcing code to execute) rather than a data structure?
19:18:19 <sjanssen> bd_: I don't find the control flow argument convincing
19:18:21 <dcymbala> Gracenotes: That looks like it's working fine now, thanks. Now I'm getting a failure on converting a string to and Integer to pass to a function. Any idea what is wrong with: do { b <- read str :: Integer; (f b) } ?
19:18:53 <Botje> read is not a monadic action.
19:19:13 <Saizan> dcymbala: x <- foo, makes sense only if foo is of type M A, for some monad M
19:19:13 <Botje> f (read str :: Integer)
19:19:22 <bd_> sjanssen: It doesn't alter or observe the actual data in question; I don't see why it would be in Data
19:19:28 <kw317> hmm.. is every function from |N to |N representable in System F w/o fixpoint?
19:19:30 <Botje> or let b = read str :: Integer in f b
19:19:46 <bd_> the fact that it traverses the data structure is just an implementation detail :)
19:20:07 <Saizan> kw317: those would be the naturals?
19:20:11 <kw317> yes
19:21:25 <Saizan> i'd guess no, by something like the incompleteness theorem, though i don't know
19:21:51 <kw317> hmm.. for example f(n) = if n > 4 then 1 else 0
19:21:53 <dcymbala> so using the <- notation only applies to a monad context?
19:22:23 <Gracenotes> dcymbala: mm. the do block I used above is used because it makes it easy to express IO actions (any IO do block has the type (IO something)). In your case, and most cases, a do block isn't needed. It's darker, more monadic sort of (totally comprehensible, really) magic
19:22:47 <kw317> could represent it if I had the minimization, but..
19:24:03 <Saizan> kw317: that's like \n -> zero? (sub n 4) 0 1
19:24:18 <Saizan> kw317: using definitions from here http://en.wikipedia.org/wiki/Church_encoding
19:24:31 <kw317> yeah, damn
19:24:38 <kw317> it's late ;-)
19:25:05 <kw317> I'm trying to think of something for which you need minimization and what can't be computer using a paramorphism
19:25:15 <dcymbala> Perhaps I'm still thinking procedurally, but is it safe to say that <- only applies when a monad is involved, and let is used when an alias for a function result is needed?
19:25:38 <kw317> fib and fact are easily rep., so is ackermann function
19:25:44 <Saizan> yeah, more or less
19:26:02 <pikhq> dcymbala: More or less.
19:26:49 <dcymbala> ok, that clarifies what I've been struggling with - thanks
19:26:55 <ivant> I need to process a huge XML in Haskell, so loading the whole thing in memory is out of the question. Is there a way to read/parse/transform it "lazily"? Can I do that with HXT, or there's some better choice?
19:27:17 <monochrom> HXT reads the whole thing in memory.
19:27:18 <Saizan> dcymbala: let x = foo means that x and foo are exactly the same thing, while x <- foo, means that x is the result of executing foo, where the exact meaning of "execution" depends on the monad
19:27:50 <Saizan> kw317: what was minimization?
19:27:54 <Gracenotes> maybe FRP might be applicable to get a SAX-like parser
19:28:06 <Saizan> ivant: tagsoup let you do stream processing
19:28:11 <Gracenotes> no thoughts whatsoever on whether it'd be performant
19:28:34 <ivant> Saizan: thanks for the tip!
19:28:36 <monochrom> HaXML has a part that reads incrementally. You can ask for one element, and just one element is read.
19:28:39 <Philonous> > do { x <- [1..3]; y <- [10,20,30]; return x+y }
19:28:40 <lambdabot>   No instance for (GHC.Num.Num [b])
19:28:40 <lambdabot>    arising from the literal `10' at <inte...
19:28:45 <Saizan> well, for a SAX-like parser you can just use tagsoup with lazy IO, or iteratees
19:28:51 <Gracenotes> hm. Well, at least something reactive.. a time-based model certainly isn't the best idea
19:29:00 <kw317> Saizan: finding n s.t. some function g(n) = 0
19:29:03 <Saizan> though maybe FRP would be nicer than iteratees (i hope)
19:29:11 <kw317> Saizan: I thinks that square root will do as an example
19:29:35 <Philonous> > do { x <- [1..3]; y <- [10,20,30]; return (x+y) }
19:29:36 <lambdabot>   [11,21,31,12,22,32,13,23,33]
19:30:03 <ivant> monochrom, Saizan, Gracenotes: thanks!
19:30:12 <kw317> t = 0; while (t^2) != n do t := t + 1; return t -> can't do it without minimization
19:32:31 <Saizan> i wonder how a proof that some total function can't be written in System F would look
19:32:58 <Gracenotes> suffocatingly formal, I'd guess?
19:33:13 <monochrom> would look like a halting problem
19:33:36 <Gracenotes> mm, System F is pretty turing-complete
19:33:48 <Saizan> System F is not turing complete
19:33:58 <Gracenotes> no? :| darn it. s/pretty/almost/
19:34:08 <Saizan> i was thinking of a function you can write on a turing machine, however
19:34:31 <Gracenotes> what's stopping it? doesn't have natural recursion, and types make fix impossible, right?
19:34:34 <monochrom> try ackerman then, usually works.
19:34:50 <kw317> Gracenotes: yes
19:34:54 <Saizan> Gracenotes: yeah, no general recursion
19:34:59 <kw317> monochrom: it's rep. in systme f
19:35:00 <Gracenotes> haven't worked on this in a bit
19:35:03 <kw317> *System F
19:35:06 <Saizan> Gracenotes: all terms have a normal form
19:35:10 <kw317> that's the funny bit ;-)
19:35:11 <roconnor> ``As a term rewriting system, System F is strongly normalizing. '' <-- wikipedia
19:35:22 <Gracenotes> seriously need to dive into TAPL again
19:35:31 <kw317> because you can do higher-order iteration
19:36:57 <kw317> ok, time to bed
19:36:58 <kw317> thanks!
19:37:07 <monochrom> But you can build upon ackerman. try: f(n) = iterate something ackerman(n,n) times
19:38:01 * hackagebot upload: hxt-extras 0.1 - Extra functions for HXT (TonyMorris)
19:38:27 <monochrom> How about some decision problems about System F?
19:39:16 <Saizan> a System F typechecker?:)
19:39:21 <ivanm> dibblego: what kind of extra functions does hxt-extras contain that you didn't try to get them upstream?
19:39:58 <monochrom> Yeah, something like "can you write a System F program that typechecks an alleged System F program"
19:40:07 <ivanm> heh
19:40:19 <ivanm> then you get the typechecking problem (ala the halting problem)? :p
19:40:47 <dibblego> ivanm, only two functions, but I am annoyed with writing Util.hs all the time
19:40:58 <ivanm> *nod*
19:41:17 <monochrom> "can you write a System F program that takes a System F program as input, run it with itself as input"
19:42:57 <rwx> F(F(x)) ?
19:43:15 <Gracenotes> it's System Fs all the way down :|
19:45:51 <hooopy> > sum [1..12]
19:45:53 <lambdabot>   78
19:46:04 <hooopy> inits [1..12]
19:46:15 <Philonous> > inits [1..12]
19:46:16 <hooopy> > inits [1..12]
19:46:17 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
19:46:17 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
19:46:40 <hooopy> > concat (inits [1..12])
19:46:41 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
19:47:12 <ivanm> grrr.... I want a function to have type (a -> b) -> (a -> b), but haddock typesets it as (a -> b) -> a -> b
19:47:19 * Saizan suddenly feels the urge to write goedel's incompleteness theorem in agda
19:47:25 <ivanm> I know they're the same, but I wanted to emphasise that I was manipulating the function :@
19:47:26 <hooopy> > map (sum) (inits [1..12])
19:47:27 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78]
19:47:39 <ivanm> hooopy: no need to add parens around sum there...
19:48:59 <aavogt> > (((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))
19:49:00 <lambdabot>   ()
19:49:03 <hooopy> would you have to have parens around *?
19:49:14 <aavogt> yes hooopy
19:49:18 <ivanm> hooopy: you have to
19:49:26 <ivanm> > map (*) [(1,2), (3,4)]
19:49:27 <ray> :t (*)
19:49:27 <lambdabot>   No instance for (GHC.Num.Num (t, t1))
19:49:27 <lambdabot>    arising from a use of `GHC.Num.*' ...
19:49:28 <lambdabot> forall a. (Num a) => a -> a -> a
19:49:56 <ivanm> anyone know sinelaw's real name (for thanking purposes in a patch)?
19:50:18 <Philonous> I wish ` worked on any expression. Like "[1,2,3] `zipWith (+)` [4,5,6] "
19:50:23 <ivanm> Philonous: yeah
19:50:56 <ivanm> bah, just realised what I did wrong in that map function...
19:50:58 <ivanm> @type map (*)
19:50:59 <lambdabot> forall a. (Num a) => [a] -> [a -> a]
19:51:04 * hackagebot upload: OSM 0.2 - Parse OpenStreetMap files (TonyMorris)
19:51:11 <ivanm> dibblego: cool
19:51:25 <ivanm> so when are you going to add path-finding support? :p
19:52:12 <dibblego> when someone writes it -- I've written Vincenty's direct/inverse geodetic algorithms, which will go up there some day soon
19:53:45 <dibblego> next is parsing GPX files though
19:58:42 <Gracenotes> Philonous: would you allow nesting?
20:00:13 <Gracenotes> e.g., [3] `zipWith (`kitty` food)` [4]
20:00:53 <Veinor> so that would do zipWith (`kitty` food) [3] [4]
20:01:32 <Gracenotes> to completely eliminate, (flip kitty food)
20:01:44 <aavogt> I would do    [kitty 3 food 4]
20:02:32 <aavogt> I think that level of nesting could be somewhat confusing
20:02:34 <Gracenotes> but, [3] `zipWith `kitty` food` [4] would be: food (zipWith [3] kitty) [4]. it is currently.
20:02:52 <Gracenotes> only different being the parens
20:02:55 <Gracenotes> ence
20:03:30 <aavogt> Gracenotes: what do you mean, currently it's a parse error?
20:04:47 <Gracenotes> er. it is? maybe the whitespace is not to be swept under the rug here
20:04:50 <ivanm> preflex: seen sinelaw
20:04:50 <preflex>  sinelaw was last seen on #haskell 5 hours, 47 minutes and 45 seconds ago, saying: conal, i really appreciate that, great
20:05:00 <kpreid> what I would do is allow only parenthesized expressions in ``
20:05:10 <kpreid> then you remove any appearance of ambiguous nesting
20:06:43 <Gracenotes> they are like quotes, so there's not exactly much nesting anyway
20:10:08 <ivanm> @ask sinelaw I've pushed a patch that does unique IDs for multiple edges + manual augmentation support (and it seems to work from my quick tests).  See if you're happy with it.  Also, can I have your real name to put into the Changelog?
20:10:08 <lambdabot> Consider it noted.
20:12:11 <DarthShrine> I'm writing a simple program to sort 10^6 numbers by their absolute value. I have http://pastie.org/755313 so far (excuse my inability to use $ and . properly), but it's exceptionally slow. Could it be an issue in the I/O stage?
20:14:40 <ivanm> DarthShrine: well, first of all, your lambda function is just compare `on` abs
20:14:46 <Cale> DarthShrine: Well, possibly, but you could also prevent from re-evaluating the absolute values
20:14:46 <ivanm> (so that's a stylistic thing)
20:14:57 <Cale> You probably want to replace it anyway
20:14:58 <ivanm> but yeah, as Cale suggests, do a schwarzian transform
20:15:12 <DarthShrine> ivanm: I'm a complete noob, so I have no idea about that stuff.
20:15:26 <ivanm> you could probably cheat anyway...
20:15:33 <Cale> map snd . sortBy (comparing fst) . map (\x -> (abs x, x)) $ unsorted
20:15:39 <ivanm> rather than read/abs/show, try doing a direct comparison of the raw String
20:15:40 <Cale> something like that
20:15:54 <Cale> ivanm: whaaat
20:16:15 <ivanm> absString ('-':str) = str; absString str = str
20:16:27 <ivanm> Cale: he's doing comparisons of string representations of Ints
20:16:38 <ivanm> oh, wait, that might not work...
20:16:46 <ivanm> > "123" > "23"
20:16:46 <lambdabot>   False
20:16:52 <ivanm> bah, forget that idea then
20:17:01 * ivanm can never remember list comparison rules
20:17:04 <ivanm> @src [] compare
20:17:04 <lambdabot> Source not found. My brain just exploded
20:17:04 <Cale> right, it's still a numeric comparison
20:17:14 <ivanm> yeah
20:17:30 <ivanm> since you're doing read, you probably won't get any benefits of trying to use a bytestring or something
20:19:38 <Gracenotes> list comparison is element-wise
20:19:47 <ivanm> yeah, I get that
20:19:57 <ivanm> for some reason I thought longer lists were larger than shorter lists
20:20:03 <Gracenotes> excellent (!!)
20:20:05 <ivanm> of course, there's no good way of doing such a comparison
20:20:36 <aavogt> > sort (mconcat $ map compare [(`on` length),(`on` id)]) ["123","23","9"]
20:20:37 <lambdabot>   Couldn't match expected type `[a]'
20:20:37 <lambdabot>         against inferred type `GHC.Types...
20:20:41 <aavogt> > sortBy (mconcat $ map compare [(`on` length),(`on` id)]) ["123","23","9"]
20:20:42 <lambdabot>   Couldn't match expected type `[a]'
20:20:43 <lambdabot>         against inferred type `GHC.Types...
20:20:55 <ivanm> can anyone suggest a module name I can use for my graphviz library which distinguishes my types that don't have a specific ordering to those I already have (that _do_ have a specific order)?
20:20:57 <Gracenotes> aren't they? so long as: and $ zipWith (==) xs ys
20:21:05 <ivanm> calling it Data.GraphViz.Types.Unordered seems weird :s
20:21:13 <aavogt> > sortBy ((compare `on` length) `mappend` compare) ["123","23","9"]
20:21:14 <lambdabot>   ["9","23","123"]
20:21:20 <SamB_XP_> Gracenotes: yes, when all else is equal, the longer ones are greater, true ;-P
20:21:26 <ivanm> OK, there's no _efficient_ way of doing such a comparison
20:21:46 <aavogt> though that doesn't work if you have decimal places
20:21:56 <DarthShrine> They're all integers.
20:21:58 <Gracenotes> the intuitive grasp of where two strings fit in a dictionary holds here. at least, that is something I just made up that I think is true.
20:23:07 <aavogt> > sortBy (on compare length `mappend` compare) ["123","23","9","0123"]
20:23:08 <lambdabot>   ["9","23","123","0123"]
20:24:04 <Gracenotes> on compare == comparing... from Data.Ord
20:24:21 <Gracenotes> oh. goodness.
20:24:40 <aavogt> I don't like comparing
20:25:00 <Gracenotes> well, you do save a character
20:25:10 <SamB_XP_> and a pair of parens, likely
20:25:15 <hooopy> > sum [1..12]
20:25:16 <lambdabot>   78
20:25:48 <aavogt> and then there is less to think about if you can use    on (==)
20:25:54 <aavogt> @hoogle equating
20:25:54 <lambdabot> No results found
20:26:09 <aavogt> @hoogle multiplying
20:26:09 <lambdabot> No results found
20:26:16 <aavogt> @hoogle adding
20:26:16 <lambdabot> Text.Html cellpadding :: Int -> HtmlAttr
20:26:16 <lambdabot> Text.XHtml.Frameset cellpadding :: Int -> HtmlAttr
20:26:16 <lambdabot> Text.XHtml.Strict cellpadding :: Int -> HtmlAttr
20:27:34 <hooopy> > [ sum[1..x] | x <- [1..12]]
20:27:37 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78]
20:28:01 <Gracenotes> seems justified enough to me... it is a highly common use case which functions *in the library* necessitate. namely, the *by functions
20:29:26 <sauf> > let a = 0:1:zipWith (-) (map ((+1).(*2)) (tail a)) a in take 12 a
20:29:27 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66]
20:29:43 <SamB_XP_> comparing also came before on, and it works well with the english ;-)
20:30:19 <aavogt> > scanl1 (+) [0..]
20:30:20 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
20:31:02 <aavogt> > scanl1 (+) $ scanl1 (+) [0..]
20:31:03 <lambdabot>   [0,1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,154...
20:31:46 <sauf> > let a = 1:0:zipWith (-) (map ((+1).(*2)) (tail a)) a in take 12 a
20:31:48 <lambdabot>   [1,0,0,1,3,6,10,15,21,28,36,45]
20:31:57 <aavogt> > map (take 6) $ iterate (scanl1 (+)) [0..]
20:31:59 <lambdabot>   [[0,1,2,3,4,5],[0,1,3,6,10,15],[0,1,4,10,20,35],[0,1,5,15,35,70],[0,1,6,21,...
20:34:57 <sauf> > scanl1 (*) [1..]
20:34:58 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
20:35:34 <sauf> @type scanl1
20:35:35 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
20:36:02 <sauf> @type scanl
20:36:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:36:42 <sauf> > scanl (*)(-1) [1..]
20:36:43 <lambdabot>   [-1,-1,-2,-6,-24,-120,-720,-5040,-40320,-362880,-3628800,-39916800,-4790016...
20:48:00 <hiptobecubic> 'learnyouahaskell' is kicking my ass
20:48:31 <hiptobecubic> I was doing find until it got to reimplementing map with foldl
20:48:34 <hiptobecubic> fine*
20:52:27 <aavogt> > let mp f = foldl (\x -> (++x) . return . f) [] in mp succ [1..10]
20:52:28 <lambdabot>   [11,10,9,8,7,6,5,4,3,2]
20:52:47 <aavogt> > let mp f = foldl (\x -> (x++) . return . f) [] in mp succ [1..10]
20:52:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
20:53:26 <aavogt> or is there a proper efficient way to do it?
20:53:34 <aavogt> (this is hiptobecubic's problem)
20:53:55 <hiptobecubic> What?
20:54:02 <aavogt> > let mp f = foldl (\x -> (x++) . return . f) [] in mp f [x,y,z,w] :: Expr
20:54:04 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
20:54:04 <lambdabot>         against inferred ...
20:54:10 <hiptobecubic> What is the quetion?
20:54:35 <aavogt> can map be written more efficiently in terms of foldl than that
20:54:59 <hiptobecubic> aavogt, give me a minute to think. I'm new :)
20:55:04 <aavogt> notice that the accumulating parameter is prepended
20:55:11 <aavogt> @src (++)
20:55:12 <lambdabot> []     ++ ys = ys
20:55:12 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:55:12 <lambdabot> -- OR
20:55:12 <lambdabot> xs ++ ys = foldr (:) ys xs
20:55:28 <aavogt> if you have to do that once for each element of your list
20:55:45 <aavogt> and that operation takes time proportional to the length of how much has been accumulated
20:55:51 <aavogt> if you count that up, and round up
20:56:01 <aavogt> that's  O(n^2) or something
20:56:53 <sauf> > let map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs in map' succ [1..10]
20:56:53 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
20:56:58 <sauf> in the book
20:57:58 <aavogt> yeah, same as I wrote
20:58:17 <sauf> 2 arguments instead of one
20:58:40 <aavogt> @unpl (\x -> (x++) . return . f)
20:58:41 <lambdabot> (\ x d -> x ++ (return (f d)))
20:59:25 <hiptobecubic> > let map' f = foldr (\acc x -> f x : acc) [] xs in map' (*-1) [1..5]
20:59:26 <lambdabot>   Not in scope: `xs'Not in scope: `*-'
20:59:28 <hiptobecubic> balls
20:59:31 <sauf> seems the same !
20:59:38 <hiptobecubic> > let map' f xs = foldr (\acc x -> f x : acc) [] xs in map' (*-1) [1..5]
20:59:40 <lambdabot>   Not in scope: `*-'
20:59:52 <hiptobecubic> > let map' f xs = foldr (\acc x -> f x : acc) [] xs in map' (*(-1)) [1..5]
20:59:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
20:59:57 <hiptobecubic> :D
21:00:57 <hiptobecubic> > let map' f xs = foldr (\acc x -> f x : acc) [] xs in map' (* (-1)) [1..5]
21:00:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:01:51 <hiptobecubic> > let map' f xs = foldr (\x acc -> f x : acc) [] xs in map' (* (-1)) [1..5]
21:01:52 <lambdabot>   [-1,-2,-3,-4,-5]
21:01:55 <hiptobecubic> There we go
21:02:32 <gwern> sjanssen: if the lists are evaluated and then cached, then only one invocation should take the hit; the other 999 invocations would  sort like normal
21:03:07 <gwern> sjanssen: and if *you* can figure out how to make criterion work with IO [Int] and IO String, feel free to patch it
21:03:25 <hiptobecubic> > let map' f = foldr (\x acc -> f x : acc) []
21:03:26 <lambdabot>   not an expression: `let map' f = foldr (\x acc -> f x : acc) []'
21:03:27 <gwern> as it is, I spent quite enough time on it that I don't want to deal with monad and criterion internals crap
21:07:59 <gwern> sjanssen: also, why would defining them in the same module invalidate my numbers? surely the cross-module pessimizations wouldn't affect ghc and yhc sort differently
21:10:43 <sauf> > let map' f = foldr (\x acc -> f x : acc) [] in map succ [1..10]
21:10:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
21:10:57 <sauf> > let map' f = foldr (\x acc -> f x : acc) [] in map' succ [1..10]
21:10:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
21:13:22 <trie> Hmm now both Hoogle and Hayoo are down. An other API search mechanism that I am missing?
21:14:07 <hiptobecubic> This hurts
21:14:43 <aavogt> > let id = foldr (:) [] in id [1..10]
21:14:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:15:39 <hiptobecubic> > let rev' = foldr (flip (:)) [] in rev' [1..10]
21:15:40 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
21:17:02 <hiptobecubic> > let rev' = foldr (:) [] in rev' [1..10]
21:17:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:17:09 <hiptobecubic> > let rev' = foldr flip (:) [] in rev' [1..10]
21:17:10 <lambdabot>   []->
21:17:11 <lambdabot>    [[1,2,3,4,5,6,7,8,9,10]]
21:17:11 <lambdabot>  [[]]->
21:17:11 <lambdabot>    [[1,2,3,4,5,6,7,8,9,10],[]]
21:17:11 <lambdabot>  [[...
21:17:39 <hiptobecubic> > let rev' = foldr $ flip (:) [] in rev' [1..10]
21:17:40 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
21:18:01 <hiptobecubic> > let rev' = foldr (flip (:)) [] in rev' [1..10]
21:18:02 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
21:18:08 <hiptobecubic> I don't see the problem with that one
21:18:32 <hiptobecubic> > :t (:)
21:18:33 <lambdabot>   <no location info>: parse error on input `:'
21:18:58 <hiptobecubic> > let rev' = foldl (flip (:)) [] in rev' [1..10]
21:18:59 <aavogt> > "a" : 'a' -- same problem as here
21:18:59 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
21:19:00 <lambdabot>         against inferred ...
21:19:00 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:19:30 <hiptobecubic> > let rev' = scanl (flip (:)) [] in rev' [1..5]
21:19:32 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
21:19:35 <sauf> > let rev' = foldr (flip (++) . return) [] in rev' [1..10]n
21:19:35 <lambdabot>   <no location info>: lexical error at character '\DLE'
21:19:44 <aavogt> > let a = undefined in a : head a
21:19:45 <lambdabot>   [* Exception: Prelude.undefined
21:20:00 <aavogt> @type let a = undefined in a : head a
21:20:01 <lambdabot> forall a. [a]
21:20:21 <sauf> > let rev' = foldr (flip (++) . return) [] in rev' [1..10]
21:20:22 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:20:42 <aavogt> @vixen no monomorphism restriction?
21:20:43 <lambdabot> no?
21:20:55 <hiptobecubic> What's the point of the ". return" ?
21:21:04 <dibblego> @type (. return) -- this!
21:21:05 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
21:21:12 <sauf> > let rev' = foldr (flip (++) . (:[])) [] in rev' [1..10]
21:21:13 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:21:27 <aavogt> it's the same as the monkey (:[])
21:21:28 <hiptobecubic> I haven't read about monads yet
21:21:32 <sauf> it is a wrapper
21:21:37 <sauf> sort of
21:22:10 <aavogt> which is the same as writing  [f x]
21:22:18 <sauf> the . is the composition
21:22:28 <tensorpudding> monads are burritos!
21:22:37 <aavogt> provided that you actually name the variables in the last case
21:23:55 <hiptobecubic> > let concat = (\acc x:xs -> x:(concat xs acc)) in concat 'What' 'is going on here?'
21:23:56 <lambdabot>   <no location info>: parse error on input `:'
21:24:08 <hiptobecubic> > let concat = (\acc (x:xs) -> x:(concat xs acc)) in concat 'What' 'is going on here?'
21:24:09 <lambdabot>   <no location info>:
21:24:10 <lambdabot>      lexical error in string/character literal at chara...
21:24:17 * hiptobecubic goes back to ghci
21:36:36 <lowki> does haskell support binary files?
21:36:59 <lowki> er, i'm assuming it's just like ordinary file, but how to pattern match hex ?
21:37:12 <tommd> lowki: You can read binary files in many ways
21:37:19 <tommd> the 'binary' package is the most popular
21:37:24 <Stinger> @faw
21:37:24 <lambdabot> The answer is: Yes! Haskell can do that.
21:37:27 <Stinger> @faq
21:37:27 <lambdabot> The answer is: Yes! Haskell can do that.
21:37:27 <tommd> with 'cereal' as an up-and-coming.
21:37:56 <Stinger> whoa lag :/
21:37:57 <ivanm> tommd: by you?
21:38:16 <tommd> ivanm: by me what?  I didn't write either of those if thats the question.
21:38:26 <ivanm> cereal
21:38:33 <tommd> @hackage cereal
21:38:34 <lambdabot> http://hackage.haskell.org/package/cereal
21:38:36 <ivanm> just wondering how you know about an up-and-coming project ;-)
21:38:49 <ivanm> oh, "up-and-coming" in the sense that it's improving, rather than it will be released soon
21:39:01 <tommd> yes, that's what I ment.
21:39:11 <tommd> Its growing more popular.
21:40:00 <tommd> The Galois folks developed it because 'binary' causing exceptions to permeate their programs didn't make them happy.
21:40:17 <ivanm> I take it cereal started off as a fork of binary?
21:40:31 <tommd> IIRC, yes
21:40:40 <SamB_XP_> hmm, I would have assumed it started around the breakfast table ;-P
21:40:45 <tommd> But it is strict and rather explicit in its errors.
21:40:57 <lispy> tommd: didn't someone say at the pdxfunc it started as a stack of transformers?
21:40:59 <ivanm> SamB_XP_: no, that's were it ended up
21:41:09 <hiptobecubic> >let concat xs ys = flip (foldr (\x acc -> (x:acc))) xs ys in concat "Is this possible" "without using flip or (++)?"
21:41:20 <tommd> lispy: Did they?  I'll take your word for it, I don't quite recall.
21:41:25 <lispy> tommd: certainly the api was based on binary
21:41:37 <lispy> tommd: It's hard for me to recall too :)
21:42:07 <lispy> I recall being hungry and tired at pdxfunc, not a great situation for enhancing memory...
21:42:39 <tommd> So at what point do I have to stop referring to anything from Galois as being done by the "Galois folk"?  Once they pass 100 employees?
21:42:51 <tommd> Or once I know less than 50% of them?
21:43:10 <hiptobecubic> >let concat xs ys = flip (foldr (\x acc -> (x:acc))) xs ys in concat "Is this possible" " without using flip or (++)?"  -- what happened?
21:43:18 <ivanm> heh
21:43:53 <SamB_XP_> tommd: well, when they start having 3- or 4-tier org chart, maybe ;-P
21:44:05 <tommd> Gahhh!
21:44:08 <ivanm> hiptobecubic: put a space after the >
21:44:14 <tommd> Never say "org chart" in my presence!
21:44:16 <hiptobecubic> > let concat xs ys = flip (foldr (\x acc -> (x:acc))) xs ys in concat "Is this possible" " without using flip or (++)?"  -- what happened?
21:44:18 <lambdabot>   "Is this possible without using flip or (++)?"
21:44:22 <hiptobecubic> ivanm, thanks :)
21:44:24 <ivanm> SamB_XP_: so just keep them wide... ;-)
21:44:27 <ivanm> hiptobecubic: no worries
21:44:41 <ivanm> tommd: what other chart comes out of org-mode though? :p
21:44:44 <SamB_XP_> or at least fairly obvious subgroups
21:45:12 <Gracenotes> hiptobecubic: you can always do away with flip with more explicit variables... in this case, just switching them around. concat xs ys = foldr (:) ys xs
21:45:18 <SamB_XP_> tommd: it's one of those things you do in graphviz telling who is working under who
21:45:50 <hiptobecubic> > let concat xs ys = (foldr (\x acc -> (x:acc))) ys xs in concat
21:45:51 <lambdabot>   []->
21:45:51 <lambdabot>    {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
21:45:51 <lambdabot>  [()]->...
21:45:56 <Gracenotes> hiptobecubic: so.. do you sort of get how foldr (:) [] xs always == xs, so long as == is defined?
21:46:07 <ivanm> SamB_XP_: what, pen and paper isn't good enough?
21:46:10 <Gracenotes> I mean, it doesn't bottom out
21:46:22 <SamB_XP_> ivanm: too embarrasing
21:46:34 <SamB_XP_> remember, these people can't draw very well ;-P
21:46:42 <ivanm> heh
21:46:47 <hiptobecubic> Gracenotes, i'm working on it. This is a new way of thinking for me.
21:46:48 <tommd> What people?  People in large organizations?
21:47:15 <hiptobecubic> > let concat xs ys = flip (foldr (\x acc -> (x:acc))) ys xs in concat "Is this possible" " without using flip or (++)?"
21:47:17 <lambdabot>   " without using flip or (++)?Is this possible"
21:47:21 <Gracenotes> hiptobecubic: well, the second argument to foldr, [], is reached at the end of xs.
21:47:28 <tommd> You can always delegate the drawing of the org-chart to the person at the bottom of the org-chart who will contract it out to the lowest bidder.
21:47:28 <ivanm> tommd: technically minded people I believe he's referring to
21:47:34 <ivanm> heh
21:47:48 <Gracenotes> hiptobecubic: you might want to get rid of the flip if it's confusing: concat xs ys = foldr (\x acc -> x:acc) ys xs
21:48:11 <lucidrains> Can anyone recommend a good tutorial to haskell or functional programming in general?
21:48:24 <hiptobecubic> lucidrains, learnyouahaskell.com
21:48:27 <lispy> why foldr (\x acc -> x:acc) and not, foldr (:)
21:48:29 <lucidrains> Can anyone also relate if learning haskell is a good gateway into learning scala or clojure
21:48:40 <Gracenotes> lispy: I have that above, but I only volunteered to get rid of the flip :)
21:48:41 <hiptobecubic> lispy, because i don't know what i'm doing :)
21:48:44 <lucidrains> Thanks hiptobecubic
21:48:50 <lispy> aaaah
21:49:14 <Gracenotes> hiptobecubic: hm.. source substitution can sometimes help. lemme try
21:49:14 <hiptobecubic> lispy, just started f(x) programming yesterday
21:49:21 <Gracenotes> @src foldr
21:49:21 <lambdabot> foldr f z []     = z
21:49:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:49:44 <tensorpudding> foldr up, shipM out
21:49:47 <Gracenotes> now, suppose concat xs ys = foldr (\x acc -> x:acc) ys xs
21:50:24 <Gracenotes> then, substituting the arguments that are not pattern matched (broken down):
21:50:26 <lowki> so i tried it like a string, but didn't work
21:50:28 <Gracenotes> concat (x:xs) = x : concat xs
21:50:31 <Gracenotes> concat [] = ys
21:50:35 <lowki> i want to match with the hex code
21:50:50 <Gracenotes> the x : concat xs comes from \x acc -> x:acc.
21:51:13 <lowki> not sure how to convert string from readFile, to some format, where I could match with hexcodes
21:51:17 <hiptobecubic> Gracenotes, i'm not seeing how the edge case terminates it.
21:51:27 <Gracenotes> in the simple case that xs is empty in concat xs ys, then the result is ys.
21:51:30 <hiptobecubic> Gracenotes, wouldn't that keep tacking ys on it forever?
21:51:45 <hiptobecubic> Gracenotes, oh nevermind i see it
21:51:53 <Gracenotes> if xs is [3], say, then the result will be 3:concat [] = 3:ys
21:52:11 <lispy> lowki: what is the type of hexcodes?
21:52:19 <hiptobecubic> Gracenotes, yes. I'm really enjoying this recursive approach to things that used to be simple :)
21:52:33 <Gracenotes> the idea of foldr is that the acc is calculated based on the result from the rest of the list.
21:52:45 <hiptobecubic> Gracenotes, yes i just read that section
21:52:57 <lispy> :t scanr
21:52:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
21:53:00 <lowki> lispy:  0x89
21:53:10 <lowki> opcodes
21:53:19 <lowki> x86 assembler, i'm making a decompiler
21:54:19 <lispy> lowki: it sounds like you want to open the file in binary mode and then each get the numeric code of each character that is in the file
21:54:22 <lispy> :t ord
21:54:23 <lambdabot> Char -> Int
21:54:41 <lispy> > ord '\u0x89'
21:54:42 <lambdabot>   <no location info>:
21:54:42 <lambdabot>      lexical error in string/character literal at chara...
21:54:43 <Gracenotes> hiptobecubic: ah, good. Now in imperative non-lazy languages like C, you need to calculate the result from the rest first. e.g. concat(xs, ys) { if (xs is empty) return []; tmp = concat(tail xs, ys); return cons(head xs, tmp)}
21:54:49 <tensorpudding> you can think of foldr as taking every (:) and replacing it with your function
21:54:55 <lispy> > chr 0x89
21:54:56 <lambdabot>   '\137'
21:55:02 <lpsmith> hehe,  I just came up with another fun function that has the same type as scanr
21:55:13 <lpsmith> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5562#a5563
21:55:19 <hiptobecubic> Gracenotes, yeah i'm coming from C++ and python/perl so this is quite different.
21:55:33 <lispy> > scanr (:) 'a' "hello"
21:55:33 <lambdabot>   Couldn't match expected type `[a]'
21:55:33 <lambdabot>         against inferred type `GHC.Types...
21:55:44 <lispy> > scanl (:) 'a' "hello"
21:55:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:55:55 <Gracenotes> in Haskell, it is lazily available any time you need it. So if you want the first element of concat [1,2,3] [4,5,6], it gives you 1 straight away, and remembers that it has to do concat [2,3] [4,5,6].
21:56:17 <lispy> :t scanr (:)
21:56:17 <lambdabot> forall a. [a] -> [a] -> [[a]]
21:56:19 <Gracenotes> essentially
21:56:30 <lispy> :t scanr (:) [] "hello"
21:56:31 <lambdabot> [[Char]]
21:56:40 <lispy> > scanr (:) [] "hello"
21:56:41 <lambdabot>   ["hello","ello","llo","lo","o",""]
21:56:55 <lispy> > scanl (:) [] "hello"
21:56:56 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
21:56:57 <Gracenotes> and, er, technically, this is (++) we're talking about; concat combines a list of lists
21:57:14 <lowki> lispy: o
21:57:28 <lispy> I guess, tails = scanr (:) []
21:57:45 <hiptobecubic> :t (:)
21:57:46 <lambdabot> forall a. a -> [a] -> [a]
21:57:52 <lispy> ?check \x -> tails x == scanr (:) [] (x:: String)
21:57:53 <lambdabot>   "OK, passed 500 tests."
21:58:07 <aavogt> ?src tails
21:58:07 <lambdabot> tails []         = [[]]
21:58:08 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
21:58:17 <hiptobecubic> ,,, what?
21:58:20 <lunabot>  luna: parse error on input `what'
21:58:29 <Gracenotes> what what?
21:59:23 <Gracenotes> @src []
21:59:24 <lambdabot> data [] a = [] | a : [a]
21:59:25 <hiptobecubic> What does lunabot do?
21:59:31 <hiptobecubic> , help
21:59:35 <lunabot>  type of an expression:      , [$ty| \x -> x |]
21:59:35 <lunabot>  get info for a type/class:  , src ''Monad
21:59:35 <lunabot>  get info for a var/con:     , src 'fix
21:59:36 <tensorpudding> lunabot does crazy stuff
21:59:38 <Gracenotes> lambdabot wannabe
21:59:47 <tensorpudding> @botsnack
21:59:47 <lunabot>  :o
21:59:47 <lambdabot> :)
22:00:01 <lispy> ?src scanr
22:00:01 <lambdabot> scanr _ q0 []     =  [q0]
22:00:01 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
22:00:01 <lambdabot>     where qs@(q:_) = scanr f q0 xs
22:00:02 <Gracenotes> certainly just kidding! more specialized, Haskell-oriented, polite
22:00:08 <aavogt> @uptime
22:00:08 <lambdabot> uptime: 2d 9h 35m 28s, longest uptime: 1m 10d 23h 44m 29s
22:00:18 <Gracenotes> vixen needs to learn some manners sometimes
22:00:20 <aavogt> , uptime
22:00:20 <hiptobecubic> ,src scanr
22:00:21 <lunabot>  luna: Not in scope: `uptime'
22:00:21 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
22:00:30 <lispy> ?vixen are you rude to newbies?
22:00:30 <lambdabot> i truely am
22:00:35 <hiptobecubic> , src scanr
22:00:36 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
22:00:37 <aavogt> , src 'scanr
22:00:40 <lunabot>  scanr :: forall a b . (a -> b -> b) -> b -> [a] -> [b]
22:00:41 <hiptobecubic> oh
22:01:10 <lispy> ?src scanl
22:01:10 <lambdabot> scanl f q ls = q : case ls of
22:01:10 <lambdabot>     []   -> []
22:01:10 <lambdabot>     x:xs -> scanl f (f q x) xs
22:01:19 <aavogt> the leading quote is template haskell stuff
22:01:26 <lispy> :t scanl (:)
22:01:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
22:01:28 <lambdabot>       Expected type: a
22:01:28 <lambdabot>       Inferred type: [a]
22:01:36 <Gracenotes> flip it about
22:01:37 <aavogt> to get the name associated with that value
22:01:43 <lispy> :t scanl (flip (:))
22:01:44 <lambdabot> forall b. [b] -> [b] -> [[b]]
22:01:47 <lispy> good point
22:01:53 <lispy> But now it becomes scanr?
22:02:04 <lispy> > scanl (flip (:)) [] "hello"
22:02:04 <tensorpudding> @src scanl
22:02:05 <lambdabot> scanl f q ls = q : case ls of
22:02:05 <lambdabot>     []   -> []
22:02:05 <lambdabot>     x:xs -> scanl f (f q x) xs
22:02:05 <lambdabot>   ["","h","eh","leh","lleh","olleh"]
22:02:16 <lispy> oh, in reverse
22:02:19 <lispy> That makes sense
22:02:20 <lpsmith> @let interleave = loop where { loop [] ys = ys ; loop (x:xs) ys = x : loop ys xs }
22:02:21 <lambdabot>  <local>:2:0:
22:02:21 <lambdabot>      Multiple declarations of `L.interleave'
22:02:21 <lambdabot>      Declared at: ...
22:03:36 <Gracenotes> for normal form-able lists, (foldr f z xs) tends to == reverse (foldl (flip f) z xs)
22:03:58 <lpsmith> @let powerfoldr f b = fold where { fold [] = [b] ; fold (a:as) = interleave bs (map (f a) bs) where bs = fold as }
22:03:58 <lambdabot>  <local>:2:60:
22:03:58 <lambdabot>      Ambiguous occurrence `interleave'
22:03:58 <lambdabot>      It could refer to ...
22:04:11 <lpsmith> @let interleave' = loop where { loop [] ys = ys ; loop (x:xs) ys = x : loop ys xs }
22:04:12 <lambdabot>  Defined.
22:04:18 <lpsmith> @let powerfoldr f b = fold where { fold [] = [b] ; fold (a:as) = interleave' bs (map (f a) bs) where bs = fold as }
22:04:19 <lambdabot>  Defined.
22:04:33 <lpsmith> > powerfoldr (:) [] "hello"
22:04:34 <lambdabot>   ["","h","e","he","l","hl","el","hel","l","hl","el","hel","ll","hll","ell","...
22:04:36 <hiptobecubic> Is there a way to see source from withing ghci
22:05:04 <lpsmith> > powerfoldr (:) [] "abc"
22:05:05 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
22:05:39 <lowki> lispy: excellent that ord really did the trick :D
22:06:14 <lispy> lowki: cool.  There are ways to specify values in hex, but I always have to look them up
22:06:25 <lispy> ?hoogle Int -> Char
22:06:25 <lambdabot> Data.Char chr :: Int -> Char
22:06:25 <lambdabot> Data.Char intToDigit :: Int -> Char
22:06:25 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
22:06:27 <lowki> lispy: btw how to convert int to hex string ?
22:06:29 <aavogt> > powerfoldr (+) 0 [1,2,4,8]
22:06:30 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
22:06:57 <lispy> lowki: there is a printf library that likely does it, but there is also showHex if I recall correctly
22:07:00 <lispy> ?hoogle showHex
22:07:00 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
22:07:11 <lispy> > showHex 0x34
22:07:12 <lambdabot>   ""->
22:07:12 <lambdabot>    "34"
22:07:12 <lambdabot>  "a"->
22:07:12 <lambdabot>    "34a"
22:07:12 <lambdabot>  "aa"->
22:07:14 <lambdabot> [5 @more lines]
22:07:36 <aavogt> lpsmith: neat stuff with powerfoldr
22:07:58 <lispy> ?hoogle hex
22:07:58 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
22:07:58 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
22:07:58 <lambdabot> Text.Parsec.Char hexDigit :: Stream s m Char => ParsecT s u m Char
22:08:53 <aavogt> > powerfoldr (*) 1 [2,3,5,7]
22:08:54 <lambdabot>   [1,2,3,6,5,10,15,30,7,14,21,42,35,70,105,210]
22:09:27 <lpsmith> aavogt:  it's a new toy for me :-)
22:10:33 <lispy> > showHex 0x34 ""
22:10:34 <lambdabot>   "34"
22:10:48 <lispy> I don't know what ShowS is
22:10:56 <lispy> > showHex 34 ""
22:10:56 <lambdabot>   "22"
22:11:09 <BMeph> ShowS = String -> String
22:12:26 <lowki> lispy: excellent :D
22:12:31 <lowki> decompiler in commission
22:12:37 <lowki> or working
22:12:49 <lispy> lowki: http://hackage.haskell.org/package/hex
22:13:08 <Gracenotes> hiptobecubic: not quite :/
22:13:53 <lispy> lowki: eventually you will likely realize that the file has a format to it and you'll want to write a binary parser.  Take a look at Cereal or Data.Binary when you get to that point.
22:13:58 <Gracenotes> lambdabot's functionality comes from a precompiled source
22:14:20 <Gracenotes> er, that is, an index that was manually put together
22:15:30 <lispy> lowki: reading in the instructions and decoding them is relatively easy.  The hard part of a decompiler is coming up with clever heuristics to reconstruct a human readable source program
22:15:49 <lispy> But maybe that's the fun part you want to work on?
22:16:40 <drhodes> oin #occam
22:17:39 <lowki> lispy: i'm working on understanding machine language,
22:17:58 <lowki> i'm still working on a human speakable programming language, and compiler
22:18:13 <lispy> lowki: it's not where I would start but I respect your gumption
22:18:25 <lowki> well i started many years ago :)
22:18:32 <lowki> i just got this part now
22:18:34 <lowki> lol
22:18:41 <lispy> lowki: Last time I was writing a compiler I had gcc generate the assembly code to a file and then I studied that :)
22:18:50 <lowki> what's the way of marking number as oct ?
22:19:07 <lispy> > o123
22:19:08 <lambdabot>   Not in scope: `o123'
22:19:11 <lispy> > 0123
22:19:12 <lambdabot>   123
22:19:15 <medfly> :)
22:19:17 <lispy> > 09
22:19:17 <lambdabot>   9
22:19:22 <lispy> Hmm...I forgot
22:19:26 <lowki> lispy: i'm using nasm to generate the code, and do study it in hexeditor, but figure might as well make decompiler
22:19:28 <lispy> The H98 report covers this
22:20:23 <medfly> > 0o9
22:20:23 <lispy> I was thinking octal literals started with o, but I'm mistaken it seems
22:20:24 <lambdabot>   Not in scope: `o9'
22:20:26 <medfly> dang.
22:20:44 <ivanm> > 0x203
22:20:45 <lambdabot>   515
22:20:51 <ivanm> oh, wait, that's hex
22:20:52 <lowki> hex
22:20:55 <ivanm> yeah
22:21:00 <medfly> > 0o9
22:21:01 <lambdabot>   Not in scope: `o9'
22:21:05 <medfly> no good
22:21:05 <ivanm> not sure if there is a way of having a literal octal...
22:21:07 <SamB_XP_> > 09
22:21:08 <lambdabot>   9
22:21:11 <SamB_XP_> > 0009
22:21:12 <lambdabot>   9
22:21:13 <ivanm> SamB_XP_: heh
22:21:16 <SamB_XP_> > 0055
22:21:18 <lambdabot>   55
22:21:22 <medfly> > 0O9
22:21:23 <lambdabot>   Not in scope: data constructor `O9'
22:21:24 <SamB_XP_> I guess not
22:21:25 <medfly> ...
22:21:34 <ivanm> apparently it's 0o ...
22:21:35 <medfly> it's on the report
22:21:37 <ivanm> > 0o23
22:21:37 <lambdabot>   19
22:21:38 <stroan> < 0o10
22:21:40 <ivanm> ^^
22:21:45 <medfly> WHY DOES IT WORK FOR YOU!
22:21:47 <SamB_XP_> 0o0
22:21:50 <ivanm> medfly: 9 isn't octal ;-)
22:21:53 <stroan> 9 is not octal
22:22:02 <medfly> oh, right.
22:22:08 <SamB_XP_> yeah, I was going for a syntax error
22:22:14 <medfly> me too.
22:22:24 <lowki> > 0o13
22:22:25 <lambdabot>   11
22:22:30 <lowki> kk :)
22:22:30 <ivanm> medfly: excuses, excuses ;-)
22:22:31 <lowki> thanks
22:22:52 <medfly> :-(
22:22:56 <ivanm> so, is 0b the prefix for binary then? ;-)
22:22:58 <medfly> yes. I suck horribly.
22:22:59 <lispy> Oh yeah, when I tried 09 I was trying to get an error to be sure it was reading it as oct or not :)
22:23:00 <ivanm> > 0b101
22:23:01 <lambdabot>   Not in scope: `b101'
22:23:03 <ivanm> :(
22:23:34 <ivanm> > let a = 2 in 0a
22:23:34 <lambdabot>   Ambiguous type variable `t' in the constraint:
22:23:35 <lambdabot>    `GHC.Num.Num t' arising f...
22:23:46 <ivanm> trying to work out that weird scope error...
22:23:54 <ivanm> > let a = 2 :: Int in 0a
22:23:55 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> a))
22:23:56 <lambdabot>    arising from the lite...
22:24:06 <ivanm> @type 0a
22:24:07 <lambdabot> forall t. (Num (Expr -> t)) => t
22:24:13 <ivanm> @type a
22:24:14 <lambdabot> Expr
22:24:18 <ivanm> weird...
22:24:22 <ivanm> > let a = 2 :: Int in 0a 4
22:24:23 <lambdabot>   Ambiguous type variable `t' in the constraint:
22:24:23 <lambdabot>    `GHC.Num.Num t' arising f...
22:24:27 <lispy> it's a lambdabot-ism
22:24:31 <ivanm> ahhh
22:24:46 <lispy> Just like (.) is a Caleskell ism
22:24:50 <lispy> :t (.)
22:24:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:24:54 <ivanm> OK, trying it in ghci gives "No instance for (Num (Int -> t))"
22:24:56 <lispy> That's not how Haskell defines it
22:24:57 <ivanm> @slap Caleskell
22:24:58 * lambdabot moulds Caleskell into a delicous cookie, and places it in her oven
22:25:10 <ivanm> @botsnack
22:25:10 <lunabot>  :o
22:25:10 <lambdabot> :)
22:25:17 <drhodes> can haskell do base 1?
22:25:21 <ivanm> lunabot: just shut up and eat your caleskell cookie
22:25:24 <lispy> ?vixen do you like having Caleskell cookies in your oven?
22:25:25 <lambdabot> sure, i definitely don't hate
22:25:31 <lispy> mmHHmmmm
22:25:31 <ivanm> drhodes: I hope you're not serious...
22:25:48 <drhodes> serious as a salamander
22:25:51 <stroan> > 0000000
22:25:53 <lambdabot>   0
22:25:53 <lispy> drhodes: using unit and lists
22:25:54 <stroan> yup
22:26:13 <lispy> > length [(),(),()]
22:26:13 <lambdabot>   3
22:26:33 <lpsmith> or just define    data N = Z | S N
22:26:53 <medfly> take 3 . repeat $ ()
22:26:57 <medfly> > take 3 . repeat $ ()
22:26:58 <lambdabot>   [(),(),()]
22:27:07 <lpsmith> but then you have to define functions to work on it yourself
22:27:27 <lispy> lpsmith: make an instance for Num :)
22:27:31 <medfly> we were working the other way around!
22:27:38 <drhodes> but does it put the slash through on multiples of 5, all the cavemen are going to be ripped if it can't do slashes
22:27:50 <medfly> hahaha
22:28:27 * lispy hacks on darcs
22:29:10 <lispy> Making it load the bodies of patches very explicitly so that it's not allowed to hold them in memory except to do some very specific task then be done with it.
22:29:30 <lispy> The goal is to improve memory performance
22:30:02 <lpsmith> I'm impressed,  darcs 2.3.1 seems to fetch a fair bit faster over the network...
22:30:19 <lispy> 2.3.1 has the starts of Petr Rockai's stuff
22:30:22 <napping> It's easy to compile together a group of functions that share a suffix
22:30:27 <lispy> The hashed-storage code from his GSoC project
22:30:34 <napping> what about functions that share a prefix?
22:30:53 <lispy> napping: what do you mean by prefix/suffix?
22:30:56 <lispy> The types?
22:31:04 <napping> like, f2 = f2 >> a1; f3 = f2 >> a3; f4 = f3 >> m4
22:31:54 <napping> if it were the other way around you could just compile m1 >> m2 >> m3 >> m4 with four entry points and one return
22:36:19 <lowki> what's the opposite of ord?
22:36:54 <lispy> lowki: What is the type you need?
22:37:08 <lowki> chr :) i hoogled it
22:37:14 <lispy> Cool!
22:37:24 <lispy> I was going to recommend you use hoogle once you know the type :)
22:40:05 <Veinor> hoogle is sexy.
22:40:35 <lispy> I nominate hoogle for the title of Cap'n Sexy Pants
22:44:07 <merehap> I'll admit that I'm confused as to why ord and chr exist as they are just type limited versions of fromEnum and toEnum...
22:44:46 <napping> there are a lot of things like that
22:44:52 <napping> map is just a special case of fmap
22:45:00 <napping> ++ of mappend, for example
22:45:24 <merehap> at least ++ is a switch to infix and is shorter...
22:46:02 <merehap> map probably isn't justified either, though the list is a quite well known type so it might be
22:46:14 <lispy> I suspect the Prelude was designed to be at least partially useful for teaching haskell
22:46:17 <merehap> there doesn't seem to be anything that is so special about Char
22:46:20 <Veinor> yeah, that
22:46:50 <Veinor> bah. i went to download and read theorems for free and I only got a .ps :(
22:47:01 <merehap> huh, I didn't even know ord and chr existed until recently, though I've know about toEnum and fromEnum for quite a while
22:47:15 <shepheb> Veinor: ps2pdf?
22:47:24 <Veinor> on windows atm :(
22:47:46 <lispy> Veinor: does citeseer have it?  They usually have both formats
22:47:51 <SamB_XP> an atm running windows ?
22:47:54 <SamB_XP> crazy shit!
22:47:56 <merehap> I'm not sure if those functions met their purpose of making Haskell easier for the beginner since that is the case
22:48:09 <Veinor> they do?
22:48:13 <Veinor> SamB_XP: most of them do!
22:48:25 <Veinor> ah, didn't see that pdf link
22:48:25 <merehap> well, seeing lots of blue screens isn't so crazy after the first few times...
22:48:27 <SamB_XP> Veinor: even crazier!
22:49:22 <Veinor> now I just need to download/install a pdf reader
22:50:18 <SamB_XP> what kind of crazy installer doesn't put adobe reader on a windows system ?
22:52:56 <Gracenotes> foxit tis good
22:54:27 <Gracenotes> personally I love evince here on Ubuntu... it may be simple, but it manages to meet my needs quite outstandingly, although I do wonder what it's doing when it says it's rendering a page
22:55:48 <clarkb> okular is very nice
22:56:06 <clarkb> much better than evince imp
22:56:14 <clarkb> s/imp/imo/
22:56:58 <tommd> clarkb: Is that your NN package I saw?
22:57:11 <clarkb> tommd: no
22:57:12 <medfly> Gracenotes: it takes another sip of your blood
22:57:12 <lispy> What library is this? * Missing C libraries: icuuc, icuuc
22:57:21 <lispy> Cabal-install is all up in arms about it
22:57:24 <clarkb> mine is ugly and would need extreme refactoring before I would put it out in public
22:57:26 <lispy> But, I can't find it in apt
22:57:40 <Gracenotes> clarkb: nice integration into gnome?
22:58:00 <clarkb> Gracenotes: it is a Qt app
22:58:05 <clarkb> so yes and no
22:58:05 <Gracenotes> medfly: it's okay, I have enough vitals to spare, biological and spiritual
22:58:11 <tommd> clarkb: You might want to checkout the latest one - linked on r/haskell - sounds like someone went through some polish effort.
22:58:13 <Gracenotes> eeek... Qt in GNOME... fugly :/
22:58:28 <clarkb> Gracenotes: but the problem is Gnome
22:58:36 <clarkb> switch to xmonad then you dont care anymore :)
22:58:45 <Veinor> a lot of people I know use xmonad
22:59:04 <Veinor> how resource-y is it?
22:59:07 <clarkb> lol
22:59:09 <pikhq> Gracenotes: Qt 4 in GNOME renders via GTK...
22:59:22 <Gracenotes> I am susceptible to the minimalist, but not totally minimalist, way Gnome looks.
22:59:32 <clarkb> Gnome is minimalist?
22:59:44 <pikhq> I thought Gnome was the epitome of bloat.
22:59:45 <Veinor> if my that you mean minimal featurist, dohohoho
22:59:49 <Veinor> *by
22:59:51 <pikhq> Featureless bloat.
22:59:51 <clarkb> Veinor: other than needing ghc (which I assume isnt an issue because you are in here) it is tiny
23:00:02 <Veinor> clarkb: I mean processor-wise.
23:00:06 <Gracenotes> not feature-wise, for sure. But in appearance. Maybe "sleek" is a better term?
23:00:06 <clarkb> still tiny
23:00:13 <clarkb> it sips at cpu
23:00:15 <Veinor> awesome. I might switch then
23:00:38 <Veinor> if only because every cycle counts on the netbook. same reason I use chrome.
23:00:55 <Gracenotes> pikhq: okay, I'll blame GTK. Qt still doesn't seem very smooth.
23:01:05 <lispy> apt-get install libicu-dev for anyone following along at home.
23:01:25 <Veinor> I hate the current implementation of notify-osd
23:01:46 <Veinor> literally no customization and it has some atrocious behavior
23:02:26 <napping> what does it do wrong?
23:02:48 <Veinor> you can't have multiple notifications visible at the same time, and there's no way to specify how long one should be displayed
23:03:10 <Gracenotes> okay, yeah, notify seems to have unimproved in the latest version, looks like.
23:03:35 <Veinor> also, they don't start in the upper-right corner anymore, they leave room for the async volume notifications instead of the old pushdown behavior
23:03:44 <Veinor> which I an others think looks ugly as hell
23:04:54 <Veinor> but apparently, according to shuttleworth, is a 'feature'
23:05:01 <Gracenotes> I do like the async volume/brightness/general laptop notification. But you'd think they could be more flexible, maybe
23:05:05 <Gracenotes> with the layout
23:05:13 <Veinor> I want to have multiple notifications visible at the same time.
23:05:16 <Veinor> basically, I want growl
23:05:32 <napping> have you seen Eric Horvitz's stuff?
23:06:08 <Veinor> no, link?
23:08:32 <napping> he's at MSR, easy to findL http://www.google.com/search?q=eric+horvitz
23:09:29 <Veinor> I mean, what is it exactly?
23:09:46 <napping> oh, he does research on notification systems, among other things
23:10:04 <napping> when it's best to interrupt you or not, different ways of displaying thing, etc
23:13:18 <Veinor> ah, neat
23:31:21 <povman> Lonely, cheer me up.
23:32:12 <elly> lambdabot: can haskell do that?
23:32:54 <lispy> ?faq can Haskell cheer up da povman?
23:32:54 <lambdabot> The answer is: Yes! Haskell can do that.
23:32:57 <lispy> Woot!
23:33:05 <povman> yay!
23:33:15 <clarkb> working already
23:33:28 <povman> Now I have enough motivation to create a human.
23:36:02 <medfly> tmi
23:37:59 <povman> (in haskell)
23:38:22 <lispy> The Haskell9000
23:38:35 <lispy> I think Disney does research in this area
23:47:12 <Mark1> what would be the easiest way to get the longest string in a list?
23:48:38 <povman> maximum . map length
23:48:57 <povman> > (maximum . map length) ["abc", "asdf", "c"]
23:48:58 <lambdabot>   4
23:49:02 <povman> oh
23:49:24 <Mark1> right, i had tried that, and of course got that result
23:49:39 <Mark1> the other thing i hoped would work was foldl1 max
23:49:50 <povman> :t &&&
23:49:51 <lambdabot> parse error on input `&&&'
23:49:52 <dblhelix> @type maximumBy
23:49:52 <BMeph> > head . sortBy (flip comparing length)  ["abc", "asdf", "c"]
23:49:52 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
23:49:53 <Mark1> but that just gives me the string with a z
23:49:53 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> a1'
23:50:16 <BMeph> > head . sortBy (flip comparing . length)  ["abc", "asdf", "c"]
23:50:17 <lambdabot>   Couldn't match expected type `[a]' against inferred type `b -> a1'
23:50:33 <BMeph> > head . sortBy (flip (comparing length))  ["abc", "asdf", "c"]
23:50:34 <lambdabot>   "aac"
23:50:43 <dblhelix> (maximumBy (\x y -> compare (length x) (length y)) ["abc", "asdf", "c"]
23:50:45 <napping> the longest string, or length of the longest string?
23:50:52 <Mark1> the longest string
23:50:55 <dblhelix> > (maximumBy (\x y -> compare (length x) (length y)) ["abc", "asdf", "c"]
23:50:56 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:50:59 <dblhelix> ouch
23:51:02 <dblhelix> too early
23:51:19 <povman> :t comparing
23:51:19 <dblhelix> > maximumBy (\x y -> compare (length x) (length y)) ["abc", "asdf", "c"]
23:51:20 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:51:20 <lambdabot>   "asdf"
23:51:34 <dblhelix> :t on
23:51:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:51:40 <povman> > maximumBy (comparing length)  ["abc", "asdf", "c"]
23:51:41 <lambdabot>   "asdf"
23:51:44 <povman> aha!
23:51:52 <Mark1> ok, excellent
23:51:53 <Mark1> thank you
23:52:01 <dblhelix> maximumby (compare `on` length) ["abc", "asdf", "c"]
23:52:10 <dblhelix> > maximumby (compare `on` length) ["abc", "asdf", "c"]
23:52:11 <povman> :t comparing
23:52:11 <lambdabot>   Not in scope: `maximumby'
23:52:12 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:52:15 <Mark1> i had tried something similar, but i messed up somewhere
23:52:19 <povman> :t (compare `on`)
23:52:20 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
23:52:23 <dblhelix> > maximumBy (compare `on` length) ["abc", "asdf", "c"]
23:52:24 <lambdabot>   "asdf"
23:52:33 <dblhelix> it looks a bit nicer that way ;-)
23:52:34 <napping> that will compute length multiple times
23:52:43 <BMeph> Freaking Caleskell...:(
23:52:45 <Mark1> similar to dblhelix's, i mean
23:52:53 <BMeph> > head (sortBy (flip (comparing length))  ["abc", "asdf", "c"])
23:52:54 <lambdabot>   "asdf"
23:53:17 <dblhelix> BMeph: a bit expensive perhaps? :)
23:53:30 <Mark1> povman's solution appears to be the most concise
23:53:53 <medfly> Hascale
23:54:04 <povman> :i comparing
23:54:10 <BMeph> > head . sortBy (flip (comparing length))  $ ["abc", "asdf", "c"]
23:54:11 <lambdabot>   "asdf"
23:54:18 <povman> where's that defined?
23:54:21 <Mark1> you guys are all very good at this :-)
23:54:36 <povman> haskell is good at being concise
23:54:43 <Mark1> my mind is starting to squeeze into the functional paradigm, but it definitely takes some twisting
23:55:19 <BMeph> dblhelix: Expensive, or expAnsive? ;)
23:55:23 <medfly> hit it with a hammer
23:55:50 <dblhelix> BMeph: no, the former... worried about time, not space ;-)
23:56:07 <dblhelix> @where comparing
23:56:07 <lambdabot> I know nothing about comparing.
23:56:17 <medfly> @type comparing
23:56:17 <dblhelix> @type Data.Ord.comparing
23:56:18 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:56:18 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:56:24 <BMeph> :t Data.Ord.comparing
23:56:25 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
23:56:44 <BMeph> > maximumBy (comparing length) ["abc", "asdf", "c"]
23:56:45 <lambdabot>   "asdf"
23:56:52 <Mark1> is Data.Ord a module i need to install?
23:57:04 <dblhelix> Mark1: it ships with GHC
23:57:09 <povman> :t on
23:57:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:57:25 <BMeph> > maximumBy (comparing length) . words $ "When you know the notes to sing, you can sing most anything!""
23:57:26 <lambdabot>   <no location info>:
23:57:26 <lambdabot>      lexical error in string/character literal at end o...
23:57:33 <BMeph> > maximumBy (comparing length) . words $ "When you know the notes to sing, you can sing most anything!"
23:57:34 <lambdabot>   "anything!"
23:57:40 <Mark1> ah, ok. i didn't see it here in zvon.
23:58:11 <BMeph> Mark1: Shun zvon. It's out of date, and GHC's own docs are better. :)
23:58:11 <dblhelix> and now I'll go hunting for some coffee ;-)
23:58:44 <kosmikus> dblhelix: good luck hunting :)
23:58:48 <Mark1> ok :-) right now it's a bit more convenient than hoogle because all the links seem to be broken
23:59:55 <povman> on should be called mapCombine :D
