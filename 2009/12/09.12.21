00:03:45 <Gracenotes> @bot
00:03:45 <lunabot>  :o
00:03:45 <lambdabot> :)
00:14:26 <dmwit> :o
00:36:38 * hackagebot upload: uuagc 0.9.13 - Attribute Grammar System of Universiteit Utrecht (ArieMiddelkoop)
01:22:58 <tobe> hi, I have to wirte an Enum for natural numbers. Is there any tutorial how to write Enums in general?
01:25:01 <c_wraith> @src Enum
01:25:01 <lambdabot> class  Enum a   where
01:25:01 <lambdabot>     succ                     :: a -> a
01:25:01 <lambdabot>     pred                     :: a -> a
01:25:01 <lambdabot>     toEnum                   :: Int -> a
01:25:01 <lambdabot>     fromEnum                 :: a -> Int
01:25:03 <lambdabot> [3 @more lines]
01:25:16 <c_wraith> more to that class than I thought
01:26:23 <c_wraith> tobe:  http://www.haskell.org/onlinereport/basic.html  see section 6.3.4
01:26:52 <tobe> ok, i'll have a look on it
01:29:00 <c_wraith> > succ 1.8
01:29:01 <lambdabot>   2.8
01:32:28 <Jafet> > let succ (n-1) = n in succ 1.8
01:32:29 <lambdabot>   <no location info>: Parse error in pattern
01:33:09 <Jafet> > let prev (n+1) = n in prev 2.8
01:33:11 <lambdabot>   Ambiguous type variable `t' in the constraints:
01:33:11 <lambdabot>    `GHC.Real.Integral t'
01:33:11 <lambdabot>   ...
01:34:19 <MoALTz> "Minimal complete definition: toEnum, fromEnum"
01:34:36 <MoALTz> http://www.haskell.org/onlinelibrary/standard-prelude.html#$tEnum
01:34:45 <c_wraith> Though pay attention to the rest of those comments
01:34:54 <jaspervdj> @src splitAt
01:34:55 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
01:35:03 <c_wraith> that default implementation only works in some cases.  though it would be just fine for naturals.
01:35:29 <c_wraith> > [1.8..]
01:35:30 <lambdabot>   [1.8,2.8,3.8,4.8,5.8,6.8,7.8,8.8,9.8,10.8,11.8,12.8,13.8,14.8,15.8,16.8,17....
01:35:35 <jaspervdj> why is splitAt defined like (take, drop)? I mean, it iterates two times over the first n elements, when once would do, right?
01:35:39 <c_wraith> > [1.8,1.9..]
01:35:40 <lambdabot>   [1.8,1.9,1.9999999999999998,2.0999999999999996,2.1999999999999993,2.2999999...
01:36:22 <Jafet> jasper, @src is purely pedagogical
01:36:25 <kmc> jaspervdj, @src is sort of fake
01:36:38 <smiler> jaspervdj: Check the real source :)
01:36:40 <Jafet> That one's from the Haskell report I think
01:36:54 <kmc> http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/base/src/Data-List.html
01:37:01 <kmc> that has genericSplitAt
01:37:09 <mux> yeah that splitAt definition comes from the Haskell report
01:37:19 <mux> it's perfect for describing the behaviour
01:37:40 <kmc> i assume the Report only defines the Prelude up to extensional equivalence
01:37:42 <jaspervdj> Okay, thanks guys :-)
01:38:20 <smiler> If you check lambdabot, it has a file named 'source' in it's state containing the source for @src
01:42:42 <vy`> "cabal update && cabal upgrade mime" returns "cabal: fromFlag NoFlag. Use fromFlagOrDefault". What could be the problem? (Cabal-1.8.0.2, cabal-install 0.8.0)
01:43:32 <Saizan> vy`: mh, that's a bug
01:44:00 <Saizan> vy`: however if you just want the latest version of mime you can "cabal install mime"
01:44:31 <Axman6> what a nice article: http://jlouisramblings.blogspot.com/2009/12/parsing-binary-data-in-erlang-and.html
01:44:42 <vy`> Saizan: Thanks. Let me report that.
01:46:59 <Axman6> jaspervdj: the reason it's defined like that is to help with laziness. you may not use both parts of the split, and if you don't, you can halve the work done
01:47:40 <Saizan> Axman6: it's not really defined like that in Data.List
01:47:49 <Axman6> i know
01:48:00 <Axman6> but that's the idea behind that definition
01:48:01 * hackagebot upload: regions 0.1 - Provides the region monad for safely opening and working with  scarce resources. (BasVanDijk)
01:48:22 <Saizan> the definition in Data.List has the same lazyness properties, no?
01:48:33 <Axman6> i haven't looked
01:48:54 <Saizan> i'm almost sure, they are pretty rigorous on these things
01:50:24 <Saizan> you just need to pattern match lazily on the tuple that comes from the recursive call
01:51:07 * hackagebot upload: regions-monadsfd 0.1 - Monads-fd instances for the RegionT monad transformer (BasVanDijk)
01:52:07 * hackagebot upload: regions-monadstf 0.1 - Monads-tf instances for the RegionT monad transformer (BasVanDijk)
01:59:09 * hackagebot upload: usb-safe 0.4 - Type-safe communication with USB devices. (BasVanDijk)
02:23:33 <Jedai> I have the same problem with leksah as I've already had : Space is considered as Ctrl+Space and so I can't write a whitespace in my files... I know last time I just commented a line in a key shortcuts file but I can't find it again in .~/leksah, someone know where it is ?
02:42:35 <ketil> I ought to know this, but: what's the best way to get the size of a file?
02:42:48 <kmc> on UNIX you can use stat
02:43:29 <ketil> In System.Posix.something?  Ideally, I'd like something portable.
02:43:42 <kmc> i do not know how to do it portably
02:43:58 <Saizan> ?hoogle fileSize
02:43:59 <lambdabot> System.IO hFileSize :: Handle -> IO Integer
02:43:59 <lambdabot> System.IO hSetFileSize :: Handle -> Integer -> IO ()
02:44:19 <ketil> Ah.
02:44:32 <Saizan> that's portable
02:46:02 <kmc> This is the 156,530th message to this channel to contain the string "monad".
02:46:11 <knobo> hpaste is dead
02:46:55 <quicksilver> http://moonpatio.com/fastcgi/hpaste.fcgi/new works
02:47:01 <Saizan> @tell mmorrow hpaste's database is locked
02:47:01 <lambdabot> Consider it noted.
02:47:16 <mmorrow> grr
02:47:16 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
02:48:16 <mmorrow> ok
02:48:49 <mmorrow> ketil: although with that you have to open the file first..
02:49:42 * mmorrow mentions this because he heard this on #ghc the other day and it stuck in his mind for some reason
02:49:43 <mmorrow> <Igloo> Do we really not have a portable function to find the size of a file without opening it?
02:49:52 <mmorrow> i guess we don't
02:50:12 <knobo> This was useful for me to understand the State monad: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5446#a5446
02:50:14 <tibbe> I need a persistent heap that allows me to delete elements from inside the heap e.g. by returning some sort of token on insert that can be used for that purpose. Anyone know of such a data structure?
02:50:33 <ketil>   size <- sum `fmap` mapM (\f -> do {h <- openFile f ReadMode; r <- hFileSize h;  hClose h; return r) inputs
02:50:39 * ketil sighs.
02:50:41 <Twey> Huh
02:50:44 <knobo> Other people could do the same if they have problems
02:51:00 <mmorrow> tibbe: so a (priority queue + map) ?
02:51:10 <Twey> We don't even seem to have a general equivalent of stat
02:51:34 <mmorrow> tibbe: you could use IntMap as a priority queue, and dole out sequential unique Ints on each insert to use as key
02:52:04 <tibbe> mmorrow: yes
02:52:17 <tibbe> mmorrow: just checking if something like that already exists
02:52:22 <Twey> Data.Unique
02:52:32 <tibbe> Twey: does it use unsafePerformIO magic?
02:52:38 <mmorrow> you wouldn't need Data.Unique even
02:52:42 <Twey> tibbe: Yes
02:52:47 <Twey> Not that you should care
02:53:09 <mmorrow> data PQWithDelete = PQWD {theQ :: ...., next :: Int}
02:53:41 <tibbe> mmorrow: right
02:53:47 <mmorrow> insertQ :: PQWD a -> Priority -> a -> (Int, PQWD a)
02:54:02 <tibbe> mmorrow: right, probably with newtype Key = Int
02:54:33 <mmorrow> yeah, you could pretty it up in various ways for sure
02:55:00 <mmorrow> and if the type is abstract, the user won't need to worry about the Int, and you won't need to worry about them messing with it
02:55:47 <tibbe> mmorrow: exactly
02:55:51 <mmorrow> s/Abstract/Constructor not exported/ (since haskell doesn't have abstract datatypes.. :(
02:55:53 <tibbe> mmorrow: just feels like someone have done this before
02:56:00 <tibbe> mmorrow: and thought about making it fast
02:56:16 <mmorrow> tibbe: i've done the Q part with IntMap (using okasaki's "bootstrapping")
02:56:26 <tibbe> mmorrow: have the code somewhere?
02:56:29 <mmorrow> http://moonpatio.com/repos/PQ.hs
02:56:40 <quicksilver> mmorrow: that's a bit harsh isn't it? There are a variety of ways of doing abstract data types in haskell, depending what you understand by the term.
02:56:45 <mmorrow> you could add the "next::Int" super easy
02:57:37 <dancor> what do you do if you have a "Overlapping instances for Monad (Either String)" error with mtl/transformers but neither is in your build-depends line
02:57:39 <mmorrow> quicksilver: heh, yeah that's slightly harsh.
02:58:18 <mmorrow> quicksilver: i suppose with associated data/types + classes you can get this (modulo not controlling instance selection)
02:58:47 <stoop> conal = Conrad?
02:58:53 <mmorrow> quicksilver: but i hesitate to consider not exporting the constructors to be enough, since modules don't have signatures
02:59:19 <stoop> mmorrow, any idea?
02:59:33 <mmorrow> stoop: you mean about conal?
02:59:34 <mmorrow> no
02:59:39 <stoop> Ok.
02:59:39 <Saizan> dancor: instances get exported transitively, so it means there are other packages you're using that do use those packages
02:59:45 <mmorrow> stoop: Conal
03:00:08 <mmorrow> quicksilver: what are your thoughts on this?
03:00:18 <dancor> Saizan: yikes
03:00:25 * mmorrow was trying to be provocative and succeeded!@
03:01:05 <Saizan> mmorrow: my meaning of "abstract datatype" doesn't include the ability to change the implementation from within the language
03:01:48 * dancor has never been very impressed with instance resolution
03:02:22 <Saizan> dancor: instances are global, that's the meat
03:02:37 <mmorrow> Saizan: right, but i would consider it to be the ability to specify a type abstractly along with functions that act on it
03:03:01 <mmorrow> Saizan: but typeclass instance selection constrains the possible implems of two separate instances of that type
03:03:10 <dancor> well this is a software development nightmare
03:03:52 <mmorrow> dancor: global vars rule!
03:04:01 <dancor> they rule harshly
03:04:02 * mmorrow provokes quicksilver some more
03:04:35 <Saizan> well, i still prefer typeclasses to functors for most things :)
03:04:48 <Saizan> s/to/rather than/
03:04:56 <mmorrow> Saizan: definitely, i think they are totally orthogonal
03:05:48 <Saizan> mh no, in a language where you've both i'd require some bridge
03:06:25 <mmorrow> i think figuring out what that could be is the major hurdle to having both
03:06:38 <mmorrow> but wrt what they give you, i think they're orthogonal
03:06:40 <dancor> what is the connection between instances being global and functors
03:06:58 <Saizan> ML functors
03:07:02 <dancor> or, what about instances not being global is bad
03:07:03 <Saizan> i.e. parametrized modules
03:07:23 <Saizan> instances not being global means you can't keep some invariants
03:07:27 <mmorrow> since functors map modules, and typeclasses associate certain operations with a collection of non-overlapping types
03:07:35 <Saizan> s/keep/count on/
03:07:52 <dancor> but with global instances you can't count on very much
03:08:02 <Saizan> the silliest example is that Data.Map works only because you can only have a single Ord instance for every type
03:08:06 <dancor> any dependency could ruin everything at any moment..
03:08:18 <dancor> subsubdep
03:08:31 <mmorrow> dancor: the price of convenience
03:08:59 <Saizan> dancor: you can always solve that with a newtype
03:09:17 <quicksilver> mmorrow: it's monday morning and I have a lot of work today before I quit for xmas. No spare brain cycles. I've never had difficulties making my datatypes as abstract as I want.
03:09:29 <Saizan> which is no noiser than what you'd get with ML functors from the start
03:09:30 <mmorrow> Saizan: as long as the conflicting instances are under your control, that is
03:09:41 <Saizan> mmorrow: no, why?
03:10:23 <dancor> well i have no idea what is the easiest resolution, or the resolution possibilities, for my problem.  it's completely insane.
03:10:28 <dancor> this used to build.
03:10:30 <Saizan> mmorrow: make a newtype and derive from the instance you want in a different module, then you can import it in the module that has both instances in scope
03:10:33 <mmorrow> Saizan: dancor is importing two modules by two paths that both have instance Monad (Either String), right?
03:10:44 <dancor> mmorrow: correct
03:10:44 <mmorrow> and he wrote neither of those instances
03:10:48 <dancor> correct
03:10:48 <Saizan> yeah
03:10:54 <Saizan> and i gave you a solution to that
03:11:13 <mmorrow> Saizan: so he needs to either not import one of them, or modify it's code
03:11:14 <dancor> and people do this often?
03:11:27 <mmorrow> Saizan: /me is parsing your suggestion
03:11:27 <dancor> the newtype solution
03:11:48 <Saizan> i'm not sure how often people get this problem
03:11:49 <mmorrow> Saizan: oh.
03:11:58 <mmorrow> Saizan: yeah, that's a clever solution
03:12:29 <mmorrow> well, i'd call it more a workaround than a solution, but .. :)
03:13:32 <Saizan> newtypes is how you get to choose instances
03:13:41 <Saizan> s/is/are/
03:13:42 <mmorrow> quicksilver: but sometimes it's difficult to provide your abstract types with concrete implems if two of these implems' types overlap
03:13:45 <dancor> haskell, or maybe cabal, seems very inherently prone to bitrot over issues like this
03:14:54 <Saizan> (and you can even create instances at runtime)
03:15:20 <Saizan> (but that's a bit hackier :)
03:16:05 <mmorrow> quicksilver: (no further comment expected :) merry xmas!
03:16:37 <Axman6> well, gtk2hs doesn't seem to compile with 6.12. no big surprise there
03:18:47 <dancor> changing Either String a to a newtype doesn't really seem sane here
03:19:36 <quicksilver> dancor: the fault is really with the modules/packages that define the instances (although I appreciate that's no great comfort to you)
03:19:44 <mmorrow> Saizan: although, that solution only works since ghc doesn't complain about conflicting instances unless that instance is actually used (which iirc is non-haskell98, but following the standard on this point would be unduly hard to implement iirc)
03:20:01 <quicksilver> it's not sane to define an instance unless you either "own" the type or the class
03:20:19 <mmorrow> yeah, that's a good rule
03:20:34 <quicksilver> mmorrow: it doesn't *sound* very hard to export a global symbol (possibly dummy) for each instance to force an error at link time if you have more than one instance.
03:20:48 <quicksilver> I think it was rejected on pragmatic grounds, not implementation grounds.
03:21:51 <mmorrow> quicksilver: i can't remember what he difficulty was, but istr this being said when someone realized and posted somewhere that you could have two different Monoid instances for Int (or something) in two different modules
03:21:53 <dancor> quicksilver: i mean it's comforting to me.  i didn't really know what the language designers intended with this issue
03:22:10 <mmorrow> and do something weird like   One.mappend 2 (Two.mappend 2 3)
03:22:18 <mmorrow> ===> 2 * (2 + 3)
03:22:21 <mmorrow> or something
03:22:32 * mmorrow looks for this
03:23:00 <sinelaw> what's a "clustered graph"?
03:23:03 <Saizan> that means those mappend are not polymorphic anymore though
03:24:31 <mmorrow> quicksilver: http://www.haskell.org/pipermail/haskell/2008-June/020436.html
03:24:38 <mmorrow> (i think that's it)
03:24:52 <mmorrow> which prompted http://hackage.haskell.org/trac/ghc/ticket/2356
03:25:52 <mmorrow> ah, the ticket has the comments i'm thinking of
03:26:31 <CalJohn> @src zipWithM3_
03:26:31 <lambdabot> Source not found. Are you on drugs?
03:26:40 <CalJohn> is there a zipWithM3_ anywhere?
03:26:56 * Saizan sees that quicksilver and augustss think alike
03:27:00 <Axman6> :t zipWithM
03:27:02 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:27:15 <CalJohn> @src zipWithM
03:27:16 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
03:27:29 <CalJohn> ah, defining it will be pretty simple
03:27:37 <mmorrow> oh interesting, Igloo gives an example where this breaks Data.Set
03:27:46 <CalJohn> @src zipWithM_
03:27:47 <lambdabot> zipWithM_ f xs ys = sequence_ (zipWith f xs ys)
03:27:53 <quicksilver> mmorrow: yes but I don't follow spj's reasoning.
03:28:02 <dibblego> @type \f x y z -> sequence (liftA3 f x y z)
03:28:03 <lambdabot> forall a b c (m :: * -> *) a1. (Monad m) => (a -> b -> c -> m a1) -> [a] -> [b] -> [c] -> m [a1]
03:28:08 <quicksilver> Saizan: I was almost certainly quoting augustss. It was either him or JohnMeacham
03:29:25 <mmorrow> quicksilver: oh. i glossed over your "link time" comment until after i read the ticket and re-read your suggestion
03:29:25 <mmorrow> quicksilver: yeah, link-time seems like it both achieves catching this *and* in a way that's cheap for the compiler
03:30:23 <quicksilver> I think claus's comment "That depends on what you define as wrong, doesn't it?" is incomprehensible
03:30:31 <quicksilver> to me Igloo's example is quite obviously broken.
03:30:55 <quicksilver> certainly overlapping instances make the problem worse, though.
03:32:51 <dancor> i mean i think it's fine to put a monad instance of Either String a somewhere
03:33:04 <dancor> but i guess then you can never easily transition to another place
03:33:31 <mmorrow> dancor: in Data.Monad or Data.Either i'd consider the two acceptable places (as per quicksilver's rule)
03:33:38 <dancor> ah
03:33:44 <dancor> right.
03:34:55 <mmorrow> well, probably be "instance Monad (Either a) where" too (but then `fail' would be tough to implem i guess..)
03:35:48 <Saizan> sometimes you've to make orphan instances to glue together two different libraries though, you can't expect everyone that declares a class to make all the conceivable instances for types on hackage, or vice versa
03:35:51 <quicksilver> mmorrow: actually I think it's probably acceptable anywhere in the same package as those modules.
03:36:15 <mmorrow> quicksilver: yeah, i could see that
03:36:23 <quicksilver> Saizan: probably only in "leaf" locations - i.e. applications
03:36:39 <quicksilver> Saizan: otherwise you get exactly this problem
03:37:29 <Saizan> quicksilver: yeah, though if i have many applications that need this? i make a package for orphans?
03:38:23 <quicksilver> ideally you push it into one or the other of the two libraries concerned
03:38:40 <dancor> my naive opinion is still that instances are broken
03:38:47 <quicksilver> I suppose the second-best solution is a package which *only* does the orphan instances in the hope it becomes canonical.
03:38:52 <Saizan> that orphan's package should remain a leaf
03:40:06 <dancor> how is the package a leaf if it's being used by other packages?
03:40:17 <Saizan> dancor: "fixing" them and keeping reasonable semantics doesn't seem so easy though, it seems like you'd have to be able to parametrize datatypes by instances
03:40:36 <dancor> mm
03:40:40 <quicksilver> my view is that if you fix them, you don't have typeclasses any more
03:40:50 <quicksilver> you may well have something useful, but it isn't typeclasses
03:40:53 <Saizan> dancor: well, not really a leaf, it would be used by applications
03:40:54 <mmorrow> yeah, i think that it's not a matter of "fixing" instances/typeclasses (since
03:40:55 <mmorrow> yeah
03:41:04 <mmorrow> something /else/ is needed
03:41:05 <quicksilver> give it a good name and convince people it's a good abstraction.
03:41:06 <dancor> but not by libraries
03:41:18 <dancor> Saizan: so leaves or leaf-parents only
03:41:22 <quicksilver> I remain unconvinced you have anything better than "explicit dictionaries"
03:41:30 <mmorrow> since typeclasses do exactly what they're meant to do (for better or for worse given a situation, but by design nonetheless)
03:41:44 <quicksilver> it may be that a fairly simplistic kind of syntactic sugar over explicit dictionaries is the solution
03:41:52 <Saizan> mmorrow: btw, if you have both functors and typeclasses, how would you declare Monad?
03:41:58 <quicksilver> and possible syntactic sugar to convert between typeclasses and explicit dicts.
03:42:47 <mmorrow> quicksilver: i think one thing better than explicit dictionaries is to have a module language which you provide the implems of these dicts, so your application code is less cluttered
03:43:10 <quicksilver> yes, that kind of thing
03:43:17 <quicksilver> fair enough that's slightly more than syntactic sugar
03:43:24 <quicksilver> but it's along similar-ish lines.
03:43:27 <mmorrow> right
03:43:35 <quicksilver> of course having a module language at all is an interesting direction.
03:43:47 <quicksilver> once we have one it might be easier to speculate about ways to use it :)
03:44:06 <mmorrow> the *crucial* aspect though in my opinion is that you don't deal with connecting implem to interface in your application code
03:45:09 <mmorrow> yeah, i think that's the major hurdle. once you've got it and questions of "is it worth it" are through with, only then could you really come up with the killer apps
03:45:23 <mmorrow> but you need at least one or two killer apps to get it!
03:45:29 <mmorrow> vicious cycle
03:45:55 * Saizan has tried the module language in agda and he's not amused
03:48:09 <quicksilver> mmorrow: what you need to get it is a working prototype
03:48:18 <quicksilver> it's very hard to get people to discuss stuff entirely in the abstract.
03:48:29 <quicksilver> most people need to try it to comment usefully.
03:48:34 <mmorrow> quicksilver: yeah, that's really it isn't it.
03:49:26 <quicksilver> I strongly suspect that all the people who think they want a record syntax would no longer think they do, if somebody did a really *excellent* version of Data.Accessor, and got it "standard enough" to become widely used.
03:49:36 <quicksilver> (sorry, that was a bit tangential)
03:49:40 <mmorrow> oh not haz implem? kthxbai.
03:49:49 <quicksilver> (but some people equate a module language with a good record syntax)
03:49:51 <mmorrow> quicksilver: hah
03:50:06 <mmorrow> (hah at your Data.Accessor mini-rant)
03:51:37 <sinelaw> can ghci do qualified imports?
03:52:18 <sinelaw> also, if I have Blah.Module and Blah.Module.Bleh and I want them qualified as Module and Module.Bleh, how do I import the second one?
03:53:41 <Saizan> can you "import qualified Blah.Module.Bleh as Module.Bleh"?
03:54:46 <sinelaw> Saizan, it doesn't give an error but also doesn't let me access the stuff inside as Module.Bleh
03:55:17 <Saizan> ghci might not really support qualified imports
03:55:29 <Saizan> at the prompt, i mean
03:55:44 <sinelaw> Saizan, yeah never mind that. I'm more concerned abuot the second question and for ghc
04:49:32 <aep> umm. why can't i define a function :: ()  and just stick it in the middle of any do list ? doesnt fun :: () say: this function has no parameters and returns nothing?
04:50:45 <Saizan> 1) anything of type () is not a function
04:51:11 <Saizan> 2) by do-list you mean an expression written using do-notation?
04:51:17 <aep> yes
04:51:26 <copumpkin> () -> ()
04:51:44 <aep> yeah but that whines it wants an IO action as parameter
04:52:02 <Saizan> because expressions in do-notation needs to have type M A, for some A and some M which is a monad,
04:52:15 <aep> actually the real problem is, i have no idea why it complains about the do expression where i'm _using_ the function
04:52:32 <aep> all of them?
04:52:37 <aep> i though only the last one
04:52:41 <Saizan> all of them.
04:52:47 <aep> ew.  ok thanks
04:53:04 <mauke> what would you expect it to do with over values?
04:53:13 <aep> with what?
04:53:23 <aep> what are "Over values" ? oO
04:53:27 <mauke> argh
04:53:27 <Saizan> "do a; b; c; x <- d; e" a, b, c, d and e need to be of type M A, with the same M but A can vary
04:53:31 <mauke> *other
04:53:38 <aep> aah.  yeah well, ignore them?
04:53:49 <mauke> aep: then why did you put them in in the first place? :-)
04:53:51 <aep> i guess haskell is to strict to allow that
04:54:08 <mauke> if it just ignores them, it's pointless to put them in
04:54:26 <aep> yeah right. doesnt make much sense. i'm trying to use a function that doesnt do anything yet, simply because i have no clue
04:55:16 <aep> i'm applying the "add some function that only prints something to stdout" aproach, which doesn't work well with haskell :D
04:55:40 <Saizan> you want IO () instead of () as the type of such a function
04:55:46 <aep> right
04:56:02 <mauke> that's not a function
04:56:07 <aep> hey that works though
04:56:09 * hackagebot upload: base-unicode-symbols 0.1 - Unicode alternatives for common functions and operators (RoelVanDijk)
04:56:11 * hackagebot upload: containers-unicode-symbols 0.1 - Unicode alternatives for common functions and operators (RoelVanDijk)
04:56:44 <aep> wuu it runs
04:57:36 <Saizan> yeah, it's not a function, if you want to be more specific then "value" you can say "IO action"
04:57:44 <Saizan> *than
04:58:37 <aep> IO action implys it actually returns a monad, doesnt it?
04:58:45 <aep> err IO.
04:58:53 <aep> so return () doesnt work
04:59:00 <Saizan> the type constructor IO is the monad
04:59:14 <Saizan> anything of type IO Something is an IO action
04:59:40 <aep> yes. but IO () is not the same as IO action, is it?
04:59:45 <aep> it complains at least
05:00:10 <aep> fn :: IO action  \  fn = do putStrLn "fn"
05:00:11 <Saizan> "IO action" is a term to talk about these things, it's not a type
05:00:12 <mauke> IO () is the type of an IO action
05:00:16 <aep> ah ok
05:00:28 <aep> i though its some sort of wildcard. heh
05:00:32 <mauke> do X is the same as X
05:00:45 <mauke> aep: if you actually put it in your program, it is a wildcard :-)
05:00:55 <ziman> () is a concrete type
05:01:01 <ziman> :t ()
05:01:02 <lambdabot> ()
05:01:09 <mauke> but then it complains because putStrLn returns something of type (), not of every possible type
05:01:20 <aep> i see
05:01:28 <BenceF> heyy
05:03:46 <BenceF>  is there a command in ghci to get it to show the implementation of a function?
05:03:52 <mauke> no
05:03:56 <BenceF> :(
05:04:42 <Jafet> grep is your friend
05:04:51 <kpreid> we have @src here though
05:04:59 <Saizan> source links on haddock docs too
05:05:22 <Saizan>  @src has a limited and not always faithful database
05:06:01 <Jafet> Staffed by pet ferrets
05:10:28 <BenceF> ive got ´data Vector = Vector [Float]´ how do i pattern match in a func? ´f § Vector (x:xs)´ or ´f (Vector (x:xs))´ doesnt seem to work
05:10:41 <copumpkin> the latter should work
05:11:07 <copumpkin> not sure what you want with that § though :)
05:11:24 <BenceF> replace the parenthesis
05:11:25 <copumpkin> $ doesn't work in patterns
05:11:31 <BenceF> oh
05:11:39 <copumpkin> yeah, that doesn't work, and it's $, not § :P
05:11:44 <BenceF> ahha
05:11:55 <BenceF> ok
05:11:56 * Saizan wonders why we don't have a § operator yet
05:12:00 <Cale> $ doesn't *really* just replace parens, it's actually a defined function
05:12:00 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
05:12:01 <BenceF> im new:)
05:12:13 <copumpkin> @let (§) = ($)
05:12:14 <lambdabot>  Defined.
05:12:22 <copumpkin> > (+1) § 4
05:12:24 <lambdabot>   5
05:12:40 <Cale> Hmm, I wonder if I can type that symbol using my compose key
05:13:15 <aep> if you have a gui program with widgets (i'm trying hscurses), do you pass around your windows in a custom data structure between functions?
05:13:37 <Saizan> ah, that's why, it's missing from english keyboards :)
05:14:29 <BenceF> yeah iv got a german one
05:14:52 <BenceF> and theyre next to each other
05:16:44 <Cale> aep: I'm afraid I haven't tried that library, but possibly?
05:17:23 <aep> it was more a general question for functional programming
05:17:38 <aep> i'm guessing states are done by passing around a state structure
05:17:57 <Cale> That's a typical approach, yeah.
05:18:43 <Twey> Cale: Compose o s
05:18:45 <Twey> §
05:19:09 <Cale> Twey: ah, there it is :)
05:21:35 <Axman6> bleh, i haven't written any haskell in ages, and can't think of anything fun to write
05:21:47 <copumpkin> haskell_proposals
05:21:58 <Raevel> hey i can relate
05:21:58 <copumpkin> or be my codemonkey and I'll give you a thousand projects I have on my queue
05:22:11 <Axman6> copumpkin: such as?
05:22:26 <Raevel> /nick comonkey
05:22:45 <copumpkin> Axman6: http://reddit.com/r/haskell_proposals
05:22:47 <Cale> aep: Depending on the situation, using a state or reader monad or monad transformer, or using IORefs/MVars/etc. can help deal with state, but simple parameter passing is simple and often actually the nicest thing.
05:23:28 <Axman6> "A Haskell Meta Language EDSL to generate (imperative) code for multiple target progamming languages" sounds interesting, but out of my legue
05:24:44 <Cale> aep: But if you start doing lots of tupling of results in order to pass modified state back to the caller of various functions, that's a good sign that maybe something more structured would help.
05:24:50 <burp> oh, haskelltop..
05:25:19 <jkff> Hey. I wonder: is Mark P. Jones a relative of Simon Peyton Jones?
05:27:11 <quicksilver> no
05:27:20 <quicksilver> Jones /= Peyton Jones
05:27:37 <Cale> But what does the P stand for? :)
05:27:42 <jkff> Cale: +1 :)
05:27:50 <copumpkin> lol
05:27:52 <quicksilver> and of course Jones is an extremely common surname.
05:28:04 <copumpkin> Simon P. Jones and Mark Peyton Jones
05:28:09 <mauke> instance Monad Peyton where
05:28:17 * jones-- wonders about all this hilighting :)
05:28:18 <quicksilver> Cale: Peyton is part of the surname, not a middle name
05:28:31 <Cale> I know :)
05:28:52 <copumpkin> oh he was born in south africa
05:29:21 <jkff> I googled and googled, but couldn't find what the P stands for :-|
05:29:34 <jkff> His personal page does not reveal the truth
05:31:00 <mauke> POWERLORD
05:31:05 <copumpkin> he's on twitter
05:31:09 <copumpkin> send him a tweet asking :)
05:35:33 <ketil> I'm running an experiment - pitching a bloom filter against Data.Set.
05:36:33 * quicksilver fills ketil's cache with cosmic rays to distort the experiment.
05:36:39 * ketil is hoping the bloom filter will significantly speed up an application, where (or so the suspicion goes) Data.Set is responsible for slowing everything down as it grows to comsume a relatively large amount of memory.
05:37:06 <ketil> quicksilver, ai, ai!  A balrog!  A balrog has come.
05:37:57 <Twey> Haha
05:38:06 <copumpkin> ketil: but false positives! zomg!
05:38:08 <ketil> ops.  The bloom filter just allocated 20GB or RAM.
05:38:12 <Twey> Hahaha
05:38:37 <aep> hm how do i convert a literal char to a word32?
05:38:44 <copumpkin> ord
05:38:47 <Twey> :t ord
05:38:47 <copumpkin> fromIntegral .
05:38:48 <lambdabot> Char -> Int
05:38:54 <ketil> Stupid bug of the month: forgot to divide the file size by the record size.  Now it thinks it will have to store 8.4 gigarecords, instead of about 3 million.
05:38:55 <Twey> :t fromIntegral . org
05:38:55 <lambdabot> Not in scope: `org'
05:38:56 <Twey> Ack
05:38:57 <Twey> :t fromIntegral . ord
05:38:58 <lambdabot> forall b. (Num b) => Char -> b
05:39:06 * copumpkin bows
05:39:14 <Twey> > chr -1
05:39:15 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Char))
05:39:15 <lambdabot>    arising ...
05:39:17 <Twey> Hate
05:39:20 <Twey> > chr $ negate 1
05:39:21 <lambdabot>   * Exception: Prelude.chr: bad argument
05:39:22 <ketil> copumpkin, positives schmozitives, I say.
05:39:27 <copumpkin> :)
05:39:30 <aep> thanks
05:39:34 <Twey> Really, chr/ord should just use a Word value to start with
05:39:38 <ketil> (they don't matter for this application)
05:39:39 <copumpkin> yeah
05:39:43 <nha_> what causes top level functions without args not to become a CAF besides class constraints
05:39:48 <copumpkin> Int doesn't belong in 90% of the places it's used
05:39:50 <Twey> Yeah
05:40:05 <Twey> I mean, that's just fugly
05:40:09 <Twey> > chr $ negate 1
05:40:10 <lambdabot>   * Exception: Prelude.chr: bad argument
05:40:32 <Twey> If it used a Word and we had a proper class hierarchy for numeric types, that would be a compile-time error
05:41:11 <quicksilver> ketil: I'd certainly expect a decent bloomfilter to perform much better than Data.Set
05:41:19 <quicksilver> Data.IntSet should be closer.
05:41:27 <aep> um
05:41:29 <aep> No instance for (Integral Char)
05:41:39 <aep> oO
05:41:50 <Twey> aep: You're doing it wrong :þ
05:41:55 <aep> probably
05:41:58 <Twey> Don't forget the ‘ord’
05:42:03 <aep> fromINtegral 'f'
05:42:10 <Twey> > fromIntegral $ ord 'f'
05:42:11 <lambdabot>   102
05:42:30 <aep> uh whats ord?
05:42:36 <Twey> :t ord
05:42:37 <lambdabot> Char -> Int
05:42:59 <aep> oh. so what do i need fromINtegral from then if ord already is an int?
05:43:06 <Twey> aep: Because you wanted a Word
05:43:19 <aep> aah
05:43:28 <PeakerWork> @check ord = fromEnum
05:43:29 <lambdabot>   Parse error at "=" (column 5)
05:43:37 <PeakerWork> @check liftA2 (==) ord fromEnum
05:43:38 <lambdabot>   "OK, passed 500 tests."
05:43:39 <BenceF> how do i print a character by utf code?
05:43:48 <ketil> quicksilver, yes, me too.   Especially now that I fixed it to only allocate 200M, not 20G for the bit array :-)
05:44:05 <aep> main.hs:12:33: Not in scope: `ord'
05:44:05 <Twey> BenceF: What do you mean by ‘UTF code’?
05:44:11 <Twey> aep: import Data.Char (ord)
05:44:17 <quicksilver> BenceF: UTF code? nobody knows UTF codes...
05:44:25 <aep> aye thanks
05:44:26 <BenceF>  like u+fd80
05:44:51 <Twey> You mean a Unicode codepoint
05:45:01 <BenceF> thats it is
05:45:04 <Twey> > text "\uFD80"
05:45:05 <lambdabot>   <no location info>:
05:45:05 <lambdabot>      lexical error in string/character literal at chara...
05:45:06 <Jonno_FTW> ansii codes?
05:45:09 <Twey> Hmph
05:45:12 <Jonno_FTW> chr 54
05:45:15 <Jonno_FTW> > chr 54
05:45:16 <lambdabot>   '6'
05:45:22 <Twey> > text . return $ chr 0xfd80
05:45:23 <lambdabot>   ﶀ
05:45:39 <Twey> > read "0xFD80" :: Int
05:45:40 <lambdabot>   64896
05:45:41 <ketil> quicksilver, actually, the speed difference isn't that great, as long as the Set is small.
05:45:52 <copumpkin> > "\12345"
05:45:53 <lambdabot>   "\12345"
05:45:55 <Twey> Aha
05:46:18 <Twey> > text "\A7"
05:46:19 <lambdabot>   <no location info>:
05:46:19 <lambdabot>      lexical error in string/character literal at chara...
05:46:22 <Twey> > text "\000A7"
05:46:23 <lambdabot>   A7
05:46:26 <Twey> o.@
05:46:38 <Twey> > "\000A7"
05:46:38 <lambdabot>   "\NULA7"
05:46:40 <ketil> Hm.  Is there an issue with GC and huge, mutable arrays, I wonder?
05:46:44 <Twey> Hmn.  That's not what I wanted.
05:46:46 <Axman6> > text "\00A7"
05:46:47 <lambdabot>   A7
05:46:49 <ketil> The big one seems to be stuck at the moment.
05:47:04 <Twey> No leading zeroes after four?
05:47:15 <Twey> Oh, wait — that was interpreted as \NULA7 too
05:48:08 <Twey> > text . return . chr . read . ("0x" ++) . drop 2 $ "U+00A7"
05:48:09 <lambdabot>   §
05:48:11 <Twey> \o/
05:48:19 <BenceF> well guys iv gotta go cause ive got vectorcalculus exam tomorrow and i know nothing
05:48:20 <Axman6> > text "\x00A7"
05:48:21 <lambdabot>   §
05:48:34 <Twey> > length "\12345"
05:48:34 <lambdabot>   1
05:48:44 <Twey> Ah, I see
05:48:46 <Twey> That's decimal
05:48:55 <Twey> > read "0xA7" :: Int
05:48:56 <lambdabot>   167
05:48:59 <Twey> > "\167"
05:49:00 <lambdabot>   "\167"
05:49:04 <Twey> > text "\167"
05:49:05 <lambdabot>   §
05:49:07 <Twey> Okay
05:49:10 <Twey> Mystery solved :þ
05:50:57 <quicksilver> ketil: yes, there is a big slowdown for mutable arrays + GC.
05:51:05 <quicksilver> ketil: yes, a Data.Set will be fast if it fits entirely in cache.
05:51:14 <quicksilver> ketil: everything is fast if it fits entirely in cache, in a sense :)
05:51:15 <copumpkin> mutable boxed arrays, at least
05:51:19 <ketil> Bloom filter and Set do about 30K records/sec initially, after 200K records, Set is down to about half, BF stays at about 30K.
05:51:23 <copumpkin> but that should be improved in the past few days
05:51:35 <ketil> The big one is still garbage collecting :-)
05:51:42 <copumpkin> but a bloom filter could fit in an unboxed array
05:51:43 <quicksilver> ketil: (although perhaps a little less so in the case of modern machines with lower multipliers)
05:52:03 <quicksilver> copumpkin: improvements in the past few days?
05:52:04 <Axman6> hmm, i need to read the bloom filter chapter of RWH sometime
05:52:10 <Axman6> @where rwh
05:52:11 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:52:24 <ketil> copumpkin, I'm using Bryan O'Sullivan's library, it uses an unboxed bit-array.
05:53:04 <copumpkin> quicksilver: simple card marking
05:54:13 * mstevens starts to regret upgrading ghc
05:54:23 <copumpkin> why?
05:54:50 <quicksilver> copumpkin: cool.
05:55:37 <mstevens> copumpkin: cabal doesn't seem to quite have caught up
05:55:44 <copumpkin> you mean hackage?
05:55:46 <copumpkin> or cabal-install?
05:56:03 <nha_> cabal-install probably
05:56:13 <mstevens> copumpkin: well a) cabal-install, and b) ability of "cabal install xmonad" to work
05:56:19 <Saizan> 0.8 works with 6.12
05:56:27 <Axman6> mstevens: cabal install 'cabal-install >= 0.8' should help, if you can
05:56:29 <Saizan> cabal-install 0.8 i mean
05:56:52 * mstevens tries this
05:56:58 <dcoutts> indeed the older version of cabal install should tell you this if you try to use it with ghc-6.12
05:57:04 <mstevens> on the positive side, I'm enjoying Real World Haskell
05:57:24 <mstevens> dcoutts: I was trying the darcs version after the old version whinged. Which I admit is a risky idea.
05:57:48 <dcoutts> mstevens: did it tell you to use  cabal install 'cabal-install >= 0.8' ?
05:58:32 <mstevens> dcoutts: I don't think either any tool or my quick google has proposed this.
05:58:51 <EvanR> is this unsafe: foo = unsafePerformIO newMVar
05:58:54 <dcoutts> mstevens: do you know what version of cabal-install you were using?
05:59:22 <dcoutts> it's supposed to say:
05:59:22 <dcoutts> cabal: This version of the cabal program is too old to work with ghc-6.12+.
05:59:22 <dcoutts> You will need to install the 'cabal-install' package version 0.8 or higher.
05:59:22 <dcoutts> If you still have an older ghc installed (eg 6.10.4), run:
05:59:22 <dcoutts> $ cabal install -w ghc-6.10.4 'cabal-install >= 0.8'
05:59:44 <Axman6> EvanR: it said it's unsafe right there :P
05:59:56 <dcoutts> that's what version 0.6.4 says anyway, earlier versions died with 'ghc-pkg dump failed'
06:00:05 <luite> dcoutts: do you know what might have cause this (installing happstack-data for ghc 6.12.1 with cabal-install 0.8.0, all other packages are installed with cabal-install too) ghc.exe: dist\build\Happstack\Data\Default.o: unknown symbol `_sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacbsZN_closure'
06:00:23 <luite> dcoutts: I have the same problem on both windows and linux
06:00:24 <dcoutts> luite: no but my inclination would be to clean and rebuild
06:00:26 * hackagebot upload: hums 0.2.5 - Haskell UPnP Media Server (BardurArantsson)
06:00:32 <dcoutts> luite: oh
06:00:38 <EvanR> Axman6: clearly, but were advised to only use unsafePerformIO to do something after we decide its not going to cause the universe to explode etc
06:00:44 <luite> dcoutts: I reproduced it with a clean 6.12 install on ubuntuj
06:00:55 <mstevens> As far as I can tell from scrollback I had:
06:00:56 <EvanR> Axman6: like, what problems could that cause, above
06:00:59 <mstevens> mstevens@mstevens-desktop:~ % cabal --version
06:00:59 <mstevens> cabal-install version 0.6.2
06:00:59 <mstevens> using version 1.6.0.3 of the Cabal library
06:00:59 <mstevens> mstevens@mstevens-desktop:~ % cabal update
06:00:59 <mstevens> Downloading the latest package list from hackage.haskell.org
06:01:02 <mstevens> Note: there is a new version of cabal-install available.
06:01:04 <mstevens> To upgrade, run: cabal install cabal-install
06:01:07 <mstevens> mstevens@mstevens-desktop:~ % cabal upgrade
06:01:09 <mstevens> cabal: failed to parse output of 'ghc-pkg dump'
06:01:21 <luite> but I have no idea if this is a bug in happstack-data, cabal, ghc, syb-witch-class or something else
06:01:28 <Axman6> EvanR: my advice about unsafePerformIO is to only use it for what it was designed for: FFI bindings to functions you know are pure
06:01:35 <dcoutts> mstevens: ok, so you're using 0.6.2
06:01:49 <mux> dcoutts: I started having problems with cabal-install 0.8.0 - someone is calling fromFlag when flag is NoFlag
06:01:50 <mstevens> dcoutts: well now I listened to you and installed 0.8, and things seem to be working better
06:02:01 <Saizan> luite: at the link level i'd bet ghc
06:02:03 <mux> dcoutts: I'm seeing that for instance when trying to update the HTTP package
06:02:15 <dcoutts> mux: yes, that happens with upgrade, use install as the workaround for the moment
06:02:22 <EvanR> Axman6: i saw someone use it to load a config file...
06:02:22 <mux> ah, ok, cool :-P
06:02:24 <mux> dcoutts: thanks.
06:02:35 <Axman6> EvanR: i wouldn't do that
06:02:43 <Axman6> in face, that's a horrible way to use it
06:02:51 <Axman6> don't ever do that!
06:03:00 <nha_> man this sucks, this giant tree keeps getting rebuilt everytime the datatype its inside of is modified
06:03:09 <nha_> why doesnt it just use the old value
06:03:15 <dcoutts> mstevens: yes, 0.6.4 is the one that it was telling you was available, that's the version that knows that it does not work with ghc-6.12, but you'd already upgraded to 6.12 before there was a chance to fix anything
06:03:21 <copumpkin> you don't even need unsafePerformIO for pure FFI
06:03:36 <Axman6> you don't?
06:03:45 <dcoutts> copumpkin: it's kind of implicit
06:04:08 <copumpkin> ah
06:04:22 <mstevens> Anyone know where Signals.h is meant to come from?
06:04:43 <dcoutts> mstevens: sounds like you're tring to reinstall the unix package, I suggest not doing that.
06:04:49 <aep> hm how do i actually access records from record types inside a function?
06:04:55 <mstevens> dcoutts: I was trying to "cabal install darcs"
06:05:10 <aep> record.foo doesn't appear to be correct
06:05:22 <EvanR> aep: use the accessor methods auto defined by record syntax
06:05:25 <dcoutts> mstevens: if you add --dry-run it'll tell you what it's going to do, not everything will build with 6.12 yet
06:05:27 <Saizan> aep: you use the field names as accessors
06:05:41 <dcoutts> mstevens: if it needs the older unix package, that may well not build with 6.12
06:06:05 <Axman6> aep: foo record
06:06:11 <Saizan> aep: if youde data Foo = Foo { x :: Int} then     x (Foo {x = 1}) == 1
06:06:11 <aep> aah
06:06:22 <mstevens> dcoutts: it's not so bad, xmonad was the bit I wanted to use soon
06:06:39 <aep> Saizan: yes that works, but requires defining a new function for each access
06:06:40 <EvanR> aep: thats the update syntax?
06:06:50 <Saizan> aep: it's already defined
06:06:50 <EvanR> aep: they are already defined for you
06:07:02 * aep puzzled
06:07:11 <EvanR> Saizan: i was directing the second to last thing at you ;)
06:07:38 <Saizan> EvanR: Foo {x = 1} is a way to construct a value of type Foo
06:07:40 <Raevel> aoeu
06:07:43 <Raevel> oops
06:07:45 <EvanR> yes
06:08:10 <aep> aye cool.   Foo { x::int}     x m where m is Foo  just works
06:08:18 <Axman6> aep: record syntax provides you with accessor functions for free
06:08:28 <aep> yeah
06:08:35 * mstevens pokes at ftp.uk.debian.org, which doesn't seem to love me anymore
06:08:48 <EvanR> and m {x = 5} returns the m with x updated to 5
06:09:54 <aep> ah yeah, that leads me to another question. i cant actually modify a value in a record can i? i have to create a new one and return it
06:10:02 <dcoutts> Axman6, mux: ok, fixed the fromFlag error in upgrade, thanks for the report.
06:10:13 <EvanR> aep: well you dont have to
06:10:20 <EvanR> haskell does it for you
06:10:22 <Axman6> dcoutts: what was the problem btw?
06:10:37 <aep> problem is, i have a function which expects a function which only returns ()  but i need to modify the state inside that
06:11:09 <Axman6> only returns ()?
06:11:18 <Axman6> that function can't do anything then
06:11:20 <byorgey> a function which returns () is useless.
06:11:24 <byorgey> in Haskell, at least.
06:11:32 <dcoutts> Axman6: missing basic defaults
06:12:02 <dcoutts> Axman6: we make the flags from basic defaults, config file, command line. We were doing that for install but missed the base ones for upgrade.
06:12:05 <aep> hm.. well, i'm not sure. getKey :: MonadIO m => m () -> m Key
06:12:09 <Twey> Except for type-level programming ;)
06:12:34 <EvanR> aep: functional programming. you cant have a function which secretly updates something somewhere
06:12:37 <aep> i dunno what that does. but ( getKey someFn) works where someFn returns ()
06:12:40 <Axman6> ah, righto
06:12:41 <Twey> aep: That's not a function
06:12:45 <Twey> It's a monadic value
06:12:53 <EvanR> aep: unless its IO
06:12:56 <Saizan> nha_: maybe you bumped into this? http://hackage.haskell.org/trac/ghc/ticket/2284
06:13:00 <aep> ok now its getting to the monad part again which i never understood :(
06:13:59 <aep> got any document for me to read about monads? most of those i read are kindof blurry describing it
06:14:22 <Jonno_FTW> @src drop
06:14:22 <lambdabot> drop n xs     | n <= 0 =  xs
06:14:23 <lambdabot> drop _ []              =  []
06:14:23 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
06:14:25 <EvanR> aep: it returns m Key, not (), so at least you can start there
06:15:24 <ketil> THERE!  After 32 minutes and 900K elements, the Bloom filter has caught up with the Set, which had a 220 minute head start.
06:15:52 * Twey chuckles.
06:16:08 <Saizan> aep: http://www.haskell.org/haskellwiki/Monads_as_computation
06:16:13 <ketil> Set: 1.3K elements/minute, BF still at 30K. (And yes, it is of course minute, not per second)
06:16:16 <Axman6> aep: my experience with monads is that they're easier to use than explain/understand
06:16:16 <aep> thanks
06:16:17 <Saizan> ?google you could have invented monads
06:16:19 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
06:16:19 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
06:16:22 <Twey> aep: Have you read RWH yet?
06:16:27 <Twey> Monads As Computation is very good, too
06:16:31 <Saizan> aep: that one too ^^^
06:16:31 <aep> no. whats that?
06:16:43 <Twey> @where rwh
06:16:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:16:56 <aep> ah that. yeah didnt get it
06:16:59 <aep> i'll try again
06:17:34 <Twey> Start at the beginning — don't jump into the section on monads
06:18:05 * mstevens has been reading RWH, good so far
06:21:59 <romand> hi, guys. where can I read anout those ReadS, ReadP and CharParser from Parsec and their relationships?
06:22:03 <romand> *about
06:23:07 <Absolute0> When I do :info Functor, [] is not an instance of Functor. but fmap works on lists. How come?
06:23:15 <Absolute0> :info Functor
06:23:39 <Absolute0> nevermind it is
06:23:43 <Absolute0> I think i am going blind
06:23:44 <Absolute0> :)
06:30:18 <Saizan> :info sometimes lies
06:30:29 <copumpkin> :misinfo
06:47:42 <EvanR-work> someone say something >_<
06:47:48 <Axman6> no
06:48:25 <copumpkin> something
06:50:43 <EvanR-work> @hoogle priority queue
06:50:44 <lambdabot> No results found
06:51:23 <burp> > text "\195\382"
06:51:24 <lambdabot>   Ãž
06:51:30 <burp> > text "\195\158"
06:51:32 <lambdabot>   Ã
06:51:47 <Axman6> rarg
06:52:10 * EvanR-work gets washed away
07:00:45 <burp> > text "\222"
07:00:46 <lambdabot>   Þ
07:03:56 * hackagebot upload: ls-usb 0.1.0.3 - List USB devices (RoelVanDijk)
07:07:17 <Absolute0> anyone knows when http://learnyouahaskell.com/ will come out with the monad chapters?
07:07:25 <copumpkin> only BONUS
07:07:51 <dumael> Does anyone know if the author(John Meacham) of Jhc frequents this channel?
07:07:52 <Raynes> Absolute0: Sometime last summer, IIRC.
07:07:59 <Raynes> BONUS has forsaken us.
07:08:04 <Absolute0> Raynes: well its not on the page..
07:08:08 <Absolute0> it's in the pdf?
07:08:38 <Raynes> Absolute0: He said that he was going to try to finish it by the end of the summer, I believe.
07:08:40 <Raynes> But he didn't.
07:08:51 <Raynes> As I said, BONUS has forsaken us. x_x
07:09:27 <siki> dumael: no, but he's always on Gale.
07:09:47 <Absolute0> thats a kick ass tutorial by the way
07:10:04 <Absolute0> the guy probably read some pyschology literature on education
07:10:05 <Absolute0> :-P
07:10:27 <dumael> siki: thanks.
07:10:48 <siki> dumael: former classmate of mine.
07:10:50 <Raynes> Absolute0: Or he just read _why's guide to Ruby and/or knows from experience how easy it is to learn when you're having fun doing so.
07:11:10 <dumael> siki: ah.
07:11:41 <Absolute0> ruby guys seem to gravitate towards haskell for some reason.
07:12:00 <Absolute0> both languages seem smart and elegant maybe thats why
07:12:03 <Raynes> Absolute0: Because Haskell is the logical step up from Ruby.
07:13:54 <EvanR-work> eh? ruby seems like a better python
07:14:09 <Absolute0> Do people work on haskell in the US?
07:14:22 * EvanR-work is in US
07:14:57 <Absolute0> http://www.gla.ac.uk/
07:15:03 <Absolute0> that domain is uk :)
07:15:07 <Absolute0> and so is the schoool
07:15:09 <mstevens> EvanR-work: a worse python from my point of view :)
07:15:19 <Raynes> Oh hell.
07:15:36 <dcolish> its pretty the opposite of python
07:15:44 <Absolute0> mstevens: agreed
07:15:47 <Twey> Raynes: Now look what you've done!
07:15:47 <Raynes> Not the "RUBY. NO PYTHON. NO RUBY. NO PYTHON. PYTHON BETTER RUBY SUK. RUBY BETTER PYTHON SUK."
07:16:19 <Absolute0> well ruby is just not consistant
07:16:28 <Absolute0> you have monkey patching and a lot of duplications
07:16:52 <dcolish> thats a vague way to sum up anything
07:17:00 <Saizan> stay on topic, please. this could go on for hours :)
07:17:03 <Absolute0> length size both do the same exact thing
07:17:19 <Absolute0> there are 3 functions for each purpose that are equivalent
07:17:27 <Absolute0> and extending classes at runtime is just evil
07:17:35 <mauke> well, you know python's motto: TMTOWTDI
07:17:39 <Twey> Python allows that, too ;)
07:17:59 <Raynes> This discussion should move to #getoveryourselvesbothofthemsuckcomparedtohaskell
07:18:11 <dcolish> heh
07:18:19 <Absolute0> mauke: is it?
07:18:20 <Twey> Hehe
07:18:24 <mauke> IT IS NOW
07:18:28 <Twey> :-D
07:18:30 <EvanR-work> which is why 'haskell is a step up from ruby' makes no sense ;)
07:19:07 <Axman6> ?
07:19:11 <Axman6> sure it does
07:19:11 <Raynes> EvanR-work: Not sure I understand what you're saying.
07:19:13 <Absolute0> haskell seems like a programmers playground
07:19:19 <Absolute0> a lot of it are cool thought experiments
07:19:21 <Saizan> that sentence means that it's better than ruby
07:19:37 <Raynes> I can say, with lot's of confidence, that Haskell is a wildly better language than Ruby.
07:19:49 <EvanR-work> right a lot more than a step up
07:19:59 <EvanR-work> its completely different!
07:20:03 <Raynes> EvanR-work: Er...
07:20:09 <Raynes> How vague...
07:20:12 <mstevens> Haskell feels like it will be so excellent once I grok
07:20:20 <shapr> I agree
07:20:26 <Absolute0> mauke: i think TMTOWTDI is more ruby/perl than python
07:20:35 <EvanR-work> Raynes: why are you asking me, im not the one who said it
07:20:41 <shapr> Python is about one best way to do things.
07:20:41 <Axman6> mstevens: it is
07:20:43 <mstevens> python is more "there's onoly one way to do it"
07:20:46 <shapr> Perl is about many good ways to do things.
07:20:51 * Raynes rubs his head.
07:21:20 <Absolute0> EvanR-work: shouldn;t you be working? :-P
07:21:27 <shapr> I'm not sure how to describe Haskell. It's something different.
07:21:43 <mstevens> Axman6: so far in my readings I have particularly liked pattern matching on arguments and guards and things. But there is still much of RWH to digest.
07:21:43 <Absolute0> shapr: try FP
07:22:01 <shapr> Absolute0, Yeah but does that mean one or many ways to do things? I'm not sure exactly.
07:22:30 <Absolute0> shapr: i'd say its closer to one
07:22:32 <Raynes> shapr: In my experience, there tend to be several ways to do the same thing, depending on how complex you want the code to be.
07:22:33 <shapr> In any case, I do enjoy writing Haskell, though I haven't written much lately.
07:22:39 <Raynes> I disagree with Absolute0.
07:22:47 <Raynes> It's obviously several.
07:22:48 <Absolute0> everything is a function
07:23:02 <EvanR-work> Absolute0: nah
07:23:03 <Absolute0> in other languages you can go procerdural oop
07:23:15 <Absolute0> procerdural or oop
07:23:41 <mstevens> It's interesting, once you start thinking about FP a little you start seeing how many bugs in other languages come from mutable state.
07:23:56 <dcolish> Raynes: you've probably seen the evolution of a hs programmer :)
07:24:02 <Absolute0> mstevens: make everything immutable :)
07:24:14 <copumpkin> next step, encode all your behavior in your types
07:24:17 <mstevens> Absolute0: That's what started happening to my java :)
07:24:19 <Jafet> Actually bugs in other languages stem more from ugly semantics
07:24:25 <aep> what does => mean in a type?
07:24:30 <Axman6> mstevens: yes indeed. the more haskell you do, the more you'll think people who use other languages are insane :P
07:24:39 <EvanR-work> aep: the left side tells what type variables are
07:24:44 <Raynes> dcolish: I'm still going through that evolution.
07:24:44 <Axman6> aep: a type constraint
07:24:45 <EvanR-work> Monad m =>
07:24:46 <Axman6> :t (+)
07:24:48 <lambdabot> forall a. (Num a) => a -> a -> a
07:24:49 <mstevens> Axman6: well I'm conflicted, the way of lisp also seems strong
07:24:52 <Raynes> Why did I just try to tab-complete evolution? :\
07:24:57 <mauke> aep: it separates class constraints from the rest of the type
07:25:01 <Absolute0> aep: (Enum a) => a, a is an instance of the Enum typeclass
07:25:03 <Axman6> mstevens: pfft. too many brackets
07:25:04 <dcolish> Raynes: arent we all !
07:25:09 <aep> ah great thanks
07:25:59 <Raynes> I love Lisp. I'm a Clojure guy as well as a Haskell guy. I love parentheses.
07:26:16 <Absolute0> How elegant do gui frameworks behave in haskell? Do you just step into monads and do everything procedurally?
07:26:24 <Jafet> > (if ((/=) ((+) 1 1) 2) then (True) else (and ((:) (True) ((:) (False) []))))
07:26:25 <lambdabot>   False
07:26:30 <mauke> "monads" does not mean procedurally
07:26:33 <copumpkin> (C((L(O(J)U)R)E)
07:26:52 <Absolute0> mauke: well its a way of simulating procedural code.
07:26:53 <Raynes> copumpkin: You mismatched a bracket there.
07:26:53 <dcolish> you forgot a paren i think
07:26:58 <mauke> Absolute0: no
07:26:58 <Raynes> :)
07:27:01 <Axman6> Absolute0: monads aren't about doing things procedurally
07:27:02 <copumpkin> I was trolling :P
07:27:09 <Raynes> copumpkin: Troll better.
07:27:10 <Raynes> :D
07:27:10 <Absolute0> ok sequencing..
07:27:13 <Saizan> Absolute0: there are almost direct bindings like gtk2hs as well as higher level libs, though the former is the most robust so far
07:27:13 <Absolute0> whats the difference?
07:27:23 <mstevens> haskell web dev is the bit that interests me
07:27:24 <copumpkin> Raynes: it's like the people who say "trolling is a art"
07:27:44 <burp> http://hackage.haskell.org/packages/archive/iconv/0.4.0.2/doc/html/Codec-Text-IConv.html#v%3AconvertStrictly <- this is somehow strange, the error is output in the right part of Either
07:27:47 <Axman6> Absolute0: couldn't tell you, but monads aren't about procedural programming :P
07:27:50 <Saizan> monads are not even about sequencing, really
07:27:50 <Absolute0> mauke: define the behavior of monads?
07:27:54 <mauke> Absolute0: no
07:27:59 <copumpkin> burp: then they're silly
07:28:00 <mauke> every monad has a different behavior
07:28:20 <dcolish> i find the "what a monad is not" page really helpful
07:28:26 <Axman6> burp: email the author and chastise them
07:28:31 <EvanR-work> monads are a pattern
07:28:56 <copumpkin> dcoutts: that's odd. Why is the error in the Right of the Either in that package? (iconv)
07:29:02 * EvanR-work is sufficiently general so cant possibly be wrong
07:29:04 <Saizan> monads are a way to compose functions with "richer" results, so they are as much about sequencing as (.) is
07:29:54 <Twey> . is very much about sequencing
07:29:57 <Twey> In fairness
07:29:59 <Absolute0> well "do" blocks seem to be akin to procedural code
07:30:07 <Jafet> Monads are functors with bind and return
07:30:08 <Axman6> is there any reason that monad do notation could not be applicative do notation?
07:30:19 <Jafet> @src Monad
07:30:20 <lambdabot> class  Monad m  where
07:30:20 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
07:30:20 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
07:30:20 <lambdabot>     return      :: a -> m a
07:30:20 <lambdabot>     fail        :: String -> m a
07:30:30 <Jafet> And fail, of course.
07:30:41 <copumpkin> Axman6: you could have that, but you wouldn't be able to refer to x <- until the last statement
07:30:54 <Axman6> fair enough
07:30:56 <copumpkin> fail is fail
07:31:09 <Raynes> fail fail is fail.
07:31:24 <EvanR-work> > repeat "fail"
07:31:25 <lambdabot>   ["fail","fail","fail","fail","fail","fail","fail","fail","fail","fail","fai...
07:31:37 <Twey> > repeat $ fail "fail"
07:31:38 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:31:38 <lambdabot>    arising from a use of `M3297563135...
07:31:46 <copumpkin> > [0..] >>= join replicate
07:31:47 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
07:31:50 <Twey> Arising from a use of *what*?
07:31:54 <EvanR-work> why did you use M3297563135!
07:31:56 <copumpkin> what what?
07:32:24 <Twey> copumpkin: That's cute
07:32:37 * Twey approves
07:32:43 <copumpkin> :)
07:33:36 <Axman6> > join replicate `fmap` [1..]
07:33:37 <lambdabot>   [[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8,8...
07:34:03 <copumpkin> > join (join replicate `fmap` [1..])
07:34:04 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
07:34:26 <aavogt> > join replicate =<< [1..]
07:34:27 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
07:34:35 <copumpkin> pff
07:34:57 <aavogt> oh, been done already
07:35:54 <EvanR-work> > reverse [1..]
07:35:57 <aavogt> haskell is all over the place with whether you read left to right or right to left
07:35:58 <lambdabot>   mueval-core: Time limit exceeded
07:36:20 <EvanR-work> mine would have been so much cooler
07:36:41 <Saizan> [\omega, \omega - 1, ...]
07:36:59 <Axman6> @src (=<<)
07:37:01 <lambdabot> f =<< x = x >>= f
07:37:11 <Axman6> ^^ my favourite definition ever
07:37:18 <EvanR-work> o_o
07:37:23 <dcolish> palindrome!
07:37:30 <Twey> Hehe
07:37:39 <aavogt> @src (<=<)
07:37:40 <lambdabot> Source not found. Where did you learn to type?
07:37:40 <EvanR-work> someone should make a syntax where all code was like that
07:37:46 <aavogt> @src (>=>)
07:37:46 <lambdabot> Source not found. Sorry.
07:37:52 <Axman6> > let o =<< x = x >>= o in join replicate =<< [1..]
07:37:55 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
07:40:14 <aavogt> > transpose $ join replicate `fmap` [1..]
07:40:15 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:40:29 <aavogt> > tail $ transpose $ join replicate `fmap` [1..]
07:40:30 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:40:45 <copumpkin> fancy
07:41:07 <aavogt> > map take 5 $ transpose $ join replicate `fmap` [1..]
07:41:08 <lambdabot>   Couldn't match expected type `a -> b'
07:41:08 <lambdabot>         against inferred type `[[a1] ...
07:41:14 <aavogt> > map (take 5) $ transpose $ join replicate `fmap` [1..]
07:41:15 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
07:41:23 <mxc> hi
07:41:36 <mxc> was the current situation with MTL vs Transformers?
07:42:05 <aavogt> you can have no problems to have both installed
07:42:33 <aavogt> it is convenient to have one hidden:   ghc-pkg hide transformers
07:42:34 <EvanR-work> Transformers vs G.I. Joe
07:42:45 <mxc> say you were starting a new project, any reason to go w/ one over the other?
07:43:17 <aavogt> I think transformers requires you to use more lift
07:43:35 <aavogt> there are other monad libraries though
07:43:51 <Jonno_FTW> @src join
07:43:51 <lambdabot> join x =  x >>= id
07:44:00 <Jonno_FTW> :t join
07:44:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:44:35 <mxc> if i've been using MTL before, any compelling reason to switch?
07:44:43 <aep> ok i've read about monads now and i fail to see why one is used here. shouldnt it rather take a function as parameter? http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/UI-HSCurses-CursesHelper.html#v%3AgetKey
07:45:28 <aep> the documentation says it wants a function, but the type clearly shows it takes a monad.  for what purpose?
07:46:20 <benmachine> aep: sounds like the documentation is misleading
07:46:50 <benmachine> it's an action, not a function, by the sound of it
07:46:53 <aep> yeah the docs are really bad. i guess i shouldnt start learning haskell with it :/
07:46:56 <dmwit> aep: Just s/function/action/ and the documentation is clear.
07:47:17 <aep> hmm.
07:47:35 <dmwit> (...to me, anyway)
07:48:01 <aep> it takes an action which results in nothing and returns an action which results in a key?
07:48:12 <benmachine> dmwit: except that the documentation of start doesn't discuss the problem at all
07:48:24 <aep> makes sense, but how do i get to do side effects from within the action it takes then?
07:48:34 <benmachine> within?
07:48:45 <dmwit> aep: The action can be any MonadIO monad, so just do the side effects.
07:48:48 <aep> well its a "callback".  i need to handle stuff within it
07:48:49 <dmwit> Not sure what you're asking.
07:48:51 <dmwit> :t liftIO
07:48:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:49:18 <aep> i need to operate on some sort of state engine in it, to actually resize a window
07:49:23 <michaelh> is there a pdf version of learnyouahaskell?
07:49:27 <aep> if i understand correctly
07:49:28 <michaelh> or otherwise downloadable
07:49:46 <michaelh> nevermind
07:50:01 <michaelh> < rtffaq
07:50:42 <Saizan> aep: suppose you've messWithEngine :: Engine -> IO (), and (engine :: Engine), then you can say "getKey (messWithEngine engine)" which will be of type IO Key
07:50:45 <aep> the problem is:  during the getKey function, the OS may throw a SIGWINCH, which results in the action to be run
07:51:01 <lhoersten> it seems wierd that I can't have two data types with the same record syntax function names
07:51:13 <EvanR-work> aep: use catch to handle io exceptions
07:51:14 <aep> Saizan: aah! thanks
07:51:27 <lhoersten> can't it figure out the two functions are different based on the type of the datatype being passed into the function it's creating?
07:51:51 <EvanR-work> lhoersten: put them in two different modules
07:51:54 <dmwit> lhoersten: The complaint has been raised often.
07:52:06 <dmwit> lhoersten: There's even a proposal to H' to fix it.
07:52:06 <Saizan> lhoersten: often the type of the argument is recovered by the functions you use on it
07:52:14 <dmwit> lhoersten: It hasn't been accepted yet. =/
07:52:46 <IceDane> isn't that basically function overloading?
07:52:48 <lhoersten> splitting between two different modules should get around it?
07:52:52 <Saizan> you can use different modules
07:52:54 <lhoersten> thanks
07:53:01 <lhoersten> dmwit: H'?
07:53:08 <dmwit> IceDane: Yep; so are type classes.  (And the proposal is framed in terms of type classes.)
07:53:20 <dmwit> lhoersten: Haskell', the fictitious next version of the Haskell spec.
07:53:23 <lhoersten> ah
07:53:25 <lhoersten> haha
07:53:28 <Saizan> type classes are more behaved overloading than this.
07:53:31 <lhoersten> dmwit: you were at hacphi right?
07:53:35 <dmwit> I was!
07:53:44 <lhoersten> eh I sat behind you =)
07:53:47 <dmwit> I just released the library I started there, in fact. =)
07:53:51 <dmwit> oh hai!
07:53:52 <lhoersten> awesome
07:53:58 <lhoersten> what was the library?
07:54:02 <dmwit> ?hackage sgf
07:54:03 <lambdabot> http://hackage.haskell.org/package/sgf
07:54:05 <lhoersten> awesome
07:54:09 <lhoersten> daniel right?
07:54:12 <dmwit> daniel
07:54:30 <dmwit> Remind me...?
07:54:37 <lhoersten> Luke
07:54:44 <aep> Saizan: hm but parameters are passed by copy arent they?  so how do i actually modify the data inside that so it has an effect on the caller?
07:54:54 <dmwit> Were you working on MatLink, or somebody else?
07:55:03 * mxc wanted to go tp hacphi but couldn't :(
07:55:17 <lhoersten> that was someone else. I was just working on random crap =)
07:55:26 <dmwit> oh, ok =)
07:55:34 * dmwit -> work
07:55:39 <dmwit> good luck
07:55:45 <lhoersten> =)
07:56:07 <Saizan> aep: well, they are not really passed by copy, but they are immutable, though since you're in IO you can use mutable references, like IORefs
07:56:32 <aep> uh oh, another new scary concept.
07:56:34 * aep googles
07:57:16 <EvanR-work> aep: having an effect on the caller... you can return something
07:57:26 <aep> i can't, in the callback
07:57:42 <EvanR-work> ah. spooky IO stuff ;)
07:57:43 <Saizan> hscurses has a quite imperative API
07:57:52 <lhoersten> is it not common to mix record syntax and algebraic multiple value constructors in the same type?
07:57:58 <lhoersten> i don't see too many examples of that
07:58:21 <jmcarthur> definitely not common for me
07:58:28 <aep> i have a function (MonadIO m) =>  m () -> m key and i need to modify a global context inside m()
07:58:31 <dons> the year in haskell: http://haskellwebnews.wordpress.com/2009/12/20/the-year-in-haskell/
07:58:34 <Saizan> not very common, but you can, and you can reuse labels among constructors if they have the same type
07:58:34 <dons> enjoy!!
07:58:36 <roconnor> lhoersten: it is not common because that usually leads to partial functions for the "projections"
07:58:41 <lhoersten> it's looking pretty messy
07:58:50 <lhoersten> ah
07:58:58 <EvanR-work> aep: yeah, so the api should have a action maker function for that
07:59:01 <roconnor> dons: why just the year?
07:59:34 <mxc> roconnor: so he can double his reddit karma whoring when he releases the decade in haskell next week :)
07:59:37 <lhoersten> roconnor: a way around that would be defining record types to be used in my algebraic data type?
07:59:38 <aep> nope it doesn't
07:59:43 <roconnor> mxc: I knew it!
07:59:44 <mxc> lhoersten: that seems like a good way to end up with a lot of partial functions
08:00:09 <aep> i wish hscurses had examples :(
08:00:16 <mxc> lhoersten i had a similar stituation.  i found that for me the best thing to do is pull the records out into separate types
08:00:17 <aep> this really makes no sense to me.
08:00:30 <lhoersten> mxc: yeah that's what I think i'll do. Thanks!
08:00:36 <aep> there is no state engine to pass around
08:00:42 <dons> roconnor: well, 20 years is a bit too much work.
08:01:16 <dons> also on proggit http://www.reddit.com/r/programming/comments/ah3v6/the_year_in_haskell/ and ycombinator http://news.ycombinator.com/item?id=1007976
08:01:37 <aep> how would you usually make state engines? i used a record type, but maybe that's wrong
08:02:01 <mxc> and there's the reddit link...
08:02:05 <mxc> :)
08:02:10 <lhoersten> aep: same
08:02:13 <lhoersten> but i'm a n00b
08:02:34 <EvanR-work> aep: that can be hidden by the monad
08:02:44 <aep> its pretty odd to use with the monad stuff
08:03:20 <lhoersten> the State monad is specific for what you want to do I think
08:03:29 <Saizan> aep: i think by default you could just pass http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/UI-HSCurses-Curses.html#v%3Arefresh to getKey
08:04:17 <dons> i'd be interested in feedback on the "year in review". i don't believe we've tried to do this before.
08:04:55 <pozic> dons: why are you so enthusiastic about Haskell? Do you get paid to write all these "OMG, HASKELL IS GREAT"-posts? It is a serious question.
08:05:24 <aep> Saizan: that might make sense, thanks
08:05:53 <shambler_> pozic, no
08:05:58 <dons> pozic: um, no. i don't get paid.
08:06:28 <lhoersten> dons: what's your full-time job?
08:06:32 <dons> but we have some great technology, but have been a very insular community historically, which i wanted to change.
08:06:37 * copumpkin writes OMG HASKELL IZ GRAET posts too
08:06:39 <dons> i'm a researcher at galois.com
08:06:43 <copumpkin> you should see my twitter feed
08:07:08 <lhoersten> dons: is that place pretty much all haskell?
08:07:27 <dons> that's our main dev language, yep.
08:07:32 <lhoersten> reflecting back on galois, the only reason I know about them may be because of you
08:07:34 <dons> the glue for all our projects.
08:07:35 <lhoersten> that's pretty awesome
08:07:41 * EvanR-work votes dons off the island
08:07:44 <Mitar> i would like to make a function which works on any monad based on IO monad ... how could i do that?
08:07:52 <copumpkin> EvanR-work: how come?
08:07:57 <EvanR-work> joking
08:07:58 <Mitar> so that it lifts itself enough times :-)
08:08:09 <luite> liftIO ?
08:08:13 <pozic> dons: it seems a quite interesting kind of post, but if you are not an insider, you would probably want to see more applications.
08:08:40 <Mitar> but it says that types do not match ... i have to do liftIO . lift for example
08:08:46 <pozic> dons: for example using "::" is a Haskell insider thing.
08:08:47 <Mitar> for them to match
08:09:19 <pozic> dons: the fact that these two things are the only comments on it, show it is a good post. Take it as a compliment.
08:09:20 <dons> there's a section on industrial and open source use.
08:09:24 <Jedai> Mitar: You need a type like "(MonadIO m) => stuff -> m otherStuff"
08:09:31 <Saizan> Mitar: you might miss a MonadIO instance
08:09:46 <Jedai> Mitar: then you can use liftIO in that
08:09:49 <Mitar> hmm, thanks, i will try it
08:09:58 <ben0x539> Is IO a MonadIO instance?
08:10:03 <Jedai> ben0x539: yes
08:10:12 <jmcarthur> Mitar: it sounds like a something in your transformer stack is missing a MonadIO instance
08:10:22 <Mitar> i use just StateT
08:10:27 <ben0x539> so are we going to get rid of all the IO a types in the standard library and replac ethem with some sort of MonadIO constraints?
08:10:39 <jmcarthur> Mitar: did you newtype wrap it by chance?
08:10:44 <Jedai> Mitar: StateT s IO a should work with liftIO without problem
08:10:45 <Mitar> no
08:10:47 <Mitar> should I?
08:10:56 <Mitar> i have double StateT
08:11:00 <Jedai> What did you import ?
08:11:03 <Mitar> so StateT around StateT
08:11:06 <pozic> ben0x539: if you want that, upload a package to Hackage, which does that.
08:11:06 <Mitar> is this a problem?
08:11:08 <Jedai> double shouldn't change anything
08:11:18 <saml> [a,b,c,d..] ==> [(a,b), (c,d)..]  is there a name for this?
08:11:20 * hackagebot upload: usb-id-database 0.4.0.1 - A database of USB identifiers (RoelVanDijk)
08:11:23 <Saizan> Mitar: i think pasting the code with types will be more productive :)
08:11:29 <jmcarthur> Mitar: it depends. i was only asking because it might effect what's going on. StateT has a MonadIO instance though, so I don't know what's going on without seeing the code
08:11:35 <jmcarthur> Mitar: hpaste.org :)
08:11:39 <Mitar> i have already broken it apart ...
08:11:41 <saml> > group 2 [1,2,3,4]
08:11:42 <lambdabot>   Couldn't match expected type `[t1] -> t'
08:11:43 <lambdabot>         against inferred type `[[a...
08:11:54 <Saizan> saml: no
08:11:57 <Jedai> saml: not to the best of my knowledge
08:12:03 <Saizan> > group [1,2,2,3]
08:12:04 <Mitar> ok, i will play a little and if i will have still problems i will make an example paste ..
08:12:04 <lambdabot>   [[1],[2,2],[3]]
08:12:07 <Mitar> thanks for now
08:12:09 <copumpkin> saml: generally, converting between lists and tuples is inelegant
08:12:23 <jmcarthur> ben0x539: not every use of IO can be replaced with MonadIO m => m without some hackery
08:12:39 <ben0x539> :<
08:12:41 <saml> xml gives "1,2,3,4"  i need a list of pairs
08:12:42 <Jedai> saml: you have some library that provides [a,b,c,d..] ==> [[a,b], [c,d]..] under the name chunk 2 though
08:12:43 <jmcarthur> ben0x539: for example, bracket. (but there is a library that gets around it somehow...)
08:13:09 <jmcarthur> ben0x539: i think the workarounds involve making yet other type classes
08:13:23 <Jedai> saml: you can use "uncurry zip . halve"
08:13:48 <saml> > (uncurry zip . halve) [1,2,3,4]
08:13:49 <lambdabot>   Not in scope: `halve'
08:13:58 <Jedai> where halve = foldr (\x ~(xs, ys) -> (ys, x:xs)) ([],[])
08:14:10 <Mitar> aha
08:14:14 <Mitar> i see what i did wrong
08:14:16 <Mitar> i defined
08:14:17 <Mitar> io :: IO a -> NXT a
08:14:17 <Mitar> io = liftIO
08:14:19 <pozic> dons: dead link: http://www.jedi-ninja.net/2009/04/20/A-little-fun.html
08:14:19 <HugoDaniel> im using liftM
08:14:24 <Jedai> let halve = foldr (\x ~(xs, ys) -> (ys, x:xs)) ([],[]) in (uncurry zip . halve) [1,2,3,4]
08:14:27 <Jedai> > let halve = foldr (\x ~(xs, ys) -> (ys, x:xs)) ([],[]) in (uncurry zip . halve) [1,2,3,4]
08:14:30 <lambdabot>   [(2,1),(4,3)]
08:14:35 <HugoDaniel> but now i have a large number of arguments, what other function can i use ?
08:14:40 <HugoDaniel> liftM20 ? :P
08:14:52 <burp> ap
08:14:54 <Jedai> > let halve = foldr (\x ~(ys, xs) -> (x:xs, ys)) ([],[]) in (uncurry zip . halve) [1,2,3,4]
08:14:55 <lambdabot>   [(1,2),(3,4)]
08:15:00 <burp> :t ap
08:15:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:15:02 <aavogt> > unfoldr (\x -> case x of a:b:xs -> Just ((a,b),xs); _ -> Nothing) [1,2,3,4]
08:15:03 <lambdabot>   [(1,2),(3,4)]
08:15:04 <Mitar> and used io function ... so i fixed it to NXT StateT type, and then when i wrapped NXT into new StateT io function did not work anymore
08:15:11 <jmcarthur> HugoDaniel: return f `ap` a `ap` b `ap` c
08:15:23 <Jedai> saml: see ^
08:15:36 <jmcarthur> HugoDaniel: and if it happens to be an instance of applicative: f <$> a <*> b <*> c
08:15:38 <Saizan> Mitar: use "io :: MonadIO m => IO a -> m a"
08:15:41 <burp> http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Control-Monad.html#v%3Aap
08:15:45 <Mitar> yes, i know now :-)
08:15:46 <Mitar> thanks
08:16:04 <saml> > unfoldr (\x -> case x of a:b:xs -> Just ((a,b),xs); _ -> Nothing) [1,2,3,4,5]
08:16:05 <lambdabot>   [(1,2),(3,4)]
08:16:40 <HugoDaniel> allright :D thanks
08:16:43 <saml> thanks aavogt and Jedai i wish you a merry new year
08:16:50 <jmcarthur> HugoDaniel: but i'm afraid of functions that have so many arguments. perhaps it would be beneficial to attempt to decompose that massve function somehow
08:17:03 <Jedai> saml: that unfoldr is probably better, merry christmas to you too
08:17:25 <HugoDaniel> jmcarthur: im reading stuff from a huge web form in happstack
08:17:33 <HugoDaniel> :(
08:17:35 <HugoDaniel> i also dislike it
08:17:39 <gwern> you know, I try to buy books by living authors and not pirate them, but 72$ for TAPL is really trying my resolve
08:17:44 <HugoDaniel> but right now im king of in a hurry, so it will have to do
08:17:45 <copumpkin> HugoDaniel: have it take a record
08:17:50 <HugoDaniel> copumpkin: yes
08:17:52 <EvanR-work> past few days ive been here couple people tried to deemphasize the role of monads in haskell. its one of many language features. would it be appropriate to compare monads in haskell to pointers in c, in terms of language-characteristic role (sorry for being vague ;)?
08:17:53 <HugoDaniel> thats what im doing
08:18:09 <gwern> (and used for a mere 47$)
08:18:11 <jmcarthur> copumpkin: you still have to apply the constructor applicatively
08:18:19 <copumpkin> ah
08:18:22 <HugoDaniel> i have a huge record, and then for each value on the record im calling the function to read it from the form
08:18:24 <jmcarthur> i think this is a case that can't be helped
08:18:27 <HugoDaniel> but i have to use `ap`
08:18:36 <HugoDaniel> because its a huge record
08:18:36 <copumpkin> <*>
08:18:37 <HugoDaniel> :/
08:18:39 <copumpkin> :P
08:20:55 <EvanR-work> analogy: 'you have to understand and use (pointers / monads) to get the most out of the language (C / haskell) ?
08:20:58 <EvanR-work> '
08:22:14 <gwern> oh fun, there's a pirated version on an Iranian website
08:22:20 <gwern> seems to have preserved all the diagrams too
08:23:52 <jmcarthur> EvanR-work: the trick is that there isn't much to understand about monads since they don't actually do anything
08:24:22 <jmcarthur> a lesson which is very difficult for a learner to take to heart, i think
08:25:03 <EvanR-work> its more abstract than a pointer
08:25:20 <EvanR-work> so monad transformers are even more abstract. functions which take pointers arent so much
08:26:25 <jmcarthur> EvanR-work: are you implying that the abstraction is what makes it hard, or do you really mean the complexity of the monad transformer abstraction?
08:26:35 <dons> could do with some upmods on the ycombinator post, http://news.ycombinator.com/item?id=1008050
08:27:19 <EvanR-work> jmcarthur: basically we should use the convention that all my statements have understood question marks at the end ;)
08:27:49 <mreh> does anyone understand how haskore Primitives can be untyped?
08:28:20 <mreh> they're generic, to put it another way
08:29:33 <quicksilver> dons: "implementated"
08:29:45 <mreh> > data Primitive note =
08:29:45 <mreh> >          Atom Dur (Atom note) -- a note or a rest
08:29:45 <mreh> >     deriving (Show, Eq, Ord)
08:29:46 <lambdabot>   <no location info>: parse error on input `data'
08:29:46 <lambdabot>   Not in scope: data constructor `Atom'Not in scope: data constructor `Dur'No...
08:29:46 <lambdabot>   <no location info>: parse error on input `deriving'
08:29:51 <mreh> upps
08:29:56 <stevec> hello, I'm reading real world haskell, and i'm stuck on this http://book.realworldhaskell.org/read/using-typeclasses.html#id607949 ... is there an article or a discussion that explains it better? I don't understand the difference between [Char] specializing [a] vs just Char specializing a
08:30:22 <jmcarthur> EvanR-work: you are right that monads are more abstract than C pointers, but i'm not sure i agree with the idea that abstraction accumulates
08:30:30 <benmachine> the typeclassopedia has an arrow from Functor to Pointed
08:30:35 <jmcarthur> EvanR-work: that's why it sounds to me more like you are talking about complexity
08:30:36 <benmachine> how does that work?
08:31:28 <EvanR-work> jmcarthur: perhaps in a heirarchy of abstractions, if we understand the base case (monads) it shouldnt be hard to understand the entire thing piece by piece
08:31:37 <EvanR-work> im only just now getting monads, in any case
08:31:49 <quicksilver> jmcarthur: if an abstraction is good, you don't need to worry about the complexity because it's hidden. If an abstraction fails to hide the complexity we call it a 'leaky' abstraction, don't we?
08:31:51 <jmcarthur> EvanR-work: by definition, an abstraction *hides* underlying details. you shouldn't need to understand the internals
08:32:05 <jmcarthur> quicksilver: exactly my point
08:32:34 <quicksilver> good.
08:32:48 <jmcarthur> EvanR-work: monad transformers are just a way to construct one monad from another. it's not very important to understand how they work until you build one
08:32:54 * quicksilver pats jmcarthur on the back in a cheerful affirmation of mutual understanding.
08:34:04 <EvanR-work> jmcarthur: maybe i just have never had to deal with real abstractions until now
08:34:21 <jmcarthur> EvanR-work: that's the spirit! ;)
08:34:21 <EvanR-work> doing something with truely not knowing the internals
08:34:39 <aep> any idea what "user error -1" means?
08:34:47 <EvanR-work> after doing low down EE and mathematics stuffs, not sure how i feel about it ;)
08:35:00 <EvanR-work>  / physics
08:35:13 <jmcarthur> EvanR-work: it feels liberating once you learn to unlearn
08:35:54 <EvanR-work> >_<
08:36:45 <Philonous> EvanR-work: Every library is an abstraction. Surely you don't try to understand every last detail about every library you use?
08:37:22 <EvanR-work> i instantly figure out how it would work all the way down
08:37:30 <burp> physics is abstraction ;)
08:37:30 <EvanR-work> as if doing it myself!
08:37:50 <burp> you don't know the internals =9
08:37:52 <copumpkin> everything we deal with is abstraction
08:37:56 <EvanR-work> its true getting to quantum fields and stuff, you basically have to stop and let it go. but in computers i strive to get it all
08:38:00 <copumpkin> the universe is codata, anyway
08:38:06 <copumpkin> to us, at least
08:38:09 <jmcarthur> there is always a point where you stop and ignore the details. just raise the bar... a lot :)
08:38:31 <lhoersten> mxc: when pulling records out into separate datatypes, do you find access becomes more of a pain with more dimension to your types?
08:38:40 <EvanR-work> its true in math you stop a lot sooner because often theres no fruit in doing stuff like axiomatic set theory ;)
08:38:54 <copumpkin> EvanR-work: the whole point of abstraction is for you to not have to get it all, and specifically for you to not rely on getting it all (because it could change, and you shouldn't have to care)
08:39:01 <mxc> not really
08:39:01 <mxc> f
08:39:06 <mxc> forces you to be more disciplined
08:39:33 <EvanR-work> copumpkin: i dont mind that... i know the abstraction is there and the layer, i just sometimes cant bear to not know stuff
08:39:41 <mxc> so i guess, actually, it does, in the way htat all of haskell's static typing and such makes you more disciplined
08:39:42 <lhoersten> mxc: you can't just pattern match on the value constructor can you? you have to match the whole structure and that's where the worry about partial functions comes from?
08:39:45 <EvanR-work> no problem using the interface as it is
08:39:45 <jmcarthur> EvanR-work: maybe it would help to use more generic ideas. instead of thinking IO, think Monad. instead of StateT, think MonadState
08:40:10 <mxc> dont have to mach the whole structure
08:40:17 <EvanR-work> IO seems to be a special case since you cant write IO in haskell
08:40:24 <lhoersten> mxc: don't you have to wildcard the things you don't use?
08:40:30 <mxc> anyway, hard to discuss abstractly
08:40:33 <jmcarthur> EvanR-work: it's still just a monad
08:41:00 <EvanR-work> thats true, but just a monad doesnt do anything :)
08:41:02 <mxc> yeah
08:41:10 <mxc> i still prefer it that way
08:41:15 <copumpkin> EvanR-work: a monoid is an abstraction. Do you understand the internals, all the way down there?
08:41:21 <EvanR-work> yeah?
08:41:25 <EvanR-work> 0, +
08:41:26 <jmcarthur> EvanR-work: no monad "does" anything ;)
08:41:26 <mxc> i use TH to make accessor fxns which helps in some cases w
08:41:33 <lhoersten> mxc: I mean you cant have 'data A = B C D E' and pattern match 'b'... you have to do '(b c _ e)' in the pattern match
08:41:33 <copumpkin> EvanR-work: you reduced it to a particular example
08:41:36 <lhoersten> ?
08:41:41 <mxc> yeah, you do
08:41:44 <jmcarthur> copumpkin: well, no he didn't
08:41:45 <Philonous> I need a constraint like "forall a. Monoid (w a)". I know that's not possible, but someone mentioned "class Monoid1 m where mappend :: m a -> m a -> ma ; mempty :: m a". Is there already a library that has this?
08:41:52 <copumpkin> jmcarthur: fine
08:41:55 <jmcarthur> :P
08:41:58 <mxc> but when i have big ones, like data A = A B C F  D G EE D  F G ...
08:42:12 <monochrom> > case Just True of Just{} -> 'x'
08:42:13 <copumpkin> jmcarthur: he either just gave me the definition, or was thinking of naturals with 0 identity
08:42:13 <lambdabot>   'x'
08:42:22 <copumpkin> jmcarthur: I assumed the latter :P
08:42:23 <EvanR-work> substitute the symbols
08:42:28 <mxc> and a lot of them, I have TH code that automates everything
08:42:38 <EvanR-work> %, L
08:42:40 <lhoersten> TH?
08:42:40 <EvanR-work> ;)
08:42:41 <jmcarthur> copumpkin: if he just gave you the definition then he understands it as well as he can
08:42:49 <jmcarthur> copumpkin: i say that for his sake more than yours i think
08:43:02 <doserj> Philonous: would MonadPlus work for you?
08:43:07 <copumpkin> jmcarthur: :)
08:43:07 <mxc> brb
08:43:36 <copumpkin> jmcarthur: that was kind of my point, that abstraction, but "knowing it all the way down" often doesn't go much deeper than the definition
08:43:53 <EvanR-work> you can know lots of examples and theorems about monoids
08:43:53 <Philonous> doserj: Unfortunately not.
08:44:03 <EvanR-work> seems deeper
08:44:03 <jmcarthur> copumpkin: "doesn't go any deeper than the definition" ... FTFY
08:44:44 <jmcarthur> EvanR-work: examples are theorems are examples of and constructions from monoids, not any sort of internals
08:44:47 <copumpkin> jmcarthur: the much I was thinking of were notions of free constructions and possible derived facts about an abstraction
08:44:51 <jmcarthur> *examples and theorems
08:45:02 <stevec> anybody? looking for a better explanation for not being able to use instance Name [Char], but having instance Name Char allowed
08:45:16 <EvanR-work> right
08:45:25 <copumpkin> stevec: you need an extension to do [Char]
08:45:34 <copumpkin> FlexibleInstances I think?
08:45:37 <copumpkin> it should suggest one to you
08:45:40 <quicksilver> stevec: explanation? It's not allowed because that's what haskell98 said.
08:45:42 <stevec> yea, i get that, but i'm trying to understand the reason
08:45:53 <jmcarthur> well, i can see how one might see that as gaining a better understanding, but it's not really insight into some sort of implementation
08:45:56 <copumpkin> stevec: haskell98 only likes type constructors with free type variables in them
08:45:57 <stevec> i'm trying to understand the type parameters vs type variables
08:46:00 <EvanR-work> definition is as low as you can go, so what im talking about is correspondence between uses and... something... 'understanding'
08:46:02 <copumpkin> so [a] is ok, [Int] is not
08:46:36 <quicksilver> it is a very conservative rule
08:46:45 <copumpkin> stevec: I'm not really sure what the reasoning is behind it, because as far as I can see it doesn't make typechecking harder either way
08:46:49 <quicksilver> one merit is that it avoids all overlaps except complete duplicates.
08:46:52 <copumpkin> but maybe I am missing something
08:46:59 <quicksilver> so it makes overlap checking easier
08:47:06 <stevec> copumkin, thanks, but why is just instance Something Int allowed?
08:47:22 <copumpkin> there's no type constructor in between
08:47:39 <quicksilver> possibly one merit is subjective; maybe some people felt different instances for [Int] and [Char] "felt wrong" and it "should" be a polymorphic instance for [a]. I'm only guessing there.
08:47:57 <copumpkin> quicksilver: it led to the nasty string show hack :/
08:48:00 <stevec> so, the type for [a] and [Char] is a list for both
08:48:16 <stevec> and type for Int is Int and for a is "parametric" ?
08:48:52 <copumpkin> [a] can be thought of as a type function from a type to another type, a -> [a]
08:48:55 <quicksilver> copumpkin: sure, but FlexibleInstances alone isn't enough to fix it.
08:49:12 <copumpkin> stevec: [Int] is a constant
08:49:15 <quicksilver> copumpkin: you need OverlappingInstances to fix that, and none of the haskell committee were that depraved.
08:49:22 <copumpkin> :)
08:50:05 <stevec> it's {-# LANGUAGE TypeSynonymInstances #-} according to real world haskell
08:50:13 <quicksilver> no, that's something else
08:50:18 <quicksilver> that's for "instance Name String"
08:50:26 <quicksilver> because String is a type synonym for [Char]
08:50:53 <monochrom> {-# -fglasgow-exts #-}
08:50:55 <quicksilver> there are no type synonyms involved in [Char]
08:50:59 <stevec> ok, so there aree two issues, one is allowing synonyms and the other is getting [Char] accepted
08:51:08 <quicksilver> exactly
08:52:45 <stevec> trying to think it through, but i'm still confused... Why is it in,  instance Something Int, Int is not a constant?
08:52:54 <mauke> it is
08:52:56 <quicksilver> it is a type constant, yes
08:52:58 <mauke> but it's not a parameter there
08:53:30 <stevec> i'm specializing class Something to Int by declaring that instance correct?
08:53:37 <mauke> no
08:53:44 <mauke> you can't specialize classes
08:54:01 <stevec> i'm defining instance of class Something for Int?
08:54:05 <mauke> yes
08:54:45 <stevec> and when i go to define one for [a], i'm defining one for a list
08:54:54 <quicksilver> yes, or You are making Int a member of the class Something (by defining an instance)
08:54:56 <gwern> 'Barrelfish OS: Microsoft’s new Barrelfish OS was built on domain specific languages written in Haskell :: PDF'
08:54:59 <gwern> huh. I missed that
08:55:48 <rovar> MS should really be careful to specify MSR vs Microsoft
08:56:11 <rovar> MSR does some cool stuff.. but it's also a vacuum
08:56:49 <stevec> and for lists, i can make list [a] member of class Something, because in that case, i'm already specifying the type of 'a' in class Something a, as type [a]?
08:57:27 <mauke> huh?
08:58:44 <aep> is there an imap lib for haskell?
08:59:02 <gwern> aep: what does hackage say?
08:59:11 <aep> it has a search? hm
08:59:57 <aep> the only one that search finds is haskellnet, which doesnt compile
09:00:10 <aep> and isnt complete anyway
09:00:30 <aep> i guess i need to learn to wrap c libs.  hscurses doesn't work either
09:00:42 <aep> or i'll give up and write it in C..
09:02:13 <EvanR-work> ncurses program, is there any other language to use ;)
09:02:29 <aep> yeah well i wanted to try haskell for the sake of learning haskell :P
09:02:58 <aep> the concept sounded nice, but i can't figure out how to use haskell in real world
09:03:12 <gwern> hscurses is constantly broken. curses is hard to bind
09:03:17 <gwern> although it does work
09:03:32 <aep> how would it work? it has NO drawing operations
09:03:46 <aep> the only one it has crashes with user error -1
09:03:51 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5476#a5476  this is not good
09:03:53 <HugoDaniel> really not good
09:04:44 <stevec> what is the difference between, a, and [a]? Are both type parameters? Is one an actual type? and how is, [a], different from [Char]? again, is one a type parameter and the other a type?
09:04:48 <aep> hmm haskellnet appears to compile from cabal. now i only need to find _any_ docs.  how do you guys usually figure out how things work?  read the source?
09:05:29 <EvanR-work> so far i havent used anything but the prelude ;)
09:05:31 <EvanR-work> its documented
09:05:40 <copumpkin> stevec: [a] is really [] a, where [] is a type constructor like Maybe
09:05:43 <Saizan> stevec: 'a' is a type variable there, [a] is the [] type constructor applied to a type variable 'a'
09:05:54 <aep> EvanR-work: that'll work for non real life use, yes :D
09:06:06 <EvanR-work> i am writing a real life program
09:06:16 <aep> and you can do that with only prelude?
09:06:19 <gwern> aep: look at the programs that use hscurses
09:06:27 <EvanR-work> luckily its a server so only needs network and file IO :)
09:06:34 <Saizan> stevec: the relevant difference between [a] and [Char] here is that 'a' is a type variable while 'Char' is a concrete type
09:06:38 <aep> gwern: tried, there appear to be none
09:06:59 <mercury^> :t reverse
09:07:03 <lambdabot> forall a. [a] -> [a]
09:07:09 <mercury^> :t "olleh"
09:07:10 <lambdabot> [Char]
09:07:11 <aep> EvanR-work: good point. maybe i should learn haskell in a different project. like webserver. that seems to be fairly well documented
09:07:16 <Saizan> aep: we usually look at the haddock docs
09:07:17 <mercury^> > reverse "olleh"
09:07:18 <lambdabot>   "hello"
09:07:28 <Saizan> aep: though i suspect haskellnet to be a binding to C#
09:07:42 <aep> urgs ok
09:07:59 <Saizan> aep: i was wrong :)
09:08:03 <aep> phew
09:08:14 <EvanR-work> aep: there are graphics libs. but maybe learning how to interface directly to c would be good ;)
09:08:21 <Saizan> aep: http://hackage.haskell.org/package/HaskellNet <- if you click on the modules you can find the documentation
09:08:34 <aep> yeah i think haskell might make a better glue language to C stuff
09:08:59 <aep> Saizan: yes i know, but all it lists are types
09:09:21 <aep> so how do you find out where to start? how it actually works? which functions to use for what?
09:10:15 <Saizan> true, not a very good documentation, if i knew the domain i'd probably just guess from the names
09:11:05 <aep> hm okay :/  i'll move learning haskell to webstuff. docs for that seem to be good
09:11:35 <EvanR-work> is the web seriously a popular application for haskell D:
09:13:03 <Jafet> @can Haskell power the Web?
09:13:04 <lambdabot> Maybe you meant: faq map run wn
09:13:10 <Jafet> @faq can Haskell power the Web?
09:13:10 <lambdabot> The answer is: Yes! Haskell can do that.
09:13:44 <EvanR-work> @faq does this thing ever produce negative results
09:13:44 <lambdabot> The answer is: Yes! Haskell can do that.
09:14:32 <Jafet> @vixen Wanna cyber?
09:14:33 <lambdabot> cyber? okay, you start out
09:14:54 <EvanR-work> ._.
09:19:36 <alp_> @vixen Haskell rocks.
09:19:36 <lambdabot> church is my favourite computer scientist.
09:20:42 <danblick> I want to experiment with a tool that can parse haskell code.  Is installing Hugs and using Language.Haskell.Parser in Hugs the best place to start?
09:21:02 <copumpkin> danblick: nope
09:21:05 <copumpkin> haskell-src-exts probably
09:22:21 <danblick> copumpkin: thanks
09:23:38 <BenceF> will you check out wheres the error?
09:23:42 <BenceF> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14807#a14807
09:23:57 <BenceF> i get a parse error on instance
09:24:28 <copumpkin> it's indented wrong
09:24:55 <BenceF> can you point to a good example?
09:25:51 <copumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14807#a14808
09:26:06 <copumpkin> the where is still awfully indented for my taste, but I stuck to your tabs
09:28:25 <BenceF> whats better to indent with? tabs or spaces?
09:28:59 <jlouis> I definitely prefer spaces
09:29:36 <gwern> aep: haskellnet installs for me
09:29:55 <lament> BenceF: spaces, if you want to conform to standard practice
09:30:15 <lament> BenceF: mostly because identation in haskell is variable, it's not a multiple of some number
09:30:25 <lament> *indentation
09:30:40 <BenceF> ok. ill stick to spaces
09:32:19 <BenceF> now its loaded
09:32:32 <BenceF> thanks for the help
09:33:11 <aep> gwern: yup. the cabal package works
09:33:30 <aep> still no docs though and looking at the implementation reveals it will likely not work at all
09:38:48 <Berengal> One thing I like about unfoldr is that in the comments for the step function I can write "stops at nothing"
09:39:19 <BenceF> im workin on my uni's server and sometimes ive got so little memory even vim wont run :(
09:39:50 <BenceF> free : 14308
09:40:04 <BenceF> thats not much
09:40:12 <benmachine> use sed!
09:40:24 <benmachine> that will definitely work instead of making you want to claw your eyes out
09:40:58 <BenceF> however i recently discovered theres nethack on it
09:40:58 <Berengal> I think you're lying
09:41:38 <BenceF> and the highscore is like 2000 points
09:41:47 <BenceF> i could totally beat that
09:42:36 <sproingie> anyone have a usage example for atomicModifyIORef?
09:43:17 <sproingie> i can't figure out what the convention of the modify function is
09:43:28 <sproingie> @type atomicModifyIORef
09:43:29 <lambdabot> Not in scope: `atomicModifyIORef'
09:43:32 <adnz> hello, i have a question... can anyone help me?
09:43:52 <sproingie> duh.  no IO in lambdabot
09:43:59 <sproingie> adnz: go ahead and ask
09:44:31 <adnz> ok, i've been trying to use the sqrt function on an integer x, but it states that x needs to be a RealFrac
09:44:46 <kmc> > let x :: Int; x = 3 in sqrt x
09:44:47 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
09:44:48 <lambdabot>    arising from a use of...
09:44:50 <kmc> > let x :: Int; x = 3 in sqrt $ fromIntegral x
09:44:51 <lambdabot>   1.7320508075688772
09:44:53 <adnz> then i found out that i needed to use the function fromIntegral on x
09:45:01 <adnz> but it still isnt working
09:45:03 <sproingie> > sqrt 3.0
09:45:04 <lambdabot>   1.7320508075688772
09:45:10 <sproingie> that
09:45:19 <sproingie> that's a cheap way to get it as a literal
09:45:25 <sproingie> otherwise use fromIntegral
09:45:34 <lament> yesterday i wrote a little script, all it really did was check for existence of some files and launch vim... so i wrote it in python instead of haskell
09:45:39 <lament> now i feel guilty :(
09:45:48 <adnz> i used sqrt (fromIntegral x), but the compiler still complains
09:46:04 <PeakerWork> lament: what you clearly need is an .hs file that imports the whole world, so your Prelude is as useful as Python's
09:46:15 * sproingie is in numeric type hell now thanks to opengl
09:46:25 <Berengal> adnz: Are you sure that's what the compiler's complaining about?
09:46:28 <PeakerWork> sproingie: lambdabot does allow showing types and stuff of IO stuff
09:46:33 <sproingie> adnz: pastebin the code and the error
09:46:34 <lament> PeakerWork: no, i need some project to work on where haskell makes sense :)
09:46:38 <Berengal> @paste
09:46:38 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:46:46 <adnz> sproingie: ok
09:46:59 <sproingie> @type modifyIORef
09:47:00 <lambdabot> Not in scope: `modifyIORef'
09:47:01 <PeakerWork> lament: I think Haskell makes sense as a scripting language
09:47:25 <Berengal> PeakerWork: Agreed. I use it for small scripts all the time
09:47:32 <sproingie> eh.  anyway, the modify function for modifyIORef is a->a, simple enough.  for atomicModifyIORef it's a->(a,b) which I don't get
09:47:35 <adnz> Berengal: it says "No instance for (Floating Integer) arising from a use of 'sqrt' in...
09:47:44 <Berengal> But I sort of feel guilty for not expressing the problem domain properly with types...
09:48:08 <lament> PeakerWork: i don't :)
09:48:16 <copumpkin>  sproingie you want to return something and modify it in an atomic operation
09:48:26 <copumpkin> @hoogle atomicModifyIORef
09:48:27 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
09:48:29 <PeakerWork> lament: any particular thing that's harder for this purpose?
09:48:42 <sproingie> copumpkin: i get that, i'm using modifyIORef right now
09:48:57 <sproingie> i just don't get what the modify function is supposed to look like for atomicModifyIORef
09:49:16 * sproingie would rather not have to use iorefs at all, but *sigh*, callbacks
09:49:16 <Berengal> sproingie: The b is the return value, e.g. the old a, or something
09:49:25 <lament> PeakerWork: just feels wrong
09:49:26 <copumpkin> sproingie: don't really understand what you don't undersatnd :)
09:49:49 <copumpkin> modifyIORef f = atomicModifyIORef (f &&& const id)
09:49:58 <PeakerWork> lament: it feels wrong while everything is just as easy? :)
09:50:02 <copumpkin> I meant const ()
09:50:04 <copumpkin> :)
09:50:29 <PeakerWork> @type (&&& const ())
09:50:30 <lambdabot> forall b c. (b -> c) -> b -> (c, ())
09:50:52 <PeakerWork> @type (flip (,) const () .)
09:50:53 <sproingie> so for atomicModifyIORef i can specify a different value to roll back to?
09:50:53 <lambdabot>     Couldn't match expected type `a -> b'
09:50:54 <lambdabot>            against inferred type `(a1, a2)'
09:50:54 <lambdabot>     In the first argument of `flip', namely `(,)'
09:50:58 <copumpkin> @type atomicModifyIORef . (&&& const ())
09:50:59 <PeakerWork> @type (flip (,) () .)
09:50:59 <sproingie> like perhaps undefined if i want it to fail?
09:50:59 <lambdabot> Not in scope: `atomicModifyIORef'
09:51:00 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, ())
09:51:12 <Berengal> sproingie: It doesn't roll back. It's the return value
09:51:20 <sproingie> ohhhh
09:51:23 <sproingie> i'm such a dunce
09:51:24 <copumpkin> lol
09:51:26 <copumpkin> :P
09:51:44 <sproingie> normally would return the old value for atomic operations, yes
09:52:16 <sproingie> being that i ignore it anyway i guess i can return unit
09:53:16 <sproingie> @pl \x -> (f x, ())
09:53:16 <lambdabot> flip (,) () . f
09:53:24 <sproingie> mmkay
09:53:36 <copumpkin> &&&
09:53:44 <copumpkin> f &&& const ()
09:53:55 <copumpkin> f &&& id would return the old value and modify it
09:53:59 <sproingie> one of these days i'll think in arrows
09:54:09 <copumpkin> ignore it being arrow
09:54:13 <copumpkin> it's just a handy function for pairs
09:54:30 <Berengal> Function product...ish
09:54:37 <adnz> sproingie: http://pastebin.com/m3a4836e8
09:55:48 <copumpkin> sqrt
09:56:39 <Berengal> adnz: y needs to be the same type as sqrt (fromIntegral x) if you want to compare them. Right now they aren't
09:56:50 <Berengal> You need to fromIntegral y as well
09:57:11 <adnz> ooooooooooooooooooh
09:57:16 <adnz> thank you
09:57:28 <mreh> haskell says: "Soloist.hs:66:0: parse error (possibly incorrect indentation)"
09:57:29 <sproingie> > let y = 2; x = 3 in fromIntegral y >= sqrt (fromIntegral x)
09:57:30 <lambdabot>   True
09:57:37 <mreh> I have no line 66 in my sourcecode
09:58:17 <sproingie> i find i have to pepper my code with type signatures and fromIntegral to make opengl happy
09:58:21 <sproingie> seems older code didn't have to
09:58:23 <BenceF> mreh: then thats the secret ingredient
09:59:05 <BenceF> sproingie: what does your program do?
09:59:09 <mreh> BenceF I think I missed a step in the recipie
09:59:17 <sproingie> BenceF: just redbook examples right now
09:59:28 <sproingie> i'm writing conway's life using an opengl renderer
09:59:37 <sproingie> to get practice writing a tile engine mostly
10:00:03 <BenceF> sproingie: im intrested. if its done can i look at the code?
10:00:13 <sproingie> i'll put it on hackage when i'm done
10:00:21 * EvanR-work wonders what the function to take a conway state and return the next generation looks like in haskell...
10:00:26 <BenceF> sproingie: cool
10:00:40 <sproingie> EvanR-work: take a look at brians-brain in hackage.  it's pretty much like that
10:00:49 <EvanR-work> heh
10:00:59 <sproingie> brians-brain is broken right now because Control.Parallel broke backward compatibility recently
10:01:09 <lament> run some 3d automaton instead!
10:01:10 <sproingie> just s/parArr/parTraverse/ and you're fine
10:01:18 <lament> with awesome translucent cells
10:01:25 <sproingie> better yet take out the parallel stuff because it has absolutely zero improvement
10:02:12 <BenceF> i started to write a Turing-model simulation in javascript
10:02:15 <BenceF> but got lazy
10:02:17 <sproingie> i will probably make cells animate in and out as an FRP project
10:02:25 <sproingie> but right now it's just going to be a simple POC
10:02:38 <BenceF> however i will finish it  after the exams
10:03:06 <BenceF> but it only worked in chrome and safari so far :(
10:03:56 <EvanR-work> sproingie: so youre saying its a parallel algorithm
10:04:00 * chrisdone uses tail-whip
10:04:05 <BenceF> other browsers are lazy on implementing canvas functions
10:04:16 <sproingie> brians brain would look pretty neat if i rendered it as a smoothed polygon
10:04:20 <sproingie> very blobular
10:04:43 <sproingie> i guess so would life, but bb has more "movement"
10:05:20 <sproingie> EvanR-work: it should be an embarassingly parallel algorithm, but i could never get any speedup out of it
10:05:46 <BenceF> cause data sharing?
10:05:50 <sproingie> possibly because the unit of work is so small
10:06:06 <BenceF> i see
10:06:34 <BenceF> id like to get into automatons and modelling
10:06:41 <EvanR-work> brians brain looks cool
10:06:41 <jmcarthur> something like NDP should work well for it since it's supposed to separate the work into reasonably sized chunks
10:06:51 <sproingie> there's a pretty cool blog post showing how to use a CA for pathfinding
10:07:06 <BenceF> link? pls
10:07:08 <jmcarthur> but i haven't had much luck getting NDP to work properly myself. it seems problematic still
10:07:29 <sproingie> basically you fill up corners and dead-ends with cells and what's left is a "hot zone".  if you have only one entrance and exit, it's actually the shortest path
10:07:48 <sproingie> unfortunately he doesn't show any code and he explains the algorithm terribly.  i'll see if i can dig it up
10:08:08 <sproingie> http://realtimecollisiondetection.net/blog/?p=57
10:08:23 <BenceF> my friend , you rule
10:09:04 <BenceF> bookmarked
10:09:21 <sproingie> :)
10:09:32 <sproingie> that whole blog is chock full of cool game programming info
10:09:44 <BenceF> pattern matching last element:  '(a:[])'  is that right?
10:10:13 <tromp__> that's just [a]
10:10:36 <sproingie> i
10:10:39 <BenceF> so [a] will do it?
10:10:40 <sproingie> 'i've seen both
10:10:44 <sw17ch> is there a good way to fake parameterized modules with GHC?
10:10:58 <copumpkin> BenceF: only if it's at the end of a walk through the list
10:11:10 <copumpkin> sw17ch: typeclasses?
10:11:19 <sproingie> i kind of prefer (a:[])
10:11:28 <sproingie> both work
10:11:35 <sw17ch> copumpkin: yeah, i figured that was the answer id' get :(
10:11:39 <lament> :[]
10:11:47 <sw17ch> i really want a parameterized modules extension...
10:11:50 <BenceF> ill stick to (a:[]) i guess
10:11:51 <copumpkin> :)
10:11:55 <sproingie> 8[] nom nom nom
10:12:00 <EvanR-work> lol
10:12:07 <sw17ch> import Foo.Bar (where fun = something; otherfun = somethingElse)
10:12:11 <EvanR-work> OM NOM NOM
10:12:58 <BenceF> using vim through dialup ssh is a whole other experience
10:13:16 <sproingie> CookieMonster := Om {Nom}+
10:13:20 <BenceF> however i could just 4j 5h and stuff
10:15:06 <copumpkin> > cycle "om n"
10:15:07 <lambdabot>   "om nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom nom...
10:15:16 <BenceF> ahhhh now vectors look like vectors
10:15:51 <BenceF> pretty neat
10:16:32 <BenceF> im sure theres a lib for this. but this is the way i like to learn a language
10:17:19 <BenceF> now how do i associate an operator with a function?
10:17:42 <BenceF> like i hav addVector. can i make it + ?
10:17:46 <luite> an operator is a function
10:17:48 <luite> oh
10:17:54 <luite> :t (+)
10:17:55 <lambdabot> forall a. (Num a) => a -> a -> a
10:18:06 <copumpkin> > let (*) = foldr1 in (+) * [1..10]
10:18:07 <lambdabot>   55
10:18:19 <luite> BenceF: you'd need to make your vector an instance of Num, but that doesn't really work
10:18:32 <BenceF> :(
10:18:49 <BenceF> ill try that anyway
10:18:51 <luite> BenceF: because you'd have to support all Num operators, like (*)
10:19:04 <koeien37> yeah. best way to go is to use .+. or something like it
10:19:25 <koeien37> unless you have an algebra instead of a vector space, or if you can live with (*) being undefined. pretty ugly though
10:19:29 <BenceF> can i name my function .+. ?
10:19:34 <koeien37> sure!
10:19:45 <koeien37> let x .+. y = (2*x) + (2*y) in 3 .+. 4
10:19:51 <koeien37> > let x .+. y = (2*x) + (2*y) in 3 .+. 4
10:19:52 <lambdabot>   14
10:19:59 <BenceF> and do i have to `.+.` ?
10:20:03 <koeien37> no.
10:20:19 <benmachine> > let x .+. y = show x ++ y in 7 .+. "bananas"
10:20:20 <lambdabot>   "7bananas"
10:20:22 <luite> BenceF: you could do (.+.) v1 v2
10:20:23 <koeien37> you can name your function .+++++..+ too
10:20:29 <scoo4114> how do I try out lambdabot in a separate win without interrupting the conversations?
10:20:42 <luite> BenceF: if you need prefix
10:20:49 <benmachine> BenceF: as long as the name is entirely symbol characters it's an infix operator
10:20:53 <ziman> scoo4114, just query her
10:21:16 <mmorrow> @bot
10:21:16 <lambdabot> :)
10:21:17 <lunabot>  :o
10:21:26 <BenceF> i get it. so no letters, and i dont need ``
10:21:31 <scoo4114> thanks ziman
10:21:45 <scoo4114> @bot
10:21:45 <lunabot>  :o
10:21:46 <lambdabot> :)
10:24:06 <BenceF> ok. how do i export .+. in the module?
10:24:15 <luite> (.+.)
10:24:19 <BenceF> thx
10:24:36 <luite> BenceF: you may want to use infixl/infixr for your operator, so you can do a .+. b .+. c
10:24:59 <BenceF> looks like boobs
10:25:29 <BenceF> luite: i definetly want
10:25:40 <BlackM> ...boobs? ;p
10:25:59 <BenceF> infixr for right order yes?
10:26:32 <BenceF> BMeph: (.+.) doesnt it?
10:26:39 <Gracenotes> well, same order, but grouped from the right
10:26:45 <luite> right associative
10:26:49 <Gracenotes> a + (b + (c + d))
10:27:02 <BenceF> yeah thats what am going for
10:27:13 * BMeph prefers "stripper-boobs": (.)$(.)
10:27:15 <BenceF> i think
10:27:23 <Gracenotes> more arithmetic operators are infixl. it's a default users might expect for simple operations anyway
10:28:02 <BenceF> im thinkin about deriving from Num
10:28:03 <BMeph> HOw much stuff would break if we made (++) infixr? :)
10:28:04 <BenceF> maybe
10:29:05 <Gracenotes> infixl, you mean? well, thankfully it only accepts parsing. There would nonetheless be a disturbance in the force.
10:29:14 <BenceF> and where infixx goes in syntax? ist like: infixl .+. a b =..   ?
10:29:15 <Gracenotes> *affects
10:29:33 <luite> infixl .+. 4
10:29:47 <luite> where 4 is the precedence level, an integer from 1 to 9
10:29:54 <luite> oops
10:29:56 <luite> flip the arguments
10:30:02 <luite> infixl 4 .+.
10:30:39 <BenceF> so like infixl 4 .+. a b =...   ?
10:30:41 <lhoersten> is there a haskell convention for predicates like java's 'isSomething()' or scheme's 'something?'
10:31:10 <luite> BenceF: no just the infixl line is just a separate line
10:31:12 <BONUS> i have not forsaken anybody!!!
10:31:19 <BONUS> i am just equal parts busy and lazy
10:31:20 <BONUS> : )
10:31:26 <BenceF> luite: ok. got it
10:31:26 <medfly> :)
10:31:53 <Gracenotes> BONUS: we should have known when we gave you that stipend to write LYAH!!
10:32:29 <BONUS> hahaha! i fooled you all!
10:32:40 <BMeph> lhoersten: Java's I'd say.
10:32:44 * BONUS steals christmas
10:32:57 * BMeph cancels Christmas!
10:33:26 <BenceF> ok its pretty fun mixing things to learn, but im getting nowhere fast
10:33:30 * hackagebot upload: xml 1.3.5 - A simple XML library. (IavorDiatchki)
10:33:53 <BenceF> so im gonna leave haskell for a while and concentrate on vectorcalculus only
10:33:58 <BMeph> @remember BONUS i have not forsaken anybody!!!  i am just equal parts busy and lazy
10:34:04 <lambdabot> Done.
10:34:06 <Gracenotes> It is.. remembered?
10:34:12 <Gracenotes> @botsmack
10:34:13 <lunabot>  :o
10:34:14 <lambdabot> :)
10:34:30 <mk64ftw> anyone know where I can ask some random ssl questions?
10:34:45 <BenceF> in the meantime ill download ghc so i dont have to latency jitsu with ssh
10:34:53 <medfly> mk64ftw: you can get away with asking them here
10:35:36 <Gracenotes> o rly
10:36:04 <ystael> Gracenotes: is that "strike bot with open palm" or "shoot bot up with heroin" ?
10:36:21 <mk64ftw> medfly: heh, kind of what I was hoping. basically i was wondering if i need to send a password across a network, i want to use ssl right?
10:36:33 <jlouis> @botsnack
10:36:33 <lunabot>  :o
10:36:35 <lambdabot> :)
10:36:45 <vy> Can anybody help with "Couldn't match expected type `IO [String]' against inferred type `[String]' In the expression: map snd $ filter match headers"  error in http://codepad.org/DHmRkMAl
10:36:56 <Gracenotes> slappin' them bots up
10:37:27 <jlouis> vy: you are in the IO monad, so you need return $ map ...
10:37:27 <mk64ftw> vy: return?
10:38:47 * SamB_XP wonders if it's possible to find a leaner, but still recent, Emacs for NT ...
10:40:43 <vy> jlouis: mk64ftw: Bah! Thanks!
10:41:22 <SamB_XP> vy: what does that actually do?
10:42:58 <sproingie> woohoo, all done with my glbrain
10:44:02 <EvanCarroll> in a typeclass definition are x and y always the compairison values?
10:44:07 <EvanCarroll> for rhs/lhs?
10:44:37 <kmc_> what are x and y?
10:44:43 <EvanCarroll> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
10:44:54 <EvanCarroll> go down to where it says # class Eq a where
10:45:02 <EvanCarroll> is the use of x and y special?
10:45:05 <kmc_> those are just variables
10:45:06 <kmc_> no
10:45:48 <kmc_> it's just like:  fact n = product [1..n]
10:45:51 <kmc_> 'n' is not special there
10:46:02 <EvanCarroll> right, but i see the n in the signature
10:46:03 <kmc_> it's a name bound on the left and used on the right
10:46:09 <kmc_> signature?
10:46:13 <EvanCarroll> fact n
10:46:22 <kmc_> sure, and you see "x == y"
10:46:29 <kmc_> if you like, that's equivalent to "(==) x y"
10:46:38 <EvanCarroll> oh
10:46:41 <EvanCarroll> ok!
10:46:57 <EvanCarroll> one more question then how would you do a ternary operator in a type class?
10:47:05 <kmc_> there are no ternary operators in Haskell
10:47:18 <EvanCarroll> ah
10:47:19 <EvanCarroll> fair enough
10:47:20 <EvanCarroll> thanks
10:47:21 <kmc_> also, operators are not special to typeclasses
10:48:04 <kmc_> infix operators are just an alternative syntax for function application.  a function being applied can live in a typeclass or not, independent of whether it's an operator
10:48:55 <kmc_> also typeclass members needn't be functions
10:48:59 <kmc_> for example maxBound
10:49:01 <kmc_> :t maxBound
10:49:02 <lambdabot> forall a. (Bounded a) => a
10:49:58 <jneira> > take 3 $ repeat "test"
10:49:59 <lambdabot>   ["test","test","test"]
10:50:01 <PeakerWork> you can have "ternary operators" by adjusting the types of 2 operators a and b, such that a :: a -> b -> c ; b :: c -> d -> e
10:50:08 <PeakerWork> > take 3 . repeat $ "test"
10:50:09 <lambdabot>   ["test","test","test"]
10:50:12 <PeakerWork> @src replicate
10:50:13 <lambdabot> replicate n x = take n (repeat x)
10:50:21 <PeakerWork> replicate n = take n . repeat
10:50:26 <jneira> uau my first time using lambda bot
10:50:36 <PeakerWork> > "Congratulations"
10:50:37 <lambdabot>   "Congratulations"
10:50:59 <jneira>  @src? neat
10:51:57 <Philonous> Agda style mixfix operators would be really nifty.
10:51:59 <jneira> better . than $ where possible ..
10:52:14 * jneira testing
10:53:05 <jneira> thnx PeakerWork
10:53:51 <PeakerWork> jneira: (.) is nicer than ($)  because you can "cut & paste" segments into a separate function and they work, because (.) is associative and ($) isn't
10:56:14 <EvanCarroll> "Maybe a" is a concrete type right?
10:56:48 <dons> "concrete" ?
10:56:55 <EvanCarroll> Maybe Int is a concrete even though it is algebraic
10:57:15 <EvanCarroll> Pretty simple. The YesNo typeclass defines one function. That function takes one value of a type that can be considered to hold some concept of true-ness and tells us for sure if it's true or not. Notice that from the way we use the a in the function, a has to be a concrete type.
10:57:24 <dons> Maybe a is the type of values that are Nothing or Just some other type a.
10:57:54 <EvanCarroll> right, I understand that I'm more asking about the parlance
10:58:05 <EvanCarroll> `Maybe Int` is a concrete algebraic type?
10:58:22 <jmcarthur> "concrete" is a strange word
10:58:37 <jmcarthur> Maybe has kind * -> *, Maybe Int has kind *
10:58:41 <dons> what do you mean by concrete? monomorphic?
10:58:45 <dons> Maybe a has kind * too
10:58:52 <jmcarthur> right
10:59:01 <mreh> everything type signature in the haskore documentation is T -> T () -> T
10:59:03 <dons> its just polymorphic, so functions on it have various general properties
10:59:03 <jmcarthur> i bet he does mean monomorphic
10:59:17 <Philonous> EvanCarroll: Where did you read this? Care to share the url?
10:59:33 <gwern> anyone know what option turns off -Wall?
10:59:51 <PeakerWork> I guess Concrete is the opposite of Abstract
10:59:55 <gwern> (-noWall doesn't work)
10:59:56 <jmcarthur> -Bulldozer?
10:59:59 <jmcarthur> ;)
11:00:00 <PeakerWork> Maybe is not an Abstract Data Type -- because it exposes its representation
11:00:00 <dons> -w
11:00:09 <PeakerWork> so I guess Maybe is a Concrete data type
11:00:18 <gwern> (http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html doesn't help either)
11:00:22 <EvanCarroll> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
11:00:45 <mreh> any Haskore geniuses on?
11:01:20 <Berengal> Maybe is a type constructor
11:01:24 <Philonous> "Fonzie says: Aaay! When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of them polymorphic functions, [a] or (Ord a) => Maybe a and stuff. And like, sometimes me and the boys say that Maybe is a type, but we don't mean that, cause every idiot knows Maybe is a type constructor. When I apply an extra type to Maybe, like Maybe String, then I have a concrete type. You kn
11:01:27 <Berengal> type constructors are to types what functions are to values
11:01:47 <gwern> dons: hm. that works. any idea why :unset -Wall doesn't?
11:01:53 <monochrom> Maybe (Maybe ())
11:02:12 <monochrom> Kero (Kero (Keroppi))
11:02:16 <EvanCarroll> re Philonous
11:02:27 <Berengal> I use the simple heuristic that anything that has a value is a concrete type
11:02:48 <jmcarthur> Berengal: data Void is not a concrete type?
11:02:52 <dons> gwern: is it set in a file?
11:02:57 <gwern> monochrom: keropi? isn't that... some anime character?
11:03:06 <gwern> dons: no, I do :set ... -Wall in .ghci
11:03:13 <Berengal> jmcarthur: According to my heuristic, no, but it's just a heuristic
11:03:18 <gwern> dons: I'm trying to hide the noise from my :hlint script
11:03:20 <BONUS> what about _|_
11:03:23 <jneira> <jmcarthur> "concrete" is a strange word <<< abstract too i think :-P
11:03:26 <monochrom> Yes
11:03:35 <Berengal> BONUS: _|_ is a value, not a type
11:03:40 <BONUS> yeah but i mean
11:03:42 <Berengal> BONUS: And _|_ still isn't a member of Maybe
11:03:48 <BONUS> Void can have a value of _|_, can't it?
11:03:54 <Berengal> Right, true
11:04:02 <Berengal> There you go. My heuristic works in haskell :)
11:04:10 <jmcarthur> is _|_ really a value?
11:04:14 <BONUS> i agree with your heuristic :)
11:04:19 <jmcarthur> i guess it is
11:04:20 <increpare> jneira: what relevancy do arrows have here? : P
11:04:32 <Berengal> jmcarthur: Has to be. I can assign it to a variable
11:04:37 <jneira> juas
11:05:35 <jneira> i am coding a hashiwokakero resolver in haskell
11:06:22 <jneira> http://www.nikoli.co.jp/en/puzzles/hashiwokakero/
11:06:23 <BONUS> funny thing, i forkbombed myself like 3 times yesterday while coding some C. i bet that wouldn't have happened in haskell
11:07:12 * Baughn just netbombed himself in haskell
11:07:16 <dum8d0g> hi.. is there somebody who knows how to use parsec?
11:07:21 <jneira> with backtracking but i am stuck wih the performance
11:07:37 <dum8d0g> I mean, I have the parser done, but I don't have a clue how to get the parsed data out of it
11:07:57 <HugoDaniel> hi
11:08:13 <HugoDaniel> if i want to generate haskell within haskell, whats the best thing ?
11:08:31 <Berengal> HugoDaniel: Template Haskell?
11:08:57 <Berengal> HugoDaniel: Depends on useage. Do you want an AST or concrete syntax?
11:09:15 <kmc_> dum8d0g, i do
11:09:18 <PeakerWork> The AST types can generate concrete text easily, can't they?
11:09:24 <kmc_> can you hpaste your parser?
11:09:47 <kmc_> dum8d0g, you may want:  runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
11:09:51 <BenceF> where does ghci gets the editor setting? not from VISUAL thats sure
11:10:19 <kmc_> $EDITOR?
11:10:36 <dum8d0g> I am using 'case parse inputParser fname input of'
11:10:40 * gwern has created a monster! 'let hlint _ = return $ unlines [":unset +t +s", ":set -w",    ":redir hlintvar1 :show modules", ":cmd return (\":! hlint \" ++ (concat $ intersperse \" \" (map (fst . break (==',') . drop 2 . snd . break (== '(')) $ lines hlintvar1)))",    ":set +t +s -Wall"]'
11:10:45 <dum8d0g> which works somewhat alright
11:11:03 <dum8d0g> but now I have Right out -> ... -- and there I have no idea what to write here
11:11:09 <EvanCarroll> BONUS: LYAH needs subchapters lol
11:11:26 <BONUS> EvanCarroll: yeah i agree, i'm adding them actually
11:11:28 <EvanCarroll> http://learnyouahaskell.com/making-our-own-types-and-typeclasses a book in and of itself.
11:11:38 <dum8d0g> It would be nice if the function containing those expressions will return the 'out'
11:11:41 <EvanCarroll> if it wasn't for vimperators inner page bookmarks i would /suicide.
11:11:41 <kmc_> dum8d0g, well, what do you want to do with the result
11:11:42 <kmc_> okay
11:11:47 <kmc_> well, what did you do on the "Left" part?
11:11:50 <dum8d0g> kmc_: send it to another function..
11:11:56 <EvanCarroll> search on the fly almost crashes the browser
11:12:00 <BONUS> going over the old material with my editor and we're adding a lot of subsections and such
11:12:04 <kmc_> dum8d0g, are you familiar with how "case" works in general?
11:12:13 <dum8d0g> kmc_: not so well
11:12:22 <BONUS> and once we're done i'll put those changes up on the main page, along with the changes nice people from the net have warned me of
11:13:11 <jneira> this version works but it's slow and it is my first haskell program.. http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14809#a14809
11:13:42 <kmc_> > let f x = case x of { Nothing -> "nothing to see here"; Just v -> "it's: " ++ v } in (f Nothing, f (Just "Monty Python's Flying Circus"))
11:13:43 <lambdabot>   ("nothing to see here","it's: Monty Python's Flying Circus")
11:14:32 <gwern> kmc_: it's $EDITOR, yeah. ghc srcs call getEnv EDITOR and fallback to notepad on windows
11:14:42 <gwern>    default_editor <- liftIO $ findEditor
11:14:59 <dum8d0g> kmc_: hah.. thats something I thougt.. ok.. I am trying it now
11:15:14 <dum8d0g> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14810#a14810
11:15:19 <dum8d0g> there is the (old) version
11:15:40 <kmc_> dum8d0g, the "case" expression is an expression and so it must evaluate to a value.  each alternative must have the same type, which is the type of the overall expression
11:16:06 <kmc_> so when you say that within "Right out ->" you want to feed out to another function... that's all fine, but what do you ultimately return?  the result of that function? or another one?
11:16:15 <dum8d0g> kmc_: thanks.. I think I know what is the issue now..
11:16:17 <kmc_> and how do you make th Left branch match its type?
11:16:28 <dum8d0g> kmc_: ah.. thats problem I guess..
11:16:29 <kmc_> if you just want the program to die on parse failure, "error" is an acceptable way
11:16:47 <dum8d0g> kmc_: that is some function from System ?
11:17:27 <b0fh_ua> Hi there! Is there any efficient way to implement heap (or ordered queue) in haskell?
11:18:06 <kmc_> dum8d0g, which?
11:18:07 <kmc_> error?
11:18:09 <kmc_> it's in the prelude
11:18:10 <kmc_> :t error
11:18:11 <lambdabot> forall a. [Char] -> a
11:18:14 <kmc_> > error "bleh"
11:18:15 <lambdabot>   * Exception: bleh
11:18:16 <kmc_> > fix error
11:18:17 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:18:20 <dum8d0g> kmc_: ok.. :)
11:18:22 <dum8d0g> thx
11:18:31 <kmc_> note that it can take on any type -- since the evaluation of error never succeeds, its type doesn't matter
11:19:04 <benmachine> :t let x = x in x
11:19:05 <lambdabot> forall t. t
11:20:08 <jneira> :t [1,2]
11:20:09 <lambdabot> forall t. (Num t) => [t]
11:20:39 <jneira> good
11:22:11 <jneira> :set +s
11:22:19 <jneira> :-P
11:22:47 <emile_m> I have some functions with types like "foo :: Get Foo; bar :: Get Bar; ...".  Then,  have a "root" function where one of those "Get a" functions is called depending on value which is fetched from real world in runtime (I already have fixed values associated with that functions).  I guess this is something about dependent types (?).  What can I do in this situation?
11:22:59 <emile_m> Sorry for bothering you guys again.
11:24:34 <chrisdone> oh wait, ghc got shared libraries? awesome
11:25:36 <Saizan> emile_m: you can use Either
11:26:00 <Saizan> emile_m: if condition then Left <$> foo else Right <$> bar
11:26:17 <Saizan> ?type Left
11:26:18 <lambdabot> forall a b. a -> Either a b
11:26:23 <Saizan> ?type Right
11:26:24 <lambdabot> forall b a. b -> Either a b
11:27:04 <dum8d0g> kmc_: I think I know what needs to be done, but I still don't know how to write it :(
11:27:07 <dum8d0g> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14810#a14811
11:27:22 <emile_m> Saizan: I have more than 2 functions, their quantity is about 5-6 and a wish to add more later.
11:27:32 <PeakerWork> dum8d0g: you don't need the "::[Module]"
11:27:55 <dum8d0g> PeakerWork: its for clarity (no?)
11:28:01 <PeakerWork> dum8d0g: No the type is right above there
11:28:07 <dum8d0g> PeakerWork: ok
11:28:18 <PeakerWork> dum8d0g: also, "myerror" is in IO, it has no reason to throw a pure exception - it could throw an IO exception
11:28:26 <Saizan> emile_m: how are you going to deal will all these different types?
11:28:45 <Saizan> emile_m: i mean, what are you going to do with the result of this?
11:28:47 <PeakerWork> dum8d0g: print_modules doesn't need to recurse itself, you could use "mapM" which does this for you.  print_modules = mapM print
11:29:26 <jneira> emile_m: do you want a dynamic runtime dispatch on type?
11:29:51 <PeakerWork> dum8d0g: the result type of parse is Either ... (IO ())?
11:29:53 <dum8d0g> PeakerWork: thanks for comments.. but the main issue is IO b versus [Module] .. :(
11:30:03 <dum8d0g> PeakerWork: yes
11:30:22 <dum8d0g> PeakerWork: Either ParseError [Module]
11:30:28 <PeakerWork> dum8d0g: process_input is not a pure function, it reads files
11:30:38 <dum8d0g> PeakerWork: yes.. I noticed ;)
11:30:51 <PeakerWork> dum8d0g: what are you trying to do?
11:30:52 <dum8d0g> PeakerWork: but I dont know how to get rid of this 'inpurity'
11:31:07 <PeakerWork> dum8d0g: just read the file outside
11:31:07 <emile_m> Something like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14812
11:31:11 <PeakerWork> dum8d0g: and give it the string
11:31:30 <dum8d0g> PeakerWork: its just something like 'cat' but more complicated
11:32:03 <emile_m> jneira: Somehow i suppose this can be done statically.
11:32:29 <lispy> Cale: ping
11:32:40 <PeakerWork> dum8d0g: can you be more specific?
11:33:00 <PeakerWork> emile_m: hmm -- after using the various getters, what does the root function do?
11:33:04 <emile_m> Oh, yes. In that example, x is the someHeader.
11:33:20 <dum8d0g> PeakerWork: its tool for converting modular grammars to classic monolithic grammars
11:33:34 <dum8d0g> PeakerWork: in future it will be parser generator for modular grammars
11:34:06 <dum8d0g> PeakerWork: now I have grammar modules written in files, I have parser, I have data structures, but now I need to pass that AST to something
11:34:10 <lispy> ?botsnack
11:34:10 <lambdabot> :)
11:34:12 <lispy> hmm
11:34:16 <PeakerWork> emile_m: what is the type of getSomeType?
11:34:27 <emile_m> PeakerWork: root is sort of parsing function.
11:35:11 <PeakerWork> emile_m: what do you want to do with "x" of an unknown type?
11:35:17 <PeakerWork> emile_m: what can you do with a value (exists a. a) ?
11:35:32 <Saizan> emile_m: so getSomeType is polymorphic, right?
11:35:45 <emile_m> PeakerWork: getSomeType has one of the types "Get Foo; Get Bar; ..."
11:35:47 <Saizan> emile_m: does it require a typeclass context?
11:36:14 <Saizan> ah, i misread
11:36:14 <emile_m> Yes, I can make them instances of some class.
11:36:23 <PeakerWork> emile_m: oh.. I see, I meant something else, I meant, if you have getSomeType x >>= \st -> ...           -- what can you possibly do with "st"?
11:36:46 <PeakerWork> emile_m: or in other words, what do you intend to do with the result of root/getSomeType?
11:38:54 <emile_m> PeakerWork: I want to construct a value of Root with fields like { size, some, ... } (where "some" is some type which have an instance of class "Some").
11:40:00 <PeakerWork> emile_m: well, whatever it is that is common to all types so that you can actually use it no matter what type you get -- can't you take this common thing - declare a type for that, and have everyone "Get CommonType" instead?
11:40:35 <emile_m> PeakerWork: ... like that http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14812#a14814
11:41:18 <PeakerWork> emile_m: well, lets say you have  class Contained a where getContents :: a -> Contents -- so far so good?
11:41:55 <PeakerWork> if this is the case, then your Root type is isomorphic to a simpler: data Root = Root { size :: Int, contents :: Contents, -- other stuff }
11:42:28 <Saizan> emile_m: you could just have "data AnyContained = forall a. Contained a => AnyC a" and have all of them return AnyContained, in the general case
11:42:30 <jneira> jum it seems a little oop oriented no?
11:44:27 <PeakerWork> emile_m: what is the Contained class in your case?
11:46:05 <mxc> hi
11:46:07 <emile_m> PeakerWork: class Contained a where header :: a -> String; getThis :: ByteString -> Get a
11:46:18 <mxc> my mind is blanking on trying to do osmething which should be simple
11:47:58 <PeakerWork> emile_m: I don't think there's any useful way to use the "a" result of "getThis"
11:48:14 <PeakerWork> emile_m: so I'm guessing only the "header" part is useful in this context?
11:48:31 <emile_m> "header" returns that fixed value for each type, and getThis parses given ByteString with rules specified for type a.
11:49:31 <mxc> say I have a function f :: a -> m b  and I want to make a new function fE :: (Either e a) -> m (Either e b) isn't there a simple, clean way to do that w/out a case statement?
11:50:00 <miguel-hs> :t either
11:50:01 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:50:16 <emile_m> PeakerWork: OK, that is the part where I got into troubles (with getThis)... But, then, how can I call some function that depends on value?
11:51:18 <PeakerWork> emile_m: your "a" type is unknown, what would you do after using "getThis" and getting a value of an unknown type?
11:52:06 <jneira> But, then, how can I call some function that depends on value? >> good question
11:52:14 <PeakerWork> emile_m: I think you can just figure out what you're going to do with these existentially typed values, and then put whatever you need for that, which is not an existential (e.g replace "Contained" with "String" for header)
11:52:16 <emile_m> PeakerWork: I thought I could use "getThis" method to do all dirty work.
11:53:16 <PeakerWork> emile_m: Instead of an existential "a", you had an existential "a" with a (Contained a) context.  The method in question just yields a new value of the exact same type - so it doesn't help you much with getting rid of the existential
11:53:59 <emile_m> PeakerWork: Hmm... I need some datatype which can hold (among others) undefined quantity of that "Root" types.
11:55:02 <PeakerWork> emile_m: but what are you going to do with the existentials in there?
11:55:12 <PeakerWork> emile_m: what is the purpose of these values?
11:55:20 <jneira> mmm like a object that have a list of objects of a abstract class...
11:55:29 <EvanR-work> (what is an existentials?)
11:55:31 <dum8d0g> Please, what is wrong with function 'process_input'? I am still getting ~ expected IO String, inferred [String].. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14815#a14815
11:56:50 <emile_m> PeakerWork: I used existentials there just for holding non-monomorphic datum in a list.
11:57:22 <jneira> <EvanR-work> (what is an existentials?) .. I would like to know too
11:57:30 <emile_m> More specifically, I need to parse some values, transform them, and put it back.
11:57:57 <kmc_> dum8d0g, a "do" block always has type "IO a"  (if you're doing IO)
11:58:12 <kmc_> the return type of process_input should be IO [Module]
11:58:22 <mreh> There are too many "type T" in haskore!!!!
11:59:07 <PeakerWork> emile_m: put it back to a ByteString?
11:59:09 <byorgey> mreh: the intention is that they are to be used qualified.
11:59:14 <kmc_> dum8d0g, a function cannot do IO; it can only return a recipe for doing IO.  that is what a value of type "IO a" represents
11:59:18 <kmc_> dum8d0g, also, this may help you:
11:59:19 <kmc_> :t mapM
11:59:20 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:59:24 <mreh> byorgey: they aren't qualified in the documentation
11:59:28 <kmc_> @bot
11:59:28 <lunabot>  :o
11:59:28 <lambdabot> :)
11:59:31 <emile_m> PeakerWork: Yes.
11:59:37 <PeakerWork> emile_m: then why can't you hold the result ByteString to put back instead of the existential?
11:59:38 <mreh> it makes it hard to read
11:59:47 <byorgey> mreh: indeed, haddock doesn't deal correctly with qualified names apparently
11:59:50 <byorgey> I agree.
12:00:08 <byorgey> mreh: you have to look at the source, unfortunately
12:00:23 <kmc_> dum8d0g, it looks like print_modules and process_input could both be written with mapM
12:00:31 <emile_m> PeakerWork: You mean I should hold ByteString instead of [ExistentialType]?
12:00:37 <mreh> byorgey: yes, that helps, I've only understood it so far by reading the source
12:00:44 <PeakerWork> emile_m: yeah
12:01:25 <dum8d0g> kmc_: Could I ask you to show me how?
12:01:29 <kmc_> dum8d0g, another choice is to define a pure function (not returning an IO action) that does the parsing.  then your per-file case can be written simply as "myparser <$> readFile fname"
12:01:49 <emile_m> PeakerWork: I wish I could use Data.Generics for transformation :)
12:01:52 <kmc_> (<$>) comes from Control.Applicative and is used (in this case) to "lift" a function so it operates on IO-recipes rather than simple values
12:02:04 <byorgey> mreh: Henning Thielemann uses this style with all his packages (haskore, numeric-prelude, ...).  I appreciate the style in principle but the haddock infelicity does make it annoying in practice.
12:02:18 <byorgey> maybe I should look into what would be required to fix haddock so it handles such things better.
12:02:19 <kmc_> dum8d0g, why don't you take a couple minutes to experiment -- i'll be here if you get stuck
12:02:37 <dum8d0g> kmc_: I am experimenting exactly 5 hours now
12:02:45 <dum8d0g> kmc_: within those 50 LOC :/
12:02:49 <kmc_> you can try all this IO stuff in ghci
12:02:51 <mreh> byorgey: It almost feels like he's defining classes, as if we were doing Java
12:03:21 <dum8d0g> kmc_: but I will experiment some more.. I am not going to sleep until I solve it..
12:03:33 <jneira> <EvanR-work> http://www.haskell.org/haskellwiki/Existential_type
12:03:37 <kmc_> dum8d0g, why don't you write the function to load one module
12:03:39 <byorgey> mreh: yeah, one-type-per-file.  It does have some advantages in terms of type class instance management but I forget the specifics at the moment.
12:03:43 <EvanR-work> jneira: thanks
12:03:43 <kmc_> of type:  String -> IO Module
12:04:39 <kmc_> then I think the defn you want for process_input is simply: mapM loadOneModule
12:04:47 <kmc_> you'll want to import Control.Monad
12:05:14 <dum8d0g> kmc_: I will try it out
12:06:07 <kmc_> dum8d0g, do you understand why that function can't have type "String -> Module"?
12:06:38 <dum8d0g> kmc_: because of that readFile which is IO?
12:06:51 <kmc_> right
12:06:57 <mreh> byorgey: his decision to make Primitive polymorphic baffles me
12:07:12 <mreh> Haskore.Music.Primitive
12:07:16 <kmc_> the module you return is not determined solely by the filename you pass in -- it also depends on the state of that file on disk
12:07:39 <kmc_> so you can't make the function return a module.  it has to return an IO-recipe that can produce a module if executed.
12:08:12 <Cale> I haven't read the discussion, but if the only I/O that your function depends on is from readFile, then you could make it a function of the *contents* of the file instead, and separate out the I/O
12:09:18 <lifflander> How would you do that? Wouldn't that function still depend on the state of the file, and therefore it still has to return IO?
12:10:02 <EvanR-work> all programs always depend on some input from IO. doesnt meant every function must return IO a
12:10:19 <Philonous> lifflander: Of yourse you still have to do IO at some point, but you don't have to do it in _this_ function
12:10:27 <lifflander> I got you.
12:10:34 <mreh> the IO functions call the pure functions
12:10:37 <kmc_> lifflander, do { x <- readFile name; return (myPureFn x) }
12:10:48 <mreh> you can make the demarcation between the two solid
12:10:52 <kmc_> or simply: myPureFn <$> readFile name
12:10:54 <mreh> infact, you have to
12:11:04 <kmc_> or:  liftM myPureFn $ readFile name
12:11:14 <vowyer> what does <$> do?
12:11:14 <kmc_> :t  liftM
12:11:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:11:17 <kmc_> :t (<$>)
12:11:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:11:34 <Philonous> vowyer: <$> is just fmap
12:12:08 <jneira> f:: * -> *
12:12:12 <jneira> jumm
12:12:16 <kmc_> vowyer, in this case: <$> is used to apply a function of type (a -> b) to a value of type (IO a) and get a value of type (IO b) back
12:12:38 <kmc_> with respect to the above type, the functor "f" is IO
12:12:46 <kmc_> IO is a monad and every monad is also a functor
12:13:05 <lifflander> What is the point of the functor?
12:13:17 <kmc_> i don't follow
12:13:31 <kmc_> what's the point of functors in general?
12:13:36 <kmc_> or what's the point of IO being a functor?
12:13:48 <lifflander> What is the point of monads being functors?
12:13:56 <EvanR-work> ^ was about to ask this
12:15:01 <byorgey> there's no "point", it's just true by definition =)
12:15:08 <Ferdirand> because they can ?
12:15:09 <Philonous> lifflander: It's just the way it is. Monads provide enough functionality that you can make them a functor.
12:15:21 <Baughn> @join #dfhack
12:15:21 <lambdabot> Not enough privileges
12:15:27 <Baughn> ..d'oh.
12:15:28 <byorgey> a monad is a functor along with some operations which satisfy some extra properties.
12:15:28 <kmc_> lifflander, you can write fmap using only the things present in the Monad typeclass
12:15:30 <lifflander> Okay, I didn't realize the def of functors in haskell
12:15:43 <lifflander> So in that case it makes since
12:15:44 <increpare> Philonous: though technically, because of how type-classes work in haskell, you have to manually make declare them as being isntances of functor
12:15:48 <kmc_> so once you have an idea of functors in the language, you want every monad to be a functor, for consistency
12:16:04 <byorgey> unfortunately, in Haskell it is not required that every Monad is a Functor, but it should be
12:16:05 <Philonous> increpare: Yes. And that's a bloody shame.
12:16:10 <byorgey> and it is true in practice.
12:16:11 <EvanR-work> @src Functor
12:16:11 <lambdabot> class  Functor f  where
12:16:11 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
12:16:16 <increpare> Philonous: bring on the class aliases : D
12:16:23 <sproingie> the practical point of a monad being a functor is that you can use a monad with any function that takes a functor
12:16:39 <sproingie> assuming you created a functor instance, since Monad sadly doesn't do it automatically
12:16:40 <EvanR-work> the fmap in Monad is defined with >>= ?
12:16:45 <PeakerWork> lifflander: anything that has a type parameter that can be changed from "a" to "b" by an (a -> b) function, and satisfies a couple of laws (basically that fmap id = id, and that fmap f (fmap g x) = fmap (f . g) x, is a Functor
12:16:52 <kmc_> EvanR-work, yes, it's just liftM
12:16:58 <Philonous> @src liftM
12:16:59 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:16:59 <tromp__> @src fmap
12:16:59 <lambdabot> Source not found. Wrong!  You cheating scum!
12:17:11 <PeakerWork> EvanR-work: fmap for monads is liftM.  liftM f x = x >>= (return . f)
12:17:21 <increpare> ::t liftM
12:17:23 <Philonous> tromp__: fmap is a class member. There is not unique definition
12:17:24 <EvanR-work> wow
12:17:26 <lifflander> Okay, makes sense thanks for explanation
12:17:29 <increpare> :t liftM
12:17:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:17:33 <kmc_> @unpl \f x -> x >>= (return . f)
12:17:34 <lambdabot> \ f x -> x >>= \ c -> return (f c)
12:17:34 <PeakerWork> @type (return . f =<<)
12:17:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Show a1, SimpleReflect.FromExpr a) => m a1 -> m a
12:17:39 <kmc_> @pl \f x -> x >>= (return . f)
12:17:39 <lambdabot> fmap
12:17:42 <PeakerWork> @type \f -> (return . f =<<)
12:17:43 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
12:18:16 * EvanR-work gets washed away in random type algebra expressions
12:18:28 <zong_sharo> does Network.Socket.SocketOption's NoDelay is O_NONBLOCK?
12:20:02 <tromp__> liftM = (<<=) . (return .)
12:20:13 <vowyer> return is an odd name, why did they use that name?
12:20:20 <dum8d0g> I give up
12:20:35 <dum8d0g> I just dont know how
12:20:35 <sinelaw> has anyone success in compiling with -prof on ubuntu, using the haskell platform?
12:20:46 <sinelaw> i get errors about base not being available with profiling info
12:20:55 <zong_sharo> well
12:21:04 <EvanR-work> vowyer: looks like imperative code
12:21:06 <jneira> to bash imperative guys .-P
12:21:07 <zong_sharo> you need base compiled with -prof
12:21:10 <zong_sharo> my guess
12:21:21 <emile_m> vowyer: Because you *return* some pure (untouched) value in the monad.
12:21:30 <dum8d0g> I just want to read couple files, put them into parser, get the results, process the results and get it to the output
12:21:31 <emile_m> They already told me before :)
12:21:33 <dum8d0g> but haskell said no
12:21:42 <dum8d0g> why?
12:21:47 <dum8d0g> why!
12:22:02 <increpare> emile_m: that presents a perverted back-to-front outlook, and privileges the imperative over the functional : P
12:22:15 * dum8d0g is cuddling with his little C code..
12:22:16 <EvanR-work> vowyer: often appears at the end of a do expression when the final result is a rather than m a
12:22:25 <dum8d0g> I just dont get you guys
12:22:27 <Philonous> If you don't like return, you can always go for pure or point
12:22:49 <increpare> point?
12:22:49 <dum8d0g> you are all either so genius.. or so masochistic..
12:23:11 <zong_sharo> increpare: Pointed from category extras
12:23:18 <Philonous> Sadly, you will have to provide the applicative or pointed instance respectively on your own
12:23:31 <emile_m> increpare: "Haskell is *the* best imperative language".
12:23:33 <sproingie> anyone here who can create a hackage account for me?
12:23:38 <jneira> the io in other langs are trivial..in haskell isnt whether good or bad
12:23:42 <lispy> One of the lambdabot processes has gone rogue
12:23:53 <lispy> I want to kill it, but Cale doesn't seem to be around to restart it
12:24:04 <EvanR-work> jneira: bare IO is way easier to haskell
12:24:09 <EvanR-work> in*
12:24:15 <sinelaw> so, can anyone tell me how to compile with -prof successfully on ubuntu?
12:24:19 <Cale> nyao?
12:24:34 <lispy> Cale: hey, there you are
12:24:39 <lispy> Cale: I just killed it
12:24:44 <lispy> ?bot
12:24:47 <increpare> Philonous: pointed is a bit of a stretch, but pure is fair game : )
12:24:54 <lambdabot> :)
12:25:01 <zong_sharo> does Network.Socket.SocketOption's NoDelay maps to the C's O_NONBLOCK ?
12:25:05 <Cale> I just restarted it :)
12:25:13 <lispy> Cale: thank you :)
12:25:23 <lifflander> dum8d0g: What is your problem now?
12:25:34 <Philonous> increpare: Why is pointed a stretch?
12:25:42 <sinelaw> dcoutts, check this out: $ cabal install -p base         Resolving dependencies...          cabal: internal error: impossible
12:25:45 <lifflander> dum8d0g: Did you try pulling out the readFile?
12:26:10 <vowyer> lifflander: he already quit the channel
12:26:24 <lispy> Cale: you should have sudo access on that machine now
12:26:27 <jneira> jum
12:26:31 <lifflander> vowyer: Right, didn't see that...
12:26:54 <lispy> Cale: also, I setup codersbase.com to point at the ip address.  I don't  which is easier to remember :)
12:27:32 * lispy notes that lambdabot was using 100.2 % of the CPU at one point according to the monitoring tools :)
12:27:45 <Cale> lispy: I have   74.207.243.105 lambdabot   in my hosts.conf
12:28:00 <lispy> Cale: ah, cool
12:28:52 <gwern> out of curiosity, can anyone running firefox >3 see the captcha in https://www.blogger.com/comment.g?blogID=8070355695530434450&postID=7274562269466245079&pli=1 ?
12:29:26 <lispy> gwern: yes with Firefox/3.0.15
12:29:39 <chrisdone> gwern: yeah I can on firefox 3.5.6
12:29:42 <pps> I can see it in 3.0.14 iceweasel
12:29:52 <gwern> I'm on 3.5.5. hm.
12:29:54 <gwern> chrisdone: linux?
12:29:57 <chrisdone> yep
12:30:06 <sinelaw> gwern, yes
12:30:18 <sinelaw> gwern, 3.5.6, ubuntu
12:30:21 <gwern> dammit
12:30:33 <gwern> for years now this has been a problem
12:30:51 <alp_> do anyone know about a zipWith operating on one side on a list and on the other side on an UArr ? :-p
12:30:52 <chrisdone> it's just an img element with a straight-forward src
12:30:56 <chrisdone> gwern: what do you see on yours?
12:31:03 <gwern> chrisdone: just a box
12:31:16 <sproingie> perhaps you're adblocking it?
12:31:18 <gwern> it must be a pref or extension or something because it isn't an issue if I nuke .mozilla
12:31:25 <gwern> sproingie: well, I did try disabling adblock
12:31:25 <lispy> alp_: Can you lazily stream the UArr to a list?
12:31:32 <lispy> alp_: and what type do you want back?
12:31:37 <sproingie> noscript perhaps?
12:31:44 <sproingie> tho i dont think blogger's captchas need it
12:31:51 <chrisdone> no, they don't
12:31:53 <gwern> sproingie: nah, I don't even have noscript
12:32:12 <gwern> (this time I'll try disabling every extension)
12:32:40 <lispy> gwern: better yet, start FF with a new profile
12:32:49 <gwern> lispy: well, that is the same thing as nuking .mozilla
12:33:02 <gwern> lispy: I don't want to lose years of setting & history and css tweaks and whatnot
12:33:06 <lispy> firefox -ProfileManager is your friend :)
12:33:10 <Baughn> gwern: Any chance you could get \bot into #dfhack? (We don't need it on a permanent basis, but it'd be useful at the moment)
12:33:17 <gwern> @join #dfhack
12:33:21 <Baughn> Thanks. :)
12:33:36 <sproingie> what's #dfhack?
12:34:05 <Baughn> sproingie: A channel dedicated to hacking dwarf fortress. Very specific. :P
12:34:11 <sproingie> thou shittest me
12:34:18 <gwern> dammit! it wasn't an extension, unless extensions can mess things up even when disabled
12:34:25 <sproingie> i'm all over that :)
12:34:33 <sinelaw> sproingie, shitteth?
12:34:48 <gwern> sproingie: if you want to sound learned, 'scumber' is a better verb
12:34:51 <gwern> @wn scumber
12:34:51 <lambdabot> No match for "scumber".
12:34:55 <gwern> see?
12:35:42 <ezyang> scumber reminds me of scumble
12:35:43 <sinelaw> Scumber: v. To void excrement.
12:35:52 <sinelaw>         n. Dung
12:35:58 <sinelaw> (Webster 1913)
12:36:48 <gwern> sinelaw: dont' forget 'bescumber' too!
12:37:08 <sinelaw> "To discharge ordure or dung upon."
12:37:21 <sinelaw> DISGUSTING
12:37:30 <gwern> thou bescumbers me! it's a great verb
12:39:05 <aavogt> well there must be a reason such words fell out of use
12:39:24 <gwern> aavogt: you presume they ever fell into use
12:39:27 <aavogt> gwern: or were they ever popular?
12:40:03 <chrisdone> sounds like west-country dialect
12:40:06 <gwern> aavogt: it is a specialized term, clapper-claw me if it ain't!
12:41:21 <gwern> (ok, so it isn't firefox itself; it isn't any extension; it isn't the skin or GTK; it isn't any of the plugins... time to wipe history and cookiees and see how they go)
12:41:25 <sproingie> bescumber sounds so awesomely piratey
12:41:37 <sproingie> ARR, BESCUMBER YE LANDLUBBERS
12:43:47 <gwern> nope, wasn't my history. 2mb difference though, I'm surprised
12:44:18 <ezyang> Straw poll: is a non-deterministic turing machine too complex an example for a TMR article?
12:44:59 <gwern> nor was it cookiees!
12:45:04 <gwern> what's left but preferences...
12:48:59 <gwern> nor was it my userChrome.* stuff
12:49:09 <gwern> gordon bennett!
12:49:58 <lispy> ezyang: Sounds like an interesting article
12:50:59 <gwern> nor was it pref.js!
12:51:00 <gwern> WTF
12:51:38 <gwern> what the heck could it possibly be?
12:51:40 <lispy> gwern: could it be a proxy or a web caching issue?  squid?
12:51:53 <gwern> lispy: no, as I said, nuking .mozilla entirely resolves the issue
12:51:58 <gwern> there's something in .mozilla that's causing this
12:52:03 <lispy> gwern: oh, I missed that
12:52:29 <gwern> (if it wasn't history, cookiees, preferences, extensions, or plugins, what could it be?)
12:53:00 <lispy> gwern: is there a #firefox channel on freenode?
12:53:06 <gwern> lispy: yes, but it's useless
12:53:10 <gwern> as useless as #ubuntu
12:53:35 <osaunders> Does this error "`read' is not a (visible) method of class `Read'" mean what I think it does? Namely, that it's not possible to define new behavior for read for a new type?
12:53:58 <gwern> osaunders: are you not 'deriving' Read/Show?
12:54:01 <ezyang> gwern: I missed some context: what are you debugging?
12:54:10 <gwern> ezyang: the blogger.com captchas never show up
12:54:12 <osaunders> gwern: I am.
12:54:21 <ezyang> Clean profile works?
12:54:28 <gwern> yes
12:54:33 <osaunders> data Graph a = ... deriving (Eq, Show, Read) ... instance Read Graph a where
12:54:40 <gwern> if by clean you mean 'rm -rf .mozilla && firefox' works
12:55:15 <mauke> osaunders: why are you trying to define two instances for Read (Graph a)?
12:55:21 <Acedio> Can you add type signatures to lambda functions?
12:55:24 <ezyang> gwern: What happens if you firefox -ProfileManager, and make a new profile w/o nuking .mozilla. Should be the same, but doesn't hurt to try...
12:56:19 <lispy> > \f -> f :: a -> a
12:56:20 <lambdabot>   Inferred type is less polymorphic than expected
12:56:20 <lambdabot>    Quantified type variable...
12:56:27 <osaunders> http://codepad.org/mzfWBET4
12:56:36 <osaunders> mauke: ^
12:56:46 <gwern> ezyang: new profile is the same as nuking
12:56:57 <mauke> osaunders: that doesn't answer my question
12:56:57 <Acedio> lispy: Ahh, that looks about right.
12:57:21 <ezyang> gwern: Ok.
12:57:35 <lispy> Acedio: I'd advise against it though.  If you want a lambda with a type signature, let and where are very likely more readable
12:57:47 <dons> yay, lots of readers for the year in review news! :)
12:58:04 <osaunders> mauke: Oh sorry I misread your question. Because I want to change the way a graph is read.
12:58:13 <ezyang> gwern: How were you testing w/o extensions?
12:58:16 <lispy> dons: yeah, and it made me realize that darcs could use a year-end publication
12:58:22 <gwern> ezyang: first I disabled, then I uninstalled
12:58:30 <Acedio> lispy: Hm... Well the problem I'm currently running into is this:
12:58:38 <dons> lispy: did i summarise the darcs world suitably?
12:58:39 <Acedio> byteStringToInt bstr = B.foldr (\x y -> x :: Char -> y :: Int -> (* 256 y) + (ord x)) 0 bstr
12:58:39 <mauke> osaunders: how will two instances help with this?
12:58:56 <lispy> dons: I didn't make it that far in your article I guess.  I'll look again
12:58:57 <Acedio> Oops, one sec...
12:59:00 <lhoersten> How do I construct a Word64 of 0? I can't seem to import the constructor correctly
12:59:10 <mauke> lhoersten: 0
12:59:10 <Acedio> byteStringToInt bstr = B.foldr (\x y -> (* 256 y) + (ord x)) 0 bstr
12:59:25 <lhoersten> mauke: seems to be complaining. problem may be somewhere else then
12:59:49 <lhoersten> ah it works but errors
13:00:09 <sinelaw> dons, your counter just incremented again
13:00:13 <ezyang> gwern: Curioser and curioser
13:00:30 <Acedio> There. ghc is complaining because the lambda function is supposed to be (Char -> a -> a) but currently it's (Char -> Int -> Int), which seems fine to me.
13:00:34 <gwern> ezyang: I've had this problem for years, but I'm finally irritated enough to sink an hour or two into solving it
13:00:38 <ezyang> gwern: Can you install something like Firebug and see if the blogger captcha is being loaded, and if so what Firefox's DOM thinks it looks like?
13:00:41 <tobe> I have: data Nat = Z | S Nat deriving (Eq,Ord,Show). How can I output an infinite list with als Nats?
13:00:42 <ezyang> Aha :-)
13:00:58 <osaunders> mauke: I don't think it will. Why would anyone define two instance for anything?
13:01:03 <osaunders> *instances
13:01:08 <ezyang> In that case, another big hammer is to use FEBE to back up parts of your profile and selectively load them into a clean one
13:01:16 * sw17ch wants to amke GHC's GC explicitly scheduled
13:01:22 <tobe> like: allNats :: [Nat]
13:01:23 <gwern> ezyang: i'm just right now selecting rm -rfing in .mozilla
13:01:31 <mauke> osaunders: well, it's an error, so they wouldn't. I'm just trying to understand what you're thinking
13:01:47 <mauke> tobe: iterate S Z
13:02:17 <osaunders> mauke: Yes, but now that I realize I'm completely misusing instance I'm curious why I didn't just get an error saying an instance is already defined for read.
13:02:34 <mauke> osaunders: because it didn't get that far
13:02:48 <osaunders> Ah OK.
13:03:15 <mauke> read is not a method of Read, so it failed before it could notice that the whole instance can't work
13:04:57 <tobe> mauke:: ok, so I have to output all natural numbers so i don't know at the moment if I have to output the S Zs or the real number. but i'll think about it
13:05:58 <tobe> but when it says [Nat] it have to be right
13:06:02 <gwern> ezyang: I fixed it! after I rm -rf [a-l]*, 'rm -rf m* p*' fixed it
13:06:19 <gwern> so something named or in {m,p}* is causing the problem
13:06:22 <osaunders> mauke: What are the methods of Read?
13:06:46 <mauke> osaunders: http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Prelude.html#t%3ARead
13:07:09 <ezyang> ^^
13:07:17 <ezyang> Sort of helpful, I guess?
13:07:44 <gwern> ezyang: well, I can copy mp* back over into .mozilla, and once I'm down to the recreant file, I shall dole out condign punishment
13:08:12 <mauke> > read "['x']" :: String
13:08:13 <lambdabot>   "x"
13:08:30 <gwern> (ok, it wasn't m*; neither mimetype.rdf nor minidumps fixed anything)
13:08:33 <merijn> Does GHCi have a way to display a quick function explanation like help() displaying the doc string of an object in Python?
13:09:00 <gwern> ah! it was permissions.sqlite
13:09:04 <gwern> whatever the hell that is
13:09:34 <EvanR-work> merijn: :t
13:09:41 <EvanR-work> :t read
13:09:42 <lambdabot> forall a. (Read a) => String -> a
13:09:48 <drhodes> :i read
13:09:52 <osaunders> I've supposedly read the chapter on types and typeclasses twice in LYAH but everything still confuses me. This is balls and I'm blaming LYAH.
13:10:14 <sproingie> gwern: you might have accidentally disallowed images from that url
13:10:16 <EvanR-work> :t nice
13:10:17 <lambdabot> Not in scope: `nice'
13:10:18 <kmc_> osaunders, what confuses you about them?
13:10:18 <EvanR-work> :i
13:10:23 <gwern> sproingie: must be, that seems to be what it's about
13:10:27 <kmc_> did you try another tutorial or reference?
13:10:40 <osaunders> kmc_: Everything. I just don't know them at all.
13:10:49 <osaunders> I don't know what an instance is.
13:10:56 <kmc_> osaunders, a typeclass is a set of types
13:10:56 <merijn> EvanR-work: I know about :t, while that's useful it's not quite what I want.
13:11:07 <sproingie> an instance is a type that implements that typeclass
13:11:19 <EvanR-work> merijn: the bot has
13:11:19 <sproingie> bit confusing with OOP terminology since it's a type, not an object
13:11:25 <EvanR-work> @src take
13:11:25 <lambdabot> take n _      | n <= 0 =  []
13:11:25 <lambdabot> take _ []              =  []
13:11:25 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:11:26 <kmc_> an instance is an assertion that some particular type is in some particular typeclass
13:11:26 <kmc_> for example, Eq is the set of all types that have equality-comparison
13:11:37 <kmc_> we say that "Int is an instance of Eq" because we can use (==) on Ints
13:11:44 <kmc_> and (==) is defined in the Eq typeclass
13:11:48 <EvanR-work> merijn: and the mentioned :i
13:12:01 <gwern> but it's *not* any image blocking. blogger isn't there under images
13:12:06 <kmc_> we can use (==) on Ints, because somewhere in the Prelude it says "instance Eq Int where ..."
13:12:16 <kmc_> meaning "Ints can be compared for equality, and here's how: ..."
13:12:19 <sproingie> gwern: they might serve the captcha from a different url
13:12:50 <EvanR-work> @instance Eq
13:12:50 <lambdabot> Maybe you meant: instances instances-importing
13:12:51 <gwern> sproingie: I thought of that earlier, but the HTML says '/captcha?type=IMAGE&amp;captchaKey=151024az6x3zg'
13:12:56 <gwern> it's a relative link
13:12:56 <EvanR-work> @instances Eq
13:12:57 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:13:08 <ezyang> Is there any cute way to make this ball of code look prettier?
13:13:12 <sproingie> gwern: beats me.  it wouldn't surprise me if firefox got confused
13:13:16 <kmc_> osaunders, if you like, a typeclass is a "property" of types, like an interface in some OO languages
13:13:17 <EvanR-work> there are only up to 5-tuples?
13:13:17 <ezyang> http://pastebin.com/m3dd23468
13:13:22 <kmc_> Eq is the "comparable to self" property
13:13:27 <kmc_> Show is the "can be converted to string" property
13:13:36 <gwern> I guess I'll just delete permissions.sqlite
13:13:41 <gwern> not worth figuring out how to repair it
13:13:57 <merijn> EvanR-work: Well not really, but at least the location given by :i helps me find documentation online. I'll just stick to that then, thanks
13:14:16 <opqdonut> ezyang: seems pretty standard. i'm not sure what you mean with TuringStateIndex though
13:14:42 <kmc_> osaunders, http://www.haskell.org/tutorial/classes.html
13:14:53 <ezyang> opqdonut: Turing machines are represented as an array of states to transitions. But there's no sensible definition for the Halt state transition
13:14:58 <sproingie> > (1,2,3,4,5,6) == (1,2,3,4,5,6)
13:14:59 <lambdabot>   True
13:15:00 <kmc_> Gentle Introduction is generally regarded as anything but; however it may click in a way that LYAH won't for you
13:15:19 <ezyang> well... I guess strictly speaking that's always stay in Halt and do nothing
13:15:29 <EvanR-work> sproingie: lies! (,,,,,) wasnt listed!
13:15:47 <sproingie> tuples are odd things in ghc
13:16:12 <opqdonut> ezyang: so you might want to do something like "type TuringState = Running State | Halted; type State = StateA | StateB"
13:16:16 <opqdonut> otherwise you
13:16:27 <ezyang> opqdonut: Possibly
13:16:34 <ezyang> lemme see if that simplifies the code
13:16:34 <sproingie> haskell98 should guarantee things up to sized 15
13:16:34 <opqdonut> 'll be matching between TuringState and TuringStateIndex all the time
13:16:39 <Peaker> If we had unlifted products - we wouldn't need N-tuples
13:16:49 <osaunders> kmc_: TY
13:16:50 <kmc_> grr tuples
13:17:00 <sproingie> interestingly hugs is the same way
13:17:04 <osaunders> LYAH has too many words for me, I think.
13:17:43 <EvanR-work> osaunders: a gentle introduction for you
13:17:45 <kmc_> what do people think of YAHT?
13:18:00 <sproingie> it sucks
13:18:13 <kmc_> also i asked this yesterday but, do you think there's room in the world for another Haskell tutorial, and if so, how should it differ from the others?
13:18:21 <sproingie> it's better than the gentle intro anyway
13:18:28 <sproingie> except for being half-done
13:19:06 <gwern> kmc_: I think we need more focused tutorials on things like monoids and arrows
13:19:19 <gwern> apfelmus's monoid blogposts are good but small in aggregate
13:19:38 <EvanR-work> kmc_: two things i was thinking of. a) use the assumption that the reader is a child who has never programmed or b) present as much as possible about the base language as tersely as possible ;)
13:19:39 <gwern> (ah, excelelnt. I've restored everything and blogger.com is working again!)
13:19:40 <osaunders> kmc_: I think they should have a lot more exercises to complete.
13:19:45 <sproingie> i think it should have focused topics with examples that are actually interesting
13:19:48 <osaunders> There's nothing testing or cementing knowledge.
13:19:49 <sproingie> no Foo this Bar that
13:19:59 <kmc_> osaunders, indeed
13:20:00 <gwern> it only took me about an hour or so :)
13:20:52 <kmc_> yeah, i was thinking that we lack a tutorial teaching Haskell from first principles
13:21:14 <kmc_> it's kinda awkward that all of the tutorials are full of statements about how this or that feature is different from other languages
13:21:17 <sshc> kmc_: what do you mean by "from first principles"?
13:21:26 <sproingie> i ditched my own tutorial after i couldn't decide what kind of focus to have, now i'm thinking something more example-driven
13:21:31 <osaunders> LYAH explains things with lots of words making everything trivial to understand but immediately forgettable and difficult to reference. The ease of understanding probably makes it more forgettable than something with less exhaustive explanation that required you to think in order to reach understanding.
13:21:34 <tobe> i should implement toNat :: Int -> Maybe Nat for data Nat = Z | S Nat deriving (Eq,Ord,Show). Does anybody thinks that it's just: toNat number = Just (toEnum number)?
13:21:37 <sproingie> more like a "follow along as we build this cool game" thing
13:21:46 <kmc_> sproingie, yes
13:21:47 <kmc_> that'd be great
13:22:33 <sproingie> it's tricky in haskell tho since you have to introduce a lot of fundamentals that are really different than the languages i do assume the reader knows
13:22:48 <sproingie> i'm not good enough as a teacher to start from first principles
13:22:50 <gwern> @wn recreant
13:22:52 <lambdabot> *** "recreant" wn "WordNet (r) 2.0"
13:22:52 <lambdabot> recreant
13:22:52 <lambdabot>      adj 1: having deserted a cause or principle; "some provinces had
13:22:52 <lambdabot>             proved recreant"; "renegade supporters of the usurper"
13:22:52 <lambdabot>             [syn: {renegade}]
13:22:54 <lambdabot> [8 @more lines]
13:23:02 <kmc_> by first principles i mean that you make no reference to "other languages", and you provide motivation for everything in terms of basic concepts
13:23:03 <gwern> kmc_: the hawiki builds from scratch
13:23:13 <gwern> er, sorry, haskell wikibook
13:23:27 <sproingie> first principles in this case is "haskell as a first programming language"
13:23:58 <sproingie> i recognize my limits, i don't know how to do that so i assume the reader knows something like perl/python/ruby/php and a smattering of C or java
13:24:15 <gwern> https://secure.wikimedia.org/wikibooks/en/wiki/Haskell
13:24:23 <gwern> ooh, it's become a featured book since I last looked
13:24:48 <kmc_> i would probably give up on writing introductory CS material of any kind after realizing it will never be as good as SICP
13:24:59 <sproingie> SICP is dry as a bone
13:25:07 <opqdonut> sicp is great
13:25:08 <Twey> But excellent
13:25:09 <sproingie> "i want to learn programming so i can do peano numbers, YAY"
13:25:18 <kmc_> SICP is very first-principles -- it sure as hell doesn't stop every paragraph to tell you how the thing you just learned is unlike the similarly-named thing in java
13:25:41 <Twey> Yeah
13:25:42 <gwern> SICP needs better examples early on ~-~
13:25:43 <osaunders> I like very concise things.
13:25:54 <kmc_> "i want to learn physics so i can predict the motion of a frictionless pendulum"
13:25:54 <sproingie> SICP is great all right, but it's hard to hold interest when it stays abstract throughout
13:25:56 <gwern> if you don't like number theory you'll never make it past the early sectionw
13:26:39 <calsaverini> hi
13:26:41 <kmc_> so, i think you could combine "concise, motivated from first principles" with "interesting running example"
13:26:45 <kmc_> hi calsaverini
13:27:05 <sproingie> i think "concise" and "first principles" are often at odds
13:27:18 <EvanR-work> kmc_: wonder which is harder, guide for a non programmer or guide for c programmer ;)
13:27:27 <Gracenotes> sproingie: I'd think they're orthogonal
13:27:37 <sproingie> i'm gonna chop up what i started with my tutorial into smaller digestable lessons
13:27:41 <calsaverini> I'm trying to install a package with cabal but I got a lot of "you should compile it with -XFlexibleInstances" error messages. Anyone knows how I force cabal to compile with a certaing compiling flag?
13:27:49 <lament> doesn't SICP have a bunch of graphics
13:28:04 <EvanR-work> my version only had diagrams
13:28:08 <EvanR-work> sparsely
13:28:09 <byorgey> calsaverini: which package is this?
13:28:12 <sproingie> diagrams are also helpful
13:28:20 <lament> i mean, SICP had examples that generated graphics
13:28:25 <ezyang> opqdonut: That was a really good suggestion. Thanks!
13:28:28 <gwern> calsaverini: couple ways to do that
13:28:28 <byorgey> calsaverini: and which version of ghc do you have installed?
13:28:45 <EvanR-work> yeah the 'painting language' ;)
13:28:51 <sproingie> calsaverini: that flag should be in the .cabal file.  if not it's a bug
13:29:31 <gwern> calsaverini: iirc you want a field like 'extensions: FlexibleInstances' in the library section
13:29:32 <calsaverini> hummm
13:29:46 <calsaverini> thanks
13:30:24 <gwern> calsaverini: or you could add the -X to ghc-options, or put a {-# LANGUAGE FlexibleInstances #-} in the relevant file or...
13:32:01 <osaunders> kmc_: Yes, I agree that you could combine them.
13:32:10 <osaunders> I think that would be good work.
13:32:12 <ezyang> Oh balls, but then I can't derive Ix, Enum and Bounded
13:34:45 <pozic> You really talk too much. Try scrolling back for 5 hours. ;)
13:35:03 <cpfr_> hey I am trying to build the Haskell Platform
13:35:13 <cpfr_> and the build is freezing on "Linking Setup ..."
13:35:54 <ezyang> I guess I'll sit down and write the grody instance code manually :-(
13:36:48 <alp_> anyone willing to review a neural network library (very minimal for the moment) ? Thanks in advance.
13:42:35 <kmc_> okay, so what's a good running motivating example for a concise, first-principles Haskell tutorial?
13:42:53 <EvanR-work> i am so motivated to compute the fibonacci sequence
13:43:00 * EvanR-work gets beefed up
13:43:19 <Philonous> kmc_ I started learning haskell because I wanted to write a monad tutorial!
13:43:24 <kmc_> hahaha
13:43:27 <EvanR-work> lol
13:43:27 <koeien37> oh no
13:43:30 <kmc_> i hear they're like burritos
13:44:03 <lament> haskell found its niche
13:44:10 <dolio> Writing a lmmbda calculus interpreter.
13:44:14 <dolio> Lambda, even.
13:44:20 <dolio> That's what people do with Haskell.
13:44:41 <lament> go write yourself a scheme
13:44:42 <Peaker> what's the name of the TH package to auto-derive accessors to record fields?
13:44:59 <kmc_> dolio, i think that stuff is really cool, but i'm not sure others will agree
13:45:07 <kmc_> Peaker, lenses, fclabels, data-accessor
13:45:08 <kmc_> pick one
13:45:38 <kmc_> dolio, it's clear that a Haskell tutorial should have a strong languages component, but maybe in a more fleshed-out setting
13:46:18 <Philonous> Peaker: the TH magic is in data-accessor-template
13:46:28 <Peaker> kmc_: thanks
13:46:36 <idnar> where does the 'b' in 'lambda' come from?
13:46:49 <Peaker> @where SEC
13:46:49 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:47:34 <kmc_> so what are the flaws of GIH?
13:48:22 <merijn> Is there a concise description of haskell syntax somewhere? I'm playing around with some examples and run into problems where I don't know how to (for instance) combine guards and where clauses.
13:48:41 <kmc_> merijn, the Haskell report is always the authoritative source
13:48:56 <roconnor> ya, I always go back to the haskell report for stuff like that
13:49:01 <Peaker> Philonous: thanks
13:49:07 <kmc_> merijn, maybe you'd like http://www.cs.uu.nl/wiki/pub/FP/CourseLiterature/haskellsyntax-main.pdf
13:49:54 * hackagebot upload: life 0.1 - Conway's Life cellular automaton (ChuckAdams)
13:50:36 <BMeph> idnar: ...the 2nd letter of the Greek alphabet? :)
13:51:16 <idnar> BMeph: I know, but why isn't it spelled "lamda"?
13:51:38 <sproingie> yay my first hackage package
13:51:41 <EvanR-work> standard english misspelling of random stuff
13:51:44 <merijn> idnar: Because you don't pronounce it lamda? It's pronounced lambda...
13:52:18 <idnar> merijn: those would appear to have identical pronunciations, since the 'b' isn't voiced
13:53:29 <merijn> idnar: The b is voiced slightly in English and quite clearly when pronounced in, say, Dutch or Greek.
13:54:19 <EvanR-work> wikipedia  Greek: Λάμβδα or Λάμδα
13:54:24 <vowyer> merijn: in spanish isn't voiced at all in this case
13:54:39 <EvanR-work> so its basically there because the greeks said so
13:55:08 <skorpan> when i was
13:56:21 <merijn> vowyer: Yeah, but since it is voiced in Greek (at least in Ancient Greek, I've never had classes in modern Greek, but I presume those are the same) it makes sense the spelling stuck around, it being a Greek letter and all.
13:58:33 <sproingie> wut a dum argument
13:59:11 <vowyer> merijn: I thought ancient greek pronounciation isn't clear at all
13:59:22 <vowyer> *wasn't
14:00:08 <BenceF> vowyer: the deadsea tapes cleared that up
14:00:27 <merijn> vowyer: I'll settle for "the pronounciation which is now taught as Ancient Greek" if it makes you happy :p
14:02:43 <BenceF> we pronounce the b in hungarian if that helps
14:02:47 <vowyer> merijn: I still hear people talk in latin the english way, so I'm not sure the way they teach pronounciation is correct
14:03:12 <mauke> there is no b in hungarian!
14:03:27 <BenceF> i think i pronounce it
14:03:39 <BenceF> well maybe not
14:04:10 <vowyer> mauke: what's the sound for b or v?
14:04:25 <BenceF> no just in lambda
14:04:42 <skorpan> when i was
14:04:58 <lament> there's no "correct" pronunciation for latin
14:05:24 <lament> pronunciation changed as latin evolved
14:05:28 <ketil> Well - there's classical or medieval?
14:05:45 <BenceF> we gotta ask the iso comitte to come up with one
14:05:52 <lament> we really should.
14:05:55 <skorpan> medieval latin?
14:06:18 <BenceF> well it was always in use wasnt it
14:06:29 <lament> skorpan: sure, for example, what carmina burana is written in
14:06:34 <ketil> Where you pronounce c's as s in front of bright vowels.
14:06:35 <skorpan> In Modern Greek the name of the letter, Λάμδα, is pronounced [lamða]
14:06:43 <skorpan> is lambda even latin?
14:06:50 <lament> no.
14:06:57 <skorpan> for what it's worth, latin wikipedia: http://la.wikipedia.org/wiki/Labda
14:07:01 <skorpan> LABDA people. LABDA.
14:07:06 <ketil> I imagine it is also the latin name for a greek letter :-)
14:07:06 <BenceF> its greek i think
14:07:39 <m0nkfish> seriously? theres a latin wikepedia? O_O
14:07:49 <skorpan> there is/was a tokipona wikipedia...
14:07:57 <BenceF> :D b and d is too hard to say after each other
14:08:01 <ketil> Oh, right.
14:08:09 <BenceF> man. theres a klingon wikipedia
14:08:13 * ketil imagines wrong.
14:08:14 <vowyer> skorpan: there isn't latin lambda
14:08:15 <lament> lamda and labda are practically the same word
14:08:38 <skorpan> both are bilabial
14:08:41 <skorpan> or something... :|
14:08:59 <vowyer> b is bilabial
14:09:04 <skorpan> so is m
14:09:12 <vowyer> but not the d
14:09:21 <skorpan> right
14:09:34 <skorpan> d is alabial... *making stuff up*
14:09:50 <Botje> c is for cookie!
14:10:02 <vowyer> interdental i think
14:10:16 <lament> alveolar
14:10:24 <vowyer> that must be it
14:10:26 <lament> m and b are bilabial, n and d are alveolar
14:10:33 <lament> mb, nd, mb, nd
14:10:52 <vowyer> no, d is more interdental
14:11:00 <eugenn> :t compare
14:11:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:11:13 <eugenn> @src compare
14:11:14 <lambdabot> compare x y | x == y    = EQ
14:11:14 <lambdabot>             | x <= y    = LT
14:11:14 <lambdabot>             | otherwise = GT
14:11:16 <skorpan> you are all looking this up on wikipedia
14:11:30 <lament> i'm not
14:11:30 <lament> http://en.wikipedia.org/wiki/Voiced_alveolar_plosive
14:11:32 <vowyer> not me
14:11:39 <vowyer> I should
14:11:41 <lament> yes
14:11:44 <eugenn> in which module is "compare" defined?
14:11:56 <mtnviewmark> :i compare
14:11:56 <skorpan> @hoogle compare
14:11:56 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
14:11:56 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
14:11:56 <lambdabot> Text.ParserCombinators.Parsec.Error messageCompare :: Message -> Message -> Ordering
14:11:58 <Peaker> @index compare
14:11:58 <lambdabot> Prelude
14:12:06 <aavogt> @hoogle plosive
14:12:06 <lambdabot> No results found
14:12:12 <skorpan> so Data.Ord
14:14:44 <lispy> :do a >>= b
14:14:53 <lispy> ?list
14:14:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:14:57 <Peaker> @do a >>= b
14:14:57 <lambdabot> do { c <- a; b c}
14:16:12 <Peaker> > intercalate " >>= " (map return ['a'..'z'])
14:16:13 <lambdabot>   "a >>= b >>= c >>= d >>= e >>= f >>= g >>= h >>= i >>= j >>= k >>= l >>= m ...
14:16:25 <Peaker> @do a >>= b >>= c >>= d >>= e >>= f >>= g >>= h >>= i >>= j >>= k >>= l >>= m >>= n >>= o >>= p >>= q >>= r >>= s >>= t >>= u >>= v >>= w >>= x >>= y >>= z
14:16:25 <lambdabot> do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <-
14:16:25 <lambdabot> do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- do { a' <- a; b a'}; c a'}; d a'}; e a'}; f a'}; g a'}; h a'}; i a'}; j a'}; k a'}; l a'}; m a'}; n a'}; o a'}; p a'}; q a'}; r a'};
14:16:25 <lambdabot> s a'}; t a'}; u a'}; v a'}; w a'}; x a'}; y a'}; z a'}
14:16:45 <Peaker> oops, sorry about the flood. I was wondering what it'd choose if a..z are all taken :)
14:17:18 <skorpan> nothing compared to a flip flood
14:17:29 <pikhq> Peaker: Apparently it does a lot of variable shadowing. :)
14:18:45 <eugenn> @pl (\x y -> compare (head x) (head y))
14:18:45 <lambdabot> (. head) . compare . head
14:18:49 <cpfr_> is there any reason my compile would be freezing?
14:19:06 * hackagebot upload: gitit 0.7 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
14:19:28 <Philonous> @type compare `on` head
14:19:29 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
14:19:55 <Philonous> > compare `on` head $ [1,2,3,4] [4,3,2,1}
14:19:56 <lambdabot>   <no location info>: parse error on input `}'
14:20:02 <Philonous> > compare `on` head $ [1,2,3,4] [4,3,2,1]
14:20:03 <lambdabot>   Precedence parsing error
14:20:03 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
14:20:22 <Philonous> > (compare `on` head) [1,2,3,4] [4,3,2,1]
14:20:23 <lambdabot>   LT
14:20:28 <Peaker> eugenn: that's   compare `on` head
14:20:38 <Peaker> oops, I'm redundant :)
14:20:57 <eugenn> great, thanks! it's what I wanted, but in which module is 'on' defined?
14:20:59 <BMeph> Or better yet, 'comparing head'. :)
14:21:15 <BMeph> eugenn: Data.Function
14:21:22 <eugenn> oh
14:21:28 <Peaker> comparing = (compare `on`)
14:22:07 <jneira> mmm is there a short idiomatic way to sort by the second element of a dupla?
14:22:25 <Berengal> sortBy (comparing snd)
14:22:31 <jneira> mmm
14:22:33 <eugenn> so "sortBy comparing head [lists..]" would work? how expressive ... :)
14:22:36 <Berengal> Assuming by dupla you mean pair
14:22:57 <alp_> sproingie, congrats :-)
14:23:03 <jneira> > :t comparing
14:23:04 <lambdabot>   <no location info>: parse error on input `:'
14:23:09 <jneira> :t comparing
14:23:10 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:23:23 <jneira> beautiful thnx
14:23:26 <sproingie> alp_: thanks :)
14:23:47 <eugenn> > sortBy comparing head [[1,2,3],[6,7,8],[2,3,4]]
14:23:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
14:23:59 <eugenn> > sortBy (comparing head) [[1,2,3],[6,7,8],[2,3,4]]
14:24:00 <lambdabot>   [[1,2,3],[2,3,4],[6,7,8]]
14:24:05 <eugenn> allright!!
14:24:29 <jneira> i love haskell for things like this
14:25:04 <skorpan> i like writing haskell, but as soon as i want to write something "real world" i lose my motivation
14:25:15 <kmc_> why?
14:25:22 <alp_> @where hackagebot
14:25:22 <lambdabot> I know nothing about hackagebot.
14:25:26 <alp_> tss
14:25:29 <alp_> you're jealous.
14:25:34 <Berengal> > sortBy (comparing head `mappend` length) $ words "asdf bsdf csd"
14:25:35 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
14:25:36 <lambdabot>         against...
14:25:40 <skorpan> kmc_: it's not haskell per se, it's just that writing something "real world" takes effort
14:25:45 <Berengal> > sortBy (comparing head `mappend` comparing length) $ words "asdf bsdf csd"
14:25:47 <lambdabot>   ["asdf","bsdf","csd"]
14:25:49 <kmc_> skorpan, that's true
14:25:55 <jneira> jum
14:26:01 <jneira> try clojure instead
14:26:03 <jneira> :-P
14:26:16 <jneira> if you dont hate ((()))
14:26:30 <Berengal> ((())) killed (((())))!
14:26:37 <jneira> jeje
14:26:44 <kmc_> i think even once you are an expert at the theoretically beautiful parts of Haskell, there is an extra curve for learning how to interface it to the real world
14:26:46 <skorpan> and you always end up having to do some further abstraction because of some corner case you didn't think about
14:26:52 <Berengal> At least he's not as bad as {}
14:27:05 <kmc_> but that once you learn that too, Haskell is a fine language for that stuff as well
14:27:25 <sinelaw> can I somehow tell cabal/ghc to build with static linkage on the final executable?
14:27:37 <skorpan> and i tend to end up in StateT with IO no matter what i do...
14:27:38 <Peaker> sinelaw: isn't that the default?
14:27:41 <sproingie> i'm finding opengl is absurdly easy to interface to, and it's pretty real-world
14:27:46 <sproingie> it's also pretty darn imperative
14:27:48 <eugenn> is Data.Function included in Hugs?
14:27:54 <sinelaw> Peaker, ah, i don't know
14:27:59 <Peaker> sproingie: I find OpenGL painfully difficult
14:28:07 <pikhq> eugenn: Don't use Hugs.
14:28:09 <sinelaw> Peaker, and with template haskell it seems to be "no"
14:28:09 <jneira> sorry..where is comparing
14:28:19 <kmc_> Data.Ord
14:28:26 <sinelaw> Peaker, maybe i'm wrong, checking
14:28:29 <BMeph> > sortBy (on mappend comparing head length) $ words "asdf bsdf csd"
14:28:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:28:30 <lambdabot>         against inferred type ...
14:28:30 <jneira> thnx
14:28:42 <BMeph> Aww...
14:28:47 <sinelaw> Peaker, executable is 16M, so I guess it is.
14:29:05 <sproingie> Peaker: well the math tends to whiz over my head but there's libraries to handle most of it
14:29:19 <pikhq> :t on mappend comparing head length
14:29:20 <lambdabot> [Int] -> [Int] -> Ordering
14:29:26 <Berengal> @type (++)
14:29:27 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:29:34 <pikhq> :t sortBy
14:29:51 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:30:08 <Peaker> sproingie: not the math, the gory implementation details (setting up a window with GLUT, loading textures from a file, etc)
14:30:10 <sproingie> i'll probably never wrap my brain around quaternions.  but i just treat them as opaque encodings of matrices and i'm all set
14:30:14 <Berengal> > sortBy (comparing length ++ comparing sum) [[1,2,3,4],[5,6,7,8],[2,5,3],[95,0,0,0]]
14:30:15 <lambdabot>   [[2,5,3],[1,2,3,4],[5,6,7,8],[95,0,0,0]]
14:30:25 <sinelaw> Peaker, i found graphics-drawingcombinators to be really easy to use
14:30:32 <Peaker> sinelaw: cool, it seems nice indeed :)
14:30:34 <sinelaw> Peaker, although I don't do much with it yet
14:30:41 <Peaker> sinelaw: just explaining why the imperative OpenGL interface, as is, I find hard
14:30:42 <sinelaw> (I know it's somewhat incompelte)
14:31:04 <sinelaw> Peaker, ok, I agree then
14:31:15 <sproingie> Peaker: setting up a window is easy.  initialWindowSize $= Size x y; createWindow "hello world"
14:31:40 <sproingie> the various mode bits have sensible defaults
14:31:43 <sinelaw> Peaker, it's a tough library for imperative programmers, because it's really a functional library. It's even tougher for functional programmers, because the interface is imperative
14:31:52 <kmc_> haha
14:32:01 <lament> sounds like the best of both worlds
14:32:23 <sinelaw> the worst, perchance
14:32:33 * sinelaw had to say "perchance" today
14:32:36 <sproingie> i don't find much functional about it
14:32:45 <kmc_> shader programming is very functional
14:32:45 <jneira> > sortBy (comparing $ length.snd) [(0,[1,3]),(2,[1,1,1]),(3,[1]),(1,[1,1,1,1])]
14:32:46 <lambdabot>   [(3,[1]),(0,[1,3]),(2,[1,1,1]),(1,[1,1,1,1])]
14:32:48 <sinelaw> sproingie, all the mathematical operations are functional
14:32:56 <kmc_> the GL api itself, not so much
14:32:57 <sinelaw> and they are a lot of the work
14:32:59 <sproingie> if anything it's forth programmers who pick it up easily since you have stacks to push and pop matrices on
14:33:04 <jneira> aixx
14:33:05 <sproingie> as well as attributes
14:33:10 <sinelaw> sproingie, true
14:33:37 <sinelaw> sproingie, but to quote The Cat In The Hat: "But that is not all, oh no that is not all..."
14:33:50 <sinelaw> I know that book almost by heart
14:33:51 <sproingie> and all the matrix operations in GL mutate the current matrix
14:33:54 <Peaker> sproingie: how do you load an image and blit it to the display?
14:33:57 <sproingie> that's not terribly functional
14:34:07 <Peaker> sproingie: with SDL, its something like loadImage filename >>= blit display params
14:34:59 <eugenn> is ghci portable and multiplattform like Hugs?
14:35:19 <sproingie> Peaker: it's a pain in the ass to do raw.  tga format is popular for textures because it's almost exactly like GL's internal format
14:35:22 <dolio> It's as portable as GHC, presumably.
14:35:41 <Peaker> sproingie: that's the pain in the ass I'm talking about :)
14:35:43 <Peaker> sproingie: also rendering text
14:35:56 <sproingie> Peaker: the fiddliest part is dealing with texture filtering
14:36:14 <Peaker> sproingie: 2d blitting should be easy ...
14:36:48 <sproingie> it's kind of annoying with raw GL.  i'd rather be using SFML
14:36:56 <Berengal> I hate fiddling... I wish programming was all done in 25 pt Comic Sans
14:37:46 <sinelaw> i hate comic sans
14:38:06 <sinelaw> i wish all programming was done in 5pt courier OLD
14:38:17 <sproingie> maybe i'll make myself a FFI project and write sfml bindings for haskell
14:38:35 <sinelaw> sproingie, did you see graphics-drawingcombinators?
14:38:41 <jneira> i have an ugly lambda (lamda labda or what else) ...
14:38:47 <sinelaw> it's by luqui
14:39:06 <sproingie> sinelaw: no i havent in fact
14:39:09 <Peaker> I hate unqualified open imports!  I get a missing data constructor - I have no idea where it should be coming from :-(
14:39:13 <Saizan> "lambda"
14:39:29 <sproingie> if it's a SDL+GL thing that actually works, i'll be all over it
14:39:31 <Peaker> sproingie: sfml?
14:39:43 <sproingie> @google sfml
14:39:45 <lambdabot> http://www.sfml-dev.org/
14:39:45 <lambdabot> Title: SFML - Simple and Fast Multimedia Library
14:39:45 <eugenn> what does the i in ghci stand for?
14:39:49 <sproingie> eugenn: interactive
14:39:53 <sinelaw> sproingie, it is something in that direction. check out the example.hs that comes with it
14:40:20 <merijn> I'm going over Real World Haskell and it has some notes on TCO with some of the examples these (http://dpaste.com/136406/) versions are exactly identical, right? (Not just in regards to TCO)
14:40:21 <sinelaw> Peaker, i've emailed you a compiled graphui binary :)
14:40:28 <Peaker> sinelaw: heh
14:40:34 <Peaker> sinelaw: 1999 called
14:40:36 <sproingie> my attempts at using SDL's gl context in haskell were always foiled
14:40:40 <sinelaw> 1989 maybe
14:40:50 <Peaker> sproingie: I managed to do that
14:41:34 <sinelaw> sproingie, I urge you to look at that lib
14:41:42 <jneira>  map (\a->(fst a, filter (valid (fst a)) $ (snd a)))   list
14:42:04 <sproingie> hotdamn there it is
14:42:06 <Botje> merijn: the second uses a' but doesn't define it anywhere
14:42:26 <sproingie> doesn't segfault when exiting either
14:42:29 <Peaker> jneira: use pattern matching on the tuple
14:42:32 <sproingie> (my other SDL apps were doing that)
14:42:48 <jneira> pattern matching in a lambda?
14:43:04 <skorpan> jneira: lambdas are functions
14:43:05 <Botje> sure. \(a,b) -> ...
14:43:24 <merijn> Botje: Ah, yeah. I glossed over that one. Then the let makes more sense to keep things clean. Suppose the a' was replaced with the proper code they'd be identical, right?
14:43:34 <sinelaw> sproingie, it actually did segfault when quitting a few times for me, but only when quitting via Ctrl-c
14:43:40 <sinelaw> (not on normal quit)
14:43:42 <BMeph> jneira: More "Haskellian":  map (\(a,b)->(a, filter (valid a) $ b)) list
14:43:47 <Peaker> jneira: map (\(x, y) -> (x, filter (valid x) y)
14:43:54 <Botje> merijn: well, with the let you're only going to compute a' once.
14:43:59 <jneira> thought that I had tried that before
14:44:13 <Botje> with the other you might, but it's up to the compiler there.
14:44:18 <sproingie> cool.  next version of life will be using that.
14:44:25 <jneira> ok
14:44:32 <jneira> but withput lambda?
14:44:38 <jneira> *without
14:44:49 <merijn> Botje: ok, thanks
14:45:04 <sproingie> sinelaw: i think i'd ignored it because i saw the build failure on 6.10
14:45:10 <Botje> but apart from that they're the same, yes
14:45:54 <sinelaw> sproingie, it does build on mine, which is 6.10
14:46:00 <eugenn> jneira, [ (x, filter (valid x) y) | (x,y) <- xs ] but it's not point-free anymore
14:46:02 <sproingie> sinelaw: yah it works fine on mine too
14:46:12 <BMeph> jneira: Most "Haskellian":  map (\(a,bs)->(a, filter (valid a) bs)) list
14:46:14 <byorgey> jneira: it's really not worth doing it without a lambda.
14:46:25 <sproingie> i might pull in gpipe to run life in a shader
14:46:26 <byorgey> @pl \(x,y) -> (x, filter (valid x) y)
14:46:27 <lambdabot> uncurry (liftM2 (.) (,) (filter . valid))
14:46:29 <byorgey> see?
14:46:31 <sproingie> yay 10,000 FPS
14:46:41 <jneira> fiuuu
14:46:46 <sinelaw> sproingie, how did you get that stat?
14:47:06 <sinelaw> no, you are kidding.
14:47:28 <sproingie> i didn't, but i've run other CA stuff in shaders before (someone else's code of course) and it was ludicrously fast
14:47:44 <Peaker> in the new base, where did "StringConstr" go?
14:48:23 <sinelaw> sproingie, last time i heard that combination of words was when I watched Space Balls
14:48:36 <Peaker> Data.Data used to have it, but no longer does... it seems
14:48:54 <eugenn> does the ghc download in haskell.org come with libraries?
14:49:22 <sproingie> just base
14:49:28 <sinelaw> Peaker, got the binary?
14:49:31 <sproingie> you need the haskell platform for more
14:49:34 <dolio> They've gone plaid!
14:49:43 <eugenn> ok
14:50:13 <Peaker> sinelaw: compresses well..
14:50:34 <sinelaw> Peaker, too well for the unprepared decompresser
14:50:38 <sinelaw> :)
14:50:44 <Peaker> sinelaw: needs libffi.so..
14:50:56 <sinelaw> doh, so it doesn't static link
14:51:06 <sinelaw> at least not completely
14:51:27 <tommd> ?where hackagebot
14:51:28 <lambdabot> I know nothing about hackagebot.
14:53:26 <sinelaw> preflex, seen hackagebot
14:53:26 <preflex>  hackagebot was last seen on #haskell 34 minutes and 20 seconds ago, saying: * hackagebot upload: gitit 0.7 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
14:56:13 <Berengal> http://www.pic-spot.com/images/arx1261436089a.png
14:56:39 <ahf> hah
14:56:43 <ahf> what's that font named?
14:57:13 <sinelaw> Berengal, haha! that's cool
14:57:13 <Berengal> Purisa
14:57:46 <skorpan> what's that (<-) arrow in the newtype?
14:57:54 <skorpan> that can't compile, can it?
14:58:29 <dolio> No, that's not legal haskell.
14:58:31 <cpfr_> so how do i use split-obj so haskell works on slicehost
14:58:47 <dolio> * + * is not a Haskell kind.
14:58:59 <Berengal> Sometimes I wish it were...
14:58:59 <sproingie> nor is * <- *
14:59:07 <dolio> Right.
14:59:28 <sproingie> yah screw n+k patterns, let's have n+k kinds!
14:59:33 <Berengal> Hehe
15:00:21 <Liskni_si> what would it mean?
15:01:16 <Berengal> Sum-kinds, obviously...
15:03:57 * Liskni_si doesn't know what that means; googles for it then.
15:04:20 <Botje> it would be terribly confusing :p
15:05:31 <dolio> Sum types are disjoint unions.
15:05:37 <Peaker> the fclabels package's cabal file specifies "template-haskell >= 2.2 && < 2.4" but seems to compile with template-haskell-2.4.0.0 just fine
15:06:15 <dolio> Is 2.4.0.0 new with 6.12 or something?
15:06:19 <Peaker> yeah
15:06:24 <dolio> Well, there you go.
15:06:41 <Peaker> dolio: is it standard practice to specify <newer-than-existing on deps?
15:07:07 <dolio> It is now. Hackage will complain about packages that don't specify an upper bound.
15:07:16 <sproingie> about time
15:07:20 <dolio> And specifying some ridiculously high version is also bad practice.
15:07:31 <sproingie> next major version seems typical
15:07:44 <sproingie> not that it stops a lot of stuff from breaking compatibility in minor versions
15:08:52 <merijn> Ok, so is it me or does it just take about a week to grok foldl being expressed using foldr?
15:09:14 <Botje> it is a silly thing to do. :)
15:09:22 <dolio> It helps to derive it yourself.
15:09:57 <dolio> Which you can do somewhat systematically.
15:11:03 <mtnviewmark> that's what I did: Figured out from first principles how to do it - watched my head explode - wrote it down - forgot it!
15:12:28 <merijn> Oh well, to the whiteboard we go, then
15:12:35 <dolio> The universality of foldr means that 'f [] = z ; f (x:xs) = g x (f xs)' implies that f = foldr f z, so you need to massage the foldl equations into that form.
15:12:48 <dolio> foldr g z, even.
15:13:20 <roconnor> @free foldr
15:13:20 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
15:13:45 <dolio> Just don't be lulled into complacency by the fact that the base cases for foldr and foldl look the same.
15:14:06 <Botje> funny way of defining h, there :)
15:14:59 <BMeph> Funny way of deriving g, if you ask me... ;)
15:15:26 <merijn> dolio: I find the difference fairly obvious if you think about it in terms of operator associativity
15:16:52 <merijn> I think examples of foldl/foldr should just default to - rather then + that'd make the difference a lot clearer since it's just coincidence that plus behaves the same with right associativity
15:18:46 <sohum> I think there should be a "fold"
15:18:57 <sohum> which the compiler gets to pick what to optimise it into
15:19:15 <Berengal> http://www.pic-spot.com/images/jdv1261437490m.png
15:19:15 <calsaverini> are any of you experiencing problems with cabal today?
15:19:32 <mtnviewmark> sohum - surely that would only work with associative operations!
15:19:48 <sohum> specifying foldl or foldr when you don't need the order is specifying more information than necessary sometimes
15:19:49 <calsaverini> Oh... I see my problem.
15:20:04 <Saizan> merijn: association is only half of the story
15:20:06 <calsaverini> I'm trying to upgrade cabal by doing a "sudo cabal install cabal-install"
15:20:09 <Botje> Berengal: you forgot to use a factory!
15:20:09 <mtnviewmark> @info fold
15:20:09 <lambdabot> fold
15:20:16 <Berengal> Botje: There wasn't room :(
15:20:20 <mtnviewmark> isn't there a fold in Traversable?
15:20:22 <Saizan> calsaverini: don't!!
15:20:28 <mtnviewmark> or, er, Foldable?
15:20:31 <sohum> mtnviewmark: well, yea, clearly. but in that case when you don't /care/ about the order it's useful to let the optimiser figure out what'd be best
15:20:35 <calsaverini> but it's installing the binaries in my home instead of installing in the system
15:20:43 <Saizan> calsaverini: "cabal install --global --root-cmd=sudo cabal-install"
15:20:49 <calsaverini> Saizan, why not?
15:20:51 <calsaverini> Oh...
15:20:53 <Botje> also, it's probably Transaction<Transaction>.transactionTransaction(); ;)
15:20:58 <calsaverini> I see
15:21:42 <calsaverini> this is strange
15:21:50 <kmc_> Berengal, hahaha
15:21:56 <kmc_> every part of that is wonderful
15:21:58 <calsaverini> cause that is the command cabal itself recommends
15:22:01 <sohum> :t foldl
15:22:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:22:04 <sohum> :t foldr
15:22:05 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:23:07 <Berengal> kmc_: Every part of that is true :'(
15:23:24 <Liskni_si> dolio: I know about sum types, but sum kinds? I've quite failed at googling that :(
15:23:30 <Saizan_> calsaverini: got my message about --root-cmd ?
15:23:36 <calsaverini> yes
15:23:41 <calsaverini> that worked I think
15:23:43 <dolio> Liskni_si: Same thing, but one level up.
15:23:51 <Peaker> I think one of foldl/foldr's type variable names should be swapped
15:24:01 <calsaverini> yes, it worked
15:24:13 <Peaker> foldl :: (b -> a -> b) -> b -> [a] -> b
15:24:18 <sohum> mtnviewmark: actually, in most cases, you don't even need associativity. think about folding over a list and inserting it into a datastructure, say. with foldl you'd write \set x -> insert x set and with foldr you'd write \x set -> insert x set . given that fold will only have one signature, and given that it can be easily transformed to the other, it's as long as inserting all of those elements in any order gives the same set
15:24:20 <Peaker> foldr :: (a -> b -> b) -> b -> [a] -> b
15:24:31 <Liskni_si> dolio: I see. I think I can now imagine that.
15:25:07 <calsaverini> Saizan_ I was going crazy with this. Thanks
15:25:16 <mtnviewmark> yes, I am sometimes annoyed by the difference in the order of the arguments to the folds
15:25:28 <mtnviewmark> and sometimes I'm comforted in the mnemonic meaning....
15:25:40 <mtnviewmark> but mostly I'm generally annoyed that foldl' isn't in the Prelude!
15:25:58 <mtnviewmark> @hoogle fold
15:25:58 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
15:25:58 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
15:25:58 <lambdabot> Data.IntSet fold :: (Int -> b -> b) -> b -> IntSet -> b
15:26:18 <mtnviewmark> sohum --- isn't Data.Foldable.fold exactly what you want?
15:26:19 <tensorpudding> foldl' isn't in the prelude?
15:26:19 <calsaverini> Saizan_ Well, I'm still having problems to install packages with cabal even after upgrading it correctly... I thought that was the problem.
15:26:27 <tensorpudding> @hoogle foldl'
15:26:28 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
15:26:28 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
15:26:28 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
15:26:33 <tensorpudding> hmm, guess not
15:26:38 <sohum> mtnviewmark: well, I'm pretty sure it's defined as one of the two under the hood
15:27:07 <mtnviewmark> well - from a client perspective - it meets your needs: Express the fold, without expressing a bias for ordering
15:27:22 <mtnviewmark> and the instances of Foldable are free to do what is most efficient
15:27:26 <sohum> :t fold `asTypeIn` \fold -> fold [2,3,3]
15:27:27 <lambdabot> Not in scope: `fold'
15:27:32 <mtnviewmark> @hoogle fold'
15:27:32 <lambdabot> No results found
15:27:38 <sohum> mtnviewmark: this is true
15:28:02 <Saizan_> calsaverini: running sudo cabal ... might have made your ~/.cabal (or parts) owned by root, anyhow, which command are you running and which errors are you getting?
15:28:17 <mtnviewmark> alas, it doesn't have fold' .. which might be useful too
15:28:27 <mtnviewmark> BUT it has foldl' AND foldr'
15:30:29 <calsaverini> Damn... I think my haskell-platform is broke
15:30:54 <calsaverini> I can't install any package from hackage
15:30:56 <calsaverini> Saizen_
15:31:15 <calsaverini> Saizan_ I tried to install hmatrix, yi and a lot of other packages
15:31:22 <BMeph> sohum: Perhaps edwardk's Monoids package is more your style... :)
15:31:37 <calsaverini> Saizan_ some of them fail in building, others in the configuring phase
15:31:58 <calsaverini> Saizan_ i was doing "sudo cabal install" before and it was kind of working alright
15:32:08 <Saizan_> calsaverini: well, those might be problems with the specific packages
15:32:17 <calsaverini> Saizan_ today it stoped working
15:32:21 <Saizan_> calsaverini: sudo cabal install is how to get it borked
15:32:58 <Saizan_> calsaverini: try a chown -R on ~/.cabal and ~/.ghc to your user
15:33:09 <calsaverini> Saizan_ right
15:36:05 <ac_> `cabal install thrsx` is dying with another "Prelude is a member of package base which is hidden". Anybody else having problems with this package or is it just me again?
15:37:17 <xerox> ac_: http://haskell.org/cabal/FAQ.html has some answers about hidden packages
15:37:26 <Saizan_> ac_: the latest version on hackage is intentionally borked i think, since it's deprecated
15:37:28 <calsaverini> Saizan_ well... not workng yet. I'll try to remove and delete all packages and install GHC and Haskell-Platform from zero
15:37:37 <Saizan_> ac_: you can cabal unpack thrsx to look at the content
15:37:37 <ac> Saizan_: but happstack depends on it
15:38:07 <Saizan_> ac: ask the happstack guys on that then :)
15:38:22 <Saizan_> calsaverini: can you paste the errors first?
15:38:25 <Saizan_> @hpaste
15:38:25 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:38:47 <Saizan_> calsaverini: e.g. yi is known for not working out of the box, currently
15:38:59 <mmorrow> @let foldt = let pair(a:b:cs)=(a,b):pair cs; pair _ = []; deinterleave = unzip . pair; fold f z [] = z; fold f z [a,b] = f (f z a) b; fold f z xs = let (ys,zs)=deinterleave xs in f (fold f z ys) (fold (flip f) z zs) in fold
15:39:01 <lambdabot>  Defined.
15:39:20 <mmorrow> > foldt (\a b->parens(a<>text "+"<>b)) (int 0) (fmap int [1..16])
15:39:21 <lambdabot>   (((((0+1)+9)+(13+(5+0)))+(((0+7)+15)+(11+(3+0))))+((((0+4)+12)+(16+(8+0)))+...
15:39:27 <mmorrow> > foldt (\a b->parens(a<>text "+"<>b)) (int 0) (fmap int [1..8])
15:39:29 <lambdabot>   ((((0+1)+5)+(7+(3+0)))+(((0+4)+8)+(6+(2+0))))
15:39:32 <adekoba> hello. I've written an ID3 tag parser library, but I'm unsure of what the best API for it would be. I'm unsure of whether to make a data stucture of the frame types themselves, or make them constructors for the general frame type.
15:40:00 <adekoba> If I were to make a data structure of the frame types, I would need accessor functions to prevent misuse
15:40:15 <xerox> mmorrow: some kind of tree?
15:40:15 <calsaverini> Saizan_ just a sec
15:40:53 <calsaverini> Saizan_ so, the prefered way to install packages from hackage is to do just "cabal install blablabla" and install it in your local home?
15:41:07 <mmorrow> xerox: yeah, it repeatedly de-interleaves the list until it gets to lists of two elems, the starts back up the recursion tree combining stuff
15:41:20 <Saizan_> calsaverini: yes
15:41:23 <mmorrow> xerox: which is the exact recursion pattern of the FFT
15:41:33 <xerox> mmorrow: is it? that's nice.
15:41:45 <calsaverini> Saizen_ I am obsessed with installing all globally for some reason
15:42:33 <calsaverini> Saizan_ I'll try to install some package again to get the errors
15:43:03 <calsaverini> Saizan_ is there any package you know that should surely install correctly if cabal is well configured?
15:43:03 <Saizan_> calsaverini: "--global --root-cmd=sudo" works for installing them globally
15:44:16 <Saizan_> calsaverini: zlib
15:44:33 <mmorrow> @let foldt2 = let pair(a:b:cs)=(a,b):pair cs; pair _ = []; deinterleave = unzip . pair; fold f z [] = z; fold f z [a,b] = f a b; fold f z xs = let (ys,zs)=deinterleave xs in f (fold f z ys) (fold f z zs) in fold
15:44:34 <lambdabot>  Defined.
15:44:39 <mmorrow> might be better def
15:45:00 <mmorrow> > foldt2 (\a b->parens(a<>text "+"<>b)) (int 0) (fmap int [1..8])
15:45:01 <lambdabot>   (((1+5)+(3+7))+((2+6)+(4+8)))
15:45:40 <calsaverini> Saizan_ :/ that one is installing correctly
15:45:43 <xerox> ?type L.int
15:45:44 <lambdabot> Not in scope: `L.int'
15:46:16 <calsaverini> Saizan_ I just was unlucky to try to install 4 broken packages in a row
15:46:16 <benmachine> :t int
15:46:18 <lambdabot> Int -> Doc
15:46:24 <calsaverini> Saizan_ maybe
15:47:36 <Saizan_> calsaverini: we can generally work around those failures by giving hints on what packages to choose
15:48:05 <calsaverini> ok
15:48:15 <calsaverini> I have the error messages
15:48:35 <calsaverini> I'm trying to install template-haskell to install yi
15:48:39 <Saizan_> use a pastebin
15:48:49 <calsaverini> ok
15:48:56 <Saizan_> no, you can't install a new template-haskell
15:49:21 <calsaverini> ahhhn
15:49:39 <calsaverini> maybe that's why yi isn't installing:?
15:49:44 <Saizan_> yeah
15:49:46 <Saizan_> use -f-template_2_4
15:49:51 <calsaverini> hummm
15:49:52 <Saizan_> so that it doesn't try to
15:49:53 <calsaverini> thanks
15:49:54 <Botje> hmmmm
15:50:01 <Botje> cabalizing parts of GHC..
15:50:07 <Botje> cabal install monad-comprehensions
15:50:56 <calsaverini> well It's still trying to install template-haskell
15:52:04 <MarcWeber> Can I use -Wall without -fwarn-missing-signatures ?
15:52:19 <aavogt> MarcWeber: -fno-warn...
15:52:23 <calsaverini> Saizan_ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14817#a14817
15:52:23 <shapr> MarcWeber, Tried mixing -Wall with -fnowarn-missing-signatures ?
15:52:25 <shapr> dang
15:52:27 <shapr> too slow
15:53:10 <Saizan_> calsaverini: --constraint="template-haskell < 2.4"
15:53:57 <Saizan_> or maybe --constraint="data-accessor-template < 0.2.1.2" is better.
15:54:17 <Saizan_> and you'd probably also need --constraint="data-accessor < 0.2.1"
15:54:37 * Saizan_ should publish these hints on the web
15:56:56 <benmachine> hmm I got     Not in scope: data constructor `CharConstr'
15:57:05 <benmachine> building template-haskell
15:57:10 <benmachine> is CharConstr new?
15:57:18 <Peaker> benmachine: I think 6.12 changes StringConstr to CharConstr
15:57:22 <Peaker> benmachine: I got the opposite
15:57:27 <Saizan_> you can't upgrade template-haskell
15:57:28 <benmachine> ah
15:57:37 <benmachine> oh, is it like base?
15:57:39 <Saizan_> nor downgrade etc..
15:57:40 <Peaker> benmachine: when I tried compiling older template-haskell from hackage on 6.12,
15:57:42 <Saizan_> yeah
15:58:03 <benmachine> cabal went ahead and tried anyway
15:58:12 <calsaverini> Worked!
15:58:18 <calsaverini> Thanks Saizan_
15:58:22 <Saizan_> np
15:59:05 <bnijk_> i'm on a hunger strike until my haskell logo is made official
15:59:08 <bnijk_> http://community.haskell.org/~hexpuem/logo_contest/haskell_5.png
15:59:27 <bnijk_> http://www.haskell.org/logos/logos/logo7000.png this one is boring ;)
15:59:34 <mtnviewmark> did you draw that with Context Free?
15:59:40 <bnijk_> no
15:59:57 <monochrom> May you die of hunger.
16:00:28 <gwern> dons: btw, I don't know whether you've updated rss2irc recently but http4k seems to make downloading much easier than all the code supporting '
16:00:32 <gwern> get :: URI -> IO String'
16:00:33 <sproingie> bnijk_: what do you call it, "Monad Tutorial"?
16:00:37 <bnijk_> lol
16:00:43 <bnijk_> it reminds me of haskell
16:00:44 <chrisdone> bnijk_: that one is a gorgeous logo!!1
16:00:44 <mtnviewmark> if you reduce it down to the size you'd need it to brand web pages and the like, it kind of looks like an abstract Ostritch
16:01:17 <chrisdone> bnijk_: this is the best ever: http://haskellwebnews.files.wordpress.com/2009/12/haskell-logo-variation.png?w=128&h=128
16:01:27 <chrisdone> I want to make love to it
16:01:37 <bnijk_> i don't like it
16:01:44 <bnijk_> doesn't convey anything
16:02:04 <xerox> conveys 2.0-ness
16:02:06 <lament> other than the obvious "Haskell is a railway company"?
16:02:14 <Peaker> Or Haskell is all about monads :)
16:02:17 <gwern> bnijk_: actually, it conveys the result of the monadic comptuation on the left hand side to the function on the righthand side
16:02:21 <chrisdone> bnijk_: conveys tonnes of things
16:02:24 <bnijk_> gwern: >::OOOOOO
16:02:27 <gwern> bnijk_: this could be a lot, such as gigs of data
16:02:43 <bnijk_> doesn't convey anything *visually*
16:02:48 <bnijk_> as opposed to *syntactically*
16:03:10 <xerox> "you're going to type these symbols."
16:03:37 <Ytinasni> i've never typed a lambda.
16:03:41 <bnijk_> everybody in this channel always takes everything literally
16:03:44 <benmachine> bnijk_: your logo conveys that haskell will chop me into very small pieces if I touch it incautiously
16:03:48 <chrisdone> purple is an exotic, rich colour. green is a natural colour. it's smooth and rounded and shiny and sleek, and the lambda/notational aspect tells you that it's founded in math theory
16:03:52 <bnijk_> benmachine: yes, that is accurate
16:03:57 <bnijk_> is it not?
16:04:24 <benmachine> :(
16:04:26 <gwern> bnijk_: it was funnier to take it literally
16:04:32 <bnijk_> yeah yeah
16:04:43 * bnijk_ disappears
16:04:58 * bnijk_ *poof*
16:05:09 * chrisdone itches to use the word butthurt
16:11:57 <medfly> why is a logo so important, we all use textual editors to write code and compile in the textual ghc
16:12:36 <Taejo> medfly: but we don't all use lynx to browse the web
16:12:53 <chrisf> no, some of use use wget and vi
16:12:56 <medfly> I think that logo is nice
16:12:57 <medfly> ahahahaha
16:13:09 <chrisf> c_c
16:13:38 <mm_freak> >λ=
16:14:32 <Taejo> >,\=
16:14:38 <medfly> we could always use http://uncyclopedia.wikia.com/wiki/File:Halflife-Haskell.jpg
16:14:44 <mark11> in haskell, if you want to run a suffix sort (given a list of characters, create list with all elements, then a list with all elements minus the first, then all minus the second... then sort the list of these lists), how would you express the iteration? i'm having trouble converting from the imperative idiom of suffixes[i] = s.substring(i, suffix.length) to something that makes sense in haskell
16:15:11 <mark11> *sorry, all minus the first, then all minus the first two, etc.
16:15:50 <aavogt> > tails "mark11"
16:15:51 <lambdabot>   ["mark11","ark11","rk11","k11","11","1",""]
16:15:52 <Taejo> > sequence . map tails $ ["Taejo", "mark11"]
16:15:53 <lambdabot>   [["Taejo","mark11"],["Taejo","ark11"],["Taejo","rk11"],["Taejo","k11"],["Ta...
16:16:05 <Taejo> > sequence . map inits $ ["Taejo", "mark11"]
16:16:07 <lambdabot>   [["",""],["","m"],["","ma"],["","mar"],["","mark"],["","mark1"],["","mark11...
16:16:40 <Taejo> > map inits $ ["Taejo", "mark11"]
16:16:41 <lambdabot>   [["","T","Ta","Tae","Taej","Taejo"],["","m","ma","mar","mark","mark1","mark...
16:17:01 <mark11> ok, awesome. thank you!
16:17:18 <aavogt> @src tails
16:17:18 <lambdabot> tails []         = [[]]
16:17:18 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
16:21:38 <lispy> > reverse . tails $ "ninja"
16:21:39 <lambdabot>   ["","a","ja","nja","inja","ninja"]
16:22:25 <lispy> > "a" `elem` (tails "ninja")
16:22:26 <lambdabot>   True
16:22:30 <Peaker> @check liftA2 (==) (iterate tail) tails
16:22:31 <lambdabot>   "Falsifiable, after 0 tests:\n[(),()]\n"
16:22:45 <lispy> I guess the reverse is not really needed here
16:22:47 <ujihisa> > take 10 . reverse . tails $ [1..]
16:22:49 <Peaker> nice way of implementing tails via iterate?
16:22:52 <lambdabot>   mueval: ExitFailure 1
16:23:18 <Taejo> iterate tail "abc"
16:23:21 <Taejo> > iterate tail "abc"
16:23:22 <xerox> :t takeWhile (not . null) . iterate tail
16:23:26 <lambdabot>   mueval-core: Time limit exceeded
16:23:27 <lambdabot> forall a. [a] -> [[a]]
16:23:27 <lispy> Peaker: Wouldn't unfoldr be easier than iterate?
16:23:40 <aavogt> > unfoldr (\x -> do listToMaybe x; return $ tail x) "lipy?"
16:23:41 <lambdabot>   Couldn't match expected type `(a1, [a])'
16:23:42 <lambdabot>         against inferred type `[a]'
16:23:50 <Taejo> > takeWhile (not . null) . iterate tail $ "abc"
16:23:52 <lambdabot>   ["abc","bc","c"]
16:24:07 <lispy> Taejo: nice
16:24:23 <Taejo> lispy: it was xerox
16:24:29 <aavogt> > unfoldr (\x -> do listToMaybe x; return $ (x,tail x)) "lipy?"
16:24:29 <lambdabot>   ["lipy?","ipy?","py?","y?","?"]
16:24:34 <Taejo> but it's still not the same as tails
16:24:35 <Berengal> > unfoldr (\x -> listToMaybe x >> return . join (,) $ tail x) "foobar"
16:24:36 <lambdabot>   Couldn't match expected type `a -> a1'
16:24:36 <lambdabot>         against inferred type `Data....
16:24:50 <Berengal> > unfoldr (\x -> listToMaybe x >> (return . join (,) $ tail x)) "foobar"
16:24:51 <lambdabot>   ["oobar","obar","bar","ar","r",""]
16:25:00 <xerox> :t (++[]) . takeWhile (not . null) . iterate tail
16:25:01 <lambdabot> forall a. [a] -> [[a]]
16:25:05 <xerox> err
16:25:10 <xerox> :t (++[[]]) . takeWhile (not . null) . iterate tail
16:25:11 <lambdabot> forall a. [a] -> [[a]]
16:25:25 <aavogt> unfoldr does less traversals
16:25:46 <xerox> possibly the compositions get fused?
16:25:50 <Berengal> The traversals could be fused
16:26:06 <xerox> (not sure it *actually* happens)
16:26:16 <Berengal> There is a solution. That's good enough ;)
16:26:37 <xerox> :)
16:26:51 <xerox> I like unfoldr too.
16:26:55 <Taejo> I must say I've more than once had use for a version of takeWhile which includes the first element that fails the predicate
16:27:19 <xerox> ?src takeWhile
16:27:19 <lambdabot> takeWhile _ []                 =  []
16:27:19 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
16:27:19 <lambdabot>                    | otherwise =  []
16:27:52 <xerox> another version with    | otherwise = [x]   what could it be called?
16:27:54 <Taejo> xerox: so I'd like "... | otherwise = [x]"
16:27:54 <aavogt> does the order you write your case expression cases matter at all?
16:28:23 <Taejo> aavogt: yes
16:28:36 <aavogt> I mean when it doesn't change the meaning of the code
16:28:38 <Taejo> in general
16:28:41 <Taejo> oic
16:29:03 <mnislaih> ping MarcWeber
16:29:16 <aavogt> case x of Left a -> .. ; Right a -> ..; Center a -> ...; ...
16:29:28 <aavogt> is that more efficient if you expect mostly Left constructors?
16:30:24 <Saizan> aavogt: GHC uses the order in which the constructors appear in the data definition, iirc
16:30:33 <sinelaw> is there a library for binomial coefficients?
16:35:31 <mnislaih> dolio: ping
16:35:55 <mnislaih> dolio: I have a patch for bytestring-show to make it work with 6.12
16:43:54 <alp_> can we ask about haddock here ?
16:43:59 <alp_> +questions
16:44:49 <shachaf> alp_: I think you can either ask Haddock questions or ask about Haddock, but not ask about Haddock questions.
16:45:23 <alp_> shachaf, rather meant "can we ask questions about Haddock"
16:45:29 <alp_> the questions had to go there in my sentence.
16:45:32 <shachaf> Ah. :-)
16:46:20 <alp_> anyway, I'm using UArr (from the uvector package). when creating the doc using haddock, I get : Warning: Neuron: could not find link destinations for:
16:46:20 <alp_>     GHC.Types.Double Data.Array.Vector.UArr.UArr GHC.Show.Show (for example)
16:46:23 <alp_> how can I fix that ?
16:46:26 <medfly> I think it's okay to ask questions about any questions.
16:46:52 <dmwit> Install the docs for UArr?
16:46:56 <benmachine> is it ok to ask questions about questions about questions?
16:47:02 <dmwit> No!
16:47:11 <dmwit> It's not okay to ask questions about questions at all!
16:47:13 <alp_> dmwit, isn't it done when installing UArr with cabal ?
16:47:14 <dmwit> RRRR
16:47:18 <dmwit> alp_: Not by default.
16:47:22 <alp_> oh
16:47:40 <dmwit> alp_: There's a setting in your cabal config to switch on doc installations.
16:47:54 <benmachine> it should be on by default if you ask me
16:48:06 <benmachine> (if it isn't already, I don't know)
16:48:55 <alp_> dmwit, any pointer documenting that switch ?
16:49:10 <dmwit> um
16:49:13 <benmachine> edit .cabal/config
16:49:18 <benmachine> it's commented out in there
16:49:20 <benmachine> I think
16:49:26 <dmwit> alp_: documentation: False
16:49:27 <dmwit> ;-)
16:49:35 <alp_> oh ok thanks
16:49:43 <dmwit> (Switch it to True, obviously.)
16:50:03 <alp_> dmwit, yeah, I got that :-p
16:50:13 <Twey> I thought it was meant to be FileNotFound
16:50:18 <dmwit> brillant
16:51:45 <brad_larsen> How does one get alex, happy, and cabal to all play nicely together?
16:52:02 <dmwit> cabal install alex happy # doesn't this work?
16:52:14 <monochrom> by using haskell platform instead :)
16:52:15 <brad_larsen> Let me be more specific...
16:52:19 <dmwit> yes plz
16:52:20 <dmwit> =)
16:52:29 <brad_larsen> I'm writing a cabal package.
16:52:46 <brad_larsen> silly calculator program, to get the hang of things
16:52:53 <brad_larsen> using alex for lexing, happy for parsing
16:53:13 <brad_larsen> I want alex & happy to be run as appropriate, when building the calc executable defined in my cabal file
16:53:18 <brad_larsen> i have
16:53:23 <brad_larsen> executable calc
16:53:24 <brad_larsen> ...
16:53:28 <dmwit> ?hpaste
16:53:28 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:53:33 <brad_larsen> yes
16:53:36 <brad_larsen> thanks :-)
16:54:20 <brad_larsen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14818#a14818
16:54:21 <brad_larsen> there
16:54:23 <calsaverini> how should I modify a .cabal file to allow for FlexibleInstances?
16:54:34 <brad_larsen> the thing is, though, that alex is not being run before happy
16:54:42 <dmwit> calsaverini: Modify the file that needs it, instead.
16:54:45 <brad_larsen> and hence the build fails, since the lexer .hs file isn't generated
16:54:52 <dmwit> {-# LANGUAGE FlexibleInstances #-}
16:54:54 <ezyang> Can someone familiar with the tmr LaTeX class explain to me what the algorithm is used for deciding that all listings will go after the text?
16:54:56 <calsaverini> humm
16:54:58 <ezyang> as opposed to inline?
16:55:20 <calsaverini> dmwit isn't there a shortcut for that? There are a lot of files
16:55:44 <dmwit> calsaverini: Yes, there's a ghc-options flag for cabal files if you want it for every single one.
16:55:58 <ezyang> oh hey... I botched the syntax. Nvm.
16:56:28 <dmwit> calsaverini: http://www.haskell.org/cabal/release/cabal-1.6.0.2/doc/users-guide/authors.html#buildinfo
16:56:37 <dmwit> calsaverini: See the "extensions:" bit.
16:58:04 <dmwit> brad_larsen: Hm, maybe you need a different build-type.
16:58:05 <lifflander_> Hoogle question: does anyone know why this is broken, specifically "http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html"
16:58:23 <dmwit> brad_larsen: I've never done this before myself.  Perhaps you should look at a project that uses these successfully?
16:59:09 <dmwit> lifflander_: Put a version number on the package name, i.e. s/base/base-4.2.0.0/
16:59:44 <lifflander_> dmwit: I did this and it worked, but why does Hoogle lead to a broken link for things like "Data.List"
16:59:55 <dmwit> Because Hoogle hasn't been updated.
16:59:57 <dmwit> File a bug.
17:00:07 <lifflander_> Okay, thanks.
17:01:55 <osaunders> Any suggestions on what I should use to write a whitespace-sensitive grammar?
17:02:14 <xerox> a lexer?
17:02:20 <dmwit> The usual suspects, I guess.
17:02:44 <osaunders> Yes whitespace sensitive lexer.
17:03:18 <dmwit> alex, parsec, readp?
17:04:30 <eugenn> @pl (\ f x y -> f y x)
17:04:31 <lambdabot> flip
17:04:53 <eugenn> @pl (\ f x y z -> f y x z)
17:04:53 <lambdabot> flip
17:05:05 <eugenn> @pl (\ f x z y -> f y x z)
17:05:05 <lambdabot> (flip .) . flip
17:05:26 <eugenn> @pl (\ f x y z -> f z y x)
17:05:26 <lambdabot> flip . (flip .) . flip
17:05:41 <ezyang> Anyone know how to specify GHC extensions from a literate Haskell file?
17:05:58 <dmwit> > {-# LANGUAGE Etc #-}
17:06:00 <Peaker> ezyang: maybe a > {-# LANGUAGE ... #-} ?
17:06:00 <lambdabot>   not an expression: `{-# LANGUAGE Etc #-}'
17:06:12 <dmwit> ?botsnack I'm sorry, little guy.
17:06:13 <lambdabot> :)
17:06:34 <ezyang> Peaker: Oh, the extra thing: I'm doing LaTeX, not plaintext
17:06:34 <eugenn> ? lambdabot smiled??
17:06:48 <ezyang> maybe I can put it in a \ignore{} block
17:06:52 <c_wraith> there's also {-# GHC_OPTION blah #-} for things that there aren't extensions for.  (like -f-no-warn-orphan)
17:07:10 <alp_> wow
17:07:18 <alp_> mkcabal tells me
17:07:37 <alp_> mkcabal: Prelude.read: no parse
17:07:43 <alp_> freaky.
17:07:45 <ezyang> \ignore{\begin{code}{-# LANGUAGE TypeSynonymInstances #-}\end{code}}  didn't seem to work
17:08:10 <ezyang> ah, putting it after the preamble worked
17:08:11 <xerox> alp_: maybe with  loch  you can find it *where* it goes wrong
17:08:24 <eugenn> > intercalate " " " " "
17:08:25 <lambdabot>   <no location info>:
17:08:25 <lambdabot>      lexical error in string/character literal at end o...
17:08:28 <alp_> good idea xerox
17:08:35 <eugenn> > intercalate " " " "
17:08:35 <xerox> http://www.cse.unsw.edu.au/~dons/loch.html
17:08:35 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:08:36 <lambdabot>         against inferred ty...
17:08:42 <alp_> thanks :)
17:08:46 <xerox> alp_: if you find out I'd love to know :)
17:08:50 <dmwit> ezyang: Is the \ignore really necessary?
17:09:10 <dmwit> > intercalate " " [" ", "b", "c"]
17:09:11 <lambdabot>   "  b c"
17:09:15 <alp_> xerox, you in charge of some cabal related dev ?
17:09:32 <xerox> alp_: nope, but I'd like to have mkcabal work too. It bit me some time ago.
17:09:34 <mark11> in ghci, why would "tails 'abc'" return the exception "non-exhaustive patterns in function tails"?
17:09:41 <alp_> xerox, oh okay
17:09:57 <ezyang> dmwit: No... but I sort of don't want the "standard proceedings" gunking up the article
17:09:59 <alp_> xerox, nothing found out using loch ?
17:10:13 <xerox> Didn't try. Just remembered now :)
17:10:36 <aavogt> > tails []
17:10:37 <lambdabot>   [[]]
17:11:39 <aavogt> mark11: if you're using the same tails function as the rest of us, it's patterns are exhaustive
17:11:42 <eugenn> > map tails (replicate 8 [])
17:11:43 <lambdabot>   [[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]]]
17:12:06 <eugenn> > concat (map tails (replicate 8 []))
17:12:07 <lambdabot>   [[],[],[],[],[],[],[],[]]
17:12:18 <mark11> yep, i'm just using the standard tails function
17:12:36 <aavogt> you didn't  let tails = ....
17:12:56 <dmwit> Oh, hey, haddock's mini_ variants of pages are quite nice-looking!
17:13:02 <dmwit> How come I didn't know about these sooner?
17:13:07 <xerox> dmwit: what what?
17:13:13 <xerox> ?docs
17:13:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:13:17 <alp_> xerox, oh, I installed the archlinux AUR version of mkcabal and it works.
17:13:36 <dmwit> xerox: e.g. http://haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/mini_Data-List.html
17:13:48 <xerox> alp_: so the mystery continues.
17:13:51 <mark11> aavogt: thanks. i must've done that earlier without realizing it. i am an idiot.
17:13:58 <alp_> xerox, I'll investigate tomorrow
17:14:12 <xerox> alp_: wonderful :)
17:14:23 <alp_> xerox, maybe it can't locate readline/whatever
17:14:27 <luqui> does anyone know an algorithm which sorts the nodes in a graph into an array such that nearby nodes in the graph are nearby in the array
17:14:28 <alp_> well
17:14:29 <alp_> no idea ftm.
17:14:56 <eugenn> > let nTimes n f = foldl1 (.) (replicate n f) in nTimes 5 (+1) 18
17:14:57 <lambdabot>   23
17:15:10 <chessguy> luqui, sounds like a touring-complete problem
17:15:23 <luqui> chessguy, shutup you :-P
17:15:25 * chessguy giggles
17:15:56 <luqui> yeah i read that it was No-Problem complete
17:16:12 <dmwit> luqui: Well, that's a pretty vague description.  But toposort is maybe similar...?
17:16:21 <monochrom> Dijkstra called his car "the touring machine"
17:16:32 <xerox> hahaha.
17:17:08 <luqui> dmwit, does topsort do a decent job.  The description is vague because there are a lot of ways to solve it
17:17:21 <luqui> (or maybe there are a lot of ways to solve it because the description is vague)
17:17:21 <eugenn> :t topsort
17:17:22 <lambdabot> Not in scope: `topsort'
17:17:36 <monochrom> Lots of ways to interpret it.
17:17:47 <dmwit> http://en.wikipedia.org/wiki/Topological_sort
17:18:01 <xerox> dmwit: anyway, it's really nice the mini version.
17:18:07 <luqui> yeah true.  basically i've got a big ass-graph and am finding neighbors, and i want good cache locality
17:18:30 <aavogt> ass-graph eh?
17:18:36 <eugenn> :t (:)
17:18:37 <lambdabot> forall a. a -> [a] -> [a]
17:18:51 <luqui> aavogt, http://xkcd.com/37/
17:19:07 <Peaker> can lambdabot join #enough ?
17:19:42 <xerox> @join #enough
17:19:43 <lambdabot> Not enough privileges
17:22:08 <brad_larsen> dmwit: sorry, I was pulled away from the computer
17:22:24 <eugenn> @pl qsort (x:xs) = qsort (filter (<=x) xs) ++ [x] ++ qsort (filter (>x) xs)
17:22:25 <lambdabot> qsort = fix ((`ap` tail) . (. head) . ap (ap . (liftM2 (++) .) . (. (filter . flip (<=))) . (.)) (liftM2 (.) (:) . (. (filter . flip (>))) . (.)))
17:22:38 <brad_larsen> dmwit: i've been looking for packages on hackage that use alex
17:22:46 <brad_larsen> dmwit: do you know any?
17:23:04 <dmwit> erm
17:23:15 <dmwit> ...no
17:23:16 <dmwit> =P
17:23:26 <brad_larsen> aha
17:23:31 <brad_larsen> owell ;-)
17:23:39 <eugenn> :t ap
17:23:39 <brad_larsen> happy seems to be invoked automatically
17:23:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:23:44 <brad_larsen> alex, not so much.
17:23:49 <eugenn> :t on
17:23:49 <dmwit> brad_larsen: The "Compilers/Interpreters" section seems like a good place to start looking, though.
17:23:49 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:26:35 <eugenn> > @quote basic
17:26:36 <lambdabot>   <no location info>: parse error on input `@'
17:26:41 <eugenn> @quote basic
17:26:41 <lambdabot> DRMacIver says: So basically the lambda calculus is a demonstration that verbing weirds language? :)
17:27:23 <kmc_> verbs all the way down
17:28:33 <largos> I'm trying to understand 'cabal test', and in the process, I've realized I need to define a runTests user hook
17:28:44 <eugenn> @pl natural x = natural (x+1)
17:28:44 <lambdabot> natural = fix (. (1 +))
17:28:46 <largos> but I can't tell what the Bool param to runTests means
17:29:08 <largos> it appears that it is (almost?) always False...
17:29:23 <largos> does anyone happen to know?
17:31:03 <eugenn> @src sum
17:31:03 <lambdabot> sum = foldl (+) 0
17:32:33 <eugenn> @pl f x = x + 4 + 2
17:32:33 <lambdabot> f = (6 +)
17:33:00 <eugenn> @pl f x = x f
17:33:00 <lambdabot> f = fix (flip id)
17:33:05 <luqui> @pl f x = 2 + x + 4
17:33:05 <lambdabot> f = (6 +)
17:33:09 <luqui> nice :-)
17:33:21 <luqui> :t flip id
17:33:21 <lambdabot> forall a b. a -> (a -> b) -> b
17:34:04 * monochrom silently makes a Num instance with non-associative non-commutative (+)
17:34:32 <monochrom> instance Num Ordinal where .... hehehe!
17:34:37 <largos> monochrom: are you reimplementing PHP as a DSL?
17:34:44 <shachaf> @slap monochrom
17:34:44 * lambdabot karate-chops monochrom into two equally sized halves
17:35:14 <eugenn> @slap lambdabot
17:35:14 * lambdabot loves lambdabot, so no slapping
17:35:21 <eugenn> haha
17:35:24 <largos> heh
17:36:17 <eugenn> @pl 4 . 2
17:36:17 <lambdabot> 4 . 2
17:36:30 <c_wraith> heh.  @pl doesn't typecheck
17:36:56 <c_wraith> though with caleskell, it's fully possible someone could make Integer a functor instance.  somehow
17:37:05 <Berengal> @pl doesn't even term check
17:37:06 <lambdabot> doesn't even term check
17:37:25 <largos> what is @pl?
17:37:29 <doserj> there is no typing error anyways...
17:37:30 <Berengal> pointless
17:37:36 <eugenn> > (\(x+1) -> x) 5
17:37:38 <lambdabot>   4
17:37:40 <dmwit> ?pl \f x -> f x
17:37:41 <lambdabot> id
17:37:48 <eugenn> > (\(x+2) -> x) 5
17:37:49 <lambdabot>   3
17:37:58 <dmwit> ?pl \x -> f (g (h (i x)))
17:37:59 <lambdabot> f . g . h . i
17:37:59 <c_wraith> @pl f x y = x + y
17:37:59 <lambdabot> f = (+)
17:38:23 <eugenn> > (\(x+3) -> x) 5
17:38:23 <lambdabot>   2
17:38:36 <Berengal> @pl (\x -> [ [foo, bar, x])
17:38:36 <eugenn> > (\(x+3+1) -> x) 5
17:38:36 <lambdabot> (line 1, column 8):
17:38:36 <lambdabot> unexpected "["
17:38:36 <lambdabot> expecting lambda abstraction or expression
17:38:37 <lambdabot>   <no location info>: Parse error in pattern
17:39:07 <eugenn> > (\(x+1) -> x) 5
17:39:07 <lambdabot>   4
17:39:12 <eugenn> > (\(x-1) -> x) 5
17:39:13 <lambdabot>   <no location info>: Parse error in pattern
17:39:21 <Berengal> @pl (\x -> [y | y <- [z | z <- x]]
17:39:21 <lambdabot> (line 1, column 31):
17:39:21 <lambdabot> unexpected end of input
17:39:21 <lambdabot> expecting variable, "(", operator or ")"
17:39:27 <doserj> @type let (.) f g x = f (g x) in 4 . 2 -- even without caleskell
17:39:28 <lambdabot> forall t t1 t2. (Num (t -> t1), Num (t2 -> t)) => t2 -> t1
17:39:30 <Berengal> @pl (\x -> [y | y <- [z | z <- x]])
17:39:31 <lambdabot> return . ((y | y) <-) . return . ((z | z) <-)
17:39:37 <eugenn> how can that be? why does + work for pattern matching if it's not a data constructor?
17:39:40 <Berengal> There we go, broken @pl parser
17:39:49 <aavogt> eugenn: n plus k patterns
17:39:53 <c_wraith> eugenn: they're called n+k patterns.
17:39:59 <c_wraith> eugenn: and should really never be used.
17:40:06 <eugenn> oh! thanks
17:40:07 <aavogt> they are going away in haskell 2010
17:40:21 <eugenn> there seem preety useless
17:40:27 <Berengal> eugenn: It won't work for long. They're depricated, obsolete, singing with the choire invisible etc.
17:40:48 <brad_larsen> dmwit: fixed it!  I needed to list my CalcLexer and CalcParser modules in the other-modules field in my cabal file.
17:40:49 <c_wraith> are they an ex-feature?
17:40:50 <eugenn> hehe, for more powerful pattern matching we have prolog
17:41:35 <dmwit> brad_larsen: Sweet!
17:42:14 <eugenn> @src intersect
17:42:14 <lambdabot> intersect = intersectBy (==)
17:43:19 <alp_> > interserctBy ((==0) . mod) [1..10] [1..10]
17:43:20 <lambdabot>   Not in scope: `interserctBy'
17:43:25 <alp_> > intersectBy ((==0) . mod) [1..10] [1..10]
17:43:26 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
17:43:26 <lambdabot>         against inferred ...
17:43:42 <eugenn> @pl f x y = y
17:43:42 <lambdabot> f = const id
17:43:55 <drdr> hi haskell users
17:44:07 <eugenn> hi drdr
17:44:12 <drdr> maby one of you can awnser my question
17:44:44 <drdr> i tired to learn a functioanl programing language but totaily facepalmed at the function writing serching stuff part
17:44:45 <drdr> any reson why?
17:44:56 <kmc_> which language did you try to learn, and how?
17:45:07 <drdr> haskell lernyouahaskell
17:45:08 <kmc_> and i don't know what part you refer to
17:45:24 <drdr> umm ill find it
17:46:49 <drdr> http://learnyouahaskell.com/syntax-in-functions#pattern-matching
17:46:56 <eugenn> > let allEven = all even in allEven [1,3,5,7,431]
17:46:57 <lambdabot>   False
17:47:17 <kmc_> drdr, okay.  what trouble are you having with this section?
17:47:46 <drdr> two thighs one haskell is WAYY too big and that it aggravated me enought to stop trying
17:48:11 <kmc_> in what way is it "big"?
17:48:17 <Berengal> drdr: Just a background question: What other languages do you know?
17:48:46 <drdr> umm ruby python java vb some C varaents
17:49:23 <Berengal> Okay. Now, Haskell is pretty different from all of those, which is probably why it seems so daunting at first.
17:49:25 <Peaker> @pl const . Set.singleton $ AG.Id AG.Edge jd
17:49:25 <lambdabot> const (Set.singleton (AG.Id AG.Edge jd))
17:49:45 <Berengal> Those languages probably seemed rather "big" when you first started out learning to program
17:49:52 <drdr> not really
17:49:58 <drdr> its just that they made more sence
17:50:10 <kmc_> drdr, can we help you make sense of this section?
17:50:15 <EvilTerran> haskell makes plenty of sense
17:50:26 <drdr> not unless you know of a lighter guide
17:50:38 <drdr> and a smaller haskell implimentation
17:50:39 <kmc_> drdr, really, you aren't willing to let us try?
17:50:43 * Twey laughs.
17:50:44 <kmc_> smaller implementation?
17:50:50 <eugenn> try Hugs
17:50:51 <drdr> i would be but i uninstalled haskell
17:50:51 <kmc_> you care about the size of your GHC binary?
17:50:55 <drdr> i do
17:50:57 <Berengal> There is Helium... Don't know it's current state...
17:50:57 <alp_> yay, I should release a library to hackage soon
17:51:01 <drdr> when its 100mb's
17:51:01 <kmc_> drdr, there is no program called "haskell"
17:51:06 <kmc_> drdr, why do you care
17:51:16 <EvilTerran> haskell's just different from other programming languages; one could argue that thinking of haskell as maths instead of programming might be more helpful
17:51:18 <drdr> because my ssd is 3.9 mb
17:51:26 <kmc_> drdr: 187M    /usr/lib/python2.3
17:51:26 <ivanm> Berengal: AFAIK, it's dea
17:51:29 <ivanm> *dead
17:51:33 * Twey wonders how big CPython is these days
17:51:41 <Berengal> ivanm: I thought I had read something about some work being done this summer...
17:51:49 <ivanm> *shrug* maybe
17:52:00 <ivanm> I just know that its build procedure is a right royal PITA (due to using Java)
17:52:00 <Berengal> Twey: I just installed python3. Took 20mb of extra space, according to apt-get
17:52:07 <kmc_> drdr, i don't imagine you can do much development on a machine with only 3.9 MB of storage.  perhaps the Tiny C compiler would fit
17:52:12 <ivanm> and the home page says its for ghc 6.8.{1,2} :s
17:52:17 <EvilTerran> "<drdr> ... ruby python java vb ..." <- all of which have tiny development environments, of course
17:52:19 <Twey> Hm, pacman says 63MB, excluding dependencies
17:52:20 <drdr> umm GB sorry
17:52:24 <kmc_> you certainly couldn't develop for ruby, python, java, or vb
17:52:24 <kmc_> heh
17:52:28 <Peaker> hlint seems to have a bug, suggesting to replace  const . f $ g   with   f
17:52:30 <Twey> Haha
17:52:38 <drdr> my ssd is 3.9gb
17:52:39 <Twey> You could fit a FORTH environment on there!
17:52:44 <ivanm> Peaker: :o
17:52:51 <ivanm> @type \ f g -> const . f $ g
17:52:52 <lambdabot> forall a b a1. (a1 -> a) -> a1 -> b -> a
17:52:55 <drdr> i have outher dev systems but my outher nix box is broken
17:52:57 <kmc_> drdr, okay.  as others said, you could try Hugs
17:53:09 <kmc_> which is a Haskell interpreter
17:53:14 <kmc_> rather than a compiler like GHC
17:53:15 <ivanm> > (const . succ $ 2) []
17:53:16 <lambdabot>   3
17:53:34 <Twey> Or just GHC.  100MB really isn't that much of 3.9GB, especially if the system is a dedicated development environment.
17:53:37 <Peaker> @type \ f g -> [f, const . f $ g]
17:53:38 <lambdabot> forall a b. (b -> a) -> b -> [b -> a]
17:53:43 <kmc_> you could also buy a bigger hard drive, or get one free in a box of cereal
17:53:49 <Twey> Hahahaha
17:54:03 <drdr> well its a really odd ssd laptop from chinatown
17:54:05 <kmc_> how much is a 1 GB USB thumbdrive these days?
17:54:05 <Twey> Or get a USB Flash drive :þ
17:54:12 <Twey> Yeah, I was about to say
17:54:13 <drdr> or a sd card
17:54:18 * Berengal has a fully functional nix on a 4GB pen-drive, with ghc
17:54:19 <drdr> all on my list
17:54:23 <Twey> I bought an 8GB one for £10 or so last year
17:54:33 <drdr> but thats beside the point
17:54:34 <Twey> They're probably about 25p now
17:54:37 <kmc_> is it?
17:54:41 <kmc_> what's the point, then?
17:54:48 <Berengal> There's always codepad
17:54:49 <Berengal> And lambdabot
17:54:52 <Berengal> @where codepad
17:54:53 <lambdabot> codepad.org
17:55:00 <Twey> drdr: If the point is that you want to program on a tiny tiny system, you should learn FORTH.
17:55:27 <drdr> its not that tiny
17:55:29 <Twey> But 3.9GB is perfectly big enough to fit about 39 GHCs plus all dependencies on.
17:56:36 <drdr> not when the rest is filled up with i have no idea what
17:57:05 <Twey> drdr: You could make some space by removing the Java environment — that probably costs about three times as much as GHC :þ
17:57:33 <drdr> im useing the runtime only on this laptop
17:57:37 <Berengal> Twey: By my latest calculations, my java dev environment comes out at 1.3 GB...
17:57:49 <Twey> Thirteen times, then.
17:58:01 <Berengal> But then again, I've got all the bells and whistles
17:58:16 <drdr> ...
17:58:18 <Twey> It's $several_times bigger.  :þ
17:58:20 <kmc_> drdr, you can get multi-GB USB sticks for free as promotions these days
17:58:31 <kmc_> go to a career fair or a conference or something
17:58:38 <kmc_> sometimes they have food as well
17:58:45 <kmc_> you can also beat up a small child and take his iPod
17:58:48 <drdr> and i normaly use ssh on my dev for java and outher stuff
17:58:50 <Twey> Hahahaha
17:59:01 * drdr likes SMALL software
17:59:13 <Berengal> I don't think advocating beating up children is a good way to convert people to haskell...
17:59:20 <kmc_> drdr, okay.  then you should program in C
17:59:23 <Twey> drdr: Seriously.  Go and learn FORTH.
17:59:25 <kmc_> not Haskell, certainly not Java or Python
17:59:27 <drdr> .....
17:59:39 <kmc_> i don't know what you want from us
17:59:41 <Twey> You can write a compiler in about half a kilobyte.
17:59:43 <eugenn> @me is here
17:59:44 <lambdabot> Maybe you meant: messages messages? . ? @ bf do ft id let map more msg pl rc time v wn
17:59:51 <eugenn> :me trying
17:59:58 <Twey> eugenn: I think you dropped this: /
18:00:13 * eugenn trying
18:00:13 <drdr> ide just like to find a guide to haskell that i can understand
18:00:14 <eugenn> oh
18:00:18 <Berengal> FORTH fits nine bits to the byte. It's the smallest language you'll get
18:00:25 <drdr> ide just like to find a guide to haskell that i can understand
18:00:33 <kmc_> drdr, okay.  does that have anything to do with how many megabytes GHC takes?
18:00:42 <drdr> not really
18:00:50 <Twey> Right then
18:00:51 <Twey> Progress!
18:00:53 <drdr> i just have no idea how this segway happened
18:00:58 <drdr> i dont think i started it
18:01:04 <Berengal> Back on topic then :)
18:01:07 <drdr> ill awk the logs latter
18:01:17 <kmc_> drdr, can you explain what part of LYAH you can't understand?
18:01:20 <kmc_> and hopefully why?
18:01:42 <kmc_> you said you got confused at pattern matching -- what's the first confusing statement in the section?
18:02:06 <drdr> # sayMe :: (Integral a) => a -> String
18:02:07 <lunabot>  luna: parse error on input `::'
18:02:17 <kmc_> drdr, that is a type signature
18:02:18 <Twey> That's not pattern matching
18:02:31 <drdr> sitll confuseing
18:02:38 <kmc_> it says that sayMe is a function.  the input to this function can be of any type, so long as that type is one of the "Integral" types.  the output is always a String
18:02:44 <Berengal> Types are explained in the previous section
18:03:03 <drdr> ok
18:03:08 <drdr> and i dont get # ghci> [a+b | (a,b) <- xs]
18:03:18 <Twey> drdr: That's a list comprehension.
18:03:21 <kmc_> (Integral a) => a -> String   <-- this means: "Suppose a is any Integral type.  This function will accept type 'a' and return a String."
18:03:22 <Twey> You should know them from Python.
18:03:29 <Berengal> > [a+b | (a,b) <- [(1,2),(3,4),(5,6)]]
18:03:31 <lambdabot>   [3,7,11]
18:03:32 <kmc_> [ a + b for (a,b) in xs [
18:03:33 <snowbeard> I have been lurking around here for a while and I wanted to tell you guys are great :)
18:03:36 <kmc_> [ a + b for (a,b) in xs ]  # in Python
18:03:38 <Twey> [a + b for (a, b) in xs]
18:03:45 <drdr> ah
18:03:54 <Twey> (but they were ours first!)
18:03:57 <eugenn> it's similar to how you define sets in math
18:04:08 <kmc_> i think the list comprehensions were also described earlier
18:04:13 <drdr> not in my math class
18:04:21 <drdr> but thats besides the point
18:04:33 <Berengal> You should read them as "<some expression with variable> where <variable> comes from <list>"
18:04:43 <drdr> ok thats MUCH better
18:05:22 <drdr> there needs to be a cheatsheet of these
18:05:45 <kmc_> @google haskell cheat sheet
18:05:46 <lambdabot> http://blog.codeslower.com/2008/10/The-Haskell-Cheatsheet
18:05:53 <kmc_> there's a couple i think
18:05:54 <Berengal> You can also put several generator expressions and guards in. For example [x + y | x <- listA, y <- listB, x /= y] means "x + y where x comes from listA and y comes from listB and x not equal y"
18:06:04 <Twey> drdr: http://cheatsheet.codeslower.com/CheatSheet.pdf
18:06:09 <Twey> Oh, someone got there first ☺
18:06:16 <Berengal> Or in python: [x + y for x in listA for y in listB if x != y]
18:07:03 <Twey> Didn't know Python could do that.  *learns*
18:07:16 <drdr> i think if anyone writes another haskell guide these archairc runes may be a important sectoin to add
18:07:32 <drdr> and python can do lots of things
18:07:35 <Twey> Haha
18:07:36 <Berengal> Twey: It's pretty much copied a-verbatim from haskell
18:07:40 <Twey> Yeah
18:07:42 <drdr> i use it with belnder3d
18:07:53 <Twey> I figured they left out the multiple-lists bit
18:08:03 <drdr> *me dosnt see haskell with a 3d modeling suite*
18:08:04 * Twey wants monad comprehensions back, too ☹
18:08:20 * Twey doesn't see anyone particularly caring
18:08:30 <drdr> i also like some tea
18:08:36 <Twey> And a pony!
18:08:40 <Twey> Oh wait, we have one of those.
18:09:06 <drdr> and rap music to die but i dont see any of those things happening  soon
18:09:22 <Twey> Ah, but monad comprehensions might
18:09:24 <Berengal> drdr: I just pretend it doesn't exist.
18:09:25 * kmc_ doesn't see Python with static checking
18:09:32 <drdr> it cans
18:09:36 <Twey> Well, strictly speaking, it doesn't
18:09:50 <Berengal> Twey: monad comprehensions are just do-notation with a funky syntax. I tend to use that instead of list-comprehension for building lists anyway
18:09:52 <Twey> Since ‘rap music’ is an oxymoron, and all
18:10:10 <Twey> Berengal: Basically, yeah — but it's a *handy* funky syntax
18:10:28 <drdr> not as oxymoronic whe you rap + e
18:10:32 <drdr> more just creepy then
18:10:42 <eugenn> > 1e18
18:10:43 <lambdabot>   1.0e18
18:10:47 <Twey> Still not seeing the connection to music
18:11:54 <Berengal> Ooo, python doesn't have to put the guards at the end of the comprehension either... I too am learning stuff
18:12:06 <drdr> pythons ok
18:12:32 <drdr> but its annoying when ubuntu uses it like its the OLNY programing language
18:12:56 <Berengal> ... Linspire uses Haskell instead...
18:12:59 <Peaker> It is great progress compared to shell scripts or bad Perl
18:13:32 <drdr> that it is
18:13:35 <Twey> Berengal: Really?  o.@
18:13:38 <drdr> but not as nice a rake taskes
18:13:41 <ivanm> Berengal: isn't linspire dead?
18:13:47 <drdr> microsoft now
18:13:50 <Twey> A… rake… taskes?
18:13:57 <drdr> *task
18:14:00 <xerox> check lambdabot hostname in /whois :-)
18:14:00 * Twey turns it upside down and peers at it.
18:14:10 <drdr> rake kinda like make
18:14:14 <drdr> but in ruby
18:14:22 <Berengal> ivanm: Pretty much...
18:14:38 <Twey> I've never dared ask why \b is in #unicycling
18:14:40 <Twey> drdr: Aha
18:14:47 <xerox> oh maybe linspire and linode are different things afterall.
18:14:47 <alp_> does hackage package checking shoud put documentation links and so on on the preview or is it normal there aren't there ?
18:14:49 <Twey> Well, it sounds… very useful.  ☺
18:14:57 <Mitar> hi, why this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14820 hangs?
18:15:10 <drdr> well write a logic tree
18:15:18 <drdr> and test out yer issue
18:15:23 <drdr> like a REAL man
18:15:38 <Mitar> it should loop forever
18:15:45 <Mitar> but it just hangs printing last line
18:15:56 <Mitar> (it is a standalone program, you can check it in ghci)
18:16:08 <Mitar> doProcessInput is the main function
18:16:30 <drdr> mintar you check for NULL pointers?
18:16:40 <Twey> Hahaha
18:16:45 <ezyang> Hot off the presses! First draft of part I of "Adventures in Three Monads."  People with free time and inclination for draft-reading see here: http://web.mit.edu/~ezyang/Public/threemonads.pdf
18:16:48 <Mitar> ?
18:16:55 <drdr> theres also a math equation but you wouldnt get it
18:16:58 <kmc_> haha drdr
18:17:20 <Berengal> alp_: The documentation is built in batches. It won't be up for a few hours after you upload.
18:18:00 <drdr> ill check it out ezy
18:18:08 <ezyang> drdr: Cool!
18:18:09 <Mitar> so anybody?
18:18:12 <alp_> Berengal, oh ok, so it's normal for the preview. I don't have an account yet, so the upload isn't for now
18:18:22 <alp_> thanks for the answer.
18:18:39 <drdr> mintar its your looping
18:18:53 * Berengal is glad his one hackage library finally became useful
18:18:56 <drdr> add a try
18:19:03 <Mitar> try?
18:19:05 <drdr> is that the diff one?
18:19:06 <kmc_> hahaha
18:19:07 <Mitar> it does not finish
18:19:11 <Mitar> it just hangs
18:19:22 <drdr> ya like have the code run in a try block
18:19:22 <Mitar> it is not that there would be any exception
18:19:38 <drdr> then benchmark it
18:19:43 <ezyang> is this Parsec code?
18:19:55 <kmc_> drdr, just out of curiosity: how high are you right now?
18:20:10 <Mitar> my code? no
18:20:13 <drdr> verry grouned
18:20:21 <Twey> Heheh
18:20:23 <drdr> maby -20 below
18:20:35 <drdr> i have issues typeing
18:20:38 <ezyang> oh, ok.
18:20:38 <Twey> A revealing if untruthful answer ;)
18:20:39 <drdr> without spellcheck
18:22:53 <c_wraith> > let (<-) = (+) in 4 <- 5
18:22:54 <lambdabot>   <no location info>: parse error on input `<-'
18:23:24 <ezyang> "don't do that!"
18:23:38 <c_wraith> really, I just was making sure that was an error. :)
18:25:10 <Mitar> i found out what it was
18:25:12 <Mitar> let newSpeed = max (-maxSpeed) (newSpeed - acceleration)
18:25:14 <Mitar> :-)
18:25:19 <Mitar> loop :-)
18:26:34 <Berengal> Those typoes always get me...
18:26:55 <Berengal> Even when I very specifically try to avoid them
18:27:00 <HaskellLove> Can some explain me what these "ellipsis patterns in records" thing is and does Haskell have them?
18:27:24 <ezyang> HaskellLove: Say again?
18:27:25 <BMeph> ezyang: I'll check it out, too. I think your Logic Monad might be a mobile, but I'll have to read more to be sure. :)
18:27:36 <aavogt> HaskellLove: RecordPuns or something like that
18:27:42 <aavogt> but it's only in ghc
18:28:03 <ezyang> BMeph: mobile?
18:28:03 <aavogt> @google ghc user manual
18:28:04 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html
18:28:04 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.12.1
18:28:11 <ezyang> BMeph: But thanks :-)
18:28:38 <ezyang> Oh dude, GHC defines Unicode syntax.
18:28:39 <aavogt> HaskellLove: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-wildcards
18:28:40 <ezyang> So cool.
18:30:55 <HaskellLove> f (C {a = 1, ..}) = b + c + d - aavogt so it just does the same thing for the rest as for a? it binds b and c to 1?
18:31:28 <aavogt> I have no idea what you defined as the fields of C
18:31:51 <copumpkin> HaskellLove: that pattern will only match if a is 1, and then it will add up the other fields, which may not be 1
18:32:28 <dibblego> cabal install curl fails with "See `config.log'" -- where can I find that file?
18:32:43 <HaskellLove> aavogt data C = C {a :: Int, b :: Int, c :: Int, d :: Int}
18:32:45 <HaskellLove> f (C {a = 1, b = b, c = c, d = d}) = b + c + d
18:33:12 <aavogt> what copumpkin said it right
18:33:13 <Berengal> ezyang: Top of page 4, when you say that a NTM is strictly more powerful than a DTM, you might want to qualify that. A DTM can do anything a NTM can, but might take more time getting there
18:33:32 <ezyang> Oh, that's true.
18:34:18 <aavogt> Berengal: those acronyms sound sort of like the modulations used for telephone dialing....
18:34:43 <Berengal> aavogt: They are. What did you think they were? Turing machines?
18:34:50 <Twey> Heh
18:35:18 <aavogt> yeah, something less applied
18:35:24 <Berengal> ;)
18:35:56 * hackagebot upload: maid 2009.12.20 - A simple static web server (JinjingWang)
18:38:30 <BMeph> ezyang: A "mobile" is like a (binary) tree, whose arms can swap sides, like the play toy.
18:39:01 <ezyang> Curious image.
18:47:34 <Gracenotes> BMeph: they are ordered, though.. I take it.
18:50:55 <BMeph> Gracenotes: The sub-mobiles in relation to each other, no.
18:51:35 <alp_> @type interleave
18:51:36 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
18:52:03 <Gracenotes> I mean, there is an ordered pair representing a node's links, not just a set with two elements
18:52:09 * ezyang is kind of surprised the Prompt monad works at all 
18:53:29 <eugenn> > 0 ^ 0
18:53:30 <lambdabot>   1
18:53:41 <BMeph> They're commutative, but not associative. So, a set seems like a fair way to think of them. Or rather a multiset, since both arms could be identical.
18:54:38 <ezyang> multisets are funny bags
18:55:49 <dolio> They're not just ordinary bags?
18:57:11 <alp_> @instances MonadLogic
18:57:12 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
18:57:20 <ezyang> Also, literate Haskell is so beautiful!
18:57:26 <ezyang> alp_: That seems poor.
18:57:34 <alp_> yup
19:03:20 <jackdaw> how do i get more info on a "non exhaustive patterns" exception
19:03:58 <mauke> like what?
19:04:10 <Axman6> jackdaw: it means you haven't match all possible cases in a pattern match, and one of the cases you didn't match occured and couldn't be matched
19:04:33 <jackdaw> i was wondering if i could get the exception to tell me what patterns it figured couldn't be matched, but i figured it out myself
19:04:39 <jackdaw> (noob)
19:04:56 <Axman6> so, you might have a function which has something like f (x:y:xs) = ...; f [] = ..., and that would never match [x]
19:05:07 <Axman6> jackdaw: compile with -Wall
19:05:20 <jackdaw> Axman6: great thanks
19:07:07 <ezyang> does anyone know what the relation is between the prompt monad and frp?
19:07:18 <dons> hmm...
19:07:28 <dons> i suspect no one knows.
19:07:34 <ezyang> :-)
19:07:40 * Twey certainly doesn't
19:08:09 <ezyang> I mean, I'm trying to decide of the prompt monad is a simple but dead end design path for interactivity, or if you develop it further it becomes frp
19:09:25 <jackdaw> is prelude on hoogle working for other people? i get a 404
19:09:35 <monochrom> No.
19:09:48 <dons> oh, the links might be brokenn due to the new release?
19:09:59 <monochrom> base-4.2.0.0 instead of base
19:10:13 <copumpkin> jackdaw: all the links from google are broken
19:10:15 <jackdaw> thanks monochrom, that works fine
19:10:20 <dons> sigh. Igloo ^^
19:10:31 <ezyang> Links hve been broken for a while.
19:11:07 <monochrom> I hope it takes finite time to guess version numbers in general. XD
19:12:18 <HaskellLove> In Haskell inexhaustive match is caught at compile time by the typechecker right?
19:12:34 <Axman6> no
19:12:37 <ezyang> I think you need to use the profiler
19:12:45 <Axman6> you need to use -Wall
19:13:10 <Berengal> HaskellLove: Haskell isn't total. Partial functions are allowed
19:13:15 <jimi_hendrix> what would be a good excercise for me in learning haskell that isnt a giant math problem (project euler)
19:13:18 <aavogt> > case [] of [x] -> "this is a runtime error"
19:13:19 <lambdabot>   "* Exception: <interactive>:1:133-175: Non-exhaustive patterns in case
19:13:59 <dmwit> jimi_hendrix: Write yourself a Scheme in 48 hours.
19:14:09 <dmwit> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
19:15:00 <monochrom> A giant interpreter problem.
19:15:21 * Axman6 argues that's also a large maths problem!
19:15:33 <jimi_hendrix> dmwit, ok, will look (i am interested in interpreters), but anything else while i am here
19:15:50 <HaskellLove> aavogt aha yes I remember now, when I was defining functions and i left out the 0 case it compiled fine, but when used at run time yes yes... run time error, got it. Same is in SML... Any opinions if should it be a compile time problem or it is not possible?
19:15:51 <monochrom> Any Haskell book suggests projects.
19:15:53 <Berengal> jimi_hendrix: IRC bot
19:16:31 <Berengal> HaskellLove: Languages like Agda and Coq enforce totality, and -Wall at least gives warnings when you leave out patterns
19:16:40 <jimi_hendrix> Berengal, Haskell sockets are easy?
19:16:45 <jackdaw> i tried that write yourself a scheme, fun
19:16:51 <monochrom> Easier than C.
19:17:03 <Berengal> jimi_hendrix: They're not terribly hard, at least. Just point and shoot, mostly.
19:17:28 <monochrom> socket is the easiest part in irc. the irc protocol itself is subtle.
19:17:31 <jackdaw> the icfp things are fun
19:18:01 <\yrlnry> Is is possible that a particular implementation of >>= for lists might satisfy the monad laws for all finite lists, but fail for infinite lists?
19:18:09 <jimi_hendrix> Berengal, ok, i am familiar with making irc bots in other languages
19:18:25 <jimi_hendrix> monochrom, hehe...but once the parser is done its easy
19:18:33 <monochrom> "server will spontaneously send pings to client. if client doesn't pong back in time, bye" this makes your program structure interesting.
19:18:50 <HaskellLove> Berengal how to use -Wall? like this: ghc --make -O2 -Wall "/home/user/Desktop/a.hs"
19:18:52 <Twey> Just keep it asynchronous
19:19:00 <Twey> Best way to do it anyway
19:19:04 <Berengal> HaskellLove: Yes, it's just another compiler flag
19:19:10 <monochrom> Yes of course.
19:19:38 <Berengal> Some tasks are best done asynchronously, even if they're entirely sequential
19:20:03 <monochrom> Most beginners haven't thought of it.
19:20:31 <Berengal> Most beginners are afraid of threads too
19:20:37 <jackdaw> should i use parsec if'
19:20:43 <Twey> Erlang hath its benefits.  ;)
19:21:02 <jackdaw> im just parsing some varying number of doubles or nothing
19:21:13 <Twey> Personally, I'm of the opinion that asynchronicity is always the ideal approach to IO
19:21:22 <Twey> The difficulty is in implementation
19:21:51 <jimi_hendrix> so, is there a shiney tutorial for async in Haskell, or am i going to spend a night cuddling up with the docs
19:22:23 <ezyang> jimi_hendrix: What kind of async?
19:22:30 <Twey> jimi_hendrix: Hehe.  It's pretty simple, really — you just need to know how to use Chans and you're fine.
19:22:35 <Berengal> jimi_hendrix: I don't have a tutorial ready to go, but take a look at STM
19:22:37 <Twey> FRP, now…
19:22:49 <Twey> FRP is nicer, but more complicated.
19:23:01 <Twey> Red pill or blue pill?  ☺
19:23:11 <BMeph> I thought Chans blocked?
19:23:15 <monochrom> Take the blue pill to enlarge your...
19:23:27 <Twey> BMeph: Okay, you also need to know how to use ‘forkIO’ :þ
19:23:50 <copumpkin> monochrom: is that what you did?
19:24:11 <monochrom> No, it's what I saw in spams.
19:24:17 <jimi_hendrix> ok
19:24:35 <jimi_hendrix> monochrom, then what does the red one do...
19:26:14 <ezyang> I've actually been putting off learning about STM and Chans for a while now
19:26:17 <medfly> haha, I'm talking to this guy, and mentioning I like Haskell, and he goes "students here complain that we teach it in the first semester"... woo!
19:26:26 <ezyang> What's a good introductory text for learning about them?
19:26:43 <monochrom> The spams didn't say.
19:27:45 <Twey> Hehe.
19:27:53 <Twey> ezyang: I learnt from the Wikibook page.
19:28:01 <Twey> Oh, wait.
19:28:12 <Twey> You're not jimi_hendrix.  What are you asking about?  :þ
19:28:18 <ezyang> Twey: http://en.wikibooks.org/wiki/Haskell/Concurrency
19:28:23 <Twey> That's the one
19:28:27 <BMeph> Twey: Sorry, am I being a '' in your side? ;)
19:28:28 <ezyang> I'm jumping on the Jimi Hendrix train
19:28:38 <monochrom> I just read the docs to learn forkIO and MVar and Chan.
19:28:49 <Twey> BMeph: Ho, ho, ho :þ
19:28:53 * copumpkin facepalms in BMeph's direction
19:28:54 <jimi_hendrix> Twey, i am confused too
19:28:56 <Twey> (wrong encoding, though!)
19:29:02 <Twey> ezyang: Aha :þ
19:29:04 <ezyang> The only concurrency I've been exposed to in Haskell was the Boston Haskell Meetup CnC talk (which I missed the first half of) and the STM paper in Beautiful Code.
19:29:08 <monochrom> Of course I took a standard OS course previously so I know what it's talking about.
19:29:51 <monochrom> Perhaps the problem with some people is they use Haskell tutorials to replace a comprehensive CS education.
19:30:18 <Axman6> ezyang: check the wikipedia page for haskell to see how to use STM, i've written a fairly extensive introduction there
19:31:14 <ivanm> hey Axman6
19:31:19 <Axman6> o/
19:31:41 <ivanm> I may be coming down for a flying visit in the next couple of days to sign the contract for the apartment
19:31:51 <Axman6> cool
19:33:01 <ezyang> wha, the ST monad sounds scary.
19:33:12 <ivanm> @src ST
19:33:12 <lambdabot> newtype ST s a = ST (STRep s a)
19:33:20 <ivanm> what's STRep?
19:33:22 <ivanm> @src STRep
19:33:22 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
19:33:31 <ivanm> oh, ST is unboxed State ?
19:33:32 <ezyang> "strep throat"
19:33:38 <ezyang> Oh, is that all it is?
19:33:38 <Twey> Heh
19:33:41 <ezyang> "that's not so bad"
19:33:46 * Twey chuckles.
19:33:53 <Twey> ST isn't that scary.
19:34:03 <ivanm> ezyang: heh, I'm not saying I get it.... I'm trying to understand what it is and how it differs from State
19:34:08 <ivanm> @src State#
19:34:08 <lambdabot> Source not found. :(
19:34:15 <ivanm> @hoogle State#
19:34:15 <lambdabot> No results found
19:34:21 <mauke> ivanm: it's nothing like State
19:34:25 <Twey> ivanm: Rather than just threading a value through a series of computations, it lets you do actual in-place updates
19:34:27 <mauke> ST is a restricted version of IO
19:34:29 <Twey> Yeah
19:34:31 <ezyang> "use ST to allocate mutable memory, then you initialize and play with it, then you put it away and return a normal Haskell value"
19:34:34 <ivanm> ahhh
19:34:34 <ezyang> That's SCARY!
19:34:38 <Twey> Hehe
19:34:48 <mauke> basically, ST gives you STRefs
19:34:52 <ivanm> OK, so what's State# ?
19:34:53 <mauke> that's the main point
19:34:59 <mauke> an implementation detail
19:35:26 <ivanm> *nod*
19:35:39 <ivanm> so ST is IO restricted to memory management?
19:35:50 <mauke> STRefs
19:36:03 <jimi_hendrix> this STM looks painful
19:36:06 <ivanm> and what are STRefs?
19:36:12 <ivanm> jimi_hendrix: nah, STM is quite nice
19:36:14 <mauke> mutable variables, like IORefs
19:36:17 <ezyang> jimi_hendrix: STM is amazing
19:36:19 <ivanm> see SPJ's santa clause example
19:36:21 <ezyang> It's like... composable locks
19:36:29 <jimi_hendrix> ok
19:36:34 <ezyang> If you've ever had to write locking code, it's pretty painful
19:36:38 <ezyang> and totally breaks modularity.
19:36:41 <ezyang> STM brings it back.
19:36:44 <copumpkin> ivanm: IORefs in ST?
19:36:46 <jimi_hendrix> touch
19:37:02 <Twey> STRefs in ST
19:37:13 <Twey> But *like* IORefs.  ☺
19:37:15 * ivanm hasn't really used IORefs much either...
19:37:17 <copumpkin> ivanm: yes, ST is IO restricted to mutable datastructures, without letting the mutability escape
19:37:27 <ivanm> *nod*
19:38:52 <copumpkin> ivanm: it does that by making sure all your operations within ST operate on a universally quantified "state thread" type, so you can't rely on that type being anything specific (and haskell doesn't allow the universally quantified variable to escape, so anything you do inside can't be returned)
19:39:08 <ivanm> *nod*
19:40:23 <Axman6> jimi_hendrix: what are you looking at that's making you feel that STM is painful?
19:40:53 <jimi_hendrix> Axman6, on further review, it does not look that bad
19:40:57 <jimi_hendrix> http://en.wikibooks.org/wiki/Haskell/Concurrency
19:41:31 <Axman6> jimi_hendrix: take a look at http://en.wikipedia.org/wiki/Haskell_(programming_language)#STM_monad
19:41:57 <jimi_hendrix> ok
19:51:04 <HaskellLove> Hmm the more I read on SML it seams it is lot more powerfull then Haskell, I mean, the power of high order functions sharing mutable state, wow, mind blowing oportunities... With reference cells you can mimic C programming... I am not there yet but, does Haskell compensates enough with monads, for its purity? Can it match SML in this sense?
19:51:33 <copumpkin> in that sense, c is more powerful than either, with unrestricted power
19:51:47 <copumpkin> the point is you want to restrict behavior or things might do bad things behind your back
19:51:52 <copumpkin> and make reasoning impossible
19:51:54 <ezyang> in that sense, asm is more powerful than c
19:52:35 <Berengal> HaskellLove: IO actions are first-class in haskell as well. The only difference is we tag them as such
19:52:45 <HaskellLove> I will know when I get to work with monads, but it probably can do similar stuff as SML, with monads
19:52:45 <copumpkin> HaskellLove: we can do everything SML can do with mutability in haskell, as long as you declare in your type that you're going to be mutating things
19:53:22 <Berengal> HaskellLove: I frequently send processes a way to read or write to a channel, but not the channel itself, to guarantee I don't mess up.
19:54:29 <HaskellLove> Berengal sorry, processes to channels? what are you exactly talking about, sorry?
19:54:47 <ezyang> HaskellLove: Singularity OS might be interesting reading for you
19:54:58 <Berengal> HaskellLove: multithreading, using channels for communication
19:54:59 <ezyang> Not Haskell, but it manages to explicate the same ideas fairly well.
19:56:06 <HaskellLove> Berengal oh, concurrent programming, I am not there yet :)
19:57:11 <HaskellLove> ezyang should I search for papers on Singularity a book or whatever? I will google, but if you want to point me to some specific stuff, please...
19:57:20 <ezyang> let me dig up a link
19:57:36 <ezyang> http://pdos.csail.mit.edu/6.828/2009/readings/hunt07singularity.pdf
19:58:29 * ezyang had to read it for his operating systems engineering class 
20:00:58 <HaskellLove> ezyang you worked with Tanenbaum book for OS class?
20:01:16 <ezyang> Doesn't ring a bell.
20:02:08 <EvanR> the racoon book
20:03:02 <Axman6> HaskellLove: i think i've got that one
20:14:03 <copumpkin> @remember PaulWHomer The diagonal argument works perfectly fine with a sequence. It is invalid, however, when used on a magic sequence.
20:14:03 <lambdabot> Done.
20:14:29 <copumpkin> @forget PaulWHomer The diagonal argument works perfectly fine with a sequence. It is invalid, however, when used on a magic sequence.
20:14:30 <lambdabot> Done.
20:15:11 <copumpkin> @remember PaulWHomer [Regarding Cantor's diagonalization] The diagonal argument works perfectly fine with a sequence. It is invalid, however, when used on a magic sequence.
20:15:11 <lambdabot> Done.
20:17:14 <Axman6> wait, wtf? i have no Control.Concurrent.STM in my 6.12.1 :O
20:17:26 <copumpkin> yeah you do
20:17:41 <Axman6> hmm, there's a flag isn't there
20:17:54 <kmc> HaskellLove, SML and Haskell have much the same capabilities in terms of mutable state and reference cells.  the difference is that, in SML, calling a function can update a reference cell.  in Haskell, only a monad action can update a reference cell.  Calling a function can give you a monad action, but will not actually perform the effect
20:17:59 <monochrom> stm is not with ghc 6.12
20:18:07 <copumpkin> http://hackage.haskell.org/package/stm
20:18:09 <monochrom> stm, network, mtl are not.
20:18:26 <ivanm> monochrom: they weren't for 6.10 either
20:18:54 <kmc> HaskellLove, so basically, they can do the same things.  But Haskell requires a little more discipline in terms of how you *describe* what you want to do
20:19:00 <Axman6> wtf?
20:19:17 <kmc> What you get in exchange is the ability to think about what your code does more easily
20:19:19 <Axman6> i just did a cabal install --reinstall stm, and i still can't :m +Control.Concurrent.STM
20:19:37 <monochrom> ivanm: I invite you to compare http://www.haskell.org/ghc/docs/6.10.4/html/libraries/index.html with http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:19:58 <Axman6> so, how am i supposed to use STM?
20:20:11 <ivanm> monochrom: extralibs /= ghc
20:20:21 <ivanm> Axman6: weird...
20:20:28 <ivanm> you using the new 0.8 version of cabal-install
20:20:37 <Axman6> yes
20:21:14 <monochrom> ivanm: http://www.haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-unknown-linux-n.tar.bz2 has mtl, stm, network
20:22:07 <Axman6> monochrom: any chance you could stop trying to be right, and give me some help? :P
20:25:26 <monochrom> And I suppose you be the judge of what constitutes as "help" and what as "you're not helping".
20:26:09 <Axman6> well, i didn't see that arguing with ivanm was helping me at all
20:26:19 <ivanm> heh
20:26:30 * Twey chuckles.
20:26:37 <ivanm> monochrom: just because the generic binary used to be bundled with extralibs included doesn't make it part of GHC IMHO
20:26:45 <ivanm> Axman6: hush you ;-)
20:27:01 <Axman6> so, no one has any idea why i can't use STM i take it
20:27:55 <ivanm> nope
20:28:10 <Axman6> well this probably has something to do with it: There are problems in package stm-2.1.1.2: dependency "base-4.2.0.0-95c41f6bf22ec723b98f35a571e408fc" doesn't exist
20:28:18 <ivanm> Axman6: I take it that "ghc-pkg list" doesn't show stm?
20:28:27 * ivanm wonders if this is a OSX problem... >_>
20:28:29 <Axman6> and i get that for a whole lot of packages in ghc-pkg check
20:29:38 <ivanm> yup
20:29:42 <Axman6> wtf
20:29:46 <ivanm> your install appears to be hosed
20:29:50 <Axman6> why are there so many packages broken
20:29:51 <ivanm> Axman6: "ghc-pkg check" ?
20:29:54 <Axman6> yes
20:30:02 <ivanm> Axman6: you didn't try to upgrade base or something, did you?
20:30:03 <Axman6> ghc-pkg list told me to do it
20:30:07 <Axman6> no
20:30:15 <ivanm> *shrug* try re-installing?
20:30:17 <ivanm> or ask on #ghc
20:30:22 <Axman6> i did
20:30:27 <HaskellLove> kmc here is the perspective i look from: Ok, SML has reference cells and Haskell has monads. If I were to design a general purpose multiparadigm language, what to choose for my functional part? SML is older, but why did not Haskell use the same example and use reference cells, it can be pure without using them so...  Or maybe for this I will have too look at Scala because it is multi...
20:30:29 <HaskellLove> ...paradigm and see how this issue is handled there to work with oop capabilities? give me some opinions...
20:31:15 <kmc> you have started off on the wrong food
20:31:17 <kmc> foot*
20:31:19 <kmc> food tool
20:31:21 <kmc> ack
20:31:27 <kmc> let *me* start over
20:31:42 <kmc> you say that "SML has reference cells and Haskell has monads"
20:31:48 <kmc> this is not a 1:1 comparison
20:31:48 <HaskellLove> yep
20:32:00 <kmc> it is more correct to say "SML has reference cells and Haskell has reference cells"
20:32:15 <kmc> "SML references are manipulated by functions; Haskell references are manipulated by monad actions"
20:32:29 <ivanm> Axman6: this is on SL or something (that everyone else has been bitching about)?
20:32:43 <kmc> i explained this above, it's important that you understand it before we go further
20:32:55 <Axman6> yes, the SL problems were fixed in 6.12.1
20:33:23 <HaskellLove> kmc well yeah down there at low level it is all references i get that
20:33:35 <Axman6> no, even at the high level
20:33:37 <kmc> HaskellLove, no.  not at the low level
20:33:49 <kmc> the ML type "'a ref" is exactly like the Haskell type "IORef a"
20:34:17 <kmc> there is no sense in which ML has references and Haskell lacks them
20:34:26 <HaskellLove> I see
20:34:57 <kmc> there are actually 4 or 5 different reference-cell types in the libs that come with Haskell Platform
20:35:15 <Axman6> so, whoever said that SML was more powerful because it has mutable state obviously doesn't know shit about haskell
20:35:29 <HaskellLove> kmc ok it is enough for me to know that... for now... will keep reading thanks
20:37:01 <kmc> HaskellLove, if you want to make an educated comparison of Haskell and SML you will sooner or later have to write a lot of code in each
20:37:02 <dons> :t writeIORef
20:37:03 <lambdabot> Not in scope: `writeIORef'
20:37:09 <dons> :t Data.IORef.writeIORef
20:37:10 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
20:37:14 <dons> HaskellLove: time to write some code!!
20:37:17 <HaskellLove> Axman6 so if you were to design your own language, as best example, you would take Haskell right? All this language studies bla bla is about that, I learn languages i compare, i see what i like for mine, i ask is this same as that and why would you have that in your languge rather then this and so on
20:37:20 <dons> too much irc, not enough code.
20:37:27 <ivanm> heh
20:37:38 <ivanm> @remember dons too much irc, not enough code.
20:37:38 <lambdabot> Okay.
20:37:54 <dons> HaskellLove: seriously, your irc questions quota is going to expire unless you write some haskell code.
20:38:04 <dons> you owe us a package.
20:38:05 * Axman6 agrees
20:38:18 <HaskellLove> dons well i did 20 eulers in haskell, but i pause now to read on other functional languages to compare and see where is haskell... i read on c# and f# and now i will finish a book on ml, but just reading those, will get back at haskell coding in a day or two
20:38:34 <dons> 20 eulers is good.
20:38:41 <Axman6> you're a terrible comp sci student
20:38:47 <dons> prob. should build an app now though.
20:38:53 <Axman6> sorry, but you can't have learnt much at all in that time
20:39:11 <dons> yeah, you need to write lots of code to be good at this. its like learning the piano. practice! daily!
20:39:18 <dons> reading doesn't cut it.
20:39:25 <Axman6> you can't spend a week with a language and decide you know it
20:39:35 <ivanm> damn storms...
20:39:40 <HaskellLove> Axman6 well you can actually get a general overview it is not that hard... i am not able to go now and code f# anc c# but i saw what they do and in what relation they stand to haskell and how they handle stuff
20:39:42 * ivanm heads offline until its over
20:39:45 <Axman6> i've been using haskell for neigh on 2 years now, and i sure don't know it well at all
20:39:48 <kmc> HaskellLove, i said this before, but 20 Project Euler problems (I refuse to call them "Eulers", it sounds like you're screwing clones of our friend Leonhard) barely scratches the surface of Haskell
20:40:11 <kmc> Project Euler only exercises a small part of the language
20:40:15 <Axman6> HaskellLove: no, you don't
20:40:35 <kmc> you will not learn Haskell by completing every Euler problem and then declaring victory
20:40:37 <kmc> much less 20 of them
20:40:45 <dons> perhaps write a bittorrent client like jlouis is?
20:40:45 <Axman6> god damnit, wtf is my ghc 6.12.1 installed so boned! :'(
20:40:47 <HaskellLove> Axman6 yes but theory is also important, otherwise you just learn syntax
20:41:01 <Axman6> you learn the theory through using it
20:41:02 <copumpkin> no you don't
20:41:07 <jmcarthur> you don't just learn syntax if you are actually using it
20:41:11 <dons> HaskellLove: at the moment you have an atypically high ratio of reading/questions to code, based on my experience teaching haskell.
20:41:21 <monochrom> You are not doing theory. You are doing opinions.
20:41:25 <kmc> HaskellLove, if you want only an overview of different languages, that's fine.  but when you come here and say false things comparing SML and Haskell, and people tell you to learn more Haskell, you should probably pay attention
20:41:41 <kmc> because it means the level of comparison you want to make is outpacing your knowledge of the things being compared
20:41:57 <monochrom> If you haven't calculated a fixed point or proved a type system consistent lately, you are not doing theory.
20:42:38 <dons> :)
20:43:01 <dons> that's about right. maybe shown some termination properties in isabelle or something.
20:43:05 <HaskellLove> kmc I asked I did not say Haskell is better SML, i said this guy handles stuff this way and Haskell that way... give me some opinions how does haskell do that, and so on...
20:43:16 <dons> HaskellLove: time to go hack!
20:43:16 <kmc> HaskellLove, i did not say you said Haskell is better [than] SML
20:43:22 <HaskellLove> dons yep
20:43:32 <kmc> HaskellLove, my complaint is not the direction of your opinion, but rather the fact that it's founded on simply false statements
20:44:01 <copumpkin> [In #python] "I hear that ruby is so much better than python. Is this correct?"
20:44:05 <copumpkin> there's a name for that
20:44:19 <HaskellLove> kmc I just asked how does Haskell handle the stuff that SML does with references :) anyways i go back to reading monochrom yes you are right i hope to start doing that soon
20:45:44 <dons> start now!
20:45:52 <dons> don't talk. hack!
20:46:18 <HaskellLove> dons yes sir :)
20:46:38 <dons> drop and give me 50 lines.
20:47:36 <Axman6> anyone know how to get all my locally registered packages unregistered and uninstalled?
20:47:57 <monochrom> loop over ghc-pkg unregister...
20:48:22 <monochrom> to uninstall, first unregister, then go ahead and delete directories and files manually
20:48:44 <dons> Axman6: remove the local package.conf
20:48:54 <Axman6> sounds like an easier idea
20:48:58 <monochrom> Oh haha that's more efficient!
20:49:00 <Axman6> that's in ~/.ghc right?
20:49:11 <dons> yeah
20:49:27 <Axman6> excellent
20:49:34 <Axman6> now let's see if everything's still boned...
20:49:41 * dons came upon this trick trying to unregister 700 packages.
20:49:42 <copumpkin> boned :o
20:49:53 <Axman6> hooray, i have STM!
20:50:13 <Axman6> dons: when you're down here, i now owe you two beers :)
20:50:59 <Axman6> you can even have the really nice, expensive wig and pen one with strawberries and other berries in it.
20:52:22 <monochrom> So, local packages interefered with global packages?
20:52:53 <Axman6> something like that. now i need to try installing something with cabal-install, and see where the problem was
20:54:34 <monochrom> Is there a cyclic dependency between cabal-install and those packages that cabal-install needs?
20:55:06 <Axman6> anyone know why so many things rely on array 0.2.0.0?
20:57:19 <monochrom> I bet most usages of array are usages of the mutable ones actually.
20:58:17 <Axman6> urgh
20:58:21 <deh> Hello; I'm reading GHC source to learn how things are implemented "for real".  I've figured out that I# must be a boxing operator, but where should I be looking for its definition?
20:58:45 <Axman6> cabal-install can't even install itself atm, because something wants unix, but an older one that is installed
20:59:09 <copumpkin> deh: it's not a boxing operator
20:59:21 <copumpkin> deh: it's just a data constructor for a data type
21:00:00 <monochrom> Maybe in GHC.Prim
21:00:33 <copumpkin> it's just data Int = I# Int#
21:00:48 <copumpkin> no different from data Sum a = Sum a
21:01:07 <copumpkin> GHC.Types IIRC
21:01:17 <Axman6> oh duh, need to tell it to use cabal-install >= 0.8 >_<
21:01:19 <Axman6> idiot
21:01:27 <lpsmith> monochrom:  don't think so,  although I built cabal-install for one of the prerelease ghc-6.12,  there are a lot of packages to track down
21:02:36 <Axman6> ok, all good!
21:03:16 <deh> Ah!  libraries/ghc-prim/GHC/Types.hs.  Also C#, F#, D#.
21:03:31 <Axman6> for Char, Float and Double
21:03:43 <lament> i was wondering what D# was
21:03:43 <copumpkin> omg F# in haskell!
21:04:14 <Axman6> can't remember what the two constructors for Integer are. S# is one of them i think
21:04:17 <Axman6> @src Integer
21:04:17 <lambdabot> data Integer = S# Int#
21:04:17 <lambdabot>              | J# Int# ByteArray#
21:04:29 <Axman6> Small and Jumbo >_>
21:04:41 <copumpkin> lol
21:05:10 * Axman6 doesn't have a clue where J comes from
21:05:15 <lpsmith> so why is Integer somewhat slower and more malloc-ful than Int,  even if your Ints are small and not jumbo?
21:05:42 <Axman6> lpsmith: probably how gmp is implemented
21:06:13 <copumpkin> lpsmith: it's slower even with small integers because it needs to check size with every operation
21:06:34 <Axman6> yeah, there's an extra pattern match for all operations
21:06:37 <copumpkin> lpsmith: also, I guess it's hard/impossible to unbox such a representation, given it has two constructors
21:06:58 <Axman6> and i'd guess that gmp has functions for adding an Int to a gmp integer, as well as gmp integer to gmp integer
21:11:18 <Axman6> hmm, what's a package that has lots of dependances?
21:11:39 <monochrom> "a promiscuous package"
21:12:09 <monochrom> Try HXT
21:14:11 <monochrom> logic-TPTP depends on 9 packages. some depends on some other further.
21:14:47 <holmak> happstack has quite a few, as i recall
21:14:49 <monochrom> I try to pick packages that solve real-world problems.
21:15:10 <Axman6> holmak: yeah, tried it, some of its dependancies are broken with 6.12
21:15:22 <holmak> ah, too bad
21:15:49 <Axman6> HJScript is one, seems there was some GADT changes
21:16:35 <monochrom> Many packages depend on containers (just for Data.Map and Data.Set perhaps?), containers depend on array (just because of hash table?). This is why everyone depends on array.
21:16:51 <copumpkin> let's kill hashtable
21:16:54 <copumpkin> with fire
21:17:03 <monochrom> No, just use the delete key.
21:18:19 <monochrom> Haha. polyparse says "base(<=6)". Is this like "will expire in 2012"?
21:18:28 <EvanR> i have come to think harder about errors and exceptional conditions since doing haskell... it seems there are lots of parts of the code which just cant fail. but now im thinking about 'out of memory'
21:18:40 <EvanR> can 'out of memory' occur in functional code?
21:18:46 <monochrom> Yes.
21:18:48 <dmwit> Yes, of course.
21:18:48 <Axman6> sure
21:18:54 <EvanR> right. whats happens then
21:18:58 <monochrom> The first one you'll hit is "stack overflow"
21:18:58 <Axman6> boom
21:19:00 <dmwit> It dies.
21:19:10 * dmwit has run out of memory without a stack overflow
21:19:13 <EvanR> is there no way to recover
21:19:22 <j4cbo> this sounds like it's time for my turing machine rant.
21:19:32 <Axman6> EvanR: laziness often helps. it can often be slower, but uses a hell of a lot less RAM in many cases
21:19:36 <dmwit> EvanR: Hm.  Is there a way to recover in other languages?
21:19:42 <pikhq> EvanR: Computers are finite state automatons.
21:19:50 <j4cbo> pikhq: you beat me to it. :D
21:20:01 <pikhq> Most *programming languages* describe Turing machines.
21:20:03 <copumpkin> LBA
21:20:12 <EvanR> yes. i know that things are a lot nicer if you pretend we are in ideal computer land
21:20:23 <Axman6> monochrom: well, HXT installed fine
21:20:28 <monochrom> Neato
21:20:31 <pikhq> Because of this, it is impossible to actually implement the programming language correctly.
21:20:40 <EvanR> currently modelling a language for a mud, and ive listed only six operations which could possibly fail
21:20:48 <j4cbo> pikhq: it's not entirely clear to me whether or not the C machine spec is for a turing machine or an FSM
21:20:50 <EvanR> except for the memory thing
21:20:51 <pikhq> This pretty much only surfaces in memory allocation.
21:21:06 <elly> by the way, you guys should check out Jetblue's website - they have a great package deal for a week-long vacation in Ideal Computer Land with bookings for the Fixed-Point Hotel, all for like $550
21:21:07 <monochrom> Oh haha HXT does depend on 12 packages!
21:21:07 <j4cbo> pikhq: if you make the assumption that pointers are of finite size...
21:21:16 <pikhq> j4cbo: FSM, unless you consider file I/O.
21:21:26 <pikhq> And pointers are required to have a finite size in C.
21:21:28 <EvanR> in C you have at least the possibility of doing something when the OS is out of memory
21:21:41 <j4cbo> pikhq: they are required to have a sizeof()
21:21:49 <mle> in an ideal computer hotel you can check out any time you like, but you can never LEAVE
21:22:08 <j4cbo> pikhq: but if you make the assumption that sizeof(char) is actually large enough to hold any natural number, i don't think you reach a contradiction.
21:22:20 <elly> mle: you can't even check out, because inside your room is a complementary gamma function
21:22:49 <j4cbo> pikhq: i've spent a bit of time thinking about this, but never convinced myself either way
21:23:11 <dmwit> EvanR: Does anybody use it for anything smarter than "die"?
21:23:20 <j4cbo> dmwit: yes
21:23:23 <elly> dmwit: 'save state to disk and then die'
21:23:26 <monochrom> oh no an ideal computer hotel is like a monad then!
21:23:27 <j4cbo> dmwit: if you're writing a kernel, for instance :)
21:23:29 <EvanR> i dont, but conceivably you can do an emergency dump of some program state
21:23:39 <pikhq> j4cbo: Hmm. The only way for a TC C is for the char to hold any natural...
21:23:49 <elly> monochrom: in ideal computer land, all hotels are monads
21:23:53 <mle> elly: if you can save state to disk and die, then you can gc by execing.
21:24:02 <dmwit> j4cbo: If you're writing a kernel, you're not using the same interface as userland folks anyway.
21:24:07 <elly> "What happens in the Fixed-point Hotel *stays* in the Fixed-point hotel... until you return."
21:24:12 <dmwit> j4cbo: That would be equally true in a Haskell kernel.
21:24:26 <pikhq> So, does the language require the range of values of char to be finite?
21:24:28 <copumpkin> @quote magic
21:24:28 <lambdabot> dons says: ah, via the magic of SCIENCE
21:24:31 <copumpkin> @quote magic
21:24:31 <lambdabot> Axman6 says: foldr chosen for its magical evil terminating powers
21:24:46 <EvanR> well now
21:24:55 <j4cbo> dmwit: true, but you are probably using something called malloc()
21:24:57 <Axman6> EVIL!
21:25:06 <lpsmith> hahaha
21:25:09 <j4cbo> not necessarily, but it is convenent to do so
21:25:11 <EvanR> i guess the answer is that haskell has no facilities for recovering or emergency dumping on 'out of memory'
21:25:25 <copumpkin> it does
21:25:30 <copumpkin> if you're in IO
21:25:35 <EvanR> ah
21:25:37 <copumpkin> only makes sense
21:25:44 <lpsmith> when I was starting to learn Haskell and SML,  I had a strong preference for foldl over foldr
21:25:53 <ColonelJ> foldl' please
21:25:53 <lpsmith> But I've moved rightward :-)
21:26:16 <EvanR> copumpkin: but if you run out of memory in a non IO function, youre screwed?
21:26:23 <kmc> can you catch an out of memory error in IO?
21:26:24 <copumpkin> nope
21:26:26 <lpsmith> ColonelJ:  sure :-)
21:26:26 <dmwit> "Notes: GHC currently does not throw HeapOverflow exceptions."
21:26:31 <dmwit> copumpkin: I think you might be wrong. =)
21:26:33 <copumpkin> oh, guess not
21:26:40 <copumpkin> ah well, it probably could
21:26:47 <EvanR> well now!
21:26:54 <copumpkin> if it restricted the heap to a little less than what it actually has
21:26:57 <copumpkin> to give you some memory to recover
21:27:06 <pikhq> Presumably you could unsafePerformIO deleteTheHeap? :P
21:27:34 <EvanR> i guess i could ignore the problem
21:27:40 <EvanR> pretend its ideal computer lang
21:27:41 <EvanR> d
21:27:49 <j4cbo> that's the usual approach
21:27:55 <pikhq> That's the general approach.
21:27:57 <j4cbo> taken by most user applications
21:27:59 <EvanR> \o/
21:28:08 <pikhq> I'd like to note that on Linux, there is no way to recover whatsoever.
21:28:14 <j4cbo> and kernels try to "help" approximate it, with things like swap
21:28:18 <elly> turn off overcommit!
21:28:19 <pikhq> Since Linux malloc never, ever, ever returns NULL.
21:28:32 <ColonelJ> what elly said
21:28:34 <mle> does tcmalloc?
21:28:43 <elly> it can't, because the kernel lies to it
21:28:57 <elly> the linux kernel will promise you RAM that doesn't exist - this behavior is known as overcommitting
21:28:57 <monochrom> evil
21:29:02 <pikhq> The kernel is a lying bastard when it comes to memory allocation.
21:29:07 <mle> yes yes, but what if overcommit is off?
21:29:14 <elly> then either of them can return NULL
21:29:19 <pikhq> Then it functions correctly.
21:29:35 <pikhq> Otherwise, malloc(SIZE_T_MAX) is almost guaranteed to succeed.
21:29:45 <pikhq> (failure will result in your program being killed)
21:29:57 <mle> but that's kill on use of the pages
21:30:00 <mle> not on allocation.
21:30:17 <elly> yes
21:30:31 <mle> nothing wrong with that.  It's just being lazy.
21:30:34 * pikhq nods
21:30:39 <elly> er, there *is* something wrong with that
21:30:42 <kmc> you can disable overcommit
21:30:48 <elly> your program can die randomly after the kernel promised you there was memory there
21:31:03 <pikhq> mle: ... Except that that prevents a program from handling a failure to allocate memory.
21:31:07 <monochrom> exactly like lazy I/O
21:31:21 <j4cbo> modern OSen are disgusting, sloppy monstrosities
21:31:25 <j4cbo> film at eleven
21:31:45 <mle> yep.  Just another lazy io case.
21:31:53 <mle> in a lot of situations it is fine.
21:32:42 <elly> I emphatically disagree that it is okay for the kernel to go around killing processes that have done nothing wrong to cover up its previous lies :P
21:33:18 <Axman6> heh
21:33:50 <j4cbo> The children now love luxury. They have bad manners, contempt for authority, they show disrespect to their elders...
21:33:51 <EvanR> i suppose i will consider out of memory a situation analogous to the hard drive exploding, and just commit periodic backups
21:34:16 <elly> j4cbo: where's that from?
21:34:26 <j4cbo> elly: Socrates, allegedly
21:34:29 <elly> heh
21:34:31 <pikhq> j4cbo: The definite of <limits.h> seems to require that chars be finite.
21:34:47 <gwern> j4cbo: don't forget their memories are weak from reading
21:34:54 <j4cbo> pikhq: that's a good point
21:34:57 <pikhq> It requires that the maximum value of char be a char.
21:35:38 <j4cbo> #define CHAR_MAX           __OMEGA__
21:35:38 <lunabot>  luna: Not in scope: `define'
21:35:46 <j4cbo> ;)
21:35:55 <elly> danger: __OMEGA__
21:35:55 <j4cbo> (i know, i know, that's not a natural)
21:36:06 <elly> j4cbo: "but it's close!"
21:36:30 <mle> hm, a c-like language where chars are Integers and pointers are keys in an intmap?
21:36:55 <HaskellLove> any book recomendations on program specification and verification please?
21:37:07 <HaskellLove> first time reader on topic so be gentle...
21:37:17 <pikhq> For a char to be an actual natural type would break the following portions of C: <limits.h>
21:37:36 <monochrom> http:///www.cs.toronto.edu/~hehner/aPToP/ is one
21:37:40 <copumpkin> HaskellLove: half an hour of actual coding proved to be too much?
21:37:41 <j4cbo> wow, this channel actually gets traffic.
21:37:52 <copumpkin> j4cbo: I should hope so, with >600 people in it
21:38:03 <j4cbo> i'm too used to #sml.
21:38:09 <ColonelJ> once people stop talking, everyone starts feeding the bot with functions
21:38:24 <j4cbo> HaskellLove: :(
21:38:41 <monochrom> > fix (True :)
21:38:43 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
21:38:58 <pikhq> > fix fix
21:38:59 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
21:39:02 <j4cbo> > fix error
21:39:03 <HaskellLove> copumpkin actually I am finishing the book on ML, could not resist, just a litle bit...
21:39:03 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
21:39:19 <ColonelJ> > fix "lol?"
21:39:20 <lambdabot>   Couldn't match expected type `a -> a'
21:39:21 <lambdabot>         against inferred type `[GHC.T...
21:39:30 <dmwit> fix ("lol? "++)
21:39:33 <dmwit> > fix ("lol? "++)
21:39:36 <lambdabot>   "lol? lol? lol? lol? lol? lol? lol? lol? lol? lol? lol? lol? lol? lol? lol?...
21:39:37 <monochrom> More information on fix at http://www.vex.net/~trebla/haskell/fix.xhtml
21:39:58 <j4cbo> > fix ("lo"++)
21:39:59 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
21:40:07 <kmc> HaskellLove, how long did it take you to read the ML book?
21:40:09 <kmc> also, which book?
21:40:11 <j4cbo> lolol.
21:40:15 <kmc> and did you write any code while reading it?
21:40:21 <kmc> > fix ((0:) . scanl (+) 1)
21:40:22 <Axman6> > fix (++ "lo")
21:40:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:40:26 <lambdabot>   mueval-core: Time limit exceeded
21:40:56 <HaskellLove> kmc no, I am reading to get general overview of sml, compare it to haskell and functional programming in general and get asap to haskell... i am on it 3 days i guess...
21:41:05 <HaskellLove> but not full time
21:41:20 <kmc> HaskellLove, why don't you pick something and learn it well?
21:41:43 <HaskellLove> it s Programming in ML - Carnegie Melon
21:41:44 <copumpkin> you seem to enjoy reading more than you enjoy actually doing the stuff you're reading about :)
21:42:07 <dmwit> Hm, when did this crowd turn anti-academic?
21:42:21 <pikhq> HaskellLove: fix (learn Haskell :)
21:42:23 <ColonelJ> > fix ((0:) . scanl (+) 2)
21:42:23 <copumpkin> dmwit: you clearly haven't been following this adventure :P
21:42:24 <lambdabot>   [0,2,2,4,6,10,16,26,42,68,110,178,288,466,754,1220,1974,3194,5168,8362,1353...
21:42:40 <dmwit> copumpkin: I suppose.  All I see is somebody asking for reading suggestions and getting attacked.
21:42:43 <Axman6> HaskellLove: reading lots of theory makes you a philosopher, not a (computer) scientist
21:42:50 <dmwit> WTF?
21:42:51 <kmc> dmwit, any serious academic has a depth of knowledge in at least one area
21:42:53 <monochrom> I didn't turn anti-academic. I brought up proving a type system consistent.
21:42:55 <j4cbo> HaskellLove, Harper's book?
21:43:07 <HaskellLove> copumpkin yeah but you guys know what you are doing when coding, functional programming is still dark forest for me so i try to cut down litle by litlte and you can't do it just with coding you lose sense of your path in general.... i have a rule, first think of the general and only then the specific, it always worked for me so...
21:43:29 <Axman6> HaskellLove: yes, you can, that's how we all did it
21:43:34 <pikhq> HaskellLove: You get better at functional programming by doing it.
21:43:41 <pikhq> Not by not doing it.
21:44:08 <copumpkin> dmwit: this has been going on for a couple of weeks now, and some people are getting frustrated, is all
21:44:14 <HaskellLove> j4cbo yes
21:44:15 <dmwit> I see.
21:44:34 <monochrom> I suggest refraining from answering.
21:44:43 <dmwit> monochrom++
21:45:11 * j4cbo should learn haskell one of these days, but has been almost entirely happy with SML
21:45:12 <ColonelJ> > fix ((1:) . scanl (*) 2)
21:45:14 <lambdabot>   [1,2,2,4,8,32,256,8192,2097152,17179869184,36028797018963968,61897001964269...
21:45:38 <elly> j4cbo: two words: 'deriving Show'
21:45:47 <ColonelJ> @src Show
21:45:47 <lambdabot> class  Show a  where
21:45:47 <lambdabot>     showsPrec :: Int -> a -> ShowS
21:45:47 <lambdabot>     show      :: a   -> String
21:45:47 <lambdabot>     showList  :: [a] -> ShowS
21:45:48 <elly> (;))
21:45:50 <j4cbo> elly: yeah, that's pretty tempting
21:46:02 <j4cbo> also, like, (+1)
21:46:08 <j4cbo> also typeclasses
21:46:19 <kmc> also purity
21:46:20 <j4cbo> also unsafePerformIO... ok, maybe i'll stick with ML.
21:46:35 <j4cbo> kmc: i like my programming languages like i like my women: eager and impure.
21:46:41 <kmc> haha
21:46:57 <ColonelJ> :t scanl
21:46:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:47:02 <ColonelJ> :t fix
21:47:03 <lambdabot> forall a. (a -> a) -> a
21:47:14 <HaskellLove> j4cbo you nasty boy, get your hands of Haskell :D
21:47:19 * copumpkin points j4cbo at http://pchiusano.blogspot.com/2009/05/optional-laziness-doesnt-quite-cut-it.html
21:47:44 <monochrom> I wonder what I like about Haskell.
21:48:02 <pikhq> monochrom: It's more a matter of what you hate about every other language ever. :P
21:48:07 <copumpkin> the cranks like Earle and Moore that it attracts
21:48:24 <Axman6> reckon they're the same person?
21:48:32 <kmc> HaskellLove, are you keeping notes about the books you read?
21:48:43 <HaskellLove> kmc yep
21:49:12 <monochrom> I suppose because it opens up so many better ways to abstract. (Laziness enables more abstractions. There are other factors.)
21:49:16 <kmc> on your blog?
21:49:47 <monochrom> I don't hate any other language, really. OK, sometimes I scorn at Perl because of @#%
21:49:56 <c_wraith> preflex: seen BONUS
21:49:56 <preflex>  BONUS was last seen on #haskell 10 hours, 37 minutes and 34 seconds ago, saying: and once we're done i'll put those changes up on the main page, along with the changes nice people from the net have warned me of
21:50:14 <j4cbo> copumpkin: i dunno, i feel like all that indicates is "scala does optional laziness wrong"
21:50:37 <monochrom> Typeclass is a really convincing story to me. Organized overloading.
21:51:02 <kmc> monochrom, i see you haven't used C++ or PHP
21:51:13 <j4cbo> i want a language with typeclasses and SML-style functors.
21:51:15 <j4cbo> and a pony.
21:51:22 <HaskellLove> kmc yep http://haskelllove.wordpress.com/
21:51:27 <monochrom> You must admit the Eq story of Haskell wins over the eqtype story of MLs.
21:51:35 <j4cbo> no argument there.
21:51:48 <monochrom> I have used C++. I haven't used PHP.
21:51:58 <kmc> HaskellLove, it looks like, in the past few days, you've written up notes on the introduction or first few chapters of each of five books
21:52:06 <kmc> are you reading five books in parallel and constantly adding more?
21:52:32 <HaskellLove> kmc only tapl and the one on sml are work in progress ...
21:53:53 <monochrom> I hated C++ in some distant past, yes. Not anymore. I have grown out of hating.
21:54:39 <monochrom> Now I am more like: I would charge more money if it has to be C++, less money if it has to be Haskell. I'm compensated, nothing to hate.
21:54:46 <j4cbo> i hated C++ until i actually wrote a large project in it
21:54:50 <j4cbo> and it wasn't that bad
21:55:32 <kmc> j4cbo, i'm past that stage
21:55:34 <kmc> and back to hating it
21:55:35 <monochrom> Indeed, I hated C++ just when it was a university course forcing the use of C/C++. No money received, and forced, that was really why.
21:55:42 <j4cbo> it wasn't *good*, but i didn't find myself fighting with the language
21:55:55 <kmc> because eventually you will realize that the long project would have taken 1/5 the time to complete in another language
21:56:14 <kmc> and you see that all the super nifty complex C++ design patterns you learned are just workarounds for language flaws
21:56:23 <j4cbo> my current big projects are a kernel (in C) and a mid-sized web application (in SML).
21:56:31 <monochrom> Oh no, not much to fight with the language. Just very tedious type signatures in for loops just because you use iterators from STL.
21:58:01 <napping> Being able to specify the memory layout and offer some degree of abstraction is one thing C++ has going for it
21:58:22 <kmc> and then a 2 page incomprehensible error because you used an iterator instead of a const_iterator in one place.  even though it was used as const
21:58:23 <monochrom> I used a map, whose value part is another map.  map<id, map<name, mytype> > ...
21:58:38 <kmc> napping, you can do that in straight C
21:58:51 <j4cbo> can you ever!
21:59:26 <monochrom> haha kmc I got that enough number of times that I became oblivious to it!
21:59:55 <monochrom> "oh, this again, yeah, need const_iterator"
22:00:03 <j4cbo> typedef struct new_stack_t { ctx_switch_frame_t ctx_switch_frame; void * next_return_addr; entry_t entry_frame; } new_stack_t;
22:00:12 <j4cbo> delicious, yet terrible.
22:00:25 <kmc> C++ is basically C with a huge pile of features added, each interacting with all the others, such that if you choose features very carefully and then use them together exactly right, the result is a language not much worse than C.
22:00:40 <j4cbo> kmc: well put.
22:00:56 <napping> Eh, trying to do anything like objects in C is pretty painful
22:01:00 <tass> Hrm... http://cthulhu.regex.pl/shub_build_error.log
22:01:18 <tass> I think there's _something_ that ghc doesn't like about my code : P
22:01:22 <napping> Is shub_build_error one of the elder gods of computer science?
22:01:40 <tass> napping: Oh yes
22:01:44 <napping> looks like a liner error
22:01:56 <napping> did you use ghc --make ?
22:02:04 <tass> Nope, just ghc?
22:02:16 <napping> ah, then you have to say -package foo for some dependencies
22:02:25 <c_wraith> really, use --make.  always.
22:02:36 <tass> Oh, that worked, cheers : )
22:02:43 <napping> and "base" has been shedding functionality for a while now
22:02:45 <tass> (That's what you get for inexperience, I guess)
22:02:56 <c_wraith> (unless you're using cabal, or want to compile a file without linking it)
22:03:06 <kmc> or you have to work within an existing build system
22:03:20 <kmc> which reminds me, if anyone has some bjam rules for ghc laying around i'd be very interested to see them
22:04:50 <tass> BTW, does haskell build stuff statically linked?
22:04:58 <tass> Or rather, does GHC do that?
22:05:06 <kmc> ghc is static by default
22:05:10 <tass> Groovy
22:05:11 <kmc> and until recently that was the only option
22:05:20 <napping> that doesn't mean it statically links everything, though
22:05:20 <tass> A 1.3M binary of my irc bot : D
22:05:31 <c_wraith> well.  it's static against haskell libraries.  it's dynamic against system libraries, by default.
22:05:39 <tass> Ah : )
22:05:52 <napping> yeah, like that. I don't know how to get everything static
22:06:27 <mle> it's tricky on some systems.
22:07:11 <c_wraith> I'm not sure you really want to link statically against libc very often, anyway
22:07:20 <mle> worstcase you can always strace to determine the ld command line used then at -Bstatic -Bdynamic stuff to adjust as needed.
22:07:35 <mle> did that for "portable" solaris darcs in the darcs 1.x era
22:07:39 <napping> well, I don't seem to have statically linkable versions of some system libraries
22:07:56 <napping> not really a big deal
22:08:51 <napping> Seeing a linker error like that is probably fatal, wouldn't it be nice if GHC would figure out the packages that would have been used with --make and suggest them?
22:09:00 <tass> I guess it'd be useful to have some libs built in statically, so you can take the binary to other systems.
22:09:07 <monochrom> I think another thing I like about Haskell is not Haskell itself but the libraries. Their APIs are well-designed mostly. See http://lambda-the-ultimate.org/node/3720 . Note there are even examples where you don't need Haskell's high abstraction ability (laziness, HOF) to give a sensible interface but lib authors in other languages just don't care.
22:10:33 <kmc> Maybe mutable state makes bad APIs too easy?
22:10:57 <kmc> We have state too, but it's considered a big deal to use it
22:11:24 <kmc> So it's not used for frivolous things like { Date date(2009, 12, 1); date.setMonth(11); }
22:12:38 <tass> I like how all configuration of my bot is hardcoded.
22:12:43 <tass> : P
22:12:55 <dmwit> ack
22:13:05 <kmc> tass, just like xmonad and yi ;)
22:13:11 <tass> ; )
22:13:17 <kmc> if you want to get fancy, look at the package "dyre"
22:13:24 <tass> I didn't like yi, really.
22:13:41 <tass> It was "almost like vim, but not quite"
22:13:51 <tass> So missed a lot of things I'm used to
22:13:52 <manym> was it because you were using it vim mode?
22:14:00 <manym> use it emacs mode!
22:14:11 <tass> But I don't really like emacs.
22:14:23 <tass> No, let me rephrase; I'm not really comfortable with emacs.
22:14:26 <manym> This means war
22:14:29 <manym> Hm, okay.
22:14:37 <kmc> @vixen vi or emacs?
22:14:38 <lambdabot> i think you know the answer to that one, silly
22:15:23 <tass> And lisp syntax always felt awkward to me, even though you can fix it with stuff like sweet expressions.
22:16:55 <c_wraith> I feel like haskell goes out of its way to be anti-lisp, syntactically.  It gives you so many ways to avoid using any parens at all...
22:17:13 <tass> Haha : D
22:17:39 <tass> Well, python is worse : P
22:18:32 <mle> try liskell
22:20:03 <tass> Well, I like Haskell syntax, so I don't see the point ; )
22:21:36 <kmc> Lisp is designed for ease of metaprogramming at the expense of ease of programming
22:22:00 <tass> Sounds about right : P
22:22:06 <kmc> Except I don't trust dynamically-typed programs written by dynamically-typed programs
22:22:07 <lament> haskell is the anti-lisp, much in the same way that jesus is the anti-antichrist
22:22:10 <c_wraith> Oh, right.  GHC 6.12 will even get rid of parens in top-level TH.  :)
22:22:10 <tass> (I'm all for ease of programming)
22:22:46 <kmc> i like metaprogramming but i think it's the sort of thing you resort to
22:22:58 <lament> you *like* metaprogramming?
22:23:11 <kmc> yessir
22:23:26 <mle> metaprogramming is an optimization.
22:23:45 <mle> ideally you shouldn't need it.  ideally.
22:23:56 <kmc> mle, often the thing you optimize is programmer productivity
22:23:57 <lament> why is it an optimization?
22:24:01 <lament> it's an abstraction
22:24:14 <lament> just like any other abstraction, like polymorphic types
22:24:20 <monochrom> Hey what is metaprogramming? Is it like, instead of programming, you talk about programming?
22:24:22 <kmc> i see it as a relatively self-contained way to extend the language
22:24:24 <kmc> haha
22:24:24 <monochrom> </troll>
22:24:35 <kmc> monochrom, i've been doing too much of that :/
22:24:39 <mle> for things like templates to avoid repetitive code, sure.  That's good.  But it's describing a solution for a limitation in the expressive power of the language.
22:24:44 <Axman6> monochrom: hey, i think we have an expert on that in here!
22:24:44 <lpsmith> j3cbo:   I know a guy who is developing a "Hi Language",   it looks like a rather nice cross between Haskell and ML,  with the good parts of Erlang's syntax.
22:24:58 <jmcarthur> i agree that syntactic abstraction is more hacky than semantic abstraction
22:24:58 <lpsmith> I don't know if it has functors or not
22:25:02 <mle> a lot of macro use in CL is to have function-like things that don't evaluate their arguments
22:25:10 <mle> which is bad.
22:25:14 <c_wraith> is talking about metaprogramming metametaprogramming?
22:25:31 <jmcarthur> c_wraith: now you're metametametaprogramming, right?
22:25:35 <kmc> oh snap
22:25:44 <kmc> > fix ("meta"++)
22:25:46 <lambdabot>   "metametametametametametametametametametametametametametametametametametame...
22:26:01 <jmcarthur> me tame tame tame tame tame...?
22:26:46 <lament> somehow metaprogramming and dynamic scope seem similar in flavor :)
22:27:00 <kmc> because of the issue of name capture?
22:27:04 <lpsmith> yeah,  my eye is definitely drawn to tame...
22:27:16 <lpsmith> What if you use hygenic macros?
22:27:18 <kmc> it's that damn t.  thinks it's so great, taller than the other letters
22:27:29 <kmc> > fix ("Meta"++)
22:27:31 <lambdabot>   "MetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMetaMe...
22:27:39 <lament> kmc: i guess because both force you to concentrate on what your program is rather than what it does
22:27:46 <Axman6> god damn it, i hate websites that require a secret question >_<
22:28:12 <mle> I use questions like WRqcMsGAP3QJHc05FS8KZp2fxUlKrAJ2
22:28:33 <monochrom> "What is my favourite programming language?" may do well. or not. at least it fulfills the requirement.
22:28:44 <lament> Axman6: i once had to register on a website that required me to provide answers to five questions, each question chosen from a small predetermined set
22:28:47 <dmwit> I use questions like, "What is my mother's maiden name?", and answers like WRqcMsGAP3QJHc05FS8KZp2fxUlKrAJ2
22:28:51 <lpsmith> lament:  have you ever played around with hygenic macros? :-)
22:28:57 <Axman6> lament: ...
22:29:09 <tass> lament: Oh, I know those!
22:29:12 <tass> They are horrible :<
22:29:24 <lament> it took me a while to even find five questions i knew answers to
22:29:27 <Axman6> dmwit: actually, that's not a bad idea, 1Password can create random answers and remember them for me
22:29:40 <lament> they were like, "what hospital were you born in"
22:29:43 <lament> i'm not kidding
22:29:44 <mle> tass: they do improve security for the general case though.  I've seen users with questions like 'what color is the sky' -> 'blue'
22:29:51 <Adamant> dmwit: is she a WRqcMsGAP3QJHc05FS8KZp2fxUlKrAJ2 on her mom or dad's side?
22:29:59 <dmwit> heh
22:30:05 <napping> kmc: tactics in Coq are an interesting case - dynamically typed code making the exct opposite of dynamically typed code
22:30:08 <tass> mle: I'd rather _NOT_ have "secret questions".
22:30:38 <mle> tass: well yeah.  Best to just send a client-side certificate.  or kerberos ticket.  or something.
22:30:47 <lament> lpsmith: not much, no
22:30:48 <tass> Yeah
22:31:03 <tass> Like when I connect to my box through ssh..
22:31:41 <tass> I've got a 10Kbit ssh RSA key created and stored on an encrypted volume mounted to my .ssh directory.
22:31:50 <lpsmith> I guess I've never really used dynamic scope,  so I don't get what it's useful for...
22:32:06 <tass> I type my long secure master password once (when mounting the volume), and then I'm good to go.
22:32:56 <lament> i use the same password for all sites and nobody hacked me yet.
22:33:04 <tass> Nay, password isn't quite correct, passphrase is more like it.
22:33:30 <monochrom> "What is my favourite Haskell one-liner?"
22:33:42 <medfly> heh
22:33:58 <medfly> answering the actual question can be problematic.
22:34:00 <elly> passprogram
22:34:16 <monochrom> Be careful to remember the exact spacing.
22:34:45 <napping> spacing?
22:35:26 <medfly> this one time when I was a kid I actually guessed someone's secret question because it was the obvious answer to the question
22:35:54 <medfly> something about his favourite some sports field team, and I knew where he lived. it was the local team. (I had a list of all the other teams in the country, too)
22:36:11 <medfly> it's funny passwords can be obvious like that
22:36:19 <medfly> you'd think you'd need some fancy work to find them out :)
22:36:37 <kmc> didn't sarah palin's yahoo mail get hacked this wya
22:36:44 <medfly> it'd make sense
22:36:45 <kmc> "where did you grow up"
22:36:50 <medfly> lol
22:36:54 <kmc> "who is your favorite republican president"
22:36:54 <medfly> some question for a politician
22:37:27 <kmc> you can expect this to happen when your entire public life is a series of simple repetitive catchphrases
22:38:09 <tass> : )
22:38:10 <Adamant> it was "where did your husband go to high school" IIRC
22:38:25 <tass> Guess I ought to learn emacs
22:38:59 <kmc> "what is your favorite animal to hunt from an aircraft"
22:39:00 <monochrom> napping: So you chose "fix ((0 :) . scanl (+) 1)
22:39:00 <monochrom> " to be your favourite. Then next time you enter it as "fix ((0:) . scanl (+) 1)
22:39:00 <monochrom> " and that's a problem.
22:39:21 <napping> yeah, so minimize spaces
22:39:25 <Adamant> well.. they met and were raised in Wasilia. Clearly extensive brute force searching is required to solve this program.
22:39:27 <napping> unless you want a little more entropy
22:39:36 <Adamant> *problem
22:39:43 <medfly> hehehehe
22:39:45 <BMeph> tass: Maybe you should learn yi, and fid a way to make it work to your own liking...then write it up and Force Other Programmers To Your Will! ;)
22:39:45 <medfly> yeah...
22:40:07 <medfly> I remember reading this one thing that things like 123456 are the most common passwords
22:40:15 <elly> There is no more free will, only my will.
22:40:23 <monochrom> And asdf the most common user name
22:40:32 <Adamant> maybe we could just relabel it 'All personal questions for passwords are worthless if subject is or becomes famous'
22:40:48 <luite> does yi support background syntax and type checking for haskell files?
22:40:57 <tass> BMeph: I actually considered coding a haskell editor in haskell.
22:41:33 <napping> I remember a study saying that the most popular password was now "password1", up from "password" some years back
22:41:49 <medfly> I wanted to use xmonad and yi, just to be cool like that, but to write javascript.
22:41:57 <medfly> hahahaha
22:42:07 <mle> yeah, that adds a number which defeats most safety checkers, but crypt() only looks at the first 8.  -.-
22:42:09 <medfly> those kind of lists should be made public
22:42:11 <tass> I used xmonad on my boxes with a display
22:42:16 <tass> Really like it
22:42:16 <Adamant> Paris Hilton more or less got hit by a similar attack on her Sideback back when she was vaguely relevant with people who weren't
22:42:25 <medfly> crpyt()?
22:42:37 <Mark1> is there a reason why parentheses are necessary for function composition in the interpreter but not in source files?
22:42:46 <kmc> i always assumed Paris Hilton was not a real person but some kind of elaborate sociology experiment
22:42:54 <kmc> CGI images on the evening news
22:43:01 <mle> medfly: see man 3 crypt
22:43:03 <Axman6> @remember medfly I wanted to use xmonad and yi, just to be cool like that, but to write javascript.
22:43:03 <lambdabot> It is stored.
22:43:09 <dmwit> Mark1: eh?
22:43:14 <Adamant> kmc: who says a real person can't be using their life as a profitable sociology experiment
22:43:15 <BMeph> I'm shocjed! I would've bet on "p@ssw0rd" being #1. ;)
22:43:22 <BMeph> *shocked
22:43:23 <dmwit> Mark1: Doesn't sound right to me.
22:43:34 <Adamant> "the most common passwords are God, sex, drugs, money.."
22:43:37 <Axman6> Mark1: got an example of what you're talking about?
22:43:58 <dolio> Is that a Hackers quote?
22:44:07 <Mark1> well.. for example, "lcp = map head . takeWhile (\(x:xs)-> all (==x) xs) . transpose" seems to work in a source file, but not if i enter it directly into the interpreter
22:44:07 <Axman6> sounds like it to me
22:44:12 <Adamant> probably, but they all blur together after a while
22:44:17 <Adamant> and I probably mangled it
22:44:25 <lament> aaaaaa is common, qwerty is common
22:44:26 <Axman6> Mark1: you need let lcp = ...
22:44:27 <dmwit> Mark1: Try sticking a "let" in front. ;-)
22:44:47 <kmc> what about ',.pyf
22:44:56 <dmwit> ',.pyf
22:45:00 <dmwit> Huh, it does look funny.
22:45:02 <kmc> haha
22:45:05 <Twey> Heh, aoeui
22:45:20 <dmwit> I have entire files full of snthsnthsnthsnth for testing purposes.
22:45:22 <Mark1> ah, ok. :-) i'll give that a try.
22:45:32 <Twey> dmwit: What's that useful for?
22:45:33 <dolio> kmc: No, your password is fine.
22:45:39 <dmwit> Twey: testing ;-)
22:45:49 <kmc> alias aoeu='setxkbmap -layout us'; alias asdf='setxkbmap -layout dvorak'
22:45:52 * Twey has /dev/urandom for that purpose :þ
22:46:06 <monochrom> You see what I mean by "you can easily answer a question asked 10 seconds later".
22:46:10 <medfly_> I'm wondering if someone produced a very large list of the most common passwords and then someone would try to get into many accounts like that, it'd be easier than trying to guess captchas
22:46:29 <dmwit> kmc: setxkbmap -option grp:shift_caps_toggle 'us(dvorak)+us(qwerty)'
22:46:40 <lament> medfly_: there're many lists of common passwords, large and small
22:46:41 <Twey> cat /dev/urandom | sed 's/[^ -~]//g'
22:46:54 <dmwit> monochrom: nice try ;-)
22:46:56 <medfly_> mostly about the latter bit
22:47:04 <medfly_> I think usernames are much easier to guess
22:47:31 <monochrom> I should collect all these examples.
22:47:45 <dmwit> medfly_: There was a reddit thread a few days ago where people got into the hacking spirit; probably 40 or more accounts were stolen by guessing common passwords or username-for-password type deals.
22:48:07 <medfly_> heh
22:48:18 <Mark1> hmm.. when i try to run lcp x, i get a "couldn't match expected type" error
22:48:23 <medfly_> I was wondering if using that on many accounts might be easier than guessing captchas
22:48:35 <Adamant> reddit is definitely not a cesspool
22:48:44 <Axman6> Adamant: only turning into one
22:48:45 <Adamant> that's gone to hell
22:49:00 <dmwit> bah
22:49:09 <Adamant> Axman6: well yes, there was a time when it was awesomesauce
22:49:11 <dmwit> It's easy, you just keep moving to smaller and smaller subreddits.
22:49:15 <BMeph> :t let lcp = map head . takeWhile (\(x:xs)-> all (==x) xs) . transpose in lcp
22:49:16 <lambdabot> forall a. (Eq a) => [[a]] -> [a]
22:49:21 <Axman6> fucking digg users
22:49:22 <medfly_> soon there will be another site, yes
22:49:49 <Axman6> i'm so sick of all the crappy memes that have developed on reddit. especially the english gentelman one
22:49:51 <Adamant> dmwit: I think mathematics has something to say about that, continunity
22:50:09 <Adamant> and the John Gabriel Greater Internet Fuckwad Theory
22:50:49 <dmwit> That is why you move to smaller communities.
22:51:04 <dmwit> Smaller communities are "less anonymous" because your nick is not one of thousands but one of merely dozens.
22:51:20 <Adamant> well the point I am trying to make, is that gradually, even smaller and smaller communities are getting worse
22:51:24 <kmc> one of 576
22:51:38 <dmwit> > sqrt 567 == 26
22:51:39 <lambdabot>   False
22:51:41 <dmwit> bah
22:51:44 <dmwit> > 26*26
22:51:45 <lambdabot>   676
22:51:48 <kmc> i think the size of a workable community is mostly fixed by biology at around 100
22:51:53 <dmwit> yep
22:52:05 <BMeph> > 24 * 24
22:52:06 <lambdabot>   576
22:52:08 <medfly_> heh
22:52:15 <dmwit> The exact number differs by who you ask, some go up to 200.
22:52:20 <Adamant> well #haskell seems to be doing OK, despite them letting idiots like me post.
22:52:35 <dmwit> I wonder how many people are actually active here.
22:52:40 <dmwit> ?users
22:52:40 <lambdabot> Unknown command, try @list
22:52:46 <dmwit> ?list
22:52:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:52:50 <medfly_> I'm tempted to write a plugin just so I can see that.
22:52:57 <medfly_> (to lambdabot?)
22:53:02 <monochrom> We take shifts. 600 people / 3 shifts = 200 people per shift.
22:53:02 <dmwit> "seen provides: users seen"
22:53:11 <kmc> you can download the logs
22:53:13 <Adamant> sounds about right.
22:53:15 <medfly_> right.
22:53:40 <dmwit> Well I for one do my part to be active at different times each day. =P
22:53:56 <lpsmith> @seen dolio
22:53:56 <lambdabot> Unknown command, try @list
22:54:09 <dolio> preflex: seen dolio
22:54:09 <preflex>  dolio was last seen on #haskell 8 minutes and 36 seconds ago, saying: kmc: No, your password is fine.
22:54:14 <Adamant> dmwit, strong connector in the social graph
22:54:32 <lpsmith> heh
22:54:36 <dmwit> Hm, I hope that makes me powerful or something.
22:55:20 <Adamant> it worked for a dorky Harvard undergrad, it can work for you
22:55:23 <Axman6> http://thedailywtf.com/Articles/Really_Unique_Passwords.aspx ... jesus
22:55:35 <lpsmith> have you played around with codensity-like tricks (using the forall to hide the final result type)  in an effort to create a call-by-name continuation monad?
22:56:38 <dolio> No.
22:56:57 <dolio> Codensity type stuff doesn't have call/cc.
22:58:33 <dolio> Of course, I've never bothered figuring out call/cc for call-by-name CPS, either.
22:58:39 <lpsmith> I'm making multiple guesses based on fuzzy intuition here... but it seems that (say) the lazy state monad doesn't get executed at all like an imperative programmer might assume
22:59:58 <kmc> lpsmith, how so?
23:00:26 <alinp> hi guys
23:00:30 <lpsmith> It seems like you start from the end,  somehow,  and execute only those parts that are needed to compute whatever is demanded from the final answer
23:00:34 <dolio> Yeah, I don't disagree. I was thinking about that earlier.
23:00:40 <alinp> could anyone please tell me .. if Maybe is a monad ?
23:00:46 <dmwit> Sure it is!
23:00:49 <Twey> Maybe is indeed a monad
23:00:54 <dmwit> > Just 3 >> Just 4
23:00:55 <lambdabot>   Just 4
23:00:56 <alinp> if yes, why is this possible ? let test1 :: Maybe Int -> Int; test1 (Just a) = a; test1 Nothing = 0
23:01:02 <Twey> > Just 5 >>= return . succ
23:01:03 <lambdabot>   Just 6
23:01:08 <Twey> > Nothing >>= return . succ
23:01:10 <lambdabot>   Nothing
23:01:13 <alinp> I mean, I knew that when entering a monad, you cannot leave it
23:01:13 <Twey> > return 5
23:01:15 <lambdabot>   No instance for (GHC.Show.Show (m t))
23:01:15 <lambdabot>    arising from a use of `M3772545890...
23:01:17 <dmwit> alinp: There's nothing preventing monads from being "runnable".
23:01:17 <kmc> alinp, that is not true
23:01:22 <Twey> > return 5 :: Maybe Int
23:01:23 <lambdabot>   Just 5
23:01:24 <lpsmith> sohum,  how do you start from the end in an arbitrary continuation with non-local exits?
23:01:25 <kmc> alinp, it's only true for IO and certain other "strange" monads
23:01:28 <Twey> … aand that's about everything you need to know about the Maybe monad
23:01:30 <lament> alinp: you have been reading the wrong monad tutorials :)
23:01:34 <kmc> alinp, IO is not a typical example of a monad
23:01:35 <lpsmith> But a codensity doesn't have non-local exits
23:01:38 <dmwit> alinp: The correct statement is that there is no "run" function that works for *all* monads.
23:01:42 <dolio> Although, I don't usually think of 'undefined >> whatever' as being the best example of lazy state.
23:01:45 <alinp> mno, I didn't read the wrong one :)
23:01:56 <dmwit> alinp: Any particular monad is of course free to have a run function if it likes. =)
23:01:59 <dmwit> :t runState -- for example
23:02:01 <alinp> I read some stuff from haskell.org
23:02:01 <lambdabot> forall s a. State s a -> s -> (a, s)
23:02:02 <lpsmith> So that's my very hand-wavy and incomplete thinking that lead to the question.
23:02:06 <dolio> Rather 'State (\_ -> undefined)'.
23:02:07 <Axman6> alinp: i think your understanding of monads is greatly misguided :)
23:02:15 <dolio> Even though those should be the same.
23:02:16 <dmwit> I don't think it's greatly misguided.
23:02:20 <dmwit> It's only a little bit misguided.
23:02:21 <alinp> ok, so, the entering and not leaving, is available only for IO monad ?
23:02:32 <kmc> alinp, there are others, but it's not the norm
23:02:38 <kmc> and certainly not required by the concept of "monad"
23:02:42 <dmwit> alinp: Leaving is available for IO, too.  (But, shhh, it wasn't me who told you!)
23:02:49 <kmc> alinp, if you want to do IO, do IO.  if you want to learn Monads, forget for a little while that IO is a monad.
23:03:01 * tass now has a basic understanding for operating emacs but doesn't quite understand how to intialize the haskell-mode
23:03:04 <kmc> you're definitely on the way, by learning Maybe
23:03:07 <kmc> it's a great first example of a monad
23:03:11 <Twey> tass: M-x haskell-mode
23:03:13 <lpsmith> yeah,  I haven't thought through the algebraic laziness properties of the lazy state monad in detail
23:03:16 <alinp> yeah, I'm on that way
23:03:18 <alinp> thanks guys
23:03:27 <dmwit> Nothing wrong with learning monads, if you like.
23:03:32 <dmwit> Just don't assume it's required reading. =)
23:03:33 <Axman6> @src Maybe Monad
23:03:33 <lambdabot> Source not found. :(
23:03:40 <Axman6> @src Monad Maybe
23:03:40 <lambdabot> Source not found. There are some things that I just don't know.
23:03:42 <kmc> @src Maybe (>>=)
23:03:43 <lambdabot> (Just x) >>= k      = k x
23:03:43 <lambdabot> Nothing  >>= _      = Nothing
23:03:44 <Axman6> bah
23:03:49 <Axman6> that's right
23:03:50 <tass> Twey: No match : S Weird, I could swear I installed the package...
23:04:06 <lament> alinp: basically, monads are somewhat difficult and so require a tutorial; the IO monad is also somewhat difficult and requires a tutorial; but because the IO monad is the first example of a monad most people come across, these two tutorials end up merged in one
23:04:12 <lpsmith> dmwit:  amen :)
23:04:35 <alinp> yes lament, I agree with you
23:04:41 <alinp> this is what happened to me
23:04:54 <dmwit> ?go the io monad for people who just don't care
23:04:54 <lambdabot> Maybe you meant: google googleit do
23:04:58 <dmwit> ?google the io monad for people who just don't care
23:05:00 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
23:05:00 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
23:05:11 <dmwit> The antidote to "must learn monads" disease. =)
23:05:33 <dmwit> ?google you could have invented monads and maybe you already have
23:05:34 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:05:35 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
23:05:47 <dmwit> This is the antidote to "want to learn monads" disease. ;-)
23:05:55 <Twey> tass: You need to load the file… there's a guide on the page
23:05:58 <lament> dmwit: the don't care tutorial is remarkably long for a tutorial for people who simply don't care
23:06:06 <sohum> lpsmith: uh... I don't know?
23:06:26 <dmwit> =)
23:08:24 <lpsmith> sohum,  oops,  I meant to type  so... um... =)
23:08:40 <tass> Twey: Yeah, noticed that about now, trying to figure out which file is the main file, though.
23:10:15 <tass> There we go
23:10:36 <tass> Now I just need to figure out a way for automagically initializing haskell-mode for haskell files...
23:10:44 <sohum> lpsmith: :P no problem
23:16:36 * kmc is overwhelmed by the number of audio-related packages on Hackage
23:16:50 <kmc> if i just have some samples and want to dump them to the soundcard in Linux, what's a reasonable way to do this?
23:17:35 <monochrom> maybe cat > /dev/dsp , but I don't really know.
23:18:07 <monochrom> find a suitable /dev/blah thing and hope that you can just dump data to it.
23:18:27 <dolio> lpsmith: Do you have some example program that distinguishes between strict and lazy state besides stuff involving undefined?
23:18:44 <snowbeard> tass: paste this into your .emacs file
23:18:45 <snowbeard> tass:
23:18:54 <snowbeard> (setq auto-mode-alist (cons '("\\.hs$" . haskell-mode) auto-mode-alist))
23:19:06 <tass> snowbeard: Cheers!
23:19:09 <monochrom> You could write a loop instead of an undefined.
23:19:41 <dolio> Something not involving bottom, then. :)
23:19:49 <monochrom> Eww.
23:19:51 <kmc> monochrom, you've got to ioctl those first.  i'm sure an external prog will do it for me, but a simple API would be nice
23:19:55 * kmc shrugs
23:20:09 <dolio> Or maybe something that's bottom with strict state, but non-bottom for lazy state.
23:20:30 <tass> Nice, that works : )
23:20:42 <dolio> Due to circularity of the overall computation, rather than just propagating bottoms.
23:21:35 <tass> Now.. if I just found commands for deleting what's in front of the cursor, whole lines, and joining lines together, I could use emacs about as efficiently as I do vim.
23:22:57 <Twey> tass: I recommend http://xahlee.org/emacs/ergonomic_emacs_keybinding.html
23:24:50 <tass> Twey: Looks like rather sane keybindings
23:25:20 <Twey> Ayup
23:25:38 <Twey> Using meta for everything takes some getting used to, but it pays off
23:26:59 <monochrom> @where paste
23:26:59 <lambdabot> http://hpaste.org/new
23:28:09 <monochrom> Should I trust that?
23:28:17 <Cale> copumpkin: Heh, are you godofpumpkins on reddit?
23:28:18 <Axman6> no
23:28:25 <copumpkin> Cale: *cough*
23:28:28 <copumpkin> surely not!
23:28:37 * copumpkin looks guilty
23:28:41 <Cale> hehe
23:28:51 <monochrom> Oh haha, Firefox remembers better than I can!
23:29:14 <copumpkin> Cale: you saw my "provocative" submission to /r/math? :P
23:29:16 <Cale> The "irrationals are countable" thing you posted to the math subreddit is cute
23:29:30 * Smokey` sighs and leaves
23:29:43 <copumpkin> Cale: did you see my follow-up comment about the reals being uncountable because the rationals are uncountable, and the irrationals countable? :P
23:29:56 <Cale> heh
23:30:22 <Cale> I just posted a comment on the blog which explicitly gives a number which is not in the table when the central element is pi
23:30:26 <copumpkin> it's a pity stuff like that gets downvoted because people aren't sure if I'm kidding about it
23:30:39 <Cale> (specifically, e^pi is not in the table)
23:30:41 <dolio> Cale: Won't matter.
23:31:03 <HaskellLove> I am reading A Practical Theory of Programming, can I ask questions related here on channel or not? Haskell unrelated but proofs, logic, bla bla related...
23:31:28 <Cale> Every pair of numbers in the table is algebraically dependent over Q, since they're all polynomials in the central element with rational coefficients.
23:31:40 <tass> Twey: Though, arguably I should probably use the default bindings as they are what I'll encounter in documentation while learning how to handle the beast.
23:31:44 <monochrom> dolio: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5481#a5481
23:31:56 <Cale> and so any number which is algebraically independent of the originally selected number certainly won't be in there
23:32:03 <napping> copumpkin: well, there is that guy on knoll who seems to seriously claim rationals are uncountable or something
23:32:03 <Twey> tass: Doubt it
23:32:09 <Twey> tass: It only changes the basic movement bindings
23:32:10 <monochrom> I know this trick because my thesis depends on it!
23:32:20 <Twey> All the clever stuff is in mostly the same place
23:32:27 <copumpkin> napping: yeah, saw him too
23:32:30 <dolio> Ah, good.
23:32:38 <tass> Ah, I se
23:33:06 <tass> s/\\s(se)$/see/
23:33:21 <Cale> copumpkin: Oh, I almost missed it: "In totality, is this the continuum hypothesis?"
23:33:24 <copumpkin> HaskellLove: we don't mind in principle, I don't think, as long as they're questions which are potentially interesting to haskell programmers and applicable to haskell
23:33:30 <copumpkin> Cale: yeah, wasn't even sure how to respond to that
23:33:31 <tass> (Don't ask, I'm a regex-o-holic)
23:34:05 <copumpkin> Cale: but beyond the article itself, the comments really reveal how little he understands
23:34:13 <Cale> yeah
23:34:25 <dolio> monochrom: Okay, thanks. That clarifies my thinking.
23:34:32 <copumpkin> Cale: for a set S = {1,2,3}, he seems to think that S x S = {1,2,3,1,2,3}
23:34:35 <kmc> unlike ##c++, #haskell lacks a bot that snarks people who are off-topic
23:34:41 <HaskellLove> copumpkin that means i should send here or not? lot of them won't be haskell related, i guess i should find a proofs stuff chanel
23:35:19 <medfly_> heh
23:35:19 <Mark1> is there an easy way to compare each element in a list to the element that comes after it?
23:35:29 <kmc> Mark1, zipWith (==) xs (tail xs)
23:35:36 <kmc> or substitute (==) for whatever comparison you want
23:35:41 <copumpkin> HaskellLove: no, I think we're interested in general, but people might get frustrated with you asking about it in particular.
23:35:44 <medfly_> I was told it's okay to be off topic here if you talk CS or mathematics.
23:35:49 <Twey> Heh.
23:35:49 <kmc> > let xs = "hello world!" in zipWith (==) xs $ tail xs
23:35:50 <lambdabot>   [False,False,True,False,False,False,False,False,False,False,False]
23:35:59 <Mark1> kmc, thanks
23:36:07 <kmc> > let xs = "hello world!" in zipWith compare xs $ tail xs
23:36:08 <lambdabot>   [GT,LT,EQ,LT,GT,LT,GT,LT,GT,GT,GT]
23:39:23 <copumpkin> I hope I didn't offend him
23:39:38 <kmc> sigh
23:39:47 <dibblego> he'll be back
23:40:05 <kmc> he seems impervious to criticism
23:40:17 <kmc> also seriously manic
23:40:33 <Twey> Didn't he get banned?
23:40:39 <kmc> and then un-banned
23:40:47 <merehap> for doing what?
23:41:08 <kmc> being super annoying
23:41:30 <merehap> about his super-duper compiler plans?
23:41:51 <kmc> meh, i don't care enough to dig up the logs, sorry
23:41:59 <copumpkin> for being hyper ADD about learning stuff, "reading books" in about half an hour, and generally not actually learning haskell
23:42:11 <Twey> Haha
23:42:13 <merehap> ah
23:42:20 <medfly_> heh
23:42:44 <kmc> we should ban him until he uploads something worthwhile to hackage
23:42:52 <kmc> now please do not apply this standard globally because i have done jack shit in that department
23:42:57 <Twey> Haha
23:43:03 <Twey> Hypocrisy!  :þ
23:43:05 <copumpkin> lol
23:43:05 <medfly_> I don't think that will ever happen
23:43:19 <copumpkin> medfly_: he seems awfully enthusiastic, which makes me feel bad for getting annoyed at him
23:43:25 <medfly_> yeah.
23:43:27 * BMeph is guiltily reminded that he really should follow up on his hackage package...
23:43:32 <medfly_> me too.
23:43:32 <copumpkin> but damn, he seems incapable of staying still for a minute
23:43:36 <kmc> we could find his meatspace address and send a jumbo family size bottle of adderall
23:44:02 <medfly_> I think that when I'm very enthusiastic about something, I"m annoying and flood people with text.
23:44:03 <merehap> are the logs for this channel publically available, or should I be keeping my client logged in in order to record history?
23:44:08 <medfly_> it could be a side effect of his enthusiasm.
23:44:17 <kmc> merehap, the former.  see topic
23:44:27 <merehap> ok, thanks
23:44:32 <copumpkin> merehap: it's in the topic
23:44:42 <medfly_> merehap: I'm curious, why would the logs of what is going on, especially when you're not online, be so importnat to you?
23:45:20 <merehap> might be nice to go over in case I've missed anything interesting
23:45:34 <BMeph> kmc: Can you actually do that, because being able to pick up a family size bottle of adderall sounds like itd be a really neat trick to have, it could even be usefull at parties and such like if you wanted to stay up all night and just like you know, PARTY!!! but if you cant do it, then its okay im just asking
23:45:36 <merehap> I don't have any specific purpose in mind at this point...
23:45:45 <medfly_> merehap: but how would you know about it if you haven't been around? :)
23:45:57 <kmc> ehehe
23:45:59 <BMeph> :)
23:46:12 <merehap> another Haskell friend, in the meatspace
23:46:27 <medfly_> wow, meatspace Haskell friends.
23:46:43 <merehap> it is weird to think about...
23:46:57 <lament> meatspace friends...
23:47:46 <medfly_> I only know like 4 other people in real life who can program (fo real!), only 1 of which is not a relative of mine or my parents' friend. he's my employer.
23:47:53 <copumpkin> :o
23:48:40 <merehap> I know about a hundred people who claim to be able to program, and perhaps 4 that actually can...
23:49:04 <medfly_> hmm
23:49:19 <merehap> that's M$ for you :)
23:49:21 <medfly_> I'm actually assuming they know how to program, I don't know that for sure.
23:49:45 <merehap> nah, reading over their code is enough to disavow me of that notion
23:50:31 <copumpkin> oh wow, that Paul Homer dude has written books
23:50:38 <copumpkin> I guess cantor was wrong after all
23:51:43 <dolio> Books on what?
23:52:05 <merehap> the football player at u of washington?
23:52:13 <merehap> that's all google is returning...
23:53:40 <copumpkin> http://stores.lulu.com/paul_homer
23:53:50 <dolio> Presumably it's not a book on "my misunderstanding of how to properly apply diagonalization to some structure proves that there's no correct way to do it."
23:53:56 <copumpkin> they're available as free pdfs too
23:54:48 <napping> dolio: that does seem to be a popular sort of claim
