00:00:27 <yrlnry> I did not expect that this would be a new idea.  But it does make me feel that I have finally arrived, monadwise.
00:00:47 <kmc> very nice :)
00:01:03 <yrlnry> Thanks.
00:01:12 <ezyang> Possibly more contrived example? http://pastebin.com/m6a058cff
00:01:17 <kmc> QM is not really like computing with probability distributions, just seemed similar enough to mention
00:01:47 <kmc> ezyang, what does the return value of "search" mean?
00:02:00 <ezyang> kmc: That's why it feels contrived
00:02:13 <yrlnry> Regrettably there is no way in H98 to define a monad with a typeclass restriction on it.  I would like to say that ProbDist p a is a monad only when (Eq a), but no.
00:02:13 <ezyang> Ok, I'm going to throw out this example and do a game tree
00:02:15 <kmc> well... if you're designing this thing you probably have a non-contrived use in mind
00:02:29 <kmc> yrlnry, indeed.  did you see rmonad on hackage?
00:02:56 <ezyang> kmc: Yeah.  Constraint search.
00:03:06 <yrlnry> Yes, people gave me that and some other references a couple of days ago when i complained about not being able to create a set monad.
00:03:09 <yrlnry> Thanks very much.
00:03:22 <kmc> cool
00:03:27 <napping> hmmhmhmm
00:03:56 <napping> what does it take to make  \a b -> mapMaybe id (unionWith f a b) associative?
00:04:30 <kmc> for arbitrary f?
00:04:32 <napping> wait, that doesn't even work, does it
00:04:48 <kmc> :t \a b -> M.mapMaybe id (M.unionWith ?f a b)
00:04:49 <lambdabot> forall b k. (?f::Maybe b -> Maybe b -> Maybe b, Ord k) => M.Map k (Maybe b) -> M.Map k (Maybe b) -> M.Map k b
00:07:00 <napping> I need to put everything into maybe, I think
00:07:46 <BMeph> yrlnry: Also, you sound like you'd get a kick out of Dan "sigfpe" Piponi's blog - just search for sigfpe. :)
00:08:09 <yrlnry> BMeph:  You are quite right.  I'm already a regular reader.
00:08:13 <yrlnry> Thanks!
00:09:48 <BMeph> yrlnry: Yep. Many of the things you mentioned, he's covered, so I thought you'd like the blog. And, you do... ;)
00:14:46 <yrlnry> Oh, did he already do the probability monad?
00:14:51 <yrlnry> I eithe rmissed tha tor forgot it.
00:14:59 <yrlnry> I either missed that or forgot it.
00:47:06 <tehgeekmeister> how easy/difficult would it be to cross compile happstack for ubuntu server 9.10 64 bit from a desktop ubuntu 9.10 32 bit system?
00:54:17 <tehgeekmeister> (or any other app/package on ghc in general)
00:56:21 <Beelsebob> tehgeekmeister: ghc doesn't support cross compiling at all, so... very difficult I would imagine
00:56:24 <eivuokko> Impossible, there's no cross-compiling afaict.
00:56:35 <tehgeekmeister> hmph.
00:56:43 <tehgeekmeister> okay.
01:01:26 <sergdf> is there a way to grab a member of an ADT without using pattern matching? say I have a type "data RGB = RGB Int Int Int", and a list :: [RGB], and i want to get a list of just the red component. perhaps by mapping some function over the list?
01:01:49 <sergdf> never mind, i just realized i could easily write that
01:02:08 <Beelsebob> red (RGB r _ _) = r; map red list
01:02:21 <sergdf> yeah, no kidding
01:06:31 <kmc> data RGB = RGB { red, green, blue :: Int }
01:06:33 <kmc> map red mylist
01:06:51 <kmc> or
01:06:57 <kmc> map (\(RGB r _ _) -> r) mylist
01:17:57 <luite> aargh I hate perl :(
01:21:54 <vy> I have a small DSL "(rssP < 1024) `andP` (flagsP (==) 0)" which I want to read from a file. How can I read such Haskell expressions from a string?
01:25:52 <Lemmih> vy: You want to read and evaluate it?
01:26:01 <vy> Lemmih: Yup.
01:26:19 <Lemmih> vy: Don't. That's very difficult to get working right.
01:26:59 <vy> Lemmih: Should I make shell script wrapping ghci around my code instead?
01:27:33 <Lemmih> vy: If that suits your needs, sure.
01:33:25 <kmc> vy, look at the package "hint" on Hackage
01:33:30 <kmc> it's not *too* hard
01:33:57 <kmc> examples: http://code.haskell.org/hint/devel/examples
01:34:26 <kmc> you still might be better off with a script wrapping ghc, ghc -e, or ghci
01:34:32 <Lemmih> kmc: Ten bucks says he'll shoot himself in the foot.
01:34:34 <kmc> (the script could be written in Haskell as well, if that suits your purpose)
01:34:39 <kmc> Lemmih, *shrug*
01:34:45 <kmc> you've had bad experiences with hint?
01:35:18 <kmc> vy, you can look at mueval as well
01:36:22 <kmc> option the nth: convert your eDSL into a non-embedded DSL, optionally with an eDSL frontend
01:36:38 <vy> non-eDSL?
01:37:17 <kmc> yeah
01:42:58 <vy> What's wrong with this fn sig "(>?)    :: (Ord a) => (PSField -> a) -> a -> PSField -> Bool" that ghc complains that "Occurs check: cannot construct the infinite type: a = PSField -> a" and "When generalising the type(s) for `>?'".
01:45:55 <kmc> the signature is fine, i think
01:46:00 <kmc> can you hpaste the definition
01:48:12 <vy> kmc: hpaste.org appears to be down.
01:49:49 <vy> kmc: http://haskell.pastebin.com/m4bab975f
01:51:03 <kmc> okay so (>?) = liftOpP (>)
01:51:19 <kmc> can you load the working parts of the file in ghci, and ask the type of that expression?
01:51:37 <RyogaU> hi
01:51:41 <kmc> hi
01:52:55 <vy> kmc: Doh! Thanks.
01:54:41 <RyogaU> I'm fairly new to Haskell and I have a question about something I tried and I was hoping if one of you guys in this channel could help me out =)
01:54:50 <kmc> sure thing
01:56:42 <kmc> if there's code, you can upload it to haskell.pastebin.com
01:56:53 <kmc> usually we use hpaste.org but it's down now :/
01:57:16 <shambler> dpaste?
01:57:27 <shambler> http://dpaste.com/
01:58:20 <RyogaU> oh well
01:58:32 <RyogaU> I copied everything in codepad now
01:58:48 <vy> http://pastie.org/l/haskell appears to be cool as well.
01:59:21 <kmc> ah i like codepad
01:59:28 <kmc> that's the one i was looking for actually
01:59:32 <kmc> anyway they all do the same thing :)
01:59:39 <RyogaU> so I hope you don't mind (altough it won't compile there because it's only a module I was creating that produces this error and I'm missing a "main" ;D)
01:59:49 <RyogaU> yeah they do ;D
02:00:31 <RyogaU> http://codepad.org/AvRKf7cJ
02:00:45 <RyogaU> oh well, the comment was for nothing, the error shows up anyway
02:01:06 <RyogaU> if I remove the "import IO" or anything I try to import, it works just fine
02:01:25 <kmc> RyogaU, put your import all the way in the left column
02:01:42 <RyogaU> indent.error?
02:01:49 <RyogaU> hmm
02:01:50 <kmc> typically we would just say "module ExtendedEuclideanAlgorithm where"
02:02:09 <RyogaU> yeah I wasn't sure what I like better so I was trying both styles of typing it
02:02:27 <kmc> the "import" is in the same group of syntactic elements as your "data" and "instance"
02:02:38 <RyogaU> I see
02:02:47 <kmc> the "where" in a module line scopes over the whole file, iirc
02:03:55 <Saizan> it does
02:04:25 <Saizan> if you put import there you've to align all the rest to it
02:05:45 <napping> vy: It's probably better to write a little parser for your little DSL
02:05:46 <RyogaU> ah so the first line specifies where I need to align the rest of the module?
02:06:15 <Heffalump> yep
02:06:56 <RyogaU> Wow, didn't know that ... I really didn't recall reading anything about alignment of lines at all
02:07:02 <RyogaU> is there more I need to know about that?
02:07:14 <kmc> RyogaU, well, Haskell has whitespace-sensitive syntax in general
02:07:24 <kmc> though there is always an equivalent form which is not sensitive to whitespace
02:07:42 <napping> It's called "layout" in the standard
02:08:02 <kmc> RyogaU, the basic rule is this:
02:08:22 <kmc> it applies to four keywords: let, where, do, of
02:08:46 <RyogaU> oooh, okay!
02:08:54 <kmc> if the next token after one of those is not {, layout applies
02:09:25 <kmc> in that case you get an invisible { and the parser remembers the column of that first token after the keyword
02:10:22 <kmc> any subsequent lines that start at the same column are additional elements in the block, i.e. they get separated by invisible ;
02:10:24 * hackagebot upload: hemkay-core 0.1.0 - A device independent module music mixer (GergelyPatai)
02:10:26 * hackagebot upload: hemkay 0.2.0 - A module music mixer and player (GergelyPatai)
02:10:36 <RyogaU> yeah, I see that now
02:10:36 <kmc> any line that starts to the left closes the block, like }
02:10:49 <kmc> any line that starts to the right of the remembered column continues the line above it
02:10:52 <RyogaU> okay =) thanks!
02:11:11 <kmc> it's a little complicated to state but hopefully intuitive
02:11:20 <kmc> just remember that if you have trouble you can always put in the braces and semicolons yourself
02:11:20 <RyogaU> no it's alright
02:11:33 <RyogaU> it makes sense in the context of C in which Haskell was created so, it's fine =)
02:11:44 <RyogaU> yeah you can =)
02:11:47 <kmc> hmm i don't follow but, okay
02:11:59 <copumpkin> context of C?
02:12:25 <kmc> haskell is a standardized language, it was created using mailing lists and whiteboards and coffee
02:12:37 <kmc> there was an early haskell implementation in C but iirc, the first implementation was in Lazy ML
02:12:41 <luite> ah this is better, I replaced the perl flymake script with a haskell program :)
02:13:18 <RyogaU> yeah I meant if you consider in which language Haskell was created in
02:13:26 <kmc> English, i believe
02:13:27 <copumpkin> ML?
02:13:39 <copumpkin> C was definitely not a concern
02:13:41 <kmc> at least i think the canonical version of the report is in English.  i'm sure it's been translated
02:13:43 <copumpkin> hugs is in c
02:14:14 <napping> hmm, wasn't it lazy ml?
02:14:32 <RyogaU> well, anyway, thanks =)
02:14:49 <copumpkin> :)
02:14:50 <kmc> maybe it hasn't been translated :/
02:15:59 <kmc> meh
02:16:22 <napping> HBC compiler in LML, and Yale in Common Lisp, that was it
02:16:52 <kmc> neither of which is the language in which "Haskell was created"
02:17:24 <kmc> hmm the highest-usercount non-English Haskell channel is #haskell.cz
02:17:29 * kmc is surprised
02:17:33 <napping> and GHC was written in Haskell
02:18:00 <Cale> The original Haskell was created in the molecular language of DNA.
02:18:22 <kmc> wow, they have a Czech translation of LYAH
02:18:27 <kmc> Naučte se Haskell!
02:18:56 <kmc> google says "Learn to Haskell!"
02:21:34 <kmc> anyway i cannot find a copy of the Report in any language other than English
02:22:35 <koeien> that would introduce inconsistencies
02:24:05 <kmc> so i maintain Haskell was created mostly in English, with small parts in BNF and Haskell (the syntax of the layout desugarer of 9.3 looks suspiciously familiar)
02:24:43 <kmc> oh and of course the Prelude is codified and written in Haskell, as are various desugarings
02:25:17 <kmc> koeien, hopefully not; it could be a good check on whether your specifications are precise. but anyway you can designate one language as canonical
02:25:49 <koeien> what is the benefit?
02:26:08 <kmc> the benefit of translating a document is that more people can read it
02:26:32 <koeien> if they want to use GHC, they still have to speak English for (e.g.) the user manual
02:26:47 <kmc> and that could be translated as well
02:27:21 <kmc> and the various natural-language strings in GHC
02:27:49 * koeien can't wait until he sees 'Achtung: Fehler in GHC runtime.'
02:30:50 <kmc> the Report is especially important, as it's a precise, authoritative statement of the language
02:31:49 <kmc> it packs a lot of information into relatively little prose, which could compound difficulties for non-native speakers, and for the machine translation tools they might want to use
02:32:01 <kmc> although Google is getting scarily good at idiomatic translation of technical terms
02:42:22 <Saizan> one day they'll find an AI hidden in their servers
02:42:43 <copumpkin> zomg
02:43:28 <kmc> you can't, like, own a god
02:57:02 <merehap> is there a good reason why read 3 :: Rational doesn't work?
02:57:18 <c_wraith> 3 isn't a string
02:57:22 <Saizan_> > show (3 :: Rational)
02:57:23 <lambdabot>   "3 % 1"
02:57:29 <merehap> sorry
02:57:34 <merehap> read "3" :: Rational
02:57:35 <Saizan_> > read "3 % 1" :: Rational
02:57:36 <lambdabot>   3 % 1
02:57:52 <merehap> it seems like a major loss of generality
02:58:04 <merehap> read "3" :: Float works, for example
02:58:22 <c_wraith> read is just a hack, anyway.
02:58:36 <merehap> even though the more conventional form is read "3.0" :: Float
02:58:45 <merehap> hm
02:59:20 <Cale> > read "3" :: Rational
02:59:21 <lambdabot>   * Exception: Prelude.read: no parse
02:59:29 <merehap> so it is right that there is no polymorphic method for reading a num type?
02:59:41 <Cale> Right.
02:59:45 <Saizan_> > readFloat "3" :: Rational
02:59:46 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
02:59:46 <lambdabot>         against inferred t...
02:59:53 <merehap> I mean in a moral sense, not a technical sense
03:00:01 <Heffalump> > (fromInteger . read) "3" :: Rational
03:00:02 <lambdabot>   3 % 1
03:00:22 <merehap> if read is just a hack anyway
03:00:27 <Cale> Well, yeah, you could do like Heffalump shows and read an Integer
03:00:53 <merehap> well thats what I ended up doing
03:00:58 <Cale> Integers are the only thing you can guarantee will correspond to members of a Num type in general, of course.
03:01:02 <merehap> but then you can't read floating point types
03:01:04 <Heffalump> well, that's a polymorphic method for reading a Num type :-)
03:01:15 <Saizan_> Num has no operation to construct a fractional value, anyhow
03:02:05 <merehap> hm, I see, I was just frustrated when I couldn't make the RPN calculator that I posted to rosetta code read arbitrary num types
03:02:29 <Heffalump> I'm actually strill srtuggling to find a clean way to read a rational from decimal notation
03:02:49 <Cale> But yeah, I agree that read instance for Rational is a bit broken. It should at least parse integer and fractional literals with the same syntax as in Haskell.
03:03:00 <Heffalump> I think because there's no good way to convert floats into rationals
03:03:24 <Cale> Well, there's realToFrac
03:03:29 <Heffalump> which in one way is silly, as all (non-exceptional) floats are representable as rationals
03:03:38 <Heffalump> oh yes
03:03:40 <Cale> :t realToFrac
03:03:42 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
03:03:45 <Cale> But you lose precision
03:03:51 <merehap> realToFrac 3.1415
03:03:55 <Heffalump> > (realToFrac . readFloat) "3.0"
03:03:56 <lambdabot>   No instance for (GHC.Real.Real [(a, GHC.Base.String)])
03:03:57 <lambdabot>    arising from a us...
03:04:31 <Saizan_> > realToFrac (read "3.0" :: Float) :: Rational
03:04:32 <lambdabot>   3 % 1
03:04:35 <merehap> that's reasonable though
03:04:39 <Cale> > 3.00000000000000000000000000000000000000000000000000000000000000000001 :: Rational
03:04:41 <lambdabot>   300000000000000000000000000000000000000000000000000000000000000000001 % 100...
03:04:46 <Cale> > 3.00000000000000000000000000000000000000000000000000000000000000000001 :: Float
03:04:46 <merehap> ha
03:04:46 <Saizan_> > realToFrac (read "3.0" :: Float) :: Float
03:04:47 <lambdabot>   3.0
03:04:47 <lambdabot>   3.0
03:04:54 <merehap> keep trying :)
03:05:05 <Heffalump> ok, Saian wins, but the type signature is annoying
03:05:32 <Heffalump> Sai*z*an
03:05:35 <Saizan_> ?type readToFrac . read
03:05:36 <lambdabot> Not in scope: `readToFrac'
03:05:46 <Heffalump> @type readToFrac . read
03:05:48 <lambdabot> Not in scope: `readToFrac'
03:05:50 <Heffalump> bah
03:05:52 <Saizan_> ?type realToFrac . read
03:05:53 <lambdabot> forall b. (Fractional b) => String -> b
03:05:58 <Heffalump> oh, right :-)
03:06:02 <Saizan_> defaulting to Double there?
03:06:05 <Heffalump> isn't it ambiguous, or does defaulting work out?
03:06:07 <Heffalump> I guess so.
03:06:12 <c_wraith> wait, you can have a Rational literal in decimal form?  How does GHC parse literals?
03:06:25 <Heffalump> c_wraith: the point is that you can't without conversion
03:06:34 <Cale> c_wraith: By treating them as rationals, and applying fromRational to them
03:06:37 <Heffalump> but obviously it does make sense, since the denominator would just be 10^n
03:06:44 <Heffalump> (and then could be simplified)
03:06:49 <Cale> :t fromRational
03:06:49 <c_wraith> thanks, Cale
03:06:50 <lambdabot> forall a. (Fractional a) => Rational -> a
03:06:57 <Cale> :t 3.3461
03:06:58 <lambdabot> forall t. (Fractional t) => t
03:07:35 <kmc> :t pi
03:07:36 <lambdabot> forall a. (Floating a) => a
03:07:41 <Cale> Which incidentally is why literals with very large exponents can cause problems
03:07:47 <Heffalump> c_wraith: oh, I see, you meant real literals. Sorry.
03:07:55 <Heffalump> as opposed to ones being read
03:07:58 <Cale> > 1e1000000000000000 :: Float
03:08:03 * kmc doesn't like the type of pi
03:08:04 <lambdabot>   mueval: ExitFailure 1
03:08:17 <kmc> sure, pi is not equal to any rational number.  it's also sure as hell not equal to any Double!
03:08:30 <Saizan_> > pi :: Double
03:08:31 <lambdabot>   3.141592653589793
03:08:34 <kmc> > pi :: CReal
03:08:36 <lambdabot>   3.1415926535897932384626433832795028841972
03:08:38 <merehap> it is now :)
03:08:50 <Cale> ^^ It tried to construct a very large Rational (and as a consequence, a very large integer) there, while compiling the 1e100...00
03:09:00 <c_wraith> Eh.  You just have to pretend that Doubles represent approximate values, rather than exact ones.
03:09:10 <Saizan_> 15 decimal digits should be enough for everyone
03:09:31 <merehap> 16k of ram should be good enough for anyone
03:09:38 <merehap> everyone*
03:09:42 <kmc> > let x = 0/0 in x == x
03:09:43 <lambdabot>   False
03:09:50 <kmc> > let x = 0/0 in x /= x
03:09:52 <lambdabot>   True
03:10:00 <merehap> how does that work?
03:10:01 <kmc> > let x = 0/0 in compare x x
03:10:02 <lambdabot>   GT
03:10:08 <__me> @src (++)
03:10:08 <kmc> > let x = 0/0 in x > x
03:10:08 <lambdabot> []     ++ ys = ys
03:10:09 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
03:10:09 <lambdabot> -- OR
03:10:09 <lambdabot> xs ++ ys = foldr (:) ys xs
03:10:10 <lambdabot>   False
03:10:17 <kmc> > let x = 0/0 in (compare x x, x > x)
03:10:18 <lambdabot>   (GT,False)
03:10:24 <Cale> I wonder all the time whether there's an implementation of computable reals that's actually anywhere near the practicality of Doubles.
03:10:26 <kmc> surprise your friends! confound your enemies!
03:10:52 <merehap> well it confounded me
03:10:56 <Cale> CReal has the problem that numbers get slower as they are built up from more and more complicated computations, even if it's all integers
03:11:00 <merehap> but lets me friends anyway
03:11:07 <Cale> > sum [1..1000] :: CReal
03:11:11 <lambdabot>   mueval-core: Time limit exceeded
03:11:15 <merehap> wow
03:11:34 <kmc> merehap, 0/0 is an unsigned Not-a-Number value
03:11:34 <dschoepe_> > let x = 0/0 in [x == x, x < x, x > x]
03:11:36 <lambdabot>   [False,False,False]
03:11:38 <kmc> > 0/0
03:11:39 <lambdabot>   NaN
03:11:50 <kmc> merehap, as opposed to 1/0 and -1/0, which are positive and negative infinity resp.
03:11:59 <kmc> > sort [1/0, -1/0]
03:12:00 <lambdabot>   [-Infinity,Infinity]
03:12:18 <kmc> merehap, NaN `op` NaN = False, for any comparison op
03:12:40 <merehap> ah, makes sense
03:12:48 <Cale> So you have fast numbers which satisfy almost no nice properties (except for commutativity), or impractically slow but computationally perfect numbers
03:12:54 <Saizan_> > compare (0/0) (0/0) -- this doesn't make much sense, but heh
03:12:55 <lambdabot>   GT
03:12:57 <kmc> so says IEEE 754 iirc
03:13:07 <Cale> Maybe we need some arbitrary finite precision arithmetic.
03:13:26 <Cale> It still has no nice properties, but you can do something about it when you run into problems...
03:13:42 * kmc would like compare :: (Ord a) => a -> a -> Maybe Ordering
03:14:04 <Saizan_> maybe we could use a first order representation for CReals so we can simplify them
03:14:29 <Cale> Yeah, some bag of tricks for representing simple computable reals of various forms
03:14:38 <merehap> it seems like there would many be cases that ops on "computationally perfect" numbers would return bottom rather than just be slow
03:14:40 <kmc> what about lazy sequences of rationals?
03:14:58 <Cale> merehap: Yes, but continuous operations should be fine.
03:15:28 <Cale> merehap: It's discontinuous functions which are not computable, like equality testing or order comparisons.
03:15:48 <merehap> ah, due to lazy evaluation, i assume
03:15:57 <Cale> No, just the nature of computation.
03:16:27 <kmc> every computable real number has a productively computable infinite sequence of rational approximations, correct?
03:16:33 <Cale> yeah
03:16:44 <kmc> (i'm not sure "productively computable" is a real term but it seemed to need some qualification)
03:17:01 <merehap> well, I meant as far as continuous functions are concerned, lazy evaluation aids in arbitrary precision
03:17:03 <Cale> For each k, you can compute a rational within 1/(2^k) of the computable real
03:17:16 <Cale> merehap: well, yeah, or just functions
03:17:46 <Cale> You can use lazy lists, or functions of a parameter which encodes the precision.
03:17:51 <merehap> but as you mentioned, arbitrary precision doesn't help in an equality test, just so I'm clear...
03:19:02 <kmc> the equality relation on computable reals is uncomputable
03:19:03 <Cale> Yeah, given a computable function which takes an integer precision and produces a rational approximation to a real number, there's no way to know whether the rational approximation really approaches, say, 0, or if it just gets really close and stops getting closer at some point.
03:19:04 <Saizan_> you can check that they are equal up to some precision, but at least you don't have holes in your representation making equal things unequal just because of some changed association of operators etc..
03:19:50 <Cale> Well -- you can tell when it fails to be 0
03:19:57 <kmc> it's co-RE
03:20:01 <Cale> But it takes an arbitrarily long time to do so
03:20:05 <kmc> you can enumerate the pairs of numbers that are not equal
03:20:13 <Cale> and if it is 0, there's no way to verify that
03:21:13 <kmc> > (2 :: CReal) == 1 + 1
03:21:15 <lambdabot>   True
03:21:30 <merehap> meaning what?
03:21:35 <Cale> I think the Eq instance cheats and compares to within some finite precision.
03:21:42 <merehap> ah
03:21:46 <Baughn> > (3 :: CReal) = 1.5 + 1.5
03:21:47 <lambdabot>   <no location info>: parse error on input `='
03:21:50 <Baughn> > (3 :: CReal) == 1.5 + 1.5
03:21:51 <lambdabot>   True
03:22:09 <Baughn> > (3 :: CReal) == 1+1+1
03:22:10 <lambdabot>   True
03:22:12 <Cale> > 0 == 0.000000000000000000000000000000000000000000000000000001 :: CReal
03:22:13 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
03:22:13 <lambdabot>         against infe...
03:22:20 <Cale> > 0 == (0.000000000000000000000000000000000000000000000000000001 :: CReal)
03:22:21 <lambdabot>   True
03:22:27 <Cale> ^^ fail
03:22:33 <merehap> there it is
03:22:37 <kmc> > (1 :: CReal) == iterate ((+0.9).(*0.1)) 0.9
03:22:38 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
03:22:39 <lambdabot>         against infe...
03:22:45 * hackagebot upload: primitive 0.2 - Wrappers for primitive operations (RomanLeshchinskiy)
03:22:57 <kmc> > (1 :: CReal) == fix ((+0.9).(*0.1)) 0.9
03:22:58 <lambdabot>   No instance for (GHC.Real.Fractional
03:22:58 <lambdabot>                     (t -> Data.Number....
03:24:05 <sohum> > fix ((+0.9) . (*0.1))
03:24:09 <lambdabot>   mueval-core: Time limit exceeded
03:24:17 <sohum> :t fix ((+0.9) . (*0.1))
03:24:18 <lambdabot> forall a. (Fractional a) => a
03:25:22 <kmc> > (1 :: CReal) == sum $ map ((2^^).negate) [1..]
03:25:23 <lambdabot>   Couldn't match expected type `Data.Number.CReal.CReal'
03:25:23 <lambdabot>         against infe...
03:25:29 <sohum> > let (x :: CReal) = 0.9 + (0.1 * x) in 1 == x
03:25:33 <lambdabot>   mueval-core: Time limit exceeded
03:25:42 <Cale> sohum: The only functions for which fix will find a defined fixed point are those which don't send undefined to itself.
03:25:44 <Saizan_>  > (1 :: CReal) == (sum $ map ((2^^).negate) [1..])
03:25:50 <Saizan_> > (1 :: CReal) == (sum $ map ((2^^).negate) [1..])
03:25:56 <lambdabot>  Terminated
03:26:11 <sohum> Cale: oooh, that's a nice statement of the property, thanks!
03:26:11 <merehap> sum (take 100 (iterate (/2) 1)) == (2 :: CReal)
03:26:26 <sohum> Cale: on reflection it should've been obvious, but... :P
03:26:32 <merehap> > sum (take 100 (iterate (/2) 1)) == (2 :: CReal)
03:26:35 <kmc> Cale, because they have _|_ as a fixed point, and it's the least value in the domain?
03:26:37 <lambdabot>   False
03:26:40 <Cale> kmc: right
03:26:50 <kmc> Cale, this principle i like to summarize as "ask a stupid question, get a stupid answer"
03:27:08 <kmc> it's funny though that "fix id" is an error
03:27:27 <kmc> > fix (id :: () -> ())
03:27:32 <lambdabot>   mueval-core: Time limit exceeded
03:27:34 <Baughn>  > sum . inits (iterate (/2) 1)
03:27:46 <Baughn> > sum . inits (iterate (/2) 1)
03:27:47 <Cale> Well, it's _|_ because that's the least fixed point as always :)
03:27:48 <lambdabot>   [0.0,1.0,1.5,1.75,1.875,1.9375,1.96875,1.984375,1.9921875,1.99609375,1.9980...
03:28:10 <merehap> Baughn: still false in the end for CReals, though...
03:28:18 <Baughn> > sum . inits (iterate (/2) 1) !! 500
03:28:19 <lambdabot>   Precedence parsing error
03:28:19 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.List.!!'...
03:28:23 <Cale> Now all we need is a maximal fixed point operator :)
03:28:24 <Baughn> > (sum . inits (iterate (/2) 1)) !! 500
03:28:25 <lambdabot>   2.0
03:28:30 <sohum> basically CReal + lazy evaluation isn't enough to simulate limits, is what I'm getting from this
03:29:08 <Baughn> > length $ takeWhile (/= (2.0 :: CReal)) $ sum . inits (iterate (/2) 1)
03:29:12 <lambdabot>   mueval-core: Time limit exceeded
03:29:19 <Baughn> Aww
03:29:29 <Saizan_> Cale: if only our domains had a Top :)
03:29:30 <merehap> ha
03:29:40 <merehap> a Top?
03:29:44 <Cale> Heh, I wonder if you could define a maximal fixpoint operator using unamb for some algebraic types.
03:29:46 <kmc> Cale, with a co-recursive definition presumably :)
03:30:45 <Baughn>  > using unamb
03:30:49 <Baughn>  > unamb
03:30:51 * Baughn shudders
03:30:57 <kmc> :t unamb
03:30:58 <Saizan_> merehap: a value that's greater than all the others wrt the definedness relation
03:31:00 <lambdabot> Not in scope: `unamb'
03:31:03 <Cale> :t using
03:31:04 <lambdabot> forall a. a -> Strategy a -> a
03:31:12 <Baughn> kmc: unamb :: a -> a -> a
03:31:16 <kmc> yeah
03:31:42 <BrianB04_> Morning all, I have sort of a silly question: When pattern matching against a list, why is an empty list [], but looking at the contents of a list uses ()?
03:31:44 <Saizan_> merehap: then you could find the greatest fixed point of f using f (f (f ... (f Top)))
03:31:45 <kmc> computes join on the domain lattice?
03:31:55 <kmc> BrianB04_, the parens are just for grouping
03:31:55 <Cale> BrianB04_: () isn't a list
03:32:06 <kmc> there are a few contexts where they aren't required
03:32:09 <merehap> looks like I might have some studying to do, then
03:32:14 <Cale> BrianB04_: Or you mean why do you write parens around (x:xs)?
03:32:14 <kmc> the pattern for a non-empty list is a:b
03:32:16 <sohum> > 5:[1,23,4]
03:32:17 <lambdabot>   [5,1,23,4]
03:32:33 <kmc> because the two constructors of the list type are named [] and (:)
03:32:44 <Cale> BrianB04_: it's just that f x:xs means (f x) : xs because of precedence
03:32:55 <Cale> So you need parens to overcome that
03:32:55 <kmc> > (\[x,y,z] -> x+y-z) [2,3,4]
03:32:57 <lambdabot>   1
03:33:01 <BrianB04_> Cale: Yes, why do you write parens around (x:xs) or (x). Oh, I get it. I'm used to erlang where you do [] for everything.
03:33:08 <kmc> BrianB04_, ^^^^ matching a non-empty list with []
03:33:28 <kmc> > case "abc" of x:[y,z] -> z
03:33:29 <lambdabot>   'c'
03:33:58 <kmc> BrianB04_, [a,b] is sugar for a:[b], and [a] is sugar for a:[]
03:34:01 <sohum> BrianB04_: if you know your list has, say, exactly three elements, you can pattern match in [a,b,c]. but [a:b] doesn't make sense - unless it's a list of one element, which is also a list
03:34:14 <kmc> :t \[a:b] -> ()
03:34:15 <lambdabot> forall t. [[t]] -> ()
03:34:20 <kmc> you don't need the parens there
03:34:27 <kmc> and it is indeed a function of lists-of-lists
03:34:52 <kmc> > (\[a:b] -> a) ["foo"]
03:34:54 <lambdabot>   'f'
03:34:54 <kmc> > (\[a:b] -> a) ["foo", "bar"]
03:34:56 <lambdabot>   * Exception: <interactive>:1:134-144: Non-exhaustive patterns in lambda
03:35:31 <merehap> > (\[a,b] -> a) ["foo", "bar"]
03:35:32 <lambdabot>   "foo"
03:36:02 <kmc> anyway it'd be poor form to write [a:b] instead of [(a:b)]
03:38:56 <Dresio> Hi guys
03:39:04 <Cale> Hello
03:40:03 <Cale> okay
03:41:55 <Saizan> if you had a bunch of threads reading and writing on some TVars, how'd you make so you could tell if they are all blocked?
03:42:23 <Saizan> (they can all block since they retry depending on what they find inside the variables)
03:43:16 <Baughn> Saizan: If they are all blocked simultaneously, the RTS will throw a fit and kill them.
03:43:38 <Baughn> Assuming nothing else is theoretically capable of unblocking them.
03:43:40 <Saizan> Baughn: the vars are references from other threads too
03:43:48 <Saizan> *referenced
03:44:09 <Saizan> well, a single controller thread, i'd say
03:44:24 <napping> If they are referenced from threads that are not blocked, then those threads might be able to fix things
03:44:30 <Baughn> Well, you can't really tell if they're all blocked.. why do you want to?
03:44:47 <napping> and otherwise the garbage collector will realize the threads are inaccessible
03:44:54 <Saizan> napping: yeah, in fact they will, the point is that they have to start fixing things only when we get to this point
03:45:09 <napping> well, may realize it. You are not guaranteed that any particular deadlock will be detected
03:45:18 <Baughn> ..I think you should probably not make your program do this.
03:45:52 <Saizan> Baughn: i've to model a set of agents that prune the domains of some variables in a constraint solving engine, though they might get stuck and i'd have to start doing some backtracking
03:45:57 <Baughn> Saizan: atomically blocks are supposed to be /atomic/; what you want seems to break that
03:46:16 <Saizan> yeah, i'm mostly evaluating if STM fits my needs
03:47:10 <Baughn> Saizan: Well, it's technically possible, but I don't think there's an exposed way to do it (safely); try #ghc?
03:48:12 <Saizan> (i guess i could encode it somehow in STM anyway, but i'm not sure that would turn out nicely)
03:48:26 <Baughn> Not really. Remember, STM blocks are /atomic/.
03:48:37 <Baughn> There's no way to write a value inside one and have anything else notice before it finishes.
03:49:02 <Saizan> i'd just have to make the retry something else that signals out that it blocked
03:49:24 <Saizan> "that the thread blocked"
03:49:31 <Baughn> Saizan: Unless you actually leave the atomically call, there's no way to signal out at all
03:49:39 <Saizan> Baughn: i know
03:50:07 <Baughn> And if you /do/, you have a race condition where it may leave the call, then your controller thread decides they're all blocked before it gets around to signalling that it's left it
03:50:57 <Saizan> leave which call?
03:53:14 <Saizan> i guess you could easily get a race condition where the controller sees all of them as blocked while in fact some thread is just restarting
03:53:37 <Baughn> Right
03:53:50 <Baughn> Which is inevitable no matter how you do it, really.
03:54:21 <Saizan> do you have a formal proof?:)
03:54:35 <Saizan> which assumptions are we using here?
03:54:59 <Baughn> Hm. Actually, I'm wrong.
03:55:02 <Baughn> let's see..
03:55:14 <Baughn> If you have a TVar Int representing the number of threads not blocked
03:55:48 <Baughn> Then you atomically $ modifyTVar _ pred before entering the main atomically block that might block
03:55:51 <SimonRC> ouch, abstraction inversion ;-)
03:55:59 <Baughn> And at the end of that block, modify it back
03:56:11 <Baughn> That way, you can stop being blocked and increment the counter, atomically
03:56:54 <Baughn> Although in this case there's a risk your controller will decide they're all blocked when they aren't, that's /inevitable/; they could all genuinely be inside the block and still be making progress
03:57:48 <merehap> guess we should give up and just go back to single thread programming...
03:57:57 <Baughn> Saizan: Hey, at least I'm not using a TChan to represent a mutex.
03:58:43 <Saizan> mh, i guess STM doesn't help me much here, i might as well just associate callbacks to IORefs or MVars
04:00:23 <Baughn> Saizan: STM is great when you use it right, but it's quite deliberately not observable in action. That's the /point/. ;)
04:01:34 <Saizan> it's great if it fits your needs, or if you want to use it as a building block for abstrations that fit your needs :)
04:02:31 <Baughn> On that note..
04:02:34 <Saizan> it's not an ultimately nice abstraction to describe concurrent processes, ime
04:02:40 <Baughn> Saizan: http://pastebin.com/m22563a6d <-- I've /got/ to rewrite this. ^^;
04:02:47 <Baughn> >_<;, more like
04:03:12 * Baughn stares at it again. Let's at least make sure it actually works.
04:04:08 <Baughn> Saizan: (Horrified yet?)
04:05:13 * Baughn should have used M.lookup, obviously. Oh well.
04:06:31 <kmc> hmm, how do TVar and TMVar relate?
04:06:46 <Baughn> TVar is to TMVar as IORef is to MVar
04:06:57 <Baughn> Or perhaps as IORef is to IORef (Maybe a)
04:07:02 <kmc> ah
04:07:21 <kmc> so TMVar has the empty/full semantics, with retry (rather than block)
04:07:21 <Baughn> TMVar is implemented using TVar, probably
04:07:28 <Baughn> Right.
04:07:33 <Baughn> Though retry /is/ block.
04:07:33 <kmc> and TVar is simply a mutable cell that can be used multiple times within an "atomically" block
04:07:39 <kmc> hmm, true
04:08:49 <Baughn> Actually, I would note be surprised at all if there is 'newtype TMVar a = TVar (Maybe a)' somewhere
04:08:55 <Baughn> With more constructors.
04:09:54 <Baughn> http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/src/Control-Concurrent-STM-TMVar.html#TMVar <-- Aha!
04:09:56 <increpare> newtype TMVar a = TMVar (TVar (Maybe a))
04:09:59 <increpare> snap : P
04:10:05 <increpare> heheh
04:12:37 <Saizan> Baughn: something for a FRP core?
04:13:02 <Saizan> the paste, i mean
04:13:21 <Baughn> Saizan: No. FRP code is about as convoluted, but it has a /reason/.
04:13:33 <Baughn> Anyway, you can't mix STM with unsafePerformIO
04:13:36 <Baughn> Mustn't.
04:14:02 <zygoloid> that''s a spanking offence :)
04:14:03 <merehap> sounds like a challenge
04:14:32 <increpare> Baughn: what was this paste?
04:14:46 <burp> is there a cabal configuration option to make it build shared binaries in ~/.cabal/bin ?
04:14:52 <Baughn> merehap: You can't have nested transactions (in one thread),so you'd have to do tricks with forkIO
04:15:07 <Baughn> increpare: Some code for my thesis. By far the worst bit of code in there, thankfully.
04:15:18 <increpare> Baughn: what's your thesis on?
04:15:46 <Baughn> increpare: Distributed filesystem. Oh, it's a MSc-level thesis, not..
04:16:19 <Baughn> So I don't actually have to be all that original. Trying to make it user-friendly apparently counts. :P
04:16:25 <burp> "shared: True" makes it build shared libraries
04:16:30 <Baughn> (Says sad things about the other ones..)
04:16:34 <b0fh_ua> Hi there!
04:16:48 <Baughn> burp: And /nothing/ makes it build executables using those shared libraries. Makes things a bit pointless.
04:16:55 <b0fh_ua> Can somebody please help me with resolving and fixing the following error: http://pastebin.com/d828e4e1 ?
04:17:07 <Baughn> ghc -dynamic works, though
04:18:06 <b0fh_ua> I don't really understand why doesn't it like acc ++ [x]
04:18:23 <increpare> b0fh_ua: what's maxsequence meant to do?
04:18:23 <burp> hm ok
04:19:11 <b0fh_ua> increpare: it should find out the maximum ascending subsequence in a sequence
04:19:32 <increpare> what's acc?
04:19:39 <increpare> oh oops
04:19:41 <increpare> variable : P
04:19:47 <b0fh_ua> increpare: accumulator for fold )
04:19:57 <increpare> acc:[x] doesn't work?
04:20:06 * hackagebot upload: GPipe 1.1.3 - A functional graphics API for programmable GPUs (TobiasBexelius)
04:20:13 <b0fh_ua> yes, same error (but with : instead of ++)
04:20:20 <Saizan> b0fh_ua: rewrite ( snd . last acc == (snd x) + 1 )  as ( (snd . last) acc == snd x + 1 )
04:20:29 <jlouis> b0fh_ua: what is the type of acc? what is the type of x?
04:20:37 <Saizan> acc:[x] would work only if acc was of the same type of x
04:20:42 <jlouis> I think figuring that out solves the problem
04:20:47 <b0fh_ua> Saizan: wow
04:21:00 <increpare> ah yes: should have spotted that a mile away : P
04:21:24 <b0fh_ua> awesome, thanks
04:21:35 <b0fh_ua> Saizan: what did I do in wrong way?
04:22:09 <Saizan> b0fh_ua: "snd . last acc" parses as "snd . (last acc)"
04:22:11 <b0fh_ua> I assumed that (snd . last) acc is the same as snd . last acc
04:22:21 <Saizan> b0fh_ua: no, it isn't
04:22:22 <increpare> b0fh_ua: oh no! oh no it's not!
04:22:33 <Saizan> b0fh_ua: prefix function application has the highest precedence
04:23:50 <b0fh_ua> Saizan: but last acc will return last item from list, and calling snd on that item will return second item from tuple?
04:24:04 <b0fh_ua> ah
04:24:04 <Saizan> b0fh_ua: which is also why you can drop the parentheses from around "snd x"
04:24:23 <Saizan> this is way before evaluation
04:24:56 <b0fh_ua> Saizan: I still don't understand what is the difference in returning value for (snd . last) acc and snd . last acc
04:25:19 <Berengal> b0fh_ua: snd . last acc == snd . (last acc)
04:25:27 <Saizan> b0fh_ua: the difference is how the compiler interprets those expressions to be pranthesized
04:25:52 <nolrai_P> how do you tell ghc to ignore a library?
04:25:59 <b0fh_ua> voodoo
04:26:10 <Baughn> nolrai_P: Haskell package, or C library?
04:26:12 <Saizan> b0fh_ua: in the last one you're saying it to compose snd and (last acc), but (last acc) is not a function, so can't be composed
04:26:18 <nolrai_P> Haskell package
04:26:32 <Baughn> nolrai_P: -hide-package. Or use cabal, which takes care of this automatically.
04:26:34 <b0fh_ua> aha
04:26:42 <b0fh_ua> that makes sence, really
04:26:48 <b0fh_ua> but the error is a bit strange
04:27:07 <Saizan> b0fh_ua: while with (snd . last) acc you're saying it to compose snd and last and apply the result to acc
04:27:24 <nolrai_P> Baughn: hmm cabal doesn't seem to be, I was using mtl-tf, but need monads-tf, and now ghc gets confused.
04:27:56 <b0fh_ua> okay, I've got that
04:27:59 <b0fh_ua> thanks a lot!
04:28:10 <Baughn> nolrai_P: With cabal, you explicitly name all the packages you use. That equates to passing -hide-all-packages and lots of -package foo to ghc.
04:28:33 <Baughn> nolrai_P: You could also use the PackageImports ghc extension, which makes things play well with ghci
04:28:53 <Baughn> nolrai_P: Basically, 'import "monads-tf" Control.Monad.State' or whatever
04:29:23 <Baughn> ..my files typically have a three-line list of extensions I'm using. :/
04:29:36 <hatNine> [HASKELL!]
04:31:24 <mreh> #haskell-blah is dead
04:31:27 <lunabot>  luna: parse error on input `|]'
04:31:48 <Baughn> lunabot: What.
04:32:01 <Saizan> #ty id
04:32:05 <lunabot>  forall a . a -> a
04:32:07 <chrisdone> [] 1
04:32:19 <Baughn> #haskell-blah is dead
04:32:20 <lunabot>  luna: parse error on input `|]'
04:32:22 <chrisdone> hm
04:32:30 <Baughn> ..where is it getting the |] from?
04:32:38 <nolrai_P> okay, I remeber there being some way to just run some comand by ghc, and have ghc never look a particular package again.
04:32:49 <Baughn> ghc-pkg hide mtl
04:32:55 <Saizan> it's spliced as [$haskell-blah| is dead |]
04:33:01 <zygoloid> Baughn: #foo bar is interpreted as , [$foo|bar |] iirc
04:33:09 <Baughn> I shee
04:33:23 <Saizan> nolrai_P: yeah, ghc-pkg hide
04:33:38 <nolrai_P> Saizan: thanks!
04:33:47 <mreh> i didn't mean to do that
04:34:02 <mreh> I was looking for a verdict on how best to make xmonad look nice
04:34:19 <mreh> is replacing metacity with xmonad the most popular solution?
04:34:37 <chrisdone> yeah, xmonad inside gnome is nice
04:34:42 <koeien> i don't use gnome
04:34:45 <koeien> although it would be nice
04:34:54 <ivanm> mreh: I doubt it
04:34:58 <mreh> but I need to cut down on the bloat
04:35:01 <Saizan> i just use lxpanel
04:35:10 <koeien> i use trayer, gmrun and lots of GTK / GNOME apps
04:35:14 <ivanm> people use xmonad on its own, xmonad with gnome, xmonad with kde, xmonad with xfce and xmonad with lxde
04:35:26 <ivanm> Saizan: eh, I like the autostart stuff in lxde
04:36:28 <koeien> i sometimes miss an applications menu. for example if i want to burn a cd
04:36:35 <luks> hi, does anyone know, how one can output margin signs from IBM code page 437?
04:36:38 <koeien> i don't know which app to use for that, so i have to guess
04:36:39 <luks> putStrLn reasonably gives ?'s for anything above 0x7F
04:36:43 <Saizan> ivanm: how do you set that up?
04:37:40 <ivanm> Saizan: have the apps you want autostarted in .config/autostart/<foo>.desktop and run lxsession when you log in (which occurs if you actually use lxde proper)
04:37:43 <Baughn> luks: GHC uses unicode. But the normal I/O system doesn't handle things right until you get to 6.12, so that might be an idea.
04:37:57 <Baughn> luks: Alternately, there are various utf-8 packages on hackage that will work on 6.10
04:37:58 <kmc> luks, if you can map them to Unicode codepoints, you can use utf8-prelude
04:38:14 <kmc> yeah what Baughn said
04:38:19 <ivanm> lxsession-edit can help you actually create the .desktop files
04:38:21 <Baughn> You will not, in any case, get codepage 437.. what still uses that?
04:38:55 <luks> thanks for the hints, i'll go check.
04:39:00 <kmc> oh man that's the codepage where 0x01 and 0x02 are smiley faces
04:39:15 <eivuokko> Is there really no Windows Service package yet? o.O
04:39:59 <ivanm> eivuokko: why should there be?
04:40:55 <Baughn> eivuokko: Haskell support on windows is horrid, mostly because not many windows users are interested in improving it. This falls into that area, so..
04:41:15 <kmc> i thought the Windows support was pretty good due to Microsoft patronage
04:41:28 <Baughn> Well, it /used/ to be.
04:41:35 <ivanm> kmc: actually, it isn't
04:41:44 <ivanm> IIRC, out of the big three GHC devs, only one uses windows
04:41:56 <Baughn> ..one os x, and one linux. That works out.
04:42:05 <Baughn> Or is it two linux?
04:42:27 <Baughn> kmc: GHC works well on windows. Haskell doesn't.
04:42:35 <Asztal> It doesn't help that building anything from source tends to be painful on windows :(
04:43:19 <eivuokko> Huh.  Anything is gross generalisation.  A lot of stuff is very easy to build in Windows.
04:43:48 <chrisdone> I switched from windows to ubuntu because it was a pain in the ass to build open source software
04:43:59 <koeien> chrisdone: you might argue that that's the fault of said OSS
04:44:33 <Baughn> koeien: With no equivalent of /usr/{include,lib} I doubt that
04:44:52 <eivuokko> ivanm, I'm trying to come up answer to that....  It's a thing I'd have supposed many people want, enough that someone had put some code into a package.
04:45:02 <koeien> Baughn: well, yeah, it's a completely different system. but then don't claim that you support it
04:45:14 <Baughn> koeien: Oh, I don't.
04:45:33 <koeien> me neither ;) depends on the situation of course
04:46:03 <koeien> but is Haskell on windows a problem then? i just it was pretty well supported
04:46:10 <koeien> s/just/thought
04:46:41 <ivanm> koeien: I'd argue its the fact that the development environment in unix-based OSs is easier
04:46:49 <eivuokko> GHC when you install it from binaries is well supported, Cabal is ok.  A lot of other stuff - random quality.
04:46:56 <koeien> ivanm: i do not think this is a "fact" at all
04:47:13 <Baughn> koeien: It's hard to get cabal-install working
04:47:30 <eivuokko> ivanm, that is very hard position to defend, imo.  It's subjective "I prefer", rather.
04:47:31 <koeien> Baughn: ah. aren't there binaries available?
04:47:49 <Baughn> koeien: There are, but that's not really the problem.
04:48:00 <Baughn> koeien: A lot of packages require a bash shell and whatnot
04:48:08 <ivanm> *shrug* compare how many libs have to be bundled with apps for windows
04:48:23 <Baughn> koeien: Also, the lack of /usr/{include,lib} makes anything that links with C a sheer hell to compile
04:48:30 <koeien> ivanm: at least they work, then. try to distribute a binary for "linux" sometime
04:48:39 <ivanm> Baughn: right, that was part of my point
04:48:43 <ivanm> koeien: why should I?
04:48:48 <ivanm> build it from source!
04:48:50 <Baughn> koeien: ..I've done that. It.. ack... my /braaains/!
04:48:59 * Baughn goes on a zombie rampage
04:49:04 <koeien> heh
04:49:19 <Baughn> I've done it, but not successfully. :/
04:49:27 <koeien> so lots of packages don't compile with cabal-install on windows, but cabal-install itself works?
04:49:36 <eivuokko> Mostly.
04:49:53 <eivuokko> It doesn't do access control-related things right at all.
04:49:59 * shambler failed to cabal installed lambdabot today, because readline and something called unix failed to compile
04:50:17 <shambler> on windows
04:50:24 <burp> "Dynamic linking required, but this is a non-standard build" hm.. I read that this occurs when using template haskell + profiling, but I get this error with -dynamic and template haskell.
04:50:28 <mreh> does xmobar look any good>
04:50:35 <koeien> mreh: sure. i use it
04:50:42 <koeien> works fine
04:50:57 <mreh> is it nice to look at?
04:50:59 <eivuokko> So, anyway, nobody has heard of package that'd have code to ease making windows service?
04:51:14 <Baughn> mreh: It's.. elegant. Eyecandy? Not really.
04:51:16 <koeien> mreh: that is very subjective. can't you find a screenshot?
04:51:22 <Baughn> mreh: http://brage.info/~svein/screenshot.png
04:51:39 <ivanm> eivuokko: by "service" you mean "yet another annoying app that gets run at startup for no real reason and is a PITA to disable"?
04:51:52 <ivanm> IIRC, most "services" I've come across in windows fall into that category...
04:52:05 <mreh> it's a bit too minimal, I'll just use the gnome bar instead
04:52:41 <koeien> even if you use xmobar, you'll need a system tray too (at least I need one)
04:52:49 <eivuokko> ivanm, I see.  You are one of those peopel that think it's hard to disable stuff if you have to a) use mouse b) use the command line.
04:53:06 <ivanm> nope
04:53:12 <ivanm> hard to work out where the hell it is to disable it
04:53:23 <ivanm> and why the hell does it install a service anyway
04:53:34 <eivuokko> Ah, so reading docs is hard, I see.
04:53:42 <ivanm> from memory, I ended up disabling half of MS's default services last time I ran windows
04:53:46 <ivanm> eivuokko: not at all
04:53:57 <ivanm> having to go through to manage computer, etc. is a PITA
04:54:18 <increpare> ivanm: oh hey.  Cale was saying you were working with on a new graph class?
04:54:55 <ivanm> heh, we started... but I've had trouble grabbing his attention so that we could keep working on it
04:55:08 <increpare> ivanm: You have something sketched already?
04:55:25 <ivanm> very rough, yes
04:55:33 <aeter> I'm so proud, I have just made a fortune implementation
04:55:35 <aeter> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5409#a5409
04:55:38 <increpare> ivanm: could I have a gander?
04:55:39 <aeter> :)
04:56:09 <aeter> though most of the code is taken from rosettacode...
04:56:16 <increpare> aeter: heheh
04:56:24 <aeter> ;]
04:56:39 <aeter> but it's my first working haskell program!
04:56:43 <ivanm> increpare: http://paste.pocoo.org/show/158250/
04:56:46 * aeter goes jumping around
04:57:17 <eivuokko> ivanm, I honestly don't understand what all this had to do with my question.  Did you really not understand it, or did you actually have some non-flammatory topic in mind?
04:57:32 * Tordmor throws some confetti over aeter
04:57:39 <ivanm> eivuokko: I was asking what you meant by service
04:58:23 <increpare> ivanm: looks nice and kitchensinky.  We notice it has no edges?
04:58:52 * increpare notices that hpaste is down
04:59:06 <ivanm> sure it does
04:59:25 <ivanm> you have isArc
04:59:50 <ivanm> and then adjacencyMap, arcs, etc.
05:00:11 <increpare> ivanm: arcs are potentially compound edges?
05:00:12 <ivanm> increpare: actually, there's a newer version... but Cale has it AFAIK...
05:00:21 <increpare> k
05:00:22 <eivuokko> ivanm, Services, as they are called in Windows.
05:00:24 <ivanm> increpare: an arc (a,b) is an edge from a to b
05:00:48 <ivanm> eivuokko: which are those auto-starting things that you have to get to by digging down in manage computer or something?
05:01:11 <eivuokko> ivanm, "have to".  No.
05:01:20 <increpare> ivanm: ah I grew up in a place where we only ever said 'directed edges'; haven't come across the term 'arc' before
05:01:36 <eivuokko> ivanm, "auto-starting."  Not neccesarily.
05:01:41 <mux> ghc-pkg's colored output in 6.12.1 is nice
05:01:58 <ivanm> increpare: yeah, that was Cale's terminology
05:02:00 <increpare> ivanm: I'm tossing together a basic graph class for personal use - looks like http://pastebin.com/m46fbe6a7 for now
05:02:05 <ivanm> apparently its more correct for infinite graphs
05:02:26 <increpare> ivanm: it's not especially interested, but I figured it polite to share
05:02:52 <ivanm> doesn't look to bad
05:02:56 <increpare> ivanm: I don't see how a change in term could make any difference : P
05:03:08 <ivanm> it's maths! :p
05:03:28 <Jonno_FTW> why do people think haskell has no real world applications?
05:03:32 <increpare> ( even given that it's maths )
05:03:43 <ivanm> Jonno_FTW: propoganda
05:04:08 <ivanm> increpare: when I can eventually attract Cale's attention, I think the general outline is going to be: Graph -> FiniteGraph [get lists of nodes/edges] -> node-labelled/edge-labbeled -> mappable (ala FGL)
05:04:08 <increpare> ivanm: oh it seems people use the term 'directed arc' as well : P
05:04:08 <Jonno_FTW> really? is it that people get to monads and think the whole language is useless?
05:04:25 <ivanm> Jonno_FTW: no, they get to "immutable state" and "functional" and think its useless
05:04:29 <ivanm> after all, there's no OO!
05:04:29 <ivanm> ;-)
05:04:35 <increpare> ah cool; was wondering wheb the labelling was going to kick in
05:04:47 <increpare> (when)
05:05:18 <Jonno_FTW> jmm
05:05:26 <luite> Jonno_FTW: or they might be afraid that their java certifications will become useless once haskell takes over the world :p
05:06:02 <chrisdone> I see "monads are a hack for IO" a lot
05:06:05 <|Jedai|> Jonno_FTW: I think the fact that a lot of fundamental research is done in it has a lot to do with it
05:06:07 <chrisdone> that bugs me
05:06:22 <Jonno_FTW> hmm
05:06:26 <|Jedai|> chrisdone: impure language are a hack for IO !!
05:06:28 <luite> the hack or the for IO part? :)
05:06:46 <Jonno_FTW> see, my perl programmer friend is a victim of this propaganda
05:06:48 <increpare> chrisdone: monads pretty much are a hack for IO aren't they? (they're other things as well, of course)
05:07:10 * increpare doesn't tend thing of the term 'hack' in a bad light
05:07:14 <luite> Jonno_FTW: I replaced a perl script this morning by a haskell programma, and it was shorter! :p
05:07:15 <increpare> (tend to think >_<)
05:07:17 <Baughn> increpare: No. They figured out how to do IO first, then they noticed that function structure was a monad.
05:07:33 <|Jedai|> Jonno_FTW: many people think that research language automatically means "useless in the real world" and on the whole they're often right, it just so happen that for Haskell they're wrong IMHO
05:07:36 <increpare> Baughn: ah: interesting.
05:07:51 <Baughn> increpare: Although admittedly Haskell didn't have a Monad class before then
05:07:54 <Jonno_FTW> hmm
05:08:01 <increpare> Baughn: heh
05:08:15 <|Jedai|> Jonno_FTW: since at least a few years in the past
05:08:25 <Jonno_FTW> ok
05:08:44 <increpare> I think people will think a lot less badly of monads when applicative functors become more common in usage
05:09:17 <Jonno_FTW> are there any major projects done in haskell?
05:09:21 <Adamant> |Jedai|: no, people who think research language automatically means "useless in the real world" are wrong
05:09:43 <Adamant> can it mean inappropriate for a lot of stuff?
05:09:44 <Adamant> sure
05:10:05 <Adamant> but most research languages are very strong at a niche at minimum
05:10:13 <increpare> Jonno_FTW: darcs
05:10:19 <Jonno_FTW> oh right
05:10:24 <SimonRC> increpare: I can just imagine Java 10 haveing a special syntax for fmapping method calls ;-)
05:10:31 <increpare> Jonno_FTW: ghc, I guess.  Not much else that's really big.
05:10:48 <Jonno_FTW> a compiler for a language written in the language itself!
05:10:53 <|Jedai|> Adamant: ok, but you have to admit that a lot of research language never see the outside of their laboratory and are never even meant to do that, like you said they're extremely strong in their niche but not many people needs a language that can only do one thing very well and nothing else
05:10:59 <chrisdone> xmonad is bigish if you include its contribution libraries
05:11:15 <|Jedai|> Adamant: or at least they don't want to learn it
05:11:46 <increpare> Jonno_FTW: ghc isn't all written in haskell; just parts.
05:11:59 <Jonno_FTW> ok
05:12:02 <|Jedai|> Adamant: Haskell is an exception because it do lot of thing very well
05:12:05 <Adamant> |Jedai|: but sooner or later, if you have a varied career, you come to the point where you are working in a bunch of different niches
05:12:14 <|Jedai|> increpare: GHC is completely written in Haskell
05:12:14 <chrisdone> you usually see research language shadows in other languages
05:12:33 <Baughn> Jedai: Incorrect. There's quite a lot of C and C-- in it.
05:12:38 <|Jedai|> increpare: you're confusing GHC runtime with GHC
05:12:54 <Baughn> ..well.
05:13:01 <|Jedai|> Baughn: well that depends what you call GHC I suppose
05:13:04 <Baughn> Most people would say the GHC runtime is part of GHC
05:13:16 <Adamant> |Jedai|: and knowing the research languages is important if for no other reason that hijacking their ideas for other languages
05:13:21 <|Jedai|> Baughn: I wouldn't say that, the runtime don't compile anything
05:13:42 <Baughn> Jedai: It's still in the GHC tarball
05:13:44 <luite> |Jedai|: but GHC itself uses the runtime
05:13:52 <Adamant> also, both the Lisp family and Smalltalk have been quite researchy and used for a lot of stuff
05:14:09 <chrisdone> logic languages, generics, list comprehensions, immutible data structures, closures
05:14:23 <|Jedai|> Adamant: I didn't say that it was useless to learn them, but I can see the point of those that don't want to
05:14:24 <chrisdone> suddenly it's a good idea if an industry standard imperative language implements a retarded form of it!
05:15:25 <|Jedai|> Adamant: Sure, and ultimately, most (all ?) good languages were or still are research language, but they're not seen like that anymore by the general public
05:15:55 <|Jedai|> luite: good point ! Didn't think of that one
05:16:22 <chrisdone> Perl sure feels like an experiment of some horrific depth
05:16:49 <Baughn> Perl could be an attempt at a constructive proof of the Turing-Lovecraft theorem
05:17:03 <|Jedai|> Baughn: Right, but I wouldn't say that GHC is written in HTML just because there's some doc in html in the tarball
05:17:07 <increpare> oi! don't be hatin' on perl! : )
05:17:12 <chrisdone> Baughn: indeed
05:17:31 <Baughn> Jedai: GHC still works without the HTML docs. It doesn't without the runtime.
05:18:21 <Baughn> It doesn't work without glibc either, but that /isn't/ generally considered part of it and bundled in the tarball
05:18:57 <|Jedai|> Baughn: True :) Well as I said it depends if you call GHC the compiler itself which doesn't need the runtime (just a way to compile it) or the complete package that is used to compile a program with GHC
05:19:35 <Baughn> If GHC was actually written in haskell'98, I might agree with you. :P
05:19:44 <|Jedai|> to clarify, the compiler itself is written in Haskell and you just need an Haskell implementation to compile it with the proper extensions
05:19:58 <Baughn> That's the problem.
05:20:17 <|Jedai|> A problem I would say ;)
05:20:22 <Baughn> The minimal closure over code required to compile GHC isn't "GHC + Haskell implementation", it's "GHC + compiled GHC with runtime"
05:21:18 <increpare> the final executable, in any event, contains chunks of compiled hand-written c code
05:21:22 <|Jedai|> Baughn: Really ? I would have thought it was "GHC + Haskell implementation with a lot of GHC extensions" but I agree that it's currently the same thing
05:21:25 <Saizan> anyhow, i wouldn't think the runtime is the majority of the code, right?
05:21:53 <increpare> Saizan: it's a sizeable and important chunk (the garbage collector is still written in C, say)
05:22:05 <Baughn> Jedai: Given that GHC is the only compiler with that set of extensions, arguing that any other will do is basically equivalent to saying that it doesn't use C, because you can rewrite it to not use C..
05:22:12 <Saizan> increpare: do you have a percentage?
05:22:19 <|Jedai|> increpare: it's a lot less than GHC (the compile) itself though
05:22:20 <Baughn> (Some of the extensions are very dependent on the C/C-- code)
05:22:37 <increpare> |Jedai|: k
05:22:43 <|Jedai|> Baughn: I agree, but
05:23:20 <|Jedai|> I hope you can see my point if I insist that GHC (the compiler) is written in Haskell, even if it use C in its compilation model
05:23:39 <Saizan> i wouldn't say "just parts are written in haskell", i'd rather say "just parts are written in C"
05:24:06 <Baughn> Definitely that. Most of it's haskell.
05:25:26 * hackagebot upload: hecc 0.2 - Elliptic Curve Cryptography for Haskell (MarcelFourne)
05:25:42 <increpare> |Jedai|: yeah if you make the distinction that the compiler part of ghc is written in haskell, I'd buy your proposition
05:25:50 <Twey> Isn't there a Perl-shaped bramble buried in that rosebush somewhere, too?
05:26:02 <increpare> Twey: heheheh oh really?
05:26:07 <Baughn> Twey: We Do Not Mention the Evil Mangler.
05:26:07 <Adamant> the Perl Mangler strikes again
05:26:08 <Saizan> the evil mangler.
05:26:11 <Twey> Heheh.
05:26:15 <increpare> heh
05:26:24 <|Jedai|> Twey: right, but the evil mangler is no longer strictly necessary, no ?
05:26:31 <Twey> Someone should really rewrite that thing :þ
05:26:33 <Twey> Isn't it?
05:26:33 <Saizan> mostly unused these days, if you're on a platform with a native codegen
05:26:38 <Twey> Ah, phew
05:27:20 <Adamant> I think the logic behind it's use was that basically all Unixes ship with a Perl at this point
05:28:05 <Saizan> maybe someone was a regex ninja at the time :)
05:28:15 <Adamant> and doing the code mangling it does still sucks less in Perl than in C
05:29:27 * hackagebot upload: digits 0.2 - Converts integers to lists of digits and back. (HenryBucklow)
05:30:33 <Twey> Adamant: But it would suck less in Haskell :þ
05:30:41 <Adamant> Twey: now it would :P
05:30:56 <Twey> Heh, fair enough
05:31:30 <ivanm> Twey: I think it remains in Perl for two reasons: 1) avoid an extra regex dep for ghc; 2) no-one can be bothreed converting it
05:31:37 <Twey> Haha
05:31:39 <increpare> I'm sort of vascillating between making a library of spurious combinators with silly operators or not; given that they're more for the type-system than for clarity of understanding what the code is doing maybe I could justify a library on the side of things like (a->b) -> (a,a)->(b,b) or the like
05:32:02 <ivanm> increpare: I think that's join (***)
05:32:03 <dibblego> @type join (***)
05:32:04 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
05:32:05 <ivanm> @type join (***)
05:32:06 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
05:32:19 <tensorpudding> @djinn (a -> b) -> (a,a) -> (b,b)
05:32:19 <lambdabot> f a (b, _) = (a b, a b)
05:32:29 <ivanm> > join (***) Just (2,3)
05:32:30 <lambdabot>   (Just 2,Just 3)
05:32:36 <increpare> ooh
05:32:38 <ivanm> tensorpudding: heh
05:32:53 <tensorpudding> hmm
05:32:55 <ivanm> @hoogle (a -> b) -> (a,a) -> (b,b)
05:32:56 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
05:32:56 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
05:32:56 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
05:33:00 <ivanm> heh
05:34:15 <BrianB04_> Okay, Hoggle is offically the coolest thing ever.
05:34:29 <tensorpudding> hoogle is pretty neat
05:34:30 <increpare> hoogle is pretty ggreat
05:34:54 <tensorpudding> @hoogle unsafePerformIO
05:34:54 <lambdabot> Foreign unsafePerformIO :: IO a -> a
05:34:54 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
05:34:56 <ivanm> when ndm integrates hackage support into hoogle, _then_ it will be _really_ great
05:35:00 <BrianB04_> Though, that may be because the type system in Haskell is so frigging descriptive.
05:35:06 <ivanm> as that's the one advantage hayoo has over hoogle
05:35:24 <tensorpudding> you can search by function name, module name, type signature...
05:35:24 <ivanm> BrianB04_: IIRC, when ndm first wrote hoogle it was meant to have Java support available... >_>
05:35:28 * hackagebot upload: luhn 0.2 - An implementation of Luhn's check digit algorithm. (HenryBucklow)
05:35:30 <gwern> 'The C Programming Language
05:35:31 <gwern> Brian W Kernighan & Dennis M Ritchie & HP Lovecraft'
05:35:35 <gwern> http://www.bobhobbs.com/files/kr_lovecraft.html
05:35:39 <tensorpudding> ivanm: Java support?
05:35:46 <Twey> Hahahaha
05:35:57 <ivanm> search for java methods based on type sig
05:36:23 <Baughn> "Exercise 4-13. Write a function reverse(s) which reverses the string s by turning the mind inside out"
05:36:28 <gwern> '"Now, there's two ways to do that. The old-timers'd take the digits and stow 'em in an array, then print 'em right smart in reverse order. But Cap'n Marsh, see, he'd been dealing with queer folks in the South Sea islands, and they taught him some peculiar ways. Out there on Devil Reef, he built a funct'n that called itself to print any leading digits, then printed out the trailing digit at the end."'
05:36:32 <tensorpudding> I didn't think Java methods had polymorphic types
05:36:49 <BrianB04_> What the heck is an: Kibro v String
05:37:19 <gwern> 'I had heard tales of the... thing that C.A.R. Hoare had summoned up in '62– dark hints of choosing one element from an array, and partitioning the rest into lesser and greater sets, and hellishly recursing until the data were twisted into a sorted list– but nothing I could have imagined would be in any way comparable to the daemoniac, blasphemous reality that I saw. '
05:38:02 <tensorpudding> quicksort is far from hellish
05:38:48 <BrianB04_> It appears I just stumbled upon another web framework for Haskell.
05:38:56 <increpare> BrianB04_: which one?
05:38:59 <tensorpudding> they're lying all over the place
05:39:08 <BrianB04_> increpare: Kibro.
05:39:31 <ivanm> we need "Yet Another Web Framework" ... hmmm, YAWF is almost pronouncable!
05:39:32 <BrianB04_> I was bored and hunting for methods String -> String -> Integer, and stumbled upon the odd return type, so had to investigate
05:40:02 <dibblego> levenshteinDistance ?
05:40:55 <BrianB04_> Speaking of web frameworks, is there a recommended one?
05:41:08 <Twey> Kibro
05:41:09 <Twey> ;)
05:41:18 <ivanm> heh
05:41:41 <tensorpudding> happstack?
05:41:43 <Twey> Kibro's pretty sweet.  chrisdone uses it for some commercial stuff, IIRC.
05:42:02 <Twey> Elsewise, there's happstack and Turbinado, depending how your taste for these things runs
05:42:18 <koeien> happstack-state is pretty neat but experimental
05:44:10 <Twey> gwern: « Exercise 4-13. Write a function reverse(s) which reverses the string s by turning the mind inside out, converting madness into reality and opening the door to allow the Old Ones to creep forth once more from their sunken crypt beyond time. »
05:44:16 <burp> @hoogle splitBy
05:44:16 <lambdabot> No results found
05:44:33 <BrianB04_> Twey: Where is that from?
05:44:41 <Twey> http://www.bobhobbs.com/files/kr_lovecraft.html
05:44:43 * increpare doesn't really see the comic value in demonizing recursion
05:44:57 <BrianB04_> Twey: It sounds like...I was going to say Cthulu wrote a programing book....
05:45:02 <Twey> Hehe.
05:45:09 <increpare> heh
05:45:53 <BrianB04_> Yea, they sound like Lovecraft wrote them.
05:45:58 <Twey> increpare: This {is,was} a common view of recursion {in the minds of some professional programmers,at the time} ☺
05:46:36 <tensorpudding> because their minds have been broken
05:46:36 <BrianB04_> Oh god, I thought recursion was evil and couldn't get my head wrapped around it. When I started writing in functional languages though, it all started to make a lot of sense.
05:46:58 <koeien> loops are just a special kind of recursion
05:47:18 <Twey> True that
05:47:21 <increpare> koeien: so is just doing things once
05:47:24 <tensorpudding> yes, but it's less explicitly so
05:47:24 <BrianB04_> When you come from an imperitive language, this looks odd: sum = x + sameFunction xs
05:47:26 <Twey> Haha
05:47:44 <koeien> BrianB04_: it doesn't look very odd, just very inefficient to me
05:47:49 <koeien> in an imperative setting
05:47:56 <Twey> Aye
05:48:07 <koeien> well, that may make it odd. hmm.
05:48:21 <Axman6> BrianB04_: i wouldn't write that in any style of programming personally :P
05:48:32 <increpare> Axman6: how *would* you write it?
05:49:11 <Baughn> sum = foldl (+) 0
05:49:12 <Axman6> sum xs = sum' 0 xs where sum' acc (x:xs) = (x+acc) xs; sum' acc [] = acc
05:49:23 <Twey> Shhhh
05:49:24 <Axman6> just because i like explicit recursion
05:49:25 <koeien> sum = foldl' (+) 0 or foldr
05:49:27 <Twey> Cale will hear you!
05:50:13 <BrianB04_> Oh, that brings up another question: How do you decide when to use foldr or foldl'?
05:50:17 <Axman6> uh, there was a sum' in there also
05:50:51 <Axman6> BrianB04_: if you need to work with infinite lists, then foldr has to be the one
05:50:52 <tensorpudding> foldl' is strict, and foldr is not
05:51:06 <koeien> BrianB04_: depends a little bit on the function f in fold{l,r} f e
05:51:07 <Axman6> foldr can't really be strict either
05:51:25 <koeien> for sum on integers, foldl' makes more sense
05:51:38 <tensorpudding> foldl' prevents lots of thunks being produced
05:51:40 <Baughn> If the result is an atom, then foldl' makes sense. If it isn't, then foldr might, depending on the structure of the function.
05:51:42 <koeien> because it cannot work on infinite lists, and you need to inspect the whole list anyway
05:51:51 <BrianB04_> Axman6: I do remember reading that foldl on an infinite list could become pain.
05:51:53 <tensorpudding> which makes sense on operations like sum
05:52:01 <Baughn> Where "is an atom" means "rnf x = rwhnf x"
05:52:06 <koeien> BrianB04_: it doesn't terminate
05:52:09 <tensorpudding> but if the list is infinite you will stack overflow
05:52:34 <koeien> i believe there is a wiki article about this subject
05:52:45 <Jonno_FTW> how does $ differ from $! ?
05:52:56 <Axman6> @src ($!)
05:52:56 <lambdabot> f $! x = x `seq` f x
05:52:57 <tensorpudding> @src ($!)
05:52:57 <lambdabot> f $! x = x `seq` f x
05:52:58 <koeien> Jonno_FTW: $! first seqs its second argument
05:52:59 <Axman6> @src ($)
05:52:59 <lambdabot> f $ x = f x
05:53:16 <koeien> http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
05:53:34 <Jonno_FTW> @src seq
05:53:34 <lambdabot> Source not found. You speak an infinite deal of nothing
05:53:35 <koeien> BrianB04_: ^
05:53:42 <koeien> Jonno_FTW: seq is special
05:53:43 <tensorpudding> @type seq
05:53:43 <koeien> :t seq
05:53:44 <lambdabot> forall a t. a -> t -> t
05:53:45 <lambdabot> forall a t. a -> t -> t
05:53:45 <Jonno_FTW> what does seq do?
05:54:17 <Jonno_FTW> > let f x = (2*) $ 1+x in f 5
05:54:18 <lambdabot>   12
05:54:23 <Jonno_FTW> > let f x = (2*) $! 1+x in f 5
05:54:24 <lambdabot>   12
05:54:29 <koeien> it checks whether its first argument is undefined (_|_). If it isn't, it returns the second argument. Otherwise, it returns _|_
05:54:40 <koeien> > 1 `seq` 2
05:54:41 <lambdabot>   2
05:54:43 <Jonno_FTW> what is _|_?
05:54:45 <koeien> > undefined `seq` 2
05:54:47 <lambdabot>   * Exception: Prelude.undefined
05:54:58 <tensorpudding> _|_ is the avatar of evil
05:55:11 <Baughn> _|_ is bottom
05:55:14 <koeien> it stands for "bottom". A computation that does not terminate or is invalid (e.g. head [])
05:55:18 <tensorpudding> it is what is "returned" by non-terminating functions
05:55:26 <Jonno_FTW> ok
05:55:42 <Baughn> Or exception-throwing functions
05:55:50 <tensorpudding> yes, or ones that throw exceptions
05:56:28 <koeien> anyway, the main point of seq is to introduce strictness
05:57:14 <koeien> if you write out what foldl (+) 0 :: [Int] -> Int does, you will see that before you get a result, there will be a long (of size ~the length of the list) thunk in memory
05:57:38 <tensorpudding> @src foldl'
05:57:39 <lambdabot> foldl' f a []     = a
05:57:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:58:19 <tensorpudding> the seq forces a' to be evaluated instead of thunking it
05:58:25 <burp> @hoogle parseTest
05:58:26 <lambdabot> Text.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
05:58:26 <lambdabot> Text.ParserCombinators.Parsec.Prim parseTest :: (Stream s Identity t, Show a) => Parsec s () a -> s -> IO ()
05:58:28 <koeien> if you use seq on the accumulator, it will check whether the sum "a + x" is _|_. This has the benefit that the accumulator will be evaluated
05:58:45 <Baughn> Although in most cases GHC will rewrite foldl to foldl'.. there's pretty much never any reason to use foldl as such
05:59:11 <tensorpudding> it tells haskell to not be lazy in the first argument
05:59:33 <koeien> http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
05:59:35 <tensorpudding> seq is in the report i think
05:59:57 <tensorpudding> @hoogle seq
05:59:58 <lambdabot> Prelude seq :: a -> b -> b
05:59:58 <lambdabot> Data.Sequence data Seq a
05:59:58 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
06:00:00 <koeien> that article also explains seq
06:00:19 <koeien> it is a kind of magical function :) we mortals cannot write it directly without compiler support
06:04:42 <BrianB04_> I apparently have much more to learn about Haskell...
06:05:14 <koeien> suppose i do "cabal install X -fFLAG". Will FLAG be passed to dependencies, or not?
06:10:47 <CalJohn> I'm using gtk2hs, and I have a TreeView on which I am trying to mutate the ListStore.  However, neither modifying the ListStore nor replacing the Model in the TreeView seem to have any effect.  Is there something I am forgetting to do?
06:11:52 <CalJohn> http://privatepaste.com/9f91393e0c <- pastebin with the code.  relevant section is at the bottom
06:22:12 <CalJohn> wait, it's probably glade's fault
06:26:48 <vy> What's wrong with "translate" function in http://codepad.org/FrfInWAn that it cannot operate on infinite lists?
06:27:35 <vy> Is it because of eager Regex functions or implementation fault?
06:29:32 <Codex_> vy: I have doubts about (++) with infinite lists.
06:30:49 <chellomere> Codex_, well. it works just fine. but I don't see any use for it :)
06:31:13 <Jafet> > [0..] ++ [0..]
06:31:14 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:31:36 <aavogt> > "hello" ++ repeat 'o'
06:31:37 <lambdabot>   "helloooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
06:31:53 <chellomere> well yeah, if the first one isn't infinite...
06:32:15 <dibblego> > head (repeat 1 ++ [7])
06:32:17 <lambdabot>   1
06:32:17 <aavogt> > ("hello" ++ repeat 'o') ~= "/hello/" :: String
06:32:17 <lambdabot>   Not in scope: `~='
06:32:23 <aavogt> > ("hello" ++ repeat 'o') ~== "/hello/" :: String
06:32:24 <lambdabot>   Not in scope: `~=='
06:35:44 <chellomere> /=
06:36:00 <chellomere> oh wait, regex?
06:36:12 <chellomere> > last $ repeat 1
06:36:18 <lambdabot>   mueval: ExitFailure 1
06:54:13 <burp> @hoogle ClockTime
06:54:13 <lambdabot> System.Time data ClockTime
06:54:13 <lambdabot> System.Time addToClockTime :: TimeDiff -> ClockTime -> ClockTime
06:54:13 <lambdabot> System.Time diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
06:56:39 <Berengal> Why are the regex compile functions in IO?
06:58:55 <PeakerWork> Berengal: cowards who do not wish to take responsibility for declaration of purity of external functions, probably :)
07:11:09 * hackagebot upload: crockford 0.2 - An implementation of Douglas Crockford's base32 encoding. (HenryBucklow)
07:11:11 * hackagebot upload: hemkay-core 0.1.1 - A device independent module music mixer (GergelyPatai)
07:35:35 <vy> Has anybody ever used hsemail? I'm reading the api docs but still couldn't figure how to parse a plain text message. Any hints?
07:38:39 <Saizan> mh, you've to find the parser that corresponds to a complete message (maybe by looking at the rfcs?) and then use it with the parse function from parsec
07:39:59 <jbe> vy: I am using mime-0.3.0 to parse email messages (including text/plain).  As I recall, I was unable to get it to work out of the box, but I tweaked the exports and now it is working OK.
07:41:22 <EvanR> do i have to use parentheses around lambda abstractions
07:41:59 <koeien> let f = \x -> x + 1 in f 37
07:42:02 <Twey> EvanR: Not necessarily
07:42:03 <koeien> > let f = \x -> x + 1 in f 37
07:42:05 <lambdabot>   38
07:42:12 <Twey> But they have huge right scopes
07:42:16 <Jafet> Usually.
07:42:38 <EvanR> when using one in a highorder function it seems i have no choice
07:42:40 <Twey> If you want to put anything after them, you have to
07:42:42 <Twey> Yes
07:42:43 <EvanR> ah i can use let
07:42:44 <Twey> Well
07:42:46 <Twey> You can flip
07:42:58 <koeien> :t map \x -> x + 37
07:42:59 <lambdabot> parse error on input `\'
07:43:01 <Jafet> It shouldn't be a problem
07:43:08 <Twey> instead of foo (\bar -> baz) quux, you can go: flip foo quux $ \bar -> baz
07:43:08 <EvanR> but if i use let i have to name it :(
07:43:27 <Twey> Yeah, you also need a $ in there
07:43:33 <Twey> :t map $ \x -> x + 37
07:43:34 <lambdabot> forall a. (Num a) => [a] -> [a]
07:43:34 <jbe> vy: Specifically, I added parseMIMEMessage and parseHeaders to the export list.
07:43:36 <EvanR> what about multiline lambdas
07:43:47 <EvanR> thats where i dislike ) the most
07:43:59 <Twey> If you've got multiline lambdas, you really ought to use a named definition
07:44:04 <Twey> Or possibly a do block
07:44:12 <EvanR> yeah...
07:44:16 <vy> jbe: Could you share them?
07:44:26 <EvanR> do blocks arent functions though ;)
07:44:48 <EvanR> i guess thats why there are fooM functions
07:45:50 <Jafet> Nah, those are simply pointless
07:46:53 <EvanR> eh? mapM is pointless?
07:48:10 <burp> > text "246"
07:48:11 <lambdabot>   246
07:48:12 <burp> > text "\246"
07:48:13 <lambdabot>   ö
07:48:49 <romildo> Hi.
07:50:40 <romildo> Does anybody have any idea of how soon gtk2hs will be available for ghc-6.12.1?
07:50:51 <burp> and also c2hs ;)
07:51:02 <romildo> It can be a development version.
07:51:22 <vy> jbe: Saizan: What about HackMail?
07:51:22 <jbe> vy: Here's a patch to mime-0.3.0: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14448#a14448
07:51:25 <sproingie> by the time the haskell platform is 6.12 i would hope
07:52:27 <vy> jbe: Isn't it possible to use those functions without exporting them?
07:53:18 <jbe> vy: Heh.  I suppose it is.  You mean by using the fully-qualified name?
07:53:26 <vy> jbe: Yup.
07:53:57 <jbe> Still, seems like the two most important names in the package, to me.
07:54:13 <sproingie> anyone have advice on how i can turn stateful callbacks into something pure?
07:55:16 <sproingie> namely GLUT callbacks.  lots of examples have them set some global
07:56:24 <vy> Is it possible to reach unexported functions?
07:57:20 <vy> jbe: I sent an email to the mime author.
07:57:41 * wahjava is having issues, trying to compile GHC 6.12.1 on FreeBSD
07:58:15 <Saizan> sproingie: a step forward is to carry the references in a ReaderT
07:58:48 <Codex_> sproingie: glut would need to be modified to support extra parameter to be passed to the callbacks.
07:59:00 <sproingie> i could mutate iorefs, sure.  was wondering about pure ways
07:59:06 <Saizan> vy: no, you can't break the module hiding mechanism
07:59:44 <sproingie> was thinking maybe have the callback write to a channel, read the channel in another thread, do its "stateful" stuff there in a state monad or whatever, then send the new state back over a reply channel
08:00:22 <Saizan> that might be a good way too
08:00:23 <sproingie> and have the callback read the reply channel.  thing is i don't know how to do a blocking timeout
08:00:41 <Saizan> blocking timeout?
08:01:51 <Saizan> well, you can throw an exception to a thread blocked on Chan/MVar to interrupt the waiting
08:02:14 <Saizan> if that's what you need
08:02:15 <sproingie> i don't want to have to race the callback's actual handler, but i can't let it block too long reading a reply, i'd rather drop the frame
08:02:22 <wahjava> This is the error, I'm getting while trying to build GHC 6.12.1 on FreeBSD (amd64) http://paste2.org/p/570920
08:02:33 <Baughn> Is there a name for something that is both a Functor and a Cofunctor?
08:02:41 <sproingie> i suppose the exception would work
08:03:03 <Saizan> Baughn: Co in the sense of contravariant? invariant functor then
08:03:36 <Baughn> Saizan: Co in the sense of cofmap. I can never seem to remember what contravariant means, but now I remember I was supposed to look it up. Again.
08:04:06 <wahjava> It seems iconv is messing up.
08:04:17 <Saizan> well, it's all a matter of perspective
08:04:56 <jbe> vy: Thanks for emailing the author.  I guess it *is* necessary.
08:05:55 <Zao> wahjava: --with-iconv-includes=/usr/local/include --with-iconv-libraries=/usr/local/lib ?
08:06:16 <Zao> Hrm, no.
08:06:31 <wahjava> Zao, yeah, GHC is built but haddock is having problems.
08:06:43 <wahjava> s/haddock/hscolour/
08:06:52 <Zao> Never got that far myself, my cross GHC always segfaults in stage2 :)
08:07:31 <wahjava> hscolour installed on system with GHC 6.10.4 is able to generate doc for that file without any issues, but hscolour built with GHC 6.12.1 fails.
08:08:27 <wahjava> ghc 6.10.4 is also built with iconv support, but not hscolour executable is not linked with iconv.
08:08:36 <wahjava> s/not hsc/hsc/
08:11:32 <wahjava> any ideas how to prevent iconv from linked to HsColour ?
08:13:34 <Saizan> ghc 6.12 does unicode decoding by default on System.IO Handle's
08:14:08 <Baughn> @djinn a -> b -> b
08:14:08 <lambdabot> f _ a = a
08:14:15 <Baughn> @pl f _ a = a
08:14:15 <lambdabot> f = const id
08:14:32 <wahjava> oh, so Saizan you mean iconv is conflicting ?
08:15:19 <Saizan> wahjava: i'm not sure why you say iconv is the problem
08:15:35 <Saizan> wahjava: iconv is probably what ghc uses to do the unicode decoding
08:17:08 <wahjava> Saizan, because same version of hscolour works when linked without iconv.
08:18:25 <Saizan> wahjava: i'd look at the problem at an higher level: the behaviour of Handle changed in ghc 6.12
08:18:48 <wahjava> Saizan, okay, so you meant HsColour needs to be modified.
08:19:27 <Saizan> yeah, or maybe ghc didn't get tested with your version of iconv and it's not working with it, or something
08:20:33 <Saizan> wahjava: ghc-users could be more helpful
08:21:11 <wahjava> Saizan, GHC 6.10.4 is already installed and working fine. and I just generated a GHC 6.12.1 bootstrap tarball using GHC 6.10.4, now I'm using GHC 6.12.1 tarball to compile GHC 6.12.1
08:21:15 <Saizan> another workaround might be to change your locale
08:21:43 <wahjava> Saizan, or should I convert all haskell files using iconv, post-extraction.
08:22:03 <Saizan> 6.10 didn't use iconv, i think
08:22:41 <wahjava> Saizan, it needs it.
08:22:59 <Saizan> ok, don't listen to me then :)
08:25:36 <sproingie> tried to track down a pdf of the opengl redbook, finally fought through rapidshare's craptastic download queue, and it turns out to be a scan of an issue of redbook magazine
08:26:45 <EvanR> lol
08:27:03 <EvanR> it used to be available on sgi website
08:27:12 <sproingie> html form yah
08:27:21 <Zao> There's been lots of revisions since then.
08:27:24 <sproingie> i just found a slightly better offline conversion
08:27:33 <sproingie> Zao: yah, only the first edition's free tho
08:27:47 <EvanR> as long as youre not doing 3.0 or shaders its a fine book
08:27:56 <sproingie> opengl core api is still completely compatible
08:28:11 <sproingie> and the aux stuff it uses has equivalents in GLUT
08:28:16 <Zao> I'd just grab the OpenGL standard and GLSL standard.
08:28:43 <sproingie> i have a copy of the opengl superbible that covers shaders, which is nice
08:28:47 <Zao> Which is available for free and should be enough for any manly man.
08:29:04 <sproingie> i'd love to find a book that didn't throw on tons of utility libraries from the very first example tho
08:29:30 <sproingie> the redbook is close, it just uses aux, which is easily portable to glut
08:29:32 <Zao> It's OpenGL. You will die alone without any.
08:30:23 <sproingie> started off learning directx which is a funny study in opposites
08:30:48 <Zao> Yes. Sanity :)
08:30:50 <sproingie> every version of direct3d loses backward compatibility, but the system support libraries stay compatible forever
08:31:20 <Zao> sproingie: Well, there's been a few revs of 9.
08:31:30 <sproingie> far as i know they just add features
08:31:30 <Zao> 10 and 10.1 is largely the same.
08:31:33 <EvanR> i usually use sdl to use opengl
08:31:41 <sproingie> the revs of 9 that is
08:31:55 <sproingie> EvanR: i can't make sdl+opengl work in haskell
08:32:04 <Zao> sproingie: At least they added feature levels in 10.1 and 11.
08:32:05 <EvanR> that sucks >_<
08:32:09 <sproingie> i get only blank screens
08:32:18 <sproingie> and yes i even set and cleared the depth buffer
08:32:27 <Zao> I can create a 11level9 device on a DX9-capable card and be able to use suitable bits of the D3D11 API.
08:32:34 <EvanR> blank screens are common without a reference working dummy program
08:32:48 <sproingie> these are reference programs
08:32:49 <EvanR> tons of sign conventions
08:33:03 <Zao> sproingie: Never ever clear to full black or white.
08:33:11 <Zao> Too many mistakes result in those colours.
08:33:14 <sproingie> i have two SDL+opengl lessons in haskell and they just dont work
08:33:38 <sproingie> one doesn't map a window at all the other maps a black window that crashes the instant you even move it
08:33:46 <sproingie> other SDL stuff works fine
08:33:47 <Berengal> Dining philosophers turned out to be pretty easy with STM...
08:33:49 <Zao> Robust.
08:34:04 <sproingie> so i'm stuck with glut
08:34:32 <pastah_rhymez> http://i.imgur.com/8ZrT2.png
08:34:38 <sproingie> maybe i can make glfw work, it at least has some joystick support
08:34:50 <Zao> GLFW tends to be sane.
08:35:02 <Zao> And doesn't have the oh so amusing glut/freeglut personality split.
08:36:21 <sproingie> glfw also gives me free fsaa which is nice for my purposes (2d tiled game)
08:36:49 <Berengal> Is this enlightening? http://rosettacode.org/wiki/Dining_philosophers#Haskell
08:37:11 <EvanR> eww AA 2d ;)
08:37:18 <EvanR> pixels ftw
08:37:31 <sproingie> "mapM_ forkIO philosophersWithForks"
08:37:36 <sproingie> for some reason that amuses me greatly
08:37:44 <Twey> Heheh
08:37:56 <Zao> EvanR: http://www.acc.umu.se/~zao/swoosh24.png
08:38:00 <Zao> Best of two worlds.
08:38:19 <wahjava> Saizan, deleted the conflicting characters and it is running :)
08:38:20 <Zao> I'd like to see your pixel-pushing push 10k particles in realtime :)
08:38:47 <EvanR> high rez 2d, ewww ;)
08:38:49 <EvanR> 320x240 ftw
08:38:55 <wahjava> Zao, are you interested in test freebsd port ?
08:39:11 <Zao> EvanR: The underlying render target is low-res.
08:39:12 <wahjava> s,est,esting,
08:39:21 <Zao> EvanR: It just has hq2x/hq4x scaling applied.
08:39:26 <sproingie> it's the fact that i want a lot of particles that i'm going with gl instead of sdl in the first place
08:39:39 <Zao> This one seems to be 2xSuperSai of 640 though.
08:39:44 <sproingie> if sdl 1.3 ever came out or if there were sfml bindings for haskell the question would be moot
08:40:52 <EvanR> Zao: i see
08:41:09 <EvanR> ewww ;)
08:45:00 <pastah_rhymez> EvanR: i like 320x224 better
08:45:33 <increpare> what's this resolution talk?
08:46:00 <hsaliak> increpare: in preparation for the new year
08:46:18 <increpare> hsaliak: ho ho ho
08:46:32 * pastah_rhymez dies i little inside
08:46:32 <increpare> seems like I just caught the end of a bad pun
08:50:15 <Absolute0> Is there any command in ghci that could tell me all the operations a particular type has with the currently loaded modules?
08:50:31 <Twey> :info Type
08:50:54 <Absolute0> great
08:51:06 <Absolute0> thanks
08:51:23 <Absolute0> Twey: can I do the same with modules?
08:51:48 <Twey> Absolute0: Use tab-completion
08:52:08 <Absolute0> ah
08:52:08 <Absolute0> ok
08:52:10 <Absolute0> thanks
08:53:41 <increpare> If I'm writing a class that's a subclass of Eq (say), is it possible to give a default implementation of (==) ?
08:54:05 <Raevel> yes
08:54:55 <PeakerWork> increpare: you mean, like the Applicative class giving a default fmap (as pure and <*>)?  AFAIK, its not possible (unfortunately)
08:54:56 <Raevel> _ == _ = True for instance, though it might not be very useful in this case :-)
08:55:26 <Raevel> or am i mistaken?
08:55:30 <PeakerWork> Raevel: I think he means:  class Functor f => Applicative f where (<*>) :: ... ; pure :: ... ; fmap f = (pure f <*>)
08:56:36 <increpare> PeakerWork: yeah, that's what I meant
08:57:30 <PeakerWork> increpare: There's a "class aliases" proposal that deals with this iirc, but afaik there's no nice way to do this
08:58:31 <increpare> PeakerWork: ah yes.  the class aliases thing would be really handy from several points of view  (It's up there with class families and parametrized types on my list of things I ache to see appear at some point in the future).
08:58:47 <PeakerWork> yeah, it would be nice
09:00:00 <maltem> I have a situation where BS.hGet, with ghc-6.12.1, gives me hLookAhead: invalid argument (Invalid or incomplete multibyte or wide character)
09:00:25 <maltem> But with ghc-6.10.4 I don't get the error. Is that somehow to be expected?
09:00:42 <rovar> simple question:  http://gist.github.com/260556
09:01:01 <monochrom> probably because ghc 6.12 starts doing utf-8 decoding.
09:01:39 <rovar> what is the easiest way to run L.readFile inside of a list comprehension? It's failing because a constructor expects L.ByteString and I'm passing it IO L.ByteString
09:01:40 <maltem> monochrom, I guess so, but I'm curious as to why this should affect ByteStrings, where I don't even want any decoding to happen
09:01:50 <rovar> line 19
09:01:57 <koeien> rovar: you don't
09:02:09 <rovar> koeien,  that's a good start
09:02:20 <monochrom> OTOH ByteString doesn't tell IO to suppress decoding either.
09:02:31 <koeien> xs <- L.readFile "..." ; [ ... xs ... ]
09:02:43 <Twey> map Constructor <$> mapM L.readFile yourList
09:03:04 <Saizan> yeah, the decoding happens in the primitives that read from Handle
09:03:16 <Saizan> afaiu
09:03:28 <PeakerWork> maybe you can mmap? Its hard to believe mmap would decode anything
09:04:01 <maltem> Strange organization, but ok. How do I turn decoding off?
09:04:55 <PeakerWork> maltem: not an optimization, but an i18n, it seems
09:05:02 <PeakerWork> though it seems like it was put in the wrong level
09:05:06 <PeakerWork> (too low)
09:05:13 <Saizan> "organization"
09:05:51 <HaskellLove> I read TAPL and I don't understand what "untyped arithmetic expressions" chapter is about? I can't see the big picture, I understand the 0. pred, and succ functions but...
09:06:03 <PeakerWork> I think what Java and Python did is nice: Strings are for unicode text strings that get [en|de]coded.  ByteStrings are for raw byte strings that don't encode text at all, so shouldn't be [en|de]coded.. In fact, what does   decodeUTF8 :: ByteString -> ByteString -- even do?
09:06:05 <monochrom> set "locale" or "language" to ascii or iso-latin-1
09:06:36 <Saizan> maltem: System.IO appears to have the functions to set the encoding
09:06:44 <rovar> Twey, I see what you're saying.. now I have to remember how to use ap.. since my ctor takes 3 params
09:06:47 <maltem> PeakerWork, that's what I meant. monochrom, that would be latin1 :: TextEncoding I presume?
09:06:56 <monochrom> Yes.
09:07:16 <PeakerWork> so what does (decodeUTF8 :: ByteString -> ByteString) even do?  doesn't make much sense...
09:07:38 <EvanR> convert utf8 to utf32?
09:08:32 <benmachine> PeakerWork: where'd you get that function from?
09:08:33 <lambdabot> benmachine: You have 1 new message. '/msg lambdabot @messages' to read it.
09:08:57 <monochrom> decodeUTF8 was written before 6.12.
09:09:14 <maltem> Alright, that did the trick. I guess that means, whenever you use BS.hGet, set the encoding of the handle to latin1
09:09:35 <Saizan> i wonder how hGet is implemented
09:09:44 <monochrom> Or ensure the input is valid utf-8.
09:10:24 <Absolute0> how can I print numbers in binary or hex?
09:10:28 <maltem> How to ensure the input is valid utf-8 if I haven't read it yet? :P
09:10:30 <PeakerWork> benmachine: Well, I'm assuming it exists under the hood since reading a ByteString still decodes -- the file has a ByteString, and its yielding a ByteString, so I'm filling in the details :)
09:11:31 <Saizan> ok, it uses hGetBuf, i wouldn't expect any decoding on hGetBuf
09:11:46 <EvanR> Absolute0: printf ?
09:11:59 <Absolute0> @src printf
09:11:59 <lambdabot> Source not found.
09:12:07 <Absolute0> EvanR: which module is that from?
09:12:10 <doserj> > showHex 47 ""
09:12:11 <EvanR> :t printf
09:12:12 <lambdabot>   "2f"
09:12:12 <lambdabot> forall r. (PrintfType r) => String -> r
09:14:23 <maltem> Fwiw here's what triggered the exception for me, I'm not sure how to track it down exactly: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14449
09:14:48 <Saizan> PeakerWork: there's no decoding on the bytestring side here, hGetBuf would fill the given buffer with decoded data though, afaiu
09:15:07 <maltem> (The exception is not triggered by e.g. BS.readFile)
09:17:20 <monochrom> I wrongly assumed you opened in binary mode.
09:17:38 <maltem> uh
09:19:09 <maltem> I wasn't aware that makes a difference on non-windows systems. That sure should be the proper fix
09:19:36 <Saizan> maltem: it might be that reading in chunks like you do creates problems for multibyte characters, while readFile reads the whole thing at once
09:19:54 <benmachine> t probbaly didn't before but it might do now that ghc 6.12 is being all unicodey
09:20:42 * Saizan wonders if there's a good documentation for all this
09:22:01 <maltem> aha, opening in binary mode is approximately the same as setting the encoding to latin1, and disabling newline transition
09:26:41 <maltem> Saizan, I realize the base-4 haddocks aren't to bad, if one actually reads them :)
09:29:30 <maltem> Even though I'm still not sure if I'm not having encoding/decoding overhead on ByteString I/O
09:29:46 * increpare found a use for -XDeriveFunctor ... but had the new ghc installed in the wrong path...blech/rebuilding
09:32:32 <Saizan> now i'm confused, the docs say that hGetBuf ignores encodings and reads bytes directly
09:32:49 <EvanR> i thought that bytestrings were for unencoded stuff
09:32:54 <Saizan> and BS.hGet is implemented with hGetBuf
09:37:51 <maltem> Maybe there's some misplaced call to hLookAhead
09:43:48 <maltem> That must be it: hLookAhead :: Handle -> IO Char, so this one does respect the encoding and should, arguably, not be called by hGetBuf/BS.hGet. I don't find the guilty code though
09:49:32 <EvanR> whats the inverse function of lines
09:49:49 <Zao> unlines, kind of.
09:50:19 <mercury^> :t lines
09:50:20 <lambdabot> String -> [String]
09:50:24 <mercury^> :t unlines
09:50:25 <lambdabot> [String] -> String
09:50:27 <PeakerWork> EvanR: lines loses information, so it has no real inverse
09:50:35 <EvanR> good enough
09:50:39 <Absolute0> :t showHex
09:50:40 <lambdabot> forall a. (Integral a) => a -> String -> String
09:50:45 <PeakerWork> > map lines ["1\n\n2", "1\n2"]
09:50:46 <lambdabot>   [["1","","2"],["1","2"]]
09:50:50 <PeakerWork> or not
09:51:01 <PeakerWork> mercury^: my bad, it doesn't seem to lose information
09:51:07 <Zao> > map lines ["1\n2\n", "1\n2"]
09:51:09 <lambdabot>   [["1","2"],["1","2"]]
09:51:13 <PeakerWork> ah, it does :)
09:51:16 <mercury^> :>
09:51:35 <PeakerWork> @check \x y -> x /= y ==> lines x /= lines y
09:51:37 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:51:37 <lambdabot>                     (Test.QuickCh...
09:51:42 <PeakerWork> @check \x y -> x /= y ==> (lines x /= lines y)
09:51:43 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:51:43 <lambdabot>                     (Test.QuickCh...
09:51:46 <mercury^> The second of those is sort of invalid though.
09:51:50 <EvanR> ehm, lines and unlines only work on lists of strings, not lists of lists of strings
09:52:01 <mercury^> So one could say that it preserves information on well formed data.
09:52:19 <Saizan> EvanR: concat or map concat ?
09:52:28 <EvanR> i wasnt to avoid that
09:52:30 <EvanR> unlines is good
09:52:36 <EvanR> s/wasnt/wanted/
09:52:46 <Absolute0> :t printf
09:52:47 <lambdabot> forall r. (PrintfType r) => String -> r
09:53:17 <cbeck> I'm attempting to do some fairly simple symbolic algebra, do I need to make a data type for variables, or is there a built in construct that'd be easier?
09:53:19 <Absolute0> Which module is printf in?
09:54:07 <Absolute0> Text.Printf
09:54:08 <Absolute0> :)
09:54:56 <PeakerWork> where's the type-safe printf thing?
09:58:28 <increpare> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14453#a14453 <- not sure if there's any particularly elegant way to introduce functors into the above container setup : (
09:59:18 <rovar> http://gist.github.com/260580
09:59:40 <rovar> anyone feel like critiquing that?
10:00:32 <PeakerWork> rovar: main = mapM loadDir ["basic_types", "complex", "single_types"]
10:00:47 <rovar> good idea :)
10:00:55 <ben0x539> Is there something that parses layout and spits out the same code with explicit {, }, ;?
10:00:58 <PeakerWork> rovar: the open unqualified imports, I'd convert to closed unqualified or qualified imports
10:00:59 <increpare> rovar: not compiling for me (as of line 35)
10:01:13 <PeakerWork> rovar: run hlint on it :)
10:01:30 <Heffalump> PeakerWork/rovar: mapM_
10:01:45 <PeakerWork> oops, hlint would say :)
10:01:51 <increpare> rovar: ignore me actually.
10:01:53 <Heffalump> on long lists using mapM where mapM_ would be appropriate can lead to linear space usage
10:02:08 <Baughn> Is it possible tickle GHC to warn me about language extensions I've enabled but am not actually using?
10:02:32 <increpare> Baughn: hlint does that  to some extent I think
10:02:34 <gwern> @hoogle temp
10:02:34 <lambdabot> package template-haskell
10:02:35 <lambdabot> Foreign.C.Error eNOTEMPTY :: Errno
10:02:35 <lambdabot> System.Console.Editline.Readline getAttemptedCompletionOver :: IO Bool
10:02:49 <gwern> @hoogle getTemp
10:02:50 <lambdabot> System.Directory getTemporaryDirectory :: IO FilePath
10:02:53 <Baughn> increpare: Aha! Verily, I shall.. actually, hlint dies on my code with a parse error. :P
10:03:04 <gwern> Baughn: really? it shouldn't do that
10:03:15 <gwern> I thought with the latest darcs -exts and hlint it could parse just about everything
10:03:16 <increpare> Baughn: Yeah it crashed on mine earlier today ... actually it related to language extension flags as well
10:03:33 <Baughn> gwern: I've also got haddock misplacing the second parameter's docstring as the first's, and so on. The first's goes missing.
10:03:44 <Baughn> gwern: ..well, maybe the darcs version would be fine
10:03:48 <PeakerWork> rovar: http://gist.github.com/260587
10:03:54 <gwern> ought to try, Baughn, so you can tell ndm
10:04:05 <Baughn> gwern: Verily.. later.
10:04:10 <increpare> PeakerWork: a nice set of suggestions : )
10:04:17 <PeakerWork> that's hlint :)
10:04:17 <Baughn> gwern: I'm doing twisted and horrifying things to Typeable now.
10:04:21 <PeakerWork> increpare: not me
10:04:32 <increpare> PeakerWork: yes yes, I know, but still.
10:04:49 <rovar> PeakerWork, cool.. installing hlint now :)
10:05:15 <gwern> @hoogle withTempDir
10:05:15 <lambdabot> No results found
10:05:21 * increpare thinks that there is a general guideline somewhere recommending that people put code through hlint before asking other people to gawk at it.
10:05:32 <gwern> what's really horrifying is how hard it is to get a :hlint in ghci
10:05:49 <increpare> gwern: is it possible?
10:05:55 <gwern> increpare: oh, it is
10:06:02 <gwern> it cost me 5 sanity points, but I did it
10:06:13 <increpare> gwern: hmm.  that would be nice.  Hmm.  But if it's hard, I might stick with my 2-terminal approach : P
10:06:35 <gwern> what's hard was making it; actually using it is as easy as :hlint
10:06:45 <gwern> managed to get it to run on loaded files
10:06:52 <gwern> (pretty neat actually)
10:07:06 * Baughn implements a Haskell parser. Wish me luck.
10:07:42 <haslamx> Is anyone good at php here? :L
10:07:56 <gwern> @hoogle bracket
10:07:57 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:07:57 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:07:57 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:07:58 <PeakerWork> haslamx: you searched for "programming chat" on google?
10:08:12 <gwern> withTempDir baseName = bracket (createTempDir 0 baseName) (removeDirectoryRecursive)
10:08:22 <PeakerWork> gwern: why the ()?
10:08:29 <gwern> am I correct in thinking that when withTempDir exits, nothing in the directory is still there?
10:08:43 <gwern> PeakerWork: ?
10:08:44 <Baughn> haslamx: We don't do PHP here. Try #php. But while you're here, want to join the cult of haskell?
10:09:00 <Berengal> Hehe
10:09:07 <PeakerWork> gwern: (removeDirectoryRecursive)
10:09:08 <gwern> increpare: http://community.haskell.org/~gwern/.ghci
10:09:10 <Philonous> What are the rules concerning which Type argument will be used when deriving a Functor instance?
10:09:13 <PeakerWork> gwern: did you do some Scheme/CL lately? :)
10:09:14 <gwern> PeakerWork: dunno man, I didn't write it
10:09:17 <PeakerWork> oh, ok
10:09:31 <Baughn> Philonous: "The first one".
10:09:46 <Baughn> Philonous: Or, rather, instance Functor Foo where <- Foo has to have kind * -> *
10:09:52 <Baughn> So, more like "the only one"
10:10:03 <haslamx> Yeah umm #php is full :(
10:10:11 <increpare> gwern: thanks : )
10:10:16 <Baughn> haslamx: Well, looks like you've got to learn haskell, then. :3
10:10:16 <PeakerWork> rovar: also, when you have common sections under then/else you should probably take them out
10:10:22 <Philonous> Baughn: data Foo a b = Foo a b works
10:10:33 <Philonous> Baughn: deriving functor *
10:10:37 <PeakerWork> rovar: some of your parenthesis are unnecessary
10:10:50 <rovar> yea.. i got rid of quite a few
10:10:54 <gwern> what undoes -Wall?
10:10:57 <Baughn> Philonous: *deriving* functor? On *data*?
10:11:20 <doserj> Philonous: the only sensible thing would be "the last one"
10:11:27 <Philonous> Baughn: -XDeriveFunctor
10:11:36 <PeakerWork> instead of:  if (str == b) then putStrLn $ f ++ ":: SUCCEEDED" else putStrLn $ f ++ ":: FAILED"  -- you can have: putStrLn $ f ++ ":: " ++ if str == b then "SUCCEEDED" else "FAILED" -- or even take that "if" into a separate conversion function
10:11:54 <Baughn> Philonous: Interesting. Which one does it pick? b, I suppose?
10:12:34 <Philonous> doserj: Now that you say it, it makes sense. And that matches with what I've been seeing
10:12:42 <Philonous> Baughn: Yes, b
10:12:44 <Baughn> @type cofmap
10:12:45 <lambdabot> Not in scope: `cofmap'
10:12:58 <gwern> bollocks, all the docs are bollocked!
10:13:03 <gwern> even hoogle links to dead links
10:13:34 <Philonous> Now I think about it, the functor deriving is actually much more straight forward than I initially thought
10:13:39 <ben0x539> gwern: Add an explicit version number to the package name in the URL and it might work
10:13:45 <ben0x539> Like base-4.2.0.0
10:14:00 <ben0x539> http://haskell.org/ghc/docs/latest/html/libraries/index.html is enirely functional, as far as I could tell.
10:14:36 <rovar> PeakerWork, those are just placeholders.. going to add some extra stuff, so it'll probably be separate functions.
10:14:50 <gwern> @seen ndm
10:14:50 <lambdabot> Unknown command, try @list
10:14:54 <gwern> preflex: seen ndm
10:14:55 <preflex>  ndm was last seen on #haskell 225 days, 7 hours, 56 minutes and 14 seconds ago, saying: plus with current compiler technology, it would be slower
10:15:18 <Twey> I guess Hoogle's not going anywhere fast, then :þ
10:15:26 <Baughn> @ask conal It occurs to me that if you have both a ContraFunctor and a Functor, you've got something like a lens. But is there some other name for that?
10:15:26 <lambdabot> Consider it noted.
10:15:45 <conal> @where+ hinam http://www.reddit.com/tb/agkls
10:15:46 <lambdabot> It is forever etched in my memory.
10:16:18 <conal> copumpkin's terrific remarks.  (Haskell is not about monads)
10:16:18 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:17:08 <conal> Baughn: hm.  don't know.
10:17:49 <conal> or http://www.reddit.com/r/haskell/comments/agkls/hinam_haskell_is_not_about_monads/
10:18:19 <conal> for monad-obsessed newbies
10:18:40 <Baughn> Then we just get applicative functor-obsesses newbies instead
10:19:04 <conal> Baughn: phooey.  classic pure FP.
10:19:31 <conal> Baughn: really the point is neither.
10:19:40 <Baughn> conal: Could you imagine Haskell with Applicative IO plus an explicit joinIO operation? :P
10:19:44 <conal> Baughn: it's that Monad is not central to Haskell.  it's simply one pattern.
10:19:56 <increpare> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14453#a14453 <- I tried adding an associated type Uncontents (Contents a) but that didn't work (probably for the best : P )
10:20:26 <conal> Baughn: i'm not saying down with Monad.  rather that it's not central.  "HINAM".
10:21:13 <Baughn> conal: It's amusing to see everyone obsess about it. Maybe I should write a "Monads are like quantum computing" tutorial..
10:21:19 * increpare doesn't mind new people have some site of focus: their horizons will broaden eventually.
10:21:44 <PeakerWork> increpare: its a bad place for initial focus -- its not an easy point to start at
10:22:17 <conal> Baughn: and more than obsessing, newbies think that monads enable state.  as if they were some sort of magic.
10:22:20 <increpare> PeakerWork: True (that it's not easy).  But they're there: right from the start pretty much.  I guess it's understandable that people get caught up with them.
10:22:26 <Berengal> The pure functional aspects are the fun ones.
10:22:28 <increpare> conal: yeah, that's dangerous
10:22:31 <PeakerWork> increpare: the rewards for someone learning the pure parts are bigger/quicker -- encouraging them to learn more.  The reward for Monads is smaller and its much more difficult - so many may end up just giving up
10:22:42 <Baughn> conal: Hm. That reminds me.
10:22:48 <PeakerWork> increpare: IO is there, perhaps because not enough tutorials teach people to toy with ghci :)
10:23:44 <increpare> PeakerWork: Right, so maybe the best thing is to say "yeah don't worry about the IO monad too much for now".
10:23:49 <Berengal> PeakerWork: I'm prepared to say it's because not enough languages have interactive REPLs
10:24:17 <increpare> Berengal: plenty of languages have them, just not many fashionable ones
10:24:21 <conal> PeakerWork: amen.  an interactive repl allows I/O without clobbering semantic simplicity and composability
10:24:32 <Baughn> conal: I've been reading a story called "Well-Understood Modern Magic", which is about.. basically, fantasy-style magic using computers. They at one point actually mention monads as central.. or possibly monoids, I'm not sure what they've done to the poor spelling.
10:24:33 <increpare> conal: it also allows mutability : )
10:25:11 <conal> increpare: joke?  what's "it"?
10:25:21 <Berengal> REPLs
10:25:25 <EvanR> data Foo = Foo a, how do i export the data constructor (as well as / instead of the type)
10:25:41 <Baughn> EvanR: module Bar(Foo(..)) where ...
10:25:43 <Berengal> EvanR: (..., Foo(..), ...)
10:25:48 <EvanR> ah
10:25:50 <monochrom> module Mine(Foo(Foo)) or module Mine(Foo(..))
10:26:06 <increpare> conal: yeah repls.  How central this is I guess is up for discussion.  Comment was slightly tongue-in-cheek
10:26:12 <Twey> よく分かる現代魔法
10:26:22 <monochrom> The important thing is there are two Foo's.
10:26:29 * Baughn wishes the Prelude didn't have quite so many Data.List functions that clash with Map
10:26:31 <Berengal> ghci could use some work, but I still think it's the best repl I've used...
10:26:35 * increpare wonders which one monochrom pities 
10:26:43 <Berengal> I didn't get too much into lisp though, but I've heard they've got better ones
10:26:43 <jkff> Hi folks. What latex symbols are pretty analogs of >> and >>= ?
10:27:02 <PeakerWork> Baughn: They should have used type-classes.. if it warrants using the same name, and similar semantics -- can't they formalize the common part of the semantics into a common vocabulary?
10:27:03 <EvanR> 魔<-not enough pixels in xterm >_< ;)
10:27:07 <Baughn> jkff: If you find some, tell me so I can stick 'em in haskell-mode.
10:27:24 <Baughn> PeakerWork: Agreed.
10:28:28 <EvanR> do x <- f; print x;, is there any way to avoid the variable and do print f ?
10:28:35 <maltem> jkff, I've seen authors just smashing them together, possilby using negative offsets. But that didn't meet my eye too elegantly
10:28:40 <Berengal> f >>= print
10:28:47 <EvanR> ah
10:29:00 <increpare> (conal: as an aside, though I've never quite gotten Reactive to compile properly, I'm a reasonably big appreciator of your general efforts.  I really have to get my frp chops at some point...)
10:29:04 <Baughn> EvanR: ..what? Demon?
10:29:23 <EvanR> Baughn: i cant read japanese ;)
10:29:43 <conal> increpare: not even compile?  hm :(
10:29:47 <jkff> maltem: That's a pity :-|
10:30:01 <monochrom> 現代 = modern, 魔法 = magic
10:30:05 <Baughn> Twey: Ah yes. That. I missed your line. :P
10:30:11 <increpare> conal: I think it was when it was one of these (especially) in-between development states where I had to downgrade a bunch of packages : P
10:30:13 <Baughn> Twey: No, I don't read japanese.
10:30:35 <Baughn> Twey: ..I /decode/ japanese.
10:30:37 <PeakerWork> conal: btw, yairchu ended up implementing his own Yampa style library -- though not with the use of arrows/type-products, but rather event-based using type sums instead (No Maybes).  I haven't looked at the code yet (its called "peakachu"), but it sounds like it may be nicer than Yampa, but I also would prefer the (Time -> a) model.
10:31:11 <PeakerWork> conal: (Category + type sums representing event processing, rather than arrows + type products representing signal processing)
10:31:47 <jkff> Baughn: How about \gg for >> ?
10:32:08 <increpare> PeakerWork: sounds like a not-unpleasant approach
10:32:25 <conal> PeakerWork: i think i know what you mean.  i have an old blog post about sums & products in frp.
10:32:27 <Baughn> jkff: I should've mentioned, I'm limited to things that appear in unicode.
10:32:36 <jkff> Ah, ok
10:32:50 <gwern> @hoogle [a] -> [a] -> [a]
10:32:50 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:32:51 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
10:32:51 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:33:08 <PeakerWork> conal: My own feeling is that something like Reactive, but that is points-free with explicit graph building, rather than Applicative/Monadic point-ful notation, could ease implementation concerns significantly, while hopefully maintaining semantic simplicity
10:33:28 <maltem> Baughn, ≫ ?
10:33:28 <gwern> > "" `mplus` "foo"
10:33:29 <lambdabot>   "foo"
10:33:40 <conal> PeakerWork: graphs?
10:34:24 <gwern> @check \x ->let orIfNull lst backup = if null lst then backup else lst in orIfNull x == "" `mplus` x
10:34:25 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> [GHC.Types.Char]'
10:34:28 <Baughn> maltem: Hm. Seems a bit.. well, maybe.
10:34:35 <monochrom> Bird uses ▷ for >>= and ≫ for >>
10:35:04 <Baughn> monochrom: I think there would be blood over that first one
10:35:19 <PeakerWork> conal: Well, I see the composition of Reactive's Behaviors/Events as a "graph" connecting behaviors/events
10:35:19 <gwern> @check \x -> let orIfNull lst backup = if null lst then backup else lst in (orIfNull "foo" x == "foo" `mplus` x)
10:35:20 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\377609\"\n"
10:35:31 <monochrom> Tell them to kill Bird then.
10:35:39 <gwern> @check \x -> let orIfNull lst backup = if null lst then backup else lst in (orIfNull "foo" x == x `mplus` "foo")
10:35:40 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\680427\\762774\"\n"
10:35:47 <conal> PeakerWork: a representational rather than semantic POV
10:35:48 <gwern> hm
10:36:19 <PeakerWork> conal: Well, that is when I try to grasp things from the implementation POV, yeah
10:36:23 <EvanR> is there a way to show a Data.Unique value, clearly theres no api for it. any ideas?
10:36:59 <conal> PeakerWork: that POV always alarms me.  folks then want to inspect & traverse graphs.  which breaks equational properties.  and then they want to mutate them.
10:37:13 <shortcircuit> I've got an idea that involves signal processing.  It's not EM-related, but you folks would seem to be the best to ask.  I'd *like* to take two sound emitters with an initially-synced carrier frequency of about 100kHz, invert one of those carriers, and use phase modulation to generate an audio signal in the 0-50Hz range.
10:37:14 <Twey> Baughn: Hehe
10:37:36 <PeakerWork> conal: I agree the graph is an implementation detail
10:37:42 <PeakerWork> conal: Not part of the semantics
10:37:49 <conal> (PeakerWork: same for graphics, especially 3d)
10:38:15 <shortcircuit> The 100kHz carrier is ideal for its wavelength characteristics (smaller/closer interference nodes), relative ease of deadening, and because it's well outside hearing range.
10:38:30 <Baughn> shortcircuit: So you're trying for sound beams?
10:38:32 <Baughn> Neat
10:39:26 <shortcircuit> Baughn: More a different kind of subwoofer than anything else. :)
10:39:40 <jmcarthur> very interesting
10:40:00 <PeakerWork> conal: One of the main implementation directions/ideas for a library like Reactive (for me, at least) is to try to figure out a graph, from the use of Reactive's semantic combinators
10:40:03 <conal> PeakerWork: my own personal PTSD from a microsoft frp product effort.
10:40:04 <Trafalgard> "The requested URL /ghc/docs/latest/html/libraries/base/Data-List.html was not found on this server."
10:40:14 <Trafalgard> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
10:40:23 <monochrom> change base to base-4.0.0.0 or something
10:40:27 <conal> PeakerWork: including loops & sharing?
10:40:35 <Trafalgard> hoogle is broken then
10:40:41 <blobl> is it normal to wait forever for ghc to build when installing gtk? anyone has tried it?
10:40:43 <Baughn> shortcircuit: Most of the time, when I hear about interference between high-frequency sound used to make low-frequency, it's because the high-frequency stuff doesn't diffract nearly as much
10:40:51 <monochrom> Equivalently you could say the docs are broken.
10:41:03 <PeakerWork> conal: Do you think forbidding Behavior/Event loops is a valid semantic choice?
10:41:14 <Trafalgard> no, base-4.0.0.0 didn't work either
10:41:23 <PeakerWork> conal: (You can still loop/recurse within the pure part)
10:41:44 <shortcircuit> Baughn: I hadn't thought of that, but it's an interesting characteristic.
10:41:46 * Trafalgard goes to http://haskell.org/ghc/docs/
10:41:47 <conal> PeakerWork: i wasn't going for forbidding.  i meant to ask if you wanted to detect sharing & loops.
10:42:03 <monochrom> 4.2.0.0
10:42:04 <conal> PeakerWork: when you "figure out a graph"
10:42:18 <PeakerWork> conal: Sharing, definitely (and this is where trouble comes in with the Functor instance, for example)
10:42:28 <Trafalgard> uhhh
10:42:40 <Trafalgard> The 'libraries' link on http://haskell.org/ghc/docs/latest/html/ goes to a nonexistant page
10:42:49 <increpare> yeah, you have to replace latest with 6.10.4
10:43:00 <increpare> probably due to the recent upgrade
10:43:06 <conal> PeakerWork: yep.  sharing has always been tricky for FP with time & space (as in fran & pan).
10:43:10 <shortcircuit> I'm curious what problems I'd likely have to address in the in-medium signal handling, as well as what devices exist that can efficiently push 50W of 100kHz vibrations in air.
10:43:12 <Trafalgard> ah.
10:43:27 * increpare isn't sure who's responsible for maintaining it
10:43:34 * Trafalgard hasn't updated
10:43:35 <conal> PeakerWork: the Eros/TFP combinators give one answer.
10:43:40 * Trafalgard is using some older version
10:43:56 <conal> PeakerWork: using Arrow-minus-arr
10:44:55 <PeakerWork> conal: Yeah, the direction I was getting to, is that maybe, for the ease of implementing the approach of "figuring out an explicit graph", one can require the user to use combinators from which an explicit graph is easier to derive (e.g arrows), while (hopefully) preserving the simple semantics (I don't suggest exposing graph building semantics instead)
10:44:57 <shortcircuit> Huh.  I wonder what happens if you vibrate a permanent magnet at 100kHz.  How far away could you pick up the signal with an antenna?
10:45:04 <SamB_XP_> shortcircuit: so, you're looking for some kind of hypertweeter thingy ?
10:45:13 <Baughn> shortcircuit: Well, there's no theoretical limit
10:45:15 <shortcircuit> SamB_XP_: Yup.
10:45:20 <EvanR> shortcircuit: another galaxy? :)
10:45:21 <artagnon> anyone else having a problem with runOrRaise failing with Emacs?
10:45:25 <conal> PeakerWork: got it now.  sounds good to me.
10:45:42 <Baughn> shortcircuit: (Though eventually you get into quantum issues where you need to wave the magnet a very long time just to get a single quantum reliably)
10:46:11 <PeakerWork> conal: Did Eros/TFP have ArrowApply?
10:46:26 <PeakerWork> conal: Could it build parts of the arrow at "runtime"?
10:46:31 <conal> PeakerWork: i don't think so
10:46:55 <PeakerWork> I wonder what consequences Arrow-minus-arr-plus-apply has
10:49:10 <osaunders> Why does head throw an exception instead of returning a Maybe?
10:49:26 <Twey> osaunders: Because.
10:49:32 <Twey> Check out the ‘safe’ package.
10:49:33 <Baughn> osaunders: Most times when you use it, you already know it's safe
10:50:27 <PeakerWork> osaunders: because totality without other features in place to ease it might make some things people expect to be easy, a bit more difficult (e.g, I'd guess the number of times people use "head" safely in one-liners with lambdabot is pretty high)
10:50:35 <jmcarthur> :t Data.Maybe.listToMaybe
10:50:35 <conal> Baughn: and our type system isn't expressive enough to prove what we know.
10:50:36 <lambdabot> forall a. [a] -> Maybe a
10:51:00 <Baughn> conal: And that.
10:51:23 <PeakerWork> I can't wait for Epigram to be usable for Real Stuff (TM)
10:51:37 <jmcarthur> i am still of the personal opinion that head and tail should be total. the maybe combinators/folds are still a lot easier than manual pattern matching
10:51:58 <jmcarthur> and we could still have partial versions of head and tail, of course
10:52:07 <conal> osaunders: great question.  delving into it (rather than jumping to answers) can teach you a lot about types & functional programming.
10:52:30 <osaunders> conal: I ask a lot of annoying questions
10:52:37 <PeakerWork> jmcarthur: I thought about having an alias "fj = fromJust" and have a "fj." prefix to stuff to mark their partiality unsafe...
10:52:47 <jmcarthur> i was convinced a long time ago that they should not be called unsafeHead and unsafeTail though, unless we were to adopt the pedantic policy that all partial functions be called unsafe
10:53:13 <PeakerWork> jmcarthur: fj.head  fj.tail :)
10:53:19 <jmcarthur> PeakerWork: that's... interesting
10:53:29 <conal> osaunders: bah.  people get annoyed about a lot of things. don't take it personally.
10:53:31 <jmcarthur> i like it, but only in a "that's a clever hack" sort of way ;)
10:54:01 <osaunders> :t fj.head
10:54:02 <lambdabot> Not in scope: `fj'
10:54:06 <PeakerWork> @let fj=fromJust
10:54:08 <lambdabot>  Defined.
10:54:11 <osaunders> :t fj.head
10:54:13 <lambdabot> forall a. [Maybe a] -> a
10:54:22 <jmcarthur> head is wrong ;)
10:54:29 <jmcarthur> this head would be partial
10:54:35 <jmcarthur> :t fj.listToMaybe
10:54:36 <lambdabot> forall a. [a] -> a
10:54:51 <jmcarthur> s/partial/total/
10:54:51 <osaunders> Shouldn't it be [a] -> Maybe a
10:54:57 <jmcarthur> :t listToMaybe
10:54:59 <lambdabot> forall a. [a] -> Maybe a
10:54:59 <PeakerWork> jmcarthur: totally partial!
10:55:07 <PeakerWork> (Maybe is a safer kind of partiality)
10:55:17 <jmcarthur> osaunders: the idea is that that should be the type of head and the fj. prefix makes it partial
10:55:27 <conal> jmcarthur: hm.  unsafeHead & unsafePerformIO  or  head and performIO.
10:55:37 <osaunders> What is partial? Does that mean it is conditional in some way?
10:55:49 <conal> jmcarthur: i like the idea that performIO is a partial function.
10:55:50 <jmcarthur> conal: that assumed that head [] = _|_ is "unsafe"
10:55:55 <jmcarthur> hmm
10:56:13 <jmcarthur> conal: but it's also not referentially transparent
10:56:34 <PeakerWork> conal: I think the reason unsafePerformIO gets a bigger scary prefix is because head may break into a bottom, and unsafePerformIO may expose evaluation order/etc, and the latter is just considered more dangerous
10:56:36 <ben0x539> It is also not typesafe, or at least induces type-unsafety, etc
10:56:37 <conal> jmcarthur: performIO is RT over its domain
10:56:50 <jmcarthur> hmm, interesting
10:57:04 <PeakerWork> RT?
10:57:13 <jmcarthur> referentially transparent
10:57:20 <Heffalump> what domain, the domain of IO actions that happen to be pure?
10:58:15 <conal> Heffalump: yes, or some decidable subset.
10:58:16 <pastah_rhymez> conal: how do you explain readFile then? e.g. that first time it succeeds and second time it gives IO Error
10:58:37 <conal> pastah_rhymez: see above
10:59:10 <pastah_rhymez> conal: how far above...
10:59:31 <conal> pastah_rhymez: "yes, or some decidable subset."
10:59:37 <pastah_rhymez> haha
10:59:41 <pastah_rhymez> nasty clause
11:00:22 <Berengal> The trouble is that there's no way to distinguish pure IO actions from impure IO actions in Haskell...
11:00:35 <Berengal> Well, there is. We call pure IO actions values...
11:00:37 <jmcarthur> not without some sort of special type, you mean
11:00:50 <jmcarthur> arguably, return 5 is pure
11:01:00 <ben0x539> Is pure IO not basically ST?
11:01:06 <conal> Berengal: probably not.  that's why "some decidable subset".
11:02:05 <conal> *lots* of IO actions are provably pure.
11:02:20 <Twey> Like ‘return’
11:02:20 <conal> (not just return)
11:02:25 <Twey> :þ
11:02:54 <jmcarthur> data IO p a where return :: a -> IO Pure a ; bind :: IO p a -> (a -> IO q b) -> IO (Mappend p q) b
11:03:04 <monochrom> and retern >>= return
11:03:18 <jmcarthur> where Mappend Pure Pure = Pure and Mappend anything else is Impure
11:03:56 <conal> jmcarthur: cool.  that's one simple example.  there are lots of other, less restrictive ones.
11:04:03 <jmcarthur> i'm sure there are many
11:04:53 <jmcarthur> conal: well, actually, i think that GADT (if you ignore my syntax errors) is not so restrictive.
11:05:15 <jmcarthur> conal: it depends on how restrictive the IO primitives you use with it are (other implicit constructors of the GADT)
11:05:20 <increpare> having mild confusion with existential types.  How do I write a function like f :: a -> (exists b. Show b => b); f x = "test" ?
11:05:45 <conal> jmcarthur: i'm thinking of pure compositions of impure components
11:05:50 <jmcarthur> conal: unless you think it should allow some cases of two impure actions making a pure action or something
11:05:53 <jmcarthur> conal: ah
11:05:55 <mauke> increpare: I don't think that's possible
11:06:06 <conal> :)
11:06:16 <jmcarthur> two wrongs making a right?
11:06:31 <conal> :)
11:06:54 <EvanR> so basically in haskell, if it compiles, it runs correctly ;)
11:07:01 <increpare> mauke: Hmm okay.  For some reason I always thought it was.
11:07:03 <EvanR> or so it seems so far
11:07:07 <jmcarthur> EvanR: well, we like to pretend ;)
11:07:18 <PeakerWork> increpare: You can write:  data Showable = forall a. Show a => Showable a  ;  f :: a -> Showable ; f x = Showable "test"
11:07:35 <jmcarthur> EvanR: it's surprising how much the haskell type system captures sometimes
11:08:06 <EvanR> yes it is ridiculous
11:09:32 <increpare> PeakerWork: ah yes, that's the twist I was looking for!
11:09:41 <PeakerWork> @type (<$)
11:09:42 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:09:43 <increpare> PeakerWork: thanks
11:09:59 <conal> for another large class of provably pure IO actions, consider the output of a correct compiler for a pure functional language.
11:10:57 <EvanR> jmcarthur: heres the network part of my mud server http://pastebin.com/m5b507f0f it exports a channel which produces player input, allows disconnecting players, get a diagnostic report, and recovers from errors (i hope)
11:11:51 <increpare> PeakerWork: ooh I like that function.
11:13:09 <PeakerWork> increpare: if you don't intend to use it in the context of showsPred or such, then Showable is almost the same as simply a ShowS value
11:13:20 <PeakerWork> increpare: but uses an existential+type-class, which is significantly more complicated
11:13:34 <PeakerWork> increpare: IOW, its quite a heavy encoding for something that is usually just a String
11:13:56 <PeakerWork> @src Show
11:13:56 <lambdabot> class  Show a  where
11:13:57 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:13:57 <lambdabot>     show      :: a   -> String
11:13:57 <lambdabot>     showList  :: [a] -> ShowS
11:14:19 <aavogt> conal: a compiler is free to use global variables and state all over the place when compiling a pure functional language
11:14:43 <aavogt> or you mean to take the output as a whole?
11:14:49 <PeakerWork> increpare: if you have:  class Class b where method :: b -> SomeType  -- then:   data Blah = forall t. Class t => Blah t  -- is pretty much a silly way to hold SomeType
11:14:51 <increpare> PeakerWork: well the 'show' thing was only an example function; I want to see if I can construct a function between two other (slightly more aribtrary) classes
11:15:01 <gwern> > let foo x y = if x==mempty then y else x in foo "" "foobar"
11:15:03 <lambdabot>   "foobar"
11:15:07 <gwern> > let foo x y = if x==mempty then y else x in foo "quux" "foobar"
11:15:08 <aavogt> rather than say, running individual functions (as in an import by FFI)
11:15:08 <lambdabot>   "quux"
11:15:16 <conal> aavogt: a provably correct FPL compiler produces a provably pure IO action.
11:15:24 <gwern> @hoogle '(Monoid a) => a -> a -> a
11:15:25 <lambdabot> Parse error:
11:15:25 <lambdabot>   --count=20 "'(Monoid a) => a -> a -> a"
11:15:25 <lambdabot>              ^
11:15:25 <PeakerWork> increpare: can you paste those classes? I have a hunch that existentials aren't necessary here
11:15:26 <gwern> @hoogle '(Monoid a) => a -> a -> a'
11:15:27 <lambdabot> Parse error:
11:15:27 <lambdabot>   --count=20 "'(Monoid a) => a -> a -> a'"
11:15:27 <lambdabot>              ^
11:15:32 <gwern> @hoogle (Monoid a) => a -> a -> a
11:15:34 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
11:15:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:15:34 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
11:15:47 <increpare> PeakerWork: yeah, but I might give myself a couple of minutes to figure out what you've already said : )
11:16:28 <conal> aavogt: regardless of the programming techniques used in the implementing the FPL compiler itself
11:18:29 <osaunders> @seen BONUS
11:18:30 <lambdabot> Unknown command, try @list
11:18:47 <Botje> preflex: seen BONUS
11:18:48 <preflex>  BONUS was last seen on #haskell 1 day, 3 hours, 9 minutes and 37 seconds ago, saying: why should that type have parameters?
11:19:19 <aavogt> conal: what I mean is that individual functions called by that compiler's main could be impure
11:19:43 <aavogt> so if you can arbitrarily reorder them  (as in importing individual functions), you can be impure
11:20:05 <conal> aavogt: i'm talking about a compiler for a pure FPL.
11:20:54 <aavogt> that's not the misunderstanding
11:21:16 <conal> maybe someone else understands what aavogt is trying to tell me.  i'm not getting it.
11:22:28 <PeakerWork> increpare: when you have:  exists a. (a -> T, a)  -- the only thing you can do with this value, is get a T out of it.  So I think that's isomorphic to T, but a whole lot more complicated
11:22:36 <aavogt> hmm, though I guess if you exported individual funtions from that pure FPL, the compiler would be incorrect if it applied any optimizations that broke purity of those functions (but not of some combination of those functions)
11:22:42 <sinelaw> conal, i've finished my preparatory report. it's not much, but it's here: http://www.ee.bgu.ac.il/~noamle/
11:22:58 <PeakerWork> increpare: and when you have:   (exists c. Class c => c) -- for the above-mentioned class, its really the same, so you really just have a SomeType
11:23:22 <aavogt> conal: I was making a special case where there is none
11:23:27 <conal> sinelaw: wow.  congrats!  i'll check it out.
11:23:41 <conal> aavogt: k
11:24:23 <sinelaw> @type when
11:24:24 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:24:40 <RayNbow> hmm, cann (R,+,*) be considered a field or not?
11:25:40 <maltem> RayNbow, are you askng if the real numbers with standard addition and multiplication are a field?
11:25:47 <RayNbow> yes
11:25:52 <maltem> Yes, the are.
11:25:57 <maltem> *they are
11:26:04 <RayNbow> but what about the multiplicative inverse of 0?
11:26:22 <maltem> A field doesn't have one
11:27:20 <RayNbow> I thought a ring doesn't have one?
11:27:57 <tensorpudding> rings don't have them either
11:28:35 <byorgey> RayNbow: Rings don't have multiplicative inverses at all.
11:28:43 <RayNbow> oh wait
11:28:44 <byorgey> Fields have all multiplicative inverses except one for 0.
11:28:44 <koeien37> byorgey: well, they may have
11:28:51 <koeien37> and fields are commutative
11:28:53 <byorgey> well, I mean they aren't required to.
11:28:57 <tensorpudding> if they are a division ring
11:28:58 <RayNbow> apparently my definition of fields was a bit off
11:29:32 <koeien37> 0 doesn't have a mult. inverse. you can quite easily see why not
11:29:37 <RayNbow> "Similarly, for any a in F **other than 0**, there exists an element a^−1 in F, such that a · a^−1 = 1." [ http://en.wikipedia.org/wiki/Field_(mathematics)#Definition_and_illustration ]
11:29:58 * RayNbow updates his knowledge
11:30:10 <koeien37> there is also the notion of "skew field", which is not a field
11:30:24 <koeien37> but that doesn't apply to the reals :)
11:30:57 <tensorpudding> skew fields are another name for division rings
11:31:13 <maltem> Yea if you ask for a multiplicative inverse of 0, where 0*x = 0 for all x, you won't get far
11:31:26 <koeien37> yes. and 0 != 1 in fields
11:32:20 <sinelaw> @hoogle when
11:32:21 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
11:32:36 <tensorpudding> also, rings can have a subset of elements that are invertible, these elements are called units
11:32:53 <conal> sinelaw: two "t"s in "Elliott", please.
11:33:09 <sinelaw> conal, oops, I'll fix that
11:33:19 * RayNbow is trying to figure out how to prove 0*x = 0 using the definitions of a field...
11:33:20 <conal> sinelaw: thx :)
11:33:52 <maltem> Btw are there any infinite fields that are not isomorphic to R or C?
11:33:56 <tensorpudding> use the distributive law
11:34:06 <koeien37> maltem: oh, lots
11:34:13 <tensorpudding> maltem: extension fields of Q
11:34:20 <koeien37> look at number fields
11:34:22 <tensorpudding> the p-adic integers i think
11:34:27 <lament> R^n ?
11:34:34 <tensorpudding> the gaussian integers
11:34:35 <RayNbow> x*(0 + 0) = 0 --> x*0 + x*0 = 0 --> x*0 = 0   -- something like this, tensorpudding?
11:35:01 <koeien37> lament: what is the inverse of (1,0) in R^2 ?
11:35:22 <conal> RayNbow: (a-a)*x
11:35:43 <maltem> Oh, I even forgot Q itself, heh. tensorpudding: An extension field is something like Q[X] modulo (X^2+1)Q[X] ?
11:35:51 <tensorpudding> oh wait, forgot, Z[i] isn't a field
11:35:58 <tensorpudding> just an integral domain
11:36:08 <koeien37> maltem: that is an algebraic extension of Q
11:36:13 <tensorpudding> Q[i] is a field though
11:37:02 <maltem> tensorpudding, the polynomial ring is a field? How can that be? Or is that the power series ring?
11:37:08 <lament> koeien37: good question.
11:37:36 <tensorpudding> Q[i] is {a+bi | a,b in Q} i believe
11:37:37 <maltem> koeien, ok, and what other extensions are there?
11:37:59 <increpare> PeakerWork: sorry for that.  was trying to strip down my code so i could understand what I was asking.  Ended up with a sketch of it here -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14475#a14475
11:38:06 <maltem> tensorpudding, oh ok, that would be isomorphic to Q[X] module (X^2 + 1)Q[X] then, I believe
11:38:25 <tensorpudding> yes, actually, it is an extension field of Q
11:38:43 <PeakerWork> increpare: you  mean type Vertices there?
11:38:47 <maltem> Stupid incosistent algebraic notations :P
11:38:52 <tensorpudding> there are also the constructible numbers
11:39:05 <increpare> PeakerWork: oops that should be Vertex not Vertices
11:39:12 <increpare> or Vertices not Vertex
11:39:12 <tensorpudding> and the algebraic numbers
11:39:37 <increpare> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14475#a14483
11:39:55 <tensorpudding> though the latter is also an extension of Q
11:40:03 <tensorpudding> just not a finite-dimensional one
11:40:14 <increpare> PeakerWork: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14475#a14484
11:40:14 <koeien37> http://en.wikipedia.org/wiki/Field_extension
11:40:22 <PeakerWork> increpare: what about Edges?
11:40:25 <koeien37> maltem: ^
11:40:55 <PeakerWork> increpare: well, with type families involved, I'd have to think more about the relationships there :)
11:40:56 <maltem> thx
11:41:21 <increpare> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14475#a14485 <- bah; still very rough
11:41:34 <increpare> PeakerWork: yeah, they seem to complicate things a little
11:42:18 <koeien37> maltem: there are algebraic and transcendental extensions
11:42:29 <PeakerWork> increpare: since you have makeGraph in there, its not what I thought.. do you plan to have an existential Graph instance value, and use makeGraph with its type?
11:42:39 <koeien37> Q(sqrt 2) is algebraic, Q(pi) is not
11:43:01 <increpare> PeakerWork: I expect each instance of Graph to implement its own makeGraph, so there should be no need for existentials
11:43:08 <gwern> @check \x -> let orIfNull lst backup = if null lst then backup else lst in (orIfNull "foo" x == head $ mconcat x)
11:43:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:43:11 <tensorpudding> there are fields of functions also
11:43:25 <increpare> PeakerWork: the only issue arises because I'm achingly close to being able to give a default implementation for skeletal
11:43:25 <gwern> @check \x -> let orIfNull lst backup = if null lst then backup else lst in (orIfNull "foo" x == head $ mconcat mempty x)
11:43:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:43:35 <PeakerWork> increpare: ah, ok.   I think every use of existentials I've seen - was eliminated by a slightly nicer/simpler representation
11:43:38 <gwern> > mconcat mempty "foo"
11:43:39 <lambdabot>   ()
11:43:57 <PeakerWork> increpare: But I can't prove if this is true in the general case
11:44:00 <gwern> > mconcat [mempty, "foo"]
11:44:01 <lambdabot>   "foo"
11:44:21 <gwern> > mconcat [mempty, "foo", "bar"]
11:44:23 <lambdabot>   "foobar"
11:44:33 <aavogt> @type mconcat mempty
11:44:34 <lambdabot> forall a. (Monoid a) => a
11:44:52 * gwern ponders. there must be some monoid way of doing 'orIfNull lst backup = if null lst then backup else lst' but shorter
11:46:05 <HaskellLove> I can go and create the bnf syntax for my language now and not worry about messing things up right? I mean, i want a multiparadigm language general solver... it will come down to semantics, and syntax i can do now whatever i want right? syntax is like an interface for semantics...
11:46:18 <aavogt> gwern: I don't think that's possible for any monoid
11:46:40 <gwern> aavogt: well, it's basically foo x y = if x == mempty then y else x
11:47:06 <aavogt> yeah, that adds  Eq m to the Monoid m
11:47:09 <gwern> every monoid supplies a mempty, and I'd be surprised if monoid didn't imply Eq
11:47:30 <gwern> (how can you not be able to compare mempty with mempty?)
11:47:58 <conal> sinelaw: another reference for image semantics is pan
11:48:00 <aavogt> instance Monoid (IO ())
11:48:01 <conal> @where pan
11:48:01 <lambdabot> http://conal.net/Pan
11:48:23 <osaunders> HaskellLove: See forth bullet http://gist.github.com/260610
11:48:28 <osaunders> *fourth
11:48:38 <gwern> aavogt: mempty would be return (); what would we lose by being able to do return () == return ()?
11:48:46 <sinelaw> conal, yes i realized that. Luke wrote his blog based on your ideas too. I'll update that.
11:48:49 <aavogt> also the (Monoid b => Monoid (a -> b))
11:48:58 <conal> sinelaw: thx
11:48:59 <sinelaw> (realized after finished writing)
11:49:00 <osaunders> The line feeds turned out really crap there.
11:49:01 <sinelaw> conal, if you refresh it should become corrected throughout the site (or re-download the PDF).
11:49:17 <aavogt> gwern: (putStr "oh hai" >> mempty) == mempty ??
11:49:38 <sinelaw> conal, and I've cited you quite a bit so i hope i didn't mis-interpret or say wrong things in your name :)
11:49:43 <Tim_M89> Hi everybody. What logo does you guys see here http://www.reddit.com/r/haskell. Does it look like a dolphin to you guys too or is that just me. It used to appear as the haskell lambda logo for me.
11:50:01 <Zao> Tim_M89: It's a narwhal.
11:50:03 <EvanR> in ghci how do i evaluate an expression that results in an IO action without executing the action
11:50:10 <increpare> PeakerWork: yeah, I can get where you're coming from.  I think I might be going OTT with my use of type families.  The current class in full, along with the incorrect 'skeletal' method, is here: http://ded.indiefaqs.com/~locus/doc/Kultur-Data-Graph.html
11:50:17 <conal> sinelaw: i'll check it out.
11:50:39 <Zao> According to the uncyclopedia, "The traditional language of the Narwhal is Haskell, an obscure yet functional dialect based on C++ templates and gonads. As a result, to human ears, Narwhals appear to speak in gibberish."
11:50:39 <Baughn> Tim_M89: No, that's a narwhale
11:50:39 <maltem> Tim_M89, you didn't know about the monadic narwhal operator???
11:50:52 <maltem> +e
11:51:13 <gwern> aavogt: so IO isn't a monoid then?
11:51:15 <maltem> oh, both spellings exist, ok
11:51:16 <conal> sinelaw: there are earlier refs for frp also, if you'd like them.
11:51:25 * Tim_M89 is looking up narwhale now
11:51:27 <aavogt> gwern: why can't it be a monoid?
11:51:52 <aavogt> well being more specific: (Monoid a => (IO a))
11:51:52 <sinelaw> conal, that would be nice for completeness' sake
11:52:03 <sinelaw> though i probably won't read them :)
11:52:21 <aavogt> gwern: I'm saying that you can have useful Monoids without Eq instances
11:52:22 <osaunders> HaskellLove: Refresh for nice line feeds.
11:52:39 <Baughn> "It was developed in 1969 by Donald 'Waddler' Duck, in collaboration with Adolf Hitler, while they were huffing kittens and planning to destroy the universe. " <-- I.. what?
11:52:45 <sinelaw> conal, it's good to have one place document all the references, though. do you mean the work you did in Microsoft before Fran?
11:53:15 <HaskellLove> osaunders wow thanks man, I definetly have the syntax disease... but it is because i dont know where to start from with semantics
11:53:24 <EvanR> Baughn: doesnt appear to follow uncyclopedias standards on 'humor'
11:53:27 <RayNbow> http://dpaste.com/135889/ <-- is this proof of x*0=0 sound?
11:53:47 <cognominal> does the last haskell work on snow leopard?
11:53:55 <conal> sinelaw: See ActiveVRML, MediaFlow, and TBAG papers on http://conal.net/papers/
11:54:10 <osaunders> HaskellLove: What is the purpose of this language?
11:54:45 <conal> sinelaw: ActiveVRML was FRP as its own ML-like language.  then i found haskell and switched to using it.
11:55:03 <HaskellLove> osaunders I am compiler engineer wannabe and i want to create my own multi paradigm general solver, will devote it 10 years definetly, full time first 3 years while in college and then work on it in free time
11:55:26 <osaunders> HaskellLove: BTW I advice that having I designed a programming language and never really got past the syntax decisions.
11:55:28 <lament> “Haskell is compiled from .hs-files which means HOMO SEXUAL”
11:55:36 <conal> sinelaw: TBAG was temporal programming with functions constraints and without purely declarative reactivity.
11:55:37 <pastah_rhymez> lament: true dat
11:56:04 <conal> sinelaw: and MediaFlow was similar but mainly for distributed multimedia.
11:56:29 <sinelaw> is MediaFlow related to DirectShow?
11:56:42 <osaunders> HaskellLove: Oh, I don't know anything about solvers.
11:56:53 <sinelaw> conal, or is any conceptual similarity between them a coincidence
11:56:59 <HaskellLove> osaunders what do you mean? have you written a language? solver, I meant a language :) so general purpose language
11:57:23 <conal> sinelaw: related in the sense that everything is related to everything.  but not particularly related.
11:57:51 <osaunders> HaskellLove: You want to write a general purpose programming language?
11:58:00 <conal> (sinelaw: not meant snarkily.  i just can't bring myself to say that two things are unrelated.)
11:58:15 <HaskellLove> osaunders yes, as i said first three years full time and then add as i have free time
11:58:43 <EvanR> HaskellLove: use haskell to make an interpreter for it. then youll have your language
11:58:57 <HaskellLove> EvanR what do you mean
11:59:12 <conal> sinelaw: TBAG & MediaFlow (done when i was at Sun Microsystems) were about pure functions of continuous time, using a polymorphic temporal algebra
11:59:17 <EvanR> your language -> haskell program -> result of your program in your language
11:59:31 <osaunders> HaskellLove: I have sort of written a language. I started the design for one which I then dropped after a while and started the implementation of another — an interpreter written in another high level language. It was mega slow but an interesting experiment.
11:59:41 <conal> sinelaw: working out tbag is how i learned to really appreciate backus's FP
11:59:53 <osaunders> I'm learning Haskell now so I can write a better version of that last one.
12:00:05 <HaskellLove> EvanR and the point of that is? I want mine to be multi paradigm so i cant see the point of doing that...
12:00:06 <sinelaw> conal, i tried reading through his paper, but gave up when he started delving into the particular algebra
12:00:13 <sinelaw> conal, am i missing anything important?
12:00:14 <lament> HaskellLove: for really small programming languages, consult #esoteric
12:00:34 <mm_freak> hi there
12:00:41 <mm_freak> can i integrate happstack with apache in some way?
12:00:59 <EvanR> HaskellLove: you dont seem to understand what im saying
12:01:06 <shapr> whee
12:01:08 <HaskellLove> EvanR nope
12:01:14 <osaunders> HaskellLove: Is your focus on the compiler design rather than the language design?
12:01:47 <HaskellLove> osaunders well both ...
12:02:17 <EvanR> a nice and vague ill defined goal
12:02:18 <conal> sinelaw: maybe.  i very much like the early philosophical part of the paper, including his critiques of (a) imperative programming (which applies equally well to Haskell's flavor) and (b) lambda calculus.  i like backus's discussion of functional-level programming (as opposed to the lambda calculus's back&forth).
12:02:26 <osaunders> HaskellLove: How long have you been programming?
12:03:26 <HaskellLove> EvanR as I said I dont expect to have it tomorow, will work full time on it three years, and later add stuff in free time... i say this like the 10-th time now i think
12:03:38 <lament> "How long have you been programming, young padawan?"
12:03:51 <HaskellLove> osaunders well like 5 years, but not professionaly yet
12:04:10 <EvanR> yes you have
12:04:27 <sinelaw> conal, i liked the philosophical part too. do you think Haskell's imperative flavor is a neccessary evil? I don't see an alternative for many cases, but that may be because I don't know about them
12:04:59 <nolrai_P> Okay I want access to a state, I want STRefs, and error handiling, and to be able to construct unique names. What monda combination do I need?
12:05:45 <Saizan_> nolrai_P: do you want the state to survive after the error or not?
12:05:54 <Saizan_> *an error
12:06:12 <osaunders> HaskellLove: Do you want to create a language that is better than the existing ones or are you content with one that includes all the features you happen to like? There's a difference.
12:06:35 <conal> sinelaw: i see Haskell's IO as having the problems backus discussed, no less than fortran (by backus also).  haskell packages imperative computation in a more sophisticated way, but doesn't change the semantics, and so inherits those problems.
12:06:47 <HaskellLove> osaunders I don't play a genius. I will collect already made stuff that I like and combine it in mine
12:07:01 <osaunders> Ah OK.
12:07:09 <osaunders> The other one is really hard!
12:07:10 <increpare> PeakerWork: (thanks a tremendous amount for your considerations; I'm off to get some food now)
12:07:26 <conal> sinelaw: and be careful -- it's possible (and very likely to me) that IO is "evil" (deeply problematic) *and* there isn't yet a viable alternative.
12:07:57 <increpare> In this context, I remember always finding uniqueness types to be rather lovely
12:07:57 <ezyang> "do no evil"
12:08:12 <HaskellLove> osaunders yeah you have to be in academia for the other one...
12:08:52 <sinelaw> conal, Well, with usable FRP on the horizon it may be that for _some_ classes of problems, the evil won't be necessary, at least when doing the high-level part
12:08:55 <HaskellLove> osaunders but I think as I go I will become researcher too, and push new borders, after it gets serious maybe 5 years from now
12:09:32 <conal> sinelaw: i also see frp as an alternative to imperative thinking.
12:10:22 <sinelaw> conal, can every system be described as a reactive one?
12:10:31 <PeakerWork> @type uncurry3
12:10:32 <lambdabot> Not in scope: `uncurry3'
12:10:38 <osaunders> HaskellLove: Cool. I'm on esoteric. I'll chat there instead.
12:10:49 <conal> sinelaw: in a pleasant way?  i don't know.
12:11:12 <nolrai_P> Saizan: nah, I can save the state out side of the monad, if it returned it with the error it could be in some weird inbetween state.
12:11:25 <conal> sinelaw: i do see frp as getting to the heart of what people want out of imperative programming, though -- change with time.
12:11:29 <PeakerWork> @hoogle (a -> b -> c -> d) -> (a,b,c) -> d
12:11:30 <lambdabot> No results found
12:11:50 <conal> sinelaw: without the semantic nightmare of nondetermism.
12:12:04 <merehap> PeakerWork: how would that work?
12:12:13 <merehap> oh, nvm
12:12:21 <yitz> conal: what's the current status?
12:13:05 <PeakerWork> @type \f (x,y,z) -> f x y z
12:13:06 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
12:13:21 <conal> sinelaw: in a sense the imperative paradigm's semantic problems come from mutation.  frp can be seen as removing mutation, but i like to also think of it as adding much more mutation -- continuous mutation.
12:13:22 <PeakerWork> @let uncurry3 f (x,y,z) = f x y z
12:13:23 <lambdabot>  Defined.
12:14:09 <conal> sinelaw: and with continuous mutation, the problematic nondeterministic interleaving of imperative concurrency is no longer applicable.
12:14:38 <conal> sinelaw: frp instead has deterministic continuous semantic concurrency
12:14:47 <conal> yitz: status of what?
12:15:15 <merehap> uncurry3 ((+) . (+)) (3,4,5)
12:15:16 <yitz> conal: frp becoming generally usable
12:15:21 <merehap> > uncurry3 ((+) . (+)) (3,4,5)
12:15:22 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
12:15:22 <lambdabot>    arising from a use of `GHC.Num.+'...
12:16:25 <dwon> Is is possible in ghci to do something like "import qualified Data.ByteString.Lazy.Char8 as L8"?
12:16:28 <PeakerWork> > uncurry3 (((.).(.)) (+) (+)) (3,4,5)
12:16:30 <lambdabot>   12
12:16:36 <conal> sinelaw: there used to be a lot more interest in learning to think about all computational problems in a purely functional/denotational way.  not so much since the haskell IO style was invented.  i agitate about the semantic woes of IO, in the hope of stimulating some new creative thought.
12:16:37 <yitz> dwon: not yet.
12:16:51 <dwon> yitz: thanks
12:16:56 <merehap> PeakerWork: yeah, you got it :)
12:17:11 <PeakerWork> merehap: (+) returns its result after 2 args, so you need ((.).(.))   to apply a function to its result of its result.. using result=(.), that's read as:  (result . result) (+) (+)  -- (apply (+) to the result of the result of (+))
12:17:16 <PeakerWork> @where SEC
12:17:16 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
12:17:20 <conal> yitz: i don't know.  "One is always a long way from solving a problem until one actually has the answer." - Stephen Hawking
12:17:47 <merehap> PeakerWork: yeah, got it, thanks
12:17:48 <conal> sinelaw: See the "opium den" remarks at http://conal.net/blog/posts/the-c-language-is-purely-functional/ .
12:18:17 <sinelaw> conal,  i've read that post, but it's never too late to read it again
12:18:58 <sinelaw> things are slowly precipitating into my mind
12:19:00 <conal> sinelaw: :) there's a lot of material in the comments
12:19:06 <sinelaw> yes, that too
12:19:33 <sinelaw> i've always thought of myself as a fast learner - but it turns out i'm a fast _shallow_ learner, unfortunately
12:20:53 <nolrai_P> sinelaw: that is true for me too.
12:21:32 <sinelaw> nolrai_P, yip. i know a little about everything
12:22:04 <nolrai_P> what does one use to get unique names, I have some vauge memory of it involving monads of some sort.
12:22:16 <sinelaw> conal, though learning electrical engineering gave me a really new point of view on building systems. they really DO do it functionally there
12:22:27 <nolrai_P> Also it is obviously some form os state.
12:22:37 <nolrai_P> sinelaw, really thats interesting.
12:22:39 <sinelaw> conal, ironically when e.e's go into software they start thinking imperatively because 'that's how programmers do it'
12:22:39 <conal> sinelaw: :) !
12:23:12 <conal> sinelaw: and doubly ironic when programmers (even haskell programmers) say that imperative thinking is inevitable because that's how hardware is.
12:24:00 <merehap> so why are all of the common CPU instruction sets imperative?
12:24:17 <yitz> conal: ok, let me put it another way. what do you think is, or should be, the current focus to make progress towards that goal? and how is that going?
12:24:19 <sinelaw> conal, yes. sequential systems have state, which does encourage imperative thinking
12:24:25 <dmwit> That's easy: it's because all of the common CPU instruction sets are imperative.
12:24:37 <PeakerWork> merehap: implementations are allowed to "cheat" when they implement pure functional interfaces :)
12:24:58 <sinelaw> conal, clocked sequential systems are the stage where people start thinking imperatively
12:25:45 <Twey> nolrai_P: Data.Unique?
12:26:02 <matt__f> :t liftM
12:26:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:26:22 <BMeph> As a former Electronics Engineering student, I can faithfully attest that those comments are spot-on. 'Struth. :\
12:26:30 <matt__f> why is the type variable 'r' ? in liftM?
12:26:57 <sinelaw> conal, I guess the register is equivalent to accumE? In reality it's a feedback system. What do you think about feedback? I've noticed that Reactive doesn't directly support it. although Yampa does
12:27:09 <yitz> matt__f: "result" maybe?
12:27:18 <conal> yitz: thx for clarifying.  hm.  there are difficulties in implementation, interface, and semantics.  as a general rule, i'd focus on semantics, since difficulties in the other areas are likely to be just symptoms, so fixing them hides problems rather than solving them.
12:27:58 <yitz> conal: ok so where is the focus in fixing semantics at this stage?
12:28:16 <conal> sinelaw: like Fran, Reactive addresses feedback by not addressing it -- ie by leaving feedback to the host language.
12:28:26 <conal> sinelaw: for simplicity/orthogonality
12:29:26 <conal> yitz: i'm not aware of any such focused work.  i've been mulling it over for a long time and have a variety of ideas.
12:29:52 <nolrai_P> can you save the ST state from con computation to another?
12:30:12 <sinelaw> conal, many reactive systems embody feedback as a basic property - FRP's model should simply no support it?
12:30:19 <sinelaw> *not
12:30:35 <nolrai_P> I just want to avoid using my own map..
12:30:36 <conal> sinelaw: yes!
12:30:40 <conal> sinelaw: if possible.
12:30:53 <conal> sinelaw: to avoid what i call "the curse of the special"
12:31:23 <conal> sinelaw: since we already have a very general & powerful model of "feedback" in functional programming.
12:31:53 <conal> sinelaw: so it'd be a shame to introduce a possibly ad hoc (special) one for temporal data types.
12:32:32 <conal> sinelaw: some people describe FRP as a paradigm different from FP, while i very intentionally designed it not to be.
12:33:05 <sinelaw> conal, you mean recursion, i assume (i'm still new to Functional Programming)?
12:33:27 <conal> sinelaw: yes.  and higher-level patterns.
12:34:13 <conal> sinelaw: "(explicit) recursion is the goto of functional programming" (erik meijer?)
12:34:14 <yitz> conal: so then, how would one start out getting involved?
12:34:29 <conal> yitz: are you interested?
12:34:42 <yitz> conal: of course. but i don
12:35:12 <yitz> 't have much time, so if it means diving into deep philosophy to start out with,
12:35:23 <yitz> I'm afraid it's not likely going to happen.
12:35:33 <nolrai_P> > iterate (+1) 1
12:35:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:36:30 <yitz> conal: I said that once here on #haskell, not knowing in my ignorance whether e.meijer or anyone else said it in the past.
12:36:45 <yitz> conal: some people got upset at me :)
12:36:58 <conal> yitz: hah :)  i bet they did.
12:37:15 <conal> yitz: i recommend to people that they take some temporal/reactive/interactive scenarios and play with the question of how to formulate them as math, with precision as simplicity.  don't think of the exercise as programming, since there are such deep mental ruts to fall into with programming.
12:37:51 <sinelaw> conal, btw i'm trying to do just that with a visual graph editor. http://www.ee.bgu.ac.il/~noamle/graphui/design.html
12:38:17 <conal> yitz: (partial answer to "how one would start out getting involved?")
12:38:42 <copumpkin> does anyone feel like dealing with http://www.reddit.com/r/haskell/comments/ag6bv/should_i_give_haskell_another_try/c0hhjul ? I'm at the airport and can't reply but it seems like someone should :)
12:39:09 <yitz> conal: perhaps true, but programming has the advantage of actually getting something done. as long as it is absolutely clear that will soon be thrown away and replaced.
12:39:10 <conal> sinelaw: i smiled when i noticed you were going for denotational design.
12:40:03 <conal> yitz: okay -- then program, with denotational design as the basis.  evaluate your design by the simplicity and flexibility of the denotation.
12:40:07 <sinelaw> conal, yes, i actually defined all my things mathematically BEFORE starting to program
12:40:49 <conal> sinelaw: yay!  then you won't fall into something like haskell's "sin bin" (SPJ)
12:41:05 <copumpkin> SPJ is our sin bin?? :O
12:41:08 <copumpkin> damn, that's harsh
12:41:13 <conal> hah!
12:41:13 <sinelaw> copumpkin, heh :)
12:41:44 <conal> SPJ's name for IO.  he points out that the purpose of IO is to hold everything that we don't understand.
12:42:16 * idnar recurses with a recursor
12:42:29 <sinelaw> conal, regarding "the curse of the special" - isn't accumE special?
12:42:37 <copumpkin> yeah :)
12:42:40 <sinelaw> (or whatever similar constructs you have)
12:43:08 <sinelaw> it embodies state implicitaly, which may be worse than Yampa's explicit feedback
12:43:16 <sinelaw> *implicitly
12:43:33 <conal> sinelaw: yes.  and if i knew how to replace it with a more general & already existing, i would.
12:44:25 <sinelaw> conal, maybe the fact that in electrical engineering they found nothing other than feedback, is a telling sign
12:44:32 <Mitar> how could i make some IO computation be run every 50 ms? (if it takes more than to compute it then it should be as fast as it can be run)
12:44:44 <PeakerWork> conal: what about "integral"?
12:44:58 <sinelaw> PeakerWork: that's just a continuous version of that
12:45:26 <sinelaw> still has state, implicitly
12:45:27 <conal> sinelaw: an example: VRML has scoping & parametrization mechanisms for 3D, which turn out to be weak/ad-hoc even for 3D, while doing nothing at all for sound & imagery.
12:46:08 <conal> sinelaw: yes.  telling, especially since math has such an influence on ee.
12:47:05 <conal> as i said before, frp doesn't eliminate state.  it adds *much* more state, replacing discrete change by continuous change.
12:47:59 <sinelaw> conal, continuous change means state? or where does FRP add state?
12:48:22 <PeakerWork> I think that if we had more type-classes, and Event a = ([] :. (Time,)) a (without the time), then those classes could perhaps contain something like "scanl" and then, scanl (and accumE, in terms of scanl) would just be the implementation for those classes
12:48:56 <PeakerWork> oops, by (without the time) I meant that the (Time,) part does not mean we have to penetrate two functors/etc to get at the "a"s
12:49:52 <PeakerWork> conal: If accumE was implemented in terms of scanlE, and scanlE was simply a Scan-class-morphism (for Events-as-lists), would that be acceptable as a non-special thing?
12:50:00 <conal> sinelaw: state is what changes.  and continuous change is more change than discrete change.
12:50:46 <sinelaw> conal, ok, so 'memory'
12:50:52 <conal> PeakerWork: yeah.  that's the sort of thing i go for -- replacing specialized building block by general/familiar ones.
12:51:30 <conal> sinelaw: hm.  sort of, but more like what-is, whether remembered or not.
12:51:56 <PeakerWork> sinelaw: Does foldl "have state"?
12:52:13 <EvanR> is there something like tryTakeMVar but with a timeout...
12:53:09 <sinelaw> PeakerWork, conal, the term I meant was really memory. It's defined as output being dependent on present AND past inputs (in terms of time)
12:53:28 <aavogt> EvanR: maybe there is, but an uglier way to do this is to fork another thread which delays, and then puts Nothing into the MVar
12:53:32 <Mitar> how could i make some IO computation be run every 50 ms? (if it takes more than to compute it then it should be as fast as it can be run)
12:53:37 <aavogt> using threadDelay
12:53:57 <sinelaw> so a 'continuously changing value' doesn't neccesarily have memory. accumE, integral, and feedback (with infinitisemal delay) does.
12:54:03 <PeakerWork> sinelaw: well, if you have  Event a = [(Time, a)] -- then accumE and foldl become pretty similar
12:54:04 <EvanR> aavogt: right, thats where im headed :S
12:54:16 <PeakerWork> sinelaw: "memory" is an implementation thing, not a semantic thing, though
12:54:21 <aavogt> EvanR: but perhaps there is a better way to coordinate your threads
12:54:41 <sinelaw> PeakerWork, i disagree. memory is a semantic thing when dealing with time-dependent systems
12:54:42 <conal> about improving FRP's semantic basis, i've been thinking about memory.  the original T->a model doesn't distinguish between access to the future and the past.  doesn't enforce what some folks call "causality", by eliminating access to the past.  but i don't really think we can access the past any more than we can the future.
12:54:51 <Mitar> but threadDelay will delay between calls
12:55:11 <EvanR> aavogt: an event queue needs to do something when the time of next event is reached, unless an event needs to be enqueued, then it needs to perhaps change its sleep duration...
12:55:26 <conal> even memory is a present thing, not a past thing.
12:55:30 <Mitar> not to try to call it in regularly independently of how long it took to compute IO computations
12:55:34 <sinelaw> conal, causality  - i think you meant denying access to the future
12:55:43 <aavogt> forkIO $ threadDelay 1000000 >> putMVar ?var Nothing
12:55:45 <sinelaw> conal, and isn't memory accessing the past?
12:56:00 <conal> sinelaw: thanks.  that's what i meant -- denying access to the future.
12:56:21 <aavogt> Mitar: and after forking that thread, you try to take the same MVar
12:56:41 <conal> sinelaw: we often think of memory as access to the past.  there's been a lot of research showing that memory is creative -- not a record of the past.
12:57:10 <sinelaw> conal, are you talking about psychology?
12:57:17 <conal> sinelaw: yes
12:57:22 <Mitar> aha, so one thread is forever looping and putting mvar
12:57:29 <shambler_> conal, that's a bit depressing
12:57:33 <conal> sinelaw: as a special case of a more general principle of design.
12:57:42 <sinelaw> conal, but does that apply also to a value that is calculated by (e.g) summing all past inputs?
12:57:44 <conal> sinelaw: namely "wwrd" -- "what would reality do".
12:57:58 <Mitar> the main one tries to takes it and then it clears it and does a computation and then it tries to take it again?
12:58:18 <EvanR> and creates another 'wake' thread
12:58:26 <conal> sinelaw: you do ee, so you know you can sum past inputs without remembering them all (at once)
12:58:52 <Mitar> aha, i see, mvar is empty after take
12:58:52 <Mitar> nice
12:58:54 <Mitar> thanks
12:58:55 <PeakerWork> sinelaw: I don't think it is a semantic thing -- I think time is only special w.r.t what conal said (enforcing causality) and otherwise similar to other things.  For example, if you represent Event a = [(Time, a)]  -- then accumE becomes much like foldl
12:59:13 <sinelaw> conal, that's right, but you need to remember that 'previous' result, which is still in the (immediate) past
13:00:03 <conal> sinelaw: now we're getting to the design puzzle i've been wondering about lately.  how small can we shrink this notion of immediate past?
13:00:07 <sinelaw> you = the system you're building
13:00:31 <conal> sinelaw: the present doesn't seem to be quite enough to explain integration.
13:00:43 <conal> sinelaw: but the past seems way more than necessary.
13:01:05 <sinelaw> conal, in ee for many problems it's a time that's short enough for the input to appear linear
13:01:07 <PeakerWork> that's straying a bit close to infitisimal delays...
13:01:14 <conal> sinelaw: maybe some sort of infinitesimal memory.
13:01:17 <sinelaw> "slowly changing"
13:01:41 <conal> PeakerWork: i have no problem with infinitesimal delay -- only with undefined non-infinitesimal delay.
13:01:44 <gnut> hi all
13:01:50 <sinelaw> conal, but that's in continuous systems. in discrete ones they have 'unit delays'
13:02:09 <conal> sinelaw: yes -- continuous systems.
13:02:35 <eugenn> I'm curious to see how lambdabot will handle this
13:02:37 <conal> sinelaw: i want to stay way clear of any discrete notion of time.
13:02:48 <eugenn> @pl (\a -> replicate a a)
13:02:48 <lambdabot> join replicate
13:02:50 <sinelaw> conal, so what if my system deals exclusively with discrete sequences? i'm not sure abondonment of discretness is desirable even at the semantic level
13:03:15 <sinelaw> it's not that time is discrete, it's that the  input is a discrete sequence
13:03:23 <sinelaw> each value appearing at some point in time
13:03:27 <eugenn> :t join
13:03:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:03:29 <PeakerWork> sinelaw: I don't think anyone suggests removing the ability to also represent discrete things
13:03:31 <conal> sinelaw: no problem.  you can faithfully model discrete on continuous.
13:03:52 <sinelaw> conal, in ee they use the dirac delta function ('impulse trains')
13:03:53 <eugenn> > join (+) 4
13:03:54 <lambdabot>   8
13:03:56 <gnut> anyone here using opensolaris and getting issues with cabal?
13:04:00 <copumpkin> > [1..] >>= join replicate
13:04:01 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
13:04:05 <pastah_rhymez> eugenn: h4xx0r
13:04:13 <conal> sinelaw: yeah.  i like that line of thought (dirac)
13:04:14 <gnut> where it can't delete directories in the /tmp directory after installation?
13:04:21 <PeakerWork> conal: I wondered about that -- do you mean you represent (Event a) via (Behavior a), for example, using the infinitesimal memory?
13:04:44 <PeakerWork> conal: oops: Behavior (Maybe a)
13:04:49 <EvanR> aavogt: in this simple scheme, old waker threads might wake me up before i wanted...
13:05:25 <eugenn> > [1,2,3] >>= join (+)
13:05:25 <conal> PeakerWork: if i saw how, yeah.  i'd *love* to eliminate the event/behavior distinction, in a semantically sound way
13:05:25 <lambdabot>   No instance for (GHC.Num.Num [b])
13:05:26 <lambdabot>    arising from the literal `1' at <inter...
13:06:23 <PeakerWork> conal: oh. I thought you had an answer, when you said "you can faithfully model discrete on continuous"
13:06:40 <sinelaw> conal, so why not use dirac's delta? Trying to think exactly how...
13:06:55 <PeakerWork> > [1,2,3] >>= (return . join (+))
13:06:57 <lambdabot>   [2,4,6]
13:07:03 <PeakerWork> > join (+) <$> [1,2,3]
13:07:05 <lambdabot>   [2,4,6]
13:07:32 <conal> my motivation to think along these lines is that FRP's denotational model is full of "junk", which may be a root cause for various symptoms.
13:07:51 <copumpkin> > (*2) <$> [1,2,3]
13:07:51 <lambdabot>   [2,4,6]
13:07:51 <eugenn> @src join
13:07:52 <lambdabot> join x =  x >>= id
13:07:55 <conal> i mean "junk" in the technical sense of containing non-denotable values
13:07:55 <copumpkin> zomg!
13:07:56 <sinelaw> conal, Event a = Behavior a, and if a behavior is meant to be an 'event stream' then you can model it as an impulse train of value a
13:08:07 <PeakerWork> conal: I am wondering why you are convinced that it is possible to model discrete on the continuous (Maybe I'm missing some basic mathematical background)
13:08:24 <eugenn> @src <$>
13:08:24 <lambdabot> f <$> a = fmap f a
13:08:26 <sinelaw> (which is a sum of delta functions translated in time)
13:08:29 <conal> PeakerWork: step functions
13:09:10 <tensorpudding> @src <*>
13:09:10 <lambdabot> Source not found.
13:09:19 <conal> sinelaw: to check: do you mean functions that are instantaneously non-constant?
13:09:22 <sinelaw> conal, I think the delta function is the basis. step functions are integrations of delta functions
13:09:22 <yitz> conal: step functions are integrals of dirac deltas
13:09:34 <tensorpudding> @hoogle <*>
13:09:34 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:09:38 <conal> yitz: yep
13:10:09 <sinelaw> (they also have the 'doublet' which is the weak derivative of dirac's delta, but i've never yet encountered a use for that)
13:10:43 <conal> sinelaw: i like your line of thinking.  the only frp+dirac work i know of is a paper by henrik nilsson.
13:10:47 <sinelaw> conal, I mean instantaneously non-zero, which is equivalent
13:11:16 <conal> sinelaw: got it.  thx.   and then generalize to other types (non-numeric)?
13:11:39 <sinelaw> exactly, for numericals they multiply the delta by the desired value (or function). we can do the same
13:11:41 <conal> "Functional Automatic Differentiation with Dirac Impulses" http://haskell.cs.yale.edu/yale/papers/icfp03/index.html
13:12:05 <sinelaw> thanks, added to reading stack
13:12:22 <PeakerWork> conal: step functions seem problematic to me, though that may just be because of my slightly implementation-skewed view :)
13:12:26 <copumpkin> sinelaw: a reading stack :O
13:12:32 <copumpkin> sinelaw: that's an uncommon reading model
13:12:49 <conal> PeakerWork: and impulses even more so.  if you think operationally, you'll expect to miss the pulses.
13:12:51 <merehap> well at least we know that he'll be reading that paper first...
13:12:55 <sinelaw> copumpkin, i often read first what was last pushed in
13:12:59 <sinelaw> copumpkin, but not always
13:13:04 <copumpkin> interesting :)
13:13:16 <merehap> a priority stack, you could say]
13:13:34 <copumpkin> lol
13:13:45 <copumpkin> what's the difference between that and a priority queue?
13:13:48 <sinelaw> merehap, i'm trained in ee, we only got as far as stacks
13:14:05 <sinelaw> merehap, well not really, but to justify myself
13:14:07 <PeakerWork> conal: I think I want a  (Continuous a -> [(Time, a)]) function that gets the steps -- and the partiality of it seems like it might introduce difficulty in modeling it
13:14:10 <merehap> copumpkin: ha, no idea
13:14:30 <sinelaw> PeakerWork, it's not partial, it's total on Maybe a
13:14:45 <sinelaw> PeakerWork, but i didn't get what you meant in that definition though
13:15:21 <PeakerWork> sinelaw: no need for Maybe,  its a list of just the changes -- consider the function:  isIrrational
13:15:41 <conal> so i wonder what a model of interactive behavior can be that is way less junky (non-denotable) than functions between time functions.
13:15:47 <sinelaw> conal, "in ee" they don't worry about missing pulses because impulses in nature are not instantanous
13:16:17 <sinelaw> and the system is designed to be sensitive enough for the energy of the given impulses
13:16:25 <monochrom> priority queue and heap are not that hard to learn.
13:17:09 <conal> so i wonder what is a model of interactive behavior that is much less junky (non-denotable) than frp's model of functions between time functions.  say something that has only infinitesimal memory or some such.
13:17:34 <sinelaw> conal, again "in ee", they stop worrying about time and use laplace-domain functions, but they have that luxury because they deal exclusively with numerical-valued time-functions
13:17:49 <sinelaw> maybe there is some sort of generalized equivalent for laplace-domain functions
13:18:08 <sinelaw> for any type
13:18:38 <monochrom> You need a measure, then use it to define integration.
13:18:43 <sinelaw> also, I don't see functions between time-functions as "junky" at all, if you leave accumE out
13:18:44 <conal> sinelaw: there are some great topics here for someone with an ee background and interest in frp.
13:19:04 <conal> sinelaw: did you get the technical meaning of "junk"?
13:19:17 <sinelaw> conal, i guess not
13:20:16 <sinelaw> conal, that's exactly why i imposed my frp-related project onto my senior year project here :)
13:20:17 <conal> sinelaw: it's one of two generally desirable properties of semantic models: abstractness and junk-freeness.
13:21:27 <conal> sinelaw: abstractness ("full abstraction") means indistinguishable things have the same denotation, while junk-freeness means everything in the denotational model is denotable (expressible).
13:22:39 <sinelaw> conal, oh that sounds familiar now. gotta go, though. very enlightening discussion about ee and FRP, though. I'll try to think more about that
13:23:04 <conal> sinelaw: and i'll read your project doc.  take care.
13:44:07 <jmcarthur> conal: is "junk-free" a common expression for that concept or did you define it that way yourself?
13:44:53 <jlouis> jmcarthur: with respect to some category theory?
13:44:56 <copumpkin> no junk, no confusion?
13:45:12 <copumpkin> FREEDOM!
13:46:50 <jlouis> "contains no junk" is a pretty common term when categorizing certain operations as universals
13:47:04 <copumpkin> yeah, that's what I was referring to :)
13:47:10 <conal> jmcarthur: a common expression
13:47:16 <jlouis> mmm, free stuff!
13:47:31 <EvanR> alright. so now im thinking about the embedded language for scripting the mud. code sitting in the world state needs to be interpreted somehow and used to control the world... i read that haskell is good at domain specific languages. where do i start? :S
13:47:58 <copumpkin> no junk, no noise sounds better than no confusion, I guess
13:49:37 <dons> EvanR: hmm. start with a set of library functions in haskell for doing what you need, then look at similar EDSLs for how to combine them as a language.
13:50:16 <EvanR> the first part shouldnt be hard
13:50:52 <EvanR> clearly there would be a parser... then... some way to execute it. or maybe its executed during parsing. or...
13:51:16 <sproingie> the language for scripting the mud is less likely to be a EDSL so much as a full blown language with separate compiler
13:51:27 <conal> EvanR: and think also about what it all *means* ("denotational design"), which will have a deep impact on how elegant it is to use.
13:51:32 <sproingie> that is if you want builders being able to program the mud
13:51:48 <EvanR> personally i have only gotten anywhere with bison / yacc, and while it was ok it wasnt the most pleasant experience...
13:51:58 <sproingie> parsec is much nicer
13:52:40 <EvanR> conal: yeah thats an issue.
13:53:12 <EvanR> i used moo. not sure how much if any inspiration to draw from that
13:53:24 <Cale> The universal mapping property is a good deal more useful than the no junk/no noise definition of a free object, but no junk/no noise has a certain intuitive appeal to it.
13:53:29 <conal> EvanR: in my experience, semantic awkwardness can be papered over but will only bite more subtly.
13:53:49 <Cale> I think that to really understand what the "no noise" part means, you really have to understand the universal mapping property though.
13:54:59 <conal> EvanR: and denotational design is the most focused way i know to get to the essence of a dsel.
13:55:00 <EvanR> i am sort of frightened that a possible design that pops into my head is a jquery style semantics, where the dom is isomorphic in some sense to the mud world...
13:55:21 <sproingie> EvanR: the mud world could use a novel design
13:55:51 <EvanR> i have the world defined pretty well since i spent a while on this using c
13:56:03 <EvanR> i know how i want it to 'feel'
13:56:11 <EvanR> just not how to program it form the inside
13:56:17 <EvanR> conal: this is interesting
13:56:19 <sproingie> one lesson i learned from moo is that the creative types don't want to write programs
13:56:42 <sproingie> they don't mind having all the power of a programming language, but they don't like being taken away from the VR to have to "drop down" to code
13:56:59 <merehap>  ["GHC 6.12 is out: http://haskell.org/ghc", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Hask
13:57:27 <sproingie> writing a mud based on powerful builder tools could let you skip the separate programming language and just keep it as a EDSL that powers the building tools
13:57:38 <conal> sproingie: bridging that divide is what motivates "tangible functional programming"
13:57:55 <Twey> Which is awesome.
13:58:18 <novas0x2a> how do you haddock function arguments for a function that is also a record field? (the basic syntax from http://www.haskell.org/haddock/doc/html/ch03s02.html fails with a parse error)
13:58:40 <EvanR> sproingie: builder tools?
13:59:06 <sproingie> EvanR: in MOO those would be stuff like @dig, @create, @message, etc
13:59:19 <EvanR> yeah
13:59:22 <sproingie> lambdacore had those and not much more
13:59:36 <sproingie> you had to get down into more low-level imperative stuff to do anything complex
13:59:39 <EvanR> heh the blank database doesnt have even that ;)
14:00:27 <sproingie> friend of mine ran a tinyMUD, as in the original tinyMUD codebase.  she was always real proud of the complex stuff she put together with nothing but flags
14:00:44 <EvanR> heh
14:01:17 <sproingie> she had puzzles consisting of flag checks and sets that reminded me of nothing so much as prolog
14:01:19 <dmwit> novas0x2a: The syntax given there WFM.
14:01:32 <sproingie> she refused to admit it was programming
14:01:32 <dmwit> novas0x2a: Did you maybe put the haddock comment before the '{'?  If so, that won't work.
14:01:43 <EvanR> can you elaborate on this denotional semantics
14:01:47 <Peaker> @unmtl ContT (StateT s) a
14:01:47 <lambdabot> err: `ContT (StateT s) a' is not applied to enough arguments, giving `/\A. (A -> a (StateT s)) -> a (StateT s)'
14:01:57 <EvanR> err denotional design
14:02:08 <novas0x2a> dmwit: let me pastebin, just a sec
14:03:09 <deech> Hi all, I am a noob and although Haskell has my complete attention now and I have also dabbled in Ocaml. One of the Ocaml list members, Jon Harrop, repeatedly claims that Haskell has serious performance issues with low-latency computing. I haven't noticed any, but I don't do high-performance computing either. Is there any validity to his claims?
14:03:49 <sproingie> harrop is a mean old crank who is obsessed with grinding an axe
14:04:03 <novas0x2a> dmwit: http://codepad.org/lv9to5pm
14:04:04 <dmwit> Harrop is funny. ^_^
14:04:08 <sproingie> any validity to his claims has to me weighed against the obsessive hatred he harbors
14:04:16 <sproingie> *has to be
14:04:22 <aavogt> he might not be lying though
14:04:39 <deech> Ah so there is some history here.
14:04:40 <sproingie> he was right, but he won't ever admit any circumstance that might mitigate his claims
14:04:48 <Heffalump> he often knows what he's talking about, but you have to look very hard to separate the truth from the invective or propaganda
14:04:49 <EvanR> conal: denotational design?
14:05:14 <mmorrow> deech: what Heffalump said
14:05:21 <EvanR> found a paper on it, reading...
14:05:33 <sproingie> he's not dumb but he is pretty well blinkered
14:06:07 <dmwit> novas0x2a: Oh, I don't know.  Haddock may not know what to do with that.
14:06:14 <Heffalump> deech: his business is based around F# and O'Caml, and he seems to have had some bad experiences with Haskell (though his explanation of those mainly comes out as insults rather than reasoned statements). So he definitely has an axe to grind.
14:06:21 <deech> mmorrow: Ok, so since I am not good enough to discern I'll just suspend judgement.
14:06:24 <dmwit> novas0x2a: Maybe it would make sense to file a bug on haddock's tracker.
14:06:26 <sproingie> i think haskell killed his dog or something
14:06:42 <EvanR> lol
14:07:02 <deech> sproingie: when you say he was right, do you mean that Haskell had issues in the past but not now?
14:07:06 <Heffalump> It's actually quite funny in a way: he keeps claiming on reddit that I lied to him about what my company was doing with Haskell, and when I ask him for some evidence of this he goes suddenly quiet
14:07:08 <novas0x2a> dmwit: will do
14:07:21 <conal> EvanR: see also http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
14:07:36 <deech> Heffalump: He doesnt seem to be very kind to the Ocaml folks either.
14:07:51 <Heffalump> deech: Haskell certainly does have plenty of situations where compiled code won't perform as well as you might hope, as do most high-level languages.
14:08:01 <Heffalump> If you tell us what situations you care about we can try to be more concrete.
14:08:02 <sproingie> deech: kind of.  his favorite is about haskell's map data structure and how woefully slow it is.  he won't consider alternatives more appropriate for functional languages
14:08:23 <sproingie> despite that it's not all that hard to create a pretty fast map data structure
14:08:24 <Heffalump> deech: that's a fairly new thing, because he's decided that F# is the future for him. If you look back a year or so he was much more positive.
14:08:26 <conal> EvanR: luke's blog post describes the general idea, and less specific to type classes.
14:08:54 <sproingie> the one in haskell's standard lib kind of sucks for speed.  kind of like how StdGen is slow for RNGs
14:09:11 <mmorrow> deech: well, what do you mean exactly by "low-latency"? no garbage collected language (that doesn't sacrifice performance in the general case for bounded GC time guarantees) can really be "low-latency". and in the case where the GC time /is/ bounded, it'll be slower than a non-bounded time GC in the common case.
14:09:24 <EvanR> sproingie: is it a constant factor slower? or something more serious...
14:09:53 <deech> Heffalump: Well I'm more on the web-app side of things. Harrop's claim that Haskell had  "unpredictable performance" was more of a concern because someday I'll want to scale my apps.
14:10:09 <Heffalump> the standard hash table type can have a linear slowdown due to the GC not implementing an optimisation known as "card-marking". But Simon Marlow has just fixed that and it'll be in the next release of GHC 6.12.2 AFAIK.
14:10:14 <mmorrow> deech: so if you mean low-latency in the sense that you need to soft-realtime stuff, neither haskell (nor ocaml) will fit the bill
14:10:43 <mmorrow> Heffalump: although JaffaCake just implemented this the other day
14:10:56 <mmorrow> so it's currently in HEAD
14:11:04 <Heffalump> deech: I think it's fair to say that it's harder to get a grip on the space (and thus time) behaviour of lazy code than of strict code. But it's not unpredictable, just more work on your part to do so.
14:11:08 <Heffalump> mmorrow: I said that :-)
14:11:22 <dons> deech: harrop doesn't write haskell code, as well. so his opinion is not based on any experience.
14:11:32 <mmorrow> Heffalump: heh, /me makes note to read complete sentences first, respond second ;)
14:11:45 <dons> mmorrow: well, there's the low-latency trading system presented at CUFP
14:11:57 <dons> galois does some low latency stuff (systems level) in haskell
14:12:07 <Heffalump> He actually seems incapable of writing Haskell code. He keeps going on about Haskell not having a generic parallel quicksort implementation, despite it being completely trivial to modify the existing sequential one on the wiki.
14:12:24 <Twey> And in exchange you get the ability to write naïve code and have it Just Work 70% of the time.
14:12:45 <mmorrow> dons: yeah definitely. i meant something like providing frames of sound data to a sound card in realtime or something
14:12:50 <dons> well, he also has an unusual business model, so he may have other issues.
14:13:17 <deech> mmorrow: I believe the most recent discussion of this "low-latency" issue had to do with a user who wanted to switch to Ocaml from C++ for a financial trading app. Harrop said that Haskell was the wrong tool for the job.
14:13:35 <sproingie> EvanR: it's a tree, so it's O(n log n).  kinda crappy when you want a hashtable
14:13:39 <mmorrow> deech: oh, bah. that's nonsense
14:13:39 <Heffalump> deech: got a link?
14:14:13 <dons> deech: http://www.starling-software.com/blogimg/tsac/s5/2009-09-01-icfp.html
14:14:15 <sproingie> it's a bit like lists, as functional idioms go, linked lists and trees are ideal.  for raw speed they ain't
14:14:23 <mmorrow> deech: if the app could be written in *any* GC-collected lang (that doesn't have a realtime GC, e.g. ocaml), it could be written in haskell
14:14:24 <dons> implementing a real time trading system (multicore) for the korean stock exchange
14:14:28 <EvanR> sproingie: and i heard to not use hash tables...
14:14:43 <sproingie> EvanR: nothing wrong with them
14:14:58 <EvanR> ah
14:15:01 <sproingie> they strike me as pretty darn functional if you ask me, using a hash function and all
14:15:10 <sproingie> especially if it's a perfect hash
14:15:12 <dons> write some stuff, it'll be fine. you don't have the mental issues harrop has :)
14:15:26 <Heffalump> sproingie: it's the single-threaded update that isn't very functional
14:15:32 <sproingie> well yeah
14:15:32 <Heffalump> functional code tends to use persistent data structures
14:15:37 <jmcarthur> hash tables are still useful, but vastly overrated
14:15:47 * hackagebot upload: HTTP 4000.0.9 - A library for client-side HTTP (SigbjornFinne)
14:15:55 <sproingie> agreed, would be nice to have one for the times where they're useful
14:16:07 <merehap> jmcarthur: yep, thats the moderate position I'm looking for...
14:16:11 <mmorrow> deech: but of course, if you can't afford not having bounded GC time, there aren't any mature functional languages that can provide that that i know of
14:16:12 <sproingie> it's also not hard to write them
14:16:40 <deech> Heffalump: I have it in my email but looking through the Caml-List archives and I don't see the complete thread.
14:17:10 <sproingie> possibly a bit tedious since you'd probably need a Hashable type class and you'd have to implement it for every key
14:17:21 <deech> Heffalump: But here's a link to the thread, Harrop's comments don't seem to be on there: http://www.mail-archive.com/caml-list@yquem.inria.fr/msg05315.html
14:17:29 <merehap> mmorrow: i didn't know there were any bounded GCs in common use
14:17:41 <Twey> What's this ThreadScope it mentions?
14:17:43 <merehap> not just for Haskell
14:17:53 <mmorrow> merehap: the only that I know of is Timber
14:17:58 <dons> deech: harrop doesn't offer impartial advice. really, don't give him the time.
14:18:13 <dons> Twey: ?http://code.haskell.org/ThreadScope/ ?
14:18:25 <eugenn> @src (^)
14:18:26 <lambdabot> x ^ 0            =  1
14:18:26 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
14:18:26 <lambdabot>   where f _ 0 y = y
14:18:26 <lambdabot>         f x n y = g x n
14:18:26 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
14:18:28 <lambdabot>                       | otherwise = f x (n-1) (x*y)
14:18:30 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
14:18:32 <Twey> Aha, that's the one — thanks, dons
14:18:32 <Heffalump> deech: I think I've found the other half of it, thanks.
14:18:45 <mmorrow> merehap: http://timber-lang.org/
14:19:14 <merehap> mmorrow: I've glanced at that, though I'll give it a deeper look now, thanks!
14:19:17 <sproingie> timber looks pretty neat
14:19:25 <mmorrow> merehap: it has a concurrent GC and the language has the concept of deadlines and time/etc built-in a primitive
14:19:30 <mmorrow> merehap: np :)
14:19:49 <deech> dons: While I don't always understand the content, the tone of his messages seems to be impartial. So I'll just ignore him until I can better understand what he is saying.
14:19:53 <increpare> anyone else finding hlint crashing occasionally at list comprehensions?
14:19:54 <deech> dons: thanks!
14:20:39 <dons> he attempts to present an impartial view in some forums, though he's primarily interested in selling his books on the technologies he advocates.
14:20:39 <Cale> deech: Yeah, I'm with dons on this one, Harrop is a well-known troll :)
14:21:04 <Heffalump> deech: I'm not sure quotes like "Erlang's performance sucks" are exactly impartial.
14:21:42 <increpare> PeakerWork: I managed to find a happy type-signature in the end (cf http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14602#a14602 )
14:22:07 <Peaker> increpare: ?
14:22:12 <Peaker> increpare: oh
14:22:16 <increpare> other peaker : P
14:22:21 <increpare> oh wait are you peakerwork?
14:22:26 <dons> he has some odd ideas about how to build a business in the internet age.
14:22:30 <Peaker> increpare: yeah, I am same one
14:22:41 <Peaker> increpare: so you converted to a record, instead of a type-class?
14:22:47 <increpare> Peaker: No, it's still a type-class
14:22:49 <Peaker> increpare: oh, wait I can't read
14:22:58 <Peaker> increpare: I think I'm too tired to read Haskell atm :-)
14:23:10 <Peaker> increpare: but no existentials, yay :)
14:23:11 <increpare> Peaker: hehe yeah I know that feeling...I'm in a similar state
14:23:15 <deech> Heffalump: s/seem to be impartial/don't seem to be impartial/
14:23:33 <merehap> dons: what, you mean like selling way overpriced books? :)
14:23:36 <Heffalump> ah, that makes more sense :-)
14:24:16 <Peaker> increpare: I'm thinking of being too tired to play SC and playing anyway :)
14:24:37 <increpare> Peaker: : )
14:24:54 <increpare> Peaker: Anyway, I'd like to reiterate my thanks.
14:25:07 <Peaker> increpare: sure, it was no trouble at all
14:25:14 <Heffalump> the other context to bear in mind when reading what he says is that he's completely focused on running numeric algorithms flat-out, and he doesn't really care or think about other applications except peripherally. So in the cases where what he says is true, it still should be considered in that context.
14:25:41 <jlouis> I should pimp my graphviz work more :)
14:26:04 <dibblego> I disagree, having your agreement by spicing his outright dishonesty with a spice of truth is exactly his tactic to forward his ulterior agenda
14:26:04 <EvanR> conal's paper on denotational design and type class morphisms is over my head. but i do see the need to correctly, elegantly reason about the design of mud programming...
14:26:35 <sproingie> the elegant and correct reasoning behind my haskell game project is "it's fun"
14:26:36 <dibblego> (and so should not be considered at all)
14:26:43 <EvanR> sproingie: heh ;)
14:26:48 <dons> we shouldn't talk about it. it's too ridiculous.
14:27:15 <dons> jlouis: did you talk to lemmih?
14:27:26 <dons> get some more devs
14:27:55 <jlouis> dons: not yet
14:28:26 <jlouis> I'd really like some more devs though
14:28:38 <EvanR> sproingie: well if i have some ideas and flesh out some semantics, do you think its ok for me to get feedback and tips from here? it wouldnt be completely haskell though...
14:28:52 <EvanR> theres a lot of smart people here
14:29:31 <sproingie> i'd love to see a haskell mud myself
14:29:46 <sproingie> i was pondering that but i'm doing a couple different game projects instead
14:30:26 <Peaker> sproingie: what games?
14:30:33 <sproingie> one being a zuma clone to learn FRP and basic opengl
14:30:48 <sproingie> the other being, well, dwarf fortress in haskell :)
14:31:01 <sproingie> not quite that ambitious, but a "sim roguelike" at any event
14:31:21 <sproingie> (rate)
14:32:22 <clarkb> gotta love google: http://stackoverflow.com/questions/822752/should-i-learn-haskell-or-f-if-i-already-know-ocaml/827594#827594
14:32:30 <knobo> in this state monad example: http://www.haskell.org/all_about_monads/html/statemonad.html. Where does the "get" in "getAny" get its state from, or the state argument?
14:33:10 <sjanssen> @src State
14:33:10 <lambdabot> Source not found. My brain just exploded
14:33:16 <mauke> knobo: from runState
14:33:38 <sjanssen> newtype State s a = State (s -> (a, s))
14:34:01 <merehap> why is hlint an untrusted package on Arch (yaourt)?
14:34:12 <sjanssen> knobo: State is just a wrapper around a function type, runState passes an initial state, which is passed through the whole computation
14:35:03 <knobo> aha.. then it makes sense. (maybe. I'll take a look)
14:36:01 <knobo> runState returns a function that takes one argument, and that will be the initial state.
14:36:15 <sjanssen> yes
14:36:19 <Botje> yes
14:36:33 <Botje> easiest to see if you try evaluating "runState get" by hand
14:37:08 <monochrom> > runState (put True >> return 'x') False
14:37:10 <lambdabot>   ('x',True)
14:38:01 <dmwit> get = State (\s -> (s, s))
14:38:05 <dmwit> runState (State x) = x
14:38:07 <dmwit> so...
14:38:17 <dmwit> runState get = \s -> (s, s)
14:38:35 <dmwit> hm, I'm not sure if that's really that enlightening. =)
14:38:42 <monochrom> > runState (get) a :: Expr
14:38:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
14:38:44 <lambdabot>         against inferred ...
14:38:52 <monochrom> Oh!
14:38:59 <monochrom> > runState (get) a :: (Expr,Expr)
14:39:00 <lambdabot>   (a,a)
14:39:03 <monochrom> heh
14:39:04 <dibblego> @type join (,)
14:39:05 <lambdabot> forall a. a -> (a, a)
14:39:33 <monochrom> > join (,) a
14:39:35 <lambdabot>   (a,a)
14:39:37 <monochrom> hehe
14:39:47 <knobo> I actually think I got it (after several DAYS!)
14:40:03 <knobo> But, if I can understand it, everyone can :)
14:40:05 <monochrom> mean time between brain explosion
14:40:43 <knobo> So there you go. Haskell is now officially not difficult anymore.
14:41:04 <EvanR> haha
14:41:33 <kmc> there was a low-latency trading system in Haskell presented at CUFP?
14:41:37 <kmc> i'd be very interested to see that
14:42:15 <knobo> I was on the edge of giving up.
14:43:02 <kmc> different people have vastly different definitions of "low-latency"
14:44:42 <dons> well, 5ms or something.
14:44:45 <EvanR> sproingie: after using haskell ive sort of given up on dynamically typed programming, i just see no point to it. but what does this mean for a mud language
14:45:04 <dons> kmc: http://www.starling-software.com/blogimg/tsac/s5/2009-09-01-icfp.html
14:45:14 <kmc> 5ms round-trip exchange to exchange?
14:45:14 <EvanR> is there a way to translate to / from haskells amazing type system
14:45:15 <kmc> thanks
14:45:18 <monochrom> dynamic type is poor man's dependent type.
14:45:19 <Peaker> sproingie: Zuma is exceptionally polished.. are you going for the same level of polish?
14:45:31 <jlouis> **5s monochrom
14:45:44 <EvanR> monochrom: dependent type?
14:45:44 <sproingie> Peaker: nope, i plan on using a lot of particles and framebuffer effects to make up for my lack of artistic skills :)
14:45:54 * monochrom 5s jlouis back
14:45:58 <kmc> EvanR, i don't totally agree
14:45:59 <sproingie> think zuma with a geometry wars look
14:46:07 <Peaker> monochrom: technically, maybe, but not in spirit :)  Their values don't meaningfully (to the developers) represent propositions..
14:46:11 <kmc> every time you use a sum type in Haskell, you put a little bit of the type into runtime
14:46:18 <kmc> the point is to do this as little as possible
14:46:24 <sproingie> EvanR: i think there's no reason a mud language couldn't be strongly typed, you just have to consider the interface
14:46:34 <kmc> hmm strongly != statically
14:46:49 <sproingie> sorry i mean statically
14:47:01 <sproingie> at the end of the day i tend to think static is "stronger"
14:47:04 <kmc> "Speed is important: tens of milliseconds make a difference."
14:47:05 <merehap> both in fact
14:47:06 <sproingie> except for C
14:47:30 <kmc> it's stronger in that things are forbidden earlier
14:47:34 <kmc> but the same set of things is forbidden
14:49:05 <QtPlaty[HireMe]> No one had an adquite definition of what "strong" ment in terms of a typing system and all it did was start flamewards.
14:49:30 <kmc> that's true, some words are best not used ;)
14:50:10 <EvanR> yeah strong / weak, i gave up on that one
14:50:17 <QtPlaty[HireMe]> Static and dynamic have decient definitions.
14:50:20 <EvanR> sort of like hybrid kernels
14:50:26 <mercury^> Is there ultrastrong* typing?
14:50:31 <SamB_XP_> well, whatever strong means, C doesn't really seem to have it, and C-- has even less of it ;-P
14:50:49 <kmc> QtPlaty[HireMe], yes, although any particular system may have a combination of static and dynamic checks
14:50:54 <EvanR> sproingie: interesting concept
14:51:00 <EvanR> about statically typed script ;)
14:51:25 <QtPlaty[HireMe]> kmc: Yes.
14:51:48 <QtPlaty[HireMe]> Though dymanic scope is mostly dead.
14:52:01 <kmc> dons, that's an interesting and encouraging presentation.  although it's still 3 orders of magnitude slower than some people would consider "high-frequency"
14:54:08 <HugoDaniel> i get to hear the "its too difficult" argument quite often
14:54:10 <HugoDaniel> :/
14:54:42 <Twey> kmc: But they write everything in assembly language and therefore don't care about PL development anyway.  ;)
14:54:58 <kmc> Twey, they write mostly in C++, but the rest of your statement holds
14:55:15 <Twey> Why would a performance maniac use C++?
14:55:15 <kmc> i think it's an extreme niche not worth competing for
14:55:26 <Twey> C or FORTH or something, I could understand
14:56:16 <kmc> you can't compare C and C++ for performance in a simple way, even if you fix one compiler
14:56:35 <kmc> there's a large subset of C++ which should be compilable with no overhead versus equivalent C constructs
14:56:59 <SamB_XP_> yeah, the choice between C and C++ is not generally made for performance reasons
14:57:01 <kmc> there are also some C++ features which will bite you in the ass performance-wise, such as execptions
14:57:23 <kmc> the choice is made because of the thought that C++ makes it easier to design large systems and still get C-like performance
14:57:24 <Twey> So if you're basically limited to C-style features anyway…
14:57:30 <qwr> hm, if you give up using strong, then what means giving error/exception on unsuitable types instead of doing something (possibly) stupid?
14:57:36 <mercury^> Exceptions are not more expensive than longjmp.
14:57:50 <kmc> Twey, depends what you mean by "C-style"
14:57:54 <SamB_XP_> mercury^: they might be somewhat
14:58:01 <kmc> the subset of C++ that i refer to is a large superset of C
14:58:07 <SamB_XP_> mercury^: depending on what you mean by longjmp
14:58:29 <kmc> mercury^, longjmp does not unwind the stack, call dtors, etc
14:58:29 <mercury^> What all could I mean?
14:58:30 <mmorrow> i think there's a distinction to be made between "low-latency" and "realtime"
14:58:33 <SamB_XP_> I mean, does your longjmp-using code have a huge chain of cleanup handlers ?
14:59:49 <kmc> Twey, for example, templates and operator overloading are entirely static features.  They are ill-advised features and there are many reasons to avoid them, but performance is not one
15:00:00 <mmorrow> longjmp just restores registers and jumps..
15:00:00 <Peaker> I don't think exceptions should really incur a serious penalty (beyond that of *correct* error handling C code!)
15:00:15 <kmc> they may however make it more difficult to see what your performance is, at a glance
15:00:34 <kmc> because things like "x = y;" can hide a tremendous amount of code
15:00:45 <mmorrow> C++ exceptions have to unwind the stack, and possibly call handlers along the way, and each handler might do some stuff, then re-propagate
15:01:17 <mmorrow> which needs embedded runtime stack-unwinding info etc
15:01:22 <kmc> indeed, the idiomatic style of writing exception-safe code in C++ makes extensive use of these handlers
15:02:21 <kmc> mmorrow, what's your distinction between "low-latency" and "realtime"?
15:02:53 <mmorrow> kmc: i'm not sure, i'm trying to think of one, which i initially thought was "on the tip of my tongue", but on second thought i'm not sure
15:03:09 <mmorrow> well, soft-realtime vs. hard-realtime has a definite distinction
15:03:13 <kmc> yes
15:03:20 <SamB_XP_> mmorrow: longjmp-using code can do more than just calling longjmp
15:03:25 <mmorrow> if a hard-realtime deadline is missed, then game over
15:03:37 <kmc> in finance it is typically soft-realtime, but the penalty is still rather steep
15:03:40 <mmorrow> people die, things break, etc
15:03:47 <mmorrow> kmc: right
15:03:55 <mmorrow> money
15:03:58 <kmc> every microsecond more it takes to respond directly costs you money
15:04:09 <sproingie> hard realtime is rocketry, industrial robots, etc
15:04:12 <kmc> yeah
15:04:14 <sproingie> where people DIE if you miss a deadline
15:04:21 <mmorrow> kmc: so i think my distinction is this:
15:04:30 <kmc> i think it's a question of step function penalty vs. smooth penalty
15:04:30 <koeien37> > join (*) 37
15:04:31 <lambdabot>   1369
15:04:45 <SamB_XP_> I didn't realize the distinction between hard realtime and soft realtime was so arbitrary
15:04:48 <kmc> there is no hard deadline in finance -- you just want "as fast as possible"
15:04:50 <mmorrow> soft-realtime implies low-latency (for some defined value of low), but low-latency doesn't necessarily imply soft-realtime
15:05:09 <merehap> it isn't arbitrary
15:05:11 <mmorrow> since low-latency says nothing about any deadlines that need to be met
15:05:18 <Peaker> SamB_XP_: I think soft realtime is about capping the average time, and hard realtime is about capping the worst-case time
15:05:20 <kmc> and in some shops that extra 10 us is worth a manyfold increase in dev time
15:05:43 <merehap> one of the direct consequences of hard realtime is that CPU usage can't top 70% at any given time, for example
15:05:45 <Berengal> @hoogle [(a, b)] -> ([a], [b])
15:05:46 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
15:05:46 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
15:05:47 <SamB_XP_> Peaker: you'd think soft realtime would be at least about almost-capping time
15:05:53 <kmc> Peaker, indeed, but many systems will care about various percentiles
15:05:59 <Berengal> Wow, it's even a prelude function...
15:06:00 <kmc> and about variance too
15:06:04 <SamB_XP_> merehap: huh ?
15:06:06 <mmorrow> SamB_XP_: e.g. a breathing machine's control software is hard-realtime, and a sound driver is soft-realtime
15:06:21 <Peaker> SamB_XP_: I guess there are varying levels of "softness" -- and the function is allowed to care at different levels about both average and worst-case times
15:06:26 <mmorrow> SamB_XP_: if the sound driver misses a deadline, it can just drop that frame
15:06:29 <merehap> SamB_XP_ : hard real time makes mathematical guarentees
15:06:38 <mmorrow> SamB_XP_: if a breathing machine misses a deadline, someone might die
15:06:48 <kmc> many traders are paid according to Sharpe ratio, which is (mean return) / (std dev return).  so predictability is good
15:06:49 <mercury^> Many systems that should be soft-realtime are unfortunately not even low-latency however.
15:06:54 <edwinb> it's hard-realtime if failing to meet a deadline is disastrous/makes the system useless [citation needed]
15:06:58 <SamB_XP_> mmorrow: that still seems rather more arbitrary than I was thinking
15:07:05 <mmorrow> mercury^: right, good point
15:07:07 <edwinb> but that's how I've always understood it, anyway
15:07:09 <Heffalump> kmc: by that measure, Madoff was exceptional
15:07:11 <mercury^> merehap: that 70% processor usage is arbitrary and unecessary.
15:07:19 <kmc> hehe
15:07:33 <SamB_XP_> I thought it was more like hard realtime is guarenteed to work unless you physically destroy the system
15:07:37 <merehap> mercury^: let me see if I can find a reference for it then
15:07:37 <mmorrow> SamB_XP_: the distinction is that if a deadline is missed,. the program is incorrect. you can miss deadlines in soft-realtime
15:07:44 <SamB_XP_> or cut off it's supply of power
15:07:48 <mercury^> merehap: 100% CPU usage is fine if all deadlines are always met.
15:07:49 <monochrom> A sound card for a mafia boss may have to be hard real-time, lest the designer will die in an "accident".
15:08:03 <merehap> how can you make a guarentee at 100?
15:08:13 <kmc> by knowing where every cycle goes
15:08:17 <SamB_XP_> mmorrow: ah, see, that's what I'm talking about
15:08:20 <merehap> there is no contingency ability, I'll see if I can find a reference
15:08:29 <mercury^> What kmc said.
15:08:37 <SamB_XP_> so, in some systems, the sound driver WILL be hard realtime
15:08:53 <mmorrow> SamB_XP_: if that's required, sure
15:09:04 <mercury^> There is really not much your reference can say except that "redundant processing power is good in case you were stupid and oversaw something"
15:10:13 <SamB_XP_> hmm, I think 2600 games are hard-realtime
15:10:41 <sproingie> they are by consequence of their design
15:10:47 <mercury^> What's 2600?
15:11:04 <mercury^> Ah, some console.
15:11:14 <mercury^> Yes, console games often have very good latency guarantees.
15:11:15 <sproingie> i doubt they they were rigorously specified
15:11:27 <SamB_XP_> it's an old videogame machine with about 256 bytes of RAM and video hardware which you had to instruct on a sub-scanline level
15:11:35 <sproingie> the 2600 had a a 1-byte frame buffer
15:11:37 <c_wraith> not just *some* console.  The first one with mass-market popularity
15:12:04 <sproingie> when you drew to the framebuffer, it would blit wherever the raster happened to be
15:12:26 <SamB_XP_> sproingie: it seems to have been a little bit more complicated than that ...
15:13:11 <kmc> you had only 1 clock per 3 pixels on the line
15:13:23 <kmc> there were 5 sprites (some single pixels) which were positioned by registers and were drawn for you
15:13:42 <SamB_XP_> ... but you DID have to structure your whole program around the beam's path across the screen
15:14:09 <mercury^> Sounds awesome.
15:14:19 <kmc> you also had a low-res "background" image that was (i think) 20 pixels smooshed out to half a screenwidth, with the other half either a copy or reflection
15:14:26 <Saizan_> that's almost an esolang
15:14:56 <kmc> and so you could sort of just set these up and go, but if you wanted a level of graphics better than "terrible" you would have to change these registers in the middle of a scanline to reuse stuff
15:15:14 <c_wraith> the thought of not having a whole framebuffer to work with terrifies me.
15:15:15 <SamB_XP_> kmc: but I believe you could update that partway through the scanline if you wanted to put something else in the second half ?
15:15:19 <kmc> http://www.io.com/~nickb/atari/doc/stella.txt
15:15:20 <kmc> yeah
15:15:55 <c_wraith> how many cycles did you get on h-sync?  on v-sync?
15:16:01 <SamB_XP_> Thrust+ does an awesome job in the face of such adversity -- it looks a great deal better than you'd think anything could under such constraints ;-)
15:16:01 <kmc> lots
15:16:31 <kmc> 5320 cycles at the end of each frame for VSYNC, VBLANK, and overscan
15:16:48 <SamB_XP_> c_wraith: well, the SMS/NES/SNES/genesis etc. didn't have framebuffers either
15:17:26 <SamB_XP_> but at least you could set up a whole frame's worth of graphics tiles to be displayed
15:18:14 <kmc> 22 cycles before each line, then 54 during the line
15:18:18 <kmc> which was 160 pixels wide
15:18:32 <dons> so i'm writing a little report on haskell in 2009, and was trying to think of notable new uses of haskell. i came up with: haskell for linux kernel modules, haskell dsls in the barrelfish os, haskell in seL4, ghc modified for the iphone, and haskabelle, haskell+isabelle.
15:18:44 <SamB_XP_> anyway, if you missed deadlines on the 2600 ... it would look pretty bad
15:18:44 <dons> can anyone think of other significant new uses of haskell?
15:18:53 <HaskellLove> "Standard ML provides strong support for algebraic datatypes. An ML datatype can be thought of as a disjoint union." anyone knows the difference between ML ADTs and Haskell's? I need a general overview kinda answer...
15:19:05 <c_wraith> yeah, I'd say that 2600 games qualified as hard realtime
15:19:15 <dons> well, similar, HaskellLove, though ghc supports generalized ADTs.
15:19:32 <dons> but this is just simple "sum types" you're talking about.
15:19:39 <sproingie> HaskellLove: haskell is descended from ML, so the ideas are the same
15:19:51 <HaskellLove> sproingie ah right, cool
15:19:53 <BenceF> heyy all
15:19:57 <kmc> i don't think ML has existential or universal fields in ADTs either
15:20:03 <jmcarthur> HaskellLove: Haskell's ADTs distinguish strictness and nonstrictness
15:20:05 <sjanssen> Haskell '98 doesn't either
15:20:13 <kmc> yeah
15:20:32 <sproingie> haskell has a lot more sauce
15:20:51 <mmorrow> SamB_XP_: yeah, if missing a deadline would cause the display of the game state to be borked, which in turn degrades the player's ability to play the game, i'd call that hard-realtime
15:20:58 <SamB_XP_> soy sauce? barbecue sauce? worcestershire sauce?
15:21:21 <sproingie> hard-realtime is such that the design of the system makes it IMPOSSIBLE to miss a deadline during normal operation
15:21:31 <mmorrow> SamB_XP_: the human ear won't notice if a sound frame or two is dropped while playing an mp3..
15:21:40 <sproingie> soft-realtime is you just do your damndest to meet the deadline
15:21:42 <SamB_XP_> mmorrow: yeah, not like Zelda which just starts missing frames when things get too computationally intensive
15:21:50 <mmorrow> SamB_XP_: heh
15:21:58 <mmorrow> Zelda rulz
15:21:59 <SamB_XP_> what is a "sound frame" ?
15:22:09 <sproingie> sample rate
15:22:24 <mmorrow> SamB_XP_: a unit of data you feed to the hardware
15:22:38 <mmorrow> (or get from the hardware)
15:22:40 <sproingie> packet i guess
15:22:47 <SamB_XP_> oh, I thought you fed it with a few KiB at a time ?
15:22:54 <c_wraith> Not in realtime audio
15:22:59 <knobo> in the State monad, get copies the state "s" over to the value "v" posistion in a new State "object", so that we can access it through the bind operator?
15:23:04 <sproingie> easier to talk about video and video frames
15:23:19 <c_wraith> Realtime audio gets rid of as many buffers as possible, to make recording more reliable.
15:23:28 <merehap> mercury^: ok, it was a specific hard real time scheduling algorithm, Rate Monotonic Scheduling, that has max CPU utilization of 70%
15:23:30 <c_wraith> (well, syncing multiple tracks, some live, some recorded)
15:23:48 <sproingie> realtime is about bounded latency
15:23:48 <sjanssen> knobo: I think your terminology is a bit confused, but that's similar to how it works
15:23:49 <SamB_XP_> c_wraith: what applications is this used for ?
15:23:54 <davidL> dons: data parallelism via the GPU?
15:24:00 <sproingie> doesn't necessarily mean fast, you could have a deadline of a minute per frame
15:24:14 <knobo> sjanssen: that's what I thought (about terminology)
15:24:34 <knobo> Could someone refrase it?
15:24:54 <c_wraith> SamB_XP_: applications that do multi-track recording, generally.  especially if they play some tracks which you record additional lines over.  You want those to be synced as tightly as possible, which means you want buffers as small as possible
15:24:56 <sproingie> not too many realtime systems operate that slow thow.  jiffy is probably the slowest most will tolerate.
15:25:14 <sproingie> 'cept video which is downright leisurely
15:25:38 <knobo> probably not. lol
15:25:56 <BMeph> SamB_XP_: You never mentioned chutney, tandoori or curry sauce... ;)
15:26:23 <SamB_XP_> sproingie: so, not videogames, then
15:26:40 <sjanssen> knobo: let's start at the beginning: State actions are functions which take a state value and produce a new state value and another value
15:26:47 <sproingie> videogames are soft realtime, usually 30fps
15:27:03 <c_wraith> sproingie: most video games are 60, now
15:27:08 <sjanssen> knobo: get is the State action where the "other value" returned is the state value that was passed in
15:27:18 <sproingie> pc anyway.  console games are typically 30
15:27:22 <SamB_XP_> sproingie: I mean, do they use this "realtime audio" stuff?
15:27:41 <sproingie> SamB_XP_: low latency in audio is handy but it's usually not a problem for games
15:28:10 <c_wraith> lots of console games are 60, now, too.  even on older systems.  especially anything heavily timing oriented, like music games or fighting games.
15:28:13 <BenceF> sound studios use realtime audio
15:28:17 <sproingie> you need low latency for things like soft synths where if your mixer is uneven you get a totally different sound
15:28:24 <BenceF> if your makin a game you dont need it
15:28:41 <SamB_XP_> c_wraith: well, the issue with 60 fps is that pesky interlacing
15:29:18 <mmorrow> SamB_XP_: a way to see it (for video games) is to imagine if that video game was the display for a pilot of a remote-controlled aircraft. if the software fails to deliver the visual info in such a way that the pilot can't prevent crashing, then that's a hard deadline (or a series of them, just aggregate them into one somehow) missed
15:29:19 <sjanssen> knobo: the bind operator combines two State such that both the resulting state and other value from the first action are passed to the second
15:29:22 <c_wraith> Yeah..  It requires an uneven buffer time.  But each half-height field is drawn independently
15:30:23 <SamB_XP_> well, maybe that's really more about the vertical resolution, I don't know ...
15:30:27 <mmorrow> c_wraith: although, frame-rate/related isn't necessarily the only thing that deadlines might be attached to
15:30:43 <napsy_> What book you would recommand for learning haskell for a guy that has lots of imperative programming experience but very few functional?
15:30:43 <mmorrow> it can be more abstract than that
15:31:07 <dons> davidL: yep, got it. thanks.
15:31:18 <mmorrow> "TODO: update aircraft altitude in a timely manner"
15:31:22 <mmorrow> "!"
15:31:25 <c_wraith> I play a lot of music games, and have looked at their internals a fair bit.  All input is attached to frames in all of Konami's music games.  (which is annoying if the bpm isn't a multiple of the frame rate)
15:31:33 <mmorrow> famous last programmer comment
15:31:41 <SamB_XP_> but I've recently noticed some Cube game(s) having scanline artifacts, which I don't think I'd seen before ...
15:32:05 <Berengal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5422#a5422 -- Iterative algorithm translated to functional... Ugly as hell
15:32:13 <merehap> napsy_: real world haskell was good for me
15:32:27 <SamB_XP_> (when used on a plain-old NTSC TV)
15:32:52 <BenceF> napsy_: im readin learnyouahaskell right now
15:33:06 <napsy_> what about Introduction to Functional Programming using Haskell (2nd Edition) ?
15:33:10 * Twey sees no definition of ‘point’
15:33:33 <Berengal> Twey: That should be "points"
15:33:37 <sproingie> LYAH is excellent
15:33:42 <Twey> Aha
15:34:04 <Berengal> There was a minor header I chopped off... unrelated things related to plotting the points and stuff
15:34:05 <BenceF> type Point = (Float,Float)
15:34:09 <BenceF> :d
15:34:19 <merehap> yeah, that is a better starting place than real world haskell, though since you asked for a book...
15:36:39 <knobo> sjanssen: I think I understand it. I just have to learn the terminology, which should be even easier :)
15:39:32 <merijn> I'm reading Yet Another Haskell Tutorial and it mentions uncurry/curry/flip without any real examples. I can see uncurry being useful, but I can't really think of any simple examples for the other two.
15:40:01 <sproingie> YAHT is not all that good
15:40:14 <Twey> YAHT is a little terrifying
15:40:20 <skorpan> YAHT is horrible
15:40:22 <skorpan> there, i said it
15:40:23 <Twey> I'd stick to RWH…
15:40:26 <sproingie> curry/uncurry are kinda useful with arrows
15:40:36 <merijn> Feel free to suggest better alternatives :p
15:40:36 <Twey> skorpan: Psht.  And there we were all being diplomatic and so on… :þ
15:40:41 <Twey> RWH
15:40:42 <Twey> @where rwh
15:40:42 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:40:42 <skorpan> LYAH
15:40:57 <sproingie> RWH is kinda uneven but good on balance
15:40:58 <Twey> LYAH if you like elephants and random asides >.>
15:41:00 <Berengal> flip is used all the time
15:41:09 <ray> :t flip (.)
15:41:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
15:41:21 <Twey> RWH if you like a good, solid introduction to real programming with Haskell, with lots of examples and serious practical exercises
15:41:23 <ray> caleskell lol!
15:41:26 <merijn> Berengal: Probably, but I'm having a hard time thinking of a concrete example
15:41:28 <ray> but still
15:41:45 <Twey> > succ . Just 5
15:41:47 <lambdabot>   Just 6
15:41:48 <Twey> Heh
15:41:53 <Twey> I'll never get used to that…
15:41:56 <sproingie> RWH starts great but then zips forward without explanations of key parts
15:41:59 <ray> it makes sense to me
15:43:17 <Berengal> > let dictionary = words "these are the words in the dictionary"; input = words "input from the user"; spellcheck = zip input (map (flip elem dictionary) input) in spellcheck
15:43:19 <lambdabot>   [("input",False),("from",False),("the",True),("user",False)]
15:43:32 <BenceF> Twey: who doesnt like elephants?
15:44:12 <BenceF> but im gonna check out rwh as well
15:44:20 <BenceF> starting
15:44:23 <Berengal> merijn: It's a simple transformation on the interface of a function. Bending it a bit to fit where it doesn't already. It's shorter than lambdas to do the same
15:44:23 <BenceF> right now
15:45:19 <merijn> Berengal: Ah, see that makes more sense.
15:48:50 <eugenn> @pl nTeces n f = foldl1 (.) (replicate n f)
15:48:50 <lambdabot> nTeces = (foldl1 (.) .) . replicate
15:51:46 <BMeph> > let rotateL n xs = uncurry (++) . flip . splitAt n $ xs in rotateL 4 [0..11]
15:51:47 <lambdabot>   Couldn't match expected type `(a, a)'
15:51:47 <lambdabot>         against inferred type `a1 -> ...
15:52:10 <BMeph> > let rotateL n xs = uncurry (flip (++)) . splitAt n $ xs in rotateL 4 [0..11]
15:52:11 <lambdabot>   [4,5,6,7,8,9,10,11,0,1,2,3]
15:52:44 <BMeph> I'm much more comfortable using 'swap' than 'flip' even after all these months... :)
16:01:44 <BenceF> if i make a new datatype is there a way to overwrite how it Shows?
16:03:18 <mauke> BenceF: it doesn't Show by default so there's nothing to overwrite
16:03:38 <BenceF> ok. and if i derive it from Show?
16:03:58 <O_4> BenceF: yeah, write your own Show instance, rather than deriving from Show
16:04:53 <BenceF> O_4: whats the syntax for it?
16:05:04 <mauke> instance Show YourType where show x = ...
16:05:27 <EvanCarroll> are there any plans to release a new version of haskell that is not compatable with the prelude?
16:05:30 <BenceF> mauke: thx
16:05:52 <dons> EvanCarroll: no.
16:07:03 <HaskellLove> If I have my compiler be a translator from my language to java for example... i mean, it comes down to a parser for my lang and actions to print java code. So, that is like cheating, i won't deal with activation records and what not i will just use java ... so that is kinda lame isnt it? :(
16:07:13 <sohum> :t swap
16:07:14 <lambdabot> Not in scope: `swap'
16:07:36 <BMeph> sohum: swap (a,b) = (b,a)
16:07:59 <sohum> BMeph: ah
16:08:09 <mauke> :t uncurry (flip (,))
16:08:10 <lambdabot> forall b a. (a, b) -> (b, a)
16:08:29 <O_4> HaskellLove: how is that lame?  You're going to be translating to some language at some point (whether it be LLVM assembly, assembly, parrot code or whatever)
16:08:31 <sohum> @djinn (a, b) -> (b, a)
16:08:32 <lambdabot> f (a, b) = (b, a)
16:08:36 <sjanssen> HaskellLove: all compilers are translators from one language to another
16:08:43 <BMeph> sohum: It's one of those "so easy, it's simpler to re-invent it than to put it in a library.
16:08:53 * sohum nod
16:09:04 <BMeph> "
16:09:58 <HaskellLove> sjanssen what if i want mine to be general multi paradigm... it will be limited to java syntax :( if i want real power i will have to do it manually in c and assembler?
16:13:12 <BMeph> HaskellLove: Well then by your logic won't it then have c/assembler syntax? ;)
16:13:15 <HaskellLove> i mean, i wont have control of low stuff like memory managment, interprocess comunication, register allocation and what not...
16:13:32 <HaskellLove> BMeph yes but i will have low level control
16:14:08 <BMeph> HaskellLove: Do you need low-level control? Or are you just uncomfortable not having it? :)
16:15:06 <HaskellLove> BMeph well i want to spend at least 10 years on that language so i might as well start properly with low level stuff... i want all paradigms in one general solver
16:16:31 * hackagebot upload: idris 0.1.3 - Dependently Typed Functional Programming Language (EdwinBrady)
16:16:33 * hackagebot upload: ivor 0.1.10 - Theorem proving library based on dependent type theory (EdwinBrady)
16:16:35 * hackagebot upload: ivor 0.1.10.1 - Theorem proving library based on dependent type theory (EdwinBrady)
16:16:58 <edwinb> Hmm, well that answers the question I was about to ask...
16:17:18 <edwinb> (namely, should I expect hackage to take several minutes to upload a package...)
16:19:42 * hackagebot upload: idris 0.1.3.1 - Dependently Typed Functional Programming Language (EdwinBrady)
16:19:58 * edwinb resolves to be more competent with hackage next time
16:20:16 <dmwit> idris, eh?
16:21:02 <dmwit> Hm, dependent types with IO?  Frightening.
16:22:11 <edwinb> and radical features like a compiler ;)
16:22:19 <gwern> hm. there must be some reason people don't consider IO to be a monoid
16:22:30 <dmwit> gwern: What's zero?
16:22:36 <mauke> gwern: wrong kind
16:22:38 <gwern> (), probably
16:22:45 <dmwit> gwern: () does not have an IO type
16:22:53 <gwern> IO () then? a no-op
16:23:10 <dmwit> IO () is a fine monoid.
16:23:39 <dmwit> In fact, for any monoid m, IO m is probably a fine monoid.
16:23:50 <dmwit> What were you planning on doing with that?
16:24:39 <dmwit> instance (Monad m, Monoid a) => Monoid (m a) -- seems writable
16:25:09 <mauke> that looks like it clashes with the list instance
16:25:17 <dmwit> most likely
16:25:41 <mauke> well, all types * -> * really
16:26:08 <dmwit> It only clashes for lists of lists.
16:26:14 <dmwit> oh
16:26:16 <dmwit> lists of monoids
16:26:23 <dmwit> Yeah, that's not really an awesome thing to write.
16:26:32 <mauke> no, all type constructors with kind * -> *
16:26:47 * dmwit nods
16:26:58 <gwern> dmwit: no, this was just some musing from an earlier discussion with aavogt
16:27:07 <gwern> I thought that one should be able to do mempty == mempty
16:30:47 <ssalkin> Hello, trying to use haskell-platform on ubuntu 9.04 with ghc 6.10.4 from the ppa, and running into problems installing template haskell because it needs base=4 but only specifies >=3 and less than 5.
16:31:13 <ssalkin> when I edit the .cabal file to specify 4 I get a zlib check failure on cabal install
16:31:36 <ssalkin> is there a way to make cabal install skip the validation on my alter tar.gz
16:32:07 <ssalkin> or cause it to accept a base version = 4 from the command line?
16:35:08 <ssalkin> all righty then ;)
16:35:14 <dmwit> dunno
16:35:23 <dmwit> But you can extract the thing yourself and...
16:35:24 <dmwit> welp
16:35:29 <dmwit> sorry
16:36:04 <dmwit> ?tell ssalkin You can extract the package yourself (with tar or whatever), then modify it and run cabal install inside the unpacked directory (with no arguments).
16:36:04 <lambdabot> Consider it noted.
16:40:06 <BMeph> I think we should have a "wait five minutes" advisory in the motd... :)
16:40:43 <dmwit> What surprises me is that people are *so impatient* that they won't even leave their IRC client running in the background.
16:44:14 <jajajap> is there a simple way to make takeWhile take one more element than it normally does (like takeWhile (<3) [1..] = [1,2,3])?
16:44:37 <dmwit> nope
16:44:41 <dmwit> There's dropWhile, though.
16:45:01 <dmwit> and split
16:45:07 <dmwit> > split (<3) [1..]
16:45:09 <lambdabot>   Couldn't match expected type `[t1] -> t'
16:45:09 <lambdabot>         against inferred type `(a ...
16:45:12 <dmwit> erm
16:45:14 <dmwit> :t split
16:45:15 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
16:45:18 <dmwit> :t break
16:45:19 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:45:25 <BMeph> span, perhaps? ;)
16:45:26 <dmwit> > span (<3) [1..]
16:45:28 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
16:45:31 <dmwit> yes =)
16:45:48 <merijn> Style question: Is there a common heuristic to decide between using "f $ x y z" and "f (x y z)" (assuming this is even the same as I think...).
16:45:48 <dmwit> > let f (xs, ys) = xs ++ take 1 ys in f . span (<3) $ [1..]
16:45:49 <lambdabot>   [1,2,3]
16:46:01 <jajajap> so everything in the first part of span, plus the first element in the second part
16:46:25 <dmwit> merijn: People seem to prefer ($) wherever possible, though I can't figure out why.
16:46:38 <dmwit> merijn: (Except where you mean (.), of course. ;-)
16:47:04 <green> Hi, beginner question: How to I compare a Type that was declared "Type Xtype = String" with a normal String... specifically I am trying to compare the result o fNetwork.BSD's getHostName with a known string
16:47:04 <lambdabot> green: You have 1 new message. '/msg lambdabot @messages' to read it.
16:47:29 <dibblego> green, by compare do you mean for equality? Then use ==
16:47:49 <dmwit> green: getHostName doesn't have type HostName.
16:47:58 <merijn> dmwit: Well, I was thinking f $ x y z was cleaner, then f (x y z) and some examples I saw. I think it's probably that it adds less visual noise
16:47:58 <dmwit> It has type IO HostName.
16:48:07 <dibblego> oh, didn't see that bit :)
16:48:10 <Drostni77> dibblego: I tried ==, but I get some expected class issues
16:48:11 <dmwit> Drostni77: There's a world of difference. ;-)
16:48:11 <merijn> s/and some/in some/
16:48:22 <Drostni77> dmwit: Thats true, either way I need to compare it :P How do I do so?
16:48:28 <dibblego> Drostni77, you want to compare a IO String to a String and get back a IO Bool
16:48:44 <dmwit> Drostni77: do { host <- getHostName; return (host == "foobar") } -- the most readable way
16:48:47 <BMeph> green: Note: Your Xtype type should have a tag on the RHS by which to identify it as an Xtype. I hope that is readable... :)
16:48:52 <dmwit> :t (<$>)
16:48:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:48:58 <dibblego> Drostni77, fmap (== theString) getHostName
16:49:13 <dmwit> (== "foobar") <$> getHostName -- the slightly more sophisticated way
16:49:17 <Drostni77> Wow, helpfulness overload! love this channel:)
16:49:42 <dibblego> (<$>) is a synonym for fmap
16:49:58 <Drostni77> cool
16:50:05 <Drostni77> thanks! lemme go try some of those implementations!
16:50:15 <dmwit> RAWK
16:50:25 <dibblego> note that you'll get back a result with the type IO Bool, not Bool
16:50:42 <Drostni77> can i use IO bool in a guard?
16:50:47 <dibblego> no
16:51:10 <dmwit> Drostni77: IO Bool is a type that happens to mention Bool, but is otherwise unrelated to Bool.
16:51:15 <tensorpudding> writing <$> instead of fmap doesn't always help readability
16:51:16 <dmwit> That is really the best way to think of it.
16:51:34 <Drostni77> ok, I can think of it like that, but how do I use it to choose what to do?
16:51:54 <dibblego> Drostni77, you can use do notation or functions such as fmap and (>>=)
16:52:03 <Drostni77> cool.  Thanks
16:52:05 <dmwit> do { answer <- somethingOfTypeIOBool; if answer then thingToDoWhenTrue else thingToDoWhenFalse } -- the most readable way
16:52:07 <HaskellLove> wow I am 6-th page on ML book and I feel lost, this did not happen with haskell, ml seems so unintuitive ... might be wrong...
16:52:23 <Drostni77> ok I'm going to apply this knowledge, also going to read up on the "<-" symbol <.< >.> <.<
16:52:35 <dibblego> Drostni77, specifically, look up do notation
16:52:53 <Drostni77> dibblego: thanks will do :)
16:53:04 <dibblego> np
16:53:14 <dmwit> (=<<) :: (a -> IO b) -> (IO a -> IO b)
16:53:22 <dmwit> This is the main way to deal with IO values.
16:53:34 <pikhq> Drostni77: As a starting hint: do {foo <- bar;baz} is equivalent to foo >>= \bar -> baz
16:53:37 <eugenn> what was the notation for fractions? I forgot
16:54:04 <tensorpudding> @type (1 / 2)
16:54:05 <lambdabot> forall t. (Fractional t) => t
16:54:11 <dmwit> So, if you have a way to do something with a Bool, i.e. a function (f :: Bool -> IO result), then you can deal with IO Bool's using (f =<<).
16:54:33 <monochrom> > 3%4 + 1%4 == 1
16:54:35 <lambdabot>   True
16:54:40 <monochrom> fractions
16:54:42 <dmwit> > 1%2 + 1/2 == 1
16:54:44 <lambdabot>   True
16:55:01 <dmwit> > 1/2 + 1/2 == (1 :: CReal)
16:55:03 <lambdabot>   True
16:55:08 <tensorpudding> @type (%)
16:55:09 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
16:55:10 <eugenn> thanks, but I guess it dowsn't work in Hugs
16:55:14 <tensorpudding> ratio?
16:55:20 <dmwit> ?index (%)
16:55:21 <lambdabot> Data.Ratio
16:55:28 <dmwit> eugenn: import Ratio, maybe?
16:55:29 <tensorpudding> must be an instance of Fractional
16:55:32 <monochrom> Ratio Integer = Rational
16:55:34 <dmwit> eugenn: Also, use ghci instead. ;-)
16:55:35 <eugenn> oh I'll try
16:57:17 <eugenn> Also, I have foldl' defined in the prelude. why does Hugs say 'undefined variable foldl'?
16:57:35 <c_wraith> foldl is in the prelude.  foldl' is not
16:57:57 <eugenn> but I have the prelude.hs opened in a text editor and I see it
16:58:11 <dmwit> Have you loaded that file in Hugs?
16:58:28 <eugenn> it's loaded everytime I launch it
16:58:34 <dmwit> I don't think so.
16:58:45 <c_wraith> are you sure you're editing the prelude that hugs actually loads?
16:58:49 <mux> foldl' is in Data.List
16:58:51 <c_wraith> Rather than a copy of it somewhere else?
16:59:54 <eugenn> i'm positive it's loaded. it's very weird.. or maybe i'm doing something stupid
17:00:10 <c_wraith> why are you editing the prelude?
17:00:19 <c_wraith> It's a library, not wher eyou put your own code.
17:00:45 <eugenn> I'm not editing it, I just opened to see how some functions are defined because i'm curious :)
17:00:56 <BenceF> ok i have data Book = Book {title :: String, price :: int}
17:01:00 <c_wraith> eugenn: oh.  then it's probably not exported.
17:01:08 <c_wraith> Just import it from Data.List
17:01:15 <Drostni77> thanks all :)
17:01:26 <BenceF> and show book = "its a book"  works fine
17:01:50 <BenceF> but how do i include the title ? for example
17:02:11 <chrisdone> pattern match on it
17:02:18 <chrisdone> do you know what pattern matching is?
17:02:23 <eugenn> that's it, I imported data.list and it works.
17:02:31 <mauke>   show book = "it's a book called " ++ show (title book)
17:03:01 <monochrom> show Book{t=title} = t
17:03:09 <BenceF> like   show _ title _ = "its a book called" ++ title    ?
17:03:29 <mauke> monochrom: that looks backwards
17:03:44 <chrisdone> BenceF: kind of, but you need the constructor to pattern match
17:03:45 <monochrom> Correction. show Book{title=t} = t
17:03:51 <mauke> BenceF: show (Book title _) = ... would be another way
17:03:54 * hackagebot upload: bsd-sysctl 1.0.5 - Access to the BSD sysctl(3) interface (MaximeHenrion)
17:04:12 <BenceF> ok im starting to get the hang of it
17:04:25 <BenceF> thanks all
17:04:30 <BenceF> haskell rules
17:04:58 <twanvl> how can I tell cabal not to use the latest version of a dependency?
17:05:10 <twanvl> data-accessor-template depends on template-haskell-2.4 or 2.3
17:05:16 <_Jedai_3> twanvl: you can add a constraint
17:05:25 <twanvl> but 2.4 doesn't built with ghc 6.10
17:05:25 <chrisdone> twanvl: you can specify the version, e.g. data-accessor-template==2.3
17:06:32 <twanvl> I am using cabal-install to install data-accessor-template, and that fails
17:07:01 <twanvl> it seems the .cabal file for d-a-t uses a flag "template_2_4" that determines which version of template-haskell it uses
17:07:15 <twanvl> is there some way to convince cabal-install to set that flag to false?
17:07:53 <twanvl> ah, adding a "-" does the trick
17:08:45 <yrlnry> ><'vc||
17:09:06 <yrlnry> hf
17:09:57 <mauke> parse error
17:11:53 <DerisionSnort> @pl \xs -> zip xs (tail xs)
17:11:53 <lambdabot> ap zip tail
17:12:19 <mauke> @quote ip`a.
17:12:19 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:12:50 <dmwit> I like that . trick.
17:13:12 <DerisionSnort> > ap zip tail $ "hello world"
17:13:13 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o'),('o',' '),(' ','w'),('w','o'),('o'...
17:13:17 * edwinb discovers that it would have been better to upload things having checked whether they worked with GHC 6.12
17:13:33 <DerisionSnort> @src ap
17:13:33 <lambdabot> ap = liftM2 id
17:15:04 <BenceF> works fine
17:15:22 <BMeph> @quote monad.blood
17:15:23 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:15:46 <BMeph> @remember edwardk ...unfortunately, nothing can stop someone from writing a monad tutorial. We've tried, there was blood everywhere.
17:15:46 <lambdabot> I will never forget.
17:15:59 <BMeph> Best. Quote. EVAR! ;p
17:16:06 <BenceF> is String just 'type String = [Char]' ?
17:16:13 <dmwit> BenceF: Yes, exactly.
17:16:23 <dmwit> BMeph: I'm pretty sure that was already in there.
17:16:34 <BenceF> so i can (x:xs) the hell out of it
17:16:34 <dmwit> BMeph: Did you mean ?quote monad.*blood ?
17:16:38 <BenceF> ?
17:16:41 <dmwit> sure
17:17:07 <mauke> @quote monad.blood
17:17:07 <lambdabot> No quotes match. I am sorry.
17:17:13 <mux> @seen dcoutts
17:17:13 <lambdabot> Unknown command, try @list
17:19:24 * BMeph shrugs
17:22:33 <DerisionSnort> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in let neighbors xs = zip xs (tail xs) in let phis = map (uncurry (/)) (neighbors fibs) in take 10 phis
17:22:34 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
17:22:55 <Paczesiowa> who understands definition (not usage) of TypeCast/TypeEq?
17:23:28 <kmc> > let fibs = ((0:) . scanl (+) 1) in zipWith (/) fibs $ tail fibs
17:23:29 <lambdabot>   Couldn't match expected type `[a]'
17:23:30 <lambdabot>         against inferred type `[t] -> [t]'
17:23:35 <kmc> > let fibs = fix ((0:) . scanl (+) 1) in zipWith (/) fibs $ tail fibs
17:23:36 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
17:24:02 <kmc> > let fibs = fix ((0:) . scanl (+) 1) in (!! 50) . zipWith (/) fibs $ tail fibs
17:24:04 <lambdabot>   0.6180339887498949
17:24:46 <mauke> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
17:24:47 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
17:27:11 <ezyang> Fair conjunctions aren't very fair...
17:28:58 <rovar_> i need to map outgoing request ids with incoming response ids in an async environment. I was thinking of using TMvar with a Data.Map. Would there be a better way?
17:29:26 <ezyang> I wonder what use-cases make favoring the nth choice 1/2^n of the time a good policy.
17:31:02 <asdf25> hi, does anyone have liskell working? it seems that the developer left the darcs repo in a broken state
17:33:18 <kmc> does the world have room for another Haskell tutorial? if so, how should it differ from (say) LYAH and RWH?
17:33:34 <mauke> it should be in elvish
17:33:35 <kmc> is there any document that teaches Haskell from first principles, without assuming knowledge of other languages?
17:33:41 <dmwit> ezyang: I assume that's just a mathematical convenience.
17:34:27 <kmc> rovar_, why a TMVar over a TVar?
17:34:52 <c_wraith> TMVar gives atomicity.
17:35:06 <c_wraith> You take it, you modify it, you put it.
17:35:22 <mauke> STM gives atomicity
17:35:25 <kmc> isn't that what STM gives you
17:35:29 <c_wraith> uh, that is
17:35:31 <c_wraith> consistency
17:35:32 <ezyang> dmwit: Well, it's making it hard for me to come up of an example where fair conjunctions are a win ^^
17:35:38 <c_wraith> if you use a TMVar, you can't lose an update
17:36:01 <ray> kmc: no, they all assume at least one natural language
17:36:06 <dmwit> ezyang: A win over what?
17:36:07 <c_wraith> if you use a straight TVar, you can lose an update in a t1 read, t2 read, t1 write, t2 write pattern
17:36:23 <kmc> c_wraith, right -- it's like a 1-element bounded asynchronous queue
17:36:26 <sproingie> it's hard to teach *any* language from first principles
17:36:41 <ezyang> dmwit: being clever with your problem space and making the search space finite
17:36:44 <sproingie> for people who can follow it, maybe SICP counts.  i don't know of many others.
17:36:47 <c_wraith> That's why you'd use TMVar for something that can be modified from multiple threads, though
17:37:03 <kmc> c_wraith, wouldn't you use "atomically" to wrap the read and wrap in both t1 and t2?
17:37:11 <kmc> doesn't that then prevent your lost write scenario?
17:37:16 <c_wraith> kmc:  not if they're different threads.
17:37:31 <kmc> c_wraith, then what's the point of STM?
17:38:28 <dmwit> ezyang: (As a side note, you can write (a | b | c | d) as ((a | b) | (c | d)), which gives all an equal shot at going.   Similar tricks apply to other numbers of choices.)
17:38:41 <dmwit> ezyang: But what if the search space isn't finite...?
17:38:46 <EvanCarroll> is there a better way to write this Data.Set.filter ("foo" `isPrefixOf`) $ Data.Map.keysSet a
17:38:46 <sproingie> atomicity doesn't prevent lost writes, it just prevents inconsistency
17:38:49 <c_wraith> STM lets you compose actions that need access to shared memory within a single thread.
17:38:58 <dmwit> ezyang: What if you know there's a lattice point that satisfies a predicate, but you don't know which one?
17:39:04 <kmc> sproingie, can you elaborate?
17:39:22 <sproingie> if you have multiple writers and you need to be aware of every time they write, you still need to coordinate them somehow
17:39:24 <c_wraith> You still need to be sure that your actions work properly when executed concurrently
17:39:41 <ezyang> dmwit: That's a good point, but it doesn't generalize to the infinite choices case.
17:39:41 <c_wraith> Which is why TMVar and TChan exist.  They do that hard work for you
17:40:04 <ezyang> dmwit: I'm looking for a good, simple problem in which the search space isn't finite and fair conjunctions give you a win.
17:40:17 <ezyang> All of the simple examples I've been playing with can be turned into finite spaces.
17:40:28 <sproingie> usually if you have multiple writers to a shared resource and aren't otherwise coordinating them, you don't care about lost writes
17:40:30 <dmwit> Lattice points can be turned into finite spaces?
17:40:33 <sproingie> usually you want just one to win
17:40:42 <sproingie> or at least all of them to eventually win
17:40:42 <HaskellLove> Just to share, In SML this is not curried: fun add(x,y)= x+y : int;  and this is curried function: fun add x y = x+y : int; Same goes for Haskell: let f a b = a+b and after that you can do this: map (f 5) [1,2,3,4], but if you do let f (a, b) = a+b you can't do map (f 5) [1,2,3,4], so the first one is curried and the second one is not, the difference? well of course, brackets on/off.
17:40:59 <ezyang> Well, I don't understand lattice points :-)
17:41:20 <dmwit> ezyang: just means points in a 2d space with only integer coordinates
17:41:32 <dmwit> (0, 0), (32, 56), (-3, 7), but not (pi, e)
17:41:35 <ezyang> Oh, ok. so, like, N x N is an example
17:41:49 <dmwit> yes
17:41:56 <ezyang> Ok. But I need a search problem on top of that.
17:42:14 <ezyang> I've done stuff like factors and pythagorean triplets, but those all turn into finite spaces.
17:42:24 <sproingie> HaskellLove: it's unusual in haskell to uncurry functions like that
17:42:34 <sproingie> without explicitly calling uncurry that is
17:42:42 <ezyang> once you fix a single variable.
17:43:06 <kmc> @hoogle forkIO
17:43:07 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
17:43:32 <sproingie> @hoogle fuckIO
17:43:32 <lambdabot> No results found
17:43:48 <dmwit> "Do the m'th and n'th prime numbers sum to two less than a Goldbach number?"
17:44:02 <dmwit> Where a Goldbach number is an even number that is not the sum of two primes.
17:44:05 <ezyang> Ha
17:44:09 <dmwit> =)
17:44:28 <ezyang> Is that a conjecture or something?
17:44:31 <dmwit> yes
17:44:34 <HaskellLove> sproingie give me example please
17:44:34 <c_wraith> I know of one goldbach number.
17:44:54 <dmwit> c_wraith: gotta be bigger than 6, sorry
17:45:00 <dmwit> should have said that in my definition
17:45:11 <kmc> @hoogle forM_
17:45:11 <c_wraith> dmwit: In that case, you need to prove the existance of a goldbach number first. :P
17:45:12 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
17:45:12 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
17:45:18 <dmwit> c_wraith: Why?
17:45:29 <dmwit> c_wraith: It's a well-defined search problem even if there is no answer.
17:45:36 <alp_> given a string
17:45:42 <ezyang> Wikipedia has a slightly different formulation "Every even integer greater than 2 is a Goldbach number, a number that can be expressed as the sum of two primes."
17:45:50 <c_wraith> dmwit: ah, ok then.  So long as you're not expecting an answer
17:45:56 <alp_> what's the most straightforward way to get all the subsequences of that string ?
17:46:07 <ezyang> In interest of being somewhat concrete, I guess I'd like my readers to be able to run the code and get an answer :-)
17:46:11 <dmwit> :t inits >=> tails
17:46:12 <lambdabot> forall a. [a] -> [[a]]
17:46:22 <dmwit> > (inits >=> tails) "abc"
17:46:23 <lambdabot>   ["","a","","ab","b","","abc","bc","c",""]
17:46:29 <alp_> haha makes sense indeed
17:46:31 <alp_> thanks dmhouse
17:46:33 <alp_> dmwit*
17:46:53 <BMeph> :t subsequences
17:46:54 <lambdabot> forall a. [a] -> [[a]]
17:47:01 <dmwit> ?index subsequences
17:47:01 <lambdabot> bzzt
17:47:08 <dmwit> :t Data.List.subsequences
17:47:09 <lambdabot> forall a. [a] -> [[a]]
17:47:10 <dmwit> neat
17:47:11 <BMeph> > subsequences "abc"
17:47:12 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
17:47:13 <sproingie> HaskellLove: an example of uncurrying?  easy
17:47:26 <alp_> @src subsequences
17:47:26 <lambdabot> Source not found. My pet ferret can type better than you!
17:47:29 <alp_> heh
17:47:34 <sproingie> > let sum = uncurry (+) in sum (1,2)
17:47:35 <lambdabot>   3
17:47:37 <HaskellLove> sproingie well yeah i had no need for it so far so...
17:47:47 <sproingie> HaskellLove: you might never need it
17:48:04 <sproingie> arrows use it
17:48:06 <BMeph> > let rotateL n xs = uncurry (flip (++)) . splitAt n $ xs in rotateL 4 [0..11]
17:48:07 <lambdabot>   [4,5,6,7,8,9,10,11,0,1,2,3]
17:48:24 <BMeph> HaskellLove: ^^ Another use. :)
17:48:33 <sproingie> uncurrying is handy when you also use zip
17:48:48 <sproingie> tho you can also just zipWith
17:48:54 <BMeph> zip, partition, splitAt, span, et al. :)
17:49:03 <HaskellLove> yeah those are cool
17:49:17 <dmwit> HaskellLove: doublify f g xs ys = f (uncurry g) (zip xs ys)
17:49:29 <dmwit> :t \f g xs ys -> f (uncurry g) (zip xs ys)
17:49:30 <lambdabot> forall a b c a1 b1 t. (((a, b) -> c) -> [(a1, b1)] -> t) -> (a -> b -> c) -> [a1] -> [b1] -> t
17:49:55 <dmwit> :t \g xs ys -> any (uncurry g) (zip xs ys)
17:49:57 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
17:50:08 <dmwit> :t \g xs ys -> all (uncurry g) (zip xs ys)
17:50:09 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
17:50:38 <ziman> @check (\p xs -> xs == (uncurry (++) . break p) xs
17:50:38 <lambdabot>  Unbalanced parentheses
17:50:44 <ziman> @check (\p xs -> xs == (uncurry (++) . break p) xs)
17:50:45 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
17:50:45 <lambdabot>    arising fro...
17:50:53 <alp_> dammit
17:51:01 <alp_> isn't there any "unique" function in Data.List ?
17:51:05 <dmwit> :t nub
17:51:07 <lambdabot> forall a. (Eq a) => [a] -> [a]
17:51:08 <sproingie> nub
17:51:15 <dmwit> :t Set.toList . Set.fromList
17:51:17 <lambdabot> Couldn't find qualified module.
17:51:22 <dmwit> :t S.toList . S.fromList
17:51:23 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:51:28 <alp_> thanks
17:51:35 <ziman> :t map head . group . sort
17:51:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:51:39 <dmwit> HaskellLove: Here's another that I've used from time to time:
17:51:48 <dmwit> :t \p -> uncurry (>) . join (***) length . partition p
17:51:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
17:52:02 <dmwit> ?let most p = uncurry (>) . join (***) length . partition p
17:52:04 <lambdabot>  Defined.
17:52:20 <dmwit> > most even [2..10]
17:52:21 <lambdabot>   True
17:52:25 <dmwit> > most even [1..10]
17:52:27 <lambdabot>   False
17:52:39 <Paczesiowa> :t join (***)
17:52:40 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:52:54 <Paczesiowa> :t join (***) length
17:52:55 <lambdabot> forall a. ([a], [a]) -> (Int, Int)
17:52:59 <dmwit> join (***) f (x, y) = (f x, f y)
17:56:27 <HaskellLove> fun f (x::y::z::zs) = z; you can do that in SML ... wow cool if you know one or two functional languages very well you will learn the rest easily, lot of things overlap
18:00:34 <kmc_> so can someone explain what "atomically" does, if it's not strong enough to glue together a read and subsequent write to a TVar?
18:00:42 <kmc_> (apologies if that message already went through before, my conn dropped)
18:01:34 <gwern> I like to think that by knowing haskell I already know sml
18:01:39 <gwern> and it's a matter of different syntax
18:02:41 * ezyang is sort of starting to wonder if fair conjunctions are actually kind of useless. 
18:02:47 <HaskellLove> gwern I dont doubt that
18:02:51 <ezyang> (in practice)
18:03:02 <gwern> fair conjunctions?
18:03:24 <ezyang> the >>- operator in the Logic monad.
18:03:33 <ezyang> I've been trying to think of a non-contrived use for them all day
18:04:44 <ezyang> They'd be more useful if they were triangular, as opposed to (1/2)^k
18:05:26 <c_wraith> kmc_: Really, I'd just think of it as "runSTM", that happens to require an IO context.  It certainly doesn't guarantee atomicity of the entire STM action with regards to other STM actions executing concurrently.  I guess it runs the internal TVar reads/writes atomically.
18:05:50 <kmc_> so what's the point of STM then?
18:06:10 <c_wraith> retry and orElse
18:07:07 <c_wraith> retry lets you declare that you don't like the state of the TVars you've read, and to back out all the changes you've made, and wait until one of those TVars changes.
18:07:22 <c_wraith> orElse lets you slightly modify the meaning of retry, in a very handy manner
18:07:46 <kmc_> c_wraith, in this chapter: http://book.realworldhaskell.org/read/software-transactional-memory.html
18:07:58 <kmc_> they run "atomically transferTest"
18:08:04 <kmc_> "The properties of atomicity and isolation guarantee that if another thread sees a change in bob's balance, they will also be able to see the modification of alice's balance."
18:08:20 <kmc_> that contradicts what you said about "It certainly doesn't guarantee atomicity of the entire STM action with regards to other STM actions executing concurrently."
18:08:34 <c_wraith> let me write a quick test case to make sure I'm telling the truth
18:08:52 <kmc_> well it's hard to test these things definitively
18:09:04 <kmc_> i have been testing and find no lost writes with 52 threads appending to a String
18:09:12 <kmc_> through a TVar
18:10:20 <ezyang> I wonder if the (1/2)^k implementation gives desirable space usage properties, though
18:11:18 <c_wraith> kmc_: compiled with -threaded, run with the correct RTS options?
18:13:12 <c_wraith> speaking of which, I don't have a good box to actually test this on either, since I don't have anything with true multiple cores, and I doubt hyperthreading would expose a lost write
18:13:44 <kmc_> yeah, built with -threaded, run with +RTS -N2, top shows it using most of two cores
18:15:41 <HaskellLove> isn't this same as foldr in Haskell, this is SML: reduce f b [i1, i2, i3] = f(i1, f(i2, f(i3, b)))
18:16:39 <c_wraith> hmm.  the RWH chapter certainly implies I'm lying.
18:17:19 <kmc_> as does the general design of the STM API
18:20:17 <c_wraith> Your example can be modified to look for retried writes using unsafeIOToSTM
18:20:31 <c_wraith> After what I've read now, I'm sure it'll show them
18:21:58 <DigitalKiwi> someone said a few days ago that ghc can't currently cross compile, will it in like near future, if ever, and are there other compilers that can?
18:22:49 <kmc_> DigitalKiwi, if you output unregistered C code from GHC, you could probably cross-compile it with your favorie C cross compiler
18:23:00 <kmc_> i think the iphone guys are doing this
18:23:03 <kmc_> performance will not be great
18:23:14 <kmc_> DigitalKiwi, YHC compiles to portable bytecode
18:23:43 <kmc_> you can interpret the bytecode on any machine, or possibly compile it for a spceific machine
18:24:03 <DigitalKiwi> does that stand for yet another haskell compiler or something else?
18:24:19 <DigitalKiwi> oh, york
18:26:24 <kmc_> c_wraith, oh, i'm sure there is plenty of retry
18:26:41 <kmc_> in fact if i use +RTS -N8 it makes no progress because it's constantly invalidating its own transactions
18:28:48 <kmc_> i think the idea of "atomically" is that if you have { thread 1 read; thread 2 read; thread 1 write; thread 2 write } then after the fact, both threads will recognize it and retry
18:28:58 <kmc_> and so of course if there is heavy contention you do not make progress, which is a problem with STM
18:29:33 <kmc_> but each "atomically" block is still executed atomically, if it ever goes through
18:32:18 <c_wraith> well, only one of those should retry, in that case.
18:32:37 <c_wraith> With only those constraints, the first writer shouldn't need to retry
18:33:08 <kmc> i was considering the scenarios where both threads are: atomically $ do { read; write }
18:33:41 <c_wraith> Yeah, I think only the second writer needs to retry in that case.  Since they both read the pre-write data.
18:34:46 <c_wraith> (all reads are only of values that have been written from a block that wasn't retried)
18:37:23 <DigitalKiwi> kmc: thanks
18:39:11 <HaskellLove> "You “open” the structure, incorporating its bindings into the current environment: open Matcher" you do the same thing in Haskell just with import right? And if you don't want it opened you use qualified, correct?
18:39:21 <HaskellLove> talking about SML^
18:39:47 <dons> HaskellLove: well, functors are more like existential values in haskell, implementing a typeclass.
18:40:03 <dons> the haskell module system is *much* simpler.
18:40:24 <dons> so the phrase above is corresponds to using an existential type.
18:40:30 <dons> approximately.
18:41:23 <HaskellLove> dons yeah the book says the module system is very powerfull, but i don;t know why yet, will keep reading... Haskell is much simpler in bad or good way?
18:42:08 <kmc> HaskellLove, the fancy uses of the ML module system map indirectly to several different Haskell features
18:42:45 <kmc> i don't think you can make it a simple matter of good or bad
18:43:17 <dons> i think it doesn't matter until you're about 5 years in.
18:43:23 <HaskellLove> kmc yes i know i meant, can it do something which Haskell can't regarding the module system, and what is the importance of having/not having that?
18:43:31 <dons> oh, they're entirely different.
18:43:36 <Thomas2> modules are straightforward until you start there isn't really a haskell equivalent to functors
18:43:46 <dons> in haskell, you use type families for that kind of effect.
18:43:50 <kmc> the ML module system can be used for things which are not possible using only the Haskell module system
18:44:02 <kmc> these things are possible using *other* features of Haskell, besides the module system
18:44:04 <ezyang> Hey folks, I'm running into a really strange bug in the logic monad.
18:44:05 <kmc> perhaps not all of them are
18:44:06 <ezyang> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14677#a14677
18:44:08 <kmc> it is not a direct mapping
18:44:08 <HaskellLove> Thomas2 what is that?
18:44:35 <Thomas2> that is an example of how hard it is to type when your internet chucks a spazz
18:44:35 <ezyang> If I run observeMany 100 $ fairFactorize' 32, I find all of the answers that I expect.  But if I run observeMany 100 $ fairFactorize 32, I only get the first two answers
18:48:07 <kmc> how many people in the world write Haskell code on a regular basis? order of magnitude?
18:48:21 <dons> how regular?
18:48:34 <ezyang> Is mzero punting choices that I'm expecting to be kept, or something?
18:48:43 <dons> every day? < 1000. in a year? 10-100k
18:48:59 <dons> btw, there were 450k downloads of the haskell platform this year.
18:49:04 <dons> and 800k cabal installs.
18:49:13 <kmc> 800k individual downloads from hackage?
18:49:17 <dons> yep
18:49:25 <dons> 140k last month
18:49:32 <dons> (all time record)
18:49:38 <kmc> cool
18:50:01 <dons> this year's hackage bandwidth http://darcs.haskell.org/mrtg/external-bandwidth-year.png
18:50:31 <kmc> ah it goes backwards in time
18:50:40 <dons> si.
18:50:43 <kmc> something really took off around May 1
18:50:50 <dons> haskell platform.
18:50:56 <kmc> cool :)
18:51:57 <kmc> hello phi
18:54:10 <ezyang> Single-stepping Haskell is so impossible :-(
18:54:43 <shotokan> god, haskell is still alive @_@
18:55:33 <dons> shotokan: welcome. do you have a haskell question?
18:55:43 <shotokan> no.. not really
18:55:52 <shotokan> I was just wandering around freenode
18:56:13 <dons> well, if you want to get haskell set up, visit haskell.org/platform for the 1-click installers.
18:57:41 <shotokan> hmm i'm seriously considering that
18:58:14 <Cale> ezyang: It's not impossible, but we don't have any tools for it.
18:59:00 <shotokan> is it possible to build any kind of GUI with it?
18:59:04 <HaskellLove> I will keep reading, but can someone familiar with both Haskell and SML, tell me top 3 exclusive super cool things in both languages, that the one has and the other does not...?
18:59:07 <Cale> shotokan: Of course.
18:59:20 <shotokan> great!
18:59:23 <ezyang> Cale: Well, there's the ghci "debugger"
18:59:40 <dmwit> HaskellLove: SML's module system is probably the big thing it has on Haskell.
18:59:48 <ezyang> I wonder if Dan Doel hangs out on #haskell
18:59:58 <HaskellLove> dmwit thanks, give me two more things
19:00:04 <Cale> shotokan: There's a fairly extensive binding to GTK 2 called Gtk2Hs, and WxHaskell which internally uses WxWidgets (but is a moderately thick abstraction over it)
19:00:06 <dons> shotokan: we have a rather excellent set of bindings to gtk+ called gtk2hs, as well as to QT or wxWidgets. there's a lot of info on gui programming.
19:00:07 * dmwit has never used SML
19:00:19 <dons> gtk2hs is where it is at.
19:00:24 <ziman> ezyang, i believe it's dolio
19:00:38 <shotokan> god there's even an OS written in haskell @_@
19:00:40 <shotokan> 'house'
19:00:41 <dolio> It is.
19:00:41 <ezyang> @seen doliio
19:00:41 <lambdabot> Unknown command, try @list
19:00:44 <dmwit> HaskellLove: Probably (without knowing for sure) the Haskell toolchain is more complete: libraries, profiling tools, debuggers, etc.
19:00:45 <dons> note, the new threadscope tool uses gtk2hs, http://code.haskell.org/ThreadScope/ as does bluetile, http://projects.haskell.org/bluetile/
19:00:46 <ziman> he's here
19:00:50 <HaskellLove> ezyang you talk about the type system signalling errors?
19:00:51 <ezyang> oh, cool
19:00:59 <ezyang> HaskellLove: No, the types check out.
19:01:14 <hellomynameisphi> hi, i am an non-programmer xmonad user who is having some trouble with cabal. where is a good place to ask about that?
19:01:14 <dons> SML doesn't have a significant open source or industrial community. so it lacks libraries and tools.
19:01:24 <dons> hellomynameisphi: in #xmonad probably. welcome!
19:01:27 <HaskellLove> shotokan name please, of the OS?
19:01:34 <shotokan> 'house'
19:01:38 * araujo points shotokan to http://www.haskell.org/himerge
19:01:46 <dons> himerge is a good example.
19:01:47 <dmwit> hellomynameisphi: Here is fine.  There's also #xmonad.
19:01:56 <shotokan> "Haskell User's Operating System and Environment"
19:02:15 <ray> HUOSE
19:02:35 <shotokan> no no
19:02:37 <shotokan> HOUSE
19:02:38 <shotokan> http://programatica.cs.pdx.edu/House/
19:02:40 <shotokan> ;~
19:02:45 <dons> house is just one of several projects. seL4 was designed in Haskell, and MS' Barrelfish OS uses Haskell for driver writing.
19:02:46 <HaskellLove> dons but, I am talking about fundamental language design, not about community/more features?
19:03:07 <dons> SML is one of the parents of Haskell.
19:03:26 <shotokan> guys, gotta sleep now
19:03:31 <shotokan> 1am here
19:03:42 <shotokan> see you tomorrow \o
19:04:13 <HaskellLove> dons yep, I ask here because I dont have time to go deep with both, so far i am like two weeks and somethin in haskell so... i hope haskell has like at least 90 % of SML
19:04:25 <dons> that's right.
19:04:35 <dons> you'll find sml easy if you learn haskell.
19:04:43 <HaskellLove> cool
19:04:49 <dons> they're very similar. though sml doesn't have the parallelism constructs.
19:05:29 <HaskellLove> well yeah haskell being younger it should be a lot better :)
19:05:49 <tommd> Its not just younger but it has a community that wasn't afraid to drastically change things.
19:06:07 <kmc> big features Haskell has that ML doesn't: laziness, enforced purity, typeclasses
19:06:23 <tommd> And people named Simon
19:07:34 <gwern> @quote sml
19:07:34 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
19:08:24 <kmc> then you can also compare libraries
19:08:38 <kmc> including fairly "core" things like the concurrent and parallel stuff
19:09:06 <kmc> big features OCaml has that Haskell doesn't: OOP, first class modules
19:09:49 <HaskellLove> thanks
19:10:19 <dons> big features haskell has that ocaml doesn't: libraries, open development, parallelism
19:10:35 <gwern> 'libraries' :)
19:11:04 <kmc> OCaml's metaprogramming facilities are somewhat fancier than Haskell's -- you can redefine concrete syntax with camlp4
19:11:12 <dons> the strength of the community is the deciding factor. it influences the viability of most parts of the toolchain.
19:11:27 <kmc> yeah, the Haskell community is wonderful :)
19:12:10 <mmorrow> kmc: um, /first/-class modules?
19:12:21 <kmc> perhaps they are not first-class
19:12:21 <mmorrow> kmc: did you really mean /first/?
19:12:27 <mmorrow> ok
19:12:30 <kmc> i am not a ML expert
19:12:36 <mmorrow> (SML's are second class)
19:12:51 <kmc> there are module signatures and parametrized modules
19:12:51 <mmorrow> first would mean you can pass around modules as runtime values
19:12:57 <kmc> yeah
19:13:16 <mmorrow> (which would make types runtime values by extension)
19:13:21 <gwern> thought modules were equivalent to typeclasses?
19:13:28 <dons> no no.
19:13:54 <dons> see "Modular type classes"
19:13:54 <dmwit> People have been trying to say what ML's module system is like in a precise way for twenty years or more.
19:13:58 <dons> for the precise comparison
19:14:12 <mmorrow> gwern: a typeclass (w/ associated data types) is kind of like a functor that you can only apply to a any given type exactly once
19:14:21 <mrd> a certain usage of modules is isomorphic to typeclassses
19:14:23 <dons> gwern: approx typeclasses with associated types + existentials, iirc.
19:14:28 <gwern> eek
19:16:51 <mmorrow> gwern: sacrificing the ability to have more than once instance of a typeclass for a given type allows the compiler to auto-generate all the dictionaries/equiv-given-its-typeclass-implem
19:17:19 <gwern> so how does sml handle multiple instances/modules?
19:17:24 <mmorrow> gwern: whereas the ML module system is more about giving /you/ a language to build systems of structures/modules/whatever-you-call-them
19:17:58 <monochrom> In SML you instantiate manually, so to speak.
19:18:21 <mrd> gwern: structure I = Functor (args...)
19:18:48 <gwern> monochrom: so you supply the module-thingy and that's where it comes from at runtime?
19:18:52 <monochrom> Have one signature S and multiple modules X,Y,Z all implementing S. Then you have to say you want X.
19:18:59 * BMeph wishes it were possible to differentiate brtween different instances of a typeclass (e.g. Monoid) by other criteria than types...
19:19:09 <BMeph> *between
19:19:22 <mrd> gwern: not at runtime
19:20:50 <mmorrow> gwern: signature Mapping = sig {type From; type To; map :: From -> To}
19:21:25 <mmorrow> signature Foo = sig structure (M:Map); structure (N:Map) with M.To = M.From
19:21:34 <mmorrow> err, ..
19:21:41 <mmorrow> .. with M.To = N.From
19:21:44 <kmc> you can do all this with existentials in Haskell, right?
19:22:02 <mmorrow> kmc: existentials give you "sharing by construction"
19:22:06 <kmc> data Mapping = forall from to. { map :: from -> to }
19:22:10 <kmc> err with a ctor
19:22:15 <mmorrow> whereas modules give you "sharing to specification"
19:22:22 <kmc> sharing of what?
19:22:27 <mmorrow> kmc: types
19:22:41 <mmorrow> as in, they're equiv because you require them to be
19:22:49 <mmorrow> but NOT in the def of that signature/structure
19:23:06 <mmorrow> some /later/ user might add this requirement because that's what he needs
19:23:16 <mmorrow> but /you/ don't have to predict this
19:23:23 <mmorrow> with existentials, you do
19:23:26 <kmc> i don't follow exactly
19:23:37 <kmc> equivalence of what?
19:23:45 <mrd> abstract types
19:24:25 <mmorrow> kmc: basically, with existentials and sharing-by-construction, making a later change to things requires non-local-to-that-module-changes
19:24:52 <kmc> what sort of change?
19:25:46 <mmorrow> one sec
19:27:06 <mmorrow> kmc: the second paragraph in the "Conclusion" section of this is kind of an explanation of what this means
19:27:08 <mmorrow> http://research.microsoft.com/en-us/um/people/simonpj/papers/first-class-modules/index.htm
19:27:42 <mmorrow> "The biggest deficiency of our system is that programs are subject to non-local changes when making a previously con-crete types abstract. Not only must record types be changed to parameterise over such types, but all uses of those record types must be similarly changed to encode the appropriate propagation of type information."
19:28:37 <mmorrow> signature Foo = sig {type A; type B; type C}
19:28:54 <mmorrow> signature Bar = sig (X:Foo) (Y:Foo) with X.A = Y.C
19:29:04 <mmorrow> signature Bar2 = sig (X:Foo) (Y:Foo) with X.C = Y.B
19:29:10 <mmorrow> signature Bar# = sig (X:Foo) (Y:Foo) with X.C = Y.C
19:29:33 <mmorrow> each of those would need different type definitions of Foo entirely
19:29:40 <mmorrow> with existentials
19:29:50 <mmorrow> actually, no
19:30:12 <mmorrow> they'd need that + to be defined simulataneously with their version of Foo too
19:30:37 <mmorrow> hmm, that's not quite it either.
19:30:46 <mmorrow> this doesn't map exactly to datatype defs
19:30:52 <mmorrow> since this is a module-level thing
19:31:07 <mmorrow> and you can name the types contained in structures directly
19:31:56 <dons> maybe 5 years ago we used to be far more worred about a weak module system than we are now.
19:32:14 <dons> i wonder why it hasn't turned out to be the issue that was feared.
19:32:36 <dons> maybe knowledge of how to fake various bits has become widespread enough that it doesn't matter.
19:32:37 <mmorrow> dons: :o this is the number one concern of mine about haskell, personally.
19:32:57 <dons> you're not able to build some systems that you'd like to?
19:33:03 <sproingie> my personal #1 concern is still documentation
19:33:14 <dons> i think my point is that i used to be worried, and now i can build everything i want without worrying.
19:33:23 <mmorrow> dons: large projects could be much cleaner at the module-level
19:33:24 <dons> sproingie: there's 10k+ pages of haddocks :)
19:33:28 <dons> mmorrow: right.
19:33:36 <mmorrow> dons: but this only really becomes an issue with >50 modules
19:33:41 <sproingie> API docs with no examples
19:33:56 <dons> lack of examples is a problem, lack of api signatures isn't.
19:34:14 <dons> i would like to know if that's particularly a problem here, or do say, perl libraries also suffer?
19:34:30 <foxy> any DarwinPorts aficiondos got the new GHC installed?
19:34:31 <sproingie> most widely used perl modules start with a usage example
19:34:31 <dons> have haddock include a special #example section, and emit warnings if they're missing?
19:34:38 <dons> do you have stats?
19:35:03 <sproingie> stats on widely used, not really
19:35:08 <dons> it's unclear  to me if haddock+hackage is uniquely documented.
19:35:21 <sproingie> fwiw, ocaml is worse
19:36:13 <dons> well, that's not reassuring. i'd like more examples, and lots of people ask for more examples.
19:36:21 <dons> esp. since often they're learning haskell from the haddocks
19:36:26 <sproingie> yep
19:36:54 <tensorpudding> hoogle and haddock have a good symbiosis
19:37:15 <mmorrow> dons: so being more reasonable (in the short term), one thing that i think would be the most useful addition (if we're only adding one) to haskell's module system (which i've been meaning to propose for haskell prime) is:
19:37:37 <dons> ...
19:37:38 <mmorrow> module A where import qualified Foo as F
19:37:43 <mmorrow> err
19:37:54 <mmorrow> module A (module A, module F) where import qualified Foo as F
19:38:06 <mmorrow> module B where import A; foo = F.foo
19:38:08 <dons> so grouping and renaming?
19:38:16 <mmorrow> so the qualification is propogated through re-exports
19:38:22 <dons> interesting!
19:38:35 <mmorrow> totally, i think so.
19:38:39 <mmorrow> it would enable a ton of stuff
19:38:55 <mmorrow> (and this is the thing i seem to want again and again)
19:39:13 <monochrom> On a superficial level, perl docs are not better than haskell docs. Haskell: "openttp: this function opens http". Perl: "openhttp: this function opens http". On a deeper level, Haskell docs suffer more: Haskell libs are lots of little combinators, the devil is in the composition. Perl libs are a few heavyweight procedures, you don't have a similar how-to-compose problem.
19:39:16 <mmorrow> since then you could, say, provide a generic "Map" implem
19:39:49 <mmorrow> err, lemme think of a good example that highlights the usefulness
19:39:50 <dons> but on the plus, we have types and purity.
19:39:59 <dons> so you can glue things together jigsaw puzzle style
19:40:10 <sproingie> on the level of individual functions it's usually a wash with perl.  but there's perldoc and most perldoc opens with a USAGE section
19:40:30 <dons> that seems like a good idea to support in haddock in some way
19:41:08 <kmc> yeah, Hackage / Haddock should integrate examples better
19:41:24 <dons> some libs have it, but it can be hard to find, e.g. Binary has a large example (scroll from http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary.html#1   )
19:41:40 <sproingie> making the hackage website display the README on the page would be a good start
19:41:47 <tensorpudding> i'd be worried if haddock docs get too big and unwieldy though
19:41:50 <sproingie> the way github and the like do
19:42:02 <sproingie> (first made popular by ftp)
19:46:39 <BMeph> I'd like a usage/tutorial for using haddock with cabal/hackage, myself.
19:47:07 <sproingie> cabal haddock
19:47:10 <sproingie> presto, done :)
19:47:35 <sproingie> i enable documentation in .cabal/config myself
19:47:56 <BMeph> There are many times that I'd like to automate integrating a package's documentation into the already-standing docs, but I don't quite "get" how to connect them.
19:51:48 <mmorrow> dons: something like this i suppose. i just realized that this would (i think) necessitate module signatures, but iirc there's already a Haskell' proposal for that and judging by its comments it's reasonable and looks like it's being considered (iirc)
19:51:52 <mmorrow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14678#a14678
19:52:10 <mmorrow> so this would be an easy extension of that i believe
19:52:22 <mmorrow> (easy wrt implementation complexity (i think?))
19:53:20 <BMeph> It'd also be nice if new modules had a link that took you back to the main contents. I'd even take a link to the libs/manual/API page.
19:53:43 <mmorrow> (i hesitated to use "signature" there, but i think that the information needed to express there could be expressed any number of ways syntactically, as long as there's /some/ way to express it)
19:54:24 <drostin77> I'm back (if anyone that helped is still around :P).  I have made a function that has a case statement like getHostName >>= \host -> case host of \n "a" -> 1 \n "b" -> 2    ..... ghc is upset with me because there is No Instance for (Num (IO b))
19:54:48 <kmc> what about "return 1" or "return 2"
19:54:58 <kmc> it thinks you want 1 or 2 to stand for an IO action, which it can't
19:55:08 <drostin77> wow
19:55:09 <drostin77> compiled
19:55:18 <kmc> 1 can stand for a value of any numeric type (any Num type) but (IO b) is not a Num type
19:55:32 <drostin77> gotcha
19:55:44 <drostin77> thanks much!
19:55:47 <kmc> no prob :)
19:56:23 <BMeph> Closable classes, or some kind of "use the instances you know about", would be nice too. :)
20:01:06 <dmwit> BMeph: Um, isn't the "Contents" link at the top exactly what you want?
20:04:11 <BMeph> dmwit: That link takes you to the module's index. I also want one that takes you to the main library index.
20:04:22 <dmwit> Not here, it doesn't.
20:04:29 <dmwit> It takes me to the package's contents.
20:05:37 <BMeph> Er, sorry, I misspoke. Yes, you are right.
20:07:04 <BMeph> I still want a link that goes back to the main library contents. So that, say, after looking at Control.Concurrent.STM, I can get back to Control.Concurrent
20:07:32 <dmwit> hm
20:07:34 <BMeph> (if that makes things any clearer..)
20:07:40 <dmwit> Define "main library"...
20:07:56 <dmwit> i.e. why isn't the "main library" Control here?
20:08:21 <BMeph> I mean the index page with the title: Haskell Hierarchical Libraries
20:08:33 <dmwit> oh
20:08:35 <dmwit> wow
20:08:59 <kmc> i have a WM shortcut for that page :)
20:09:18 <Cale> The hierarchical libraries documentation page has been getting less and less useful.
20:09:23 <dmwit> yeah =)  (Well, Firefox shortcut, anyway.)
20:09:35 <kmc> Cale, yeah, i have it pointed now to the 6.10 version
20:09:38 <Cale> and they broke all my bookmarks again
20:10:01 <kmc> are there plans to have one page with Haddock for all of Platform?
20:10:10 <kmc> that'd be super great, especially if i can download it
20:12:59 <BMeph> I'd like to see the connections to the pages go beyond the package level.
20:13:51 <BMeph> Of course, then I'd start to whine about not having a link to the package, but that's for another time... :)
20:20:46 <sohum> @djinn (a, b, Maybe c) -> Maybe (a, b, c)
20:20:46 <lambdabot> f (a, b, c) =
20:20:46 <lambdabot>     case c of
20:20:46 <lambdabot>     Nothing -> Nothing
20:20:46 <lambdabot>     Just d -> Just (a, b, d)
20:21:51 <mauke> :t (fmap .) . (,,)
20:21:51 <lambdabot> forall a (f :: * -> *) a1 b. (Functor f) => a1 -> b -> f a -> f (a1, b, a)
20:24:43 <orbitz> HAI
20:25:31 <sohum> @hoogle [Maybe a] -> [a]
20:25:31 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:25:32 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:25:32 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:25:55 <sohum> > sequence [Maybe 4, Maybe 9, Nothing, Maybe 2]
20:25:56 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe...
20:26:10 <sohum> > sequence [Just 4, Just 9, Nothing, Just 2]
20:26:11 <lambdabot>   Nothing
20:26:30 <raceRider> @run fmap
20:26:31 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
20:26:31 <lambdabot>                    GHC.Show...
20:27:24 <raceRider> :t fmap
20:27:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:44:23 <kmc> so Haskell's STM is bad in heavily contended cases
20:44:34 <kmc> because the threads keep stepping on each other and causing retries
20:44:55 <kmc> whereas a lock would cause them to run in an orderly fashion
20:45:17 <kmc> and the locks are worse in the uncontended cases, because it takes time to manipulate a lock
20:45:25 <kmc> can we say something more quantitative about this tradeoff?
20:45:52 <kmc> if i am writing a concurrent program, how do i guess ahead of time which strategy will perform better?
20:47:28 <medfly> you don't start by asking an overly general question, but by doing examples and generalising them, no?
20:48:15 <medfly> just sayin'. I suck.
20:49:12 <kmc> yeah, i am wondering if there are more specific guidelines that can cut down the amount of required experimentation
20:49:21 <medfly> oh, ok.
20:49:25 <kmc> i would not be surprised if the answer is "no"
20:50:03 <kmc> perhaps a more interesting question is: how do we write code in such a way that it can be easily retargeted to a different synchronization strategy
20:50:38 <dons> i've not observed a use of stm in practice where contention has been a bottleneck, fwiw
20:50:58 * medfly doesn't have enough experience with difficult concurrency to answer that.
20:51:01 <dons> you can imagine how it can come about, but i've not seen it in practice. in stm in general, actually.
20:51:16 <dons> maybe its just easy to get right
20:51:20 <newsham> cant "atomic" be retargetted towards other ways of guaranteeing atomicity?
20:51:25 <dons> maybe people don't hammer the code enough
20:51:28 <kmc> dons, i'm playing with pathological toy examples where STM performs very badly.  i can see that these situations are extreme
20:51:58 <dons> yeah, you can definitely construct all sorts of pathological cases. prob. like any abstraction (i can write inefficient array programs)
20:52:16 <dons> i think stm is robust though.
20:52:25 <c_wraith> It's also possible that the fact that people rarely create more execution threads than they have processors contributes to STM not being a real bottleneck.  harder to have a bunch of actions step on each other.
20:52:31 <dons> its not like there's very few ways to get the right behaviour. it's pretty easy
20:52:44 <kmc> c_wraith, do you mean OS threads or RTS threads?
20:52:49 <c_wraith> RTS
20:53:05 <kmc> that's definitely now how i code parallel or concurrent Haskell
20:53:26 <kmc> the beauty of green threads is that you spawn exactly as many as makes sense for your problem
20:54:21 <kmc> if you spawn only (# cores) RTS threads, and multiplex work between them, you are duplicating the work that the RTS thread scheduler is supposed to do, and probably not as well
20:54:36 <kmc> now if you have a 2 core machine and your problem really only has 2 logical threads in it, fine
20:54:38 <c_wraith> err, sorry.  I mean they rarely use more OS threads.  and the RTS scheduler can choose smarter points to context switch than the OS scheduler
20:54:44 <kmc> yes
20:54:54 <c_wraith> And that means fewer contention issues, potentially
20:54:55 <kmc> is the RTS scheduler aware of STM in a significant way?
20:55:03 <kmc> in say GHC 6.12
20:55:22 <kmc> eek above i said 'now' and meant 'not' ;/
20:55:54 <medfly> what is the point of opening up more threads than you have processors if you don't have to?
20:55:57 <medfly> I wonder.
20:56:05 <kmc> medfly, again, OS or RTS threads?
20:56:10 <medfly> I don't know :(
20:56:15 <kmc> with RTS, it's not a matter of "don't have to"
20:56:21 <kmc> it's a matter of describing the problem in the most natural way
20:56:50 <medfly> my experience with stuff requiring more than one thread summed up to needing to write forkIO and then it working OK
20:56:55 <medfly> ;)
20:57:16 <kmc> i wrote a mandelbrot set renderer.  it was much more natural to spawn one thread per scanline, than to artificially chop the image plane up into exactly (# cores) pieces that will take the same time (especially since, you don't know the time each piece will take without rendering the set!)
20:57:58 <medfly> oh. thanks.
20:58:02 <kmc> it is a common pattern to break a problem into many logical pieces, and farm those pieces out to a fixed number of worker threads
20:58:21 <kmc> in many languages this is done
21:00:19 <kmc> and of course a "design pattern" is a library waiting to be written
21:01:07 <kmc> and so we make this common pattern the responsibility of the GHC runtime, which has a lot of low-level information it can use to do it well
21:03:55 <medfly> make a thing split logically into something that is suitable for the machine?
21:04:02 <kmc> yes
21:04:09 <medfly> I wonder
21:04:15 <kmc> in theory it could be the responsibility of the OS, even
21:04:24 <sproingie> ghc threads are ridiculously cheap.  forkIO like there's no tomorrow
21:04:32 <kmc> but most contemporary OSes won't handle it well if you spawn 1,000,000 OS threads
21:04:41 <kmc> whereas the GHC or Erlang runtime will handle it perfectly
21:05:01 <medfly> why can't you just deal out threads per processor like cards, one for each until you run out of cards?
21:05:05 * medfly is a total noob. sorry.
21:05:36 <kmc> medfly, that sort of describes how the RTS maps RTS threads to OS threads. and how the OS maps OS threads to processors
21:06:16 <medfly> what does RTS stand for?
21:06:19 <kmc> runtime system
21:06:22 <medfly> thanks
21:06:43 <medfly> what's the problem with that?
21:06:48 <kmc> problem with what?
21:07:03 <medfly> with doing that. why is that not good?
21:07:28 <kmc> are you familiar with how an OS scheduler works?
21:07:34 <medfly> probably not
21:07:56 <kmc> so let's talk about OS threads first
21:08:09 <medfly> yay, you're cooperative and willing to explain :)
21:08:11 * medfly sits
21:08:30 <kmc> the abstraction the OS provides is that anyone can create a thread, and they all run "at once"
21:09:02 <kmc> but of course if you have more threads than processor cores, this is not literally possible
21:09:30 <kmc> so the threads take turns running on some available CPU for some fixed timeslice
21:09:47 <kmc> the OS manages this.  the component that does is called the "scheduler"
21:10:22 <kmc> depending on your requirements this can be a pretty complicated task.  thread scheduling is one of the major research areas in operating systems, and it's e.g. one of the areas of the Linux kernel that gets constant attention and periodic rewrites
21:10:37 <medfly> I see.
21:11:48 <kmc> but the key idea is for each thread to get the illusion of simultaneity with all the others, without special effort on the thread's part
21:13:14 <kmc> you can could instead provide the abstraction of "jobs are submitted to a queue; when a CPU frees up it will pick a job and run it to completion"
21:13:32 <kmc> and there are some systems that work this way
21:14:00 <kmc> but it is not the abstraction chosen by standard desktop and server operating systems, because it does not deal well with interactivity
21:14:38 <raceRider> @type fmap
21:14:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:15:33 <kmc> anyway, GHC's RTS schedules Haskell threads (the ones created by forkIO) among OS threads, just as the OS schedules OS threads among cores
21:15:58 <kmc> your hardware determines the number of cores you have, whereas a command-line argument to the RTS determines how many OS threads the RTS will use
21:16:01 <medfly> I see. thanks for the explanation :)
21:16:14 <kmc> no problem :)
21:24:47 <HaskellLove> "It is important to note that the type of an expression says nothing about its possible effects! An expression of type int might well display a message on the screen before returning an integer value." wow now that is huge difference SML vs Haskell
21:25:10 <mauke> yep
21:25:12 <kmc> yes
21:25:45 <kmc> well... in Haskell, evaluating an expression absolutely never has an effect, no matter what the type is
21:25:52 <kmc> (barring unsafePerformIO and such)
21:26:03 <kmc> so the type does not tell you anything in Haskell either
21:26:10 <kmc> ;)
21:26:37 <medfly> wouldn't it be a bit handy to have that to some extent?
21:26:43 <medfly> and annoying.
21:26:48 <kmc> to have what?
21:27:09 <medfly> some kind of way to denote what the function will be doing in types
21:27:31 <medfly> wait... no...
21:27:34 <medfly> that's not right.
21:27:35 <kmc> what's an example of something a function could "do"?
21:27:35 <Cale> medfly: Well, we *sort* of do that.
21:27:50 * medfly just realised that...
21:28:03 <medfly> yeah... sorry... I have been kept away from Haskell for too long
21:28:13 <HaskellLove> kmc well does not IO () tell you something?
21:28:25 <kmc> HaskellLove, evaluating an expression of type "IO ()" does not perform an effect
21:28:34 <dibblego> medfly, (a -> b) -> (b -> c) -> a -> c -- assuming a few things such as termination, this type only "does" one thing
21:28:36 <kmc> it cannot, any more than evaluating an expression of type "Int" does
21:28:44 <Cale> HaskellLove: Well, a value of type IO () *is* an action to be performed, but evaluating the expression still won't do anything.
21:29:03 <HaskellLove> I mean, an OS has been written in Haskell so?
21:29:05 <medfly> hi there Cale, dibblego :)
21:29:12 <medfly> HaskellLove: yes!
21:29:13 <Cale> HaskellLove: It's only *executing* actions of type IO () which causes the effects they describe to really occur, and that's a separate process.
21:29:18 <kmc> in Haskell, an "effect" is a first-class value.  evaluating an effect does not perform the effect.  Writing down a recipe for cake is not the same as baking a cake.
21:29:32 <kmc> separate to the idea of "evaluation", is the idea of "execution"
21:29:40 <Cale> The cake is a lie!
21:29:49 <DigitalKiwi> the lie is a cake!
21:30:00 <medfly> haha
21:30:13 <mjsor> Anyone here ever use the chart package via cabal on OSX (without macports or fink)?  I'm having trouble convincing it to build even after installing GTK and Cairo...
21:30:15 <kmc> HaskellLove, what is your point about the OS?
21:30:50 <Cale> One cross borehole electro-magnetic imaging rhubarb
21:30:50 <HaskellLove> kmc hmm interesting... so, we can say that an IO () function starts the chain of side effects actions but is not involved in it? i mean... hmm i dont get it
21:31:00 <kmc> well, first of all a value of type "IO ()" is not a function
21:31:05 <kmc> a function has arguments and a return type
21:31:10 <kmc> a function has "->" in its type
21:31:14 <HaskellLove> well OS, you said it has no side effects so, of course it has if you can write OS with it
21:31:33 <kmc> HaskellLove, evaluating an expression never has a side effect.  we have a different way to perform side effects.
21:31:51 <medfly> HaskellLove: haskell hides it, and denies it a lot, but you can have side effects!
21:32:07 <kmc> medfly, i do not deny it.  i am proud of the excellent support for imperative, effectful programming in Haskell
21:32:11 <HaskellLove> medfly well yeah through monads
21:32:31 <kmc> that support is excellent *precisely because* we have disentangled the quite different concepts of "function" and "side effect recipe"
21:32:38 <HaskellLove> monads are like saints that save us from sins :D haha
21:32:42 <kmc> in most languages they are the same type, and confusion results
21:32:44 <mauke> HaskellLove: no
21:33:03 <medfly> supposedly, even when I use real programming languages I write it in a functional style
21:33:04 <bd_> HaskellLove: unsafe* :)
21:33:08 <mauke> HaskellLove: monads are not magic and only tangentially related
21:33:14 <kmc> HaskellLove, consider this value
21:33:19 <kmc> > "print the number 3 to the screen"
21:33:20 <lambdabot>   "print the number 3 to the screen"
21:33:25 <ManateeLazyCat> Have a possible make FFI support "varargs method" from C ?
21:33:31 <kmc> HaskellLove, that's just a string
21:33:48 <kmc> here is another example
21:33:51 <kmc> > "send a packet to google.com"
21:33:52 <lambdabot>   "send a packet to google.com"
21:33:59 <kmc> evaluating this string does not send a packet to google.com
21:34:01 <kmc> it's just a description
21:34:04 <kmc> of something you could do
21:34:13 <kmc> you can compute the description, and still choose later whether to do it
21:34:57 <kmc> values of type "IO ()" are exactly like this, except instead of being strings in natural language, they describe effects in a way that machines can process
21:35:30 <HaskellLove> but still the chain is started by a Haskell function marked as having type IO ()
21:35:38 <kmc> HaskellLove, no function has type "IO ()"
21:35:47 <kmc> but yes.  the chain is started by "main"
21:35:47 <HaskellLove> I mean, the side effect does not just fall from sky
21:35:54 <ManateeLazyCat> Some C functions use "varargs method" to handle function argument, and i want binding those function to Haskell, but FFI can't support "varags method" now, have anyother idea to fix this problem?
21:36:10 <kmc> ManateeLazyCat, you can FFI-call a non-vararg function and pass the args another way, like in an array
21:36:23 <sohum> @hoogle replace
21:36:23 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
21:36:23 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
21:36:23 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
21:36:34 <HaskellLove> kmc yes i know that is why i said "marked" as having type bla bla...
21:36:35 <medfly> Cale: hi
21:36:41 <kmc> HaskellLove, then i don't know what you mean by that
21:36:56 <kmc> HaskellLove, when a Haskell program is executed, two things happen:  1) the expression for "main" is evaluated to a value;  2) the side effect described by that value is performed
21:37:02 <Cale> > take 3 cake
21:37:03 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
21:37:09 <kmc> haha Cale
21:37:11 <Cale> > drop 10 cake
21:37:12 <lambdabot>   ["Fish shaped candies.","Fish shaped solid waste.","Fish shaped dirt.","Fis...
21:37:13 <sohum> @hoogle grep
21:37:14 <lambdabot> Data.Data AlgRep :: [Constr] -> DataRep
21:37:14 <lambdabot> Data.Data StringRep :: DataRep
21:37:23 <HaskellLove> kmc i dont know how we got here anyways i got my answer :D thanks i go back to reading
21:37:24 <ManateeLazyCat> kmc: Yes, array is a way, but in low-level C code haven't equivalent non-vararg fucntion to replace.
21:37:28 <medfly> hehe
21:37:40 <Cale> > drop 13 cake
21:37:41 <lambdabot>   ["Fish shaped ethylbenzene.","Pull and peel licorice.","Fish shaped organic...
21:37:49 <sohum> > length cake
21:37:51 <lambdabot>   42
21:37:56 * sohum snerrrk
21:38:05 <sohum> :t split
21:38:05 <medfly> this must be a really complicated joke :)
21:38:06 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
21:38:12 <sohum> :t splitAt
21:38:13 <HaskellLove> > let monad = "Chesus"
21:38:13 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:38:14 <lambdabot>   not an expression: `let monad = "Chesus"'
21:38:19 <Cale> medfly: It's the cake recipe from a game called Portal
21:38:20 <dmwit> You know what made that game amazing?  They spent the time to create 42 weird cake ingredients, just in case you got stuck on that one for the entire 5 minute time.
21:38:22 <pikhq> ManateeLazyCat: Crazy assembly hackery to go from an array to a vararg call?
21:38:40 <medfly> hehehe
21:38:48 <kmc> ManateeLazyCat, it's a limitation of C that you can't call a vararg function non-variadically
21:38:58 <kmc> that's why there are variants of vararg functions, e.g. vprintf, vsprintf
21:39:04 <ManateeLazyCat> kmc: Example, function `dbus_g_proxy_begin_call` in DBus-Glib, it haven't equivalent function to replace it.
21:39:07 <medfly> @type drop
21:39:08 <lambdabot> forall a. Int -> [a] -> [a]
21:39:08 <sohum> tryiiing to get fgl to output undigraphs
21:39:11 <kmc> if the designer of the API you're using did not include these, you should complain ;)
21:39:56 <sohum> is there a function s.t. f " -> " " -- " "a -> b\n c -> d" == "a -- b\n c -- d" ?
21:40:05 <Cale> medfly: Part of a computer that you rip off from the main tree of components recites the recipe to you as you carry it to its fiery doom, as the computer is busily pumping nerve gas into the giant chamber to kill you if you take too long.
21:40:31 <medfly> hehe
21:40:33 <ManateeLazyCat> kmc: I have finish most DBus-Glib functions binding for gtk2hs, but some import functions (such as dbus_g_proxy_begin_call) can't finish, so i can't write demo program to test binding.
21:40:38 <sohum> > drop 40 cake
21:40:39 <lambdabot>   ["And it contains proven preservatives, deep penetration agents, and gas an...
21:40:47 <ManateeLazyCat> s/import/important
21:40:52 <medfly> I think you don't need so much nerve gas in a room to kill a person, though
21:41:23 <mtnviewmark> cake?!?
21:41:35 <pikhq> medfly: Intentionally weak nerve gas.
21:41:36 <sohum> liecake!
21:41:40 <medfly> okay.
21:41:40 <sohum> not just any liecake
21:41:45 <sohum> the /original/ liecake
21:41:47 <mtnviewmark> :t cake
21:41:48 <lambdabot> [[Char]]
21:41:54 <mtnviewmark> :t liecake
21:41:55 <lambdabot> Not in scope: `liecake'
21:42:01 <mtnviewmark> ha! the liecake is a lie!
21:42:05 <sohum> @let liecake = cake
21:42:06 <lambdabot>  Defined.
21:42:09 <kmc> ManateeLazyCat, well, as a hack... you can write them out to some fixed arity
21:42:15 <sohum> @let theCakeIsALie = liecake
21:42:16 <lambdabot>  Defined.
21:42:34 <pikhq> > fix (cake:)
21:42:35 <lambdabot>   [["One 18.25 ounce package chocolate cake mix.","One can prepared coconut p...
21:42:41 * mtnviewmark wonders how long lambdabot keeps binds around.....
21:42:48 <Cale> medfly: Also, the chamber was ridiculously large
21:42:55 <kmc> > interleave $ concat cake
21:42:55 <pikhq> THE INFINITE CAKE!
21:42:56 <lambdabot>   ""->
21:42:57 <lambdabot>    "One 18.25 ounce package chocolate cake mix.One can prepared coconu...
21:43:09 <kmc> > fix (interleave $ concat cake)
21:43:10 <lambdabot>   "OOnOen O1e8n. 2O51 eo8unn.c e2 Op5a1c keaog8eu ncnh.occ oel2a tOep 5caa1kc...
21:43:13 <hzap> > cake
21:43:14 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
21:43:15 <sohum> mtnviewmark: until Cale reboots lambdabot, I believe
21:43:18 <kmc> > length cake
21:43:19 <lambdabot>   42
21:43:24 <hzap> > cake !! 3
21:43:25 <lambdabot>   "Four large eggs."
21:43:26 <Cale> sohum: I actually put it in Pristine.hs :)
21:43:30 <sohum> > map length 42
21:43:31 <lambdabot>   No instance for (GHC.Num.Num [[a]])
21:43:31 <lambdabot>    arising from the literal `42' at <in...
21:43:31 <mtnviewmark> well, OF COURSE it's 42!
21:43:36 <sohum> > map length cake
21:43:37 <lambdabot>   [43,40,35,16,35,42,40,28,31,21,20,24,17,25,23,59,52,20,13,28,26,38,21,37,25...
21:43:38 <Cale> so it'll be there until I decide to get rid of it
21:43:39 <hzap> > length cake
21:43:41 <lambdabot>   42
21:44:00 <sohum> Cale: we were referring to @let liecake and @let theCakeIsALie :P
21:44:06 <Cale> oh
21:44:27 <kmc> > fst . last . sortBy (comparing snd) . map (id &&& length) $ cake
21:44:28 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
21:44:29 <Cale> > cake !! 40
21:44:30 <lambdabot>   "And it contains proven preservatives, deep penetration agents, and gas and...
21:45:06 <HaskellLove> hmm who said SML does not have lazy evaluation? turns out it has, as the book says so...
21:45:18 <kmc> HaskellLove, it is not lazy by default
21:45:24 <Cale> > cake !! 25
21:45:25 <lambdabot>   "An entry called 'how to kill someone with your bare hands.'"
21:45:34 <dolio> Which book?
21:45:51 <kmc> lazy evaluation can be implemented in any functional language, with explicit syntax to make a value lazy and to force it
21:45:59 <sohum> is there a function s.t. f " -> " " -- " "a -> b\n c -> d" == "a -- b\n c -- d" ?
21:46:18 <kmc> i can't parse that, sorry
21:46:23 <mauke> kmc: stringReplace
21:46:28 <ManateeLazyCat> kmc: I think some fix in Haskell side, we can use '()' surround vararg function, like (varargToHaskell arg1 arg2 arg3).
21:46:32 <Cale> sohum: map (\x -> if x == '>' then '-' else x)
21:46:43 <mauke> haha
21:46:46 <sohum> Cale: I don't want to replace all ">", that's the problem
21:47:05 <Cale> Well, you only asked for a function which satisfied those mappings ;)
21:47:19 <ManateeLazyCat> kmc: Then we can binding vararg function with Haskell.
21:47:25 <Cale> hmm
21:47:27 <sohum> Cale: I /knew/ someone would make that smartass comment :P
21:47:41 <mauke> random thought of the day:
21:47:46 <HaskellLove> "Note that ML does not perform any implicit conversions between types!" There we go another difference Haskell vs SML
21:47:46 <mauke> SML stands for Simula
21:47:59 <kmc> HaskellLove, Haskell does not perform any implicit conversions between types
21:48:02 <HaskellLove> mauke no man, standard ml
21:48:09 <Cale> sohum: Oh, I see, the strings to match and replace are parameters
21:48:13 <mauke> HaskellLove: that doesn't sound very random
21:48:25 <luite> sohum: Data.Text has replace, but it is Text -> Text -> Text -> Text
21:48:53 <sohum> @hoogle String -> String -> String -> String
21:48:53 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
21:48:54 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:48:54 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
21:49:14 * sohum glares at fgl for making me do this
21:49:20 <HaskellLove> kmc well in haskell i can do 6+6.2 and in sml i cant
21:49:29 <kmc> HaskellLove, that's not an implicit conversion
21:49:42 <ManateeLazyCat> kmc: Or other way, i write equivalent function with array in C, then binding it.
21:50:00 <patch-tag> ghc-pkg list shows I have both base-3 and base-4 installed. In ghci I load a module that uses some module from base. (System.Console.GetOpt). How can I tell which base package is being used?
21:50:13 <sohum> > (\6 -> 6 4) (+6)
21:50:14 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
21:50:14 <lambdabot>    arising from the literal `6' at <...
21:50:19 <Cale> HaskellLove: both 6 and 6.2 must be the same type for that addition to succeed in Haskell, and it will not convert for you
21:50:22 <mtnviewmark> HaskellLove, but you can write:   \a b -> a + b :: (Int -> Double -> Double)
21:50:27 <mtnviewmark> er, you can't
21:50:33 <medfly> :t (6)
21:50:34 <lambdabot> forall t. (Num t) => t
21:50:43 <dmwit> sohum: Check out Data.List.Split and Data.List.intercalate
21:50:48 <kmc> HaskellLove, (6 + 6.2) does not convert from Int to Double.  Rather, it sees at compile time that 6 must already be a Double
21:50:51 <mauke> mtnviewmark: but that's because (Int -> Double -> Double) is not an instance of Num
21:50:58 <kmc> :t 6
21:50:58 <Cale> HaskellLove: However, the numeric literals are polymorphic, and so can be used at a variety of types
21:50:58 <HaskellLove> Cale but 6+6.2 shows no errors
21:50:59 <kmc> :t 6.2
21:50:59 <lambdabot> forall t. (Num t) => t
21:51:00 <lambdabot> forall t. (Fractional t) => t
21:51:04 <mtnviewmark> mauke - there was a lambda in there
21:51:05 <Cale> :t 6 + 6.2
21:51:06 <lambdabot> forall t. (Fractional t) => t
21:51:11 <mauke> mtnviewmark: no
21:51:27 <kmc> in fact, 6.2 could be something else, like Rational.  It can be any member of the Fractional class
21:51:28 <mtnviewmark> oh - meant (\a b -> a + b) :: Int -> Double -> Double
21:51:29 <Cale> HaskellLove: Once you pick a specific fractional type, the computation proceeds entirely with that one type.
21:51:31 <sohum> :t 6 `asTypeIn` \x -> x + 6.2
21:51:32 <lambdabot> forall t. (Fractional t) => t
21:51:48 <Cale> HaskellLove: That is, 6 might refer to a Double or a Rational number.
21:51:49 <mtnviewmark> was trying to point out how that won't work in Haskell.... and clearly I failed miserably!  :-)
21:51:52 <HaskellLove> kmc, Cale, can we say the having type inference haskell does not need implicit conversions?
21:51:54 <ManateeLazyCat> patch-tag: ghc-pkg register ?
21:51:57 <kmc> HaskellLove, no
21:51:59 <kmc> we cannot say that
21:52:05 <kmc> as they are fairly unrelated concepts
21:52:07 <mauke> SML has type inference
21:52:14 <kmc> HaskellLove, here is a practical example that shows that there are no implicit conversions:
21:52:18 <kmc> > (4 `div` 2) / 3
21:52:19 <lambdabot>   Ambiguous type variable `t' in the constraints:
21:52:19 <lambdabot>    `GHC.Real.Integral t'
21:52:19 <lambdabot>   ...
21:52:21 <sohum> smiler: oh, you meant that capital letter
21:52:22 <Cale> HaskellLove: It's actually typeclass polymorphism and defaulting which make this work, for the most part.
21:52:33 <Cale> But I suppose inference is sort of important.
21:52:36 <sohum> smiler: woops, sorry, tabfail
21:52:45 <mauke> > length "butter" * 0.5
21:52:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:52:46 <lambdabot>    arising from the lit...
21:52:49 <Cale> You do need explicit numeric conversions in Haskell quite often.
21:52:49 <kmc> inference is important because we want to infer types for overloaded things, rather than write them
21:52:53 <sohum> dmwit: oh, I see, you meant that capital letter
21:52:55 <kmc> but that's strictly a matter of convenience
21:53:02 <kmc> mauke's example is good
21:53:03 <kmc> :t length
21:53:04 <lambdabot> forall a. [a] -> Int
21:53:12 <kmc> > 6 * 6.2
21:53:14 <lambdabot>   37.2
21:53:15 <kmc> > (6 :: Int) * 6.2
21:53:17 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
21:53:17 <lambdabot>    arising from the lit...
21:53:18 <Cale> It would be a less good example if length had a sane type.
21:53:21 <dmwit> sohum: yep =)
21:53:27 <dmwit> ?hackage split
21:53:28 <lambdabot> http://hackage.haskell.org/package/split
21:53:47 <HaskellLove> got it, thank you kmc, Cale
21:53:55 <sohum> :t sepBy
21:53:56 <lambdabot> Not in scope: `sepBy'
21:54:47 <luite> hehe, split, splitOn, splitWhen, splitAt (Prelude or Data.List)
21:54:59 <medfly> -l
21:55:33 <sohum> :t intercalate
21:55:34 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:57:27 <HaskellLove> as I read I keep bumping on this general patterns in functional languages. Like, look at this one now: "Both “arms” of the conditional must have the same type!", because of course a conditional is a function and a function can have only one type of input/output. I think i go in the right direction, I am not just learning syntax...
21:57:47 <kmc> HaskellLove, the (?:) operator in C has the same property
21:58:25 <luite> > let replace from to = intercalate to.splitOn from in replace " -> " " -- " "a -> b"
21:58:26 <lambdabot>   Not in scope: `splitOn'
21:58:35 <dmwit> Any git masters?  What do I have to on my server to make "git clone http://dmwit.com/sgf" work?
21:58:44 <luite> oh no split package in lambdabot
21:59:06 <kmc> dmwit, not sure... try #git?
21:59:12 <dmwit> Good idea.
21:59:20 <HaskellLove> really? cool... but kinda not logical to me, since in C we deal with procedures and i would not be surprised if "if-then" or "?:" can have arms with different types...
22:00:05 <kmc> HaskellLove, "if (...) then { ... } else { ... }" in C has no type.  it's not an expression.  it doesn't evaluate to a value
22:00:06 <mtnviewmark> ?: in C/C++ is an expression, not a statment -- hence it must have one static type ---
22:00:07 <lambdabot> Maybe you meant: . ? @ v
22:00:17 <mtnviewmark> heh
22:00:45 <HaskellLove> kmc oops almost forgot, woow two weeks in haskell got my mind spining around types :)
22:00:55 <mtnviewmark> if / else in C/C++ is a statement -- and in some sense, both arms *do* have the same type: Statement -- or IO ()!
22:01:08 <kmc> mtnviewmark, heh
22:01:18 <kmc> (;) :: IO () -> IO () -> IO ()
22:01:33 <kmc> "a ? b : c" is an expression, and has a static type
22:01:54 <kmc> the rule is "if a has type Bool, and b and c have the same type, then a ? b : c has the same type as b and c"
22:02:09 <kmc> (complicated by the fact that C has no real Bool type, and C++ does but also has a huge awful system of implicit conversions)
22:02:31 <kmc> (so that, for example, a could have type std::iostream which is implicitly convertible to void* which is implicitly convertible to bool)
22:02:51 <dolio> Wow, seriously?
22:03:02 <kmc> dolio, yes... and this behavior is *intentional*!
22:03:05 <dolio> It's been too long since I've done C++, apparently.
22:03:07 <luite> they use it for error checking
22:03:14 <kmc> the only reason the conversion to void* exists is so you can say while (my_file) { ... }
22:03:15 <dolio> Oh, right.
22:03:26 <kmc> this speaks to an absolutely fundamental misunderstanding of the role of types
22:03:32 <luite> oh eof then, I thought it was for errors
22:03:33 <kmc> among the C++ designers
22:03:37 <kmc> who are generally quite type-happy
22:03:58 <kmc> fun fact: in C++, it is a *run-time* error to initialize a std::string from the value "false"
22:04:14 <kmc> or possibly an unchecked error on some systems
22:04:31 <kmc> and by "false" i do not mean the string constant but the keyword representing the boolean
22:04:58 <sohum> arright, yay! I'm not wasting my time after all! a telegraph problem instance has edges with a whole /eight/ actions specifying one edge should exist!
22:05:17 <kmc> telegraph problem?
22:05:54 <sohum> planning
22:06:01 <sohum> AI
22:06:30 <HaskellLove> what colege are you in?
22:07:04 <sohum> trying to decompose problems to solve them faster, and the current method disregards the conceptual strength of links between atoms
22:07:52 <sohum> I have a "gut feeling" (TM) that taking that into account will make for better decompositions
22:08:18 <sohum> my statement's mostly sarcastic, because I was expecting far stronger differences than the 1..8 range
22:18:31 <HaskellLove> kmc can you have similar thing in Haskell, that is in ghci interpreter? type float = real and average = float, that is type binding in SML, but hmm...I can't see why I would do something like that...
22:28:50 <dibblego> @hoogle Kleisli m a b -> (a -> m b)
22:28:51 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
22:32:26 * hackagebot upload: dgs 0.1 - Haskell front-end for DGS' bot interface (DanielWagner)
22:53:21 <mtnviewmark> actually - with regard to C++'s implicit conversion..... I *just* this weekend wrote a type conversion system in Haskell
22:53:44 <dmwit> ack
22:53:46 <mtnviewmark> it defines        convert :: (ConvertFrom a, ConvertTo b) => a -> b
22:54:00 <dmwit> ... quadruple ack
22:54:02 <mtnviewmark> and there are (for my needs) 8 types that it handles
22:54:11 <dmwit> It's not a (Convert a b) => a -> b ?
22:54:26 <mtnviewmark> No - because that would have required 64 instances
22:54:52 <dmwit> Surely not.
22:55:07 <mtnviewmark> ConvertTo has 8 methods (convertFromXxxx for each of the 8 types)
22:55:33 <mtnviewmark> and ConvertFrom has only one method: convert --- each of the 8 instances defineds convert to be convertFromXxxx for it's type
22:55:34 <dmwit> But even so, how is 128 functions better than 64 instances?
22:55:46 <dmwit> ok, 64 functions
22:55:47 <mtnviewmark> there aren't 128 functoins
22:55:58 <dmwit> 8 methods * 8 instances = 64 functions
22:56:04 <mtnviewmark> that's right
22:56:16 <dmwit> So... how is that better than 64 instances?
22:56:24 <mtnviewmark> (though not all are defined, or rather, some are handled by the 8 default implementations in the class)
22:56:34 <mtnviewmark> (which is also an advantage....)
22:57:07 <mtnviewmark> this way also makes it easier for other functions based on the system to be easily polymorphic (I think)
22:57:57 <mtnviewmark> kind of crazy - I know, but it comes from the semantics of an interchange format that has such conversions defined
22:59:09 <HaskellLove> from SML book "Type checking must take account of the declared type of a variable. Evaluation must take account of the declared value of a variable. This is achieved by maintaining environments for type checking and evaluation." Does Haskell have type enviornments, of course it has value enviornments, but type? is it just module based?
22:59:55 <mtnviewmark> dmwit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14679#a14679   if you feel like being further amused
23:01:24 <dmwit> I don't want to know, man, I don't want to know.
23:01:40 <dmwit> I've got my own bad specs to rant about, I don't need your problems. =P
23:01:52 <mtnviewmark> :-)
23:02:10 <kmc> HaskellLove, a typical Haskell compiler will keep a type environment during the type inference and typechecking phases of compilation
23:02:34 * hackagebot upload: mime 0.3.2 - Working with MIME types. (SigbjornFinne)
23:03:34 <kmc> In axiomatic descriptions of type theories, this is often called a "type context".  It appears to the left of a turnstile (⊢) in a typing judgement, and is often represented by the variable Γ.
23:03:43 <HaskellLove> kmc, yes but in SML you can have type enviornments like, in a "let" block you can have local values right, well it turns out in sml you can also have local types...
23:03:58 <kmc> Typically, information about types is not present at run time; it is "erased".
23:04:22 <kmc> Ah.  Haskell does not allow you to use "newtype", "type", or "data" within a local binding context, to my knowledge.
23:05:32 <HaskellLove> kmc so type contexts are module-based we can say...
23:05:51 <HaskellLove> one type context per module...
23:05:58 <HaskellLove> more value contexts per module
23:14:26 <kmc> i think, in the passage you quoted, a type context associates each variable to a type
23:14:50 <kmc> much as the value context associates each variable to a value
23:15:05 <kmc> in a statically typed language, the former is a compile-time concept and the latter a run-time concept
23:15:19 <kmc> in that sense every "let" will have its own type context, giving the types for the variables bound within that "let"
23:15:23 <kmc> as will the body of each lambda, etc.
23:15:32 <kmc> the question of whether you can define *new* types locally is i think a separate one
23:16:27 <kmc> > let x :: Int; x = 3 in x + 1
23:16:29 <lambdabot>   4
23:16:43 <kmc> the type context of the body "x + 1" is { x :: Int }
23:16:52 <kmc> the value context is { x = 3 }
23:17:08 <kmc> neither of these will necessarily hold elsewhere in the module
23:18:05 <kmc> (in fact those contexts will also contain all of the rest of the module, and all of the imports, Prelude, etc.)
23:40:28 * dmwit <3 cabal sdist
