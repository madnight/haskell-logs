00:00:05 <roostaj> hiptobecubic: ha ha. are you doing grad school or just working?
00:00:19 <Adamant> I thought the point was that there was nothing to do in Lubbock?
00:00:24 <Adamant> :P
00:00:24 <hiptobecubic> roostaj, but yes. This place is absolutely terrible. The girlfriend got a job at one of the major hospitals here. I'm just along for the ride until summer when we move to Rotterdam
00:00:35 <hiptobecubic> Lubbock is a terrible, terrible place.
00:00:41 <copumpkin> @tell mmorrow hear, hear! (re jdh post on -cafe)
00:00:41 <lambdabot> Consider it noted.
00:00:49 <Adamant> I think the only thing there is Texas Tech
00:00:56 <Adamant> or Texas A&M
00:01:06 <Jafet> lolol is brainfuck functional?!?1/
00:01:11 <roostaj> hiptobecubic: there are worse places, but it is a very ugly place
00:01:20 <roostaj> Adamant: Texas Tech
00:01:21 <hiptobecubic> Granted I'm coming from parties on South Beach, but really there's just nothing to do here at all.
00:01:21 <kmc> a language is a mathematical object.  and so i think the subset "functional language" should be based on some relatively precise aspect of the language itself, rather than vague ideas of what types of programming are encouraged or accepted by the community
00:01:42 <roostaj> hiptobecubic: don't go to San Angelo then lol... you will die of shock!
00:02:04 <Jafet> Er, brainfuck is a bad example. Replace it by jot
00:02:18 <kmc> in the end, nobody can agree on what any of the terms categorizing languages means
00:02:19 <copumpkin> kmc: well, I think that being expression-based encompasses most of what we care about in functional languages, and cuts out a lot of confusion with ruby/python that you'd get from using a first-class function definition
00:02:36 <kmc> copumpkin, i am perfectly happy to call Python and Javascript functional languages
00:02:56 <kmc> they support the expressiveness of functional programming in an important way that C++ and Java do not
00:03:13 <kmc> furthermore it's easy to imagine languages that are expression-based but lack this expressiveness
00:03:40 <kmc> C is fairly expression-based
00:03:50 <kmc> there are expression operators for assignment, sequencing, and conditionals
00:03:51 <copumpkin> really?
00:04:22 <kmc> yet it has no closures, and so the best you can do as far as first-class functions is an enumeration over a compile-time-fixed set of function behaviors
00:04:48 <roostaj> hiptobecubic: it snowing in lubbock? its a blizzard where i am
00:04:58 <copumpkin> not sure I'd call c expression-based, despite the expressions you mention :P
00:05:10 <hiptobecubic> roostaj, stopped snowing earlier today. We got a few inches though. Ice on the roads.
00:05:12 <kmc> copumpkin, it's certainly a stretch, compared to the C that people actually write
00:05:16 <hiptobecubic> I made my first snowman ever today :)
00:05:20 <kmc> anyway, Haskell has plenty of things that aren't expressions
00:05:45 <copumpkin> how about, its fundamental mode of computation is reducing expressions rather than sequencing statements
00:06:01 <roostaj> hiptobecubic: we drove down I-20 today, took 5 hours to go 70 miles... road shelters set up to help stranded drivers... lots of wrecks. Fun christmas eve for some people :D
00:06:16 * copumpkin makes subtle gestures towards #haskell-blah
00:06:29 <hiredman> http://www.info.ucl.ac.be/~pvr/paradigms.html
00:06:30 <hiptobecubic> That's not very subtle.
00:06:39 * roostaj coughs and looks around
00:06:40 <copumpkin> hiptobecubic: damn, I failed :(
00:06:45 <kmc> copumpkin, this seems rather less OT than the other conversations going on
00:07:15 <roostaj> kmc: i assume copumpkin is pointing at a rooster
00:07:18 <kmc> ah
00:07:19 <kmc> hehe
00:07:22 <roostaj> :P
00:07:31 <roostaj> im off ot bed anyway
00:07:31 <roostaj> goodnight all
00:07:35 <roostaj> have a nice holiday
00:07:40 <copumpkin> damn, I killed the spirit
00:07:44 <copumpkin> g'night :P
00:07:55 <hiptobecubic> night
00:08:02 <roostaj> :)
00:08:50 <copumpkin> hiredman: not sure I'd agree with that chart
00:08:59 <kmc> copumpkin, but what if sequencing is expressed by an expression that you reduce
00:09:21 <copumpkin> kmc: then you have encoded imperative programming in your functional language
00:09:22 <hiredman> copumpkin: I this wouldn't be an irc channel if you did
00:09:53 <copumpkin> :)
00:09:56 <kmc> copumpkin, not necessarily encoded.  i mean things like Scheme's (begin) where the side effects are carried out, not merely metaprogrammed, by the reduction step
00:10:15 <hiredman> it's a pretty char though
00:10:19 <copumpkin> I'm not sure how I feel about impure functional languages :)
00:10:19 <hiredman> chart
00:10:22 <kmc> basically would C be a functional language if we used , instead of ; ?
00:10:28 <kmc> that seems silly to me
00:10:28 <copumpkin> it kind of feels like an oxymoron to me
00:11:01 <Adamant> copumpkin: I like Haskell but that's the Kool-aid talking
00:11:05 <Adamant> plenty of them exist
00:11:09 <kmc> copumpkin, i agree, it's messier.  but i'm also annoyed by the people who use "functional language" to mean "Haskell and nothing else".  we have plenty of words, we can spread them around
00:11:25 <copumpkin> kmc: and agda, and clean, and so on :P
00:11:31 <kmc> in particular some people will argue that you can't have functional programming without static types
00:11:41 <copumpkin> Adamant: well yeah, and I feel uncomfortable with placing them under the "functional" umbrella
00:11:44 <kmc> which is total nonsense to me
00:11:53 <copumpkin> yeah, that is
00:11:55 <someotherguy> it's definitely Haskell, and it may be some other things
00:11:59 <Adamant> copumpkin: then you need to invent a new umbrella to put Haskell under
00:12:02 <someotherguy> problem solved
00:12:10 <Adamant> because it's completely accurate
00:12:26 <copumpkin> Adamant: talking about completely accurate only makes sense if you have a precise definition of the term in the first place
00:12:51 <copumpkin> and it's a fairly contentious term
00:12:57 <copumpkin> so I wouldn't oversimplify
00:13:16 <Adamant> copumpkin: even dons more or less traces the history of Haskell from impure functional languages to pure lazy ones
00:13:56 <copumpkin> I don't really care what dons does :P I'm just saying that there's more than one valid (and common) definition of functional and depending on which you choose, you might include c++, or python, or ruby, or ocaml
00:14:00 <Adamant> I mean I can understand the perspective that Haskell should be considered something else
00:14:16 <copumpkin> so talking about "completely accurate" is an oversimplification :)
00:14:25 <kmc> anyone who includes C++ in their definition is quite twisted
00:14:27 <kmc> maybe C++1x
00:14:30 <someotherguy> "a language that insists on pretending it doesn't have side effects"
00:14:33 <copumpkin> :)
00:14:34 <hiredman> I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
00:14:40 <copumpkin> lol
00:14:40 <kmc> hahahaha
00:14:41 <someotherguy> haha
00:14:47 <kmc> @remember hiredman I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
00:14:48 <lambdabot> It is stored.
00:14:55 <Adamant> but, pterodactyls don't cease to be flying animals because birds came around and also flew :P
00:14:57 <copumpkin> @flush
00:14:57 <lambdabot> Not enough privileges
00:15:13 * copumpkin avoids abusing lambdabot
00:15:18 <Adamant> hiredman: the dons and the milliOleg
00:15:42 <hiredman> http://en.wikipedia.org/wiki/University_don
00:16:10 <Adamant> Don Corleone
00:16:27 <kmc> Donbot
00:16:28 <Adamant> I'm going to make your type checker an offer it cannot refuse
00:16:42 <kmc> irrefutable offer
00:16:48 <copumpkin> fail
00:17:00 <lispy|web> hiredman: no, we use the title simon for that
00:17:14 <lispy|web> hiredman: like, Simon Marlow, Simon Peyton-Jones, etc
00:17:32 <kmc> @quote simonSaysPerformIO
00:17:32 <lambdabot> lilac says: ponders whether unsafePerformIO would be better as simonSaysPerformIO
00:17:46 <hiredman> lispy|web: :P
00:18:40 * copumpkin still wants to create a haskell trophy system
00:18:49 <copumpkin> to give people like HaskellLove something to aim for
00:18:54 <copumpkin> in bite-sized chunks
00:19:24 <Jafet> I just paint the bullseyes afterwards
00:19:24 <copumpkin> "today I shall get the arrow achievement!"
00:19:37 <kmc> copumpkin, he did a lot of "eulers", it didn't seem to help more generally
00:19:54 <copumpkin> I started with a bunch of eulers too, but they get boring and after a while teach you nothing about haskell
00:20:14 <Jafet> They were never meant to teach you anything about Haskell
00:20:16 <c_wraith> About the first three you do teach you interesting things.
00:20:17 <copumpkin> I know
00:20:37 <c_wraith> Also, the first time I ran into a dynamic programming problem, it taught me something useful.
00:20:47 <copumpkin> the histomorphism?
00:21:00 <kmc> copumpkin, but at some point, people told you to learn something other than Euler problems, and you listened to them
00:21:05 <kmc> or you did it yourself
00:21:12 <copumpkin> yep
00:21:16 <copumpkin> well I think he's moved on too
00:21:22 <elly> copumpkin: that's a good idea, actually
00:21:23 <copumpkin> he just decided to pick up a book on type theory
00:21:26 <elly> (the haskell trophy thing)
00:21:35 <copumpkin> :)
00:21:39 <copumpkin> not sure how I'd go about it
00:21:41 <hiredman> merit badges
00:22:02 <copumpkin> and cheating might be a problem, although since the badges don't really get you anything it really doesn't matter much
00:22:07 <Adamant> copumpkin: just integrate it and the Haskell Platform as a Steam game
00:22:12 <copumpkin> lol
00:22:13 <elly> just have a bunch of exercises that use knowledge of different parts of haskell
00:22:15 <elly> Adamant: haha
00:22:30 <copumpkin> mmorrow: I liked your email :P
00:22:30 <elly> copumpkin: if you did that it would make me actually get around to learning haskell :P
00:23:01 <copumpkin> elly: zomg! maybe I'll come up with a few online haskell exercises
00:23:07 <c_wraith> That'd also require someone writing a real-ish IDE
00:23:09 <kmc> Adamant, Haskell PÎ»atform Episode One
00:23:12 <hiredman> http://www.nerdmeritbadges.com/
00:23:22 * elly currently knows scheme and SML, but not really haskell
00:23:43 <Adamant> I dunno if that's actually as crazy as it sounds. there have been some pretty fun little web games that were based on programming a virtual bot to do things
00:23:50 <elly> yes
00:24:24 <Adamant> kmc: now with more lambda, crowbar optional
00:24:27 <copumpkin> hah
00:24:42 <kmc> crowbar is *never* optional
00:24:56 <elly> what about cowbell?
00:25:07 <copumpkin> you can never have too much cowbell
00:25:07 <Adamant> kmc: they didn't give me a crowbar off the bat in HL2:E1
00:25:11 <elly> copumpkin: if you do this, I will beta-test it by learning haskell :)
00:25:14 <c_wraith> with a little art work, the crowbar could *be* a lambda
00:25:15 <kmc> crowbar sounds like a library the likes of spoon or vacuum
00:25:15 <Adamant> I was slightly dissapointed
00:25:24 <copumpkin> elly: okay, I'll add it to my todo list :P
00:25:25 <elly> </bribery?>
00:25:33 <kmc> Adamant, bummer
00:25:54 <Adamant> kmc: but then, sawblades and the gravity gun made up for it
00:26:40 <elly> copumpkin: you know what would be neat? reimplementing parts of the basis, perhaps
00:26:45 <elly> (the arrow library? I dunno)
00:26:57 <elly> I'm sure some parts of the prelude are instructive in implementation
00:27:06 <luite> reimplementing ghc could be a level 50 exercise
00:27:50 <c_wraith> I think achievements should be using various libraries.  ST, STM, Parsec, etc
00:28:01 <elly> hmm, that'd be neat
00:28:35 <c_wraith> I sure felt like I unlocked an achievement after I learned how to use STM. :)
00:29:14 <c_wraith> And ST, for that matter.
00:30:18 <kmc> template haskell
00:30:27 <c_wraith> That's another good one
00:31:06 <mmorrow> copumpkin: hehe
00:31:06 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:32:38 <hiptobecubic> why not just use mesgserv or whatever it is
00:33:15 <elly> lambdabot smells nicer
00:33:55 <copumpkin> elly: yeah, that's true
00:34:12 <elly> re what/
00:34:13 <elly> *?
00:34:21 <copumpkin> reimplementing some basic stuff
00:34:24 <elly> oh, yeah
00:34:45 <elly> "If you want to know if you understand something, try teaching it" <-- an axiom that generalizes :)
00:46:55 <copumpkin> :)
00:48:03 <copumpkin> you know what's cool?
00:48:24 <copumpkin> Cofree Comonads
00:48:37 <whoppix> Coffee monads?
00:50:35 <dblhelix> copumpkin: I take it that's the monad you get when you take the product of the type parameter and a functor, recursively?
00:50:48 <dblhelix> copumpkin: er, the comonad you get... etc.
00:51:23 <copumpkin> yeah, pretty much
00:51:41 <dblhelix> copumpkin: Cofree f a = Fix (K a :*: f) ?
00:52:34 <copumpkin> if :*: is a type-level &&&, yep :)
00:52:41 <dblhelix> okay, I see... (and I think I've seen it before... :)) ... it decorates an f-tree with a-labels
00:52:47 <copumpkin> yeah
00:53:01 <dblhelix> copumpkin: data (f :*: g) a = f a :*: g a
00:53:05 <copumpkin> yep
00:54:16 <dblhelix> copumpkin: yeah, definitely seen that one before... I guess it arises in comonadic attribute grammars and such... cool indeed ;-)
00:54:36 <copumpkin> one interesting one is Cofree ((->) a)
00:54:47 * dblhelix ponders
00:55:39 <copumpkin> http://en.wikipedia.org/wiki/Moore_machine
00:56:39 <dblhelix> Cofree ((->) a) b ~= (b, a -> (b, a -> (b, a -> ...))) ?
00:56:45 <copumpkin> yep
00:56:59 <copumpkin> a state label and a transition function!
00:58:36 <dblhelix> I see.. you get a start state labeled with a b-value and a transition from a-tokens to next states? nice...
00:58:50 <copumpkin> yep
00:59:50 <copumpkin> edwardk showed me the light
01:00:20 <dblhelix> I'm not sure whether I see that the output cannot depend on the input...
01:07:00 <dblhelix> copumpkin: ah, I see now...
01:08:29 <dblhelix> copumpkin: newtype Moore a b = (b, a -> Moore a b)
01:08:30 <dblhelix> copumpkin: newtype Mealy a b = a -> (b, Mealy a b)
01:08:53 <drhodes> is anyone here using a character entry tool for math symbols?  (maybe something like SCIM for hanzi..)
01:09:19 <Jafet> \text{Why?}
01:10:04 <dblhelix> TeX-input in Agda-mode for emacs is pretty neat
01:10:21 <Jafet> SCIM has a latex plugin
01:10:28 <Jafet> But SCIM is crap
01:15:23 <vy> From RWH, I recall some kind of functor/monad(?) usage similar to (a -> b) -> (a,c) -> (b,c). In other words, sth similar to (^2 . snd) (2,3) results in (2,9). Does anybody remember that?
01:15:47 <copumpkin> vy: first
01:15:55 <copumpkin> dblhelix: yep :)
01:16:12 <dblhelix> vy, copumpkin: but first is an arrow operation
01:16:15 <copumpkin> dblhelix: and they're adjoint
01:16:37 <copumpkin> dblhelix: I got the impression he wasn't sure what class/abstraction to look for it in :P
01:17:11 <copumpkin> :t first :: (a -> b) -> (a, c) -> (b, c)
01:17:12 <lambdabot> forall a b c. (a -> b) -> (a, c) -> (b, c)
01:18:19 <vy> :i first
01:18:27 <vy> :t first
01:18:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
01:18:43 <vy> copumpkin: Which module supplies "first"?
01:19:20 <copumpkin> vy: Control.Arrow
01:19:21 <luite> Control.Arrow
01:20:54 <copumpkin> dblhelix: hah, I liked conor's interpretation :P it is surprisingly appropriate
01:21:28 <vy> Is it possible to implement (\(u,v) -> show u ++ v) in a more haskellish style using "first" and "concat"?
01:21:47 <copumpkin> :t uncurry (++) . first show
01:21:48 <lambdabot> forall b. (Show b) => (b, String) -> String
01:21:48 <dblhelix> copumpkin: didn't realise it until he mentioned it, but cofree comonads are definitely in the spirit of Christmas
01:22:13 <copumpkin> vy: ^ :)
01:22:30 <vy> copumpkin: Awesome, thanks!
01:26:37 <dblhelix> back to some writing now, though... enjoy your Christmas Day, you all!
01:26:46 <copumpkin> :) thanks, same to you
01:29:28 <vy> copumpkin: Now there is a new "pretty" function in http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
01:30:11 <copumpkin> :)
01:30:27 <vy> I mean the name of the function is "pretty"! :D
01:45:27 <mreh> those videos on youtube of the attractive lady talking about category theory, are they part of a series?
01:47:02 <mreh> it's quiet in here... there must be something happening today...
01:47:33 <mreh> nope, I have no idea.
01:49:22 <Cale> mreh: If you're talking about Eugenia Cheng's catsters videos, then yes, they're part of a series
01:49:37 <Cale> http://www.youtube.com/user/TheCatsters
01:50:07 <Cale> There are actually quite a few of them, but it's been a while now since the last update.
01:50:34 <mreh> Cale: have you seen khanacademy's channel?
01:50:40 <mreh> it's amaaaaaazing
01:51:16 <mreh> public video lectures are the future of the world
01:52:02 <Cale> :)
01:52:10 <Cale> Looks like an awful lot of videos
01:53:50 <mreh> Cale: I know, his linear algebra ones I can highly recommend
01:54:11 <copumpkin> the catsters are slightly more abstract
01:54:55 <copumpkin> I'd like a higher quality collection of catsters with a diagram of dependencies in a format I can install on my phone
01:55:18 <copumpkin> in fact, we can make a dependency (I guess just a preorder) category of catster videos
01:57:38 <mreh> copumpkin: that would be nice
01:57:57 <copumpkin> maybe I'll email them and ask if there are higher-quality versions I could get and make a pretty package out of
01:58:00 <mreh> 22,000 people have viewed monads, not so many made it to the second video
01:58:07 <copumpkin> yeah, kind of sad
01:58:22 <copumpkin> one of those also has a "related videos" link to blowjob girl
01:58:29 <copumpkin> very random
01:58:39 <mreh> and she's talking about natural transformations and functors off the bat
02:00:11 <mreh> and "The Monad make my head hurt"
02:00:16 <mreh> hahaha
02:00:32 <mreh> s/monad/monads
02:12:17 <chrisdone> merry christmas!
02:12:19 <Cale> Natural transformations and functors are a traditional dependency of understanding monads.
02:12:37 <Cale> and you usually learn them early on in studies of category theory
02:13:23 <Accidus> Cale, thanks for that insight about monads earlier.
02:13:35 <Cale> Accidus: no problem
02:14:05 * Accidus couldn't believe he missed it.
02:14:20 <Cale> Which one in particular?
02:14:33 <Accidus> The one about the partial order
02:14:36 <Cale> Oh, right
02:14:56 <Accidus> If I could get one more theorem right, then I'm set.
02:15:04 <Heffalump> what's the insight?
02:15:06 <Cale> I can't help but think of order theory in terms of categories now.
02:15:22 <Accidus> Where's the harm in that?
02:15:51 <Accidus> Heffalump: That a certain property of partial orders actually corresponds to an indexed set of monads
02:16:28 <rajeshsr> hi
02:16:42 <Cale> Heffalump: He was looking for an associative binary operation on the rationals which is monotone in both parameters, and which had that a <= a * b, and that a * b * b <= a * b
02:16:50 <Accidus> Cale, not the rationals
02:16:55 <rajeshsr> how would one write a Dynamic Programming solution say for fibonacci numbers?
02:16:57 <Cale> not on the rationals?
02:17:02 <Cale> okay :)
02:17:05 <Accidus> Cale, any simple example would have fit
02:17:09 <Cale> ah, okay
02:17:10 <rajeshsr> let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
02:17:21 <Accidus> Cale, and I didn't feel like generating free semigroups and quotienting them
02:17:23 <rajeshsr> any way to memoize it?
02:17:51 <Cale> rajeshsr: Well, you could use the memocombinators library if you want
02:18:01 <Cale> rajeshsr: Or just write the infinite list version instead
02:18:09 <Cale> Or introduce an array for small values
02:18:30 <rajeshsr> Cale, am just a beginner in haskell, so would want to do things without a library, before going to do that
02:18:42 <Heffalump> the next time someone asks me about fib at an interview, I'm going to ask if they're working on Int32, and if so tell them to use a lookup table.
02:18:52 <Cale> rajeshsr: So, the traditional way to write fibs is:  fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
02:19:12 <Cale> rajeshsr: This is memoising because it's a constant, and constants don't get recomputed.
02:19:34 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
02:19:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:19:46 <rajeshsr> Cale, thanks!
02:19:57 <Cale> You could then define fib as looking up the nth element of that list
02:20:15 <Cale> Another way to do it would be to define an array
02:20:16 <rajeshsr> so that is how we do memoizing? Can it be extended for LCS Dynamic Programming?
02:20:50 <rajeshsr> more specifically about DPs with multiple states..
02:22:55 <Heffalump> you can also use a Map as the lookup structure
02:23:08 <Heffalump> that works well when you don't expect every element to be wanted
02:23:54 <Cale> > let big = 100; smallFibs = array (0,big) [(n, fib' n) | n <- [0..big]]; fib' 0 = 0; fib' 1 = 1; fib' n = fib (n-1) + fib (n-2); fib n | n <= big = smallFibs ! n | otherwise = fib' n in fib 100
02:23:55 <lambdabot>   354224848179261915075
02:24:04 <Cale> Sorry for crushing that onto one line
02:24:25 <rajeshsr> Cale, wow! thanks! lemme study that to understand it!
02:24:28 <Cale> But it displays an example of how to use an array to handle the memoisation.
02:24:44 <Cale> Basically, again, since smallFibs is a constant, once computed, it remains computed.
02:25:00 <Cale> The elements of the array are separately lazy, and will only be computed when they're demanded.
02:25:18 <Cale> With the memocombinators library, it's much simpler
02:26:25 <Cale> > let fib = Memo.integral fib' where fib' 0 = 0; fib' 1 = 1; fib' x = fib (x-1) + fib (x-2) in fib 100
02:26:26 <lambdabot>   354224848179261915075
02:26:53 <Cale> The Memo.integral memoiser will memoise any function whose parameter is integer-like
02:27:59 <rajeshsr> Cale, oh, ok! thanks. That looks good! Anyway is there any nice Haskell tutorial out there catering to the needs of a CS student?
02:28:00 <Cale> and it actually achieves this in an extremely clever way, which makes use of how lazy evaluation doesn't recompute the parameters to functions.
02:28:25 <Cale> Hmm... well, you should know about learnyouahaskell and the Real World Haskell book.
02:28:53 <Cale> There are some others, like Yet Another Haskell Tutorial and the wikibook
02:28:57 <Cale> @where lyah
02:28:57 <lambdabot> http://www.learnyouahaskell.com/
02:28:59 <Cale> @where rwh
02:28:59 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:29:03 <Cale> @where yaht
02:29:03 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
02:29:07 <Cale> @where wikibook
02:29:07 <lambdabot> http://en.wikibooks.org/wiki/Haskell
02:29:28 <Cale> Of course, feel free to ask questions here
02:30:11 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
02:30:22 <Cale> ^^ documentation for the data-memocombinators library
02:31:35 <Cale> The real equivalent of the array one that I wrote would be...
02:31:54 <Cale> > let fib = Memo.arrayRange (0,100) fib' where fib' 0 = 0; fib' 1 = 1; fib' x = fib (x-1) + fib (x-2) in fib 100
02:31:55 <lambdabot>   354224848179261915075
02:32:35 <Cale> That only memoises the first 100 (putting limits is good if you want low memory usage)
02:32:50 <Cale> But will be obviously slower for high parameter values
02:32:58 <Cale> > let fib = Memo.arrayRange (0,100) fib' where fib' 0 = 0; fib' 1 = 1; fib' x = fib (x-1) + fib (x-2) in fib 140
02:33:02 <lambdabot>   mueval-core: Time limit exceeded
02:33:10 <Heffalump> Cale: the list-based version seems ideal in this instance, since it only takes up memory as far as you actually evaluate
02:33:12 <Cale> > let fib = Memo.integral fib' where fib' 0 = 0; fib' 1 = 1; fib' x = fib (x-1) + fib (x-2) in fib 140
02:33:13 <lambdabot>   81055900096023504197206408605
02:33:43 <Cale> Heffalump: Yeah, though if you're using it as a function, scanning through the list is a bit painful
02:34:09 <Cale> The integral combinator will effectively build a binary tree out of function structure
02:34:26 <Heffalump> how does it do that?
02:34:43 <Cale> It operates on the bits of the number
02:35:11 <Cale> integral :: (Integral a) => Memo a
02:35:11 <Cale> integral = switch (>= 0) unsignedIntegral (\f -> unsignedIntegral (f . negate) . negate)
02:35:17 <Cale> unsignedIntegral :: (Integral a) => Memo a
02:35:17 <Cale> unsignedIntegral f = list bool (f . integralFromBits) . integralBits
02:35:45 <Cale> integralFromBits and integralBits just do the obvious conversion back and forth to lists of Bool
02:36:04 <Cale> bool and list are where the clever bit is :)
02:36:07 <Cale> bool :: Memo Bool
02:36:07 <Cale> bool f = cond (f True) (f False)
02:36:07 <Cale>     where
02:36:07 <Cale>     cond t f True  = t
02:36:07 <Cale>     cond t f False = f
02:36:46 <Cale> Because (f True) and (f False) are parameters, they'll only be evaluated once and shared between calls
02:36:59 <Cale> list :: Memo a -> Memo [a]
02:36:59 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
02:36:59 <Cale>     where
02:36:59 <Cale>     table nil cons [] = nil
02:36:59 <Cale>     table nil cons (x:xs) = cons x xs
02:37:19 <Cale> This is a similar trick, but elaborated to work for lists
02:39:13 <Heffalump> ah, operating on the bits is how I'd have assumed it worked, but your comment about "out of function structure" confused me
02:40:01 <Cale> Yeah, the binary trees are totally implicit in how this recursion builds the required function
02:41:43 <rajeshsr> Cale, thanks. Sorry got disconnected! I really wondered about how DPs could be put into Haskell elegantly! Thanks for such a nice explanation
02:43:47 <Cale> rajeshsr: Well, once you can memoise any function that you'd like to work with, isn't that essentially enough?
02:44:03 <Cale> You can memoise functions of more parameters as well
02:44:21 <rajeshsr> yeah, i would like to know about memoizing complex DPs
02:44:33 <rajeshsr> with many state variables
02:44:53 <Cale> Just to check that we're on the same page, you mean dynamic programming problems?
02:45:19 <rajeshsr> yeah, of course. Like LCS etc..
02:47:14 <Cale> okay
02:55:04 <Cale> I suppose we can work on memoising the recursive definition given on the wikipedia page. It's a bit awkward to use that one with lists because of all the indexing, but perhaps there's a way to simplify the description of this
02:56:50 <Cale> In principle, it just amounts to defining a function  lcs' i j which gives us the longest common subsequence of the prefixes of length i and j respectively, and then memoising it and applying it to the appropriate lengths for the full strings
02:57:24 <Cale> So if you can write the naive version, you can write the DP version just by applying the appropriate memo combinator and replacing a few recursive calls.
03:00:33 <Cale> actually, makes a whole lot more sense using the tails
03:08:05 <Cale> aw, he quit
03:08:14 <Cale> rajeshsr: There you are :)
03:08:21 <Cale> rajeshsr: I have a solution to lcs for you
03:08:25 <rajeshsr> Cale, am really sorry! Net is quite unstable..
03:08:31 <rajeshsr> yeah tell me
03:08:47 <rajeshsr> thanks, can you paste it?
03:11:24 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15001#a15001
03:11:56 <Cale> rajeshsr: Because the lists get indexed a whole lot, I turn them both into arrays
03:12:34 <rajeshsr> Cale, thanks! let me look at that
03:13:18 <Cale> rajeshsr: Instead of using Memo.arrayRange, I could also have used Memo.integral like before.
03:13:36 <xle> Hey all.. I'm trying to put together something that would socksify a redirect from iptables to a socks server.. I want to do the tcp part and then the udp part to support both under SOCKS5. Any ideas on how I can go about doing this?
03:14:03 <Cale> I don't know how well it performs on real examples, but it at least works well on toy examples here, and is a lot faster than the non-memoised version.
03:14:23 <xle> I will need to implement a low level handshake with the socks server and then forward all incoming packets coming from a remote client to the socks server.
03:16:00 <Cale> xle: Apart from "you sound like you'll want to use the low level network interface?" I don't really have much to offer, as I have no idea about socks.
03:17:15 <xle> Cale: yeah, i think so too. Essentially, I will have to inspect the IP/TCP headers to figure out where the packet was targeted, establish a connection to the SOCKS server and forward the body of the packet.
03:17:36 <Cale> rajeshsr: Note that laziness is taking care of everything when it comes to deciding which entries of the memo table are actually computed.
03:17:41 <rajeshsr> Cale, hmm, ok! thanks. I got now how memoization can be done in haskell. Awesome indeed! But wishing that it should get more brief! :)
03:17:42 <xle> Cale: The first question for me was, how do I inspect the tcp/ip headers? As far as I know, Network library is too high level to show me that
03:18:03 <Cale> rajeshsr: Well, LCS isn't a completely trivial example to use, I guess
03:18:24 <Cale> rajeshsr: The changes you have to make to do the dynamic programming bit are easy, yeah?
03:18:42 <Cale> rajeshsr: Most of the code is in the naive implementation of the function.
03:18:45 <rajeshsr> Cale, yeah of course! :)
03:19:28 <Cale> oh, great, where the heck did the documentation for the Network library go?
03:20:31 <DigitalKiwi> I eated it
03:20:45 <DigitalKiwi> 'twas yummy
03:20:54 <Cale> aha, there's some documentation linked from here: http://hackage.haskell.org/package/network-2.2.1.5
03:21:57 <Cale> xle: Hmm, perhaps it is
03:23:47 <Cale> hmm, this package defines datastructures for the appropriate headers http://hackage.haskell.org/package/network-data
03:23:55 <Cale> I'm not sure how it ought to be used...
03:27:55 <xle> Here's another network library that seems interesting: http://hackage.haskell.org/package/network-fancy
03:28:33 <xle> yeah, so I'll get the destination IP from IP headers and port information from TCP/UDP headers
03:29:14 <Cale> http://hackage.haskell.org/package/pcap -- not sure what this is good for, but it looks interesting
03:29:51 <xle> Cale: ah yeah, that's for tcpdumping
03:30:02 <copumpkin> I want to do something awesome with pcap
03:30:05 <copumpkin> but no time so far
03:30:28 <alp_> what is it ?
03:30:42 <Cale> xle: I suppose if all else fails, you can ffi import the appropriate system calls.
03:30:50 <copumpkin> a scapy-alike in haskell, with several improvements
03:30:53 <alp_> (the thing you want to do)
03:32:34 <copumpkin> (http://www.secdev.org/projects/scapy/)
03:32:56 <copumpkin> scapy has the disadvantage that it's hard to do real-time stuff in it
03:33:35 <copumpkin> I tried to do some seriously sketchy 802.11 stuff in it a while ago and python just wasn't fast enough to respond within the timeouts for 802.11
03:34:30 <copumpkin> also, having a monadic packet query generator that compiles to bpf programs would be pretty awesome
03:34:54 <copumpkin> (that's where the pcap package would come into play)
03:35:27 <copumpkin> but it's not very high up on my priority queue
03:36:12 <Cale> rajeshsr: oh, by the way, just so that it's clear how I wrote that, it's essentially this version from wikipedia: http://upload.wikimedia.org/math/e/4/9/e49ef6db695cb7edc3da7d67325fd97a.png
03:36:30 <copumpkin> a histomorphism!
03:36:31 <Cale> rajeshsr: Except that instead of prefixes, I went with suffixes.
03:36:49 <rajeshsr> Cale, yeah i get the algorithms
03:41:55 <NewbieWithQuesti> I'm running the latest haskell platform on win7 and 'cabal update' keeps telling me that there is a new versino of cabal-install even after I do a 'cabal install cabal-install'. Any insights would be appreciated!
03:42:22 <copumpkin> does cabal install cabal-install succeed?
03:42:31 <Cale> NewbieWithQuesti:  cabal --version
03:42:39 <NewbieWithQuesti> yes it does, provided I run as admin (which I am doing)
03:42:52 <Cale> Which version of cabal does it claim to be?
03:42:55 <NewbieWithQuesti> when I go check in program files\haskell\bin it seems to regenerate the same binary repeatedly
03:42:57 <NewbieWithQuesti> just a sec
03:43:09 <NewbieWithQuesti> cabal-install version is 0.6.4
03:43:14 <Cale> hmm
03:43:24 <luite> NewbieWithQuesti: perhaps the directory with the old cabal.exe is in your path before the cabal bin directory
03:43:28 <NewbieWithQuesti> using version 1.6.0.3 of the Cabal library it says
03:43:36 <NewbieWithQuesti> just a sec...
03:43:40 <Cale> That's what mine says here...
03:43:56 <Cale> cale@zaphod:~$ cabal --version
03:43:56 <Cale> cabal-install version 0.6.4
03:43:56 <Cale> using version 1.6.0.3 of the Cabal library
03:44:34 <Cale> and no complaints on update
03:44:45 <Cale> So perhaps it is a windows thing.
03:44:46 <luite> have you run cabal update recently?
03:44:55 <NewbieWithQuesti> Doesn't seem to be any ld version in my path. A dir/s indicates that there is one in program files\haskell\bin and another one tucked away in the platform extralibs
03:45:15 <NewbieWithQuesti> yes, I ran cabal update a few minutes ago, which asked me to do this update of cabal-install
03:45:26 <luite> oh I was asking Cale :)
03:45:39 <NewbieWithQuesti> sorry :-))
03:45:48 <Cale> luite: Somewhat recently before I just tested it now
03:47:49 <tibbe> @seen JaffaCake
03:47:49 <lambdabot> Unknown command, try @list
03:48:00 <Cale> heh, cabal list cabal-install seems to think that cabal install is not installed, which is kind of odd.
03:48:13 <Cale> also, that there's a newer version available
03:48:21 <copumpkin> preflex: seen JaffaCake
03:48:21 <preflex>  JaffaCake was last seen on #ghc 3 days, 22 hours, 10 minutes and 50 seconds ago, saying: does substExpr go inside the types too?
03:48:45 <Cale> oh, maybe I know what's going on
03:49:02 <luite> you downloaded a separate cabal-install executable?
03:49:04 <NewbieWithQuesti> OK I found the problem - it looks like the haskell platform updated my path so that the extralibs\bin comes before progfiles\haskell\bin. So the 'cabal update cabal-install' is updating the latter while the former gets invoked. Good catch- thank you!
03:49:23 <Cale> There *is* a newer version, but I think perhaps it's not intended for 6.10.x?
03:49:32 <copumpkin> oh, yeah, that's probably it
03:49:54 <luite> hmm, that shouldn't be the problem, as you should upgrade cabal-install before installing 6.12
03:50:02 <luite> otherwhise you need to bootstrap it manually
03:50:18 <copumpkin> maybe we can get more interest in quickcheck from the general programmer population by calling it a fuzzer rather than a testing tool
03:50:40 <Cale> Well, it doesn't appear to be the version which cabal install selects by default. Explicitly specifying a version number will get it to upgrade.
03:50:43 <copumpkin> people's eyes seem to glaze over when I tell them about quickcheck generating automatic test cases
03:50:50 <copumpkin> even people who are sold on testing
03:51:38 * Cale used quickcheck to falsify a simple number theoretical conjecture today, rather than thinking about it.
03:51:49 <copumpkin> I've wanted quickcheck in agda, actually
03:52:06 <copumpkin> the past couple of days I've accidentally tried to prove things that weren't correct
03:52:22 <copumpkin> and a quick poke from quickcheck would have caught that
03:52:46 <Cale> heh, have agda quickcheck things in the background while you try to prove them, so if it finds a counterexample, it can stop you :)
03:52:49 <copumpkin> it seems like it would be a decent helper tool
03:52:53 <copumpkin> yeah :)
03:53:11 <NewbieWithQuesti> I'm trying to manually upgrade cabal as you suggest, but the cabal web page liasts 1.6.0.2 as the latest version whereas I have 1.6.0.3 as a consequence of doing a cabal install.
03:53:30 <luite> cabal comes with ghc
03:53:32 <copumpkin> omg a Saizan
03:53:42 <alp_> * Cale used quickcheck to falsify a simple number theoretical conjecture today, rather than thinking about it. <<< a bad advertisemennt for it would be "QuickCheck prevents you from thinking."
03:53:54 <copumpkin> lol
03:53:56 <NewbieWithQuesti> so if I overlay 6.12 over my haskell platform then it will all be kosher?
03:54:03 <copumpkin> saves you from thinking about stuff a computer can do for you
03:54:07 <copumpkin> that's generally a good thing :)
03:54:13 <alp_> yeah
03:54:17 <copumpkin> so you can use your limited brain cycles on more interesting things
03:54:28 <alp_> like CT
03:54:38 <copumpkin> it's very frustrating to find that the lemma your proof is built on is false
03:54:41 <Cale> NewbieWithQuesti: It probably won't see anything you have installed already
03:54:42 <luite> NewbieWithQuesti: cabal-install will fail to do anything with ghc 6.12 if it's not updated to 0.8 first
03:54:52 <Cale> (apart from executables)
03:55:03 <Cale> You'll have to install packages for 6.12 separately
03:55:38 <NewbieWithQuesti> got it - thank you much, Cale and luite. Smogasbord it is then...
03:56:52 <luite> NewbieWithQuesti: are you using windows? I may be able to send you a working version 0.8 cabal.exe if you want
03:57:24 <NewbieWithQuesti> Yes, I'm using win7. would much appreciate it: borgmace@gmail.com
03:58:23 <luite> (it's a pain to build, you need some patches to network and install a bunch of packages manually)
03:58:30 <luite> one moment, I'll walk to my windows computer
03:58:49 <NewbieWithQuesti> ok
03:59:40 <copumpkin> NewbieWithQuesti: in general, it is not wise to give out your email address in public on the internet
03:59:55 <NewbieWithQuesti> got it - that one is expendible :-)
04:00:05 <copumpkin> NewbieWithQuesti: this channel contains over 600 people and is publicly logged, so any number of people can do things with it :)
04:00:16 <NewbieWithQuesti> one of my nyms but thanks for the warning!
04:01:25 <dolio> Cale: What's with flip?
04:01:30 <tibbe> Does anyone know of an efficient priority queue implementation?
04:01:40 <copumpkin> tibbe: harrop does, I'm sure
04:01:56 <tibbe> copumpkin: it needs to be persistent
04:02:05 <tibbe> copumpkin: for concurrent use
04:02:17 <copumpkin> tibbe: then it's necessarily 10000000000000000000 times slower than an F# priority queue, I'm sure
04:02:19 <dolio> It's impossible to write efficient immutable data structures. :)
04:03:30 <tibbe> copumpkin: don't let harrop get to you
04:03:44 <tibbe> copumpkin: I'm gonna benchmark it :)
04:03:45 <copumpkin> I was cheering when mmorrow sent his second email
04:03:56 <copumpkin> :)
04:06:07 <luite> NewbieWithQuesti: I sent you the mail (it took me a while to find the file, it was in a different place than I expected)
04:06:59 <luite> NewbieWithQuesti: oh, gmail didn't accept it because it's an illegal attachment :(
04:07:19 <sinelaw> Peaker, yo
04:07:32 <necroforest> luite: i think if you change the extension it will work
04:07:36 <necroforest> name it like .zzz
04:08:11 <mreh> :t (&&&)
04:08:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:08:49 <Cale> tibbe: PSQueue?
04:09:02 <tibbe> Cale: one of my candidates
04:09:05 <Cale> tibbe: That's more than a priority queue alone
04:09:13 <tibbe> Cale: it's a pit confusing though, there's a priority and a key but no value
04:09:40 <mreh> what does that type context mean?
04:09:44 <luite> NewbieWithQuesti: see /msg for url :)
04:10:05 <Cale> tibbe: That's because it's like a normal priority queue, but it supports set-like searching on keys
04:10:08 <copumpkin> this proof is kicking my ass
04:10:38 <tibbe> Cale: Right which is great but I would expect to be able to also keep a value that's distinct from the key
04:11:37 <Cale> tibbe: Should be possible, though, you could just use pairs.
04:11:47 <tibbe> Cale: right
04:11:53 <tibbe> Cale: although I want it unboxed
04:12:05 <copumpkin> premature optimization is the root of all evil
04:12:11 <copumpkin> or something like that
04:12:14 <copumpkin> I think there's a cream for that
04:12:18 <Cale> Well, everything is boxed here anyway
04:12:56 <Cale> I wrote a rough implementation of PSQueue in terms of fingertree and put it on hackage as well.
04:13:13 <tibbe> copumpkin: this is mature optimization
04:13:23 <Cale> I didn't bother benchmarking it, since I only wrote it because I thought fingertree could use more examples.
04:13:32 <tibbe> copumpkin: we're optimizing GHC's I/O manager
04:13:52 <tibbe> Cale: I'm going to make a specialized, unboxed version
04:13:53 <copumpkin> tibbe: unboxing everything still isn't necessarily going to change the performance much
04:14:02 <tibbe> copumpkin: Criterion will tell me
04:14:16 <copumpkin> :)
04:14:18 <tibbe> copumpkin: I want to scale to 50-100k elements
04:14:42 <copumpkin> I think you should optimize it with a dynaparamorphic zygomorphism
04:14:54 <tibbe> copumpkin: of course
04:14:57 <sinelaw> ???
04:15:13 <sinelaw> youre kidding
04:15:28 <Cale> sinelaw: yes, that was a joke
04:15:44 <sinelaw> you killed tibbe
04:15:47 <Cale> sinelaw: Though there are things with similar names
04:15:54 <sinelaw> i know!
04:17:51 <chrisdone> oh nice, one could hookup fdo-notify with ghc
04:17:56 <chrisdone> "x has finished compiling"
04:24:30 <someotherguy> hi
04:32:44 <skorpan> ooh, cool, hydrairc
04:32:46 <skorpan> i'll try that
04:38:53 <chrisdone> I did try that, what a pile of crap
04:40:56 <chrisdone> some guy's closed source all-my-design-decisions-are-correct and-somehow-not-as-good-as-mirc vanity project
04:40:57 <chrisdone> <_<
04:41:25 <jewel> I thought most open-source projects were vanity projects
04:41:58 <copumpkin> "The professional IRC client" says it all
04:42:08 <copumpkin> reminds me of our industrial-strength parsers
04:42:57 <chrisdone> a vanity project usually stops being a vanity project when it has a point/usefulness other than bigging up the developer's ego
04:43:17 <copumpkin> needs moar synergy and forward mobility
04:43:53 <alp_> "the latest in super responsive un-bloated GUI toolkits (Windows Template Library)"
04:43:54 <alp_> haha
04:43:59 <alp_> very funny
04:45:50 <mreh> can I spoof my IP address to get academic papers?
04:46:04 <mreh> I suppose I could just tunnel through my university
04:48:29 <copumpkin> mreh: spoofing doesn't really work very well on the internet
04:49:19 <Jonno_FTW> http://qdb.us/301020
05:08:44 <maltem> Anyone around who can tell if the iteratee monad instance (in the iteratee package on hackage) does respect the monad laws?
05:10:14 <maltem> For example, I'm wondering if  x >>= return  =  x  holds if x returns a "Done"
05:11:15 <copumpkin> @hackage iteratee
05:11:15 <lambdabot> http://hackage.haskell.org/package/iteratee
05:11:16 <maltem> ah, I figure it does. nvm
05:14:22 <dolio> I would assume that Done >>= f = Done forall f.
05:15:30 <dolio> Or is it not just a Done?
05:16:03 <maltem> The notation is a little havier due to the monad m involved
05:16:08 <maltem> *heavier
05:18:22 <maltem> it's  Iteratee f >>= return  =  Iteratee f, with f :: Stream -> m Iter
05:18:35 <ijnek> gtk2hs from darcs head doesn't seem to gc pixbufs created by pixbufNewFromFile
05:18:43 <maltem> (I'm shortening IterateeG c el m a etc. to Iteratee, etc.)
05:20:04 <merijn> Is there something like Python's raw strings for working with regex's? (i.e. strings where \ is not used as an escape avoiding the mess of having to double escape everything)?
05:21:06 <Saizan_> no
05:21:52 <maltem> merijn, maybe TH provides something related?
05:23:35 <merijn> maltem: That seems a little out of my league for now. It was more of a curiosity thing anyway. Nothing is as annoying as doing things the hard way for months only because you didn't bother to ask if there was an easier way :p
05:26:03 <maltem> true, true
05:27:20 <xle> hey guys, i'm trying to modify the Network.Socket library and use it for a little tool i'm building. How can I get my Main.hs to use my version instead of the standard library?
05:29:02 <Saizan_> xle: you can put the module in your source tree
05:29:34 <xle> may sound funny, but I'm not sure how to load a file that's in a sub-directory
05:29:36 <Saizan_> e.g. if you've foo/Main.hs and foo/Network/Socket.hs, when you compile Main.hs it should pick it
05:29:45 <xle> ah really?
05:29:57 <xle> ok, so all subdirectories are namespaced via (.) characters in module names
05:30:01 <Saizan_> yeah, if you've import Network.Socket in Main
05:30:08 <Saizan_> yeah
05:30:12 <Lemmih> xle: Why are you modifying Network.Socket?
05:30:43 <xle> Lemmih: It doesn't let me access SocketOption SO_ORIGINAL_DST in the IP layer
05:30:57 <xle> in other words, there are pre-defined algebraic names for each SocketOption
05:31:02 <xle> and I need to use one that is not defined there
05:31:51 <xle> I guess the other option is to re-implement the socket C FFI in my own tool and call that one by myself.. I'm afraid that's going to be too much work
05:37:14 <xle> Hm I put the Network.Socket lib into Network/Socket.hs, but my tool is still loading from the standard lib
05:38:17 <increpare> xle: why do you want to copy over a standard module?
05:38:19 <Saizan_> xle: how are you compiling it?
05:38:31 <Saizan_> increpare: he just explained that :)
05:38:59 <increpare> Saizan_: drat.  I arrived too late...I'll go check the logs...
05:40:46 <xle> Saizan_: I'm compiling by just doing ghc --make
05:41:47 <Saizan_> xle: try by cleaning the .hi files
05:42:11 <Saizan_> xle: and Socket.hs needs to have module Network.Socket where at the top
05:42:46 <xle> Saizan_: Yeah, I haven't modified the socket module by much. The structure is the same. Also, it is Socket.hsc and not Socket.hs
05:43:55 <skorpan> why does (1) typecheck, but not (2)?  (1) do { modifyState (ind:) ; return $ Just Indent } (2) modifyState (ind:) >> return $ Just Indent
05:44:11 <skorpan> oops, never mind :P
05:44:43 <increpare> brackets?
05:44:49 <koeien37> the $ has lower prio
05:44:54 <skorpan> yep, it was the ($)
05:45:15 <skorpan> thus ghc saw (modifyState (ind:) >> return) (Just Indent)
05:45:32 <increpare> hehheh
05:48:36 <increpare> I'm working on a small game right now.  I have a lot of mixed static/mutable data (say a room with information about its collision properties (static data), and a list of people in it ) - are there any rough principles as to how much or how little one should separate mutable (by the base IO monad) and immutable data structures? (there's part of me that's wary of having a datatype data Room =
05:48:37 <increpare> Room{id:Int,members:[Person],collisiondata:[Mesh]}, but I don't know if it's superstition or not...)
05:50:05 <increpare> also in general I find myself leaning towards having things references eachother by index rather than directly (so there's only one copy I have to change when I want to change something)
05:50:50 <xle> Saizan_: When I run make with -v, it doesn't includ .hsc in its search path. Any idea how I can get ghc to look at .hsc files as well?
05:50:59 <skorpan> > find (==3) [1..10]
05:51:00 <lambdabot>   Just 3
05:51:12 <skorpan> > takeWhile (/=3) [1..10]
05:51:13 <lambdabot>   [1,2]
05:52:33 <skorpan> > drop 2 [1..10]
05:52:34 <lambdabot>   [3,4,5,6,7,8,9,10]
05:56:10 <mornfall> increpare: How do you make your mutable data?
05:56:23 <mornfall> increpare: If that's just IORef [Person], it doesn't make a difference really.
05:56:24 <skorpan> :t iterate
05:56:25 <lambdabot> forall a. (a -> a) -> a -> [a]
05:56:25 <increpare> mornfall: well it'll chiefly be modified through the io monad
05:56:54 <increpare> mornfall: oh right, I hadn't really thought about putting IORefs inside pure-seeming data-structures
05:56:55 <mornfall> increpare: I more mean like what mutable data structures you use.
05:57:17 <mornfall> increpare: No, no. Well, you can do that, but still, it won't buy you any real performance, likely.
05:57:27 <skorpan> :t negate
05:57:27 <lambdabot> forall a. (Num a) => a -> a
05:57:49 <mornfall> increpare: Since if you update an ioref of a list, the list update is pure, only the ioref bump to the new list is mutation.
05:58:07 <increpare> mornfall: frequently am updating ADT-defined trees right now (and also lists)
05:58:39 <mornfall> increpare: Yeah, ADTs (which lists are, too) don't make a real difference. Unless you use mutable arrays or so, I don't think it makes much sense worrying about making things mutable.
05:58:41 <increpare> mornfall: I'm not sure exactly what you mean by that last statement?
05:59:20 <mornfall> increpare: Or are you concerned about design and not about speed? :)
05:59:25 <increpare> mornfall: right so - I guess I'll hold off worrying until I find I need to optimise, so : )
05:59:59 <skorpan> @hoogle Maybe a -> a
06:00:00 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
06:00:00 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:00:00 <lambdabot> Data.Monoid First :: Maybe a -> First a
06:00:01 <mornfall> Also, legend has it that mutable data comes at a price in GC performance.
06:00:41 <increpare> mornfall: I'm concerned with both (I guess for the purposes of my question above I was talking about speed, but you can take it as a given that I'm concerned at all times about design : )  )
06:02:40 <mornfall> increpare: Well, the first relatively safe bet is to express your game as pure functions over suitable data structures. So it may look like turn :: Map -> Actors -> Actors, eg. You can easily build the imperative outer framework on top of that, then.
06:03:18 <increpare> mornfall: yeah, that's pretty much what I'm doing : )
06:04:31 <increpare> As a stylistic issue, I find myself frequently vascillating between explicitly passing RandomGen variables to functions and wrapping them in MonadRandom - I made good use of the latter last week, but this week I am unendeared to it
06:13:25 <Saizan_> xle: no, but you could make a .cabal file, then cabal would preprocess the files for you
06:13:43 <xle> Saizan_: I see.. thanks, I'll take a look at that
06:16:43 <xle> Saizan_: Can the cabal file generate an executable in the end?
06:18:21 <xle> Saizan_: Or can I use cabal config of the original library to generate an object file that I can link to from my tool's source?
06:19:44 <Saizan_> xle: yes, you can have even only an Executable in a .cabal file
06:20:15 <Saizan_> xle: e.g. http://hackage.haskell.org/packages/archive/happy/1.18.4/happy.cabal
06:26:58 <xle> Saizan_: OK, so I built the modified Network module in a local directory. It generated a dist folder with a bunch of .o files inside, which makes sense. How can I now include these in my tool project?
06:28:35 <Saizan_> xle: i thought you could add the modified parts of your Network inside your tool project, otherwise you could just edit them in the context of the network package and install it under a new version
06:29:07 <Saizan_> or even a new name
06:29:15 <xle> Saizan_: I could add them in the tool, but they require lots of .h files, etc. to properly compile.. I'm afraid it might get a bit messy.
06:29:34 <xle> Saizan_: A new name sounds good actually. I need to change filenames everywhere for that? (and module names)
06:30:08 <Saizan_> xle: no, just name name: field in the .cabal file, you can continue to use the same module names
06:31:00 <xle> Saizan_: OK. But if they have the same module names, how would I import them vs. the original library modules?
06:31:38 <Saizan_> xle: in the .cabal file for your tool you'd specify mynetwork instead of network, so it'd know how to resolve names
06:31:45 <koeien37> or ghc-pkg hide network
06:31:53 <Saizan_> xle: and for bare ghc compilation, what koeien37 said
06:31:59 <koeien37> if you're too lazy to cabalize your tool
06:32:49 <xle> koeien37: do I run ghc-pkg before and after compilation then?
06:32:58 <Saizan_> just before
06:33:10 <xle> how do I un-hide it then? :)
06:33:12 <Saizan_> and just once suffices, not at every compilation
06:33:15 <koeien37> ghc-pkg expose
06:33:40 <Saizan_> or you can pass -hide-package network
06:33:44 <koeien37> ghc-pkg list gives you a list of all packages installed; type just "ghc-pkg" for some help on this tool
06:33:56 <xle> ah great, thanks
06:34:20 <xle> so if I go the cabal way, I would specify mynetwork under build-depends section, right?
06:34:24 <Saizan_> xle: however i'd also try mailing network's maintainer, he might jsut include your change
06:34:25 <koeien37> yes.
06:34:57 <xle> Saizan_: I think I will! I want to make sure my custom additions work well, then I will get in touch with him!
06:38:22 <xle> Great!
06:38:26 <xle> It worked - thanks a lot guys!
06:38:37 <xle> and I learned cabal as a bonus :)
06:39:04 <koeien37> Cabal isn't that hard to pick up, but it's very useful :)
06:52:04 <skorpan> :t listToMaybe
06:52:05 <lambdabot> forall a. [a] -> Maybe a
06:52:17 <skorpan> @hoogle [Maybe a] -> [a]
06:52:17 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
06:52:17 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:52:17 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:52:23 <skorpan> @src catMaybes
06:52:23 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:54:59 <increpare> One thing I find with haskell, that amuses me, is that I seem more more naturally inclined to split things up into many modules than I do when I'm doing stuff with C.  Might just be because I only have half as many files to add when I decide to...
06:55:26 <skorpan> i think that's because in other languages, making abstractions is not as easy
06:55:56 <skorpan> when i'm doing C# i find myself creating lots of dummy interfaces and huge abstract classes which really only fit in one place
06:56:41 <increpare> skorpan: you think that abstraction comes into it? hmm
06:59:19 <increpare> I'm personally still inclined towards the 'one file' theory.  Though, that said, I don't have as many troubles adding new source files with AS3 (java-style one-class-per-file), but it's still not quite as effortless-feeling an endeavour.
06:59:28 <luite> anyone encountered this error when installing network-2.2.1.6?    `fdIsSocket_' is not a (visible) field of constructor `FD'
07:00:30 <koeien37> luite: that sounds like you're trying to compile a version of network with a version of GHC that is not compatible with it
07:00:58 <Veinor> copumpkin: the joke is that it's a derivation of why the term for those tables is 'tableau' and not 'table' :P
07:02:02 <luite> koeien37: 2.2.1.5 compiles fine with ghc 6.12.1, 2.2.1.6 (which was released yesterday) doesn't
07:02:56 * hackagebot upload: bindings-libftdi 0.1 - Low level bindings to libftdi. (SivaramGowkanapalli)
07:12:50 <joe1> i uploaded a package to hackage but cannot find it. any thoughts, please?
07:17:45 <Saizan_> how's it called?
07:18:33 <joe1> bindings-libftdi
07:19:09 <burp> http://hackage.haskell.org/package/bindings-libftdi-0.1
07:19:13 <burp> why can't you find it?
07:19:22 <skorpan> @pl \x -> indentation x > 0 || length (tokens x) > 0
07:19:22 <joe1> thanks. i did not the url link
07:19:22 <lambdabot> ap ((||) . (> 0) . indentation) ((> 0) . length . tokens)
07:19:25 <skorpan> ...
07:19:30 <skorpan> does lambdabot know about arrows?
07:19:37 <skorpan> or rather does @pl know about arrows?
07:19:44 <xerox> skorpan: how's your indentation aware parser coming about?
07:19:54 <Saizan_> skorpan: not much
07:20:03 <skorpan> xerox: that's exactly what i'm working on now :)  trying to figure out what the best lexer data structure is
07:20:09 <skorpan> data ReLine = Line { indentation :: Int, tokens :: [String] }
07:20:26 <skorpan> so i figured i'd take care of invalid indentation in the parser
07:21:20 <swapnil> Hi, I'am in intermediate stage of learning Haskell ( i understand monads), anyone can suggest me small haskell application for just learning
07:21:41 <skorpan> swapnil: make up your own little language and interpreter for it
07:22:20 <burp> solve project euler problems
07:22:20 <Saizan_> xmonad has a nice core
07:23:09 <Philonous1> swapnil: Write you a scheme
07:23:11 <Saizan_> isn't project euler for beginners rather than "intermediate"?
07:23:40 <joe1> in my experience, start doing something practical (at work) with it.
07:23:46 <Twey> Saizan_: o.@
07:23:55 <swapnil> i think interpreter is best
07:26:28 <Saizan_> Twey: well, the effort in PE looks more in solving the problems mathematically, the programming part was always quite limited in scope
07:26:40 <skorpan> can i do something nifty with arrows to make this pointfree?  \x -> indentation x > 0 || length (tokens x) > 0
07:26:40 <Twey> Aye
07:27:53 <xerox> I think it looks nice that way.  Or  liftM2 (||) ((0<) . indentation) ((0<) . length . tokens)  but that hides the shape. imo.
07:27:55 <Twey> skorpan: Monads, even
07:28:26 <skorpan> Twey: was xerox's idea what you were thinking as well?
07:28:48 <Twey> Basically
07:28:50 <Jonno_FTW> wow, project euler 79 was incredibly easy
07:29:00 <Twey> Or maybe a list
07:29:21 <skorpan> i'll just stick to pointful then
07:29:35 <skorpan> not very pretty in the full context though: filter (\x -> indentation x > 0 || length (tokens x) > 0) <$> lexerLine `sepBy` newline
07:29:41 <Twey> \x -> all (> 0) [indentation x, length $ tokens x]
07:29:51 <Twey> Hard to get the x out of there, then, though
07:29:56 <Twey> Oh, duh
07:29:59 <xerox> I think he wants  any  not  all
07:30:04 <Twey> Er, yes, sorry
07:30:38 <Philonous> > uncurry (&&) $ ((length &&& length) >>> join (***) (>0)) "abc"
07:30:39 <lambdabot>   True
07:31:00 <skorpan> heh
07:31:01 <Twey> any (> 0) . flip map [indentation, length . tokens] . flip id
07:31:02 <Twey> There you go
07:31:05 <Twey> That's quite nice
07:31:39 <increpare> Twey: but it is somewhat difficult to read
07:31:49 <Twey> increpare: I don't think soâ¦ not particularly
07:32:08 <burp> too flippy for me
07:32:17 <joe1>  let y ((1,2):(1,2):(1,2):(1,2):xs) = 1000
07:32:21 <ahihi> ((||) `on` (>0)) <$> indentation <*> (length . tokens)
07:32:25 <skorpan> the "flip id" boggles me
07:32:27 <joe1>  y  zip [1,1,1,1,1] [2,2,2,2,2]
07:32:30 <Twey> It's the coming up with it that's the problemâ¦ the reading of it is simple right-to-left
07:32:30 <xerox> Philonous: join (&&&) length -- :D
07:32:35 <joe1>  (y . zip) [1,1,1,1,1] [2,2,2,2,2]
07:32:42 <skorpan> joe1: start with ">"
07:32:52 <joe1> > y  zip [1,1,1,1,1] [2,2,2,2,2]
07:32:53 <lambdabot>   Couldn't match expected type `([a] -> [b] -> [(a, b)])
07:32:53 <lambdabot>                     ...
07:32:55 <Twey> skorpan: (\x y -> y x) â flip id
07:33:09 <joe1> > y  (zip [1,1,1,1,1] [2,2,2,2,2])
07:33:10 <lambdabot>   Couldn't match expected type `[(t1, t2)] -> t'
07:33:10 <lambdabot>         against inferred typ...
07:33:13 <Twey> Also flip ($) (($) = id)
07:33:13 <Philonous> xerox: Sure. I just couldn't be bothered to think of another function.
07:33:17 <joe1> > let y ((1,2):(1,2):(1,2):(1,2):xs) = 1000
07:33:18 <skorpan> joe1: what's "y"?
07:33:18 <lambdabot>   not an expression: `let y ((1,2):(1,2):(1,2):(1,2):xs) = 1000'
07:33:20 <joe1> > y  (zip [1,1,1,1,1] [2,2,2,2,2])
07:33:21 <lambdabot>   Couldn't match expected type `[(t1, t2)] -> t'
07:33:21 <lambdabot>         against inferred typ...
07:33:23 <increpare> Twey: yeah I guess so...in reading you can pretty much gloss over all the combinators anyway
07:33:29 <skorpan> joe1: use let ... in
07:33:42 <joe1> skorpan, thanks
07:33:48 <Twey> increpare: Yeah
07:33:53 <joe1> > let y ((1,2):(1,2):(1,2):(1,2):xs) = 1000 in y  (zip [1,1,1,1,1] [2,2,2,2,2])
07:33:54 <lambdabot>   1000
07:34:03 <Twey> For me the biggest barrier to reading is when you have to keep switching reading direction
07:34:05 <joe1> > let y ((1,2):(1,2):(1,2):(1,2):xs) = 1000 in  (y.zip) [1,1,1,1,1] [2,2,2,2,2]
07:34:06 <lambdabot>   Couldn't match expected type `[(t, t1)]'
07:34:06 <lambdabot>         against inferred type `[b]...
07:34:19 <Twey> Or things like liftM2, where the data flow jumps around all over the place
07:34:28 <increpare> Twey: you must hate types in C then : P
07:34:34 <Twey> Oh yes :Ã¾
07:34:48 <increpare> what's the term for the way of reading them?
07:34:56 <increpare> (alternating between reading left and reading right)
07:34:59 <Twey> Same-line boustrophedon?  :Ã¾
07:35:02 <xerox> perl6
07:35:05 <Twey> Hahaha
07:35:40 <Saizan_> i don't really read these things decoding the data flow
07:35:56 <Twey> Real boustrophedon, alternating lines, is lovely, because the next line starts right where your eye is at the end of the previous one
07:36:00 <Twey> Nightmare to write, though
07:36:03 <increpare> Twey: yes, that's it : )
07:36:28 <xerox> Twey: for some time I thought about hacking evince or something to have a boustrophedic option for rendering pdf... but that is quite an hard work.
07:37:20 <increpare> I think once somebody pointed that out to me, I could read most c types without killing myself.
07:37:37 <skorpan> what's bothersome about c types?
07:37:42 <Philonous> >  (all (>0) .  ap [length, length . reverse,]  . return )  "abc"
07:37:43 <increpare> xerox: justification would be a killer : P
07:37:43 <lambdabot>   <no location info>: parse error on input `]'
07:37:52 <Philonous> >  (all (>0) .  ap [length, length . reverse]  . return )  "abc"
07:37:53 <lambdabot>   True
07:38:01 <joe1> i think goa should be merged into ghci, by default.
07:38:27 <increpare> skorpan: they can be difficult to read sometimes?
07:38:35 <increpare> skorpan: take... " void (*signal(int sig, void (*func)(int)) ) (int); " , say
07:38:41 <xerox> joe1: hehe, lambdabot has got too many dependencies for that. But maybe if one takes out the plugins' sources, removes dependencies, and packs it up... it can be made easier.
07:38:59 <skorpan> increpare: apparently i've never seen real c :)
07:39:07 <Twey> Heh
07:39:28 <increpare> skorpan: ah you don't need to worry really: everything gets cast as void* anyway : P
07:39:36 <skorpan> hehe, so i've heard
07:39:36 <Twey> Hahaha
07:39:38 <Twey> The pain
07:44:09 <increpare> I do want to do some proper C programming at some point; it's been ages since I've done anything other than mongrel C/C++
07:44:36 <increpare> I was wandering around the (C) source for Puredata ( http://puredata.info/ ) recently, and was totally struck by how beautiful it was.
07:45:41 <Zao> http://puredata.info/dbimage.jpeg <- aaargh
07:46:11 <skorpan> what's that?
07:46:44 <Zao> Some kind of fancypants audio-visual representation doohickey application thingie.
07:47:14 <pettter> what a simple and intuitive interface
07:47:17 <increpare> Zao: it's an A/V programming environment/scripting language
07:47:40 <increpare> Zao: a lot of people swear by it, but I've never quite managed to get into the swing of using it
07:49:19 <increpare> pettter: well you set up stuff yourself - if the interface's complex it's because someone has made lots of complicated things they want to control... (yeah yeah I know the software has some impact on this as well, but I think it's an unavoidable part of the workflow pretty much)
07:49:54 <increpare> it's pretty easy to interface with (which is good) - spore used and embedded version of it for all of its sound
07:50:34 <pettter> increpare: ah, I see
07:54:16 <joe1> how can I change the number of commands in ~/.ghc/ghci_history file
07:54:37 <joe1> basically, change the last number of commands on the interpreter?
07:58:13 <joe1> the ghci-debugger manual says that ghci remembers the last 50 steps in the history.
07:58:29 <joe1> and it also mentioned that it will made configurable in the future.
07:58:41 <joe1> does anyone know if it has been made configurable
08:02:00 <copumpkin> :o
08:02:56 <hanDerPeder> how does namespacing work in haskell? Trying to use function ord which is in module Char
08:03:22 <monochrom> import Char
08:03:38 <hanDerPeder> thanks
08:03:49 <copumpkin> or Data.Char if you want to be more modern
08:05:07 <monochrom> import Char(ord,isSpace) for just those two names.
08:05:24 <monochrom> There are further variations.
08:06:17 <joe1> how can I define a function with type signature on ghci
08:06:28 <copumpkin> not very elegantl
08:06:29 <copumpkin> y
08:06:32 <joe1> i have done this before, but I lost how I did it.
08:06:40 <monochrom> let { x :: Int; x = 0 }
08:06:41 <copumpkin> let f :: zomg type; f x = ...
08:07:15 <monochrom> I chose Int because it's one of the shortest names.
08:07:21 <copumpkin> ()
08:07:28 <copumpkin> I guess that's the same number of keystrokes
08:07:39 <copumpkin> let { x :: 1, x = ? }
08:07:41 <monochrom> without being too boring
08:08:16 <joe1> thanks.
08:09:41 <joe1> GOA Prelude> :t zip
08:09:41 <joe1> zip :: [a] -> [b] -> [(a, b)]
08:09:41 <joe1> GOA Prelude> :t y
08:09:41 <joe1> y :: [(Int, Int)] -> Int
08:10:07 <joe1> i want to use the function composition as (y . zip) [1,1,1,1] [2,2,2,2]
08:10:17 <copumpkin> (y . ) . zip
08:10:31 <joe1> so, I understand that I would have to convert a and b to Int
08:10:41 <joe1> is there something like a toInt?
08:10:45 <copumpkin> you wouldn't have to do anything explicit
08:10:55 <copumpkin> the types get unified for you
08:10:56 <increpare> (joe1 there's no toint, only fromIntegral : P )
08:11:09 <increpare> copumpkin: that also : )
08:11:25 <copumpkin> :)
08:11:45 <monochrom> This is not "convert".
08:12:09 <Twey> y (zip a b) â (y . zip a) b â (((y .) . zip) a) b â ((y .) . zip) a b â ((y .) (zip a)) b â (y . zip a) b â y (zip a b)
08:12:45 <copumpkin> Twey, the human evaluator
08:12:52 <Twey> Hehe
08:13:04 <Twey> Simplest way I know to explain such things
08:13:32 <copumpkin> Twey types IRC in agda-mode in emacs
08:13:32 <increpare> Twey: I found it enlightening : )
08:13:51 <Twey> Haha :Ã¾
08:14:00 * Twey has never actually tried Agda
08:14:04 <Twey> Some rainy day, maybe
08:14:15 <monochrom> This is why I say: don't think, calculate!
08:15:07 <copumpkin> Twey: it's raining here, you know you want to /j #agda
08:15:47 <Twey> It's raining here too, but I've only got a couple of weeks to learn Lithuanian, so I've other things on my plate :Ã¾
08:15:56 <copumpkin> pff
08:17:04 <joe1> twey: i am trying to understand what you have written, please give me a few more minutes.
08:17:47 <monochrom> Don't worry, IRC is asynchronous.
08:17:53 * increpare is happy that epigram development seems to be chugging along nicely
08:17:55 * copumpkin blocks on joe1
08:19:30 * xerox takesMVar copumpkin 
08:19:54 <elly> in public, xerox?
08:20:20 <Twey> Heh
08:20:47 <joe1> what does it mean "copumpkin blocks on joe1"? sorry for being naive
08:20:58 <copumpkin> joe1: now that you've spoken again, I'm unblocked
08:21:18 <monochrom> because IRC is concurrent
08:21:27 <copumpkin> joe1: just being super nerdy and pretending you're an event and that I'm one of those functions that doesn't return until the event has occurred
08:21:43 * copumpkin looks sad about http://snapplr.com/7c1r :(
08:22:08 * Twey looks confused about it, instead
08:22:49 <increpare> copumpkin: what's the deal with that?
08:23:07 * increpare also damn you whoever mentioned agda - it looks pretty delicious : )
08:23:23 <copumpkin> increpare: my sad attempts to prove a monstrosity of a function I wrote in agda that emulates control-monad-omega
08:23:44 <copumpkin> increpare: that might have been me :(
08:23:48 <copumpkin> sorry, it's addictive
08:24:23 * increpare was ignorant of the omega monad until now - it's pretty nifty
08:24:47 <joe1> twey: the whole deal with (.) is that it can only take one argument?
08:25:06 <Twey> joe1: All Haskell functions take only one argument
08:25:14 <tibbe> > 100 / 2
08:25:15 <lambdabot>   50.0
08:25:18 <increpare> Twey: damn beat me to it
08:25:26 <tibbe> > floor (100 / 2)
08:25:27 <lambdabot>   50
08:25:37 <tibbe> > floot (100 / 2) :: Int
08:25:38 <lambdabot>   Not in scope: `floot'
08:25:46 <tibbe> > floor (100 / 2) :: Int
08:25:47 <Saizan_> copumpkin: look at amgu-c if you want to feel better about your proofs :) http://code.haskell.org/~Saizan/unification/UnifyProof2.agda
08:25:47 <lambdabot>   50
08:26:00 <copumpkin> oh my
08:26:08 <joe1> ok, thanks. makes sense now.
08:26:26 <copumpkin> Saizan_: I feel lame now, my module is simple by comparison :P
08:26:30 <monochrom> "Theorem: Unification is correct. Proof: By unification."
08:26:45 <Twey> Hahahaha
08:26:45 <copumpkin> Saizan_: what does Amgu mean?
08:26:47 <xerox> <<Loop>>
08:27:06 <increpare> Saizan_: what's that doing?
08:27:26 <monochrom> What is open ÃÂ£Ã¢ ?
08:27:44 <increpare> monochrom: convert to utf-8
08:27:46 <xerox> It is not utf-8 :/
08:28:08 <increpare> monochrom: if you're in firefox view->character encoding->utf-8
08:29:30 <Saizan_> copumpkin: mgu stands for most general unifier
08:29:35 <copumpkin> oh :o
08:29:37 <Saizan_> copumpkin: a for auxiliar
08:29:44 <copumpkin> sounds hardcore
08:29:52 <copumpkin> I think there's a rule against putting comments in agda code
08:29:59 <copumpkin> NAD follows it religiously
08:30:05 <Saizan_> hehe
08:30:08 <copumpkin> and I definitely make an effort to as well
08:30:18 <hupgjalbx> hello; is there any standard haskell function that combines lists like this: http://ideone.com/iiyMGfpP
08:30:24 <copumpkin> comments would ruin the beautiful unicode wonder
08:30:33 <Saizan_> well, it's an implementation in agda of Conor's first order unification and correctness proof
08:30:55 <copumpkin> hupgjalbx: replicateM ?
08:31:01 <copumpkin> or rather, flip replicateM
08:31:12 <copumpkin> > flip replicateM "abc" 3
08:31:13 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
08:31:40 <Saizan_> (as you can see i've gone mad at some point and used non-sensical names for where variables)
08:31:47 <copumpkin> :) I do that too
08:33:02 <monochrom> I had "auto detection" off.
08:33:09 <hupgjalbx> huh, but how, doesn't replicateM just repeat an action several times?
08:34:15 <monochrom> The action "abc" picks one char out of a,b,c.
08:34:16 <increpare> am I correct in seeing that interfacing agda to haskell is actually pretty ok?
08:34:16 <Philonous> hupgjalbx: A monadic action, yes. But the monad instance for lists may seem somewhat arcane.
08:34:19 <Gracenotes> in the case of IO, yeah.
08:34:38 <Gracenotes> a lot of functions out there seem to be designed for IO
08:34:46 <Gracenotes> others have.. interesting effects for non-IO monads
08:35:02 <Gracenotes> and at times useful
08:35:24 <copumpkin> hupgjalbx: you get the answer in one minute, now spend an hour figuring out why that is the answer :P
08:35:31 <monochrom> Do this three times: pick one char out of a,b,c. What will you get?
08:35:57 <monochrom> Perhaps the first time you pick a, the second time a again, the third time c. This becomes "aac".
08:36:01 <hupgjalbx> yup it's my really esoteric way of learning
08:36:02 <Saizan_> increpare: it seems so, i think the whole IO implementation is just FFIed in from haskell
08:36:10 <copumpkin> there, I fixed my lemma to actually be true
08:36:15 <copumpkin> one day I may even succeed in proving it
08:36:58 <Gracenotes> replicateM 3 "abc" == do { one <- "abc"; two <- "abc"; three <- "abc"; return [one, two, three] }
08:38:05 <increpare> Saizan_: innteresting; breaking off chunks of code from haskell and agda-ing them up might be a reasonable thing for me to do should I feel so taken...
08:38:19 <Gracenotes> well. technically, with the sequence and all, it's a bit more complicated, but this has the same effect
08:39:16 <monochrom> sequence unfolds to what you wrote.
08:39:22 <Saizan_> increpare: i've done that, but without really interfacing the languages, i just copied the haskell source over in an .agda
08:39:31 <monochrom> I mean expands.
08:40:00 <increpare> Saizan_: you haven't used agate then?
08:40:08 <copumpkin> increpare: that's more or less what I did for my current exercise, but due to the abundance of infinity in this particular function it took quite a bit more work
08:40:18 <Saizan_> increpare: no
08:41:26 <Saizan_> does agata let you call agda code from haskell?
08:41:31 <Saizan_> *agate
08:42:17 <monochrom> For a second I thought you meant s/agda/agate/
08:42:52 <monochrom> Say, suppose you wish to just delete a word or a character, do you just say * ?
08:43:05 <Twey> * is ambiguous
08:43:07 <increpare> Saizan_: it's an extra compilation step - it says it converts agda code to haskell, so one figures that it should (however it looks a little out of date?  2006 being the last release)
08:43:10 <Twey> It just means âreplace something with thisâ
08:43:23 <increpare> Twey: that doesn't sound ambiguous: it sounds polymorphic : D
08:43:36 <Twey> increpare: No, ambiguous :Ã¾
08:43:40 <Saizan_> yeah * is not great
08:43:49 <Twey> So I guess that could workâ¦ but regexen are nicer :Ã¾
08:45:37 * hackagebot upload: stm-io-hooks 0.6.0 - An STM monad with IO hooks (PeterRobinson)
08:47:51 <joe1> i am trying to define a type synonym in ghci. Is it possible?
08:47:58 <joe1> > type dminus = Int ;
08:47:58 <lambdabot>   <no location info>: parse error on input `type'
08:47:59 <Saizan_> no
08:48:40 <Saizan_> most declarations are not allowed in ghci
08:49:17 <mmmyal> the code 'let x = id x in x' produces an infinite loop, why is that?
08:49:34 <joe1> saizan: thanks.
08:49:37 <xerox> because id x is x
08:49:46 <Twey> mmmyal: x = id (id (id (id (id â¦
08:49:51 <monochrom> let x=x in x.  x=x
08:49:58 <xerox> ?src undefined
08:49:59 <lambdabot> undefined =  error "Prelude.undefined"
08:50:22 <xerox> :/
08:50:25 <Saizan_> mmmyal: the x in 'id x' is the same x you're defining with your let
08:50:42 <Twey> So it's a circular definition.
08:51:12 <mmmyal> in that case, how does fix work?
08:51:23 <Twey> (and it doesn't actually produce an infinite loop in itself â only when evaluated)
08:51:33 <xerox> mmmyal: http://www.vex.net/~trebla/haskell/fix.xhtml this is good
08:51:35 <Twey> > fst ((), let x = id x in x)
08:51:37 <lambdabot>   ()
08:51:37 <tibbe> copumpkin: I have numbers :)
08:51:47 <pikhq> mmmyal: Fix is also infinite. Because Haskell is lazy, it only does finite portions of infinite when it can get away with it.
08:51:53 <monochrom> You beat me to my url. This is embarrasing or something! XD
08:52:07 <xerox> hahaha
08:52:09 <tibbe> copumpkin: a priority search queue specialized to unpacked ints is twice as fast as an unspecialized one for insert and min operations
08:52:09 <copumpkin> tibbe: omg!
08:52:15 <copumpkin> nice
08:52:36 <Twey> monochrom: Haha
08:52:38 <Veinor> fix const 7 = const 7 (fix const 7) = 7
08:52:41 <tibbe> copumpkin: done by a brain dead search-and-replace in the PSQ code base
08:52:45 <Twey> tibbe: O.O
08:52:49 <copumpkin> :)
08:52:59 <copumpkin> tibbe: moar profiling and you might even get it faster!
08:53:01 <copumpkin> what's PSQ?
08:53:10 <tibbe> copumpkin: so perhaps other things could be optimized as well (like changing the representation totally
08:53:19 <Gracenotes> priority search queue?
08:53:19 <tibbe> copumpkin: priority search queue
08:53:23 <copumpkin> :o
08:54:03 <Saizan_> dons gave a talk on implementing this kind of thing using associated data
08:54:16 <tibbe> copumpkin: this can be done automatically with associated data types
08:54:21 <copumpkin> yep
08:54:23 <tibbe> Saizan_: was it recorded?
08:54:27 <copumpkin> uvector does just that
08:54:37 <copumpkin> it's fairly simple
08:54:46 <tibbe> copumpkin: using associated data types?
08:54:50 <copumpkin> yep
08:55:23 <copumpkin> class PrioQElementClassThingy x where data PrioQ x :: *; bunchOfFunctions :: ...
08:55:33 <Saizan_> though you get a potentially infinite number of instances, edwardk was thinking about having only a fixed types in the representation and instances that encode your own types into them
08:55:40 <Saizan_> i.e. combinator style
08:55:46 <tibbe> for the record: IntMap has twice as fast insert as the specialized int PSQ but is about 20x slower in finding the min
08:56:25 <tibbe> correction: 30x slower
08:56:39 <tibbe> so don't use an IntMap as a priority queue
08:56:54 <Twey> Woah
08:57:07 <tibbe> I imagine normal Maps are even worse
08:57:18 * tibbe hopes his Criterion benchmarks aren't lying to him
08:57:25 <Twey> There's some PSQ package somewhere, isn't there?
08:57:39 <tibbe> Twey: on hackage
08:57:46 <Twey> Named?
08:57:59 <tibbe> Twey: search for priority on the index page
08:58:04 <Twey> Ah, ta
08:58:12 <tibbe> I think the balancing scheme used for PSQs could be improved
08:58:17 <tibbe> decreasing insert speed
08:58:35 <Twey> I have a codebase that uses a Map as a PSQâ¦ heh.
08:58:47 <tibbe> Twey: I did too
09:04:31 <copumpkin> increpare: too good for #agda?
09:04:36 * copumpkin pouts
09:05:09 <increpare> copumpkin: no, it seemed lovely, but I just want to focus on stuff, and so having lots of chatrooms open doesn't help with that...
09:05:14 <copumpkin> lol
09:05:19 * copumpkin should learn from you
09:08:48 <Gracenotes> I should take a peek
09:08:59 <joe1> > let remove_bitstuffing :: [(Int,Int)] -> [(Int,Int)]; remove_bitstuffing all@((1,1):(1,1):(1,1):(1,1):xs) = tail all
09:09:00 <lambdabot>   not an expression: `let remove_bitstuffing :: [(Int,Int)] -> [(Int,Int)]; r...
09:09:08 <joe1> > let remove_bitstuffing :: [(Int,Int)] -> [(Int,Int)] ; remove_bitstuffing all@((1,1):(1,1):(1,1):(1,1):xs) = tail all
09:09:09 <lambdabot>   not an expression: `let remove_bitstuffing :: [(Int,Int)] -> [(Int,Int)] ; ...
09:09:11 <Gracenotes> oops. "You can't join that many channels"
09:09:17 <joe1> > remove_bitstuffing all@((1,1):(1,1):(1,1):(1,1):xs) = tail all
09:09:18 <lambdabot>   <no location info>: parse error on input `='
09:09:18 <Gracenotes> yeah, there is a limit of 20, isn't there
09:09:22 <copumpkin> Gracenotes: chanho
09:09:32 <joe1>  > (remove_bitstuffing . concat) [(replicate 10 (1,1)), [(2,2)]]
09:09:53 <joe1> is there a smarter way of doing the remove_bitstuffing function?
09:10:14 <copumpkin> it seems very specific
09:10:34 <copumpkin> that means the function will only work if the list starts with 4 (1,1)s
09:10:36 <joe1> it does the job but curious of how your feedback.
09:10:37 <increpare> Silly question.  What do you call something that's not a module? (a source file with only a main defined, say)
09:10:49 <copumpkin> increpare: implicit Main module
09:11:05 <increpare> copumpkin: touche ...
09:11:08 <joe1> yes, if the list starts with 4(1,1)'s replace with list that has 3(1,1)'s
09:11:41 <eu-prleu-peupeu> hellooo
09:12:53 <Gracenotes> copumpkin: I think that makes lambdabot the ultimate chanho
09:13:19 <Gracenotes> and she holds up pretty well for all that use, if you get what I mean
09:13:48 <andrewe> Is there an API reference for Yampa?
09:13:50 <copumpkin> I most certainly do
09:14:08 <joe1> i actually want to extend the remove_bitstuffing to change a list of 24 (1,1)'s to a list of 20 (1,1)'s
09:14:34 <joe1> and the way I have it defined, it would need 4 tails and the 24 (1,1)'s listed.
09:15:01 <joe1> just curious if there is a smarter way.
09:15:47 <andrewe> Or does someone know which modules Yampa consists of?
09:16:19 <increpare> andrewe: you know there's a yampa package on hackage, right?
09:16:24 <increpare> ( http://hackage.haskell.org/package/Yampa )
09:16:44 <andrewe> increpare: thank you
09:16:58 <increpare> andrewe: np - you planning on doing something interesting with it?
09:17:25 <andrewe> increpare: yes, I'm trying to understand it (and arrows). ;-)
09:18:44 <increpare> andrewe: I wish you the greatest of successes, so
09:19:51 * hackagebot upload: bindings-yices 0.1 - Bindings to the Yices theorem prover (PepeIborra)
09:20:06 <andrewe> increpare: did you use it?
09:20:40 <increpare> andrewe: nope (arrows, happily enough, can be understood on their own terms)
09:21:29 <andrewe> increpare: I know, but I haven't found practical uses for them, but am happy if you have more examples.
09:21:48 <increpare> andrewe: heheh, yeah
09:23:09 <copumpkin> why isn't jdh banned from -cafe, anyway?
09:23:12 <tibbe> great, a sorted linked list performs better than any of the balanced tree types, something is wrong
09:23:13 <increpare> andrewe: I had a friend doing stuff in distributed computing where he was using them
09:23:27 <increpare> I think just in their role of being nice for boxing up functions
09:23:30 <Zao> copumpkin: Why ban such a productive member of society?
09:23:44 <tibbe> ah
09:23:47 <tibbe> missing normal form
09:24:02 <tibbe> too much lazyness
09:25:33 <tibbe> @seen bos
09:25:33 <lambdabot> Unknown command, try @list
09:25:59 <Saizan_> preflex: seen bos
09:26:00 <preflex>  bos was last seen on #haskell 1 day, 21 hours, 35 minutes and 52 seconds ago, saying: tibbe|away: i found a hg-git plugin that will let me pretend that git doesn't exist
09:26:34 <andrewe> increpare: I just don't understand them enough, I would like to understand how they are related to monads. I know that every monad can be represented by an arrow, but I haven't groked yet how that works.
09:28:13 <joe1> i want to pattern match the first x number of the same list elements, I can list it out as below but am wondering if there is a smarter way of doing it
09:28:16 <joe1> let remove_bitstuffing all@((1,1):(1,1):(1,1):(1,1):xs) = drop ((length all) - 4) all
09:28:26 <tibbe> @tell bos Did some benchmarking of different priority queues. So far a version of Hinze's priority search queues specialized to a specific priority/key type (i.e. Int) performs the best. Specialized PSQ is 2x faster than non-specialized PSQ, which is much faster than IntMap. Sorted lists are dog slow for inserting new value (no surprise I guess.)
09:28:26 <lambdabot> Consider it noted.
09:28:43 <joe1> as the number of list elements that I match in the beginning could get as high as 24
09:29:38 <joe1> if there are 24 (1:1) 's then drop the first 4 of them.
09:30:11 <increpare> andrewe: monads can't be completely represented by arrows (they're a bit weaker)
09:30:38 <copumpkin> they can't?
09:30:47 <osfameron> I thought arrows were more general?
09:30:55 <andrewe> increpare: isn't it that arrows are a generalization of monads?
09:31:28 <increpare> andrewe: well to my understanding arrows are just functors (albeit to a category where the 'functions' are mappings)
09:31:47 <copumpkin> well, you have Kleisli arrows
09:31:50 <increpare> (aren't mappings)
09:31:51 <Saizan_> you can make an arrow out of every monad
09:31:53 <copumpkin> which completely describe monads
09:32:06 <copumpkin> where composition is kleisli composition <=< style
09:32:08 <skorpan> does anyone have an example of how to use Text.Parsec.Prim.tokens?
09:32:08 <Saizan_> but only using the arrow interface you can't express everything you can with the monad interface
09:32:32 <|Jedai|> joe1: if (all (== (1,1)) (take 24 xs) then drop 4 xs else xs
09:32:34 <mornfall> With arrows, there is no fail! : - )
09:32:42 <|Jedai|> joe1: something like that
09:33:16 <increpare> copumpkin: right, but arrows by themselves are weaker/more flexible/general things than monads
09:33:40 <copumpkin> hm
09:33:54 <increpare> oops
09:34:01 <copumpkin> I wouldn't even compare them directly
09:34:13 <Saizan_> and, more interesting, there are instances of arrows that aren't instances of monads
09:34:18 <mornfall> There's always some confusion with weaker and stronger.
09:34:29 <copumpkin> it's not a total order
09:34:32 <mornfall> Saizan_: Well, it wouldn't make sense to make arrow a different concept otherwise.
09:34:37 <Gracenotes> things which theoretically include other things don't always inherit expressiveness too
09:34:56 <increpare> Gracenotes: cf set  : P
09:35:08 <Gracenotes> nor does turing-completeness ensure expressiveness >_>
09:35:10 <mornfall> Gracenotes: Yeah, we'd be all programming in lambda calculus otherwise.
09:35:21 <mornfall> Or maybe Turing machines, for the more imperatively twisted. :P
09:35:25 <Saizan_> mornfall: well, it could have been the other way around
09:35:37 <Gracenotes> eek. I'd prefer programming LC to programming TMs, I think
09:35:41 <increpare> mornfall: imperative programmers would probably sense some irony in that first statement
09:35:43 <Saizan_> (always going via something like Kleisli)
09:36:04 <increpare> Anyway, I don't think I've seen anyone say that arrows are just functors (in the mathematical sense)
09:36:11 <Gracenotes> it's just like LISP, without the binding!
09:36:12 <increpare> it took me some time to work it out
09:36:19 <increpare> because I thought they were talking about arrow categories
09:36:24 <Saizan_> increpare: how are arrows functors?
09:36:44 <Saizan_> i guess they are a bifunctor
09:36:51 <mornfall> Saizan_: Isn't it like, monad is an arrow is a functor?
09:37:02 <increpare> Saizan_: they're functors to a category where the morphisms can be any old type (rather than functions)
09:37:15 <Gracenotes> technically, you could have global (non-recursive) binding with a huge lambda. But yeah, conversation has taken off and I haven't.
09:37:22 * increpare hopes he hasn't misunderstood them
09:37:50 <copumpkin> http://www.kurims.kyoto-u.ac.jp/~ichiro/talks/msfp06.pdf
09:38:07 <andrewe> increpare: what do you mean by "any old type"?
09:38:27 <Saizan_> increpare: the standard interpretation is that each Arrow instance (~>) defines a new category where the objects are the same as Hask, and the morphisms are those of type A ~> B
09:38:28 <increpare> andrewe: I mean that, with haskell Functors, fmap transforms functions onto functions
09:39:05 <increpare> Saizan_: right, but things to type A ~> B dont' have to be functions, right?
09:39:18 <andrewe> increpare: still don't see old types :-(
09:39:18 <increpare> but merely have to have a well-behaved notion of composition
09:39:32 <Saizan_> increpare: that's what is meant by "new category"
09:39:51 <increpare> Saizan_:Yep.  Anyway, it seems we're in agreement?
09:40:12 <Saizan_> increpare: i don't see what you're identifying as functor there
09:40:35 <increpare> looking at the haskell docs, isn't "arr" itself a functor?
09:40:38 <increpare> from the old category to the new one?
09:40:39 <BMeph> joe1: If you're still working on the "matching stuff at the front" problem, I'd suggest using 'group' instead.
09:40:58 <increpare> ( http://haskell.org/ghc/docs/6.10.4/html/libraries/base/Control-Arrow.html )
09:41:37 <increpare> arr : (A->B) -> (A~>B)
09:42:12 <Saizan_> increpare: a functor is made of two things, something that maps objects and something that maps morphisms
09:42:52 <Saizan_> increpare: i guess arr can be the morphisms part of the functor from Hask to the new category that maps each object to itself.
09:43:11 <increpare> Saizan_: it can be (equivalently) defined just in terms of something that maps morphisms, and with laws that the head/tails of morphisms match up sensibly
09:43:29 <increpare> the arrow class also defines first and second
09:43:33 <Saizan_> but "~>" is not a functor in that sense
09:43:37 <increpare> no?
09:43:56 <increpare> well, not "~>", but arr is?
09:44:35 <joe1> |jedai|: that is smart. will try it out.
09:44:47 <Saizan_> if you only take the morphism part in your definition of functor it is
09:44:49 <joe1> bmeph: I will check out group
09:45:08 <Saizan_> though there are many that want to remove arr from Arrow
09:45:33 <increpare> Saizan_: and that's a mathematically valid thing to do
09:45:49 <Saizan_> (first/second/***/.. just restrict the kind of new category you can define)
09:46:15 <increpare> Saizan_: hmm?
09:47:03 <Saizan_> increpare: to support them means that your category has products, etc..
09:47:48 <Saizan_> (they are more relaxed than the standard categorical product, probably?)
09:48:00 <increpare> Saizan_: oooh
09:49:45 <BMeph> joe1: Specifically, (concat . tail . group) will give you the part after the (first) matching group. If you're doing pairs, and you want to consider it a "match" if just the first parts are the same, then you would use 'groupBy ((==) `on` fst)'. Similar transforms for different criteria. :)
09:50:10 <Saizan_> increpare: though now i see your point that Arrow also defines an "almost Id" functor from Hask to the new category
09:50:31 <increpare> Yeah It seems that they want the sets of morphisms to be internal to the new category defined
09:50:42 <Spockz|lap> is there a way to place a string into the pastebuffer using ghci/haskell?
09:50:48 <increpare> (which, though my mind is rusty on this, pretty much requires it to be a topos)
09:51:01 <BMeph> joe1: In fact, you may want to use 'group xs' (assuming xs is your original list, just to find matches. :)
09:51:18 <increpare> Saizan_: almost Id?
09:51:28 <joe1> bmeph: thanks a lot.
09:51:48 <Saizan_> increpare: well, it maps objects to themselves
09:51:52 <joe1> am trying it out
09:52:03 <BMeph> Saizan_: tensor, maybe? :)
09:52:42 <increpare> increpare: hmm? it doesn't need to ; any normal functor can be rewritten as an arrow
09:52:49 <increpare> oh wait
09:53:22 * BMeph waits to see it increpare is going to argue more with himself... ;)
09:53:25 <increpare> hmm no yeah
09:53:50 <Saizan_> arr :: (A -> B) -> (Id A ~> Id B)
09:55:17 <increpare> Saizan_: nopers - you could have [] as an arrow where arr = fmap :: (a -> b) -> [a] -> [b]   (so arr a b = [a] -> [b])
09:55:25 <Saizan_> if we generalize fmap beyond endofunctors we get fmap :: (a -C> b) -> (f a -D> f b)
09:55:27 <increpare> Saizan_: unless I misunderstand?
09:55:44 <increpare> Saizan_: what do you mean there?
09:56:34 <Saizan_> increpare: the arrow wouldn't be [], it'd be ListArrow a b = [a] -> [b], so arr would still be (a -> b) -> (ListArrow a b), not (a -> b) -> (ListArrow (F a) (F b))
09:57:26 <Saizan_> increpare: in "fmap :: (a -C> b) -> (f a -D> f b)" 'f' is a functor from C to D
09:57:40 <Saizan_> where -X> is the type of the morphisms in the category X
09:57:53 <increpare> Saizan_: reading...
09:59:51 <Saizan_> it's true that you can probably define an FArrow f a b = f a -> f b and make it an instance of Arrow, though i never tried
10:00:17 <Saizan_> (given Functor f)
10:00:50 <Cale> hmm
10:00:53 <increpare> Saizan_: ah, but in the case of [], ListArrow a b = a -> b  - the arrows are just trivially normal functions
10:01:08 <Saizan_> increpare: that's not how it'd work
10:01:16 <increpare> so arr :: (a->b) -> ListArrow [a] [b]
10:01:22 <Saizan_> no
10:01:26 <Cale> oh, yeah, it's just the trivial arrow restricted to f
10:01:29 <Saizan_> ?type arr
10:01:30 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:01:37 <Saizan_> increpare: see?
10:01:53 <BMeph> class (Functor f) => Arrow (FArrow f) where arr = fmap -- ? :)
10:02:15 <Saizan_> increpare: arr :: Arrow (~>) => (a -> b) -> (a ~> b)
10:02:47 <Saizan_> increpare: so what you use as (~>) should be ListArrow a b = [a] -> [b], if you want the final type to be (a -> b) -> [a] -> [b]
10:03:13 <Saizan_> [] is not even of the right kind
10:04:03 <increpare> Saizan_: No I think for functors you have arr have the trivial type (b->c) -> b->c
10:04:22 <increpare> Saizan_: the (haskell) Functor part of it would be in how you define arr
10:04:51 <Saizan_> i don't know what you're talking about now :)
10:05:08 <Saizan_> it seems you're just saying that (->) is an instance of Arrow
10:05:10 <Saizan_> which is true
10:05:32 <Saizan_> but then arr is id, and doesn't have much to do with functors
10:05:34 <copumpkin> it sure looks like an arrow to me! ;)
10:05:39 <increpare> Saizan_: well there are many ways to make (->) an instance of arrow
10:05:47 <Saizan_> increpare: are there?
10:05:49 <copumpkin> really?
10:05:50 <increpare> Saizan_: but you don't have to make arr id then
10:05:55 <copumpkin> how would you compose them?
10:06:03 <increpare> for instance arr = map ?
10:06:09 <Saizan_> increpare: id is the only implementation possible.
10:06:14 <copumpkin> then it would need to work on lists
10:06:20 <copumpkin> it's polymorphic on the domain and codomain
10:06:28 <Saizan_> ?djinn (a -> b) -> (a -> b)
10:06:28 <lambdabot> f a = a
10:06:54 <copumpkin> increpare: it seems like what you're talking about are newtypes around (->)
10:07:04 <increpare> copumpkin: yeah pretty much exactly
10:07:08 <Saizan_> increpare: if you try "instance Arrow (->) where arr = map" you get a type error
10:07:11 <copumpkin> newtype ListZOMG a b = ListZOMG ([a] -> [b])
10:07:20 <copumpkin> instance Arrow ListZOMG
10:07:38 <copumpkin> often called a stream processor
10:07:44 <copumpkin> but I prefer ListZOMG
10:07:45 <increpare> Saizan_: I think I'm just going to have to try writing an instance myself to figure out what I'm doing wrong.  brb...
10:07:49 <Saizan_> that's what he was saying wasn't the arrow he was talking about though :)
10:08:01 <copumpkin> oh
10:08:11 * copumpkin gives up then and goes back to his hopeless agda proof
10:08:41 * elly has been given The {Little,Reasoned,Seasoned} Schemer for christmas :)
10:08:54 <copumpkin> nice!
10:08:55 <Saizan_> increpare: yeah, the typechecker helps a lot :)
10:16:16 <increpare> Saizan_:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15002#a15002
10:17:01 <copumpkin> \x -> x
10:17:01 <copumpkin> = id
10:17:34 <copumpkin> that's exactly the instance for (->)
10:17:46 <copumpkin> but wrapped in a datatype
10:17:49 <increpare> oops...i forgot something
10:17:54 <Saizan_> Cale: for Functor f => FArrow a b = f a -> f b, can we write (***)? it seems like we'd need some "fzip"
10:18:22 <copumpkin> you'd need Applicative I think?
10:18:29 <increpare>         arr f = ListArrow (map f)
10:18:29 <increpare> and...type errors
10:18:39 <copumpkin> isn't that pretty much the categorical definition of an applicative?
10:19:38 <copumpkin> increpare: it's fairly easy to prove that there's only one possible instance
10:19:47 <copumpkin> if the type is isomorphic to (->)
10:19:52 <Saizan_> copumpkin: i've generally seen applicatives transformed into arrows via AArrow f a b = f (a -> b)
10:20:02 <copumpkin> oh
10:20:04 <skorpan> i have a little problem... i'm using Parsec on a stream of type [MyThing] and i want to apply a parser `myParser' on each MyThing in the stream. how do i do that?
10:20:34 <Saizan_> though liftA2 (,) would have the right type here
10:20:48 <copumpkin> yeah, and that's sort of the fundamental property
10:21:04 * copumpkin wants to say the word but feels pretentious
10:21:55 <eu-prleu-peupeu> i like the "year in review" on haskell.org
10:22:02 <Saizan_> skorpan: so MyThing is your token type?
10:22:03 <dolio> @type \f -> fmap (\(a,b) -> (f a, b))
10:22:04 <lambdabot> forall t t1 t2 (f :: * -> *). (Functor f) => (t -> t2) -> f (t, t1) -> f (t2, t1)
10:22:06 <skorpan> Saizan_: yeah
10:22:07 <eu-prleu-peupeu> i think there should also be a "decade in review" :D
10:22:20 <copumpkin> oh, you just want that?
10:23:18 <Saizan_> skorpan: i'd think of "do xs <- many myParser; eof; return xs"
10:23:54 <skorpan> Saizan_: me too, but looking at the type of `many', that's not the right one
10:24:09 <skorpan> many :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
10:24:55 <skorpan> maybe i'm misthinking here, but my idea was to have myParser :: Parsec MyThing u a
10:25:10 <skorpan> not Parsec [MyThing] u a, that doesn't make sense to me
10:25:44 <copumpkin> you want many things
10:25:55 <copumpkin> oh I see
10:26:04 <copumpkin> just map it?
10:26:23 <skorpan> yep, but "mapM myParser ..." fill in the gap!
10:26:30 <Saizan_> skorpan: s is the type of the stream
10:26:53 <Saizan_> which i thought was [MyThing], not [[MyThing]]
10:27:16 <skorpan> Saizan_: mainParser :: Parsec [MyThing] u a ... myParser :: Parsec MyThing u a
10:27:23 <skorpan> that's the design i'm going for, dunno if that's the best
10:27:46 <Saizan_> ah, so MyThing is not your token type here, it's your stream type
10:28:04 <Saizan_> in myParser
10:28:10 <skorpan> hm, i guess
10:28:40 <BMeph> From the "Oblivious" paper: [Applicatives] "are equivalent to arrows that satisfy the type isomorphism A ~>B <=> () ~> (A -> B)"
10:28:43 <Saizan_> the stream is the collection from which parsec gets tokens with uncons
10:29:17 <skorpan> Saizan_: MyThing is in reality pretty much just a lexed line, so i have [MyThing] in my main parser, which parses each line separately
10:29:35 <skorpan> i could make a new token called Newline and just use `sepBy'
10:30:45 <Saizan_> i don't know if there's a combinator to go from one stream type to another in the same parsec action, you might need to use runParser
10:32:09 <mreh> haskore makes my brain hurt, does anyone know the purpose of the multiple interfaces defined in Medium? There's C, there's Construct, and then there are three types implementations of Medium.C, the only one that seems to be used by Haskore is Medium.Controlled.T
10:32:30 <skorpan> Saizan_: ah, of course... that makes sense.
10:32:37 <mreh> old Haskore was better :( :( :(
10:32:41 <mreh> hmpf
10:32:55 <sRp> is there a way to get ghc to pretty print escape characters has hex values (like python does,) rather then stuff like "\RS\SOH"
10:33:06 <copumpkin> mreh: oh god, is that written by Henning?
10:33:14 <mreh> copumpkin: yes
10:33:25 <mreh> who knows what goes on inside his head!
10:33:44 <Saizan_> or worse, in his haddocks
10:33:57 <mreh> copumpkin: the use of C and T makes the haddocks hard to read :)
10:34:09 <copumpkin> I know!
10:34:23 <mreh> four-fold if you aren't familiar with it
10:34:29 <dolio> It will all be fine when Haskell suddenly turns into ML one of these days.
10:34:41 <mreh> heresy
10:34:51 <Saizan_> dolio: yay!
10:36:52 <Saizan_> mh, you can't even write first :: Functor f => (f a -> f b) -> (f (a,c) -> f (b,c)), can you?
10:37:07 <dolio> If you could write first, you could write (***).
10:37:35 <mreh> Saizan_ who are you talking to?
10:38:10 <Saizan_> mreh: whoever answers :)
10:38:22 <mreh> i thought you said my name
10:38:30 <mreh> I am such a big head!
10:39:06 <Twey> :t fmap (first undefined)
10:39:07 <lambdabot> forall b c d (f :: * -> *). (Functor f) => f (b, d) -> f (c, d)
10:39:21 <sRp> another way to put what i want: i'd prefer to see the integer based escapes rather then the ascii control based ones. Is there no way to control this for ghci?
10:39:22 <Twey> Oh, wait
10:39:38 <Twey> Hmm, no, don't think so
10:39:46 <Twey> You'd need to be able to extract the value
10:40:06 <Saizan_> you'd have to use your own printing function, i think
10:40:23 <mreh> I have a serious case of an excess of Henning
10:40:34 <c_wraith> @src Show Char
10:40:34 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:40:34 <mreh> god bless him
10:41:08 <sRp> Saizan_: thanks, i guess i'll try doing that
10:41:13 <increpare> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15003#a15003 < - any better
10:41:16 <Cale> Henning Thielemann writes so much useful code, but sabotages it with terrible terrible conventions.
10:41:33 <Twey> And/or join
10:41:47 <tibbe> Why would installing Criterion have cabal try to install template-haskell?
10:41:51 <Twey> Cale: Is he the one who likes to write types called Module.T?
10:41:57 <Cale> Twey: yeah
10:42:01 <mreh> We need a Henning disaster control team
10:42:04 <Twey> Haha
10:42:10 <Cale> Every type is called T, every typeclass is called C
10:42:15 <Twey> Ych :Ã¾
10:42:22 <increpare> Cale: does he defend his style?
10:42:41 <mreh> The worst part is sometimes he even includes two classes in a module, so I think, what's the point in that?!
10:42:56 <maltem> increpare, yeah he did once when I asked him in a mail
10:42:57 <Cale> increpare: Well, regardless of whether he defends it, he produces a lot of useful code in this style, and he's basically the only person who does that.
10:43:24 <Twey> mreh: What does he call them then?  C1 and C2?  :Ã¾
10:43:25 <mreh> so he's a convention of one man
10:43:29 <mreh> that's not what I call a convention
10:43:35 <Twey> Heh
10:43:46 <Twey> Oh, probably C and C'
10:43:50 <maltem> increpare, said that this was the clearest arrangement he could think of, approximately
10:43:53 <c_wraith> tibbe: It probably depends on syb, and the newest version of syb depends on a new version of TH.  cabal is a bit broken right now
10:43:55 <mreh> Twey: nah, C and Construct
10:43:55 <Cale> I've seriously considered systematically going through his packages, fixing the names, and reuploading *-sane versions of them to hackage.
10:44:01 <Saizan_> increpare: yes, that paste is what i was describing earlier, arr in this case is the morphism part of a functor from (->) to the ListArrow category, which maps every object to itself
10:44:06 <Twey> mreh: Yerwhat?  o.@
10:44:12 <mreh> Twey: yes :)
10:44:16 <tibbe> c_wraith: solved it by putting a constraint on template-haskell
10:44:39 <mreh> could I have a C please Carol, no not a C! A C!!!
10:45:16 <Cale> I wonder how much work it would be to write a source -> source cothielemann translator
10:45:31 <Saizan_> tibbe, c_wraith: the problematic dep. is the new data-accessor in this case, just for the record
10:46:00 <tibbe> Saizan_: yes, it doesn't seem to require a new TH though
10:46:07 <Cale> Which simply renames the types with the name of the module that they're in, and same with the classes, I guess.
10:46:14 <mreh> Cale: you would have to do it by hand, but if Haddock qualified the names it would be fine
10:46:19 <Cale> (The last component of the module)
10:46:29 <Saizan_> tibbe: no, but cabal-install's solver is to greedy to see it
10:46:30 <Cale> mreh: huh?
10:46:38 <mreh> The only way that anyone can program with Hennings code is to qualify everything, else all the Ts and Cs clash
10:46:38 <tibbe> Saizan_: I see
10:47:01 <Cale> mreh: I mean, use something like haskell-src to parse the code that Henning has written and fix it.
10:47:05 <mreh> if Haddock had a -thielmann switch
10:47:19 <Cale> (without having to do it by hand
10:47:20 <Cale> )
10:47:27 <mreh> Cale: you'd have to choose names for the Ts and Cs
10:47:37 <mreh> oh, I get you
10:47:40 <Cale> Right, you'd just always choose the last component of the module path
10:48:21 <Saizan_> if you have both a T and a C you'd have to pick two different names though, no?
10:48:30 <Cale> Oh, perhaps that's the case.
10:48:46 <mreh> Saizan_ yeah, but he doesn't do that
10:48:54 <mreh> so far, from what I have see
10:48:54 <mreh> n
10:48:59 <Cale> I think I'd add "Class" to the end of the class-name then.
10:49:24 <dolio> I wonder why he doesn't put every function in a separate module and call them all "f".
10:49:31 <Cale> dolio: Heh.
10:50:23 <mreh> I think the argument that "it's ****** hard to read" is good enough
10:50:30 <Twey> I don't think you actually do need to have separate names for classesâ¦
10:51:20 <mreh> Twey: how so?
10:51:34 <mreh> :t join
10:51:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:51:49 <mreh> @pl \x -> x x
10:51:49 <lambdabot> join id
10:51:55 <mreh> @pl \x -> (x, x)
10:51:55 <lambdabot> join (,)
10:52:39 <mreh> :t join (,)
10:52:40 <lambdabot> forall a. a -> (a, a)
10:52:46 <Saizan_> Twey: tried, i get a "multiple declarations" error
10:52:47 <mreh> stupid question
10:52:49 <Twey> Huh.
10:52:51 <Twey> Seems odd
10:53:00 <Twey> They shouldn't clash â they're in different namespaces
10:53:04 <mreh> :t (,)
10:53:05 <lambdabot> forall a b. a -> b -> (a, b)
10:53:14 <mreh> what monad is (,)?
10:53:26 <Twey> mreh: (,) isn't a monad
10:53:30 <Twey> (a,) is
10:53:42 <Twey> Er, wait
10:53:44 <Twey> Is it?
10:53:46 <Twey> It's a Functor
10:53:53 <Twey> Not a Monad, actually
10:53:55 <Asztal> it's a comonad
10:54:07 <increpare> Saizan_: map defines a functor that doesn't map objects to themselves, so why do you say that app does?
10:54:20 <mreh> does RWH haskell do functors and comonads?
10:54:33 <mreh> I got distracted after it explined monads
10:54:51 <c_wraith> @instances Monad
10:54:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:55:07 <c_wraith> @instances Functor
10:55:07 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:55:26 <increpare> mreh: it's a pity he didn't put the index up as well : P
10:55:31 <mreh> is that all the monads in the prelude?
10:55:44 <mreh> and selected modules
10:55:47 <aavogt> no, you have to import stuff for some of those
10:55:52 <c_wraith> > ("foo", "mechanical") `fmap` ("bar", reverse)
10:55:53 <lambdabot>   Couldn't match expected type `a -> b'
10:55:53 <lambdabot>         against inferred type `([GHC....
10:56:12 <aavogt> mreh: you expect some kind of exhaustive list?
10:56:13 <mreh> increpare: sorry, who?
10:56:19 <c_wraith> > reverse `fmap` ("bar", "reverse")
10:56:20 <lambdabot>   ("bar","esrever")
10:56:31 <mreh> aavogt: it's quite a long list I am told
10:56:38 <c_wraith> @instances Applicative
10:56:38 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
10:56:39 <increpare> mreh: bria/don/john, I guess
10:56:51 <c_wraith> @instances Control.Applicative.Applicative
10:56:52 <lambdabot> ((,) a), ((->) a), IO, Maybe, []
10:56:56 <haskell_hater> does anyone know how to write reverse with foldr?
10:57:02 <c_wraith> Ah, that's the one I was thinking of.
10:57:10 <mreh> haskell_hate, yes but I'm not telling you
10:57:18 <haskell_hater> why not?
10:57:21 <mreh> actually, i think you're thinking of foldl
10:57:35 <haskell_hater> no, foldr
10:57:37 <mreh> i can do reverse with a foldl
10:57:43 <haskell_hater> i know how to write it with foldl
10:57:55 <haskell_hater> but how about foldr
10:57:55 <mreh> very good :)
10:58:10 <c_wraith> > ("foo", reverse)  <*> ("bar", "eleven")
10:58:11 <lambdabot>   ("foobar","nevele")
10:58:16 <haskell_hater> is it possible
10:58:24 <mreh> foldr (flip . (++)) [] [1,2,3]
10:58:27 <mreh> > foldr (flip . (++)) [] [1,2,3]
10:58:28 <lambdabot>   Occurs check: cannot construct the infinite type:
10:58:28 <lambdabot>    f = (->) (f b -> b)
10:58:31 <xerox> :t (<*>)
10:58:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:59:05 <haskell_hater> isn't ++ slow?
10:59:18 <mreh> > foldr (\x y -> flip . (y ++ [x])) [] [1,2,3]
10:59:18 <BMeph> monochrom: Ha-ha: "Please don't use the Ackermann function! "
10:59:18 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> b))
10:59:18 <lambdabot>    arising from the literal `1'...
10:59:28 <monochrom> hehehe
10:59:36 <copumpkin> haskell_hater: you can write foldl with foldr, and you can write reverse with foldl
10:59:55 <mreh> > foldr (\x y -> (y ++ [x])) [] [1,2,3]
10:59:57 <lambdabot>   [3,2,1]
10:59:57 <haskell_hater> you can do it like this: foldr (\x result -> result ++ [x]) [] [1..10]
10:59:59 <mreh> yey
11:00:13 <haskell_hater> but is ++ not to slow?
11:00:28 <copumpkin> you impose artificial constraints on how to do something
11:00:34 <copumpkin> you get the penalties associated
11:00:46 <mreh> haskell_hater, it is slow by virtue of the fold
11:00:47 <monochrom> Try using foldr plus cps.
11:00:51 <Saizan_> increpare: because i was talking in the general settings of Arrows, so we've to talk what arr means for ListArrow
11:01:00 <mreh> monochrom:?
11:01:06 <raceRider> >toLower "ASDBAS"
11:01:14 <Saizan_> increpare: an instance of Arrow doesn't need to be of the form \a b -> f a -> f b
11:01:26 <increpare> Saizan_: I think I understand now, yeah.
11:02:05 <Cale> mreh: I'd rather say that it's slow because xs ++ ys necessaily takes O(length xs) time
11:02:18 <raceRider> @run [1..10]
11:02:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:02:23 <Cale> Writing reverse in terms of (++) is not a great idea
11:02:38 <Cale> > foldl (flip (:)) [1..10]
11:02:39 <lambdabot>   []->
11:02:39 <lambdabot>    [1,2,3,4,5,6,7,8,9,10]
11:02:39 <lambdabot>  [-2]->
11:02:39 <lambdabot>    [-2,1,2,3,4,5,6,7,8,9,10]
11:02:39 <lambdabot>  [-2,-1...
11:02:41 <Cale> > foldl (flip (:)) [] [1..10]
11:02:42 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
11:03:11 <increpare> Saizan_: if we were to give the category ListArrow objects, they may as well be of type a as [a] - I don't think it matters really
11:03:48 <increpare> Saizan_: (in that they're only used to keep track of domains and ranges)
11:04:15 <increpare> unless [] intervenes somewhere...
11:04:47 <increpare> scratch that thought actually
11:04:48 <Saizan_> using [a] is just working in Hask
11:04:52 <Saizan_> not ListArrow
11:04:56 <copumpkin> you seem to be describing a functor
11:04:58 <mreh> Cale: I was thinking that the foldr forces you to do the computations on a list that you're folding the wrong way, so you have to unfold it with the ++
11:05:31 <mreh> haskell takes a while to get lodged in your brane, I often speak intuitively about it before I understand it
11:05:53 <mreh> haskell_love picked up folds quickly, i'm impressed
11:06:05 <Saizan_> increpare: we could just say that all the objects need to be of the form [a], but that seems like breaking the abstraction for no reason to me
11:06:12 <pikhq> Also, how does one lodge things in a brane?
11:06:19 <pikhq> A brain I can understand, but a brane?
11:06:28 <pikhq> Maybe a one Dr. Hawking could inform us.
11:06:36 <Saizan_> increpare: and don't respect how you represent it in haskell via the ListArrow newtype
11:06:54 <monochrom> a brain is a brane
11:07:08 <Saizan_> s/don't/doesn't/
11:07:14 <skorpan> insane in the membrane
11:07:24 <Cale> > foldr (\x g xs -> g (x:xs)) id [1,2,3,4,5] []
11:07:25 <lambdabot>   [5,4,3,2,1]
11:07:30 <mreh> insane in the brain!
11:07:39 <Cale> You can do it efficiently with foldr too
11:07:52 <pikhq> What sort of brane, an5yways? 1-brane? 2-brane?
11:07:54 <copumpkin> that's what I said to do, albeit a bit indirectly
11:08:01 <pikhq> Infini-brane?
11:08:03 <increpare> Saizan_ : hmm...well I defined a category instance of ListArrow first...id was defined to be ListArrow id, which is only defined on things of type [a]
11:08:22 <mreh> oooh, I don;t understand that, what is it?
11:08:33 <pikhq> s/an5/an/
11:08:38 <monochrom> Use foldr to produce a function first.
11:08:46 <increpare> Saizan_: but yeah, I get your point : so long as we don't insist as looking at the arrows as being functions, using a instaed of [a] is more natural
11:08:54 <monochrom> It is like the shows approach.
11:09:22 <increpare> Saizan_: but as soon as you do, you end up constructing an isomorphic category with has objects [a]
11:09:31 <Saizan_> increpare: e.g. in the ListArrow category a morphism A -> B is represented as a morphism [A] -> [B] in Hask
11:09:40 <mreh> are there any haskell events coming to London soon?
11:09:42 <increpare> Saizan_: Yep.
11:09:49 <increpare> Saizan_: I think we have an understanding now?
11:09:49 <copumpkin> that's what I wrote way back earlier
11:09:51 <copumpkin> ListZOMG
11:09:54 * copumpkin pouts
11:09:56 <increpare> copumpkin: : P
11:10:18 <increpare> damn...I have to increase my log size, I can't scroll that far back : (
11:10:23 <copumpkin> lol
11:10:23 <Saizan_> increpare: yeah, except that you seem to think this is something fundamental about Arrow, rather than an accident
11:10:34 <Veinor> @pl \x g xs -> g (x:xs)
11:10:34 <lambdabot> flip (.) . (:)
11:10:45 <copumpkin> omg Veinor is the @pl master
11:10:47 <Veinor> :O
11:10:53 <mreh> :t foldr
11:10:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:11:23 <Veinor> :t flip (.) . (:)
11:11:24 <lambdabot> forall b a. a -> ([a] -> b) -> [a] -> b
11:11:36 <Saizan_> though i don't know if i'm right on that :)
11:12:26 <increpare> Saizan_:  If I say that the only things blocking the interpretation in general are first and second (which require the functor to obey additional laws), is that closer?
11:12:37 * increpare isn't sure what Saizan_ means by 'accident'...
11:12:38 <skorpan> @unpl flip (.) . (:)
11:12:38 <lambdabot> (\ i c f -> c (((:)) i f))
11:12:43 <Cale> So, what we're doing in the foldr for reverse is replacing list structure with function structure, and building the function which tips the elements of the list in reverse order onto another list.
11:13:00 <Saizan_> ah, well, you can make an arrow out of every comonad and monad with a distributive law, where it'd look like w a -> m a, so that interpretation doesn't hold at all
11:14:00 <Saizan_> increpare: if i make an instance where you get to "arr :: (a -> b) -> (w a -> m a)", is that still the morphism part of some functor to you?
11:14:01 <Cale> So, in \x g xs -> g (x:xs), the g is the function constructed from the rest of the list, xs is the parameter to the function we're constructing, and x is our list element
11:14:17 <Saizan_> increpare: for some fixed and different w and m
11:14:55 <increpare> Saizan_: oh I don't believe for a moment that all arrows are functors
11:15:02 <Cale> and what we're doing is adding x, which we can think of as the "first" element of the list to the list xs, and then applying g to put the rest of the list elements onto the front of it
11:15:08 <increpare> Saizan_: in the sense of being realizable in Haskell
11:15:16 <increpare> (Hask/whatever)
11:15:53 <Saizan_> increpare: the instance i'm talking about can be written in haskell
11:17:08 <increpare> inclement: I mean that there's no way of writing it as a haskell Functor
11:17:10 <rajeshsr> just curious, is lambdabot written in haskell? source code is open srced?
11:17:25 <copumpkin> yup
11:17:55 <rajeshsr> copumpkin, src code available publicly?
11:18:00 <copumpkin> yup
11:18:16 <rajeshsr> copumpkin, do you know the link?
11:18:30 <copumpkin> @google lambdabot
11:18:31 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
11:18:31 <lambdabot> Title: Lambdabot - HaskellWiki
11:18:38 <increpare> Saizan_: oops that was pointed at you.  Anyway, yep.  I don't think that all arrows give rise to haskell Functors (endofunctors in Hask, I guess).
11:18:46 <increpare> Saizan_: was that your point?
11:19:26 <Saizan_> increpare: yes, that's more or less how i understood your initial statement about arrows just being functors
11:19:29 <copumpkin> rajeshsr: http://hackage.haskell.org/package/lambdabot
11:19:50 <increpare> Saizan_: ah okay, right : )
11:20:50 <kmc> haskell_hater == HaskellLove?
11:21:00 <copumpkin> doubt it
11:21:04 <copumpkin> he was .nl
11:21:12 <increpare> Saizan_: there're haskell Functors, and then there're CT Functors - differentiating in irc can be tough : P
11:21:29 <increpare> Saizan_: thanks for the chat - I did appreciate it, and feel on much more intimate terms with Arrows now : )
11:21:40 <kmc> well, saying you hate something *is* a good way to get advice on irc
11:22:50 <monochrom> Hi, I hate polymorphism. Any hints?
11:23:10 <copumpkin> no
11:23:11 <increpare> kmc: the "advice" may not exactly be constructive in general though : P  (on here it tends to be, though)
11:23:53 <increpare> monochrom: oo polymorphism, or parametric?
11:23:57 <copumpkin> the only cure for monochrom is an overdose of polymorphism
11:24:04 * copumpkin writes him a rank-10 polymorphic function
11:24:23 <monochrom> I am rank-16, going on rank-17
11:25:30 <increpare> monochrom: "I'm sorry, my dear: I'm not of legal rank yet"
11:25:53 <monochrom> It is funny that a person seeking help on X names himself/herself one of: Xlove, Xhate, XGod, Xnewbie, Xhelp.
11:25:56 <copumpkin> f :: (forall a. (forall b. (forall c. (forall d. (forall e. (forall f. (forall g. (forall h. (forall i. (forall j. (forall k. (forall l. (forall m. (forall n. (forall o. (forall p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p)))))))))))))))) -> p
11:26:00 <copumpkin> oh wait
11:26:10 <copumpkin> f :: (forall a. (forall b. (forall c. (forall d. (forall e. (forall f. (forall g. (forall h. (forall i. (forall j. (forall k. (forall l. (forall m. (forall n. (forall o. (forall p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q)))))))))))))))) -> q
11:26:18 <copumpkin> otherwise it would make no sense!
11:26:20 <monochrom> The part about XGod I understand the least.
11:26:44 <monochrom> <MathGod> Hi I need help in math. how do you solve x-2=0?
11:26:44 <kmc> barely legal types
11:27:01 <copumpkin> :t f :: (forall a. (forall b. (forall c. (forall d. (forall e. (forall f. (forall g. (forall h. (forall i. (forall j. (forall k. (forall l. (forall m. (forall n. (forall o. (forall p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q)))))))))))))))) -> q
11:27:02 <lambdabot>     Could not deduce (Show
11:27:02 <lambdabot>                         (forall a b c d e f g h i j k l m n o p.
11:27:02 <lambdabot>                          a
11:27:04 <monochrom> Why would you call yourself MathGod if you can't do it?
11:27:09 <copumpkin> oh my
11:27:10 <Twey> :t undefined :: (forall a. (forall b. (forall c. (forall d. (forall e. (forall f. (forall g. (forall h. (forall i. (forall j. (forall k. (forall l. (forall m. (forall n. (forall o. (forall p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q)))))))))))))))) -> q
11:27:11 <lambdabot> forall q. (forall a b c d e f g h i j k l m n o p. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q) -> q
11:27:11 <kmc> irony?
11:27:20 <kmc> find hot types for unification in your area
11:27:25 <emile_m> Autogenerated Haskell code? :)
11:27:25 <Twey> Haha
11:27:35 <Peaker> monochrom: who says a math god knows how to do maths?
11:27:36 <increpare> the line "you're not my type" suddenly acquires decidedly sinister overtones
11:27:48 <copumpkin> I guess that's only rank 2
11:27:54 <copumpkin>  but I'm too lazy to do it right
11:28:12 <rajeshsr> copumpkin, sorry. Got disconnected..
11:28:14 <increpare> copumpkin: heheh
11:28:15 <monochrom> But the biggest problem is the lack of self-identity. So today you call yourself XBoy because you need help on X? And tomorrow you become YBoy because it is Y instead? Keep changing names?
11:28:27 <kmc> most people don't do this
11:29:18 <monochrom> Ahem!
11:29:18 <emile_m> It's an ad-hoc polymorphism, isn't it?
11:29:24 <monochromboy> yeah?
11:29:36 <xerox> Need help with ... light? old cinema stuff?  :P
11:29:46 * BMeph sees that someone needs help with monochrom... ;p
11:30:38 * Zao renames to HarropBoy.
11:30:48 <Twey> Hehe
11:31:19 <Twey> monochrom: Yeah, it's a bit creepy
11:31:50 <copumpkin> shush you or Tweyboy will be my next nick
11:32:12 <monochrom> polymorphicBoy
11:32:17 <Twey> Haha
11:32:19 * BMeph had Star Trek flashbacks for a bit: "State the nature of the monochrom emergency." ;p
11:50:55 <mreh> what makes a functor different from a function?#
11:51:08 <mreh> i understand it is a subset of the latter
11:51:53 <koeien371> in Haskell, a Functor is a typeclass.
11:51:57 <mreh> wikipedia confuses me with talk of morphisms
11:52:10 <koeien371> in Category Theory, a functor is a morphism of categories
11:52:24 <mreh> in haskell, how does this relate to monads?
11:52:31 <koeien371> all monads are functors
11:52:47 <emile_m> Monad = Functor + join || >>=
11:53:16 <mreh> is that some kind of funky syntax?
11:53:17 <emile_m> afaik
11:53:23 <koeien371> @src Functor
11:53:23 <lambdabot> class  Functor f  where
11:53:23 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:53:29 <koeien371> you need return.
11:53:40 <emile_m> Oh, yes,
11:53:42 <koeien371> mreh: that is an improved syntax
11:53:55 <c_wraith> :t fmap
11:53:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:53:58 <koeien371> but return and >>= is enough to define fmap
11:54:01 <koeien371> @src liftM
11:54:01 <c_wraith> :t liftM
11:54:01 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:54:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:54:06 <copumpkin> that would just be a semigroup in the category of endofunctors!
11:54:19 <koeien371> instead of a monoid
11:54:29 <emile_m> Functors have "fmap", Applicative functors additionally have "pure", and Monads have "join" or "bind"
11:55:33 <copumpkin> emile_m: applicative functors have more than pure
11:55:34 <mreh> so fmap for the list monad is just map
11:55:38 <copumpkin> pure should come from pointed
11:55:40 <koeien371> correct
11:55:54 <copumpkin> applicative has liftN or <*>/ap
11:55:57 <mreh> fmap is a contraction of functorMap?
11:56:08 <koeien371> i guess so
11:56:09 <c_wraith> mreh: interestingly enough, Functor is such a trivial typeclass that it can be derived automatically in GHC 6.12
11:56:30 <koeien371> there are lots of functors in Haskell
11:56:36 <c_wraith> (For types with one type variable)
11:56:40 * copumpkin -> sleep
11:56:46 <emile_m> copumpkin: Yes, Thanks.
11:57:30 <mreh> i dont really buy that you can *really* program haskell without category theory
11:57:58 <c_wraith> You can, pretty easily.
11:58:08 <koeien371> i don't know much CT
11:58:09 <mreh> program haskell, well
11:58:13 <koeien371> I won't say i can program Haskell, but I don't see that it's really required
11:58:16 * gwern doesn't know category theory, and I claim to program haskell
11:58:37 <c_wraith> mreh:  I recommend trying it.  Forget about category theory, and just write a program.
11:58:52 <mreh> i'm trying to learn Arrow
11:59:01 <koeien371> the Functor, Pointed, Applicative, Monad hierarchy is the most important, and then arrows
11:59:15 <c_wraith> why?  All I know about Arrow is that I don't need to know about it.
11:59:17 <emile_m> @hoogle Pointed
11:59:17 <lambdabot> No results found
11:59:25 <mreh> Pointed?
11:59:27 <emile_m> @info Pointed
11:59:27 <lambdabot> Pointed
11:59:33 <koeien371> @where typeclassopedia
11:59:33 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:59:34 <monochrom> There are two "category theory"s. One is: you have to know the standard names. The other is: you don't have to know the standard names.
12:00:05 <monochrom> Clearly, by the time you fully exploit Haskell, you end up knowing the second kind. But not necessarily the first kind.
12:00:24 <c_wraith> I know just enough about arrow to know that -> is an instance, so I can use &&& and *** with functions.
12:00:45 <mreh> c_wraith interesting
12:00:51 <c_wraith> :t (id &&& show)
12:00:52 <lambdabot> forall b. (Show b) => b -> (b, String)
12:01:00 <Cale> While Control.Arrow has a category-theoretic explanation, it doesn't mean the same thing as arrows in category theory.
12:01:35 <Cale> Nor, for that matter does Control.Category really accurately depict what a category is.
12:01:41 <emile_m> koeien371: Thanks, I've just stumbled upon this paper in Monad.Reader issue.
12:02:11 <koeien371> it is really cool :)
12:02:18 <Cale> The definitions of category theoretic concepts in Haskell are specialised to Haskell, some more highly than others.
12:02:34 <koeien371> Cale: seems to be hard to do in Haskell in full generality (at least, seems to me :) )
12:02:42 <Cale> Well, a bit, yes.
12:03:06 <koeien371> if you understand typeclasses, the Typeclassopedia is a good read
12:03:19 <koeien371> and have a little bit of Haskell experience
12:03:58 <Cale> You could formalise categories in a completely different way in Haskell, like as a pair of types o, a, with id :: o -> a, and (.) :: a -> a -> Maybe a
12:04:31 <koeien371> o = "the objects", a = "the arrows"?
12:04:32 <Cale> and  dom :: a -> o,  cod :: a -> o
12:04:33 <Cale> yeah
12:04:42 <mreh> :t (&&&)
12:04:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:04:51 <mreh> someone explain kinds to me again
12:05:01 <Cale> mreh: kinds are the types of types
12:05:03 <mreh> what does it say about the function?
12:05:11 <Cale> * is the kind of all the normal types with values in them
12:05:19 <koeien371> a type constructor has a kind. it corresponds to the number of type arguments you have to give in order to get a type
12:05:20 <mreh> oh...
12:05:32 <mreh> nothing to do with functions then
12:05:33 <Cale> * -> * is the kind of type constructors, which take one type parameter, and produce an ordinary type
12:05:39 <Cale> Like  Maybe  for instance
12:05:43 <mreh> gotcha
12:05:44 <Cale> Maybe is a function on the type level
12:05:51 <koeien371> mreh: they are the type of "functions on the type level"
12:05:51 <mreh> what type is a function?
12:06:10 <lispy|web> mreh: (->)
12:06:10 <Cale> mreh: *
12:06:14 <koeien371> a function can have a type. This type can have a kind.
12:06:24 <koeien371> well, it always has
12:06:32 <Cale> (I sort of tried to intuit what you were really asking there)
12:06:37 <zoheb> So I am trying to combine the StateT monad (test3) with the InputT monad transformer found in the haskeline package and get an error
12:06:39 <mreh> Cale :)
12:06:41 <lispy|web> oh, I misunderstood the discussion .  It's really about kinds.
12:06:52 <mreh> yeah, functions have types, but they also have _types_
12:06:55 <Cale> If f is a function, its type is of the form A -> B for some types A and B, and this type has kind *
12:06:55 <zoheb> test3 :: StateT Integer (InputT IO ()) (Integer)
12:07:06 <zoheb> and the error I get is
12:07:31 <Cale> (->) itself has kind * -> * -> *, though it's actually a variation on this in GHC, because GHC has special kinds for dealing with unboxed types
12:07:34 <zoheb>     Kind mis-match     Expected kind `* -> *', but `InputT IO ()' has kind `*'     In the type `StateT Integer (InputT IO ()) (Integer)'     In the type signature for `test3':       test3 :: StateT Integer (InputT IO ()) (Integer)
12:07:39 <koeien371> mreh: yes. But type constructor that is a monad has kind * -> *
12:08:01 <Cale> zoheb: You don't want the ()
12:08:05 <koeien371> e.g. Maybe, or []
12:08:08 <zoheb> Is this because I haven provided a lift fn from StateT to InputT?
12:08:09 <koeien371> zoheb: leave out the () near InputT
12:08:18 <zoheb> ok
12:08:22 <Cale> zoheb: you want to apply the monad transformer StateT Integer to the monad  InputT IO
12:08:25 <mreh> Cale: is that because the function has a result of kind *
12:08:32 <koeien371> mreh: an arrow has kind * -> * -> *.
12:08:33 <Cale> mreh: not particularly
12:08:43 <Cale> mreh: Any value has a type whose kind is *
12:09:02 <koeien371> mreh: (->) is an instance of Arrow, so it has kind * -> * -> *. This means that you have to supply it with two type arguments to get a type
12:09:09 <koeien371> e.g. (->) Int Bool
12:09:19 <emile_m> @kind Arrow
12:09:20 <lambdabot> Class `Arrow' used as a type
12:09:23 <Cale> (->) Int Bool = Int -> Bool
12:09:28 <mreh> oh, I think I get it now
12:09:33 <koeien371> @kind Maybe
12:09:35 <lambdabot> * -> *
12:09:37 <koeien371> @kind (->)
12:09:38 <lambdabot> ?? -> ? -> *
12:09:50 <Cale> Please ignore the question marks ;)
12:09:51 <koeien371> @kind Int -> Int
12:09:52 <lambdabot> *
12:09:58 <mreh> so you could say, anything with a kind other than * has no value
12:10:00 <Cale> @kind (->) Integer
12:10:01 <lambdabot> ? -> *
12:10:09 <Cale> mreh: indeed
12:10:12 <koeien371> mreh: well, something of kind * -> * is not a type
12:10:13 <emile_m> @kind a -> b -> c
12:10:14 <lambdabot> Not in scope: type variable `a'
12:10:14 <lambdabot> Not in scope: type variable `b'
12:10:14 <lambdabot> Not in scope: type variable `c'
12:10:21 <koeien371> there is no value of type "Maybe", for example
12:10:25 <Cale> mreh: But it can still be useful for constructing types which do have values in them
12:10:27 <koeien371> (it is not a type)
12:10:31 <mreh> Cale, of course
12:11:07 <emile_m> That's tough
12:12:07 <mreh> so, I'm still a little confused on how to parse that (a :: * -> * -> *)
12:12:20 <koeien371> it means that a is a type constructor of this kind
12:12:25 <mreh> do you only get this in the context?
12:12:33 <koeien371> do you understand it for monads?
12:12:37 <koeien371> :type (>>=)
12:12:40 <koeien371> @type (>>=)
12:12:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:12:44 <emile_m> That is, actual types have * kinds (like actual values have "a" types)?
12:13:05 <mreh> >>= only works on Monadic type constructors that take a single value
12:13:11 <koeien371> you see that the "m" gets one type argumetn supplied (the a)
12:13:26 <koeien371> @type (***)
12:13:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:13:38 <koeien371> there "a" gets two type arguments each time
12:14:04 <koeien371> you could leave it out, since Arrow a already implies the kind of a
12:14:46 <mreh> yeah, I get it now
12:15:15 <mreh> I can't see the relevance yet
12:15:31 <koeien371> of the Arrow type class?
12:15:37 <mreh> of the kind restrictions
12:15:44 <emile_m> Hmm, there is only (*)'s. What about some kind of "types on types"?
12:16:02 <mreh> types on types, sounds like classes
12:16:06 <koeien371> emile_m: you want dependent types?
12:16:07 <mreh> type classes
12:16:09 <emile_m> ... like "*" and "~"
12:17:08 <emile_m> koeien371: I don't know, but for me, "*" is kinda placeholder for all available types.
12:18:25 <emile_m> And what if we can distinguish between "*" and "~", and "%" etc. Err... types of kinds...
12:18:54 <emile_m> DOes it make any sense? =)
12:19:18 <koeien371> you probably want more than is available in haskell now :)
12:19:47 <mreh> kinds dont strike me as being haskell98
12:20:38 <emile_m> I even don't know what is it.
12:20:40 <mreh> :t (&&&)
12:20:41 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:20:45 <Tordmor> emile_m, and where do you stop? types of types of types ... What problem do you think you could solve with another level of meta that you can't now?
12:21:23 * Heffalump definitely wants polymorphic kinds, and probably wants a full kind system
12:21:38 <koeien371> Heffalump: I would like it too
12:21:53 <koeien371> thinks like "Vector 3 Int" would be cool
12:22:00 <mreh> i am suspicious of the word meta
12:22:04 <Heffalump> Tordmor: if you're playing with phantom types, then having a proper kind system is useful
12:22:57 <mreh> phantom types?!
12:23:47 <emile_m> koeien371: Does polykinds imply dependent types?
12:24:42 <emile_m> s/Does/Do/
12:25:04 <kmc> mmm phantom types
12:25:10 * kmc recently found a good simple example of those
12:25:26 <mreh> :t (***)
12:25:27 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:25:31 <increpare> ah i get it now!  Arrows are (ignoring first and second) members of the arrow category Hom(Has,*)
12:25:33 <increpare> (hask)
12:26:05 <emile_m> kmc: Show us this example, please.
12:26:24 <Heffalump> emile_m: no
12:26:31 <Heffalump> (they don't imply dependent types)
12:26:32 <ivanm> I use phantom types in some of my code for a solver
12:26:46 <kmc> so in the interface to C code, you want to represent pointers
12:26:57 <kmc> and so we imagine:  data Ptr a = MkPtr Word
12:27:01 <kmc> the type 'a' is not used on the righ-
12:27:04 <kmc> t-hand side
12:27:14 <kmc> a (Ptr Char) is not any different in representation than a (Ptr Int)
12:27:17 <ivanm> I had a multiparam class that had two methods: a -> Foo; Foo -> b (and did some stuff with Foo in between when using it)
12:27:40 <kmc> but we want to keep a type with it anyway, so that the typechecker can prevent us doing pointer casts unintentionally
12:27:41 <emile_m> kmc: ... and we can "cast" this to any type we want?
12:27:51 <ivanm> to make sure which Foo -> b method to use, I used a phantom type to make it a -> Foo a; Foo a -> b
12:27:54 <ivanm> emile_m: ^^
12:28:06 <ivanm> (IIRC, Heffalump is the one who suggested I do that)
12:28:16 <kmc> cast :: Ptr a -> Ptr b; cast (MkPtr x) = MkPtr x
12:28:28 <kmc> note that despite the LHS and RHS being the same, you cannot write "cast = id"
12:28:48 <kmc> because we're using the deconstruct/construct to change the phantom type
12:29:40 <kmc> anyway, this is the idea of phantom types.  the type parameter stores some semantic information about correct usage of the type, even though it's not required for deciding representation
12:29:42 <mreh> we have a good turnout for christmas day
12:30:31 <Zeiris> Is there some standard library data type to store Objects and do String -> Object lookups? Preferably with partial name matches?
12:30:44 <kmc> what Object type?
12:30:52 <kmc> data-object?
12:30:53 <monochrom> I thought I needed to troll "hi I have homework due in 2 hours please help" to increase activity. :)
12:30:59 <ivanm> @time
12:31:00 <lambdabot> Local time for ivanm is Sat Dec 26 06:30:36
12:31:00 <Zeiris> I guess a data object.
12:31:01 <ivanm> mreh: ^^
12:31:05 <ivanm> not Christmas day here anymore
12:31:12 <kmc> Zeiris, i mean, there is a specific package named "data-object"
12:31:17 <kmc> are you referring to this one?
12:31:20 <Zeiris> Oh. No.
12:31:25 <monochrom> I think Data.Map
12:31:25 <emile_m> monochrom: hi I have homework due in 2 days please help
12:31:32 <kmc> there's nothing in standard Haskell named "Object"
12:31:34 <Zeiris> I'm just looking for something like a hashmap, or dictionary, or even string-indexed trie.
12:31:38 <kmc> Zeiris, yes, that would be Data.Map
12:31:47 <monochrom> hi emile_m how would anyone make homework due on Christmas :)
12:31:49 <Zeiris> Cool, thanks.
12:31:55 <kmc> or, if your keys are integers, Data.IntMap is a more efficient variant
12:32:06 <emile_m> monochrom: I'm working on Santa, you know.
12:32:07 <ivanm> monochrom: no, due in two days would make it due on a Sunday/Monday, depending where in the world you are now
12:32:16 <monochrom> "Object" and "String" are clearly over-specifications.
12:32:33 <zoheb> koeien371,Cale thanks, I think I understand whats happening now, removing the () fixed the issue
12:32:49 <Heffalump> mreh: I'm celebrating noodlemas.
12:33:03 <koeien371> zoheb: if you look at kinds, it may become clearer
12:33:07 <richardha> Get windows keys for 5eur only http://bit.ly/5Tgz2X :)
12:33:21 --- mode: ChanServ set +o monochrom
12:33:31 --- mode: monochrom set +b *!n=richardh@*.dial-up.dsl.siol.net
12:33:31 --- kick: richardha was kicked by monochrom (monochrom)
12:33:50 <ivanm> hey, a dev who's on the ball!
12:33:58 <ivanm> s/dev/op/
12:34:08 <Twey> Heh
12:34:15 <Heffalump> is that a rarity? :-)
12:34:44 <Twey> Well, #haskell is the only channel I'm in in which that guy has been banned already.
12:35:01 <monochrom> Only because I have homework due in 2 hours!
12:35:19 <Twey> Oh, not any more.  #fedora caught on.  âº
12:35:23 <ivanm> a lot of times a "@where ops" may be needed due to what seems to be an unfortunate conglomeration of ops in late time zones...
12:35:41 <ivanm> monochrom: I thought it was 2 days...
12:35:56 --- mode: monochrom set -b *!n=richardh@*.dial-up.dsl.siol.net
12:36:01 --- mode: monochrom set -o monochrom
12:36:33 <increpare> @where ops
12:36:33 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
12:37:41 * kuribas reduced the main part of his optimal paragraph breaking algorithm to 6 lines!
12:37:51 <Saizan_> ?
12:37:57 <mreh> Heffalump: not ceilingmas then?
12:38:16 <increpare> kuribas: paragraph-breaking?
12:38:19 <kuribas> Knuth's paragraph breaking algorithm actually :)
12:38:36 <increpare> kuribas: ah line breaking?
12:38:40 <elly> knuth is a pretty cool guy
12:38:43 <kuribas> yes
12:38:55 <increpare> I don't think the algorithm is his
12:38:55 <mreh> hip to the beat
12:38:58 <Heffalump> mreh: what's ceilingmas?
12:39:04 <mreh> I made it up
12:39:16 <increpare> kuribas: or at least the one in latex isn't, I think
12:39:27 <SamB_XP> latex doesn't have its own!
12:39:41 <increpare> kuribas: will you share it with us?
12:39:43 <mreh> some say ceilingcat sent his only son to be born in an image macro
12:39:45 <kuribas> sure
12:39:46 <increpare> SamB_XP: what do you mean?
12:40:01 <SamB_XP> that's backed into TeX
12:40:03 <mreh> is it a flying spaghetti monster thing?
12:40:05 <SamB_XP> er. baked
12:40:38 <pettter> invisible pink unicorn?
12:40:38 <increpare> SamB_XP: ah right, course - excuse me for doing a violence to the distinction between them  :)
12:40:40 <kuribas> The code isn't checked though...
12:41:00 <kuribas> increpare: http://paste.lisp.org/display/92642
12:41:13 <kuribas> It doesn't hyphenate words either...
12:41:14 <mreh> you can't actually disprove the existance of the flying spaghetti monster, so I don't really understand what DickDawk is talking about
12:41:28 <increpare> kuribas: yawww
12:42:36 <kuribas> It would have been much more complicated in another language, thanks to haskell's lazyness!
12:42:42 <emile_m> At last, I have some debugging activity in Haskell!
12:42:50 <increpare> kuribas: :)
12:42:57 <increpare> emile_m: oho?
12:44:03 <mreh> I'm going to write a book doubting the existance of the flying spaghetti monster, and see how long it takes for someone to call Poe's Law
12:44:48 <increpare> Ah yes, the line-breaking stuff was done by Knuth and Plass (who did a thesis on the matter)
12:45:11 <emile_m> increpare: Somehow my code adds 8 redunant bytes in output.
12:45:41 <Heffalump> mreh: ah :-) yes.
12:46:04 <kuribas> I have also taken the cost function from "the TeXbook".
12:46:31 <increpare> emile_m: well if they're redundant you don't need to worry about them :P
12:50:32 <emile_m> increpare: I need. They break some data structure.
12:51:09 <emile_m> To be honest, it isn't "bug" in compiler, i've just heed some tracing.
12:51:35 <increpare> emile_m: you could set breakpoints ?
12:52:11 <emile_m> increpare: Trying to do this :-)
12:52:29 <increpare> emile_m: hope it works out : )
12:54:17 <emile_m> increpare: Thanks. Actually, that so-called "bug" is in my head.
12:54:46 <increpare> emile_m: so it was a redundant bug then?
12:55:44 <alp_> how can I ensure a "writeFile" has been executed when leaving the function it's being written in ?
12:57:03 <increpare> alp_: hmm?
12:57:34 <alp_> I do successive calls to a function containing a 'writeFile filename content' call
12:58:02 <increpare> it performs these calls unsafely?
12:58:20 <Zao> Aren't writeFile and appendFile strict?
12:58:24 <monochrom> writeFile will block until writing is done.
12:58:29 <koeien371> I don't see your problem. If a writeFile is performed, the file is written to
12:58:43 <Zao> I suppose "strict" is the wrong wording, as they're in IO ()
12:58:44 <koeien371> yeah, it blocks until it's done
12:58:53 <koeien371> or it throws an exception
12:59:04 <ivanm> with Seq, is it 0-indexed or 1-indexed?
12:59:15 <koeien371> (e.g., for out of disk space, or insufficient permissions)
12:59:43 <Saizan_> i'd think of I/O buffering, but writeFile presumably closes the handle, so they should get flushed?
12:59:46 <ivanm> ahhh, right
13:00:02 <ivanm> it starts at 1; the version in 6.12 has better docs than the one with 6.10
13:00:56 <Saizan_> > Seq.index 1 $ Seq.fromList [0..10]
13:00:58 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:00:58 <lambdabot>         against inferred type ...
13:01:00 <koeien371> Saizan_: right.
13:01:05 <koeien371> the handle is closed
13:01:18 <koeien371> even in case of exceptions
13:01:42 <Saizan_> > Seq.index (Seq.fromList [0..10]) 0
13:01:43 <lambdabot>   0
13:01:45 <Saizan_> > Seq.index (Seq.fromList [0..10]) 1
13:01:46 <lambdabot>   1
13:02:25 <Saizan_> ivanm: it's 0 based
13:03:44 <alp__> <alp_> I do successive calls to a function containing a 'writeFile filename content' call <alp_> and sometimes it happens to tell me the file is still locked while I try to write stuffs in it
13:04:26 <Saizan_> alp__: do you also read from it somewhere else?
13:04:26 <koeien371> could you paste your code?
13:04:50 <alp__> Saizan_, from the same file, actually, yeah.
13:05:14 <alp__> is there any `seq` trick or whatever that could guarantee the file is properly opened, read/written and closed ?
13:05:15 <Saizan_> if you're doing it with readFile that might be why
13:05:26 <alp__> I use readFile & writeFile yeah.
13:05:39 <alp__> hGetContent & all are better ?
13:05:56 <koeien371> hGetContents is actually strange with respect to file handle closing
13:06:00 <Saizan_> readFile is implemented with hGetContents
13:06:09 <Saizan_> which is the problem.
13:06:09 <alp__> ok
13:06:13 <koeien371> readFile is also lazy i guess
13:06:20 <Saizan_> because it's using "lazy I/O"
13:06:23 <alp__> it is, yes, or seems to be.
13:06:33 <Saizan_> alp__: a solution is to force the whole result of readFile
13:06:55 <koeien371> or explicitly read the whole file into memory and close your file handle
13:07:00 <alp__> Saizan_, should I seq the result of readFile before actually doing stuffs and then writing back stuffs to the file ?
13:07:26 <Saizan_> alp__: before writing out at least, you've to seq the length
13:07:49 <koeien371> imho it's cleaner to explicitly close the file handle yourself
13:07:57 <koeien371> i guess you still depend on the timing of the garbage collector otherwise
13:08:04 <Saizan_> alp__: e.g. do xs <- readFile "foo"; ...; length xs `seq` writeFile "foo" ..
13:08:13 <alp__> yeah
13:08:17 <alp__> that's what I'm typing at the moment
13:08:24 <Saizan_> koeien371: i think getContents explicitly closes the handle
13:08:45 <alp__> Saizan_, it is less likely to happen with writeFile ?
13:09:00 <koeien371> Saizan_: doesn't hGetContents make the handle "semi-closed"?
13:09:02 <Saizan_> if you close the handle yourself you've to make sure you've read all that you want to read from it
13:09:27 <Saizan_> alp__: writeFile doesn't use "lazy I/O"
13:09:37 <alp__> ok
13:09:38 <alp__> then it's perfect
13:09:41 <koeien371> Saizan_: you mean, once it reaches EOF, it always closes the handle immediately?
13:09:41 <alp__> thank you :)
13:09:54 <Saizan_> koeien371: istr that
13:10:41 <ivanm> Saizan_: yeah, I'm still using 6.10.4 atm, and its docs say "... which should be a positive integer less than the size of the sequence."; methinks someone doesn't know what "positive integer" means wrt 0 ...
13:11:05 <koeien371> reminds me of the Django "PositiveIntegerField"...
13:18:12 <pantsman> hello
13:18:27 <koeien371> hi!
13:19:15 <pantsman> I got a haskell book for christmas :D
13:19:29 <monochrom> neato
13:19:52 <koeien371> Real World Haskell?
13:20:08 <monochrom> Haskell at World's End
13:20:13 <pantsman> koeien371, yes :o
13:20:23 <pantsman> how did you know? :P
13:20:27 <cizra> I got a roll of solder and acid, along with a T-shirt with Tux on it \o/
13:20:44 <koeien371> pantsman: there are not that many haskell books in existence
13:20:52 <pantsman> ah
13:21:16 <monochrom> actually, many in existence but not many in circulation
13:21:47 <BMeph> czira: Lucky! I'm buying a hibachi, 'cause some nice guy left me a sack of coal to use in one... ;p
13:23:30 <emile_m> Is there a book which explains some intermadiate functional techniques like existentials or rank-n types?
13:24:14 <chrisdone> heh, the old "lump of coal for bad kids". horrible santa, it's not like I'll be able to use this to heat my room while plotting bad deeds for next year
13:25:21 <ivanm> monochrom: never heard of that one...
13:25:47 <ivanm> emile_m: they're "intermediate"? I thought they were more advanced techniques...
13:27:30 <emile_m> ivanm: From my pov, "advanced" are Control.Arrow.Extras, type families or something like that.
13:28:24 * ivanm lumps them all together as the "these might be cool things but thankfully I don't really have to know anything about them yet" category ;-)
13:28:44 <ivanm> well, I use type families a bit to provide type aliases in classes rather than using a fundep
13:28:48 <ivanm> but that's about it
13:28:59 <monochrom> ivanm: I made that up. :)
13:29:10 <ivanm> awwwwwww :(
13:29:29 <monochrom> Haskell x Pirates of Carribean: At World's End. :)
13:30:03 <ivanm> I thought it was more apocalyptic sci-fi ...
13:30:08 <andrewe> hoogle search links are broken, I get a 404 error. Is there a fix?
13:30:22 <ivanm> andrewe: yes; someone re-does the links
13:30:25 <ivanm> otherwise, use hayoo
13:31:21 <chrisdone> ah, back to SICP
13:31:22 <andrewe> ivanm: thanks, I didn't know hayoo.
13:31:50 <chrisdone> SICP is like Art of Programming. you can just come back to it all the time
13:32:51 <meanburrito920_> I'm having a bit of trouble with some basic haskell; namely foldl and foldr. I'm trying to figure out what exactly gets passed to the function given to foldl or foldr
13:33:12 <emile_m> I heard that they don't teach SICP in MIT anymore.
13:33:19 <chrisdone> :t foldr
13:33:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:33:25 <meanburrito920_> emile_m: nope, they teach python now
13:33:40 <meanburrito920_> chrisdone: right, i got that part, but that doesnt tell me specifically what is passed to what
13:33:46 <chrisdone> meanburrito920_: b is the accumulated "total" which will be the final value. a is each a from the list
13:34:00 <meanburrito920_> for example, lets say i want to foldl the list 1:2:3:4:[]
13:34:08 <emile_m> meanburrito920_: foldl f z [1..5] = (((((f z 1) 2) 3) 4) 5)
13:34:28 <ivanm> > foldr (:) []
13:34:28 <aavogt> > foldr f z [1..5] :: Expr
13:34:29 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
13:34:29 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
13:34:38 <ivanm> aavogt: that's what I was aiming for
13:34:46 <emile_m> foldr f z [1..5] = (f 1 (f 2 (f 3 (f 4 (f 5 z)))))
13:35:03 <meanburrito920_> oh, ok.
13:35:20 <meanburrito920_> and then foldr evals from the right and foldl from the left
13:35:33 <chrisdone> yes
13:35:59 <meanburrito920_> thanks :)
13:36:01 <Veinor> > foldl f z [1 .. 5] :: Expr
13:36:02 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
13:36:10 <emile_m> meanburrito920_: Year. Note that "zero" value comes at first place in left fold and last in right fold.
13:37:32 <meanburrito920_> specifying the :: Expr type to lambdabot is useful :) too bad it doesnt seem to work in ghci
13:37:38 <eu-prleu-peupeu> anyone going to the hackaton in march ?
13:37:49 <chrisdone> where is the hackathon?
13:37:53 <eu-prleu-peupeu> zurich
13:37:55 <monochrom> It is another library. Look for "simple reflection"
13:37:55 <aavogt> @hackage simple-reflect
13:37:55 <lambdabot> http://hackage.haskell.org/package/simple-reflect
13:38:05 <chrisdone> ho, ho. you must be joking, mr eu
13:38:15 <eu-prleu-peupeu> http://www.haskell.org/haskellwiki/ZuriHac
13:38:39 <ivanm> chrisdone: yeah, as if _anyone_ would want to go to zurich (unless you have some money you don't want your government to see)!
13:39:18 <eu-prleu-peupeu> zurich is 200â¬ away from here
13:39:51 <Heffalump> eu-prleu-peupeu: me
13:40:03 <Heffalump> must get round to booking stuff
13:40:40 <chrisdone> ivanm: I'm just too disorganised to attend =)
13:40:56 <chrisdone> although some people I'd like to meet appear to be going
13:41:01 <Heffalump> my company's headquarters is in Zurich
13:41:03 <ivanm> well, I'm not going
13:41:14 <ivanm> but the way you said it implied that _no-one_ was going ;-)
13:41:14 <eu-prleu-peupeu> Heffalump: im not sure if i will go there
13:41:20 <eu-prleu-peupeu> Heffalump: you work @google ?
13:41:22 <Heffalump> not that this is relevant to my hackathon trip
13:41:33 <Heffalump> eu-prleu-peupeu: no, Credit Suisse :-) Google's HQ is in California.
13:41:44 <eu-prleu-peupeu> ah ok
13:42:01 <j4cbo> google has offices all over, though
13:42:07 <eu-prleu-peupeu> credit suisse works in haskell ?
13:42:30 <eu-prleu-peupeu> isn't credit suisse the bank of the mafia bosses ?
13:42:57 <Heffalump> we do some Haskell stuff, though more F# these days
13:43:14 <eu-prleu-peupeu> why F# instead of haskell ?
13:43:24 <Heffalump> .NET is probably the main reason
13:43:50 <eu-prleu-peupeu> hmm, i see
13:44:05 <chrisdone> did I hear something about a .NET backend to GHC in the works or did I dream that?
13:44:13 <eu-prleu-peupeu> haskell.net  :)
13:44:31 <Heffalump> there've been various abortive efforts, but it's fundamentally a hard problem to do well
13:44:31 <chrisdone> maybe it was that other virtual machine
13:44:34 <ivanm> chrisdone: there's a couple IIRC
13:44:36 <ivanm> salsa, etc.
13:44:37 <Heffalump> either .NET or JVM
13:44:49 <Heffalump> salsa and hs-dotnet are bridges
13:44:52 <Heffalump> not backends
13:44:54 <ivanm> ahhh
13:44:54 <chrisdone> mm
13:45:02 <eu-prleu-peupeu> mono haskell
13:45:08 <ivanm> *shrug* I have no real interest in anything but a native backend
13:45:10 <Berengal> The problem isn't getting haskell to run on a vm, but doing nice interop with the other languages that do
13:45:32 <ivanm> Berengal: which is why everyone _wants_ haskell on the VM in the first place?
13:45:38 <ivanm> (well, not really for llvm)
13:45:45 <eu-prleu-peupeu> Heffalump: are you going to bring any project to the hackaton ?
13:45:50 <Berengal> ivanm: Presumably, yes
13:45:51 <Heffalump> probably do darcs stuff
13:46:30 <chrisdone> I have interest in happstack
13:46:44 <Berengal> happstack is fun to use
13:51:58 <Jackdaw> Hi All, i'm trying to solve the next palindrome problem on spoj, i have a working alg but it times out when i submit it, i made a little test file and it takes about 11s to find palindromes for 4 1million digit numbers, i guess this is too slow. The code is here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15007#a1500 any hints for speeding it up?
13:52:56 <Botje> Jackdaw: for starters, you could not bother reading
13:53:05 <Botje> let sx = show x in sx == reverse sx
13:53:30 <Cale> Jackdaw: (!!), length, last, and to a lesser extent (++), are all things which are to be avoided if possible.
13:54:04 <Jackdaw> Botje: i stopped using the first method, it was too slow
13:54:07 <Cale> They're all O(n) operations
13:54:45 <Botje> it was fast enough when i used it for project euler
13:55:22 <Jackdaw> the time limit is 9s
13:55:53 <Cale> x !! halfway, for instance, is going to take about halfway number of steps to evaluate
13:56:24 <burp> @hoogle zipWith4
13:56:24 <lambdabot> Data.List zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
13:56:49 <Jackdaw> ahh thats a good point cale
13:57:38 <burp> @hoogle zipWithM4
13:57:39 <lambdabot> No results found
13:59:26 <burp> um, never mind
14:00:26 <xle> hey all.. I'm trying to locally install the Network module.. I downloaded the package from hackage, did runhaskell Setup configure --prefix=$HOME --user, then build and then install.. I keep getting segfault when I link to the library though.. any ideas?
14:00:57 <tommd> xle: Is it actually a segfault or are you getting a GHC build error?
14:01:14 <tommd> If its just a build error I'm guessing you are forgetting to use "--make"
14:01:32 <xle> tommd: it actually builds fine, and I get Segmentation fault when I try to run the program that uses the library
14:01:47 <xle> I build with ghc --make
14:02:05 <Heffalump> is there a standard way of memoising IO functions?
14:02:42 <tommd> xle: I don't have any guesses, from what you've said the bug could be anywhere in your program.  Try reducing it to something digestable then paste.
14:02:47 <_Jedai_> Heffalump: isn't that a bit of a problem ?
14:03:05 <Heffalump> well, I know the functions I want to memoise are idempotent
14:03:06 <_Jedai_> Heffalump: either it's really IO with side-effect and you don't want to memoize it
14:03:16 <Heffalump> it's a read effect
14:03:34 <Heffalump> and ideally the memo scheme would be itself in IO so I can restart when I know the results will have changed
14:03:43 <_Jedai_> Heffalump: or it's really pure and you just have to use unsafe and do the same as pure functions, no ?
14:03:59 <Heffalump> imagine I'm reading a file
14:04:03 <_Jedai_> Ok, that might be interesting
14:04:06 <Heffalump> (I'm not, but it's morally equivalent)
14:04:19 <Heffalump> essentially I have String -> IO [something]
14:04:30 <Heffalump> and I want to only run the action once for each String.
14:05:30 <_Jedai_> use an MVar, do the classic memoizing from imperative languages ?
14:05:53 <xle> tommd: actually, I even tried it with an almost empty body and I still get the segfault... When i substitute the local installation of the Network library with the default library package, it runs fine
14:06:03 <xle> tommd: looks like the problem is with linking / something underlying
14:06:06 <ivanm> the "moral equivalent"?
14:06:07 <_Jedai_> Or rather an MMap, maybe Data.HashTable though its performance is said to be quite atrocious
14:06:44 <Heffalump> ivanm: reading a list of objects from Amazon S3, as it happens.
14:06:57 <ivanm> hmmm...
14:07:12 <skorpan> monads are still weird to me
14:07:20 <Heffalump> really I just want something structured like Data.MemoCombinators, but handling IO
14:07:24 <skorpan> i never manage to stay focused when reading up on them
14:07:31 <adu> Heffalump: if you take it out of IO, then I think there is automagic memoization
14:07:42 <_Jedai_> Heffalump: So what do you think of my idea ? Since you're in IO you can just do your memoization like in any imperative language
14:08:05 <_Jedai_> Heffalump: see memoization framework in imperative languages for inspiration
14:08:15 <_Jedai_> adu: Not quite
14:08:17 <tommd> xle: I'd say somethings wrong with your development setup - for all the platforms I've heard of the network library doesn't do that when properly installed
14:08:31 <tommd> xle: What platform anyway?
14:08:33 <xle> tommd: os x
14:08:46 <tommd> Can't say that's surprising.
14:08:50 <Heffalump> _Jedai_: yeah, I guess that's the obvious answer. I was just overcomplicating in my head.
14:08:50 <xle> tommd: which is somewhat problematic I think... yeah I know what you mean
14:09:14 <tommd> I'd peruse the network trac and if there isn't already a bug report then dig a little more info up and make one.
14:09:41 <adu> whats wrong with osx?
14:10:18 <xle> tommd: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15008#a15008
14:10:29 <xle> tommd: in case you want to take a look... nothing complicated though
14:13:18 <adu> is that calling the getaddrinfo() function underneath?
14:14:20 <tommd> xle: Have you strace'd it yet?
14:14:36 <xle> tommd: no, not sure how to do that under os x
14:14:42 <xle> tommd: no command called strace..
14:15:35 <Zao> Might have truss, as it has BSD heritage.
14:15:58 <adu> xle: i'm on macosx, no problems here
14:16:02 <Zao> Ah, ktrace
14:16:03 <adu> xle: what version?
14:16:19 <xle> adu: i've got snow leopard 10.6.2
14:16:29 <adu> xle: ah, that must be it, I have 10.5.8
14:16:35 <adu> lots of things broke in 10.6
14:16:41 <xle> adu: no problems when i sue the build-in Network.Socket... I just can't get a recompiled version (from hackage) to run without segfaulting
14:17:09 <xle> Zao: i tried both truss and ktrace.. can't find either
14:17:13 <adu> 10.6 was the release that was supposed to fix everything, but the ended up breaking a few things
14:17:51 * adu has heard of lots of mac apps failing in bizarre ways on macosx 10.6 
14:18:27 <adu> xle: you know what the bigest change was?
14:18:54 <xle> adu: some underlying stuff i think.. the central dispatch, etc..
14:18:58 <adu> xle: gcc compiles in 64bit mode by default now
14:18:59 <xle> adu: and 64-bit of course
14:19:21 <adu> that is the biggest change, and I don't approve
14:19:23 <Zao> DTrace might do in >= 10.5
14:19:36 <xle> adu: ah i see.. that could be it actually.. the problem I'm having is obviously has to do with the C FFI
14:19:59 <xle> Zao: thanks! there is a dtrace.. let me take a look
14:20:11 <mreh> how does one add to existing packages?
14:20:14 <xle> Zao: any good flags I should use?
14:20:18 <mreh> in hackage that is
14:20:35 * adu votes against changing defaults between minor releases
14:20:36 <mreh> do I need to be added as a contributor a package I do no maintain directly
14:21:59 <Saizan_> mreh: you usually send a mail to the maintainer, with a patch if you can find the repository somewhere
14:22:04 <adu> I can see doing something like that in macos11 tho
14:22:04 <byorgey> mreh: it depends. you should contact the maintainer of the package.
14:22:48 <Zao> xle: No idea, check the link from wikipedia on OSX and strace.
14:22:57 <xle> Zao: Looking at it now :)
14:23:17 <chrisdone> if you made a significant contribution then attribute yourself in the authors field. if you are willing to be a maintainer and receive a bunch of emails all the time about it, check with the existing maintainer and add yourself as a maintainer if they approve or are not available
14:23:24 <mreh> I would be inclined to include it as a extension to the core modules, in which case I might just release it as my own library, e.g. haskore-lilypond
14:25:35 <mreh> oh, a question, does haddock recognise multi-line comments?
14:25:49 <mreh> {- | blah -}?
14:25:54 <monochrom> Yes.
14:26:06 <ivanm> harrop said that Louis Wasserman assumed the author of a paper meant asymptotic time complexity; I think harrop is assuming we care what he thinks and that we actually want him to troll
14:26:06 <mreh> excellent
14:26:48 <Jackdaw> so what would be a more efficient data type for storing a long list, which needs to be cut in half and such? given that get element, length and such are order N for a regular list
14:27:10 <opqdonut> have a look at Data.Sequence
14:27:17 <Jackdaw> opqdonut: thanks i will
14:27:32 <opqdonut> can't remember if splitting was especially efficient, but indexing is
14:27:52 <ivanm> opqdonut: IIRC, splitting is reasonably efficient
14:28:07 <Jackdaw> opqdonut: looks like split is o(log(min(pos, n-pos)) which is pretty ok
14:28:07 <ivanm> O(log(min(i,n-i))) <-- splitAt
14:28:08 <opqdonut> yeah, reasonable is what i expected
14:28:13 <opqdonut> nice
14:28:25 <Jackdaw> ahh this should be a simple replacement too, thanks!
14:30:22 <xle> Zao: FYI there is a dtruss on mac
14:30:41 <xle> Zao: also an xcode tool called instruments that has an outstanding UI to profile realtime apps.. trying to figure it out now..
14:31:21 <Zao> I tend to avoid the silly platform.
14:36:38 <mreh> what's the acceptable way to begin and end a multiline comment, I find the closing comment on a newline
14:36:48 <mreh> closing comment marker
14:37:32 <Gracenotes> I tend to begin with {- and end with -}, but that is just my personal practice
14:38:21 <Twey> Haha
14:38:54 <Gracenotes> hm. interesting enough, the base and container libraries have multiline comments as a series of -- comments
14:39:37 <mreh> I need to cater for our inferiors, those who view code in a text only environment
14:39:56 <Gracenotes> that seems to be the haddock way
14:43:56 <BMeph> Odd...I would've expected that splitting a Sequence in half would be especially fast, considering the underlying tree carries the size as an element.
14:44:14 <Twey> mreh: Errâ¦ I view code in a text-only environment.  What're you talking about?  :Ã¾
14:44:41 <mreh> does it bug you when comments wrap?
14:45:27 <pantsman> I view code as a small troupe of squirrels who convey its meaning to me via interpretive dance
14:45:31 <pantsman> text is for losers
14:45:41 <ivanm> BMeph: it is...
14:45:46 <ivanm> pantsman: heh
14:45:55 <ivanm> @remember pantsman I view code as a small troupe of squirrels who convey its meaning to me via interpretive dance
14:45:55 <lambdabot> It is stored.
14:46:23 <mreh> sounds like acid
15:11:51 <mreh> @pl scoreToLySource' s { music = toMediumList . music $ s }
15:11:51 <lambdabot> (line 1, column 20):
15:11:52 <lambdabot> unexpected "{"
15:11:52 <lambdabot> expecting variable, "(", operator or end of input
15:15:58 <Twey> mreh: No point-free equivalent!
15:16:19 <Twey> pantsman: Hahaha
15:16:51 <Twey> mreh: No, it doesn't bug me when comments wrap.  Then again, on my display it takes quite a long line to wrap against my will.
15:17:11 <Twey> If it did bug me, I would simply turn off line-wrap.  ;)
15:19:07 <kuribas> mreh: what are you doing with lilypond?
15:19:21 <mreh> kuribas: haskore to lilypond
15:19:43 <mreh> direct translation of a haskore Music.T datatype to lilypond source
15:19:53 <kuribas> mreh: I see.
15:19:57 <mreh> you get nice printed scores of your music
15:20:22 <mreh> i'm working on a monophonic version for my purposes, maybe it will grow further
15:20:42 <kuribas> mreh: I am starting a music notation program written in haskell.
15:20:56 <mreh> well check out haskore
15:21:31 <mreh> it's quite a good library
15:21:40 <kuribas> haskore is more oriented towards performance than towards notation.
15:21:51 <mreh> no it isnt
15:22:06 <mreh> it's oriented towards abstract music representation
15:22:21 <mreh> well, okay, you're right
15:22:51 <kuribas> It doesn't have double sharp or double flat for example...
15:23:17 <mreh> kuribas: that can be fixed with algorithms when it comes to rendering
15:24:33 <mreh> i don't know what they are, but there is a consistant way to write music that is unabiguous
15:25:52 <kuribas> Well, converting from absolute pitch to notenames isn't trivial.  You can have a melodic reason for prefering sharp to flat or a harmonic one.
15:26:13 <kuribas> But there are no fixed rules.  Often it is up to the composer.
15:27:51 <mreh> I would propose a consistant set of functions that convert an abstract representation into a note value, then you can have some choice
15:28:35 <mreh> a set of consistent functions, rather
15:29:58 <mreh> melodically, a double sharp/flat is prefered when the note following would require an alteration that results in a natural
15:30:21 <mreh> does that seem that correct and consistant?
15:30:53 <kuribas> mreh: It is a good hearistic.
15:31:40 <kuribas> I have written a program to take midi input and convert it to notation.  It does a good job, but it cannot always get the notes right.
15:31:55 <mreh> really? midi2ly is woeful!
15:32:24 <kuribas> I am using pmw at the moment, because lilypond is broken on my system :(
15:33:17 <kuribas> For lilypond there is rumor: http://www.volny.cz/smilauer/rumor/rumor.html
15:34:23 <mreh> kuribas: I'll have to try that
15:34:38 <mreh> I had tried haskore -> midi -> lilypond, but it didn't work at all
15:35:02 <mreh> there were empty bars, and everything was twice as long as it should have been
15:35:42 <mreh> there might have been an error in the code I wrote, didn't debug, but it didn't tie notes, simple things
15:35:52 <kuribas> mreh: That's because it doesn't synchronise it's internal metronome with the midi file.
15:36:11 <mreh> kuribas: interesting
15:36:46 <kuribas> If you need keyboard input, you can use my program.
15:37:57 <mreh> i'm using haskore because it's really neat for making music automatically
15:38:11 <mreh> not very good music, but i'm interested in making etudes automatically
15:38:47 <kuribas> ah, I see.
15:39:36 <mreh> souless music :)
15:41:54 <kuribas> mreh: I am sorry for the poor musician that has to play generated music ...
15:42:09 <mreh> it's going to be me
15:42:31 <mreh> i give the computer a cut down score, the program fills in the blanks
15:42:41 <mreh> helps with melodic improv
15:43:00 <kuribas> interesting...
15:43:21 <mreh> changing between parallel guidetone lines, embellishing it melodically, changing octaves
15:43:42 <mreh> trying to synthesise the technical and the aural
15:44:04 <mreh> and improving reading
15:49:06 <eu-prleu-peupeu> an implementation of .net in haskell would be nice :)
15:49:14 <eu-prleu-peupeu> the haskell.net
15:50:37 <Zao> I'd be happy with something targetting the VC++ compiler.
15:50:47 <ivanm> eu-prleu-peupeu: don't you mean the other way round?
15:50:56 <ivanm> Zao: why would you want it to target another compiler?
15:51:24 <ivanm> getting rid of gcc-isms, yes; but why would you want to then restrict it to a different compiler?
15:52:00 <Zao> ivanm: I would want it to target VC++ so I could use it with and in code targetting that compiler.
15:52:30 <maltem> @tell lispy Baaad. Now I'm annoyed by the same iteratee issue about empty chunks (and in general, impl. of >>=) as you were, and it drives me crazy :)
15:52:30 <lambdabot> Consider it noted.
15:52:45 <Zao> If I want to use any GHC-sourced Haskell now, I must first FFI it to a GCC-sourced DLL, then dynamically load that into my MSVC++ application.
15:52:58 <Zao> Not exactly elegant.
15:54:12 <Zao> Heck, my primary usage would be to FFI against DirectX.
15:54:23 <Zao> Something that isn't quite simple with the current mingw clusterhug.
15:54:42 <ivanm> right, make it C-compiler agnostic
15:55:06 <Zao> You still need lots of platform-tied bits, as I understand it.
15:55:08 <Zao> Linker etc.
15:55:23 <Zao> Not to mention register mapping, and a slew of other Fun Stuff I hope I never have to touch.
15:56:05 <eu-prleu-peupeu> i would really like to have xna in haskell
15:56:46 * maltem has a look at IterateeCPS.hs and hopes it makes happy
15:59:38 <Saizan_> iteratee :: Brains -> Happyness
16:10:45 <maltem> hey it does indeed make more sense in CPS
16:11:15 <maltem> less arbitrary code
16:29:40 <Saizan_> mh, i can imagine that
16:39:32 <mistermattaway> has anyone ever watched the C9 lectures on Haskell?
16:48:49 <eu-prleu-peupeu> mistermattaway: no, where are they ?
16:49:41 <ivanm> on the internet...
16:49:56 <mistermattaway> oops, sorry! I forgot to link them
16:49:58 <mistermattaway> http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
16:50:47 <monochrom> I wonder why it is not called Channel 0xF
17:00:11 <eu-prleu-peupeu> monochrom: why 0xF ?
17:03:46 <eu-prleu-peupeu> hey copumpkin_ :P
17:04:04 <Twey> As in âtotally â¦edâ?
17:06:56 <mistermattaway> tmin!
17:07:35 <monochrom> why 0xF is because the same reason as why 9 but better.
17:08:15 <mistermattaway> apparently there is a channel 8, and 10 as well
17:14:18 <holmak> @unmtl StateT s IO a
17:14:18 <lambdabot> s -> IO (a, s)
17:14:24 <holmak> @unmtl StateT s Maybe a
17:14:25 <lambdabot> s -> Maybe (a, s)
17:14:31 <holmak> @unmtl StateT s [] a
17:14:31 <lambdabot> s -> [(a, s)]
17:17:49 <CalJohn> > fmap (+1) (1,2)
17:17:50 <lambdabot>   (1,3)
17:22:44 <Veinor> ... what?
17:22:50 <Veinor> (a,b) is a Functor?
17:23:21 <tensorpudding> @hoogle Functor
17:23:22 <lambdabot> Prelude class Functor f
17:23:22 <lambdabot> Control.Monad class Functor f
17:23:22 <lambdabot> Control.Monad.Instances class Functor f
17:23:28 <tensorpudding> err
17:23:30 <tensorpudding> @info (,)
17:23:31 <lambdabot> (,)
17:23:32 <skorpan> @instances Functor
17:23:33 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:23:37 <skorpan> ((,) a)
17:24:01 <skorpan> (i guess)
17:24:05 <Veinor> which means the same as (a,b)? :P
17:24:06 <Niccus> doesn't seem to be so by default
17:24:11 <tensorpudding> no
17:24:22 <Veinor> and yeah, it's not in ghci
17:24:35 <Veinor> by default
17:24:41 <tensorpudding> it's probably defined in a module that you haven't imported
17:24:47 <tensorpudding> but which lambdabot knows
17:25:13 * Veinor nods
17:25:17 <CalJohn> > fmap show (1,"Hello")
17:25:18 <lambdabot>   (1,"\"Hello\"")
17:25:34 <skorpan> i think i heard the other day that lambdabot knows Caleskell
17:25:50 <Veinor> > fmap (++ "f") (1,"Haskell")
17:25:50 <lambdabot>   (1,"Haskellf")
17:26:13 <tensorpudding> maybe in Control.Monad.Instances
17:26:26 <Niccus> :t fmap (++ "b") (1,"a")
17:26:27 <lambdabot> forall t. (Num t) => (t, [Char])
17:26:28 <tensorpudding> unfortunately it looks like it's down
17:26:30 <skorpan> :t fmap fmap fmap
17:26:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:28:01 <tensorpudding> i don't think you can define functors to have kind * -> * -> *
17:29:24 <xerox> ?src Functor
17:29:24 <lambdabot> class  Functor f  where
17:29:24 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
17:29:33 <xerox> indeed.
17:29:38 <HaskellLove> what does it mean to say that a functional programming language is combinatorics based?
17:29:52 <tensorpudding> but it does appear that a lot of the hoogle links are broken
17:30:11 <tensorpudding> all the ones that link to haskell and not hackage
17:30:21 <CalJohn> Veinor: i think (a,b) is a functor in ghci out of the box
17:30:33 <skorpan> HaskellLove: that someone likes to use buzz words
17:30:34 <Veinor> fmap (+1) (1,2) errored
17:30:47 <xerox> you have to import some module, where the instance is defined
17:30:56 <xerox> it might be Control.Monad.Instances I'm not sure
17:30:56 <tensorpudding> no
17:31:05 <tensorpudding> it's in Control.Monad.Instances, not by default
17:31:16 <Veinor> yeah, it's C.M.I.
17:31:34 <tensorpudding> that module contains tons of crazy instances
17:31:36 <CalJohn> ah, I am confused I have C.M on the loadpath for ghci
17:34:22 <tensorpudding> like (-> r)
17:34:22 <HaskellLove> skorpan no seriosly, FL is based on combinatorial logic it says, can you give me general answer what that means. I am not combinatorics expert but i will understand if you explain in programerish terms
17:34:22 <xerox> (tensorpudding: it's the other argument)
17:34:22 <skorpan> HaskellLove: that makes more sense.  http://en.wikipedia.org/wiki/Combinatorial_logic
17:34:22 <tensorpudding> but apparently i can't find the docs, is there something wrong with haskell.org?
17:34:22 <xerox> ?docs
17:34:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:34:22 <skorpan> HaskellLove: as i understand it, it basically means that it is based on purity of functions, i.e. side-effect free (basically no variables) and referential transparency (x means the same x everywhere in the function)
17:34:22 <xerox> this always works, the various "?docs Control.Monad.Instances" might not, because the plug in doesn't know about the base split
17:34:22 <HaskellLove> skorpan well of course wiki, but i would not have asked if i understood that there
17:34:22 <tensorpudding> okay
17:34:22 <tensorpudding> so it's hoogle that's broken
17:34:22 <skorpan> HaskellLove: i'm a newbie myself, so excuse any invalidity in my answer :P
17:34:22 <tensorpudding> ah, right
17:34:22 <tensorpudding> all the ones i'm messing up on are in base
17:34:22 <tensorpudding> it didn't know
17:34:26 <tensorpudding> :t [::]
17:34:28 <lambdabot> parse error on input `::'
17:34:31 <tensorpudding> huh
17:34:44 <Veinor> what're you trying to do?
17:35:09 <Veinor> :k []
17:35:10 <lambdabot> * -> *
17:35:20 <Veinor> :k is like :t for type constructors, yeah?
17:35:21 <lambdabot> parse error on input `:'
17:35:28 <tensorpudding> :k tells you what the kind is
17:35:30 <lambdabot> Not in scope: type variable `tells'
17:35:30 <lambdabot> Not in scope: type variable `you'
17:35:30 <lambdabot> Not in scope: type variable `what'
17:35:33 <Veinor> ...
17:35:41 <Veinor> hush, you.
17:35:54 <Veinor> yeah, but I mean, the way I think of kinds is, [] takes a type and returns a type
17:35:56 <tensorpudding> :k Monad
17:35:57 <lambdabot> Class `Monad' used as a type
17:36:01 <tensorpudding> err, right
17:36:07 <Veinor> :k ->
17:36:08 <lambdabot> parse error on input `->'
17:36:12 <tensorpudding> :k (->)
17:36:13 <lambdabot> ?? -> ? -> *
17:36:18 <Veinor> yes, that's what I meant
17:36:23 <Veinor> ok, now what does that mean? :P
17:36:26 <skorpan> HaskellLove: e.g. if i have "f x = something with x" i can not assign a new value to "x", as you can in impure languages.  x is just a placeholder for whatever argument the function received to begin with.  like in digital circuits, i suppose.
17:36:30 <tensorpudding> :k (,)
17:36:31 <lambdabot> * -> * -> *
17:36:47 <Veinor> maybe I should look up what kinds really are
17:37:00 <HaskellLove> skorpan got it, combinational vs sequental logic is like functional vs imperative languages...
17:37:07 <skorpan> HaskellLove: yeah, something like that
17:37:22 <skorpan> HaskellLove: of course, there are impure functional languages as well, so fp doesn't necessarily mean pure
17:37:55 <HaskellLove> skorpan impure language would be a combination of combination and sequential logic
17:38:05 <skorpan> a functional language to me is one that allows me to send functions to other functions which may in turn return a new function
17:38:17 <tensorpudding> functional programming doesn't have a strict universal definition
17:38:24 <tensorpudding> most people use it to mean first-class functions
17:38:24 <skorpan> these functions are known as "higher-order functions"
17:38:34 <tensorpudding> or higher-order functions
17:39:00 <tensorpudding> but there are languages that aren't considered functional which have them
17:39:26 <skorpan> tensorpudding: what languages?
17:39:32 <Veinor> I don't ever want to live in a language without first-class everything again
17:39:42 <Twey> Haskell doesn't have first-class modules!  :Ã¾
17:39:45 <kmc> someone want an explanation of the crazy kind of (->)?
17:39:48 <Veinor> Pfft :P
17:39:50 <j4cbo> skorpan: Javascript, perhaps?
17:39:54 <Veinor> close enough!
17:39:59 <skorpan> j4cbo: i regard javascript as functional
17:40:00 <j4cbo> it has first-class functions, but most people wouldn't consider it functional
17:40:02 <Kim^Walkman> skorpan: PHP has it too
17:40:04 <Twey> Javascript is considered functional by everyone who matters
17:40:13 <Twey> Kim^Walkman: Arguably
17:40:16 <j4cbo> Python is a better example
17:40:25 <skorpan> i regard python as functional as well...
17:40:30 <Kim^Walkman> You can pass functions as arguments and call those functions, and it does have closures now
17:40:31 <kmc> tensorpudding, i consider every language with first-class functions to be "functional".  because the other definitions are too fuzzy
17:40:33 <skorpan> it has map, reduce and lambda :)
17:40:37 <Veinor> strictly speaking, haskell doesn't have first-class types
17:40:37 <kmc> "functional style" != "functional language"
17:40:41 <j4cbo> yeah
17:40:49 <kmc> lambda is not an issue.  lambda is merely the literal syntax for function values
17:40:52 <skorpan> kmc: what's the difference?
17:40:58 <j4cbo> you can write code that would be considered functional in python, but you're encouraged not to.
17:41:00 <skorpan> between style and language
17:41:03 <kmc> you can have integers without allowing integer literals
17:41:08 <tensorpudding> was thinking of that article on C being a functional language
17:41:19 <kmc> skorpan, an individual piece of code can be subjectively said to have functional style
17:41:27 <kmc> a language can be (mostly) objectively said to be a functional language
17:41:35 <kmc> whether or not people tend to write "functional style" code using it
17:41:43 * j4cbo only thinks of the MLs and Haskell when people say "functional language"
17:41:48 <skorpan> would you say that e.g. common lisp is functional?
17:41:55 <tensorpudding> Scheme is functional
17:41:59 <kmc> j4cbo, then you are probably conflating the unrelated concepts of "functional" and "statically typed"
17:42:06 <tensorpudding> but it's also dynamically typed
17:42:07 <j4cbo> oh, i guess lisp/scheme too
17:42:28 <j4cbo> kmc: not really
17:42:36 <kmc> anyway there is no excuse for a general purpose language to lack first-class functions
17:42:40 <j4cbo> kmc: you're conflating "statically typed" with "having an expressive type system" :P
17:42:42 <sshc> Hi, can anybody point me to a beginner tutorial or guide or reference to the State monad?
17:43:08 <kmc> the real error is that people think the opposite of "functional language" is "imperative language"
17:43:08 <skorpan> j4cbo: lisp and scheme are in my opinion no more functional than python.  the terse syntax of the lisps may lead one to believe so, but i don't think syntax is that important.
17:43:20 <skorpan> common lisp*
17:43:25 <tensorpudding> Lazy K is the quintessence of functional programming languages
17:43:28 <kmc> and that people think that lacking first-class functions is a matter of style or design philosophy rather than simply a defect
17:43:33 <kmc> tensorpudding, yes
17:43:34 <kmc> !
17:44:01 <tensorpudding> though it's lazy, which seems to be less common in functional languages
17:44:11 <kmc> imperative programming is a legitimate style and "paradigm", but to do it right you absolutely need first-class functions
17:44:28 <kmc> same with OO
17:44:34 <kmc> end rant, will return later
17:45:13 <halberd> lisp is actually pretty verbose
17:45:35 <skorpan> you think?
17:45:46 <j4cbo> i wish SML had typeclasses :/
17:45:59 <halberd> I've written a bunch of it
17:46:29 <halberd> the identifiers are long and all the parens add a lot of characters
17:46:39 <tensorpudding> lazy K is garbage-collected, referentially-transparent, lazy and functional, and has almost no other features
17:46:40 <kmc> sshc, i liked "All About Monads" though people here have found a few errors
17:46:41 * increpare just discovered hs-boot files there.  Finds them a little unnerving...wonders if there's another way to deal with circular dependencies in modules...
17:47:01 <kmc> sshc, the important thing to realize is that State computations are just sugar for ordinary functions:
17:47:04 <kmc> @unmtl State s a
17:47:04 <lambdabot> s -> (a, s)
17:47:42 <kmc> you can read the Monad instance for State here:  http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
17:47:56 <kmc> it's only 5 lines
17:48:20 <kmc> and the useful operations are here: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/mtl/Control-Monad-State-Class.html
17:49:18 <halberd> it is possible to make a program that is asymptotically optimal for any problem such that the worst case runtime of the asymptotically optimal solution can be found
17:49:34 <kmc> what
17:50:28 <halberd> the program should run two threads, one of the threads solves the actual problem using the best method yet known, and the other thread searches for a solution that it can prove is correct and asymptotically faster
17:50:41 <eu-prleu-peupeu1> i feel that haskell is never going to become mainstream
17:50:51 <halberd> er, the other thread searches for an algorithm that it can prove is correct and asymptotically faster
17:50:53 <sshc> eu-prleu-peupeu1: what makes you think that?
17:51:05 <eu-prleu-peupeu1> its too hard and different
17:51:07 <skorpan> haskell is already mainstream. haskell is experiencing the same thing now that ruby experienced a couple of years ago.
17:51:21 <skorpan> haskell is all the rage!
17:51:23 <eu-prleu-peupeu1> skorpan: which is ?
17:51:26 <pikhq> Except that Haskell doesn't suck.
17:51:29 <j4cbo> oh god
17:51:31 <skorpan> ruby doesn't suck
17:51:32 <halberd> so if there is an asymptotically fastest solution whose worst case runtime can be proved, the program will eventually find it and start using it
17:51:34 <tensorpudding> except Haskell doesn't have a killer-app
17:51:36 <j4cbo> i seriously hope haskell doesn't have that
17:51:40 <skorpan> tensorpudding: xmonad of course
17:51:47 <tensorpudding> ruby got popular mostly due to rails, i thought
17:51:49 <halberd> the program will find the asymptotically fastest algorithm in a constant time, albeit very long time
17:51:57 <pikhq> tensorpudding: Parsec?
17:52:01 <eu-prleu-peupeu1> :)
17:52:05 <ivanm> skorpan: and pandoc is reasonably popular as well
17:52:16 <pikhq> It *is* lightyears ahead of the competition.
17:52:28 <ivanm> @slap pikhq
17:52:28 * lambdabot karate-chops pikhq into two equally sized halves
17:52:47 <skorpan> ivanm: cool, i was looking for something like that to use with my web app just an hour ago...!
17:53:20 <sshc> if a function is of type a -> b, can a function be passed as the first argument (a)?
17:53:23 <ivanm> skorpan: what, pandoc?
17:53:34 <skorpan> ivanm: something which can write both markdown and reSt, specifically
17:53:36 <sshc> or even a function that returns a function? (a -> a -> a)
17:53:53 <ivanm> there's gitit, which is a (git/darcs/mercurial) backed wiki using pandoc for markup -> html as well
17:53:58 <tensorpudding> sshc: yes
17:54:04 <sshc> if "foo :: a -> b" could I use "foo (+) 3"?
17:54:04 <skorpan> never heard of pandoc 'til now
17:54:11 <sshc> tensorpudding: ok, thanks
17:54:11 <pikhq> sshc: Yes. A function is a type.
17:54:26 <ivanm> preflex: seen malcolmw
17:54:27 <preflex>  malcolmw was last seen on #ghc 2 days, 9 hours, 51 minutes and 21 seconds ago, saying: Igloo:  I was hoping for something that would only take a few minutes :-)
17:54:27 <tensorpudding> a matches any type
17:54:27 <pikhq> However, I would like to note that "a -> b" is one of the most evil type signatures written.
17:54:30 <pikhq> sshc: Yes.
17:54:33 <tensorpudding> unless there is a specific kind restriction
17:54:41 <pikhq> sshc: Well, so long as "b" is a function. ;)
17:54:52 <tensorpudding> @type const
17:54:54 <lambdabot> forall a b. a -> b -> a
17:54:59 <sioraiocht> sshc: good luck finding a function that satifies a -> b ;)
17:55:02 <sshc> pikhq: could I limit "a" to require a function?
17:55:02 <Cale> tensorpudding: Well, it can't have any other kind here, unless you start talking about unboxed kinds
17:55:18 <sshc> sioraiocht: undefined
17:55:22 <tensorpudding> @type const (+5) 3
17:55:23 <lambdabot> forall a. (Num a) => a -> a
17:55:27 <pikhq> sshc: Much much much harder, unless you want it to be a specific sort of function.
17:55:31 <sioraiocht> :t undefined
17:55:33 <lambdabot> forall a. a
17:55:36 <pikhq> (say, a function of some number of arguments)
17:55:41 <sioraiocht> that's not forall a b. a -> b
17:55:59 <harrisonpartch> i wonder about parallel haskell and manticore
17:56:04 <pikhq> @hoogle a -> b
17:56:05 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:56:05 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:56:05 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:56:08 <tensorpudding> there can't be any interesting functions of type a -> b
17:56:10 <harrisonpartch> i have a killer app in mind
17:56:11 <Cale> :t undefined :: a -> b
17:56:12 <lambdabot> forall a b. a -> b
17:56:15 <tensorpudding> that don't break things
17:56:17 <Cale> :t const undefined :: a -> b
17:56:18 <lambdabot> forall a b. a -> b
17:56:22 <sioraiocht> Cale: touchÃ©
17:57:01 <Cale> Scary thing: const undefined and undefined are semantically different in Haskell
17:57:10 <tensorpudding> hmm, const undefined is one
17:57:12 <sshc> :t unsafeCoerse
17:57:13 <lambdabot> Not in scope: `unsafeCoerse'
17:57:15 <Cale> > const undefined `seq` 5
17:57:16 <lambdabot>   5
17:57:19 <Cale> > undefined `seq` 5
17:57:20 <lambdabot>   * Exception: Prelude.undefined
17:57:22 <sshc> :t unsafeCoerce
17:57:24 <lambdabot> Not in scope: `unsafeCoerce'
17:57:35 <pikhq> :t Unsafe.Coerce.unsafeCoerce
17:57:36 <tensorpudding> how does unsafeCoerce work?
17:57:42 <sioraiocht> tensorpudding: it breaks the type system =p
17:57:45 <pikhq> tensorpudding: unsafePerformIO
17:57:51 <lambdabot> forall a b. a -> b
17:57:54 <pikhq> (IIRC)
17:58:14 <tensorpudding> sounds unsafe
17:58:16 <pikhq> Either that, or it's just something in GHC that smashes the type system to pieces.
17:58:18 <Cale> pikhq: You can write an unsafeCoerce with unsafePerformIO and a polymorphic IORef, but that's not how it actually works
17:58:19 <sshc> > Unsafe.Coerce.unsafeCoerce ([3]++)  :: Int
17:58:20 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
17:58:43 <tensorpudding> i heard that lambdabot was not able to do unsafePerformIO
17:58:44 <Cale> Obviously, it's not available in the bot.
17:58:47 <pikhq> Cale: So, it's just something in GHC that smashes the type system to pieces. Got it.
17:59:01 <pikhq> tensorpudding: unsafePerformIO would be... Unsafe.
17:59:02 <tensorpudding> but i wonder why it exists
17:59:02 <Cale> tensorpudding: Right, that would also be a stupid thing to have imported :)
17:59:20 <pikhq> So that you can smash the type system to pieces, I presume.
17:59:22 <Cale> tensorpudding: unsafePerformIO is for times where you'd otherwise be forced to modify the compiler
17:59:36 <tensorpudding> how do you get in a situation like that
18:00:10 <Cale> tensorpudding: Let's suppose you want to add a new low-level datastructure to Haskell, or a new evaluation mechanism.
18:00:32 <Paczesiowa> I'd like unsafeTypeIO that would work during typechecking, it would get the whole type context and return some type
18:00:53 <Paczesiowa> Cale: stick it in IO
18:00:53 <sshc> I never knew ([3]++) == 16777480
18:00:57 <pikhq> Paczesiowa: Sounds like that belongs in Template Haskell.
18:01:02 <tensorpudding> hmm, so you're doing crazy stuff
18:01:13 <Cale> Paczesiowa: You could do that, but it's a shame if it's actually a datastructure with pure semantics.
18:02:12 <Cale> Like, for example, the ByteString library uses unsafePerformIO to access chunks of memory directly, but the end result is a pure interface.
18:02:53 <Paczesiowa> sure it's pure - you just have to trust us!
18:05:11 <Paczesiowa> pikhq: doesn't TH say "our type system is too weak to express that"?
18:05:13 <Cale> Well, you have to trust the GHC guys too.
18:05:31 <Cale> So, this is why I say, you use unsafePerformIO whenever you'd otherwise modify the compiler.
18:07:12 <Paczesiowa> Cale: to use modified compiler I have to download/compile it. to use unsafePerformIO I have to.. I don't have to do anything - I can't do anything. it should require language extension
18:08:15 <Cale> Paczesiowa: Well, you either have to use it explicitly, or use a library which uses it
18:08:43 <Paczesiowa> Cale: that's right, I have no idea if library uses it.
18:09:10 <Cale> I agree that there ought to be some sort of unsafety tracking, with of course a way to override it when you know that you've written a library which is safe.
18:09:20 <gwern> old request
18:09:34 <gwern> isn't there a years old bug for safety tainting?
18:09:45 <Paczesiowa> Cale: "when you know"...
18:09:55 * gwern incidentally was surprised to see how little a difference there was between haskell isSpace versions and C isspace
18:10:12 <Cale> Paczesiowa: Often it's easy to see that you've constructed something which is actually pure.
18:10:43 <Paczesiowa> Cale: make it pure then!
18:10:49 <Cale> Paczesiowa: Like, I wouldn't like to be hassled over using ByteString, because I trust ByteString to not break the pure semantics.
18:11:25 <gwern> Cale: could there be some sort of ST-alike for bytestring?
18:11:59 <sshc> is it just me, or has Hoogle not been working for anybody else for a few... months or so?
18:13:20 <gwern> ever since ghc released and broked hyperlinks
18:13:32 <gwern> it worked fine before
18:15:17 <ivanm> @hoogle a -> [a] -> a
18:15:17 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
18:15:17 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
18:15:17 <lambdabot> Prelude asTypeOf :: a -> a -> a
18:15:26 <ivanm> what do you mean? hoogle seems to be working fine!
18:17:11 <Paczesiowa> :i (~)
18:19:31 <ivanm> Paczesiowa: lambdabot doesn't recognise :i
18:19:35 <ivanm> :k Maybe
18:19:36 <lambdabot> * -> *
18:19:43 <ivanm> :t Just
18:19:44 <lambdabot> forall a. a -> Maybe a
18:19:54 <Paczesiowa> @info (~)
18:19:55 <lambdabot>  Parse error at ")" (column 3)
18:19:55 <ivanm> ^^ AFAIK, they're the only two :_ commands lambdabot knows
18:20:07 <ivanm> Paczesiowa: ~ is an irrefutable pattern
18:20:10 <ivanm> @src partition
18:20:10 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:20:10 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:20:10 <lambdabot>                               | otherwise = (ts, x:fs)
18:20:18 <ivanm> @google haskell irrefutable pattern
18:20:19 <lambdabot> http://www.haskell.org/tutorial/patterns.html
18:20:19 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
18:20:21 <Paczesiowa> ivanm: I mean eq constraint
18:20:31 <ivanm> hmmm?
18:20:35 <ivanm> (Eq a) => ...
18:20:50 <ketil> Good evening/morning!  My program spends all its time collecting garbage.  Is there any good way to debug and/or remedy this?
18:20:51 <Paczesiowa> (a ~ b ) => a -> b -> ()
18:21:02 <ketil> (well, not all, but ... 80% maybe?)
18:21:04 <ivanm> take it back, it's a lazy pattern
18:21:13 <ivanm> ketil: you're compiling with -O2 ?
18:21:24 <ivanm> ketil: IIRC, RWH's profiling chapter deals with too much GC
18:21:32 <ivanm> Paczesiowa: never seen that before...
18:21:39 <ivanm> where's that from? you sure it's Haskell?
18:21:45 <Paczesiowa> ivanm: type family stuff I think
18:21:50 <ivanm> ahhh, could be
18:22:16 <ivanm> @google haskell tilda type
18:22:16 <lambdabot> No Result Found.
18:22:19 <ivanm> @google haskell tilda
18:22:20 <lambdabot> http://womenandhollywood.com/2009/03/02/molly-haskells-feminist-take-on-gone-with-the-wind/
18:22:21 <lambdabot> Title: Molly Haskellâs Feminist Take on Gone with the Wind | Women & Hollywood
18:22:27 <ivanm> I don't think that's what we want ;-)
18:22:30 <ivanm> @google haskell tilda family
18:22:31 <lambdabot> No Result Found.
18:22:33 <ivanm> bah
18:22:53 <ketil> ivanm, yes, -O2.  RWH - damn, I just left my copy at work...oh, wait, it's online?
18:22:56 <kmc> we talkin 'bout ~(irrefutable patterns)?
18:22:58 * ketil runs off to check.
18:22:59 <Paczesiowa> I just wonder if (~) is built-in or implemented with families
18:23:08 <ivanm> ketil: yup
18:23:09 <kmc> oh, no, the other thing
18:23:29 <ivanm> Paczesiowa: I wildly guess built in rather than implemented
18:23:32 <kmc> (~) would be a class, not a family, right?
18:23:38 <kmc> since it appears in contexts
18:23:47 <Paczesiowa> if it's built-in, it's funny that TypeEq is more powerful
18:23:48 <kmc> class (~) a b where { }; instance (~) a a where { }
18:23:54 <kmc> how is TypeEq more powerful?
18:24:29 <ivanm> oh, could be
18:24:32 <Paczesiowa> kmc: TypeEq can "fail" with TypeEq a b HFalse and you can recover from it/ dispatch on it
18:24:32 <ivanm> duh, didn't think of that
18:24:45 <kmc> ah
18:24:50 <kmc> well, it's more powerful and more complicated
18:24:55 <kmc> makes sense to build it out of simpler built-in things
18:24:58 <ivanm> kmc: so where is that class from?
18:25:09 <kmc> ivanm, i don't think it's actually defined that way
18:25:29 <Paczesiowa> kmc: also, incoherent TypeEq is very powerful - it matches only ground types, or ungrounded but really equal
18:25:36 <kmc> another fun thing: data Eq a b where { Refl :: Eq a a }
18:25:45 <kmc> what makes a type grounded?
18:25:51 <Paczesiowa> kmc: no foralls
18:26:00 <kmc> grounded means "rank-0" then?
18:26:09 <ivanm> kmc: a copper bar going down into the ground I think...
18:26:10 <ivanm> ;-)
18:26:12 <kmc> but... it's not the same as "monomorphic"?
18:26:17 <kmc> can it have free type variables?
18:26:40 <Paczesiowa> kmc: I think it's the same, but oleg calls them "ground" instead of monomorphic
18:26:45 <kmc> okay
18:26:48 <ketil> Hmm ... let's see if +RTS -S tells me more than -s
18:27:47 <Paczesiowa> what I really need right now is class that could decide (with HTrue/HFalse) iff TypeCast a b would succeed
18:28:13 <BMeph> @google haskell tilde
18:28:14 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Laziness
18:28:24 <kmc> instance (TypeCast a b) => CanCast a b HTrue; instance CanCast a b HFalse
18:28:27 <kmc> that doesn't work?
18:28:58 <ivanm> bah, I can't believe I'm so stupid... with my parsing, I decided to abstract explicitly parsing for braces around an item by writing a function that parsed the opening brace, used the supplied parser and then parsed the closing brace
18:29:03 <Paczesiowa> kmc: there should be fundep for result
18:29:09 <kmc> hmm yes
18:29:14 <ivanm> thing is, my code decided not to parse anything... because I forgot to use that function! :s
18:29:24 <gwern> ivanm: I have an enterprise position for you...
18:29:30 <ivanm> heh
18:29:35 <ivanm> gwern: I'm parsing Dot code
18:29:35 <ketil> Looking at the GHC docs, I notice there are RTS options like -A, -c etc.  Any hint what would help, or should I just experiement?
18:29:42 <ivanm> so I _have_ to do stuff with braces
18:29:56 <gwern> ketil: incidentally, you know your suggested optimization for Data.Char.isSpace had a bug?
18:30:01 <ivanm> ketil: I have no idea sorry :(
18:30:04 <Paczesiowa> ketil: profile your code and check what exactly what produces so much garbage
18:30:15 <gwern> ketil: \b doesn't count as whitespace :)
18:30:40 <ivanm> preflex: seen Cale
18:30:40 <preflex>  Cale was last seen on #haskell 19 minutes and 50 seconds ago, saying: Paczesiowa: Like, I wouldn't like to be hassled over using ByteString, because I trust ByteString to not break the pure semantics.
18:30:54 <Cale> ã«ããï¼
18:31:03 <gwern> ketil: no need to thank me, thank quickcheck!
18:31:31 <ivanm> Cale: did you keep a copy of the latest we did on that generic graph thingy?  I can't seem to find it anywhere :s
18:32:16 <Cale> hmm
18:32:55 <Cale> I think that was it
18:33:08 <ivanm> grrr....
18:33:17 <Cale> Missing stuff?
18:36:11 <ketil> gwern, huh?  Is this old stuff?
18:37:19 <ketil> \b as in backspace?
18:38:13 <ivanm> yup
18:38:50 <ivanm> gwern: for graphviz, I"ve had to resort to my own custom String Gen instance since too many cases were failing due to unrealistic dodgy strings that QC generated :s
18:44:00 <ketil> Okay.  I ran with +RTS -c -G3 -A16M, and that seems to reduce the GC time to about 50%...
18:45:48 <Paczesiowa> ketil: stop producing so much garbage:)
18:48:00 <ketil> Paczesiowa, and how do I tell what is producing the garbage?
18:48:15 <Paczesiowa> ketil: profile and check for memory allocation
18:52:24 <ketil> Paczesiowa, good point!  I'll take a peek.
18:53:06 <gwern> ketil: yes, old space, from a year or two ago
18:53:42 <gwern> ivanm: shouldn't your code be able to handle dodgy cases? if it can't handle random srings then that's a security issue, or at least, a reliability issue
18:54:21 <ivanm> gwern: there are a lot of cases where users are told not to use certain characters, because in Dot they are separators for that particular Attribute
18:55:33 <ivanm> it was pissing me off having to take every single individual one of these into account when defining each individual Arbitrary instance, so I just made a arbString :: Gen String function that only generates alphanumeric characters + some symbols
18:55:53 <ivanm> (basically, there were too many special cases and I was sick of pandering to them)
18:56:49 <Berengal> Special cases call for special case constructs...
18:57:39 <ketil> while I'm waiting for profiling to finish....looks like the -A option does the trick: the higher, the less time spent in GC
18:58:47 <Paczesiowa> ketil: well, if you have unlimited memory, you don't have to collect garbage:)
18:58:54 <ivanm> Berengal: what do you mean by that?
18:59:41 <Berengal> ivanm: Not much. Just that special cases are sometimes just ASTs waiting to be defined...
18:59:51 <Berengal> ivanm: I have no idea what the context is in this case
19:00:25 <ivanm> in Dot, a lot of attributes use seperator characters in Strings to efine lists, etc. (and they're different each time)
19:00:47 <ivanm> so I couldn't be bothered special casing the Arbitrary instances when doing QC tests
19:00:48 <Berengal> What's Dot?
19:00:55 <ivanm> for graphviz
19:00:57 <ivanm> graphviz.org
19:00:58 <Berengal> Ah
19:01:07 <Berengal> Yeah, that's true...
19:12:21 <kmc> garbage collection is premature optimization :)
19:13:21 <pikhq> Turing completeness is premature optimization.
19:13:45 <papermachine> Turing completeness isn't just convenient -- it's the law!
19:14:12 <Berengal> Turing completeness is overrated
19:14:17 <kmc> it's *so* not convenient
19:14:32 <kmc> it's convenient as long as you don't care what your programs do
19:14:50 <Berengal> It's convenient if you want infinite loops
19:16:00 <kmc> oh yes gotta have those
19:16:04 <j4cbo> it's convenient if you have extra reels of paper tape of unbounded length sitting around.
19:16:20 <kmc> all you have to do is order more when you run out
19:16:57 <kmc> and pause the computation until it arrives
19:17:12 <Niccus> are all real computers technically not turing-complete since the universe is finite?
19:17:30 <kmc> we don't like to talk about that ;)
19:17:48 <ketil> well - we need at least one turing complete language, in which to write interpreters for all the others, don't we?
19:17:53 <Berengal> It'd be awesome if they found out the universe is really infinite in the limit, and thus truly turing complete
19:18:06 <kmc> also that's not so clear -- in a naive model of classical or quantum physics, the universe has an uncountable infinite number of states even though it contains a finite number of things in a finite volume
19:18:39 <j4cbo> in any case, the thing on your desk that you're pressing buttons on is actually a really big FSM.
19:18:49 <kmc> yeah
19:18:53 * kmc doesn't own a desk
19:19:02 <Berengal> Mine's pretty small, about 13''
19:19:12 <Niccus> mine seems to be dying
19:19:17 <j4cbo> but how many states does it have? :P
19:21:14 <Niccus> are there some wild theoretical constructs for fractional or negative states
19:21:58 * ketil was trying to calculate the number of dimensions of knowledge the other day.
19:22:51 <ketil> Based on the camp fire metaphor - the more you light up, the more darkness is on your perimeter.  I.e. the more you know, the more of the unknown you discover.
19:23:29 <ketil> Since the ratio of perimeter to volume depends on the number of dimensions, this just boils down to the number of questions compared to the number of answers.
19:24:04 <byorgey> I think the space of knowledge is also hyperbolic
19:24:07 <Gracenotes> alternately, you can continually wonder around with a candle and see a wide variety of stuff, but not in any depth.
19:24:31 <Berengal> The camp fire metaphor breaks down if you set fire to everything...
19:24:38 <tensorpudding> if you think of knowledge as a region K in R^3, the greater the volume of K, the greater the area of dK
19:27:50 <Gracenotes> let's not think of knowledge too much. or else we might discover epistemology.
19:28:04 <Gracenotes> and then it's down the rabbit hole with that
19:28:46 <ketil> My program is almost finished, after 100 hours.  It's getting late, but perhaps I should stay up just to see it cross the finishing line?
19:29:42 <mattam> There's a very nice article somewhere about how any interesting algorithm implemented by a turing machine can be implemented in a non-turing complete language with only a constant factor efficiency penalty. Basically you add a counter to the program and you're recursive on it. There's a rather big lower bound on what the number should be but it works in theory.
19:31:10 <Berengal> mattam: That's a common technique in non-turing complete languages such as Agda. You provide a proof of termination to an otherwise partial function, and recurse on the proof
19:31:37 <eldragon> can you terminate the intensive neuron training?
19:32:27 <mattam> Berengal: I know. But it's usually not considered that way from the point of view of computation theory.
19:32:56 <Veinor> non-turing-complete languages? O_o
19:33:42 <Berengal> Veinor: They're great fun!
19:33:43 <eldragon> how efficient is GHC for intensive neuron training?
19:34:00 <eldragon> with these tons of doubles
19:34:00 <pikhq> Veinor: Plenty exist.
19:34:03 <kmc> Veinor, in Agda, you can express *any* property of your function in its type
19:34:05 <pikhq> For example, C.
19:34:29 <Berengal> kmc: The problem is often expressing it in the value ;)
19:34:33 <mattam> Here "interesting" means that the running time can be succintely expressed by a terminating function. It's basically saying that you can build a well-foundedness proof I guess.
19:34:33 <Veinor> pikhq: I was about to ask 'how?' then I realized that there's probably some technicality that says that you can only have finite state :P
19:34:49 <kmc> and for the proofs of those properties (i.e., terms with the appropriate proof-type) to be trustworthy, we need to know that evaluation will terminate
19:35:05 <kmc> Veinor, a simple example of an interesting non-Turing-complete language is the simply-typed lambda calculus
19:35:27 <pikhq> Veinor: char is required to be a natural, and CHAR_MAX must be storable within a char.
19:35:36 <pikhq> Thus, char must be finite.
19:35:37 <kmc> you can prove that it is strongly normalizing, meaning that *any* sequence of evaluation steps will eventually reach a term that will not evaluate further, and always the same one regardless of the steps you take
19:35:42 <pikhq> Therefore, all other types must be finite.
19:35:42 <Veinor> pikhq: it's a good thing C has other data types then :D
19:35:46 <mattam> Veinor: you can have non-terminating functions, but then they must be productive instead and expressed as generators from which you get the next value.
19:36:15 <pikhq> Veinor: The other types are allowed to be the size of a finite number of chars.
19:36:36 <kmc> pikhq, but malloc is in the standard library
19:36:38 <Veinor> what about a struct largenumber that points to other largenumbers?
19:36:54 <pikhq> kmc: And returns a pointer to a location in finite memory.
19:37:01 <kmc> ah, a pointer of finite size
19:37:07 <pikhq> Veinor: The pointer must be in finite memory.
19:37:07 <Veinor> ahh.
19:37:45 <kmc> file I/O is also in the standard library
19:38:09 <pikhq> And that deals with files of a finite size. And file names of a finite length.
19:38:29 <Veinor> well, by that approach no language is turing complete :P
19:38:33 <kmc> is there a maximum file name length in the spec?
19:38:35 <mattam> Veinor: in the end everything is represented finitely anyway :) But you can model infinite structures in these languages too, like streams.
19:38:39 <pikhq> Veinor: C requires it.
19:38:46 <pikhq> kmc: No, but file names must be valid strings.
19:38:52 <pikhq> Meaning that they must be finite.
19:39:05 <kmc> pikhq, so, an OS can easily provide a file which acts as an unbounded size memory
19:39:15 <pikhq> (since strings are finite pointers to a finite number of chars)
19:39:23 <pikhq> kmc: No, file sizes are required to be finite.
19:39:34 <kmc> pikhq, you mean they have a fixed bound?
19:39:40 <kmc> (because Turing machine tapes are all finite as well)
19:39:53 <QtPlaty[HireMe]> pikhq: What about /dev/ 's ?
19:40:06 <pikhq> QtPlaty[HireMe]: Not ISO C. ;)
19:40:12 <kmc> the OS can provide a file with a very small maximum size that still provides unbounded storage
19:40:15 <kmc> but yes, not ISO C
19:40:24 <pikhq> POSIX extends C to be at least possibly Turing complete.
19:40:47 <QtPlaty[HireMe]> /dev/random is infintitely long
19:40:49 <mattam> kmc: not in the model right, they're infinite on both sides.
19:41:08 <kmc> mattam, at every point in time, the non-blank characters form a finite string
19:41:31 <kmc> it is a fine definition to say that a Turing machine tape is finite at all times, but can grow without bound
19:41:43 <kmc> this is equivalent to an infinite tape that starts out empty
19:41:44 <mattam> I see.
19:42:09 <kmc> and it's critical at many points in theory of computation that every state of a Turing machine be representable by a finite string
19:42:19 <pikhq> Hmm. Nothing *requiring* a file to be finite.
19:42:29 <QtPlaty[HireMe]> A Terminiating program will only use a finite amount of tape.
19:42:38 <pikhq> And bounded.
19:42:53 <pikhq> Only thing in C without a bound.
19:43:45 <Berengal> What, tape?
19:44:28 <mattam> But not a non-terminating one? Does that mean some equivalence proofs rely on the termination of the algorithms/the finiteness of the tape?
19:44:59 <pikhq> mattam: The tape will always be finite at any point in time.
19:45:17 <pikhq> Because the execution cannot have occured for an infinite amount of time yet.
19:45:18 <kmc> mattam, the problem is that non-terminating machines can run forever and expand the tape infinitely many times
19:45:34 <mattam> I'm more used to the formal def where we start with a finite number of states.
19:46:20 <pikhq> There exists a mapping between the steps of execution of a non-terminating Turing machine and the naturals.
19:46:40 <Veinor> really? :O
19:47:16 <pikhq> Veinor: ... Yes... It's even a trivial mapping.
19:47:20 <mattam> pikhq: I agree.
19:47:20 <kmc> of course.  you can talk about "the nth step" of the machine
19:47:41 <kmc> supposing you've fixed a machine description and the input
19:47:42 <Veinor> yes, that was a sarcastic "really? :O"
19:47:47 <kmc> ah ;P
19:47:50 <pikhq> Okay.
19:48:02 <medfly> denial
19:48:04 <Veinor> next you'll be telling me the finite cardinals and ordinals have the same cardinality!
19:48:19 <medfly> really? :O
19:48:29 <mattam> But the naturals is not a finite set.
19:48:30 <QtPlaty[HireMe]> Does it make sence to take the limit of turing states?
19:48:46 <kmc> not to me, unless you specify further what you mean
19:49:30 <QtPlaty[HireMe]> Good point.
19:49:56 <kmc> typically we use Turing machines to decide sets of finite strings
19:50:07 <kmc> (all the interesting ones are infinite sets of finite strings)
19:50:46 <kmc> i believe you can extend the definition to include accepting an infinite string, as with Büchi automata
19:55:41 <mattam> The key point in the formal def of a turing machine is that the blank character is the only one to appear infinitely. If you allow the alphabet characters to be repeated infinitely too I don't see how you say that the "tape is always finite".
19:56:16 <kmc> mattam, you mean in the extension i just mentioned?
19:56:42 <mattam> I mean if I take the definition on Wikipedia
19:58:42 <mattam> You didn't provide the extension, just said you believed it was possible to accept infinite strings (which is probably not decidable so accept seem weird to me here)
19:59:14 <kmc> not with a regular Turing machine
19:59:39 <kmc> i'm saying one could define a similar thing which accepts some infinite strings, much like one extends finite state automata to Büchi automata
20:00:01 <kmc> i am sure this thing has been thought of and studied (and maybe discarded as useless); I don't know the name
20:01:02 <mattam> Quite possibly :)
20:02:05 <monochrom> I know BÃ¼chi acceptance. I believe Turing machine with BÃ¼chi acceptance hasn't been studied.
20:02:41 <kmc> the problem is, just to tell if the machine accepts a string you have to write a proof
20:03:33 <Berengal> To accept an infinite string, it can't look at the whole string, so the accepting string can be reduced to a finite one without altering the computation in any way
20:04:20 <kmc> Berengal, the definition is that it accepts the infinite string if it enters an accept state 'infinitely often'
20:04:35 <kmc> meaning that at each point in time, it will enter an accept state sometime in the future
20:04:41 <kmc> mmm temporal logic :)
20:05:03 <kmc> always (eventually is-in-accept-state)
20:06:16 <Berengal> kmc: Can we write such a machine?
20:06:18 <_nickel> google has failed me :( how can I round down ?
20:06:24 <kmc> > floor 3.4
20:06:25 <lambdabot>   3
20:06:35 <_nickel> kmc: thank you
20:06:50 <kmc> _nickel, you may need to convert the type back with fromIntegral
20:06:51 <kmc> :t floro
20:06:52 <lambdabot> Not in scope: `floro'
20:06:53 <kmc> :t floor
20:06:54 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:06:55 <kmc> :t fromIntegral
20:06:56 <lambdabot> forall a b. (Integral a, Num b) => a -> b
20:07:11 <kmc> Berengal, what do you mean?
20:07:47 <_nickel> kmc: I'll make a note, thank you again :D
20:08:09 <Berengal> kmc: I just want a construction of a machine that accepts some infinite string. It would be interesting
20:08:30 <kmc> well, take a look at Büchi automata
20:11:10 <solidsnack> The GHC "API" is pretty horrible.
20:11:35 <solidsnack> Trying to from String to located defs -- OMGWTFBBQ.
20:12:15 <solidsnack> I hate to do it by I'm going to write my own parser.
20:12:22 <solidsnack> God help me.
20:12:59 <kmc> there's haskell-src-exts
20:13:17 <kmc> there's also scion
20:14:40 <monochrom> The point of BÃ¼chi automaton is not to execute it! You analyse it and find "it accepts nothing" or "it accepts something". I expect Turing machine with BÃ¼chi acceptance is similar - the point is not to execute it.
20:15:29 <medfly> how did this go from "take a look at buchi automata" to monochrom getting upset and seeming to argue about something :)
20:15:33 <kmc> however you can discover the emptiness of a Büchi automaton by simple exhaustive search
20:15:48 <kmc> which is not possible for the Turing machine analogue
20:17:00 <monochrom> No, it went from "it takes forever to run" to "yes but that's not the point".
20:17:15 <solidsnack> kmc: Trying to use Scion this past day has convinced me that abstracting the GHC API is not a good idea. That API is riddled with crazy side effects.
20:18:27 <solidsnack> kmc: Thanks for pointing me to haskell-src-exts -- it seems like the right tool for what I'm trying to do.
20:39:13 <alex404> Do things in where declarations get recomputed with recursive functions?
20:40:50 <kmc> > let { x = y where { y = 1:z; z = 0:y } } in x
20:40:51 <lambdabot>   [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,...
20:41:07 <kmc> alex404, "where" bindings are recursive, if that's what you're asking
20:42:53 <alex404> kmc: I mean that if you have a recursively defined function with where bindings (which stay the same during the recursion), are they getting reevaluated?
20:44:01 <kmc> oh
20:44:37 <kmc> i'm not sure if that's defined by the spec, nor what GHC's behavior is
20:44:42 <kmc> i would lift them out to be sure, and for clarity
20:45:14 <alex404> Good point. thanks
20:47:04 <hiptobecubic> kmc, that blew my mind
20:47:13 <kmc> which?
20:47:27 <hiptobecubic> your recursive where declaration
20:47:34 <kmc> oh
20:47:36 <kmc> well let is recursive too
20:47:50 <kmc> > let x = 'a':y; y = 'b':z; z = 'c':x in x
20:47:51 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
20:47:55 <kmc> > cycle "abc"
20:47:57 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
20:48:16 <hiptobecubic> The idea of referencing undefined things is still hard for me to keep under control
20:48:30 <kmc> they're all defined
20:49:01 <hiptobecubic> kmc, yes but only when taken all together. If you want to figure out just one of them you chase your tail forever.
20:51:13 <kmc> x,y,z are the three cons pairs in a cyclic linked list
20:51:29 <kmc> lambda calculus expressions are syntax trees, and the beta-reduction evaluation rule is a transformation on trees
20:51:50 <kmc> from there you can extend to acyclic graphs (which is necessary for an efficient implementation (lazy evaluation) of non-strict semantics)
20:51:57 <kmc> and finally to cyclic graphs
20:52:29 <hiptobecubic> My education stopped at Calc II.
20:52:49 <pikhq> I was unaware that education could stop.
20:53:03 <pikhq> I thought everyone was in a constant state of learning.
20:53:09 <pikhq> (and that some people just sucked at it)
20:53:10 <eldragon> kmc, how cyclic graphs?
20:53:11 <Niccus> well you can get anterograde amnesia and get halfway there
20:53:45 <hiptobecubic> pikhq, i was using the formal definition of education.
20:54:34 <pikhq> x, y, and z are fully defined. x = 'a':y, y = 'b':z, and z='c':x. That the definitions are not expanded until you ask for it is irrelevant.
20:55:26 <sshc> who here likes C++?
20:55:33 <Niccus> define like
20:55:33 <kmc> hahahaha
20:55:40 <kmc> ahahahahaha
20:55:46 <Lycurgus> :(
20:55:54 <medfly> ?
20:56:00 <sshc> !
20:56:08 <medfly> I can guess C++ is less bad than some things that I have to do.
20:56:26 <Niccus> â½
20:56:29 <pikhq> I love a small portion of its type system. Namely, the portion that is lambda calculus.
20:56:33 <sshc> medfly: what are those things that you have to do?
20:56:34 <camio> sshc: I do, but only after using haskell for several years.
20:56:41 <medfly> web development :(
20:56:52 <Lycurgus> prolly most here would rather it than say php
20:57:03 <medfly> yes... Lycurgus ... I would
20:57:07 * medfly pretends not to have to do PHP.
20:57:08 <kmc> it very much depends on who you're working with
20:57:11 <kmc> C++ is really, really hard
20:57:15 <kmc> stupid people produce very bad C++ code
20:57:18 <Lycurgus> or VB, etc.
20:57:25 <kmc> furthermore even smart people will not agree on which subset of the language to use
20:57:32 <kmc> if you use it all, it's an unmitigated trainwreck
20:57:39 <medfly> kmc: it sounds like it leads to the same result as doing web development.
20:57:46 <pikhq> ... Using all of C++?
20:57:51 <pikhq> I don't think that's possible.
20:57:57 <pikhq> I don't think even *Boost* does that.
20:58:12 <Lycurgus> i used to feel that way about it but don't anymore, it's reasonably standardized and C is still there at it's core
20:58:14 <sshc> in particular, which parts of C++ are really all that "trainwreck"?
20:58:23 <kmc> const reference to volatile pointer to templated virtual overloaded operator
20:58:43 <camio> sshc: unions & enums
20:58:44 <kmc> sshc, http://yosefk.com/c++fqa/
20:58:48 <Lycurgus> it's a better situation than when I started my career, since which time it's replaced machine language
20:59:00 <medfly> machine language?
20:59:04 <pikhq> sshc: There's a lot of parts that are like that.
20:59:14 <pikhq> And, in fact, part of the problem is that there are a lot of parts.
20:59:43 <pikhq> I would like to note an especially egregious problem: there exists valid C++ that cannot be compiled.
20:59:50 <medfly> haha, frequently questioned answers
21:00:11 <Lycurgus> machine language, which was still fairly heavily used in ordinary business applications when I first began programming
21:00:16 <camio> pikhq: The same is true for Haskell98.
21:01:29 <pikhq> Really, the entire type system is a train wreck.
21:01:40 <sshc> would C++ (or java, though I don't know it) be a better option for something as stateful as a game?
21:01:52 <sshc> pikhq: you are referring to C++'s type system, correct?
21:01:55 <kmc> better than what?
21:01:59 <pikhq> sshc: Yes.
21:02:07 <sshc> kmc: Haskell.
21:02:12 <sshc> pikhq: Why?
21:02:13 <pikhq> Haskell's type system is, of course, the Type System.
21:02:13 <kmc> sshc, Haskell has excellent, first-class support for mutable state
21:02:33 <kmc> granted you have to learn a lot of stuff to get there
21:02:37 <sshc> pikhq: I thought you were answering my game question
21:02:43 <kmc> but it's a total myth that Haskell should not be used for imperative programming
21:02:47 <pikhq> sshc: Ah.
21:03:01 <sshc> kmc: the state monad?
21:03:12 <kmc> sshc, not really
21:03:16 <pikhq> But, yes, Haskell is good for state. Monad: The Ultimate Imperative
21:03:21 <kmc> i meant true in-place update
21:03:31 <kmc> IO, ST, STM, etc.
21:03:50 <kmc> the IO monad is a much better imperative language than most
21:04:00 <sshc> kmc: than most what?
21:04:04 <kmc> imperative languages
21:04:11 <kmc> (not all monads are about imperative programming, however)
21:04:18 <sshc> kmc: you'd rather program in the IO monad than in C?
21:04:26 <kmc> sshc, can't say without knowing the task at hand
21:04:34 <kmc> for low level systems bit-banging stuff, i'll use C
21:04:43 <kmc> for high-level imperative programming, Haskell definitely
21:04:45 <sshc> kmc: for most tasks
21:04:47 <sshc> kmc: wel actually
21:04:51 <sshc> kmc: a game
21:04:52 <pikhq> sshc: An example type (a map from string to string):
21:04:53 <pikhq> std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
21:04:54 <pikhq> std::basic_string<char, std::char_traits<char>, std::allocator<char> >,
21:04:56 <pikhq> std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>,
21:05:06 <pikhq> std::allocator<char> > const, std::basic_string<char, std::char_traits<char>,
21:05:07 <pikhq> std::allocator<char> > > > >
21:05:07 <pikhq> Sorry to flood.
21:05:09 <kmc> sshc, i think the deciding factor for a game will probably be library support
21:05:28 <sshc> kmc: which would you use for most tasks?
21:05:39 <sshc> pikhq: pfffffffffffft, taht's not flooding
21:05:45 <sshc> pikhq: takes less than a fifth of a screenful
21:06:05 <kmc> sshc, C is a low-level systems language.  it's like a portable assembler, except it lacks several key features of real assembly languages
21:06:17 <eldragon> i've heard Diesel
21:06:25 <SamB_XP_> @quote assembly
21:06:26 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
21:06:28 <SamB_XP_> @quote assembly
21:06:28 <lambdabot> qwe1234 says: never heard of malbolge before, but i'd think that writing a simple source-to-source translator from some sort of minimal vm assembly to malbolge shouldn't be too difficult.
21:06:31 <SamB_XP_> @quote assembly
21:06:32 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
21:06:43 <SamB_XP_> @quote means
21:06:44 <lambdabot> pesco says: <pesco> Heh, to deprecate means "to ward off by prayer" in its latin root. Hehe.
21:06:46 <SamB_XP_> @quote means
21:06:47 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
21:06:47 <lambdabot> just don't know what it means.
21:06:50 <kmc> urgh flood
21:06:50 <SamB_XP_> @quote means
21:06:51 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
21:06:51 <lambdabot> us until we're sure they're OK.
21:06:52 <kmc> urgh
21:06:54 <SamB_XP_> sorry
21:07:22 <sshc> kmc: are you implyng that you'd only use C instead of the IO monad for things that involve low-level tasks?
21:07:39 <kmc> sshc, those are not the only considerations, or the only options
21:07:42 <kmc> but yes generally
21:08:16 <kmc> i would use Haskell for any general-purpose program that is complex, needs to be maintainable, and does not require microsecond-level control over latency
21:08:42 <kmc> for one-off text processing, i'd use Python.  once your code is no longer obviously correct by inspection, the lack of static types starts to be a major obstacle.
21:09:17 <kmc> for realtime programming, you can't afford garbage collection.  however a Haskell DSL compiling to C is an option (see: atom on Hackage)
21:10:39 <eldragon> i'll start to read Diesel programming language
21:11:16 <kmc> sshc, in Haskell, functions and imperative actions are two orthogonal types, with first-class support for both
21:11:30 <kmc> you can write a function that takes or returns an imperative action, and you can write an imperative action that yields a function
21:11:49 <kmc> this is tremendously useful in practice.  for example, consider the type of forkIO
21:12:21 <kmc> furthermore, most supposedly stateful programs consist of a shell of state and IO around some purely functional computations
21:13:54 <roostaj> @src takeUntil
21:13:54 <lambdabot> Source not found. Just try something else.
21:16:11 * BMeph would rather use LLVM for low-level stuff, since if you're looking to be low-level, you might as well go assembler.
21:16:21 <kmc> what about C--?
21:19:07 <pikhq> LLVM appears to be more common than C--.
21:19:45 <BMeph> Also, LLVM has more eyeballs on it, as far as development goes.
21:22:36 <eldragon> disaffortunately, the target of the Whirlwind compiler is C--
21:23:12 <kmc> there is a class of software which is high-level (many layers of API, concepts and code far from the machine) and requires expressiveness and abstraction for programmer productivity, yet is critically sensitive to latency
21:23:19 <kmc> i do not know of a good language for this niche
21:24:20 <kmc> the best choice i know is C with some carefully chosen features from C++
21:24:45 <eldragon> i should follow the principles of OO pure
21:24:52 <pikhq> C at least allows you to not kill yourself while doing it. Though, it'll be some pretty large C.
21:25:05 <kmc> the expressiveness of C and C++ is pitiful though
21:25:09 <kmc> i hear that D is good, haven't learned it
21:25:29 <pikhq> D, from what I've seen, is what C++ would be if it didn't suck.
21:25:41 <medfly> sounds good
21:26:02 <eldragon> and the languages that follow these principles are Cecil/Diesel, Dylan, Lisaac, Self and Ruby.
21:27:09 <eldragon> some of them, not more maintained.
21:33:49 <SamB_XP_> kmc: the trouble with "some carefully chosen features of C++" is that some of the features of C++ that you didn't choose could easily bite you in the ass if you make a typo :-(
21:34:01 <kmc> indeed
21:34:35 <kmc> could be fixed with static analysis tools, except that parsing C++ is a nightmarish task
21:34:57 <kmc> and the fucking hippies who wrote g++ make it intentionally hard to hook into their frontend
21:35:37 <SamB_XP_> gccxml could be of some assistance in that regard, I think?
21:35:51 <SamB_XP_> (but maybe that only does declarations right now?)
21:36:39 <kmc> yup, no function bodies
21:36:43 <kmc> can't actually analyze your code
21:37:14 <kmc> i think the project is pretty much inactive too
21:37:30 <pikhq> Nightmarish? Try "impossible".
21:38:57 <SamB_XP_> pikhq: I don't think that's QUITE accurate
21:39:09 <SamB_XP_> at least, C++ compilers do a fairly good immitation of it ...
21:39:17 <pikhq> SamB_XP_: Only an imitation.
21:39:24 <pikhq> They don't solve the halting problem, sadly.
21:39:47 <kmc> this topic is depressing as hell
21:39:50 <kmc> let's talk about Haskell
21:39:55 <medfly> :(
21:40:03 <BMeph> I think the world is due for a new article: "Coding in C++ Is Considered Harmful""
21:40:22 <medfly> May lead to suicide attempts and schizophrenia
21:40:46 <ido> C++ is best language.  I Svetlana, she-programmer of Kerbleckistan.  I write good codes.
21:41:01 <kmc> anyone used ThreadScope yet?
21:41:23 * ivanm isn't using 6.12 yet, so he definitely hasn't
21:41:46 <ivanm> ido == interactively-do (like in emacs)? :p
21:41:55 <medfly> I'm guessing it's a name
21:42:28 <kmc> http://code.haskell.org/ThreadScope/ this page suggests a very complicated dance to get ThreadScope working
21:42:38 <kmc> which involves both GHC 6.12.1 and 6.10.3, but *not* 6.10.4 :/
21:43:05 <ido> ivanm: what can i interactively do for you?
21:43:18 <ivanm> nothing atm, thanks
21:43:19 <ivanm> ;-)
21:43:36 <ivanm> kmc: why not 6.10.4?
21:43:42 <ivanm> gtk2hs works now for 6.10.4 ...
21:43:48 <kmc> okay, then the page is perhaps out of date
21:50:59 <kmc> ah, the gtk2hs / 6.10.4 problem is perhaps Windows-specific
21:59:02 <ivanm> looks like it
21:59:27 <eldragon> about abstractions ...
21:59:49 <ivanm> dcoutts says he's posted a patch to the gtk2hs list that will let it build on 6.12; AFAIK, once that's applied and released then compiling ThreadScope won't be as cumbersome
21:59:59 <ivanm> (assuming they don't change the API for their next release)
22:00:09 <eldragon> is there any Abstract Machine that combines for Prolog's, Haskell's and Java's, three in one?
22:01:26 <kmc> how do you wish them to combine?
22:01:37 <kmc> there are machines to which Prolog, Haskell, and Java code can all be targetted
22:01:41 <kmc> you are probably using one right now
22:04:47 * hackagebot upload: mwc-random 0.4.1 - Fast, high quality pseudo random numbers (BryanOSullivan)
22:04:49 * hackagebot upload: statistics 0.4.1 - A library of statistical types, data, and functions (BryanOSullivan)
22:10:43 <ivanm> bos: so you're splitting the number generation _out_ of statistics?
22:11:10 <bos> ivanm: yep
22:11:10 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:11:15 <copumpkin> nice
22:12:20 <bos> ivanm: no reason to tie them together, and it was hard for people to find that random code in the statistics package
22:12:34 <ivanm> *nod*
22:12:35 <bos> the tendency on hackage is to go for numerous small packages, so fair enough
22:14:53 <ivanm> anyone here knowledgeable about how QC uses the size parameter?
22:17:47 <copumpkin> ivanm: depends on the arbitrary instance I think
22:17:53 <ivanm> yeah
22:18:25 <ivanm> I'm trying to work out if its possible to halve the size parameter for something
22:18:43 <ivanm> or just apply a function to the size value
22:20:31 <ivanm> eh, using sized with an explicit size parameter might do the trick
22:24:48 <Cale> http://www.wolframalpha.com/input/?i=relative+static+permittivity+of+steel  <-- wtf
22:25:50 <kmc> Cale, that's a cellular automaton which computes the relative static permittivity of steel by finite element modeling
22:25:56 <Cale> lol
22:26:45 <ivanm> a very slow cellular automaton?
22:27:19 <ivanm> I love how "curated data" is a primary source, but where they actually got it from is only a "secondary source"
22:29:33 <kmc> how can i write a Word8 to a file as a byte?
22:29:51 <kmc> i was writing binary data with Char, but this breaks with GHC 6.12.1's Unicode IO support
22:30:36 <ivanm> convert to bytestring?
22:30:49 <ivanm> that's probably not the simplest way of doing it though...
22:31:33 <uorygl> Wolfram Alpha *still* gives a value for the melting point of apples.
22:31:46 <uorygl> So, I'm here to vocally ponder what a Haskell runtime system would look like.
22:31:47 <ivanm> heh
22:31:52 * uorygl ponders what a Haskell runtime system would look like.
22:32:17 <uorygl> And by "runtime system", I mean "interpreter chip".
22:33:24 <ivanm> and by "mean" I mean "average" :p
22:34:25 <ido> kmc: have you checked out http://jlouisramblings.blogspot.com/2009/12/parsing-binary-data-in-erlang-and.html
22:36:15 <Cale> ivanm: and it's not even anything sensible.
22:36:25 <Cale> er, uorygl rather
22:38:32 <uorygl> Turning Haskell into something directly executable *seems* clear enough.
22:39:26 <stoop> uorygl, what do you mean?
22:40:05 <uorygl> Haskell types are capable of corresponding to types in C-like languages.
22:40:08 <uorygl> @maybe
22:40:08 <lambdabot> Unknown command, try @list
22:40:09 <uorygl> Er.
22:40:11 <uorygl> @type maybe
22:40:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:40:23 <stoop> ?
22:40:39 <stoop> "Turning Haskell into something directly executable *seems* clear enough" <- What do you mean by this statement?
22:41:01 <uorygl> I mean it seems like there ought to be a straightforward way to compile Haskell into a C-like language.
22:41:09 <stoop> Like C?
22:41:19 <uorygl> C is a C-like language, yes.
22:41:33 <stoop> uorygl, see -fvia-C in ghc.
22:41:35 <uorygl> I guess that wasn't the only interpretation of what I said.
22:42:19 <stoop> uorygl, as far as I know this was implemented before the native code generator.
22:42:39 <copumpkin> it's not what I'd call straightforward
22:42:52 <copumpkin> it still does most of the crazy stuff GHC does anyway
22:42:57 <copumpkin> and just uses c as a final stage
22:43:07 <uorygl> Does -fvia-C tack on a garbage collector?
22:43:22 <copumpkin> it's still interfacing with the RTS
22:43:26 * uorygl nods.
22:45:13 * hackagebot upload: mwc-random 0.4.1.1 - Fast, high quality pseudo random number generation (BryanOSullivan)
22:45:13 <uorygl> It seems every Haskell value could be written as a function that takes a couple of pointers, maybe does some stuff, and returns an enumerated value and maybe some more pointers.
22:45:31 <Cale> uorygl: Haskell values are implemented as pointers to code
22:45:35 <Cale> (in GHC)
22:45:53 <uorygl> And that's what makes sense.
22:46:12 <kmc> :t liftM (>>)
22:46:13 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b -> m b)
22:46:20 <uorygl> Where do the runtime system's functions come in? Is it entirely memory management?
22:46:21 <kmc> :t liftM2 (>>)
22:46:23 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
22:46:28 <Cale> The first time the code executes, it returns the actual value, but not before resetting the pointer to point at a shorter piece of code which returns the value immediately.
22:46:29 <kmc> uorygl, scheduling of Haskell threads also
22:47:10 <uorygl> Is there a list of all of the RTS's functions?
22:47:15 <kmc> yes, the RTS source code ;)
22:47:21 <copumpkin> nm libHSRTS.a
22:47:22 <uorygl> "Function" in the ordinary English sense, not the programming sense.
22:47:22 * kmc does not have a non-smartass answer
22:47:39 <stoop> And "pointers" in the ordinary English sense? :-P
22:47:49 <stoop> Oh
22:47:52 <stoop> Functions. ;p
22:47:56 <uorygl> Well, I didn't ask a question about pointers, I asked a question about functions. :-)
22:48:29 <uorygl> Well, browsing the RTS source code just might work. Can I do that somewhere?
22:49:16 <Cale> uorygl: If you're interested in this low-level stuff (which is not how I think about Haskell when reasoning about performance, it's actually too low-level for that), there's a rather good introductory paper
22:49:27 * BMeph wants to know about the setters and retrievers. Why is it always about the glory-hound pointers all the time? ;p
22:49:36 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
22:50:05 <Cale> (look to the right of the yellow section for a pdf link)
22:51:27 <uorygl> As I sort of said above, my unrealistic goal is to create a computer chip for interpreting Haskell.
22:51:41 <Cale> It discusses various possibilities for implementing Haskell, and in particular one which is very much like the present one used by GHC. (However, GHC has reintroduced pointer tagging to some extent)
22:51:45 <uorygl> (But it's easy to "create" something. All you have to do is tell everyone what to do, right?)
22:51:55 <Cale> Oh, in that case, do you know about the Reduceron project?
22:52:15 <Cale> http://www.cs.york.ac.uk/fp/reduceron/
22:52:16 <uorygl> Nope.
22:52:24 <Cale> http://video.google.com/videoplay?docid=-1518197558546337776#
22:52:30 <ivanm> Cale: how did you get my nick mixed in with uorygl's? :s
22:52:37 <uorygl> Actually, that sounds familiar.
22:52:37 <Cale> ivanm: same colour
22:52:45 <ivanm> heh
22:53:05 <ivanm> it's even worse when kmc and ksf have the same colour nick... >_>
22:53:10 <uorygl> Nonsense. My nick is white, unlike any other person's nick. :-P
22:54:21 <stoop> IRC.
22:54:27 <stoop> It's pretty cool.
22:54:30 <Cale> uorygl: If you're implementing hardware for Haskell evaluation, you'll (probably) want it to look very different from standard processors today.
22:54:57 <uorygl> Probably.
22:54:58 <Cale> uorygl: Basically, because beta reduction is very memory intensive and parallel (even when performed sequentially)
22:55:45 <Cale> The guy (Colin Runciman?) in that talk I linked to explains in more detail.
22:56:37 * uorygl ponders why Haskell cannot be run using a single stack.
22:56:54 <Cale> eh?
22:56:59 <bd_> uorygl: it can. However GHC was not implemented using continuation passing style.
22:57:10 <bd_> So GHC uses a stack for each thread.
22:57:22 <Cale> Oh, for concurrency
22:57:32 <Cale> ?
22:57:46 <bd_> I assume so - why else would there be multiple stacks? *shrug*
22:57:55 <Cale> I suppose so
22:58:05 <uorygl> What I meant is why some Haskell programs require some form of infinite memory other than a single stack.
22:58:23 <bd_> ?
22:58:37 <kmc> uorygl, this is true of most programs in most languages
22:58:43 <Cale> uorygl: I see it this way: the heap is where all the let-bound things and function parameters go
22:58:46 <uorygl> There is no universal Turing machine that uses a stack instead of a tape.
22:58:54 <uorygl> So yeah, the heap.
22:58:59 <Cale> the stack is where case expressions waiting for their scrutinee to evaluate go
22:59:03 <bd_> uorygl: Sure there are UTMs that use stacks rather than heaps.
22:59:17 <bd_> instead of tapes*
22:59:20 <uorygl> Are you sure?
22:59:22 <copumpkin> isn't a PDA with two stacks a TM?
22:59:31 <Cale> copumpkin: yes, iirc.
22:59:33 <copumpkin> or trivially convertible to one
22:59:34 <roostaj> copumpkin: yes I believe so
22:59:38 <uorygl> I said "a stack", not "stacks".
22:59:40 <bd_> uorygl: Depends on how you define stack
22:59:48 <copumpkin> uorygl: well, then obviously not
22:59:53 <bd_> uorygl: Are we allowed to address into the middle of a stack?
22:59:57 <uorygl> I define a stack as a stack that can only be accessed via pushing and popping.
23:00:05 <copumpkin> then no
23:00:08 <bd_> uorygl: okay, GHC doesn't use that sort of stack
23:00:11 * uorygl nods.
23:00:23 <uorygl> Now let me try to visualize a Haskell program running.
23:00:25 <copumpkin> there's already a well defined class for such a machine :P
23:01:01 <Cale> My mental model is that Haskell evaluation proceeds by rewriting terms, and the heap and stack are used for the purposes I just mentioned.
23:02:40 <uorygl> Did you actually mentioned how the stack is used?
23:02:44 <uorygl> Oh, you did.
23:04:10 <uorygl> I like the word "scrutinee". :-P
23:04:18 <Cale> While it's not 100% completely true when you include certain extensions *cough bang patterns cough*, the general association that  let <-> heap  and  case <-> stack  seems to work well.
23:04:29 * copumpkin scrutinizes uorygl 
23:04:38 <copumpkin> uorygl: there, you to are a scrutinee now
23:04:41 <copumpkin> *too
23:04:45 <uorygl> Hey, I didn't say I liked *being* a scrutinee.
23:04:50 <bd_> and a very lazy one, too.
23:04:56 <uorygl> I'm sure Tolkien never wanted to be a cellar door.
23:07:09 <uorygl> Hi, Cale_.
23:07:14 <uorygl> (And hi, bd_.)
23:07:15 <copumpkin> uorygl: I get your nick now!
23:07:27 <Cale> For this model to work well enough, of course you should translate all pattern matches into case, and all local bindings into let
23:07:28 <uorygl> You do? Why?
23:07:28 <Cale> and furthermore, use let inside beta reduction whenever the parameter to a function occurs more than once in the body
23:07:49 <copumpkin> uorygl: I was wondering where warrigal had gone
23:07:50 <Cale> Hmm...
23:07:53 * Cale wonders if the lag on this connection is dying down...
23:08:02 <Cale> Yeah, looks like it
23:08:35 <uorygl> Oh! By "get", you meant "understand", not "receive possession of".
23:08:52 <Cale> uorygl: before I sleep, I'll give the example I always give of evaluation
23:09:02 <Cale> Suppose we have the function  double x = x + x
23:09:21 <Cale> and the expression  double (double 5)
23:09:41 <Cale> Under innermost first (strict) evaluation, this would go
23:09:45 <Cale> double (double 5)
23:09:49 <Cale> -> double (5 + 5)
23:09:51 <Cale> -> double 10
23:09:55 <Cale> -> 10 + 10
23:09:57 <Cale> -> 20
23:10:32 <Cale> (for the purposes of this discussion, you can treat + as something which pattern matches on both its parameters)
23:10:52 <uorygl> I'd kind of like to see if I can work through that expression myself.
23:10:57 <Cale> Under plain outermost-first ("normal order") evaluation
23:11:08 <Cale> how might it go?
23:11:27 <Cale> (would you like to try it, or should I write it?)
23:11:41 <uorygl> I'll do it.
23:11:52 <uorygl> It could go double (double 5) -> double 5 + double 5 -> (5 + 5) + double 5 -> 10 + double 5 -> 10 + (5 + 5) -> 10 + 10 -> 20, or...
23:11:58 <Cale> right
23:12:11 <Cale> So you can see the wasted work there
23:12:15 <uorygl> Right.
23:12:30 <Cale> double 5 was computed twice because x occurred twice in the body of double x
23:12:38 <uorygl> It could go double (double 5) -> E + E where E = double 5 -> E + E where E = 5 + 5 -> E + E where E = 10 -> 10 + 10 -> 20.
23:13:10 <Cale> So lazy evaluation adds a caveat just like that, to share the evaluation between copies in just the way you did there
23:13:37 <Cale> Normally I'd use  let x = double 5 in x + x  there, but where works too
23:14:04 <uorygl> Does it actually work, or does it only work in the sense of having an obvious meaning?
23:14:20 <Cale> Well, 'where' isn't an expression form in Haskell
23:14:24 <uorygl> Right.
23:14:28 <Cale> It's part of the syntax of declarations
23:14:37 * uorygl ponders.
23:14:57 <Cale> (in order that it can scope over multiple guards in function definitions)
23:15:18 <Cale> Also, syntax-wise, E isn't an appropriate variable name, since it starts with an uppercase letter, but that's being picky :)
23:15:32 <uorygl> Being picky for the second time, even. :-)
23:15:42 <uorygl> It's perfectly valid!
23:15:46 <uorygl> > let True = False in True
23:15:47 <lambdabot>   True
23:15:49 <uorygl> It just doesn't work!
23:16:45 <Cale> But yeah, you see the x parameter there go on the heap and get shared.
23:16:46 <kmc> that's not a variable
23:16:57 <copumpkin> > let 5 = 6 in 5
23:16:58 <lambdabot>   5
23:16:59 <copumpkin> zomg
23:17:05 <kmc> > let ~5 = 6 in 5
23:17:05 <copumpkin> > let !5 = 6 in 5
23:17:06 <lambdabot>   * Exception: <interactive>:1:149-154: Non-exhaustive patterns in pattern bi...
23:17:06 <lambdabot>   5
23:17:18 <kmc> > let x@5 = 6 in x
23:17:19 <lambdabot>   * Exception: <interactive>:1:145-151: Irrefutable pattern failed for patter...
23:17:22 <Cale> This behaviour can be cleverly hijacked in order to memoise functions of a known type of domain.
23:17:36 <uorygl> > let 5@x = 6 in x
23:17:37 <lambdabot>   <no location info>: parse error on input `@'
23:17:48 <uorygl> > let True@x = False in x
23:17:49 <lambdabot>   <no location info>: parse error on input `@'
23:17:52 <uorygl> Meh.
23:17:54 <Cale> bool f = cond (f True) (f False)
23:17:55 <Cale>     where
23:17:55 <Cale>     cond t f True  = t
23:17:55 <Cale>     cond t f False = f
23:18:17 <Cale> ^^ this code, stolen from the data-memocombinators library, memoises a function of a boolean parameter
23:18:23 <copumpkin> > let x@True = False in x
23:18:24 <lambdabot>   * Exception: <interactive>:1:133-146: Irrefutable pattern failed for patter...
23:18:49 <uorygl> Hmm.
23:19:26 <adu> wow
23:19:31 <uorygl> Hmm.
23:19:31 <copumpkin> ?
23:19:35 <Cale> Confusing that f is used in two ways though
23:19:50 <uorygl> Clearly, inside the where, it should be f'. :-P
23:20:01 <adu> or "q"
23:20:01 <Cale> I'd probably change the function name to g
23:20:17 * uorygl ponders why that memoises.
23:20:21 <Cale> So bool g = cond (g True) (g False)
23:20:25 <kmc> uorygl, the syntax for an @-pattern is variable@pattern
23:20:34 <kmc> not pattern@pattern
23:20:46 <uorygl> Aww.
23:21:12 * kmc has threadscope working
23:21:15 <kmc> It's shiny!
23:21:32 <kmc> except that... it and X together conspire to use one of my cores in entirety, even when i'm not looking at it
23:21:35 <Cale> So, after a little evaluation, you get something which looks like  \b -> let t = g True; f = g False in case b of True -> t; False -> f
23:21:44 <kmc> so i can't test and look at results at the same time
23:22:02 <Cale> and as t is evaluated, the binding for t is actually updated
23:22:19 <Cale> and the function itself "changes", in a sense
23:23:09 <Cale> It's one constant thing on the heap
23:23:37 <Cale> But t and f can be in different states of evaluation
23:23:49 <uorygl> So, lessee. Traditionally, the stack contains the "current job" and all its local variables. double (double 5) can work the same way, I think.
23:24:18 <Cale> uorygl: Well, the only thing this needs the stack for is the pattern match which (+) does
23:24:28 <Cale> The rule for double matches immediately
23:24:34 <Cale> with x = double 5
23:25:04 <Cale> It's only when there's a real pattern match on the structure of data that you have to put things on the stack
23:25:08 <Cale> (or primitive functions)
23:26:04 <dblhelix> good morning
23:27:14 <Cale> So for the purpose of showing off how the stack works, this double example is a little poor.
23:27:24 <uorygl> So, the stack contains some context, and on top, a pointer to a thunk representing (double 5). The evaluator pops this pointer and pushes a continuation _ + _ and a pointer to 5. It pops this pointer and pushes a continuation _ + _ again, then it evaluates 5, pops the continuation, plugs 5 into it, pops the other continuation, plugs 5 into that, and returns.
23:27:29 <uorygl> Except that didn't sound right.
23:29:08 <Cale> I think of the stack as consisting of things which look like  case ... of pat1 -> res1; pat2 -> res2; ...
23:29:30 <uorygl> Can you give me your what's-on-the-stack-and-what's-on-the-heap again?
23:29:54 <Cale> The heap has everything bound by a let, including the lets we create when applying a function to parameters
23:30:04 <Cale> (in order to share evaluation)
23:30:28 <uorygl> Can we assume lambdas to be implicit lets?
23:30:30 <Cale> The stack has the case expressions which are waiting for their scrutinee to be sufficiently evaluated so they can pattern match
23:30:57 <Cale> You can assume that lambdas create lets when they're beta reduced
23:31:05 <uorygl> Right.
23:31:23 <uorygl> Hum, I kind of feel like coming up with this myself rather than being told it.
23:31:34 <Cale> Well, this is just my own mental model
23:31:38 <uorygl> Right.
23:31:47 <Cale> and in places it's not even perfect regarding GHC's behaviour
23:31:55 <Cale> GHC doesn't *really* just do lazy evaluation
23:32:03 <kmc> uorygl, did you read: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
23:32:10 <Cale> It does strict evaluation when it can prove that it would be okay
23:32:29 <Cale> and there are lots and lots of practical complications
23:32:39 <Cale> and I haven't even talked about the executor and I/O yet ;)
23:32:42 <uorygl> So, essentially, a Haskell program consists of function applications, lambdas, lets, and case statements, right?
23:32:52 <Cale> expressions, yes
23:32:56 <SamB_XP> ooh, talk about the executionor!
23:33:00 <Cale> (let and case expressions)
23:33:09 <uorygl> kmc: is that the spineless whatever that was linked earlier?
23:33:25 <kmc> spineless tagless G-machine
23:33:39 <uorygl> Hmm, bool above contains all of those.
23:33:41 <Cale> btw, Data.MemoCombinators is an insanely cool library, and I highly recommend its use
23:33:49 <kmc> yes
23:33:50 <copumpkin> uorygl: it can all be reduced to lets and case statements
23:34:19 <Cale> It should be in Platform, if it's not
23:34:38 <uorygl> bool = \g -> let cond = \t f x = case x of True -> t; False -> f in cond (f True) (f False)
23:34:40 <copumpkin> Cale: propose it!
23:34:56 <uorygl> Oh, there are also data constructors. :-P
23:35:01 <uorygl> And builtins. But let's not get out of hand.
23:35:22 <uorygl> kmc: no, I haven't read that.
23:35:33 <uorygl> copumpkin: can you write
23:35:36 <uorygl> Er.
23:35:40 <copumpkin> I think I can
23:35:42 <kmc> uorygl, in GHC there are also primitive values, which are rather different from constructor values
23:35:45 <copumpkin> not sure
23:35:46 <uorygl> copumpkin: can you write \x -> x in terms of lets and case statements?
23:36:00 <uorygl> kmc: are those what I think they are?
23:36:03 <Cale> You can't write lambda in terms of case and let
23:36:08 <kmc> uorygl, i don't know, i can't read your mind
23:36:08 <Cale> You need all three
23:36:11 <kmc> your Int is actually "data Int = I# Int#", where Int# is the primitive
23:36:15 <copumpkin> let zomg x = x :P
23:36:17 <kmc> and Int# has various special properties
23:36:25 <uorygl> copumpkin: bah!
23:36:29 <uorygl> kmc: okay.
23:36:38 <kmc> it's represented by a machine int, not a pointer into the heap
23:36:49 <kmc> so it's never a thunk
23:36:52 <uorygl> Right, it's unboxed.
23:37:23 <copumpkin> Cale: can't you just give the lambda a generated name and write it in a let?
23:37:42 <uorygl> copumpkin: so, can you write f x in terms of lets and case statements as well?
23:37:43 <kmc> a + b = case a of (I# c) -> case b of (I# d) -> case primIntAdd# c d of e -> I# e
23:38:19 <copumpkin> uorygl: expand the f with its definition and it becomes a case statement
23:39:00 <uorygl> If f is itself a case statement, that could get large.
23:39:26 <copumpkin> well it isn't so much about the syntax as the meaning
23:39:34 <copumpkin> if you write f True = 1; f False = 2;
23:39:39 <uorygl> I think I prefer to keep all four primitive things.
23:39:44 <copumpkin> that's really just f x = case x of True -> 1; False -> 2
23:40:18 <Cale> sigh
23:40:38 <Cale> uorygl: okay, not sure when I got disconnected there
23:41:16 * uorygl ponders arrogantly saying "Don't worry, we didn't need you to read any of that anyway."
23:41:18 <Cale> uorygl: But let's take that desugaring of bool (corrected for the f <-> g transposition), and apply it to some imaginary function of a Bool parameter g
23:41:36 <Cale> bool = \g -> let cond = \t f x = case x of True -> t; False -> f in cond (g True) (g False)
23:41:39 <Cale> ^^ fixed
23:41:54 <Cale> bool g
23:41:56 <Cale> -> let cond = \t f x = case x of True -> t; False -> f in cond (g True) (g False)
23:42:39 <emile_m> How Monoid and MonadPlus are related? Isn'
23:42:49 <Cale> -> let (\t f x = case x of True -> t; False -> f) (g True) (g False)
23:42:53 <Cale> er, d'oh
23:42:55 <Cale> -> (\t f x = case x of True -> t; False -> f) (g True) (g False)
23:43:36 <Cale> -> let t = g True; f = g False in \x = case x of True -> t; False -> f
23:44:02 <Cale> okay
23:44:41 <uorygl> Is there a term for adding and pulling stuff from a heap?
23:44:58 <Cale> So there's our function, which will presumably be heap allocated, as that's how you're expected to use the memocombinators library, by defining functions with let by applying combinators like this bool to other functions
23:45:13 <Cale> uorygl: You just use the variables
23:45:31 <uorygl> "Stash", "store", "add"...
23:45:38 <uorygl> Like "push" and "pop" but for heaps.
23:46:26 <Cale> oh, I don't know. I just think of it as a block of memory in which space is allocated for things and garbage collected when those things are no longer referred to
23:46:57 <uorygl> Hmm. Is there a reason we don't just have:
23:47:15 <Cale> Or, you can think of it as the physical space required for the let expressions :P
23:47:38 <uorygl> bool = \g -> (\t f x -> . . .) (g True) (g False)
23:47:58 <Cale> no particular reason
23:48:01 <uorygl> "Yeah, . . . isn't a valid Haskell expression; you can't have infix operators next to each other like that."
23:48:03 <Cale> It'll be the same here
23:48:44 <Cale> (evaluation gets there quickly anyway)
23:49:02 <Cale> You could also write
23:49:20 <sannysanoff> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15015             - how to implement function of given signature? (rigid variables error). Please help.
23:49:39 <Cale> bool = \g -> let t = g True; f = g False in \x -> case x of True -> t; False -> f
23:49:51 <Cale> since that's where this is going
23:50:18 <Cale> It's important to know that let doesn't cause evaluation to occur. Evaluation is driven by case
23:50:25 <Cale> let just makes bindings
23:51:15 <uorygl> sannysanoff: unfortunately, it's rather difficult.
23:51:15 <Cale> So when we write "let t = g True ...", it doesn't mean to evaluate g True right away, but only to define t like this, and when t is evaluated, eventually it'll settle down to whatever constant it happens to be.
23:51:27 <uorygl> sannysanoff: nevertheless, let me attempt it.
23:51:53 <sannysanoff> uorygl, this was very unexpected for me
23:52:01 <Cale> sannysanoff: I don't understand what your function is supposed to do
23:52:15 <Cale> sannysanoff: "X" :: String
23:52:21 <Cale> *not*  (Show b) => b
23:52:45 <sannysanoff> this is fake function, real function is different
23:52:45 <uorygl> Cale: the function as written would have the type (Show a) => a -> Int -> exists b. (Show b) => b, if that were a valid type.
23:53:18 <uorygl> sannysanoff: well, in this instance, you really should just return show "X" and show a.
23:53:23 <Cale> Well, sure, with fancy enough types, you can give anything a type, but mostly it just looks like a type error
23:53:31 <sannysanoff> uorygl, hmm, I don't need return Strings
23:53:34 <Cale> Or just "X" and show a
23:53:44 <Cale> sannysanoff: What do you need to return?
23:53:49 <sannysanoff> Cale, Show!
23:54:02 <uorygl> sannysanoff: well, you're not returning Strings and so you're getting a type error, so it sounds like you need to return Strings.
23:54:11 <Cale> sannysanoff: If all you know about something is that it's showable, then it is effectively a string anyway
23:54:24 <uorygl> sannysanoff: the thing is, your type signature means that for all a and b, as long as a and b are showable, you can take and a and an Int and return a b.
23:54:29 <sannysanoff> I need to return either argument of type Show, or constant (of type show)
23:54:37 <Cale> Show is not a type
23:54:37 <sannysanoff> a and b came as an attempt
23:54:40 <uorygl> Show isn't a type, though.
23:54:53 <sannysanoff> let me rephrase
23:54:54 <medfly> => isn't ->
23:54:55 <Cale> Show is a class to which types belong
23:55:06 <uorygl> But I believe you said this isn't actually the function you're trying to implement. What is the function you're trying to implement?
23:56:16 <sannysanoff> ok, I need a function, that takes any type which belongs to class Show, and under some conditions returns concrete instance of that class, otherwise it returns original argument.
23:56:37 <Cale> When you write (Show t) => ... t ..., what you mean is that t can be *any type at all* so long as there's a Show instance for it
23:56:37 <uorygl> sannysanoff: why do you need such a function?
23:56:39 <sannysanoff> to add a condition, i pass second (Int) argument.
23:56:54 <copumpkin> (Show a) => a -> Either a ConcreteInstance
23:56:57 <sannysanoff> uorygl, i will tell you in a second.
23:57:13 <Cale> sannysanoff: Yeah, use Either, like copumpkin suggests
23:57:36 <sannysanoff> 'Either" suggests using "case" after that, which is making code more complex
23:57:51 <copumpkin> sannysanoff: how else do you expect to do it?
23:57:55 <Cale> Indeed, but you're doing something unnatural and strange, so it's necessary
23:57:58 <copumpkin> :t either
23:57:59 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:58:04 <copumpkin> no case required
23:58:07 <sannysanoff> ok, I am using Happstack
23:58:08 <copumpkin> :P
23:58:33 <sannysanoff> i have set of functions "fun :: ToMessage a => a"
23:58:58 <uorygl> Well, yeah. In Haskell, the return type of a function simply can't depend on the value the function receives, only the type it receives, but using Either, you can pretend otherwise relatively painlessly.
23:58:59 <sannysanoff> some of them return strings (which are of class ToMessage), other return Responses,
