00:01:39 <wm_eddie_> I just wanted a cheat sheet, not a disertation.
00:02:03 <Cale> "All about monads" has some presentation issues too.
00:02:39 <wm_eddie_> I wish I could figure out how to run two functions concurrently, and add their products.
00:02:58 <Cale> (The examples are silly and complicated, and there are terminology problems)
00:03:15 <Cale> wm_eddie_: Does it need to be concurrent, or just parallel?
00:03:46 <wm_eddie_> just parallel, to see how it's done.
00:04:17 <Cale> let u = f x; v = g y in u `par` v `seq` u + v
00:06:36 <mercury^_> How can something be "just parallel", but not concurrent?
00:07:04 <mercury^_> I thought parallel implied concurrent, while concurrent does not imply parallel.
00:07:05 <Cale> mercury^_: concurrency implies that the result is potentially nondeterministic depending on the interleaving of threads
00:07:09 <wm_eddie_> I was lso wondering...
00:07:29 <wm_eddie_> That's what I thought.
00:08:13 <Apocalisp> Cale: I agree. Everybody knows that the "father" of a Sheep is called a sire.
00:08:35 <Apocalisp> (re. terminology problems)
00:09:37 <Cale> There's a good analogy for explaining the distinction between parallelism and concurrency. Imagine a fast food restaurant. Concurrency is all about putting multiple queues in front of the counter so that multiple people's orders can be taken at once (even if they're served by one poor guy in the back), and the order in which people get served changes, and if you run out of food, who gets their order and who doesn't be
00:09:37 <Cale> comes less determined. Parallelism is about putting more employees behind the counter.
00:10:13 <Cale> So that even if you're just making one person's order at a time and what you serve up is completely deterministic, you might be able to do it faster.
00:10:14 <mercury^> To execute tasks in parallel, these tasks need to be concurrent. But concurrent tasks can be executed in sequence.
00:11:09 <Cale> mercury^: Well, okay, but there's a sort of trivial concurrency where the tasks don't depend on each other in any way, which is almost not concurrency at all.
00:11:57 <HaskellLove_> Pici: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13925#a13925
00:12:05 <osaunders> Can you use import just to include files without declaring a module and stuff?
00:12:21 <quicksilver> osaunders: no. a module is what a file contains (in GHC)
00:12:24 <Cale> osaunders: You need to put a module declaration at the top
00:12:30 <quicksilver> (and indeed in all the other haskell compiles I'm aware of)
00:12:38 <quicksilver> it's not part of the language spec, but it's the decision they all took
00:12:40 <mercury^> If you do not put the module declaration, there is an implicit one.
00:12:47 <mercury^> Which exports everything and has the name of the file.
00:12:49 <Cale> osaunders: and in order that GHC can find your module, you need to put it in a file of the same name
00:12:56 <osaunders> So you couldn't ever had a definition of a module spanning more than one file.
00:13:03 <Cale> mercury^: Er, are you sure that the module isn't called Main?
00:13:12 <mercury^> Ah, hmm.
00:13:12 <Cale> osaunders: right
00:13:34 <mercury^> I haven't tried importing things without a module declaration yet, could be that it is always called Main.
00:13:38 <Cale> osaunders: but you can write multiple modules and have one module which imports and re-exports them all
00:13:41 <HaskellLove_> oops wrong chanel ^
00:14:55 <mercury^> Ah, indeed:
00:14:55 <mercury^>     File name does not match module name:
00:14:55 <mercury^>     Saw: `Main'
00:14:55 <mercury^>     Expected: `Foo'
00:15:02 <mercury^> So you have to declare modules.
00:15:08 <mercury^> Unless you name the file Main.
00:15:11 <Jonno_FTW> would it be more sensible to learn the finer points of point-free notation before looking into monads??
00:15:12 <osaunders> Can you import files with numeric names like "09.hs" in this case?
00:15:26 <mercury^> Jonno_FTW: the two are unrelated.
00:15:30 <osaunders> I seem to be getting a parse erro.r
00:15:53 <mercury^> (except that some monads are useful for point-free notation)
00:15:59 <c_wraith> Jonno_FTW: did you figure out what I was talking about with floating point yesterday?
00:15:59 <osaunders> Jonno_FTW: There are no points in point-free notation. :P
00:16:05 <Jonno_FTW> but a lot of monad tutorials use it in examples
00:16:12 <Jonno_FTW> it was a pun
00:16:24 <mercury^> But you cannot understand those examples without understanding monads.
00:16:26 <Jonno_FTW> i get the floating point thing
00:16:34 <eivuokko> For getting practical stuff done, I'd learn monads before trying to master point-free.
00:16:39 <Jonno_FTW> i am doing the monad tutorials
00:16:48 <Jonno_FTW> ok
00:16:54 <mercury^> Wouldn't it be better behaviour if the default module had the name of the file?
00:17:52 <Cale> Jonno_FTW: There's not a lot of point-free-ness to most monadic code.
00:17:59 <Jonno_FTW> ok
00:18:07 <Jonno_FTW> i have read a few tutorials
00:18:18 <Jonno_FTW> but i need to implement in practice problems first
00:18:27 <Jonno_FTW> because i still don't get it
00:18:37 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
00:18:38 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
00:18:57 <Cale> > [1,2,3] >>= \x -> [4,5] >>= \y -> return (x,y)
00:18:58 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
00:19:19 <Cale> > liftM2 (,) [1,2,3] [4,5]
00:19:20 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
00:19:40 <Cale> It's possible to remove the points sometimes, but do-notation tends to make them explicit
00:20:06 <mercury^> (,) <$> [1,2,3] <*> [4,5]
00:20:09 <mercury^> > (,) <$> [1,2,3] <*> [4,5]
00:20:10 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
00:20:29 <Cale> Yeah, applicative notation tends to force you into a points-free style more.
00:21:01 <Cale> (In a sense, anyway)
00:21:45 <Jonno_FTW> are there some functions which can only be used with point free?
00:22:02 <osaunders> Can you import files with numeric names like "09.hs" in this case?
00:22:10 <mercury^> osaunders: try it.
00:22:16 <osaunders> Parse erorr.
00:22:18 <mercury^> I doubt you can though.
00:22:28 <osaunders> *I get a parse error when I tried.
00:22:31 <osaunders> *got
00:22:52 <eivuokko> Jonno_FTW, no.  But sometimes it just makes more sense not to mention parameters.
00:23:28 <Jonno_FTW> hmmm
00:23:32 <Jonno_FTW> example?
00:23:44 <mercury^> What's your definition of pointfree anyway?
00:24:15 <Jonno_FTW> when you don't mention any arguments in the function
00:24:38 <Jonno_FTW> instead they are replaced with "." in what the function does
00:24:51 <mercury^> Ugh.
00:25:26 <aavogt> osaunders: it works if that file has a main, and you :load it instead of trying to get a module... oh you want to import from a different file
00:25:38 <mercury^> I think you shouldn't worry about any distinction there and just remember that there are many ways to write the same function.
00:25:41 <aavogt> yeah, module names can't start with numbers apparently
00:25:53 <Jonno_FTW> ok
00:25:59 <Jonno_FTW> well
00:26:19 <Jonno_FTW> how would i write this function point free?
00:26:21 <osaunders> aavogt: Rats. I'm going to stick a letter at the start or something.
00:26:28 <c_wraith> Jonno_FTW: ask lambdabot
00:26:32 <osaunders> Jonno_FTW: @pl tells you.
00:26:44 <osaunders> @pl \x y = y x
00:26:44 <lambdabot> (line 1, column 6):
00:26:44 <lambdabot> unexpected "="
00:26:44 <lambdabot> expecting pattern or "->"
00:26:47 <Jonno_FTW> factorial n = foldl' (*) $ [1..n]
00:26:51 <osaunders> @pl \x y -> y x
00:26:51 <lambdabot> flip id
00:27:05 <Jonno_FTW> @pl factorial n = foldl' (*) $ [1..n]
00:27:06 <lambdabot> factorial = foldl' (*) . enumFromTo 1
00:27:08 <Cale> > foldl' (*) 1 . enumFromTo 1
00:27:09 <lambdabot>   {-3->1;-2->1;-1->1;0->1;1->1;2->2;3->6}
00:27:17 <Cale> heh
00:27:46 <Jonno_FTW> @pl factorial n = foldl' (*) 1 $ [1..n]
00:27:47 <lambdabot> factorial = foldl' (*) 1 . enumFromTo 1
00:28:01 <aavogt> I find it strange that haskell has much of the prelude optimized for lazy evaluation, but where are the lazy numbers in the standard library to take advantage of those?
00:28:06 <aavogt> @src sum
00:28:06 <lambdabot> sum = foldl (+) 0
00:28:18 <jmcarthur_work> aavogt, nowhere :(
00:28:21 <mercury^> aavogt: What are lazy numbers?
00:28:25 <osaunders> aavogt: Lazy numbers?
00:28:31 <jmcarthur_work> aavogt, we have lazy naturals in the numbers package though
00:28:31 <Cale> It's also a bit screwy for those to be foldl if you wanted to use lazy naturals
00:28:31 <c_wraith> Things like natural
00:28:48 <c_wraith> yeah, foldl doesn't work with Natural anyway
00:28:53 <jmcarthur_work> i intend to have some lazy numeric types in alt-stdlib
00:29:05 <aavogt> jmcarthur_work: how's that coming along?
00:29:10 <jmcarthur_work> slowly
00:29:18 <jmcarthur_work> still in the mostly design phases
00:29:24 <c_wraith> > foldr (+) (1::Natural) [1..] > 1000
00:29:24 <jmcarthur_work> but i'm liking it
00:29:25 <lambdabot>   True
00:29:43 <c_wraith> > foldl (+) (1::Natural) [1..] > 1000
00:29:47 <lambdabot>   mueval-core: Time limit exceeded
00:29:55 <c_wraith> So..  it's very odd that they're foldl
00:30:01 <HaskellLove_> i am reading on lambda calculus, what chanel to go for lambda questions?
00:30:13 <jmcarthur_work> we will be either waiting for or implementing constraint synonyms and constraint families in ghc for it, first, since a lot of our ideas need it
00:30:20 <aavogt> yeah, some things would be easier with naturals, such as comparing which of two lists is longer
00:30:20 <mercury^> Those "lazy numbers" seem hardly useful.
00:30:42 <aavogt> so you could think about it in terms of numbers and not lazy lists
00:30:47 <Jonno_FTW> should I learn the basics of lambda calculus? or just learn how to use lambda expressions?
00:31:00 <eivuokko> What was that example with genericLength someone brought up with the Natural?
00:31:01 <aavogt> @where unlambda
00:31:02 <lambdabot> http://www.madore.org/~david/programs/unlambda/
00:31:03 <mercury^> Jonno_FTW: you should learn something instead of wondering what to learn.
00:31:04 <jmcarthur_work> > genericLength [1..100] == (genericLength [1..] :: Natural)
00:31:06 <lambdabot>   False
00:31:22 <Jonno_FTW> im reading up on monads right no
00:31:22 <Jonno_FTW> w
00:31:47 <jmcarthur_work> i also have an FRP related use case for lazy numbers
00:32:16 <jmcarthur_work> adding, subtracting, and comparing partially known time values
00:32:41 <eivuokko> jmcarthur_work, yeah, thanks.  I really like that example.
00:32:58 <c_wraith> jmcarthur_work: how does that work out with non-integer time units?
00:33:27 <jmcarthur_work> c_wraith, implemented as a lazy list of strict numbers
00:33:29 <aavogt> > (1::CReal) == read ("0."++  repeat '9')
00:33:32 <osaunders> Jonno_FTW: My understanding is that Haskell is lambda calculus only with ASCII syntax and types.
00:33:35 <lambdabot>   mueval-core: Time limit exceeded
00:33:43 <aavogt> > (1::CReal) == read (take 100 $ "0."++  repeat '9')
00:33:43 <Jonno_FTW> wow
00:33:46 <lambdabot>   True
00:33:46 <c_wraith> jmcarthur_work:Ah, that makes sense.
00:33:57 <Jonno_FTW> any book recommendations?
00:33:57 <aavogt> there's your proof ;)
00:34:24 <aavogt> not that anybody in particular asked...
00:34:41 <aavogt> Jonno_FTW: depends what you're looking for
00:34:41 <osaunders> For Haskell? Real-world Haskell has been mentioned a lot. I'm getting The Haskell School of Expression from the library after n weeks.
00:35:14 <ezyang> Jonno_FTW: +1 on RWH
00:35:20 <mercury^> aavogt: That is surprising. Why does it give a wrong answer?
00:35:23 <aavogt> osaunders: people take the haskell books out of your library?
00:35:29 <jmcarthur_work> c_wraith, if you think about it, even the naturals are just a list of (+1) ;)
00:35:37 <aavogt> mercury^: that's the right answer for the wrong reason
00:35:39 <osaunders> aavogt: No the library doesn't have it so they are getting it in for me.
00:35:49 <osaunders> I had to pay some but cheaper than buying the book.
00:35:53 <osaunders> £3
00:36:07 <osaunders> Till then I'm using LYAH.
00:36:11 <osaunders> @where LYAH
00:36:11 <lambdabot> http://www.learnyouahaskell.com/
00:36:20 <osaunders> Jonno_FTW: ^^
00:36:22 <c_wraith> jmcarthur_work:  I'm vaguely aware of that.  Having a tattoo that makes some degree of use of that fact. :)
00:36:35 <Jonno_FTW> i already have LYAH and RWH
00:36:44 <Jonno_FTW> anything specific on lambda calc?
00:36:50 <mercury^> aavogt: It's the wrong answer and CReal should know better.
00:36:52 <jmcarthur_work> c_wraith, a natural tattoo?
00:37:17 <osaunders> Jonno_FTW: Ask in a math room?
00:37:18 * tass ponders whether it's possible to use regex in guards or not
00:37:18 <Jonno_FTW> i already know normal calculus
00:37:36 <mercury^> Jonno_FTW: are you trolling?
00:37:44 <Jonno_FTW> no....
00:37:49 <ezyang> Jonno_FTW: you might be interested in Types and Programming Languages by Benjamin C. Pierce
00:37:57 <jmcarthur_work> +1
00:37:58 <c_wraith> jmcarthur_work: it is an expression regarding the naturals, at least.  The process of acquiring it may not have wholly natural.
00:38:06 <jmcarthur_work> ;)
00:38:10 <eivuokko> tass, what do you mean?  You can call arbitary functions in guard expression, as long as it evaluates to Bool.
00:38:38 <aavogt> mercury^: CReal compares only to a bounded precision (something like 40 decimal places), otherwise it could never say True
00:38:38 <c_wraith> Jonno_FTW:  Lambda calculus has nothing to do with newton/liebniz calculus.
00:38:57 <Jonno_FTW> ok ok
00:39:01 <jmcarthur_work> i would rather (==) return ⊥ if it can't prove it
00:39:27 <tass> eivuokko: Would this work? -> | myVar =~ "pattern" = "return result"
00:39:39 <tass> Or am I doing it wrong?
00:39:54 <quicksilver> I read barendregt on lambda calculus
00:39:55 <mercury^> aavogt: otherwise it *might* never say True, or does it extend finite lists by 0?
00:39:57 <quicksilver> that's pretty old-skool though
00:40:03 <quicksilver> I found it quite charmingly so
00:40:09 <quicksilver> but other peopel might find it insufferable
00:40:11 <eivuokko> tass, if you have operator =~ defined.  Are you searching for regexp support in haskell or?
00:40:24 <eivuokko> tass, (it's not defined in Prelude)
00:40:47 <tass> eivuokko: I have imported Text.Regex.PCRE, if that's what you mean
00:42:11 <quicksilver> aavogt: it's possible to have CReal-like things which True for some subset of things which are actually identical
00:42:24 <quicksilver> aavogt: but of course, only ever a subset, since computable equality isn't computable
00:42:32 <quicksilver> (hmm, that's a strange form of words)
00:43:19 <quicksilver> I mean you can get something which returns True sometimes, False sometimes, and sometimes doesn't return, and is always correct if it returns.
00:43:19 <eivuokko> tass, On a quick glance, it looks ok to me.  Are you getting an error?
00:43:22 <aavogt> quicksilver: so to keep say the generating power series around, and if the generating formulas for such can somehow be manipulated to be equal...
00:43:30 <quicksilver> aavogt: right.
00:43:48 <tass> eivuokko: Yeah, it might not be regex related even, it's a type mismatch basically
00:46:05 <eivuokko> tass, the way =~ is defined, it's quite possible the type errors are confusing.
00:46:21 <tass> I guess I could get it on pastebin if you'd like to take a closer look.
00:47:03 <Saizan> you might just stick to the less overloaded API in the regex-compat package
00:47:43 <eivuokko> tass, Well, without seeing (and trying it myself) I'd make a new op with String->String->Bool that just calls the =~ or match and use it on guard.
00:48:16 <tass> Think the problem is that my function expects to end with IO(), but it instead returns an exitcode, since the case at hand is supposed to make the program exit clean.
00:49:16 <ezyang> tass: ExitCode or IO ExitCode?
00:49:49 <tass> ExitCode is what _is_ returned, while it expects IO.
00:50:10 <ezyang> @hoogle ExitCode -> IO ()
00:50:11 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
00:50:11 <lambdabot> Prelude print :: Show a => a -> IO ()
00:50:11 <lambdabot> System.IO print :: Show a => a -> IO ()
00:50:39 <ezyang> You want exitWith
00:50:56 <tass> I'm using exitWith ExitSuccess
00:51:00 <tass> To be quite precise.
00:51:28 <ezyang> :t exitWith ExitSuccess
00:51:32 <lambdabot> Not in scope: `exitWith'
00:51:32 <lambdabot> Not in scope: data constructor `ExitSuccess'
00:51:38 <ezyang> meh
00:52:07 <ezyang> I guess I don't understand your question.
00:52:21 <tass> I'll get it on pastebin then, haha
00:54:02 <tass> http://pastebin.com/d29b5ef63
00:55:19 <ezyang> What's the type of write?
00:55:58 <ezyang> also, I'm kind of skeptical your parentheses do what you think they do.
00:56:17 <Saizan> i think you just miss a >>
00:56:23 <ezyang> (or lack thereof)
00:56:38 <Jonno_FTW> @pl f x = 2*x
00:56:39 <lambdabot> f = (2 *)
00:57:02 <Saizan> tass: http://pastebin.com/mc2dfda
00:57:11 <tass> The write is a socket
00:57:21 <tass> Well, to a socket, anyway.
00:57:30 <ezyang> "yes, but what's its type?"
00:57:33 <c_wraith> tass:  that's not a type.  and the problem is almost certainly that the type of write isn't what you think it is
00:58:07 <tass> Hmm... it writes strings?
00:58:12 <c_wraith> still not a type
00:58:20 <Baughn> Has there been any progress on the execute-IO-action-at-startup-to-make-global-variable thing?
00:58:24 <ezyang> A type is something like id :: a -> a
00:58:29 <c_wraith> a type would be something like:  write :: Handle -> String -> IO ()
00:58:34 <Baughn> I mean, other than newer, more exciting ways to use unsafePerformIO?
00:58:41 <tass> A handle, then.
00:58:46 <c_wraith> that's still not a type.
00:58:52 <ezyang> Ok, let's try this differently
00:59:00 <ezyang> replace the non-typechecking expression with an undefined
00:59:05 <ezyang> Then load up the file into ghci
00:59:11 <ezyang> And then type :t write
00:59:15 <ezyang> and give us the output
00:59:31 <tass> My definition of write would be the following: write :: Handle -> String -> String -> IO()
00:59:41 <Saizan> that's not the definition
00:59:55 * ezyang has to bounce 
00:59:58 <ezyang> bye
00:59:59 <Saizan> it's a type annotation
01:00:12 <Saizan> and so "Handle -> String -> String -> IO()" is the type of write
01:00:34 <HaskellLove_> Guys what is this Unlambda language, is it worth wasting time there? Seems like useless language?
01:00:36 <Saizan> tass: the paste i linked to you above  http://pastebin.com/mc2dfda should be correct then
01:00:39 <tass> Hrm.. well, it would be called something like that in languages not Haskell, guess I'm not completely accustomed yet.
01:00:56 <h20xt> tass: no it would be a declaration
01:01:08 <tass>  h20xt True.
01:01:51 <tass> Ah, that actually did solve the problem, though, I did run into a new one. But I believe I can fix that
01:02:16 <tass> Haskell is by far the most fun language I've written code in.
01:02:23 <c_wraith> tass, in the IO context, >> is approximately "do what's on the left side, then do what's on the right side"
01:02:33 <Saizan> the problem was that you can't just put the actions one after the other, you've to compose them with >>/>>= or do-notation
01:02:39 <tass> Ooh, nifty
01:02:54 <Saizan> @undo do a; b
01:02:57 <lambdabot> a >> b
01:03:25 <fasta> I might be an exception, but I just use do notation in >80% of the cases.
01:04:14 <tass> Now... I just have to do some sweet catch-all-return-null case among those guards..
01:04:25 <fasta> I don't think I am an exception, though, seeing by all the code I have read.
01:04:27 <Saizan> mh, depends on the expression for me, i don't bother if it's just for >>
01:04:58 <fasta> tass, case bla of _ -> "something"
01:05:11 <Saizan> | otherwise = return ()
01:05:26 <h20xt> the type () only has one value, namely () right?
01:05:39 <fasta> h20xt, and bottom.
01:05:47 <Saizan> only one observable, and then bottom
01:05:47 <fasta> h20xt, so, wrong ;)
01:05:49 <quicksilver> h20xt: except for _|_ which is, in a sense, not a value
01:05:50 <h20xt> fasta: do all types pottentially take that value?
01:06:09 <tass> Saizan: Thank you!
01:06:13 <fasta> h20xt, unless you create setup the system such that it is impossible.
01:06:13 <aavogt> bottoms, they're everywhere
01:06:37 <Saizan> tass: note that otherwise is not a keyword, it's just defined as otherwise = True
01:06:40 <h20xt> how could you eliminate bottoms, would that not solve the halting problem?
01:07:06 * hackagebot upload: property-list 0.0.0.7 - XML property list parser (JamesCook)
01:07:07 <fasta> h20xt, you can create a module and then only export limited stuff.
01:07:27 <jix> but you can still use undefined :: a
01:07:30 <Saizan> or you can use a non turing complete language :P
01:07:57 <fasta> h20xt, you cannot write the Halting program in some programming languages.
01:08:10 <__me> @src concat
01:08:10 <lambdabot> concat = foldr (++) []
01:08:40 <c_wraith> @src concatMap
01:08:40 <lambdabot> concatMap f = foldr ((++) . f) []
01:08:49 <h20xt> huh, okay, thanks
01:08:52 <fasta> h20xt, or rather, you can, if you require proofs of termination for every program.
01:09:05 <h20xt> fasta: oh i see
01:09:12 <fasta> h20xt, the thing is just that you cannot write down a finite description of all terminating objects.
01:09:22 <fasta> h20xt, kind of cool if you think about it.
01:09:54 <fasta> What you can do is write a program Halts that works 99.999999999999999999999999999999999999999999999999999% of the time.
01:17:44 <h20xt> these channel 9 lectures are spamming me with microsoft products
01:18:16 <leimy> buy some
01:18:21 <leimy> maybe it'll stop :-)
01:18:23 <akappa> h20xt, I don't find it surprising :P
01:19:40 <Cale> fasta: That seems to imply that there are not many programs for which termination is not decidable, and while I agree with that in practice (in that people don't tend to write programs for which the termination behaviour is even difficult to see), I'm not sure if that likelihood applies to the whole space of programs.
01:22:25 <Veinor> is it decidable whether a program's termination is decidable?
01:22:40 <Veinor> or is that itself undecidable
01:22:57 <Veinor> and if it's undecidable, how far does the undecidability go?
01:24:43 <h20xt> Veinor: the halting problem: given a description of a program, decide whether the program finishes running or will run forever, is undecidable over turing machines
01:25:13 <h20xt> Veinor: i don't know much about it though, sorry
01:25:27 <tass> Is it perhaps possible to implement a function with optional arguments?
01:25:28 <Veinor> h20xt: I know what the halting problem is, I'm wondering if the question 'given a program, can the halting problem be solved for it' decidable?
01:25:39 <EvanCarroll> @src or
01:25:39 <lambdabot> or    =  foldr (||) False
01:25:40 <h20xt> ah i see
01:25:51 <EvanCarroll> @src any
01:25:51 <lambdabot> any p =  or . map p
01:26:18 <Veinor> I don't think you can do optional arguments
01:26:47 <EvanCarroll> how does `or . map p` work
01:27:03 <EvanCarroll> oh this is just pointless.
01:27:11 <tass> Hmm, then I have send extra arguments but make sure they have no impact/aren't used.
01:27:13 <Veinor> no, pointless would be
01:27:17 <Veinor> any  = or . map
01:27:18 <Veinor> :D
01:27:39 <Veinor> EvanCarroll: okay, what's the output of map odd [1, 2, 3, 4] ?
01:27:43 <h20xt> both those definitions have points... :P
01:27:44 <EvanCarroll> Veinor: right, it seems weird that they have the point for the predicate but not the array
01:28:04 <EvanCarroll> Veinor: true false true false
01:28:04 <scree> @type or . map
01:28:05 <lambdabot>     Couldn't match expected type `[Bool]'
01:28:05 <lambdabot>            against inferred type `[a] -> [b]'
01:28:05 <lambdabot>     Probable cause: `map' is applied to too few arguments
01:28:22 <Veinor> right, so what's True || False || True || False?
01:28:32 <Veinor> oh wait, that's not right
01:28:58 <Veinor> it'd be (or .) . map
01:29:05 <scree> > let any' = (or .) . map in any (>3) [1..3]
01:29:06 <lambdabot>   False
01:29:07 <h20xt> tass: i don't understand
01:29:25 <Veinor> EvanCarroll: do you get how or works?
01:29:30 <tass> h20xt: A function that takes say.. one OR two arguments.
01:29:43 <h20xt> tass: list
01:29:49 <tass> But that sounds horribly not-haskell
01:30:06 <EvanCarroll> Veinor: yea, it takes two arguments returns true if either are true.
01:30:13 <Veinor> EvanCarroll: no, that's what || does
01:30:13 <tass> A list.. hmm, that should work.
01:30:22 <Veinor> > True || False
01:30:23 <lambdabot>   True
01:30:27 <Veinor> > or [True, False]
01:30:28 <lambdabot>   True
01:30:38 <EvanCarroll> ok, so it takes a list returns true if any are true?
01:30:41 <h20xt> > :t or
01:30:42 <lambdabot>   <no location info>: parse error on input `:'
01:30:48 <Veinor> yeah
01:30:50 <Veinor> you get why?
01:30:57 <h20xt> i suck at lambdabot
01:30:58 <EvanCarroll> Veinor: but still why have an or and an any
01:31:10 <Veinor> why not?
01:31:15 <EvanCarroll> what is the diff?
01:31:30 <Veinor> well, any lets you supply the predicate
01:31:39 <h20xt> there are lots of functions in the standard that are minor variations on others
01:31:42 <Veinor> or is for when you have a list that's already had the predicate applied to it
01:31:42 <Cale> any p = or . map p
01:31:55 <Cale> all p = and . map p
01:37:05 <HaskellLove_> If u are a compiler engineer what is like the best dream job place where you want to get an internship as student and steal some knowledge?
01:37:24 <HugoDaniel> hi
01:37:28 <HugoDaniel> can someone help me out
01:37:33 <HugoDaniel> im using tcsh in freebsd
01:37:37 <HugoDaniel> and when i pop ghci
01:37:38 <zygoloid> HaskellLove_: possibly MSR?
01:37:40 <HugoDaniel> i get this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5297#a5297
01:38:09 <HugoDaniel> whenever i try out the Ctrl+U or other Ctrl+ combinatio ... (they work on the shell, i have properly setup the key bindings for the terminal im using)
01:39:31 <jix> hmm does anybody now why the option-click of the mac os x Terminal.app doesn't work in ghci?
01:39:56 <xerox> what you mean?
01:40:12 <h20xt> COC?!?
01:40:22 <h20xt> BOC?
01:40:36 <h20xt> jix: is that what happens to you?
01:41:13 <jix> h20xt: the cursor moves but leaves some characters everywhere it went along
01:41:35 <jix> OD and D most of the time
01:41:57 <h20xt> now mine is pulling from my ghci history...
01:42:21 <jix> basically it should send the cursor keys to go to the spot where you clicked
01:42:33 <jix> if you click somewhere above your cursor you will get your history with that of course....
01:42:48 <jix> but it is quite usefull to navigate in long lines with the mouse...
01:43:01 <h20xt> mouse and terminal... does not compute
01:43:03 <jix> except it doesn't work in ghci the way it should
01:43:19 <xerox> opt-click does square selection here
01:43:44 <h20xt> jix: i see, same thing happens to me, same letters too...
01:43:49 <jix> xerox: if you do a single click it should send cursor keys... but that might be an option you have to activate
01:44:06 <xerox> oh I see.
01:44:48 <xerox> what is another program in which this does something useful?
01:44:50 <h20xt> can i set vi bindings for ghci?
01:44:59 <zygoloid> If you're seeing OD that indicates it /is/ sending cursor keys; cursor keys sometimes send <esc>OA, <esc>OB, <esc>OC, <esc>OD
01:45:25 <h20xt> yay!
01:46:04 <jix> zygoloid: yeah but it seems that ghci doesn't read it as <esc>OD but as <esc> and OD
01:46:17 <jix> which it should
01:47:06 <jix> it uses haskeline?
01:50:54 <Saizan> yes
01:51:01 <Saizan> see the trac wiki for documentation
01:53:11 <Veinor> I need something to write.
01:58:22 <desp> Is GHC still broken on OS X 10.6?
01:58:23 <Veinor> I want to code something but I have no idea what
01:59:22 <nominolo> desp: 6.12 seems to work
01:59:34 <desp> I just installed GHC 6.10.4 from the provided .pkg, and it fails to compile even the simplest file
01:59:38 <nominolo> desp: butting getting cabal-install to work with 6.12 is currently a bit tricky
01:59:49 <desp> nominolo: huh, and where should I get 6.12 from?
01:59:54 <nominolo> desp: ah, yes, you need to modify the wrapper scrip for that
02:00:09 <nominolo> desp: wait for the next platform release is the safest way
02:01:05 <erik__> desp: did you add -optc-m32 -opta-m32 -optl-m32 to your ghc shell script?
02:01:12 <nominolo> desp: http://passingcuriosity.com/2009/haskell-on-snow-leopard/
02:01:19 <desp> I did that with my 6.10.3 install back in July...
02:01:26 <desp> I really thought this would be fixed by now
02:01:43 <nominolo> it's fixed in HEAD
02:01:56 <jix> afaik there was no new ghc release since sl came out
02:02:35 <nominolo> there is a remaining problem with libs that use cpphs
02:03:42 <sproingie> nominolo: you just need to use the darcs version of cabal-install on 6.12
02:03:53 <sproingie> nothing to it
02:03:58 <desp> Just wondering
02:04:06 <sproingie> pain in the ass getting all the dependencies manually, that's all
02:04:10 <desp> What is your preferred way to build Haskell packages on OS X?
02:04:11 <nominolo> sproingie: failed to bootstrap on Ubuntu
02:04:21 <nominolo> sproingie: right
02:04:21 <desp> I've taken to using homebrew, but it has no Haskell packages yet
02:07:30 <Jonno_FTW> how can i convert "ABC" into ['a','b','c']?
02:07:52 <clarkb> it already is
02:07:57 <HaskellLove_> let x = 3 in (* x x) wrong?
02:08:03 <zygoloid> Jonno_FTW: map toLower
02:08:05 <Jonno_FTW> but
02:08:12 <Jonno_FTW> woops
02:08:15 <clarkb> er oh the case is different
02:08:18 <Jonno_FTW> i wanted a list
02:08:21 * clarkb runs away
02:08:25 <lament> :t "ABC"
02:08:26 <lambdabot> [Char]
02:08:34 <Jonno_FTW> yeah i know it is like that
02:08:36 <zygoloid> HaskellLove_: yep. that's the same as: \y -> y * (x x)
02:08:39 <c_wraith> > map toLower "ABC" == ['a', 'b', 'c']
02:08:40 <lambdabot>   True
02:09:01 <Jonno_FTW> i meant ['A','B','C']
02:09:09 <c_wraith> Oh.  then they're already equal
02:09:11 <Jonno_FTW> or is it unnecessary
02:09:16 <lament> > "ABC" == ['A','B','C']
02:09:17 <lambdabot>   True
02:09:23 <zygoloid> HaskellLove_: which will fail the occurs check since you're trying to pass a function as an argument to itself...
02:09:23 <c_wraith> if you want to control how it prints, you need to do that manually
02:09:27 <c_wraith> but they're the same data
02:09:46 <zygoloid> Jonno_FTW: String is exactly the same as [Char].
02:09:48 <HaskellLove_> zygoloid hmm? but how come man it is wierd... isnt x suposed to be replaced with 3?
02:10:25 <zygoloid> HaskellLove_: right, but this isn't lisp. (* 3 3) means: \y -> y * 3 3.
02:10:42 <c_wraith> zygoloid: that doesn't compile though, since 3 is not a function
02:11:02 * zygoloid 401 -> HaskellLove_ 
02:11:07 <HaskellLove_> wierd stuff... i am gonna bang my head twice now
02:11:38 <zygoloid> umm 301 :)
02:14:07 <Jonno_FTW> how would i check if any of the permutations of an element of a list are present in the list?
02:14:26 <Jonno_FTW> anagrams = nub [n|n<-ws,(permutations n) `elem` ws]
02:14:36 <Jonno_FTW> is what i got so far but it doesn't work
02:16:37 <Jonno_FTW> wait i got it
02:16:45 <Jonno_FTW> but it is rather slow
02:16:57 <Jonno_FTW> anagrams = nub [n|n<-ws,x<-permutations n, x `elem` ws]
02:18:51 <luite> Jonno_FTW: sort the letters of each word and use them as keys in a multimap
02:19:28 <Jonno_FTW> oh right
02:20:14 <HaskellLove_> The most mind blowing coolest programming in general book ever?
02:20:47 <lament> HaskellLove_: Alice In Wonderland
02:21:03 <HaskellLove_> dont fuck around man i am serious
02:21:26 <Gracenotes> Perlis++
02:22:20 <lament> HaskellLove_: ok, then SICP
02:22:25 <sproingie> CTM is good too
02:22:46 <HaskellLove_> hole names guys i dont understand this abreviations :D
02:22:49 <sproingie> i find the SICP lectures better than the dry tome of a book
02:22:59 <sproingie> use teh googelz
02:23:02 <lament> HaskellLove_: you can google them.
02:23:11 <HaskellLove_> ok
02:23:17 <lament> SICP the book is online for free, dunno about CTM
02:23:19 <jmcarthur_work> @where sicp
02:23:19 <lambdabot> http://mitpress.mit.edu/sicp/
02:23:28 <sproingie> there's an old draft of CTM available free
02:23:31 <Gracenotes> one cannot google for someone who cannot google themselves. er.
02:23:35 <sproingie> it's got a lot of errata tho, i wouldn't recommend it
02:24:02 <Jonno_FTW> should this give a correct result? anagrams = nub [n|n<-map sort ws, n `elem` (delete n $map sort ws)]
02:24:03 <HaskellLove_> i have read that SICP, but CTM is? even google knows not
02:24:10 <sproingie> @google CTM book
02:24:12 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
02:24:12 <lambdabot> Title: Concepts, Techniques, and Models of Computer Programming
02:24:13 <jmcarthur_work> HaskellLove_, http://tinyurl.com/mlhvyv
02:25:16 <sproingie> would be nice to see a haskell book that did the programming treatment from first principles
02:25:29 <jmcarthur_work> yes
02:26:26 <sproingie> i suppose a fair amount of SICP could translate to haskell
02:26:28 <sproingie> not so much CTM
02:27:07 <sproingie> a CTM translation might work with some monad wrapping
02:27:17 <lament> what language does CTM use?
02:27:20 <sproingie> Oz
02:27:25 <jmcarthur_work> @where ctm
02:27:27 <lambdabot> http://www.info.ucl.ac.be/~pvr/book.html
02:27:49 <lament> oz is modernized prolog?
02:27:58 <sproingie> not really
02:28:02 <sproingie> it has logic variables, that's about it
02:28:31 <sproingie> it's basically a core language for Mozart/Oz, but most people just call it Oz
02:28:40 <lament> Orz
02:28:46 <sproingie> Alice uses a modified Oz
02:29:17 * hackagebot upload: rwlock 0.0.0.2 - Multiple-read / single-write locks (JamesCook)
02:32:14 <Jonno_FTW> how can i modify this to return the original unsorted words?
02:32:16 <Jonno_FTW> anagrams =  [n|n<-map sort ws, n `elem` (delete n $map sort ws)]
02:32:21 <sproingie> did the OpenGL modules become incompatible with older versions recently?  i can't seem to compile half the stuff out there that uses it
02:32:56 <jix> sproingie: i noticed some changes, but that was about 2 to 3 month ago iirc
02:33:52 <sproingie> i get a lot of "couldn't match GLsizet against inferred type GLint"
02:34:06 <sproingie> or even GLdouble against Double
02:34:33 <sproingie> can't compile raincat or reactive-glut
02:35:10 <|Jedai|> > let anagrams = M.toList . M.fromListWith (++) . zipWith (sort &&& (:[])) in anagrams (map words ["hello world", "world hello", "Haskell rocks"]
02:35:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:35:39 <|Jedai|> let anagrams = M.toList . M.fromListWith (++) . map (sort &&& (:[])) in anagrams (map words ["hello world", "world hello", "Haskell rocks"])
02:35:46 <|Jedai|> > let anagrams = M.toList . M.fromListWith (++) . map (sort &&& (:[])) in anagrams (map words ["hello world", "world hello", "Haskell rocks"])
02:35:47 <jix> sproingie: exactly the errors i got
02:35:48 <lambdabot>   [(["Haskell","rocks"],[["Haskell","rocks"]]),(["hello","world"],[["world","...
02:35:53 <sproingie> GLdouble is a CDouble, so maybe i could see that.  but GLsizei and GLint are both CInt
02:36:01 <Jonno_FTW> i don't follow what you did?
02:36:41 <sproingie> the source for reactive-glut is full of comments like "this is totally broken" so i guess it was never really finished
02:37:10 <sproingie> finding a FRP library i can actually learn is getting a little frustrating.  i think i'll do my GUI with CHP
02:37:24 <aavogt> could haskell be lazy about ambiguous type variables safely?
02:37:24 <|Jedai|> Jonno_FTW: ok, lambdabot truncate the output so you don't see, but this anagrams gives you a [([String],[[String]])] which associates a sorted version with all the anagrams that correspond to it
02:37:30 <sproingie> CHP i can grok easily
02:37:33 * hackagebot upload: OpenVG 0.3.0 - OpenVG (shivag-0.2.1) binding (StephenTetley)
02:38:02 <|Jedai|> Jonno_FTW: the M here is an abbreviation for Data.Map
02:38:09 <Jonno_FTW> ahh
02:38:26 <aavogt> I mean, could you statically recognize, this parameter is discarded, so there's no point in deciding which typeclass instances to choose?
02:40:29 <litb> hello folks
02:40:30 <Jonno_FTW> i'll figure this out tomorrow
02:40:36 <Jonno_FTW> goodbye folks
02:40:44 <jmcarthur_work> aavogt, but what if that type is intended to certify something about how the function is being used?
02:41:30 <aavogt> jmcarthur_work: I don't understand what you mean by that
02:41:38 <jmcarthur_work> i guess if the type parameter is for something unused that implies no other types really depend on it either though...
02:42:12 <aavogt> I'm discussing cases where the type parameter could be anything
02:42:28 <jmcarthur_work> yeah, okay
02:42:42 <aavogt> and at least in this specific case, none of the methods of that class are used
02:43:06 <aavogt> so I have to annotate which type, when it doesn't matter
02:43:40 <aavogt> but that sounds like lazy typechecking... and we know how well that works out
02:43:50 <jmcarthur_work> aavogt, one bad thing i can think of is if the type class is placed as a specification and the implementation might start using it later
02:43:59 <jmcarthur_work> aavogt, so changing the implementation could break existing code
02:44:04 <jmcarthur_work> even though the type is the same
02:44:24 <aavogt> perhaps somebody has already formalized when it is ok to default type variables
02:44:59 <HaskellLove_> anyone has made a function compiler i want to talk about it... i am reading lambda calculus and func languages implementation?
02:45:06 <aavogt> jmcarthur_work: I'm suggesting that there would be some way to machine verify that the type class is fully unused in that situation
02:45:59 <aavogt> specifically: f :: C a => a -> [b] -> Something
02:46:15 <aavogt> and I have a case for b == [] that discards the first argument
02:46:43 <jmcarthur_work> aavogt, right, so you don't have to annotate the first argument when you use f
02:46:46 <jmcarthur_work> right?
02:46:57 <aavogt> yes
02:47:12 <aavogt> but you do right now if you supply a polymorphic first argument
02:47:18 <jmcarthur_work> aavogt, but what if f's implementation is later changed to actually use a method of C?
02:47:28 <jmcarthur_work> aavogt, f's type doesn't change, but things suddenly don't compile
02:48:00 <aavogt> anyways, I have to head out now.
02:48:28 <aavogt> we'll discuss the rest of this later
02:49:23 <lament> HaskellLove_: just ask if you have specific questions
02:51:10 <HaskellLove_> lament: in a book i read it talks about lambda as being the assembler for func languages. Actually some SK language is the last one, anyways... it translates Miranda first to extended lambda and then to lambda... I want to know why it translates to lambda, is it closer to the assembler language or what?
02:51:41 <bfh6558> I dont understand why haskell wont allow length ([1..15) + 3.4 ; both the type int of length and float of 3.4 are both of typeclass num.
02:52:01 <bfh6558> shouldn't that allow for the addition
02:52:19 <sproingie> > (length [1..15]) + 3.4
02:52:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:52:20 <lambdabot>    arising from the lit...
02:52:46 <sproingie> > (1::Int) + 3.4
02:52:47 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
02:52:47 <lambdabot>    arising from the lit...
02:52:54 <sproingie> there's your answer
02:53:06 <xerox> > genericLength [1..15] + pi
02:53:07 <lambdabot>   18.141592653589793
02:53:18 <sproingie> @type genericLength
02:53:20 <lambdabot> forall b i. (Num i) => [b] -> i
02:53:49 <c_wraith> :t pi
02:53:50 <lambdabot> forall a. (Floating a) => a
02:53:58 <sproingie> arguably it's a wart that length is restricted to Int
02:54:10 <sproingie> practically speaking it's fine that way
02:54:20 <c_wraith> bfh6558: the problem is that num declares that both of its arguments be the same type.
02:54:29 <c_wraith> :t (+)
02:54:33 <lambdabot> forall a. (Num a) => a -> a -> a
02:54:39 <bfh6558> oh
02:54:44 <bfh6558> i c
02:54:58 <bfh6558> :) thanks guy
02:55:03 <c_wraith> you're welcome
02:55:11 <bfh6558> guys*
02:56:35 <copumpkin> HaskellLove_: http://www.haskell.org/haskellwiki/Wadlers_Law
02:57:04 <copumpkin> HaskellLove_: BNF is a syntax for expressing grammars that in turn represent your language's syntax
02:57:21 <HaskellLove_> Too bad i cant find his book :(
02:57:29 <lament> HaskellLove_: Don't take analogies literally.
02:57:44 <sproingie> Wadler's Law sounds like what others call "bikeshedding"
02:58:36 <HaskellLove_> u guys have his book on torrent or rapid, i could not find it? introduction to functional programming
02:58:54 * sproingie sighs
02:59:05 * copumpkin is spoiled by an enormous library
02:59:50 <sproingie> i'm accumulating a nice stack of CS books i never finish
03:00:07 <osfameron> yay!  me too
03:00:20 <osfameron> I'm currently planning not to finish TaPL, over christmas
03:00:30 <Cale> hehe
03:00:33 <sproingie> i've been not finishing TaPL for a couple years now
03:01:58 <copumpkin> Veinor: you sure you want to export toNimber and nimRecip?
03:02:09 <copumpkin> Veinor: since they're already used as methods in your typeclass instances?
03:02:13 <Veinor> copumpkin: yeah, I dunno why I export nimRecip :P
03:02:28 <copumpkin> :)
03:02:32 <Veinor> as for toNimber, how else can I make sure people can't say Nimber (-5) ?
03:02:52 <Veinor> or would it be best to just apply abs to the argument and take that as Nimber 5
03:03:07 <copumpkin> that's about it, unfortunately
03:03:10 <copumpkin> nope, I'd throw an error
03:03:13 <Veinor> hm.
03:03:17 <Cale> Your choices are pretty much abs or error
03:03:18 <copumpkin> but toNimber is already fromInteger in the Num class
03:03:23 <Veinor> ah, true
03:03:26 <copumpkin> so if you type 5
03:03:33 <Veinor> but what if someone types Nimber 5?
03:03:34 <copumpkin> you're already getting toNimber if the type is right
03:03:42 <copumpkin> oh, don't export the constructor
03:03:58 <Veinor> but then people have no way of explicitly constructing a Nimber if I don't export toNimber.
03:04:10 <copumpkin> they do through the Num instance
03:04:16 <copumpkin> fromInteger = toNimber
03:04:23 <Veinor> so, as (5 :: Nimber)
03:04:23 <Veinor> ?
03:04:27 <copumpkin> yeah
03:04:31 <Veinor> ah, kay.
03:04:49 <ray> ah, implicit fromInteger
03:04:55 <Veinor> I'll change that and push it as 0.1.1
03:05:24 <c_wraith> What's that going to do when they provide an illegal value?
03:05:31 <c_wraith> > -1 :: Natural
03:05:33 <lambdabot>   * Exception: Natural: (-)
03:05:42 <c_wraith> I suppose that's not a bad approach
03:05:49 <ray> 3_3
03:06:00 <Veinor> yeah, I'd say error is better, since if you're trying to produce a negative nimber, you're doing something wrong.
03:06:10 <Veinor> the definition admits no natural extension
03:06:27 <copumpkin> unfortunately the haskell standards love negative numbers where none belong
03:06:50 <trofi> > (1 :: Natural) + 1
03:06:50 <lambdabot>   2
03:06:53 <trofi> > (1 :: Natural) - 1
03:06:54 <lambdabot>   0
03:07:08 <jix> > (1 :: Natural) + (-1)
03:07:09 <lambdabot>   * Exception: Natural: (-)
03:07:14 <Veinor> bleh. I need an emacs cheat sheet
03:07:43 <c_wraith> > (1::Natural) - 2
03:07:44 <lambdabot>   * Exception: Natural: (-)
03:08:00 <trofi> it could have slightly better error reporting :]
03:08:44 <trofi> > undefined :: Natural
03:08:45 <lambdabot>   * Exception: Prelude.undefined
03:11:30 <Veinor> man, I'm glad I wrote a unit test :D
03:12:29 <Veinor> hm, now that I think about it, I could probably speed up division by, when computing a / b, finding an n such that n * b either equals 1 or a
03:16:03 <mreh_> acme-now: An interface to the philosophical and metaphysical "now"
03:16:10 <Powerfool> Anybody up to some silly beginner questions?
03:16:52 <burp> just ask and don't ask to ask :>
03:16:55 <mreh_> Powerfool: shoot
03:17:22 <mreh_> preflex: seen mmorrow
03:17:23 <preflex>  mmorrow was last seen on #haskell 10 hours, 57 minutes and 48 seconds ago, saying: <<loop>>
03:17:44 <zygoloid> i always suspected mmorrow was implemented in haskell.
03:18:26 <Powerfool> I have a function of type: newChannel :: (MonadCHP m, Channel r w) => m (Chan r w a), which returns a new CHP channel. I want to have an arbitrary number of these in a list. However, when using replicateM I get a type error.
03:18:54 <mreh_> Powerfool: that is hardly a beginner question
03:19:01 <xerox> ?type replicateM
03:19:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
03:19:14 <mreh_> I was to answer a beginner question
03:19:33 <xerox> types match  replicateM n newChannel :: m [Chan r w a]
03:19:36 <Powerfool> mreh_: Oh, sorry then -- I'm trying to play with Haskell / CHP for the first time at the moment.
03:19:51 <mreh_> s/was/want
03:19:58 <xerox> (where n :: Int)
03:20:14 <Powerfool> xerox: That's what I thought too, but if I do this:
03:20:26 <Powerfool> replicateM 5 newChannel
03:20:30 <Powerfool> I get a type error. :|
03:20:52 <xerox> maybe the problem is that you are using it in a context where the monad is not a MonadCHP ?
03:21:22 <mreh_> what type does it expect?
03:21:33 <mreh_> it'll tell you what it inferred and what it expects
03:21:38 <mreh_> that might be the wrong way round
03:22:06 <Powerfool> It says "Ambiguous type variables r, w in the constraint ...".
03:22:13 <Powerfool> Channel r w.
03:23:06 <Powerfool> There's also: "Probable fix: add a type signature that fixes these type variable(s)." but I don't know what to make out of that ...
03:23:19 <xerox> do that!
03:23:36 <mreh_> :t m a :: IO a
03:23:37 <lambdabot>     Ambiguous occurrence `a'
03:23:37 <lambdabot>     It could refer to either `L.a', defined at <local>:11:0
03:23:37 <lambdabot>                           or `SimpleReflect.a', imported from SimpleReflect at State/L.hs:75:0-32
03:23:41 <mreh_> D'oh
03:23:57 <mreh_> :t m Int :: IO Int
03:23:58 <lambdabot> Not in scope: data constructor `Int'
03:24:09 <mreh_> wtf is wrong with you lambdabot?
03:24:17 <Powerfool> Hm, how would I do that?
03:24:42 <mreh_> (Channel r w :: Type sig)
03:24:59 <blueonyx> are Control.Concurrent.STM.TChan's chans lazy?
03:25:05 <mreh_> ignore me
03:25:09 <xerox> if it is not part of a bigger expression, give it the most general type by hand:  replicateN 5 newChannel :: (Monad m, Channel r w) => m [Chan r w a]
03:25:22 <ToRA> > map (*2) [a,b,c]
03:25:23 <lambdabot>   Ambiguous occurrence `a'
03:25:23 <lambdabot>  It could refer to either `L.a', defined at <local...
03:25:33 <blueonyx> > L.a
03:25:34 <lambdabot>   * Exception: I told you to stop
03:25:43 <mreh_> is she broken
03:25:45 <xerox> if it is part of a bigger expression, fix the type variables and eliminate unnecessary constraints
03:25:59 <ToRA> no, the SimpleReflect stuff is to do with letting you visualise stuff iirc
03:26:13 <ToRA> > map (+y) [x,y,z]
03:26:14 <lambdabot>   [x + y,y + y,z + y]
03:26:21 <ToRA> > map (f) [x,y,z]
03:26:22 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:26:23 <lambdabot>    `GHC.Show.Show b'
03:26:23 <lambdabot>      a...
03:26:49 <ToRA> of course remembering how to use it ...
03:27:16 <xerox> > map f [x,y,z] :: Expr
03:27:17 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
03:27:17 <lambdabot>         against inferred ...
03:27:25 <xerox> > map f [x,y,z] :: [Expr]
03:27:26 <lambdabot>   [f x,f y,f z]
03:27:28 <Veinor> all right, v0.1.1 uploaded
03:27:50 * hackagebot upload: nimber 0.1.1 - An implementation of (finite) nimbers (PatrickHurst)
03:28:17 <mreh_> > map f [a,b,c]
03:28:18 <lambdabot>   Ambiguous occurrence `a'
03:28:18 <lambdabot>  It could refer to either `L.a', defined at <local...
03:28:25 <mreh_> she's never done this before
03:28:27 <ksf> am I correct that I can emulate uniqueness typing with indexed monads or is my intuition off?
03:28:54 <xerox> mreh: not sure what the command is for flushing definitions, but it's that some ?let a = something before
03:29:01 <Veinor> @undef
03:29:29 <mreh_> is there a calendar of haskell events up anywhere? haskell.org just has a long list
03:29:44 <zygoloid> > map f [a,b,c]
03:29:45 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:29:45 <lambdabot>    `GHC.Show.Show b'
03:29:45 <lambdabot>      a...
03:29:51 <zygoloid> > map f [a,b,c] :: [Expr]
03:29:52 <lambdabot>   [f a,f b,f c]
03:29:57 <Powerfool> xerox: still struggling :|
03:30:08 <xerox> Powerfool: hpaste the whole context
03:30:20 <pastah_rhymez> sm!!
03:30:26 <pastah_rhymez> sm: pm
03:30:46 <Cale> Powerfool: It sounds like your program isn't doing enough to pin down which type of channel you want to create.
03:31:23 <HaskellLove_> shit I stopped reading the book i see it is useless to go on further if i dont start coding my compiler now and just use the book as reference
03:31:29 <zygoloid> ~/sb end
03:32:15 <Powerfool> xerox: I trimmed it down to just (in ghci): "let feeds = replicateM 5 newChannel". I tried some type annotations, but no luck so far.
03:33:01 <Powerfool> Cale: If I create channel one by one I also don't have to annotate. But I guess the type checker would do that for me based on when I use the channel the first time?
03:33:17 <Cale> yeah
03:33:46 <Cale> Hmm, maybe GHCi's extended defaulting rules are strange
03:34:13 <Cale> Powerfool: What are the types of the channels if you create them one at a time?
03:35:12 <Powerfool> Just simple integer channels.
03:36:12 <c_wraith> Powerfool:  The type inference mechanism should have no trouble with that.  can you hpaste the whole thing?
03:36:48 <Cale> Powerfool: I mean, what type does :t report?
03:37:04 <Cale> Powerfool: Each channel is parametrised by 3 types, by the looks of it
03:37:44 <Powerfool> c_wraith: it's really just that: "replicateM 5 newChannel" or "replicateM 5 newChannel :: (Monad m, Channel r w) => m [Chan r Int Int]". The former has a type mismatch, the latter a kind mismatch. :|
03:37:56 <Powerfool> Expected kind `* -> *', but `Int' has kind `*'.
03:38:01 <Powerfool> Or could this be just in ghci?
03:38:27 <xerox> can you paste what  :info Channel  says?
03:38:34 <xerox> (maybe not here, it can be long)
03:39:07 <Powerfool> class Channel r w where
03:39:07 <Powerfool>   newChannel' :: (MonadCHP m) => ChanOpts a -> m (Chan r w a)
03:39:07 <Powerfool>   sameChannel :: r a -> w a -> Bool
03:39:07 <Powerfool>  
03:39:35 <Powerfool> (Omitted some other stuff.)
03:39:37 <xerox> you see, r and w are type constructors
03:40:48 <xerox> but Int is a type (I may be forgetting some naming here, was there another name for type constructors of * -> * kind?)
03:41:49 <Cale> xerox: Not that I'm aware of
03:41:52 <c_wraith> Oh, does Channel use type families?  Those do break type inference.
03:42:50 <xerox> OK.  So Powerfool you'd better find out more about those 'r' and 'w' type constructors, they must mean something, so there are some useful choices for them.
03:43:09 <Cale> I think you usually want them to be Chanin and Chanout
03:43:18 <HaskellLove_> I am learning Haskell reference from start... so... data Ix i => Array i e  ... What is this Ix module, what the name means?
03:43:38 <Powerfool> xerox: ok, I see that there is more to it. Guess I have to go back to the docs. Thanks a lot for your help!
03:43:45 <Zao> HaskellLove_: It's a typeclass.
03:44:30 <c_wraith> HaskellLove_: The name means Index.  It's just a typeclass for things that can be used as array indices
03:44:33 <Powerfool> One more question actually: is GdH / Eden still working? There seems to be a lot of interest in parallel Haskell, but not such much (any more?) in distributed Haskell?
03:44:41 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ix.html
03:45:37 <Powerfool> I would like to write a distributed event-processing system in Haskell. A the moment CHP with protocol buffers over a socket seems to be a reasonable choice. Any comments / ideas?
03:49:41 <HaskellLove_> why does not this print me anything just empty space : index (2,20) 5, I have imported Data.Ix by the way
03:53:20 <HaskellLove_> actually it is ok now ok ok... just litle interpreter problems
04:03:50 <kmc> :t index
04:03:51 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
04:06:33 <HaskellLove_> :t array
04:06:34 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
04:10:01 <sinelaw> :t love
04:10:03 <lambdabot> Not in scope: `love'
04:10:09 <sinelaw> it sure isn't
04:12:16 <kmc> :(
04:13:01 <HaskellLove_> :t sinelaw's mother
04:13:02 <lambdabot> Not in scope: `sinelaw's'
04:13:02 <lambdabot> Not in scope: `mother'
04:13:09 <HaskellLove_> ah shit
04:13:27 <sinelaw> don't make me fix fix you
04:14:47 <HaskellLove_> anyways... guys, i just passed over Array documentation, if it is immutable why would u use it instead of a list?
04:15:14 <blueonyx> hi, i'm using the same mechanism for spawning threads as in rwh chap28 (STM) but on waitFor i get: thread blocked indefinitely, how comes that?
04:15:17 <kmc> why would you use an array over a linked list in Java or C++?
04:15:45 <HaskellLove_> oh i see kmc
04:15:51 <kmc> blueonyx, can you hpaste a small code example?
04:16:06 <kmc> HaskellLove_, an array has O(1) indexing
04:16:15 <kmc> with a list you have to walk from the beginning
04:16:17 <HaskellLove_> yes yes i know got it
04:16:19 <copumpkin> and has better locality
04:16:27 <copumpkin> in fact, it has locality in the first place
04:16:52 <Berengal> HaskellLove_: You can still do fast lookups, and it's possible to "update" an array in bulk, so you only have to copy it once. Not too painful if that works for whatever you're using it for.
04:17:22 <kmc> also see DiffArray, which has an immutable interface, but has the property that if you use the functional "modify" operator (//) and only access the "latest" version, it will be as fast as a mutable array
04:17:22 <HaskellLove_> got it
04:17:31 <kmc> also you can convert between mutable and immutable arrays
04:17:47 <Berengal> But stay away from boxed mutable arrays...
04:17:52 <kmc> why?
04:17:57 <copumpkin> kmc: sadly it's a lot slower than it should be
04:18:02 <Berengal> The garbage collector hates them
04:18:03 <kmc> i do think a lot of simple uses of arrays in Haskell would be better with Data.Sequence or Data.Map
04:18:18 <kmc> Berengal, just because they have a lot of pointers?
04:18:33 <Berengal> kmc: Yep, and it has to traverse the entire array if it's dirty
04:18:52 <Berengal> Even if it's in an older generation... as long as one of the objects in it is in a younger one
04:18:59 <kmc> :/
04:19:04 <HaskellLove_> oki doki, going next to Bits in the reference
04:19:13 <kmc> alphabetical? :)
04:19:40 <Berengal> Continuations next :P
04:19:46 <eivuokko> Alphabetically reading library docs?  Now, that's ... a job for computer.
04:20:25 <Berengal> Anyway, yes, Sequence is probably better than arrays and lists in many situations
04:20:35 <Berengal> At the end of the day, even arrays are trees
04:21:32 <HaskellLove_> alphabetical yes, you dont wanna be me :D
04:22:06 <kmc> how's that Berengal?
04:25:17 <Berengal> kmc: Hardware memory is tree-like
04:26:06 <Berengal> Otherwise you'd have linear traversing...
04:26:24 <Berengal> So really, memory lookups are already O(log n)
04:26:32 <Berengal> Where n is the size of your memory
04:26:56 <leimy> only if the tree is balanced. :-)
04:27:02 <leimy> otherwise it degrades
04:27:07 <Berengal> leimy: It is. And constant size.
04:27:27 <blueonyx> kmc (or anyone): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13943#a13943 for the indefinitly blocked thread with STM
04:27:31 <Berengal> Unless you hotplug new ram
04:27:44 <HaskellLove_> ah shit this is boring and pointless...at least now i learned to use the reference but i will go to euler #7 now...
04:27:56 <Berengal> HaskellLove_: Good man :)
04:28:33 <bfh6558> Im not sure i understand pattern matching with using :, [1,2,3] is equivalent to 1:2:3[] how? and moreso x:xs is like saying bind the first element of a list to x and the rest to xs?
04:29:04 <weebl> x:xs says there is an x on top of a list
04:29:07 <weebl> this list can be empty too
04:29:11 <Berengal> bfh6558: [x,y,z] is just syntactic sugar for x:y:z:[]
04:29:12 <nlogax> > 1:2:3:[]
04:29:13 <lambdabot>   [1,2,3]
04:29:42 <bfh6558> yeah now that i look at that i think i understand, just 1 followed by 2 followed by 3,
04:30:30 <weebl> > (:) 1 [2,3]
04:30:31 <lambdabot>   [1,2,3]
04:30:40 <bfh6558> weebl, x:xs is so general how do you infer a type list from that
04:30:56 <weebl> : is only used for lists really
04:30:56 <tombee> Hi, wondering if anyone could provide any feedback on my simple attempt at a basic neuron
04:30:58 <tombee> http://github.com/tombee/Perceptron/blob/master/perceptron.hs
04:31:00 <weebl> you could also use
04:31:02 <ezyang> :t (:)
04:31:03 <lambdabot> forall a. a -> [a] -> [a]
04:31:11 <weebl> (x:y:ys) - which would be a list with at least two elements
04:31:13 <tombee> I'm also wondering how I go about making this into a sort of 'object'
04:31:30 <tombee> As I can't get my head around how you would go about linking neurons together in haskell
04:31:41 <ezyang> tombee: You don't really, in Haskell
04:31:47 <ezyang> If you need "interfaces" you can use typeclasses
04:31:48 <tombee> Style/Function improvements are welcome :)
04:31:56 <bfh6558> purelyfunctional means no objects
04:32:22 <tombee> I understand that bfh6558, but I guess there must be a way of sort of grouping stuff together, instead of having a huge muddle of functions :)
04:32:23 <OscarZ> bfh6558: what are there instead of objects?
04:32:34 <bfh6558> interfaces
04:32:38 <ezyang> tombee: Types and modules :-)
04:32:38 <bfh6558> typeclasses
04:33:18 <ezyang> You can get encapsulation by selectively exporting data-structures and functions from a module
04:33:31 <bfh6558> OscarZ: objects imply imperative programming, state checking, all that jazz
04:34:05 <bfh6558> and usually a big mess of object/class heirarchy
04:34:21 <OscarZ> is it wrong to think that for example Just 4 is an instance of Maybe type ?
04:34:41 <bfh6558> its of several class types
04:34:48 <carlocci> is there a down to earth explanation for the practical man of what a typeclass or interface is and how they work?
04:34:48 <bfh6558> but no ints not really an instance
04:34:55 <bfh6558> the number 4 is very general
04:35:07 <bfh6558> its simply a number, you cant really think of a tangible 4
04:35:18 <ezyang> OscarZ: Mmm, the intuition works a little bit.
04:35:22 <weebl> :t (Just 4)
04:35:23 <lambdabot> forall t. (Num t) => Maybe t
04:37:02 <ezyang> OscarZ: You'll get in a little bit of trouble if you try to paste superclasses onto that model
04:37:38 <kmc> OscarZ, "type" and "typeclass" are two differenc concepts in Haskell.  Maybe builds types, not typeclasses
04:37:42 <OscarZ> is there anything from the OO world that i could map into this stuff that wouldnt confuse me ? ;)
04:37:47 <stoop> carlocci, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
04:37:49 <HaskellLove_> guys can u point me to some blog creator or whatever, i want to start a blog and write my thinking on the euler problems there
04:37:55 <kmc> the relations are "expression E has type T" and "type T is an instance of typeclass C"
04:38:46 <carlocci> stoop, thanks: reading...
04:39:28 <stoop> carlocci, the author, BONUS, is here.
04:40:08 <copumpkin> you get free pink unicorns if you talk to bonus
04:40:59 <OscarZ> ok, what kind of properties do typeclasses have?
04:41:12 <copumpkin> they are relations!!!
04:41:29 <jmcarthur_work> HaskellLove_, wordpress.com
04:41:50 <bfh6558> instances vs types are a little hard, oop uses qualities and how qualities interact, functional prog'ing uses qualitative properties and behaviours of quantities/numbers (alteast thats what i've gathered out of 3.5 chapters of learnyouhaskell)
04:42:27 <carlocci> ok, I'll hammer him, until I get my pink unicorn then :)
04:42:31 <tass> Okay... so this is sorta weird.  ghc first claims that it can't find Control.Monad.Reader and then says that it found it in two packages
04:42:39 <tass> Wat?
04:42:42 <bfh6558> typeclasses provide interfacing, or how different quantitative behaviors can interact between eachother
04:42:55 <ezyang> tass: It sounds like you've got two monad libraries installed
04:43:07 <ezyang> you can use XPackageImports to explicitly specify one
04:43:21 <tass> mtl and monads-fd
04:43:36 <tass> How would I go about removing one? : P
04:43:37 <ezyang> yup
04:43:48 <ezyang> you could hide it with ghc-pkg
04:43:50 <eivuokko> tass, you can hide one with ghc-pkg
04:43:53 <ezyang> otherwise, probably cabal
04:44:07 <tass> cabal doesn't seem to have a deinstall/uninstall/remove command
04:44:17 <ezyang> o rly
04:44:20 * ezyang goes and checks 
04:44:31 <kmc> @src Eq
04:44:31 <lambdabot> class  Eq a  where
04:44:31 <lambdabot>     (==), (/=)   :: a -> a -> Bool
04:44:36 <tass> Not when I typed cabal --help anyway ; P
04:44:43 <ezyang> well I'll be darned
04:44:52 <eivuokko> You can uninstall packages by using ghc-pkg to find what files it uses and then removing the entry with the same tool.
04:44:53 <tass> Pretty funky
04:44:59 <dcoutts> ezyang: nope, it's not made it to the top of the TODO list yet
04:45:00 <ezyang> anyway, hiding the package will be basically equivalent
04:45:22 <tass> Soooo... which one is the keeper? mtl or monad-fd? : P
04:45:23 <kmc> OscarZ, that means "Any type T which is an instance of the Eq typeclass has defined functions (==) and (/=) of type a -> a -> Bool"
04:45:33 <kmc> meaning, Eq is the class containing those types which have comparison
04:45:34 <ezyang> tass: mtl is the de facto standard
04:45:42 <tass> Alrighty then
04:45:46 <ezyang> tass: monad-fd has some nice qualities, and is used by transformers
04:45:57 <ezyang> no one knows what the hell is going on with all the monad libraries
04:46:06 <kmc> so each typeclass contains some "methods", and each instance implements the methods of the class for the specific type
04:46:12 * tass sobs silently
04:46:22 <kmc> @src Eq ()
04:46:22 <lambdabot> Source not found. That's something I cannot allow to happen.
04:46:26 <tass> Do want standards!
04:46:41 <idnar> (==) = const True
04:46:43 <ezyang> Anyone have an example of an endofunctor in Haskell?
04:46:53 <kmc> ezyang, every instance of Functor
04:46:55 <OscarZ> kmc: ok, makes sense
04:46:57 <idnar> aren't all Func... yeah
04:47:00 <ezyang> oh, really?
04:47:03 <kmc> yes
04:47:12 <ezyang> Oh, right, because we're in the Hask category
04:47:13 <OscarZ> kmc: they really sound like interfaces in OO
04:47:18 <kmc> OscarZ, they are similar
04:47:28 <bfh6558> length' ss = sum [1 | _ <- ss] Anyone see any syntax errors with this? ghci wont load this giving me a parse error on the '='
04:47:29 <Paczesiowa> is there a paper on ST monad?
04:47:31 <idnar> an endofunctor is just a functor from a category to itself, Functors are Hask -> Hask (theoretically)
04:47:41 <Baughn> > 10*2^24+1
04:47:42 <lambdabot>   167772161
04:47:57 <Botje> bfh6558: some error before that definition?
04:48:13 <kmc> if F is a functor, the types (F a) are also objects of Hask, and the arrows (fmap f) :: F a -> F b  are also functions in Hask
04:48:19 <ezyang> Wow, the constant functor sounds really useless. ^_^
04:48:25 <bfh6558> hmm, theres only 1 line before that definintion and it loaded and evaluated correctly
04:48:33 <kmc> in other words, the Functor typeclass does not capture all functors
04:48:43 <idnar> ezyang: no more useless than the "const" function
04:48:58 <ezyang> fair enough :-)
04:49:04 <xerox> ?docs Control.Monad.ST
04:49:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
04:49:12 <copumpkin> bfh6558: if you're defining it in ghci, you need a let
04:49:14 <xerox> Paczesiowa: it's in the first comment
04:49:19 <OscarZ> kmc: is it incorrect to think typeclasses as OO interfaces, types as OO classes .. data constructors as immutable instances of classes ?
04:49:26 <bfh6558> copumpkin: im defining it in a .hs and trying to load it into gchi
04:49:34 <kmc> "types as OO classes" will be very misleading i think
04:49:46 <OscarZ> ok
04:49:57 <bfh6558> OscarZ: think of math class, defining behavior of functions
04:50:03 <kmc> it's more the other way -- in OO languages, some types are classes
04:50:07 <bfh6558> and how combining functinos changed the output
04:50:12 <bfh6558> id say those are more like interfaces
04:50:16 <bfh6558> f(g)
04:50:18 <idnar> the main difference between typeclasses and interfaces is universal qualification vs. existential qualification
04:50:23 <Paczesiowa> xerox: stupid me - trying to google that:)
04:50:24 <bfh6558> f following g follwoing h
04:50:42 <kmc> informally "type class" and "type set" would mean the same thing
04:50:44 <idnar> when you declare a variable of type SomeInterface in, say, Java, you're saying that it's some particular instance of SomeInterface, but you don't know which one
04:50:46 <bfh6558> for f to follow g they must interface correctly
04:50:52 <kmc> a typeclass is a set of types -- the types for which you have an instance
04:51:13 <idnar> when you have the type (SomeClass a) => a in Haskell, you're saying that it can be all instances of SomeClass
04:51:27 <bfh6558> and then y Hask (theoretically)
04:51:27 <bfh6558> 15:43 <    Baughn> > 10*2^24+1
04:51:27 <bfh6558> ou Hask (theoretically)
04:51:27 <bfh6558> 15:43 <    Baughn> > 10*2^24+1
04:51:35 <ezyang> Wait, if functors are homomorphisms, what do forgetful functors do?
04:51:36 <bfh6558> wtf
04:52:05 <xerox> ezyang: they'll not be injective for example
04:52:26 <copumpkin> ezyang: they forget something!
04:52:28 <ezyang> oh, right homomorphism != isomorphism
04:53:11 <kmc> OscarZ, idnar makes a good point.  in Java you can have a value whose type is an interface.  but in Haskell we strictly separate interface and "concrete" type.  interfaces are properties of or restrictions on concrete types
04:53:22 <ezyang> wait, but Wikipedia claims that "a homomorphism is a structure-preserving map"
04:53:26 <ezyang> hmmm....
04:53:44 <kmc> specifically, they're restrictions we use with parametric polymorphism, which is kind of like generic functions in Java
04:53:53 <xerox> ezyang: i.e. algebraically it behaves well with respect the defined operations
04:54:00 <kmc> it's important to understand unconstrained polymorphism before you apply typeclasses to it
04:54:01 <kmc> so e.g.
04:54:02 <kmc> :t map
04:54:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:54:08 <kmc> is unconstrained polymorphism
04:54:18 <OscarZ> idnar: interesting.. what about java generics ?
04:54:34 <ezyang> OscarZ: You /basically/ get that for free in Haskell
04:54:38 <OscarZ> kmc: ok
04:54:42 <kmc> that's what our parametric polymorphism is
04:55:54 <idnar> OscarZ: I don't understand Java generics at all, so I can't answer that one
04:56:06 <kmc> in Java you could say:   <T implements Foo> bool f(T x)
04:56:18 <kmc> that is very much like this Haskell type:   (Foo t) => t -> Bool
04:56:47 <kmc> the stuff to the left of (=>) is a list of constraints to be satisfied by the types mentioned on the right
04:57:06 <kmc> in this case, the single constraint is that whatever type is filled in for the type variable "t" must be an instance of the "Foo" typeclass
04:58:16 <OscarZ> ok
04:59:33 <blueonyx> .oO(interesting that 'stablePtr <- myThreadId >>= newStablePtr' keeps the thread blocked indefinitely away)
04:59:58 <ezyang> Does anyone know any useful functors that are just functors (i.e. do not have sensible implementations for pointed/applicative/monad)
05:00:18 <Twey> A non-pointed functor?
05:00:32 <ejpbruel> hi everybody
05:00:41 <Twey> How would you get such a thing?
05:00:45 <ezyang> Twey: Yeah
05:01:09 <Twey> Sounds rather difficult to construct
05:01:10 <ejpbruel> i was wondering if anybody here has any idea why the STG is more efficient than an ordinary tagless g-machine
05:01:34 <ezyang> Actually, I bet (,) a is not pointed
05:01:50 <ezyang> since there's no way to pick a "default" value for a
05:02:22 <ToRA> ezyang: you mean (,) as in type Two a = (a,a) ?
05:02:43 <Paczesiowa> xerox: do you understand that forall in runST?
05:03:03 <ezyang> ToRA: I think that's pointed
05:03:09 <ToRA> yeah it is
05:03:14 * ToRA just looks up pointed
05:03:44 <ezyang> but TwoPrime a b = (a, b) wouldn't be
05:04:01 <xerox> ?type runST
05:04:02 <lambdabot> forall a. (forall s. ST s a) -> a
05:04:09 <ezyang> I sort of feel like I'm cheating there though
05:04:18 <kmc> yeah, that's why it's (Monoid a) => Monad ((,) a)
05:04:28 <ezyang> Right. In which case you use zero
05:04:35 <xerox> Paczesiowa: it's easy to get it wrong
05:05:19 <kmc> hmm what's the question about ST?
05:05:27 <xerox> It's covariance versus contravariance
05:06:01 <ejpbruel> anybody here with any knowledge about graph reduction?
05:06:16 <Paczesiowa> xerox: runEither :: (forall e. Either e a) -> a, I get the missed pattern (for Left), but in those ST docs they say that this forall makes sure that s cannot escape to other code, so my exception also shouldn't be able to escape, right?
05:06:48 <kmc> :t runEither
05:06:49 <lambdabot> Not in scope: `runEither'
05:07:16 <Paczesiowa> runEither y = case y of Right x -> x, runEither :: (forall e. Either e a) -> a
05:08:13 <xerox> Paczesiowa: not sure what you mean by exception there, but surely one can't do anything with a Left there, because whatever one wants to do with it, it should work for all values of all types Left t
05:08:44 <bfh6558> myLength :: (Num b) [a] -> b mylength [] = 0 mylength (_:xs) = 1 + mylength xs    am i missing a case here? gettinga  Non-exhaustive patterns in functino
05:08:57 <kmc> the intent is that the return value of runST can't contain anything parametrized on that "s", like an STRef
05:09:48 <Paczesiowa> I just need total function runEither :: EIther e a -> a, any tricks to make other computations sure that it's not Left?
05:09:56 <Paczesiowa> *make sure
05:10:55 <Paczesiowa> perhaps, that GADT trick for non-null lists
05:12:40 <kmc> why do you need it to be total?
05:12:58 <Paczesiowa> I like total things
05:13:00 <kmc> there is no total function of type (Either e a -> a); you'll have to modify the type somehow
05:13:18 <copumpkin> Either a a -> a
05:13:20 <copumpkin> muahahaha
05:13:32 <kmc> (e -> a) -> Either e a -> a
05:13:33 <roconnor> @djinn Either a a -> a
05:13:34 <lambdabot> f a =
05:13:34 <lambdabot>     case a of
05:13:34 <lambdabot>     Left b -> b
05:13:34 <lambdabot>     Right c -> c
05:13:38 <kmc> @djinn (e -> a) -> Either e a -> a
05:13:38 <lambdabot> f a b =
05:13:38 <lambdabot>     case b of
05:13:38 <lambdabot>     Left c -> a c
05:13:40 <lambdabot>     Right d -> d
05:13:58 <kmc> @djinn (a,b) -> Either a b
05:13:58 <lambdabot> f (a, _) = Left a
05:14:02 <Paczesiowa> kmc: all my functions that result in Left, also put some things into context, and thus cannot be "run".
05:16:33 <copumpkin> I love djinn
05:16:54 * absentia dreams of djinni with the light brown hair ....
05:17:59 <sinelaw> @djinn a -> b -> a
05:17:59 <lambdabot> f a _ = a
05:18:14 <sinelaw> also known as const
05:18:37 <Paczesiowa> @djinn (Monad m) => (s -> m (a,s)) -> (a -> s -> m (b,s)) -> (s -> m (b,s))
05:18:37 <lambdabot> -- f cannot be realized.
05:18:57 <sinelaw> @djinn a -> b -> c
05:18:58 <lambdabot> -- f cannot be realized.
05:19:19 <sinelaw> @djinn Int -> Int -> Int
05:19:20 <lambdabot> Error: Undefined type Int
05:19:30 <ezyang> @djinn a -> a -> a -> a
05:19:30 <lambdabot> f _ _ a = a
05:19:36 <ezyang> eehee
05:23:08 <Cale> @djinn a -> a -> Either a a
05:23:08 <lambdabot> f _ a = Left a
05:23:29 <Beelsebob> @djinn a -> a -> (a,a)
05:23:29 <lambdabot> f a b = (b, a)
05:23:33 <Beelsebob> interesting
05:23:35 <Beelsebob> random too
05:24:04 <Beelsebob> @djinn a -> a -> a -> (a,a)
05:24:04 <lambdabot> f _ a b = (b, a)
05:24:14 <Cale> @djinn a -> a -> a -> (a,a,a)
05:24:15 <lambdabot> f a b c = (c, b, a)
05:24:58 <Vulpyne> It must use list prepending, resulting in the reversed output.
05:25:06 * Beelsebob nods
05:25:22 <Cale> Yeah, it appears to have a stack of unused arguments of a given type
05:26:02 <Cale> @djinn a -> a -> a -> (a,a,a,a)
05:26:02 <lambdabot> f a b c = (c, c, b, a)
05:26:52 <Cale> @djinn a -> a -> a -> b -> b -> b -> b -> (a,a,a,a,a,a,b,b,b,b,b,b)
05:26:52 <lambdabot> f _ _ a b c d e = (a, a, a, a, a, a, e, e, e, d, c, b)
05:27:08 <Cale> weird
05:27:14 <tensorpudding> djinn is kinda odd
05:27:15 <HaskellLove_> Anyone familiar with Sieve of Eratosthenes algorithm? i wanna ask something
05:27:22 <Cale> HaskellLove_: yes
05:27:49 <roconnor> Paczesiowa: put some things into context?
05:27:56 <Cale> (though it's probably more effective just to ask the question)
05:28:00 <roconnor> Paczesiowa: what are you doing?  It sounds interesting
05:28:25 <copumpkin> HaskellLove_: it can be implemented nicely
05:28:29 <copumpkin> in haskell
05:28:46 <Cale> Well, depends on what counts :)
05:28:47 <absentia> yes
05:28:58 <jix> is there something like amap but with indices for the mapping function?
05:28:59 <HaskellLove_> Cale: I understood how it works except the final thing, when you square to check if to stop? why does that work from math point of view i try to figure out
05:29:25 <c_wraith> HaskellLove_: if you haven't found a factor less than the square root, there's no greater factor until n
05:29:36 <c_wraith> HaskellLove_: that's kind of the definition of a square root
05:29:44 <Paczesiowa> roconnor: pure checked exceptions
05:30:04 <roconnor> what is a context?
05:30:42 <Paczesiowa> myAssoc :: (VarNotFound record result) => String -> [(String, b)] -> Either (record -> result) b
05:30:44 <ezyang> Hey... does anyone have any functor lambdacats?
05:30:50 <HaskellLove_> c_wraith can u point me to some link to see this in action?
05:31:13 <c_wraith> HaskellLove_: .... no.  I'm not sure anyone has ever illustrated this point.  It seems too obvious.
05:31:23 <Paczesiowa> roconnor: it's like Jose Iborra library, but no casts and no typeable
05:31:26 <xerox> HaskellLove_ consider n = a*b with a,b both greather than sqrt(n), then a*b > sqrt(n)*sqrt(n) but that contradicts the hypothesis
05:32:03 <xerox> (or it's simply false because it says n > n)
05:32:05 <Cale> HaskellLove_: Suppose that k is the smallest factor of n, and that k > sqrt(n). Then if n is reducible as n = kl where l is the product of the rest of the factors, and so l > k, we have n = kl > k^2 > sqrt(n)^2 = n
05:32:12 <Berengal> HaskellLove_: If n is the square root of N, n*n = N. For all x > n, x * y = N -> y < n
05:32:13 <Cale> HaskellLove_: and so n > n.
05:32:13 <c_wraith> thank you xerox.  I was feeling too snarky to answer properly.
05:32:23 <absentia> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
05:32:49 <ezrakilty> is there a reason why downloads on a hackage page are at the bottom, below the fold? can we put them at the top?
05:33:13 <roconnor> Paczesiowa: losely speaking, it seems to me that you should have Either e1 (Either e2 ... a), and remove things as you handle exceptions.
05:33:14 <Paczesiowa> ezrakilty: you're not supposed to use hackage directly I think
05:33:23 <copumpkin> HaskellLove_: best way is to avoid that altogether
05:33:26 <roconnor> Paczesiowa: thus when you are exception free, you are left with a
05:33:29 <roconnor> no need for runEither
05:33:42 <c_wraith> @hackage primes
05:33:42 <lambdabot> http://hackage.haskell.org/package/primes
05:33:47 <Cale> HaskellLove_: Therefore, if the smallest nontrivial factor of n is larger than its square root, n must be irreducible.
05:33:57 <Cale> (and therefore prime)
05:34:13 <Berengal> ezrakilty: The hackage website is more for browsing. Cabal is for downloading from it (amongst other things)
05:34:14 <c_wraith> That's an amusing package.  It consists pretty much solely of an implementation of a list of primes based on the n'neill paper
05:34:24 <roconnor> Paczesiowa: though perhaps it is more practical to associate the Eithers the otherway. (Either (Either e1 ...) a)
05:35:14 <Berengal> The O'Neill paper is one of my favorite papers...
05:35:33 <c_wraith> It's a fun paper.  easy to grasp, well-written, and produces some interesting results.
05:36:01 <Paczesiowa> roconnor: I don't think that would be usable - I want to write code like "if b then throw e1 else throw e2", not that easy to turn that to nested Eithers
05:36:26 <Berengal> c_wraith: Indeed. It's one of the few papers I've understood properly on my first read-through
05:36:38 <roconnor> Paczesiowa: well, you'd need to abuse the class mechisim
05:37:03 <roconnor> but ya, it'd be hard
05:37:24 <ezyang> Which paper is this?
05:37:30 <Paczesiowa> roconnor: don't worry there's plenty of abuse:)
05:37:58 <Berengal> ezyang: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
05:38:00 <Paczesiowa> roconnor: Left value is Oleg's polymorphic variant on steroids
05:38:32 <ezyang> O, the genuine Sieve of Erastothenes
05:38:36 <ezyang> That's a cool one.
05:39:04 <ezrakilty> Berengal, Paczesiowa: why is that? seems it's nice to have a place to browse and also download
05:39:05 <Paczesiowa> roconnor: I could put the Right/OK also into polymorphic variant, but I have some problems (it has to be polymorphic), and it would be slow probably.
05:39:08 <Berengal> The only thing I don't like about it is that after I read it I stopped implementing prime-finding algorithms
05:39:18 <absentia> deja vu
05:39:22 <HaskellLove_> that paper is confusing, i must be extremely dumb ass
05:39:27 <Paczesiowa> ezrakilty: use cabal-install
05:39:36 <roconnor> Paczesiowa: how do you type catch?
05:39:45 <absentia> http://www.haskell.org/pipermail/haskell-cafe/2007-February/022666.html
05:40:04 <Berengal> ezrakilty: Why do you want to download and install stuff manually when cabal can do it for you?
05:40:14 <ezrakilty> i don't think the existence of an alternative argues for not improving a service...
05:40:15 <Berengal> ezrakilty: Also, you can use cabal to sort-of-browse.
05:40:16 <Paczesiowa> roconnor: are you familiar with Oleg's polymorphic variants?
05:40:20 <roconnor> nope
05:40:21 <ezrakilty> anyway i'm trying to install cabal!
05:41:11 <Berengal> ezrakilty: If we put the download on top of the hackage page, something else would have to be moved down. As it is, the package metadata and documentation links are on top, which suits me just fine, since that's just about the only thing I use that site for.
05:41:47 <Berengal> Download links on top would just get in the way, at least for me (but I guess for many others as well. Hands up people!)
05:41:53 <Paczesiowa> roconnor: polymorphic variant is a function that takes record/dictionary of all the posibilites and returns result. I just abused some more to return itself if particular error case isn't handled
05:42:27 <Paczesiowa> roconnor: atm it's super ugly - 20 loc and 2 classes of boilerplate per exception
05:42:54 <mreh> what stops me just encapsulating a monad inside another, instead of using a transformer
05:43:01 <mreh> like State s (IO a)
05:43:15 <Paczesiowa> mreh: nothing
05:43:16 <Berengal> mreh: You can't "lift" then
05:43:38 <c_wraith> mreh:  That has the downside of being unable to actually *do* IO.
05:43:40 <Paczesiowa> :t return getLine :: State Int (IO String)
05:43:41 <lambdabot> State Int (IO String)
05:43:49 <Berengal> Also, a State s (IO a) is different from a StateT s IO a
05:43:55 <c_wraith> mreh: so you can't base decisions at the state level on IO results.
05:44:02 <Berengal> @unmtl StateT s IO a
05:44:02 <lambdabot> s -> IO (a, s)
05:44:47 <Gracenotes> down with newtypes :x
05:45:01 <Berengal> I like newtypes...
05:45:29 <Berengal> They're alot nicer than nested products and sums of everything...
05:45:53 <Gracenotes> quite nice they are, but they muddy up making basic sense of some monads
05:46:09 <jmcarthur_work> i like newtypes because they usually mean i saved a lot of work
05:46:36 <jmcarthur_work> type composition ftw!
05:46:55 <Paczesiowa> can someone explain to me safeHead function from GADT wiki? where does Safe come from in Cons 1 Nil ?
05:47:07 <Berengal> Gracenotes: Agreed on that point, but there really aren't _that_ many monads for the basic types...
05:47:07 <jmcarthur_work> Paczesiowa, link?
05:47:15 <Paczesiowa> http://en.wikibooks.org/wiki/Haskell/GADT
05:48:19 <Cale> Paczesiowa: You can only apply it to lists which are provably nonempty
05:48:21 <Berengal> Paczesiowa: Look at the type of Cons
05:48:25 <jmcarthur_work> Paczesiowa, you mean the phantom type Safe?
05:48:26 <Gracenotes> Berengal: do notation doesn't help, either, for comprehending it. But if you're actually writing code, there is an advantage to treating it as a newtyped black box
05:48:36 <Gracenotes> so you gain some clarity in that respect (for losing it in others)
05:48:44 <heoa> How can you get the first ten derivatives of f(x)=sqrt(x^4+3x)-sqrt(3x)  ?
05:48:59 <mreh> > do { g <- getStdGen; randoms g }
05:49:00 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO b'
05:49:00 <lambdabot>         against inferred typ...
05:49:05 <ezyang> heoa: Wrong chan?
05:49:13 <Paczesiowa> Berengal: I'm looking, it doesn't say that Cons returns MarkedList t Safe
05:49:43 <mreh> > do { g <- getStdGen; randoms g :: [Int] }
05:49:44 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO b'
05:49:44 <lambdabot>         against inferred typ...
05:49:45 <Gracenotes> ezyang: I'd venture to say "automatically" though
05:49:47 <Paczesiowa> Berengal: so how come safeHead accepts it?
05:50:13 <ezyang> Gracenotes: fair enough
05:50:17 <Berengal> Paczesiowa: Oh, I was looking at the earlier one... In the later, the type of Cons is decided by the place it's used
05:50:20 <Paczesiowa> mreh: return $ randoms g ?
05:50:25 <ezyang> Wait, I just saw a paper about that
05:50:33 <Paczesiowa> Berengal: oh
05:50:33 <jmcarthur_work> Paczesiowa, Cons seems to create MakedLists that can be accepted by functions that take both Safe or Unsafe lists
05:50:44 <Paczesiowa> clever
05:50:44 <ezyang> http://conal.net/blog/posts/beautiful-differentiation/
05:50:46 <Berengal> Paczesiowa: Because Cons is polymorphic, it can return any type in the phantom parameter
05:50:48 <jmcarthur_work> Paczesiowa, note that the type parameter is polymorphic
05:51:10 <Cale> heoa: Ask a computer algebra system?
05:51:18 <Paczesiowa> Berengal, jmcarthur_work: thanks
05:51:19 <Cale> heoa: Doing it by hand will take quite a while.
05:51:22 <jmcarthur_work> Paczesiowa, however, you will not be able to pass the same MarkedList to a function the accepts only Safe and another that only accepts Unsafe
05:51:32 <Cale> heoa: They get pretty complicated
05:51:38 <jmcarthur_work> Paczesiowa, since that would mean it has to have both types :)
05:52:54 <mreh> does lambdabot no return IO?
05:53:05 <mreh> she just says <IO>
05:53:16 <jmcarthur_work> mreh, lambdabot will not *execute* IO
05:53:17 <mreh>  <IO [Int]> specifically
05:53:23 <jmcarthur_work> only evaluate it
05:53:31 <mreh> okay, i can use show though
05:53:33 <Cale> heoa: The 10th derivative is (14175*(-143548119*Sqrt[x] - 453811248*x^(7/2) - 641455848*x^(13/2) - 526559616*x^(19/2) - 1326150144*x^(25/2) + 5224227840*x^(31/2) - 5238411264*x^(37/2) + 1281540096*x^(43/2) - 73138176*x^(49/2) + 393216*x^(55/2) + 47849373*Sqrt[3]*Sqrt[x*(3 + x^3)] + 143548119*Sqrt[3]*x^3*Sqrt[x*(3 + x^3)] + 191397492*Sqrt[3]*x^6*Sqrt[x*(3 + x^3)] + 148864716*Sqrt[3]*x^9*Sqrt[x*(3 + x^3)] + 74432358*Sqr
05:53:33 <Cale> t[3]*x^12*Sqrt[x*(3 + x^3)] + 24810786*Sqrt[3]*x^15*Sqrt[x*(3 + x^3)] + 5513508*Sqrt[3]*x^18*Sqrt[x*(3 + x^3)] + 787644*Sqrt[3]*x^21*Sqrt[x*(3 + x^3)] + 65637*Sqrt[3]*x^24*Sqrt[x*(3 + x^3)] + 2431*Sqrt[3]*x^27*Sqrt[x*(3 + x^3)]))/(1024*x^(19/2)*(3 + x^3)^9*Sqrt[x*(3 + x^3)])
05:53:43 <jmcarthur_work> mreh, right, because show is pure
05:53:54 <jmcarthur_work> Cale, helpful...
05:53:54 <heoa> Cale: did you do it with Haskell?
05:54:03 <Cale> heoa: No, mathematica
05:54:34 <heoa> Cale: how can you find the first three terms with Haskell?
05:54:59 <heoa> I mean first der, second der, thirth der
05:55:00 <Cale> Write an expression differentiator
05:55:08 <Cale> third*
05:55:20 <mauke> preflex: 6st 1 2 3
05:55:21 <preflex>  1st 2rd 3th
05:55:23 <roconnor> deriv (\x -> sqrt(x^4+3x)-sqrt(3x))
05:55:28 <roconnor> > deriv (\x -> sqrt(x^4+3x)-sqrt(3x))
05:55:29 <lambdabot>   No instance for (GHC.Num.Num
05:55:29 <lambdabot>                     (Data.Number.Dif.Dif a -> ...
05:55:37 <roconnor> > deriv (\x -> sqrt(x^4+3*x)-sqrt(3*x))
05:55:38 <lambdabot>   -0.375->
05:55:38 <lambdabot>    NaN
05:55:38 <lambdabot>  -0.75->
05:55:38 <lambdabot>    NaN
05:55:38 <lambdabot>  -1.5->
05:55:40 <mreh> :t print
05:55:40 <lambdabot> [5 @more lines]
05:55:42 <lambdabot> forall a. (Show a) => a -> IO ()
05:55:44 <roconnor> oops
05:55:47 <roconnor> > deriv (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x
05:55:48 <lambdabot>   ((1 * x + x * 1) * (x * x) + x * x * (1 * x + x * 1) + 3 * 1) * recip (2 * ...
05:55:52 <Paczesiowa> Berengal, jmcarthur_work: why safeHead is not-exhaustive?
05:56:04 <jmcarthur_work> Paczesiowa, what do you mean not exhaustive?
05:56:10 <roconnor> > (deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x
05:56:11 <lambdabot>   ((1 * 1 + 1 * 1) * (x * x) + (1 * x + x * 1) * (1 * x + x * 1) + ((1 * x + ...
05:56:26 <Paczesiowa> jmcarthur_work: compiling with -Wall complains about missing Nil case
05:56:42 <roconnor> > (deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x
05:56:44 <lambdabot>   ((1 * 1 + 1 * 1) * (1 * 1 + 1 * 1) + ((1 * 1 + 1 * 1) * (1 * 1 + 1 * 1) + (...
05:57:04 <jmcarthur_work> Paczesiowa, ghc probably can't tell that the list can't be empty from the type
05:57:22 <jmcarthur_work> which is kind of dumb, but whatever
05:57:52 <jmcarthur_work> roconnor, would be nice if that was normalized...
05:58:27 <roconnor> > reduce $ (deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x
05:58:29 <lambdabot>   ((1 + 1 * 1) * (1 * 1 + 1 * 1) + ((1 * 1 + 1 * 1) * (1 * 1 + 1 * 1) + (1 * ...
05:59:08 <roconnor> > (reduction $ (deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x)!!100
05:59:09 <lambdabot>   Not in scope: `reduction'
05:59:42 <mreh> do { g <- newStdGen; return . show . take 10 . randoms $ g }, how goes GHC know what type of Random to return here? I haven't specified a type, yet it still returns integers
06:00:03 <roconnor> > iterate reduce ((deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x) !! 100
06:00:05 <lambdabot>   24 * negate ((2 * (24 * negate ((2 * ((2 * (x * x) + (1 * x + x * 1) * (1 *...
06:00:11 <roconnor> > iterate reduce ((deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x) !! 200
06:00:13 <lambdabot>   24 * negate ((2 * (24 * negate ((2 * ((2 * (x * x) + (1 * x + x * 1) * (1 *...
06:00:25 <roconnor> > iterate reduce ((deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv . deriv) (\x -> sqrt(x^4+3*x)-sqrt(3*x)) x) !! 1000
06:00:27 <lambdabot>   24 * negate ((2 * (24 * negate ((2 * ((2 * (x * x) + (1 * x + x * 1) * (1 *...
06:00:32 <roconnor> :(
06:00:41 <Paczesiowa> jmcarthur_work: lookes like it was fixed in 6.12
06:01:12 <Paczesiowa> *looks
06:02:27 <James__d> Join #crustytampon !!!!!
06:02:29 <James__d> Join #crustytampon !!!!!
06:02:29 <James__d> Join #crustytampon !!!!!
06:02:32 <James__d> Join #crustytampon !!!!!
06:02:32 <James__d> Join #crustytampon !!!!!
06:02:32 <James__d> Join #crustytampon !!!!!
06:02:33 <James__d> Join #crustytampon !!!!!
06:02:33 <James__d> Join #crustytampon !!!!!
06:02:33 <James__d> Join #crustytampon !!!!!
06:02:35 <James__d> Join #crustytampon !!!!!
06:02:37 <James__d> Join #crustytampon !!!!!
06:02:37 --- mode: ChanServ set +o dcoutts
06:02:39 <James__d> Join #crustytampon !!!!!
06:02:40 --- mode: dcoutts set +b *!n=somethin@209.56.61.28
06:02:40 --- kick: James__d was kicked by dcoutts (dcoutts)
06:02:56 <HaskellLove_> primes = sieve [2..]            sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p > 0]  Should I use an array instead of list? I mean, when I do: let a = take 10001 primes and then a !! 10001 it is fuckin slow, it traverses the list to get to the 10001 element and with arrays you have random access right?
06:03:16 <c_wraith> HaskellLove_: then you lose laziness
06:03:44 <c_wraith> HaskellLove_: Also, it's not slow because of the list traversal.  It's slow because it's the wrong algorithm.  (see the paper we've mentioned several times)
06:04:00 <jmcarthur_work> c_wraith, you don't necessarily lose laziness if you use unboxed arrays
06:04:02 <jmcarthur_work> err
06:04:04 <jmcarthur_work> *boxed
06:04:06 <tensorpudding> using (!!) is a bad plan
06:04:12 <copumpkin> damn right
06:04:14 <HaskellLove_> yeah but i can understand this so far so i will keep with this solution..
06:04:24 --- mode: ChanServ set -o dcoutts
06:04:34 <sproingie> then don't complain that it's slow
06:04:43 <ziman> HaskellLove_, you need the elements 0..10000 anyway
06:04:43 <HaskellLove_> ok
06:04:45 <Paczesiowa> when will 6.12.1 be released?
06:05:03 <ziman> ...to get the 10001st one
06:05:05 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes !! 10001
06:05:08 <lambdabot>   104759
06:05:29 <Cale> That one is a bit faster
06:05:42 <Cale> It's still not terribly efficient, but it's a good deal better.
06:05:48 <copumpkin> Paczesiowa: probably not for another month or two
06:06:42 <HaskellLove_> holy shit it stopped: *** Exception: Prelude.(!!): index too large
06:07:01 <jmcarthur_work> that would be a bug
06:07:02 <Cale> HaskellLove_: That's because you chopped the list too short
06:07:14 <Cale> HaskellLove_: Why'd you apply take first?
06:07:42 <Cale> Applying !! with a positive number to an infinite list is safe, and using take will only slow things down
06:07:53 <Paczesiowa> jmcarthur_work: are those [Not]Safe constructors phantom?
06:08:09 <HaskellLove_> Cale, I see, so just use !! without take, cool let me try it
06:08:16 <jmcarthur_work> Paczesiowa, yes. they have no values (ignoring ⊥)
06:08:28 <Vulpyne> You can use !! with a negative number? :)
06:08:33 <jmcarthur_work> Paczesiowa, and they are only used as type parameters
06:08:46 <Paczesiowa> jmcarthur_work: no no, I mean in MarkedList type, is it equivalent to regular List at runtime?
06:08:48 <Cale> Vulpyne: You can, but it's not safe, you get an error.
06:09:03 <dubhrosa_> I'm learning parsec and trying to use it for a real work problem that basically amounts to the same thing as parsing a file of C code so that non-comment content is gathered into one String and all comment content is gathered into another String, any Parsec gurus here care to suggest an elegant solution? (I've tried and failed miserably...)
06:09:04 <benmachine> it's not so much unsafe as guaranteed to break?
06:09:05 <HaskellLove_> holy shit that was fast :D less then second :D with !! instead of take
06:09:06 <jmcarthur_work> Paczesiowa, appears to store the same data
06:09:50 <benmachine> dubhrosa_: fwiw, C block comments aren't allowed to nest
06:09:52 <Paczesiowa> some rewrite rule would be nice
06:09:56 <benmachine> (unlike, I believe, haskell comments)
06:10:12 <jmcarthur_work> Paczesiowa, what for?
06:10:19 <Paczesiowa> > 1 + {- hello {- world -} -} 2
06:10:20 <lambdabot>   3
06:10:29 <mauke> there's no such thing as "nested comments"
06:10:30 <aavogt> @hackage language-c
06:10:30 <lambdabot> http://hackage.haskell.org/package/language-c
06:10:32 <Paczesiowa> jmcarthur_work: turning fancy stuff back to normal lists
06:10:43 <dubhrosa_> benmachine: yes, for the purpose in question nesting can be ignored
06:10:43 <jmcarthur_work> Paczesiowa, it should be the same at runtime anyway...
06:10:49 <Cale> mauke: Yes there is :)
06:10:58 <jmcarthur_work> Paczesiowa, or close enough that it won't matter
06:10:59 <mauke> Cale: they're either not nested or not comments
06:11:05 <HaskellLove_> why is !! so fast?
06:11:06 <mauke> or both
06:11:10 <jmcarthur_work> HaskellLove_, it's not
06:11:13 <Paczesiowa> jmcarthur_work: but there are fusion systems for regular lists
06:11:16 <copumpkin> it's so slow
06:11:22 <sm> does the Package versioning policy say that we should avoid making X.Y releases on hackage ? Ie 0.7.0 preferred, 0.7 not ?
06:11:23 <Cale> mauke: Look at that example given by Paczesiowa
06:11:39 <sproingie> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
06:11:40 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:11:40 <HaskellLove_> what do you mean it gave me 104759 insantly
06:11:54 <mauke> Cale: that's not really a nested comment. the inner {- -} is not a normal haskell comment
06:11:58 <Cale> mauke: That doesn't work in C, since the comment parser isn't careful to look for {- inside a comment
06:12:03 <copumpkin> HaskellLove_: it's not slow if you use it once or twice
06:12:10 <copumpkin> the bulk of the time will be your prime calculation there
06:12:10 <aavogt> hmm, but the AST in that package doesn't seem to have fields for comments that I can easily find
06:12:10 <jmcarthur_work> Paczesiowa, but they won't really work unless you *also* use rewrite rules on the functions that manipulate MakedLists... but i see your point now
06:12:13 <copumpkin> but in general, you should avoid it
06:12:17 <dubhrosa_> (it's actually a brew file which is a mix of latex and R, and I want to separate the R from the latex, the delimiters are "<%" and "%>")
06:12:19 <sm> if it doesn't matter too much, I'll use simple X.Y on hackage when I can
06:12:23 <mauke> Cale: exactly. you've got a special rule in the comment parser that looks for {- and -} for no good reason
06:12:35 <Cale> mauke: There is a good reason
06:12:37 <mauke> it doesn't call itself
06:12:39 <benmachine> I think it's for a good reason
06:12:50 <jmcarthur_work> HaskellLove_, it's O(n) time. it has to traverse the entire list up to the index you give one element at a time
06:12:52 <ezyang> damn. I forgot how to prove the pointed law with free parametricity
06:12:52 <mauke> Cale, benmachine: you're both wrong!
06:12:54 <benmachine> if you want to comment out a large amoutn of code, which contains block comments
06:12:56 <mauke> actually, what's the reason?
06:12:58 <Paczesiowa> jmcarthur_work: rewriting Nil and Cons to [] and (:) would fix those functions
06:13:01 <mauke> benmachine: yeah, that's wrong
06:13:09 <benmachine> then you need nesting for it to not break
06:13:10 <Cale> mauke: It's so that when you comment out a block of code, and it happens to contain a block comment, you don't end up uncommenting the block comment accidentally.
06:13:13 <copumpkin> ezyang: you fail! I propose expulsion from #haskell
06:13:17 <HaskellLove_> jmcarthur_work this was more like O(1) man :D
06:13:19 <mauke> <mauke> Cale, benmachine: you're both wrong!
06:13:22 <benmachine> heh
06:13:23 <jmcarthur_work> Paczesiowa, the reason regular lists fuse is because the functions on them are defined to fuse
06:13:43 <copumpkin> oh, I thought it was cause GHC was really hot
06:13:50 <copumpkin> and things passed through it got so hot they fused
06:13:50 <mauke> Cale: the only language where that works is OCaml because its "nested comments" aren't really comments
06:13:58 <jmcarthur_work> Paczesiowa, MarkedList functions are separate implementations, so they won't fuse unless you rewrite them to [] functions or make your own fusion rules for them
06:14:06 <Cale> mauke: huh?
06:14:12 <Paczesiowa> jmcarthur_work: oh, right I thought about something else
06:14:12 <mercury^> mauke: huh?
06:14:16 <benmachine> mauke: huh?
06:14:22 <sproingie> sproingie: huh?
06:14:22 <jmcarthur_work> Paczesiowa, also, rewrite rules require both sides to have the same type
06:14:24 <benmachine> > text "mauke: huh?"
06:14:25 <lambdabot>   mauke: huh?
06:14:28 <mauke> benmachine, Cale: nested comments are neither sufficient nor required for not breaking arbitrary commented out code
06:14:40 <mauke> consider putStrLn "-}"
06:14:55 <mauke> commenting that gives you {- putStrLn "-}" -}
06:15:02 <benmachine> > text {- "-}" -} "blah"
06:15:03 <lambdabot>   <no location info>:
06:15:03 <lambdabot>      lexical error in string/character literal at end o...
06:15:04 <mauke> this breaks regardless of whether your comments nest or not
06:15:11 <ziman> clever!
06:15:23 <mauke> it works in OCaml because OCaml actually lexes your "comments"
06:15:26 <benmachine> okay, now prove required
06:15:34 <benmachine> also, nothing wrong with parsing comments
06:15:41 <mauke> so (* foo " *) is actually a syntax error there
06:15:47 <benmachine> so long as the intention is preserved
06:15:51 <sproingie> this is one reason i like using line comments
06:15:55 <mauke> for the required part, look at C
06:16:04 <mauke> the C solution is #if 0 .. #endif
06:16:12 <tensorpudding> mauke: seriously?
06:16:18 <mauke> this works, nests properly, and isn't a comment
06:16:34 <copumpkin> that's what she said
06:16:35 <mauke> precisely because it preserves the token structure of the code
06:16:50 <mercury^> mauke: the difference is that "-}" can appear in haskell code without being a comment delimiter.
06:17:44 <supershoe0> anyone here play vba?
06:17:50 <copumpkin> no
06:17:54 <copumpkin> nobody does
06:17:55 <benmachine> mauke: you are clever, this should be written down somewhere
06:18:09 <mauke> I'm not clever; this stuff is obvious :-[
06:18:13 <Cale> supershoe0: Visual Basic for Applications?
06:18:23 <benmachine> you might still be clever!
06:18:43 * ziman has a private notepad where he puts all these interesting excerpts from #haskell(-blah)?
06:18:57 <mercury^> ziman: interesting question.
06:19:20 <mauke> benmachine: well, I am the inventor of the nested one-line comment
06:19:21 <Powerfool> Question: I have "map myFun myList", but myFun takes two arguments (one being constant). Can I use curry/uncurry to concisely express that?
06:19:27 <mauke> so maybe that's something
06:19:37 <mauke> Powerfool: map (myFun 42) myList
06:19:48 <Berengal> mauke: nested one-line comment?
06:19:56 <Powerfool> mauke: thanks.
06:20:17 <Cale> Powerfool: If you have a list of pairs, then yes
06:20:22 <Paczesiowa> what's libtinfo.so.5 and why binary ghc package needs it?
06:20:24 <Cale> map (uncurry f) xs
06:20:29 <mauke> Berengal: comments start with "REM" and end with "\n"
06:20:42 <mauke> Berengal: and they nest
06:20:57 <Berengal> mauke: Which language is this?
06:21:00 <ziman> mercury^, it was a regex, actually :)
06:21:01 <Powerfool> Ah, and I need to use flip to reverse the argument list. Cool.
06:21:06 <mauke> Berengal: ploki
06:21:11 <mercury^> ziman: Oh, heh.
06:21:18 <Berengal> mauke: Never heard of it...
06:21:29 <mauke> yeah, it's a private project
06:21:49 <Berengal> I must admitt, I don't really see the need for nesting one-line comments...
06:21:58 <mercury^> REM REM
06:22:01 <mercury^> Berengal: how so?
06:22:24 <Vulpyne> Powerfool: You could also do map (42 `myFun`) myList :)
06:22:27 <Berengal> Unless they somehow don't last until the end of line...
06:22:35 <Berengal> But then I don't see why they can't span several lines
06:22:44 <mercury^> REM REM
06:22:51 <mercury^> You can comment several lines.
06:22:55 <mercury^> REM REM REM
06:22:57 <mercury^> Like this.
06:22:59 <mercury^> For example.
06:23:03 <dubhrosa_> so my basic test case would be: parse myparser "" "t1<%r1%>t2<%r2%>t3" which should return Right ("t1t2t3", "r1r2")
06:23:15 <mauke> mercury^: exactly
06:23:27 <Berengal> mercury^: So it's a multiline-comment with an initial count?
06:23:31 <HaskellLove_> does someone has explanation why !! was so fuckin fast?
06:23:38 <mauke> it doesn't have to be all up front
06:24:00 <Cale> HaskellLove_: It's not very fast at all, xs !! n takes O(n) time.
06:24:24 <HaskellLove_> Cale yeah man but it gave me the result like ultra fast not even a second
06:24:24 <mercury^> Cale: does it get fused maybe?
06:24:27 <Berengal> HaskellLove_: It's not, it just seems like it becaus your brain doesn't notice delays on the order of µs
06:24:29 <Cale> HaskellLove_: But in terms of the constant factor, it does actually use some low-level hackery with unboxed ints.
06:24:51 <Vulpyne> Hmm, if you're generating a list and taking O(n) time, does !! ing it add another O(n)? I would think it doesn't.
06:25:01 <ezyang> copumpkin: Can I have a hint please? ^_^
06:25:12 <Cale> Vulpyne: Well, maybe.
06:25:12 * ezyang totally knew how the proof went at some point 
06:25:26 <Vulpyne> Fusion. Magical stuff and faerie dust. *waves hands around*
06:25:50 <mercury^> Is GHC transforming lists or parts of them into something array like?
06:26:11 <Cale> Vulpyne: If you spend O(n) time evaluating the first n elements of a list, and then apply (!! n) to the list, you'll spend O(n) time again walking down it
06:26:20 <jmcarthur_work> mercury^, i very much doubt it
06:26:34 <Cale> mercury^: no.
06:27:03 <Cale> However, it does fuse away adjacent list operations which can be fused.
06:27:11 <Cale> I'm not sure those ever apply to !! though.
06:27:12 <Vulpyne> Cale: Like for the primes !! 1000 thing, I can envision it calculating the primes fused with the !! so it would not have to ever have the entire list exist.
06:27:29 <mercury^> Would seem like a good optimization to study, since lists are often used for small collections that arrays are better for.
06:27:32 <Cale> Vulpyne: yes, but I don't think it does.
06:27:33 <Vulpyne> In which case, it wouldn't have a whole list to force !! to walk through again.
06:27:33 <mauke> http://mauke.ath.cx/tmp/ploki-0.6.4/examples/calc.pk
06:27:39 <Vulpyne> Too bad.
06:27:44 <Berengal> 1000 is a very low number for n
06:27:54 <Vulpyne> I guess most people avoid !! so it could be pointless anyway.
06:28:35 <c_wraith> also, please note that in the case of a list like primes, calculating the next element is not O(1).  So if the !! is the first thing to force the list, it will result in more than O(n) work being done
06:28:37 <Vulpyne> I think the number HaskellLove was talking about was considerably higher, I just used 1000 as an example.
06:29:23 <dubhrosa_> I'm pretty disappointed that such a simple parsing task is so difficult using Parsec, I mean it's just a couple of lines of C to do the same thing.
06:29:32 <ezyang> man, this is really bothering me
06:29:45 <Berengal> HaskellLove_: If !! is O(1), then [1..] !! 1000000 and [1..] !! 1000000000 should take equally long to calculate
06:29:48 <Vulpyne> dubhrosa_: What was the problem?
06:30:12 <mauke> heh. sort of related: http://mauke.ath.cx/tmp/ploki-0.6.4/examples/uncomment.pk
06:30:24 <HaskellLove_> now it is calculating slow again copumkin was right, either way i have no fuckin idea what happened, maybe the first time the list was cached or something, but i did not evaluate it that is why it was wierd...
06:30:44 <Vulpyne> mauke: It looks almost like LOLCODE.
06:30:48 <dubhrosa_> splitting a brew file which contains a mix of latex and R out so the latex content and R content are separated. They are delimited by "<%" and "%>" which marks the start and end of the R blocks...
06:30:53 <Vulpyne> Jush there are less LOLs to be had.
06:31:07 <mauke> why, because there's a KTHX statement?
06:31:13 <Vulpyne> mauke: Yes.
06:31:14 <mauke> they stole that from me :-(
06:31:19 <Vulpyne> And caps stuff.
06:31:49 <dubhrosa_> and you can't really assume anything about the content of either, so I can't see how to define the latex block properly
06:31:59 <mauke> actually, the whole language is a practical joke that got out of hand
06:32:02 <Cale> HaskellLove_: If you'd already evaluated  take 10001 primes !! 10001 and had it fail in ghci, and primes remained in scope, then the first 10001 elements of primes would already be evaluated
06:32:09 <Vulpyne> dubhrosa_: Can the stuff in <% have an escaped %> in it?
06:32:18 <Cale> HaskellLove_: and so getting the 10001st element would be fast
06:32:29 <dubhrosa_> no, it can't
06:33:19 <Vulpyne> dubhrosa_: Hold on, I will look at it.
06:33:40 <dubhrosa_> thanks, it's driving me nut
06:33:41 <dubhrosa_> s
06:33:53 <jkramer> Ahoy
06:35:16 <jkramer> I'd like to create a type that behaves like an Int but has a maxBound of 4
06:35:43 <Paczesiowa> jkramer: make a newtype
06:35:48 <jkramer> When I create it with "type Foo = Int", ghc throws errors when I declare the instance
06:36:01 <jmcarthur_work> jkramer, newtype
06:36:02 <mauke> 'type' doesn't create types
06:36:03 <Paczesiowa> newtype Foo = Foo Int
06:37:06 <copumpkin> it's a bit of a misnomer, eh
06:37:39 <mauke> it's just like typedef in C!
06:37:43 <jkramer> Hmm, does that mean that I have to use "Foo 3" everywhere?
06:37:52 <mauke> jkramer: not if you make it an instance of Num
06:38:05 <jkramer> Ah
06:38:18 <Paczesiowa> jkramer: no, use GeneralizedNewtypeDeriving and add deriving Num
06:38:34 <Paczesiowa> jkramer: then 3 :: Foo
06:38:34 <jmcarthur_work> Paczesiowa, bad idea if the maxBound should be 4
06:38:46 <Paczesiowa> :t maxBound
06:38:47 <lambdabot> forall a. (Bounded a) => a
06:38:53 <jmcarthur_work> better to write an instance manually
06:39:05 <jmcarthur_work> Paczesiowa, what should it do if you do 3+3?
06:39:06 <Paczesiowa> Bounded != Num
06:39:16 <Paczesiowa> jmcarthur_work: don't ask me, ask him
06:39:20 <jkramer> Do I have to implement all instance functions of Num or is there a minimal subset?
06:39:28 <aavogt> Paczesiowa: you need num if you want to use integer litterals
06:39:33 <jmcarthur_work> Paczesiowa, that's just my point. usually maxBound means anything above that would be illegal
06:40:03 <mauke> jkramer: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#7
06:40:06 <jmcarthur_work> i guess that might be a bad assumption about the Bounded type class...
06:40:08 <Berengal> Aren't there some modulo-arithmetic packages on hackage already?
06:40:13 <jmcarthur_work> i don't know if it's specified that way
06:40:41 <jmcarthur_work> Int is modular arithmetic ;)
06:40:59 <copumpkin> yay
06:41:18 <HaskellLove_> Yeii Euler #7 done now onto #8 - http://haskelllove.wordpress.com/ - thank you so much guys i fuckin love you all
06:41:52 <copumpkin> they get significantly harder :)
06:41:56 <copumpkin> good luck!
06:43:24 <cocon> after installing 6.12.1rc2 I get this for 'runhaskell Setup': <command
06:43:24 <cocon> 	line>: can't load .so/.DLL for: gmp (dlopen(libgmp.dylib, 9): image
06:43:24 <cocon> 	not found)
06:44:41 <jkramer> Oh noes, can't I use my new type instead if Ints?
06:44:55 <mauke> no, it's a new type
06:45:07 <mauke> you can't have both
06:45:26 <jkramer> Hrm
06:45:52 <jkramer> Is there a workaround? Like "toInteger"?
06:46:01 <roconnor> @quote gcd
06:46:01 <lambdabot> No quotes match. Just what do you think you're doing Dave?
06:46:11 <mauke> jkramer: fromIntegral
06:46:34 <roconnor> > nubBy((0<).).gcd)[2..]
06:46:35 <lambdabot>   <no location info>: parse error on input `)'
06:46:41 <roconnor> > nubBy(((0<).).gcd)[2..]
06:46:44 <lambdabot>   mueval-core: Time limit exceeded
06:47:10 <roconnor> > nubBy(((1<).).gcd)[2..]
06:47:11 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:47:22 <roconnor> > (nubBy(((1<).).gcd)[2..])!!10001
06:47:26 <lambdabot>   mueval-core: Time limit exceeded
06:47:29 <roconnor> :O
06:48:48 <mercury^> > (filter ((1<).gcd) (2:[3,5..]))!!10001
06:48:49 <lambdabot>   No instance for (GHC.Classes.Ord (a -> a))
06:48:49 <lambdabot>    arising from a use of `GHC.Cl...
06:49:05 <mercury^> err
06:49:57 <sm> is there a cross-platform alternative to System.Posix.Files (fileExist) ?
06:50:03 <Vulpyne> dubhrosa_: Hmm, this is bit more of a pain than I thought.
06:50:24 <mercury^> > nubBy (\a b -> b == b*(b `div` a)) [2..]
06:50:25 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:50:40 <mauke> @hoogle doesFileExist
06:50:40 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
06:50:55 <sm> ooh, thanks mauke
06:51:17 <dubhrosa_> Vulpyne: not being able to assume anything whatsoever about the content is problematic, right?
06:51:54 <Vulpyne> dubhrosa_: No, not that. That manyTill's ending parsing eats the ending.
06:52:12 <mercury^> > nubBy (\a b -> b == a*(b `div` a)) [2..]
06:52:13 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
06:52:27 <mercury^> I think I should go to bed. :s
06:52:29 <dubhrosa_> yes, I hit that problem too, I can't see a way around it
06:52:59 <roconnor> > let {isPrime x = all ((1<). (gcd x)) (takeWhile (\p -> p^2 <= x) prime); primes = 2:filter isPrime [3,5..]} in primes
06:53:00 <lambdabot>   Not in scope: `prime'
06:53:06 <roconnor> > let {isPrime x = all ((1<). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in primes
06:53:10 <lambdabot>   mueval-core: Time limit exceeded
06:53:44 <dubhrosa_> all the remotely similar examples I've looked at were able to define the blocks without reference to the separators, because they could assume something about their content/structure
06:54:07 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in primes
06:54:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:54:28 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in primes!!10001
06:54:31 <lambdabot>   104759
06:54:40 <roconnor> yay
06:55:06 <roconnor> ack
06:55:14 <roconnor> I'm wrong
06:55:16 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in primes!!10002
06:55:19 <lambdabot>   104761
06:56:05 <Vulpyne> dubhrosa_: Yeah... I'm sure there is some easy way to do this though...
06:56:24 <Vulpyne> dubhrosa_: It would be quite easy without using parsec. :)
06:56:49 <mercury^> > (nubBy (\a b -> a == (a `div` b)*b) [2..])!!10001
06:56:49 <roconnor> how can I be wrong!
06:56:50 <dubhrosa_> Vulpyne: yes!
06:56:53 <lambdabot>   mueval-core: Time limit exceeded
06:57:06 <dubhrosa_> Vulpyne: so much for trying to better myself :)
06:57:38 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in primes!!10000
06:57:41 <lambdabot>   104743
06:57:51 <roconnor> oh
06:57:57 <roconnor> god damn off by 1 errors
06:58:36 * roconnor kicks ordinal numbers in the crotch.
06:59:25 <Ferdirand> every one of them ?
06:59:37 <ddarius> roconnor: I'd be careful.  There's a lot more of them than there is of you.
07:00:12 <Veinor> oh no, they might gang up on him!
07:00:35 <Veinor> > (nubBy (\a b -> a == (a `div` b)*b) [2..])
07:00:37 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:00:38 <dubhrosa_> Vulpyne: if the separator were a single character, you could use (many (noneOf '<')) to grab the latex blocks, but I can't see a way to do that with string "<%"
07:00:40 <Veinor> ah.
07:01:44 <mauke> [^<]*<+([^<%][^<*<+)*%
07:01:46 <mauke> untested
07:01:53 <mauke> oh, also missing ]
07:03:17 <mauke> many (noneOf "<") >> many1 (char '<') >> many (noneOf "<%" >> many (noneOf "<") >> many1 (char '<')) >> char '%'
07:03:37 <ddarius> Oh lord.  John Earle, Gregg Reynolds, Casey Hawthorne, Andrew Coppin all in one thread.
07:04:07 <mauke> .oO( quick, lock it up and throw away the key )
07:04:10 <Paczesiowa> ddarius: what about them?
07:04:15 <tensorpudding> it doesn't work that way
07:04:34 <mauke> THIS THREAD IS LOCKED. NONE SHALL ESCAPE.
07:05:45 <BONUS> lol
07:05:48 <BONUS> where's harrop
07:05:57 <BONUS> paging harrop
07:06:01 <copumpkin> #haskell-blah
07:06:03 <lunabot>  luna: A section must be enclosed in parentheses
07:06:06 <copumpkin> we're just talking about him
07:06:41 <Vulpyne> dubhrosa_: Heh, I got parsec to say "unexpected end of input. expecting end of input"
07:06:43 <Paczesiowa> I heard that ocaml sucks because it has slow hashtables so haskell ftw
07:07:09 <Paczesiowa> I guess he must be busy or smth
07:07:35 <ivanm> Paczesiowa: heh
07:07:37 <c_wraith> haskell also has slow hashtables. >_>
07:07:38 <dubhrosa_> Vulpyne: nice!
07:08:50 <dubhrosa_> mauke: noneOf "<%" will match against a single '%' or '<', not the delimiter "<%" - if we had something that would do so I think it would be straightforward to solve
07:08:56 <mauke> dubhrosa_: I know
07:09:02 <mauke> that's expected
07:09:20 <dubhrosa_> sorry. I'm missing something then
07:11:11 <Paczesiowa> damn, GADTs allow to write nice runEither :: MyEither e a Safe -> a, but it results in bad error messages (no mentioning of class context):/
07:11:43 <Paczesiowa> can I ask ghc to always print class context?
07:12:33 <ddarius> So crazy lurking Agda people, if I were to start hacking some Agda code, what would be interesting to do in it or would be useful?
07:12:52 <ddarius> (Please don't say a type-safe interpreter.)
07:13:49 <copumpkin> ddarius: I'm playing with making a nicer algebra library than the standard one, right now
07:14:11 <sproingie> have it make me a sandwich
07:14:44 <copumpkin> ddarius: I dunno, typesafe matrix operations, implement a sorely missing real number library, prove some stuff about regular/context-free languages
07:14:49 <Veinor> @faq can Haskell make me a sandwich?
07:14:49 <lambdabot> The answer is: Yes! Haskell can do that.
07:14:54 <copumpkin> lots of good stuff that needs doing :)
07:14:57 <Veinor> well get to it
07:15:17 <Vulpyne> dubhrosa_: I think I got it.
07:15:41 <ddarius> "can" and "will" (or "can" and "shall") are rather different things.
07:16:00 <Veinor> hey ezyang what should I write, I'm bored
07:16:13 <dubhrosa_> Vulpyne: really?
07:16:27 <Vulpyne> dubhrosa_: Almost... Except < not followed by % kills it.
07:16:41 <copumpkin> ddarius: I mostly just listed the things I've played with to get acquainted with the language, but your interests are probably different. How about a universe-polymorphic category-extras for agda! :D
07:16:48 <ddarius> copumpkin: You don't happen to know if there is a vim mode for Agda.
07:16:52 <ezyang> Veinor: wait what?
07:17:15 <ac> is there a version of tail in the stdlib that returns [] given []?
07:17:18 <copumpkin> ddarius: pretty sure there isn't :/ it's fairly heavily tied to emacs right now
07:17:21 <ac> (instead of erroring)
07:17:25 <ddarius> copumpkin: Bah
07:17:30 <Botje> ac: drop 1
07:17:41 <copumpkin> yeah, I didn't like the idea but got used to it pretty quickly
07:17:46 <Botje> > drop 1 []
07:17:46 <lambdabot>   []
07:17:53 <ac> Botje: thanks :)
07:18:00 <copumpkin> maybe just because I was so amazed at the language, but maybe if I had had a bit more exposure to this sort of stuff it would be less impressive to me
07:18:06 <dubhrosa_> Vulpyne: dang
07:18:46 <Veinor> ezyang: I'm bored and need something to code to pass the time. I'm open to suggestions.
07:19:30 * copumpkin whispers agda in Veinor's ear
07:19:31 <Vulpyne> dubhrosa_: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=13948 -- It's very likely this is not the optimal way to do it.
07:20:05 <ezyang> Veinor: Hmm...
07:20:19 <ezyang> Settle down by the paper and read a nice math paper.
07:20:24 <ezyang> *by the fire
07:20:58 <Vulpyne> dubhrosa_: It doesn't parse into Either, but you could make it do that instead if you wanted.
07:22:58 <dubhrosa_> Vulpyne: very, very, very nice. Thank you!
07:23:12 <Vulpyne> dubhrosa_: No problem... It was trickier to get that working that I expected. :)
07:23:21 <Vulpyne> parsec is fun though, like more complicated regular expressions.
07:24:20 <ddarius> copumpkin: Hmm... I have some ideas now...
07:24:39 <dubhrosa_> Vulpyne: all the examples show it simplifying things so much, strange how it needs a little warping to do this parse
07:24:40 <copumpkin> like what?
07:25:14 <Vulpyne> dubhrosa_: I've used it for parsing quite a few different formats, and usually you don't run into this problem.
07:25:30 <ddarius> copumpkin: I'm thinking proofs of categorical results.  It wouldn't be at all like category-extras though.
07:25:39 <Vulpyne> The solution wasn't all that complicated though, just not very obvious.
07:26:13 <Veinor> ezyang: what does it say about me that I asked you this over IRC as opposed to just saying something out loud? also, any suggestions? :P
07:26:16 <copumpkin> ddarius: yeah, that could be fun. I'd talk to dolio about that though, because last time he tried playing with CT definitions agda ate up all his RAM, but the more recent version in HEAD might be less hungry now
07:26:44 <ddarius> copumpkin: For example, realizing that construction of graphs by using general topos results would be interesting.
07:27:59 <ddarius> Veinor: You wouldn't be the first person to talk to someone they were physically with via #haskell.
07:28:23 <Vulpyne> I wish I worked with other Haskell people.
07:28:34 <dubhrosa_> Vulpyne: thanks for your help, I can sleep easy now...
07:28:34 <Nafai> Me too
07:28:46 <Vulpyne> dubhrosa_: No problem. :)
07:28:48 <copumpkin> ddarius: that would indeed be very neat
07:29:05 <Vulpyne> I keep trying to get my coworkers to learn.
07:29:35 <copumpkin> Veinor, ezyang: you taking a class together?
07:29:55 <ezyang> copumpkin: Not quite.
07:30:04 <ezyang> We're currently hanging out in the SIPB office
07:30:37 <copumpkin> :o
07:30:49 <Veinor> indeed
07:30:59 <Veinor> classes are over! except for finals.
07:31:04 <copumpkin> nice
07:31:27 <Veinor> and I, being a poor freshman, have finals in all four of my classes. and all four of my classes next term as well.
07:31:51 <copumpkin> aw po' thing
07:32:08 <ivanm> copumpkin: you running out of o's and r's or something?
07:32:14 <copumpkin> yeah
07:32:25 <copumpkin> I'm a southerner
07:33:03 <HaskellLove_> how am i to store a 1000 digit number in haskell?
07:33:12 <Veinor> as an Integer?
07:33:13 <Paczesiowa> Integer
07:33:18 <aavogt> cereal
07:33:34 <copumpkin> > 10^1000
07:33:35 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
07:33:42 <copumpkin> HaskellLove_: with no extra effort
07:33:55 <Paczesiowa> > length $ show $ 10^1000
07:33:56 <lambdabot>   1001
07:33:58 <copumpkin> damn!
07:33:59 <copumpkin> I failed
07:34:32 <Paczesiowa> > it
07:34:33 <lambdabot>   Not in scope: `it'
07:35:21 <ivanm> copumpkin: so now you _are_ admitting that you're a yank?
07:35:35 <roconnor> @what CHP
07:35:36 <lambdabot> I know nothing about chp.
07:35:54 <HaskellLove_> copumkin?
07:36:09 <ivanm> roconnor: you mean neil brown's work?
07:36:24 <roconnor> yes
07:36:30 <ivanm> @where CHP
07:36:31 <lambdabot> I know nothing about chp.
07:36:40 <copumpkin> ivanm: nope, I said southerner, never said southern US
07:36:43 <roconnor> what = where
07:36:54 <ivanm> roconnor: chplib.wordpress.com
07:37:10 <ivanm> copumpkin: heh, well I thought you were intimating that from your supposed accent
07:37:20 <ivanm> (though how can you have an accent when _typing_????)
07:37:23 <roconnor> @where + CHP http://www.cs.kent.ac.uk/projects/ofa/chp/
07:37:23 <lambdabot> I know nothing about +.
07:37:26 <siki> Noob question -- this seems like something that is very not right and there shouble be a better way of doing it:
07:37:27 <Veinor> ivanm: a person from the southern US would not even self-identify as a yank :P
07:37:29 <roconnor> @where+ CHP http://www.cs.kent.ac.uk/projects/ofa/chp/
07:37:29 <copumpkin> ivanm: nope, that's a result of my southern european-ness
07:37:29 <lambdabot> It is forever etched in my memory.
07:37:34 <ivanm> roconnor: heh
07:38:08 <ivanm> Veinor: to me, yank == citizen of the united states of america, something copumpkin has previously professed not to be
07:38:14 <ivanm> siki: what is it?
07:38:17 <siki> data Foo = Foo Int | Foo [Int] and type FooMap = Map.Map String Foo
07:38:24 <siki> now
07:38:27 <Veinor> ivanm: right, and what I'm saying is to a person who's from the southern US, yank == person from the north :P
07:38:30 <mauke> siki: that's invalid
07:38:33 <copumpkin> ivanm: nope, by that definition I'm a yank
07:38:34 <roconnor> ivanm: is CHP implemented using STM?
07:38:48 <siki> and should be a new line but I'm not finished with the whole problem :)
07:38:52 <ivanm> siki: each constructor has to be unique
07:39:02 <ivanm> roconnor: no idea tbh
07:39:06 <ivanm> copumpkin: aha!
07:39:20 <HaskellLove_> copumkin: how come this is ok? haskell divides it automatically to 32 or 64 bit ints? and returns a pointer at first member?
07:39:22 <siki> oh, I'm sorry, yes so data Foo = Foo Int | FooArray [Int]
07:39:35 <siki> that's not actually what I have a question about
07:39:41 <siki> so now:
07:40:05 <copumpkin> HaskellLove_: it uses gmp behind the scenes in this version, but that's an opaque implementation detail.
07:40:58 <HaskellLove_> indentation errors are fuckin crazy... i have the file it has : c = and here there is like 1000 digit number, no indentation and shows me indentation error... fuckin fuckin anoying thing with haskell
07:41:19 <mauke> HaskellLove_: why don't you stop using indentation then?
07:41:25 <siki> if I now want to write a function that just returns [Int] for a given key, I can have: getInts key map = ints where FooArray ints = Map.lookup key map
07:41:34 <HaskellLove_> mauke that is the point i have nothing indented :D
07:41:41 <HaskellLove_> and still shows errors
07:41:46 <c_wraith> HaskellLove_: then you probably need some semicolons
07:41:48 <BONUS> whoa whoa whoa there's children on this channel!
07:41:53 <ivanm> HaskellLove_: is there really a need for so much profanity?
07:41:53 <BONUS> HaskellLove_: paste your code?
07:42:09 <ivanm> BONUS: yes, and children should be seen (== idling) and not heard! :p
07:42:20 <Veinor> oh hi BONUS
07:42:26 <BONUS> heyo!
07:42:37 <siki> but this gets around the whole idea of type safty, cuz you don't know in advance wheter the value for your key is in the form of "Foo Int" or "FooArray [Int]"
07:42:46 <siki> how do I make it more type safe?
07:42:54 <Vulpyne> siki: It's a Foo either way though.
07:43:01 <mauke> siki: well, what do you want to do in case of Foo int?
07:43:02 <Jedai> siki: That's the partiality problem
07:43:10 <HaskellLove_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13950#a13950
07:43:12 <BONUS> siki: Bool can also be True and False, there's the same amount of un-safety there
07:43:29 <Vulpyne> siki: Just having ways to extra a [Int] from that doesn't make it unsafe (as long as you handele every case)
07:43:32 <siki> true but is there a way to make it more "safe"?
07:43:33 <Philonous> Why does this work: "instance (HList l, HOccursNot e l) => HOccursNot e (HCons e’ l)" Giving types different names doesn't mean they are distinct, does it?
07:43:34 <mauke> HaskellLove_: er, you can't put linebreaks in the middle of a number
07:43:41 <nejucomo> I've gotten quite confused by exception handling and lazy evaluation.
07:43:44 <copumpkin> ddarius: if you have any questions about agda (there isn't that much documentation out there) there's #agda, and a mailing list
07:44:02 <Jedai> siki: suppressing it completely leads to pretty inconvenient functions. GHC can tell you when your pattern match aren't exhaustive
07:44:17 <BONUS> HaskellLove_: strange, i can compile nicely with that number. maybe your editor is messing with you
07:44:31 <siki> well that's what I thought as well but actually it doesn't tell me that in this case
07:44:33 <BONUS> but yeah minus the line breaks
07:45:10 <Vulpyne> Try compiling with ghc -Wall ?
07:45:11 <HaskellLove_> BONUS what line breaks, how to remove them?
07:45:28 <BONUS> HaskellLove_: well the hpaste file shows the linebreaks
07:45:40 <siki> instead if the value for the key is Foo Int instead of FooArray [Int] it runs and returns an error something like "Irrefutable pattern failed for pattern...."
07:45:43 <BONUS> i added a revision without them
07:45:52 <BONUS> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13950#a13951
07:46:23 <Paczesiowa> Philonous: OverlappingInstances?
07:47:01 <Philonous> Paczesiowa: Oh, you are right. Thanks.
07:47:19 <carnieri> > length $ show
07:47:19 <carnieri> 731671765313306249192251196744265747423553491949349698352031277450632623957831801698480186947885184385861560789112949495459501737958331952853208805511125406987471585238630507156932909632952274430435576689664895044524452316173185640309871112172238311362229893423380308135336276614282806444486645238749303589072962904915604407723907138105158593079608667017242712188399879790879227492190169972088809377665727333001053367881220235421809751254540594752243525849077
07:47:19 <carnieri> 601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100
07:47:20 <lambdabot>   Couldn't match expected type `[a]'
07:47:20 <lambdabot>         against inferred type `a1 -> GHC...
07:47:21 <carnieri> 5520005593572972571636269561882670428252483600823257530420752963450
07:47:25 <Paczesiowa> Philonous: what are you doing with HList?
07:47:38 <Philonous> Nothing, I'm just reading OLegs paper
07:47:38 <adu> carnieri: wow
07:47:46 <andrewsw> hi, I've written an FSA simulator using the state monad (just a toy), as a learning tool.
07:47:51 <carnieri> sorry
07:47:58 <Jedai> siki: let introduce irrefutable patterns, so using let in your case is like telling GHC explicitly "I know what I'm doing, don't bother warning me". With a case or for declarations, GHC with -Wall would warn of non-exhaustive pattern
07:48:19 <andrewsw> but it requires a tuple, and I'd like to have it use *only* state, not state plus some other thing.
07:48:22 <adu> carnieri: what were all those numbers?
07:48:49 <carnieri> adu: that's from BONUS' hpaste above
07:48:51 <HaskellLove_> how to convert an integer into list so i can iterate over its digits?
07:48:56 <mauke> HaskellLove_: show
07:49:08 <andrewsw> how can I have just state and not get output as well, until the computation is done?
07:49:10 <Vulpyne> Keep in mind that will convert it into a list of characters, not digits.
07:49:21 <Philonous> Paczesiowa: But couldn't the same thing be achieved with a constraint in the lines of "HEqual e e' HFalse" without overlapping instances?
07:49:24 <andrewsw> s/output/value/
07:49:42 <mauke> Vulpyne: digits are characters
07:49:52 <mauke> > all isDigit (show 123)
07:49:53 <lambdabot>   True
07:50:05 <copumpkin> > map digitToInt . show $ 6 ^ 324
07:50:06 <lambdabot>   [1,3,2,1,3,1,1,2,2,4,4,2,8,1,1,4,7,3,0,0,6,4,7,7,9,9,7,1,0,4,3,0,3,4,9,5,9,...
07:50:09 <Philonous> Paczesiowa: Scratch that, I think constraints are checked later.
07:50:24 <adu> andrewsw: if you can break up the state, then "sequence" would do that
07:50:24 <siki> thanks, that was helpful, as always
07:51:07 <Vulpyne> I meant what copumpkin said. :)
07:51:19 <HaskellLove_> show $ 6^25
07:51:33 <HaskellLove_> lambdabot: show $ 6^25
07:52:08 <Veinor> > show $ 6^25
07:52:11 <lambdabot>   "28430288029929701376"
07:52:43 <andrewsw> adu: what do you mean by "break up the state"?
07:53:04 <ddarius> andrewsw: I would model state machines in Haskell as recursive equations.
07:53:28 <BONUS> i think there's a sigfpe post about that
07:53:35 <adu> andrewsw: what I meant was "break up the computation", like if you can do 10 steps at a time, then return enough state to continue from that point on if it is passed back into the function
07:53:55 <andrewsw> hmmm...
07:54:10 <adu> andrewsw: or you can use gdb
07:54:12 <kmc> andrewsw, do you maybe want evalState instead of runState?
07:54:43 <kmc> what do you mean by getting output before the computation is done?
07:54:54 <kmc> you can't do output from a State monad
07:55:07 <andrewsw> noobishness abounds here.
07:55:29 <adu> andrewsw: are you calling me a noob?
07:55:34 * copumpkin is a noob!
07:55:38 <andrewsw> adu: no! myself!
07:55:43 <adu> oh ok
07:55:47 <andrewsw> ;)
07:55:52 <adu> andrewsw: do you know what gdb is?
07:56:06 <andrewsw> adu: if it's not the gnu debugger, then no
07:56:13 <adu> andrewsw: yes it is
07:56:26 <Apocalisp> Good thing HaskellLove is here. These noobs don't pwn themselves you know.
07:56:35 <andrewsw> let me try to explain a little better.
07:56:45 <andrewsw> and kmc: maybe so
07:57:51 <vovik> how do i find out the kind of something in ghci?
07:57:51 <Vulpyne> http://hackage.haskell.org/package/Workflow perhaps?
07:57:58 <Vulpyne> vovik: :t thingy
07:58:03 <Vulpyne> Or :i
07:58:08 <andrewsw> I have a function delta :: Char -> Int -> (Bool, Int) where Char is used for the next character in the input string, Int is the current state and the tuple shows accept or not and the next state
07:58:33 <davidL> vovik: :k
07:58:45 <vovik> davidL: thanks
07:58:54 <andrewsw> I would rather not have the Bool in there at all, because in my mind, acceptance of a string is independent of the state transition function
07:59:09 <andrewsw> so I would prefer to have delta:: Char -> Int -> Int
07:59:56 <andrewsw> Currently, I have this wrapped up in the state monad thus: step :: Char -> State Int Bool
08:00:06 <andrewsw> where step is one step in the execution of the machine
08:00:15 * andrewsw is getting really long winded, sorry
08:00:24 <HaskellLove_> there is an intToDigit, but not charToDigit, how do i convert a Char to one digit Int?
08:00:25 <Apocalisp> @kind Maybe
08:00:26 <lambdabot> * -> *
08:00:40 <mauke> HaskellLove_: digitToInt
08:00:41 <Apocalisp> ooh
08:01:45 <andrewsw> to make it all work, I do: runState (step 'a') 0, for example. and I get back (False, 1) because my delta says so.
08:02:20 <andrewsw> But what I really want back is just 1... the next state
08:02:40 <ddarius> andrewsw: You could just project it, but there is already a function that does that.
08:02:42 <mauke> :t runState
08:02:43 <lambdabot> forall s a. State s a -> s -> (a, s)
08:02:43 <ddarius> :t execState
08:02:44 <lambdabot> forall s a. State s a -> s -> s
08:03:01 <tass> So, let's say I've got this string, and I want to split it up into a list/array by whitespace, with 0 being the whole string, 1 the string until the first whitespace, 2 the second part of the string until next whitespace, etcetera. How would I go about that?
08:03:03 <ddarius> @src execState
08:03:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:03:11 <c_wraith> :t evalState -- for completeness' sake
08:03:12 <lambdabot> forall s a. State s a -> s -> a
08:03:18 <mauke> tass: words
08:03:23 <tass> mauke: Hmm?
08:03:31 <mauke> > words "foo bar baz"
08:03:32 <lambdabot>   ["foo","bar","baz"]
08:03:39 <andrewsw> hmmm... maybe execState is what I want
08:03:52 <ddarius> execState m s = fst (runState m s)
08:03:57 <ddarius> er snd
08:04:01 <tass> Hmm, yes.. that ought to work.
08:04:07 <andrewsw> ddarius: right
08:04:27 <zygoloid> > join (flip (:) . words) "foo bar"
08:04:28 <lambdabot>   ["foo bar","foo","bar"]
08:04:36 <andrewsw> but really, I don't want my delta function to care about acceptance, so I'd like to change delta's type, but I couldn't get that to work.
08:04:42 * andrewsw goes off to try again
08:04:58 <mauke> > ap (:) words "foo    bar"
08:04:59 <lambdabot>   ["foo    bar","foo","bar"]
08:05:07 <Vulpyne> andersp: Maybe put some code on hpaste.
08:05:20 <andrewsw> yeah, if I don't get anywhere, I'll do that
08:05:40 <mikste> > let f x = ((\(x, xs) -> x:xs) . last . takeWhile ((>0) . fst) . iterate (\(a, b) -> let (c, d) = a `divMod` 10 in (c, d:b)) $ (x, [])) in f 12345
08:05:42 <lambdabot>   [1,2,3,4,5]
08:06:44 <samirov> 1/q
08:06:58 <zygoloid> > 1/q
08:06:59 <lambdabot>   1 / q
08:07:02 <zygoloid> thought so.
08:13:39 <v_> Hm, this twitter Haskell client is interesting
08:14:39 <v_> Reminds me of vi
08:15:14 <kmc> andrewsw, why do you want to runState a single step at a time?
08:15:59 <Mr_McCoy>  Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat...
08:16:00 <Mr_McCoy> ...Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat...
08:16:02 <Mr_McCoy> ...Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat...
08:16:05 <Mr_McCoy> ...Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat...
08:16:10 <Mr_McCoy> ...Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat Moist_Bat...
08:16:13 --- mode: ChanServ set +o Igloo_
08:16:20 <Badger> @get ops
08:16:21 <lambdabot> shapr!!
08:16:50 --- mode: ChanServ set +o Lemmih
08:16:52 <elly> "?"
08:16:54 <andrewsw> kmc: because I'm a noob and I'm learning
08:16:56 <v_> Heh
08:17:12 <kmc> andrewsw, if you're interested in running the machine to completion, you'd build that action within the State monad, and use evalState or such to get the final result
08:17:29 <andrewsw> let me post the code
08:20:48 <andrewsw> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13952#a13952
08:21:38 <andrewsw> what I currently do is runMachine "aaab" 0 and it spits out a True or False for acceptance
08:21:48 <kmc> okay so you are using runState on the whole run
08:21:58 <aavogt> @. elite get
08:21:58 <lambdabot> Plugin `compose' failed with: Unknown command: "get"
08:22:08 <andrewsw> yep, is that a good thing? or a bad thing?
08:22:12 <kmc> seems reasonable
08:22:18 <aavogt> oh, no corrections for the compose plugin
08:22:18 <bos> yay, text library benchmark results: http://bit.ly/7kKSyD
08:22:19 <kmc> i was confused because you said runState step earlier
08:22:33 <andrewsw> yeah, sorry.
08:22:51 <kmc> andrewsw, what about:   runMachine  str st = fst (runState (machine str) st)
08:22:52 <kmc> :t fst
08:22:53 <lambdabot> forall a b. (a, b) -> a
08:23:10 <kmc> but also, there's this evalState
08:23:27 <andrewsw> oh sure, that's fine, but what I really want is to change the type of Delta to
08:23:38 <andrewsw> Delta = Symbol -> FSAState -> FSAState
08:23:49 <andrewsw> and when I do that the State constructor barfs on me
08:24:00 <andrewsw> because it expects a tuple.
08:24:03 <kmc> how about:  Symbol -> FSAState -> ((), FSAState)
08:24:12 <kmc> every monadic action has to produce a value, even if it's a useless one
08:24:33 <andrewsw> ah! okay. that's a rule I didn't know.
08:24:55 <andrewsw> so, you can't have just state with no value.
08:25:03 <kmc> it's because monads are built on this operator:
08:25:05 <kmc> :t (>>=)
08:25:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:25:21 <andrewsw> right.
08:25:36 <andrewsw> now it seems sort of obvious.
08:25:37 <HaskellLove_> is there a better way to traverse a list (string)? x<-[(fst number)..(last number)] where number = show n and n is this huuge number
08:26:25 <kmc> HaskellLove_, that's a range of characters?
08:26:37 <kmc> andrewsw, do you want other misc. tips on that code?
08:26:49 <andrewsw> but of course!
08:27:07 <HaskellLove_> kmc yes
08:27:21 <kmc> HaskellLove_, seems reasonable
08:27:48 <kmc> andrewsw, i'd write d1 using multiple equations rather than nested case expressions
08:28:17 <kmc> d1 'a' 0 = (False, 1);  d1 'b' 0 = (False, 0);  -- etc
08:28:26 <andrewsw> kmc: oh yeah, that's just a stupid test case.
08:29:00 <kmc> also, in your first equation for "machine" the "do" is unnecessary, since it's one statement.  you may prefer it for consistency
08:29:18 <kmc> and you could rewrite the second eqn on one line as:  step a >> machine as
08:29:31 <andrewsw> oh cool. okay.
08:29:43 <HaskellLove_> actually it is : x <- [(number !! 0)..(last number)], fst did not work on the string but last does... phew...
08:30:15 <kmc> also "machine" will fail on the empty string
08:30:29 <kmc> HaskellLove_, fst works on tuples.  you probably want "head", or better yet a pattern match
08:30:32 <andrewsw> kmc: flymake is already warning me about that.
08:31:06 <andrewsw> kmc: thanks for the tips! you've been super helpful!
08:31:10 <kmc> also you can rewrite "machine" using mapM
08:31:12 <kmc> no problem :)
08:31:22 <andrewsw> oh really? I tried that and couldn't get it to go
08:31:57 <andrewsw> oh!
08:32:02 <andrewsw> oh. maybe not.
08:32:59 <kmc> it's complicated by you wanting the last result
08:33:20 <andrewsw> I thought mapM required the same type on both "ends" for lack of a better term
08:33:23 <kmc> :t \f xs -> last <$> mapM f xs
08:33:24 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f a) -> [a1] -> f a
08:33:31 <kmc> :t mapM
08:33:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:34:27 <zygoloid> @type foldr1 (>>)
08:34:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
08:34:40 <zygoloid> @type foldr1 (>>) . map ?f
08:34:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?f::a1 -> m a) => [a1] -> m a
08:36:24 <andrewsw> kmc: I don't understand, but I have to go. I'll come back later and try again.
08:36:54 <zygoloid> @type runState
08:36:55 <lambdabot> forall s a. State s a -> s -> (a, s)
08:36:59 <zygoloid> @type evalState
08:37:00 <lambdabot> forall s a. State s a -> s -> a
08:37:11 <andrewsw> kmc: thanks for the help
08:37:13 <zygoloid> ^^ looks like you want evalState instead of runSTate
08:37:23 <andrewsw> zygoloid: yeah, sort of.
08:37:36 <andrewsw> out
08:42:11 <bos> @seen dons
08:42:11 <lambdabot> Unknown command, try @list
08:42:15 <bos> preflex: seen dons
08:42:15 <preflex>  dons was last seen on #haskell 1 day, 20 minutes and 26 seconds ago, saying: very odd
08:46:53 <HaskellLove_> I need advice how to MODEL this: x and xs, I need x to go from start to end of list, and xs to go from x to next four digits, so being a list of 5 elements. I had some attempts but failed and in imperative style i see the solution simply with two for loops.
08:47:39 <Zao> > tails [1..10]
08:47:40 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,...
08:48:36 <HaskellLove_> lambdabot: take 5 (tails [1..10])
08:48:39 <Lemmih> HaskellLove_: I do not follow.
08:49:24 <HaskellLove_> Lemmih it is the euler #8 man, i need to get maximum product of 5 consecutive elements in a list, so i need to traverse it like that u see?
08:49:42 <mauke> that's not "next four digits"
08:50:18 <Zao> So you want a list of all 5-element sublists.
08:50:29 <HaskellLove_> yes
08:50:41 <HaskellLove_> well defined :)
08:50:49 <mauke> more like substrings
08:50:50 --- mode: Lemmih set -o Lemmih
08:51:01 <copumpkin> > map inits . tails $ [1..5]
08:51:02 <lambdabot>   [[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]],[[],[2],[2,3],[2,3,4],[2,3,4,...
08:51:28 <copumpkin> > filter ((==5) . length) . filter (not . null) . concatMap inits . tails $ [1..10]
08:51:29 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
08:51:30 <Zao> > filter (\x -> length x == 5) $ map (take 5) $ tails [1..7]
08:51:31 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7]]
08:51:43 <copumpkin> mine is super inefficient but super cool
08:51:47 <Zao> Many fine solutions, all from composing building blocks.
08:52:10 <mauke> > map (take 5) $ tails [1..7]
08:52:16 <copumpkin> > filter (not . null) . concatMap inits . tails $ [1..]
08:52:16 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7],[5,6,7],[6,7],[7],[]]
08:52:19 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
08:52:31 <copumpkin> > filter (not . null) . concatMap tails . inits $ [1..]
08:52:36 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
08:52:36 <copumpkin> there we go
08:52:40 <mauke> > maximumBy (comparing product) . map (take 5) $ tails [1..7]
08:52:41 <lambdabot>   [3,4,5,6,7]
08:53:11 <copumpkin> HaskellLove_: this sounds like a dynamic programming problem, and is probably designed to be really slow if you do the naive thing
08:53:14 <Zao> mauke: Wouldn't that have the risk of identifying sequences <5 in length?
08:53:23 <Zao> Hrm, no.
08:53:30 <Zao> Unless you have negative numbers.
08:53:55 <Zao> Or numbers below 1, naturally.
08:54:00 <copumpkin> yeah
08:55:36 * hackagebot upload: text 0.6 - An efficient packed Unicode text type (BryanOSullivan)
08:55:38 * hackagebot upload: criterion 0.4.0 - Robust, reliable performance measurement and analysis (BryanOSullivan)
08:56:09 <HaskellLove_> copumpkin you frickin monster :D how can u compose all those functions like that man, how long are u in haskell?
08:56:39 <copumpkin> almost exactly a year of actual learning, about two months more if you count exposure :)
08:56:52 <Cale> seems like a sensible thing to write to me :)
08:56:58 <BONUS> yeah. you should see some other composition trickery that goes around here
08:57:02 * BMeph prefers '> tail . concatMap tails . inits $ [1..]'
08:58:02 <BONUS> > unfoldr (\x -> guard (length x > 4) >> Just (take 5 x, drop 1 x)) [1..10]
08:58:11 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
08:58:19 <copumpkin> > filter (not . null) . (tails <=< inits) $ [1..]
08:58:21 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
08:58:23 <copumpkin> super cute!
08:58:31 <BMeph> HaskellLove_:  I Tweeted this composition: qsort xs = (case (drop 1 xs) of { [] -> id; (x:_) -> uncurry . on (++) qsort . partition (<x)}) xs
08:58:42 <ziman> wow
08:58:56 <xerox> very cute  subsequences :)
08:58:58 <BONUS> hehe
08:58:58 <Cale> > takeWhile ((> 4) . length) . map (take 5) . iterate (drop 1) $ [1..10]
08:58:59 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10]]
08:59:22 <copumpkin> xerox: inits <=< tails gets stuck on infinite lists :(
08:59:26 <ziman> nice list-monad-fu :)
08:59:35 * copumpkin beams
08:59:35 <xerox> aww :(
08:59:42 <kmc> > fix (interleave "abc")
08:59:43 <lambdabot>   "aabacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbacbac...
08:59:48 <kmc> > fix (interleave "ab")
08:59:49 <lambdabot>   "aababababababababababababababababababababababababababababababababababababa...
09:00:00 <copumpkin> > filter (not . null) . tails <=< inits $ [1..]
09:00:01 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4],[1,2,3,4,5],[2...
09:00:03 <kmc> > fix (interleave (cycle ['a'..'z']))
09:00:04 <lambdabot>   "aabacbdaecfbgdhaiejckflbmgndohpaqiresjtcukvfwlxbymzganbdcodhepfagqhiirjeks...
09:00:08 <copumpkin> yay, the precedence fits
09:00:28 <HaskellLove_> showofs :D
09:00:30 <BMeph> > tail . tails <=< inits $ [1..]
09:00:31 <lambdabot>   [[],[2],[],[2,3],[3],[],[2,3,4],[3,4],[4],[],[2,3,4,5],[3,4,5],[4,5],[5],[]...
09:00:47 <BMeph> Ah, multipicles! ;p
09:00:48 <HaskellLove_> copumkin u work with haskell man or exposure in coledge or something?
09:01:46 <kmc> exposure in the womb
09:02:03 <xerox> > filterM (const [True,False]) [1,2,3,4,5]
09:02:08 <lambdabot>   [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1...
09:02:19 <copumpkin> HaskellLove_: my girlfriend took a haskell course and I thought it looked really cool, so I started hanging out here
09:02:43 <copumpkin> before this I was a rubyhead :)
09:02:45 <HaskellLove_> copumkin hahaha u motherfucker way the go :D
09:02:55 <copumpkin> lol
09:03:01 <mauke> your spelling makes me a sad panda
09:03:11 * copumpkin is a sad platypus
09:03:31 <Raevel> :-(
09:03:40 * BMeph got pointed at Haskell by following slava
09:04:13 <copumpkin> enslaved by slava
09:04:22 <shepheb> BMeph: I wish the people I stalk could introduce me to things as good as Haskell.
09:04:26 <shepheb> :P
09:04:44 <fracture> is there a function to apply a function to a tuple?
09:04:54 <fracture> meaning taking the tuple elements as arguments
09:04:58 <mauke> yes, uncurry
09:05:09 <kmc> :t uncurry
09:05:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:05:22 <fracture> nice, thanks
09:06:46 <BMeph> shepheb: :D
09:07:27 <BMeph> fracture: Note that it only works for pairs. :\
09:07:31 <shepheb> BMeph: watching him on his laptop from across a cafe. "He's programming... what language is that? Looks interesting."
09:07:44 <fracture> BMeph: yeah, saw that... (happns to be exactly what I need i this case though)
09:07:55 <fracture> maybe some combo with folding can do arbitrary args?
09:08:10 <fracture> .. oh maybe not
09:08:18 <fracture> I'm thinking like lists...
09:08:34 <BMeph> shepheb: Mine was more of a "Cool, this language looks more like Forth than Joy. Wait, what's that language he's complaining about? Hmm, that looks interesting... ;)
09:09:03 <BONUS> i don't even remember how i got into haskell, i think i fell in by accident
09:09:17 <shepheb> haha. I've looked into Factor, it's not bad.
09:09:18 <copumpkin> BONUS: I think you were riding the pink unicorn over the rainbow and fell off
09:09:28 <BONUS> haha
09:09:34 <shepheb> I got into Haskell because some Perl Monks had mentioned it in the context of Pugs.
09:09:41 <SamB_XP_> I blame exarkun
09:09:43 <tensorpudding> you fell in with the wrong crowd
09:09:46 <tensorpudding> the haskell crowd
09:09:56 <mauke> the haskell nomads
09:10:01 <copumpkin> BONUS: omg infinite jaffa cakes! that would make GHC super amazing in 0 time
09:10:03 <SamB_XP_> exarkun gave up on learning Haskell, though
09:10:08 <SamB_XP_> sometimes I tease him about it ;-P
09:10:15 <BONUS> one can dream
09:10:15 * shepheb pictures #haskell like a gang from West Side Story, circling and clicking our fingers.
09:10:22 <kmc> can i have a jaffa cake
09:10:31 <kmc> is this a feature for 6.12
09:10:43 <tensorpudding> we can't be the gang from west side story without rivals
09:10:49 <copumpkin> I can haz JaffaCake
09:10:57 <SamB_XP_> isn't he sleeping ?
09:11:09 <copumpkin> maybe
09:11:37 * copumpkin got caught in universe polymorphism!
09:11:58 <SamB_XP_> oh, you meant to be talking about the Star Wars universe only ?
09:12:27 <copumpkin> :o
09:12:48 <shepheb> tensorpudding: hmm, who would our greased-hair, jazz tapping rivals be?
09:13:32 <ohday> Is there a pdf of real world haskell available? :)
09:13:52 <ivanm> ohday: not for free AFAIK
09:13:54 <SamB_XP_> ohday: the HTML isn't good enough for you ?
09:15:31 <ohday> SamB_XP_, I'm simply asking if there's one available.
09:15:40 <ohday> ivanm, Thanks.
09:15:49 <SamB_XP_> bos: is this so?
09:15:51 <ohday> Might I know why people generally prefer GHC over Hugs?
09:16:00 <SamB_XP_> ohday: 'cause it's better!
09:16:23 <ohday> Why...
09:16:28 <mauke> ohday: better error messages; 'let' at the interpreter prompt; compiler; more language extensions
09:16:30 <SamB_XP_> well, really, 'cause it has more extensions, can compile, and ...
09:16:46 <ohday> mauke, :) thanks.
09:16:57 <ohday> SamB_XP_, uh huh, ok.
09:17:23 <ohday> BONUS BONUS_: around?
09:17:28 <kmc> because it's GLORIOUS
09:17:35 <tensorpudding> do people still use hugs?
09:18:07 <kmc> hugs could be useful for ultra portability
09:18:22 <ohday> Not a lot of documentation/compilers based on the haskell prime/2010 standard are there?
09:18:39 <kmc> ohday, those are mostly codifying extensions that have been in GHC for a long time
09:18:43 <ohday> Is there an official document like a draft of some sort?
09:19:02 <kmc> if you read the extensions section of the GHC manual you will learn about those and also plenty more that haven't made it into H2010
09:19:25 <tensorpudding> haskell prime is not haskell 2010...haskell 2010 is the first phase
09:19:43 <ohday> kmc: So, I should read compiler documentation to figure out more about the language standard?
09:19:51 <SamB_XP_> ohday: no!
09:20:03 <ohday> tensorpudding, I'm just looking for a haskell standard draft or something =)
09:20:06 <kmc> ohday, no.  you should read compiler documentation to learn about things that may be in the standard down the line
09:20:11 <ohday> For 2010 or prime.
09:20:28 <kmc> haskell prime is the name of the ongoing standardization project
09:20:31 <kmc> it's not a standard
09:20:33 <MarcWeber> How do you think about making hsql support extensible exceptions?
09:20:37 <tensorpudding> haskell prime is sort of just a collection of "extensions that people are using en masse that we want to be standardized someday"
09:20:38 <kmc> ohday, http://www.haskell.org/pipermail/haskell/2009-November/021750.html
09:20:47 <tensorpudding> and "nice things to have"
09:21:02 <ohday> Then Haskell 2010's draft!
09:21:09 <ohday> Do you have a draft for haskell 2010?
09:21:14 <mauke> why draft?
09:21:19 <kmc> ohday, i just sent you a link
09:21:21 <mauke> you have the 98 standard and the diffs
09:21:24 <kmc> it enumerates the extensions in H2010
09:21:25 <ohday> Ah ok.
09:21:31 <tensorpudding> the specifics on what haskell 2010 has is available are in that link that kmc sent
09:21:33 <kmc> each of them is described on the haskell-prime trac wiki, also linked from there
09:21:40 <ohday> mauke: do you have a linsk to the haskell 98 std?
09:21:41 <mauke> also /topic
09:21:47 <ohday> mauke: thanks.
09:21:50 <kmc> @google haskell 98 report
09:21:52 <lambdabot> http://www.haskell.org/onlinereport/
09:21:52 <lambdabot> Title: The Haskell 98 Language Report
09:21:58 <mauke> @where report
09:21:58 <lambdabot> http://www.haskell.org/onlinereport/
09:22:12 <kmc> ohday, the extensions in H2010 are really conservative
09:22:51 <kmc> unfortunately a lot of the stuff not in H2010 is still essential for doing real work in haskell
09:23:38 <stoop> kmc, such as?
09:23:58 <kmc> MultiParameterTypeClasses, Rank2Types
09:24:07 <tensorpudding> gadts!
09:24:18 <kmc> one of: fundeps or type families
09:24:28 <kmc> ExistentialTypes
09:24:32 <kmc> ImpredicativePolymorphism
09:24:46 <copumpkin> I think both fundeps and type families should coexist
09:24:47 <kmc> unboxed stuff
09:25:05 <MarcWeber> I need some advice: hsql is still usng throwDyn. I think it can replaced by using extensibel exceptions only.
09:25:08 <ohday> Thanks *
09:25:12 <kmc> relaxed instance declarations
09:25:13 --- mode: ChanServ set +o mauke
09:25:14 --- mode: mauke set +b nlogax!n=nlogax@unaffiliated/nlogax
09:25:21 <MarcWeber> However I'm not sure how much code will break when doing so.
09:25:22 <kmc> ...?
09:25:33 <copumpkin> kmc: quitting and rejoining automatically a lot
09:25:37 <kmc> ah
09:25:38 <copumpkin> connection problems probably, but annoying
09:25:46 <HaskellLove_> how can i get out the biggest number from a list?
09:25:56 <MarcWeber> HaskellLove_: max ?
09:25:58 <mauke> HaskellLove_: maximum
09:26:00 <kmc> :t maximum
09:26:01 <lambdabot> forall a. (Ord a) => [a] -> a
09:26:07 <tensorpudding> @src maximum
09:26:07 <lambdabot> maximum [] = undefined
09:26:07 <lambdabot> maximum xs = foldl1 max xs
09:26:14 --- mode: mauke set -o mauke
09:26:17 <tensorpudding> hmm
09:26:21 <tensorpudding> @src max
09:26:21 <lambdabot> max x y = if x <= y then y else x
09:26:28 <tensorpudding> ah, nice
09:26:37 <kmc> > maximum $ words "hello everybody out there in haskell land"
09:26:37 <shachaf> Why does maximum need to define the [] case?
09:26:38 <lambdabot>   "there"
09:26:43 <stoop> > maximum [1 ..]
09:26:46 <mauke> shachaf: it doesn't
09:26:47 <stoop> omega
09:26:50 <lambdabot>   mueval: ExitFailure 1
09:26:52 <kmc> our source is sort of fake
09:26:57 <kmc> > minimum [1..]
09:27:03 <lambdabot>   mueval-core: Time limit exceeded
09:27:05 <mauke> > maximum []
09:27:05 <stoop> kmc, hehe
09:27:06 <lambdabot>   * Exception: Prelude.maximum: empty list
09:27:15 <mauke> shachaf: better error messages
09:27:17 <tensorpudding> > maximum "1 2 3 4 over_9000"
09:27:18 <kmc> it's a shame you can't specify a default
09:27:18 <lambdabot>   'v'
09:27:24 <tensorpudding> whoops
09:27:45 <shachaf> mauke: ...But it uses undefined.
09:27:45 <stoop> > maximum $ words "1 2 3 4 over_9000"
09:27:45 <mauke> kmc: maximum (default : rest) ?
09:27:46 <lambdabot>   "over_9000"
09:27:55 <mauke> shachaf: don't believe everything lambdabot tells you
09:27:57 <kmc> > maximum [minBound .. maxBound] :: Word8
09:27:59 <lambdabot>   255
09:28:07 <tensorpudding> > maximum []
09:28:08 <lambdabot>   * Exception: Prelude.maximum: empty list
09:28:38 <tensorpudding> that's actually an okay error message
09:28:50 <shachaf> @karma- lambdabot
09:28:51 <lambdabot> lambdabot's karma lowered to -4.
09:28:54 <kmc> > let max0 = maximum . (0:) in (max0 [1,2,3], max0 [])
09:28:55 <shachaf> Aw.
09:28:56 <lambdabot>   (3,0)
09:28:58 <shachaf> @karma+ lambdabot
09:28:58 <lambdabot> lambdabot's karma raised to -3.
09:29:10 <kmc> preflex, karma lambdabot
09:29:10 <preflex>  lambdabot: 9
09:29:26 <kmc> > cycle "lambdabot++ "
09:29:27 <lambdabot>   "lambdabot++ lambdabot++ lambdabot++ lambdabot++ lambdabot++ lambdabot++ la...
09:29:36 <kmc> > cycle "kmc++ "
09:29:39 <lambdabot>   "kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ kmc++ km...
09:29:39 <ivanm> @karma lambdabot
09:29:41 <lambdabot> lambdabot has a karma of -3
09:29:42 <stoop> > maximum [(()), ()]
09:29:43 <lambdabot>   ()
09:29:43 <shachaf> preflex: karma lambdabot
09:29:44 <preflex>  lambdabot: 10
09:29:49 <stoop> > minimum [(()), ()]
09:29:50 <lambdabot>   ()
09:29:51 <kmc> > (()) == ()
09:29:52 <lambdabot>   True
09:29:53 <ivanm> kmc--
09:29:58 <stoop> > minimum [(()), (), (())]
09:29:59 <lambdabot>   ()
09:30:01 <mauke> > cycle "kmc-- "
09:30:01 <ivanm> for trying to rort the system!
09:30:03 <lambdabot>   "kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- km...
09:30:07 <tensorpudding> > minimum [1..]
09:30:17 <lambdabot>   mueval: ExitFailure 1
09:30:20 <mauke> wait, what
09:30:33 <roconnor> 1
09:30:42 <ivanm> tensorpudding: it tries to find the minimum after evaluating the entire list...
09:30:47 <tensorpudding> yes, i know
09:30:49 <stoop> > (((((((((()))))))))) == ()
09:30:52 <lambdabot>   True
09:31:03 <kmc> > [[]] == []
09:31:04 <lambdabot>   False
09:31:15 <tensorpudding> unless it had reason to believe the list were sorted, it has no better way
09:31:17 <copumpkin> > minimum [0..] :: Natural
09:31:17 <stoop> Sure. :-P
09:31:25 <lambdabot>   mueval: ExitFailure 1
09:31:35 <tensorpudding> but sorted lists are pretty simple to find the minimum of
09:31:46 <stoop> roconnor, haha
09:31:54 <copumpkin> > foldr1 min [0..] :: Natural
09:31:54 <kmc> yeah there are prelude functions for that
09:31:56 <lambdabot>   0
09:32:01 <copumpkin> there we go
09:32:03 <copumpkin> damn foldls where they don't belong
09:32:08 <HaskellLove_> [(head number)..(last number)] why does this give me empty string, number is like this huge 1000 digit number turned into string
09:32:27 <kmc> > ['5'..'3']
09:32:28 <lambdabot>   ""
09:32:47 <stoop> > ["3" .. "10"]
09:32:47 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
09:32:48 <lambdabot>    arising from the arithm...
09:32:50 <stoop> Uh oh
09:32:53 <kmc> > let number = show "5483728493853" in [(head number) .. (last number)]
09:32:53 <lambdabot>   "\""
09:32:59 <kmc> err
09:33:04 <kmc> > let number = show 5483728493853 in [(head number) .. (last number)]
09:33:05 <lambdabot>   ""
09:33:40 <HaskellLove_> by the way this is the last step me solving the euler #8 :(
09:33:53 <ivanm> kmc: ['5' .. '3'] == []
09:34:03 <copumpkin> that's what he's showing HaskellLove_
09:35:07 <stoop> :t (undefined * undefined) ** undefined / (0.5 :: Double)
09:35:10 <lambdabot> Double
09:35:30 <ivanm> ahhh
09:35:45 <kmc> HaskellLove_, you are asking for every digit between '5' and '3'
09:35:46 <xerox> HaskellLove_: what is that code supposed to do?
09:35:48 <kmc> or something like that
09:36:20 <HaskellLove_> ok let me try again
09:36:38 <HaskellLove_> max = maximum (map sum (map (take 5) $ tails [$ digitToInt $ head number .. $ digitToInt $ last number]
09:36:50 <HaskellLove_> that is my euler #8 just one more problem to solve it
09:36:55 <copumpkin> whoa, too many dollars
09:37:04 <aavogt> yeah, they're expensive
09:37:14 <HaskellLove_> expensive?
09:37:18 <copumpkin> lots of money
09:37:35 <HaskellLove_> seriosly guys are they expensive and hard on the parser?
09:37:37 <Lemmih> HaskellLove_: He's kidding.
09:37:45 <mauke> hahaha
09:37:50 <HaskellLove_> oh :D man i almost got a heart attack
09:37:51 <ivanm> they use euros now, not dollars
09:37:53 <ivanm> ;-)
09:38:10 <kmc> "hard on the parser"?
09:38:12 <aavogt> euros are flipped function application in some book I recall
09:38:22 <copumpkin> €
09:38:35 <kmc> > let () = elem in 3  [1..5]
09:38:38 <lambdabot>   True
09:38:40 <HaskellLove_> kmc - yep, depends how it is structures, translating a bracket may be one step and translating a $ may be more steps
09:38:46 <kmc> but... why do you care
09:38:49 <kmc> how long the parser takes
09:38:56 <kmc> unless your compilation times are actually an issue
09:38:57 <HaskellLove_> cause i am ninja and i want it to be fast
09:39:02 <copumpkin> lol
09:39:13 <aavogt> if you use ghc-api and evaluate your code at runtime of course
09:39:17 <tensorpudding> are you looking for the real ultimate haskell power?
09:39:17 <kmc> you do realize that this is a compile-time issue, right?
09:39:35 <Cale> HaskellLove_: Try to get used to using composition more than ($), since it refactors better. Whenever you have something like  f $ g $ h $ x  you can always replace it with  f . g . h $ x  but the difference is that now things like  g . h  and  f . g  have meaning on their own, where  f $ g and g $ h would have been type errors.
09:39:37 <kmc> GHC's parser isn't running while your program is running
09:40:47 <HaskellLove_> kmc got it
09:41:03 <HaskellLove_> Cale thank you so much i will note that now in my blog
09:42:00 <HaskellLove_> Cale hmm... do you sugest actually to not use map and $ an instead use .? i mean u use $ with map...
09:42:08 <kmc> you have a blog?
09:42:29 <copumpkin> @quote Wikipedia In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
09:42:29 <lambdabot> No quotes for this person. Take a stress pill and think things over.
09:42:29 <HaskellLove_> kmc from today :) i document my thinking process for euler in haskell funcitonal way
09:42:35 <copumpkin> @remember Wikipedia In topology, the long line (or Alexandroff line) is a topological space analogous to the real line, but much longer.
09:42:36 <lambdabot> Okay.
09:42:45 <xerox> copumpkin: true that! :)
09:42:59 <stoop> HaskellLove_, are you Macedonian?
09:43:00 <kmc> copumpkin, haha
09:43:14 <HaskellLove_> stoop yeah
09:43:19 <tensorpudding> copumpkin: that's awesome
09:43:29 <stoop> Cool, one of my closest friends is Macedonian.
09:43:50 <copumpkin> just like Alexander
09:43:58 <xerox> I forget what counterexample is it for
09:44:06 <copumpkin> http://en.wikipedia.org/wiki/Long_line_(topology)
09:44:12 <copumpkin> more info in case people are feeling lazy
09:44:16 <Cale> HaskellLove_: I don't understand that question
09:44:41 <Cale> HaskellLove_: map and (.) happen to both be special cases of fmap, and so I'd like to generalise both into the same thing
09:44:51 <HaskellLove_> Cale you said not to use $ and instead use .   but i use the $ with map
09:44:59 <Cale> HaskellLove_: in which case?
09:45:09 <Cale> HaskellLove_: There are places where ($) is the right thing
09:45:12 <HaskellLove_> so is the advice dont use $ and use brackets or the advice was use . instead of map
09:45:25 <kmc> HaskellLove_, the idea is that (f $ g $ h $ x) should be written (f . g . h $ x)
09:45:33 <Cale> HaskellLove_: It's just where you chain more than one $ in a row where you'll want to replace it with (.)
09:45:42 <tensorpudding> you can use parens and (.)  anywhere you use ($)
09:45:48 <xerox> ah simply connected but not contractible, nice
09:45:48 <tensorpudding> but that won't necessarily make things clearer
09:45:56 <HaskellLove_> ah ah ok sorry got it now
09:46:09 <stoop> @src (.)
09:46:09 <lambdabot> (f . g) x = f (g x)
09:46:31 <stoop> > (+ 1) . (* 2) $ 5
09:46:32 <lambdabot>   11
09:46:34 <tensorpudding> (.) behaves exactly like the composition in mathematics
09:46:42 <copumpkin> just don't look at its type
09:46:48 <stoop> haha
09:46:51 <vovik> @pl (f . g) x = f (g x)
09:46:52 <lambdabot> (line 1, column 11):
09:46:52 <lambdabot> unexpected "="
09:46:52 <lambdabot> expecting variable, "(", operator or end of input
09:47:01 <copumpkin> if you really want a scary type, you should see the type of dependent composition
09:47:14 <stoop> copumpkin, let's see.
09:47:24 <vovik> uh oh it can't make . pointfree
09:47:39 <mauke> @pl \f g x -> f (g x)
09:47:41 <copumpkin> ∀ {a b c} {A : Set a} {B : A → Set b} {C : {x : A} → B x → Set c} → (∀ {x} (y : B x) → C y) → (g : (x : A) → B x) → ((x : A) → C (g x))
09:47:41 <copumpkin> in agda
09:47:41 <lambdabot> (.)
09:47:46 <mauke> yay!
09:47:53 <tensorpudding> how would you make (.) pointfree?
09:48:00 <copumpkin> tensorpudding: you wouldn't!
09:48:11 <HaskellLove_> will someone correct this one for me with . and no $ stuff? i tried i dont why it confuses me :
09:48:11 <tensorpudding> yes
09:48:13 <HaskellLove_> max = maximum (map sum (map (take 5) $ tails [$ digitToInt $ head number .. $ digitToInt $ last number]
09:48:25 <mauke> HaskellLove_: that looks like a syntax error
09:48:29 <stoop> @botcrack
09:48:29 <lunabot>  :o
09:48:29 <lambdabot> :)
09:48:34 <tensorpudding> also agda is confusing enough without things like that copumpkin
09:48:34 <mauke> correction, two syntax errors
09:48:36 <copumpkin> @buttcrack
09:48:36 <lambdabot> Unknown command, try @list
09:48:40 <kmc> HaskellLove_, "[$" ?
09:48:48 <stoop> @pl \f g x -> x
09:48:48 <lambdabot> const (const id)
09:48:48 <copumpkin> tensorpudding: but it's just function composition :(
09:48:56 <stoop> @pl \f g x -> f (g x)
09:48:56 <lambdabot> (.)
09:49:06 <stoop> Oh, I didn't see the response. :-P
09:49:14 <kmc> copumpkin, that version is universe-polymorphic?
09:49:32 <copumpkin> kmc: yeah, but even without universe polymorphism it's significantly more complicated than haskell's composition type
09:49:40 <kmc> what is the type of the index of Set, e.g. a b c?
09:49:46 <copumpkin> kmc: Level
09:50:01 <kmc> so Set : Level -> Set ... ?
09:50:14 <stoop> eek
09:50:31 <HaskellLove_> max = maximum (map sum (map (take 5) $ tails [$ digitToInt $ head number .. $ digitToInt $ last number])) missed the last brackets there you go now its ok i think
09:50:49 <mauke> HaskellLove_: that looks like a syntax error
09:51:01 <HaskellLove_> where?
09:51:04 <mauke> [$
09:51:07 <copumpkin> _∘_ : {A : Set} {B : A → Set} {C : {x : A} → B x → Set} → (∀ {x} (y : B x) → C y) → (g : (x : A) → B x) → ((x : A) → C (g x)) -- is the version pre-universe-polymorphism
09:51:22 <tensorpudding> @type maximum (map sum (map (take 5) $ tails [$ digitToInt $ head number .. $ digitToInt $ last number]))
09:51:23 <lambdabot> parse error on input `$'
09:51:24 <Cale> Also, the  ..  in the middle of that can't possibly be right
09:51:26 <ray> that's longer!
09:51:49 <Cale> Er, I see, you probably just want to drop the initial $'s
09:52:00 <HaskellLove_> max = maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number])) now?
09:52:06 <tensorpudding> @type maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. $ digitToInt $ last number]))
09:52:07 <lambdabot> parse error on input `$'
09:52:22 <Cale> tensorpudding: both of them
09:52:43 <tensorpudding> @type maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number]))
09:52:44 <lambdabot> Not in scope: `number'
09:52:44 <lambdabot> Not in scope: `number'
09:52:59 <Cale> @type \number -> maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number]))
09:53:00 <tensorpudding> @type \number -> maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number]))
09:53:02 <lambdabot> [Char] -> Int
09:53:03 <lambdabot> [Char] -> Int
09:53:12 <tensorpudding> yargh, beaten
09:56:35 <tensorpudding> > (\number -> maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number]))) "this is my string, there are many like it, but this one is mine"
09:56:43 <lambdabot>   * Exception: Char.digitToInt: not a digit 't'
09:57:22 <HaskellLove_> I know just leave that, now i am trying to convert it to all dots and no dollars, i will handle the part in the digitToInt later
09:58:10 <tensorpudding> > (\number -> maximum (map sum (map (take 5) $ tails [digitToInt $ head number .. digitToInt $ last number]))) "123456"
09:58:11 <lambdabot>   20
09:58:20 <tensorpudding> hmm
09:58:25 <aavogt> > a.b.c.d.e.f.g.h.i.j.k.l.m.n.o.p.q.r.s.t.u.v.w.x.y.z$Nothing
09:58:28 <lambdabot>   Couldn't match expected type `a -> b'
09:58:28 <lambdabot>         against inferred type `Simple...
09:58:29 <tensorpudding> sum [1..6]
09:58:30 <tensorpudding> > sum [1..6]
09:58:31 <lambdabot>   21
09:58:37 <tensorpudding> close
09:58:48 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in sum (takeWhile (<2000000) primes)
09:58:52 <lambdabot>   mueval-core: Time limit exceeded
09:59:28 <HaskellLove_> this part is not correct just leave it guys : digitToInt $ head number .. digitToInt $ last number it wont go from the first to last element but from that number to that u see... will handle that later help me now convert all that into dots notation and composition like
10:02:29 <vovik> HaskellLove_: just write your function like you were going to, then you could always convert it automatically if you want
10:02:42 <vovik> HaskellLove_: then try to reverse engineer it or something
10:03:00 <vovik> HaskellLove_: observe
10:03:02 <vovik> @pf \x -> x + 3
10:03:03 <lambdabot> Maybe you meant: bf pl
10:03:03 <HaskellLove_> yeah i tried but confuses me a lot
10:03:10 <vovik> @pl \x -> x + 3
10:03:11 <lambdabot> (3 +)
10:03:30 <tensorpudding> @pl \f x -> f x
10:03:31 <lambdabot> id
10:03:38 <Axman6> interesting, it knows the that (+3) and (3+) are the same
10:03:48 <copumpkin> yeah, I'd consider that a bug
10:03:59 <vovik> @pf \x -> x - 3
10:03:59 <lambdabot> Maybe you meant: bf pl
10:04:05 <vovik> @pl \x -> x - 3
10:04:08 <lambdabot> subtract 3
10:04:16 <vovik> lol
10:04:29 <vovik> lambdabot, sneaky bastard
10:04:49 <tensorpudding> oh shit, it's learning
10:04:57 <HaskellLove_> pf stands for?
10:05:03 <HaskellLove_> machine learning wooow
10:05:07 <kmc> yeah, they needn't be the same
10:08:37 <HaskellLove_> is there a way to traverse strings elements from the first to the last one? i mean, this does not work:
10:08:39 <HaskellLove_> head "ninja" .. last "ninja"
10:08:43 <vovik> pf stands for point-free
10:08:47 <kmc> HaskellLove_, what do you want to do at each one?
10:08:59 <kmc> you probably want "map"
10:08:59 <Cale> HaskellLove_: yes, "ninja"
10:09:11 <Cale> HaskellLove_: Strings are lists already
10:09:43 <kmc> HaskellLove_, (head "ninja") is 'n' and (last "ninja") is 'a'.  so you are asking for all the characters in the alphabet between 'n' and 'a'
10:09:56 <HaskellLove_> i want it to range over the first toward the last element of the list and my list is this: i have number n like 232323232394333333333333333333333 and then number = show n, and then i want to traverse each digit from start to end u see?
10:10:04 <kmc> travers and do what?
10:10:06 <copumpkin> you want map
10:10:13 <copumpkin> not ..
10:10:16 <benmachine> or foldr?
10:10:26 <copumpkin> > map succ (show 232323232394333333333333333333333)
10:10:27 <lambdabot>   "3434343434:5444444444444444444444"
10:10:45 <kmc> > map (\x -> "digit: " ++ show x) (show 12345)
10:10:46 <lambdabot>   ["digit: '1'","digit: '2'","digit: '3'","digit: '4'","digit: '5'"]
10:10:51 <kmc> > concatMap (\x -> "digit: " ++ show x) (show 12345)
10:10:52 <lambdabot>   "digit: '1'digit: '2'digit: '3'digit: '4'digit: '5'"
10:11:57 <aavogt> > [head "aah" .. last "aah"]
10:11:58 <lambdabot>   "abcdefgh"
10:12:00 <HaskellLove_> copumkin not like that, the sucesor i want is the next digit, not a digit bigger then it
10:12:36 <aavogt> > succ '9'
10:12:36 <Cale> HaskellLove_: You *do* realise that a string is a list of characters?
10:12:37 <lambdabot>   ':'
10:13:17 <kmc> HaskellLove_, you keep saying you want to "traverse" or "get the next digit" but.... what are you *doing* with these digits?
10:13:26 <HaskellLove_> Cale yes but was confused how to traverse... now i know...
10:14:05 <HaskellLove_> well just to map that range, and from there another functions take over like tails and map(take 5)
10:14:10 <kmc> typically you will either a) compute a new list element from each one, or b) compute some aggregate property by combining them
10:14:19 <kmc> those are abstracted as "map" and "foldr" respectively
10:15:22 <xerox> > unfoldr (\x -> case (divMod x 10) of (0,0) -> Nothing; (d,r) -> Just (r,d)) 1234
10:15:23 <lambdabot>   [4,3,2,1]
10:15:30 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in isPrime 563
10:15:31 <lambdabot>   True
10:15:45 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in findIndex 563 primes
10:15:47 <lambdabot>   No instance for (GHC.Num.Num (a -> GHC.Bool.Bool))
10:15:47 <lambdabot>    arising from the lite...
10:15:59 <roconnor> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in findIndex (563==) primes
10:16:00 <lambdabot>   Just 102
10:18:21 <HaskellLove_> hope this works: map digitToInt ((head number) .. (last number)) Cale why I dont think that this will work? so i first go from first to last element and then map digitToInt to it
10:18:38 <mauke> that doesn't go from first to last element
10:18:55 <HaskellLove_> mauke I know but i cant find a way
10:19:02 <mauke> map digitToInt number
10:19:38 <kmc> > map digitToInt (show 1453849)
10:19:39 <lambdabot>   [1,4,5,3,8,4,9]
10:19:51 <kmc> HaskellLove_, is that what you want?
10:19:58 <HaskellLove_> you are my hero kmc :D
10:20:40 <kmc> "map" is already the concept of traversing, and "number" or (show 1453849) is already a list.  you don't need to do anything else.
10:20:49 <kmc> you just tell it what function to apply on every element
10:21:34 <xerox> > let {isPrime x = all ((1==). (gcd x)) (takeWhile (\p -> p^2 <= x) primes); primes = 2:filter isPrime [3,5..]} in all isPrime [ 11 + 2*n^2 | n <- [0..10] ]
10:21:35 <lambdabot>   True
10:21:45 <kmc> ((head x) .. (last x)) is not a list of the first through last element of x.
10:22:00 <kmc> > let x = [1, 4, 7] in [(head x) .. (last x)]
10:22:01 <lambdabot>   [1,2,3,4,5,6,7]
10:22:10 <kmc> it goes by counting / alphabetical order, not by the sequence x
10:22:26 <kmc> because (head x) and (last x) both throw out all but one element... there is no way for the ".." operation to see the rest
10:25:15 --- mode: ChanServ set +o mauke
10:25:16 --- mode: mauke set -b nlogax!n=nlogax@unaffiliated/nlogax
10:26:16 --- mode: mauke set -o mauke
10:26:23 <Philonous> "head x" is not a pointer or a reference but just the first value in x
10:26:42 <HaskellLove_> got it
10:27:00 <HaskellLove_> I just put it like that to solve later i did not know how so... put it as pseudo
10:27:51 <kmc> ".." always counts in a single order that is defined per type
10:28:00 <kmc> it is defined by making the type an instance of Enum
10:28:01 <kmc> @instances Enum
10:28:04 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:28:11 <kmc> the Float instance is sketchy
10:28:12 * Bynbo7 wonders if there's a name for f xs = [min xs .. max xs]
10:28:27 <kmc> @pl \xs -> [min xs .. max xs]
10:28:27 <lambdabot> liftM2 enumFromTo min max
10:28:37 <aavogt> > enumFromTo minBound maxBound
10:28:38 <lambdabot>   [()]
10:28:45 <kmc> > enumFromTo minBound maxBound :: [Char]
10:28:46 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
10:29:01 <Axman6> aavogt: not quite the same
10:29:01 <aavogt> @hoogle (Enum a, Bounded a) => [a]
10:29:05 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
10:29:05 <lambdabot> Prelude maxBound :: Bounded a => a
10:29:05 <lambdabot> Prelude minBound :: Bounded a => a
10:29:50 <aavogt> hmm true
10:30:46 <kmc> > liftM2 enumFromTo minimum maximum "hello world"
10:30:47 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg...
10:30:58 <kmc> > liftM2 enumFromTo minimum maximum "helloworld"
10:30:59 <lambdabot>   "defghijklmnopqrstuvw"
10:31:50 <Philonous> > [0.0.. 3.1415] :: Double
10:31:51 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
10:31:51 <lambdabot>         against inferred ty...
10:32:03 <kmc> > [0 .. pi] :: [Double]
10:32:04 <lambdabot>   [0.0,1.0,2.0,3.0]
10:33:04 <Philonous> Oh, enumerations need not exhaustive. Well that makes it a whole lot easier
10:33:10 <Philonous> +be
10:37:48 <HaskellLove_> how to convert a string to a value? I tried: read "24545" but nope...
10:38:18 <mauke> what do you mean by "nope"?
10:38:19 <aavogt> strings are values
10:38:33 <aavogt> I recomend the use of id for such conversions
10:38:36 <copumpkin> > read "24545" :: Int
10:38:37 <lambdabot>   24545
10:38:45 <tensorpudding> @type read
10:38:46 <lambdabot> forall a. (Read a) => String -> a
10:38:50 <aavogt> > id "24545"
10:38:51 <lambdabot>   "24545"
10:39:00 <copumpkin> real helpful ;)
10:39:27 <aavogt> @vixen you're also quite helpful
10:39:27 <tensorpudding> id is great
10:39:28 <lambdabot> you sir are no gentleman
10:40:03 <roconnor> > ($)  "24545"
10:40:04 <lambdabot>   Couldn't match expected type `a -> b'
10:40:04 <lambdabot>         against inferred type `[GHC.T...
10:40:22 <roconnor> > id $  "24545"
10:40:23 <lambdabot>   "24545"
10:40:32 <roconnor> @pl id $  "24545"
10:40:33 <lambdabot> "24545"
10:40:36 <copumpkin> > id id "24545"
10:40:37 <lambdabot>   "24545"
10:41:16 <HaskellLove_> wow this is cool i have never executed a function like this: read "24545" :: Int sayng the type after it woooooooow
10:41:33 <kmc> HaskellLove_, the syntax (e :: t) is a type signature.  it says that the expression e has type t
10:41:48 <kmc> it's not a cast or anything; it won't change the type.  it's just that in this case, the compiler cannot figure out the type without a hint
10:41:56 <kmc> > (2 + 3) :: Int
10:41:57 <lambdabot>   5
10:41:59 <kmc> > (2 + 3) :: Char
10:42:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:42:00 <lambdabot>    arising from the literal `2...
10:42:17 <Philonous> @instances Num
10:42:18 <lambdabot> Double, Float, Int, Integer
10:42:26 <HaskellLove_> awesome, i never executed a func like that... of course i know :: means type and so on...
10:43:29 <aavogt> > id`id`id`id`id`id`id`id`id`id`id`1
10:43:30 <lambdabot>   <no location info>: parse error on input `1'
10:43:55 <aavogt> > id`id`id`id`id`id`id`id`id`id`1
10:43:56 <lambdabot>   1
10:44:10 <xerox> haha what changed?
10:44:25 <aavogt> unmatched `
10:45:19 <kmc> HaskellLove_, it's different from a signature on a binding at top level
10:45:27 <HaskellLove_> how to find read :: Int in the docs? there is only read for taking string but from input, getLine and stuff not like this... where to read on this function?
10:45:37 <kmc> @hoogle read
10:45:37 <lambdabot> Prelude read :: Read a => String -> a
10:45:37 <lambdabot> Text.Read read :: Read a => String -> a
10:45:37 <lambdabot> module Text.Read
10:46:02 <HaskellLove_> kmc yeah i searched on hoogle but nothing
10:46:04 <kmc> HaskellLove_, you should read this: http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html
10:46:25 <kmc> hmm that doesn't have read though
10:46:38 <kmc> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
10:47:24 <HaskellLove_> same thing check it out for yourself there is no such thing as read::Int
10:47:37 <cwraith> But there's read.
10:47:56 <HaskellLove_> I have them boomarked the hierarchy of haskell and hoogle and use them
10:47:57 <kmc> HaskellLove_, the function is named "read".  i thought you said you already knew the syntax
10:48:29 <kmc> and (read :: Int) is definitely invalid.  (read :: String -> Int) and (read "123" :: Int) are both valid
10:48:37 <kmc> > read :: String -> Int
10:48:38 <lambdabot>   * Exception: Prelude.read: no parse
10:48:47 <HaskellLove_> cwraith my point was there is nothing in docs talking about the function read with  use like this : read "3434" :: Int
10:49:03 <kmc> it describes the function "read"
10:49:14 <kmc> which works for any result type which is a member of the Read typeclas
10:49:16 <mauke> HaskellLove_: there's nothing in the docs talking about (+) saying that 40 + 2 is 42
10:49:19 <kmc> the signature is just to tell it what type
10:49:25 <kmc> > ['0'..'9'] >>= read :: [Int]
10:49:26 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:49:26 <lambdabot>         against inferred type...
10:49:52 <Philonous> > reads :: String -> [(Int,String)]
10:49:53 <lambdabot>   ""->
10:49:53 <lambdabot>    []
10:49:53 <lambdabot>  "a"->
10:49:53 <lambdabot>    []
10:49:53 <lambdabot>  "aa"->
10:49:55 <lambdabot> [6 @more lines]
10:50:04 <HaskellLove_> mauke I see what u mean, so in future I should get intuition about these things i guess
10:50:24 <ivanm> wow, that "definition" looks boring...
10:50:46 <aavogt> > (40+)
10:50:47 <lambdabot>   {-3->37;-2->38;-1->39;0->40;1->41;2->42;3->43}
10:52:11 <HaskellLove_> aavogt whaat? :D I do : > (40+) but i dont get this result what is goin on? is the > operator from someother module?
10:52:42 <aavogt> > "makes lambdabot evaluate some expression HaskellLove_"
10:52:43 <lambdabot>   "makes lambdabot evaluate some expression HaskellLove_"
10:53:17 <Philonous> lambdabot: provides a Show instance for functions using small check
10:53:27 <aavogt> in the case of passing lambdabot functions... what Philonous said
10:54:33 <kmc> you'd probably get "No instance for (Show (a -> a))"
10:54:47 <Draconx> > id
10:54:48 <lambdabot>   {()->()}
10:55:15 <kmc> > not
10:55:15 <Philonous> > iterate show $ show id
10:55:16 <lambdabot>   {True->False;False->True}
10:55:16 <lambdabot>   ["{()->()}","\"{()->()}\"","\"\\\"{()->()}\\\"\"","\"\\\"\\\\\\\"{()->()}\\...
10:55:41 <Draconx> > (&&)
10:55:42 <lambdabot>   {True->{True->True;False->False};False->{True->False;False->False}}
10:55:53 <kmc> currying :D
10:55:59 <Draconx> > uncurry (&&)
10:56:00 <lambdabot>   {(True,True)->True;(True,False)->False;(False,True)->False;(False,False)->F...
10:56:03 <Draconx> that's better.
10:56:38 <Philonous> > zipWith5
10:56:42 <lambdabot>   {()->{()->{()->{()->{()->()}}}}}->
10:56:44 <lambdabot>    []->
10:56:46 <lambdabot>      []->
10:56:48 <lambdabot>        []->
10:56:50 <lambdabot>          [...
10:56:55 <kmc> ahaha
10:57:06 <kmc> > ($ ())
10:57:07 <lambdabot>   {{()->()}->()}
10:57:16 <kmc> > ($ 3)
10:57:17 <lambdabot>   {{-3->();-2->();-1->();0->();1->();2->();3->()}->()}
10:57:42 <HaskellLove_> map read (map (take 5) (tails number)) :: Int        What is wrong with this?
10:57:43 <tensorpudding> these examples are not helpful at all
10:58:00 <kmc> HaskellLove_, the result of a map is always a list
10:58:07 <kmc> Int is not the type of a list
10:58:10 <Philonous> > (.)
10:58:14 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
10:58:16 <lambdabot>                    GHC.Show...
10:58:21 <HaskellLove_> I ment to use :: Int for read
10:58:32 <kmc> map (read :: String -> Int) ...
11:01:05 <jmegner> I have a question
11:01:11 <jmegner> let's say I have...
11:01:29 <jmegner> bigFunc fileNames = do
11:01:30 <ivanm> oh noes! not a question!
11:01:31 <ivanm> :p
11:01:50 <jmegner>     bigString <- foldl addFileContentsToString "" fileNames
11:01:56 <jmegner>     putStr bigString
11:02:02 <mauke> no
11:02:08 <ttmrichter> A question?  About Haskell?  That's unpossible!
11:02:13 <Philonous> @paste
11:02:14 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:02:26 <jmegner> oh, I should use the haskell pastebin?
11:02:38 <ivanm> jmegner: well, _a_ pastebin
11:02:48 <HaskellLove_> What is wrong with my euler 8 solution, gives me type errors, u guys can see on first look what is wrong there, i am banging my head here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13959#a13959
11:03:05 <mauke> bigString <- liftM concat (mapM readFile fileNames)
11:04:09 <phr> read :: String->Int     can't be right
11:04:37 <aavogt> on it's own that's ok
11:04:50 <phr> oh ok
11:05:02 <HaskellLove_> hmm...
11:05:02 <jmegner> here is my code snippet: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5298#a5298
11:05:38 <jmegner> obviously it won't work because the addFileContentsToString takes a String and produces a IO String
11:06:03 <jmegner> what's a good way to un-IO the String?
11:06:13 <copumpkin> that must be the most common question ever
11:06:40 <Philonous> jmegner: You can't. You lift your function into IO world.
11:07:15 <Philonous> jmegner: Well, inside IO you sort of can. use foo <- bar to do that in do-notation
11:07:29 <jmegner> Philonous, right
11:07:46 <jmegner> so, I guess I could use recursion and get rid of the foldl
11:07:58 <tensorpudding> foldl is using recursion
11:08:22 <Philonous> jmegner: Or you could use some premade combinators that will do that for you. Either is fine.
11:08:28 <jmegner> tensorpudding, yeah, but I'm not sure how I would do a '<-' in the foldl correctly
11:08:37 <mauke> :t foldM
11:08:38 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:08:48 <jmegner> Philonous, I have no idea where to find these premade...oh, foldM?
11:09:20 <jmegner> warning: I do not know the difference between IO and Monad yet
11:09:20 <Philonous> jmegner: liftM, liftM2, mapM, foldM and friends.
11:09:22 <tensorpudding> foldM uses functions that return monadically-wrapped values though
11:09:36 <tensorpudding> jmegner: IO is one specific instance of a Monad
11:09:52 <tensorpudding> it has some quirks that make it different than others though
11:09:58 <Philonous> jmegner: IO is a monad. If you want you can substitute "Monad m" with "IO" in your head
11:10:18 <jmegner> Philonous, tensorpudding, thank you
11:10:21 <Philonous> i.e. "Monad m => foo m" becomes "foo IO"
11:10:41 * Axman6 would have used "m foo"
11:11:23 <jmegner> wow, all I had to change was one letter
11:11:24 <jmegner> yay
11:11:53 <jmegner> thank you, always-helpful-haskell-channel
11:12:09 <HaskellLove_> Someone can help this poor guy so he can solve euler 8 and go to sleep a happy man? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13959#a13959
11:12:37 <Philonous> jmegner: As a koan, try to understand what mauke wrote earlier: "bigString <- liftM concat (mapM readFile fileNames)"
11:13:08 <jmegner> what does "koan" mean?
11:13:29 <jmegner> Philonous, oh, wow, I didn't even see that mauke wrote that
11:13:30 <Philonous> It's some sort of puzzle. Something to meditate over
11:13:36 <shachaf> Philonous: Isn't a kōan supposed to be unanswerable?
11:14:17 <Philonous> shachaf: Yes and no afaik. Many aren't but some are. And I meant it metaphorical.
11:14:29 <jmegner> mauke, ah, I see, you answered so early! your mind-guessing is good
11:16:50 <HaskellLove_> heeeeeeeeeeelp somebody anybody heeelp
11:16:52 <HaskellLove_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13959#a13959
11:17:58 <RadioApeShot> Can someone point me to a link about accessing tuples elements of more than two element tuples
11:17:59 <RadioApeShot> ?
11:18:06 <copumpkin> pattern match
11:18:16 <copumpkin> @hackage tuples
11:18:16 <lambdabot> http://hackage.haskell.org/package/tuples
11:18:20 <aavogt> AdioRapeShot?
11:18:27 <copumpkin> @hackage tuple
11:18:27 <lambdabot> http://hackage.haskell.org/package/tuple
11:19:16 <aavogt> I wonder why that tuple sequencing doesn't have instances for applicative
11:19:47 <kmc> > let (a, _, _) = (1,2,3) in a
11:19:48 <lambdabot>   1
11:19:51 <RadioApeShot> http://www.last.fm/music/Brainiac/_/Radio+Apeshot
11:19:57 <kmc> > case (1,2,3) of (a, _, _) -> a
11:19:58 <lambdabot>   1
11:20:12 <Philonous> HaskellLove_: Project Euler asks for products, but you compute sums.
11:21:03 <HaskellLove_> oh ok nevermind, but still the point is i get type errors
11:21:50 <HaskellLove_> oh shit my hole function is wrong ... Philonous got it... oh shit am i blind or ... oh chesus...
11:22:04 <copumpkin> please stop swearing
11:22:14 <kmc> are you 14 years old
11:22:23 <HaskellLove_> kmc just stupid
11:22:59 <HaskellLove_> kmc, I mean me stupid, not u
11:23:04 <kmc> u
11:23:33 <kmc> @wn u
11:23:34 <lambdabot> *** "u" wn "WordNet (r) 2.0"
11:23:36 <lambdabot> u
11:23:38 <lambdabot>      adj : (chiefly British) of or appropriate to the upper classes
11:23:40 <lambdabot>            especially in language use
11:23:42 <lambdabot>      n 1: a nitrogen-containing base found in RNA (but not in DNA) and
11:23:44 <lambdabot> [5 @more lines]
11:23:47 <kmc> @more
11:23:47 <lambdabot>           derived from pyrimidine; pairs with adenine [syn: {uracil}]
11:23:48 <lambdabot>      2: a heavy toxic silvery-white radioactive metallic element;
11:23:50 <lambdabot>         occurs in many isotopes; used for nuclear fuels and
11:23:52 <lambdabot>         nuclear weapons [syn: {uranium}, {atomic number 92}]
11:23:54 <lambdabot>      3: the 21st letter of the Roman alphabet
11:25:04 <PepeSilvia> hi, can someone explain why this happens:
11:25:06 <PepeSilvia> let a n = round (((1 + sqrt 5) ** n - (1 - sqrt 5) ** n) / (2 ** n * sqrt 5)) in a 32
11:25:09 <PepeSilvia> > let a n = round (((1 + sqrt 5) ** n - (1 - sqrt 5) ** n) / (2 ** n * sqrt 5)) in a 32
11:25:10 <lambdabot>   2178309
11:25:19 <PepeSilvia> > let a n = round (((1 + sqrt 5) ** f - (1 - sqrt 5) ** f) / (2 ** f * sqrt 5)) where f = fromInteger n :: Float in a 32
11:25:23 <lambdabot>   2178310
11:25:30 <PepeSilvia> why are they not the same?
11:26:24 <PepeSilvia> err, a is supposed to be fibonacci, btw
11:26:43 <aavogt> one is calcuated as a float, the other as a double
11:26:50 <aavogt> > let a n = round (((1 + sqrt 5) ** f - (1 - sqrt 5) ** f) / (2 ** f * sqrt 5)) where f = fromInteger n :: CReal in a 32
11:26:51 <lambdabot>   * Exception: log of negative number
11:27:38 <PepeSilvia> > let a n = round (((1 + sqrt 5) ** f - (1 - sqrt 5) ** f) / (2 ** f * sqrt 5)) where f = fromInteger n :: Double in a 32
11:27:39 <lambdabot>   2178309
11:27:54 <PepeSilvia> ugh, ok! thanks!
11:28:32 <HaskellLove_> copumkin save me man http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13960#a13960
11:28:46 <aavogt> > fix (\x -> 1:1: zipWith (+) x (tail x)) !! 32
11:28:47 <lambdabot>   3524578
11:28:51 <aavogt> > fix (\x -> 1:1: zipWith (+) x (tail x)) !! 31
11:28:52 <lambdabot>   2178309
11:29:20 <PepeSilvia> @t fix
11:29:20 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:29:23 <aavogt> PepeSilvia: the one using Double is correct
11:29:45 <HaskellLove_>  file name does not match module name `Main' Failed, modules loaded: none. what this means?
11:29:59 <PepeSilvia> aavogt, that solution is nice too, but what does fix do?
11:30:06 <Philonous> @src fix
11:30:06 <lambdabot> fix f = let x = f x in x
11:30:07 <mauke> @src fix
11:30:07 <lambdabot> fix f = let x = f x in x
11:30:20 <mauke> time travel
11:30:36 <PepeSilvia> is it Y?
11:30:37 <tensorpudding> fix is a fixed-point thing
11:30:54 <tensorpudding> not Y
11:31:00 <mauke> PepeSilvia: yes
11:31:29 <PepeSilvia> that's sweet, so it applies the first part of the list [1,1..] to zipWith
11:31:32 <kmc> HaskellLove_, what would you guess that it means?
11:31:46 <aavogt> @free fix
11:31:47 <lambdabot> f . g = h . f => f (fix g) = fix h
11:32:03 <HaskellLove_> kmc i have no idea no more tried some stuff but...
11:32:06 <aavogt> gotta love those
11:32:43 <kmc> haskell has recursive let so you don't need tricks like Y to write a fixed point combinator
11:33:21 <shachaf> kmc: It's not as if you "need" a trick like Y in Scheme or most other languages either.
11:34:51 <PepeSilvia> the laziness in that function is insane though; I still need to learn to think more lazily ;)
11:35:08 <HaskellLove_> kmc u have any idea?
11:35:27 <HaskellLove_> kmc http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13960#a13960
11:36:12 <kmc> shachaf, but you need it in the untyped lambda calculus
11:36:18 <kmc> and you can't even write it in the simply typed lambda calculus
11:36:38 <Philonous> > nubBy (flip divides) [2..]
11:36:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
11:37:08 <shachaf> kmc: True. I thought you were comparing Haskell to programming lnaguages for some reason. :-)
11:37:17 <kmc> those are programming languages ;)
11:37:39 <kmc> and i'd wager Y was invented before most programming languages
11:37:42 <kmc> if not all
11:38:04 <copumpkin> was it invented or discovered??
11:38:52 <Axman6> copumpkin: yes
11:39:01 <copumpkin> oh that's what I thought
11:40:25 <HaskellLove_> lambdabot: :t divides
11:40:35 <ivanm> you're talking about the Y combinator?
11:40:44 <kmc> :t divides
11:40:45 <lambdabot> forall a. (Integral a) => a -> a -> Bool
11:40:53 * ivanm is of the opinion that things in CS, etc. are developed, rather than invented or discovered
11:41:32 <HaskellLove_> @hoogle divides
11:41:32 <lambdabot> No results found
11:41:58 <iross> > take 20 $ nubBy (\ x y -> x `mod` y == 0) [2..]
11:41:59 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
11:42:00 <HaskellLove_> where does this function come from? aint in the docs hoogle
11:42:10 <copumpkin> I wrote it yesterday
11:42:11 <kmc> @src divides
11:42:11 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:42:34 <tensorpudding> > repeat "developers"
11:42:35 <lambdabot>   ["developers","developers","developers","developers","developers","develope...
11:42:56 <ivanm> > cycle "developers "
11:42:57 <lambdabot>   "developers developers developers developers developers developers develope...
11:43:14 <tensorpudding> hmm, that works
11:43:16 <Philonous> Balmer peak would be an explanation for quite a few things.
11:43:17 <tensorpudding> @src cycle
11:43:17 <lambdabot> cycle [] = undefined
11:43:17 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:43:33 <HaskellLove_> will someone help me guys http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13960#a13960 :( pleaseee why this gives me error on load: file name does not match module name `Main' Failed, modules loaded: none.
11:43:51 <sohum> how do I get ghc to stop warning me that all the fields in a record aren't initialised?
11:44:08 <Draconx> initialize them :P
11:44:28 <sohum> but I don't want to :{
11:44:36 <ivanm> sohum: initialise them to undefined
11:44:38 <Philonous> initialise them with undefined
11:44:55 <tensorpudding> initialize them as undefined
11:44:56 <Philonous> Or use extensible records
11:45:11 <ivanm> sohum: rather than using a constructor, you can use a "default" value with all fields set to undefined, and just overwrite the ones you want
11:45:18 <ivanm> Philonous: oh? where can you get extensible records?
11:46:14 <sohum> hm. that'd work, because lazy evaluation
11:46:16 <sohum> awesome
11:46:26 <ivanm> HaskellLove_: you need a main function...
11:46:35 <ivanm> and put up the top "module Main where"
11:47:26 <HaskellLove_> ivanm so far i never needed one for my solutions that is why i was ... why does this one needs and other solutions did not i mean...
11:47:35 <sohum> now to figure out how haddock works...
11:47:37 <ivanm> HaskellLove_: how are you trying to use it?
11:47:39 <ivanm> sohum: heh
11:47:42 <kmc> > intersperse $ cycle "developers"
11:47:42 <Philonous> ivanm: I don't know if they are in a library, but Oleg Describes them in "Strongly Typed Heterogeneous Collections"
11:47:47 <lambdabot>  Terminated
11:47:49 <ivanm> ahhh
11:47:55 <HaskellLove_> i have a file on desktop and load it in ghci ivanm
11:48:03 <kmc> > fix (intersperse $ cycle "developers")
11:48:07 <lambdabot>   mueval-core: Time limit exceeded
11:48:14 <kmc> > fix (interleave $ cycle "developers")
11:48:15 <lambdabot>   "ddedveedlvoepeedrlsvdoeevpeeleodprelrssvddeoveeelvoppeeerlsedoedvperleolpr...
11:48:42 <ivanm> HaskellLove_: OK, so in that case that isn't needed
11:48:47 <ivanm> you're doing ghci Foo.hs ?
11:48:48 * Philonous feels that he hasn't earned the right to call Mr Kiselyov by his first name 
11:49:11 <HaskellLove_> ivanm no i call it from ghci with load
11:49:20 <ivanm> same diff
11:49:23 <ivanm> Philonous: heh
11:49:26 <ivanm> HaskellLove_: should work then
11:49:56 <sohum> > fix . interleave $ cycle "shall I compare thee to a Summer's day?"
11:49:58 <lambdabot>   "sshsahlsla hIl scloam phaIrle  stchleoea mt op haa ISrulmem e rs'tsc hdlae...
11:50:09 <Philonous> ivanm: For some reason he is always mentioned by his first name in this channel
11:50:26 <ivanm> Philonous: yeah
11:50:46 <kmc> :t fix . interleave . cycle
11:50:48 <lambdabot> forall a. [a] -> [a]
11:50:55 <kmc> > let f = fix . interleave . cycle in f "abcd"
11:50:57 <lambdabot>   "aabacbdaacbbcddaaabccbdbacbdcddaaabacbdcacbbcddbaabccbddacbdcddaaabacbdaac...
11:51:01 <kmc> what's the inverse of that function?
11:52:35 <Philonous> > let inverse =const "abcd"; f = fix . interleave . cycle in inverse . f  $ "abcd"
11:52:36 <lambdabot>   "abcd"
11:56:21 <dibblego> http://www.mail-archive.com/haskell-cafe@haskell.org/msg37938.html did anything ever come of this?
11:56:23 <kmc> like magic
11:57:51 <sohum> Philonous: I know you're kidding, but by definition inverse . f == id. it can only depend on f, not it's argument
11:57:52 <manju_> I have a function that returns a bool based on a number input
11:59:14 <kmc> > System.Info.os
11:59:15 <lambdabot>   Not in scope: `System.Info.os'
11:59:31 <manju_> ok I have no idea what to do
12:00:07 <kmc> manju_, ?
12:00:13 <kmc> you described having a function but not what you want to do with it
12:00:13 <manju_> I want to iterate over an infinite list
12:00:23 <HaskellLove_> how to make a product of all digits in a string like this: "34343434" and you want something like 3*4*3 and so on
12:00:42 <manju_> and quit when the function returns true, and return the number where the function returned true
12:00:44 <kmc> HaskellLove_, try to figure it out with things you already know
12:00:53 <kmc> i've seen you use every individual piece that you need
12:01:16 <HaskellLove_> hmm ok let me try again even though i did like a lot :( ok ok here i go
12:01:32 <kmc> > head $ dropWhile (< 10) [1,3,..]
12:01:33 <Philonous> product . fmap digitToInt "12345]
12:01:33 <lambdabot>   <no location info>: parse error on input `..'
12:01:39 <Philonous> oops
12:01:39 <kmc> > head $ dropWhile (< 10) [1,3..]
12:01:40 <lambdabot>   11
12:01:44 <kmc> manju_, like that?
12:01:57 <manju_> I think so
12:02:01 <manju_> yes
12:02:03 <manju_> that is it
12:02:15 <manju_> thanks :-)
12:04:37 <Philonous> kmc: There is no inverse btw
12:04:49 <copumpkin> just like there is no spoon
12:04:55 <drhodes> anyone know if there's a translator from a bison grammar, to the .cf grammar used by bnfc?
12:05:18 <kmc> Philonous, no?
12:06:53 <Philonous> > let f = fix . interleave . cycle in zipWith (==) (f "abcd") (f "abcdabcd")
12:06:54 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
12:07:44 <mxyz> anyone here familiar with Data.Binary.IEEE754?
12:08:17 <manju_> kmc can you tell me why head $ dropWhile run on the infinte list returns, shouldn't it keep going for ever ?
12:08:47 <kmc> dropWhile produces its first element once the predicate returns False
12:08:58 <PepeSilvia> where do I find interleave?
12:08:59 <kmc> when head sees the first element it returns that element and does not inspect the rest of its input
12:09:08 <cwraith> @hoogle interleave
12:09:09 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
12:09:09 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
12:09:09 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
12:09:13 <copumpkin> PepeSilvia: in LogicT
12:09:14 <Philonous> PepeSilvia: http://hackage.haskell.org/packages/archive/logict/0.3/doc/html/Control-Monad-Logic-Class.html
12:09:23 <PepeSilvia> thanks!
12:09:40 <manju_> these inifinite lists are confusing me
12:09:49 <Philonous> PepeSilvia: On lists it is basically interleace (x:xs) (y:ys) = x:y:(interleave xs ys)
12:11:00 <copumpkin> > fix $ interleave [0..]
12:11:01 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
12:12:06 <Gracenotes> :o
12:12:35 <kmc> manju_, you can think of them as streams, like a UNIX pipeline
12:12:39 <kmc> anyway i have to go, bbl
12:12:44 <PepeSilvia> copumpkin: I need to write that out :|
12:12:50 <manju_> kmc, thanks :-)
12:12:51 <Gracenotes> let x = interleave [0..] x in x
12:12:52 <copumpkin> PepeSilvia: ?
12:13:00 <PepeSilvia> to follow what it does I mean
12:13:04 <copumpkin> oh
12:13:10 <copumpkin> Gracenotes just did
12:13:12 <Gracenotes> > interleave [1..5]
12:13:13 <lambdabot>   []->
12:13:13 <lambdabot>    [1,2,3,4,5]
12:13:13 <lambdabot>  [-2]->
12:13:13 <lambdabot>    [1,-2,2,3,4,5]
12:13:13 <lambdabot>  [-2,-1]->
12:13:15 <lambdabot>    [1,-2,2,-1,3,4,...
12:13:27 <Gracenotes> > interleave [1..5] [6..10]
12:13:29 <lambdabot>   [1,6,2,7,3,8,4,9,5,10]
12:13:35 <Gracenotes> amm. right
12:14:35 <Gracenotes> copumpkin: oh, really? heh, I did
12:15:08 <copumpkin> > let x = interleave [0..] x in x
12:15:08 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
12:15:59 <PepeSilvia> ok, I get it now. Thanks guys
12:16:02 <Gracenotes> that is one interesting function, though. lemme think.. the "x" part gets more and more behind the [0..] part of the list, because it not only includes the numbers, but everything in between itself
12:16:23 <copumpkin> here's something that might make it clearer
12:16:41 <copumpkin> > map head . itereate (drop 2) $ fix (interleave [0..])
12:16:41 <lambdabot>   Not in scope: `itereate'
12:16:47 <copumpkin> > map head . iterate (drop 2) $ fix (interleave [0..])
12:16:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:16:57 <copumpkin> > map (head . tail) . iterate (drop 2) $ fix (interleave [0..])
12:16:59 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
12:17:44 <copumpkin> (which is fix (interleave [0..])) again
12:19:27 <copumpkin> which is almost the definition, but might make it clearer :)
12:20:50 <Gracenotes> fix (\x -> let list = zip [0..] x in concatMap (\(a, b) -> [a, b]) list)
12:20:54 <Gracenotes> noooooooooooooooooooooooooooooooooooo
12:20:57 <Gracenotes> > fix (\x -> let list = zip [0..] x in concatMap (\(a, b) -> [a, b]) list)
12:21:01 <lambdabot>   mueval-core: Time limit exceeded
12:21:26 <Gracenotes> hm. that went well.
12:22:41 <Philonous> > let diagonal = foldr1 interleave in diagonal $ repeat [1..]
12:22:42 <lambdabot>   [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,...
12:23:29 <Philonous> > let diagonal = foldr1 interleave in diagonal $ liftM2 [1..] [1..]
12:23:30 <lambdabot>   Couldn't match expected type `a1 -> a2 -> r'
12:23:30 <lambdabot>         against inferred type ...
12:23:39 <Philonous> > let diagonal = foldr1 interleave in diagonal $ liftM2 (,) [1..] [1..]
12:23:40 <lambdabot>   No instance for (Control.Monad.Logic.Class.MonadLogic ((,) a1))
12:23:40 <lambdabot>    arising ...
12:25:05 <Philonous> > let diagonal = foldr1 interleave in diagonal $ [[(i,j) | i<- [1..] ] | j<-[1..]]
12:25:06 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(3,1),(2,2),(4,1),(1,4),(5,1),(3,2),(6,1),(2,3),(7...
12:25:26 <mxyz> how do i use putStrLn with "Data.ByteString.Lazy.Internal.ByteString"?
12:26:03 <manju_> the command line editing in ghci, does not detect keys like end, home etc., is there a fix ?
12:26:32 <Philonous> mxyz: import qualified ... as BS, BS.putStrLn
12:26:49 <mxyz> thanks ill give it a try
12:28:57 <HaskellLove_> I just solved Euler 8 and updated my blog. http://haskelllove.wordpress.com/ Thank you all. Good Night :)
12:32:42 <mxyz> philonous: im getting a weird error: main.o:fake:(.text+0x3f): undefined reference to `datazmbinaryzmieee754zm0zi4_DataziBinaryziIEEE754_putFloat64be_closure' .... times 6
12:35:03 <mxyz> if im using "import Data.Binary.IEEE754"
12:35:21 <mxyz> do i need to compile with "ghc -package Data.Binary.IEEE754 main.hs" or something?
12:35:37 <copumpkin> --make
12:35:55 <mxyz> "ghc --make main.hs" ?
12:36:01 <copumpkin> yep
12:36:12 <mxyz> nice! it worked. thanks
12:36:17 <manju_> for the 12 th problem in eulerproject, my cpu is really hot and ghci has been running for 11min now :-(
12:36:27 <manju_> the prog works for smaller values
12:36:49 <copumpkin> manju_: most project euler problems are designed to have a simple naive solution that will take a million years to complete
12:36:55 <copumpkin> and a sneaky smart solution that will take under a minute
12:37:21 <manju_> copumpkin, I think this is one like that
12:38:12 <copumpkin> > scanl1 (+) [1..]
12:38:13 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
12:38:23 <mxyz> this creates a bytestring: main = do BS.putStrLn $ runPut $ putFloat64be 2.0005
12:38:33 <mxyz> so thats a byte array basically with the bits packed in it right?
12:38:37 <manju_> I have a strange problem with redhat/fedora, when I put my latop to sleep or hibernate, after it wakes up the left part of my laptop gets incredibly hot and the battery status says the battery does not exist, one thing the haskell prog did was tell me that the CPU is the left part of my laptop and that was what was getting hot
12:38:54 <manju_> some sort of a kernel bug I think, because the CPU usage is zero according to top
12:39:00 <copumpkin> > scanl1 (+) [1..] !! 10000
12:39:00 <lambdabot>   50015001
12:39:06 <stroan> manju_: prime factors
12:39:18 <copumpkin> not prime factors
12:39:22 <copumpkin> divisors
12:39:34 <copumpkin> > scanl1 (+) [1..] !! 12000
12:39:35 <lambdabot>   72018001
12:39:47 <copumpkin> > scanl1 (+) [1..] !! 12300
12:39:48 <lambdabot>   75663451
12:39:50 <manju_> :-(
12:40:05 <manju_> how can you guys write such short code, which does so much
12:40:21 <manju_> you should see my code for that it has 3 functions :-)
12:40:49 <manju_> anyway back to drawing board I think
12:40:56 <Draconx> manju_, practice.
12:41:03 <manju_> Draconx, yes
12:41:14 <manju_> but the fun part it is fun to practice in haskell
12:41:31 <dmead> hey channel
12:41:33 <manju_> if I had to do this C++, I wouldn't have enjoyed it as much I think
12:41:46 <dmead> does anyone know where i can find phillip wadler's tech talk about haskell type classes and java generics?
12:41:52 <dmead> it seems to have dissapeared from the internets
12:41:52 <copumpkin> manju_: generating the triangle numbers is super simple
12:41:59 <Percy> Beginners to any language tend to overcomplicate the simplest of matters.
12:42:02 <copumpkin> manju_: now just come up with a good way of finding all the divisors :)
12:42:25 <manju_> copumpkin, :-)
12:43:13 <Percy> The concept of KISS needs to be employed in all things ;)
12:43:53 <dmead> =)
12:45:07 <Draconx> I found learning Haskell to involve lots of "crap, I just spent the last half hour implementing something in the standard library"
12:45:27 <ddarius> > let f n = n*(n-1) `div` 2 in f 12000
12:45:28 <lambdabot>   71994000
12:45:29 <manju_> Draconx, exactly
12:45:40 <ddarius> > let f n = n*(n-1) `div` 2 in f 12001
12:45:41 <lambdabot>   72006000
12:46:38 <ddarius> > let f n = n*(n-1) `div` 2 in f 12002
12:46:39 <lambdabot>   72018001
12:52:25 <cwraith> is (.) strict?
12:53:03 <Lemmih> ?src (.)
12:53:04 <lambdabot> (f . g) x = f (g x)
12:53:24 <copumpkin> c_wraith: strict in the functions?
12:53:49 <c_wraith> right, always look at the source.  It's strict in f, not in g
12:53:57 <tensorpudding> > ((const 5) . (const undefined)) 3
12:53:58 <lambdabot>   5
12:54:08 <SamB_XP_> > (undefined . undefined) `seq` 5
12:54:09 <lambdabot>   Ambiguous type variable `f' in the constraint:
12:54:09 <lambdabot>    `GHC.Base.Functor f'
12:54:09 <lambdabot>     ...
12:54:18 <copumpkin> ugh!
12:54:22 <SamB_XP_> > (undefined . undefined :: () -> ()) `seq` 5
12:54:23 <lambdabot>   5
12:54:26 <Draconx> caleskell!
12:54:49 * SamB_XP_ wants calefaulting
12:55:15 <tensorpudding> caleculus
12:56:12 <Draconx> yeah, caleskell functors should calefault to ((->) a)
13:05:28 <ddarius> What the hell is Erik talking about in his Ch 8?
13:07:21 <toast-opt> Erik Meijer?  in his chan 9 haskell lectures?
13:07:48 <SamB_XP_> why's that called Channel 9, anyway ?
13:08:21 <toast-opt> ... thought ch9 was a reference to the local PBS station.  tv ch9 often contains local educational programming
13:08:39 <aavogt> they are named after bulletin boards
13:09:12 <SamB_XP_> huh? channel 9?
13:09:27 <SamB_XP_> last I checked PBS was on channels 12 and 23
13:09:40 <toast-opt> wikipedia says it relates to "United Airlines' on-board entertainment system's channel nine, branded "From the Flight Deck," on which passengers can listen to the radio conversations between the flight crew and air traffic control."
13:09:54 <tensorpudding> i thought it was different in different places
13:10:05 <SamB_XP_> tensorpudding: well, probably
13:10:08 <SamB_XP_> that's here ;-P
13:10:26 <mullein> SamB_XP_: you must be in philadelphia area
13:10:34 <SamB_XP_> very likely we don't get 23 anymore
13:11:02 <SamB_XP_> I haven't really looked too closely since we got the box a few weeks back
13:16:37 <toast-opt> ddarius, you mentioned something strange in Erik's talk?
13:22:47 <copumpkin> omg a kroo
13:23:27 <kroo> wassup pumpkin
13:23:45 <kroo> see my former company was bought by a Google?
13:23:49 <copumpkin> just doing some work
13:23:53 <copumpkin> your former company?
13:24:20 <kroo> yeah, etherpad was acquired by google recently
13:24:37 <copumpkin> oh cool
13:25:06 <kroo> I ended up leaving b4 -- wouldn't want to end up stuck in australia for a year :)
13:25:20 <copumpkin> shh, lots of australians in here, they might murder you
13:25:23 <kroo> :)
13:25:48 <SamB_XP_> hmm, dons seems happy enough to be stuck in the US for that order of time ...
13:25:53 <ivanm> @slap kroo
13:25:53 * lambdabot activates her slap-o-matic...
13:26:01 <kroo> neway, the eventual consistency algorithms powering google wave / etherpad are very cool :)
13:27:23 <kroo> lets you do so many things in real-time that you otherwise could not -- I think its going to be a huge deal for real-time webapps
13:28:36 <copumpkin> sounds neat :)
13:30:18 <kroo> mhmmm :)  http://portal.acm.org/citation.cfm?id=240305 <-- a good read, if ya want to learn more
13:33:05 <kroo> I've been working on putting together an open source version of the algorithm described in that there paper -- I did it in javascript, and tried and failed to do it in haskell... gotta bone-up on my haskell a bit more i guess :P
13:33:18 <copumpkin> need more boning
13:33:56 <kroo> http://github.com/kroo/infinote-JS <-- the js code at least works... the haskell code is a big mess :P
13:34:40 <copumpkin> no free version of that paper available it seems, and I'm not on campus now and am too lazy to vpn in :P I'll grab it tomorrow
13:34:48 <kroo> :(
13:35:10 <kroo> acm sucks :P
13:35:23 <SamB_XP_> not as much as the IEEE
13:36:30 <kroo> copumpkin:  http://idk.im/p288-ressel.pdf
13:36:36 <kroo> but ya didn't get it from me :)
13:36:46 <kroo> ;)
13:36:52 <copumpkin> failurl
13:36:56 <kroo> :(
13:37:02 <SamB_XP_> kroo: why not from you ?
13:37:03 <kroo> my dyndns ftl
13:37:10 <SamB_XP_> are you a non-author ?
13:37:17 <kroo> SamB_XP_: im a non-author
13:37:35 <SamB_XP_> kroo: so, who should we say we did get it from ?
13:37:44 <ivanm> SamB_XP_: the internetz
13:37:52 <kroo> one of the authors? :P
13:38:43 <copumpkin> kroo: it seems like this stuff is begging for some algebra
13:39:55 <kroo> copumpkin: its very much an algebra sort of problem
13:40:10 <kroo> next.seekrit.org/p288-ressel.pdf
13:40:11 <kroo> try that one
13:40:19 <copumpkin> group = undoable stuff, commutative group = undoable stuff in any order
13:40:25 <kroo> exactly :)
13:41:26 <kroo> the only tricky bit is making sure you can transform an operation from a previous state into the current one... with many dimensions (users) that problem gets a little tricky to get right :)
13:41:37 <copumpkin> yeah, I'd imagine
13:41:45 <roconnor> @go haskell polymorphic recursion
13:41:46 <lambdabot> Maybe you meant: google googleit do
13:41:52 <roconnor> @google haskell polymorphic recursion
13:41:53 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
13:41:53 <lambdabot> Title: 7.8.�Other type system extensions
13:43:01 <kroo> but still, most of the concepts you can put together in 2 or 3d carry over to higher dimensions... you just have to come up with a few proofs about consistancy regardless of the dimensionality
13:43:01 <BMeph> As "bad" as the IEEE/ACM are for paper access, they're Chatty Cathy orgs, compared to the SIAM... :\
13:43:31 <SamB_XP_> BMeph: the who now ?
13:43:43 <copumpkin> beware of Thailand
13:43:45 <SamB_XP_> they haven't annoid me by being cited NEARLY as often ...
13:43:51 <kroo> :)
13:45:53 <SamB_XP_> strange comic ... Gabriel plays poker with Azrael...
13:46:12 <kroo> copumpkin -- apparently this class of algorithm is used a lot in clock synchronization of embedded systems... tho tbh I haven't had enough conversations with my embedded systems prof to really understand how or why :P
13:50:01 <copumpkin> :)
13:52:12 <copumpkin> solidsnack: you a category theory master now?
13:52:33 <solidsnack> copumpkin: Hmmm?
13:52:47 <copumpkin> solidsnack: I thought you were auditing the CT course at stanford
13:53:33 <solidsnack> Well, it was just a one credit course.
13:53:48 <solidsnack> I am now a much more humble categorist.
13:53:54 * ddarius doesn't think auditing a single CT course would make one a master unless it was an -excellent- course.
13:54:05 <copumpkin> :)
13:55:15 <solidsnack> So actually, I make lots of mistakes and don't know very much actual math -- like rings and groups and such.
13:55:41 <copumpkin> ah
13:55:44 <BMeph> SamB_XP_:   Try looking for a Dana Scott paper...you'll run into the SIAM soon enough.
13:56:08 <copumpkin> not having many examples of categories to tie concepts back to makes it more painful than it could be
13:57:13 <solidsnack> Well, I actually have managed to learn a bit about rings, ideals and modules in the past week.
13:57:24 <b6> some adventurous person with mac os x, please see if http://github.com/bsl/GLFW-b builds for you?
13:58:00 <BMeph> I like ideals. They're squirrelly, but interesting. ;)
13:58:51 <copumpkin> b6: nope
13:58:53 <ddarius> solidsnack: Category theory marblizes well with learning other mathematics topics.
13:59:17 <copumpkin> b6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13962#a13962
13:59:22 <ddarius> solidsnack: For example, the categorical characterization of normal subgroups or ideals is, in my opinion, a lot clearer and better motivated than the typical approaches.
13:59:51 <b6> copumpkin: thanks for trying.
14:00:15 <copumpkin> b6: I'm still on leopard, for what it's worth
14:00:27 <b6> copumpkin: i don't have enough money to know what that means.
14:00:35 <b6> ;)
14:00:37 <copumpkin> lol
14:00:52 <kroo> copumpkin -- roughly the same thing on snowleopard
14:01:14 <copumpkin> QtPlaty[HireMe]: did you see the job postings on haskell-cafe?
14:01:18 <b6> copumpkin: please pull and try again? <3.
14:01:33 <kroo> http://pastie.textmate.org/private/o385jmllba4pjvgwlgg
14:01:45 <QtPlaty[HireMe]> No I haven't my I have a URL?
14:01:54 <b6> alright. these are some nice errors.
14:01:57 <kroo> (b4 your update b6, but on snow leopard, the latest mac os x installment)
14:02:08 <copumpkin> b6: that worked
14:02:12 <b6> really!?
14:02:20 <b6> great.
14:02:20 <copumpkin> gave me lots of deprecation warnings
14:02:29 <copumpkin> but it succeeded in the end
14:02:30 <copumpkin> :)
14:02:45 <copumpkin> b6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13963#a13963
14:02:51 <kroo> b6: http://pastie.textmate.org/private/igop1wsjkerd9ejgecpmq
14:03:02 <b6> copumpkin, kroo: awesome, thanks.
14:03:06 <kroo> (with changes, on 10.6 :))
14:03:07 <copumpkin> QtPlaty[HireMe]: http://www.haskell.org/pipermail/haskell-cafe/2009-December/070469.html
14:03:15 <b6> maybe see if http://github.com/bsl/GLFW-b-demo works. warning: mind-blowing graphics.
14:03:24 <b6> (it's a cube. you can turn it with cursor keys.)
14:03:33 * b6 does something with eyebrows
14:04:08 <copumpkin> it'll be a while, haven't compiled the opengl package
14:04:11 <copumpkin> 184 modules :o
14:04:17 <b6> ok, sorry.
14:04:25 <copumpkin> no problem, I'm just leaving it to compile
14:04:25 <QtPlaty[HireMe]> Thankyou
14:04:31 <copumpkin> I also have profiling turned on, so it'll do it twice :P
14:04:42 <b6> copumpkin: thanks, i appreciate it.
14:04:43 <ddarius> Modulo the profiling, it should compile pretty quickly.
14:05:00 <copumpkin> ddarius: it should, but I'm on the world's shittiest laptop
14:05:05 <copumpkin> a macbook air!
14:05:06 <copumpkin> first gen
14:05:21 <copumpkin> the thing overheats if you breathe on it, and turns its clock rate down to about 2 hz
14:05:43 <tensorpudding> lol
14:06:00 <tensorpudding> i would hardly call a macbook air the shittiest laptop
14:06:15 <copumpkin> I've never felt such laptop rage, and I've had a lot of laptops
14:06:20 <copumpkin> this thing makes me want to stomp on it
14:06:24 <copumpkin> sometimes multiple times a day
14:06:40 <SmurfOR> copumpkin, but it fits in a manilla envelope!!!!!!11
14:06:51 <copumpkin> the only good thing about it is its portability
14:06:52 <kroo> lol -- its not supposed to use its own cpu ever :P
14:07:06 <kroo> your supposed to remotely control beefier machines with it :)
14:07:12 <copumpkin> it weighs nothing at all
14:07:18 <copumpkin> kroo: oh no, it overheats with remote desktop too :P
14:07:22 <copumpkin> best I can do is ssh
14:07:31 <kroo> yeh, who needs graphics :)
14:08:06 <copumpkin> it also overheats every time mobileme syncs, and if I watch a youtube video
14:08:18 <kroo> hahah, thats horrible
14:08:29 <SmurfOR> copumpkin, has it always overheated?
14:09:03 <b6> maybe they call it air because you need to keep a box fan blowing on it.
14:09:04 <SmurfOR> the fan could be dusty and less efficient.  I've seen that happen with a couple laptops where people smoke a lot around them.
14:10:22 <copumpkin> SmurfOR: when I first got it, I could run windows in vmware just fine, then it got progressively worse and now the best I can do is text editing. I took it to a store because its hinge is a piece of **** and they said they could reproduce the slowing down symptoms. So they basically changed the logic board, screen assembly, hard drive (the whole computer, basically) and then said "hmm, this still overheats, not sure what else to do
14:10:23 <copumpkin> gave it back to me
14:10:38 <copumpkin> of course, it's overheated right now
14:10:55 <copumpkin> which means the text I type appears on screen about half a second after I type it
14:11:06 <SmurfOR> that sucks :/
14:11:08 <dibblego> take it back and ask for your money back
14:11:32 <kroo> at that point, they should just give you a new one... preferably a second generation one :P
14:11:49 <SmurfOR> yeah sounds like a lemon
14:13:27 <copumpkin> yeah :/
14:14:22 <copumpkin> I'm going to get it checked up more seriously soon, but I lent my other laptop to my roommate since his died, and I can't be laptopless for the time it would take them to do diagnostics
14:14:45 <dibblego> tell them to supply an immediate replacement
14:16:10 <kroo> or just continue working on a kindle until they give your laptop back -- thats kinda the next logical step in your choice of laptops :)
14:16:22 <copumpkin> lol
14:16:23 <kroo> rather underpowered, but very thin and light :)
14:16:31 <SmurfOR> it's white
14:16:33 <copumpkin> the screen isn't exactly responsive :)
14:16:49 <copumpkin> I'd very much like an A4 reader for papers
14:16:56 <copumpkin> if I can type on it, all the better
14:16:56 <HaskellLove> Can someone translate this and replace all the parenthesis with "." ? I want to write like that from now on so pelase guide me just show me on this one and i will learn, i really tried. max5 = maximum (map product (map (map digitToInt) (map (take 5) (tails number))))
14:17:22 <sohum> copumpkin: remember, a4 screen = bigger than that device. would you really want to carry that around?
14:17:26 <copumpkin> @pl max5 number = maximum (map product (map (map digitToInt) (map (take 5) (tails number))))
14:17:26 <lambdabot> max5 = maximum . map product . map (map digitToInt) . map (take 5) . tails
14:17:34 <copumpkin> HaskellLove: there :)
14:17:42 <copumpkin> sohum: yes
14:18:01 <HaskellLove> copumkin I love u man, in a not gay way of course thank you :D
14:18:03 <sohum> copumpkin: *shrug*. fair enough.
14:18:12 <Zao> Can't you merge the mapped functions into one big one?
14:18:21 <copumpkin> Zao: yeah
14:18:27 <ddarius> @pl map f . map g
14:18:27 <lambdabot> map (f . g)
14:18:29 <sohum> don't we have hslint?
14:18:33 <b6> hlint.
14:18:33 <ddarius>  @pl knows all
14:18:41 <copumpkin> sohum: or if not A4, almost that big. I got my girlfriend a kindle dx and it's nicer than the smaller one, but not quite big enough to read papers comfortably on
14:18:49 <sohum> @hlint max5  = maximum (map product (map (map digitToInt) (map (take 5) (tails number))))
14:18:49 <lambdabot> No module "max5  = maximum (map product (map (map digitToInt) (map (take 5) (tails number))))" loaded
14:18:57 <sohum> @help hlint
14:18:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:19:08 <copumpkin> I had to add a parameter to max5 to make it pl-worthy
14:19:09 <sohum> oh, it's reading that as help help
14:19:19 <kroo> copumpkin -- I've got a DX -- have to turn it sideways sometimes to read comfortably
14:19:28 <kroo> but most of the time actually does work for papers
14:19:33 <copumpkin> kroo: yeah, and that's fine for one-column papers
14:19:41 <ddarius> Two column papers are evil.
14:19:41 <copumpkin> kroo: but two-column papers and sideways is a nightmare
14:20:05 <copumpkin> yeah, but they do have a good point that people don't like wide lines
14:20:09 <kroo> heh, forward. back. forward forward. back. repeat :)
14:20:33 <copumpkin> kroo: I tried that on a paper but got frustrated :) if the screen update were smoother maybe it wouldn't be so painful
14:20:47 <HaskellLove> I dont think you can merge the two maps, I have like 2d matrix in there...
14:21:00 <copumpkin> HaskellLove: no, it's a property of map
14:21:05 <kroo> yeah; one of these days they're going to solve e-ink
14:21:22 <copumpkin> max5 = maximum . map product . map (map digitToInt) . map (take 5) . tails
14:21:37 <ddarius> kroo: It's probably pretty much solved, just not commercialized yet.
14:21:43 <copumpkin> max5 = maximum . map (product . map digitToInt . take 5) . tails
14:21:52 <kroo> ddarius -- yeah? got a link?
14:21:52 <ddarius> @src maximum
14:21:52 <lambdabot> maximum [] = undefined
14:21:52 <lambdabot> maximum xs = foldl1 max xs
14:22:24 * copumpkin loves foldr sometimes
14:22:31 * hackagebot upload: Lucu 0.4.1 - HTTP Daemonic Library (MasatakeDaimon)
14:22:32 <copumpkin> > foldr min [0..] :: Natural
14:22:33 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
14:22:33 <lambdabot>         against ...
14:22:37 <ddarius> You could define maximum as a foldr and you could define tails as an unfoldr so you could do some foldr/map or map/unfoldr fusion and then some foldr/unfoldr fusion.
14:22:38 <copumpkin> > foldr1 min [0..] :: Natural
14:22:39 <lambdabot>   0
14:22:45 <kroo> ddarius:  thats awesome :)
14:23:07 <drhodes> if I've got two languages A and B and an AST of program_in_A (astA).  I think for any node in astA there exists a translation to one in astB (.. ok do that for all nodes ..). Then run a pretty printer over astB and this is an A to B compiler - so I'm wondering if there is a common way or tool or standard of specifying the node translations?
14:23:36 <copumpkin> > foldr1 min ([1..10] ++ [0] ++ [1..]) :: Natural
14:23:37 <lambdabot>   0
14:23:39 <copumpkin> :D
14:23:47 <copumpkin> foldr ftw
14:24:13 <HaskellLove> copumpkin where can i learn all the cool @pl and what not stuff u guys write here? pl is pointless or something? and gives u the function with dot notation?
14:24:40 <copumpkin> HaskellLove: yeah, or point-free
14:24:41 <dons> HaskellLove: are you scalalove?
14:24:46 <dons> http://www.haskell.org/haskellwiki/Pointfree
14:25:18 <HaskellLove> dons I was man... :D now I am Haskell freak
14:25:20 <dons> can't be with the chan you love, so you love the chan you're with? :)
14:25:23 <copumpkin> b6: zomg, it finally finished compiling :)
14:25:41 <b6> copumpkin: didn't mean to blow up your equipment.
14:26:00 <copumpkin> b6: oh no, I deal with this all the time. You should see me try to typecheck agda :) I walk away and come back later
14:26:15 <ddarius> copumpkin: Write faster type programs.
14:26:17 <ezyang> I saw someone hacking on Cantor normal form... and they were using Unicode characters... it was amazing
14:26:36 <copumpkin> ezyang: agda!
14:26:49 <copumpkin> ddarius: yeah :( but this wasn't even my code (mostly)
14:26:56 <sohum> ddarius: what'd you mean by eink's solved but not commercialised?
14:26:57 <copumpkin> just standard library code I was extending to be universe-polymorphic
14:27:11 <ezyang> oh wow, Agda uses unicode too...
14:27:12 <ivanm> dons: I take it you never ended up going to ANU and giving a talk?
14:27:23 <dons> i'm heading to .au in 2 weeks
14:27:29 <copumpkin> ezyang: agda has the most flexible naming system in any programming language I know of
14:27:33 <sohum> dons: awesome. where?
14:27:38 <ddarius> sohum: That's not what I said.
14:27:38 <ivanm> aha, for christmas I take it
14:28:23 <sohum> ddarius: oh? sorry, what did you mean, then?
14:30:11 <ddarius> sohum: I said "probably" and if your question is about "solved" ask kroo, but basically a "satisfactory" solution.
14:31:22 <sohum> ddarius: ah, fair enough. yea, I'll agree with you there - I got my prs505 almost two years ago and love it.
14:31:50 <copumpkin> I'm hoping http://www.plasticlogic.com/ will turn out to be decent
14:32:37 <kroo> copumpkin: guess we'll find out soon enough...  "Premiering January 7th at CES"
14:32:45 <copumpkin> yep :)
14:33:32 <sohum> it runs windows ce?
14:34:43 <kroo> looks to be a large touch-screen grayscale display
14:34:46 <sohum> I assume you lot have seen http://wiki.mobileread.com/wiki/E-book_Reader_Matrix , right?
14:34:55 <sohum> fantastic resource, that entire site
14:35:08 <copumpkin> kroo: e-ink
14:35:23 <kroo> copumpkin: right, or "plastic", as they refer to it as :)
14:35:28 <copumpkin> yeah :P
14:35:43 <sohum> their screens will apparently be flexible
14:36:21 <kroo> unless the whole device is flexible, i'm not sure how much thats actually a benfit
14:36:39 <copumpkin> lol, it's great that you won't risk cracking it when you take the device apart!
14:36:44 <copumpkin> I hate it when that happens ;)
14:37:12 <kroo> that happened to my DX after a particularly bad day in my backpack
14:37:20 <kroo> luckily amazon replaced mine :)
14:37:31 <copumpkin> nice :)
14:37:43 <kroo> this caused me to invest in screen-protection for the first time
14:38:12 <copumpkin> sohum: yeah, saw that :) been looking into e-readers for a while now because I'm tired of reading papers on an lcd and don't like printing stuff
14:38:12 <kroo> the dx definately needs it
14:38:33 <sohum> it's probably only really necessary on large format devices
14:39:08 <sohum> hm. I've been trying to find information about the DRM format B&N sells its ebooks in
14:39:12 * ezyang is rereading the LogicT paper. 
14:42:40 <manju_> hello
14:42:50 <copumpkin> ALÔ
14:42:54 <ezyang> HOLA!
14:42:58 <manju_> I was k-lined, because dronebl said I am running an insecure proxy server
14:43:02 <manju_> gah
14:43:09 <ezyang> meep
14:43:18 <ezyang> "did you try nmapping yourself?"
14:43:18 <manju_> it was false, somebody else had got this ip before
14:43:21 <kroo> prolly not a good plan :)
14:43:38 <manju_> how does one nmap oneself ?
14:43:41 <kroo> ah, darn dynamic ips :)
14:43:52 <tensorpudding> you ssh into another machine, and then do it
14:44:05 <manju_> I am sitting being 2 routers with hardware firewalls on a secure linux box
14:44:15 <kroo> manju_ ssh into your old research box at school, then nmap back in your direction :)
14:44:16 <manju_> 'I' can't even get it
14:44:35 <b6> copumpkin: did you try dist/build/GLFW-b-demo/GLFW-b-demo?
14:44:36 <manju_> ok lunch time
14:44:46 <copumpkin> b6: yep, got a non-perspective cube
14:44:51 * ezyang suddenly realizes it's really late. 
14:44:51 <copumpkin> sorry, thought I'd mentioned that
14:45:04 <b6> copumpkin: i probably missed it. thanks for doing that stuff.
14:45:13 <copumpkin> no problem :)
14:45:32 * ezyang switches to reading the Finger Tree paper 
14:45:59 <ivanm> ezyang: so you have "early reading" and "late reading" material? :p
14:46:16 <ddarius> Ralf Hinze has quite a few good papers.
14:46:35 <ezyang> ivanm: hehe
14:46:56 <ddarius> ivanm: "late reading" and "really late reading"
14:47:04 <ivanm> heh
14:47:43 <HaskellLove> I am new to ubuntu and installing lambdabot now... cd haskell-src-exts... where is actually that folder haskell?
14:48:07 <copumpkin> lambdabot is a pain to instlal
14:48:09 <copumpkin> I'd avoid it
14:48:50 <ivanm> agreed
14:48:56 <clarkb> ubuntu is a pain I would avoid it...
14:49:01 <ddarius> There's already a pibot somewhere, yes?
14:49:22 <ivanm> ddarius: /whois says not
14:49:33 <clarkb> and yet I can't find time to reload this machine
14:49:50 <HaskellLove> copumkin lambdabot is a must man
14:50:19 <ddarius> Almost everything lambdabot does is available as separate packages.
14:50:22 <ivanm> HaskellLove: online, yes
14:50:25 <ivanm> offline, not as much
14:50:45 <HaskellLove> ivanm how about dot refactoring?
14:50:53 <ivanm> realistically, the only plugins I'd use offline is @pl and maybe @src, though for the latter it's easier to look at the docs
14:51:05 <ivanm> HaskellLove: you mean @pl? IIRC there's a standalone tool for it on hackage
14:51:26 <copumpkin> HaskellLove: @pl is a package on hackage
14:51:30 <HaskellLove> really? :D cool i did not know it is standalone u have link? let me get it
14:51:30 <copumpkin> @hackage pointless
14:51:30 <lambdabot> http://hackage.haskell.org/package/pointless
14:51:36 <copumpkin> @hackage point-free
14:51:36 <HaskellLove> awesome
14:51:36 <lambdabot> http://hackage.haskell.org/package/point-free
14:51:41 * copumpkin gives up
14:52:01 <ivanm> @hackage this_package_doesn't_actually_exist
14:52:01 <lambdabot> http://hackage.haskell.org/package/this_package_doesn't_actually_exist
14:52:10 <copumpkin> yeah, I know
14:52:13 <copumpkin> http://hackage.haskell.org/package/pointful
14:52:36 <copumpkin> also, http://hackage.haskell.org/package/pointless-haskell
14:52:47 <medfly> haskell is pointless:)
14:53:03 <HaskellLove> medfly say that again
14:53:08 <ivanm> @slap medfly
14:53:09 * lambdabot smashes a lamp on medfly's head
14:53:16 <medfly> ow
14:53:16 <ddarius> @hackage pointful
14:53:17 <lambdabot> http://hackage.haskell.org/package/pointful
14:55:40 * hackagebot upload: pandoc 1.3 - Conversion between markup formats (JohnMacFarlane)
14:55:56 * ivanm wonders what changes are in this version of pandoc
14:56:13 <HaskellLove> copumkin so how to use it now? I downloaded it
14:57:07 <copumpkin> HaskellLove: oh, beats me
14:57:10 <copumpkin> I just pm lambdabot :)
14:57:17 <slc> I'm  working through Haskell School of Expression and am stuck because getWindowTick is no longer in Graphics.SOE.Gtk. Does anyone know a way around this under windows?
14:57:42 <HaskellLove> copumkin do you have his mobile phone?
15:00:47 * copumpkin gets back to hacking on a disgusting 10k-line piece of c++ shit that he's been procrastinating for a few hours
15:00:57 <ivanm> copumpkin: do I dare ask why?
15:01:38 <ezyang> I can't write a foldr with just map, right?
15:01:41 <copumpkin> ivanm: it's the only extant implementation of an algorithm I'm reimplementing in haskell, and some parts of it basically amount to me reverse engineering
15:01:47 <copumpkin> ezyang: nope
15:01:51 <copumpkin> but you can do vice versa
15:02:00 <ivanm> copumpkin: which alg?
15:02:02 <copumpkin> foldr in many senses is a fundamental operation of lists
15:02:13 <copumpkin> ivanm: called VEB, for training conditional random fields
15:02:22 <ezyang> ok. vice versa is map f = foldr (\a -> (:) (f a)) [] or something?
15:02:35 <copumpkin> yeah
15:02:51 * ezyang wonders if there's a more concise way to write that lambda 
15:02:53 <copumpkin> :t \f -> foldr (f . (:)) []
15:02:54 <lambdabot> forall a a1. (([a] -> [a]) -> [a1] -> [a1]) -> [a] -> [a1]
15:02:57 <copumpkin> whoops
15:03:06 <copumpkin> :t \f -> foldr ((:) . f) []
15:03:07 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
15:03:15 <ezyang> oh ho. :-)
15:03:39 <copumpkin> :t (flip foldr [] .) . (:)
15:03:39 <lambdabot>     Couldn't match expected type `a -> [a1] -> [a1]'
15:03:39 <lambdabot>            against inferred type `[a2]'
15:03:39 <lambdabot>     Probable cause: `:' is applied to too many arguments
15:03:43 <copumpkin> whoops :)
15:03:59 * copumpkin stops trying to procrastinate more by failing to @pl in his head
15:04:01 <ddarius> @pl \a -> (:) (f a)
15:04:02 <lambdabot> (:) . f
15:05:13 <copumpkin> @pl \f -> foldr ((:) . f) []
15:05:13 <lambdabot> flip foldr [] . ((:) .)
15:05:17 <copumpkin> there, that's it
15:05:22 <copumpkin> ;)
15:05:25 <copumpkin> I prefer the lambda one
15:06:26 <ezyang> ew.
15:06:44 <ezyang> I hate partially applied function compositions.
15:06:49 <ivanm> copumpkin: OK, what's a conditional random field? :p
15:07:32 <copumpkin> ivanm: a fairly flexible way of specifying a probability distribution and dependencies between its variables with a graph
15:07:45 <ivanm> hmmm.... sounds intriguing
15:07:46 <copumpkin> a bit like a hidden markov model, but more general and not generative
15:07:52 <ivanm> copumpkin: so what data structure are you using?
15:08:27 <copumpkin> my haskell code is a nightmare too right now, just hacking out a nasty thing that works and will clean it up once I get it working. But for now my graph is mostly IntMap-based
15:08:35 <ivanm> *nod*
15:08:54 <copumpkin> the code would be so much prettier if Map/Set could be Monads
15:09:09 * ivanm wishes that GHC was smart enough to use IntMap and IntSet under the hood if the key/value type is Int in a normal Map/Set...
15:09:17 <copumpkin> yeah
15:09:23 <copumpkin> not just Int, either
15:09:25 <copumpkin> Word, etc.
15:09:30 <ivanm> copumpkin: yeah, damn restrictions on what values are allowed in Sets! :p
15:09:43 <ivanm> copumpkin: well, you'd need WordMap/WordSet ... ;-)
15:09:50 <copumpkin> yeah, or unsafeCoerce :)
15:09:54 <copumpkin> ;)
15:10:29 <tensorpudding> coersion is bad
15:10:55 <ivanm> no, really? is that why it has the unsafe in the function name? ;-)
15:10:59 <ivanm> @hoogle unsafeCoerce
15:10:59 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:11:09 <ivanm> > unsafeCoerce 2 :: String
15:11:10 <lambdabot>   Not in scope: `unsafeCoerce'
15:11:12 <ivanm> bah
15:11:17 <ivanm> > Unsafe.Coerce.unsafeCoerce 2 :: String
15:11:18 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
15:15:47 <toast-opt> i saw a reference on wikipedia to sml/ocaml parametric modules having characteristics in common with haskell's type classes.
15:15:59 <toast-opt> i was curious if there was a good comparison of the two?
15:19:47 <copumpkin> they do
15:19:55 <copumpkin> having parametrized modules in haskell would still be nice
15:20:00 <copumpkin> and better module support in general
15:20:09 <ezyang> haha. The soln for compose is compose = foldr (.) id; I derived flip $ foldr ($)
15:21:59 <Twey> :t flip $ foldr ($)
15:22:00 <lambdabot> forall b. [b -> b] -> b -> b
15:22:05 <Twey> :t foldr (.) id
15:22:06 <lambdabot> forall b. [b -> b] -> b -> b
15:22:15 <Twey> Huh.  That actually works.  :þ
15:22:30 <ezyang> Yeah. Although, the former solution is (I think) more clever
15:22:51 <Twey> Well, it's more roundabout :þ
15:23:13 <tensorpudding> :t flip . foldr ($)
15:23:14 <lambdabot> forall a b. (a -> b) -> a -> [(a -> b) -> a -> b] -> b
15:23:17 <Twey> Nice to use the foldr initial value, though, aye.
15:31:52 <ezyang> ok, on to implementing foldM
15:35:37 <Twey> while :: (a -> Bool) -> IO a -> IO a; while cond act = act >>= join ((?? while cond act) . return)
15:35:49 <Twey> Well, actually
15:35:59 <ezyang> :t (??)
15:36:00 <Twey> while :: Monad m => (a -> Bool) -> m a -> m a; while cond act = act >>= join ((?? while cond act) . return)
15:36:00 <lambdabot> Not in scope: `??'
15:36:06 * Twey wants this in Control.Monad
15:36:15 <Twey> @let (y ?? n) p = if p then y else n
15:36:16 <lambdabot>  Defined.
15:37:07 <ezyang> "is there a lambdabot hackage library of @let dfns?"
15:38:20 <manju__> how do I convert a string to an Int ?
15:38:31 <Twey> Damn, while cond act = act >>= \v -> return v ?? while cond act $ cond v I guess
15:38:33 <manju__> [Char] -> Int
15:38:35 <ezyang> manju__: read is quick and dirty
15:38:46 <ezyang> > read "234" :: Int
15:38:47 <lambdabot>   234
15:38:53 <Twey> @pl \v -> return v ?? while cond act $ cond v
15:38:53 <lambdabot> liftM2 (?? while cond act) return cond
15:38:59 <Twey> Oh!  Yeah.  Of course.
15:39:02 <manju__> ezyang, it is not working for me
15:39:11 <ezyang> Are you explicitly specifying the type?
15:39:17 <ezyang> (somewhere, at least)
15:39:40 <manju__> n = read (args !! 0) :: Int
15:39:40 <manju__>   print (sumL 0 0 n)
15:39:48 <manju__> what is wrong with tis ?
15:40:07 <dmead> > let 2 + 2 = 5 in 2 + 2
15:40:07 <lambdabot>   5
15:40:27 <manju__> there is no space before print
15:40:35 <ezyang> Heard to say w/o knowing the types of args and sumL
15:40:38 <ezyang> *Hard
15:40:46 <manju__> args <- getArgs
15:41:00 <Berengal> manju__: What's in the args?
15:41:03 <manju__> n = read (args !! 0) :: Int
15:41:16 <manju__> "1"
15:41:18 <ezyang> I guess args should be [String]
15:41:36 <Berengal> Is this in a do or something?
15:41:40 <manju__> yes
15:41:52 <ezyang> Oh, you need a let.
15:42:03 <tensorpudding> > getArgs
15:42:03 <manju__> let me do a paste
15:42:03 <lambdabot>   Not in scope: `getArgs'
15:42:09 <Berengal> Then it should be 'do{let n = read (args !! 0) :: Int; print (sumL 0 0 n)
15:42:11 <Berengal> }'
15:42:37 <manju__> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5299#a5299
15:43:10 <Berengal> Yeah, you need a let in front of that =
15:43:20 <ddarius> manju__: Why did you assume the problem was with 'read'?
15:43:27 <Berengal> Same as when you're defining things in ghci
15:43:37 <manju__> it said parse before '='
15:43:53 <manju__> parse error
15:44:04 <ezyang> g'night all
15:44:10 <manju__> so I need let inside do
15:44:13 <manju__> ok
15:45:13 <manju__> it is kinda weird, whatever I do, my CPU gets hot, but I am not getting the answer for problem 12
15:45:16 <manju__> :-/
15:45:54 <copumpkin> do you have a good prime generator?
15:45:58 <manju__> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5299#a5300
15:46:16 <manju__> copumpkin, it doesn't need a prime generator, I think
15:46:43 <copumpkin> if you want it to be remotely usably fast, it does
15:46:58 <copumpkin> finding the divisors is as hard as finding prime factors
15:47:00 <manju__> copumpkin, ah...
15:47:08 <manju__> copumpkin, ok
15:47:13 <ivanm> copumpkin: you're selling one cheap I take it? :p
15:47:15 * manju__ didn't know that
15:47:16 <copumpkin> if you're testing all possible numbers, you're wasting work
15:47:21 <copumpkin> ivanm: hah nope
15:47:29 <copumpkin> well, even nub (flip divides) [2..]
15:47:35 <copumpkin> might be better than the naive approach
15:47:43 <copumpkin> probably not though
15:48:06 <Berengal> nub . map product . powerSet . factorize
15:48:08 <ddarius> nubBy
15:48:11 <manju__> copumpkin, hmm....ok
15:48:17 <copumpkin> oh yeah :)
15:49:44 <ddarius> Apparently Agda needs base-4.1 and that's apparently not what GHC 6.10.1 has.
15:50:25 <ivanm> ddarius: sounds like 6.12's base...
15:50:40 <copumpkin> I think it's 6.10.4
15:50:42 <copumpkin> or .3
15:50:59 <copumpkin> ddarius: just changing the constraint to base 4 will probably work
15:51:11 <copumpkin> ddarius: you installing from darcs?
15:51:17 <ddarius> No, cabal install.
15:51:25 <copumpkin> ah, that one doesn't have universe polymorphism yet
18:03:10 --- topic: '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:03:10 --- topic: set by Saizan on [Wed Dec 02 21:02:12 2009]
18:04:17 <HaskellLove> a = k (m^2 - n^2); b = k(2mn); c = (k^2 + n ^2) -------------- On wikipedia it does not say what this k is actually. So what am I supose to put it, all i know is m>n. I guess it would be ok for me to"fix" k one low value, and then change m and n and hope i will get a triple that gives me 1000 ... any sugestions?
18:05:23 <Cale> HaskellLove: This is related to generating pythagorean triples?
18:06:07 <HaskellLove> yep
18:07:15 <Cale> HaskellLove: For each rational number m/n greater than 1 (2*m*n, m^2 - n^2, m^2 + n^2) is a pythagorean triple.
18:07:39 <Cale> @let posRationals :: [Rational]; posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
18:07:40 <lambdabot>  Defined.
18:07:47 <Cale> > posRationals
18:07:48 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
18:08:18 <HaskellLove> Cale what formula is that? seems familiar
18:08:31 <Cale> HaskellLove: Essentially the one you just gave
18:08:38 <Cale> @let pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
18:08:39 <lambdabot>  Defined.
18:08:41 <osaunders> Tabs or spaces?
18:09:01 <Cale> osaunders: spaces. Tabs are evil and must be disposed of.
18:09:15 <Cale> > map (pyth . (+1)) posRationals
18:09:16 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
18:09:21 <osaunders> Does the whole Haskell community feel that way?
18:09:26 <Cale> osaunders: Yes.
18:09:30 <osaunders> OK.
18:09:39 <osaunders> 2 spaces?
18:09:47 <Cale> osaunders: In Haskell, the exact column alignment matters
18:09:57 <ziman> > unfoldr (Just . splitAt 3) [1..]
18:09:58 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
18:09:59 <osaunders> Yeah, I noticed.
18:10:03 <Cale> osaunders: I use however many spaces will make things line up.
18:10:18 <Cale> osaunders: and configure my tab key to insert 2 spaces
18:10:25 <osaunders> OK.
18:11:08 <HaskellLove> Cale your version wont generate all triples skips some, that is why i use the other version Euclid on stereoids the same as yours but has one more parameter k
18:11:31 <Cale> HaskellLove: Mine generates all pythagorean triples in which a,b,c have no common factor
18:11:55 <HaskellLove> yep, it is called primitive triple or something... i need them all
18:11:56 <Cale> HaskellLove: Every Pythagorean triple is a multiple of one of those
18:12:00 <Cale> okay
18:12:24 <osaunders> TextMate isn't very good any more.
18:12:31 <HaskellLove> but i need to find a triple so a + b + c = 1000 , i might skip it like that u see
18:12:32 <Cale> @let primitiveTriples = map (pyth . (+1)) posRationals
18:12:33 <lambdabot>  Defined.
18:12:55 <Cale> HaskellLove: Oh, in that case, you have a really good bound on how many you have to look at.
18:14:14 <HaskellLove> well there is only one such triple so i thought generating somehow infinite list, relay on lazy evaluation and go from smal to big and eventually it will find it...
18:14:29 <JohnDoe365> HaskellLove: this is typically a problem of constrain programming
18:15:07 * hackagebot upload: attempt 0.2.1 - Concrete data type for handling extensible exceptions as failures. (MichaelSnoyman)
18:15:10 * Baughn laughs crazily at /hakell/ having a working alloca, when C doesn't
18:15:27 <HaskellLove> JohnDoe365 any advices?
18:15:57 <Baughn> HaskellLove: Probably a bit too general, but have you looked at prolog?
18:15:59 <Cale> You really only have one parameter, since you have two equations in three variables a,b,c
18:16:12 <HaskellLove> Baughn yes
18:16:12 <quicksilver> osaunders: I, on the other hand, use an emacs indentation mode which understands haskell indentation and configure TAB to advance to the next sensible position.
18:16:46 <Baughn> ..some of the time, anyway. *fixes indentation of #-lines*
18:17:17 <osaunders> quicksilver: Is emacs hard/long to learn?
18:17:19 <Cale> You can eliminate c = 1000 - (a + b), giving  a^2 + b^2 = (1000 - (a+b))^2
18:18:10 <Cale> and then if you like, solve for a in terms of b, giving  a = (-b +- sqrt(2000 - 3 b^2))/2
18:18:59 <Cale> So first of all, you only have to check values of b for which 2000 - 3b^2 is positive and a square.
18:19:08 <Baughn> osaunders: Much less so than haskell, and it's similarly rewarding
18:19:50 <osaunders> Less than Haskell is pretty unspecific.
18:19:54 <Cale> Which puts some pretty severe limits on what b's you can try. There are not so many for which 3 b^2 is less than 2000
18:20:09 <osaunders> Given how Haskell is boundless.
18:20:41 <HaskellLove> Cale r u a grad?
18:20:45 <Cale> HaskellLove: no
18:21:20 <HaskellLove> u r good... thanks man will copy this now and study your solution thank you
18:21:24 <Cale> HaskellLove: Well, I have a BMath in pure mathematics.
18:21:42 <Cale> But I'm not a graduate student
18:21:51 <HaskellLove> sweet
18:22:50 <Cale> But this is just a little bit of highschool algebra -- the quadratic formula, and substitution.
18:23:07 <Cale> Along with keeping in mind that we want the thing to be an integer
18:23:36 <osaunders> Most people forget highschool algebra.
18:23:47 <osaunders> I have.
18:25:12 <osaunders> I've been working through the 99 Haskell problems.
18:25:25 <osaunders> It has been very useful for learning.
18:25:45 <osaunders> They start off really easy which is absolutely what I needed because I still found them pretty hard.
18:25:58 * osaunders should be using present tense.
18:26:03 <mullein> what are the 99 haskell problems?
18:26:17 <osaunders> 99 Questions, sorry.
18:26:29 <osaunders> http://www.haskell.org/haskellwiki/99_questions/1_to_10
18:26:58 <mullein> thanks, hadn't heard of them
18:27:24 <osaunders> I've solved #13 now and I was really happy.
18:27:42 <osaunders> Then I looked at the solution and I'm like "Bah, his solution is always nicer than mine."
18:27:53 <osfameron> heh
18:28:13 <osaunders> The palindrome solution was really annoying.
18:28:54 <HaskellLove> wow this is cool i will work on this and the eulers
18:29:12 <osaunders> I'm also thinking of doing some of the problems on Rosetta Code.
18:29:41 <osaunders> @google Rosetta Code
18:29:42 <lambdabot> http://rosettacode.org/
18:29:42 <lambdabot> Title: Rosetta Code
18:29:44 <osaunders> I like that site.
18:30:43 <nagnatron> osaunders: Thanks, didn't about the 99 problems. Very cool.
18:30:51 <osaunders> np
18:30:59 <weebl> hey i'm not weebl
18:31:13 <fracture> I have a toplevel equation in my module; something :: IO Int that returns random ints from 1-6... is it possible to have it track the history internally using IORef or something so it can reroll instead of returning one of the last 3 random values?
18:31:28 <quicksilver> osaunders: emacs is similarly boundless. But you can get the hang of basic editing quickly enough.
18:31:40 <Cale> I think problem 13 there is a little ill-posed. The code which they've given is not any more efficient than the obvious code using group.
18:32:37 <Baughn> fracture: Sure.. um...
18:32:41 <Cale> (It might have been, under strict evaluation, but group xs can be lazily consumed)
18:32:41 <osaunders> Cale: It's not about efficiency.
18:32:50 <Baughn> fracture: It Sounds Like You Want A Global Variable
18:32:50 <osaunders> Not for me anyway.
18:32:52 <osaunders> It's about learning.
18:32:54 <fracture> Baughn: how does that look?
18:32:54 <Baughn> fracture: May I suggest MonadRandom instead?
18:33:02 <Cale> osaunders: Well, yeah :)
18:33:10 <Baughn> fracture: ..well, I'm hardly the person to talk. Hang on.
18:33:20 <osaunders> Cale: So I quite like having to do the same thing again only slightly differently.
18:33:21 <fracture> ah, I've been kinda avoiding monad transformers
18:33:29 <Baughn> They're nice. ;)
18:33:36 <Baughn> fracture: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13966#a13966 <-- But you may get some inspiration from this.
18:33:48 <osaunders> It turned out to be quite different actually.
18:33:50 <fracture> if I were going to thread the state for this guy through the whole program I think it'd be equal work with or without them
18:34:04 <Cale> osaunders: Well, that's true
18:34:21 <fracture> ah thanks, I'll take a look at that
18:34:26 <theclaw> hi
18:34:50 <Cale> osaunders: It's just that the concern which led to the problem being a natural thing to ask for in lisp/scheme doesn't really apply to Haskell.
18:35:00 <Baughn> fracture: The point of using transformers is mainly that you can add more environment later, and you don't have to touch the functions using the transformer
18:35:16 <osaunders> Cale: Yeah.
18:35:24 <Baughn> fracture: ..no, not really. Um..
18:35:46 <Baughn> fracture: http://hackage.haskell.org/packages/archive/AES/0.2.1/doc/html/Codec-Crypto-AES-Monad.html <-- Here, I'd like to think this is a good use of transformers.
18:36:01 <Baughn> ..wait, I forgot to export AEST? Doh.
18:36:09 <sheyll_> Integer to UTCTime??
18:37:50 <ziman> Could not deduce (Functor m) from the context (MonadRandom m) <-- hmm, interesting
18:38:02 <ziman> i suppose that's because Monad does not depend on Functor
18:38:28 <ivanm> exactly
18:39:07 <Cale> ziman: So the options are to add a Functor m constraint or just to use liftM in place of fmap
18:39:25 <fracture> Baughn: I'm not fluent in them yet, but they seem potentially pretty heavy-weight for a lot of simple tasks...
18:39:30 <ziman> I used liftM.
18:39:31 <Baughn> fracture: You could use the random-number module I gave you as-is, if you like. It's cryptographically secure, yes, but you should still get ~200MB/s at least.
18:39:31 <theclaw> how do I use haddock recursively on a directory?
18:39:44 <lostella> #news
18:39:46 <lunabot>  luna: Not in scope: `news'
18:39:48 <lostella> pardon
18:39:50 <ziman> I just find <$> more aesthetically pleasing. :)
18:40:08 <Baughn> fracture: Otherwise just replace crypt with whatever you prefer
18:40:19 * hackagebot upload: AES 0.2.2 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
18:40:21 * hackagebot upload: SHA2 0.1.1 - Fast, incremental SHA hashing for bytestrings (SveinOveAas)
18:40:50 <HaskellLove> What is wrong here, gives me error on load: parse error on input `=' I load it from ghci
18:40:52 <HaskellLove> triple = [(a,b,c) | m <- [2..], n = (m - 1), a = ((m ^ 2) - (n ^ 2)), b = (2 * m * n), c = (m ^ 2 + n ^ 2)]
18:41:26 <pastah_rhymez> inside that list comprehension you want a ==, b == etc.
18:41:29 <pastah_rhymez> not =
18:42:03 <Baughn> Or possibly <- instead of =, but I really doubt it
18:42:28 <pastah_rhymez> Baughn: no, this is list monad, and RHS of those '=' are just Nums
18:42:57 <Baughn> Well, there /could/ be an instance Num [Int] somewhere..
18:43:30 <fracture> hm.  all this IO crap is still too advanced for me....  I think I'm just going to track the state at the place I need this (heh)
18:43:33 <HaskellLove> pastah_rhymez == ??? but isnt that compare, i need asignment operator
18:45:09 <osaunders> > integerToBreakfast 3
18:45:10 <lambdabot>   Not in scope: `integerToBreakfast'
18:45:23 <osaunders> Damn.
18:45:49 <osaunders> @remember integerToBreakfast = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover vindaloo curry"] !!)
18:45:50 <lambdabot> Good to know.
18:45:59 <osaunders> > integerToBreakfast 3
18:46:00 <lambdabot>   Not in scope: `integerToBreakfast'
18:46:15 <osaunders> @forget intergerToBreakfast
18:46:16 <lambdabot> Incorrect arguments to quote
18:46:31 <osaunders> I'm going to stop before I break anything.
18:49:10 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13967#a13967 can someone help me with this one line code?
18:49:25 <HaskellLove> it gives me that error when i load from ghci
18:50:06 <BONUS> HaskellLove: what are you trying to do with that code
18:50:31 <HaskellLove> get pythagorian triples
18:50:34 <BONUS> in a list comprehension the right side of the <- must always be a list
18:50:47 <BONUS> but here you did n <- (m - 1), and m is a number
18:51:02 <osaunders> > integerToBreakfast 5
18:51:03 <lambdabot>   "Waffles"
18:51:17 <pao> Cale: could you help me? I've a vague recall of a paper (probably by SPJ) discussing the impossibility to "merge" strict vs non-strict semantics in a language... have you read anything like that?
18:52:02 <HaskellLove> so <- in a list comprehension binds a variable to range not to single value... got it
18:52:26 <BONUS> HaskellLove: are you following any specific tutorials?
18:52:45 <osaunders> HaskellLove: Binds anything I think.
18:52:55 <HaskellLove> no i am researching solving by myself
18:53:24 <HaskellLove> BONUS i am using euclid formulas
18:53:25 <osaunders> > [ x,y | x -> 1, y -> [1,2,3] ]
18:53:26 <lambdabot>   <no location info>: parse error on input `|'
18:53:27 <BONUS> there's a thing on pythagorean triplets with list comprehensions here http://learnyouahaskell.com/starting-out#tuples
18:53:27 <Cale> pao: Odd... I don't recall seeing anything like that.
18:53:41 <osaunders> > [ x,y | x <- 1, y <- [1,2,3] ]
18:53:42 <lambdabot>   <no location info>: parse error on input `|'
18:53:57 <osaunders> > [ (x,y) | x -> 1, y -> [1,2,3] ]
18:53:58 <BONUS> usually it's better to follow some tutorials instead of just guessing the syntax and semantics
18:53:58 <lambdabot>   <no location info>: parse error on input `->'
18:54:05 <pao> Cale: it's only in my immagination probably... thanks for your attention
18:54:08 <Cale> pao: Do you have a better description of what is meant by "merge" there?
18:54:10 <osaunders> > [ (x,y) | x <- 1, y <- [1,2,3] ]
18:54:11 <lambdabot>   No instance for (GHC.Num.Num [t])
18:54:12 <lambdabot>    arising from the literal `1' at <inter...
18:54:58 <pao> Cale: I think it was about coding strictness in types ... i.e it is not possible to have a language in which Int !Int are different types
18:55:22 <pao> Cale: in other terms it is not possible to encode evaluation semantics in types
18:55:32 <Cale> Er, hmm...
18:55:45 <HaskellLove> BONUS: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13967#a13968 I still get errors check the new below
18:56:01 <Cale> I think it's possible to put that information in the types, but it's not really the right thing.
18:56:39 <BONUS> HaskellLove: the syntax is off
18:56:47 <HaskellLove> BONUS where?
18:57:08 <BONUS> well, you can't just do , n = (m -1),
18:57:10 <BONUS> maybe you want
18:57:50 <Cale> and from a perspective of seeing the type as a collection of values of some sort, it doesn't really make sense, because Int is already as strict as you can get without disallowing nontermination altogether. There's no such thing as a partially evaluated Int.
18:58:52 <BONUS> [(a,b,c) | m <- [2..], let n = m - 1; a = m^2 - n^2; b = 2 * m * n; c = m^2 + n^2]
18:58:57 <pao> Cale: that is true...
18:59:05 <BONUS> that would be ok syntax i think but it still wouldn't give you the pythagorean triplets
18:59:38 <pao> Cale: hmmm... i hate the fact that I didn't bookmarked the paper... :-(
19:03:03 <HaskellLove> BONUS yes it does
19:03:21 <BONUS> oh would you look at that
19:03:30 <BONUS> sorry, i'm still sleepy
19:03:32 <BONUS> congrats then!
19:04:38 <pao> Cale: I think I found it http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/not-not-ml.pdf
19:04:53 <BONUS> anyway, you can you let bindings inside list comprehensions
19:05:23 <BONUS> you could have also done
19:05:25 <pao> Cale: yep... that's the paper
19:05:25 <HaskellLove> BONUS what do you mean?
19:05:29 <BONUS> well like her
19:05:47 <BONUS> let n = m -1; a = m^2 - n^2; b = 2* m * n; c = m^2 + n^2
19:06:02 <BONUS> this is a let binding in a list comprehension. it binds values to names n, a, b, and c
19:07:03 <BONUS> you could have also done [(a,b,c) | m <- [2..], n <- [m - 1], a <- [m^2 - n^2] ...
19:07:09 <BONUS> but it's better to use let in such cases
19:07:17 <HaskellLove> yes yes got it i thought u ask me something else
19:07:33 <HaskellLove> hmm interesting what u just said let me test that
19:07:59 <BONUS> it makes sense, because [m - 1] is a list with only one element
19:09:00 <osaunders> > integerToBreakfast 10
19:09:02 <lambdabot>   "Headache pills and water"
19:10:38 <pao> Cale: by the way... my description was really misleading :-)
19:10:47 <kmc> > integerToBreakfast 3
19:10:48 <lambdabot>   "Cup of tea and a biscuit, gotta dash"
19:11:11 <kmc> > map integerToBreakfast [0..]
19:11:11 <HaskellLove> ah shit this euclid algorithm is skippin the triple i need: a + b + c = 1000
19:11:12 <lambdabot>   ["Cornflakes","Strawberry jam toast","Grapefruit","Cup of tea and a biscuit...
19:11:46 <kmc> :t integerToBreakfast
19:11:47 <lambdabot> Int -> [Char]
19:12:01 <Cale> > integerToBreakfast 100
19:12:02 <lambdabot>   "* Exception: Prelude.(!!): index too large
19:12:03 <kmc> hmm, i think Breakfast should be an abstract type with a Show instance
19:12:08 <kmc> and also a Cook and an Eat instance
19:12:50 <osaunders> kmc: Yes!
19:14:38 <HaskellLove> BONUS it skips the tupple i need man :) i will try new algorithms now
19:15:43 <BONUS> HaskellLove: yeah i think that algo doesn't generate all pythag triples, just some
19:16:15 <HaskellLove> there is one same like it but uses extra k parameter but why i did not how to use it
19:16:40 <HaskellLove> BONUS it is same as Euclid but plus one more parameter k check it on wiki if u can use it please help me
19:17:10 <notweebl> can anyone give me an example of usage of map map
19:17:14 <notweebl> i can't figure it out
19:17:18 <BONUS> notweebl: you mean map . map?
19:17:23 <notweebl> yes
19:17:25 <notweebl> no
19:17:27 <notweebl> map map
19:17:41 <BONUS> > map (map (+1)) [[1,2,3,4],[3,3,3]]
19:17:42 <lambdabot>   [[2,3,4,5],[4,4,4]]
19:17:45 <arjanb> :t map map
19:17:46 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
19:18:10 <toast-opt> is that like zip zip?
19:18:15 <notweebl> lol lol
19:18:18 <notweebl> ty
19:18:21 <toast-opt> :t zip zip
19:18:22 <lambdabot>     Couldn't match expected type `[a]'
19:18:22 <lambdabot>            against inferred type `[a1] -> [b] -> [(a1, b)]'
19:18:22 <lambdabot>     In the first argument of `zip', namely `zip'
19:18:23 <kw317> types tell you everything :-)
19:18:24 <HaskellLove> notweebl> check my function might help u somehow....
19:18:26 <HaskellLove> max5 = maximum (map product (map (map digitToInt) (map (take 5) (tails number))))
19:18:34 <toast-opt> oh, nm,
19:19:23 <HaskellLove> I used map(map bla bla above ... you use for 2d matrix kinda stuff where you have a list of list of elements and u apply the stuff to the elemnts
19:19:44 <notweebl> > ((.)$(.)) (==) 1 (1+) 0
19:19:45 <lambdabot>   True
19:20:12 <osaunders> That's pretty crude.
19:20:32 <BONUS> a more common thing is map . map
19:20:42 <BONUS> > (map . map) (+2) [[1,2,3],[3,4]]
19:20:47 <lambdabot>   [[3,4,5],[5,6]]
19:20:56 <BONUS> > (map . map . map) (+3) [[[1,2],[3,4]],[[2,3]]]
19:20:58 <lambdabot>   [[[4,5],[6,7]],[[5,6]]]
19:21:01 <ivanm> oooh, never thought of doing it that way
19:21:08 <ivanm> I've always done map (map f)
19:21:12 <ivanm> @type map . map
19:21:13 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
19:21:18 <ivanm> @type map . map . map
19:21:19 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
19:21:34 <BONUS> if you think of map as a function that takes a function a -> b and turns it into [a] -> [b]
19:21:38 <BONUS> then if you do map . map
19:21:54 <BONUS> it will take a -> b, turn it into [a] -> [b] and pass it to the other map, which will turn it into [[a]] -> [[b]]
19:23:39 <toast-opt> :t fix map
19:23:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
19:23:40 <lambdabot>       Expected type: a
19:23:40 <lambdabot>       Inferred type: [a]
19:24:29 <notweebl> > Maybe (Just Nothing)
19:24:30 <lambdabot>   Not in scope: data constructor `Maybe'
19:24:49 <toast-opt> :t fix Just
19:24:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
19:24:50 <lambdabot>       Expected type: a
19:24:50 <lambdabot>       Inferred type: Maybe a
19:26:51 <toast-opt> :t fix $ map . Just
19:26:52 <lambdabot>     Couldn't match expected type `a -> b'
19:26:52 <lambdabot>            against inferred type `Maybe ([a] -> [b])'
19:26:52 <lambdabot>     In the second argument of `(.)', namely `Just'
19:27:01 <HaskellLove> anyone knows how euclid formula works for pythagora triples, but with the extended parameter? or maybe point me to algorithms chanel?
19:33:10 <fracture> @hoogle filterM
19:33:10 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
19:33:10 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
19:34:16 <notweebl> BONUS: it was something different
19:34:17 <notweebl> it was like
19:35:38 <notweebl> let f = map map [(+1),(*2)]
19:35:56 <notweebl> and then map (\x -> x [1..10]) f
19:36:02 <notweebl> so you' d have a list of functions
19:40:50 <BONUS> well yeah you can do that, but i don't see where it's useful
19:41:18 <BONUS> > map ($ [1,2,3]) (map map [(+1), (*2), (+3)])
19:41:19 <lambdabot>   [[2,3,4],[2,4,6],[4,5,6]]
19:41:20 <notweebl> i know
19:41:31 <notweebl> but it was a question in an exam
19:41:32 <notweebl> :P
19:41:34 <BONUS> ah hehe
19:41:36 <notweebl> and i didn't understand it
19:41:57 <HaskellLove> triple = [[a,b,c] | m <- [2..]; let n = m - 1; let k = n; a = k*(m^2 - n^2); b = k*(2 * m * n); c = k*(m^2 + n^2)] What am i doing wrong here? When should you put ";" and when "," in list comprehensions?
19:42:48 <BONUS> > map <$> [(+1), (*2), (+3)] <*> pure [1,2,3]
19:42:49 <lambdabot>   [[2,3,4],[2,4,6],[4,5,6]]
19:44:49 <JohnDoe365> HaskellLove: (11:10:59) HaskellLove: JohnDoe365 any advices? <-- Sorry, no, that thats the kind of problems i resort to prolog normally
19:45:31 <HaskellLove> maybe u can help my question above then? JohnDoe365 about the ";" vs ,""
19:46:19 <fracture> this question might not make sense.... but is it possible to end up in the "wrong" monad?
19:46:41 <fracture> I am doing some stuff with a list of io actions, and it seems like it might be using the list monad definition for bind
19:47:42 <fracture> basically it's code of the form:   sequence $ take 6 (repeat randomPiece) >>= something
19:47:50 <fracture> where randomPiece is a IO PieceType
19:49:19 <JohnDoe365> HaskellLove: I'm myself a complete newbee in haskell ... real world haskell is still on shipping to my address ;)
19:50:12 <BONUS> HaskellLove: you can use one let to define several names
19:50:18 <BONUS> and you separate them with a ;
19:50:26 <fracture> ugh actually i was just doing something dumb, nm
19:50:30 * fracture must be tired.
19:51:19 <BONUS> you can also do stuff like [(x,a,b,y) | x <- [1..10], let a = x+1; b = x+2, y <- [2..20]]
19:51:23 <HaskellLove> BONUS: like:            let a = 3; b=a+2; c=b+7;
19:51:26 <BONUS> yeah
19:51:47 <HaskellLove> and you use "," for the guards only then i guess
19:52:20 <BONUS> you use , to separate let bindings, guards and generators (it's what i call the x <- [1..10] thing9
19:52:49 <BONUS> the above is equivalent to
19:52:51 <HaskellLove> how come u use ";" here then :  let a = x+1;
19:53:08 <BONUS> [(x,a,b,y) | <- [1..10], let a = x + 1, let b = x+2, y <- [2..20]]
19:53:22 <BONUS> you use ; to separate several name bindings in one let
19:53:28 <BONUS> but it's all still one let
19:53:40 <HaskellLove> ah ok got it now
19:54:13 <BONUS> anyway i prefer to write like [(a,b,c) | x <- [1..10], let a = x + 1, let b = x+2, let c = b+3]
19:54:17 <BONUS> and just avoid the ; alltogether
19:54:43 <HaskellLove> yeah lot better
20:03:53 <HaskellLove> triple = [[a,b,c] | let m <- [2..], let n = m - 1, let k = n-1, a = k * (m^2 - n^2), b = k * (2 * m * n), c = k * (m^2 + n^2)]
20:04:09 <HaskellLove> What is syntactiacly wrong with that code? ^
20:05:33 <Lemmih> HaskellLove: You're missing a bunch of let's.
20:06:11 <quicksilver> alternative, turn some of those commas into ;s
20:06:25 <quicksilver> which I assume is a legal way to separate equations in list comp lets
20:06:29 <quicksilver> it works in other places :)
20:08:45 <HaskellLove> Lemmih i miss lets? like where?
20:09:09 <Lemmih> HaskellLove: Read (or re-read) what BONUS wrote.
20:10:09 <zygoloid> > take 5 $ [[a,b,c] | m <- [2..], let n = m - 1; k = n - 1; a = k * (m^2-n^2); b = k * 2*m*n; c = k * (m^2+n^2)]
20:10:10 <lambdabot>   [[0,0,0],[5,12,13],[14,48,50],[27,120,123],[44,240,244]]
20:10:16 <nlogax> Sorry if anyone was disturbed by all my joining and quitting before. VPS freakout…
20:10:58 <HaskellLove> please repeat last posts guys i was disconected for a sec now
20:11:06 <zygoloid> > [[a,b,c] | m <- [2..], let n = m - 1; k = n - 1; a = k * (m^2-n^2); b = k * 2*m*n; c = k * (m^2+n^2)]
20:11:07 <lambdabot>   [[0,0,0],[5,12,13],[14,48,50],[27,120,123],[44,240,244],[65,420,425],[90,67...
20:11:57 <zygoloid> HaskellLove: don't put 'let' before a <- binding, and if you want to bind multiple variables in a single let, separate them with ; not ,
20:48:16 <HaskellLove> findIndex (==1000) (map sum pythags) : this is calculating some time now, is it infinite or wrong or something syntacticaly i mean?
20:48:20 <pastah_rhymez> hi
20:48:39 <ivanm> HaskellLove: if there was something wrong syntactically, then it wouldn't run at all
20:48:45 <quicksilver> HaskellLove: it will run forever if there is no item which sums to exactly 1000
20:48:51 <pastah_rhymez> I remember reading a blog post about performance in haskell games, using MONADIUS as an example
20:48:53 <ivanm> HaskellLove: and since I have no idea what you're doing, I can't tell if you're doing it properly
20:49:00 <pastah_rhymez> but i can't find it for the life of me
20:49:00 <ivanm> @hoogle findIndex
20:49:00 <lambdabot> Data.ByteString findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
20:49:01 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
20:49:01 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
20:49:09 <pastah_rhymez> could someone help out?
20:49:12 <HaskellLove> ok let me wait andsee then
20:49:15 <ivanm> quicksilver: will it? won't it just return Nothing?
20:49:23 <ivanm> or is pythags an infinite list of lists?
20:49:28 <quicksilver> ivanm: not if the list is infinite
20:49:39 <HaskellLove> infinite list yes but has value 1000
20:50:06 <HaskellLove> ok got it found it
20:50:15 <HaskellLove> Just 316
20:51:45 <pastah_rhymez> Cale: i found some log of this channel where you were involved in a discussion about this, GameObject etc...
20:53:03 <HaskellLove> (findIndex (==1000) (map sum pythags)) How to convert this from Maybe Int to Int?
20:54:00 <HaskellLove> toInteger... ok got it
20:54:08 <koala_man> you can use fromJust if you're sure it won't be Nothing
20:55:11 <HaskellLove> Couldn't match expected type `Int' against inferred type `Integer' ------------------ hmm i need to convert to Int not Integer, so there is no command for that, what now?
20:57:33 <koala_man> :t fromJust
20:57:34 <lambdabot> forall a. Maybe a -> a
20:59:08 <Cale> pastah_rhymez: Yes?
20:59:09 <Voker57> HaskellLove: fromIntegral
20:59:41 <Cale> pastah_rhymez: I sort of used Monadius as an example of possibly unfortunate choice of datatypes in http://cale.yi.org/index.php/A_look_at_OO_from_Haskell
20:59:50 <HaskellLove> fromJust did it
21:02:36 <pastah_rhymez> Cale: yeah, that was it
21:13:32 <theclaw> when calculating fibonacci numbers with "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)", zipWith always uses the "updated" fibs?
21:13:33 <theclaw> or did I get something wrong?
21:13:46 <quicksilver> theclaw: there is no update.
21:13:49 <quicksilver> theclaw: there is only one fibs :)
21:14:09 <theclaw> hmm.
21:14:10 <quicksilver> theclaw: but yes, zipWith uses the 'same' fibs - the one you are currently, recursively, defining.
21:15:42 <theclaw> quicksilver: yes, I know it's the same 'fibs', but the _result_ of fibs gets updated?
21:16:05 <quicksilver> I'm being a little pedantic to challenge you.
21:16:08 <quicksilver> There is no 'result'
21:16:10 <quicksilver> fibs is fibs.
21:16:14 <quicksilver> the result of fibs is fibs.
21:16:17 <pastah_rhymez> Tobsan: yo!
21:16:20 <Tobsan> yo pastah_rhymez!
21:16:24 <Tobsan> I was teh netsplitted
21:16:32 <theclaw> quicksilver: when zipWith does the first "+", I have the next element of fibs; when fibs gets evaluated the next time, it has this value
21:16:33 <pastah_rhymez> where are you?
21:16:45 <Tobsan> pastah_rhymez: the monad, what did you expect ;)
21:16:50 * pastah_rhymez is with yohan & sharous
21:16:51 <theclaw> quicksilver: still wrong?
21:16:57 <pastah_rhymez> Tobsan: be right there :)
21:17:07 <Tobsan> what?!
21:17:14 <quicksilver> theclaw: there is only one fibs, but it is lazily constructed.
21:17:27 <quicksilver> theclaw: (almost everythign in haskell is lazily constructed)
21:17:53 <quicksilver> theclaw: when you try to observe the 3rd element, that forces it to run the zipWith a bit
21:18:03 <HaskellLove> I just finished Euler #9 - http://haskelllove.wordpress.com/ - I document my thinking process there, onto #10 after I get some rest, damn... :D
21:18:08 <quicksilver> theclaw: by running that zipWith, fortunately, it only asks for the 1st and 2nd elements
21:18:13 <quicksilver> theclaw: (otherwise it would loop)
21:19:41 <theclaw> quicksilver: I think there's a communication problem :p
21:19:57 <theclaw> quicksilver: I understand that there's only one fibs
21:20:43 <Saizan_> operationally there isn't an update of fibs, it's more a filling of the nodes with their normal form
21:21:43 <Saizan_> you've this cyclic structure made of constructors and suspended expressions that unfolds
21:21:46 <theclaw> quicksilver: when zipWith tries to get the next element of fibs, it uses the values calculated before, so there has to be some internal update mechanism?
21:22:15 <quicksilver> there doesn't "have" to be, in terms of the semantics of the language
21:22:19 <quicksilver> but yes, in practice, there is.
21:22:45 <theclaw> Saizan_: I don't know, what do you mean with normal form?
21:22:51 <quicksilver> values are lazily calculated, and once part of a value is calculated, that part is written in there
21:23:01 <quicksilver> to save the time required to calculate it next time
21:23:23 <theclaw> quicksilver: if that weren't the case, this wouldn't work?
21:23:30 <Saizan_> theclaw: the form that can't be reduced further i.e. a concrete value
21:23:39 <Saizan_> (in this case)
21:24:32 <theclaw> Saizan_: hmm. I still don't quite get it. Which nodes are you talking about? :/
21:24:34 <quicksilver> theclaw: it would be quite OK to just start the calculation again
21:24:39 <quicksilver> theclaw: it would just make it very slow in deed
21:25:38 <Saizan_> so you don't update fibs incrementally to a longer list at each step, you just fill in the part that wasn't already calculated in place of the suspended expression
21:27:56 <Saizan_> theclaw: mh, maybe i'm not helping.. though basically you can picture the evaluation of a lazy language as reducing a graph made of conctructors and suspended expressions, also called thunks, that point to each other
21:29:03 <theclaw> Saizan_: I don't know enough about that yet to understand this :)
21:29:52 <quicksilver> theclaw: lazy evaluation is an ongoing process
21:30:07 <quicksilver> theclaw: initially fibs is <unexecuted code>
21:30:30 <quicksilver> theclaw: if you try to access the first element, it runs that code - but only as much as it needs to
21:30:39 <quicksilver> the fibs = 0 : <unexecuted code>
21:31:04 <quicksilver> theclaw: so fibs - the value - is well defined, it's an infinite list
21:31:08 <theclaw> quicksilver: yes, that makes sense
21:31:24 <quicksilver> theclaw: fibs - the representation in your computer memory - evolves monotonically
21:31:43 <quicksilver> where "monotonically" means the only permitted evolution is to replace <unexecuted code> with its result
21:31:51 <vy> Is there a cuter way to find the minimum head item from a list of lists than using "where (h:hs) = map head xs\n p = foldl' min h hs"?
21:31:54 <notweebl> if i have a datatype with { first :: String, second :: String} how do I create a new instance of this?
21:32:02 <quicksilver> nothing which has been evaluated previousely will change.
21:32:12 <quicksilver> notweebl: using the constructor, which you haven't told us ;)
21:32:37 <quicksilver> data TTT = CCC { first :: String, second :: String }
21:32:50 <quicksilver> you would then create a value as either (CCC "foo" "bar")
21:33:00 <notweebl> yeah that's what i meant
21:33:01 <quicksilver> or (CCC { first = "foo", second = "bar" })
21:33:06 <notweebl> thanks
21:33:17 <quicksilver> or (CCC { second = "bar", first = "foo"} )
21:33:31 <HaskellLove> More effiiceint way to do this? primesBelowTwo = takeWhile (<2000000) primes; sumPrimesBelowTwo = sum primesBelowTwo ------------- or there is no speed concerning code here? primes is a ready list of primes bu the way, but i am just concerned now if this section only can influence speed?
21:33:48 <Saizan_> i wonder what's a proper notation for expressions graphs over IRC, it'd be confusing to overload let
21:33:56 <vy> Nevermind.
21:35:25 <quicksilver> Saizan_: I don't think there is a good one-dimensional notation.
21:35:46 <quicksilver> "let" is a poor one-dimensional notation :)
21:36:20 <theclaw> quicksilver: at the bottom of http://en.literateprograms.org/Fibonacci_numbers_(Haskell) is an example of how this fibs is evaluated
21:37:04 <theclaw> quicksilver: there, when zipWith wants to access e.g. the fourth element if fibs, it uses previously calculated values. I don't know how that would be possible without.
21:37:37 <quicksilver> theclaw: of course it would be possible - it would just be very slow
21:37:53 <quicksilver> each time it accessed the fourth element it would have to recalculate it form the 1st, 2nd, and 3rd
21:37:55 <Saizan_> let fibs = 0 : a; a = 1 : b; b = zipWith (+) fibs (tail fibs) ~~> b = zipWith (+) fibs a ~~> b = 0 + 1 : zipWith a b ~~> ...
21:38:17 <Saizan_> not that pretty :)
21:39:16 <quicksilver> i.e. just like the naive recursive version, in effect
21:39:33 <quicksilver> plus a bonus list traversal to make it slower still :)
21:45:26 <theclaw> quicksilver: so for example, my current evaluation is 0 : 1 : 1 : zipWith(+) fibs_rest (tail fibs_rest), how would I calculate the 4th element if zipWith didn't have the "updated" fibs_rest?
21:45:54 <theclaw> quicksilver: from my understanding, fibs_rest would be 1:<undefined>
21:50:04 <theclaw> quicksilver: at the moment it seems to that not just it would be very slow, but that it simply wouldn't work :/
21:50:40 <quicksilver> theclaw: it's not fibs_rest it's fibs.
21:50:54 <quicksilver> theclaw: it would just start the calculation again (twice)
21:51:31 <theclaw> quicksilver: ? why is it fibs, not fibs_rest? zipWith is applied again with the rest of the list, not with the same list
21:51:35 <quicksilver> NO
21:51:39 <quicksilver> it's applied with the SAME list
21:51:42 <quicksilver> that is the whole point :)
21:52:14 <theclaw> quicksilver: I thought basically, zip (x:xs) (y:ys) = zip xs ys ?
21:52:18 <theclaw> err
21:52:22 <quicksilver> oh I see
21:52:30 <theclaw> zip (x:xs) (y:ys) = (x,y):zip xs ys
21:52:34 <quicksilver> you mean after you have expanded the zipWith once
21:52:38 <theclaw> yes.
21:52:39 <quicksilver> yes, that is indeed the tail.
21:52:54 <quicksilver> but in the non-thunk-updating version, each is a seperate copy of fibs
21:53:24 <quicksilver> fibsA = 0 : 1 : 1 : zipWith (+) (tail_of_fibsB) (tail tail_of_fibsC)
21:53:34 <quicksilver> and each of those in turn will spawn two copies
21:53:38 <quicksilver> so you get exponential time
21:53:44 <quicksilver> (just like the naive recursive function)
21:54:30 <pwerken> is there a way to suppress the 'modules loaded:' mesg in ghci?
21:54:49 <theclaw> quicksilver: so how is tail_of_fibsB calculated?
21:55:09 <Lemmih> pwerken: -v0?
21:55:40 <quicksilver> theclaw: by calculating fibs again
21:55:43 <quicksilver> theclaw: a second copy
21:55:45 <quicksilver> and a third copy
21:55:47 <quicksilver> and so on.
21:56:01 <quicksilver> just like calling a function twice in any language does.
21:56:13 <pwerken> Lemmih: thanks!
21:56:13 <theclaw> quicksilver: hmm.
21:56:24 <quicksilver> this is not how it works
21:56:29 <quicksilver> but the point I'm making is that:
21:56:42 <quicksilver> thunk-updating-evaluation is not the only way you can implement laziness
21:56:51 <quicksilver> sorry
21:56:57 <quicksilver> not the only way you can implement non-strict-evaluation
21:57:01 <quicksilver> (to be a bit more precise)
21:57:16 <quicksilver> you can implement non-strict-evaluation perfectly well by recalculating things every time, too
21:57:40 <quicksilver> using some kind of thunk-updating-scheme is much more efficient in most cases, and this is a striking example of when it is
21:57:44 <quicksilver> (linear time vs exp time)
21:58:13 <quicksilver> the "lazy" in "laziness" actually referes to being "lazy" by not calculating the same thing twice - instead you save the updated thunks.
21:58:26 <quicksilver> however, that confuses people who imagine that means automatic memoization which it isn't :)
21:59:05 <theclaw> quicksilver: mhm. I'm a bit confused now :)
21:59:49 <theclaw> quicksilver: unfortunately I have an appointment in 20 mins, can I get back to this discussion later?
22:02:28 <theclaw> bbl. thanks for your help
22:15:21 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=11 how to represent these in matrix in haskell? should i just put them in 20 lists?
22:16:58 <zygoloid> HaskellLove: i used a list of lists for that one
22:17:31 <zygoloid> HaskellLove: but equally you could copy and paste that into your source code as a string, and use  lines,  words  and read  to parse it
22:18:12 <HaskellLove> so you copied each and put it in a separate list and then enclose all in one list?
22:18:22 <HaskellLove> i would rather do that then the string way
22:20:34 <HaskellLove> on second thought it would take me lot of time copying each list and separating each element with ",", i guess i would copy everything as string and go from there
22:21:02 <HaskellLove> zygoloid how much time it took u to solve this?
22:21:30 <zygoloid> a couple of minutes. but i have a good editor ;-)
22:21:47 <JohnDoe365> zygoloid: Vim?
22:21:54 <HaskellLove> holy shit :D it will take me probably 4 hours
22:21:54 <zygoloid> yup ;-)
22:21:56 <Veinor> emacs?
22:22:17 <JohnDoe365> zygoloid: That was obvious ;)
22:22:54 <Veinor> also, it wouldn't be that hard to do it in any editor with generalized regexp find/replace
22:22:59 <HaskellLove> zygoloid i install vim now to check it out on ubuntu
22:23:35 <zygoloid> Veinor: sure, that's a feature i'd expect in any good editor :)
22:23:37 <JohnDoe365> HaskellLove: Under windows ther eis gvim, maybe there are gtk bindings for ubuntu too?
22:23:56 <Veinor> I know gvim exists on ubuntu.
22:24:24 <Veinor> also, how would you go about dealing with edge cases for that?
22:24:30 <HaskellLove> it found vim in synaptic so i install it now as vim
22:25:57 <JohnDoe365> HaskellLove: I suspect you'll only get console if this doesn't bother you ...
22:26:12 <quicksilver> HaskellLove: if you find it hard to do a structured search and replace on text you really need to learn how to use a decent editor.
22:26:22 <quicksilver> over time it will save you months of work.
22:26:32 <JohnDoe365> ack .. !
22:27:08 <Veinor> ah, now I see how to do it
22:27:09 <HaskellLove> i used netbeans man it is cool but scala did not work with so i did not try it with haskell hmm :( should i go netbeans?
22:27:54 <JohnDoe365> you mean eclipse?
22:27:56 <ToRA> i thought leskah was becoming the de-facto haskell ide
22:28:05 <JohnDoe365> I tried both
22:28:11 <JohnDoe365> both have wins and drawbacks
22:28:21 <JohnDoe365> don't now which one is better ...
22:28:36 <Veinor> I use emacs with haskell-mode.
22:28:44 <JohnDoe365> I mean i treid sclipse and leksha
22:28:54 <HaskellLove> JohnDoe365 both meaning? Netbeans u talk about? by the way i hate emacs and i could not install leksah
22:28:55 <Veinor> it has the usual emacs learning curve though :P
22:29:10 <JohnDoe365> eclipse .. yes
22:29:11 <vy> Is there any timing function available in the Prelude?
22:29:20 <Veinor> vy: timing function? like, sleep?
22:29:41 <quicksilver> vy: no.
22:29:49 <vy> Veinor: Like TIME in Common Lisp, to measure the execution time of a function call.
22:29:57 <Veinor> ahh.
22:30:02 <quicksilver> vy: that would be impure :)
22:30:17 <quicksilver> you can time IO actions with getCurrentTime though
22:30:19 <JohnDoe365> HaskellLove: The big win of eclipse plugin is the decent editor (for free), and the excelent project setup with cabal support
22:30:20 <ToRA> yv: if you mean cpu cycles used, there's System.CPUTime
22:30:44 <JohnDoe365> HaskellLove: and (D)CVS integration
22:31:01 <HaskellLove> (D)CVS integration, what is that?
22:31:12 <JohnDoe365> HaskellLove: The big win of Leksha is debugging supoort, although it's really buggy, it has cabal package support too
22:31:23 <mreh> trying to debug a HGL application just makes my terminal unresponsive
22:31:36 <mreh> it's blocking on something
22:31:42 <HaskellLove> nevermind i will just keep to my ubuntu text editor u guys confuse me so many options
22:31:50 <dcoutts> mreh: HGL is borked
22:31:58 <mreh> dcoutts_: alternatives?
22:32:00 <dcoutts> has been for years
22:32:02 <JohnDoe365> HaskellLove: (Distributed) Version Control system  ----- git, darcs, cvs, scm, .....
22:32:07 <mreh> preferrably with exactly the same interface
22:32:39 <Veinor> I don't like using eclipse on my netbook, it's java and therefore slow.
22:33:00 <JohnDoe365> hate emacs too ... but took me years to think of it as te anti christ ;)
22:33:09 <Veinor> :P
22:33:13 <mreh> dcoutts_: alternatives? preferrably with exactly the same interface
22:33:16 <Veinor> I'm using emacs because it's lightweight
22:33:24 <JohnDoe365> hahahaaha
22:33:31 <Veinor> :P
22:33:39 <Veinor> by which I mean, processor lightweight.
22:33:47 <mreh> emacs... lulz
22:34:05 <oteren1> eclipse is not slow because its java
22:34:09 <oteren1> its slow because its a rich IDE
22:34:10 <HaskellLove> i have installed eclipse and netbeans is there any stupid easy way to get haskell running there?
22:34:26 <HaskellLove> or i would have to install like 100 things and set some dependencies and what not
22:34:28 <Veinor> oteren1: ... also java
22:34:36 <mreh> HaskellLove, there are a couple of versions of an eclipse FP plugin
22:34:39 <oteren1> java dissing is so 2006
22:34:43 <mreh> I never got them working
22:35:04 <dcoutts> mreh: http://www.haskell.org/soe/software1.htm
22:35:21 <dcoutts> mreh: two new implementations of the SOE graphics API
22:35:22 <JohnDoe365> found it very easy
22:35:49 <JohnDoe365> even on (K)ubuntu 9.10 which i use next to my XP box every update site works perfectly
22:35:54 <dcoutts> mreh: SOE is a subset of HGL of course, if you want the full HGL and exact API then you're stuffed.
22:35:59 <oteren1> the haskell plugin for eclipse is really nice
22:36:10 <oteren1> but the ghc error output is rather limited
22:36:11 <JohnDoe365> can also recomend it
22:36:17 <JohnDoe365> yup
22:36:22 <mreh> dcoutts_: SOE doesn't have a way of extracting arrow key presses
22:36:23 <Cale> Heh, the joke used to be that emacs stands for "eighty megs and constantly swapping", but now we think "only eighty megs, that's not bad!"
22:36:24 <oteren1> so dont expect as good errors as when doing java
22:36:35 <oteren1> haha cale
22:36:36 <Veinor> Cale: exactly
22:36:58 <dcoutts> mreh: then look into the other proper graphics libs like gtk2hs, wxhaskell and a few other less used ones
22:37:01 <Veinor> hell most modern IDEs take up more memory/disk space than some old OSs
22:37:02 <mreh> eclipse typically runs with an 80 gigabyte footprint
22:37:12 <Veinor> speaking of gtk2hs, how active is development on it?
22:37:13 <pozic> Before I switch to anything else, I want to see a screencast first. Too much proof-of-concepts "tools" have been released.
22:37:39 <oteren1> 80gig footprint?
22:37:40 <dcoutts> Veinor: lots of patches on the commit list
22:38:02 <Veinor> so why haven't they been committed? :P
22:38:38 <quicksilver> Cale: the joke used to be *eight*, actually.
22:38:52 <JohnDoe365> oteren1: It's more like 120 ... but I have git and some web plugins
22:39:05 <dcoutts> Veinor: that is the commit list! ;-)
22:39:09 <Veinor> ahh, okay.
22:39:23 <Veinor> misunderstood what you meant, thought you said 'there are a lot of patches that have yet to be committed'.
22:39:41 <Cale> quicksilver: Ah, right :)
22:39:58 <dcoutts> Veinor: there's the devel list where people discuss stuff and a list where all the patches get sent once committed
22:39:58 <JohnDoe365> oteren1: BTW the git plugin makes it a breeze to stay up-to-date with a nascent project on github - dunonothing about darcs
22:40:09 <Veinor> I love github and git, it's sexy
22:40:21 * oteren1 has a deja vu
22:40:22 <Veinor> never actually used darcs though.
22:40:26 <mercury^> Emacs is still slow though. :>
22:40:40 <oteren1> the conversation went the exact same way the last time someone asked about the haskell FP plugin
22:40:51 <Veinor> mercury^: compared to what? :P
22:40:54 <JohnDoe365> Veinor: me too, bitbukcet (HG) is catching up though
22:40:55 <vy> I want to define a recursive fibonacci number sequence function computing the sequence from scratch every time. Is "fibs = let fibs' = 0 : 1 : zipWith (+) fibs' (tail fibs') in fibs'" ok for this purpose, or is there a more elegant solution?
22:41:02 <mercury^> Veinor: gedit even.
22:41:09 <Veinor> huh.
22:41:16 <Veinor> I used to use gedit and had no problems with it.
22:41:27 <mercury^> Yes, neither do I.
22:41:39 <mercury^> Apart from it fucking up when opening large files.
22:41:45 <mercury^> But Emacs is slow compared to it.
22:41:50 <Veinor> and I haven't had problems with emacs aside from the usual keyboard shortcut witchery
22:42:11 <Veinor> how slow is slow?
22:42:15 <Veinor> appreciably?
22:42:16 <JohnDoe365>  oteren1: vim vs. Emacs ?? ;)
22:42:28 <mercury^> I have not tried Yi yet, but so far I have not used a single good editor.
22:42:43 <mercury^> Yes, noticably and annoyingly slow on some operations.
22:42:46 <mercury^> Like starting up.
22:42:52 * Veinor shrugs
22:42:59 <Veinor> I find editor flamewars silly
22:43:04 <quicksilver> I think starting up is the only operation emacs is noticeably slow on
22:43:14 <quicksilver> and if you start up emacs more than once a fortnight, you're doing it wrong
22:43:38 <Veinor> in any case, I think I'm going to go get some breakfast
22:43:44 <Twey> Yeah, emacs is horribly slow.  The other day, I started it up and it took a whole 500ms to launch!
22:43:48 <quicksilver> for the operations we were discussing here (structured search and replace, semi-structured text editing)
22:43:53 <quicksilver> it's very fast.
22:43:54 <mreh> Veinor: but it's 2pm
22:44:02 <Veinor> mreh: maybe in your heretical timezone
22:44:04 <Veinor> !
22:44:11 <quicksilver> (not saying that other things might not be as fast or faster, but it's all sub human observation)
22:44:13 <Twey> 1439, to be precise.  ;)
22:44:38 <oteren1> JohnDoe365: no, from haskell FP plugin to discussion about CMS
22:44:44 <oteren1> *CVS
22:44:44 <mercury^> Twey: which is annoyingly slow if you start it up every time you want to edit a file.
22:44:52 <Veinor> that reminds me, I saw this picture of obama and some other world leaders at a meeting, and there was a digital clock that displayed the time in taiwan, london, NY, etc
22:44:59 <Twey> mercury^: No.  No it isn't.
22:45:08 <Twey> It's *half a second*.
22:45:20 <Veinor> and the first thing I noticed was 'huh, those clocks are out of sync'
22:45:33 <Twey> (and that's only because of all the extra stuff I have in my init file: a clean emacs launches instantaneously so far as I can tell)
22:45:34 <Veinor> cause one of them said 'xx:29' and the other said 'yy:30'
22:45:53 <quicksilver> mercury^: I refer you to my earlier comment - you're doing it wrong. Or you would be.
22:46:08 <Veinor> mercury^: who kills their editor after they're done editing?
22:46:12 <Twey> Yeah, daemon mode is useful anyway.
22:46:13 <mercury^> quicksilver: I guess so. But I like opening files through the shell and not the editor.
22:46:16 <JohnDoe365> oteren1: That's because I _think_ that when talking about an IDE, which eclipse is, it's not only the ditor you buy but also the environment, which is superb with CVS integration
22:46:23 <quicksilver> mercury^: then welcome to the 20th century
22:46:28 <quicksilver> mercury^: just use emacsclient
22:46:30 <Twey> mercury^: You can use the ‘emacsclient’ program to load the file
22:46:40 <quicksilver> mercury^: this problem was solved literally 20 years ago :)
22:46:42 <Twey> And even start a new frame in your current terminal
22:46:45 <Veinor> anyway, foodtimes for real
22:46:54 <vy> How one can force GC in GHC?
22:47:02 <quicksilver> vy: System.performGC
22:50:38 <vy> Why does length (take 10000000 fibs) leaks memory in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13974
22:51:29 <dcoutts> vy: because you're caching fibs at the top level
22:51:43 <dcoutts> so forcing a lot of it means you've got a lot in memory
22:51:54 <vy> dcoutts: That's what I was trying to avoid. How can I do that?
22:51:57 <keizer_nero> what does the erro "Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for 'runLength'
22:52:06 <dcoutts> the GC can release top level things, but only if you're not going to use them again
22:52:17 <dcoutts> and it's not always obvious that the program cannot use it again
22:52:26 <Saizan_> keizer_nero: means you're using a list as is it was an element or vice versa
22:52:40 <keizer_nero> thank you
22:52:44 <dcoutts> vy: certainly in ghci it's still in scope so you could still ask for it, so it cannot be discarded
22:52:59 <quicksilver> yes, I imagine vy is doing it in GHCi
22:53:10 <quicksilver> top-level things are never gced in ghci
22:53:26 <vy> quicksilver: Hrm... Thanks.
22:53:39 <quicksilver> for exactly the reason dcoutts gave
22:54:03 <vy> dcoutts: quicksilver: But my fibs implementation is correct, right? It will calculate the fib list from scratch every time?
22:54:59 <dcoutts> vy: it will calculate it once and if it's used in multiple places then it'll be cached.,
22:55:11 <HaskellLove> wow this is harder then i thought. converting a string into a matrix structure... it is more complicated that numbers are with two digits... http://projecteuler.net/index.php?section=problems&id=11
22:55:12 <dcoutts> because you've defined it as a top level value
22:55:49 <keizer_nero> why doesn't this work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13975#a13975 "Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for 'runLength'
22:56:02 <mreh> is there a wait :: IO () in haskell?
22:56:12 <mreh> some thread blocking function
22:56:14 <dcoutts> vy: the behaviour is fairly straightforward, things are memoised (cached) if (and only if) you bind them to a name.
22:56:15 <quicksilver> mreh: wait for what?
22:56:21 <Saizan_> you could make it polymorphic to defeat the sharing :)
22:56:27 <mreh> wait :: Int -> IO ()
22:56:44 <mreh> threadDelay
22:56:48 <mreh> thc
22:56:56 <mreh> thx*
22:57:24 <keizer_nero> why doesn't the followin work: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13975#a13975
22:57:37 <dcoutts> Saizan_: aye, without the MR then the behaviour becomes harder to explain
23:01:46 <Saizan> keizer_nero: bs is a list of lists, while runLength takes a list
23:02:39 <Saizan> keizer_nero: maybe the real problem is in samDup' though
23:02:42 <mreh> i just want to make a simple game of asteroids! SOE can't detect arrow keys for me, or convert them to HGL events
23:02:54 <Saizan> keizer_nero: are you sure it should return a list of lists?
23:02:54 <mreh> what's the simplest graphics interface after those two?
23:02:59 <aavogt> use hjkl then?
23:03:40 <keizer_nero> Saizan tnx
23:03:57 <mreh> lol, i thougth "hjkl?! is that some library I haven't heard of"
23:04:10 <Twey> Urgh
23:04:24 <keizer_nero> I saw the error it had to be rungLengt (a:as) and were it says bs it has to be as
23:04:43 <Twey> What genius came up with the idea of arranging the vertical movement keys horizontally, anyway?
23:04:54 <aavogt> @hackage hjkl
23:04:54 <lambdabot> http://hackage.haskell.org/package/hjkl
23:05:02 <aavogt> hmm, doesn't exist yet ;)
23:05:15 <Twey> Hehe
23:05:17 <Saizan> oh, right
23:06:19 <aavogt> well you fingers are kind of horizontally arranged by default...
23:06:36 <EvanR-work> what annoys me about hjkl is that jkl; is the home row position...
23:06:48 <nfrs> hi
23:06:56 <Twey> Speak for yourself — my middle finger reaches the row above naturally
23:07:00 <Twey> Hi
23:07:19 <Twey> EvanR-work: And yeah, that's really annoying, too
23:07:29 <nfrs> I'm trying to write my first little program in Haskell, would be grateful, if someone could answer several questions
23:07:43 <aavogt> well, then you have more delay to go up one line then quickly down a line... like that's supposed to happen often at all
23:08:16 <JohnDoe365> vy: This is woth a read, though the titel is very missleading: vy:
23:08:24 <JohnDoe365> http://muaddibspace.blogspot.com/2008/08/tail-call-optimization-doesnt-exist-in.html
23:08:35 <nfrs> 1. is there any way to specify that a f expects to receive a non-empty list as an argument?
23:08:36 <Twey> nfrs: I'm sure someone could.  Why don't you ask them and see?
23:08:41 <Twey> No
23:08:51 <Twey> Next ☺
23:09:01 <aavogt> accept this type instead:   (a,[a])
23:09:05 <Twey> (not in types, that is)
23:09:23 <Twey> Well, that's one way of doing it :þ
23:09:30 <theclaw> quicksilver: what I didn't get is why spawning a new copy of "fibs" helps in this case
23:09:45 <aavogt> it's just about as convenient as the GADT thing with the phantom types for nonempty lists
23:09:49 <theclaw> quicksilver: sorry for interrupting that discussion, didn't think it will take that long ;)
23:10:01 <nfrs> aavogt: that would just move the burden of proving that the list is non-empty to the caller. I'd like it to be automatically figured via the typesystem, if possible
23:10:28 <Twey> nfrs: No, we don't have a non-empty-list data-type.
23:10:32 <Twey> (we probably should)
23:10:46 <nfrs> Twey: any other way to do that? monads, shmonads?
23:11:15 <Twey> data NEL a = Thing a | More a NEL
23:11:47 <aavogt> that's isomorphic to my (a,[a])
23:11:55 <Twey> Yup
23:12:03 <Twey> But easier to define
23:12:39 <Twey> But less efficient to convert, I guess
23:13:06 <Twey> nfrs: Surprisingly, monads are not the answer to every solution ever devised ;)
23:13:12 <Twey> Er, problem**
23:13:30 <Twey> Ha, although many solutions also turn out to be problems… anyway.
23:13:33 <trzkril> :)
23:13:36 <nfrs> Twey: I heard something about dependent types solving something like this
23:13:44 <Twey> I believe they do
23:14:00 <nfrs> though I don't really understand what that means. any pointers?
23:14:03 <Twey> As a beginner, however, you don't want to go there.  ☺
23:14:34 <Twey> Just provide a means for dealing with it at the value level.  Maybe is popular.
23:14:37 <nfrs> Twey: I'd like to hack something working, but elegant, up and then analyze it :)
23:15:01 <nfrs> Twey: that's not fun. I've done that too much in ocaml :)
23:15:32 <mreh> can I nest do's like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13978#a13979
23:15:42 <Twey> http://www.haskell.org/haskellwiki/Dependent_type
23:15:43 <mreh> obviously not quite like this
23:15:54 <Twey> mreh: Yes
23:16:03 <keizer_nero> why doesn't this work http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13975#a13980
23:16:05 <mreh> Twey: check the rror
23:16:05 <Twey> But you need to fix the ‘if’
23:16:07 <mreh> error*
23:16:23 <Twey> The ‘then’ and ‘else’ of the ‘if’ need to be indented more, to show that they're part of the ‘if’
23:16:40 <mreh> > if True then "It is Truth" else "Unreachable stoopid"
23:16:41 <lambdabot>   "It is Truth"
23:16:53 <mreh> Twey: oh tx
23:17:20 <dcoutts> keizer_nero: 	where (b:bs) = samDup as
23:17:33 <dcoutts> keizer_nero: do you understand the error message?
23:17:40 <mreh> :t (!=)
23:17:41 <lambdabot> Not in scope: `!='
23:17:42 <keizer_nero> no i don't
23:18:12 <dcoutts> keizer_nero: an irrefutable pattern is one like above, where there's only one case and it's not allowed to fail
23:18:14 <mreh> can lambdabot give class info?
23:18:36 <dcoutts> keizer_nero: you get irrefutable patterns in let and where clauses
23:19:09 <keizer_nero> and what is the solution to it?
23:19:14 <dcoutts> keizer_nero: so you're stating that in this situation samDup as will always return a list of length at least one.
23:19:15 <Twey> rle = map (length &&& head) . group . sort
23:19:16 <EvanR-work> :t (/=)
23:19:18 <lambdabot> forall a. (Eq a) => a -> a -> Bool
23:19:47 <dcoutts> keizer_nero: and at runtime that has proved not to be the case (ie samDup as = [] )
23:19:57 <mreh> :i Eq
23:20:05 <keizer_nero> samDup does also has samDup [] = []
23:20:05 <Twey> Oh wait, no sort.
23:20:22 <dcoutts> keizer_nero: the solution is that you need to think more about the algorithm, what you expect the result to be in that case
23:21:07 <keizer_nero> i cannot see a problem because i think that there are enough patterns
23:22:46 <Veinor> keizer_nero: what happens if as = [] in runLength?
23:23:10 <dcoutts> keizer_nero: yes, it's not obvious to me either
23:23:41 <keizer_nero> veinor do you mean only as or (a:as)?
23:23:49 <Veinor> only as
23:23:58 <keizer_nero> let me think about that for a sec
23:24:00 <Veinor> that would happen if you call runLength on a list of one element
23:24:14 <dcoutts> keizer_nero: are you sure that's the code you're actually running?
23:24:31 <quicksilver> theclaw: depends what you think helps means
23:24:42 <quicksilver> theclaw: it makes it exponentially slower, but it means you don't need to do any updating.
23:25:01 <keizer_nero> then you will get (length as, head as) : runLength [] where (b:bs = samDup as
23:25:08 <Veinor> right.
23:25:16 <theclaw> quicksilver: e.g., in what way is tail_of_fibsB different from tail_of_fibsC?
23:25:18 <Veinor> so, as = []
23:25:22 <dcoutts> keizer_nero: I cannot reproduce it, since that code (3rd version) has a type error
23:25:28 <theclaw> quicksilver: I just don't understand the idea
23:25:34 <Veinor> dcoutts: I think I found the error
23:25:38 <Veinor> or at least, an error
23:25:48 <dcoutts> Veinor: there's an infinite type error :-)
23:25:49 <mreh> Nothing is like the new NullPointer
23:25:54 <mreh> it makes my program crash
23:26:05 <Veinor> well, I think I found the irrefutable pattern error
23:26:13 <keizer_nero> i didn't past my code i typet it
23:27:02 <keizer_nero> but veinor what do you think about the possible error
23:27:13 <Veinor> well, when you call runLength [x]
23:27:31 <Veinor> then a = x, as = []
23:27:39 <Veinor> so what would that make b and bs?
23:27:40 <theclaw> quicksilver: you still need the calculated values so far (0:1:1) for calculating the fourth value, how does tail_of_fibsB/C get them?
23:27:58 <keizer_nero> let me think about that for a sec
23:28:29 <keizer_nero> b  would b x and bs would be []
23:28:34 <keizer_nero> be*
23:28:35 <Veinor> no
23:28:43 <Veinor> since (b:bs) = samDup []
23:28:48 <Veinor> and samDup [] = []
23:29:02 <keizer_nero> oow i see
23:29:39 <The_User> Hi! Sorry, I've not yet learned Haskell (forgive me ;)), but I want to invoke a Haskell function I've found in a GNU-ML from command-line: print $ urToRegU8 (read getArgs[0]) (read getArgs[1]), of course there is no indexing (that would be unsafe), but I hope you know, what I mean. Is there any quick way to do something like that?
23:29:59 <keizer_nero> it almost works now
23:30:07 <mreh> > False && length [1..]
23:30:07 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
23:30:08 <lambdabot>         against inferred type ...
23:30:32 <mreh> > False && length [1..] > 1
23:30:33 <lambdabot>   False
23:30:36 <mreh> w00t
23:30:54 <mreh> > True || length [1..] > 1
23:30:54 <lambdabot>   True
23:31:27 <Veinor> > length [1..] > 1
23:31:30 <lambdabot>   mueval-core: Time limit exceeded
23:31:32 <Veinor> aww. :P
23:31:39 <mreh> actually that's bad, I dont understand why my program doesn't work now
23:31:47 <quicksilver> theclaw: by calculating them again.
23:32:02 <quicksilver> theclaw: do you understand this version, in pseudo-C?
23:32:06 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13981#a13981 -- this fails to exit on window closure
23:32:13 <mreh> I don't know why
23:32:26 <mreh> must be HGL borked
23:32:37 <quicksilver> theclaw: fib(n) { if (n == 0) { return 0; } if (n==1) {return 1;} return fib(n-1) + fib (n-); }
23:32:44 <quicksilver> theclaw: fib(n) { if (n == 0) { return 0; } if (n==1) {return 1;} return fib(n-1) + fib (n-2); } rather
23:32:59 <theclaw> quicksilver: yes
23:33:26 <quicksilver> theclaw: that recalculates 'the whole list' for the n-1 call
23:33:30 <quicksilver> theclaw: and again for the n-2 call
23:33:34 <quicksilver> theclaw: there is no sharing of results.
23:33:41 <quicksilver> that's all I'm suggesting.
23:34:07 <MarcWeber> Is anyone using Interlude ?
23:34:07 <mreh> can someone replicate this bug for me? HGL windows aren't returning a Closed :: Event on window closure
23:34:10 <theclaw> quicksilver: yes, but that would be fib n = fib (n - 1) + fib (n - 2) in haskell (plus the stop criteria)
23:34:47 <theclaw> quicksilver: I don't see how the version with the different "fib-instances" would do the same
23:34:58 <mercury^> theclaw: what version?
23:35:05 <quicksilver> theclaw: yes, but that is the same
23:35:10 <quicksilver> theclaw: a value is just a function call
23:35:13 <theclaw> mercury^: 14:48:49 < quicksilver> fibsA = 0 : 1 : 1 : zipWith (+) (tail_of_fibsB) (tail tail_of_fibsC)
23:35:15 <quicksilver> theclaw: there is no difference
23:35:23 <quicksilver> theclaw: would it help if I pretended it was a function?
23:35:46 <mercury^> What are tail_of_fibs{B,C}?
23:35:48 <quicksilver> fibs x = 0 : 1 : zipWith (+) (fibs x) (tail (fibs x))
23:36:12 <quicksilver> mercury^: they are (tail fibs) caused by inlining the first unfolding of zipWith
23:36:32 <keizer_nero> The update off the error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13975#a13982
23:36:35 <mreh> quicksilver: now give me the Seive of Arastopharnese
23:36:42 <mercury^> theclaw: do you understand this:
23:36:51 <mreh> aristophanes*
23:36:51 <mercury^> > let f = 1:f in f
23:36:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:37:01 <quicksilver> mercury^: you don't know what it is he doesn't understand ;)
23:37:03 <theclaw> mercury^: yes.
23:37:08 <quicksilver> mercury^: he's happy with how it works
23:37:15 <quicksilver> mercury^: this discussion is about thunk-updating
23:37:17 <mercury^> Ok. :>
23:37:23 <mreh> > fix (:1)
23:37:24 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:37:26 <quicksilver> mercury^: theclaw thought thunk-updating was essential
23:37:27 <HaskellLove> I have a long string of digits. 20 x 20 matrix, so that is 400 2-digit numbers, divided by empty space. How can I get a list with all of them as separate strings, how can i separate them using the empy space inbetween each? http://projecteuler.net/index.php?section=problems&id=11
23:37:30 <mreh> > fix (1:)
23:37:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:37:41 <quicksilver> mercury^: I was explaining that whilst thunk-updating is *efficient* you can in fact have non-strict evaluation without it
23:37:48 <quicksilver> mercury^: ...just at the cost of a lot of recomputation.
23:37:59 <mercury^> Right.
23:38:17 <mercury^> But I think Haskell requires the updating?
23:38:17 <Botje> HaskellLove: map (map read . words) . lines
23:38:26 <Botje> :t map (map read . words) . lines
23:38:27 <lambdabot> forall a. (Read a) => String -> [[a]]
23:39:02 <theclaw> quicksilver: pretending that it would be a function doesn't really help, no, sorry ;)
23:39:09 <The_User> ah, !!, okay
23:39:11 <mreh> why does everyone say HGL is borked, it seems to be being maintained, last upload Nov 4
23:39:20 <mreh> webpage doesn't mention any major bugs
23:39:44 <quicksilver> theclaw: but now it's the same as the C version
23:39:47 <quicksilver> theclaw: don't you see that?
23:40:03 <quicksilver> mercury^: not technically, no, although it would be pretty inefficient not to have it, and all implementations use it.
23:40:35 <quicksilver> and there's some wording in the report which vaguely suggestes it, especially in the bit about the monomorphism restriction.
23:40:40 <Berengal> quicksilver: Doesn't the report specify evaluation method? Or does it just say non-strict evaluation?
23:41:07 <nfrs> is there a built-in type for natural numbers?
23:41:25 <Berengal> nfrs: [()] ;)
23:41:30 <mercury^> I guess it's not so bad with multiprocessors around not to demand it.
23:41:38 <theclaw> quicksilver: sorry, but *how* is "fibsA = 0 : 1 : 1 : zipWith (+) (tail_of_fibsB) (tail tail_of_fibsC)" the same as the C version?
23:41:48 <mercury^> Some thinks may be a lot smaller than their evaluation.
23:41:49 <HaskellLove> Botje there is a catch 22: If I make newlines in the string it will show me indentation error and the file does not load, what now?
23:41:52 <MarcWeber> dcoutts: Is anyone working on enabling comments on hackage? Eg Interlude seems to be broken since 2008. I contacted the author by mail two days ago. The easiest solution would be createa link to the haskell wiki eg  http://haskell.org/haskellwiki/library-name-without-version This way we don't have to change much and we have a way to add notes such as. "This library is superseded by ..." or "Try this patch to make it compile with .." etc. How do you think ab
23:41:52 <mercury^> thunks*
23:42:20 <quicksilver> theclaw: that's not what I said.
23:42:35 <quicksilver> theclaw : fibs x = 0 : 1 : zipWith (+) (fibs x) (tail (fibs x))
23:42:37 <nfrs> Berengal: ah, the Church numerals. never get old
23:42:38 <dcoutts> MarcWeber: if you want to work on this, please help us with the new server, rather than hacking more features into the old one.
23:42:48 <zygoloid> HaskellLove: write it to a file, and read it from there?
23:42:54 <quicksilver> theclaw: that's the same as the C version. It has made fibs into a function, which is called recursively.
23:43:04 <HaskellLove> zygoloid yes
23:43:04 <MarcWeber> dcoutts: Don't you think that adding one link only can be done in 10min but provides many value to everyone?
23:43:28 <MarcWeber> dcoutts: Where can I read more about the new server?
23:43:28 <dcoutts> MarcWeber: it cannot be done in 10min, the page is generated, you can't just go edit it.
23:43:34 <zygoloid> @type (map (map read . words) . lines) <$> readFile "grid" :: IO [[Int]]
23:43:35 <lambdabot> IO [[Int]]
23:43:44 <dcoutts> MarcWeber: darcs get http://code.haskell.org/hackage-server/
23:43:56 <zygoloid> HaskellLove: ^^ something like that
23:43:56 <MarcWeber> dcoutts: But I can change the script generating the pages? or are they snapshots and are never touched again?
23:44:18 <theclaw> quicksilver: you mean it's the same as the C version when thunk updating isn't used, right?
23:44:33 <mercury^> theclaw: it will have the same complexity.
23:44:34 <HaskellLove> zygoloid oh man IO i am not ready :(
23:44:39 <dcoutts> MarcWeber: now I'm confused, what do you want to do exactly?
23:44:46 <Berengal> dcoutts: What's the status of the new server? Is there a blog or mailing list?
23:44:48 <theclaw> mercury^: that would make more sense
23:44:52 <nfrs> what is the analogical syntax construct to OCaml's (expr as x)?
23:44:58 <mercury^> Uh, well.
23:45:10 <dcoutts> Berengal: the status is that it's not done yet, and we could do with help to get it done
23:45:20 <dcoutts> Berengal: mailing list is just the cabal list
23:45:20 <nfrs> e.g. let f (x::xs as ys) = ...
23:45:24 <mercury^> They calls to "fibs" don't share any information.
23:45:30 <Berengal> dcoutts: I might get bored during christmas :)
23:45:30 <mercury^> The*
23:45:43 <mercury^> Grr, my ssh connection is laggy.
23:45:44 <Veinor> nfrs: I think you want f ys@x:xs, but I'm not sure
23:46:05 <Veinor> I know @ does what you want, I just don't remember the precise semantics and googling for it is hard
23:46:17 <quicksilver> theclaw: well, I added a function parameter to make it look less like thunk updating would be used.
23:46:26 <nfrs> Veinor: thanks
23:46:29 <dcoutts> Berengal: so grab the code and talk to me and Antoine Latter <aslatter@gmail.com>
23:46:44 <quicksilver> theclaw: because generally people tend not to expect functions to be thunks, only values.
23:46:49 <Summermute> (Potential)Newbie Question - from a 43  year old Pascal/Awk/C/C++/Java/CL/Scheme/~ML + more  Polyglot
23:46:56 <dcoutts> Berengal: the next target is mirroring and feature-parity
23:47:27 <Summermute> I'm really intereseting in learning Haskell if only for its use in many discussions of type theoretic issues.
23:47:33 <Berengal> dcoutts: Just got the code. Is there a trac by the way?
23:47:51 <theclaw> quicksilver: could you make a concrete example of how the fourth value of fibs is calculated, without using thunk updating? It seems otherwise I won't understand that
23:47:55 <theclaw> quicksilver: I can't think of any
23:48:11 <dcoutts> Berengal: same trac as the old server + cabal
23:48:44 <Berengal> dcoutts: I'll have a look :)
23:48:54 <zygoloid> theclaw: you can view it as graph reduction
23:48:58 <mercury^> Isn't there an interpreter that lets you explore the reduction graph?
23:49:20 <Summermute> But I'm also looking, for various reasons, to do a "shallow tackle" on a wide range of prosaic problems - a GUI app that catalogs recipes with pictures; a desktop Widget (Google or Yahoo); a simple DBM based database; a small XML-RPC server providing access to the recipes
23:49:35 <quicksilver> theclaw: the same way as in the C code?
23:49:47 <quicksilver> theclaw: fib (4) calls fib(3) and fib (2)
23:50:05 <MarcWeber> dcoutts: I'd like to provide a small forum where users can put comments  about libraries.
23:50:13 <quicksilver> theclaw: then, fib(3) calls fib (2) and fib (1); whilst fib (2) calls fib(1) and fib (0)
23:50:18 <MarcWeber> This forum must be accessible from hackage because everyone is looking fro packages on hackage
23:50:35 <quicksilver> theclaw: then, that fib(2) calls 1+0; fib(1) returns immediatley; fib(1) and fib(0) return immediately.
23:50:48 <quicksilver> theclaw: quite a lot of function calls.
23:50:51 <Summermute> You get the idea - My explicit interest is in experimenting with using advanced functional languages "embedded" deeply in the context of the OS and Library environments in which they run. So this gets into library availability, FFI issues, and so on - legitimate overall language design questions.
23:50:58 <Jonno_FTW_> hforum?
23:51:03 <Summermute> How good is Haskell a candidate?
23:51:10 <MarcWeber> If you click on package details eg http://hackage.haskell.org/package/korfu I'd add a link below "package description" at the bottom pointing to the haskell wiki. By default the page doesn't exist. But if there is a note you want to add you can just edit the page and be done.
23:51:31 <theclaw> quicksilver: okay, then my problem lies elsewhere. Could you explain _why_ this behaves like the C version when not using thunk updating?
23:52:10 <MarcWeber> dcoutts: The main goal is to enhance user experience. Someone told me recently that you have the idea of letting soemone change the .cabal file only (to update dependencies) or such. Great idea.
23:52:13 <mercury^> Summermute: Haskell is very capable of solving "desktop programming" problems.
23:52:32 <dcoutts> MarcWeber: ok, so this isn't a small feature, and we should do it in the new server
23:53:04 <Veinor> @faq can haskell solve desktop programming problems?
23:53:05 <lambdabot> The answer is: Yes! Haskell can do that.
23:53:12 <MarcWeber> dcoutts: :) Right now I'm still trying to recompile a small app using a more recent ghc. But I have to patch many libs because they still support base3. In this case hsql.
23:53:14 <Veinor> there you go!
23:53:21 <Summermute> mercury^:  that's good to hear - in my somewhat random researching, I did come across a wxHaskell, a library with which I'm familiar from a some Python hacking
23:53:24 <Jonno_FTW_> @faq can haskell do my laundry?
23:53:26 <absentia> maybe it can, but I can't do it with haskell
23:53:27 <lambdabot> The answer is: Yes! Haskell can do that.
23:53:27 <absentia> yet
23:53:34 <Jonno_FTW_> wow!
23:53:39 <quicksilver> theclaw: I don't know how to answer "why"
23:53:46 <MarcWeber> dcoutts: Why is it big? The feature is provided by haskell.org wiki. hackage only provides a link.
23:54:08 <mercury^> Summermute: I do not just mean GUIs (for which the GTK binding is probably better), but also the other things you mentioned.
23:54:15 <quicksilver> theclaw: I'm saying "existing haskell implementations use thunk-updating, but that's not technically required. They could, instead, treat values just like C treats functions"
23:54:17 <MarcWeber> And it should be damn easy to make the new server point to the wiki as well.
23:54:27 <Summermute> Can anyone briefly characterize Haskell's FFI mechanism - I'm not above rolling my own when needed
23:54:32 <pastah_rhymez> @src fi
23:54:32 <lambdabot> Source not found. You speak an infinite deal of nothing
23:54:35 <pastah_rhymez> @src fix
23:54:35 <lambdabot> fix f = let x = f x in x
23:54:43 <quicksilver> theclaw: and if they did do that, well , that's what you'd get.
23:54:45 <dcoutts> MarcWeber: oh so you don't want to make a user commenting system, just want to add links to the haskell.org wiki
23:54:54 <MarcWeber> dcoutts: You got it.
23:55:21 <mercury^> Summermute: I am not an expert on it, but you can basically interface to C by giving the C functions Haskell signatures.
23:55:40 <MarcWeber> I really dn't have time to add ikiwik or whateverwiki to hackage. But I'd like to provide wiki like features. Just a page everyone can edit to share knowledge which isn't worth uploading a new package version
23:55:41 <Summermute> mercury^:  Even better to hear :-)  And GTK sounds good. Many years now later after my first encounters, there are solid GTK implementations for the major 3 platforms - *nix/Mac/Win (I do Win and Linux)
23:56:18 <Summermute> Any knowledge here on the list regarding data structure representation control in an FFI context?
23:56:19 <dcoutts> MarcWeber: so my concern is that package authors might not always like it, it means yet another "home page" like thing that they have to look at and maintain
23:56:27 <mercury^> (You can also call haskell functions from C, by giving them C compatible signatures)
23:56:35 <dcoutts> MarcWeber: what does CPAN do?
23:56:42 <mercury^> Summermute: I suggest you read the FFI documentation that is part of the language report.
23:57:07 <MarcWeber> dcoutts: I don't know. I just know that I want to tell people that I have a patch for Interlude which makes it work.
23:57:12 <theclaw> quicksilver: when I tell a haskell interpreter without thunk updating to evaluate "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)", then how would it infer the "C version" from that?
23:57:13 <Summermute> mercury^: A great benefit of a good compiler - support for calling conventions! Big duh, but it can be left out of so many languages!
23:57:36 <MarcWeber> others see it, download it and get disappointed because they can't find their head call causing trouble but get more type errors.
23:57:42 <dcoutts> MarcWeber: the best approach of course is to contact that author, if the author is AWOL then ask on the libs list to take it over
23:57:55 <quicksilver> theclaw: it would treat everything as a function.
23:58:06 <quicksilver> theclaw: it would treat fibs as a function which ignores its argument
23:58:10 <quicksilver> theclaw: (a function of no arguments, if you like)
23:58:53 <Summermute> mercury^:  I'll definitly peruse the docs. Is there any support from Swig or similar language specific tools or on a different tack, libffi which PLT Scheme uses with oodles of Scheme infrastructure/macros on top?
23:59:10 <MarcWeber> dcoutts: They may be on holiday. I think we don't have time to waste on fixing the same things mulitple times. But maybe I should ask this question again on haskell-cafe. Maybe its only me who wants get things done right now and maybe fix them properly after receiving a reply of the maintainer
23:59:28 <SamB_XP> Summermute: there's c2hs
23:59:59 <mercury^> And Greencard.
