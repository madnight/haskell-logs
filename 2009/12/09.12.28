00:00:18 <Jafet> Hah. But I'm a nobody
00:00:19 <HaskellTripleLov> is there some graphing tool that graphs recursive functions?
00:00:47 <c_wraith> mathematica.  or any of the similar packages.  there's nothing special about recursion
00:02:05 <HaskellTripleLov> mathematica allows that? seriosly?
00:03:00 <c_wraith> there's *nothing* special about recursive functions, as far as mathematica is concerned
00:03:21 <HaskellTripleLov> well why did you recomend it... nevermind i will get some book now
00:03:41 <c_wraith> like I said.  It can graph them, the same way it can graph any function.
00:03:53 <c_wraith> it doesn't care whether or not it's recursive
00:05:10 <ivanm> you give it an x value, it calculates a y value
00:05:19 <ivanm> you give it a bunch of x values, it calculates the y value for each
00:05:37 <ivanm> it then uses those value pairs to plot points on a canvas and (presumably) joins them up with line segments
00:05:49 <ivanm> maybe even some interpolation for smoothing it out a bit
00:06:24 * ivanm should point out that this is a guesstimate on how it works, since he's never really used mathematica
00:06:41 <ivanm> what would be clever (but probably unfeasible) would be if it detected that it was recursive, and used previous values rather than recalculating them afresh
00:08:01 <c_wraith> eh.  unless it's an exceptionally slow-running function, it can calculate it for every x pixel on the graph fast enough that there's no real issue.  It's only a couple thousand samples, worst case.
00:08:23 <kmc> that optimization would just be memoization
00:08:29 <kmc> which is valuable independent of recursion
00:08:52 <kmc> i hope you can express memoization as a higher-order function in mathematica
00:09:32 <kmc> my guess is that you can as i'm almost certain there's an implementation of half of Common Lisp buried deep in the guts of Mathematica
00:10:46 <ivanm> heh
00:10:57 <ivanm> kmc: greenspun's 10th?
00:11:59 <Cale> Hmm, hackage needs a feature where it builds a generic documentation tree for the latest version of any given package, with roughly fixed URLs so long as the module names don't change.
00:12:26 <Cale> That way, there would be a URL for the most recent documentation for any given package.
00:13:35 <ivanm> Cale: you mean have a latest URL like ghc does?
00:14:02 <HaskellTripleLov> c_wraith you use it on ubuntu? i am thinking of geting the windows version and use it with wine on ubuntu?
00:14:09 <ivanm> hmmm... maybe even "hackage flags", so for things like criterion that need packages that aren't on hackage...
00:14:12 <Cale> ivanm: yeah
00:14:16 <DigitalKiwi> so cabal is a package manager for haskell libs, right?
00:14:19 <c_wraith> I've used it on windows and solaris.  But not recently for either.
00:14:26 <Cale> ivanm: Also, the GHC hierarchical libraries documentation should be fixed.
00:15:01 <ivanm> DigitalKiwi: no
00:15:13 <ivanm> Cabal is a library used for packaging libraries and applications
00:15:33 <ivanm> cabal-install is a limited package manager for packages that are buildable with cabal (and found on hackage)
00:15:44 <DigitalKiwi> so it doesn't actually manage them, just install?
00:16:23 <ivanm> what do you mean by "manage"?
00:16:27 <ivanm> it can't uninstall, for instance
00:16:43 <ivanm> and automatic upgrades is currently disabled to avoid breakage
00:17:31 * hackagebot upload: plist 0.0.2 - Generate and parse Mac OX property list format (YurasShumovich)
00:17:51 <jfischoff> How do you write a quickCheck test where first arg is always less then the second?
00:18:19 <ivanm> jfischoff: as in only check the property if this condition holds?
00:18:27 <ivanm> or you want to check that the first arg is < second arg?
00:18:27 <jfischoff> ivarm: yeah
00:18:47 <jfischoff> ivarm: the first thing you said
00:19:13 <ivanm> jfischoff: first of all, there's no `r's in my nick ;-)
00:19:37 <ivanm> @type (==>)
00:19:38 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
00:19:39 <jfischoff> ivanm: I just say that, my bad ^_^
00:19:42 <ivanm> jfischoff: ^^ ;-)
00:19:54 <jfischoff> thanks guys
00:19:57 <ivanm> jfischoff: so prop_blah a b = a < b ==> .....
00:19:59 <ivanm> no worries
00:21:41 <jfischoff> dope, worked like a charm :)
00:31:38 <HaskellLove> anyone has installed ghc 6.12 i get  errors http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15121#a15121
00:33:20 <c_wraith> 6.12 isn't ready for normal use.  it's missing a lot of commonly-used libraries, still
00:34:16 <HaskellLove> ok i will just leave it, i downloaded it and i cant watch it sitting uninstalled :D
00:35:51 <Cale> HaskellLove: Though, that's an easy error to fix
00:36:12 <Cale> HaskellLove: It's complaining that you don't have a /usr/local/share/man/man1 directory
00:36:42 <Cale> So if you really do want to install 6.12, it's probably as simple as making that directory
00:37:16 <Cale> However, I haven't installed it myself, as I'm going to wait a while for compatibility to improve.
00:41:06 * ivanm hasn't installed it, because he needs to get some code written before he wastes time fiddling with 6.12 and library compatability
00:41:51 <HaskellLove> you mean compatibility between versions? i dont need that i just solve eulers
01:17:18 <merehap> is it possible to build a haskell source file as an executable binary if the module is other than Main? if so what ghc options to I need to pass?
01:17:52 <kmc> ghc -main-is
01:18:04 <merehap> thank you, kmc
01:18:11 <kmc> you're welcome :)
01:21:25 <merehap> kmc: hm, does it work with 6.10.4?
01:21:47 <merehap> oh, wait
01:22:48 <merehap> it looks like the purposes of that is to specify a different function as main
01:22:53 <merehap> rather than a different module
01:23:02 <merehap> I need:
01:23:05 <merehap> module Foo where
01:23:10 <merehap> main = print "Hello"
01:23:30 <merehap> and it should be compiled as an executable file
01:24:32 <doserj> -main-is Foo should work
01:25:16 <doserj> as should -main-is Foo.main
01:26:33 <merehap> hm, I'm getting link errors, but I'll keep trying...
01:27:20 <doserj> rm *.o?
01:28:15 <merehap> ha, you're good, thanks
01:33:45 * mux notes FreeBSD 8-STABLE got PIE fixes yesterday and guesses it's time to make GHC 6.12.1 work with shared libraries and FreeBSD
01:35:31 <HaskellLove> hmm how to start with this one guys? http://projecteuler.net/index.php?section=problems&id=27
01:36:10 <medfly_> you sure are determined , HaskellLove
01:36:35 <HaskellLove> i got 25 so far level one yeeiii :D
01:37:21 <merehap> bruteforce works fine on that problem, if I recall...
01:38:02 <medfly_> can't see why it won't :p
01:38:33 <copumpkin> HaskellLove: :O
01:38:51 <copumpkin> HaskellLove: you have a search space of 4 million :)
01:39:00 <medfly_> you can filter out cases if you want, like there are cases where it's obviously non-prime
01:39:05 <HaskellLove> copumpkin scary yeah :D
01:39:30 <copumpkin> HaskellLove: if the expression factors, then it won't generate primes
01:39:47 <medfly_> even easier, you can use even/odd rules
01:43:05 <copumpkin> HaskellLove: once you've filtered out the obviously bad choices for a and b, I'd just make an Set of the first bunch of primes, so you can test very quickly whether your sequence generates primes
01:45:07 <lament> We know b is a prime. We also know that the biggest n is smaller than b, so b must be somewhat big. Start searching from the large end of values for b; as soon as you start generating results, you get some maximum n - then you know that usable b are greater than that
01:51:36 <merehap> I kept going on the euler problems until I realized that I'd have to put some time into studying number theory in order to make further progress...
01:52:04 <merehap> learning Haskell is enough for me right now, let alone adding number theory to that
01:52:19 <copumpkin> not sure you really need much number theory
01:52:33 <copumpkin> they're all pretty concrete
01:52:50 <merehap> lots of combinatoric transformations started to become necessary for optimization
01:52:55 <Jafet> You need basic number theory to do them well.
01:52:59 <Jafet> But not Basic Number Theory.
01:53:14 <copumpkin> :)
01:53:47 <merehap> once I started reading the comment threads on some of the higher problems it was clear that there were a few gaps in my knowledge
01:53:49 <Jafet> If you need less puerile exercises to do, I'd consult Knuth or HAKMEM
01:53:57 <Jafet> EP is a minor joke
01:53:59 <merehap> that would take some time to fill in
01:54:32 <merehap> Jafet: I had fun with them, but I've moved on for now
01:54:47 <merehap> I've found some more practical things to do
01:54:58 <copumpkin> yeah, after doing a couple dozen PE problems, I doubt you'll learn much more haskell from them
01:56:08 <merehap> it did force me to start using more efficient data structures than lists, along with other things
01:56:18 <HaskellLove> copumpkin correct, but you learn problem solving which is the point of project euler
01:56:31 <HaskellLove> merehap that too...
01:56:46 <copumpkin> yeah, that's what I mean about a couple dozen of them
01:56:50 <HaskellLove> it is not that bad as ah you won't learn anything from euler bla bla
01:56:57 <copumpkin> I didn't say that
01:57:01 <copumpkin> I said you won't learn any more haskell
01:57:26 <HaskellLove> yeah i am just saying cause lot of people hold that opinion
01:57:51 <Jafet> EP doesn't teach you problem solving.
01:57:58 <Jafet> You just have no idea how complex real problems are.
01:58:06 <HaskellLove> Jafet well I must be retarded then ...
01:58:21 <Jafet> It's mostly computational number theory exercises.
01:58:44 <HaskellLove> Jafet can you tell me one such real problem so i compare where i am
01:59:09 <Jafet> A factoring sieve. Now there's a nice problem
01:59:18 <Jafet> One I'm not sure Haskell can even do yet, in fact
01:59:27 <Jafet> (Sans FFI)
02:00:17 <copumpkin> Jafet: why not?
02:00:21 <merehap> a factoring sieve? from my understanding that was useful in a few of the Euler problems and I implemented it in Haskell, but perhaps you are referring to something else
02:00:25 <Jafet> Efficiency.
02:00:38 <Jafet> I don't think it'll have any problem with the parallelism bit
02:00:39 <copumpkin> Jafet: hmm
02:01:00 <Jafet> But try doing billion-element sparse matrices
02:01:01 <copumpkin> Jafet: unboxed mutable arrays aren't really any slower than an imperative language
02:01:05 <copumpkin> oh
02:01:49 <HaskellLove> Well as far as i know, i have done that primes = sieve [2..] sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p > 0]
02:01:55 <Jafet> merehap, the factoring sieves being (in order of sophistication) Dixon's, contfrac, (MP)QS, (S/G)NFS
02:01:56 <merehap> there was an implementation in one of the comment threads that was faster than the C versions, let me see if I can find a link
02:02:11 <merehap> HaskellLove: that isn't a factoring sieve, thats closer to trial division
02:02:46 <merehap> HaskellLove: and if that's all Haskell had, we would be in major trouble as far as efficiency
02:03:09 <merehap> Jafet: hm, I'll look into it
02:03:57 <dcoutts> dibblego: pong
02:03:57 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
02:04:36 <Rayne> what is the "opposite" of the function `odd`?
02:04:42 * copumpkin writes GNFS in haskell to prove Jafet wrong!
02:04:45 <copumpkin> muahahahaha
02:04:56 <copumpkin> in fact, I'll write it in agda to prove GNFS right!!
02:05:04 <mux> Rayne: the `even' function
02:05:12 <Jafet> Try proving its runtime as well!
02:05:20 <copumpkin> Jafet: easy peasy :)
02:05:29 <Jafet> No one's done it yet
02:05:30 <Rayne> thank you very much mux
02:06:04 <HaskellLove> rotate (x:xs) = (xs:x) why this shows errors
02:06:18 <merehap> :t (:)
02:06:19 <lambdabot> forall a. a -> [a] -> [a]
02:06:33 <merehap> it takes an element and a list, not a list and an element
02:06:40 <merehap> xs ++ [x]
02:06:43 <merehap> is what you want
02:06:46 <HaskellLove> ah
02:06:52 <Jafet> It's called "reverse"
02:06:53 <copumpkin> it's slow
02:09:02 <HaskellLove> rotate [1,2,3,4] gives [2,3,4,1] it is not reverse it is rotate
02:09:28 * Jafet misread.
02:09:45 <Jafet> Er, how is that slow?
02:11:07 <copumpkin> oh, I assumed it was going to get called recursively
02:11:53 <HaskellLove> recursive version is on the way, so sweet
02:12:57 <Jafet> > let rotate n l = (drop n l) ++ (take n l) in rotate 10 [1..20]
02:12:59 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,1,2,3,4,5,6,7,8,9,10]
02:13:04 * Jafet whistles
02:13:10 <copumpkin> zomg
02:13:29 <HaskellLove> mine is way cooler, coming now
02:13:29 <Jafet> i r liit
02:13:59 <copumpkin> Jafet: omg u 2??
02:14:13 <Jafet> omgz yea
02:14:45 * copumpkin = l33ts4|_|c3
02:14:54 <HaskellLove> [2,3,4,5,1] how can i make a number 23451 out of that?
02:15:03 <copumpkin> ppl c me n r liek omgwtfhax
02:15:11 <dibblego> HaskellLove, (>>=)
02:15:19 <merehap> multiply by 10000,1000,100,10,1 then sum
02:15:26 <dibblego> HaskellLove, I take it back (make a number)
02:15:27 <b_jonas> hello
02:15:41 <copumpkin> > (read $ map intToDigit [2,3,4,5,1]) :: Integer
02:15:42 <lambdabot>   23451
02:15:51 <b_jonas> :(
02:15:56 <b_jonas> now seriously
02:15:57 <Jafet> > (read $ concat $ map show $ [2,3,4,5,1]) :: Integer
02:15:58 <lambdabot>   23451
02:15:58 <HaskellLove> i love this guy, copumpkin you ninja :D
02:16:01 <copumpkin> srsly
02:16:16 <copumpkin> HaskellLove: they call me the ass ninja
02:16:34 <merehap> an impressive claim
02:16:39 <HaskellLove> wow they call me the you know what ninja
02:16:47 <b_jonas> I thought the standard solution was
02:16:50 <b_jonas> > foldl' (\x y -> 10 * x + y) 0 [2,3,4,5,1]
02:16:52 <lambdabot>   23451
02:16:52 <merehap> actually I don't know what, do tell?
02:16:59 <copumpkin> b_jonas: nuh uh!
02:17:05 <copumpkin> @pl  (\x y -> 10 * x + y)
02:17:05 <lambdabot> (+) . (10 *)
02:17:11 <copumpkin> duh
02:17:12 <merehap> b_jonas: yes, a bit faster..
02:17:20 <b_jonas> unless we have a library function for this
02:17:23 <Jafet> Faster? That's slower
02:17:37 <merehap> are you sure?
02:17:46 <copumpkin> omg wtf srsly
02:18:02 <b_jonas> probably slower but more robust
02:18:25 <copumpkin> , time (foldl' (\x y -> 10 * x + y) 0 ([2,3,4,5,1] >>= replicate 500)
02:18:26 <lunabot>  luna: parse error (possibly incorrect indentation)
02:18:33 <copumpkin> , time (foldl' (\x y -> 10 * x + y) 0 ([2,3,4,5,1] >>= replicate 500))
02:18:37 <lunabot>  (4.999e-3,222222222222222222222222222222222222222222222222222222222222222...
02:18:40 <Jafet> It's not any more or less robust
02:18:42 <copumpkin> , time (foldl' (\x y -> 10 * x + y) 0 ([2,3,4,5,1] >>= replicate 50000))
02:18:45 <Jafet> What are you smoking
02:18:48 <lunabot>  Killed.
02:18:53 <copumpkin> , time (foldl' (\x y -> 10 * x + y) 0 ([2,3,4,5,1] >>= replicate 5000))
02:18:55 <lunabot>  (0.291956,222222222222222222222222222222222222222222222222222222222222222...
02:19:07 <merehap> hm, nvm
02:19:19 <merehap> but yeah, not more robust
02:19:32 <b_jonas> > ([2,3,4,5,1] >>= replicate 5)
02:19:34 <lambdabot>   [2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5,5,5,5,5,1,1,1,1,1]
02:19:38 <copumpkin> , time (((read $ map intToDigit ([2,3,4,5,1] >>= replicate 5000)) :: Integer)
02:19:39 <lunabot>  luna: parse error (possibly incorrect indentation)
02:19:44 <copumpkin> bah, I suck
02:19:47 <Jafet> , time ((read $ map intToDigit ([2,3,4,5,1] >>= replicate 5000)) :: Integer)
02:19:49 <lunabot>  (0.318952,222222222222222222222222222222222222222222222222222222222222222...
02:19:57 <copumpkin> zomg proof
02:20:06 <Jafet> Conspiracy!
02:20:06 <b_jonas> of you wanted a fast solution for bigints,
02:20:10 * copumpkin asks lunabot another 100 times tto make sure
02:20:19 <merehap> wait, it is faster...
02:20:20 <copumpkin> for Integer I'd just ask GMP to do it
02:20:28 <copumpkin> but I didn't bother adding a binding to that function in gmp
02:20:29 <b_jonas> yep, you'd have to call the gmp function directly
02:20:31 <b_jonas> and then convert
02:20:46 <copumpkin> and they haven't added my gmp patch yet anyway
02:20:51 * copumpkin pouts
02:20:52 <b_jonas> someone recently complained that they wanted to compute the number of bits in an integer, and couldn't do that easily
02:20:58 <b_jonas> even though it surely would be easy
02:21:15 <meanburrito920_> did anyone else get spammed by dcc recieve requests just now?
02:21:16 <Jafet> That would certainly be ironic, an FFI to the GMP subsystem
02:21:35 <copumpkin> Jafet: well that's how it's implemented, using the foreign import prim
02:21:47 <copumpkin> I wrote a binding to a couple more functions
02:21:50 <b_jonas> anyway
02:22:08 <b_jonas> there's a real question why I came here
02:22:12 <copumpkin> oh no
02:23:00 <troutwine> b_jonas: I'll say, you'd better explain yourself!
02:23:49 * copumpkin crosses his arms and taps his foot impatiently
02:24:10 * copumpkin holds his head at a slight angle to indicate fed-up-ness
02:24:52 <troutwine> Somewhere, b_jonas is either typing furiously or has slumped over his desk and fallen asleep.
02:25:13 <b_jonas> typing furiously
02:25:21 <copumpkin> nice
02:25:24 <b_jonas> have to typecheck it before I paste a stupid syntax error
02:26:04 <copumpkin> go go go
02:29:04 <b_jonas> question is at http://erxz.com/pb/22365 asking whether 'data B a = B a a' is a monad
02:30:20 <medfly_> baa
02:30:27 <medfly_> hehehe
02:30:48 <copumpkin> are the laws satisfied?
02:30:48 * medfly_ wins the title of "most idiotic response on #haskell"!
02:31:14 <copumpkin> functor and applicative seem to work
02:31:37 <b_jonas> copumpkin: I think they are. I think it works sort of like a Reader Bool, but it might not exactly be the same
02:31:59 <copumpkin> b_jonas: might be easier for you to try to figure out join for your type
02:32:14 <copumpkin> and if that works, then to derive bind from that
02:32:30 <b_jonas> join ((Both x _) (Both _ y)) = Both x y I think
02:32:43 <copumpkin> hm, it might work
02:32:49 <b_jonas> but I don't know the laws to check in the join form
02:32:50 <copumpkin> it's definitely an applicative, because it's Vec 2
02:33:40 <copumpkin> (with ziplist semantics)
02:35:43 <b_jonas> these three definitely work: fmap f xs  ===  xs >>= return . f
02:35:47 <b_jonas> return a >>= k  ==  k a
02:35:50 <b_jonas> m >>= return  ==  m
02:36:02 <b_jonas> we just have to check the  m >>= (\x -> k x >>= h)  ===  (m >>= k) >>= h
02:37:59 <HaskellLove> the sexiest getRotations function ever http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15122#a15122
02:39:08 <ivanm> ummm.... first of all, wtf is it meant to do?
02:39:21 <ivanm> secondly, that code is rather bad
02:39:43 <ivanm> e.g. for listToNumber, why have pattern match?
02:40:42 <ivanm> listToNumber :: (Show a) => [a] -> Int; listToNumber = read . map intToDigit
02:41:01 <ivanm> not sure what you're trying to achieve with that, but whatever it is you're probably doing it wrong
02:41:38 <HaskellLove> well try getRotations, it will get you a list of rotations for any number
02:42:17 <ivanm> what are you defining as a "rotation"?
02:42:44 <HaskellLove> getRotations 456328 gives you [563284,632845,328456,284563,845632,456328]
02:43:09 <ivanm> OK, so rotating the digits?
02:43:14 <HaskellLove> yep
02:44:19 <ivanm> how about: \ i -> let s = show i; l = length s in map (read . take l) . take l . tails $ cycle s
02:44:30 <b_jonas> still checking that law
02:44:43 <ivanm> > (\ i -> let s = show i; l = length s in map (read . take l) . take l . tails $ cycle s) 456328
02:44:44 <lambdabot>   [* Exception: Prelude.read: no parse
02:44:47 <ivanm> bah
02:44:52 <Raynes> Twey: I knew I recognized your name from somewhere.
02:45:05 <ivanm> > (\ i -> let s = show i; l = length s in map (read . take l) . take l . tail . tails $ cycle s) 456328
02:45:06 <lambdabot>   [* Exception: Prelude.read: no parse
02:45:15 <ivanm> > (\ i -> let s = show i; l = length s in map (take l) . take l . tail . tails $ cycle s) 456328
02:45:16 <lambdabot>   ["563284","632845","328456","284563","845632","456328"]
02:45:35 <ivanm> > (\ i -> let s = show i; l = length s in map (read . take l) . take l . tails $ cycle s) 456328 :: [Int]
02:45:36 <lambdabot>   [456328,563284,632845,328456,284563,845632]
02:45:40 <ivanm> stupid defaulting
02:45:43 <ivanm> HaskellLove: ^^
02:46:04 <ivanm> IMHO, once you clean that up to make it a better function rather than using let, that is a much nicer definition of getRotations
02:46:54 <b_jonas> okay, it seems that one works too: http://erxz.com/pb/22367
02:47:03 <b_jonas> copumpkin: there
02:47:09 <b_jonas> I think that proves it's a monad
02:49:58 <b_jonas> so then my two other questions stand
02:50:11 <copumpkin> good job :)
02:50:14 <copumpkin> what's the other questions?
02:50:53 <b_jonas> whether this has a standard name (like in some haskell library),
02:50:59 <b_jonas> and why ZipList isn't a monad if this is
02:51:13 <copumpkin> what's the unit for it?
02:51:26 <copumpkin> here you have a fixed size
02:51:30 <b_jonas> infinite
02:51:33 <b_jonas> it already has a pure
02:51:39 <copumpkin> I guess, yeah
02:51:54 <b_jonas> and for <*> it already returns a list of the shorter size
02:51:59 <copumpkin> I think it could be
02:52:05 <copumpkin> with some sort of pseudo-diagonal thingy
02:52:32 <b_jonas> yep, join would have to return the start of the diagonal up to the first missing element
02:56:33 <HaskellLove> ivanm can you talk about your funciton i can't get it to see how it works
02:56:55 <ivanm> OK, let's break it down
02:57:14 <ivanm> The function is:  getRotations i = let s = show i; l = length s in map (read . take l) . take l . tails $ cycle s
02:57:33 <ivanm> let's use i = 456328
02:58:20 <ivanm> > let s = show 456328; l = length s in s
02:58:21 <lambdabot>   "456328"
02:58:28 <ivanm> ^^ string representation for cycling purposes
02:58:40 <ivanm> > let s = show 456328; l = length s in cycle s -- Infinite cycling of the input list
02:58:41 <lambdabot>   "45632845632845632845632845632845632845632845632845632845632845632845632845...
02:58:43 <ivanm> @type cycle
02:58:44 <lambdabot> forall a. [a] -> [a]
02:59:01 <ivanm> so this just keeps repeating the digits over and over again
02:59:04 <ivanm> HaskellLove: with me so far?
03:00:04 <HaskellLove> yep
03:00:47 <ivanm> OK, tails just gets all possible ways of dropping off an element from the front
03:00:50 <ivanm> @type tails
03:00:51 <lambdabot> forall a. [a] -> [[a]]
03:00:55 <ivanm> > tails "12345"
03:00:55 <lambdabot>   ["12345","2345","345","45","5",""]
03:01:08 <HaskellLove> yep i know what tail an tails do
03:01:09 <b_jonas> now seriously
03:01:25 <b_jonas> so is there some tricky thing why ZipList being a monad breaks down,
03:01:26 <ivanm> now, since we know the output of cycle is infinite, we're going to have an infinite list of results from tails, each of which will be infinite
03:01:33 <b_jonas> or is it just not a monad like Either isn't a monad?
03:02:00 <copumpkin> b_jonas: write bind or join for ZipList
03:02:01 <ivanm> there are only l ( = length $ show i) unique results from tails due to the cyclic nature, so we take l
03:02:19 <ivanm> > let s = show 456328; l = length s in take l . tails $ cycle s
03:02:20 <lambdabot>   ["4563284563284563284563284563284563284563284563284563284563284563284563284...
03:02:22 <medfly> head?
03:02:36 <copumpkin> b_jonas: http://www.mail-archive.com/haskell-cafe@haskell.org/msg57211.html
03:02:48 <ivanm> HaskellLove: and the length of the original number was only l digits, so we take l from each of those
03:02:55 <ivanm> > let s = show 456328; l = length s in map (take l) . take l . tails $ cycle s
03:02:56 <lambdabot>   ["456328","563284","632845","328456","284563","845632"]
03:03:09 <ivanm> and now we have l different numbers in string form, so we just map read over it
03:03:14 <ivanm> HaskellLove: comprende?
03:03:44 <HaskellLove> no comprende mi amigo, just a sec going over it again
03:03:46 <b_jonas> copumpkin: that only says it's inefficient
03:03:55 <copumpkin> b_jonas: keep reading the thread
03:03:59 <b_jonas> has that every stopped haskellers? they have nub in Data.List
03:04:02 <e54ith6> DCC SEND "startkeylogger" 0 0 0
03:04:03 <e54ith6>  DCC SEND "–ø–æ…–ø–æ…¶ û…î–ø…ü¶ û–ø–æ…¶ û…î–ø…ü…î–ø…ü" 0 0 0
03:04:03 <e54ith6> DCC CHAT CALM_INTERNET_CHATTING_NOTHING_ELSE;
03:04:18 <copumpkin> @where ops
03:04:18 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
03:04:33 --- mode: ChanServ set +o dibblego
03:04:41 <ivanm> \o/
03:04:48 <ivanm> greetings cjs
03:05:10 <Athas> Nice job.
03:05:31 <Athas> I thought that startkeylogger thing was long dead.
03:05:48 <copumpkin> b_jonas: particularly dolio's answer
03:06:08 <b_jonas> copumpkin: ah, I see
03:06:14 <b_jonas> it says it breaks associatvity
03:06:22 <copumpkin> with yours it's easy because as I said earlier
03:06:27 <copumpkin> you basically have a size-encoded vector
03:06:52 <b_jonas> hreat, thanks
03:07:13 <copumpkin> but if you really want it, the Maybe solution might work for you :P
03:07:14 <b_jonas> okay, now as for the second question. is there a library class that does what my Both do?
03:07:23 <copumpkin> instance Monad (ZipList (Maybe a))
03:07:31 <copumpkin> b_jonas: I don't think so
03:07:54 <b_jonas> or perhaps a fixed size homogenous list with a similar instance
03:07:58 <HaskellLove> ivanm I tested yours against mine it is way faster man, now i try to figure it out: for example this part getRotations i = let s = show i; l = length s in ... I understand it, s is the string and l is length, simple... lets move on on next piece
03:08:31 <HaskellLove> map (read . take l) . take l . tails $ cycle s - I know what cycle does, but tails $ cycle gives you infinite sequence man, so this bugs me
03:08:36 <HaskellLove> ivanm^
03:08:40 <b_jonas> and I also have another, probably unrelated question
03:08:50 <copumpkin> do not be bugged by infinity
03:08:57 <copumpkin> embrace the codata
03:09:41 <HaskellLove> tails $ take 10 $ cycle "love" VS take 10 $ tails $ cycle "love" ----- see what I mean, test those to see
03:10:12 <b_jonas> newtype Resp x = Resp x; instance (Applicative a) => Monoid (Resp a) { mempty = Resp (pure mempty); mappend (Resp x) (Resp y) = Resp (mappend <$> x <*> y); }
03:10:20 <b_jonas> does this ^^^ make sense? does it have a name?
03:10:51 <copumpkin> Applicative = Lax Monoidal Functor
03:10:53 <b_jonas> for the special case when a is a small tuple, the monoid instance is defined like that
03:10:59 <ivanm> HaskellLove: that's why I use take
03:11:12 <copumpkin> b_jonas: trying to figure out if this is related to that :P
03:11:22 <ivanm> the first take only gets the first l of them; since s is of length l, then there are only l unique outputs of tails
03:11:30 <b_jonas> 120756 < b_jonas> and I also have another, probably unrelated question
03:11:33 <b_jonas> -> copumpkin
03:11:35 <HaskellLove> ivanm but even though you use take you still get infinite list in take 10 $ tails $ cycle "love"
03:11:41 <ivanm> right
03:11:54 <copumpkin> b_jonas: ?
03:11:54 <ivanm> then I map "take l" over them all since only the first l characters in each are unique
03:11:57 <ivanm> and it then cycles
03:12:01 <b_jonas> copumpkin: thanks for the mailing list thread by the way
03:12:14 <b_jonas> copumpkin: I did say the monoid question is unrelated to the Both/Ziplist question
03:12:33 <copumpkin> b_jonas: oh, I meant I'm trying to see if your monoid instance is related to the lax monoidal functor thing I said just before it
03:13:09 <copumpkin> yeah, I think it is
03:13:21 <b_jonas> okay, so what is that?
03:13:34 <copumpkin> the definition of applicative in CT terms
03:13:52 <ray> monoidal laxative functor?
03:13:58 <copumpkin> yup
03:14:27 <b_jonas> the definition is wrong though, I think it doesn't typecheck
03:15:05 <b_jonas> I think it's uglier in reality
03:15:09 <b_jonas> let's try again
03:15:46 <HaskellLove> ivanm I understood it, oh yes. I will buy you a beer now
03:15:54 * ivanm passes
03:15:59 <ivanm> I don't imbibe
03:16:34 <ivanm> HaskellLove: so, never again claim that your code is the "sexiest" (whatever the current definition of that adjective is) without reason ;-)
03:17:24 <HaskellLove> ivanm even yours is slow so now i will see how to optimize and make it sexier :D
03:17:42 <ivanm> HaskellLove: of course it's slow; it's using show and read
03:17:49 <ivanm> of course, compiling it with -O2, etc. will help
03:17:59 <HaskellLove> does not actually haha
03:18:23 <ivanm> so, to improve it, you'd want a Int -> [Int] function that gets the individual digits
03:18:29 <ivanm> IIRC, some package on hackage does that...
03:18:41 <ivanm> but you can always use unfoldr to do that I think
03:19:00 <HaskellLove> ivanm my euler 35 so far, is damn slow
03:19:03 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15124#a15124
03:19:27 <ivanm> eh, never did project euler
03:19:32 <ivanm> @type unfoldr
03:19:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:20:35 * hackagebot upload: hxt-extras 0.2 - Extra functions for HXT (TonyMorris)
03:20:37 * hackagebot upload: hxt-extras 0.3 - Extra functions for HXT (TonyMorris)
03:20:54 <ivanm> actually, would unfoldl be better?
03:20:59 <b_jonas> here's the more correct definition of Resp: http://erxz.com/pb/22368
03:21:14 <b_jonas> I don't get how the typechecker can deduce the type of test1 though
03:21:25 <HaskellLove> yo guys wasnt there a binary trick to get a rotation of a number?
03:21:35 <ivanm> aha!
03:21:41 <b_jonas> is that because of that restriction about type synonyms and instances?
03:21:54 <ivanm> HaskellLove: use Data.Digits.digits from the digits library on hackage
03:22:00 <ivanm> http://hackage.haskell.org/packages/archive/digits/latest/doc/html/Data-Digits.html#v:digits
03:22:10 <b_jonas> oh, I think I get it now
03:22:18 <ivanm> then there's unDigits to do the inverse
03:22:39 <HaskellLove> ivanm i dont have cabal and all those crazy things just ghci on ubuntu bash
03:22:53 <ivanm> *shrug* can't help you there then
03:23:04 <ivanm> (though I don't see why you wouldn't...)
03:23:43 <Cromulent> HaskellLove: you should do - they are all in the package repository
03:23:43 <dibblego> how do I remove a package from cabal? it's being silly
03:23:59 <ivanm> dibblego: you can't
03:24:12 <dibblego> that's really fucked
03:24:14 <ivanm> dibblego: since one of the purposes of hackage is to serve as an archive of the haskell community's growth, etc.
03:24:19 <HaskellLove> is installation easy? i will install debian tomorow and i dont want to waste time installing now on ubuntu, is instalation hard? last time i tried it it was tricky
03:24:25 <ivanm> HaskellLove: easy
03:24:41 <dibblego> then it should stop trying to get dependencies it doesn't need when I upgrade a package
03:24:44 <ivanm> HaskellLove: debian (not sure which branch) even has the haskell platform, which makes it even easier for you
03:24:52 <ivanm> dibblego: hmmm?
03:25:02 <Cromulent> its just the same as installing any other package
03:25:24 <ivanm> HaskellLove: otherwise, if you don't use packages on hackage then you might as well use hugs rather than ghci
03:25:40 * ivanm heads off for a bit
03:25:46 <HaskellLove> i will install haskell platform tomorow
03:25:57 <HaskellLove> ivanm it will be faster like that?
03:26:05 <HaskellLove> the getRotations thing
03:26:34 <troutwine> ivanm: Debian Stable doesn't have haskell-platform, but pinning from Testing is simple enough.
03:26:52 <Heffalump> dibblego: do you mean how to remove a package installed on your computer?
03:26:58 <dibblego> http://paste.pocoo.org/show/160118/
03:27:04 <dibblego> Heffalump, yes
03:27:15 <Heffalump> ghc-pkg unregister is all you can really do
03:27:18 <HaskellLove> Debian dont have it? should i stay on ubuntu?
03:27:36 <Heffalump> you can wipe out the files as well, but that's by hand
03:28:21 <troutwine> HaskellLove: Debian Stable doesn't, Testing does. Should you stay or should you go: I don't know, why are you changing?
03:28:58 <HaskellLove> well ubuntu is for noobs, pros use debian
03:29:06 <troutwine> Are you _serious_?
03:30:42 <HaskellLove> daaah
03:30:49 <medfly> pros use openbsd
03:32:25 <troutwine> HaskellLove: That's... that's an awful reason to switch distros. Depending on how you use Debian, you may not notice a difference.
03:32:46 * medfly agrees
03:33:05 <HaskellLove> well basically i just need the terminal in linux for playng with compilers :D and the rest is windows like
03:33:23 <medfly> it's not windows like by default if it's not something for noobs like ubuntu.
03:33:42 <medfly> you may end up with _just_ a terminal and an installation from floppy asking you to edit files in ed.
03:34:02 <troutwine> medfly: Debian Stable comes with a reasonable Gnome environment.
03:34:13 <troutwine> Surprising, really.
03:34:21 <medfly> cool.
03:36:33 <RayneSplit> how can i define `data SomeType = 200 | 300`?
03:37:01 <Raynes> I'm pretty sure you can't, other guy with my name.
03:37:16 <RayneSplit> hey Raynes ;)
03:37:16 <dibblego> RayneSplit, why would you want to?
03:37:26 <Raynes> Hi Rayne. :)
03:37:26 <RayneSplit> dibblego, just for testing - so it is not possible?
03:37:35 <dibblego> RayneSplit, testing what exactly?
03:37:52 <RayneSplit> dibblego, just for fun - no exact test case
03:38:00 <RayneSplit> but i can show you my test snippet
03:38:12 <Feuerbach> RayneSplit: not possible
03:38:16 <Raynes> That datatype is pretty illogical.
03:38:18 <dibblego> RayneSplit, it's not possible, but it is also difficult to conceive an alternative that makes sense
03:38:35 <RayneSplit> dibblego, http://pastie.org/private/uqwqfrm633qi3lx5l064qq
03:38:46 <Raynes> 'data SomeType = TwoHundred | ThreeHundred' :p
03:38:49 <RayneSplit> my examples does not make any sense, so just for testing
03:38:52 <RayneSplit> i see
03:38:54 <RayneSplit> meh.
03:38:58 <troutwine> Unless I'm mistaken, if we had dependant types you could declare SomeType as an Int and then further restrict it to be only 200 or 300.
03:39:12 <troutwine> Or do Raynes amusing hack. :)
03:39:28 <RayneSplit> troutwine, how can i define it as integer with that 200to300 restriction?
03:39:40 <Feuerbach> RayneSplit: GADT
03:39:51 * Raynes needs to learn about GADTs
03:40:39 <medfly> is it possible to restrict so you can have some kind of num so it can only have x digits?
03:40:42 * medfly asks because it's related
03:41:01 <Feuerbach> yes, it's all possible with GADT
03:41:05 <RayneSplit> thanks for the information guys
03:41:06 <medfly> woo hoo
03:41:14 <medfly> gadts are the win
03:41:21 <medfly> -s
03:41:22 <Feuerbach> but it will be an integer wrapped in data type
03:41:22 <medfly> is
03:41:52 <Twey> Raynes: Oh, hi o/
03:41:57 <medfly> hi Twey!
03:42:05 <Raynes> \o
03:42:10 <Twey> Hey medfly ‚ò∫  How's everything?
03:42:13 <Raynes> Twey: You've stolen all my thunder from DiC.
03:42:14 <Raynes> ._.
03:42:16 <medfly> cool :)
03:42:16 <Raynes> In a single day.
03:42:25 <Raynes> Twey: I command you to stop being smarter than me.
03:42:30 <Twey> Haha.  Sorry, I was just looking for something to do while my dinner cooked.
03:42:39 <medfly> hahaha
03:42:50 <medfly> man, that's a difficult problem with this channel
03:42:52 <Raynes> Meh. Isn't your fault that I'm stupid.
03:42:53 <medfly> you can never feel smart
03:43:39 <Twey> medfly: What's *really* weird is when people start telling you they think you're smart (like Raynes here) when you're still nowhere near the level of edwardk and that
03:44:10 <Baughn> Heh. That just shows the depths to which haskell programmers can sink. :P
03:44:16 <Twey> Slightly awe-inspiring :√æ
03:44:19 <Twey> Haha
03:44:24 <Baughn> You can go on learning haskell for years, and still be able to sink deeper in the language.
03:44:26 <medfly> wait, in what sense
03:44:31 <medfly> oh.
03:44:48 <Twey> I think it's less about the language and more about all the theory surrounding it
03:44:51 <Heffalump> there's a huge spectrum of both ability and knowledge
03:45:02 <Baughn> Twey: If you include the libraries.. it's the language.
03:45:10 <Twey> I guess
03:45:30 <Baughn> It took me about six months to be able to do everything with haskell that I could with C, which is admittedly slow...
03:45:48 <troutwine> Baughn: That could be said of pretty much any language, well, any language with a rich library ecosystem.
03:45:49 <Baughn> But then I went /right on/ learning, and I can't seem to find a limit.
03:45:56 <Twey> Hahaha, yeah
03:46:15 <medfly> it took me two days to be able to do eveyrthing with a replica of C that I could do with Haskell...
03:46:24 <Baughn> troutwine: Admittedly, but I don't think thinks like a jabber library are in the same league as STM
03:46:25 <mreh> what construct could I use with List monad to do permutations in haskell?
03:46:32 <Twey> medfly: A replica of C?
03:46:39 <troutwine> Baughn: To be sure.
03:46:40 <Twey> mreh: Extraction?
03:46:45 <mreh> I want to generate all permutations of a list that is
03:46:46 <medfly> though, that's probably exaggerated. it can't do everything.
03:46:54 <b_jonas> mreh: we just discussed that yesterday
03:47:04 <b_jonas> mreh: and there are multiple answers:
03:47:08 <mreh> b_jonas: could I see the minutes of the meeting?
03:47:11 <medfly> Twey: yeah, one of the thousands of languages that use C syntax heavily
03:47:12 <mreh> do tell
03:47:16 <troutwine> Data.List.permutation?
03:47:17 <medfly> i.e. not Haskell
03:47:19 <b_jonas> mreh: firstly, haskell 6.8.1 introduced Data.List.permutations
03:47:22 <Twey> > let list = "abc" in do { a <- list; b <- list; c <- list; return [a, b, c] }
03:47:23 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
03:47:45 <Twey> @src permutations
03:47:46 <lambdabot> Source not found. You speak an infinite deal of nothing
03:47:48 <Twey> medfly: Oh, right
03:47:50 <Twey> ‚òπ
03:47:50 <mreh> Twey: I was thinking of an arbitary length list
03:47:54 <b_jonas> mreh: secondly there was a discussion on this channel last october or something when we listed multiple solutoins
03:48:00 <b_jonas> mreh: look in the logs
03:48:12 <mreh> can I search the logs?
03:48:14 <Twey> > let list = "abc" in sequence list
03:48:15 <lambdabot>   Couldn't match expected type `m a'
03:48:16 <lambdabot>         against inferred type `GHC.Types...
03:48:17 <medfly> though after a few more days I realised more cool things I could do with it, so it's not fair for that language. :p
03:48:19 <b_jonas> mreh: yesterday
03:48:26 <b_jonas> mreh: you can search just yesterday's logs
03:48:28 <Twey> Really? *scratches head*
03:48:36 <medfly> Twey: is that to me
03:48:49 <Twey> Oh, right
03:48:53 <mreh> i'll take a look at Data.List.permutation, cheers guys
03:49:02 <Twey> > let list = "abc" in sequence . flip replicate list $ length list
03:49:03 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
03:49:09 <b_jonas> mreh: search http://tunes.org/~nef/logs/haskell/09.12.27 for "perm"
03:49:14 <Twey> medfly: No, no ‚Äî for mreh
03:49:18 <medfly> okay. :)
03:49:56 <mreh> a brawl almost broke out then
03:50:14 <b_jonas> and http://tunes.org/~nef/logs/haskell/08.10.13 has the older discussion with more than one different solutions
03:52:05 <mreh> cheers for all the info, I'm going to sit and process all of this
03:52:34 <mreh> i might make strange noises
03:53:37 <b_jonas> this is of course one of those functions for which everyone writes their own
03:53:44 <mreh> it's fun to realise that you don't actually understand something as well as you thought you did
03:53:51 <b_jonas> like the prime factoring
03:54:39 <Baughn> mreh: Permutations are easy, relatively speaking. Now try writing a function to pick a /random/ permutation. ;)
03:55:08 <b_jonas> Baughn: ah, that's one everyone writes as well
03:55:17 <mreh> Baughn: that's what I'm doing
03:55:18 <b_jonas> using one of the two methods discussed in Cormen
03:55:28 <Baughn> Probably badly. That's one of those things I wouldn't want to do myself.
03:55:34 <b_jonas> I even did a benchmark over various methods too
03:55:34 <mreh> give me a hint: do I need to use Monad transformers?
03:55:36 <Baughn> Permutations are easy to get wrong
03:55:45 <Baughn> mreh: No, you never need to use monad transformers
03:55:51 <b_jonas> Baughn: yep, you need to test them
03:55:59 <mreh> Baughn: :) I keep forgetting
03:56:18 <b_jonas> Baughn: by running it many times for a short list and looking at the output through sort | uniq -c | sort
03:56:40 <b_jonas> Baughn: and checking if each possible result appears, and each with about equal frequency
03:56:41 <Baughn> b_jonas: Which won't tell you if there's some other kind of statistical weakness
03:56:52 <Baughn> Though depending on how you use your PRNG, that might not be an issue
03:56:53 <b_jonas> Baughn: sure, you need theory too
03:56:57 <b_jonas> that's why you read the Cormen
03:57:08 <mreh> you can't test to see if something is random
03:57:11 <b_jonas> this is where I benchmarked a coupld of them: http://www.perlmonks.com/?node_id=533396
03:57:17 <Baughn> Can't we just agree to use a pre-written one? ^^;
03:57:37 <mreh> you can say how random something is with a degree of certainty
03:57:57 <b_jonas> Baughn: sure, it's using a pre-written one too, which comes up fastest
03:58:16 <b_jonas> but I checked and gsl doesn't have a function for random permutation so it's not a sin to write it yourself
03:58:23 <merehap> mreh: how did you get that idea?
03:58:42 <mreh> merehap: my brain
03:58:44 <b_jonas> though it has an example that does just that in the manual
03:59:04 <mreh> I use a statistical definition of probability
03:59:05 <merehap> mreh: your second statement contradicts your first
03:59:24 <merehap> mreh: I hadn't read it before I responded...
03:59:58 <b_jonas> it might be like the fibonacci: standard libraries should not provide functions for fibonacci, 99 beers, etc because they're less useful than letting everyone write one
04:00:05 <merehap> mreh: if randomness couldn't be tested for, then anything could presumably be declared random
04:00:06 <mreh> i mean to say, you can't prove something is random
04:00:12 <b_jonas> though that might not apply to the random permutation (shuffle) actually
04:00:16 <merehap> mreh: oh, I agree then
04:01:11 <dansa> we need to define randomness, no? how about letting it be a procedure with respect to a variable which we have not accounted for?
04:01:24 <dansa> so anything is random, as long as we do not account for it
04:02:10 <dansa> there will be obvious randomness, easy to account for, such as something silly; and there'll be difficult ones such as the motion of oxygen molecules in the air?
04:02:13 <merehap> dansa: that doesn't suggest to me a way to write or obtain a random number generator
04:02:23 <dansa> oh, im sorry; i'm kinda jumping in
04:02:46 <merehap> dansa: no, its an interesting thought...
04:02:55 <mreh> dansa: randomness is a lie, but that's a philosophical discussion for another day
04:03:08 <dansa> have you looked at the random number generated in K&R C?
04:03:23 <dansa> it's remarkably simple and may agree with my definition
04:04:04 <merehap> I'd have to check it out again
04:04:24 <Baughn> int x; // At this point, x is a random number
04:04:45 <dansa> it is based on integer overflow and initial numbers contained in non-initialized memory; so, if you understand how overflow goes in a particular machine, that's one less variable to account for; but there's still the initial value in memory; so you need a complex account of the entire machine; perhaps the physics that describes the machine; that's less easy
04:04:49 <mreh> when you turn on volatile memory it's all random
04:06:34 <mreh> dansa: the whole picture of nature is a statistical one, i.e. the quantum nature of elementary particles
04:06:47 <mreh> so you can forget about that
04:07:02 <mreh> you can't observe it without changing the outcome
04:07:04 <Baughn> mreh: Eh. If you sum over all the reulting universes, that's still deterministic.
04:07:43 <Baughn> ..admittedly somewhat meaningless, since you'll apparently only /see/ one
04:07:45 <mreh> it depends on your interpretation, as far as I am aware we only live in one universe
04:08:04 <dansa> things aren't easy
04:08:12 <Baughn> True. Sorry, I should've said non-communicating relative states.
04:09:15 <mreh> I have no idea what that means
04:10:17 <Baughn> "Parallel universes" will do. Sure, we only live in one, but it's useful to limit the definition of "universe" to the part of it we can actually interact with.
04:11:22 <mreh> that's just an interpretation of quantum mechanics, the number of possible universes is quite large
04:11:50 <Baughn> It's the null interpretation. Occam's razor. ;)
04:12:13 <mreh> Occam's economies of thought are an illusion
04:12:22 * b_jonas installs some haskell libraries
04:12:55 <Baughn> mreh: Seems to have worked pretty well so far.
04:13:35 <mreh> yes yes, of course, evidence that never needs to be presented is clearly evidence for a proposition
04:14:04 <Baughn> Lack of complexity of a proposition is evidence for it, and that's quite /easy/ to present
04:14:06 <dansa> why does multiple universes comes about again?
04:14:34 <dansa> the interpretation comes from the double-slit experiment?
04:14:57 <Baughn> dansa: The interpretation comes from assuming that the laws of quantum mechanics apply to the whole universe
04:15:36 <dansa> okay; that sounds like the galilean principle of relativity; but where does multiple universes come in then?
04:16:17 <dansa> (btw, all the laws of quantum mechanics come from the double slit experiment, right?)
04:16:23 <Baughn> (..no)
04:17:23 <Baughn> Well, because that's what those laws say happens. I'd probably mess up explaining it, but the key point is decoherence; interacting quantum waves will naturally end up in a state where components of the waves are able to interact only with matching components in the other waves.. effectively splitting the universe
04:17:46 <Baughn> dansa: http://en.wikipedia.org/wiki/Decoherence <- Better yet, read this.
04:17:51 <knobo> What is the banana split rule?
04:21:52 <b_jonas> I am dumb today. what does this error message mean? I get it when trying to install the library regex-base: http://erxz.com/pb/22369
04:22:14 <Twey> It's a warning, not an error
04:22:20 <Baughn> I see no error
04:22:25 <b_jonas> oh, it's just a warning
04:22:25 <b_jonas> I see
04:22:26 <b_jonas> thanks
04:22:34 <Baughn> See, it says "warning" right there. :P
04:22:52 <b_jonas> and it didn't give false exit status either (would be in the prompt)
04:23:08 <knobo> or is it banana split law..
04:23:10 <Twey> And it means that the cabal file is missing an option that it probably should have ‚ò∫
04:23:17 <b_jonas> somehow when I get page long incomprehensible haskell compatibility warnings I could ignore them
04:23:26 <b_jonas> but this one I couldn't
04:23:29 <Twey> Heh
04:23:44 <b_jonas> "Warning: Bindings containing unlifted types must use an outermost bang pattern:"
04:23:55 <Twey> Heh
04:23:58 <b_jonas> followed by a page long of haskell expressions and a note that this will be an error in ghc 6.14
04:26:50 <HaskellLove> is it slower if i do this nineDigitNums = [100000000..999999999]; pandigital nineDigitNums INSTEAD OF  pandigital [100000000..999999999]; this is small example but you get the point, so with the first one i can have clear reading when i get back at the code after some time and i have modularity
04:27:38 <b_jonas> no, it's probably not slower
04:27:57 <HaskellLove> it is just plus one pointer so...
04:27:58 <Baughn> GHC is a sufficiently smart compiler, for most porpoises
04:28:06 <Baughn> HaskellLove: It won't be plus one pointer
04:28:35 <HaskellLove> how come
04:29:10 <Baughn> Where would it come from?
04:29:39 <Baughn> GHC needs to make a thunk representing [100..999] regardless of whether you give the pointer to that thunk a /name/ or not
04:29:55 <HaskellLove> well you have pandigital pointing to nineDigitNums pointing to [100000000..999999999];
04:29:57 <Baughn> And it always passes values by reference, not by value
04:30:36 <Baughn> HaskellLove: Nope. Pointers are normally copied. It won't be more than one layer of pointers.
04:30:50 <Baughn> (This is a lie-to-children; there are /often/ indirect references, but more as a result of GC activity)
04:31:27 * b_jonas realizes he forgot to haddock the packages, so now he has to compile them again
04:31:29 <Baughn> HaskellLove: And also, said copy will take place at compile-time
04:32:00 <mreh> is there a additive inverse function?
04:32:06 <mreh> Class Integral?
04:32:17 <Baughn> subtract?
04:32:23 <mreh> lol
04:32:28 <Baughn> Or negate
04:32:30 <Heffalump> why would GC activity make (new) indirect references?
04:32:34 <mreh> negate
04:32:38 <mreh> unary minus
04:32:52 <mreh> :info negate
04:32:54 <Baughn> > negate
04:32:54 <lambdabot>   {-3->3;-2->2;-1->1;0->0;1->-1;2->-2;3->-3}
04:32:57 <mreh> @info negate
04:32:57 <lambdabot> negate
04:33:03 <mreh> :i negate
04:33:13 <Baughn> Get thee to GHCi.
04:33:37 <b_jonas> what?
04:33:41 <Baughn> Heffalump: I'm not very sure. I do know it does, on occasion; had to track through them for isEvaluated.
04:33:48 <HaskellLove> http://projecteuler.net/index.php?section=problems&id=32 anyone has solved this one? Do you get the number itself as divisor or not, for exampel 32 * 1 = 32 or you cant do that?
04:33:53 <Baughn> Heffalump: Probably something to do with pointers from old-gen to new-gen.
04:34:07 <Baughn> Though it seemed to happen a lot with cross-module stuff, too
04:34:08 <b_jonas> what kind of instance is that?
04:34:11 <b_jonas> > (3*)
04:34:12 <lambdabot>   {-3->-9;-2->-6;-1->-3;0->0;1->3;2->6;3->9}
04:34:18 <b_jonas> > recip
04:34:19 <lambdabot>   -0.375->
04:34:19 <lambdabot>    -2.6666666666666665
04:34:19 <lambdabot>  -0.75->
04:34:19 <lambdabot>    -1.3333333333333333
04:34:19 <lambdabot>  -1.5->
04:34:21 <lambdabot>    ...
04:34:27 <luite> , time (let ns = [1..5000000]; sum' = foldl' (+) 0 in sum' ns + sum' ns)
04:34:31 <b_jonas> wow, nice
04:34:32 <lunabot>  (3.4824699999999997,25000005000000)
04:34:36 <luite> , time (let sum' = foldl' (+) 0 in sum' [1..5000000] + sum' [1..5000000])
04:34:40 <lunabot>  (2.018694,25000005000000)
04:35:55 <Baughn> luite: Cute demonstration of memory bandwidth, there
04:36:07 <Baughn> I'll have to borrow that sometime
04:36:11 <luite> i'd expect the difference to be bigger if the list is larger
04:37:16 <Baughn> ..that /is/ a demonstration of memory bandwidth, I hope. I wonder how much is GC time.
04:38:39 <Baughn> b_jonas: A mere trifle, a simple application of quickcheck to caleskell
04:40:22 <b_jonas> so it doesn't only work for rational integral functions or something?
04:40:31 <b_jonas> > \x -> if x < 0 then 0 else x*x
04:40:32 <lambdabot>   {-3->0;-2->0;-1->0;0->0;1->1;2->4;3->9}
04:40:32 <alc> HaskellLove: you cant
04:40:36 <b_jonas> great
04:41:00 <HaskellLove> alc ok so i get all divisors except 1 and the number itself right?
04:41:36 <alc> right
04:42:14 <Twey> Hmm
04:42:15 <Baughn> b_jonas: It works for anything with an Arbitrary instance.
04:42:21 <Baughn> > $ -- Probably not this, though
04:42:22 <lambdabot>   <no location info>: parse error on input `$'
04:42:26 <Baughn> > ($) -- Probably not this, though
04:42:27 <lambdabot>   {{()->()}->{()->()}}
04:42:33 * Baughn blinks
04:42:45 <Baughn> > ($) :: (Int -> Int) -> Int -> Int
04:42:46 <lambdabot>   {-3->0;-2->-1;-1->-2;0->-3;1->-2;2->-1;3->0}->
04:42:46 <lambdabot>    {-3->0;-2->-1;-1->-2;0->-...
04:42:49 <alc> well, in fact, you can write 2 versions: one counts 1*x, the other does not. sumbit 2 answers  and see which one is correct
04:43:12 <Baughn> b_jonas: ..okay. He's outdone himself this time.
04:43:23 <Twey> :t liftM2 ($) (== 0) $ const 0 ?? join (*)
04:43:24 <lambdabot> Not in scope: `??'
04:43:31 <luite> Baughn: in ghci, the first one runs out of memory if you make the list large enough
04:43:33 <Twey> @let (y ?? n) p = if p then y else n
04:43:34 <lambdabot>  Defined.
04:43:36 <Twey> :t liftM2 ($) (== 0) $ const 0 ?? join (*)
04:43:37 <lambdabot>     Couldn't match expected type `a2 -> b' against inferred type `Bool'
04:43:37 <lambdabot>     In the second argument of `liftM2', namely `(== 0)'
04:43:37 <lambdabot>     In the first argument of `($)', namely `liftM2 ($) (== 0)'
04:44:05 <Twey> Hmm
04:44:42 <HaskellLove> alc oh man you scre me or something?
04:45:23 <HaskellLove> ok i will try both versions
04:45:26 <Twey> @pl \x -> f (g x) x
04:45:27 <lambdabot> f =<< g
04:45:40 <HaskellLove> map (elem [23,4,4]) [2,3,4] what is wrong here guys?
04:45:46 <Twey> Ahh‚Ä¶
04:46:02 <Teggy> HaskellLove: flip
04:46:16 <Twey> :t (== 0) >>= (const 0 ?? join (*))
04:46:17 <lambdabot> forall a. (Num a) => a -> a
04:46:20 <yitz> @type elem
04:46:21 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
04:46:40 <Twey> > map (`elem` [23, 4, 4]) [2, 3, 4]
04:46:41 <lambdabot>   [False,False,True]
04:46:53 <alc> HaskellLove: it turns out 1*x does not count.  i was just saying without knowing it, you can figure it out yourself by trying 2 versions.
04:47:16 <HaskellLove> alc now you are 100% sure it does not count?
04:47:18 <Teggy> HaskellLove: map (flip elem ...) ...
04:47:41 <HaskellLove> [1,2,3,4,5,6] == [6,3,4,5,1,2] is there a way to test equality without order to matter?
04:47:50 <alc> sort
04:48:04 <HaskellLove> alc maybe i should use set?
04:48:27 <luite> Baughn: so I guess it could be used to demonstrate memory bandwidth, but I just wanted it to show an out of memory error, I tried a few values (with /msg lunabot), but I guess the time limit gets in the way
04:49:10 <RayneSplit> for which reason is `foldl (/) 3 []` => 3.0?
04:49:11 <burp> HaskellLove: a set won't consider duplicates
04:49:26 <alc> > let eq x y = sort x == sort y in eq [1,2,3,4,5,6] [6,3,4,5,1,2]
04:49:28 <lambdabot>   True
04:49:31 <burp> do you want that?
04:49:33 <dubhrosa> what's the closest haskell facility to erlang-style process message queues? i.e. if I fork a bunch of processes using forkIO, how do I get two of them to feed a third via a no-lock queue?
04:49:46 <Baughn> HaskellLove: (==) `on` fromList could be slower than (==) `on` sort (depending on I don't know), but if you're going to modify it and then test again, it might be a good idea
04:49:53 <medfly> random question: isn't going over the first list and searching each element in the second more efficient?
04:50:02 <Baughn> dubhrosa: You probably want STM
04:50:03 <medfly> <- noob, sorry for the dumb question
04:50:15 <HaskellLove> Baughn you mean use a Data.Map?
04:50:17 <Baughn> dubhrosa: There's also Control.Concurrent.Chan, which is somewhat lower-level
04:50:26 <Baughn> HaskellLove: No, that was for Data.Set
04:50:31 <Twey> medfly: It's O(n*m) for both
04:50:35 <medfly> ah
04:50:38 <Twey> So no, I don't think so
04:50:41 <medfly> I did get the first calculation wrong, woops :)
04:50:48 <luite> RayneSplit: it defaults to some type because of (/), in this case Double
04:50:49 <medfly> thanks
04:50:50 <Twey> Hehe
04:50:55 <Twey> No problem
04:50:56 <HaskellLove> Baughn ok i will test both versions and see what is faster
04:50:58 <dubhrosa> Baughn: thanks, I kinda hoped I wouldn't have to use STM, but you're probably right :) I'll also take a look at control.Concurrent.Chan, cheers.
04:51:36 <Baughn> dubhrosa: Once you learn STM, you'll learn to love it. :)
04:51:49 <RayneSplit> i do not understand that :/
04:52:02 <luite> RayneSplit: it has to choose a suitable type for the 3 literal, and it can't choose Int or Integer, because you use (/) on it
04:52:22 <RayneSplit> but why 3?
04:52:31 <luite> @src foldl
04:52:31 <lambdabot> foldl f z []     = z
04:52:31 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:52:32 <dubhrosa> Baughn: cool, I've been meaning to for a while, read some high-level articles etc but never had a real need in a proper project before.
04:53:03 <luite> foldl f z [] = z, you use: foldl (/) 3 [], so f = (/), z = 3, the result is z
04:53:09 <burp> > (S.fromList [1,2,3,4,5,6]) == (S.fromList [6,3,4,5,1,2])
04:53:11 <lambdabot>   True
04:53:31 <medfly> what's that?
04:53:37 <Baughn> dubhrosa: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15125#a15125 <-- I seem to paste this a lot, but it makes a nice demonstration of STM
04:53:51 <Twey> Ooh, hpaste.org is back
04:53:51 <Baughn> dubhrosa: Demonstrating composition as well as retry. :)
04:53:57 <Twey> Do we know what happened?
04:54:03 <RayneSplit> ah, thanks luite :)
04:54:55 <HaskellLove> Teggy can you explain how the flip code works please?
04:55:42 <Teggy> HaskellLove: (flip f) is like f but it expects its two arguments in reverse order
04:55:53 <burp> @src flip
04:55:54 <lambdabot> flip f x y = f y x
04:56:04 <Teggy> :t flip
04:56:05 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:56:12 <Baughn> HaskellLove: For an exercise, figure out what flip id does, and why
04:56:51 <Teggy> Baughn, (flip id) does not type
04:57:02 <HaskellLove> yes i know but the way you used is strange map (flip elem ...)
04:57:03 <Baughn> Teggy: Does too. :)
04:57:09 <yitz> @type flip id
04:57:10 <lambdabot> forall a b. a -> (a -> b) -> b
04:57:11 <Twey> Teggy: Does so!  ‚ò∫
04:57:16 <Baughn> ..aww, you gave it away
04:57:20 <yitz> oops
04:57:25 <Twey> Boo, yitz :√æ
04:57:30 <Teggy> OK, I take that back ;-)
04:57:32 <yitz> @slap yitz
04:57:33 * lambdabot karate-chops yitz into two equally sized halves
04:57:42 <Baughn> ..oww. That's a bit extreme.
04:57:49 <Twey> Hehe
04:57:50 <dubhrosa> Baughn: great example, definitely looks sufficient for what I need, thanks.
04:57:51 <Teggy> Too much Scheme lately...
04:57:54 <yitz> @vixen it's your fault, you gave it away
04:57:56 <lambdabot> have you ever made it with a man?
04:58:05 <Baughn> dubhrosa: You know all that stuff about how retry blocks, right?
04:58:11 <b_jonas> Baughn: heh, nice
04:58:36 <dubhrosa> Baughn: no
04:58:57 <Baughn> dubhrosa: That's the most important clue about STM. Basically:
04:59:26 <Baughn> dubhrosa: When you enter an atomically block, the runtime keeps track of which TVars you read. (The others - TMVar, etc. - are implemented using TVars)
04:59:43 <Baughn> dubhrosa: Then, if you retry, the call blocks until one of those TVars have changed.
05:00:02 <ben0x539> Is the GC smart enough to collect those leaky buckets?
05:00:16 <Baughn> ben0x539: If you lose all references to one, sure
05:00:29 <Baughn> Oh, you mean with the forkIO
05:00:35 <Baughn> Yes, it'll kill off that thread too.
05:00:39 <ben0x539> Neat
05:00:50 <Baughn> It gets a "permanently deadlocked" exception
05:00:58 <Baughn> ..or it /should/, I haven't tested. It hasn't come up.
05:01:01 <ben0x539> Sounds tricky.
05:01:16 <dubhrosa> Baughn: gotcha.
05:06:22 <b_jonas> is there an XVar and XBox for each letter X now?
05:06:45 <Baughn> Well, we do have IVars
05:07:09 <b_jonas> because I'd like to know what name is free for when I make my own abstractions
05:07:36 <b_jonas> well there's always greek letters, AlphaBox, AlphaVar, BetaBox, BetaVar, ..., OmegaVar
05:07:41 <Baughn> b_jonas: Pretty sure YVar is free.
05:07:55 <Baughn> And VVar
05:07:59 <b_jonas> @info LVar
05:08:00 <lambdabot> LVar
05:08:05 <Twey> o.@
05:08:14 <Twey> What are LVars and IVars?
05:08:23 <b_jonas> @info HlaghVar
05:08:24 <lambdabot> HlaghVar
05:08:33 <Twey> Hahaha
05:08:38 <Baughn> IVars are immutable MVars. You can write only once, and not take, which means readIVar is not in IO.
05:08:47 <Twey> Oho
05:08:47 <Baughn> ..LVars, I don't think exist.
05:09:14 <Twey> What's the point of IVars?  Can't you just pass a value instead?  :√æ
05:09:38 <Baughn> readIVar /blocks/ until the corresponding writeIVar is executed
05:09:40 <Baughn> This can be handy.
05:09:58 <ben0x539> Clearly what we need is a typeclass for all sorts of Vars
05:09:59 <b_jonas> wow, is that really safe?
05:10:01 <HaskellLove> pandigitals nums = [x | x <- nums, d <- (listOfDivisors x), let y = (x `div` d), let productList = numbersToDigitsList ([d]++[y]++[x]), containsNums_1_9 productList] Do you see possible optimizations here? without knowing what other code means, just by looking at this
05:10:02 <Baughn> Yes.
05:10:13 <Baughn> Although, you can often do the same stuff with mfix and whatnot
05:10:24 <ben0x539> Baughn: So IVars are kind of like MVars without take?
05:10:25 <Baughn> (Which is considerably cheaper)
05:10:30 <Baughn> ben0x539: That's what I said.
05:11:55 <Teggy> [d]++[y]++[x] smells like [d,y,x]
05:12:43 <Baughn> ..well, it certainly /smells/.
05:12:49 <Cale> It's a somewhat less efficient version of the same thing, yes
05:13:54 <b_jonas> maybe they have a custom lexical (++)
05:14:28 <b_jonas> not likely
05:16:01 <Twey> [x | x <- nums, d <- listOfDivisors x, containsNums_1_9 $ numbersToDigitsList [d, x `div` d, x] ]
05:16:12 <HaskellLove> [d]++[y]++[x] smells like [d,y,x] so the first one is faster?
05:16:29 <burp> the first one? :D
05:16:36 <elly> the first one? o_O
05:16:39 <HaskellLove> i mean the second one sorry
05:16:45 <HaskellLove> how fast, double or near?
05:17:20 <Lemmih> HaskellLove: They compile to the same thing.
05:17:41 <HaskellLove> well yeah that is why i asked if it is really faster
05:17:54 <Lemmih> HaskellLove: It's prettier, though.
05:18:03 <Teggy> HaskellLove, it will most probably not have any impact performance-wise at all.   It's shorter and clearer, though.
05:20:39 <HaskellLove> sort (x:xs) == [1..9] should i go with this or use Set? I mean, it compares lists with 9 elements
05:21:27 <b_jonas> ?
05:21:54 <HaskellLove> will using Set to test for equality be faster then just == list comparison
05:22:09 <HaskellLove> but the sort will take time i guess
05:23:23 <Teggy> HaskellLove, it depends.  Haskell is lazy.  == will consume its operands only to  the point where both list disagree for the first time.
05:23:46 <HaskellLove> ah cool then
05:24:09 <Teggy> HaskellLove, if sort is based on insertion sort, for example, the sort may never actually sort the whole list x:xs (but only build a prefix)
05:29:43 <HaskellLove> this is same speed-wise with this [show d, show y, show x] VS map show [d,y,x]
05:29:47 <HaskellLove> ?
05:31:59 <dblhelix> has anyone been successful recently in installing yhc / catch?
05:32:26 <Baughn> Teggy: But of course it isn't. It's merge-sort.
05:32:36 <dblhelix> (on a non-windows platform)
05:33:38 <opqdonut> HaskellLove: sure
05:34:04 <opqdonut> inlining map in the second will give the first
05:34:18 <Teggy> Baughn, yes.  I was only referring to the folklore  minimum xs = head (isort xs)    (where isort is insertion sort)
05:34:50 <opqdonut> you can mostly trust ghc to do the right thing with this small-scale stuff
05:35:18 <opqdonut> i wonder if there is a sub-quadratic sorting algorithm that produces prefixes
05:36:07 <dblhelix> opqdonut: iirc there was some discussion about this on one of the mailing lists about a year ago
05:36:20 <opqdonut> i'm not surprised
05:36:31 <opqdonut> -cafe?
05:36:46 <dblhelix> opqdonut: not sure, but most likely
05:37:33 <opqdonut> yeh
05:38:24 <HaskellLove> i am litle sleepy.... an odd number does not have even divisors right?
05:38:45 <dblhelix> HaskellLove: right
05:39:33 <Baughn> Any even divisor can be decomposed into an odd divisor and 2
05:39:45 <Baughn> Any number with 2 as a divisor is not odd. ;)
05:40:06 <HaskellLove> listOfDivisors n | odd n = [x | x<-[3,5..(n`div`2)], n `mod` x ==0] | otherwise = [x | x<-[2..(n`div`2)], n `mod` x ==0] can that be further optimised? I did two optimisations 1. I search to half of n 2. for odd ones i skip even ones
05:41:30 <opqdonut> for big numbers, factorise first, then produce list of divisors
05:41:39 <b_jonas> yep, factorize first
05:41:49 <Axman6> how would you do that?
05:42:10 <opqdonut> for example 12=2*2*3, divisors are 2, 2*2, 3, 2*2*3
05:42:42 <opqdonut> oops, missed 2*3
05:42:53 <opqdonut> anyway, kinda like the powerset of the factor multiset
05:43:50 <b_jonas> list monad
05:43:52 <b_jonas> evil
05:44:02 <opqdonut> a better example: 36=2*2*3*3, divisors are 2, 2*2, 3, 3*3, 2*3, 2*2*3, 2*2*3*3, 2*3*3
05:44:42 <Axman6> oh, so it's all combinations of all the prime factore, multiplied?
05:44:48 <Axman6> how interesting
05:45:49 <HaskellLove> opqdonut so once you have the factors list, then the divisors are sublists of that?
05:45:55 <opqdonut> if n=prod[i] p_i^a_i, then m=prod[i] p_i^b_i, where b_i<=a_i, is a divisor of n
05:46:07 <opqdonut> HaskellLove: well yeah, but that way you'll get duplicates
05:46:14 <opqdonut> but it's a good starting point
05:46:31 <HaskellLove> opqdonut any better point?
05:47:01 <opqdonut> proper multisetting, represent n as the list [a_i | i\in N]
05:47:22 <opqdonut> then go throught lists m that are less or equal to n at every index
05:48:53 <Axman6> > let factors n = f n 2 where f 1 x = [], f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 36
05:48:54 <lambdabot>   <no location info>: parse error on input `,'
05:48:55 <HaskellLove> ah this seems boring i will go with mine listOfDivisors n | odd n = [x | x<-[3,5..(n`div`2)], n `mod` x ==0] | otherwise = [x | x<-[2..(n`div`2)], n `mod` x ==0]
05:49:04 <opqdonut> something like: divs (a:as) = do xs <- divs as; x <- [1..a]; return x:xs
05:49:06 <Axman6> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 36
05:49:07 <lambdabot>   [2,2,3,3]
05:49:11 <ivanm> Axman6: any idea when dons is going to the ACT?
05:49:12 <Axman6> hooray
05:49:18 <ivanm> because I probably wont' be there till Feb 10
05:49:28 <Axman6> some time in janurary
05:49:43 <ivanm> right; I might even be in madrid then doing other haskelly stuff ;-)
05:49:52 <opqdonut> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 100
05:49:53 <lambdabot>   [2,2,5,5]
05:50:01 <opqdonut> ah, i thought it wouldn't work
05:50:03 <opqdonut> nice
05:50:07 <HaskellLove> ivanm yo you work in a company with haskell?
05:50:29 <ivanm> HaskellLove: nope
05:50:31 * ivanm is a student
05:50:35 <opqdonut> ah, of course, p<p^k
05:51:17 <ivanm> @check \ p k -> p < p ^ k
05:51:18 <lambdabot>   "Falsifiable, after 0 tests:\n1\n2\n"
05:51:23 <ivanm> aha!
05:51:30 * ivanm has no idea what opqdonut is talking about, but anyway
05:52:03 <opqdonut> ivanm: for k>1, the reason why Axman6's factorisation code works
05:52:20 <ivanm> @check \ p k -> k > 1 ==> p < p ^ k
05:52:21 * Axman6 is a genius
05:52:21 <lambdabot>   No instance for (Test.QuickCheck.Testable
05:52:21 <lambdabot>                     (Test.QuickCh...
05:52:26 <ivanm> bah
05:52:30 <ivanm> @type \ p k -> k > 1 ==> p < p ^ k
05:52:31 <lambdabot> forall a a1. (Integral a, Num a1, Ord a1) => a1 -> a -> Property
05:52:51 <opqdonut> ivanm: and for primes (or just positive numbers at least 2) p
05:53:52 <dblhelix> @seen ndm
05:53:52 <lambdabot> Unknown command, try @list
05:54:49 <dblhelix> uh
05:55:09 <Axman6> preflex: seen ndm
05:55:09 <preflex>  ndm was last seen on #haskell 233 days, 3 hours, 36 minutes and 28 seconds ago, saying: plus with current compiler technology, it would be slower
05:55:30 <b_jonas> @info ==>
05:55:30 <lambdabot> (==>)
05:55:32 <dblhelix> famous last words
05:55:35 <b_jonas> @query ==>
05:55:35 <lambdabot> Unknown command, try @list
05:55:38 <b_jonas> @hoogle ==>
05:55:39 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
05:56:54 <HaskellLove> wait i dont get it, now that i get a list of factors how to get the multipliers?
05:57:05 <HaskellLove> give me concrete steps step 1.2.3. bla bla
05:57:09 <medfly_> :|
05:57:17 <opqdonut> 1548.40  opqdonut$ something like: divs (a:as) = do xs <- divs as; x <- [1..a]; return x:xs
05:57:21 <opqdonut> sorry to quote myself
05:57:32 <mauke> wait, HaskellLove still can't program?
05:57:40 <opqdonut> that gives you the lista [a_i...] relating to each divisor
05:57:44 <medfly_> I think you can google solutions for all euler problems ;)
05:58:10 <opqdonut> now you just "product $ zipWith (^) xs primes" over the results
05:58:23 <HaskellLove> well i have a function for factors written by the genius me, but now how to get divisors list
05:58:49 <b_jonas> first, you get the divisors in power form
05:58:50 <HaskellLove> i have done the number of divisors thing with the exponents and stuff, but not list of divisors like this
05:58:58 <b_jonas> with each groups of same divisors grouped together to a powe
05:59:24 <b_jonas> then for each prime maximal power divisor p^n you take the list [1, p, p^2, ..., p^n]
05:59:24 <HaskellLove> ok...
05:59:34 <b_jonas> and then multiply each of these lists
05:59:48 <b_jonas> finally if you want proper divisors, remove the original number
06:00:29 <Axman6> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 573514657
06:00:33 <lambdabot>   mueval-core: Time limit exceeded
06:00:34 <opqdonut> yeah that's a bit more efficient, you don't need ^, just iterated *
06:00:36 <Axman6> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 5735146
06:00:40 <lambdabot>   mueval-core: Time limit exceeded
06:00:43 <Axman6> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 57351
06:00:43 <lambdabot>   [3,7,2731]
06:00:50 <opqdonut> and of course, that factorisation code is horrible :)
06:00:56 <Axman6> :O
06:00:57 <Axman6> bah!
06:01:00 <opqdonut> you should only be testing primes, for one
06:01:16 <opqdonut> at least if you're factorizing a big bunch of numbers
06:01:17 <b_jonas> also I recommend Szalay: Sz√°melm√©let (Tank√∂nyvkiad√≥), for it's a great intruduction to number theory
06:01:22 <Axman6> i've found that calculating the primes takes more time than just testing everything
06:01:48 <jkff> Perhaps you are using an inefficient method of calculating primes
06:02:01 <HaskellLove> Axman6 that is so messy unreadable code or i am so noob
06:02:08 <Axman6> but, if you are doing it a lot, you can have the list of primes kept around and lazily calculated
06:02:11 <HaskellLove> why use divMod, just use mod == 0
06:02:26 <Axman6> medfly_: it's unreadable because it's on one line. proper layout makes it quite clear
06:02:38 <Axman6> because you need to divide anyway
06:02:44 <Axman6> uh, HaskellLove, not medfly_
06:02:44 <opqdonut> yeah using primes for one factorisation isn't efficient
06:02:57 <opqdonut> but for many, it can be
06:03:13 * Axman6 has a somewhat nice corecursive lazy primes list thing somewhere
06:03:41 <Axman6> primes used isPrime to find primes, and isPrime uses primes to find prime numbers
06:03:57 <mietek> http://www.bobhobbs.com/files/kr_lovecraft.html
06:04:00 <mietek> Beautiful.
06:04:48 <jkff> Axman6: That reminds me of an episode of "Beavis and Butthead" where they copied each other's results on an IQ test and were proclaimed "gifted pupils".
06:04:55 <HaskellLove> Mine is so sexy, the ones i saw here confused me a lot
06:05:00 <Axman6> jkff: ha
06:05:00 <HaskellLove> primeFactors n = firstMultiplier : primeFactors secondMultiplier where
06:05:02 <HaskellLove>                  firstMultiplier = getFirstDivisor n
06:05:04 <HaskellLove>                  secondMultiplier = n `div` firstMultiplier
06:05:15 <Axman6> o.O
06:05:35 <Axman6> your function names arte too long >_<
06:05:47 <Axman6> too much java in your past
06:05:48 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15126#a15126
06:05:58 <b_jonas> HaskellLove: how does that work? doesn't that always return an infinite list
06:06:12 <Axman6> yes
06:06:28 <b_jonas> Axman6: says the haskell guy
06:06:36 <Axman6> b_jonas: check the link though
06:06:45 <Axman6> b_jonas: ?
06:06:52 <b_jonas> oh, I see
06:06:54 <b_jonas> better
06:07:15 <Axman6> though that's a horrible way to find a divisor
06:07:29 <HaskellLove> haha it is fast actually
06:07:40 <Axman6> HaskellLove: that's pretty damn inefficient. looks like it's O(n^n)
06:08:17 <Axman6> > let factors n = f n 2 where f 1 x = []; f n d = case n `divMod` d of (n',0) -> d : f n' d; _ -> f n (d+1) in factors 57351
06:08:18 <lambdabot>   [3,7,2731]
06:08:33 <HaskellLove> O(n^n) how did you get to that?
06:08:44 <b_jonas> nah, this is the best way to factor primes: http://erxz.com/pb/22372
06:09:07 <b_jonas> it's my sixth prime factoring program for the programmable calculator, with each one faster than the next one
06:09:11 <HaskellLove> Axman6 test mine against yours and tell me time it will kill you
06:09:33 <b_jonas> it factors numbers near 10^10 in one or two minutes
06:09:56 <Axman6> that's gross and i don't want to see it again
06:09:58 <Axman6> :P
06:10:20 <HaskellLove> gross? I wait you in the ring with gloves young man
06:10:24 <jkff> b_jonas: For which numbers does it take 2 minutes? Should be only the prime ones or products of a prime and something small
06:10:38 <b_jonas> jkff: yep, prime numbers near 10^10
06:10:50 <b_jonas> obviously for exactly 10^10 it's fast
06:10:52 <HaskellLove> b_jonas test mine and tell me time
06:11:04 <jkff> b_jonas: why not add a good and fast primality test to the algorithm, and boost its performance by a lot?
06:11:05 <Axman6> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15127#a15127
06:11:29 <b_jonas> jkff: I tried once,
06:11:43 <b_jonas> jkff: the problem is that for one you'd need to be able to multiple double precision numbers
06:11:56 <jkff> b_jonas: And how is that a problem?
06:11:59 <b_jonas> jkff: the normal precision being the native floats between 10 or 12 digits
06:12:10 <b_jonas> jkff: it's an old and limited calculator, it would be very to do that
06:12:10 <jkff> Ah, the normal precision of the calculator
06:12:28 <b_jonas> jkff: I implemented pollard rho
06:12:36 <b_jonas> it worked for numbers around 10^5
06:12:43 <b_jonas> because then it could multiply two exactly
06:12:53 <b_jonas> but it's of course slow for numbers in that range
06:12:58 <HaskellLove> Axman6 test time please and compare them both
06:13:31 <HaskellLove> for some huge number
06:13:35 <jkff> b_jonas: Does testing a number for division by all numbers in 1..10^5 take 2 minutes on the calculator?
06:13:48 <Axman6> HaskellLove: stop being lazy and terst it for yourself
06:13:54 <Axman6> you're the one who cares
06:14:03 <b_jonas> jkff: yes, something like that
06:14:09 <b_jonas> jkff: probably just one minute with this new program
06:14:09 <HaskellLove> Axman6 I would if i knew it... i dont know how to import timer or something
06:14:20 <Axman6> well learn!
06:14:21 <b_jonas> jkff: because it has some 6502-like slow cpu which can't do arithmetic fast
06:14:28 <Berengal> HaskellLove: Just compile and use time
06:14:34 <medfly_> what
06:14:38 <b_jonas> jkff: and you can't program it in assembly so you have to use the slow builtin floating point number operations and limited language
06:14:40 <medfly_> a calculator with a cpu that can't do arithmetic fast
06:14:43 <medfly_> WHAT IS THE POINT OF THAT
06:15:06 <Berengal> medfly_: I bet it calculates faster than you.
06:15:13 <medfly_> oh yeah!!
06:15:14 <HaskellLove> Berengal how
06:15:35 <Berengal> HaskellLove: ghc --make -O2 foo.hs && time ./foo, for a given foo.hs
06:15:42 <b_jonas> medfly_: do you know what a wonder that pocket calculator was ten years ago when I got it?
06:15:53 <b_jonas> medfly_: almost no-one had good programmable calculators back then
06:15:55 <medfly_> I'm just joking, what you said sounded funny
06:16:06 <b_jonas> medfly_: even in our class of geeks I was the third one to get such a calculator
06:16:17 <HaskellLove> Berengal cool so the && is like some operator for commands to compiler or what?
06:16:28 * medfly_ doesn't have a programmable calculator
06:16:31 <Berengal> HaskellLove: No, it's a shell operator
06:16:37 <b_jonas> I don't use them anymore
06:16:41 <b_jonas> but love it for history
06:16:45 <b_jonas> because I wrote such programs on it
06:16:51 <b_jonas> these days I have computers everywhere so I don't use it
06:19:59 <HaskellLove> Berengal bash: ./e: No such file or directory
06:20:20 <HaskellLove> ghc --make -O2 "/home/user/Desktop/e.hs" && time ./e
06:20:52 <Raevel> add -o e
06:21:06 <Berengal> HaskellLove: You run it just as you would without time, except you put "time" in front.
06:21:08 <mauke> or run it from your desktop
06:22:13 <HaskellLove> in front ? well you put it as && time bla bla? after the compile thing
06:22:40 <jkff> HaskellLove: Why don't you read a shell programming tutorial?
06:23:12 <Berengal> HaskellLove: Learn a bit of shell scripting. It's not hard, and even just a little bit will go a long way in making your life easier.
06:23:13 <jkff> foo && bar means "foo, and if it succeeds, then bar"
06:23:16 <Axman6> HaskellLove: foo && blah runs foo, and if it exits without an error code, runs blah
06:23:24 <jkff> "time foo" means "run foo and then report timing statistics"
06:24:00 <jkff> HaskellLove: btw, are you on Windows or on some kind of Unix?
06:25:02 <HaskellLove> ubuntu yeah i know i have read on bash but never used time
06:25:34 <HaskellLove> real	0m0.386s    user	0m0.168s     sys	0m0.044s  what do those mean in short?
06:25:35 <Berengal> HaskellLove: For a quick demo, try "time ls"
06:26:00 <jkff> HaskellLove: You need some meta-knowledge before all.
06:26:26 <HaskellLove> comparing algorithms mine vs Axman6
06:26:27 <medfly_> rtfm
06:26:28 <jkff> HaskellLove: "man" is a command for getting help. "man time" gives you help about the "time" command
06:27:09 <mux> No manual entry for monad
06:27:09 <jkff> Actually, the existence of google is more than enough to eliminate the need for asking about the output of "time" on a haskell channel
06:27:10 <mauke> does it?
06:27:10 <mux> wait
06:27:22 <mauke> oh, it does
06:27:27 <Axman6> HaskellLove: user is the time your code took to run, sys is the time spent in system calls, and real is the total running time
06:27:32 <mux> a gazillion monad tutorials but no monad manual page?! ;-)
06:27:46 <mauke> apparently there's a /usr/bin/time in addition to the shell builtin
06:28:01 * hackagebot upload: explicit-iomodes 0.1.3 - File handles with explicit IOModes (BasVanDijk)
06:28:05 <mauke> (for which you should use "help time")
06:28:06 <Axman6> the binary is usually more useful
06:29:24 <jkff> Heh, something changed on the Shootout, and now the 2 Haskell programs take 2 first places!
06:29:41 <Berengal> jkff: Someone set up them the bomb?
06:30:19 <HaskellLove> user	0m0.224s VS user 0m0.228s haha Axman6 dude I am faster
06:30:20 <Axman6> jkff: which ones?
06:30:32 <Axman6> HaskellLove: what number were you fact5orising?
06:30:34 <Axman6> -5
06:30:35 <jkff> Don't know: haskell ghc #4 is my patch of Brian's program that previously ran 20% faster than his program, and now they take identical time
06:30:38 <HaskellLove> main = print (length (factors 10000000000000000))
06:30:44 <jkff> http://shootout.alioth.debian.org/u64q/benchmark.php?test=pidigits&lang=all
06:30:54 <Berengal> HaskellLove: Try some other number, like 123574535745267924
06:30:55 <Axman6> HaskellLove: that's a stupid number to use though
06:30:57 <jkff> Oh, I forgot to say it was the pidigits benchmark
06:31:17 <Berengal> HaskellLove: Also, the timings aren't entirely precise. You should run them a couple of times, and probably disregard the last number...
06:31:20 <Axman6> yeah pidigits was a bit of a bitch
06:31:24 <HaskellLove> Axman6 give me 3 numbers to test if you like
06:32:20 <Axman6> 2^823749-1
06:32:34 <Axman6> > length . show $ 2^823749-1
06:32:36 <lambdabot>   247974
06:32:41 <Axman6> more like it!
06:32:43 <Axman6> >_>
06:32:49 <medfly_> hehehe
06:32:52 <medfly_> I can pick a number
06:34:28 <medfly_> try 9990454949
06:34:36 <Berengal> 2^a billion!
06:34:49 <Berengal> -1
06:34:54 <Axman6> heh
06:35:00 <HaskellLove> i am sleepy i go, you test it if you like ;D
06:35:32 <medfly_> you write me code, you test, you figure out ideas
06:37:07 <HaskellLove> i will after i get some nap
06:47:22 <dum8d0g> Hi, what is the simplyest way to find out if an element is in the list or not?
06:47:29 <mauke> :t elem
06:47:30 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:47:30 <Zao> `elem`
06:47:45 <Axman6> > 4 `elem` [1..10]
06:47:45 <dum8d0g> ah.. thanks :)
06:47:46 <lambdabot>   True
06:47:48 <Twey> > 'a' `elem` "vakaras"
06:47:49 <lambdabot>   True
06:47:49 <Axman6> > 40 `elem` [1..10]
06:47:50 <lambdabot>   False
06:48:04 <Twey> > elem 3 [5 .. 10]
06:48:05 <lambdabot>   False
06:48:26 <dum8d0g> thank you.. that is exactly what I needed
06:54:52 <copumpkin> b_jonas: did you figure out your monoid?
07:03:15 <dum8d0g> and another simple question.. how do I remove all occurences of an element from a list please?
07:03:48 <mauke> filter (/= x)
07:04:23 <dum8d0g> :)
07:04:26 <dum8d0g> thanks
07:05:08 <jlouis> mauke is on a Data.List spree today!
07:07:16 <Axman6> o/ jlouis
07:07:30 <jlouis> hep Axman6
07:08:09 <copumpkin> hep?
07:08:28 <jlouis> copumpkin: some scandinavian variant of "hi"
07:08:39 <copumpkin> ah
07:08:46 * copumpkin just sent an email to Eugenia Cheng!
07:08:49 <Axman6> i made some more haskelltorrent changes today. cleaned up what's different between our two branches quite a bit i think. i also took a look at what you said about um... well i didn't really understand it, so i haven't done what you said i should do :P
07:09:02 <jlouis> Axman6: hehe
07:09:18 <jlouis> Axman6: I've just pulled it for now into a 'pu' branch of published changes
07:09:27 <Axman6> i think you may like my changes to BCode though. the code's a lot prettier now
07:09:39 <jlouis> You went Applicative?
07:09:44 <Axman6> very :P
07:09:48 <jlouis> Cool!
07:10:01 <Axman6> makes the code a lot shoter
07:10:22 <jlouis> I'll probably pull them into the main master branch later today
07:10:32 <Axman6> added things like:
07:10:34 <Axman6> getWrapped :: Char -> Char -> Get a -> Get a
07:10:35 <Axman6> getWrapped a b p = char a *> p <* char b
07:10:52 <jlouis> oh, I see where that goes! Nice
07:10:53 <Axman6> which makes the rest a lot nicer too
07:10:53 <mux> yeah, ain't that cute
07:10:59 * mux loves Applicative too
07:11:05 <Axman6> getBArray :: Get BCode
07:11:05 <Axman6> getBArray = BArray <$> getWrapped 'l' 'e' (many get)
07:11:07 <mux> the number one module for code golfing
07:11:19 <mauke> huhu, that's why I invented (<<)
07:11:31 <mauke> (before I learned about applicatives)
07:11:32 <Axman6> mauke: type?
07:11:37 <Accidus> Hrmph. Someone in #math told me I don't understand computability, after I said that the function deciding {0} is not computable.
07:11:45 <mauke> (Monad m) => m a -> m b -> m a
07:11:52 <Axman6> ah, heh
07:12:05 <Axman6> so it is just flip (>>)
07:12:10 <mauke> no
07:12:17 <jlouis> Accidus: what is {0} here?
07:12:21 <Axman6> no?
07:12:27 <mauke> (<*) isn't just flip (*>) either
07:12:45 <Accidus> 0 among the real numbers
07:12:53 <mauke> the order of the effects is different
07:12:54 <mux> flip (>>) would only change the direction you write stuff, but you need to invert the effects
07:13:15 <Axman6> ok, i'm going to need to see some definitions now
07:13:34 * mux notes talking about effects is fine for (<<) but is likely incorrect for (<*) though
07:13:50 <jlouis> Accidus: I guess what you want is to invoke Rice's theorem, though I can't see where and how
07:14:32 <Axman6> is there a nicer way to write:
07:14:33 <mauke> a << b = do { x <- a; b; return x }
07:14:33 <Axman6> getBString = do count <- getDigits BString <$> ( char ':' *> getByteString (read count))
07:14:36 <Axman6> ?
07:14:59 <Axman6> where getDigits has a ; (thanks irssi for the onelining)
07:16:46 <mauke> do count <- read <$> getDigits; char ':'; BString <$> getByteString count
07:17:54 <b_jonas> copumpkin: re monoid: no
07:18:28 <mux> is Sigbjorn Finne on IRC?
07:18:52 <jlouis> Axman6: anyway, I got most of the Peer Process up to par wrt. leeching now
07:19:08 <Axman6> meaning?
07:19:11 <jlouis> Axman6: working on getting the file system code to accept not having the whole file :)
07:19:20 <Axman6> yeah, that would be nice :)
07:19:29 <jlouis> Meaning that we'll be able to download stuff in a couple of days with luck
07:19:56 <copumpkin> mux: don't think so
07:19:59 <Axman6> i'm downloading an arch linux iso at the moment to try out seeding (which is implemented right?)
07:20:27 <jlouis> Seeding ought to work though the checking at the beginning is awfully slow due to Pure.SHA :)
07:21:01 <jlouis> That is the reason I only use a 5mb test file
07:21:04 <Accidus> jlouis, sorry about disappearing, got involved in the discussion on #math. What I meant was that the set of all algorithms producing the digits of a particular real number is undecideable
07:21:07 <mux> copumpkin: thanks
07:21:15 <b_jonas> copumpkin: the applicative laws are so complicated that I'm not even sure it's really a monoid
07:21:18 <b_jonas> but I hope it is
07:22:10 <copumpkin> b_jonas: well the applicative laws are basically saying it's monoidish, but in a categorical sense
07:22:15 <b_jonas> mauke: a <* b
07:22:36 <copumpkin> http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Applicative.html
07:22:45 <Axman6> jlouis: there are better sha libraries aren't there? (though, maybe i could take a look at Pure.SHa and see if i have the knowledge to speed it up at all :))
07:23:15 <copumpkin> jlouis: so what's your end goal for this haskell BT stuff?
07:23:30 <jlouis> Axman6: there are definitely better libraries, but you get more comitters by choosing the blatantly slowest one :)
07:23:50 <Axman6> hehe, good plan :)
07:23:52 <b_jonas> copumpkin: ah, so App from that module
07:23:56 <b_jonas> copumpkin: thanks for the reference
07:24:02 <copumpkin> b_jonas: but that's probably more complicated
07:24:10 <copumpkin> let me give it a go
07:24:22 <jlouis> copumpkin: dunno, see if GHC can beat erlang at the ease with which you implement concurrent programs
07:24:31 <copumpkin> :)
07:25:00 <jlouis> Also that almost all the linux clients are crap in one way or the other
07:25:31 <copumpkin> ah
07:25:36 <copumpkin> so it's going to be a command-line thing?
07:25:50 <jlouis> either they are written in Java and kill small machines, or they handle the protocol with the intelligence of a braindead fly
07:26:22 <Axman6> jlouis: how do you feel about how you'll be able to handel the protocol using haskell?
07:26:26 <jlouis> commandline, perhaps with a web-infterface if someone gets interested
07:26:40 <Axman6> seems like it's quite straight forward, to parse at least
07:27:02 <jlouis> Well, the protocol parsing is done with applicative :)
07:27:35 <jlouis> it is not particularly hard to work with. The interesting parts are the extensions to the protocol of which there are some 10-20
07:28:03 <jlouis> one of them is XML IIRC... that is going to be "fun"
07:29:02 <mercury^> Is there any advantage in wrapping XML around plaintext?
07:29:33 <jlouis> The erlang client is 3500 lines of code including comments and it handles the basic protocol fine so it doesn't take too much work
07:30:01 <merijn> mercury^: Yes, it makes your code "Enterprise" :p
07:30:20 * stroan shudders at the word
07:30:41 <jlouis> enterprise is a synonym with big, ugly and slow :)
07:30:59 <stroan> broken, don't forget broken
07:31:32 <BONUS> unless it's preceded by "USS"
07:31:50 <stroan> BONUS: hardly a movie goes by it doesn't explode. hardly good workmanship there...
07:32:01 <BONUS> haha
07:32:04 <Beelsebob> it didn't explode in the most recent one
07:32:09 <mercury^> And the D model is clearly big, ugly and slow.
07:32:16 <Beelsebob> but it was big, and arguably slow
07:34:29 <b_jonas> so could you predict which xml library I'll like?
07:34:40 <Beelsebob> yes
07:34:42 <Beelsebob> none of them
07:34:46 <Beelsebob> they all deal with xml
07:35:15 <b_jonas> sad
07:35:21 <merijn> BONUS: Arguably even the USS Enterprise is slow, warp relies on the ship standing still while warping space around it so it's technically not moving and thus can't be fast..
07:35:25 <b_jonas> I still have to deal with xml in some way
07:35:29 <b_jonas> I like the perl XML::Twig module
07:35:43 <b_jonas> because it's perlish
07:40:55 <mchase> does anyone know of an html generation library that uses ByteStrings instead of Strings?
07:41:19 <mux> mchase: moe does, IIRC
07:41:26 <mux> I haven't tried it yet though
07:41:48 <mchase> mux: moe?
07:41:58 <mchase> i tried "moe haskell" and didn't get much
07:42:11 <mux> http://hackage.haskell.org/package/moe
07:44:19 <mchase> mux: cool, thx
07:45:57 <wahjava> Hi everyone
07:47:01 <Axman6> 'lo wahjava
07:47:33 <sshc> @let rollFirstDie  :: StdGen -> (Integer, StdGen); rollFirstDie = randomR (1, 6)
07:47:34 <lambdabot>  Defined.
07:47:42 <wahjava> hi Axman6
07:48:23 <wahjava> I'm trying to port GHC 6.12.1 to FreeBSD, and I noticed GHC 6.12.1 excludes lots of module like Control.Monad.Trans from installing.
07:48:47 <mux> porting? GHC 6.12.1 builds and runs fine under FreeBSD
07:49:04 <mux> GHC 6.12 ships with a lot less modules than previously
07:49:06 <wahjava> mux, I mean packaging :)
07:49:08 <mux> mtl is one of those
07:49:26 <mux> note that there is no extralibs tarball anymore
07:49:48 <wahjava> mux, haskeline mtl terminfo.
07:50:00 <Axman6> woah, there's a RWH iPhone app :O
07:50:25 <sshc> @let rollSecondDie :: Integer -> StdGen -> (Integer, StdGen); rollSecondDie x seed = let (value, seed) = randomR (1, 6) seed in (value + x, seed)
07:50:26 <lambdabot>  Defined.
07:50:32 <wahjava> yes, I noticed that. So that means, for existing programs to work, one also needs to port (read as 'package') mtl, haskeline, and terminfo modules also.
07:51:11 <camio> I'm looking to write a parser for DXF and am considering uu-parsinglib, parsec, and attoparsec. Any recommendations?
07:51:50 <Axman6> parsec is quite nice indeed. what sort of format is DXF?
07:52:04 <camio> Axman6: That's the format for autocad.
07:52:20 <Axman6> what's the format like?
07:52:29 <sshc> Saizan_: are these functions that I can compose by passing rollSecondDie as the first argument and rollFirstDie as the first argument?
07:52:43 <Axman6> is there a lot of binary data?  or is it more textual?
07:52:53 <camio> Axman6: It is a text based format.
07:53:06 <mux> isn't there a Random monad to avoid threading the PRNG state around?
07:53:06 <Axman6> got an example of it somewhere?
07:53:17 <sshc> Saizan_: or can I compose them by "bind rollSecondDie . rollFirstDie $ random (1, 6)"?
07:53:18 <Axman6> mux: yes
07:53:31 <mux> well, I suggest sshc to use that, then. :-)
07:53:41 <sshc> mux: probably, but I'm not supposed to be aware of the standard monads yet
07:53:59 <camio> Axman6: http://people.sc.fsu.edu/~burkardt/data/dxf/cube.dxf
07:54:28 <HaskellLove> [[[2,4,8],[3]]] how to remove the outermost bracket?
07:54:29 <Axman6> oo, that's quite a nice one to parse. i reckon parsec would work well
07:54:34 <HaskellLove> the innermost i can with concat
07:54:37 <Axman6> concat
07:54:44 <Axman6> @hoogle [[a]] -> [a]
07:54:44 <lambdabot> Prelude concat :: [[a]] -> [a]
07:54:45 <lambdabot> Data.List concat :: [[a]] -> [a]
07:54:45 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
07:54:58 <camio> Axman6: Why would you prefer parsec over attoparsec and uu-parsinglib?
07:55:16 <sshc> mux: Saizan_: I'm trying to figure out how bind is supposed to work for randomised functions (functions that take a a value and a seed, and return a new value and a new seed in a tuple)
07:55:21 <Axman6> because i've used it :P
07:55:31 <sshc> mux: exercise 7
07:55:56 <camio> Ah, I'm looking more for the strengths/weaknesses of each. I've used parsec extensively as well, but not the other two.
07:56:13 <sshc> mux: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
07:57:24 <mux> sshc: well, enjoy :-)
07:59:01 <Raynes> @pl \x -> isDigit x || isSpace x
07:59:02 <lambdabot> liftM2 (||) isDigit isSpace
07:59:50 <Lemmih> > or $ sequence [isDigit, isSpace] '2'
07:59:51 <lambdabot>   True
07:59:55 <Lemmih> > or $ sequence [isDigit, isSpace] 'f'
07:59:56 <lambdabot>   False
08:03:51 <twanvl> > any ($2) [isDigit, isSpace]
08:03:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
08:03:53 <lambdabot>    arising from the literal `2...
08:04:00 <twanvl> > any ($'2') [isDigit, isSpace]
08:04:01 <lambdabot>   True
08:04:56 <HaskellLove> can you see wrong in this code: listOfDivisors_all x = zipWith (divisorsList_1) a (tail a) where a = (concat $ listOfDivisors_separate x)
08:05:12 <sshc> mux: if you're willing to help a newbie, could you help answer my questions?
08:05:35 <sshc> mux: I'm not going to continue in the tutorial until I understand what bind does / is supposed to do in lesson 7
08:05:38 <HaskellLove> divisorsList_1 is binary
08:05:40 <Axman6> yes, your naming is terrible
08:06:49 <HaskellLove> Axman6 well why do you think so
08:07:03 <Axman6> they're too long, and use underscores
08:07:38 <Axman6> only use long names where what something is is unclear. for example, a is a terrible name there, because i have no idea what it is
08:07:56 <HaskellLove> Axman6 heh but I do
08:08:06 <Axman6> so?
08:08:15 <Axman6> you need to get into good habbits to be a good programmer
08:08:27 <Saizan_> sshc: what's the type of rollSecondDie and rollFirstDie?
08:08:30 <HaskellLove> I mean, a is just local val cant you see, it is in where so what does it matter how you call it
08:08:56 <sshc> let rollFirstDie  :: StdGen -> (Integer, StdGen); rollFirstDie = randomR (1, 6)
08:08:59 <HaskellLove> in "where block" ^
08:09:01 <sshc> let rollSecondDie :: Integer -> StdGen -> (Integer, StdGen); rollSecondDie x seed = let (value, seed) = randomR (1, 6) seed in (value + x, seed)
08:09:11 <sshc> Saizan_: these are the definitions
08:09:12 <Raynes> What is a better way to write `read sub > 21 || read sub < 1'?
08:09:15 <Axman6> because we read a lot of code in haskell. it should document itself
08:09:21 <HaskellLove> sshc you guys do a game?
08:09:49 <sshc> HaskellLove, I'm trying to learn monads
08:10:03 <Saizan_> sshc: ok, so you can do (bind rollSecondDie rollFirstDie) which will have type StdGen -> (Integer, StdGen)
08:10:05 <sshc> HaskellLove: this is an exercise of code
08:10:52 <Axman6> because we read a lot of code in haskell. it should document itselfPure.SHa sure is a memory hog (i think)
08:10:56 <sshc> Saizan_: why do I pass the second function to bind here, but I *don't* pass the second function to the previous bindns?
08:11:07 <Axman6> unless i did something stupid (which i probably did
08:11:23 <b_jonas> Raynes: let { x = read sub } in x > 21 || x < 1
08:11:34 <b_jonas> or something like that
08:11:53 <sshc> Saizan_: are these entirely different types of bind?
08:11:53 <Saizan_> sshc: because from bind's point of view rollFirstDie doesn't look like the kind of functions bind is supposed to work with
08:12:16 <Saizan_> sshc: it looks more like an inhert value to it
08:12:26 <Saizan_> sshc: which different types of bind?
08:12:39 <sshc> Saizan_: so I couldn't use bind in the manner in which I previously have?
08:12:44 <HaskellLove> How can I make this: divisorsList_1 x y = [n | xs<-x, ys<-y, let n = x*y] instead of being type divisorsList_1 :: (Num [t]) => [t] -> [t] -> [[t]] to be type divisorsList_1 :: (Num [t]) => [t] -> [t] -> [t]
08:13:00 <sshc> Saizan_: which is "bind f . bind g . bind h . j $ 42"
08:13:02 <mux> sshc: sorry I'm too busy right now, but I'm sure other people will (and actually they already are) help you
08:13:22 <sshc> mux: yes, they are, and no problem :)
08:13:37 <Saizan_> sshc: you can, but f,g,h and j have to be of the right type, which is not the type of rollFirstDie
08:13:45 <sshc> Saizan_: how would I chain together multiple randomised functions with this bind?
08:14:07 <sshc> @let rollThirdDie :: Integer -> StdGen -> (Integer, StdGen); rollThirdDie x seed = let (value, seed) = randomR (1, 6) seed in (value + x, seed)
08:14:08 <lambdabot>  Defined.
08:14:19 <sshc> rollThirdDie is identical to rollSecondDie
08:14:41 <Saizan_> ?type bind rollThirdDie . bind rollSecondDie
08:14:42 <lambdabot>     Couldn't match expected type `Float'
08:14:42 <lambdabot>            against inferred type `Integer'
08:14:42 <lambdabot>     In the first argument of `bind', namely `rollThirdDie'
08:14:50 <Saizan_> ah, that's still the old bind
08:15:03 <HaskellLove> sshc can you give me link to code so i learn something from it please?
08:15:05 <Saizan_> however that was wrong
08:15:21 <Saizan_> sshc: "bind rollThirdDie . rollSecondDie" for example
08:16:08 <sshc> HaskellLove: if you understand how functional programming works, http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:16:31 <b_jonas> agreed, that's a good tutorial
08:16:34 <sshc> Saizan_: how would I bind rollThirdDie, rollSecondDie, and rollFirstDie?
08:16:44 <HaskellLove> sshc your blog?
08:17:01 <sshc> HaskellLove: if you're asking me if that's my blog, of course it isn't
08:17:12 <Saizan_> sshc: bind (bind rollThirdDie . rollSecondDie) rollFirstDie
08:17:12 <sshc> HaskellLove: I'm trying to learn monads :)
08:17:33 <HaskellLove> sshc well i asked about code to share and you gave me a blog so i was confused...
08:18:02 <sshc> Saizan_: ok
08:18:09 <sshc> Saizan_: what does bind here do?
08:18:21 <Saizan_> sshc: notice the difference between composition and application
08:18:51 <sshc> Saizan_: and if I had 5 rollDie functions, would I do:
08:19:22 <Saizan_> sshc: conceptually it does the same as the other bind, it prepares one of these fancy functions so that it can easily be composed with the others, the implementation is in the blog post
08:20:10 <sshc> Saizan_: bind (bind (bind (bind rollFifthDie . rollFourthDie) rollThirdDie) rollSecondDie) rollFirstDie
08:20:13 <sshc> Saizan_: ?
08:20:24 <Saizan_> sshc: no
08:21:34 <Saizan_> sshc: assuming rollFifthDie and rollFourthDie are the same as rollThirdDie and rollSecondDie, i.e. of type Integer -> StdGen -> (Integer, StdGen)
08:21:46 <EvanCarroll> Nereid Nereid_ Nereid_` you ever use screen?
08:22:12 <Saizan_> sshc: you do bind (bind rollFifthDie . bind rollFourthDie . bind rollThirdDie . bind rollSecondDie) rollFirstDie
08:24:30 <Saizan_> sshc: or if you prefer application rather than composition, (bind rollFifthDie (bind rollFourthDie (bind rollThirdDie (bind rollSecondDie rollFirstDie))))
08:27:48 <mux> hmm, dons is on vacation, now is the time to score lots of link karam on the haskell reddit
08:27:53 <mux> karma
08:39:19 <merijn> It's bad practice to put typeclass restrictions in data declarations?
08:40:34 <jlouis> mux: yeah
08:42:15 <Lemmih> merijn: Yes.
08:43:44 <sclv> anyone know if hacBOS is an ongoing proposition or did it peter out?
08:44:23 <merijn> Lemmih: ok, thanks
08:46:37 * Baughn imports Data.Unamb. This won't end well.
08:51:48 <osaunders> I've got another types questions for the channel
08:51:51 <osaunders> This works
08:51:53 <osaunders> > (map head . group) "aaaaabbcccd"
08:51:54 <lambdabot>   "abcd"
08:52:02 <osaunders> but this doesn't
08:52:06 <Baughn> (Serialize p, Typeable r, Serialize p, Typeable r) <-- Do you see the problem? It took me ten minutes to spot.
08:52:12 <Baughn> I feel that GHC should warn about this.
08:52:15 <osaunders> > let compress = map head . group in compress "aaaaabbbcc"
08:52:16 <lambdabot>   "abc"
08:52:19 <osaunders> Oh.
08:52:25 <osaunders> Hm.
08:52:46 <osaunders> @define compress = map head . group
08:52:53 <Baughn> That's @let
08:53:00 <osaunders> @let compress = map head . group
08:53:01 <lambdabot>  Defined.
08:53:03 <sclv> dread monomorphism restriction strikes again!
08:53:05 <osaunders> Baughn: Thanks
08:53:12 <osaunders> > compress "aaabbbddd"
08:53:13 <lambdabot>   "abd"
08:53:29 <osaunders> OK, well that doesn't work in my GCHi. I get: Couldn't match expected type `()' against inferred type `Char'
08:53:40 <Baughn> @type compress
08:53:41 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:53:53 * maltem is disappointed to realize that iteratees don't even turn out to be the holy grail
08:53:55 <sclv> osaunders -- in the pointfree style, compress defaults to working on monomorphic lists
08:53:55 <Baughn> > let compress = map head . group in compress "aabbccdd"
08:53:56 <lambdabot>   "abcd"
08:53:58 <Baughn> > let compress = map head . group in compress "aabbccd"
08:53:59 <lambdabot>   "abcd"
08:54:05 <osaunders> (my :t compress = compress :: [()] -> [()])
08:54:08 <sclv> except like in lambdabot where the dmr is i guess enabled
08:54:26 <sclv> you either give a type signature, write pointful, or turn of the monomorphism restriction with a flag
08:54:28 <Baughn> maltem: No, the holy grail is conal-style FRP
08:54:47 <osaunders> What is the monomorphism restriction exactly/
08:54:58 <osaunders> Defaulting to ()?
08:55:04 <sproingie> let mrthis = succ . pred in mrthis
08:55:07 <sclv> things that "look like constants" are monomorphic
08:55:08 <maltem> Baughn, then someone must invent reactive streams
08:55:11 <sproingie> > let mrthis = succ . pred in mrthis
08:55:12 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
08:55:24 <sclv> this combines with ghci's extended defaulting to produce the ()
08:55:37 <sproingie> looks like \bot still has mr
08:55:41 <sclv> if you compile, i think you get an error
08:56:13 <Baughn> maltem: Those are trivial
08:56:18 <sclv> sproingie: well, yes and no. i think its durned off in the define file.
08:56:27 <sclv> s/durned/turned/
08:56:45 <sproingie> that error is pretty different
08:56:52 <sw17ch> has any one written a ring datastructure in haskell? i could do it myself, but it seems common enough some one else may have.
08:57:11 <Baughn> > cycle "foo"
08:57:12 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
08:57:17 <sproingie> speaking of a circularly linked list kind of ring or the mathematical structure?
08:57:25 <Baughn> *algebraic
08:57:41 <sproingie> eh it's all math to me
08:57:44 <sclv> sw17ch: do you mean a ring typeclass?
08:57:48 <Baughn> Mathematical structure would /include/ circular lists. :P
08:57:58 <osaunders> Huh?
08:57:58 <osaunders> Why would it do that? Seems > let mrthis = silly succ . pred in mrthis should return a function to me.
08:57:58 <osaunders> s/seems//
08:58:29 <sproingie> osaunders: monomorphism strikes again.  actually i don't know why \bot doesn't like it, but ghci will make it more obvious
08:58:45 <sproingie> osaunders: lots of ways around it, not the least of which is just disabling it outright
08:58:47 <maltem> Baughn, I suppose that depends on what one wants from them
08:59:13 <sproingie> something about trying to treat a CAF as a regular function, i dunno the rationale
08:59:15 <osaunders> I get "Ambiguous type variable `a' in the constraint" with mrthis in GHC.
08:59:35 <osaunders> CAF?
08:59:46 <sproingie> constant applicative form
08:59:51 <sproingie> more or less "a value"
09:03:42 <maltem> Baughn, or did you mean to imply that FRP has something to offer for data processing? I don't see why it should, but I'm frankly quite ignorant of FRP
09:03:57 <Baughn> maltem: No, just that FRP is the holy grail.
09:04:02 <Baughn> Nobody seems able to make it work right.
09:04:13 <Baughn> The semantics are simple enough. The implementation? Uh...
09:04:38 <maltem> Yeah I guess that from all those papers and posts by conal about an efficient implementation
09:04:47 <sclv> I think that the semantics are probably less simple than people think.
09:04:50 <Baughn> If *conal* can't get it right, you know it's hard. Well, I've got my own attempt, but I haven't gotten very far either - too little time
09:05:08 <maltem> I was wondering, though, what reactive streams would be, if you say they're trivial
09:05:28 <Baughn> (Though I did manage a better core than conal has, through having more focus on low-level implementation-defined details of haskell.  ;)
09:05:40 <jaspervdj> I'm working on a small library and for the last release, the haddock docs failes to generate on haskell. Here is a logfile: http://hackage.haskell.org/packages/archive/hakyll/0.2/logs/failure/ghc-6.10
09:05:42 <sclv> the meaning of recursively defined frp systems is actually somewhat complicated
09:05:47 <Baughn> maltem: ..basically the same as unsafeInterleaveIO, but with time tags added on
09:06:00 <jaspervdj> I really don't have any idea on why it failed, anyone here who can help me figure this out?
09:06:05 <Baughn> maltem: They're trivial, sure. And FRP semantics are nice, but I don't think I really want to do IO like that.
09:06:32 <jaspervdj> Also, the documentation builds fine locally
09:06:36 <maltem> So, basically, you're speaking of embedding IO into FRP code?
09:07:00 <Baughn> maltem: Oh, I've got to do that anyway. Um..
09:07:20 <Baughn> maltem: You may not be very familiar with FRP as such, but I think I can show you why /implementing/ it is so hard
09:07:29 <Baughn> maltem: http://github.com/Baughn/Reactant/blob/master/FRP/Reactant/Time.hs <-- Have a look at this horror
09:07:38 <sproingie> apparently the hardest part of FRP is documenting it
09:07:46 <sproingie> there are more FRP implementations than serious applications of it
09:08:17 * Baughn seems to always end up with at least one ten-line insanely complex function in any haskell library he's working on
09:08:52 <camio> How do I "cabal install" the latest version of something from hackage? "cabal install uu-parsinglib-2.3.0" doesn't work.
09:09:58 <maltem> Baughn, that doesn't look too horroneous to me per se. I'm now used to staring at Oleg's iteratee implementation, though
09:10:03 <dcoutts> camio: that's the correct syntax to select a specific version
09:10:11 <dcoutts> camio: and it installs ok for me
09:10:13 <Baughn> @let undefined' = error $ "Undefined at " ++ __FILE__ ++ ":' ++ __LINE__
09:10:13 <lambdabot>   Improperly terminated string
09:10:18 <Baughn> @let undefined' = error $ "Undefined at " ++ __FILE__ ++ ":" ++ __LINE__
09:10:19 <lambdabot>  <local>:2:40: Not in scope: `__FILE__'
09:10:19 <lambdabot>  
09:10:19 <lambdabot>  <local>:2:59: Not in scope: `__LIN...
09:10:23 <Baughn> ..aww, no cpp?
09:11:01 <Baughn> maltem: It depends on undefined semantics of unsafePerformIO and thunk evaluation details
09:11:35 <sproingie> wouldn't __FILE__ and __LINE__ always expand to the same place?
09:11:46 <maltem> Baughn: ah. I should have looked at the first function, and its comment :)
09:11:52 <camio> dcoutts: Thanks. I forgot to do "cabal update" first. Maybe a little message would be nice there for that scenerio.
09:11:55 <Baughn> sproingie: Come to think of it. I'd have to make it a macro.
09:12:27 <Baughn> maltem: Yess. You know it's bad if you have to shorten unsafePerformIO.
09:12:37 <maltem> Defining io = unsafePerformIO is actually quite harsh.
09:13:04 <mux> yeah, this is particularly evil since most of the time io = liftIO
09:13:27 <Baughn> Well, it's not exported
09:14:15 <zygoloid> Baughn: why does 'wait' do special stuff if both are complete? any calling code presumably has to be able to handle the race condition anyway?
09:15:19 <Baughn> zygoloid: I'm not actually sure, but I dare not remove it. I probably had a good reason.
09:15:29 <Baughn> Yes. It's /that/ kind of code.
09:15:35 <zygoloid> eep!
09:18:10 <Baughn> zygoloid: Frankly, I've pretty much decided that this needs RTS support.
09:18:50 <i_am_neuron> Folks, I'm getting an error "Inferred type is less polymorphic than expected" in this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15128#a15129 Could anybody give me a clue?
09:19:31 <Baughn> i_am_neuron: I can't tell which line is #21
09:20:00 <i_am_neuron> Baughn: the topmost
09:20:06 <Baughn> #1? Ok.
09:20:07 <lunabot>  luna: parse error on input `Ok.|'
09:20:33 <zygoloid> #include <lunabot_errors>
09:20:35 <lunabot>  luna: Not in scope: `include'
09:20:47 <Baughn> i_am_neuron: I've never yet gotten existentials to work right, so I can't really help you there. :P
09:20:55 <benmachine> #id
09:20:56 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
09:21:00 <Baughn> i_am_neuron: But instead of using one, you could have an explicit field for the buildProtocol type
09:21:06 <benmachine> #undefined
09:21:07 <lunabot>  luna: Exception when trying to run compile-time code:
09:21:25 <Baughn> data Listener = L PortNumber (Protocol b => a -> b)
09:21:27 <Baughn> ..hm
09:21:27 <zygoloid> i_am_neuron: i think you'd need an explicit forall there.
09:21:46 <maltem> i_am_neuron, I think you must consider f to be of type a for *some* Factory a
09:21:48 <Baughn> You would. I wish I could phrase it in terms of exists.
09:21:48 <zygoloid> data Listener = L PortNumber (forall a. (Factory a) => a)
09:22:33 <maltem> i_am_neuron, but L wants it to be polymorphic in Factory a => a
09:22:34 <zygoloid> i_am_neuron: or maybe you want: data Listener = forall a. Factory a => L PortNumber a
09:22:48 <i_am_neuron> Baughn: yeah, buildProtocol is going to be reworked, like Reactor is already
09:22:56 <merijn> Are there any decent GUI frameworks for Haskell?
09:23:06 <i_am_neuron> zygloid: trying this now
09:23:13 <maltem> i_am_neuron, hence f is "less polymorhic than expected"
09:23:17 <zygoloid> i_am_neuron: based on the later code i think the latter is what you want
09:23:17 <Baughn> merijn: gtk2hs, most likely. Nothing very mature /and/ suited for haskell.
09:23:56 <i_am_neuron> zygloid: this: "data Listener = forall a. Factory a => L PortNumber a" means that Listener is defined ONLY for Factories, right?
09:24:06 <conal> merijn: are you looking for something functional (tractable semantics)?  or will imperative/IO do?
09:24:10 <i_am_neuron> zygloid: no other type is going to work
09:26:00 <zygoloid> i_am_neuron: it means that the L constructor can only be applied to types which are Factories
09:26:21 <merijn> conal: I don't have a very specific use in mind right now. I'm just starting out with some toy programs, but since anything non-trivial I'd want to share with friends will need a GUI of some sort (the windows console sucks) I figured I'd look around for some frameworks already.
09:26:48 <i_am_neuron> zygloid: Isn't "data Listener = L PortNumber (forall a. (Factory a) => a)" means the same? I tried both in the code, none works, but error messages are different :)
09:26:52 <zygoloid> i_am_neuron: i find GADT notation nicer for this sort of thing: data Listener where L :: Factory a => PortNumber -> a -> Listener
09:27:17 <maltem> i_am_neuron, no it's not the same
09:27:34 <zygoloid> i_am_neuron: no, they're not the same. the (forall a. (Factory a) => a) one says "the second parameter is of every type "a" such that a is an instance of Factory
09:28:00 <zygoloid> i_am_neuron: whereas the other one says that "a" is of some (unknown but specific) type which is an instance of Factory
09:29:40 <conal> merijn: gtk2hs and wxhaskell are both are pretty feature-rich.  they're very old-skool/imperative style programming, though.  of the two, i prefer the relative elegance of wxhaskell.
09:30:16 <aavogt> @hackage phooey
09:30:16 <lambdabot> http://hackage.haskell.org/package/phooey
09:30:32 <aavogt> is that abandonded?
09:30:52 <xerox> gtk2hs is very apt to fast GUI making, you draw it in glade, export an xml, load it in  main  and attach callbacks to buttons and such.
09:31:11 <conal> merijn: what keeps me from using wxhaskell now is that it's fatal to ghci.  kills its parent process when a gui exits. :(
09:31:28 <i_am_neuron> zygloid: not sure if I really feel the difference. For cases like "data Foo = forall a. Bar a => Foo a a" and "data Foo = Foo (forall a. Bar a => a) (forall a. Bar a => a)" the difference is clear, but in my case I really can't tell one from another...
09:32:06 <conal> aavogt: phooey is neglected for now.  may rise again some day.  i like the TV style better, since it's compositional.
09:32:18 <conal> aavogt: more compositional, i mean.
09:32:32 <xerox> consider http://code.haskell.org/gtk2hs/demo/glade/GladeTest.hs
09:32:41 <conal> @wiki TV
09:32:41 <lambdabot> http://www.haskell.org/haskellwiki/TV
09:33:21 <zygoloid> i_am_neuron: ok. suppose we have: data A = forall a. A a; data B = A (forall a. a)
09:33:42 <xerox> TV is really cute.
09:33:57 <zygoloid> i_am_neuron: A can be constructed given a value of any type. B can be constructed given a value of /all/ types (thus the value must be _|_)
09:33:58 <i_am_neuron> zygoloid: yep
09:34:35 <conal> the non-composability of most interaction approaches shows itself in types.  the runnable things have type m (), where m is e.g. IO or GUI.
09:35:14 <conal> while in TV, the runnables have type 'TV a' -- ie both usable and reusable.
09:35:17 <zygoloid> conversely, when pattern matching on (A a), you can't assume anything about the type of a; when pattern matching on (B a) you can assume that a is any type you like (since it must be of all types)
09:35:21 <i_am_neuron> zygoloid: so "data B = A (forall a. a)" means "I can construct value of type B using variant constructor A which accepts any type", right?
09:35:47 <i_am_neuron> "variant constructor A" = "the variant of constructor A"
09:36:24 <i_am_neuron> And from this "any type" we go directly to _|_
09:36:39 <zygoloid> the B constructor only accepts values which are of all types
09:37:00 <i_am_neuron> Yeah, that's what I meant, sure
09:37:10 <i_am_neuron> zygoloid: thanks for the explanation
09:37:46 <i_am_neuron> zygoloid: however, going back to the earlier question: as I said, none of the forall'd versions worked
09:37:50 <ccasin> i_am_neuron: so you can never apply that constructor, because nothing has type (forall a . a)
09:38:10 <Baughn> @type undefined
09:38:11 <lambdabot> forall a. a
09:38:13 <mux> undefined has :)
09:38:16 <ccasin> well, maybe you can use undefined or something
09:38:17 <mux> damn, too late again.
09:38:18 <ccasin> yeah :_
09:38:30 <ccasin> although, interestingly
09:38:34 <ccasin> ghci won't let me do it
09:38:43 <ccasin> oh, no, nevermind
09:38:54 <ccasin> yes, it works :)
09:40:54 <i_am_neuron> I've modified the code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15128#a15130 and the error remains the same
09:41:23 <ccasin> i_am_neuron: your quantifier is in the wrong place
09:41:40 <ccasin> I think you want an existential type
09:41:44 <i_am_neuron> ccasin: It has to be "data Listener = forall a. Factory a => L PortNumber a"?
09:41:51 <ccasin> yes
09:43:02 <ccasin> for example, if you wanted a data constructor which accepted terms of any type (rather than only terms which have every type)
09:43:04 <ccasin> you would write:
09:43:09 <ccasin> data C = forall a . D a
09:43:42 <i_am_neuron> OK, this + enabled extension helped, thanks guys
09:43:54 <ccasin> no problem
09:44:49 <mercury^> Is there a latex package that generates arrow diagrams from formulas?
09:45:04 * hackagebot upload: hakyll 0.3 - A simple static site generator library. (JasperVanDerJeugt)
09:45:53 <wagle> mercury^: i use kristoffer rose's xypic (?) for drawing for category theory
09:46:13 <mercury^> I do not mean categorical diagrams.
09:46:18 <ccasin> mercury: what sort of formulas?  Certainly there are packages for arrow diagrams (I like xypic too)
09:46:37 <mercury^> http://www.haskell.org/arrows/
09:46:42 <mercury^> I mean diagrams like the ones there.
09:46:56 <byorgey> oh, heh, those kinds of diagrams =)
09:47:03 <byorgey> I don't know of any
09:47:09 <mercury^> They are close to the graphical calculi for topological quantum field theories.
09:47:34 <mercury^> And I was searching for a package that let you type in formulae and generated those diagrams for you.
09:50:11 <i_am_neuron> Now similar error pops in other place, and similar type quantification doesn't help: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15128#a15131
09:50:16 <wagle> looks like ross patterson generated that pgae (but you should double check)..  you migt ping him to ask what he used
09:50:41 <mercury^> I do not want to replicate that exact style. I just want diagrams of that type in latex.
09:50:50 <sproingie> dot maybe?
09:50:58 <sproingie> er graphviz
09:51:25 <wagle> possible..  graphviz IS worth getting facile with
09:51:50 <sproingie> the ones in the arrows paper may have just been done by hand
09:52:04 <wagle> i use xfig for drawing, but its got a learning curve
09:52:10 <aavogt> conal: hmm, GuiTV-0.4 depends on phooey-2.0 which failed to install.
09:52:11 <ccasin> i_am_neuron: moving the forall a in the type of addListener outside R doesn't help?
09:52:29 <sproingie> wagle: not so much a learning curve as an unlearning curve.  namely the last 20 years of UI development
09:52:43 <conal> aavogt: what error(s)?
09:53:03 <aavogt> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15132#a15132
09:53:48 <wagle> sproingie: gnome copycatting all the worst of windows is progress?  </troll>
09:53:55 <conal> aavogt: wow -- pretty old phooey.
09:54:20 <i_am_neuron> ccasin: trying this now, some type name ambiguity popped, working to fix
09:54:26 <wagle> gui rules for xfig are a bit odd, but that that bad..  but i've been using it for 20 years
09:54:30 <sproingie> some of the old ui ideas were fine, sure.  easy to look at, no.
09:54:44 <sproingie> Xaw3d actually looks pretty nice even today
09:54:51 <ccasin> i_am_neuron: OK - do you understand the difference between those two types, though?
09:55:01 <aavogt> conal: would it make sense to build with --constraint="reactive == 0.5", (the last version before you moved stuff into FRP.*)
09:55:03 <wagle> .. not that bad ..
09:55:17 <sproingie> notions of copy and paste in those days were ... not fun
09:55:20 <conal> aavogt: oh!  good idea.
09:55:31 <aavogt> or would it not be difficult to adapt it to a newer / improved reactive?
09:55:58 <i_am_neuron> ccasin: I guess so. When forall is below the function name, this means that this function should accept the parameter of type (forall a. Factory a), which is not the same as just instance of Factory
09:55:59 <conal> aavogt: probably easy to adapt.  might only be module names.
09:56:39 <aavogt> ah, more build failures wrt moving pure out of Control.Arrow...
09:56:50 <aavogt> (when I try reactive-0.5
09:56:53 <aavogt> )
09:56:58 <conal> aavogt: sure.  sigh.
09:57:46 <ccasin> i_am_neuron: right.  when the forall is inside, addListener must work for every a that is a factory.  When it is outside R, R is a constructor that may be applied at any particular a that is a factory
09:59:02 <i_am_neuron> ccasin: thanks again
10:05:27 <aavogt> conal: what happened to mkEvent in reactive?
10:06:16 <aavogt> I see it used as: do (e,snk) <- mkEvent
10:06:36 <aavogt> but there's only a commented out export of it in src/FRP/Reactive/PrimReactive.hs
10:07:01 <conal> aavogt: i guess it's now makeEvent in Internal.TVal
10:09:27 <sproingie> "This version of Reactive has some serious bugs that show up particularly with some uses of the Event monad"
10:09:30 <sproingie> is this still the case?
10:11:48 <conal> sproingie: not sure.  viator tells me that unamb works much better in ghc 6.12.1, and he has some patches i'm reviewing to help with some subtle non-termination issues.  i don't yet have 6.12.1 on my machine.
10:12:32 * dcoutts_ installs 6.12 on his old sparc box...
10:13:04 <conal> sproingie: and i'm rethinking the Reactive implementation to use unamb less.
10:13:10 <Philonous1> Is there an estimate when gtk2hs will run on ghc 6.12 ?
10:13:29 <dcoutts_> Philonous1: ask the devs, I sent in a patch a week or so ago
10:13:40 <Philonous1> Ok
10:16:38 <sproingie> i still feel like i'm just not smart enough to grok the overall nature of FRP
10:16:52 <sproingie> CHP i like, i can get my head around processes easily
10:21:22 <johnnowak> sproingie: CHP?
10:21:40 <sproingie> communicating haskell processes
10:21:47 <sproingie> basically, csp in haskell
10:21:54 <johnnowak> ah.
10:22:27 <sproingie> very low-level thing, but easy for a coroutine junkie like me
10:33:55 <sshc> how is "get" defined for the State Monad?
10:34:34 <Paczesiowa> @src State get
10:34:34 <lambdabot> Source not found. That's something I cannot allow to happen.
10:34:39 <Paczesiowa> @src get State
10:34:40 <lambdabot> Source not found.
10:35:01 <sshc> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-State-Strict.html#State
10:40:19 <dpratt71> @pl g v = v `zip` tail v
10:40:20 <lambdabot> g = ap zip tail
10:41:14 <dpratt71> @hoogle ap
10:41:15 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
10:41:15 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
10:41:15 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
10:44:08 <artobstrel95> When will Haskell Platform with GHC 6.12 be out?
10:44:57 <sshc> in a State monad, when I do "g <- get", then why does g refer to the actual state instead of the state computation?
10:45:22 <sproingie> the terminology used for the state monad is extremely ambiguous
10:45:48 <sproingie> insofar as when you're in the state monad, g gets the actual stored state value
10:46:38 <dpratt71> why doesn't ghci like the definition of "g" as given by @pl ? "No instance for (Monad ((->) String))..."
10:47:19 <sproingie> if you have a couple hours to spare you should check out Beckman's lectures on the state monad
10:47:43 <sproingie> http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/
10:47:49 <sshc> sproingie: I'll refer to the function wrapped in a State type, (State \s -> (a, b)) as a state computation, and the value or result as the "a"
10:47:50 <dmhouse> dpratt71: you'll probably have to import Control.Monad.Instances, that particular instance definition isn't in the Prelude
10:48:14 <dpratt71> dmhouse: thanks, I'll give that a shot
10:48:30 <sshc> sproingie: "g <- get; ..." translates to "(State $ \s -> (s, s)) >>= \g -> ..."
10:48:30 <Philonous> Or you may want to figure out for yourself how ((->) String) is a Monad. might be quite instructive
10:48:49 <dpratt71> dmhouse: ding! thanks again
10:49:32 <sshc> sproingie: shouldn't g point to the state computation (wrapped in State runState)?
10:49:39 <dpratt71> @hoogle [b] -> [(b, b)]
10:49:39 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
10:49:40 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
10:49:40 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
10:50:57 <artobstrel95>      fact2 :: Integer -> Integer
10:50:57 <artobstrel95>      fact2 x = f x y
10:50:57 <artobstrel95>        where
10:50:57 <artobstrel95>          f n e | n < 2  = 1
10:50:57 <artobstrel95>                | e == 0 = n * (n - 1)
10:50:58 <artobstrel95>                | e > 0  = (f n (e `div` 2)) * (f (n - (e * 2)) (e `div` 2))
10:51:00 <artobstrel95>          y = 2 ^ (truncate (log (fromInteger x) / log 2))
10:51:08 <sproingie> artobstrel95: please use the pastebin
10:51:14 <artobstrel95> sorry
10:51:47 <sshc> sproingie: what exactly does "g" point/refer to?
10:52:15 <sshc> sproingie: it does refer to the state computation (wrapped in State runstate), right?
10:52:30 <artobstrel95> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15133#a15133
10:52:42 <sproingie> it does, though for practical purposes you can simply treat it as the state value itself
10:52:44 <sshc> sproingie: but I'm seeing it used as the result of the state being run, or evalState
10:52:52 <artobstrel95> why fact2 is quicker than fact3
10:53:09 <sclv> quick question -- what's the proper rts option to just turn gc off for a microbenchmark?
10:54:33 <mjd_> I wrote "instance Rational Surreal where fromRational x = undefined"  and then ghci did not complain that I failed to define either "recip" or "(/)".  Why no warning message?
10:55:21 <Twey> Perhaps they have default implementations?
10:56:20 <Twey> Probably, \x y -> toRational $ fromRational x / fromRational y
10:56:23 <mjd_> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Prelude.html#t%3AFractional says that a minimal complete definition includes fromRational and one of recip or (/).
10:56:59 <Twey> I don't think it's GHC is smart enough to check for ‚Äòone of‚Äô
10:57:05 <Twey> s/it's //
10:57:20 <mjd_> Oh,right.  Probably each one is defined in terms of the other.
10:57:22 <mjd_> Thanks!
10:57:51 <Twey> Yeah
10:58:13 <mjd_> Yes, that's exactly it.  Thanks again.
10:59:59 <sshc> Saizan_: in a State monad, when I do "g <- get", why does g refer to the result instead of the state computation (the runState function wrapped in the State constructor)?
11:00:54 <sshc> Saizan_: "g <- get; ..." translates to "(State $ \s -> (s, s)) >>= \g -> ..."
11:01:15 <sproingie> sshc: i'm not good at explaining it unfortunately.  State is always about sequencing state transformer functions.  get is a sort of identity function that does nothing to the state, and put returns nothing useful (unit acually) but yields a new state for the next transformer
11:01:20 <byorgey> sshc: that's right, now unfold the definition of >>= for State.
11:01:35 <sproingie> the higher-order-ness of it makes it hard for me to explain verbally
11:02:05 <byorgey> @src State (>>=)
11:02:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:02:34 <mjd_> I found that writing out the complete defintiion of put x >>= get  in paper and expanding it completely was very enlightening.
11:02:38 <mjd_> I did this last week.
11:02:39 <mjd_> Hi, Brent.
11:03:22 <sshc> byorgey: aha
11:04:16 <sshc> so >>= kind of evaluates the previous monad or removes the monad wrapper and passes it onto the next function
11:05:47 <Vulpyne> Sort of. But it can also do other stuff, take for example something like the Maybe monad.
11:06:19 <byorgey> hi mjd_
11:06:29 <byorgey> mjd_ = yrlnry ?
11:06:54 <Vulpyne> > Just 1 >>= \x -> Nothing >>= \y -> Just 2
11:06:55 <lambdabot>   Nothing
11:07:02 <Vulpyne> > Just 1 >>= \x -> Just 0 >>= \y -> Just 2
11:07:03 <lambdabot>   Just 2
11:07:31 <mjd_> byorgey: yes
11:07:39 <yrlnry> Better.
11:08:05 <byorgey> heh, I don't care which you use, just making sure I knew who you were =)
11:08:24 <Vulpyne> > [1..10] >>= return . (+10)
11:08:25 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
11:08:36 <Vulpyne> sshc: As you can see, it doesn't just unwrap and pass to a function.
11:08:57 <sproingie> what >>= is pretty arbitrary as long as it obeys the monad laws
11:09:03 <Nomad010> so i'm looking to learn haskell
11:09:20 <byorgey> indeed, "unwrap" isn't the right idea since it reinforces the (wrong) idea that something of type  "m a" contains exactly one value of type "a"
11:09:24 <Nomad010> i have done a major in maths though i never touched algebra
11:09:34 <Vulpyne> Some people have called it an "electric semicolon".
11:09:40 <byorgey> but "m a" can contain no a's (e.g. Maybe) or many (e.g. [])
11:09:45 <mauke> Nomad010: do you know what a group is?
11:09:57 <Nomad010> ok i lie
11:09:59 <byorgey> Nomad010: cool, you have come to the right place =)
11:10:03 <Nomad010> i did introductory algebra
11:10:09 <Nomad010> we covered groups
11:10:25 <mauke> ok, that will suffice
11:10:27 <yrlnry> Hmm.   Data Foo a = Foo;   instance Foo Monad where return x = Foo; (Foo >>= f) = Foo;
11:10:32 * yrlnry chuckles.
11:10:35 <sproingie> when i went to school we never covered abstract stuff like groups in algebra or otherwise
11:10:47 <byorgey> mauke: suffice for what?
11:10:56 <sproingie> it was all solving systems of linear equations and crap like that
11:11:05 <mauke> byorgey: understanding Monoid and Monad
11:11:21 <Nomad010> i have vague knowledge of what a monoid is
11:11:40 <Nomad010> and very vague knowledge from reading some haskell stuff on what a monoid is
11:11:55 <byorgey> Nomad010: a monoid is a set with an associative binary operation and an identity element.
11:12:00 <Nomad010> yes
11:12:06 <byorgey> Nomad010: like a group but without the requirement of inverses.
11:12:09 <byorgey> that's all. =)
11:12:17 <Nomad010> i don't know any theorems for monoids though
11:12:33 <dcoutts_> though that doesn't tell you why they're useful or why they crop up everywhere
11:12:36 <byorgey> oh, there aren't that many interesting theorems.  the point is just that they come up all the time.
11:13:09 <dcoutts_> and let you do parallel reductions, relying on associativity
11:13:12 <Nomad010> ok
11:13:41 <Nomad010> anything like categories i am clueless on
11:13:51 <yrlnry> Nomad010: the canonical example of a monoid is the set of integers under multiplication
11:13:59 <Nomad010> ya
11:14:01 <yrlnry> Nomad010: or the set of strings with concatenation
11:14:02 <byorgey> Nomad010: you don't need to know any category theory to learn Haskell.
11:14:11 <Philonous> yrlnry: That's not a monad. return >=> f == f doesn't hold.
11:14:14 <sproingie> addition also works, and conveniently the zero is actually zero
11:14:18 <Accidus> yrlnry, I thought the canonical example of a monoid is the set of finite lists under concatenation?
11:14:20 <byorgey> Nomad010: though if you are mathematically inclined you may pick up some CT while learning Haskell.  but that's optional.
11:14:28 <Nomad010> ok, just letting you know that my algebra knowledge stops abruptly :p
11:14:32 <Accidus> (Because that's the free monoid of a given set)
11:14:41 <yrlnry> Accidus: yeah, that is a better example.
11:14:50 <yrlnry> That's strings; I should have said it first.
11:14:52 <byorgey> Philonous: it doesn't?
11:14:53 <Trinithis> Nomad010: You dont really need thms for haskell. The only reason why understanding something like groups or vector spaces is just for the notiion of an abstract set of things
11:14:59 <sproingie> i'd say addition and multiplication are more accessible examples
11:15:07 <Philonous> byorgey: f = undefined
11:15:08 <Nomad010> ok
11:15:09 <Trinithis> In fact I've never used a thm for haskell
11:15:10 <yrlnry> Philonous: yes, it does.
11:15:11 <Accidus> sproingie, to a computer scientist? :P
11:15:23 <sproingie> beckman uses clock arithmetic for his example
11:15:27 <zygoloid> yrlnry: given f x = undefined, return a >>= f = Foo >>= f = Foo /= f a = undefined. ;-)
11:15:41 <Nomad010> my friend Taejo, is a genius and knows haskell
11:15:44 <byorgey> Philonous: sigh, away from me with your heathen partial programs!
11:15:48 <yrlnry> lots of monads violate the monad laws when given _|_ values.
11:15:58 <Nomad010> and he did all that sort of stuff which makes me quiver
11:16:32 <sproingie> you should see the stuff oleg gets up to
11:16:45 <zygoloid> yrlnry: they shouldn't ;-)
11:16:47 <Nomad010> lol, *shudders*
11:16:49 <byorgey> Nomad010: hehe, yeah, don't worry about it.  you will be just fine. =)
11:17:04 <Nomad010> so another friend suggested practicing on project euler
11:17:14 <sproingie> if you like math it's great
11:17:24 <Nomad010> the thing is, i am heavily rooted in imperative programming
11:17:51 <kmc_> Euler is a good project for learning how to think in terms of pure functions
11:18:24 <Nomad010> yeah, i've done a couple dozen in C++/python
11:18:28 <Trinithis> yrlnry: is violating on bottom a bad thing?
11:18:34 <kmc_> it's a good very first start to Haskell
11:18:40 <byorgey> Nomad010: so are most people who start learning Haskell.  PE sounds like a great place for you to start.  but read a tutorial or two first, at least partially
11:18:50 <zygoloid> yrlnry: data Foo a; instance Monad Foo where; is a better trivial monad imo
11:18:56 <Nomad010> i've read a couple of tutorials
11:19:03 <Nomad010> i think the moldy bread one
11:19:07 <kmc_> the Haskell features you need to solve Euler problems only barely scratch the surface of the language
11:19:10 <byorgey> moldy bread!?
11:19:18 <Nomad010> lol
11:19:21 <byorgey> I haven't heard of that one.
11:19:23 <zygoloid> Trinithis: there's the outside chance that some code might be _|_ or not depending on the compiler you use
11:19:29 <kmc_> Nomad010, did you see LYAH and RWH?
11:19:30 <Nomad010> i have definitely screwed up that name :p
11:19:33 <kmc_> @where RWH
11:19:33 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:19:35 <blackh1> Nomad010: A lot of us are heavily rooted in imperative programming, like me.  I found the best way was to write lots of real programs, but do them in such a way as to make as much of the code pure as possible.  That is, factor all the IO to the outside.  Doing that naturally made me pick up the "functional way".
11:19:38 <kmc_> @where LYAH
11:19:38 <lambdabot> http://www.learnyouahaskell.com/
11:19:45 <zygoloid> Trinithis: (iirc the Report allows compilers to assume the monad laws hold when desugaring do-notation)
11:19:50 <Nomad010> LYAH is the one i saw
11:19:59 <Trinithis> alright
11:20:01 <kmc_> Nomad010, ah.  i strongly recommend you look at RWH also
11:20:02 <Nomad010> i thought moldy bread because of that shopping list
11:20:06 <Nomad010> ;p;
11:20:13 <Trinithis> Are there any monads in the standard libs that violate it with bot?
11:20:14 <kmc_> when you start out, you should not even worry about doing IO.  the interactive loop in ghci will take care of that for you
11:21:08 <Nomad010> i've also heard stuff dynamic programming is a haxx0r mission in haskell
11:21:19 <byorgey> dynamic programming is easy in Haskell.
11:21:24 <kmc_> i cannot decipher this statement
11:21:30 <byorgey> just use a lazily construced read-only array.
11:21:41 <kmc_> Nomad010, "dynamic programming" has a specific idiosyncratic meaning
11:21:42 <sclv> anyone used criterion here?
11:21:43 <Nomad010> maybe it was memoisation i was thinking of
11:21:47 <kmc_> ah yes
11:21:53 <Nomad010> ya
11:21:53 <kmc_> so you do mean that
11:21:55 <byorgey> you don't even have to worry about the correct order in which to compute the entries, the Haskell runtime figures that out for you.
11:22:01 <sclv> how does it handle parallelism?
11:22:04 <kmc_> Nomad010, you should look at the data-memocombinators package on Hackage
11:22:11 <byorgey> memoisation isn't too hard either, using tools that other people have made
11:22:13 <Nomad010> lol
11:22:14 <sclv> i think it might be measuring processor time rather than clock time?
11:22:18 <byorgey> like the memocombinators library
11:22:20 <zygoloid> Nomad010: you can either do it via lazy data structures (in which case it's easy if you can construct the right structure) or you can do it via mutable data structures (which is often painful)
11:22:20 <kmc_> Nomad010, i rarely do explicit DP in Haskell.  it's easier to just write the recursion and memoize it
11:22:30 <Nomad010> ahh ok
11:22:32 <thegoatlikedit> how can I use Haskell to get laid?
11:22:33 <blackh1> Nomad010: There's surprisingly little written about it to help imperative programmers out of the imperative paradigm, and I think that's partly because it's a bit difficult to pin down. It comes naturally after a while, but I found it was very helpful to learn from others.
11:22:37 <Trinithis> lol
11:22:39 <yrlnry> It was *always* easier to just write the recursion and memoize it.
11:22:44 <kmc_> @faq Can Haskell get thegoatlikedit laid?
11:22:45 <lambdabot> The answer is: Yes! Haskell can do that.
11:22:51 <yrlnry> Dynamic Programming is an anachronism.
11:23:01 <Codex_> memoization is pretty nice tool.
11:23:01 <Nomad010> lol
11:23:06 <thegoatlikedit> Exciting
11:23:10 <Trinithis> Just say "Monad" in bed, and that will do the trick.
11:23:16 <byorgey> thegoatlikedit: (1) learn Haskell (2) find girls who like guys with Haskell Skills (3) profit
11:23:25 <blackh1> sclv: I used criterion recently
11:23:29 <Nomad010> it will encapsulate the side effects too
11:23:30 <yrlnry> Perl got me laid.  Haskell, not so far.
11:23:40 <thegoatlikedit> Is it faster than chrloroform?
11:23:43 <zygoloid> blackh1: the middle step of your plan evaluates to _|_
11:23:51 <zygoloid> s/blackh1/byorgey/
11:23:53 <blackh> yrlnry: It works for me, but then I am married.
11:24:15 <thegoatlikedit> sorry I meant chloroform
11:24:23 <thegoatlikedit> Or whatever you use these days
11:24:36 <sclv> blackh: did you use it on parallel code
11:24:43 <Codex_> what you think about hom(axb,c) = hom(a,hom(b,c)) ?
11:25:04 <zygoloid> thegoatlikedit: i hear rohypnol is the new chloroform, but google go skills work too
11:25:06 <byorgey> Codex_: that's called currying.  what about it?
11:25:15 <thegoatlikedit> byorgey: this step 2 I think is hard
11:25:19 <blackh> sclv: Actually I used it on some IO code, but I know all about forcing evaluation, so I can probably help you get it working.
11:25:24 <Twey> byorgey: Is it?
11:25:31 <blackh> sclv: Obviously if it's taking nearly zero time, it's probably not getting evaluated. :)
11:25:37 <Codex_> twey: yes
11:25:39 <sclv> the question is really just how it handles parallelism
11:25:44 <Twey> Codex_: I think that ‚Äòa‚Äô and ‚Äòb‚Äô are undefined
11:25:46 <Nomad010> so has anybody implemented say fortune's algorithm in haskell?
11:25:55 <sclv> i.e. is it giving processor time or clock time?
11:26:02 <thegoatlikedit> zygoloid: yeah but that has to be slipped in drinks and all that jazz, seems like a waste of alcohol. Bitches aint that much (beer > woman)
11:26:03 <byorgey> Twey: what?
11:26:20 <kmc_> the most popular date rape drug, by far, is alcohol
11:26:21 <Codex_> twey: it's CT stuffs.
11:26:28 <byorgey> thegoatlikedit: that's enough.
11:26:34 <Twey> Ah, I thought we were talking Haskell.  Silly me.  ;)
11:27:06 <thegoatlikedit> byorgey: oh I did not know you were a woman
11:27:12 <sclv> i'm dumbly wasting time with jdh's "efficient parallel mergesort" problem
11:27:15 <blackh> sclv: Actually I don't really know. I would expect it uses "wall clock" time. You might have to read the code.
11:27:18 <byorgey> thegoatlikedit: I am not, but I respect them.
11:27:32 <kmc_> ah this is fun
11:27:37 <thegoatlikedit> byorgey: Sure I do too, but come on. A good beer?
11:27:51 <Trinithis> @quote
11:27:51 <lambdabot> nixon says: I ha\/E zeeN it. I xnOW. I 8eLIe\/3 T|-|At.
11:27:56 <kmc_> thegoatlikedit, Haskell may not get you laid, but trolling IRC seems like a strictly worse strategy
11:28:03 <kmc_> @. elite nixon
11:28:03 <lambdabot> $01u+IOnz are No7 thE AN$\/\/eR.
11:28:03 <Nomad010> ok so google doesn't show much hope
11:28:06 <byorgey> ok, kmc_, thegoatlikedit, take it to #haskell-blah, please.
11:28:12 <kmc_> meh i'm done
11:28:26 <yrlnry> byorgey: look for a surprise in your email.
11:28:32 <thegoatlikedit> okay
11:28:38 <byorgey> oh boy! a surprise!
11:28:44 <yrlnry> I*good* surprise.
11:29:06 <thegoatlikedit> remember it's not rape if you yell surprise
11:29:17 <Codex_> byorgey: what other functors for F and G you can use for it instead of F(a) = axb and G(c) = hom(b,c)?
11:29:19 <Trinithis> ahah
11:29:25 <blackh> thegoatlikedit: Good bye
11:29:27 <zygoloid> thegoatlikedit: remember on IRC people can't tell whether you're serious
11:29:41 <sclv> ah uses posix time
11:29:46 <kmc_> lol, an internet meme
11:30:29 <byorgey> yrlnry: wow! I am downloading it now...
11:30:35 <Codex_> byorgey: I mean the normal hom(F(a),c) == hom(a,G(c)) thing.
11:30:35 <thegoatlikedit> zygoloid: In space nobody can hear you clean
11:31:35 <byorgey> Codex_: functors F and G for which that holds are called adjoint.
11:31:59 <byorgey> adjoint functors come up all over the place.
11:33:06 <Nomad010> stuff like that scares me
11:33:07 <yrlnry> byorgey: see diagram on page 20 (70)
11:33:33 <Nomad010> hom(F(a),c) == hom(a,G(c)) - why is that useful for programming?
11:33:46 <thegoatlikedit> homomorphisms?
11:33:49 <Nomad010> ya
11:33:51 <thegoatlikedit> oh that is very useful
11:34:03 <thegoatlikedit> All of category theory is as well
11:34:03 <kmc_> Nomad010, very indirectly
11:34:10 <Nomad010> lol
11:34:12 <byorgey> yrlnry: yes, I just found it.   wow, this is fantastic. =)
11:34:15 <monochrom> hom(F(a),c) == hom(a,G(c)) seems to be part of an adjunction.
11:34:24 <kmc_> you don't need to know any category theory to use Haskell
11:34:39 <thegoatlikedit> kmc_: you don't need a drivers license to drive a car
11:34:39 <Nomad010> so would galois connections and stuff like that be useful?
11:34:44 <Nomad010> ok
11:34:44 <Accidus> thegoatlikedit, what can you use category theory for?
11:34:45 <byorgey> thegoatlikedit: no, the 'hom' here means 'hom-set', the set of arrows in a category between to objects
11:34:48 <yrlnry> byorgey: Merry Christmas, or whatever you prefer.  :)
11:34:53 <thegoatlikedit> Accidus: anything
11:34:57 <byorgey> it doesn't really have to do with homomorphisms necessarily
11:35:06 <Accidus> thegoatlikedit, That doesn't sound very useful
11:35:11 <kmc_> category theory is a sort of meta-theory tying together results from algebra, geometry, topology, logic, etc.  if you like, you can use it to tie results from Haskell into those
11:35:20 <byorgey> yrlnry: thanks! and yes, Christmas is appropriate. =)
11:35:21 <Nomad010> yeah
11:35:39 <Nomad010> i remember Taejo talking about proof by pictuer
11:35:48 <Nomad010> *picture
11:35:58 <Accidus> kmc_, can you give an example of tying several results together using category theory?
11:36:05 <Nomad010> in category theory
11:36:17 <kmc_> Accidus, i'll bet other people can give a better example
11:36:29 <kmc_> i will step aside due to total math noobage
11:37:01 <kmc_> @quote higher-dimensional
11:37:01 <lambdabot> Cale says: I swear that most of higher-dimensional category theory must have been arrived at by some guys sitting around in a room with a blackboard and saying "What if a drew a diagram like *THIS*!?
11:37:02 <lambdabot> " and drawing some insane scribble up on the blackboard, and then everyone tries to figure out how to turn it into meaningful mathematics.
11:37:14 <Nomad010> lol
11:37:24 <Accidus> lol
11:37:47 <maltem> I don't understand this space leak, but it's the first time I'm fiddling with ForeignPtr. Anyone? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15134
11:38:04 <monochrom> pushouts solve the diamond problem.
11:38:45 <yrlnry> Category theory is cool because it allows me to win arguments with my friend the professional mathematician who knows no category theory.
11:38:55 <Nomad010> lol
11:38:55 <thegoatlikedit> byorgey: You're right, I checked my old book
11:39:09 <Accidus> yrlnry, Can you explain?
11:39:20 <elspru> how to reverse order of string? i.e. instead of "abc" "cba" ?
11:39:27 <yrlnry> elspru: reverse
11:39:28 <thegoatlikedit> anyways category theory is extremely useful and if you are in the position to take a course on it I highly recommend it
11:39:29 <sclv> okay another criterion question -- the mean it provides is higher than the peak on the kernel density graph.
11:39:33 <monochrom> And in general use colimits for multiple inheritance where the dependency DAG is arbitrary.
11:39:45 <sclv> is there some output that just gives that peak?
11:39:50 <Nomad010> thegoatlikedit: i was in a position to take a course in it a year ago
11:39:53 <sclv> or is it only idsplayed in the graph?
11:40:04 <Nomad010> algebra is a third year maths course at uct
11:40:06 <kmc_> yes it is useful for understanding maths.  however, a lot of people are under the impression that you need it to use Haskell, which is simply false
11:40:26 <thegoatlikedit> Nomad010: I took it and got an A in it and now I have forgotten averythign about it, but I remember that it was amusing
11:40:30 <dbelange> CT makes me haskell so much faster
11:40:33 <Nomad010> lol
11:40:36 <Accidus> thegoatlikedit, but you haven't gave evidence why it's useful. It might be very /interesting/, but why is it useful?
11:40:42 <Accidus> * haven't given
11:41:09 <thegoatlikedit> Accidus: You discover interesting properties and do highly mechanical proofs. That in itself is very useful
11:41:35 <kmc_> maltem, hmm, i'm looking and can't see anything wrong
11:41:41 <Accidus> thegoatlikedit, doing mechanical proofs is useful? I'd say the other way around...
11:41:44 <kmc_> do you have any more information about how the leak is occurring?
11:41:51 <Accidus> thegoatlikedit, If they're mechanical, let a machine do them.
11:41:59 <Nomad010> lol
11:42:01 <thegoatlikedit> Accidus: You are a machine
11:42:10 <thegoatlikedit> Accidus: Put yourself to good use
11:42:19 <kmc_> maltem, well, none of your mallocs will free until you reach the final iteration of "loop"
11:42:31 <Accidus> thegoatlikedit, can you give an example of an interesting property discovered with category theory? Preferably one that couldn't have been discovered otherwise
11:42:32 <kmc_> it will reallocate every time
11:42:43 <kmc_> maltem, probably you want to allocate and reuse a single buffer
11:43:07 <Accidus> thegoatlikedit, That's just Church's Thesis ;-) (anything achieved by a human being can be achieved by a suitable Turing machine)
11:43:15 <kmc_> oh dear
11:43:23 <monochrom> nomad010 = do { putStrLn "lol"; threadDelay 60000000; nomad010 }
11:43:29 <CalJohn> Accidus: that's not quite it
11:43:36 <Nomad010> hmm never
11:43:40 <maltem> kmc_, ok that makes sense, so I'll basically shuffle around the first few lines of "loop"
11:43:49 <kmc_> sixty million microseconds
11:43:56 <CalJohn> Accidus: hylomophisms are a simple, useful thing from CT (ish?)
11:43:57 <Nomad010> factor that in monochrom :p
11:44:07 <kmc_> maltem, i think you want to allocate the buffer, then pass it to loop
11:44:09 <thegoatlikedit> Accidus: The point of it is to connect structures and see if they share certain properties. You can save yourself a lot of work that way
11:44:24 <monochrom> My Turing test includes the halting problem.
11:44:45 <Nomad010> hmm lol is it an oracle?
11:44:47 <elspru> yrlnry: thanks :)
11:44:53 <Accidus> Which ones are the hylomorphisms? unfold and then fold?
11:45:05 <maltem> kmc_, what would I do, though, if I actually wanted to discard every buffer in turn? Not that it would make much sense, but afaics there's no explicit "free" for ForeignPtrs?
11:45:16 <CalJohn> hylomorphisms are otherwise known as list fusion or stream fusion
11:45:25 <Accidus> thegoatlikedit, but surely there are specific examples?
11:45:26 <Codex_> accidus: main advantage of category theory seems to be that it makes connections between different branches of mathematics explicit. So you can take theorem from one branch of mathematics and convert it to theorem in another branch, just by applying mechanical tools available in category theory.
11:45:28 <thegoatlikedit> Accidus: It is also an excellent way to make time pass
11:45:33 <CalJohn> I'm not really very knowledgable about CT though
11:45:40 <kmc_> maltem, you'd need to make the recursive call outside the argument to mallocForeignPtrBytes
11:46:00 <kmc_> an easy way is to have that block return the next IO action
11:46:06 <Accidus> Codex_, Do you? Or do you have to generalise the theorem into category theory and then reinstantiate it to get the result in the other field?
11:46:07 <thegoatlikedit> Accidus: There are myriads of concrete uses
11:46:15 <kmc_> loop n = do act <- mallocForeignPtrBytes ...; act
11:46:23 * kmc_ <3 higher-order imperative programminc
11:46:24 <maltem> kmc_, ok thx
11:46:36 <Codex_> accidus: it's just stating the same thing in different terminology
11:46:45 <Accidus> thegoatlikedit, If there are, surely you can name a few :)
11:46:49 <kmc_> maltem, you have to make sure the buf is not reachable from the IO action you returned
11:47:08 <kmc_> maltem, also realize that finalization is nondeterministic and you really have no control over how long it takes after the last reference disappears
11:47:25 <kmc_> if you need that control, use explicit malloc and free
11:48:09 <Accidus> Codex_, no it's not, really. For example, matrices and numbers are both instances of the same thing --- vector space. But theorems about numbers don't always translate to theorems about matrices, even if the language makes sense (easy example: ab = ba). Only the theorems that can be proven for vector spaces can be translated in this way.
11:48:29 <kmc_> but once you prove a theorem for vector spaces, you get it for free for matrices and numbers
11:48:30 <maltem> indeed, reusing the buffer speeds things up nicely
11:48:35 <kmc_> cool
11:48:40 <Codex_> accidus: it doesnt make things that are fundamentally different to be the same thing.
11:50:14 <Accidus> Codex_, I can understand that. And kmc_, the difference is that I /know/ what vector spaces are useful for. But you haven't given examples why category theory is useful (apart from CalJohn, with Hylomorphisms)
11:51:05 <monochrom> I don't go around evangelizing "haskell is useful" or "category theory is useful".
11:51:12 <kmc_> "data NonTermination: Thrown when the runtime system detects that the computation is guaranteed not to terminate. Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not."
11:51:27 <Nomad010> categories are useful if you have prediliction for drawing graphs
11:51:48 <monochrom> I don't draw any graph when doing category theory.
11:52:13 <thegoatlikedit> Accidus: I looked around a little and flipped through my book and did not find anything useful, you just have to trust me on this one. It is in fact extremely useful and I think you should devote a lot of time to learning about it
11:52:14 <Nomad010> well if you like drawing graphs, categories are for you :p
11:52:40 <Accidus> thegoatlikedit, Ah...
11:52:44 <Nomad010> lol
11:52:52 <monochrom> http://wwwhome.cs.utwente.nl/~fokkinga/#detail_0000003536  no chasing diagrams, just do algebra.
11:53:11 <kmc_> real ultimate coalgebra?
11:53:57 <monochrom> I also brought up pushouts and colimits but Accidus didn't see it.
11:54:23 <monochrom> Or maybe did see but didn't know they are also category theory.
11:54:40 <Nomad010> i was looking for a book called "category theory for computer scientists", but my friend said it was that much of a gentle approach to CT
11:54:44 <Codex_> accidus: category theory being useful has two aspects in it: 1) many different things are categories. 2) categories are rich enough that it provides plenty of theorems to work with....
11:54:48 <Nomad010> *wasn't
11:54:56 <thegoatlikedit> monochrom: put that pdf somewhere else
11:55:23 <monochrom> Why?
11:55:26 <Codex_> I found 2 good books about CT: "Sets for mathematics", and "Categories for working mathematician". But you'll need few years time to read them.
11:55:35 <thegoatlikedit> why not?
11:55:44 <Nomad010> lol
11:55:47 <monochrom> OK, I don't know what you mean.
11:55:56 <thegoatlikedit> then why did you say why?
11:56:10 <Nomad010> that pdf dne
11:56:10 <monochrom> Are you just trolling me?
11:56:24 <monochrom> OK, one moment.
11:56:45 <Accidus> thegoatlikedit, Well, for future reference: semantics for programming languages rely heavily on category theory, as you don't have to commit yourself to a particular model but talk about them generically. Low dimensional topology: by noting that categories of knots and categories of vector spaces are the same instance of a single categorical concept, you can define a translation from knots to vector spaces, obtaining knot invariants, allowing you
11:56:45 <Accidus> to tell knots apart (which is really what knot theory is about), category theory is very useful to algebraic topology, giving a common framework for many topological constructs, category theory is very useful in logic, where you can use topos theory to obtain insights about deep results in logic. Just to name a few uses.
11:56:57 <monochrom> I have no control over that web page. But I can upload my own copy.
11:57:18 <Nomad010> cool thanks monochrom
11:57:20 <kmc_> @src ($!)
11:57:20 <lambdabot> f $! x = x `seq` f x
11:58:01 <thegoatlikedit> Accidus: exactly and that has helped a lot of people in their day to day life
11:58:21 <Accidus> thegoatlikedit, It helps me in my day to day life :)
11:58:53 <Accidus> thegoatlikedit, But after giving proper semantics to languages, you can try to mimic them syntactically or fit the language better to the semantics and you get... Haskell!
11:59:04 <Nomad010> 'category theory helps me in my every day life' - lol
11:59:47 <yrlnry> Category theory has helped a lot of people in day to day life by showing the way to improved algorithsm for ditchdigging.
11:59:48 <Accidus> I also didn't mention about unifying and directing research, as it's much more vague and harder to explain
11:59:48 <monochrom> I only have a gzipped postscript copy. http://www.vex.net/~trebla/tmp/mmf92b.ps.gz
11:59:52 <thegoatlikedit> Nomad010: You can impress ladies with it
12:00:06 <yrlnry> Also, swilling cheap beer in front of the TV can be understood as an instance of an adjoint functor.
12:00:08 <Accidus> Research is way too specialised... I should say knowledge.
12:00:15 <thegoatlikedit> thanks
12:00:16 <kmc_> all right, best category theory pickup lines
12:00:18 <yrlnry> So never say that Category Theory isn't relevant to everyday life.
12:00:18 <kmc_> you guys must have some
12:00:24 <Nomad010> monochrom: i don't suppose you have the one below it?
12:00:30 <Codex_> nomad010: well, for a programmer it's very useful to know CT. My code design changed very much after reading CT. It just highlights importance of certain things...
12:00:34 <Nomad010> Law and Order in Algorithms
12:00:45 <Accidus> Codex_, any code design?
12:00:51 <monochrom> I have that one as gzipped postscript too. One moment.
12:00:52 <Accidus> Codex_, can you give examples?
12:00:57 <Nomad010> awesome thanks
12:01:21 <Codex_> accidus: f :: Int -> Int. These signatures of functions you'll understand much better after reading CT.
12:01:28 <monochrom> http://www.vex.net/~trebla/tmp/mmfphd.ps.gz
12:01:34 <Nomad010> thanks
12:01:37 <thegoatlikedit> I like 80 pages better than my 300 pages book
12:01:46 <thegoatlikedit> Now I have a nice paperweight
12:01:50 <Accidus> Codex_, oh, you mean using generics?
12:02:04 <Accidus> Codex_, or pattern matching on integers?
12:02:27 <Codex_> accidus: things like "diagram commutes", "composition".
12:02:29 <johnnowak> Codex_: is any of this CT-influnced code of yours available publicly?
12:02:51 <Codex_> johnnowak: it's c++ code mostly :(
12:03:15 <Accidus> Codex_, I don't get you're point
12:03:46 <Accidus> Codex_, You understand things like "function from integers to integers" better than before? In what sense? and how did your design changed?
12:05:15 <Codex_> accidus: how to combine those functions. If you have more than one of them.
12:05:27 <kmc_> you compose them?
12:05:49 <kmc_> i don't think most people learn about function composition for the first time by studying category theory
12:05:53 <Codex_> accidus: normal composition of the functions. And then how you get the same result if you follow the diagram in two different paths.
12:06:01 <Accidus> Codex_, you don't need to know category theory to know about composition, that's the first thing you learn in any course in math
12:06:14 <kmc_> is the lesson from CT "function composition is associative"?
12:06:28 <Codex_> kmc_: that's very small part of it.
12:06:42 <thegoatlikedit> CT is more of a meta theory than anything that will help you gain understanding of soemthing
12:07:01 <thegoatlikedit> that is very useful by the way
12:07:07 <thegoatlikedit> can save you a lot of time
12:07:16 <jlouis> After CT you'll go: Oh, that is just a left adjoint. People not knowing CT will then be boggled
12:07:20 <Accidus> Codex_, if you had to take one thing out of CT, it shouldn't be "composition is associative". It should be "arrows are everything"
12:07:35 <Codex_> accidus: lets take another example: ! :: T->1. true :: 1->2.  p :: T->RxRxR. ch :: RxRxR ->2. // subset of RxRxR space.
12:08:21 <Codex_> check all ways how those functions fit together with composition.
12:08:30 <jlouis> Bug found, now to find the fix.
12:08:42 <Accidus> Codex_, why?
12:09:12 <Codex_> there is two paths in it. From T->1->2. and T->RxRxR->2. Both paths are giving the same result.
12:10:35 <Accidus> Codex_, what's p and ch?
12:11:04 <yrlnry> ch is a subset of R^3.
12:11:23 <Accidus> and p?
12:11:24 <yrlnry> ch takes an element of R^3 to True if the element is in the subset, and to False if not.
12:11:45 <Codex_> accidus: p is a function which just chooses elements from RxRxR which are part of a subset of RxRxR. ch is characteristic function which will decide if a point in RxRxR is part of the subset or not.
12:12:06 <thegoatlikedit> stop this sherade, someone posted a CT book. Read it and do the exercises(if there are any)
12:12:34 <i_am_neuron> Folks, I'm fighting with existential quantifiers, can't get them to work right. Now can't resolve type ambiguity: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15137#a15137 Could someone help?
12:12:40 <Accidus> Codex_, so you have to choose p and ch that are compatible, otherwise it wouldn't commute
12:13:01 <kmc_> i_am_neuron, sure, i'll take a look
12:14:03 <Accidus> thegoatlikedit, lol, thanks. It's just that I'm planning on giving a talk on why category theory is useful and worthwhile to know, and was wondering whether you could base your claims better than me.
12:14:16 <yrlnry> Accidus: right, that's the whole point.
12:14:30 <yrlnry> Accidus: that's why we bothing discussing p -> 1 -> 2 in the first place.
12:15:21 <Accidus> yrlnry, Ah, pullbacks
12:15:29 <Accidus> ?
12:16:07 <yrlnry> Accidus: yes.
12:16:13 <yrlnry> http://en.wikipedia.org/wiki/Subobject_classifier
12:16:15 <kmc_> i_am_neuron, what if you remove your type signature
12:16:45 <Codex_> yrlnry: yes, that example was exactly that.
12:17:00 <thegoatlikedit> Accidus: I always thought it was because you could define some "thing" to be a category and prove useful things about it. Later on you could save yourself a lot of time when you encountered a second thing and bridged the two with functors or showing that the new thing is a subcategory of the other. That way you get a lot of properties for free.
12:17:19 <Accidus> thegoatlikedit, that's some of it, but not all of it.
12:17:39 <johnnowak> Accidus: useful and worthwhile for whom?
12:17:39 <i_am_neuron> kmc_: If I change the problem line to "where al = \p -> \f -> reactor $ (L p f):ls", I got this: "Ambiguous type variable `a' in the constraint: `Factory a' arising from a use of `L' at Octopus/Core.hs:22:47-51"
12:17:56 <Accidus> johnnowak, I'm targeting the talk at researchers.
12:18:01 <i_am_neuron> kmc_: #22 is this exact line
12:18:09 <rajeshsr> is there any implementation of data structures like Heap, Red-black tree in a functional way which the haskell community wud recommend?
12:18:11 <yrlnry> They got rid of the n+k patterns.
12:18:16 <yrlnry> Geez Louise.
12:18:40 <rajeshsr> i mean to read it to get an understanding of how we do in functional way..
12:18:57 <kmc_> rajeshsr, you could look at the source of Data.Map
12:19:15 <kmc_> i_am_neuron, that seems like the same error
12:19:18 <djahandarie> In this piece of Haskell code I'm looking at, the comments start like this:   -- | text    rather than just -- text
12:19:23 <i_am_neuron> kmc_: sure
12:19:30 <djahandarie> Any significance?
12:19:34 <thegoatlikedit> Accidus: seems like the most useful part.
12:19:35 <rajeshsr> kmc_, ok!
12:19:44 <rajeshsr> kmc_, thanks!
12:20:49 <Accidus> thegoatlikedit, It's also useful for comprehending new (scientific) subjects. At the very least, you should know what kind of category you are dealing with. If you don't, there is something missing, and the subject could probably benefit from introducing it
12:21:07 <kmc_> i_am_neuron, when you build a Reactor value, you must choose a specific Factory type
12:21:34 <kmc_> addListener :: PortNumber -> a -> Reactor, not addListener :: forall b. PortNumber -> b -> Reactor
12:21:36 <mjsor> djahandarie: haddock doccumentation
12:21:44 <kmc_> 'a' is bound by the existential
12:21:49 <Accidus> Or pragmatically: What are the objects? What are the morphisms? What kind of functors are there? Does the hom-sets have any structure? (is it enriched?)
12:22:50 <Accidus> Anyway, dinner time.
12:22:54 <Accidus> Thanks for the time.
12:23:56 <jfischoff> is #haskell saved in a searable form somewhere?
12:24:16 <monochrom> Does the topic help?
12:24:29 <kmc_> you can wget all of the logs since forever
12:24:30 <kmc_> and grep them
12:24:41 <i_am_neuron> kmc_: addListener is declared like this: "addListener :: PortNumber -> a -> Reactor" where a is forall'd. So not sure what you mean here
12:25:07 <jfischoff> kmc_: thanks
12:25:25 <kmc_> i_am_neuron, but that forall is outside the cotnstructor
12:25:42 <kmc_> i_am_neuron, you're saying "this Reactor is built around a specific factory type, and its addListener field is a function which takes  factories of that type only"
12:25:53 <djahandarie> mjsor, ah alright, that makes sense. Thanks.
12:25:58 <kmc_> that's *different* from "addListener :: forall b. PortNumber -> b -> Reactor", which means "addListener takes any factory"
12:26:12 <i_am_neuron> kmc_: I see, that's right
12:26:33 <kmc_> i_am_neuron, you can think of the existential as adding an extra field to your record -- which stores a type, not a value
12:27:03 <kmc_> an existential is sort of like a dependent pair
12:28:04 <sclv> so if anyone knows, am i correct in assuming that hacbos is not going to happen?
12:28:27 <i_am_neuron> kmc_: Oh, after changing the line to "addListener :: (Factory a) => PortNumber -> a -> Reactor" I'm getting the error I had 3 hours ago (when added this forall): "Inferred type is less polymorphic than expected"
12:28:32 <copumpkin> sclv: I hope it does
12:28:52 <sclv> copumpkin: are you in boston?
12:28:59 <copumpkin> sclv: not really
12:29:09 <copumpkin> sclv: but I'd go there for it
12:29:14 <sclv> I want to go but I haven't heard any further news, so its hard to make plans
12:29:24 <copumpkin> send an email :)
12:29:26 <kmc_>  i_am_neuron what do you actually want?
12:29:29 <kmc_> should addListener take any factor?
12:29:36 <kmc_> or only the factory type associated with the reactor?
12:29:53 <i_am_neuron> kmc_: it should take any
12:29:53 <sclv> copumpkin: too easy :-)
12:30:21 <kmc_> i_am_neuron, then what's the point of bundling each Reactor with a specific factory type?
12:30:28 <kmc_> i don't see another use of the existentially-bound variable
12:32:53 <i_am_neuron> kmc_: from the relation between Reactor and Factory this version is better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15137#a15138 However, there's an error in the type polymorphism
12:33:34 <kmc_> so "listeners" is basically a heterogeneous list of Factory instances
12:33:41 <kmc_> okay that's good
12:33:59 <i_am_neuron> kmc_: right
12:34:48 <kmc_> i_am_neuron, try putting a signature on "reactor"
12:35:06 <kmc_> you are working with higher-rank types here, which means inference does not always work right
12:36:05 <i_am_neuron> kmc_: didn't help
12:39:39 <sshc> how do I set / put / write a part of a State monad?  I can get / read a part of a State by using "gets".
12:39:53 <Twey> Depends on the data-type
12:40:04 <Twey> SECs will help you
12:41:27 <mauke> :t put
12:41:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
12:41:30 <johnnowak> Is anyone aware an instance of the bird-meertens formalism applied to real-world Haskell (or similar) code? The small examples I can find are pretty but seem limited to programs of four or five lines.
12:41:35 <mauke> sshc: you get everything, then put a modified version
12:43:18 <sshc> mauke: aha, that makes sense
12:43:28 <sshc> Twey: what are SEC's?
12:43:51 <kevinclark> hey there. I'm trying to take a number and split it up into digits. I figured I'd just 'show x' and then map the characters to Int, but can't figure out how to make read work. Any hints? (I'm only a few chapters into the RWH book, so I might be missing something fundamental)
12:43:56 <kmc_> sshc, look at these hackage packages: data-accessor, lenses, fclabels
12:44:16 <kmc_> > map digitToInt $ show 12345
12:44:17 <lambdabot>   [1,2,3,4,5]
12:44:27 <mauke> kevinclark: why use read?
12:44:39 <kevinclark> oh. well. yes. that's the function I'm actually looking for
12:44:41 <kevinclark> kmc_: thanks!
12:45:07 <kmc_> i_am_neuron, i put this signature and it builds:
12:45:12 <kmc_> al :: forall a. (Factory a) => PortNumber -> a -> Reactor
12:45:16 <kevinclark> mauke: Because I don't really understand my options yet. I'm still in the kiddie pool, essentially
12:45:22 <kmc_> actually you don't even need explicit forall
12:45:30 <mauke> ah, ok
12:45:59 <mauke> > map (read . return) $ show 12345 :: [Integer]
12:46:00 <lambdabot>   [1,2,3,4,5]
12:46:21 <kmc_> i_am_neuron, aha! this is the Dreaded Monomorphism Restriction
12:46:36 <mauke> this "return" just wraps each character in a list
12:46:40 <mauke> Char -> [Char]
12:46:42 <kmc_> if you add NoMonomorphismRestriction to your LANGUAGE pragma, you don't have to change the code at all
12:47:04 <kevinclark> mauke: Ah, that makes sense. That seemed to be what the compiler was complaining about, but I didn't know how to do the wrap
12:47:21 <mauke> > map (\c -> read [c]) $ show 12345 :: [Integer]
12:47:23 <lambdabot>   [1,2,3,4,5]
12:47:25 <mauke> explicit
12:47:30 <kevinclark> got it
12:47:34 <kevinclark> thanks
12:47:49 <Twey> sshc: Semantic Editor Combinators, an approach to problems like these
12:48:11 <Twey> http://conal.net/blog/posts/semantic-editor-combinators/
12:48:24 <i_am_neuron> kmc_: for me changing to "where al = (\p -> \f -> reactor $ (L p f):ls) :: (Factory a) => PortNumber -> a -> Reactor" still gives the "not polymorphic enough" error. How you got that to build?
12:48:26 <kmc_> Twey, sshc, the hackage packages i mentioned are also very similar to SEC
12:48:54 <Twey> What were those?
12:48:55 <kmc_> i_am_neuron, where al :: forall a. (Factory a) => PortNumber -> a -> Reactor; al = (\p -> \f -> reactor $ (L p f):ls)
12:49:01 <Twey> I did not see them
12:49:02 <kmc_> Twey, data-accessor fclabels lenses
12:49:05 <Twey> Oh, right
12:49:07 <Twey> Yes, indeed
12:49:31 <kmc_> i_am_neuron, but see my comment about MMR
12:49:44 <kmc_> giving an explicit sig is a way around MMR, as is simply turning it off
12:49:48 <artobstrel95> Help, please! Why fact2 is quicker than fact3? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15133#a15133
12:50:46 <i_am_neuron> kmc_: I'll have a look at that, thank you very much!
12:50:50 <kmc_> :)
12:54:25 <c_wraith> artobstrel95: because math ops on doubles are primitive in the CPU, where math ops on Integer aren't.
12:55:07 <c_wraith> artobstrel95: however, fact2 will give incorrect answers due to FPU rounding error.  fact3 won't have that problem.
12:55:37 <monochrom> Oh, so the faster algorithm is not faster.
12:55:56 <c_wraith> it's faster...  but it's an approximation algorithm
12:56:15 <monochrom> I can write an even faster one that approximates even more!
12:56:39 <monochrom> fact n = n {- gross approximation, at least I get the lower bound right -}
12:57:03 <ray> fact n = 0
12:57:44 <c_wraith> hmm.  fact2 is interesting.  Looks like it doesn't need the FP math at all.
12:57:56 <c_wraith> You could do that same thing with bit manipulation ops
12:58:01 <xpika> checkout my list updating function modAt http://hpaste.org/fastcgi/hpaste.fcgi/view?id=15139#a15139
12:58:03 <monochrom> There are also nice and fast formulas for computing the gamma function approximately (very close approximation this time).
12:58:09 <carlocci> is "foo :: (Integral a) => a -> String" the same as "foo :: Integral -> String" and the same as "foo :: (Integral a, String b) => a -> b"?
12:58:25 <pikhq> carlocci: No.
12:58:32 <pikhq> String is a type, Integral is not.
12:59:02 <ray> yes, your second 2 examples there are impossibilities
12:59:13 <ray> classes like Integral are constraints on polymorphic types, not types
12:59:20 <pikhq> "foo :: (Integral a) => a -> String" reads "foo is a function from a to String, where a is a member of the Integral typeclass."
12:59:28 <carlocci> so that's why types and typeclasses are named differently
12:59:53 <carlocci> thank you
12:59:53 <sinelaw> does anyone know of a plotting program/lib (in haskell, or any other) that can easily produce something like this constellation plot: hi, question about plotting. what's the easiest way to create a constellation plot such as this one: http://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/QPSK_Gray_Coded.svg/200px-QPSK_Gray_Coded.svg.png?
12:59:59 <c_wraith> and fact2 would still be faster.  It looks like it does some clever re-use of intermediate results, in a repeated squaring algorithm.
13:00:02 <sinelaw> conal, hi
13:00:12 <eu-prleu-peupeu> hi
13:00:14 <monochrom> nice
13:01:07 <dpratt71> @pl g p = (isLower $ fst p) && (isUpper $ snd p)
13:01:07 <lambdabot> g = ap ((&&) . isLower . fst) (isUpper . snd)
13:01:57 <dpratt71> @pl g f s = (isLower f) && (isUpper s)
13:01:57 <lambdabot> g = (. isUpper) . (&&) . isLower
13:03:50 <sshc> why isn't hoogle working?
13:04:04 * hackagebot upload: OSM 0.3 - Parse OpenStreetMap files (TonyMorris)
13:04:35 <xpika> sinelaw: you could whip something like that up for yourself using gtk2hs and cairo
13:04:56 <sinelaw> xpika, maybe, but i want latex output ideally
13:05:35 <troutwine> sinelaw: What are you making?
13:06:22 <sinelaw> troutwine, diagram of symbol constellation in gray-coded 4-QAM
13:06:29 <sinelaw> similar to the one I linked above
13:06:42 <dcoutts_> sinelaw: or the chart package, that will give you pdf (based on cairo)
13:07:03 <dcoutts_> sinelaw: when you say latex output, does that include pdf/ps/eps ?
13:07:18 <sinelaw> thanks! for now i just want a quick solution - i'll look into those later
13:07:27 <sinelaw> yeah pdf/ps/eps is also ok i guess
13:07:33 <sinelaw> latexdraw seems ok
13:14:24 <xpika> sinelaw: cairo supports postscript and pdf
13:14:34 <sinelaw> ah ok
13:14:39 <sinelaw> i'll keep that in mind
13:15:27 <dcoutts_> and svg, x11, win32, quartz, opengl, png and raw in-memory bitmaps
13:15:34 <conal> sinelaw: hi!
13:16:29 <conal> sinelaw: i have a few more comments on your project report.  we're about to go into town for misc errands & a movie, but tomorrow would be a good day for me to chat more.
13:17:06 <sinelaw> conal, sure, i'm busy with an annoying project (about digital communcations) now anyway
13:17:22 <conal> sinelaw: good luck.
13:19:02 <sinelaw> conal, thanks, I'll really need it. spent too much time on fun stuff (programming in haskell...)
13:19:46 <conal> sinelaw: i try to keep my fun/nonfun ratio as high as possible.
13:20:31 <sinelaw> me too, that's why i'm way behind on my univ. duties! last big semester, thankfuly
13:22:10 <sinelaw> conal, I need to find a way to do full-time fun when i'm done, though
13:22:20 <sinelaw> :)
13:22:38 <conal> sinelaw: yes!
13:25:26 <mreh> :t switchList
13:25:26 <lambdabot> Not in scope: `switchList'
13:39:25 <sinelaw> pgf/tikz did the job inside latex, for those interested
13:46:13 <Gracenotes> sinelaw: tikz is an awesome-party
13:46:42 <sinelaw> Gracenotes, sure is, I just produced a really cool figure in no time
13:47:24 <Gracenotes> here is a document I've made with pretty sample stuff: http://docs.google.com/fileview?id=0B_a5MxwyB_zYZjYzNWZkODYtMjZjYS00M2E4LTgwNDktOTVkYTU4YTU0MDEx&hl=en
13:47:25 <iammisc> /help
13:47:43 <Gracenotes> (the download link -> PDF, directly, better rendering probably)
13:48:21 <Gracenotes> I need to learn more about defining my own styles, though
14:01:22 <jlouis> Axman6: got it to seed in the local lab here. Had to eradicate some 5-6 bugs first though
14:01:42 <eu-prleu-peupeu> are there any universities giving courses in haskell ?
14:02:23 <jlouis> eu-prleu-peupeu: I am pretty sure there are some using it as an introductory language
14:02:32 <jlouis> We have a couple of courses where it has been used
14:02:41 <eu-prleu-peupeu> hmm
14:02:58 <eu-prleu-peupeu> here in pt there are quite some univ. using it in begining classes
14:04:42 <increpare> eu-prleu-peupeu: So you already knew the answer when you asked? : P
14:04:48 <eu-prleu-peupeu> there should be a university with a course entirely in haskell
14:04:49 <eu-prleu-peupeu> so
14:04:52 <eu-prleu-peupeu> no
14:04:57 <increpare> eu-prleu-peupeu: ah i get you now
14:05:07 <eu-prleu-peupeu> i was wondering if there was any univ giving a course in haskell
14:05:12 <eu-prleu-peupeu> not just a class
14:05:45 <increpare> eu-prleu-peupeu: Why should there be?  I'd rather a class in concurrency/compiler design, than one focussing on haskell qua haskell.
14:06:28 <eu-prleu-peupeu> because haskell is teh best language in teh world...
14:06:32 <eu-prleu-peupeu> ...forever!
14:06:36 <Heffalump> the programming languages course at Oxford is based on definitional interpreters in Haskell
14:07:34 <sproingie> i'm all for "teaching languages" with no industrial uses.  they're supposed to be teaching concepts, not churning out code-grinders
14:07:44 <eu-prleu-peupeu> i have a masters in computer engineering, and no haskell was taught :(
14:07:48 <troutwine> eu-prleu-peupeu: I think PSU in Portland gives "welcome to programming, kiddos!" in Haskell now.
14:07:54 <pikhq> sproingie: But but INDUSTRY!
14:08:45 <sproingie> something like helium would be appropriate
14:09:59 <eu-prleu-peupeu> i see
14:10:56 * monochrom writes code like "v `modifyIORef` (x : )" hehe
14:12:27 <eu-prleu-peupeu> is there any article on cache aligning data structures with haskell ?
14:13:08 <kmc_> eu-prleu-peupeu, pretty hard to do in vanilla haskell.  you have very little control over the in-memory layout of stuff
14:13:22 <kmc_> in fact no control at all in the standard language.  a little control if you know your implementation is  GHC
14:13:25 <sproingie> peek and poke
14:13:34 <kmc_> hmm that's true
14:13:53 <sproingie> pretty hard to lay out reasonable data structures that way tho
14:14:00 <kmc_> Foreign *does* give you the same facilities as C (malloc, pointer arithmetic)
14:14:34 <sproingie> i think it's something you'd have to get the compiler to do
14:14:41 <eu-prleu-peupeu> what kind of applications does haskell not fit as a good language to code in ?
14:14:41 <kmc_> anyway there are some bindings to the C Judy arrays library on Hackage
14:14:42 <sproingie> it'd make a neat pragma
14:14:46 <kmc_> eu-prleu-peupeu, hard real-time
14:14:56 <kmc_> or indeed highly latency-sensitive soft real-time
14:14:58 <sproingie> i never got much out of judy
14:15:06 <increpare> kmc_: there was a nice proposal on dealing with bitfields a while ago, don't think it got anywhere though.
14:15:09 <kmc_> because you have periodic latency from garbage collection
14:15:12 <sproingie> clever idea but the performance gains just werent there
14:15:23 <eu-prleu-peupeu> kmc_: like computer games ?! and software that manages nuclear stuff ?
14:15:24 <kmc_> sproingie, versus what?
14:15:29 <Philonous> becomes = writeIORef, isNow = modifyIORef  ... v `becomes` 3; w `becomes` 5; z `isNow` (+2)
14:15:30 <eu-prleu-peupeu> because of the garbage collector ?
14:15:51 <kmc_> eu-prleu-peupeu, computer games depends.  if your game has to deliver one frame every 1/60 of a second, that's a huge latency margin
14:16:05 <sproingie> kmc_: a decent hashtable implementation.  can't recall offhand which one, it was pretty off-the-shelf
14:16:07 <Ytinasni> eu-prleu-peupeu: not computer games. they can take 100ms too long and noone will notice, unless they do it often.
14:16:17 <kmc_> of course you'll never get that last bit of performance from Haskell.  what you do get is (making numbers up here) 95% of the performance in 10% of the development time
14:16:42 <kmc_> eu-prleu-peupeu, hard real time means that if you miss even one deadline, your program is a total failure and you get sued.  possibly people die.
14:16:54 <eu-prleu-peupeu> like nuclear stuff ?
14:17:01 <eu-prleu-peupeu> xernobyl stuff
14:17:06 <kmc_> i do not know what role computers play in running nuclear power plants
14:17:13 <kmc_> or whether realtime control is necessary
14:17:19 <sproingie> hard realtime means a missed deadline is a failure of the system
14:17:20 <eu-prleu-peupeu> so haskell would not be a good language if i was a coder in xernobyl ?
14:17:21 <increpare> Ytinasni: people are ultra-sensitive to small delays in games, actually - I've had friends say they tested and got that people prefer stable 30fps to unstable 60fps
14:17:41 <kmc_> soft real time means that quality degrades gradually as you miss deadlines
14:17:55 <sproingie> following from that, a properly designed hard realtime system *cannot* miss a deadline
14:18:05 <dv_> no
14:18:11 <increpare> Ytinasni: but a lot of games nowadays are written in things like C sharp, java, actionscript, so yeah people can evidently live with garbage collection.
14:18:12 <dv_> because missing one is a fatal error
14:18:13 <drhodes> software engineering radio has a great episode on realtime systems
14:18:18 <kmc_> hard realtime coding is really really hard
14:18:19 <Ytinasni> increpare: depends on the type of game, too. for an fps you care a lot more.
14:18:23 <sproingie> barring external failures anyway
14:18:24 <kmc_> usually requires special languages and OSes
14:18:38 <dv_> kmc_, I've heard various definitions of hard/soft realtime
14:18:43 <drhodes> http://www.se-radio.net/podcast/2007-10/episode-73-real-time-systems-bruce-powel-douglass
14:18:46 <eu-prleu-peupeu> well, humans tend to notice a decrease in framerate, much more than flicker in motion, thats why 24fps is enough for movies.... but if you have an app runing in 60fps, and then suddently it drops to 50fps, you can be sure that you will notice it
14:18:51 <eu-prleu-peupeu> and it will feel sluggish
14:19:03 <kmc_> anyway, 17 ms between frames is a huge amount of time
14:19:07 <eu-prleu-peupeu> thats why it is preferable to have a constant framerate, even though slower
14:19:12 <increpare> eu-prleu-peupeu: yippers
14:19:22 <kmc_> video games are nowhere near the cutting edge in terms of latency requirements
14:19:31 <increpare> kmc_: for sure
14:19:39 <dv_> kmc_, perhaps except for the networking component
14:19:46 <eu-prleu-peupeu> so i could use haskell for an xbox 360 game ?
14:19:52 <dv_> and audio, which cannot tolerate any misses (causes stutter)
14:20:00 <pikhq> eu-prleu-peupeu: I don't think there's an API for it.
14:20:09 <sproingie> eu-prleu-peupeu: short answer, no
14:20:12 <increpare> eu-prleu-peupeu: no (not without gigantic amounts of work), but you might be able to use fsharp
14:20:18 <kmc_> dv_, the time between samples at 44.1kHz is still pretty big
14:20:23 <kmc_> and usually you produce audio in big blocks
14:20:23 <pikhq> Console developers tend to make it very very hard to port languages to it.
14:20:30 <dv_> kmc_, but still you cannot miss the deadline
14:20:40 <eu-prleu-peupeu> what if... i use ghc to generate C code, and then run that C code in xbox 360 ? or playstation3 ?
14:20:40 <dv_> hard realtime does not mean *tight* deadlines, but *hard* ones
14:20:45 <kmc_> sure -- i was talking about magnitude of deadline, not about hard versus soft
14:20:53 <increpare> pikhq: and usually have very dodgy compilers/libraries themselves
14:20:57 <sproingie> realtime doesn't even have to mean "fast".  just "guaranteed"
14:20:59 <dv_> tight and hard deadlines are bloody hard to code
14:21:01 <kmc_> i'm saying there are other soft real time apps besides video games with much tighter requirements
14:21:07 <pikhq> increpare: Yeah...
14:21:10 <Ytinasni> dv_: it's such a long deadline that it isn't really comparable with most other hard-realtime programs, though.
14:21:17 <pikhq> increpare: The Wii even has very dodgy firmware...
14:21:39 <kmc_> the networking component of games is still pretty laggy.  about the best you can expect is gigabit ethernet on LAN and decent cable modem for internet
14:21:43 <dv_> Ytinasni, sure, but sticking to this requirement helps keeping the "hard/soft realtime" terms straight
14:21:54 <increpare> pikhq: I believe it
14:22:06 <kmc_> eu-prleu-peupeu, look at "atom" for a Haskell EDSL for hard-real-time programming
14:22:09 <kmc_> it's on hackage
14:22:21 <eu-prleu-peupeu> ok
14:22:26 * increpare goes to look at atom
14:22:28 <eu-prleu-peupeu> EDSL = ?
14:22:29 <dv_> yes, networking is soft, not as soft as graphics though
14:22:32 <eu-prleu-peupeu> domain specific language
14:22:33 <kmc_> embedded domain-specific language
14:22:37 <eu-prleu-peupeu> embedded ?
14:22:39 <eu-prleu-peupeu> why embedded ?
14:22:45 <kmc_> embedded within another language
14:22:47 <eu-prleu-peupeu> it does not work in haskell natively ?
14:22:55 <pikhq> It's stuck inside of Haskell.
14:22:55 <kmc_> an EDSL is a library that "acts like" a language in its own right
14:23:05 <increpare> atom looks pretty interesting - how does it deal with haskell's gc?
14:23:07 <dv_> eu-prleu-peupeu, think of a library defined with haskell
14:23:18 <pikhq> increpare: It doesn't.
14:23:23 <yitz> inclement: it generates C
14:23:27 <kmc_> eu-prleu-peupeu, search google for "Haskell EDSL"
14:23:27 <kmc_> increpare, it generates C code
14:23:28 <increpare> ah right
14:23:41 <kmc_> it uses Haskell as a metalanguage for generating C code for embedded devices
14:23:49 <dv_> heh
14:23:51 <eu-prleu-peupeu> so i can make my killer 3D engine with atom ?
14:23:55 <sproingie> no
14:23:55 <kmc_> eu-prleu-peupeu, doubtful
14:23:58 <dv_> think of an EDSL for writing device drivers
14:24:01 <kmc_> eu-prleu-peupeu, you should do more reading
14:24:02 <pikhq> "Can", yes.
14:24:03 <sproingie> the code atom generates isn't automatically fast
14:24:07 <dv_> eu-prleu-peupeu, you dont need hard realtime for engines
14:24:08 <pikhq> "Would", no.
14:24:10 <sproingie> it just executes in very constant time
14:24:12 <kmc_> eu-prleu-peupeu, how much Haskell do you know?
14:24:23 <eu-prleu-peupeu> kmc_: not much, but im working on it
14:24:26 <kmc_> cool
14:24:27 <pikhq> Hard realtime means that you know how long it will run.
14:24:28 <Heffalump> anyone Dutch around? Is it true there are twice as many bikes as inhabitants in the Netherlands, and if so why?
14:24:32 <pikhq> It doesn't mean it's fast at *all*.
14:24:34 <Heffalump> </off-topic>
14:25:07 <pikhq> "It will always run in 30 seconds, and will always need to be run in 30 seconds" is hard realtime, but freaking slow.
14:25:20 <sproingie> Heffalump: lots of rentals i suppose
14:25:24 <dv_> indeed.
14:25:25 <lament> at least among my friends, people who often use bicycle for transportation tend to have more than one
14:25:31 <eu-prleu-peupeu> so i could use it for a nice 3D demo that i know that runs in 5 minutes
14:25:40 <pikhq> No.
14:25:42 <sproingie> you don't need atom for that
14:25:45 <pikhq> That's not why you would use it at all.
14:25:49 <dv_> why do you want hard realtime for this?
14:25:50 <eu-prleu-peupeu> :)
14:25:54 <eu-prleu-peupeu> i dont
14:26:07 <eu-prleu-peupeu> im just trying to figure out what kind of apps is haskell a bad language to code in
14:26:17 <sproingie> i don't think you'd find the expressiveness of a DSL like atom very pleasant to work with
14:26:27 <pikhq> eu-prleu-peupeu: "Not many".
14:26:35 <increpare> eu-prleu-peupeu well that's not the sort of constraint you'd have in games - you need to get lots of frames out every second.  Not "I need my game to be finished in five minutes"  : P
14:26:39 <dv_> perhaps one that would results in many monads
14:26:41 <troutwine> Heffalump: There are 1.102 passenger vehicles per person in the United States, incidentally.
14:27:21 <dv_> increpare, actually, if you can pull off some convincing motion blur, you dont need that many frames
14:27:24 <increpare> dv_: we need another round of obfuscated haskell, with a 'monads' theme : P
14:27:39 <increpare> dv_: appropriateness of motion blur depends on context
14:27:45 <dv_> eu-prleu-peupeu, but mostly its a library issue I guess
14:28:29 <increpare> dv_: also motion blur is not without cost.  I don't know off-hand of any game that's used motion blur to compensate for shitty frame-rates.
14:28:32 <dv_> increpare, but apps that dont need motion blur at all dont need 60 fps either
14:28:52 <dv_> in fact, 60 fps are a hack to work around the fact that motion blur is hard to implement
14:28:54 <eu-prleu-peupeu> why people dont like haskell that much ?!
14:29:15 <increpare> dv_: what?  there're plenty of 60fps platform games on pc that don't go anywhere near motion blur.
14:29:15 <dv_> eu-prleu-peupeu, its quite different from the C language family
14:29:21 <holmak> Most people haven't heard of it. Can't like something you don't know about.
14:29:47 <dv_> increpare, not sure what you mean.
14:29:48 <eu-prleu-peupeu> holmak: but yet they like to speak bad about it
14:29:50 <increpare> dv_: it's as much a responsiveness issue as a visual issue for a lot of developers
14:30:02 <dv_> increpare, responsiveness != framerate
14:30:09 <sproingie> most engines do some motion blur.  it's just subtle.
14:30:17 <dv_> if you put graphics in its own thread of course
14:30:30 <holmak> eu-prleu-peupeu: I wouldn't worry about it. Write in whatever language you like. People disliking languages doesn't harm the language.
14:30:39 <pikhq> increpare: Motion blur reduces the frame rate needed to do an illusion of motion...
14:31:03 <increpare> dv_ : responsiveness is linked to framerate (on the assumtion that the rendering is tied to the logic, which it usually is to some extent)
14:31:07 <pikhq> This is a large part of why film gets away with 24 FPS.
14:31:11 <increpare> pikhq: ok I'll buy that
14:31:24 <increpare> pikhq: so long as you don't focus on the backgrounds too much when the camera is panning : P
14:31:30 <pikhq> increpare: Right.
14:31:34 <dv_> yes, with correct motion blur game graphics at 24 fps could work
14:32:20 <sproingie> even high refresh rates often demand some motion blur just because we've come to expect it now
14:32:25 <dv_> if you run game logic and rendering concurrently, then you unlink them
14:32:32 <sproingie> if you watch a tv show with no motion blur, it often comes across looking cheap
14:32:40 <dv_> which is already done for networking and sound, for instance
14:32:48 <sproingie> like it was shot on a cheap handheld
14:32:52 <ray> there are a lot of misconceptions around frame rates
14:33:00 <kmc_> eu-prleu-peupeu, who speaks poorly of Haskell?
14:33:05 <ray> my advice is to run your program and see if it looks good
14:33:08 <kmc_> what sort of criticism do you see?
14:33:08 <ray> and be honest with yourself
14:33:14 <kmc_> some of it is legitimate, and a lot is misinformed
14:33:21 <increpare> dv_ : True.  But unlinking them all can be awkward for design.
14:33:29 <dv_> yes, it indeed is harder.
14:33:29 <ray> who speaks badly of haskell? we'll break their kneecaps
14:33:40 <dv_> a MVC-like design helps though
14:33:52 <ray> though if it's jon harrop, he's full of crap wrt haskell
14:33:59 <kmc_> yes, he's seriously in the tank
14:34:01 <kmc_> for F# now?
14:34:07 <ray> f# yeah
14:34:07 <sproingie> for now
14:34:16 <dv_> oh yes, what about that f#?
14:34:32 <eu-prleu-peupeu> its hard, it has no future, javascript is the way to go, it has an ugly name, nobody codes in it, it is hard to find people coding in haskell hence all the projects done in it are doomed to be unmaintainable by other people besides you
14:34:36 <increpare> dv_ : it's better for writing xbox games than haskell : )
14:34:49 <ray> yeah, where's haskell .NET
14:34:49 <dv_> is it interesting?
14:35:02 <eu-prleu-peupeu> i usually get the its slow argument, and the "there are no real applications done in haskell"
14:35:02 <dv_> I thought f# is based on caml
14:35:07 <kmc_> Haskell is pretty hard
14:35:07 <kmc_> and i think it's hard even aside from unlearning bad habits from other languages -- that makes it much harder
14:35:13 <ray> f# is an ocaml-alike
14:35:14 <kmc_> the thing is... writing good programs is hard!
14:35:20 <sproingie> there's a few XNA sample projects in F#
14:35:25 <dv_> eu-prleu-peupeu, haskell is very different from most other languages
14:35:27 <lament> kmc_: not in Javascript!
14:35:30 <dv_> that makes it hard to learn
14:35:31 <kmc_> eu-prleu-peupeu, as to the second: http://haskell.org/haskellwiki/Haskell_in_industry
14:36:01 <kmc_> hardware design, embedded systems programming, financial analytics, bioinformatics, cryptography
14:36:10 <dv_> one real-world issue is the possible adverse impact of lazy evaluation
14:36:15 <eu-prleu-peupeu> in the world of today, if a coder stays in a company more than 6 months then it is something extraordinary
14:36:20 <increpare> There's a part of me that really thinks it would be super to do haskell stuff as a day job.
14:36:27 <kmc_> increpare, only a part?
14:36:34 <dv_> like, all of a sudden theres a significant increase in RAM usage, because something is evaluated just now
14:36:34 <sproingie> eu-prleu-peupeu: where do you get that figure?
14:36:39 <lament> increpare: the head?
14:36:46 <jfischoff> it only takes one killer platform to take a language to the mainstream
14:36:50 <jfischoff> look at rails
14:36:53 <kmc_> darcs and xmonad are great programs but we're long past the time when they're the pinnacle of real-world haskell usage
14:37:01 <eu-prleu-peupeu> sproingie: the 6 months figure ?
14:37:06 <idnar> I've been working for the same company for about 7 years
14:37:12 <dv_> kmc_, the lead developer of the Unreal engine is very fond of haskell
14:37:26 <increpare> kmc_: pretty much - most of the haskell work I've seen was in specialist areas stuff that's rather far from my rather small base of knowledge
14:37:39 <sproingie> unreal has some interesting stuff like kismet
14:37:41 <eu-prleu-peupeu> dv_: yeah, but he probably doesn't know how to code a thing :P
14:37:43 <increpare> (i'm a games programmer)
14:37:46 <kmc_> increpare, you can't write an EDSL for financial modeling just because you don't know finance?
14:37:50 <kmc_> i don't think that's very accurate
14:37:51 <increpare> dv_ yeah i noticed that
14:37:56 <dv_> eu-prleu-peupeu, I think Tim Sweeney does know how to code.
14:37:58 <ray> tim sweeney is a bit of an outlier though
14:37:59 <increpare> kismet is interesting all right; I've had a lot of fun with it
14:38:00 <kmc_> you will pick up all the domain knowledge as you go
14:38:13 <dv_> his programming language presentation was quite enlightening
14:38:21 <ray> it's not often that you succeed like he did by actual codewriting
14:38:32 <sproingie> worked for carmack
14:38:49 <lament> what's carmack up to these days?
14:38:51 <eu-prleu-peupeu> tim sweeney just drives his ferraris around, goes to the company to see if everybody is working, spends the day watching youtube vids, and then goes to some foruns, prepares some presentations and talks about haskell
14:38:55 <ray> it worked for id and epic, and now everyone uses their code
14:38:57 <dv_> carmack was in the right place at the right time. he's very talented, but today, he would become the star he is now.
14:39:05 <dv_> he wouldnt
14:39:06 <dv_> that is
14:39:07 <dv_> :)
14:39:19 <ray> tim sweeney probably would
14:39:20 <increpare> dv_ are there any star games programmers around now?  I guess the crytek brothers.
14:39:30 <sproingie> lament: new idtech engine, game called Rage.  hoping to god more people license it this time
14:39:53 <ray> tim sweeney didn't start with 3D engines, he only went with that because it was getting big
14:39:53 <increpare> sproingie: this use any of the ray tracing tech he's been pushing?
14:39:55 <dv_> I wasnt surprised that few licensed tech 4
14:39:59 <dv_> it didnt scale well
14:40:13 <jfischoff> game developers fear new languages, because of the old contraints
14:40:30 <c_wraith> was tim sweeney the programmer at epic from the start?  ZZT, and the like?
14:40:31 <sproingie> game developers love new languages, just not to write core engine code in
14:40:34 <ray> yes
14:40:35 <increpare> jfischoff: not they don't.  Big developers and corporations fear new languages, because of the risk involved.
14:40:41 <ray> epic is his company
14:40:50 <increpare> sproingie: game developers have embraced a lot of cookie and charming scripting languages
14:40:51 <sproingie> otherwise, game devs work with some of the most wack-ass languages around
14:40:52 <kalven> developers that write real programs have to live in the real world
14:41:09 <jfischoff> increpare: Sure, I'm just speaking from time at EA and Emergent
14:41:10 <ray> game developers invent crazy languages!
14:41:15 <dv_> Lua has established itself as a popular game scripting language
14:41:18 <jfischoff> ray: true that
14:41:24 <eu-prleu-peupeu> lua sucks
14:41:24 <sproingie> being about to control stuff like gc is a big deal in a game engine tho
14:41:35 <jfischoff> ray: I had to work on custom scripting language at ea, sucked ass
14:41:36 <kmc_> video games have been a prime usage of domain-specific languages since forever
14:41:37 <dv_> and it can do pretty wacky things
14:41:47 <increpare> jfischoff: Gotcha.  I'm involved with the indie games scene, and language-choices are considerably more varied there : )
14:41:51 <sproingie> lua is not typically used for super complex things in most games
14:42:05 <dv_> true that. its mainly used for gameplay elements
14:42:07 <increpare> sproingie: well that's sort of the point of it.
14:42:07 <sproingie> WoW's interface is probably the main exception
14:42:08 <eu-prleu-peupeu> lua made it because lucas arts picked it up a few years ago, else it would have never left the academia world
14:42:12 <dv_> scripted events etc.
14:42:25 <jfischoff> increpare: that's the thing. using the hardware takes well written programs
14:42:43 <sproingie> bioware was using lua before it was well-known
14:42:46 <jfischoff> increpare: not super tight loops. So other languages make more sense
14:42:47 <increpare> jfischoff: hmm?
14:42:51 <dv_> eu-prleu-peupeu, lua's fast, easy to integrate, small, and has a nice license. topseller if you ask me.
14:43:04 * increpare has very fond feelings towards lua
14:43:20 <c_wraith> lua was built for sandboxing.  that makes it very attractive in game scripting environments
14:43:29 <jfischoff> its lightweight too
14:43:36 <eu-prleu-peupeu> it has a register based vm
14:43:36 <jfischoff> low memory usage
14:43:44 <eu-prleu-peupeu> which is actually quite nice, but everything else sucks
14:43:45 <increpare> and is fast
14:43:54 <dv_> and quite powerful
14:43:55 <jfischoff> eu-prleu-peupeu: exactly
14:43:55 <increpare> also ansi-compliant, which is important when your console has a shitty c compiler : P
14:44:42 <eu-prleu-peupeu> is haskell ansi-compliant ?
14:44:48 <sproingie> what does that even mean?
14:44:48 <jfischoff> if haskell had profile guided memory manager I wonder if it could achieve AAA game performance?
14:44:58 <increpare> anyone here ever use IO (the scripting language)?
14:45:00 <kmc_> eu-prleu-peupeu, "ansi-complient" meaning ANSI C
14:45:02 <ray> no, haskell violates the C standard
14:45:06 <increpare> ( http://iolanguage.com/ )
14:45:07 <sproingie> increpare: i have.  it's kinda fun.
14:45:14 <eu-prleu-peupeu> isn't C-- ansi compliant ?
14:45:19 <kmc_> eu-prleu-peupeu, not
14:45:22 <kmc_> even close
14:45:23 <ray> a conforming c compiler will not compile a haskell program
14:45:29 <kmc_> C-- has several important features that are not in C
14:45:32 <kmc_> that's why it exists
14:45:38 <mle> more than just the stack assumptions?
14:45:38 <eu-prleu-peupeu> oh
14:45:43 <increpare> sproingie: I've look at it, but haven't quite *gotten* it yet.  I haven't used it properly, and don't think I'm sensitive enoguh to divine its lovelinesses without direct experience.
14:45:52 <eu-prleu-peupeu> i thought gcc could compile it
14:45:55 <increpare> ray: : P
14:46:02 <eu-prleu-peupeu> so what does the via-C flat in ghc does exactly !?
14:46:06 <kmc_> eu-prleu-peupeu, don't think so.  if you have a link i'm happy to be proven wrong
14:46:07 <ray> no word on non-conforming implementations
14:46:08 <kmc_> eu-prleu-peupeu, it generates C
14:46:09 <kmc_> not C--
14:46:13 <eu-prleu-peupeu> ok
14:46:16 <kmc_> it generates C via C-- i think
14:46:19 <eu-prleu-peupeu> so is that C ansi compliant ?
14:46:21 <kmc_> or via ghc's flavor of C--
14:46:24 <ray> eu-prleu-peupeu: makes macro-infested C that looks more like assembly to be honest
14:46:32 <lament> i looked at io, it seemed like proof of concept for the sake of proof of concept.
14:46:35 <kmc_> right, because it's using C as a portable assembler
14:46:42 <kmc_> the point of C--, and LLVM, is to have a better portable assembler than C
14:46:46 <kmc_> C doesn't even support tail calls!
14:46:50 <increpare> lament: I have a couple of friends who talk about how wonderful it is sometimes.
14:46:55 <eu-prleu-peupeu> so i can use gcc -O3 with a haskell via-C output, right ?
14:47:00 <kmc_> yup
14:47:10 <eu-prleu-peupeu> and i can use that via-C in xbox360 and ps3, right ?
14:47:17 <kmc_> ghc -fvia-C -optc-O3
14:47:19 <sproingie> increpare: the async message stuff is probably the most interesting feature it has.  otherwise, it's just a language with a lot of hackability through reflection, but you're not obligated to use those features
14:47:27 <kmc_> eu-prleu-peupeu, *maybe* with an "unregistered" build of ghc
14:47:27 <dv_> hmm
14:47:29 <lament> increpare: it's conceptually pretty because it's so simple. Many other languages are, too. I would never want to program in it.
14:47:34 <kmc_> meaning, one which does not do postprocessing to the C compiler's output
14:47:36 <increpare> eu-prleu-peupeu: you'd have to pull all the library bindings up from c first.  also get a development licence : P
14:47:49 <kmc_> iirc there's no evil mangler or native codegen for ppc64
14:47:57 <dv_> I suppose there is some haskell frontend for llvm?
14:48:11 <kmc_> dv_, Haskell binding to the LLVM library?
14:48:11 <increpare> dv_ yeah someone made one recently
14:48:11 <kmc_> yes
14:48:12 <dv_> or a ghc version using llvm?
14:48:22 <kmc_> there is also (a totally unrelated thing) a GHC fork which outputs LLVM
14:48:34 <jfischoff> is the llvm public?
14:48:37 <increpare> dv_ http://www.google.com/url?sa=D&q=http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf&usg=AFQjCNEGsTI0EW5cN5lS0nMb4T50F-eJSA
14:48:37 <dv_> yes
14:48:40 <dv_> it is
14:48:45 <increpare> oops
14:48:46 <increpare> dv_     http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf
14:48:57 <dv_> seeing that everything focuses around llvm now, it appears to be a logical move
14:48:58 <jfischoff> where can I download
14:49:19 <sproingie> @google llvm
14:49:19 <lambdabot> http://llvm.org/
14:49:19 <lambdabot> Title: The LLVM Compiler Infrastructure Project
14:49:33 <dv_> I'd vote llvm for the project of the decade
14:49:36 <dv_> :)
14:49:39 <jfischoff> yeah, what about the ghc llvm part. is that out?
14:49:46 <increpare> dv_: what endears you to it so much?
14:49:54 <increpare> it to you
14:50:03 <sproingie> if clang ever gets finished, i'd concur
14:50:23 <jfischoff> adobe has a llvm to actionscript byte code
14:50:31 <ray> too bad it's in c++
14:50:35 <jfischoff> would love to program flash with haskell
14:50:36 <increpare> jfischoff: hahah really?
14:50:41 <ray> talk about dubious
14:50:43 <increpare> jfischoff: oh is that their c++ compiler thingy?
14:50:51 <increpare> makes sense, I guess
14:50:51 <jfischoff> increpare: yeah
14:51:07 <kmc_> i am happy whenever people stop reinventing wheels
14:51:10 <increpare> jfischoff: it's a pitty that as3 is, for most purposes, a better language than c++ : P
14:51:23 <increpare> I haven't even thought of checking it out.
14:51:33 <dv_> depends on what kind of c++ you write
14:51:39 <jfischoff> increpare: haha yeah, just doesn't have boost
14:51:52 <sproingie> or need it for the most part
14:52:03 <increpare> jfischoff: right: it comes with a decent built in library instead.
14:52:19 * dv_ likes parts of boost
14:52:26 <increpare> dv_ yeah true, but the kind of c++ that you'd want to port to as3 is a small subset of the kind of c++ that you'd want to use in general
14:52:30 <jfischoff> increpare: yeah but sucks ass compared to haskell :)
14:52:37 <increpare> dv_ I also have a great fondness for lots of boost
14:53:44 <jfischoff> someone should right a haskell to c++ template language translator. Write boost libraries with haskell
14:53:46 <increpare> jfischoff: it's not clear to me that it does (its key advantage being the distribution format...)
14:53:48 <jfischoff> err write
14:53:55 <dv_> increpare, I try to stay away from 1995-MFC-style c++
14:54:24 <increpare> dv_ how would you describe your c++ style?
14:54:26 <jfischoff> increpare: haskell's clear advantage is the distro or actionscript?
14:54:43 <sproingie> jfischoff: because C++ compiler messages aren't opaque enough, eh?
14:54:45 <dv_> still, about the only reason I still use c++ is its availability and the fact that its the language I have the most experience with
14:54:51 <ray> @ghc
14:54:55 <jfischoff> sproingie: haha
14:54:57 <dv_> increpare, generic, boost-like
14:55:05 <jfischoff> i guess I just hate templates
14:55:06 <monochrom> Any Haskell?
14:55:09 <dv_> and strict iso-c++
14:56:02 <increpare> jfischoff: an area where as3 is very strong is in how easily it is to distribute things to people, and how quite well supported it is (linux nay-sayers not withstanding)
14:56:06 <lambdabot> ghc says: Interesting!  A join var that isn't let-no-escaped
14:56:08 <increpare> "<dv_> My C++ style is a sort of 1960's avant-guard / punk-rock hybrid, largely inspired by the post-feminist discourse of the mccarthy era."
14:56:08 <increpare> "<increpare> golly."
14:56:37 <sproingie> @ghc
14:56:37 <lambdabot> ghc says: Inferred type is less polymorphic than expected
14:56:40 <dv_> 8)
14:56:41 <jfischoff> increpare: yeah totally. That's why I am trying to program in haskell for the flash platform
14:56:54 <increpare> jfischoff: you trying to do a compiler?
14:57:08 <jfischoff> increpare: haha, I hope not
14:57:11 <increpare> jfischoff: there's a dodgy scheme->swf compiler around somewhere isn't there?
14:57:19 <dv_> increpare, and how would you describe your c++ style?
14:58:04 <jfischoff> increpare: looked at, not very good. haskell -> LLVM -> Daniel -> LLVM -> Actionscript Byte Code
14:58:04 <increpare> dv_ not fully mature...my non-professional code is horribly messy for the most part.  My professional code tends to be more or less an emulation of whatever the style of the nearest non-pathological code nearby is.
14:58:19 <increpare> (horribly messy but entirely functional : ) )
14:58:29 <jfischoff> increpare: Daniel is my friend that works on the LLVM project for Apple :)
14:59:07 <increpare> jfischoff: Ah, cool.  Very interesting.  Hooking up haskell to the llvm->as3 generator would be verrrry interesting.
14:59:15 <increpare> and potentially riotously fun : )
14:59:25 <dv_> as3 with haskell :D
14:59:26 <pikhq> My C++ style is pretty simple. ... It looks remarkably similar to C.
14:59:35 <jfischoff> yep
14:59:48 <increpare> ah; alchemy converts llvm -> as3
14:59:52 <increpare> which is then converted to as3 bytecode
14:59:57 <increpare> (or whatever)
15:00:08 <jfischoff> increpare: yeah
15:00:11 <increpare> pikhq: to the extent that you'd have trouble writing in C if you tried?
15:00:19 <pikhq> increpare: No.
15:00:22 * increpare tried writing something in C recently; didn't get too far...
15:00:31 <pikhq> I have trouble using most of C++'s features.
15:00:43 <pikhq> I really do write nearly-C in C++.
15:00:47 <dv_> increpare, about as3: the code migration part is indeed something naysayers forget. its much easier to introduce new codecs this way
15:00:58 <pikhq> Because so much of the rest of the language is just too much of a headache to do otherwise.
15:01:06 <sproingie> i tend to use a lot of STL, that's about it
15:01:22 <jfischoff> increpare: err LLVM -> AVM2 (ActionScript Virtual Machine 2)
15:01:30 <jfischoff> increpare: is alchemy
15:01:33 <sproingie> oh and occasional boost.  but not stuff like boost.lambda because it looks like absolute ass when it breaks
15:01:40 <dv_> there's no clear style in how to do stuff in c++
15:01:47 <jfischoff> increpare: I think... :)
15:01:49 <increpare> dv_ : yeah I'll acknowledge the importance of that.  (However, it should not be underestimated how easy it is to port C++ -> AS3 (and back) )
15:01:50 <dv_> which causes a lot of headaches when one mixes them
15:02:02 <increpare> jfischoff: "Alchemy works by converting LLVM bytecode to ActionScript 3.0 (AS3) source through an Adobe-authored LLVM back-end. This AS3 source is then compiled using a special version of the ActionScript Compiler to ActionScript bytecode (ABC). This ABC output is then bundled into either a SWF or a SWC depending on your compile options. The resulting SWFs can be executed using Flash Player or bundled into an AIR app
15:02:16 <jfischoff> increpare: my bad
15:02:29 <dv_> sproingie, still, the bind() functions and the function objects are badly needed features
15:02:39 <increpare> jfischoff: much of a muchness though, I guess; you just gotta get things to llvm - doesn't matter much what's on the other side : P
15:02:44 <dv_> I use them whenever I can
15:02:58 <jfischoff> increpare: true that
15:03:00 <sproingie> dv_: binders in STL are just hideous
15:03:11 <dv_> sproingie, I dont mean the STL ones
15:03:15 <sproingie> i find myself writing my own boilerplate in order to avoid them
15:03:22 <dv_> I mean the boost ones
15:03:26 <jfischoff> dv_: do you have a link for the ghc branch that has the LLVM?
15:03:26 <kalven> bind & function is standard in 0x
15:03:30 <dv_> bind, lambda.bind, phoenix.bind
15:03:44 <sproingie> i think i used boost's bind once or twice, it wasn't quite as bad
15:03:44 <increpare> dv_ I find bind, even in boost, to be really really hard to use.  Every time I try to, I just...can't figure it out myself.  Maybe I should have headed to some C++ chatrooms for help at those points.
15:04:11 <sproingie> still they just seem to draw circles around, underscore, and hilight the lack of real first-class functions
15:04:14 <dv_> increpare, it has a bad learning curve, but once you get it, it all falls into place.
15:04:40 <dv_> but yes, they are sorely lacking, c++0x will introduce some form of lambda into the language
15:04:57 <dv_> its monomorphic though
15:05:02 <sproingie> meanwhile C# already has
15:05:13 <increpare> dv_: I'll take your word for it.  With C++0x I'll be able to ignore them hopefully anyway...
15:05:42 <dv_> most of the time, you just do stuff like bind(&foo, someval, _1, someotherval, _2) , where _1 and _2 are placeholders
15:05:52 <increpare> jfischoff: not sure where this guy's code is
15:06:00 <increpare> jfischoff: the llvm back-end.
15:06:13 <jfischoff> increpare: yeah, I couldn't track it down either
15:06:24 <increpare> jfischoff: ah it's here http://www.cse.unsw.edu.au/~davidt/
15:06:34 <jfischoff> increpare: sweet
15:06:35 <dv_> err, _1 and _2 are bound variables
15:17:54 * mux has GHC 6.12.1 with shared libraries working on FreeBSD: http://pastebin.com/m130d7342
15:18:17 <mux> 11k Hello world :D
15:18:51 <sproingie> stripped?
15:19:12 <mux> hey, not even
15:19:26 <mux> 7k stripped :D
15:19:33 <sproingie> doesn't get much better
15:19:48 <sproingie> did you have to do anything special to build it?
15:19:53 <sproingie> (ghc that is)
15:19:59 <mux> http://pastebin.com/m4ec69aea
15:20:09 <mux> sproingie: yes, I have a few patches here and there
15:20:16 <sproingie> send 'em in :)
15:20:22 <sproingie> been a while since i ran bsd
15:20:24 <pikhq> I see your 7k "Hello, world!" and raise you a 76-byte "Hello, world!"
15:20:29 <mux> I'll clean them up and send them tomorrow most likely
15:20:50 * hackagebot upload: happstack-helpers 0.47 - Convenience functions for Happstack. (ThomasHartman)
15:20:52 * hackagebot upload: happstack-helpers 0.48 - Convenience functions for Happstack. (ThomasHartman)
15:21:09 <sproingie> 8k is like the smallest useful memory image you can map, no?
15:21:27 <mux> has anyone run GHC 6.12.1 with shared lib on Linux? the ld warnings are scary.
15:21:45 <pikhq> sproingie: That depends on the OS and the architecture.
15:22:12 <mux> x86 pages are 4k
15:22:17 <sproingie> 4k pages are pretty common
15:22:18 <mux> the smaller ones, that is.
15:22:26 <pikhq> x86_32 pages are 4k, yes.
15:22:37 <mux> other architectures have 8k as their smallest page sizes
15:22:46 <mux> for kicks, ia64 has 256MB pages IIRC
15:22:57 <pikhq> x86_64 has variable sized pages.
15:22:57 <sproingie> ia64 is superfreaky
15:23:03 <mux> maximum, of course.
15:23:05 <pikhq> I think it goes up to 2GB.
15:23:13 <mux> ia64 assembly is out of this worl already
15:24:52 * hackagebot upload: vty 4.2.1.0 - A simple terminal access library (CoreyOConnor)
15:27:30 <pikhq> IA64 is pretty much just out there.
15:30:43 <ahf> IA64 assembly is disturbing :(
15:32:40 <kmc_> i like how every architecture developed by Intel, except one, has been a dismal failure
15:32:48 <elspru> how do i find, how many bytes it takes to represent a certain int
15:32:55 <kmc_> what do you mean?
15:32:59 <kmc_> in Haskell?
15:33:03 <elspru> or math
15:33:15 <elspru> 0xffee is two bytes long
15:33:15 <kmc_> elspru, you want the base-2 logarithm?
15:33:20 <kmc_> > (log 29) / (log 2)
15:33:21 <lambdabot>   4.857980995127573
15:33:29 <kmc_> it takes 5 bits to represent 29
15:33:33 <kmc_> (you round up)
15:33:36 <kmc_> > (log 32) / (log 2)
15:33:38 <lambdabot>   5.0
15:33:52 <c_wraith> um.  sometimes you add one :)
15:33:57 <ehamberg> floor + 1
15:34:01 <kmc_> right
15:34:06 <elspru> > (log 0xffff) / (log 0x10)
15:34:07 <lambdabot>   3.9999944965131844
15:34:18 <elspru> > div (log 0xffff) (log 0x10)
15:34:19 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:34:20 <lambdabot>    `GHC.Float.Floating t'
15:34:20 <lambdabot>  ...
15:34:28 <elspru> is there a way to get an int result?
15:34:34 <kmc_> (+1) . floor
15:35:01 <elspru> > div (log 0xffaa) (log 0x100) . floor
15:35:02 <lambdabot>   No instance for (GHC.Real.Integral (a -> b))
15:35:02 <lambdabot>    arising from a use of `GHC....
15:35:06 <kmc_> > let nBits = (+1) . floor . (/ log 2) . log in map nBits [1..]
15:35:07 <lambdabot>   [1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,...
15:35:39 <clutchsk1> hey all ... is there a built-in function or idiom to compose a function a particular number of times  ... e.g ... composeTimes 5 f  ->  f . f . f . f . f
15:35:40 <elspru> > (+1) . floor . (div (log 0xffaa) (log 0x100))
15:35:40 <lambdabot>   No instance for (GHC.Real.Integral (f a1))
15:35:41 <lambdabot>    arising from a use of `GHC.Re...
15:35:47 <kmc_> > concatMap (join replicate) [1..]
15:35:48 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
15:36:04 <elspru> kmc_: ?
15:36:10 <pikhq> kmc_: Nice.
15:36:23 <johnnowak> elspru: you want to apply '(+ 1) . floor' to the result, not compose it with the result
15:36:35 <elspru> ?
15:36:37 <johnnowak> > ((+ 1) . floor) 3.6
15:36:38 <lambdabot>   4
15:36:44 <elspru>  i don't understand the .
15:36:51 <elspru> it's too confusing,
15:36:55 <kmc_> elspru, function composition
15:36:58 <Beelsebob> elspru: (.) is called "function composition"
15:36:58 <c_wraith> :t sequence $ replicateM 5 (+1)
15:36:59 <lambdabot>     The section `+ 1' takes one argument,
15:37:00 <lambdabot>     but its type `[a]' has none
15:37:00 <lambdabot>     In the second argument of `replicateM', namely `(+ 1)'
15:37:09 <elspru> i'm used to the ordinary func arg arg
15:37:09 <johnnowak> . is function composition.. you can write '\x -> floor x + 1' instead
15:37:11 <Beelsebob> elspru: it makes a new function by putting one function after the other
15:37:17 <kmc_> > let ncomp n = foldr (.) id . replicate n in ncomp 5 succ 0
15:37:18 <lambdabot>   5
15:37:21 <c_wraith> :t sequence $ replicate 5 (+1)
15:37:22 <lambdabot> forall a. (Num a) => a -> [a]
15:37:22 <kmc_> clutchsk1, ^^^^
15:37:32 <Beelsebob> elspru: so, f = (+1) . floor is the function that adds 1 to things "after" flooring things
15:37:51 <elspru> so could you demonstrate something that could count the bytes of a hex number?
15:37:58 <kmc_> (+1) . floor   ==  \x -> (+1) (floor x)  ==  \x -> floor x + 1
15:38:05 <clutchsk1> kmc_ cool .. i just to learn what id & in are
15:38:06 <c_wraith> :t foldl id $ replicate 5 (+1)
15:38:07 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
15:38:07 <lambdabot>     Probable cause: `id' is applied to too many arguments
15:38:07 <lambdabot>     In the first argument of `foldl', namely `id'
15:38:07 <clutchsk1> thanks
15:38:24 <kmc_> clutchsk1, id is the identity function.  returns its argument
15:38:26 <kmc_> > id "bleh"
15:38:27 <lambdabot>   "bleh"
15:38:29 <ehamberg> can anyone suggest an elegant way of looking at the the first and last element of a list and drop the element if a given test is true?
15:38:37 <kmc_> "in" is not a function, it's syntax used with let
15:38:40 <kmc_> let x = y in z
15:38:46 <Beelsebob> elspru: I'm not sure I understand the question
15:38:48 <elspru> so far I haven't seen the "(+1) . floor"  connected with 0xff99 0x100
15:38:51 <kmc_> establishes a local binding x=y for the scope of z
15:39:04 <elspru> how do i find, how many bytes it takes to represent a certain int
15:39:06 <clutchsk1> ah ... cool
15:39:10 <kmc_> > floor ((log 0xff99) / (log 0x10)) + 1
15:39:11 <lambdabot>   4
15:39:21 <elspru> amazing :D
15:39:36 <kmc_> > let nBits = (+1) . floor . (/ log 2) . log in map nBits [1..]  --- elspru i had this a while ago
15:39:37 <lambdabot>   [1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,...
15:39:41 <kmc_> it's up there
15:39:54 <kmc_> oh and the name is wrong ;)
15:40:09 <elspru> kmc_: the nBits stuff with the infinite string means very little to me
15:40:13 <johnnowak> elspru: it's impossible to ask a question in #haskell without half a dozen people spraying infinite lists in response... sorry about that
15:40:22 <johnnowak> just ignore them
15:40:24 <kmc_> > let nBits = (+1) . floor . (/ log 2) . log in map nBits [1..7]
15:40:27 <clutchsk1> kmc_: thanks!
15:40:28 <elspru> lol k
15:40:28 <Beelsebob> elspru: well, [1..] generates *all* natural numbers
15:40:41 <lambdabot>   [1,2,2,3,3,3,3]
15:40:41 <kmc_> ... is it really easier to understand with a finite list?
15:40:44 <kmc_> i was just demonstrating the use of this function nBits at multiple arguments
15:40:50 <Beelsebob> elspru: then he maps nBits across them ‚Äì i.e. ask "how many bits do you need for each natural number"
15:41:00 <merehap> kmc_: yup, I'm with you
15:41:03 <kmc_> > let nBits = (+1) . floor . (/ log 2) . log in map nBits [1..2999673254]
15:41:04 <lambdabot>   [1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,...
15:41:05 <kmc_> there it's finite ;P
15:41:15 <elspru> lol
15:41:24 <johnnowak> not exactly my point, but very well
15:41:30 <kmc_> johnnowak, what's your point exactly
15:41:41 <Beelsebob> > let nBits = (+1) . floor . (/ log 2) . log in map length . group . map nBits [1..]
15:41:42 <lambdabot>   No instance for (GHC.Real.Integral [a])
15:41:42 <lambdabot>    arising from a use of `GHC.Real....
15:41:54 <kmc_> anyway that's not the clearest way to write the function
15:42:00 <johnnowak> kmc_: that the poor guy just wants a simple answer
15:42:01 <djahandarie> pointless almost
15:42:02 <Beelsebob> > let nBits = (+1) . floor . (/ log 2) . log in map length . group . map nBits $ [1..]
15:42:06 <lambdabot>   mueval-core: Time limit exceeded
15:42:23 <kmc_> > let nBits n = ((log n) / (log 2)) +1) in map nBits [1..2999673254]
15:42:23 <lambdabot>   <no location info>: parse error on input `)'
15:42:28 <kmc_> > let nBits n = ((log n) / (log 2)) +1 in map nBits [1..2999673254]
15:42:29 <lambdabot>   [1.0,2.0,2.584962500721156,3.0,3.321928094887362,3.584962500721156,3.807354...
15:42:47 <kmc_> johnnowak, and giving the answer *and* an example of its use and demonstration of correctness is not good?
15:42:52 <kmc_> > let nBits n = floor ((log n) / (log 2)) +1 in map nBits [1..2999673254]
15:42:53 <lambdabot>   [1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,...
15:43:32 <tensorpudding> #haskell is so helpful it's unhelpful!
15:43:33 <lunabot>  luna: Not in scope: `haskell'
15:43:40 <djahandarie> I don't understand how someone could use Haskell and NOT understand the concept of infinite lists
15:43:44 <johnnowak> i'm not going to argue why generating an infinite list of the answer for all natural numbers is silly when a) you'd never do that in practice, and b) it's more than he was asking for
15:43:57 <kmc_> johnnowak, you are not familiar with the concept of "demonstration"
15:43:57 <johnnowak> it should be obvious
15:44:07 <kmc_> the "let .. in" nicely separates the answer i give and the demonstration of how it works
15:44:35 <merehap> johnnowak: "it should be obvious", that's a great assumption to use with beginners
15:44:36 <kmc_> giving multiple examples is more useful than picking one arbitrary test case
15:44:58 <kmc_> fine here is the simple answer:   nBits n = floor ((log n) / (log 2)) +1
15:45:01 <kmc_> see, it's what i said above
15:45:07 <kmc_> with the added bonus of not testing it
15:45:23 <tensorpudding> lazy data structures are one of the great things about haskell
15:45:34 <kmc_> i mean i'm not using [1..] to show off Haskell
15:45:41 <kmc_> i'm using it to generate test cases for the problem at hand
15:45:48 <kmc_> here i will make you all happier
15:45:52 <merehap> tensorpudding: therefore lets hide them away so no beginner can see them!
15:46:05 <kmc_> > let nBits n = floor ((log n) / (log 2)) +1 in map nBits [1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18,19,20]
15:46:06 <lambdabot>   [1,2,2,3,3,3,3,4,4,4,4,4,4,4,5,5,5,5,5]
15:46:08 <tensorpudding> well, they are surely going to confuse some people
15:46:49 <aavogt> > succ . floor $ log 0 / log 2
15:46:51 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
15:47:03 <kmc_> hehe
15:47:07 <merehap> yeah, but learning lazy lists are essential for breaking in to the Haskell paradigm, I would say...
15:47:31 <tensorpudding> > log 0
15:47:32 <lambdabot>   -Infinity
15:47:44 <tensorpudding> > log 0 / log 2
15:47:46 <lambdabot>   -Infinity
15:47:52 <c_wraith> > succ $ log 0
15:47:53 <lambdabot>   -Infinity
15:47:57 <aavogt> > floor (log 0) == minBound
15:47:58 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:47:58 <lambdabot>    `GHC.Real.Integral b'
15:47:58 <lambdabot>   ...
15:48:06 <aavogt> > floor (log 0) == (minBound :: Int)
15:48:07 <lambdabot>   False
15:48:16 <djahandarie> -_-
15:48:35 <djahandarie> Integer?
15:48:35 <aavogt> > floor (log 0) :: Int
15:48:36 <lambdabot>   0
15:48:37 <kmc_> > minBound
15:48:38 <lambdabot>   ()
15:48:49 <tensorpudding> interesting...
15:48:54 <monochrom> > log 0
15:48:55 <lambdabot>   -Infinity
15:49:03 <monochrom> > log 0 :: Double
15:49:04 <lambdabot>   -Infinity
15:49:12 <monochrom> Fun...
15:49:14 <tensorpudding> @type minBound
15:49:15 <lambdabot> forall a. (Bounded a) => a
15:49:18 <aavogt> so where does 0 come from?
15:49:34 <monochrom> Unexplained mystery.
15:49:55 <c_wraith> > 0 / 0.0
15:49:56 <lambdabot>   NaN
15:50:05 <monochrom> > floor (0 / 0.0)
15:50:06 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
15:50:09 <elspru> > :t floor
15:50:10 <lambdabot>   <no location info>: parse error on input `:'
15:50:13 <monochrom> hahahaha....
15:50:14 <djahandarie> \o/
15:50:21 <elspru> >:t floor
15:50:25 <zygoloid> > floor (-1 / 0 :: Double) :: Int
15:50:25 <lambdabot>   0
15:50:27 <Badger> :t floor
15:50:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:50:41 <monochrom> > floor (1/0)
15:50:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
15:50:49 <elspru> ya so is there a version that uses Int's?
15:50:51 <monochrom> "very big number"
15:50:52 <c_wraith> > floor (0 / 0.0) == (minBound :: Int)
15:50:53 <lambdabot>   False
15:51:09 <djahandarie> > minBound :: Int
15:51:10 <lambdabot>   -9223372036854775808
15:51:13 <djahandarie> > minBound :: Integer
15:51:15 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
15:51:15 <lambdabot>    arising...
15:51:17 <djahandarie> Err
15:51:21 <djahandarie> Yeah
15:51:22 <djahandarie> Random
15:51:24 <djahandarie> :P
15:51:25 <tensorpudding> Integer is not bounded
15:51:25 <elspru> like I've never heard of realFrac or Integral types before
15:51:38 <djahandarie> tensorpudding, yes I know, but was just testing. :P
15:51:43 <tensorpudding> well, technically, it is
15:51:50 <elspru> and I've been using haskell for years
15:51:51 <monochrom> "Dad, what is the biggest number?" "179769313486231590772930519078902473361797697894230657273430081157732675805..."
15:51:53 <tensorpudding> but the bounds are not explicit
15:52:25 <elspru> okay, i'll figure out another way
15:52:31 <Cale> elspru: RealFrac encompasses fractional types which are subsets of the real numbers (so not complex), Integral captures all integer-like types.
15:52:35 <elspru> maybe with string manipulation or something
15:52:37 <djahandarie> monochrom, and then we know the world has ended when Haskell compilers give birth to children!
15:52:39 <aavogt> > length $ show $ floor $ log (1/0)
15:52:40 <lambdabot>   309
15:52:52 <shachaf> > ceiling (1/0)
15:52:53 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
15:52:54 <aavogt> > length $ show $ 10^^1000
15:52:55 <lambdabot>   8
15:53:05 <elspru> Cale: sounds like math
15:53:06 <aavogt> > length $ show $ (10^^1000::Integer)
15:53:07 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
15:53:07 <lambdabot>    aris...
15:53:08 <tensorpudding> > 10^^1000
15:53:09 <lambdabot>   Infinity
15:53:09 <Cale> elspru: So, for example, the type means that floor will convert from Double to Int, or from Rational to Word16
15:53:15 <tensorpudding> huh?
15:53:15 <monochrom> > ceiling(1/0) - floor(1/0)
15:53:16 <aavogt> > length $ show $ (10^1000::Integer)
15:53:16 <lambdabot>   0
15:53:17 <lambdabot>   1001
15:53:26 <tensorpudding> @type (^^)
15:53:27 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
15:53:37 <monochrom> At least it gets ceiling(oo)-floor(oo) right.
15:53:39 <tensorpudding> what is (^^)
15:53:54 <Cale> tensorpudding: exponentiation to possibly negative integer exponents
15:54:05 <tensorpudding> oh, so it's just a more generic (^)
15:54:14 <tensorpudding> i thought it was like knuth arrows or something
15:54:17 <Cale> tensorpudding: More generic in the exponent, less generic in the base
15:54:25 <Cale> There's also...
15:54:30 <Cale> :t (**)
15:54:32 <lambdabot> forall a. (Floating a) => a -> a -> a
15:54:56 <johnnowak> :t let x = 42 in (x, 42)
15:54:57 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
15:55:06 <Cale> So, yes, we can has three exponentiation operators.
15:55:09 <c_wraith> > 1 ** 57.2372809
15:55:10 <lambdabot>   1.0
15:55:13 <tensorpudding> ah, tetration, that is what i was thinking of
15:55:24 <Cale> Each corresponds to a different definition of exponentiation from mathematics.
15:55:47 <monochrom> We should have at least a couple of exponentiations because people disagree royally on what to do with 0 to the 0.
15:55:49 <Cale> (in mathematics, we tend to use the same notation for them, because they line up pretty well)
15:56:11 <Cale> Anyone who has thought about it for any length of time will agree that 0^0 should be 1
15:56:16 <c_wraith> > 0 ^ 0
15:56:17 <lambdabot>   1
15:56:25 <tensorpudding> GHC agrees
15:56:31 <monochrom> It really drives home the point that there is no Platonic "real" exponentiation. Different users patch up different inventions.
15:56:47 <c_wraith> > (0 ^^ 0, 0 ** 0)
15:56:48 <lambdabot>   (1.0,1.0)
15:56:59 <tensorpudding> @hoogle exp
15:56:59 <lambdabot> Prelude exp :: Floating a => a -> a
15:56:59 <lambdabot> Language.Haskell.TH data Exp
15:56:59 <lambdabot> Language.Haskell.TH.Syntax data Exp
15:57:05 <Veinor> 0^0 looks like some kind of face
15:57:23 <Liskni_si> more like glasses without a face
15:57:30 <Veinor> Ha
15:57:31 <tensorpudding> is there an exp defined for complex numbers somewhere...
15:57:34 <djahandarie> (.)$(.)
15:57:43 <djahandarie> Hoot hoot
15:57:44 <Cale> I can imagine 0 ** 0 being left undefined, because that point is additional to the x ** y = exp (log x * y) definition
15:57:45 <Veinor> a stripper with a dollar-bill tip
15:57:52 <Veinor> :D
15:57:56 <Cale> (clearly, 0 is not in the domain of log)
15:58:01 <monochrom> > (0:+1)**(0:+1)
15:58:02 <lambdabot>   0.20787957635076193 :+ 0.0
15:58:11 <monochrom> That's complex exponentiation i^i
15:58:27 <Cale> > 0 ** 0 :: Complex Double
15:58:27 <monochrom> x:+y is x+iy
15:58:28 <lambdabot>   NaN :+ NaN
15:58:32 <Cale> ^^ bad
15:58:38 <Veinor> > (2.718281818:+0) ** (0:+3.14159265)
15:58:40 <lambdabot>   (-0.9999999999999999) :+ 1.5677597564940778e-8
15:58:41 <Veinor> :D
15:59:01 <monochrom> haha
15:59:19 <tensorpudding> > (2.718281818:+0) ** (0:+3.14159265) == ((-1) :+ 0)
15:59:20 <lambdabot>   False
15:59:44 <Veinor> is there a Data.Complex.i ?
15:59:52 <dmwit> > 0 :+ 1
15:59:54 <lambdabot>   0.0 :+ 1.0
16:00:03 <dmwit> > sqrt (-1) :: Complex
16:00:04 <lambdabot>   `Data.Complex.Complex' is not applied to enough type arguments
16:00:04 <lambdabot>  Expected ki...
16:00:05 <monochrom> A scene from Black Adder: "The king is probably dead. Long live the king."
16:00:06 <tensorpudding> @hoogle pi
16:00:07 <lambdabot> Prelude pi :: Floating a => a
16:00:07 <lambdabot> Data.Fixed type Pico = Fixed E12
16:00:07 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
16:00:11 <aavogt> @hoogle i
16:00:12 <lambdabot> module Data.Array.IArray
16:00:12 <lambdabot> Data.Array.IArray class IArray a e
16:00:12 <lambdabot> Prelude id :: a -> a
16:00:13 <dmwit> > sqrt (-1) :: Complex Double
16:00:14 <Veinor> > sqrt (-1) :: Complex Double
16:00:14 <lambdabot>   (-0.0) :+ 1.0
16:00:14 <lambdabot>   (-0.0) :+ 1.0
16:00:17 <tensorpudding> @hoogle e
16:00:17 <lambdabot> Data.Graph.Inductive.Example e :: Gr Char ()
16:00:18 <lambdabot> Data.Graph.Inductive.Example e' :: IO (SGr Char ())
16:00:20 <lambdabot> Data.Fixed data E12
16:00:22 <Veinor> > sqrt (-1) :: Complex Integer
16:00:22 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Integer.Internals.Integer)
16:00:24 <lambdabot>    aris...
16:00:29 <Veinor> ah, RealFloat
16:00:36 <tensorpudding> so there is pi but not e?
16:00:38 <tensorpudding> lame
16:00:41 <dmwit> > exp 1
16:00:42 <lambdabot>   2.718281828459045
16:00:49 <Veinor> tensorpudding: pi is used more :P
16:00:57 <tensorpudding> depends on what you're doing
16:01:08 <dmwit> No, it's just that e is available another way and pi isn't.
16:01:22 <Veinor> arctans!
16:01:26 <monochrom> See, you can even have e^2.
16:01:27 <tensorpudding> it's not too hard to implement machin's algorithm
16:01:53 <monochrom> Think of exp as polymorphic e.
16:01:57 <dmwit> Hm, neat, Skype supports s/regex/replacement/ syntax now.
16:02:09 <dmwit> Though it's implicitly global. =/
16:02:23 <monochrom> We heard you loved e so we put in exp so you can haz parameterized e.
16:02:24 <tensorpudding> > ((exp 1) :+ 0)**(0 :+ pi)
16:02:25 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
16:02:28 <Veinor> pi = 16 arctan .2 - arctan (1/239)
16:02:38 <Veinor> er
16:02:43 <Veinor> pi = 16 arctan .2 - 4 arctan (1/239)
16:02:53 <tensorpudding> > ((exp 1) :+ 0)**(0 :+ pi) == ((-1) :+ 0)
16:02:54 <lambdabot>   False
16:03:12 <monochrom> > 4*arctan 1
16:03:13 <lambdabot>   Not in scope: `arctan'
16:03:19 <monochrom> > 4*aan 1
16:03:20 <lambdabot>   Not in scope: `aan'
16:03:22 <monochrom> > 4*atan 1
16:03:23 <lambdabot>   3.141592653589793
16:03:46 <zygoloid> > 2*asin 1
16:03:47 <lambdabot>   3.141592653589793
16:03:52 <Veinor> > ((exp 1) :+ 0) ** (0 :+ pi)
16:03:53 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
16:03:57 <Veinor> floating poiiiiiiiiiiint!
16:04:12 <tensorpudding> stupid floating point
16:04:34 <tensorpudding> we need computers with the whole real numbers built-in
16:05:07 <yitz> > pi :: CReal
16:05:07 <Cale> Heh, ZFC definable reals
16:05:07 <lambdabot>   3.1415926535897932384626433832795028841972
16:05:08 <monochrom> > ((exp 1) :+ 0) ** (0 :+ pi) :: Complex CReal
16:05:10 <lambdabot>   (-1.0) :+ 0.0
16:05:14 <Veinor> computable reals
16:05:15 <monochrom> \o/
16:05:15 <zygoloid> > imagPart . log $ (-1) :+ 0
16:05:16 <lambdabot>   3.141592653589793
16:05:27 <zygoloid> > imagPart . log $ (-1) :+ 0 :: CReal
16:05:28 <lambdabot>   3.1415926535897932384626433832795028841972
16:05:39 <Cale> I wonder how well you could work with even non-computable reals.
16:05:51 <Cale> I wonder if there's a potential benefit there in obscure cases.
16:05:51 <monochrom> But I wonder how CReal manages to do that!
16:06:03 <Veinor> > ( ((exp 1) :+ 0) ** (0 :+ pi) :: Complex CReal) == ((-1) :+ 0)
16:06:04 <lambdabot>   True
16:06:08 <Veinor> hooray!
16:06:10 <tensorpudding> haskell knows chaitin's constant
16:06:26 <Veinor> @faq can haskell compute the nth digit of chaitin's constant?
16:06:26 <lambdabot> The answer is: Yes! Haskell can do that.
16:06:30 <tensorpudding> but it can't tell us, that would be too easy
16:06:37 <Veinor> well played :P
16:06:46 <Cale> You might not be able to compute Chaitin's constant, but you could define it in a way that lets you work with it as an abstract idea.
16:07:33 <Cale> I suppose it would effectively behave similarly to undefined with regard to computing digits anyway
16:07:42 <zygoloid> haskell can solve non-computable problems, but figuring out which source file does that is itself non-computable ;-)
16:08:11 <Veinor> well, I think that for most sane languages you can get the first few bits
16:08:26 <Cale> So that after applying some transformations, you might be able to compute some digits, but thereafter, just get nontermination, the same way you might get when performing operations on an undefined computable real
16:09:16 <tensorpudding> omega is pretty big
16:09:21 <Veinor> well, if the language in question is some prefix-free variant of C
16:09:41 <kqrx> does anyone know of a lightweight haskell compiler? (ghc weights in at about 200 megabytes, and i'd rather not like that for a small slow laptop...)
16:09:42 <Veinor> like, a program in which the main function must be at the very end
16:09:55 <tensorpudding> hugs is smaller and more portable
16:09:58 <tensorpudding> but it doesn't compile
16:10:03 <tensorpudding> does it?
16:10:12 <Cale> hugs ought to compile...
16:10:17 <Veinor> then I think you can extract a few bits of omega simply because short programs can be decided :D
16:10:24 <Cale> Er, you mean hugs isn't a compiler?
16:10:29 <Cale> That's true, it's not a compiler :)
16:10:46 <Veinor> hugs does not compile (transitive) :P
16:10:51 <monochrom> yhc, nhc, ...
16:11:01 <tensorpudding> hmm
16:11:15 <tensorpudding> www.haskell.org/index.html is really old looking
16:11:37 <kqrx> debian.org is worse
16:12:01 <Cale> kqrx: Unfortunately for those with not much free disk space, GHC is the only real option for serious work at the moment. Of course, for learning the language, you might not need everything.
16:12:02 <monochrom> Just use http://www.haskell.org/
16:12:08 <tensorpudding> last updated in 2005
16:12:10 <tensorpudding> i know
16:12:21 <kmc_> kqrx, you can buy a 2 GB USB stick for like $5
16:12:28 <tensorpudding> i got linked to www.haskell.org/index.html though, and i'm just pointing out that this page is old and should probably get removed
16:12:39 <kmc_> as for "slow" it is not clear what the on-disk size of ghc has to do with that
16:12:40 <monochrom> Supposedly "index.html" is implementation detail and abstraction leak because it could be "Overview.html" instead.
16:12:48 <kmc_> certainly programs compiled with ghc will run much much faster than those interpted by hugs
16:12:55 <kqrx> kmc_: good point
16:13:07 <kmc_> there is some relationship (e.g. slow IO)
16:13:25 <Veinor> Last update: 20 November 2005
16:13:26 <Veinor> oh no!
16:13:40 <yitz> a book-sized USB 1 TB external hard disk is under $150, pocket-sized under $200.
16:13:42 <tensorpudding> also debian.org is updated regularly, it just looks like it isn't because they don't care about looking modern
16:13:47 <Veinor> haskell died four years ago and we're just a ghost!
16:14:00 <tensorpudding> i see dead languages
16:14:02 * sproingie vanishes in a puff of logic
16:14:53 * monochrom goes to the imaginary part.
16:14:59 <tensorpudding> haskell is significantly less dead than clean
16:15:11 * hackagebot upload: tkhs 0.2.3 - Simple Presentation Utility (YusakuHashimoto)
16:15:21 <Veinor> I was kind of expecting haskell to be dead when I first heard about it >_>
16:15:38 <kmc_> Veinor, indeed.  most languages like this never make it out of a small academic circle
16:15:44 <kmc_> Haskell wasn't intended to, either
16:16:12 <tensorpudding> haskell's pretty old
16:16:13 <Veinor> avoid success at all costs?
16:16:35 <Cale> We seem to suck at avoiding success.
16:16:37 <tensorpudding> considering how it's only now getting any traction
16:16:41 <sproingie> we failed to fail
16:16:43 <Cale> We need to be more insular.
16:16:51 <Veinor> stop being so nice to newbies!
16:16:52 <sproingie> FAIL FAIL
16:17:24 <c_wraith> haskell was started in...  1984ish?
16:17:35 <tensorpudding> i thought it was like 88 or 89
16:17:37 <Veinor> wikipedia says 1990
16:17:42 <kmc_> first standard in 98
16:17:45 <tensorpudding> yes
16:17:47 <sproingie> 1498
16:17:53 <sproingie> thus haskell 98
16:17:56 <Cale> c_wraith: The first standard was produced in 89/90, but there was work on it before that.
16:17:57 <Veinor> in 1498 a committe made a language great
16:18:04 <Veinor> :D
16:18:15 <kmc_> err yeah, first standard wasn't '98
16:18:18 <Cale> and of course, it's derived from a host of similar research languages before it
16:18:20 <kmc_> there was like Haskell 1.2 and whatever
16:18:22 <merehap> in which the world failed to partake...
16:18:29 <Cale> The first one was Haskell 1.0
16:18:30 <tensorpudding> then it wasn't until a few years ago that anyone had heard about it
16:18:32 <sproingie> lack of a computer to run it on did not stop critics from leveling charges that garbage collection made it too slow
16:18:41 <Veinor> sproingie: ?
16:18:59 <kmc_> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
16:19:08 <scree_> the true renaissance man can do garbage collection in his head
16:19:12 <Cale> I have a book here from 1975 which uses a language quite similar to Haskell.
16:19:21 <tensorpudding> miranda?
16:19:24 <Cale> In fact, it even uses (:) for list cons
16:19:28 <yitz> Actually, the algorithm we use for Data.List.permutations is based in part on an algorithm developed by English church bell ringers in the 1400s
16:19:32 <Cale> I'm not sure if it's quite Miranda.
16:19:38 <tensorpudding> maybe ISWIM
16:19:39 <roconnor> KRC?
16:19:55 <tensorpudding> err, not ISWIM
16:19:57 <Cale> Yeah, it's like ISWIM, but better defined
16:20:01 <sproingie> did anyone ever actually implement ISWIM?
16:20:09 <tensorpudding> the one that the miranda guy did before he did miranda
16:20:13 <Veinor> 1964 - John Kemeny and Thomas Kurtz create BASIC, an unstructured programming language for non-computer scientists.
16:20:16 <Veinor> 1965 - Kemeny and Kurtz go to 1964.
16:20:16 <Veinor> Oh god.
16:20:18 <Cale> No, it was a rough sketch of a language which wasn't really anything you could call a definition
16:20:39 <sproingie> i figured it was "this is a language that might run on the SECD machine"
16:20:44 <Zao> http://ianen.org/haskell/bindings/cpython/api-documentation/CPython.html <- oh god the horrors
16:20:46 <roconnor> : is a terrible name for cons
16:20:46 <tensorpudding> SASL?
16:20:53 <Cale> lol, GOTO the ultimate time machine
16:21:26 <c_wraith> the algorithm used by Data.List.permutations is confusing.  It's not as fast as a simpler allgorithm, and it doesn't provide lexicographically ordered output.
16:21:29 * sproingie learned there's an OS called Time Warp.  it has one synchronization primitive: Rollback
16:21:30 * roconnor prefers something like ‚óÇ for cons
16:21:43 <sproingie> i wonder if it's called jumpToTheLeft
16:21:56 <yitz> "retry" is Haskell's time machine
16:21:56 <scree_> @src Data.List.permutations
16:21:56 <lambdabot> Source not found. You speak an infinite deal of nothing
16:22:11 <roconnor> @go haskell time travel
16:22:12 <lambdabot> Maybe you meant: google googleit do
16:22:19 <sproingie> @google google
16:22:19 <lambdabot> http://www.google.com/
16:22:19 <lambdabot> Title: Google
16:22:29 <kmc_> @google bing
16:22:29 <lambdabot> http://www.bing.com/
16:22:30 <sproingie> .oO( )
16:22:34 <tensorpudding> @google @google
16:22:35 <lambdabot> http://www.google.com/
16:22:35 <lambdabot> Title: Google
16:22:49 <tensorpudding> @google justfuckinggoogleit
16:22:50 <merehap> @google elgoog
16:22:51 <lambdabot> http://justfuckinggoogleit.com/
16:22:51 <lambdabot> Title: Just Fucking Google It
16:22:52 <lambdabot> http://elgoog.rb-hosting.de/
16:22:54 <Cale> roconnor: If only we had such symbols which were possible to type in 1 or 1.5 keystrokes.
16:22:54 <sproingie> BWA
16:23:18 <Veinor> 1991 - Dutch programmer Guido van Rossum travels to Argentina for a mysterious operation. He returns with a large cranial scar, invents Python, is declared Dictator for Life by legions of followers, and announces to the world that "There Is Only One Way to Do It." Poland becomes nervous.
16:23:56 <kqrx> Cale: how do you type something in 1.5 keystrokes?
16:24:01 <Veinor> Cale: < ... oh wait
16:24:18 <Cale> kqrx: one keystroke, plus a modifier key
16:24:28 <tensorpudding> what is the sound of one key clacking?
16:24:40 <Veinor> it's a clicking sound. just press a single key :D
16:24:43 <kqrx> Cale: that's two strokes, isn't it?
16:25:02 <kqrx> Cale: anyways, that depends on your layout... i've got access to a shitload of symbols in 1.5 keystrokes
16:25:16 <roconnor> Cale: http://www.wickensonline.co.uk/apl/unicomp-apl-front.jpg
16:25:21 <Cale> Well, sort of -- you may sometimes be holding that key down.
16:25:37 <Cale> roconnor: right.
16:25:50 <kqrx> tensorpudding: depends on the mechanism of the keys... *wants a buckling spring keyboard*
16:26:12 <Cale> I can type lots of symbols, but they take many more keystrokes to access, since I usually have to switch into TeX-table mode.
16:26:34 <Cale> I can switch to Greek characters by hitting both shift keys
16:26:49 <kmc_> kqrx, you can buy one from unicomp
16:26:56 <kmc_> original model M design
16:27:02 <Cale> But usually my alternate SCIM mode is set on Japanese rather than TeX, which makes a lot of things farther away.
16:27:15 <sproingie> i had one of those.  then i decided to open it up.
16:27:18 <kqrx> kmc_: hmm, how much are they?
16:27:20 <kmc_> too much
16:27:23 <kmc_> like $100
16:27:26 <kmc_> depends on model
16:27:27 <sproingie> i call those "humpty dumpty keyboards" now
16:27:32 <kqrx> i was afraid of that :/
16:27:39 <kmc_> on the other hand for $260 you can get the Kinesis Contoured Advantage
16:27:42 <kmc_> which is fucking amazing
16:27:50 <Cale> In any case, I think that : is decent notation for cons.
16:27:54 <tensorpudding> i like my cheap keyboard
16:28:02 <sproingie> kenesis countoured advantage sounds like a brand of vibrator
16:28:09 <tensorpudding> i have a model m but it's too heavy
16:28:27 <merehap> tensorpudding: certainly a problem for a vibrator
16:28:56 <roconnor> In my experience texmacs style entry of character works quite well.  I wonder where they stole it from.
16:29:01 <kqrx> tensorpudding: isn't it meant to just... rest on the desk?
16:29:23 <tensorpudding> the model m would be the worst vibrator ever
16:29:32 <roconnor> you write vague ascii art and then use tab to select the character.
16:29:52 <pastah_rhymez> http://lenovoblogs.com/designmatters/?p=2737 <-- new KB design... i think this was recently released in english
16:29:53 <Cale> Yeah, TeXmacs is something that I would use for homework, but not for anything serious. It seems to have really bad scaling issues on even moderately large documents, and I don't really like the output as much as real LaTeX.
16:30:08 <pastah_rhymez> i think the swedish version will be coming within a month or so
16:30:08 <roconnor> Cale: I wrote my thesis in TeXmacs
16:30:12 <Cale> But it's really convenient for quick notes.
16:30:29 <roconnor> mostly out of my hate for LaTex
16:30:36 <Cale> roconnor: Oh? Did you somehow avoid the problems where it seemed to have O(n^2) performance on a lot of things?
16:31:04 <roconnor> Cale: yes, I wrote three parts and assembled them at the end
16:31:04 <Cale> Maybe they've fixed it up somewhat since I last used it.
16:31:06 <kqrx> roconnor: why the hatred towards latex?
16:31:10 <Cale> ah
16:31:33 <roconnor> TeXmacs or something like it has a lot of potential.  I kinda want to rewrite it in Haskell :D
16:31:48 <Cale> I had problems with documents that were only 10 pages long :P
16:32:00 <roconnor> kqrx: I learned HTML / SGML first, and after that LaTeX just seemed like a big mess or random hacks.
16:32:13 <tensorpudding> LaTeX is a big mess of hacks
16:32:13 <roconnor> HTML / SGML / DSSSL
16:32:16 <sproingie> HTML strikes me as a big mess of random hacks
16:32:21 <opqdonut> indeed
16:32:23 <sproingie> SGML+DSSSL is nice
16:32:33 <Cale> I used plain TeX for a long time before LaTeX
16:32:34 <opqdonut> xhtml is nice, but i dislike xml in general
16:32:44 <opqdonut> latex gets the job done
16:32:56 <tensorpudding> latex is "good enough"
16:33:00 <opqdonut> the markup is passable, and it looks great
16:33:01 <opqdonut> imo
16:33:07 <Cale> The LaTeX syntax seemed kind of heavy to me, with all its \begin{...} \end{...} madness ;)
16:33:09 <roconnor> sproingie: I still write my resume with SGML + DSSSL
16:33:12 <kqrx> latex gets the job done, and usually with a beautiful result and very small amount of effort from my side
16:33:15 <tensorpudding> which is why it still exists and probably won't be replaced for a while
16:33:16 <opqdonut> i used *roff before latex
16:33:51 <opqdonut> they are pretty good for your basic text, headings, tables, justifying and a nice font
16:33:51 <Berengal> I'm a fan of markdown...
16:34:01 <sproingie> gml looks a lot like troff actually
16:34:03 <opqdonut> markdown strikes me as a big mess of random hacks
16:34:07 <Berengal> It is
16:34:11 <sproingie> sgml can be made to look like it
16:34:15 <opqdonut> but some other lightweight markups are nice
16:34:16 <sproingie> (troff that is)
16:34:26 <opqdonut> and pandoc is <3
16:34:31 <Cale> The thing about TeX is that its output mostly looks right, and mathematicians are generally extremely picky about the appearance of typeset mathematics.
16:34:38 <opqdonut> indeed
16:34:43 <opqdonut> that's why i switched to tex
16:34:47 <opqdonut> from groff
16:34:48 <opqdonut> equations
16:34:51 <roconnor> opqdonut: how do I write haskell style infix `mod` in inline code for markdown?
16:34:57 <Cale> Get the scale factor on exponents a little off, and the whole thing looks terrible.
16:35:04 <opqdonut> roconnor: i have no idea, honestly
16:35:04 <kmc_> indeed, [La]TeX looks right basically by definition
16:35:11 <opqdonut> indeed
16:35:12 <roconnor> opqdonut: ha
16:35:39 <opqdonut> what did i say, hacks
16:35:47 <Cale> roconnor: I seem to recall that something like `` or \` worked.
16:36:01 <kmc_> pandoc's markdown is probably friendlier
16:36:07 <Berengal> markdown has escapes, but I don't know what they are...
16:36:13 <roconnor> oops I wa s supposed to ask Berengal my question
16:36:15 <kmc_> maybe not inline, but you can do real lhs
16:36:31 <Berengal> That's one of the things I like about markdown: I don't have to know anything about it to use it
16:36:52 <roconnor> <Berengal> That's one of the things I like about markdown: I don't have to know anything about it to use it
16:36:52 <Berengal> As long as your needs are simple, it just works
16:36:54 <opqdonut> i dislike markup's list syntax and weird indentation rules
16:36:57 <roconnor> <Berengal> markdown has escapes, but I don't know what they are...
16:37:03 <Cale> markdown is very similar to wiki syntax.
16:37:14 <kmc_> if you use Gitit, very very similar ;)
16:37:15 <Cale> (not wikipedia syntax)
16:37:24 <opqdonut> but there are options, restructured text etc
16:37:28 <opqdonut> mediawiki markup is ok too
16:37:37 <sproingie> ech
16:37:46 <kmc_> dokuwiki sucks hard
16:37:59 <opqdonut> i actually like confluence's markup, simple things are simple, the rest is done with stuff like {color:red}, {code} etc
16:38:05 <Cale> I really hate how there are all these web applications which mangle text horribly, and can't seem to do anything right.
16:38:19 <sproingie> my take on wiki markup is that it's a user interface.  as a format, they all suck.  hard.  all of them.
16:38:23 <opqdonut> you mean thosw wysiwyggy javascript editors?
16:38:25 <Cale> WordPress is particularly difficult to get into a sensible state.
16:38:26 <sproingie> as a UI it's not that bad
16:38:36 <kmc_> what is a format if not a UI?
16:38:47 <sproingie> a format is a UI and then some
16:39:08 <Cale> It often seems to mangle your source before storing it in its database, so when you view the source for your pages, it's not even what you put in the first time.
16:39:12 <opqdonut> a format is a ui that's nice to write code about ;)
16:39:21 <sproingie> sounds about right
16:40:07 <Cale> There are too many web applications which are written using PHP and messes of regular expressions.
16:40:21 <sproingie> unfortunately not many wikis store in any canonical format, so they come to depend more and more on the quirks of the markup parser and renderer
16:40:47 <Cale> by people who don't understand security and do all these cargo-cultish things to text
16:40:54 <opqdonut> indeed
16:40:59 <opqdonut> gitit is nice
16:41:08 <sproingie> mediawiki's parser and renderer are both lovecraftian horrors
16:42:26 <Cale> You know what would be really nice? If instead of producing yet another HTML, the people designing the web browsers would define a proper programming language for page layout with proper facilities for abstraction and libraries.
16:43:08 <opqdonut> isn't that the direction we're going?
16:43:11 <Cale> So that we wouldn't have builtin things like CSS with a kajillion stupid little details, but something akin to CSS could be a library.
16:43:19 <opqdonut> with javascript etc.
16:43:22 <gwern> markdown is pretty good but some of it is terrible. like the 'two trailing spaces to break a quote'
16:43:24 <Cale> I guess sort of.
16:43:31 <gwern> or '* and _ do the same thing'
16:43:40 <opqdonut> indeed
16:43:53 <Cale> I also really despise XML.
16:44:04 <Cale> It is *way* too complicated for what it is.
16:44:13 <dibblego> Cale, that would be awesome; I'll buy it
16:44:35 <gwern> dibblego: how much will you pay me for JSON
16:44:41 <dibblego> pfft
16:45:19 <Cale> CSS is so dumb in that it has zero facility for abstraction of common tasks.
16:45:33 <Cale> Essentially nothing is first class.
16:45:46 <gwern> your momma's so dumb she can't abstract her prostitution tasks
16:46:54 <tensorpudding> designing webpages with CSS is like decorating your wall with corkboard and pushpins
16:47:02 <ray> i really hate css
16:47:11 <ray> but that's heresy
16:47:15 <kmc_> all web abstraction is handled on the server side :/
16:47:42 <ray> html is ok
16:47:53 <ray> doesn't need reinventing
16:47:59 <ray> needs evolving, like html 5
16:48:00 <Cale> HTML really isn't OK either. It has way way too many primitives.
16:48:03 <Cale> and no abstraction
16:48:13 <ray> what kind of abstraction
16:48:17 <c_wraith> neither html nor css are ok.
16:48:26 <ane_> it's good for what it was made for but not good for what people think it should be
16:48:48 <Cale> ray: Look at the HTML for any given page, and you'll likely see a lot of repetition. There's no way to factor that repetition out.
16:48:57 <ray> oh, right
16:48:58 <c_wraith> ray: I want a function that draws my widget containing the string passed in.  html doesn't allow that
16:49:07 <ray> the orthodox answer is some bullshit with xml transforming
16:49:12 <ray> that's bullshit
16:49:36 <ray> so i get what you are saying
16:49:40 <Cale> yeah, you have a stupid half-assed functional language with AWFUL syntax.
16:49:47 <Cale> and no library
16:50:02 <gwern> so compile to html
16:50:05 <gwern> it's assembler
16:50:14 <Cale> HTML makes a bad target though
16:50:51 <Cale> You would want something much simpler and much easier to control the behaviour of as a page layout target language.
16:50:54 <ray> it would be more like assembler without css, but yeah
16:51:17 <Cale> Something a lot more like postscript.
16:51:55 <tensorpudding> writing webpages in postscript would be...different
16:51:57 <Cale> (in that it would give you very low-level control over positioning and drawing)
16:52:18 <Cale> and then libraries for things like reflowing text would be written on top of that
16:52:27 <Saizan_> but they want html to look decently on various media and sizes
16:52:41 <ray> well, the party line is that you shouldn't be allowed low-level control, and then everyone goes to great lengths to get it anyway
16:54:01 <ray> there was display postscript once
16:54:03 <Cale> Well, maybe reflowing things would need to be something primitive anyway, but you get the idea.
16:54:09 <sproingie> ray: still is on OSX
16:54:21 <sproingie> er display PDF now :-/
16:54:51 <dibblego> Cale, when will it be available for purchase?
16:54:55 <Cale> dibblego: heh
16:55:16 <Cale> dibblego: The hard part isn't necessarily even designing and implementing this stuff
16:55:26 <sproingie> i remember working with DPS in solaris 7.  it stunk to high heaven.
16:55:34 <sproingie> slow, never antialiased, crashy.
16:55:35 <Cale> dibblego: It's getting the support for it into major browsers so that it could be used.
16:55:38 <dibblego> what is? Supporting a browser?
16:55:48 <dibblego> Cale, I thought that came in the package
16:56:27 <Cale> dibblego: I'm talking about effectively replacing the rendering engines in browsers, or at least writing a new front end to them.
16:57:15 <dibblego> Cale, OK, I'll take two
16:57:18 <Cale> hehe
16:57:47 <Cale> But I'm probably not the person to actually write it.
16:58:07 <dibblego> you don't have a keyboard?
16:58:15 <Saizan_> i gather that writing a rendering engine is quite a lot of work
16:58:34 <tensorpudding> the internet is broken, let's fork it
16:58:49 <newsham> mv css #haskell-blah
16:59:08 <jfischoff> can you make a prop in quickcheck that is polymorphic? Or do you have to work with concrete types?
16:59:11 <Cale> I suppose there is a middle ground where someone figures out a sensible way to use HTML/CSS/Javascript as a target language, and designs another language/Haskell EDSL which compiles to that and handles all the cross-browser issues etc. But that's a mess.
16:59:20 <monochrom> I am considering using hs-plugins for its purpose. Do you have further blessings or disapprovals?
16:59:36 * shapr sings
16:59:40 <Cale> jfischoff: The property can be polymorphic, but you tend to have to apply it at a concrete type
16:59:46 <shapr> jfischoff, yes
16:59:47 <Heffalump> jfischoff: you can make a polymorphic property, because a property is like any other Haskell value
17:00:09 <Heffalump> but as Cale says you'll probably have to disambiguate when you run it
17:00:13 <Cale> monochrom: which purpose?
17:00:17 <monochrom> Specifically I will have IO routines of a very specific type. I suppose it poses the least of problems.
17:00:18 <jfischoff> cool
17:00:25 <Heffalump> and be careful of what defaulting does
17:00:38 <Cale> monochrom: You might also want to look at hint
17:00:45 <monochrom> load and unload IO rountines.
17:00:49 <Heffalump> @quickcheck \xs -> null xs || all (==head xs) xs
17:00:49 <lambdabot> Unknown command, try @list
17:00:54 <Heffalump> @check \xs -> null xs || all (==head xs) xs
17:00:54 <lambdabot>   "OK, passed 500 tests."
17:01:05 <Cale> monochrom: Yeah, try hint, it's a little nicer, and built more directly on top of the GHC API.
17:01:37 <Cale> (hs-plugins uses the GHC API now, but not for everything that it could use it for, from what I recall)
17:01:48 <Saizan_> i'm not sure how to get hint to compile code with optimizations though
17:02:09 <Cale> Saizan_: You can run GHC over the code beforehand, and if the .o files are present, it will load them, just like ghci
17:02:14 <monochrom> I will compile myself and load *.o and *.hi files
17:03:18 <dibblego> is there a minimum/maximum that uses Maybe instead of error?
17:07:12 <tensorpudding> what characters are acceptable in haskell identifiers?
17:08:46 <kmc_> unicode letters and _
17:08:48 <monochrom> abc'_ are
17:08:49 <kmc_> see the report
17:09:09 <monochrom> abc012'_
17:10:18 <Cale> variable ids start with a lowercase unicode letter, and are followed by a string of alphanumeric unicode characters and quotation marks, and are not permitted to be a certain set of reserved keywords
17:10:45 <c_wraith> contain?  not match?
17:11:43 <monochrom> For example "dataa" is alright
17:13:31 <monochrom> "d…ët…ë" is also alright. :)
17:13:40 <tensorpudding> so would ‚Üë be acceptable?
17:13:48 <ray> :t delete
17:13:49 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
17:13:55 <tensorpudding> ghci is giving me malformed crap
17:13:56 <ray> tensorpudding: maybe as an operator
17:14:05 <ray> and yet "delete" has let in it
17:14:12 <ray> that is a better example, monochrom
17:14:15 <monochrom> > isAlpha '‚Üë'
17:14:16 <lambdabot>   False
17:14:18 <theorbtwo> tensorpudding: ‚Üë isn't alpha, or numeric, or a quotation mark.
17:14:31 <ray> or _
17:14:39 <tensorpudding> > let a ‚Üë b = (a + b)
17:14:40 <lambdabot>   not an expression: `let a ‚Üë b = (a + b)'
17:14:46 <ray> then i guess not
17:14:50 <tensorpudding> :\
17:14:53 <ray> wait
17:14:56 <ray> that's not an expression
17:14:59 <ray> what am i saying
17:15:11 <dibblego> @pl fmap join . mapM
17:15:12 <lambdabot> fmap join . mapM
17:15:15 <ray> > let a ‚Üë b = a + b in 2 ‚Üë 2
17:15:16 <tensorpudding> > let ‚Üë a b = (a + b)
17:15:16 <lambdabot>   4
17:15:17 <lambdabot>   <no location info>: parse error on input `‚Üë'
17:15:20 <ray> see, it works
17:15:23 <tensorpudding> okay
17:19:36 <dibblego> @pl (a -> a -> a) -> [a] -> Maybe a
17:19:36 <lambdabot> (line 1, column 4):
17:19:36 <lambdabot> unexpected ">"
17:19:36 <lambdabot> expecting variable, "(", operator or ")"
17:19:39 <dibblego> @hoogle (a -> a -> a) -> [a] -> Maybe a
17:19:39 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
17:19:40 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
17:19:40 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
17:22:58 <tensorpudding> is it possible to use foldr as infix?
17:23:09 <Saizan_> 2
17:23:14 <kmc_> `foldr]
17:23:15 <kmc_> `foldr`
17:23:23 <Saizan_> ?type \f z -> f `foldr` z
17:23:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:23:37 <kmc_> (f `foldr` 0) [a,b,c]
17:23:39 <kmc_> > (f `foldr` 0) [a,b,c]
17:23:40 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:23:41 <lambdabot>    `SimpleReflect.FromExpr ...
17:23:47 <kmc_> > (f `foldr` 0) [a,b,c] :: [Expr]
17:23:48 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
17:23:49 <lambdabot>    arising from the lite...
17:24:07 <tensorpudding> okay, so it has to be written that way
17:24:12 <kmc_> fucufcucucfuoceuc
17:24:13 <Saizan_> > (f `foldr` 0) [a,b,c] :: Expr
17:24:34 <Saizan_> @bot
17:24:35 <lunabot>  :o
17:24:55 <increpare> kmc_ hmm?
17:25:30 <lambdabot> :)
17:25:30 <lambdabot>   f a (f b (f c 0))
17:31:18 <merehap> well I guess I learned something about IRC today
17:31:26 <merehap> why isn't the network more robust?
17:31:44 <merehap> it seems netsplits should be a bit less likely...
17:32:21 <Zao> merehap: Because ircds are excellent targets for DDoSes.
17:32:52 <Zao> merehap: Someone gets kicked, DDoS. Someone gets glined, same. Someone wants to take over a channel by booting services and owners, DDoS.
17:32:56 <Zao> Etc.
17:33:07 <merehap> interesting
17:34:08 <kmc_> i like applying this rule to the real world
17:34:08 <CalJohn> exactly, social centers get DDoS'd
17:34:08 <kmc_> if you ever get kicked out of a club, come back the next day with a gas can and a match
17:34:16 <sproingie> irc's architecture wasn't designed to handle the tens of thousands of asshat griefers who actively attempt to destroy it
17:34:32 <repnop> it isn't irc
17:34:40 <merehap> so are there any better, more redundant protocols?
17:34:55 <repnop> it's the fact that they have more bandwidth via zombies than most providers can fight againt
17:35:06 <sproingie> it's also irc's architecture
17:35:15 <medfly> kmc_: I am trying your approach from now on
17:35:45 <mle> merehap: redundancy would likely result in duplicate message delivery, so you'd need a complete protocol change.
17:35:48 <kmc_> "Los Angeles was destroyed today after two freshman engineering majors were expelled from UCLA"
17:36:12 <kmc_> it's a really fortunate fact that hydrogen bombs are a little tricky to make
17:36:16 <sproingie> you'd only need server-to-server protocol change
17:36:34 <sproingie> ircd's usually speak some private dialect between themselves anyway
17:36:35 <merehap> mle: well general internet routers have several backup routes so if one goes down there is only a short delay before the link is established
17:36:45 <repnop> well most ircds have a leaf/hub arch already
17:36:47 <kmc_> although i think a private organization will build at least a little atomic bomb sometime in the next few decades
17:36:51 <merehap> it seems the same could be done for irc
17:37:00 <mle> merehap: I don't think you see the scale of the ddos problem.
17:37:31 <increpare> yeah will take more than a couple of nukes to deal with it
17:37:54 <increpare> Maybe an international forced sterilization program might deal with it
17:38:06 <merehap> mle: the only recent ddos attacks that have been successful against the core internet infrastructure have been protocol bugs in DNS and BGP
17:38:09 <monochrom> irc network is deliberately a tree by design (every node is a cut-point!) so that the simplest implementations can be used.
17:38:33 <mle> merehap: email is already almost unusable.
17:38:47 <sproingie> the DDOS people will still outgun the irc network, but a more robust system would at least keep it from being so easy
17:38:47 <repnop> it's up to the network monochrom
17:38:52 <merehap> mle: you mean spam? I think I've seen 2 spam emails in the last year
17:38:58 <repnop> you can have many leafs that only have a small amount of clients...
17:39:22 <mle> merehap: good for you.  but this is sorta offtopic here.
17:39:42 <monochrom> If you start doing even a biconnected graph, you will receive duplicates and you have to do real work as opposed to just a naive select()-then-recv-or-send loop.
17:40:01 <tensorpudding> hooray running out of ram trying to calculate knuth arrows
17:40:20 <xerox> what are knuth arrows?
17:40:31 <kmc_> big fukkin numbers
17:41:22 <tensorpudding> it's a generalization of exponentiation
17:41:39 <tensorpudding> a single arrow is just an exponent
17:42:02 <tensorpudding> if A is the arrow, then (a A b) = a^b
17:42:20 <Raynes> Twey: Real World Haskell didn't seem to make Lazy I/O sound as bad as you say it is. As a matter of fact, they actually seemed to hype you up about it quite a bit. What a dream killer. :\
17:42:58 <tensorpudding> if you have two arrows, you do (a AA b) = a A (a A ... A a)) where you have done A b times
17:43:12 <tensorpudding> and you can define it recursively for any number of arrows
17:43:13 <increpare> tensorpudding: thought you were talking about a variation of haskell Arrows there (especially with the notation : P )
17:43:14 <monochrom> You can use the getContent kind of lazy I/O if you don't want to distinguish between eof and other exceptions.
17:43:35 <sproingie> graham's number: because googleplex is for kiddies
17:43:42 <tensorpudding> they get unusably big really quick
17:43:48 <increpare> though I imagine there're some analogies that can probably be drawn between the two (given that exponentials represent the cardinality of sets of functions)
17:43:56 <Saizan_> and don't care much about when the handle is closed
17:44:23 <tensorpudding> graham's number is too big to given easily in terms of knuth arrows
17:44:46 <kmc_> > let up 1 a b = a^b; up _ _ 0 = 1; up n a b = up (n-1) a (up n a (b-1)) in up 2 4
17:44:48 <lambdabot>   * Exception: stack overflow
17:44:51 <tensorpudding> but can be succinctly expressed in conway arrows
17:45:01 <tensorpudding> hmm
17:45:16 <tensorpudding> that's another conway + knuth pairing, the second i've seen this week
17:46:11 <increpare> tensorpudding: what was the first?
17:46:39 <tensorpudding> the surreal numbers
17:46:51 <tensorpudding> conway came up with the numbers, and knuth came up with the name
17:47:01 <increpare> tensorpudding: ah yep.  And he wrote a book, as a sort of tribute to conway.
17:47:14 <increpare> (or that's in effect what it functioned as)
17:47:29 <tensorpudding> yes
17:48:02 <tensorpudding> conway did a lot of cool math stuff
17:48:25 <increpare> tensorpudding: *is* doing a lot of cool math stuff : )
17:48:27 <tensorpudding> yes
17:48:47 <tensorpudding> i first heard of him in terms of knots actually
17:49:00 <tensorpudding> and then heard of him again through games
17:49:09 <sproingie> i first heard of him in terms of Life
17:49:10 <tensorpudding> and now yet again through these surreal numbers
17:49:23 <sproingie> and that's still about all i can understand :)
17:49:39 <increpare> tensorpudding: my first real interaction with his stuff was throguh surreal numbers.  Though it's bloody hard to find out proper articles on them (There's a lot of crud).  It's really fun programming them in haskell (you can make good use of amb! : D )
17:50:27 <tensorpudding> hmm, i forgot about the free-will theorem
17:54:26 <increpare> tensorpudding: hadn't come across the '15 theorem' before - it's pretty excellent : )
17:56:43 <djahandarie> -_-
18:10:52 * hackagebot upload: GPX 0.1 - Parse GPX files (TonyMorris)
18:19:50 <pshc> hmmm... so I'm working on a toy language, doing type inference
18:20:15 <pshc> it looks like, for substitution composition, order matters
18:20:35 <pshc> but I have a hard to time figuring out which way things should be composed
18:20:40 <JohnnyL> so
18:20:57 <pshc> though Algorithm W spells it out for its small example language, when extending it gets messy
18:21:54 <pshc> anyone recommend some good material for this intution? Kind of scared of the proofs themselves
18:26:35 <ccasin> pshc: The best treatment of algorithm-w-like inference I know of is in "practical type inference for arbitrary-rank types", by peyton jones et al
18:26:50 <ccasin> it's a long, tutorial style discussion of the topic
18:27:03 <ccasin> it gets to arbitrary rank types, but starts by just explaining algorithm w
18:27:25 <ccasin> showing how to implement it using a monad in haskell (there is code too)
18:27:35 <ccasin> though I don't know if it reaches the level of complexity you want
18:27:39 <pshc> ooh.
18:27:52 <pshc> oh, not complex at all
18:28:20 <pshc> I'm just trying to divine the rationale behind the order of composition of substitutions
18:28:26 <pshc> like (s3 o s2 o s1)
18:29:03 <pshc> if I rearrange those, the types end up being too general
18:29:40 <pshc> so I'm OK for the cases presented by the original Algorithm W, but not always sure what is the right order otherwise
18:29:49 <pshc> anyway, I'll read it over, thanks!
18:39:36 --- mode: irc.freenode.net set +o dibblego
18:39:36 --- mode: irc.freenode.net set +o ChanServ
18:39:36 <pshc> and get some substitutions from that
18:39:36 <pshc> call them s2
18:39:36 <pshc> and my existing current substitution is s1
18:39:36 <pshc> so then... do I do s1' = s1 `compose` s2? or s1' = s2 `compose` s1?
18:39:40 <pshc> (well, s1 `compose` s2 gives me my desired type, while the other is too general)
18:40:15 <pshc> so what I'm saying is in general, how do I know which way to compose? Is the current subtitution always on the left side of `compose`?
18:40:48 <pshc> intuitively to me it feels like the current substitution should be on the right side...
18:42:55 <Cale> pshc: It could go either way, obviously it's a convention, but I'd probably expect substitutions to work like functions
18:43:14 <Cale> (and composition to use the same convention as function composition)
18:43:33 <pshc> yeah I would expect that too...
18:43:49 <pshc> but I get different results depending on order
18:44:04 <Cale> of course
18:44:17 <pshc> so... if I'm just consistent all the time?
18:44:51 <pshc> I don
18:44:52 <pshc> er
18:45:20 <pshc> I don't know, I guess I don't grok it quite yet... I mean if I'm writing code, it's pretty obvious which order functions need to be composed in
18:45:29 <pshc> but for subtitutions it's not so clear for me
18:51:40 --- mode: irc.freenode.net set +o dibblego
18:52:11 * hackagebot upload: data-accessor 0.2.1.2 - Utilities for accessing and manipulating fields of records (HenningThielemann)
18:53:48 <sshc> if I use the writer monad for debugging purposes on something that's a bit expensive, will there be a big difference if I *don't* use the debug output?
18:56:23 <sshc> if I use the writer monad for debugging purposes on something that's a bit expensive, will there be a big difference if I *don't* use the debug output?
18:56:34 <sshc> I want to know if Haskell's laziness will only have something evaluated if and only if I use it.  If Haskell more or less ignores it or it doesn't have a big impact on performance, I can leave it there, but if it does, I'll only use the writer monad when I'm debugging.
18:57:43 <pshc> damn netsplit :)
18:58:10 <sshc> pshc: maybe I should wait until it's over before I ask again?
18:58:14 <Codex_> sshc: how are you removing it when you don't use it?
18:58:18 <merehap> sshc: from the best of my knowledge, there should be very little performance impact if you don't use the result
18:58:23 <aavogt> sshc: it probably will have an impact though
18:58:24 <dmwit> sshc: You are correct, lazy evaluation means that it will not be computed.
18:58:33 <sshc> Codex_: I don't always want to use the result
18:58:36 <merehap> sshc: which would explan why there is a lazy and strict version
18:58:39 <sshc> Codex_: I only want to use the result when I'm debugging
18:58:40 <Botje> you'll still create thunks.
18:58:43 <dibblego> > fst (7, undefined) -- sshc
18:58:44 <lambdabot>   7
18:59:07 <sshc> ok, thanks!
18:59:12 <dmwit> ?unmtl Writer monoid value
18:59:12 <lambdabot> (value, monoid)
18:59:40 <Berengal> sshc: Profile and see for yourself. GHC might be able to remove most of it as long as you have no references to the debug output in the finished code
19:00:06 <aavogt> @quote transformer
19:00:07 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
19:00:19 <Berengal> sshc: The thunks won't be evaluated anyway, but there might be some extra function calls happening
19:00:24 <aavogt> @quote transformer.*.speed
19:00:24 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
19:03:04 <trie> any recommendation for a good explanation of "Function Dependencies" and when you need them?
19:05:11 <Botje> the paper? :]
19:05:51 <ben0x539> Do people ever update their papers when the extensions or libraries described in them change?
19:06:26 <trie> "Language and Program Design for Functional Dependencies" MP Jones?
19:08:22 <trie> or "Type classes with functional dependencies." by the same author?
19:08:32 <Botje> yeah. try that one first
19:10:44 <tensorpudding> all instances of Num are instances of Ord right?
19:11:18 <dmwit> na
19:11:19 <dmwit> no
19:11:30 <dmwit> class (Eq a, Show a) => Num a
19:14:43 <maikeru|> Any particularly recommended reading for learning haskell, or just http://haskell.org/tutorial?
19:14:55 <dmwit> ?where LYAH
19:14:56 <lambdabot> http://www.learnyouahaskell.com/
19:14:59 <dmwit> ?where RWH
19:15:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:15:02 <dmwit> ?where gentle
19:15:03 <lambdabot> http://www.haskell.org/tutorial/
19:15:10 <matt_f> real world haskell is my favorite
19:15:20 <dmwit> The Gentle Intro is my favorite, but it's none too gentle.
19:15:41 <maikeru|> Ah, thank you. I'll check those two out first then.
19:15:53 <matt_f> but learn you a haskell is good too :)
19:16:59 <maikeru|> matt_f: hah, this is no fair. I have a terrible time making decisions, like which to start with. I usually flip a coin to decide whether or not a coin flip decision should be made.
19:18:31 <mtnviewmark> evening all - anyone have trouble installing template-haskell 2.4 with GHC 6.10?
19:18:50 <matt_f> maikeru|: realworldhaskell is longer and has a lot more examples than the other two, a gentle introduction was more straightforward, and learnyouahaskell was probably more fun
19:19:05 <mjsor> I really like LYAH.
19:19:31 <mtnviewmark> I'm having the same problems as this person was: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14817
19:19:35 <maikeru|> matt_f: Hmm, thanks. I think I've narrowed it down to LYAH and RWH. I do like examples a lot, but such is true for fun as well.
19:19:57 <QinGW1> hi all, It reported "Setup: At lease the following dependencies are missing: time ==1.1.*" Error during cabal-install bootstrap when I install cabal. How to do it? thanks
19:20:15 <matt_f> maikeru|: i read them together, they mostly stay together and compliment each other
19:20:43 <matt_f> it's nice to get the same material reinforced in different ways :)
19:20:43 <mjsor> mtnviewmark: I had the same problem recently.  Never found a good solution in here.
19:20:44 <QinGW1> My ghc-version is 6.8.2
19:20:44 <nus> QinGW1, cabal install time?
19:20:54 <nus> ;-P
19:21:09 <mtnviewmark> hmmm... so, mjsor, you stays at TH 2.3.0.1?
19:21:16 <maikeru|> matt_f: Ah, cool - that was what I was checking for next, to see if they mostly went along with the other.
19:21:20 <QinGW1> nus: thanks, but it occur when I install cabal. so cabal not exist.
19:21:28 <maikeru|> And yeah, it definitely is :)
19:21:32 <mtnviewmark> problem is I wanted to go to Criterion 0.4
19:21:36 <mjsor> mtnviewmark: actually, I never found a work around unfortunately.
19:21:47 <mtnviewmark> sigh - wonder what's that about...
19:34:37 <Axman6> , (16/9,2560/1440)
19:34:38 <QinGW1> Does any other ways to install time except cabal.
19:34:39 <lunabot>  (1.7777777777777777,1.7777777777777777)
19:34:56 <dmwit> QinGW1: You can of course download it and install manually.
19:35:05 --- mode: irc.freenode.net set +o dibblego
19:35:13 <mtnviewmark> mjsor - turns out Hackage is having the same problem too!
19:35:13 <mtnviewmark> http://hackage.haskell.org/packages/archive/template-haskell/2.4.0.0/logs/failure/ghc-6.10
19:35:16 <matt_f> maikeru|: there's no wrong way to go about it, good luck
19:35:31 <Axman6> wtf  happenedc to freenode? o.O
19:35:35 <QinGW1> Thanks dmwit
19:35:51 <bd_> Axman6: ddosses
19:36:03 <maikeru|> matt_f: Thank ya. I'll likely be in here and full of questions in a few weeks once I've had time to read through those and give haskell a try.
19:36:05 <bd_> ie script kiddies with too much time and bots on their hands
19:36:31 <Axman6> maikeru|: we'll be happily awaiting your questions :)
19:36:47 <Axman6> mmm turkey
19:39:44 <Zeiris> What's the difference between using a Reader monad to store some config data your function uses, and passing that config data as a parameter?
19:40:09 <Axman6> potentially less typing?
19:40:15 <dmwit> no difference
19:40:18 <Botje> reader monad hides the clutter
19:41:16 <bd_> Zeiris: They are exactly identical, down to the type level
19:41:37 <bd_> ie, the reader monad really is, quite literally, passing that config as a paramter
19:41:40 <bd_> parameter*
19:41:49 <Zeiris> So there's no giant, obvious advantage as far as practical programming goes that I'm missing.
19:42:23 <merehap> cleanliness is a big advantage
19:42:23 <bd_> > ask 1
19:42:24 <lambdabot>   1
19:42:31 <bd_> > ask :: (a -> a)
19:42:32 <lambdabot>   {()->()}
19:42:36 <bd_> ask = id :)
19:43:06 <bd_> and yeah, it's all about hiding the clutter, acting as part of a monad transformer stack, and letting you use standard monad algorithms without having to think about your environment
19:45:30 <Zeiris> Standard monad algorithms being the 'do' sugar, and various arrows?
19:51:16 <dmwit> Zeiris: Yes, and things like mapM, sequence_, etc.
20:05:57 --- mode: irc.freenode.net set +o dibblego
20:06:09 <dibblego> there is an advantage to the Reader monad, like there is for using any abstraction, but there is no advantage of using Reader above (->) (they are equivalent)
20:08:24 <aavogt> dibblego: perhaps using Reader is a bit more explicit than ((->) r), which may or may not lead to less accidental use of the variable in the environment
20:08:41 <aavogt> err, Reader is definitely more explicit
20:09:12 <dibblego> I don't see how when Reader = (->)
20:09:34 <dibblego> the only thing more explicit is that it has a newtype wrapper
20:23:56 --- mode: irc.freenode.net set +o dibblego
20:24:05 <Codex_> what do you think about subsetsum problem?
21:19:54 <RadioApeShot> I am trying to access an sqlite database from haskell via the HDBC and the haskelldb-hdbc-sqlite cabal package.
21:20:31 <RadioApeShot> No dice, though, it complains about a missing dependency ("* Missing header file: sqlite3.6") even though I just compiled and installed the latest sqlite
21:20:58 <RadioApeShot> (version 3.6.21)
21:21:05 <RadioApeShot> Anyone approach this in a different way?
21:21:10 <RadioApeShot> Or know what is going on?
21:21:48 <RadioApeShot> I am running on Jaunty using the latest haskell platform
21:22:05 <Axman6> Adamant: you may need to provide the path to where the library and headers are stored. using --extra-include-dirs=/path/to/thing/include --extra-lib-dirs=/path/to/thing/lib
21:22:12 <RadioApeShot> I have tried that.
21:22:20 <RadioApeShot> No dice.
21:22:28 <RadioApeShot> Nothing I do seems to convince it to build.
21:23:24 <PepeSilvia> hi, I get a suggestion from hlint that doesn't actually work for me. Is there some kind of extension I need to enable for this: type CalendarEAlgebra = CalendarAlgebra Edits
21:24:00 <PepeSilvia> ghc says: Type synonym `CalendarAlgebra' should have 5 arguments, but has been given 1
21:26:43 <resistor> anyone familiar with HOpenGL around?
21:28:49 <kmc> tiny bit
21:31:41 <resistor> kmc_: do i need to do something special to make setting lineWidth work? my simple test program is crashing on a null dereference when i do "lineWidth $= 2.0"
21:31:57 <resistor> null dereference inside glSetLineWidth, that is :-/
21:32:11 <resistor> erm, glLineWidth
21:34:03 <resistor> same thing if i try to set lineSmooth, though the null dereference is in glEnable()
21:36:54 <kmc__> i don't know about that :/
21:50:13 <HaskellLove> what would this funciton look like: give me all combinations of 1 and 2, so that the sum equals to 10? so you should get stuff like: [2,2,2,2,2], [2,2,2,2,1,1], [2,2,2,1,1,1,1]
21:54:23 <dmwit> resistor: Did you call initialize and createWindow?
21:57:21 <lpsmith> HaskellLove:  sounds like a good exercise,  a straightforward application of recursion.
21:58:19 <HaskellLove> euler 31 is a good excercise yes, it will take me hours now but i am on good start
21:59:38 <HaskellLove> ones n = take n $ repeat 1; identity n = [n]; combinations = ones n ++ identity n ++ ... this is what i have so far, it is only for number 2, will work on 5 now
22:00:22 <dmwit> HaskellLove: There is an approach that is at once more flexible and simpler.
22:00:28 <dmwit> Give it a little thought...
22:01:10 <HaskellLove> yes i will, i asked here and expected quick answer but now i see the problem is not that easy... will enjoy thinking this one it is really great
22:01:18 <dmwit> Actually, the Inventor's Paradox might be relevant here.
22:01:39 <dmwit> What if you didn't know that the numbers you could use were 1 and 2?  What if I just handed you a list of numbers you could use?
22:01:40 <HaskellLove> i see the problem as Russian Dolls
22:01:55 <dmwit> Figuring out how to solve the problem in this more general case may actually be easier. ;-)
22:02:03 <HaskellLove> yeah i am going that way
22:02:18 <HaskellLove> basically it will test if the number is divisible with 2 and 5
22:02:25 <HaskellLove> to deal with that
22:02:35 <lpsmith> that's way too complicated, think simpler
22:02:37 <dmwit> i.e. for giving change for American money, I might give the list [1, 5, 10, 20, 50, 100] as possible summands...
22:02:41 <lpsmith> I'm looking at my solution now
22:02:47 <lpsmith> Very simple recursion
22:03:04 <HaskellLove> lpsmith dont tell me now i am on good way to do my own, wait for me to send code here
22:03:31 <lpsmith> Oh believe me,  I'm not going to give you an answer :-)
22:03:48 <lpsmith> But dmwit is right...
22:04:13 <Veinor> bleh, now I'm trying to figure it out :P
22:04:25 <HaskellLove> i this problem brainfucking me haha
22:04:44 <HaskellLove> i enjoy ^
22:06:49 <lpsmith> I will give you one little hint,  although it might not make sense:   ever take a combinatorics class?   Ever studied the binomial coefficients?   The recursion is similar....
22:08:17 <Veinor> got it!
22:08:21 <HaskellLove> well yeah but i cant see it yet as combinatorics problem, because of the condition untill sum reaches 10
22:08:57 * BMeph laughs out loud at lpsmith's honesty!
22:09:02 <HaskellLove> the choose formula can give me number of combinations, but not the combinations themselves
22:09:03 <dmwit> I'm not sure lpsmith's hint would help me, and I've solved this problem before. =P
22:10:17 <BMeph> I'm not sure if it would've helped me...but it wouldn't have hurt. :)
22:10:40 <lpsmith> My solution doesn't make use of binomial coefficients,  it's just that the particular recursion I used is similar :-)
22:12:08 <roboshibby> re
22:12:37 <dmwit> Hiya, roboshibby!
22:13:47 <roboshibby> heya
22:15:46 <Axman6> o/ roboshibby
22:15:53 <roboshibby> basic mathematics question if i may: im trying to nail down the proper terminology for what it is that a variable 'represents'. i know there isnt assignment in math, that's programming, but i dont know what a better word for the equality relationship of, say, "x = 5". thank you
22:16:00 * roboshibby ^5's Axman6 
22:16:05 <Axman6> heh
22:16:22 <dmwit> roboshibby: In Haskell, when you say "x = 5", it really means "x = 5" forever more.
22:16:27 <dmwit> ...unlike in other languages
22:16:32 <HaskellLove> a = getLine; main = print (show a) what is wrong with that?
22:16:39 <roboshibby> so that's a constant assignment, correct?
22:16:46 <Axman6> :t getLine
22:16:47 <lambdabot> IO String
22:16:53 <Axman6> > show getLine
22:16:53 <dmwit> HaskellLove: a is an IO action; you can't show IO actions, only execute them.
22:16:54 <lambdabot>   "<IO [Char]>"
22:17:12 <dmwit> roboshibby: It's an equation.
22:17:46 <HaskellLove> a = getLine; main = print a that does not work either
22:17:46 <dmwit> roboshibby: You can think of it as a constant assignment if you like, but the reality is that there are no non-constant assignments.  This is huge!
22:17:59 <dmwit> It means that there is equational reasoning in Haskell, just like in math.
22:18:00 <roboshibby> hrm, so then what /is/ a variable in math?
22:18:18 <roboshibby> what's the practical difference in this, than say how ruby works?
22:18:30 <roboshibby> my Q was about math, but i know ruby so can try to relate through it
22:18:34 <roboshibby> somewhat less objc
22:18:40 <dmwit> HaskellLove: Try main = a >>= print
22:19:19 <dmwit> roboshibby: In most languages, when you say "x = 5", that means: allocate memory to store the number 5, then let the name "x" point to that piece of memory.
22:19:39 <dmwit> roboshibby: Later, you can override that, and let the name "x" point to another piece of memory.
22:20:04 <roboshibby> sure, but x = 5 means x represents the value of 5 correct?
22:20:05 <dmwit> roboshibby: In Haskell, when you say "x = 5", that means: 'x' is now a synonym for the value '5'.
22:20:22 <roboshibby> ah hm, synonym
22:20:31 <dmwit> silly words
22:20:36 <dmwit> Call it how you like.
22:20:40 <HaskellLove> main = getLine >>= print wohoo welcome to the IO world of Haskell with binds and monads and crazy monsters
22:20:43 <dmwit> The important part is that it's always 5. =)
22:21:07 <j4cbo> i think of it as "binding"
22:21:11 <DigitalKiwi> dmwit: but he's asking what it is in math I think?
22:21:20 <dmwit> HaskellLove: It might be more readable for you this way: "main = do { line <- getLine; print line }".
22:21:28 <roboshibby> ok. so to me, conceptually, i categorize that as identity:value
22:21:30 <dmwit> HaskellLove: That is exactly equivalent to what I wrote.
22:21:41 <dmwit> j4cbo: sure
22:21:49 <roboshibby> some identity expression, x, is equated to the value 5
22:22:21 <dmwit> DigitalKiwi: Yeah, I think I'll step out of this conversation.  It's too late for me to explain anything well. =)
22:22:56 <roboshibby> synonym is a good way to think about it
22:23:08 <roboshibby> for all intents and purposes, x /is/ 5
22:23:22 <dmwit> right
22:23:34 <DigitalKiwi> until you change it
22:23:39 <roboshibby> sure
22:23:39 <Trinithis> haha
22:23:59 <roboshibby> thanks guys
22:24:05 <HaskellLove> main = do {input <- getLine; combinations (read input)::Int} I am trying to convert input from string to integer, please help
22:24:35 <Trinithis> > combinations [1,2,3]
22:24:36 <lambdabot>   Not in scope: `combinations'
22:24:52 <dmwit> HaskellLove: Two things.
22:24:52 <lpsmith> > subsequences [1,2,3]
22:24:53 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
22:25:06 <dmwit> HaskellLove: Put the type annotation inside the parens: combinations (read input :: Int)
22:25:37 <dmwit> HaskellLove: The second line of the do block must be an IO action.  So, for example "print (combinations (read input :: Int))".
22:25:52 <dmwit> HaskellLove: or, better: main = getLine >>= print . combinations . read
22:26:14 <HaskellLove> you mean the last action? or you can only have two in the main block?
22:26:17 <dmwit> main = print . combinations =<< readLn -- even better
22:26:21 <Trinithis> > filterM (const [True, False]) [1,2,3]
22:26:22 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
22:26:35 <Trinithis> > filterM (const [False, True]) [1,2,3]
22:26:37 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
22:26:41 <dmwit> HaskellLove: I mean the last line, yes.
22:27:06 <jfischof> has anyone used the Thrist package?
22:27:27 <dmwit> I tried to read the Thrist paper once, does that count?
22:27:48 <jfischof> dmwit: haha, yeah I just had my eyes gloss over
22:27:52 <alexyk> greetings -- I'm trying to do cabal install readline on MAc OSX, and the googled recipies about specifying MacPorts' one do not work.  I.e. this fails, even though I have readline 6.0 active there: cabal install readline --extra-include-dirs=/opt/local/include --extra-lib-dirs=/opt/local/lib ... Any fixes?
22:28:28 <jfischof> alexyk: have you read the install text that comes with the package?
22:28:29 <dmwit> I'm smarter now than I was last year.  Maybe I should try again some time.
22:28:44 <alexyk> jfischof: nope, how do I do that?
22:29:16 <medfly> regarding 'sortBy (\x y-> compare y x) [3,4,2]' is there a function that does the (\x y-> y x) part
22:29:18 <jfischof> alexyk: download the tar ball on the hackagedb page, and look for the INSTALL text file
22:29:54 <alexyk> jfischof: so I can't do that with just cabal?
22:30:18 <BMeph> jfischof: Looked at it, and read the paper, but I've never used it. It reminds me of a couple of other things - Restricted Monads and Session Types, especially.
22:30:23 <dmwit> medfly: flip
22:30:27 <jfischof> alexyk: I would go to the webpage
22:30:36 * medfly_ was misusing flip :)
22:30:46 <jfischof> Bmeph: alright, I'll report back
22:30:49 <Veinor> > sortBy (compare . flip) [3,4,2]
22:30:50 <lambdabot>   No instance for (GHC.Num.Num (a -> a -> b))
22:30:50 <lambdabot>    arising from the literal `3'...
22:30:53 <Veinor> ...
22:30:55 <dmwit> ?pl \x y -> compare y x
22:30:55 <lambdabot> flip compare
22:30:57 <medfly_> > sortBy (flip compare) [3,4,2]
22:30:58 <lambdabot>   [4,3,2]
22:31:03 <medfly_> that was that:)
22:31:10 <Veinor> oh yeah. silly me.
22:31:16 <medfly_> yeah, silly me too. same mistake :D
22:31:20 <medfly_> thanks!
22:31:20 <Veinor> :D
22:31:39 <Veinor> wait, what's the difference between ?pl and @pl?
22:31:45 <medfly_> I don't knowif there is
22:31:50 <dmwit> Veinor: They're the same.
22:31:53 <medfly_> I should use @pl to golf
22:31:59 <dmwit> Veinor: ? and @ are both command-starters for \bot.
22:32:14 <medfly> ah ok
22:32:14 <medfly> got it :)
22:32:28 <alexyk> jfischof: there's no INSTALL
22:32:44 <dmwit> Wait, were medfly and medfly_ not the same person there?
22:32:44 <jfischof> alexyk: what's the name of the package?
22:32:50 <alexyk> readline
22:32:56 <medfly_> dmwit: my connection dies
22:33:10 <Veinor> he is two minds in one :O
22:33:18 <alexyk> this is a googled question, folks adding MacPorts readline to it
22:33:35 <alexyk> the question is, does it work with GNU readline 6.0
22:34:39 <dmwit> I vaguely recall something strange about Macs and readline... like there's an Apple-distributed library called readline that is totally unrelated to GNU readline.
22:34:53 <dmwit> I guess you've already ruled out the possibility that you're linking against this wrong thing, right?
22:35:02 <dmwit> (I take it that's what Google told you about.)
22:35:07 <mle> it's a bsd-vs-gnu issue
22:35:25 <mle> osx-is-nextstep-is-netbsd userspace
22:35:30 * dmwit is almost totally uninformed about this and should most likely shut up
22:35:31 <alexyk> ah, I think I see MacPorts put the header into include/readline/
22:35:37 <j4cbo> :w
22:35:48 <j4cbo> ... do not mix up your irc and vi windows
22:35:55 <dmwit> ~/.irssi/logs/#haskell saved (192 KB)
22:36:24 <jfischof> alexyk: I would try install the readline lib with macports
22:36:42 <alexyk> jfischof: I do have that
22:37:03 <jfischof> alexyk: I don't know then
22:43:47 <lpsmith> Trinithis:   that is a pretty solution, but not very efficient,  unfortunately :-)
22:45:42 <dmwit> I don't think it is a solution.  At least, not to the summing problem...
22:45:47 <Trinithis> all we need now is sortM!
22:45:52 <Trinithis> jk
22:46:01 <dmwit> hah
22:47:01 <Trinithis> I wonder if a reasonable (and useful) type/defn could be made for something like sortM
22:47:42 <dmwit> sortIO :: (a -> a -> IO Ordering) -> [a] -> IO [a]
22:48:12 <Trinithis> @ty sortIo
22:48:13 <lambdabot> Not in scope: `sortIo'
22:48:15 <dmwit> sortIO (\x y -> print x >> print y >> prompt "Which one is bigger? " x y)
22:48:17 <dmwit> ;-)
22:48:19 <Veinor> :t Data.Map.lookup
22:48:19 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
22:48:28 <Trinithis> is sortIO real?
22:48:29 <Veinor> why was it originally m a? :/
22:48:31 <dmwit> no
22:48:38 <dmwit> Veinor: more general
22:48:45 <Veinor> yes, but why?
22:48:45 <dmwit> Veinor: Now ask why it's Maybe now.
22:49:02 <HaskellLove> combinations n | n==1 = 1 | n == 2 = combinations` n | otherwise = combinations` where combinations` = ones n ++ identity n
22:49:04 <HaskellLove> what is wrong with this?
22:49:15 <dmwit> HaskellLove: Ask your local neighborhood compiler.
22:49:20 <dmwit> Read his answer carefully.
22:49:43 <HaskellLove> well he says parse error on input `|' but i dont get him
22:49:53 <dmwit> Does he?  That's unhelpful.
22:50:01 <dmwit> How about "parse error on input `"
22:50:07 <dmwit> is that more helpful? ;-)
22:50:20 <Veinor> dmwit: because 99% of the time you want Maybe?
22:51:30 <dmwit> Veinor: Oh, really?  I used it at [a] plenty when it was polymorphic, and several other variations, as well.
22:51:42 <Ytinasni> Veinor: i want IO more than 1% or the time. :D
22:51:50 * Veinor shrugs
22:52:02 <Veinor> so what do you do now that it's Maybe if you want it in []?
22:52:04 <HaskellLove> combinations n | n==1 = 1 | n == 2 = combinations' n | otherwise = combinations' where combinations' = ones n ++ identity n well i removed the ` dmwit
22:52:15 <dmwit> HaskellLove: getting better =)
22:52:25 <HaskellLove> well what is it now
22:52:40 <dmwit> HaskellLove: Well, what does your compiler say now?
22:52:46 <Veinor> or, the general monad m
22:52:57 <dmwit> HaskellLove: This time, it should be a fairly enlightening type error.
22:53:08 <medfly_> odd
22:53:20 <dmwit> Veinor: maybe
22:53:24 <dmwit> :t maybe
22:53:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:53:33 <medfly_> I've written something and sent it to @pl, mine works, @pl-ised version doesn't?
22:53:36 <dmwit> :t maybe return fail
22:53:37 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe String -> a -> m a
22:53:51 <dmwit> :t maybe (fail "") return
22:53:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
22:53:57 <dmwit> but better is
22:54:00 <dmwit> :t maybe mzero return
22:54:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
22:54:21 <Veinor> well that assumes you're working in a MonadPlus!
22:54:22 <dmwit> medfly_: Happens sometimes; ?pl isn't type-aware.
22:54:32 <dmwit> Veinor: Yes.  So does "fail", basically.
22:54:36 <Veinor> true
22:55:01 <Veinor> oh hey, it's almost 1 am
22:55:08 <medfly_> it works on lambdabot... odd
22:55:08 <ivanm> @time
22:55:09 <lambdabot> Local time for ivanm is Tue Dec 29 16:54:44
22:55:11 <ivanm> no it isn't!
22:55:11 <ivanm> ;-)
22:55:18 <medfly_> @type (.)
22:55:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:55:24 <Veinor> @time
22:55:27 <lambdabot> Local time for Veinor is Tue Dec 29 01:55:00 2009
22:55:34 <medfly_> so I basically need fmap :P
22:55:49 <Veinor> oh yeah, server's in MA
22:55:51 <HaskellLove> dmwit i dont get it man
22:55:56 <ivanm> Veinor: so it's almost 2AM!
22:56:01 <ivanm> (for you)
22:56:08 <dmwit> HaskellLove: Okay, give me a sec to check out the error for myself.
22:56:12 <dmwit> Maybe I'm wrong again.
22:56:12 <medfly_> @type fmap
22:56:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:56:27 <Veinor> ivanm: s/you/the server irssi is running on/
22:56:33 <ivanm> ahhh
22:57:02 <medfly_> err, how do I get around (.) == fmap, do I replace it like that
22:57:16 <ivanm> @type (Prelude..)
22:57:17 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:57:22 <ivanm> medfly_: ^^ that what you mean?
22:57:54 <dmwit> HaskellLove: An excerpt from my error message: "Couldn't match expected type `a -> b' against inferred type `[c]' in the expression "combinations' n"."
22:58:01 <medfly_> nono, lambdabot gave me something which uses (.) as fmap (I think), I would like it to work even on my non (.) = fmap Haskell
22:58:03 <dmwit> HaskellLove: That looks like a pretty good error to me.
22:58:11 <dmwit> HaskellLove: What's the type of combinations'?
22:58:26 <dmwit> HaskellLove: Compare that type to how you're using it in the expression "combinations' n".
22:58:28 <medfly_> like the other way around :P
22:58:32 <dmwit> You should be good to go after that. =)
22:58:45 <HaskellLove> ok
22:59:08 <ski> medfly_ : what did lambdabot give you ?
22:59:22 <medfly_> map =<< subtract . minimum
22:59:26 <medfly_> I'm not used to using fmap :P
22:59:28 <dmwit> medfly_: Why don't you just drop the offending ?pl command in here.
22:59:41 <medfly_> @pl offset xs = map (\n->n - (minimum xs)) xs
22:59:42 <lambdabot> offset = map =<< subtract . minimum
22:59:57 <ski> @type let (.) = (Prelude..) in map =<< subtract . minimum
22:59:58 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a]
23:00:10 <dmwit> :t map =<< subtract . minimum
23:00:11 <ski> @type let (f . g) x = f (g x) in map =<< subtract . minimum
23:00:11 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a]
23:00:12 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a]
23:00:26 <ski> medfly_ : it doesn't seem to require that Caleskell variant ..
23:00:32 <medfly_> oh... odd
23:00:37 <dmwit> medfly_: import Control.Monad.Reader
23:00:39 <sshc> > 1
23:00:40 <lambdabot>   1
23:01:13 <medfly_> thanks!
23:01:18 * medfly_ was a bit confused :)
23:01:18 <ski> though as i think dmwit is suggesting, it might need `instance Monad ((->) r)'
23:01:57 * dmwit is indeed suggesting that
23:03:02 <jfischof> BMeph: Thirst works. I wish it had a foldr though
23:03:39 <jfischof> BMeph: if you look at the source on hackage there is a little demo commented out. I would try that
23:08:20 <roboshibby> what's Control.Monad do?
23:08:24 <roboshibby> rather, what is it
23:08:37 <Veinor> a miserable little pile of functions!
23:08:50 <roboshibby> ?
23:08:55 <Veinor> nevermind.
23:09:40 <ivanm> roboshibby: provides a whole bunch of convenience functions for use with monads
23:09:47 <ivanm> e.g. liftM{,2,3,4,...}
23:09:50 <ivanm> @type liftM4
23:09:50 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
23:10:02 <ivanm> @src liftM4
23:10:02 <lambdabot> liftM4 f m1 m2 m3 m4 = do { x1 <- m1; x2 <- m2; x3 <- m3; x4 <- m4; return (f x1 x2 x3 x4) }
23:10:57 <roboshibby> im new, so that means nothing to me. what's a monad?
23:11:20 <medfly_> you opened a can of worms
23:11:30 <ivanm> maybe you should read through tutorials or the wikipedia page on Monads rather than just asking us here
23:12:02 <alexyk> where should I email about readline-1.0.1.0 not building on Snow Leopard for me?
23:12:04 <Veinor> oh dear.
23:12:18 <roboshibby> ok, but i was mainly just curious what haskell developers have to say about it
23:12:24 <roboshibby> im reading the web in the meantime
23:12:35 <alexyk> monad is just a tag
23:12:58 <roboshibby> tag?
23:13:07 <Veinor> what is a monad? a miserable little pair of functions! but enough of this, have at you!
23:13:17 <Veinor> ... I'll go stand in the corner now.
23:13:31 <alexyk> but anyhoo, is haskell-cafe appropriate for package not building help reauests?
23:13:44 <Veinor> yeah.
23:13:54 <medfly> I'm told monads are like all of mathematics: things that abide a set of arbitrarily chosen rules.
23:14:00 <medfly> ;)
23:14:05 <lpsmith> heh
23:14:13 <alexyk> roboshibby: there's a 1M monad tutorials on the web.  There's even a microsoft channel 9 video, for deity'ssakes.
23:14:28 <lpsmith> well,  most interesting mathematics have some justification,  eventually,  for the rules they choose
23:14:32 <alexyk> everybody and their half-uncle teach what a monad now
23:14:40 <medfly> you sure are exaggerating
23:14:46 <medfly> no one outside the Haskell community knows what a monad is
23:14:48 <alexyk> medfly: ok, quarter uncle
23:14:58 <lpsmith> That's what bugs me about category theory,  it takes *forever* to get to the "eventually" part
23:15:11 <medfly> what's an eventually part
23:15:15 <dibblego> yes they do
23:15:17 <alexyk> medfly: folks in Scala and Clojure and OCaml and F# communities are well versed in monads, trust me.
23:15:20 <medfly> lpsmith: is it the part where it's not a set of arbitrarily chosen rules?
23:15:27 <medfly> okay, then some other languages too
23:15:31 <alexyk> some of them, at least.
23:15:42 <dibblego> I know a midwife who has never programmed and knows what a monad is
23:15:49 <medfly> is she a mathematician
23:15:53 <medfly> what's a midwife?
23:15:54 <dibblego> no, a midwife
23:15:59 <lpsmith> medfly:  lpsmith:  well,  most interesting mathematics have some justification,  eventually,  for the rules they choose  ;-)
23:16:08 <dibblego> a registered nurse with a post-graduate degree in child birthing
23:16:14 <kmc> roboshibby, if you're new to Haskell, you have a lot to learn before you get to monads
23:16:32 <roboshibby> ive just heard the term for a while, decided to see what it is
23:16:33 <alexyk> dibblego: broseph!  nice to see you here.  I had to drink from the source, and now stupid readline woulnd't build -- these people don't use VMs, they compile from tarballs...
23:16:39 <kmc> they're not a core feature of Haskell, as some would have you believe
23:16:57 <kmc> roboshibby, a monad is simply any type which is a member of the Monad typeclass
23:16:58 <dibblego> alexyk, you mean to install GHC?
23:17:08 <kmc> which means it supports these two functions:
23:17:09 <kmc> :t return
23:17:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:17:11 <kmc> :t (>>=)
23:17:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:17:13 <alexyk> dibblego: that works, but cabal install readline can't find the right one.
23:17:16 <ivanm> dibblego: are you related to this midwife by marriage? :p
23:17:20 <alexyk> ./configure is soo 1970s
23:17:22 <dibblego> ivanm, no
23:17:29 <medfly> 1970, lol
23:17:45 <medfly> how does this midwife know what a monad is and I don't
23:17:49 <Veinor> HINAM
23:17:54 <dibblego> because I told her
23:17:55 <alexyk> sure Java world is slow, but none of that find me lib heck knows where crap
23:17:56 <medfly> oh
23:18:26 <dibblego> alexyk, what is your error?
23:18:45 <ivanm> medfly: dibblego can bash FP-related knowledge into _anyone_ ;-)
23:18:48 <dibblego> also, saying the Java world (maven haha!) is any way better off, is likely to attract giggles
23:18:54 <alexyk> checking for rl_begin_undo_group... no -- seems famous, I googled the solution, and it doesn't work.
23:19:03 <medfly> though, to be honest, I didn't know Haskell before, and someone bashed it into me
23:19:29 <alexyk> it finds the lib but not that symbol; apparently it's a mac osx broken libreadline clone; so I point at the macports' one, and still no luck.
23:19:41 <medfly> was she giving birth to your child and you were like "so monads support this return function and (=<<)..."
23:19:57 <kmc> roboshibby, monads give us a common language for using different "computational features" like nondeterminism, exceptions, side effects, parsers, logic programming, concurrency, code generation, software transactional memory, ...
23:20:22 <roboshibby> kmc, what are the terms and definitions of this language?
23:20:30 <kmc> return and (>>=)
23:20:34 <kmc> two ordinary Haskell functions
23:20:36 <alexyk> this is supposed to point to the macports' readline and it fails too: cabal install readline --extra-include-dirs=/opt/local/include --extra-lib-dirs=/opt/local/lib
23:20:39 <kmc> which are associated with a typeclass named Monad
23:20:40 <roboshibby> what do they do?
23:20:46 <kmc> in the same way (+) is associated with the typeclass Num
23:21:05 <kmc> :t return
23:21:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
23:21:17 <dibblego> alexyk, I've not been able to get apple products to work since the 2e
23:21:20 <kmc> so e.g. return :: a -> IO a, return :: a -> Parser a
23:21:28 <alexyk> someone on #scala told me about an excellent monad tutorial by a Microsoft guy in Channel9 videos, any URLs for that?
23:21:32 <roboshibby> can you just tell me in plain language?
23:21:38 <roboshibby> i dont know haskell
23:21:42 <roboshibby> was considering learning
23:21:45 <dibblego> @google erik meijer channel 9 monad tutorials
23:21:46 <kmc> roboshibby, you really need to study Haskell's type system before you get to monads
23:21:47 <lambdabot> http://channel9.msdn.com/shows/Going+Deep/Expert-to-Expert-Brian-Beckman-and-Erik-Meijer-Inside-the-NET-Reactive-Framework-Rx/
23:21:47 <lambdabot> Title: Expert to Expert: Brian Beckman and Erik Meijer - Inside the .NET Reactive Frame ...
23:21:49 <kmc> this is not an intro topic
23:21:53 <dibblego> not that one
23:21:57 <kmc> nor is it something that's essential to learning the language
23:21:59 <alexyk> oh! thx dibblego
23:22:11 <ski> (kmc : i'd say all those are included in the word "effects" ..)
23:22:36 <alexyk> roboshibby: seriously, you got to read the book.
23:22:40 <roboshibby> i will
23:22:42 <roboshibby> geez
23:22:43 <alexyk> or watch videos.
23:22:51 <medfly> yeah, you have to learn for a degree too
23:22:53 <medfly> don't forget that
23:22:58 <medfly> otherwise you'll suck forever
23:23:10 <kmc> but basically... return "lifts" a value into the monad without giving it any of the monad's special properties.  so in the world of parsers, "return x" produces the value x without parsing anything.  in the world of IO, "return x" produces the value x without doing any IO.  in the world of exceptions, "return x" produces the value x without raising any exceptions
23:23:12 <roboshibby> im not in uni
23:23:19 <alexyk> medfly: not necesserily suck, but not reach the full potential
23:23:59 <roboshibby> ok
23:24:08 <roboshibby> and >>=?
23:24:32 <kmc> (a >>= f) means: do the computation described by a, then pass the resulting value to the function f.  f decides what to do next and returns another computation.  the value of (a >>= f) represents the overall computation of doing all of that.
23:24:45 <ksf> :t (>>=)
23:24:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:24:57 <ksf> the a -> m b part is the most important to grok
23:25:11 <alexyk> dibblego: have to click back from that link to State Monad
23:25:14 <ksf> ...as that's the only way to get a value "out" of a monad
23:25:26 <kmc> ksf, that's only true for some monads
23:25:30 <ski> to execute the monadic action `m >>= f' : first execute the action `m' (call the result value `v') then execute the monadic action `f v'
23:25:31 <dibblego> alexyk, I don't think that's the right link
23:25:33 <kmc> most of them have a monad-specific "run" function
23:25:49 <ksf> ...quotation marks because you're not actually getting the value out of the monad, but lifting a function into it.
23:26:01 <ksf> kmc, well... you're wrong.
23:26:02 <alexyk> dibblego: yeah, but I got this from it: http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/ -- is it what you meant?
23:26:06 <ksf> a monad is a monad is a monad.
23:26:10 <ski> for exceptions, this means that if `m' raises any exception, then `f v' never gets to run
23:26:11 <dibblego> alexyk, no (I think)
23:26:19 <roboshibby> interesting
23:26:19 <kmc> roboshibby, so (>>=) is very roughly like the semicolon in C.  but of course it's an ordinary user-defined function, not special syntax.
23:26:25 <ksf> and stuff that incidentally comes with a run function may give raise to a monad, yes.
23:26:26 <kmc> it's an overloadable operator
23:27:03 <ski> for parsers, `m' will parse some input before generating a value `v', then `f v' will parse some more input, possibly depending on the previously parsed value `v'
23:27:10 <kmc> roboshibby, the high-level view is:  in Haskell, functions are one type, and sequence-of-steps-to-do is another type.  both are first-class values, so e.g. a function can return a sequence of steps.  that's very different from the function actually *performing* the steps
23:27:36 <ski> for backtracking parsers, if `f v' detects an "impossible parse", it will backtrack into `m', to let `m' try parsing in another way
23:27:41 <kmc> this idea of "sequence of steps" as a first-class value is strongest in the IO monad but is part of every monad to some degree -- because (>>=) means that computations are logically ordered, if not actually ordered in time
23:28:12 <kmc> anyway, i can't explain this very well to someone who knows no Haskell.  i suggest you start learning and come to it at the appropriate time -- there's really a lot of more fundamental stuff in the language.
23:28:20 <kmc> monads get a lot of PR because they have a weird name, and they're used for IO
23:28:39 <ksf> and because people that want to bitch about haskell get hung up on them.
23:28:58 <roboshibby> thank you
23:29:01 <kmc> no problem :)
23:29:11 <kmc> if you want to learn Haskell you should definitely hang around here
23:29:20 <kmc> we have a cool bot
23:29:26 <kmc> > fix ((0:) . scanl (+) 1)
23:29:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:29:34 <kmc> ^^^^ infinite list of all fibonacci numbers
23:29:38 <roboshibby> i will, thanks kmc. ive been building an interpreter on my own and came up with the concept of sequence of steps myself
23:29:45 <roboshibby> so i like the thinking
23:29:48 <kmc> cool
23:30:18 <alexyk> monad is just  a tag.  It separates things which can be IO, state, or whatever.  You have to have liftM and forM and mapM and think which one to use instead of plain and simple things like Clojure.  Otherwise its usefulness has to really be painfully made up.  :)
23:30:49 <kmc> alexyk, um okay
23:30:50 * ski wonders what a tag is
23:30:54 <ksf> oh, and monads aren't actually about sequencing.
23:31:09 <ksf> ...applicative functors are, and every monad also happens to be an applicative functor
23:31:13 <ksf> :t (<*>)
23:31:14 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:31:16 <kmc> monads are not merely a way of distinguishing (by types) things which would otherwise be stuffed together
23:31:37 <ski> ksf : they are about adding a logical sequencing, using `(>>=)' (or `join', if you prefer)
23:31:39 <lpsmith> Here's an idea that I had a long time ago, but never really worked on it
23:31:43 <kmc> monads are a way of adding new features
23:32:02 <ksf> the thing that monads add is branching: influencing the next action taken
23:32:02 <alexyk> kmc: RWH says that return is inject, and for me it's just tag.  I think of monads as syntactic constructs which make you jump over the constructor.  Real easy.  The constructor is the barrier.
23:32:04 <kmc> this is why Haskell has exception handling, but "throw" and "try" and "catch" are ordinary functions
23:32:08 <ski> ksf : yes, there are commutative monads, but the basic operations still (neddlessly) expresses this logical sequencing
23:32:31 <lpsmith> Could you "split" the IO monad up into a bunch of different "sub-monads",  like a monad to interact with the keyboard,  another to interact with the filesystem,  etc
23:32:38 <kmc> lpsmith, yes, that's a great idea
23:32:45 <kmc> better you can put each operation in a typeclass
23:32:53 <aavogt> but how to recombine the separate ones?
23:32:57 <lpsmith> And then if you wanted one that did both,  have basically something like (Keyboard + filesystem) a
23:33:09 <aavogt> wouldn't it get awkward to interleave the two styles of effects?
23:33:14 <roboshibby> yes
23:33:17 <kmc> (MonadKb m, MonadFs m) => m a
23:33:24 <aavogt> oh, like that
23:33:38 <kmc> in particular... the natural divisions i see are
23:33:44 <kmc> - safe mutable state
23:33:49 <kmc> - unsafe / FFI
23:33:51 <kmc> - actual IO
23:33:53 <aavogt> yeah, that's good except there should be some sugar for leaving out the long typeclass context
23:33:54 <kmc> - concurrency
23:33:57 <ksf> ooooh.
23:34:06 <kmc> aavogt, yeah, context synonyms
23:34:13 <ksf> I wanted to hack on a ref monad that doesn't use ST
23:34:26 <roboshibby> FFI?
23:34:28 <ksf> ...but I don't think it's going to happen any time soon.
23:34:31 <kmc> foreign function interface
23:34:37 <kmc> the interface for calling C functions from Haskell
23:34:39 <kmc> and by extension most languages
23:34:46 <roboshibby> oh
23:35:06 <kmc> the FFI libraries let you do things like unsafe pointer arithmetic that are not part of "ordinary" haskell code
23:35:07 <ksf> there's some pretty nifty stuff you can do with indexed monads there, the most fun thing being that you get rid of the existential of the ST type.
23:35:07 <aavogt> I don't think you can call other languages any other way (well, other than hacking on the compiler)
23:35:21 <kmc> aavogt, right, i mean that most languages can be reached via C
23:35:27 <kmc> though, IPC is always a viable option
23:36:04 <ksf> we don't have pointer addition, though.
23:36:07 <kmc> every time your Firefox loads a Rails site you are making a C -> Ruby foreign call ;)
23:36:11 <ksf> only addition of a pointer and offset.
23:36:12 <lpsmith> IPC is sometimes the only sane way to do it :)
23:36:15 <kmc> ksf, neither does C, i thought
23:36:19 <ksf> but I guess that's a good thing.
23:36:19 <kmc> pointer + offset = pointer
23:36:22 <kmc> pointer - pointer = offset
23:36:57 <kmc> ksf, but i think you can cast a Word to a (Ptr a) without throwing out the whole system and using unsafeCoerce#
23:36:58 <lpsmith> Especially if you are dealing with two large run-time environments that want to step on each other's toes
23:37:02 <ksf> yep, but void* - void* = void*
23:37:30 <kmc> lpsmith, yup.  i had a lot of fun with a GHC-Haskell to Sun-Java-JVM FFI... it would crash nondeterministically, 50% of the time in GHC's RTS, 50% of the time in the JVM
23:37:45 <ksf> warning: assignment makes pointer from integer without a cast
23:37:49 <lpsmith> yeah, that sounds insane
23:38:00 <lpsmith> definitely time to keep those two in seperate processes
23:38:10 <kmc> yeah
23:38:22 <kmc> also involved some truly awful hacks to get ghc to produce a .so
23:38:25 <kmc> (this was years ago)
23:39:03 <ski> @type Foreign.Ptr.minusPtr
23:39:03 <ski> 
23:39:04 <lambdabot> forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b -> Int
23:39:06 <ski> @type Foreign.Ptr.plusPtr
23:39:08 <lambdabot> forall a b. GHC.Ptr.Ptr a -> Int -> GHC.Ptr.Ptr b
23:39:32 <kmc> :t Foreign.Ptr.intPtrToPtr
23:39:33 <lambdabot> forall a. Foreign.Ptr.IntPtr -> GHC.Ptr.Ptr a
23:39:38 <kmc> :t Foreign.Ptr.intPtrToPtr 0
23:39:39 <lambdabot> forall a. GHC.Ptr.Ptr a
23:39:40 * ski wonders why those don't have `a' and `b' the same type
23:39:42 <swolchok> what's the haskell equivalent to python's unary * operator? (unpack tuple or list and apply function with elements as args)
23:39:59 <kmc> swolchok, none
23:40:05 <kmc> you could not give it a sane static type
23:40:13 <swolchok> fair enough
23:40:13 <aavogt> @type curry
23:40:14 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:40:21 <kmc> curry and uncurry are vaguely relevant
23:40:23 <ski> well, you can do
23:40:35 <kmc> there's also the Printf hack for variadic functions
23:40:39 <ski> > let f(x,y) = x*10 + y; p = (3,4) in f p
23:40:39 <kmc> and there's also Template Haskell
23:40:40 <lambdabot>   34
23:40:40 <swolchok> I want to apply a three-argument function to "take 3 xs"
23:40:52 <swolchok> guess I'll just spell it out with nth
23:40:54 <kmc> swolchok, (\[a,b,c] -> f a b c) (take 3 xs)
23:41:08 <kmc> if xs is less than 3 elements this will be a runtime error
23:41:24 <aavogt> probably best to use   case xs of [a,b,c] -> f a b c; _ -> whatNOW?
23:41:38 <ski> > let [a,b,c] = take 3 [1..] in [c,b,a]
23:41:39 <lambdabot>   [3,2,1]
23:41:53 <aavogt> but perhaps you f could take a list?
23:42:58 <swolchok> actually, the original function should have patterns for x:y:z:xs and _, shouldn't it?
23:43:13 <ski> if it takes a list, then sure
23:43:14 <kmc> swolchok, if you want
23:43:17 <lpsmith> kmc:  it wasn't gcjni was it?
23:43:18 <swolchok> I guess that depends on the original function, which I haven't told you
23:43:24 <kmc> lpsmith, no
23:45:17 <Cale_> <Cale> swolchok: case take 3 xs of [x,y,z] -> ...; _ -> what if there's not enough elements?
23:56:32 <roboshibby> kmc, what's the sequence-of-steps type called?
23:56:43 <kmc> depends on what sort of step precisely
23:56:46 <HaskellLove> I have list [2,2,1] and given that as input to a function i want the function to output [[2,1,1,1], [1,1,1,1,1]] how to do it? basically 2 is expanded to its summers [1,1] It is not that simple, imagine a list like [10,10,5], you will do it recursivly for each element and then get all lists together... euler 31
23:56:49 <roboshibby> oh
23:57:05 <kmc> roboshibby, each monad defines its own notion of steps of computation
23:57:25 <roboshibby> i see
23:57:40 <kmc> here's a concrete example
23:57:42 <kmc> :t getChar
23:57:43 <lambdabot> IO Char
23:57:46 <kmc> getChar has type (IO Char)
23:57:51 <kmc> it's an IO-step which returns a character
23:57:55 <kmc> note that getChar is not a function
23:58:15 <roboshibby> what is getChar?
23:58:18 <kmc> it's an IO action
23:58:18 <roboshibby> if not a func
23:58:28 <kmc> functions have (->) in their types
23:58:29 <roboshibby> what's the difference between a func and an action?
23:58:33 <kmc> :t \x -> x + 3
23:58:34 <lambdabot> forall a. (Num a) => a -> a
23:58:37 <kmc> roboshibby, they are totally different types
23:58:43 <kmc> what's the difference between a bool and a string?
23:58:46 <roboshibby> ah
23:58:51 <kmc> functions have arguments, actions don't
23:58:55 <roboshibby> what's the similarity? :P
23:59:12 <kmc> functions are applied to arguments.  actions are glued onto other actions
23:59:19 <roboshibby> oh
23:59:33 <kmc> note that you can evaluate "getChar" in full and still no IO is performed
23:59:34 <kmc> > getChar
23:59:35 <lambdabot>   <IO Char>
23:59:45 <kmc> evaluation of functions and values does not have side effects
23:59:50 <aavogt> kmc: is (Maybe a) also an action for you?
23:59:59 <kmc> side effects come by *executing* an action, not by evaluating it
