00:01:57 <dblhelix> kosmikus: tnx
00:02:09 <povman> > ((+) `on` length) "abc" "defg"
00:02:10 <lambdabot>   7
00:03:20 <Mark1> does anyone know why so many of the hoogle results return 404's?
00:03:42 <copumpkin> Mark1: because they moved all the docs recently
00:03:46 <copumpkin> not sure why
00:03:53 <Cale> Mark1: If they're documentation links, the GHC web documentation got messed up by the upgrade to 6.12
00:04:37 <Cale> Haddock has this default behaviour of putting package documentation in version-numbered directories, but they'd worked around that in the previous couple releases of GHC
00:04:43 <Cale> I'm not sure what happened this time
00:04:54 <Mark1> ah, ok.
00:06:35 <Mark1> i'm surprised that hoogle doesn't automatically re-index after an upgrade
00:07:57 <copumpkin> they don't happen often enough for it to be a terribly pressing feature
00:09:05 <Mark1> i see. that makes sense, then.
00:11:42 <lpsmith> one thing that's obnoxious though,  is that haddock executables are tied to ghc versions,  but the haddock executables aren't versioned
00:12:11 <lpsmith> Makes it a pain to manage user documentation without writing a script to do it yourself
00:13:37 <lpsmith> I've come up with a lazier version of powerfoldr:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5562
00:16:51 <lpsmith> > powerfoldr (:) [] [1..]
00:16:52 <lambdabot>   * Exception: stack overflow
00:17:12 <lpsmith> @let powerfoldr f b = fold where { fold [] = [b] ; fold (a:as) = interleave' (map (f a) bs) bs where bs = fold as }
00:17:12 <copumpkin> nice
00:17:13 <lambdabot>  <local>:3:0:
00:17:13 <lambdabot>      Warning: Pattern match(es) are overlapped
00:17:13 <lambdabot>               In...
00:17:27 <mmorrow> @tell dons http://moonpatio.com/repos/wow.txt
00:17:27 <lambdabot> Consider it noted.
00:17:34 <lpsmith> @let powerfoldr' f b = fold where { fold [] = [b] ; fold (a:as) = interleave' (map (f a) bs) bs where bs = fold as }
00:17:38 <mmorrow>  @tell #haskell http://moonpatio.com/repos/wow.txt
00:17:40 <mmorrow> :)
00:17:43 <lpsmith> > powerfoldr' (:) [] [1..]
00:17:45 <mmorrow> well, :( for that..
00:17:49 <lambdabot>  Defined.
00:17:51 <lambdabot>   * Exception: stack overflow
00:17:55 <PepeSilvia> hi, is it possible to have something like lambdabot's :src command in ghci?
00:18:19 <lpsmith> hmm
00:18:22 <mmorrow> PepeSilvia: lambdabot just uses a txt file for the few functions it has in there
00:18:51 <mmorrow> PepeSilvia: would you want /arbitrary/ function defs, or just Prelude/stdlib ones?
00:18:59 <PepeSilvia> ah ok, that's too bad. The :list command only seems to work on interpreted modules
00:19:30 <PepeSilvia> mmorrow: just to make it easier to look up the standard functions/packages.
00:19:48 <mmorrow> PepeSilvia: if the former, i guess you'd need to write a prog that uses haskell-src-exts or something to parse modules, then maybe store the defs in an sqlite db or something (this would be a killer app btw..)
00:20:35 <mmorrow> PepeSilvia: ah, if you're just looking to have Prelude/Data.List, that wouldn't be too hard to hack something together by hand
00:21:16 <mmorrow> stuff.txt + quicky script + :def a ghci cmd
00:21:36 <PepeSilvia> mmorrow: ok, thanks for the pointers.
00:21:41 <mmorrow> np
00:22:08 <mistermattaway> um, could someone point me to Haskell's indenting rules?
00:22:44 <napping> it's in the standard
00:23:30 <napping> http://haskell.org/onlinereport/syntax-iso.html#layout
00:24:09 <lpsmith> intuition fail... oh well,  lazier powerfoldr is easily fixed...
00:24:42 <Gracenotes> at least the indentation rules don't introduce any bad situations. just remove arguably good ones.
00:25:19 <Gracenotes> (well, besides the requirement that things line up when they should.. that's rather necessary, I'd argue)
00:25:55 <mistermattaway> everything looks lined up, but I'm still getting a parse error
00:26:45 <napping> you could try explicit grouping
00:27:20 <PepeSilvia> in Data.Maybe: it starts with defining a fold for Maybe (maybe), but then it never uses it in the other definitions. Why is that?
00:27:29 <PepeSilvia> @src fromMaybe
00:27:30 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
00:27:32 <PepeSilvia> why not:
00:27:39 <PepeSilvia> @let fromMaybe2 = flip maybe id
00:27:40 <lambdabot>  Defined.
00:27:50 <PepeSilvia> > fromMaybe2 3 (Just 6)
00:27:51 <lambdabot>   6
00:27:54 <PepeSilvia> > fromMaybe2 3 Nothing
00:27:55 <lambdabot>   3
00:28:52 <mistermattaway> I think notepad++ is breaking my indenting somehow
00:29:16 <lpsmith> @undefine powerfoldr'
00:29:46 <lpsmith> @let powerfoldr' f b = fold where { fold [] = [b] ; fold (a:as) = interleave' (map (f a) (b:bs)) (b:bs) where ~(b:bs) = fold as }
00:29:46 <lambdabot>  <local>:1:61: Not in scope: `interleave''
00:30:50 <lpsmith> @let interleave = loop where { loop [] ys = ys ; loop (x:xs) ys = x : loop ys xs }
00:30:51 <lambdabot>  Defined.
00:30:56 <lpsmith> @let powerfoldr' f b = fold where { fold [] = [b] ; fold (a:as) = interleave (map (f a) (b:bs)) (b:bs) where ~(b:bs) = fold as }
00:30:57 <lambdabot>  <local>:2:61:
00:30:57 <lambdabot>      Ambiguous occurrence `interleave'
00:30:57 <lambdabot>      It could refer to ...
00:31:10 <lpsmith> @undefine interleave
00:31:18 <lpsmith> @let powerfoldr' f b = fold where { fold [] = [b] ; fold (a:as) = interleave (map (f a) (b:bs)) (b:bs) where ~(b:bs) = fold as }
00:31:19 <lambdabot>  Defined.
00:32:02 <lpsmith> > take 4 $ map (take 4) $ powerfoldr' (:) [] [1..]
00:32:03 <lambdabot>   [[1,2,3,4],[2,3,4,5],[1,3,4,5],[3,4,5,6]]
00:32:06 <lpsmith> :)
00:34:01 <chrisdone> nice
00:44:25 <lpsmith> I could write up a blog post about how this disproves Cantor's diagonalization :-P
00:44:35 <lpsmith> and submit it to /r/math
00:45:17 <copumpkin> lol
01:25:02 <sinelaw> PeakerWork, ?
01:25:03 <lambdabot> sinelaw: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:25:46 <sinelaw> preflex, seen ivnam
01:25:46 <preflex>  Sorry, I haven't seen ivnam
01:25:49 <sinelaw> preflex, seen ivanm
01:25:50 <preflex>  ivanm was last seen on #haskell 3 hours and 18 seconds ago, saying: drhodes: I hope you're not serious...
01:32:34 <ivanm> hey sinelaw
01:33:06 <sinelaw> ivanm, hi just saw your messages, i'm gonna try it now.
01:33:16 <ivanm> good-o
01:50:18 <|Jedai|> Did someone follow the "performance of parallel mergesort" thread that Jon Harrop started on Haskell-beginner ?
01:50:33 <ivanm> nope
01:50:43 <ivanm> so he's even trolling there on the beginners thread?
01:50:52 <|Jedai|> This troll had the gall to start this thread in Haskell-Beginner (his intention couldn't be more obvious)
01:50:55 <ivanm> has that man^h^h^h toad no shame?
01:51:02 <|Jedai|> No, visibly not
01:51:35 <|Jedai|> So he took a very bad translation of a parallel mergesort and tried to compile it with ghc6.8
01:51:44 <ivanm> *groan*
01:51:52 <|Jedai|> And get regression with -Nn n>=2...
01:51:59 <|Jedai|> surprising isn't it ?
01:52:58 <Heffalump> he's not exactly a Haskell beginner, more like a Haskell fuckwit
01:53:18 <|Jedai|> Then install ghc6.10 without cleaning the compiled .hi and ghc crash (it does that when it tries to compile with an older version-created .hi, it's admittedly a bug but not exactly a complicated one to fix)
01:53:43 <ivanm> @remember Heffalump he's [Jon Harrop] not exactly a Haskell beginner, more like a Haskell fuckwit
01:53:43 <lambdabot> Nice!
01:54:04 <merehap> wow, he usually tries to make it a subtle attempt, but I guess he's digressed further this time...
01:54:27 <|Jedai|> Then he trolled on installing GHC 6.12 and how there was a "circular dependancy" because obviously its ghc6.10 "couldn't compile anything" (so he only tested it on one thing apparently)
01:55:00 <|Jedai|> and of course he _had to_ compile it from source, not like he could use a binary package, no...
01:55:12 <merehap> no lambdabot, not nice, regrettable
01:56:19 <|Jedai|> To put it nicely he managed to put almost every single trolls on GHC he could in one conversation and he did it on Haskell-Beginner... I would say this border on impoliteness, no ?
01:56:23 <dolio> He's pretty pathetic.
01:56:34 <ivanm> yup
01:56:39 <ivanm> is there a moderator on beginner?
01:56:44 <merehap> a real cool guy if you ask my opinion
01:56:58 <ivanm> merehap: I hope that was sarcasm... >_>
01:57:08 <merehap> indeed, it was :)
01:57:17 <ivanm> you're lucky then!
01:58:21 <merehap> I've seen enough of jdh's vendetta to know better
02:00:10 <ray> what is it with people and misusing the word troll
02:00:24 <ray> i don't have anything against language evolving in itself, but that word has become "someone i don't like"
02:00:26 <merehap> there are times when I'm tempted to troll F# forums, but I just can't find the energy that Harrup has
02:00:34 <ivanm> @hoogle Seq a -> [a]
02:00:35 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
02:00:35 <lambdabot> Prelude repeat :: a -> [a]
02:00:35 <lambdabot> Data.List repeat :: a -> [a]
02:00:37 <ray> he runs a f# consultancy, he has money in this
02:01:12 <merehap> I think that still fits the definition of troll
02:01:12 <ray> pissing off haskellers is not his aim, it is a side-effect
02:01:13 <sinelaw> Did anyone here manage to get antialiasing working via the haskell opengl bindings?
02:01:25 <sinelaw> (i'm doing 2d lines)
02:01:36 <merehap> I don't see anyone from the Scala comunity bashing Haskell...
02:01:47 <hiredman> ray: maybe there is some kind of monad for that
02:02:05 <merehap> likewise I don't see anyone from the Haskell community going out of their way to bash another programming language community
02:02:33 <merehap> troll is very appropriate for harrup, I'd say
02:02:37 <ray> a monad that allows you to perform computations and conveniently manages the people you piss off along the way
02:02:57 <merehap> as a side-effect, of course :)
02:03:01 <ray> no, "guy who is willing to do unsavory things for financial gain" fits him
02:03:18 <ray> maybe a money-seeker with trollish tendencies
02:03:28 <ray> if you use it as an adjective i guess it's ok
02:03:36 <merehap> ok, I'll go with that description
02:03:59 <ray> hiredman: i think that is the public relations monad
02:04:00 <luite> hm, he is that F# guy right?
02:04:09 <dolio> What I don't understand is how it works.
02:04:14 <dolio> But I guess it must.
02:04:18 <ray> yeah he has some jumping frog f# consultancy
02:05:54 <ray> presumably he sees haskell as f#'s biggest competitor and wants to hurt its reputation
02:05:59 <ray> it doesn't have to work to make sense
02:09:09 <dolio> I guess. But I think that repeatedly making a fool of yourself posting dishonest benchmarks would be bad for business.
02:09:33 <Heffalump> well, since I now mainly work with F#, it's certainly at least potentially cost him business from me
02:10:08 <|Jedai|> luite: And he was that OCaml guy once, and he almost was that Haskell guy at a time... JdH will get on a bandwagon for a time and trash all others bandwagons including some he had been on in the past
02:10:13 <dolio> Unless the people who see the benchmarks aren't the ones who'd employ him, in which case, how are they damaging Haskell's credibility with the relevant people?
02:11:00 <blackh> This Jon Harrop business is totally surreal.
02:11:36 <merehap> blackh: how so? dons mentioned the same thing, though I didn't know what he was talking about..
02:11:45 <|Jedai|> ray: I don't know if he really does that for financial gain, I tend to think there should be some better things to do for him that would obviously make him more money than trashing other languages on forums his client are unlikely to be following
02:11:45 <ivanm> |Jedai|: IIRC, he also trashed academia...
02:11:52 <merehap> I assume you are talking about his business
02:11:52 <ivanm> (in general that is)
02:12:02 <ivanm> wasn't he the one that said you should only go to uni to find a partner?
02:12:07 <ivanm> (as in relationship wise)
02:13:08 <|Jedai|> After following some of his intervention on a lot of forums for years I tend to think he just get a kick out of being an asshole
02:16:04 <|Jedai|> which is why I qualify him as "troll", I don't think I ever used that term on anyone else to be honest since I tend to stay away from the communities where they're rumoured to be more common... He's the only one in the FP community I ever definitely classified as such
02:16:44 <|Jedai|> But to be doing it on Haskell-Beginner... That's a new low even for him
02:17:58 <QtPlaty[HireMe]> He is not a troll as a troll doesn't beleave there BS
02:18:32 <Heffalump> it's hard to tell if he does believe it or not. He certainly posts it for effect.
02:19:10 <merehap> yeah, how can you tell either way if he has a financial incentive in it?
02:19:26 <QtPlaty[HireMe]> I would classify him as a mission poster.
02:19:58 <QtPlaty[HireMe]> Like a religious nut or  RMS
02:20:07 <merehap> ha
02:21:02 <blackh> Well, it's an interesting question to ask, "Can you mutate different parts of the same array in parallel in Haskell".  Perhaps the answer to this question is: That can't be done safely, so the IO level is an appropriate level to do it at.
02:21:15 <ivanm> I wouldn't; I doubt he truly believes fervently in it, just that he's protecting his business
02:21:27 <ivanm> blackh: right, that was dons' point with his newish judy bindings
02:21:40 <ivanm> you give up your safety for _speed_
02:22:38 <blackh> Well, that's the Haskell way!  If you must do something unsafe, do it, but put lead shielding around it.
02:22:41 <alp_> haha
02:22:51 <alp_> you're discussing Harrop's blog post :D
02:22:58 <ivanm> alp_: nope
02:23:09 <ivanm> oh, his anti-uni one? yeah, in passing
02:23:15 <alp_> :-p
02:23:18 <ivanm> we started off talking about his trolling on haskell-beginners
02:24:36 <Accidus> Harrop's anti uni post?
02:25:31 <ivanm> as part of his post, he said the only reason you should go to uni is to find yourself a {girl,boy}friend
02:25:39 <ivanm> since you don't actually learn anything of value at uni
02:26:07 <alp_> that is stupid, yeah.
02:26:13 * Accidus lols.
02:26:26 <Accidus> Has he been to Uni.?
02:27:15 <ivanm> yes
02:27:22 <ivanm> IIRC, he claims to have worked at one for a while
02:27:27 <Accidus> Did he find himself a {girl,boy}friend?
02:27:30 <ivanm> but I could be getting him mixed up with wolfram
02:56:46 <kiuma> hello
02:58:15 <Axman6> g'day kiuma
02:58:38 * ivanm waves idly in kiuma's general direction
02:58:51 <kiuma> :)
02:59:18 <kiuma> I was wonodering if haskell could be my next 2010 language :)
03:00:07 <kiuma> I hear a lot of people saying that haskel is cool
03:00:10 <Axman6> it sure could be
03:00:19 <Axman6> it's more than cool
03:00:41 <kiuma> is there a good manual to buy out there ?
03:00:53 <Axman6> @where lyah
03:00:54 <lambdabot> http://www.learnyouahaskell.com/
03:01:00 <Axman6> good place to start ^^^^
03:01:09 <Axman6> then, after that:
03:01:13 <Axman6> @where rwh
03:01:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:01:43 <Axman6> an O'Reilly book, that's available online for free (the actual book is several hundred pages long)
03:01:48 <Peaker> kiuma: BONUS's http://www.learnyouahaskell.com/ is really great
03:02:10 <Peaker> (I've given it to my coworkers, and they loved it too)
03:03:38 <ivanm> or else for tutorial books, see Craft of functional programming, Haskell School of Expression, etc.
03:03:59 <ivanm> Peaker: "given it"? you mean he did get it published (even though it isn't finished)?
03:04:15 <Peaker> ivanm: no no, I mean, sent them there
03:04:29 <ivanm> ahhhh
03:05:18 <kiuma> Is there a java implementation integration too ?
03:05:41 <Axman6> no
03:05:45 <Axman6> thankfully
03:05:47 <ivanm> you mean running on the JVM?
03:05:51 <ivanm> Axman6: agreed!
03:05:57 <ivanm> native FTW!
03:06:38 <Axman6> kiuma: haskell, using ghc (the main haskell compiler) is compiled to (fast) native machine code
03:07:18 <kiuma> like CL more or less ?
03:07:36 <Axman6> CL is compiled?
03:07:40 <kiuma> sure
03:08:03 <kiuma> well depends by the cl machine
03:08:14 <kiuma> in the most of the cases yes
03:08:18 <Peaker> kiuma: I think ghc's compiled binaries would outperform CL compiled code, because GHC has more input to optimize with
03:08:43 <kiuma> nice to hear :)
03:09:02 <Axman6> haskell can be damn fast (beating C if you're doing the right things)
03:09:14 <kiuma> Peaker, so it is virtually faster then C ?
03:09:17 <Axman6> while still being very high level, and much safer
03:10:25 <kiuma> what about the outside world ? I mean DB, SOAP web services  & c. ?
03:10:42 <ivanm> sure, why not
03:10:51 <ivanm> (depending on someone having written a SOAP library...)
03:11:03 <kiuma> yes I know that :)
03:11:07 <Axman6> sure, we've got some very nice DB libraries, no idea about SOAP, but i'd say there's almost certainly a few libraries for it, and haskell has a great FFI
03:11:24 <kiuma> good
03:11:27 <Axman6> writing your own SOAP library probably wouldn't be too hard
03:11:29 <Peaker> kiuma: Well, C lets you get pretty good control of the exact assembly generated -- as such, the super-best-program possible, is possible to represent in C, but not in many other languages (except in special cases). However, that's misrepresenting real-world C, because figuring out the most super-optimal program is hard, and code that is super-optimal will sacrifice other important software aspects
03:11:32 <ivanm> a lot of people have said that Haskell has the best FFI around
03:12:16 <yitz> Axman6: SOAP, though conceptually easy, is one of those big hairy enterprise things with zillions of corner cases.
03:12:25 <Axman6> Peaker: mind you, there's also libraries for creating assembly in haskell too aren't there?
03:12:43 <romildo> Hi.
03:12:55 <Axman6> yitz: yeah, i read that thing on reddit recently, about the S in SOAP being for Simple...
03:13:01 <Peaker> Axman6: well, in C, you can represent the assembly you want with C (and perhaps hint the compiler at what optimizations you want).  inline assembly is cheating and using a different language :)
03:13:16 <kiuma> yitz, yes, this was my question about java integration
03:13:20 <Peaker> kiuma: I'd say that naive/elegant Haskell is significantly slower than naive/elegant C, but that fast/optimized Haskell is similar to fast/optimized C for most purposes, and that on multi-core, real world Haskell can beat real world C
03:13:33 <Axman6> i thought there was at least one EDSL for creating x86 assembly in haskell?
03:13:51 <copumpkin> Peaker: things like DPH and uvector make naive/elegant haskell pretty and superfast too
03:13:54 <copumpkin> but it's fragile
03:13:59 <yitz> Axman6: that's why most people use REST instead nowadays, unless forced to use SOAP. So I'm not sure if anyone has spent the time to write a complete SOAP implementation in Haskell yet.
03:14:07 <romildo> After installing gtk2hs-darcs with dcouts patch to enable compiling with ghc-6.12.1 (from the gtk2hs-devel mailing list) applied, I am getting linking errors when compiling demo/hello/World.hs:
03:14:09 <Peaker> copumpkin: I wouldn't say even the use of uvector is naive Haskell, though maybe it is elegant
03:14:12 <romildo> $ ghc --make /var/tmp/gtk2hs/demo/hello/World.hs -o helloworld
03:14:12 <romildo> [1 of 1] Compiling Main             ( /var/tmp/gtk2hs/demo/hello/World.hs, /var/tmp/gtk2hs/demo/hello/World.o )
03:14:12 <romildo> Linking helloworld ...
03:14:12 <romildo> /var/tmp/gtk2hs/demo/hello/World.o: In function `r2Tf_info':
03:14:12 <romildo> (.text+0x67): undefined reference to `gtkzm0zi10zi1_GraphicsziUIziGtkziTypes_zdfButtonClassButton_closure'
03:14:15 <romildo> Any clues?
03:14:19 <Axman6> yitz: that was the conclusion of this piece too :)
03:14:21 <ivanm> Axman6: yeah, sounds familiar
03:14:28 <Axman6> romildo: don't do that!
03:14:30 <ivanm> harpy IIRC
03:14:37 <Axman6> harpy, that's the one
03:14:38 <copumpkin> Peaker: well, its API is designed to look just like []'s api, but I guess you're right :)
03:14:46 <luite> ivanm: the ffi is good, but it still has some annoying limitations. you can't use any C++ library from ghci for example
03:15:18 <ivanm> doesn't bother me ;-)
03:15:23 <Axman6> luite: i thought that was a feature >_>
03:15:31 <romildo> Axman6, sorry. I will not do that again.
03:15:43 <Peaker> copumpkin: btw: I think solving the problem of having both optimizations and not being fragile -- would best be done with an interactive code editor that informs you what the changes you're doing do to the possible optimizations
03:16:05 <Peaker> copumpkin: hopefully visualizing the code transformations done by optimizations, as Core->Core function visualizations
03:16:17 <copumpkin> Peaker: yeah, I was hoping to write a GHC plugin (but plugins isn't done yet) that interactively showed how rewrite rules affected your code
03:16:26 <yitz> kiuma: yeah, there have been several efforts to create Java VM bridges for Haskell. Some went along pretty far, got to something usable even. But it's a huge amount of work to make it complete and keep it up-to-date, and I don't think there's been enough demand for that yet.
03:16:37 <luite> Axman6: I don't particularly like C++, but it's rather annoying that you cannot use ghci anymore once you need to call some C++ library
03:16:40 <copumpkin> Peaker: but as it stands, GHC doesn't output enough information to determine what was actually done between simplifier steps
03:16:42 <copumpkin> :(
03:17:11 <yitz> even with a C wrapper?
03:17:23 <luite> yitz: yes, the problem is in the ghci dynamic linker
03:17:34 <copumpkin> luite: wow, really? that seems odd
03:17:36 <luite> it cannot handle the 'strange' c++ object files
03:17:45 <copumpkin> oh, for linking to .o files
03:17:49 <luite> which have sections for global constructors and that kind of things
03:18:18 <luite> even if all functions are 'extern "C"'
03:18:20 <kiuma> yitz, anyway I know that SOAP is something like evil, but it's the easiest way to make two application written with different languages to communicate each other
03:18:39 <Axman6> what about REST?
03:18:43 <yitz> kiuma: no it's not. unless one of those two is already using SOP.
03:18:45 <luite> copumpkin: do you know a workaround? I'd really like to be able to make this work
03:18:46 <yitz> SOAP
03:18:50 <copumpkin> luite: I imagine that would be a pretty straightforward fix, if you just want to deal with those files (not necessarily do the right thinking when linking)
03:18:55 <kiuma> rest is not a standard
03:19:11 <kiuma> and out there there are to scarce coders
03:19:11 <copumpkin> kiuma: zomg, what ever shall we do!
03:19:25 <luite> copumpkin: I've been looking at the ghci linker source code, and it's not particularly pretty :p
03:19:31 <copumpkin> luite: I imagine :)
03:19:36 <kiuma> nothing, just pondering :)
03:19:37 <yitz> kiuma: right, it's a simple principle that makes it easy for two applications to talk to each other without the burden of a "standard".
03:19:37 <copumpkin> luite: is there a bug filed for it?
03:20:19 <luite> not sure, but it seems to be a well-known limitation. there are package on hackage that haven an option to build a more limited c++-less version just for this
03:20:43 <kiuma> good, time to study now :)
03:22:09 <Peaker> copumpkin: I think maybe an interactive code editor would have to have a lot of the compiler code in it (e.g: I'd move type inference to the editing stage)
03:22:30 <Peaker> copumpkin: (And have editing edit the ASG directly, etc)
03:22:38 <copumpkin> Peaker: oh yeah, I wasn't thinking of something that ambitious (although I imagine your goal could be achieved with the GHC api and/or a tool like scion)
03:27:00 <kiuma> how about this book "Real World Haskell" ?
03:27:14 <kiuma> is there something better ?
03:27:49 <luite> depends on what you need to learn. for beginners, lyah may be better/easier
03:28:10 <luite> @where lyah
03:28:10 <lambdabot> http://www.learnyouahaskell.com/
03:28:19 <kiuma> ps.: this year I gave a look at groovy: a complete delusion. Clojure was a nice experience
03:29:03 <kiuma> luite, sure but I'm a quick (old) student :)
03:29:09 <vy> kiuma: dilusion?
03:29:19 <kiuma> vy, delusion
03:29:41 <vy> I really wonder the details...
03:29:42 <kiuma> let me check the dictionary :)
03:30:52 <kiuma> vy, (yes delusion :) )
03:31:28 <kiuma> vy groovy does add only some syntactic sugar to java
03:31:31 <mistermattaway> Why does this code fail when I enter "aab"? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14934#a14934
03:31:54 <kiuma> vy, while clojure is another story :)
03:32:29 <ivanm> mistermattaway: first of all, the null xs line is superfluous
03:32:33 <mistermattaway> I get an exception, 'non exhaustive pattern'
03:32:42 <vy> mistermattaway: lines 2 and 4 are identical, btw.
03:32:46 <ivanm> mistermattaway: you need an | otherwise = False there
03:32:56 <ivanm> and I would say that "" is a palindrome ...
03:33:13 <ivanm> so I would just have: checkPalindrom xs = reverse xs == xs
03:33:20 <ivanm> though there are more efficient ways of doing it
03:33:26 <mistermattaway> Oh, I forgot the Otherwise
03:33:45 <mistermattaway> ivan, yeah that would be better
03:33:53 <mistermattaway> I wanted to use the guards
03:34:12 <mistermattaway> what is a more efficient way of doing it?
03:34:33 <yitz> @wn delusion
03:34:35 <lambdabot> *** "delusion" wn "WordNet (r) 2.0"
03:34:35 <lambdabot> delusion
03:34:35 <lambdabot>      n 1: (psychology) an erroneous belief that is held in the face of
03:34:35 <lambdabot>           evidence to the contrary [syn: {psychotic belief}]
03:34:35 <lambdabot>      2: a mistaken or unfounded opinion or idea; "he has delusions
03:34:37 <lambdabot> [4 @more lines]
03:35:03 <ivanm> mistermattaway: walk your way through the list by hand rather than using reverse
03:35:16 <ivanm> the only tricky bit is what to do with odd-length lists
03:35:22 <ivanm> @google haskell palindrome
03:35:24 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/Haskell_craft/palindrome.html
03:35:24 <lambdabot> Title: Problem solving: recognising palindromes
03:35:33 * hackagebot upload: roman-numerals 0.1.0.1 - Parsing and pretty printing of Roman numerals (RoelVanDijk)
03:35:45 <mistermattaway> I was going to write that version after i did the one with reverse, this one is for the real world haskell problem set in chapter 3
03:36:09 <ivanm> that's a bad example...
03:36:16 <ivanm> ahhh, fair enough
03:36:22 <ivanm> @pl \ xs -> reverse xs == xs
03:36:22 <lambdabot> (==) =<< reverse
03:36:29 <ivanm> ooohhh...
03:36:37 <ivanm> @type (==) =<< reverse
03:36:38 <lambdabot> forall a. (Eq a) => [a] -> Bool
03:36:49 <ivanm> would that be the function monad?
03:37:10 * kiuma has to feed his daughter , l8r
03:37:19 <Peaker> ivanm: ya
03:38:24 <Peaker> (==) =<< reverse -- take the result of reverse, and give it to (==).  both of these are given the same argument
03:39:20 <skorpan> of course, it all gets clearer if you write it as reverse >>= (==)
03:40:15 <Peaker> f =<< x  =  join (fmap f x) ;  (==) =<< reverse  =  join (fmap (==) reverse)  =  join ((==) . reverse)
03:41:11 <ivanm> skorpan: heh
03:41:15 <Beelsebob> skorpan: I don't think that's clearer at all, no
03:41:24 <Beelsebob> skorpan: most of our functional programs go right to left
03:41:24 <ivanm> @src (->a) (=<<)
03:41:24 <lambdabot> Source not found. There are some things that I just don't know.
03:41:36 <Peaker> ivanm: the type makes only one thing possible :)
03:41:39 <Beelsebob> @src (=<<)
03:41:39 <lambdabot> f =<< x = x >>= f
03:41:45 <vy> mistermattaway: palindrome cs = (take n cs) == (take n (reverse cs)) where n = (length cs) `div` 2
03:41:48 <ivanm> Beelsebob: yeah, it's a bit weird that monadic code doesn't
03:41:48 <Beelsebob> @src (-> a) (>>=)
03:41:49 <lambdabot> Source not found. Sorry.
03:41:52 <Peaker> (>>=) :: m a -> (a -> m b) -> m b
03:41:54 <zygoloid> @src (->) r  (>>=)
03:41:54 <lambdabot> Source not found.
03:42:03 <ivanm> Peaker: it's the fact that the same argument is supplied that makes it weird (to me at least)
03:42:04 <Peaker> (>>=) :: (r->a) -> (a -> r -> b) -> r -> b
03:42:07 <Beelsebob> ivanm: I use (=<<) and (<=<) for most of my monadic code
03:42:12 <Peaker> @djinn (r->a) -> (a -> r -> b) -> r -> b
03:42:12 <lambdabot> f a b c = b (a c) c
03:42:16 <Beelsebob> it's rare that do-notation looks better
03:42:17 <ivanm> oh, wait, that's how the function monad works, isn't it? supply the same argument to everything?
03:42:27 <ivanm> Beelsebob: fair enough
03:42:30 <zygoloid> (f >>= g) r = g (f r) r
03:42:30 <ivanm> @type (<=<)
03:42:31 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:42:46 <ivanm> is that the equivalent of (.) ?
03:42:46 <Peaker> ivanm: since the type of join in (r->) monad is:  (r -> r -> a) -> r -> a   -- it has to duplicate the argument
03:42:50 <Beelsebob> ivanm: yep
03:43:12 <Peaker> @djinn  (b -> r -> c) -> (a -> r -> b) -> a -> r -> c
03:43:12 <lambdabot> f a b c d = a (b c d) d
03:43:25 <Peaker> @djinn (.)
03:43:25 <lambdabot> Cannot parse command
03:43:29 <Peaker> oops
03:43:36 <zygoloid> @@ @djinn @type (.)
03:43:37 <lambdabot>  Cannot parse command
03:43:41 <Peaker> @djinn (b -> c) -> (a -> b) -> (a -> c)
03:43:41 <lambdabot> f a b c = a (b c)
03:43:47 <Beelsebob> @. djinn type (.)
03:43:47 <Peaker> its not exactly (.)
03:43:48 <lambdabot> Cannot parse command
03:44:14 <Beelsebob> Peaker: looks like (.) to me
03:44:19 <zygoloid> Peaker: it's (.) for the category of kleisli arrows
03:44:21 <Beelsebob> @src (.)
03:44:21 <lambdabot> (f . g) x = f (g x)
03:44:34 <Peaker> Beelsebob: there's the duplicated "d"
03:44:49 <Beelsebob> Peaker: oh wait, I see what you're saying now
03:45:03 <Beelsebob> yeh, as zygoloid said – it's kleisli composition
03:45:05 <Beelsebob> not composition
03:45:29 <Axman6> hooray, bencoded parser written using cereal finished!
03:45:57 <mistermattaway> I have to sayy probably 100% of the time I never have any idea what you guys are talking about
03:46:03 <ivanm> mistermattaway: heh
03:46:04 <Peaker> ivanm: the (r ->) monad, like all monads, needs to be able to take two (r ->) and yield one -- the only way to do this is take an argument and duplicate it..
03:46:10 <ivanm> don't worry, most of us felt that way when we started
03:46:18 <ivanm> I think I get about 75-85% of it nowadays
03:46:30 <mux> merry christmas haskellers
03:46:34 <ivanm> Peaker: you mean join for the (r ->) monad?
03:46:38 <Peaker> ivanm: yeah
03:46:41 <Beelsebob> merry unchristmas mux
03:46:42 <Axman6> mistermattaway: been here two years now, i only get about 20% of it :P
03:46:46 <mistermattaway> I'm hoping I can get through this book enough to use haskell in my upcoming algorithms class
03:46:48 <Peaker> ivanm: though (>>=) also does that, after an fmap
03:46:53 <ivanm> mux: technically, there's still at least 15 minutes until anywhere is the 25 December ;-)
03:46:59 <ivanm> oh, wait, stupid daylight saving time...
03:47:04 <ivanm> so NZ might have it already... >_>
03:47:07 <yitz> ivanm: why do you think that stepping through the list manually is a faster way of recognizing palindromes?
03:47:16 <ivanm> Axman6: :o
03:47:20 <Beelsebob> ivanm: there are places 13 hours ahead of GMT?
03:47:21 <mux> well, it's still the 24th here but I won't be here anymore on the 25th :-)
03:47:22 <mistermattaway> function call overhead?
03:47:27 <Beelsebob> because it's 11:47 GMT atm
03:47:30 <Axman6> Beelsebob: i believe so
03:47:38 <Beelsebob> random
03:47:41 <Peaker> ivanm: that's why its the "reader" monad, because when you compose "actions" in the reader monad into one big "action" -- you have just one (r->) arg, and lots of little actions within it that have (r->) each, so it has to duplicate them without any change, hence "read-only"
03:47:51 <mux> going to unbox my lambda presents
03:47:56 <Beelsebob> lol
03:48:02 <mistermattaway> personally, I'd trust a library function more than anythign I could write
03:48:04 <ivanm> yitz: *shrug* reverse is about 2*n, then equality is another n; I _think_ I've seen one that only needs 2*n all up
03:48:07 <ivanm> I could be completely wrong
03:48:13 <Peaker> ivanm: There's nowhere to get another "r" from except from the argument (unlike State, for example, where you also have the results of previous actions)
03:48:16 <ivanm> Beelsebob: daylight saving adds an hour...
03:48:41 <Axman6> mistermattaway: you in NZ?
03:48:42 <Beelsebob> ivanm: oh, duh, southern hemisphere has daylight savings atm
03:48:44 <Beelsebob> or does it?
03:48:45 <Axman6> uh, mux, not mistermattaway
03:48:48 <ivanm> Beelsebob: some parts
03:48:54 <mux> Axman6: .fr
03:48:56 <Axman6> Beelsebob: my part of it does
03:48:59 <ivanm> yay for queensland so far not giving in to the DST fascists! :p
03:49:00 <Axman6> ah, heh
03:49:18 <ivanm> don't think we have many kiwis here...
03:49:21 <Axman6> yay for it still being light at 8:30 PM
03:49:30 <Beelsebob> well, looks like we'll have a white christmas
03:49:31 <Axman6> blackh is one
03:49:32 <Beelsebob> so :P
03:49:51 <Axman6> sucks for you :)
03:49:55 <ivanm> Axman6: yeah, daylight saving makes more sense in southern states/territories; even with daylight saving it'd be darkish around 7:30 here
03:50:05 <yitz> ivanm: I don't believe you'll do better than reverse <*> (==)
03:50:11 <blackh> Hello! I am one.
03:50:13 <ivanm> Beelsebob: I have never seen snow IRL, and am proud of it
03:50:18 <mistermattaway> ivan, I just found a reverse online that kind of blew my mind a little: reverse (x:xs) = reverse xs ++ [x]
03:50:21 <Axman6> o/ blackh
03:50:24 <Beelsebob> that is a pretty impressive feat ivanm
03:50:27 <ivanm> blackh: so is it now 25 december for you, or not for another 10 minutes?
03:50:42 <ivanm> I'll probably be seeing some in January though :s
03:50:48 <blackh> ivanm: That's old news - it's been 25 december for 50 whole minutes already
03:50:49 <ivanm> unless europe gets a southern heat wave... >_>
03:50:55 <Axman6> ivanm: heading up to thredbo?
03:50:59 <Axman6> ah, heh
03:51:00 <mistermattaway> axman, I'm actually in the midwestern US, my sleep schedule is sort of :( at the moment
03:51:08 <Axman6> mistermattaway: mine too :)
03:51:12 <ivanm> blackh: right, so you're +10 (without daylight saving)
03:51:21 <Axman6> my mum had to wake me up at 6:30 last night for dinner
03:51:26 <ivanm> heh
03:51:35 <mistermattaway> too much team fortress
03:51:43 <Axman6> hehe
03:51:44 <blackh> ivanm: 12 hours away from GMT in winter, 13 in summer
03:51:47 <Axman6> good stuff :)
03:51:48 <yitz> ivanm: you've never seen snow? so you've never had a non-cable television?
03:52:10 <ivanm> blackh: oh, so you're right on the split line?
03:52:14 <Axman6> cosmic snow /= snow
03:52:16 <ivanm> yitz: heh
03:52:26 <ivanm> yitz: I've never had cable TV
03:52:43 <Axman6> does cabal even exist here?
03:52:43 <ivanm> we do have digital now since our new DVD/VCR player has an SD set-top box built in...
03:52:45 <blackh> ivanm: Yes - quite near the dateline. I went to the US on my birthday once so I am actually a year older than I am
03:52:49 <Axman6> uh, cable
03:52:49 <ivanm> Axman6: foxtel, etc.
03:52:54 <Axman6> too much haskell >_<
03:53:00 <ivanm> blackh: heh
03:53:04 <ivanm> Axman6: heh
03:53:06 <Peaker> ivanm: http://www.skrbl.com/125563793
03:53:09 <Axman6> that's usually satellite no?
03:53:13 <ivanm> nope
03:53:22 <ivanm> even transact does TV over its fibre
03:53:23 <Axman6> sure it is
03:53:39 <Axman6> well yeah, transact is, but lots of foxtel places use satellites
03:53:46 <ivanm> it might not be the same "cable" that yanks use though
03:53:51 <ivanm> Peaker: heh
03:54:14 <Axman6> anyway, blackh, in the new year, we must get together and dominate the shootout some more
03:54:21 <ivanm> Peaker: but I can't read your handwriting... >_>
03:54:47 <ivanm> Axman6: virtually, I presume, unless one of you two are crossing the tasman
03:54:50 <ivanm> @slap mistermattaway
03:54:50 * lambdabot slaps mistermattaway with a slab of concrete
03:54:56 <Peaker> ivanm: its not my handwriting :)
03:55:06 <Peaker> ivanm: anyone here could be it :)
03:55:08 <blackh> Axman6: Let's do that - we can use ghc-6.12!
03:55:21 <mistermattaway> I wonder if I could draw with a stylis on my laptop mouse pad
03:55:22 <Axman6> ivanm: your ideas of meetings are so dated, get with the mellenium!
03:55:25 <mistermattaway> stylus
03:55:29 <ivanm> mistermattaway: I doubt it
03:55:29 <Axman6> blackh: hoorah!
03:55:32 <ivanm> they use body heat IIRC
03:55:38 <Axman6> shoul;d make some of the parallel code nice
03:55:44 <ivanm> Axman6: get with the correct spelling of millenium!
03:55:54 <ivanm> and using 6.12 depends on the shootout machine having 6.12
03:56:04 <Axman6> we'll make them install it
03:56:16 <Axman6> "You're using an anclent compiler, of course it's slow!
03:56:17 <Peaker> anyway, ap/<*> and >>= and join all "duplicate" an argument (join does just this, >>= also does (.) before join, and ap is like >>= with some flips)
03:56:54 <mistermattaway> hehe I'm probably going to end up writing horrible looking C++ code for class
03:56:56 <Axman6> is there a nice way to get an Applicative only version of >>=?
03:57:14 <Peaker> Axman6: (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b     (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b   - so they're the same up to flipping some
03:57:36 <Axman6> i see... so =<< = <*>?
03:57:45 <Peaker> need to flip the func there too
03:57:47 <Axman6> not wuite
03:57:52 <Axman6> bleh
03:57:53 <Peaker> @djinn ((r -> a) -> (a -> r -> b) -> r -> b) -> (r -> a -> b) -> (r -> a) -> r -> b
03:57:53 <lambdabot> f _ a b c = a c (b c)
03:57:57 <Axman6> not very nice :\
03:58:46 <Peaker> doh, it just reimplemented <*> instead of using (>>=) to do so :)
03:58:52 <theorbtwo> dijin takes a type and tries to give you back a function of that type?
03:59:01 <Axman6> theorbtwo: yup
03:59:07 <theorbtwo> Cool.
03:59:12 <Peaker> @type (.flip) (=<<)
03:59:13 <lambdabot> forall (f :: * -> *) a b. (Functor f, Monad f) => f (a -> b) -> f a -> f b
03:59:14 <Axman6> haskell is so awesome, you can produce code without having to write it!
03:59:18 <dolio> (=<<) and (<*>) are only equivalent for reader.
03:59:38 <Axman6> mince pie time!
03:59:50 <Peaker> @let (f .. g) x = f (g x)
03:59:50 <lambdabot>   Parse error: DotDot
03:59:58 <ivanm> IIRC, the typeclassopedia says that Monad = Applicative + (>>=)
04:00:04 <ivanm> so I doubt you can have an applicative-only version
04:00:05 <Peaker> @let (f .@. g) x = f (g x)
04:00:05 <mistermattaway> Axman, I'm goign to try to get soem tylenol PM tomorrow night
04:00:06 <lambdabot>  Defined.
04:00:12 <Peaker> @type (.@.flip) (=<<)
04:00:13 <lambdabot> forall (f :: * -> *) a b. (Functor f, Monad f) => f (a -> b) -> f a -> f b
04:00:15 <ivanm> Axman6: not for another hour!
04:00:28 <Peaker> why Functor?
04:00:37 <ivanm> Peaker: why?
04:00:43 <Peaker> @type flip
04:00:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:00:46 <ivanm> Peaker: Caleskell
04:00:48 <Peaker> oh
04:00:48 <ivanm> @src (.)
04:00:49 <lambdabot> (f . g) x = f (g x)
04:00:52 <ivanm> bah
04:00:53 <Peaker> ivanm: I used .@. for this reason
04:00:58 <ivanm> Peaker: *nod*
04:01:00 <Peaker> ivanm: but apparently flip is too!
04:01:06 <ivanm> yup
04:01:10 <Peaker> @let flipp f x y = f y x
04:01:11 <lambdabot>  Defined.
04:01:15 <Peaker> @type (.@.flipp) (=<<)
04:01:16 <lambdabot> forall t1 t t2. (t1 -> t -> t2) -> (t1 -> t) -> t1 -> t2
04:01:29 <Peaker> there we go
04:01:34 <Peaker> that's Reader's <*>
04:01:56 <Peaker> @type (P..)
04:01:57 <lambdabot> Couldn't find qualified module.
04:02:00 <Peaker> @type (Prelude..)
04:02:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:02:14 <Peaker> @type (Prelude.. Prelude.flip) (=<<)
04:02:15 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
04:02:27 <Peaker> that's nicer..
04:03:48 <mistermattaway> I want some donuts
04:03:49 <blackh> Axman6: Actually in our last round of shootout-ing, I was concentrating on making the code fast - but next time I'll shift the emphasis to making the code nice *and* fast.
04:04:03 <Axman6> good plan
04:04:09 <blackh> Axman6: Some of my shootout code is hideous.
04:04:13 <Axman6> heh
04:04:32 <Axman6> i dislike the n-body code because it's basically low level C hacking
04:05:03 <mistermattaway> triple pointers
04:05:12 <mistermattaway> where are my aviators
04:06:51 <ivanm> ...
04:09:11 <ivanm> @instances-importing Data.Sequence Functor
04:09:12 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, Seq, State s, StateT s m, ViewL, ViewR, Writer w, WriterT w m, []
04:09:38 <Peaker> mistermattaway: how new are you to Haskell?
04:10:16 <mistermattaway> with respect to you all, I may as well have never heard of it
04:10:49 <ivanm> gah! why is ghci complaining about infinite types!
04:11:00 <mistermattaway> peaker, so quite new
04:11:11 <Peaker> ivanm: the most annoying type error, ever
04:11:16 <zygoloid> ivanm: magic 8-ball says you created an infinite type ;-)
04:11:29 <zygoloid> > join id
04:11:30 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a)
04:11:46 <Peaker> ivanm: you're trying to use [a] in place of a, or (a->b) in place of a or b, or some such
04:12:04 <zygoloid> ivanm: can you paste?
04:12:04 <Peaker> I think in these error messages, ghc could at least give more specific information about where the error lies
04:12:24 <zygoloid> Peaker: i think the problem (not just here but also more generally in Hindley-Milner) is that it doesn't really know
04:12:31 <ivanm> I had a custom list-like type (which is an instance of Functor) in a record type; I changed this to being a Seq of a custom type instead, and now it complains!
04:12:58 <zygoloid> but there was a paper circulating recently which discussed using a proof of ill-typing to determine which parts of the program might be relevant
04:13:12 <ivanm> http://paste.pocoo.org/show/159373/
04:13:18 <ivanm> the error is near the bottom
04:14:29 <Peaker> zygoloid: It knows at least which parts are typed like that
04:14:47 <ivanm> the fact that it includes a recursive definition probably doesn't help...
04:14:47 <Axman6> mistermattaway: what have you done so far?
04:14:56 <Peaker> zygoloid: it could highlight all participants in the problematic unification
04:16:12 <zygoloid> ivanm: looks like you're one fmap short?
04:16:30 <zygoloid> ivanm: you've fmapped under the Seq but not under GDotStatement
04:16:38 <Peaker> ivanm: where's the error?
04:16:43 <Peaker> oh, missed it
04:16:46 <Peaker> long paste :)
04:17:14 <mistermattaway> axman6, what do you mean? With Haskell?
04:17:16 <zygoloid> fmap f sg { gSubGraphStmts = stmts } = sg { gSubGraphStmts = (fmap.fmap) f stmts }
04:17:19 <Peaker> ivanm: using SECs (for records here) you can make that code prettier and avoid {}
04:17:24 <Axman6> mistermattaway: yeah
04:17:34 <ivanm> SECs?
04:17:49 <mistermattaway> axman6, I'm just slowly working through Real World Haskell (I'm on the chapter 3 problem set)
04:17:59 <zygoloid> whoops... sg@(GDotSG { ... }) = ...
04:18:02 <ivanm> zygoloid: why would it need fmap . fmap? I would have thought the fmap definition for Seq would have taken care of that...
04:18:15 <zygoloid> ivanm: that'll take you to GDotStatement a, not to a
04:18:18 <Axman6> mistermattaway: may i recommend lyah to you? RWH is not in my opinion a good book to learn haskell for. it's better once you have a feel for the language
04:18:25 <Baughn> @type (.) . (.)
04:18:26 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:18:28 <ivanm> ahh, that works; thanks zygoloid
04:18:32 <Peaker> ivanm: instead of blah { bleh = f (bleh blah) }  you can have:  atBleh f
04:18:34 <Baughn> ..oh, cale.
04:18:40 <ivanm> @type (Prelude..) Prelude..  (Prelude..)
04:18:41 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:18:45 <ivanm> Baughn: ^^
04:18:50 <Baughn> Thanks. ^^;
04:18:51 * Axman6 rages at Cale again
04:18:55 <ivanm> Peaker: how?
04:19:08 <ivanm> we need a @blame-Cale plugin similar to @get-shapr
04:19:10 <Peaker> @hackage cflabels
04:19:10 <lambdabot> http://hackage.haskell.org/package/cflabels
04:19:16 <Baughn> @get-shapr
04:19:16 <lambdabot> shapr!!
04:19:18 <ivanm> ahhh
04:19:20 <Baughn> Aha.
04:19:25 <mistermattaway> axman6, I've seen that before, I think once I get more of the basics solidified I'll startt to bounce between the two
04:19:25 <ivanm> Peaker: I myself don't really use them that much that I care
04:19:31 <Baughn> shapr: No, nothing. Don't mind us.
04:19:44 <ivanm> preflex: seen shapr
04:19:44 <preflex>  shapr was last seen on #haskell-blah 2 days, 5 hours, 46 minutes and 21 seconds ago, saying: http://www.cracked.com/article_15231_7-reasons-21st-century-making-you-miserable.html
04:20:03 <Peaker> ivanm: either using that, or some boilerplate around records:  data Record { a, b :: Integer } ; atA f r = r { a = f . a $ r } ; ...
04:20:15 <Peaker> ivanm: then all access to the records, especially of nested kind, is much nicer
04:20:16 <ivanm> right, I get what you mean now
04:20:26 <ivanm> but I don't use them that much to care
04:20:28 <Peaker> ivanm: if you want to change the field buried 3 records deep, just: (atA . atB . atC) (+1)
04:20:32 <Peaker> ivanm: ok
04:20:37 <ivanm> since I _don't_ change them that deep ;-)
04:20:48 <zygoloid> Peaker: this would seem to be the implemementation of that boilerplate :)
04:20:52 <ivanm> Peaker: for the most part, I don't expect anyone to actually view the guts of these record types
04:21:11 <ivanm> they're there mainly for debugging purposes, and in case anyone is making DotGraph values by hand rather than converting from FGL
04:21:20 <ivanm> if someone asks, I can add that in
04:21:26 <ivanm> no-one has asked yet though, so shmeh ;-)
04:24:01 <Peaker> ivanm: can you add that in?
04:24:10 <Peaker> haha, ruined that line of reasoning :)
04:24:14 <ivanm> @slap Peaker
04:24:15 * lambdabot activates her slap-o-matic...
04:24:25 <ivanm> Peaker: show me how you're using graphviz and I'll consider it ;-)
04:24:40 <Peaker> ivanm: I'm using graphviz to alter your records
04:25:20 <ivanm> ...
04:26:09 <YuleAthas> Is there a standard name for this function: \(a, b) = (,) <$> a <*> b ?
04:27:04 <Axman6> listA2 (,)
04:27:11 <Axman6> uh, liftA2
04:27:19 <YuleAthas> Ah, right, of course.
04:27:31 <Axman6> uh, not quite
04:27:43 <Axman6> uncurry (liftA2 (,))
04:27:50 <Axman6> :t uncurry (liftA2 (,))
04:27:50 <Peaker> or <^(,)^>
04:27:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
04:27:52 <YuleAthas> Well, close enough.
04:28:04 <Peaker> if you import Control.Applicative.Infix
04:28:06 <YuleAthas> liftM2/liftA2 is what I forgot about.
04:28:16 <Axman6> Peaker: seems we both missed the \(a,b) part
04:28:16 <Beelsebob> Peaker: actually <^(,)^> can't stand on it's own :(
04:28:20 <Peaker> oh
04:28:26 <Beelsebob> at least one of <^ or ^> needs to be fully applied
04:28:37 <Peaker> Beelsebob: Yeah, I know
04:28:42 <Beelsebob> this is a shame :(
04:29:04 <Axman6> :t <^(,)^>
04:29:05 <lambdabot> parse error on input `<^'
04:29:10 <Axman6> :t (<^(,)^>)
04:29:11 <lambdabot> parse error on input `)'
04:29:14 <Axman6> :(
04:29:25 <Beelsebob> @let (<^) a f = fmap f a
04:29:25 <Axman6> :t (?a <^(,)^> ?b)
04:29:26 <lambdabot> Not in scope: `<^'
04:29:26 <lambdabot> Not in scope: `^>'
04:29:26 <lambdabot>  Defined.
04:29:38 <Beelsebob> @let (^>) f a = f <*> a
04:29:39 <lambdabot>  Defined.
04:29:47 <Axman6> :t (?a <^(,)^> ?b)
04:29:47 <lambdabot> forall (f :: * -> *) a a1. (?a::f a, Applicative f, ?b::f a1) => f (a, a1)
04:30:10 <Beelsebob> basically – it's lifted tupling
04:31:01 <Baughn> shapr: AAGH!
04:31:26 <Baughn> shapr: Thanks for the cracked.com link! You're not even here, and you're wrecking my day! ;_;
04:31:38 <Baughn> shapr: ..five tabs and counting. ;_;
04:32:06 <Peaker> Beelsebob: <^(,)^>  is way too heavy for me though
04:32:25 * Beelsebob prefers it to liftA2 (,)
04:32:26 <Peaker> Beelsebob: In Agda where they have more "advanced" infixing, I guess it could be something like <^,^>  maybe?
04:32:33 <Beelsebob> fewer characters, and makes it clearer what's going on
04:32:41 <Beelsebob> Peaker: yeh, that would be nice
04:32:44 <Peaker> Beelsebob: liftA2 (,) is fewer tokens though
04:32:54 <Beelsebob> tbh, what it really needs is not advanced-infixing, it's mixed-fixing
04:33:09 <Beelsebob> where <^a^> = liftA2 a
04:33:21 <Peaker> How do you convert between fixing in Agda?
04:33:41 <Peaker> If you want a "prefix" +, in Haskell you write (+), in Agda you write..?
04:33:41 <Beelsebob> no idea
04:33:44 * Beelsebob doesn't know agda
04:34:00 <Saizan_> Peaker: _+_
04:34:15 <Beelsebob> heh, that's a shame, it has the reverse connotation of ^
04:34:32 <Peaker> Saizan_: cool, that's what I guessed :)
04:34:38 <Saizan_> _ is the placeholder for arguments anyway
04:34:43 <Baughn> ..has haskell become synonymous with ghc?
04:34:51 <burp> kind of :>
04:34:53 <Peaker> Baughn: where?
04:35:05 <Baughn> Peaker: haskell.org, "download haskell" link - haskell platform, including ghc.
04:35:06 <burp> haskell version 6.12 ;)
04:35:09 <Baughn> Not even a choice.
04:35:17 <Beelsebob> > isSymbol "⇈"
04:35:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:35:18 <lambdabot>         against inferred type...
04:35:32 <Beelsebob> > isSymbol '⇈'
04:35:33 <lambdabot>   True
04:35:41 <yitz> Baughn: jhc is being actively developed. Some uni courses still use Hugs.
04:35:50 <Beelsebob> > isSymbol '↿'
04:35:51 <lambdabot>   True
04:36:04 <Beelsebob> @let (↿) a f = fmap f a
04:36:05 <lambdabot>  Defined.
04:36:13 <jlouis> I sometimes use hugs for smaller things where I just want the speed
04:36:13 <Beelsebob> @let (↾) f a = f <*> a
04:36:14 <lambdabot>  Defined.
04:36:32 <Beelsebob> > (Just 1) ↿(,)↾ (Just 2)
04:36:33 <lambdabot>   Just (1,2)
04:36:46 <Beelsebob> how's that Peaker?
04:36:50 <jlouis> GHC produces excellent executables, but the compilation time doesn't really cut it
04:37:15 <Peaker> Beelsebob: cool :)
04:37:32 <Saizan_> jlouis: runghc/ghci ?
04:37:48 <jlouis> Saizan_: I've begun using that recently, yes
04:37:49 * hackagebot upload: bluetile 0.3.1 - A modern tiling window manager with a gentle learning curve (JanVornberger)
04:37:51 <Beelsebob> Peaker: I may just add that to the infix-applicative package
04:39:14 <mreh> is increased computational complexity a good trade-off against program complexity?
04:40:25 <mreh> I need to implement some non-determinism, list-monad is the obvious choice, but I need to simulate race conditions/have a genuinely stochastic output
04:40:54 <mreh> so I'm going to waste a lot of computation in practice
04:41:31 <Saizan_> so you're going to randomly select only one of the results?
04:41:33 <mreh> that is by keeping the code simple
04:41:37 <mreh> Saizan_ aye
04:41:45 <mreh> i suppose I could randomise the input lists
04:42:11 <mreh> x <- choose $ randomise mylist
04:42:21 <mreh> but then were talking about monad transformers
04:42:58 <Saizan_> if the overall performance is acceptable and you encapsulate it so that it's easy to switch to something else later, i'd say it's fine
04:43:15 <mreh> Saizan_ hehe, computation is rather cheap these days
04:43:36 <Peaker> mreh: not as cheap as lack of computation!
04:44:17 <mreh> Peaker: my brain hurts when I have to do monad transformers, so In practice I don't agree
04:45:44 <Peaker> mreh: I newtype away my Monad Transformer stack and then I write lifters for every level, and then I don't think about it anymore
04:45:46 <ivanm> datatypes and classes share the same namespace, don't they
04:45:49 <Saizan_> mreh: this is a great paper to learn about transformers http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.268 for when you're in the mood of learning them :)
04:45:53 * hackagebot upload: InfixApplicative 1.1 - liftA2 for infix operators. (ThomasDavie)
04:46:04 <Peaker> mreh: Or I use it one-shot like:  runMaybeT . forever $ do ...  for breakable loops/etc
04:46:41 <mreh> Peaker: therein I don't know what you're talking about :)
04:46:52 <mreh> I'm sure it's all good juicy stuff
04:47:24 <Peaker> mreh: the newtype stuff?
04:47:56 <mreh> I'm going to get the ball rolling with a library for haskore that just hasn't been written yet, even though it's been promised for ages
04:48:06 <mreh> even if it is crappy
04:48:16 <Peaker> mreh: which stuff didn't you get?
04:48:31 <mreh> Peaker: newtypes, I don't have time to invest in it today
04:48:52 <mreh> RWH mentions about how it behaves with undefined values
04:49:16 <mreh> not much use because I didn't understand the behaviour, so I didn't remember it
04:49:18 <sinelaw> why does my haskell-mode not autocomplete when i have a Module.something? I treats the '.' as part of the word
04:49:24 <sinelaw> is there an easy way to fix that?
04:49:44 <Saizan_> well, the main thing about newtypes is that they don't add any runtime overhead over the wrapper type
04:50:06 <mreh> Saizan_ they are single constructor types aren't they?
04:50:16 <Saizan_> mreh: single constructor and single field
04:50:54 <mreh> have any successful libraries started off as toys?
04:51:00 <Saizan_> s/wrapper/wrapped/
04:51:01 <ivanm> sinelaw: because it doesn't have any autocompletion in it
04:51:08 <ivanm> (if you're talking about the emacs haskell-mode)
04:51:31 <sinelaw> i am, but it's because it thinks '.' is part of the word rather than separating it away as it does in python-mode
04:51:40 <mreh> I want to write a library that is useful to me, is it worth putting it on hackage?
04:51:49 <ivanm> sinelaw: nominolo is working on a tool/library that can be used to augment editing modes in this way
04:51:53 <mreh> so it might be extended
04:51:55 <sinelaw> it should try to complete on the 'something', not on 'Module.something'
04:52:00 <ivanm> mreh: if you think it will be usefult to others, then yes
04:52:04 <mreh> it will be no means a complete implementation
04:52:06 <ivanm> sinelaw: what should try to complete?
04:52:08 <sinelaw> mreh, what is it?
04:52:25 <mreh> sinelaw: a lilypond source code generator from haskore data structures
04:52:25 <ivanm> AFAIK, emacs haskell-mode doesn't do _any_ completion
04:52:49 <sinelaw> mreh, of course you should put that on hackage
04:52:51 <mreh> i'm hoping it's simple because the notation of music is separate from the interpretation
04:53:09 <mreh> it may even guide the development of haskore
04:53:29 <mreh> but it is literally going to start off by just writing out simple melodies and rhythms correctly
04:53:33 <sinelaw> ivanm, sorry i don't mean autocompletion, i mean completion according to similar words in the open buffers (the basic emacs completion)
04:53:56 <ivanm> what basic completion? I don't recall emacs having any inbuilt completion support...
04:54:11 <sinelaw> dabrrev-expand
04:54:11 <mreh> parallel voices, chords... etc. etc.
04:54:12 <EvilTerran> vim has ^N and ^P
04:54:19 <ivanm> no idea then
04:54:38 <sinelaw> ivanm, try running M-x dabbrev-expand
04:54:42 <sinelaw> in my emacs it's bound to M-/
04:54:58 <sinelaw> do it after typing the beginning of a word
04:55:07 <sinelaw> that already exists in an open buffer
04:55:28 <ivanm> cool
04:55:31 <ivanm> didn't know about that
04:55:42 <mreh> can haskell inspect a stack of nested functions like it can recursively inspect a load of nested datatypes?
04:55:58 <mreh> I've seen lists with functions, but I seem to remember you have to add extra parameters
04:56:19 <sinelaw> ivanm, if you press M-/ more than once, it iterates between the available options
04:56:23 <Saizan_> mreh: can you make an example?
04:56:38 <ivanm> yeah, I noticed that
04:58:15 <mreh> Saizan_ well, in haskore you can express a music object like a trill in haskore by a function of two notes and the period (think 1/frequency) of the trill
04:58:50 <mreh> haskore turns that into a performance by evaluating that function, I would like to turn that function into a datatype that represents the trill so it can be notated in the appropriate way
04:59:06 <mreh> with lazy evaluation I have the opportunity
04:59:16 <mreh> but maybe not the means
04:59:51 <Saizan_> well, you can't look inside the function
05:00:06 <Saizan_> you can only apply it and look at the result
05:00:48 <mreh> i suppose the lambda calculus has no such operation...
05:01:14 <mreh> it may be the next step in the development of haskore
05:01:17 <mreh> we shall see
05:01:48 <Saizan_> use first-order datatypes rather than functions?
05:02:25 <Axman6> merry christmas haskellers
05:02:48 <ClaudiusMaximus> if the function are members of a type class, you could have an instance of that class that constructs a data structure that you can inspect
05:02:57 <ivanm> hmmm... is there a way of stopping extra instances from being made of a class?
05:03:03 <ivanm> thanks Axman6
05:03:26 <mreh> ClaudiusMaximus: methods in a type class?
05:05:06 <sinelaw> is there a common name for the function you pass into a fold?
05:05:19 <sinelaw> a 'folder'? :(
05:05:33 <ClaudiusMaximus> mreh: i'm not familiar with haskore, but type classes would be a logical way (to me) to have multiple interpretations (like performance, notation, ...) of the same code
05:05:36 <sinelaw> @hoogle (a -> b -> b)
05:05:37 <lambdabot> Prelude seq :: a -> b -> b
05:05:37 <lambdabot> Control.Parallel par :: a -> b -> b
05:05:37 <lambdabot> Control.Parallel pseq :: a -> b -> b
05:06:34 <mreh> ClaudiusMaximus: how is the visitor pattern done in haskell?
05:07:13 <ClaudiusMaximus> mreh: no idea
05:09:28 <ivanm> @src Functor
05:09:29 <lambdabot> class  Functor f  where
05:09:29 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
05:10:18 <sinelaw> is there a way to do pattern matching in side the guard of a list comprehension?
05:10:22 <sinelaw> *inside
05:10:23 <Peaker> there should be a convention, maybe, that you're only allowed multiple methods in a single type-class if they can be defined in terms of each other anyway
05:10:50 <Peaker> sinelaw: you can use a "let" clause and then a guard
05:10:55 <sinelaw> ok
05:11:27 <Peaker> in Python, btw, list comprehensions don't have a "let" clause, so I'm using something like: x <- [y]  for let :)
05:12:00 <sinelaw> huh?
05:12:09 <ivanm> how can I define a class where the instance has kind * -> * but with constraints on the type?
05:12:40 <sinelaw> instance (Monad m, Show a) => MyClass m a?
05:12:41 <ivanm> e.g. I want to let (F a) be an instance iff (F a) is an instance of Eq
05:12:56 <Peaker> sinelaw: to emulate:  [(x, y, z) | x <- [1..10], y <- [x+1..10], let z = 20 - x - y, odd z]  I'd use:  [(x, y, z) for x in xrange(10) for y in xrange(x+1, 10) for z in [20-x-y] if odd(z)]
05:12:57 <sinelaw> oops that was wrong, i guess
05:13:17 <sinelaw> Peaker, oh, heh
05:13:28 <sinelaw> i meant class, not instance
05:13:49 <Peaker> ivanm: maybe a multi-param type-class, like rmonad
05:14:05 <ivanm> bugger, I was hoping to avoid extensions...
05:14:14 <Peaker> ivanm: http://hackage.haskell.org/packages/archive/rmonad/0.4.1/doc/html/Data-Suitable.html#t%3ASuitable
05:14:23 <ivanm> I dont' _need_ to have those constraints in there; it just means that some functions down the track would have much nicer type sigs
05:14:37 <Peaker> ivanm: Oh, but then you'd be restricting generality
05:14:51 <ivanm> yeah
05:15:06 <ivanm> but in this specific case, the only reason I'm using a class is to provide a common usage API for two different types
05:18:04 <ivanm> ideally, I'd want to restrict the ability to make new instances as well
05:19:03 <gwern> sjanssen: turns out that running the yhc functions before ghc doesn't change the results like you thought they might: http://hackage.haskell.org/trac/ghc/attachment/ticket/2143/sort-reverse.txt
05:20:14 <ivanm> *sigh* type families are nice to use, but too damn verbose IMHO :s
05:20:43 <ivanm> Peaker: so using associated types or fundeps the only way to place constraints on the a in (F a) ?
05:28:21 <Saizan_> ivanm: you need just multiparameter typeclasses if i've understood you
05:28:41 <ivanm> not even a fundep? :o
05:28:42 <Saizan_> ivanm: could we see the class as it is now?
05:28:54 <ivanm> heh, I've butchered it now
05:29:19 <ivanm> but say something like: class (Ord a) => SetLike (s a) where ...
05:29:37 <ivanm> oh, but actual constraints on (s a) as well
05:30:02 <Saizan_> class (SomeClass (s a), Ord a) => SetLike s a where ..
05:30:29 <ivanm> ooohhh...
05:30:44 <ivanm> one big huge ugly constraint, coming right up! ;-)
05:30:45 <Saizan_> that's a typeclass with two parameters
05:30:48 <ivanm> thanks Saizan_
05:33:03 <ivanm> and of course it needs flexibleinstances... :s
05:34:07 <ivanm> hmmm... in the end, I need to shift the equivalent to the (Ord a) bit to the instances to get it to work...
05:34:21 <ivanm> (since I actually have something like (Ord a, Ord (s a))
05:34:27 <ivanm> but it's still nicer!
05:36:01 <ivanm> the only way to stop extra instances being added is to export a class without any of its methods, right?
05:38:20 <c_wraith> Doesn't that also prevent the class from being used outside that module?
05:38:46 <c_wraith> Though I guess it can be included in contexts in type signatures of functions that are exported...  So it has some value
05:39:42 <Saizan_> well, not exporting the methods only prevents you from making an usable instance
05:40:41 <ivanm> why doesn't MultiParamTypeClasses automatically enable FlexibleInstances?
05:40:53 <ivanm> c_wraith: right
05:40:55 <ivanm> Saizan_: :(
05:41:08 <ivanm> so there's no way of stopping people from making instances?
05:41:28 <c_wraith> why is it so bad if people make extra instances?
05:43:53 <Saizan> you can have another dummy class, like YouCantInstanceThis, and make it a superclass of your SetLike
05:44:13 <Saizan> and not export YouCantInstanceThis at all
05:44:38 <ivanm> nah, that's too dodgy
05:44:45 <ivanm> c_wraith: well, there should be no reason for them to do so
05:44:57 <ivanm> so for neatness sake I thought it'd be better not to let them
05:52:41 <koala_man> I'm doing some graphy stuff that involves a function Node -> [Node], which I want to apply it repeatedly until I find all the unique nodes it'll produce. Is there a more clever approach than a State monad that keeps a list of visited nodes and elem against it?
05:53:11 <ivanm> use a Set?
05:53:20 <ivanm> maybe with an unfoldr or something?
05:53:37 <ivanm> koala_man: depends on what you want to do; I've done similar stuff for my graphalyze library
05:53:40 <ivanm> @hackage Graphalyze
05:53:40 <lambdabot> http://hackage.haskell.org/package/Graphalyze
05:54:36 <koala_man> I specifically want to find nodes reachable by epsilon transitions in a fsm
05:54:38 <ivanm> actually, some of what you want is stuff that isn't in a release yet; see Data.Graph.Analysis.Algorithms.Directed in darcs
05:55:01 <ivanm> koala_man: no idea what epsilon transitions are, but I have reachability functions in the darcs repo
05:55:30 <ivanm> the accessible* functions
05:55:55 <kw317> what's the plural of redex?
05:56:02 <koala_man> well.. how'd you do it? :P
05:56:15 <ivanm> have a look at the code!
05:56:16 <ivanm> ;-)
05:56:24 <Twey> Redices, perhaps
05:56:27 <ivanm> but I used sets
05:56:31 <Twey> But probably just ‘redexes’ :þ
05:56:35 <ivanm> and some fixPoint functions
05:57:01 <kw317> Twey: google fight will tell me ;-)
05:57:08 <Twey> Hehe
05:57:34 <kw317> redices seems to be more popular
05:57:48 <kw317> or I will just re-write the sentence so as it does not need plural
05:58:14 * kw317 hates English morphology
05:58:17 <Jonno_FTW> hey, is there a way I can use takeWhile (/=) and still get x on the end without appending it the list?
05:58:34 <ivanm> Jonno_FTW: redefine takeWhile
05:58:40 <ivanm> which several people have done themselves
05:58:46 <Jonno_FTW> @src takeWhile
05:58:46 <lambdabot> takeWhile _ []                 =  []
05:58:46 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
05:58:46 <lambdabot>                    | otherwise =  []
05:58:51 <ivanm> yes, it's a PITA; but there's no standard function that does it
05:59:01 <ivanm> Jonno_FTW: all you need to do is edit the otherwise to return [x]
05:59:28 <koeien> kw317: heh. I think English morphology is quite sane :)
06:00:12 <koeien> not to start a holy war, but are there any vim fans that do use emacs for haskell editing?
06:00:20 <koeien> (because of haskell-mode)
06:00:45 <vowyer> koeien: me
06:00:58 <vowyer> mostly because of sane indentation
06:02:07 <koeien> any other features that you think are very useful?
06:02:21 <koeien> maybe i should just try it to see whether i like it =)
06:02:35 <vowyer> koeien: yes, automatic type info
06:03:10 <koeien> and what about leksah?
06:03:24 <vowyer> I started using emacs for clojure, because of the REPL and slime integration, and being a vim fan I can tell you it's not that bad
06:03:55 <osfameron> slime looks very cool
06:04:01 <osfameron> I couldn't get it to install
06:04:06 <Jonno_FTW> ok thanks, i accidentally had ghci suck up all the ram
06:05:07 <vowyer> koeien: I didn't try leksah
06:05:34 <koeien> Jonno_FTW: I find it useful to use ulimit before starting my ghci sessions
06:05:51 <Jonno_FTW> how do i do that?
06:06:11 <koeien> this is a feature of linux, don't know if it's available elsewhere
06:06:22 <koeien> (and bash, i guess? don't know)
06:06:24 <Jonno_FTW> i have windows
06:06:54 <vowyer> *nix specific
06:08:14 <koeien> i have a    ulimit -S -v 3*1024*1024   in my .bashrc
06:08:40 <koeien> this has turned out to be useful sometimes =)
06:11:16 <Jonno_FTW> ok
06:11:29 <Jonno_FTW> perhaps I should program more memory friendly though
06:11:44 <koeien> if you run out of RAM, that's probably a good idea
06:12:03 <Jonno_FTW> doing a project euler question
06:12:11 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=132
06:12:56 <koeien> what is your approach?
06:13:05 <mxc> i've never been able to get leksah to work
06:13:17 <Jonno_FTW> x n = r (10^n) where r k = read $concatMap show $ replicate k 1 :: Integer
06:13:27 <mxc> can get it running, but can't succesfully import a project or anything, even htough everything i do is cabalized
06:13:29 <Jonno_FTW> could that be the problem?
06:13:45 <koeien> Jonno_FTW: yes! r (10^n) is *huge*
06:13:50 <Jonno_FTW> yep
06:13:57 <Jonno_FTW> and then i finish with
06:14:00 <necroforest> Is there any way to write the following point-free: scaleUniform a = scale a a a
06:14:01 <Jonno_FTW> answer = takeWhile' (/= 9091) $ map fst $primePowerFactors (x 50)
06:14:22 <koeien> didn't they want 10^9 ?
06:14:30 <Jonno_FTW> woops
06:14:37 <Jonno_FTW> yes, replace 50 with 9
06:14:38 <koeien> @pf \a -> a a a
06:14:39 <lambdabot> Maybe you meant: bf pl
06:14:43 <koeien> @pl \a -> a a a
06:14:43 <lambdabot> join (join id)
06:14:47 <Jonno_FTW> and it still sucks up the ram
06:15:01 <koeien> could you paste your whole program?
06:15:01 <Jonno_FTW> even at x 6 it takes a while
06:15:19 <Jonno_FTW> that's it
06:15:27 <koeien> @pl scaleUniform a = scale a a a
06:15:28 <lambdabot> scaleUniform = join (join scale)
06:16:16 <koeien> necroforest: i don't think the pointfree version is particularly readable
06:16:38 <necroforest> koeien: i was just curious if you could do it
06:16:55 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14935#a14935
06:16:57 <koeien> necroforest: well, join f is \x -> f x x.
06:17:06 <koeien> > join (*) 37 -- computes 1369
06:17:07 <necroforest> ah
06:17:07 <lambdabot>   1369
06:17:35 <necroforest> so a point free square would just be square = join (*)
06:17:46 <koeien> yes
06:18:22 <ziman> @pl \f x -> f x x
06:18:23 <lambdabot> join
06:18:39 <koeien> Jonno_FTW: that psate is not complete
06:18:51 <ziman> what's the least possible set of functions needed to @pl anything? is join necessary?
06:19:06 <b_jonas> altern> let { square :: (Num a) => a -> a; square = (*)<$>id<*>id; } in square 37
06:19:06 <Jonno_FTW> assume primePowerFactors is pretty good
06:19:18 <Jonno_FTW> as in really fast prime factorisation
06:19:32 <ziman> :t ap id
06:19:33 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
06:19:35 <ski> ziman : you need some function that duplicates, in any case .. such as `join' or `ap'
06:19:54 <ziman> :t flip ap id
06:19:55 <lambdabot> forall a b. (a -> a -> b) -> a -> b
06:20:11 <b_jonas> and you need a return
06:20:23 <ziman> S, K, then? :)
06:20:35 <koeien> and a fix, i guess
06:21:27 <Jonno_FTW> and ideas koeien?
06:21:40 <koeien> Jonno_FTW: one moment
06:22:01 <PeakerWork> necroforest: or (^2) :)
06:22:08 <dfdf> Jonno_FTW: do you know geometric series?
06:22:33 <Jonno_FTW> sort of
06:23:04 <Jonno_FTW> a constant ratio between each term in the series
06:23:16 <ziman> i'm unsure now; SK calculus is turing-complete, afaik -- does that mean we don't need to add fix?
06:23:24 <dfdf> you can use these to avoid direct representation of (R10^9) in memory
06:23:33 <Jonno_FTW> how?
06:23:37 <dfdf> think
06:23:54 <koeien> > (10^5 - 1)%(10-1)
06:23:56 <lambdabot>   11111 % 1
06:24:05 <koeien> nice idea megabeest
06:24:26 <dfdf> koeien : thx
06:24:44 <Jonno_FTW> how would i use that though?
06:26:00 <dfdf> it is not that hard
06:26:42 <koeien> > (10^10 - 1) % (10-9) -- see the pattern?
06:26:43 <lambdabot>   9999999999 % 1
06:26:59 <koeien> > (10^10 - 1) % (10-1) -- see the pattern?
06:27:00 <lambdabot>   1111111111 % 1
06:27:29 <Jonno_FTW> but how can a small representation of a number be factorised?
06:27:55 <dfdf> factorization is not needed
06:28:00 <ski> ziman : iidc, `s (k (s i i)) (s (s (k s) (s (k k) i)) (k (s i i)))' is `fix' .. but that is not typable (without equi-recursive types)
06:29:02 <koeien> a number with 10^9 digits is quite large.
06:29:13 <Jonno_FTW> yes
06:30:39 <koeien> but you are only interested in whether it is a multiple of p for primes p
06:31:43 <tromp__> SSK(S(K(SS(S(SSK))))K) is a shorter fix
06:31:46 <koeien> to do that, you can calculate (10^k - 1) / 9 mod p, where k is the number of digits. (In your case k = 10^9)
06:31:53 <ziman> ski, tromp__, cool :)
06:32:27 <koeien> run through p = 2,3,5,7, ... and determine whether it is zero. Find the lowest 40 primes for which this is true, and sum them
06:32:32 <ski> tromp__ : mine is even longer, if you expand the `i's
06:32:44 <koeien> do you see a way to calculate (10^k - 1)/9 mod p, without actually computing (10^k - 1) first ?
06:32:58 <tromp__> yes, mine is provably minimal
06:33:17 <Jonno_FTW> no...
06:33:41 <koeien> you can use that (a*b) mod p = (a mod p)* (b mod p)
06:33:44 <ziman> hmm, how do you prove it's minimal?
06:33:53 <tromp__> try all shorter ones:)
06:33:58 <ziman> hehe :)
06:34:20 <ski> @unpl ap ap const (ap (const (ap ap (ap (ap ap const)))) const)
06:34:21 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ n o -> n >>= \ l -> o >>= \ k -> return (l k)) (\ a _ -> a) ((\ _ -> (\ af ag -> af >>= \ ad -> ag >>= \ ac -> return (ad ac)) >>=
06:34:21 <lambdabot> \ x -> (\ am -> ((\ ay az -> ay >>= \ aw -> az >>= \ av -> return (aw av)) >>= \ aq -> (\ c _ -> c) >>= \ ao -> return (aq ao)) >>= \ aj -> am >>= \ ai -> return (aj ai)) >>= \ w -> return (x w)) >>=
06:34:21 <lambdabot>  \ r -> (\ d _ -> d) >>= \ q -> return (r q))
06:34:41 <ski> .. hrm, maybe not
06:34:55 <koeien> > (2^10) `mod` 37
06:34:57 <lambdabot>   25
06:35:03 <koeien> > (2^5) `mod` 37
06:35:04 <lambdabot>   32
06:35:09 <b_jonas> koeien: though that gets hard if p == 3
06:35:11 <koeien> > (32 * 32) `mod` 37
06:35:12 <lambdabot>   25
06:35:14 <ziman> :t ap ap const (ap (const (ap ap (ap (ap ap const)))) const)
06:35:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = m (a -> b)
06:35:15 <lambdabot>       Expected type: m (a -> b)
06:35:15 <lambdabot>       Inferred type: a
06:35:26 <ski> @type let i = id; k = const; s f g x = ap f g x in s (k (s i i)) (s (s (k s) (s (k k) i)) (k (s i i)))
06:35:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
06:35:27 <lambdabot>     Probable cause: `i' is applied to too few arguments
06:35:27 <lambdabot>     In the second argument of `s', namely `i'
06:35:33 <koeien> b_jonas: yeah, true. (9,3) != 1. But you can easily see it in that case using 10 = 1 mod 3
06:35:33 <ski> (obviously)
06:36:21 <koeien> b_jonas: so 111...11 is a 3-multiple iff the number of 1's is a multiple of 3
06:38:19 <koeien> and you don't need to divide by 9 in the other cases, since the inverse of 9 is never going to be 0. So to test whether that expression is zero, you need nothing else than to check whether 10^k = 1 mod p
06:38:30 <koeien> maybe you can see it now, Jonno_FTW ?
06:39:29 <Jonno_FTW> sort of,
06:39:34 <Jonno_FTW> so p is a prime?
06:39:46 <koeien> yes
06:40:01 <Jonno_FTW> hmm
06:40:03 <koeien> we were interested in prime factors p of a number x. p is a factor of x iff x mod p = 0
06:40:11 <Jonno_FTW> ok
06:40:55 <koeien> so run through p = 2, 3, 5, 7, ..., and determine whether your x mod p = 0 is true or not
06:41:17 <koeien> your x = (10^k - 1)/9.
06:41:43 <koeien> you can divide by 9 if p != 3, otherwise you have to be careful
06:41:45 <b_jonas> koeien: or in more general you can compute the power modulo 27, then you can compute the division by 9 modulo 3 I think
06:42:11 <saml> data Foo a = ....
06:42:19 <saml> can I add new data constructor for Foo ?
06:42:25 <saml> i can't modify source code of Foo.hs
06:42:27 <koeien> no
06:42:28 <alp_> after it's been declared ?
06:42:30 <alp_> no you can't
06:42:45 <saml> so if i get compiled library, how would i "extend" it?
06:42:47 <koeien> b_jonas: i don't get what you're saying
06:43:07 <saml> can i create XML and turn that into HaskellBean?
06:43:23 <koeien> Jonno_FTW: so (10^k - 1)/9 mod p = 0 iff 10^k - 1 = 0 mod p iff 10^k = 1 mod p. (For primes p /= 3)
06:43:55 <koeien> Jonno_FTW: now you want to know whether 10^k = 1 mod p, without actually computing 10^k first (this would be very memory-hungry). Can you think of a method?
06:44:31 <b_jonas> koeien: if you know that x is divisible by 9 and that (x `mod` 27 == y) then ((x / 9) `mod` 3 == y / 9)
06:45:07 <b_jonas> koeien: you can compute (10^k - 1) `mod` 27 the way you mentioned, and that way you can compute the quotient modulo 3
06:45:15 <koeien> ahw yeah, maybe. it's not necessary in this case, for the answer you can start at p = 5
06:45:52 <b_jonas> is this some projecteuler problem?
06:45:55 <koeien> yes
06:45:59 <b_jonas> or what was the original question?
06:46:07 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=132
06:46:19 <koeien> http://projecteuler.net/index.php?section=problems&id=132
06:46:38 <Jonno_FTW> we only need the primes between 11 and 9091 anyway
06:46:43 <koeien> why?
06:46:43 <b_jonas> ah, thanks
06:47:11 <b_jonas> don't you also need to check if any prime divides it twice?
06:47:28 <koeien> b_jonas: it's a little bit ambiguous
06:47:39 <koeien> i would think that you don't need to do that
06:48:10 <b_jonas> it says prime _factors_, not prime_ divisors, so I'd think you would need to
06:48:31 <Jonno_FTW> what's the difference between factors and divisors?
06:48:32 <koeien> well, yeah, "first" is also a bit strange. Why not "smallest"?
06:49:12 <koeien> b_jonas: in that case you would need to use a method like you suggested.
06:49:22 <b_jonas> koeien: point
06:49:45 <b_jonas> koeien: or just compute the remainders modulo p^2 in first place
06:49:57 <b_jonas> and change it to p^3 if it turns out there is a prime that divides it twice
06:50:39 <Jonno_FTW> i think i'll get some sleep and figure this out later
06:50:45 <koeien> it probably has lots of prime factors anyway
07:00:43 <c_wraith> it doesn't have any small prime factors...
07:02:07 <koeien37> why not? I would expect it to have lots of small prime factors
07:02:32 <c_wraith> I don't know why not...
07:02:40 <c_wraith> But it certainly doesn't.
07:03:19 <skorpan> does parsec 3 have anything built-in for parsing "whitespace-aware" languages?
07:04:05 <skorpan> i see that it has a lexer for haskell, but i can't find how it deals with indentation and such things
07:04:27 <b_jonas> whitespace is a character like anything else
07:04:49 <skorpan> b_jonas: well i have a made-up language which depends on the indentation of each line, pretty much like python works.
07:04:59 <c_wraith> Oh, hm.  It's taking forever just to calculate repunit
07:04:59 <skorpan> so "indent" is a token
07:05:03 <skorpan> so is "dedent"
07:05:31 <b_jonas> skorpan: so you want to produce those tokens with parsec?
07:05:37 <skorpan> b_jonas: yes
07:05:53 <b_jonas> skorpan: I guess you need to put the stack of earlier indent levels in the state you carry around in parsec
07:06:02 <skorpan> yes, that's exactly what i'm doing
07:06:18 <b_jonas> and you're asking if parsec 3 has something built in for that. I understand now.
07:06:23 <skorpan> :)
07:13:03 <b_jonas> koeien, c_wraith it has to have lots of prime factors, because for every n that divides 10^9, R(n) divides R(10^9), right?
07:13:28 <xerox> skorpan: you might try to encode the indentation in the stream? data IndentedStream a = Indent | UnIndent | Token a -- not sure if it really saves something
07:13:46 <b_jonas> so it has all the prime factors of R(10) and more
07:14:12 <c_wraith> b_jonas: yeah, the problem I was running into was calculating R(10^9) takes forever.
07:14:29 <c_wraith> I'm not sure why.
07:14:55 <c_wraith> does interpreted code do something dumb for Integer?
07:15:18 <b_jonas> well it's a huge number, isn't it?
07:15:53 <b_jonas> and even if it would fit your memory (which is possible these days), dividing it with all the small primes is probably much slower than doing all the modular exponentiations as koeien suggested
07:17:08 <dfdf> you don't even need to do all the modular exponentiations
07:18:14 <dfdf> just calculate the order
07:18:28 <EvilTerran> c_wraith, the ghci prompt is wholly un-optimised
07:19:44 <b_jonas> dfdf: maybe. it's probably not worth to write that code for just this projecteuler.
07:22:10 <dfdf> koeien : it pleases my perfectionist heart
07:32:47 <b_jonas> hmm
07:32:57 <b_jonas> I tried a solution but it's wrong according to project euler
07:33:31 <dfdf> .
07:33:40 <dfdf> oops
07:33:43 <b_jonas> I've got 683295
07:41:11 <b_jonas> oh, I found my error
07:42:20 <b_jonas> yep, I've got the right number now
07:42:23 <b_jonas> in two different ways
07:42:34 <b_jonas> well, two different implementations
07:42:41 <b_jonas> they're both just simple modular exponentiation
07:44:52 * hackagebot upload: network 2.2.1.6 - Networking-related facilities (JohanTibell)
07:48:26 <b_jonas> and indeed, it does not have a small prime dividing it twice
07:53:55 <pozic> Is it possible to send encrypted mail with also an encrypted subject?
07:55:17 <Botje> just put the subject inside the body?
07:55:28 <Botje> and put "Encrypted mail from XXX" as "normal" subject
07:56:09 <nazgjunk> There's no support for such a thing in the typical mail standards, no
07:56:38 <nazgjunk> Encryption really just was bolted on to those afterwards, unfortunately.
08:00:10 <jlouis> Axman6: oh, this is going to be fun to merge/rebase :)
08:00:29 <pozic> Botje: yes, but that doesn't integrate with normal functionalities in clients.
08:01:00 <pozic> I cannot underestimate the stupidity of whoever thought it was a good idea not to encrypt the subject.
08:01:06 <pozic> I read a whole discussion on it now.
08:01:25 <sinelaw> what's wrong here? newtype (RealFloat a) => VRDNode = VRDNode { shapeN :: Vector2 a }
08:01:35 <sinelaw> error: "Not in scope: type variable `a'"
08:01:41 <pozic> Basically there are the implementors who say "we need a standard, before we implement anything" and the users who way "this is trivial to do, and it doesn't matter how you do it".
08:01:45 <pozic> Real fun.
08:01:50 <PeakerWork> sinelaw: You should put "a" on the left of =
08:02:01 <PeakerWork> sinelaw: and the class context is not needed here, only in functions using this type
08:02:18 <PeakerWork> sinelaw: generally, in data/newtype, in left of =, there's no purpose/point to class contexts
08:02:37 <sinelaw> what's wrong here? newtype VRDNode = VRDNode { shapeN :: (RealFloat a) => Vector2 a }
08:02:38 <sinelaw> ?
08:02:45 <b_jonas> don't you mean newtype VRDNode a = ... ?
08:02:50 <sinelaw> oops, newtype VRDNode = VRDNode { shapeN :: (RealFloat a) => Vector2 a }
08:02:54 <b_jonas> or is it supposed to be a GADT or something?
08:02:57 <sinelaw> is that ok?
08:03:05 <sinelaw> b_jonas, it's a record, there are more fields
08:03:08 <b_jonas> I mean a higher-rank type or whatever
08:03:18 <pozic> sinelaw: or you miss a forall.
08:03:40 <b_jonas> and if it's higher-rank it can't even be newtype, can it?
08:03:54 <pozic> b_jonas: I don't see why not.
08:04:37 <b_jonas> pozic: well newtype is supposed to be so that it can be represented by its argument type
08:04:51 <PeakerWork> sinelaw: the "a" has to either be a parameter, or an existential.. it should probably be a type parameter
08:05:07 <b_jonas> a higher order newtype would be like a newtype with two arguments to its data constructor or like a newtype with more than one data constructors
08:05:20 <sinelaw> PeakerWork,  newtype VRDNode a = VRDNode { shapeN :: (RealFloat a) => Vector2 a } ?
08:05:31 <PeakerWork> sinelaw: No, get rid of the class context
08:05:40 <PeakerWork> sinelaw: the class context is not in the type decl. it should be in the functions using it
08:05:43 <PeakerWork> sinelaw: when they need it
08:05:48 <sinelaw> PeakerWork, right ok
08:06:15 <pozic> import Prelude
08:06:16 <pozic> newtype Bla = Bla (forall a. (Show a)=> a)
08:06:31 <pozic> This works. It has nothing to do with a standard, though.
08:06:44 <Saizan> that's a pretty useless type though
08:07:27 <Saizan> the only inhabitant is Bla undefined, since (forall a. (Show a)=> a) means that it's a polymorphic value
08:07:28 <pozic> Yes, it is like an envelope.
08:07:57 <Saizan> not even an envelope, you can't put anything in it
08:08:17 <Saizan> "data Bla = forall a. Show a => Bla a" would be an envelope
08:08:20 <pozic> You are right.
08:09:11 <pozic> A newtype constructor cannot have an existential context.
08:09:19 <pozic> That's what you get if you try anyway.
08:10:22 <b_jonas> sinelaw: http://erxz.com/pb/22282 shows it's not allowed
08:10:51 <b_jonas> it is allowed if you change the newtype to data
08:11:04 <sinelaw> b_jonas, never mind, i'll do what PeakerWork suggested
08:11:13 <sinelaw> newtype VRDNode a = VRDNode { shapeN :: Vector2 a }
08:11:20 <Saizan> yup, because existentials are implemented by storing the dictionary inside the constructor in GHC
08:11:30 <theorbtwo> Is there an idiom for foo 0 = False; foo _ = True, or should I just write that function?
08:11:39 <b_jonas> sinelaw: sorry, that was to pozic
08:11:46 <b_jonas> pozic: see above
08:12:14 <b_jonas> oh, you already found it
08:12:14 <b_jonas> I see
08:12:35 <osfameron> hi theorbtwo :-)
08:12:50 <PeakerWork> theorbtwo: (/=0) ?
08:13:04 <theorbtwo> Oh, hi, osfameron!
08:13:05 <b_jonas> that, yes
08:13:17 <b_jonas> that's basically what the pattern match expands to anyway
08:13:21 <b_jonas> (almost)
08:13:54 <osfameron> or:  not . (== 0)   ;-)
08:14:39 <theorbtwo> Hm.  Actually, in context, I think I'm better off just using testBit instead of (.&.)...
08:15:11 <b_jonas> so it's 'foo x = 0 == x;' ?
08:16:48 <PeakerWork> or: not . not . (/= 0) ;;)
08:18:41 <Twey> liftM2 (&&) (<= 0) (>= 0)
08:19:10 <Twey> Hmm… there's got to be some way to get that 0 out of there… :þ
08:19:12 <b_jonas> nah, that won't work for complexes
08:19:46 <Twey> liftM2 (liftM2 (&&)) (<=) (>=) $ 0
08:19:51 <Twey> b_jonas: Oh, yeah ☹
08:20:42 <PeakerWork> @type (/=) . getSum . mempty
08:20:46 <Twey> On the other hand… is 0 a Complex anyway?
08:20:46 <lambdabot> forall a (f :: * -> *). (Eq a, Monoid (f (Sum a)), Functor f) => f (a -> Bool)
08:21:01 <PeakerWork> @type (/=) . getSum $ mempty
08:21:03 <lambdabot> forall a. (Num a) => a -> Bool
08:21:13 <PeakerWork> no 0 :)
08:21:22 <Twey> Ahhh, there we go :þ
08:21:33 <Twey> What's this getSum?
08:21:43 <Twey> :t getSum
08:21:44 <lambdabot> forall a. Sum a -> a
08:21:49 <Twey> *headscratch*
08:21:57 <b_jonas> sure it is
08:22:02 <b_jonas> > 0 :: Complex Double
08:22:03 <lambdabot>   0.0 :+ 0.0
08:22:05 <b_jonas> > 3 :: Complex Double
08:22:06 <lambdabot>   3.0 :+ 0.0
08:22:09 <Twey> Oh, okay then
08:22:15 <Twey> I thought you had to define it as 0 :+ 0
08:22:15 <b_jonas> @type 0
08:22:16 <lambdabot> forall t. (Num t) => t
08:22:36 <PeakerWork> Twey: Sum is a newtype for Num's with a Monoid instance (0,(+))
08:22:48 <PeakerWork> Twey: Product is the same for (1,(*))
08:22:52 <Twey> PeakerWork: Oho
08:23:06 <PeakerWork> > mconcat [Sum 1, Sum 2]
08:23:07 <lambdabot>   Sum {getSum = 3}
08:23:14 <PeakerWork> > mconcat [Product 1, Product 2]
08:23:15 <lambdabot>   Product {getProduct = 2}
08:23:22 <b_jonas> > genericLength 0
08:23:23 <lambdabot>   No instance for (GHC.Num.Num [b])
08:23:23 <lambdabot>    arising from the literal `0' at <inter...
08:23:26 <b_jonas> > genericLength []
08:23:27 <lambdabot>   0
08:30:45 <EvilTerran> 0 = fromInteger (0 :: Integer)
08:32:14 <Twey> EvilTerran: Yes, I just forgot that Complex a is a Num :þ
08:45:58 <Jafet> What's a very terse programming language? I can think of the APL family, but no others come to mind
08:47:10 <Stinger> what do you mean by terse?
08:47:38 <Jafet> You can write line noise in it
08:47:44 <Jafet> High entropy density
08:48:13 <Stinger> oh well by that definition, surely perl?
08:48:16 <Jafet> And no, I doubt perl comes close to APL
08:48:28 <Jafet> It has keywords.
08:50:00 <b_jonas> haskell is dense too
08:50:01 <b_jonas> really
08:50:26 <Twey> Yeah
08:50:28 <Twey> FORTH is pretty dense
08:50:40 <Stinger> I was gonna suggest forth
08:50:55 <SamB_XP> that's because Haskell has abstracted recursion patterns
08:51:37 <Twey> Aye
08:51:43 <Twey> FORTH can do that too, though
08:52:06 <b_jonas> haskell wins in longer programs, apl wins in shorter stuff
08:52:07 <Mathnerd314> Jot or some other esoteric language (every bit string is a valid program)
08:52:07 <SamB_XP> also laziness
08:52:09 <Stinger> not really knowing forth, isn't that the poing of FORTH?
08:52:11 <b_jonas> in length
08:52:23 <Stinger> you have to build the abstractions yourself to do anything?
08:52:46 <Twey> Stinger: Well, that kind of applies to any programming language
08:52:56 <SamB_XP> that, I think, lets the abstracted recursion patterns do a good deal more ?
08:53:02 <Jafet> Three cheers for this router
08:53:10 <Jafet> Did I miss the party
08:53:23 <b_jonas> but ruby and smalltalk are also quite dense because of the nice standard library
08:53:24 <SamB_XP> mine could use some cheers, too, I think
08:53:39 <SamB_XP> it must be depressed -- it keeps rebooting for no apparent reason
08:53:43 <b_jonas> in shorter programs, ruby gets denser than perl, but it also gets hard to write and ugly for longer programs
08:54:34 <Jafet> .oO( Hm, is APL nonexistent in this channel...? )
08:54:48 <b_jonas> Jafet: yes, they kick me if I try to show any apl code
08:54:54 <Twey> Haha
08:54:59 <Twey> I want to see some APL code!
08:54:59 <SamB_XP> b_jonas: hmm, really ?
08:55:02 <SamB_XP> try me!
08:55:03 <|Jedai|> Well you already spoke of APL
08:55:04 <Twey> It's on my to-learn list.
08:55:09 <SamB_XP> I wanna see if my fonts are up to it ;-)
08:55:27 <b_jonas> well not literally kick, but get very angry
08:55:33 <|Jedai|> I must say the concept is interesting, the realisation is perfectly unreadable :)
08:55:34 <b_jonas> I usually stop before they'd really kick me
08:55:41 <SamB_XP> b_jonas: who gets angry ???
08:55:48 <SamB_XP> (what encoding do you use ?)
08:56:00 <Jafet> UTF-8!
08:56:10 <|Jedai|> J ?
08:56:12 <b_jonas> nah, I just write J and it's ascii so the encoding doesn't matter
08:56:15 <SamB_XP> if you use an EBCDIC variant, well, duh they don't like that ...
08:56:29 <SamB_XP> b_jonas: that's not quite the same as APL, I think ;-P
08:56:38 <b_jonas> SamB_XP: sure, it's better than apl
08:56:45 <Jafet> Well, out with it. I'm interested in designing a data encoding that uses a programming language as the encoding
08:56:50 <LISPersAnonymous> Ken Iverson authored a language named 'J' after APL that didn' need special keys. It has seen a bit of use in the quant community.
08:56:51 <b_jonas> it knows everything you'd want to write in apl
08:56:53 <b_jonas> and more
08:57:22 <SamB_XP> LISPersAnonymous: yeah, I think most of us are aware of the general idea of J ;-)
08:57:31 <LISPersAnonymous> :-)
08:57:50 <Mathnerd314> I don't like J. Too verbose.
08:58:06 <b_jonas> depends on what you use it for
08:58:09 <SamB_XP> what I don't like is how the parsing is dynamic ...
08:58:12 <b_jonas> I use J only for short stuff
09:00:49 <b_jonas> the bigger problem with J imo is not how is's completely dynamic but how it doesn't have lexical scope
09:01:39 <Jafet> Woah, APL has scope now..?
09:01:56 <b_jonas> Jafet: it always had dynamic locals
09:02:36 <b_jonas> or didn't it?
09:02:46 <b_jonas> anyway, "modern" apl has had dynamic locals
09:02:48 <b_jonas> and J certainly does
09:02:59 <Jafet> "lexical scope" sounds like someone wants it to have a block structure now
09:03:24 <b_jonas> well it could have lambdas
09:03:34 <Mathnerd314> Ursala might have high entropy.
09:04:32 <Jafet> Hm, the website examples look promising
09:04:55 <b_jonas> what website what example?
09:05:19 <Jafet> http://www.basis.uklinux.net/ursala/blip.fun
09:05:33 <Jafet> Even the library names are abbreviated
09:06:13 <b_jonas> Jafet: everyone but haskell uses abbreviated names
09:06:30 <b_jonas> haskellers reserve them for the really abstract stuff only
09:06:40 <b_jonas> the more general something is, the shorter name it gets
09:06:41 <hooopy> does haskell have namespaces?
09:06:49 <hooopy> or is everything jammed into a global scope?
09:07:09 <Beelsebob> hooopy: it has Modules
09:07:11 <Beelsebob> which are similar
09:07:21 <Beelsebob> and local variable scoping within functions ofc
09:07:29 <Jafet> Maybe I should look into Joy
09:07:38 <b_jonas> which one is joy?
09:07:54 <b_jonas> wasn't it some forth-alike or smalltalk-alike?
09:08:25 <b_jonas> forth, google says
09:08:56 <b_jonas> this irc server has some forthers over there in #concatenative or something like that
09:09:41 <Jafet> Heh, a channel for a language *genre*
09:11:35 <gwern> http://hackage.haskell.org/trac/ghc/ticket/2143#comment:11 hurray!
09:12:11 <gwern> victory jig everyone. there are >1k uses of 'sort' out there and now they're all 20-100% as fast
09:13:38 <Jafet> I wonder what algorithms these library writers use
09:13:53 <Jafet> I've read about a dozen recent sorting papers
09:14:16 <Jafet> Twisty little permutation of algorithms, all alike
09:15:39 <Mathnerd314> ...until quantum computing makes the question academic.
09:16:07 <Jafet> Quantum computing is the academic question
09:16:59 <Mathnerd314> you mean *the* academic question?
09:17:07 <gwern> Jafet: see the ndm post
09:17:32 <gwern> Jafet: it's a mergesort with checks for being already sorted, I think
09:18:06 <Twey> gwern: Wey-hey!
09:18:20 <gwern> ok!
09:19:13 <Jafet> Wait, the attached code is the ghc implementation?
09:19:29 <gwern> Jafet: it's both, depending on which attachment you refer to
09:19:30 <dolio> The GHC sort used to, I think, just start with a list of singletons and merge them.
09:19:49 <dolio> The YHC sort starts with nondecreasing/nonincreasing sections of the list.
09:19:52 <gwern> for my next trick, I will bring us Control.Monad.ignore and Network.URI.escape
09:19:55 <Jafet> Ah, the theoretical elegance of mergesort
09:20:52 <Twey> gwern: What is Control.Monad.ignore?
09:21:01 <gwern> Twey: IO a -> IO () basically
09:21:10 <gwern> good for what ails ya (with forkIO esp)
09:21:15 <Twey> So (>> return ())?
09:21:23 <Twey> :t void
09:21:24 <lambdabot> Not in scope: `void'
09:21:26 <Twey> Hm
09:21:35 <portnov> :t ()
09:21:36 <lambdabot> ()
09:21:36 <Twey> There used to be a function somewhere called ‘void’ that did that
09:21:54 <Twey> But it's a symptom of a deeper problem, namely unnecessarily specific types…
09:21:59 <b_jonas_> @hoogle void
09:21:59 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
09:22:05 <Twey> Ah, that's the one
09:22:52 <gwern> but in the wrong place, and with too narrow a type sig
09:23:01 <gwern> we could boost it all the way up to functor
09:23:20 <Twey> fmap (const ())
09:23:21 <Twey> Mm
09:23:46 <Jafet> :t fmap (const())
09:23:47 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
09:24:13 <Jafet> Can't think of any use outside IO though
09:24:24 <Twey> Can't think of any real use inside IO
09:24:40 <b_jonas_> @t (()<$)
09:24:40 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:24:42 <monochrom> @type forkIO
09:24:42 <Twey> Apart from as a hackish workaround for things that say () when they mean a
09:24:43 <b_jonas_> @ttype (()<$)
09:24:43 <lambdabot> Not in scope: `forkIO'
09:24:43 <Jafet> Knowing IO, one will be invented
09:24:44 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
09:24:49 <b_jonas_> @type (()<$) -- argh
09:24:50 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
09:25:37 <Jafet> forkIO isn't standard Haskell, is it
09:25:47 <Twey> Nope, it's from Concurrent Haskell
09:26:18 <gwern> Jafet: parsing is a use for ignore
09:26:33 <Twey> gwern: Why?
09:26:41 <gwern> and it's useful in IO for deliberately discarding results, although most obviously used with forkIO
09:26:47 <gwern> Jafet: I forget, ask john meachem
09:26:54 <b_jonas> but forkIO is essential in that if there was no concurrency supported I wouldn't try to learn haskell probably
09:27:05 <Jafet> Ok, once I find out who john meachem is
09:27:20 <conal> i've used 'fmap (const ())' a fair bit in Reactive
09:27:35 * hackagebot upload: reactive 0.11.4 - Push-pull functional reactive programming (ConalElliott)
09:27:50 <b_jonas> (()<$) looks like an emoticon
09:27:56 <conal> oh, weird coincidence.  i started a 'make release' about 5 minutes ago.
09:28:16 <conal> trivial update. paper ref and gpl comment.
09:28:24 <b_jonas> gwern: point
09:28:35 <monochrom> if b then getLine else putStrLn "bye"
09:29:35 <monochrom> This is erroneous. Adding >>return() or ignore to the then branch fixes it.
09:31:44 <Twey> Hmmm
09:32:03 <Twey> It seems there should be some way to treat the whole if as an IO a
09:32:49 <Twey> I.E. generalise to the lowest common denominator of the branches
09:33:12 <b_jonas> no. just be explicit there and add the ()<$
09:33:43 <b_jonas> you don't just ignore values implicitly, we're not an untyped procedural language
09:35:30 <Baughn> b_jonas: "do getLine; putStr "ignored!""
09:36:10 <Baughn> If (>>) :: Monad m => m () -> m a -> m a, you'd have a (better) point
09:37:34 <b_jonas> Baughn: yep, and ghc actually has an option to warn about that kind of ignoring (if you do it with do notation, not >>)
09:37:54 <Baughn> -Wall?
09:37:58 <Baughn> Hm. No.
09:38:07 <b_jonas> dunno, can't find it in the manual now
09:38:09 <b_jonas> searching
09:38:31 * Baughn wishes -Wall would stop warning me about top-level bindings without types that I also don't export
09:38:39 <b_jonas> I only remember they say the workaround is do { _ <- getLine; ...
09:38:52 <Baughn> ..I know what I'm doing, haskell, and I don't feel like typing in that three-line type.
09:39:31 <b_jonas> -fwarn-unused-do-bind
09:39:58 <b_jonas> sure, it's optinal, they can't just change >> to have type :: m () -> m a -> m a now
09:40:27 <theorbtwo> Baughn: :load, :t in ghci, copy-and-paste once, and you're done.
09:40:36 <Baughn> theorbtwo: And then I change the function.
09:40:41 <Baughn> Type inference is great. I want to use it more.
09:40:47 <theorbtwo> Baughn: And break your API?
09:40:54 <b_jonas> yep, works
09:41:00 <Baughn> theorbtwo: I mentioned it isn't exported. It isn't part of the API.
09:41:03 <monochrom> "I also don't export"
09:41:05 <theorbtwo> (Though I suppose it's not bad if your new type is a superset of your old type.)
09:41:10 <b_jonas> after ':set -fwarn-unused-do-bind', 'do { getLine; putStrLn "ignored!"; }' gives a warning but works in ghci
09:41:11 <theorbtwo> Baughn: Oh.  Good point.
09:41:21 <monochrom> (Why is reading so hard?)
09:41:32 <monochrom> (It was not even on a different line.)
09:41:35 <Baughn> Oh, and loading .hsc files in ghci is inconvenient. Anyone know how to make it run hsc2hs implicitly?
09:41:59 * gwern wonders if a good application of criterion to http://hackage.haskell.org/trac/ghc/ticket/1473 would help
09:42:20 <Baughn> criterion should be part of the ghc test package. :)
09:42:21 <monochrom> Next time I will change "people behave like their scrollback buffer has just 5 lines" to "people behave like their scrollback buffer has just 5 words".
09:42:30 <Baughn> Make it automatically tell devs when they slow something down
09:42:39 <b_jonas> did someone write an equivalent to my ghcidecl thingy that works in ghci 6.12.1 ? (it allows you to type arbitrary declarations including data or import as in the ghci prompt)
09:42:46 <b_jonas> I'd like one
09:42:58 <b_jonas> and mine's broken, it only works in 6.10
09:43:02 <Baughn> b_jonas: I think we're all waiting for you to fix it
09:43:11 <b_jonas> nah, I don't think I can
09:43:23 <b_jonas> ghci has changed so that hack doesn't work anymore
09:43:27 <gwern> Baughn: seems hard to do. thorough tests are very slow. my sort tests took 2 and a half hours to run
09:43:41 <b_jonas> it was actually a small miracle that it worked in ghci 6.12
09:43:46 <b_jonas> s/6.12/6.10/
09:43:47 <Baughn> gwern: I mean, have a "make benchmark" to go with "make test"
09:44:10 <Baughn> Or better yet, a benchmark-bot machine somewhere
09:44:42 <Baughn> It could detect slowdowns over 5% from the best result, then automatically bisect ghc to figure out which patch did it..
09:44:48 <Baughn> It'd be an exciting program to write
09:45:19 <b_jonas> lol
09:46:14 <Baughn> I'm not really kidding.
09:46:19 <lowki> Baughn: ya, sounds great
09:46:27 <theorbtwo> Hm.  perl5-porters, IIRC, did something similar for a while.  I can't remember why it didn't catch on.
09:46:28 <lowki> kinda like the language i'm designing
09:46:31 <lowki> with inbuilt AI
09:46:37 <theorbtwo> Baughn: If it sounds exciting, by all means, do it.
09:46:38 <lowki> it's also operating system
09:46:48 <gwern> Baughn: sounds like the usual buildbot system though
09:46:51 <Heffalump> benchmarking tends to be very noisy
09:46:52 <Baughn> lowki: Oh, you're cloning Emacs?
09:46:55 <gwern> probably could use nobench
09:46:56 <Heffalump> so you'll get lots of false alarms
09:47:08 <gwern> Heffalump: isn't that what criterion is for?
09:47:12 <Jafet> emacs' idea of AI is eliza
09:47:12 <lowki> Baughn: no, human speakable
09:47:23 <gwern> detecting system resolution, running many times, and doing that bootstrapping thing to detect variance issues
09:47:27 <Heffalump> I guess so, but it does burn a lot of CPU to get its results
09:47:31 <b_jonas> lowki: some people tried that. it never worked. cobol, applescript, etc.
09:47:36 <b_jonas> but good luck.
09:47:48 <lowki> Baughn: thanks :)
09:47:49 <Baughn> lowki: Emacs was originally based on a south-american dialect known as "Lifpth".
09:48:08 <lowki> ctrl never entered human speech
09:48:23 <Jafet> With sister dialects such as "McLifpth"
09:48:27 <lowki> i dono emacs, i'm a vim user
09:48:31 <Baughn> lowki: You need to pronounce it right
09:48:36 <Baughn> ..anyway, it's "C-" in emacs
09:48:49 <lowki> i dono :|, really
09:48:59 <lowki> emacs is a domain i haven't pierced
09:49:49 <gwern> was there a LANGUAGE pragma we need to use ffi import?
09:49:50 <lowki> mainly studied mythology, religion, linguistics, science, math, to merge language into one language for all applications
09:50:02 <Baughn> gwern: Foreign..interface
09:50:08 <gwern> ?
09:50:09 <lowki> howto's books..
09:50:11 <Baughn> Um, but was it LANGUAGE?
09:50:18 <theorbtwo> Could pretty easily keep running the benchmark until you are 95% confident of the value within +/- 3%, and only call it bad if the numbers have gone up by 5%.
09:50:19 <lowki> ya, english mainly
09:50:28 <theorbtwo> (Assuming you have lots of CPU to throw around...)
09:50:30 <Baughn> gwern: {-# LANGUAGE ForeignFunctionInterface #-}
09:50:33 <gwern> ah
09:51:01 <paulvisschers_> I got the new GHC, and now my cabal-install is broken
09:51:44 <Baughn> paulvisschers_: Update to 0.8
09:51:53 <paulvisschers_> it says to install using cabal install cabal-install, but then I get an "cabal: failed to parse output of 'ghc-pkg dump'" error
09:52:53 <paulvisschers_> Baughn: Is there a faster way to do that than manually downloading and installing all packages and dependencies?
09:53:41 <b_jonas> paulvisschers_: yes, manually install the new version of cabal first, then use that to install everything else.
09:53:57 <b_jonas> just a guess though
09:53:59 <b_jonas> I haven't tried
09:55:21 <Baughn> paulvisschers_: There should be a bootstrap.sh script in the tarball
09:56:11 <paulvisschers_> Baughn: A thanks, that's a huge timesaver
09:56:31 <paulvisschers_> Baughn: Silly I didn't remember that from last time :)
10:05:34 <jmillikin> Is anybody else having trouble installing the new template-haskell package? I get an error about an unknown constructor CharConstr.
10:10:35 <Saizan> jmillikin: you don't install a template-haskell package, you've to stick with the one that comes with your ghc
10:10:41 <Saizan> jmillikin: are you trying to install yi?
10:10:52 <jmillikin> Saizan: no, I'm trying to install criterion
10:11:33 <gwern> @hoogle [a] -> Bool
10:11:33 <lambdabot> Prelude null :: [a] -> Bool
10:11:34 <lambdabot> Data.List null :: [a] -> Bool
10:11:34 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
10:12:18 <gwern> > foldr (==) True [True, True, True]
10:12:18 <lambdabot>   True
10:12:20 <Saizan> jmillikin: try with --constraint="data-accessor-template < 0.2.1.2" --constraint="data-accessor < 0.2.1"
10:12:22 <gwern> > foldr (==) True [True, True, False]
10:12:23 <lambdabot>   False
10:13:34 <jmillikin> Ah, that's working, thanks.
10:14:11 <saml> hey how can I get an element from a list that is before the first element that satisfies pred?
10:14:18 <gwern> > foldr (==) False [False, False, False]
10:14:18 <lambdabot>   True
10:14:24 <saml> thanks
10:17:05 <Botje> saml: zip the list with its tail first.
10:17:25 <saml> Botje, thanks
10:17:36 <gwern> > foldr (==) False [False, False]
10:17:37 <lambdabot>   False
10:17:41 <gwern> what
10:18:00 <gwern> oh
10:18:01 <gwern> dammit
10:18:04 <pikhq> (False == False) == False -> True == False -> False
10:18:07 <xerox> (False == False) == False
10:18:11 <gwern> pikhq: yeah yeah, I see now
10:18:49 <xerox> > not . or [False,False]
10:18:51 <lambdabot>   Couldn't match expected type `f GHC.Bool.Bool'
10:18:51 <lambdabot>         against inferred typ...
10:19:10 <gwern> xerox: the idea is to see whether the list is made of either all Trues or all Falses
10:19:16 <xerox> ah!
10:19:26 <gwern> there are several obvious solutions to me, but the elegant ones aren't coming
10:19:27 <jmillikin> > all (== False) [False, False, False]
10:19:28 <lambdabot>   True
10:19:35 <xerox> ?type any . (/=)
10:19:55 <xerox> zZzZ
10:19:58 <kmc_> :t any . (/=)
10:19:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:20:02 <kmc_> :t any (/=)
10:20:04 <lambdabot>     Couldn't match expected type `Bool'
10:20:04 <lambdabot>            against inferred type `a -> Bool'
10:20:04 <lambdabot>     In the first argument of `any', namely `(/=)'
10:20:19 <kmc_> > any . (/=)
10:20:20 <lambdabot>   {()->{[]->False;[()]->False;[(),()]->False;[(),(),()]->False}}
10:20:27 <gwern> > all (==True) [True, True, True]
10:20:28 <lambdabot>   True
10:20:30 <xerox> must decompose the list..
10:20:32 <kmc_> > any . (/=) :: Bool -> [Bool] -> Bool
10:20:33 <lambdabot>   True->
10:20:33 <lambdabot>    []->
10:20:33 <lambdabot>      False
10:20:33 <lambdabot>    [True]->
10:20:33 <lambdabot>      False
10:20:35 <lambdabot>    [True,True]->
10:20:37 <lambdabot>      Fals...
10:21:14 <bgs100> Why is it that there is, for example, a typeclass for equality, for things that could be equated, but not for things that, for example, could be added?
10:21:35 <kmc_> bgs100, (+) lives in the typeclass Num
10:21:35 <pikhq> bgs100: Num
10:21:46 <kmc_> but the numerical hierarchy should in fact be more fine-grained
10:21:51 <xerox> :t any =<< ((/=) . head)
10:21:52 <lambdabot> forall a. (Eq a) => [a] -> Bool
10:21:57 <bgs100> Oh.
10:22:03 <jmillikin> The problem with Num is that it has too much stuff in it
10:22:09 <kmc_> i like the idea of reworking that, and also adding context synonyms to the language, and preserving backwards compatability that way
10:22:12 <xerox> gwern: that breaks on empty lists though
10:22:15 <jmillikin> (+) :: Set -> Set -> Set make sense, but can't reasonably exist
10:22:22 <gwern> xerox: good thing I use none
10:22:39 <xerox> look carefully at the end of your lists, I see some!
10:23:05 <pikhq> xerox: Let him use _|_ with abandon, man. Some are just into that. :P
10:23:41 <gwern> it's a fixed list of tests!
10:23:49 <gwern> space_props :: Char -> Bool
10:23:49 <gwern> space_props x = all (== gspace x) [yspace x, gspace' x]
10:24:13 <gwern> first I quickcheck for correctness, and then when I have a bunch of avriants on isSpace and they all agree, I run criterion
10:24:40 <gwern> ack. hoogle is dead. does CInt cover the same range as Int?
10:24:40 <clarkb> gwern: xerox was pointing out that all lists are constructed on top of the empty list :)
10:24:43 <xerox> good
10:25:07 <xerox> > maxBound :: CInt -- will it float?
10:25:08 <jmillikin> gwern: IIRC, CInt might have a larger range.
10:25:08 <lambdabot>   Not in scope: type constructor or class `CInt'
10:25:40 <gwern> they're teh same here
10:25:52 <gwern> but I don't know if maxBound::Int == maxBount::CInt everywhere
10:26:32 <jmillikin> For me, maxBound :: Int > maxBound :: CInt
10:26:43 <clarkb> according to http://www.haskell.org/haskellwiki/FFI_Introduction they arent
10:26:51 <jmillikin> 9223372036854775807 > 2147483647
10:30:29 <tromp__> > 2*2147483648*2147483648-1
10:30:30 <lambdabot>   9223372036854775807
10:37:09 * BMeph is too scared to get a working 64-bit version of GHC for his 64-bit machine...
10:37:25 <rwx> MoALTz, "# kmc: Data.Map is like a C++ STL map<k,v>, without the suck"
10:37:25 <jmillikin> You don't need to, just install a 64-bit version in virtualbox for testing.
10:37:34 <rwx> MoALTz, from http://sequence.complete.org/hwn/20091219
10:37:39 <rwx> er
10:37:42 <rwx> yes
10:37:45 <rwx> sorry guys
10:39:58 <Saizan> BMeph: OS X?
10:53:28 <mjrosenb> does hugs not support heirchal modules?
10:54:09 <Heffalump> I'm sure recent hugs do
10:54:30 <kmc_> don't hugs and ghc share much of the std lib code?
10:55:30 <mjrosenb> ERROR "./Ast.hs" - Can't find imported module "System.FilePath"
10:55:41 <mjrosenb> well, they aren't sharing *something*
10:56:10 <kmc_> hmm, do you need some equivalent of GHC's -package?
10:59:16 <mjrosenb> also, wow
10:59:23 <mjrosenb> hugs last updated in 2006
10:59:40 <kmc_> yup
11:00:27 <kmc_> i don't know a current use case for hugs, though there probably is one
11:00:38 <mjrosenb> maybe during this break, I will try to get ghci running
11:00:45 <kmc_> perhaps for portability
11:00:50 <mjrosenb> kmc_: it gives a repl on systems where ghc can not
11:00:54 <kmc_> in that respect it would be nice if hugs could run ghc for bootstrapping
11:00:58 <kmc_> mjrosenb, which systems are those?
11:01:04 <kmc_> ppc mac?
11:01:07 <mjrosenb> kmc_: ppc64-linux
11:01:11 <kmc_> ah
11:01:30 <mjrosenb> i have found that in general *nothing* works the way you want it to
11:02:02 <kmc_> :/
11:03:47 <mjrosenb> also, seems like hugs10 should be released at some point or other
11:05:43 <ACSpike[Home]> how can I tell if a library call produces a list lazily or if it materializes the whole thing?
11:06:56 <bd_> ACSpike[Home]: Read the library source?
11:07:11 <bd_> It's invisible to the calling code - that's the whole point :)
11:07:13 <lament> ACSpike[Home]: you could get the list, and then profile the time it takes to get to its last element
11:07:44 <BMeph> Saizan: Nothing so dev-friendly; this box runs Vista. (=:O)
11:08:05 <ACSpike[Home]> I realize is should be transparent, just wondering if there was some way to instrument it and see in from the outside (some sort of profiler I guess)
11:08:25 <kmc_> vacuum
11:09:11 <ACSpike[Home]> visualize with cairo
11:09:28 <kmc_> or opengl or dot etc.
11:09:43 <kmc_> the base "vacuum" package gives you an API to extract heap structure
11:10:13 <BMeph> "Obviously" that can never work correctly, since your observing it collapses the superposition of laziness. ;)
11:11:14 <gwern> ah, finished my criterion benchmark!
11:11:17 <kmc_> also, remember that the laziness of the spine of the list is a separate issue from the laziness of the contents
11:11:21 <gwern> now to let it run for 4 or 6 hours :)
11:11:30 <EvanR> heh. are we making analogies between QM and lazy evaluation ;)
11:12:14 <gwern> EvanR: well, Quantum programming languages are very well suited to haskell
11:12:16 <gwern> why there are so many
11:13:18 <Axman6> they are?
11:14:50 <gwern> Axman6: well, there are so few that 2 or 3 in haskell counts as a lot :)
11:15:19 <Axman6> heh
11:18:27 <Axman6> i guess laziness maps fairly well onto quantum computing
11:26:16 <trofi> ladies and gentlemen! I'm happy to share micropatches for lambdabot against ghc6.12 and cabal-1.8 : http://code.haskell.org/~slyfox/lb-ghc6.12-cabal1.8.dpatch
11:26:49 <trofi> wold not be too bad to release relevant packages on hackage as users stuck on installation failures
11:33:06 <Axman6> trofi: good work
11:35:54 <eugenn> @pl estaOrdenada' (x:xs) = all (\(a,s) -> a < s) (zip (x:xs) xs)
11:35:54 <lambdabot> estaOrdenada' = ap ((all (uncurry (<)) .) . join . (zip .) . (:) . head) tail
11:35:58 <jlouis> Axman6: quantum computing is quite different from traditional computing
11:36:08 <Axman6> indeed
11:36:28 <Axman6> hey what do you think of the changes i've made by the way?
11:36:36 <jlouis> Axman6: My guess is that you have a traditional computer with a "Quantum Board"
11:36:51 <jlouis> Axman6: I have not looked at them in detail yet.
11:37:14 <jlouis> Axman6: I tried to merge them, but we are currently somewhat conflicting, so I'll have to fix that :)
11:37:20 <Axman6> there's a fairly large number of small changes, so it might be a lot to take in
11:37:27 <Axman6> heh :)
11:37:44 <jlouis> I got through the first patch with a rebase
11:40:15 * Axman6 doesn't know what that means, but senses more git nonsense and just accepts it
11:40:45 <Axman6> jlouis: did you see i managed to get a fairly nice BCode parser working using cereal?
11:41:06 <Axman6> (which i think has replaced binary as my favourite binary package)
11:41:21 <jlouis> Axman6: yeah, that was the patch after the one where I stopped reading though, so not yet :)
11:41:31 <Axman6> heh
11:43:12 <chrisdone> :t runLogic
11:43:13 <lambdabot> forall a r. Logic a -> (a -> r -> r) -> r -> r
11:45:55 <CalJohn> @src zip
11:45:55 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:45:55 <lambdabot> zip _      _      = []
11:46:26 <CalJohn> what is the "right" way to import the prelude but exclude zip?
11:46:45 <Botje> import Prelude hiding (zip)
11:46:47 <kmc_> import Prelude hiding (zip)
11:46:50 <kmc_> damn
11:47:19 <kmc_> if you import Prelude explicitly it takes the place of the implicit import
11:47:32 <CalJohn> ah, i see
11:53:19 <BMeph> @pl estaOrdenada' xs = and (zipWith (<) xs (drop 1 xs))
11:53:19 <lambdabot> estaOrdenada' = and . ap (zipWith (<)) (drop 1)
11:56:26 <eugenn> @ pl isSorted (x:xs) = fst (foldl (\(b,a) s -> (b && (a < s),s)) (True,x) xs)
11:56:38 <eugenn> @pl isSorted (x:xs) = fst (foldl (\(b,a) s -> (b && (a < s),s)) (True,x) xs)
11:56:39 <lambdabot> isSorted = ap ((fst .) . foldl (uncurry (flip flip id . (liftM2 (,) .) . (. (<)) . (.) . (&&))) . (,) True . head) tail
11:57:41 <trofi> @pl \(a,b,c) -> (c,b,a)
11:57:41 <lambdabot> (line 1, column 6):
11:57:41 <lambdabot> unexpected ","
11:57:41 <lambdabot> expecting letter or digit, operator or ")"
11:57:41 <lambdabot> ambiguous use of a non associative operator
11:58:05 <trofi> wut?
11:58:24 <Twey> Truly
11:58:26 <dolio> pl doesn't do triples.
11:58:36 <eugenn> @pl (\(a,b) -> (b,a))
11:58:36 <lambdabot> uncurry (flip (,))
12:00:49 <c_wraith> pl can't do triples, since there's no standard fuunctions to extract values from them.
12:01:27 <dolio> It could just make them up, like it does with if'
12:01:54 <b_jonas> let's just call it bool, not if'
12:02:01 <b_jonas> if' is such a wierd name
12:02:07 <trofi> yup
12:02:13 <trofi> like strict if
12:02:40 <Twey> (y ?? n) p = if p then y else n
12:03:44 <c_wraith> @pl \a -> (a,a,a)
12:03:44 <lambdabot> join (join (,,))
12:04:12 <jfischoff> Does anyone know if there is a Haskell 3D graphics mailing list?
12:04:27 <jlouis> Axman6: if I merge your changes, can we then get some rather nice basepoint to work from?
12:04:44 <jlouis> Otherwise git management becomes pain :)
12:10:05 <increpare> jfischoff: there is a mailing list along those lines
12:10:15 <increpare> lemme check
12:10:28 <jfischoff> increpare: sweet
12:10:47 <increpare> jfischoff: there is a hopengl mailing list
12:10:57 <increpare> though it's not *stumpendously* active
12:11:14 <jfischoff> yeah
12:11:35 <increpare> jfischoff: you doing 3d stuff at the moment?
12:11:48 <jfischoff> increpare: Yep, as we speak
12:11:57 <increpare> jfischoff: cool; whatcha doing?
12:12:16 <jfischoff> increpare: prototype a new avatar system for the company I work at
12:12:39 <jfischoff> increpare: I'm working on 3d compression
12:12:59 <jfischoff> increpare: Are you interested in 3D
12:13:00 <increpare> jfischoff: ah, cool
12:13:40 <increpare> jfischoff: yes I am : ) was supposed to spend today tinkering about with opengl stuff, but got stuck doing other things
12:14:26 <jfischoff> increpare: cool. OpenGL in Haskell is annoying
12:14:39 <jfischoff> increpare: I wish there was a pure way to render images
12:14:41 <increpare> jfischoff: I actually find it pretty pleasant (in that it's idiomatic enoguh, as wrappers go)
12:14:58 <jmcarthur> jfischoff: there is!
12:15:04 <jfischoff> increpare: really?
12:15:16 <jfischoff> increpare: do tell
12:15:21 <jmcarthur> jfischoff: they just aren't very full featured
12:15:41 <increpare> jfischoff: fieldtrip is suppoed to be functional enough, innit?
12:15:43 <jfischoff> jmcarthur: fine with me
12:15:54 * increpare admittedly i haven't tried it
12:15:56 <increpare> ( http://www.haskell.org/haskellwiki/FieldTrip )
12:16:01 <jfischoff> increpare: I think field trip uses opengl
12:16:17 <increpare> jfischoff: right, but it's a functional wrapper on top of that.
12:16:42 <conal> increpare: yes.  fieldtrip has purely functional/simple semantics.  no IO semantics peeks through.
12:16:45 <jfischoff> increpare: that's not what I want
12:16:58 <increpare> jfischoff: what did you mean?
12:17:05 <jfischoff> increpare: I need to right tests against images.
12:17:17 <increpare> oh
12:17:17 <increpare> hah
12:17:25 <increpare> jfischoff:  : P
12:17:41 <jfischoff> increpare: I need Mesh -> Image function
12:17:42 <increpare> jfischoff: I've never tried rendering to surface, but surely it shouldn't be that horrible?
12:18:17 <increpare> (in sdl at least it's totally possible)
12:18:28 <jfischoff> increpare: you mean like a graphics card surface for a screen grab?
12:18:50 <increpare> jfischoff: yeah: that wouldn't work?
12:19:17 <jfischoff> increpare: it works.
12:19:40 <jfischoff> increpare: I'm using readpixels right now
12:19:46 <increpare> oh right , here's where purity come in
12:19:50 <increpare> I follow now
12:20:31 <jfischoff> increpare: yeah, I want to use quickcheck more for my tests. I probably still can but its much more complicated then necessary
12:20:31 <increpare> you could do a wrapper if you wanted i ugess, but each function call would have to have its own context
12:21:06 <jfischoff> increpare: as a community I think we just need our own renderer
12:21:16 <increpare> jfischoff: : )
12:21:25 <jfischoff> jfischoff: :)
12:21:34 <Absolute0> How can I print a number in binary representation?
12:21:38 <jfischoff> increpare: we are not far away.
12:21:49 <increpare> jfischoff: I wouldn't turn my nose up as a sleek and snazzy pure software renderer
12:22:08 <jfischoff> increpare: ?
12:22:35 <increpare> jfischoff: by which I mean: one written in haskell.  I'm not sure how else we might need a renderer?
12:22:41 <merehap> due to a typo, it appears we have our community renderer! thanks for signing up increpare :)
12:23:03 <increpare> a hah hah hah
12:23:05 <increpare> >_<
12:23:07 <increpare> oops
12:23:14 <increpare> I hope that doesn't appear as an angry face to anyone else
12:23:19 <increpare> I'm not angry, just feeling silly...
12:23:21 <merehap> so when can you start?
12:23:29 <Absolute0> How can I print a number in binary representation?
12:23:31 <jfischoff> soon soon
12:23:35 <increpare> merehap: I'll get my notepad out tonight
12:23:46 <merehap> ha
12:23:51 <Absolute0> showHex 4 => "0100"
12:23:56 <jfischoff> seriously I think it could be written in a weekend
12:24:01 <Twey> Absolute0: showIntAtBase from Numeric
12:24:01 <Absolute0> err, showBinary 4 => "0100"
12:24:11 <increpare> jfischoff: so what is it that you think could be written?
12:24:11 <jfischoff> if it only did self illumating texture meshes
12:24:22 <merehap> Absolute0: I think you want the Data.Bits library
12:24:25 <increpare> (to clear up any residual misunderstandings)
12:24:33 <jfischoff> take a textured mesh and make a image
12:24:41 <Twey> > let showBinary n = showIntAtBase 2 ("01" !!) n "" in showBinary 4
12:24:41 <jfischoff> assume no lighting
12:24:42 <lambdabot>   "100"
12:24:52 <Twey> Padding extra ☺
12:25:24 <Absolute0> showIntAtBase is not in Data.Bits
12:25:26 <Absolute0> or Word
12:25:32 <increpare> jfischoff: yeah it sounds totally doable/fun
12:25:42 <Absolute0> @where showIntAtBAse
12:25:42 <lambdabot> I know nothing about showintatbase.
12:25:48 <Twey> numeric
12:25:51 <Twey> Er
12:25:52 <Twey> Numeric
12:25:53 <jfischoff> jfischoff: I'm gonna do it if no one else does
12:25:58 <Twey> Hence: 20:23:37 < Twey> Absolute0: showIntAtBase from Numeric
12:26:03 <jfischoff> increpare: you interested?
12:26:07 <Twey> jfischoff: Talking to yourself is the first sign of madness ;)
12:26:12 <jfischoff> haha
12:26:14 <jfischoff> whoops
12:27:41 <increpare> jfischoff: I don't think I want to do it myself (I have no need)
12:28:09 <increpare> jfischoff: but I will interestedly follow you if you do it
12:28:10 <jfischoff> increpare: what are you interested in 3D wise?
12:28:19 <jfischoff> increpare: cool
12:28:56 <joe1> 'showHex 4' is giving me an error. loaded the module Numeric.
12:29:02 <joe1>     No instance for (Show (String -> String))
12:29:33 <increpare> jfischoff: at the moment I'm working on a game - graphics aren't really going to be a big part (at least for the time being), but yeah I need to get a top-down camera (thinking a slightly zoomed in version of the GTA camera) working at least so I can test stuff out
12:30:11 <jfischoff> increpare: Cool.
12:30:15 <increpare> I doubt I'll see any textures this side of easter
12:30:22 <jfischoff> haha
12:30:44 <increpare> had trouble getting hsdl to work, ended up just going with glut for now...easy enough to change once I figure out how to get it running again (or I wait for cabal to catch up)
12:31:11 <increpare> had it working before, but did a system wipe...
12:31:22 <jfischoff> increpare: Sucks
12:31:42 <increpare> anyway, I've spent most of today cursing how unwieldy container classes feel
12:32:06 <increpare> (with the exception of lists)
12:32:23 <jfischoff> yeah if you only need lists life's a dream
12:32:28 <jfischoff> off to lunch
12:32:29 * increpare has a love-hate relationship with Arrays and Ixs
12:32:34 <increpare> enjoy
12:32:37 <jfischoff> good talking to ya
12:32:45 <increpare> ditto
12:35:32 <dave_r5> in general, is it a pretty good assumption that the GHC extensions to Haskell will someday be included in the formal Haskell language?
12:37:17 <chrisdone> dave_r5: some have, but not many
12:37:34 <chrisdone> there's always the fact ghc is the de facto standard implementation
12:38:29 <increpare> chrisdone: yeah, things do get obsoleted every now and then
12:38:42 <dave_r5> i see. i suppose my real question is whether portability is an issue with GHC extensions.
12:39:01 <pikhq> In effect, GHC is *the* Haskell compiler.
12:39:25 <dave_r5> perhaps not forever, though
12:39:39 <increpare> dave_r5: it depends on what extensions you're using, I guess
12:39:43 <pikhq> Whatever succeeds it would probably support GHC extensions.
12:39:59 <increpare> dave_r5: GADTs, and type families, are unlikely to be thrown out
12:40:57 <increpare> but, in 6.12, say, the RecursiveDo and ImpredicativeTypes extensions were marked as deprecated
12:42:00 <copumpkin> well recursive do is just dying because they changed the syntax
12:42:36 <Twey> What's the new syntax?
12:42:44 <increpare> copumpkin: yeah, that's true
12:42:50 <increpare> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/syntax-extns.html#mdo-notation
12:42:57 <Twey> Ta
12:46:12 <joe1> hello, i am looking to split a byte into list of bits. any suggestions, please?
12:46:38 <mjrosenb> how does ghc normally invoke cpp?
12:48:05 <xerox> > showIntAtBase 2 ("01" !!) 0xA ""
12:48:06 <lambdabot>   "1010"
12:48:26 <Twey> > reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ 0xA
12:48:27 <lambdabot>   [1,0,1,0]
12:48:53 <Twey> > map digitToInt $ showIntAtBase 2 ("01" !!) 0xA ""
12:48:54 <lambdabot>   [1,0,1,0]
12:49:00 <Twey> As you like
12:50:51 <joe1> thanks..
12:51:17 <Twey> Personally, I feel that parsing to a string and back is a bit ugly
12:51:28 <Twey> On the other hand, the more elegant version involves a reverse
12:51:37 <Twey> Which is also a bit nasty
12:51:43 <Twey> So, whatever you like ☺
12:52:30 <joe1> ok, thanks.
12:54:44 <joe1> :t div
12:54:45 <lambdabot> forall a. (Integral a) => a -> a -> a
12:54:51 <joe1> :t iterate
12:54:51 <lambdabot> forall a. (a -> a) -> a -> [a]
12:54:59 <joe1> :t takeWhile
12:55:00 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:55:14 <joe1> :t mod
12:55:14 <lambdabot> forall a. (Integral a) => a -> a -> a
12:55:25 <mgsloan> how much effort would it take to get together a wrapper for libpurple?  http://developer.pidgin.im/doxygen/dev/html/group__core.html
12:55:54 <nero_> [10..1]
12:56:15 <xerox> > let { f 0 = Nothing; f x = let (q,r) = (divMod x 2) in Just (r,q); g = reverse . unfoldr f } in g 100
12:56:16 <lambdabot>   [1,1,0,0,1,0,0]
12:56:33 <nero_> people does anyone knows why this doesn't work: [10..1]
12:56:37 <mgsloan> most of the rote work would be done by automatic tools, no?  everything else would be writing wrappers to make it more haskellian?
12:56:47 <ben0x539_> > [10,9..1]
12:56:48 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:56:54 <nero_> [10..1]
12:56:59 <Twey> nero_: Because the default step is 1, if you don't provide one
12:57:07 <nero_> [10,9..1]
12:57:09 <xerox> nero_: because it is sugar for enumFromTo 10 1
12:57:17 <joe1> is there a way to see the code of a haskell function in ghci
12:57:19 <merehap> rather than negative 1 as you are expecting
12:57:29 <merehap> @src take
12:57:29 <nero_> oke tnx everyone
12:57:29 <lambdabot> take n _      | n <= 0 =  []
12:57:29 <lambdabot> take _ []              =  []
12:57:29 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:57:43 <merehap> use @src, joe1
12:57:46 <merehap> as I did
12:57:46 <joe1> thanks.
12:57:53 <Twey> joe1: If you install GOA, you can call lambdabot's @src function from your local GHCi
12:57:57 <deh> @src enumFromTo
12:57:57 <lambdabot> Source not found. You speak an infinite deal of nothing
12:58:19 <Twey> But it's not infallible.  ☺
12:58:28 <nero_> > [10..1]
12:58:29 <lambdabot>   []
12:58:31 <joe1> what GOA? just a module with the name GOA or is it an acronym for something.
12:58:40 <nero_> > [10, 9 ..1]
12:58:41 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:58:55 <Twey> joe1: GHCi On Acid
12:59:00 <increpare> [ 10, 9.1, ..1]
12:59:04 <increpare> oops
12:59:08 <Twey> It's a module that integrates lambdabot into GHCi.
12:59:09 <increpare> > [ 10, 9.1, ..1]
12:59:10 <lambdabot>   <no location info>: parse error on input `..'
12:59:19 <increpare> > [ 10, 9.1 ..1]
12:59:20 <lambdabot>   [10.0,9.1,8.2,7.299999999999999,6.399999999999999,5.499999999999998,4.59999...
12:59:37 <Twey> You should always space operators, especially ones involving ‘.’
12:59:39 <increpare> > [ 3, 2.1 ..1]
12:59:41 <lambdabot>   [3.0,2.1,1.2000000000000002]
12:59:42 <Twey> Ambiguity can result otherwise.
13:00:03 <increpare> : )
13:00:35 <merehap> > [3%1, 21%10 .. 1]
13:00:36 <lambdabot>   [3 % 1,21 % 10,6 % 5]
13:02:02 <joe1> twey: thanks, installing goa
13:02:57 <chrisdone> how easy is goa to setup these days? last time I used it, it was tricky enough that I wrote a guide on setting it up
13:04:23 <chrisdone> actually, after reading, it's not tricky at all
13:04:26 <chrisdone> http://chrisdone.blogspot.com/2009/12/ghci-on-acid.html
13:04:27 <joe1> twey: i installed goa with cabal and ghci is still giving me an error on @src. is there something special that I need to do.
13:05:19 <chrisdone> joe1: check that guide
13:05:23 <joe1> ok, thanks.
13:06:01 <chrisdone> I might update it and stick it on the haskellwiki
13:06:21 <xerox> chrisdone: thanks for the love you gave to GOA :)
13:06:45 <chrisdone> welcome =)
13:10:55 <Spockz|lap> Is there already a function 'between' :: Num a => a -> a -> a -> Bool? I can't find it with hoogle.
13:11:38 <koeien37> Ord would be more appropriate there
13:12:47 <Spockz|lap> koeien37:  indeed, that's what I wnated to type :p
13:12:58 <koeien37> then, maybe not, but easily defined
13:12:58 <Spockz|lap> (couldn't find that one either though)
13:13:06 <koeien37> @let between a b = \x -> a <= x && x <= b
13:13:07 <lambdabot>  Defined.
13:13:09 <koeien37> :t between
13:13:10 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
13:14:23 <koeien37> > between 2 42 37
13:14:24 <lambdabot>   True
13:17:19 <Spockz|lap> I know
13:20:39 <chrisdone> if you ask that a function already exists so that you don't have to define it yourself, this channel will still tell you that it's easy to define and provide the definition. I don't think they believe you haven't already figured it out, I just think they love writing haskell code, a lot =)
13:22:28 <roconnor> > inRange (42,37) 2
13:22:29 <lambdabot>   False
13:22:30 <c_wraith> sometimes we point out `on`, though, as it's an easy function to miss the applications of
13:22:37 <roconnor> > inRange (37,42) 2
13:22:38 <lambdabot>   False
13:22:44 <roconnor> er
13:22:50 <roconnor> > inRange (2,42) 37
13:22:52 <lambdabot>   True
13:22:52 <xerox> ?index inRange
13:22:53 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
13:22:55 <xerox> aha.
13:23:01 <c_wraith> :t max `on` snd
13:23:02 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> b
13:23:14 <zoheb> I was looking at the defn of MonadSTate, can someone explain what the | symbol means?
13:23:16 <roconnor> @type inRange
13:23:17 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
13:23:18 <zoheb> class (Monad m) => MonadState s m | m -> s where
13:23:30 <roconnor> note that inRange has a completely different type constraint
13:23:45 <Philonous> zoheb: in a class declaration, | introduces a functional dependency
13:24:12 <xerox> > let between a b = liftM2 (<=) (compare a) (flip compare b) in map (between 1 2) [0..3] -- but this does half-open interval
13:24:13 <lambdabot>   [False,False,True,True]
13:24:15 <zoheb> Philonous, where can I read about functional dependencies?
13:24:28 <zoheb> what exactly does it mean?
13:24:46 <zoheb> That there must be some fn from m to s?
13:25:03 <Philonous> zoheb: So class Foo a b | a-> b That means that you promise that you provide at most one instance with the same b.
13:25:36 <Philonous> zoheb: With the same a*
13:25:52 <adekoba> cabal just gave me this error trying to compile something: ghc-6.10.4 requires old-time ==1.0.0.2 however
13:25:58 <Philonous> Or rather: For any two instances which cover the same a, the b is equal
13:25:59 <adekoba> old-time-1.0.0.2 was excluded because ghc-6.10.4 requires old-time ==1.0.0.3
13:26:07 <adekoba> wtf?
13:26:42 <c_wraith> adekoba: what are you compiling that depends on ghc?
13:26:57 <Philonous> zoheb: The idea behind this is that, whenever the compiler sees an a, he can automatically fill in the b, so you don't need to add an explicit type annotation
13:27:05 <zoheb> ok
13:27:33 <zoheb> so given a monad M the corresponding s is obvious to the compiler
13:28:06 <c_wraith> zoheb: it's usually done when you have a multivariable typeclass that has some functions that don't use all the type variables.
13:28:08 <Philonous> zoheb: Exactly.
13:28:17 <Philonous> zoheb: http://www.haskell.org/haskellwiki/Functional_dependencies
13:28:21 <adekoba> c_wraith: just a little program. here's the dependency line: build-depends:   mtl, cereal, bytestring, encoding
13:28:23 <copumpkin> not sure why you'd mention monads explicitly
13:28:24 <Philonous> http://www.cs.chalmers.se/~hallgren/Papers/wm01.html
13:30:03 <c_wraith> adekoba: this sounds like hackage is finding new versions of packages that can't be upgraded, and trying to upgrade them.  It's worth putting explicit versions on those packages, and making sure the set of versions is compatible with each other and your version of ghc
13:30:29 <c_wraith> err, *cabal* is finding....
13:31:19 <adekoba> c_wraith: certainly sounds like the case. `cabal upgrade` reports numerous packages to be updated, but most can't be upgraded because they depend on the new base which depends on the new ghc which my distro doesn't have yet
13:31:23 <Axman6> > let between a b = liftM2 (&&) (a <=) (<= b) in map (between 1 2) [0..3]
13:31:24 <lambdabot>   [False,True,True,False]
13:31:41 <zoheb> Sorry I lost my net connection
13:31:43 <Axman6> > let between a b = liftA2 (&&) (a <=) (<= b) in map (between 1 2) [0..3]
13:31:44 <lambdabot>   [False,True,True,False]
13:31:45 <adekoba> c_wraith: I'll give your suggestion a shot
13:31:52 <c_wraith> adekoba: I ran into a similar problem yesterday, and worked around it with enough --constraint args on my cabal install line.  *shrug*
13:32:02 <zoheb> Philonous Thanks
13:32:22 <zoheb> I will read up
13:43:05 <jfischoff> whenever I try to pass options to runHaskell I get: runGenProcess: does not exist (No such file or directory)
13:43:10 <jfischoff> any ideas?
13:43:43 <jlouis> jfischoff: strace(1) the process, look at what it tries to exec
13:44:15 <jfischoff> jlouis: is that a *nix thing?
13:44:26 <jfischoff> jlouis: on windows?
13:44:42 <jlouis> jfischoff: screw windows.
13:44:45 <jfischoff> haha
13:45:12 <jlouis> jfischoff: Don't windows have a trace tool for tracing system calls a program makes?
13:45:17 <mk64ftw> how would strace help? that isn't a system call...
13:45:18 <joe1> what is lambdabot home directory if i installed lambdabot with cabal?
13:45:34 <jfischoff> jlouis: yeah
13:45:37 <mk64ftw> just to see which open call was failing?
13:45:51 <mk64ftw> i guess that does help
13:46:05 <chrisdone> joe1: typically ~/.cabal/bin
13:46:10 <joe1> thanks.
13:46:16 <jlouis> Another way is to figure out what runGenProcess is and what it gets fed
13:46:37 <joe1> chrisdone: i meant the setLambdabotHome directory?
13:46:43 <joe1> is it still .cabal/bin?
13:47:05 <jfischoff> jlouis:
13:47:06 <joe1> in the dot-ghci file it is set to a different dir lambdabot?
13:47:18 <joe1> under the home directory?
13:47:46 <joe1> if you do not mind my asking, what is it used for?
13:47:52 <jfischoff> jlouis: I think I am passing the option incorrectly. It is trying to find a program called no-warn-missing-methods.exe
13:48:07 <jlouis> jfischoff: oh, interesting
13:48:21 <jfischoff> jlouis: does this look wrong? runHaskell -fno-warn-missing-methods $(FULL_CURRENT_PATH)
13:48:41 <mk64ftw> a gcc option?
13:49:03 <jfischoff> ghc option
13:50:23 <joe1> chrisdone: in your blog post i can see that it is set to /var/www/chrisdone/lambdabot-personal ?
13:50:38 <chrisdone> joe1: yeah, I didn't install mine with cabal back then
13:50:46 <chrisdone> (I got the darcs version)
13:51:00 <joe1> yes.
13:51:29 <joe1> chrisdone: i am a bit nervous that lambdabot might write all kinds of stuff to that directory and I would rather have the bin dir clean?
13:51:53 <joe1> hence, wanted to doublecheck before I set it to .cabal/bin.
13:52:05 <mk64ftw> jlouis: kind of a hack, but you can try using the OPTIONS_GHC pragma
13:52:53 <chrisdone> joe1: I suspect programs installed with cabal have their own resources directories, but I'm not sure
13:53:16 <joe1> so, should I remove the directory option from the .ghci and try?
13:53:25 <joe1> i think that is reasonable, doesn't it?
13:53:43 <jfischoff> mk64ftw: do you put the OPTIONS_GHC in the file?
13:53:45 <chrisdone> I don't know =)
13:54:35 <mk64ftw> jfischoff: like this {-# OPTIONS_GHC -fno-warn-mission-methods #-} first line of the file
13:55:01 <TomMD-TB> preflex: seen alpheccar
13:55:01 <preflex>  Sorry, I haven't seen alpheccar
13:55:01 <joe1> ok, thanks.
13:55:06 <jfischoff> mk64ftw: Nice
13:55:18 <mk64ftw> jfischoff: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/using-ghc.html#source-file-options for more info
13:55:45 <jfischoff> mk64ftw: Cool thanks man
13:57:25 <joe1> chrisdone: it is looking for the lambdabot binary in that directory, hence .cabal/bin is the way to go.
13:57:51 <chrisdone> should be ok
14:02:18 <joe1> chrisdone: when I do :source <module> , i am getting the below
14:02:20 <joe1> GOA Prelude Data.List> :source reverse reverse not available
14:02:37 <joe1> is it because reverse is not in haskell code?
14:02:47 <joe1> and is an internal?
14:03:44 <chrisdone> joe1: 'reverse' isn't a module
14:05:03 <joe1> oh, ok. I thought :source = @src . mistake.
14:05:07 <chrisdone> joe1: consider the definition of ":source":
14:05:08 <chrisdone> :def source    lambdabot "fptools"
14:05:08 <chrisdone> you could define an ":src" to do what you want, e.g.:
14:05:11 <chrisdone> :def src lambdabot "<the command to get function source>"
14:05:43 <joe1> how I can see the code of a function: @src does not seem to work.
14:05:48 <joe1> @src takeWhile
14:05:49 <lambdabot> takeWhile _ []                 =  []
14:05:49 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
14:05:49 <lambdabot>                    | otherwise =  []
14:06:02 <joe1> though it works here.
14:06:17 <joe1> i want the above lambdabot's output at ghci?
14:06:51 <koeien37> these sources are not real, but mainly chosen for educational value
14:07:02 <joe1> oh, really?
14:07:12 <joe1> so, there is no point in looking at them?
14:07:23 <koeien37> well, there is a point. They are supposed to be equivalent
14:07:28 <koeien37> @src concat
14:07:28 <lambdabot> concat = foldr (++) []
14:07:29 <joe1> am I better off looking at the documentation online?
14:07:32 <koeien37> yeah
14:08:10 <koeien37> @src (++)
14:08:11 <lambdabot> []     ++ ys = ys
14:08:11 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:08:11 <lambdabot> -- OR
14:08:11 <lambdabot> xs ++ ys = foldr (:) ys xs
14:08:14 <koeien37> here, two examples
14:08:20 <joe1> ok, but am still curious as to why @src does not work at my ghci prompt.
14:08:20 <koeien37> this is not the real source
14:08:27 <koeien37> @src is not something ghci supports
14:08:28 <lambdabot> Source not found. stty: unknown mode: doofus
14:08:48 <CalJohn> joe1: lambdabot is not just a ghci repl
14:09:26 <chrisdone> joe1: it just calls lambdabot directly
14:09:27 <koeien37> > putStrLn "This is not actually executed by lambdabot."
14:09:27 <lambdabot>   <IO ()>
14:10:18 <chrisdone> @help
14:10:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:10:21 <chrisdone> @list
14:10:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:11:17 <chrisdone> chris@chrisamilo:~$ lambdabot -e 'src maybe'
14:11:17 <chrisdone> Initialising plugins .....................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
14:11:17 <chrisdone> ................ done.
14:11:17 <chrisdone> maybe n _ Nothing  = n
14:11:20 <chrisdone> maybe _ f (Just x) = f x
14:11:24 <chrisdone> Exception: all servers detached
14:11:33 <chrisdone> joe1: try :def src lambdabot "src"
14:12:41 <joe1> GOA> :def src lambdabot "src"
14:12:41 <joe1> macro 'src' is already defined
14:12:41 <joe1> GOA> src takeWhile
14:12:41 <joe1> <interactive>:1:0: Not in scope: `src'
14:12:41 <joe1> (0.00 secs, 0 bytes)
14:13:05 <monochrom> freenode is a bogus server?
14:13:18 <joe1> GOA> @src takeWhile
14:13:18 <joe1> <interactive>:1:0: parse error on input `@'
14:13:18 <joe1> (0.00 secs, 0 bytes)
14:13:39 <BMeph> Is there a particular reason why the worker-wrapper form for reverse puts the helper list at the end? It looks to me as if it'd work better as the first argument, for substitution purposes.
14:14:03 <koeien37> why would it matter?
14:14:26 <joe1> chrisdone: i can see that lambdabot works from the console prompt. but am having trouble to get it to run from ghci
14:15:09 <chrisdone> joe1: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14984#a14984
14:16:22 <dave_r5> if i make a data type that has several constructors, is there a way that I can use automatically derived show implementations for some of the constructors, and define my own instance for other constructors?
14:16:45 <joe1> chrisdone: thanks, it works.
14:16:52 <chrisdone> joe1: ^_^
14:17:02 <joe1> thanks for your help. sorry if I was being a bit thick there..
14:17:08 <koeien37> dave_r5: no
14:17:23 <Philonous> dave_r5: instance declarations are all or nothing.
14:18:12 <dave_r5> i see. is there a way that i can reference the default implementation, to do something like "show x = default_show x"
14:18:32 <koeien37> no
14:19:02 <koeien37> is it really a problem? how many constructors do you have?
14:19:02 <dave_r5> cool. thanks
14:19:11 <dave_r5> not that many, just trying to keep it clean
14:19:17 <dave_r5> and learn things
14:19:40 <koeien37> okay :) good luck
14:21:59 <BMeph> koeien37: I'm trying to figure out a way to write 'reverse (reverse xs) == xs' in a more manipulable form, and was wondering what, if any, importance is associated with the order of the worker's args.
14:22:56 <koeien37> in general, i'd write func x = worker x initial where worker x acc = ...
14:23:18 <koeien37> seems a little bit more idiomatic
14:25:44 <BMeph> Idiomatic, yes. It does make it more awkward for transformation, though. Well, in my case it does. :)
14:31:05 <Cale> lol: Font: "Helvetica" does not appear to be either a font file or registered with ImageMagick. A similarly-named font was not found. Sorry! The font "Helvetica" will be used instead.
14:35:29 <koeien37> Cale: heh
14:39:07 <ane_> .)
14:39:17 <BMeph> ...wait, what?!?
14:43:42 <joe1> twey, u there?
14:46:09 <joe1> takeWhile (/=0) $ iterate (`div` 2) $ 0xa
14:46:15 <joe1>  takeWhile (/=0) . iterate (`div` 2) $ 0xa
14:46:21 <skorpan> :t iterate
14:46:22 <lambdabot> forall a. (a -> a) -> a -> [a]
14:46:41 <joe1> i am trying to understand the difference between $ and .
14:46:49 <joe1> I know that one is function composition.
14:46:50 <tommd> :t (.)
14:46:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:46:53 <tommd> :t $
14:46:54 <lambdabot> parse error on input `$'
14:46:56 <joe1> I know that one (.) is function composition.
14:47:00 <monochrom> . is between two functions, $ is between a function and its parameter
14:47:00 <skorpan> "f $ x" is the same as "f x"
14:47:07 <tommd> :t ($)
14:47:08 <lambdabot> forall a b. (a -> b) -> a -> b
14:47:18 <skorpan> the only thing $ does is change the fixity
14:47:32 <monochrom> I never use $ personally. Yes I would rather use parentheses.
14:47:33 <tommd> Its often used to replace parentheses.
14:48:04 <tommd> f x (z + 4)    ===> f x $ z + 4
14:48:42 <skorpan> is ($) infixr 1?
14:49:01 <tommd> That is an intentionally bad example, but you do see things like that.  Most uses are a little smarter, such as with putStrLn and lots of concatenated strings.
14:49:14 <monochrom> infixr 0
14:50:19 <BMeph> > head .   ["alley","bacon","chart"]
14:50:20 <lambdabot>   "abc"
14:50:27 <BMeph> > head $  ["alley","bacon","chart"]
14:50:28 <lambdabot>   "alley"
14:50:33 <skorpan> now that's just confusing BMeph :P
14:50:36 <monochrom> O you evil
14:50:44 <joe1> bmeph, that is very interesting.
14:50:48 <BMeph> Very different -- and valid, thanks to Caleskell... ;)
14:50:53 <b_jonas> yeah, that's cheating
14:50:58 <b_jonas> thye aliased . to <$>
14:51:02 <monochrom> And oh, "that's just confusing BMeph" is also confusing (by ambiguity) :)
14:51:05 <skorpan> and <$> is an alias for fmap
14:51:06 <b_jonas> which is the right thing to do except historaically
14:51:43 * BMeph loves oatmeal cookies with extra hysterical raisins!
14:52:39 <CalJohn> what is the real . in Caleskell?
14:52:54 <skorpan> they're the same thing, aren't they?
14:52:54 <CalJohn> (ie: where is function composition?)
14:53:07 <joe1> bmeph, that is a vey brilliant example.
14:53:13 <monochrom> Perhaps you can write Prelude.(.)
14:53:14 <CalJohn> @type .
14:53:15 <lambdabot> parse error on input `.'
14:53:22 <CalJohn> @type (.)
14:53:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:53:23 <Saizan> CalJohn: (.) works as function composition too
14:53:42 <Saizan> > ((+1) . (+1)) 0
14:53:43 <lambdabot>   2
14:53:45 <joe1> bmeph, can you put this on the wiki, ( if not already there). because I get this question all the time.
14:54:25 <skorpan> joel: imo, BMeph's example is potentially confusing to beginners, but interesting
14:55:41 <BMeph> joe1: Well, I could, but it only works because the definition of (.) has been artificially widened to work with any functor, not just functions (AKA the "Reader" Functor). :)
14:56:08 <monochrom> "head . [x,y,z]" is not standard.
14:56:31 <skorpan> > Prelude.(.) head [1,2,3]
14:56:32 <lambdabot>   Not in scope: data constructor `Prelude'
14:56:34 <skorpan> hm...
14:56:43 <Twey> joe1: Yes
14:57:09 <Twey> joe1: ($) is low-precedence function application.  It's used to avoid having to put brackets around everything.
14:57:22 <BMeph> joe1: Basically, it shouldn't work at all, except that (.) is not redefined to let it work. I found it out "the hard way" by writing what should've been a type error...that wasn't. ;)
14:57:24 <Twey> You can think of f x $ g y as being the same as (f x) (g y).
14:57:41 <joe1> twey: i am still trying to unravel the code that you posted to split the byte into individual bits. I find the code to be brilliant. I am curious to know how you could do it so quickly.
14:57:54 <skorpan> when i learned about $, the explanation was "$ puts parentheses around everything to the right of it"... which is pretty much what it does.
14:57:56 <joe1> did you have the code somewhere else or did you think it on the spot.
14:57:59 <Twey> joe1: It's part of the code library in my head.  I like it, too.  ☺
14:58:33 <Twey> It's actually just a functional rendering of the usual method for converting a number into a base on paper
14:59:38 <joe1> twey: i think of "f x $ g y" as f x (g y)
14:59:42 <joe1> am i wrong?
14:59:52 <skorpan> joel: that's correct
14:59:54 <monochrom> It is correct.
15:00:00 <joe1> i think that the result of g y is passed as the second parameter to f
15:00:43 <monochrom> takeWhile (/=0) (iterate (`div` 2) 0xa)
15:01:02 <Twey> 1) Write down the number.  2) If the number is 0, go to 5.  3) Divide the number by the target base.  Write the remainder to the right of the number, and the result underneath the original number.  4) Go to 2 and repeat with the divided result.  5) Read up the column of remainders.  This is the answer you seek.
15:01:04 <monochrom> Premature $ization is the root of all evils.
15:01:21 <joe1> i understand $ but have trouble understanding . $ = brackets but with ., I cannot figure out it's special purpose.
15:01:38 <tromp__> premature ejaculation?
15:01:46 <pozic> monochrom: all programming is premature optimization.
15:02:08 <pozic> Or to put that in mathematical language "almost all programming".
15:02:08 <joe1> twey, thanks for the explanation.
15:02:14 <monochrom> I am talking about $ization, not optimization.
15:02:14 <BMeph> I've noticed that there is a recurring pattern of "f z = let (x,y) = g z in h (h1 x) (f y)" functions in use. I'm sure it's one of edwardk's many functions in either the category-extras or monoids package, but I'm not sure which one. I also feel like it should be used more often... :\
15:03:44 <Twey> Write down the number: n.  Divide the number by the target base (we go all the way down to the bottom in one step, because it's easier): iterate (`div` 2) n.  If the number is 0, stop: takeWhile (/= 0) $ iterate (`div` 2) n.  Take the modulus of the numbers: map (`mod` 2) . takeWhile (/= 0) $ iterate (`div` 2) n.  Reverse the moduli: reverse . map (`mod` 2) . takeWhile (/= 0) $ iterate (`div` 2) n.
15:04:29 <BMeph> joe1: The way (.) is "supposed" to work, it's like a "do this function after that one" operator. I.e., (f.g) x == f (g x)
15:04:31 <Twey> joe1: To say that f x $ g y is the same as f x (g y) is accurate in this case, but may be confusing in others (hence the extra brackets I inserted).
15:05:18 <Twey> For example, f . g x $ h x is not f . g x (h x), but (f . (g x)) (h x)
15:05:35 <joe1> bmeph: f $ g x = f (g x) and (f.g) x = f (g x)
15:06:46 <joe1> oh, I think I get it now.
15:06:55 <Saizan> f . g = \x -> f (g x) is more fair
15:06:57 <joe1> . has a higher precedence
15:07:01 <BMeph> joe1: ...and, f . g x /= f $ g x
15:07:02 <Twey> Yes
15:07:30 <skorpan> joe1: this is just an effect of letting ($) have the absolute lowest precedence possible in an infix operator.  (and that it is infixr and not infixl)
15:07:56 <skorpan> hm, this gives me an idea...  is there anything that says i can't define e.g. ($$) to be f $$ x = f x, and infixl 0?
15:08:03 <Twey> Nothing at all
15:08:07 <Twey> Feel free
15:08:08 <skorpan> cool.
15:08:17 <Twey> ($$) = id, though ☺
15:08:18 <pikhq> "f $ g x" is just a way to avoid parens. "f . g" is how you compose functions.
15:08:32 <skorpan> Twey: but id isn't 0 is it?
15:08:57 <pikhq> (see typical mathematical notation for "f . g"'s reasoning)
15:09:07 <joe1> pikhq " f . g" makes it a big function of "fg"
15:09:10 <Twey> Yes.  If I hadn't wanted to use $ there, I would have had to write (reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2)) n
15:09:14 <Twey> Which would be annoying ☺
15:09:17 <Twey> skorpan: Sorry?
15:09:21 <gwern> I am feeling mildly disappointed. the non-FFI variants on isSpace claimed to be faster are only a little
15:09:30 <gwern> darn you criterion for destroying my dreams!
15:09:51 <monochrom> This is why Haskell and MLs let you create your own operators.
15:09:52 <pozic> gwern: are you referring to some super-compiler?
15:10:02 <gwern> pozic: I is not
15:10:06 <Twey> (+ 2) $ 3 ⇒ (+ 2) `id` 3 ⇒ id (+ 2) 3 ⇒ (+ 2) 3 => 5
15:10:21 <skorpan> Twey: maybe i misunderstood something here, but the important thing about my suggestion was "infixl ($$) 0"... but maybe id works just as well?
15:10:29 <Twey> skorpan: Ah, yes
15:10:34 <pozic> gwern: because someone wrote a program on wich wc was faster than C by using the program counter.
15:10:51 <Twey> The infixl 0 is the important bit — I was just pointing out that you can say ($$) = id instead of f $$ x = f x
15:10:52 <pikhq> joe1: Yes.
15:11:05 <skorpan> oh, i see
15:11:18 <kmc> joe1, eliding brackets is not the only use of ($).  since it's an operator you can section it
15:11:19 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
15:11:22 <pikhq> And in the world of functional programming, you compose functions all the time. It's half the point. ;)
15:11:34 <Twey> Hehe, yes.
15:11:39 <Twey> It's a very useful operation.
15:11:40 <kmc> > map ($ "foo") [reverse, tail, ("bleh" ++)]
15:11:41 <lambdabot>   ["oof","oo","blehfoo"]
15:12:18 <Twey> > map (flip id "foo") [reverse, tail, ("bleh" ++)]
15:12:20 <lambdabot>   ["oof","oo","blehfoo"]
15:12:41 <skorpan> > zipWith ($) [(+1), (+2), (+3)] [(0,0,0)]
15:12:41 <kmc> :t flip id
15:12:42 <lambdabot>   No instance for (GHC.Num.Num (t, t1, t2))
15:12:42 <lambdabot>    arising from the literal `1' a...
15:12:42 <lambdabot> forall a b. a -> (a -> b) -> b
15:12:47 <Twey> It's a weird hiccough of Haskell's syntax that you can't actually refer to function application directly
15:12:53 <Twey> Hence the slightly hackish use of id and $ there
15:13:01 <skorpan> > zipWith ($) [(+1), (+2), (+3)] [0,0,0]
15:13:02 <lambdabot>   [1,2,3]
15:13:10 <Twey> (since function application is just white-space, not an identifier of any sort to speak of)
15:13:14 <kmc> Twey, is there a language where you can?
15:13:22 <Twey> No idea
15:13:39 <Twey> I once wrote a language with a ‘function application’ operator
15:13:42 <Twey> #
15:13:46 <lunabot>  luna: parse error on input `]'
15:13:50 <skorpan> kmc: i suppose e.g. __call__ of python?
15:13:54 <skorpan> not sure
15:13:55 <Twey> Function invocation looked like f # x # y
15:13:57 <pozic> Twey: isn't that called apply in Scheme?
15:13:58 <pikhq> C++ has operator (). Does that count? :P
15:14:09 <Twey> pikhq: No, because you still can't refer to it :þ
15:14:12 <Twey> pozic: Possibly so
15:14:17 <Twey> I don't know enough Scheme to comment
15:14:23 <kmc> i don't think those things are different from ($)
15:14:28 <Twey> kmc: They're not
15:14:40 <skorpan> "funcall" exists in emacs lisp
15:14:44 <Twey> The only difference is that (at least in my case) they're the primary means of function application
15:14:48 <kmc> if you have explicit syntax for application, you still need to quote it somehow if you like it to be a value
15:14:58 <Twey> skorpan: But talking about ‘operators’ in Lisp contexts is a bit iffy :þ
15:15:14 <Twey> kmc: But the point is that in Haskell you can't quote it at all
15:15:23 <Twey> Because it has no identifier by which to refer to it
15:15:29 <gwern> > ['a'..]
15:15:30 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
15:15:36 <uorygl> What does an executable produced by GHC look like?
15:15:36 <Twey> So we have to wrap it in $, and quote that instead
15:15:43 <skorpan> Twey: there's little to no difference between operators and functions when it comes to programming imo :P
15:15:47 <kmc> uorygl, a bunch of bits
15:15:49 <pozic> uorygl: big?
15:15:50 <kmc> uorygl, what do you mean?
15:15:50 <Twey> uorygl: Er, like any other executable for that platform
15:15:58 <uorygl> It's the Haskell runtime system plus some other stuff, right?
15:16:03 <kmc> Twey, well, i'm sure you can find lots of distinguishing characteristics
15:16:05 <uorygl> What sort of other stuff is there?
15:16:10 <kmc> uorygl, the GHC runtime system plus other stuff
15:16:18 <Twey> I don't think the whole runtime is bundled into the executable…
15:16:30 <pozic> uorygl: a bunch of back-doors.
15:16:41 <Twey> skorpan: Semantically, but syntactically there is (which is the whole point of the discussion :þ)
15:16:45 <uorygl> You can't exactly do runtime things at compile time.
15:16:55 <Twey> uorygl: Of course you can
15:17:02 <Twey> What did you *think* Template Haskell was for?  :þ
15:17:02 <gwern> ok, this time around I'll make the lists 10^25 entries long, that should make differences clearer
15:17:06 <pozic> Twey: you don't?
15:17:07 <kmc> uorygl, you can, with Template Haskell.  but i also don't see the relevance
15:17:18 * uorygl shrugs.
15:17:26 <Twey> pozic: Is it?  That would make a terribly chunky executable…
15:17:28 <pozic> Twey: how can you run a Haskell program without a Haskell run-time system?
15:17:37 <Twey> pozic: I assumed it was a dependency
15:17:38 <pozic> Twey: it is not that chunky.
15:17:38 <gwern> pozic: using lots of RAM
15:17:39 <kmc> pozic, by dynamically linking it, probably, but i don't think GHC does that
15:17:43 <gwern> pozic: look at jhc
15:17:44 <Twey> Huh.  Okay.
15:17:46 <kmc> hehe
15:17:50 <joe1> kmc: your example above was very thoughtful.
15:18:04 <joe1> is there a way in ghci to see the execution path?
15:18:26 <joe1> like a step by step elucidation of how the processing happens?
15:18:40 <Twey> joe1: I find Debug.Trace quite illustrative
15:19:56 <pozic> kmc: yes, but the bits are still there.
15:20:08 <pozic> Unfortunately, Haskell does not run on magic.
15:20:21 <kmc> @faq Can Haskell run on magic?
15:20:22 <lambdabot> The answer is: Yes! Haskell can do that.
15:20:56 <Twey> pozic: Having a runtime /= building the runtime into the executable
15:21:11 <kmc> i thought the question was whether the runtime is statically or dynamically linked
15:21:21 <pozic> Twey: yes, but for GHC the latter is the case, at least until 6.10.4.
15:21:31 <Twey> pozic: That's true.
15:21:38 <kmc> until and including, i thought
15:21:49 <Twey> I was talking about this:
15:21:51 <Twey> 23:17:15 < kmc> pozic, by dynamically linking it, probably, but i don't think GHC does that
15:21:54 <Twey> 23:19:32 < pozic> kmc: yes, but the bits are still there.
15:21:57 <pozic> Twey: The idea was that 6.12 would bring new stuff, but I haven't seen any major announcements.
15:22:08 <pozic> kmc: yes, including.
15:22:20 <kmc> pozic, uh, the 6.12 announcement happened
15:22:23 <Twey> You seemed to be implying that we were implying that the runtime magically vanishes, rather than just gets moved somewhere else, as I erroneously assumed was the case :þ
15:22:26 * pozic reads release notes
15:22:35 <pozic> kmc: I know, I just didn't read them yet.
15:22:40 <kmc> http://www.mail-archive.com/haskell@haskell.org/msg22499.html
15:22:41 <kmc> ah
15:22:59 <PeakerWork> I like that ghc 6.12 warns you if you ignore result of IO a vs IO ()
15:23:04 <kmc> it's actually out now, non-release-candidate, although Haskell Platform has not caught up
15:23:08 <PeakerWork> (with -Wall at least)
15:23:11 <kmc> PeakerWork, yes
15:23:20 <monochrom> Wait, I thought "libHSrts.a" means static linking
15:23:35 <PeakerWork> encourage separating out the side-effect-only stuff into IO () functions, and perhaps a "forkIO" that is bracket-based (to kill the thread when exiting the bracket)
15:24:07 <pozic> Ok, so on Linux apparently they fixed it.
15:24:37 <pozic> And then they say there is no software for Linux ;)
15:24:59 <PeakerWork> pozic: ?
15:25:31 <gwern> interesting. I've managed to expose how yhc's isSpace doesn't handle some cases it should
15:25:41 <pozic> PeakerWork: "where is the Photoshop, Autocad, Excel, Adove After Effects"-kind of people.
15:25:44 <harrisonpartch> any luck with leksah?
15:25:44 <gwern> but I had to crank the list of random chars up to 10^25 to show that
15:25:47 <harrisonpartch> the IDE?
15:25:53 <pozic> PeakerWork: you might not have met them.
15:25:56 <gwern> just goes to show djikstra's dictum about testing & bugs!
15:26:49 <harrisonpartch> haskell and ml have had a tremendous effect on my programming style already and i have not actually written one line in them et
15:27:03 <BMeph> kmc: It's a "semi-candidate". It was released to encourage developers to use it to update libraries for 6.12, without worrying that thee "official" release would be too different.
15:27:10 <monochrom> > 10^25 / 10^9 / 60 / 60
15:27:11 <lambdabot>   2.777777777777778e12
15:27:51 <monochrom> Sorry? If you tested 10^25 characters at 1 nanosecond per test, you would still need that many hours. When did you begin the tests? Before I was born?
15:28:25 <BMeph> So... (over) two trillion hours? ;p
15:28:36 <alp_> so many haskellers are geeks...
15:28:38 <monochrom> > 10^25 / 10^9 / 60 / 60 / 24 / 365
15:28:39 <lambdabot>   3.170979198376458e8
15:29:12 * pikhq has been contemplating a way to do a Turing machine in Magic: The Gathering...
15:29:23 <pikhq> If I manage that, then yes, Haskell can run on magic.
15:29:37 <monochrom> Hahaha
15:29:43 <harrisonpartch> Heights: The Wuthering
15:29:46 <alp_> hqhq
15:29:49 <alp_> haha*
15:30:11 <kmc> pikhq, hmm, i think that's been proven possible
15:30:17 <kmc> but i don't have a link :/
15:30:24 <alp_> pikhq, please let me know if you actually do it
15:31:22 <pikhq> kmc: Seems reasonable.
15:32:17 <pikhq> There's a few different sources of infinite storage in there.
15:32:20 <c_wraith> There are enough tools in Magic, that if you picked a proper representation, you could build an infinite tape and perform operations on it.
15:32:24 <pikhq> Stack, exile, battlefield...
15:32:33 <c_wraith> I was thinking an infinite set of tokens, of various types.
15:32:54 <pozic> It is more interesting to think of a faster way to compute than a slower way.
15:33:09 <pikhq> c_wraith: Heck, just a stack and "Exile the stack in an ordered pile. Place an ordered pile from the exile zone onto the stack."
15:33:31 <monochrom> Turing machine is too easy. Do lambda calculus directly.
15:33:33 <pozic> There is no challenge in doing it slower. Cf., "Look ma, I can ride a tricycle".
15:33:50 <pikhq> monochrom: I've also been contemplating that...
15:34:07 <c_wraith> pozic: last time I tried to ride a tricycle, I fell off.
15:34:08 <pikhq> Spells on the stack could reasonably be considered lambda expressions.
15:34:40 <monochrom> STG Magic: The Gathering
15:44:46 <mistermattaway> does anyone know anythign about using sortBy?
15:44:52 <mistermattaway> in Data.List?
15:45:09 <Beelsebob> what about it?
15:45:17 <gwern> monochrom: turns out 10^25 blows my RAM
15:45:17 <kmc> :t sortBy
15:45:19 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:45:28 <gwern> so I'm going with 10^24
15:45:34 <Beelsebob> > sortBy (compare `on` snd) [(1,5),(2,6),(9,2),(3,5)]
15:45:36 <lambdabot>   [(9,2),(1,5),(3,5),(2,6)]
15:45:46 <kmc> > sortBy (comparing snd) [(1,5),(2,6),(9,2),(3,5)]
15:45:47 <lambdabot>   [(9,2),(1,5),(3,5),(2,6)]
15:45:48 <Beelsebob> > sortBy (compare `on` fst) [(1,5),(2,6),(9,2),(3,5)]
15:45:49 <lambdabot>   [(1,5),(2,6),(3,5),(9,2)]
15:45:56 <mistermattaway> I'm having trouble finding examples of using it with a function that generates ordering
15:46:18 <gwern> interesting. with 10^24, looks like ghc' is slightly better than ghc on random chars
15:46:20 <Beelsebob> mistermattaway: anything with an Ord instance has compare
15:46:25 <Beelsebob> @type compare
15:46:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
15:47:19 <Beelsebob> you can ofc write your own variants, but more often than not, you need some combination of compare, comparing, `on` and getters
15:47:20 <mistermattaway> ah
15:55:12 <Baughn> I don't know how I survived in emacs with a recursive-edit binding..
15:55:30 <Baughn> ...and other editors? Um.. *hugs emacs*
15:55:47 <pozic> Baughn: you mean without?
15:55:58 <Twey> Recursive-edit binding?  What's this?
15:56:01 <Baughn> Without.
15:56:18 <Baughn> Twey: Let me just go to a recursive edit (again, level 3 now..), and..
15:56:28 <pozic> Twey: when you go into the mini-buffer to type something, the ability to do arbitrary stuff, AFAIK.
15:56:38 <Baughn> No, more.. in general
15:56:54 <pozic> Baughn: since you are the expert here, please enlighten us.
15:56:55 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14991#a14991
15:57:00 <Baughn> Basically, with those bindings..
15:57:13 <Baughn> Press super-(, and emacs enters a recursive edit. Nothing apparently happens.
15:57:19 <Baughn> You can then do anything you like.
15:57:41 <Baughn> Once you exit, the set of buffers, windows, buffer positions, etc. all go back to how they were before you entered.
15:57:50 <Baughn> Oh, and the status line shows your nesting level. :P
15:57:51 <Twey> Ah… sweet.
15:57:56 <Baughn> Oh yeah. :D
15:58:10 <Twey> I want this for all my apps.  :-\
15:58:13 <Baughn> My programming tends to nest, so emacs should too
15:58:17 <Baughn> Heh. Indeed. :P
15:58:19 <Twey> Hehe, yes
15:58:44 <pozic> So, it is basically push and pop :)
15:58:50 <Twey> *nod*
15:59:13 <mistermattaway> you guys and your macs
15:59:31 <Twey> Haha
16:00:54 <Baughn> I use it as a sort of instant bookmark. Any time I intend to scroll/switch somewhere, fix something, then go back - recursive edit instead.
16:01:45 <monochrom> Perhaps "10" means two.
16:02:11 <mistermattaway> so if I had a list of lists [[a]], and I wanted to split the head from the tail in a pattern, would it look like: ([a]:[as])?
16:02:24 <Saizan> no
16:02:27 <Saizan> (a:as)
16:02:45 <Saizan> [a] is a pattern that matches a singleton list with 'a' as its single element
16:02:52 <mistermattaway> ah, gotcha
16:03:21 <monochrom> And [as], singleton list with 'as' as single element.
16:03:27 <dmhouse> ?localtime dmhouse
16:03:27 <lambdabot> Local time for dmhouse is Fri Dec 25 00:03:04 2009
16:03:34 <dmhouse> Merry Christmas all :)
16:03:35 <Twey> ([a] : [as]) would match a list of two lists, giving you the first element of the first list in a and all of the second list in as
16:03:53 <michaels_> Get windows keys for only 5 eur http://bit.ly/5Tgz2X :)
16:03:55 <Baughn> dmhouse: Happy agnostica
16:04:08 <mistermattaway> festivus
16:04:28 <Twey> Heh
16:04:29 <chrisdone> @src sort
16:04:29 --- mode: ChanServ set +o monochrom
16:04:29 <lambdabot> sort = sortBy compare
16:04:32 <Twey> Happy Yule
16:04:34 <chrisdone> @src sortBy
16:04:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:04:38 --- mode: monochrom set +b *!n=michaels@*.dial-up.dsl.siol.net
16:04:39 --- kick: michaels_ was kicked by monochrom (monochrom)
16:04:59 <chrisdone> @src filter
16:04:59 <lambdabot> filter _ []     = []
16:04:59 <lambdabot> filter p (x:xs)
16:04:59 <lambdabot>     | p x       = x : filter p xs
16:04:59 <lambdabot>     | otherwise = filter p xs
16:05:44 --- mode: monochrom set -b *!n=michaels@*.dial-up.dsl.siol.net
16:05:47 --- mode: monochrom set -o monochrom
16:06:22 <chrisdone> filter is weird on infinite lists, especially if you use it repeatedly. layers and layers of thunks
16:06:36 <Twey> Yep
16:07:21 <Twey> filter p = foldr (\x t -> if p x then x : t else t) []
16:09:02 <mistermattaway> can someone tell me why my pattern is getting a parse error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14992#a14992
16:09:25 <Twey> mistermattaway: ‘null’ is not a constructor
16:09:34 <BMeph> mistermattaway: For that "list-of-lists" thing, (xs:xss) is also accepted usage. :)
16:09:55 <mistermattaway> hi fives for the two of you
16:10:41 <mistermattaway> what should I put in place of my null bit?
16:10:46 <CalJohn> mistermattaway: []
16:11:06 * CalJohn wishes that list desugaring was mentioned in textbooks
16:11:08 <mistermattaway> I tried that, and it resulted in an 'ambiguous occurance of intersperse' error
16:11:17 <chrisdone> I once had a session generator by extracting randomness from /dev/random, chunking it into 128 chars, as an infinite list of random sequences of characters. each time I extracted one I would update it to be let keys = filter (/=latestSessionKey) keys. I figured this was faster than the alternative O(n) operation it would be to check the existing keys to test for uniqueness, but it layers on thunks per new key, and is probably a memory
16:11:17 <chrisdone> hog
16:11:24 <BMeph> YO DAWG I HERD U LIEK EMPTY LISTS... ;p
16:11:32 <mistermattaway> oh wait, intersperse is in Data.List?
16:11:34 <Axman6> mistermattaway: you'll need to give it another name
16:11:40 <mistermattaway> yep :)
16:12:10 <mistermattaway> remidner: read the error messages at least up to the second line
16:12:11 <Cale> mistermattaway: Yes, also, your last line is a spelling mistake, and the second last line has a pattern which matches everything, meaning that the last won't be used.
16:12:40 <Twey> Really?
16:12:43 <Twey> :t intersperse
16:12:45 <lambdabot> forall a. a -> [a] -> [a]
16:12:52 <Twey> *peer*
16:12:57 <Twey> Oh
16:13:02 <Twey> There it is
16:13:11 <Cale> oh, also your type signature is wrong
16:13:15 <chrisdone> (of course, layering thunks still causes an O(n) operation, but I didn't realise it at the time)
16:13:35 <Twey> chrisdone: Yeah ☺  Surprising, isn't it?
16:13:38 * Cale doesn't like thinking about thunks when understanding how Haskell code will perform.
16:13:51 <Cale> It's more low-level a notion than you usually need.
16:13:55 * mistermattaway ducks (that's what was in the book!)
16:13:58 <Cale> Just think about the reduction of expressions :)
16:14:04 <chrisdone> well, it's not really a thunk, anyway
16:14:12 <chrisdone> more like closures
16:14:18 <Cale> expressions!
16:14:19 <Cale> hehe
16:15:03 <pozic> I still want to see a graph application for reducing expressions.
16:15:54 <chrisdone> http://hackage.haskell.org/packages/archive/kibro/0.4.3/doc/html/src/Kibro.html#line-147
16:17:21 <Saizan> i think i'd prefer something textual using let for sharing
16:17:50 <pozic> chrisdone: ?
16:17:53 <Cale> I'd take either one :)
16:18:09 <pozic> Or both.
16:18:28 <Cale> Though I think the textual one would actually be more practical as well as being easier to implement.
16:18:37 <chrisdone> pozic: that was the "list of random, unique values" thing I was talking about
16:24:24 <kmc> okay so i'm trying to track down this weird cabal-install bug
16:24:47 <kmc> the one described here and various other places: http://osdir.com/ml/haskell-cafe@haskell.org/2009-09/msg00047.html
16:25:11 <kmc> if someone knows the guts of cabal-install better than me (i.e. at all) it'd be great to chat
16:26:19 <troutwine> Would someone read through this and hit me with a clue stick? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14996#a14996
16:27:35 <kmc> which part needs clue-sticking?
16:28:11 <troutwine> kmc: I'm not sure how to construct a correct abcParse, one that recognizes only and all the strings in abcLang.
16:30:58 <kmc> troutwine, so it's supposed to parse a sequence of tokens with exactly one a, exactly one b, and any number of c, in any order?
16:32:18 <troutwine> kmc: Yes.
16:33:05 <kmc> troutwine, that sort of language is awkward to express as a grammar
16:33:14 <pozic> troutwine: you first generate all orders.
16:33:18 <kmc> i'm not sure what your constraints are; whether you have to use parsec
16:33:28 <kmc> but if not, i'd just tokenize the stream and count letters yourself
16:33:47 <pozic> troutwine: then you write something like [many c, char 'a', char 'b'] and you are done.
16:33:54 <newsham> (a|bb|cc*) ?
16:34:07 <pozic> troutwine: that is the "have to use Parsec method".
16:34:19 <pozic> troutwine: very elegant, trivially correct, and slow.
16:34:32 <Eduard_Munteanu> Hi.
16:34:36 <calsaverini> hi
16:34:42 <troutwine> pozic: Yes, the slow bit is a problem.
16:34:59 <pozic> troutwine: it is only slow until you tried it.
16:35:03 <calsaverini> have any of you ever used the differential equation module in the numeric-prelude package?
16:35:03 <Eduard_Munteanu> Is there a minimal set of Haskellish instructions that make a lambda-recursive machine Turing-complete?
16:35:15 <kmc> Eduard_Munteanu, look up the SK combinatory calculus
16:35:21 <Eduard_Munteanu> kmc, thanks.
16:35:21 <kmc> can't necessarily be typed though
16:35:27 <newsham> lambda-recursive?
16:35:31 <Eduard_Munteanu> kmc, still sounds good.
16:35:38 <pozic> troutwine: so, what is the real question?
16:35:45 <calsaverini> Is there a "user manual" for the numeric-prelude package?
16:35:57 <troutwine> kmc: The posed problem is a simplification of parsing in a more general language.
16:36:05 <calsaverini> I really didn't quite get how to use the differential equation solver
16:36:09 <Eduard_Munteanu> newsham, yup. I know the model is equivalent to a Turing machine, but I want to express it functionally instead of branching and all that.
16:36:17 <pikhq> liftM :: a -> b -
16:36:27 <pikhq> ... Urgh. Stupid enter.
16:36:42 <pikhq> Eduard_Munteanu: liftM and const?
16:36:49 <kmc> f 1 1 = c >> optional (f 1 1); f nA nB = (a >> optional (f (nA+1) nB)) <|> (b >> optional (f nA (nB+1))) <|> (c >> optional (f nA nB)) -- troutwine something like this maybe?
16:36:51 <pikhq> (AKA S and K)
16:36:57 <pozic> If you feel cold this Christmas, build Coq from source. :)
16:37:06 <kmc> i.e. you count the number of a or b as you recurse on the parser
16:37:19 <troutwine> pozic: I'm validating a bunch of iCal docs and have to assert that some parameters occur only once and others as many times as wanted, in any order within a given block.
16:37:19 <newsham> kmc: heat generating, but no other side effects?
16:37:23 <kmc> Coq is a great way to warm up
16:37:24 <Eduard_Munteanu> pikhq, will try to figure that out too, though it sounds very monadish.
16:37:33 <pikhq> Eduard_Munteanu: Not really.
16:37:34 <kmc> newsham, ?
16:37:47 <newsham> building coq
16:37:59 <pikhq> It's just a coincidence that liftM on the ((->) r) is *also* the S combinator.
16:38:01 <newsham> oops, for pozic
16:38:01 <Eduard_Munteanu> pikhq, kmc, the reason I'm asking is I'm trying to concoct a CPU instruction set that looks functional.
16:38:02 <kmc> hehe
16:38:08 <pozic> troutwine: if it has to be fast, use what kmc said.
16:38:35 <kmc> there's probably a better way to write it too
16:39:27 <pozic> newsham: yes, I think the verificaiton of the theories is the most lengthy part.
16:39:33 <pozic> verification*
16:40:54 <troutwine> kmc: It _is_ awkward to express and it _seems_ like there should be but I'm stuck for a classy way of doing it.
16:41:08 <kmc> troutwine, well, you can try to write it as a CFG
16:41:19 <kmc> and worry about translating to Parsec later
16:41:37 <increpare> http://ded.indiefaqs.com/~locus/cscape.png <- yay have a bassssic city-scape prototype (very basic, but should suffice for my current purposes)
16:41:59 <calsaverini> anyone?
16:42:03 <joga> increpare, neat
16:43:00 <troutwine> kmc: True, okay. Thanks for the comments all.
16:52:44 <andy_> If no one minds a more or less naive question:
16:53:09 <newsham> ?stats
16:53:09 <lambdabot> Unknown command, try @list
16:53:27 <andy_> is there a way to map over the state of the Control.Monad.State.Lazy State monad using a State monad?
16:53:49 <andy_> i.e. the state is made up by a Data.Array.IArray
16:54:04 <newsham> gets . map f   ?
16:54:06 <andy_> and would like to map over it without having to explicitly pass it to a function
16:54:07 <andy_> ok
16:54:08 <andy_> thanks
16:54:12 <newsham> gets (map f) ?
16:54:28 <newsham> modify (map f) ?
17:03:54 <glitch> Merry Christmas everyone :)
17:04:20 <ivanm> and to you glitch!
17:08:54 <kmc> can i get a backtrace of some sort when catching an IO exception?
17:09:21 <mrd> isn't the stack unwound then?
17:15:06 <mreh> :t Parser
17:15:07 <lambdabot> Not in scope: data constructor `Parser'
17:15:18 <jh> :t 1
17:15:20 <lambdabot> forall t. (Num t) => t
17:18:39 <andy_> just to make sure its how I wrote it and not some other factor:
17:19:04 <andy_> is DiffArray still not so speedy (compared to IOArray)
17:31:00 <ivanm> Saizan: you around?
17:34:06 <hiptobecubic> Why isn't learnyouahaskell in /topic? Where do you all normally direct people when they ask for a tut?
17:36:19 <medfly> there's also rwh
17:36:27 <medfly> people don't ask for it THAT much :)
17:37:05 <RyanT5000> is there a 32-bit mersenne twister lying around anywhere?
17:37:12 <RyanT5000> i'd be more than happy to package it if anyone's got one
17:37:20 <ivanm> RyanT5000: not AFAIK
17:37:28 <ivanm> RyanT5000: any particular reason for wanting it though?
17:37:35 <RyanT5000> yeah; i've gotta run it on ARM11
17:37:44 <ivanm> for starters, bos' PRNG in Statistics is meant to be better IIRC
17:37:54 <RyanT5000> ivanm: well, that'll do, then
17:38:13 <RyanT5000> yeah, i guess there's no reason i need MT specifically
17:38:17 <ivanm> RyanT5000: besides, I can use 64bit MT on a 32bit machine...
17:38:19 <RyanT5000> i just want a really fast PRNG
17:38:35 <Badger> hiptobecubic: when people ask...
17:38:37 <Badger> @where lyah
17:38:38 <lambdabot> http://www.learnyouahaskell.com/
17:39:19 <RyanT5000> ivanm: performance is critical - i assume 64-bit algorithm on 32-bit hardware will be slow
17:39:34 <ivanm> nopr
17:39:36 <ivanm> *nope
17:39:49 <RyanT5000> hm, alright
17:39:51 <ivanm> IIRC, the 64bit refers to using 64bit Double (rather than 32bit Float)
17:40:05 <ivanm> hiptobecubic: I try not to direct people to LYAH
17:40:05 <ivanm> ;-)
17:40:09 <RyanT5000> i thought it was integers, not floats
17:40:30 <Badger> ivanm: but... it has a picture of a boat, with BOAT written on it!
17:40:39 <Badger> Have you no heart?!
17:40:44 * ivanm checks
17:40:53 <ivanm> yes, I have muscles that pump blood around my body
17:40:55 <ivanm> next question?
17:40:59 <ivanm> RyanT5000: whatever ;-)
17:41:09 <ivanm> IIRC, the 64bit refers to implementation, not architecture
17:41:27 <RyanT5000> ivanm: yeah... i'm just super-resource-constrained right now, lol
17:41:39 <Badger> Just checking. Wouldn't want zombies subverting things.
17:41:46 <RyanT5000> Apple's terrible OpenGL drivers waste like 60% of the CPU just blitting things to the graphics card (on the iPhone)
17:42:14 <RyanT5000> or rather, blitting them around randomly in RAM *before* sending them to the graphics card
17:43:25 <ivanm> Badger: I believe that most zombies have said muscles as well; they just don't get used according to most definitions of zombies that I have seen (since they somehow manage to survive without blood flowing)
17:45:06 <PeakerWork> ivanm: why not LYAH?
17:45:15 <Badger> ivanm: Good point. I should've mentioned that the heart should be in working order. It just seemed to detract a little from the exclamation to ask "Have you no fully functioning heart which is providing oxygenated blood to your bodily tissues?!"
17:46:10 <ivanm> PeakerWork: because it isn't grammatical, and treats readers like idiots
17:46:19 <PeakerWork> ivanm: Grammatical?
17:46:33 <ivanm> "Learn You a Haskell for Great Good" <-- wtf does that even _mean_?!?!?!?
17:46:38 <PeakerWork> ivanm: Lighten up :)
17:46:41 <ivanm> Badger: heh
17:46:55 <ivanm> PeakerWork: I don't have any ohter internal sources of photons available for me to activate
17:46:56 <ivanm> ;-)
17:47:10 <PeakerWork> ivanm: It speaks to readers in a "light" tone - not like they're idiots. I've directed my coworkers at it and they all loved it
17:47:12 <kmc> meh, LYAH has a distinctive style that some people like and others hate
17:47:33 <kmc> i wish we also had a less "quirky" tutorial with similar material
17:47:35 <PeakerWork> its all about being light, because Haskell has a "heavy" impression
17:47:55 <Badger> Heavy duty monads.
17:48:19 <ivanm> PeakerWork: *shrug* I don't
17:48:32 <ivanm> then again, I prefer math-opriented tutorials to string-based or "quirky" ones
17:48:49 <PeakerWork> I don't think LYAH is "unmathy". Its not a "monads are astraunaut suits" tutorial
17:49:01 <mreh> does anyone understand Haskore.Medium well enough to explain it to me
17:49:16 <Badger> PeakerWork: wait... is there one that uses that analogy?
17:49:43 <ivanm> PeakerWork: well, most language tutorials are either String-based (typically for Java, etc.) or maaths-based (typically for FP langs) with the occasional "quirky" one (LYAH, _why's poignant guide, etc.)
17:51:46 <mreh> so I read Haskore.Medium and I was like "Whaaaaaaaa?"
17:54:13 * kmc is thinking of writing a Haskell tutorial which uses image processing as motivation throughout
17:55:23 * jh would like reading that =)
17:57:09 <ivanm> kmc: School of Expression does that to a limited extent IIRC
17:59:17 <kmc> yeah
17:59:22 <kmc> i should read it
17:59:54 <mreh> @google perspicuous
17:59:55 <lambdabot> http://www.merriam-webster.com/dictionary/perspicuous
17:59:55 <lambdabot> Title: perspicuous - Definition from the Merriam-Webster Online Dictionary
18:00:08 <ivanm> @wn perspicuous
18:00:10 <lambdabot> *** "perspicuous" wn "WordNet (r) 2.0"
18:00:10 <lambdabot> perspicuous
18:00:10 <lambdabot>      adj : (of language) transparently clear; easily understandable;
18:00:10 <lambdabot>            "writes in a limpid style"; "lucid directions"; "a
18:00:10 <lambdabot>            luculent oration"- Robert Burton; "pellucid prose"; "a
18:00:11 <lambdabot> [3 @more lines]
18:00:29 <mreh> sounds like a latin root
18:01:06 * increpare never heard of luculent as a variant of lucid before...
18:01:46 <Twey> Yep
18:01:55 <Twey> From ‘perspicuus’
18:02:09 <Twey> Earlier from ‘perspicere’, to see through
18:02:31 <mreh> limpid just sounds like a mollusc
18:03:11 <mreh> @google Kleisli
18:03:12 <lambdabot> http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html
18:03:12 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ...
18:03:58 <Twey> That's a limpet :þ
18:04:07 <DarthShrine> I have the fortunate pleasure of reading in a large number (10^6) of integers, each of which are on separate lines for processing, then writing the back to the file. However, even just the reading, converting and writing takes about 35 seconds on my PC (compared to 1.5 for the C equivalent).
18:04:30 <Twey> DarthShrine: Bet you're not using ByteStrings
18:05:32 <DarthShrine> Twey: Bet you're right. I'm pretty new to Haskell.
18:06:04 <Twey> DarthShrine: Give RWH a read
18:06:08 <Twey> @where rwh
18:06:09 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:06:22 <DarthShrine> Twey: Okay, thanks.
18:07:01 <mreh> isn't bind the Kleisli arrow?
18:07:29 <ivanm> Twey: IIRC, he's doing show . abs . read ...
18:09:14 <theorbtwo> I'm working through Real World Haskell myself.  It's pretty good, so far.
18:09:35 <DarthShrine> ivanm: Well, sorted on absolute values, yes. But the fact that the IO itself, just read and show is taking 35 seconds is part of the problem.
18:09:36 <increpare> mreh: don't think so
18:10:03 <increpare> it doesn't take a non-monad-related function a->b as input, for one
18:10:12 <mreh> I am warpping my brane round A Neighbourhood of infinity, I like this blog
18:10:19 <increpare> I'm also fond of it
18:10:30 <mreh> increpare: you're correct
18:10:38 <mreh> so it's a little like liftM
18:10:48 <mreh> or is it... the same!
18:10:50 <PeakerWork> DarthShrine: Using the String type is pretty slow, the standard read/show use that
18:11:47 <mreh> @wn monoid
18:11:48 <lambdabot> No match for "monoid".
18:12:14 <Twey> And the standard IO functions, probably more relevantly
18:13:03 <Eduard_Munteanu> Any math-oriented Haskell books you'd recommend? I mean I'd happily make my way through some category theory if it is fun.
18:13:04 <increpare> @pl \f e -> e (fmap f)
18:13:04 <lambdabot> flip id . fmap
18:14:07 <mreh> I'm with Eduard_Munteanu, i have time off, so I might do the same
18:14:21 <increpare> I haven't come across any too interesting theoretical books myself
18:14:30 <increpare> mainly end up going to papers or blogs for that sort of stuff
18:15:46 <mreh> not knowing the theoretical basis gnaws away at me a little
18:16:04 <mreh> seeing as it is so formal
18:16:33 <mreh> this is what happens when you do an undergraduate degree at UCL
18:18:27 <mreh> liftM f a = do { a' <- a ; return f a' } -- this doesn't look right
18:18:34 <mreh> should it be return $ f a'
18:19:05 <Twey> Who said that?
18:19:07 <Twey> @src liftM
18:19:08 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:19:28 <mreh> yey!
18:19:45 <alp_> mreh, you still studying @ UCL ?
18:19:48 <mreh> this clown! http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#functors
18:19:50 <mreh> alp_ yes
18:19:56 <alp_> mreh, which year ?
18:20:04 <mreh> alp_ are you faculty?
18:20:19 <alp_> mreh, no, student too, and I got a friend there
18:20:27 <mreh> i'm a masters student
18:20:44 <Twey> liftM = flip (>>=) . (return .)
18:20:45 <joe1> i am trying to understand how this piece of code works: ($ "foo") reverse
18:20:49 <Twey> :t liftM
18:20:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:20:56 <Twey> :t flip (>>=) . (return .)
18:20:56 <alp_> ok
18:20:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
18:21:00 <mreh> joel: ($ "foo") is a section
18:21:03 <Twey> \o/
18:21:20 <mreh> do  you know about sections
18:21:27 <mreh> alp_ what year are you at?
18:21:53 <joe1> mreh: i have never heard about sections. will get back to the manual about it.
18:21:55 <joe1> thanks.
18:21:59 <Twey> joe1: ($ "foo") reverse ⇒ ($) reverse "foo" ⇒ reverse "foo" ⇒ "oof"
18:22:05 <Twey> > (+ 1) 3
18:22:07 <lambdabot>   4
18:22:26 <alp_> mreh, I'll get my undergrad degree this year. But I'm in France. Though, I have a friend at UCL, in 2nd (undergrad) year
18:22:39 <joe1> :t ($)
18:22:40 <lambdabot> forall a b. (a -> b) -> a -> b
18:22:45 <mreh> alp_ don't talk to me about undergraduates
18:22:50 <Berengal> map (+1) [1,2,3]
18:22:56 <Berengal> > map (+1) [1,2,3]
18:22:57 <lambdabot>   [2,3,4]
18:23:09 <mreh> > map (1+) [1,2,3]
18:23:10 <lambdabot>   [2,3,4]
18:23:14 <alp_> mreh, why ? :D
18:23:23 <mreh> alp_ you all know why :)
18:23:43 <Berengal> > map ($1) [(+1) , (*2)]
18:23:44 <lambdabot>   [2,2]
18:24:03 <Eduard_Munteanu> > take 3 $ iterate (1+) 2
18:24:04 <lambdabot>   [2,3,4]
18:24:19 <Eduard_Munteanu> :P
18:24:36 <stoop> > [2, 3, 4]
18:24:38 <lambdabot>   [2,3,4]
18:24:41 <stoop> :-)
18:24:49 <stoop> > map id [2 .. 4]
18:24:50 <lambdabot>   [2,3,4]
18:24:54 <Eduard_Munteanu> :D
18:25:14 <mreh> did you see the OCC winner, I think it was last year, or maybe a few years back
18:25:26 <joe1> twey: thanks.
18:25:39 <mreh> it was the shortest self replicating program, it printed zero bytes and was zero bytes in length
18:25:55 <Eduard_Munteanu> Um?!?!
18:26:00 <Eduard_Munteanu> That's trivial! :D
18:26:04 <dmhouse> mreh: that's an old one
18:26:14 <Eduard_Munteanu> That's the trivial quine.
18:26:35 <mreh> the rules were changed as a consequence
18:26:43 <kmc> how does that manage to compile and run as a valid C program?
18:26:46 <Eduard_Munteanu> Heh... did he receive the prize?
18:26:51 <kmc> would not there be a linker error?
18:26:54 <mreh> Eduard_Munteanu, yes
18:26:58 <pikhq> kmc: It's not valid.
18:27:13 <Twey> mreh: That was ages ago ☺
18:27:17 <pikhq> However, most C compilers will emit a no-op main for that.
18:27:19 <Eduard_Munteanu> kmc, he probably did tricks in the compiler arguments, which didn't qualify as code
18:27:19 <Twey> kmc: Makefile hacker
18:27:20 <Twey> y
18:27:28 <Twey> Yeah
18:27:35 <Twey> The Makefile was excluded
18:27:54 <Twey> Hm, for that matter… I wonder if it would be possible to include a lot of echo statements in the Makefile :þ
18:28:08 <theorbtwo> I'm surprised they haven't modified the rules to make that sort of trickery just not work.  It's been done, you know?
18:28:09 <Eduard_Munteanu> Yeah though that kinda qualifies as code.
18:29:03 <pikhq> Twey: The hack for "" working was much simpler: the compiler would emit "main: ret" for an executable without a main at the time.
18:29:06 <Eduard_Munteanu> Then I'll enter next year with an asm-written thingy that disassembles itself using binutils libs :)
18:29:10 <pikhq> It no longer does.
18:29:16 <Eduard_Munteanu> That's kinda trivial as well.
18:29:46 <Eduard_Munteanu> You don't even need to do I/O for that.
18:30:03 <pikhq> The rules have since been amended to require 1 or more characters in your program.
18:30:31 <Eduard_Munteanu> pikhq, what if I write it in asm ^ ?
18:30:36 <theorbtwo> I think in their place, I'd specifiy a compiler command line, and not let you write your own makefile.
18:30:48 <pikhq> Eduard_Munteanu: It's a *C* contest.
18:31:03 <theorbtwo> It's supposed to be the international obfuscaed *C* competition, not obfuscated Make.
18:31:07 <Eduard_Munteanu> Oh.
18:31:24 <theorbtwo> If it were the IOMC, GNU autofoo would win every year.
18:31:43 <pikhq> theorbtwo: Make hackery doesn't win mostly because "it's lame", quoth the judges.
18:32:53 <theorbtwo> pikhq: Hm, fair point, I guess, though there's a few objective categores, I thought.
18:33:08 <pikhq> No, it's a pretty subjective contest.
18:33:42 <Twey> pikhq: Can the characters be ‘//’?  ;)
18:34:11 <pikhq> Twey: Not a quine, just a dumb program.
18:34:15 <pikhq> And won't compile in modern GCC.
18:34:22 <pikhq> Well, won't compile *and link*.
18:34:24 <theorbtwo> Twey: Sure, but I don't think a C program consisting only of // will print it's own source code when executed.
18:34:46 <Twey> No, but if that's the only precaution they took against Makefile hackery…
18:35:54 <theorbtwo> Twey: It might validly solve the problem, and be quite short indeed, and still not win, because it's not any fun.
18:37:35 <Twey> True :þ
19:05:33 <mistermattaway> haha wow, the last problem in real world haskell chapter 3 is implementing a convex hull algorithm
19:06:53 <monochrom> oooh that is neato
19:06:59 <monochrom> @quote monochrom chapter
19:07:00 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
19:07:31 <monochrom> Seems like I have to update my quote. "by chapter it's already doing convex hull" hahaha
19:08:06 <monochrom> Oops, omitted "3" there.
19:08:19 <mistermattaway> yeah I wasn't expecting to see that at all
19:08:25 <mistermattaway> I'm going to try to do it too
19:33:23 <solidsnack> I'm trying to use the GHC API to parse a string with a module in it, like: "module Foo.Bar where..."
19:33:46 <solidsnack> However, the GHC API is pretty complicated and I'm not sure where to get started with this.
19:34:11 <pikhq> solidsnack: Use Parsec.
19:34:20 <solidsnack> It has a Haskell parser?
19:34:37 <pikhq> It might only be an H98 parser, but yes.
19:37:44 <solidsnack> pikhq: Well, that might be very bad for me; I wouldn't want it to vomit on `deriving instance` or other extensions.
19:39:27 <solidsnack> I'm going to try Scion -- it claims to be a reasonable abstraction of the GHC API.
19:39:28 <ivanm> use haskell-src-exts
19:43:41 <deech> Hi all, I am working on a Haskell Web Application Server and I want to use a config file written in Haskell in the style of xmonad. How does xmonad evaluate its config file?
19:44:24 <Eduard_Munteanu> deech, it seems to be compiled and ran.
19:44:31 <xerox> I think it compiles it as part of its new binary when it recompiles itself
19:44:33 <Eduard_Munteanu> deech, it has a main defined.
19:45:01 <deech> so how does it recompile itself?
19:45:41 <Eduard_Munteanu> deech, simply calls the compiler IIRC. The config script then runs xmonad by invoking the 'xmonad' function
19:46:34 <deech> Eduard_Munteanu: But that would mean that the entire xmonad source in recompiled everytime a change is made in the config file. I dont t
19:46:50 <deech> hink this is exactly how it works.
19:46:57 <Eduard_Munteanu> deech, no, only the config file, the rest is linked in.
19:47:36 <Eduard_Munteanu> deech, you don't recompile glibc everytime you compile programs.
19:47:39 <kmc> deech, the relevant package is 'dyre'
19:48:23 <kmc> xmonad is a library which is installed in the normal way, with precompiled binarys + .hi files
19:48:35 <kmc> your xmonad.hs is the main module of a custom window manager written using the xmonad library
19:48:51 <kmc> it uses either dyre or something very similar to manage recompilation and reloading state
19:49:19 <deech> kmc: Ah ah! Cool, that's what I was looking for. Thanks@
19:51:09 <Veinor> blah. I want to do some coding but the only machine I have available to me with ghc installed is a remote shell server
19:51:41 <Veinor> and I don't feel like using emacs in a terminal ;/
19:51:55 <kmc> X forward it?
19:52:59 <Veinor> not on Linux at the moment
19:53:17 <Veinor> I don't even know if it has X :P
19:53:19 <pikhq> X forward it?
19:53:33 <pikhq> You could install Xlib in ~. :P
19:53:40 <Veinor> ewwww.
19:53:46 <pikhq> Yeah.
19:53:53 <Veinor> Maybe I should just suck it up and learn how to use emacs from a terminal.
19:54:19 <holmak> or vim!
19:54:40 <Veinor> ewwwwww!
19:55:11 <holmak> haha
19:56:10 <Veinor> right now all I know is C-x C-s and C-x C-f :(
19:56:45 <kmc> write your own editor
19:56:54 <holmak> i tried learning vim and emacs about three times each
19:57:00 <holmak> vim stuck first
19:57:28 <lispy|web> I use ed for everytihng
19:57:33 <lispy|web> Sooo much easier
19:57:33 <holmak> what a champ
19:57:49 <lispy|web> :)  Really I use a mixture of emacs/vi
19:58:13 <lispy|web> anyone using yi these days?
19:58:27 <lispy|web> A friend of mine tried to cabal install yi and ran into a lot of trouble
19:58:44 <holmak> what are the dependencies? gtk?
19:58:51 <lispy|web> he started on ghc-6.10.4 and then tried 6.12.1, but he couldn't make it happy on either
19:59:17 <lispy|web> holmak: I'm not really sure.  Back in the day it was ncurses
20:00:45 <Eduard_Munteanu> Real programmers use Vim...
20:00:52 <Eduard_Munteanu> [and that's how it begins]
20:01:03 <hiptobecubic> Here here!
20:01:08 <hiptobecubic> or is it hear
20:01:15 <hiptobecubic> i believe it's hear
20:01:16 <Eduard_Munteanu> I mean the xkcd comic if you know it.
20:01:16 <deh> Veinor: "C-h i" is pretty useful
20:01:20 * hiptobecubic wanders off...
20:01:26 <lispy|web> Eduard_Munteanu: yeah, that's a good one
20:01:34 <Eduard_Munteanu> C-m C-x butterfly :D
20:01:42 <monochrom> Real programmers read Real World Haskell.
20:01:52 <Veinor> I read RWH.
20:02:13 <Veinor> read as in 'am reading'. print version. It's pretty good, but there are some glaring errors. :/
20:02:15 <monochrom> @quote monochrom real
20:02:16 <lambdabot> monochrom says: Real World Haskell is not a spectator sport. :)
20:02:16 <holmak> I like RWH pretty well, though it seems to have tons of small errors
20:02:20 <Veinor> Yeah.
20:02:38 <holmak> Is there are RWH second edition?
20:02:46 <holmak> I might buy such a thing
20:02:47 <Veinor> like, one instance where it says 'now we have to do X to make this work, and these are the results once we do X'
20:02:52 <Veinor> then it shows you what happens if you don't do X :/
20:03:12 <Veinor> and in the 'popular misconceptions about monads' section, the 'Monads are just for controlling flow' subsection is completely blank.
20:03:54 <Veinor> granted, it's only a couple sentences, but still.
20:09:55 <deh> So what's the situation with building using MinGW on Windows?
20:10:05 <deh> The PATH line in the middle of http://hackage.haskell.org/trac/ghc/wiki/Building/Preparation/Windows
20:10:12 <deh> refers to /c/mingw/bin
20:10:59 <deh> and http://hackage.haskell.org/trac/ghc/wiki/Building/QuickStart mentions c:/mingw in the configure line
20:11:28 <deh> so I added something to the Building/Preparation/Windows page about installing MinGW
20:12:09 <deh> Now I see that GHC ships with an internal MinGW, and if you configure without the special PATH & configure, it works!
20:16:12 <lispy|web> deh: I think it's shipped with an internal C compiler for a long time
20:16:40 <lispy|web> I've never tried to build GHC on windows though.  That sounds like a difficult task :)
20:17:23 <lispy|web> I have occasionally wished GHC had a backend that could generate nice portable C like JHC can
20:18:06 <lispy|web> But even if it did that, writing a clean portable RTS to match is really hard.  How do you have nice support for threading that exploits platform strengths?
20:19:52 <kmc> urg xkcd again
20:19:52 <deh> lispy|web: Building GHC on Windows is actually quite simple (given the wiki instructions)
20:20:06 <kmc> remember that several key Haskell and GHC developers work at Microsoft :)
20:20:14 <kmc> though MS is also trying to compete with Haskell
20:21:02 <kmc> how portable is unregistered ghc C output?
20:21:37 <lispy|web> kmc: I don't know, I've never looked at it.  My hunch is, "works everywhere gcc does"
20:23:05 <kmc> the RTS issue is a tricky one, though
20:23:54 <lispy|web> We should write the RTS is java!
20:24:01 <lispy|web> compile once, run anywhere
20:24:32 <deh> /?
20:24:41 <deh> \?
20:24:58 <kmc> too bad JVM blows for implementing functional languages
20:25:23 <lispy|web> TCO is overrated ;)
20:25:35 <kmc> that's right, just man up and write a for loop
20:25:39 <kmc> that's what real programmers do
20:26:00 <lispy|web> Well, and hand optimize the binary when it's too slow
20:26:20 <lispy|web> If you the compiler optimizes for the exception cases by accident, just tune it with your hex editor
20:27:06 <lispy|web> Oh, my keyboard layout is set to sarcasm to day...
20:36:54 <Veinor> are there any haskell gmail bindings?
20:37:37 <Veinor> er, wait
20:37:41 <Veinor> just use imap, derp
20:38:05 <kmc> anyone here wanna talk about weird cabal-install bugs?
20:38:16 * kmc has done some sleuthing but has hit a bit of a brick wall
20:39:42 <lispy|web> kmc: what is the bug?
20:40:29 <kmc> the one described here and various other places: http://osdir.com/ml/haskell-cafe@haskell.org/2009-09/msg00047.html
20:40:59 <kmc> it affects my system and dcoutts said it was still mysterious and unresolved
20:41:20 <Veinor> how good is HaskellNet for POP/IMAP?
20:45:49 <lispy|web> kmc: can you reproduce it consistently?
20:45:55 <kmc> on my machine, yes
20:46:04 <kmc> including rebuilding from source
20:46:12 <kmc> also with -O0 which was suggested to fix the problem
20:46:15 <lispy|web> kmc: have you used strace to figure out what file it tries to open?
20:46:18 <kmc> yes
20:46:36 <kmc> it opens a file with a nondeterministic single character, often unprintable name
20:46:42 <kmc> which is also what appears in the error message
20:47:10 <lispy|web> ah
20:47:16 <kmc> in other words, weird as hell
20:48:26 <lispy|web> What else do you know about it( the thread you linked to seems light on details)
20:48:34 <lispy|web> Which commands reproduce it?
20:48:49 <kmc> sorry there may be other threads with more details
20:49:22 <kmc> i've been reproducing with "cabal update"
20:49:30 <kmc> others like "cabal install" also hit it
20:49:52 <kmc> the bug is triggered while parsing ~/.cabal/config
20:50:25 <holmak> liftIO is magical! (in a good way)
20:50:29 <lispy|web> does cabal do anything with lazy io?
20:50:33 <lispy|web> :t liftIO
20:50:34 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
20:50:44 <monochrom> oh what fun, it is to ride, non-deterministic getChar, hey!
20:51:01 <kmc> the config file parser IO action yields a result successfully.  when you try to force the config data structure that's when the error is hit
20:51:07 <kmc> which is weird and breaks referential transparency
20:51:16 <kmc> lispy|web, good idea about lazy IO
20:51:19 <holmak> I was trying to figure out how to use monad transformers. liftIO led to success.
20:51:25 <kmc> :t lfit
20:51:26 <lambdabot> Not in scope: `lfit'
20:51:26 <kmc> durr
20:51:27 <kmc> :t lift
20:51:29 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:51:56 <kmc> lift is the more general one.  it goes 'one layer' whereas liftIO goes all the way to the bottom, but only if the bottom is IO
20:52:05 <kmc> also, e.g.
20:52:07 <kmc> :t get
20:52:08 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
20:52:09 <kmc> is also typeclassed
20:52:16 <kmc> so it will work in any transformer stack with State somewhere
20:52:33 <holmak> thanks
20:52:43 <monochrom> so that ErrorT e (StateT s IO) a  can use get directly.
20:52:57 <holmak> It's pretty exciting/arcane stuff
20:52:58 <lispy|web> kmc: I'd grep for unsafeInterleaveIO
20:53:08 <lispy|web> kmc: but, cabal could use something more innocent like readFile
20:53:19 <kmc> it does use readFile i'm pretty sure
20:53:31 <kmc> hmm maybe i can force the list early
20:53:34 * kmc will try
20:53:39 <lispy|web> the strict bytestring version of readFile is safe thought
20:53:45 <kmc> :t \m -> do { m :: StateT () (State ()) (); get }
20:53:47 <lambdabot> StateT () (State ()) () -> StateT () (State ()) ()
20:56:53 <holmak> Most of my problems come from trying to understand what the combination of monads *means*
20:57:23 <holmak> like, what is StateT s Maybe t? Where would you use it?
20:57:32 <holmak> (rhetorical question)
20:57:56 <Jafet> RTFM?
20:58:34 <kmc> @unmtl StateT s Maybe t
20:58:35 <lambdabot> s -> Maybe (t, s)
20:58:35 <lispy|web> (testing my own understanding), that is a transformation of Maybe t, to add state s?
20:59:06 <kmc> holmak, an action in (StateT s Maybe t) depends on state, and does one of two things: a) fail, b) yield a value along with state update
20:59:15 <lispy|web> Interestingly, some of the guys I work with say that mtl is poorly designed and say you should always use monadLib instead
20:59:17 <kmc> as @unmtl shows
21:00:06 <lispy|web> yeah, unmtl looks handy that way
21:00:17 <kmc> @unmtl MaybeT (State s) t
21:00:17 <lambdabot> s -> (Maybe t, s)
21:00:25 <holmak> It is starting to make sense
21:00:33 <holmak> I will meditate on it
21:00:40 <kmc> in this monad, by contrast, the value can "fail" to Nothing, but the state updates will continue through
21:00:45 <holmak> where meditate = poke at ghci
21:00:56 <kmc> you can also think about why there's no IOT :)
21:01:16 <lispy|web> monad transformers are serious business, and I wish I groked them better
21:01:38 <lispy|web> IOT = join :)
21:01:47 <holmak> by the way, what does mtl stand for?
21:01:56 <lispy|web> monad transformer library
21:02:01 <holmak> ah
21:02:02 <lispy|web> (I think)
21:02:24 <lispy|web> IANAE (I'm not an expert ;)
21:03:14 <kmc> in isolation, it's easier to reason about a single handcrafted monad than about a stack of transformers
21:03:39 <kmc> it's also not at all hard to implement any mtl stack yourself
21:03:44 <kmc> so if you get stuck there's always that route
21:04:24 <kmc> the standard transformers are nice not because they're easy but because they are standard and work across library boundaries
21:05:20 <holmak> Well, I would certainly prefer to reuse code. I hear it is good practice. :D
21:07:14 <lispy|web> holmak: yeah, and there is usually a monad for what you want to do (at least via transformers) the trick is often to give that monad it's own identity in the type system (GeneralizedNewtypeDeriving)
21:07:38 <lispy|web> I've made very powerful use of this in my past endeavors
21:07:57 <lispy|web> I made a nice DSL for generating assembly code instructions
21:08:11 <lispy|web> I used writer to spool it all up, monad unique to create lables
21:08:14 <lispy|web> labels*
21:08:27 <lispy|web> and I used reader to store labels and be able to jump
21:08:52 <lispy|web> I never tested how it scaled in memory usage, but it was quick and easy to wipe up and it worked well for my needs
21:09:32 <holmak> neat!
21:10:05 <lispy|web> I can show you the code if you're interested, oh wait....my server is down
21:10:18 <holmak> I've seen references to this sort of thing; DSLs for generating embedded programming; its a very neat idea
21:10:21 <Peaker> lispy|web: how do you forward-jump?
21:11:05 <Peaker> lispy|web: Monad transformers (at least some of them) are not hard.. explaining MaybeT, for example, is pretty easy
21:11:09 <lispy|web> Peaker: I don't recall.  I was writing a lisp/scheme compiler so my assembly code only supported what I needed
21:11:27 <Peaker> lispy|web: ah, augustuss has an assembly monad too, with forward references via MonadFix (and mdo syntax)
21:11:39 <Peaker> and runtime LLVM bindings to convert that to executable functions in runtime!
21:11:40 <lispy|web> ah, then I probably didn't have that
21:11:48 <lispy|web> I certainly didn't have anything overly fancy
21:11:57 <lispy|web> Peaker: harpy?
21:12:14 <Peaker> not sure
21:12:50 <holmak> do any of you know of a good low-level-code-generating DSL that i can look at?
21:13:19 <holmak> and by good, I mean one that is easy to comprehend
21:13:27 <Peaker> augustuss does pretty awesome stuff
21:13:38 <holmak> I'm curious how you approach this problem
21:13:48 <holmak> Can I google for augustuss?
21:15:26 <Peaker> http://augustss.blogspot.com/2009/01/llvm-arithmetic-so-we-want-to-compute-x.html
21:15:35 <holmak> Thanks!
21:22:41 <Peaker> lispy|web: interested in grokking a transformer example via MaybeT?
21:23:09 <lispy|web> Peaker: sure
21:23:46 <Peaker> I found that I had a common pattern in my code at one point, where I had lots of IO (Maybe a) -- and I wanted a Nothing in there to terminate the computation, so a >>= between two IO (Maybe a)  would break on a contained Nothing
21:24:00 <Peaker> lispy|web: how do you make >>=  on (IO (Maybe a)) behave that way?
21:25:23 <lispy|web> Peaker: hmm....I'm not sure.  But you have a solution?
21:25:37 <Peaker> Well, first we can define our ioMaybeBind
21:26:04 <lispy|web> :t (>>=)
21:26:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:26:16 <Peaker> ioMaybeBind a f = do { xx <- a ; case xx of Nothing -> return Nothing ; Just x -> f x }
21:26:36 <lispy|web> Did you use MonadIO?
21:26:38 <Peaker> we can also define ioMaybeReturn x = return (return x)   (or just  return . return)
21:26:46 <Peaker> nope, this is just a normal function
21:26:57 <Peaker> @type let ioMaybeBind a f = do { xx <- a ; case xx of Nothing -> return Nothing ; Just x -> f x } in ioMaybeBind
21:26:59 <lambdabot> forall (m :: * -> *) t a. (Monad m) => m (Maybe t) -> (t -> m (Maybe a)) -> m (Maybe a)
21:27:34 <Peaker> now, we can newtype this into a Monad, rather than using custom names like ioMaybe*
21:27:48 <Peaker> (note this is generic to all containing monads, not just IO)
21:27:52 <lispy|web> ?untml MaybeT (IO a) t
21:27:53 <lambdabot> Maybe you meant: unmtl unpl
21:28:00 <lispy|web> ?unmtl MaybeT (IO a) t
21:28:01 <lambdabot> IO a (Maybe t)
21:28:10 <Peaker> @unmtl MaybeT IO a
21:28:11 <lambdabot> IO (Maybe a)
21:28:33 <Peaker> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
21:28:51 <Peaker> instance Monad m => Monad (MaybeT m) where
21:28:58 <Peaker>   (>>=) = ioMaybeBind
21:29:02 <Peaker>   return = ioMaybeReturn
21:29:46 <Peaker> so, now, instead of manually pattern-matching against Nothing in our IO results, we can just take our   IO (Maybe a)  values, use "MaybeT" as a function to convert them to MaybeT IO a values, and normally bind
21:30:14 <Peaker> MaybeT :: m (Maybe a) -> MaybeT m a
21:30:47 <Peaker> Then, when we've bound everything together, we just runMaybeT on the result, to get back another IO (Maybe a) of the entire result
21:31:17 <holmak> Interesting.
21:31:19 <lispy|web> cool
21:31:28 <lispy|web> Peaker: did you blog about this?
21:31:34 <Peaker> So now, we're almost done -- but we still have one thing missing:  When we want to bind our  IO (Maybe a) actions to normal   IO  actions, we need to convert IO actions to MaybeT actions
21:31:41 <Peaker> lispy|web: Nope, I'm too lazy to blog :)
21:32:09 <monochrom> (listToMaybe <$> getLine) >>= \c -> putStrLn ("the first char is " ++ [c])
21:32:09 <holmak> lispy|web: Let's copy this above, make a blog, and slap his name on it
21:32:31 <monochrom> I forgot some liftIO's there.
21:32:41 <lispy|web> I've been meaning to setup my blog again
21:32:48 <lispy|web> I'm grumpy at wordpress
21:33:19 <lispy|web> I know what address I want my blog to be at, and I have the data base for wordpress, but I don't want to run wordpress on my server anymore because it's too exploitable
21:33:19 <Peaker> So to convert an  IO a  value  to an   IO (Maybe a)  value,  we define a "lift" operation:   lift :: Monad m => m a -> MaybeT m a
21:34:00 <Peaker> btw, does anyone know in what cases   lift /= liftM return ?
21:34:07 <Peaker> @type liftM return
21:34:08 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 a1 -> m1 (m a1)
21:34:28 <lispy|web> :t lift
21:34:30 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
21:34:44 <lispy|web> Precisely when you need MonadTrans?
21:34:56 <Peaker> This part I'm not entirely sure about.., In the Monad Transformers I remember/understand,  lift is just  liftM return.  But it must be wrong for other monads
21:35:13 <Peaker> well, anyway, let's assume liftM return is wrong for other monad transformers :)
21:35:27 <Peaker> but for MaybeT I think its the same, so there's the MonadTrans class
21:35:29 <Peaker> @src MonadTrans
21:35:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
21:36:01 <Peaker> class MonadTrans t :: * -> * -> * where lift :: Monad m => m a -> t m a
21:36:31 <Peaker> instance MonadTrans MaybeT where lift = liftM return
21:37:04 <lispy|web> interesting
21:37:09 <Peaker> holmak, lispy|web: So one thing cool about MaybeT, is that it gives you the missing loop "break" in your forM, from other languages :)
21:37:27 <lispy|web> Peaker: so lift is very literally, "Hey, inject this value into the inner monad"
21:37:31 <Peaker> Yep
21:37:59 <lispy|web> break = fail?
21:38:01 <Peaker> though "inner" and "outer" are confusing many, because in the MaybeT type the MaybeT is outer, but in the representation the MaybeT is inner
21:38:07 <lispy|web> ?src fail Maybe
21:38:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:38:17 <lispy|web> ?instance Monad Maybe
21:38:18 <lambdabot> Maybe you meant: instances instances-importing
21:38:33 <Peaker> lispy|web: or you can have a specialized MaybeT thing that amounts to   return Nothing   (with the MaybeT wrapping)
21:38:55 <Peaker> btw: I forgot the MaybeT newtype [un]wrapping
21:38:59 <Peaker> in some of my funcs there
21:39:19 <Peaker> ?src Maybe fail
21:39:19 <lambdabot> fail _      = Nothing
21:39:24 <Peaker> though fail would work
21:39:49 <Peaker> say you had:  forM_ [1..10] $ \i -> do { want to break at 5 ; print i }
21:39:57 <lispy|web> Has anyone made a transaction monad?
21:40:05 <c_wraith> STM?
21:40:09 <lispy|web> I guess it would be like, ST, IO, or State, with a rollback
21:40:21 <kmc> State with rollback would be pretty easy
21:40:21 <Axman6> it's called STM ;)
21:40:28 <kmc> STM is like ST with rollback
21:40:30 <Peaker> you can do: runMaybeT . forM_ [1..10] $ \i -> do { break ; lift $ print i }
21:40:55 <kmc> well except without the runST part
21:40:55 <lispy|web> Axman6: STM is a good example of what I'm asking for, but I was implicitly wondering about other examples.  Like file system transactions in IO
21:40:55 <Axman6> lispy|web: STM is like using IORefs/MVars, in transactions
21:40:57 <Peaker> so by wrapping the loop with "runMaybeT" and adding "lift" when you want IO -- you get to break out of any part
21:41:42 <Peaker> its also nice to do:   runMaybeT . forever $ do { ... break ... }
21:41:50 <Peaker> where break = fail ""
21:41:54 <Peaker> (or whatever MaybeT provides)
21:42:23 <monochrom> The problem is you don't just quit the loop.  forever (do { ... break ...}) >> rest  will skip the rest too.
21:42:42 <Peaker> monochrom: I used "runMaybeT . forever... $ ..."
21:42:51 <Peaker> monochrom: so it'll break out of the "forever"
21:43:17 <Peaker> (it'll break out of the "runMaybeT" block
21:43:18 <Peaker> _
21:43:19 <lispy|web> wait, you return from forever?
21:43:19 <Peaker> )
21:43:28 <Peaker> lispy|web: yeah, "forever" is no longer forever..
21:43:35 <Peaker> > forever []
21:43:36 <lambdabot>   []
21:43:43 <Peaker> (in many monads forever is not really forever)
21:43:48 <lispy|web> If you return from forever, then can't you implement unsafeCoerec?
21:43:57 <lispy|web> :t forever
21:43:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:43:59 <Peaker> lispy|web: Nope, because you get a Nothing
21:44:03 <Peaker> not a Just
21:44:12 <Peaker> You get a (Maybe whateveryouwant) with a Nothing inside it
21:44:15 <monochrom> It unsafeCoerces []::[a] to []::[b]. :)
21:44:18 <c_wraith> Maybe can return from forever.  Either e can return from forever.  Anything with similar control flow can.
21:44:20 <Peaker> Yeah :)
21:45:04 <lispy|web> Sometimes the ways types work amazes me
21:45:27 <Peaker> so, just like you can bind in IO while case'ing over Nothing, you can also bind in IO while threading around State (s -> (s, a))
21:45:33 <Peaker> so similarly to MaybeT, there's StateT
21:45:46 <Peaker> and basically almost every monad has the transformer variant
21:45:59 <lispy|web> The control flow in those monads ([], either, maybe) makes sense and is fine.  forever looks like it has a dangerous type if it ever returns (proof from one thing to another thing), and yet it's fine here
21:46:06 <monochrom> > Control.Monad.State.Lazy.evalState
21:46:07 <lambdabot>   Not in scope: `Control.Monad.State.Lazy.evalState'
21:46:21 <Peaker> And then you can define Maybe = MaybeT Identity.  State = StateT Identity - and define all your functions on the StateT, rather than the State
21:46:24 <monochrom> boo
21:47:22 <kmc> :t forever
21:47:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:47:28 <monochrom> m a -> m b is a richer type than a -> b
21:47:29 <Peaker> lispy|web: Logic/Curry Howard at work :)  It would be impossible to break out of forever if you had to create a "Just" with a Void field in it
21:47:38 <kmc> lispy|web, the thing is, a value of type (m a) is not a proof of a
21:47:51 <lispy|web> kmc: yeah, I was thinking about that
21:47:52 <kmc> it is if m is a comonad, but not if it's a monad
21:48:07 <lispy|web> m a -> m b  is different than a -> b in a meaningful way
21:48:11 * copumpkin writes a (_ -> _|_) monad
21:48:12 <kmc> this is the "not every monad has an extractor" thing
21:48:27 <kmc> or more specifically "there is no extractor which works for every monad"
21:48:29 <monochrom> some modal logic may help. m a is a modal statement rather than a propositional statement.
21:48:54 <kmc> monochrom, ah, that's very interesting
21:49:43 <kmc> does that mean that classical logic is a modal logic on top of constructive logic (via Cont)?
21:49:58 <kmc> where the mode Cont means "classically"
21:50:02 <copumpkin> Veinor: what's funny is that table is also french
21:50:20 <kmc> > forever Nothing
21:50:22 <lambdabot>   Nothing
21:50:26 <copumpkin> Nyana
21:50:44 <Peaker> arg, electrical break
21:50:55 <lispy|web> > forever Nothing >> forever [] >> return 1 :: Maybe Int
21:50:56 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
21:50:56 <lambdabot>         against inferred ...
21:51:06 <Peaker> @type forever Nothing
21:51:07 <lambdabot> forall b. Maybe b
21:51:16 <Peaker> @type forever []
21:51:16 <tensorpudding> @type forever
21:51:17 <lambdabot> forall b. [b]
21:51:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:51:19 <lispy|web> > forever Nothing >> return 1 :: Maybe Int
21:51:20 <lambdabot>   Nothing
21:51:55 <Peaker> lispy|web: so there are a couple of last things to know about them :)
21:52:16 <kmc> > forever Nothing == Nothing
21:52:17 <lambdabot>   True
21:52:19 <Peaker> one is that instead of defining operations in a specific monad like MaybeT or like State, the operations tend to be defined in type-classes
21:52:28 <kmc> > forever (Just 3)
21:52:32 <lambdabot>   mueval-core: Time limit exceeded
21:52:51 <Peaker> For example, a MonadState class that has get/put operations - and then the simple State monad is an instance, and so is StateT (and other monads that can implement State)
21:53:03 <Peaker> so when you use "get", it works in any monad that supports it
21:54:18 <Peaker> lispy|web: Now, the annoying thing about monad transformers, is that if you have:  StateT s (MaybeT IO) a  -- you have to "count" the lifters.  If you want an (IO a) operation, you need   lift . lift   or   lift  for MaybeT,  or nothing for StateT. And you can get pretty nested monad transformer stacks
21:55:00 <Peaker> There are 2 solutions to this.  One is a horrible one (IMO :) which is to define that basically all Monad transformers have an instance of MonadState that just "relays" it to the inner monad
21:55:22 <Peaker> (this means each monad transformer you define must instantiate a class of each other monad in existence. an O(N^2) code explosion!)
21:55:43 <lispy|web> Peaker: I've used newtypes to solve this problem
21:55:47 <Peaker> Yeah
21:55:55 <Peaker> newtype + named lifters for each layer
21:56:00 <Peaker> That's the nice solution
21:56:34 <Peaker> There is still a bit of clumsiness involved (boilerplate lifter code, lots of "liftBlah" prefixes in code) but I think its a minor nuisance
21:56:53 <Peaker> (compare to O(N^2) code explosion, for example)
21:57:52 <Peaker> IO, btw, cannot have a transformer unless you have a time machine
21:58:26 <c_wraith> What's the alternate monad composition thing that's been mentioned a couple times?
21:58:29 <kmc> usually i implement a few domain-specific actions on my newtyped transformer stack and use those throughout
21:58:49 <Peaker> kmc: IOW you use the transformer stack to implement a new monad with its own "opaque" operations
21:58:53 <kmc> yes
21:58:56 <kmc> exactly
21:59:09 <kmc> in that sense it's best not to even derive MonadState, MonadError, etc.
21:59:55 <kmc> maybe you have IO in the stack, but want to restrict the actual forms of IO
22:00:06 <kmc> e.g. allow threads but not file or network access
22:00:13 <Peaker> e.g: IOT Maybe a would be:  Maybe (IO a)   and (>>=) would allow using the result of an IO to determine whether to bind to Nothing in the outer monad -- so if you bind a bunch of IOT Maybe a  together, you might end up depending on actions' execution to determine the whole result is a Nothing - which is an impossibility, because a Nothing contains no action at all
22:00:54 <Peaker> kmc: Yeah, btw, your newtype doesn't have MonadIO/MonadTrans/etc so they can't escape to IO using MonadIO
22:01:02 <kmc> yeah
22:01:11 <Peaker> kmc: oh, that's what you meant by "not derive"
22:01:31 <kmc> right, i'd use GenNewTDer for Monad but not MonadIO, etc
22:01:40 <kmc> and they can't define MonadIO because i'd not export the constructor
22:02:07 <Peaker> yeah.  Haskell has wonderfully simple encapsulation :)
22:02:13 <Peaker> (Don't export stuff)
22:02:22 <kmc> it's fun how when designing good modular code you have to wear many hats and talk about "the user" and "the implementor" even though they may be the same person
22:02:25 <Peaker> Instead of "private" keywords and the likes :P
22:05:45 <lispy|web> kmc: like how the engineer who designs cars might also drive them?
22:06:47 <Jafet> The implementor is you now, and the user is you in a week's time
22:06:53 <Jafet> So it depends on how masochistic you are
22:23:33 <merehap> startx
22:23:41 <merehap> oops wrong screen :)
22:33:58 <jz87> hey
22:34:09 <jz87> have anyone tried installing Yi with GHC?
22:34:17 <jz87> I've tried 6.12.1 and 6.10.4
22:34:18 <jz87> and neither work
22:34:36 <jz87> I've been trying to migrate from emacs
22:34:48 <jz87> since haskell is easier to write than elisp
22:34:56 <jz87> but just getting things to work have been difficult
22:36:15 <lispy|web> jz87: a friend of mine is having the same trouble
22:36:22 <lispy|web> I don't know how you're supposed to build it right now
22:36:31 <lispy|web> Is there a website that says what versions to use?
22:36:47 <jz87> I got stuck on the template-haskell step
22:37:02 <jz87> it seems that template-haskell doesn't like 6.10.4
22:37:36 <kmc> isn't TH included in 6.10.4?
22:37:50 <kmc> hmm guess not
22:38:00 <kmc> anyway i have used TH with 6.10.4 for sure
22:38:03 <lispy|web> http://haskell.org/haskellwiki/Yi#Installation  <-- do you have to use 6.8.x?
22:38:03 <jz87> it has template haskell 2.3
22:38:15 <jz87> yi needs template haskell 2.4
22:38:27 <kmc> can you get an older version of yi?
22:38:52 <jz87> is there a way to specify version with cabal-install?
22:39:03 <jz87> which version of ghc is yi supposed to work with?
22:39:11 <jz87> if it doesn't work with 6.10.4 and not with 6.12.1
22:43:02 <kmc> well i imagine some version of yi works with 6.10.4
22:43:10 <kmc> and yes i think you can specify, but i don't know how
22:43:13 <kmc> or you can always download the tarball
22:43:27 <jz87> yeah but then you have to do manual dependency management
22:43:54 <jz87> this is really unnecessarily painful
22:45:15 <lispy|web> jfoutz: try, cabal install --constraint="template-haskell < 2.4"
22:45:17 <lispy|web> er
22:45:24 <lispy|web> jz87: ^^
22:45:38 <lispy|web> It works fine
22:45:46 <lispy|web> on ghc-6.4.10
22:45:52 <lispy|web> er, ghc-6.10.4
22:49:57 <copumpkin> preflex: seen FunctorSalad
22:49:58 <preflex>  FunctorSalad was last seen on #haskell-blah 19 days, 4 hours, 20 minutes and 12 seconds ago, saying: and too lazy to get it tested...
23:05:19 <roostaj> happy holidays everyone
23:07:06 <roostaj> i was curious as to what level of success any sort of AI has been implemented in haskell
23:07:49 <elly> probably the same level of success as all other AI projects
23:07:53 <elly> i.e., AI is still really hard
23:08:20 <roostaj> elly: :), I guess I was refering to a comparison to imperative languages at least
23:08:28 <elly> heh :P
23:09:12 <roostaj> i see there is an effort on HaskellWiki to gather some codebase
23:09:55 <roostaj> elly: I don't claim to actually know anything about the topic, i was just curious :)
23:10:01 <elly> I don't either!
23:10:06 <elly> I just know that AI is hard :P
23:10:13 * roostaj dances
23:10:26 <roostaj> elly: :) there just seems to be a knack for AI people to like languages such as LISP
23:10:41 <roostaj> elly: I have little insight as to why, but it led me to the question regardless
23:11:11 <elly> well, wait around and someone who knows will answer
23:11:50 <kmc> i'm not sure the reasons AI people like Lisp would translate to Haskell
23:12:07 <kmc> the two are pretty different
23:12:37 <lispy|web> jz87: I've updated the FAQ on the haskell wiki about building yi
23:13:18 <roostaj> kmc: hmm... what are the reasons?
23:13:42 <lispy|web> some lisp people do switch to haskell
23:13:43 <kmc> roostaj, i have no idea.  i can speculate and think of plausible ones that would not translate
23:13:54 <roostaj> kmc: such as?
23:13:56 <kmc> i think Lisp was simply by far the most expressive language, for a period of decades
23:14:11 <lispy|web> lisp is painfully expressive
23:14:20 <Jafet> It depends on what is to be expressed
23:14:22 <lispy|web> It's hard to write large system in lisp without a lot of discipline
23:14:26 <kmc> roostaj, ubiquitous metaprogramming, dynamic types, homoiconicity, implementations that unify compile and runtime
23:14:45 <kmc> these are all things we can do in Haskell, but they're not defining aspects of the language
23:14:52 * lispy|web has worked on large lisp code bases
23:15:08 <lispy|web> It can be a nightmare
23:15:13 <roostaj> lispy|web: it's in your name!
23:15:21 <Jafet> Well, if your programmers are all allowed to define their own languages, it would get tricky
23:16:30 <lispy|web> lisp and haskell are kindered spirits
23:16:40 <lispy|web> But, where lisp invests in meta programming haskell invests in types
23:16:58 <lispy|web> each is possible in both, but the emphasis is different
23:17:14 <roostaj> lispy|web: i see
23:17:15 <kmc> does Lisp have anything resembling static types?
23:17:26 <lispy|web> kmc: SBCL does
23:17:32 <roostaj> is the functional programming methodology preferable to ai programming?
23:17:35 <kmc> how's that work?
23:17:50 <kmc> roostaj, i think it's preferable in general
23:17:58 <lispy|web> kmc: but they work more like hints and run-time assertions, although the compiler can sometimes figure them out statically which is useful for optimizations
23:17:58 <kmc> i also think you can write non-functional code in Lisp, and in Haskell
23:18:04 <roostaj> kmc: :)
23:18:08 <kmc> lispy|web, well, runtime assertions are not static types
23:18:12 <Jafet> PLT has a Haskell-inspired toy "typed scheme"
23:18:24 <kmc> Jafet, is it based on simply typed lambda calculus?
23:18:28 <lispy|web> kmc: it does have static ones though.  just not with full language generality
23:18:43 <Jafet> I believe it has some polymorphism, but you should check
23:18:45 <roostaj> kmc: i thought haskell was "purely' functional?
23:18:51 <lispy|web> kmc: but sometimes it's perfectly sane in a lisp program to know what type you'll get statically
23:18:55 <Adamant> Qi also had types IIRC
23:19:00 <Adamant> but it's kind of on hiatus
23:19:16 <kmc> roostaj, it depends what you mean by all these terms, and nobody will agree
23:19:24 <hiredman> Qi had an embedded prolog for manipulating its types
23:19:32 <Jafet> I've heard what lispy is saying described as "soft typing"
23:19:38 <roostaj> kmc: fair enough. I haven't gotten far enough into my "Haskell training" to form an opinion i suppsoe
23:19:40 <Jafet> On LtU
23:19:51 <kmc> if by "purely functional" you mean "no side effects", then Haskell is the *opposite* of purely functional. we have made side effects first-class and elevated them from being a mere aspect of functions to being a type in their own right.
23:20:01 <Jafet> roostaj, as opposed to PHP, which is purely dysfunctional
23:20:07 <kmc> Haskell has side effects; Haskell *functions* have no side effects
23:20:07 <roostaj> Jafet: :D
23:21:06 <kmc> what i mean by "non-functional" code is some combination of a) does not use the feature of first-class functions, and b) uses mutable state excessively
23:21:17 <kmc> you can write code like that in Lisp, or in Haskell.  Haskell has a bit more of a stigma against it
23:21:28 <Jafet> Common Lisp is full of it
23:21:35 <Jafet> The b) part, that is
23:21:43 <hiredman> full of a lot of stuff
23:21:45 <kmc> isn't the standard sort procedure in Lisp destructive?
23:21:55 <lispy|web> usually in CL if you want to use (b) you hide it behind an api that looks functional
23:22:00 <roostaj> kmc: hmm... so you can mutate data in haskell?
23:22:15 <kmc> roostaj, sure thing.  we have plenty of types that represent mutable data stores
23:22:15 <Jafet> You can express the mutation of data in Haskell.
23:22:26 <kmc> IORef, STRef, MVar, TVar, IOUArray...
23:22:27 <hiredman> there is no Lisp, there are lisps
23:22:32 <kmc> hiredman, there is Common lisp
23:22:34 <roostaj> kmc: sort of against the spirit :)?
23:22:37 <lispy|web> Which is analogous to us using ST or state within the function but having the function itself look pure
23:23:11 <lispy|web> Since lisp is eager, you need this more than in Haskell
23:23:12 <kmc> roostaj, the way I see it:  we write functional programs to manipulate whatever data type is appropriate to the task at hand.  sometimes the data we manipulate is "sequence of steps"
23:23:27 <hiredman> kmc: sure, but if you mean "common lisp" it is best to say "common lisp" instead of "lisp"
23:23:30 <lispy|web> Laziness means you don't need as much of the pure api/mutable state under the hood idiom
23:23:31 <kmc> sure
23:23:48 <kmc> most Lisps before CL didn't have lexical scoping, which imo means they lack true first-class functions
23:24:07 <kmc> for the same reason C does
23:24:09 <lispy|web> CL is sort of amazing actually
23:24:09 <hiredman> actually scheme brought lexical scoping main stream
23:24:21 <hiredman> well, lisp mainstream
23:24:53 <hiredman> (The Evolution of Lisp is a neat paper)
23:24:54 <lispy|web> They "unified" many lisps and it's taken years to actualize a conformant CL compiler.  Which essentially means that standardizing it killed it.  But it may have already been dead.
23:25:31 <roostaj> kmc: so, imperative style sequencial, "pure" functions? lol
23:25:38 <lispy|web> IMO, the biggest problem with CL is that it has no real future.  The fact that it lacks good static types is just icing on the cake.
23:25:43 <kmc> roostaj, i'm not sure what you mean
23:25:49 <roostaj> kmc: me neither!
23:26:06 <kmc> roostaj, in Haskell, a function never has a side effect.  a function can return a value which represents an unperformed side effect
23:26:12 <lispy|web> The Haskell community is a beacon of light by comparison
23:26:23 * j4cbo is still an enormous fan of Standard ML
23:26:23 <kmc> these effects are actually performed through a mechanism unrelated to function application
23:26:28 * j4cbo is aware of how weird that makes him
23:26:55 <roostaj> kmc: ah, so now you are just SIMULATING mutation
23:27:03 <kmc> roostaj, "simulating"?
23:27:03 <roostaj> kmc: without it actually happening?
23:27:09 <kmc> at what level?
23:27:13 <kmc> i am talking about the semantics of the language
23:27:22 <Adamant> j4cbo: eagerness is nice sometimes
23:27:25 <kmc> on the machine, with GHC, an STRef update is an actual honest to god in-place update
23:27:26 <elly> j4cbo: you're weird for other reasons too
23:27:32 <roostaj> kmc: ah ok
23:27:37 <Adamant> yeah, but awesome weird
23:27:52 <kmc> roostaj, the idea is: functions and mutation actions are totally different things.  let's have different types for them
23:28:03 <kmc> this is why neither "main" nor "getChar" is a function
23:28:14 <kmc> "putChar" is a function that returns an action
23:28:38 <j4cbo> to quote bob harper, "the advantage of lazy languages is that side effects become encoded in the type system; the disadvantage of lazy languages is that side effects become encoded in the type system."
23:28:58 <kmc> hmm that quote conflates a bunch of issues
23:28:59 <roostaj> kmc: ah ok, i get it. The functions are guaranteed to have no side effects-- but if its not a function... it's no longer the case
23:29:16 <j4cbo> well
23:29:16 <kmc> roostaj, well.  *evaluating* a value never has a side effect
23:29:24 <kmc> evaluating (putChar 'x') does not put a char
23:29:28 <kmc> > putChar 'x'
23:29:30 <lambdabot>   <IO ()>
23:29:34 <dblhelix> merry christmas, #haskell
23:29:42 <j4cbo> i forget the exact phrasing; it was probably something other than "lazy"
23:30:09 <j4cbo> since harper is careful about that sort of thing
23:30:34 <kmc> roostaj, here is a value representing a side effect:
23:30:38 <kmc> > "send a packet to google.com"
23:30:39 <lambdabot>   "send a packet to google.com"
23:30:43 <kmc> evaluating it does not send a packet to google.com
23:30:45 <kmc> it's just a description
23:30:56 <kmc> a value of type "IO a" is like that, except the description is machine-readable
23:31:27 <roostaj> kmc: ah, i see
23:31:27 <kmc> to run a Haskell program, you *first* evaluate "main" to such a description, *then* you do what the description says
23:31:37 <kmc> (except in practice these things need to happen at once)
23:31:38 <roostaj> kmc: interesting
23:31:48 <roostaj> kmc: i haven't gotten that deep into haskell yet :)
23:32:16 <kmc> so this is really nice.  every function has exactly one argument.  no function has side effects.  evaluation never has side effects.  yet we have excellent first-class support for side effects
23:32:42 <dblhelix_> sometimes it helps (for me) to think about a function that produces an IO-value as a function that *computes* an imperative program (but that doesn't *run* the imperatieve program); at top level, main then, ultimately, produces such a program---and that's the program that's run
23:34:06 <Jafet> The evaluation and effectation steps are interdependent, tnhough
23:36:03 <dblhelix> jafet: but you shouldn't worry about that during your first encounters with Haskell's IO
23:36:42 <Jafet> Depends on how rigorous you want yourself to think
23:37:26 <roostaj> kmc: lots to learn in ole' haskell
23:37:45 <kmc> mhm
23:37:52 <roostaj> kmc: rewarding i hope
23:37:57 <kmc> there's always more to learn
23:38:00 <kmc> and yes it is rewarding
23:38:24 <Jafet> It rewards you with distaste for work
23:38:37 <roostaj> Jafet: :O
23:38:50 <dblhelix> jafet: of course... anyway, explaining IO to undergraduates this way has worked out well for me in the past...
23:39:01 <kmc> yes, after you know haskell well, it's annoying to use a language where you have to write literally 10x as much code and spend 10x as much time chasing runtime errors
23:39:14 <roostaj> dblhelix: you a grad student?
23:39:50 <dblhelix> roostaj: yes, I'm a couple of months shy of delivering my PhD thesis
23:40:12 <roostaj> dblhelix: well good luck to you, i'm a undergrad looking to go down that path as well
23:40:25 <roostaj> dblhelix: mind if I ask which school you attend?
23:40:31 <dblhelix> roostaj: thanks
23:40:53 <dblhelix> roostaj: I work at Utrecht University, http://people.cs.uu.nl/stefan
23:43:05 <roostaj> dblhelix: cool, so what level do you teach undergrads Haskell?
23:43:15 <roostaj> (by level I mean classification of student)
23:43:21 <PepeSilvia> he taught me :P
23:43:28 <roostaj> PepeSilvia: :D
23:43:36 <hiptobecubic> dblhelix,  not that you're the webadmin or anything... but http://www.uu.nl/EN/Pages/default.aspx
23:43:37 <dblhelix> roostaj: in Utrecht, you learn Haskell in your freshman year
23:44:02 <roostaj> dblhelix: that is exciting. this is assumed to be their first programming langauge?
23:44:25 <PepeSilvia> roostaj: it was the second after java
23:44:37 <copumpkin> same at my school
23:44:58 <dblhelix> roostaj: no, we'll teach them some Java first
23:45:30 <roostaj> PepeSilvia: dblhelix: ah. I so desperately regret not going to a bigger university... my cs department is pretty weak... luckily i also study math and their department is much stronger
23:46:00 <dblhelix> hiptobecubic: lol, it appears as if we're closed for the holidays :)
23:46:03 <hiptobecubic> My school started everyone on C/C++
23:46:09 <hiptobecubic> dblhelix,  :)
23:46:11 <kmc> hiptobecubic, which one?
23:46:17 <hiptobecubic> University of Miami
23:46:21 <kmc> hiptobecubic, i meant, which language
23:46:25 <kmc> C++ is like fourteen times the size of C
23:46:32 <PepeSilvia> we haven't seen any C nor C++ on the other hand
23:46:36 <dblhelix> roostaj: which uni is that?
23:47:11 <roostaj> dblhelix: its a small state school in Texas, USA http://angelo.edu if ou really must know :)
23:47:29 <hiptobecubic> kmc, C++ more than C, although the first few classes aren't focused on learning the language in so much as learning concepts
23:47:31 <dblhelix> roostaj: have you applied for a phd position yet?
23:47:49 <kmc> hiptobecubic, that's quite unfortunate, because C++ badly mangles every important concept of object-oriented programming
23:48:21 <roostaj> dblhelix: i won't graduate until May 2011, so Ii'll start appling to grad school next summer/fall ... I hope to get out of town and do a research program this upcoming summer
23:48:21 <copumpkin> and gives interesting types a bad name, too
23:48:35 <Jafet> I do a lot of C++ and I've never used anything they call "object-oriented"
23:48:53 <Jafet> The metaprogramming and overloading usually gets most things done
23:48:54 <hiptobecubic> kmc, I don't think everyone would agree with you, but java is introduced by the second course if that helps.
23:49:34 <roostaj> i personally think C++ is a terrible language to teach to beginners... I tutor for the department and the students get very wrapped up in syntax errors and types
23:49:36 <j4cbo> Jafet: there is exactly one project i've ever done in which "OOP" has been helpful
23:49:40 <hiptobecubic> I didn't actually study CS anyway. Just took some courses for fun as I was finishing my Bio/Chem degree :)
23:49:40 <j4cbo> (in C++)
23:49:54 <j4cbo> a raytracer.
23:49:59 <kmc> i think OOP is great and that C++ has a terrible version of it
23:50:11 <kmc> in particular, you can't do OOP well without also supporting functional programming
23:50:15 <dblhelix> hiptobecubic, Jafet: and how did you guys stumble upon Haskell?
23:50:16 <j4cbo> kmc: do you like Smalltalk? :P
23:50:21 <kmc> i haven't learned it
23:50:42 <copumpkin> kmc: really? oop seemed like the antithesis of (pure) functional to me, but I'd be interested to hear otherwise
23:50:53 <Jafet> dblhelix, by tripping over scheme
23:51:03 <kmc> copumpkin, by "functional" i mean presence and ease of working with first-class functions
23:51:10 <dblhelix> Jafet: ah, that figures
23:51:11 <roostaj> Jafet: same for me Jafet. nice
23:51:22 <hiptobecubic> dblhelix, a buddy in ##slackware was working on a functional programming project. I asked what he was talking about. After some wikipedia reading, here I am.
23:51:22 <kmc> copumpkin, not necessarily the de-emphasis of state
23:51:40 <dblhelix> hiptobecubic: welcome :)
23:51:48 <lispy|web> hiptobecubic: interesting
23:51:57 <lispy|web> hiptobecubic: people still work on slackware? ;)
23:51:58 <hiptobecubic> dblhelix, you're in utrecht you said, yes?
23:52:13 <hiptobecubic> lispy|web, the world still runs on slackware, yes :)
23:52:33 <dblhelix> hiptobecubic: yes (that is, I work there... I am at home now; it's Christmas Day, you know ;-))
23:52:35 <Jafet> copumpkin, CL's object system takes the idea to some sort of extreme
23:52:47 <lispy|web> hiptobecubic: I moved to debian many years ago and I just assumed slackware disappeared.  I've heard they have little support for GHC :(
23:53:09 <hiptobecubic> lispy|web, i had no trouble installing ghc
23:53:22 <lispy|web> hiptobecubic: from the package manager?
23:53:37 <Adamant> lispy|web: linux distros don't usually die, others just grow around them bigger and more popular
23:53:51 <hiptobecubic> lispy|web, if by 'package manager' you mean SlackBuild script, yes.
23:53:51 <kmc> copumpkin, for example, a method bound to an instance is just a partial application of the underlying function, with closure over the "this" parameter
23:54:04 <copumpkin> kmc: yeah
23:54:17 <kmc> then again i think first-class functions are just fundamental to programming in general.  not having them is not a "paradigm"
23:54:19 <lispy|web> hiptobecubic: okay.  That was the problem the person I spoke with had.  They wanted to install darcs but they couldn't get ghc
23:54:35 <kmc> they're an essential feature that's useful in any general-purpose language
23:54:47 <hiptobecubic> Slackware has a relatively small following i guess. It seems be mostly diehards. Everyone else has jumped ship to arch.
23:54:48 <kmc> regardless of whether you also have state, objects, concurrency, whatever
23:54:52 <Jafet> Any language with functions, that is
23:55:13 <Adamant> hiptobecubic: Slackware users generally either jumped to Debian or Gentoo
23:55:14 <kmc> Jafet, sure.  but i imagine any "general-purpose language" will have something like functions, and i'd want them to be first-class
23:55:22 <hiptobecubic> lispy|web, not sure what they did. I built it without problem.
23:55:29 <Adamant> and a lot of those are now on Ubuntu or Arch
23:55:33 <Jafet> Sure, otherwise you couldn't express abstraction in them.
23:55:49 <copumpkin> kmc: you seem to be defining function = first-class functions
23:55:59 * dblhelix goes and fetch himself some coffee
23:56:08 <kmc> copumpkin, i don't see how... C has functions and they are not first-class
23:56:17 <copumpkin> oh
23:56:19 <copumpkin> I meant functional
23:56:21 <copumpkin> sorry
23:56:24 <kmc> yes
23:56:28 <copumpkin> ah
23:56:37 <kmc> i generally use the definition that functional language = language with first-class functions
23:56:43 <copumpkin> I see
23:56:51 <Jafet> C++ will have lambdas and closures! (Bonus feature: they segfault too)
23:56:52 <hiredman> :|
23:56:52 <kmc> there is widespread disagreement on this
23:57:02 <copumpkin> I'd usually define it as expression-based
23:57:03 <kmc> Jafet, of course, you have to manage their memory manually like everything else
23:57:32 <hiptobecubic> roostaj, you aren't too far from me :)
23:57:41 <roostaj> hiptobecubic: where are you?
23:57:46 <hiptobecubic> roostaj, Lubbock
23:57:56 <roostaj> hiptobecubic: we are sister schools :)
23:58:09 * hiptobecubic isn't a Red Raider ;)
23:58:16 * roostaj must be from LCU?
23:58:27 <roostaj> dont know why i /me'd that
23:58:31 <roostaj> are you at LCU?
23:58:43 <Jafet> It gets muddled by culture. I think kmc's definition is reasonable, but I wouldn't say Python is "functional" even though it fits
23:59:00 <kmc> i think when people contrast "functional" and "imperative" programming as opposing camps, they are often actually contrasting "languages with first-class functions" (including some good imperative languages like Python and Haskell), vs. C++ and Java, which have a specific design flaw
23:59:03 <Adamant> some CL'ers are relatively anti-functional
23:59:13 <hiptobecubic> roostaj, I graduated last may from the University of Miami
23:59:25 <copumpkin> kmc: well, I think that's because most people don't really know the essence of functional programming :P
23:59:28 <roostaj> hiptobecubic: ah i see. what are you doing in lubbock?!?
23:59:36 <copumpkin> kmc: but I'd agree that your definition matches most people's distinction
23:59:44 <hiptobecubic> roostaj, you know.. that's all anyone ever asks me.
