00:00:06 <knobo> |Jedai|: uncles has to be processed.
00:00:20 <aavogt> you can do that one with pencil and paper reasonably
00:00:43 <|Jedai|> knobo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13688
00:00:53 <yitz> scalaLove: so find does just what we have been talking about - it filters a (possibly infinite list), and then returns the first element of the resulting list if it exists.
00:01:14 <|Jedai|> knobo: I think this one works, but there clearly is a repeat of code, we can probably do better
00:01:43 <knobo> what does the '' mean?
00:02:07 <|Jedai|> knobo: oops, it's just a "second" because I have several versions of buildTree in my script
00:02:30 <Zao> knobo: ' is a valid character in names.
00:02:34 <scalaLove> so what is wrong with this code then? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13689#a13689
00:02:51 <Zao> > let f x x' x'' = x + x' + x'' in f 42 3 5
00:02:52 <lambdabot>   50
00:03:30 <|Jedai|> aavogt: apparently it's not so slow (some minutes to finish) since the solution is not so big
00:03:41 <scalaLove> oh oh one posible optimization is for the list not to go [20..] but can it go +20?
00:03:42 <yitz> scalaLove: what is x?
00:04:29 <|Jedai|> scalaLove: [20,40..]
00:04:29 <Botje> [20,40..]
00:04:31 <aavogt> ah, I guess they could have picked 1..100 as the numbers
00:04:38 <Axman6> scalaLove: sounds like a good 20x improvement right there :)
00:04:50 <scalaLove> yep thanks :)
00:05:13 <Botje> are you solving the "number that divides all of [1..20]" one?
00:05:15 <yitz> > [20,40..]
00:05:17 <lambdabot>   [20,40,60,80,100,120,140,160,180,200,220,240,260,280,300,320,340,360,380,40...
00:05:42 <Axman6> scalaLove: when i was doing project euler, i often found that optimisation was the most fun thing :)
00:05:53 <aavogt> scalaLove: look at the infered type: isDivisibleAll :: (Integral a) => t -> a -> a -> Maybe a
00:05:59 <|Jedai|> scalaLove: What's the n parameter of isDivisibleAll ?
00:06:21 <scalaLove> guys give me a sec will paste new code with explanations
00:06:26 <aavogt> that 't' can be anything
00:06:27 * hackagebot upload: hinotify 0.3.1 - Haskell binding to INotify (LennartKolmodin)
00:06:30 * hackagebot upload: hjpath 1.0 - XPath-like syntax for querying JSON (JaroslavGridin)
00:06:30 <yitz> Axman6: i found the opposite. if it was too slow, i went back and looked again at the math. you almost never need optimized code in euler, really.
00:06:54 <yitz> Axman6: so i enjoyed writing *beautiful* code, not optimized.
00:07:01 <Axman6> i've always been too much of a programmer to look at the maths ;)
00:07:03 <|Jedai|> yitz: well that depends what you call "optimization"
00:07:17 <yitz> |Jedai|: true :)
00:07:31 <|Jedai|> yitz: I think "looking at the maths and finding a better way" is just the best optimization you can find
00:07:43 <yitz> agreed
00:08:15 <knobo> |Jedai|: The big file got processed correct now :)
00:09:21 <|Jedai|> knobo: As I said, it's very probably correct now but I think we can simplify the code yet...
00:10:37 <knobo> |Jedai|: That's always fun :) body in GT and EQ are the same, only different "level".
00:11:07 <|Jedai|> knobo: Right, you can delete one, look
00:11:24 <scalaLove> this is understandable i guess http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13690#a13690
00:11:45 <napsy> Hello. I read a text file into a variable and then make a call to "let array = lines content" ... But now I can't traverse the array because it's of type "IO". How do I get the [String] type from the content?
00:12:17 <aavogt> content <- readFile "filename" -- in a do block
00:12:28 <napsy> I do that
00:12:40 <aavogt> then content has type String
00:12:41 <|Jedai|> knobo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13691
00:12:51 <aavogt> and array has type [String]
00:12:55 <napsy> aavogt: http://haskell.pastebin.com/m672c0d2d
00:13:35 <napsy> but the compiler keeps nagging about type mismatch
00:14:16 <opqdonut> napsy: hint: the problem is line 2
00:14:28 <opqdonut> another hint: write a type signature for traverseLines
00:14:49 <napsy> hum
00:15:13 <knobo> wow!
00:15:16 <|Jedai|> knobo: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13640#a13692
00:15:38 <|Jedai|> knobo: with the guard syntax since we only have two cases we don't need the compare :)
00:17:29 <knobo> I really like this :) I can see that haskell is really cool now. This i a "matrix moment" for me :)
00:17:59 <Axman6> heh
00:18:00 <knobo> "I know kung foo" ;)
00:18:14 <aavogt> you've seen kung foo?
00:18:16 <Axman6> @remember knobo I really like this :) I can see that haskell is really cool now. This i a "matrix moment" for me :)
00:18:16 <lambdabot> I will remember.
00:20:18 <scalaLove> this is understandable i guess http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13690#a13690 any help when you are availiable guys? when i execute isDivisibleAll 20 1 20, i press enter in terminal and does nothing, presing enter just makes new empty lines :(
00:21:27 <Jedai> scalaLove: Maybe a lot of patience will help ? You're using brute-force here !! Especially if you try to do it in GHCi
00:21:41 <aavogt> scalaLove: you still have not explained what the first parameter to isDivisibleAll is
00:21:47 <opqdonut> scalaLove: isDivisibleAll is wrong
00:22:14 <Jedai> scalaLove: if you compile it with GHC and execute it, you should probably get the result faster (though it will still takes minutes)
00:22:37 <uochem> scalaLove: maybe compile, like via ghc --make -O2 *.hs
00:22:39 <opqdonut> Jedai: it's an infinite loop
00:22:45 <Axman6> i'd wager more than minutes, from experience
00:22:51 <Jedai> opqdonut: no
00:23:24 <Jedai> opqdonut: but there is an useless parameter "n"
00:23:32 <opqdonut> ah yes
00:23:34 <opqdonut> misread
00:23:40 <opqdonut> that'll take ages yes
00:23:45 <scalaLove> usually when it calculates something u cant type in terminal nothing, but i can now which, i duno means something else maybe infinite loop?
00:24:07 <opqdonut> > product [1..20]
00:24:08 <lambdabot>   2432902008176640000
00:24:12 <Jedai> scalaLove: why is there an "n" parameter in isDivisibleAll, it doesn't appear in the body
00:24:44 <opqdonut> > product [1,2,3,5,7,11,13,17,19] -- the result is about this magnitude
00:24:46 <lambdabot>   9699690
00:24:48 <scalaLove> yes it does :find (\n -> isDivisibleOne n start end) [20,40..]
00:24:51 <opqdonut> oh, it's not that big
00:25:02 <opqdonut> scalaLove: that's a different n
00:25:04 <Jedai> scalaLove: The fact you can write in the terminal doesn't mean anything
00:25:34 <aavogt> it's about 24 times larger?
00:26:01 <Jedai> ah crud, he was disconnected....
00:26:10 <yowgi> opqdonut, you have to account for some other numbers as well
00:26:22 <yowgi> what you wrote isn't divisible by 4, for example
00:26:24 <opqdonut> that's why i said "about"
00:26:27 <opqdonut> yeah
00:26:27 <yowgi> yes :)
00:26:30 <Raynes> He thinks that he's passing n as a parameter to the lambda.
00:26:33 <Raynes> Poor guy. :(
00:26:54 <Jedai> opqdonut: it's a bit more than that though
00:27:01 <aavogt> yeah, should have turned on warnings
00:28:31 <uochem> Have some general questions (Haskell is kinda a break from C++ for me): 1. how's interop with c++ (is it only via C?) 2. what's the Haskell party line on F# (f$harp)?
00:28:43 <Heffalump> uochem: it's only via C
00:28:45 <opqdonut> uochem: via C
00:28:50 <Heffalump> and why do you think there'd be a party line?
00:28:56 <uochem> ok
00:29:00 <Heffalump> I have some personal opinions, being quite experienced with both.
00:29:09 <opqdonut> pray tell?
00:29:17 <scalaLove> i am sorry ubuntu restarted on me can someone copy please to me on PM after i left?
00:29:20 <Jedai> uochem: we're not very "party" oriented in #haskell
00:29:26 <opqdonut> i've no experience with f# so i think of it as just another ocaml
00:29:28 <uochem> cool
00:29:29 <scalaLove> |Jedai} please?
00:29:37 <Heffalump> scalaLove: there are logs online, see the topic
00:30:02 <Heffalump> it'd be easier to answer specific questions than tell you everything I think :-)
00:30:07 <Jedai> scalaLove: you didn't miss much, except that n in the body is a parameter of the lambda, so has nothing to do with the parameter of the function
00:30:30 <uochem> Heffalump: I was really just trying to find out quickly if it's worth some of my time
00:30:31 <scalaLove> i see, hmm...
00:30:36 <Heffalump> essentially I think F# is fundamentally a hack, but one that is inevitable and mostly well-done given the circumstances (FP/.NET interaction)
00:30:47 <Jedai> scalaLove: you could write (\x -> isDivisibleOne x start end) and it would be exactly the same thing
00:30:47 <Heffalump> uochem: depends on your requirements. If you care about .NET and about FP, then certainly.
00:30:52 <Heffalump> If you don't care about .NET, then no.
00:31:05 <uochem> thank you, that helps
00:31:21 <Heffalump> well, it does have some interesting features from a general FP point of view (e.g. units-of-measure)
00:31:50 <Jedai> Heffalump: yep, cool stuff, we have a library in Haskell but it's not as convenient
00:31:57 <Heffalump> but overall it lacks too much stuff like either type classes or functors to make it really nice to use if you are not platform limited (and don't care about good tool support, which it has and most other FP languages don't)
00:32:52 <Heffalump> the interaction of functional style and objects is quite nicely done in general, but IMO the type system ends up being a bit of a mess
00:34:30 <Jedai> scalaLove: basically if you want to use this solution, I suggest you get rid of this useless parameter, put "main = print (isDivisibleAll 1 20)" in your script and compile it with "ghc -O2 --make Euler5.hs"
00:35:01 <Jedai> scalaLove: then launch the executable and wait ;)
00:35:30 <Jedai> scalaLove: to be honest it shouldn't take much more than 4 minutes
00:36:31 <Jedai> scalaLove: if you want some statistics for your execution you can launch your binary with some option for the runtime "./Euler5 +RTS -sstderr"
00:36:54 <blobl> hey how can i write this point free lcFirst s = toLower (head s) : tail s
00:37:22 <Heffalump> @pl (\s -> toLower (head s) : tail s)
00:37:22 <lambdabot> ap ((:) . toLower . head) tail
00:37:27 <Heffalump> but don't do it :-)
00:37:38 <Heffalump> for one thing, it's not safe since it doesn't handle empty strings
00:37:58 <blobl> hm
00:38:20 <blobl> because of head?
00:38:29 <osaunders> How do I convert Integer to Int?
00:38:29 <Heffalump> yes (and tail, but that fails under the same conditions)
00:38:38 <Heffalump> lcFirst (x:xs) = toLower x : xs
00:38:41 <Heffalump> lcFirst [] = []
00:38:44 <Heffalump> is much nicer
00:38:49 <Jedai> osaunders: fromIntegral
00:38:52 <blobl> if i re-write that it should be ok right?
00:39:07 <Heffalump> rewrite what?
00:39:09 <osaunders> Jedai: Thnx
00:39:43 <uochem> Heffalump: well, the thing is this, in my own time, I'm obviously not platform limited, but work wise I'd just like to improve my coding-for-windows experience. wpf and stuff is nice. So far, took only tiny look through the F# book and was immmediately annoyed by the introduction.
00:39:46 <Jedai> osaunders: it converts between the Integral types (Word* and others included)
00:39:53 <scalaLove> |Jedai| thank you so much, one last question, ghc -O2 --make Euler5.hs, O2 means?
00:39:58 * Heffalump really dislikes WPF, for what it's worth
00:40:05 <Heffalump> which F# book, Expert F#?
00:40:15 <uochem> Don't judge a book by it's introduction, if you like.
00:40:16 <blobl> head? so it handles empty strings
00:40:25 <Jedai> scalaLove: it's the optimization level, -O2 is the best GHC can give you
00:40:35 <Heffalump> blobl: and tail, then. And then you'd find that lcFirst "" wasn't an empty string.
00:40:40 <Heffalump> Or you could do it the way I suggested :-)
00:40:47 <blobl> lambdabot is it a bot?
00:40:58 <blobl> ya im just playing
00:41:05 <Jedai> scalaLove: --make tells GHC to chase dependancies itself
00:41:16 <Heffalump> blobl: yes
00:41:38 <blobl> so it did that conversion by itself?
00:41:44 <Heffalump> yes
00:41:50 <blobl> thats cool
00:42:03 <Jedai> blobl: that pl, you can find it on hackage, there's a plugin in lambdabot
00:42:24 <blobl> hm i am so noob :D
00:44:05 * Baughn ponders writing a hindley-milner layer for C
00:44:22 <blobl> Heffalump: whats "" if not an empty string?
00:44:28 <Jedai> Baughn: insanity !!
00:44:34 <Baughn> > "" :: [Int]
00:44:35 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:44:35 <lambdabot>         against inferred type ...
00:45:27 <Baughn> Jedai: Instead of writing yet another new language (and what'd be the point?), why not write something that can output usefully readable C code?
00:45:34 <Heffalump> blobl: it is an empty string
00:45:37 <Baughn> Type-classes are just a bonus. :P
00:45:44 <Jedai> blobl: Heffalump meant to say that if you redefine head and tail to make your first definition works everytime you'll have to make it so lcFirst "" isn't an empty string
00:45:45 <uochem> Heffalump: I think Programming F#. What do you prefer over wpf for windows programming
00:46:02 <Heffalump> uochem: dunno, something lower-level like Winforms I guess.
00:46:18 <Heffalump> I just really dislike the dynamic nature of WPF and the way it just silently fails when you screw up
00:46:31 <Jedai> Heffalump: Winforms are quite horrifying too though ...
00:46:56 <uochem> Jedai, Heffalump: lol
00:47:08 <Heffalump> uochem: I haven't really read any F# books so I don't know what to recommend. I use Expert F# as a reference manual occasionally, but mostly I just read the language spec.
00:47:34 <Jedai> Qt is actually not bad under Windows now I believe, and I heard good things about WxWidgets
00:48:10 <scalaLove> Ladies and gentleman wont you congratulate me I just solved the Euler in #Haskell, first time Haskell, I love this lang and i love this people here thank you thank you :D
00:48:34 <osaunders> You solved all of project Euler?
00:49:19 <osaunders> Anyway
00:49:27 <osaunders> Anybody know a shorter way of writing this:
00:49:29 <osaunders> > let x = 5 :: Int; y = 2 :: Int in zipWith zip (replicate y [0..x-1]) (map (replicate x) [0..y-1])
00:49:30 <lambdabot>   [[(0,0),(1,0),(2,0),(3,0),(4,0)],[(0,1),(1,1),(2,1),(3,1),(4,1)]]
00:51:06 <Philonous> > liftM2 (,) [0..4] [0..1]
00:51:07 <lambdabot>   [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),(4,0),(4,1)]
00:51:28 <scalaLove> nah man just first 5 so far, 4 in Scala the #5 in Haskell
00:51:58 <osaunders> scalaLove: OK, yeah. Well done.
00:52:13 <osaunders> Philonous: Nice. Let me look up that func.
00:52:35 <Philonous> osaunders: No, that's actually something else, sorry
00:52:35 <dmhouse> > groupBy (equating snd) $ liftM2 (,) [0..4] [0..1]
00:52:37 <lambdabot>   Not in scope: `equating'
00:52:41 <tomh-> whats % called in haskell?
00:52:43 <dmhouse> Boo.
00:52:49 <osaunders> Philonous: Oh yes I see now/
00:52:55 <Phyx-> tomh-: mod
00:53:00 <tomh-> ah thanks
00:53:04 <dmhouse> > let let equating f x y = f x == f y in groupBy (equating snd) $ liftM2 (,) [0..4] [0..1]
00:53:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:53:09 <osaunders> I can do it with a list comp
00:53:14 <osaunders> > [ (x,y) | x <- [0..1], y <- [0..4] ]
00:53:16 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4)]
00:53:21 <dmhouse> > let equating f x y = f x == f y in groupBy (equating snd) $ liftM2 (,) [0..4] [0..1]
00:53:23 <lambdabot>   [[(0,0)],[(0,1)],[(1,0)],[(1,1)],[(2,0)],[(2,1)],[(3,0)],[(3,1)],[(4,0)],[(...
00:53:27 <dmhouse> Oops.
00:53:44 <Jedai> Philonous: no, it's the same modulo a concat and a sort
00:55:27 <osaunders> That lisp comp I posted works btw.
00:55:34 <osaunders> I just the x and y round the wrong way.
00:55:55 <osaunders> My preference is not to use lisp comprehensions though.
00:56:15 <osaunders> I know there's a HOF equivalent that has been mentioned here before.
00:56:31 <osaunders> s/lisp comp/list comp/
00:56:51 <Philonous> osaunders: The listp comprehension is the same as I wrote, but it differs from the list you posted earlier, too.
00:57:06 <Jedai> osaunders: well in this case Philonous proposition worked
00:57:30 <eu-prleu-peupeu> hi
00:57:37 <osaunders> Jedai: Which?
00:57:44 <Jedai> osaunders: list comprehension are just the list monad in disguise (thus why liftM2 has the same effect)
00:57:45 <osaunders> His last one is different.
00:58:01 <eu-prleu-peupeu> is it possible to write something like this: do [a1, a2, a3] <- [b1, b2, b3]
00:58:12 <aavogt> yes
00:58:19 <opqdonut> pattern matches work
00:58:36 <eu-prleu-peupeu> how do i define operators ?
00:58:43 <Jedai> osaunders: liftM2 (,) [0..4] [0..1] has the same elements as your line
00:58:53 <Jedai> eu-prleu-peupeu: like normal functions
00:58:59 <aavogt> > do [a,b,c] <- ["hai","you","nomatch"]; return [c,b,a]
00:59:00 <lambdabot>   ["iah","uoy"]
00:59:11 <uochem> Jedai: in the past, you'd have to do extra work to stop flicker with wx, which was annoying. But again, not a ui/exp guy here.
00:59:12 <Jedai> eu-prleu-peupeu: x <+> y = addStuff x y
00:59:16 <osaunders> @hoogle liftM2
00:59:20 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:59:31 <eu-prleu-peupeu> can i define an operator that has a name instead of a symbol ?
00:59:39 <eu-prleu-peupeu> the operator "with" :P
00:59:42 <eu-prleu-peupeu> <with>
00:59:45 <eu-prleu-peupeu> is it possible ?
01:00:02 <aavogt> you know the ``?
01:00:07 <Jedai> eu-prleu-peupeu: no, but you can always use a function as infix with the backticks
01:00:17 <uochem> Heffalump, Jedai: thanks again for the thoughts, I'm new to Haskell / functional / pure / anything that isn't C++, lol
01:00:17 <aavogt> > let plus = (+) in 1 `plus` 2
01:00:18 <Philonous> Jedai: It has the same lements, but his lists where nested two levels, mine is flat
01:00:18 <lambdabot>   3
01:00:20 <Jedai> eu-prleu-peupeu: 5 `mod` 2 == 1
01:00:52 <osaunders> Jedai: Nope
01:00:54 <osaunders> > liftM2 (,) [0..4] [0..1] == [ (x,y) | x <- [0..1], y <- [0..4] ]
01:00:55 <lambdabot>   False
01:00:58 <Jedai> Philonous: I know Philonous, that's why I said they were the same modulo a concat and a sort
01:01:10 <Philonous> I see
01:01:17 <Jedai> osaunders: of course you reversed the order of the lists
01:01:37 <Jedai> > liftM2 (,) [0..1] [0..4] == [ (x,y) | x <- [0..1], y <- [0..4] ]
01:01:39 <lambdabot>   True
01:02:21 <osaunders> Oh right.
01:02:37 <osaunders> Hm.
01:03:26 <Axman6> @undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:03:27 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) [0 .. 4]) [0 .. 1]
01:03:47 <Jedai> osaunders: if you want the same ordering as in your initial list of list, you could use "liftM2 (flip (,)) [0..1] [0..4]"
01:03:47 <aavogt> @@ do undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:03:48 <lambdabot>  do undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:03:58 <aavogt> @@ @do @undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:03:58 <lambdabot>  concatMap (\ x -> concatMap (\ y -> [(x, y)]) [0 .. 4]) [0 .. 1]
01:04:07 <Jedai> > liftM2 (flip (,)) [0..1] [0..4]
01:04:09 <lambdabot>   [(0,0),(1,0),(2,0),(3,0),(4,0),(0,1),(1,1),(2,1),(3,1),(4,1)]
01:04:12 <Axman6> @. @pl @undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:04:13 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
01:04:20 <osaunders> Jedai: No that's Ok.
01:04:27 <Axman6> @@ @pl @undo [ (x,y) | x <- [0..1], y <- [0..4] ]
01:04:27 <lambdabot>  ([0..4] >>=) . flip flip [] . ((:) .) . (,) =<< [0..1]
01:04:40 <osaunders> I had no idea (,) was a function.
01:04:44 <Axman6> obviously
01:04:54 <Jedai> osaunders: right and (,,,) is a function too
01:05:00 <Axman6> osaunders: all constructors are functions, if they have values inside them
01:05:09 <Axman6> > map Just [1..5]
01:05:09 <benmachine> (,) is a bit special though
01:05:10 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
01:05:14 <Jedai> @type (,,,,)
01:05:15 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
01:05:37 <Axman6> @src zip
01:05:37 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
01:05:37 <lambdabot> zip _      _      = []
01:06:00 <emile_m> I defined a datatype using GADT + record syntax and put some class constraint on one field.  Would pattern match on that field bring the context up?
01:06:07 <Philonous> > fmap ( flip fmap [0..4] . (,)) [0..4]
01:06:08 <lambdabot>   [[(0,0),(0,1),(0,2),(0,3),(0,4)],[(1,0),(1,1),(1,2),(1,3),(1,4)],[(2,0),(2,...
01:06:27 <Philonous> > fmap ( flip fmap [0..4] . flip (,)) [0..4]
01:06:28 <lambdabot>   [[(0,0),(1,0),(2,0),(3,0),(4,0)],[(0,1),(1,1),(2,1),(3,1),(4,1)],[(0,2),(1,...
01:06:53 <Philonous> Too much cursing for one line of code, though
01:07:55 <Saizan> emile_m: pattern matching on the gadt constructor should
01:09:18 <emile_m> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13695
01:09:30 <osaunders> Why isn't (..) a function?
01:09:45 <Philonous> osaunders: It's just syntactic sugar.
01:09:52 <osaunders> For what
01:09:53 <Philonous> @type enumFromTo
01:09:53 <osaunders> ?
01:09:54 <lambdabot> forall a. (Enum a) => a -> a -> [a]
01:09:57 <osaunders> Oh
01:09:58 <emile_m> Doesn't work...
01:10:28 <osaunders> emile_m: data Container = Container ...
01:10:34 <ziman> it's not a function because (1..) would have different meaning from [1..]
01:10:37 <ziman> i suppose
01:10:42 <zygoloid> osaunders: if it were a fucntion then [1..3] would presumably have to give [[1,2,3]]
01:11:14 <osaunders> I can't believe (,) is a function.
01:11:19 <osaunders> That's fucked up.
01:11:22 <zygoloid> > (,) 1 2
01:11:24 <lambdabot>   (1,2)
01:11:39 <Jedai> ziman: it would also have to support the four variants
01:11:49 <osaunders> > (,,) 1 2 3
01:11:51 <lambdabot>   (1,2,3)
01:11:54 <BONUS> 6.12 is getting (,) sectioning support, rite?
01:11:58 <zygoloid> fortunately, (,) isn't a fairy, so it doesn't need your belief to stay alive ;-)
01:12:02 <zygoloid> BONUS: yep
01:12:02 <ziman> Jedai, yes
01:12:03 <Jedai> osaunders: everything is function in the functional world :) it's pretty convenient
01:12:07 * BONUS woots
01:12:09 <emile_m> osaunders: What about GADTs and records together?
01:12:20 <Philonous> > let (...) = enumFromTo in (1 ... 3)
01:12:21 <lambdabot>   [1,2,3]
01:12:50 <eivuokko> emile_m, it probably won't work like that.  The type of a "leaks" upwards from where.  Might work better with let or doing case/function level pattern matching.
01:12:59 <Philonous> Jedai: You wish! Type functions are not first class, unfortunately
01:13:09 <eu-prleu-peupeu> > [,] 1 2
01:13:10 <lambdabot>   <no location info>: parse error on input `,'
01:13:52 <Jedai> Philonous:  the type level is unfortunately different, but that's improving steadily I believe
01:14:05 <osaunders> emile_m: Here's an example of a correct record type declaration
01:14:06 <osaunders> data Screen = Screen { width::Int, height::Int }
01:14:16 <gwyndyllydd> Joined just to give a little update. Yesterday I've tried accessing haskell.org and it "was down" (to me). Some people helped me here and I've checked my DNS. No luck.
01:14:33 <gwyndyllydd> I then used Google Public DNS and no luck either. I'm accessing haskell.org through a VPN now.
01:14:37 <osaunders> emile_m: Does that answer your question? Because I didn't completely understand what you meant
01:14:58 <gwyndyllydd> I'm on Brazil, on the Oi network. Maybe there is some geoblock in place?
01:15:17 <osaunders> gwyndyllydd: Contacted your ISP?
01:15:18 <Philonous> osaunders: I believe you need to look up GADTs
01:15:53 <osaunders> Philonous: Oh OK.
01:15:57 <eivuokko> emile_m, ignore what I said, sorry, I read wrong.
01:16:08 <osaunders> emile_m: Philonous points out that I don't know what I'm talking about which is probably quite right.
01:16:46 <gwyndyllydd> osaunders: not yet. i just want to make sure there is no blocking from the website's part. my ISP is usually not very cooperative.
01:16:51 <zygoloid> gwyndyllydd: gives 128.36.229.215 from my machines in the UK and west-coast US
01:17:29 <Jedai> osaunders: GADT looks like "data Stuff :: * -> * where Constr :: a -> Stuff a; Constr2 :: Maybe b -> Stuff b"
01:17:53 <gwyndyllydd> zygoloid: thanks zygoloid. I've tried pinging and accesing this IP address, and I'm getting timeouts.
01:18:14 <Jedai> osaunders: they're a quite powerful tool for typed DSL and other interesting type trickery :)
01:18:27 <osaunders> Yeah whatever.
01:18:45 <zygoloid> gwyndyllydd: sounds like the anti-haskell conspiracy doesn't want you getting to it ;-)
01:19:08 <blobl> which is the language that has the coolest string functions implemented already? php ?
01:19:29 <osaunders> Define coolest.
01:19:30 <Kim^Walkman> “coolest”, blobl?
01:19:47 <osaunders> Jedai: I'm not at that stage.
01:19:59 <blobl> :D close to human though?
01:20:21 <osaunders> I just thought GADT == ADT so thanks for the explaination but I'm like ":-s wtf?!" reading that code.
01:20:53 <osaunders> No, not PHP.
01:20:56 <medfly> blobl, are you trying the insult way of discovering information about Haskell?
01:21:13 <Jedai> blobl: PHP is horrible, no consistency in the naming or the parameters or the returns... Too many functions, not flexible enough... Perl is much better from this point of view
01:21:17 <blobl> no im just trying to write functions for practice
01:21:23 <gwyndyllydd> zygoloid: coincidentally, i'm using the popular "circunvent the great firewall of china" free VPN GPass. Some doofus probably messed with routing tables somewhere. I'm calling my ISP.
01:21:26 <emile_m> All works with ordinary GADT, but not with record GADT: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13695
01:21:26 <osaunders> Anyway it depends what you're doing with strings
01:22:09 <gwyndyllydd> thanks everyone, and sorry to disturb the much more interesting language issues here.
01:22:09 <Jedai> blobl: Haskell is surprisingly good once you discover advanced tools, though it probably lacks some functions
01:22:41 <blobl> advanced tools like?
01:22:49 <medfly> the nice thing about Haskell (and many other languages that aren't PHP) is that it's not very hard to write general functions for yourself if you find that you want one
01:22:56 <Jedai> blobl: Parsec, Text,....
01:23:03 <Jedai> medfly: agreed
01:23:11 <emile_m> Parsec is cool.
01:23:23 <eivuokko> emile_m, note that the types are different.  In record your a is bound to just that field, in another it's over the whole ctor.
01:23:44 <osaunders> I want to try Parsec some day.
01:23:48 <eivuokko> emile_m, (or so I read that)
01:24:02 <osaunders> When I'm not so ungood at Haskell. Yep ungood.
01:24:37 <emile_m> eivuokko: And is there any difference?
01:24:57 <thoughtpolice> osaunders: find an excuse to use it; then you have an excuse to become doubleplusgood at haskell! ;)
01:25:20 <osaunders> thoughtpolice: I have an excuse. In fact my excuse is the same reason for using Haskell at all.
01:25:31 <eivuokko> emile_m, Word32 -> (forall a.Binary => a) -> Container vs Binary a => Word32 -> a -> Container.  I think
01:25:58 <osaunders> I want to write a DSL using Haskell but everytime I come here I'm like ":-S I don't know anything compared to these guys."
01:26:21 <eivuokko> emile_m, You can't pattern match the class context out of the single parameter, while you can from ctor level.  Or so I understand it, but I might be wrong.
01:26:27 <blobl> parsec seems cool
01:26:39 <osaunders> blobl: What are you wanting to do with strings anyways?
01:26:53 <blobl> just fooling around trying to write some haskell code
01:26:58 <emile_m> eivuokko: Word32 -> (forall a.Binary => a) -> Container vs forall a. Binary a => Word32 -> a -> Container. No? :-)
01:27:23 <osaunders> blobl: Do you want to help me write snake?
01:27:27 <eivuokko> emile_m, Yes, sorry.
01:27:53 <emile_m> eivuokko: Question is: is it the same r not? :)
01:28:01 <emile_m> s/r/or/
01:28:23 <osaunders> blobl: Or actually I'm quite happy to help you with something. I just want to practice.
01:28:31 <eivuokko> emile_m, They are not the same type.  The type of a cannot be used in first without it leaking, and hence it cannot be used.
01:28:59 <eivuokko> I wonder, though...
01:29:25 <blobl> snake? like the game?
01:29:29 <osaunders> Yeah.
01:30:12 <blobl> could that be done in terminal? :D
01:30:27 <osaunders> Yeah. I'm using HSCurses.
01:30:44 <osaunders> Which is pretty simple.
01:31:02 <Berengal> Today someone told me he wanted to be my friend because he had learned Haskell because of my ramblings, and found that it was awesome
01:31:34 <emile_m> eivuokko: Are you sure?  I always thought that records is just some sort of free accessor functions...
01:31:43 <osaunders> Berengal: Aww.
01:31:58 <osaunders> Berengal: Did you say thanks but that's not necessary, or something?
01:31:59 <eivuokko> emile_m, it appears I was wrong about foralls, but class contexts behave like foralls in the type sigs I gave.
01:32:08 <Saizan> emile_m: your record version looks more like data Container where Container :: Word32 -> (forall a. Binary a => [a]) -> Container
01:32:16 <Berengal> osaunders: I said Haskellers get free friend-passes :)
01:32:52 <osaunders> Berengal: You become friends automatically?
01:32:55 <eivuokko> emile_m, Well, you'd need to more the class context to ctor level, but I dunno if you can do that with GADT syntax.
01:33:01 <eivuokko> *move
01:33:12 <blobl> osaunders: the best thing i can do for that snake is shout "well done" when you code
01:33:38 <emile_m> Saizan: Yes...
01:33:49 <eivuokko> emile_m, Well, what's the type of accesor function here?
01:34:21 <Berengal> osaunders: No reason not to. If you think Haskell is awesome, we've got something in common.
01:34:22 <osaunders> blobl: Oh OK. Have you only just started with Haskell?
01:34:24 <eivuokko> emile_m, Does Container -> (Binary a => [a]) make sense to you?
01:34:30 <blobl> irc is a distractive place.
01:34:35 <Saizan> emile_m: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13695#a13699 <- this should work
01:34:52 <osaunders> Berengal: Nice.
01:35:00 <blobl> yes i few days trying to understand
01:35:15 <blobl> a few
01:35:20 <emile_m> eivuokko: Sort of, though I'm not sure...
01:35:47 <eivuokko> Saizan, well, now it's not GADT, right?
01:36:23 <osaunders> blobl: I've been here a couple of weeks I've read up to chapter 8/9 on LYAH (skipping most of the one about modules) but I've barely written any code yet. I suppose you don't get to write lots of code until you're confident about it.
01:36:25 <Saizan> eivuokko: no, but there's no need to use gadts here
01:36:47 <eivuokko> Saizan, That's not up to me.  Can you do that with GADT syntax?
01:36:50 <osaunders> I've been a bit distracted by IRC too. I think I come here too much. Also I've got an awesome new non-programming book that's distracting me.
01:36:55 <emile_m> Saizan: I see, I can use that, but I'm still curious about using both GADT and records (and global contexts).
01:36:57 <blobl> i believe writting makes confident
01:37:26 <osaunders> Yeah.
01:37:26 <Saizan> emile_m, eivuokko: i don't know what's the syntax to write that as a record gadt
01:37:30 <blobl> we greeks have this saying. the one who does not have brains has legs
01:37:52 <osaunders> Cool saying.
01:37:54 <emile_m> It seems GHC haven's any way to express this...
01:38:04 <blobl> and me havent spoken english for quite a time :D sorry
01:38:08 <eivuokko> emile_m, let's assume foo :: Container -> (forall a. Binary a => a).  And you use it like this bar (foo c).  Now the class context is seen... just inside (foo c), not up to bar.
01:38:27 <osaunders> I like that saying a lot actually. I basically get all my confidence from smarts. Without smarts in something I'm like a scared kid.
01:38:27 <emile_m> I've tried to put context in different places.
01:38:31 <zygoloid> you don't need to use GADT syntax to define a GADT
01:38:32 <eivuokko> The forall there isn't quite right, though.
01:39:52 <eivuokko> zygoloid, The type inference is the same for all ADTs now, or what triggers it?
01:40:16 <emile_m> eivuokko: I see. It's a bit tricky for me yet.
01:40:38 <zygoloid> eivuokko: i think it's type equality constraints in the context which trigger GADT-style behaviour
01:40:59 <eivuokko> zygoloid, Hmm, right, that'd make sense, I guess.
01:42:09 <zygoloid> emile_m: http://www.haskell.org/pipermail/glasgow-haskell-users/2009-June/017393.html
01:42:18 <blobl> confidence is instant but its less tasty than fake cappucino. is that a smart?
01:42:49 <Saizan> emile_m: btw, do you get the semantic difference between these two? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13695#a13700
01:43:25 <osaunders> blobl: Sounds pretty silly to me.
01:43:52 <emile_m> Saizan: Yes, but not too clear.
01:44:14 <eivuokko> Hmmm, so that's the diff.  I thought GADTs would give up the require, don't store-class contexts.
01:44:16 <blobl> embrace love for cappucino
01:44:38 <emile_m> zygoloid: Thanks for link.
01:44:50 <blobl> specially the fake instant thing ready in 30 sec
01:48:27 <taidgh> hey
01:48:33 <taidgh> does anyone want buy batteries?
01:48:49 <taidgh> give good price
01:48:50 <taidgh> AA
01:48:52 <taidgh> AAA
01:49:00 <taidgh> worldwide ship
01:49:24 <opqdonut> ?ops
01:49:24 <lambdabot> Maybe you meant: docs oeis pl
01:49:30 <opqdonut> hrmh
01:49:51 <taidgh> secure paypal
01:49:52 <medfly> @where ops
01:49:54 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
01:49:56 <medfly> :)
01:50:09 <Saizan> emile_m: in the second case ctData stores a polymorphic list, that you can use as any type that's an instance of Binary, instead in the first case the list is of an already fixed type about which you only know that it's an instance of Binary
01:50:21 --- mode: ChanServ set +o Saizan
01:50:24 <medfly> taidgh, oh yeah man I could use some batteries, I always go on IRC for batteries
01:50:28 --- mode: Saizan set +b *!*=tstrogen@*.hari.cable.virginmedia.com
01:50:29 --- kick: taidgh was kicked by Saizan (Saizan)
01:50:47 <Saizan> medfly: don't talk to spammers :)
01:50:49 <QtPlaty[HireMe]> Saizan++
01:50:52 --- mode: Saizan set -o Saizan
01:52:33 <osaunders> That batteries guy was funny.
01:55:08 <emile_m> Saizan: Thank you very much for explanation!  Finally I've got the point about this.
01:55:15 <twp> hi all -- i have a question about XML parsing libraries and their ability (or otherwise) to handle large XML files
01:55:21 <BONUS> how come there's no wikipedia definition for "inductive class"
01:55:31 <BONUS> or is there some other term for that
01:55:57 <twp> i'm writing a prog to convert from one XML file (workout data from my GPS watch) to another (Google Earth KML)
01:56:48 <twp> the input files are quite large ~26MB, I tried using HXT but it got killed by the OS (Linux) when its VM size exceeded 2GB or so
01:57:04 <twp> this is a simple HXT prog that just copies input to output
01:57:39 <twp> a HaXml 'identity' XML parser (copy input to output) survives with about ~1GB memory used
01:57:39 <akappa> twp, the library lets you manipulate trees?
01:58:06 <twp> yes, effectively I need to do some structural induction on the input file
01:58:22 <akappa> twp, with files of that size you cannot manipulate trees
01:58:27 <akappa> they takes too much memory
01:58:39 <twp> eek, I feared that you might say that :(
01:58:45 <akappa> :P
01:59:01 <twp> so realistacally I have to use a stream-based parser?
01:59:08 <akappa> in Java you have two parser
01:59:09 <twp> (realistically)
01:59:10 <akappa> DOM and SAX
01:59:18 <|Jedai|> twp: something based on TagSoup maybe
01:59:22 <akappa> DOM is nicer, with trees and similar thinks
01:59:36 <twp> ok -- will have a look at tagsoup
01:59:38 <akappa> SAX is "event-based", but it is fast and takes few memory
01:59:39 <twp> o
01:59:46 <akappa> you should use something like SAX
01:59:54 <twp> i'm not too bothered about validation
02:00:21 <|Jedai|> akappa: TagSoup is stream-based and quite nice from what I know
02:00:27 <twp> unfortunately the Garmin GPS app that generates the XML files generates a single file containing *all* your history
02:00:34 <twp> this grows with time :-)
02:00:46 <twp> thanks all for pointer to tagsoup
02:01:27 <akappa> thinks, argh
02:01:29 <akappa> things
02:02:58 <Veinor> copumpkin: are you egohot? :P
02:25:59 <gwern> http://ivanmiljenovic.wordpress.com/2009/11/26/if-wishes-were-tests-code-would-be-perfect/#comments
02:26:04 <gwern> anyone know what Ivan is talking about?
02:26:11 <gwern> I don't see what he means by the actual instance
02:26:46 <gwern> he doesn't seem to be suggesting modify the Arbitrary class to demand 'shrink :: a -> Seq a' rather than 'shrink :: a -> [a]', but I don't know what he means by it
02:27:38 <gwern> I mean, you can't modify instance Arbitrary -> [a] where... to read instance Arbitrary -> Seq a where..., because then that's a different instance
02:32:44 <Saizan> gwern: i think he means he should change the use of lists in his own datatypes to Seq's
02:33:13 <gwern> but then why would he say it's something QC should do?
02:33:18 <gwern> QC can't touch his code
02:34:19 <gwern> and there are a fair number of ++s in the Arbitrary.hs, which makes his comment sense
02:35:26 <Saizan> he's not saying QC should do it, he first complains about the bad performance of the instance for lists, then he wonders if he shouldn't use another structure altogether
02:36:53 <Saizan> where "complains" shouldn't be taken as a negative judgement on the post :)
02:37:32 <gwern> hm. I'm not sure that's the best reading
02:37:40 <gwern> maybe I'll just ask for clarification
02:42:23 <mxc> is it possible to have ghc output the type of a nested function somehow?
02:42:56 <EvanCarroll> let f :: Char -> [Char] -> [Char]; f s x:xs = let n = f s xs in x:s:n;
02:43:02 <EvanCarroll> why doesn't that work
02:43:15 <eivuokko> mxc, maybe try to give it a type annotation that is wrong.
02:43:16 <Saizan> you need parentheses around x:xs
02:43:32 <gwern> mxc: you can just float it out to the top level and then -Wall will print the inferred type
02:44:11 <Saizan> fsvo of just that might require lambda lifting
02:44:30 <mxc> i think eivuokko's idea will have ot work...  generally i'dfloat it out, but its a pain when its a closure on a lot of values
02:44:40 <mxc> though i may be abusing terminology
02:45:26 <mxc> as in let f a b c d = let z y = y + a +b + c +d in z 1 (not sure what to refer to the fact that z refers to the values a b c d defined above it)
02:45:55 <Saizan> yeah, it's closing over those variables
02:50:06 <dancor> well, in that case,   zTop y a b c d = y + a + b + c + d; f = zTop 1
02:50:47 <dancor> isn't as bad as it could be bc we could at least imply the vars in the defn of f
02:51:07 <mxc> i was just asking if that's the right terminology there
02:51:17 <dancor> i see
02:51:24 <mxc> believe it or not, i'm giving an intro to haskell lecture tomorrow
02:51:42 <mxc> not really lecture, more an informal intro to the type system at the singapore FP users group meeting
02:52:54 <lvillani> is it normal that cabal-install 0.7.5 doesn't even try to tell ghc to link share libraries instead of static ones?
02:52:59 <lvillani> (ghc 6.12)
02:52:59 <dancor> are there any closures that are not nested functions (i know there are nested functions that are not closures)
02:53:40 <mxc> if there are no free variables, is it still considered a closure?
02:53:45 <dancor> mxc: no
02:53:51 <mxc> let f a b = let z = a + b in ...
02:53:52 <gwern> isn't it a combinator then?
02:54:06 <mxc> dancor: then no right?
02:55:15 <dancor> hm, what about x = 4; f = x + 5 both at top-level
02:56:14 <|Jedai|> lvillani: maybe there's an option ?
02:58:47 <mxc> didn't you just say that no free variables implies not a closure?
02:58:49 <lvillani> |Jedai|: I found --enable-shared but it just builds shared libraries and doesn't link to them
02:59:14 <dancor> "a closure is a first-class function with free variables that are bound in the lexical environment"
02:59:20 <lvillani> it still prefers to link vanilla libraries
02:59:37 <dancor> x is a free-variable in f
02:59:48 <mxc> isit?
02:59:48 <lvillani> (calling ghc manually with -dynamic works for my projects)
03:00:04 <dancor> oh idk
03:00:18 <dancor> ok well x a = 4 + a; f b = x + b + 5 then
03:00:43 <dancor> rather: x a = 4 + a; f b = x 1 + b + 5 then
03:00:57 <mxc> still not locally bound
03:01:23 <mxc> i those for a variable to be closed it has to only be accessible in that environment
03:02:01 <mxc> i'm far from an expert, so generally, i'd go with anything said in the channel by anyone besides myself, but..
03:02:17 <dancor> i guess that works if top-level is not considered "an environment"
03:02:50 <mreh> is there a logical reason why bind for the list monad is defined to be concat map?
03:02:50 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
03:03:00 <mxc> including this:
03:03:06 <mxc> > randomIO :: IO Bool
03:03:07 <lambdabot>   <IO Bool>
03:03:10 <dancor> mreh: well there are probably other options that satisfy the monad laws
03:03:23 <mxc> > randomIO :: IO Bool >>= putStrLn . show
03:03:24 <lambdabot>   <no location info>: parse error on input `.'
03:03:33 <dancor> mreh: but that one works with the lists-as-nondeterminism monad instance
03:03:34 <mxc> > (randomIO :: IO Bool) >>= putStrLn . show
03:03:34 <byorgey> mreh: well, the type of bind for the list monad is  [a] -> (a -> [b]) -> [b]
03:03:35 <lambdabot>   <IO ()>
03:03:37 <mreh> dancor: oh, the monad laws
03:03:41 <mxc> ugh nevermind
03:03:48 <byorgey> mreh: flip concatMap is a rather obvious function with that signature.
03:03:53 <mxc> > (randomIO :: IO Bool) >>= show
03:03:55 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO b'
03:03:55 <lambdabot>         against inferred typ...
03:03:58 <byorgey> I can't think of many other reasonable ones.
03:04:10 <zygoloid> mreh: as far as i'm aware, that's the /only/ (>>=) for which a return exists where that pair gives a monad
03:04:16 <dancor> mreh: which is probably the most useful interpretation.  the only other one i know about involves return = repeat
03:04:34 <byorgey> dancor: and that one only satisfies the monad laws for infinite lists.
03:04:49 <dancor> (and i'm ignoring trivial ones too that don't use the full structure of being a list)
03:05:16 <copumpkin> Veinor: surprisingly not me
03:05:22 <dancor> (like treating (a:_) as Just a and [] as Nothing)
03:05:39 <mreh> this is all very useful, thanks dancor, zygloid, byorgey
03:05:41 <dancor> byorgey: ah interesting
03:06:42 <mreh> i think dijkstra would have liked haskell, did he express any sentiments in his lifetime?
03:06:59 <byorgey> dancor: associativity of >>= fails when you have different-length lists, or something like that
03:07:05 <dancor> what's a structure with a "chosen" monad instance (i.e. there are others that are not clearly inferior but a default was chosen)
03:07:05 <byorgey> I forget the exact details
03:07:51 <dancor> i think i've seen haddock comment where they were like we didn't provide a monad instance bc there are two
03:08:21 <byorgey> dancor: hmm, I know of cases like that for Monoid, but not for Monad off the top of my head
03:08:32 <dancor> ah maybe it was that too
03:08:42 <zygoloid> (Either Bool) has a few i think
03:08:45 <juer> let r = 25 :: Num a => a what does it mean it is confusing... the :: stands for type and => stands for results in but i cant get the meaning of that whole...
03:09:05 <byorgey> juer: no, => is for type class constraints
03:09:09 <mauke> juer: => does not stand for "results in"
03:09:20 <byorgey> juer: it means r is any type a which is an instance of the type class Num
03:09:40 <byorgey> like Int, Integer, Double...
03:09:45 <juer> and the 25 means?
03:09:50 <byorgey> it means 25 =)
03:09:51 <mauke> 25
03:10:21 <mauke> but (Num a => a) is the natural type of 25, so that type annotation is useless
03:10:23 <byorgey> but it may end up being the Integer version of 25, or the Int version, or the double version... depending on what type you use r as
03:10:48 <byorgey> mauke: not with MR/type defaulting in effect.
03:10:58 <mauke> byorgey: irrelevant
03:11:04 <mauke> the type annotation is on 25, not r
03:11:31 <byorgey> oh, hrm
03:12:06 <byorgey> heh, you're right
03:12:28 <copumpkin> mauke is right by definition
03:13:47 <byorgey> hehe
03:14:18 <Draconx> copumpkin, even if we ask mauke questions about mauke?
03:14:28 <copumpkin> yep
03:14:30 <byorgey> @remember copumpkin mauke is right by definition
03:14:31 <lambdabot> I will remember.
03:14:31 <dancor> let's not make a maukery of this discussion
03:14:35 <copumpkin> right is defined as what mauke says
03:15:13 <copumpkin> we originally were checking his answers but he was right so often that we figured we'd just redefine the word to save ourselves some effort
03:15:23 <mauke> I am wrong
03:15:27 <copumpkin> fuck
03:15:31 <zygoloid> huh
03:15:39 <zygoloid> i guess it's time to reassess the meaning of 'wrong'
03:15:41 <jlouis> mauke: Don't mauk copumpkin
03:15:42 * byorgey asplodes
03:15:53 <mauke> FLAWLESS VICTORY
03:15:59 <copumpkin> :P
03:16:47 <byorgey> @forget copumpkin mauke is right by definition
03:16:47 <lambdabot> Done.
03:16:49 <byorgey> @remember copumpkin <copumpkin> mauke is right by definition  <mauke> I am wrong  <copumpkin> fuck
03:16:49 <lambdabot> Done.
03:17:07 <copumpkin> :)
03:17:16 <monochrom> I thought I was the one always right.
03:17:28 <juer> why are wiki explanations so hard... i dont understand what a monomorphism is, anyone?
03:17:42 <mauke> do monomorphisms exist?
03:17:43 <copumpkin> juer: a monomorphism? or "monomorphism"?
03:17:53 <byorgey> juer: where are you reading about this?
03:18:05 <copumpkin> juer: one is the opposite of polymorphism, the other is more abstract
03:18:05 <juer> wikipedia
03:18:33 <monochrom> There are several unrelated meanings.
03:18:42 <byorgey> juer: note that a "monomorphism" from category theory has little to do with the "monomorphism restriction" in Haskell.
03:18:45 <shepheb> monomorphism is the medical term for the loss of weight of a person who has mono.
03:18:46 <juer> polymorphism means many shapes, i gues mono means one? a val can have one type only?
03:18:57 <copumpkin> yep
03:18:57 <zygoloid> juer: mono: one. morphism: changingness
03:19:08 <mauke> morphism: shapery
03:19:10 <monochrom> Yes. Or a variable having only one type.
03:20:04 <byorgey> juer: right. and this has nothing to do with the wikipedia page on "monomorphism"
03:20:40 <juer> but it says category theory is central to haskell
03:20:57 <monochrom> encyclopedias are hard to read in a sense. they are not called tutorials for a reason.
03:21:03 <dancor> what is the category in which categorical monomorphisms are abstract algebra monomorphisms
03:21:44 <monochrom> if you use sets as objects and functions as morphisms, monomorphisms become injective functions.
03:22:02 <dancor> juer: ya and bc math is central to haskell, everything has confusing overlapping nomenclature just like in math!
03:22:05 <monochrom> epicmorphisms are surjective functions.
03:22:15 <monochrom> err, epimorphisms
03:22:31 <dancor> monochrom: but in that case you don't have to be a homomorphism
03:22:36 <monochrom> Did you know there are also three unrelated meanings of functor?
03:22:37 <juer> i guess as undergraduate i should run away from these things as far as possible?
03:22:57 <byorgey> juer: no.
03:23:04 <byorgey> @quote wrap
03:23:05 <lambdabot> monochrom says: Don't wrap your head around haskell. Immerse! Wrap haskell around your head.
03:23:05 <|Jedai|> monochrom: cool lapsus ! I want some epicmorphisms in my maths pasta please
03:23:23 <dancor> juer: this case is not that hard to unravel
03:23:40 <dancor> maybe the opposite of polymorphism should have been called something else
03:23:47 <juer> ok got it i will stay with programming onlt
03:23:51 <ziman> monochrom, i know C++'s and categorical; what's the third one?
03:23:53 <monochrom> unimorphism
03:23:54 <dancor> i assume that one came after the abstract algebra meaning
03:23:59 <ddarius> dancor: The name is perfectly sensical.
03:24:07 <monochrom> sml parameterised modules are called functors
03:24:13 <dancor> ddarius: you understand this overlapping terminology issue yes?
03:24:21 <|Jedai|> juer: Probably not, running away from interesting maths is seldomly the right thing to do for an undergraduate (assuming you mean a maths undergraduate of course)
03:24:27 <dancor> is namespacing the answer
03:24:44 <juer> cs undergrad
03:24:47 <ddarius> dancor: Yes, and I've never had any trouble with it.  It is already namespaced.  One is an adjective, the other is a noun.
03:24:48 <copumpkin> CategoryTheory.monomoprhism vs. UmNotPolymorphism.monomorphism ?
03:24:55 <dancor> ddarius: that is not namespacing
03:24:57 <dancor> that's a hack
03:24:58 <monochrom> dancor: If you have groups as objects and group homomorphisms as morphisms, monomorphisms become injective homomorphisms too.
03:25:00 <dancor> that's perl
03:25:11 <|Jedai|> juer: cs is maths, specific maths but still maths
03:25:27 <copumpkin> oh and apparently the category theory one is spelled monomoprhism
03:25:32 <copumpkin> because I can't spell
03:25:33 <juer> so i should take all the math deep and serious ?
03:25:33 <monochrom> Yeah you are programmers, you know namespacing.
03:25:35 * hackagebot upload: oeis 0.2.2 - Interface to the Online Encyclopedia of Integer Sequences (BrentYorgey)
03:25:35 <copumpkin> so no ambiguity!
03:25:37 * hackagebot upload: split 0.1.2 - Combinator library for splitting lists. (BrentYorgey)
03:25:39 * hackagebot upload: UMM 0.1.4 - A small command-line accounting tool (UweHollerbach)
03:25:39 <ddarius> dancor: That's natural language.  You can tell the difference between "well" and "well" can't you?
03:25:53 <copumpkin> dancor: monad has two meanings!
03:25:57 <dankna> natural language is not even remotely context-free
03:26:01 <dancor> ddarius: i don't think theses namings should see natural language as the bar to match
03:26:05 <ddarius> copumpkin: It has at least three.
03:26:07 <|Jedai|> juer: no, you should take it lightly and just enjoy the mind-bendingly weird thing you find about it :)
03:26:13 <mauke> ddarius: http://img.moronail.net/img/0/6/1506.jpg
03:26:16 <ddarius> dancor: They -are- natural language.
03:26:23 <copumpkin> lol
03:26:36 <dancor> anyway i think "abstract algebra monomorphism" and "category theory monomorphism" are the qualified versions
03:26:53 <juer> |Jedai| u r serious right? cause i am thinking about that for a long time and what u say i think is good path to follow :D
03:26:55 <monochrom> I don't understand why we are arguing this. The right solution is to have an ISO registry for names.
03:27:19 <dancor> i'm mad bc haskell claims to be elegant bc it's based on this math
03:27:35 <dancor> and the math itself is arcane
03:27:45 <dancor> and inelegantly named
03:27:45 <zygoloid> hold on, is that 'iso' meaning 'same' or 'iso' mthe standards body?
03:27:56 <dancor> and inconsistent
03:27:56 <monochrom> Hahahaha
03:28:02 <|Jedai|> juer: for a CS student not completely focused on Maths I think it's the best path to follow, the more fun and the one less likely to make you hate maths
03:28:09 <ddarius> dancor: So Haskell becomes less elegant as more math is created?
03:28:21 <dancor> i done paying my troll toll, ddarius.
03:28:24 <dancor> i'm
03:29:14 <monochrom> And my ObOT: 3 ½, 3 x, sin x
03:29:58 <zygoloid> monochrom: your Obligatory Off Topic ... umm, stuff?
03:30:08 <monochrom> yeah hehe
03:30:11 <|Jedai|> juer: just enjoy, Maths is fun and there's plenty of interesting people to met and talk to
03:31:17 <juer> i think math is easy, but the way we are educated about it since kids is bullshit
03:31:23 <monochrom> Premature learning of math is the root of all hot air
03:31:38 <juer> and explanations are more formal then should be, without mentor you get lost
03:32:24 <ddarius> In my experience, the problem with a lot of math education is that definitions are less formal than they should be.
03:32:52 <toast-opt> ddarius, where?  which math programs?
03:32:55 <toast-opt> US?
03:33:21 <ddarius> In the US, yes.
03:34:01 <ddarius> Basically, unless you are majoring in math, you never really learn how to prove anything.  I'm not saying we shouldn't also have didactic, informal explanations as well, but there is more of that than there is of formality by far.
03:34:08 <toast-opt> heh, one example still sticks out in my head:  "don't worry about negative square roots.  they don't mean anything, so don't worry about them"
03:34:32 <shambler> hehe
03:35:03 <copumpkin> lol
03:35:11 <juer> i am gona forget math then and have a happy life and enjoy programming
03:35:11 <dancor> > sqrt (-1)
03:35:13 <lambdabot>   NaN
03:35:14 <toast-opt> they never did explain the name 'root'.  i don't think i even thought about it until years after I'd learned everything i know about the math
03:35:21 <copumpkin> square roots of negative numbers, or that -2 is a square root of 4?
03:35:25 <akappa> ddarius, do you consider computational complexity math or computer science?
03:35:27 <toast-opt> > sqrt (-1:+0
03:35:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:35:28 <|Jedai|> > sqrt (-1) :: Complex Double
03:35:29 <lambdabot>   (-0.0) :+ 1.0
03:35:51 <ddarius> akappa: I would say computer science.
03:35:54 <juer> akappa ouch nasty question
03:36:08 <toast-opt> copumpkin, either would have been nice
03:36:10 <copumpkin> I'm not sure it's worth distinguishing them around there
03:36:14 <akappa> ddarius, but in cc you need formal definitions and proofs :)
03:36:18 <dancor> i consider it theoretical c.s. which i consider math
03:36:18 <|Jedai|> akappa: both, depending on the level at which you work with them
03:36:26 <Draconx> akappa, computer science is math, so...
03:36:29 <akappa> juer, yes, sometimes the boundaries are vagues
03:36:30 <c_wraith> wait, the question doesn't even seem coherent to me.  computer science is the branch of math that cares about computational complexity
03:36:47 <dancor> isn't there practical c.s.
03:36:49 <akappa> Draconx, only the theoretic cs. :P
03:36:53 <ddarius> akappa: How many people need to be taught proving when they get to that class?
03:37:00 <aavogt> toast-opt: so what is meaning of the word root then?
03:37:13 <Taejo> :t sequence
03:37:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:37:21 <Taejo> :t sequence . map
03:37:21 <|Jedai|> c_wraith: I don't think CS only cares about computational complexity, even if you only consider the theoretical side of the divide
03:37:21 <akappa> ddarius, I don't understand your question, can you rephrase a bit?
03:37:22 <lambdabot>     Couldn't match expected type `[m a]'
03:37:22 <lambdabot>            against inferred type `[a1] -> [b]'
03:37:22 <lambdabot>     Probable cause: `map' is applied to too few arguments
03:37:29 <Taejo> :t sequence . map ?f
03:37:31 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?f::a1 -> m a) => [a1] -> m [a]
03:37:49 <copumpkin> Taejo: mapM ?
03:37:51 <toast-opt> aavogt, solutions to polynomials intersecting the input domain's 'zero' axis/plane
03:37:53 <ddarius> akappa: How many students in such class can readily form valid proofs given the formal definitions?
03:38:02 <Draconx> akappa, applied computer science is still math.
03:38:07 <Taejo> copumpkin: just checking that mapM f = sequence . map f
03:38:10 <monochrom> There are 5 unrelated meanings of computer science. OK related, as in overlapping.
03:38:11 <dancor> |Jedai|: what does {theoretical c.s.} - {math} look like to you
03:38:44 <akappa> ddarius, oh, I don't know. I just love that field and mathematics in general, so I consider myself sufficiently capable
03:38:52 <Draconx> akappa, much like how applied math is still math.
03:38:58 * copumpkin enjoyed proofs but really started "getting it" when he started playing with agda
03:39:05 <|Jedai|> dancor: It's empty :)
03:39:17 <monochrom> {-# LANGUAGE OverlappingInstances,IncoherentInstances #-} instance CompSci cs where ...; instance CompSci cs where ...; ...
03:39:28 <juer> would you agree that a sucessfull computer scientist is not just a guy that studies hard but knows what to study and what not. Like he sees math an he jumps chapter, he sees some crazy formula and he knows aaa fuck this shit ... you know... give me comments on this
03:39:31 <|Jedai|> dancor: but that's not what I said, I think anyway
03:39:51 <dancor> |Jedai|: i agree with both statements
03:40:12 <ddarius> juer: I would not say that describes the game plan of anyone successful.
03:40:42 <juer> I would say it is a lot of that, knowing not to study everything is thrown at you
03:41:15 <ddarius> juer: Knowing what to study is useful, but just blindly avoiding areas of study isn't.
03:41:45 <monochrom> I know what to study, but it is not "skip math". I skip some math but not all.
03:41:45 <|Jedai|> juer: My experience of university is that not much of anything is thrown at you, you have to work out on your own which area are worthy of study
03:41:50 <juer> noone said blindly
03:42:03 <ddarius> "Like he sees math an he jumps chapter"
03:42:43 <juer> yeah like, i know enough to pass exam, i wont waste time with it i will do real programming and problem solving
03:43:34 <akappa> ddarius, btw, in my country we spent the first two years of course doing basically math, so a professor is expected to see a proof from us
03:43:35 <ddarius> juer: Specifically for "computer scientist," that field is rather mathematical.  Perhaps you meant "programmer" in which case you can be a professional programmer without being knowledgeable about math at all.
03:44:02 <ddarius> akappa: For what degree?
03:44:07 <Berengal> Solving a problem is easy. What's hard is solving problem solving.
03:44:09 <akappa> computer science
03:44:33 <aavogt> > cycle "solving problem "
03:44:34 <lambdabot>   "solving problem solving problem solving problem solving problem solving pr...
03:44:41 <medfly> Berengal, I'd like to see you solve some unsolved or poorly solved problems now
03:45:14 <Berengal> medfly: Just because it's easy doesn't mean I can do it, It's all relative
03:45:28 <ddarius> Berengal: http://www.hutter1.net/ai/pfastprg.htm
03:45:30 <juer> it is good to know it all, but you gota set limits and be the best in what u do, that is my point... you dont have to be crazy math guy to be good computer scientist
03:45:58 <medfly> basically, to be a programmer you don't need to know CS.
03:46:00 <akappa> juer, a computer scientist NEEDS to know math
03:46:18 <mee> medfly++
03:46:19 <mercury^> medfly: but you are a much better programmer if you know it.
03:46:20 <akappa> juer, even if you design algorithms and you need to study its average complexity
03:46:29 <medfly> by know CS I mean "study it for a degree", obviously :)
03:46:57 <juer> akappa that is easy math man, i am talking going really crazy with math
03:46:58 <mercury^> You do not need a degree in anything to be good at it.
03:47:12 <akappa> juer, it isn't always so easy
03:47:22 <medfly> oh yeah, let's see you become a doctor on your own.
03:47:22 <copumpkin> juer: what do you define as crazy math?
03:47:25 <Berengal> juer: There are only two kinds of math: Easy math, and math you don't know yet.
03:47:28 <medfly> CS is unique at that.
03:47:29 <eu-prleu-peupeu> a computer scientist needs to know how to solve differential equations by head
03:47:45 <eu-prleu-peupeu> and haskell
03:47:52 <ddarius> medfly: You still don't need a degree to become a good doctor except you won't be able to practice.
03:47:58 <dancor> Berengal: do you think andrew wiles thinks his proof of FLT is "easy"?
03:48:14 <ddarius> dancor: He probably thinks it's pretty crummy.
03:48:21 <mercury^> medfly: You are assuming that one does not have access to the study resources if one did not get a degree.
03:48:23 <medfly> ddarius, basically, in all other fields you can't practise as easily.
03:48:23 <dancor> or other mathematicians that know it but not as well even
03:48:30 <juer> eu-prleu-peupeu differentials in practice are used? sorry i am first year dont have the big picture yet
03:48:42 <copumpkin> juer: not unless you're involved in certain fields
03:48:49 <medfly> I feel that CS is one of the few fields that ANYONE has access to the materials.
03:48:53 <dancor> i guess you could say he hasn't "fully" learned it yet..
03:49:17 <akappa> I've see some easy differential equations in computational mathematics
03:49:19 <mercury^> medfly: fields such as philosophy, literature, mathematics, law, ...?
03:49:20 <akappa> *seen
03:49:21 <juer> nothing can compare to a professor in live
03:49:31 <medfly> okay those are roughly like that, but they aren't real fields.
03:49:41 <medfly> real fields are only technology related things!
03:49:59 <dancor> the other thing is that any large field involves a lot to know and internalizing a lot of stuff has an inherent non-easy-ness
03:50:06 <copumpkin> juer: depends, really. There are some people who know a lot of "stuff" who aren't professors, but you can have the same kind of knowledge exchange with them
03:50:07 <BONUS> actually if the reading material is good, i prefer that over a professor because you can go at your own pace
03:50:26 <juer> copumkin - how? on IRC?
03:50:30 <medfly> being able to go at your own pace can be a disadvantage... we all know what procrastination means
03:50:42 <copumpkin> juer: that or in person, but they need not have a PhD or a professorship somewhere
03:50:49 <Berengal> juer: I've had plenty of good discussions on IRC. Learned a decent amount of math here.
03:50:52 <mercury^> IRC is the worst place to have a meaningful discussion.
03:51:00 <dancor> forums
03:51:00 <copumpkin> medfly: which is where enthusiasm and curiosity come in
03:51:06 <copumpkin> mercury^: I wouldn't say that
03:51:06 <medfly> nonsense mercury^
03:51:16 <medfly> copumpkin, pffft, those only exist for the first day! :-p
03:51:19 <Berengal> mercury^: There are places far worse than #haskell for discussing CS
03:51:24 <copumpkin> damn, I'm overdue
03:51:42 <juer> it is 21 century, you got IRC you got all books you want on rapidshare, what do you need more :)
03:51:44 <luite> BONUS: hmm, I don't really like lectures, but I find that talking with the professor in person often is tremendously better than just reading the material
03:51:49 <dancor> Berengal: but are all those places other irc chans ;)
03:51:50 <medfly> mercury^, this place is great.
03:51:54 <mercury^> Well, I haven't had any discussion where I was thinking "Cool, I really learned something interesting here" on IRC for a long time.
03:51:59 <BONUS> ever tried to discuss Haskell in a loud club setting? now that's the worst
03:52:02 <BONUS> or at a construction site
03:52:12 <dancor> next to an airplane taking off
03:52:15 <medfly> BONUS, OR WHILE SKYDIVING
03:52:18 <Berengal> dancor: I'd say they're pretty much anywhere but the CS departments of universities
03:52:19 <BONUS> or that!
03:52:28 <copumpkin> BONUS: I've had a couple of good conversations with edwardk in a loud beer place
03:52:31 <mercury^> The best thing I get is an occasional nice topic that I can then collect information on elsewhere.
03:52:32 <medfly> your nick makes me want to write in caps.
03:52:41 <BONUS> copumpkin: lucky bastard
03:52:58 <BONUS> i wish i got to drink beer with edwardk
03:52:58 <medfly> mercury^, of course you can collect it elsewhere, nearly everything is available somewhere
03:53:13 <eu-prleu-peupeu> i like differential equations
03:53:14 <eu-prleu-peupeu> and haskell
03:53:15 <ddarius> Berengal: Did you check out that link?
03:53:26 <dancor> eu-prleu-peupeu: cool, do you solve them with it
03:53:36 <Berengal> ddarius: didn't get to it yet
03:53:45 <Berengal> ddarius: But it's on my tab stack
03:53:48 <eu-prleu-peupeu> i dont
03:53:56 <eu-prleu-peupeu> i just like them, i dont solve them
03:54:09 <mercury^> But if you compare the #math IRC channel to http://matheoverflow.net you will see what difference it makes. Somehow IRC attracts shallower conversations.
03:54:32 <ddarius> Berengal: Just the title of the page is enough, though you may be interested in the paper later.
03:54:32 <juer> if i ever get into math deeply i will use mathematica and all visual tools posible
03:54:41 <BONUS> i think part of that is that, despite mathbin or whatever, math notation is hard to get across over irc
03:54:45 <eu-prleu-peupeu> (++)
03:54:51 <medfly> mercury^, I personally like that things are shallow.
03:54:56 <dancor> mercury^: both have trade-offs.  do you think we're in a shallower conversation _right_now_?
03:54:59 <BONUS> without just every second thing you say being a mathbin link
03:55:06 <medfly> mercury^, especially when compared with non-existent websites :)
03:55:14 <copumpkin> mercury^: not necessarily
03:55:22 <akappa> BONUS, you can't parse latex on the fly? :D
03:55:24 <paolino> is there a way to express that given Left a it should return Left f , for the function Either a b -> c -> d -> Either f g ?
03:55:28 <copumpkin> http://mathoverflow.net/
03:55:56 <mercury^> BONUS: I believe it has to do with the immediacy of the chat too.
03:55:59 <burp> get an irc client with latex math formular support $1+1$ :>
03:56:07 <ddarius> Freenode #math is not a good place to discuss interesting math.
03:56:10 <Botje> paolino: how would that result be constructed?
03:56:17 <Berengal> ddarius: So... there's an algorithm that solves everything as fast as possible?
03:56:21 <ddarius>  #not-math is better but still not great
03:56:24 <Botje> paolino: you could use the a Bifunctor
03:56:25 <mercury^> If you write slightly longer posts that you have more time to think about, they will be beter on average.
03:56:28 <ddarius> Berengal: All "Well-Defined Problems"
03:56:36 <BONUS> akappa: haha, i htink those #math guys have visual implants which replace latex code with typeset math equations right in their brains
03:56:38 <copumpkin> most IRC is pretty bad, because people get used to unpleasantness and grumpy users, but that doesn't mean it's an inherent property of IRC
03:56:38 <Botje> paolino: or perhaps arrows will have a combinator
03:56:40 <Berengal> ddarius: And how are well-defined problems defined?
03:56:47 <akappa> BONUS, :D
03:56:48 <byorgey> paolino: Either (a -> c -> d -> f) (b -> c -> d -> g) ?
03:57:01 <byorgey> paolino: I'm not sure exactly what you're asking
03:57:07 <ddarius> Berengal: In this case, it means, if I remember correctly, I haven't read the paper in years, all programs in P with formal proofs that they are in P.
03:57:09 <mercury^> copumpkin: this channel is quite good in that regard actually.
03:57:15 <copumpkin> mercury^: yep!
03:57:20 <Cale> paolino: Er... pattern match?
03:57:39 <paolino> byorgey: that one is pretty correct
03:57:52 <Berengal> ddarius: Is this proof required by the algorithm somehow?
03:57:55 <paolino> well I would separate those
03:57:56 <medfly> HI CALE!
03:57:57 <ddarius> Berengal: Yes.
03:57:58 <mercury^> But yes, #math and #not-math for example are full of nasty people that infect others.
03:58:14 <Phyx-> wasn't there a function namd "snuc" or something to add an element to the end of a list? instead of doing ++ [x]
03:58:15 <paolino> Cale, and erroring on Right ?
03:58:27 <Cale> paolino: eh?
03:58:34 <mercury^> Phyx-: snoc
03:58:37 <Berengal> ddarius: Sounds interesting.
03:58:38 <Phyx-> ah
03:58:41 <ddarius> Berengal: Admittedly, the constant factor is... large...
03:58:49 <Phyx-> mercury^: thanks , couldn't remember it for the life of me :)
03:59:08 <Cale> foo (Left x) y z = Left (... something using x, y, z ...)
03:59:10 <mercury^> Phyx-: it's cons backwards.
03:59:10 <shepheb> Phyx-: "cons" backwards, if that helps.
03:59:24 <monochrom> > reverse "cons"
03:59:25 <lambdabot>   "snoc"
03:59:26 <medfly> snoc?
03:59:33 <idnar> heh
03:59:48 <Phyx-> ah, the name makes sense now :P
03:59:56 <Berengal> ddarius: Sounds like it's an interpreter of sorts. If LC is a proof-system, and a program in LC is a proof, then an LC-interpreter can solve the problem described by the program by just evaluating the proof
04:00:01 <paolino> Cale: that means foo is correct, but I'm not forcing it to be
04:00:05 <Cale> mercury^: I left #not-math because I realised that the people there never talked about anything of interest to me.
04:00:21 <medfly> Cale, those people and their non-math conversations!
04:00:22 <Cale> paolino: You aren't?
04:00:39 <medfly> Cale, so boring! who wants to hear about that?
04:00:42 <copumpkin> why is http://mathoverflow.net/questions/8015/is-regular-language-close-under-intersection-with-non-regular downvoted so much? because the answer is too easy? or because it sounds like homework?
04:00:49 <ddarius> medfly: #not-math means not-#math
04:00:49 <Phyx-> mercury^: where is it, thought it was in Data.List but can't find it
04:00:50 * copumpkin isn't an *overflow expert
04:00:52 <Berengal> ddarius: Now add some type-theory and you've got haskell
04:01:06 <Cale> Well, they mostly didn't talk about math, but the non-math topics they chose were mostly unpleasant.
04:01:29 <mercury^> Phyx-: I don't know if there is a list version in some common library, but there's a ByteString version in the ByteString imports
04:01:32 <ddarius> Berengal: It doesn't require an algorithm provided just a formal description of what needs to be solved and a correctness proof (not a proof that it is in P like I said)
04:01:45 <Phyx-> mercury^: ah ok
04:02:12 <paolino> Cale : my function is defined :: a ->(Either b c -> d -> Either e f) -> ....
04:02:17 <Berengal> ddarius: So... prolog then? guess I'll just read the paper...
04:02:52 <paolino> then I expect a correct foo, not enforcing it to be
04:03:12 <Cale> copumpkin: I think because the answer should be obvious.
04:03:28 <copumpkin> Cale: yeah... I'm tempted to get myself some cheap karma though :P
04:03:30 <Cale> copumpkin: It sort of indicates that the person hasn't thought about it.
04:03:50 <copumpkin> true
04:03:57 * copumpkin resists temptation
04:04:10 <Veinor> Is there a guide somewhere for packaging things for cabal/hackage?
04:04:12 <Cale> (The language of all strings is regular -> as many counterexamples as you want)
04:04:52 <paolino> Cale : now I'm stopping on Right if I get a Left and in the opposite situation also
04:05:07 <mercury^> The same person asks other questions that are downvoted too.
04:05:37 <copumpkin> mercury^: they all sound like basic homework
04:05:38 <paolino> (and I don't know what is a bifunctor, but it sounds good for the task=
04:05:47 <copumpkin> paolino: Either is one
04:06:32 <copumpkin> I guess (->) is another one
04:06:38 <copumpkin> (,) too
04:07:13 <monochrom> I didn't stop and think about it. I stopped and calculated about it, i.e., try symbolically some contrapositions, and one of them rings a bell. IMO you can't hold a student responsible if you haven't taught them a toolbox they should try first.
04:07:55 <ddarius> copumpkin: (->) is one as a (bi)functor C^op x C -> C where C = Hask
04:08:16 <ddarius> A bifunctor is just a functor from a pair of categories.
04:08:30 <copumpkin> yep
04:08:48 <copumpkin> someone should make a more general form of ***
04:09:23 <ddarius> copumpkin: I set up a framework for that in my Monad Reader article.
04:09:28 <copumpkin> oh
04:10:31 <ddarius> I kind of wish I had changed the presentation to only introduce the framework for handling op categories later though, though that would make the preceding definitions invalid.
04:10:34 <luite> hmm, suppose I have function that gets a partial order relation and I want to calculate the transitive closure, transClosure::[(a,a)] -> (a,a) -> Bool, what's a good way to calculate this quickly?
04:11:19 <copumpkin> hm
04:11:45 <ddarius> Isn't a partial order already transitive?
04:11:47 <monochrom> Sorry, what is the type [(a,a)] -> (a,a) -> Bool ?
04:12:01 <monochrom> Sorry, I mean: why is the type [(a,a)] -> (a,a) -> Bool ?
04:12:11 <ddarius> Presumably there is supposed to be, at least, an Eq constraint.
04:13:12 <Veinor> how do I make a type an instance of Arbitrary?
04:13:14 <luite> ddarius: oh yes, the list not really a partial order relation yet, but the transitive closure is
04:13:31 <Heffalump> Veinor: that sounds like a dangerous idea
04:13:48 <Heffalump> but if you want to, I'd suggest choosing between a set of known types, rather than generating arbitrary random data in it
04:14:17 <copumpkin> what's dangerous about it?
04:14:25 <Veinor> I want to be able to use QuickCheck though :(
04:14:29 <Heffalump> oh, I misread.
04:14:30 <Heffalump> Ignore me.
04:14:33 <luite> ddarius: which imposes some restrictions on the input list, for example [(A,B),(B,A)] is forbidden if B /= A
04:14:39 <Heffalump> Just ignore me, completely :-)
04:14:56 <|Jedai|> Veinor: well you just write an instance
04:15:13 <|Jedai|> Veinor: It's generally not too hard
04:15:15 <Veinor> yeah, I want to know what arbitrary and coarbitrary have to do.
04:15:34 <Heffalump> I'd suggest using QuickCheck 2 instead, which has shrinking, which is cool
04:15:45 <watermind> there's a quickcheck 2?
04:15:48 <watermind> I didn't even know that
04:15:48 <|Jedai|> Veinor: coarbitrary is necessary to generate functions, you may not really need it yet
04:15:49 <Heffalump> yes
04:15:52 <ddarius> luite: You can probably do a kind of dynamic programming algorithm on it.
04:16:12 <Veinor> so just coarbitrary = undefined for now? :P
04:16:29 <SamB_XP> Veinor: you could just leave it out ...
04:16:34 <Heffalump> leave it out and you'll get an ok default
04:16:44 <Veinor> don't you have to define everything for an instance?
04:16:56 <Heffalump> not if there are defaults defined, as there are in this case
04:17:05 <Veinor> ahh.
04:17:30 <Heffalump> in fact leaving it out is preferable to = undefined, because the compiler will insert an error message with more information
04:17:31 <Berengal> You don't have to define anything for an instance, not even those lacking defaults
04:17:44 <Berengal> But GHC will whine if you do...
04:17:46 <Heffalump> (when there aren't defaults defined, that is)
04:18:04 <SamB_XP> plus it gives a compile-time warning if you leave a defaultless method out
04:18:18 <SamB_XP> yeah, like Berengal said
04:18:22 <|Jedai|> Veinor: sometimes, you'll see documentation for a typeclass that says "minimal implementation is ..." that means there are defaults that will complete an instance if you correctly define the minimal implementation
04:18:26 <SamB_XP> which is actually often good ;-)
04:18:29 <Berengal> SamB_XP: Only with -Wall
04:18:36 <luite> ddarius: yeah I'm going to try that, but I think I have to process the list in topological order for that
04:18:44 <SamB_XP> oh, is that so???
04:18:45 <Veinor> so now I need to figure out how to write arbitrary.
04:18:47 * SamB_XP frowns
04:19:02 <Berengal> SamB_XP: At least ghci accepts my 1 minute old test-program
04:19:04 <|Jedai|> Veinor: a simple example is Eq where defining one of (/=) and (==) is enough
04:19:08 <Veinor> right, right
04:19:20 <Veinor> is there a simple way to write Arbitrary for a class that's basically a wrapper around integers?
04:19:34 <Berengal> Veinor: toEnum? ;)
04:20:08 <|Jedai|> Veinor: arbitrary = Wrapper <$> arbitrary
04:20:36 <ddarius> :t arbitrary
04:20:37 <lambdabot> forall a. (Arbitrary a) => Gen a
04:20:47 <Veinor> yeah, I figured that out
04:20:50 <|Jedai|> Veinor: or "arbitrary = liftM Wrapper arbitrary" if you don't use Applicative
04:21:18 <ddarius> @index fmap
04:21:19 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:21:25 <ddarius> @index liftM
04:21:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:21:29 <|Jedai|> Veinor: Note that Derive provides automatic derivation of Arbitrary instances
04:21:31 <ddarius> fmap requires no imports
04:21:43 <Veinor> |Jedai|: ?
04:22:05 <Veinor> I'm pulling in Control.Monad anyway, I like liftM in this case
04:23:05 <|Jedai|> Veinor: Derive is a software that'll write instances for you for more typeclass than the normal deriving mechanism
04:23:12 <Accidus> What does .|. mean?
04:23:15 <Veinor> oooh, pretty
04:23:24 <ddarius> @hoogle (.|.)
04:23:25 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
04:23:26 <Veinor> bitwise or
04:23:30 <|Jedai|> Veinor: you can even use TH to make it all automatic
04:23:33 <Accidus> Thanks
04:23:57 <Veinor> Template Haskell? i've heard about that a bit, but never really looked into it.
04:24:08 <Veinor> also, what exactly is it that coarbitrary does?
04:24:15 <ddarius> :t coarbitrary
04:24:16 <lambdabot> forall a c. (CoArbitrary a) => a -> Gen c -> Gen c
04:24:48 <|Jedai|> Veinor: http://hackage.haskell.org/package/derive
04:25:01 <Heffalump> it's used for generating arbitrary functions from a->c
04:25:23 <|Jedai|> Veinor: using TH is easy, writing some is not too hard, writing something interesting with it is harder
04:25:30 <Heffalump> you take a generator for c, and you perturb it using a specific value of a
04:26:01 <Veinor> hm.
04:26:42 <Veinor> I think I'll look in to Data.Derive
04:27:30 <|Jedai|> Veinor: you just have to write $( derive makeArbitrary ''Foo ) in your script and you're good (if you don't have special requirements on the way your type is generated
04:27:53 <Veinor> that's kinda magic :O
04:28:23 <Veinor> and I do happen to have some restrictions; can't generate the type from a negative number
04:28:37 <|Jedai|> Veinor: Just Template Haskell, that is macros in Haskell (everything is checked at compiling time of course so you won't have too nasty a surprise)
04:28:46 <aavogt> , '(-1)
04:28:47 <lunabot>  luna: parse error on input `1'
04:28:52 <quuuux> @pl \ f a _ b -> b $ f a
04:28:52 <aavogt> , '1
04:28:52 <lambdabot> ((const . flip id) .)
04:28:53 <lunabot>  luna: parse error on input `1'
04:28:58 <|Jedai|> Veinor: then you can't use Derive
04:29:04 <Veinor> awww :(
04:29:04 <aavogt> , let x = (-1) in 'x
04:29:05 <lunabot>  luna: Stage error: the non-top-level quoted name 'x
04:29:36 <ddarius> , 'Just
04:29:37 <lunabot>  Data.Maybe.Just
04:29:39 <ddarius> , ''Maybe
04:29:40 <lunabot>  Data.Maybe.Maybe
04:29:50 <|Jedai|> Veinor: Well I don't see how hard writing "arbitrary = liftM (Wrapper . abs) arbitrary" can be
04:29:56 <aavogt> but numeric litterals are supposed to be constructors, no?
04:30:08 <ddarius> aavogt: ' takes names
04:30:22 <ddarius> , 'sin
04:30:24 <lunabot>  GHC.Float.sin
04:30:27 <aavogt> , '()
04:30:28 <lunabot>  GHC.Unit.()
04:30:30 <Veinor> yeah, that's what I wound up doing.
04:30:32 <uorygl> So, I've been trying to think of evil Christmas presents for my dad, and I came up with the idea of a book on functional programming. I'm not sure what such things there are, though.
04:30:57 <aavogt> , '"hello"
04:30:57 <ddarius> There are piles of them.
04:30:58 <lunabot>  luna: parse error on input `"'
04:31:08 <|Jedai|> uorygl: Real World Haskell ! No probably TTPL is better
04:31:10 <aavogt> , '("hello")
04:31:11 <lunabot>  luna: parse error on input `"'
04:31:11 <|Jedai|> @where TTPL
04:31:12 <lambdabot> I know nothing about ttpl.
04:31:23 <ddarius> |Jedai|: Are you think TaPL?
04:31:23 <aavogt> @where TAPL
04:31:23 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:31:32 <uorygl> What's TTPL?
04:31:45 <monochrom> uorygl: pick one from http://www.vex.net/~trebla/weblog/fpbooks.xhtml
04:31:48 <|Jedai|> ddarius: Right !
04:32:01 <ddarius> I would not describe TaPL as a FP book.
04:32:14 <Veinor> It makes me want to consider just silently applying abs to the argument of the constructor.
04:32:16 <aavogt> ddarius: what's you reasoning for ' in TH not working for litterals?
04:32:19 <ddarius> Get Algebra of Programming ...
04:32:25 <|Jedai|> ddarius: Well that's true...
04:32:27 <ddarius> aavogt: Literals are not names.
04:32:43 <aavogt> well Just is not a name, 'Just is a name
04:33:04 <aavogt> :t Just
04:33:05 <lambdabot> forall a. a -> Maybe a
04:33:07 <uorygl> What's TaPL, then?
04:33:14 <aavogt> , [$ty| 'Just |]
04:33:17 <lunabot>  Name
04:33:20 <|Jedai|> ddarius: it's still pretty cool and a good introduction to some of the concept in use in the FP world
04:33:35 <aavogt> ddarius: couldn't litterals have names?
04:33:35 <|Jedai|> uorygl: just follow the link ! :)
04:33:57 <Veinor> hooray, I experimentally verified distributivity!
04:34:04 <ddarius> aavogt: Literals are self-evaluating.  If you want 1, just use 1.  Names need to be looked up in some environment.
04:34:39 <toast-opt> uorygl: types and programming languages
04:34:39 <toast-opt> it's a book
04:34:53 <ddarius> I don't want the function \x -> Just x, I want the name "Just"
04:35:00 <ddarius> Veinor: Why not prove it?
04:35:02 <Heffalump> it's a programming language semantics book, not a pure FP book
04:36:06 <Veinor> because my definition of multiplication is ugly as sin
04:36:15 <Veinor> :/
04:36:24 <Veinor> sized $ \n -> choose (-n,n)
04:36:27 <Veinor> whoops
04:36:36 <Veinor> http://github.com/veinor/nimber/blob/master/Nimber.hs#L47
04:36:38 <monochrom> use computer to prove things ugly as sin or cos.
04:36:47 <Veinor> I need to make line 53 not take up 200 columns
04:36:57 <Phyx-> @pl \x-
04:36:58 <lambdabot> (line 1, column 3):
04:36:58 <lambdabot> unexpected end of input
04:36:58 <lambdabot> expecting "->"
04:37:06 <Phyx-> @pl \f->ap (return f)
04:37:06 <lambdabot> fmap
04:37:09 <Phyx-> lol
04:37:11 <Phyx-> ofcourse
04:37:16 <Veinor> ah, so -> = m
04:37:18 <Veinor> :D
04:37:27 <scalaLove> why this shows error: (\x -> x*x) [1..100]
04:37:53 <Veinor> scalaLove: because that function you wrote takes an Integer (or Double, or Float, or...) and you're passing it a list of them
04:37:56 <Phyx-> @pl \f x->head liftM f x
04:37:56 <lambdabot> head fmap
04:38:09 <Veinor> you need map (\x -> x * x) [1..100]
04:38:42 <Phyx-> how is that type correct
04:38:44 <Phyx-> @type head fmap
04:38:45 <lambdabot>     Couldn't match expected type `[a]'
04:38:45 <lambdabot>            against inferred type `(a1 -> b) -> f a1 -> f b'
04:38:45 <lambdabot>     In the first argument of `head', namely `fmap'
04:38:49 <ddarius> Or an instance Num a => Num [a] ...
04:38:55 <Phyx-> @pl \f x->head (liftM f x)
04:38:55 <lambdabot> (head .) . fmap
04:38:58 <Phyx-> ah
04:39:06 <ddarius> Phyx-: @pl doesn't perform any type checking.
04:39:12 <ddarius> @pl \x -> x x
04:39:13 <lambdabot> join id
04:39:18 <ddarius> :t join id
04:39:20 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
04:39:20 <lambdabot>     Probable cause: `id' is applied to too few arguments
04:39:20 <lambdabot>     In the first argument of `join', namely `id'
04:39:36 <Phyx-> does this function already exist?
04:39:41 <Phyx-> \f x->head (liftM f x)
04:39:43 <ddarius> @pl (\x -> x x) (\x -> x x)
04:39:47 <lambdabot> ap id id (ap id id)
04:39:47 <lambdabot> optimization suspended, use @pl-resume to continue.
04:40:11 <ddarius> Phyx-: No, because it's silly.
04:40:15 <ddarius> @free head
04:40:17 <lambdabot> f . head = head . $map f
04:41:05 <ddarius> So \f x -> head (liftM f x) === (. head)
04:41:30 <Phyx-> ah, ok
04:42:27 <Phyx-> thanks ddarius
04:42:30 <Veinor> in map (\(xs, ys) -> pow2mult $ bitProduct (toBits $ toInteger xs) (toBits $ toInteger ys)) $ onePairs $ liftM2 (,) [0 ..  length aBits - 1] [0 .. length bBits - 1]
04:42:40 <Veinor> how can I make that line not be so long?
04:42:56 <jmcarthur> @pl  map (\(xs, ys) -> pow2mult $ bitProduct (toBits $ toInteger xs) (toBits $ toInteger ys)) $ onePairs $ liftM2 (,) [0 ..  length aBits - 1] [0 .. length bBits - 1]
04:42:57 <lambdabot> map (uncurry ((pow2mult .) . (. (toBits . toInteger)) . bitProduct . toBits . toInteger)) (onePairs (liftM2 (,) [0..length aBits - 1] [0..length bBits - 1]))
04:43:07 <koeien37> use a suitable "where"  clause
04:43:16 <ddarius> @hoogle toBits
04:43:17 <lambdabot> No results found
04:43:19 <koeien37> introduce a helper function for  toBits . toInteger
04:43:29 <Veinor> called godIHateLength
04:43:32 <ddarius> :t Data.Bits.toBits
04:43:33 <lambdabot> Not in scope: `Data.Bits.toBits'
04:44:43 <watermind> ddarius: for some reason I had this idea that AoP is a bit outdated as in... you can read much of it more general and better explained, in papers by bird, hutton and hughes
04:44:50 <watermind> ddarius: am I wrong about this?
04:45:03 <Veinor> I'm pulling stuff out into a let (short stuff) in (that expression) where (various long definitions)
04:46:16 <ddarius> watermind: I have no idea, but I do suspect that if you collect enough papers you could cover all the information in it.
04:55:53 <blobl> is this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13708#a13708 as stupid as i think?
04:56:28 <mauke> yes, entirely too much 'length s'
04:57:16 <koeien37> @src zipWith
04:57:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
04:57:17 <lambdabot> zipWith _ _      _      = []
04:57:19 <blobl> i think im very stupid after finishing that
04:57:22 <koeien37> does this seem familiar?
04:57:31 <blobl> :D not really
04:57:36 <koeien37> look at mMap
04:57:44 <fracture> anyone here used the haskell qt bindings?  (and if so, got any opinion on whether it compares favorably to wxHaskell, or other libs)?
04:58:25 <ddarius> Watching Antoine Dufour play is so simultaneously depressing and exciting.
04:58:39 <blobl> nice thing is that haskell can work even with the stupidest of the logics, such as that thing
04:58:54 <koeien37> well, yeah, you can write FORTRAN in any language ;)
04:58:57 <mauke> :t \n -> map fst . filter (isPrefixOf n . snd) . zip [0 ..] . tails
04:58:57 <lambdabot> forall a a1. (Eq a1, Num a, Enum a) => [a1] -> [a1] -> [a]
04:59:00 <ddarius> blobl: Here's a tip for the future:  Never use length.
04:59:32 <mauke> > (\n -> map fst . filter (isPrefixOf n . snd) . zip [0 ..] . tails) "bra" "abracadabra"
04:59:33 <lambdabot>   [1,8]
04:59:49 <blobl> oh yes its the same
05:02:21 <scalaLove> what is the typical reference for haskell where one can search commands and stuff?
05:02:29 <blobl> hoogle?
05:02:55 <dons> commands?
05:03:23 <dons> http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:03:32 <EnglishGent> hi scalaLove :)
05:06:56 <dancor> i hate to say it but i think we need heredocs instead of "..\  \..\  \.."
05:07:37 <dancor> eh idk
05:09:19 <jlouis> dancor: idk?
05:10:05 <dancor> jlouis: r u asking me what idk means
05:10:10 <jmcarthur> idk = i don't know
05:10:22 <dancor> ya http://www.urbandictionary.com/define.php?term=idk
05:10:38 <jlouis> Oh, I thought it meant "My cat typed this on the keyboard! It's intelligent!"
05:10:53 <dancor> it can mean that as well
05:10:55 <jlouis> i.e., Haskell-cat-a-morphism :)
05:13:22 <ddarius> dancor: There are QQ functions to do that.
05:13:24 * hackagebot upload: chp 1.8.0 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
05:13:32 <ddarius> , [$here| foor bar baz |]
05:13:34 <lunabot>  " foor bar baz "
05:13:42 <jlouis> I need to check chp out!
05:13:56 * ddarius recommends the cml library.
05:14:34 <jlouis> ddarius: cml is hellishly cool as well. I played with cml in SML/NJ
05:14:50 <jlouis> Do you have any reason to choose cml over chp?
05:16:15 <ddarius> jlouis: It's seems cleaner, there are less potential gotchas.  I also prefer things closer to the pi calculus as opposed to CSP.  That said, the current cml library on hackage is only synchronous channels currently.  It has some things the real CML doesn't, but it is missing a lot of primitives CML had.
05:16:51 <ddarius> @hackage cml
05:16:52 <lambdabot> http://hackage.haskell.org/package/cml
05:18:11 <jlouis> ddarius: I should check out both and think about which would fit the thing I had in mind best
05:18:23 <SmurfOR> Anyone know why I'd need to put a duplicate type signature for my infix operator in this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5278#a5279 (comments in paste explain a bit more).
05:18:56 <koeien37> switch of the Monomorphism restriction, it is evil
05:19:28 <koeien37> s/of/off
05:19:53 <dh____> good evening everybody, may I ask a question ? I did googled before
05:20:01 <koeien37> dh____: sure
05:20:11 <dh____> I'm using MonadPlus, and have a following error message
05:20:22 <dh____> mzero is not a visible method of MonadPlus
05:20:41 <c_wraith> dh____: are you using a limited import?
05:21:02 <dancor> ddarius: is here :: QuasiQuoter defined somewhere?
05:21:04 <c_wraith> dh____: It sounds like you're importing MonadPlus, but not MonadPlus(..)
05:21:04 <dh____> import Control.Monad (MonadPlus) , is that what you mean by limited import?
05:21:05 <SmurfOR> koeien37, but the example code doesn't use that pragma yet still loads without the extra type signatures.  The monomorphism error only occurs with the operators that use the liftP function not the liftP2, any idea why?
05:21:14 <c_wraith> dh____: yes.
05:21:21 <ddarius> dancor: Ask mmorrow, though you could define one yourself pretty easily.
05:21:50 <koeien37> SmurfOR: no explanation for that. the monomorphism restriction kicks in if you don't have arguments on the left hand side
05:22:27 <dh____> what is the correct way to import ? c_wraith?
05:23:00 <scree> is there any way of accessing hackagedb build logs for packages that didn't fail?
05:23:22 <dh____> I got it, just remove the (Monad). I'll read some tutorial later , thanks c_wraith
05:23:30 <c_wraith> dh____: there are several options.  You could use "import Control.Monad ( MonadPlus(..) )" or "import Control.Monad ( MonadPlus(mzero) )" or just use "import Control.Monad"
05:23:58 <dh____> great thanks c_wraith.
05:24:09 <c_wraith> dh____: you're welcome
05:24:13 <dh____> BTW, how many people from Canada are here ?
05:24:13 <doserj> SmurfOR: andP and orP are not type-class polymorphic, so the monomorphism restriction doesn't kick in.
05:25:07 <ddarius> , let foo = QuasiQuoter stringE (litP . stringL) in [$foo| asohteu |]
05:25:08 <lunabot>  luna: GHC stage restriction: foo
05:25:42 <Peaker> Haskell 2011 should deprecate the syntax  import Blah  for   import Blah (*)   so people are aware of the insanity
05:26:12 <c_wraith> Peaker: not import Blah (..) for consistency?
05:26:36 <Peaker> c_wraith: Yeah, that would be better
05:26:46 <Peaker> (though (*) has insanity going for it :)
05:27:06 <Heffalump> do you also object to all of the Prelude being implicitly imported?
05:27:32 <Peaker> Heffalump: I think that's ok -- because it means that any name not found in the import list surely from there
05:27:44 <Peaker> Heffalump: as long as there's just one open unqualified import - its still tractable
05:28:16 <Heffalump> or a typo, or a clash with a local name that appears in the Prelude in asome later iteration
05:28:59 <Peaker> Heffalump: well, avoiding clashes with Prelude is easier than avoiding clashes with 3rd party libs..  There are good reasons for even Prelude not to be imported that way, but its not as bad as 3rd parties
05:29:23 <Heffalump> true
05:29:29 <Heffalump> but what about e.g. Data.List, Data.Maybe?
05:29:38 <Heffalump> I think there's a gradual progression
05:30:06 <Heffalump> also, what about qualified imports? Do they need the ugly syntax too?
05:30:23 <Peaker> Heffalump: Too crowded
05:30:34 <Peaker> Heffalump: I think qualified imports should be like Python
05:30:42 <Peaker> Heffalump: import Blah  should have meant a qualified import
05:30:44 * ddarius really doesn't think the "ugly syntax" is ugly enough to stop anyone.
05:31:02 <Peaker> no need for the word "qualified"
05:31:12 <Peaker> just import Blah (..) vs import Blah
05:31:21 <idnar> Python has the equivalent of implicit prelude
05:31:26 <koeien37> __builtins__
05:31:28 <idnar> (the outermost scope is __builtins__)
05:31:39 <idnar> (which is produced by importing __builtin__...)
05:31:45 <ddarius> Almost every language has the equivalent of an implicit Prelude.
05:31:53 <idnar> (note the name difference, which always trips me up)
05:32:05 <idnar> does Java have that?
05:32:15 <koeien37> or C ?
05:32:38 <idnar> C kinda has everything imported implicitly
05:32:43 <koeien37> you could say that
05:32:51 <idnar> insofar as you can call a function that hasn't even been declared anywhere
05:32:53 <koeien37> "use it, we'll see at link time"
05:33:24 <Draconx> idnar, well, that feature was removed in C99.
05:33:46 <ddarius> The linker, the last bastion of lost functions.
05:33:50 <c_wraith> idnar: java has everything in Java.Lang imported by default
05:33:56 <koeien37> String, a.o.
05:34:05 <idnar> yeah, but it's 2009, so there's still nobody using C99
05:34:05 <idnar> ;)
05:34:25 <idnar> c_wraith: ah, okay
05:36:29 <c_wraith> of course, imports in java are strictly syntactic sugar, so it doesn't mean as much.
05:37:59 <Peaker> c_wraith: what do you mean sugar?  Imports are always syntactic..?
05:38:36 <c_wraith> Peaker: imports in haskell have semantic content.  they do in python, as well.  In java, they purely are to reduce typing.
05:39:58 <monochrom> All propositions are false.
05:40:04 <Peaker> c_wraith: I see imports in Haskell as a purely syntactic thing -- they allow you to form links between your AST's across files -- to build the abstract syntax graph
05:40:36 <Draconx> Peaker, try putting "module Foo.Bar", or something equvalent, in the export list of a module without an import.
05:41:01 <c_wraith> Peaker:  I mean that the statement "import Control.Monad.Instances" has semantic content.  It changes the behavior of the program.  (well, the compiler usually, unless orphan instances are involved)
05:41:20 <Peaker> Draconx: wouldn't it simply fail?
05:41:36 <Draconx> Peaker, yes.
05:41:59 <Peaker> Draconx: then I am not sure I follow your point
05:42:07 <Draconx> Peaker, there is no way to export functions from a module without importing it.
05:42:12 <Peaker> c_wraith: well, without overlapping instances -- you can view these imports as   import (..)  -- it also changes what a name you use means
05:42:26 <Peaker> Draconx: why does it mean that imports are not a syntactic thing?
05:42:27 <Draconx> Peaker, if imports were purely syntactic sugar, you would be able to do this.
05:42:51 <c_wraith> Peaker:  the remainder of my point is - in java, you never need to use an import.  They're just syntactic sugar.
05:43:00 <Draconx> Peaker, in java, you can refer to any class in any package without imports.
05:43:30 <Peaker> Draconx: I see these layers: Haskell semantics  -> encode ->  Haskell Abstract Syntax Graph -> encode ->  AST's connected with imports and names  ->  encode ->  Textual files
05:44:10 <Peaker> Draconx: I see the encoding of a graph to AST's as a syntactic feature, not a semantic one
05:44:40 <Peaker> Names, for example, are also a purely syntactic thing (encoding of ASG into AST)
05:46:27 <napsy> Can someone help me. I'm stuck with this error and I can't figure out what's wrong http://haskell.pastebin.com/m2597c43
05:47:03 <Peaker> (it would be nice, btw, to have a Haskell ASG editor - where the links are encoded with hidden auto-generated names, rather than documentary names, and the documentary names could be changed without breaking all their users
05:47:03 <Peaker> or causing unnecessary SCM conflicts, etc)
05:47:10 <koeien37> napsy: traverseLines is an I/O action. your type is incorrect
05:47:18 <dfdf> i would like to sample from the exponential distribution
05:47:30 <dfdf> does anyone know of a good implementation?
05:47:44 <koeien37> dfdf: liftM (\x -> -lambda / log x) (randomR (0,1))
05:47:47 <dfdf> :)
05:47:48 <acidjnk> hello
05:47:57 <dfdf> that's unstable
05:48:48 <acidjnk> The subtypeof symbol: "S<:T". Is it more common to use it only when S != T or is it common to use it when S is a subtype or equal to T?
05:48:51 <napsy> koeien37: Ok koeien37 ok but how can I get a String from IO String so I can ise putStr
05:48:58 <acidjnk> And is there an authority that determines which notion is right?
05:49:11 <jlouis> acidjnk: the subtyping relation is reflexive, no?
05:49:12 <koeien37> napsy: your traverLines is [String] -> IO ()
05:49:29 <ddarius> acidjnk: Subtype or equal to.
05:49:45 <koeien37> acidjnk: i'd conjecture "equal to" would also be included. just like G is a subgroup of G
05:49:45 <ddarius> acidjnk: You can check TaPL for a reasonably authoritative reference.
05:50:04 <jlouis> It tends to be reflexive, yes
05:50:06 <koeien37> T is a subgraph of T. S is a subset of S
05:50:30 <acidjnk> thanks @all, it's probably reflexive then, but I'll check to make sure
05:50:30 <ddarius> acidjnk: The thing is you want f(T) where T <: S to mean you can put anything enough like S into f, and S is certainly enough like S.
05:51:34 <napsy> koeien37: ok I fixed the type to [String] -> IO but now I get "  `IO' is not applied to enough type arguments".
05:51:45 <koeien37> "IO ()", not "IO"
05:51:51 <jlouis> napsy: IO takes a type parameter
05:51:57 <napsy> oh sorry
05:52:04 <acidjnk> I am currently revisiting the Java RI compiler change from 1.5.0 to 1.5.0_01 where the behaviour of choosing the "more specific" method has totally been changed without backward compatibility.
05:52:09 <napsy> it works thanks
05:52:36 <koeien37> napsy: try to read http://www.haskell.org/haskellwiki/Introduction_to_IO by Cale, it's a concise introduction to IO in Haskell
05:52:44 <jlouis> acidjnk: in general, subtyping is "fun"
05:52:44 <napsy> ok I will
05:53:06 <acidjnk> In the case of Java, it gets real ugly real fast when generics and autoboxing and varargs enter the arena.
05:53:15 <jlouis> acidjnk: indeed!
05:53:34 <Draconx> Peaker, Consider a module which calls the "sort" function in the Data.List module.  Every AST for this module either (a) contains an import of Data.List, or (b) contains an import of a module that does (a) or (b).
05:54:00 <acidjnk> I am the one who reported this "bug" years ago, but it turned out to be a disagreement between spec author and the two compiler authors: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6249122
05:54:22 <Peaker> Draconx: in order for it to be syntactically correct, yeah
05:54:24 <Draconx> Peaker, this means that the import is "present", in a sense, at the higher layers.
05:55:03 <Peaker> Draconx: The AST -> ASG syntactic conversion will fail if the "sort" edge in the graph cannot be resolved
05:55:38 <Draconx> Peaker, oh, so you consider variable binding to be syntactic?
05:55:47 <Peaker> Draconx: yeah
05:55:52 <Draconx> Peaker, what about variable binding in languages such as perl?
05:56:12 <Peaker> Draconx: When the name resolution is dynamic, it is hard to consider it syntactic
05:56:46 <Peaker> Draconx: which is something I hate about dynamic languages - btw.  The dynamic typing part, I understand, it was/is tough to get a type system right.  But the dynamic name resolution - I think is unjustified
05:57:12 <Heffalump> Peaker: what do you think of virtual functions?
05:57:22 <Draconx> Peaker, it tends to be a very popular feature in C++ and Java.
05:57:37 <Peaker> Heffalump: the syntactic relationship is with the base class's method (just like type-classes), the chosen implementation is a semantic thing
05:58:10 <Peaker> Draconx: What do you mean? afaik C++ doesn't have dynamic name resolution (unless you consider dlsym or such libraries)?
05:58:31 <Draconx> Peaker, consider "foo.bar" in C++.
05:58:59 <Peaker> Draconx: ah, I see what you mean -- the syntactic decoding of the AST->ASG in C++ depends on type resolutions, but those too can be considered syntactic
05:59:08 <Peaker> Draconx: (because it depends only on static type resolutions)
05:59:16 <Draconx> Peaker, the type of foo might not be known at compile time.
05:59:32 <Peaker> Draconx: Only if it is virtual it matters - but in that case - the name binding is with the base class's name, not the subclass
05:59:54 <Peaker> Draconx: Just like in Haskell, the name resolution of (>>=) is to Monad's, even if at runtime, concatMap is the chosen implementation
06:00:36 <Draconx> Peaker, this isn't just like Haskell, because (>>=) is bound at compile time.
06:00:46 <Peaker> Draconx: SomeType x; x.blah()   in C++ that is equivalent to:  SomeType x; x.SomeType::blah()
06:01:32 <Peaker> Draconx: the "blah" name resolution can be said to happen at compile-time -- choosing the virtual method as a descriptor for the call.  Dereferencing the descriptor happens at runtime, but is not name resolution
06:02:07 <Draconx> Peaker, now you are talking about implementation details.
06:02:26 <acidjnk> In Java it would be wrong to say int <: long, even though an int can safely be passed anywhere where a long can be passed. Or wouldn't it?
06:03:26 <Draconx> Peaker, on a sligtly different note: do you consider type classes in Haskell to be pure syntax?
06:03:31 <Peaker> Draconx: If you have  class Base { virtual void blah(..); };   class Sub : public Base { void blah() {...} }  Sub s; Base *b = &s; b->blah();   you could say that a syntactic binding to Base's blah was formed by b->blah(), even if at runtime, the Sub's blah will be chosen
06:04:01 <Peaker> Draconx: I don't think so
06:04:13 <dibblego> acidjnk, it would be correct to say that
06:04:47 * hackagebot upload: failure 0.0.0 - A simple type class for success/failure computations. (MichaelSnoyman)
06:04:49 * hackagebot upload: control-monad-failure 0.6.0 - A class for monads which can fail with an error. (MichaelSnoyman)
06:04:51 * hackagebot upload: safe-failure 0.4.0 - Library for safe functions (MichaelSnoyman)
06:04:53 * hackagebot upload: attempt 0.2.0 - Concrete data type for handling extensible exceptions as failures. (MichaelSnoyman)
06:05:19 <acidjnk> thanks dibblego
06:05:48 <dibblego> acidjnk, you might consider that "there exists an implicit conversion from int to long", which is precisely what subtyping is
06:05:55 * hackagebot upload: control-monad-attempt 0.0.0 - Monad transformer for attempt. (MichaelSnoyman)
06:05:57 * hackagebot upload: control-monad-failure-mtl 0.6.0 - A class for monads which can fail with an error. (MichaelSnoyman)
06:07:13 <acidjnk> yes, but in Java int can't be used as a covariant return type where the base method had a long. That makes it a little confusing.
06:08:00 <luite> @pl \xs -> xs >>= sequence [fst,snd]
06:08:01 <lambdabot> (sequence [fst, snd] =<<)
06:11:00 <Draconx> Peaker, it seems semantically awkward to say that "b->blah" is bound at compile time, then that binding is ignored and a new binding is determined at runtime.
06:11:30 <Peaker> Draconx: its not ignored -- its a binding to a method - not to a function
06:11:43 <Peaker> Draconx: like (>>=) is bound at compile-time, but implementation may be chosen at runtime
06:11:51 <dibblego> acidjnk, trying to make sense of Java is a futile exercise
06:12:02 <Draconx> Peaker, (>>=)'s implementation is not chosen at runtime - or rather, it does not need to be.
06:12:10 <Peaker> Draconx: It may need to be
06:12:10 <Draconx> (what GHC does is irrelevant)
06:12:21 <Peaker> Draconx: existential types, polymorphic recursions
06:12:33 <Draconx> Peaker, let's ignore language extensions for now.
06:12:49 <Peaker> Draconx: polymorphic recursions are not H98?
06:13:07 <Heffalump> they are H98
06:13:35 <Draconx> Peaker, polymorphic recursion doesn't make it necessary to resolve (>>=) at runtime.
06:13:48 <Peaker> f :: Show a => Int -> a -> String ; f 0 x = show x ; f n x = f (n-1) (x,x)
06:13:50 <Draconx> Peaker, the instance is known at the call site.
06:14:02 <Heffalump> Draconx: only dynamically
06:14:02 <Peaker> Draconx: how do you resolve the show instance at compile-time here?
06:14:06 <Heffalump> based on the instance it was called with
06:14:30 <Draconx> Heffalump, yes, and the instances are known at /that/ call site.
06:14:48 <Heffalump> only because they are passed in dynamically
06:15:36 <Heffalump> with polymorphic recursion they are not statically known at any textual location in the recursion
06:15:55 <Peaker> Draconx: the instances of show for Int, and for (Int, Int), and for (Int, Int), (Int, Int) are all different
06:16:00 <Draconx> When the program is considered as a whole, we can decide all instances.
06:16:11 <Peaker> Draconx: so you have to resolve the Show instance f uses at runtime
06:16:28 <Peaker> Draconx: you'd have to execute f to decide its instances
06:16:52 <Draconx> Peaker, no, you're wrong, because the types passed to f are known at compile time.
06:17:03 <Peaker> Draconx: no, because f calls itself with a new type
06:17:09 <Peaker> Draconx: the type f is called with depends on runtime values
06:17:13 <emile_m> Is it correct to say "Foo :: Int -> [Class a => a] -> Foo" in GADT constructor (with impredicative polymorphism turned on)?  I've got a GHCi crash when tried to load this.
06:17:24 <Draconx> Peaker, which is known at compile time, because it is derived from the types passed to f, which are known at compile time!
06:17:39 <Heffalump> Draconx: polymorphic recursion is a situation where the types are *not* known at compile time
06:17:59 <emile_m> It died with last words "panic! (the 'impossible' happened)".
06:18:21 <Heffalump> emile_m: looks legal to me
06:18:33 <Peaker> Draconx: note: f 2 ()   will result in a call to f with the type (((), ()), ((), ()))  -- where as with 3 () it will be called with the type ((((), ()), ((), ())), (((), ()), ((), ()))) -- these types are clearly different, and depend on the runtime input
06:18:56 <Peaker> Draconx: there's an infinite variety of types - and which ones occur at runtime can depend on user input
06:19:07 <aavogt> but there's only two instances it needs:   Show a => Show (a,a), and Show ()
06:19:27 <Draconx> Peaker, There are only two 'show' definitions used in your example.
06:20:05 <Peaker> Draconx: an implementation might have the same Show instance for ((), ()) and (((), ()), ((), ())) -- is that what you mean?
06:20:27 <Draconx> Peaker, the two relevant instances were already mentioned.
06:20:30 <Peaker> Draconx: the instance code will be shared, but it will take something akin to the type - as input - at runtime
06:20:47 <Draconx> Peaker, there is only one show definition for Show a => Show (a, a)
06:20:49 <mmorrow> i think Draconx means means that you know how to show an Int, and a "(a,b)", assuming you know how to show an "a" and a "b", so you can statically resolve on the base dictionaries for Int and (a,b) at compile time. otoh, you've got to use the (DShow a -> DShow b -> DShow (a,b)) function to produce the ((Int,Int),(Int,Int)) and so on
06:21:05 <ziman> I have a function f x = x + length (expensiveList) where expensiveList = expensiveComputation; will the expensiveList be recalculated on each invocation of f?
06:21:19 <Draconx> Peaker, this is /nothing/ like virtuals in C++.
06:21:23 <ddarius> ziman: Potentially.
06:21:36 <Peaker> Draconx: Ok -- so lets add existential types then? :)
06:21:46 <ziman> so should I make the expensiveList top-level?
06:22:00 <Peaker> Draconx: surely they shouldn't make a conceptual difference in whether the binding to (>>=) is syntactic or semantic?
06:22:21 <emile_m> Heffalump: Everything goes fine with ordinary constructors or without list field.
06:22:35 <Peaker> Draconx: existential types are very much like virtuals in C++
06:22:37 <Draconx> Peaker, well, I don't consider variable bindings to be syntactic, so you seem to be proving my point.
06:22:43 <ddarius> ziman: The sharing behavior is unspecified.  For that particular example, I don't know whether GHC will pull it up or not, but you can do something like f = let expensiveList = expensiveComputation in \x -> x + length expensiveList which is more likely to be shared (but not required by anything)
06:23:00 <ziman> ddarius, thank you
06:23:16 <Draconx> Peaker, going back to imports: you should note that instances are affected by them.
06:23:19 <Peaker> Draconx: is it invalid to see variable bindings as an encoding of a graph?
06:23:39 <Peaker> Draconx: Yeah, in that sense you can view imports as unqualified open name imports
06:24:30 <Peaker> Draconx: is:  f x = x*2+1   syntactically or semantically different to:  f = (+1) . (*2)  ?
06:25:05 <Heffalump> emile_m: it works fine for in GHC 6.10.4, though it requires FlexibleContexts which I don't fully understand
06:25:26 <Peaker> Draconx: semantically, they are equivalent -- so what differs here is just the syntactic encoding
06:25:31 <Draconx> Peaker, depends on the definitions of *, + and .
06:25:37 <Heffalump> oh, or RankNTypes and a forall a . before the Class a
06:25:42 <Heffalump> that does make sense
06:25:44 <Draconx> Peaker, which are, of course, affected by imports.
06:25:45 <Peaker> Draconx: sure, lets assume its the Prelude ones
06:25:56 <Peaker> Draconx: yeah, my piece of syntax is actually incomplete without the imporst
06:26:22 <Peaker> Draconx: or - if it is complete - it means that its using the Prelude
06:26:25 <emile_m> Heffalump: I have exactly the same version of GHC and flexible contexts turned on.
06:26:51 <mreh> why isn't bind just implemented as a map for the list monad?
06:27:26 <koeien37> :t  flip concatMap
06:27:27 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
06:27:34 <Heffalump> emile_m: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13710
06:27:47 <koeien37> :t (>>=) :: [a] -> (a->[b]) -> [b]
06:27:48 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
06:28:07 <Heffalump> (it also works fine if I rename 'Bar' to 'Class', in case you did literally mean that)
06:28:16 <mreh> does lambdabot always include the existential qualifier?
06:28:29 <quuuux> someone remind me how to spell the strict version of (.)?
06:28:33 <Draconx> Peaker, sure, they are the same function.
06:28:36 <Peaker> Draconx: I can resolve all names in a Haskell or C++ program in compile-time -- in Haskell some of these names will resolve to methods -- in C++ some of these names will resolve to base class methods -- and a runtime semantic decision will resolve the implementation of those methods.  There's no rule that says a name must resolve to a specific value/implementation - its allowed to be indirected
06:29:10 <Peaker> Draconx: then - after resolving all names, I can re-encode the program as a graph -- and I will have done -- is just syntactic transformations
06:29:20 <Draconx> Peaker, the connection of names to method names to method implementations is called "binding".
06:29:21 <Peaker> Draconx: all I will have done, that is
06:29:45 <Peaker> Draconx: I distinguish between the binding of (>>=) to (Prelude.>>=)  and between the binding of (>>=) to a particular instance's
06:30:37 <mreh> koeien37, so i suppose concatmap is the natural implementation of bind in the list monad
06:30:51 <mreh> i can't think of another
06:31:02 <Peaker> mreh: the only one that satisfied the monad laws, unless you're willing to add the assumption all lists are of the same length
06:31:07 <Draconx> Peaker, I'd love to discuss this further, but alas guests have just arrived.
06:31:17 <mreh> Draconx: hehe
06:31:28 <Peaker> Draconx: Ok, was interesting -- have fun with the guests
06:31:33 <mreh> don't they like haskell?
06:31:42 <mreh> why do you speak to these people?
06:33:14 <mreh> how can you make lists using the lambda calculus?
06:34:17 <emile_m> Heffalump: Thanks. I've found the problem. It was caused by one function defenition. Very strange... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13710#a13711
06:35:16 <mreh> actually, wikipedia does a pretty good explaination of this
06:35:18 <mreh> for once
06:35:22 <emile_m> Heffalump: Can you check this one on your machine? Maybe t's a real bug.
06:36:24 <Heffalump> emile_m: yep, I get that too
06:36:29 <Heffalump> but in 6.12rc1, I get:
06:36:33 <Heffalump>     Could not deduce (Binary ((Binary a) => a)) from the context ()
06:36:50 <Heffalump> so I suggest trying your real code with the latest 6.12 RC
06:37:18 <adu> hey
06:38:04 <adu> I think I found a bug in HXT, it uses QNames for processing instructions (XPi), but PI's can only have NCNames
06:39:51 <emile_m> Heffalump: Thanks.
06:40:11 * Heffalump disappears
06:40:18 <Heffalump> emile_m: no problem
06:43:33 <mreh> I think I know where most monad tutorials go wrong
06:43:44 <mreh> they assume that monads are not a radical novelty
06:44:03 <koeien37> ?
06:44:06 * hackagebot upload: http-wget 0.4.0 - Provide a simple HTTP client interface by wrapping the wget  command line tool. (MichaelSnoyman)
06:44:08 * hackagebot upload: authenticate 0.4.0 - Authentication methods for Haskell web applications. (MichaelSnoyman)
06:44:10 <koeien37> "you could have invented monads"
06:44:35 <mreh> that's from RWH right?
06:44:50 <koeien37> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
06:45:04 <monochrom> I think I know where most beginners go wrong. They assume that monads are a radical novelty.
06:45:06 <|Jedai|> mreh: they're not
06:45:15 <koeien37> monochrom: that's more like it!
06:46:04 <|Jedai|> Monads are just a formalisation of a pattern often used in programming
06:46:12 <mreh> well, this tutorial seems to get the point, but they're nothing like cars, or spacesuits
06:46:40 <mreh> or containers, all those analogies have only served to confuse me
06:46:55 <|Jedai|> mreh: Ah the famous "monads are like ***", there you may have a point if you denounce confusing analogies
06:46:58 <monochrom> Well, I accept no analogy either.
06:47:08 <monochrom> Analogies are like monads.
06:47:41 <mreh> you must have read the dijkstra paper "the cruelty of really teaching computer science"
06:48:12 <monochrom> and "calling it computer science is like calling that knife science" :)
06:48:30 <mreh> hehe
06:48:40 <mreh> contradicting himself
06:49:06 <mreh> dijkstra reveals himself as a crank
06:49:27 <m4t3j> myunlines = (foldl (++) "").(map(++"\n"))
06:49:27 <m4t3j> genstvorec n =[['*'|x<-[1..n]]|x<-[1..n]]
06:49:27 <m4t3j> stvorec n=putStr(myunlines (genstvorec n))   if I have this functions for draw rectangle,  what do functions myunlines and what here fold and map does ?
06:49:36 <monochrom> I still accept no analogy. You know all the empirical evidence.
06:50:02 <nagnatron> Is anyone here using haskellmode-vim?
06:52:00 <flippo> koeien37, nice article.  (I like the ASCII formatting too.)
06:52:09 <koeien37> flippo: yeah, i liked it too
06:52:14 <koeien37> one of my favorite monad tutorials :)
06:52:21 <ziman> m4t3j, genstvorec :) the map appends a newline to each line; foldl (++) "" concatenates the (newlined) lines into one
06:53:01 <ziman> m4t3j, that foldl should really be foldr; foldl (++) would have horrible complexity
06:53:31 <monochrom> Maybe I should bookmark you-could-have-invented-monads. It is the same line of thought as Phil Wadler's monad lecture notes, which I like the most.
06:54:03 <dfdf> monochrom : see Analogies, artificial perception, and category theory
06:54:44 <dfdf> monochrom : analogies are monads
06:55:10 <m4t3j> ziman, thanks for explanation, sorry for genstvorec :D correct is genrectangle, but I know that you understand me :)
06:56:13 <ddvlad> isn't cabal supposed to solve dependencies on its own?
06:56:35 <mreh> ddvlad: I wish it were true
06:56:46 <ziman> m4t3j, :)
06:57:00 <ddvlad> dunno why i assumed that was true
06:57:01 <monochrom> I was imprecise. I reject analogies that are nothing more than subjective analogies. But some analogies are more, they are rigorously defined transformations or reductions, and I accept or reject them based on which properties they preserve and what context we are talking about. But then I accept them not as analogies, but as transformations.
06:57:16 <ddarius> concatMap is not the only correct implementation of (>>=) for []
06:57:24 <koeien37> ZipList
06:57:46 <ddarius> koeien37: That's not natural/correct for finite lists.
07:01:32 <dfdf> monochrom : if i understand you correctly, you reject all anologies
07:01:55 <monochrom> sometimes I don't understand myself correctly either
07:03:00 <monochrom> but maybe I should pass the burden back on you. what is analogy and how to prove it is a monad?
07:03:21 <dfdf> ah, i don't think analogies are monads
07:03:43 <dfdf> i only found the idea funny, that some people try to formalize such notions
07:04:49 <monochrom> IMO it is futile to formalize this one because people are very flexible with what passes as analogies.
07:04:54 <dmwit> analogies are endofunctors in the category of bad explanations
07:05:13 <monochrom> @remember dmwit analogies are endofunctors in the category of bad explanations
07:05:13 <lambdabot> Nice!
07:06:15 <akappa> how I can ask lambdabot about facts like that?
07:06:20 <quuuux> @quote
07:06:20 <lambdabot> wchogg says: We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
07:06:21 <jlouis> yes
07:06:28 <akappa> @quote knuth
07:06:28 <lambdabot> No quotes match. Maybe you made a typo?
07:06:37 <akappa> @quote endofunctors
07:06:38 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
07:06:49 <dmwit> ?quote [kK]nuth
07:06:50 <lambdabot> No quotes match. Sorry.
07:06:54 <dmwit> bummer
07:07:28 <quuuux> wait. Monoid isn't pronounced /'moUnOId/?
07:07:36 <shachaf> @quote Knuth
07:07:37 <lambdabot> Knuth says: I envy astronomers: People expect them to study stars because stars are beautiful and interesting?
07:08:44 <akappa> @quote haskell
07:08:44 <lambdabot> haskell says: wow am I in the wrong chat maybe?
07:08:51 <monochrom> hahaha
07:08:59 <dmwit> heh
07:09:07 <jlouis> quuuux: no, it's pronounced as Semigroup :)
07:09:44 <ddarius> Pointed magma
07:09:50 <jlouis> hah
07:09:53 <dmwit> jlouis: semigroups don't necessarily have identities, do they?
07:10:31 <jlouis> dmwit: in any case, the monoid terminology seems more common
07:10:44 <jlouis> and perhaps also considerably less ambiguous
07:12:14 <koeien37> i've seen semigroup defined both as a set with an associative operator, and as a monoid
07:15:08 <ddarius> @hoogle transpose
07:15:09 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
07:15:09 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
07:15:09 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
07:17:32 <evolio_> hi there
07:18:29 <evolio_> what is the preferred text editor for haskell?
07:18:42 <dmwit> vim
07:18:47 <shachaf> evolio_: Preferred by whom?
07:18:50 <dmwit> Okay, let's be fair:
07:19:02 <dmwit> vim, emacs, and leksah all have followers
07:19:08 <evolio_> any gtk based?
07:19:16 <dmwit> gvim ;-)
07:19:19 <mjsor> gvim
07:19:28 <ziman> isn't leksah gtk-based?
07:19:30 <c_wraith> there's an emacs fork thatuses gtk, too. :)
07:19:31 * ziman uses gvim
07:19:36 <evolio_> cool
07:19:45 * shachaf uses vim.
07:19:56 <adu> uses emacs.
07:20:01 <evolio_> noticed that gedit has colouring for haskell
07:20:04 <evolio_> probably just stick with this
07:20:17 <shachaf> (But then, learning vim is somewhat of a process of its own.)
07:20:19 * koeien37 prefers vim
07:20:23 <evolio_> ok, so i've got my dev enviroment set up
07:20:24 <c_wraith> if you get an editor that supports decent indenting, it really helps
07:20:25 * adu prefers emacs
07:20:32 * hotaru2k3 uses yi.
07:20:40 * adu uses yi
07:20:43 <shachaf> hotaru2k3: Wait, Yi is usable?
07:20:44 <evolio_> i come from a php/python/ruby background, is there any tutorials aimed at converting from any of these languages?
07:20:48 * myr0 vim
07:20:50 <koeien37> for me, it wasn't :(
07:20:51 <evolio_> for learning
07:21:06 <koeien37> evolio_: i would just read RWH
07:21:08 <adu> evolio_: to Haskell?
07:21:15 <shachaf> There's Haskell for C Programmers, maybe?
07:21:22 <evolio_> Yeah I'm reading that now actually
07:21:23 <monochrom> I use pidgin as my editor
07:21:26 <evolio_> lol pidgin
07:21:27 <shachaf> But otherwise just RWH and LYAH are the standard recommendations, I think.
07:21:38 <evolio_> cool
07:21:42 <evolio_> anyone from edinburgh here?
07:21:50 <adu> evolio_: I think the transision from Python to Haskell is easier than PHP to Haskell
07:22:03 <evolio_> adu, i guessed as much
07:22:08 <adu> evolio_: because Python has lambda's, PHP doesn't
07:22:18 <evolio_> i'm most experienced in PHP, then ruby, then python heh
07:22:20 <koeien37> it doesn't matter that much imo tbh
07:22:31 <quuuux> evolio_: I'd also recommend Write Yourself A Scheme In 48 Hours and YAHT as quite good tutorials
07:22:32 <adu> evolio_: do you know what a lambda is?
07:22:47 <evolio_> wave frequency? ;)
07:22:55 <adu> evolio_: *sigh*
07:22:56 <koeien37> hehe
07:23:05 <evolio_> lol
07:23:08 <evolio_> yeah
07:23:08 <ddarius> It's wavelength.
07:23:09 <koeien37> > (\x -> x + 1) 3
07:23:10 <lambdabot>   4
07:23:18 <evolio_> ddarius, you're correct
07:23:35 <EvanR> im guessing that foo : bars is an efficient way to construct a list right, but in my algorithm it seems i have to do bars ++ [foo], is this worse?
07:23:44 <dmwit> yes
07:23:51 <adu> evolio_: if you don't understand lambda, then nothing else will make sense
07:23:57 <dmwit> Can you construct the list backwards, and reverse it at the end?
07:24:10 <EvanR> let me show you
07:24:14 <adu> evolio_: a lambda is an unnamed function
07:24:35 <evolio_> i have an exam tomorrow for it
07:24:40 <evolio_> been ill for a lot of the course
07:24:40 <adu> evolio_: so (\x -> x+1) is a function that adds one to its input and returns it
07:24:59 <evolio_> so it's just a case of cramming the entire language into one night :) not going to work, but as long as i can get the basics down i can pull it off i think
07:25:12 <evolio_> gotcha
07:25:14 <adu> evolio_: what test?
07:25:20 <evolio_> compsci course
07:25:23 <evolio_> at university
07:25:25 <adu> evolio_: in what lang?
07:25:30 <evolio_> haskell
07:25:32 <adu> oh
07:25:37 <evolio_> it's the university of edinburgh, they developed the language
07:25:42 <EvanR> dmwit http://pastebin.com/m58a6e3d7
07:26:02 <evolio_> i don't think any other university in the world would use haskell, i thought this was a java course but it's haskell. got a bit of a shock
07:26:17 <ddarius> There are many universities that use Haskell.
07:26:32 <adu> evolio_: wow, and you haven't been paying attention? thats like being Archimedes' student and slacking off
07:26:48 <adu> Archimedes was da bomb
07:26:49 <evolio_> it's cool. i was really ill for most of the course
07:26:53 <mjsor> cramming haskell in one night, eh?
07:26:54 <koeien37> evolio_: even here we use Haskell :)
07:26:59 <evolio_> indeed mjsor
07:27:03 <dino-> adu: I didn't want to come off mean-spirited, but I was thinking that too. I'd kill to be in that class right this minute.
07:27:10 <evolio_> dino-, i bet guys
07:27:12 <kurtis> I don't use Haskell. I just come here to be cool.
07:27:14 <adu> evolio_: it took me 10 years to learn Haskell, and I still suck at it
07:27:19 <Peaker> I don't think any professor in any Israeli university knows Haskell yet :-(
07:27:19 <dino-> Even if it's mostly review.
07:27:19 <dmwit> EvanR: Sounds like you want a queue.
07:27:21 <johnnowak> evolio_: would get off IRC and read RWH, then come back when you have specific questions
07:27:33 <Peaker> adu: how much effort did you really put into it?
07:27:34 <dmwit> EvanR: Also, I guess you already know we have quite fast random number generators on Hackage.
07:27:44 <dmwit> EvanR: (And in the standard library, though I think they may be a bit slower.)
07:27:49 <EvanR> this generator isnt fast, its just very long period
07:27:51 <adu> Peaker: I would read the report every night before I went to bed
07:27:58 <evolio_> yeah just about to do that johnnowak
07:28:20 <evolio_> is haskell used much in web programming?
07:28:35 <shachaf> Peaker: You're in Israel?
07:28:36 <Peaker> adu: heh - not a great way to learn a language
07:28:38 <Peaker> shachaf: yeah
07:28:39 <adu> evolio_: not unless you use happs
07:28:50 <EvanR> dmwit i could keep the r-element state backwards the entire time, but i would need to 'dequeue' from the other side, which would seem to also be slow? a queue huh...
07:29:04 <ddarius> Also, Haskell was not developed at Edinburgh.
07:29:14 <evolio_> ddarius, where was it then?
07:29:22 <Peaker> shachaf: We want to organize an Israeli Haskell group
07:29:34 <dmwit> EvanR: the most naive queue around is actually pretty good: type Queue a = ([a], [a])
07:29:34 <Peaker> shachaf: I also want to pass some Haskell knowledge to Uni. professors, hopefully they get excited and take it on
07:29:34 <adu> Peaker: what do you think _is_ a good way to learn a language?
07:30:06 <Peaker> adu: Trying to use it -- getting feedback -- reading about it -- in a loop :)
07:30:14 <EvanR> dmwit two lists...
07:30:20 <dmwit> EvanR: enqueue x (heads, tails) = (heads, x:tails); dequeue (h:hs, tails) = (h, (hs, tails)); dequeue ([], ts) = dequeue (reverse ts, [])
07:30:22 <c_wraith> is this a positive or negative feedback loop?
07:30:27 <dino-> adu: There's a fair amount of not-happs stuff out there too for web.
07:30:27 <ddarius> evolio_: It was designed by a committee involving several universities.  The initial call to develop Haskell was at a conference in Portland, Oregon.  The Haskell 1.0 Report lists no one from the University of Edinburgh.
07:30:44 <adu> Peaker: well i did that too, but not every night, I think I did the social things about twice a month
07:31:16 <dino-> I mean to say, it's all over the map with Haskell and web frameworks or even lack thereof.
07:31:16 <Peaker> adu: Who gave you feedback about your code?
07:31:22 <adu> #haskell
07:31:24 <lunabot>  luna: Not in scope: `haskell'
07:31:30 <dmwit> EvanR: This will have amortized O(1) enqueue and dequeue for constant-sized queues.
07:31:52 <dmwit> (for any queues, actually)
07:31:57 <EvanR> dmwit: i found this rng on wikipedia in the blurb for mersenne twister sayings its too complex, i tested the c version of this algorithm in dieharder tests and the period is about 2^100000 times as long as MT ;)
07:32:19 <EvanR> passes all the tests for randomness as MT
07:32:24 * EvanR likes this algo
07:32:49 <adu> evolio_: I seem to remember my first trouble was using variables in lists
07:32:51 <poe> dmwit the second line is probably concatenation in the second element of the tuple
07:32:57 <dmwit> EvanR: You might like http://www.serpentine.com/blog/2009/09/19/a-new-pseudo-random-number-generator-for-haskell/
07:33:00 <ddarius> MT19337 also optimizes for execution time.
07:33:09 * EvanR checks that out
07:33:18 <adu> evolio_: try writing something in Haskell that uses variables in lists
07:33:29 <adu> evolio_: like a sorting algorithm or something, or "reverse"
07:33:35 <dmwit> poe: hm?
07:33:51 <EvanR> ddarius this algorithm only needs the multiply with carry instruction, so could be optimized. i used b = 2^32 for that reason
07:33:59 <poe> dmwit the second line builds a tuple whose second element isn't a list
07:34:01 <EvanR> and so could use 32bit or 64bit numbers
07:34:16 <dmwit> poe: Right, the second line builds a tuple whose second element is a Queue.
07:34:25 <EvanR> and basically outperforms MT19337
07:34:45 <poe> dmwit I missed the recursive call in the third line, pardòn
07:35:20 <EvanR> dmwit hehe this link is the same algo ;)
07:35:25 <EvanR> MWC for the win
07:35:34 <dmwit> EvanR: That's what I figured.  And why I suggested you look on Hackage. =)
07:36:08 <EvanR> i havent used haskell before so i thought trying to make this as simple as possible would be good practice
07:37:59 <dmwit> totally
07:38:07 <EvanR> im liking this 'naive queue' ;)
07:38:20 <evolio__> do you guys all use linux then?
07:38:33 <jlouis> evolio__: why?
07:39:12 <evolio__> just wondering
07:39:18 <evolio__> or is there a lot of mac/windows use as well?
07:39:21 <monochrom> I use cp/m
07:39:42 <EvanR> beos
07:39:57 <koeien37> linux, mac, then windows, i guess
07:40:31 <evolio__> EvanR, not haiku? ;)
07:41:04 <EvanR> haiku hopefully one day
07:41:30 <thaldyron> If I have n threads that only run "atomically $ writeTVar foo data" on the same TVar without reading it, is it possible that some of them will be retried by the STM runtime?
07:43:23 * hackagebot upload: control-monad-exception-monadstf 0.8.0 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:43:44 <roconnor> thaldyron: why do you care?
07:44:25 * hackagebot upload: control-monad-exception 0.8.0 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:44:27 * hackagebot upload: control-monad-exception-mtl 0.8.0 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:44:29 * hackagebot upload: control-monad-exception-monadstf 0.8.0.1 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:44:31 * hackagebot upload: control-monad-exception-mtl 0.8.0.1 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:44:33 * hackagebot upload: control-monad-exception 0.8.0.1 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:44:53 <dmwit> hm
07:45:26 <evolio__> ok guys, quick question. please don't laugh at me
07:45:35 * hackagebot upload: control-monad-exception-monadsfd 0.8.0.1 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
07:45:35 <evolio__> i'm writing a function to square x.
07:45:42 * EvanR points and laughs at EvanCarroll
07:45:46 <EvanR> ... evolio_
07:45:52 <thaldyron> roconnor: performance loss due to retries. I have one TVar that must be written to in every transaction and I'm wondering if keeping it write-only makes a difference
07:46:33 <evolio__> nevermind, figured it
07:46:44 <monochrom> Does f x = x*x make you happy?
07:47:01 <dmwit> too long!
07:47:08 <ddarius> join (*)
07:47:10 <dmwit> f=(^2)
07:47:27 <roconnor> thaldyron: okay.  I'm not an expert on STM, and I have never used it, but I think it is impossible in GHC's implemenation for a block to retry if no reads were done.
07:48:52 <evolio__> heh monochrom, indeed it does :)
07:49:35 <roconnor> > iterate (*x) 1 !! 2
07:49:36 <aavogt> product . take 2 . repeat
07:49:37 <lambdabot>   1 * x * x
07:49:53 <roconnor> aavogt: take 2 . repeat is replicate 2
07:49:53 <aavogt> > product . take 2 $ repeat x :: Expr
07:49:54 <lambdabot>   1 * x * x
07:50:10 <ddarius> > x^2
07:50:11 <lambdabot>   x * x
07:50:15 <aavogt> that's true
07:50:30 <aavogt> sometimes I forget
07:50:41 <evolio__> how do you exit ghci?
07:50:57 <|Jedai|> evolio__: :quit
07:51:00 <Veinor> or ctrl-d
07:51:06 <evolio__> thanks
07:51:11 <evolio__> :) this is fun
07:51:14 <|Jedai|> evolio__: use :help to get a list of commands and further help
07:51:27 <evolio__> yeah i forgot the : for some reason, makes a lot of sense since it's :l
07:51:37 <EvanR> dmwit annoys me, i shouldnt have to pass the state around, the state IS the sequence, just i need the rth last to calculate the next, but also the 1st last carry
07:52:45 <dmwit> You can almost always trade computation time for memory use.
07:52:52 <dmwit> I'm sure this is no exception.
07:53:00 <dmwit> If you don't want to pass the state around, just recompute it each time.
07:53:12 <dmwit> If you don't want to recompute it all the time, pass it along.
07:53:22 <thaldyron> roconnor: that's the behaviour I was hoping for, but since every entry in the transaction log also contains a "old value", there is some implicit read involved with every TVar-operation
07:53:33 <dmwit> (The State combinators can help a little by hiding the "pass" part, but it boils down to the same thing.)
07:55:01 <EvanR> by recompute you mean pass a number along and do like rand seed !! (n-r) ?
07:56:11 <dmwit> I mean, compute r steps of the computation each time. =)
07:56:15 <EvanR> i was also hoping that somehow by using this sequence haskell would not keep the entire past history of the generator around...
07:56:29 <EvanR> but thats probably a separate issue
08:00:27 <evolio__> ok, another quick question from this tutorial. fib n = fibGen 0 1 n
08:00:56 <evolio__> fibGen 0 1 n is passing 0, 1, n to the function fibGen correct?
08:01:30 <dmwit> correct
08:02:10 <dmwit> If you want to bend your mind, the right way to think of it is that fibGen 0 1 n is passing n to the function (fibGen 0 1), which is passing 1 to the function (fibGen 0), which is passing 0 to the function fibGen.
08:02:35 <Veinor> which is passing... wait
08:04:16 <Peaker> I find that its much less of a mind-bend once you look at (a -> b) as a true map..  a -> (b -> c)   is pretty easy to grasp that way
08:04:33 <quuuux> is there a way to ask the debugger for the value of any variable at a breakpoint, not just the ones involved in the expression being evaluated?
08:05:48 <quuuux> oh, wait, the obvious solution worked. It didn't a second ago, I swear
08:06:08 <evolio__> ok, fibGen :: Int -> Int -> Int -> Int. i can't grasp what this means
08:06:22 <evolio__> it takes an int, to an int, to an int, to an int?
08:06:30 <dmwit> no
08:06:39 <aavogt> -> associates to the right
08:06:49 <quuuux> evolio__: no. Using bracketting: Int -> (Int -> (Int -> Int)))
08:07:03 <dmwit> It takes an Int to an (Int -> Int -> Int).
08:07:03 <dmwit> i.e. it parses as
08:07:03 <dmwit> Int -> (Int -> (Int -> Int))
08:07:11 <dmwit> The innermost one is easy: (Int -> Int) is a function taking integers and returning integers.
08:07:24 <evolio__> gotcha on the (Int -> Int)
08:07:41 <dmwit> The next innermost one is kind of mind-bending: (Int -> (Int -> Int)) says it's a function that takes an Int, and return a *function* from Ints to Ints.
08:07:49 <evolio__> hm
08:07:52 <dmwit> Once you get that, the final level is easy as cake. =)
08:09:04 <benmachine> the expression fibGen 0 1 is type Int -> Int
08:09:31 <Peaker> evolio__: for example, (+1) and (*2) are (Int -> Int) values.   Bool -> (Int -> Int)    could be implemented as:  f True = (+1) ; f False = (*2)
08:09:45 <benmachine> the expression fibGen 0 gives you an Int -> Int when you give it a 1, so its type is Int -> (Int -> Int)
08:09:46 <Peaker> evolio__: followed that?
08:09:53 <aavogt> @djinn Bool -> Int
08:09:54 <lambdabot> Error: Undefined type Int
08:09:58 <aavogt> @djinn Bool -> Integer
08:09:58 <lambdabot> Error: Undefined type Integer
08:10:50 <c_wraith> @djinn Bool -> Bool -> Bool
08:10:51 <lambdabot> f a b =
08:10:51 <lambdabot>     case a of
08:10:51 <lambdabot>     False -> b
08:10:51 <lambdabot>     True -> False
08:11:24 <evolio__> Peaker, not really
08:11:29 <dmwit> > \a b -> case a of False -> b; True -> False
08:11:31 <lambdabot>   {True->{True->False;False->False};False->{True->True;False->False}}
08:12:00 <netinho2lol> okay
08:12:03 <dmwit> > \a b -> not a && b
08:12:04 <lambdabot>   {True->{True->False;False->False};False->{True->True;False->False}}
08:12:35 <evolio__> i haven't came across 'case' yet
08:12:37 <evolio__> what does this mean
08:12:43 <eu-prleu-peupeu1> True<-False->False->True<-True(()))
08:12:44 <dmwit> evolio__: Ignore this, I'm just playing.
08:12:46 <netinho2lol> I'm going to pick on the Data.List.transpose and make a reversetranspose
08:12:50 <dmwit> evolio__: It's unrelated to what you're thinking about.
08:12:56 <dmwit> (sorry)
08:13:11 <evolio__> give me a second to play around and read more
08:13:28 <aavogt> you must learn what name shadowing means
08:13:49 <evolio__> i really appreciate your help, i hope things start to click once i've got the basic concepts, but having someone to explain the concepts is very helpful :)
08:14:47 <aavogt> > let x = 1 in (x,let x = 2 in x)
08:14:48 <lambdabot>   (1,2)
08:15:04 <aavogt> > let x = 1 in (x,let x = 2 in x,x)
08:15:05 <lambdabot>   (1,2,1)
08:15:47 <netinho2lol> I hate that shadowing thing
08:15:50 <aavogt> if they ask you "what does this code do", it will definitely be tricking you like that
08:15:56 <netinho2lol> I always use diferent names
08:16:17 <evolio__> aavogt, we just have to write programs to do what they say
08:16:24 <Peaker> I enable shadowing warnings and avoid shadowing too
08:17:34 <aavogt> sometimes it's harmless like a variable name 'exp' instead of 'expression
08:17:37 <aavogt> '
08:18:27 <aavogt> and even if you did accidentally think the prelude exp was the one in scope, the types wouldn't match up
08:18:44 <aavogt> but there are enough times when shadowing is a pain
08:20:04 <dmwit> How to break an imperative programmer's brain: tell them that to swap two variables, you write "let (a, b) = (b, a) in ..."
08:20:17 <evolio__> heh
08:20:23 <Peaker> dmwit: You do the same in Python, which is imperative, pretty much
08:20:27 <c_wraith> dmwit: what's brain-breaking about that?  it's exactly the same as in python
08:20:32 <dmwit> Peaker: Yeah, except in Python that works.
08:20:34 <c_wraith> Which...  peaker beat me to ;)
08:20:43 <netinho2lol> wait a minute...
08:20:47 <Peaker> dmwit: hehe :)
08:20:51 <dmwit> =)
08:20:51 <ddarius> dmwit's code means fix swap
08:21:02 <benmachine> > let (a, b) = (1, 2) in let (a, b) = (b, a) in a
08:21:06 <lambdabot>   mueval-core: Time limit exceeded
08:21:20 <c_wraith> minor detail. :)
08:21:24 <ddarius> > let p@(a,b) = (0:b,1:a) in p
08:21:25 <lambdabot>   ([0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
08:21:25 <netinho2lol> if a reversed transpose is a transpose with the positions reversed, then all I have to do is to reverse the arguments in the last line of the transpose function
08:21:50 <aavogt> in which dimension?
08:21:56 <dmwit> :t transpose
08:21:58 <lambdabot> forall a. [[a]] -> [[a]]
08:22:00 <dmwit> um
08:22:11 <dmwit> What is this reverse transpose supposed to do?
08:22:37 <netinho2lol> transpose rotates to the right
08:22:47 <netinho2lol> reverse transpose rotates to the left
08:22:51 <dmwit> um
08:22:56 <ddarius> transpose doesn't rotate
08:22:57 <dmwit> transpose doesn't rotate...?
08:23:06 <benmachine> it flips
08:23:08 <evolio__> ok, to try and understand things i'm going to write two functions, square and double, to square a number and double it with the function squareDouble
08:23:26 <dmwit> evolio__: That sounds like a good place to start.
08:24:01 <netinho2lol> it's a list of lists so I see it as a matrix of numbers and then a figure... that rotates
08:24:05 <netinho2lol> :)
08:24:41 <ddarius> netinho2lol: It doesn't rotate, it flips about the diagonal.  You could rotate in the 3rd dimension but it would be the same way whether you rotated one "way" or another.
08:25:28 <aavogt> leaves the other diagonal intact?
08:26:35 <ddarius> > transpose ["ab","cd"]
08:26:36 <lambdabot>   ["ac","bd"]
08:26:54 <aavogt> > transpose $ map reverse ["ab","cd"]
08:26:54 <netinho2lol> > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]
08:26:55 <lambdabot>   ["bd","ac"]
08:26:56 <lambdabot>   True
08:27:20 <aavogt> > transpose $ map reverse $ transpose ["ab","cd"]
08:27:21 <lambdabot>   ["cd","ab"]
08:27:46 <netinho2lol> reversetranspose [[1,2,3],[4,5,6]] == [[3,6],[2,5],[1,4]]
08:28:06 <evolio__> dmwit, i've wrote the square and double functions and they're working
08:28:17 <evolio__> i now want to write squareDouble
08:28:33 <evolio__> so would that be squareDouble :: Int -> Int -> Int
08:28:58 <netinho2lol> reversetranspose [[1,2,3],[4,5,6]] == [[3,6],[2,5],[1,4]]
08:29:00 <netinho2lol> ops
08:29:00 <quuuux> evolio__: well, with squareDouble, you put in a Int and get out an Int, so it's only Int -> Int
08:29:01 <netinho2lol> sorry
08:29:12 <evolio__> evolio__, ok
08:29:19 <evolio__> why do i keep doing that?
08:29:32 <evolio__> quuuux, ok
08:29:36 <aavogt> > join (*) . join (+) $ 2
08:29:38 <lambdabot>   16
08:29:52 <quuuux> evolio__: what you need is some function (Int -> Int) -> (Int -> Int) -> (Int -> Int)
08:30:37 <quuuux> evolio__: that is, it takes two functions from Int to Int and gives you back a third. The one you're looking for happens to be called (.)
08:30:57 <ddarius> netinho2lol: Any rotation can be made by two reflections.  transpose is a reflection and reverse is a reflection, so reverse . transpose is a rotation.
08:32:32 <gwern> hm. I wonder if Go, powered by optimal players, is turing-complete
08:32:40 <gwern> games can be indefinitely long, after all
08:32:57 <ddarius> gwern: There's only a finite amount of state.
08:33:04 <aavogt> does go have non-repeat rules?
08:33:14 <gwern> ddarius: oh, right. then an indefinitely large board then?
08:33:29 <quuuux> gwern: how do you then score it?
08:33:47 <gwern> aavogt: so far as I know, it doesn't, because eyes mean that between pros, eventually you reach a point where further play hurts you
08:34:00 <EvanR> aavogt: yes, game ends if you repeat the move twice or something
08:34:15 <gwern> quuuux: well, that's like asking how life can beturing-complete, I think
08:34:16 <quuuux> actually, there are no-repeat rules, though they vary depending on the -exact- ruleset
08:34:28 <quuuux> gwern: no, I mean how do you score territory on an infinite board?
08:34:59 <gwern> quuuux: the number of stones which are alive? (that is, part of enclosures with multiple eyes)
08:35:05 <evolio__> ok, gotcha quuuux
08:35:20 * gwern has a theory that territory counting is just a shortcut for 'how many live stones does a player have'
08:35:57 <benmachine> I thought go had a rule where you weren't allowed to return the board to a prior state?
08:35:59 <quuuux> gwern: okay, that's defensible, but the game would then never stop on an infinite board, because I'll just move 200 squares east of the most easterly stone
08:36:08 <ddarius> I highly suspect that restricted to optimal players you'd only have a small set of equivalence classes of games.
08:36:20 <quuuux> benmachine: yes, the ko rule, but different associations have different versions
08:36:23 <gwern> benmachine: the ko rule bans, I think, immediate returns to a prior state
08:36:37 <gwern> benmachine: it'd be hard to enforce such a rule on every turn :)
08:36:44 <benmachine> hard but not impossible!
08:37:09 <quuuux> some of the flavours: you can't return to -any- prior board state, you can return to a prior board state so long as the turn parity is different, you can't return to an immediately prior state
08:37:23 <gwern> ddarius: well, that's plausible. we could probably code up players complex enough to cooperate and compute, but then they're practically turing-complete in and of themselves and the fun of the thought-problem is gone
08:37:52 <evolio__> quuuux, http://pastebin.com/m257a5864 is what i have so far
08:37:59 <ddarius> gwern: Yeah, I'm pretty sure if you allow all players then you can easily model a Turing machine on an infinite go board.
08:38:04 <EvanR> infinite go board, i guess thats like the infinite resistive network
08:38:37 <quuuux> evolio__: that type signature for squareDouble is wrong. That type signature means it takes two functions and gives you a third
08:38:48 <evolio__> sorry
08:38:58 <evolio__> got you confused
08:39:03 <evolio__> making it hard for myself :)
08:39:07 <quuuux> evolio__: no, my mistake, I was trying to be too complicated with my explanation
08:39:34 <dmwit> evolio__: Maybe you'd better master first-order functions before you start tackling higher-order functions. =P
08:39:44 <evolio__> heh yeah
08:40:21 <ddarius> I wonder what the maximum number of states you'd have to remember in any single game on a go board that disallows ever returning to a previous state.
08:40:47 <evolio__> in php i would just do $x = 5, $x = square($x), $x = double($x)
08:40:51 <gwern> ddarius: would 'state' include # of stones captured?
08:41:03 <EvanR> dmwit: this results in error type Queue = ([a],[b]), a and b not in scope
08:41:14 <ddarius> gwern: Presumably that is irrelevant for the rule of ko.
08:41:17 <ddarius> So no.
08:41:21 <quuuux> gwern: here's a conjecture: on an infinite go board, with stone scoring, an optimal strategy is to make a line of stones heading eastwards, making kinks only if blocked by opposing stones
08:41:22 <dmwit> ddarius: In the worst case, all of them, as one player can play long enough to fill in his own eyes, then pass long enough for the opponent to capture all his stones.
08:41:41 <gwern> ok; because if it did include # of stones, then trivially your answer is # of all possible states :)
08:41:47 <quuuux> gwern: I think this can be reduced to a version of Conway's angel game
08:41:51 <dmwit> EvanR: type Queue a = ([a], [a]) -- gotta declare which type variables you're using
08:41:54 <evolio__> to square 5 then double the result. how does one write that in haskell inside my fucntion
08:42:25 <quuuux> evolio__: (double . square) 5
08:42:36 <EvanR> dmwit: got it.
08:42:36 <dmwit> > let square = (^2); double = (*2) in square (double 5)
08:42:37 <lambdabot>   100
08:42:46 <Cale> quuuux: er... you'll be captured eventually if you do that.
08:42:46 <dmwit> > let square = (^2); double = (*2) in double (square 5)
08:42:47 <lambdabot>   50
08:43:11 <dmwit> evolio__: Just apply both functions. =)
08:43:23 <Cale> quuuux: though, I suppose if you have a general enough definition of 'kink' and 'blocked' perhaps it's rescuable :)
08:43:24 <dmwit> evolio__: There's a handy shortcut for this, the . operator, but start simple. =)
08:43:39 <aavogt> I would say that . is simpler
08:43:54 * dmwit shrugs
08:43:55 <dmwit> maybe so
08:44:08 <gwern> quuuux: what happens if I go 1 million spaces in front of you, and spend every time zizagging alternately back to the origin, 'wrapping around' you? then your kinks will only be able to go backwards and I can finish encircling you, capturing that group
08:45:13 <Cale> I don't think Go makes so much sense on an infinite board.
08:45:15 <quuuux> gwern: you need to construct a 'triangle' to catch me, which takes twice as many stones as it is deep
08:45:44 <dmwit> Cale: exactly
08:46:03 <Cale> quuuux: I only need to make a comparatively light shape to eat your heavy group. :)
08:46:08 <gwern> quuuux: but I'll still have stones around much of your group, and if you try to break through I'll be in a better tactical position than you
08:46:09 <EvanR> dmwit: heres the version with Queue, and it actually works (testing with mapM_ print (rand (repeat 0)), takes a while to 'start up'... but anyway is there anything stylistically wrong with it? tips appreciated
08:46:17 <Cale> quuuux: I only have to thicken it if you threaten to cut.
08:46:18 <gwern> and if you go west instead, I do the same thing
08:46:36 <evolio__> ahah, and squareDouble 0.1 beta is going
08:46:38 <evolio__> go
08:46:41 <Cale> quuuux: Which you won't even do if you stick to your plan.
08:46:45 <evolio__> :)
08:46:52 <dmwit> evolio__: Awesome!
08:47:08 <Paczesiowa> what's the difference between "let foo = f in foo x" and "f x" ? I have an example when first one typechecks and the second one result in occurs check
08:47:22 <evolio__> i'll get a cvs going for this groundbreaking piece of software
08:47:52 <dmwit> The former allows foo to specialize its polymorphic type differently in different places in the body of the "in".
08:47:56 <Cale> Paczesiowa: the free type variables which occur while inferring the type of something bound by let will be generalised.
08:48:00 <dmwit> The latter allows exactly one specialization.
08:48:16 <ddarius> Unless f itself is let bound.
08:48:20 <dmwit> So, for that particular example, no difference.
08:48:31 <dmwit> But, for "let foo = f in (foo x, foo y)", there could be a difference.
08:48:45 <dmwit> erm
08:49:01 <Cale> > let foo = id in (foo 5, foo "hello")
08:49:03 <lambdabot>   (5,"hello")
08:49:11 <Cale> > (\foo -> (foo 5, foo "hello")) id
08:49:13 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
08:49:13 <lambdabot>    arising from the literal ...
08:49:15 <evolio__> i think i'm gonna go get a coffee and some food, thanks very much so far for your help
08:49:16 <evolio__> :)
08:49:46 <Paczesiowa> ok, there are no pairs, but f is a method, does that matter?
08:49:53 <Cale> > ((\foo -> (foo 5, foo "hello")) :: (forall a. a -> a) -> (Integer, String)) id
08:49:55 <lambdabot>   (5,"hello")
08:50:04 <BONUS> anyone got any good papers on irregular types?
08:50:10 <BONUS> like polymorphic recursion and that stuff
08:50:19 <ddarius> BONUS: Google "nested data types"
08:50:27 * Cale wonders what it is that's causing network activity on his machine...
08:50:44 <monochrom> someone playing games with lambdabot
08:50:46 <BONUS> ah, cheerio
08:50:53 <Cale> not lambdabot
08:51:00 <Cale> Lambdabot doesn't run on my machine
08:51:11 <Cale> It runs on lispy's machine, I just keep it running :)
08:51:20 <jlouis> netstat -anput :)
08:51:30 <gwern> Cale can't fess up to his grandmotherxdwarf pron torrents
08:53:07 <gwern> > 17*17
08:53:09 <lambdabot>   289
08:53:35 <Paczesiowa> covering your sick ideas with basic arithmetic?
08:54:03 <Cale> Apparently Google?
08:54:08 <Cale> huh...
08:54:41 <Cale> My web browser is not running. Maybe their spider is ignoring my robots.txt?
08:54:51 <Cale> Oh well, it's passed.
08:55:00 <hotaru2k3> > let squareDouble = uncurry (.) $ join (***) join ((*),(+)) in squareDouble 5
08:55:01 <lambdabot>   100
08:55:06 <quuuux> okay, emacs question time: is there an ungodly child of C-x 4 0 and C-x 1, which deletes all the other windows and kills their buffers except the active one?
08:55:39 <monochrom> No.
08:55:40 <copumpkin> > (.) `on` join (*) (+) 2
08:55:41 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
08:55:41 <lambdabot>    arising from a use of `GHC.Num.+'...
08:55:50 <copumpkin> > (.) `on` join $ (*) (+) 2
08:55:52 <lambdabot>   Precedence parsing error
08:55:52 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
08:55:54 <copumpkin> bah
08:56:02 <copumpkin> > ((.) `on` join) (*) (+) 2
08:56:03 <lambdabot>   16
08:56:06 <copumpkin> there we g
08:56:13 <copumpkin> > ((.) `on` join) (*) (+) 5
08:56:15 <lambdabot>   100
08:56:26 <dmwit> You can't even express triumph properly. =P
08:56:29 <copumpkin> :(
08:56:31 * copumpkin fails hard
08:56:56 <ddarius> > fix fail
08:56:57 <lambdabot>   ""
08:57:12 <monochrom> Oh that's neat!
08:57:22 <copumpkin> :t fix fail
08:57:24 <lambdabot> String
08:57:35 <copumpkin> indeed!
08:57:46 <dmwit> :t fmap fix return
08:57:48 <lambdabot> forall a. a -> a
08:58:15 <dmwit> > fmap fix return "most complicated id known to man"
08:58:16 <hotaru2k3> > on (.) join (*) (+) 5
08:58:16 <lambdabot>   "most complicated id known to man"
08:58:17 <lambdabot>   100
08:58:37 <copumpkin> damn, hotaru2k3 beat me
08:58:51 <monochrom> I challenge you on that. fmap fix return (fmap fix return)
08:58:56 <shachaf> dmwit: There are more complicated implementations of id!
08:59:24 <dmwit> > liftM2 (.) (^) (*) 2 5
08:59:26 <lambdabot>   1024
08:59:30 <dmwit> hm
08:59:31 <shachaf> fmap fix return is really just fancy name for fix . const.
08:59:55 <dmwit> oh
09:00:33 <dmwit> > on (liftM2 (.)) flip (^) (*) 2 5
09:00:34 <lambdabot>   100
09:00:38 <dmwit> yuck
09:00:46 <copumpkin> lol
09:01:15 <copumpkin> okay, someone come up with a grammar of expressions that produce that result
09:01:22 <copumpkin> using those combinators
09:01:25 <ddarius> I like hotaru2k3's the most because there is no (explicitly) nested syntactical structure.
09:01:30 <copumpkin> yeah
09:01:39 <Veinor> it's conventional to separate testing code and actual code code in different .hs files, yes?
09:01:43 <benmachine> > return (fmap fix return) (fix return fmap) 9
09:01:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = m a
09:01:47 <benmachine> aw
09:01:48 <copumpkin> Veinor: depends who you ask
09:01:53 <ddarius> And hey, it's treating on as a 6-ary function.
09:02:03 <copumpkin> :)
09:02:19 <ddarius> er 5-ary
09:02:20 <Veinor> hm
09:02:36 <Veinor> basically I'm going to be packaging nimber for hackage and I want to add some quickcheck tests
09:02:52 <Veinor> which will pretty much consist of the usual field properties :P
09:03:08 <copumpkin> you could make an instance of Field using numeric-prelude
09:03:14 <copumpkin> if you can get over the um
09:03:16 <copumpkin> naming scheme
09:03:18 <ddarius> Veinor: Have you looked at the checkers package?
09:03:24 <Veinor> checkers?
09:03:29 <ddarius> @hackage checkers
09:03:30 <lambdabot> http://hackage.haskell.org/package/checkers
09:03:31 <copumpkin> not the game
09:03:57 <benmachine> > return fmap fix fmap return x
09:03:58 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
09:03:59 <lambdabot>                    GHC.Show...
09:04:04 <benmachine> blah.
09:04:07 <Veinor> eh, I think it might just be best to do, say
09:04:29 <Veinor> distributes x y z = (x + y) * z == x * z + y * z :: Nimber -> Nimber -> Nimber -> Bool
09:04:30 <benmachine> oh whoops
09:04:35 <benmachine> > return fmap fix fix return x
09:04:36 <lambdabot>   x
09:04:51 <Veinor> :t return fmap fix fix return
09:04:52 <lambdabot> forall a. a -> a
09:04:56 <Veinor> heh
09:05:06 <copumpkin> Veinor: numeric-prelude has a properties module
09:05:08 <copumpkin> which you could use
09:05:10 <benmachine> one of those fixes is actually arbitrary I think
09:05:12 <copumpkin> to avoid writing those out
09:05:25 <Veinor> :t return fmap f fix return
09:05:27 <lambdabot>     Ambiguous type variable `a' in the constraint:
09:05:27 <lambdabot>       `SimpleReflect.FromExpr a'
09:05:27 <lambdabot>         arising from a use of `f' at <interactive>:1:12
09:05:29 <monochrom> > fmap fix return (return fmap fix fix return) x
09:05:30 <lambdabot>   x
09:05:30 <Veinor> heh
09:05:34 <Veinor> copumpkin: link?
09:05:39 <copumpkin> @hackage numeric-prelude
09:05:40 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
09:05:52 <Veinor> I know I don't have to check for commutativity or any properties or +
09:06:01 <Veinor> er, commutativity of*
09:06:12 <copumpkin> but it's not too pretty
09:06:35 <Veinor> hm
09:06:52 <copumpkin> it uses a certain naming scheme
09:07:20 <copumpkin> lol, Number.GaloisField2p32m5
09:08:22 <copumpkin> > 2^32 - 5
09:08:24 <lambdabot>   4294967291
09:08:44 <monochrom> hahaha
09:09:16 <napsy> What's the haskell operator for "not equal" (!=)?
09:09:19 <copumpkin> I guess it's something that needs its own module
09:09:23 <dibblego> napsy, /=
09:09:29 <napsy> thanks
09:09:36 <dons> :t (/=)
09:09:37 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:10:07 <monochrom> > False /= False
09:10:08 <lambdabot>   False
09:10:09 <Veinor> that's a very specific module
09:10:35 <Veinor> you'd think it'd be -1
09:10:45 <ddarius> copumpkin: I like the list of instances.
09:11:13 <monochrom> Wait, a Galois field cannot have order 2^32-5. Must have prime^power order.
09:11:19 <Veinor> it's really an instance of C T
09:11:20 <copumpkin> ddarius: yeah, it's awesome
09:11:41 <copumpkin> check out the instances on Module
09:11:41 <copumpkin> http://hackage.haskell.org/packages/archive/numeric-prelude/0.1.3/doc/html/Algebra-Module.html#t%3AC
09:12:01 <benmachine> monochrom: 2^32-5 is prime?
09:12:04 <Veinor> monochrom: 2^32-5 is prime
09:12:07 <copumpkin> pity the beauty is marred by the Ord and Eq names
09:12:11 <monochrom> Oops.
09:12:11 <Veinor> I just checked in Mathematica
09:12:18 <copumpkin> , isPrime
09:12:19 <lunabot>  luna: Not in scope: `isPrime'
09:12:22 <benmachine> I checked with dc
09:12:22 <copumpkin> :t isPrime
09:12:24 <lambdabot> Not in scope: `isPrime'
09:12:26 <benmachine> using this program I wrote:
09:12:27 <benmachine> 10asn[lpnlnnlp/dvsrltx]ss[dlp%0=s]st[ltxlp2+splrlp!>l]sldvsr2spltx3spllx[p]spd1!=pc
09:12:34 <monochrom> I checked in #haskell
09:12:58 <Veinor> benmachine: oh hey, I didn't know you were a perl programmer
09:13:01 <Veinor> dohohohohohohohohoho
09:13:03 <monochrom> Oh did you know that some perl regex can determine primality too? :)
09:13:05 <benmachine> Veinor: :D
09:13:07 <benmachine> monochrom: yes
09:13:28 <benmachine> something like 1 x $num =~ m/(11+)\1+/
09:13:42 <Veinor> I think that would do it, yeah
09:14:10 <bfh6558> SO... is there a #xmonad ?
09:14:20 <bfh6558> or is this where i can find answers for that?
09:15:02 <xternal> bfh6558: aye, there is an #xmonad
09:15:02 <Paczesiowa> bfh6558: why don't you check that channel?
09:15:30 <Veinor> http://www.mentalfloss.com/blogs/wp-content/uploads/2009/12/original_lolcat.jpg
09:31:58 <stulli> How do i match parenthesis in Tex.Regex.Posix? Escaping with \ didn't work
09:32:03 <stulli> Text*
09:32:29 <ben> Tried not escaping them?
09:32:46 <stulli> yes, that doesn't work either
09:33:06 <Paczesiowa> [(]?
09:33:29 <stulli> wow, that worked, thanks
09:33:36 <Paczesiowa> that looks like a hamburger...
09:33:53 <ddarius> Paczesiowa: ...
09:34:13 <mauke> stulli: how did you escape them?
09:34:27 <Paczesiowa> ddarius: what? I'm hungry...
09:35:18 <Veinor> ([]|
09:35:20 <Veinor> omnomnom
09:35:23 <stulli> mauke, backslash liki "foo(xyz" =~ "foo\(.*"
09:35:29 <mauke> > "\("
09:35:30 <lambdabot>   <no location info>:
09:35:30 <lambdabot>      lexical error in string/character literal at end o...
09:35:42 <mauke> that looks invalid
09:35:58 <mxyz> how do you link a .dll to ghci?
09:36:26 <Paczesiowa> -llib.dll?
09:36:45 <stulli> just wondering why i can't just escape them with a backslash
09:36:50 <Veinor> > "\\("
09:36:51 <lambdabot>   "\\("
09:36:56 <Veinor> > "\("
09:36:57 <lambdabot>   <no location info>:
09:36:58 <lambdabot>      lexical error in string/character literal at end o...
09:37:06 <Veinor> > '\' ++ "("
09:37:08 <lambdabot>   <no location info>:
09:37:08 <lambdabot>      lexical error in string/character literal at chara...
09:37:11 <Veinor> > '\'
09:37:13 <lambdabot>   <no location info>:
09:37:13 <lambdabot>      unexpected end-of-file in string/character literal...
09:37:15 <Veinor> :/
09:37:17 <Paczesiowa> stulli: probably you have to escape that escaping backslash
09:37:40 <mauke> stulli: because Haskell uses the \ in its string syntax
09:37:50 <Paczesiowa> haskell will eat one of them
09:37:55 <Philonous1> > '\\'
09:37:56 <lambdabot>   '\\'
09:37:58 <Veinor> yeah, you want "\\("
09:38:13 <stulli> hm, yeah. With the regex [(] worked aswell as \\(
09:38:14 <mxyz> Paczesiowa: using -l it says it loaded the dll
09:38:34 <mxyz> but when i call a function it says "can't load .so/.DLL for: portaudio (addDLL: could not load DLL)"
09:38:56 <Paczesiowa> mxyz: sorry, no idea.
09:39:01 <mxyz> the only way i get it to work is if i run ghci from inside the directory with the dll
09:39:33 <shachaf> > value
09:39:35 <lambdabot>   "\("
09:39:55 <Paczesiowa> mxyz: there is LD_LIBRARY_PATH env var for linux, maybe windows has something like that too
09:41:46 <Axman6> > filter (== '_') . map (\x -> if x == ' ' then ',' else x) "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:41:47 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:41:47 <lambdabot>         against inferred ty...
09:42:04 <Axman6> > filter (== '_') . map (\x -> if x == ' ' then ',' else x) $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:42:06 <lambdabot>   "______________________________________________"
09:42:11 <bd_> Paczesiowa: it's just PATH on windows
09:42:12 <Axman6> > filter (/= '_') . map (\x -> if x == ' ' then ',' else x) $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:42:13 <lambdabot>   "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,...
09:42:58 <monochrom> hehehe
09:43:09 <Axman6> > filter (\x -> x /= '_' || x /= ',') . map (\x -> if x == ' ' then ',' else x) $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:43:10 <lambdabot>   "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,a_,b_,c_,d_,e_,f_,g_,h...
09:43:25 <Axman6> > filter (\x -> x /= '_' && x /= ',') . map (\x -> if x == ' ' then ',' else x) $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:43:26 <lambdabot>   "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghij"
09:43:33 <Axman6> > length . filter (\x -> x /= '_' && x /= ',') . map (\x -> if x == ' ' then ',' else x) $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:43:35 <lambdabot>   62
09:44:24 <m3ga> i'm looking at some code that uses something called green-card for FFI generation. Is green-card still in common usage? Is something else preferred?
09:44:49 <napping> Is it just calling C?
09:45:25 <Axman6> > length . filter isAlpha $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
09:45:26 <lambdabot>   62
09:45:29 <Axman6> -_-
09:46:47 <arsenm> m3ga: I think it's more common to use c2hs now
09:47:35 <muri_one> why aren't gtk2hs and glade in hackage?
09:47:53 <Axman6> because they can't be installed with cabal-install afaik
09:48:38 <muri_one> why can't they be installed by cabal?
09:49:25 <mxyz> muri_one: that gets asked a lot :)
09:50:13 <mxyz> why isnt "ghci -L"C:\portaudio\bin" -lportaudio" working?
09:50:39 <mxyz> ghci --help says that you can pass .dll names in as arguments but that doesnt work either
09:50:41 <Axman6> argh, i need a good example of how to use tuples
09:50:58 <Axman6> for the wikipedia article
09:51:53 <dons> gtk2hs has a complicated build system
09:56:17 <mxyz> ghci says "- Dynamic libraries (.so suffix, or .dll on Windows)" can be passed as arguments. Has anyone gotten that to work?
09:57:11 <Axman6> @src sip
09:57:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:57:14 <Axman6> @src zip
09:57:14 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:57:14 <lambdabot> zip _      _      = []
09:58:05 <Axman6> > zip [1..5] "hello
09:58:06 <lambdabot>   <no location info>:
09:58:06 <lambdabot>      lexical error in string/character literal at end o...
09:58:11 <Axman6> > zip [1..5] "hello"
09:58:12 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
09:59:13 <copumpkin> > zip [1..] "hello"
09:59:14 <lambdabot>   [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
10:05:43 <Axman6> anyone mind taking a look at the tuples section here? http://en.wikipedia.org/wiki/Haskell_(programming_language)#Algebraic_data_types i've just added it (I added the ADT and pattern matching sections yesterday, so i wouldn;t mind someone taking a look at those too)
10:07:27 <Axman6> dons: would you be able to take a look ay the ST and STM monad sections in http://en.wikipedia.org/wiki/Haskell_(programming_language)#Monads_and_input.2Foutput ? i Added those last night, and i thought you might have some ideas on improvement perhaps
10:08:52 <dolio> I don't know if it's strictly accurate to say that ST functions are pure in themselves.
10:09:14 <Axman6> they are when run though right?
10:09:46 <dolio> It's that the impurity is contained in a sort of scope, while the results are ultimately pure.
10:10:43 <dolio> It's rather like the observation that you can write pure functions in C, but ST makes that explicit and enforced.
10:11:06 <dolio> Pure functions that use mutability internally, that is.
10:12:19 <dons> the effect is local, and guaranteed not to escape by the clever type.
10:14:11 <andun> if f(k) == f(k) if k == k and f doesn't have any side effects, f is pure, right?
10:14:40 <andun> I guess the latter implies the first
10:15:08 <napping> the first part should be enough
10:16:02 <napping> "side effects" you can only observe in IO don't really count
10:16:33 <andun> napping: in general... f(x) = print "yo"; return x is obviously impure
10:17:09 <dolio> Well, an impure function needn't be in IO. IO is a way to regain a sort of purity for side effects.
10:18:02 <andun> dolio: an impure function *can't* be in IO, or anywhere else in haskell :)
10:19:13 <dolio> Well, even Haskell has trap doors.
10:19:29 <andun> no, hush! don't say the u word!
10:19:51 <dolio> unsafeInterleaveST?
10:20:39 <andun> maybe "a pure function is a function that can be represented in haskell" is a suitable definition? :)
10:21:07 <Axman6> dolio: do you prefer this? http://en.wikipedia.org/wiki/Haskell_(programming_language)#ST_monad
10:21:52 <dolio> Yeah, I think that's better.
10:22:01 <Axman6> excellent :)
10:22:09 <Axman6> got an y thoughts on the STM section?
10:22:33 <Axman6> (it's rather large...)
10:24:10 <dolio> I think it'd be good to explain how even locks (MVars) have a race condition for that program.
10:24:39 <dolio> Because you can't compose correctly locked programs to get correctly locked programs.
10:25:53 <FuriousJoe> Hey, I can't figure this out, and I was wondering if someone could help. This code: (getStdGen >>= (\x -> return (random x))) works fine in ghci, but when I put it into the function let (num, _) = (getStdGen >>= (\x -> return (random x))) in return num, it has type errors that say it can't match expected type (Int, a) with infered type IO StdGen
10:26:36 <dolio> I suppose you'd need to modify it a bit. Write a "credit :: Account -> Int -> IO ()" and debit. Then write transfer in terms of credit and debit.
10:27:15 <dolio> credit and debit would each be correctly locked, but you'd need an extra lock around them in transfer to ensure consistency.
10:36:48 <Axman6> dolio: perhaps you'd like to add something along those lines?
10:37:32 <luite> is it possible to write this in a nicer way: f m x = case g x of [] -> ...; [y] -> ...; (y:ys) -> ...;
10:38:58 <roconnor> luite: add a helper function in a where clause
10:40:57 <luite> is this not something that can be done with view patterns?
10:42:46 <napping> luite: you have three cases. It's not going to get uch nicer than that
10:43:24 <napping> you might write (g -> x) and case x of instead of what you have
10:45:54 <luite> it's not that bad, I was just wondering if it could be done better :p
10:47:18 <fracture> anyone here ever done pixel-manipulation in haskell's SDL bindings?  (it looks like the library may not allow this?)
10:47:45 <fracture> (there's a surfaceGetPixels function, but it doesn't appear that you can do anything with them)
10:48:12 <napping> How are they defined?
10:49:55 <fracture> http://pastebin.com/m2e74460e
10:49:58 <fracture> in the hsc
10:50:15 <fracture> which I guess means it is an opaque pointer as far as haskell is concerned
10:50:24 <fracture> (but i haven't played with hsc stuff so I don't know)
10:51:40 <dolio> Axman6: Would I have to get a wikipedia account to do that?
10:51:52 <Axman6> dolio: i don't believe so
10:52:15 <napping> ptr is not very strongly typed
10:53:01 <fracture> :P
10:53:12 <fracture> it looks like that function is somewhat useless, no?
10:54:23 <napping> you can peek whatever type you like. not so clean, but the C docs should explain what to expect
10:54:56 <fracture> what do you mean?
10:55:10 <fracture> in the C libs, this is an array of bytes that has a format depending on the surface type
10:55:30 <fracture> so it's pixel data, with a particular bpp, stride, etc
10:55:45 <fracture> but it doesn't look like I can mutate that from the haskell bindings?
10:55:54 <fracture> (if I can I don't know how)
10:56:23 <napping> see castPtr and peekByteOff
10:58:17 <fracture> I want pokeByteOff?
11:00:26 <blobl> is haskell bigger than life? no
11:01:04 <napping> pokeByteOff, or maybe use castPtr once plus Foreign.Marshal.Array syuff
11:02:49 <luite> @pl f (x,y) = (x,y,())
11:02:49 <lambdabot> f = uncurry (flip flip () . (,,))
11:05:09 <fracture> hrm... what does invocation of castPtr usually look like?
11:05:13 <fracture> not sure how to specify the return type I want
11:05:59 <napping> with how you use it later, or with a type signature somewhere
11:06:18 <fracture> oh just make a new function out of it?
11:06:47 <luite> > let f = uncurry (,,()) in f (1,2)
11:06:49 <lambdabot>   <no location info>: parse error on input `('
11:06:56 <luite> hmm, it doesn't know tuple sections yet
11:06:59 <fracture> castToPixels :: Ptr a -> Ptr Pixel
11:06:59 <fracture> castToPixels = castPtr
11:07:02 <fracture> doesn't quite work?
11:08:46 <napping> that should work, if you have a suitable Pixel
11:09:00 <fracture> ok; it's probably something else then (lookin into it)
11:09:02 <fracture> thanks for the help, btw
11:09:53 <mxyz> fracture: yo. i still couldnt find a way to pass the dll to ghci but i put up a tutorial: http://www.subreddits.org/misc/haskell/portaudio.html
11:10:55 <fracture> mxyz: nice; looks cool
11:12:57 <BMeph> luite: This may have been what other folks meant, concerning your earlier question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13719#a13719
11:13:07 <uorygl> That's kind of a terse definition of zip.
11:13:16 <uorygl> Whoops, I was scrolled up.
11:13:17 <luite> mxyz: can't you skip step [4] and [5] in 3b? (configure and install)
11:13:41 * fracture wrote a pixel to a sdl surface.
11:13:43 <fracture> huzzah. :)
11:13:56 <BMeph> fracture: Grats! :)
11:16:40 <luite> BMeph: are you sure that works?
11:17:53 <mxyz> luite: if you do step 3a you are not supposed to do 3b
11:18:42 <luite> mxyz: I mean if you execure step 6, it will automatically configure and build the package
11:19:06 <mxyz> oh! i didnt know. im quite new to this. i only copied the instructions i got at haskell-cafe
11:19:13 <mxyz> i will update the tutorial
11:19:54 <mxyz> thank you. also, i missed a step about editing the .def file and have to update the binaries.
11:20:24 <fracture> @hoogle liftIO
11:20:25 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
11:23:20 <Axman6> @src MonadIO
11:23:21 <lambdabot> Source not found. My mind is going. I can feel it.
11:23:52 <pastah_rhymez> what's the name of that lib that lets you dump binary data?
11:24:04 <pastah_rhymez> i think you get a function 'put' or something
11:24:14 <pastah_rhymez> (or if it was a typeclass)
11:24:34 <Axman6> Data.Binary, from the binary package
11:26:39 <pastah_rhymez> thank you :)
11:30:02 <Axman6> there's another one using strict bytestrings if you'd prefer that
11:30:09 <Axman6> but i can't remember its name
11:32:06 <dolio> Axman6: http://en.wikipedia.org/wiki/Haskell_(programming_language)#STM_monad  What do you think?
11:32:53 <BMeph> luite: That should do the same thing your original did, it's just using those two extensions there at the top to give you that shorter form.
11:33:25 <fracture> hrm... I seem to remember an easy way to do an IO action multiple times (but it was a general monad tool thing)
11:33:29 <fracture> anyone know what I'm thinking of?
11:33:48 <Axman6> dolio:  looks good. i think i'll change the improved transfer version (the one checking to see if there's enough cash) to use that :)
11:34:15 <BMeph> fracture: replicateM_, maybe? :)
11:34:22 <fracture> ah that sounds like it
11:34:47 <hotaru2k3> @hoogle replicateM
11:34:48 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:34:48 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
11:35:13 <fracture> yep that's it; thanks
11:35:29 <luite> BMeph: I enabled those two extensions, but it gives me a parse error on ->
11:36:29 <luite> BMeph: (not because of the missing ) in the y:ys case)
11:36:52 <pastah_rhymez> does anyone know the etymology of "Return From Subroutine" == "RTS"
11:37:10 <Axman6> dolio: ok, changed it so that it now checks there's enough money, then uses debit and credit to make the transfer
11:37:26 * pastah_rhymez is working on his state machine...
11:37:57 <dolio> Axman6: You should remove my note that we won't be using credit and debit anymore, then.
11:38:07 <Axman6> heh, ok
11:39:46 <Axman6> done
11:49:04 <luite> I have a function f::(Ord a) => [a] -> Bool, f xs = .... where graph = G.topsort' (G.mkGraph v e),  G is Data.Graph.Inductive, the type of the graph should be G.Gr a (), for the same a as the type of the function
11:49:14 <luite> how can I specify that in a type signature?
11:50:18 <napping> say f:: forall a . ... in the function signature, and turn on the right extension
11:50:24 <luite> oh I messed up with the names, graph is not a graph but a topologically sorted list of vertex labels
11:50:50 <luite> napping: hmm, I don't think that's what I want
11:51:07 <napping> ScopedTypeVariables? with the right extension on, any variable you explicitly introduce with a forall becomes available in local signatures
11:51:31 <luite> ooh I see
11:52:35 <luite> thanks, didn't know that, it works
11:52:43 <luite> ScopedTypeVaribles indeed
11:52:47 <luite> Variables
11:58:47 <luite> if I have a data type data Z = Z1 | Z2 | Z3 | Z4 deriving (Eq,Ord,Enum,Show), is it possible to get a list of all constructors without having to specify the first (enumFrom Z1)?
11:59:04 <bd_> add a deriving Bounded and do [minBound..maxBound]
11:59:37 <luite> oh I just thought of another way: enumFrom (toEnum 0) :: [Z]
11:59:55 <bd_> that works
12:08:29 <erikc> hmm, i've been out of the loop for a while, so there will be a new haskell report in 2010?
12:10:02 <Cale> erikc: Yes, but it is not exciting.
12:10:36 <erikc> standardizing already existing extensions
12:10:47 <Cale> And only very boring ones at that
12:11:07 <Cale> erikc: However, the idea is that they've made some progress with other stuff, and so should be able to continue the standards progress.
12:11:23 <Cale> process*
12:11:47 <Cale> So perhaps there will also be one in 2011
12:11:47 <erikc> right
12:25:31 <pastah_rhymez> <3 <3 <3 haskell <3 <3 <3
12:25:46 * pastah_rhymez wrote something very elegant
12:30:44 <adu> nice
12:34:58 <fracture> is there a way to specify the type of a function declared in a let binding?
12:35:19 <fracture> or if I want that is something probably wrong with my approach here...?
12:35:33 <ddarius> fracture: You do it the same way you do for any other function.
12:36:55 <fracture> ah thanks
12:37:02 <fracture> turned out it wasn't the problem anyway...
12:37:14 <fracture> (had turned a lambda into a local function, but accidently left the (\x -> ....) stuff in there)
12:38:05 <stulli_> another question: Can you check the type of a let/where binding in ghci?
12:38:16 <ddarius> Nope.
12:38:33 <ddarius> Chameleon's type debugger can do that though.
12:38:41 <dons> :t let x = 1 in x
12:38:42 <lambdabot> forall t. (Num t) => t
12:39:00 <dons> a binding expression can be checked, if that's what you meant.
12:39:31 <napping> but it's not so simple to check something in a function
12:40:03 <dons> inside another function? no.
12:40:08 <dons> nothing that's not at top level scope
12:40:16 <dons> except if you're in the debugger.
12:40:27 <dons> you can step through evaluation until the binding is in scope, then query its type
12:40:31 <stulli_> Well, i often look at somebody else's code (with very large where sections) and it would be so much easier to understand if i knew the types
12:44:22 <BMeph> luite: Sorry, I  messed that up; try this drop-in: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13719#a13728
12:46:31 <luite> would that be compiled to a 'case g .. of', or could g be executed more than once?
12:51:01 <luite> BMeph: thanks for the example, I'll check that later with ghc-core
12:51:28 <mxyz> anyone using Happy?
12:55:21 <mxyz> do I need to install Perl to install the Happy package?
12:59:37 <fracture> so... I wrote a haskell line drawing function for SDL... if anyone feels like telling me anything that could be done better, I'd appreciate it:  http://pastebin.com/m7a12104e
13:00:30 <fracture> (more interested in things that are not idiomatic haskell (I think like a C++ programmer) rather than ways to rewrite it without floating point etc...)
13:02:16 <mxyz> fracture: looks good
13:02:58 <fracture> or tangentially related:  is there a function that returns all pairwise adjacent elements from a list?
13:03:08 <fracture> (I could make it a little cleaner with one of those...)
13:03:22 <ddarius> fracture: Use SDL_gfx (or whatever)
13:03:29 <mauke> > ap zip tail [0 ..]
13:03:30 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,1...
13:03:59 <fracture> mauke: thanks
13:04:02 <fracture> ddarius: what's that
13:04:13 * fracture googles. ;)
13:06:11 <fracture> ddarius: it doesn't seem to be remotely complete (just grabbed it from hackage)
13:06:30 <fracture> I've never used the C version, but presuming it provides line drawing routines, the haskell wrapper doesn't seem to have it
13:06:38 <ddarius> fracture: It would be easy to complete it and either send in a patch or upload a new package.
13:08:02 <luite> I have finite list of [Set a] and want to get a list of the same type, with arbitrary unions of the sets, any suggestions how to approach this?
13:08:35 <ddarius> luite: I don't understand what you mean by "arbitrary unions"
13:09:01 <BMeph> luite: subsequences. :)
13:09:18 <BMeph> > subsequences [0..3]
13:09:19 <lambdabot>   [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[2,3],[0,...
13:09:39 <BMeph> luite: Is that what you meant, though? :)
13:09:47 <luite> BMeph: the elements will not be unique though
13:10:34 <luite> ddarius: suppose the list is [a,b,c], the new list would contain [a,b,c, a `union` b, a `union` c, b `union` c, a `union` b `union` c]
13:10:49 <luite> but no duplicate elements
13:11:26 <luite> that's why I think that an approach with subsequences is not ideal :)
13:12:21 <fracture> luite: basically you want the power set?
13:12:26 <ddarius> No duplicates is going to be hard to enforce efficiently as set equality ain't cheap.
13:12:57 <ddarius> map unions . powerList would do it except for it would avoid duplicates
13:13:25 <fracture> @hoogle powerList
13:13:26 <lambdabot> No results found
13:13:49 <luite> yes nub.map unions.subsequences would guive the required answer, in a horribly inefficient way :p
13:14:19 <ddarius> > let powerList [] = [[]]; powerList (x:xs) = powerList xs ++ map (x:) (powerList xs) in powerList [a,b,c]
13:14:20 <lambdabot>   [[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]]
13:14:45 <luite> not the filterM (const [True,False]) one? :)
13:15:00 <ddarius> > filterM (const [True,False]) [a,b,c]
13:15:01 <lambdabot>   [[a,b,c],[a,b],[a,c],[a],[b,c],[b],[c],[]]
13:15:13 <ddarius> > filterM (const [False, True]) [a,b,c]
13:15:14 <lambdabot>   [[],[c],[b],[b,c],[a],[a,c],[a,b],[a,b,c]]
13:15:58 <ddarius> Actually if order isn't too important...
13:16:31 <Lemmih> > subsequences [a,b,c]
13:16:33 <lambdabot>   [[],[a],[b],[a,b],[c],[a,c],[b,c],[a,b,c]]
13:17:05 <ddarius> > let powerList [] = [[]]; powerList (x:xs) = xs' /\/ map (x:) xs' where xs' = powerList xs; [] /\/ ys = ys; xs /\/ [] = xs; (x:xs) /\/ ys = x:(ys/\/xs) in powerList [a,b,c]
13:17:07 <lambdabot>   [[],[a],[b],[a,b],[c],[a,c],[b,c],[a,b,c]]
13:26:02 <BMeph> Why not 'map unions . nub. ...' instead?
13:26:50 <luite> because that wouldn't necessarily give unique elements, {1,3}u{2,3} = {1,2,3}
13:27:12 <BMeph> Oh, wait; the list contains sets, which overlap. Yeah, that is a toughie... :\
13:27:26 <Cale> > let powerList [] = [[]]; powerList (x:xs) = xs' /\/ map (x:) xs' where xs' = powerList xs; xs /\/ ys = concat . transpose $ [xs,ys] in  powerList [a,b,c]
13:27:27 <lambdabot>   [[],[a],[b],[a,b],[c],[a,c],[b,c],[a,b,c]]
13:28:14 <BMeph> > let powerList [] = [[]]; powerList (x:xs) = xs' /\/ map (x:) xs' where xs' = powerList xs; xs /\/ ys = concat . transpose $ [xs,ys] in powerList [[a,b],[a,c],[d]]
13:28:16 <lambdabot>   [[],[[a,b]],[[a,c]],[[a,b],[a,c]],[[d]],[[a,b],[d]],[[a,c],[d]],[[a,b],[a,c...
13:32:17 <evolio_> hi guys
13:32:56 <evolio_> i need to take a list of numbers and add up the ones that are between 3 and 7
13:34:34 <fracture> > sum $ filter (\x -> x > 3 && x < 7) [1,3,1,5,6,4,5,3,32,1,2,32,45,5]
13:34:36 <lambdabot>   25
13:34:50 <evolio_> wow :)
13:36:26 <Lemmih> > sum [ x | x <- [1,3,1,5,6,4,5,3,32,1,2,32,45,5], x > 3, x < 7 ]
13:36:27 <lambdabot>   25
13:36:50 <ddarius> @pl \x -> x > 3 && x < 7
13:36:51 <lambdabot> liftM2 (&&) (> 3) (< 7)
13:37:56 <ddarius> > [ x | x | False <- [1,2]]
13:37:58 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
13:37:59 <lambdabot>         against inferred type ...
13:38:00 <evolio_> how would i write this as a function
13:38:09 <gnut> hi all
13:39:20 <gnut> I successfully compiled ghc HEAD branch (on a solaris x86 machine). and I used --enable-shared
13:39:28 <gnut> am I supposed to see a bunch of .so files?
13:39:40 <gnut> in the lib/ghc-6.13.xxxxx directory?
13:39:48 <gnut> because I only see the archives (.a)
13:40:23 <Gracenotes> evolio_: well, you could do sum37 list = ... the expression there, just replacing the list literal with the variable name
13:41:25 <hotaru2k3> > sum $ filter (inRange (3,7)) [1..20]
13:41:29 <lambdabot>   25
13:41:53 <Lemmih> hotaru2k3: Ha, nice.
13:42:38 <evolio_> what does the $ sign? I'm just working through a book and i don't understand what that means yet
13:43:15 <dons> ?src ($)
13:43:15 <lambdabot> f $ x = f x
13:43:28 <Gracenotes> it separates expressions so you don't have to use as many parentheses. essentially syntax sugar (non-built-in).
13:47:01 <hotaru2k3> > let sum37 = sum . filter (inRange (3, 7)) in sum37 [1..20]
13:47:03 <lambdabot>   25
13:47:08 <evolio_> Gracenotes, can I PM?
13:48:00 <evolio_> how would i define this using sum37 :: [Int] -> Int though
13:49:08 <dibblego> sum37 = sum . filter (inRange (3, 7))
13:49:19 <evolio_> right
13:49:23 <Lemmih> evolio_: Sounds a lot like homework.
13:49:41 <evolio_> it is :) but i'm just stuck with this problem, it's just revision for an exam
13:50:04 <ddarius> Lemmih: He allegedly has a test tomorrow and is trying to learn all of Haskell today.
13:50:09 <evolio_> hah
13:50:34 <evolio_> I don't need to learn all of it. Lists, functions and recursions
13:50:41 <evolio_> are the main things
13:51:12 <evolio_> I'm just blitzing as many problems as I can, learning a bit each time :)
13:51:45 <evolio_> it's an open book exam too. maybe i'll write an irc haskell client ;)
13:52:13 <evolio_> first.hs:2:22: Not in scope: `inRange'
13:52:29 <Niccus> need Data.Ix
13:52:36 <evolio_> ok
13:53:46 <Twey> 05:42:33 < Gracenotes> it separates expressions so you don't have to use as many parentheses. essentially syntax sugar (non-built-in).
13:53:56 <Twey> Gracenotes: map ($ foo) fs
13:54:24 <Gracenotes> I don't see it separating anything there :) so my description doesn't apply
13:54:52 <ddarius> map (`id` foo) fs-
13:54:54 <Gracenotes> though, it does apply to the expression asked about
13:59:17 <evolio_> how would you double each item in a list
14:00:00 <fracture> evolio_: learn map
14:00:05 <kmc> > map (*2) [3,5,7]
14:00:07 <lambdabot>   [6,10,14]
14:00:35 <evolio_> very nice function
14:00:42 <kmc> :t map
14:00:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:00:52 <evolio_> :)
14:00:55 <evolio_> this language is really cool
14:00:59 <kmc> yeah
14:01:42 <pastah_rhymez> evolio_: try out filter too
14:01:45 <pastah_rhymez> :t filter
14:01:46 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:02:03 <kmc> > fix $ (0:) . scanl (+) 1  -- infinite list of all fibonacci numbers
14:02:04 <pastah_rhymez> > filter odd [1..10]
14:02:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:02:05 <lambdabot>   [1,3,5,7,9]
14:02:18 <kmc> evolio_, there is also the list comprehension syntax
14:02:26 <pastah_rhymez> kmc: gaddamit, you're using fix
14:02:29 <pastah_rhymez> i hate that
14:02:36 <kmc> > [ x^2 + 3 | x <- [1..10] ]
14:02:37 <lambdabot>   [4,7,12,19,28,39,52,67,84,103]
14:02:37 <pastah_rhymez> mostly because it's all brainfuck to me
14:02:43 <kmc> @src fix
14:02:43 <lambdabot> fix f = let x = f x in x
14:02:52 <kmc> pastah_rhymez, i didn't invent that fib generator though :/
14:02:55 <kmc> saw it here yesterday maybe
14:03:07 <pastah_rhymez> how that even can do anything is beyond me
14:03:45 <mauke> pastah_rhymez: well, it's easy if f = const
14:03:52 <mauke> er
14:03:52 <evolio_> kmc, i'll get to that soon
14:03:56 <mauke> const 42
14:04:00 <pastah_rhymez> @type fix const
14:04:01 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
14:04:01 <lambdabot>     Probable cause: `const' is applied to too few arguments
14:04:01 <lambdabot>     In the first argument of `fix', namely `const'
14:04:07 <evolio_> next on my list, just gonna hack the next part of this question together and see if it works
14:04:09 <mauke> @type fix (const 42)
14:04:10 <lambdabot> forall a. (Num a) => a
14:04:13 <pastah_rhymez> mauke: real easy...
14:04:28 <pastah_rhymez> > fix (const 42)
14:04:29 <lambdabot>   42
14:04:29 <mauke> pastah_rhymez: (const 42) ignores its argument and returns 42
14:04:43 <pastah_rhymez> @src fix
14:04:43 <lambdabot> fix f = let x = f x in x
14:04:49 <ski> @type fix . const
14:04:50 <lambdabot> forall a. a -> a
14:04:59 <kmc> > let x = ((0:) . scanl (+) 1) x in x   -- unwrapping the defn
14:05:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:05:04 <ski> @type fix . (:)
14:05:05 <lambdabot> forall a. a -> [a]
14:05:27 <evolio_> > :t product
14:05:28 <lambdabot>   <no location info>: parse error on input `:'
14:05:31 <evolio_> lol
14:05:37 <kmc> > let x = (\y -> (0:) $ scanl (+) 1 y) x in x    -- eta conversion, introduce an explicit arg
14:05:38 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:05:39 <pastah_rhymez> mauke: i need to evaluate this by hand to get it, i think
14:05:46 <evolio_> >:t product
14:05:49 <mauke> pastah_rhymez: go ahead :-)
14:05:57 <kmc> > let x = (0:) $ scanl (+) 1 x in x    -- beta-reduce
14:05:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:06:06 <pastah_rhymez> mauke: later, busy with State atm. :p
14:06:24 <mauke> :t product
14:06:25 <lambdabot> forall a. (Num a) => [a] -> a
14:12:15 <hotaru20> > let loeb = fix (fmap . flip id =<<) in loeb [(-1+).(!!1), const 1, (1+).(!!1)]
14:12:16 <lambdabot>   [0,1,2]
14:12:34 <mxyz> has anyone used the unix tool "autoreconf" on windows?
14:16:09 <evolio_> http://pastebin.com/m56977842
14:16:15 <evolio_> what am i doing wrong on the last line
14:16:31 <evolio_> i'm attempting to take the numbers between 3 -7 in a list, add one to them and multiply them all together
14:16:32 <kmc> what erro do you get?
14:16:43 <evolio_> Couldn't match expected type `[Int]'
14:16:43 <evolio_>            against inferred type `[Int] -> [Int]'
14:16:58 <kmc> do you want multiply . add1 . filter37 ?
14:17:13 <evolio_> oh
14:17:15 <kmc> right now you're trying to apply (add1 filter37), which doesn't work
14:18:03 <kmc> @src product
14:18:04 <lambdabot> product = foldl (*) 1
14:18:08 <evolio_> kmc, of course
14:18:21 <kmc> hmm foldl not foldl' or foldr?
14:18:30 <evolio_> my php-wired brain loves the ( ) for no reason
14:18:34 <kmc> > product [a,b,c,d]
14:18:35 <lambdabot>   1 * a * b * c * d
14:18:44 <pastah_rhymez> could someone help me? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13731#a13731
14:18:52 <pastah_rhymez> i don't like nested ifs
14:19:04 <kmc> pastah_rhymez, what are those guards supposed to be guarding?
14:19:17 <pastah_rhymez> well, mah buulz
14:19:45 <pastah_rhymez> i know i once managed to get guards working somehow insida a do-block
14:19:46 <kmc> case () of _ | done -> ...; _ | stepAgain -> ...; _ -> ...
14:20:12 <ski> > let loeb = fix (fmap . flip id =<<) in loeb [sum . tail,(-1+).(!!1), const 1, (1+).(!!1)]
14:20:15 <lambdabot>   [* Exception: stack overflow
14:20:21 <kmc> case (done, stepAgain) of (True, _) -> ...; (False, True) -> ...; _ -> ...
14:20:26 <ski> hrm
14:20:35 <ski> > let loeb = fix (fmap . flip id =<<) in loeb [sum . tail,(-1+).(!!2), const 1, (1+).(!!1)]
14:20:37 <lambdabot>   [2,0,1,1]
14:20:39 <pastah_rhymez> kmc: AMAGAD IT LOADS!
14:21:08 <pastah_rhymez> kmc: thank you, you're awesome :)
14:21:14 <kmc> thanks
14:22:23 <pastah_rhymez> why isn't there support for guards inside do-notations?
14:22:37 <pastah_rhymez> except with this little hack
14:23:03 <ski> because a `do'-sequence is a sequence ? (no branching)
14:23:11 <kmc> a guard traditionally attaches to a pattern match
14:23:14 <pastah_rhymez> ski: ifs?
14:23:32 <ski> there is no special support for `if' in a `do'-sequence
14:23:34 <kmc> if you just want a multi-way if, the cond hack is as close as you can get, i think
14:23:43 <kmc> pastah_rhymez, there is also:
14:23:44 <kmc> :t guard
14:23:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:23:55 <pastah_rhymez> kmc: not exactly monadplus here
14:24:20 <ski> (but since a command in a `do'-sequence can be an expression, that expression can be an `if'-`then'-`else'-expression, sure)
14:24:27 <pastah_rhymez> kmc: State GameState a
14:24:37 <kmc> fair enough
14:26:02 <mxyz> anyone use mingw?
14:26:13 <copumpkin> lots of people, I'm sure
14:26:56 <mxyz> is there a "autoreconf" for mingw?
14:27:17 <mxyz> im trying to build gtk2hs from source
14:27:24 <luite> there is one for msys
14:30:05 <mxyz> its part of msys i guess. damn, i installed mingw yesterdya and didnt realize msys was a separate download.
14:31:17 <luite> you may need to upgrade those autotools packages manually
14:32:58 <mxyz> i just installed msys and it says "Oh joy, you do not have c:/mingw/bin/make.exe. Keep it that way." :)
14:33:52 <luite> I'd install mingw in a different dir if possible
14:34:24 <luite> ghc bundles its own mingw gcc, and I think it has some hardcoded paths
14:34:57 <mxyz> i already have mingw installed in "c:\mingw"
14:35:13 <luite> which version?
14:35:23 <mxyz> 5.1.6
14:35:31 <luite> which gcc version? :p
14:35:39 <mxyz> ok i installed msys and still no autoconf or autoreconf
14:36:02 <mxyz> "gcc (GCC) 3.4.5 (mingw-vista special r3)"
14:36:15 <|Jedai|> mxyz: There are a lot of additional packages on the sourceforge page of MSys
14:36:34 <luite> and there doesn't seem to be a package manager....
14:36:35 <|Jedai|> and you seem to have an old version of Mingw
14:36:56 <luite> 3.4.5 is the 'correct' gcc version, at least it's the same as the one that comes with ghc
14:36:58 <|Jedai|> luite: Nope, no package manager, welcome to my world !
14:37:38 <mxyz> jedai: i see "mingw autoconf" and "msys autoconf" downloads. no autoreconf
14:38:01 <|Jedai|> luite: well I'm mostly on Linux nowadays but I still had to use Mingw/Msys too much for my taste in the past
14:38:28 <mxyz> omg, tell me i have to install cygwin...
14:38:33 <|Jedai|> mxyz: there's an autotools I think, and autoreconf is in there
14:39:07 <mxyz> there's autogen and automake?
14:39:38 <mxyz> http://sourceforge.net/projects/mingw/files/
14:42:12 <|Jedai|> mxyz: it's in there somewhere (might even be with autoconf), probably ?
14:42:41 <mxyz> jedai: ill try it out. do i install the mingw or msys version or both?
14:43:15 <|Jedai|> I think only one is necessary, I would suggest the msys one now that you have it installed
14:45:47 <|Jedai|> mxyz: you should install autogen, automake, autoconf and libtools and m4
14:46:07 <mxyz> jedai: sweet. msys autoconf did have autoreconf
14:46:29 <|Jedai|> with that you should have everything necessary (and a bit more probably)
14:46:38 <mxyz> you are probably going to laugh, but im new to this, and these files dont have file extensions. how do i run them?
14:46:57 <luite> run the msys bash shell
14:47:08 <|Jedai|> mxyz: You use the msys terminal
14:47:21 <mxyz> when i unpacked the files did i have to move them to c:\minsys\bin ?
14:47:56 <|Jedai|> mxyz: you should always unpack those in the root directory of msys
14:48:24 <|Jedai|> So C:\minsys for you, probably
14:49:04 <mxyz> c:\minsys\1.0\ but yea. done.
14:51:40 <mxyz> jedai: can i cd in the bash shell?
14:52:07 <luite> your c drive is /c/
14:52:33 <mxyz> bash-3.1$ cd /c/gtk2hs
14:52:33 <mxyz> bash-3.1$
14:52:34 <copumpkin> IntMap.lookup's arguments are in an awkward order
14:53:37 <|Jedai|> mxyz: you can
14:54:24 <|Jedai|> mxyz: Do you have any experience of the Unix terminal ?
14:54:43 <mxyz> i used ubuntu for 6 months and was good with it
14:55:05 <|Jedai|> mxyz: Ok, good. I do believe you can use "cd c:/gtk2hs"
14:55:20 <|Jedai|> though /c/ should work too
14:55:25 <mxyz> bash-3.1$ cd c:/gtk2hs
14:55:25 <mxyz> bash-3.1$
14:55:37 <|Jedai|> ok, and when you do an ls
14:55:38 <mxyz> should it be giving some indication that its "in" that folder?
14:55:45 <luite> pwd
14:55:47 <luite> :)
14:55:52 <|Jedai|> depends on how the print is configured
14:55:53 <mxyz> OHHH
14:55:54 <luite> you can modify the prompt to show
14:56:01 <|Jedai|> s/print/prompt
14:56:03 <mxyz> :-/
14:56:11 <mxyz> nothing to see here
14:56:53 <|Jedai|> maybe start by going to /c and do a ls there
14:56:56 <mxyz> you guys are awesome thanks.
14:57:11 <mxyz> no it worked. it justed didnt print the directory so i thought it wasnt working
14:57:29 <kmc> windows is a world of pain
14:57:50 <|Jedai|> Ok, good luck ! (you're attempting to compile Gtk2Hs under Windows ? You're a courageous man !)
14:58:08 <luite> hehe
14:58:17 <mxyz> *someone* has to fix the installer for everyone else
14:58:30 <luite> I succeeded once in doing that, there should still be some guide somewhere on hpaste
14:58:38 <|Jedai|> True :)
14:59:01 <mxyz> the installer script is littered with "6.10.1". i think just changing that one thing will get it to work. the installer fails for me on xp.
14:59:08 <|Jedai|> I think I did it too, a year or two ago
14:59:36 <luite> mxyz: this may help a little: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=10033
15:00:19 <luite> mxyz: but I was told that it can be done easier if you grab the binary dependencies package from the gtk2hs sourceforge site
15:00:26 <luite> instead of collecting/building them yourself
15:00:42 <mxyz> luite: wow thanks. if you did this already, can i just have your installer?
15:01:30 <luite> hmm, I'm not sure if I still have it, I reinstalled windows a few weeks ago
15:01:55 <mxyz> ok. ill just continue along. that page will be very helpful.
15:02:53 <luite> I used c:/mingw as my mingw install path there, I later learned that this might cause problems
15:03:37 <mxyz> luite: did you finally get Gtk2hs working though?
15:03:59 <luite> yes, although I vaguely remember that there still was something wrong with the installer
15:04:04 <luite> not sure exactly what it was though
15:04:34 <mxyz> alright well im going to bed. thanks for everyones help
15:20:09 <Jonno_FTW> salutations
15:20:54 <ski> greetings
15:22:23 <Jonno_FTW> is this a good place for help?
15:22:51 <Heffalump> with Haskell, yes
15:22:52 <Lemmih> Jonno_FTW: Yes, we're even better than the help line.
15:22:54 <medfly> sure
15:22:54 <Heffalump> not with Java :-)
15:23:02 <Jonno_FTW> even better than stackoverflow?
15:23:08 <medfly> this channel helped me with C when ##c didn't!
15:23:15 <Jonno_FTW> wow
15:23:18 <medfly> :)
15:23:19 <ski> Jonno_FTW : let's hear your question/problem
15:23:35 <cnwdup> Jonno_FTW, still this is the friendliest and most competent channel I know.
15:23:38 <Jonno_FTW> would you rather me explain or give you a link to SO?
15:23:48 <Heffalump> a link is fine with me
15:24:04 * ski wonders how a link to Jonno_FTW's Significant Other would help ..
15:24:10 <Jonno_FTW> http://stackoverflow.com/questions/1855561/implementing-a-factorisation-method-in-haskell
15:24:34 <Jonno_FTW> i can't figure out how to find all the iterations of the snd in a list of tuple
15:26:06 <Jonno_FTW> to give a list of tuples
15:26:16 <Heffalump> do you really mean 'iterations'?
15:26:26 <Jonno_FTW> not really
15:26:36 <Jonno_FTW> permutations
15:27:08 <|Jedai|> Jonno_FTW: you don't need permutations, only the power matter, multiplication is commutative
15:27:28 <Jonno_FTW> ok
15:27:32 <|Jedai|> so sequence will be necessary here
15:28:02 <Jonno_FTW> hmm
15:28:22 <|Jedai|> sequence . map (\(x,y) -> map ((,) x) [0..y]) . primesFactors
15:28:31 <|Jedai|> Jonno_FTW: should do it
15:28:50 <ski> i'm thinking `floor' or `ceiling' would be more appropriate than `round'
15:29:17 <gnut> does the shared object feature of ghc only work on linux?
15:29:24 <Jonno_FTW> why?
15:29:31 <ivanm> gnut: windows as well IIRC
15:29:50 <|Jedai|> it may be better to do : map product . sequence . map (\(x,y) -> map (x^) [0..y]) . primesFactors
15:29:53 <gnut> ivanm: okay. that, too. but on other architectures?
15:29:53 <Jonno_FTW> well it got angry when i used a floating point in takeWhile (<= sqrt n)
15:29:55 <ski> i don't see why you'd sometimes want to round up and sometimes round down
15:30:05 <ski> @type round
15:30:06 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:30:07 <ivanm> gnut: you asked about an OS, not an architecture ;-)
15:30:09 <ski> @type floor
15:30:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:30:12 <ski> @type ceiling
15:30:14 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:30:14 <|Jedai|> Jonno_FTW: I don't see why you need to use Floating at all in there
15:30:20 <gnut> ivanm: hehe.. touche.. you're right :)
15:30:27 <ivanm> gnut: AFAIK, it only works on linux and windows yet, not OSX (don't know about other *nixes)
15:30:30 <gnut> ivanm: I guess, not on solaris x86?
15:30:35 <ivanm> gnut: but AFAIK, its independent of architecture
15:30:51 <ski> but, as |Jedai| is probably implying, one could square one side and compare, instead of take square root of the other side, and compare
15:30:55 <gnut> I just got ghc-HEAD to compile on solaris x86 with --enable-shared, but there were no .so files anywhere
15:31:07 <ski> (i'm not sure which would be best)
15:31:23 <|Jedai|> >  map product . sequence . map (\(x,y) -> map (x^) [0..y]) $ [(2,2),(7,2)]
15:31:25 <lambdabot>   [1,7,49,2,14,98,4,28,196]
15:31:30 <Jonno_FTW> thanks
15:32:37 <Jonno_FTW> WHAT
15:32:43 <Jonno_FTW> i entered the solution
15:32:51 <Jonno_FTW> and Porject euler says it was wrong
15:33:04 <copumpkin> hah
15:33:08 <ski> maybe you want to remove the `196', factor, there ?
15:33:12 <Jonno_FTW> i think i nkow why
15:33:19 <Jonno_FTW> i need to sort the list of factors
15:34:11 * ski thinks one possibly could generate a sorted list without invoking the `sort' sledge-hammer
15:34:12 <|Jedai|> Jonno_FTW: well obviously... if you want to do a takeWhile after that
15:34:50 <copumpkin> that looks like a cute problem
15:35:00 <hello> hi everyone
15:35:05 <|Jedai|> ski: probably, you could manage to generate the factors in the right order but I'm not sure it's worth it
15:35:13 <hello> whose good at programming here. like used visual basic
15:36:18 <hello> if u r add my email free20ride@hotmail.com and let me nkow
15:37:01 <copumpkin> lol
15:37:22 <PhilRod> project euler is fun, but can anyone suggest some (not too hard!) problems that exercise haskell a little more? Or at least, a little more explicitly?
15:37:40 <copumpkin> there's a series of type exercise with funny names
15:41:25 * bos is somewhat unhappy with Data.Text
15:41:48 <fracture> what's an ! in a data constructor declaration do?
15:42:05 <PhilRod> copumpkin: er, do you know what the funny names are?
15:42:05 <fracture> (hard to google for)
15:42:11 <Raevel> fracture: strictness declaration
15:42:15 <copumpkin> bos: how come?
15:42:16 <|Jedai|> fracture: strict field
15:42:20 <copumpkin> PhilRod: trying to think
15:42:25 <fracture> ah
15:42:44 <bos> copumpkin: it's not as close to bytestring performance as i'd like
15:42:47 <copumpkin> PhilRod: http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
15:42:59 <copumpkin> bos: :/
15:43:13 <copumpkin> bos: any particular culprits slowing it down, or is it just in general?
15:43:28 <bos> copumpkin: the real culprit is the variable-length encoding
15:43:39 <copumpkin> ah :(
15:43:54 <dons> bos: the performance question keeps me up at night. at least, i dreamt once about it.
15:44:01 <bos> copumpkin: for small strings, it's kind of a wash, i think
15:44:12 <dons> sometimes i have haskell fever dreams, though. so it might not just be Data.Text
15:44:21 <bos> dons: yeah, no kidding.
15:44:43 <bos> so out of 45 benchmarks, strict text is >= 10x slower than bytestring on 15.
15:44:57 <bos> and lazy is >= 10x slower on 27.
15:45:04 <dons> hmm
15:45:20 <dons> with 6.12 and the magic inliner?
15:45:35 <PhilRod> copumpkin: thanks! that looks good
15:45:35 <bos> they're within a factor of <= 3 on 14 and 10, respectively.
15:45:47 <dons> "factor of <= 3" sound great.
15:46:27 <bos> dons: 6.10.4 has 14 and 10 within <= 3, HEAD has 23 and 19
15:47:05 <bos> dons: and 6.10.4 has 15 and 27 >= 10, while HEAD has 13 and 16
15:47:35 <bos> so HEAD is *far* better than 6.10, essentially for free.
15:47:38 <kmc> PhilRod, write a scheme interpreter
15:47:51 <copumpkin> bos: that's encouraging, at least!
15:47:56 <PhilRod> kmc: /= "not too hard", surely?
15:47:56 <kmc> @google haskell write yourself a scheme
15:47:58 <lambdabot> http://jonathan.tang.name/files/scheme_in_48/tutorial/overview.html
15:47:58 <lambdabot> Title: Write Yourself a Scheme in 48 hours
15:48:06 <bos> but we have plenty of cases where bytestring is 10,000 to 1,000,000 times faster than text
15:48:13 <bos> simply due to the fixed-width encoding
15:48:45 <|Jedai|> bos: Couldn't text propose a fixed-width encoding too ?
15:48:48 <kmc> PhilRod, relative terms... but checkout the website, you may be surprised how easy it is
15:49:02 <bos> |Jedai|: yes, but it would be a *lot* of work to switch over.
15:49:10 <copumpkin> I guess you could have Text.SuperfastButWasteful that uses UCS4
15:49:21 <PhilRod> kmc: hm, that does look interesting. Thanks!
15:49:29 <Jonno_FTW> wow, so i ran that program and it sucked up my RAM and now I don't have the answer
15:49:40 <Jonno_FTW> :(
15:49:52 <copumpkin> aw
15:50:17 <bos> i'm not ready to call the current implementation of Data.Text a failure, but it ain't far off in my mind.
15:50:34 <fracture> @hoogle cos
15:50:35 <lambdabot> Prelude cos :: Floating a => a -> a
15:50:35 <lambdabot> Prelude cosh :: Floating a => a -> a
15:50:35 <lambdabot> Prelude acos :: Floating a => a -> a
15:50:36 <copumpkin> well, encoding-awareness is bound to slow things down a bit
15:50:48 <bos> copumpkin: sure.
15:50:51 <copumpkin> the 10,000 and 1,000,000 factors sound like pathological cases? or are they common?
15:51:02 <bos> copumpkin: those are for things like "take"
15:51:20 <copumpkin> well, take in bytestring is effectively constant-time
15:51:22 <bos> copumpkin: because bytestring take simply adjusts a pointer and a length, while text take has to actually scan.
15:51:24 <ski> bos : hm, why would fixed-width be that much faster .. people are not indexing into bytestrings, are they ?
15:51:56 <bos> i think it would be useful to do a survey of how people actually use the list and bytestring APIs for text manipulation.
15:52:12 <fracture> @hoogle fst
15:52:13 <lambdabot> Prelude fst :: (a, b) -> a
15:52:13 <lambdabot> Data.Tuple fst :: (a, b) -> a
15:52:13 <lambdabot> Control.Parallel.Strategies fstPairFstList :: NFData a => Strategy [(a, b)]
15:52:14 <bos> it could be that i've optimised the right stuff, and the slow cases simply don't matter.
15:52:37 <pastah_rhymez> @src (>>)
15:52:37 <lambdabot> m >> k      = m >>= \_ -> k
15:52:46 <bos> i know i've optimised the hell out of a few key functions, such as "find substring", which are ubiquitous in practice.
15:52:50 <pastah_rhymez> @type const . (>>)
15:52:51 <lambdabot> forall b (m :: * -> *) a b1. (Monad m) => m a -> b -> m b1 -> m b1
15:53:00 <pastah_rhymez> @type const (>>)
15:53:00 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => b1 -> m a -> m b -> m b
15:53:02 <copumpkin> bos: seems like the most common case would be parsers built on top of text, but they don't really exist yet
15:53:13 <dons> i'm enjoying this guys haskell tweets. http://twitter.com/akiradeveloper/statuses/6424628392
15:53:17 <kmc> copumpkin, lmfao @ intermediate haskell exercises
15:53:23 <kmc> that's devious ;)
15:53:29 <dons> http://twitter.com/akiradeveloper/statuses/6424660676
15:53:31 <copumpkin> kmc: thank dibblego :)
15:54:16 <copumpkin> djinn-like exercises can be kind of fun
15:54:25 <bos> copumpkin: true
15:54:39 <kmc> they are seriously good exercises too
15:54:53 <copumpkin> bos: not really sure what kinds of operations a parser would need, but most likely they'd just chomp characters off the front and move along?
15:54:56 <kmc> "We, Haskell programmers, never stop writing Haskell code!"
15:55:05 <evolio_> i want to use list comprension to filter all numbers greater than 5 out of a list
15:55:06 <bos> copumpkin: or match an exact string.
15:55:18 <kmc> > [ x | x <- [1..10], x <= 5 ]
15:55:19 <|Jedai|> evolio_: why list comprehension ?
15:55:19 <lambdabot>   [1,2,3,4,5]
15:55:20 <evolio_> why is filter5 x = [ x | x |  x > 5 ] invalid
15:55:27 <bos> copumpkin: fortunately, the text API has a "match exact string then return remainder" function for just this purpose.
15:55:28 <kmc> > filter (<= 5) [1..10]
15:55:30 <lambdabot>   [1,2,3,4,5]
15:55:32 <copumpkin> evolio_: you have it backwards
15:55:36 <copumpkin> bos: aha, great
15:55:42 <bos> i need to port attoparsec to text, and see how it goes
15:55:54 <kmc> evolio_, [ thing to generate | x <- where to get it, a condition on x, y <- where to get something else ]
15:55:58 <bos> but then i need a non-trivial parser, too.
15:56:14 <kmc> | reads as "such that"
15:56:23 <kmc> "x such that x is from [1..10], and x <= 5"
15:56:28 <bos> not to mention simple things like a parser for a double precision floating point number.
15:56:49 <copumpkin> supporting fullwidth digits from japanese! :P ５６．３
15:56:50 <bos> bytestring has one, but it uses alex i believe.
15:56:52 <copumpkin> :P
15:57:18 <dons> yeah, i added some tweaks to alex to lex from bytestrings.
15:57:20 <kmc> the use of multiple "|" is a GHC extension to run two generators in "parallel".  it's probably not what you want
15:57:29 <copumpkin> 一三．五
15:57:40 <|Jedai|> Jonno_FTW: 2^42 factors may be a bit much...
15:57:58 <copumpkin> I thought it was just the product of the first 190 primes
15:58:01 <|Jedai|> Jonno_FTW: or rather 2^41 I guess
15:58:04 <evolio_> kmc, i understand, but i'm defining a function filter5
15:58:08 <evolio_> sorry
15:58:10 <evolio_> basic error again
15:58:25 <kmc> filter5 xs = [ x | x <- xs, x <= 5 ]
15:58:28 <kmc> that's pretty bad style imo
15:58:32 <kmc> because it's easier to say:
15:58:38 <kmc> filter5 = filter (<= 5)
15:58:39 <|Jedai|> copumpkin: Wait, the first 190 primes ? I thought it was primes below 190, that's even worse !!
15:58:48 <copumpkin> oh maybe I misrememebered :)
15:58:51 <evolio_> ok
15:58:54 <kmc> you don't need to name x *or* xs
15:59:06 <kmc> and, i think "filter (<= 5)" is more descriptive than the name.  so i probably wouldn't name it at all
15:59:07 <evolio_> yeah i know but filter is a higher-level function, correct?
15:59:09 <|Jedai|> copumpkin: the product of n primes have 2^n factors, so brute force approach is ___bad___
15:59:14 <kmc> filter is a higher-order function
15:59:23 <copumpkin> hmm
15:59:24 <kmc> meaning it takes a function as an argument
15:59:28 <kmc> it's lower-level in that list comprehension is defined in terms of filter
15:59:30 <copumpkin> |Jedai|: divisors?
15:59:32 <|Jedai|> copumpkin: ok, you misremembered, still not a good idea
15:59:40 <kmc> @undo [ x | x <- xs, x <= 5 ] -- this work?
15:59:41 <lambdabot> concatMap (\ x -> if x <= 5 then [x] else []) xs
15:59:45 <kmc> hrm not really
15:59:46 <|Jedai|> copumpkin: divisors right,
15:59:49 <evolio_> yeah, i'm meant to start with list comphrension, then recursion then higher-order functions to filter numbers greater than 5 out
15:59:49 <copumpkin> aha :)
15:59:54 <kmc> ah, cool
15:59:59 <copumpkin> cause product of n primes has n factors :P
16:00:03 <kmc> @src filter
16:00:04 <lambdabot> filter _ []     = []
16:00:04 <lambdabot> filter p (x:xs)
16:00:04 <lambdabot>     | p x       = x : filter p xs
16:00:04 <lambdabot>     | otherwise = filter p xs
16:00:08 <evolio_> right
16:00:14 <kmc> ^^^^ your recursion will look like that most likely
16:00:16 <evolio_> so xs is the 'end' of the list,correct?
16:00:20 <kmc> where?
16:00:21 <|Jedai|> copumpkin: it has n prime factors
16:00:22 <kmc> in (x:xs) ?
16:00:27 <copumpkin> you need a zygohistomorphic prepromorphism
16:00:30 <evolio_> no in x <- xs
16:00:38 <kmc> that doesn't define xs
16:00:38 <ski> `xs' there is the whole input list
16:00:42 <evolio_> oh
16:00:44 <evolio_> gotcha
16:00:45 <kmc> xs is defined on the left hand side of your equation
16:00:52 <kmc> "x <- xs" says "choose some x from xs"
16:00:53 <bos> heh. if a text function is > 100x slower than a bytestring function, it is very likely to be > 10000x slower.
16:00:57 <evolio_> yep gotcha
16:01:00 * ski would say s/defined/bound/
16:01:06 <evolio_> thanks :)
16:01:08 <kmc> :)
16:01:09 <|Jedai|> copumpkin: factor == divisor
16:01:20 <|Jedai|> copumpkin: at least by one definition of factor
16:01:27 <copumpkin> |Jedai|: I always thought factors were assumed to be prime and divisors were anything that divided a number
16:01:30 <copumpkin> but wikipedia does not back me up
16:01:33 <copumpkin> so I must be wrong :)
16:01:47 <Jonno_FTW> ok, that program took 1.6GB of RAM before crashing
16:02:01 <Jonno_FTW> where did i go wrong?
16:02:13 <Jonno_FTW> psr n = last $ takeWhile (< rSq n) $  factors n
16:02:16 <kmc> so "misty" is the new "warm fuzzy thing"
16:02:18 <Jonno_FTW> p = foldl' (*) 1 $ takeWhile (< 190) primes
16:02:24 <|Jedai|> copumpkin: no, and neither does my experience elsewhere (after all why would we talk about "prime factors" if factor implied primes)
16:02:25 <Jonno_FTW> answer = (psr p) `mod` (10^16)
16:02:38 <copumpkin> bos: couldn't a take function get away with only reading every other byte?
16:02:40 <evolio_> kmc, i get a fp/second.hs:2:21: Not in scope: `xs' error
16:02:45 <copumpkin> |Jedai|: fair enough
16:02:49 <|Jedai|> Jonno_FTW: 2^41 factors to sift through I said
16:02:51 <kmc> evolio_, can you hpaste your code?
16:03:05 <evolio_> filter3 :: [Int] -> [Int]
16:03:05 <evolio_> filter3 = [ x | x <- xs , x <= 3 ]
16:03:12 <bos> copumpkin: maybe, but it probably wouldn't be faster.
16:03:17 <ski> @hpaste
16:03:18 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:03:25 <evolio_> sorry
16:03:28 <evolio_> will use next time
16:03:30 * bos <$> cocoa <*> bed
16:03:36 <copumpkin> :)
16:03:37 <|Jedai|> Jonno_FTW: and they're big, so multiplication is not a O(1) operation here
16:03:47 <Jonno_FTW> blast
16:03:50 <kmc> evolio_, you don't define what "xs" refers to
16:03:52 <ski> evolio_ : you forgot to name the parameter to the `filter3' function
16:04:03 <Jonno_FTW> does this mean i have to find some other method of solving the problem?
16:04:13 <ski> evolio_ : `filter3 myIntListInput = ..myListInput..'
16:04:17 <Jonno_FTW> because that prime factors optimisation was the best i could come up with
16:04:40 <evolio_> kmc/ski could you explain further
16:04:44 <|Jedai|> Jonno_FTW: 5397346292805549782720214077673687806275517530364350655459511599582614290 is your number...
16:04:59 <Jonno_FTW> p
16:05:05 <evolio_> i thought xs was a predefinied thing... as in for variable x, xs is the whole thing?
16:05:06 <Jonno_FTW> it only has 49 factors though
16:05:28 <Cale> Jonno_FTW: What's the problem?
16:05:33 <|Jedai|> Jonno_FTW: 42 primes factors, 2^42 divisors
16:05:37 <Jonno_FTW> 42 factors
16:05:38 <Jonno_FTW> typo
16:05:39 <kmc> evolio_, no... and you didn't define x either
16:05:46 <kmc> evolio_, you're writing a function that takes "xs"
16:05:53 <Jonno_FTW> > 2^42
16:05:53 <kmc> it's as if you wrote "f = n + 3" instead of "f n = n + 3"
16:05:54 <lambdabot>   4398046511104
16:06:00 <Jonno_FTW> blast
16:06:04 <evolio_> ok
16:06:41 <|Jedai|> Jonno_FTW: it wouldn't be as bad if we didn't have to work with Integer, but this mod 10^16 is not really encouraging...
16:06:47 <dons> mm. hot chocolate time. good thinking bos. night!
16:06:56 <Jonno_FTW> hmm
16:07:01 <evolio_> ok got it
16:07:09 <Jonno_FTW> what if i got the factors in reverse
16:07:32 <|Jedai|> > length . show $ maxBound :: Int
16:07:33 <lambdabot>   2
16:07:41 <evolio_> so for function foobar, foobar xs = ...., xs refers to the whole list and x refers to an individual item in the list?
16:07:45 <Jonno_FTW> so as to the avoid the majority of factors
16:07:51 <|Jedai|> > maxBound :: Int
16:07:53 <lambdabot>   9223372036854775807
16:08:08 <|Jedai|> > show $ maxBound :: Int
16:08:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:08:10 <lambdabot>         against inferred type ...
16:08:16 <kmc> > (length . show $ maxBound) :: Int
16:08:18 <lambdabot>   2
16:08:19 <|Jedai|> > length . show $ (maxBound :: Int)
16:08:20 <lambdabot>   19
16:08:32 <kmc> > (length . show (maxBound :: ()) :: Int
16:08:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:08:38 <kmc> > (length . show (maxBound :: ())) :: Int
16:08:39 <lambdabot>   Couldn't match expected type `[a]'
16:08:39 <lambdabot>         against inferred type `GHC.Types...
16:08:46 <|Jedai|> Jonno_FTW: do you have a 64 bit computer ?
16:08:46 <kmc> > (length . show (maxBound :: Bool)) :: Int
16:08:48 <lambdabot>   Couldn't match expected type `[a]'
16:08:48 <lambdabot>         against inferred type `GHC.Types...
16:08:53 <Jonno_FTW> yes
16:09:06 <kmc> > (length . show $ (maxBound :: Bool)) :: Int
16:09:08 <lambdabot>   4
16:09:15 <kmc> ... what type did it use?
16:09:16 <|Jedai|> Jonno_FTW: Then you may manage to use Int
16:09:30 <Jonno_FTW> hmm
16:09:35 <evolio_> kmc, am i right with my understanding of xs?
16:09:45 <kmc> evolio_, there's no magic relationship between x and xs
16:09:50 <kmc> they are two distinct names for variables
16:09:57 <Jonno_FTW> i don't follow
16:10:14 <kmc> nor does xs have to be a list.  it's just a convention
16:10:22 <kmc> > let { foobar xs = xs + 3 } in foobar 5
16:10:24 <lambdabot>   8
16:10:41 <evolio_> oh i see
16:10:45 <kmc> evolio_, the part where x is an element of xs happens when you say "x <- xs" in the list comprehension
16:10:47 <|Jedai|> Jonno_FTW: instead of doing multiplication, you can do modular multiplication, and you don't need to test against the sqrt
16:10:52 <evolio_> aaaaaaaaah
16:10:53 <evolio_> i see
16:10:57 <kmc> that defines x in terms of xs
16:11:05 <Jonno_FTW> modular multiplication?
16:11:07 <ski> `x <- xs' is read as "`x' is an element of `xs'"
16:11:21 <|Jedai|> Jonno_FTW: since you already know how many factors there are and so how many factors under the squareroot
16:11:28 <ski> (s/an/any/, if you prefer)
16:11:39 <kmc> or "x chosen from xs"
16:11:48 <Jonno_FTW> how?
16:12:03 <Jonno_FTW> sorry, I only have yr 12 maths
16:12:14 <|Jedai|> Jonno_FTW: x = x'[n] and y = y'[n] ==> xy = x'y'[n]
16:12:20 <evolio_> i think if the exam paper is anything like the rest of the candidates, i should be able to get 50% now :)
16:12:29 <evolio_> another 6 hours and hopefully i can get a bit more learnt
16:12:35 <|Jedai|> Jonno_FTW: read that as "x congruent to x' modulo n"
16:14:21 <Jonno_FTW> how do i use this though?
16:14:35 <|Jedai|> Jonno_FTW: now that I think about it, you don't need to worry about that if we manage to generate the factors in the right order
16:14:47 <Jonno_FTW> yeah
16:15:18 <|Jedai|> since you already know what index is the psr
16:15:33 <Jonno_FTW> i do?
16:15:48 <|Jedai|> Jonno_FTW: yeah, since you know how many divisors there are
16:16:00 <Jonno_FTW> 2^42 divisors
16:16:13 <Jonno_FTW> then what is the index of the factor i want?
16:17:00 <evolio_> ok, so taking [ x | x <- xs , x >= 3 ], is there a way to say 'any number' instead of x >= 3
16:17:21 <xpika> i want to parse text using parsec from the other end so that i can parse the TOKEN "COMMAND" out of somehting like "foo foobar bazCOMMAND"
16:17:36 <xpika> what would be a good way of going about this.
16:17:37 <evolio_> right now i'm doing add1 xs = [ x + 1 | x <- xs, x > 0 ] but that seems a bit silly
16:20:10 <Cale> Jonno_FTW: What is the question you're trying to answer?
16:20:29 <Jonno_FTW> my program takes too much RAM
16:20:39 <Cale> What does your program do?
16:20:41 <Jonno_FTW> factors = map product . sequence . map (\(x,y) -> map (x^) [0..y]) . primePowerFactors
16:20:43 <Jonno_FTW> psr n = last $ takeWhile (< rSq n) $  sort $ factors n
16:20:44 <|Jedai|> Jonno_FTW: 2^41 or maybe 2^41 - 1
16:21:01 <Jonno_FTW> hmm
16:21:13 <Cale> What's rSq?
16:21:21 <Jonno_FTW> rSq n = toInteger $ round $ sqrt (fromInteger n)
16:21:23 <|Jedai|> Jonno_FTW: 2^41 - 1 (since there are 2^41 divisors under the sqrt)
16:21:29 <Jonno_FTW> of course
16:21:37 <Jonno_FTW> willl this suck up my RAM?
16:21:44 <Jonno_FTW> or will it only calculate that one factor
16:22:27 <|Jedai|> Jonno_FTW: if we rephrase our generator so that it generates them in order directly, we won't need to sort them so it should be ok (nothing will force the values)
16:22:33 <Cale> Okay, so you're computing all the divisors of some large number, and then sorting them? It'll have to calculate all of them to sort them.
16:22:49 <Jonno_FTW> blast
16:22:51 <Cale> (and keep them in memory the whole time)
16:22:53 <c_wraith> much easier to just spit them out sorted.
16:23:10 <c_wraith> divide by 2 until you can't.  then go to 3.  and so on up the list of primes, until you're left with 1.
16:23:30 <Cale> What are we actually trying to compute here?
16:23:41 <c_wraith> Oh, good point.  Prime factors, or all divisors?
16:23:48 <Jonno_FTW> factors
16:23:50 <|Jedai|> c_wraith: that's not the problem
16:23:53 <Cale> ...
16:23:56 <Jonno_FTW> i already have the prime factors
16:24:17 <|Jedai|> c_wraith: the number is the product of the first 42 primes, we want its pseudo-square-root
16:24:18 <Jonno_FTW> we just need to make sure the prime factors are produced in order
16:24:19 <Cale> What problem are you actually trying to solve?
16:24:31 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=266
16:24:37 <|Jedai|> the last divisor under its square root
16:24:44 <Jonno_FTW> hopefully i'll get the first haskell solution
16:24:55 <Jonno_FTW> psr2 n = (factors n) !! ((2^(length $ primePowerFactors n))-1)
16:26:39 <c_wraith> Oh.  So it has 42 prime factors. and what you're really looking for is the combination of them with the largest product less than or equal to its sqrt
16:26:49 <|Jedai|> c_wraith: right
16:26:53 <Jonno_FTW> no combination
16:26:56 <Jonno_FTW> just a factor
16:27:08 <Jonno_FTW> oh wait
16:27:10 <Jonno_FTW> yeah
16:27:50 <evolio_> i am struggling to find any simple-to-read documentation on list-recursion
16:27:51 <c_wraith> so the brute force solution space is 2^42.  I see.  You can be a lot smarter than that with a branch & bound strategy, though
16:28:07 <Jonno_FTW> but
16:28:09 <Cale> evolio_: What tutorial are you using?
16:28:19 <|Jedai|> Ok, I may have an idea
16:28:22 <Jonno_FTW> the solution is so close
16:28:23 <evolio_> using haskell wikibooks and google
16:28:45 <Cale> evolio_: Have you tried LYAH? :)
16:28:48 <Cale> @where lyah
16:28:49 <lambdabot> http://www.learnyouahaskell.com/
16:28:55 <Jonno_FTW> for great good
16:29:30 <evolio_> never found this, this looks excellent
16:29:34 <evolio_> wish i'd started with this heh
16:29:39 <evolio_> nevermind :)
16:30:48 <c_wraith> Is there a solution that's obviously better than branch & bound?
16:31:04 <Jonno_FTW> a sorted list of tuples
16:31:30 <c_wraith> Is that really better?
16:31:39 <Jonno_FTW> it should be
16:31:45 <|Jedai|> c_wraith: just make the "product" of the binary representation of 2^41 and the list of the 42 first primes
16:32:18 <Jonno_FTW> if done correctly, it should give the  lists of tuples in an order such that the result is ascending
16:33:45 <Cale> Branch and bound seems like the right way to do it to me.
16:34:14 <Jonno_FTW> branch and bound?
16:34:30 <Cale> You won't have to search very much of the space of divisors, because not very many of them are close to the square root.
16:36:57 <luite> perhaps you could just find the largest number below the square root with largest factor smaller than 190
16:37:21 <luite> not sure how close it actually is :)
16:38:32 <evolio_> Cale, i'm stuck on how to pick numbers greater than 3 out of a list recursively
16:38:55 <luite> oh I guess that wouldn't work when you have repeated factors
16:39:07 <clarkb> evolio_: set up your recursive function to do one thing when the number is > 3 and another thing when it isnt
16:39:09 <Cale> evolio_: Okay, so we break it down into two cases
16:39:28 <evolio_> i got as much, but i'm struggling with the syntax on how to write that
16:39:30 <Cale> evolio_: One is where the list you're given is empty, and the other is where the list is nonempty
16:39:34 <Cale> foo [] = ...
16:39:37 <Cale> foo (x:xs) = ...
16:40:16 <Cale> Any nonempty list is constructed from a first element and another list using the (:) constructor.
16:40:37 <Cale> So this pattern match will call the first element of the matched list x, and the remainder of the list xs
16:42:06 <evolio_> yep, i understand that
16:42:10 <Cale> evolio_: So, it should be easy enough to resolve the empty case at least, yeah? :)
16:42:19 <evolio_> foo [] = 0
16:42:23 <Cale> oh?
16:42:32 <Cale> Isn't the result intended to be a list?
16:42:38 <evolio_> foo [] = [] :)
16:42:42 <Cale> okay
16:43:02 <Cale> and now, in the recursive case, we have two possibilities
16:43:13 <Cale> Either x is larger than 3, or it is not.
16:43:20 <evolio_> yes
16:43:34 <Cale> We can express this in a number of ways, but probably the most idiomatic in Haskell is to use guards
16:43:43 <Cale> foo (x:xs)
16:43:55 <Cale>   | x > 3     = ...
16:44:00 <Cale>   | otherwise = ...
16:44:11 <jkff> Hi. What are some uses of impredicative polymorphism? I looked at the "boxy types" and "FPC" papers of SPJ and found only artificial examples, looked at stackoverflow and haskellwiki and wikibooks, and found there absolutely nothing. I googled and found only some more theoretical papers on type systems. I don't know where else to look.
16:44:58 <jkff> TAPL has nothing interesting on that, too
16:45:10 <Cale> evolio_: Have you seen code like that? Is it clear what's intended there?
16:45:55 <evolio_> yes
16:46:00 <Cale> evolio_: Each guard is evaluated in order, and the first one to give True will result in that right hand side of the equation being selected
16:46:07 <evolio_> cale, so if x > 3, put it somewhere, otherwise, discard it
16:46:22 <Cale> evolio_: Well, don't just put it *somewhere*, it's part of our result.
16:46:27 <c_wraith> Let's see if this terminates in a sane amount of time
16:46:37 <Cale> evolio_: so we ought to have:
16:46:50 <Cale>   | x > 3     = x : ...
16:46:57 <kmc> i don't understand how ImpredicativeTypes and RankNTypes differ
16:46:58 <c_wraith> Ah, crap, it won't.  I did it all wrong.  sigh
16:47:03 <kmc> i can give lots of use cases for the latter
16:47:28 <Cale> evolio_: and then what will the rest of the list be? Well, we haven't used xs yet, so it probably is obtained from xs somehow.
16:47:51 <Cale> evolio_: We want the rest of the list to be the result of picking out the large elements from xs, right?
16:48:14 <kmc> jkff, perhaps you are building an interpreter for a dynamically typed language.  and you'd like a finite map of valid numerical operations.  its type would be: Data.Map.Map String (forall a. (Num a) => a -> a -> a)
16:48:20 <kmc> (this came up here a while back)
16:48:24 <kmc> i think that'd be impredicative
16:48:29 <evolio_> yes
16:48:35 <jkff> kmc: Thanks, that's a really good example!
16:48:46 <Cale> evolio_: Thankfully, we have a function for picking out all the large elements of xs already.
16:48:58 <Cale> The foo that we're writing of course!
16:49:07 <Cale> So we get:
16:49:11 <Cale>   | x > 3     = x : foo xs
16:49:44 <Cale> That is, if x is larger than 3, then foo (x:xs) = x : foo xs
16:50:04 <kmc> i suppose that type is rank-1 and therefore i have answered my own question as well :)
16:50:07 <copumpkin> does our mergesort reduce to the selection algorithm (i.e., O(n)) if you only ask for one value?
16:50:19 <Cale> evolio_: Make sense?
16:50:24 <evolio_> yes, completely
16:50:33 <evolio_> Cale, what do we do about the otherwise then?
16:51:06 <Cale> Well, what should we do? We don't want x to appear in the result.
16:51:07 <Cale> So we won't use x this time
16:51:32 <Cale> But then doesn't that mean that foo (x:xs) will be the same thing as foo xs ?
16:51:57 <Cale> and that should work :)
16:52:03 <Cale>   | otherwise = foo xs
16:52:11 <evolio_> ok
16:52:17 <evolio_> let me play around with this then :)
16:52:45 <Cale> evolio_: Normally, you'd just write this as  foo = filter (> 3)
16:53:01 <Cale> evolio_: But it's good to be perfectly comfortable with recursion
16:53:05 <evolio_> Cale, yes, i know but my textbook question says use recursion
16:53:24 <copumpkin> anyone know? it seems like there's no good way to test without just timing it
16:53:32 <evolio_> as i explained a little while ago, i have some problems and i have to solve them with list comprehension, then recursion, then high-order functions
16:53:46 <evolio_> i've got the list comp and high-order functions
16:53:51 <evolio_> just needed to brush up the recursion
16:54:00 <Cale> evolio_: ah, okay :)
16:54:12 <evolio_> the syntax is so strange to someone like me used to php/python
16:54:20 <evolio_> especially php
16:54:45 <Cale> evolio_: if it helps, another option would have been to write   foo (x:xs) = if x > 3 then x : foo xs else foo xs
16:55:09 <Cale> That is, since there are only two options here, it doesn't hurt to just use if :)
16:55:13 <evolio_> yeah
16:55:33 <Cale> (If there were more, we'd have to start nesting if/then/else, which gets awkward)
16:56:06 <evolio_> yeah gotcha
16:56:15 <evolio_> i'm well versed in the nastiness of nested if, as a php user
16:56:19 <Cale> :)
16:56:24 <evolio_> or should i say sufferer ;)
16:56:47 <luite> but a haskell if is not quite the same as an if in an imperative language
16:56:58 <evolio_> i'm aware
16:57:10 <evolio_> my rule for haskell is pretty much forget everything you know about programming and start again :)
16:57:24 <Cale> yeah, it's more like the ?: operator (can't remember if PHP has that, but many C-like languages do)
16:57:32 <Cale> evolio_: That's a good policy
16:57:34 <luite> that's not a bad rule, second rule should be join #haskell :p
16:57:43 <evolio_> well i'm here ain't i? :D
16:57:56 <copumpkin> think of all those who aren't!
16:57:56 <evolio_> could I PM you Cale?
16:57:59 <Jonno_FTW> this is my first time and i started learing haskell ~3 months ago
16:58:02 <Cale> evolio_: sure
16:58:28 <Cale> Jonno_FTW: Yeah, we try to get the word out, but there do seem to be a lot of Haskell users who aren't here :)
16:58:39 <Jonno_FTW> wow
16:59:08 <Jonno_FTW> i normally get help on stackoverflwo
16:59:11 <Jonno_FTW> *flow
16:59:52 <Cale> That's interesting. I only glanced at that site briefly when it first opened. I didn't know there was much of a Haskell community on there.
17:00:23 <Jonno_FTW> there is only 500 or so haskell tagged questions
17:01:07 <Jonno_FTW> 562
17:08:05 <ski> mmorrow : where does `Pos' come from in <http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5105> ?
17:10:11 <copumpkin> looks like BMeph did that?
17:10:22 <c_wraith> Jonno_FTW: What's the runtime on solutions in other languages?
17:10:45 <Jonno_FTW> i can't see them without the answer first
17:10:54 <ski> ("author  morrow")
17:11:13 <Jonno_FTW> but i think the trick is to produce the lists of primepowers in order
17:12:26 <Jonno_FTW>     (2^0)(7^0) = 1 , (2^1)(7^0) = 2, (2^2)(7^0) = 4, (2^0)(7^1) = 7, (2^1)(7^1) = 14,(2^2)(7^1) = 28
17:12:28 <c_wraith> Well, I've got a branch &  bound search running.  I just have no clue if it's going to finish in a reasonable amount of time
17:12:31 <Jonno_FTW> like that
17:12:45 <copumpkin> ski: oh, I see. BMeph homogenized the Pos
17:13:11 <Jonno_FTW> can this be done?
17:13:43 <c_wraith> wait, what
17:13:45 <copumpkin> Jonno_FTW: yes, but it's not trivial
17:13:48 <c_wraith> the problem isn't what I thought
17:13:59 <Jonno_FTW> blast
17:14:00 <c_wraith> it's mod 10^16
17:14:09 <c_wraith> that makes this both easier and harder
17:14:28 <Jonno_FTW> can't i just get the answer and then mod 10e16 it?
17:14:32 <c_wraith> No.
17:14:40 <Jonno_FTW> why not?
17:14:41 <copumpkin> Jonno_FTW: that'd also be inefficient
17:14:48 <c_wraith> Because the *input* is p mod 10^16
17:14:56 <c_wraith> that's a completely different number
17:15:15 <c_wraith> oh, damn my inability to read
17:15:20 <Jonno_FTW> i yeah
17:15:27 <c_wraith> you're right.  But it is inefficient.
17:15:33 <Jonno_FTW> (psr p) `mod` 10e16
17:16:02 <c_wraith> like, to the point where I should be re-writing this to take advantage of those mod steps
17:17:24 <c_wraith> hmm.  not sure that's actually possible.  the sqrt is significantly greater than 10e16
17:18:00 <Cale> I wouldn't expect it to be of much use, because it's not valid to do the order comparisons modulo 10^16
17:18:06 <c_wraith> right
17:18:51 <Jonno_FTW> yeah
17:19:06 <Jonno_FTW> i think the modulo is so the answer is short
17:19:26 <c_wraith> well, then.
17:19:29 <c_wraith> I'm going to sleep
17:19:31 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13737#a13737
17:19:37 <c_wraith> I'm going to see if that finishes by morning
17:20:02 <c_wraith> I have no clue why I still have the Control.Monad import
17:25:03 * Cyneox re
17:31:10 <_Jedai_> c_wraith: it's not really a branch and bound, or rather the bound part is quite large, right ? You still have to explore 2^41 possibility and find the maximum in that...
17:32:12 <Jonno_FTW> i did some checking with 2^n -1 trick
17:32:17 <Jonno_FTW> and it doesn't always work
17:32:31 <Jonno_FTW> psr2 n = (sort $ factors n) !! ((2^((length $ primePowerFactors n)-1)))
17:33:07 <_Jedai_> Jonno_FTW: It do for products of unique prime factors
17:33:10 <Jonno_FTW> *Main> psr 3156
17:33:12 <Jonno_FTW> 12
17:33:13 <Jonno_FTW> *Main> psr2 3156
17:33:15 <Jonno_FTW> 6
17:33:26 <_Jedai_> Jonno_FTW: that's all that matters for our case :)
17:33:30 <Jonno_FTW> ok
17:34:36 <Jonno_FTW> what?
17:34:58 <_Jedai_> I think so at least ;)
17:35:14 <Jonno_FTW> *Main> psr2 (173*181)
17:35:16 <Jonno_FTW> 181
17:35:17 <Jonno_FTW> *Main> psr (173*181)
17:35:19 <Jonno_FTW> 173
17:35:29 <Jonno_FTW> psr is the correct result
17:36:00 <Jonno_FTW> and those are 2 prime factors of p
17:36:01 <_Jedai_> Jonno_FTW: Right, I said 2^41 - 1
17:36:29 <_Jedai_> Jonno_FTW: which does (2^((length $ primePowerFactors n)-1) - 1
17:37:08 <Jonno_FTW> ok
17:37:12 <Jonno_FTW> it's all good now
17:37:29 <Jonno_FTW> hazah
17:37:40 <Jonno_FTW> now to sort out the factors list problem
17:41:40 <Jonno_FTW> hmm
17:41:51 <Jonno_FTW> can't think of how to do it
17:42:00 <scalaLove> Why does not this show error: [[1,2,3], []] I mean arent lists homogeneous? and here we have elements of different type: [Int] and []
17:42:37 <fasta> scalaLove, [] is not a type.
17:42:50 <fasta> scalaLove, [a] is a type for example.
17:43:06 <fasta> scalaLove, and this happens to unify with [Int]
17:43:13 <_Jedai_> scalaLove: [] is an empty list, an empty list can be of any type
17:44:20 <scalaLove> fasta, everything has type, that is of type "empy list", i like Jedai explanation, thanks guys
17:44:38 <_Jedai_> scalaLove: in other word, the first sublist say that the type of your list must be [[Int]] so the second empty list is inferred as an [Int] list though it could have any other type
17:45:05 <_Jedai_> scalaLove: [] is not a type, fasta is correct, [] has a type but it's not a type.
17:45:31 <scalaLove> I see
17:45:54 <_Jedai_> scalaLove: the discussion is confused because similar syntax are used to indicate list values and list type, but if you rename the type constructor List . instead of [.]
17:46:28 <_Jedai_> scalaLove: you'll see that only "List Int" is a type "List" is only a type constructor
17:46:42 <manju> psst...guys what is the secret haskell handshake ?
17:46:51 <_Jedai_> scalaLove: and [] can be of type "List a" for any a imposed by the context
17:47:17 <scalaLove> this would be type inference in action?
17:47:41 * fracture wishes "fromIntegral" were a little less verbose.
17:47:45 <_Jedai_> scalaLove: yes, this is.
17:48:22 <_Jedai_> fracture: True, I often put "fI x = fromIntegral x" in my programs if I need fromIntegral too much
17:48:32 <fracture> ah. good idea
17:48:57 <Jonno_FTW> there is a haskell hadshake?
17:49:18 <manju> <whisper>yes</whisper>
17:49:19 <_Jedai_> Jonno_FTW: Not to the best of my knowledge
17:49:35 <manju> there is a guy in another channel offering me it
17:49:49 <Jonno_FTW> i would assume it involve a fold
17:49:49 <_Jedai_> manju: nice for you
17:49:51 <endojelly> why are people in #haskell always so nice and knowledgable and people in other language channels like #python always so irritating and full with wrong assumptions
17:50:07 <Jafet> Because we crave success
17:50:09 <Jonno_FTW> because the don't program in haskell
17:50:14 <Jonno_FTW> *they
17:50:29 <manju> endojelly: ever tried programming in python ?
17:50:40 <kfish> manju, lol
17:50:43 <endojelly> manju, I do actually 8)
17:50:52 <manju> kfish: :-)
17:51:01 <Jonno_FTW> i tried one time
17:51:43 <shambler> why you talk about PLs like about drugs...
17:51:52 <medfly> lol
17:51:59 <Jonno_FTW> because python was there
17:52:03 <quicksilver> endojelly: irritating and rude is the IRC norm.
17:52:14 <scalaLove> guys lets keep it haskell
17:52:16 <quicksilver> endojelly: (I don't know why/how #haskell flaunts it so effectively)
17:52:16 <Jonno_FTW> he walked out from the shadows offering something new
17:52:22 <evolio_> ok, i have to make a function that takes an integer, and a list, and make the list repeat so it is the length of the integer
17:52:54 * kfish smells homework
17:53:01 <manju> endojelly: <pet_theory>I think it is more to do with the age group, python is for rank newbies and I would assume the average age of #python is younger than #haskell </pet_theory>
17:53:05 <medfly> take n . cycle $ list
17:53:06 <evolio_> for example; if the integer was 8 and the list "abc" it'd produce output abcabcab
17:53:15 <medfly> er, or is it
17:53:21 <medfly> @type cycle
17:53:22 <lambdabot> forall a. [a] -> [a]
17:53:26 <evolio_> i've got to use list comprhension on this one, not higher order functions
17:53:30 <endojelly> manju, that's a good theory
17:53:30 <medfly> @type repeat
17:53:31 <lambdabot> forall a. a -> [a]
17:53:38 <dibblego> evolio_, it would be great if you did your own homework
17:53:45 <evolio_> what would be the best way about going about thi
17:53:45 <evolio_> s
17:53:45 <medfly> that one then
17:53:52 <evolio_> :/
17:54:02 <medfly> I LOVE SOLVING OTHER PEOPLE'S HOMEWORK! IT MAKES ME FEEL LIKE I AM CAPABLE OF SOLVING SOME HOMEWORK!
17:54:23 <Jafet> "We don't do homework, let alone yours"
17:54:23 <evolio_> i just need a pointer in the right direction so i can look up the right stuff
17:54:26 * manju checks if #haskell just became #python
17:54:31 <fasta> evolio_, *
17:54:39 <dibblego> @where yaht
17:54:39 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
17:54:45 <dibblego> evolio_, ^^
17:55:13 <Jonno_FTW> ahh homework
17:55:17 <ray> got to love irc homework whiners
17:55:20 <kfish> at least haskell homework is fun to work out by yourself :)
17:55:21 <Jonno_FTW> good thing i finished school a few weeks ago
17:55:25 <ray> and by "got to" i mean "inclined to"
17:55:28 <ray> and by "love" i mean "hate"
17:55:37 <Jafet> List comprehension isn't really the first thing that pops into my head when I think about taking n elements from a cycled list
17:55:37 <Jonno_FTW> i finished secondary school FOR EVER
17:55:38 <manju> how do you guys know he is asking for homework help ?
17:55:39 <medfly> I thnk he should have done it the insult way
17:55:49 <medfly> Haskell sucks! it can't even repeat a list n times!
17:55:55 <evolio_> lol
17:55:59 <manju> I am a newbie too, and I could probably ask that question :-) ?
17:56:00 <Jonno_FTW> it can
17:56:05 <fasta> manju, I have to use list comprehensions for this one kind of gives it away.
17:56:09 <medfly> Jonno_FTW, oh yeah? show me
17:56:18 <evolio_> i was thinking about getting the length of the list, dividing by the integer and then doing someting from that
17:56:21 <evolio_> probably a poor way to do it
17:56:22 <Jafet> @faq can Haskell do that?
17:56:23 <lambdabot> The answer is: Yes! Haskell can do that.
17:56:33 <ray> it's sad that the insult way is more reliable than just asking
17:56:35 <Jonno_FTW> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#16
17:56:36 <fasta> evolio_, anyway, there are two different things to consider.
17:56:38 <ray> isn't it?
17:56:40 <Jonno_FTW> 4 functions for it
17:56:41 <medfly> am I a bad Haskeller for telling him the answer?
17:56:41 <ray> am i just out of touch
17:56:53 <Jonno_FTW> you want
17:56:58 <quicksilver> for the record, "we don't do homework" is *not* the official #haskell policy.
17:56:59 <Jonno_FTW> f x xs = replicate x xs
17:57:01 <luite> hmm, I have to admit that I wouldn't even know how to do it with list comprehensions
17:57:08 <fasta> evolio_, 1) syntax (read the language report). 2) the algorithm (you should have learned how to come up with algorithms in some other course).
17:57:16 <quicksilver> http://www.haskell.org/haskellwiki/Homework_help
17:57:23 <medfly> Jonno_FTW, it's okay :) I was just showing how to ask questions the insult way (the sure way to get answers)
17:57:26 <manju> luite: I could if I figured how to make a list into a string
17:57:27 <medfly> Jonno_FTW, thanks
17:57:35 <quicksilver> manju: strings are lists.
17:57:36 <Jonno_FTW> :)
17:57:39 <quicksilver> manju: (strings are lists of Chars)
17:57:43 <Jonno_FTW> lists of chars
17:57:58 <manju> ah...see ?
17:58:07 <Jonno_FTW> "abc
17:58:08 <evolio_> fasta, i don't know a good algorithm for this
17:58:14 <ray> haskell sucks, it can't even compile itself
17:58:18 <Jonno_FTW> "abc" == ['a','b','c']
17:58:22 * Jafet compiles ray
17:58:31 * Jonno_FTW double-compiles ray
17:58:50 <Jafet> evolio, you will, once you think about it hard enough
17:58:52 <fracture> @hoogle ap
17:58:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
17:58:53 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
17:58:53 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
17:59:17 <luite> manju: how would you do it (msg if you don't want to spoil the answer for evolio_)?
17:59:21 <ray> evolio_: start by thinking infinite lists
17:59:29 <manju> luite: I am thinking
17:59:39 <Jonno_FTW> what about
17:59:39 <luite> I know a way, but it's extremely ugly
17:59:40 <Jonno_FTW> [n
18:00:00 <evolio_> ok, should i do three cases - 1) if the integer is less than the length, then just split, 2) if it is the same, just output, 3) if it is more, make it longer by adding it together
18:00:21 <evolio_> infinite lists sounds like a plan. i could then just make abcabcabcabc (to infinity) and then split the right length out?
18:00:22 <Jonno_FTW> f x xs =[n|n<-(replicate x xs)]
18:00:28 <endojelly> which reminds me, I still have to grade a lot of homework...
18:00:31 <Jonno_FTW> it's a list comprehension
18:00:31 <ray> yeah
18:00:38 <ray> we have a function called "take" too
18:00:40 <endojelly> actually, no, I don't have to grade it, just... correct it
18:00:45 <luite> Jonno_FTW: how does that use the list comprehension?
18:00:45 <endojelly> how do you say that in english?
18:00:49 <endojelly> in germany we say "korrigieren"
18:00:54 <evolio_> i already have take written down on my notes here for this one
18:01:06 <evolio_> ok, so what i need to do i guess is make an infinite list and split it down to the length :)
18:01:09 <endojelly> to mark homework?
18:01:09 <Jonno_FTW> isn't "[n|n<-(replicate x xs)]" a list comprehension thing?
18:01:19 <luite> it's the same as (replicate x xs)
18:01:24 * evolio_ googles infinite lists
18:01:32 <Jonno_FTW> replicate is the built in function you need
18:01:36 <endojelly> to process homework?
18:01:41 <ray> @hoogle [a] -> [a]
18:01:41 <lambdabot> Prelude cycle :: [a] -> [a]
18:01:42 <lambdabot> Prelude init :: [a] -> [a]
18:01:42 <lambdabot> Prelude reverse :: [a] -> [a]
18:01:53 <Jonno_FTW> make a program to grade homework?
18:01:53 <medfly> somehow I actually answered his question a while ago except it was somehow lost
18:02:02 <Jonno_FTW> i saw
18:02:09 <Jonno_FTW> he wanted a list comprehension
18:02:22 <medfly> oh
18:02:35 <evolio_> yeah i need to do it with list comprehension first then recursion
18:02:43 <Jafet> (an expression that produces the desired list) can be written as [ x | x <- (an expression that produces the desired list) ]
18:02:55 <luite> I was thinking about  mkList xs n = head [ys | ys <- (inits.cycle $ xs), length ys == n]
18:03:09 <manju> > ["abc" | x <- [1..n]]
18:03:10 <lambdabot>   * Exception: not a number
18:03:15 <manju> > ["abc" | x <- [1..8]]
18:03:16 <lambdabot>   ["abc","abc","abc","abc","abc","abc","abc","abc"]
18:03:20 <mlesniak> Anyone knows if there's a possiblity to pass command line options while using criterion? Did not found any infos in the docs
18:03:24 <manju> something like that ?
18:03:34 <luite> but I can't imagine why anyone would want to write it like that :)
18:03:41 <Jonno_FTW> :!command
18:03:45 <evolio_> manju could you then join this list together
18:03:56 <endojelly> what would you use for disjoint sets (creating, merging, finding elements)? union-find with ranking an path compression? is that a feasible data structure for purely functional environments?
18:03:58 <ray> :t concat
18:04:00 <lambdabot> forall a. [[a]] -> [a]
18:04:02 <Jonno_FTW> concat
18:04:18 <evolio_> yep
18:04:20 <manju> > concat ["abc" | x <- [1..8]]
18:04:22 <lambdabot>   "abcabcabcabcabcabcabcabc"
18:04:31 <evolio_> this is very simple i think :)
18:04:35 <manju> evolio_: that is the stupid way
18:04:40 <Jonno_FTW> i think it's right
18:04:53 <manju> I have exactly written 8 programs in haskell so beware of my skillz
18:05:01 <manju> small ones (one liners)
18:05:12 <mlesniak> argh, nevermind
18:05:22 <Jonno_FTW> i have a folder fulll of programs in haskell
18:05:25 <Jonno_FTW> not all of them work
18:05:34 <manju> I am just enough to make me dangerous
18:05:38 <luite> [fst x | x <- zip (cycle xs) [1..n]] ?
18:05:43 <manju> s/am/know
18:05:51 <ray> > let f n xs = take n $ cycle xs in (f 5 "arctic circle", f 10 "hi") -- is what i would do, but i guess there's no list comprehension there
18:05:53 <lambdabot>   ("arcti","hihihihihi")
18:05:53 <Jonno_FTW> dangerous how?
18:06:17 <evolio_> how does one comment in haskell?
18:06:18 <luite> ray: he has to do it with higher order functions next, don't spoil it ;)
18:06:21 <medfly> --
18:06:24 <luite> evolio_: -- for single line
18:06:24 <Jafet> We don't need comments!
18:06:26 <mjsor> {-  -}
18:06:26 <ray> -- like this
18:06:27 <Jonno_FTW> {-multiline \m -}
18:06:30 <evolio_> cheers
18:06:35 <Lemmih> evolio_: Rarely.
18:06:36 <Jafet> ...thanks, everyone.
18:06:41 <manju> Jonno_FTW: I dunno, where I am nobody knows anything about haskell (not many people atleast), so hypothetically I could get hired to write software the space shuttle or something
18:06:42 <Jonno_FTW> -- This is a well commented line
18:07:04 <Jonno_FTW> where i come from
18:07:10 <Jonno_FTW> only 2 people knew about haskell
18:07:17 <Jonno_FTW> and neither of them could program in it
18:07:20 <manju> haha
18:07:26 <Jonno_FTW> teachers that is
18:07:38 <Jonno_FTW> and one was a programming teacher
18:07:39 <medfly> I don't see why knowing Haskell means you'd be hired to program for the space shuttle
18:07:45 <scalaLove> why this gives me error: [1, 2, 3] : [4, 5]
18:07:52 <manju> you mean they were haskell teachers ?
18:07:54 <Jonno_FTW> use ++ instead of :
18:08:01 <Jonno_FTW> one was a maths teacher
18:08:10 <luite> @type (:)
18:08:11 <lambdabot> forall a. a -> [a] -> [a]
18:08:15 <fasta> manju, if you want to work on a space shuttle, become an expert at some theorem provers and learn about space, I guess.
18:08:16 <Jonno_FTW> the other was a maths physics teacher
18:08:19 <ray> scalalove: : is for adding an element to a list, not for joining lists together
18:08:24 <fasta> manju, Haskell is a step in the right direction, though.
18:08:24 <manju> medfly: I am just kidding :-)
18:08:24 <ray> > 1 : [2,3,4,5]
18:08:25 <lambdabot>   [1,2,3,4,5]
18:08:32 <manju> fasta: I agree
18:08:37 <ray> > [1] ++ [2,3,4,5]
18:08:38 <lambdabot>   [1,2,3,4,5]
18:08:45 <scalaLove> ray: tnx
18:08:45 <evolio_> ugh i struggle when functions need two inputs
18:08:49 <medfly> I do however feel that Haskell made me a better programmer.
18:08:54 <evolio_> makelist = replicate n [a]
18:08:57 <fasta> evolio_, those functions don't exist.
18:09:00 <evolio_> why is that wrong?
18:09:12 <medfly> you can just write makelist arg1 arg2 = something arg2 arg1
18:09:23 <copumpkin> evolio_: it'll give you a list of singleton lists
18:09:24 <medfly> or something.
18:09:29 <manju> evolio_: are you following any text book ?
18:09:38 <fracture> hmm so... I see like 3-4 linear algebra libraries in hackage
18:09:42 <fracture> anyone have any recommendations?
18:09:59 <Jonno_FTW> i reckon learn you a haskell is one of the best
18:09:59 <fasta> fracture, it depends on lots of stuff.
18:10:00 <copumpkin> fracture: I liked conal's one
18:10:08 <Jonno_FTW> then use project euler for practice
18:10:10 <fasta> fracture, do you care about the license for example?
18:10:14 <fracture> I just need some basic matrix multiplication ... dimension < 10
18:10:21 <fracture> hmm...
18:10:23 <copumpkin> fracture: then use hmatrix or hmatrix-static
18:10:26 <fracture> oh
18:10:27 <fracture> ok
18:10:40 <copumpkin> that's basically BLAS/LAPACK bindings
18:10:41 <fasta> fracture, hmatrix is gpl, which is why I asked.
18:10:48 <fracture> ah, nah don't care about that
18:10:56 <copumpkin> that is frustrating :/
18:11:27 <manju> Jonno_FTW: I have finished 8 problems in projecteuler, but I am stuck with work
18:11:32 <evolio_> manju, i'm just googling and am using the wikibooks for reference
18:11:35 <scalaLove> I am thinking why : and ++ exist as separate operators. Sometimes you just want to add one element to a list and if u use ":" and it notices more then one element is added signals error. Might be desired behaviour in some cases yes. But still I think it is not intuitive to have two operators for adding to a list, what do you guys think?
18:11:38 * copumpkin got tired of project euler
18:11:45 <manju> evolio_: learn you a haskell is good
18:11:48 <Jafet> scalaLove, what are the types of (:) and (++)?
18:11:50 <copumpkin> scalaLove: the first is fundamental
18:11:57 <manju> evolio_: also hutton is good
18:11:57 <ray> evolio_: no 'n' on the lhs
18:12:22 <ray> also, you probably don't want [a]
18:12:33 <copumpkin> scalaLove: (:) is the constructor of lists, ++ is a function that concatenates them
18:12:36 <Jonno_FTW> i have 49 problems on project euler done
18:12:37 <evolio_> ray, of course
18:12:42 <ray> also, you probably want to just use replicate directly
18:12:48 <copumpkin> scalaLove: so (:) forms the fundamental structure of a list
18:12:52 <fracture> Statically-dimensioned 2D matrices.
18:12:53 <evolio_> i now get a Occurs check: cannot construct the infinite type: a = [a] error
18:12:54 <copumpkin> (along with [])
18:12:59 <fracture> that ... is a weird sentence :)
18:13:06 <evolio_> ray i'm aware but i like breaking each bit into its own function
18:13:06 <fracture> lib description, whatever
18:13:10 <evolio_> so i can test as i go along
18:13:10 <ray> if it's small, anything's probably good
18:13:20 <ray> whoa, lag
18:13:37 <Jonno_FTW> http://projecteuler.net/index.php?section=profile&profile=Jonno_FTW
18:13:37 * copumpkin is tempted to @remember ray if it's small, anything's probably good
18:13:53 <ray> evolio_: yeah, but renaming replicate doesn't get you anything
18:14:08 <scalaLove> Jonno_FTW how much time it took you to solve 49?
18:14:08 <evolio_> this is true
18:14:14 <Jonno_FTW> ahhh
18:14:26 <Jonno_FTW> i have been doing haskell for about 3 months now
18:14:38 <fasta> evolio_, have you considered that it might be useful to think a few minutes about what is wrong before you ask?
18:14:40 <copumpkin> wow, they've added so many problems since I last tried it
18:14:54 <evolio_> i've got it sorted now
18:15:00 <Jonno_FTW> make that 5 months
18:15:02 <manju> Jonno_FTW: wow
18:15:06 <Jonno_FTW> yeah
18:15:12 <Jonno_FTW> i was doing school
18:15:13 <fasta> fracture, Vec does that.
18:15:15 <scalaLove> Jonno_FTW, 5 months for 49 problems?
18:15:21 <Jonno_FTW> yep
18:15:24 <copumpkin> http://projecteuler.net/index.php?section=profile&profile=int-e
18:15:43 <copumpkin> you can tell when he stopped trying the problems :P
18:15:46 <Jonno_FTW> wow
18:16:20 <fracture> fasta: does what?
18:16:25 <Jonno_FTW> i did one in excel when i was really new to haskell
18:16:32 <Jonno_FTW> and one on my TI-83
18:16:36 <fasta> fracture, Statically-dimensioned 2D matrices.
18:16:46 <fracture> fasta: oh; I was just making fun of the phrasing
18:17:37 <manju> who is int-e ?
18:17:37 <copumpkin> manju: he's in this channel :P
18:17:42 <manju> oh ?
18:17:44 * copumpkin waves at int-e
18:17:44 <ivanm> preflex: seen int-e
18:17:44 <preflex>  int-e was last seen on #ghc 2 days, 16 hours, 35 minutes and 15 seconds ago, saying: twice - the terminfo problem is more recent than the other one.
18:18:09 <copumpkin> manju: there are several haskellers (none of them on IRC afaik) in the top 100
18:18:21 <Jonno_FTW> yep
18:18:27 <manju> top 100 ?
18:18:29 <Jonno_FTW> because haskell is excellent for project euler
18:18:36 <copumpkin> I think I'm just under 100
18:19:03 <evolio_> ok, i'm stuck again. and yes i have thought about it. i'm trying to concat a replcate then use take
18:19:04 <copumpkin> 100 problems that is, not rank :)
18:19:10 <manju> http://projecteuler.net/index.php?section=scores&level=6
18:19:24 <manju> no there are haskellers in the rank too
18:19:37 <manju> there is a GeneralRetard
18:19:43 <copumpkin> I meant, I'm just under 100, not rankwise
18:19:53 <fasta> manju, if I go to that URL, I just go to the home page.
18:20:01 <manju> ah...copumkin :-)
18:20:11 <manju> fasta: me too
18:20:12 <ray> > concat $ replicate 5 "lol"
18:20:12 <copumpkin> fasta: you need to have an account and be logged in :/
18:20:13 <lambdabot>   "lollollollollol"
18:20:27 <manju> fasta: oh..that way you need to login
18:20:29 <Jonno_FTW> i do believe this was a question in LYAH
18:20:39 <fasta> copumpkin, a year ago that wasn't the case.
18:20:54 <copumpkin> I wonder why they changed it
18:21:00 <fasta> "Oh, we are really popular now". Let's annoy the users!
18:21:19 <ray> "let's force registration!"
18:21:20 * therp wants to solve problem 160 for about year.
18:21:45 * therp should try harder :). the first five attempts failed 
18:21:50 <Jonno_FTW> http://projecteuler.net/index.php?section=scores&language=Haskell
18:22:35 <ray> like i'd remember my stupid project oyler login
18:22:40 <Jonno_FTW> hmm
18:22:46 <copumpkin> damn, I'm not even on the first page! :P
18:23:23 <Jonno_FTW> 160 solution might be
18:23:26 <evolio_> ray, how can i do that without hte $
18:23:42 <copumpkin> g'night!
18:24:01 <therp> jonno: no don't give it away with a one-liner or so
18:24:33 <manju> atleast I am not on the last page
18:24:36 <Jonno_FTW> take 5 $ show reverse $ foldl' (*) 1 $ enumFromTo 1 1000000000000
18:24:42 <Jonno_FTW> time for work
18:24:46 <Jonno_FTW> woops
18:24:54 <Jonno_FTW> i was busy writing and didn't see you there
18:25:14 <Jonno_FTW> perhaps i'll see now
18:25:22 <therp> jonno: well, that doesn't work complexity-wise
18:25:32 <ray> evolio_: just use parentheses
18:25:53 <Jonno_FTW> hmm
18:25:55 <Jonno_FTW> g2g
18:26:07 <therp> (10^16)! doesn't fit into ram I'd say.
18:26:23 <therp> (without doing the "math")
18:27:03 <ray> are you finding the last digits of a factorial or something?
18:27:23 <Jafet> The first digits are also probably findable
18:27:30 <ray> there's well known algorithms for that
18:28:21 <fasta> therp,  Why exactly do you work on Project Euler? It are all problems that have already been solved.
18:28:34 <fasta> therp, do you just want to rediscover the algorithms?
18:28:41 <Jafet> It's the nerd equivalent of going to the gym
18:28:46 <therp> fasta: of course
18:28:59 <therp> Jafet: thanks that's a brilliant metaphor :)
18:29:06 <Jafet> I hate gyms.
18:29:32 <fasta> therp, so, you want a problem that has been solved already to give you the comfort that a solution exists.
18:29:59 <medfly> he just wants some brain mas... exercise
18:29:59 <Jafet> fasta, the website keeps score and compares yours to others'.
18:30:10 <Jafet> So you can size yourself up.
18:30:31 <fasta> Jafet, if it is just about scoring, you would just gather all the papers for a problem, read them, and implement it.
18:30:42 <fasta> Jafet, it doesn't show any kind of skill.
18:30:49 <medfly> not really... people usually try to figure out ways to do things themselves.
18:30:53 <therp> fasta: interesting point.. I guess it is not about comfort, it's about motivation. To know, that it is possible prevents you from slipping into the idea that it can't be done
18:30:58 <scalaLove> once you define a tuple you cant add to it? like 1 : (2,3)
18:30:58 <Jafet> It does. Just not the kind that really matters to some.
18:31:10 <Jafet> scalaLove, what is the type of (:)?
18:31:22 <Jafet> scalaLove, is that a difficult question?
18:31:26 <fasta> scalaLove, read the language report.
18:31:39 <fasta> scalaLove, especially, if your name is scalaLove.
18:31:46 <scalaLove> it is type that gets list as input, but how do i add element to tuple
18:31:46 <Cale> scalaLove: (2,3) is a tuple, and (:) wants a list as its second parameter
18:31:54 <Cale> scalaLove: By making another tuple
18:32:02 <scalaLove> so they are fixed, i see
18:32:14 <therp> fixed?
18:32:26 <Cale> Essentially everything is :)
18:32:29 <medfly> scalaLove, this is Haskell. everything is.
18:32:44 * medfly licks Cale
18:33:01 <Jafet> scalaLove, you seem to have very little idea of what Haskell is all about...
18:33:03 <scalaLove> lists are not
18:33:13 <Cale> scalaLove: Lists are too
18:33:14 <medfly> scalaLove, you create a new list, you don't modify it.
18:33:21 <scalaLove> Jafet actually i, yes it is pure
18:33:42 <ray> as for types, tuples of different size are different types entirely
18:33:54 <scalaLove> yes i know that, why dont they allow me to make a new tuple then same as you can add to lists?
18:34:11 <scalaLove> ray i know that
18:34:20 <Jafet> scalaLove, your previous remarks show that you don't really understand what purity is.
18:34:22 <therp> so you want to 1:(2,3)=(1,2,3) ?
18:34:30 <Cale> scalaLove: However, there is truth in that... when you form the list x : xs, the structure of xs is shared and reused in your new list. When you make a 3-tuple by taking apart a 2-tuple and reusing the elements to make a 3-tuple, there's no sharing of structure (except the elements of course)
18:34:32 <ray> you could write a specific function
18:34:32 <scalaLove> yes
18:34:46 <Cale> However, what you *can* do is to simply make a pair of pairs.
18:34:50 <therp> scalaLove: probably you want to go for lists not tuples, there you have 1:[2,3]=[1,2,3]
18:34:50 <Cale> (1,(2,3))
18:34:59 * Jafet wheels in the HLists
18:35:12 <medfly> HASKELL SUCKS, IT CAN'T ADD ANOTHER ELEMENT TO A TUPLE LIKE THAT
18:35:24 <Cale> If you find yourself using tuples much larger than pairs, you shouldn't be using tuples anyway.
18:36:04 <Cale> You almost always will be better off defining a new datatype which represents the values you're working with -- possibly with named fields.
18:36:07 <Jafet> I haven't really encountered tuples a lot outside @pl output
18:36:25 <medfly> have you encountered many DiffArrays?
18:36:32 <scalaLove> but lists are limited, i can have same types inside only... what if i want different types together and add and remove, i guess i should make my own functions for tuples
18:36:36 <Jafet> Well, no
18:36:37 <Cale> Does @pl ever introduce tuples where there were none?
18:36:38 <medfly> that's because tuples are a pita to use.
18:36:47 <Jafet> I think so, Cale
18:36:56 <therp> I wonder if some professors give their students project euler problems to solve as homework
18:36:57 <Jafet> With curry and uncurry
18:37:01 <Cale> scalaLove: You will not find the type restriction on lists an inconvenience in practice.
18:37:16 <medfly> therp, they'd be really easy to look up then.
18:37:29 <therp> medfly: hmm. true :/
18:37:32 <Jafet> scalaLove, types represent the intentions of your code. Think about creating or adapting types that properly reflect your intentions.
18:37:42 <Jafet> This is not Java, where you have to hack around the object system to express anything
18:37:57 * medfly used to find out whether the solution is right by googling "project euler <result>"
18:37:57 <fasta> scalaLove, use HLists if you really want.
18:38:15 <fasta> scalaLove, but if you want those kinds of things, you are better off using a language with built-in support for that.
18:38:16 <scalaLove> HLists?
18:38:17 <Cale> scalaLove: This is because you usually want to operate uniformly on lists, and in order to do that, you need to know that the elements of your list have something in common. When the elements you want to put in the list have something in common, you can invent a datatype which reflects what that is.
18:38:54 <fasta> scalaLove, there is this thing called a search engine, you might have heard of it?
18:38:56 <Jafet> Or use a different data structure
18:39:11 <scalaLove> fasta what do mean
18:39:21 <fasta> @google HList haskell
18:39:23 <lambdabot> http://okmij.org/ftp/Haskell/types.html
18:39:23 <lambdabot> Title: Haskell Programming: Types
18:39:31 <fasta> Oh, look, it works.
18:39:54 <therp> fasta: don't be so mean, all of us have asked stupid questions sometimes
18:40:02 <ray> someone didn't have a nutritious breakfast today
18:40:07 <scalaLove> fasta yeah man but i cant go that detailed, i asked here just to get a general overview man, i am not ready to read all that
18:40:16 <Jafet> scalaLove has asked several stupid questions over quite some time here, though, which is mildly annoying
18:40:21 <scalaLove> i am reading beginner books in haskell now
18:40:27 <Cale> scalaLove: Yeah
18:40:36 <Cale> scalaLove: It's safe for you to ignore HLists.
18:40:52 <ray> it's safe for you to ignore anything by oleg for now, probably
18:41:00 <therp> Jafet: I don't think so. #haskell is popular because it is ok to ask stupid questions :)
18:41:08 <Cale> scalaLove: It's a library for typed heterogeneous lists in Haskell -- basically fancy tricks stacked on top of making lists out of 2-tuples.
18:41:24 <Jafet> HLists aren't standard haskell, anyway
18:41:30 <Cale> Jafet: oh?
18:41:33 <napsy> Hello. I'm trying to creat a funcion that returns an array of random numbers. The problem is I can't get [Int] from IO Int. Any ideas? http://haskell.pastebin.com/mdebc0af
18:41:37 <scalaLove> second day in haskell i solved #5 euler so ... those stupid questions lead me somewhere in a week i will know more then any of you here :)
18:41:39 <Cale> They just need some GHC extensions.
18:41:42 * therp would hate to see #haskell turn into #lisp where you get flamed when you can recite the hyperspec drunk at 3am in the morning
18:41:48 <Jafet> Ah, you pick the standard.
18:41:53 <Jafet> Good point
18:42:03 <integral> napsy: you can get IO [Int] from IO Int though
18:42:26 <Cale> Jafet: Haskell 98 is mostly irrelevant, and the new standard doesn't do much better :P
18:42:56 <therp> cale: which new standard?
18:42:58 <Cale> napsy: do xs <- replicateM 100 foo; ... use xs here ...
18:43:14 <ray> h10
18:43:17 <Cale> therp: 2010
18:43:40 <napsy> Cale: um I don't uderstand
18:43:51 <therp> ah the output of haskell prime, I see
18:44:06 <ray> well, this year's output at least
18:44:15 <ski> napsy : either you need to say `getThresomeRnd :: IO [Int]' or `getThresomeRnd :: RandomGen g => g -> [Int]' or similar
18:44:18 <ray> allegedly, they'll have an annual revision
18:44:35 <napsy> ski: ok I'll try both
18:44:43 <Cale> napsy: There's a function in Control.Monad called replicateM which, given a number and an action, produces an action which when run, will run the given action the given number of times, producing a list of the results
18:44:57 <napsy> oh
18:45:22 <ski> napsy : every haskell function (even value) is deterministic, if you want it to be able to give different random values, then you have to be able to provide it with different input (either explicitly or implicitly)
18:45:27 <Cale> napsy: So, for instance,  replicateM 10 getLine  will, when run, get 10 lines of text from the user, and give a list of the lines
18:45:43 <napsy> interesting
18:46:06 <Cale> napsy: You can run IO actions inside other IO actions using the do-notation.
18:46:15 <fasta> scalaLove, by your nickname I got the impression that you wanted to market Scala.
18:46:15 <napsy> so (a1, a2, n) = replicateN 10 randomRIO (1, 100 :: Int) should work?
18:46:25 <napsy> *replicateM
18:46:32 <ski> napsy : so if you're saying `getThresomeRnd :: [Int]' that would mean that `getThresomeRnd' is always the same list of `Int's .. so if it e.g. is `[6,28,496,8128]', then it will always be that list ..
18:46:37 <Cale> napsy: not quite
18:46:41 <Cale> napsy: Inside a do-block, the line  v <- x  means to run the action x producing the result v
18:46:41 <ski> (.. which i assume is not what you were after)
18:46:49 <Cale> napsy: If x :: IO t, then v :: t
18:47:12 <Cale> napsy: The do-block as a whole will have type IO s for possibly some other type s
18:47:21 <napsy> ok
18:47:31 <ski> napsy : also, if you name `Int' in the type signature, then you don't need any of the `:: Int' you have there
18:47:42 <Cale> napsy: You can think of values of type (IO t) as being descriptions of stuff that could be done to produce a value of type t
18:48:06 <Cale> :t randomRIO
18:48:07 <lambdabot> forall a. (Random a) => (a, a) -> IO a
18:48:23 <Cale> So,  randomRIO (1, 100 :: Int) :: IO Int
18:48:43 <Cale> and then  replicateM 10 (randomRIO (1, 100 :: Int)) :: IO [Int]
18:48:59 <napsy> ok I'll try that
18:49:02 <Cale> and then to run the action to get the list of results, inside a do-block you will write
18:49:11 <Cale> xs <- replicateM 10 (randomRIO (1, 100 :: Int))
18:49:16 <Cale> and xs :: [Int] then
18:49:55 <Cale> and you can then pass that list to some pure functions or transform it in some way in order to do some output perhaps
18:50:17 <Cale> A simple way to continue might be just to print the list
18:50:19 <Cale> print xs
18:50:36 <Cale> :t do xs <- replicateM 10 (randomRIO (1, 100 :: Int)); print xs
18:50:37 <lambdabot> IO ()
18:50:47 <ski> @hoogle MonadRandom
18:50:48 <lambdabot> No results found
18:51:09 <napsy> well it compiles now
18:53:18 <Cale> napsy: By the way, ski pointed this out, but just to reiterate, in your definition of getThresomeRnd, you don't need to write Int over and over. You just need to put it in one place so that the compiler can work out what type of random thing to generate somehow.
18:53:44 <napsy> huh lots of information
18:53:48 <napsy> I'm kinda new to haskell
18:54:14 <napsy> but thanks both of you for the explanations
18:59:42 <manju> http://www.reddit.com/r/AskReddit/comments/abut8/anyone_stuck_on_reddit_when_they_should_be/
18:59:57 <manju> danm...I still have nightmares about exam week
19:00:05 * manju shudders
19:01:13 <manju> is I have a list of lists, how can I flatten the list ?
19:01:28 <manju> or is there a function to flatten a list
19:03:12 <dibblego> join or concat
19:03:20 <dv-> @hoogle [[a]] -> [a]
19:03:21 <lambdabot> Prelude concat :: [[a]] -> [a]
19:03:21 <lambdabot> Data.List concat :: [[a]] -> [a]
19:03:21 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:04:07 <scree> @src concat
19:04:07 <lambdabot> concat = foldr (++) []
19:07:11 <tombee> Is it normal to just have no idea whatsoever how to solve trivial problems in haskell as a beginner? :p
19:07:54 <scalaLove> tombee no man, i solved problems in haskell the second day with it
19:08:22 <scalaLove> use the book as reference and translate your pseudo code to haskell
19:08:30 <tombee> pack (x:xs) = (x:first) : pack rest
19:08:42 <tombee> What does that even mean?
19:08:59 <manju> tombee: yeah it is normal
19:09:13 <manju> if you came from an absolutely no fp background
19:09:17 <tombee> Create a list ' x:first:pack rest '
19:09:25 <tombee> what is 'first?'
19:09:26 <tombee> heh
19:11:24 <manju> is it like pack (x:xs) = x : pack xs
19:12:14 <tombee> dunno, I run ghc on it and says first/rest isnt defined
19:12:29 <manju> yes and xs is not being used
19:12:35 <Lemmih> tombee: Where did you find the code?
19:12:41 <manju> context ?
19:13:07 <tombee> Think its problem 8 on that '99 problems' site
19:13:23 <ray> i've got 99 problems but finding primes ain't one
19:13:25 <manju> tombee: link ?
19:13:31 <tombee> http://haskell.org/haskellwiki/99_questions/1_to_10
19:13:36 <tombee> Problem 9
19:14:13 <Lemmih> tombee: The stuff after 'where' is Haskell code as well.
19:14:35 <tombee> Just noticed the last line yep
19:15:12 <tombee> The first solution is very obscure
19:15:38 <Lemmih> tombee: Are you familiar with 'span'?
19:15:49 <tombee> Just reading it now
19:18:31 <manju> if the condition (==x) is satisfied then first is added to to list with x on the subsequent call and so forth
19:18:34 <manju> x:first
19:19:18 <manju> add first to with x, and then call with same pack function recursively with tail as the argument
19:19:35 <tombee> yeah I guess I understand it, but if i was asked to write that, I'd have no idea ;)
19:19:52 <manju> tombee: are you doing eulerproject.net ?
19:19:59 <tombee> Nope?
19:20:12 <manju> tombee: that is supposed to be a good place to start
19:20:22 <manju> I am learning haskell by doing the code on there
19:20:26 <manju> er...problems
19:20:43 <manju> it is helping...
19:21:01 <manju> I guess you need to get familiar with the tricks of the trade, so to say
19:21:19 <quicksilver> well, project euler is really about maths (or problem solving) not about programming
19:21:28 <scalaLove> how can i destroy  current  bindings in haskell interpreter?
19:21:35 <manju> yes...but it is something to chew on
19:21:38 <quicksilver> so if you find the maths/ problem solving part quite hard, that may be a distraction from the business of learning haskell.
19:21:49 <quicksilver> also it gives you a rather mathsy focus on your language learning
19:21:55 <manju> quicksilver: yes...
19:21:59 <quicksilver> scalaLove: in ghci, the only way is by loading a new file.
19:22:04 <medfly> on the other hand, if you're that poor at mathematics, you should meet me at ##php
19:22:06 * scree did exactly that about 4 years ago and can now nearly code haskell
19:22:15 <quicksilver> (which resets all bindings)
19:22:24 <manju> medfly: there are hard problems on there
19:22:27 <medfly> :)
19:22:27 <quicksilver> I find the maths / problem solving part of project euler very boring
19:22:31 <quicksilver> but that's just me :)
19:22:48 <scree> they vary an awful lot
19:22:55 <medfly> (I am aware, I just meant that if you can't do any...)
19:23:15 <scalaLove> quicksilver: that is anoying isnt it? I write in text editor in ubuntu, and have ghci in terminal, as i make changes to file i load it, now i will have to create a new file for each change i make?
19:23:28 <manju> well if you can't do any then maybe learning high school math is a good start :-)
19:23:43 <manju> scalaLove: :l ?
19:23:58 <medfly> scalaLove, :re
19:24:39 <scalaLove> i do :r but some bindings stay
19:25:27 <quicksilver> scalaLove: I think you're wrong.
19:25:33 <quicksilver> if you do :r, no bindings stay.
19:25:51 <scalaLove> oki lets hope it is so
19:25:57 <quicksilver> (certainly you don't have to create a new file for each change, that would indeed be ridiculous)
19:26:10 <scalaLove> for this for example f x = case x of {0 -> 1; 1 -> 2; _ -> (-1)}
19:26:56 <scalaLove> i got errors like x not in scope, and when i change x to y and f to g it worked
19:27:12 <quicksilver> no, you did something else wrong.
19:27:22 <quicksilver> changing x to y and f to g will never change anything.
19:27:36 <quicksilver> x there is a local variable.
19:39:14 <scalaLove> 5 :: (Num t) => t ----------------------- This means 5 is of type Num t => t, which means Num is a type class and t is the argument, but what is the => t part for?
19:40:19 <int-e> scalaLove: the syntax is  context => type. the Num t is a context and means that t is an instance of Num; the t is the type of the expression.
19:40:36 <quicksilver> scalaLove: so, 5 has type "t", subject to the constraint (Num t)
19:40:36 <int-e> @type (+)
19:40:38 <lambdabot> forall a. (Num a) => a -> a -> a
19:41:26 <scalaLove> damn I try to understand this third time and i cant, ok i will keep reading the book
19:41:33 <int-e> maybe a less degenerate example is more useful here - in the type of (+), we see that (+) has type a -> a -> a, i.e. a function that takes two values of type a and returns another value of the same type, a. And the context says that a is an instance of Num.
19:45:51 <sohum> :t undefined -- < scalaLove, see this
19:45:53 <lambdabot> forall a. a
19:46:21 <sohum> forall a. a is different from Num a => a precisely because of the context
19:46:48 <quicksilver> well you may choose to ignore the 'forall'. And we may all choose to insult lambdabot for confusing us by putting it there.
19:47:02 <quicksilver> the haskell98 type of 'undefined' is simply 'a'
19:47:06 <sohum> (foralls are (almost) never needed, so "forall a. a" == "a")
19:47:29 <scalaLove> a. a what is that dot there?
19:47:44 <sohum> it's the separater when you have qualifiers
19:47:46 <quicksilver> ignore the dot and everythign to the left of the dot
19:47:50 <quicksilver> the type is simply a
19:47:53 <sohum> so forall a <separator> a
19:47:59 <sohum> or exists a <separator> a
19:48:30 <ray> there is no exists :(
19:48:44 <sohum> really? I thought it was a keyword...
19:48:47 * sohum shrug
19:49:20 <sohum> basically, "forall types I can call a, a". Since you can call all types a, that means undefined has any type.
19:49:42 <quicksilver> there is no exists and there is no forall
19:49:46 <quicksilver> lambdabot is a dirty liar.
19:50:15 <sohum> for 5, it's "forall types that have a Num instance that I can call a, a."
19:50:27 <sohum> so 5 has the type of any numeric type
19:50:31 <sohum> *has any numeric type
19:52:10 <dv-> i have a question that's been on my mind for a while... why doesn't backspace work on the ghci prompt?
19:52:13 <sohum> quicksilver: why the hate?
19:52:17 <quicksilver> because your ghci is broken.
19:52:29 <quicksilver> sohum: I hate changes to lambdabot which mean it doesn't describe haskell
19:52:35 <quicksilver> sohum: because this channel is about teaching haskell.
19:52:36 <sohum> dv-: it should work. something's broken, then
19:52:51 <dv-> sohum: I just get ^?^?^?^?^?^?
19:52:57 <int-e> dv-: which ghci? is this the editline problem?
19:53:02 <ski> quicksilver : yes, GHCi ought to not show outermost `forall's when inferring types
19:53:08 <quicksilver> (even though the forall extension is fairly innocent, it still confuses you if you're looking at other reference works / ghci)
19:53:14 <sohum> quicksilver: but what's the difference between forall a. a and a?
19:53:19 <dv-> int-e: i'm using ubuntu's 6.10.1
19:53:25 <quicksilver> sohum: "a" is haskell. "forall a . a" is some other made up language.
19:53:35 <ski> sohum : the latter is an open type expression, the former isn't
19:53:45 <quicksilver> there is "forall" keyword in haskell.
19:53:54 <sohum> dv-: ...oh, that's weird. the ghc package in the ubuntu repos should work?
19:53:56 <ski> s/is/is no/
19:53:59 <quicksilver> "x :: forall a . a" is a syntax error
19:54:02 <quicksilver> thanks ;)
19:54:06 <quicksilver> is no, indeed.
19:54:22 <Kim^Walkman1> dv-: Does ^H work?
19:54:32 <sohum> :t undefined :: forall a. a
19:54:33 <lambdabot> forall a. a
19:54:33 <quicksilver> sohum: it's a GHC extension to have a forall keyword. It's useful and all, but it's annoying when you're trying to explain things and it gets in the way.
19:54:43 <sohum> aaaah
19:54:43 <quicksilver> sohum: as I said, lambdabot doesn't speak haskell.
19:54:44 <sohum> I see
19:54:47 <quicksilver> that is the source of my complaint.
19:54:49 <zygoloid> quicksilver: i find it disappointing that ScopedTypeVariables isn't part of Haskell2010
19:54:54 <quicksilver> lambdabot has a rag-tag bunch of extensions turned on.
19:54:59 <quicksilver> zygoloid: yes, a baffling omission.
19:55:00 <dv-> Kim^Walkman1: ^H?
19:55:09 <Kim^Walkman1> dv-: CTRL + H
19:55:16 <quicksilver> zygoloid: still, let's hope with the rapid language development process we can get it in '11 ;)
19:55:32 <dv-> Kim^Walkman1: oh right. no. It just echoes ^H
19:55:35 <sohum> I don't like the rapid philosophy
19:55:39 <zygoloid> so, only a year of lambdabot's "forall a." lies to put up with ;-)
19:56:06 <sohum> it means that in, say, 2020, you've got to choose which one of 2014-2019's editions to comply to
19:56:09 <dv-> Kim^Walkman1: this isn't a new problem. I've been using ghci for years and backspace has never worked
19:56:15 <dv-> my solution has been to just get really good at typing correctly :)
19:56:23 <Kim^Walkman1> Ouch
19:56:26 <Jafet> ghci uses readline, doesn't it
19:56:28 <sohum> and the differences are minor and will be hard to remember
19:56:32 <zygoloid> i quite like that \b has ImplicitParameters enabled to be honest -- but that doesn't (often) make a difference unless you want to use it
19:56:47 <scree> dv-: sure sounds like the editline problem
19:57:00 <int-e> Jafet: not since 6.10. 6.10.1 switched to editline, which was generally regarded as a bad move; 6.10.4 switched to haskeline.
19:57:27 <int-e> or is it libedit, I'm lost in that forest of forks.
19:57:30 <sohum> where if you have big releases, then there are clear differences between each edition. Less mental overhead when choosing which version to comply to, and less arbitary "why'd he pick 2013 when 2012 works just fine?" decisions
19:57:34 <dv-> scree: i guess. it's just weird that it persists for so long
19:57:46 <Jafet> Well, I just use the emacs keys and it works for me
19:58:04 <quicksilver> sohum: I don't think it's a big problem as long as "most" things are both forward and backward compatible.
19:58:10 <quicksilver> sohum: (and I believe that will be the case)
19:58:24 <quicksilver> but we will see.
19:58:48 <scree> int-e: 6.10.4 here and haskeline not installed
19:59:35 <int-e> dv-: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/015935.html may help
19:59:36 <Raevel> you need to add a few bindings to .haskeline to get 6.10.4 (iirc) to behave properly
20:01:00 <Raevel> though backspace works out of the box for me, i only added bindings for C-p and C-n
20:01:10 <dv-> int-e: i'll try that. thanks
20:01:34 <int-e> scree: it's still using haskeline, it just doesn't install the library.
20:01:53 <sohum> quicksilver: basically, the more versions you have, the less people are going to check what breaks when, and the less they'll remember about what breaks when
20:02:09 <sohum> of course, it's not a black or white decision
20:02:18 <sohum> but 1/yr is too many
20:02:47 <scalaLove> For newbies like me, this is from a book, just to share it :  By this time you should be in the habit of thinking "What type is that function?" about every function you come across.
20:03:10 <scree> int-e: aha
20:03:23 <scree> int-e: that would explain why I couldn't find any sensible dependencies :)
20:03:54 <sohum> scalaLove: yep. the types are /incredibly/ useful documentation.
20:03:56 <sohum> :t map
20:03:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:04:09 <sohum> @djinn (a -> b) -> [a] -> [b]
20:04:09 <lambdabot> Error: Undefined type []
20:04:16 <sohum> wait really?
20:04:30 <quicksilver> sohum: in my experience it is already the case that a quantity of code requires the latest GHC version
20:04:55 <quicksilver> sohum: that just makes it hard for other implementations to be useful.
20:05:10 <quicksilver> sohum: at least with actual language standards to target we might have something more useful to say than "requires GHC 6.10.4"
20:05:31 <quicksilver> (although to be honest until some other implementation has a reasonable implementation of concurrency, GHC has a big lead)
20:06:07 <|Jedai|> sohum: djinn is a little bit limited, it don't know a lot of types
20:06:08 <sohum> quicksilver: true, but I'm thinking of the case when, say, in 2015, someone releases code that "requires 2014" but works fine on 2013, just because it's the latest, and most nonghc implementations haven't supported 2014 yet.
20:06:29 <sohum> |Jedai|: I see a transcript where it understands []?
20:07:14 <scalaLove> guys what reference do you use for haskell commands?
20:07:24 <|Jedai|> sohum: maybe some versions do, but apparently, not the one that is in the lambdabot currently on the channel
20:07:26 <nlogax> commands?
20:07:46 <|Jedai|> scalaLove: you mean GHCi ? Just type ":help" at GHCi promp
20:07:49 <|Jedai|> *t
20:07:57 <sohum> quicksilver: if you have both actual language standards and larger gaps between them... then "the latest" can equal what is really necessary more often
20:08:16 <sohum> scalaLove: or maybe you want to know hoogle?
20:08:25 <sohum> @hoogle a -> m a
20:08:26 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
20:08:27 <lambdabot> Prelude return :: Monad m => a -> m a
20:08:27 <lambdabot> Control.Monad return :: Monad m => a -> m a
20:08:36 <scalaLove> hoogle?
20:08:45 <sohum> @hoogle concatMap
20:08:45 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
20:08:46 <lambdabot> Data.ByteString concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
20:08:46 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
20:08:57 <sohum> haskell google :P
20:09:20 <|Jedai|> scalaLove: hoogle is a search engine on Haskell function that can search for a name but also for a type (and it does some unification), it's pretty useful
20:09:42 <sohum> the website version has links to the documentation for the functions, too
20:09:46 <ray> @where hoogle
20:09:46 <lambdabot> http://haskell.org/hoogle
20:09:49 <|Jedai|> @hoogle (Functor f) => (a -> b) -> f a -> f b
20:09:50 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:09:50 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
20:09:50 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
20:10:36 <ray> @hoggl m (m a) -> m a
20:10:37 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
20:10:37 <lambdabot> Prelude concat :: [[a]] -> [a]
20:10:37 <lambdabot> Data.List concat :: [[a]] -> [a]
20:10:37 <scalaLove> hoogle, woow now that is exactly what i search for, wish there was similar for scala
20:12:27 <sohum> |Jedai|: http://lambda-the-ultimate.org/node/1178 :P
20:15:06 <|Jedai|> sohum: Right, and it then say (in one of the comment) that Djinn doesn't know lists. So apparently djinn has been "improved" since then so that it signal when it don't know a type and don't just treat it like a type variable.
20:16:00 <sohum> aah, I see
20:25:59 <tombee> What editors are recommended for writing Haskell?
20:26:16 <tombee> to run on windows
20:26:28 <Stinger> cue religious war
20:26:37 <ray> HOLY WAAAAAAAAAAAAARS
20:26:42 <ray> *riff*
20:26:53 <tombee> I can't help it, I'm forced to use Windows at work :)
20:27:00 <ray> you realize you said "which editor should i use" AND mentioned windows
20:27:18 <ray> you have been transported to jerusalem at the time of the third crusade
20:27:23 <osfameron> could also have said "to write ocaml"
20:27:23 <tombee> :(
20:27:30 <ray> i use notepad
20:27:35 <osfameron> tombee: any.  But try using a good one ;-)
20:27:39 <ray> i'm not going to make any moral comments, that's just what i use
20:27:48 <ray> notepad and powershell
20:27:49 <osfameron> gvim, emacs, one of the notepad+ type editors
20:27:50 <Stinger> you are a bad person ray
20:28:15 <osfameron> powershell sounds fun.  notepad less so
20:28:24 <osfameron> though it recently gained a feature didn't it?  (line numbers)
20:28:27 <sohum> eeemaaaacs
20:28:38 <tombee> emacs and vim on windows though?
20:28:47 <CalJohn> emacs does work on windows
20:28:47 <tombee> Can this really be a sensible idea? :)
20:28:56 <osfameron> tombee: gvim works very well on windows.  I believe emacs can do too.
20:29:00 <byorgey> sure, I used to use emacs on windows
20:29:02 <ivanm> emacs is my preferred editor when I'm forced to use the OS from Redmond...
20:29:39 <Stinger> I should look at powershell, windows command line sucks
20:30:26 <sohum> powershell is verboooose
20:30:32 <sohum> but I love the idea behind it
20:30:39 <osfameron> yarr
20:30:48 <osfameron> I still don't get why people aren't more excited about it
20:30:51 <Stinger> hmm I don't like verboseness
20:31:01 <osfameron> i talked about it at the london perl workshop on saturday
20:31:01 <ivanm> is powershell the official name of what was going to be called MONAD?
20:31:13 <sohum> unfortunately, to really work, you need the language to be basically what your userland lives in
20:31:14 <osfameron> yeah
20:31:35 <sohum> or write an unbounded number of translation layers
20:32:18 <sohum> osfameron: a better unified information exchange format than text, basically
20:32:22 <osfameron> I suspect one can write a good-enough-to-be-useful version that interfaces nicely with bash-land
20:33:02 <sohum> yea, but you/your users would have to write new wrappers for every new command
20:33:11 <sohum> and unless there's some sort of global standard
20:33:22 <osfameron> sohum: well indeed.  There has to be a standard, basically
20:33:30 <osfameron> because eventually you stop piping objects between commands
20:33:35 <osfameron> and just pretend to do that
20:33:43 <sohum> translating from one object hierarchy to another is just as involved, if not more, than munging text
20:34:19 <osfameron> I got as far as:  newFind | newGrep '$_->stat->size > 1000'
20:34:33 <osfameron> which is quite cute but... yeah.. there's quite a lot of work to do to make it generally useful
20:35:04 <sohum> there's the rush shell, which is along the same lines
20:35:05 <sohum> http://rush.heroku.com/
20:37:21 <sohum> and hotwire
20:37:22 <osfameron> interesting
20:37:33 <sohum> but they all have to translate stuff
20:38:29 <osfameron> you mean to repurpose existing shell commands ?
20:38:37 <sohum> yea
20:38:42 <osfameron> that's unavoidable
20:39:07 <osfameron> you could write a fixed-width command output parser
20:39:08 <sohum> only if you're building on top of an existing layer
20:39:16 <osfameron> that generates a stream of named objects
20:39:43 <sohum> that's part of the reason why powershell works - because microsoft is slowly moving windows to be built on the .NET framework
20:39:45 <osfameron> for example, something that parses the output of ls -ltr, but expressed as a config file
20:39:50 <osfameron> yarr
20:40:05 <osfameron> to do it properly requires writing all the builtins in the framework
20:40:12 <sohum> yerp.
20:40:15 <sohum> and heck, C is /old/
20:40:38 <quuuux> osfameron: surely at that point you no longer have a shell, you have a general-purpose scripting language?
20:40:47 <sohum> osfameron: well, what's the difference?
20:40:51 <sohum> or, rather
20:41:00 <sohum> why should there be a difference?
20:41:25 <sohum> I'd love to see an OS built on, say, Go
20:41:40 <ray> of course there shouldn't be a difference
20:41:40 <osfameron> well, it's not so much of a problem to create a shell command when you have a good set of libraries
20:41:49 <osfameron> this is my reimplementation of 'find': http://github.com/osfameron/pipe/blob/master/lib/Pipe/Command/find.pm
20:42:08 <osfameron> because CPAN has File::Next and Path::Class to do iteration and file encapsulation
20:42:14 <osfameron> I'm sure same applies to haskell of course
20:42:41 <sohum> or heck, even haskell
20:42:51 <sohum> I wonder what an os built on haskell would look like
20:43:02 <osfameron> House, presumably
20:44:13 * sohum explores this thing
20:44:20 <tombee> if I declare a sequence such as
20:44:22 <tombee> fibs = 1 : zipWith (+) fibs (tail fibs)
20:44:34 <tombee> how do I put an upper limit on it, use filter?
20:44:45 <quicksilver> tombee: no, use takeWhile
20:44:49 <quicksilver> filter will run forever
20:44:49 <tombee> ok thanks
20:44:54 <quicksilver> > filter (<5) [1..]
20:44:56 <tombee> thanks :)
20:44:58 <lambdabot>   mueval-core: Time limit exceeded
20:45:08 <quicksilver> ... it is going to spend forever just in case some really big number turns out to be <5
20:45:22 <quicksilver> filter can't take advantage of properties of your specific sequence to short-circuit.
20:45:35 <quicksilver> > takeWhile (<5) [1..]
20:45:37 <lambdabot>   [1,2,3,4]
20:45:59 <ray> > filter (const False) [1..]
20:46:03 <lambdabot>   mueval-core: Time limit exceeded
20:46:08 <ray> or properties of your specific predicate
20:46:42 <quicksilver> indeed
20:48:19 <tombee> thing is, I don't think this works for the fibs list I've used?
20:48:24 <sohum> there doesn't seem to be that much info about house on the web
20:48:24 <tombee> > fibs = 1 : zipWith (+) fibs (tail fibs)
20:48:26 <lambdabot>   <no location info>: parse error on input `='
20:48:49 <ray> > let fibs = 1 : zipWith (+) fibs (tail fibs) in fibs
20:48:53 <lambdabot>   mueval-core: Time limit exceeded
20:48:58 <ray> or just the expression
20:49:11 <tombee> but I can't use takeWhile on that?
20:49:26 <ray> sure you can
20:49:39 <sohum> > let fibs = 1 : zipWith (+) fibs (tail fibs) in takeWhile (<100) fibs
20:49:44 <lambdabot>   mueval-core: Time limit exceeded
20:49:49 <sohum> > let fibs = 1 : zipWith (+) fibs (tail fibs) in takeWhile (<40) fibs
20:49:51 <byorgey> you need two base cases =)
20:49:54 <lambdabot>   mueval-core: Time limit exceeded
20:49:57 <sohum> oh, right
20:49:58 <byorgey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:49:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:50:10 <ray> takeWhile (<100) $ 0 : 1 : zipWith (+) fibs (tail fibs)
20:50:17 <sohum> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<100) fibs
20:50:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89]
20:50:33 <ray> > take 20 $ 0 : 1 : zipWith (+) fibs (tail fibs)
20:50:34 <lambdabot>   Not in scope: `fibs'Not in scope: `fibs'
20:50:40 <ray> oh, right
20:50:44 <ray> i must be drunk
20:50:55 <sohum> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
20:50:56 <lambdabot>  Defined.
20:51:03 <acidjnk> hello
20:51:30 <tombee> > takeWhile (<100) fibs
20:51:32 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
20:51:39 <tombee> interesting
20:51:44 <ray> > dropWhile (<100) fibs
20:51:45 <lambdabot>   [144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,1213...
20:51:51 <ray> hm hm hmmmmm
20:52:18 <tombee> ah, I have to use 0 : 1
20:52:22 * hackagebot upload: haskell-src-exts 1.3.4 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
20:52:52 <tombee> Is there a list of answers to that Project Euler site?
20:52:53 <ray> > getSequenceByID "A000045"
20:52:55 <lambdabot>   Just [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,...
20:54:58 <ray> > description . lookupSequenceByID "A000045"
20:55:00 <lambdabot>   Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) =...
20:59:37 <medfly> tombee, googling gives a lot of people's attempts at thing
20:59:37 <medfly> s
20:59:52 <tombee> It's ok, i've logged in and it lets me check my answers :)
21:16:26 <Veinor> I had a scary dream, someone hold me :(
21:17:38 <Liskni_si> is there any way I can put quickcheck properties for not-exported functions to a separate module?
21:18:09 <zygoloid> tombee: once you get a correct answer you can view the forum page for that question, which has various answers
21:18:23 <tombee> Yep, got it, thanks :)
21:18:44 <tombee> I best stop distracting myself with haskell and do some work :)
21:19:03 <zygoloid> Liskni_si: no, if a function is not exported it can't be seen from other modules.
21:19:19 <Liskni_si> zygoloid: okay, that makes sense, so what would be the recommended way to do it then?
21:20:11 <zygoloid> Liskni_si: well, if you want them separate, i guess you could make a <yourmodulepath>.Internals containing (and exporting) the functions, a <yourmodulepath>.Tests with the tests, and a <yourmodulepath> which only re-exports those functions you want to be visible externally
21:20:56 <Liskni_si> zygoloid: that's a nice idea, thanks :-)
21:21:09 <burp> > fmap length $ getSequenceByID "A000045"
21:21:11 <lambdabot>   Just 39
21:22:05 <zygoloid> i always suspected the fibonacci numbers stopped after a while ;-)
21:24:00 <Veinor> Haha
21:29:47 <osaunders> @hoogle Word32
21:29:47 <lambdabot> Data.Word data Word32
21:32:37 <osaunders> > Word32 4454
21:32:38 <lambdabot>   Not in scope: data constructor `Word32'
21:32:59 <osaunders> > 10 :: Word32
21:33:01 <lambdabot>   10
21:36:04 <paul424> I get stack overflow, its because haskell laziness for certainm what should I do :?
21:36:34 <zygoloid> paul424: paste your code on hpaste.org so we can tell you where :)
21:37:02 <int-e> > fmap last $ getSequenceByID "A000045"
21:37:04 <lambdabot>   Just 39088169
21:37:12 <paul424> no way, my lectureres hangs around in here,this could cause only traubles
21:37:30 <zygoloid> paul424: i think there's a way to get ghci to tell you what it was evaluating when the stack overflowed
21:38:23 <quuuux> paul424: you could try and use the GHCi debugger. Google it, and refer to :help
21:39:58 <zygoloid> paul424: i've found using ghci to debug haskell to be a pretty horrendous experience, so good luck! :)
21:40:47 <quuuux> actually, so long as you've got an idea of where the problem lies, I've found GHCi to be quite a capable debugger. Not so good for exploratory debugging though
21:43:22 <paul424> I know exactly, where the problem lies , the only problem is that in the end it tries to reduce one big function tree with milions of max functions.
21:44:13 <paul424> for small numbers the function  works, but for  n =  10 000 it overflows stack.
21:44:20 <zygoloid> quuuux: i've found it to be poor for any sort of debugging. for instance, trying to locate the stack overflow in "foldl (+) 0 [1000000]". i can :set -fbreak-on-exception, but it still won't tell me where the exception was thrown from
21:44:39 <paul424> brb
21:44:57 <zygoloid> quuuux: :trace <that expression> followed by :history after the trace hits the exception, says "Empty history. Perhaps you forgot to use :trace?"
21:49:18 <osaunders> Hm, I don't know how to do this.
21:49:54 <osaunders> I want to call this function mvAddCh :: Int -> Int -> Word32 -> IO ()
21:50:44 <osaunders> I've got a [[Word32]]
21:50:47 <zygoloid> quuuux: when it does work, it loses all of its history if you force something while debugging which produces an exception.
21:51:00 <osaunders> That I want to apply to mvAddCh and the Ints should be x,y positions.
21:51:05 <zygoloid> quuuux: and then it blames /me/ for "forgetting to use :trace"
21:51:37 <osaunders> I've got lists for the xy positions too.
21:52:20 <osaunders> So I want to get mvAddCh 0 0 60 then mvAddCh 0 1 60 then mvAddCh 0 2 60 etc.
21:53:42 <zygoloid> osaunders: how do the xy positions relate to elements in your [[Word32]]?
21:54:11 <osaunders> x0 y0 == head $ head [[Word32]]
21:54:31 <osaunders> They just number them.
21:55:08 <zygoloid> osaunders: do you know about zipWith?
21:55:51 <zygoloid> > zipWith (+) [0..] [1,5,4,9]
21:55:52 <lambdabot>   [1,6,6,12]
21:56:07 <zygoloid> > zipWith f [0..] [1,5,4,9]
21:56:08 <lambdabot>   Ambiguous type variable `c' in the constraints:
21:56:09 <lambdabot>    `SimpleReflect.FromExpr ...
21:56:13 <zygoloid> > zipWith f [0..] [1,5,4,9] :: [Expr]
21:56:15 <lambdabot>   [f 0 1,f 1 5,f 2 4,f 3 9]
21:58:03 <osaunders> Hang on.
22:01:37 <osaunders> zygoloid: I'm not sure this is even right but it should illustrate what I'm trying to do http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13748#a13748
22:02:40 <zygoloid> osaunders: well, (!!) is pretty slow...
22:03:09 <osaunders> zygoloid: I don't like how I construct this thing with pointsUpTo only to break it down again with xPoints and yPoints.
22:03:10 <zygoloid> osaunders: also your pointsUpTo should probably say [0..dims-1] not [0..x-1]
22:03:48 <osaunders> dims is a tuple
22:04:49 <zygoloid> osaunders: still, it's pretty confusing to write 'x <- [0..x-1]'
22:05:14 <osaunders> Hm yeah.
22:05:29 <osaunders> lineOfX <- [0..maxX-1]
22:05:49 <osaunders> lineOfX <- [0..maxX] where maxX = width - 1
22:05:52 <zygoloid> osaunders: is buf necessarily (fst dims x snd dims) ?
22:06:15 <osaunders> buf is under my control.
22:06:24 <zygoloid> > concat $ zipWith (\x -> zipWith (f x) [0..]) [0..] [[1,2],[5,6,7],[4],[9,0]] :: [Expr]
22:06:25 <lambdabot>   [f 0 0 1,f 0 1 2,f 1 0 5,f 1 1 6,f 1 2 7,f 2 0 4,f 3 0 9,f 3 1 0]
22:06:33 <zygoloid> ^^ that's what i'd do
22:06:44 <pastah_rhymez> anyone here that knows vty?
22:06:51 <pastah_rhymez> i have no clue where to start :/
22:08:33 <osaunders> > zipWith (\x -> zipWith (f x) [0..])
22:08:35 <lambdabot>   Ambiguous type variable `c' in the constraints:
22:08:35 <lambdabot>    `SimpleReflect.FromExpr ...
22:08:41 <paul424> back to my question, I think I just need to reduce my function when it is needed ...
22:08:59 <osaunders> > zipWith (\x -> zipWith (f x) [0..]) [0..]
22:09:00 <lambdabot>   Ambiguous type variable `c' in the constraints:
22:09:00 <lambdabot>    `SimpleReflect.FromExpr ...
22:09:14 <osaunders> > zipWith (\x -> zipWith (f x) [0..]) [1,2,3]
22:09:15 <lambdabot>   Ambiguous type variable `c' in the constraints:
22:09:15 <lambdabot>    `SimpleReflect.FromExpr ...
22:09:24 <osaunders> > zipWith (\x -> zipWith (f x) [0..]) [1,2,3] :: [Expr]
22:09:25 <lambdabot>   Couldn't match expected type `[SimpleReflect.Expr]'
22:09:25 <lambdabot>         against inferre...
22:09:29 <osaunders> ffs
22:11:48 <paul424> damm ok I give up here's the code : http://pastebin.com/m50629f73
22:13:08 <pastah_rhymez> paul424: NICE indentation :p
22:13:13 <zygoloid> > zipWith (\x -> zipWith (f x) [0..]) [0..] [[1,2],[3,4]] :: [Expr]
22:13:15 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
22:13:15 <lambdabot>         against inferred ...
22:13:19 <paul424> are there any one line comments like // in c++
22:13:21 <zygoloid> > zipWith (\x -> zipWith (f x) [0..]) [0..] [[1,2],[3,4]] :: [[Expr]]
22:13:22 <lambdabot>   [[f 0 0 1,f 0 1 2],[f 1 0 3,f 1 1 4]]
22:13:37 <zygoloid> paul424: yes. -- starts a line comment
22:15:30 <zygoloid> paul424: i suspect ghc's strictness analyzer has failed to spot that maxsyr_aux is strict in acc.
22:16:11 <paul424> zygoloid: are you making fun of me ? haskell is lazy
22:16:14 <ray> it didn't catch it because it isn't ANALLY strict in acc
22:16:52 <zygoloid> paul424: i'm not making fun of you! GHC has a pass which looks for function arguments which are used strictly, and uses that to remove unnecessary laziness
22:17:13 <zygoloid> paul424: firstly, are you compiling with optimization enabled? (-O2)
22:17:20 <scalaLove> for algorithim analasys do you use any tools with haskell? maybe guis for function graphs?
22:17:30 <paul424> AHa thanks, I use the ghci
22:17:48 <paul424> with Winhugs which is the gui for windows.
22:17:48 <pastah_rhymez> paul424: fixed your syntax: http://pastebin.com/d3e36ed67
22:17:55 <zygoloid> ray: you mean, because "maxsyr_aux 1 0 acc" isn't strict in acc? :)
22:18:14 <aavogt> winhugs is a gui for hugs, not ghci
22:18:30 <aavogt> but there is a fancy frontend for ghci using similar code
22:18:37 <aavogt> called winghci or something similar
22:18:38 <ray> well, i didn't read the code, just a StrictAnal joke
22:19:16 <aavogt> ray: it's quite a shocker when looking through the ghc api
22:20:14 <aavogt> ghc's been doing _what_ to my pretty code?
22:20:51 <paul424> aavogt: didn't know that I wil try to swith to winghci
22:20:57 <ray> well, some people call haskell a bondage and discipline language
22:21:17 <zygoloid> paul424: do you know about seq or $!?
22:21:22 <zygoloid> ($!)?
22:21:47 <aavogt> paul424: you'll get best performance compiled with -O2 using ghc
22:21:48 <paul424> hmm er a little
22:22:21 <aavogt> I'm not sure whether or not ghci does much optimization.... though it does load compiled modules
22:22:32 <Jonno_FTW> what does -O2 actually do?
22:22:57 <ray> turns on a bunch of optimizations
22:23:00 <zygoloid> paul424: ok, so the problem lies in the "maxsyr_aux (n1+1) n2 (max acc (syr n1))" expression. that's potentially building up chain of 'max' expressions (and a chain of '+' expressions)
22:23:12 <aavogt> trade compiler execution time to reduce code execution time
22:23:28 <paul424> zygoloid: yes thats what I have told prev .
22:23:33 <aavogt> there's a list of the specific things in the ghc manual
22:24:44 <zygoloid> paul424: ok. so there's this operator ($!). "f $! x" evaluates x (to weak head normal form), and produces (f x).
22:25:10 <paul424> aha, thats what I asked at the beginning
22:27:09 <scalaLove> A lot of Haskell programmers remark that once they have fixed all the type errors in their programs, and their programs compile,
22:27:11 <scalaLove> that they tend to 'just work': function flawlessly first time, with only minor problems. --------------- Can someone please explain me what that means?
22:27:12 <fasta> Is there any piece of Haskell code, which implements a real protocol (like some crypto code) which runs with plain GHC that does not look horrible _and_ runs fast?
22:27:46 <pastah_rhymez> scalaLove: the type checker is a goddamn dick, letting nothing buggy through
22:28:02 <fasta> scalaLove, it means that for the simplistic programs most people write, code usually works the first time.
22:28:13 <idnar> Haskell's rich type system allows you to represent the semantics of your program much more precisely
22:28:32 <ray> in haskell, a greater percentage of errors are type errors than in other languages
22:28:34 <pastah_rhymez> scalaLove: The haskell typechecker can be likened to a Foreign Leigion drill seregant
22:28:41 <idnar> so some large / common classes of error result in a type error which is caught by the type checker
22:28:43 <ray> and type errors will break your compile
22:28:50 <fasta> scalaLove, once you write something complicated (which is harder to do in Haskell, since Haskell sort of forces you to design in a sane way), it will probably be about the same.
22:28:54 <ray> but runtime errors go through silently
22:28:57 <ray> so it's a good thing
22:29:18 <fasta> How anyone can love Scale puzzles me, though.
22:29:26 <scalaLove> if u write well dont you have that in all languages ? :)
22:29:45 <pastah_rhymez> scalaLove: didn't you notice that all your shitty attempts were shot down when you were doing your list functions yesterday?
22:30:05 <Jonno_FTW> are there any basic text based games that can be made in haskell?
22:30:16 <aavogt> attempts that 99.9% of the time have no sensible interpretation
22:30:19 <pastah_rhymez> Jonno_FTW: working on one right now
22:30:25 <Jonno_FTW> go on
22:30:44 <pastah_rhymez> Jonno_FTW: though i'm about to start using VTY...and it feels daunting
22:30:49 <scalaLove> pastah_rhymez, cant remember what exactly u mean
22:30:58 <pastah_rhymez> i guess this must be what it's like to play EVE online
22:31:29 <pastah_rhymez> scalaLove: well, i remember you got some cool errors; "Expected [a], Inferred [a] -> [a]"
22:31:51 <scalaLove> not really
22:32:09 <pastah_rhymez> please don't make me go look in my log to find your old pastes
22:32:36 <saml> [a] means list of a's
22:32:49 <saml> [a] -> [a]  means something else
22:32:50 <scalaLove> questions were haskell syntax related since i am new, to translate the pseudo code... i had no such problems as u say
22:33:19 <zygoloid> scalaLove: look at it this way: every single thing the typechecker complains about is a bug (unless you're doing fringe type hackery, which almost no-one is). haskell typecheckers moan more than typecheckers for most other languages. therefore they catch more bugs.
22:33:22 <saml> haskell syntax is more complicated than lisp's
22:33:34 <pastah_rhymez> scalaLove: anyway, the idea is that since the type system is so cool so a lot of bugs automagically get caught in it
22:33:40 <aavogt> type errors can't usually tell you how to fix your code, since there are usually a couple ways to fix the contradictions you write
22:34:19 <scalaLove> ok thanks guys i see what u mean, but still I would not say haskell is special because of this, if you really know what u do, and u should, then u have this in any language
22:34:41 <saml> haskell is not special
22:34:46 <sohum> scalaLove: basically it means two things: a) haskell is a lot more declarative than other languages, so there's less scope for error in translating what you /mean/ and b) haskell's strong typing usually catches a lot of the "plumbing" bugs.
22:34:52 <fasta> scalaLove, also u is a forbidden word in #haskell.
22:35:07 <aavogt> fasta: r u sure?
22:35:13 <fasta> Haskell is not "declarative".
22:35:14 <pastah_rhymez> scalaLove: ok, so the type checker won't catch (u-v) when it should be (v-u), but it will be mad when you do 'concat "lol"' when it should've been 'concat ["lol","lulz"]'
22:35:41 <fasta> Haskell is about howto knowledge, not what knowledge. Computers are about howto knowledge.
22:35:41 <saml> haskell lets you write papers
22:36:01 <zygoloid> scalaLove: if you're skilled enough that you can write programs which the typechecker doesn't complain about, first time, then the typechecker is not helping you find errors, that's true. few people are so skilled.
22:36:09 <sohum> fasta: it's a continuum that correlates roughly with abstraction. I think it's justified to call it "a lot more declarative"
22:36:30 <zygoloid> scalaLove: on the other hand it's trivial to write such code in python, and the result is that more bugs aren't found until runtime
22:36:30 <pastah_rhymez> scalaLove: http://necrobious.blogspot.com/2009/03/fun-example-of-haskells-newtype.html <-- here you have a good example of how you can prevent bugs in haskell
22:36:36 <pastah_rhymez> by just using the type system
22:36:43 <scalaLove> of course it is declarative guys, check wiki, C is imperative for example
22:37:45 <pastah_rhymez> scalaLove: check link^^ and 2nd comment
22:38:06 <fasta> Declarative code is this: Give me two numbers x and y s.t. x*y=80391238172389273982378237823823213232323232321231312.
22:38:25 <fasta> Most programming is about solving those problems and the trivial glue code.
22:38:27 <pastah_rhymez> fasta: <3 <3 <3 prolog <3 <3 <3
22:38:33 <fasta> pastah_rhymez, nope.
22:38:40 <pastah_rhymez> well, almost
22:38:45 <fasta> pastah_rhymez, there is a language called Godel which does that, IIRC.
22:38:56 <fasta> pastah_rhymez, of course, terribly slow.
22:39:16 <pastah_rhymez> fasta: P(X,Y) = X*Y = 80391238172389273982378237823823213232323232321231312.
22:39:18 <pastah_rhymez> oh
22:39:36 <pastah_rhymez> sorry... X*Y is ...
22:40:08 <fasta> "declarative" is just a buzz-word.
22:40:11 <aavogt> heh, haskell programmers complaining about languages being declarative and hiding how evaluation actually takes place
22:40:18 <zygoloid> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ <-- you could do it like this...
22:40:50 <fasta> It's better to say that Haskell makes you worry about less irrelevant stuff than C.
22:40:51 <eu-prleu-peupeu> hmm
22:41:00 <medfly> fuck yes
22:41:03 <scalaLove> declarative is a where you say WHAT to be done, in imperative you do your own pointer and garbage collection shit
22:41:21 <fasta> scalaLove, yep, and Haskell is not declarative.
22:41:32 <eu-prleu-peupeu> if i have two datatypes, A and B, where B belongs do the class Ord but A doesn't... does that makes (A,B) belong to the class Ord  ?
22:41:33 <ddarius> The trick to statically typed programming is not having the type checker catch your errors but manipulating the types so that the type checker completely rules out the possibility of certain, application-specific, errors.
22:41:37 <scalaLove> functional is declarative man
22:41:40 <scalaLove> logic is too
22:42:02 <saml> no functional is imperative
22:42:05 <ray> declarative is more of an extreme
22:42:11 <saml> substitution is very imperative
22:42:14 <ddarius> aavogt: Pure logic languages, which Prolog is not, don't require explaining how evaluation takes place (as much)
22:42:17 <saml> lambda reduction is very imperative
22:42:27 <saml> imperative is how our brain works
22:42:31 <Kamujin> ddarius: Well said.
22:43:36 <saml> this channel gets +1 lvl up for not feeding troll like me
22:44:27 <nominolo> saml: what is "imperative" anyways
22:44:55 <scalaLove> http://en.wikipedia.org/wiki/Programming_paradigm
22:45:01 <Kamujin> fasta: Haskell still make you worry about more irrelevant stuff than I'd like. Plus it obfuscates in some cases where imperative is clearer. IMO, we will have to iterate on a few more languages still to get it right.
22:45:04 <saml> a sequence of instructions on howto
22:45:05 <scalaLove> Please tell me where do you see functional is?
22:45:16 <fasta> Kamujin, I never said that Haskell is perfect.
22:45:27 <saml> of ocurse you can reduce lambda in many different ways.. but you need to commit to one
22:45:31 <scalaLove> saml look at the wiki so i can have a big smile haha
22:45:33 <fasta> Kamujin, what is your list of annoyances?
22:45:38 * Ferdirand goes on to fix the wikipedia article
22:46:06 <saml> you can disect any group into any way
22:46:27 <scalaLove> Haskell is functional and it is in imperative... go read some book on programming paradigms saml
22:46:32 <saml> that wiki page did it that way to aid its argument
22:47:06 <scalaLove> saml u r confused read a book on paradigms seriosly
22:47:27 <nominolo> saml: The Reduceron manages uses a very different mechanism for implementing (parallel) Haskell as graph reduction.  GHC's STG machine does the same, but it's modelled to run well on an imperative machine.
22:47:49 <saml> exactly. all programms on von neuman are imperative
22:48:15 <saml> they are all isomorphic. functional, logic..blah blah.. when it comes down to it, they are all encoded as imperative
22:48:23 <quuuux> hmm. I'm having some trouble compiling type-level-0.2.3: apparently base-3.0.3.0 is hidden, so it can't see Data.Generics?
22:48:32 <nominolo> well, in order to decide such a claim you'd have to settle on a fairly rigorous definition of "imperative"
22:48:32 <quicksilver> saml: how they are encoded is irrelevant, however.
22:48:39 <ddarius> saml: Which simply verifies the Church-Turing thesis.
22:48:40 <quicksilver> what matters about haskell is what it *is*, not how its compiler works.
22:48:52 <pastah_rhymez> isn't there a haskell machine?
22:49:04 <pastah_rhymez> i remember reading about one with just four instructions or something
22:49:13 <quicksilver> the point about haskell is that it has (we hope) a direct semantic denotation
22:49:25 <quicksilver> so we don't need to appeal to the implementation to argue about how it behaves
22:49:25 <zygoloid> i would argue that haskell isn't imperative, since its operational semantics are not specified (in particular, it's non-strict, not lazy)
22:49:27 <quuuux> according to ghc-pkg list, base-3.0.3.0 should be visible, and it's also listed as a requirement in the .cabal file
22:49:28 <Kamujin> fasta: The usual suspects. IE When all you have is a tail-recursive loop, everything looks like an unbounded list. Single produce / multiple consumer shared state concurrency where performance is critical, etc. That said, Haskell has many strengths, don't get me wrong.
22:49:35 <nominolo> pastah_rhymez: the Reduceron
22:49:48 <nominolo> pastah_rhymez: http://www.cs.york.ac.uk/fp/reduceron/
22:50:14 <scalaLove> zygoloi: exactly !!! operational semantics not specified, you hear that saml?
22:50:20 <tombee> Can anyone help me spot where I'm going wrong here? http://pastebin.com/mc2440a3
22:50:32 <nominolo> pastah_rhymez: it implements (Core) Haskell on an FPGA
22:50:32 <tombee> I'm trying to get the prime factors of a number :)
22:50:55 <nominolo> the FPGA runs at 110MHz but is only 2-3x slower than GHC on a 3GHz Core 2
22:51:27 <saml> i think that could be a falacy. to find space leak in haskell, you need to refer to implementation
22:51:30 <paul424> suppose I have defined :  (*) :: a -> a -> a , e :: a and I want from this line (*) to be a + and e an '0', what should I do >?
22:51:37 <pastah_rhymez> nominolo: that's pretty amazing :)
22:52:35 <fasta> Why is there no splitAt which works from the end?
22:52:55 <nominolo> pastah_rhymez: yup :)  They basically avoid the Von Neumann bottleneck (memory).  Application is ceil(n/2) cycles where n is the number of application nodes in the function body.
22:53:21 <nominolo> And memory is partitioned so more things can happen in parallel.
22:53:33 <saml> paul424, (+) = (*)   ?
22:53:43 <zygoloid> saml: space leaks are a result of simulating the denotational semantics of a haskell program on a specific imperative machine. different imperative machines can give different sets of space leaks (for instance, applying GHC's strictness analyzer can remove space leaks, and let lifting can introduce them)
22:53:43 <saml> e = 0
22:53:44 <jmcarthur_work> nominolo, what architecture are you talking about?
22:53:57 <nominolo> jmcarthur_work: the Reduceron (Haskell on an FPGA)
22:54:01 <jmcarthur_work> ah!
22:54:07 <jmcarthur_work> i've been meaning to read about how it works
22:54:29 <nominolo> jmcarthur_work: this one might be a good start http://www.cs.york.ac.uk/fp/reduceron/memos/Memo41.pdf
22:54:33 <saml> zygoloid, yup. too much complication. conversion of one system ot another is hard
22:54:39 <jmcarthur_work> nominolo, thanks!
22:55:01 <saml> > let (*) = (+); e = 0 in e * 23
22:55:03 <lambdabot>   23
22:55:24 <nominolo> jmcarthur_work: and this is the IFL'07 paper: http://www.cs.york.ac.uk/fp/reduceron/reduceron.pdf
22:57:00 <paul424> suppose I have defined :  (*) :: a -> a -> a , e :: a and I want from this line (*) to be a + and e an '0', what should I do >?
22:57:12 <paul424> sorry I put the history
22:57:57 <saml> paul424, oh you might need let expression.   to redefine something from "this line"
22:59:44 <saml> or did you mean + as string concatenation?   and e is a Char '0' ?
23:00:11 <saml> > let (*) = (:); e = '0' in e * "hola back"
23:00:12 <lambdabot>   "0hola back"
23:00:51 <osaunders> I don't understand this output:
23:00:53 <osaunders> > zip [0..]
23:00:54 <lambdabot>   []->
23:00:55 <lambdabot>    []
23:00:55 <lambdabot>  [()]->
23:00:55 <lambdabot>    [(0,())]
23:00:55 <lambdabot>  [(),()]->
23:00:56 <lambdabot> [3 @more lines]
23:01:00 <osaunders> What does that mean?
23:01:10 <osaunders> Specifically [] -> []
23:01:49 <sohum> @pl \a b -> f (g a b)
23:01:50 <lambdabot> (f .) . g
23:02:49 <sohum> @pl \a b c -> f (g a b c)
23:02:50 <lambdabot> ((f .) .) . g
23:03:11 <osaunders> What's point-free code?
23:03:21 <osaunders> @help pl
23:03:21 <fasta> Is there already a way to denote ByteStrings using normal String syntax? That is, does "bar"::ByteString already work?
23:03:22 <lambdabot> pointless <expr>. Play with pointfree code.
23:03:29 <Stinger> it's "pointless" code
23:03:34 <saml> osaunders, point-free means without lambda
23:03:47 <saml> probably i'm wrong
23:04:20 <Stinger> without binding values to names (my layman explanation (i.e. I'm the layman))
23:04:30 <zygoloid> osaunders: that code is a special lambdabot mechanism for printing out functions
23:04:36 <sohum> @pl \f g -> result (result (result f)) g
23:04:37 <lambdabot> result . result . result
23:04:43 <sohum> right.
23:04:45 <zygoloid> osaunders: "a->b" in that output means the function produces b when given a.
23:05:10 <osaunders> zygoloid: Right, OK.
23:05:16 <zygoloid> osaunders: imagine the output started '\x -> case x of' and you're on the right lines
23:05:18 <osaunders> TY
23:06:23 <fasta> Nm.
23:06:26 <zygoloid> fasta: there's an extension to support that. -XOverloadedStrings
23:06:34 <paul424> > (*) :: a -> a -> a
23:06:35 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
23:06:35 <lambdabot>    arising from a use ...
23:06:39 <fasta> zygoloid, yes, I already found it.
23:07:52 <paul424> > let (*) :: a -> a -> a = (+); e :: a = 0  in 53 * 0
23:07:54 <lambdabot>   Not in scope: type variable `a'Not in scope: type variable `a'Not in scope:...
23:09:10 <zygoloid> > let (*) = (+); e = 0 in 53 * e
23:09:12 <lambdabot>   53
23:09:53 <paul424> zygoloid: why I cannot add my typing restrictions ?
23:10:06 <Stinger> > [1,2,3] >>= guard . (==2)
23:10:08 <lambdabot>   [()]
23:11:05 <sohum> > let (*) :: a -> a -> a; (*) = (+) in 53 * 0
23:11:07 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
23:11:07 <lambdabot>    arising from a use ...
23:11:14 <sohum> paul424: that's the syntax
23:11:23 <Stinger> ok how are you supposed to use guard
23:11:40 <sohum> paul424: the second problem is that (+) isn't of type a -> a -> a, it's of type Num a => a -> a -> a
23:12:16 <paul424> hmm I would say it is a subtypoe
23:12:26 <sohum> subtypes are fune
23:12:33 <paul424> fun or fune ?
23:12:33 <sohum> > let (*) :: Fractional a => a -> a -> a; (*) = (+) in 53 * 0
23:12:35 <lambdabot>   53.0
23:12:45 <sohum> *fine
23:12:58 <sohum> but a -> a -> a is a supertype of Num a => a -> a -> a
23:13:13 <sohum> and so you can't define the former with the latter
23:13:48 <Stinger> > [1,2,3] >>= \x -> guard . (==2) >>= return x
23:13:49 <lambdabot>   The section `GHC.Classes.== 2' takes one argument,
23:13:49 <lambdabot>  but its type `[GHC.Bool...
23:14:32 <Stinger> > [1,2,3] >>= \x -> guard (x==2) >>= return x
23:14:33 <lambdabot>   No instance for (GHC.Num.Num [b])
23:14:33 <lambdabot>    arising from the literal `1' at <inter...
23:14:41 <Stinger> bah humbug
23:16:00 <quuuux> > [1, 2, 3] >>= \ x -> guard (x == 2) >> return x
23:16:02 <lambdabot>   [2]
23:16:39 <scalaLove> guys, give me top 3 things you dislike about haskell, I am learning and so far everything seems so perfect...
23:16:48 <narens> if I am transforming a huge list to another list is it alright to use foldr and avoid stack overflow? or should i do foldl
23:16:54 <aavogt> scalaLove: records
23:17:36 <scalaLove> whats wrong with records
23:17:42 <Saizan> narens: foldr let you produce the output list before consuming the whole input one
23:17:43 <Jafet> Everything.
23:17:46 <mrd> scalaLove: type classes
23:18:01 <Saizan> narens: but the choice depends on how you actually look at the input list
23:18:19 <sohum> scalaLove: constructor overload
23:18:29 <narens> Saizan: say i want to convert [[a]] by adding an element to each of the inner list. foldr would be okay?
23:18:55 <Saizan> narens: yes
23:19:00 <Jafet> foldl' also avoids stack overflow, in a different way
23:19:12 <scalaLove> sohum: you dislike type classes, constructor overload and records? wait read carefully i said dislike,not like. I like these stuff, what is wrong with them?
23:19:16 <Saizan> narens: but for that case you can use map in particular
23:19:30 <narens> Saizan: thanks. oh yeah! good point. sometimes i think too much
23:19:40 <sohum> scalaLove: I just said constructor overload
23:19:56 <Saizan> narens: map f = foldr (\x xs -> f x : xs) []
23:20:08 <scalaLove> i meant for you guys all, not just sohum ... anyways, why?
23:20:15 <sohum> scalaLove: I mean cases where you have to say things like Just Endo [Right "something"]...
23:20:32 <aavogt> records are nasty when trying to update them when nested multiple levels deep
23:20:41 <Saizan> narens: basically foldr f z is appropriate when f is lazy on its second argument
23:20:49 <sohum> or Just (C [Foo [Right 4]])
23:20:55 <sohum> or any other pathological case
23:21:05 <narens> Saizan: indeed. I remember reading that in the haskell performance wiki
23:21:08 <EnglishGent> has anyone here got lib-magic to work with Haskell?
23:21:14 <Jafet> Record syntax needs improving, and I have no idea why someone would dislike type classes
23:21:29 <quuuux> @pl \ x -> (>>) (f x) (g x)
23:21:29 <lambdabot> liftM2 (>>) f g
23:21:31 <sohum> the record mechanism in general needs improving
23:21:39 <aavogt> there are libraries to derive composable functions, but that brings up the trouble of using template haskell
23:21:52 <scalaLove> why u dislike constructor overload man, i see no reason, explain please more, sohum
23:22:08 <aavogt> what is constructor overload in haskell?
23:22:20 <sohum> scalaLove: because imo all of those constructors are unnecessary, given the type
23:22:21 <narens> Saizan: Actually, i can ask something else here. So, if I want to make a general mean function (i.e. take the average of numbers) [a] -> Double. The problem is a has to be Floating. Is there anyway a can be Num
23:22:26 <Saizan> aavogt: i was wondering the same
23:22:33 <pastah_rhymez> Jafet: it is improved
23:22:33 <sohum> unnecessary and obscuring the actual data
23:22:50 <sohum> If I could say "foo" :: Maybe String, I'd be happy.
23:22:50 <pastah_rhymez> check hackage package "fclabels"
23:23:03 <quicksilver> sohum: I believe you do not understand the consequences of that.
23:23:12 <sohum> quicksilver: I know, I've heard it before
23:23:20 <quicksilver> you lose the property that "foo" has a principle type.
23:23:34 <sohum> quicksilver: I don't think it's something unsurmountable, though
23:23:42 <quicksilver> this breaks all kinds of things; one example is it breaks many common sense program-rewriting transformations
23:23:59 <quicksilver> and your programs become less composable/modular because of that
23:24:06 <quicksilver> it also breaks type-inference, in general
23:24:14 <aavogt> sohum: can't you do that with -XOverloadedStrings?
23:24:18 <quicksilver> so you have to be quite careful which special case you choose
23:24:18 <Saizan> narens: you can't divide with just Num, you could use fromIntegral on the sum but that requires Integral
23:24:41 <sohum> quicksilver: don't defaulting and typeclasses solve those, though?
23:24:44 <Veinor> :t /
23:24:45 <lambdabot> parse error on input `/'
23:24:48 <Veinor> :t (/)
23:24:50 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:25:00 <narens> Saizan: right, so i guess i am asking if doing fromIntegral on a huge list of Int's... what the perf hit will be
23:25:08 <quicksilver> sohum: you can solve it in particular cases with typeclasses, yes
23:25:13 <quicksilver> sohum: like Num, for example.
23:25:23 <quicksilver> sohum: but that then fails to solve it for general cases
23:25:31 <quicksilver> do you also want to say [3] :: Maybe [Int] ?
23:25:35 <sohum> aavogt: ghc has special support for stringability, and haskell has special support for numability. but how would you go 5 :: Just Integer?
23:25:35 <quicksilver> (for example)
23:25:51 <mrd> type classes are wonderful for creating small concise programs.  the problem with them comes when structuring large programs.
23:25:56 <Saizan> narens: you can do the sum as Int and fromIntegral only on that, if you don't worry about overflow
23:25:56 <quicksilver> sohum: by making Maybe Integer an instance of Num
23:25:58 <sohum> quicksilver: I'm envisioning a typeclass ConstructableFrom a b where construct :: a -> b
23:25:59 <aavogt> sohum: instance Num a => Num (Maybe a)
23:26:16 <jmcarthur_work> instance Num a ⇒ Num (Maybe a) where …
23:26:21 <quicksilver> sohum: you rapidly dissolve into a morass of ambiguity.
23:26:22 <jmcarthur_work> err, that
23:26:25 <scalaLove> sohum u confused me, but i see u r in confusion too
23:26:36 <sohum> aavogt: bad example. Lit "foo" :: Just Sexp
23:27:00 <sohum> aavogt: basically, Numability and Stringability are specialcased at the moment
23:27:02 <quicksilver> sohum: as there quickly become a whole tree of paths ConstructablFrom {a b} {b c} {c d} which could lead to possible ways to the result type d
23:27:04 <aavogt> sohum: that's another bad example
23:27:12 <quicksilver> sohum: and no sensible way of annotating the path you actually wanted.
23:27:24 <sohum> *Maybe Sexp
23:27:25 <sohum> my bad
23:27:38 <quicksilver> sohum: (actually there is one sensible way to annotate the path you wanted - explicit constructors ;)
23:27:40 <Stinger> @pl \x -> guard (x==2) >> return x
23:27:41 <lambdabot> ap ((>>) . guard . (2 ==)) return
23:27:43 <sohum> quicksilver: I don't thunk that tree exists in practice
23:28:04 <sohum> quicksilver: or, rather
23:28:56 <scalaLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13751#a13751 from book on haskell... that link confirmes it is functional if someone still doubts it...
23:28:57 <sohum> quicksilver: you can implement this for everything that /doesn't/ cause the tree (in practice things which are unambiguous with respect to type, like Maybe), and still solve a whole lot of issues
23:29:18 <jmcarthur_work> the thing is you have to have a concrete rule for that
23:29:37 <quicksilver> sohum: I believe the cost outweighs the benefit but you're welcome to design a system how you'd like it to work. Would make an interesting blog post or cafe post.
23:29:40 <jmcarthur_work> otherwise it's not a language feature but a dirty compiler trick
23:30:03 <quicksilver> or the power to weight ratio is poor, is probably a slightly better metaphor
23:30:06 <jmcarthur_work> i encourage any attempt to make things simpler
23:31:10 <sohum> quicksilver: I started, once. quickly got bored when I realised there didn't exist a Typable0 to bootstrap :P I'll have a look at it again, even if it means copypasting the code directly from Typable
23:31:20 <PeakerWork> sohum: I think  Just "foo"  communicates an important detail to the reader
23:31:27 <jmcarthur_work> which i believe the ideal in this idea is to simplify, although i too am skeptical of how much complexity is necessary to yield simplicity
23:31:43 <jmcarthur_work> that is meant to sound contradictory
23:31:47 <sohum> PeakerWork: and I think that "foo" :: Maybe String communicates exactly the same information
23:31:59 <PeakerWork> sohum: Much longer, though
23:32:08 <sohum> PeakerWork: but, given that the signature is usually specified anyway, is shorter
23:32:29 <jmcarthur_work> i think the string overloading idea is perfectly reasonable, personally
23:32:37 <PeakerWork> sohum: well, then its no longer "foo" :: Maybe String,   its "foo" in one place, and Maybe String somewhere else...  And most code isn't type-annotated anyway
23:32:42 <jmcarthur_work> just like our numeral overloading
23:33:01 <jmcarthur_work> we even have it already...
23:33:07 <Saizan> i feel like type annotations are also more fragile wrt refactors than constructors, but it might well be the inverse
23:33:12 <fasta> Why is there no zipWith which creates a ByteString?
23:33:56 <PeakerWork> @hoogle zipWith :: ByteString
23:33:57 <lambdabot> No results found
23:34:10 <sohum> PeakerWork: I don't think the latter statement is true, but with defaulting the cases where it isn't type annotated are unaffected. and types tend to stick with the function being defined, anyway.
23:34:16 <fasta> zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
23:34:23 <Saizan> sohum: "usually specified anyway" is not true in the code i write and have seen
23:34:25 <PeakerWork> @hoogle (Word8 -> Word8 -> Word8) -> ByteString -> ByteString -> ByteString
23:34:25 <lambdabot> No results found
23:34:50 <fasta> Given the type of map in the same module, which does return a ByteString, I find it kind of weird.
23:35:08 <medfly> bytestring bytestring bytestring
23:35:16 <PeakerWork> sohum: I think it complicates things -- and I don't see the benefit (I really don't see the "Just" there as noise)
23:36:00 <quicksilver> sohum: I don't even mean a working implementation.
23:36:12 <quicksilver> sohum: I mean a description, in words, (with examples) of how you'd *like* it to behave
23:36:24 <quicksilver> sohum: then we could discuss teh difficult cases and you coudl tell me how you'd solve them.
23:36:27 <sohum> PeakerWork: in the simple case with one constructor, it usually feels ok. but when you get into longer chains...
23:36:35 <PeakerWork> sohum: Example?
23:36:44 <jmcarthur_work> PeakerWork, what is your opinion on overloading Num for instances of Applicative (ignoring the functions in Num that obviously don't always fit)?
23:37:09 <sohum> I've found myself avoiding refactoring large datatypes because I couldn't bear the additional level of constructors
23:37:14 <PeakerWork> jmcarthur_work: I think Num is too wrong to do such nice things :)
23:37:41 <PeakerWork> sohum: If you make your data type a type-composition or have an Applicative instance, you can "pure" into as many constructors as you'd like
23:38:26 <sohum> PeakerWork: I once had to work with a Just (XVar (V "foo")). XVar Variable, and Variable = V String | Undefined ...
23:38:27 <jmcarthur_work> PeakerWork, i agree that Num is bad, but is the idea that numeric literals can be made into Maybe Int bad?
23:38:34 <sohum> PeakerWork: what's this?
23:39:05 <jmcarthur_work> perhaps i am misunderstanding both sides of this debate
23:39:07 <PeakerWork> jmcarthur_work: I don't like that, but I haven't thought about it that much
23:39:21 <jmcarthur_work> PeakerWork, i've done it a lot and haven't run into any problems
23:39:36 <sohum> PeakerWork: what do you mean, "a type-composition or have an Applicative instance"? there an example you can point me to?
23:39:38 <PeakerWork> sohum: Can't you abstract-away the packing/unpacking of your constructors?
23:39:47 <jmcarthur_work> besides junk like the Eq constraint
23:39:55 <PeakerWork> sohum: the TypeCompose library, see the :. type operator
23:40:20 <quicksilver> sohum: why wouldn't you just do mkv = Just . XVar . V ?
23:40:26 <quicksilver> sohum: and then work with 'mkv' ?
23:40:34 <sohum> PeakerWork: usually, and that's the only reason this is bearable. but it's still annoying in cases where, say, you cant to pattern match and such.
23:40:47 <sohum> quicksilver: pattern matching.
23:40:53 <sohum> well, sorry
23:40:55 <sohum> my apologies
23:41:01 <quicksilver> sohum: if you're pattern matching 3 deep you're doing it wrong ;)
23:41:02 <fasta> Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'  against inferred type `Data.ByteString.Internal.ByteString'. How do I construct a value of the first type?
23:41:32 <quicksilver> sohum: you should normally have combinators or functor instances in that kind of case
23:41:41 <fasta> Some library (SHA) exposes the internal type of a different library. Also kind of bad.
23:41:43 <quuuux> oh, awesome, my first GHC panic. I feel so proud of myself
23:42:01 <fasta> quuuux, what is it?
23:42:03 <quicksilver> sohum: I mean, I do agree entirely, by the way, that Just (XVar (V "foo")) is unaesthetic
23:42:22 <quuuux> fasta: the debugger throwing up all over itself
23:42:25 <quicksilver> sohum: I just think the language already gives us tools to manage these things and I suspect implicit promotion to be a can of worms.
23:42:34 <quicksilver> sohum: I'm happy to be proven wrong, definitely.
23:42:40 <fasta> quuuux, the debugger needs work.
23:42:44 <sohum> quicksilver: like I said, that's the main reason why it's bearable, because you can usually hide it in layers and have each layer deal with one constructor at a time
23:43:03 <scalaLove> while u write and study compilers u will learn lot of languages. How to manage that knowledge? Should i create myself a nice pdf where I will have sections with notes for each language containing most important syntax like asignment,loops, and other stuff as needed?
23:43:04 <PeakerWork> sohum: I think of pattern-matching as a relatively low-level primitive, and abstract it away, usually
23:43:11 <edwardk> preflex: seen dons
23:43:11 <preflex>  dons was last seen on #haskell 7 hours, 36 minutes and 7 seconds ago, saying: mm. hot chocolate time. good thinking bos. night!
23:43:15 <PeakerWork> sohum: For example, I'd almost always use "maybe" rather than pattern-match Maybe
23:43:24 <edwardk> whoa, dons sleeps
23:43:33 <PeakerWork> sohum: similarly, you can abstract away your 3-level-deep matching
23:44:02 <sohum> I get that
23:44:09 <sohum> being able to abstract away stuff is awesome
23:44:23 <sohum> but ... it's kinda like the common lisp argument
23:44:35 <sohum> "we don't need to evolve the language because you can, with macros"
23:44:40 <fasta> Nm.
23:45:27 <sohum> there's some stuff that's useful or convenient as standard, and, conversely, there's stuff which is annoying and warty in the standard
23:45:41 <quicksilver> sure.
23:45:56 <quicksilver> I just have yet to see a cure which isn't worse than the disease
23:46:05 <sohum> and that's fair enough
23:46:08 <jmcarthur_work> i'm still not sure what the proposed language-level feature is. afaik most of what's been discussed can already be done
23:46:11 <Stinger> @src ap
23:46:12 <lambdabot> ap = liftM2 id
23:46:12 <sohum> I haven't really looked deeply into it
23:46:31 <sohum> it's just an intuition that it should be possible without causing too many issues
23:46:36 <quicksilver> jmcarthur_work: it's not clear if language level features or not are necessary.
23:46:53 <quicksilver> if there is a language-level feature it's probably inserting an implicit "convert" at certain points in code.
23:46:53 <jmcarthur_work> quicksilver, so far it sounds like library level
23:47:04 <quicksilver> just like "5" gets an implicit "fromIntegral" in front of it.
23:47:37 <jmcarthur_work> if it's for anything besides numeric or string literals it's language level afaik, but otherwise...
23:47:39 <quicksilver> (and with -XBrokenStrings, "foo" gets an implicit fromString in front of it)
23:47:53 <jmcarthur_work> how is it broken?
23:48:04 <quicksilver> principle of least surprise.
23:48:10 <quicksilver> "abcd" is a list of precisely 4 elements.
23:48:18 <sohum> no
23:48:20 <jmcarthur_work> sounds no less broken than implicit fromIntegral, no?
23:48:23 <sohum> "abcd" is a string literal
23:48:34 <quicksilver> it's a point of view, and I wasn't entirely serious.
23:48:43 <quicksilver> as I said before, I don't much like Num literal overloading
23:48:43 <Veinor> no, "abcd" is a representation of a string literal :D
23:48:45 <sohum> ['a','b','c','d'] is a list of four elements
23:48:59 <jmcarthur_work> i like overloaded literals
23:49:00 <quicksilver> I dislike Num literal overloading, I dislike String literal overloading more ;)
23:49:05 <quicksilver> neitehr of them make me lose sleep.
23:49:14 <quicksilver> they're just minor warts.
23:49:34 <Stinger> @ty "test"
23:49:35 <lambdabot> [Char]
23:49:39 <sohum> I think they go a long way towards making the language more declarative
23:49:51 <jmcarthur_work> more declarative?
23:50:02 <sohum> when you don't need to care whether it's a list of char or a ByteString underneath...
23:50:11 <sohum> you just mean "Foo" and that's it
23:50:46 <jmcarthur_work> i think i would call that more abstract, but not necessarily more declarative
23:51:18 <Stinger> more implicit
23:51:19 <sohum> similarly, you just mean 3, as in (succ (succ (succ 0))), and you don't need to care if you'll use it fractionally or as an Integer or as a CReal...
23:51:56 <jmcarthur_work> Stinger, more abstract. it hides details
23:52:03 <quicksilver> btu the disadvantage is that it breaks program rewriting
23:52:13 <jmcarthur_work> quicksilver, how so?
23:52:26 <sohum> I'd argue that declarativity is a continuum roughly correlated with abstraction anyway
23:52:30 <quicksilver> if you move the term 3 around in your program, it gains different meanings
23:52:40 <quicksilver> which means that, sometimes, moving it breaks the program
23:52:42 <PeakerWork> sohum: Of course CL libraries do evolve and add standard macros.. I just don't think macros are as omnipotent as they say they are -- and the syntax penalty is too bad, IMO
23:52:50 <fasta> Is this instance defined anywhere? (Data.String.IsStringData.ByteString.Lazy.Internal.ByteString)
23:52:54 <quicksilver> especially in the presence of the monomorphism restriction, but not only that
23:53:05 <jmcarthur_work> quicksilver, only if you move it somewhere this it naturally has a different meaning anyway. the same applies to any overloaded identifier that's not a literal
23:53:08 <jmcarthur_work> like mempty
23:53:19 <quicksilver> true.
23:53:21 <sohum> quicksilver: and if you move a ... yea.
23:53:25 <jmcarthur_work> i think of 3 like i do mempty
23:53:26 <quicksilver> it's the cost of overloading, yes.
23:54:13 <EnglishGent> hello - can anyone help with a cabal problem? I'm getting an error re: a missing C library :|
23:54:16 <sohum> PeakerWork: they do? I haven't seen any - or been pointed to by any tutorials/guides/references as I was learning, anyway - any standard macro library for CL
23:54:59 <quicksilver> jmcarthur_work: although the interaction between default and the monomorphism restriction makes numeric literals a little more painful than mempty
23:55:18 <jmcarthur_work> true
23:55:28 <PeakerWork> sohum: CL libs just have macros in them, don't they?  Not sure if there's a "standard macro lib" that only has macros
23:55:32 <jmcarthur_work> but that's due to interference from other "features"
23:55:56 <jmcarthur_work> i'm not sure what i think of either of those features, really
23:57:21 <PeakerWork> I just disable the MR everywhere...
23:57:25 <sohum> quicksilver: that's kinda the point, right? that it always /does/ mean one thing, but at a higher level of abstraction. mzero always means the identity for MonadPlus, even though you might want to think of it as [] or Nothing. 3 always means s (s (s 0)), evne though you may want to think of it as 00000011 or 3e0.
23:57:54 <quicksilver> jmcarthur_work: the point to note is that those "features" were added precisely because numeric overloading turned out to be less convenient than expected.
23:58:04 <quicksilver> jmcarthur_work: ...and that is now considered to have been a mistake by many.
23:58:13 <quicksilver> jmcarthur_work: this is all part of the pain of overloading.
23:58:26 <PeakerWork> quicksilver: do you think it would have been better to just have 123 be Integer, and 123.345 be Double?
23:58:41 <quicksilver> sohum: except that some parts of haskell are monomorphic (by design) and when you push one of those through a monomorphic filter, you get stuck with one personality.
23:58:44 <jmcarthur_work> 123.345 be Rational ;)
23:58:55 <jmcarthur_work> 123.345 being Double by default would be a disaster
23:58:56 <quicksilver> PeakerWork: I don't know what would have been better.
23:59:03 <fasta> Overloading of string literals is great, when they work.
23:59:04 <jmcarthur_work> :t 123.345
23:59:06 <lambdabot> forall t. (Fractional t) => t
23:59:08 <quicksilver> PeakerWork: it may be that the current compromise is the right compromise.
23:59:08 <fasta> (which they don't)
23:59:10 <jmcarthur_work> *sigh*
23:59:15 <jmcarthur_work> i wanted the default
23:59:16 <sohum> PeakerWork: yea, but the macros aren't usually exported, and are usually tightly bound to the lib in question
23:59:18 <quicksilver> PeakerWork: I just mean to indicate problems with them.
23:59:46 <sohum> hm.
23:59:49 <jmcarthur_work> ugh, Double is the default
23:59:51 <jmcarthur_work> that's horrible
