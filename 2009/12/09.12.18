00:00:50 <thinkmore> Does it work on test123x?
00:00:54 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5378#a5378
00:00:56 <HugoDaniel> another one :D
00:00:57 <thinkmore> Still trying to figure it out  XD
00:01:01 <HugoDaniel> can someone help me out with that one ?
00:04:06 <bastl> HugoDaniel: how about this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5379#a5380
00:04:35 <manjunaths> what does reads do ?
00:04:49 <manjunaths> rather where would I use it ?
00:05:11 <thinkmore> @t reads
00:05:11 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:05:13 <HugoDaniel> :D
00:05:18 <thinkmore> > :t reads
00:05:19 <manjunaths> :t reads
00:05:19 <lambdabot>   <no location info>: parse error on input `:'
00:05:20 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:05:36 <thinkmore> Oh.
00:05:46 <manjunaths> what is Read a ?
00:05:51 <manjunaths> what is (Read a) ?
00:05:53 <kmc> typeclass of readable things
00:06:02 <kmc> types that can be parsed from a string
00:06:12 <kmc> > read "3.14" :: Double
00:06:13 <lambdabot>   3.14
00:06:21 <kmc> > read "\"Hello\tworld\"" :: String
00:06:22 <lambdabot>   "Hello\tworld"
00:06:34 <thinkmore> > reads "5"
00:06:35 <lambdabot>   []
00:06:43 <kmc> > read "((), False, 7)" :: ((), Bool, Float)
00:06:44 <lambdabot>   ((),False,7.0)
00:06:54 <kmc> > reads "5" :: () -- what yours defaulted to
00:06:55 <lambdabot>   Couldn't match expected type `()'
00:06:56 <lambdabot>         against inferred type `[(a, GHC.B...
00:07:08 <kmc> > reads "5" :: [((), String)] -- what yours defaulted to
00:07:09 <lambdabot>   []
00:07:16 <kmc> > reads "5" :: [(Int, String)]
00:07:18 <lambdabot>   [(5,"")]
00:07:19 <kmc> > reads "5.3" :: [(Int, String)]
00:07:19 <manjunaths> kmc, but it doesn't work in ghci ?
00:07:20 <lambdabot>   []
00:07:25 <kmc> manjunaths, reads should work in ghci
00:07:50 <manjunaths> if I triy
00:07:59 <manjunaths> reads "5" :: Int
00:08:08 <kmc> :t reads
00:08:09 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:08:17 <kmc> manjunaths, the return value is a list of (result, remaining string) pairs
00:08:17 <manjunaths> I get some error Couldn't match expected type `Int'
00:08:18 <manjunaths>            against inferred type `[(a, String)]
00:08:24 <kmc> that's what the type error is telling you
00:08:45 <kmc> when you get an error like that, ask GHCi for the type of the function you're applying (in this case, reads) to make sure you're using it right
00:08:56 <kmc> note that "read" has a different type from "reads"
00:09:11 <kmc> "read" is the "higher-level" interface; it gives you a single value or aborts the program
00:09:19 <thinkmore> > :t read reads
00:09:20 <lambdabot>   <no location info>: parse error on input `:'
00:09:22 <manjunaths> ok
00:09:29 <manjunaths> > :t reads
00:09:29 <kmc> reads gives you the list of parses, useful for building compound parsers or for handling error gracefully
00:09:30 <lambdabot>   <no location info>: parse error on input `:'
00:09:35 <manjunaths> :t reads
00:09:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:09:44 <kmc> ">" is for eval, ":t" gets type.  they are two separate lambdabot commands
00:09:48 <kmc> but :t also works in ghci
00:10:13 <kmc> if you need any parsing beyond very simple things, look at Parsec or uu-parsinglib
00:10:17 <manjunaths> for all types of readable things a to string to list of forall types of (a, String)
00:10:19 <manjunaths> ?
00:10:21 <thinkmore> Ah, alright.  I thought lambdabot only took @foo and > foo
00:10:41 <kmc> in this chan she understands a few shortcuts like ">" and ":t"
00:10:49 <kmc> in general she takes commands prefixed with '@' only
00:10:56 <kmc> @run 1 + 2
00:10:58 <lambdabot>   3
00:10:59 <kmc> @type 1 + 2
00:11:00 <lambdabot> forall t. (Num t) => t
00:11:04 <kmc> @. elite nixon
00:11:04 <lambdabot> dOn'7 +rY 70 +ake On 4 N3\/\/ pErz0nAlI+y; I+ DOE5N'+ \/\/oRx.
00:11:12 <manjunaths> lambdabot is a she ?
00:11:15 <kmc> yes
00:11:18 <kmc> @vixen are you a woman?
00:11:19 <lambdabot> yeah, why? of course i'm a girl
00:11:31 <manjunaths> haha
00:11:53 <lament> @vixen got pics?
00:11:54 <lambdabot> no pic, i'll get one soon
00:11:55 <kmc> @vixen how old are you?
00:11:55 <lambdabot> 19, you?
00:12:14 <kmc> iirc the purpose of @vixen was to lure people into cybering her
00:12:26 <manjunaths> hehe
00:12:31 <lament> yes, she makes more sense in an instant messenger
00:12:55 <Twey> Haha
00:13:25 <manjunaths> it would be nice if one can connect her to cleverbot.com
00:13:35 <manjunaths> then we can really lure people
00:13:57 <manjunaths> :-)
00:14:00 <bastl> @vixen ASL ?
00:14:01 <lambdabot> why don't you guess?
00:14:17 <bastl> hm.
00:14:17 <manjunaths> @vixen hello
00:14:18 <lambdabot> hi
00:14:29 <bastl> lambdabot is not a good name for a chatty girl ...
00:14:46 <bastl> @vixen what does your name mean?
00:14:47 <lambdabot> My name is Emily
00:15:30 <manjunaths> @vixen hi emily
00:15:30 <lambdabot> hi
00:15:45 <manjunaths> @vixen wanna go drinking ?
00:15:45 <lambdabot> nevermind about that
00:15:53 <manjunaths> lol
00:15:59 <dbelange> @vixen functors
00:16:00 <lambdabot> fun fun fun!
00:16:26 <dbelange> @vixen monads
00:16:27 <lambdabot> So, tell me your biggest and darkest secret. Something that no one knows of you.
00:16:42 <lament> @vixen I am trapped inside a monad.
00:16:42 <lambdabot> f
00:16:46 <manjunaths> ok I am off for an afternoon nap
00:16:48 <dbelange> @vixen I killed a man.
00:16:49 <lambdabot> Most guys don't understand me, but we really seem to connect.
00:17:09 <bastl> @vixen help
00:17:09 <lambdabot> Beer, it's so much more than just a breakfast drink!
00:17:23 <bastl> @vixen help
00:17:23 <lambdabot> Math is hard. Let's go shopping.
00:17:44 <bastl> @vixen more help
00:17:44 <lambdabot> Whatever
00:17:50 <dbelange> @nixon
00:17:51 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
00:18:03 <kmc> ah nixon
00:18:06 <kmc> the lovable racist
00:20:17 <lament> modern racists call themselves "biorealists"
00:22:14 <Jafet> @. vixen nixon
00:22:14 <lambdabot> have you ever scubadived?
00:23:29 <Twey> « The difficulty in understanding the Russian is that we do not take cognizance of the fact that he is not a European, but an Asiatic, and therefore thinks deviously. We can no more understand a Russian than a Chinese or a Japanese, and from what I have seen of them, I have no particular desire to understand them except to ascertain how much lead or iron it takes to kill them. In addition to his other amiable…
00:23:36 <Twey> … characteristics, the Russian has no regard for human life and they are all out sons-of-bitches, barbarians, and chronic drunks. »
00:23:39 <Twey> — Patton
00:39:39 <MoALTz> > let f n = 1/n - 1 in fix (\r n -> if n == (f n) thenn else r (f n)) 2
00:39:41 <lambdabot>   <no location info>: parse error on input `else'
00:39:47 <MoALTz> > let f n = 1/n - 1 in fix (\r n -> if n == (f n) then n else r (f n)) 2
00:39:49 <lambdabot>   -1.618033988749895
00:39:53 <Adamant> if you translate the "no regard for human life" to "inability to govern selves without evil strongman" and "chronic drunks" as "chronic drunks", he's not wrong about those parts :P
00:40:32 <roostaj> is there an isEmptyList function?
00:40:50 <Raynes> roostaj: null
00:40:53 <Adamant> of course Americans tend to forget that we were worse and nastier drunks than the Russians pre-Prohibition.
00:40:54 <roostaj> :t null
00:40:55 <lambdabot> forall a. [a] -> Bool
00:40:59 <Raynes> > null []
00:41:00 <lambdabot>   True
00:41:00 <roostaj> Raynes: thank you
00:45:18 <roostaj> man, my euler023 is nasty
00:45:35 * roostaj cries silently
00:47:54 <Jonno_FTW> i have half a solution dor 23
00:48:01 <Jonno_FTW> s/dor/for/
00:48:18 <roostaj> Jonno_FTW: i know there is a better way than what my first algorithm is
00:48:42 <roostaj> efficiency is the issue
00:48:45 <Jonno_FTW> me too
00:50:08 <roostaj> @src null
00:50:08 <lambdabot> null []     = True
00:50:08 <lambdabot> null (_:_)  = False
00:51:01 <roostaj> if null is on the outside of a composition, and an infinite list is being filter inside... will null terminate as soon as it sees an element?
00:51:35 <roostaj> , time $ null [1.100000000000]
00:51:37 <lunabot>  (0.0,False)
00:51:59 <roostaj> , time $ null filter (> 500000) [1..]
00:52:00 <lunabot>  luna: Couldn't match expected type `[a]'
00:52:13 <roostaj> , time $ null . filter (> 500000) [1..]
00:52:14 <lunabot>  luna: Couldn't match expected type `a -> [a1]'
00:52:20 <roostaj> , time $ null . filter (> 500000) $ [1..]
00:52:22 <lunabot>  (9.7985e-2,False)
00:52:24 <Jonno_FTW> what is the question  for 23?
00:52:43 <roostaj> Jonno_FTW: it's long but the short version is : Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
00:52:56 <roostaj> , time $ null . filter (> 50000000) $ [1..]
00:53:02 <lunabot>  Killed.
00:53:09 <roostaj> , time $ null . filter (< 50000000) $ [1..]
00:53:11 <lunabot>  (0.0,False)
00:59:44 <Jonno_FTW> ok
00:59:48 <Jonno_FTW> i got stuck on 23 as well
01:00:54 <Jonno_FTW> one thing i have
01:01:07 <Jonno_FTW> is that all abundant numbers are either even or divisible by 5
01:01:42 <roostaj> hmm that could help the speed of calculating abundant numbers a bit...
01:01:48 <Jonno_FTW> yep
01:01:58 <Jonno_FTW> also, use prime factorisation to quickly find divisors
01:02:02 <Jonno_FTW> but I don'
01:02:20 <roostaj> yeah my divisor algorithm could use a juicing
01:02:25 <Jonno_FTW> t know how to see if the integer is the sum of 2 abundant numbers
01:02:33 <Jonno_FTW> divisors = init . map product . sequence . map (\(x,y) -> map (x^) [0..y]) . primePowerFactors
01:02:35 <roostaj> ah
01:02:39 <roostaj> my method is terrible
01:02:51 <Jonno_FTW> abundant  n = (sum' $ divisors n) > n
01:03:19 <roostaj> i'll hpaste it if you want to take a look
01:03:24 <Jonno_FTW> ok
01:04:05 <roostaj> if hpaste will load
01:05:46 <roostaj> lol i think my euler023 is hogging the cpu
01:06:41 <roostaj> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14379#a14379
01:06:41 <Jonno_FTW> hehehe
01:06:50 <roostaj> its bad
01:07:14 <roostaj> i wrote divisors on a whim thinking it would be fast enough
01:07:21 <roostaj> it probably is
01:07:25 <roostaj> euler023 is the problem
01:07:45 <Jonno_FTW> yep
01:07:51 <Jonno_FTW> i suggest using prime factorisation
01:08:36 <roostaj> i ran takeWhile (< 28123) abundantNumbers and it finished reasonably
01:08:45 <roostaj> so i'm not too concerned there
01:08:50 <Jonno_FTW> hmm
01:08:57 <Jonno_FTW> i'll see how fast i get it
01:09:12 <roostaj> ive been runnig for 10 minutes and havent gotten a response yet
01:09:53 <Jonno_FTW> *Main Data.Char> time $ print (length abundance)
01:09:55 <Jonno_FTW> 130873
01:09:57 <Jonno_FTW> Computation time: 3.104419900 sec
01:10:19 <roostaj> =\
01:10:24 <Jonno_FTW> :d
01:10:56 <roostaj> divisors damn you
01:11:07 <Jonno_FTW> MUAHAHAH
01:12:00 <roostaj> abundance is your abundantNumber to 28123?
01:12:15 <Jonno_FTW> yes
01:13:25 <roostaj> run (takeWhile (< 28123) abundantNumbers) using my abundantNumbers and time it
01:13:32 <roostaj> use your machine as a benchmark for my divisors
01:13:35 <roostaj> lo
01:13:35 <roostaj> l
01:13:59 <Jonno_FTW> what are your specs?
01:14:30 <roostaj> athlon 64 3500+ 2.2 GHz 1 GB RAM
01:14:42 <roostaj> DDR1
01:14:42 <roostaj> lol
01:15:11 <Jonno_FTW> i have intel core 2 duo p8400 2.2GHz 2GB RAM
01:15:16 * roostaj grumbles
01:16:11 <kmc> you should parallelize whatever it is that you're doing
01:16:19 <kmc> http://donsbot.wordpress.com/2009/09/05/defun-2009-multicore-programming-in-haskell-now/
01:16:32 <roostaj> kmc: it isn't necessary, and I am ashamed
01:16:39 <roostaj> :(
01:17:01 <roostaj> it finished!
01:17:02 <roostaj> omg
01:17:12 <Jonno_FTW> *Main Data.Char> time $ print (length$takeWhile (< 28123) abundantNumbers)
01:17:14 <Jonno_FTW> 6965
01:17:15 <Jonno_FTW> Computation time: 4.212027000 sec
01:17:20 <Jonno_FTW> do really mean 218123?
01:17:35 <roostaj> no
01:17:36 <roostaj> lol
01:17:37 <roostaj> 28123
01:17:38 <roostaj> :)
01:17:41 <roostaj> 4 secs?
01:17:42 <roostaj> not bad
01:18:00 <roostaj> lol i got euler023
01:18:04 <roostaj> only took 20 minutes of cpu time
01:18:07 <kmc> @hoogle time
01:18:08 <lambdabot> package time
01:18:08 <lambdabot> module Data.Time
01:18:08 <lambdabot> module System.Time
01:18:23 <kmc> @hoogle time :: IO a -> IO a
01:18:24 <lambdabot> System.Time normalizeTimeDiff :: TimeDiff -> TimeDiff
01:18:24 <lambdabot> Control.Exception.Base runtimeError :: Addr# -> a
01:18:24 <lambdabot> System.Time addToClockTime :: TimeDiff -> ClockTime -> ClockTime
01:18:38 <kmc> use-less
01:18:53 <roostaj> kmc: that hurts my feelings
01:19:04 * roostaj grumbles
01:19:09 <kmc> Jonno_FTW, where did you get this "time"?
01:19:25 <kmc> roostaj, hoogle is useless, not you
01:19:30 <roostaj> kmc: :D
01:19:53 <kmc> although if i had your computer and sold it, i bet i could not buy even one decent crack rock
01:20:03 <Twey> Haha
01:20:24 <roostaj> :)
01:21:06 <roostaj> Jonno_FTW: i would also like to know where "time" is
01:23:36 <matt_f> Jonno_FTW: I just attempt that problem and gave up
01:23:40 <matt_f> euler 23 right?
01:24:18 <roostaj> matt_f: yes
01:24:44 <roostaj> matt_f: you can use my algorithm if you have 30-60 minutes
01:24:46 <roostaj> kik
01:24:48 <roostaj> lol
01:25:43 <matt_f> haha i think mine would take longer LOL
01:25:51 <matt_f> super brute force
01:26:04 <roostaj> matt_f: let it run overnight :)
01:26:27 <matt_f> i feel bad for my computer it was getting so noisy so i interrupted it
01:26:32 <roostaj> lmao
01:26:33 <stoop> Does Roland Zumkeller hang out here by any chance?
01:26:43 <MoALTz> i feel ashamed when i'm forced to brute-force a projecteuler problem (and then read in the problem thread how people got it done a lot faster)
01:27:03 <roostaj> lol true that
01:27:09 <roostaj> don't read the haskell wiki on problem 23
01:27:13 <roostaj> you will feel sad
01:27:25 <matt_f> haha i will after i solve it
01:28:19 <matt_f> i think my algorithm is something like O(n^323234)
01:28:22 <kmc> 4:20 smoke haskell every day
01:28:56 <kmc> matt_f, hey, still polynomial time
01:29:31 <matt_f> real assuring :)
01:29:43 <kmc> the problem "does graph G contain K as a subgraph?" is NP-complete.  but if you fix K then it's in P
01:30:00 <kmc> O(n^k) where k is the number of vertices in K ;)
01:40:33 <cathper> I have recognized the following two lines of code to eat up most of the cpu cycles of my program:
01:40:36 <cathper> cartesian = mapM (\n -> [0..n])
01:40:38 <cathper> cart dim size = cartesian (replicate dim size)
01:40:56 <cathper> Any suggestions on how I can speed it up?
01:41:20 <mmorrow_> , mapM (\n -> [0..n]) [0..3]
01:41:21 <lunabot>  [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,1,0],[0,0,1,1],[0,0,1,2],[0...
01:42:00 <mmorrow_> cathper: well, what are you doing with the resulting list?
01:42:40 <cathper> `cart dim size' produces { (x_1,...,x_dim) | x_i \in {0,1,...,size} }.
01:43:00 <cathper> mmorrow_: maximizing a function over it.
01:43:00 <mmorrow_> cathper: if you're immediately consuming it and in such a way that ghc doesn't fuse stuff, you can manually fuse your code (slight pita) so the list never exists
01:43:26 <mmorrow_> cathper: right, but what do you do with that list next?
01:43:50 <cathper> mmorrow_: Throw it away, basicly.
01:43:55 <kmc> cathper, so you eval this function over each coordinate in the list, and find the max?
01:44:10 <cathper> kmc: True.
01:44:42 <kmc> so you can call the function directly, rather than calling (:) to build coord-lists, then pattern-matching that (:), and probably using a lot of heap in the process
01:44:49 <kmc> i think that's what mmorrow_ suggested too
01:44:57 <Jonno_FTW> time is some super fantastic thing
01:45:21 <roostaj> Jonno_FTW: but where is it
01:45:53 <Jonno_FTW> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14381#a14381
01:46:00 <Jonno_FTW> it was behind your ear all along
01:46:30 <kmc> hmm, (>>=) in IO is strict in its first argument?
01:47:07 <roostaj> lol thanks
01:47:25 <Jonno_FTW> now you too can time everything
01:47:32 * roostaj puts away the stopwatch
01:47:43 <Jonno_FTW> i had an egg timer originally
01:47:48 <Jafet> :t time
01:47:49 <lambdabot> Not in scope: `time'
01:47:57 <mmorrow> cathper: maintaining being generic in the dimension like you're using the (sub)-lists for won't carry over so well to a faster solution however
01:48:06 <Jonno_FTW> :t System.CPUtime
01:48:07 <lambdabot> Not in scope: data constructor `System.CPUtime'
01:48:17 <Jonno_FTW> :t System.CPUTime
01:48:18 <lambdabot> Not in scope: data constructor `System.CPUTime'
01:48:40 <Jonno_FTW> >System.getCPUTime
01:48:45 <Jonno_FTW> > System.getCPUTime
01:48:46 <lambdabot>   Not in scope: `System.getCPUTime'
01:49:05 <mmorrow> cathper: are most functions you'll be dealing with's domain dim < (say) 8?
01:49:17 <mmorrow> cathper: s/8/a lot/
01:50:19 <mmorrow> cathper: (and are you using linear search? maybe a better algo too (if this is a critical thing))
01:50:20 <kmc> that "time" may be surprising:  do { n <- time $ return (fibs !! 100000); print n }
01:50:40 <kmc> this prints "Computation time: 0.000000 sec", then pauses while it does the computation ;)
01:50:55 * roostaj thinks kmc is cheating the system
01:51:18 <kmc> how so?
01:51:22 * roostaj grumbles
01:51:37 <mmorrow> kmc: it times how long it takes to reduce the value to WHNF
01:51:40 <Jonno_FTW> oh right
01:51:50 <Jonno_FTW> if you are doing it interactively
01:51:53 <Jonno_FTW> things are stored in memory
01:51:54 * roostaj thinks most of his algorithms can be timed using a sun dial
01:51:57 <Jonno_FTW> so it doesn't take time
01:51:57 <mmorrow> i don't see how this can be surprising
01:52:04 <kmc> not to me
01:52:11 <mmorrow> , fst $ time [undefined]
01:52:11 <kmc> but to someone perhaps
01:52:13 <lunabot>  0.0
01:52:16 <Jonno_FTW> this only occurs if you used it before
01:52:19 <Jonno_FTW> say you do
01:52:32 <Jonno_FTW> time $ print (sum [1..1000])
01:52:33 <Axman6> print $! n?
01:52:39 * cathper was off for the phone ... reading, reading ...
01:52:40 <Jonno_FTW> and had already done it before
01:52:43 <Jonno_FTW> it won't take any time
01:52:58 <kmc> "$!" and "seq" will also only reduce to whnf
01:53:25 <Jonno_FTW> feel free to post a revision of time
01:53:42 <kmc> do { n <- time $ return (fibs !! 100000); case rnf n of () -> return (); print n }
01:53:54 <mmorrow> time a = unsafePerformIO (timeItT (return $! a))
01:53:58 <kmc> Jonno_FTW, it's not a matter of it being done before
01:54:01 <kmc> this will happen the first time
01:54:02 <mmorrow> import System.TimeIt(timeItT)
01:54:06 <mmorrow> @hackage timeit
01:54:07 <lambdabot> http://hackage.haskell.org/package/timeit
01:54:11 <Jonno_FTW> hmmm
01:54:15 <Jonno_FTW> works fine for me
01:54:16 <Jonno_FTW> usually
01:54:32 <kmc> because all you are "timing" is to build the thunk representing the return computation
01:54:42 <kmc> it does not actually perform that computation until later
01:55:05 * roostaj pulls out the stopwatch
01:55:10 <mmorrow> a thunk isn't in WHNF
01:55:20 <kmc> that's true
01:55:37 <mmorrow> so you're timing what it takes to arrive at the first constructor
01:55:54 <mmorrow> which in the case of sum/etc is all of the computation
01:56:02 <roostaj> goodnight all
01:56:06 <mmorrow> (sum for Int/etc that is)
01:56:09 <cathper> mmorrow: I will have a hard time telling how large dim is at most.
01:56:41 <mmorrow> cathper: i was thinking maybe to have a different function for each dimension, if this is feasible
01:56:41 <kmc> is there a nicer way to force NF in a monad than "case rnf v of () -> return ()"
01:56:46 <patch-tag> where is the documentation for the LANGUAGE CPP pragma?
01:56:56 <cathper> mmorrow: Linear search through the list takes ~no time compared to building the list, tells ghc's profiling me.
01:57:16 <mmorrow> cathper: well you're building it as you search through it
01:57:26 <cathper> mmorrow: That can be an option.
01:57:29 <Jedai> kmc: () <- return (rnf v)
01:58:10 <Jedai> kmc: then you define (mRnf = return . rnf)
01:58:21 <Jedai> () <- mRnf v
01:58:25 <kmc> fair enough
01:58:27 <Twey> [ () | () <- mRnf v ]
01:58:31 <kmc> hehe
01:58:35 <Twey> Who needs a do-block ☺
01:58:41 <mmorrow> cathper: and then in each of those specialized-to-a-dim functions, you can generate the coords without a list (i.e. manually fuse the code, which may be a slight pain, but much faster)
01:59:01 <cathper> mmorrow: I see.
01:59:11 <mmorrow> cathper: you lose the convenience of the list monad mapM however
02:00:51 <cathper> mmorrow: Right. I can probably live without.
02:01:45 <quicksilver> OK, I finally found out how to write a negative lookahead assertion for parsec
02:01:59 <quicksilver> try (foo >> ((bar >> pzero) <|> return ()))
02:02:13 <quicksilver> which is, kind of, what notFollowedBy does by default, except it has the wrong type.
02:02:27 <sohum> why would a haskell program be blocking?
02:04:14 <Twey> sohum: Err, the same reason any other program is blocking?  :þ
02:04:17 <sohum> oh, never mind, getContents is firing for some reason
02:24:46 <sohum> OptArg in GetOpt works how I'd expect, right? The function from Maybe String -> a is Just String when it was passed and Nothing when it wasn't?
02:26:23 <ivanm> yeah
02:26:45 <ivanm> sohum: cmdargs from ndm looks a lot nicer if you can except dropping support for ghc < 6.10 (since it needs base-4)
02:26:58 <ivanm> *accept
02:27:03 <pao> dcoutts: I find your "StrongTypesandPureFunctions" presentation really interesting... did you have any recorded talk based on it?
02:27:39 <sohum> then why on earth is my trace never getting run...
02:28:12 <ivanm> *shrug*
02:28:44 <pao> dcoutts: ops... I did see the referring blog post only now...  "Video may or may not become available"
02:31:41 <sohum> ivanm: http://pastebin.com/m1b2851ec is what the code looks like. calling it with -p <filename> -i <filename> still blocks on getContents and never runs the trace
02:32:12 <patch-tag> I defined a compiler pragma using
02:32:21 <patch-tag> #elif _SOMEVAR in a file.h header, in a cabal package. (darcs in fact)
02:32:22 <lunabot>  luna: Not in scope: `elif'
02:32:33 <ivanm> sohum: what's readFileAndName ?
02:32:36 <patch-tag> Can I set _SOMEVAR to true with an argumetn to cabal install, or do I have to do additional tweaking in the cabal file for this to work?
02:33:02 <sohum> ivanm: strength . (id &&& readFile). it works perfectly for the -p option.
02:33:03 <patch-tag> specifically i'm trying to turn off hard linking, on a unix box (the patch-tag server)
02:33:10 <ivanm> what's strength ?
02:33:11 <patch-tag> cause it's causing problems
02:33:32 <ivanm> sohum: ummm... what's setInst?
02:33:35 <patch-tag> http://allmydata.org/trac/darcs-2/browser/src/maybe_relink.c
02:33:51 <ivanm> sohum: IIRC, the traced message won't show if the value isn't used... (i.e. still a thunk)
02:33:57 <sohum> ivanm: strength ∷ Functor f ⇒ (a, f b) → f (a, b). basically in this case (String, IO String) -> IO (String, String)
02:34:09 <ivanm> ahhh, OK
02:34:22 <sohum> ivanm: setInst is what you'd expect, setInst i o = o { inst = i }
02:34:47 <ivanm> sohum: not sure how well trace works for functions...
02:34:50 <ivanm> or in IO
02:35:03 <ivanm> IIRC, I've had problems getting trace to work in IO (unless its in a let statement)
02:35:04 <sohum> ivanm: and yea, I'm not /expecting/ it to be a thunk, because I force evaluation of i
02:35:53 <sohum> ivanm: given what it prints i out as, it seems like it's keeping the inst field unchanged from what it is in defaultOptions
02:36:03 <ivanm> *nod*
02:36:07 <sohum> ivanm: i.e, "stdin", <whatever I typed in>
02:38:53 <quicksilver> sohum: not sure what you expect
02:39:02 <quicksilver> sohum: if you force all of getContents it will hang until EOF, yes
02:39:06 <quicksilver> that's what getContents does.
02:39:18 <sohum> quicksilver: but it /shouldn't/ be getContents
02:39:25 <quicksilver> oh
02:39:51 <quicksilver> sorry misunderstood your question then :)
02:39:55 <sohum> quicksilver: given that getopts works correctly, the foldl line should've replaced the inst field with a non-getContents using function
02:40:06 <sohum> quicksilver: at least, as far as I understand it
02:42:06 <sohum> quicksilver: which is clearly incorrect somehow, because I probably haven't found a bug in getopt... :P
02:46:58 <mmorrow> sohum: try ==> trace "here" . setInst
02:47:30 <mmorrow> sohum: well, actually that may not change anything
02:47:53 <mmorrow> sohum: bottom line is that if it isn't getting printed then it's not getting forced
02:48:10 <sohum> mmorrow: yea, I was about to say, I doubt that'll help
02:48:16 <mmorrow> it's just kind of unclear what exactly needs to be forced in your example
02:48:37 <sohum> hm. arright, lemme see if I can pull up a minimal working case
02:49:46 <mmorrow> sohum: what were the command line args and what was the output for the paste you showed
02:49:47 <mmorrow> ?
02:50:23 <mmorrow> err, wait. what do the colors mean? (i assumed they meant was/wasn't evaluated, but i just realized that i'm not looking at HPC output..)
02:50:42 <sohum> mmorrow: exactly what you'd expect if setInst was never being called. i.e, blocking on getContents, and printing out ("stdin", <what I typed>)
02:51:19 <mmorrow> sohum: what command line args did you give?
02:51:29 <sohum> mmorrow: -p <filename> -i <filename>
02:54:09 <mmorrow> sohum: possibly readFileAndName is returning Nothing
02:54:37 <mmorrow> i mean, it must be, right?
02:54:41 <sohum> mmorrow: it returns an IO (FilePath, String). hold up, I have a minimal testcase
02:54:57 <mmorrow> oops, n/m
02:55:06 <mmorrow> readFileAndName is in the Just case..
02:57:31 <sohum> mmorrow, ivanm: minimal testcase here: http://pastebin.com/m4480d7b9
02:58:09 <sohum> whether you pass it the -t option or not, it prints stdin
02:59:11 <mmorrow> sohum: (haven't looked yet) i'd do
02:59:13 <mmorrow> (\x opts -> let !o = traces "here" (setInst (readFileAndName x) opts) in return o)
02:59:29 <mmorrow> because it's almost impossible to know what's going on with all those (.)s
03:01:06 <ivanm> mmorrow: agreed
03:04:12 <mmorrow> sohum: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14385#a14385
03:05:11 <mmorrow> don't ask me why..
03:05:20 <sohum> that works?
03:05:50 <mmorrow> yup, it's Nothing
03:06:08 <sohum> it's /always/ Nothing
03:06:31 <mmorrow> um
03:06:49 <sohum> whether I pass the -t argument or not
03:06:56 <mmorrow> right
03:07:04 <mmorrow> i don't know why
03:10:23 <mmorrow> sohum: ok, i think i know what's going on. apparently OptArg only works like --thingy=foo
03:10:47 <mmorrow> it doesn't consider "-t foo" to be giving -t an arg
03:11:05 <sohum> mmorrow: but.. that syntax works fine for ReqArg's...
03:11:19 <mmorrow> yeah, i'm not sure if this is on purpose or not
03:11:34 <mmorrow> sohum: i'd read the GetOpt code
03:12:04 <mmorrow> http://darcs.haskell.org/libraries/base/System/Console/GetOpt.hs
03:13:33 <sohum> mmorrow: the usageInfo command they define seems to say that it supports -t<argument> only
03:14:17 <mmorrow> ahh, that works
03:14:29 <mmorrow> well, good to know
03:14:40 * mmorrow notes this for future use of GetOpt
03:14:51 <sohum> mmorrow: and for reqargs -t <arg> only
03:14:56 <mmorrow> heh
03:15:01 <sohum> mmorrow: so it does seem to be intentional, if awful
03:15:08 * sohum goes to file a bug report
03:15:45 <ivanm> sohum: oh, short options? yeah, AFAIK that's "standard" for optional args in GNU stuff, etc.
03:15:55 <ivanm> though it would probably be a good idea to accept -t=foo as well
03:15:56 <Baughn> Oh, this is wonderful..
03:16:14 <sohum> ivanm: it does. it doesn't accept -t foo for optional args, though
03:16:26 <mmorrow> ivanm: for optional args, "-t foo" doesn't work, but "-tfoo" and "--<t-long>=foo" do
03:16:31 <ivanm> yeah
03:16:38 <mmorrow> but for required args, "-t foo" works
03:16:45 <mmorrow> (is this what you understood?)
03:16:45 <ivanm> my guess is because if you have "-t foo", it's hard to tell if the foo belongs to the -t or not
03:16:51 <ivanm> Baughn: what?
03:16:52 * Baughn curses all asynchronous exceptions
03:16:54 <sohum> and is infact recommended
03:16:56 <ivanm> mmorrow: yup
03:17:16 <Baughn> ivanm: Basically, bracket is being annoying. If I have a thread blocked in the "acquire resource" stage of that, then killThread doesn't work.
03:17:22 <mmorrow> ivanm: but why is it harder for optional args than for required args?
03:17:23 <ivanm> yeah
03:17:28 <Baughn> ivanm: Admittedly, /making/ it work is semantically hard.
03:17:34 <ivanm> mmorrow: required args _have_ to have that value
03:17:36 <mmorrow> because it would have to check if "foo" begins with a '-'?
03:17:41 <sohum> @hoogle String
03:17:42 <lambdabot> module Data.String
03:17:42 <lambdabot> module Foreign.C.String
03:17:42 <lambdabot> module Text.Parsec.String
03:17:46 <ivanm> mmorrow: if I have "-t -t" with -t being optional, how should it parse it?
03:17:51 <sohum> @hoogle newline
03:17:51 <lambdabot> Text.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
03:17:51 <lambdabot> Text.ParserCombinators.Parsec.Char newline :: Stream s m Char => ParsecT s u m Char
03:17:51 <lambdabot> Text.Regex.Posix.ByteString compNewline :: CompOption
03:17:55 <ivanm> especially since I don't think the parser it uses has backtracking
03:18:02 <mmorrow> ivanm: -t "-t" if you mean it as an arg
03:18:10 <ivanm> hmmm...
03:18:37 <sohum> ivanm: I don't think that's a common enough case to disallow spaces for optionals for.
03:18:56 <ivanm> sohum: OK, fine, different case
03:19:14 <ivanm> say you accept a filename (without an explicit arg)
03:19:24 <ivanm> but you have an optional second filename as well
03:19:38 <mmorrow> ok
03:19:40 <ivanm> so is -t foo.txt parsing the foo.txt as the optional one or not?
03:19:45 <sohum> as the optional
03:19:48 <ivanm> as I said, I guess most of this is to simplify parsing
03:19:59 <ivanm> sohum: so how would you do it if you want it to be the required one?
03:20:12 <sohum> ivanm: you wouldn't have the "-t"?
03:20:27 <DigitalKiwi> does haskell have anything like pythons optparse module?
03:20:37 <mmorrow> i haven't actually ever used OptArg before, nor can i think of a standard utility that has a flag with an optional arg that has a short version
03:20:55 <mmorrow> DigitalKiwi: System.Console.GetOpt
03:20:58 <mmorrow> ?
03:21:03 <ivanm> sohum: but you want the effects of -t without the optional arg
03:21:25 <ivanm> mmorrow: agreed; optional flags are usually better expressed with the full arg
03:21:32 <DigitalKiwi> mmorrow: I dunno you tell me ;D
03:21:36 <ivanm> DigitalKiwi: or cmdargs on hackage (which needs base-4)
03:21:37 <sohum> ivanm: ... wait wait wait. ReqArg and OptArg are for the /arguments/ of those options, not for those flags themselves!
03:21:41 <sohum> ivanm: I am an idiot
03:21:47 <ivanm> DigitalKiwi: I don't know about mmorrow, but I have no idea what optparse is
03:21:54 <ivanm> sohum: yup
03:22:01 <mmorrow> DigitalKiwi: the "?" since i don't know what python's does, but if it is what i'd expect then that's the answer :)
03:22:05 <ivanm> you are
03:22:05 <ivanm> ;-)
03:22:06 <DigitalKiwi> http://docs.python.org/library/optparse.html#module-optparse
03:22:17 <DigitalKiwi> it's more cool than just getopts
03:22:40 <ivanm> DigitalKiwi: don't nkow enough python to be able to tell
03:22:45 <ivanm> but as I said, there's also cmdargs
03:22:51 <mmorrow> ivanm: you have a point in the "-t foo.txt" case, it's impossible to have foo.txt not connected to -t if you allow "-t arg" where arg is optional
03:22:54 <ivanm> (and a couple of other options on hackage IIRC)
03:23:14 <DigitalKiwi> well you don't have to know python to look at that website and be like "oh yeah xxx does that"
03:23:18 <ivanm> mmorrow: yup; never underestimate the stupidity of your users (both end users and people using your library) ;-)
03:23:32 <ivanm> DigitalKiwi: I have to know python to be able to compare syntax, features, etc. ...
03:23:39 <DigitalKiwi> not really
03:23:47 <ivanm> DigitalKiwi: and surely it's up to _you_ to see if getopts and cmdargs matches what you want/expect
03:24:08 <ivanm> (since, after all, why should we _care_ what python has?)
03:24:15 <DigitalKiwi> it explains on that site everything it does, even more than just looking at the code, which is pretty self-explanatory
03:24:48 <DigitalKiwi> I don't care what python has either, I don't use it, that's just a cool feature it has that would be nice if someone had implemented in haskell :)
03:25:03 <ivanm> what cool feature?
03:25:07 <ivanm> it's a _library_ AFAICT
03:25:19 <ivanm> and why should we have exactly the same API, etc.?
03:25:20 <Jonno_FTW> > let comp x y | (length x) == (length y) =  error "Not equal length"  | x == y = 0  | x /= y = 1 in comp [1] [1]
03:25:21 <lambdabot>   * Exception: Not equal length
03:25:30 <Jonno_FTW> how the hell does that not work?
03:25:41 * ivanm mumbles something about annoying sheep-lovers...
03:25:47 <DigitalKiwi> I'm not saying you should...
03:26:09 <DigitalKiwi> I'm not actually from new zealand, and I don't hump sheep, tyvm
03:26:10 <ivanm> Jonno_FTW: ummm... their lengths are equal
03:26:15 <ivanm> so it returns the first value
03:26:18 <ivanm> I don't see your problem
03:26:19 <Jonno_FTW> oh right
03:26:24 <ivanm> DigitalKiwi: my sincere apologies then
03:26:26 <Jonno_FTW> silly me
03:26:30 <ivanm> (I was j/k anyway)
03:26:47 <ivanm> (the apology was for assuming you were a kiwi)
03:27:23 <ivanm> Jonno_FTW: haskell's type system picks up _some_ silly programmer errors, not all of them ;-)
03:27:24 <Twey> DigitalKiwi: Looks like GetOpt to me…
03:27:34 <Twey> GetOpt does all this stuff
03:27:56 <DigitalKiwi> so GetOpt does more than like C getopt then?
03:28:13 <Jonno_FTW> where can i get an english interpreter to pick up such errors??
03:28:25 <Jonno_FTW> i'd like to integrate so it picks up such errors
03:29:02 <sohum> Jonno_FTW: if you find one, send it my way please?
03:29:06 <Twey> DigitalKiwi: I don't really know how C getopt works
03:29:10 <Twey> DigitalKiwi: But presumably ☺
03:29:13 <DigitalKiwi> man getopt ;)
03:29:30 <ivanm> DigitalKiwi: again, if you want to do such a comparison, go ahead
03:29:31 <Twey> DigitalKiwi: http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
03:29:50 <Twey> It's very flexible
03:30:02 <Twey> Even moreso than that Python one, at least from what I saw just then
03:30:24 <ivanm> Twey: you had a look at cmdargs?
03:30:52 <Twey> ivanm: Ooh, that looks nice
03:30:57 <ivanm> yeah
03:31:01 <Twey> Yes, the verbosity of GetOpt has always been an annoyance for me
03:31:02 <ivanm> base-4 only though...
03:31:10 <ivanm> and the implementations rather hacky (with the ioref, etc.)
03:31:12 <DigitalKiwi> ivanm: a lot of languages implement at least a basic getopt, and getopt from C is about as basic as it gets, and is the most common so they try to emulate it
03:31:15 <ivanm> IIRC, it's unsafe... >_>
03:31:20 <Twey> Eek
03:31:40 <DigitalKiwi> so I'm just curious what haskell has to offer, and it looks like 'a lot'
03:31:48 <ivanm> DigitalKiwi: right; but we're happy (well, maybe not "happy" per-se) using haskell's getopts; why should I care that it emulates C's getopt?
03:32:07 <DigitalKiwi> grr
03:32:12 <DigitalKiwi> you are completely missing the point
03:35:00 <DigitalKiwi> all I wanted to know was what kind of features/ease of use haskell has available for option parsing...
03:35:04 <DigitalKiwi> thanks
03:35:30 <Twey> DigitalKiwi: GetOpt is very featureful and rather elegant, if a little awkward to use sometimes
03:35:31 <ivanm> and we told you: getopt and cmdargs
03:35:45 <mmorrow> DigitalKiwi: um, all the ones you'd expect :)
03:35:45 <ivanm> you could have just asked, without pestering us if they matched the "feature" that python had
03:35:55 <ivanm> Twey: agreed
03:35:58 <sohum> I think what DigitalKiwi is trying to say is that he assumed that GetOpt was a basic wrapper around C's getopt and thus not relevant to his question
03:36:11 <ivanm> well, that's what docs are for...
03:36:14 <Twey> (note, though, that the Haskell language itself makes simple option-parsing from a list of strings much easier than in other languages — you may not need an option-parsing library at all)
03:36:21 <ivanm> DigitalKiwi: if you want to know how to _use_ getopt, see the RWH chapter
03:36:21 <DigitalKiwi> mmorrow: well you're over estimating what I'd expect, in lua I had to implement it myself :)
03:36:39 <mmorrow> DigitalKiwi: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/System-Console-GetOpt.html
03:36:40 <Twey> Lua is a light-weight language
03:36:42 <Twey> Haskell is not
03:36:48 <ivanm> Twey: well, GetOpt is nice for doing the actual command line parsing for you and converting it to a more usable format
03:36:49 <sohum> very much not :P
03:36:57 <ivanm> heh
03:37:25 <osaunders> What constitutes a light-weight language?
03:37:39 <Twey> osaunders: One that includes minimalism in its goals ☺
03:37:57 <DigitalKiwi> 200kb interpreter
03:38:04 <Raynes> osaunders: One that guarantees you can lift it with one hand.
03:38:06 <sohum> my personal definition is "one which can be described in a number of pages within an order of magnitude of scheme"
03:38:29 <Twey> DigitalKiwi: In fact, even so there are a bunch of libraries for option-parsing on LuaForge
03:38:43 <DigitalKiwi> yeah, most of them weren't that great :(
03:38:55 <idnar> Lua just has a light-weight implementation
03:39:01 <DigitalKiwi> I just made a lua version of getopt_long and it works wonderfully
03:39:16 <idnar> I wouldn't say there's anything light-weight about the language itaelf
03:39:35 <idnar> *itself
03:39:44 <Twey> idnar: Eh?
03:39:53 <DigitalKiwi> it's a pretty powerful language considering it's size
03:40:30 <Twey> It aims for minimalism.  Not quite in a Scheme sense, since it has a lot of syntax, but rather than piling features on willy-nilly, it attempts to provide common ground for users to implement things themselves.
03:40:41 <ivanm> is this another case of people taking descriptions of the default/only implementation of a language and generalising it for the entire language?
03:41:07 <Twey> I don't know what idnar was talking about.  I was speaking of the language itself, not anything to do with any implementation.
03:41:23 <Twey> I guess DigitalKiwi mentioned one implementation, but that could be taken as an example.
03:41:27 <sohum> hm. are javascript and lua related?
03:41:29 <ivanm> fair enough
03:41:35 <Twey> sohum: Loosely
03:41:47 <DigitalKiwi> hasn't lua been around longer?
03:41:48 <Twey> They're quite similar, but they came about in fairly different ways
03:42:13 <sohum> they both have prototypal inheritance, right?
03:42:17 <ivanm> apparently lua is two years older
03:42:25 <DigitalKiwi> lua 1993, javascript 1995
03:42:25 <Twey> sohum: Yeah
03:42:34 <Twey> Javascript is kind of like a corrupted Lua
03:42:36 <Jonno_FTW> i get annoyed when people think javascript is based on java
03:42:46 <Twey> Jonno_FTW: You and everyone else
03:42:46 <idnar> the language itself is way more convoluted than I'd be willing to call "lightweight"
03:42:47 <Jonno_FTW> the only similarity is syntax
03:43:08 <idnar> Jonno_FTW: that's not even that similar
03:43:12 <ivanm> Jonno_FTW: that and netscape wanted to cash in on java's popularity at the time...
03:43:16 <sohum> Twey: why corrupted? I've been hacking on it lately and it's actually really nice, if you ignore the DOM and the lack-of-automatic currying :P
03:43:28 <idnar> Jonno_FTW: I'd say the only similarity is the name :)
03:43:33 <Jonno_FTW> hohoho
03:43:37 <ivanm> and the syntax is more from being based on C++ (since according to wikipedia, C++ influenced javascript...)
03:43:41 <Twey> sohum: Javascript has a lot more magic for things that are first-class citizens in Lua
03:43:59 <sohum> Twey: ooh. example?
03:44:00 <Twey> Like its ‘constructor functions’ and the magic ‘new’ keyword
03:44:04 <idnar> sohum: there's so many stupid corner cases
03:44:09 <Twey> Yeah
03:44:16 <Twey> Javascript is a bit conflicted about its OO model, too
03:44:28 <Twey> It has some sort of classical/prototypical hybrid
03:44:30 <DigitalKiwi> at least it has one!
03:44:34 <wm_eddie> yeah.
03:44:53 <Twey> (which unfortunately really screws things up for both models — they don't mix well)
03:44:56 <DigitalKiwi> blasted lua makes you pick one you can actually enjoy using ;D
03:45:10 <Twey> DigitalKiwi: Wha'?
03:45:11 <sohum> I ... don't think I've encountered 'new' in js?
03:45:23 <Twey> sohum: You haven't been hacking on it much, then :þ
03:45:38 <DigitalKiwi> Twey: lua doesn't have built in oo, so people roll their own, and thus get to pick whichever one they like :)
03:45:39 <idnar> shoum: like Array("foo") is ["foo"], Array(1, 2) is [1, 2], but Array(3) is [undefined, undefined, undefined]
03:45:48 <Twey> DigitalKiwi: Lua does have built-in OO.
03:46:04 <idnar> er, and I forgot the new, but you know what I mean
03:46:10 <sohum> Twey: oh, /ew/. why would you even use that?
03:46:28 <Twey> sohum: Because it's the only way to work with JS's prototype magic
03:46:56 <sohum> that's silly. you're silly, javascript.
03:46:58 <Twey> Recent Mozilla implementations have hacked on a read-write __proto__ property to objects so that you don't have to use constructors to set a prototype any more
03:47:11 <Twey> But everything else still requires one (and __proto__ is not really an elegant solution, anyway)
03:47:55 <sohum> yea, ok, you've convinced me :P
03:48:12 <sohum> I thought we had a good thing going, js :( why'd you gotta be like that?
03:48:16 <Twey> Hehe.
03:48:33 <osaunders> Without prototype JS wouldn't be much of a language.
03:48:40 <osaunders> *prototype-OO
03:48:46 <DigitalKiwi> Twey: not reall to the extent of other languages, sure you have : but classes, inheritance, etc. have to be made
03:49:03 <Twey> DigitalKiwi: You're really missing the point of prototypical OO, huh :þ
03:49:14 <DigitalKiwi> no...
03:49:26 <Twey> Prototypical OO means that you don't have classes.
03:49:39 <DigitalKiwi> http://www.lua.org/pil/16.1.html
03:49:54 <Twey> Objects inherit directly from other objects, which can be done with metatables alone.
03:51:08 <Twey> That's an implementation of class-based OO, on top of prototypical OO.
03:51:21 <DigitalKiwi> right
03:51:29 <Twey> You can do this because prototypical OO is more powerful.  Class-based OO can be implemented using prototypical OO, but not vice versa.
03:51:39 <osfameron> not true
03:52:04 <osfameron> with sufficiently powerful meta-model, you can do Prototype OO in class-based OO
03:52:13 <Twey> (and it's a travesty to do so: something like hacking a PC to behave like an AMSTRAD word-processor, as I mentioned in #lua the other day)
03:52:23 <Twey> osfameron: Well, yes, point
03:52:28 <DigitalKiwi> lets start over, lua is cool because it lets you pick how you want to handle - or not handle - object orientedness, instead of someone telling you "ok this is how it is deal or get out"
03:52:32 <Twey> I guess I was referring to Java-style.
03:53:05 * osfameron only really knows prototype OO from Javascript, where it's a massive, overcomplicated, pile of arse, with many traps for the unwary
03:53:08 <Twey> But a ‘class’ in prototype terms is basically an object that can't be used as an object in itself
03:53:10 <osfameron> oh, and Inform, which is cute
03:53:44 <Twey> osfameron: It's simple in JS, too; the overcomplication is where they've hacked bits of classical OO in (or squashed bits of prototypical OO to look like classical OO)
03:54:00 <osfameron> Twey: the function generator things are weird
03:54:11 <osfameron> and the "new" keyword... I guess that's one of the hacked bits
03:54:20 <osfameron> and .prototype versus .constructor etc.
03:54:25 <Twey> Yeah
03:54:27 <osfameron> it's vastly more complicated than Inform anyway...
03:55:00 <Twey> osfameron: You can do pure prototypical using just objects and functions, not touching any of the magical stuff
03:55:19 <Twey> The problem is that then you can't interoperate with things that don't work that way
03:55:29 <Twey> (also, not using .prototype is a massive performance hit)
03:55:46 <osfameron> I need to reread "The Good Parts" at some point
03:56:00 <osfameron> but right now I mainly just use jQuery for web-javascript, and don't do anything else complicated with it...
03:56:14 <Twey> Crockford (and everyone else) bit the bullet on JS' OO
03:56:18 <osaunders> Good Parts barely discusses OO. It mentions the new keyword only to say that's bad.
03:57:23 <McManiaC> can you put class constrictions into a type definition?
03:57:26 <sohum> Twey: do you know if the js community feels this is something that needs to be fixed?
03:57:45 <zygoloid> sohum: they're awake?
03:57:46 <Twey> sohum: Half the JS community wants to introduce real classes
03:57:51 <jkff> Funny, the shootout program for pidigits turned out to be trivial to speed up a bit. Let us see if it speeds up on the benchmark machines, too. /me has submitted the program
03:58:07 <Twey> Luckily, I think Eich managed to shout them down for JS2
03:58:20 <osaunders> McManiaC: What's a constriction?
03:58:22 <Twey> There are meant to be some improvements, though I've lost the slideshow
03:58:32 <sohum> Twey: so status quo, more or less?
03:58:35 <McManiaC> type (Monad m) => foo = m -> m a
03:58:41 <McManiaC> or something equally
03:58:52 <Twey> They'll be adding some cool stuff
03:58:59 <sohum> McManiaC: not on type synonyms (what you introduce with 'type')
03:59:03 <Twey> The main problem is that we won't see it in IE for years yet
03:59:15 <Twey> So anyone wanting compatibility will have to keep using the old stuff…
03:59:20 <zygoloid> McManiaC: yes, as a GHC extension
04:00:07 <sohum> McManiaC: oh, yea, I suppose you could enable that extension
04:00:15 <sohum> rankntypes, I think
04:00:21 <McManiaC> hmm
04:00:36 <McManiaC> ah, its type foo = (Monad m) => ...
04:00:37 <zygoloid> McManiaC: you write it as: type Foo = (Monad m) => m () -> m a
04:00:42 <sohum> McManiaC: normally, though, if you're doing something like that, you want a newtype instead
04:00:44 <McManiaC> ok cool, thx
04:01:14 <zygoloid> McManiaC: the relaxed rules which GHC uses in this case is basically just a hygienic substitution for the body of the 'type'.
04:01:40 <sohum> Twey: that's a shame... any recommendations for a resource that goes in detail about these warts?
04:01:53 <McManiaC> hygienic substitution?
04:02:02 <Twey> I think The Good Parts is probably worth a read, sohum
04:02:13 <Twey> (I haven't read it myself, but I hear it's good)
04:02:34 <zygoloid> McManiaC: substitution, but the introduced tyvars (like 'm' and 'a') are replaced with new unique variable names
04:02:39 <sohum> zygoloid: hygienic in the sense of not inadvertently capturing outer variables, right?
04:02:54 <sohum> zygoloid: right, awesome. lisp /is/ useful :P
04:03:09 <sohum> Twey: thankee
04:03:11 <McManiaC> hmmm okay
04:04:44 <osaunders> I think the window cleaners are leaving. Thank god.
04:10:59 <DigitalKiwi> thanks everyone
04:11:03 <DigitalKiwi> even you ivanm
04:11:10 <ivanm> heh
04:21:13 <BrianB04> Morning all.
04:29:07 * hackagebot upload: lhs2tex 1.15 - Preprocessor for typesetting Haskell sources with LaTeX (AndresLoeh)
04:29:23 <thinkmore> So for fun I unletted all my ghci bindings.
04:29:38 <thinkmore> This is my work thus far (trying to solve a problem purely using basic functions)
04:30:00 <thinkmore> \a ->  foldl (zipWith (++)) (repeat []) (filter (not . foldl (&&) True . map (all (=='.'))) (map (filter (/=[]) . split '#') $ lines a))
04:30:00 <thinkmore> \a ->  foldl (zipWith (++)) (repeat []) (filter (not . foldl (&&) True . map (all (=='.'))) (map (filter (/=[]) . split '#') $ lines a))
04:30:18 <thinkmore> Dunno why it posted twice, but my god it works thus far.  lmao!
04:30:24 <thinkmore> I'm scared of what haskell is doing to me
04:30:55 <ziman> @src and
04:30:55 <lambdabot> and   =  foldr (&&) True
04:31:37 <thinkmore> I'm trying to solve this as difficultly as possible (well for the parsing.  The resulting tree structure will make this cake.)  http://dwite.ca/questions/portals_redux.html
04:31:44 <thinkmore> Just for fun
04:31:52 <thinkmore> Now I need to go crash.  This is probably not healthy lol
04:31:55 <thinkmore> Lates!
04:32:22 <BrianB04> thinkmore: See ya. Oh, Haskell messes with you in ways no language should, probably why I love it.
04:33:02 <thinkmore> BrianB04, Ah, this is exactly why I love haskell.  I CAN do this shit  =P
04:33:21 <BrianB04> thinkmore: But should you is the question. That's looking close to Perl code;)
04:33:25 <thinkmore> What's funny is making my beloved split function took longer than that block of code.  Ha.  I'm a noob at doing real coding
04:33:26 <thinkmore> LOL
04:33:49 <thinkmore> BrianB04, No.  This would be much easier imperative code.  I just love using as many Data.List functions as I can!
04:36:03 <thinkmore> I actually think I have a different approach lol
04:37:55 <Cale> foldl (&&) True  is a less efficient version of  foldr (&&) True  which is defined as  and  in the Prelude
04:38:13 <thinkmore> > let number = zip [1..] in number $ lines ["Line1","Line2","Line3","LineN"]
04:38:14 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:38:14 <lambdabot>         against inferred type...
04:38:31 <Cale> @src all
04:38:31 <lambdabot> all p =  and . map p
04:38:45 <thinkmore> I'm not completely aware with all of prelude yet  =P
04:38:59 <thinkmore> I had an "ands" defined somewhere with is basically that all
04:39:06 <Cale> and once you replace the  foldl (&&) True  with  and  you can see that you have  and . map (all (=='.'))
04:39:22 <Cale> so that's  all (all (=='.'))
04:39:25 <thinkmore> Ah, but you are making it simpler and easier to read, don't do that  =P
04:39:42 <Cale> hehe :)
04:40:27 <thinkmore> > let number = zip [1..] in number $ lines "Line1\nLine2\nLine3\nLineN"
04:40:27 <BrianB04> thinkmore: So you are golfing haskell code?
04:40:28 <lambdabot>   [(1,"Line1"),(2,"Line2"),(3,"Line3"),(4,"LineN")]
04:40:31 <thinkmore> I might approach it like this
04:40:55 <Cale> Even though it's shorter, I usually avoid (/=[]) for testing if a list isn't empty, since in general, it involves an extra Eq constraint over (not . null)
04:40:59 <thinkmore> BrianB04, That's my real code as a result of me going back in the history of ghci and replacing my variables with their original definitions  =P
04:41:03 <Cale> (though in your case, that may not matter)
04:41:23 <thinkmore> I didn't know about null either  =P
04:41:30 <thinkmore> I saw it today
04:41:45 <thinkmore> Finally actually went over the WHOLE list instead of the cool ones like unfoldr and scanl
04:42:01 <thinkmore> I was trying to define split using unfoldr, I KNOW I DID before but I couldn't re-figure it out without screaming
04:42:14 <Cale> :)
04:42:26 <thinkmore> So I did a boring ass 8 liner (needed a safe tail)
04:43:15 <thinkmore> Eh shit I just finish my intro to cs class and I'm doing fucking haskell over break for 12 hours straight.  If I have a problem, raise your hand.
04:43:28 <Cale> hehe
04:43:39 <thinkmore> Albeit at 8pm to 7am my time
04:43:42 <dbelange> @nixon
04:43:42 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
04:43:57 <thinkmore> lol i love lambdabot
04:44:06 <thinkmore> > putStrLn "I am loved"
04:44:07 <lambdabot>   <IO ()>
04:44:10 <thinkmore> damn you
04:44:30 <thinkmore> The non-io version is too easy
04:44:56 <thinkmore> I must admit infinite lists + zip/zipWith = sex
04:45:12 <thinkmore> They're a 1-2-punch combo
04:45:55 <thinkmore> I need to crash, ugh.  Lates, till tomorrow when i finish this bugger
04:46:07 <Twey> theclaw: A problem?  That's normal.
04:46:09 <Jafet> A fisting fetishist
04:46:17 <Twey> Darn, I hate it when that happens.
04:46:24 <Twey> Sorry, Claw.
04:46:59 <idnar> > map (==[]) []
04:47:00 <lambdabot>   []
04:47:26 <idnar> how does that work? defaulting?
04:47:39 <Raynes> @src map
04:47:40 <lambdabot> map _ []     = []
04:47:40 <lambdabot> map f (x:xs) = f x : map f xs
04:47:48 <Twey> idnar: Just type inference
04:47:58 <Axman6> :t (==[])
04:48:00 <lambdabot> forall a. (Eq a) => [a] -> Bool
04:48:04 <idnar> Twey: how does it pick a type?
04:48:05 <Axman6> :t []
04:48:06 <lambdabot> forall a. [a]
04:48:06 <Twey> That only typechecks if your ([] :: Ord a => [[a]])
04:48:13 <Twey> So that's what it assumes it to be
04:48:19 <Axman6> EQ a*
04:48:23 <Twey> Er, yes
04:48:24 <Twey> Sorry
04:48:28 <ivanm> heya Axman6
04:48:32 <Axman6> o/
04:48:39 <idnar> yeah, but it has to pick a concrete type somehow
04:48:42 <Raynes> \O
04:48:44 <Axman6> Twey: that's what teamwork's all about :P
04:48:50 <Raynes> I have a big head.
04:48:56 <Twey> Defaulting makes the (a :: ())
04:49:05 <Twey> But that's not really relevant, since you never use it
04:49:24 <idnar> the compiler doesn't know you don't use it
04:49:31 <Axman6> :t let ?f = (==[]) in map f []
04:49:32 <lambdabot> forall b. (SimpleReflect.FromExpr b) => [b]
04:49:40 <Axman6> >_<
04:49:43 <Twey> It doesn't break it, whether you use it or not.
04:50:12 <idnar> well, either way, you confirmed my guess about defaulting
04:50:23 <Twey> :t let ys = map (== []) xs; xs = [] in xs
04:50:24 <lambdabot> forall a. [a]
04:50:36 <Twey> Huh.
04:50:49 <Twey> I expected an Eq => [[a]] there.
04:51:40 <Axman6> > let nums = 1 : map succ nums in nums
04:51:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:53:06 <idnar> Axman6: cute
04:53:49 <Axman6> > let nums a = a : map succ (nums a) in nums 0
04:53:50 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:54:03 * Axman6 is bore
04:54:05 <Axman6> d
04:57:50 <Jafet> Let's play sylver coinage
04:57:51 <Axman6> > let nums a = a : map succ (nums a) in nums minBound
04:57:52 <lambdabot>   [(),* Exception: Prelude.Enum.().succ: bad argument
04:57:59 <Jafet> 5
04:58:15 <Axman6> > let nums a = a : map succ (nums a) in nums minBound :: [Word]
04:58:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
04:59:30 <Axman6> > let nums a = a : map succ (nums (succ a)) in nums minBound :: [Word]
04:59:31 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
04:59:41 <Axman6> obviously
05:14:39 <Lemmih> @seen dcoutts
05:14:39 <lambdabot> Unknown command, try @list
05:17:46 <ivanm> preflex: seen dcolish
05:17:46 <preflex>  dcolish was last seen on #haskell 12 days, 19 hours, 52 minutes and 7 seconds ago, saying: does a graphics library currently exist that allows me to render a data stream rather than static data?
05:17:48 <ivanm> preflex: seen dcoutts
05:17:48 <preflex>  dcoutts was last seen on #haskell 1 day, 19 hours, 47 minutes and 50 seconds ago, saying: tibbe: mm
05:17:50 <ivanm> ^^ Lemmih
05:18:11 <ivanm> @slap dcolish for having a nick that completes before dcoutts' does
05:18:11 * lambdabot secretly deletes dcolish for having a nick that completes before dcoutts' does' source code
05:18:13 <Jonno_FTW> hazah! after hours of toiling i implemented a bitwise XOR
05:19:15 <Jonno_FTW> bitwiseXOR a b | (length $ decToBin a) > (length $ decToBin b) = bitwise xor ((replicate ((length $ decToBin a) - (length $ decToBin b)) 0)++(decToBin b)) (decToBin a)
05:19:16 <Jonno_FTW>                | (length $ decToBin a) < (length $ decToBin b) = bitwise xor ((replicate ((length $ decToBin b) - (length $ decToBin a)) 0)++(decToBin a)) (decToBin b)
05:19:18 <Jonno_FTW>                | otherwise = bitwise xor (decToBin b) (decToBin a)
05:19:20 <Jonno_FTW> oh the horror
05:19:21 <Lemmih> ivanm: Thanks.
05:19:55 <Jonno_FTW> how can i compress that?
05:20:53 <jps_77> I'm thinking of getting started with Haskell but I'm not sure where to start.
05:21:36 <byorgey> Jonno_FTW: how is that different than plain old 'xor'?
05:21:38 <Jonno_FTW> jps_77: start by reading learn you a haskell
05:21:47 <byorgey> @where lyah
05:21:48 <lambdabot> http://www.learnyouahaskell.com/
05:21:50 <Jonno_FTW> it's not different
05:21:54 <Jonno_FTW> i left a bit out
05:22:06 <Jonno_FTW> xor x y  | x == y = 0    | x /= y = 1
05:22:17 <Jonno_FTW> bitwise f x y = zipWith f x y
05:23:01 <byorgey> Jonno_FTW: hmm?  No, I mean, how is it different from Data.Bits.xor
05:23:08 <Jonno_FTW> i made it
05:23:25 <byorgey> ok, just for fun/to learn?
05:23:28 <Jonno_FTW> plus i can't be bothered to learn how to use that library at the moment
05:23:40 <Jonno_FTW> also for project euler 59
05:23:41 <byorgey> !
05:23:44 <flippo> It was easier to write one?
05:23:49 <Jonno_FTW> yes
05:23:51 <Jonno_FTW> than learn
05:23:53 <ben> no it was not
05:23:57 <ben> stop being terrible :<
05:24:00 <flippo> Baffling
05:24:00 <byorgey> it isn't hard, just  import Data.Bits at the top of your file... then use functions from it like xor
05:24:09 <ben> @type xor
05:24:10 <lambdabot> forall a. (Bits a) => a -> a -> a
05:24:17 <ben> @info Bits
05:24:17 <lambdabot> Bits
05:24:21 <Jonno_FTW> but that would require learning how to use another data type
05:24:22 <ben> >:I
05:24:25 <ziman> jps_77, Real World Haskell is also popular
05:24:27 <ziman> @where rwh
05:24:28 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:24:33 <jps_77> Thanks
05:24:34 <byorgey> Jonno_FTW: no it wouldn't.
05:24:39 <jps_77> Looking at lyah at the moment
05:24:41 <Jonno_FTW> :O
05:25:21 <byorgey> Jonno_FTW: anyway, I am impressed with your effort =)
05:25:30 <Jonno_FTW> it was once even huger
05:25:50 <Jonno_FTW> i ran into problems when the length of one binary number was different to the second
05:25:51 <byorgey> Jonno_FTW: you could probably make it shorter if you represent the lists of bits from least to most significant instead of most to least
05:25:56 <Jonno_FTW> hence the length of the function exploded
05:26:03 <byorgey> then you don't have to do the stuff with adding zeros on the front
05:26:20 <byorgey> oh... well, no, I guess you'd still need a special zipWith function then
05:26:28 <Jonno_FTW> yep
05:26:37 <Jonno_FTW> http://projecteuler.net/index.php?section=problems&id=59
05:26:39 <Jonno_FTW> doing this
05:26:39 <byorgey> one that just copies the longer list
05:27:35 <byorgey> ok, yes, it would have been much easier just to use Data.Bits.xor =)
05:27:49 <Jonno_FTW> ....
05:28:02 <byorgey> xor works for anything in the 'Bits' type class, which includes things like Int, Integer, Char, Bool ...
05:28:08 <byorgey> > True `xor` False
05:28:09 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
05:28:09 <lambdabot>    arising from a use of `Da...
05:28:14 <byorgey> ok, not Bool
05:28:19 <byorgey> > 7 `xor` 23
05:28:20 <lambdabot>   Ambiguous type variable `t' in the constraint:
05:28:20 <lambdabot>    `Data.Bits.Bits t'
05:28:20 <lambdabot>      a...
05:28:24 <byorgey> > 7 `xor` 23 :: Int
05:28:26 <lambdabot>   16
05:29:13 <Jonno_FTW> *XOR> binToDec $bitwiseXOR 7 23
05:29:15 <Jonno_FTW> 16
05:29:26 <Jonno_FTW> i even implemented binary to decimal conversion
05:29:33 <Jonno_FTW> binToDec xs = foldl' (+) 0 $ map (\(x,y) -> x*(2^y) ) $reverse $ zip (reverse xs) [0..]
05:31:14 * Saizan_ was reading $bitwiseXOR as a TH splice
05:32:06 <Jonno_FTW> i think I'll put length$decToBin x in it's own function
05:34:45 <pastah_rhymez> > let netsplit = null
05:34:47 <lambdabot>   not an expression: `let netsplit = null'
05:34:51 <pastah_rhymez> @let netsplit = null
05:34:52 <lambdabot>  Defined.
05:35:00 <tass> Okay.
05:35:19 <tass> So, how would I go about implementing the IRC protocol's 'ACTION'?
05:35:20 <pastah_rhymez> tass: i have an idea for something funny here... hmmm
05:35:40 <tass> This is giving me a headache.
05:35:46 <pastah_rhymez> tass: what's the end game?
05:35:59 <tass> pastah_rhymez: Pardon?
05:36:27 <pastah_rhymez> you wondered how to implement ACTION
05:36:31 <pastah_rhymez> what are you building?
05:36:41 <tass> An IRC bot
05:37:05 <pastah_rhymez> using this http://hackage.haskell.org/package/irc ?
05:37:19 <tass> No sir, I'm rolling my own.
05:38:02 <tass> http://regex.pl/shub-niggurath.hs
05:38:02 * pastah_rhymez wonders if this is an ACTION
05:38:12 <tass> That is an action
05:38:27 <tass> In an IRC Protocol kind of way
05:38:38 <pastah_rhymez> data Message = Text String | Action String
05:39:24 <tass> Well, the thing is, actions are constructed really weird, and there's _something_ I'm missing out on
05:40:18 <tass> They look like this ":nick~!user@hostmask PRIVMSG #channel :ACTION string-of-choice"
05:40:42 <Twey> There is indeed
05:40:48 <Twey> You need a \1 around the action
05:40:58 <tass> Except, there's obviously some invisible characters or something going on, because when I send that to the server, it outputs "ACTION string-of-choice"
05:41:01 <tass> Twey: Oh?
05:41:08 <Twey> ":nick~!user@hostmask PRIVMSG #channel :\1ACTION string-of-choice"
05:41:37 <tass> And that's all?
05:41:41 <Twey> Er
05:41:44 <Twey> I missed the ending \1
05:41:47 <Twey> ":nick~!user@hostmask PRIVMSG #channel :\1ACTION string-of-choice\1"
05:41:53 <Twey> Yes, that's all you need to do, IIRC
05:41:55 <tass> Right.
05:42:20 <Twey> Yep, that should work.
05:43:25 <tass> Nope, something's amiss still.
05:43:33 * hackagebot upload: epic 0.1.3 - Compiler for a supercombinator language (EdwinBrady)
05:44:02 <Twey> Oh?
05:44:29 <tass> Yeah, still getting "ACTION string-of-choice" sent to channel
05:44:56 <Twey> I believe that when sending, you shouldn't attach a message prefix
05:44:58 <Twey> That's for receiving
05:45:12 <Twey> But I don't think it makes that much difference.  Are you sure you didn't forget to recompile?
05:45:27 <tass> Twey: Oh, I'm quite certain, but I'll make sure
05:46:28 <tass> Yes, it fails
05:46:36 <Twey> Oo-er
05:46:43 <Twey> Oh, oops
05:47:00 * tass pats Twey 
05:47:03 * TweyTelnet tests again.
05:47:07 <Twey> There we go
05:47:16 <Twey> That's definitely the format
05:47:18 <tass> Hmm..
05:47:21 <Twey> You're doing something wrong in your code
05:47:35 <tass> action h c s = write h "PRIVMSG" (c ++ " :" ++ "\1" ++ "ACTION" ++ s ++ "\1")
05:47:52 <jps_77> You don't need the ACTION part
05:47:57 <Twey> You do
05:48:04 <Twey> Or that happened (above) ☺
05:48:08 <Twey> happens**
05:48:19 <Twey> 13:46:08 TweyTelnet [n=twey@cpc3-brig15-2-0-cust781.3-3.cable.virginmedia.com] requested unknown CTCP Test from #haskell:
05:48:31 <Twey> Hmm
05:48:40 <tass> Perhaps the wrong encoding?
05:48:42 <Twey> Does s include a leading space+?
05:48:43 <Twey> ?**
05:48:44 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
05:48:48 <tass> So it just gets ignored?
05:48:52 <Twey> lambdabot: Hush, you :þ
05:48:54 <SoleSoul> Greetings everyone, and BONUS if you are here. I'm in chapter 8 of lyah. Does anybody know if it is still being written?
05:49:39 <tass> I guess I could do some things...
05:49:41 <Twey> tass: write h $ printf "PRIVMSG %s :\1ACTION %s\1" c s
05:50:31 <Twey> Oh
05:50:42 <Twey> And don't forget the \r\n, if ‘write’ doesn't append those for y ou
05:50:43 <Twey> you**
05:50:47 <tass> Hmm, yeah
05:50:50 <Twey> Sorry, my typing is bad today
05:52:02 <tass> Hrm.. now I'm getting a stupid type mismatch
05:52:19 <tass> IO() expected and String -> IO() given
05:52:26 <tass> Guess I could work around that.
05:52:27 <jps_7> \01Hello\01\r\n
05:52:39 <jps_77> ah, forgot cant do that in telnet
05:52:52 <Twey> jps_7: Type C-a to get \01
05:52:57 <jps_77> ah
05:53:08 <Twey> And use the ‘toggle crlf’ command to enable crlfs for linebreaks
05:53:12 <tass> It involves not using my write function
05:53:12 <jps_7> hello\r\n
05:53:22 <Twey> (though Freenode accepts \n too)
05:54:01 <Twey> jps_7: See?  ☺
05:54:12 <Twey> The ACTION is required.
05:59:26 <SoleSoul> Greetings everyone, and BONUS if you are here. I'm in chapter 8 of lyah. Does anybody know if it is still being written?
06:00:53 <Lemmih> SoleSoul: We heard you the first time.
06:01:02 <jps_77> The format should be: PRIVMSG <target> :\01action <message>\01\r\n, just checked the raw log on my client
06:01:24 <SoleSoul> Lemmih: :) Sorry
06:03:02 <pastah_rhymez> who's lunabot and why do we have her?
06:03:56 <tass> Twey: Fixed it : P
06:03:59 <zygoloid> lunabot is mmorrow's bot iirc. she goes places lambdabot cannot, such as the wacky world of TH
06:04:02 <Zao> pastah_rhymez: Redundance for when lambdabot goes bottom.
06:04:08 <Zao> pastah_rhymez: And slightly different features set.
06:04:13 <tass> Twey: Had to do a custom write function
06:04:24 <Jonno_FTW_> i don't get what I need to do here: http://projecteuler.net/index.php?section=problems&id=59
06:04:32 <pastah_rhymez> Zao: oh, cool
06:04:47 <Jonno_FTW_> i XOR the numbers given with another number
06:05:08 <jps_77> is NOT (TRUE AND FALSE) == FALSE or TRUE?
06:05:13 <Jonno_FTW_> but what do i do with the XOR result and how is the other number determined
06:05:26 <jps_77> the parenthesis should equal FALSE, and then NOT FALSE must be TRUE
06:05:29 <jps_77> correct?
06:05:33 <Jonno_FTW_> > not (True && False)
06:05:34 <lambdabot>   True
06:05:35 <Zao> Jonno_FTW_: Cycle the key, xor with each character, look for results that look like english text.
06:05:57 <Jonno_FTW_> > (not (True && False)) == (False || True)
06:05:57 <lambdabot>   True
06:06:15 <Zao> Jonno_FTW_: The last bit is the hardest, I'd filter out all solutions that contain values outside the permissible range.
06:06:26 <Jonno_FTW_> so do I `ord` the key?
06:06:28 <Zao> Maybe look at letter distributions if you feel fuzzy.
06:06:50 <Zao> Oh look, I haven't solved that problem yet.
06:06:54 * Zao pulls up Leksah :)
06:07:26 <pastah_rhymez> Zao: you running leksah?
06:07:32 <pastah_rhymez> i can't get it installed :(
06:07:46 <Zao> pastah_rhymez: Not currently though, as it's lost in a recent computer wipe.
06:07:57 <Zao> pastah_rhymez: Shouldn't be too painful, provided one has a decent gtk2hs built.
06:08:17 <pastah_rhymez> Zao: i tried to make it build on ubuntu 9.10, nu luck
06:08:23 <pastah_rhymez> *no luck*
06:14:46 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14386#a14386 <-- how do i fix this?
06:19:40 <pastah_rhymez> i thought cabal solved dependencies
06:22:09 <Zao> pastah_rhymez: gtk2hs is special, you must grab and install that yourself.
06:22:30 <Zao> pastah_rhymez: http://www.haskell.org/gtk2hs/
06:23:34 <nominolo> yay, cabal update segfaults on Snow Leopard ...
06:23:37 <Twey> tass: Aha ☺
06:25:40 <tass> Think I could reload a module?
06:25:49 <pastah_rhymez> Zao: but i have gtk2hs (at least i think i do)
06:26:10 * tass is pondering having triggers in a separate module, so that they can be changed on the fly.
06:30:35 * tass is also pondering whether one should implement CTCP VERSION and such as well
06:35:32 <edwardk> preflex: xseen copumpkin
06:35:32 <preflex>  copumpkin was last seen on freenode/#haskell-blah 2 days, 7 hours, 30 minutes and 23 seconds ago, saying: lol
06:35:36 <Raynes> pastah_rhymez: I could never get Leksah built on Hardy. Ever. Dependency hell.
06:36:26 <edwardk> the bostonhaskell meeting last night was very cool
06:37:22 <edwardk> now i just need to figure out how to cabalize the concurrent collection code. =/
06:38:32 <pastah_rhymez> Raynes: i'm installing gtk2hs to solve SOME of my dependencies now
06:38:46 <pastah_rhymez> even though i already had it installed through APT
06:41:41 <Raynes> pastah_rhymez: gtk2hs was never the problem for me.
06:41:45 <Raynes> Nothing GUI related.
06:41:50 <pastah_rhymez> ok
06:41:55 <pastah_rhymez> well, we'll see
06:42:05 <Raynes> It was other stuff. Stuff that it said I didn't have, but cabal install said I did have.
06:42:28 <Raynes> ghc-pkg list even said I didn't have the package.
06:42:35 <Raynes> But cabal install insisted I did.
06:42:39 <Raynes> So I eventually gave up.
06:43:15 <Jedai> Raynes: you can force an install in cabal-install
06:44:02 <Raynes> Jedai: If it claims you already have it, and reinstalling this 'invisible' package, is it really a good idea to force it to install? :\
06:44:18 <Raynes> reinstalling doesn't work*
06:44:22 <Raynes> Kind of wandered off there.
06:46:48 <Jedai> Well if you really didn't have it before, it can't break much of anything to force its install now ?
06:47:13 <jutaro> Sorry for that many Leksah install problems, we reaaly try to keep dependencies minimal. But he last release still has this regex package problem.
06:48:53 <Jedai> Well here it's building on a Ubuntu 9.10 with the latest cabal-install and gtk2hs packages from aptitude
06:49:01 <Jedai> no telling if it works yet
06:49:15 <Raynes> jutaro: It's irrelevant. Was not Leksah's fault. That problem seems to be fixed now, however, it wont compile because I don't have the newer version of gtksourceview2, because I have no way of getting it on Hardy.
06:49:25 <zandax> hi
06:49:31 <Raynes> I'll just have to wait until the next LTS.
06:49:52 <bnijk_> where do i find an 'erf' function, and other similar stuff
06:50:25 <jutaro> Raynes: So it is the gtk library version of sourceview, which causes the problem?
06:51:38 <Raynes> jutaro: I have no idea. I suppose the problem is the fact that the gtksourceview2 I have install on Ubuntu Hardy is version 2.2.2 where it's supposed to be higher.
06:51:50 <Raynes> At least, that's what a little googling told me.
06:52:03 <Raynes> installed*
06:52:16 <Raynes> I've been awake for a good long while. ;)
06:52:17 <Jedai> zandax: Hello
06:52:28 <jutaro> Raynes: And what is the error you get?
06:52:43 <Raynes> jutaro: One moment.
06:53:04 <zandax> Jedai, weren't you the one who helped me some days ago? Sadly I am struggling with my first attempt right now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14388
06:53:23 <zandax> I am unable to create the type instance for my monad : /
06:53:45 <Raynes> jutaro: src/IDE/Completion.hs:99:26-59:   Not in scope: `sourceLanguageManagerGuessLanguage'
06:54:59 <jutaro> Raynes: Yes, I remember this, I once had a fix for it.
06:55:02 <HaskellLove> Anyone has read TPL, can I count on someone here for questions regarding the book as I read?
06:55:55 <osfameron> TaPL ?
06:56:12 <Jedai> zandax: look at the types, they'll help you see what you should be doing
06:56:34 <Jedai> zandax: for instance, your second let should be :
06:56:36 <zandax> Jedai: yes, it's the type system I am struggling with.
06:56:37 <HaskellLove> osfameron> Types and Programming Languages MIT Pierce
06:56:37 <McManiaC> whats up with haskell.org/ghc/docs...?
06:56:50 <McManiaC> I got "not found" for a few days now
06:56:51 <osfameron> HaskellLove: yeah, that's usually abbreviated TAPL I think
06:56:55 <edwardk> HaskellLove: yes, lots of us have read TaPL
06:57:20 <bnijk_> i need a haskell function to calculate t-statistics
06:57:20 * osfameron is reading it over Christmas (well, paused this week, while busy, but hoping to get a little way through it over brak)
06:57:24 <bnijk_> does one exist?
06:57:41 <HaskellLove> osfameron, edwardk great two guys so far, thank you. As i read if questions are apropriate to haskell chanel will post them here otherwise pm. Reading now...
06:57:41 <Jedai> zandax: I wouldn't say that, rather that the type system is telling you you're doing thing wrong
06:58:24 <edwardk> HaskellLove: another thing is some guy converted all the little language examples in that book into haskell, not sure where that was posted
06:58:41 <HaskellLove> http://haskelllove.wordpress.com/ I started topic for the book will make notes for it like i made for the previous one
06:58:47 <zandax> yeah, but somehow higher order functions (+ currying) and type classes are unbelievable complicated for an imperative programmer like me
06:59:09 <nvoorhies> did TaPL use SML or OCaml?  I forget.
06:59:13 <edwardk> HaskellLove: http://code.google.com/p/tapl-haskell/
06:59:27 <HaskellLove> zandax keep working I am a almost two weeks in haskell, it gets easier and easier, release yourself from imperative chain
06:59:40 <edwardk> HaskellLove: that will help a bit with the fact that Pierce uses ML throughout
06:59:44 <HaskellLove> nvoorhies have no idea, reading now...
07:00:03 <HaskellLove> edwardk oh great i know litle ML, ok i go back to work... thanks guys
07:00:05 <zandax> I am already lucky that I understood most concepts so far, and I try to keep going
07:00:35 <zandax> In that particular case, I just can't figure out how to match my bind function with the general type signature of >>=
07:00:36 <Raynes> If you believe it's hard, it's going to be hard.
07:00:43 <HaskellLove> zandax implement in haskell dont just read, i want to solve all eulers just to learn haskell to the core... it is worth it trust me
07:00:43 <Jedai> RND (\rd -> let (a, rd') = f rd
07:00:43 <Jedai>                            RND rg = g a
07:00:43 <Jedai>                      in  rg rd')
07:00:48 <Raynes> Don't try to learn Haskell with the mindset that it's absolutely difficult.
07:01:04 <Jedai> zandax: that's what it should look like
07:01:17 <Raynes> It's really not that hard, if you can just try to forget what you already know while doing so.
07:01:19 <Jedai> zandax: except properly indented
07:02:02 <zandax> thanks Jedai, I can see my mistake now!
07:02:25 <zandax> I just wanted to pass the single integer in the old state, but I have to pass the whole state of course
07:02:39 <edwardk> Haskell is easy, all you have to do is accept that the compiler is always right, and seek ways to appease it, when it chastises you. This mantra works for every language, but in Haskell's case the type checker is at least a benevolent God.
07:03:34 <ben> In other words, the Haskell type checker puts a lot of effort into making you be right too
07:03:38 <Twey> Hehehe.
07:03:39 <pastah_rhymez> Raynes: i'm coming somewhere here...
07:03:45 <zandax> I noticed that Hugs gives you nearly no errors except type errors and syntax errors, I find that pretty interesting, because more doesn't seem necessary and imperative compilers give you tons of different error messages
07:03:47 <bnijk_> what is UArr? anyone?
07:03:57 <manjunaths> http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=5386#a5386 <- anyone know how to fix these linker errors ?
07:04:05 <pastah_rhymez> Raynes: i only have the Binary and utf8 dependencies left
07:04:07 <Twey> It's a benevolent god so long as you feed it sufficient sacrifices of type-signatures
07:04:36 <Twey> If you don't show it proper respect with the appropriate forms, it will become vexed and mislead you in punishment
07:04:56 <Raynes> pastah_rhymez: The dependency hell I spoke of was because my setup was apparently flawed. The only problem I have now is related to my ancient version of Ubuntu.
07:05:02 <pastah_rhymez> Raynes: i solve all this dependency bullshit by downloading the sources and install them system-wide
07:05:34 <zandax> works great Jedai, thanks again!
07:06:36 <bd_> zandax: If you look closely, the errors that imperative compilers give you are _also_ syntax or type errors, at some level. Or, in the case of C++, occasionally kind errors :)
07:06:36 <lambdabot> bd_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:06:40 <bd_> @messages
07:06:40 <lambdabot> yrlnry said 9h 57m 14s ago: sorry that I disappeared before you could come up with the cite I asked for. But I was able to pluck it from the channel logs, so your kind efforts were not wasted. Many
07:06:40 <lambdabot> thanks!
07:07:06 <edwardk> Twey: If you needs must feed it type signatures, then you are asking more of your God, than his lesser handmaiden, the two-headed demigod Hindley-Milner, can understand. The signature sacrifices are the price you pay for his full attention.
07:08:08 <Twey> Hehe.
07:08:14 <Twey> bnijk_: Unboxed array, probably
07:08:41 <bnijk_> so UArr Double is an unboxed array full of doubles
07:08:49 <bnijk_> ok
07:08:56 <edwardk> bnijk_: its from uvector. http://hackage.haskell.org/packages/archive/uvector/0.1.1.0/doc/html/Data-Array-Vector-UArr.html
07:09:09 <gwern> I wonder whether the haskell community is growing
07:09:11 <edwardk> its a nicely fusable unboxed array-like structure
07:09:14 <gwern> it seems to have slowed down lately
07:09:26 <edwardk> gwern: winter
07:09:29 <gwern> I don't see so many ANNs or blog posts or emails as I seem to remember
07:09:35 <edwardk> gwern: next semester hasn't started yet
07:09:47 <edwardk> gwern: finals are here
07:09:48 <gwern> edwardk: wouldn't that encourage activity though? vacation time is hacking time
07:10:20 <edwardk> gwern: i'm planning on doing my hacking between christmas and new years for the most part. took the time off work and everything =)
07:10:36 <gwern> knowing you no one will know you did anything at all
07:10:49 <pastah_rhymez> Raynes: 1 down, 1 to go
07:10:56 <edwardk> =P
07:11:11 <gwern> 'After a week of hacking and testing, I've made a change: 'f = g . id' rather than 'f = id . g' now, to release 1.0!'
07:11:19 <Twey> Hehehe
07:11:20 <edwardk> =)
07:11:28 <pastah_rhymez> IT'S BUILDING!!
07:12:37 <edwardk> nah, i'm trying to get a version of kata packaged up so other people can hack on it, and i want to convert the concurrent collections library into a form suitable for hackage
07:13:07 <gwern> packaging is easy and mindless. even I can do it
07:13:13 <edwardk> so as soon as ryan newton can get the intel lawyers to say its okay for him to BSD license it, it can go right out there.
07:13:36 * gwern suddenly remember a tool I thought of yesterday in the shower but forgot until now!
07:13:39 <edwardk> gwern: right now it compiles via a very c-like build process, it needs to basically be rewritten to feel like haskell
07:14:14 <gwern> I had an idea: write a tool that grovels through $HOME, analyze the text in every file for URLs, and submit the URLs to webcite.org
07:14:25 <pastah_rhymez> HAH!!!
07:14:26 <edwardk> and i want to try out an idea i had for using a monad and applicative pair like is used in uu-parsinglib to see if i can make a partially lazy implementation
07:14:31 * pastah_rhymez is running LEKSAH on ubuntu
07:14:37 <gwern> this way the URLs cited in your personal files and all your projects and whatnot will get archived, even the ones you have long forgotten about
07:14:53 <HaskellLove> Conversely, unsafe languages often provide "best effort" static type checkers that help programmers eliminate at least the most obvious sorts of slips, but such languages do not qualify as type-safe either, according to our definition, since they are generally not capable of offering any sort of guarantees that well-typed programs are well behaved typecheckers for these languages can suggest...
07:14:55 <HaskellLove> ...the presence of run-time type errors (which is certainly better than nothing) but not prove their absence. THAT IS FROM TAPL. Can you guys tell me example of such language so i do more research on this?
07:15:10 <idnar> gwern: just submit every URL on the internet
07:15:23 <gwern> -_- the internet archive has my back there
07:15:35 <idnar> also, I don't think webcite.org is what you meant
07:15:46 <gwern> ah, webcitation.org
07:15:50 <HaskellLove> ok c and c++ are in the group, others?
07:16:14 <gwern> HaskellLove: sounsd like weak static typingl java, eg.
07:16:43 <HaskellLove> actually it says Java is safe and staticaly checked
07:17:09 <gwern> java ain't safe. it practically requires you to use type coercions
07:18:09 <HaskellLove> well that is argument for being safe :)
07:18:13 <zandax> btw. are there any good reasons for dynamic typing? For me dynamic typing has always been some kind of catastrophe, and I am really happy that Haskell has such strict static typing
07:18:37 <jaspervdj> i'm wondering if there is a better way to strip css comments than this snippet i wrote http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14389#a14389
07:19:43 <edwardk> gwern: yes, but when it does you'll at least get an exception rather than undefined behavior most of the time.
07:19:44 <Jonno_FTW_> filter (isSafe) progLanguages
07:20:35 <HaskellLove> zandax not only strict but lazy too :) dynamic typing can be more flexible (e.g. by allowing programs to generate types and functionality based on run-time data), though at the expense of fewer a priori guarantees
07:21:11 <edwardk> zandax: sure, there are just some things you can't get in a language that has type inference without losing the ability to infer those properties. so if you want everything in the language to lack a type annotation you have to eventually give up either those features or typing
07:21:54 <zandax> I see, interesting
07:23:28 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14390 <- I fixed my code now, but I cannot figure out how to create like an "empty object" of type a in the getNum function
07:25:02 <edwardk> zandax: that should tell you something about the nature of that function -- namely that it can't exist at least without using an undefined value.
07:25:25 <edwardk> zandax: you need another constraint - a way to make an 'a' that is interesting to you, from an integer seed.
07:26:08 <zandax> in that particular case, a should be something like an IO unit
07:26:09 <edwardk> zandax: one way would  be to make up a typeclass of Randomly generatable things, and have your random function ask that typeclass to do the dirty work given the seed
07:26:44 <zandax> actually 'a' should not have to do anything with the seed
07:28:47 <edwardk> zandax: what is getNum supposed to do? give you a single Int as output?
07:29:24 <edwardk> then your RndData is too complicated for what it needs to do
07:29:39 <zandax> I was afraid it would be
07:29:44 <edwardk> newtype Random a = RND (Seed -> (a, Seed))
07:29:49 <zandax> I wasn't sure about storing the acutal Int in the structure
07:29:54 <zandax> ah, I see
07:30:08 <edwardk> now your function should be a lot easier to define
07:30:24 <edwardk> but its signature is different
07:30:27 <zandax> but I still don't know how to create the 'a' object
07:30:33 <edwardk> getNum :: Int -> Int -> Random Int
07:31:04 <edwardk> its not an 'a' it should be an Int, after all the value you are getting out in your monad will be an integer, not an arbitrary 'a'
07:31:51 <zandax> actually the whole deal about that monad should be that you combine random number generation with other things like IO, like you can see in the 'main' expression
07:32:08 <zandax> so I have to carry some additional info as well
07:32:28 <edwardk> getNum min max = RND $  \s -> (s `mod` (max-min) + min, nextSeed s)
07:32:37 <edwardk> zandax: thats fine, so you change your monad
07:32:54 <edwardk> newtype RandomT m a = RND (Seed -> m (a, Seed))
07:32:58 <edwardk> where m is a monad
07:33:17 <edwardk> then you can define a monad instance like: instance Monad m => Monad (RandomT m) where ...
07:33:17 <zandax> aha!
07:33:41 <zandax> thank you very much, I would have never figured that out by myself!
07:33:51 <edwardk> and you can use the return and bind for the underlying monad inside of your own return and bind
07:33:55 <edwardk> no problem
07:34:19 <edwardk> once you work it out i can supply you with a spoiler from someone who has already tackled this
07:34:31 <edwardk> but you're on the right track
07:34:41 <zandax> :)
07:41:43 <Jonno_FTW_> HaskellLove, on your blog, i suggest you add in a <code> style so it can actually be read
07:43:02 <HaskellLove> Jonno_FTW_ i think it is ok like this, it is readable that is all it matters :) and it is not about someone copying the code, it is about reading that so... somewhere i dont put all the code but just more complex stuff so...
07:43:58 <Jonno_FTW_> but, it is quite hard to read the stuff which gets wrapped around multiple lines
07:44:45 <HaskellLove> Jonno_FTW_ on second thought hmm, you are right... so i just put it in <> ?
07:45:25 <Jonno_FTW_> no, unless wordpress comes with such tags, you will need to edit the page style
07:45:55 <Jonno_FTW_> http://codex.wordpress.org/Writing_Code_in_Your_Posts
07:46:55 <Jonno_FTW_> so put your code between <code> some code </code>
07:46:56 <HaskellLove> Jonno_FTW_ ok thanks for this, i will change it all as soon as i can
07:53:25 <eugenn> @pl (\y -> f y < f x)
07:53:25 <lambdabot> (< f x) . f
07:53:46 <Baughn> @pl \x y -> f y < f x
07:53:47 <lambdabot> flip ((<) . f) . f
07:53:56 <Baughn> @pl \x y -> f y < f y
07:53:56 <lambdabot> const (liftM2 (<) f f)
07:55:04 <Baughn> ..I'd like to think const (const False) would be fine for that last one
07:58:26 <Twey> :t on
07:58:27 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:58:29 <Twey> :t liftM2
07:58:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:58:34 <roconnor> are there any real systems that actually do bi-direction type checking?
07:58:37 <Twey> Huh
08:02:18 <sshc> how is >> useful for the List monad?
08:02:47 <c_wraith> when used with guard
08:03:40 <roconnor> @type guard
08:03:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:03:59 <Philonous> > guard (2==3) >> return 1
08:04:00 <lambdabot>   No instance for (GHC.Show.Show (m t))
08:04:00 <lambdabot>    arising from a use of `M4161321570...
08:04:13 <Philonous> > guard (2==3) >> return 1 :: [Int]
08:04:14 <lambdabot>   []
08:04:18 <Philonous> > guard (2==2) >> return 1 :: [Int]
08:04:19 <lambdabot>   [1]
08:04:40 <sshc> @src guard
08:04:41 <lambdabot> guard True  =  return ()
08:04:41 <lambdabot> guard False =  mzero
08:04:51 <c_wraith> > do { x <- [1..3] ; y <- [1..3; guard $ x /= y ; return $ (x, y) }
08:04:52 <lambdabot>   <no location info>: parse error on input `;'
08:05:01 <c_wraith> > do { x <- [1..3] ; y <- [1..3] ; guard $ x /= y ; return $ (x, y) }
08:05:02 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
08:05:16 <roconnor> @undo do { x <- [1..3] ; y <- [1..3] ; guard $ x /= y ; return $ (x, y) }
08:05:16 <lambdabot> [1 .. 3] >>= \ x -> [1 .. 3] >>= \ y -> guard $ x /= y >> return $ (x, y)
08:05:25 <roconnor> >>!!
08:05:51 <c_wraith> huh.  @undo is broken
08:05:51 <Philonous> > [1..5] >> return 1
08:05:53 <lambdabot>   [1,1,1,1,1]
08:06:02 <roconnor> c_wraith: why?
08:06:14 <roconnor> > [1 .. 3] >>= \ x -> [1 .. 3] >>= \ y -> guard $ x /= y >> return $ (x, y)
08:06:15 <lambdabot>   Couldn't match expected type `a -> a1'
08:06:15 <lambdabot>         against inferred type `GHC.B...
08:06:16 <poucet> roconnor: the priority of $
08:06:16 <c_wraith> that expression does not type check
08:06:20 <roconnor> :(
08:06:28 <roconnor> > [1 .. 3] >>= \ x -> [1 .. 3] >>= \ y -> (guard $ x /= y) >> return $ (x, y)
08:06:29 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) (t, t)))
08:06:29 <lambdabot>    arising from a u...
08:06:39 <poucet> another $
08:06:41 <roconnor> > [1 .. 3] >>= \ x -> [1 .. 3] >>= \ y -> (guard $ x /= y) >> (return $ (x, y))
08:06:42 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
08:07:33 * hackagebot upload: SGdemo 1.0.1 - An example of using the SG and OpenGL libraries (NeilBrown)
08:07:52 <c_wraith> Is $ the only operator that will break @undo?
08:08:16 <Baughn> I imagine any operator with lower precedence than >>/>>= will
08:08:34 <c_wraith> Well, yes.  I'm just wondering if there are any that are commonly used
08:09:11 <Baughn> $!
08:09:20 <c_wraith> several, according to the report
08:09:27 <c_wraith> including `elem`, for maximum shock value
08:09:46 <Baughn> Eh? That's infix 4
08:10:03 <c_wraith> well, it'd still break @undo
08:10:07 <c_wraith> being the same precedence
08:10:28 <c_wraith> oh, I can't read
08:10:49 <c_wraith> >> and >>= are infixl 1
08:11:00 <c_wraith> so just $, $!, and `seq`
08:13:55 <mmorrow> :o
08:13:59 <mmorrow> > [(9223372036854775807::Int)..]
08:14:00 <lambdabot>   [9223372036854775807]
08:14:07 <mmorrow> oh right, Bounded..
08:14:13 <mmorrow> n/m :)
08:15:00 <Baughn> > [(92233720368547758074635278432657483564372895634789::Int)..]
08:15:01 <lambdabot>   [6828343066514855269,6828343066514855270,6828343066514855271,68283430665148...
08:15:16 <Baughn> I never get tired of that.
08:17:47 <pastah_rhymez> @faq is it possible to program christmas present buying?
08:17:48 <lambdabot> The answer is: Yes! Haskell can do that.
08:19:11 <burp> buying is no problem, getting the right ideas is :|
08:33:18 <sproingie> is there a way to make cabal automatically build and install haddock html pages when installing?
08:33:38 <dcoutts> --enable-documentation
08:34:04 <sproingie> can i set that in config?
08:34:31 <dcoutts> yes
08:34:46 <zandax> edwardk: I have some difficulties redefining my functions, could you give me hint for my return functionm maybe? I tried something like "return a = RND $ \s -> return (a, s)"
08:40:24 <sshc> > [(9223372036854775807::Integer)..]
08:40:26 <lambdabot>   [9223372036854775807,9223372036854775808,9223372036854775809,92233720368547...
08:41:00 <sshc> > [(9223372036854775807)..]
08:41:02 <lambdabot>   [9223372036854775807,9223372036854775808,9223372036854775809,92233720368547...
08:41:14 <sshc> :t 9223372036854775807
08:41:16 <lambdabot> forall t. (Num t) => t
08:41:32 <zygoloid> zandax: can you hpaste your monad definition?
08:41:43 <sshc> > [(9223372036854775807::Int)..]
08:41:44 <lambdabot>   [9223372036854775807]
08:41:46 <sshc> > [(9223372036854775808::Int)..]
08:41:48 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
08:42:01 <zygoloid> zandax: or if it's one line, paste it here
08:44:20 <zandax> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=14398#a14398
08:44:28 <zandax> unfortunately my code is pretty much broken right now
08:44:55 <maltem> zandax, instance Monad m => Monad (Random m)
08:45:26 <maltem> otherwise the "inner return" wouldn't be allowed
08:45:34 <zandax> ouch
08:45:45 <zygoloid> zandax: you're also going to need to use the inner >>= in your >>=
08:46:20 <zandax> so my current >>= won't work?
08:46:42 <zygoloid> zandax: no. you say 'let (a, s') = f s' but f s produces a value in the m monad
08:47:12 <zandax> I see
08:47:16 <zygoloid> zandax: changing it to 'do (a, s') <- f s; ...'  might be a good start there
08:47:19 <zandax> so I do something like "in a >>= (g' a)"
08:47:37 <zygoloid> something like 'f s >>= \(a, s') -> ...', yeah
08:47:45 <zandax> ah, okay then
08:48:10 <zygoloid> it's pretty close though
08:48:33 <zygoloid> your 'return' looks correct, for instance.
08:48:54 <zandax> is my 'run' type signature correct?
08:49:24 <benmachine> depends what you want it to do
08:49:35 <zygoloid> zandax: i'd probably use the more general Monad m => Seed -> Random m a -> m a.
08:49:36 <benmachine> unless you already said and I just missed it
08:49:50 <zygoloid> (but what benmachine said stands too :))
08:50:21 <zandax> okay, I hope I can put that together :)
08:50:50 <benmachine> p.s. if you declared your newtype as
08:51:13 <benmachine> newtype Random m a = RND { runRandom :: Seed -> m (a, Seed) }
08:51:36 <benmachine> you'd automatically get a function runRandom of type Random m a -> Seed -> m (a, Seed) which is almost what you want
08:52:42 <zandax> cool
08:52:47 <zandax> I'll try that later
08:53:06 <benmachine> (it would otherwise be identical to the current definition)
08:56:25 <bnijk_> do you guys ever suddenly find really beautiful music on your harddrive
08:56:29 <bnijk_> that you've never heard before
08:57:04 <quicksilver> yes, but the videos that accompanied the music were quite disturbing :-S
08:57:12 <bnijk_> oh my
08:57:18 <zandax> whew, I'm not able to declare the 'run' function. "run s f = let (a, s') = f s in a" does not work :(
08:57:19 <mk64ftw> cat /dev/sda1 > /dev/dsp ?
08:57:37 <mk64ftw> beautiful
08:57:39 <bnijk_> mk64ftw: i handed that in for homework once
08:57:44 <mk64ftw> hehe
08:57:46 <bnijk_> in an experimental video class
08:57:53 <bnijk_> lugged a computer in and everything
08:57:59 <mk64ftw> thats pretty neat
08:58:22 <mk64ftw> its funny when you hit actual audio files and they play
08:58:23 <bnijk_> i guess it's not really "experimental' if somebody's done it before you
08:58:41 <bnijk_> do you really have that many wav's mk64ftw
08:59:04 <benmachine> zandax: isn't that the same thing as with >>=, where the tuple is in a monad?
08:59:10 <mk64ftw> bnijk_: no like two :(, but they are usually pretty low in inode number because they get installed early in my system
08:59:22 <bnijk_> ah yes
08:59:29 <bnijk_> but then they're just little beep noises
09:00:30 <mk64ftw> yeah i should insert some more interesting ones at more oppotune times, a hdd mashup of sorts
09:00:38 <benmachine> [ben@euler ~]$ sudo cabal install base
09:00:38 <benmachine> Resolving dependencies...
09:00:38 <benmachine> cabal: internal error: impossible
09:00:40 * benmachine sighs
09:00:48 <benmachine> oh that just means I need to upgrade ghc doesn't it
09:01:03 <c_wraith> cabal isn't allowed to update base
09:01:08 * benmachine has a look to see if it's in the repositories yet
09:01:10 <benmachine> it is not :(
09:01:22 <c_wraith> so yes, if you want a newer version of base, you need to install a newer ghc
09:01:32 <zandax> benmachine: I think there is something wrong with the f func / parameter :/
09:03:17 <benmachine> zandax: oh, yeah it's not a function, it's a function-in-a-wrapper
09:03:27 <benmachine> pattern match against it
09:03:36 <benmachine> run seed (RND f) = ...
09:04:46 <manjunaths> is it possible to write map using fold ?
09:05:23 <mux> yes
09:05:39 <manjunaths> ok...thanks
09:05:47 <manjunaths> then I'm going to try it
09:05:58 <mux> > let map f = foldr (f . (:)) [] in map (+1) [1..5]
09:06:00 <lambdabot>   No instance for (GHC.Num.Num ([a] -> [a]))
09:06:00 <lambdabot>    arising from the literal `1' ...
09:06:09 <mux> > let map f = foldr ((:) . f) [] in map (+1) [1..5]
09:06:11 <lambdabot>   [2,3,4,5,6]
09:06:28 <benmachine> installing xmonad-contrib I get pages of warnings of the form "could not find link destinations for..."
09:06:33 <mux> manjunaths: I highly recommend the "on the universality of fold" paper
09:06:40 <benmachine> anyone know what that means?
09:06:57 <manjunaths> noooooooooo
09:07:03 <manjunaths> I want to write it
09:07:08 <brutus_> can someone help me understand the ((->) t) monad without actually showing me the monad instance (I'm trying to derive it myself)?
09:07:15 <mux> close your eyes then :) (sorry!)
09:07:17 <manjunaths> mux, ok...thanks
09:07:21 <manjunaths> :)
09:07:27 <manjunaths> no I didn't see it
09:07:30 <benmachine> brutus_: do you know about the Reader monad?
09:07:31 <manjunaths> ....yet
09:07:43 <mux> manjunaths: maybe /clear would help you :)
09:07:44 <brutus_> benmachine: a bit, yes
09:07:48 <benmachine> brutus_: (also, it's possible to derive the instance having no idea what it does, just follow the types)
09:08:07 <benmachine> brutus_: well, the Reader monad is basically a newtype wrapper around the ((->) t) monad
09:08:11 <benmachine> they do exactly the same job
09:08:50 <benmachine> which is basically passing a parameter implicitly through several function calls
09:09:07 <brutus_> benmachine: so ((->) t) represents a function with t as it's argument?
09:09:12 <benmachine> yes
09:09:39 <mux> did someone benchmark GHC 6.12.1 and its new inliner to see if the monad stacking overhead is dealt with better?
09:09:40 <benmachine> if type operator sections were allowed we'd be able to write it as (t ->)
09:09:45 <manjunaths> mux, no I'll loose the rest of the context
09:09:46 <benmachine> which I think would be more clear
09:10:02 <mux> like, does it still pay off to use IORef's instead of the Reader monad, stuff like that
09:11:04 <benmachine> brutus_: would it help to see an example of the ((->) t) monad in operation? I have a good one somewhere
09:11:19 <brutus_> benmachine: if you can find it, that'd be awesome
09:12:11 <brutus_> > ((>>=) const id) $ 1
09:12:12 <lambdabot>   1
09:12:17 <benmachine> brutus_: I don't know if this helps but
09:12:18 <benmachine> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12144
09:13:05 <benmachine> it's also easy to find the function monad in @pl
09:13:06 <benmachine> e.g.
09:13:28 <benmachine> @pl let join f x = f x x in join
09:13:29 <lambdabot> join
09:13:33 <benmachine> er
09:13:48 <benmachine> not sure that makes my point
09:13:51 <benmachine> but anyway
09:15:34 <brutus_> @pl \h f t -> h (f t) t
09:15:34 <lambdabot> flip flip id . liftM2
09:16:16 <benmachine> @pl let foo f g x = f (g x) x in foo
09:16:17 <lambdabot> flip flip id . liftM2
09:16:20 <ColonelJ> :t integerToBreakfast
09:16:21 <lambdabot> Int -> [Char]
09:16:49 <benmachine> > integerToBreakfast 0
09:16:51 <lambdabot>   "Cornflakes"
09:17:15 <ColonelJ> :t max
09:17:16 <lambdabot> forall a. (Ord a) => a -> a -> a
09:17:18 <benmachine> > unwords . map integerToBreakfast $ [-5 .. 5]
09:17:19 <lambdabot>   "* Exception: Prelude.(!!): negative index
09:17:23 <benmachine> :(
09:17:26 <benmachine> > unwords . map integerToBreakfast $ [0 .. 5]
09:17:28 <lambdabot>   "Cornflakes Strawberry jam toast Grapefruit Cup of tea and a biscuit, gotta...
09:17:44 <benmachine> > map integerToBreakfast $ [0 .. 5]
09:17:45 <lambdabot>   ["Cornflakes","Strawberry jam toast","Grapefruit","Cup of tea and a biscuit...
09:18:11 <ColonelJ> :t length
09:18:11 <lambdabot> forall a. [a] -> Int
09:18:24 <brutus_> benmachine: (\h f t -> h (f t) t) does it, which I sort of inferred from your join f x = f x x, but I still don't think I get it 100%. perhaps I need to spend more time with the types
09:19:28 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..10000])
09:19:29 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:19:37 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..1000])
09:19:38 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:19:41 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..100])
09:19:42 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:19:44 <ColonelJ> umm
09:20:13 <benmachine> brutus_: well, can you see from the types why join does that?
09:20:19 <benmachine> @type join
09:20:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:21:01 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..50])
09:21:02 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:21:06 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..40])
09:21:07 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:21:16 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..30])
09:21:17 <lambdabot>   "* Exception: Prelude.(!!): index too large
09:21:26 <ColonelJ> there seems to be a lack of breakfasts
09:21:38 <aavogt> > map integerToBreakfast [0..]
09:21:39 <lambdabot>   ["Cornflakes","Strawberry jam toast","Grapefruit","Cup of tea and a biscuit...
09:21:41 <benmachine> you know you can PM lambdabot right?
09:21:51 <ColonelJ> > length (map integerToBreakfast [0..])
09:21:55 <lambdabot>   mueval-core: Time limit exceeded
09:21:57 <sproingie> integerToBreakfast ought to be in the ghc distribution
09:22:18 <Jafet1> That's a lot of breakfast.
09:22:24 <sproingie> GHC.intToBreakfast#
09:22:25 <aavogt> > length (takeWhile (not . null) $ map integerToBreakfast [0..])
09:22:26 <lambdabot>   * Exception: Prelude.(!!): index too large
09:22:41 <ColonelJ> you have to handle the exception it seems
09:22:44 <benmachine> > map (\x -> integerToBreakfast x `seq` x) [0..]
09:22:46 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,* Exception: Prelude.(!!): index too large
09:23:02 <ColonelJ> > foldl' (\x y -> if (length x > length y) then x else y) "" (map integerToBreakfast [0..12])
09:23:03 <benmachine> > integerToBreakfast 12
09:23:03 <lambdabot>   "Bacon, eggs, toast, tomato and mushroom. You deserve it"
09:23:04 <lambdabot>   "Leftover vindaloo curry"
09:23:21 <manjunaths> :t .
09:23:22 <Jafet> @quote breakfast
09:23:22 <lambdabot> parse error on input `.'
09:23:22 <lambdabot> lambdabot says: Beer, it's so much more than just a breakfast drink!
09:23:27 <poucet> :t (.)
09:23:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:23:30 <Jafet> @quote integerToBreakfast
09:23:31 <lambdabot> integerToBreakfast says: = (["Cornflakes", "Strawberry jam toast", "Grapefruit", "Cup of tea and a biscuit, gotta dash", "Bacon, eggs, toast, tomato and mushroom. You deserve it", "Waffles", "
09:23:31 <lambdabot> Porridge of some description", "Orange juice and muffins", "Apples, pears, mango and kiwi", "A selection of cold meats with crisp bread", "Headache pills and water", "Leftover pizza", "Leftover
09:23:31 <lambdabot> vindaloo curry"] !!)
09:23:56 <manjunaths> poucet, thanks
09:24:00 <benmachine> > head $ sortBy (comparing length) (map integerToBreakfast [0 .. 12])
09:24:01 <lambdabot>   "Waffles"
09:24:07 <benmachine> > last $ sortBy (comparing length) (map integerToBreakfast [0 .. 12])
09:24:08 <lambdabot>   "Bacon, eggs, toast, tomato and mushroom. You deserve it"
09:24:16 <benmachine> hmm
09:24:21 <benmachine> is there an easy way to flip a sort?
09:24:32 <quicksilver> sortBy (flip (comparing length))
09:24:34 <Jafet> reverse?
09:24:40 <benmachine> oh, yeah that makes sense
09:24:47 * benmachine silly
09:26:01 <quicksilver> there is no silly. There is only wise you don't have yet.
09:26:24 <poucet> quicksilver++
09:26:26 <benmachine> :) you are too kind
09:26:44 <benmachine> (if such a thing is possible)
09:27:49 <Absolute0> Is there a "between?" operator for Ints?
09:28:01 <Absolute0> or in range..
09:28:16 <Absolute0> ie: 2 `in` [1..9]
09:28:22 <Twey> `elem`
09:28:27 <Twey> Probably not quite what you want, though
09:28:33 <Twey> > 2 `elem` [1 .. 5]
09:28:34 <lambdabot>   True
09:28:38 <Twey> > 2.5 `elem` [1 .. 5]
09:28:39 <lambdabot>   False
09:28:57 <Absolute0> thats probably not so effecient
09:28:57 <Twey> [1 .. 5] == [1, 2, 3, 4, 5]
09:29:01 <Absolute0> if your range is huge
09:29:01 <Twey> No
09:29:05 <Twey> Indeed
09:29:19 <Absolute0> i'll just write my own between operator then. :)
09:29:40 <Twey> n >< (l, u) = n >= l && n <= u
09:29:47 <poucet> > let elem1 x l = x `elem` (takeWhile (<= x) . sort $ l) in elem1 1 [0..]
09:29:53 <lambdabot>   mueval: ExitFailure 1
09:29:53 <poucet> > let elem1 x l = x `elem` (takeWhile (<= x) . sort $ l) in elem1 1 [0..100]
09:29:59 <lambdabot>   mueval-core: Time limit exceeded
09:30:08 <Absolute0> Twey: great choice of punctuation! :)
09:30:09 <benmachine> Twey: 'd make more sense to put the arguments the other way around, I'd think
09:30:18 <Twey> Why's that?
09:30:20 <benmachine> well, I suppose you can just section it
09:30:24 <Twey> Yeah
09:30:25 <Twey> You have to anyway
09:30:28 <Twey> It's an operator
09:30:31 <Twey> And it reads better this way
09:30:34 <benmachine> k
09:30:36 <benmachine> conceded
09:30:37 <Twey> (as ‘in’ or ‘in range’)
09:31:00 <Twey> > let n >< (l, u) = n >= l && n <= u in 2.5 >< (1, 5)
09:31:03 <lambdabot>   True
09:31:18 <Twey> Maybe those bounds should be exclusive, with a name like ><
09:31:30 <Twey> > let n >< (l, u) = n > l && n < u in 2.5 >< (1, 5)
09:31:31 <lambdabot>   True
09:31:44 <benmachine> >=<?
09:31:55 <zygoloid> @let a >=< b = True
09:31:58 <lambdabot>  Defined.
09:32:01 <Twey> Yeah, that'd be a good name for an inclusive equivalent
09:32:01 <benmachine> heh
09:32:20 <poucet> > 1 >=< "Hi"
09:32:22 <lambdabot>   True
09:32:27 <zygoloid> > let nan = 0/0 :: Double in nan < nan || nan == nan || nan > nan
09:32:28 <lambdabot>   False
09:32:34 <zygoloid> @undef
09:32:44 <zygoloid> @let a >=< b = a < b || a == b || a > b
09:32:45 <lambdabot>  Defined.
09:32:54 <zygoloid> > let nan = 0/0 :: Double in nan >=< nan
09:32:56 <lambdabot>   False
09:33:07 <poucet> > 1 >=< 1
09:33:08 <lambdabot>   True
09:33:27 <Jafet> > let o = 6; (-<-<) = ((*7).const) in o-<-<1
09:33:29 <lambdabot>   No instance for (GHC.Num.Num (b -> a))
09:33:29 <lambdabot>    arising from a use of `GHC.Num.*'...
09:33:38 <Jafet> Failed
09:33:46 <Jafet> > let o = 6; (-<-<) = const in o-<-<1
09:33:47 <lambdabot>   6
09:34:33 <Twey> I was thinking it should be exclusive because the tuple syntax uses round brackets :þ
09:35:48 <Twey> n >=< [l, u] = n >= l && n <= u
09:35:49 * Twey hides.
09:37:27 <Philonous> > let nan = 0/0 in compare nan nan
09:37:28 <lambdabot>   GT
09:37:38 <Philonous> > let nan = 0/0 in nan > nan
09:37:39 <lambdabot>   False
09:38:03 <Philonous> > let nan = 0/0 in flip compare $ nan nan
09:38:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a
09:38:31 <Philonous> > let nan = 0/0 in (flip compare) nan nan
09:38:33 <lambdabot>   GT
09:38:36 <Vulpyne> lastlog -25
09:38:38 <Absolute0> >  ('b',9) >=< (('a',1),('h',8))
09:38:39 <Vulpyne> Oops.
09:38:39 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:38:39 <lambdabot>         against inferred type...
09:38:46 <Absolute0> that returns false :(
09:39:06 <benmachine> :t (>=<)
09:39:08 <lambdabot> forall a. (Ord a) => a -> a -> Bool
09:39:18 <Absolute0> n >=< (l, u) = n >= l && n <= u
09:39:18 <Absolute0> onBoard position = position >=< (('a',1),('h',8))
09:39:30 <Absolute0> ('a',1) is not of type Ord?
09:39:37 <Twey> Umm
09:39:42 <benmachine> no, >=< isn't defined how you have it
09:39:54 <Absolute0> well it works fine by me
09:39:56 <benmachine> > ('a', 1) < ('b', 9)
09:39:57 <lambdabot>   True
09:40:04 <Twey> > ('b', 9) > ('a', 1)
09:40:05 <lambdabot>   True
09:40:07 <benmachine> > ('a', 9) < ('b', 1)
09:40:07 <quicksilver> Absolute0: Ord is a class not a type. But (Char,Int) is a member of Ord, yes.
09:40:08 <lambdabot>   True
09:40:09 <Twey> > ('b', 9) > ('a', 10)
09:40:10 <lambdabot>   True
09:40:14 <Absolute0> I want to check if a chesspiece is on the board.
09:40:20 <Twey> I think it compares the first one first, then the second
09:40:41 <Absolute0> oh right..
09:40:47 <benmachine> Absolute0: so er, you want that to return false then?
09:40:50 <Absolute0> I would need to use my own compare
09:40:53 <benmachine> which is what it does?
09:40:56 <benmachine> oh
09:41:05 <Absolute0> i am sorry it returns true..
09:41:05 <benmachine> never mind
09:41:06 <Absolute0> :)
09:41:15 <benmachine> right
09:41:20 <Absolute0> *MoveIterator> onBoard ('b',9)
09:41:20 <Absolute0> True
09:41:22 <Twey> Hehe
09:41:48 <benmachine> you need onBoard (x, y) = x >=< ('a', 'h') && y >=< (1, 8)
09:41:51 <benmachine> or some similar
09:42:03 <Absolute0> right
09:42:08 <benmachine> you can't do it with just an Ord instance unless it is a broken one
09:42:25 <benmachine> (probably not even then)
09:46:07 <quicksilver> you might find the Ix instance more appropriate
09:46:15 <quicksilver> it has something called 'inRange' or something
09:46:30 <quicksilver> it does rectangles not lexicographic
09:53:31 <dcoutts> if anyone wants to help test cabal-install-0.8 then grab it here:
09:53:33 <dcoutts> http://haskell.org/cabal/release/cabal-install-0.8.0/
09:55:47 <Absolute0> quicksilver: what implements Ix?
09:56:09 <Absolute0> http://www.zvon.org/other/haskell/Outputix/Ix_c.html instances = []
09:57:47 <eugenn> :t liftM2
09:57:47 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:58:29 <eugenn> :t liftM2
09:58:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:58:54 <quicksilver> Absolute0: most things.
09:58:58 <eugenn> :t liftM3
09:58:59 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
09:58:59 <quicksilver> :t inRange
09:59:00 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
09:59:19 <eugenn> :t liftM4
09:59:20 <lambdabot> forall a1 a2 a3 a4 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
09:59:24 <quicksilver> > inRange (('a',1'),('h',8)) ('c',4')
09:59:26 <lambdabot>   <no location info>:
09:59:26 <lambdabot>      lexical error in string/character literal at chara...
09:59:31 <quicksilver> > inRange (('a',1'),('h',8)) ('c',4)
09:59:32 <lambdabot>   <no location info>:
09:59:32 <lambdabot>      lexical error in string/character literal at chara...
09:59:47 <eugenn> > inRange (2,5) 3
09:59:48 <lambdabot>   True
09:59:59 <quicksilver> > inRange (('a',1),('h',8)) ('c',4)
10:00:01 <lambdabot>   True
10:00:05 <quicksilver> Absolute0: damn typos ;)
10:00:11 <quicksilver> Absolute0: anyway, isn't that what you want
10:00:13 <quicksilver> ?
10:00:43 <eugenn> :t liftM5
10:00:44 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
10:00:50 <eugenn> :t liftM1
10:00:51 <lambdabot> Not in scope: `liftM1'
10:00:55 <HaskellLove> anyone uses datatype invariants?
10:00:56 <eugenn> :t liftM6
10:00:57 <lambdabot> Not in scope: `liftM6'
10:01:12 * hackagebot upload: hesql 0.7 - Haskell's embedded SQL (ChristophBauer)
10:01:18 <eugenn> liftM2 1 2 map
10:01:26 <eugenn> > liftM2 1 2 map
10:01:27 <lambdabot>   No instance for (GHC.Num.Num ((a -> b) -> a1))
10:01:27 <lambdabot>    arising from the literal ...
10:02:12 <eugenn> :t =<<
10:02:13 <lambdabot> parse error on input `=<<'
10:03:00 <eugenn> span true [1,3..15]
10:03:04 <eugenn> > span true [1,3..15]
10:03:05 <lambdabot>   Not in scope: `true'
10:03:12 <eugenn> > span True [1,3..15]
10:03:13 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
10:03:14 <lambdabot>         against inferred ...
10:03:31 <eugenn> > span (\a -> True) [1,3..15]
10:03:32 <lambdabot>   ([1,3,5,7,9,11,13,15],[])
10:03:49 <theclaw> how do I load a module in ghci?
10:04:05 <theclaw> i.e. directly in ghci, not via a file which is loaded by ghci
10:04:12 <enolan> :m + Control.Monad
10:04:14 <enolan> like that
10:04:28 <theclaw> enolan: thanks
10:05:16 <eugenn> @quote goto
10:05:16 <lambdabot> anonymous says: Primitive recursion is the goto of functional programming.
10:05:44 <Absolute0> is either of foldl and foldr preferred when order us not important?
10:05:55 <Absolute0> s/us/is/
10:06:28 <enolan> foldl is tail recursive, and foldr is not. foldr is better when you want laziness, foldl when you want to build something strictly
10:06:32 <luite> hmm, should that actually say primitive recursion?
10:07:00 <sproingie> foldl is tail recursive but the laziness will still kill you
10:07:09 <sproingie> foldl' is when you want to build something strictly
10:07:35 <kmc_> whose desk is this: http://haskell.org/sitewiki/images/a/aa/Screen-triplehead-galois.jpg
10:07:52 <Absolute0> why would it kill?
10:08:04 <Absolute0> isn't laziness good?
10:08:13 <sproingie> > foldl (+) 0 [1..1000000]
10:08:14 <lambdabot>   * Exception: stack overflow
10:08:21 <sproingie> > foldl' (+) 0 [1..1000000]
10:08:22 <lambdabot>   500000500000
10:08:44 <sproingie> laziness is good up to a point
10:08:45 <kmc_> foldl will effectively reverse your entire list on the stack before calling
10:08:55 <kmc_> because foldl folds in the opposite direction from the list structure
10:09:02 <kmc_> it's unnatural, like petting a cat in the wrong direction
10:09:20 <Vulpyne> Some cats like that.
10:09:21 <jlouis> Absolute0: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' and http://www.haskell.org/haskellwiki/Fold
10:09:31 <Absolute0> the same applies for the scans?
10:09:36 <kmc_> foldr is natural for lists.  (foldr f z) just replaces each (:) with f and [] with z
10:09:51 <kmc_> so you can see foldr as a simple pass-through filter in this way
10:10:04 <kmc_> @where fold diagrams
10:10:04 <lambdabot> I know nothing about fold.
10:10:07 <kmc_> @where fold-diagrams
10:10:08 <lambdabot> I know nothing about fold-diagrams.
10:10:48 <kmc_> http://cale.yi.org/index.php/Fold_Diagrams
10:10:50 <jaredj> kmc_: given that it has 'galois' in the filename, i bet dons
10:11:05 <kmc_> there must be a lot of people at galois who use xmonad
10:11:19 <jaredj> oh. of course
10:11:50 <kmc_> @where+ fold.diagrams http://cale.yi.org/index.php/Fold_Diagrams
10:11:50 <lambdabot> It is forever etched in my memory.
10:11:54 <kmc_> @where+ fold-diagrams http://cale.yi.org/index.php/Fold_Diagrams
10:11:54 <lambdabot> Done.
10:11:57 <kmc_> @where+ fold_diagrams http://cale.yi.org/index.php/Fold_Diagrams
10:11:58 <lambdabot> Done.
10:11:58 <edwardk> zandax: still around?
10:12:00 <kmc_> @where fold_diagrams
10:12:00 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
10:12:02 <kmc_> @where fold
10:12:02 <lambdabot> I know nothing about fold.
10:14:04 <Absolute0> those diagrams are confusing
10:14:13 <Absolute0> they all look the same. :)
10:14:19 <kmc_> nah man :)
10:14:58 <kmc_> okay the one for mapAccumR is pretty confusing
10:15:04 <kmc_> @where vacuum
10:15:04 <lambdabot> http://moonpatio.com/vacuum/
10:15:33 <kmc_> the vacuum library will build graphs like this out of an actual running GHC Haskell process
10:16:43 <kmc_> using some high-grade esoteric magic
10:18:51 <eugenn> > zipWith ($) [1..5] (repeat (+1))
10:18:52 <lambdabot>   No instance for (GHC.Enum.Enum ((a -> a) -> b))
10:18:53 <lambdabot>    arising from the arithme...
10:19:02 <sproingie> can vacuum show sizes?
10:19:07 <sproingie> that would be useful
10:19:26 <eugenn> > zipWith ($) (repeat (+1)) [1..5]
10:19:27 <lambdabot>   [2,3,4,5,6]
10:20:12 <eugenn> > (even . length) [1,2,3,4,5]
10:20:13 <lambdabot>   False
10:20:29 <kmc_> see also http://www.archive.org/details/ClaudiusMaximus_-_ULCIv1
10:21:02 <sproingie> that's an odd composition
10:21:06 <sproingie> i'd have used $
10:21:21 <kmc_> > even . length
10:21:22 <lambdabot>   {[]->True;[()]->False;[(),()]->True;[(),(),()]->False}
10:22:43 <sproingie> doh where's my brane
10:23:08 <eugenn> :t shift
10:23:09 <lambdabot> forall a. (Bits a) => a -> Int -> a
10:23:10 <sproingie> oh yeah fried reinstalling haskell-platform umpteen times before i wandered into the patch for the install script
10:23:32 <eugenn> > shift 1001011 4
10:23:33 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:23:33 <lambdabot>    `Data.Bits.Bits t'
10:23:33 <lambdabot>      a...
10:26:08 <eugenn> is there a defined function that takes [1,2,3,4,5] and returns [5,1,2,3,4] ?
10:26:50 <kmc_> :t liftM2 (:) last init
10:26:51 <lambdabot> forall a1. [a1] -> [a1]
10:26:57 <kmc_> > liftM2 (:) last init [1..5]
10:26:58 <lambdabot>   [5,1,2,3,4]
10:27:31 <eugenn> oh, great! too bad I don't know liftM2 :P
10:27:42 <kmc_> more straightforward, \xs -> last xs : init xs
10:27:54 <sproingie> liftM2 lifts a 2-arg function into a monad
10:27:56 <kmc_> > (\xs -> last xs : init xs) [1..5]
10:27:57 <lambdabot>   [5,1,2,3,4]
10:27:57 <sproingie> in this case the list monad
10:27:58 <Absolute0> :t >=<
10:27:59 <lambdabot> parse error on input `>=<'
10:28:02 <Absolute0> :t `>=<`
10:28:04 <lambdabot> parse error on input ``'
10:28:07 <Absolute0> :t (>=<)
10:28:08 <lambdabot> forall a. (Ord a) => a -> a -> Bool
10:28:12 <kmc_> sproingie, no, in this case the ((->) a) monad
10:28:52 <Absolute0> shouldn't the second parameter be (a,a) ?
10:28:56 <sproingie> oh right on
10:29:12 <kmc_> eugenn, in this situation you can think of it as:   liftM2 f a b x = f (a x) (b x)
10:29:18 <kmc_> it is actually more general
10:29:22 * sproingie should disengage brain entirely and just lurk today
10:29:23 <kmc_> Absolute0, ?
10:29:26 <eugenn> oh
10:29:26 <kmc_> what situation
10:29:29 <kmc_> sproingie, nah man
10:29:33 * kmc_ hugs sproingie
10:29:48 <Absolute0> kmc_: >=< defined above
10:29:49 <sproingie> :)
10:31:49 <eugenn> > (\a -> take (length a) (cycle a)) [1,2,3,4,5]
10:31:50 <lambdabot>   [1,2,3,4,5]
10:32:14 <eugenn> > (\a -> take (length a) ((cycle . tail) a)) [1,2,3,4,5]
10:32:15 <lambdabot>   [2,3,4,5,2]
10:32:40 <EvanCarroll> how/win 2
10:33:32 <eugenn> > (\a -> take (length a) ((cycle . tail) a):(head a)) [1,2,3,4,5]
10:33:33 <lambdabot>   Occurs check: cannot construct the infinite type: a = [[a]]
10:35:04 <eugenn> > map (\(a,b) -> (b,a)) [(1,2),(3,4),(5,6)]
10:35:05 <lambdabot>   [(2,1),(4,3),(6,5)]
10:35:20 <poucet> > map (flip (,))  [(1,2),(3,4),(5,6)]
10:35:20 <lambdabot>   [{()->((),(1,2))},{()->((),(3,4))},{()->((),(5,6))}]
10:35:25 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14406 <- finished my monad, but I still don't know how to get IO actions into it though
10:35:43 <poucet> > map (uncurry . flip $ (,))  [(1,2),(3,4),(5,6)]
10:35:44 <lambdabot>   [(2,1),(4,3),(6,5)]
10:36:02 <eugenn> :t (,)
10:36:03 <lambdabot> forall a b. a -> b -> (a, b)
10:36:16 <eugenn> (,) 4 5
10:36:19 <eugenn> > (,) 4 5
10:36:19 <lambdabot>   (4,5)
10:36:25 <poucet> > (+) 4 5
10:36:26 <lambdabot>   9
10:36:34 <poucet> > (Just) 1
10:36:35 <lambdabot>   Just 1
10:36:41 <eugenn> I didn't know the comma was a function
10:36:47 <poucet> eugenn: it's not, it's a data constructor
10:37:11 <poucet> Well actually not really, it's the sliced version of (a,b)
10:37:36 <eugenn> > zipWith (,) [1,2,3] [4,5,6]
10:37:37 <lambdabot>   [(1,4),(2,5),(3,6)]
10:38:20 <eugenn> so zip = zipWith (,).. I wonder why is defined with the lambda instead in the prelude
10:39:30 <luite> > zipWith (,,1) [1..] [1..]
10:39:31 <lambdabot>   <no location info>: parse error on input `1'
10:39:54 <sproingie> you can't section tuple constructors
10:40:38 <luite> 6.12 has tuple sections
10:41:35 <eugenn> :t (,1)
10:41:35 <lambdabot> parse error on input `1'
10:41:36 <eugenn> :t (,) 1
10:41:36 <lambdabot> forall t b. (Num t) => b -> (t, b)
10:41:37 <sproingie> > zipWith ((,,) 1) [1..] [1..]
10:41:37 <lambdabot>   [(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1...
10:41:38 <kmc_> :t (,,,,)
10:41:38 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
10:41:39 <kmc_> :t (2,,,3)
10:41:39 <lambdabot> parse error on input `,'
10:41:39 <poucet> :t (,,,,,,,,,,,,,,,,,,,,)
10:41:39 <kmc_> ^^^^ coming in GHC 6.12
10:41:39 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n,
10:41:39 <lambdabot> o, p, q, r, s, t, u)
10:41:39 <sproingie> :t ((,,,,,) "chameleon")
10:41:40 <lambdabot> forall b c d e f. b -> c -> d -> e -> f -> ([Char], b, c, d, e, f)
10:41:40 <poucet> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:41:40 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
10:41:40 <lambdabot> t63 t64 t65 t66 t67 t68 t69. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -
10:41:40 <lambdabot> > t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 ->
10:41:40 <lambdabot> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40,
10:41:40 <lambdabot>  t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69)
10:41:40 <poucet> There's a size limit, no?
10:41:41 <sproingie> yes and no
10:41:41 <edwardk> poucet gets bored easily
10:41:41 <sproingie> to the literal syntax, no
10:41:41 <kmc_> ghc's instances for Show and such top out at 40 or something
10:41:48 <eugenn> :t (()
10:41:49 <poucet> edwardk: Clearly.
10:41:49 <lambdabot> parse error (possibly incorrect indentation)
10:41:55 <sproingie> for Show and such, 40.  haskell98 only requires up to something like 18?
10:42:10 <kmc_> it's pretty uncommon to use tuples bigger than 2
10:42:16 <kmc_> very uncommon to use bigger than 3
10:42:29 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14406 <- edwardk can you give me a hint now how to actually use that thing? :)
10:42:48 <sproingie> arrows sure love 2-tuples
10:42:52 <edwardk> zandax: sure.
10:43:24 <edwardk> zandax: it compile now?
10:43:28 <poucet> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
10:43:29 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
10:43:29 <lambdabot> t63 t64 t65 t66 t67 t68 t69 t70 t71 t72 t73 t74 t75 t76 t77 t78 t79 t80 t81 t82 t83 t84 t85 t86 t87 t88 t89 t90 t91 t92 t93 t94 t95 t96 t97 t98 t99 t100 t101 t102 t103 t104 t105 t106 t107 t108 t109
10:43:29 <lambdabot> t110 t111 t112 t113 t114 t115 t116 t117 t118 t119 t120 t121 t122 t123 t124 t125 t126 t127 t128 t129 t130 t131 t132 t133 t134 t135 t136 t137 t138 t139 t140 t141 t142 t143 t144 t145 t146 t147 t148
10:43:29 <lambdabot> t149 t150 t151 t152 t153 t154 t155 t156 t157 t158 t159 t160 t161 t162 t163 t164 t165 t166 t167 t168 t169 t170 t171 t172 t173 t174 t175 t176 t177 t178 t179 t180 t181 t182 t183 t184 t185 t186 t187
10:43:32 <lambdabot> t188 t189 t190 t191 t192 t193 t194 t195 t196 t197 t198 t199 t200 t201 t202 t203 t204 t205 t206 t207 t208 t209 t210 t211 t212 t213 t214 t215 t216 t217 t218 t219 t220 t221 t222 t223 t224 t225 t226
10:43:33 <poucet> damnit
10:43:35 <lambdabot> [24 @more lines]
10:43:35 <kmc_> urk
10:43:36 * poucet shuts up
10:43:39 <kmc_> hehe
10:43:45 <zandax> it compiles fine but I don't know how to put IO actions into the Random monad
10:43:46 <DigitalKiwi> lambdabot: spammer
10:43:48 <poucet> I was hoping it'd fail if I made it long enough
10:43:56 <kmc_> poucet, you can PM lambdabot ;P
10:43:57 <poucet> I tried /msg, but got nothing back
10:43:57 <edwardk> there are a couple of ways
10:44:01 <sproingie> i think you'd run into the irc line length limit first
10:44:05 <kmc_> poucet, /msg lambdabot @run 2+3
10:44:07 <edwardk> one option is to make an instance for MonadTrans
10:44:11 <edwardk> since you are a monad transformer
10:44:21 <kmc_> > fix error
10:44:22 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
10:44:27 <poucet> kmc_: lambdabot won't answer :t in privmsg
10:44:32 <poucet> kmc_: I tried before
10:44:32 <copumpkin> zomg
10:44:34 <copumpkin> optimus coprime?
10:44:36 <edwardk> instance MonadTrans Random where lift m = ...
10:44:36 <copumpkin> poucet: use @type
10:44:36 <eugenn> @where liftM2
10:44:37 <lambdabot> I know nothing about liftm2.
10:44:50 <edwardk> zandax: MonadTrans is in Control.Monad.Trans from the mtl
10:44:52 <kmc_> poucet, @type
10:44:58 <poucet> Thanks
10:45:13 <sproingie> handled a couple thousand commas just fine for me
10:45:14 <zandax> things are getting more and more complicated :|
10:45:16 <edwardk> zandax: another option is to just make your own little 'lift' routine. that has the signature. liftR :: Monad m => m a -> Random m a
10:45:22 <edwardk> zandax: well, all is not lost =)
10:45:32 <zandax> edwardk: yeah, I tried to make a lift function
10:45:35 <sproingie> so i suspect the limit is available RAM
10:45:43 <edwardk> zandax: then you define instance MonadTrans Random where lift = liftR
10:45:58 <edwardk> when you get around to making this a transformer
10:46:08 <edwardk> but lets focus on how to define liftR
10:46:15 <zandax> but as I can see now I just failed to write the right type signature
10:46:15 <Kruppe> is there a place where I can look at the docs for previous versions of haskell?
10:46:25 <zandax> I did something like: Monad m => m -> Random m a
10:46:36 <zandax> Types still confuse me
10:47:13 <sproingie> i think i'll make my entire roguelike program use a 100x100 grid and write it as functions on 10000-tuples
10:47:31 <copumpkin> :O
10:47:39 * copumpkin hopes sproingie is kidding
10:47:47 * DigitalKiwi hopes he isn't
10:47:51 <sproingie> type signatures are gonna be a bitch
10:48:07 <copumpkin> no haskell compiler supports tuples that big
10:48:20 <copumpkin> you'll have to write your own massive datatype
10:48:23 <edwardk> instance MonadTrans (Random s) where lift m = RND $ \s -> do a <- m; return (a, s)
10:48:44 <edwardk> zandax: no problem you'll get there
10:48:59 <sproingie> i just did a :t on (,,,,,,,,,,,,,, etc*10000)
10:49:05 <eugenn> > (!!) [4,(5/0)] 0
10:49:06 <lambdabot>   4.0
10:49:13 <sproingie> if it doesn't support actually compiling it, i should open a bug :)
10:49:23 <edwardk> zandax: then what you can do is: lift $ putStrLn "foo"
10:49:29 <edwardk> as an action in your monad
10:49:31 <eugenn> :t lift
10:49:32 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
10:50:01 <Absolute0> What would be an elegant way of generating [(x,y)] where x,y are either 1 or -1?
10:50:02 <Vulpyne> You could use TH to help with manipulating your 1000 tuples.
10:50:38 <Absolute0> ie: [(1,1),(1,-1) ..
10:51:19 <Absolute0> [(x,y) -> [1,-1]] :-P
10:51:33 <edwardk> zandax: if you want to be 'complete' you can make a MonadIO instance as well. not that much uses it.
10:51:38 <eugenn> > zip (repeat 1) (repeat (-1))
10:51:38 <copumpkin> Vulpyne: nope, GHC still doesn't support tuples that big
10:51:39 <lambdabot>   [(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-1),(1,-...
10:51:46 <edwardk> instance MonadIO Random where liftIO = lift . liftIO
10:51:53 <kmc_> > 2 ^ 5
10:51:54 <lambdabot>   32
10:51:55 <Absolute0> thats not it
10:52:00 <zandax> edwardk: what will that do?
10:52:00 <copumpkin> you could do Mu ((,) a)
10:52:04 <sproingie> > do { x <- [1,2]; y <- [1,2]; return (x,y); }
10:52:05 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
10:52:08 <Absolute0> right
10:52:13 <sproingie> whups
10:52:20 * copumpkin proposes renaming Mu to Moo
10:52:20 <Absolute0> you don't need the monad syntax
10:52:23 <sproingie> personally i'd just use the listcomp
10:52:30 <eugenn> :t Mu
10:52:31 <lambdabot> Not in scope: data constructor `Mu'
10:52:58 <sproingie> copumpkin: \Moo
10:53:01 <edwardk> zandax: well, that helps if you use your transformer to transform another monad transformer, and don't want to 'count' the lifts to get the to IO in the center of the tootsie-pop
10:53:23 <Absolute0> [(x,y)| x<-[1,-1], y <-[1,-1]]
10:53:38 <Absolute0> is there a shorter way to write: x<-[1,-1], y <-[1,-1] ?
10:53:40 <edwardk> zandax: i.e. no matter how many monads you have nested around IO you can just 'x <- liftIO getStrLn'
10:53:41 <Vulpyne> Heh, emacs syntax highlighting does not like gigantic tuples.
10:53:55 <chrisdone> reet
10:53:56 <sproingie> shorter perhaps.  obvious probably not
10:54:06 <zandax> edwardk: that looks interesting, I will try that!
10:54:22 <Absolute0> (x,y) <- [1,-1] fails
10:54:37 <sproingie> naturally
10:54:48 <Absolute0> i was hoping it wouldn't :)
10:54:48 <sproingie> you're trying to pattern match (x,y) against [1,-1]
10:54:51 <Absolute0> right
10:55:03 <Vulpyne> copumpkin: I guess you were right. :( "x.hs:5:10:    A 3996-tuple is too large for GHC      (max size is 62)"
10:55:24 <eugenn> > sequence [1,-1]
10:55:25 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
10:55:25 <lambdabot>    arising from a use of `M47412723...
10:55:25 <copumpkin> Vulpyne: yeah :P why not just do data X = X Int Int Int Int Int Int Int ...
10:55:38 <Vulpyne> That's true.
10:55:45 <sproingie> i guess i'll just have to do it in terms of nested 62-tuples
10:55:48 <eugenn> > sequence [1,(-1)]
10:55:49 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
10:55:49 <lambdabot>    arising from a use of `M47589724...
10:55:52 <sproingie> woo, base 62
10:56:01 <eugenn> :t sequence
10:56:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:56:43 <Absolute0> No instance for (Num (m a))
10:56:48 <edwardk> zandax: if you want most of the instances on StateT here: http://www.haskell.org/ghc/docs/6.10.4/html/libraries/mtl/src/Control-Monad-State-Lazy.html can be applied to your Random so that if you wrap writer, reader, error, etc. they can all do the right thing when you ask to 'get' or 'put' or 'ask' or 'tell' something.
10:57:09 <edwardk> zandax: but that is possibly a bit more work than you're ready for.
10:57:15 <Vulpyne> sproingie: Use something in the style of data X a b c d e f g h i j k l m n o p = X a b c d e f g h i j k l m n o p :)
10:57:33 <zandax> that looks a bit complicated, I wanted to keep it as simple as possible
10:57:40 <zandax> yep
10:58:03 <zandax> Can I find die MonadIO class somewhere in the modules?
10:58:24 <eugenn> :t transpose
10:58:25 <lambdabot> forall a. [[a]] -> [[a]]
10:58:27 <edwardk> Control.Monad.Trans
10:58:42 <edwardk> contains both MonadTrans and MonadIO
10:58:49 <sproingie> X a b c d e f g h i j k l m n o p q r s t u v w x y z = Y | X X X X X X X X X X X X X X X X X X X X X X X X X X X
10:58:59 <edwardk> those are the two you _should_ implement, the others are niceties ;)
10:59:19 <zandax> "instance MonadIO Random where liftIO = lift . liftIO"  <- okay, it says 'Illegal type in class constraint' :(
10:59:38 <edwardk> ah oops
10:59:45 <poucet> sproingie: you will have to parametrize all the Xs except for the first one which is a dataconstructor
10:59:49 <copumpkin> sproingie: not sure that would work :)
10:59:49 <eugenn> :t unwords
10:59:50 <lambdabot> [String] -> String
10:59:59 <sproingie> maybe i should only use 10 types and call it a finger tree :)
11:00:05 <copumpkin> lol
11:00:05 <edwardk> instance (MonadIO m) => MonadIO (Random m) where liftIO = lift . liftIO
11:00:08 <poucet> .. = Y | X (X a b. ..) (X a b ..) ..
11:00:39 <Vulpyne> There should be something like IOCCC for Haskell. :)
11:00:48 <sproingie> Vulpyne: that's called hackage
11:00:54 <Vulpyne> Zing.
11:02:00 <zandax> edwardk: that works just fine, I'll have a look at it later and will try to understand everything, thank you very much so far!
11:02:18 <edwardk> zandax: no problem =)
11:02:30 <edwardk> zandax: so does it let you embed IO actions now?
11:02:44 <zandax> yes
11:02:59 <zandax> one last thing:
11:03:03 <edwardk> shoot
11:03:12 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14406 <- is it possible to get rid of the "return () :: IO ()"
11:03:17 <zandax> doesn't look so cool
11:03:24 <gwern> supercompilation is a very unclear term
11:03:35 <gwern> I was reading ndm's paper, and it looked like partial evaluation to me
11:03:52 <edwardk> sure, just return () as the last thing in your internal monad
11:04:04 <edwardk> run $ do ....; return ()
11:04:07 <edwardk> or better
11:04:32 <edwardk> run $ do ... ; liftIO $ putStrLn "Hello World"
11:04:53 <edwardk> just end on a lifted IO action that happens to return a unit
11:05:07 <zandax> it says "Unresolved top-level overloading" :/
11:05:34 <zandax> Binding: main, Outstanding context: MonadIO b
11:05:38 <edwardk> write: main :: IO () above the main definition
11:05:53 <aavogt> disable monomorphism restriction?
11:06:00 <zandax> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14388#a14407 <- here is the new source
11:06:26 <zandax> oh, now it works fine with the type signature!
11:06:56 <Absolute0> how do I skip the first iteration when calling iterate?
11:07:03 <aavogt> tail
11:07:08 <Absolute0> :)
11:07:14 <edwardk> also you might consider using a more haskell-idiomatic lift $ putStrLn "Hello World"
11:07:30 <gwern> @seen ndm
11:07:30 <lambdabot> Unknown command, try @list
11:07:31 <edwardk> haskell is the anti-lisp ;)
11:07:36 <gwern> ,seen ndm
11:07:38 <lunabot>  luna: Not in scope: `seen'
11:07:42 <gwern> what
11:07:52 <gwern> mmorrow: explain your bot's insolence!
11:08:08 <edwardk> also you don't need the 'do' for your main because it only calls one method
11:08:15 <zandax> $ is pretty cool, other languages should have that as well :)
11:08:24 <ddarius> The identity function?
11:08:38 <zandax> yeah, I noticed that
11:09:11 <edwardk> ,xseen ndm
11:09:12 <lunabot>  luna: Not in scope: `xseen'
11:09:19 <edwardk> preflex: xseen ndm
11:09:19 <preflex>  Sorry, I haven't seen ndm
11:09:25 <aavogt> do other languages also have user assignable fixities?
11:09:28 <sproingie> $ works because of currying
11:09:37 <gwern> zandax: I'm starting to dislike $, actually
11:09:43 <edwardk> clearly removing @seen to cut channel spam has had the opposite effect
11:09:44 <sproingie> other languages would have to support that before they could define $
11:09:46 <gwern>  . or $, choose!
11:09:55 <aavogt> most of the ones I've seen just look at the first character
11:09:56 <zandax> gwern: oh, why?
11:10:10 <gwern> zandax: it confuses new people, and can make definitions harder to read
11:10:14 <edwardk> gwern: bah. start with converting to $'s then find the places where they can become .'s
11:10:25 <edwardk> not every $ can become a .
11:10:37 <sproingie> scala has weird fixity resolution based on the first or sometimes the last character
11:10:52 <zandax> I always thought of $ like an "invocation operator"
11:10:57 <sproingie> any method ending in : becomes right-associative
11:11:01 <sproingie> stuff like that
11:11:12 <gwern> edwardk: can't they? with appropriate lambda and parens
11:11:44 <edwardk> gwern: well, with appropriate lambdas and parens $ isn't needed as it is just id ;)
11:11:45 <thaldyron> I have a large 'Data.Map k a' that I need to make thread safe; am I on the right track (performance-wise) by using 'TVar (Map k (TVar a))'?
11:11:57 <edwardk> gwern: but removing parens was the whole point of putting in the $!
11:12:11 <gwern> edwardk: I think $ isn't needed anywhere near as often as it's used
11:12:23 <gwern> the other day I saw someone paste their xmonad.hs - 'main = xmonad $ myConfig'
11:12:26 <aavogt> it isn't needed at all
11:12:26 <sproingie> it's really handy for do-blocks
11:12:28 <gwern> this was not the first time
11:12:36 <aavogt> ever
11:12:43 <sproingie> foo $ do ...
11:12:47 <edwardk> gwern: that one is fairly egregious, but you don't know how they got there.
11:13:07 <edwardk> foo $ do is my favorite reason for getting used to it wrapping a do in ()'s makes me sad
11:13:12 <gwern> edwardk: I know exactly how they got there, they copy-pasted because they didn't understand . and $ and function application
11:13:16 <sproingie> any syntax sugar can be abused
11:13:28 <edwardk> i do wish the grammar was adjusted to break from straight fixity to allow for 'foo do ...' to just work
11:13:40 <copumpkin> edwardk: runST $ do ... ?
11:13:43 <gwern> sproingie: but is any abused quite as often as $? 'do', maybe but that's all I can think of
11:13:46 <edwardk> gwern: i've wound up there as i kept simplifying the rhs
11:13:56 <sproingie> gwern: if/then/else perhaps
11:14:07 <gwern> mm. I don't see if that often, actually
11:14:31 * gwern checks into my find/grep job
11:14:43 <gwern> ouch. apparently there are >1000 uses of 'sort' in my collection of repos
11:14:48 <sproingie> mostly newbie code (like mine)
11:14:56 <sproingie> 'cept i know it's icky so i try to factor it out
11:14:57 <gwern> and ghc is still not using the apparently faster yhc sort either
11:15:46 <gwern> wonder whether criterion would be good for benchmarking the 2 sorts
11:16:19 <gwern> has anyone used criterion before? how well does it work for pure list functions?
11:17:01 <jmcarthur> criterion works nice if you can find a good way to force results
11:17:07 <sproingie> i could use a criterion for size
11:17:09 <jmcarthur> rnf
11:17:15 <sproingie> pretty graphs of size consumption
11:17:29 <jmcarthur> sproingie: different from heap profiling?
11:17:34 <gwern> jmcarthur: just have to force the spine of the list I would guess
11:17:53 <gwern> a length would do it
11:17:56 <sproingie> profilers are all well and good, i just want an easy front-end with pretty output
11:22:00 <kmc_> there's some graphing frontend to ghc's heap profiler
11:23:34 <gwern> the postscript stuff?
11:23:48 <kmc_> yeah
11:27:05 <zygoloid> why are "foo do" and "foo \x -> ..." not legal?
11:27:56 <sproingie> :t map \x -> x+1
11:27:57 <lambdabot> parse error on input `\'
11:28:35 <zygoloid> :t id let x = 42 in x
11:28:36 <lambdabot> parse error on input `let'
11:29:12 <zygoloid> i'd let x = 42. haskell wouldn't. ;-(
11:29:25 <sproingie> > replicateM 5 do return 1 :: Just Int
11:29:26 <lambdabot>   <no location info>: parse error on input `do'
11:29:33 <sproingie> ambiguity ahoy
11:29:40 <sproingie> > replicateM 5 $ do return 1 :: Just Int
11:29:41 <lambdabot>   Not in scope: type constructor or class `Just'
11:29:46 <sproingie> doh
11:29:50 <sproingie> > replicateM 5 $ do return 1 :: Maybe Int
11:29:51 <lambdabot>   Just [1,1,1,1,1]
11:30:07 <zygoloid> sproingie: the 'as far to the right as possible' rule seems to apply
11:30:26 <zygoloid> at least for let, if and lambda...
11:30:29 <sproingie> makes sense
11:33:54 <saml> hey, given a string, i want to get rid of all parenthesis and save indexes.  "(ab) (cde)" ==> "ab cde"   and [(0,2), (3,6)]
11:34:33 <Absolute0> if the I have the following in some function (x ++ y ++ z) and x,y,z are defined as lists elsewhere. Does the concatenation only occur once, or on each function invocation?
11:35:03 <Absolute0> saml: use regexp
11:35:28 <luqui> Absolute0, depends
11:35:46 <Lemmih> Absolute0: The compiler is free to do either.
11:35:52 <luqui> Absolute0, you mean it's like f w = x ++ y ++ z  ?
11:36:30 <Absolute0> ghc
11:36:36 <Absolute0> luqui: yes
11:36:44 <luqui> Absolute0, as Lemmih says.  without -O, probably multiple times, with -O probably once.  but it is probably best to be explicit if you want the sharing
11:36:56 <luqui> f = let list = x ++ y ++ z in \w -> list
11:37:10 <luqui> it will certainly only be computed once if it is not under a lambda
11:37:20 <Absolute0> i just defined foo = x ++ y ++ z
11:37:28 <Absolute0> turns out i need it more than once :)
11:37:29 <luqui> Absolute0, oh, that's not a function
11:37:36 <luqui> that'll happen just once
11:37:43 <Absolute0> luqui: no i mean i did that just now
11:37:44 <gwern> hm
11:37:46 <Absolute0> didnt have that before
11:37:47 <gwern> I just had an idea
11:38:08 <gwern> suppose I wrote a program to spider hackage for every darcs or git repo url, and then shelled out to download them
11:38:18 <gwern> (or pull, presumably). would anyone use that?
11:38:54 <Absolute0> what's the syntax for using guards in case expressions?
11:39:21 <luqui> case foo of x | x == 4 -> ...
11:39:32 <luqui> same as in definitions, except use a -> instead of the rightmost =
11:40:22 <Absolute0> oh thanks
11:41:23 <kmc_> gwern, what's the use case?
11:41:32 <gwern> kmc_: someone who wants all the repos
11:41:50 <gwern> or at least a snapshot of the public haskell community to a good approximation
11:42:32 <gwern> it's useful to be able to grep them all
11:42:34 <luqui> saml, what is the output for a string like "(ab(cde)(fg"
11:42:44 <gwern> general idea of how often something is used, examples, etc.
11:43:20 <saml> luqui, "ab(cde(fg"  and [(0,5)]
11:43:48 <saml> it it can be just error. inputs should not have nested parens
11:43:54 <luqui> saml, you sure it's not "(abcde(fg" and [(3,5)]  ?
11:43:55 <saml> and all parens match
11:44:07 <luqui> saml, ah so you are parsing
11:44:17 <saml> yup. i'm using regex to replace
11:44:49 <luqui> saml, to be honest, I would go about it using something like ReadP using "character type" (Int,Char)
11:44:54 <luqui> passing it zip [0..] input
11:45:09 <luqui> some might consider that overkill.  i'm partial to parser combinators
11:45:35 <dcsobral> I'm reading http://bit.ly/4pTFBC and I would like to type the code on a REPL, but neither hugs nor ghci seems to accept the data declaration at the beginning. What am I doing wrong?
11:45:37 <Absolute0> Can I use data constructors in conjunction with X | Y | Z..?
11:46:03 <luqui> dcsobral, unfortunately you cannot define new types in the repl
11:46:04 <Absolute0> data FooBar = Foo Bar (X|Y|Z)
11:46:25 <copumpkin> no
11:46:28 <kmc_> Absolute0, no
11:46:34 <kmc_> each alternative needs to get its own constructor
11:46:41 <kmc_> data FooBar = Foo X | Bar Y | Baz Z
11:46:46 <Absolute0> oh
11:46:46 <copumpkin> data XYZ = X | Y | Z
11:46:46 <Absolute0> ok
11:46:49 <Absolute0> thats annoying
11:46:51 <copumpkin> data FooBar = Foo Bar XYZ
11:47:01 <copumpkin> it's fine to factor them out though :)
11:47:10 <Absolute0> I have a chess piece
11:47:13 <Absolute0> and it should get a color
11:47:17 <kmc_> Absolute0, it's fundamental to the way pattern matching works
11:47:22 <Absolute0> not sure what to call a datatype with no color
11:47:25 <Absolute0> its still a chesspiece
11:47:26 <Absolute0> :)
11:47:37 <kmc_> what would the type (A|B) mean? If you get a value with that type, how do you tell if it's an A or a B?
11:47:42 <Absolute0> s/datatype/chesspiece/
11:47:48 <lament> "kind"? :)
11:47:55 <eivuokko> Or Type.
11:47:57 <lament> data Piece = Piece Kind Color
11:47:59 <tromp__> aor b A = "It's an A!"
11:48:04 <monochrom> data Piece = IHazColor Color  | Monochrome ;  data Color = ...
11:48:16 <luqui> lol
11:48:16 <tromp__> aorb B = "It's a B!"
11:48:28 <luqui> this discussion is the most ambiguous i have seen in a while
11:48:29 <Absolute0> Is Piece = Piece good style?
11:48:39 <luqui> different people interpreting the questions in different ways
11:48:42 <lament> Absolute0: yes
11:48:46 <kmc_> Absolute0, data Piece = Piece Foo Bar?
11:48:46 <Absolute0> it becomes tedious writing Piece everywhere
11:48:56 <luqui> Absolute0, what would you prefer?
11:48:59 <monochrom> I have seen more ambiguous ones recently.
11:48:59 <Twey> ‽
11:49:09 <Absolute0> Color Type works fine..
11:49:19 <Absolute0> Extra piece constructor seems extra
11:49:31 <bnijk_> hmm
11:49:39 <lament> Absolute0: it shouldn't even matter what the internals of your data type are, since presumably you would access them through accessor functions like "color" and "type"
11:49:40 * kmc_ has come to believe that the H98 "data" syntax is not very good and is quite confusing to beginners
11:49:46 <luqui> so you want to write "White Pawn"
11:49:46 <Philonous> data Piece = Piece (Maybe Color) <other parameters>
11:49:46 <kmc_> dare we to introduce GADT syntax first?
11:50:07 <luqui> Absolute0, that would imply that White :: Kind -> Piece... which is kind of weird
11:50:15 <kmc_> you can define a function to do it
11:50:17 <luqui> you could do it...
11:50:26 <luqui> data Piece = White Kind | Black Kind
11:50:33 <Absolute0> luqui: same with (Kind Piece) ?
11:50:39 <Twey> kmc_: I concur
11:50:45 <kmc_> white :: Kind -> Piece; white k = Piece White k
11:50:49 <lament> luqui: ha, that's kinda cute
11:50:50 <kmc_> or just white = Piece White
11:50:53 <Absolute0> luqui: same with (Kind Color) ?
11:51:00 <kmc_> i think "data Piece = White Kind | Black Kind" is bad
11:51:04 <lament> i think it's bad, too
11:51:05 <kmc_> that's a sum where it should be a product
11:51:06 <lament> but it's cute
11:51:12 <kmc_> every piece has a kind, and separately, a color
11:51:14 <luqui> yeah i would recommend against it :-)
11:51:15 <kmc_> :)
11:51:18 <kmc_> it is cute
11:51:32 <lament> especially since "color" is definitely a separate context that will find use on its own
11:51:32 <kmc_> i think "smart constructor" functions are the way to be cute here
11:51:32 <bnijk_> lol
11:51:37 <bnijk_> data Piece = White Kind | Black Kind
11:51:39 <lament> s/context/concept
11:51:50 * bnijk_ gets the torches ready
11:52:31 <monochrom> Do whatever you want. Experiment with actual usage. You will find how much it rocks or sucks.
11:52:31 <Cale> It was a long time ago now, but I'm pretty sure that I found the data syntax intuitive, but I knew about context free grammars at the time.
11:52:35 <luqui> Absolute0, you might be getting confused by the data syntax.  when you say data A = B C | D E, despite the symmetry, there are a few different things going on.  A,C,and E are types, but B and D are constructors.
11:52:50 <kmc_> Absolute0, as regards "data Foo = Foo ...", using the same name for type and value ctors... i think it should never be done for >1 constructor, and always done for 1 constructor
11:52:54 <kmc_> with a few exceptions
11:53:20 <Absolute0> Using white and black as constructors was just what i needed..
11:53:24 <lament> Absolute0: NO
11:53:32 <monochrom> And I say that because your question has no unique right answer. It depends on your usage.
11:53:33 <lament> :)
11:53:33 <Absolute0> YES
11:53:35 <Absolute0> :-P
11:53:38 <bnijk_> i'm hungry
11:53:40 <lament> Absolute0: no, seriously, it's the wrong thing to do
11:53:40 <bnijk_> what should i order
11:53:53 <Absolute0> ChessPiece Color Kind is annoying
11:53:55 <kmc_> data Color = White | Black; data Kind = Pawn | Rook | ...; data Piece = Piece Color Kind; white = Piece White; black = Piece Black
11:54:08 <kmc_> Absolute0, why is it annoying? You only have to write it once
11:54:10 <lament> Absolute0: the problem is that you might need the Color type anyway
11:54:22 <kmc_> Absolute0, with this solution you can write "white Knight"
11:54:23 <Absolute0> lament: well thats what pattern matching does..
11:54:25 <lament> Absolute0: for example, to encode whose turn it currently is
11:54:30 <Cale> type Color = Bool  ;)
11:54:31 <lament> Absolute0: not the color of a piece; just a color
11:54:32 <luqui> Absolute0, you will find that correctness in modeling goes a *lot* further to the cleanliness of your code than syntactic convenience
11:54:34 <kmc_> yet you also get "White" and "Black" as usable things
11:54:40 <roconnor> Cale: shh
11:54:42 <luqui> Absolute0, just bite the bullet and write the extra word.
11:54:49 <kmc_> luqui, yes.  that's something where most languages fail miserably
11:54:51 <luqui> Absolute0, or write helper functions to cut down on it.
11:55:00 <kmc_> they sacrifice understandable semantics for a little syntactic niceness
11:55:29 <bnijk_> is this #gnaa
11:55:34 <bnijk_> i got lost...
11:55:35 <kmc_> yes
11:55:38 <lament> Absolute0: also, you will not actually write stuff like Piece White Knight very often
11:55:42 <Absolute0> let isWhite piece | White _ -> True | otherwise False
11:55:54 <kmc_> that syntax is borked
11:56:07 <Absolute0> lament: I am rewriting my code and i do have it everywhere :(
11:56:08 <kmc_> Absolute0, you can build in record selectors
11:56:11 <Absolute0> so i am trying to clean it up
11:56:21 <kmc_> data Piece = Piece { color :: Color, kind :: Kind }
11:56:27 <kmc_> isWhite = (== White) . color
11:56:51 <monochrom> This debate is lame.
11:57:14 <tromp__> this debate is not monochrome
11:57:17 <Absolute0> :)
11:57:24 <roconnor> Phantom variable!
11:57:40 <roconnor> data Piece a = Knight | King | ...
11:57:50 <roconnor> data White =
11:57:54 <roconnor> data Black =
11:58:01 <lament> Absolute0: well, hopefully if you choose to do it the wrong way at least you understand why it's wrong :)
11:58:02 <roconnor> Knight :: Piece White
11:58:08 <roconnor> Knight :: Piece Black
11:58:21 <eivuokko> Modelling which side piece belongs at piece-level is anyway a bit silly imo.
11:58:27 <xerox> type Stone = Bool -- let's play Go, Chess is boring
11:58:28 <roconnor> :P
11:58:36 <Twey> Hehe
11:58:37 <luqui> choosePiece :: player -> Piece player
11:59:03 <roconnor> luqui: good point
11:59:06 <roconnor> data White = White
11:59:09 <tromp__> ok, xerox, 2x2 go. i play A1. your move
11:59:09 <roconnor> data Black = Black
11:59:25 <xerox> tromp__: I resign.
11:59:27 <lament> eivuokko: why? data Square = Maybe Piece
11:59:30 <roconnor> tromp__: what are the ko rules?
11:59:37 <tromp__> positional superko
11:59:48 <roconnor> tromp__: B2
11:59:53 <Twey> Hahaha
11:59:54 <tromp__> A2
11:59:57 <xerox> You can't ko!
11:59:58 <lament> the only person who uses positional superko
11:59:59 <lament> is tromp
12:00:03 <Twey> tromp__ wins :þ
12:00:07 <Absolute0> I am using hashmap position -> piece to represent the board, is there a more effecient data structure?
12:00:09 <roconnor> tromp__: B1 I take your pieces
12:00:19 <lament> Absolute0: yes.
12:00:22 <tromp__> A2
12:00:32 <lament> Absolute0: This is a very, very well-developed area
12:00:34 <kmc_> haha
12:00:36 <lament> Absolute0: read 10 papers
12:00:39 <roconnor> tromp__: A1 I take your piece
12:00:44 <tromp__> A2
12:00:50 <roconnor> crap!!
12:00:50 <tromp__> take yours:)
12:00:51 <roconnor> :D
12:00:53 <kmc_> prove at compile time that your board cannot make illegal moves :D
12:00:54 <Absolute0> @where chess
12:00:54 <lambdabot> I know nothing about chess.
12:00:57 <Absolute0> :(
12:01:01 <roconnor> tromp__: B1
12:01:06 <tromp__> A1
12:01:25 <roconnor> tromp__: you win, I have no more legal moves.
12:01:31 <tromp__> you can always pass
12:01:35 <roconnor> I can?
12:01:39 <tromp__> anytime
12:01:42 <roconnor> strange rules
12:01:44 <roconnor> ok
12:01:49 <lament> what? not having legal moves makes you lose?
12:01:50 <roconnor> I pass
12:01:51 <tromp__> passing is normal
12:01:57 <tromp__> i pass too
12:01:57 <roconnor> lament: in standard game theory.
12:01:58 <monochrom> Is this an infinite game?
12:02:15 <luqui> nah the game's over now
12:02:16 <roconnor> tromp__: you can't pass can you?
12:02:21 <Absolute0> are bit boards possible in haskell?
12:02:24 <roconnor> tromp__: that would repeat a board position.
12:02:26 <tromp__> anyone can pass anytime
12:02:31 <kmc_> Absolute0, yes
12:02:33 <tromp__> well, if it's their turn:)
12:02:41 <roconnor> tromp__: I pass again
12:02:47 <kmc_> Absolute0, if you want to optimize for performance, use an IOUArray Int
12:02:51 <kmc_> or IOUArray Word64
12:02:52 <luqui> Absolute0, you clearly are a beginner.  don't go there.
12:02:56 <tromp__> repeating is only forbidden for moves
12:02:57 <xerox> how many did you capture?
12:03:00 <kmc_> and use Data.Bits functions to manipulate them
12:03:04 <kmc_> and make everything strict
12:03:08 <kmc_> (STUArray is fine too)
12:03:08 <tromp__> we use area rules i hope
12:03:17 <Absolute0> luqui: how else would one learn?
12:03:18 <Absolute0> :-P
12:03:19 <tromp__> just count stones+surrounded empty
12:03:31 <tromp__> 2 for me, 1 for you:)
12:03:33 <roconnor> tromp__: I like the rule where the person with no legal move loses
12:03:35 <xerox> captured stones + surrounded empty
12:03:36 <luqui> Absolute0, well by getting your game to work without needless optimizations first.
12:03:43 <Absolute0> luqui: that part is done
12:03:45 * hackagebot upload: AES 0.2.3 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
12:03:58 <roconnor> tromp__: but yes, area counting is fine.
12:04:04 <Absolute0> luqui: thinking more than 2 moves ahead runs forever..
12:04:05 <roconnor> tromp__: congratulations
12:04:12 <roconnor> tromp__: I thought I had you there.
12:04:14 <tromp__> thanks
12:04:21 <luqui> Absolute0, you are using hashmap?
12:04:29 <Absolute0> also my ai is pretty stupid
12:04:37 <tromp__> this was but one of MANY possible 2x2 games
12:04:37 <Absolute0> i do blind search on the entire board
12:04:43 <roconnor> tromp__: really?
12:04:45 <tromp__> can you guess how many??
12:04:55 <tromp__> it's more than you think:(
12:04:58 <Absolute0> instead of iterating the actual moves
12:05:08 <roconnor> tromp__: don't I have to block your diagonal?
12:05:12 <Absolute0> need to do alpha beta pruning
12:05:25 <roconnor> tromp__: if you get exactly two diagonal stones you win for sure.
12:05:30 <tromp__> when i say possible, that includes dumb games
12:05:45 <tromp__> like pass, A1, A2, pass,....
12:05:53 <roconnor> tromp__: I guess I should have passed on my second turn.
12:06:13 <tromp__> in area rules, B can always win by 1
12:06:13 <xerox> < 3^4
12:06:24 <tromp__> not positions, xerox. games
12:06:36 <xerox> > 3^4 hehe
12:06:37 <lambdabot>   Not in scope: `hehe'
12:06:46 <tromp__> hehe
12:06:48 <inimino> heh
12:06:59 <roconnor> tromp__: I prefer rules with no passing and the first player who cannot move loses.
12:07:04 <xerox> you've got some nice diagrams in your Combinatorics of Go, tromp ;)
12:07:07 <roconnor> tromp__: granted these are non traditional rules
12:07:18 <inimino> I've never even heard of those rules.
12:07:34 <tromp__> that's very elegant, roconnor, but a little too unlike how people actually play go
12:07:37 <roconnor> tromp__: but I think they are equivalent to what I am told are ancient rules: where you lose two point per disconnected group at the end of the gaim.
12:07:48 <roconnor> game
12:07:58 <tromp__> yeah, that's called stone scoring
12:08:03 <xerox> roconnor: in those setting there is no "pass" ?
12:08:09 <tromp__> see how many stones you can lay down
12:08:20 <tromp__> stone scoring also has pass
12:08:22 <roconnor> xerox: hmm, I'm not sure what the ancient rule on passing are.
12:08:46 <roconnor> xerox: but the idea would be (equivalent to AGA rules) to play in your territory instead of passing.
12:09:23 <xerox> I think that changes the game a bit.
12:09:44 <tromp__> not having pass changes it quite a bit
12:09:47 <roconnor> AGA rules passing and playing in your territory is the same.
12:09:57 <roconnor> well very close to the same
12:10:15 * roconnor tries to think of a difference.
12:10:43 <roconnor> anyhow
12:10:57 <roconnor> in mathematical go, you would have no passing and stone scoring.
12:11:09 <tromp__> when you cant pass, and both players have enclosed same size area, results still dpends on its shape
12:11:09 <roconnor> it is like the perfect game :D
12:11:12 <xerox> Seems like the parity of your enclosed intersections matters.
12:11:41 <roconnor> tromp__: how do you mean?
12:11:51 <roconnor> xerox: how do you mean too?
12:11:51 <xerox> Two empty spaces, together, or two eyes
12:12:11 <tromp__> for instance, 4 1pt eyes is much better than 2 2pt eyes
12:12:14 <roconnor> well, two empty spaces together is only one 1
12:12:16 <roconnor> one eye
12:12:47 <xerox> I was going for completely trivial, right. Three spots.
12:12:52 <roconnor> tromp__: I don't see why that is the case.  They are both reduced to 2 1pt eyes after two passes
12:13:10 <tromp__> i'm talking about the no-passing game
12:13:18 <roconnor> tromp__: so am I
12:13:30 <tromp__> but you talk about two passes!
12:13:50 <roconnor> tromp__: lets say one person has 4 1pt eyes and the other has 2 2pt eyes
12:14:00 <roconnor> tromp__: the winner will depend on whose turn it is
12:14:08 <tromp__> the 1pt eye owner can play in opponent area
12:14:10 <roconnor> tromp__: no shape is in advantage.
12:14:22 <roconnor> tromp__: oh right.
12:14:30 <tromp__> the 2pt owner has to play in his own
12:14:43 <tromp__> so shape is important
12:14:46 <ColonelJ> wtf are you talking about
12:14:50 <tromp__> in hard to fathom ways
12:14:55 <roconnor> tromp__: interesting
12:15:00 <ColonelJ> ah go
12:15:14 <roconnor> tromp__: thanks for pointing this out to me.
12:15:24 <tromp__> so, xerox, how many 2x2 games are possiible?
12:15:35 <tromp__> seems you read the paper:)
12:15:48 <napping> what's to stop them playing in the opponent's eye?
12:15:59 <tromp__> playing in 1pt eye is suicide
12:16:03 <xerox> I remember reading it, I don't remember the count!
12:16:05 <tromp__> forbidden by superko
12:16:08 <ColonelJ> I don't understand the example
12:16:12 <roconnor> tromp__: so I guess a 2pt eye isn't worth two points.  It is in fact worth 1 pt.
12:16:23 <ColonelJ> if you have two eyes you live
12:16:26 <roconnor> tromp__: according to mathematical go
12:16:50 <roconnor> hmm
12:17:36 <roconnor> strange
12:17:44 <roconnor> obviously I don't understand this as well as I thought I did.
12:17:49 * hackagebot upload: SGdemo 1.1 - An example of using the SG and OpenGL libraries (NeilBrown)
12:18:05 <xerox> < 2^2^2
12:18:15 <tromp__> well, its worth (1 | 2) i guess
12:18:20 <ColonelJ> AGA is like chinese scoring isn't it
12:18:40 <roconnor> tromp__: {1 | 2} or {2 | 1} ?
12:18:53 <roconnor> {1 |2
12:19:04 <tromp__> {1|2} for left
12:19:09 <xerox> what is that symbol?
12:19:12 <roconnor> {1 | 2 } = 1.5 right?
12:19:16 * ColonelJ goes afk
12:19:18 <tromp__> yes
12:19:23 <roconnor> ah
12:19:46 <roconnor> so 2 2pt eyes vs 3 1 pt eyes is even then?
12:19:51 <tromp__> shld be
12:20:49 <roconnor> seems to be worth * to me
12:21:14 <tromp__> no, first player loses
12:21:36 <roconnor> first player plays in a 2pt eye
12:21:49 <roconnor> second captures
12:21:55 <roconnor> first in the other 2pt eye
12:21:56 <tromp__> well, the 1pt owner always tries to play in a 2pt eye
12:22:03 <roconnor> second captures
12:22:12 <roconnor> first in one of his three eyes
12:22:23 <roconnor> now it is even
12:22:27 <tromp__> 2nd doesnt capture
12:22:39 <tromp__> second move reduces 2pt eye to 1pt eye
12:22:44 <napping> um, when does the game end?
12:22:47 <tromp__> leaving himself 3 moves
12:22:55 <roconnor> tromp__: I suck a go
12:22:57 <roconnor> :D
12:23:18 <roconnor> napping: whoever cannot move loses.
12:23:21 <tromp__> just need more practice:)
12:23:22 <napping> are you really contemplating rules that force players to keep laying down pieces until one has suicided all their groups?
12:23:37 <roconnor> napping: more or less
12:23:38 <napping> ah, I guess you are, aren't you
12:23:39 <tromp__> until you have ni legal move
12:24:07 <napping> and nothing makes playing in your last eyes illegal
12:24:14 <xerox> and you must be smart about it, or you'll make no eyes
12:24:25 <napping> so that's a bit funny
12:24:26 <roconnor> napping: I think suicide is still illegal.
12:24:44 <roconnor> napping: I should consider both varients
12:25:14 <napping> cabal - how do you install something systemwide on windows?
12:25:24 <napping> do you have to open a terminal as administrator?
12:25:26 <Vulpyne> Does --global not work?
12:25:34 <napping> permission denied
12:25:37 <roconnor> napping: I'd be interested in cases where the result is different.
12:25:44 <Vulpyne> Ahh, you probably need administrator then.
12:25:47 <roconnor> tromp__ is pretty smart and might know.
12:26:11 <tromp__> know what?
12:26:24 <roconnor> does restricting suicide or not make a difference in mathematical go?
12:26:34 <roconnor> probably
12:27:19 <tromp__> i'd expect so
12:27:27 <eivuokko> I think it's needed to make the game end.
12:27:39 <gwern> './TagSoup/Generate/Supercompile.hs'
12:27:39 <gwern> o.0
12:28:01 <tromp__> superko ensures end
12:28:47 <roconnor> though superko makes mathematical analysis harder
12:29:02 <roconnor> probably destroys composability
12:29:57 <napping> I am an administrator, but it's windows 7 so there's probably supposed to be a popup or way of running a root terminal or somehting
12:29:59 <eivuokko> tromp, yes, right.
12:31:00 <tromp__> value of 2pt eye with 1 prisoner in it depends on suicide rule
12:31:00 <eivuokko> napping, cabal&windows&global install?  Doesn't work if >=Vista, afaict.
12:31:18 <roconnor> what's a good reference for bidirection type checking?
12:31:20 <tromp__> without suicide it's worth 2 moves
12:31:22 <napping> well, I've found how to run an "elevated" command prompt, so I'll give it a go
12:31:25 <tromp__> with suicide only 1.5
12:31:39 <eivuokko> napping, Yeah, that might work, I recall I had probs in Vista, even then.
12:31:43 <roconnor> bidirectional
12:31:59 <eivuokko> Migth depend on some policy settings as well.
12:32:09 <napping> looks like success
12:32:36 <roconnor> apparently PT98 is such a reference
12:32:39 <roconnor> whoever P and T is
12:32:55 <napping> cabal-install and a new package seem to be fine
12:33:23 <roconnor> who PT98 is isn't part of this book preview
12:33:36 <napping> Is there any easy way to include a version of a cabalized dependency in the distribution of a cabalized project, so it gets built automatically
12:34:00 <napping> I just remembered a project I need to turn in required some patching of a library, which hasn't been folded in upstream yet
12:44:29 <EvanR-work> forkIO and channels are awesome. are channels not as good as STM?
12:47:01 <napping> EvanR-work: channels work fine if they are what you need. STM gives you composability
12:47:24 <EvanR-work> composabiliy
12:47:27 <EvanR-work> t
12:47:50 <napping> being able to change two things and make sure other threads can't see just one of them
12:48:44 <napping> if channels are good for you, then you probably don't need it. I can't think of any case where you are already happy pushing an event onto an asynchronous channel and couldn't just add other work by doing it before the send
12:56:27 <napping> EvanR-work: what are you making?
12:57:54 <EvanR-work> a mud server. ive been told to use threads to handle blocking i/o on sockets, and that one or two threads blocking on sockets/channels for each connected player is no big deal
12:58:17 <tromp__> what's your favorite mud?
12:58:48 <napping> sounds about right. Btw, a bunch of threads blocking on sockets gets turned into one select loop in the runtime, there was some stuff on planet haskell about a patch recently
12:59:11 <EvanR-work> patch for what, to make that happen?
12:59:28 <EvanR-work> certainly the default is not to make a thousand real threads
12:59:51 <napping> No, they dropped in poll more as a proof of concept, thinking of targeting epoll or kqueue or something eventually
12:59:58 <mauke> EvanR-work: the default is to make no real threads (or one, depending on how you look at it)
13:00:28 <EvanR-work> i would have done a select loop. actually, i did. i wrote the whole thing in c already. but i got stuck at the part that saves the world to a file and restores it ;)
13:00:33 <EvanR-work> which seems to be trivial in haskell
13:01:15 <napping> STM might be useful when you have to handle changes to world state
13:01:52 <EvanR-work> i was going to serialize the player input, but someone suggested i make the whole damn enchillada concurrent
13:01:55 <EvanR-work> which scares me
13:02:55 <napping> how are you managing the state now?
13:04:01 <EvanR-work> i actually havent had a chance to work on it in a while. im thinking of the state is a single value with not much to it except a map for objects
13:04:20 <EvanR-work> server settings etc could be stored in there
13:10:29 <napping> STM is probably an easy way of writing the state management
13:13:18 <EvanR-work> i was thinking the harder part of 'state management' was gonna literally be how to update it
13:14:07 <EvanR-work> object has methods for updating properties, moving objects.
13:14:55 <EvanR-work> i havent really done anything with state yet in haskell
13:15:01 <napping> well, to get concurrency you'd probably have to use mutable bits of the state
13:15:43 <rolando> is the book "Haskell - The Craft of Functional Programming" any good?
13:15:54 <napping> STM is worth checking out anyway, and the version in Haskell has the nicest semantics of any language I've seen
13:16:11 <EvanR-work> i would rather limit the concurrent stuff to IO
13:16:35 <napping> though clojure is a decent second place, I think their ordinary set! is hooked to complain if used in a transaction
13:17:51 <napping> the monad STM is much like IO, except you can only use mutable variables, send on channels, and do a handful of other things. In return, you can run them in different threads and it acts like they ran one at a atime
13:18:34 <napping> basically the effect you'd get if you shipped callbacks off to a central thread for running state changing stuff  that ran them in some order, except you don't need to write all that gunk and you get some parallelism
13:19:09 <EvanR-work> uh huh :S
13:22:40 <Absolute0> I am getting an indent error: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14408#a14408
13:23:08 <kmc_> indent the case arms further than "case"
13:23:08 <Absolute0> mixing nested case inside a let
13:23:25 <kmc_> i'd put the kw on the next line, indented relative to pawnIncrements
13:23:36 <kmc_> or of course you can always use explicit { } ;
13:24:21 <napping> I'd recommend reading the definition of the layout translation enough times
13:24:26 <Absolute0> kw?
13:24:35 <napping> keyword
13:24:36 <mauke> not further than 'case', further than 'pawnIncrements'
13:24:37 <kmc_> the keyword "case"
13:24:48 <Absolute0> oh
13:24:54 <kmc_> or turn pawnIncrements into a function rather than pattern bind, and color into an argument rather than free variable, for the purpose of writing multiple equations
13:24:58 <mauke> a single space is all you need
13:25:12 <kmc_> pawnInc White 2 = [(0, 1), (0, 2)];
13:25:19 <kmc_> pawnInc White n = [(0,1)]
13:25:19 <kmc_> etc
13:26:46 <napping> basically a { gets added at the start of the next token after keywords like let and of, and the parser remembers that column. Then later lines starting on that exact column get a ;, and the block is close with a } whenver you see a line indented less
13:27:38 <napping> so let remembers the column of pawnIncrements, and the "White" at the same column gets a ; because it's at the same line, but that breaks because it's not actually the start of the next equation in the let
13:28:25 <v_> Heh, #haskell had a peak of 689 users. #c++ had 666. W00t.
13:29:13 <shambler> well it's like comparing #windows and #linux channels
13:30:10 <gwern> ah, some righteous Gitit hacking
13:30:20 <gwern> now the RSS code doesn't make me want to barf
13:30:25 <gwern> (although it's still pretty bad)
13:30:29 <mtnviewmark> does that just mean that Haskellers need more help? :-)
13:30:34 <napping> hmm, anyone know how to build iconv on windows?
13:30:44 <shambler> mtnviewmark, may be
13:30:49 <mtnviewmark> heh!
13:30:57 <gwern> napping: like any unix lib - with a pole and tempered blastshield between you and it
13:31:28 <Rotaerk_> type aliases in F# are a little annoying
13:31:32 <napping> The C part is installed, I need to point cabal at it somehow
13:31:57 <Rotaerk_> if T has constraints on its type parameters, and you want to make an alias for T, say U, you have to put the same constraints on U's type parameters
13:34:58 <luqui> After a weekend with F#, I never want to see it again.  I think C# is a better functional programming language...
13:35:07 <notweebl> lol
13:35:09 <EvanR-work> ._.
13:35:21 <copumpkin> luqui: what didn't you like about it? do you dislike ocaml too?
13:35:57 <napping> I think the time is about right for a new functional language
13:36:01 <luqui> copumpkin, haven't used ocaml.  it was just all the little things done wrong.  seems like F# had a huge feature list and no consideration for how the features interacted with each other.
13:36:09 <copumpkin> ah
13:36:12 <Mitar> what is the function which turns two arguments of another function around?
13:36:19 <thoughtpolice> :t flip
13:36:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:36:21 <luqui> every time i tried to do something powerful it seemed there was a special case in the compiler to prevent me from doing so
13:36:23 <Mitar> thanks
13:36:37 <luqui> "can't define functions in pointfree style.  name arguments explicitly"
13:36:52 <luqui> so you... *know* that i am trying to define a function in pointfree style, but won't let me?
13:37:53 <napping> wow, iconv seemed to install
13:38:17 <luqui> wow, that def of flip is interesting.
13:38:24 <napping> guess it just needed that --extra-include-dirs (which I vaguely remember not being compatible with cabal install last time I tried)
13:39:10 <copumpkin> luqui: it's great for beginners when we try to show them how to flip a function! ;)
13:39:24 <gwern> so what's the opinion of 4 or 5 lines commented out with -- instead of {--}?
13:39:28 <gwern> is it bad style?
13:39:30 <luqui> copumpkin, haha
13:39:46 <luqui> napping, I agree!
13:39:56 <luqui> (re: new functional programming language)
13:40:04 <DigitalKiwi> gwern: are they lines you may uncomment individually or alwas grouped?
13:40:09 <luqui> something that blows us out of the water.  that shows haskell everything it did wrong :-)
13:40:09 <napping> qwern: Haddock is okay with it. Wouldn't want to do it by hand, though
13:40:12 <gwern> DigitalKiwi: grouped, I should say
13:40:20 <kmc_> F# has the problem of trying to unify two very different type systems
13:40:20 <gwern> napping: I mean just stylistically
13:40:31 <kmc_> it's not just "OO + functional".  it's that the OO system has to be specifically .NET's
13:40:34 <gwern> let's say they're 5 lines of haddock docs
13:40:35 <luqui> kmc_, yes, that seems to be the root of most of it
13:40:41 <gwern> --, or {-?
13:40:48 <kmc_> you can have OO and functional together quite nicely, if you're willing to design it from the ground up
13:40:51 <napping> well, I figure Haddock would try to encourage good style for documenting code
13:41:02 <napping> I think it looks a bit nicer, but is more of a pain to edit
13:41:19 <gwern> what is 'it'? :)
13:41:21 <luqui> kmc_, honestly, i would have preferred F# to keep its eye on its own HM type system, and provide an interop layer to .NET
13:41:27 <luqui> rather than having .NET invade the whole language
13:41:28 <napping> using more --
13:42:18 <kmc_> and the .NET libraries are all very imperative
13:42:58 <kmc_> luqui, yeah, i think interop is much less problematic than tight coupling of languages
13:43:28 <kmc_> witness all the trouble in C++ caused by including C as an almost-subset, where most other OO languages just provide a self-contained C FFI
13:43:42 <luqui> honestly i would have preferred an implementation of Haskell on .NET :-P
13:44:38 <Heffalump> luqui: F# isn't that bad
13:44:47 <Heffalump> and certainly C# is way worse as a FP language
13:44:55 <napping> kmc_: I'm interested in seeing how well this Go works out, because subtyping+bounded polymorphism is bad news for System F, but I suspect you could make an acceptable object system from interfaces and extensible records
13:45:31 <luqui> Heffalump, it's more of a catch phrase.  I consider them about equal acutally, C# a bit more verbose.  But C#, in my opinion, is a smaller, simpler, more predictable language
13:45:59 <napping> Especially because the OO guys seems to favoring composition over inheritance and stuff lately
13:46:01 <Heffalump> C# doesn't have type inference
13:46:11 <luqui> Heffalump, which C# are you using?
13:46:30 <Heffalump> well, not in as many places as F#
13:46:43 <Heffalump> though I haven't used it that much and not for a while, so maybe I'm wrong..
13:46:53 <luqui> yeah... but every time i was going to take advantage of F#'s type inference, it whined at me to add a type signature because it couldn't figure it out
13:46:55 <kmc_> napping, but Go simply lacks polymorphism
13:47:04 <Heffalump> just don't program point-free, and it'll figure it out
13:47:15 <BrianB04> Afternoon all.
13:47:19 <kmc_> you're talking about what sort of polymorphism it might get down the line?
13:47:22 <luqui> Heffalump, and don't use method calls.
13:47:50 <Heffalump> you know the type inference is left-to-right as far as method calls are concerned?
13:48:12 <Heffalump> i.e. you typically need to use thing |> ... (something determined by thing).Foo ...
13:48:14 <luqui> Heffalump, yes.
13:48:19 <luqui> it's just as frustrating as Coq for that reason
13:48:34 <napping> kmc_: accepting any instance of an interface is a sort of polymorphism you can handle just fine in a H-M style type system, and the designers seem to claim it's an acceptable substitute for the "any subclasses of T" you get in usual OO languages
13:49:00 <Heffalump> napping: no it's not!
13:49:00 <luqui> Heffalump, i mean, i don't have a solid argument.  basically it comes down to:  F# is thoroughly frustrating to use, C# is not...
13:49:17 <Heffalump> napping: it interacts really badly with the value restriction, for one thing
13:49:19 <luqui> i don't want to have to think about the operational semantics of a typechecker while i am coding
13:49:24 <luqui> unless i am coding a typechecker
13:49:28 <luqui> and even then i avoid it :-)
13:50:02 <kmc_> napping, indeed, it's pretty close to subclass polymorphism.  but that's not very close to System F style polymorphism
13:50:05 <kmc_> i.e. parametric
13:50:23 <napping> ah, but haskell does fine with forall a . (Interface a) =>
13:50:26 <Heffalump> napping: we've run into situations where you write something with a specific type, then try to declare something else that partially applies that first function, and you hit the value restriction.
13:50:40 <napping> you mean the monomorphism restriction?
13:50:45 <napping> or are you talking about ML?
13:50:47 <Heffalump> no, I mean the value restriction, in F#.
13:51:01 <Heffalump> which does precisely what you're saying with accepting any instance of an interface
13:51:24 <kmc_> napping, indeed.  but Haskell does not have subtypes
13:51:32 <napping> Isn't that just F# being bad?
13:51:33 <Heffalump> it would be ok in Haskell with no monomorphism restriction
13:51:51 <kmc_> and as you said, once you try to mix together all of subtypes and parametric bounded polymorphism, it's big trouble
13:51:53 <Heffalump> napping: well, not really, it's a natural consequence of doing that in a language with the value restriction
13:52:00 <kmc_> although i can't offhand describe why
13:52:16 <kmc_> Heffalump, can you summarize what the value restriction is?
13:52:27 <kmc_> ah, found a faq
13:53:03 <napping> Well, subtyping + bounded polymorphism + System F makes for undecidable typechecking, so I'm interesting in seeing how well the Go folks can support IO styles without subtype bounded polymorphism
13:53:10 <napping> OO style, rather
13:53:40 <kmc_> more an issue of generic style than OO style
13:53:45 <kmc_> they have typecase though
13:53:57 <kmc_> basically the answer is that there will be a lot of runtime ad-hoc polymorphism
13:54:26 <kmc_> and the language will seem more and more dynamically typed as you get into complicated polymorphic whatsits
13:54:27 <napping> they don't have algebraic data either - and we get typecase with Dynamic, which works almost the same way
13:54:49 <kmc_> sure, but if you used Dynamic for some vanilla polymorphic thing like map or fold, people would shoot you
13:54:56 <knobo> if I have data MyType = MyType {a::Int, b::Int, ....}, and I want a function MyType -> Int -> "accessor, a or b or.." -> MytType, that returns a MyType with identical content, except for the value the accessor is asosiated with.
13:54:58 <kmc_> that's the *only* way to do it in go
13:55:14 <kmc_> knobo, those are a pain in Haskell 98
13:55:20 <kmc_> you have to write some crap like
13:55:27 <kmc_> \v r -> r { a = v }
13:55:31 <kmc_> using record update syntax
13:55:39 <kmc_> knobo, look at the hackage packages: data-accessor, fclabels, lenses
13:55:57 <kmc_> these provide true first-class record labels
13:56:39 <knobo> kmc_: url?
13:57:02 <kmc_> @where hackage
13:57:02 <lambdabot> http://hackage.haskell.org/package/
13:57:24 <knobo> thanx
13:57:30 <napping> more build problems - I've got the most recent Haskell Platform, but cabal-install is trying to build a newer template-haskell for some reason, which fails saying Data.Data is in hidden package base - but from ghci I can import it fine
13:57:36 <Mitar> is it possible to have different parts of code for different versions of GHC? like in C where you can use preprocessor directives? because I have one line of code which does not compile on 6.12 and if I correct it, it does not compile on 6.10
13:59:55 <Berengal> Mitar: Not sure if there are any builtin definitions in the CPP you can check, but if you use cabal it's pretty easy to set conditional flags based on compiler and compiler-version
14:00:16 <Mitar> I am using Makefiles :-)
14:01:22 <mtnviewmark> Mitar - text 0.7 does just that sort of 6.10 vs. 6.12 conditional thing
14:01:23 <mtnviewmark> see http://hackage.haskell.org/packages/archive/text/0.7/doc/html/src/Data-Text-IO.html
14:01:31 <Berengal> I'm not very used to them, but setting flags shouldn't be hard. How to test for version, I don't know
14:02:18 <Mitar> aha, so CPP is the parameter
14:06:28 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor  has full information on which symbol has the version number.
14:06:48 * v_ scrolls 
14:06:59 <v_> Hmm, f#. How's that language, anyway?
14:07:20 <Berengal> Functional
14:07:22 <Berengal> Last I heard
14:07:23 <v_> A bad Haskell clone for .NET?
14:07:28 <napping> this build is not going so well. Darn, I though getting libiconv was going to be the hard part
14:07:29 <v_> Yeah, Functional# do ho hoo.
14:07:41 <Berengal> I've heard that too
14:07:45 <idnar> more like an Ocaml clone
14:07:52 <v_> Yeah, it's more in the ML family
14:07:56 <v_> Just like Scala
14:08:00 <Berengal> @quote F#
14:08:01 <lambdabot> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
14:08:02 <monochrom> I think you mean "Hmm, haskell. How's that language, anyway?"
14:08:03 <v_> But Scala is a strange beast
14:08:16 <Berengal> @quote F#
14:08:17 <lambdabot> Raynes says: F# isn't a cousin [of Haskell], it's the retarded son in law.
14:08:21 <v_> Hahaha
14:08:34 <nlogax> v_: F# looks the most interesting of the .net stuff to me. fwiw :)
14:08:34 <burp> lol
14:08:42 <Mitar> monochrom: thanks, it works!
14:08:46 <nlogax> i'd have to use mono to use ".net"...
14:08:47 <v_> Yep. Brings some functional goodness to .NET
14:08:51 <Berengal> nlogax: Me too. I still haven't looked at it
14:08:58 <v_> Same goes for C#
14:09:03 <idnar> mono doesn't have an F# compiler, anyway
14:09:05 <idnar> (does it?)
14:09:10 * v_ shrugs 
14:09:17 <idnar> I suppose maybe you could get the MS compiler to run on Mono's runtime
14:09:19 <nlogax> not sure, really. just assumed it had it :)
14:09:23 <Berengal> idnar: Does it need one?
14:09:25 <v_> Mono doesn't have the Linq magic and the F# stuff
14:09:36 <v_> Whatever
14:09:43 <nlogax> every time i look at any .net stuff i come to that conclusion.
14:09:51 <EvanR-work> if you compile it on MS, seems like it should run on mono... or not
14:09:55 <idnar> what...EVERRRRR
14:10:01 <nlogax> and go "but there's haskell, lovely haskell, i don't need F#"
14:10:02 <idnar> :)
14:10:27 <EvanR-work> are ML, ocaml, f# etc etc purely functional?
14:10:43 <v_> Meh. Not really
14:11:00 <Berengal> There's something about a language that doesn't rely on vms. I mean, they're fun and all, but people always fall for the temptation to put too much stuff in them
14:11:07 <v_> nlogax: .NET has a bigger ecosystem.
14:11:09 <EvanR-work> scala
14:11:27 <v_> I've been wanting to check those 4 Scala books I have in my collection
14:11:29 <nlogax> v_: yes. i'm sure it's really nice if you're 100% MS and stuff.
14:11:30 <v_> Oh well.
14:11:41 <v_> nlogax: bingo
14:11:44 <nlogax> but if you're not, it's just.. uncomfortable.
14:11:51 <v_> Or Scala if you are a Java (platform) fan
14:11:54 <nlogax> yeah.
14:12:07 <Berengal> I tried getting into scala... couldn't make it.
14:12:20 <Berengal> IMO, it lacks good online tutorials.
14:12:24 <v_> Berengal: and how long have you been coding in Haskell?
14:12:34 <Berengal> v_: A little more than a year
14:12:42 <v_> Berengal: I have 4 pdf's and one pdf about Lift, the Scala framework
14:12:45 <v_> If you want docs..
14:13:03 <Berengal> v_: I probably have them too... But you're free to link
14:13:03 <kmc_> C# is slowly pilfering good features from Haskell
14:13:04 <v_> So many Scala books in so little time. Heh
14:13:20 <Berengal> v_: If there's anything like LYAH for scala, I'd be very happy
14:13:21 <nlogax> kmc_: but that's a good thing, right? :)
14:13:22 <v_> kmc_ : it's a free world :-P
14:13:24 <kmc_> sort of
14:13:38 <v_> Berengal: ok. Links incoming. In private.
14:13:43 <Berengal> kmc_: The more features of haskell it gets, the more likely people are to jump ship
14:13:44 <EvanR-work> wrong! patent the remaining good features immediately!
14:13:46 <nlogax> i don't use C#, but if it gets sweet stuff from haskell, that's awesome.
14:13:51 <knobo> How to transform  [a] to Maybe [a], so that it is nothing if the list is empty?
14:13:54 <kmc_> it's just ironic to see people run screaming from monads, and then gush about how great F# "workflows" or C# LINQ are
14:14:03 <kmc_> branding is everything :/
14:14:04 <v_> Yeah, it's all about marketing
14:14:08 <kmc_> :t listToMaybe
14:14:09 <lambdabot> forall a. [a] -> Maybe a
14:14:12 <kmc_> knobo, ^^^
14:14:12 <nlogax> hehe, yeah. but that's just meaningless popularity contest..
14:14:15 <kmc_> but not
14:14:17 <Berengal> knobo: listToMaybe, but that drops the tail of the list. Otherwise, why would you want that?
14:14:24 <v_> The "Monad" word scares people.
14:14:29 <mauke> \xs -> if null xs then Nothing else Just xs
14:14:32 <kmc_> :t \xs -> case xs of [] -> Nothing; _ -> Just xs
14:14:33 <lambdabot> forall t. [t] -> Maybe [t]
14:14:34 <v_> And stuff like "monadic parser combinator".
14:14:35 <v_> Heh
14:14:46 <monochrom> I propose \xs -> Nothing
14:14:49 <EvanR-work> should have called it something else
14:14:57 <kmc_> @djinn List a -> [a]
14:14:57 <lambdabot> Error: Undefined type List
14:15:00 <Berengal> v_: "monadic parser combinator" is my favorite haskell term :)
14:15:04 <nlogax> :)
14:15:05 <kmc_> @djinn a -> Maybe a
14:15:06 <lambdabot> f = Just
14:15:07 <kmc_> :)
14:15:10 <v_> Yes. It's awesome
14:15:31 <v_> Parsec is one hell of a library
14:15:42 <v_> Cool name too
14:15:54 <Berengal> It's also pretty easy to write one yourself, if you know the basics
14:16:05 <nlogax> i'm a super-noob, but i find that monads and other things in haskell are much simpler than people make it sounds.
14:16:19 <v_> I've been reading Grammars and Parsing in Haskell
14:16:21 <v_> Good doc
14:16:26 <nlogax> because people don't go "but what are arrays, *really*???" about JS or whatever.
14:16:39 <kmc_> i agree with some other people here, that the confusion over monads stems from 1) thinking they're more important than they are and learning too early, and 2) confusion over higher-order programming in general
14:16:41 <nlogax> i can use monads, i can use JS arrays..
14:16:48 <knobo> kmc_: That's what I want yes.
14:16:51 <v_> oh, yeah. That reminds me of "JQuery is a monad" haha.
14:16:55 <v_> Good article
14:16:55 <nlogax> hhahaha
14:17:01 <nlogax> yyah.. not quite...
14:17:03 <Berengal> nlogax: The simplicity of monads is what makes them hard. There's so little to them it's hard for people to relate them to anything else.
14:17:13 <nlogax> Berengal: exactly.
14:17:14 * EvanR-work stares at his jquery docs... 
14:17:26 <v_> EvanR-work: it gave me a serious WTF
14:17:38 <EvanR-work> i do it for a living now...
14:17:38 <Berengal> nlogax: And when people try, they conclude "lists are monads" or whatever, then people go "well, lists _are_ a monad, but a monad is not a list..."
14:17:52 <EvanR-work> glad to know its a monad all of a sudden lol
14:18:03 <nlogax> Berengal: that's what i was trying to say.. how do you explain a string or an array or a "Number" in JS? you don't, because no one really cares... anyone can use them. :p
14:18:11 <v_> So, this http://www.windley.com/archives/2009/01/jquery_monads_and_functional_programming.shtml
14:18:14 <DigitalKiwi> square is a rectangle, etc
14:18:22 <v_> And this http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/
14:18:57 <v_> The moral: You probably have used monads but just haven’t realized it.
14:19:12 <luqui> that's why you introduce functors first.  gives you something to relate it to.
14:19:35 <luqui> but it is not sufficient to simply use monads
14:19:39 <osaunders> getStdRandom seems like a terrible name for what is withNewStdGen
14:19:43 <knobo> I just thought there was a (m a) -> (mp m a) function.
14:20:12 <knobo> But it would not transform [] in to nothing...
14:20:41 <luqui> to become a proficient haskell programmer, you must learn to recognize new monads (and functors/applicatives/etc.), notice not-quite-monads (support operations but don't obey the laws), know what ways a monad that breaks the laws will affect you, ...
14:21:00 <nlogax> when you read about haskell, it sounds really complicated, a lot of fancy words that you haven't heard before (as a simple web devloper such as myself), but when you use it, it's another story.
14:21:10 <nlogax> +e
14:21:14 <knobo> ghci is slooooooooooooow
14:22:03 <nlogax> if i would try to explain the intricacies of javascript, i'd be in for the long haul...
14:22:11 <monochrom> @remember nlogax because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
14:22:12 <lambdabot> Nice!
14:22:18 <knobo> after compiling my functions takes 0.015 sec, interpreted it takes a minute or two, maybe three now that I start using this Maybe monad.
14:22:34 <nlogax> haha, oh no, i got quoted
14:22:48 <mreh> :t foldM
14:22:49 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:22:54 <napping> I'm seeing missing a missing symbol _iconv_open. Finally got everything to build, but it won't link
14:23:11 <EvanR-work> v_: thats pretty sweet v_
14:23:11 <monochrom> "what is ____ ?" should never be answered. Useless philosophical question.
14:23:17 <napping> oh, and I had to explicitly request syb-with-clas-0.6 instead of syb-with-class-0.6.1
14:23:26 <EvanR-work> v_: my mind is now blown ;)
14:23:30 <v_> EvanR-work: yeah, very interesting articles :-D
14:23:37 <nlogax> monochrom: i hope that was for usefulnes, and not mocking :D
14:23:38 <v_> EvanR-work: you're a jQuery fan?
14:23:58 <monochrom> I am not mocking.
14:24:04 <EvanR-work> no. im a web monkey we happen to be using it. i decided to do as little in php as possible and make the app mostly client side. then we switched to jquery.
14:24:05 <nlogax> cool.
14:24:13 <mreh> how does foldM work? using (>=>)?
14:24:17 <mreh> oh i forgot
14:24:20 <mreh> @src foldM
14:24:20 <lambdabot> foldM _ a []     = return a
14:24:20 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:24:36 <nlogax> EvanR-work: "as little in php as possible" sounds extremely healthy to me
14:24:43 <EvanR-work> v_: i now realize how deeply im falling into the functional abyss ;)
14:24:48 <EvanR-work> haha
14:24:48 <monochrom> My http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml begins with "What are Arrows? I won't answer. Distracting."
14:24:49 <v_> jQuery and Prototype bring the fun in functors
14:24:51 <v_> :-D
14:24:57 <tensorpudding> php is kinda like trans-fat
14:25:02 <luqui> monochrom, strongly disagree...
14:25:04 <nlogax> just quit my job since 15 moths to get away from php. it's really, really terrible..
14:25:12 <v_> PHP is kinda meh. To say the least
14:25:19 <mreh> can we take all this php to haskell-blah?
14:25:26 <v_> EvanR-work: and this is a very cool presentation http://www.slideshare.net/ujihisa/from-javascript-to-haskell
14:25:26 <luqui> monochrom, you just have to be willing to accept an abstract, mathematical answer.  if not, *then* it is philosophy
14:25:28 <mreh> please
14:25:32 <nlogax> haskell-blah? i'm there!
14:25:54 <monochrom> Starting using it and exploring its properties already. That is all you ever need to know. Ever. Yes, even "what is ___" is ultimately defined by properties and examples, not by essays.
14:26:02 <knobo> is there a way to do  ((a,b) -> f -> (f a b))?
14:26:17 <luqui> kniu, uncurry?
14:26:19 <luqui> :t uncurry
14:26:20 <mreh> uncurry
14:26:20 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:26:35 <EvanR-work> v_: does that have sound? i dont
14:26:56 <v_> No sound. Just some slides
14:26:57 <luqui> knobo, or just write what you said :-):     (\(a,b) -> \f -> f a b)
14:27:05 <luqui> which is:
14:27:07 <luqui> :t flip uncurry
14:27:08 <lambdabot> forall a b b1. (a, b) -> (a -> b -> b1) -> b1
14:27:12 <v_> It's a good comparaison of Haskell and Js.
14:27:19 <knobo> how about (a,b,c) then?
14:27:36 <mreh> @pl (\(a,b,c) -> \f -> f a b c)
14:27:36 <lambdabot> (line 1, column 7):
14:27:36 <lambdabot> unexpected ","
14:27:36 <lambdabot> expecting letter or digit, operator or ")"
14:27:36 <lambdabot> ambiguous use of a non associative operator
14:27:41 <luqui> knobo, no, not in general.  haskell really only has decent support for 2-products
14:27:48 <mreh> @pl (\(a,b,c) f = f a b c)
14:27:48 <lambdabot> (line 1, column 7):
14:27:48 <lambdabot> unexpected ","
14:27:48 <lambdabot> expecting letter or digit, operator or ")"
14:27:48 <lambdabot> ambiguous use of a non associative operator
14:28:06 <luqui> mreh, not sure @pl supports tuple pattern matching
14:28:11 <mreh> it seems not
14:28:19 <luqui> @pl (\f tup = let (a,b,c) = tup in f a b c)
14:28:20 <lambdabot> (line 1, column 9):
14:28:20 <lambdabot> unexpected "="
14:28:20 <lambdabot> expecting pattern or "->"
14:28:31 <knobo> you need -> not =
14:28:33 <luqui> well, i don't know what it would generate anyway
14:28:40 <luqui> @pl (\f tup -> let (a,b,c) = tup in f a b c)
14:28:40 <lambdabot> (line 1, column 16):
14:28:40 <lambdabot> unexpected "("
14:28:40 <lambdabot> expecting "()", natural, identifier or "in"
14:28:41 <napping> monochrom: that's a rather loose scheme you reject there
14:28:46 <luqui> there is no function (a,b,c) -> a
14:28:50 <luqui> in the libraries
14:29:06 <knobo> ok.
14:29:29 <tensorpudding> @help
14:29:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:29:38 <mreh> :info
14:29:39 <tensorpudding> @list
14:29:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:30:05 <mreh> @hoogle foldM
14:30:05 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:30:05 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
14:30:05 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:30:07 <tensorpudding> @help djinn
14:30:07 <lambdabot> djinn <type>.
14:30:07 <lambdabot> Generates Haskell code from a type.
14:30:07 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
14:30:30 <tensorpudding> @djinn forall a b c. (a,b,c) -> a
14:30:30 <lambdabot> f (a, _, _) = a
14:31:20 <napping> does anyone know how ghci on windows wants to load packages?
14:32:01 <kniu> uncurry?
14:32:35 <mreh> i think someone wrote your name by accident
14:32:44 <luqui> > (uncurry (+)) (1,2)
14:32:44 <lambdabot>   3
14:32:47 <mreh> they meant to say knobo
14:32:51 <luqui> oh
14:33:05 <luqui> yeah sry :-)
14:33:25 <luqui> my nick hash function is of the form  f . head
14:34:27 <monochrom> my irc software tries to give priority to recently-speaking nicks.
14:34:41 <mreh> monochrom: amazing
14:34:52 <mreh> hey look at all these people joining!
14:34:57 <v_> Haha
14:35:01 <v_> Indeed
14:35:11 <mreh> I THINK THERE WAS A NET SPLIT
14:35:17 <v_> people joining and netplit right after
14:35:48 <lispy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14413#a14413  <-- compile error with show-0.3.3 on GHC 6.12.1.
14:35:57 <lispy> Does anyone know if this has been fixed somewhere?
14:35:59 <napping> monochrom: what is the list syntax for --extra-lib-dirs? Or is that useless philosophy ;)
14:36:31 <monochrom> What is "list syntax"?
14:37:02 <napping> The --help says it takes a list of directories
14:37:20 <largos> dcoutts: are you around?
14:37:25 <dcoutts_> @arr!
14:37:26 <lambdabot> Swab the deck!
14:37:32 <monochrom> I bet /usr:/local:/home/monochrom:/tmp
14:37:47 <largos> dcoutts_:  lispy suggested I ask you about some cabal install confusion
14:38:05 <dcoutts_> largos: ok, ask, I'll fetch tea...
14:38:16 <monochrom> yeah, colon-separated for most of those path options
14:38:20 <lispy> dcoutts: thanks
14:38:34 <mreh> :t unzip
14:38:35 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:38:47 <napping> well, I've got spaces in my paths
14:38:53 <knobo> does ghc have first class accessors for data types?
14:39:04 <knobo> looks like it works in my program
14:39:12 <largos> dcoutts_: I'm trying to figure out why pastepipe (a simple app)  shows an installed version in 'cabal list pastepipe' but other applications (such as cabal-install) say [ Not installed ], despite having *just* run 'cabal install cabal-install' (for example)
14:39:15 <lispy> knobo: Yeah, that's how records work anyway.
14:39:28 <monochrom> I think spaces are no problem.  ghc --blah "/usr:/home/this is a dir:/dev"
14:39:31 <napping> I'm trying to get it to build on windows. ; and : didn't work as a separator.
14:39:35 <pikhq> knobo: Yeah, accessors for records are just functions that are implicitly defined.
14:39:42 <lispy> knobo: if it wasn't declared with the record syntax then you have make your own :)
14:39:47 <monochrom> spaces are only problems for the shell.
14:39:54 <largos> dcoutts_: the pastepipe version is also tracked incorrectly -- the actual installed version (and the latest) is 1.3, yet the installed version is listed as 1.0
14:39:57 <napping> It complained "C:\path1:C:\path2" doesn't exist or isn't a directory
14:39:58 <EvanR-work> but we dont have first class updaters
14:40:10 <kmc_> knobo, first class accessors (with update) are provided by those packages i mentioned
14:40:18 <kmc_> the vanilla H98 record labels are much less useful
14:40:23 <knobo> fclabels gives just propper setters then?
14:40:36 <kmc_> it gives a thing that can be used as a getter or setter
14:40:36 <monochrom> Oh windows, then I don't know, colon is kind of overloaded. Try semicolon. Just a guess.
14:40:38 <kmc_> and makes them composable
14:40:39 <mreh> foldM is so elegant, it's like a sort of state monad
14:40:42 <kmc_> i heard data-accessor is the best of the 3
14:40:45 <kmc_> but try them yourself
14:40:50 <dcoutts_> largos: the output in cabal list is misleading. Installed versions of programs are not tracked.
14:40:51 <mreh> state transformer even
14:41:00 <monochrom> But do add ""s if you need spaces.
14:41:03 <dcoutts_> largos: where was the other place the installed version was reported?
14:41:31 <largos> dcoutts_: only one place -- it seems that somehow cabal install got a version for pastepipe, and I have no idea where
14:41:58 <napping> hmm, %PATH% seems to be ; separatred. ; doesn't work, though. repeating the option was accepted, but linking fails.
14:42:07 <largos> dcoutts_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14414#a14414
14:42:11 <dcoutts_> largos: it only shows installed versions for packages containing libs
14:42:18 <dcoutts_> those are the only ones registered
14:42:54 <dcoutts_> largos: do you have a version 1.0 that is actually a lib and is registered with ghc-pkg?
14:42:56 <largos> dcoutts_: being that I wrote pastepipe, I'm pretty sure there was never a library version...
14:42:58 <lispy> dcoutts_: oh, so the implementation details that cause this problem are directly related to the output of ghc-pkg?
14:43:23 <mreh> why even use StateT if you have foldM?
14:43:27 <largos> hm...  I don't know how to check ghc-pkg
14:43:34 <lispy> ghc-pkg list
14:43:36 <dcoutts_> largos: ghc-pkg list blah
14:43:51 <dcoutts_> lispy: no, it's just that cabal list should not attempt to show a version for packages that contain no libs
14:43:53 <monochrom> Perhaps omit all those "C:"s
14:44:00 <largos> ah!
14:44:12 <dcoutts_> lispy: it says [ Not installed ] but it should just say not known or something
14:44:22 <largos> yup, there is one in there.  weird...
14:44:31 <dcoutts_> largos: ok, explains everything then :-)
14:44:34 <largos> I must have had a lib. cabal file at some point
14:44:35 <lispy> dcoutts_: It would be really nice as a user if cabal-install tracked everything it installs :)
14:44:46 * largos agrees with lispy
14:45:07 <dcoutts_> lispy: sure, wouldn't it. Being able to track installed files and uninstall has been on the TODO list for a long time
14:45:12 <copumpkin> holy crap, lots of commits :)
14:45:23 <copumpkin> (to ghc)
14:45:24 <largos> ah, cool
14:45:27 <lispy> dcoutts_: okay.  I think I was confused by your earlier comment
14:45:34 <geh_meh_geh> hi
14:45:40 <dcoutts_> lispy: lack of developer time and other higher prorities get in the way sadly
14:46:00 <lispy> dcoutts_: It sounded like it was something that wasn't going to be added
14:46:21 <largos> dcoutts_: *nods* I'm glad to hear it's on the list though.
14:46:39 <dcoutts_> lispy: of course it will not help with progs installed by your distro, those will still not be registered.
14:46:51 * lispy nods
14:49:53 <lispy> I guess I'm the only one trying to build lambdabot on ghc 6.12.1 at the moment?
14:50:04 <lispy> Anyone else had issues building show?
14:52:32 <napping> monochrom: that doesn't seem to make a difference. Maybe there are missing symbols. The package thinks it built fine, but I'm trying to link stuff with it
14:53:44 <monochrom> Regrettedly I don't use Windows for programming.
14:53:58 <napping> It's not so regrettable
14:54:09 <monochrom> heh
14:54:18 <napping> I usually don't either, I'm just trying to get something I built on linux to build on windows
14:57:24 * Cale wonders why Language.C has no Show instances for anything.
14:57:40 <Cale> That is ridiculously irritating.
14:58:11 <copumpkin> it's pretty awkward to use in general
14:58:13 <monochrom> Perhaps the author really hates C code. :)
14:58:17 <copumpkin> from my experience with it
14:58:25 <ddarius> Cale: Standalone deriving, ho?
14:58:25 <largos> where do I find cabal-install >= 0.8?
14:58:27 <Berengal> Cale: Standalone deriving is your friend
14:58:49 <sjanssen_> Cale: standalone deriving to the rescue?
14:58:57 <sjanssen> whoa
14:59:00 <Cale> I suppose that works, but it's still rather annoying, as there are an awful lot of types which are missing Show instances.
14:59:05 <copumpkin> lol
14:59:15 <Berengal> Cale: you'd better hope all types are exported though, because you can't derive new instances for hidden types :(
14:59:33 * Berengal ran into that some time ago, and was seriously infuriated.
14:59:43 <Cale> Maybe I should just dig in and add all the Show instances and upload a new version of the package surreptitiously.
14:59:49 * ddarius doesn't think he's ever been infuriated by code.
15:00:15 <lispy> largos: the hackage page should have a link to the source repo
15:00:21 <Mitar> I am using this construct to prepare everything and run my code: bracket init term (evalStateT run)
15:00:40 <Mitar> but the problem i have is that term is not called in a case of an exception in "init" functioon
15:00:52 <monochrom> I have been infuriated but I am not sure whether it is the code or its authors.
15:00:55 <Mitar> how could i change this code so that it would be run also then?
15:00:55 <Twey> Mitar: Yes… you need ‘catch’
15:01:18 <largos> lispy: I was hoping for a released version...
15:01:27 <Twey> bracket init term (evalStateT run `catch` const term)
15:01:46 <Twey> Would terminate cleanly on any error
15:01:57 <Mitar> ehm, you mean (init `catch const term) ?
15:01:59 <napping> Mitar: are you sure the exception is raised inside the code? You could be returning a lazy value hiding an exception
15:02:01 <lispy> largos: oh, are you looking for cabal 0.8 because of the message you get using cabal with ghc 6.12?
15:02:05 <Berengal> ddarius: What was infuriating was that everything I needed to make something useable was there with very little work required on my part, but I wasn't allowed to do it because of some silly restriction on the visibility of some code.
15:02:11 <napping> e.g. bracket init term (return undefined) >>= print
15:02:20 <largos> lispy: yup
15:02:26 <lispy> largos: If so, I don't know if it's released yet
15:02:31 <ddarius> Berengal: Welcome to the magical land of open source software.
15:02:35 <dcoutts_> largos: I put out a pre-release earlier
15:02:38 <Mitar> i am sure exception is raised inside of init ... it is an IO code
15:02:43 <lispy> I'm using the dev verison, FWIW
15:02:47 <Berengal> ddarius: Basically, when that happens you have two choices: use something else, or dig into the library code itself, becoming familiar with the intimiate details, and add the instances.
15:02:49 <napping> Mitar: brakcet should work
15:02:52 <Mitar> so if it is raised inside of run then it is cleaned ok
15:02:56 <kmc_> @yhjulwwiefzojcbxybbruweejw
15:02:56 <lambdabot> Just 'J'
15:03:02 <Mitar> but if it is raised in init then term is not called
15:03:09 <napping> What's wrong with Language.C? It seems to follow the syntax pretty closely
15:03:10 <ddarius> Berengal: Probably doesn't require "becoming familiar with intimate details" in most cases.
15:03:22 <napping> I always just ran things through the pretty printer
15:03:36 <Berengal> ddarius: So basically, hiding that type didn't do any hiding at all. Indeed, it did the opposite, forcing me to much around in the library code directly, instead of treating it as a black box.
15:03:43 <Berengal> ddarius: That's true...
15:03:49 <largos> dcoutts_: well, I'll have the darcs repo shortly... that should do
15:03:50 <napping> Mitar: also, Bracket re-raises the exception after term, which might be what you see
15:03:52 <Mitar> so i Like the type of bracket ... so that I can return state in init and use it in run
15:04:03 <Mitar> yes, i like that it re-raises the exception
15:04:13 <Berengal> ddarius: But at least I had to become somewhat familiar with the overall organization of the code. Module hierarchy (of internal modules) and such
15:04:18 <Mitar> what i am missing is that it does not run term or raise an exception if there is an exception in init
15:04:21 <napping> but it's just not running the handler? Probably sneaking out in a pure value
15:04:36 <napping> oh, or maybe the wrong bracket? You are using the one from Control.Exception?
15:04:45 <Mitar> ehm, yes?
15:04:45 <Cale> napping: My specific problem is that the Show instances are missing, which makes it impossible to sanely test things at the GHCi prompt.
15:04:48 <Mitar> which one should i use?
15:05:21 <Cale> (and while you can pretty print things, that's not at all the same, because it doesn't show you which constructors you ought to pattern match)
15:05:24 <napping> Cale: I run things through the pretty printer for that. It's not often I'd want to see the full values
15:05:24 <eugenn> > liftM2 (+) (+) (+) 3
15:05:25 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
15:05:25 <lambdabot>    arising from a use of `GHC.Num.+'...
15:05:35 <Mitar> which bracket should i run?
15:05:47 <Cale> It's impossible to get a feel for the structures that it's producing via example.
15:06:20 <eugenn> > liftM2 (+) (+1) (+1) 3
15:06:21 <lambdabot>   8
15:06:25 <monochrom> Mitar: My perspective: if init fails, term should not be run. Example: bracket (openFile ...) (hClose) etc.  Why would you call hClose if openFile fails. There is nothing to close if nothing is opened.
15:06:28 <napping> Mitar: oh, that seems to be the only one. It's catch that has a prelude version that only does IOErrors
15:06:29 <eugenn> yay
15:06:36 <kniu> I saw Real World Haskell at Borders today.
15:06:42 <kmc_> :D
15:06:50 <Mitar> yes, for catch i know
15:06:51 <copumpkin> :t ((*) <=< (+))
15:06:52 <lambdabot> forall b. (Num b) => b -> b -> b
15:07:16 <copumpkin> > ((*) <=< (+)) 5 6
15:07:18 <lambdabot>   66
15:07:18 <Mitar> monochrom: because I also do some other things in init not just openFile :-)
15:07:19 <napping> Cale: I just wanted to generate C, so I was mostly interesting in how things looked - but you can also inspect values in the debugger
15:07:19 <monochrom> Please God not netsplit again.
15:07:36 <napping> Mitar: bracket just protects the inner action
15:07:38 <ddarius> monochrom: Is it really that big of a deal?
15:07:40 <monochrom> Mitar: OK, then I suggest multiple levels of bracket. Try to be atomic.
15:07:40 <eugenn> > ((*) <=< (+)) 4 20
15:07:41 <lambdabot>   480
15:07:49 <Mitar> so i am searching for something like bracket but which would run also term in a case of init failure
15:08:03 <eugenn> > ((*) <=< (+)) 10 20
15:08:04 <lambdabot>   600
15:08:08 <napping> then it sounds like you have the boundary wrong
15:08:20 <copumpkin> > ((*) <=< (+)) x y :: Expr
15:08:21 <lambdabot>   (x + y) * y
15:08:26 <endojelly> what's the canonical way to fetch sources from hackage (for playing around with them)?
15:08:33 <napping> cabal fetch
15:08:36 <eugenn> ooh
15:08:39 <monochrom> wget
15:08:39 <kniu> wait wait what
15:08:40 <ddarius> endojelly: cabal unpack if you have a new cabal-install.
15:08:41 <endojelly> napping, thanks
15:08:44 <napping> and untar them out of the cabal dir - that's what I do
15:08:48 <kniu> > ((*) <=< (+)) x y :: Expr
15:08:49 <lambdabot>   (x + y) * y
15:08:51 <endojelly> ddarius, ah, ok, thanks
15:08:51 <Mitar> or bracket (catch init term) term (...)
15:08:52 <napping> unpack sounds shiny, thanks
15:08:52 <Mitar> ?
15:08:55 <kniu> how the hell does this work?
15:08:57 <kniu> > x
15:08:58 <lambdabot>   x
15:09:03 <napping> Mitar: (stuff >> moreStuff) `finally` term
15:09:06 <ddarius> :t x
15:09:07 <lambdabot> Expr
15:09:10 <kniu> huh.
15:09:14 <Berengal> endojelly: cabal unpack. Doesn't fetch dependencies, and unpacks automatically in the pwd
15:09:18 <copumpkin> > foldr f z [a,b,c,d]
15:09:19 <lambdabot>   f a (f b (f c (f d z)))
15:09:19 <Mitar> hm, no, types do not match
15:09:24 <ddarius> :t var "baz"
15:09:25 <lambdabot> forall a. Sym a
15:09:33 <kniu> oh wow.
15:09:33 <ddarius> > var "baz"
15:09:34 <lambdabot>   baz
15:09:35 <napping> Mitar: or, brachet init (failingInit >> body) term insteas of bracket (init >> failingInit) body term
15:09:38 <Cale> napping: heh, it turns out that produces things which are remarkably impossible to read because the debugger apparently likes to print strings as lists of characters with one character per line
15:09:39 <eugenn> > ((*) <=> (+)) 10 20
15:09:40 <lambdabot>   Not in scope: `<=>'
15:09:57 <napping> Cale: oh yeah, I remember that now
15:10:06 <monochrom> bracket (openFile "first") (hClose) (\f1 -> bracket (openFile "second") (hClose) (\f2 -> real work))))
15:10:07 <eugenn> > ((*) <<= (+)) 10 20
15:10:08 <lambdabot>   Not in scope: `<<='
15:10:15 <napping> Cale: at least it implements sensible pruning rules
15:10:36 <Mitar> i doubt i can split this init so nicely into two parts ... failing parts are quite inerleaved
15:10:58 <ddarius> Mitar: Do what monochrom suggested.
15:11:07 <napping> Mitar: why do you want to run term all the time? Presumably it needs to clean up stuff from the first part
15:11:20 <Mitar> yes
15:11:23 <napping> so like bracket initA (bracket initB body cleanB) cleanA instead
15:11:33 <ddarius> monochrom: At least I listen to you.  There's that.
15:11:39 <monochrom> Haha
15:12:02 <Mitar> i cannot really split init into two
15:12:04 <Mitar> hmm
15:12:12 <eugenn> @pl (\x y -> (x+y)*y)
15:12:12 <lambdabot> join . ((*) .) . (+)
15:12:12 <napping> sure you can
15:12:14 <Mitar> maybe i could do somethine like finally
15:12:20 <napping> how do you think do works?
15:12:31 <Mitar> so put init and body together
15:12:49 <napping> well, that's tricky if cleanup needs values from the body
15:12:55 <monochrom> bracket (openFile "first") (hClose) (\f1 -> do n2<-hGetLine f1; bracket (openFile n2) (hClose) (\f2 -> real work))))
15:12:59 <Mitar> yes :-) i needs state
15:13:02 <monochrom> This example even has a dependency.
15:13:07 <mreh> :t foldM
15:13:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:13:14 <Twey> Mitar: You could wrap the whole thing, if you like.  bracket init term (evalStateT run) `catch` const term
15:13:15 <eugenn> > ( (-) <=< (*) <=< (+)) 10 20
15:13:17 <lambdabot>   580
15:13:26 <mreh> @hoogle (Monad m) => (b -> a -> m a) -> a -> [b] -> m a
15:13:26 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
15:13:26 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
15:13:26 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
15:13:43 <Mitar> but then term will be ran twice in a case of exception in body?
15:14:23 <fata_erro> okay so i'm reading rwh and i come to page 289
15:14:29 <napping> If you are describing your problem accurately, then term can be split in two pieces
15:14:45 <fata_erro> how in gods name does a value get bound to height
15:14:53 <kmc_> fata_erro, link?
15:14:59 <fata_erro> top of page 239 rwh
15:15:11 <Berengal> @where RWH
15:15:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:15:12 <kmc_> do you have a link into the online version?
15:15:12 <fata_erro> i only have the book
15:15:17 <kmc_> what chapter
15:15:29 <napping> Mitar: presumably you don't need the later values from the init process to clean up if something earlier in init raises an exception
15:15:29 <fata_erro> chapter 10
15:15:32 <eugenn> > liftM2 (+) (+) (+1) (+1) 3
15:15:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
15:15:35 <Mitar> no, it is like: acquire some, write some debug messages, acquire some more, write some more debug messages, send some commands over line, which can fail, do some more stuff
15:15:38 <Mitar> ok, now run budy
15:15:38 <mreh> :t foldlM
15:15:39 <lambdabot> Not in scope: `foldlM'
15:15:42 <eugenn> > liftM3 (+) (+) (+1) (+1) 3
15:15:43 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
15:15:53 <fata_erro> Heading Getting Rid of Boileplate code
15:15:58 <eugenn> > liftM2 (+) (+1) (+1) (+1) 3
15:15:59 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
15:15:59 <lambdabot>    arising from a use of `GHC.Num.+'...
15:16:02 <Mitar> and if anything fails, i will like to send messages over the line first, and then close the resources
15:16:06 <eugenn> > liftM3 (+) (+1) (+1) (+1) 3
15:16:07 <lambdabot>   Occurs check: cannot construct the infinite type: a3 = a3 -> r
15:16:42 <kmc_> fata_erro, \(height, s) ->  getNat s         >>? ...
15:16:46 <lispy> Those infinite types are a sneaky bunch
15:16:48 <Berengal> fata_erro: is this the code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14415#a14415
15:17:00 <fata_erro> kmc_: ya
15:17:16 <mreh> > foldl (+) z [a,b,c]
15:17:17 <lambdabot>   z + a + b + c
15:17:19 <fata_erro> Berengal: yes
15:17:47 <fata_erro> how does a var to an anon func get bound
15:17:57 <fata_erro> seems bizare
15:18:08 <kmc_> ?
15:18:09 <monochrom> I don't understand the question.
15:18:12 <fata_erro> sorry in* an anon func
15:18:13 <kmc_> it's just a lambda expression
15:18:16 <kmc_> > (\x -> x+2) 3
15:18:17 <lambdabot>   5
15:18:18 <Mitar> hmm, ok, i will try to refactor the code a little bit
15:18:25 <Berengal> fata_erro: The function is applied inside (>>?)
15:18:28 <Mitar> thanks to everybody
15:18:32 <Cale> fata_erro: By substitution?
15:18:46 <fata_erro> so does it use height in the Just
15:18:46 <mreh> > foldl (:) z [a,b,c]
15:18:47 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:18:50 <fata_erro> how*
15:18:50 <kmc_> fata_erro, it':  \(height, s) ->  (getNat s >>? ... entire rest of expression )
15:18:57 <monochrom> Oh God not another Cale lecture hour again. :)
15:19:05 <Cale> heh
15:19:14 <fata_erro> ow i get it
15:19:17 <lispy> Cale lectures are nice!
15:19:24 <Cale> I don't have enough of a handle on this discussion to know which lecture to give.
15:19:27 <Berengal> fata_erro: A lambda eats as much as possible. Every lambda in that definition extends all the way to the end of the function; they're nested.
15:19:35 <fata_erro>  \(height, s) ->  (getNat s >>? ... Just height etc )????
15:19:39 <mreh> > foldl (flip . :) z [a,b,c]
15:19:39 <lambdabot>   <no location info>: parse error on input `:'
15:19:42 <monochrom> Thank God for unclear questions.
15:19:43 <kmc_> yup
15:19:46 <mreh> > foldl (flip . (:)) z [a,b,c]
15:19:47 <lambdabot>   Occurs check: cannot construct the infinite type: f = (->) [f b]
15:19:51 <Berengal> fata_erro: Which means that the variables bound by the earlier lambdas are visible in the later ones
15:19:51 <kmc_> correct fata_erro
15:19:58 <fata_erro> ok
15:20:00 <mreh> > foldr (:) z [a,b,c]
15:20:01 <lambdabot>   Couldn't match expected type `[a]'
15:20:01 <lambdabot>         against inferred type `SimpleRef...
15:20:15 <mreh> > foldr (:) 0 [1,2,3]
15:20:16 <lambdabot>   No instance for (GHC.Num.Num [a])
15:20:17 <lambdabot>    arising from the literal `0' at <inter...
15:20:21 <fata_erro> i thougt (x -> x+ 2), Just x blah blah
15:20:32 <fata_erro> i was reading it wrong
15:20:35 <fata_erro> thanks
15:20:51 <eugenn> someday i'll understand monads. i promise all of you
15:21:03 <mreh> @quote someday
15:21:04 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:21:09 <monochrom> I still don't understand monads, I promise all of you.
15:21:17 <sergdf> is there a standard tool for formatting Haskell source code files, so people won't laugh at my indentation?
15:21:18 <eugenn> haha
15:21:26 <fata_erro> i stopped reading rwh when i got to that prob
15:21:31 <mreh> sergdf: the space bar
15:21:45 <fata_erro> dropped haskell altogether
15:21:55 <lispy> sergdf: I don't think so.  The layout rules leave enough valid indentations that it's hard to get people to agree anyway :)
15:21:56 <monochrom> No one laughs at your indentation. Don't worry.
15:21:58 <fata_erro> thought it was to damn confusing
15:22:18 <sergdf> heh ok, thanks
15:22:39 <napping> sergdf: the emacs mode does a decent job if you want editor support
15:22:49 <napping> but no, nothing like a standard beautifier
15:22:50 <mreh> :t a
15:22:51 <lambdabot> Expr
15:22:58 <napping> > a + 1
15:22:59 <lambdabot>   a + 1
15:23:09 <mreh> what module is that from?
15:23:12 <mreh> @hoogle Expre
15:23:13 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
15:23:13 <lambdabot> Text.ParserCombinators.Parsec.Expr buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
15:23:14 <mreh> @hoogle Expr
15:23:14 <lambdabot> module Text.Parsec.Expr
15:23:14 <lambdabot> module Text.ParserCombinators.Parsec.Expr
15:23:14 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
15:23:46 <DigitalKiwi> monochrom: lies, the highlight of my days are often reaading poorly indentend code and saying to myself in a superior tone how much better my indentation is than this "nub" and bragging about how much better I could write the program
15:24:25 <napping> Yes, applying nub will surely mess up the formatting in your code
15:26:14 <mreh> haha
15:26:31 <EvanR-work> ok bitches. its 5:30 on friday. does this mean i can go home and write some haskell dammit?
15:26:38 <mreh> >nub "foldr (:) [] [1,2,3]
15:26:41 <mreh> >nub "foldr (:) [] [1,2,3]"
15:26:44 <mreh> > nub "foldr (:) [] [1,2,3]"
15:26:45 <lambdabot>   "foldr (:)[]1,23"
15:26:50 <mreh> urgh
15:27:23 <mreh> EvanR-work, sorry to break it to you, but it's 11:30 on a friday evening
15:27:28 <Berengal> > nub "nub \"nub\""
15:27:29 <lambdabot>   "nub \""
15:27:31 <Cale> Unfortunately, that is not what people mean when they tell you to remove repetition from your code
15:27:42 <mreh> :D
15:27:56 <EvanR-work> hah
15:28:02 <Berengal> > nub $ fix (show "nub" ++)
15:28:02 <EvanR-work> 'dont repeat yourself' ;)
15:28:06 <PepeSilvia> ik ga maar eens slapen
15:28:07 <lambdabot>   mueval: ExitFailure 1
15:28:10 <Berengal> :/
15:28:54 <benmachine> > take 5 . nub . fix $ (show "nub" ++)
15:29:00 <lambdabot>   mueval: ExitFailure 1
15:29:04 <benmachine> > take 3 . nub . fix $ (show "nub" ++)
15:29:05 <lambdabot>   "\"nu"
15:29:14 <Mitar> in bracket ... does "release resource" computation gets initial value returned by "acquire resource" computation or does it gets updated value? for example if this value is a state i am modifying in a bracket body computation?
15:29:25 <benmachine> oh, that sort of makes sense
15:29:59 <benmachine> Mitar: if it's e.g. an IORef then the thing to which it refers could change
15:30:00 <Kim^Walkman> :t bracket
15:30:01 <lambdabot> Not in scope: `bracket'
15:30:20 <Mitar> no, it is just normal haskell record data type
15:30:25 <Kim^Walkman> :t Control.Exception.bracket
15:30:26 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:31:10 <lispy> ?src bracket
15:31:10 <lambdabot> bracket before after thing = block $ do
15:31:10 <lambdabot>     a <- before
15:31:10 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
15:31:10 <lambdabot>     after a
15:31:10 <lambdabot>     return r
15:31:33 <lispy> Mitar: does that answer your question?
15:31:35 <Kim^Walkman> I'd guess it's the original value, assuming it's immutable like most values are, no?
15:31:37 <Mitar> :-)
15:31:44 <Mitar> yes
15:31:51 <benmachine> Kim^Walkman: most?
15:32:04 <dcoutts_> Mitar: you can tell just from looking at the type
15:32:08 <dcoutts_> bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:32:12 <lispy> Mitar: So, @src doesn't always give the implementation used by the compiler, but it's usually similar
15:32:22 <Kim^Walkman> Word chosen because of uncertainty :)
15:32:26 <lispy> dcoutts_: ah, good point
15:32:35 <Kim^Walkman> IORefs, STMVars etc… don't know if they'd be called immutable…
15:32:48 <ddarius> lispy: I believe that's the GHC implementation (or a GHC implementation)
15:32:48 <Mitar> Kim^Walkman: yes
15:32:56 <lispy> To work the way Mitar wants it would need to be bracket :: IO a -> (c -> IO b) -> (a -> IO c) -> IO c
15:32:56 <dcoutts_> Kim^Walkman: they are immutable names for mutable things
15:32:57 <benmachine> :t bracket
15:32:58 <lambdabot> Not in scope: `bracket'
15:32:59 <Mitar> it is just a data record
15:33:06 <benmachine> @type Control.Exception.bracket
15:33:07 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:33:55 <Mitar> lispy: not true, if body fails then it type is not IO c
15:34:07 <ddarius> :t fail
15:34:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:34:36 <Mitar> probably we could not say it is even defined
15:35:20 <dcoutts_> Mitar: you mean lispy's version of your suggestion could not work? I think that's right
15:35:33 <Mitar> yes
15:35:47 * lispy agrees
15:35:59 <Mitar> now that i think it simply cannot be any different
15:36:06 <dcoutts_> right
15:36:21 <lispy> It's amazing how often the type can constrain the implementation
15:36:28 <Mitar> true
15:36:36 <Mitar> but in good way in most cases
15:36:39 <dcoutts_> hurrah for parametricity
15:37:14 <monochrom> syntax and type are two important checks against crazy ideas.
15:37:28 <napping> Isn't that about the only secret we have left?
15:38:30 <monochrom> I don't just mean for programming. I also mean for debates too.
15:38:47 <skorpan> i used newtype for the first time today
15:39:20 <Mitar> monochrom: true, i can very often tell that something somebody is telling is wrong just by "type checking" it :-)
15:39:20 <napping> That's the one thing I don't think anyone who hasn't used functional languages has heard of
15:39:24 <lispy> skorpan: congrats.
15:40:10 <mreh> skorpan: was it to do with undefined?
15:40:22 <mreh> I still have no idea when to use it
15:40:29 <skorpan> lispy: thank you.  i'm not sure i used it appropriately though.  i did newtype Day = Day { day :: Int } and instantiated Bounded for it, so that only Day 1 through Day 31 were possible.
15:40:44 <skorpan> now that i think about it, what i did doesn't really help ... does it?
15:40:58 <benmachine> mreh: it's usually just an efficiency thing when otherwise you'd use a data with one constructor
15:41:01 <endojelly> what do you use to (locally) persist data?
15:41:32 <mreh> endojelly: this is functional programming
15:41:39 <lispy> skorpan: that's pretty reasonable
15:41:54 <DerisionSnort> @pl [1..]
15:41:55 <lambdabot> [1..]
15:42:01 <benmachine> so, newtype State s a = State { runState :: s -> (a, s) } would work fine as data State s a = ... but would have an extra layer of indirection
15:42:04 <endojelly> mreh, yes?
15:42:04 <benmachine> or something.
15:42:20 <mreh> what's the problem: endojelly
15:42:24 <lispy> skorpan: You might even want to make it periodic
15:42:25 <skorpan> lispy: it's just that i believed to have restricted the Int value in Day to 1..31 in the type system :P
15:42:38 <benmachine> heh
15:42:54 <endojelly> mreh, just want a simple way to persist data (inside IO)
15:43:06 <endojelly> write it out to a file, read it back
15:43:16 <endojelly> without necessarily writing my own parser
15:43:21 <dcoutts_> read/show for really simple stuff
15:43:27 <endojelly> do you just implement Show and Read?
15:43:30 <endojelly> dcoutts_, so you do :P
15:43:33 <skorpan> what's a good way to do that anyways?  make a data type represent 1..31 in the type system.  without 31 constructors for an ADT.
15:43:48 <mreh> endojelly: show/read is different from Show and Read
15:43:49 <dcoutts_> endojelly: using derive, yes.
15:44:06 <endojelly> mreh, Show and Read are the typeclasses?
15:44:11 <mreh> yeah
15:44:13 <mreh> you got it
15:44:31 <dcoutts_> endojelly: whether or not that's sufficient depends on the problem of course
15:44:34 <endojelly> mreh, please stop being condescending, there's no need. I know what a typeclass is.
15:44:41 <endojelly> dcoutts_, derive sounds interesting
15:44:47 <endojelly> dcoutts_, I will take a look into it, thanks
15:44:53 <mreh> i'm sorry if my delivery is so dry
15:45:06 <dcoutts_> endojelly: sorry, I just meant "deriving" the keyword not the "derive" tool
15:45:18 <endojelly> dcoutts_, aah, ok
15:45:30 <endojelly> dcoutts_, well that's simple, yes
15:45:30 <DerisionSnort> > let a = 1 in let b = 2 in a + b
15:45:31 <lambdabot>   3
15:45:43 <dcoutts_> endojelly: I try to avoid custom Read/Show instances
15:45:57 <endojelly> is there anything else readily available for persisting with a binary format?
15:45:59 <DerisionSnort> > let primes = sieve [2..] in let sieve (prime:rest) = prime : sieve (filter coprime rest) where coprime factor = factor `mod` prime /= 0 in take 20 primes
15:46:00 <lambdabot>   Not in scope: `sieve'
15:46:07 <endojelly> that is more efficient?
15:46:18 <skorpan> what's a good way to do that anyways?  make a data type represent 1..31 in the type system.  without 31 constructors for an ADT.
15:46:23 <skorpan> OOPS ACCIDENTAL, but what's the answer!?
15:46:37 <quicksilver> skorpan: there isn't one.
15:46:40 <DerisionSnort> > let let sieve (prime:rest) = prime : sieve (filter coprime rest) where coprime factor = factor `mod` prime /= 0 in primes = sieve [2..] in take 20 primes
15:46:41 <lambdabot>   <no location info>: Parse error in pattern
15:46:53 <skorpan> quicksilver: oleg can't help?
15:46:53 <DerisionSnort> > let sieve (prime:rest) = prime : sieve (filter coprime rest) where coprime factor = factor `mod` prime /= 0 in let primes = sieve [2..] in take 20 primes
15:46:54 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
15:46:56 <DerisionSnort> ah
15:47:10 <DerisionSnort> > let sieve (prime:rest) = prime : sieve (filter coprime rest) where coprime factor = factor `mod` prime /= 0 in let primes = sieve [2..] in take 100 primes
15:47:11 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:47:14 <quicksilver> skorpan: sure, you can do something with type-level binary numberes
15:47:22 <quicksilver> skorpan: but you said you wanted a *good* way
15:47:34 <skorpan> wow... i'm so disappointed.
15:47:40 <skorpan> i really thought there was a good way.
15:48:10 <mreh> skorpan: how you stop there being a 31st of February?
15:48:27 <skorpan> mreh: i didn't care that much
15:48:55 <mreh> skorpan: i thought you might be implementing a calendar
15:49:11 <skorpan> mreh: someone on the haskell-beginners list was doing that and i just got curious
15:49:28 <napping> hackage has some type-level integers
15:49:48 <napping> there's no obviousl package that has something like a BoundedInteger parametized over a type level bound, though
15:50:33 <mreh> just represent the day as an integer and convert the int into a (Day, Month)
15:51:02 <monochrom> Just use Data.Time.Calendar
15:51:08 <mreh> or the appropriate show implementation
15:51:11 <mreh> or that yes :(
15:51:15 <mreh> :)
15:55:20 <napping> Is there any tool for deriving a build-depends list from the things ghc --make finds?
15:55:40 <Igloo> ghc -M
15:55:42 <mreh> i'd like to know the answer to that too
15:55:59 <Igloo> Oh, ignore that, I misunderstood what you wanted
15:56:35 <gwern> so I'm editing an HCAr.tex; in the \begin{itmize} section with \items, how does one do subitems for an \item?
15:56:43 <napping> yeah, that's not quite it. Oh well, I seem to have found them all
15:56:48 <napping> gwern: another itemize!
15:56:54 <gwern> that's so ugly
15:57:20 <gwern> srsly? I need to do \item foo \begin{itemize} \item bar, to have * foo ** bar?
15:57:26 <napping> yeah
15:57:31 <luqui> seems reasonable to me...
15:57:41 <napping> get a good editor. I like yasnippets in emacs
15:57:52 <skorpan> get a good emacs-mode, e.g. org-mode
15:57:57 <skorpan> then export it to latex
15:58:25 <napping> yeah, I don't remember HCAR being too markup heavy. I don't think a project has ever had beautiful equations they wanted to include in their blurb
15:58:35 <gwern> napping: is that a dare?
15:59:21 <napping> Well, if you want * and ** use ReST or markdown or whatever
15:59:45 <gwern> hcar demands tex apparently
15:59:51 * gwern does use markdown on my own wiki
16:00:10 <napping> oh, you are just giving them a bit of tex to stick in?
16:00:14 <gwern> huh. this gitit plugin uses the SHA library to get a unique name, instead of 'mktemp'...
16:00:19 <gwern> napping: basically
16:01:22 <napping> couldn't you export from markdown?
16:02:05 <napping> hmm, windows doesn't have patch by default.
16:02:27 <napping> guess I'll just have to include the hacked up version of my dependency
16:04:41 <gwern> napping: I probably could but I'd have to rewrite the entire HCAR and I'm not sure the tex would be right
16:05:07 <nolrai_P> @src (.)
16:05:07 <lambdabot> (f . g) x = f (g x)
16:07:10 <knobo> wouldn't it be more logical to check the length of the two lists rather the value of the first element ing max [a] [a]?
16:07:13 <napping> gwern: try Pandoc with --no-wrap
16:07:41 <patch-tag> where is there a description of how #ifdef, #elsif (or is it #elif) and so on function for conditional compilation?
16:07:50 <patch-tag> Can't find the docu
16:09:09 <Saizan> they are standard standard cpp directives
16:10:14 <luqui> is there a computably uncountable set which is not compact?
16:10:52 <kmc_> @vixen is there a computably uncountable set which is not compact?
16:10:52 <lambdabot> there must be
16:10:56 <luqui> well, obviously there is   (Cantor x Integer)...
16:10:58 <luqui> :-)
16:10:59 <kmc_> there you are
16:11:07 <luqui> but... that is "cheating"
16:11:08 <hiredman> what is the wide bytecode instruction used for?
16:11:12 <luqui> i wonder what i mean by cheating
16:11:33 <lament> what does computably uncountable mean?
16:11:47 <hiredman> …
16:11:54 <luqui> no computable enumeration of its elements
16:11:56 <patch-tag> so cabal actually runs source through the cpp?
16:12:14 <hiredman> oh, sorry. wrong channel
16:12:17 <luqui> (as eg. an infinite list)
16:12:40 <dolio> It means that given any function f : N -> T, you can produce a T that doesn't correspond to f n for any n.
16:12:51 <lament> luqui: so, R?
16:13:29 <dolio> And yes, the reals are computably uncountable.
16:13:39 <lament> (and are not compact)
16:13:51 <luqui> lament, heh... riiight, that would work.  R doesn't have a repr as a recursive datatype...
16:13:59 <luqui> but i am not sure that matters for my purposes
16:14:01 <dcoutts_> patch-tag: yep, if you ask it to (ie use the CPP extension)
16:14:15 <dolio> Even the computable reals are computably uncountable, if that helps.
16:14:34 <luqui> that's what i was interpreting R as
16:14:38 <lament> dolio: what
16:14:40 <luqui> i don't believe in uncomputable things
16:14:42 <lament> dolio: but programs are countable?
16:14:43 <patch-tag> beh I don't know the c toolchain
16:14:59 <napping> luqui lives in the effective topos?
16:15:01 <dolio> lament: You can be countable but computably uncountable.
16:15:09 <nolrai_P> dolio: because of halting?
16:15:26 <lament> dolio: it certainly seems like i can write a program that would output all possible haskell programs...
16:15:35 <kmc_> so "computably uncountable" means "not computably-countable"?
16:15:47 <patch-tag> lament: might take a while though
16:15:48 <dolio> It's stronger than not computably countable.
16:15:55 <Cale> lament: DO IT NOW
16:16:03 <dolio> Because it gives you an example of what's missing.
16:16:05 <Cale> hehe
16:16:16 <lament> Cale: not quite sure what it would achieve :)
16:16:32 <nolrai_P> lament: but you cant get the outputs of all of those cause you can't know which ones are _|_.
16:16:38 <patch-tag> lament: your laptop might get hot
16:16:41 <lament> (so?)
16:16:48 <dolio> lament: You get to prove false in Haskell, so that's probably not surprising. :)
16:16:51 <lament> i just want to enumerate them, not to run them
16:17:00 <luqui> dolio, ah didn't know that defn
16:17:18 <nolrai_P> thats do able sure.
16:18:07 <luqui> lament, but you can't do it embedded.  you can enumerate all haskell programs which output Stream Bools for example
16:18:08 <augur> man
16:18:08 <dolio> luqui: I think it's a good enough definition, at least.
16:18:12 <augur> monads in ruby
16:18:20 <augur> are nowhere near as fun as monads in haskell
16:18:22 <augur> but theyre still fun
16:18:31 <luqui> but given any [Stream Bool] you can find a Stream Bool not included in it
16:19:16 <luqui> er, "which output [Stream Bool]s for example"
16:19:26 <dolio> luqui: N -> T is an implementation of Stream T, so I think it's the same as your definition.
16:19:46 <luqui> dolio, no i meant the defn of "can find one missing" rather than "not enumerable"
16:20:23 <luqui> thinking about this stuff always turns my brain into knots
16:20:25 <dolio> Oh, well, how else are you going to (constructively) prove that the function isn't an enumeration?
16:21:06 <luqui> yeah that makes sense
16:21:06 <eugenn> is it possible to define a function that behaves like this? > double 4 "x" returns 8 and > double "x" 8 returns 4
16:21:19 <luqui> eugenn, not without typeclas hacks
16:21:48 <luqui> eugenn, because it is taking different types for its first and second arguments...
16:21:56 <luqui> eugenn, or was that a typo?
16:22:13 <eugenn> no, you're right, I didn't saw that
16:22:45 <napping> so you want refute::((N->T)->T), but how do you give evidence that refute f is not any f n?
16:23:13 <dolio> You use a fancier type system than the one Haskell has.
16:24:03 <dolio> http://code.haskell.org/~dolio/agda-share/html/Diag.html
16:24:12 <DerisionSnort> Is there any way I can use Data.Function.fix to rewrite this?
16:24:12 <DerisionSnort> iterate guess = guess : iterate (improve guess)
16:24:47 <napping> How about the standard iterate?
16:24:57 <DerisionSnort> :t iterate
16:24:58 <lambdabot> forall a. (a -> a) -> a -> [a]
16:25:02 <DerisionSnort> @src iterate
16:25:02 <lambdabot> iterate f x =  x : iterate f (f x)
16:25:08 <dolio> Well, if code.haskell.org weren't down, that would show you an example.
16:25:22 <eugenn> > iterate (+3) 2
16:25:23 <lambdabot>   [2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77...
16:25:44 <copumpkin> DerisionSnort: it's pretty mechanical to convert something to use fix
16:25:58 <patch-tag> seems that you can have an #ifdef directive inside another #ifdef directive?
16:26:27 <luqui> DerisionSnort, but in general yes.  a recursive function f = ... f ...  can be rewritten as f = fix (\g -> ... g ...)
16:26:38 <patch-tag> is there an editor/emacs mode that makes this easier to read? I can't tell where directives get closed
16:26:42 <dolio> napping: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14369#a14369 There's a less nicely colored version (with extra stuff).
16:26:47 <DerisionSnort> Oh, the standard iterate is nice, didn't know about that!
16:26:47 <DerisionSnort> sqrts radicand = iterate improve radicand where
16:26:47 <DerisionSnort>     improve guess = average guess (radicand `div` guess)
16:26:47 <DerisionSnort>     average x y = (x + y) `div` 2
16:27:15 <copumpkin> say you wanted to write nub with fix
16:27:16 <copumpkin> @src nub
16:27:17 <lambdabot> nub = nubBy (==)
16:27:19 <copumpkin> bah
16:27:21 <napping> Is there some way to list the dependency versions cabal configure picked?
16:27:23 <copumpkin> @src nubBy
16:27:24 <lambdabot> nubBy eq []             =  []
16:27:24 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:27:35 <napping> -v seems ok
16:27:37 <dcoutts_> napping: yes, run configure with -v
16:27:41 <copumpkin> meh :)
16:27:49 <copumpkin> bad example
16:27:55 <luqui> nub is not a great simple function
16:27:59 <DerisionSnort> copumpkin, thanks anyway
16:28:14 <eugenn> > (\a -> a sum `div` a length) [5,7,9]
16:28:15 <lambdabot>   Couldn't match expected type `([GHC.Types.Int] -> GHC.Types.Int)
16:28:15 <lambdabot>           ...
16:28:20 <DerisionSnort> I guess I cannot make it any clearer than with iterate
16:28:21 <copumpkin> DerisionSnort: did you understand what luqui said though? it's fairly easy to just replace every occurrence of the function name with the fix paraeter
16:28:21 <luqui> > let repeat' x = fix (x:) in repeat' 42
16:28:22 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
16:28:27 <napping> well, somehow Control.Exception.catch seems to want an Exception, rather than the new extensible thing
16:28:37 <luqui> > fix error
16:28:38 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
16:29:03 <luqui> (hardly fixed)
16:29:10 <eugenn> > [5,7,9] sum
16:29:11 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:29:15 <copumpkin> :t fix . (:)
16:29:16 <lambdabot> forall a. a -> [a]
16:29:45 <eugenn> :t sum
16:29:46 <lambdabot> forall a. (Num a) => [a] -> a
16:30:03 <copumpkin> omg, sum and fix . (:) must be inverses!
16:30:18 <napping> Ah, seems --make was hiding the old base-3 and cabal left both visible
16:30:24 <luqui> :t sum . (fix . (:))
16:30:25 <lambdabot> forall a. (Num a) => a -> a
16:30:30 <copumpkin> proof!
16:30:37 <luqui> :t sum . (fix . (:)) $ 42
16:30:39 <lambdabot> forall a. (Num a) => a
16:30:42 <luqui> sum . (fix . (:)) $ 42
16:30:45 <luqui> > sum . (fix . (:)) $ 42
16:30:49 <lambdabot>   mueval-core: Time limit exceeded
16:30:50 <luqui> <- lol, sry for the noise
16:30:56 <copumpkin> they would be inverses if it terminated, I'm sure!
16:30:58 <eugenn> > [5,7,9] sum --why doesn't it work?
16:31:00 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:31:06 <copumpkin> eugenn: because that's not how you apply functions in haskell
16:31:07 <dcoutts_> napping: I'm not sure that that makes sense
16:31:11 <DerisionSnort> copumpkin, so how would I rewrite the following with fix? myIterate f x = x : myIterate f (f x)
16:31:12 <luqui> > sum [5,7,9]
16:31:13 <copumpkin> > sum [5,7,9]
16:31:13 <lambdabot>   21
16:31:15 <lambdabot>   21
16:31:15 <kmc_> eugenn, you're trying to apply a list as if it were a function
16:31:18 <luqui> functions go *before* their arguments
16:31:20 <eugenn> oh god...
16:31:22 <kmc_> > [2] 3
16:31:23 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:31:24 <eugenn> i'm so sleepy
16:31:43 <copumpkin> :t fix (\myIterate f x -> x : myIterate f (f x))
16:31:45 <napping> dcoutts_: well, cabal configure -v has a "selecting base-3.0.3.1 (installed) and 4.1.0.0 (installed)
16:31:46 <lambdabot> forall a. (a -> a) -> a -> [a]
16:32:00 <napping> oh, I guess it settled on 3 later
16:32:01 <copumpkin> DerisionSnort: I basically put a \ at the front, and changed = to -> :P
16:32:16 <dcoutts_> napping: right, that's somewhat misleading. It does pick just one in the end.
16:32:23 <DerisionSnort> copumpkin: cool!
16:32:32 <eugenn> > (\a -> a sum `div` a length) [5,7,9]
16:32:35 <dcoutts_> napping: ghc --make, and cabal configure will pick one of base 3 or base 4. They might make different choices. Cabal has the advantage of seeing the constraints in the .cabal file to inform its decision.
16:32:35 <lambdabot>   Couldn't match expected type `([GHC.Types.Int] -> GHC.Types.Int)
16:32:35 <lambdabot>           ...
16:32:42 <copumpkin> eugenn: same thing.
16:32:52 <copumpkin> eugenn: did you just come from coding factor or something?
16:32:52 <luqui> i actually use fix in practice, when i would have written  let foo = ... foo ... in foo
16:32:53 <eugenn> > (\a -> sum a `div` length a) [5,7,9]
16:32:55 <lambdabot>   7
16:33:07 <eugenn> The thing is tomorrow I have a smalltalk exam xD
16:33:23 <luqui> quick, fill eugenn's head with strongly typed propaganda!
16:33:23 <dolio> lament: Anyhow, I suspect if you try to apply the diagonal construction to a function that generates and evals haskell functions you'll see some non-termination (like when you ask for the digit where the diagonal asks the enumerator to generate and evaluate the diagonal function itself).
16:33:33 <luqui> nothing better than taking an exam about a language you can't stand!
16:33:39 <mpwd> eugenn: They have exams in smalltalk?
16:33:41 <copumpkin> eugenn: you should reimplement everything at the type level
16:33:46 <mpwd> Is it 1998 or something?
16:33:59 <copumpkin> our untyped type system
16:34:04 <luqui> oh yes, how the world has improved, now we have *java* exams
16:34:12 <eugenn> actually is a programming paradigms final. includes smalltalk, haskell & prolog
16:34:22 <mpwd> luqui: Umm... now we have Haskell exams?
16:34:25 <luqui> eugenn, *that* is a good class
16:34:34 <napping> Is there any way to ask cabal-install to install the dependencies listed in a .cabal file?
16:34:42 <eugenn> It was the best I've ever had
16:34:49 <copumpkin> napping: cabal install x ?
16:34:50 <luqui> eugenn, at univ of colo, the "principles of prog. lang" class basically talks about C++ with minor syntax variations
16:34:54 <DerisionSnort> @pl \x y -> (x + y) `div` 2
16:34:54 <lambdabot> flip flip 2 . (div .) . (+)
16:34:56 <napping> copumpkin: so by hand?
16:35:18 <copumpkin> napping: no, I mean if your package is x, and it has a,b,c as dependencies, cabal install x will install a b c first
16:35:31 <DerisionSnort> is there no standard average function in the standard? average(50, 70) = 60 ?
16:35:33 <copumpkin> napping: EXCEPT if it's an executable, for some reason
16:35:38 <napping> copumpkin: from a local .cabal file?
16:35:44 <copumpkin> DerisionSnort: nope
16:35:46 <napping> don't you need to install that stuff before building?
16:35:50 <copumpkin> napping: in that case, just cabal install from the folder containing the file
16:35:55 <dcoutts_> napping: you can use "cabal install" directly
16:35:58 <napping> oh, hmm. ok
16:36:06 <eugenn> > (\a -> sum a / length a) [5,7,9]
16:36:07 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
16:36:07 <lambdabot>    arising from a use o...
16:36:07 <napping> but I don't really want to install the executable I'm building anywhere
16:36:13 <dcoutts_> of course it means it'll install rather than just configure + build
16:36:23 <copumpkin> omg you need fold combinators
16:36:24 <dcoutts_> napping: ^C helps :-)
16:36:44 <eugenn> :t average
16:36:45 <lambdabot> Not in scope: `average'
16:36:50 <napping> well, I'm trying to package up something I wrote under linux in the first place so I can send it to people to run on windows
16:37:01 <napping> and build for themselves, so I'd like it to be as simple as possible
16:37:14 <napping> I guess it doesn't hurt to hide an extry copy of my thing somewhere random
16:37:28 <Berengal> napping: They need ghc to build it on windows. It's not far-fetched to demand they have cabal as well
16:37:54 <napping> Yeah, I'm already suggesting to install the haskell platform
16:37:57 <Berengal> napping: Your other option is to build it on windows yourself, and distribute the binary
16:38:05 <napping>  but I'd like to mimize the number of steps
16:38:08 <eugenn> :t trim
16:38:09 <lambdabot> Not in scope: `trim'
16:38:20 <luqui> eugenn, hoogle it!
16:38:25 <Berengal> napping: "cabal install foo" is about as minimal as you can get...
16:38:26 <napping> there's no way to tell cabal to go build another cabal project in a subdirectory, is there?
16:38:36 <Berengal> or "cd foo; cabal install"
16:38:40 <eugenn> I'll try to define it myself
16:38:44 <napping> Berengal: yeah, I thought you'd have to be like cabal install dep1; cabal install dep2; cabal install dep3 ...
16:38:56 <sproingie> cabal install installs all deps
16:38:58 <DerisionSnort> @pl (x, y) -> x /= y
16:38:58 <lambdabot> (line 1, column 8):
16:38:58 <lambdabot> unexpected ">" or "-"
16:38:58 <lambdabot> expecting variable, "(", operator or end of input
16:39:00 <napping> but one manual step for my hacks to httpd-shed is ok
16:39:04 <DerisionSnort> @pl \(x, y) -> x /= y
16:39:05 <lambdabot> uncurry (/=)
16:39:12 <napping> sproingie: I have a local hacked copy of httpd-shed I need built and used
16:39:15 <ddarius> That's the purpose of cabal-install's existence.
16:39:26 <sproingie> would be nice if cabal unpack could be made to grab all deps
16:39:28 <napping> If I wanted the hackage version that would be fine
16:39:28 <Berengal> napping: You could also look into a custom Setup.lhs, but I don't really know how that works...
16:39:32 <sproingie> cabal fetch does so it's easy to list them
16:39:35 <dcoutts_> sproingie: that's what cabal fetch does
16:39:41 <napping> oh, hmm
16:39:51 <napping> Well, I think leaving an instruction like that is ok
16:40:03 * ddarius would certainly not want the default behaviour of cabal unpack to be to grab dependencies.
16:40:06 <sproingie> yahbut cabal fetch doesn't unpack anything.  anyway it's a pretty simple script
16:40:17 <napping> I'm on 64 bit windows 7 so they might not like my executable
16:40:23 <Berengal> Does fetch really grab dependencies though, or just check them?
16:40:24 <sproingie> as an option.  but anyway it's a simple shell script
16:40:24 <dcoutts_> sproingie: I'm clealy missing something, what's the goal here?
16:40:37 <dcoutts_> Berengal: it gets them all, so you can install offline later.
16:41:06 <eugenn> (words . unwords) "      hello world trying trim here   "
16:41:06 <Berengal> dcoutts_: Ah. I just thought i remembered it not doing that, but I must've remembered wrong
16:41:15 <eugenn> > (words . unwords) "      hello world trying trim here   "
16:41:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:41:17 <lambdabot>         against inferred ty...
16:41:33 <luqui> > (unwords . words) "    hello   world trying to  trim    here    "
16:41:33 <sproingie> dcoutts_: just for browsing's sake.  but like you mentioned, cabal fetch is perfectly good at it
16:41:34 <lambdabot>   "hello world trying to trim here"
16:41:46 <luqui> a little bit stronger than what "trim" would imply
16:41:52 <eugenn> good one ;) beat me to it
16:42:02 <dcoutts_> sproingie: you can cabal unpack several things in one go
16:42:05 <gressvol-> Does both the functions take and drop allocate memory when called?
16:42:10 * hackagebot upload: AES 0.2.4 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
16:42:24 <luqui> gressvol-, take does, drop doesn't... ish...
16:42:25 <ddarius> take allocates memory, drop doesn't need to
16:42:34 <dcoutts_> sproingie: it doesn't make a lot of sense to say "unpack this and all its deps" where do you stop? unpack base too?
16:42:49 <luqui> gressvol-, thinking about memory allocation in haskell is tricky business, and i have found it useful to transcend the idea of memory into a more abstract model
16:42:57 <luqui> what that more abstract model is i am not sure
16:43:08 <patch-tag> cabal install --flags="nohardlink" -v2    -- this should set the nohardlink flag to true, overriding the default value, right? not the behavior I'm seeing though.
16:43:10 <sproingie> if you want to cabal install from scratch you must first invent the universe
16:43:15 <kmc_> sproingie++
16:43:22 <luqui> sproingie, woot carl sagan!
16:43:36 <Berengal> dcoutts_: Can you get cabal to dump all dependency information it has on a package somehow?
16:43:45 <eugenn> > drop 3 [1,2,3,4,5,6]
16:43:45 <Berengal> dcoutts_: Preferably without building...
16:43:46 <lambdabot>   [4,5,6]
16:43:53 <dcoutts_> Berengal: cabal info blah
16:44:03 <dcoutts_> Berengal: or cabal install blah --dry-run
16:44:30 <dcoutts_> patch-tag: correct
16:44:30 <patch-tag> berengal: in 6.12 you can output a graphviz dependency graph, there's an example in the docu
16:44:49 <Berengal> dcoutts_: info only prints what's in cabal... --dry-run sounds more useful (with -v)
16:44:49 <sproingie> note to self: when blowing away ~/.cabal, also blow away ~/.ghc
16:44:49 <dcoutts_> that's for installed packages
16:44:54 <sproingie> so much breakage
16:44:55 <Berengal> The graph sounds nice :)
16:45:15 <dcoutts_> Berengal: -v isn't necessary
16:45:45 <dcoutts_> Berengal: --dry-run means print what would be installed. That's not quite the same as listing the dependencies (which is what cabal info shows)
16:45:46 <eugenn> > (succ . pred) 7
16:45:47 <lambdabot>   7
16:46:25 <Berengal> dcoutts_: Ah, right...
16:46:42 <Berengal> dcoutts_: That still leaves me with getting a list of all dependencies (with selected versions)...
16:46:54 <DerisionSnort> @pl head $ dropWhile p
16:46:54 <lambdabot> head (dropWhile p)
16:46:56 <dcoutts_> Berengal: what do you mean precsely?
16:47:09 <DerisionSnort> @pl head . (dropWhile p)
16:47:10 <lambdabot> head . dropWhile p
16:47:14 <patch-tag> aha: it wasn't working because I had flag nohardlink: in the cabal file. the colon prevented this from being parsed correctly I guess.
16:47:30 <sproingie> > let f = succ . pred
16:47:30 <lambdabot>   not an expression: `let f = succ . pred'
16:47:37 <sproingie> darg
16:47:42 <eugenn> (head .) . dropWhile
16:48:33 <sproingie> > let f = succ . pred in f
16:48:34 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
16:48:42 <Berengal> dcoutts_: I can't remember the exact scenario right now, but a couple of weeks ago I was do a bit of maintainment of an old project of mine, and wanted all dependencies with versions listed out in a neat list so I could use it in a bash script
16:48:46 <eugenn> > curry . uncurry . (+1) 4
16:48:47 <lambdabot>   No instance for (GHC.Num.Num (f (a -> b -> c)))
16:48:47 <lambdabot>    arising from the literal...
16:48:55 <patch-tag> @t succ
16:48:56 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:48:57 <sproingie> now that was unexpected
16:49:05 <Berengal> dcoutts_: Also including transient dependencies
16:49:05 <dcoutts_> Berengal: dependencies are more complicated than you think, you need to decide what that means exactly.
16:49:09 <patch-tag> > :t succ
16:49:10 <lambdabot>   <no location info>: parse error on input `:'
16:49:16 <patch-tag> @type succ
16:49:17 <lambdabot> forall a. (Enum a) => a -> a
16:49:18 <DerisionSnort> @pl \xs -> fst . head $ dropWhile (uncurry (/=)) $ neighbours xs
16:49:18 <lambdabot> fst . head . dropWhile (uncurry (/=)) . neighbours
16:49:21 <patch-tag> @type pred
16:49:23 <lambdabot> forall a. (Enum a) => a -> a
16:49:24 <sproingie> was just trying to tickle the MR
16:49:32 <dcoutts_> Berengal: so you mean resolving the package description and picking exact versions of deps to configure and build with.
16:49:48 <Berengal> dcoutts_: Yes. All packages given as arguments to ghc to build with
16:49:53 <patch-tag> what's the mr?
16:50:00 <sproingie> monomorphism restriction
16:50:11 <sproingie> f = succ . pred
16:50:16 <sproingie> try compiling that
16:50:22 <eugenn> @define f = succ . pred
16:50:23 <dcoutts_> Berengal: right, so that's what cabal install does internally, it makes an InstallPlan which is a graph with precise package deps.
16:50:56 <dcoutts_> Berengal: and when you do --dry-run it lists the subset of those that need to be (re)installed
16:50:56 <patch-tag> sproingie: works in ghci
16:50:59 <Berengal> dcoutts_: I don't know what cabal looks like on the inside, but I imagine I want a dump of all the information it has gathered right before it starts calling ghc
16:50:59 <sproingie> there's lots of ways to avoid it, it's more a curiosity
16:51:03 <luqui> :t f
16:51:04 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:51:07 <dcoutts_> Berengal: the complete list extense all the way down to base, rts of course.
16:51:15 <patch-tag> > succ . pred $ 1
16:51:16 <lambdabot>   1
16:51:24 <sproingie> patch-tag: try "let f = succ . pred"
16:51:26 <Berengal> dcoutts_: Ah, well, I also would like things that don't need to be reinstalled
16:51:30 <luqui> MR is a great example of why i hate F#
16:51:43 <luqui> F# is a language where every decision is a monomorphism restriction
16:51:49 <dcoutts_> Berengal: --dry-run -v dumps its internal thoutghts which includes the full list, but not in an especially machine readable form.
16:51:53 <sproingie> MR is a big albatross in ocaml
16:52:05 <sproingie> in haskell it's an occasionally easily avoided annoyance
16:52:14 <sproingie> surprised it didn't get tossed in Haskell 2010
16:52:15 <ddarius> sproingie: It's necessary in the MLs.
16:52:22 <ddarius> (or some system to accomplish the same is)
16:52:38 <patch-tag> MLs == ocaml and friends?
16:52:43 <eugenn> > f 5
16:52:44 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:52:45 <lambdabot>    `SimpleReflect.FromExpr ...
16:52:49 <Berengal> dcoutts_: indeed...
16:52:59 <ddarius> patch-tag: SML and (O')Caml.
16:53:01 <patch-tag> > let f = succ . pred in f 1
16:53:02 <lambdabot>   1
16:53:12 <dcoutts_> sproingie: and in Haskell it makes it much easier to explain the sharing behaviour. It lets you say that if you give it a name then it's shared.
16:53:13 <luqui> patch-tag, and F# to some extent...
16:53:13 <ddarius> And presumably their derivatives such as Alice ML and F#.
16:53:47 <Berengal> dcoutts_: For what it's worth, I wanted to use it in a ghci-launcher script
16:54:04 <Raynes> patch-tag: I'll give you $300 USD to change your name to 'tag-patch' and show a splash page with a picture of some guy chasing after Robin Williams.
16:54:08 <dcoutts_> Berengal: right, there's a ticket on a "cabal ghci" mode
16:54:10 <eugenn> :t ((+1) .)
16:54:11 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
16:54:31 <luqui> I wonder what the next big thing that will catch on in imperativia from FP is
16:54:37 <luqui> everybody is getting monad syntax
16:54:50 <luqui> and HOFs
16:54:54 <Berengal> dcoutts_: neat!
16:55:04 <sproingie> simple HOFs are everywhere already
16:55:08 <sproingie> monads much less so
16:55:15 <luqui> but i don't see them getting free theorems any time soon.  programmers don't like being told they can't do things.
16:55:20 <sproingie> list comprehensions broke out in a big way
16:55:49 <Berengal> dcoutts_: By the way, I've been looking at the hackage server code. I was meaning to fire off an email to you about it, but got distracted by snow and java.
16:56:04 <sproingie> not much left that can be taken ala-carte without adopting the type system
16:56:08 <luqui> > let f = succ . pred in (f 1, f True)
16:56:09 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
16:56:09 <lambdabot>    arising from the literal `1'...
16:56:16 <dcoutts_> Berengal: ah right
16:57:09 <napping> this is really weird. I'm trying to run my server locally, and it's getting requests but the responses are not going through
16:57:19 <Berengal> dcoutts_: I couldn't really identify any nice, small tasks that needed doing. The features that are there look mostly complete, but sometimes they turn out not to be
16:57:29 <sproingie> go might make structural subtyping popular
16:57:32 <sproingie> that would be a win
16:57:37 <dcoutts_> Berengal: how about mirroring
16:57:42 <eugenn> > (/a -> zipWith ($) (repeat concat) a) [[[[[[[8]]]]]]]
16:57:43 <lambdabot>   <no location info>: parse error on input `->'
16:57:52 <patch-tag> napping: firewall?
16:57:57 <luqui> sproingie, a lot of people are talking about purity annotations, but nobody is doing it
16:58:04 <eugenn> > (\a -> zipWith ($) (repeat concat) a) [[[[[[[8]]]]]]]
16:58:05 <lambdabot>   [[[[[[8]]]]]]
16:58:06 <dcoutts_> Berengal: we'd like to be able to mirror the current hackage server as part of the transition. And it's generally useful to have mirrors.
16:58:12 <napping> it's allowed, and the requests make it to the server
16:58:20 <Berengal> dcoutts_: I could try that. Any thoughts on how to go about it?
16:58:21 <napping> it's even printing what it tries to return in the lock
16:58:25 <napping> in the log
16:58:31 <dcoutts_> Berengal: so in particular that means being able to upload packages and "forge" the upload info.
16:58:44 <sproingie> you can sorta get purity annotations in C++ if you sprinkle 'const' in every other token
16:58:44 <patch-tag> napping: what kind of server?
16:58:54 <eugenn> > foldl1 (\a -> zipWith ($) (repeat concat) a) [[[[[[[8]]]]]]]
16:58:55 <lambdabot>   Couldn't match expected type `[[[a]]] -> [[[a]]]'
16:58:55 <lambdabot>         against inferred ...
16:59:00 <napping> httpd-shed, on port 8080
16:59:03 <luqui> :t zipWith ($) (repeat concat)
16:59:04 <lambdabot> forall a. [[[a]]] -> [[a]]
16:59:04 <napping> bound to 127.0.0.1
16:59:08 <dcoutts_> Berengal: since if I add a package to this server I want to make it look like it was uploaded by the original author and at the same time etc
16:59:23 <patch-tag> napping: what does the error log say?
16:59:25 <Berengal> dcoutts_: As in letting the other servers push, or let this server pull?
16:59:45 <dcoutts_> Berengal: let a dedicated mirroring client pull from one server and push to another.
16:59:50 <napping> patch-tag: I don't know of a standard error log, I just have some debug prints that echo the response before I return into shed
16:59:55 <luqui> @check \(xs :: [[[Bool]]] -> zipWith ($) (repeat concat) xs == concat xs)
16:59:55 <lambdabot>   Parse error at "$)" (column 32)
17:00:06 <luqui> @check (\(xs :: [[[Bool]]]) -> zipWith ($) (repeat concat) xs == concat xs)
17:00:06 <lambdabot>   Parse error in pattern at "->" (column 22)
17:00:13 <dcoutts_> Berengal: the solution is probably something like a raw PUT interface for packages and package meta-data for suitable authorised clients.
17:00:15 <patch-tag> napping: what does dmesg | tail say?
17:00:25 <napping> patch-tag: it's on windows
17:00:30 <napping> works fine on linux
17:00:31 <luqui> @check (\xs :: -> zipWith ($) (repeat concat) (xs :: [[[Bool]]]) == concat xs)
17:00:31 <lambdabot>   Parse error at "::" (column 6)
17:00:35 <luqui> wtf
17:00:45 * ddarius doesn't want purity annotations, he wants impurity annotations to otherwise pure code.
17:00:47 <patch-tag> napping: turn all firewalls off.
17:00:56 <Berengal> dcoutts_: Right. I've also thought about a possible command interface... Letting the server bind to localhost on a suitable port, allowing a client shell to issue commands to it that way
17:01:13 <luqui> ddarius, yeah, well, probably not going to happen for some time.  stick with the currently best language for that :-)
17:01:15 <ddarius> Or, at the very least, immutable variables should be the default (e.g. C# readonly) with a 'mutable' modifier.
17:01:50 <dcoutts_> Berengal: does that add anything over just using authentication? or is the worry that the authentication is too weak?
17:01:51 <luqui> @check (\xs -> zipWith ($) (repeat concat) (xs :: [[[Bool]]]) == concat xs)
17:01:52 <lambdabot>   "Falsifiable, after 4 tests:\n[[[True,False,False],[False,False,False],[Tru...
17:02:20 <luqui> @check (\xs -> map concat (xs :: [[[Bool]]]) == concat xs)
17:02:21 <lambdabot>   "Falsifiable, after 3 tests:\n[[],[[True,False],[]]]\n"
17:02:35 <Berengal> dcoutts_: It does circumvent the whole authentication business, and lets you control the server from a command line easily. Remote access can be done through ssh as usual
17:02:47 <luqui> @check (\xs -> concat (map concat (xs :: [[[Bool]]])) == concat (concat xs))
17:02:51 <eugenn> @check (succ . pred) == id
17:02:51 <lambdabot>   mueval-core: Time limit exceeded
17:02:52 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
17:02:52 <lambdabot>    arising from a use of `GHC.Cla...
17:03:06 <dcoutts_> Berengal: true, eg I've currently got a primitive local command interface for writing a data checkpoint
17:03:22 <dcoutts_> Berengal: if happs makes that easy then great
17:03:47 <dcoutts_> Berengal: eg can it serve on a unix domain socket? if it can, are there any clients that can use an interface like that?
17:04:23 <eugenn> :t append
17:04:23 <lambdabot> Not in scope: `append'
17:04:33 <Berengal> dcoutts_: I don't know if it does, but I could try to find out.
17:06:30 <gwern> huh. tex interprets & as a special character?
17:06:59 <Berengal> dcoutts_: I just know that I often find myself in want of a simple command-line-interface to the various web servers I've written. Just something simple, where you can push functions and receive data. It would be useable by both simple admin-shells and autonomous clients like a mirroring client
17:07:06 <eugenn> > fix concat [[[7]]]
17:07:07 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:07:19 <gwern> (ah, and now gitit's HCAR is up to date as well)
17:07:27 * gwern is feeling like a virtuous little dooby today
17:07:34 <gwern> must be the modafinil
17:07:49 <dcoutts_> Berengal: right
17:08:14 <eugenn> > concat 3
17:08:15 <lambdabot>   No instance for (GHC.Num.Num [[a]])
17:08:15 <lambdabot>    arising from the literal `3' at <int...
17:08:24 <dcoutts_> Berengal: the tricky thing is avoiding implementing two interfaces for each resource
17:08:42 <napping> patch-tag: that doesn't help, but some extra tracing in shed suggests it's failing at the write
17:08:47 <Berengal> dcoutts_: I know... One web-based and one CLI...
17:08:51 * ddarius doesn't know what a "dooby" is.
17:09:02 <dcoutts_> Berengal: if it speaks http over a unix domain socket then that sorts things out a bit
17:09:15 <gwern> @wn dooby
17:09:16 <lambdabot> No match for "dooby".
17:09:21 <Berengal> dcoutts_: I'
17:09:30 <dcoutts_> Berengal: but like I said, I dunno about support for that in things like wget etc
17:09:31 <Berengal> dcoutts_: I'll look into it if I've got time :)
17:09:39 <gwern> (...hm. is dooby the right spelling?)
17:10:04 <gwern> oh, here we go: http://www.urbandictionary.com/define.php?term=good%20doobie
17:10:20 <gwern> 'From old kids' t.v. show Romper Room, where the chick said "don't be a Don't Bee and do be a Do Bee." Morphed into good doobie, which is redundant.' <-- I had no idea
17:10:51 <eugenn> > (concat . concat . concat) [[[[2]]]]
17:10:52 <lambdabot>   [2]
17:11:40 <eugenn> > (/[a] -> a) [2]
17:11:41 <lambdabot>   <no location info>: parse error on input `->'
17:11:50 <eugenn> > (\[a] -> a) [2]
17:11:51 <lambdabot>   2
17:12:38 <copumpkin> eugenn: you really like the (/x -> ..) y, oh whoops (\x -> ..) y pattern, eh :P
17:13:02 <patch-tag> what's the deal with elif and elsif in cpp directives? always elif?
17:13:22 <m0nkfish> welcome to #haskell
17:14:21 <m0nkfish> if you would like more detailed information on cpp directives check out http://www.haskell.org/cpphs/
17:14:43 <patch-tag> >  (join . join . join) [[[[2]]]]
17:14:44 <lambdabot>   [2]
17:14:45 <mreh> why isn't foldlM implemented?
17:14:57 <patch-tag> eugenn: concat is join in list monad
17:15:05 <Saizan> mreh: foldM is foldlM
17:15:07 <DerisionSnort> I am trying to find the first element in a list that is equal to its neighbour. Is there something more elegant than the following?
17:15:07 <DerisionSnort> stable (x:rest@(y:_))
17:15:07 <DerisionSnort>     | x == y    = x
17:15:07 <DerisionSnort>     | otherwise = stable rest
17:15:25 <mreh> Saizan: oh good
17:15:38 <mreh> I need to understand it better I think
17:15:42 <patch-tag> eugenn: join . return . return => return ..... i think :)
17:15:52 <eugenn> oh
17:16:24 <patch-tag> join lets you "pop out" a level in your monad
17:16:45 <eugenn> > ((.) (.) (.) concat concat concat) [[[[3]]]]
17:16:46 <lambdabot>   Couldn't match expected type `t -> [[a]]'
17:16:46 <lambdabot>         against inferred type `[a...
17:16:59 <napping> whoa, is something weird with the threaded runtime on windows?
17:17:17 <eugenn> > ((.) (.) concat concat concat) [[[[3]]]]
17:17:17 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
17:17:34 <patch-tag> @pl (join . join . join) [[[[2]]]]
17:17:34 <lambdabot> [2]
17:17:36 <napping> looks like my write only goes through when the recieving socket closes, which I have a thread watching for
17:18:04 <patch-tag> @pl (join . join . join)
17:18:05 <lambdabot> join . join . join
17:18:23 <patch-tag> @pl  [[[[2]]]]
17:18:24 <lambdabot> [[[[2]]]]
17:19:12 <patch-tag> > (join . join . join . return . return . return . return) 2
17:19:12 <mreh> eugenn: function application needs brackets
17:19:13 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:19:13 <lambdabot>    arising from a use of `M2743165055...
17:19:32 <mreh> > ((.) ((.) concat concat) concat) [[[[3]]]]
17:19:33 <lambdabot>   [3]
17:19:47 <patch-tag> > (join . join . join . return . return . return . return) 2 :: [Int]
17:19:48 <lambdabot>   [2]
17:19:57 <patch-tag> > (join . join . join . return . return . return . return) (2 :: Int)
17:19:57 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Int))
17:19:58 <lambdabot>    arising from a use of ...
17:20:24 <patch-tag> > (join . join . join . return . return . return . return . return) 2 :: [[Int]
17:20:25 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:20:29 <patch-tag> > (join . join . join . return . return . return . return . return) 2 :: [[Int]]
17:20:30 <lambdabot>   [[2]]
17:20:46 <napping> whoa, is hpaste down?
17:20:50 <mreh> :t (.) (.)
17:20:51 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
17:21:02 <patch-tag> > (join . join . join . return . return . return . return . return) 2 :: (Maybe (Maybe Int))
17:21:04 <lambdabot>   Just (Just 2)
17:21:21 <ray> :t join $ fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:21:23 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
17:21:23 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
17:21:23 <lambdabot>     In the 9th argument of `fmap', namely `fmap'
17:22:18 <gwern> @quote fmap.fmap
17:22:18 <lambdabot> No quotes match. Just try something else.
17:22:26 <ray> @quote fmap
17:22:27 <lambdabot> ddarius says: fmap: Because getting functions to the values is half the battle.
17:22:29 <napping> http://paste.lisp.org/display/92335
17:22:37 <chellomere> :t join $ fmap $ fmap $ fmap
17:22:38 <lambdabot>     Occurs check: cannot construct the infinite type:
17:22:38 <lambdabot>       f = (->) (f (f1 (a -> b)))
17:22:38 <lambdabot>     Probable cause: `$' is applied to too many arguments
17:22:44 <ray> @quote occur
17:22:45 <lambdabot> ghc says: Occurs check: cannot construct the infinite type
17:22:52 <napping> This snippet seems to work okay on linux, but it looks like it's hanging until the socket closes on windows
17:23:01 <napping> I'm pretty sure I'm building with -threaded
17:23:17 <patch-tag> :t liftM
17:23:18 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:23:49 <mreh> gah, I need to do list monad stuff inside another monad!
17:24:01 <patch-tag> mreh: liftM
17:24:11 <mreh> patch-tag: cheers
17:24:16 <patch-tag> mreh: lets you reach inside a monad from another monad
17:24:41 <mreh> remarkably roomy these monads
17:24:44 <patch-tag> mreh: actually... maybe not right
17:24:47 <napping> do I need to specify -threaded when linking a package intented to be used from programs using the threaded runtime?
17:24:53 <mreh> :t liftM
17:24:54 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:25:02 <luqui> mreh, in what sense do you mean that?
17:25:11 <patch-tag> mreh: yeah, show us a snip
17:25:26 <patch-tag> mreh: inside a monad from another could mean a zillion things :)
17:25:40 <mreh> let me write a code stub so you get the idea
17:25:42 <luqui> mreh, you can do stuff like sequence [ print (x + y) | x <- [1..3], y <- [2..4] ]
17:25:56 <patch-tag> > putStrLn "yo"
17:25:57 <lambdabot>   <IO ()>
17:26:05 <copumpkin> or mapM_ print [ x + y | x <- [1..3], y <- [2..4] ]
17:26:06 <mreh> lambdabot doesn
17:26:14 <patch-tag> > return "yo" :: Maybe String
17:26:15 <lambdabot>   Just "yo"
17:26:18 <mreh> 't execute :(
17:26:48 <patch-tag> > return (reverse "yo") :: Maybe String
17:26:49 <lambdabot>   Just "oy"
17:27:41 <mreh> that isn't list monad
17:27:49 <mreh> let me think of an example problem
17:28:08 <mreh> well, i'll write out the function
17:28:09 <copumpkin> mreh: the comprehension is the list monad
17:28:37 <copumpkin> @let realsqrt x = nub [sqrt x, negate (sqrt x)]
17:28:38 <lambdabot>  Defined.
17:28:42 <luqui> sequence_ $ do { x <- [1..3]; y <- [2..4]; print (x + y)}
17:28:42 <mreh> i need list monad inside of a monad, not the other way
17:29:00 <copumpkin> IO [a] ?
17:29:08 <luqui> mreh, please just continue with example.  words like "inside" are hard to intuit...
17:29:19 <patch-tag> > return (do y <- "y"; o <- "o"; return y:o:[]) :: Maybe String
17:29:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:29:20 <lambdabot>         against inferred type...
17:29:21 <mreh> RandGen g => Rand g [a]
17:29:40 <copumpkin> what do you need to do with it?
17:29:53 <mreh> create a ramdom walk
17:30:15 <copumpkin> sequence [Rand g a]
17:30:20 <copumpkin> obviously abusing syntax
17:30:44 <mreh> copumpkin: but I need to remember where I've just been
17:30:49 <mreh> so I
17:30:53 <mreh> 'm using foldM
17:31:13 <copumpkin> hm, don't really understand :/
17:31:14 <napping> hmm, does windows make it so you can't write to a socket if there is a read currently blocking on it?
17:31:17 <patch-tag> mreh: if you need to remember where you are maybe you should use state
17:31:17 <luqui> mreh, yeah me neither
17:31:33 <mreh> patch-tag, using a left fold to simulate state
17:31:40 <mreh> I only need to remember the last calculation
17:31:55 <mreh> then reversing the list
17:32:22 <mreh> > foldl (flip (:)) [] [1,2,3]
17:32:23 <lambdabot>   [3,2,1]
17:32:28 <patch-tag> mreh: just use state, it's easier to read :)
17:32:44 <mreh> patch-tag, but then I have to use the StateT monad :(
17:32:56 <patch-tag> mreh: that's what #haskell is here for :)
17:33:20 <luqui> disagreeing with patch-tag fwiw
17:33:32 <luqui> this computation does not sound stateful to me
17:33:34 <mreh> hold my hand while I deliver this baby
17:33:43 <mreh> luqui: it isn't
17:33:48 <mreh> ...really
17:33:56 <patch-tag> well... "only need to remember the last" makes it sound not stateful yes
17:34:19 <mreh> with a left fold I can access the head of the list
17:34:22 <copumpkin> mreh: can you give more details? we're still guessing at what you want
17:34:31 <mreh> the last computation
17:34:52 <luqui> :t foldM
17:34:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:34:53 <mreh> I think I can solve it without the list monad
17:35:05 <copumpkin> you shouldn't need the list monad
17:35:14 <mreh> it was just a thought to make a filter easier
17:35:15 <copumpkin> that gives you nondeterminism
17:36:15 <mreh> yeah, I
17:36:24 <mreh> 'm using the wrong abstraction if I use list monad
17:36:30 <napping> ah, it's blocking in killThread
17:36:35 <napping> why would killThread block?
17:36:39 <mreh> I also need to learn to type on this new keyboard
17:36:45 <tehgeekmeister> trying to install the haskell platform on karmic koala, 64 bit, the make command seems to have hung in the linking phase.  anyone run into this/know what it might be?
17:36:47 <mreh> netbooks...
17:37:05 <benmachine> napping: I think it only returns when the exception is delivered
17:37:11 <napping> I know it's synchronous, but the worker is just doing hGetByf and chucking results onto a chan
17:37:17 <benmachine> but I don't know why an exception would be delivered slowly
17:37:32 <napping> unless hGetBuf isn't interruptible on windows? But that makes no sense - it's the IO worker doing the waiting
17:38:17 * BMeph is disturbed that Haskell isn't improving his skills, just making him more impatient with "imperative" programmers getting lost in the weeds of stack frames, dispatch and register-saving during context switching...just Program, huh?!?
17:39:09 <napping> ok, throwTo a dead thread is prompt
17:39:27 <mreh> BMeph, loose the dead weight
17:40:24 <BMeph> mreh: The "dead weight" is a community, of fifty-three million... :(
17:40:46 <mreh> I remember a conversation I overhead, someone in management was saying "these African programmers I spoke to really understand programming better, this guy was talking as if his variables and methods were people, it was really amazing!"
17:42:02 <mreh> BMeph, we can make it on our own!
17:42:04 <kmc> hahaha
17:42:18 <patch-tag> BMeph: I'm with you there
17:42:19 <napping> Hmm, I might need to rethink the exception throwing strategy
17:43:14 <napping> I have a callback function which should have a lazy list of data recieved on the socket, but also get an asynchronous exception when the socket closes
17:43:21 <mreh> How do you tell someone in management you think what they said was a stupid idea?
17:43:32 <mreh> I usually go with "That's an excellent idea!"
17:43:39 <patch-tag> mreh: "criticism sandwich"
17:43:47 <copumpkin> omnom
17:44:06 <mreh> patch-tag: recipie?
17:44:13 <mreh> good bad good?
17:44:19 <patch-tag> mreh: I really liked blue, I noticed that purple raises some issues. We need to think about that. Green I really like.
17:44:47 <patch-tag> yes
17:44:56 <mreh> I like your glasses, I'm really concerned because you clearly know nothing about programming, but that is a really nice shirt, where did you get it?
17:45:44 <patch-tag> mreh: yes, except you should stick to the issue in part b and not go ad hominem
17:45:51 <patch-tag> doesn't matter if they don't understand the issue.
17:46:00 * BMeph prefers the point-and-laugh method
17:46:07 <patch-tag> bmeph: also that
17:46:14 <mreh> we don't have social skills in #haskell
17:47:05 <Mitar> how can i read characters directly from a console without requiring users to press enter?
17:47:18 <napping> Mitar: turn off buffering
17:47:31 <Mitar> that is? just gSetBuffer?
17:47:38 <Mitar> s/g/h/
17:47:46 <napping> NoBuffering, yes
17:48:12 <Mitar> hm, but will i able to read also key ups and key downs, arrows?
17:48:27 <napping> you'll read whatever comes on the console
17:49:05 <napping> So, my code spawns a worker thread that reads from the socket and pushes chunks onto a chan, and throws an exception back at the main thread at EOF
17:49:17 <Mitar> is there any module which would translate this for me?
17:49:39 <raceRider> how do i process a list to get a new list that shows the differences between terms, n2-n1, n3-n2....so on
17:50:06 <Botje> raceRider: zipWith (-) (tail list) list
17:50:14 <napping> The main thread keeps exceptions blocked, calls into the callback which might do blocking things, and kills the waiting thread
17:50:26 <napping> kill the worker before re-enabling exceptions
17:50:29 <raceRider> Botje, thanks, let me try that
17:50:49 <napping> but there's not a race, the browser is not closing the connection
17:54:11 <BMeph> > ap (zipWith subtract) tail [0,1,3,6,10,15,21,28,36,45,55]
17:54:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:54:28 * BMeph is full of "WIN!" ;p
17:54:47 <mreh> wtf is that?
17:55:17 <BMeph> It's my "Awesome!" button. Go ahead, push it, you know you want to.,.. ;p
17:55:28 <mreh> I am afraid to
17:55:44 <copumpkin> it's subtracting adjacent elements
17:55:59 <syntaxglitch> BMeph, going to calculate polynomials by successive differences?
17:56:06 <Alpounet> BMeph, haha, like the red pill in Matrix
17:56:50 <Alpounet> BMeph, more seriously, I often write the equivalent of wc -l or a basical grep to show the conciceness and expressiveness of Haskell
17:57:11 <Alpounet> conciseness* (if such a word exists, btw)
17:57:41 <syntaxglitch> I suggest "concision"
17:57:51 <Alpounet> thanks.
17:58:35 <syntaxglitch> conciseness works too, but doesn't sound as dramatic :P
17:58:37 <napping> Oh, http://trac.haskell.org/network/ticket/2
17:58:45 <Alpounet> syntaxglitch, hah ok
17:59:46 <Alpounet> damn, hackage grows so quickly
18:00:21 <tensorpudding> damn coders, writing so much haskell code
18:00:34 <tensorpudding> if they keep this up haskell might go mainstream
18:00:56 <syntaxglitch> wouldn't that be going against the language's core principles?
18:01:17 <tensorpudding> i think one of them was somewhat of an admonition against that
18:01:39 <Alpounet> syntaxglitch, you might even be able to find these words in the report :-p
18:01:51 <Alpounet> if it isn't written there, it's probably implicit
18:02:43 <syntaxglitch> I'm recalling a quote like "avoid success at all costs", something SPJ said I think
18:02:48 <syntaxglitch> don't remember where from, though.
18:03:04 <syntaxglitch> I don't know how well that's working out these days :\
18:03:32 <gwern> HTML gurus! I beseech thy aid! how would I programmaticaly enter URLs into the 'crawl my site' button on http://www.alexa.com/help/webmasters ? there doesn't seem to be any URL pattern I can substitute into
18:04:10 <Raynes> tensorpudding: Let's rewrite the universe in Haskell. Show God what we're made of.
18:05:04 <benmachine> gwern: it's a post form, so you can't do it just by requesting a URL
18:05:15 <gwern> benmachine: hm. how would I do it in haskell, then?
18:05:16 <napping> well, I'd forgotten the old withSocketsDo - not that that's fixed everything.
18:05:27 <BrianB04> Has anyone here worked with any of the GUI toolkits for Haskell?
18:05:30 <benmachine> there are a few modules which will happily do post requests
18:05:45 <napping> or anything
18:05:46 <benmachine> my laptop's currently trying to install ubunut 9.10 but I'll fetch something I did for that in a sec
18:06:13 <benmachine> (not that I ever use ubuntu, but...)
18:07:00 <syntaxglitch> BrianB04, I've used the SDL bindings... does that count? :P
18:07:53 <BrianB04> syntaxglitch: It counts, but not what I'm looking for
18:08:09 <gwern> benmachine: the curl hackage page mentions 'HTTP POST'
18:08:20 <benmachine> the curl package I recall being a bit nasty to use
18:08:24 <benmachine> the HTTP package shoudl do fine
18:08:28 <syntaxglitch> BrianB04, yeah, didn't think it would help much...
18:09:09 <syntaxglitch> gwern, anything that can be an HTTP client ought to provide basic POST functionality
18:09:39 <gwern> sure, but that doesn't tell me how I would actually do it :)
18:09:40 <BrianB04> syntaxglitch: I may eventually need SDL, who knows. Maybe I can build my own version of Shoes using SDL.
18:10:16 <syntaxglitch> you could either inspect the markup or get something that spies on HTTP requests (I think Firebug will do that?) to see what to send in the POST
18:10:29 <benmachine> gwern: try formToRequest: http://hackage.haskell.org/packages/archive/HTTP/latest/doc/html/Network-Browser.html#v%3AformToRequest
18:10:54 <benmachine> oh hold on the upgrade is done
18:11:02 <gwern> benmachine: looks good, but what's a Form? :) the docs say nothing
18:11:06 <gwern> to the source repo!
18:11:42 <syntaxglitch> probably represents an html form, e.g. a collection of input-y controls whose values get stuffed into POST requests
18:11:45 <benmachine> gwern: the constructor's pretty simple
18:12:23 * gwern enables firebug and waits
18:13:50 <gwern> (gosh, firebug really does slow things down)
18:16:30 <benmachine> huh, this is a lot more complicated than I remember
18:16:48 <benmachine> gwern: http://unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=5391#a5391 most of this is irrelevant to your purposes
18:16:49 <BrianB04> gwern: Not only does it slow things down, it can cause odd bugs.
18:17:00 <benmachine> but it gets a form and responds to it
18:17:01 <gwern> benmachine: ok, I foudn the part in firebug showing the post request
18:17:16 <gwern> I think
18:17:39 <syntaxglitch> gwern, it should be just some fairly simple request parameters
18:18:04 <benmachine> if you already know the form elements and stuff then you can do it a lot simpler than I did
18:18:11 <gwern> ergh, g2g
18:18:12 <benmachine> I'll try to make something interesting and annotate my paste
18:18:18 <benmachine> okay
18:18:25 <benmachine> well, formToRequest is interesting
18:18:38 <syntaxglitch> I like the comment in the code
18:18:46 <syntaxglitch> "this junk is completely untested..."
18:18:49 <syntaxglitch> :D
18:19:36 <benmachine> you make a form with the Form POST (fromJust $ parseURI string) [("key", "value"), ...]
18:20:26 <gwern> turns out ginger-flavored currant wine is pretty bad
18:20:30 <gwern> now where was I
18:21:59 <BrianB04> Oh, one other question I have: How bad is ++ really?
18:22:10 <benmachine> depends where and how you use it
18:22:41 <sjanssen> BrianB04: code that uses it a whole lot is probably not great Haskell code
18:22:52 <gwern> so let's see, 'request . formToRequest $ Form POST (fromJust $ parseURI "http://www.alexa.com/help/crawlrequest") [("submit url", url)]
18:22:57 <gwern> @src (++)
18:22:58 <lambdabot> []     ++ ys = ys
18:22:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:22:58 <lambdabot> -- OR
18:22:58 <lambdabot> xs ++ ys = foldr (:) ys xs
18:23:14 <gwern> BrianB04: O(n) looks like
18:23:28 <c_wraith> BrianB04: it has to make a copy of the left argument.  That can get bad, if you do it a lot.
18:23:31 <syntaxglitch> what's the problem with ++? I expect it has terrible time complexity, but anything else?
18:23:39 <gwern> syntaxglitch: looks lazy too
18:23:43 <syntaxglitch> ah
18:23:49 <sjanssen> syntaxglitch: the problem is that it is often misused
18:23:52 <BrianB04> gwern: That was my guess, but I haven't seen the offical definition of ++, only the one shown in the Peyton talk.
18:23:53 <gwern> so expect lots of thunks and stack overflows in large cases
18:23:58 <sjanssen> gwern: no
18:24:16 <benmachine> if you use ++ to prepend to a list it's not that bad
18:24:17 <sjanssen> (++) is pretty stack overflow safe
18:24:30 <benmachine> if you use it to append to a list it can be slow, but there are worse things you can do
18:24:31 <sjanssen> shortlist ++ longlist is okay
18:24:35 <napping> There is at mose one thunk at a time from the ++
18:24:44 <BrianB04> In that talk, it was shown basically as a recursion over list of xs, then a cons of that onto the list of ys.
18:24:58 <sjanssen> longlist ++ shortlist -- this is bad, and Haskell newbies tend to do it a lot
18:24:59 <ben> How does the number of thunks correspond to stack size?
18:25:16 <copumpkin> ben: nesting of thunks gives you big stack
18:25:17 <benmachine> gwern: you get the URL for the form from the <form> elem on the page
18:25:25 <syntaxglitch> sjanssen, the old "incrementally concatenate strings from left to right" mistake?
18:25:26 <ben> How do you nest thunks?
18:25:39 <napping> If forcing a thunk requires evaluating another thunk that happens on a stack
18:25:43 <napping> which may overflow
18:25:52 <copumpkin> ben: 1 + (1 + 1)
18:25:55 <benmachine> gwern: it looks like here that's /edit/crawlrequest, not /help/... and the key for the form is "url"
18:25:59 <sjanssen> syntaxglitch: yeah, foldl (++) vs. foldr (++)
18:26:03 <napping> something like (iterate (+1) 1 !! bignum)
18:26:14 <copumpkin> we need an iterate' :P
18:26:15 <napping> + is strict so it forces the argument thunk
18:26:18 <gwern> benmachine: odd. firebug says clearly 'submit\nurl'
18:26:22 <benmachine> (does anyone know how I can disable an irssi highlight for a specific channel? /me glares at ben)
18:26:34 <ben> Basically the amount of thunks until I hit a constructor?
18:26:37 <copumpkin> benmachine: fail
18:26:43 <ben0x539> Sorry
18:26:46 <napping> yeah, that's about right
18:26:47 <benmachine> gwern: hmm, there's a submit button as well which might get involved somehow
18:26:57 <benmachine> ben0x539: nooo don't leave that name
18:27:04 <benmachine> it's a good name!
18:27:08 <benmachine> which is why I highlight on it
18:27:24 <napping> doesn't it just highlight on your name?
18:27:27 <ben0x539> benmachine: I will get around to using it again when I am not talking in a channel that you are in :)
18:27:30 <Alpounet> yep
18:27:46 <benmachine> ben0x539: I'm um always here
18:27:51 <benmachine> as you should be
18:28:04 <benmachine> so change it back I will just turn highlight off it doesn't matter ok
18:28:11 <gwern> benmachine: ah, I needed 'browse . request'
18:28:19 <benmachine> gwern: oh, yeah
18:28:44 <benmachine> gwern: or you might be able to use simpleHTTP
18:28:54 <benmachine> instead of browse . request
18:29:08 <benmachine> or you might find that's not any better
18:29:10 * benmachine shrugs
18:29:13 <gwern> the latter gives me more debug info right now
18:29:22 <benmachine> k
18:30:01 <gwern> hm. both '/edit/crawl' and '/help/crawl' give me lots of output
18:30:38 <benmachine> you could try saving it to a file and then opening it in firefox?
18:30:52 <benmachine> when I tried entering something in there, it took me to a login page
18:31:00 <BrianB04> I finally managed to get over the bump I ran into when dealing with type constructor vs value constructor...now monads.
18:31:10 <gwern>  http://www.alexa.com/help/crawlrequest is a regular page on its own
18:31:45 <gwern> benmachine: save what to a file?
18:32:03 <benmachine> gwern: never mind, I misunderstoof
18:32:06 <benmachine> oof.
18:33:00 <gwern> let url = "http://gitit.net" in browse . request . formToRequest $ Form POST (fromJust $ parseURI "http://www.alexa.com/edit/crawlrequest") [("submit", url)]
18:33:03 <gwern> seems to work
18:34:01 <benmachine> I'm a little surprised but if it works it works
18:34:26 <gwern> although I'm bothered that the 'thanks' page never seems to show up
18:34:34 <benmachine> (surprised because the formvars look strange, don't think the key in the form is "submit")
18:34:40 <benmachine> show up? where are you expecting to see it?
18:35:11 <gwern> benmachine: I'm expecting to see it at the very end
18:35:18 <benmachine> of?
18:35:26 <gwern> since in firefox you click the button and end up on /crawlthanks or whatever
18:35:40 <benmachine> oic
18:35:47 <benmachine> are you sure it's actually working?
18:36:00 <benmachine> (have you done setAllowRedirects True?)
18:36:37 * gwern looks at the body, using 'fmap (rspBody . snd)' at the front
18:37:01 <gwern> looks like a login form...
18:37:05 <gwern> zut
18:37:07 <napping> this socket code is just not working right on windows
18:41:19 <gwern> nope, setAllowRedirects doesn't seem to have helped
18:42:22 <benmachine> if it is a login form that suggests you need to login?
18:43:43 <gwern> no, it doesn't require login!
18:43:50 <gwern> you can try it yoruselv, it's a public form
18:44:28 <gwern> http://www.alexa.com/help/webmasters as I said
18:45:34 <Mitar> uhhh, type help please! I have "type NXT = StateT NXTState IO" defined and a function "processKey :: IO Event -> NXT ()" and I would like to do something like "finally (processKey geyKey) shutdownTerm", where getKey has "IO Event" type, shutdownTerm has IO () type and I am calling this in NXT () context ... of course types mismatch .. how can i solve this?
18:45:35 <benmachine> well, I'm going to bed, but that'd suggest to me that you're sending the wrong data or to the wrong place or some such
18:45:54 <gwern> bleh
18:47:27 <gwern> maybe the referer is the problem
18:47:41 <gwern> the raw form at http://www.alexa.com/help/crawlrequest does ask you to log in
18:47:53 <Alpounet> do we have something equivalent to Erlang's actors in Haskell ?
18:48:09 <DigitalKiwi> someone said ghc can't cross compile currently, a. are there plans for it to b. are there other compilers that do?
18:48:19 <Cunbuntu> Tired of Negroes and their monkeyshines?  Join us on Chimpout Forum!  At Chimpout Forum we are NOT WHITE SUPREMACISTS.   Chimpout Forum welcomes the rainbow diversity of the human race with open arms, including Asians, non-negroid Hispanics, Semites, Jews, Whites, Indians, Native Americans, Turks, Polynesians, Saami, etc.  Basically we welcome anybody who isn't a fecal-colored niggroid AFRICOON!  Join us in the epic battle of HUMAN
18:48:19 <Cunbuntu> S VS NIGGGGGGERS!  http://www.chimpout.com/forum
18:48:30 <DigitalKiwi> not this guy again :/
18:48:48 --- mode: ChanServ set +o mauke
18:48:48 --- mode: mauke set +b *!*@201.170.62.243.dsl.dyn.telnor.net
18:48:56 <gwern> saami?
18:49:30 <gwern> oh, Lapps
18:49:48 <DigitalKiwi> mauke: how do you do the "reuested by mauke" instead of kicking them?
18:49:48 --- mode: mauke set -o mauke
18:49:56 <tehgeekmeister> anyone encountered problems with ghc hanging during linking specifically on 64 bit linux (had the problem so far in both ubuntu and arch)
18:50:13 <Mitar> no
18:50:33 <tehgeekmeister> (and it's only been on some builds, too.)
18:50:38 <mauke> DigitalKiwi: REMOVE instead of KICK
18:50:45 <DigitalKiwi> ahh, thanks
18:51:57 <BMeph> Mitar: 'lift shutdownTerm' is my suggestion. My suggestions are usually badly wrong, though, so caveat lector... ;)
18:52:09 <Mitar> hmm, yes
18:52:54 <BMeph> Mitar: Hmm, no that can't work, 'cause you'd have to lift finally, too... Never mind. :\
18:53:19 <Mitar>           (liftM2 finally) (processKey geyKey) (liftM $ shutdownTerm)
18:53:25 <Mitar> i am trying something like this
18:53:55 <Mitar> and i am getting     Couldn't match expected type `IO a' against inferred type `()'
18:54:57 <Mitar> hmm, hpaste is not working?
18:55:26 <BMeph> Mitar: 'lift', not 'liftM'. :)
18:55:48 <Mitar> and is there lift2?
18:55:55 <Mitar> hmm, what is the difference?
18:56:11 <Mitar> and what is difference between lift and liftIO?
18:56:22 <ben0x539> The types
18:56:44 <holmak> :t liftIO
18:56:45 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
18:56:53 <holmak> :t lift
18:56:54 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
18:57:23 <copumpkin> Mitar: liftIO is a special lifter that can jump through multiple layers of transformerness
18:57:56 <Mitar> and is there lift2?
18:57:58 <tehgeekmeister> it's hung now three times in a row at the linking phase just in building happstack.  what do i do to report this/work on getting it fixed?
18:58:40 <DigitalKiwi> http://codepad.org/?lang=Haskell Mitar runs code too =D
18:58:49 <c_wraith> Mitar: lift and liftM are very different.  lift2 wouldn't make sense.  Unlike liftM2
18:59:24 <ben0x539> lift is basically liftM0
18:59:35 <Mitar> hmm, ok, so how can i fix this?
18:59:39 <DigitalKiwi> (you just have to define main iirc)
19:00:23 <c_wraith> ben0x539: that's not really true.  lift has to do with monad transformers.  liftM works with any monad.
19:00:46 <Mitar> http://codepad.org/NyCPsZoE
19:01:27 <Mitar> http://codepad.org/dN8nfWyQ << with NXT type
19:01:47 <Mitar> io == liftIO
19:02:01 <Veinor> http://i.imgur.com/Ge1hS.jpg
19:02:09 <Mitar> http://codepad.org/xQaBy037
19:02:34 <Saizan> tehgeekmeister: complain to binutils?
19:02:39 <mreh> random choice of a list in a functional way?
19:02:58 <mreh> coin flips on a infinite cycle of a list is the best I came up with
19:03:03 <HaskellLove_> "Assembly languages belong to the unpleasant category of untyped unsafe languages." What does that mean? I mean, some assemblers are typed, that is, you can make variables of certain types like int, float, string or whatever.
19:03:18 <tehgeekmeister> Saizan: it happens during what ghc is claiming is the linking phase, but my guess would be it's actually a ghc problem right before or after the linking.
19:03:59 <tehgeekmeister> Saizan: of course i don't know that without stracing and ridiculous things like that, i'm really just looking for a work around.
19:04:17 <Saizan> tehgeekmeister: what does -v says?
19:04:28 <tehgeekmeister> ghc or cabal?
19:04:32 <tehgeekmeister> i was using cabal for the build
19:04:41 <Saizan> cabal works too
19:04:56 <Saizan> maybe -v2 or -v3
19:05:24 <Saizan> linking time can be quite bad, especially if you don't have much memory
19:05:37 <tehgeekmeister> oh, that may be it then
19:05:44 <tehgeekmeister> i'm used to compiling with 2gb
19:05:51 <tehgeekmeister> the machine i'm on now has 256mb
19:05:55 <mreh> :O
19:05:56 <Saizan> heh
19:06:04 <c_wraith> ouch.  yes
19:06:13 <tehgeekmeister> so i should just be patient?
19:06:25 <mreh> you could go and buy some more memory before it compiles
19:06:26 <c_wraith> 256mb isn't enough to link even medium size ghc code rapidly
19:06:31 <Saizan> i think disabling split objects should help
19:06:41 <Mitar> aaaghh, headache ... those types
19:06:42 <tehgeekmeister> i can temporarily upgrade the ram on my instance
19:06:44 <tehgeekmeister> i'll do that
19:06:56 <mreh> ?!?!
19:06:56 <tehgeekmeister> (yay for virtual servers!)
19:07:00 <mreh> ooh
19:07:04 <mreh> vmware?
19:07:10 <Saizan> but you should do that starting from ghc's ./configure, iirc
19:07:15 <tehgeekmeister> rackspace cloud
19:07:24 <mreh> sounds pornographic
19:07:42 <Veinor> Mr Hu said: "He was really furious, he made the monkeys kneel on the ground with their hands tied behind their backs to punish them and make them show remorse for their nasty attack."
19:08:14 <Mitar>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
19:08:14 <Mitar>     When matching the kinds of `t :: (* -> *) -> * -> *' and
19:08:14 <Mitar>                                `(->) :: ?? -> ? -> *'
19:08:16 <tehgeekmeister> how much ram does one normally need for ghc compiles, for a guesstimate?
19:08:19 <Mitar> really looks nice :-)
19:08:46 <c_wraith> 1 GB should be good for most projects.
19:08:57 <c_wraith> I was seeing 600-700 MB on most of my compiles
19:09:19 <BMeph> 5 Exabytes should do it... ;p
19:09:29 <mreh> tehgeekmeister: I should think it's all relative
19:10:29 <mreh> somewhere between 1mb and 2GB is the best guess I could make
19:10:36 <tehgeekmeister> ...
19:10:51 <HaskellLove_> What does it mean "Economy of language features" for programming languages that are typed?
19:10:53 <tehgeekmeister> i was going to attempt to make a reasonable reply to that, but i just gave up.
19:11:15 <mreh> well you asked "how long is a peice of string"
19:11:20 <mreh> so I gave you a reasonable response
19:11:58 * tehgeekmeister sighs
19:13:07 <mreh> and then comes execution
19:13:42 <tehgeekmeister> i probably need more ram anyway.  i'm just being cheap.
19:13:49 <tehgeekmeister> cheaper than i should be.
19:14:09 <mreh> if you're running your own rackspace cloud, you must be loaded
19:14:26 <mreh> otherwise just ask your boss for more
19:14:34 <Alpounet> Cale, your "swing" thing is kinda fun
19:14:47 <tehgeekmeister> it's really well priced for the small instances, but the larger ones get spendy quick.
19:18:06 <tehgeekmeister> mreh: unless you know of some way to get a decent server for <40 a month?
19:18:30 <mreh> no, sorry
19:18:46 <mreh> what is it you're doing?
19:19:43 <tehgeekmeister> just going to be running some small web apps, they won't need much in the way of ram to run from what i can tell, but since i'm using happstack and various other things, i need root access.
19:19:49 <tehgeekmeister> (and apparently more ram for my builds.)
19:21:24 <Mitar> help, help ..
19:22:02 <tehgeekmeister> yeah, more ram fixed it.
19:22:59 <mreh> linking is the killer normally
19:23:12 <Saizan> i guess building locally is problematic?
19:23:13 <mreh> why dont you look into dynamically linking the big stuff
19:23:57 <mreh> you could even cross compile it on a better machine
19:24:21 <tehgeekmeister> i considered cross compiling, but on the other hand with happstack keeping all state in memory, i'll end up needing to have more than 256mb ram anyway
19:24:26 <tehgeekmeister> so i may be okay with that
19:24:42 <tehgeekmeister> i don't know a thing about dynamically linking it, other than that it makes sense that could help.  i'll look into that.
19:24:43 <tehgeekmeister> thanks
19:25:04 <mreh> it makes compilation faster, that's all
19:25:20 <mreh> and you get smaller binaries
19:25:23 <tehgeekmeister> right
19:25:29 <Mitar> could somebody look at this: http://codepad.org/xQaBy037
19:25:30 <Mitar> ?
19:25:32 <Mitar> please
19:25:59 <mreh> gah, StateT, no thanks
19:26:06 <mreh> good luck ;)
19:26:33 <mreh> > [-1..1]
19:26:35 <lambdabot>   [-1,0,1]
19:26:58 <mreh> > [-2..8]
19:26:59 <lambdabot>   [-2,-1,0,1,2,3,4,5,6,7,8]
19:27:04 <Saizan> Mitar: what problem/error are you getting?
19:27:18 <Saizan> ah, finally
19:27:24 <Mitar> yes
19:27:24 <Saizan> ?type finally
19:27:26 <lambdabot> Not in scope: `finally'
19:27:34 <Mitar> i do not know how to lift finally properly
19:27:37 <Saizan> ?ty Control.Exception.finally
19:27:38 <lambdabot> forall a b. IO a -> IO b -> IO a
19:27:49 <Mitar> so I am in NXT () context
19:28:14 <Saizan> shutdownTerm is in IO?
19:28:18 <Mitar> i could do liftIO finally, but I need to keep processKey in NXT
19:28:21 <Mitar> yes
19:28:27 <Mitar> shutdownTerm is IO ()
19:28:35 <Mitar> keyGen is IO Event
19:28:46 <Saizan> ok, liftIO and lift will work only on IO actions
19:29:02 <Saizan> not on functions that accept IO actions (it'll work on their result)
19:29:36 <Mitar> ok, so what will work?
19:29:44 <Saizan> it's a bit delicate
19:29:54 <Mitar> i can change code ...
19:30:05 <Saizan> basically, it'd be better if processKey was in IO too
19:30:15 <Mitar> what i would like to do process key events in NXT context
19:30:28 <Mitar> yes, but then i would loose NXT context, wouldn't i?
19:30:32 <Saizan> yeah
19:30:41 <Saizan> well, there's a way to get both
19:30:42 <Mitar> but that is the whole point :-)
19:30:43 <BMeph> MOAR DOTS!!!!111!!!111
19:30:50 <Saizan> give me a minute
19:30:54 <Mitar> thanks
19:35:01 <tehgeekmeister> anyone know how to get around the template haskell build failure with ghc 6.10.4?  this is part of the error i get; Not in scope: data constructor `CharConstr'
19:35:21 <tehgeekmeister> google finds nothing for this except a build failure log on hackage
19:36:20 <Saizan> Mitar: http://codepad.org/23HPspJh
19:36:35 <Saizan> Mitar: i didn't typecheck it, so ask if it doesn't
19:36:40 <Mitar> ok
19:36:47 <Mitar> just that i get through it :-)
19:37:43 <Mitar> IORefs? but that is ugly ...
19:38:07 <Saizan> tehgeekmeister: are you trying to upgrade the template-haskell package? that's not going to work
19:38:21 <tehgeekmeister> Saizan: cabal is trying to in order to install happstack
19:38:23 <tehgeekmeister> i just want happstack
19:38:51 <Saizan> Mitar: somewhat, but it's almost the only way to tunnel a StateT IO into an IO, so that you can pass it to finally
19:39:14 <Mitar> is it possible to extract current state from main NXT context?
19:39:19 <Saizan> tehgeekmeister: try with --constraint="syb-with-class==0.6"
19:39:37 <mreh> @pl (\o -> (o, c))
19:39:37 <lambdabot> flip (,) c
19:39:43 <mreh> hum
19:39:45 <Saizan> Mitar: get does that
19:39:47 * tehgeekmeister really doesn't like using cabal, but recognizes it as the least evil option
19:39:47 <mreh> which is easier to read
19:39:49 <Saizan> "get"
19:40:07 <Mitar> so that i would do something like liftIO $ finally (runStateT function state) shutdownTerm
19:40:12 <Saizan> tehgeekmeister: what don't you like in particular?
19:40:23 <mreh> can @pl do sections?
19:40:27 <tehgeekmeister> Saizan: i ALWAYS run into errors like this one.  during just about every single build.
19:40:34 <mreh> > (,b) a
19:40:35 <lambdabot>   <no location info>: parse error on input `b'
19:40:39 <mreh> > (,1) 0
19:40:40 <lambdabot>   <no location info>: parse error on input `1'
19:40:47 <mreh> :t (,)
19:40:48 <lambdabot> forall a b. a -> b -> (a, b)
19:40:53 <tehgeekmeister> they are never easy to trouble shoot, and often times i have to try on here/forums for hours/days to get the answer.
19:41:00 <mreh> > (,) b a
19:41:01 <lambdabot>   (b,a)
19:41:08 <Saizan> tehgeekmeister: you use packages with poor maintainers, or that tickle some deficiency in the solver
19:41:27 <Saizan> Mitar: do s <- get; liftIO $ finally (runStateT function s) shutdownTerm
19:41:38 <mreh> @pl (\p -> toInt p >= toInt l && toInt p <= toInt h)
19:41:39 <lambdabot> ap ((&&) . (>= toInt l) . toInt) ((<= toInt h) . toInt)
19:41:44 <tehgeekmeister> i don't use anything really obscure.  happstack, hdbc, hexpat, those are about all i use.
19:41:51 <Saizan> Mitar: though you should also put the resulting state back
19:42:17 <mreh> @pl (\p -> toInt p >= toInt l &&) . (\p -> toInt p <= toInt h)
19:42:18 <lambdabot> (line 1, column 29):
19:42:18 <lambdabot> unexpected ")"
19:42:18 <lambdabot> expecting white space or simple term
19:42:20 <Mitar> in fact no need
19:42:24 <tehgeekmeister> see, now hsp failed.  i love haskell, but i don't like cabal.
19:42:35 <tehgeekmeister> and i understand what you're saying that it could be the maintainer's fault
19:42:36 <Mitar> i am running all this code in evalStateT
19:42:38 <tehgeekmeister> still not fun.
19:42:57 <Mitar> and i am returning ()
19:43:01 <mreh> @pl \p -> (toInt p >= toInt l &&) . (toInt p <= toInt h)
19:43:02 <lambdabot> ap ((.) . (&&) . (>= toInt l) . toInt) ((<= toInt h) . toInt)
19:43:06 <Axman6> http://www.andrewmcdonald.net.au/a-pictorial-guide-to-avoiding-camera-loss/
19:43:08 <Axman6> whoops
19:43:21 <Saizan> Mitar: ah, ok, if that's the last thing you do
19:43:30 <Mitar> yes
19:43:45 <Mitar> otherwise i would need execStateT and collect data from it, don't i?
19:44:02 <mreh> why didn't he just write his email address on his camera
19:44:04 <Mitar> like newstate <- liftIO $ finally (...)
19:44:22 <Saizan> you'd need runStateT and get the new state from the tuple, along with the result, like i do in toIO
19:44:52 <Saizan> but yeah, if the result is (), not much need for that
19:46:04 <Saizan> i guess i could have avoided the IORefs and require the inner action to return the tuple
19:46:19 <tehgeekmeister> Saizan: would these errors be easy for me to figure out on my own if i read up on cabal, or is there more to it than that?
19:47:22 <napping> they are not too hard to fix. Look up the failing package on hackage, and see if other versions will fit
19:47:37 <Saizan> http://codepad.org/iPpAtToC <- like this
19:48:16 <Saizan> tehgeekmeister: once you're able to read the package descriptions it's quite easier, but you also have to know that e.g. template-haskell is not upgradable
19:48:42 <Saizan> actually, i think cabal should refuse to upgrade it
19:48:48 --- mode: ChanServ set +o mauke
19:48:49 --- mode: mauke set -b *!*@201.170.62.243.dsl.dyn.telnor.net
19:49:49 --- mode: mauke set -o mauke
19:51:29 <Mitar> great
19:51:30 <Mitar> that works
19:51:31 <Mitar> state <- get
19:51:31 <Mitar>           io $ finally (evalStateT (processKey geyKey) state) shutdownTerm
19:51:38 <Mitar> thanks saizan!
19:53:48 <Saizan> np
19:53:50 <tehgeekmeister> cabal-install should phone home when builds like this fail, aggregate how often different sorts of errors are occurring, and then people could volunteer on fixing the worst offenders in hackage, rather than everyone having to know the intricacies of cabal.
19:53:55 <tehgeekmeister> well.  at least i can dream.
19:55:04 <Saizan> tehgeekmeister: it can already generate build reports, and the hackage-server in happstack can accept them
19:55:25 <tehgeekmeister> oh, so we're not that far away from being able to do something like that automatically.
19:55:58 <Saizan> i guess it needs some volunteers to finish it up so it can replace the current server
19:56:07 <Saizan> (it's in happstack, btw)
19:56:11 <tehgeekmeister> i just hate situations like this where there's lots of needlessly duplicated work.  i'd rather solve the problem i'm working on
19:56:27 <tehgeekmeister> hahaha, that's sort of a chicken and egg problem
19:56:34 <tehgeekmeister> something like this would make it easier to build happstack
19:56:39 <tehgeekmeister> but since i can't build happstack yet
19:56:41 <tehgeekmeister> =P
19:56:57 <Saizan> what's the problem in particular?
19:57:07 <Saizan> and i guess what we can do is mail maintainers :)
19:57:27 <Tom> I'm getting an error during build about Yi/Prelude.hs and Data.Accessor having duplicate Category Accessor.T declarations.
19:57:57 <tehgeekmeister> next problem was that hsp was using trhsx, so i googled that, found out it's in hackage too, tried to install it, and it says: Failed to load interface for `Prelude':
19:57:58 <aavogt> Tom: duplicate instance declarations?
19:58:04 <tehgeekmeister> it is a member of the hidden package `base-3.0.3.1'
19:58:04 <tehgeekmeister>       it is a member of the hidden package `base'
19:58:22 <Tom> i'm doing a clean install from a scratch computer, arch linux, tried both pacman and cabal install..... aavogt: yes
19:58:37 <Saizan> Tom: use --constraint="data-accessor < 0.2.1"
19:59:02 <Tom> so: cabal install yi --constraint="data-accessor < 0.2.1"  ?
19:59:10 <Saizan> Tom: yes
19:59:29 <Saizan> tehgeekmeister: that's pretty weird
19:59:47 <tehgeekmeister> i thot so too.
20:00:02 <c_wraith> I built happstack recently
20:00:08 <c_wraith> I ran into that error message
20:00:13 <c_wraith> ...  I can't remember how I solved it
20:00:29 <Tom> thanks,, i'll try that,, I figured it was a common issue
20:00:44 <tehgeekmeister> i wonder how many would be new haskellers give up on it because of issues like this?
20:00:45 <Saizan> tehgeekmeister: oh, make it pick the older version
20:01:12 <Saizan> the maintainer deprecated that package by putting up an useless apckage description
20:01:40 <Saizan> so cabal install trhsx-0.2.1 if you want it
20:01:48 <tehgeekmeister> okay, i'll try that.
20:02:05 <Saizan> Tom: yeah, and the maintainers know, they just wait to fix this in the next release
20:02:39 <Saizan> (which i find irritating, actually)
20:03:48 <tehgeekmeister> Saizan: get another error then.  wanna see it or not?
20:03:54 <Saizan> yup
20:04:11 <tehgeekmeister> Could not find module `Language.Haskell.Hsx': <== seems to be the meat of it
20:04:38 <Saizan> yeah
20:04:52 <Saizan> we need to find which version of haskell-src-exts it actually wants
20:05:07 <tehgeekmeister> i thot i had one installed already.
20:05:27 <Tom> uh oh.. now i have template-haskell dependencies... i'll get those
20:05:47 <tehgeekmeister> i saw that fly by during one of my attempts at building happstack, but i'm not sure if it succeeded or not
20:06:09 <Saizan> tehgeekmeister: you need haskell-src-exts-0.2.1 for this, apparently
20:06:17 <Saizan> tehgeekmeister: it's the only version with that module
20:06:51 <Tom> ah, template-haskell fails because CharConstr is not in scope... do i need to use an older version of that too?
20:07:10 * Saizan didn't remember this much breakage on happstack
20:07:20 <tehgeekmeister> Tom: i had the same error just a bit ago, saizan told me how to fix it
20:07:34 <Saizan> Tom: you shouldn't be installing a new template-haskell package, it comes with ghc and can't be upgraded
20:07:41 <tehgeekmeister> tom: Saizan: tehgeekmeister: try with --constraint="syb-with-class==0.6"
20:07:50 <tehgeekmeister> that's what got me past THAT part.
20:07:51 <Tom> roger....
20:07:59 <Saizan> not sure if that works here
20:08:07 <Saizan> Tom: what are you installing? still yi?
20:08:26 <Tom> saizan: yes, yi.. did you add that contraint to install yi or install template-haskell?
20:08:48 <tehgeekmeister> Tom: i'm doing happstack, but it worked for that same error.  saizan's the man who'd know, tho
20:08:52 <Saizan> Tom: it could work adding it to yi
20:09:11 <tehgeekmeister> Saizan: now it complains about hsx being part of the hidden module haskell-src-exts
20:09:23 <tehgeekmeister> Saizan: i run into that one a lot, what do i do in general for that error?
20:09:31 <Tom> lol, no version of syb-with-class satisfies 0.6
20:09:58 <Saizan> tehgeekmeister: in general you should add the package to the build-depends field in the .cabal file
20:10:21 <tehgeekmeister> Saizan: where do i find the cabal file to edit it?
20:10:28 <Saizan> tehgeekmeister: though trhsx-0.2.1 has it already
20:10:43 <Saizan> tehgeekmeister: cabal unpack $package-$version
20:10:57 <Saizan> with just $package and it'll give the latest
20:11:17 <Saizan> Tom: maybe you need to cabal update
20:11:52 <Tom> i am updated
20:12:31 <Saizan> there's http://hackage.haskell.org/package/syb-with-class-0.6 on hackage though
20:12:51 <Saizan> Tom: can you run "cabal install yi --dry-run -v" and paste the log?
20:12:53 <Saizan> @paste
20:12:53 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
20:13:00 <Tom> saizan, sure
20:13:30 <gnut> Could not find module `Distribution.Simple':
20:13:36 <Tom> it's long,, you want a grep'ed version?
20:13:40 <gnut> how do I fix that error when I try to install cabal-install?
20:13:51 <gnut> with the new ghc-6.12.1
20:14:04 <Saizan> Tom: no, full
20:14:29 <Saizan> gnut: you need the darcs version of cabal-install for it
20:15:41 <gnut> oh.. I need the developmental version of darcs?
20:15:54 <Saizan> no, the devel one of cabal-install
20:16:04 <tehgeekmeister> Saizan: could the problem be that i've got ghc 6.10 and am trying to use the latest stuff from hackage?
20:16:55 <gnut> okay. thanks. darcs getting right now
20:16:59 <Saizan> tehgeekmeister: some of the packages have been updated, but e.g. trhsx surely doens't look like one of them
20:17:11 <tehgeekmeister> Saizan: changing haskell-src-exts to haskell-src-exts==0.2.1 in build-depends fixed that
20:17:25 <EvanR> grr wheres the docs for control.concurrent
20:17:38 <EvanR> google leads to broken links
20:17:52 <Tom> Saizan: to avoid clobbering the channel....http://silenceisdefeat.com/~tom/files/   it's log.txt
20:17:55 <Saizan> tehgeekmeister: --constraint="haskell-src-exts == 0.2.1" should do the same thing, fot the future
20:18:07 <tehgeekmeister> Saizan: okay, thanks
20:18:08 <Saizan> Tom: ah, yeah, i meant on a pastebin
20:18:14 <tehgeekmeister> saves having to unpack it
20:18:25 <Saizan> EvanR: http://www.haskell.org/ghc/docs/latest/html/libraries/
20:19:36 <ColonelJ> > foldl' (++) [] (map (map ((*) [1..4])) [1..4])
20:19:37 <lambdabot>   No instance for (GHC.Enum.Enum [[t]])
20:19:37 <lambdabot>    arising from the arithmetic sequen...
20:19:56 <EvanR> thanks
20:21:07 <ColonelJ> :t foldl' (++) [] (map (map ((*) [1..4])) [1..4])
20:21:08 <lambdabot> forall t. (Num t, Enum t, Num [t], Num [[t]], Enum [[t]]) => [[t]]
20:21:50 <ColonelJ> grr why doesn't that work lol
20:22:30 <Saizan> Tom: --constraint="data-accessor < 0.2.1" --constraint="data-accessor-template < 0.2.1.2"
20:22:53 <Tom> Saizan: roger.. trying...
20:23:01 <tehgeekmeister> Saizan: hsp fails now.  http://pastebin.com/m56bd58a8
20:23:09 <Axman6> ColonelJ: what's map ((*) [1..4]) supposed to do?
20:23:30 <Saizan> Tom: i guess -f-template_2_4 in place of the latter constraint should also work
20:23:35 <ColonelJ> make a list of functions that multiply by the respective valuies
20:23:48 <ColonelJ> [mul1,mul2,mul3,mul4]
20:23:51 <Axman6> well, it doesn't :)
20:24:01 <ColonelJ> what does it do?
20:24:06 <Saizan> tehgeekmeister: on parse errors from trhsx i'm quite lost, honestly
20:24:09 <Axman6> nothing, it;s broken
20:24:17 <tehgeekmeister> Saizan: i kinda expected that.
20:24:22 <Axman6> :t map ((*) [1..4]0
20:24:23 <lambdabot> parse error (possibly incorrect indentation)
20:24:25 <Axman6> :t map ((*) [1..4])
20:24:26 <tehgeekmeister> Saizan: that seems to be the maintainers job
20:24:27 <lambdabot> forall t. (Num t, Enum t, Num [t]) => [[t]] -> [[t]]
20:25:01 <tehgeekmeister> perhaps i should wipe all this and get ghc 6.12 and see if it plays nicely with that.
20:25:17 <HaskellLove> Anyone here I can talk to about type theory and language design?
20:25:18 <Tom> Saizan: it's almost done.. i think that worked
20:25:21 <Saizan> maybe on #happs they know more about this?
20:25:29 <tehgeekmeister> good thinking
20:25:41 <Saizan> (assuming they are awake etc..)
20:26:30 <HaskellLove> Saizan what is that channel for, sorry?
20:26:36 <tehgeekmeister> happstack
20:26:49 <tehgeekmeister> Saizan: that doesn't seem to often be the case, which is why i normally come here.
20:27:01 <ColonelJ> :t (*) [5..9]
20:27:02 <lambdabot> forall t. (Num t, Enum t, Num [t]) => [t] -> [t]
20:27:16 <Saizan> HaskellLove: that line about #happs was for tehgeekmeister
20:27:25 <HaskellLove> oh sorry
20:28:01 <Saizan> type theory is quite on topic here
20:28:12 <ColonelJ> :t map (*) [5..9]
20:28:12 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
20:28:16 <ColonelJ> better
20:28:44 <stoop> Hi
20:28:49 <stoop> Is it still the case that "GHC has not yet been updated to understand the assembly output of GCC version 4.3.x. "?
20:29:05 <ColonelJ> :t map (map (*) [5..9]) [10..12]
20:29:06 <lambdabot>     Couldn't match expected type `a -> b'
20:29:06 <lambdabot>            against inferred type `[a1 -> a1]'
20:29:06 <lambdabot>     In the first argument of `map', namely `(map (*) ([5 .. 9]))'
20:29:18 <povman> @quote russa
20:29:18 <lambdabot> No quotes match. You untyped fool!
20:29:22 <povman> @quote russia
20:29:22 <lambdabot> augur says: "does this sentence sound acceptable: more people have been to russia than {I have/me}"
20:29:24 <povman> @quote russia
20:29:24 <lambdabot> augur says: "does this sentence sound acceptable: more people have been to russia than {I have/me}"
20:29:25 <povman> @quote russia
20:29:26 <lambdabot> vegai says: in Soviet Russia, YOU blow up GHC's brain!
20:29:29 --- mode: ChanServ set +o Saizan
20:29:30 <Axman6> stoop: not sure they even use gcc, except maybe as an assembler
20:29:49 <stoop> Axman6, huh?
20:29:56 <ColonelJ> I think map is the wrong function
20:30:02 <Saizan> > zipWith id (map (*) [5..9]) [10..12]
20:30:03 <lambdabot>   [50,66,84]
20:30:06 <Axman6> ColonelJ: what are you trying to do?
20:30:32 <ColonelJ> what saizan just did was close
20:30:54 --- mode: Saizan set -o Saizan
20:31:00 <Axman6> stoop: ghc uses its own native code generator, so it doesn't need to understand gcc's assembly output
20:31:01 <ColonelJ> I want it to apply all of those functions to each element of the second list
20:31:12 <copumpkin> > runZipList (map (ZipList . (*)) [5..9] <*> ZipList [10..12])
20:31:14 <lambdabot>   Not in scope: `runZipList'
20:31:16 <Axman6> i think a list comprrehension would work better
20:31:24 <copumpkin> a parallel list comp?
20:31:25 <Saizan> > (map (*) [5..9]) <*> [10..12]
20:31:26 <lambdabot>   [50,55,60,60,66,72,70,77,84,80,88,96,90,99,108]
20:31:28 <tehgeekmeister> OT but what have people's experience here with clojure/scala been?  good/bad?  i'm thinking of playing with them soon.
20:31:31 <stoop> Axman6, then why would this be in the GHC WiKi?
20:31:38 <Axman6> > [x*y | x <- [1..4], y <- 6..10]]
20:31:39 <lambdabot>   <no location info>: parse error on input `..'
20:31:45 <Axman6> > [x*y | x <- [1..4], y <- [6..10]]
20:31:46 <lambdabot>   [6,7,8,9,10,12,14,16,18,20,18,21,24,27,30,24,28,32,36,40]
20:31:48 <copumpkin> > [x * y | x <- [5..9] | y <- [10..12]]
20:31:52 <lambdabot>   [50,66,84]
20:31:54 <Saizan> > pure (*) <*> [5..9] <*> [10..12] -- applicative style
20:31:55 <lambdabot>   [50,55,60,60,66,72,70,77,84,80,88,96,90,99,108]
20:32:06 <copumpkin> it needs to be in a ziplist
20:32:07 <HaskellLove> can you recommend me any type theory channels?
20:32:13 <copumpkin> HaskellLove: this one, mostly
20:32:15 <Axman6> stoop: why not (*) <$> ...
20:32:18 <copumpkin> HaskellLove: any particular questions?
20:32:29 <Axman6> uhm, Saizan
20:32:43 <copumpkin> Axman6, stoop: it does both :P
20:32:57 <copumpkin> it has a -via-C pathway that uses gcc as a lame assembler, and its own codegen
20:33:03 <HaskellLove> So far just one, but nice to know i can count on you for this. You want private so we dont talk non haskell here or...?
20:33:16 <gnut> how do you get the head branch of cabal-install?
20:33:23 <copumpkin> HaskellLove: nope, type theory is usually considered on-topic
20:33:27 <Tom> Saizan: looks like it worked, but i'm redoing it with --global
20:33:41 <gnut> isn't it just darcs get http://darcs.haskell.org/cabal-install ?
20:34:00 <Axman6> yes
20:34:03 <Saizan> gnut: it is
20:34:14 <Saizan> gnut: it still doesn't build?
20:34:23 <Axman6> i'd make sure you build it with 6.10 before installing 6.12
20:34:27 <gnut> it's giving me that distribution.simple issue
20:34:32 <gnut> Axman6: oh...
20:34:40 <stoop> copumpkin, nod, figured.
20:34:41 <gnut> Axman6: okay. I was trying to build it with 6.12
20:34:48 <Axman6> it can be done, but it's less fun
20:34:52 <gnut> haha
20:35:00 <gnut> yeah. less fun is not as fun
20:35:14 <Axman6> i needed yo modify the bootstrap.sh file to make CABAL_VER=1.8.2 instead of 1.8
20:35:14 <stoop> copumpkin, can I not compile in support for the -via-C pathway?
20:35:25 <copumpkin> stoop: you get it automatically
20:35:28 <copumpkin> -fvia-C
20:35:32 <stoop> copumpkin, can I not compile in support for the -via-C pathway?
20:35:32 <copumpkin> -optc-O3
20:35:54 <stoop> copumpkin, compile ghc, that is, with no support for this feature.
20:35:55 <gnut> Axman6: just that one modification?
20:36:03 <Axman6> i think so
20:36:13 <copumpkin> stoop: oh, I see. I misparsed that :P I thought it was just a negative question
20:36:20 <gnut> oh... let me try that then rather than fix all the links to point back to 6.10
20:36:22 <copumpkin> stoop: I don't think you can leave it out
20:36:30 <stoop> Seems not from configure, either. :-(
20:36:33 <stoop> Oh well.
20:37:17 <HaskellLove> copumpkin: 1. Once you define the types in a formal way with premises and conclusions such as:  Γ∫A    Γ ∫ Array(A), where do you from there? I mean, once you define BNF for example you go to ANTLR for example and code it, but what about the type system? I need short answer so that as I read the paper I have general overview how things work.
20:37:38 <Saizan> gnut: weird though, i'm on 6.12 and i've that module
20:37:59 <copumpkin> HaskellLove: there's no automagic converter from your logic rules to a magic type system like a parser generator :)
20:38:08 <gnut> Saizan: distribution.simple?
20:38:22 <gnut> isn't it part of the sources of the package you're trying to build?
20:38:24 <Saizan> gnut: yeah, i can see it in ghc-pkg describe Cabal
20:38:31 <stoop> copumpkin, what's a good Haskell-related paper for a newbie like me to read (newbie to FP and newbie to type systems)?
20:38:32 <Saizan> no, it's part of Cabal
20:38:47 <gnut> Axman6: I tried modifying bootstrap.sh and changed CABAL_VER to 1.8.2 from 1.8.0 but it didn't do it... I guess I'll fix the links.
20:38:53 <copumpkin> stoop: anything in particular you're after?
20:39:03 <EvanR> HaskellLove: im sure you know that syntax and parsing are not the most signicant parts of making a language, at least not anymore
20:39:10 <Axman6> gnut: i think it may be 1.8.0.2 actually
20:39:15 <ColonelJ> > [x * y | x <- [5..9], y <- [10..12]]
20:39:16 <lambdabot>   [50,55,60,60,66,72,70,77,84,80,88,96,90,99,108]
20:39:17 <gnut> Saizan: yeah. I can see it, too...
20:39:23 <stoop> copumpkin, no, nothing in particular.
20:39:38 <Saizan> gnut: what's the whole error?
20:40:11 <gnut> runghc Setup.hs configure
20:40:11 <gnut> Setup.hs:1:7:
20:40:11 <gnut>     Could not find module `Distribution.Simple':
20:40:11 <gnut>       Use -v to see a list of the files searched for.
20:40:38 <gnut> the 1.8.0.2 change didn't do it.
20:40:54 <gnut> I didn't install ghc-6.12 with a distribution package. I just compiled it via sources
20:41:04 <HaskellLove> copumpkin, ok so there is a type inference algorithm which is basically the type system. This algorithm, can you give me overall sense what is going on? as i said, quick general overview answers is what i need now, so i dont get lost early in specifics without knowing what is going on...
20:41:12 <stoop> copumpkin, something with practicality to it, though.
20:41:27 <Saizan> gnut: are you sure runghc uses ghc-6.12? maybe you could try with ghc-6.12.1 --make Setup.hs
20:41:38 <copumpkin> stoop: hmm, data types à la carte by wouter swierstra is fun. "The Zipper" (another functional pearl) is also pretty neat and easy to understand. In fact, most of the functional pearls out there are pretty easy reading and contain interesting stuff. A lot of conor mcbride's stuff is also fun and interesting. Also, if you want to understand the crazy *morphism stuff people throw around, read the "functional programming with bananas
20:41:38 <copumpkin> lenses, and barbed wire" paper
20:41:57 <gnut> runghc --version returns 6.12.1
20:41:58 <copumpkin> HaskellLove: type checking and inference are closely related but aren't the same thing.
20:42:22 <gnut> Saizan: same error with ghc --make Setup.hs
20:42:22 <stoop> copumpkin, thank you.
20:43:01 <HaskellLove> copumpkin yes of course, should have added type checking above ...
20:43:07 <copumpkin> HaskellLove: basically you have a bunch of rules, and once you've gotten past the (comparatively) easy stage of parsing, you represent your values and functions and whatever in an abstract form that allows you to check whether any of your rules are violated. I'm not sure how to be more specific
20:43:29 <Saizan> gnut: ghc-pkg field Cabal library-dirs gives you a directory, do you have the .hi files corresponding to the modules there?
20:43:42 <copumpkin> HaskellLove: http://en.wikipedia.org/wiki/System_F and http://en.wikipedia.org/wiki/Type_inference might be good starting points
20:44:07 <Saizan> gnut: i.e. you should have a Distribution/Simple.hi in there
20:44:55 <copumpkin> HaskellLove: but before talking about algorithms for type checking and inference, it'd probably best for you to understand http://en.wikipedia.org/wiki/Curry–Howard_correspondence and type systems on a more abstract level
20:45:30 <gnut> Saizan: yeah. Simple.hi is under in /usr/local/bin/ghc-6.12.1/Cabal-1.8.0.2/Distribution
20:45:39 <HaskellLove> copumpkin i am onto reading again will be back, it was enought to hear that no magic happens out of the formal rules :)
20:46:04 <copumpkin> HaskellLove: there's a tome on type systems that's fairly easy to pick up called types and programming languages, by pierce: http://www.cis.upenn.edu/~bcpierce/tapl/ . He also wrote an advanced version with more specific paradigms: http://www.cis.upenn.edu/~bcpierce/attapl/
20:46:30 <HaskellLove> copumpkin yeah i read TAPL now
20:46:50 <ColonelJ> > foldl' (++) [] (map (\x -> map ((*) x) [10..12]) [5..9])
20:46:51 <lambdabot>   [50,55,60,60,66,72,70,77,84,80,88,96,90,99,108]
20:47:04 <copumpkin> HaskellLove: but type systems are effectively logic languages, so you might want to read up on something like prolog too while you're at it
20:47:07 <Tom> alright! I got vi working, leksah working, xmonad with dmenu and xmobar... took me a while
20:47:29 <HaskellLove> copumpkin I have done reading on Prolog and AI in past
20:47:51 <aavogt> what does AI have to do with this?
20:48:09 <gnut> when I move the links to 6.10.4, runghc Setup.hs configure says that it's configuring for cabal-install-0.7.5
20:48:17 <gnut> I thought HEAD branch was at 0.8?
20:48:18 <HaskellLove> aavogt well he mentioned Prolog, so AI has to do a lot with Prolog
20:48:33 <Axman6> copumpkin: congratulations, you just reinvented concatMap/the list monad/list comprehensions :P
20:48:36 <gnut> ghc page says cabal-install needs to be at 0.8 or later
20:48:39 <Axman6> uh, ColonelJ, even
20:48:44 <copumpkin> lol
20:49:13 <aavogt> HaskellLove: do explain why "AI has to do a lot with Prolog"
20:49:22 <copumpkin> ColonelJ: did you figure out what you needed?
20:49:23 <Saizan> gnut: 0.8 will be the next release
20:49:27 <copumpkin> parallel list comprehensions can be quite elegant
20:49:39 <ColonelJ> copumpkin: yeah I was just experimenting
20:49:49 <Axman6> i don't think he wants parallel list comprehensions
20:49:55 <Axman6> could be wrong
20:50:09 <ColonelJ> they seem a good choice for that sort of thing I think
20:50:11 <copumpkin> his original attempt used a zipWith
20:50:18 <ColonelJ> that wasn't mine
20:50:20 <copumpkin> oh
20:50:21 <copumpkin> :)
20:50:33 * Saizan is the culprit
20:50:39 <copumpkin> whoops!
20:50:43 <HaskellLove> aavogt: it is used for AI purposes. Has backtracking, facts and rules system, which is elegant for AI to simulate every day human decision making
20:50:58 <ColonelJ> My ghci doesn't recognize the <*> stuf
20:51:07 <Saizan> import Control.Applicative
20:51:08 <copumpkin> :m + Control.Applicative
20:51:37 <copumpkin> now we need an AI implemented in the haskell type system!
20:52:54 <copumpkin> HaskellLove: anyway, viewed from the curry-howard lens, type inference is rather odd. It basically says, "given a proof of something, what is the most general something that this proof proves?"
20:53:38 <aavogt> @quote flawed
20:53:39 <lambdabot> No quotes match. Take a stress pill and think things over.
20:53:49 <aavogt> @quote inconsistent
20:53:49 <lambdabot> <roconnor> says: I have a proof that Ultrafinitism is inconsistent, but the universe is too narrow to contain it.
20:54:13 <aavogt> @quote inconsistent.*.logic
20:54:14 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
20:54:15 <HaskellLove> copumpkin in other words, given one fact, what is the set of ALL facts it entails?
20:54:33 <HaskellLove> isnt it just uncurry and pattern match brute force?
20:54:58 <aavogt> those are value-level things
20:55:27 <aavogt> and I'm not sure what sort of definition of brute force you are using here...
20:55:59 <ColonelJ> it tries to match against each pattern till it finds one that works
20:56:07 <copumpkin> HaskellLove: more like, imagine you saw a particularly badly written text proof. The author wrote a proof of something but forgot to include what it was he was proving at the beginning and end of the proof. Now you want to figure out what he was trying to prove
20:56:10 <HaskellLove> ColonelJ yep
20:56:11 <ColonelJ> unless you use the magical ! operator
20:56:23 <Axman6> eh?
20:57:02 <ColonelJ> prolog actually tries to disprove the thing you put in
20:57:13 <xerox> What is a good setting for GHCi's prompt that both works with Emacs haskell-mode, and isn't very very long (as it easily becomes after some module imports)
20:57:14 <ColonelJ> it stops when it fails and finds a solution
20:58:02 <HaskellLove> ColonelJ yep, goes down the decision tree, if a path is found to be wrong, it backtracks and tries another path
20:58:51 <ColonelJ> if a path doesn't contain a counterexample rather
20:59:33 <ColonelJ> a counterexample to the opposite of what you put in
20:59:51 <ColonelJ> you can then say you don't like that one and ask it to find another
21:03:03 <Saizan> ColonelJ: yeah, though it end up giving you a witness of the truth of your query, since before starting that the query gets negated
21:03:10 <HaskellLove> Second half of 2011 I plan on to tackle Prolog, first half is for Haskell only...
21:03:18 <HaskellLove> 2010 i meant ^...
21:03:18 <Saizan> (and the query is understood to be existentially quantified)
21:03:59 <ColonelJ> I think prolog is easier to understand, it's a really tiny language
21:04:20 <ColonelJ> knowing how to do useful things with it is a different matter
21:04:37 <copumpkin> HaskellLove: just learn to program in the haskell type system ;)
21:04:40 <HaskellLove> ColonelJ I played with it like a week or so and read lot of AI, but it is much more going on in Prolog i will devote it half year
21:06:11 <kmc> you should implement prolog yourself in scheme, or haskell
21:06:23 <kmc> then you will for sure understand its magic
21:16:31 <copumpkin> you can see (a -> _) and (s -> (_, s)) as the reader and state monads
21:16:45 <copumpkin> are there any other interesting function-like monads?
21:17:05 <aavogt> @unmpl Cont
21:17:05 <lambdabot> Maybe you meant: unmtl unpl
21:17:08 <copumpkin> oh yeah
21:17:10 <aavogt> @unmtl Cont
21:17:10 <lambdabot> err: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
21:17:15 <aavogt> @unmtl Cont a b
21:17:15 <lambdabot> (b -> a) -> a
21:17:17 <copumpkin> I get it :P forgot that
21:17:21 <kmc> well you can church-encode any datatype
21:17:35 <copumpkin> kmc: sure, but something that we don't get otherwise
21:18:27 <copumpkin> I guess the Identity monad fits that too
21:18:41 <opdolio> Any datatype?
21:21:18 <lpsmith> So here's something I've been playing with the past few evenings,  although I don't think I've particularly gotten anywhere with it...
21:21:36 <lpsmith> Is there a call-by-name continuation monad?
21:21:44 <opdolio> Yes.
21:22:19 <lpsmith> and how would you derive such a beast?
21:22:20 <opdolio> Well, maybe not a monad.
21:22:34 <opdolio> There's a call-by-name continuation passing style.
21:22:40 <lpsmith> Yeah,  I know that
21:22:44 <opdolio> Oh, okay.
21:22:47 <Tom> any nano/pico keybindings available for Yi? I saw the package said it was broken, but then again, I've found lots of undocumented behavior so far in my Haskell journey
21:23:00 <opdolio> Yeah, I've never figured out how to make a monad out of it.
21:23:21 <lpsmith> I've been playing with CBN cps to try to come up with a CBN continuation monad
21:23:52 <opdolio> For instance, you need to transform datatypes to make them CBN-aware.
21:24:15 <lpsmith> Right, I was having a little trouble with that.
21:24:40 <lpsmith> Mostly,  I'm just curious if you can have a continuation based lazy state monad
21:25:00 <Axman6> and a hellm of a lot of other things on that site
21:25:06 * Axman6 meant this page: http://www.ministeam.com/acatalog/Bohm_Stirling_Engines_and_Kits.html
21:25:09 <lpsmith> So I was taking the state monad's bind operator and applying the CBN CPS transform on it
21:25:24 <Axman6> whoops, wrong chan
21:25:49 <lpsmith> (Because the CBV CPS transform does derive the bind operator for the continuation passing state monad)
21:27:02 <lpsmith> But,  either I'm doing something wrong,  it doesn't work,  or I'm in the right spot but don't see how to go forward
21:27:28 <opdolio> Couldn't you make lazy state by not currying the continuation?
21:28:15 <opdolio> Or is it not that simple?
21:28:19 <lpsmith> well,  I should clarify "laziness"  here,  not treating state lazily,  but being able to get the result out lazily without using mapCont
21:34:28 <lpsmith> So how exactly do you transform datatypes to go through the CBN CPS transformation?
21:35:04 <lpsmith> Because honestly,  I'd be happy at this point just to demonstrate something specific,  not something generic
21:36:06 <opdolio> data Foo = Con a b c Foo ... ==> data Foo r = Con (K r a) (K r b) (K r c) (K r (Foo r)) ..., I believe.
21:37:14 <lpsmith> yeah,  that looks more plausible than what I was trying to do.
21:37:16 <lpsmith> Hmm
21:38:10 <napping> Is there any way to get laziness rather than just call by name?
21:38:25 <lpsmith> do you have a handy reference for that?
21:41:06 <lpsmith> napping:   laziness is call-by-name plus memoization,  so that you don't recompute things.    Writing things in the continuation passing style allows you to specify an evaluation order:   a single expression will behave the same way under CBV and CBN.
21:41:10 <napping> well, I guess that distinction can be a bit hard to capture even in direct code
21:41:27 <lpsmith> what do you mean? :-)
21:41:41 <napping> between call by name and laziness
21:42:14 <opdolio> No, I only have just a little fooling I did on my own.
21:42:19 <opdolio> http://code.haskell.org/~dolio/haskell-share/CPSN.hs
21:42:35 <sohum> @pl \x -> f x == y
21:42:35 <lambdabot> (y ==) . f
21:42:48 <opdolio> It's hard to find anything on that transformation.
21:44:42 <lpsmith> I agree
21:44:55 <lpsmith> although there does appear to be several papers within the last 2 years
21:45:25 <napping> I was looking at some of the supero stuff a while back
21:45:55 <napping> with simple inlining you can be careful around lets and preserve sharing
21:46:15 <napping> but a CBN CPS transformation seems to totally mess that up
21:46:26 <napping> unless there's a reverse translation that restores sharing?
21:47:39 <napping> why is ScopedTypeVariables required to give signatures on bindings?
21:47:40 <lpsmith> napping:   Danvy has a few papers on direct-style transforms,  I don't know if he studied the CBN case or not
21:47:57 <lpsmith> (but I'm guessing you might already know that)
21:48:13 <napping> hmm, was that about working with ANF?
21:49:09 <lpsmith> @google "Back to direct style"
21:49:11 <lambdabot> http://citeseer.ist.psu.edu/159711.html
21:49:27 <LUke> what's the best way to browse through packages? I've been using the package archive but it seems that Base doesn't have any links to the docs
21:49:30 <opdolio> It's difficult for me to imagine a lazy CPS.
21:49:53 <opdolio> You'd have to make calling a continuation somewhere turn that same continuation elsewhere into a CBV continuation, essentially.
21:50:16 <opdolio> But maybe I'm not imagining hard enough.
21:50:18 <napping> oh, I'm pretty sure I read that but I don't remember what it was about
21:50:19 <raceRider> I want an example of how to use maximumBy on a list with this type: [[Int],Integer] and want to compare on Integer
21:50:27 <napping> opdolio: well, one easy way is just to make memoization explicit
21:51:20 <lpsmith> napping:  but I agree;   I haven't played with the CBN CPS transform much,  but it's weird and very alien to me
21:51:21 <aavogt> raceRider: do you mean [([Int],Integer)]?
21:51:30 <raceRider> yes
21:51:43 <aavogt> @type maximumBy (compare `on` snd)
21:51:44 <lambdabot> forall a b. (Ord b) => [(a, b)] -> (a, b)
21:51:48 <napping> let val cont = read <mycell> (\old -> case old of Memod v -> cont v; Thunk f -> f cont)
21:51:57 <aavogt> @index on
21:51:57 <lambdabot> bzzt
21:52:01 <aavogt> @hoogle on
21:52:02 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:52:02 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
21:52:02 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
21:52:03 <raceRider> oh yes, thanks.
21:52:21 <napping> I was looking into CPS because getting impressive results from supero on string matching requiried rewriting things into a tail recursive form first
21:52:23 <aavogt> no problem
21:53:00 <Cale> Also note
21:53:03 <Cale> @hoogle comparing
21:53:04 <lpsmith> napping:  that may be because you are producing something that's stricter than it was before
21:53:04 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
21:53:10 <napping> It wouldn't work just with any (pattern `isPrefixOf`) string - basically isPrefixOf was rewritten to pass along the position  in the original list that all would all back on
21:53:44 <napping> otherwise there wasn't another version of the original list in scope to benefit from the pattern matching that was going on - but it would be in the continuation
21:53:54 <napping> so I was thinking of CPS, but then what to do with constructor arguments?
21:53:59 <ddarius> opdolio: The trick is to consider how the function space transforms and to think general monads.
21:54:21 <ddarius> opdolio: CbV = a -> b ~> a -> m b,  CbN = a -> b ~> m a -> m b
21:55:36 <opdolio> Yeah, but what about lazy?
21:56:03 <ddarius> opdolio: Lazy isn't nice.
21:56:12 <ddarius> opdolio: For lazy you need state (passing).
21:56:19 <opdolio> Okay.
21:56:56 <ddarius> (The difference between call-by-name and call-by-need is sharing which means nothing in the absence of identity.)
21:57:28 <napping> you don't need especially general state, though
21:57:48 <opdolio> Well, the difference is performance, potentially.
21:57:58 <napping> in particular evaluation never changes a "location" into something with a different normal form
21:58:34 <napping> one trick is keeping let bindings around at the top level, with evaluation rules that preserve sharing
21:58:53 <lpsmith> opdolio:  http://okmij.org/ftp/Computation/Continuations.html#ask-by-need
21:59:01 <lpsmith> Do you understand that one yet?
22:00:07 <napping> actually, maybe the let thing would work with continuations too
22:00:29 <raceRider> Is `on` in prelude or should I import something else? I get a not in scope when I use (compare `on` snd)
22:00:48 <aavogt> Data.Function
22:00:49 <napping> though it does require defining some redexes a bit oddly
22:01:09 <raceRider> thanks
22:01:21 <aavogt> @djinn  on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:01:22 <lambdabot> Cannot parse command
22:01:30 <aavogt> @djinn  (b -> b -> c) -> (a -> b) -> a -> a -> c
22:01:30 <lambdabot> f a b c _ = a (b c) (b c)
22:02:04 <aavogt> well that one isn't what I was looking for
22:02:07 <dolio> lpsmith: I haven't read that, no.
22:02:08 <aavogt> @src on
22:02:08 <lambdabot> (*) `on` f = \x y -> f x * f y
22:02:24 <napping> whoa
22:02:39 <lpsmith> I just found it today or yesterday,   looking at it again I'm not sure how applicable it is to what I want to accomplish...
22:02:47 <napping> I don't think I've ever used an operator section as a pattern variable
22:04:13 <dolio> Does OCaml's lazy stuff use CPS? I kind of figured it doesn't.
22:05:05 <dolio> I'm not sure it does work, though, beyond a Scheme-alike macro.
22:05:40 <lpsmith> I don't honestly know,  I haven't used OCAML that much,  sadly
22:05:56 <dolio> You can probably do that sort of macro with camlp4.
22:05:57 <lpsmith> I know SML better
22:13:51 <raceRider> @src even
22:13:51 <lambdabot> even n = n `rem` 2 == 0
22:43:27 <raceRider> if I do a filter (\(_,y) -> maximum myList) myList to get only those items with max y values, will myList be generated twice? Once for the condition and once for the filter?
22:44:57 <raceRider> filter (\(_,y) -> y == maximum myList) myList      is the correct version
22:46:05 <copumpkin> it won't be generated twice, but it will be kept around
22:46:10 <copumpkin> it will be traversed twice
22:46:12 <ddarius> If myList is a named variable, it will only be calculated once (in typical implementations).  However, the maximum will be re-executed each time through.
22:46:33 <copumpkin> oh yeah, it will get traversed many times
22:48:25 <napping> what cabal version goes with ghc 6.12?
22:48:55 <Raynes> napping: Darcs version until the next release comes out.
22:49:05 <napping> haskell.org says 0.8, but darcs is only 7.5
22:50:22 <napping> thanks, darcs it is
22:50:45 <raceRider> if max would be executed each time, would it better to generate that outside the filter predicate and use a named variable?
22:51:20 <ddarius> raceRider: Probably.
22:52:08 <raceRider> ddarius: I guess I'll have to try it first. myList is 1 million records.
22:52:41 <ddarius> raceRider: Currently your algorithm is O(n^2) where n is the length of myList.  If you lift out the maximum it will be O(n).
22:53:47 <raceRider> ddarius: yes indeed, will do both for comparison
22:56:04 <copumpkin> when you compare, don't compare on a fixed list size :)
23:00:28 <raceRider> copumpkin: why?
23:01:01 <copumpkin> raceRider: because it's an asymptotic difference so if you want to make a comparison, it's probably more revealing to compare on different sizes
23:02:40 <Tom> anyone use yi?  is there a nano/pico frontend?
23:04:19 <raceRider> copumpkin: as in 1 million records vs. 1/2 million records or several orders different?
23:04:50 <copumpkin> raceRider: that should be fine :) if one grows linearly and the other grows quadratically, you should notice it pretty quickly
23:05:03 <napping> at 1 million records O(n^2) is almost certainly slower than O(n)
23:07:18 <c_wraith> you know.  unless there's a constant factor difference around 1 million in favor of the (n^2) algorithm.  Which should be rare.
23:07:55 <napping> anything short of forking out to an interpreter for each element
23:09:56 <napping> has anyone built cabal for 6.12? Looks like I'll have to manually install packages like "network" to get it going
23:10:07 <c_wraith> is there a configure flag for setting the location of the .ghc and .cabal directories?
23:12:32 <c_wraith> I'd really like to have multiple installs at once, but I need to be able to keep those separate if I do.
23:13:22 <roostaj> @src foldl'
23:13:22 <lambdabot> foldl' f a []     = a
23:13:22 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:13:30 <roostaj> @src foldl
23:13:30 <lambdabot> foldl f z []     = z
23:13:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:27:51 <napping> hmm, well it's mostly bootstrapped, but it seems the syb-0.1.0.3 I installed is incompatible with some kind of backwards-compatibility base-3 I don't even want
23:28:05 <c_wraith> ooh.  top-level TH no longer needs $()
23:28:36 <roostaj> @src Int
23:28:37 <lambdabot> data Int = I# Int#
23:28:46 <roostaj> @src I#
23:28:46 <lambdabot> Source not found. You type like i drive.
23:28:49 <roostaj> @src Int#
23:28:49 <lambdabot> Source not found. My pet ferret can type better than you!
23:29:05 <roostaj> @src Bool
23:29:06 <lambdabot> data Bool = False | True deriving (Eq, Ord)
23:29:30 <c_wraith> roostaj: Things ending in # tend to be primitive types that are not implemented in haskell
23:29:39 <roostaj> c_wraith: thanks, was curious
23:30:04 <copumpkin> I# is a regular constructor
23:30:09 <copumpkin> you have its @src :P
23:30:17 <copumpkin> Int# is primitive though
23:30:47 <roostaj> copumpkin: :>)
23:31:00 <c_wraith> If there's only a single data constructor, does ghc generate a tag for it?
23:31:24 <c_wraith> I guess it does in boxed representation.
23:31:32 <copumpkin> yeah, it just a box
23:31:36 <mtnviewmark> isn't that what newtype is for?
23:31:52 <copumpkin> if the strictness analyzer figures that it can strictify it
23:31:57 <copumpkin> maybe it won't always have it
23:32:23 <c_wraith> is State# the ST constructor?
23:32:54 <copumpkin> nope
23:33:16 <copumpkin> ST is just a newtype, and its constructor is ST
23:33:29 <c_wraith> Hmm.  the docs lie a bit, then.
23:33:36 <c_wraith> But it's a forgivable lie
23:33:44 <copumpkin> where?
23:33:45 <copumpkin> newtype ST s a = ST (STRep s a)
23:33:46 <copumpkin> type STRep s a = State# s -> (# State# s, a #)
23:34:06 <c_wraith> Well, the description of RealWorld is incomplete
23:34:19 <c_wraith> admittedly, a complete description of it is impossible.
23:34:37 <copumpkin> no, its value isn't used at all
23:34:42 <mmorrow> type State# s = () -- basically
23:35:12 <copumpkin> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:35:28 <copumpkin> c_wraith: you'll see that ST is basically IO without a hardcoded RealWorld
23:35:41 <napping> I think the strictness analyzer does something special with State#, though
23:35:43 <c_wraith> I read the 94 paper on state threads
23:36:02 <c_wraith> I was more referring to a one-off line in the docs for RealWord, which is very misleading
23:36:11 <mmorrow> napping: it's unlifted too
23:36:12 <copumpkin> what does it say?
23:36:22 <copumpkin> or rather, what's misleading?
23:36:56 <copumpkin> you can more or less think of data RealWorld = RealWorld
23:37:03 <c_wraith> "We never manipulate values of type RealWorld; it's only used in the type system, to parameterise State#."
23:37:09 <c_wraith> Which is true
23:37:21 <c_wraith> But misleading given the signature of stToIO
23:37:47 <c_wraith> Basically, it makes it sound like State# is the constructor for ST
23:38:03 <c_wraith> Which is...  just slightly misleading.
23:38:08 <copumpkin> hm
23:38:22 <copumpkin> stToIO        :: ST RealWorld a -> IO a
23:38:22 <copumpkin> stToIO (ST m) = IO m
23:38:22 <copumpkin> ?
23:38:27 <mmorrow> c_wraith: the only point of (State# s) passing is to express ordering via data-dependencies of successive (State# s) value on one another, so that during optimization/inlining/etc, the ordering is respected since it's encoded this way.
23:38:37 <copumpkin> I still don't see what's misleading :)
23:38:54 <mmorrow> after that, (State# s) values can essentially just be discarded
23:41:08 <c_wraith> Basically, I think the doc for RealWorld shouldn't mention State#, unless it's going to explain it.  As it makes it sound like it's part of ST, rather than an implementation detail that isn't actually important.
23:41:38 <copumpkin> but State# isn't tied to ST at all
23:41:46 <copumpkin> ST uses State# as does IO
23:42:08 <copumpkin> you could use State# too if you wanted to
23:43:01 <c_wraith> So then the ST docs should either say provide a link to further information, or not mention it.
23:43:02 <mmorrow> i think he means that State# is relevant only in ghc's particular implem of the abstract ST monad concept
23:43:18 <copumpkin> I thought the paper was already GHC-specific
23:43:39 <mmorrow> oh, i dunno what we're referring to though..
23:43:39 <c_wraith> the paper is only strongly ghc specific when it talks about the implementation of IO
23:44:01 <c_wraith> But I was initially talking about the Control.Monad.ST docs
23:45:00 <copumpkin> the broken google haskell doc URLs are really annoying
23:45:13 <c_wraith> yeah, everything in my browser history is broken, too
23:50:01 <copumpkin> HaskellLove: are you a type master now?
23:51:14 <copumpkin> I wish there were some high-res versions of the catsters videos all in one place to download
23:51:23 <copumpkin> or at least higher res
23:51:28 <c_wraith> is 6.12 going to default to Integer being from integer-gmp or integer-simple?
23:51:38 <copumpkin> integer-gmp
23:51:50 <copumpkin> integer-simple is a compile-time option for ghc
23:52:03 <copumpkin> (that is, you'd need to recompile ghc if you want to use integer-simple)
23:52:35 <copumpkin> having a topologically sorted list of catsters videos would be nice too
23:52:48 <kmc> gmp is LGPL right?
23:52:55 <kmc> so what's the situation where the license matters?
23:53:17 <copumpkin> well we normally statically link it
23:53:18 <c_wraith> when you're working someplace so terrified of the letters "gpl" that they even ban "lgpl"
23:53:30 <c_wraith> static linking has nothing to do with lgpl, though.
23:53:47 <copumpkin> I thought it meant that if you wanted to statically link to it, you need to distribute your object files so people can relink it
23:53:56 <kmc> ah, that's interesting
23:54:05 <c_wraith> no.  that's how you get around the gpl limitation.
23:54:24 <c_wraith> lgpl only says that you have to distribute changes to you make to the library, regardless of what it's linked to or how
23:54:49 <copumpkin> "Essentially, if it is a "work that uses the library", then it must be possible for the software to be linked with a newer version of the LGPL-covered program. The most commonly used method for doing so is to use "a suitable shared library mechanism for linking". Alternatively, a statically linked library is allowed if either source code or linkable object files are provided."
23:54:53 <napping> and then anyone you distribute the program to has to be able to replace the library with their own version, no?
23:55:05 <napping> yeah, that
23:55:07 <kmc> i see
23:55:26 <kmc> so it's not a problem with dynamic linking, which is how non-Free apps generally work on linux
23:56:27 <copumpkin> then again, I'm quoting wikipedia
23:56:35 <copumpkin> but I've heard that from multiple reasonably knowledgeable sources
23:56:45 <copumpkin> who I assume did not reference only wikipedia :)
23:56:45 <kmc> so has wikipedia
23:57:11 <c_wraith> kind annotations?  What's the syntax for a kind annotation?
23:57:17 <copumpkin> :: * -> *
23:57:26 <kmc> :t (>>=)
23:57:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:57:32 <kmc> ^^^^ kind annotation on quantifier for 'm'
23:58:12 <copumpkin> but as far as I can see, from a practical stand point it means that if you want to release a closed-source app compiled with GHC < 6.12 you have to release your unlinked object files too
23:58:37 <kmc> because shared was not an option
