00:00:01 <Summermute> SamB_XP: You made my day just from the utilities name :-)
00:00:30 <quicksilver> dcoutts: I think MarcWeber has a point. The solution you suggest is a slow one, and involves waiting for other people. "contact author. decide author is awol (wait how long to decide that? 2 weeks). contact libraries list. get no response. contact haskell-cafe. get no response. give up and learn yoga"
00:00:36 <SamB_XP> is greencard actively maintained ?
00:00:37 <mercury^> Unfortunately many haskell functions use the "this2that" naming.
00:00:44 <theclaw> quicksilver: the C version is, essentially, fib(n) { return fib(n-2)*fib(n-1); }, so the haskell interpreter would *somehow* have to infer that from what it gets, but I don't understand how this would be possible
00:00:48 <quicksilver> dcoutts: instead "make brief note on wiki" is a 5 minute job.
00:00:53 <mercury^> I don't know, but it is listed on the GHC page at least.
00:01:10 <quicksilver> theclaw: well, suppose C supports lists, because that's not really the point.
00:01:12 <dcoutts> quicksilver: it's also not especially useful
00:01:17 <burp> (i,j,k,l,...) .. how do I create n-tuples of integers where each number from 1 to n may only occur once in the tuple?
00:01:17 <Summermute> How is Haskell's data structure support - I've downloaded a handful of fairly lengthy PDF books and tutorials, and LISTS seem to be the dominant pedagogical data structure (which I can  understand). But in the real world....
00:01:19 <dcoutts> it doesn't fix it
00:01:31 <quicksilver> dcoutts: it is useful. It spreads information. "oh this doesn't work for someone else as well? I'm not just being stupid"
00:01:32 <MarcWeber> dcoutts: But it tells people how to ifx it
00:01:44 <dcoutts> quicksilver: build reporting would also work for that
00:01:48 <quicksilver> dcoutts: and it gives somewhere for the person who *did* work out how to fix it.
00:01:53 <quicksilver> to put their comments.
00:01:55 <SamB_XP> Summermute: we actually do use a lot of lists
00:01:56 <MarcWeber> dcoutts: Another question: hsql is using throwDyn. Should I rewrite it using extensible extenstions?
00:02:02 <dcoutts> MarcWeber: yes
00:02:07 <quicksilver> theclaw: then fibs is a function which returns a list.
00:02:10 <mercury^> Summermute: lists are indeed very important in structuring many things. You usually try to express recursion through folds.
00:02:11 <SamB_XP> Summermute: but we have things like Data.Map and Data.Set too
00:02:20 <MarcWeber> dcoutts: Now I decide to work on it. Someone else does as well. How do we  meet?
00:02:26 <MarcWeber> dcoutts: Shall I post to haskell-cafe ?
00:02:28 <burp> > [ (i,j,k) | i <- [1..3], j <- [1..3], k <- [1..3], i /= j, j /= k, i /= k ]
00:02:29 <lambdabot>   [(1,2,3),(1,3,2),(2,1,3),(2,3,1),(3,1,2),(3,2,1)]
00:02:38 <dcoutts> MarcWeber: sure, and or tell the package maintainer
00:02:42 <burp> I don't want to specify all i /= j etc.
00:02:47 <burp> as this gets tedious for large tuples
00:02:55 <MarcWeber> dcoutts: package maintainer may be on holiday. I want to get a job done within 3 days or so.
00:03:22 <Summermute> SamB_XP: I have a reasonable CL background, so I'm no stranger to lists; but OTOH, over in Scheme land I've been kind of trying to push things on PLT's typed-scheme vector support. Constant time random access and plus plus more can be a very good thing.
00:03:26 <dcoutts> MarcWeber: you cannot expect the maintainer to make a new release within 3 days
00:03:41 <MarcWeber> dcoutts: I could create my cloned repository and ptu a note on the wiki. If someone else is interested as well he won't miss it.
00:03:52 <dcoutts> quicksilver: the balance I'm worried about is that package authors will complain that distributing via hackage means they loose control of their package and effectively hackage becomes the package homepage, wiki, comment reporting, etc
00:03:53 <jix> Summermute: there are arrays if you need constant time random access
00:03:55 <mercury^> burp:
00:03:56 <Summermute> My current research, such that it is, is also geared toward functional record systems - Cardelli and others.
00:03:56 <SamB_XP> Summermute: oh, we DO have arrays, too
00:03:59 <mercury^> > permutations [1..3]
00:04:00 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
00:04:14 <dcoutts> MarcWeber: good idea
00:04:18 <MarcWeber> dcoutts: In the hsql case the changes will be bigger: I have to update all depending packages as wel usign extensible exceptions then, correct?
00:04:20 <SamB_XP> Summermute: but those are slow to update generally
00:04:22 <dcoutts> quicksilver: do you see what I mean?
00:04:32 <quicksilver> dcoutts: I would prefer that.
00:04:39 <dcoutts> quicksilver: prefer what?
00:04:40 <Summermute> SamB_XP: Do I correctly guess "functional update" ??
00:04:44 <burp> @hoogle permutations
00:04:44 <lambdabot> Data.List permutations :: [a] -> [[a]]
00:04:46 <Summermute> Of  records, that is?
00:04:46 <SamB_XP> Summermute: yeah
00:04:47 <quicksilver> dcoutts: the current situation is a database full of uncontactable package authors who do not reply to emails or comments.
00:04:50 <burp> mercury^: oh, thanks
00:05:00 <quicksilver> dcoutts: I would much rather motivated users had a place to post fixes
00:05:02 <SamB_XP> oh, we don't really have flat arrays of records
00:05:02 <dcoutts> quicksilver: they're not going to read comments on hackage either
00:05:08 <MarcWeber> dcoutts: That's why I'd like to see a wiki like feature. Another issue: What about usage examples?
00:05:14 <quicksilver> dcoutts: then they are useless and I don't care what happens to them (the maintainers)
00:05:17 <HaskellLove> I need a function that will split a string at index 20, and then split the splitted at 20, and then split the splited at 20 until there is nothing to split...I am not good with recursions, can anyone write this with the command splitAt 20 [some arbitrary range] ?
00:05:22 <quicksilver> dcoutts: but I want the users to have the tools to post their fixes
00:05:32 <dcoutts> quicksilver: I think build reporting will make a big difference, it should shame people into fixing stuff :-)
00:05:32 <theclaw> quicksilver: that doesn't make sense, sorry
00:05:38 <MarcWeber> dcoutts: Imagine it takes me 2hours to write a working example because documentation is lacking. How to provide this information to other users?
00:05:43 <mercury^> HaskellLove: use unfold.
00:05:54 <dcoutts> MarcWeber: send in your documentation improvements
00:05:55 <MarcWeber> I could write my own blog ... But then information is distributed all over the www.
00:06:02 <quicksilver> theclaw: OK, you're going to have to explain what you think you've understood so far. I don't even understand which bit you don't understand.
00:06:04 <Summermute> SamB_XP: I don't have a huge problem with that - actually, part of my "research" is looking for folks out in the world trying to come up with analysis to make very expressive functional record operations very fast and memory efficient.
00:06:07 <MarcWeber> dcoutts: Maintainer may be on holidays :)
00:06:13 <HaskellLove> mercury^ please show me how i have no idea :(
00:06:18 <dcoutts> MarcWeber: they'll get your patch when they get back
00:06:33 <mercury^> HaskellLove: have you looked at unfold already?
00:06:35 <MarcWeber> dcoutts: And maintainers are not going to make a new release because some examples have been added.
00:06:44 <SamB_XP> Summermute: I'm sure we have all manner of other data structures, too
00:06:51 <theclaw> quicksilver: would it be possible for you to continue this in a query?
00:07:02 <SamB_XP> those were just the ones I'm most familiar with
00:07:07 <theclaw> quicksilver: there's much traffic here, and I don't think others are much interested in this
00:07:09 <dcoutts> quicksilver: I don't object to providing extra stuff like this on an opt-in basis. But package authors may have their own existing home page, ticket system etc. We do not want to piss them off by duplicating it all.
00:07:10 <MarcWeber> dcoutts: Or does it make sense to upload a new version for documentation changes only? Think about cabal install etc. They all get much more work to find solutions.
00:07:19 <HaskellLove> Mercury^ yes but i cant do it just please show me this time i will learn for future
00:07:23 <mercury^> Yes. Most implementations are decent too, although none is really excellent.
00:07:30 <jmcarthur_work> what is the proposal for hackage? comments? more than that?
00:07:33 <MarcWeber> dcoutts: And think about how teh hackage index will grow just because of many small fixes.
00:07:39 <SamB_XP> and there are, in fact, imperative arrays, but you of course need to write imperative code to use them ...
00:07:41 <Summermute> I feel bad that I can't recall the geniuses name, but a (Japanese?) gentleman wrote a fairly "canonical" book on functional data structures.
00:07:49 <dcoutts> MarcWeber: in principle we could allow docs to be re-uploaded later
00:07:53 <SamB_XP> Summermute: okasaki
00:08:00 <davidL> > unfoldr (\x -> if null x then Nothing else Just $ splitAt 20 x) [1..]
00:08:02 <SamB_XP> I wish I could find my copy :-(
00:08:02 <dcoutts> MarcWeber: but again I worry about who controls that
00:08:08 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],[21,22,23,24,25,26,27...
00:08:22 <quicksilver> theclaw: sure.
00:08:32 <Summermute> SamB_XP: Yes!  Ijust have to image there's a Haskell source version of his algorithms and data structures out in the world :-)
00:08:35 <MarcWeber> dcoutts: That's the point. If you have a wiki you know that everyone can edit it. You know that it may be worng. But you know that it may also help you if you have a problem.
00:08:55 <dcoutts> quicksilver, MarcWeber: so I think the principle should be that package authors get to decide if they want this stuff
00:08:56 <jmcarthur_work> oh, a wiki?
00:09:06 <SamB_XP> dcoutts: how about an opt-out system where they provide a URL to their own wiki?
00:09:20 <dcoutts> SamB_XP: oh, sneaky :-)
00:09:34 <SamB_XP> and if it goes 404, the Hackage wikipage is allowed again ;-P
00:09:39 <MarcWeber> dcoutts: No. This won't work in the Interlude case.
00:09:42 <jmcarthur_work> i was just thinking if they would rather people use their own wiki instead of a hackage wiki just post a link to it on the hackage wiki
00:09:54 <dcoutts> MarcWeber: why?
00:10:14 <MarcWeber> Because I already sent an email to the author. No reply yet. Maybe it receive one in one week maybe never. I don't know
00:10:25 <quicksilver> dcoutts: As long as its opt-out, not opt-in, sure.
00:10:39 <dcoutts> MarcWeber: if the package maintainer has gone awol then it's time to get a new maintainer
00:10:41 <quicksilver> it's important to remember that the community is more important than the author
00:10:46 <Summermute> SamB_XP: mercury^ - Last q - are there some good, only if toy, example of "os environment entangled" Haskell apps out there on some Wiki or other?
00:10:57 <MarcWeber> dcoutts: But until you know it other people will fail using that library
00:11:00 <dcoutts> MarcWeber: I'm not especially interested in features to let packages limp along without a maintainer
00:11:00 <Sadache> why transpose function is not implemented using zip?
00:11:28 <jmcarthur_work> @src transpose
00:11:28 <lambdabot> transpose []             = []
00:11:28 <lambdabot> transpose ([]   : xss)   = transpose xss
00:11:28 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
00:11:36 <mercury^> Summermute: I suppose you can call xmonad something like that.
00:11:38 <dcoutts> quicksilver: but the authors put stuff up in the first place, if we take over too much they'll got elsewhere
00:11:39 <SamB_XP> dcoutts: well, this might be useful for helping people figure out that the maintainer is MIA
00:11:47 <Summermute> Whoops - one more last Q - Is there good support for building parsers/lexers ????
00:11:53 <Berengal> Sadache: Because you can't
00:11:58 <mercury^> Summermute: yes, Parsec.
00:12:12 <Summermute> Great, I'll check those out. Thanks much to all
00:12:12 <Veinor> yes, parsec is supposed to be very good.
00:12:16 <jmcarthur_work> Summermute, great support. one of the best supported kind of library :)
00:12:19 <Berengal> Or can't easily...
00:12:21 <jmcarthur_work> even the non-parsec ones
00:12:28 <Summermute> LALR?
00:12:37 <Veinor> we loves us some parsing
00:13:02 <Summermute> Newfangled combinator (to this old bird) / patrac?
00:13:07 <fasta> MarcWeber, I think a blog is a good solution with a patch associated to it. You can also just fork the package via github for example announced on Haskell Cafe. Basically, you want to avoid the lag of waiting for the maintainer.
00:13:14 <dcoutts> SamB_XP, quicksilver, MarcWeber: there's clearly loads of things we could do to improve the hackage quality and package maintenance, but we do have to realise it's also a social balancing act
00:13:20 <Sadache> Berengal: there is no ZipN that takes a list of lists?
00:13:33 <Berengal> Sadache: There is. It's called transpose :)
00:13:36 <MarcWeber> fasta: Right. But I don't want to search the haskell-cafe for blog posts. This takes too much time.
00:13:43 <dcoutts> so if we have time to add features to hackage, that's great, I've got a fairly good idea of what needs doing
00:13:48 <fasta> MarcWeber, you search Google.
00:14:05 <SamB_XP> dcoutts: I really don't see that the maintainers would mind having a public scratchspace associated with each package on hackage...
00:14:05 <fasta> MarcWeber, take for example the regular expression library.
00:14:15 <Sadache> Berengal: fair enough
00:14:20 <fasta> MarcWeber, I always just lookup the post on serpentine.com.
00:14:20 <Berengal> Sadache: The zip functional are generally reserved for generating lists of tuples
00:14:24 <Berengal> functions*
00:14:27 <jmcarthur_work> personally i would rather hackage contain everything i need to manage a project, even if only opt-in
00:14:36 <Summermute> Berengal: I've noticed that at least in the canonical set of list operators in function languages, so many are various kinds of sugaring for many of the others!!!
00:14:42 <MarcWeber> fasta: Which results will be more reliable? google results which index www and provide information dated back 2005 or a wiki page which you know that it is related to your problem and the one who solved the problem knowns this as well.
00:14:45 <Sadache> Berengal: not the zipWith
00:14:57 <dcoutts> SamB_XP: it somewhat annoys me when I end up with multiple such wiki pages for my packages, yet another place to keep tidy
00:14:58 <Berengal> Sadache: That's just the generalization of zip
00:14:59 <Sadache> Berengal: anyway i got your point
00:15:02 <Summermute> Berengal: Despite claims of "orthoganality" :-)
00:15:15 <Veinor> @src zipWith
00:15:16 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:15:16 <lambdabot> zipWith _ _      _      = []
00:15:19 <SamB_XP> dcoutts: that's why I suggested the opt-out with URL of existing wikipage
00:15:19 <dcoutts> SamB_XP: the main imposition is that users think it's a place to report bugs
00:15:26 <Veinor> figures that zipWith would be the primitive one.
00:15:35 <MarcWeber> fasta: So you told me why it's no solution: It requires the user of hackage to know about serbentine.com
00:15:40 <dcoutts> SamB_XP: which means authors feel obligated to check it to see if people are reporting errors
00:15:42 <SamB_XP> dcoutts: well, we could handle that with a bit of RED text at the top of the page ?
00:15:44 <mercury^> Sadache: you can get what you want by map zipWith f s . transpose.
00:15:46 <Sadache> Berengal: I just thought that defining transpose in terms of zip is more natural thatdoing the opposite
00:15:56 <fasta> MarcWeber, I did not read your proposal, but a link from hackage to such a wiki URL could be a good idea, yes.
00:15:59 <dcoutts> SamB_XP: and it's that obligation that many will resent
00:16:01 <mercury^> err
00:16:16 <mercury^> Sadache: you can get what you want by map foldr f s . transpose.
00:16:20 <fasta> MarcWeber, I think Hackage is fundamentally a bad architecture for a community language.
00:16:20 <dcoutts> SamB_XP: and that's why opt-in is fine
00:16:26 <Berengal> Sadache: The transpose implementation as it is now is just about the minimal required for a zipN implementation as well.
00:16:38 <Summermute> Just quickly, I've become intrigued with the organizations wiki discussion- what's the purpose of the wiki under consideration?
00:16:59 <SamB_XP> write "Do not attempt to report bugs here; you can mention them, but you really really REALLY ought to email the maintainer or use the project's bugtracker!"
00:16:59 <fasta> If the maintainers of hackage die, there is no Hackage anymore.
00:17:05 <centrinia> > transpose [[1..],[2..]]
00:17:06 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10,11],[11,12],[12...
00:17:11 <MarcWeber> fasta: Why? It does its job: it lists all packages.
00:17:19 <SamB_XP> dcoutts: hmm, perhaps there should be .cabal fields for wiki and bug tracker ?
00:17:22 <SamB_XP> are there ?
00:17:30 <dcoutts> SamB_XP: for bug tracker, yes
00:17:32 <fasta> MarcWeber, you didn't notice the less than 99% uptime?
00:17:53 <SamB_XP> dcoutts: ah, so the notice could even provide a link to the bug tracker hopefully
00:17:56 <dcoutts> SamB_XP: and for home page
00:18:07 <dcoutts> SamB_XP: hackage already links to the bug tracker
00:18:07 <MarcWeber> fasta: No.
00:18:30 <SamB_XP> dcoutts: I'm talking about a notice that users would see if they tried to edit the wiki page
00:18:30 <dcoutts> SamB_XP: and many packages use a wiki as their home page
00:18:34 <fasta> MarcWeber, you could use Google to verify that it has been down a few times this year for at least 6 hours.
00:18:57 <SamB_XP> hmm ... could hackage detect whether the homepage is a world-writable wiki ?
00:18:59 <Berengal> fasta: The only solution to that problem is setting up mirrors
00:19:11 <MarcWeber> fasta: What do you do if you look for a package providing some features ?
00:19:23 <SamB_XP> I doubt it
00:19:31 <jmcarthur_work> i think that would be the wrong way to go anyway
00:19:38 <jmcarthur_work> "too smart"
00:19:39 <SamB_XP> because world-writable status is something that people are trying to hide lately
00:19:44 <fasta> Berengal, mirrors don't "mirror" the logic.
00:19:49 <SamB_XP> only humans are supposed to be able to figure it out
00:19:57 <Summermute> Sorry to interups, are we discussing a Wiki that catalogs available Haskell packages for download?
00:20:01 <SamB_XP> to prevent spambots from spamming
00:20:08 <fasta> Berengal, you need a system in which the actual servers are replicated.
00:20:25 <SamB_XP> Summermute: no, we're talking about a wikipage for each package on Hackage
00:20:41 <Summermute> SamB_XP: thanks
00:20:58 <fasta> MarcWeber, I still go to the package list and search for some keywords with my browser.
00:21:08 <SamB_XP> with some sort of opt-in/opt-out by the package maintainer for the case where the package already has a decent wiki
00:22:08 <MarcWeber> fasta That's why I watn the link to the wiki on the hackage site because everyone is going to hackage to look for packages even if its down for serveral hours a year
00:22:21 <MarcWeber> It still is the best source of knowledge right now AFAIK.
00:22:39 <dcoutts> SamB_XP: my general plan is to award packages marks on the basis of a whole collection of measurements, download, reverse deps, successful build reports, having bug tracker/wiki/homepage links, user ratings, etc etc.
00:23:01 <jmcarthur_work> would be nice if hackage looks for relevant things on trac.haskell.org, the haskell.org wiki, code.haskell.org, etc. automatically
00:23:02 <SamB_XP> so, anyway, I think the Hackage policy should be to have such a wikipage for every package that doesn't explicitly provide hackage with the URL for a publicly-writable wikipage
00:23:05 <dcoutts> SamB_XP: specific things like "does it have a $BLAH" is just another gold star / black mark
00:23:11 <jmcarthur_work> with certain conventions assumed
00:23:24 <Summermute> Hackage looks very nice already - is the Wiki intended to give more free form descriptive capabilities (maybe even API docs, tuts)?
00:23:37 <jmcarthur_work> Summermute, we already have API docs
00:23:45 <jmcarthur_work> and ways to link to project home pages
00:24:05 <Summermute> jmcarthur Ok, so even more then my q - to ends?
00:24:11 <SamB_XP> obviously, this can't really be fully checked automatically (I mean, hackage could check for a 404 every now and then, but otherwise not much...), but users should be able to report that the wiki
00:24:21 <SamB_XP> er, that the wiki doesn't work anymore
00:24:32 <jmcarthur_work> Summermute, i think the idea is to just give the community a way to contribute to a project without the maintainer having to step in at all
00:24:39 <jmcarthur_work> Summermute, which some are having problems with, i think
00:25:03 <Summermute> jmcarthur: In what senses "contribute" if I may ask
00:25:21 <jmcarthur_work> Summermute, docs, bug reports, etc.
00:25:36 <Summermute> I see
00:26:41 <Summermute> There is such extensive developer / project support architecture out there - my first thought is to think what a super useful veneer on the existing (big co) infrastructure migh be like
00:28:43 <Summermute> Perhaps a free text addition; per-project RSS updates; a forms component imposing some uniformity on project info (hackage has this already - although I don't see any info indicating if something is platform specific)
00:30:51 <HaskellLove> can someone help me understand fold functions i am scared of them dont get them :(
00:31:00 <Summermute> "Spec" "API" and "Doc" entries might be welcome, just from my own frustrations looking for well supported packages in other languages. There are many "prose challenged" software developers out there :-)
00:32:39 <Vulpyne> HaskellLove: Perhaps this will help you: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
00:33:28 <HaskellLove> I have read thoe stuf mean i meant u guys showing me some examples litle code
00:33:34 <Summermute> Google Foldr and Foldl - there's lots of great, very step by step explanations out there. After all, it's one of those "universal computations"
00:33:52 <Vulpyne> HaskellLove: Have you used the state monad at all?
00:34:11 <HaskellLove> Vulpyne no
00:35:49 <Vulpyne> HaskellLove: Ahh, I was going to say I used foldl' quite often to simulate it. :) foldl' (\state item -> state + item) 0 [0..10000000] -- is an example (expanded for clarity, there are shorter ways to write the same thing)
00:36:25 <Summermute> using no syntax in particular:   foldr 0 + [1, 2, 3] => 0 + 3 + 2 + 1   Note: it's right associative and starts with 0 then 3 and backwards
00:36:45 <Veinor> > foldr 0 f [1, 2, 3]
00:36:46 <lambdabot>   Ambiguous type variable `a' in the constraint:
00:36:46 <lambdabot>    `GHC.Num.Num a' arising f...
00:36:50 <Veinor> awwwww :(
00:37:03 <Veinor> > foldr x0 f [x, y, z]
00:37:04 <Vulpyne> 0 in the wrong place. :)
00:37:04 <lambdabot>   Not in scope: `x0'
00:37:08 <Veinor> oh yeah.
00:37:17 <Veinor> >foldr f 0 [1, 2, 3]
00:37:25 <Veinor> > foldr f 0 [1, 2, 3]
00:37:26 <lambdabot>   Ambiguous type variable `b' in the constraints:
00:37:26 <lambdabot>    `GHC.Num.Num b' arising ...
00:37:32 <Veinor> >:(
00:37:36 <Summermute> foldl 0 + [1,2,3] => 0 + 1 + 2 + 3   Note: Left associative starting with 0 and 1.  Some people think of it as puting the operator or function in between the list elements and the initial element (zero in our case)
00:37:46 <Vulpyne> > foldr f (0 :: Int) [1,2,3]
00:37:47 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Int)
00:37:47 <lambdabot>    arising from a us...
00:38:02 <Veinor> Summermute: I think you have that wrong
00:38:06 <SamB_XP> dcoutts: what do you think of my proposed policy ?
00:38:17 <Summermute> Sorry, I'm a guest - I did say "no syntax in particular"
00:38:23 <Vulpyne> Summermute: You'd need (+) not bare + BTW.
00:38:32 <mreh> > foldr f z [a,b,c]
00:38:32 <lambdabot>   f a (f b (f c z))
00:38:43 <Veinor> there we go.
00:38:45 <SamB_XP> Vulpyne: he's talking concepts here
00:38:54 <Summermute> Can't you tell I'm a Lisper/Schemer by training :-)
00:39:12 <Vulpyne> Well, it looked like Haskell LHS of the => :)
00:39:15 <SamB_XP> Vulpyne: he had the concept right, just not the syntax or the argument order
00:39:43 <SamB_XP> and also he needs more parens ;-P
00:39:46 <Vulpyne> This conversation started with HaskellLove's confusion about fold.
00:40:01 <Summermute> I'm designing a language where fold is a "method" of all functions/operators, so I've been banging on a pretty odd syntax lately.
00:40:03 <SamB_XP> funny that a lisp-background guy would be lacking in parens
00:40:40 <Vulpyne> Maybe he used them all up.
00:40:44 <mreh> could someone compile this and try to get the program to exit when the window closes? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13981
00:40:49 <dcoutts> SamB_XP: what is it exactly?
00:40:54 <Summermute> My lang is ML'ish and infix functional land has educated me to [elt,elt] with commas too :-)
00:41:03 <mreh> I can't see anything wrong with the logic, i think HGL might be borked
00:42:10 <Vulpyne> If it was me, I'd make it start printing every event it received.
00:42:19 <SamB_XP> dcoutts: that hackage provide a wikipage for every package that it isn't explicitly told of an existing wikipage for
00:42:21 <Summermute> SamB_XP: Also I've been more or less buried in papers fora year, and excepting the Scheme papers (some great stuff), no one uses infix Lisp syntax anymore
00:42:49 <SamB_XP> and furthermore that users be able to report that such an alternative wikipage no longer works
00:43:27 <dcoutts> SamB_XP: generally, yes. I'd prefer to be slightly less rigid and have it be opt-in, but award quality black marks for packages lacking it.
00:43:31 <mreh> Vulpyne: true
00:43:39 <mreh> I think I know why it doesn't work now
00:43:45 <dcoutts> SamB_XP: social pressure rather than outright requirement
00:43:45 <SamB_XP> dcoutts: I seriously think that it should be opt-out
00:44:25 <SamB_XP> at the very least, it should be a pre-checked checkbox in a form when a user uploads a package of a new name to hackage
00:45:22 <dcoutts> SamB_XP: right, the default for new packages is a slightly separate matter and we can use defaults that we recommend.
00:45:31 <dcoutts> SamB_XP: if they do not require intervention
00:45:32 <SamB_XP> ... is the URL of the existing wiki page really too much to ask of the package maintainer who does not wish to use this wikipage?
00:45:34 <Summermute> A very effective and automated filter for users is - counting. How many views, dt started, updates, last updated, how many downloads, how many comments. Filter on that stuff and usually (not always) the cream rises to the top, and the ambitious developer devotes alot of time to updating their section of the "wiki" or whatever.
00:45:46 <MarcWeber> dcoutts: Are you fine with me writing a short wiki page which can be used to keep track of arguments for or againts wiki pages?
00:46:10 <Summermute> Ratings can work ok, but kind of easily rigged :-)
00:46:18 <dcoutts> MarcWeber: go for it
00:46:33 <SamB_XP> MarcWeber: well, it's not just a for/against issue
00:46:38 <MarcWeber> dcoutts: Is tehre a special  category I should put this page on?
00:46:39 <SamB_XP> actually, is anyome really against ?
00:46:51 <dcoutts> MarcWeber: I'm not sure really
00:47:11 <SamB_XP> what categories exist now ?
00:47:20 <edwardk> Summermute: you get what you measure. the question is do you want to drive quantity or quality?
00:47:24 <MarcWeber> SamB_XP: Anywway I'd like to collect thoughts. And I think it would be useful. So I'll create a page and no links. I'll post to haskell-cafe and see what happens
00:47:40 <Summermute> SamB_XP: politically (social dynamics) Buy in from the biggest and most popular projects is likely needed to get the snowball rolling downhill.
00:48:10 <Summermute> edwardk: One can take the behavioral argument that we can only know what we can measure :-)
00:48:45 <SamB_XP> Summermute: but the biggest projects already have wiki pages
00:49:08 <Summermute> Qualitative assessment is unfortunately key, but left to drift into the ether ....  Blog entries from 'respected' authors can help on the qualitative side of user evaluation.
00:49:10 <nolrai_FG> > let ?a = 2 in ?a = a + 1 let f = ?a in f
00:49:12 <lambdabot>   <no location info>: parse error on input `='
00:49:19 <nolrai_FG> > let ?a = 2 in ?a = a + 1 in let f = ?a in f
00:49:20 <lambdabot>   <no location info>: parse error on input `='
00:49:42 <SamB_XP> Summermute: heck, they don't have to be from respected authors if they have enough content!
00:49:47 <nolrai_FG> > let ?a = 2 in let ?a = ?a + 1 in ?a
00:49:48 <lambdabot>   3
00:49:58 <nolrai_FG> > let a = 2 in let a = a + 1 in a
00:50:02 <lambdabot>   mueval-core: Time limit exceeded
00:50:06 <nolrai_FG> cool
00:50:21 <edwardk> samb_xp: hrmm, a hackage wiki policy would be strange to me at least. for instance my blog serves as most of the support mechanism for my packages
00:50:55 <SamB_XP> edwardk: hmm. okay, alternative wiki OR comment-accepting blog ?
00:50:58 <Summermute> SamB_XP: That is true. Also, re: the biggest projects, hopefully they can be convinced to host centrally, particularly if there is "free" infrastructure maintenance, software update, mirroring ...
00:51:30 <edwardk> but isn't there also stuff on hackage only of historical interest? or is everything on hackage intended to always be current?
00:51:39 <SamB_XP> and then again there are a lot of wiki pages on the Haskell wiki ...
00:51:57 <SamB_XP> edwardk: yeah
00:52:18 <Summermute> Perhaps extend the Haskell wiki with the package oriented content? Are there political problems with doing that?
00:52:22 <SamB_XP> but historical-interest-only might especially benefit from a hackage wiki page, for people to talk about the historical context if nothing else ;-)
00:52:37 <edwardk> Summermute: honestly, i don't host source control through the community site, etc. because of performance. i get a much better workflow locally than I ever will bouncing off some server across the country at Galois or wherever the stuff is hosted today
00:52:46 <SamB_XP> Summermute: you mean like adding a hackage/ namespace to it?
00:53:10 <Summermute> Think of a search - 1 week 1 month 3 month 6 month 1 year 2 year Archive.  Some stuff just falls into the "bargain bin" - it's life.
00:53:13 <Berengal> How do you work in ghci on a project that uses caba's Paths_foo feature?
00:53:24 <dcoutts> Berengal: -idist/build/autogen
00:53:25 <edwardk> One of the things that has really helped hackage explode into popularity is that there is a very low barrier to entry
00:53:39 <Berengal> dcoutts: Thanks
00:53:40 <edwardk> Every control has a cost
00:53:54 <Summermute> edwardk: sure
00:54:30 <dcoutts> edwardk: stuff of historical interest is absolutely fine, we just need to be able to distinguish stuff that works now from stuff that does not (and is not expected to)
00:54:42 <edwardk> dcoutts: fair enough
00:54:55 <Summermute> SamB_XP: Yeah, lots of wikis have "sections" even though they are really flat graphs underneath.
00:55:01 <edwardk> i'm also perhaps more of a symptom of the disease than part of the cure. i really need to update a bunch of my packages ;)
00:55:18 <SamB_XP> Summermute: I'm talking about using that namespace just to avoid unwanted collisions
00:55:53 <Summermute> SamB_XP: Ah, you mean Wiki namespace?
00:55:54 <dcoutts> edwardk: so I want to make report pages like "bitrot watch" that lists important packages that are in danger of becoming uninstallable
00:56:17 <edwardk> dcoutts: i can definitely see value in that
00:56:25 <dcoutts> edwardk: I think if we start gathering and putting more info on the hackage pages, then authors will be more motivated to fix their stuff
00:56:29 <SamB_XP> users could easily set up redirects for those packages with existing pages on haskellwiki
00:57:11 <dcoutts> edwardk: gold stars and black marks next to your name are surprisingly motivating even though it's so transparent :-)
00:57:19 <edwardk> yeah
00:57:51 <SamB_XP> dcoutts: better not make it TOO transparent, or nobody will be able to see 'em ;-P
00:57:55 <Summermute> The wiki namespace could be managed by Pkg/Category/Foo Pkg
00:58:00 <Vulpyne> Every day that passes without an update, destroy one pixel in their logo. :)
00:58:03 <Summermute> Or whatever
00:58:05 <dcoutts> SamB_XP: :-)
00:58:14 <edwardk> summermute: packages belong to multiple categories
00:58:51 <SamB_XP> okay, so Package/<package> then ?
00:59:35 <Summermute> edwardk: Ok that makes sense. First thought - use the old Yahoo directy @Pkg symlink idiom to support mutiple cats. So yeah, there's a home cat. Just first thoughts.
00:59:59 <edwardk> i think Package/<package>
01:00:01 <SamB_XP> Summermute: that just sounds like a pain to me, having the categories in the names
01:00:09 <edwardk> avoids any headaches of dealing with ontology
01:00:12 <SamB_XP> yeah
01:00:35 <Summermute> SamB_XP: Yeah, but it solves the flat namespace problem on Wikis, right?
01:00:45 <edwardk> Vulpyne: incentive to make big logos ;)
01:00:51 <SamB_XP> Summermute: it's not really much of a problem
01:01:09 <Summermute> Wait, I thought you said it was a problem :-)
01:01:27 <Berengal> Summermute: I, at least, find searchable tag-clouds to be a better solution than namespaces
01:01:28 <edwardk> Summermute: the package namespace is flat, you can't have more than one package with the same name anyways
01:01:34 <edwardk> so the hierarchy is purely another thing to forget
01:01:46 <SamB_XP> the only point of the Package/ bit is to prevent unintended collisions between these pages and the normal pages on haskellwiki!
01:02:01 <edwardk> the categories we have are as berengal noted, just tags
01:02:24 <Summermute> If it's not a problem then do as follows - separate Sam's Package/<package> list from a PackageCategories root page where there can be links to the package from different categories. Simple enough.
01:02:44 <edwardk> SamB_XP: next niggling consideration. capitalization, package names are case sensitive, no?
01:03:16 * Berengal has this weird idea of searchable tags in the module system as well
01:03:20 <edwardk> so there could be a monoid and Monoid, what happens in wiki land?
01:03:23 <SamB_XP> edwardk: oh. yeah :-(
01:03:38 <SamB_XP> so mediawiki still suffers from that?
01:03:54 <edwardk> Berengal: i haven't figured out how to make tag-based namespacing work. i bounced it around for a while, and conal had some ideas last year some time, but nothing seems to really work
01:04:08 <Summermute> Personally, I'd try to autotag the pages from what the "users" put into their project pages and let Google manage the search.
01:04:13 <elly> arbitrary logical expressions on tags
01:04:55 <dcoutts> edwardk: we try to avoid names that differ in case only
01:05:06 <SamB_XP> Summermute: they're talking about something else now
01:05:07 <Summermute> First things first - really good fielded search usually requires tagging *management* and some user acumen as well. A bit much to ask.
01:05:11 <edwardk> dcoutts: have any found their way into the system?
01:05:19 <davide6> triforce88.webnode.com
01:05:33 <dcoutts> edwardk: I'm not aware of any atm, it'd cause problems for windows systems too
01:05:45 <Summermute> Whoops. I'm an IRC newbie too, it all flies by so fast to me :-)
01:06:01 <edwardk> yeah that was what i was thinking, or macs set up insensitively
01:06:16 <SamB_XP> Summermute: I only know they're taling about something else because it's been discussed before ;-P
01:06:22 <dcoutts> edwardk: yeah, those macs are so insensitive
01:06:28 <edwardk> =)
01:06:54 <edwardk> this explains why the artsy mac users love them. typical bad boy syndrome.
01:07:10 * SamB_XP wonders if you can set up an ext[234] filesystem insensitively on Linux...
01:07:57 <Vulpyne> I don't like that feature of OS X. :(
01:08:08 <elly> SamB_XP: http://bill.herrin.us/freebies/ apparently
01:08:10 <SamB_XP> Vulpyne: why not ?
01:08:14 <SamB_XP> elly: hmm ?
01:08:16 <Beelsebob> Vulpyne: which feature?
01:08:28 <Beelsebob> the filesystem being case preserving, not case sensitive?
01:08:43 <SamB_XP> Beelsebob: you mean that's not optional ?
01:08:49 <elly> SamB_XP: it is a case-insensitive hacked ext3 for linux :P
01:08:55 <Vulpyne> Beelsebob: Yeah.
01:09:08 <Beelsebob> it is optional, but you're in for trouble if you select sensitive SamB_XP – most app developers don't test on it, and many go wrong on it
01:09:09 <quicksilver> SamB_XP: it's an nightmare if you interoperate with other people case-sensitive FSes
01:09:11 <SamB_XP> elly: what I actually meant was "I wonder if there's a mount option for that"
01:09:13 <Vulpyne> The first time I installed OS X, I turned off the case insensitivity, and lots of programs didn't work.
01:09:14 <Beelsebob> Vulpyne: personally, I love it
01:09:18 <Beelsebob> it stops people being idiots
01:09:36 <SamB_XP> Vulpyne: ah.
01:09:36 <quicksilver> SamB_XP: you can commit makefiles / web pages / config files that work for you and not for them
01:09:39 <Vulpyne> Beelsebob: How does it stop people from being idiots more than case sensitivity?
01:09:49 <eivuokko> SamB_XP, how could it be just a mount option?  What'd happen to existing files with names that differ by only case?
01:09:54 <Beelsebob> Vulpyne: it stops people naming two files the same thing
01:09:57 <Beelsebob> ;)
01:10:03 <quicksilver> eivuokko: you'd get one non-deterministically :)
01:10:08 <SamB_XP> they should require software to be tested with case-sensitivity to get the OS X logo ...
01:10:24 <quicksilver> eivuokko: (or perhaps deterministically, like the first lexicographically unicode-wise)
01:10:26 <zygoloid> Beelsebob: what encoding does OS X use for filenames?
01:10:31 <jix> shouldn't it be possible to write a case insensitive pseudo file system using fuse
01:10:40 <SamB_XP> quicksilver: yeah, it can be a nightmare, true
01:10:43 <Beelsebob> zygoloid: not sure *checks wikipedia on hfs+*
01:10:44 <eivuokko> quicksilver, Yes, great idea ;-)
01:10:45 <quicksilver> jix: yes, modulo eivuokko's question
01:10:58 <jix> yeah
01:11:06 <SamB_XP> quicksilver: but it's not like either of the two is inherantly superior
01:11:06 <Beelsebob> zygoloid: UTF-16
01:11:09 <Vulpyne> Beelsebob: I suppose... I never really seen that happen though.
01:11:16 <quicksilver> Beelsebob: in isolation it is possible to argue for the feature. If you have to cooperate with people on case-sensitive systems it's a pain though.
01:11:35 <Beelsebob> quicksilver: very true, but one can equally say that in reverse
01:11:36 <edwardk> eivuokko: well, that is the way the macs are set up, it is a mount option to turn it on
01:11:38 <SamB_XP> hmm, I just realized why Windows doesn't sort upper-case filenames before lower-case ones ;-P
01:11:53 <quicksilver> edwardk: no it's not
01:12:02 <jix> it's a formatting option
01:12:03 <quicksilver> edwardk: it's a FS-creation-time option
01:12:08 <quicksilver> edwardk: you have to reformat to change it.
01:12:11 <edwardk> ah
01:12:25 <SamB_XP> quicksilver: what, no tunefs ?
01:12:34 <edwardk> they were just coming out with it when i left macs ;)
01:12:36 <quicksilver> Beelsebob: yes, but I interoperate at work with unix-based servers and in my personal life with linux-based hackers :)
01:12:40 <Vulpyne> Yeah, once I realized case sensitivity was going to break everything I had to totally reformat and reinstall OS X. It made me angry.
01:12:49 <eivuokko> SamB_XP, modifying fs while it's unmounted kinda doesn't count as mount-time option, does it?
01:12:56 <quicksilver> Vulpyne: I'm running case-sensitive and have had no issues yet
01:13:01 <quicksilver> Vulpyne: (reformatted a couple of months ago)
01:13:14 <SamB_XP> eivuokko: well, it's better than having to totally reformat
01:13:25 <Vulpyne> quicksilver: I forget what didn't work. I think WoW was one of the things. :)
01:13:55 <quicksilver> Vulpyne: WoW not working is a benefit not a loss. Think about all that reclaimed free time.
01:13:58 <SamB_XP> (did I say anything indicating that I believed OS X to have this as a mount-time option?)
01:13:58 <quicksilver> ;)
01:14:15 <SamB_XP> Vulpyne: what? no Linux port, they have ?
01:14:17 <Vulpyne> But but I can't check my auctions during lunch break!
01:14:27 <Vulpyne> Linux port of WoW?
01:15:19 <SamB_XP> hmm, now I've got an amusing reinterpretation of that ... "Linux port of Windows-on-Windows?"
01:15:34 <eivuokko> Heh.
01:15:46 <zachk> > let p1 n = ((-1)^n)/(2*n+1) in map p1 [0..10]
01:15:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:15:47 <lambdabot>    `GHC.Real.Fractional a'
01:15:47 <lambdabot> ...
01:16:00 <zachk> how do i make that work in ghci?
01:16:12 <SamB_XP> I still don't get why they didn't port that to amd64/ia64
01:16:25 <mauke> > let p1 n = ((-1)^n)/(2*fromIntegral n+1) in map p1 [0..10]
01:16:32 <lambdabot>   [1.0,-0.3333333333333333,0.2,-0.14285714285714285,0.1111111111111111,-9.090...
01:16:36 <zygoloid>  let p1 n = ((-1)**n)/(2*n+1) in map p1 [0..10]
01:16:40 <zygoloid> > let p1 n = ((-1)**n)/(2*n+1) in map p1 [0..10]
01:16:40 <lambdabot>   [1.0,-0.3333333333333333,0.2,-0.14285714285714285,0.1111111111111111,-9.090...
01:16:54 <zygoloid> @type (^)
01:16:55 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
01:16:56 <SamB_XP> I mean, if they had it working on all those other arches that NT used to run on ...
01:17:09 <zachk> thank you
01:17:10 <zygoloid> zachk: it's the Integral constraint on the RHS of (^) which is causing the problem
01:17:19 <zachk> rhs?
01:17:23 <zygoloid> right-hand side
01:17:29 <SamB_XP> ... how hard could that have been to port to 64-bit ?
01:17:31 <edwardk> SamB_XP: didn't port what?
01:17:51 <SamB_XP> edwardk: the 16-on-32 WoW
01:17:57 <edwardk> ah
01:18:04 <edwardk> i think the time had come for it to die ;)
01:18:21 <eivuokko> SamB_XP, I might be wrong, but it might be that it wasn't *that* reliable anyway.
01:18:37 <SamB_XP> too bad way too many setup programs were 16-bit ...
01:18:40 <edwardk> all of the developers who knew the internals of it had probably gone off to play with their Ferraris, keep in mind when they would have gotten their stock options
01:19:21 <SamB_XP> anyway, I think they should have at least offered it as an optional component for those of us who like really old software ...
01:19:47 <Daimonic> Could someone give me a leg up? I want to print out the list elements from position a to b, I am trying out with (!!)
01:19:49 <SamB_XP> ... or at the very least handed out free Windows 3.1 ISOs
01:19:55 <edwardk> as part of the generation of Spolskys that Microsoft unleashed upon the world
01:20:25 <edwardk> Daimonic: drop then take
01:20:27 <eivuokko> Daimonic, maybe check out functions drop and take.
01:20:54 <Daimonic> ah damn it, totally forgot about this quite simple way
01:20:55 <Daimonic> thanks man
01:21:17 <SamB_XP> edwardk: would they really have needed people who were already familiar with NTVDM just to port the non-x86 kernel side to 64-bit CPUs and the newer NT kernels?
01:23:09 <SamB_XP> I mean, even leaving out the DOS support so as not to require help from e.g. every single display driver?
01:23:11 <edwardk> SamB_XP: there is a point at which backwards compatibility hampers forward progress. those applications weren't aware of much of the surround environment, file names, etc.
01:23:47 <SamB_XP> I guess what I really wish is that they'd have given us the source for the non-x86 NTVDM to play with ...
01:23:57 <mreh> getting stuck in an infinite loop here, I think it's sequence maybes, can't see why though :( http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13988#a13988
01:24:00 <SamB_XP> ... so that those who thought differently could port it themselves
01:24:57 * SamB_XP wonders if he can even find binaries of non-x86 NTs
01:24:59 <Daimonic> How can I call like n times False? f 3 = [False,False,False] ?
01:25:10 <c_wraith> > replicate 3 False
01:25:11 <lambdabot>   [False,False,False]
01:25:23 <Daimonic> oh that's sugar
01:25:37 <edwardk> who knows how many intellectual property issues that would raise. they've had how many random lawsuits over the years that they had to pay out, etc. the potential legal encumbrances are large, and the payout to them is a bunch of folks using back channels that they can't close as a result
01:25:53 <eivuokko> SamB_XP, anyway, you could always just use Virtual PC instead.
01:25:56 * SamB_XP remembers that he recently noticed a reference to the Xbox 360 big endian -- is that a first for MS ?
01:26:30 <SamB_XP> eivuokko: well, sure, but only if you download a pirated copy of <insert windows version here>!
01:26:31 <trofi> that?
01:26:50 <edwardk> they ran on Alphas, which are switchable, I don't remember which mode that they ran in by default
01:27:04 <trofi> and on ppc by legend
01:27:16 <SamB_XP> yeah, but I hear the PPC version was little-endian
01:28:03 <edwardk> looks like the old NT alpha port was also little endian
01:28:13 <edwardk> so I'd hazard a 'yes'
01:28:32 <SamB_XP> yeah, I figured if the PPC port was little endian, probably they all were
01:29:09 <edwardk> from some old nt docs:   Windows NT was designed around Little Endian architecture. The Hardware Abstraction Layer (HAL) is written so that all operating system-related issues are automatically handled. Therefore, it is possible to create a HAL that could work on Big Endian architecture.
01:29:28 <SamB_XP> hmm, which port was most recently discontinued ?
01:30:20 <SamB_XP> heh
01:30:51 <SamB_XP> why am I searching for other-CPU versions of NT when I already have an ISO with NT 3.51 for ... well, several of them ...
01:31:15 <mreh> d'oh, i realised that binding isn't lazy
01:31:20 <edwardk> SamB_XP: and why for that matter are you waxing nostalgic for NT anyways? ;)
01:32:12 <SamB_XP> edwardk: well, NT seems nice enough, except the closedness and the inexplicably intermixed GUI stuff and all the heaps of libraries they've piled on top!
01:32:57 <edwardk> SamB_XP: well, i'm thinking from a kernel perspective, all of the interconnections behind the scenes. you can't peel the onion
01:33:33 <SamB_XP> edwardk: did 3.51 have all of those ?
01:33:46 <edwardk> most of the current set of interdependencies was born around then
01:33:53 <SamB_XP> oh
01:33:56 <SamB_XP> :-(
01:34:18 <SamB_XP> what was the one BEFORE they added that crap ?
01:34:34 <edwardk> hence why even the graphics-less 'windows core' installs are huge
01:34:51 <edwardk> there isn't, because nt was basically their closest attempt at a fresh slate
01:35:00 <SamB_XP> I hear they're finally working on untangling that shit
01:35:05 <edwardk> and even that was crippled by trying to be compatible with 95, etc.
01:35:28 <SamB_XP> edwardk: oh, seriously? it wasn't that 95 was made to be compatible with NT ?
01:35:56 <edwardk> oh yeah
01:36:02 <ddarius> 95 and 98 were insanity
01:36:09 <SamB_XP> ddarius: yes
01:36:18 <SamB_XP> that's why you'll probably never see a free clone of 9x
01:36:33 <SamB_XP> it's amazing they worked so well
01:36:36 <SamB_XP> honestly
01:36:44 <edwardk> but the relationship got pretty incestuous shortly thereafter
01:36:53 <ddarius> I liked 98, but I wouldn't use it for something serious.
01:37:18 <SamB_XP> and I mean, 95 really did run multiple DOS programs at the same time amazingly well
01:37:31 <ddarius> SamB_XP: That's not particularly impressive.
01:37:37 <edwardk> have to admit the only thing i like from programming on windows is the existence of VirtualQuery ;)
01:37:39 <SamB_XP> considering the access it allowed them to the hardware, I think it is
01:37:43 <zygoloid> anyone know how ReactOS is progressing?
01:38:05 <edwardk> the lack of an equivalent on any unix I can think of is a pain in my ass
01:38:15 <SamB_XP> sadly, the Windows programs were less-well protected from one-another :-(
01:38:38 <ddarius> SamB_XP: The x86 has hardware support just for doing that sort of thing.
01:38:57 <idnar> SamB_XP: what's wine, then?
01:39:02 <ddarius> It's amazing they did it that well for DOS programs and yet completely ignored protection for Windows programs.
01:39:06 <SamB_XP> idnar: eh ?
01:39:14 <idnar> < SamB_XP> that's why you'll probably never see a free clone of 9x
01:39:23 <idnar> maybe I don't understand what you mean by "free clone"
01:39:27 <SamB_XP> WINE isn't as insane as 9x
01:39:42 <ddarius> WINE couldn't be as insane as 9x if it tried.
01:39:52 <SamB_XP> I mean, it may have some of the thunking insanity, sure
01:40:01 <SamB_XP> but it doesn't actually contain an entire operating system as well!
01:40:55 <SamB_XP> nor, I think, does it it have a bunch shared DLLs loaded above 0x80000000 ?
01:41:49 <SamB_XP> anyway, this NT 3.51 Workstation disk seems to have files for Alpha, i386, MIPS, and PPC
01:42:19 <ddarius> So what are you going to do with bunches of NT 3.51 versions?
01:42:23 <edwardk> i think i still have an NT-compatible Alpha lying around in a closet somewhere
01:43:05 <SamB_XP> I was maybe going to disassemble it ;-P
01:43:24 <ddarius> SamB_XP: That's a violation of your EULA.
01:43:31 <edwardk> I used to run it as a shell machine, it was amazing how many would be x86-exploits got run against it.
01:43:32 <SamB_XP> ddarius: hehehehehe
01:44:48 <edwardk> SamB_XP: hrmm, looks like all of the Windows CE architectures were little endian as well
01:45:20 <SamB_XP> ARM, at least, seems to have been conventionally little-endian anyway?
01:45:50 <edwardk> http://msdn.microsoft.com/en-us/library/ms905093.aspx - the note from below the chart
01:47:04 <ddarius> Little endian is the right way.
01:47:33 <mauke> does anyone here speak foreign? what does "Brynhildur Táttur" mean?
01:48:08 <Vulpyne> Hmm, sounds norse.
01:48:17 <quicksilver> sounds like someone's name to me.
01:48:32 <Vulpyne> Sounds like it means "Brynhild's Song".
01:48:41 <Vulpyne> http://www.odins-gift.com/pclass/brynhildsballad.htm
01:48:56 <mauke> ah, nice
01:49:07 <Vulpyne> Should have just googled, it was the 7th result. :)
01:49:22 <EvanR-work> little endian is an abomination
01:50:38 <Taejo> EvanR-work: English writes numbers little-endianly
01:51:03 <ddarius> Taejo: No we don't.
01:51:04 <benmachine> we should totally switch
01:51:25 <Taejo> ddarius: of course we don't, I'm being an idiot
01:51:28 <Taejo> please ignore me
01:51:58 * edwardk bangs his head against the insanity of linux pthread implementations. MAP_GROWSDOWN, but only on the main thread, under a full moon.
01:52:00 <EvanR-work> however we do write numbers in the opposite order of the progression of a sentence
01:52:26 <EvanR-work> considering the ones place the logical beginning
01:52:37 <mreh> the images that I see in my head when someone writes big endian
01:52:46 <nolrai_FG> edwardk: some one should document the efect of full moons. :)
01:52:57 <Taejo> EvanR-work: what is the "order of the progression of a sentence"?
01:53:06 <mreh> nolrai_FG where do you think the word lunacy comes from?
01:53:17 <mreh> well documented anecdotally
01:53:19 <EvanR-work> Taejo: left to right, for english
01:53:20 <sproingie> no we don't, we pronounce numbers big-endian.  germans have some weird mixed thing.
01:53:31 <Taejo> and by saying "ones place [is] the logical beginning", you're arguing *for* little-endianness
01:53:55 <EvanR-work> yes. now... how do you pronounce numbers in arabic?
01:54:05 <EvanR-work> bigest first?
01:54:19 <lament> yes.
01:54:25 <EvanR-work> now thats messed up ;)
01:54:28 <lament> yes.
01:54:41 <sproingie> i recall some good argument for little-endianness having to do with opcode compression, but it's probably pretty obsolete now
01:54:46 <Taejo> EvanR-work: but they're written smallest first (biggest left, same as in english)
01:54:50 <EvanR-work> yes
01:55:19 <lament> they're written biggest first, left-to-right
01:55:20 <EvanR-work> and electrons should be positively charged!!! *runs*
01:55:44 <lament> actually in arabic i don't know how they write them
01:55:46 <Taejo> lament: if that's the case, then it is pure evil
01:55:54 <lament> in hebrew, they're certainly written left to right
01:56:05 <sproingie> arabic's got a couple different number conventions
01:56:05 <EvanR-work> A B C 123 D -> D 123 C B A
01:56:17 <lament> Taejo: the people who suffer the most are those who write typesetters and especially text selection
01:56:47 <Taejo> lament: I suffer enough trying to select text, never mind the people who wrote the algorithm
02:01:24 <edwardk> nolrai_FG: good idea.
02:02:35 <edwardk> to be fair the directionality of the way we read numbers comes more from the fact that we borrowed the system wholesale than from anything else ;)
02:03:04 <lament> it seems logical to start from the biggest
02:03:09 <lament> when reciting the number
02:03:17 <edwardk> lament: because you started that way ;)
02:03:23 <lament> no
02:03:37 <lament> because that's how humans normally describe stuff
02:03:49 <mauke> I see you haven't met my grandmother
02:03:50 <lament> first the large-scale features, then the little detail
02:04:10 <eivuokko> lament, that sounds too big a generalisation.
02:04:16 <edwardk> but you also have to stop and figure out your place so you can give that place indicator to indicate scale
02:04:17 <Berengal> It's true for me as well
02:04:42 <Berengal> Unless the number is really important, I just read the two-three first digits, then count the rest and multiply
02:05:39 <aavogt> sproingie: english has (or had) that weird thing too:   one and twenty blackbirds or something
02:06:15 <edwardk> lament: human language isn't so well structured. take english: adjectives come before, not after nouns ;) the 'incremental refinement' model would presuppose the opposite order
02:06:20 <aavogt> I think there was a movement for german to switch to a more regular ordering
02:06:37 <edwardk> similarly you'd prefer saying 'million 3' since after all scale is the most important factor
02:07:11 <|Jedai|> edwardk: right, and in french the adjectives can go on both sides depending purely on usage
02:07:34 <aavogt> |Jedai|: seems more at random to me
02:07:36 <edwardk> |Jedai|: sure, i'm just pointing out that linguistics is a morass of conventions ;)
02:07:37 <lament> edwardk: both counterexamples work because the stack is so small
02:07:51 <|Jedai|> aavogt: that's what I mean by usage
02:08:18 <sproingie> aavogt: had anyway.  nowadays it's archaeic.
02:08:19 <lament> edwardk: it doesn't matter which way you say it when there're only two words involved. The problem with numbers is that you presumably have a fairly consistent system capable of handling numbers of any length
02:08:21 <|Jedai|> lament: well, not so small in some case
02:09:48 <sproingie> 123: "einhundert, drei und zwanzig".  german is so screwed up.
02:09:57 <edwardk> lament: million 3 example was because i didn't want to come up with an internally consistent adhoc system for describing a numbers in terms of increasing focus while ignoring chunking factors simply for purpose of showing that human language isn't entirely consistent ;)
02:10:06 <aavogt> sproingie: hmm, thirteen (and other teens) are sort of a remnant of the opposite order
02:10:21 <edwardk> sproingie: good example =)
02:10:23 <aavogt> one hundred thir - teeen
02:10:26 <sproingie> yah we kept the teens
02:10:30 <aavogt> same messed up order
02:10:45 <sproingie> even the irregular forms for 11 and 12
02:10:51 <eivuokko> Or maybe remnants of the diffrent base.
02:11:01 <mauke> not entirely unrelated: http://mauke.ath.cx/stuff/c/ausschreib.c
02:11:01 <|Jedai|> lament: besides you're supposed to remember the end of a sentence better than the beginning, it's where many languages put their verbs and where the inflexion tells you about the intention of the phrase, so would it not be more consistent to end up with the biggest digit, therefore putting the scale at the point more likely to be remembered ?
02:11:30 <edwardk> |Jedai|: to be fair there is both a primacy AND a recency effect
02:11:50 <aavogt> so the unimportants stuff is in the middle
02:12:17 <aavogt> aka, 123 in german gets it right in terms of most significant figures being most emphasized
02:12:49 <|Jedai|> aavogt: though it doesn't work for bigger numbers
02:12:58 <edwardk> aavogt: though mostly by accident
02:13:22 <aavogt> ein tausend drei und vierzig
02:13:59 <aavogt> but yeah, it's broken for most larger numbers
02:14:18 <Berengal> People couldn't count that high in olden times :P
02:14:40 <lament> presumably "drei und vierzig" is small enough to be interpretable as a whole
02:14:43 <sproingie> dealing with big numbers wasn't something we usually had to deal with precisely as spoken word goes
02:14:51 <aavogt> also there's not that much point in being that precise
02:14:57 <ddarius> Indeed, the key word is "precisely"
02:15:00 <sproingie> german tends to slur it together anyway
02:15:02 <lament> (as is "ein tausend")
02:15:06 <sproingie> dreinverizg
02:15:49 <Daimonic> Is there a short version to convert an integer into a list of digits? I mean with higher order function or sth. else besides defining an own function?
02:16:09 <Berengal> Daimonic: map digitToInt . show
02:16:10 <mercury^> Daimonic: no, but defining your own is easy enough.
02:16:13 <mauke> Daimonic: show
02:16:21 <mauke> Berengal: he said list of digits, not list of ints
02:16:33 <Berengal> mauke: True. Now he has both versions
02:16:38 <Daimonic> ah show!
02:16:52 <mercury^> show only works for decimal and it returns a string
02:17:06 <lament> aren't you not supposed to use show? :)
02:17:39 <Daimonic> I can use show for my uses
02:18:03 <Berengal> Why aren't you supposed to use show?
02:18:19 <Daimonic> I am
02:18:24 <Daimonic> ?
02:18:31 <Berengal> Was asking lament
02:18:56 <Daimonic> I am out of practice *headshake* it's kind of interesting, I hear this semester abstract data types, mostly implemented in java, but our professor uses haskell for specification :- )
02:19:40 <EvanR-work> my condolences
02:19:43 <lament> Berengal: because its purpose is work in tandem with read for debugging
02:20:18 <Daimonic> EvanR-work: why that? I really like it
02:20:20 <lament> Berengal: it's meant to be a kind of internal, non-prettified, unfriendly representation
02:20:21 <EvanR-work> java?
02:20:39 <Berengal> lament: That's the first I've heard of it. I thought it was just a general to-string function, which should preferably be parseable by read
02:20:52 <Daimonic> EvanR-work: ADT only in haskell would be kinda to far away from reality ^^
02:21:06 <Daimonic> EvanR-work: or what do you suggest?
02:21:30 <Berengal> ADT in Haskell only would be too easy :P
02:21:45 <Daimonic> agree
02:21:49 <Berengal> They're built-in, for a certain value of A
02:22:09 <Daimonic> lovely to implement tree traversing in haskell
02:22:35 <eivuokko> Are you talking about algebraic or abstract?
02:22:48 <lament> Berengal: emphasis on debugging is why deriving Show works the way it does
02:22:49 <Berengal> I like ListArrow for manipulating trees...
02:22:51 * SamB_XP suspects the former for the "certain value of A" case
02:23:24 <Berengal> Or was that ArrowList...
02:23:42 <Berengal> Anyway, lovely type class that
02:24:46 <Daimonic> what was the function which reverses the argument order of a function?
02:24:51 <Berengal> flip
02:24:54 <Berengal> @type flip
02:24:55 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
02:25:03 <mauke> hah
02:25:11 <Berengal> Modulo Cale, that is.
02:25:16 <quicksilver> wow.
02:25:22 <quicksilver> I'd not thought of generalising flip.
02:25:22 <eivuokko> o.O
02:25:43 <xerox> that's why caleskell is useful :)
02:25:55 <Berengal> @src flip
02:25:55 <lambdabot> flip f x y = f y x
02:26:00 <SamB_XP> Cale really needs to come with some better names for these "generalizations"
02:26:25 <Berengal> SamB_XP: Or someone needs to come up with better names for the specialisations
02:26:49 <SamB_XP> Berengal: I don't see how this is the embodiment of flip!
02:27:42 <Berengal> SamB_XP: Agreed... But only for flip
02:28:01 <Berengal> This is more like pureAp
02:28:09 <Berengal> Or liftAp, or something...
02:28:43 <Berengal> It's certainly useful. I'm going to remember this for when I next need a parser.
02:28:58 <Daimonic> > foldl1 (flip elem [1,0]) ((map digitToInt . show) 1010)
02:28:59 <lambdabot>   Couldn't match expected type `a -> a'
02:28:59 <lambdabot>         against inferred type `GHC.Bo...
02:29:39 <Berengal> > map (flip elem [1,0]) (map digitToInt . show $ 1010)
02:29:40 <lambdabot>   [True,True,True,True]
02:30:06 <xerox> :t \amb -> \x -> amb >>= \f -> f x
02:30:07 <lambdabot> forall t (m :: * -> *) b. (Monad m) => m (t -> m b) -> t -> m b
02:30:11 <Daimonic> which I could foldl1 with &&, but would be nice to have it in on row with foldl
02:30:18 <xerox> nope
02:32:58 <Daimonic> > foldl1 (&&) $ map (flip elem [1,0]) (map digitToInt . show $ 1010)
02:32:59 <lambdabot>   True
02:34:01 <edwardk> > foldl1 (&&) . map (`elem` [1,0]) . map digitToInt . show $ 1010
02:34:02 <lambdabot>   True
02:34:11 <Berengal> @type flip flip
02:34:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
02:34:44 <Berengal> @djinn (Functor f) => a -> f (a -> b) -> f b
02:34:44 <lambdabot> -- f cannot be realized.
02:34:49 <Berengal> :/
02:35:30 <edwardk> @type all
02:35:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:35:48 <edwardk> > all (`elem` "01") . show $ 1010
02:35:50 <lambdabot>   True
02:36:21 <edwardk> djinn sucks at instances
02:36:22 <notweebl> what cabal package contains Text.Html
02:36:34 <Berengal> @hoogle Text.Html
02:36:35 <lambdabot> module Text.Html
02:36:35 <lambdabot> Text.Html newtype Html
02:36:35 <lambdabot> Text.Html Html :: [HtmlElement] -> Html
02:36:50 <Berengal> I'm going to guess html, or xhtml
02:37:13 <notweebl> html thx
02:41:18 <sproingie> bah.  trying to follow the "Programming with Arrows" paper, and it doesn't actually work with Control.Arrow
02:41:23 <osslin> inside a do block: whats the difference between writing let x = something and writing x <- something?
02:41:42 <sproingie> printFile = readFile >>> print  -- fail
02:42:12 <sproingie> i guess i could just do it from scratch, i just wonder how confused i'm going to get when i do start using Control.Arrow
02:42:12 <mk64ftw> osslin: let is a lambda with a function application, <- is a bind to a lambda
02:43:00 <sproingie> osslin: "x <- something" unwraps x from the monad, let just assigns it "raw"
02:43:06 <quicksilver> sproingie: because, unfortunately, it's not sane to make IO Kleislis into an arrow without a newtype.
02:43:13 <quicksilver> sproingie: so you have to write the horrible:
02:43:36 <quicksilver> printFile = runKleisli ( Kleisli readFile >>> Kleisli print )
02:43:55 <Berengal> sproingie: There's >=> and <=<
02:44:00 <Berengal> @type (>=>)
02:44:01 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
02:44:15 <quicksilver> :t readFile >=> print
02:44:16 <lambdabot> FilePath -> IO ()
02:44:16 <zygoloid> osslin: 'let {stuff}' is a shorthand for 'let {stuff} in do'; 'x <- stuff' is a shorthand for '(stuff >>=) $ \x ->'
02:45:03 <sproingie> type Fnord = Kleisli
02:46:36 <zygoloid> @type let bork = Kleisli; bork' = runKleisli; printFile = bork' (bork readFile >>> bork print) in printFile
02:46:37 <lambdabot> FilePath -> IO ()
02:46:42 <sproingie> is the arrow syntax in the paper still valid if i enable it in ghc?
02:47:05 <quicksilver> sproingie: basically yes, but I can't recall if there were small changes.
02:47:34 <quicksilver> (it certainly doesn't solve the Kleisli problem alluded to above)
02:48:10 <sproingie> is it mostly just IO with that problem or is it most monads?
02:48:17 <Berengal> I tend to just put IO in regular do-blocks, then use arrIO in arrows (assuming an instance for ArrowIO)
02:49:05 <sproingie> i'll probably stick with do-blocks for IO too, i'm just trying to expand my paint-deep knowledge of Arrows
02:50:16 <sproingie> trying to learn FRP, the yampa arcade paper pretty much jumps in to arrow notation
02:50:40 <quicksilver> sproingie: all monads have the issue.
02:50:48 <quicksilver> the problem is that "a -> m b" is a function
02:50:56 <quicksilver> (as well as being kleisli)
02:51:02 <quicksilver> and functions are, themeslevs, an arrow
02:51:17 <quicksilver> so the Arrow instance fo functions fundamentally overlaps the Arrow instance you want for kleislis.
02:51:37 <sproingie> can't overlapping instances fix this?
02:54:05 <sproingie> i'd try learning Reactive first, but there's a dearth of tutorial material
02:54:07 <zygoloid> you can't define an instance for '-> m'
02:54:20 <sproingie> ah
02:54:43 <toast-opt> you can't define typeclass instances over functions?
02:55:00 <zygoloid> you can. you can't define typeclass instances for the composition of two type constructors
02:55:01 <toast-opt> instance (Foobar (a -> m b)) ...?
02:55:11 <toast-opt> oh, i see
02:55:23 <toast-opt> because a -> b is really something like 'Arrow a b'
02:55:36 <zygoloid> it's "really" "(->) a b"
02:56:06 <toast-opt> thats unfortunate.  C++ templates can be so specialized
02:56:52 <zygoloid> C++ templates require the types to be known at compile time.
02:57:08 <toast-opt> template <class T> struct MyOps;  template<class A, class B, template <class> M> struct MyOps<Arrow<A,M<B> > > {... };
02:57:25 <zygoloid> in haskell, instance selection is sometimes applied to partially-unknown types
02:57:58 <toast-opt> zygoloid - true.  needed for 'duck typing'
02:59:34 <toast-opt> ... but can you say 'instance (Monad m b) MyTC a m'
03:00:19 <zygoloid> toast-opt: you can say 'instance Monad (MyTC a)', which i /think/ is what you mean there
03:01:06 <zygoloid> but there's no way of even writing that you want 'a -> m b' to be an instance of 'Arrow', because you can't write it point-free.
03:01:07 <toast-opt> zygoloid, actually, i appologize, i don't know what i really mean here
03:01:54 <Eduard_Munteanu> Hi.
03:02:08 <eivuokko> Hello.
03:02:17 <toast-opt> hmm, this is reminding me of the complexity of template partial specialization rules.  maybe i should stick to just lazy evaluation and basic parametric polymorphism
03:02:40 <edwardk> toast-opt: actually its pretty simple when you look deeper at how typeclass dispatch works
03:02:42 <Eduard_Munteanu> Is there a minimal Haskellish instruction set that would make a machine Turing-complete? I mean in terms of map etc. instead of branch etc.
03:02:51 <toast-opt> edwardk, that part made sense
03:02:58 <toast-opt> the extra 'vtable' parameter, right?
03:03:00 <edwardk> toast-opt: you _could_ make a dictionary like class Return m a where return :: a -> m a
03:03:06 <edwardk> and you could make one for bind
03:03:21 <edwardk> class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b
03:03:42 <edwardk> but you wouldn't have all of the incredibly generic functions from Control.Monad, which need the parametricity guarantees
03:03:58 <edwardk> that come from not being able to do the equivalent of partial template specialization
03:04:22 <edwardk> toast-opt: so that very limitation provides power, it is a trade off
03:04:31 <tom_> Hi there.  I'm looking at learning haskell (i especially like the research I read about implementing it in a FPGA), and looking for IDE suggestions.
03:04:59 <edwardk> toast-opt: as for why a -> m b isn't an instance of Arrow, you need to look at the fact that type class dispatch is basically pattern matching, just like at the term level.
03:05:03 <toast-opt> edwardk, but isn't this about how the vtable is selected in the first place?
03:05:04 <Eduard_Munteanu> tom_, nice, I came in here for the same reason just now.
03:05:10 <Eduard_Munteanu> tom_, I use vim for Haskell.
03:05:21 <Eduard_Munteanu> Not an IDE.
03:05:43 <toast-opt> it seems like it should be able to pattern match with as many constraints as you want... Arrow a b, where Monad m c, where Num a, where...
03:05:54 <tom_> Eduard: i saw vim, other suggestions google gave me, skyide, eclips, visual haskell, emacs
03:06:05 <lament> tom_: i don't think there's any good IDE, there's some eclipse plugin but iirc it's not great
03:06:24 <edwardk> when you define an instance Foo (a -> m b) -- it is just like defining one case for a function foo (a :-> b) -- where :-> is a constructor so it might read better as foo (Fun a b) -- the 'non-overlapping condition' on instances comes from the fact that you want that function to be definable regardless of the relative order of the clauses
03:07:09 <tom_> the eclipse is up to version 1.109.0
03:07:10 <edwardk> toast-opt: allowing overlapping instances means that the order that those instance definitions gets placed matters
03:07:14 <toast-opt> edwardk, i get that they need to be non-overlapping -- if they were overlapping, you'd be stuck in the C++ world of relative precedence, ambiguity, etc.
03:07:42 <toast-opt> i thought we were talking about not overlapping, but just strangely qualified
03:07:42 <tom_> http://eclipsefp.sourceforge.net/    anyone else... IDE suggestions?
03:07:47 <edwardk> toast-opt: not only that, you can wind up with unsafe coercions when you start mixing in other language ffeatures
03:07:54 <edwardk> toast-opt: i;m getting there ;)
03:08:08 <zygoloid> toast-opt: the key thing is, when the compiler is trying to resolve "this (a -> M b) thing is an Arrow", it needs to know which part of it is the arrow instance. the rule is that only the topmost type constructor is looked at; this allows typechecking to make progress.
03:08:35 <zygoloid> so only (->) is checked for an arrow instance, not \a b -> (a -> M b)
03:08:50 <edwardk> toast-opt: and in general proposals that allow for local instance declarations run afoul of the fact that we rely on a pretty fundamentally on the fact that you can view that instance resolution as a type level pattern matching problem
03:09:08 <Eduard_Munteanu> It seems most people into open-source don't use IDEs. It's probably because IDEs kinda restrict you in the choice of tools and build systems.
03:09:40 <edwardk> so Haskell 98 said all instances could only match on the outermost 'type constructor', but we found that annoying.
03:09:48 <edwardk> for instance it makes defining Show for Strings hard.
03:09:55 <edwardk> because that is really an instance for [Char]
03:10:03 <ski> (hence the `showList' hack)
03:10:05 <erik__> tom_ you can check out Leksah http://leksah.org/
03:10:06 <edwardk> so we relaxed it a bit
03:10:14 <tom_> there is also Leskah     Eduard: true, but they CAN be powerful tools.  Then when you need the unrestricted features, switch over to whatever else
03:10:16 <edwardk> and there are hacks to work around it. the showList hack
03:10:26 <toast-opt> yes, i read about the showList hack
03:10:31 <chrisdone> what's some good software that (1) makes flow diagrams in which I can create blobs of "goals" and annotate arrows between them indicating "actions" (2) is free (3) is not UML, I don't have time to learn UML or anything else. I just want to bring my paper notes into digital form easily. Dia is good but it could be easier
03:10:40 <tom_> erik__:  thanks... (actually, i'm trying to get it installed and running now)
03:10:42 <toast-opt> you can always re-dispatch at each type constructor
03:10:46 <toast-opt> right?
03:11:53 <toast-opt> thx for explaining though
03:12:27 <Eduard_Munteanu> chrisdone, dia?
03:12:28 <toast-opt> but i will probably stick with just types for now while i learn to use monads, then work on the edge cases of type classes later
03:12:32 <edwardk> brb
03:12:54 <edwardk> back
03:12:55 <edwardk> sorry
03:12:57 <Eduard_Munteanu> chrisdone, sorry, I didn't see you mentioned it.
03:13:07 <edwardk> so, when you say you want an instance for Monad m => a -> m b
03:13:09 <chrisdone> Eduard_Munteanu: I chuckled
03:13:10 <edwardk> er
03:13:18 <edwardk> instance Monad m => Arrow (a -> m b)
03:14:00 <Eduard_Munteanu> chrisdone, there's also xfig, but (1) doesn't look nicer and (2) isn't really diagram-oriented
03:14:10 <edwardk> then the dispatch for that is saying that those are the only arrows. that once you match (... -> ...) -- that you start looking for a monad on the right hand side and make an arrow
03:14:10 <Eduard_Munteanu> i.e. let's you draw just about anything vectorial AFAICT.
03:14:25 <edwardk> but there is a much more important arrow that looks like (... -> ...) -- the instance for (->) itself!
03:14:41 <edwardk> the the only such arrows
03:15:10 <edwardk> so you wouldn't be able to work with (->) the most canonical of arrows, you'd have to work in (... -> Identity ...)
03:16:17 * ski always thought that aspect strange
03:16:19 <tom_> Eduard: i'm having a few issues with leksah at the moment
03:17:18 <edwardk> toast-opt: so to work around that, whenever you need something that needs to dispatch on something 'deep' in the constructor like that or in a way that isn't necessarily the only such construction, we just make up a newtype and use that
03:17:55 <edwardk> if that is at all clear
03:18:05 <toast-opt> edwardk, just to make sure i'm understanding right, that's similar to how you dispatch things in languages without type classes -- Standard ML, OCaml, etc.?
03:18:31 <ski> it's not comparable
03:18:35 <edwardk> toast-opt: well, other languages have a very different dispatch model
03:18:36 <toast-opt> ... sort of an instance of the axiom 'any problem in CS can be solved with another level of indirection'
03:18:51 <ski> it's not the same kind of dispatch
03:19:09 <ski> the MLs have the usual pattern matching, like haskell
03:19:13 <edwardk> you typically have a mixed static/dynamic dispatch model where the static resolution takes care of most method calls and deals with overloading, while the dynamic one is based on vtables attached to the objects themselves
03:19:32 <ski> but this matching here is done at the type level, at compile-time
03:20:08 <edwardk> the closest thing to haskell typeclasses is in ML. ML has modules which are basically big bags of types and functions that can use those types. you would plumb in the module itself when you wanted to use it.
03:20:25 <edwardk> but then you lose all the sexy overloading
03:20:40 <toast-opt> sorry, i was refering not to the typeclass construct, but this workaround technique such as 'showList'
03:20:58 <ski> (and gain the ability to use several different kinds of dictionaries for the same type(s))
03:21:16 <toast-opt> that you can accomplish the match you want only by adding more levels of type classes
03:21:25 <edwardk> well to call some method, you'd either use the static or the dynamic dispatch semantics. the static ones an be based on a bunch of complicated template specializations, the dynamic ones are vtable based.
03:22:25 <edwardk> toast-opt: the fact that those two are not clearly related is a bit of a wart in each of those languages. Gilad Bracha had a rant about it a while back
03:22:26 <ski> hm, i wonder if one couldn't say that the `showList' hack is a bit similar to techniques of "double dispatch" sometimes used in OO languages
03:22:48 <toast-opt> edwardk, oh, that might be an interesting read.  have a link?
03:23:06 <edwardk> looking for it
03:23:19 <edwardk> there was also a post on reddit showing this difference in c# just the other day
03:24:47 <toast-opt> eric lipperts blog?
03:25:03 <edwardk> toast-opt: http://apisuckage.wordpress.com/2009/12/10/did-you-know-overload-resolution-is-broken-in-c/
03:25:38 <edwardk> and gilad's rant: http://gbracha.blogspot.com/2009/09/systemic-overload.html
03:26:34 <edwardk> i don't particularly agree that it is a problem, but it is interesting to note that you need to think about two distinct sets of semantics
03:27:17 <ski> (`abstract class Show {static void show(This); static void showList(List<This> ts) {show(ts); } } final class Char extends Show {static show(Char c) {...} static void showList(List<Char> cs) {...}}' ?)
03:28:44 <toast-opt> heh, i don't envy F# developers on this issue.  dealing with both parametric polymorphism and method overloading in close proximity
03:29:02 <edwardk> ski: class List<T> extends Show { static show(List<T> cs) { showList(cs); } } -- or something like that
03:29:29 <toast-opt> necessary evil to interoperate with languages that use overloading on static type information
03:29:32 <edwardk> toast-opt: well, f# and scala both suffer from type-system-asplosion as a result of trying to play in those waters ;)
03:31:19 <tensorpudding> how does method overloading work alongside parametric polymorphism?
03:31:38 * hackagebot upload: hpage 0.5 - A scrapbook for Haskell developers (FernandoBenavides)
03:31:59 <ski> edwardk : iirc, the default implementation of `showList' is `showList = show' (calling from `Show a' to `Show [a]')
03:32:06 <ski> (i.e. not the other way around)
03:32:08 <geoaxis> hello people, i have a type definition type Pos = (Int,Int), and i would like to make a quickcehck generation of the numbers with in a range , and i cannot figure out how to do it with arbitrary class , any ideas
03:32:34 <toast-opt> edwardk, what's the explosion?
03:32:45 <geoaxis> I cannot make this type to a data
03:32:56 <edwardk> ski: i was providing the instance for List<T> -- if you check the instance for a -> Show [a]  -- it should be basically show = showList
03:34:01 * ski just checked it up ..
03:34:08 <ski> .. i remembered the wrong way
03:34:28 <edwardk> i only know because i've had to implement that pattern a half-dozen times ;)
03:35:21 <ski> edwardk : yes .. for some reason i was thinking it was the other way around (i.e. `class Show a where ...; showList = show',`instance Show a => Show [a] where show .. = ...')
03:39:43 * hackagebot upload: hpage 0.5.1 - A scrapbook for Haskell developers (FernandoBenavides)
03:44:19 <mikste> geoaxis, I would define a newtype wrapper for Int, say MyInt, with an Arbitrary instance that generates the range I want.  I'd then unwrap that within my tests.
03:47:01 <geoaxis> mikste, thanks, let me try
03:52:49 <viator_sg> What means ~ in a pattern maching? like "fmap f ~(a : e) = ..."
03:54:17 <jmcarthur_work> viator_sg, lazy pattern matching. doesn't force the argument unless actually needed in the rhs
03:54:47 <eivuokko> viator_sg, lazy.  It evals the ctor (:) only when it has to.
03:55:00 <geoaxis> mikste: i am not quite following you, I did this http://pastebin.ca/1711354
03:56:02 <jmcarthur_work> geoaxis, i would make Pos a newtype instead of a type
03:57:00 <viator_sg> then, by default pattern matching always eval the constructor ?
03:57:40 <benmachine> viator_sg: it has to determine whether the pattern matched or not
03:57:51 <jmcarthur_work> viator_sg, only if you are matching on the constructor. if the pattern is just "a" or something then it will not
03:58:10 <geoaxis> jmcarthur: not possible
03:58:11 <benmachine> e.g. if you have a list and want to match it against a (x:xs) pattern, you have to evaluate it enough to know that it's non-empty
03:58:15 <jmcarthur_work> (foo a) will not force anything, but foo (x:xs) will
03:58:20 <jmcarthur_work> geoaxis, why not?
03:58:54 <viator_sg> Ok, thanks :)
04:00:24 <mikste> geoaxis, http://pastebin.ca/1711358
04:00:51 <mikste> geoaxis, Use makePos within your tests to generate a Pos
04:08:09 <copumpkin> wow, somsone needs to fix that server
04:46:03 <Tobsan> pastah_rhymez: are you still in monaden?
04:49:05 <pastah_rhymez> Tobsan: at home
04:55:03 <EvanR-work> quick. whats the haskell code for this algorithm: http://en.wikipedia.org/wiki/Bogosort
04:57:47 <monochrom> first you have to write a random shuffle. look for "haskell random shuffle" and "haskell perfect shuffle"
04:57:57 <EvanCarroll> transpose' :: [[a]] -> [[a]] ; transpose' ([] _) = [] ; transpose' (_ []) = [] ; transpose' ( (x:xs) (y:ys) ) = x:y : transpose' xs ys
04:58:00 <EvanCarroll> why doesn't that work?
04:58:21 <monochrom> In fact, http://www.haskell.org/haskellwiki/Random_shuffle
04:59:26 <EvanCarroll> I was trying to rewrite transpose but my version doesn't work and I don't understand why
05:00:00 <EvanR-work> random shuffling, an exciting topic
05:01:20 <int-e> EvanCarroll: what is ([] _) supposed to match?
05:02:46 <ben> > case "x" of [] _ -> "hooray"
05:02:55 <lambdabot>   Constructor `[]' should have no arguments, but has been given 1
05:03:15 <EvanCarroll> int-e: i would have expected it to match an empty list followed by anything
05:03:18 <int-e> EvanCarroll: Actually I'm really tempted to ask why you expect that to work.
05:03:55 <int-e> so [[]], [[],[]], [[],[()]] and so on? that would be ([]:_)
05:04:27 <EvanCarroll> no, doesn't [], only match []
05:05:08 <int-e> [] then?
05:05:22 <int-e> "followed by
05:05:29 <int-e> " - what does that mean here?
05:05:30 <EvanCarroll> I didn't say []:, I said "[] "
05:05:56 <EvanCarroll> if you're sending in two lists, I wanted to pattern match on an empty first list.
05:06:02 <int-e> EvanCarroll: I know what you wrote. I was making a guess about what you /meant/.
05:06:16 <int-e> you're not sending in several lists. your argument is a list of lists.
05:07:00 <EvanCarroll> my argument is a expression, I want it to evaluate that expression and find two lists, I want the first of those lists to be empty.
05:07:16 <mauke> what kind of expression is "two lists"?
05:07:22 <int-e> maybe this helps: [[1,2],[3,4]] is the same as [1,2]:[3,4]:[] is the same as (1:2:[]):(3:4:[]):[]
05:10:08 <ezyang> "Suppose you have types a,b such that b = 1 + a b."  What is this sentence supposed to mean?
05:10:42 <mauke> data B = Foo | Bar (A B)
05:10:49 <Berengal> ezyang: B = One | Bar (A B)
05:10:53 <ezyang> ah.
05:11:00 <EvanCarroll> int-e: ([]):(3:4:[]):[] how would pattern match that., and how would you pattern match ([1:2]):([]):[]
05:11:12 <mauke> [1:2] makes no sense
05:11:29 <EvanCarroll> int-e: ([]):(3:4:[]):[] how would pattern match that., and how would you pattern match ([1:2:[]]):([]):[]
05:11:39 <mauke> like that
05:11:48 <copumpkin> ezyang: if you make that 1 + a * a, and take the fixed point of that, you get a tree that carries no information!
05:12:12 <copumpkin> ezyang: the fixed point of 1 + a * b is a regular list
05:12:28 <ezyang> copumpkin: That's what I'm reading about right now
05:12:40 <copumpkin> :)
05:12:50 <ezyang> What is A supposed to represent?
05:13:02 <copumpkin> hm?
05:13:15 <copumpkin> the data being carried
05:13:27 <copumpkin> if you rename One to Nil and Bar to Cons
05:13:37 <copumpkin> B = Nil | Cons A B
05:13:48 <ezyang> oh, that makes *a lot* more sense
05:13:54 <ezyang> The parens were confusing me
05:13:57 <copumpkin> :)
05:14:47 <int-e> EvanCarroll: well, some ideas ... [] (the case of no lists), ([]:xss) (the case where the first list is empty), and ((x:xs):xss) (the case where the first list is non-empty).
05:15:19 <ezrakilty> is A meant to be a functor? Or a type of kind * -> * ?
05:15:27 <ezyang> ezrakilty: No.
05:15:29 <EvanCarroll> int-e: and how would you write the same thing if only the second list was empty?
05:15:32 <ezyang> It's a normal type
05:15:54 <ezrakilty> ezyang: what are you reading? was there really no punctuation between 'a' and 'b'?
05:15:57 <copumpkin> well, it typically is a functor
05:15:58 <int-e> EvanCarroll: (_:[]:_) (or (xs:[]:xss)
05:16:01 <int-e> )
05:16:08 <copumpkin> because that allows you to recurse over the type
05:16:17 <copumpkin> in haskell
05:16:19 <ezyang> http://monoidal.blogspot.com/2009/08/some-thoughts-and-exercises-on-folding.html
05:16:24 <copumpkin> data ListF a b = Nil | Cons a b
05:16:30 <copumpkin> data List a = Mu (ListF a)
05:16:40 <ezyang> copumpkin: ListF is a functor; but a isn't...
05:16:50 <copumpkin> oh, yeah
05:17:11 <copumpkin> in this case, ListF is a functor and List is too!
05:17:13 <copumpkin> magick!
05:17:22 <Berengal> It's a type constructor, which is what matters
05:17:47 <Berengal> (ListF a, that is)
05:18:01 <ezyang> I'm so used to thinking of lists as cons and car that the isomorphism is pretty second nature to me.
05:18:30 <copumpkin> ezyang: another fun experiment is to think of Mu Maybe
05:18:43 <ezyang> copumpkin: What's Mu?
05:18:48 <Berengal> @src Mu
05:18:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
05:18:49 <copumpkin> type fixed point
05:18:57 <copumpkin> like fix, but for types
05:19:06 <Berengal> What was the lunabot syntax for src again?
05:19:15 <Berengal> It has a better Mu definition
05:19:44 <copumpkin> , [$src| ''Mu |] -- or something
05:19:45 <lunabot>  luna: parse error (possibly incorrect indentation)
05:19:48 <copumpkin> guess not
05:19:52 <Berengal> ,src ''Mu
05:19:59 <ezyang> copumpkin: Huh. I don't even understand how fix is useful
05:20:01 <lunabot>  newtype Mu f = Mu (f (Mu f))
05:20:06 <ezyang> > fix (+1)
05:20:07 <Berengal> \o/
05:20:10 <ezrakilty> in that post, I think 'a' was meant to be the product-with-a functor
05:20:10 <lambdabot>   mueval-core: Time limit exceeded
05:20:20 <ezyang> > fix (*2)
05:20:23 <copumpkin> ezyang: have you played with lambda calculus?
05:20:24 <lambdabot>   mueval-core: Time limit exceeded
05:20:33 <ezyang> copumpkin: only in passing
05:20:33 <copumpkin> > fix (+1) :: Natural > 0
05:20:34 <lambdabot>   Only unit numeric type pattern is valid
05:20:42 <copumpkin> > (fix (+1) :: Natural) > 0
05:20:45 <lambdabot>   mueval-core: Time limit exceeded
05:20:48 <copumpkin> > (fix (1+) :: Natural) > 0
05:20:49 <lambdabot>   True
05:21:10 <copumpkin> ezyang: have you ever wondered how you'd do recursion in it?
05:21:15 <copumpkin> ezyang: since you can't name things
05:21:17 <ezyang> Wait, I thought (1+) doesn't have a fixpoint
05:21:21 <ezyang> copumpkin: Y combinator
05:21:33 <ezyang> :-)
05:21:35 <copumpkin> ezyang: it does, if you're lazy enough
05:21:44 <int-e> @pl \xs xss -> zipWith (:) xs (xss ++ repeat [])
05:21:45 <lambdabot> (. (++ repeat [])) . zipWith (:)
05:21:47 <copumpkin> ezyang: that's more or less what fix is, given the constraints of our type system
05:21:49 <ezyang> copumpkin: Huh?
05:21:56 <ezyang> copumpkin: Ah. Cool.
05:22:06 <copumpkin> ezyang: Natural is lazy naturals, peano style
05:22:10 <ezyang> (huh is re "if you're lazy enough")
05:22:15 <copumpkin> fix (1+) === let x = 1 + x in x
05:22:16 <ezrakilty> :src Natural
05:22:25 <Berengal> > fix (In . Just . out) < In Nothing
05:22:26 <lambdabot>   Couldn't match expected type `L.Mu Data.Maybe.Maybe'
05:22:26 <lambdabot>         against inferr...
05:22:27 <copumpkin> it's basically infinity
05:22:34 <ezyang> oh, I see!
05:22:43 <copumpkin> the number that is its own successor
05:22:44 <ezyang> so as long as we don't actually make GHC evaluate it we're ok.
05:22:54 <copumpkin> well, it can be evaluated by lazy-enough functions
05:23:00 <copumpkin> like > on naturals
05:23:04 <Berengal> > fix (In . Just) < In Nothing
05:23:05 <lambdabot>   No instance for (GHC.Classes.Ord (L.Mu Data.Maybe.Maybe))
05:23:05 <lambdabot>    arising from a...
05:23:10 <Berengal> :(
05:23:13 <copumpkin> if one of the two parameters is finite, it'll finish recursing
05:23:19 <copumpkin> and fix (1+) will still be bigger than it
05:23:21 <ezyang> *nod*
05:23:41 <ezyang> Hmm, I wonder how I'd recurs-ify a function with fix
05:23:47 <copumpkin> ezyang: I was just getting to that :)
05:23:55 <copumpkin> say you have your typical fibonacci definition
05:24:09 <copumpkin> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:24:19 <copumpkin> you see that the name of the value is fibs
05:24:23 <copumpkin> and that it refers to itself twice
05:24:29 <ezyang> yup
05:24:29 <Berengal> ezyang: lift the recursion out a parameter 'f', then fix
05:24:40 <copumpkin> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
05:24:40 <Berengal> to a*
05:24:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:24:48 <copumpkin> ezyang: pretty simple, eh :)
05:25:09 <copumpkin> all fix does is take care of passing the value back to itself
05:25:13 <ezyang> oh... you get to pass itself
05:25:15 <ezyang> Hahaha!
05:25:18 <ezyang> Sweet!
05:25:26 <ezyang> oh man
05:25:32 <copumpkin> you can write any recursive function that way
05:25:56 <idnar> not that you'd want to
05:25:56 <ezyang> so... what makes fix different from the Y combinator?
05:26:13 <Berengal> > fix (\map -> \f -> \l -> if null l then [] else f (head l) : map f (tail l)) (+1) [1,2,3]
05:26:14 <lambdabot>   [2,3,4]
05:26:18 <ezrakilty> Y is a particular fixpoint combinator in lambda calculus
05:26:29 <Berengal> Y isn't well typed
05:26:33 <copumpkin> Y is typically defined as
05:26:34 <copumpkin> Y = λf·(λx·f (x x)) (λx·f (x x))
05:26:40 <copumpkin> which we can't write
05:27:00 <Berengal> @type fix fix
05:27:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
05:27:02 <lambdabot>     Probable cause: `fix' is applied to too many arguments
05:27:02 <lambdabot>     In the first argument of `fix', namely `fix'
05:27:04 <copumpkin> a higher-order function that applies a function to itself can't be typed
05:27:05 <int-e> @src fix
05:27:05 <lambdabot> fix f = let x = f x in x
05:27:21 <copumpkin> (an arbitrary function, at least. With higher-rank polymorphism we can do specific instances of it)
05:27:29 <RadioApeShot> What is the indentation supposed to look like if I put a do in one of the branches of a case?
05:27:51 <Berengal> RadioApeShot: indent further than the first letter of the beginning of the pattern, I think
05:28:03 <RadioApeShot> I probably shouldn't be using emacs - it seems pretty confused, even with haskell-mode, about the indentation of haskell code.
05:28:24 <RadioApeShot> Berengal: thanks
05:28:38 <Berengal> RadioApeShot: There are several indentation modes. Look in the haskell-mode options. Some are better than others
05:28:39 <copumpkin> ezyang: so getting back to Mu
05:28:46 <ezyang> ok. So f (fix f) != fix f
05:28:59 <copumpkin> ezyang: no, you can talk of it like that too
05:29:10 <copumpkin> we write the let definition because it's more efficient
05:29:17 <ezyang> ah.
05:29:26 <Berengal> > let fix f = f (fix f) in fix (\map -> \f -> \l -> if null l then [] else f (head l) : map f (tail l)) (+1) [1,2,3]
05:29:26 <ezyang> Ok. So the Y combinator is a specific way of getting that property
05:29:27 <lambdabot>   [2,3,4]
05:29:32 <copumpkin> but Mu is defined like the version you just wrote
05:29:35 <ezyang> and we do it differently because we can't use the lambda trick
05:29:37 <ezyang> Ok.
05:29:38 <copumpkin> (the type-level fixed point)
05:29:43 <copumpkin> yeah
05:29:52 <copumpkin> , src ''Mu
05:29:55 <lunabot>  newtype Mu f = Mu (f (Mu f))
05:30:10 <ezyang> I'm having difficulty figuring out what a type level fixed point would mean
05:30:12 <ezyang> I guess it's got to do something with recursive types
05:30:32 <copumpkin> type Fix f = f (Fix f) would be the ideal
05:30:37 <copumpkin> but haskell doesn't allow that
05:30:40 <Berengal> Just consider type constructors to be regular functions, and types to be values, and Mu === fix
05:30:42 <copumpkin> so we need additional constructors in the way
05:31:09 <ezyang> ok, so back to the original example
05:31:14 <ezyang> Mu Maybe
05:31:21 <copumpkin> if you ignore the Mu for a moment
05:31:22 <ezyang> Wait, isn't that just a cons list?
05:31:24 <copumpkin> you're basically getting
05:31:30 <copumpkin> Maybe (Maybe (Maybe (Maybe (Maybe (Maybe ...
05:31:42 <copumpkin> ezyang: it's almost a cons list
05:31:43 <ezyang> oh
05:31:45 <copumpkin> a value of it could be
05:31:46 <ezyang> ok, it's contentless
05:31:47 <copumpkin> Nothing
05:31:50 <copumpkin> or Just Nothing
05:31:54 <copumpkin> or Just (Just Nothing)
05:32:09 <ezyang> It's sort of like peano numerals
05:32:14 <copumpkin> yep, isomorphic :)
05:32:33 <EvanCarroll> How would I capture the first element, of the first list, in a function taking lists-of-lists through pattern matching?
05:32:54 <ezyang> ((x:_):_)
05:32:58 <monochrom> (x:xs):xss
05:34:15 <EvanCarroll> oh wait.
05:34:19 <EvanCarroll> I think a bell just went off
05:34:26 <copumpkin> ezyang: and you can see it just like I converted fibs earlier. data Peano = Zero | Suc Peano. Ooh, it refers to itself: data PeanoF a = Zero | Suc a (this is the lambda we wrote earlier for fibs, but can't write type-level lambdas so we need to name it). Then Mu PeanoF is Peano just like fix (\fibs -> ...) was fibs
05:34:41 <EvanCarroll> That helps thanks ezyang
05:34:48 <EvanCarroll> and monochrom ;)
05:34:55 <ezyang> copumpkin: Yeah.
05:35:19 <copumpkin> ezyang: so all this fix stuff is just an exercise in factoring out the recursion from the "meat" of your functions or types
05:35:36 <ezyang> And then, data listF a b = Zero | Suc a b
05:35:52 <copumpkin> yeah, although I wouldn't necessarily call the constructors that :)
05:36:04 <ezyang> oh, right -)
05:36:26 <monochrom> data ListF a b = Succ | Zero a b
05:36:30 <copumpkin> lol
05:36:35 <idnar> zero is not the successor of any natural number
05:36:48 <copumpkin> idnar: how about the unnaturals?
05:36:53 <monochrom> data Succ a = Maybe a | Pred
05:36:55 <idnar> copumpkin: I wouldn't know about those
05:37:04 <copumpkin> idnar: bigot!
05:37:13 <idnar> heh
05:37:17 <copumpkin> :)
05:37:35 <idnar> I'm thinking of that scene in GEB where the Crab can play algebraic formulae as musical compositions
05:37:56 <roconnor> N+Z <-- unnatural numbers?
05:37:56 <ezyang> is that the breaking record one?
05:37:58 * roconnor is thinking of non standard models
05:38:01 <monochrom> data CanHaz a = Haz a | IEatedIt | NoThatsMe
05:38:10 <idnar> ezyang: nah
05:38:13 <int-e> monochrom: I guess you write programs with identifiers I1, I2, ... and i1, i2, ... (i being short for "identifier") ;)
05:38:16 <ben> What is NoThatsMe for?
05:38:24 <copumpkin> lol
05:38:27 <int-e> monochrom: after all, names don't matter to the compiler.
05:38:33 * ezyang goes and gets his GEB 
05:38:47 <idnar> data Lul a = Wut a b | Huh
05:38:56 <monochrom> No, I use identifiers 0, 1, 2, 3 and numeral literals i, ii, iii.
05:38:57 <EvanCarroll> fuck, i just don't get this
05:38:58 <int-e> oh. GEB had variables a, a', a'' and so on?
05:38:59 <copumpkin> it's a mmorrow!
05:39:15 <mmorrow> i can create 944 pthreads  http://people.redhat.com/alikins/tuning_utils/thread-limit.c
05:39:15 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:39:18 <idnar> wait, these two conversation threads are unrelated
05:39:18 <copumpkin> roconnor: N + fix(suc) + pred(zero) = unnaturals!
05:39:19 <mmorrow> copumpkin: oh hai!
05:39:20 <idnar> stop confusing me!
05:39:25 <EvanCarroll> transpose' ( (x:xs):(y:ys) ) = [x:y : transpose' [xs,ys]
05:39:29 <EvanCarroll> why doesn't that work?
05:39:51 <ezyang> EvanCarroll: You're missing a brace?
05:39:52 <roconnor> > pred 0 :: Natural
05:39:53 <lambdabot>   * Exception: Natural: pred 0
05:39:56 <copumpkin> EvanCarroll: you really want a singleton list?
05:40:04 <ezyang> *bracket
05:40:17 <copumpkin> this netsplit shit is getting really annoying
05:40:27 <idnar> netsplatter
05:40:27 <int-e> transpose' ( (x:xs):(y:ys):[] ) = (x:y:[]) : transpose' [xs,ys]
05:40:33 <int-e> would work
05:40:42 <EvanCarroll> ezyang++ # it just didn't copy, it still fails with it
05:40:54 <EvanCarroll> int-e: why is what i did different from that?
05:40:54 <mmorrow> int-e: so i'm confused slightly about exactly what problem your idea about the pointer finding algo is targeted at
05:40:54 <idnar> why not [x, y]?
05:40:55 <int-e> with the obvious limitation that it only deals with the case of two lists
05:41:01 <int-e> EvanCarroll: yes.
05:41:08 <EvanCarroll> oh
05:41:09 <xerox> > foldr (zipWith (:)) (repeat []) [[1,2],[3,4],[5,6]]
05:41:10 <lambdabot>   [[1,3,5],[2,4,6]]
05:41:23 * ezyang has finished practicing the basic fold, and now is attempting the unfold 
05:41:35 <int-e> idnar: I tried to preserve as much of the shape as possible
05:41:39 <mmorrow> int-e: there's the possibly-invalid-slash-null-ptrs-in-a-known-ptr-slot thing, and then there's the ___?
05:41:47 <xerox> (this break in some case I forget which one)
05:42:25 <int-e> > foldr (\xs xss -> zipWith (:) xs (xss ++ repeat [])) [] [[1,2,3],[4,5],[6]]
05:42:26 <lambdabot>   [[1,4,6],[2,5],[3]]
05:42:39 <mmorrow> has anyone else run that thread-limit.c ?
05:42:48 * mmorrow is interested in how many threads other people can create
05:42:54 <Veinor> > transpose [[1,2,3],[4,5],[6]]
05:42:54 <ezyang> I can try running it
05:42:55 <lambdabot>   [[1,4,6],[2,5],[3]]
05:42:59 <mmorrow> ( http://people.redhat.com/alikins/tuning_utils/thread-limit.c )
05:43:06 <int-e> mmorrow: there's registers, stuff on the stack - part of the thread's state where some words may be pointers to the heap.
05:43:10 <ezyang> as long as it doesn't hax0r my computer
05:43:27 <ezrakilty> Having trouble building the type-level package from cabal. It fails to find "Data.Generics," saying it is in a hidden package; but I can load Data.Generics fine from GHCi.
05:43:44 <ezyang> :-)
05:43:52 <ezrakilty> Any ideas what that means?
05:44:06 <ezyang> "Failed with return code 11 creating thread 382."
05:44:11 <mmorrow> int-e: right. so we're assuming that there aren't always bitmaps/some-info-to-use-to-find-ptrs available?
05:44:44 <int-e> mmorrow: I guess we should define a goal first - say, to be able to do GC even when some thread is in the middle of some non-allocating thread. And I was thinking about how far you can get without adding meta-information to the code.
05:45:00 <mmorrow> int-e: i guess what i'm confused about is what the motivation for your scheme is, since i initially thought it was related to the invalid-ptrs thing, but it appears not
05:45:10 <mmorrow> ahhh, ok.
05:46:20 <int-e> mmorrow: I didn't notice at first that I'd have to keep some objects in from-space alive, because the scheme wouldn't be able to move them - the conjectured pointer might actually be a non-pointer value. that's somewhat discouraging.
05:47:07 <mmorrow> int-e: yeah, any sort of imprecise method of finding ptrs scares the crap out of me
05:47:48 <mmorrow> int-e: and in the invalid ptr case too, there'd already be the info needed to know what's a ptr, it's just that what should be a valid pointer is either null or a garbaqe value
05:47:53 <mmorrow> *garbage
05:48:21 <mmorrow> int-e: ohh. ok, now i'm remembering all the points of our previous discussion.
05:49:45 <mmorrow> so we concluded we'd either need to test ptrs prior to dereferencing them, or keep additional meta-data about which ptrs could possibly be invalid, or some way to do the meta-data thing but avoid a huge amount of metadata
05:49:46 <mmorrow> (reminding myself here)
05:49:46 <mmorrow> so you're after (3) there?
05:50:37 <mmorrow> (also, is that all the things we concluded?)
05:51:22 <int-e> That was (1) actually - no meta-data, so having to deal with garbage (non-pointers) that looks like pointers.
05:51:45 * int-e wonders if this is the right place for this discussion
05:51:45 <mmorrow> (i guess you could also catch SIGSEGV (and make sure that any invalid ptr in NULL) :)
05:51:56 <mmorrow> int-e: ah, ok.
05:52:01 <mmorrow> int-e: yeah, true
05:52:32 <Veinor> not like there's much else going on :P
05:54:06 <mmorrow> ezyang: ah, just saw your response
05:54:23 <mmorrow> ezyang: interesting, are you on 32bit?
05:54:30 <ezyang> Yup
05:54:37 <ezyang> I have access to a 64-bit box and can try there
05:54:41 <mmorrow> how much ram? (two cores?)
05:55:14 <mmorrow> ezyang: don't go to any trouble, i'm just curious in general (but if you want to, i won't stop you :)
05:55:20 <ezyang> Two cores, 3G RAM
05:59:19 * ezyang is mildly annoyed that monoidal didn't specify endianness 
05:59:19 <mmorrow> ezyang: no specific objective, i just read http://www.kegel.com/c10k.html which lead me to https://listman.redhat.com/archives/phil-list/2003-August/msg00005.html which in turn linked to that .c
05:59:19 <mmorrow> *led
05:59:19 <Baughn> Boxen (n): Hackingnese plural of "box", a cart full of cupholders.
05:59:55 <mmorrow> ezyang: and that msg is from 2003, and he's surprised that he "only" could create 32K threads..
06:00:02 <mmorrow> ... !
06:00:04 <ezyang> heh
06:00:35 <ezyang> "my how we've regressed"
06:01:05 <ezyang> Hmm... I kind of curious about some really clever unfolds
06:01:33 <EvanCarroll> integral: that doesn't work still
06:01:58 <EvanCarroll> transpose' ( ([]) : _    ) = []; transpose' ( _    : ([]) ) = []; transpose' ( (x:xs),(y:ys):[] ) = (x:y:[]): transpose' [xs,ys]
06:02:43 <EvanCarroll> ~oh wait
06:02:50 <EvanCarroll> (x:xs):(y:ys)
06:03:01 <EvanCarroll> why can I not convert to the [] form in pattern matching?
06:03:42 <benmachine> you can?
06:03:48 <Berengal> EvanCarroll: What do you mean?
06:03:57 <Berengal> List literals are allowed in patterns
06:03:59 <benmachine> > let f [x, y] = y * x in f [2, 3]
06:04:00 <int-e> you can write [x:xs, y:ys] instead, as a pattern
06:04:01 <lambdabot>   6
06:04:10 <ezyang> Hmm, this Mu discussion has made me want to go and reread "Winging it"
06:04:19 <EvanCarroll> ah that's how it would be written?
06:04:45 <EvanCarroll> =)
06:05:25 <EvanCarroll> that looks weird and wrong =/
06:05:35 <EvanCarroll> [x:xs, y:ys]
06:08:27 <dibblego> EvanCarroll, [] is just another data type that you can use in pattern matching; data [a] = [] | a : [a]
06:09:04 <ray> putting special syntax aside, it's not magic
06:09:13 * copumpkin swears at brown.freenode.net some more
06:09:29 <ezyang> meh, I still don't understand it
06:09:35 <ezyang> I guess... time to read more papers
06:09:51 <copumpkin> ezrakilty: don't understand what?
06:09:56 <copumpkin> ezyang I mean
06:10:08 <ezyang> The slides. :-)
06:10:36 <copumpkin> :o
06:10:47 <ezyang> He gets to the one where he suddenly adds new kinds for types, and then I'm like "doink"
06:10:48 <fracture> anyone here used HSDL on win32?  I'm having a problem where the program doesn't always exit when main returns...
06:11:22 <copumpkin> ezyang: I missed that, I think it went off my scrollback due to these fucking netsplits
06:12:22 * ezyang is now reading "The Zipper" 
06:12:28 <ezyang> I think this is the third time I've attempted to read this one
06:13:12 <copumpkin> Jack the Zipper?
06:13:50 <ezyang> Huet the Zipper. :-)
06:14:17 <copumpkin> Gérard le Zippeur
06:15:17 <monochrom> Oleg the Zipper Continuer.
06:15:53 <ezyang> oh, I also remember: I don't know ocaml syntax
06:16:08 <ezyang> which didn't help
06:20:17 <Berengal> ML-languages tend to have a rather consistent syntax inbetween themselves...
06:20:33 <Berengal> Including Haskell
06:20:53 <Berengal> It probably helps that the languages have such simple foundations
06:20:56 <ezyang> Yeah. The two look kind of similar. Unfortunately, there seem to be sufficient differences for me to get confused.
06:21:18 <ezyang> for example, I don't know how to parse this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13994#a13994
06:22:19 <ezyang> oh wait, "tree list" is a single type, isn't it...
06:23:00 <Berengal> I'm not sure, but I think it's [tree]
06:23:13 <ezyang> that seems plausible
06:23:30 * Berengal had a very brief stint with sml a year ago
06:24:53 <monochrom> I can translate that for you.  data Tree = Item Item | Section [Tree].  You will need a type called Item.
06:25:19 <monochrom> Yes, ocaml "x y" is Haskell "Y X".
06:25:21 <ezyang> ok, that's what I was thinking
06:25:28 <ezyang> That's kind of... weird :-).
06:25:49 <ezyang> ok, time to figure out what * means...
06:25:57 <monochrom> "int array" is more English than "Array Int".
06:26:13 <ezyang> ok, that looks like a cartesian product
06:26:34 <monochrom> Yes, (x,y) for tuple value, t*u for tuple type
06:26:36 <byorgey> ezyang: yep
06:27:01 <copumpkin> ezyang: have you seen the curious list derivation?
06:27:11 <monochrom> And actually, ocaml "(x*z*t) y" is haskell "Y X Z T"
06:27:23 <monochrom> oops nevermind, that's wrong.
06:27:42 <ezyang> copumpkin: nope
06:27:48 <copumpkin> ezyang: not really sure what to call it, but I admit that's a bad name
06:27:50 <monochrom> ocaml "constructor of x*z*t" is haskell "Constructor X Z T"
06:28:21 <monochrom> And finally, ocaml can get away with lowercase type names because type variables must be like 'a, 't, 'x.
06:28:49 <zachk> > let fac n = product [1..n] in let e = head $ drop 1000 $ scanl (\x y->1/((fromInteger.fac) y)+x) 0 [1..] in e
06:28:50 <lambdabot>   1.7182818284590455
06:28:55 <zachk> :-D
06:29:34 <Veinor> off by 1 errors strike again!
06:29:53 <Veinor> > [1..0]
06:29:54 <lambdabot>   []
06:29:56 <Veinor> > product []
06:29:57 <lambdabot>   1
06:30:00 <Veinor> nice.
06:30:05 <ezyang> Ok. I'm looking at the path structure in the zipper
06:30:10 <copumpkin> if you have List a = Nil | Cons a (List a), you can change that to List a = 1 + (a * List a), and rearrange that to get List a - a * List a = 1, and factor to get List a * (1 - a) = 1, divide to get List a = 1 / (1 - a). Now we have a weird expression with differences and quotients of types which makes no sense, but if you ignore that for a minute and replace 1 / (1 - a) with its expansion as a geometric series, you get List a = 1 
06:30:11 <copumpkin> a^2 + a^3 + a^4 + ..., which is actually correct. Weird, eh? :P
06:30:21 <ezyang> I think that's the important bit, and I don't think I quite understand it.
06:30:21 <zachk> > let fac n = product [1..n] in let e = head $ drop 1000 $ scanl (\x y->1/((fromInteger.fac) y)+x) 0 [0..] in e
06:30:23 <lambdabot>   2.7182818284590455
06:30:48 <ezyang> copumpkin: Whoa
06:30:55 <xerox> umbral type-calculus
06:31:06 <copumpkin> dolio posted that on reddit a while ago
06:31:07 <ezyang> copumpkin: That's uber neat.
06:31:25 <copumpkin> seems like there's something profound going on but I'm not sure what :)
06:31:42 <monochrom> It may be generalizable or it may be not.
06:31:53 <ezyang> monoidal did it using regular substitution
06:31:59 <monochrom> Nothing neat if not generalizable.
06:32:19 <ezyang> I guess... types truly are an algebra...
06:32:41 <Berengal> monochrom: How much generalizeable does it have to be to be neat?
06:33:14 <monochrom> All valid Haskell98 type definitions.
06:33:18 <EvanR-work> copumpkin: you just blew my mind
06:33:42 <Berengal> ezyang: Types come very close to set-theory...
06:34:15 * ezyang really wants a picture of a zipper, with the parts of the structure stuck around 
06:34:31 <Cale> copumpkin: It seems normal to me, because I'm used to generating series :)
06:34:58 <copumpkin> Cale: yeah, but generating series for types, involving subtraction and quotients of types (which we don't have meaningful definitions of as far as I know)?
06:35:25 <ezyang> peh, the Wikipedia article doesn't have any pics
06:35:40 <Cale> Well, these are more or less the same thing as species, and you have generating series for them
06:35:43 <byorgey> copumpkin: it can all be given perfectly good meaning via so-called "virtual species"
06:35:49 <copumpkin> aha!
06:35:56 <byorgey> copumpkin: it completely generalizes, list is not a special case =)
06:35:58 <copumpkin> sounds like something I need to add to my reading list :)
06:36:03 <copumpkin> sweet!
06:36:16 <Cale> and the quotients and differences aren't *really* quotients and differences of types, but of generating series
06:36:19 <ezyang> virtual species...
06:36:42 <Cale> Well, perhaps this virtual species thing can do something about it.
06:37:14 <byorgey> yeah, Cale, good point, even without virtual species it still makes perfect sense via generating series.
06:37:15 <copumpkin> this stuff? http://en.wikipedia.org/wiki/Combinatorial_species
06:37:28 <byorgey> copumpkin: yep
06:37:29 <Cale> copumpkin: yes
06:37:40 <byorgey> copumpkin: you can also take a look at some of my recent blog posts on the subject
06:37:45 <byorgey> (I need to get back to that at some point)
06:37:50 <Cale> http://cale.yi.org/share/Bergeron%20-%20Combinatorial%20Species%20and%20Tree-like%20Structures.djvu
06:37:59 <copumpkin> ooh
06:38:07 <copumpkin> oh no, djvu :(
06:38:16 <Cale> djvu is good for page scans :)
06:38:18 <copumpkin> :)
06:39:21 <byorgey> copumpkin: I have a dead-tree copy of that book checked out from the library, if you come to my office you can borrow it ;)
06:39:24 <Cale> You don't *really* need any category theory to do this stuff, but it's nice to know that the connection is there.
06:39:40 <copumpkin> byorgey: hah, I'll just run over right now :P
06:39:45 <copumpkin> but I probably can get it out of my library
06:39:53 <byorgey> probably =)
06:40:18 <Cale> Actually, that thing from the other day seems to suggest that the categorical approach can lead to some rather deep connections, but for the basic material it's mostly just a distraction. :)
06:40:35 <Cale> hmm, did I post that link here?
06:40:50 <luite> yes, thanks :p
06:40:51 <byorgey> Cale: agreed.  what link?
06:41:30 <luite> or what link?
06:41:44 <Cale> It was essentially a book on the connections between monoidal functors, species, and Hopf algebras
06:41:52 <Cale> http://www.math.tamu.edu/~maguiar/a.pdf
06:42:17 <luite> with the crazy diagrams? :p
06:42:20 <Cale> Most of it makes my brain explode, but I understand the gist of it.
06:42:29 <luite> ah I have seen it here
06:42:47 <Cale> Well, some crazy diagrams, not as crazy as some of the other higher category theory stuff I've been looking at :)
06:43:04 <Cale> Yeah, page 14 is nuts
06:43:07 <andrewsw-afk> > :t (<$>)
06:43:08 <lambdabot>   <no location info>: parse error on input `:'
06:43:18 <andrewsw-afk> > @type (<$>)
06:43:19 <lambdabot>   <no location info>: parse error on input `@'
06:43:25 <andrewsw-afk> @type (<$>)
06:43:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:43:30 <luite> yeah that's the one I remember :)
06:43:55 <Cale> But not *too* nuts, given that that polyhedron encodes almost the whole proof of a result.
06:43:58 * byorgey boggles
06:43:59 <sproingie> if it makes Cale's brane asplode, i think there's no hope for me understanding it
06:44:09 * byorgey is with sproingie 
06:44:41 <byorgey> @remember sproingie if it makes Cale's brane asplode, i think there's no hope for me understanding it
06:44:41 <lambdabot> Nice!
06:44:59 <Cale> The thing is that everything that it discusses are all topics of interest to me, but I'd have to read a lot more carefully and spend a lot of time to make full sense of it.
06:45:12 <luite> oh bah, 2 page scans (that species book), those are a pain to properly convert to pdf
06:45:32 <Cale> Why would you?
06:45:47 <ukl> hello. I'm confused. Binary trees are so well-behaved in Haskell, but trying to implement an (a,b)-tree seems kind of impossible to get right for me right now
06:45:47 <lambdabot> ukl: You have 1 new message. '/msg lambdabot @messages' to read it.
06:45:48 <Cale> Unless you're going to re-LaTeX the thing, it's pointless anyway
06:45:55 <luite> my ebook reader doesn't really support djvu (there is a crappy port of evince, but it hardly works)
06:46:01 <Cale> ah, okay
06:46:43 <luite> they actually look better as pdf too (using some ocr option that derives an outline font from the bitmaps)
06:46:53 <sproingie> pdf's are a non-starter on my reader (kindle)
06:47:00 <monochrom> What is an (a,b)-tree?
06:47:06 <sproingie> i can image them and view them that way but it's scrolly scrolly scrolly
06:47:21 <Cale> ukl: It's *possible* to encode the size restrictions in the types, but you're probably better off, for completely general a and b like that to just not use the type system to enforce that constraint
06:48:17 <Cale> ukl: For small, fixed a and b, you can do it easily of course, by just using multiple node constructors
06:48:17 <luite> monochrom: generalization of 2-3-tree
06:48:18 <ukl> Cale: well I could fix a=2 and b=5, the problem is, pattern matching and using guards gets kind of ugly with those many possibilities
06:48:25 <Cale> Indeed.
06:48:51 <Cale> You're probably just better off using rose trees, and enforcing the constraints using the module system.
06:48:56 <Cale> Or something like that
06:49:04 <ukl> Cale: the assignment says (2,5)-tree :/
06:49:49 <ukl> So, there's no obvious and easy way to do it that anyone more experienced than me would choose?  Ok then, just had to check ;)
06:50:03 <Berengal> ukl: You could switch to a dependently typed language...
06:50:12 <Berengal> But I'm guessing that's not an option
06:50:23 <ukl> Berengal: well... it could be
06:50:23 <Cale> Well... if you were Oleg, you could use type-level natural numbers.
06:50:39 <Cale> Haskell is *almost* a dependently typed language
06:50:47 <Berengal> Or you could use she to transform Haskell into a properly dependently typed language
06:51:07 <pastah_rhymez> i want to make an instance of Ix; is there a minimal imlementation (like compare to get Ord)
06:51:29 <Cale> Minimal complete instance: range, index and inRange.
06:51:32 <jmcarthur> *properly*?
06:51:36 <Cale> (from the documentation)
06:51:43 <pastah_rhymez> Cale: thanks for being awesome
06:51:50 <Cale> :)
06:52:41 <Cale> ukl: hmm, perhaps with GADTs it's not *too* crazy.
06:53:00 <copumpkin> bah, the djvu viewer locked up my browser
06:53:02 <ukl> Cale: any pointers to what not *too* crazy looks like?
06:53:11 <Cale> ukl: I'm going to give it a try. :)
06:54:23 <luite> hmm, ddjvu even crashes on that book
06:55:18 <Cale> luite: evince worksforme
06:55:48 <luite> Cale: can that convert the images to tiff, without scaling?
06:55:56 <Cale> ah
06:55:58 <Cale> hmm
06:59:33 <luite> strange, it crashes at some random location, one time it managed to convert almost the whole file (index and bibliography missing)
07:03:48 <ukl> it's late, got to go... good night.
07:03:51 <Cale> luite: maybe try converting the thing into separate pages first?
07:04:05 <Cale> djvused myfile.djvu -e 'select 5; save-page p05.djvu'  -- example command to extract page 5
07:05:10 <Cale> hmm
07:05:19 <dmead> > reverse [1..20]
07:05:20 <lambdabot>   [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
07:05:24 <luite> Cale: it works best to convert to a single multi-page tiff (acrobat can import it), I think my latest try is actually the whole file
07:06:13 <Cale> oh, much faster way to explode: djvmcvt -i Bergeron\ -\ Combinatorial\ Species\ and\ Tree-like\ Structures.djvu tmp/ index.djvu
07:08:34 <cocon> on OS X 'ghci' gives me Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (dlopen(libgmp.dylib, 9): image not found)
07:08:47 <cocon> any help would be greatly appreciated
07:10:37 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13996#a13996 <- Does this make sense?
07:10:52 <Berengal> Because if it does, I'm impressed with myself.
07:14:14 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13996#a13997 <- I could use type equality instead of the silly Constraint...
07:18:23 <Philonous> The largest drawback of shotgun debugging seems to be that it produces code that works even though you think it shouldn't. And that's the one thing that's worse than code that doesn't work even thought you think it should.
07:20:33 <Berengal> Philonous: Programming by coincidence, I believe the term is
07:22:17 <Vulpyne> All you need is a whole bunch of monkies and a whole bunch of terminals.
07:22:28 <ddarius> Vulpyne: And a solution to the Halting Problem...
07:22:37 <Vulpyne> I trust the monkies.
07:23:03 <Vulpyne> Er, monkeys. Knew that looked wrong.
07:28:14 <MarcWeber> Who is GwernBranwen ? Does someone have his irc name or an email address?
07:28:24 <copumpkin> gwern might be it
07:28:28 <copumpkin> just a hunch though
07:28:30 <copumpkin> ;)
07:28:32 <gwern> no, that's my evil twin
07:28:42 <gwern> we carpool sometimes but that's about it
07:29:03 <MarcWeber> gwern: He uploaded Interlude to hackage and I think it's broken.
07:29:10 <copumpkin> lol
07:29:18 <gwern> hadn't heard that interlude is broken
07:29:21 <gwern> know some people used it
07:29:45 <MarcWeber> gwern: Were you kidding? Am I talking to the correct person?
07:29:53 <gwern> no
07:30:02 <MarcWeber> the interlude.h file contains a tuple (__LINE,...) but the error function doesn't expect one.
07:30:15 <MarcWeber> After removing thoes "," characters it works for me as well
07:30:26 <MarcWeber> But I don't want to fix it and upload a new version without asking
07:31:23 <gwern> you mean '#define undefined (error ("Hit 'undefined' in "++__FILE__++", "++show (__LINE__ :: Int)))
07:32:06 <MarcWeber> http://dpaste.com/132243/ @ gwern
07:32:35 <MarcWeber> line 8,9 and type in line 21
07:32:46 <gwern> hm.
07:32:51 <gwern> I know it worked before
07:33:02 <gwern> so why does this fix it? did those functions change?
07:33:12 <MarcWeber> So did behaviour of cpp change?
07:33:27 <ben> > __LINE__
07:33:28 <lambdabot>   Not in scope: `__LINE__'
07:33:49 <MarcWeber> ben: __LINE__ is substituted by cpp, the C preprocessor
07:35:25 <MarcWeber> gwern: The package compiles. But when using it I get the type error that it can't match the function against the tuple (, , , )
07:37:52 <Berengal> Final version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13996#a13998
07:38:56 <Cale> http://www.haskell.org/ghc/download_ghc_6_12_1.html ???
07:39:31 <HaskellLove> I have 400 words as separate elements in list, I want to create 20 lists with 20 elements how to do that?
07:39:36 <luite> ooh shiny new ghc
07:39:48 <Berengal> Nice
07:40:34 <Berengal> HaskellLove: unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)), I think...
07:40:44 <Berengal> @type unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a))
07:40:44 <Cale> The download page doesn't link to it yet
07:40:45 <lambdabot> forall a. [a] -> [[a]]
07:40:52 <luite> oh dead links :(
07:41:22 <Berengal> So it's probably not released yet...
07:41:33 <Berengal> I'm guessing they're still packaging up?
07:42:31 <Cale> ah, the download links are 404s
07:43:02 <Berengal> Agda has changed my understanding of the Haskell type system quite a bit...
07:43:40 <copumpkin> same here :)
07:43:41 <HaskellLove> unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)): what unfoldr does here and why do you use Just?
07:44:06 <monochrom> Just as haskell changed your understanding of previous languages etc.
07:44:18 <copumpkin> what will change my understanding of agda?
07:44:53 <monochrom> formal methods
07:44:58 <Berengal> HaskellLove: look at the type of unfoldr
07:45:00 <Berengal> @type unfoldr
07:45:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
07:45:08 <doserj> Berengal: I think one of your Between instances is faulty
07:45:20 <monochrom> (you do not need to encode specifications as types. there are more direct ways.)
07:45:32 <copumpkin> monochrom: like what?
07:45:37 <Berengal> doserj: Could well be. Which one?
07:46:03 <doserj> Berengal: type instance Between Zero (Succ b) (Succ n)  = MoreEq b n
07:46:04 <monochrom> Like writing logical statements.
07:46:25 <doserj> that should be LessEq b n?
07:46:34 <monochrom> Write "implies" as "implies", not encode as "function".  Write "and" as "and", not encode as "tuple type".
07:46:45 <HaskellLove> Berengal can you please explain me your function I am new to functional programming i find it hard to understand it
07:46:49 <Berengal> doserj: Looks like you're right. That also goes for the other one using LessEq
07:46:56 <Berengal> Seems I switched them around
07:47:08 <Berengal> HaskellLove: Yeah, sorry, I was about to but got distracted :)
07:47:21 <Berengal> HaskellLove: Are you familiar with foldr and friends?
07:48:00 <doserj> Berengal: the other one looks right, I think. But you are using MoreEq and LessEq not in the argument order tha I expectred, anyways...
07:48:01 <HaskellLove> the fold family scares me Berengal, never used them...
07:48:43 <Berengal> HaskellLove: Well, they're pretty simple once you get to know them. Their basic useage is to reduce a list of values to a single value
07:48:57 <Berengal> doserj: I got confused myself...
07:49:18 <Berengal> HaskellLove: For example, 'foldr (+) 0' is a function that reduces a list of numbers to a single number by summing them up
07:49:42 <gwern> MarcWeber: well if those modifications work
07:49:44 <Berengal> HaskellLove: unfoldr does the opposite, in a way. It builds a list from a single value
07:49:57 <gwern> MarcWeber: send them to ketil; he's a responsive maintainer, I just do the uploads for him sometimes
07:50:11 <gwern> (it's not as if interlude is abandoned like many of my uploads)
07:50:40 <MarcWeber> gwern: I did. I'll wait some more days and then retry. Thank you for your information. It helped me a lot!
07:50:47 <gwern> it did?
07:50:50 <Berengal> HaskellLove: The function you feed to unfoldr is in a way the opposite of the ones you feed to foldr. The ones you feed to foldr take two arguments and return one value, and the ones you give to unfoldr takes one argument and returns two values
07:51:20 <MarcWeber> gwern: "I did" = I sent hem an email about two days ago.
07:51:21 <HaskellLove> Berengal nice explanation, so far is ok...
07:51:34 <Berengal> HaskellLove: However, unfoldr also needs to know when to stop, when we've "used up" the initial value, so to speak, so it wraps the returned values in a Maybe. When it returns Nothing, we stop.
07:52:08 <Berengal> HaskellLove: When it returns Just something, one of those values are put in the list while the other is fed to the function again in the next iteration.
07:52:25 <Berengal> HaskellLove: Does this make sense?
07:52:39 <HaskellLove> Berengal so far it is wonderful yes thank you
07:52:45 <ddarius> copumpkin, monochrom: See "Algebra of Programming in Agda"
07:52:59 <monochrom> Oh God.
07:53:31 <Berengal> HaskellLove: Alright, so we've got unfoldr. We just need a function we can repeatedly apply to a list to get the first 20 elements and the rest. This is simply the splitAt function
07:53:36 <Berengal> @type splitAt
07:53:37 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:53:43 <monochrom> I feel that it is like that funny book, something about "pride and prejudice" plus "zombies".
07:54:15 <ddarius> "Pride and Prejudice and Zombies"
07:54:48 <sproingie> Moby Dick and Zombies
07:54:48 <Berengal> HaskellLove: Since splitAt doesn't return a maybe, we check to see if the input list is empty and return Nothing in that case (no use in keep splitting an empty list), otherwise we return Just the result of splitAt
07:54:54 <Berengal> HaskellLove: Any questions?
07:55:00 <sproingie> The Holy Bible and Zombies
07:55:23 <copumpkin> Jesus was a zombie
07:56:14 <HaskellLove> foldr (+) 5 [1,2,3,4,5] Berengal> that means fold the list using that operation but i dont understand what that 5 does there?
07:56:33 <luite> @src foldr
07:56:34 <lambdabot> foldr f z []     = z
07:56:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:56:57 <Berengal> HaskellLove: That's the "zero" argument. It's what's used when the list has run out
07:57:00 <ddarius> "syndeton" was what I was looking for
07:57:36 <Cale> HaskellLove: foldr f z replaces each (:) in the construction of the list with f, and the [] at the end of the list with z
07:57:54 <ddarius> copumpkin: Not the only one.
07:57:59 <Cale> [1,2,3,4,5] is equivalent to writing  1 : (2 : (3 : (4 : (5 : []))))
07:58:16 <copumpkin> ddarius: oh yeah
07:58:22 <Cale> and so  foldr f z [1,2,3,4,5] is  f 1 (f 2 (f 3 (f 4 (f 5 z))))
07:59:09 <ddarius> I don't know why this is at absoluteastronomy.com, but this page is pretty handy: http://www.absoluteastronomy.com/topics/Figure_of_speech
07:59:15 <luite> hm, does that work with lambdabot?
07:59:19 <luite> > foldr f z [1,2,3,4,5]
07:59:20 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
07:59:51 <HaskellLove> Berengal> so foldr is like... factoring for example u do: 2*2*3*5 bla bla bla, and you can call these as "n" and in the end if u have something left you "+" add it so i see this zero argument in similar way, do this function and at the end do that...
08:00:25 * EvanR wonders if he can use unfoldr for this rng algorithm
08:00:46 <Berengal> HaskellLove: In a way, yes.
08:00:53 * ddarius is goign to start using "erotema"
08:01:09 <ddarius> EvanR: The answer is almost certainly "yes"
08:01:42 <Berengal> HaskellLove: foldr captures a certain recursion scheme. The (+) function we send in is what to do in the recursive case, and the "zero" is what to do in the base case
08:01:42 <mercury^> Is there a way to have Haskell automatically derive the catamorphism for a type?
08:01:57 <ddarius> mercury^: You could use the Derive library.
08:02:21 <ddarius> mercury^: Also, most of the generics libraries work by providing suitably general folds, e.g. Scrap Your Boilerplate.
08:02:29 <EvanR> Berengal: looks like you begin with the 'zero' not end with
08:02:34 <ddarius> So, technically deriving Data does that of sorts.
08:02:42 <HaskellLove> Berengal> that is the most wonderful explanation
08:03:04 <Berengal> EvanR: You mean in foldr?
08:03:12 <EvanR> yeah
08:03:23 <EvanR> the end of foldr is when the list runs out
08:03:33 <Berengal> Well, lazy evaluation means the innermost expression is the last one evaluated (in this case)
08:03:53 <EvanR> well i guess the order is irrelevant
08:03:56 <Berengal> foldr really does traverse the list in left-to-right order, if you think about it
08:04:20 <ddarius> There's no other way to traverse a singly-linked list...
08:04:36 <Berengal> foldl traverses it right-to-left, but since it's singly linked, it has to read the end first...
08:04:52 <Berengal> foldl f 0 = foldr (flip f) 0 . reverse, -ish
08:06:05 <EvanR> > foldr (++) 'z' "abcd"
08:06:08 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
08:06:08 <lambdabot>    arising from a use o...
08:06:12 <EvanR> >_<
08:06:36 <mmorrow> @type (++) {- do i detect Caleskell? -}
08:06:37 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:06:40 <mmorrow> :)
08:07:19 <HaskellLove> unfoldr :: (b -> Maybe (a, b)) -> b -> [a] ------------- Berengal> can you just help me read this please... I understood foldr but unfoldr i have troubles with seeing what this type means...
08:08:00 <EvanR> it takes the second argument, applies the function, gets list element and a new b, and starts over
08:08:08 <Berengal> HaskellLove: It might help to compare it to the type of foldr
08:08:10 <Berengal> @type foldr
08:08:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:08:30 <Berengal> Notice the initial function, a -> b -> b
08:08:59 <Berengal> With a bit of currying, we get (a, b) -> b, that is, a function from to arguments to one result
08:09:13 <Berengal> The initial function of unfoldr is b -> (a, b)
08:09:39 <Berengal> Well, without the Maybe that is, but we can ignore it for now
08:09:44 <Berengal> Notice how they're opposite?
08:10:30 <Berengal> The rest of unfoldr is also pretty close to the opposite of foldr
08:11:05 <Berengal> Instead of the "zero" case parameter, there's a maybe instead. This just tells us when to stop.
08:11:18 <Berengal> Since our result is a list, we have a perfectly good value for the base case, namely []
08:11:21 <mmorrow> Berengal: i wouldn't say foldl traverses the list right to left
08:11:37 <mmorrow> they're both left-to-right
08:12:14 <Berengal> mmorrow: foldl builds up a "list of thunks", in reverse order compared to the original list... At least if you squint a bit
08:12:51 <HaskellLove> (a -> b -> b) -> b -> [a] -> b  --------- I understand the first parameter it is a function with two arguments, the second is b which is the base case argument, and then i dont understand why [a]->b and not just b, or that means it creates all the functions and then after evaluating and compositing it gets one value b, correct?
08:13:45 <Berengal> mmorrow: The outermost redex is then the rightmost
08:13:50 <mmorrow> Berengal: sure, starting from the root of the result of foldl, you reach the last list element first
08:14:29 <mmorrow> (assuming breadth-first looking)
08:15:28 <Berengal> HaskellLove: That's the type of foldr. It'd be pretty useless to just take the function and the base case; you also need something to recurse over, in this case the list
08:15:48 <mmorrow> (but of course in order for that to be so it had to combine the last list element and the accumulating thunk /last/)
08:16:59 <Berengal> > foldl (flip const) 0 [1..10000000]
08:17:04 <lambdabot>   mueval-core: Time limit exceeded
08:17:06 <EvanR> ddarius: hehe youre right
08:17:08 <Berengal> > foldl (flip const) 0 [1..1000000]
08:17:15 <lambdabot>   mueval-core: Time limit exceeded
08:17:30 <Berengal> > foldl (flip const) 0 [1..100000]
08:17:32 <mmorrow> > foldl (+) 0 [0,1,2,3,error "OH",4,5,error "HAI",6,7]
08:17:32 <lambdabot>   100000
08:17:33 <lambdabot>   * Exception: OH
08:17:33 <EvanR> unfoldr takes out a huge class of situations where you pass the result and some state to construct a list
08:17:40 <Berengal> > foldl (+) 0 [1..100000]
08:17:41 <lambdabot>   5000050000
08:18:26 <mmorrow> > foldr (flip (+)) 0 [0,1,2,3,error "OH",4,5,error "HAI",6,7]
08:18:27 <lambdabot>   * Exception: HAI
08:18:29 <mmorrow> > foldl (+) 0 [0,1,2,3,error "OH",4,5,error "HAI",6,7]
08:18:31 <lambdabot>   * Exception: OH
08:19:46 <Berengal> @check (\(l :: [Integer]) -> foldr (:) [] l == foldl (flip (:)) [] (reverse l))
08:19:46 <lambdabot>   Parse error in pattern at "->" (column 20)
08:19:58 <Berengal> @check (\l -> foldr (:) [] l == foldl (flip (:)) [] (reverse l)) :: [Integer] -> Bool
08:19:59 <lambdabot>   Couldn't match expected type `[GHC.Integer.Internals.Integer]
08:20:32 <Berengal> Sure you couldn't...
08:20:45 <HaskellLove> unfoldr :: (b -> Maybe (a, b)) -> b -> [a] - Berengal ok I understood foldr, now this more: So first it takes one value, then returns Maybe (a,b) and here I lose it. Ok what is a and what b?
08:21:43 <mmorrow> Nothing => ok, done unfolding this list, Just (a,b) => ok, add `a' to end of list, continue unfolding with seed `b'
08:21:57 <Berengal> HaskellLove: Remember the function foldr takes. It takes a value 'a', and an accumulator value 'b'. It's these values the function given to unfoldr returns back
08:22:24 <Berengal> HaskellLove: 'a' is the element to put back in the list, 'b' is the accumulator value, except this time it's not accumulating, it's being taken appart
08:23:08 <Berengal> The Maybe is so the function can return a Nothing when the "decumulator" is used up and it has no more useful values to put in the list.
08:23:26 <mmorrow> , unfoldr (\b -> if b==0 then Nothing else Just(b,b-1)) 10
08:23:28 <lunabot>  [10,9,8,7,6,5,4,3,2,1]
08:23:33 <Berengal> (Is decumulator even a word?)
08:24:14 <c_wraith> co-accumulator
08:25:15 <mmorrow> for(i=10; i!=0; i--) xs = snoc(xs,i);
08:25:48 <HaskellLove> unfoldr (\b -> if b==0 then Nothing else Just(b,b-1)) 10: So this is sayng: unfold right-to-left this list (if b ==0 then nothing else do this "b-1" and store it to b) and then binds b to 10 ... correct?
08:26:02 <mmorrow> (not literally snoc though, since the frozen function application that once forced will trigger the dominoes to fall and produce another list element)
08:26:09 <mmorrow> and so on
08:26:54 <mmorrow> needs more than an irc line of C code to express (well, maybe a hackish line of C code would do)
08:26:55 <Berengal> HaskellLove: unfoldr produces a list left-to-right. That is, the first value produced by the function is the first value in the list, and so on. Otherwise, that seems about correct, if I understood correctly.
08:27:54 <HaskellLove> ok so foldl and unfoldl are the same except in reverse order of these correct?
08:27:58 <Berengal> HaskellLove: When you've read and written a bit more Haskell, reading type signatures will become much more natural. You can often guess what a type does just from it's type signature, without even the name of the function
08:28:09 <Berengal> I don't think there is an unfoldl...
08:28:11 <Berengal> @type unfoldl
08:28:14 <lambdabot> Not in scope: `unfoldl'
08:28:15 <Berengal> @hoogle unfoldl
08:28:16 <lambdabot> No results found
08:28:17 <mmorrow> , let go i = if i==0 then [] else i : go (i-1) in go 10
08:28:18 <lunabot>  [10,9,8,7,6,5,4,3,2,1]
08:28:20 <mmorrow> , unfoldr (\b -> if b==0 then Nothing else Just(b,b-1)) 10
08:28:21 <lunabot>  [10,9,8,7,6,5,4,3,2,1]
08:28:36 <osaunders> Is (pred n) preferred to (n-1) or does nobody care?
08:29:21 <aavogt> pred is better since it can be pointfree more easily
08:29:43 <aavogt> but I guess only if you want to do that
08:29:54 <Berengal> I prefer pred to (-1), at the very least...
08:30:04 <aavogt> @type (-1)
08:30:05 <lambdabot> forall a. (Num a) => a
08:30:07 * Berengal votes we get unary minus his own sign sometime soon)
08:30:32 <osaunders> It's _ in J.
08:30:35 <Draconx> osaunders, depending on the type of n, they might not be equivalent.
08:30:36 <opqdonut> with unicode we can ;)
08:30:41 <opqdonut> yeah it
08:30:48 <opqdonut> 's _ in some stack languages too iirc
08:31:08 <HaskellLove> so if i think correct, unfoldl does not exist since you cant unfold from infinity towards zere right? :)
08:31:32 <osaunders> Draconx: My example explicitly specified 1, but I take your point.
08:31:48 <Draconx> osaunders, 1 doesn't have anything to do with the type of n.
08:32:16 <osaunders> :t (-)
08:32:18 <lambdabot> forall a. (Num a) => a -> a -> a
08:32:27 <osaunders> They have to be the same and they have to be Num.
08:32:29 <Berengal> HaskellLove: Yeah, that's a bit hard. Also, there are better ways to generate lists in reverse order
08:32:41 <Draconx> :t pred
08:32:42 <lambdabot> forall a. (Enum a) => a -> a
08:33:02 <Draconx> look ma, different class.
08:33:43 <aavogt> Draconx: do you know any Num instances whose pred isn't the same as subtract 1?
08:33:56 <KitB> :t (<3)
08:33:57 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
08:34:11 <Draconx> aavogt, a floating point library I'm working on :)
08:34:12 <KitB> Turns out love takes an ordinal, numerical value to a bool?
08:34:45 <aavogt> that sounds awful
08:35:08 <Draconx> where pred actually means predecessor, instead of "minus one"
08:35:12 <HaskellLove> Berengal> as one last thing can u write here and give some comment on foldr and foldl? just this more and i am off to go ready to use them and experiment on my own
08:35:21 <copumpkin> > map (–5) [1..5]
08:35:22 <lambdabot>   [-4,-3,-2,-1,0]
08:36:06 <Berengal> HaskellLove: Well, foldr is more general than foldl. In fact, you can write foldl using only foldr, but not the other way around
08:36:22 <Draconx> aavogt, yes, most things about floating point are awful.
08:36:37 <aavogt> Draconx: so your Enum instance enumerates all possible floating point numbers then?
08:36:40 <Berengal> HaskellLove: But in basic useage, they're just traversing lists in different directions accumulating values.
08:36:41 <gwern> ddarius: you know that absoluteastronomy is merely a wikipedia mirror, yes?
08:37:16 <Draconx> aavogt, yes -- pred x = nextafter x (-infinity), succ x = nextafter x infinity, where nextafter is defined as in C.
08:37:28 <HaskellLove> Berengal> ok it is enough I think, I will tackle now again euler #11 with my arsenal now plus folds... thank you
08:37:37 <aavogt> I don't know this nextafter
08:37:48 <Berengal> HaskellLove: foldl (and the better version, foldl', which you should use instead 99% of the time) has access to the accumulation of the previous values encountered. foldr has access to the accumulated values of the values not encountered yet
08:38:29 <Draconx> aavogt, nextafter x y means "the next representable floating point value away from x, in the direction of y"
08:39:18 <dibblego> what is the function to take an Integral to a hexadecimal string?
08:39:34 <aavogt> > showsHex 1234 ""
08:39:35 <lambdabot>   Not in scope: `showsHex'
08:39:36 <Berengal> @hoogle showAtBase
08:39:37 <lambdabot> No results found
08:39:38 <aavogt> > showHex 1234 ""
08:39:39 <lambdabot>   "4d2"
08:39:44 <dibblego> ah cheers
08:39:48 <Berengal> @hoogle showBase
08:39:48 <lambdabot> No results found
08:39:58 <aavogt> @hoogle showIntAtBase
08:39:58 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
08:39:58 <Berengal> I'm sure there was a function like that somewhere...
08:40:03 <Berengal> There we go
08:40:15 <comak> @hoogle showAtBase
08:40:15 <lambdabot> No results found
08:40:33 <osslin> i have a function which returns Gen a, and in a do-block i'm writing let e = genA, how do I convert the "Gen a" to "a"?
08:40:44 <inclement> Berengal: When *should* you use foldl rather than foldl'? I can't work out why foldl is worth having at all
08:40:50 <aavogt> use  <- instead of =
08:40:58 <aavogt> osslin: also leave out the let
08:41:15 <comak> @hoogle showIntAtBase
08:41:16 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
08:41:17 <osslin> aavogt: does not work, this is in a IO () function
08:41:25 <Berengal> inclement: I actually can't think of any case where it's *better* to use foldl, but in some cases it's not worse...
08:41:35 <Berengal> Such as foldl (flip (:)) []
08:41:38 <inclement> Berengal: Heh, okay
08:41:46 <Berengal> > foldl (flip (:)) [] [1,2,3,4]
08:41:47 <lambdabot>   [4,3,2,1]
08:41:52 <aavogt> osslin: where is Gen from?
08:41:55 <aavogt> @hoogle Gen
08:41:55 <lambdabot> Test.QuickCheck data Gen a
08:41:55 <lambdabot> Data.Char data GeneralCategory
08:41:55 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
08:42:14 <osslin> quickcheck
08:42:18 <Berengal> inclement: The extra seq might eat a few cycles in that case... I'm not sure...
08:43:51 <aavogt> osslin: you can import Test.QuickCheck.Gen, which exposes the representation of Gen
08:44:09 <mmorrow> , time (head (foldl' (flip (:)) [] [0..1000000]))
08:44:11 <lunabot>  (0.173973,1000000)
08:44:13 <mmorrow> , time (head (foldl (flip (:)) [] [0..1000000]))
08:44:15 <lunabot>  (0.447932,1000000)
08:44:26 <aavogt> but what are you trying to do with the value you get from the Gen?
08:44:40 <mmorrow> yeah, i don't think there exists a case where you'd actually want to use foldl
08:44:51 <mmorrow> (instead of foldl')
08:44:57 <osslin> I have a generating function which generates mathematical functions for quickcheck testing
08:45:01 <osslin> now im building a GUI
08:45:18 <osslin> and would like a randomize function
08:45:33 <copumpkin> > foldl' (flip (:)) [] [1..5]
08:45:34 <lambdabot>   [5,4,3,2,1]
08:45:43 <dibblego> @hoogle showHe
08:45:43 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
08:45:44 <dibblego> @hoogle showHex
08:45:44 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
08:46:01 <aavogt> , time (foldl' (flip (:)) [] [1..100000])
08:46:03 <lunabot>  (1.5997e-2,[100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,...
08:46:04 <mmorrow> @src reverse
08:46:05 <lambdabot> reverse = foldl (flip (:)) []
08:46:09 <aavogt> , time (foldl' (flip (:)) [] [1..10000000])
08:46:14 <lunabot>  Killed.
08:46:18 <aavogt> , time (foldl' (flip (:)) [] [1..1000000])
08:46:20 <lunabot>  (0.170974,[1000000,999999,999998,999997,999996,999995,999994,999993,99999...
08:46:26 <aavogt> , time (foldl (flip (:)) [] [1..1000000])
08:46:29 <lunabot>  (0.45893,[1000000,999999,999998,999997,999996,999995,999994,999993,999992...
08:46:51 <mmorrow> (since you need to see the end of the list before you can do anything with the result)
08:46:58 <HaskellLove> unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)) Berengal, do you miss an a in the parenthesis like (a, splitAt 20 a) instead of (splitAt 20 a)?
08:47:05 <osaunders> @src foldl'
08:47:06 <lambdabot> foldl' f a []     = a
08:47:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:47:13 <mmorrow> and with foldl, once you get to the end of the list, then you get to start collapsing the massive thunk you just built up
08:47:24 <mmorrow> whereas with foldl', once you see then end of the list, you're done
08:47:34 <Cale> , time (head $ foldl' (flip (:)) [] [1..1000000])
08:47:36 <aavogt> HaskellLove: you can also use    unfoldr (\a -> guard a >> Just (splitAt 20 a)) ...
08:47:36 <lunabot>  (0.170974,1000000)
08:47:39 <Cale> , time (head $ foldl (flip (:)) [] [1..1000000])
08:47:41 <copumpkin> someone should post that to -cafe to discuss
08:47:42 <lunabot>  (0.450932,1000000)
08:47:46 <copumpkin> the lack of real applications for foldl
08:47:58 <Berengal> HaskellLove: splitAt already returns a tuple
08:48:04 <osaunders> head isn't lazy?
08:48:18 <Berengal> > unfoldr (\a -> if null a then Nothing else Just (splitAt 3 a)) [1..20]
08:48:18 <aavogt> > head (1:undefined)
08:48:19 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
08:48:19 <lambdabot>   1
08:48:34 <aavogt> > head undefined `seq` ()
08:48:35 <lambdabot>   * Exception: Prelude.undefined
08:48:51 <Cale> head is formally strict, but lazy in the tail of the list
08:49:18 <Berengal> Wasn't there a more granular classification?
08:50:04 <Berengal> head is formally strict, and can return both more and less defined values than it's argument.
08:50:05 <HaskellLove> this unfold name is kinda unintuitive to me , can i think of it simply as recursion?
08:50:23 <Berengal> HaskellLove: If you wish. It's what it is underneath
08:50:25 <mmorrow> @src unfoldr
08:50:25 <lambdabot> unfoldr f b  = case f b of
08:50:25 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:50:25 <lambdabot>    Nothing        -> []
08:50:32 <copumpkin> HaskellLove: everything non-trivial is recursion
08:50:37 <copumpkin> (by my definition :P)
08:50:46 <mmorrow> HaskellLove: it's the only way to loop in haskell
08:51:38 <HaskellLove> mmorrow>well map and other stuff are loops too
08:51:49 <mmorrow> goto,for,while,do/while,continue,break,longjmp,f() ==> function call in haskell!@ :)
08:51:52 <Berengal> HaskellLove: Those are also recursive
08:51:56 <mmorrow> @src map
08:51:56 <lambdabot> map _ []     = []
08:51:56 <lambdabot> map f (x:xs) = f x : map f xs
08:52:35 <mmorrow> HaskellLove: (i mean in terms of language primitives, that is)
08:53:01 <Berengal> Pattern matches and functions calls: The turtles of Haskell.
08:53:26 <copumpkin> pattern matches and let bindings, the turtles
08:54:26 <mmorrow> function calls the turtle soup?
08:54:40 <Cale> While higher order functions are typically implemented recursively, the whole point is that you usually don't have to care how they're implemented.
08:56:08 <mmorrow> HaskellLove: and that's where knowing that a pure function is pure really comes in handy, they might as well be black boxes
08:56:56 <tensorpudding> black boxes, powered by black magic!
08:56:57 <mmorrow> f(int *x, int y){*x = (int)(0.0/0.0)/*gotcha!*/; return y;}
08:57:33 <copumpkin> nice
08:58:24 <uorygl> mmorrow: ack, where's the equals sign? :-)
08:58:24 <dibblego> why does show '∘' produce "'\\8728'" and how can I get simply "∘" ?
08:58:52 <mmorrow> uorygl: :)
08:59:16 <mmorrow> dibblego: you need to utf8-encode it by some means (either using unicode IO or by doing it by hand)
08:59:34 <mmorrow> , "∘"
08:59:35 <lunabot>  "\8728"
08:59:37 <mmorrow> , utf8enc "∘"
08:59:38 <uorygl> dibblego: well, you could use putStr instead. I hope.
08:59:39 <lunabot>  "\226\136\152"
09:00:09 <mmorrow> uorygl: putStr will just chop it at \255 or some such nonsense
09:00:15 <uorygl> , iterate utf8enc "∘"
09:00:16 <lunabot>  ["\8728","\226\136\152","\195\162\194\136\194\152","\195\131\194\162\195\...
09:00:24 <mmorrow> heh
09:00:28 <uorygl> mmorrow: then putStr is silly.
09:00:39 <tsou> will it be possible to compile the "unregistered" ghc version in ubuntu linux, in order to compile and run ghc on OpenBSD?
09:00:49 <uorygl> A Char is a character, not a byte.
09:01:12 <Lemmih> uorygl: It has been fixed.
09:01:19 <mmorrow> woo
09:01:42 <mmorrow> dibblego, uorygl: (but not in 6.10)
09:01:57 <dibblego> well bugger
09:03:18 <mmorrow> , fmap text (iterate utf8enc "∘")
09:03:19 <lunabot>  [,∘,â,Ã¢ÂÂ,ÃÂ¢ÃÂÃÂ,ÃÂÃÂ¢ÃÂÃÂÃÂÃÂ,ÃÂÃÂÃÂÃÂ¢ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ,ÃÂÃÂÃÂÃÂÃÂÃÂÃÂ...
09:03:24 <mmorrow> heh
09:04:17 <uorygl> , iterate utf8enc "\195"
09:04:18 <lunabot>  ["\195","\195\131","\195\131\194\131","\195\131\194\131\195\130\194\131",...
09:04:30 <mmorrow> , fmap text (iterate utf8enc "\195")
09:04:31 <lunabot>  [ìÃ,Ã,ÃÂ,ÃÂÃÂ,ÃÂÃÂÃÂÃÂ,ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ,ÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂÃÂ,...
09:04:47 <uorygl> , [ iterate utf8enc "\195" !! n !! n | n <- [0..] ]
09:04:51 <lunabot>  Killed.
09:04:56 <uorygl> ?
09:04:58 <mmorrow> are all of those A-ish ones the same? (my font is too small)
09:05:07 <EvanR> does ghci compile the expression first somehow or is it interpreted
09:05:23 <uorygl> Why would that not terminate?
09:05:23 <mmorrow> uorygl: it probably didn't get enough of the list to print out before it got killed
09:05:31 <uorygl> mmorrow: no, some of them are tildes and some are circumflexes.
09:05:41 <xerox> EvanR: interpreted, to compile use ghc(not i)
09:06:03 <mmorrow> uorygl: lunabot needs iirc at least 2048 printable chars (or to terminate) before it'll print anything
09:06:08 <EvanR> xerox: just having a hard time telling the speed difference :)
09:06:17 <EvanR> but i am printing as fast as possible thats probably why
09:06:21 <uorygl> Why 2048, I wonder.
09:06:24 <uorygl> And how fast is it, anyway?
09:06:25 <EvanR> i/o bottleneck
09:06:28 <mmorrow> uorygl: arbitrary choice
09:06:37 <uorygl> Er, how much time does it have, anyway?
09:06:42 <xerox> EvanR: not sure, but you could try :set +s in ghci versus some -RTS option in ghc compiled file
09:06:53 <uorygl> Less than 100 milliseconds, I'm guessing.
09:07:20 <mmorrow> uorygl: well, the bot and the evaluator are separate progs, and the evaluator has rlimits set, it currently gets 6 or 8 seconds i think
09:07:49 <mmorrow> uorygl: i can't remember which prog is chopping at 2048 though, but one of them
09:08:07 <uorygl> That seems like plenty of time.
09:08:08 <uorygl> , fix id
09:08:14 <lunabot>  luna: out of memory (requested 2097152 bytes)
09:08:25 <uorygl> Huh, that was six seconds.
09:08:37 <mmorrow> well, the bot further removes control chars, adds spaces to the beginning of lines, and adds ellipses to lines too
09:08:41 <HaskellLove> why would this line result in indentation error: unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)) w ????? w is a string by the way
09:08:56 <mmorrow> uorygl: oh right, and there're memlimits too
09:09:11 <uorygl> , unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)) w
09:09:12 <lunabot>  luna: Couldn't match expected type `[a]'
09:09:17 <mmorrow> cpu-time + memlimit are the two rlimits it uses
09:09:25 <uorygl> HaskellLove: that's not an indentation error.
09:09:43 <mauke> , unfoldr (\a -> if null a then Nothing else Just (splitAt 20 a)) "w is a string"
09:09:44 <lunabot>  ["w is a string"]
09:10:20 <HaskellLove> uorygl>what is it then?
09:10:32 <uorygl> HaskellLove: it appears to be a type error.
09:10:45 <HaskellLove> but a sting is a list so...
09:10:49 <uorygl> Actually, as mauke shows, it's not an error at all.
09:11:14 <uorygl> Your indentation error is probably caused by the context.
09:12:08 <HaskellLove> uorygl>	the file is fine, when i comment that line it loads fine but with this line does not and it is not indented or anything...
09:12:39 <uorygl> HaskellLove: well, can I see the file?
09:13:37 * hackagebot upload: PCLT 0.1 - Extension to Show: templating, catalogizing, languages, parameters, etc. (AndreySisoyev)
09:13:59 <HaskellLove> here it comes http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14004#a14004
09:14:35 <mauke> you can't just put random expressions in a file
09:16:15 <uorygl> HaskellLove: ah, yes.
09:16:35 <copumpkin> um
09:16:38 <uorygl> If you want to print out an expression, you'll want to do main = print (expression)
09:17:03 <uorygl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14004#a14005
09:17:49 <ian__> hello room how is everyone doing tonight?
09:20:01 <HaskellLove> also this works: d = and then the unfold part, basicaly just put it in a variable... i had other commands like that before dont know why unfold requires this and cant stand on its own
09:20:17 <mauke> no, you hadn't
09:20:50 <inclement> HaskellLove: What do you want your program to do there?
09:21:09 <inclement> That sounds imperative...a line of 'do this' in the middle of nowhere
09:21:32 <HaskellLove> mauke>	i meant i hve done that before with othe commands not in that file
09:21:59 * hackagebot upload: PCLT-DB 0.1 - An addon to PCLT package: enchance PCLT catalog with PostgreSQL powers. (AndreySisoyev)
09:22:03 <HaskellLove> inclement>	well i am working on euler 11 so am building the solution bottom up dont know where it goes
09:23:14 <inclement> HaskellLove: If I understand what you're saying correctly, you don't know why just writing 'unfolr ...' doesn't work?
09:23:18 <inclement> *unfold
09:23:32 <HaskellLove> yes
09:23:46 <inclement> Putting it in a variable works becase then...it's in a variable
09:24:03 <inclement> If you *don't* put it in a variable, what is the interpreter/compiler supposed to do with it
09:24:08 <inclement> Where does the 'unfoldr' line go?
09:24:20 <EvanR> mmkay, unfoldr... i rewrote my rng using unfoldr, and i didnt seem to really help ;) http://pastebin.com/m2a874735
09:24:26 <HaskellLove> how about in global space and be printed?
09:24:37 <EvanR> same number of lines, am i missing something?
09:24:47 <mrsolo> first program is always hardest to write :-<
09:24:52 <inclement> HaskellLove: I don't really understand what you mean there...you want it to evaluate the expression and print the result?
09:25:51 <uorygl> Unfortunately (?), Haskell programs are not GHCi scripts.
09:26:08 <uorygl> It might be nice if a standalone expression were evaluated and printed. However, it isn't.
09:27:07 <HaskellLove> i dont know maybe i got this from python, dunno, python was the closest thing i did to functional like year ago, and now haskell is kinda hard to learn goes slow
09:27:08 <Jedai> uorygl: that would be quite a problem given the fact that no ordering at all is imposed on declarations in the same module
09:27:09 <EvanR> but in what order would they be printed, and how would it be useful at the top level
09:27:30 <Philonous> Ah, I finally managed to write a generalised version of functional composition with arbitrary return types
09:28:27 <Philonous> i.e. reverse .:. "abc" -> "cba"; reverse .:. (
09:29:12 <Philonous> i.e. reverse .:. "abc" -> "cba"; (reverse .:. (++)) "abc" "quux" -> "xuuqcba"
09:29:48 <Jedai> HaskellLove: Python is completely sequential, declarations have to be done before use and statements are executed in order of apparition, Haskell on the other hand don't impose any order on declaration and use, and lazyness also means you don't know exactly when or even if some of the bindings will be evaluated... so it makes sense to impose a single point of entry and let it manage the order
09:30:02 <Jedai> of execution in the IO monad, that's main() role
09:31:37 <Jedai> Philonous: reverse .:. map toUpper $ "abc" -> "CBA" ?
09:32:32 <Philonous> Jedai: (.) would do that. the point is that (.:.) works with any arity
09:32:58 <Philonous> (++) .:. reverse .:. map toUpper $ "abc" "def" -> "CBAdef"
09:32:59 <copumpkin> :t (.:.)
09:32:59 <lambdabot> Not in scope: `.:.'
09:33:07 <Jedai> Philonous: Right, just checking if it works for one argument as well :)
09:33:25 <Philonous> Sure
09:33:30 <Philonous> @paste
09:33:31 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
09:33:31 <EvanR> operator art
09:34:11 <EvanR> :^:
09:34:42 <uorygl> I must say I like the way Agda handles operators.
09:35:38 <Philonous> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5306#a5306
09:41:00 <copumpkin> agdaperators
09:41:30 <copumpkin> Philonous: I was just trying to write that a few weeks back
09:41:57 <copumpkin> was doing it with type families but I ran into obstacles
09:45:27 <Philonous> copumpkin: Yeah, I tried that with type families, too. Problem was that ghc too eagerly unified types that syntactically aren't compatible. The thing that makes this work really is the type checker's naivety
09:47:03 <EvanR> if i have a function that returns [a] can i do something to make it [IO a]...
09:47:13 <Philonous> :t map return
09:47:14 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
09:47:25 <Philonous> :t map (return :: a -> IO a)
09:47:26 <lambdabot> forall a. [a] -> [IO a]
09:47:34 <EvanR> ah
09:47:48 <c_wraith> [IO a] is a strange type to want, though.
09:48:13 <EvanR> yeah might be a bad idea
09:48:21 <Philonous> Maybe you want something like mapM or foldM?
09:48:26 <bd_> :t mapM_
09:48:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:48:32 <Philonous> :t mapM
09:48:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
09:51:35 <EvanR> im trying to do a rng IO function, so makeRng :: [a] -> IO a, each time you use the resulting generator it produces the next number in the list. ive got a non io infinite list of random numbers
09:51:59 <EvanR> using readIORef, i get IO [a]
09:53:05 <c_wraith> Use a do block.  do { (x:xs) <- readIORef blah ; writeIORef blah xs ; return x }
09:53:12 <c_wraith> ...  assuming the list is infinite
09:53:15 <EvanR> this is my attempt
09:53:46 <aavogt> what's that have to do with being infinite or not?
09:54:05 <c_wraith> well, the pattern match will fail on []
09:54:10 <EvanR> http://pastebin.com/m3ce45ee0
09:54:21 <EvanR> its infinite
09:54:46 <aavogt> @hoogle ST
09:54:47 <lambdabot> module Control.Monad.ST
09:54:47 <lambdabot> module Data.Array.ST
09:54:47 <lambdabot> Control.Monad.ST data ST s a
09:55:03 <EvanR> i have to do blocks, perhaps futilly trying to hide the newIORef in a closure
09:55:17 <EvanR> yeah i need to learn these ST things
09:55:27 <aavogt> me too
09:57:17 <EvanR> c_wraith: so yeah, needless to say my code fails to compile ;)
09:57:38 <EvanR> types and so forth
10:01:16 <mxyz> how do i pack an Int with the bits of a ByteString?
10:02:29 <Lemmih> mxyz: Data.Binary.decode?
10:03:44 <mxyz> lemmih: decode :: Binary a => ByteString -> a
10:04:28 <Lemmih> mxyz: Yes?
10:04:32 <mxyz> im still trying to print the bits of a double. i got to the point where i have the bits in a bytestring, but now i need them in an Int
10:05:07 <mxyz> lemmih: im not sure what "-> a" result in. im failry confused actually, lol.
10:05:28 <Lemmih> mxyz: What do you want to do, exactly?
10:05:32 <c_wraith> EvanR: Does my example do block look helpful to you?  Because I think it accomplishes your goal.
10:05:48 <EvanR> its missing the part that does newIORef
10:05:52 <mxyz> lemmih: go from Double to a String containing the bits of that double
10:06:48 <mmorrow> what are people's opinions on whether, suppose that you have an exhaustive case expression, so there's no way for the code the compiler generates to fail to match the constructor-being-matched-on's tag UNLESS there's funny-business going on. the question is, would you consider it acceptable for the compiler to have undefined behavior (most likely a segfault, but maybe worse) in the (impossible unless someone is doing things not-possible
10:06:48 <mmorrow> in haskell (even with unsafePerformIO)) event that the value in the tag slot of the constructor is bogus?
10:06:56 <mmorrow> </longer than i expected>
10:07:00 <EvanR> c_wraith: my code has that in it, ill repaste the latest... http://pastebin.com/m670d0916
10:07:29 <mmorrow> oh, and also in order to support catching such a thing the code would have to be less efficient
10:07:38 <Lemmih> mxyz: Sounds like a bad idea, but here goes: decode (encode (10::Double)) :: Int64
10:07:43 * mmorrow things a segfault in that case is valid
10:07:45 <mmorrow> *thinks
10:07:52 <Lemmih> mxyz: Are you sure that's really what you want?
10:09:04 <mxyz> lemmih: im just playing around with bit operations to familiarize myself with haskell data types
10:09:30 <c_wraith> EvanR: I'm a bit confused about how you're using the argument to that function.  And that can't type-check correctly with the type signature you provided.
10:09:58 <EvanR> rand :: [Integer] -> [Integer]
10:10:08 <EvanR> and yeah i know the types are wrong :(
10:10:13 <mmorrow> Lemmih: what are your thoughts on that? (e.g. say you've got a 2 constructor datatype, and you implement an exhaustive case with a conditional jump (say tag/=0))
10:10:14 <Lemmih> mxyz: You're not supposed to use bit operations on floating point values.
10:10:32 <dolio> mmorrow: So, to get the undefined behavior, you'd have to unsafe coerce, or hack the runtime system in some way?
10:10:40 <mmorrow> dolio: right
10:10:47 <c_wraith> EvanR: I've got to run. good luck with getting this sorted out.
10:10:53 <EvanR> thanks
10:10:54 <Philonous> mmorrow: If that happens, aren't things already so bad that we can't give any guarantees anymore?
10:10:56 <mmorrow> dolio: hmm, said that way, i think it's perfectly valid
10:11:01 <mmorrow> Philippa: right
10:11:11 <mmorrow> ok, i'm convinced. thanks :)
10:11:19 <mxyz> lemmih: im not. i just want to *inspect* the bits of a double
10:11:37 <mmorrow> Philonous: gah!
10:11:41 <mmorrow> Philippa: sry :)
10:12:12 <HaskellLove> I am solving euler 11 and I need to concatenate all these lists for each element: up, down, left, right, diagLU, diagLD, diagRU, diagRD (diag stands for diagonal) ... kinda new grounds here anyone has done this to give me some guidelines? http://projecteuler.net/index.php?section=problems&id=11
10:12:26 <mmorrow> mxyz: you have to use extra-haskellish means to do that
10:12:27 <dolio> mmorrow: Yes, pinging her twice was the right way to solve that. :)
10:12:40 <mmorrow> dolio: heh
10:12:54 <EvanR> alright. when ghc cant match expected type a against inferred type b, which types are which? :( one is hopefully the type i meant to use and one is the type i accidentally used...
10:13:31 <Lemmih> mxyz: You're not supposed to do that either. At most you can look at the mantissa and exponent.
10:13:39 <mmorrow> mxyz: e.g. unsafeCoerce (make sure that you unsafeCoerce it to a type the same length and layout as a double), or poke it to memory as a Double, and peek it as a Word64
10:13:54 <Lemmih> mmorrow: That would be fine, imo.
10:14:01 <mxyz> mmorrow: Data.Binary.IEEE754 has a function called putFloat64be Double that does this. but it creates a Put/ByteString. im just trying to print out the bits of the BVyteString
10:14:03 <mmorrow> Lemmih: thanks
10:15:09 <Lemmih> mxyz: You can decode ByteStrings to lists of Word8's.
10:16:17 <HaskellLove> strange thing happens i am getting scared of loosing my imperative skills with Haskell over time :(
10:16:28 <mxyz> lemmih: part of my problem is that im not familiar with any of these types and how they intraconvert. a Word8 is just as alien as a ByteString to me
10:16:39 <Lemmih> mxyz: I must say, messing around with these things seems like a bad idea.
10:16:45 <xerox> HaskellLove: don't worry, they only get better
10:17:11 <gwern> didn't work that way for me, but then I do not have good anger management skillz
10:17:16 <Lemmih> mxyz: You'd learn much more by reading a Haskell tutorial.
10:17:30 <mxyz> lemmih: seriously, its just an accident, lol. Java has a method called Double.doubleToLongBits that does this. and as an exercise I thought it would be equally as trivial in Haskell, but apparently no one really knows how to do this
10:17:36 <mxyz> ive read RWH
10:18:46 <mmorrow> mxyz: e.g.
10:18:49 <mmorrow> (\d -> alloca (\p -> poke (p::Ptr Double) d >> peek (castPtr p::Ptr Word64)) :: IO Word64)
10:19:01 <mmorrow> :: Double -> IO Word64
10:19:20 <mmorrow> you could unIO that too really
10:19:40 <EvanR> > do { (x:xs) <- [1,2,3,4]; x; }
10:19:42 <lambdabot>   No instance for (GHC.Num.Num [[b]])
10:19:42 <lambdabot>    arising from the literal `1' at <int...
10:19:46 <EvanR> :(
10:19:54 <mmorrow> (unIO := unsafePerformIO)
10:20:00 <xerox> EvanR change 'x;' in 'return x;'
10:20:15 <EvanR> > do { (x:xs) <- [1,2,3,4]; return x; }
10:20:16 <lambdabot>   No instance for (GHC.Num.Num [b])
10:20:16 <lambdabot>    arising from the literal `1' at <inter...
10:20:23 <mauke> EvanR: 1 is not a list
10:20:49 <mxyz> mmorrow: ok, ill test it out
10:20:53 <EvanR> this is me getting to bottom of things, does (x:xs) <- expr work in do notation?
10:21:01 <EvanR> if so, what types do things have
10:21:17 <EvanR> > let (x:xs) <- [1,2,3,4] in xs
10:21:18 <lambdabot>   <no location info>: parse error on input `<-'
10:21:24 <EvanR> > let (x:xs) = [1,2,3,4] in xs
10:21:25 <lambdabot>   [2,3,4]
10:21:26 <mmorrow> ghci> d2l pi
10:21:26 <mmorrow> 4614256656552045848
10:21:44 <mmorrow> mxyz: be sure to give it a type sig
10:21:45 <Philonous> foo <- bar = bar >>= \foo -> ...
10:22:06 <EvanR> > do { (x:xs) <- return [1,2,3,4]; xs; }
10:22:07 <mmorrow> mxyz: oh, actually the annotations are implying Double -> IO Word8
10:22:07 <lambdabot>   [2,3,4]
10:22:17 <EvanR> :t do { (x:xs) <- return [1,2,3,4]; xs; }
10:22:18 <lambdabot> forall b. (Num b) => [b]
10:22:30 <EvanR> so the monad is gone ?..
10:22:53 <Philonous> EvanR: [] is a monad
10:23:16 <EvanR> >_<
10:23:51 <xerox> EvanR: mauke's comment was quite to the point
10:23:58 <mxyz> mmorrow: thanks for the example. but i dont really understand it. also, wouldnt it be better to use the function that was made to do this? namely "putStrLn $ runPut $ putFloat64be 4.123". All the bits are now in a ByteString, I just dont know how to print them
10:24:08 <mmorrow> mxyz: yeah, or as Lemmih said you can decode the ByteString too
10:24:29 <mmorrow> @type Data.ByteString.unpack
10:24:30 <lambdabot> BSC.ByteString -> [Word8]
10:24:35 <EvanR> xerox: i know its not a list. i thought it was irrelevant because i didnt want it to be a list
10:24:51 <EvanR> context problem
10:25:00 <mxyz> mmorrow: is a Word8 just like an Int8?
10:25:05 <mmorrow> mxyz: so unpack the ByteString, then use bit ops to combine the first 8 Word8s if needed
10:25:11 <xerox> EvanR: in x <- amb the types are  amb :: m a  and  x :: a
10:25:20 <mmorrow> mxyz: yes, same underlying bits
10:25:28 <mxyz> mmorrow: thanks ill try it out
10:25:29 <mmorrow> mxyz: just different interpretation
10:25:38 <mmorrow> hrm, well actually that may not be true
10:25:44 * mmorrow checks
10:26:08 <EvanR> xerox: and type of xs in (x:xs) <- amb?
10:26:56 <xerox> EvanR: use that rule:  y@(x:xs) <- amb  with  amb :: m a  and  y :: a  thus a = [b] and  x :: b  xs :: [b]  that makes amb :: [[b]]
10:27:05 <mmorrow> mxyz: yeah, i don't think they're the same bits actually, but this doesn't even really matter
10:27:09 <mmorrow> mxyz: just fromIntegral
10:28:19 <mmorrow> (not the same bits since Int8 is really stored as the same size as an Int and the sign bit is not in bit 8?)
10:28:26 <mmorrow> dunno
10:29:25 <EvanR> xerox: is amb supposed to be significant in some way other than as an identifier which isnt a b x xs or y
10:29:48 <xerox> EvanR: just a name for a monadic value
10:29:49 <EvanR> or m
10:29:52 <EvanR> ok
10:30:04 <mxyz> mmorrow: it worked!
10:30:19 <Philonous> EvanR: You destructure a list in a monad, so it has type Monad m => m [a]. When m = [] then it's what xerox wrote
10:30:21 <xerox> EvanR: what's significant here is the pattern (x:xs) that says that x :: b and xs :: [b]
10:30:48 <Lemmih> mmorrow: The sign /is/ at bit 8.
10:30:51 <mxyz> main = do putStrLn $ show $ LBS.unpack $ runPut $ putFloat64be 4.123
10:31:09 <mxyz> prints an array of the correct byte values
10:31:17 <Philonous> EvanR: I meant that's amb's type
10:31:36 <EvanR> so if i have y :: IO [Integer], and i do (x:xs) <- y.... (x:xs) has type [Integer] ?
10:31:46 <xerox> indeed
10:31:53 * EvanR graduates a little
10:32:03 <EvanR> thats what i was missing
10:32:10 <Lemmih> mmorrow: Or rather, only the 8 least significant bits are used.
10:33:26 <xerox> that's because the do notation gets rewritten following the rules:  do { let BINDINGS; ... }  =>  let BINDINGS in do { ... }   do { x <- amb; ... } => amb >>= \x -> do { ... }   do { amb; ... } => amb >> do { ... }  and eventually  do { EXPR } => EXPR
10:33:29 <EvanR> but if y :: IO [Integer] then x <- y... x is still IO [Integer] because the (x:xs) thing deletes the monad/
10:33:35 <mmorrow> Lemmih: ah nice
10:33:40 <mmorrow> mxyz: woot
10:33:41 <xerox> (that is all, do is a syntactic transformation)
10:34:20 <Philonous> EvanR: No, the "<-" "deletes" the monad
10:34:28 <Lemmih> mxyz: Lists aren't arrays.
10:34:38 <EvanR> so x <- y, x :: [Integer]
10:35:03 <mmorrow> Lemmih: hrm, so i guess every + (or whatever) has to sign-extend, do the +, then sign-unextend?
10:35:03 <Philonous> EvanR Yup
10:35:27 <mmorrow> Lemmih: sounds possibly sucky, unless this is still one instruction
10:35:30 <mxyz> lemmih: youre totally right. my terminology is still wrong. thanks
10:35:34 <EvanR> alright...
10:35:44 * EvanR tries to actually fix the code now
10:35:48 <dibblego> mxyz, the closest thing Java has to [] is fj.data.Stream http://functionaljava.googlecode.com/svn/artifacts/2.20/javadoc/fj/data/Stream.html
10:35:57 <Philonous> EvanR Please note that you can't use this to actually escape the monad, because do notation requires you to eventually return something inside the monad
10:36:52 <doserj> mmorrow: why would you need to sing-extend?
10:36:55 <mxyz> dibblego: thanks. its just my bad habit to call things in  [ ] arrays
10:37:09 <EvanR> Philonous: perish the thought
10:37:39 <mmorrow> doserj: to do the + as a 32/64 bit add{l,q}
10:38:33 <doserj> mmorrow: you can just use the 32/64 bit adder, no problem there
10:38:33 <mmorrow> doserj: iirc it's "recommended" to do arithmetic on full registers, but maybe i'm imagining this (is it more costly to do an addb?)
10:39:10 <mmorrow> doserj: for just the low 8 bits (with sign at bit 8) though?
10:39:36 <doserj> mmorrow: yes. 2-complement is designed that way
10:39:50 <mmorrow> doserj: geniush!
10:39:54 <mxyz> mmorrow: I DID IT! check this out:
10:39:54 <mmorrow> :)
10:40:09 <mxyz> main = do putStrLn $ show $ map getBits (LBS.unpack $ runPut $ putFloat64be 4.123)
10:40:13 <heatsink> What is the 'Language' category in the module hierarchy for?
10:40:16 <mxyz> getBits i = showIntAtBase 2 (chr . (48+)) i ""
10:40:24 <mmorrow> mxyz: nice
10:40:35 <heatsink> It seems to mostly contain programming languages, but lojban is there too
10:41:25 <HaskellLove> It comes to my mind the importance of the question: Is there a combination of built-in functions I can use or I will have to write one? Over time you can judge but in the beginning when you start functional programming you are a little lost. This is entry from my blog, give me opinions on this, since i am func new guy
10:41:31 <xerox> mxyz using . refactors better than using $ you can convert f $ g $ h $ x to f . g. h $ x
10:41:44 <fracture> I am trying to do something similar to let f = repeat (randomIO :: IO Int) ; in print $ head (takeWhile (>100) (sequence f))
10:41:45 <gwern> HaskellLove: this is why you learn hoogle
10:41:55 <gwern> and browse the standard libraries, and use hlint as well
10:41:57 <fracture> but it fails.... basically I want to have an infinite list of IO actions and do them until some condition is satisfied
10:42:05 <fracture> how does one do that?
10:42:10 <gwern> whileM?
10:42:14 <fracture> oh.
10:42:18 <gwern> hm.
10:42:20 <fracture> :t whileM
10:42:21 <lambdabot> Not in scope: `whileM'
10:42:37 <gwern> I could've sworn there was a whileM or untilM
10:42:39 <fracture> (I need the result value of the actions btw)
10:42:42 <fracture> hmm
10:42:43 <xerox> ?docs System.Random
10:42:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
10:42:54 <gwern> fracture: well, what would the type sig of your function be?
10:42:56 <xerox> (eheh base is random in the url)
10:43:07 <mmorrow> fracture: i don't think the stdlib has anything that fits the bill exactly here
10:43:14 <fracture> gwern: my function returns IO Int in this case actually
10:43:31 <fracture> (it also takes some arguments relating to the condition, but those are sorta irrelevant)
10:43:35 <xerox> fracture: you can make a list of random numbers directly with randoms and randomRs
10:43:42 <gwern> @hoogle (m a -> Bool) -> [m a]
10:43:43 <lambdabot> No results found
10:43:44 <xerox> (a lazy list of course)
10:43:59 <gwern> @hoogle a -> (a -> Bool) -> [a]
10:43:59 <heatsink> HaskellLove: It does take a while to learn what built-in functions do.  Accidentally reimplementing them is a good learning experience, though.  It helps you grok the libraries quicker.
10:44:00 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
10:44:00 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
10:44:00 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
10:44:21 <gwern> @hoogle m a -> (m a -> Bool) -> [m a]
10:44:22 <lambdabot> No results found
10:44:28 <mmorrow> doWhile :: (a -> Bool) -> [m a] -> m (); doWhile p [] = return (); doWhile p (m:ms) = do a <- m; when (p a) (doWhile p ms)
10:44:32 <xerox> fracture: do { g <- newStdGen; let xs = randoms :: [Int]; print ... }
10:44:33 <fracture> maybe one of these can be lifted into the monad or whatever?
10:44:41 <gwern> I wonder if you can just use 'until'
10:44:52 <gwern> :t until
10:44:53 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:45:09 <fracture> xerox: I could reorganize this to use that, but it'd be nicer to know generically so I can reuse a function I already wrote that does stuff with the random things (and for future reference)
10:45:13 <xerox> fracture: I think it is better to divide the generation of the random seed from whatever pure computation you want to do with the random list (which is a pure value)
10:45:17 <mmorrow> gwern: the exit condition dependent on the result of running each action is the bit that i don't think any std function supports
10:45:32 <xerox> fracture: this is also what the standard library suggest looking at the types of the System.Random functions.
10:45:35 <HaskellLove> please someone help me and give me guidelines to translate that algorithm in haskell http://hpaste.org/fastcgi/hpaste.fcgi/new
10:45:50 <mxyz> xerox: thanks. i was getting was getting errors and i think i just defaulted to $ without giving it much thought.
10:45:59 <fracture> xerox: yeah, so in this case just assume I have a bunch of IO Ints (they are actually IO SomeTypeIDefined)---the fact they are random is not really relevant to the question
10:46:03 <HaskellLove> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14009#a14009
10:46:07 <mmorrow> fracture: this would definitely be a useful function, and would be worthy of being in Control.Monad imo
10:46:21 <xerox> mxyz: it's been said before but it's very nice in practice, f . g has meaning on its own f $ g doesn't
10:46:26 <gwern> :t > until (\x -> (read x) :: Int > 10) (\_ -> getLine) ""
10:46:27 <lambdabot> parse error on input `>'
10:46:28 <gwern> :t until (\x -> (read x) :: Int > 10) (\_ -> getLine) ""
10:46:29 <lambdabot> Only unit numeric type pattern is valid
10:46:39 <gwern> :t until (\x -> (read x :: Int) > 10) (\_ -> getLine) ""
10:46:40 <lambdabot>     Couldn't match expected type `[Char]'
10:46:40 <lambdabot>            against inferred type `IO String'
10:46:40 <lambdabot>       Expected type: String
10:46:43 <gwern> hm.
10:46:48 <gwern> :t until (\x -> (read x :: Int) > 10) (\_ -> getLine) (return "")
10:46:49 <lambdabot>     Couldn't match expected type `[Char]'
10:46:49 <lambdabot>            against inferred type `IO String'
10:46:49 <lambdabot>       Expected type: String
10:47:04 <gwern> gah
10:47:05 <mxyz> xerox: yea i remember reading that in RWH i think. $ means the rest of the line and . is just composition correct?
10:47:07 <mmorrow> fracture: (in case you missed it, this would work) doWhileM :: (a -> Bool) -> [m a] -> m (); doWhileM p [] = return (); doWhileM p (m:ms) = do a <- m; when (p a) (doWhile p ms)
10:47:35 <HaskellLove> someone help me please translate this to haskell code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14009#a14009
10:48:08 <gwern> looks like homework
10:48:09 <mmorrow> fracture: (or :: (a -> Bool) -> [m a] -> m [a])
10:48:17 <xerox> mxyz: ($) is function application and (.) is function composition, yes
10:48:18 <mmorrow> sequenceWhile
10:48:19 <fracture> mmorrow: ah, that makes sense (though in my case I need to return the value when it needs to stop)
10:48:21 <mmorrow> or wsomething
10:48:35 <mmorrow> fracture: ah
10:49:15 <fracture> it seems like there should be a way to bring one of the generic functions for this into the monad---I could definitely implement a little funcction like you suggest, though
10:49:21 <mxyz> xerox: fixed? "main = do putStrLn . show $ map getBits (LBS.unpack . runPut $ putFloat64be 4.123)"
10:49:32 <gwern> mmorrow: maybe a replicateM with a takeWhile?
10:49:48 <fracture> :t replicateM
10:49:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:49:49 <gwern> that is, takeWhile boolTest $ replicateM ioAction
10:49:57 <mmorrow> gwern: but you don't know how many (m a)'s you'll need to run until you run them
10:50:10 <gwern> oh right. so that'd be... sequence? cycle?
10:50:27 <mmorrow> gwern: but since it's an infinite list, sequence'll never come back
10:50:30 <gwern> ah, repeat
10:50:33 <gwern> ?src repeat
10:50:33 <lambdabot> repeat x = xs where xs = x : xs
10:50:57 <gwern> mmorrow: looks lazy to me
10:50:58 <mmorrow> gwern: this function is literally at the primitive level
10:51:07 <xerox> It smells of continuations
10:51:26 <mmorrow> := not implementable without direct recursion with existing function
10:51:50 <mmorrow> err, that sentence wasn't ordered very well, but you know what i meant
10:53:34 <gwern> not really. why wouldn't repeat and takeWhil do the job?
10:54:33 <mmorrow> fracture: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5307#a5307
10:55:01 <mmorrow> gwern: because none of those will actually run the (m a)
10:55:06 <mmorrow> in [m a]
10:55:29 <gwern> wouldn't the bool function passed to takeWhile ahve to force it to evaluate it?
10:55:34 <mmorrow> doWhileM (/=42) (repeat readLn)
10:56:01 <fracture> mmorrow: interesting...  either of those are probably a tad verbose for my situation (I could just reorganize my function to do a loop manually using an inner function)
10:56:08 <fracture> but they might be useful generic functions to have around... ?
10:56:22 <mmorrow> fracture: i'm keeping them around.. ;)
10:56:44 <fracture> what's "stack gobbling" mean, by the way?
10:57:04 <mmorrow> fracture: it uses the stack to store the list it's accumulating
10:57:12 <mmorrow> fracture: whereas the other version uses the heap
10:57:22 <aconbere> hmmm
10:57:26 <aconbere> i'm trying to build ghc
10:57:30 <aconbere> but when I run ./configure
10:57:36 <mmorrow> fracture: so the stack-gobbling version is in danger of blowing the stack if you end up with a long list
10:57:37 <aconbere> I get an error that says I need to have ghc installed
10:57:38 <fracture> ah I see... I didn't realize that detail of storage allocation was something you could predict in haskell
10:57:43 <Cale> mmorrow: errr... really?
10:57:54 <mmorrow> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5307#a5307
10:58:13 <mmorrow> Cale: e.g. in Data.Binary this comes up with decoding lists
10:58:15 <Cale> mmorrow: Yes, that's what I'm looking at
10:58:44 <Cale> Which case expressions end up on the stack?
10:58:55 <mmorrow> as <- doWhileM p ms
10:58:55 <mmorrow>       return (a:as)
10:58:59 <aconbere> configure: error: GHC is required unless bootstrapping from .hc files.
10:59:02 <mmorrow> indentation messed up
10:59:11 <aconbere> now... that seems tricky given how I'm trying to install ghc
10:59:14 <Cale> mmorrow: But that's not a case
10:59:20 <Cale> mmorrow: hmm...
10:59:24 <mmorrow> Cale: but since we're in a monad
10:59:39 <Cale> I guess if >>= is strict it might be.
11:00:02 <mmorrow> yeah, like IO without unsafeInterleaveIO
11:00:02 <fracture> is there a doc somewhere specifying the rules haskell compilers/interpreters have to use for allocation?
11:00:13 <fracture> or is this a GHC-specific detail that you guys are thinking about?
11:00:28 <absentia> I haven't checked.. just asking here first --  is there a 64bit for snow leopard yet?
11:00:29 <mmorrow> unsafeInterleaveIO however would make the "stack-gobbling" version ok
11:01:01 <mmorrow> but in the general i'd personally probably go with the non-stack gobbler if it's for an arbitrary Monad m
11:01:08 <mmorrow> *in the general case
11:03:23 <mmorrow> Cale: don's recently added the function `getMany' (not exported) to Data.Binary because everyone's stacks were getting blown http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/src/Data-Binary.html
11:03:31 <mmorrow> *dons
11:03:45 <Cale> I'm not sure I see why this *ought* to affect the stack at all, even in IO.
11:03:50 <SamB_XP> C++ has really strange pointer casting ...
11:04:05 <copumpkin> strange = ugly
11:04:09 <Cale> doWhileM (const True) (repeat (return 1 :: IO Integer)) -- this stack overflows, but I'm not sure that it should
11:04:18 <fracture> SamB_XP: strange compared to what?
11:04:32 <mmorrow> Cale: since it's binding the rest of the list (recursively) before returning the result
11:04:46 <Cale> mmorrow: But what pattern match is waiting to happen?
11:05:20 <SamB_XP> fracture: well, okay, the multiple-inheritance is the craziest part ...
11:05:32 <mmorrow> Cale: in the (>>=)
11:05:32 <xerox> :t \ p -> flip runContT (return . head) . sequence . map (\amb -> ContT (\k -> amb >>= \x -> if p x then return x else k x))
11:05:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [m a] -> m a
11:05:35 <Cale> All the pattern matches, including the ones inside the binds, seem like they ought to happen immediately from my perspective.
11:05:43 <xerox> (it can be generalized and return more stuff)
11:06:03 <mmorrow> Cale: in IO's case, i guess maybe something like  case ... s1 of (# s2,a #) -> ....
11:07:01 <Cale> Hmm, perhaps it's a subtle bug in that implementation of IO
11:07:15 <fracture> SamB_XP: huh.  what about it?  the fact that casts need to adjust the pointer value or something?  (not sure how else it would work)
11:07:48 <Cale> I don't think with my usual mental model of IO that it would have any trouble carrying out the actions without building things up on the stack. The expression itself would grow and it would be a memory leak, but not a stack overflow.
11:08:02 <SamB_XP> fracture: well, okay, in particular I've found a class that evidently needs adjustment for casts between itself and *all* its baseclasses...
11:08:09 <mmorrow> Cale: yeah perhaps, since doing it this way uses the State# token to enforce ordering by making each successive state token data-dep on the last, and forcing the state token in each IO action
11:08:47 <mmorrow> Cale: i wonder if there's a way to enforce ordering, but get the behavior we're thinking of?
11:08:53 <fracture> SamB_XP: interesting... usually at least one has the same address as the derived class.  is it using virtual inheritance or something?
11:09:16 <SamB_XP> fracture: well, or maybe that's actually a member with the same baseclasses ...
11:09:22 <SamB_XP> hmm, yeah, probably ...
11:09:57 <fracture> erm; ... don't understand what you mean by that member part
11:10:09 <SamB_XP> I'm disassembling something
11:11:05 <absentia> IK'll take that as a no.
11:11:09 <Cale> mmorrow: oh, no, I think I see it now.
11:11:22 <absentia> any idea when a 64bit ghc might be availaable for snow leopard?
11:12:16 <Cale> er...
11:12:38 * hackagebot upload: hledger 0.7.0 - A command-line (or curses or web-based) double-entry accounting tool. (SimonMichael)
11:13:06 <mauke> .oO( hledger = heath ledger? )
11:13:27 <aconbere> hmpf
11:13:35 <sm> NO, mauke
11:13:41 <copumpkin> he be dead
11:13:46 <sm> rip
11:13:53 <mauke> RIP AND TEAR
11:14:17 <EvanR> i am confused about when IO values get run, and when they are treated as data, but could possibly be run by other code. what is the criteria for running. how do you return a single action which will not be run...?
11:14:41 <c_wraith> EvanR: an IO value is run when it's bound into main.
11:14:42 <mauke> EvanR: IO values are always data
11:14:57 <c_wraith> (perhaps transitively)
11:14:59 <gwern> IO values are like all other data - they get run when demanded :)
11:15:02 <EvanR> transitively yes
11:15:09 <mauke> EvanR: the only action that's run is the value of main, and it's executed by the runtime system (outside of haskell)
11:15:22 <Cale> mmorrow: Yeah, it's not really supposed to use the stack, I think, but it is because of that. In any case it's a memory leak though, because the size of the IO continuation waiting to execute grows.
11:16:06 <EvanR> a function that returns IO [IO a], the actions in the list will not be run? so to return a single action to defer running, we return IO IO a ?
11:16:11 <mmorrow> Cale: totally
11:16:11 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5307#a5308
11:16:38 <aconbere> any help compiling on os x, I get this error at ./configure.
11:16:38 <aconbere> configure: error: GHC is required unless bootstrapping from .hc files.
11:16:54 <c_wraith> EvanR:  You're very much on the right track.
11:17:00 <EvanR> great
11:17:48 <aconbere> everything I find in terms of build instructions seems to imply that simply ./configure; make; make install
11:17:52 <aconbere> should work for OS X
11:17:57 <EvanR> so if makeAction :: a -> IO IO () we can later do bam<-makeAction foo; bam; bam; bam; bam; ?
11:17:57 <aconbere> but, I keep running into this
11:18:01 <kmc> EvanR, "IO IO a" is a compiler error
11:18:12 <Lemmih> aconbere: To install GHC, you first need to install GHC.
11:18:13 <c_wraith> EvanR: IO (IO a), but yes
11:18:17 <EvanR> ah
11:18:20 <kmc> :t join
11:18:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:18:22 <aconbere> Lemmih: that seems tricky :)
11:18:43 <mauke> @src join
11:18:43 <lambdabot> join x =  x >>= id
11:18:52 <aavogt> :t Data.Traversable.traverse sequence (undefined :: IO [IO a])
11:18:53 <lambdabot>     No instance for (Data.Traversable.Traversable IO)
11:18:53 <lambdabot>       arising from a use of `Data.Traversable.traverse'
11:18:53 <lambdabot>                    at <interactive>:1:0-58
11:19:00 <ChilliX> aconbere: you need to install a binary distirbution to then compile from source
11:19:08 <kmc> EvanR, "join" is useful when you are nesting monadic values in this way
11:19:11 <mauke> join x = do { bam <- x; bam }
11:19:12 <aavogt> :t sequence =<< (undefined :: IO [IO a])
11:19:13 <lambdabot> forall a. IO [a]
11:19:32 <EvanR> nice
11:19:40 <aavogt> :t Data.Traversable.traverse sequence (undefined :: Maybe [Maybe a])
11:19:41 <lambdabot> forall a. Maybe (Maybe [a])
11:19:45 <mmorrow> Cale: and since GHC uses a stack for continuations, it blows the stack, but right the leak would manifest itself wherever a given runtime system stored continuations
11:19:54 <aavogt> :t Data.Traversable.traverse sequence (undefined :: Maybe [IO a])
11:19:55 <lambdabot> forall a. IO (Maybe [a])
11:19:58 <kmc> note that "sequence" is just one of the many ways to execute a list of actions.  you could execute them in a different order, drop some, repeat some, etc.
11:20:36 <Cale> mmorrow: I tend to think of x >>= f in the IO monad as a piece of data which the executor will pattern match on, so the continuation would end up on the heap, but that's not what really happens.
11:20:45 <kmc> IO actions are first-class values -- so even after you've built them with (>>=) or "do", you can control when (if at all) they execute, using higher-order functions
11:20:52 <EvanR> kmc: i just saw in this rabbit hole tutorial they guy remark 'was can make arbitrary control structures, like execute action while it returns not false' and proceeds to give the definition as = ??? :)
11:20:55 <aavogt> well why would you generate the list of IO actions if you didn't want to execute them in that order ...?
11:20:59 <EvanR> and they were just talking about that in here heheh
11:21:17 <kmc> aavogt, as an example, you might want to pick one randomly and execute it
11:21:18 <aavogt> anyways, reordering lists is relatively expensive
11:21:40 <mmorrow> Cale: you could though store "stack frames" as a linked list in the heap (which would also give you O(1) (real) callcc !!)
11:21:48 <kmc> (Array a) => IO (a Int (IO ())) ;)
11:23:00 <aavogt> @hoolge Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
11:23:00 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:23:00 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:23:00 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
11:23:17 <kmc> Do we still call a function "higher-order" if it has no arguments that are functions, but has some that are of monadic type?
11:23:30 <dh___> good evening. May I ask a question ?
11:23:37 <kmc> dh___, yes.  but don't ask to ask :)
11:23:59 <kmc> by joining this channel you are given implicit permission to ask questions.  It's in the EULA.
11:24:18 <aavogt> as in, do implicit arguments in say a (Monad m =>) count as arguments?
11:24:46 <dh___> when we use lambda to represent nature number, for the predecessor function lambda x = x -1 , how can I represent it with sucessor function ?
11:24:59 <kmc> dh___, are you talking about church numerals?
11:25:07 <EvanR> holy crap my code compiled :o
11:25:07 <dh___> the book I'm reading give : prec ( succ k ) = k
11:25:09 <dh___> yes.
11:25:09 <aavogt> so strictly,   (MonadReader (Int -> String) m) => m a   is higer order?
11:25:25 <kmc> the wikipedia article on church numerals gives definitions for various operators, including pred i believe
11:25:56 <dh___> but prec (succ k) wouldn't compile by haskell,  it gives me parse error on pattern.
11:26:12 <kmc> dh___, right.  you can't pattern match on the application of a function "succ"
11:26:25 <kmc> you could have something like this:
11:26:26 <dh___> kmc : thanks. any solution ?
11:26:29 <kmc> data Nat = Zero | Succ Nat
11:26:34 <kmc> pred Zero = Zero
11:26:37 <kmc> pred (Succ n) = n
11:26:44 <kmc> but those aren't church numerals
11:26:51 <dh___> lol.
11:26:54 <kmc> the church numeral are the folds over that datatype
11:27:15 <kmc> wp says     pred ≡ λn.λf.λx. n (λg.λh. h (g f)) (λu. x) (λu. u)
11:27:19 <kmc> which you can translate into Haskell
11:27:41 <dh___> got it, thanks, what is wp?
11:27:45 <kmc> wikipedia
11:27:58 <dh___> thanks :) have a nice evening.
11:28:02 <kmc> :t \n f x -> n (\g h -> h (g f)) (\u -> x) (\u -> u)
11:28:03 <lambdabot> forall t t1 t2 t3 t4 t5 t6. (((t -> t2) -> (t2 -> t3) -> t3) -> (t4 -> t1) -> (t5 -> t5) -> t6) -> t -> t1 -> t6
11:28:03 <kmc> you too
11:28:06 <EvanR> the lambda is xterm are funny looking ;)
11:28:07 <Cale> pred is probably most easily written in terms of isZero
11:28:09 <EvanR> in*
11:28:31 <Cale> because you sort of have to handle the 0 case specially
11:28:50 <dh___> Cale : what your mean by isZero ? I'm new to Haskell.
11:29:03 <dh___> just use Haskell to learn math .
11:29:14 <Cale> dh___: I mean a lambda calculus function which determines if a natural number is zero or not
11:29:20 <kmc> dh___, wikipedia calls it "zero?"
11:29:33 <copumpkin> allbery_b: wow @ http://www.sciencedaily.com/releases/2009/12/091210203423.htm?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+sciencedaily+%28ScienceDaily%3A+Latest+Science+News%29
11:29:37 <Cale> Does it? It appears to call it ISZERO
11:29:39 <kmc> then you also have to learn the church encoding of booleans
11:29:40 <dh___> no, I defined zero my self
11:29:52 <kmc> Cale, i'm on the "Church encoding" article
11:29:55 <dh___> zero f x = x
11:29:55 <dh___> suc n f x = f ( n x )
11:29:56 <dh___> prec zero = zero
11:29:56 <dh___> prec (suc n) = n
11:30:02 <copumpkin> http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1000599
11:30:09 <kmc> copumpkin, :O
11:30:10 <allbery_b> yeh, I was startled
11:30:17 <Cale> isZero n = n (\x -> false) true
11:30:21 <copumpkin> "What Do Transitive Inference and Class Inclusion Have in
11:30:21 <copumpkin> Common? Categorical (Co)Products and Cognitive
11:30:21 <copumpkin> Development "
11:31:08 <kmc> "Categorical (Co)Products and (Co)ognitive Development"
11:31:24 <Cale> Co-ognitive
11:32:02 <Cale> dh___: along with  true x y = x  and false x y = y
11:32:32 <copumpkin> at a glance, it doesn't look like a very profound application of CT
11:32:38 <copumpkin> but I've only just skimmed it
11:33:58 <EvanR> i thought python was bad with the identation rules, but i just cant get the hang of it in haskell. cant seem to format do blocks, using vim, any tips on tabwidth etc?
11:34:32 <heatsink> EvanR: I prefer tabwidth of 2
11:34:36 <HaskellLove> I just had the BIGGEST COOLEST AHA MOMENT in functional programming. I was solving euler 11 and in imperative you would have two for loops, both going from 0 to 20, one nested in the other ... and how to represent that in func... well you just say i <- [0..20], j<-[0..20] and that is it... functional programming is more like ALL AT ONCE instead of imperative ONE AT A TIME
11:34:41 <Cale> EvanR: Ensure that no tabs occur in your source files
11:34:47 <gwern> hm. is "woman's" 3 or 2 syllables I wonder
11:34:53 <EvanR> all spaces?
11:34:55 <kmc> HaskellLove, yes :)
11:34:58 <Cale> EvanR: yes
11:35:02 <copumpkin> HaskellLove: [0..20] is 21 values, by the way
11:35:09 <copumpkin> > length [0..20]
11:35:10 <lambdabot>   21
11:35:10 <kmc> EvanR, Haskell's treatment is better, because our whitespace translates into explicit { } ;
11:35:12 <Cale> EvanR: Any decent text editor has an option to expand tabs
11:35:14 <kmc> so in the worst case you can use those
11:35:17 <kmc> but yes tabs are the devil
11:35:45 <EvanR> tabs work for me in c ;)
11:35:54 <heatsink> EvanR: The rule is that everything in a block should line up with the first token after the (do, let, in, or whatever) keyword
11:36:06 <EvanR> since using 8 space tabs i have feared going back to space bar
11:36:17 <Cale> EvanR: That aside, the main rule is that if things are siblings, you line them up vertically -- that is, they start in the very same column, and if one thing is the child of another, it starts in a deeper column.
11:36:38 <EvanR> yeah, the main key i was missing was to avoid tabs
11:37:05 <Cale> EvanR: as a decent example, the lines inside of a do should line up as:
11:37:07 <Cale> do foo
11:37:08 <Cale>    bar
11:37:12 <Cale>    baz
11:37:31 <Cale> The first-non-whitespace character after "do" sets the indentation level.
11:37:35 <aavogt> just set expandtab, and then the tab key does the right thing
11:38:05 <EvanR> :set ai doesnt seem to help in haskell mode...
11:38:15 <EvanR> expand tab..
11:38:39 * Cale just has  set expandtab   in his .vimrc
11:38:55 <dh___> cale : thanks for the true , false things. first time know it.
11:39:15 <EvanR> ah yeah
11:39:24 * EvanR tries to backspace ah cant! ;)
11:39:33 <Cale> set smarttab
11:39:36 <aavogt> C-w
11:39:47 <Draconx> :set expandtab smarttab shiftwidth=4
11:39:49 <EvanR> nice
11:40:14 <EvanR> smarttab
11:40:20 <EvanR> sweet
11:40:26 <Cale> I usually use a shiftwidth of 2
11:40:38 <Cale> since it's more convenient to have small jumps to line things up precisely
11:40:55 <allbery_b> you can also use ^T to indent and ^D to outdent in vi-alikes
11:41:04 <Zao> ts?
11:41:24 <EvanR> sw=2
11:41:25 <dh___> well, guys, should that be in the #vim?
11:41:34 <Draconx> Cale, I have another key for small jumps, the big rectangular one in the bottom middle :)
11:41:35 <EvanR> now it takes almost as long to tab over as space ;)
11:41:40 <dh___> s/should/ shouldn't
11:42:01 <EvanR> im going with Draconx on that one
11:42:19 <allbery_b> sensible way to do this is leave tab as is and use ^T/^D for short tabs
11:43:08 <Draconx> ^T in vim means "pop from tag stack", by default.
11:43:27 <EvanR> in insert mode its tabbing and detabbing
11:43:45 <Draconx> oh, weird.
11:43:47 <EvanR> but not short
11:43:51 <EvanR> *shrugs*
11:44:25 <allbery_b> ^T obeys shiftwidth by default, while TAB uses tabsize
11:44:41 <allbery_b> smarttabs mkes TAB the same as ^T (I think)
11:45:09 <allbery_b> so if you leave it off and set shiftwidth, ^T is a shiftwidth and TAB is a larger indent
11:45:32 <Draconx> smarttab makes the tab key use shiftwidth, yes.
11:45:48 <Zao> How does 'tabstop' play in?
11:46:10 <allbery_b> tabstop is the "soft" meaning of TAB (when smarttab is off)
11:46:29 <allbery_b> hardtabs is what a TAB sent to the terminal does, which is not necessarily the same thing
11:46:52 <allbery_b> so with smarttab on, TAB indents by shiftwidth, otherwise by tabstop
11:47:41 <nolrai_FG> @djinn a->(a->b)->(a->b)->(b->b->c)->c
11:47:42 <lambdabot> f a b c d = d (c a) (b a)
11:47:58 <allbery_b> quite commonly you'll see code with a modeline that sets ts=4, meaning every tab in thew file is 4 spaces
11:48:07 <nolrai_FG> @pl f a b c d = d (c a) (b a)
11:48:08 <lambdabot> f = ap ((.) . flip . ((flip . flip id) .) . flip id) (flip id)
11:48:16 <nolrai_FG> hmm
11:48:37 <nolrai_FG> :t join (&&)
11:48:40 <lambdabot> Bool -> Bool
11:49:27 <kmc> > join (&&) True
11:49:28 <lambdabot>   True
11:49:29 <kmc> > join (&&)
11:49:30 <lambdabot>   {True->True;False->False}
11:49:35 <kmc> > join (||)
11:49:36 <lambdabot>   {True->True;False->False}
11:49:44 <kmc> welllll
11:49:49 <kmc> > join (++)
11:49:52 <lambdabot>   {()->()}
11:50:04 <dh___> :t join
11:50:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:50:14 <allbery_b> "yay" MMR
11:50:33 <EvanR> should i in general specify the type of all my declarations
11:50:49 <EvanR> i suppose its not customary to do that in let and where?
11:50:49 <c_wraith> all the top-level ones, anyway.  it's helpful documentation
11:52:46 * BMeph would try 'join xor' except xor is a Bits function, and not defined on Bool...yet...
11:52:55 <xerox> > join (/=)
11:52:56 <lambdabot>   {()->False}
11:53:03 <dh___> ? join
11:53:09 <dh___> @join
11:53:10 <lambdabot> Not enough privileges
11:53:21 <dh___> @help
11:53:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:53:22 <c_wraith> > join ["foo", "bar"]
11:53:22 <xerox> > (/=) -- xor
11:53:23 <lambdabot>   "foobar"
11:53:23 <dibblego> BMeph, (/=)
11:53:23 <lambdabot>   {()->{()->False}}
11:53:24 <mmorrow> , join (+) 42
11:53:25 <lunabot>  84
11:53:34 <dh___> @list
11:53:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:53:45 <xerox> > (/=) :: Bool -> Bool -> Bool
11:53:46 <lambdabot>   {True->{True->False;False->True};False->{True->True;False->False}}
11:53:48 <mauke> > join (/=) :: Bool -> Bool
11:53:49 <lambdabot>   {True->False;False->False}
11:53:51 <mmorrow> > join (&&&) 42
11:53:52 <lambdabot>   No instance for (GHC.Show.Show (a b (c, c)))
11:53:52 <lambdabot>    arising from a use of `M509...
11:54:01 <mmorrow> > join (,) 42
11:54:02 <lambdabot>   (42,42)
11:54:02 <mmorrow> heh
11:54:28 <BMeph> dibblego: Yes, but it's (denotationally) not the same... ;)
11:55:47 <dh___> what is that join thing?
11:56:05 <dibblego> a monad function
11:56:13 <mauke> > join f x
11:56:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:56:14 <lambdabot>    `GHC.Show.Show a'
11:56:14 <lambdabot>      a...
11:56:30 <dibblego> for one particular monad, it is (a -> a -> t) -> a -> t
11:56:32 <dh___> dibblego : thanks
11:56:34 <mauke> > join (f :: Expr -> Expr -> Expr) x
11:56:35 <lambdabot>   f x x
11:56:39 <dh___> @hoggle
11:56:40 <lambdabot> No query entered
11:56:40 <lambdabot> Try --help for command line options
11:56:43 <elly>  /w 25
11:56:45 <elly> oops
11:56:48 <dh___> @hoggle join
11:56:48 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:56:48 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
11:56:48 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
11:59:10 <dh___> I tried join (,) 42 on ghci, ( after import), it's not working . so this join is different.
12:00:03 <dibblego> dh___, define "not working"
12:00:17 <dibblego> Prelude Control.Monad Control.Monad.Instances> join (,) 42
12:00:17 <dibblego> (42,42)
12:00:18 <xerox> :m + Control.Monad.Reader
12:00:19 <copumpkin> dh___: you probably don't have Control.Monad.Instances loaded
12:00:35 <xerox> oh, Instances must be new :)
12:01:00 <HaskellLove> is this ok or bad? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14012#a14012 It gives me error trying to figure out why maybe this syntax is wrong?
12:01:10 <Lemmih> xerox: You're getting old, my man. (:
12:01:23 <dh___> got it . I just imported Control.Monad.
12:01:27 * xerox hugs Lemmih -- hi there =)
12:01:44 <copumpkin> HaskellLove: you need [] or () around your commas for lines 2-10
12:01:50 <Lemmih> xerox: Hiya, long time no see.
12:01:51 <copumpkin> not sure what you actually want
12:02:19 <xerox> Lemmih: indeed... how's unicycling?
12:02:39 <HaskellLove> copumkin yeah i know will put them in [] otherwise that way is ok? i mean, should i define left, right and all that in the list comprehension or?
12:02:53 <BMeph> HaskellLove: Just a heads-up; Haskell does not use dynamic scope... ;)
12:02:58 <dh___> join is like the W combinator, right ?
12:03:05 <dh___> W f x = f x x
12:03:16 <Lemmih> xerox: I'm a bit rusty. Just started taking it up again after a year of down time.
12:03:58 <HaskellLove> BMeph, which means i should define them in the comprehension list correct?
12:04:26 <HaskellLove> copumkin by the way, that is euler 11
12:04:52 <jimmyjazz14> Anyone had any luck building gui's in OS X with Haskell?
12:05:27 <BMeph> HaskellLove:  The conventional way would be to declare them as functions. Well, the "conventional" way would be to do it another way altogether... ;)
12:05:41 <xerox> jimmyjazz14: I had GTK working, there's a "native" backend. One reads that Cocoa bindings are also avaiable, but I never tried them.
12:06:12 <HaskellLove> BMeph>	yeah but i think this way it should work
12:06:14 <jimmyjazz14> xerox: yeah I was thinking of using GTK but it always looked a little ugly in OS X
12:06:30 <copumpkin> HaskellLove: you might need a more imaginative solution
12:06:44 <xerox> jimmyjazz14: that should be not the case anymore, modulo glitches, I wonder what's the status of the backend now.
12:06:48 <copumpkin> HaskellLove: but you may be able to get away with this for this relatively small problem
12:07:07 <HaskellLove> you mean about end cases corners and stuf?
12:07:53 <copumpkin> HaskellLove: not just that, but you're going to recompute the product of numbers multiple times
12:09:10 <HaskellLove> copumkin: actually each list is uniqe, am i wrong?
12:09:35 <xerox> jimmyjazz14: http://www.gtk-osx.org/ looks good, and then compile gtk2hs with the right options should work
12:09:46 <copumpkin> HaskellLove: look at the highlighted example in the problem itself
12:09:53 <copumpkin> how many times will you multiply 63 * 78?
12:11:12 <BMeph> HaskellLove: Another thing is that you mixed up using '<-' and 'let/=' in the comp, too. :)
12:11:42 <dh___> where can I find some doc about the join Monad ?
12:11:54 <copumpkin> join is a function on monads
12:11:58 <copumpkin> it isn't a monad itself
12:12:07 <copumpkin> traditionally, it's one of three parts that actually defines a monad
12:12:13 <HaskellLove> BMeph>	oops, thanks for pointing out still getting used to things around and kinda sleepy so :)
12:12:15 <BMeph> Some would say that it's "the" function on monads... ;)
12:12:52 <tensorpudding> join can be defined in terms of return and >>= though
12:12:58 <copumpkin> yep
12:13:07 <copumpkin> well, >>= and id
12:13:15 <tensorpudding> @src join
12:13:16 <lambdabot> join x =  x >>= id
12:13:17 <dh___> confused by join... I know about return  and >>
12:13:33 <copumpkin> > join [[1,2,3],[4,5,6]]
12:13:33 <lambdabot>   [1,2,3,4,5,6]
12:13:40 <copumpkin> > join (Just Nothing)
12:13:41 <lambdabot>   Nothing
12:13:44 <tensorpudding> apparently join takes off a layer of monadic wrapping
12:13:53 <c_wraith> :t join
12:13:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:13:54 <copumpkin> > join (Just (Just 5))
12:13:55 <lambdabot>   Just 5
12:14:08 <kmc> join :: m (m a) -> m a
12:14:10 <tensorpudding> > join (Nothing (Just 5))
12:14:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t -> m (m a)'
12:14:11 <lambdabot>         agains...
12:14:12 <c_wraith> Seriously, the type signature tells pretty much all the story for join
12:14:12 <kmc> for m a Monad
12:14:27 <tensorpudding> > join (Just (Nothing))
12:14:28 <lambdabot>   Nothing
12:14:34 <kmc> > join (Just (Just ()))
12:14:35 <lambdabot>   Just ()
12:14:38 <kmc> > join Nothing
12:14:39 <lambdabot>   Nothing
12:14:48 <tensorpudding> that's confusing...
12:14:49 <kmc> > join :: (Maybe (Maybe ())) -> Maybe ()
12:14:50 <lambdabot>   {Nothing->Nothing;Just Nothing->Nothing;Just (Just ())->Just ()}
12:14:56 <tensorpudding> :t Nothing
12:14:56 <kmc> why is it confusing?
12:14:57 <lambdabot> forall a. Maybe a
12:15:04 <tensorpudding> oh..
12:15:08 <tensorpudding> no it does make sense
12:15:14 <kmc> Nothing :: forall a. Maybe (Maybe a)
12:15:18 <kmc> a more specific type
12:15:20 <HaskellLove> BMeph>	yeah u r right, it says i not in scope, so i am gonna do it with functions now the conventional way :)
12:15:21 <tensorpudding> yeah
12:15:40 <kmc> > join :: [[()]] -> [()]
12:15:41 <lambdabot>   []->
12:15:41 <lambdabot>    []
12:15:41 <lambdabot>  [[]]->
12:15:41 <lambdabot>    []
12:15:41 <lambdabot>  [[],[]]->
12:15:43 <lambdabot> [5 @more lines]
12:15:48 <kmc> > join ["abc", "def"]
12:15:49 <lambdabot>   "abcdef"
12:16:04 <tensorpudding> > join (Just [1,2,3,4,5])
12:16:04 <BMeph> HaskellLove: Like...  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14012#a14013 this? ;)
12:16:05 <lambdabot>   Couldn't match expected type `[[t]]'
12:16:05 <lambdabot>         against inferred type `Data.Ma...
12:16:06 <c_wraith> > join (*) $ 15
12:16:07 <lambdabot>   225
12:16:13 <kmc> has to be the same monad
12:16:24 <tensorpudding> @src concat
12:16:24 <lambdabot> concat = foldr (++) []
12:16:30 <copumpkin> > Data.Traversable.sequence (Just [1..5])
12:16:31 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5]
12:16:31 <dh___> join f x
12:17:19 <HaskellLove> BMeph>	yep :) plus brackets around the functions` results
12:17:22 <kmc> > join f x :: Expr -> Expr
12:17:23 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
12:17:23 <lambdabot>    arising from...
12:17:35 <tensorpudding> :t join (*) $ 15
12:17:36 <lambdabot> forall a. (Num a) => a
12:17:39 <dh___> join (+) 5 behaviors like W (+) 5 , W is the  combinator  W f x = f x x
12:17:43 <tensorpudding> :t join (*)
12:17:44 <lambdabot> forall a. (Num a) => a -> a
12:17:46 <kmc> > let square = join (*) in square 5
12:17:47 <lambdabot>   25
12:18:43 <dh___> so I can understand join (,) 5 ==> (5,5)
12:18:54 <tensorpudding> that's kinda confusing
12:19:03 <kmc> that's join for the ((->) e) monad
12:19:05 <dh___> but join [(1,2) , (3,4)]  is another meaning for me .
12:19:10 <copumpkin> dh___: that doesn't work
12:19:19 <ray> > liftA2 (*) (+4) (+5) $ 3
12:19:20 <lambdabot>   56
12:19:22 <dh___> copumpkin : which one ?
12:19:23 <kmc> dh___, that doesn't work.  but you can use join [[1,2], [3.4]] ===> [1,2,3,4]
12:19:27 <kmc> that's the list monad
12:19:27 <ray> are you more confused now?
12:19:34 <kmc> join :: (a -> a -> b) -> (a -> b
12:19:36 <copumpkin> :t Data.Traversable.sequence
12:19:37 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
12:19:38 <kmc> join :: [[a]] -> [a]
12:19:44 <kmc> those are two types of join for two different monads
12:19:52 <copumpkin> > Data.Traversable.sequence (5, [1..5])
12:19:53 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t))
12:19:53 <lambdabot>    arising from a us...
12:19:54 <kmc> join :: Maybe (Maybe a) -> Maybe a
12:20:03 <tensorpudding> hmm
12:20:09 <tensorpudding> i hate IRC
12:20:10 <copumpkin> > Data.Traversable.sequence (zip [1..] [1..5])
12:20:11 <dh___> I mean : I can't see the common between list join and  function join :)
12:20:11 <lambdabot>   No instance for (GHC.Base.Monad ((,) t))
12:20:11 <lambdabot>    arising from a use of `Data.Tra...
12:20:27 <copumpkin> > Data.Traversable.sequence (zip (map Sum [1..]) [1..5])
12:20:27 <lambdabot>   No instance for (GHC.Base.Monad ((,) (Data.Monoid.Sum a)))
12:20:28 <lambdabot>    arising from ...
12:21:34 <kmc> dh___, they're not really that similar... each Monad is defined primarily by its implementation of join
12:21:45 <ray> :t join (,)
12:21:45 <kmc> so you can expect different monads to do different things
12:21:46 <lambdabot> forall a. a -> (a, a)
12:21:51 <kmc> subject to the monad laws
12:21:53 <dh___> kmc : ok, that make sense. thanks .
12:22:12 <copumpkin> I thought Monoid a => ((,) a) was a Monad
12:22:26 <kmc> the reason we group them together is to use some common operators and syntax to work with all monads, even though each one does something different
12:22:30 <ray> YOU THOUGHT right i think
12:22:42 <tensorpudding> :t join error
12:22:43 <lambdabot> forall a. [Char] -> a
12:23:02 <tensorpudding> > join error "what will this do"
12:23:03 <lambdabot>   * Exception: what will this do
12:23:10 <kmc> > join ([1,2], ([3,4], "foo"))
12:23:11 <lambdabot>   No instance for (GHC.Base.Monad ((,) [t]))
12:23:11 <lambdabot>    arising from a use of `Contro...
12:23:23 <kmc> hmm, [t] should be a monoid shouldn't it?
12:23:33 <copumpkin> it is
12:23:37 <tensorpudding> ((,) [t]) isn't though
12:23:43 <tensorpudding> apparently
12:23:51 <kmc> i thought that if [t] was a monoid, ((,) [t]) should be a monad
12:23:51 <copumpkin> I wanted it to be a monad
12:23:55 <copumpkin> yeah
12:23:56 <copumpkin> me too
12:24:24 <kmc> you can write the instance, guess lambdabot doesn't have it :/
12:24:32 <tensorpudding> :t join (&&&)
12:24:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
12:24:38 * copumpkin shakes his head at lambdabot
12:24:46 <kmc> > join $ Right $ Right 3
12:24:47 <lambdabot>   Ambiguous type variable `a' in the constraints:
12:24:47 <lambdabot>    `Control.Monad.Error.Cla...
12:25:16 <Draconx> silly caleskell, not having such instances :)
12:25:28 <Draconx> :t (++)
12:25:30 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:25:32 <Draconx> :t concat
12:25:33 <lambdabot> forall a. [[a]] -> [a]
12:25:46 <kmc> :t mconcat
12:25:47 <lambdabot> forall a. (Monoid a) => [a] -> a
12:25:47 <Draconx> I'm surprised caleskell doesn't have concat = mconcat
12:26:12 <tensorpudding> :t (++)
12:26:13 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:26:21 <tensorpudding> hmm
12:26:22 <Draconx> @src concat
12:26:22 <lambdabot> concat = foldr (++) []
12:26:31 <Draconx> :t foldr (++) []
12:26:32 <manju_> I have numbers in the form of strings, is there a way to get the individual numbers as ints ?
12:26:32 <lambdabot> forall a. [[a]] -> [a]
12:26:35 <manju_> for example
12:26:39 <manju_> "13967"
12:26:48 <manju_> I want [1,3,9,6,7]
12:26:49 <tensorpudding> :t (++ [1,2,3])
12:26:50 <lambdabot> forall t. (Num t) => [t] -> [t]
12:27:01 <tensorpudding> :t (++ "foo")
12:27:02 <lambdabot> [Char] -> [Char]
12:27:08 <dh___> @src join
12:27:08 <lambdabot> join x =  x >>= id
12:27:27 <tensorpudding> hmm, what else is a monoid
12:27:34 <Draconx> > map (subtract '0') "13967"
12:27:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
12:27:35 <lambdabot>    arising from a use of `GHC....
12:27:49 <Draconx> > map (chr . subtract '0' . ord) "13967"
12:27:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:27:50 <lambdabot>         against inferred type ...
12:27:54 <tensorpudding> @hoogle Monoid
12:27:54 <lambdabot> module Data.Monoid
12:27:54 <lambdabot> Data.Monoid class Monoid a
12:27:58 <Draconx> > map (chr . subtract (ord '0') . ord) "13967"
12:27:59 <lambdabot>   "\SOH\ETX\t\ACK\a"
12:29:15 <manju_> > map read "13967"
12:29:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:29:16 <lambdabot>         against inferred ty...
12:29:16 <Draconx> > map (subtract (ord '0') . ord) "13967"
12:29:17 <lambdabot>   [1,3,9,6,7]
12:29:20 <Draconx> there we go.
12:29:25 <Draconx> manju_, that one :P
12:29:30 <manju_> heh.. :-)
12:29:34 <manju_> thanks
12:29:47 <manju_> > sum (map (subtract (ord '0') . ord) "13967")
12:29:48 <lambdabot>   26
12:30:15 <manju_> > (sum (map (subtract (ord '0') . ord) "13967")) `mod` 3 == 0
12:30:16 <lambdabot>   False
12:30:39 <BMeph> > map ((*1).read) "13967"
12:30:40 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:30:40 <lambdabot>         against inferred ty...
12:31:06 <BMeph> Bah. Stupid String-using read... :(
12:31:43 <BMeph> > map ((*1).read.(:[])) "13967"
12:31:44 <lambdabot>   [1,3,9,6,7]
12:31:57 * BMeph cheers for the Robot Monkey!
12:32:21 <kmc> > map digitToInt "13967"
12:32:22 <lambdabot>   [1,3,9,6,7]
12:32:27 <Draconx> bastard.
12:33:04 <manju_> gah
12:33:07 <manju_> that is so simple
12:33:52 <absentia> hehe
12:33:54 <manju_> digitToInt doesn't exist
12:34:08 <Draconx> Data.Char, same as ord.
12:34:40 <manju_> ah...ok
12:38:19 <dh___> I'm leaving, thanks for the help , guys, :)
12:44:02 <HaskellLove> resultList = [left i j, right i j, up i j, down i j, diagUL i j, diagUR i j, diagDL i j, diagDR i j | i <- [0..19], j <- [0..19]]        Why do I get error at the "|" character?
12:45:20 <kmc> HaskellLove, what is the type of the list supposed to be?
12:45:46 <HaskellLove> list of lists of Ints
12:46:01 <copumpkin> []
12:46:03 <copumpkin> needs moar
12:46:05 <HaskellLove> those functions are ok, they return lists with 3 Ints
12:46:30 <kmc> this is not a valid list comprehension:  [a, b | ...... ]
12:46:37 <kmc> this is:  [[a,b] | ..... ]
12:46:41 <kmc> as is:   [(a,b) | ...... ]
12:46:57 <kmc> the thing to the left of '|' has to be one expression
12:47:10 <HaskellLove> oh i see
12:47:13 <HaskellLove> thanks
12:53:21 <pastah_rhymez> what's this called?
12:53:23 <pastah_rhymez> first f (x,y) = (f x, y)
12:53:25 <pastah_rhymez> second g (x,y) = (x, g y)
12:54:09 <aavogt> > first succ (1,1)
12:54:09 <lambdabot>   (2,1)
12:54:16 <aavogt> @where sec
12:54:16 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
12:54:18 <copumpkin> pastah_rhymez: what's what called?
12:54:41 <aavogt> where bananna
12:54:45 <aavogt> @where bananna
12:54:46 <lambdabot> I know nothing about bananna.
12:54:53 <aavogt> @where banannas
12:54:53 <lambdabot> I know nothing about banannas.
12:54:55 <pastah_rhymez> copumpkin: URL ^^
12:55:04 <pastah_rhymez> aavogt: thank's bro!
12:55:18 <copumpkin> yeah, saw those :) I thought you were just talking about the arrow versions
12:55:23 <aavogt> I'm not sure that such things are as amazing as advertised
12:55:26 <pastah_rhymez> aavogt: up here! _\|/_
12:55:35 <pastah_rhymez> (those are five fingers)
12:55:40 <aavogt> hifive
12:55:43 <pastah_rhymez> o/
12:55:48 <pastah_rhymez> heilfive
12:56:22 <aavogt> who uses the arrow versions?
12:56:22 <pastah_rhymez> copumpkin: no arrows, that'll just mess up my head
12:56:34 <copumpkin> I do, because they're built-in
12:56:43 <pastah_rhymez> keepin' it simple!
12:56:44 <copumpkin> I don't use them for non-function arrows though
12:56:51 <aavogt> yeah, that's what I mean
12:56:51 <copumpkin> well, maybe once or twice for Kleisli
12:57:07 <aavogt> @type first
12:57:08 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:57:40 <aavogt> @type first ?f $ Kleisli (return ('a',1))
12:57:41 <lambdabot>     Couldn't match expected type `(b, d)'
12:57:42 <lambdabot>            against inferred type `Kleisli ((,) Char) a t'
12:57:42 <lambdabot>     In the second argument of `($)', namely `Kleisli (return ('a', 1))'
12:57:49 <copumpkin> well, maybe once or twice for Kleisli
12:57:59 <copumpkin> @type first `asTypeIn` (runKleisli .)
12:58:00 <lambdabot> forall b c d (m :: * -> *). (Monad m) => Kleisli m b c -> Kleisli m (b, d) (c, d)
12:58:13 <copumpkin> @type runKleisli . first
12:58:13 <aavogt> @ty asTypeIn
12:58:14 <lambdabot> forall (m :: * -> *) b c d. (Monad m) => Kleisli m b c -> (b, d) -> m (c, d)
12:58:15 <lambdabot> forall a b. a -> (a -> b) -> a
12:58:29 <aavogt> @ty asTypeIn
12:58:30 <lambdabot> forall a b. a -> (a -> b) -> a
12:58:39 <aavogt> that's an interesting extension of asTypeOf
12:58:52 <aavogt> what's the variation for function of 2 arity?
13:00:17 <shepheb> @users
13:00:17 <lambdabot> Unknown command, try @list
13:02:13 <copumpkin> aavogt: uncurry ;)
13:02:41 <newsham> ?djinn a -> (a -> b) -> a
13:02:41 <lambdabot> f a _ = a
13:02:46 <aavogt> yeah, I was wondering what the preposition would be though
13:02:56 <aavogt> asTypeInIn
13:03:05 <aavogt> or somethin nonsensical like that
13:05:21 <kmc> @quote kleisli
13:05:21 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
13:05:58 <newsham> nice
13:06:59 <Bobrobyn> Does learning Lisp first make learning Haskell easier?
13:07:11 <copumpkin> maybe a tad, but probably not much
13:07:14 <Bobrobyn> Like, should I learn Lisp before learning Haskell?
13:07:18 <copumpkin> nope
13:07:20 <copumpkin> get on haskell ASAP
13:07:26 <copumpkin> every day you don't know haskell is a day wasted
13:07:29 <newsham> if you write functional lisp programs you will have some experience writing functions
13:07:30 <dibblego> Bobrobyn, no, no
13:07:37 <newsham> which can help with certain aspects of haskell programming
13:08:10 <xerox> or you could speed-run through SICP if you feel like it =)
13:08:56 <xerox> Scheme's simplicity is kind of nice to see, but yes, go for Haskell!
13:09:07 <newsham> are there many people who do haskell consulting and contracting?  Is most consulting about haskell compilers and tools?
13:10:11 <Axman6> Bobrobyn: what you'll learn in lisp can be learnt in haskell, with much nicer syntax and function names
13:10:39 <Axman6> like, wtf does cdr mean?
13:10:45 <newsham> axman: except macros, which work out nicer in the minimal lisp syntax
13:11:00 <Axman6> yeah, but who needs macros
13:11:01 <Axman6> >_>
13:11:10 <newsham> luckily lots of macros can be avoided in haskell due to laziness
13:11:12 <newsham> but not all
13:11:29 <Bobrobyn> A friend of mine and I are thinking of learning functional programming...we spent one night on Haskell...but we still aren't very far...and my friend thinks that learning Lisp first makes sense, because it was around first, and Haskell builds on top of what Lisp already has (or so we assume)...kind of like learning C before learning Java or C++.
13:11:56 <xerox> yeah, in the skimming of Scheme I'd pass over macros and continuations :)
13:12:00 <Axman6> haskell isn't very related to lisp, from what i can tell
13:12:08 <copumpkin> Axman6: contents of * register
13:12:12 <dibblego> Bobrobyn, your friend is wrong
13:12:32 <newsham> bobrobyn: I wouldnt recommend learning C in order to learn Java, either.
13:12:40 <Axman6> Bobrobyn: i think if you wanted to learn Java, i woould not learn C first
13:13:01 <Bobrobyn> Haha, I would.  Most people I know that have learned Java before C...or OO before procedural...are stuck in the OO world :p
13:13:21 <newsham> you can learn java first and then learn procedural programming
13:13:27 <newsham> or learn C first and learn OO programming
13:13:40 <Bobrobyn> That is true.
13:14:27 <newsham> you could study lambda calculus (untyped and typed) and category theory first, and then learn haskell
13:14:44 <newsham> or you could just learn haskell and then try to pick up what you want to know about those other subjects later
13:14:46 <Bobrobyn> So I won't be missing out on much if I learn Haskell first?
13:14:54 <dibblego> the hardest parts of Haskell are purity, laziness, static typing (thinking first, rather than last) -- you'll get none of this from Lisp
13:15:05 <newsham> hard to answer "missing out much".  there's lots of great stuff to learn from all languages :)
13:15:10 <Axman6> newsham: i found learning haskell first made learning lambda calculus very easy
13:15:18 <Axman6> Bobrobyn: god no :)
13:15:23 <newsham> but, its not like a prequel that gives big insights into some complicated plot line
13:15:27 <newsham> you wont need the lisp first
13:15:36 <Bobrobyn> I'm planning on working on my math, because I suck at it...and part of me thought that learning functional programming would help with that.
13:15:47 <Bobrobyn> I barely passed my calc course ;)
13:15:48 <copumpkin> it will if you fully embrace its glory
13:15:51 <newsham> haskell is a good tool for maths
13:16:06 <newsham> also if you learn haskell you can read sigfpe
13:16:10 <newsham> which is also a good tool for maths :)
13:16:15 <Bobrobyn> Alright
13:16:16 <Bobrobyn> Cool
13:16:40 <Bobrobyn> I'll bbiab.  Heading to campus to pull an all nighter studying stats :)  (I woke up at 6 PM...so it's not a real all nighter, haha :P)
13:16:43 <newsham> [19:07] < Bobrobyn> I barely passed my calc course ;)
13:16:53 <newsham> man, everybody likes to equate calc with math :(
13:16:57 <newsham> so much other interesting topics
13:20:08 <tensorpudding> calculus is a big one though
13:22:55 <gwern> 'Five-year-olds can reason about the world from multiple perspectives simultaneously, according to a new theory by researchers in Japan and Australia. Using an established branch of mathematics called Category Theory, the researchers explain why specific reasoning skills develop in children at certain ages, particularly at age five. The new theory, published December 11 in the open-access journal PLoS Computational Biology, shows that ...
13:23:01 <gwern> ... these reasoning skills have similar profiles of development because they involve related sorts of processes.'
13:23:13 <gwern> huh. I wonder how much category theory I'd need to know to follow their paper
13:23:33 <copumpkin> to my unlearned eye, it didn't seem terribly profound
13:23:40 <copumpkin> but maybe it is
13:23:55 <newsham> got url to paper/abstract?
13:24:03 <gwern> http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1000599
13:24:13 <gwern> full text seems
13:24:16 <newsham> ty
13:24:19 <gwern> maybe will read tomorrer
13:25:45 <kmc> fwiw i think learning lambda calculus / FP makes it easier to learn calculus of the newton and leibniz sort
13:26:00 <kmc> because derivative and integral are higher-order functions
13:26:06 <kmc> that's definitely how i thought about it when i was learning
13:26:17 <kmc> and it makes more sense than the crackhead conventional maths notation
13:27:02 <copumpkin> yeah
13:28:02 <newsham> those higher order functions peek into the functions, though
13:28:14 <newsham> which is a bit diff than most of th ehigher order functions used in functional programming
13:28:21 <xerox> newsham: not sure how sigfpe helps for learning math, none of the topics he touches were in my undergrad courses, but well, it does talk about very nice things indeed.
13:29:30 <EvanR> crackhead calculus
13:29:37 * EvanR takes notes
13:29:40 <newsham> xerox: what about http://blog.sigfpe.com/2009/10/what-category-do-haskell-types-and.html ?
13:30:12 <xerox> I haven't read them all. I'll read that one.
13:35:45 <pastah_rhymez> @pl (do { x <- [0..16]; y <- [0..16]; return (x,y) }
13:35:46 <lambdabot> (line 1, column 5):
13:35:46 <lambdabot> unexpected "{"
13:35:46 <lambdabot> expecting variable, "(", operator or ")"
13:35:53 <pastah_rhymez> @pl (do { x <- [0..16]; y <- [0..16]; return (x,y) })
13:35:53 <lambdabot> (line 1, column 5):
13:35:53 <lambdabot> unexpected "{"
13:35:53 <lambdabot> expecting variable, "(", operator or ")"
13:35:59 <gwern> pastah_rhymez: you mean @do ?
13:36:03 <gwern> do/undo
13:36:06 <Axman6> or @undo?
13:36:10 <pastah_rhymez> what?
13:36:21 <pastah_rhymez> i just want [(0,0) .. (16,16)];
13:36:30 <gwern> pastah_rhymez: do is extra syntax sugar, @pl only knows regular function syntax
13:36:41 <Cale> > join (liftM2 (,)) [0..16]
13:36:42 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),...
13:37:04 <gwern> @undo do { x <- [0..16]; y <- [0..16]; return (x,y) }
13:37:04 <lambdabot> [0 .. 16] >>= \ x -> [0 .. 16] >>= \ y -> return (x, y)
13:37:08 <pastah_rhymez> Cale: nasty person... how the hell does that work...
13:37:30 <gwern> @pl [0 .. 16] >>= \ x -> [0 .. 16] >>= \ y -> return (x, y)
13:37:30 <lambdabot> (`fmap` [0..16]) . (,) =<< [0..16]
13:37:33 <Cale> join in the function monad is   join f x = f x x
13:37:43 <pastah_rhymez> riiiight...
13:37:46 <pastah_rhymez> sorry, did'n see that
13:37:55 <pastah_rhymez> @type join
13:37:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:38:09 <Cale> and in the list monad, we effectively have  liftM2 f xs ys = [f x y | x <- xs, y <- ys]
13:38:22 <pastah_rhymez> yeah :)
13:38:25 <pastah_rhymez> i think i get it now
13:38:51 <pastah_rhymez> Cale: putting championships, here we come!!
13:39:03 <copumpkin> I did a really nasty list comprehension hack the other day
13:39:11 <pastah_rhymez> copumpkin: gief!
13:39:13 <pastah_rhymez> @hpaste
13:39:13 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:39:35 <HaskellLove> indexList = [[left i j, right i j, up i j, down i j, diagUL i j, diagUR i j, diagDL i j, diagDR i j] | i <- [0..19], j <- [0..19]] Why this gives me lists of lists of lists, when it is suposed to give lists of lists? by the way each of the functions left, right ... give list of three tuples (x,y) i need to have a list of lists of tuples, so i dont later use maps all over the place... this...
13:39:41 <HaskellLove> ...code is part of my euler 11 WIP: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14017#a14017
13:39:45 <copumpkin> trying to remember what it was now
13:39:53 <copumpkin> I was so disgusted I wrote it another way
13:39:58 <pastah_rhymez> awww
13:40:19 <copumpkin> oh
13:40:37 <copumpkin> it was Just + list comprehension on a function
13:40:48 <copumpkin> let me think up a concise example
13:41:52 <copumpkin> > [q | x <- [1..5], let y = lookup x [(3,4), (5,1)], Just q <- [y]]
13:41:53 <lambdabot>   [4,1]
13:42:09 <copumpkin> was trying to get the nice fail behavior
13:42:30 <copumpkin> it wasn't quite that
13:42:34 <copumpkin> but something similar
13:43:17 <copumpkin> > catMaybes . map (flip lookup [(3,4), (5,1)]) $ [1..5]
13:43:18 <lambdabot>   [4,1]
13:47:58 <Gracenotes> I has catMaybes for u
13:48:02 <HaskellLove> copumpkin u write to me or this is something else?
13:48:14 <copumpkin> I was talking to pastah_rhymez
13:51:20 <pastah_rhymez> copumpkin: sorry, busy proving to HaskellLove that i'm cool by golfing euler11
13:51:27 <pastah_rhymez> bot that looks kinda nasty
13:51:30 <copumpkin> lol
13:51:36 <copumpkin> need a histomorphism!
13:52:00 <pastah_rhymez> copumpkin: having [ (Int,Int) -> (Int,Int) ]
13:52:07 <EvanR> hoogle sleep
13:52:19 <pastah_rhymez> @hoogle sleep
13:52:19 <lambdabot> No results found
13:52:23 <pastah_rhymez> wat?
13:52:26 <pastah_rhymez> system.io?
13:52:37 <copumpkin> threadDelay
13:52:44 <EvanR> thanks
13:52:48 <pastah_rhymez> what's wrong with "sleep"?
13:52:49 <EvanR> biological search engines
13:52:57 <bfh6558> window new split
13:52:59 <bfh6558> sry
13:53:24 <xerox> why don't just flatten the matrix in an array and write accessor functions for the entries, and then do linear search?
13:53:53 <copumpkin> histomorphism ftw ;)
13:53:55 <xerox> or use data parallel haskell and get more than that for free! (not sure *how*)
13:55:12 <gwern> I maked a Maybe for you, but I cased it and was Nothing :(
13:55:26 <copumpkin> aw
13:57:00 <nolrai_FG> :t ("\nin" ++)
13:57:01 <lambdabot> [Char] -> [Char]
13:57:15 <nolrai_FG> :t map ("\nin" ++)
13:57:16 <lambdabot> [[Char]] -> [[Char]]
13:58:52 <pastah_rhymez> > map ("\nin" ++) ["compoop", "tendo", " makes good music"]
13:58:53 <lambdabot>   ["\nincompoop","\nintendo","\nin makes good music"]
13:59:58 <EvanCarroll> @src and
13:59:58 <lambdabot> and   =  foldr (&&) True
14:00:04 <EvanCarroll> @src any
14:00:05 <lambdabot> any p =  or . map p
14:00:14 <EvanCarroll> @src all
14:00:14 <lambdabot> all p =  and . map p
14:00:24 <EvanCarroll> @src and
14:00:25 <lambdabot> and   =  foldr (&&) True
14:04:10 <portnov> @src or
14:04:11 <lambdabot> or    =  foldr (||) False
14:04:32 <tensorpudding> @type join (&&)
14:04:33 <lambdabot> Bool -> Bool
14:04:53 <tensorpudding> > join (&&) True
14:04:54 <lambdabot>   True
14:05:35 <EvanCarroll> why is and, a foldr? and not foldl?
14:05:53 <elly> foldr is tail-recursive?
14:06:24 <copumpkin> foldl' is tail-recursive
14:06:36 <copumpkin> foldr is lazy-recursive :P
14:06:45 <EvanCarroll> aren't bot fold', and fold', tail-recursive?
14:06:47 <copumpkin> foldl shouldn't exist
14:06:59 <copumpkin> EvanCarroll: you accidentally your letters
14:07:00 <tensorpudding> it would be wise with and to be able to terminate after you reach a single False
14:07:13 <pastah_rhymez> HaskellLove: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14018#a14018
14:07:25 <pastah_rhymez> anyone feels like golfing?? ^^
14:07:41 <pastah_rhymez> i'm sure someone with arrow skillz can gold that quite a bit :)
14:07:49 <copumpkin> pastah_rhymez: both could have a more general type
14:07:59 <pastah_rhymez> copumpkin: both what+
14:08:01 <pastah_rhymez> ?
14:08:05 <pastah_rhymez> the array? the index?
14:08:06 <copumpkin> both            :: (a -> a) -> (a,a) -> (a,a)
14:08:07 <EvanCarroll> copumpkin: ?
14:08:14 <tensorpudding> hmm
14:08:16 <pastah_rhymez> copumpkin: no
14:08:16 <copumpkin> both            :: (a -> b) -> (a,a) -> (b,b)
14:08:18 <EvanCarroll> why not have and foldl, I'm confused?
14:08:21 <pastah_rhymez> oh, right
14:08:25 <tensorpudding> > False : repeat True
14:08:26 <lambdabot>   [False,True,True,True,True,True,True,True,True,True,True,True,True,True,Tru...
14:08:49 <tensorpudding> > foldr1 (&&) $ False : repeat True
14:08:49 <lambdabot>   False
14:08:51 <copumpkin> EvanCarroll: because it's begging for stack overflows and doesn't give you anything in return
14:09:00 <tensorpudding> ah, good
14:09:30 <tensorpudding> let's see how foldl does
14:09:39 <pastah_rhymez> tensorpudding: hehe, you go girl!
14:09:45 <EvanCarroll> doesn't foldl work in static memmory? and how does foldr work on infinite lists if && forces the evaluation of both sides?
14:09:50 <tensorpudding> > foldl1 (&&) $ False : repeat True
14:09:56 <copumpkin> EvanCarroll: it doesn't
14:09:58 <copumpkin> @src (&&)
14:10:00 <lambdabot>   mueval: ExitFailure 1
14:10:00 <lambdabot> True  && x = x
14:10:00 <lambdabot> False && _ = False
14:10:07 <tensorpudding> yeah, what i figured
14:10:14 <tensorpudding> that's one reason to use foldr instead of foldl
14:10:28 <copumpkin> foldr gives strictness control to the function
14:10:30 <copumpkin> foldl does not
14:10:35 <EvanCarroll> interesting, that's a wierd definition of &&
14:10:45 <copumpkin> EvanCarroll: why?
14:10:46 <tensorpudding> foldl' is nice if you can guarantee that the list is not infinite
14:10:51 <EvanCarroll> right, I thought && would force evaluation, and not work in static memory
14:11:01 <pastah_rhymez> EvanCarroll: && should be lazy
14:11:04 <copumpkin> tensorpudding: and you don't want to consume it lazily for other reasons
14:11:17 <tensorpudding> yes, that too
14:11:20 <ddarius> foldl' is nice if the argument function is strict in the accumulator, otherwise it is not.
14:11:20 <copumpkin> the result, that is
14:11:20 <pastah_rhymez> as it is in all languages i know of, anyway
14:11:30 <tensorpudding> if you want to apply the function right away
14:11:36 <MoALTz> those definitions seem funkier when you plug undefined into them - order dependant
14:11:50 <tensorpudding> there are good reasons to use foldl' and there are good reasons to use foldr
14:11:55 <pastah_rhymez> @src foldl'
14:11:55 <lambdabot> foldl' f a []     = a
14:11:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:12:01 <pastah_rhymez> @src foldr
14:12:02 <lambdabot> foldr f z []     = z
14:12:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:12:07 <kmc> static memory?
14:12:09 <ddarius> MoALTz: case (and thus pattern matching) has a specified order of evaluation.
14:12:27 <Jonno_FTW> is there good reasons to use foldl?
14:12:33 <Jonno_FTW> instead of foldl'??
14:12:48 <Axman6> not really
14:12:51 <tensorpudding> probably not
14:13:01 <Jonno_FTW> interesting
14:13:12 <tensorpudding> there is a way to define folding so that you can have strict right folds and lazy left folds
14:13:16 <ddarius> Never use foldl.
14:13:24 <Jonno_FTW> NEVER EVER?
14:13:38 <Jonno_FTW> @src product
14:13:38 <lambdabot> product = foldl (*) 1
14:13:42 <EvanCarroll> I thought foldl created a redex which allowed it to work in static memmory
14:13:43 <Jonno_FTW> scandolous
14:13:43 <copumpkin> @let foldl = error "use foldl', dumbass"
14:13:44 <Axman6> never ever ever
14:13:46 <lambdabot>  Defined.
14:13:59 <ddarius> Jonno_FTW: foldl is slightly more defined that foldl', but you have to be doing something crazy to actually care about it.
14:14:05 <Axman6> > foldl (+) 0 [1..10]
14:14:05 <xerox> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
14:14:07 <lambdabot>   Ambiguous occurrence `foldl'
14:14:07 <lambdabot>  It could refer to either `L.foldl', defined a...
14:14:07 <tensorpudding> > foldl (+) 0 [1..20]
14:14:08 <mtnviewmark> tensorpudding - not with lists, but I believe that Traversables have both kinds in both directions
14:14:08 <lambdabot>   Ambiguous occurrence `foldl'
14:14:08 <lambdabot>  It could refer to either `L.foldl', defined a...
14:14:09 <xerox> this page sums it up.
14:14:10 <Jonno_FTW> @faq should i use foldl?
14:14:10 <lambdabot> The answer is: Yes! Haskell can do that.
14:14:15 <copumpkin> @undef
14:14:17 <pastah_rhymez> http://foldr.com/
14:14:20 <tensorpudding> mtnviewmark: that is possible
14:14:23 <Jonno_FTW> foldl.com
14:14:26 <pastah_rhymez> haha
14:14:29 <tensorpudding> i might have been reading a paper on Traversables
14:14:33 <pastah_rhymez> foldl.com is overtaken :(
14:14:45 <ddarius> Jonno_FTW: That is the Report definition of product and foldl is in the Prelude.  I consider foldl being used in standard functions a mistake in the Report.
14:14:54 <mtnviewmark> too bad DNS won't allow   foldl'.com
14:15:02 <xerox> http://web.archive.org/web/20060327112912/http://foldl.com/
14:15:20 <tensorpudding> can't they revise the report?
14:15:52 <copumpkin> @let _ ? 0 = 0; x ? y = x * y
14:15:53 <lambdabot>  Defined.
14:16:00 <pastah_rhymez> xerox: thank you for satisfying all my intense clicking pleasures
14:16:10 <copumpkin> > foldl (?) 1 [2,3,undefined,5,0]
14:16:12 <lambdabot>   0
14:16:17 <copumpkin> > foldl' (?) 1 [2,3,undefined,5,0]
14:16:18 <lambdabot>   * Exception: Prelude.undefined
14:16:18 <xerox> pastah_rhymez: you're welcome
14:16:36 <EvanCarroll> does anyone have a doc pointer that talks about foldr, vs foldl, and why I should always use foldl
14:16:46 <EvanCarroll> err always use foldr
14:16:54 <tensorpudding> copumpkin: that example is pretty contrived
14:16:59 <copumpkin> you shouldn't always use foldr
14:17:04 <xerox> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'  EvanCarroll
14:17:06 <EvanCarroll> my understanding was foldl was more memmory efficent on finite lists because it worked in constant memmory
14:17:08 <copumpkin> but you almost never should use foldl
14:17:36 <Axman6> EvanCarroll: foldl' should, foldl will likely create thunks
14:17:47 <tensorpudding> foldl' is nice for not producing a ton of thunks
14:18:18 <tensorpudding> foldr is tail-recursive and can actually give meaningful answers for infinite lists
14:18:37 <EvanCarroll> are you sure?
14:18:47 <EvanCarroll> my understanding was that both ' versions were tail recursive
14:18:59 <EvanCarroll> then what does fold vs foldr' mean?
14:19:06 <Axman6> @src foldr
14:19:06 <lambdabot> foldr f z []     = z
14:19:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:19:08 <copumpkin> EvanCarroll: foldl is tail recursive if you ignore laziness
14:19:21 <EvanCarroll> copumpkin: I wish I understood that...
14:19:35 <copumpkin> tensorpudding: foldr isn't traditionally trail recursive at all
14:19:37 <Axman6> @src foldl
14:19:37 <lambdabot> foldl f z []     = z
14:19:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:19:48 * ddarius prefers his Stack overflow page: http://www.haskell.org/haskellwiki/Stack_overflow
14:19:53 <tensorpudding> i was told that foldr was tail-recursive
14:19:57 <Axman6> the last thing foldl calls is itself, making it tail recursive
14:19:58 <EvanCarroll> I've seen the definitions of of the fold[lr] code.
14:20:03 <EvanCarroll> I don't understand them
14:20:04 <ddarius> foldr is not tail recursive at all.
14:20:09 <Axman6> tensorpudding: i wouldn't say it is at all
14:20:27 <copumpkin> you can see foldl building up its accumulator
14:20:30 <xerox> ddarius: thanks
14:20:42 <EvanCarroll> Axman6: is that the only requirement for tail recursion in the language?
14:20:44 <copumpkin> EvanCarroll: unfortunately, it's building up a thunk for the accumulator, rather than the accumulator itself
14:20:51 <EvanCarroll> Axman6: the recursive call just has to be the last thing?
14:20:59 <copumpkin> EvanCarroll: basically, laziness blurs the meaning of tail recursion
14:21:01 <Axman6> EvanCarroll: i believe it's practically the definition of being tail recursive
14:21:02 <copumpkin> we don't talk about it in haskell much
14:21:45 <EvanCarroll> Axman6: no the definition of being tail recursive is not growing the stack during the recursive call, if it requires special syntax is language specific.
14:21:50 <copumpkin> no, it isn't
14:22:00 <EvanCarroll> that's always what I've heard...
14:22:01 <copumpkin> the tail in tail-recursive (or more generally talking about a tail call)
14:22:07 <copumpkin> means at the end of a function
14:22:23 <copumpkin> return 1 + function(); isn't a tail-call to function()
14:22:32 <copumpkin> return function(blah); is a tail-call to function()
14:22:38 <EvanCarroll> so, is a goto at the end of a function call, as in `goto: Fn;` tail recursive?
14:22:56 <copumpkin> it's not a call
14:23:52 <EvanCarroll> fair enoug
14:24:01 <copumpkin> so
14:24:02 <copumpkin> @src foldl
14:24:02 <lambdabot> foldl f z []     = z
14:24:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:24:14 <copumpkin> in the second case, it's making a tail call to foldl
14:24:18 <copumpkin> and passing it modified parameters
14:24:27 <copumpkin> however, because haskell is lazy, it isn't actually computing that f z x
14:24:34 <copumpkin> it's putting a thunk there and saying "I'll do that later"
14:24:40 <Axman6> * may not be
14:24:40 <copumpkin> so you get a huge tower of "I'll do that laters"
14:24:56 <copumpkin> foldl' rectifies that and tells it to do it now
14:25:00 <copumpkin> @src foldr
14:25:00 <lambdabot> foldr f z []     = z
14:25:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:25:12 <Jonno_FTW> how can i stop haskell printing out scientific notation on numbers?
14:25:14 <copumpkin> in the second case there, foldr isn't in a tail position
14:25:24 <copumpkin> so it's not a tail call to foldr
14:25:26 <Jonno_FTW> > (2^42) /2
14:25:28 <lambdabot>   2.199023255552e12
14:26:09 <dmwit> > 2^42 `div` 2
14:26:10 <lambdabot>   2199023255552
14:26:29 <ddarius> Jonno_FTW: Use a specific function and/or make a new type that has that specific function as its Show instance.
14:26:42 <Jonno_FTW> hmm
14:26:48 <EvanCarroll> copumpkin: so the answer then, is that while foldr can operate on infinite lists, and foldr' can avoid the growth through thunks, foldr isn't tail recrusive, only foldl is tail recursive - but it can't function on inf lists.
14:26:49 <Jonno_FTW> i have no experience in defining types
14:27:29 <copumpkin> EvanCarroll: basically :) and foldl is only useful if you have non-terminating _values_ in the list you're operating over and have a non-strict function that can deal with that
14:27:52 <EvanCarroll> do explain, non-terminating values?
14:27:53 <ddarius> copumpkin: And the list is short.
14:27:58 <EvanCarroll> non-inf lists?
14:28:02 <copumpkin> yeah :)
14:28:10 <dmwit> > undefined -- doesn't terminate
14:28:11 <lambdabot>   * Exception: Prelude.undefined
14:28:14 <Axman6> EvanCarroll: i don't believe there is a foldr' btw
14:28:18 <EvanCarroll> and why does foldl care about non-strict functions, foldl can't work on inf lists so why does the strictness matter?
14:28:20 <copumpkin> EvanCarroll: say you put [1,2,3, fix id, 5,6,7,8]
14:28:30 <dmwit> (Okay, technically it terminates.)
14:28:43 <copumpkin> EvanCarroll: the non-strictness on the first argument means it cares about the strictness of the values
14:28:50 <ddarius> dmwit: Not observably (from pure code.)
14:28:56 <dmwit> > foldl const 0 [1,2,3,undefined,4,5,6]
14:28:57 <lambdabot>   0
14:29:04 * copumpkin coughs something about spoon
14:29:13 * ddarius coughs something about -pure- code.
14:29:24 <copumpkin> EvanCarroll: talking about infinite lists is the strictness of the list itself
14:29:26 <copumpkin> :)
14:29:35 <dmwit> I would say there's a pretty significant difference between pure code and code with a pure type. =P
14:30:06 <ddarius> dmwit: There is a significant difference actually.
14:30:07 <copumpkin> nobody loves spoon :(
14:30:16 * Axman6 loves spoon
14:30:20 <copumpkin> aw
14:30:20 <ddarius> copumpkin: It's something only a mother could love.
14:30:28 <copumpkin> true that
14:30:37 <copumpkin> well somehow I got roconnor to argue for it on my behalf
14:30:41 <copumpkin> even though his initial reaction was disgust
14:30:44 <EvanCarroll> copumpkin: not sure I understand all that but I'll stare at it a bit
14:31:06 <EvanCarroll> you're operating over and have a non-strict function that can deal with that
14:31:17 <EvanCarroll> I still don't understand the non-strict function part
14:31:20 <pastah_rhymez> copumpkin: what's 'spoon'?
14:31:21 <copumpkin> EvanCarroll: well, say you pass a function f to foldr
14:31:28 <copumpkin> pastah_rhymez: a controversial package I released on hackage
14:31:30 <pastah_rhymez> copumpkin: the thing you and me did in bed last night?
14:31:31 <dmwit> ?hackage spoon
14:31:31 <ddarius> > foldl' const 0 [1,2,3,undefined,4,5,6]
14:31:31 <lambdabot> http://hackage.haskell.org/package/spoon
14:31:33 <lambdabot>   0
14:31:34 <copumpkin> lol
14:31:48 <ddarius> (well const is a bad choice...)
14:31:51 <pastah_rhymez> but is there a spoon?
14:32:08 <copumpkin> EvanCarroll: what does f get as parameters?
14:32:08 <EvanCarroll> @src sum
14:32:09 <lambdabot> sum = foldl (+) 0
14:32:12 <pastah_rhymez> oh, cool
14:32:23 <EvanCarroll> sum is foldl, its function (+) which is strict? right?
14:32:28 <pastah_rhymez> so i can use 'error' and let it become Maybe
14:32:30 <copumpkin> EvanCarroll: its first parameter is the current element in the list, and its second is the result of foldr on the rest of the list
14:32:34 <pastah_rhymez> that's pretty nice
14:32:38 <copumpkin> pastah_rhymez: don't!
14:32:44 <pastah_rhymez> copumpkin: DO
14:32:50 <pastah_rhymez> i hate error handling
14:32:53 <ddarius> EvanCarroll: Again, in my opinion, that is a bug in the Report.  If you use that definition in GHCi, it will stack overflow.
14:32:55 <copumpkin> pastah_rhymez: it's not for you to use error and avoid threading maybe through things :)
14:33:02 <dmwit> pastah_rhymez: Why would you use error instead of fail?
14:33:03 <ddarius> (on large enough input)
14:33:10 <copumpkin> pastah_rhymez: it's only for dealing with other people who wrote error instead of Maybe
14:33:24 <dmwit> pastah_rhymez: Or, better yet, plain old Nothing?
14:33:25 <pastah_rhymez> copumpkin: yeah, like me
14:33:38 <pastah_rhymez> writing Maybe all over the place usually brings my line width to > 72
14:33:38 <copumpkin> pastah_rhymez: there's a fairy long discussion on it here: http://www.reddit.com/r/haskell/comments/acasn/tired_of_functions_that_could_live_in_maybe_but/
14:33:56 <pastah_rhymez> so just saying "error" and failing miserably seems more like the way to go
14:34:02 <copumpkin> nooo
14:34:10 <pastah_rhymez> yeeeeeeeeeeees
14:34:10 <copumpkin> dcoutts will murder me if I let you do that
14:34:14 <pastah_rhymez> haha
14:34:17 <aeron> Is there a way to combine two parsers like concatenation of : (oneOf "abcd") ++ (oneOf "efgh") ?
14:34:19 * pastah_rhymez codes without a condom
14:34:34 <pastah_rhymez> she said she was on the pill...
14:34:35 <dmwit> > 'n' : repeat 'o'
14:34:36 <lambdabot>   "nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
14:34:38 <ddarius> error should be used for things that should "never happen" and if they do you have a program error.
14:34:41 <copumpkin> aeron: (++) `on` oneOf ?
14:34:47 <pastah_rhymez> dmwit: he
14:34:51 <aeron> copumpkin: i'll try that, thank you
14:34:54 <pastah_rhymez> dmwit: can't stop laughing
14:35:03 <dmwit> aeron: If you're using Parsec, maybe you want (>>) instead of (++).
14:35:06 <copumpkin> > cycle "ha"
14:35:06 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
14:35:09 * pastah_rhymez tries to settle down
14:35:27 <aeron> dmwit: oneOf "abcd" >> oneOf "123" ?
14:35:28 <EvanCarroll> =(
14:35:35 * EvanCarroll needs a real doc on folds
14:35:41 <dmwit> aeron: Yes... again, if you are using Parsec.
14:35:50 <pastah_rhymez> copumpkin: OR when i need to write an ad-hoc parser in two minutes and i don't have time to learn parsec
14:35:52 <dmwit> I am not familiar enough with the other parser libraries to give advice for them.
14:36:09 <pastah_rhymez> http://bitbucket.org/pastorn/illumidroid/src/tip/LevelParser.hs
14:36:12 <dmwit> ?wiki fold diagrams
14:36:12 <lambdabot> http://www.haskell.org/haskellwiki/fold_diagrams
14:36:20 <aeron> dmwit: yes, sorry, using parsec - just wanted to make sure I was understanding what you said correctly
14:36:22 <pastah_rhymez> that's my nasty parser i got working in ~30 seconds
14:36:39 <copumpkin> http://cale.yi.org/index.php/Fold_Diagrams
14:36:47 <Axman6> aeron: if you're interested, you might find this video quite helpful. it goes through implementing a monadic parser like Parsec
14:36:59 <ddarius> Folds are probably one of the most documented things in the Haskell (and greater functional) community...
14:37:03 <copumpkin> down with the monads!
14:37:09 <copumpkin> up with the lax monoidal functors!
14:37:17 <EvanCarroll> ddarius: no way.
14:37:21 <dmwit> EvanCarroll: foldr.com
14:37:25 <Axman6> aeron: http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-9-of-13/ (sorry for the delay, the page wasn't loading)
14:37:26 <pastah_rhymez> copumpkin: i'm only making small hobby projects, so having error handling is actually more of a non-issue for me
14:37:35 <pastah_rhymez> and besides, i don't like cluttering my type signatures
14:37:37 <copumpkin> pastah_rhymez: hrrmpf
14:37:37 <EvanCarroll> dmwit: stop trolling.
14:37:45 <copumpkin> o.O
14:37:52 <EvanCarroll> dmwit: that site has one line, and the foldl.com that keeps getting linked to is spam.
14:38:03 <copumpkin> EvanCarroll: it used to be the right thing
14:38:06 <copumpkin> EvanCarroll: and it isn't really spam
14:38:07 <dmwit> Yeah, foldl.com isn't in commission any more. =/
14:38:21 <copumpkin> EvanCarroll: the one line gives you the intuition of foldr though
14:38:30 <dmwit> And it's not just one line, it's one *amusing* line. ;-)
14:38:46 <dmwit> To make you smile when you're tired of tracking through the details and want a break. =)
14:39:06 <EvanCarroll> you find me one table talking about the qualities of redux, strict/lazy accumulators, constant memmory, infinite lists, and comprehensively how and when to use what folds, and I'll buy your its documented argument.
14:39:08 <copumpkin> EvanCarroll: so what specifically don't you understand about them?
14:39:26 <EvanCarroll> I don't understand that line i just quoted you on
14:39:33 <EvanCarroll> why does foldl care if its function is strict?
14:39:42 <copumpkin> oh, it doesn't explicitly
14:39:45 <EvanCarroll> if it doesn't work on infinite lists anyway, what is the benefit to a non-strict function
14:39:53 <copumpkin> haskell's evaluation model, coupled with the definition of foldl, makes it care
14:40:06 <copumpkin> EvanCarroll: because there are two parameters
14:40:17 <copumpkin> and strictness in one means one thing and strictness in the other means another
14:40:17 <ddarius> EvanCarroll: My Stack overflow page does all that and that Foldr,Foldl,Foldl' page does most of it.  Also, the executive summary is trivial if you know what strictness is.
14:41:21 <ddarius> However, "most documented" doesn't mean that what you want is documented, though in this case it is.
14:41:52 <ddarius> I could literally find hundreds of pages of text on just folds as fast as I could google them.
14:41:57 <copumpkin> EvanCarroll: the fundamental part is when you see foldl f z (x : xs) = foldl f (f z x) xs, and in particular that (f z x) bit
14:43:00 <ddarius> Indeed, the definitions of foldl, foldr, and foldl' plus the (basic) semantics of Haskell are enough to explain these issues.  They can all be calculated.
14:43:12 <copumpkin> EvanCarroll: it means that if f doesn't ever check its first argument, a bad z there (a non-terminating one) doesn't have to stop the entire expression
14:44:13 <dmwit> Oh, but it's better than that, right?
14:44:38 <dmwit> It means that if f only checks some parts of its first argument, z only has to be defined for those bits.
14:44:51 <copumpkin> yeah
14:44:56 <dmwit> I mean, if f only checks its second argument, you might as well write "f undefined . last" instead of using a fold.
14:45:09 <copumpkin> yeah
14:45:15 <ddarius> let f = (:)
14:45:53 <ddarius> (or flip (:) as the case may be)
14:46:21 <copumpkin> EvanCarroll: really, the best thing you can do if you still don't understand it is work through the evaluation of the three functions by hand
14:50:41 <Axman6> cd
14:50:46 <Axman6> whoops
14:51:30 <shachaf> rm -rf ~
14:51:32 <shachaf> whoops
14:52:03 <kmc> mplayer horse_porn.avi
14:52:05 <kmc> whoops
14:52:27 <Lemmih> kmc: DCC?
14:52:54 <ezyang> Whoo; I'll totally be in town for the Boston Haskell meeting
14:53:00 <copumpkin> ezyang: yay!
14:53:00 <ezyang> I'll be done with finals too.
14:54:21 <copumpkin> yay
14:56:09 <pastah_rhymez> someone told me today that the Facebook chat is in haskell
14:56:11 <pastah_rhymez> is this true?
14:56:25 <copumpkin> I thought it was erlang
14:56:39 <copumpkin> there are a few FPers at facebook and some of their tools are in haskell, but I don't think facebook chat is
14:56:41 <pastah_rhymez> i know that much of facebook is in erlang
14:59:19 <kmc> they have a PHP refactorizer that's written in Haskell
14:59:32 <pastah_rhymez> kmc: ehm... ok?
14:59:43 <pastah_rhymez> syntax tree modifyer for speed?
15:00:02 <kmc> don't know the details
15:00:14 <kmc> i think it's for permanent changes, not pre-computation or anything like that
15:01:11 <ddarius> @google lex-pass
15:01:12 <pastah_rhymez> yeah, guessed that :)
15:01:12 <lambdabot> http://github.com/facebook/lex-pass
15:01:12 <lambdabot> Title: facebook's lex-pass at master - GitHub
15:01:37 <copumpkin> oh, dancor is a facebooker?
15:01:55 <copumpkin> pity the package isn't up on hackage
15:02:06 <copumpkin> git clone + cabal install is so much more work than cabal install lex-pass
15:02:36 <ddarius> copumpkin: Now you won't be able to munge your PHP.
15:02:41 <copumpkin> yeah :(
15:02:58 <pastah_rhymez> i get sore eyes from clicking in the gitbub source
15:03:07 <pastah_rhymez> the contrast REALLY sucks ass
15:03:43 <xerox> actually much of fb seems to be in php, there's a conference in which one ceo says it's ~3M lines of php + some backend services not in php + mysql to save stuff (no joins) + memcached
15:05:31 <pastah_rhymez> xerox: when was this?
15:06:08 <xerox> pastah_rhymez: recently
15:07:06 <kmc> yes, the fb site is in php
15:08:32 <xerox> pastah_rhymez: http://idleprocess.wordpress.com/2009/11/24/presentation-summary-high-performance-at-massive-scale-lessons-learned-at-facebook/
15:09:35 <pastah_rhymez> xerox: thanks :)
15:10:09 <xerox> at a certain point he says that php was chosen because doesn't add complexity, then later he says they are developing a php-to-c++ compiler to handle complexity. eh eh.
15:10:40 <ddarius> Clearly C++ has negative complexity.
15:10:46 <Axman6> hmm, is there a built in function which will get all permutations of a list, not just the ones with the same length? (so, f [1,2,3] = [[],[1][2],[3],[1,2],[2,1],[1,3]...[3,2,1]]?
15:10:50 <tensorpudding> C++ has imaginary complexity
15:11:28 <copumpkin> Axman6: nope
15:11:43 <c_wraith> > map tails . permutation $ [1..3]
15:11:44 <lambdabot>   Not in scope: `permutation'
15:11:48 <c_wraith> > map tails . permutations $ [1..3]
15:11:49 <lambdabot>   [[[1,2,3],[2,3],[3],[]],[[2,1,3],[1,3],[3],[]],[[3,2,1],[2,1],[1],[]],[[2,3...
15:11:50 <xerox> there is subsequences though
15:11:58 <dibblego> > let powerset = filterM (const [True, False]) in powerset [1,2,3]
15:11:59 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:12:26 <xerox> > subsequences [1,2,3] >>= permutations
15:12:27 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
15:12:37 <c_wraith> ah, right.  dibblego's approach is the correct one.
15:12:47 <dibblego> >>= permutations or something
15:12:49 <c_wraith> err.  once you permute the results.
15:12:52 <c_wraith> yeah
15:12:54 <copumpkin> > nub . permutations <=< subsequences $ [1..3]
15:12:55 <lambdabot>   [[],[1],[2],[1,2],[2,1],[3],[1,3],[3,1],[2,3],[3,2],[1,2,3],[2,1,3],[3,2,1]...
15:13:05 <tensorpudding> is there a Set module?
15:13:09 <dibblego> Data.Set
15:13:10 <copumpkin> Data.Set ?
15:13:13 <tensorpudding> ah
15:13:22 <tensorpudding> @hoogle powerSet
15:13:22 <lambdabot> No results found
15:13:29 <tensorpudding> @hoogle powerset
15:13:29 <lambdabot> No results found
15:13:33 <tensorpudding> huh
15:13:45 <copumpkin> yeah, none of that
15:14:24 <tensorpudding> does Data.Set not have something that makes powersets?
15:14:32 <pastah_rhymez> tensorpudding: iirc Dat.Set only stores one element one time
15:14:35 <copumpkin> no powersets
15:14:54 <pastah_rhymez> so Set == NoDuplicatesBag
15:14:54 <tensorpudding> oh, so it's not actually like math sets
15:14:59 <pastah_rhymez> well
15:15:01 <pastah_rhymez> it is
15:15:21 <pastah_rhymez> in set theory if x <- S and y <- S and y==x then only x <- S
15:15:46 <pastah_rhymez> pSet :: Set a -> Set (Set a)
15:15:55 <pastah_rhymez> tensorpudding: :)
15:16:04 <tensorpudding> okay i guess
15:16:05 <copumpkin> if Set were pointed, I guess you could get a comonad out of that
15:16:18 <pastah_rhymez> copumpkin: pointed?
15:16:21 <copumpkin> but I guess it wouldn't really be powerset in that case
15:16:26 <copumpkin> pastah_rhymez: non-empty set, I guess
15:16:28 <pastah_rhymez> @hoogle [a] -> [[a]]
15:16:29 <lambdabot> Data.List inits :: [a] -> [[a]]
15:16:29 <lambdabot> Data.List permutations :: [a] -> [[a]]
15:16:29 <lambdabot> Data.List subsequences :: [a] -> [[a]]
15:16:29 <tensorpudding> ugh, relativity-breaking hangovers
15:16:49 <copumpkin> don't drink enough to get hangovers!
15:17:03 <tensorpudding> i had one drink
15:17:04 <ddarius> Actually, part of hangovers is dehydration...
15:17:11 <copumpkin> I meant alcohol :)
15:17:15 * pastah_rhymez has martini in his fridge
15:17:15 <tensorpudding> of alcohol
15:17:29 <tensorpudding> it was a jinn'tonic
15:17:35 <copumpkin> djinn?
15:17:38 <tensorpudding> no
15:17:39 <pastah_rhymez> 8 AM here... maybe a morning drink in order to get my hasklin' on
15:17:56 <Axman6> tensorpudding: jin? :\
15:18:23 <tensorpudding> man, the internet is so slow
15:18:37 <tensorpudding> jynnan tonix, that is what i wanted
15:18:40 <tensorpudding> i was way off
15:19:24 <c_wraith> hmm. I'm at a bar.  perhaps I should grab a jynnan tonix
15:20:48 <Axman6> can you guys just not spell? or is that soome silly brand name for a G&T?
15:21:07 <tensorpudding> it's a douglas adams reference
15:21:48 <c_wraith> Man.  kids these days.  Wait, axman, are you a kids these days?
15:22:01 <Axman6> not legally, no
15:22:15 <c_wraith> blast
15:22:38 <tensorpudding> kids today know about douglas adams
15:22:46 * Axman6 has spent the day drinking find wine and nice champagne
15:22:48 <tensorpudding> unfortunately they might only know the 2007 movie
15:23:01 <tensorpudding> or 2005, whenever it came out
15:23:08 <copumpkin> I think 2005
15:23:16 <Axman6> fine*
15:23:48 <newsham> kids know about douglas adams?
15:23:50 <newsham> are you sure?
15:24:06 <ddarius> newsham: Ask your kid.
15:27:22 <pastah_rhymez> if i have (Array Int (Array Int e)) (to be compared to [[e]]) and i do an updateto one element, what time complexity should i expect
15:27:36 <pastah_rhymez> (outer array 'm' long, inner are of same length; 'n')
15:27:37 <copumpkin> pastah_rhymez: are the inner arrays of different sizes?
15:27:44 <copumpkin> why not just have a 2d array then?
15:27:47 <pastah_rhymez> copumpkin: rectangular structure
15:27:48 <copumpkin> instead of an array of arrays?
15:28:02 <ddarius> pastah_rhymez: O(length of outer array + length of inner array)
15:28:12 <pastah_rhymez> copumpkin: Array (Int,Int) e?
15:28:17 <copumpkin> pastah_rhymez: yeah
15:28:26 <copumpkin> although if you want to update elements, my representation will be slower
15:28:33 <copumpkin> but in general
15:28:36 <ddarius> asymptotically
15:28:47 <copumpkin> you shouldn't be updating array elements unless you're in ST or you're bulk updating them
15:28:53 <pastah_rhymez> ddarius: yeah, becouse all elements that are not on the line will just be copied by reference, right?
15:29:14 <pastah_rhymez> *not on the line being modified*
15:29:16 <ddarius> pastah_rhymez: The pointer to the array that holds them will be the only thing copied, yes.
15:29:23 <pastah_rhymez> cool
15:29:30 <pastah_rhymez> copumpkin: i'm making a Grid library
15:29:52 <pastah_rhymez> and i want it to be able to hold many differenc kinds of representation, all generating different speeds
15:30:00 <pastah_rhymez> copumpkin: paste coming up :)
15:30:57 <ddarius> Technically, updating the list representation would be O(i+j) where you are updating the i,jth element, which, in the worst case, is O(m+n).
15:31:49 <c_wraith> What can you do in ST, anyway?  STRef, STArray(and friends)...  Is there anything else it provides?
15:32:04 <Axman6> that's about all you need really
15:32:18 <c_wraith> Yeah, that's plenty...  I was just wondering what all it supported
15:32:32 <Axman6> it provides a pure interfacer to imperative algorithms which have mutability
15:32:36 <pastah_rhymez> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14021#a14021
15:32:39 <pastah_rhymez> copumpkin: ^^
15:32:56 <Axman6> -r
15:33:01 <c_wraith> Is there an option to run ST not as IO?
15:33:07 <copumpkin> ?
15:33:08 <c_wraith> ...  I really should just look at the docs.
15:33:12 <ddarius> That's the whole point of ST.
15:33:17 <ddarius> :t runST
15:33:19 <lambdabot> forall a. (forall s. ST s a) -> a
15:33:20 <Axman6> yes, ST is pure, so you can run it anywhere
15:33:30 <copumpkin> c_wraith: that's the whole point of ST
15:33:45 <pastah_rhymez> do you have referential transparency in ST?
15:33:52 <c_wraith> Does it only use true mutability if run as IO?
15:33:54 <copumpkin> on the outside
15:34:04 <copumpkin> c_wraith: nope, it uses mutability all the time
15:34:11 <c_wraith> Ah, sweet.  Thanks.
15:34:16 <pastah_rhymez> copumpkin: what do you think of my interface?
15:34:18 <copumpkin> c_wraith: it uses a fancy rank-2 type to prevent you from noticing that from the outside
15:34:18 <Axman6> c_wraith: it always uses true mutability
15:34:54 <pastah_rhymez> oh, there will also be a function 'representation :: Grid a -> Representation' (thogh might be renamed to 'gridRep')
15:35:52 <copumpkin> pastah_rhymez: why provide the choice?
15:36:25 <pastah_rhymez> copumpkin: it depends on how update-intense you want to make it
15:36:40 <pastah_rhymez> if i'm using this for chess i would probably have it is an array
15:37:07 <pastah_rhymez> but there might be more update-intense tasks where MapRep might be more appropriate
15:37:13 <c_wraith> @hoogle STRef
15:37:14 <lambdabot> module Data.STRef
15:37:14 <lambdabot> Data.STRef data STRef s a
15:37:14 <lambdabot> Data.STRef.Lazy data STRef s a
15:37:19 <ddarius> Bitboards all the way.
15:37:39 <Axman6> :r
15:37:43 <Axman6> rarg, sorry
15:37:56 <pastah_rhymez> ddarius: what's that?
15:38:03 <ddarius> Oi.
15:38:12 <pastah_rhymez> eh?
15:38:18 <copumpkin> pastah_rhymez: I see :) looks good
15:38:55 <copumpkin> pastah_rhymez: you could actually parametrize the type by the representation :O
15:39:01 <copumpkin> with a GADT or something
15:39:10 <copumpkin> not sure why you'd want to
15:39:41 <pastah_rhymez> copumpkin: yeah, me and i friend talked about this but that'd just mess stuff up
15:39:51 <pastah_rhymez> KISS
15:40:08 <pastah_rhymez> if i had that it'd look like parsecs type signatures, something i do not approve of
15:40:16 <pastah_rhymez> Haskell98 is the way to go :)
15:40:37 <copumpkin> :)
15:40:39 <ddarius> Parsec 2 is Haskell 98 for the most part.
15:40:44 <copumpkin> I'm not a fan of haskell98
15:40:57 * pastah_rhymez is keepin it real
15:41:31 <pastah_rhymez> ddarius: what's a bitboard, you never replied :(
15:41:40 <ddarius> I believe the only thing Parsec 2 uses that is beyond Haskell 98 is the crazy hacked up "parameterized modules" for the Language module.
15:41:40 <pastah_rhymez> using Word8 as 'a'?
15:42:19 <kmc> what makes that not H98?
15:42:23 <ddarius> Parsec 3 has that and some multiparameter type classes (many of which are just support).
15:42:25 <kmc> it's a record of functions iirc
15:42:30 <ddarius> kmc: It uses rank-2 types.
15:42:36 <kmc> ah
15:42:39 <ddarius> (as commonly happens for first class module stuff)
15:42:43 <kmc> yeah
15:42:49 <kmc> rank-2 types are super useful
15:42:54 <ddarius> Indeed.
15:42:55 <kmc> i wish they were in H2010
15:43:04 <pastah_rhymez> copumpkin: you see that i have '(!!=) :: Grid a -> (Cursor, a) -> Grid a
15:43:08 <kmc> rank-N too but i guess the special case of 2 still has decidable inference?
15:43:14 <ddarius> kmc: No.
15:43:19 <pastah_rhymez> but for ':: Grid a -> [(Cursor, a)] -> Grid a'
15:43:23 <pastah_rhymez> what should it be called?
15:43:25 <kmc> what's the point of restricting to 2 then?
15:43:35 <kmc> i.e. why does GHC have -XRank2Types and -XRankNTypes
15:43:38 <ddarius> kmc: It was easier (?)
15:43:51 <copumpkin> I thought I read somewhere that rank2 was the only decidable higher-rank one
15:43:57 <copumpkin> but maybe it's just urban legend
15:44:02 <copumpkin> decidable inference, that is
15:44:09 <copumpkin> but I guess it doesn't even infer that
15:44:11 <copumpkin> so maybe not
15:44:28 <ddarius> Perhaps it's decidable but infeasible or inefficient in practice.  GHC doesn't infer rank-2 types.
15:45:24 <ski> pastah_rhymez : `foldl (!!=)' ?
15:45:50 <pastah_rhymez> ski: well, there needs to be a special implementation for the array representation
15:45:51 <ddarius> ski:  The bulk operation should definitely be separately implemented.
15:45:52 <Axman6> just finished watching http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Graham-Hutton-Functional-Programming-Fundamentals-Chapter-11-of-13/ and i've realised that the transformations Graham made were very similar to the sorts of things you do to optimise SQL expressions/relational algebra equations
15:45:57 <pastah_rhymez> @type (//)
15:45:58 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
15:46:03 <ddarius> If anything, the individual operation should be defined in terms of the bulk operation.
15:46:30 <ddarius> Axman6: Algebraic manipulations are algebraic manipulations...
15:46:33 <ski> is `Grid a' an array, here ?
15:46:44 <pastah_rhymez> though (!!=) will probably be implemented as 'g `????` [update]'
15:47:08 <pastah_rhymez> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14021#a14021
15:47:23 <pastah_rhymez> ski: as you can see there is an option for it
15:47:28 <ski> (ddarius : hm, i wonder if that could be related to the flattening transformation of Nepal ..)
15:48:10 * ski wishes hpaste would not add pointless anchors after main-pastes
15:48:24 * pastah_rhymez nods agreeingly
15:49:44 <kmc> how about a category of SQL then
15:50:17 <ddarius> There is a category of sets and relations that you should be able to encode "pure" SQL into.
15:50:24 <pastah_rhymez> ddarius: DAMN YOU!
15:50:28 <pastah_rhymez> what's a bitboard!?
15:50:34 <pastah_rhymez> you never answered :(
15:50:34 <ddarius> @google bitboard
15:50:35 <lambdabot> http://www.bitboard.com/
15:50:35 <lambdabot> Title: BitBoard Show Prep Networks
15:50:39 <ddarius> Not that.
15:50:45 <pastah_rhymez> good to know
15:50:48 <ddarius> pastah_rhymez: "Oi" was my reply.
15:51:00 <pastah_rhymez> does that even mean something?
15:51:16 <pastah_rhymez> that's what i say when i want the attention of someone whose name i do not know
15:51:23 <pastah_rhymez> that's about as far as i con interpret that
15:51:31 <ddarius> pastah_rhymez: It's more of an interjection than a semantically meaningful word, so no.
15:51:52 <ski> Axman6 : 404
15:52:00 <pastah_rhymez> ddarius: can't you just say what it is?
15:52:08 <Axman6> ski: shouldn't be
15:52:31 <ski> (literally "Page Not Found | Channel 9")
15:52:32 <ddarius> The "Oi" meant I didn't want to get into it.  If you don't already know, then you either don't need to know or you'll find out.
15:52:48 <Axman6> are you sure you got the whole URL? it works fine here
15:52:55 <ddarius> And you can certainly find it on google easily enough.
15:53:24 <ski> Axman6 : if it end with "11-of-13/", then yes
15:53:40 <Axman6> well, i tried it again, and it workd fine
15:53:51 * Axman6 will brb, maybe
15:54:05 * Axman6 -> Maybe BRB
15:54:33 <kmc> is there any document with collected wisdom about how to teach people Haskell?
15:54:51 <ddarius> kmc: There are some documents about teaching people Haskell.
15:55:14 <ddarius> I doubt there could exist a meaningful "collected wisdom"
15:55:47 <c_wraith> has any progress been made on renaming monad to "warm fuzzy thing"?
15:55:52 <ski> (well, it's also an allegory, as "Algebra of Programming" explains)
15:56:31 <kmc> a wiki is supposed to collect wisdom, sort of
15:56:35 <pastah_rhymez> kmc: i'd say that a good practice (that has worked for me) is to start with small examples and work your way to greater things
15:56:36 <kmc> do you know where i would find these documents?
15:56:45 <pastah_rhymez> like 'double :: Int -> Int'
15:57:00 <pastah_rhymez> 'triple :: Int -> Int'
15:57:08 <pastah_rhymez> 'sixTimes = double . triple'
15:57:10 <pastah_rhymez> etc.
15:57:23 <mtnviewmark> kmc - I'd look at bos' lecture slides
15:57:35 <pastah_rhymez> and then teaching about lists with basic recursion and hardcoding map's behaviour to later reach map
15:57:50 <mtnviewmark> http://www.slideshare.net/bos31337/presentations
15:58:05 <kmc> mtnviewmark, thanks
15:58:05 <mtnviewmark> lectures 1 - 7 are
15:58:28 <mtnviewmark> what he has currently taught at our little class at work he's leading
15:58:38 <ddarius> kmc: Here's one: http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
15:58:45 <kmc> mtnviewmark, where do you work, if you don't mind sharing?
15:58:51 <mtnviewmark> assumes that the students already know programming in a more "conventional" language
15:58:55 <mtnviewmark> Linden Lab
15:59:11 <pastah_rhymez> mtnviewmark: what do you produce?
15:59:19 <kmc> ddarius, thanks
15:59:20 <mtnviewmark> Second Life
15:59:26 <mtnviewmark> (the virtual world)
15:59:31 <copumpkin> mtnviewmark: doens't bos work there too?
15:59:36 <mtnviewmark> yup
15:59:36 <pastah_rhymez> oh, cool
15:59:49 <kmc> does Linden use Haskell in a significant capacity?
16:00:30 <ddarius> kmc: There's a talk somewhere about someone teaching Haskell to coworkers(?) in an organized way in an industrial context that had some interesting experience.
16:00:55 <ddarius> s/talk/blog post(?)
16:00:56 <mtnviewmark> No, we don't use Haskell at all
16:01:50 <mtnviewmark> At this point we have one master Haskell programmers (bos), one passable (myself), and about a half dozen learners
16:02:06 <mtnviewmark> not quite enough to start putting code into production! :-P
16:02:42 <copumpkin> :)
16:03:15 <kmc> i think 1.5 master Haskell programmers can write a lot of production-quality code per unit time
16:03:35 <pastah_rhymez> kmc: :)
16:03:38 <kmc> or you can do the architecture on a big project that the learners can start to contribute to as they come up to speed
16:03:48 <ddarius> But code is what matters ultimately, not code/day.
16:04:03 <kmc> thus motivating learning with a real-world example etc.
16:04:29 <kmc> ddarius, i don't agree.  it's important to get things done now rather than later
16:04:41 <ddarius> kmc: That's what -I'm- saying.
16:04:52 <copumpkin> need moar patience
16:04:59 <mtnviewmark> well, bos and I just might have some skunkworks projects up our sleeves...
16:05:01 <ddarius> 10 * 50LOC/day > 1 * 100LOC/day
16:05:06 <pastah_rhymez> ddarius: ok, wikipedia knew what a bitboard was :)
16:05:20 <kmc> oh. i thought by "code / day" you meant something different than "LoC / day"
16:05:23 <mtnviewmark> well, I don't like using LOC/day as a measure
16:05:32 <kmc> because LoC is a bogus measure, if it were accurate we should all be Java programmers
16:05:43 <ddarius> Call them "C++ equivalent LoCs"
16:05:44 <pastah_rhymez> there's a specialize-pragma that could be used for 'Grid Bool' here, right?
16:05:48 <kmc> you can write *so much* code without thinking at all!  it's great!
16:05:59 <copumpkin> Lines of Comments
16:06:02 <copumpkin> ;)
16:06:04 <copumpkin> best metric evar
16:06:28 <pastah_rhymez> kmc: i think IBM paid their programmers by LOC way too long
16:06:34 <kmc> wait they really did that?
16:06:36 <ddarius> kmc: "We" are mostly Java programmers and LoC is not a bad metric, it just isn't necessarily positively correlated.
16:06:37 <copumpkin> i++; /* take the value in i\n and add one to it\n placing the result back in i */
16:06:37 <mtnviewmark> I re-wrote a library we used extensively at work in Haskell -- I am also the author of the C++ version we use
16:06:47 <kmc> i thought every mention of payment by LoC was a joke
16:07:09 <kmc> copumpkin, i see you've TAed an intro CS class where students are told they need to write comments ;)
16:07:13 <mtnviewmark> The Haskell one is 1/5 the LOC of the C++ one
16:07:22 <copumpkin> kmc: indeed :)
16:08:04 <c_wraith> the nice thing about being paid for lines of code is that you can write tools to massively inflate your LoC. :)
16:08:19 <pastah_rhymez> mtnviewmark: nice! what does it do?
16:08:31 <ddarius> LoC/feature is a good metric (given some concrete way of quantifying "feature"), it's just negatively correlated to quality.
16:08:34 <mtnviewmark> Implements the LLSD data interchange system
16:08:44 <kmc> at one point i solved a problem someone posed here on irc, using haskell.  it took like an hour.  then i realized it was the same problem i'd spent 2 weeks on at work in C++
16:08:47 <kmc> that was depressing
16:08:55 <mtnviewmark> http://tools.ietf.org/html/draft-hamrick-llsd-00
16:09:04 <pastah_rhymez> mtnviewmark: "Little Lake School District"
16:09:06 <pastah_rhymez> ?
16:09:06 <kmc> it wasn't even the sort of thing *either* language is supposed to be good with
16:09:29 <copumpkin> kmc: what was it?
16:09:30 <kmc> i prefer D-LSD myself
16:09:41 <mtnviewmark> "Linden Lab Structured Data" -- but since it is now in an IETF working group -- it is just "LLSD"
16:11:05 <kmc> copumpkin, for R a record type, generate the function (Map String Dynamic) -> R which fills in the fields of R by indexing their names in the map, and casting to the appropriate type
16:11:28 <copumpkin> ah cute
16:11:35 <kmc> yeah it was the first time i used TH
16:12:05 <ddarius> kmc: Perhaps you should write your C++ in IRC.
16:12:11 <kmc> heh
16:12:22 <kmc> in C++ there is no introspection or decent metaprogramming, *and* the syntax is so godawful that you can't write external tools in a reasonable amount of time
16:12:49 <ddarius> @google fog c++ compiler
16:12:50 <lambdabot> http://www.agner.org/optimize/
16:12:50 <lambdabot> Title: Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X
16:13:08 <mtnviewmark> Hmmm... trait template objects ... that's how I'd solve that problem in C++
16:13:20 <ddarius> Curses
16:13:42 <kmc> there is a lot of boilerplate.  you can't just inspect the constructor signatures to get argument types and names
16:13:51 <ddarius> Freakin' Agner Fog.  'been a while since I've been to that site though...
16:14:33 <ddarius> http://www.computing.surrey.ac.uk/research/dsrg/fog/
16:15:22 <kmc> ddarius, very interesting
16:15:23 * kmc reads
16:24:15 <kmc> > otherwise
16:24:16 <lambdabot>   True
16:25:29 * hackagebot upload: PCLT-DB 0.1.1 - An addon to PCLT package: enchance PCLT catalog with PostgreSQL powers. (AndreySisoyev)
16:38:34 <kmc> @check \xs -> length (filterM (const [False ..]) xs) == (length xs ^ 2)
16:38:35 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
16:38:55 <kmc> durr
16:38:59 <kmc> @check \xs -> length (filterM (const [False ..]) xs) == (2 ^ length xs)
16:39:04 <lambdabot>   mueval-core: Time limit exceeded
16:39:07 <kmc> heh
16:44:13 <pastah_rhymez> i have a Map (Int,Int) a, how much of a performance gain should i expect if i switch to IntMap a (\(x,y) -> x*(maxValue y + 1) + y)
16:44:42 <pastah_rhymez> (all values for (Int,Int) are from (0,0) and up to a fixed value
17:06:41 <quicksilver> pastah_rhymez: none at all, if that's not your bottleneck.
17:06:51 <quicksilver> pastah_rhymez: as is always the case with optimisations.
17:07:29 <quicksilver> if it really is your bottleneck - if your program spends all it's CPU time looking up items in maps - then it's probably 3x to 5x faster, I guess
17:09:13 <pastah_rhymez> quicksilver: oh, that much? that's pretty awesome :)
17:29:07 <silverfin> hi folks.
17:29:30 <kmc> hi
17:29:35 <silverfin> what is "freshness condition" in lambda calculus?
17:29:53 <kmc> silverfin, as applied to a newly introduced variable?
17:30:22 <silverfin> I don't know. I was reading the wikipedia article on Untyped lambda calculus.
17:30:36 <silverfin> and it says this. # (λy.t)[x := r] = λy.(t[x := r]) if y is not in the free variables of r (a freshness condition).
17:31:01 <silverfin> I'm new to this stuff and I was ok up until then.
17:31:57 <kmc> the parenthetical statement does not modify the rule; they're just naming / describing it
17:32:35 <kmc> what they're getting at is that you want, syntactically, that each lambda-bound variable has a different name, so that variables don't get "captured" by substitution
17:33:48 <silverfin> There is no x inside the parenthesis. But there maybe inside t. is that it?
17:34:19 <kmc> that's a true statement, but i don't think it has to do with the condition about free variables
17:34:35 <kmc> do you know what is meant by the "free variables" of an expression?
17:35:40 <kmc> the notation a[x := b] is not part of the lambda-calculus; it's a notation we use to describe a transformation on terms of the lambda calculus
17:35:52 <silverfin> I think it means a variable that is not a parameter for the top level as well as appled lambdas inside it?
17:35:54 <kmc> it means "the expression a, where every free occurrence of x is replaced by b"
17:36:36 <silverfin> yup.
17:37:01 <ski> silverfin : consider `(\y.x (y x))[x := f y]'
17:37:18 <silverfin> ok
17:37:30 <copumpkin> any handy built-in function for selecting a subset of indices from a list?
17:37:37 <ski> the side condition there says that this does *not* simplify to `\y. f y (y (f y))'
17:38:03 <copumpkin> > select [1..10] [0,4,7] ===> 1, 5, 8
17:38:05 <lambdabot>   <no location info>: parse error on input `,'
17:38:09 <kmc> a free variable is a variable that's not "in scope"; it's a variable that's not bound by an enclosing lambda
17:38:27 <ski> you have to alpha-convert `\y. x (y x)' to e.g. `\z. x (z x)' first, so you get `\z. f y (z (f y))' as result
17:38:40 <kmc> so each variable is free by itself
17:38:41 <silverfin> kmc: ok
17:38:55 <kmc> the free variables of λx.t are the free variables of t, except x is not free
17:39:06 <kmc> and the free variables of (s t) are the union of the free variables of s and the free variables of t
17:39:28 <silverfin> ski: ok
17:39:38 <kmc> a wonderful thing about the lambda calculus is that there are only three syntactic cases, so you can give many properties by a simple recursive definition like that
17:39:58 <silverfin> I think I understand what a free variable is.
17:40:37 <silverfin> I get the general idea what a freshness condition is. But not quite well.
17:40:45 <copumpkin> I guess not
17:41:02 <kmc> i think it's not a great name
17:41:17 <silverfin> ski: what does "side condition" mean?
17:41:31 <kmc> the idea is that, since r came from outside (λy.t), if r happens to have a variable also named "y", it's not appropriate for that "y" to be bound by this lambda.  it should stay free
17:41:49 <ski> (here since `y' is free in the substitand `f y', you can't really rename that `y' without renaming wherever `y' is bound .. so the `y' in `\y. x (y x)' is renamed instead)
17:42:26 <ski> silverfin : basically an extra assumption of a rule. usually one which is not of the same form as the conclusion and "normal" assumptions
17:42:33 <pastah_rhymez> kmc: like this? (\y -> (\y -> (\x -> x + y + y) ) )
17:42:55 <kmc> pastah_rhymez, what part?
17:42:55 <pastah_rhymez> if applied to 1 2 3 that should yield 7, right?
17:43:02 <pastah_rhymez> unbound 'y'
17:43:07 <kmc> > (\y -> (\y -> (\x -> x + y + y) ) ) 1 2 3
17:43:08 <lambdabot>   7
17:43:11 <pastah_rhymez> yeah :)
17:43:14 <kmc> all those ys are bound
17:43:40 <silverfin> There's only three results for "substitand" via scroogle. So what does it mean?
17:43:47 <kmc> the thing which is substituted
17:43:55 <kmc> probably
17:43:56 <silverfin> cool
17:44:13 <ski> e.g.
17:44:16 <ski>     e0 => n0   e1 => n1
17:44:21 <ski>   + ------------------- n = n0 + n1
17:44:22 <ski>     e0 + e1 => n
17:44:45 <kmc> is that a sequent?
17:45:03 <ski> here the "judgements" used are of the form `e => v' for an expression `e' and a value `v'
17:45:45 <ski> and since the condition/assumption `n = n0 + n1' (semantic addition evaluation) is not of that form, it is commonly put "at the side"
17:46:06 <kmc> though not always
17:46:12 <ski> *nod*
17:46:26 <ski> kmc : `=>' here is the evaluation relation in a "big-step operational semantics"
17:46:37 <ski> (so, no, that's not a sequent)
17:46:39 <silverfin> ski: sorry if I can't follow along in your pace. I'll get here eventually.
17:46:49 <ski> silverfin : sure, np
17:47:16 <ski> (and the `+' to the left there was just intended as a name for the rule ..)
17:48:40 <ski> silverfin,kmc : sorry, yes, i made up "substitand" there on the spot, because it seemed appropriate to use :)
17:49:09 <kmc> oh, /me misunderstands what a sequent is
17:49:17 <ski> @google scroogle
17:49:19 <lambdabot> http://www.scroogle.org/
17:49:19 <lambdabot> Title: Scroogle
17:49:50 <pastah_rhymez> copumpkin: you here?
17:49:54 <copumpkin> yep
17:50:10 <pastah_rhymez> copumpkin: i'm refactoring my grid interface and it's going like shit
17:50:22 <pastah_rhymez> could you help?
17:52:03 <MoALTz> @pl (\x y -> uncurry (++) $ splitAt a y)
17:52:04 <lambdabot> const (uncurry (++) . splitAt a)
17:52:19 <silverfin> ski: np. it's a good word though.
17:52:28 <MoALTz> @pl (\x y -> uncurry (++) $ splitAt x y)
17:52:28 <lambdabot> (uncurry (++) .) . splitAt
17:52:44 <copumpkin> pastah_rhymez: trying to get some "real work" done now before I go to sleep :/
17:53:22 <ski> silverfin : maybe .. i'm getting unsure whether it ought to refer to `\y. y (x y)' or `f y' in `(\y. x (y x))[x := f y]'
17:53:28 <pastah_rhymez> copumpkin: heh, sorry :/
17:53:57 <silverfin> ski: so freshness condition is analogous to special forms of lisp?
17:54:05 <silverfin> or something like that.
17:54:14 <ski> silverfin : .. eh, huh !?
17:54:23 <silverfin> nevermind
17:54:33 <copumpkin> pastah_rhymez: I'll be more helpful tomorrow, sorry!
17:54:57 <ski> maybe you could say that in a very vague, distant way, side conditions is somewhat remniscent of special forms ..
17:55:03 <pastah_rhymez> copumpkin: it's cool
17:55:03 <kmc> silverfin, do you understand what the rule means, if you ignore the words "freshness condition"?
17:55:19 <ski> (namely in that they don't conform to the "standard" syntax)
17:55:37 <silverfin> yes.
17:55:42 <kmc> it's not like "freshness condition" is some precise term.  it's just a label that they're attaching to the rule they already gave, so they can refer to it later
17:56:52 <kmc> it's an example of a "side condition", in that you are giving a recursive set of rules for this substitution operation, but this rule has an extra thing that must hold, which isn't directly related to substitution
17:57:12 <kmc> (but is crucial for substitution to have the intended meaning)
17:57:18 <silverfin> I think I'm a bit confused about the difference between "side condition" and "freshness condition".
17:57:24 <silverfin> I'm sorry if I sound stupid.
17:57:33 <kmc> silverfin, this rule we're discussing is named "the freshness condition"
17:57:38 <kmc> or rather the side condition on the rule is
17:57:47 <silverfin> kmc: I do understand the rule.
17:58:17 <kmc> all of the other rules are of the form "some expression with substitions = some other expression with substitutions"
17:58:27 <silverfin> Since a variable is bound, when you introduce a rule, you rename the original variable to avoid clash.
17:58:30 <silverfin> Is that it?
17:58:30 <ski> the pattern in `augend + addend',`minuend - subtrahend',`multiplicand * multiplier',`dividend / divisor' appears to be that the right argument is the "actor", while the left one is the "actee"
17:58:54 <kmc> this one is of the form  "some expression with substitions = some other expression with substitutions, provided some extra property holds as well"
17:59:04 <ski> so maybe "substitand" would then mean "that which is to be substituted into" ?
17:59:15 <kmc> the bit "provided some extra property holds as well" is a "side condition"
17:59:47 <kmc> we have named this particular side condition "the freshness condition" for the purpose of talking about it later
17:59:47 <silverfin> kmc: I think I'm in the clear now.
17:59:50 <kmc> cool
17:59:55 <silverfin> ski: thanks man.
18:00:05 <silverfin> kmc: thanks.
18:00:09 <kmc> no problem :)
18:00:30 * ski wonders for what more thanks were required
18:01:12 <silverfin> :)
18:01:50 <EnglishGent> morning all :)
18:02:04 <shambler> hello
18:02:10 <EnglishGent> hi shambler :)
18:23:25 <silverfin> ski, kmc, when variable name clashes occur, how do we decide which set to rename?
18:27:11 <ski> silverfin : in `(\x. t)[x := r]', when `x' occurs free both `r', we rename `x' (and all free occurances of it in `t') to some fresh identifier (i.e. not occuring free in `r' and not being rebound around any of the occurances of `x' in `t') .. but don't rename anything in `r'
18:28:09 <ski> (the simplest way is to rename to some identifier which hasn't been used before at all)
18:30:05 <ski> (s/free both/free in/)
18:30:25 <silverfin> yup. i was wondering what you were trying to say.
18:30:47 <silverfin> i mostly suspect my incompetence.
18:31:28 <silverfin> :)
18:33:24 <kmc> this renaming business is the clunkiest part of the lambda calculus
18:33:36 <kmc> de bruijn indices avoid it to some degree
18:33:44 * ski sighs ..
18:34:37 <silverfin> Is it just me, or does everybody else stumble on *only* the clunkiest stuff..
18:34:48 <ski> silverfin : sorry, that `(\x. t)[x := r]' really should have been `(\x. t)[y := r]'
18:34:50 <silverfin> It not even that I'm any good.
18:35:03 * ski needs more tea
18:35:14 <ski> kmc : *nod*
18:35:46 <silverfin> ski: np. it all looks the same to me.
18:35:52 <silverfin> :)
18:39:07 <ski> silverfin : example of the qualifying parenthesis above :
18:39:51 <ski>   "not occuring free in `r'" : in `(\y. x (y x))[x := f y]' there is no point in renaming into `(\f. x (f x))[x := f y]', since `f' still occurs freely in `f y'
18:41:10 <ski>   "not being rebound around any of the occurances of `x' in `t'" : in `(\y. x (\z. y z x))[x := f y]' there is no sense in renaming into `(\z. x (\z. z z x))[x := f y]', since that renaming is wrong
18:41:38 <ski> .. so i suppose the latter remark there is just an instance of a condition on alpha-conversion/renaming
18:43:18 <silverfin> I get the idea. And I think that's what matters. The specifics are not that important I suppose. Because we don't have to manually do it in Haskell?
18:43:34 <silverfin> ski: ^^
18:44:29 <ski> yes, Haskell "keps track" of which variable is bound where, when it is "substituting"
18:45:11 <ski> (but you may have to do this manually, if you're implementing a simple lambda-calculus (or any language with local binding, i suppose) *in* Haskell)
18:46:05 <silverfin> That would be a sweet day.
18:47:43 <ski> (why sweet ?)
18:48:03 <ski> (you can start today, if you want to make today sweet :)
18:49:15 <silverfin> It's plenty sweet everyday.
18:49:32 <silverfin> For like now. I did really scale that wall.
18:50:23 <silverfin> But you kind words are like the monsoon.
18:50:30 <silverfin> your*
18:50:33 <silverfin> thanks.
18:55:49 <ski> (silverfin : you're wanting to try out rockface climbing ?)
18:57:13 <silverfin> Am I?
19:04:17 <ski> silverfin : "I did really scale that wall."
19:05:04 * ski should probably keep quiet instead of guessing that much at what people meant
19:05:22 <silverfin> Same here.
19:05:32 * ski grins
19:06:04 <silverfin> Did you get that tea of yours?
19:09:08 <ski> yes
19:09:53 <ski> (though i'm having high latency atm, due to a concurrent conversation)
19:14:36 <silverfin> I'm sure people don't take too kindly to inane banter in the official Haskell channel. I think I should head back to wikipedia.
19:14:52 <medfly> oh?
19:15:04 <silverfin> :)
19:15:27 <silverfin> :-D
19:15:50 <medfly> I don't think people mind so much.
19:15:57 <silverfin> awesome.
19:16:58 <silverfin> America is mostly asleep. So I guess it quiet here than the usual?
19:17:56 <medfly> I dunno.
19:19:11 <Niccus> yeah usually the channel's a lot more talkative
19:20:07 <MoALTz> yeah. it does seem unusually quiet tonight/today.
19:20:20 <silverfin> Cool. Maybe I should stick around. It seems fun.
19:21:12 <ski> by all means stick around :)
19:21:19 <silverfin> :)
19:30:39 <mreh> the interpretation of bind for IO monad is something along the lines of, perform this IO action take the result and plug it into this function
19:30:46 <mreh> is that correct?
19:31:23 <mreh> there's no implementation I can actually see is there?
19:31:44 <Saizan> there is, but it's not really in haskell
19:32:21 <mreh> I've realised that I've only ever had an intuition about IO monad up until now
19:32:24 <Saizan> bind is more about making a new IO action that will do that when performed/executed, anyhow
19:33:01 <pastah_rhymez> mreh: that's actually always the implementation of >>=
19:33:22 <Saizan> yeah, if you overload "perform"
19:33:32 <Saizan> since what it means depend on the monad in question
19:34:09 <Saizan> though you also have to overload "plug", e.g. the list monad uses the function multiple times
19:34:13 <mreh> the list monad concat maps the function to the first argument, that doesn't quite seem consistant, unless you overload perform, yes
19:34:25 <mreh> great minds think alike
19:35:11 <ski> thinking on the list monad in terms of side-effects is fun
19:35:24 <mreh> how so?
19:36:21 <ski> "first nondeterministically select a number `x' between `0' and `9', then nondeterministically select a number between `0' and `x', then check that `x * y' is less that `50', finally return `(x,y)'"
19:36:25 <ski> that would be
19:36:32 <mreh> that's backtracking
19:36:37 <ski>   do x <- [0..9]
19:36:43 <ski>      y <- [0,x]
19:36:53 <ski>      guard (x * y < 50)
19:36:56 <ski>      return (x,y)
19:36:57 <ski> yes
19:37:18 <mreh> it's no not deterministic, it computes every solution
19:37:34 <ski> it is "all-solutions"-deterministic
19:37:40 <ski> there are two flavours of nondeterminism
19:37:58 <ski>   angelic / all-solutions nondeterminism
19:38:00 <ski> vs.
19:38:07 <mreh> true, i've done N-D turing machines, the only way is to keep a set of states
19:38:08 <ski>   demonic / commited-choice nondeterminism
19:38:19 <ski> this is an instance of the former
19:38:26 <ski> (just as Prolog is)
19:38:44 <ski> (s/commited/committed/)
19:39:23 <mreh> as in committed to an institution for doing it the crazy way
19:39:25 <ski> the point above being that you can "imagine" that each "<-"-step there is of the demonic flavour, thus execution only flowing forward
19:39:56 <ski> thus reading `y <- [0..x]' as "nondeterministically select a number `y' between `0' and `x'"
19:40:11 <ski> (or "just choose any damn number in that interval !")
19:40:14 <ski> mreh :)
19:40:39 <mreh> i can't imagine pure non-determinism, i find it too hard
19:40:50 <ski> which kind ?
19:40:54 <mreh> demonic
19:40:59 <pastah_rhymez> what's the intuition for 'Ord (Int,Int)'?
19:41:18 <ski> pastah_rhymez : lexical ordering
19:41:26 <pastah_rhymez> ok...?
19:41:32 * pastah_rhymez don't know what that is
19:41:48 <ski> pastah_rhymez : first compare the `fst' parts of the pairs .. only if they are equal, compare the `snd' parts to disambiguate
19:42:26 <ski> > sort [('b','a'),('a','b'),('b','b'),('a','a')]
19:42:27 <lambdabot>   [('a','a'),('a','b'),('b','a'),('b','b')]
19:42:34 <pastah_rhymez> ok, but if i use (Int,Int) to represent coordinates, then does it make more sense to have (x,y) than (y,x)?
19:43:10 <ski> pastah_rhymez : lexical as in an index, think of a value in `(Int,Int)' as a "word" whose first letter is the `fst' `Int' and whose second letter is the `snd' `Int'
19:43:27 <pastah_rhymez> oh, ok
19:43:33 <pastah_rhymez> that kinda makes sense :)
19:43:35 <ski> pastah_rhymez : depends on whether you want to order "row-major" or "column-major" :)
19:43:39 <Jonno_FTW> @src sort
19:43:39 <lambdabot> sort = sortBy compare
19:43:49 <Jonno_FTW> @src sortBy
19:43:50 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
19:44:02 <pastah_rhymez> so for (Int,Int) i should think of it as perhaps two Int32 concatenated to an Int64?
19:44:06 <pastah_rhymez> s/Int/Word/
19:44:09 <Jonno_FTW> @src insertBu
19:44:09 <lambdabot> Source not found. That's something I cannot allow to happen.
19:44:11 <Jonno_FTW> @src insertBy
19:44:11 <lambdabot> insertBy _   x [] = [x]
19:44:11 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
19:44:11 <lambdabot>                                  GT -> y : insertBy cmp x ys'
19:44:11 <lambdabot>                                  _  -> x : ys
19:44:35 <ski> mreh : demonic nondeterminism is what arises when concurrent processes compete (have a race condition) for what answer to compute
19:44:39 <mreh> why do my random numbers suddenly become very deterministic in my haskell programs? is it graph reduction that is causing this?
19:44:49 <mreh> ski: right
19:45:02 <pastah_rhymez> ski: the thing here is that to enter and exit my structure it's row-major, but once inside in seems to make more sense to be column-major :/
19:45:10 <pastah_rhymez> perhaps a transpose is in order?
19:45:40 <ski> (it also arises in some other circumstances .. like modifying representations in-place to an equivalent one, and then observing the representation .. as well as "true" random bits)
19:46:09 <ski> mreh : haskell evaluation is deterministic
19:46:23 <ski> mreh : if you want different' random numbers, start with a different seed
19:46:54 <mreh> ski: passing the same random number generator to two different functions causes the same evaluation of the random numbers
19:46:59 <ski> yes
19:47:10 <ski> "so don't do that", if you don't want that :)
19:47:17 <Powerfool> What could be wrong if I get linker errors when compiling with ghc (6.10.4 on Ubuntu)? Something like: "(.text+0xb2): undefined reference to `mtlzm1zi1zi0zi2_ControlziMonadziStateziLazzy_zdf14_closure'".
19:47:18 <mreh> do I need to fork the generator first?
19:47:40 <ski> either that, or sequence by letting one of them return a "final" generator
19:47:54 <mreh> what I imagine is a sort of graph reduction thing going on
19:47:54 <Powerfool> The stuff runs fine in ghci.
19:48:10 <ski> @type System.Random.getStdGen
19:48:10 <mreh> so if I'm generating random numbers with state monad I need use a monad transformer
19:48:10 <ski> @type System.Random.newStdGen
19:48:11 <lambdabot> IO StdGen
19:48:11 <lambdabot> IO StdGen
19:48:17 <ski> @type System.Random.split
19:48:19 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
19:48:42 <ski> `newStdGen' uses `split' on the global `StdGen' in `IO'
19:49:25 <ski> pastah_rhymez : i'm not quite sure what your application is ..
19:49:44 <pastah_rhymez> ski: you got google wave?
19:50:08 <pastah_rhymez> well, it's here as well: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14022#a14024
19:50:16 <pastah_rhymez> no ability to make cool comments, though
19:50:35 * ski does not wave
19:50:36 <Jonno_FTW> i haven't got into google wave
19:50:43 <Jonno_FTW> i have an account
19:50:47 <Jonno_FTW> i just don't know what to do with it
19:51:01 <HugoDaniel> :)
19:51:02 <ski> can one use it from a text terminal ?
19:51:17 <pastah_rhymez> ski: not exactly
19:51:23 <mreh> ski: dont you use any GUI?
19:51:24 <pastah_rhymez> thogh that depends on how good lynx is
19:51:34 <ski> mreh : i do, but i try to minimize it ..
19:51:51 <Jonno_FTW> i don't reckon a text based browser could handle all the ajax
19:51:52 <erik__> ski: i didn't follow the angelic/demonic distinction -- with no side-effects, what distinction is there between backtracking vs. forward only?  the order of options tried is deterministic, right?  so i can "side-channel attack" the algorithm (indirectly observe the backtracking) by seeing that it takes longer to find a solution than if it had magically tried the correct solution first, right?
19:52:15 <pastah_rhymez> ski: for many of the features you probably need graphics
19:52:29 <pastah_rhymez> text-only is possible too, i guess
19:52:31 <mreh> erik__ we could set multiple threads all going at their own solution
19:52:41 <mreh> that's the difference
19:54:05 <erik__> mreh: demonic would have to try solutions serially?
19:54:55 <mreh> erik__, nope, that's angelic, demonic has several threads each trying their own, the first to come back are the first to try their solutions
19:55:49 <Jonno_FTW> is it possible to run haskell parralleled on a GPU?
19:56:21 <mreh> I'm not even sure if haskell is multi threaded
19:56:33 <mreh> s/haskell/GHC
19:56:37 <Jonno_FTW> Control.Parallel?
19:56:47 <opqdonut> yeah it supports multiple os threads
19:56:50 <Jonno_FTW> i'm pretty sure it can be done
19:57:00 <Jonno_FTW> but on a gpu
19:57:00 <opqdonut> which can either contain dedicated haskell threads
19:57:14 <opqdonut> or ghc can automatically load-balance
19:57:23 <ski> aside :
19:57:32 <opqdonut> Jonno_FTW: GPUs aren't general-purpose computers
19:57:39 <mreh> lol
19:57:45 <ski>   the angelic nondeterminism corresponds to what is called the Hoare powerdomain preorder, while
19:57:45 <Jonno_FTW> >:3
19:57:47 <mreh> that's what GP stands for
19:57:51 <opqdonut> i don't think you could run haskell effectively
19:58:01 <Jonno_FTW> i meant a graphical processing unit
19:58:03 <ski>   the demonic nondeterminism corresponds to what is called the Smyth powerdomain preorder
19:58:11 <opqdonut> but there is a haskell dsl for compiling shaders
19:58:12 <mreh> Jonno_FTW, I know :)
19:58:17 <opqdonut> or somethin like that
19:58:30 <ski> (if you combine both Hoare and Smyth, you get what is called the Egli-Milner preorder on a powerdomain)
19:58:38 <erik__> mreh: what is the relation to this and what ski said about forward-only?  seems i can still determine that we didn't magically guess the right answer by observing cpu usage, thread counts, etc
19:58:43 <mreh> ski: thanks for that, now where on earth did you read this
19:58:45 <opqdonut> so effectively running part of your program on the gpu
19:59:00 <HugoDaniel> i like the Gpipe project for computation on the gpu
19:59:13 <HugoDaniel> the only thing there is that it uses glut
19:59:14 <ski> the point being that in the Hoare preorder, you get a better approximation of a subset by *adding* elements to it
19:59:19 <HugoDaniel> and glut pretty much sucks it :/
19:59:30 <ski> while in the Smyth preorder, you get a better approximation of a subset by *removing* elements from it
19:59:45 <ski> (also, you can always replace individual elements by better approximations of them)
20:00:32 <ski> so the Hoare preorder corresponds to the case where you'd like as many solutions as possible, the more the better .. a.k.a. angelic non-determinism
20:01:27 <ski> while the Smyth preorder corresponds to the case where you'd like as few solutions as possible (i.e some "solutions" may later be determined to actually be falso solutions), the fewere the better .. a.k.a. demonic nondeterminism
20:02:17 <ski> mreh : i read it in "Topology Via Logic" by Steven Vickers .. (but atm i had to look up which of the preorders was which, since i don't have that book available here for the moment)
20:03:17 <ski> erik__ : to clarify : demonic / committed-choice non-determinism is when you're interested in getting *any* of potentially several solutions .. as soon as you find one, you don't need to look for any more, because any one is as good as any one else
20:04:15 <ski> erik__: while in the angelic / all-solutions non-determinism case, you're interested in getting all possible solutions to a problem, so you need backtracking or computing solutions concurrently to keep searching even after you've found one solution
20:04:26 <mreh> you can simulate that with lazy evaluation though
20:04:34 <ski> erik__ : have you done any Prolog ?
20:04:41 <ski> (mreh : "that" being ?)
20:04:55 <mreh> stopping when you've found one solution
20:05:28 <erik__> ski: how does this relate to what you said about "forward only"?   so far it sounds like the example you gave would commit to the first choice that passed the guard.  yeah actually i love prolog (mainly cuz of multi-modality, tho, which i wish other languages would adopt).
20:05:48 <opqdonut> multimodality?
20:06:23 <opqdonut> (and even if you're simulating forward-only with laziness you pay the accounting overhead)
20:06:27 <erik__> opqdonut: arguments are typically both input and output, depending on whichever you specify
20:06:33 <opqdonut> yeh
20:06:38 * ski doesn't recall saying anything about "forward only" ..
20:07:24 <erik__> ski: "thus execution only flowing forward"
20:07:30 <ski> mreh : yes .. so you don't have to decide before-hand whether you want one, all, or just some :)
20:08:02 <ski> (of course, if you only want at most one, it's more efficient to not keep any "choice-points" that could be used to find more solutions)
20:09:42 <ski> oh
20:09:44 <ski> <ski> the point above being that you can "imagine" that each "<-"-step there is of the demonic flavour, thus execution only flowing forward
20:11:41 <ski> erik__ : well, i just meant that you can think of that list-monad code "as if" it would just commit to any selection (i.e. demonic nondeterminism), and then it reads like a sequential imperative program which asks an oracle now and then which element to choose when there is a choice (this being the side-effect)
20:12:12 <gio123> ski: lo
20:12:13 <erik__> ski: hm i'm not getting it.  if each <- is committed, what happens when the guard fails?  obviously it backtracks.  the distinction you're drawing seems to be equivalent to having a red cut after the guard succeeds.
20:12:14 <ski> i.e. you can ignore thinking about the operational aspects of backtracking or what-have-you, in your angelic nondeterminism monad (here `[]')
20:12:15 <gio123> :)
20:14:15 <erik__> ski: maybe it would help if i could think of an example where i could not ignore the backtracking -- in real applications, one has to keep the backtracking in mind to make the oracle work in reasonable time.  :)
20:14:56 <ski> erik__ : well, just imagine that the `<-' always magically manages to choose the "right" choice (if any), such that succedent `guard' (or equivalent) calls succeeds :)
20:15:27 <ski> (in some sense, that is the difference between the angelic and demonic variants)
20:15:53 <erik__> ski: but if i don't prune and order my lists as well as possible, the oracle will often take too long, right?  i don't get why i would be able to ignore that detail.
20:16:49 * erik__ has never seen the word succedent before, cool
20:17:04 <ski> it's just a trick to ignore thinking about the actual backtracking (or concurrent breadth-first execution) underneath
20:17:08 <ski> nothing more
20:17:43 <ski> obviously as you say, you need to take it into account on some level, to get reasonable efficiency, in some cases
20:18:02 <stoop> dcoutts = duncan on the GHC WiKi?
20:18:07 <erik__> ski: what would be an example where i could not ignore that?
20:18:57 <ski> "in real applications, one has to keep the backtracking in mind to make the oracle work in reasonable time.  :)"
20:19:03 <ski> "but if i don't prune and order my lists as well as possible, the oracle will often take too long, right?"
20:19:26 <erik__> ski: i must be being dense, but i thought that's the stuff you just agreed we actually do have to keep in mind.
20:19:40 <ski> i guess my point, wrt this, would be that you can use this view when thinking about the code at a high-level of abstraction
20:20:08 <ski> then you will need to think more about the operational semantics, to improve potential inefficiencies
20:20:21 <shambler> HugoDaniel, CUDA allows GPU computations for example, it's C(-extension) so we can probably use it with FFI... but I'm not sure about technical details, anyway it's not just a C library
20:20:48 <ski> erik__ : i'm saying you can ignore it on a "high level of abstraction"
20:21:15 <erik__> ski: i thought by talking about "non-determinism" we were saying "we don't explicitly manage the backtracking" -- but i'm not getting how there could be two flavors of that.  i do understand parallel/serial and breadth/depth.  but i don't see how these would relate to "forward only" vs. something else, or "can ignore" vs. something else.
20:21:38 <ski> often when writing code (or modifying it), we first code an "obviously correct" definition, and then refine it to be more efficient
20:21:55 <shambler> HugoDaniel, http://imonad.com/blog/2009/09/commercial-users-of-functional-programming-videos/ there is a video called  "Running Haskell Array Computations on a GPU"
20:22:02 <HugoDaniel> shambler: it only works on nvidia :P
20:22:02 <Axman6> shambler: i'd rather see OpenCL used ahead of CUDA. mainly because a) it's a standard language, and b) it's going to be supported by everyone, on all platforms
20:22:05 <ski> this trick would just be one to help with the former part
20:22:05 <erik__> ski: i also see "stop looking as soon as you find one solution" vs. "find all the solutions" -- but one can do either in both [] and prolog, right?
20:22:32 <HugoDaniel> yes, there is also a binding to the openCL api
20:22:57 <Axman6> HugoDaniel: the OpenCLRaw one? it's a very thin binding
20:23:05 <Axman6> i should play with it though
20:24:15 <ukl> hello.
20:24:19 <ski> erik__ : yes .. but "find one solutions" but `once(relate(Input,Output))' may be wasteful
20:24:19 <shambler> hi
20:24:21 <Axman6> g'day
20:24:41 <ski> erik__ : have you seen the committed-choice determinisms (`cc_multi',`cc_nondet') in Mercury ?
20:24:49 <erik__> ski: ok, i thought you meant that "this trick" (meaning "not explicitly managing the backtracking") was angelic-specific, and that there is some other similar abstraction ("demonic") where we *would* have to somehow get explicitly involved in the backtracking or something.
20:25:45 <erik__> ski: haven't looked at mercury -- your description sounds just like a red cut in prolog tho
20:26:18 <ski> the "trick" was just a casual way of reading the angelic nondeterminism as if it were demonic, but always chooses a right solution (wrt later goals called)
20:27:00 <gio123> ski: lo :)
20:27:39 <ski> erik__ : the multi-modality of Prolog is one of the coolest parts of it. in some senses, Mercury manages better multi-modality than Prolog, though
20:28:03 <ski> erik__ : in Prolog, that would be a red cut, yes. in Mercury, it would be green :)
20:28:21 <erik__> ski: don't mean to try your patience, but i'm still not getting the angelic/demonic distinction.  the best i can manage is one or more of breadth vs. depth first, serial vs. parallel, or with vs. without a red cut afterwards.
20:28:30 <ski> (where "it" refers to committed-choice non-determinism, not to "this trick")
20:29:24 <ski> erik__ : in Prolog, append/3 has common modes (+,+,-),(+,-,+),(-,-,+)
20:29:34 <ski> erik__ : in Mercury, those are declared as
20:29:43 <ski>   :- mode append(in,in,out) is det.
20:29:49 <ski>   :- mode append(in,out,in) is semidet.
20:29:56 <ski>   :- mode append(out,out,in) is multi.
20:30:10 <det> Sir, I insist you retract that comment.
20:30:47 <ski> (where `det' means that the predicate called in this mode has exactly one solution (modulo non-termination), `semidet' means it has at most one solution, and `multi' means it has at least one solution)
20:31:00 <erik__> ski: i've used det/multi in swipl's documentation mechanism before, i agree it would be great to formally include them in the semantics
20:31:01 * ski turns det into nondet :)
20:31:39 <ski> (`nondet' means that there could be any number of solutions)
20:31:50 <erik__> ski: but i'm nervous about just asserting them (as it seems you're saying one does in mercury) -- i would want the interpreter to verify my assertion wasn't wrong :)
20:31:55 <ski> erik__ : now, there's also determinisms `cc_multi' and `cc_nondet' in Mercury (`cc' standing for "committed-choice")
20:32:19 <ski> erik__ : well, Mercury verifies the mode declarations for you (statically) :)
20:32:34 <det> You guys are jerks, I think I'm gonna join all the channels ski is in and have conversations about my recent ski trip
20:32:38 <det> where I went skiing
20:33:01 <ski> det : people often talk about the "ski combinators" here, if that's any consolation
20:33:29 <ski> det : if you prefer, i can spell "det", "deterministic" here, just for your sake :)
20:33:32 <erik__> ski: is that always decidable ahead of time?  can it infer them for me then?
20:33:40 <det> ski, I hope you let them know the i is redundant
20:33:56 <ski> (det : i usually don't comment :)
20:34:23 <ski> (also, i've myself to blame, since `ski' refers to said combinators :)
20:35:14 <ski> erik__ : if the mode system can't verify the mode declarations, it aborts the compilation. iirc, one can infer modes in some cases at least, but i'm not sure to what degree it is supported
20:35:37 <det00192> good night :-)
20:35:45 <ski> the same to you, sire
20:36:23 <ski> .. where was i ?
20:36:34 <ski> oh, right
20:37:59 <ski> `cc_multi' basically means "the predicate called in this mode has at least one solution, but i will only bother to find one of them for you"
20:38:01 <erik__> any idea why multimodality hasn't had a wider impact on languages?  i hate rerepresenting the same facts in definitions of functions and their inverses.  i guess multimodality sort of implies that each of your variables becomes a set of possibilities, and some sort of backtracking for finding consistent ones.
20:38:32 <ski> `cc_nondet' basically means "the predicate called in this mode may have any number of solutions, but i will only bother to find one of them for you, iff it exists"
20:39:16 <ski> erik__ : it would be nice with a functional language that supported bijections natively, yes
20:39:25 <ski> now, recall findall/3 from Prolog
20:39:29 <mreh> is anyone familiar with HGL blocking on maybeGetWindowEvent?
20:39:34 <erik__> ski: it's hard for me to believe that it is practical to require that these things be statically verifiable
20:39:52 <mreh> that's kind of contrary to what the function name describes
20:41:03 <mreh> Graphics.HGL.Window.maybeGetWindowEvent
20:42:12 <ski> findall/3 has a few variants in Mercury, seen at <http://www.mercury.csse.unimelb.edu.au/information/doc-release/mercury_library/solutions.html#solutions>
20:42:17 <ski> one is
20:42:18 <erik__> ski: not just bijections, right?  if f(1) = 2 and f(2) = 2, i'd like to automatically have finv(2) = possibility-list([1,2]) -- but i see that this basically requires that you are built around backtracking
20:42:40 <ski>   :- pred solutions(pred(T), list(T)).
20:42:43 <ski>   :- mode solutions(pred(out) is nondet, out) is det.
20:42:51 <ski> which always sorts the solutions list
20:43:07 <ski>   :- pred solutions_set(pred(T), set(T)).
20:43:14 <ski>   :- mode solutions_set(pred(out) is nondet, out) is det.
20:43:22 <ski> which returns a set (internally unsorted)
20:43:34 <ski> but here relevant is
20:43:40 <erik__> ski: are these richer in some way than bag_of and friends?
20:43:45 <ski>   :- pred unsorted_solutions(pred(T), list(T)).
20:44:02 <ski>   :- mode unsorted_solutions(pred(out) is nondet, out) is cc_multi.
20:44:21 <mreh> can you take this to haskell-blah? :)
20:44:27 <ski> erik__ : these i've named are basically corresponding to findall/3 .. i.e. no grouping of solutions like with bagof/3 and setof/3
20:44:38 <ski> mreh : sure
20:44:46 <ski> or, maybe #haskell-overflow ?
20:44:54 <mreh> thx, i dont think anyone is noticing my haskell questions
20:45:07 <Jonno_FTW> your question good sir?
20:45:12 <ski> my apologies
20:45:23 <mreh> yeah, #haskell-overflow
20:45:27 <mreh> just somewhere else!
20:45:44 <mreh> is anyone familiar with HGL blocking on maybeGetWindowEvent being a feature and not a bug?
20:45:47 <Saizan> mreh: i noticed, but i've no idea :)
20:46:54 <mreh> i set up an asteroids game, with a tick counter that should increment every time the game loop executes, but the tick only increases when the user presses keys or creates some other window event
20:47:09 <mreh> I would guess that it is blocking on user input even though it isn't supposed to
20:47:21 <mreh> maybe I create a patch!
20:47:37 <Berengal> Have you confirmed this?
20:47:52 * hackagebot upload: control-monad-free 0.5 - Free monads and monad transformers (PepeIborra)
20:48:03 <mreh> Berengal: I'll write a simple example to replicate the behaviour in a sec
20:49:01 <mreh> I took ages trying to make a sequenceMaybes last night, and ruined my code
20:49:54 <mreh> and sshfs is on the blink
20:50:07 <mreh> telling me I don't have permission to write to the remote drive
20:54:00 <Twey> A sequenceMaybes?
20:54:28 <Twey> :t sequence
20:54:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:54:34 <Twey> sequenceMaybe = sequence :: [Maybe a] -> Maybe [a]
20:57:14 <mreh> sequenceMaybe :: Monad m => [m (Maybe a)] -> m [a]
20:57:25 <mreh> it could probably use a better name
20:58:11 <Twey> sequenceMaybe = catMaybes . sequence
20:58:26 <gio123> ski: hey
20:58:34 <koeien37> :t catMaybes . sequence
20:58:35 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
20:58:35 <lambdabot>       Expected type: [[a1]] -> [Maybe a]
20:58:35 <lambdabot>       Inferred type: [[a1]] -> [[a1]]
20:58:40 <koeien37> :t catMaybes `liftM` sequence
20:58:41 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
20:58:41 <lambdabot>       Expected type: [[a1]] -> [Maybe a]
20:58:41 <lambdabot>       Inferred type: [[a1]] -> [[a1]]
20:59:10 <HugoDaniel> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5310#a5310
20:59:15 <HugoDaniel> can someone help me out with this ?
20:59:18 <HugoDaniel> i get that error
20:59:41 <HugoDaniel> when i try to runhaskell setup.hs configure on the directory-1.0.0.3 pkg
21:00:42 <HugoDaniel> i have rebuilt unix
21:00:43 <Berengal> HugoDaniel: Use cabal instead of runhaskell, and do a cabal clean first. Might help
21:01:03 <HugoDaniel> Berengal: exactly... im installing this because cabal-install depends on it
21:01:05 <HugoDaniel> :P
21:01:18 <Berengal> Eh, crap...
21:01:21 <HugoDaniel> i think this might be related to the fact that i have rebuild unix pkg
21:01:23 <HugoDaniel> yeh
21:01:37 <HugoDaniel> because the haskell platform depends on too much stuff :/
21:01:47 <HugoDaniel> so im just installing what i need
21:01:58 <Berengal> What I usually do is just nuke my entire ghc installation and start from scratch...
21:01:59 <HugoDaniel>  cabal being the first pkg :P
21:02:05 <HugoDaniel> oh
21:02:07 <HugoDaniel> :/
21:02:11 <HugoDaniel> thats going to take a while
21:02:27 <Berengal> Well, not if you start from a binary, and use the cabal bootstrap script thingy
21:02:51 <Berengal> Or you could try to manually clean the directory build-dir...
21:02:52 <HugoDaniel> im runing on freebsd, i tried looking for binary instalation of ghc and did not find
21:03:06 <HugoDaniel> is there any way to "recompile" all the packages only ?
21:03:07 <Berengal> Ah, then you might want to look into other alternatives, yeah
21:03:40 <HugoDaniel> hmm
21:04:00 <HugoDaniel> ill try to just deinstall and reinstall ghc form ports, without making it all over again
21:04:23 <HugoDaniel> also my ghci is completly cripled
21:04:25 <Berengal> I don't envy you
21:05:08 <Berengal> But I typically get an error like that when I've forgotten to use --make when building with ghc directly
21:05:40 <HugoDaniel> hmm
21:06:08 <Berengal> To fix that, I have to delete any .o and .hi files, or it won't link
21:06:09 <HugoDaniel> my errors in ghci are because it doesn't understand the characters Ctrl-D, up, down, left, right arrows
21:06:14 <HugoDaniel> delete, backspace, etc...
21:06:42 <Berengal> Can't help you there...
21:07:03 <HugoDaniel> i think this might be related with how ghci works with system libs in freebsd or whatever
21:07:12 <HugoDaniel> because in the shell i have properly configured the key bindings
21:07:53 <HugoDaniel> okey, reinstalling ghc solved it
21:07:55 <HugoDaniel> thanks
21:22:51 <pastah_rhymez> @src elems
21:22:51 <lambdabot> elems arr@(Array l u _) = [unsafeAt arr i | i <- [0 .. rangeSize (l,u) - 1]]
21:23:00 <pastah_rhymez> @src Map.elems
21:23:00 <lambdabot> Source not found. Sorry.
21:23:06 <pastah_rhymez> @src Data.Map.elems
21:23:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:27:09 <mreh> right, i've replicated the bug I beleive, can someone else try this out and see if the counter never budges? also check my code, but I'm pretty sure it is correct
21:27:13 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14037#a14037
21:27:29 <lambdabot_> mreh: wrong link
21:27:54 <mreh> ?!
21:27:55 <lambdabot> Maybe you meant: . ? @ v
21:28:06 <lambdabot_> Maybe you meant: . ? @ v
21:28:06 <mreh> @botsmack
21:28:06 <lunabot>  :o
21:28:06 <lambdabot> :)
21:28:17 <lambdabot_> :)
21:28:22 <zagibu> I have a beginner problem with a function that returns either a Term or Nothing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14038#a14038
21:28:41 <zagibu> if I use it like this, it complains about ambiguous "Nothing"
21:28:42 <koeien37> zagibu: Nothing already exists.
21:28:45 <koeien37> @src Maybe
21:28:45 <lambdabot> data Maybe a = Nothing | Just a
21:28:55 <lambdabot_>  data Maybe a = Nothing | Just b
21:29:07 <koeien37> why use your own type instead of Bool ?
21:29:26 <mreh> is lambdabot_ some kiddie?
21:29:36 <koeien37> yes
21:29:41 <zagibu> I already know about the Maybe type, but I have problems applying it to my case
21:29:45 <koeien37> i came to that conclusion
21:30:12 <mreh> there seems to be a latency with lambdabot_, about the length of time it takes to copy what lambdabot said
21:30:18 <koeien37> zagibu: oh, now i see what you want
21:30:18 <cnwdup> zagibu, the maybe type gives you Just a value or nothing. You probably have trouble applying it to your case because your type SubstExists is more like a Bool.
21:30:19 <zagibu> also, I can't use Bool, because normally, I return a Term (which I use for further computing)
21:30:44 <koeien37> zagibu: you want existsSubst :: Term -> MGU -> Maybe Term
21:30:56 <koeien37> and then either return "Just t2", "Just t1" or Nothing.
21:30:59 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14037#a14037 please if you can, see if I am actually replicating this bug
21:31:05 <koeien37> > Just 3 :: Maybe Int
21:31:05 <lambdabot>   Just 3
21:31:10 <lambdabot_> mreh: wrong link
21:31:15 <lambdabot_>  Just 3
21:31:41 <koeien37> @src Maybe
21:31:41 <lambdabot> data Maybe a = Nothing | Just a
21:31:51 <lambdabot_> data Maybe a = Nothing | Just b
21:32:03 <zagibu> like this, it doesn't work as well: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14038#a14039
21:32:11 <zagibu> complains that Nothing is no Term
21:34:19 <cnwdup> zagibu, you have to return Just t2.
21:34:48 <mreh> try this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14038#a14040
21:34:52 <zagibu> ah, great, thanks, that worked
21:35:15 <mreh> what?!
21:35:21 <lambdabot_> mreh: wrong link
21:35:26 <zagibu> this is so nuts, we're in a beginner's course and the "project" we were assigned is already pretty indepth
21:35:39 <zagibu> the Just t2 worked
21:35:54 <Jafet> Isn't that a good thing?
21:36:07 <zagibu> yeah, well, the project is 25% of the course grade
21:36:52 <zagibu> we are 5 teams, and 1 team has little problems (they are brainiacs), 1 team is my team, which has problems, but progresses slowly, and the other teams have no idea where to start
21:38:01 <mreh> Berengal: I replicated the error
21:38:32 * mreh .o0(bug is a stupid word)
21:39:05 <lambdabot_> mreh: bus is a stupid word
21:39:14 <mreh> this guy is hilarious
21:39:44 <mreh> can we kick him? I dont think I can take much more
21:40:29 <Jafet> Just apply the Turing test
21:40:43 <mreh> I think it passed
21:40:56 <Jafet> @faq can Haskell pass the Turing test?
21:40:56 <lambdabot> The answer is: Yes! Haskell can do that.
21:41:12 <Jonno_FTW_> @faq does haskell fail the turing test?
21:41:12 <lambdabot> The answer is: Yes! Haskell can do that.
21:41:15 <mreh> this imposter is very slow
21:42:11 <lambdabot_> :)
21:42:12 <lambdabot_> ok
21:42:12 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14037#a14037 -- this is definitely the correct link, please try and verify the error
21:42:17 <lambdabot_> guys
21:42:25 <lambdabot_> bye, i just wanted to make joke
21:42:35 <lambdabot_> bye mreh
21:42:35 <mreh> yeah, it was lost on us
21:44:18 <desp> Does anyone know if it's possible to catch the UserInterrupt exception *and* stop the program from exiting?
21:45:13 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14044#a14044
21:45:19 <desp> This does the former, but not the latter.
21:45:45 <desp> Which is very odd to me.
21:46:25 <mreh> desp: why? the program has finished evaluating when it catches the exception
21:46:47 <mreh> it has no more computation to perform
21:46:50 <desp> Oh no.
21:46:56 * desp facepalms
21:47:06 <desp> You're right, of course.
21:47:21 <desp> I was trying to simplify a more complicated program where I had problems with the exception, and I simplified too much.
21:47:27 <benmachine> heh
21:47:53 <Kim^Walkman> desp: When playing with UserInterrupt be aware that GHCi also has some mechanisms in place for catching it
22:03:53 <EnglishGent> why doesnt this work? unlist n = \x -> ([x] ++ (unlist (n-1))) - it gives me a type error - but I dont see why
22:04:38 <byorgey> EnglishGent: because  unlist (n-1) returns a function, and you are using ++ on it
22:04:41 <HugoDaniel> "configure: error: curl libraries not found, so curl package cannot be built" when i do a cabal install curl
22:04:50 <HugoDaniel> but i have the libcurl in /usr/local/lib
22:05:02 <HugoDaniel> how can i fix this ?
22:05:05 <EnglishGent> ah!
22:05:09 <byorgey> EnglishGent: perhaps you meant  \x -> ([x] ++ (unlist (n-1) x)) ?
22:05:11 <Berengal> HugoDaniel: libcurl-dev?
22:05:12 <EnglishGent> ty :)
22:05:24 <byorgey> EnglishGent: even better, perhaps you meant  'replicate n'
22:05:26 <byorgey> ;)
22:05:29 <HugoDaniel> Berengal: i dont know... let me check
22:05:34 <EnglishGent> ty byorgey :)
22:06:01 <desp> mreh: so...what am I doing wrong this time?
22:06:04 <HugoDaniel> i think it might be the dev
22:06:14 <HugoDaniel> because i also have the include files in /usr/local/include
22:06:49 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14044#a14045
22:06:59 <Berengal> HugoDaniel: Then something is preventing it from detecting them
22:07:34 <desp> Kim^Walkman: I'm not using ghci to test this; I'm running a compiled binary.  I'm not getting a "caught" message this time at all, and it takes two ^Cs to stop the program.
22:07:56 <Berengal> HugoDaniel: There might be magic arguments to specify folders to look in or whatnot, but I don't know about them.
22:08:50 <EnglishGent> actually no .. I was wondering if it would be possible to build something such that you gave it an Int n, and it returned you a n-argument function which returned you the list of all it's elements - I'm not sure if this is even doable in Haskell
22:09:03 * EnglishGent is just playing with the language - no practical use is intended :)
22:10:18 <byorgey> EnglishGent: ah.  I think that might be sort of possible using a bunch of type-level-programing hacks, but it isn't easy.
22:10:29 <Berengal> EnglishGent: I think you can hack it by beating up the type class system.
22:10:39 <byorgey> EnglishGent: what would be the type of such a function?  Int -> ???
22:10:49 <byorgey> for this you really want a dependently typed language
22:11:22 <byorgey> because the part in the ??? depends on the *value* of the Int
22:11:48 <EnglishGent> yeah - now that you pointed it out I can see that
22:12:22 <EnglishGent> but hey - that answers my origional question of 'is it possible to do this at all?'
22:12:26 * EnglishGent still learning :)
22:12:31 <Berengal> It is possible
22:12:46 <EnglishGent> how Berengal?
22:12:50 <Berengal> you could have a function :: (MagicTypeClass f) => Int -> f
22:13:46 <Berengal> And have class MagicTypeclass f where value :: f a -> [a]; apply :: (MagicTypeclass g) => f a -> a -> g a
22:14:00 <Berengal> Or something
22:14:11 <Berengal> Then have instances for functions and some other type
22:14:35 <EnglishGent> um - I'm going to have to think about that (cant really claim to grok it just now) - but thanks!
22:14:39 <Berengal> I haven't really thought this through, but printf uses this trick
22:14:42 * EnglishGent shall have a ponder
22:15:11 <byorgey> yes, but in Haskell it's all hacks to sort of simulate dependent types
22:15:16 <EnglishGent> I'm still trying to get to grips with the type system generally
22:15:26 <Berengal> I wrote one such class once to print truth-tables for every Bool* -> Bool function
22:15:34 <Berengal> (Where Bool* is an arbitrary number of bools)
22:15:44 <EnglishGent> oh - is the source available anywhere? :)
22:16:07 <Berengal> No, I don't have it anymore
22:16:26 <EnglishGent> oh well, just wondering
22:16:52 <Berengal> It wasn't too hard. Nothing fancy except for just that trick, so it's a focused excercise.
22:17:47 <EnglishGent> I shall give it a go then .. I'm trying to understand the type system at least well enough to grok type-level programming & the HLists paper - those are aims I'm trying to work towards
22:17:52 <EnglishGent> not somewhere I am yet
22:19:30 <emile_m> What kind of program all beginners usually write for leveling up their Haskell practical skills?
22:19:48 <Hunner> irc bots?
22:19:53 <Axman6> i used project euler
22:20:20 <MarcWeber> emile_m: Maybe they don't write but they read existing code :) Have a look at hackage. Take a project you're interested in and try using it
22:21:08 <MarcWeber> After reading some code come back and ask where to find documentation explaining what you don't understand yet.. :)
22:21:44 <emile_m> MarcWeber: I've already read some of hackage sources.
22:22:39 <olsner> I've written some small shell and CVS tools I needed/wanted in haskell.. basically, find something to write and write it in haskell instead of whatever language you knew before that
22:22:58 <emile_m> MarcWeber: OK, then, what should I know from mathematics?
22:24:06 <Raevel> i started doing my shell scripting in haskell
22:24:30 <Axman6> anyone ever seen any HDL sort of stuff done in haskell?
22:25:57 <MarcWeber> emile_m: Probably I'm the wrong person to ask here because I haven't done any math for two years. If you want to hack on something maybe you can help writing the next hackage server? I don't know much about this project yet except that it's darcs repository is: http://code.haskell.org/hackage-server/.
22:26:02 <desp> Axman6: kind of; have you seen Yampa?
22:26:19 <MarcWeber> Things which are on my todo list: improve hack-nix, make darcs compile with base4 and much more.
22:26:39 <Axman6> desp: nope. wikipedia leads me to three though: Bluespec, Mydra and Lava
22:26:57 <MarcWeber> emile_m: emile_m You should know about the haskell mailingilist. You'll get many replies soon if you ask who wants some help :)
22:28:37 <MarcWeber> emile_m: Rewriting all sh scripts in haskell is nonsense unless they are complicated. Each haskell binary takes much more space than a .sh script.
22:29:00 <MarcWeber> emile_m: Learn about scion and start hacking on it.
22:29:18 <desp> Can someone help me with catching UserInterrupt properly?
22:29:25 <MarcWeber> Eg adding import statements automatically is a feature I'm missing.
22:30:03 <MarcWeber> desp: Can't you just add a handle or catch statement?
22:31:06 <emile_m> MarcWeber: I've not yet acquired such Force level in order to offer my help in haskell-cafe :)
22:32:33 <desp> MarcWeber: it's not that simple
22:33:01 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=14050#a14050
22:33:08 <desp> Why does "caught" display only once here?
22:34:27 <MarcWeber> emile_m: How do you know. People are willing to help you. Which is your favourite editor?
22:35:12 <MarcWeber> desp: It works once for me
22:35:27 <emile_m> MarcWeber: emacs.
22:35:39 <desp> MarcWeber: and shouldn't it work multiple times?
22:35:53 <MarcWeber> desp: I'm still reading your code but I think yes
22:36:23 <desp> I want it to work multiple times so that I can add a save/restore function to my VM.
22:36:31 <MarcWeber> emile_m: If you really want to get with haskell programming you could extend hack-nix to support emacs tags
22:36:49 <MarcWeber> hack-nix is a system which let's you install arbitrary dependencies easily by running hack-nix --build-env
22:37:56 <emile_m> MarcWeber: Some sort of package management system?
22:38:12 <MarcWeber> emile_m: Yes.
22:38:48 <emile_m> Wow! Cool, I've thinking about "pure" package management recently.
22:39:13 <MarcWeber> It's not that related to haskell right now. But if you've set it up you'll get started faster hacking haskell
22:40:27 <MarcWeber> desp: It's not caused by nesting catch blocks or such
22:41:22 <Berengal> desp: Interrupts are disabled in the "catch" part of handlers. You need to either leave that part, or reenable them
22:41:32 <eivuokko> desp, I don't see how it'd be cause by this, but I wouldn't recurse inside catchHandler.  It will build up stack due to block/unblock.
22:41:53 <eivuokko> Berengal, shouldn't the "unblock" in side the next handler enable them automatically, anyway?
22:41:57 <MarcWeber> Berengal, desp  http://dpaste.com/132375/ I've rewritten it
22:42:06 <MarcWeber> The catch is reentered after a Interrup was caught
22:42:35 <desp> MarcWeber: it still only catches once
22:42:40 <MarcWeber> And it still doesn't work
22:42:45 <Berengal> eivuokko: There's an "unblock" at the beginning of these catches?
22:42:52 <MarcWeber> Yes. But we know that the catch or block stuff is not causing trouble..
22:43:06 <desp> eivuokko: I'm trying to figure out a way to continue looping after catching.
22:43:25 <MarcWeber> desp: What do you really want to do?
22:43:35 <desp> The idea is to print a prompt on catch, and ask the user whether she wants to continue, abort, or save the current state.
22:43:49 <MarcWeber> I think you setup your own handler. It think happs(tack) sources contain those.
22:43:52 <desp> Similar to what the Erlang interpreter does, or any number of Lisp runtimes.
22:44:20 <MarcWeber> desp: Writing a 4line shell script doing so is not an option, correct?
22:44:42 <desp> Not really, no.
22:45:49 <desp> I didn't know there's another way to provide exception handlers.
22:45:54 <desp> Looking.
22:46:23 <eivuokko> I'd possibly try something like this: foo = block bar   bar = (catch ..) >>= \x -> if x then bar else return ()
22:47:03 <eivuokko> You need outer block to stop async exception thrown while not inside catch, but you don't want to recurse with block frames in stack.
22:47:10 <eivuokko> (except the single one)
22:48:55 <eivuokko> Well, I dunno if it matters, but it could if you add support for other async exceptions, maybe signals or something.
22:49:29 <MarcWeber> desp: installHandler is the function. Maybe you can also just override teh default one
22:50:36 <desp> MarcWeber: but that's System.Posix.Signals...
22:51:30 <desp> Ah, and it works great.
22:51:35 <desp> http://therning.org/magnus/archives/285
22:51:56 <desp> Well, thanks. :)
22:52:30 <Axman6> :t catch
22:52:31 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
22:52:43 <Axman6> @hoogle IOError
22:52:44 <lambdabot> Prelude type IOError = IOException
22:52:44 <lambdabot> System.IO.Error type IOError = IOException
22:52:44 <lambdabot> Prelude ioError :: IOError -> IO a
22:52:56 <desp> Axman6: there are two catches, Prelude and Control.Exception
22:53:13 <Axman6> there's a Prelude catch?
22:53:22 <desp> That's what you just got from bot
23:03:37 <Baughn> Axman6: Sadly.
23:08:45 <Craig`> would anyone recommend learning lisp before haskell?
23:08:51 <medfly> why?
23:09:06 <Twey> Not really
23:09:09 <sioraiocht> Craig`: No
23:09:13 <opqdonut> they're pretty orthogonal
23:09:28 <Twey> I might recommend learning programming using SICP before Haskell
23:09:37 <Twey> But the Scheme is only incidental
23:09:38 <opqdonut> previous experience with functional programming is a bonus when learning haskell
23:09:58 <opqdonut> but learning lisp just to get some fp experience sounds like overkill
23:10:01 <opqdonut> yeah, SICP is a good suggestion
23:10:13 <Twey> And there are those who disagree with me there, too
23:10:22 <Craig`> it's just a few people recommend that learning LISP will make you a better programmer, so I was wondering if I should do some lisp first,
23:10:22 <Craig`> but nevermind then heh
23:10:36 <Twey> Learning using a strict language like Scheme *may* cripple your understanding of lazy programming
23:10:55 <Twey> … or it may not.  I don't feel particularly impeded by it.  YMMV.
23:11:03 <abbe> Craig`: Hacker Howto by ESR ;)
23:11:38 <Craig`> haha I read that last week :P
23:12:10 <Philonous1> Lambda calculus helped me a lot in understanding lazy evaluation
23:12:55 <Craig`> I like the idea of functional programming, and that it's different, so I'll just be doing little bits of haskell on the side, I'm thinking of getting a copy or real world haskell :)
23:13:17 <opqdonut> learning lisp probably is a good idea
23:13:36 <opqdonut> but if you want to learn haskell, start with it :)
23:13:43 <medfly> Craig`, you can learn Haskell and you can learn lisp.
23:13:44 <Twey> Learning Lisp is indubitably a good idea.  Whether it should be learnt before or after Haskell is the point that merits debate.
23:14:03 <opqdonut> or whether it even matters
23:14:09 <Craig`> I'm currently "learning" ruby
23:14:24 <Craig`> so, I'll be doing mostly ruby, but then some little FP on the side
23:14:30 <medfly> Haskell is the first language I became proficient at, and it wasn't so bad.
23:15:04 <Axman6> carlocci: that's totally the wrong way to do it ;)
23:15:04 <Twey> Oh
23:15:10 <Twey> You've already been ruined, then
23:15:12 <Craig`> did you have previous programming experience, and how long did it take you to become "proficient"?
23:15:15 <Axman6> uh, Craig`, not carlocci
23:15:16 <carlocci> I definitely agree!
23:15:32 <Twey> You might use Scheme as a stepping stone on the path of redemption ;)
23:15:36 <Twey> carlocci: :-D
23:15:54 <Craig`> Axman6, what's the wrong way to do it? I'm learning ruby atm as I like the language, the syntax, the idea of it, and I use rails
23:15:57 <medfly> I did have a little programming experience, and it was a few months, but mostly because I'm lazy and procrastinate things. (but once I started working hard on improving, it didn't take long)
23:16:27 <medfly> though there's a lot of stuff I could still learn, I feel like I could do a lot of things that I may desire to in Haskell :-)
23:16:38 <Axman6> carlocci: i'm the same as medfly. i had used a lot of languages previously (C,C++,Ruby,PHP,little perl, python), and haskell was the first one i fell in love with, and thought "shit, why isn't all programming like this?"
23:16:42 <Axman6> fark
23:16:59 <Axman6> S/carlocci/Craig`
23:17:01 <Axman6> >_<
23:17:07 <Twey> Heheh.
23:17:08 <carlocci> I see
23:17:21 <carlocci> do you want me to change nick for a while?
23:17:34 <Axman6> Craig`: you should be learning haskell, with a little ruby on the side ;)
23:17:35 <mercury^> There's no reason to get the completion wrong...
23:17:42 <carlocci> :)
23:17:55 <Twey> I presume people are transposing ‘r’ and ‘a’
23:18:00 <Philonous1> Their common prefix is just one letter. Changing nick won't help
23:18:03 <Twey> Or perhaps they're just being lazy and typing ‘c’ ;)
23:18:05 <Axman6> carlocci: the number of times i've threatened to enforce a 26 nick oonly policy in another channel... -_-
23:18:19 <medfly> I didn't have a lot of programming experience at all. I didn't even make really small programs before, but I knew a thing or two ;-)
23:18:20 <Twey> Haha
23:18:20 <Craig`> Axman6, haha :) I did a tiny bit of haskell last year, and I enjoyed it as it was different, but then I ended up doing ruby, and tbh I love it, so I'd like to do both :)
23:18:23 <Axman6> Twey: the latter ;)
23:19:01 <Twey> Craig`: I have some bad news for you
23:19:08 <Axman6> after learning haskell, i find the idea of ruby horrible. there's no types! no assurances! how can you program like that!
23:19:14 <Twey> Craig`: When you're done learning Haskell, the chance that you'll still like Ruby is slim ;)
23:19:28 <sioraiocht> Axman6: you can't, heh
23:19:33 <sioraiocht> Axman6: at least, imo =)
23:19:40 <medfly> yeah, I've gotten used to some Haskell ideas too... I'm using some inferior language now and I get surprised every time :)
23:19:46 <sioraiocht> the first thing I do when writing a function is think "So what is the type?"
23:19:52 <Craig`> well, I'll probs stay with rails, unless I try haskell cgi..
23:19:54 <Axman6> sioraiocht: me too
23:20:13 <Twey> Craig`: Turbinado, Happstack
23:20:16 <dschoepe> Craig`: there's also Happstack for web programming, but I never tried it
23:20:31 <Craig`> oh cool, but any ways, that's going too far ahead :)
23:21:00 <Twey> (and Rails is even nastier than Ruby — the Rails-centricity of the Ruby community is one of the things I dislike most about Ruby)
23:21:03 <Axman6> hmm, in parsec, how would you write the parser for /*...*/ comments? i'm trying between (string "/*") (string "*/") (many anyChar), but that's not working
23:21:04 <Craig`> what books would you recommend? real world haskell, (i know its available online, and learn you a haskell is good), any more?
23:21:12 <medfly> @where lyah
23:21:12 <lambdabot> http://www.learnyouahaskell.com/
23:21:13 <Axman6> @where lyah
23:21:14 <lambdabot> http://www.learnyouahaskell.com/
23:21:17 <Axman6> @where lyah
23:21:18 <lambdabot> http://www.learnyouahaskell.com/
23:21:19 <Axman6> for luck
23:21:20 <Twey> @where rwh
23:21:21 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:21:22 * medfly high-fives Axman6 
23:21:28 <Axman6> score!
23:21:29 <emile_m> Is it ever possible for functional programming to bevome popular and widely-used?
23:21:32 <Twey> :<
23:21:35 <dschoepe> @hoogle between
23:21:36 <lambdabot> Text.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
23:21:36 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
23:21:36 <lambdabot> Text.ParserCombinators.Parsec.Combinator between :: Stream s m t => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m a -> ParsecT s u m a
23:21:40 <Twey> emile_m: It already is
23:21:41 <dschoepe> Axman6: ^
23:21:48 <medfly> emile_m, depends on your definition of popular
23:21:57 <Twey> Where have you been the last five years? :þ
23:21:57 <Axman6> even NASA are coming to Galois for help these days!
23:22:10 <emile_m> No, I mean like Java and stuff :)
23:22:15 <Twey> We've insinuated ourselves into all the popular languages.
23:22:16 <Axman6> possibly
23:22:17 <medfly> I don't think it'd take the world of very crappy programmers any time soon, so it won't be that popular
23:22:23 <Twey> Java has generics.  .NET has LINQ.
23:22:31 <Axman6> emile_m: solves a lot of problems we need to solve right now, so, it should
23:23:07 <Axman6> emile_m: hmm, different between it seems (different parsec i guess)
23:23:09 <Twey> Python, Ruby, and Perl all have first-class functions, and now even PHP is getting proper closures (albeit with a horrifically verbose syntax)
23:23:38 <Twey> Axman6: I think your problem is that the ‘many anyChar’ matches the "*/" too
23:23:43 <Axman6> yeah
23:23:55 <Axman6> i need some way to get everything that isn't "*/"
23:24:01 <emile_m> I dream about wide-spreading of FP languages.
23:24:14 <Twey> emile_m: Oh, and don't forget
23:24:27 <Twey> The world's most prolific language, Javascript, is basically functional
23:24:44 <Twey> (and getting moreso with every Crockford book and Mozilla extension)
23:25:04 <Axman6> anyone else hear that Mozilla are encouraging people to move to Bing?
23:25:17 <medfly> are they getting money from microsoft now?
23:25:23 <Twey> Bing?  As in Microsoft's terminally crappy search engine?
23:25:37 <Axman6> no, they apparently dislike google storing as much info about you as they can
23:25:46 <emile_m> Twey: Yes, I know that (actually, I came to Haskell from Python with it's furst-class functions and map and reduce). But it isn't the same as Haskell or even ML.
23:25:47 <medfly> I dislike that too
23:25:52 <Twey> I'd recommend Clusty or something, then
23:26:06 <Twey> Y'know, something that works and gives actual relevant results
23:26:16 <medfly> altavista!
23:26:43 <Twey> emile_m: It can be, with effort.  It's just not the predominant style.
23:26:59 <emile_m> Twey: That's the key point!
23:27:15 <Twey> You can write imperatively in Haskell, too ;)
23:27:23 <Philonous> ixquick.com
23:27:35 <Axman6> powerset >_>
23:27:44 <opqdonut> i like duck duck go
23:27:54 <opqdonut> (re: alternative search engines)
23:28:09 <Axman6> oh fark, MS own powerset >_<
23:31:27 <Craig`> back :)
23:37:07 <Craig`> a little off topic, but does anyone know a good website for programming exercises? then I'd just read, and learn some programming, and then try to apply it :)
23:37:34 <dmwit> ?where euler
23:37:35 <lambdabot> http://projecteuler.net
23:38:09 <Craig`> thanks :)
23:38:19 <Craig`> I take it that the bot is programmed in haskell :)?
23:38:36 <Craig`> oh and thank you! that's the site I've been looking for a while now, :D
23:40:45 <nagnatron> Try also the 99 haskell problems.
23:41:10 <Craig`> the first one is so easy with ruby, heh but let's not get into that
23:41:39 <Berengal> The first one is easy in just about every language out there
23:42:20 <Craig`> true, but you must admit: (1..1000).find_all { |x| x % 3 == 0 or x % 5 == 0 }.inject(:+) is very simple
23:43:19 <Berengal> > sum . filter (\x -> mod x 3 == 0 || mod x 5 == 0) $ [1..1000]
23:43:20 <lambdabot>   234168
23:43:52 <Twey> sum $ filter (liftM2 (||) (`mod` 3) (`mod` 5)) [1 .. 1000]
23:43:54 <Twey> > sum $ filter (liftM2 (||) (`mod` 3) (`mod` 5)) [1 .. 1000]
23:43:55 <Craig`> that's awesome as well :)
23:43:55 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
23:43:56 <lambdabot>    arising from a use of ...
23:44:00 <Twey> Boo, hiss
23:44:08 <mercury^> > (1000 `div` 3) + (1000 `div` 5) - (1000 `div` 15)
23:44:09 <lambdabot>   467
23:44:11 <Twey> Oh, right — == 0
23:44:20 <mercury^> Oh, different question. :>
23:44:20 <Craig`> any ways, I'll do some haskell after I've had a burger and cleaned the rabbit cage mwha
23:45:07 <PepeSilvia> > sum [3,6..999] + sum [5,10..995] - sum [15,30..990]
23:45:08 <lambdabot>   233168
23:45:32 <Twey> Heh
23:45:45 <Twey> > sum $ filter (liftM2 ((||) `on` (== 0)) (`mod` 3) (`mod` 5)) [1 .. 1000]
23:45:46 <lambdabot>   234168
23:46:10 <Berengal> > sum (([3,6..999] ++ [5,10..999]) \\ [15,30..999])
23:46:10 <nagnatron> > sum [x|x<-[1..1000],x `mod` 3 == 0 || x `mod` 5 == 0]
23:46:11 * Axman6 begins to wonder if Craig` is the Craig` whose party he went to last night
23:46:12 <Twey> Also, I had to guess what ‘inject’ did
23:46:13 <lambdabot>   233168
23:46:13 <lambdabot>   234168
23:46:23 <Twey> That's a horribly unintuitive name for a fold
23:46:42 <Twey> ‘fold’, sure.  ‘reduce’, okay.  ‘inject’?
23:46:56 <Twey> Sounds like an ‘insert’
23:47:56 <mercury^> > let f n m = m*(let d = (n `div` m) in d*(d+1) `div` 2); g = f 1000 in g 3 + g 5 - g 15
23:47:57 <lambdabot>   234168
23:48:34 <Craig`> Axman6, you would be mistaken haha :)
23:51:59 <emile_m> I wonder why method "Monad m => a -> m a" has such strange name "return"?
23:52:18 <Twey> Because of how it's used
23:52:42 <Twey> It's mostly used when you want to *return* a pure value at the end of a series of computations.
23:54:51 <emile_m> Twey: I see, though name "pure" from Applicative fits better, imho.
23:56:19 <eivuokko> In any case, names chosen for such generic tools are bound to be unintuitive in some uses.
23:56:33 <manju_> can I download the haskell library doc for local use ?
23:56:47 <manju_> like when I am not connected to the internet ?
23:57:44 <Philonous> Twey: I, too, think return is misnomer. I seems as they wanted to simulate C syntax
23:59:13 * Axman6 doesn't thi8nk that pure is a better name, but also doesn't like the confusion return brings
23:59:41 <Philonous> emile_m: both return and pure are special cases of Control.Functor.Pointed.point
23:59:43 <Twey> emile_m: Yes, it does, but that one was taken, and they didn't think to make it a typeclass as they really should have ;)
23:59:51 <Twey> Aye
23:59:58 <Twey> They should really all be called point
