00:00:27 <ski> @type ?three_stars id id
00:00:29 <lambdabot> forall t a a1. (?three_stars::(a -> a) -> (a1 -> a1) -> t) => t
00:00:56 <ivanm> heh
00:03:31 <sohum> ski: ?
00:04:19 <ski> you appeared to want to know the type of a variable `(***)', when it occurs in an expression `id *** id'
00:04:48 <ski> (.. but maybe you wanted to know what instantiation the standard `(***)' would have in that expression ?)
00:05:46 <ski> @type (\three_stars -> let _ = three_stars id id in three_stars) (***)
00:05:47 <lambdabot> forall a a1. (a -> a) -> (a1 -> a1) -> (a, a1) -> (a, a1)
00:05:52 <ski> would appear to do that ..
00:06:11 <sohum> hrrrm
00:06:15 <ivanm> yes, I think that's what he wanted
00:06:24 <ivanm> ooohhh....
00:06:25 <sohum> yes, I'm just not sure how you did that
00:06:26 <ivanm> ski++
00:06:37 <ski> @type (\id -> let _ = (id False,id 'a') in id) id
00:06:38 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
00:06:39 <lambdabot>       Expected type: Char -> t
00:06:39 <lambdabot>       Inferred type: Bool -> t1
00:06:41 <ski> *nod*
00:07:17 * ski for a while feared that GHC RankN extension would hinder exploiting that lambda-bound variables are monomorphic
00:07:40 <sohum> :t (\f -> let _ = f 4 4 in f) (+)
00:07:42 <lambdabot> forall t. (Num t) => t -> t -> t
00:07:49 <sohum> :t (\f -> let _ = f 4.0 4.0 in f) (+)
00:07:51 <lambdabot> forall t. (Fractional t) => t -> t -> t
00:07:56 <sohum> oooh
00:07:58 <ski> @type (\f -> let _ = f 4 (4 :: Integer) in f) (+)
00:07:58 <sohum> that's clever
00:08:00 <lambdabot> Integer -> Integer -> Integer
00:08:10 <sohum> ski++
00:08:22 <c_wraith> @hoogle Handle -> String
00:08:23 <lambdabot> System.IO hGetContents :: Handle -> IO String
00:08:23 <lambdabot> System.IO hGetLine :: Handle -> IO String
00:08:23 <lambdabot> System.IO hShow :: Handle -> IO String
00:10:16 <sohum> so translate :t foo in foo [bar]* to :t (\gensym -> let _ = gensym [bar]* in gensym) foo
00:10:20 <sohum> cool
00:10:55 <ski> @type asTypeOf
00:10:57 <lambdabot> forall a. a -> a -> a
00:10:59 <ski> @src asTypeOf
00:11:00 <lambdabot> asTypeOf = const
00:11:01 <ski> @let asTypeIn :: a -> (a -> b) -> a; asTypeIn a f = a where _ = f a
00:11:03 <lambdabot>  Defined.
00:11:26 <ski> > (+) `asTypeIn` \(+) -> 4 + (4 :: Integer)
00:11:28 <lambdabot>   -3->
00:11:28 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
00:11:28 <lambdabot>  -2->
00:11:28 <lambdabot>    {-3->-5;-2->...
00:11:33 <ski> heh
00:11:36 <ski> @type (+) `asTypeIn` \(+) -> 4 + (4 :: Integer)
00:11:38 <lambdabot> Integer -> Integer -> Integer
00:11:40 <ski> i meant, here :)
00:11:54 <ski> @type (***) `asTypeIn` \(***) -> id *** id
00:11:56 <lambdabot> forall c c'. (c -> c) -> (c' -> c') -> (c, c') -> (c, c')
00:12:08 <sohum> that is awesome
00:12:29 <sohum> ski++
00:12:37 * ski beams
00:13:03 <osaunders> Can an anonymous fn take multiple params?
00:13:07 <ski> yes
00:13:09 <sohum> I wonder what happens if...
00:13:18 <osaunders> > (\a -> b -> a + b) 1 2
00:13:19 <lambdabot>   Pattern syntax in expression context: \ a -> b -> a + b
00:13:33 <sohum> :t (+) `asTypeIn` \f -> f 4
00:13:34 <ski> > map (\(x,y) -> x + y) [(1,300),(2,200),(3,100)]
00:13:35 <lambdabot> forall a. (Num a) => a -> a -> a
00:13:36 <lambdabot>   [301,202,103]
00:13:39 <Twey> > (\a b -> a + b) 1 2
00:13:39 <lambdabot>   3
00:13:44 <sohum> :t (+) `asTypeIn` \f -> f (4 :: Integer)
00:13:45 <ski> > map (\(x,y) -> x + y) (zip [1,2,3] [300,200,100])
00:13:46 <lambdabot> Integer -> Integer -> Integer
00:13:47 <lambdabot>   [301,202,103]
00:13:48 <Twey> A.K.A. (+) 1 2
00:13:49 <osaunders> Twey: Ahh thnx
00:13:55 <Twey> A.K.A. 1 + 2 ‚ò∫
00:14:02 <ski> > zipWith (\x -> \y -> x + y) [1,2,3] [300,200,100]
00:14:04 <lambdabot>   [301,202,103]
00:14:05 <ski> > zipWith (\x y -> x + y) [1,2,3] [300,200,100]
00:14:07 <sohum> oh cool
00:14:07 <lambdabot>   [301,202,103]
00:14:21 <sohum> yay currying
00:14:28 <Twey> > zipWith (+) [1 .. 3] [300, 200, 100]
00:14:28 <lambdabot>   [301,202,103]
00:15:58 <sohum> :t ati
00:16:00 <lambdabot> Not in scope: `ati'
00:16:06 <sohum> @let ati = asTypeIn
00:16:08 <lambdabot>  Defined.
00:16:16 <osaunders> @hoogle (a,b) -> [c]
00:16:17 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
00:16:17 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
00:16:17 <lambdabot> Prelude fst :: (a, b) -> a
00:16:44 <ski> sohum : you lazy person :)
00:16:57 <sohum> *efficient, thank you :P
00:17:19 <osaunders> @google ati
00:17:21 <lambdabot> http://www.amd.com/
00:17:21 <lambdabot> Title: Global Provider of Innovative Graphics, Processors and Media Solutions | AMD
00:17:38 <osaunders> Oh I didn't know AMD bought ATI.
00:17:48 <sohum> some time ago now, yeah
00:18:06 <copumpkin> I like that asTypeIn
00:18:13 <copumpkin> Cale: any chance of adding that permanently?
00:18:39 <sohum> @src asTypeIn
00:18:40 <lambdabot> Source not found. I feel much better now.
00:18:46 <sohum> hrm?
00:18:50 <copumpkin> sTypeIn :: a -> (a -> b) -> a; asTypeIn a f = a where _ = f a
00:19:06 <sohum> I thought src was for finding the src of bot-defined stuff
00:19:09 <copumpkin> nope
00:19:19 <copumpkin> only stuff in a magic library of source that the bot already knows
00:19:21 * sohum shrug
00:19:25 <sohum> fair enough
00:19:52 <ski> i suppose i should have s/asTypeIn a f =/a `asTypeIn` f =/ ..
00:20:03 <sohum> meh
00:20:15 <sohum> @pl \a f = a where _ = f a
00:20:16 <lambdabot> (line 1, column 6):
00:20:16 <lambdabot> unexpected "="
00:20:16 <lambdabot> expecting pattern or "->"
00:20:24 <sohum> @pl \a f -> a where _ = f a
00:20:25 <lambdabot> (line 1, column 17):
00:20:26 <lambdabot> unexpected "_"
00:20:26 <lambdabot> expecting variable, "(", operator or end of input
00:20:32 <copumpkin> it needs a type annotation
00:20:36 <copumpkin> or maybe not
00:20:51 <sohum> nah, I think it just doesn't understand _
00:21:02 <aeron> So if I have a program that needs mutable state but it's got a single main loop, since it's easy to thread the state through function arguments, what are the downsides to this approach?
00:21:20 <ski> @tell Cale .. in case you want to add it, add  asTypeIn :: a -> (a -> b) -> a; a `asTypeIn` f = a where _ = f a
00:21:21 <lambdabot> Consider it noted.
00:21:54 <copumpkin> asUsedIn ?
00:22:36 <ski> i wanted it to be a bit similar to `asTypeOf'
00:22:40 <copumpkin> yeah
00:22:54 <ski> .. but `asTypeUsedIn' is maybe too long
00:23:33 * ski wouldn't think it's too long .. but some other people might
00:23:40 <osaunders> > unwords $ map (unwords.pairToList) $ zip ["foo", "bar"] ["fighters", "crawl"]
00:23:42 <lambdabot>   Not in scope: `pairToList'
00:24:08 <copumpkin> > unwords $ transpose [["foo", "bar"] ["fighters", "crawl"]]
00:24:10 <lambdabot>   Couldn't match expected type `t -> [GHC.Types.Char]'
00:24:10 <lambdabot>         against inferr...
00:24:25 <ski> concat
00:24:32 <aeron> what are the downsides to threading state on the stack? what's the benefit to using the state/ioref monads?
00:24:35 <ski> hm, no
00:24:37 <ziman> you're missing a comma there
00:24:40 <copumpkin> aha
00:24:41 <copumpkin> lol
00:24:42 <ski> > unwords $ transpose [["foo", "bar"],["fighters", "crawl"]]
00:24:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:24:44 <lambdabot>         against inferred type...
00:24:47 <copumpkin> > unwords . concat . transpose $ [["foo", "bar"], ["fighters", "crawl"]]
00:24:49 <lambdabot>   "foo fighters bar crawl"
00:24:54 <osaunders> > unwords $ map (unwords.(\(a,b) -> [a,b])) $ zip ["foo", "bar"] ["fighters", "crawl"]
00:24:56 <lambdabot>   "foo fighters bar crawl"
00:25:08 <ski> ok, both :)
00:25:25 <osaunders> Mine is kinda awkward.
00:25:27 <copumpkin> osaunders: zip* and transpose are pretty intimate with one another
00:25:30 <osaunders> I was just messing about.
00:26:20 <ski> @type app . ((:) *** (:[]))
00:26:22 <lambdabot> forall b. (b, b) -> [b]
00:26:26 <copumpkin> lol
00:26:43 <copumpkin> is that the ArrowApply one?
00:26:45 <ski> yes
00:26:48 <ski> @type app
00:26:50 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
00:27:00 <copumpkin> now that is fancy!
00:27:12 <copumpkin> @pl couldn't have done better -- ;)
00:27:13 <lambdabot> couldn't have done better
00:27:16 * sohum blinkblink
00:27:35 <ski> @type app `asTypeIn` \app -> app . ((:) *** (:[]))
00:27:38 <lambdabot> forall b. ([b] -> [b], [b]) -> [b]
00:27:44 <copumpkin> :)
00:27:59 <copumpkin> omg an exponential!
00:28:06 <copumpkin> :P
00:28:14 <ski> @type uncurry id `asTypeIn` \app -> app . ((:) *** (:[]))
00:28:16 <lambdabot> forall b. ([b] -> [b], [b]) -> [b]
00:29:50 <ski> @pl \(a,b) -> [a,b]  -- hm ?
00:29:51 <lambdabot> uncurry ((. return) . (:))
00:30:05 <sohum> :t app `ati` (.) app
00:30:06 * ski wouldn't have thought of that ..
00:30:06 <lambdabot> forall (a :: * -> * -> *) b b1 b2. (ArrowApply a, Functor (a (a b (b1 -> b2, b1), b))) => a (a b (b1 -> b2, b1), b) (b1 -> b2, b1)
00:30:30 <ski> sohum : are you sure you didn't forget `\app -> ' in there ?
00:30:34 <sohum> oh, duh
00:30:36 <osaunders> which is preferred: (unwords.concat.transpose) or unwords $ concat $ transpose ?
00:30:39 <sohum> :t app `ati` \app -> (.) app
00:30:41 <lambdabot>     Ambiguous type variable `f' in the constraint:
00:30:41 <lambdabot>       `Functor f' arising from a use of `.' at <interactive>:1:18-24
00:30:41 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
00:30:51 <Twey> osaunders: Not equivalent
00:30:52 <sohum> right
00:30:56 <sohum> um...
00:30:58 <sohum> :t (.)
00:31:00 <sohum> :t ($)
00:31:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:31:02 <lambdabot> forall a b. (a -> b) -> a -> b
00:31:04 <ski> Caleskell
00:31:06 <ski> @type app `ati` \app -> (Prelude..) app
00:31:07 <lambdabot> forall b c. (b -> c, b) -> c
00:31:08 <ski> better ?
00:31:17 <sohum> oh, ok
00:31:19 <sohum> cool
00:31:19 <Twey> :t unwords . concat . transpose
00:31:19 <lambdabot> [[String]] -> String
00:31:27 <Twey> :t unwords $ concat $ transpose
00:31:28 <lambdabot>     Couldn't match expected type `[[a]]'
00:31:28 <lambdabot>            against inferred type `[[a1]] -> [[a1]]'
00:31:28 <lambdabot>     In the second argument of `($)', namely `transpose'
00:31:47 <ski> @type flip
00:31:49 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:31:49 <osaunders> Twey: With those functions they are. I just tried it.
00:31:59 <osaunders> > (unwords.concat.transpose) [["foo", "bar", "till"], ["fighters", "crawl", "dusk"]]
00:32:01 <lambdabot>   "foo fighters bar crawl till dusk"
00:32:04 <osaunders> > unwords $ concat $ transpose [["foo", "bar", "till"], ["fighters", "crawl", "dusk"]]
00:32:06 <lambdabot>   "foo fighters bar crawl till dusk"
00:32:16 <sohum> so app is an arrow from a pair of an arrow from x to y and x, to y.
00:32:20 * sohum nods, kinda
00:32:31 <copumpkin> app is uncurry ($) for any arrow
00:32:46 <copumpkin> well, for any ArrowApply
00:32:56 <sohum> aaaah
00:33:02 <copumpkin> that's what defines its ArrowApplyness
00:33:38 <copumpkin> basically means, I HAZ ARRO THAT TAEK CAT AND GIV DOG, AND I HAZ CAT. I CAN HAZ DOG KTHX?
00:33:40 <ski> @tell Cale you should define `flip :: Functor f => f (a -> b) -> (a -> f b); flip f a = fmap ($ a) f' in Caleskell
00:33:41 <lambdabot> Consider it noted.
00:34:15 <sohum> uncurried application, right
00:34:25 <copumpkin> I prefer my rendition
00:34:29 <sohum> I don't :P
00:34:38 <copumpkin> at least ceiling cat approves
00:34:49 <sohum> :t app
00:34:51 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
00:35:03 <sohum> well, more accurately
00:35:32 <copumpkin> :t app . uncurry app
00:35:34 <lambdabot> forall b b1 b2 b3. ((b2 -> b3 -> (b -> b1, b), b2), b3) -> b1
00:35:42 <Twey> osaunders: That's not the same thing
00:35:50 <sohum> I CAN MAKEZ ARRO FROM BOTH ARRO THAT TAEK CAT AND GIV DOG AND CAT TO DOG
00:35:56 <copumpkin> lol
00:36:55 <copumpkin> :t app . app
00:36:57 <lambdabot> forall b b1 (a :: * -> * -> *) b2. (ArrowApply a, Functor (a (a b2 (b -> b1, b), b2))) => a (a b2 (b -> b1, b), b2) b1
00:37:00 <osaunders> Twey: I know they do different things but those code snippets give the same result.
00:37:03 <Twey> osaunders: ‚Äòfoo . bar . baz $ quux‚Äô (‚Äò(foo . bar . baz) quux‚Äô) is equivalent to ‚Äòfoo $ bar $ baz $ quux‚Äô (‚Äòfoo (bar (baz quux))‚Äô), but ‚Äòfoo . bar . baz‚Äô is not equivalent to ‚Äòfoo $ bar $ baz‚Äô (‚Äòfoo (bar baz)‚Äô)
00:37:24 <copumpkin> interesting quotes
00:38:01 <Twey> osaunders: The preferred form is generally ‚Äòfoo . bar $ baz quux‚Äô
00:38:07 <sohum> :t app . app `ati` \f -> (Prelude..) f
00:38:08 <Twey> Or possibly ‚Äòfoo . bar . baz $ quux‚Äô
00:38:08 <lambdabot>     Precedence parsing error
00:38:09 <lambdabot>         cannot mix `.' [infixr 9] and `ati' [infixl 9] in the same infix expression
00:38:12 <Twey> Depending on whom you ask
00:38:19 <sohum> :t app . app `ati` (\f -> (Prelude..) f)
00:38:21 <lambdabot>     Precedence parsing error
00:38:22 <lambdabot>         cannot mix `.' [infixr 9] and `ati' [infixl 9] in the same infix expression
00:38:39 <Axman6> osaunders: what did you think of it? some of the later lectures are far more relevent to haskell
00:38:41 <sohum> oh, /that/ .
00:38:47 <sohum> :t (app . app) `ati` \f -> (Prelude..) f
00:38:49 <lambdabot> forall b b1 b2. (b2 -> (b -> b1, b), b2) -> b1
00:39:21 <osaunders> Axman6: I thought it was cool and then I thought I should finish LYAH first.
00:39:40 <osaunders> Twey: OK.
00:40:03 <sohum> wait a tcik
00:40:08 <sohum> @pl \f -> k f
00:40:10 <lambdabot> k
00:40:13 <copumpkin> :P
00:40:17 <ski> @tell Cale (hm, `asTypeIn' should probably have low precedence .. like `0')
00:40:18 <lambdabot> Consider it noted.
00:40:23 <sohum> :t (app . app) `ati` (Prelude..)
00:40:25 <lambdabot> forall b b1 b2. (b2 -> (b -> b1, b), b2) -> b1
00:40:32 <sohum> ...that is too creepy
00:40:34 <copumpkin> lol
00:40:49 <sohum> @pl \f -> f x
00:40:51 <lambdabot> ($ x)
00:40:56 <Twey> :t asTypeIn
00:40:57 <lambdabot> forall a b. a -> (a -> b) -> a
00:41:07 <Twey> *headscratch*
00:41:10 <Twey> What does this do?
00:41:17 <osaunders> Is there any Haskell I can write to turn off the big ball of light in the sky? It's really annoying.
00:41:19 <sohum> :t (+) `ati` ($ 4.0)
00:41:21 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:41:29 <ski> @type (+) `asTypeIn` \(+) -> 4 + (4 :: Integer)
00:41:30 <ski> @type (***) `asTypeIn` \(***) -> id *** id
00:41:31 <lambdabot> Integer -> Integer -> Integer
00:41:32 <lambdabot> forall c c'. (c -> c) -> (c' -> c') -> (c, c') -> (c, c')
00:41:34 <ski> Twey : ^
00:41:40 <copumpkin> @let moo = flip id
00:41:41 <lambdabot>  Defined.
00:41:51 <sohum> Twey: ski is awesome and wrote it for us
00:41:55 <copumpkin> @type (***) `moo` \(***) -> id *** id
00:41:58 <lambdabot> forall c c'. (c, c') -> (c, c')
00:42:00 <copumpkin> :P
00:42:07 <copumpkin> I fail
00:42:12 <Twey> *further headscratchings*
00:42:25 <ski> (copumpkin : you'd need a `const', in there, i think)
00:42:34 <copumpkin> ah, probably
00:42:36 <sohum> Twey: it's a way to find the type of a function once it's been applied to something
00:42:39 <dibblego> gah Codec.Archive.Zip is so buggy
00:42:54 <ski> Twey : "what is the instantiation of the type of this function, when used in this expression"
00:43:01 <Twey> Huh.
00:43:05 <Twey> How did you write that?
00:43:16 <ski> > length `asTypeIn` \length -> length "foo"
00:43:18 <lambdabot>   ""->
00:43:18 <lambdabot>    0
00:43:18 <lambdabot>  "a"->
00:43:18 <lambdabot>    1
00:43:18 <lambdabot>  "aa"->
00:43:20 <lambdabot> [7 @more lines]
00:43:30 <Twey> Oh, found it
00:43:35 <Twey> Ha, clever
00:43:37 <sohum> :t length `ati` ($ "foo")
00:43:38 <ski> <ski> @let asTypeIn :: a -> (a -> b) -> a; a `asTypeIn` f = a where _ = f a
00:43:39 <lambdabot> [Char] -> Int
00:43:42 <ski> Twey : ^
00:43:57 <ski> @type length `asTypeIn` \length -> length "foo"  -- sign
00:43:59 <lambdabot> [Char] -> Int
00:44:02 <ski> s/sign/*sigh*/
00:45:22 <trofi> > let a = undefined in length [a]
00:45:24 <lambdabot>   1
00:45:33 <trofi> > let a = (undefined :: !Int) in length [a]
00:45:34 <lambdabot>   Unexpected strictness annotation: !GHC.Types.Int
00:45:44 <ski> @type (***) `asTypeIn` \(***) -> id *** id
00:45:46 <lambdabot> forall c c'. (c -> c) -> (c' -> c') -> (c, c') -> (c, c')
00:45:47 <ski> @type (***) `asTypeIn` \(***) -> id *** id `asTypeOf` \_ -> (False,'c')
00:45:49 <lambdabot> (Bool -> Bool) -> (Char -> Char) -> (Bool, Char) -> (Bool, Char)
00:45:59 <copumpkin> @type length `asTypeIn` ($"foo")  -- sigh
00:46:01 <lambdabot> [Char] -> Int
00:46:04 <sohum> what's asTypeOf?
00:46:10 <ski> (for when you want to constrain the `b' in `asTypeIn :: a -> (a -> b) -> a' further ..)
00:46:14 <ski> @src asTypeOf
00:46:16 <lambdabot> asTypeOf = const
00:46:19 <trofi> > let { a :: !Int;  a = undefined } in length [a]
00:46:19 <ski> @type asTypeOf
00:46:21 <lambdabot>   Unexpected strictness annotation: !GHC.Types.Int
00:46:21 <lambdabot> forall a. a -> a -> a
00:46:31 <ski> sohum : standard `Prelude' function
00:46:56 <sohum> :t asTypeOf 5
00:46:58 <lambdabot> forall t. (Num t) => t -> t
00:47:12 <sohum> oooh, it's a type constrainer
00:47:14 <sohum> right
00:47:24 <ski> > typeOf (undefined `asTypeOf` 'c')
00:47:26 <lambdabot>   Char
00:47:35 <ski> sohum : just like my `asTypeIn' above is
00:47:38 <sohum> right, right
00:47:48 <copumpkin> @let asAppliedTo = \x y -> x `asTypeIn` ($ y)
00:47:50 <lambdabot>  Defined.
00:47:53 <ski> > typeOf (undefined `asTypeIn` \x -> ord x)
00:47:56 <lambdabot>   Char
00:47:59 <copumpkin> :t length `asAppliedTo` "moo"
00:48:01 <lambdabot> [Char] -> Int
00:48:10 <sohum> @let aat = asAppliedTo
00:48:12 <lambdabot>  Defined.
00:48:14 <sohum> :P
00:48:19 * ski grimaces
00:48:26 <copumpkin> :t (***) `asAppliedTo` (+1)
00:48:28 <lambdabot> forall b b' c'. (Num b) => (b -> b) -> (b' -> c') -> (b, b') -> (b, c')
00:48:46 <copumpkin> not quite as general though
00:49:28 <sohum> :t (***) `aat` (+(1::Integer))
00:49:30 <lambdabot> forall b' c'. (Integer -> Integer) -> (b' -> c') -> (Integer, b') -> (Integer, c')
00:49:46 <ski> might be useful as a shorthand, sometimes
00:49:49 <copumpkin> :t loop `aat` ((+1) *** (*3))
00:49:51 <lambdabot> forall b d. (Num b, Num d) => ((b, d) -> (b, d)) -> b -> b
00:49:57 <jkff> :t loop
00:49:59 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
00:50:23 <copumpkin> loop with (***) produces exceptionally uninteresting output
00:51:41 <osaunders> What is asTypeIn, btw?
00:52:04 <ski> <ski> @let asTypeIn :: a -> (a -> b) -> a; a `asTypeIn` f = a where _ = f a
00:52:13 <sohum> osaunders: a type constrainer for a function as used in an expression
00:52:52 <sohum> :t (+) `asTypeIn` \f -> f (4 :: Integer)
00:52:54 <lambdabot> Integer -> Integer -> Integer
00:53:18 <copumpkin> :t (+) `aat` 4
00:53:20 <lambdabot> forall a. (Num a) => a -> a -> a
00:54:53 <osaunders> Jesus this language is so hard.
00:54:56 <copumpkin> :t fmap fmap fmap fmap fmap `aat` const []
00:54:58 <lambdabot> forall a (f :: * -> *) a1 a2. (Functor f) => (a1 -> [a2]) -> (a -> a1) -> f a -> f [a2]
00:55:03 <copumpkin> osaunders: isn't it fun!
00:55:04 <ski> @type (+) `asTypeIn` \(+) -> (4 :: Integer) + 5
00:55:06 <lambdabot> Integer -> Integer -> Integer
00:55:39 <osaunders> copumpkin: It should be.
00:57:35 <ski> the `typeOf (undefined `asTypeIn` \x -> ..x..)' looks like it might be useful
00:57:57 <ski> (or if you replace `typeOf' with any function that takes a similar dummy parameter)
00:58:19 <ski> (s/looks/idiom looks/)
00:59:47 <copumpkin> nice, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html mentions parallel list comprehensions but doesn't say what the LANGUAGE flag for them is
01:00:02 <ski> (the alternative would be to either use `PatternSignatures' (aka `LocallyScopedTypeVariables') and ascribe, or to use `where _ = ..x..' manually (optionally with an ascription))
01:00:22 <dolio> ParallelListComp
01:00:36 <copumpkin> thanks :)
01:00:50 <dolio> Also, you should remember --supported-languages
01:01:19 <toast-opt> ski - wow, that's weird.  you can provide constraints on type using useless where clauses
01:01:23 <toast-opt> hadn't thought of that
01:02:13 <ski> toast-opt : iirc, i've seen that used in places .. possibly some `Arbitrary' instances
01:04:07 <ski> The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.10.4 - 4.17 Flag reference 12.†Language options <http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id472118> also lists the `LANGUAGE's
01:05:08 <ski> @where LANGUAGEs
01:05:09 <lambdabot> I know nothing about languages.
01:05:19 <ski> @where+ LANGUAGE+ http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id472118
01:05:20 <lambdabot> Okay.
01:05:25 <ski> er
01:05:30 <ski> @where+ LANGUAGEs http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id472118
01:05:31 <lambdabot> It is forever etched in my memory.
01:06:34 <ski> @where+ LANGUAGEs command line flag `--supported-languages' and <http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id472118>
01:06:36 <lambdabot> Done.
01:19:43 <ski> would `typeOf :: Typable a => Phantom a -> TypeRep' used as `typeOf (Phantom :: Phantom Foo)' or `typeOf (phantom foo)' where `data Phantom a = Phantom' and `phantom :: a -> Phantom a; phantom _ = Phantom' be a good idea ?
01:19:47 <zong_sharo> Cale: still not get, how uniplate can help me
01:20:24 <ski> (or replace `typeOf' with `cardinality :: Finite a => Phantom a -> Integer', &c.)
01:20:29 <zong_sharo> Cale: i don't need generec traversals, i need mapping from concrete PrimTree structures to BashAst's counterparts
01:22:22 <zong_sharo> like {'simple': {'words': ['make', 'install', 'DESTDIR=/opt'], 'lineno':'1'} -> Simple [Word "make" [], Word "install" [], Word "DESTDIR=/opt", [ASSIGNMENT]] 1 []
01:23:42 <cads> hey is there any way to search for some topic but limit results to things produced only by people in certain communities
01:23:55 * Cyneox re
01:23:56 <ivanm> cads: huh?
01:24:09 <cads> like i wanted to search for a blog about speed reading
01:24:31 <cads> but what came up where those fake spam blogs selling you speed reading stuff
01:25:28 <cads> and suddenly I thought it would be cool if I could find a haskeller researcher's opinion about reading faster, and would bet that some might have blogged about an experience with that
01:25:50 <ivanm> maybe on planet.haskell
01:25:56 <ivanm> but I dont' recall anything about it
01:26:03 <ivanm> @google speed reading haskell
01:26:04 <lambdabot> No Result Found.
01:26:07 <cads> heh, so basically I want to find a blog article on speedreading done by a guy who is also into haskell
01:26:41 <cads> right, the search would have to find a article about speedreading, written by an author who's also written about haskell
01:29:26 <cads> what kinds of symbols do you think we'll see in programming languages as they continuously get developed and reinvented?
01:32:09 <cads> functional languages that encode mathematical notions as letters of the ascii alphabet, though there is unicode ability
01:33:04 <zong_sharo> cads: this is dangerous way: http://www.catonmat.net/blog/secret-perl-operators/#goatse
01:33:08 <ksf> have a look at apl and compare it with perl and haskell, and you see where the trend goes.
01:33:40 <cads> but I think that a couple math formulas and diagrams can represent an algorithm better than noisy looking code
01:34:18 <ksf> I'm in favour of (<=>) = cmp, though.
01:34:47 <zong_sharo> ksf: spaceship operator? again?
01:35:04 <ksf> why not? it's clearly the lessequalgreater operator.
01:36:08 <cads> ‚áî
01:36:19 <ksf> ...it's certainly more mnemonic than $, <$> and <*> combined.
01:36:20 * ski would prefer `>=<' to `<=>'
01:36:37 <ski> (but then i would also prefer `=<' to `<=')
01:37:05 <ksf> the entangled hand of eris, that'd be.
01:37:15 <mux> ski: I think I'm now going to wonder whether it's =< or <= now for the rest of my life. thanks.
01:37:16 <ski> .. why ?
01:37:26 <ski> mux : yw
01:37:44 <ski> (incidentally, Prolog gets it right)
01:37:50 <ksf> because the hand of eris is this: -><- , and she must be moving quite strangely when it looks like >=<.
01:38:01 <ivanm> ski: why is "=<" "right"?
01:38:12 <ivanm> since it's usually pronounced less-than-or-equal-to AFAIK...
01:38:16 <ksf> =< looks awfully sad.
01:38:20 <ski> ivanm : because it doesn't look like an implication arrow
01:38:22 <zong_sharo> ksf: '''A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away'''
01:38:49 <ksf> zong_sharo, that's it. we can ditch `cmp`, then.
01:39:04 <zong_sharo> `compare` works fine for me
01:40:33 <maltem> de Saint-Exup√©ry, or by whom was that again?
01:41:44 <zong_sharo> maltem: yep
01:47:10 <cads> I don't know why we don't raid the unicode symbols
01:48:39 <zong_sharo> i don't see unicode symbols on my keyboard
01:48:55 <zong_sharo> compose is not a solution
01:49:12 <cads> you could use stuff like ‚ßî  ‚ßë  ‚ßê ‚ßé‚ßè ‚ß´  ‚ä≤ ‚ä∞ ‚ä®
01:49:13 <medfly> I don't see any compose key on my keyboard
01:50:55 <ivanm> medfly: it's usually right alt
01:50:58 <ivanm> but you have to enable it
01:51:06 <ivanm> cads: I see a bunch of boxes and a diamond
01:51:07 <ksf> conciseness of notation is overrated, anyway, what matters is the number of concepts on a line, not whether they're spelled `fmap` or <$>
01:51:33 <cads> ivanm, featureless boxes?
01:51:46 <ivanm> yes
01:51:46 <ksf> ...as long as identifiers are sufficiently different to be easy to tell apart, that is.
01:52:51 <zong_sharo> ksf: double it
01:53:09 <ksf> double what?
01:53:23 <cads> ksf, I think good notation lets you remember the semantic domain you're working in and doesn't distract you from it when you're manipulating formulas and such
01:53:26 <ivanm> <<$>>
01:53:27 <ivanm> ;-)
01:53:40 <ksf> cads, so do good identifiers.
01:54:11 <ksf> which have the advantage that your neurons already know how to parse the whole latin alphabet.
01:54:23 <ksf> ...and your muscle memory knows how to type all of it.
01:54:33 <cads> but say for doing calculus, nothing is going to be as comfortable as seeing an integral sign
01:55:47 <ksf> but saf for reading code, you wouldn't even know what to google for if you came across that funny symbol.
01:55:53 <ksf> *say
01:56:09 <quicksilver> can you not google unicode symbols?
01:56:15 <medfly> you can
01:56:26 <cads> hehe,  ‚à´ :: (R ‚Üí R) ‚Üí (R ‚Üí R)
01:56:29 <medfly> it's just a pain in the arse to type
01:56:41 <quicksilver> I seem to have no trouble googling a lambda
01:56:43 <medfly> cads, I suggest a boldy R
01:56:50 <quicksilver> medfly: sure, but you copy-paste it from the code you're reading
01:57:03 <quicksilver> medfly: (to answer ksf's specific issue)
01:57:19 <medfly> I suggest you spend 2 minutes writing code when having to scroll up and copy something to just call another function :|
01:57:25 <cads> set it up as tiny macros
01:57:43 <cads> like pressing alt-. makes a compose
01:57:44 <medfly> the only nice thing would be, if you had an editor, to have some kind of latex like thing
01:58:58 <quicksilver> medfly: sure, to *write* code usefully you need to learn how to use your editor
01:59:11 <quicksilver> medfly: but there are many hundreds of input methods in most decent editors.
02:00:14 <quicksilver> hmm. I dunno if you can google for symbols actually. tensor product (x in circle) didn't match any documents.
02:00:19 <quicksilver> google-- # useless
02:00:38 <HugoDaniel> im having problems with ICU: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5231#a5231
02:00:50 <HugoDaniel> i have it installed by pacman, and i also installed it from source in my system
02:00:56 <HugoDaniel> and yet... i still get these errors
02:00:58 <HugoDaniel> :(
02:02:17 <cads> ‚äó
02:03:08 <cads> http://www.unicode.org/charts/PDF/U2200.pdf
02:04:18 <cads> of course when you're reading something about some process calculus, they have their own wierd symbols that they use to show forks and other primitive operations
02:05:03 <cads> with apl, I think you just had to be devoted to writing code in that, but once you got the language you were very productive
02:05:34 <HugoDaniel> :(
02:05:44 <HugoDaniel> i really dislike this unicode mangling
02:06:25 <HugoDaniel> all i wanted was to do some selects from a database and get the strings right :/
02:07:10 <cads> I dunno, I like giving important operators their own symbol
02:07:53 <cads> even if I have to type the name of the operator, and press tab to complete it
02:17:40 <chellomere> is there any way of reaching 'inner' functions in ghci, for debugging?
02:24:11 <ivanm> chellomere: no
02:24:17 <netinho2lol> hey guys
02:24:17 <ivanm> you'd have to define them at the top level
02:24:35 <chellomere> ivanm, ok, thank you
02:25:36 <netinho2lol> should I use Data.List.nub to check if all elements in a list are equal?
02:25:49 <netinho2lol> because if they are, the returned list is empty
02:26:19 <netinho2lol> and if I input an empty list, it also returns an empty list
02:28:23 <quicksilver> netinho2lol: no.
02:28:33 <netinho2lol> :(
02:28:42 <quicksilver> netinho2lol: try (and $ zipWith (==) lst (tail lst))
02:28:45 <ksf> > nub [1,1,1]
02:28:47 <lambdabot>   [1]
02:28:53 <ksf> that's not empty.
02:29:35 <netinho2lol> "In particular, it keeps only the first occurrence of each element."
02:29:41 <netinho2lol> yeah, it's not empty
02:29:48 <netinho2lol> >_<
02:29:52 <quicksilver> it's still the wrong way though.
02:30:13 <quicksilver> it takes a very long time to discover that long lists with many different elements are not the same
02:30:14 <ski> (or `null list || all (uncurry (==)) (zip lst (tail lst))')
02:30:20 <ksf> @src nub
02:30:20 <lambdabot> nub = nubBy (==)
02:30:26 <ksf> @src nubBy
02:30:26 <lambdabot> nubBy eq []             =  []
02:30:27 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:30:52 <ksf> yep that isn't particularly efficient.
02:31:11 <netinho2lol> this makes a divide to conquer approach? ->  (and $ zipWith (==) lst (tail lst))
02:31:19 <quicksilver> > take 2 $ nub [1..]
02:31:21 <lambdabot>   [1,2]
02:31:23 <ksf> that's O(n)
02:31:30 <quicksilver> actually it's not as bad as I thought
02:31:43 <quicksilver> ksf: no it's not, it bails out on the first unequal element
02:31:54 <quicksilver> ksf: (due to laziness and the definition of and)
02:32:05 <ksf> well yes. so it's O(n/2), which is O(n)
02:32:19 <quicksilver> it's O(n) worst case (if all element are indeed the same)
02:32:28 <quicksilver> but its O(position of first unequal element) if they are not
02:32:49 <quicksilver> which is pretty much the best you can do.
02:32:53 <ksf> which, on average, is at the n/2s position.
02:33:04 <quicksilver> no it's not
02:33:09 <ksf> ...but I was referring to nub, anyway.
02:33:14 <quicksilver> on average the first unequal element is in the 2nd position
02:33:33 <quicksilver> depending what you think 'average' means.
02:33:43 <quicksilver> in most lists the second element is different from the first.
02:34:23 <ksf> my statistics suck, so I won't argue
02:34:42 <ksf> ...but it's still linear compexity.
02:35:24 <endojelly> yap, linear worst case and average case complexity. it's just that in the average case the constant is really low, no?
02:35:56 <endojelly> so in practice it's pretty awesomely good but running time will still increase linearly in the average case
02:36:35 <quicksilver> the statistical analysis is more complex than I care to attempt but my strong instinct is that it is sublinear.
02:36:37 <endojelly> albeit very, very slowly for random lists whose elements are members of a big enough set
02:36:50 <endojelly> quicksilver, well, we could try it out.
02:38:04 <netinho2lol> I wonder if Donald Knuth ever touched on Haskell
02:38:25 <netinho2lol> and I'm not taking in a perverse sense
02:38:39 <endojelly> quicksilver, actually that's a pretty interesting question
02:39:14 * ksf wants "The art of functional programming"
02:43:49 <endojelly> quicksilver, so wait, what was the exact problem? to see if all elements of a list are the same?
02:44:51 <gds> foldl' (==) true       ?
02:46:42 <CalJohn> is it considered good style to use foldl, knowing that GHC will optimise it into foldl'?
02:47:02 <gds> Oh, will ghc do that now?
02:47:18 <quicksilver> endojelly: yes.
02:47:24 * gds may be horribly out of date...
02:47:29 <quicksilver> CalJohn: I think not. The optimizer is fragile.
02:47:37 <quicksilver> CalJohn: say what you mean, if you know that you mean it.
02:48:32 <sohum> there should be a generic fold, which is optimised directly into whichever of foldl or foldr the compiler figures will be faster
02:48:43 <sohum> asserting commutativity, essentially
02:48:52 <Jafet> foldl' isn't always optimal
02:49:50 <CalJohn> sohum: if it's (Monoid a) => [a] that's already possible (but i don't think it happens)
02:49:54 <ivanm> preflex: seen Baughn
02:49:54 <preflex>  Baughn was last seen on #haskell 12 hours and 8 seconds ago, saying: Odd type
02:50:09 <CalJohn> Jafet: when is foldl' not an optimal left fold?
02:50:33 <ivanm> @tell Baughn you seem to have a file ending in ~ in the haskell-mode 2.7 tarball...
02:50:34 <lambdabot> Consider it noted.
02:51:21 <Jafet> Sometimes you want the laziness.
02:51:35 <sohum> hmmm, I wonder...
02:51:45 <sohum> preflex: karma god
02:51:45 <preflex>  god: 3
02:51:50 <sohum> god++
02:51:59 <sohum> preflex: seen sohum
02:51:59 <preflex>  sohum was last seen on #haskell 9 seconds ago, saying: god++
02:52:06 <sohum> preflex: karma god
02:52:06 <preflex>  god: 4
02:52:14 <sohum> cool
02:52:47 * Jafet wonders... commutativeFold
02:53:14 <Jafet> Too unhaskelly, unless one can write a typeclass to assert commutativity
02:53:17 * hackagebot upload: elerea 1.2.0 - A minimalistic FRP library (GergelyPatai)
02:53:18 <Jafet> Or something
02:53:34 <gds> Has anyone ever had the "Binary: Int64 truncated to fit in 32 bit Int    ghc: panic! (the 'impossible' happened)" thing in xmonad?
02:54:06 * gds read in the GHC bugs database that at least one other guy managed to fix it by recompiling everything, but that doesn't seem to be working here...
03:09:37 * hackagebot upload: openssl-createkey 0.1 - Create OpenSSL keypairs. (TaruKarttunen)
03:11:59 <fasta> preflex, karma satan
03:11:59 <preflex>  satan has no karma
03:13:11 <medfly> preflex, karma Haskell
03:13:11 <preflex>  Haskell: 14
03:13:14 <medfly> :)
03:15:59 <zygoloid> preflex: karma chameleon
03:16:00 <preflex>  chameleon: 2
03:16:03 <zygoloid> yay
03:31:47 * hackagebot upload: control-monad-failure 0.5.0 - A class for monads which can fail with an error. (PepeIborra)
03:33:48 * hackagebot upload: control-monad-failure-mtl 0.5.0 - A class for monads which can fail with an error. (PepeIborra)
03:34:25 <Baughn> ivanm: And every other one. Emacs does that when it writes the site-file, overwriting the old one. I keep meaning to fix it, but..
03:34:25 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
03:34:28 <Baughn> @clear
03:34:28 <lambdabot> Messages cleared.
03:34:36 <ivanm> Baughn: heh
03:34:46 <ivanm> how do you make the tarball?
03:34:48 <ivanm> manually?
03:34:55 <Baughn> 'make dist'
03:34:55 <bastian> Does anyone have an idea how to solve this problem ( http://pastie.org/723310 )?
03:35:06 <quicksilver> make dist should always ignore ~ files
03:35:09 <quicksilver> I wonder why it isn't.
03:35:13 <Baughn> quicksilver: It does
03:35:16 <Baughn> But then it /makes/ noe
03:35:17 <Baughn> *one
03:35:30 <ivanm> heh
03:35:51 * Baughn is really enjoying the index feature of latest cabal
03:36:01 <quicksilver> bastian: head y has type "a" not type "IO a"
03:36:02 <Baughn> file://~/.cabal/share/doc/index.html
03:36:29 <ivanm> Baughn: cabal-install or cabal itself?
03:36:40 <Baughn> ivanm: Um. Probably both.
03:36:51 <Baughn> You can't use one without the other anwyay..
03:37:01 <Baughn> Oh, but it works with runghc Setup.hs!
03:37:04 <Baughn> So it's cabal.
03:37:08 <ivanm> 1.6.0.3?
03:37:13 <ivanm> or do you have 1.8?
03:37:25 <Baughn> 1.8.0.1
03:37:33 <ivanm> ahhhhh
03:37:36 <bastian> quicksilver, ah ok. is there a way to lift it to IO?
03:37:38 <Baughn> ivanm: I've been using 6.12-rc2 for a while now
03:37:42 <Baughn> It seems to work very well
03:37:56 <Baughn> ivanm: And, well, linking times are down by 95%
03:38:02 <ivanm> Baughn: when I tried it, some libs I needed failed :(
03:38:12 <ivanm> bastian: liftM ?
03:38:13 <Baughn> Which ones?
03:38:26 <zygoloid> bastian: return :: a -> IO a. But it's not clear you actually want to do that...
03:38:48 <ivanm> Baughn: can't recall...
03:39:11 <Baughn> ivanm: Many things dependin on hsc2hs seem to have broken, such as hsopenssl..
03:39:12 <ivanm> but gtk2hs fails, which means criterion (which I don't actually use...) can't build its fancy graphics support :s
03:39:17 <Baughn> Ahh
03:39:20 <ivanm> yeah, that
03:39:29 <Baughn> hsopenssl is broken by design, though. :P
03:39:40 <Baughn> Well, the binding itself is mediocre, but /openssl/ is kinda broken
03:39:44 <ivanm> heh
03:40:22 <SamB_XP> yes, God knows I've heard enough complaints about pyopenssl ...
03:40:40 <zygoloid> bastian: what are you actually trying to achieve in this function?
03:41:24 <bastian> zygoloid, the list contains results of deterministic calculations... i want to return the first (later an arbitrary)
03:41:38 <SamB_XP> and never mind if SSL itself is broken by design, right ?
03:41:43 <zygoloid> bastian: i /think/ you probably want 'select :: ListT m a -> m a; seelct ndt = do x <- runListT ndt; return (head x)'
03:41:55 <zygoloid> -typo
03:41:55 <Baughn> SamB_XP: Well, I wasn't really using openssl for the ssl
03:42:05 <Baughn> SamB_XP: I was using it for the AES. /Was/.
03:42:08 <SamB_XP> I mean, it's able to establish encrypted sockets well enough, at least ...
03:42:34 <Baughn> And now for a haskell question.
03:42:35 <SamB_XP> ... but the PKS stuff is lame lame lame
03:42:54 <Baughn> Using unsafeIOToST in the strict ST monad, obviously the IO is performed in-order internally to that ST computation.
03:42:56 <quicksilver> bastian: why would you want to lift to IO? thre appears to be no IO involved.
03:43:06 <Baughn> But if I switch that out for the lazy variant, is this still the case?
03:43:47 <Baughn> (I'm using unsafeIOToST repeatedly, not just once)
03:44:03 <bastian> zygoloid, unfortunately i can't change the signature (as it is a requirement of an excercice)
03:44:36 <mmx166mhz> I've problems with cabal install httpd-shed
03:44:48 <mmx166mhz> It doesnt work, as it says ExitFailure1
03:45:16 <Baughn> It probably says something else too.
03:45:32 <zygoloid> bastian: sounds like a silly exercise ;-) but you can inject a value into IO using 'return :: a -> IO a'
03:45:47 <Baughn> return :: Monad m => a -> m a
03:46:10 <zygoloid> bastian: also, when you write "do x <- runList ndt", if runList :: m [a], then x :: [a]
03:46:12 <SamB_XP> hmm, I used to have one of those CPUs ...
03:46:22 <SamB_XP> ... back when I used Windows 95 ...
03:46:45 <mmx166mhz> Can sb help me on installing httpd-shed?
03:47:05 <mmx166mhz> cabal install gives errors (ExitFailure 1), any other possibility?
03:47:20 <SamB_XP> hmm, I'm afraid I can't help -- I can only make a dumb joke and ask you "what color of http-shed?"
03:47:30 <mmx166mhz> -_-
03:47:30 <dcoutts> mmx166mhz: it reports a more detailed error before that
03:47:37 <Baughn> Aand, the answer to my question was "IO isn't reordered". Yay!
03:47:49 <ivanm> Baughn: you sure runhaskell adds to the index? dcoutts says its in cabal-install only...
03:47:57 <mmx166mhz> Ok, lets make a screenshot..
03:48:08 <Baughn> ivanm: ..no, I never actually checked
03:48:13 <dcoutts> mmx166mhz: text and a hpaste would be better
03:48:14 <ivanm> ahhhh
03:48:37 <Baughn> Logic failed me. ;_;
03:48:48 <mmx166mhz> cabal: Error: some packages failed to install:
03:48:48 <mmx166mhz> httpd-shed-0.4 failed during the building phase. The exception was:
03:48:48 <mmx166mhz> exit: ExitFailure 1
03:48:49 * Baughn reads "A Critique of Pure Logic" as punishment
03:48:59 <Baughn> *Pure Reason
03:49:12 <dcoutts> mmx166mhz: yes, you said that. We want a log of the bit before that.
03:49:12 <SamB_XP> yeah, most people don't bother with screenshots of text-based UIs unless they use wierd glyphs like CP 850 or whatever ...
03:49:15 <dcoutts> @hpaste
03:49:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:49:20 <dcoutts> mmx166mhz: ^^^
03:49:36 <SamB_XP> hmm, now I'm wondering what the heck the TSR program is called that you can use to take screenshots of those ...
03:49:58 <Baughn> SamB_XP: ..stop it. You're reminding me. ;_;
03:50:12 <SamB_XP> but it was a really GOOD TSR!
03:50:38 <Baughn> It was STILL A TSR!
03:51:47 <SamB_XP> well, how ELSE are you going to save a GIF file with an exact representation of the screen, even from text mode -- regardless of whatever soft-loaded font you may be using ?
03:52:20 <Baughn> xwd
03:53:08 <SamB_XP> well, okay, sure -- that works IF you can configure either dosemu or dosbox to use the softloaded font, sure ...
03:54:06 <mmx166mhz> http://www.students.science.uu.nl/~3345629/
03:54:40 <SamB_XP> (though I've never been able to get the ZZT Enhancer demos working in anything but actual DOS ...)
03:55:07 <mmx166mhz> If someone can have a look at the screenshot there...?
03:55:34 <SamB_XP> mmx166mhz: you mean, instead of arguing about DOS ?
03:55:40 <SamB_XP> ewwwwww
03:55:43 <SamB_XP> JPEG???!??!
03:55:45 <mmx166mhz> ??????
03:55:50 <mmx166mhz> whats the problem?
03:55:56 <SamB_XP> JPEG is not for text!
03:56:08 <mmx166mhz> so what, just have a look..
03:56:24 <mmx166mhz> I have a problem and hope to resolve it wth ur helps.
03:56:59 <SamB_XP> hmm, I would try to explain how to copy and paste text from a windows console, if only it weren't so darn finicky a process ...
03:57:19 <pozic> How can I profile libraries which are used by an application? That is, only symbols which are defined in the application are shown in the .prof file.
03:57:45 <SamB_XP> mmx166mhz: well ... it looks like the relevant error is the "undefined reference to `getnameinfo'" line
03:57:58 <pozic> SamB_XP: you do Edit -> Mark, select your stuff and press enter.
03:58:18 <pozic> SamB_XP: or you switch to a better console, like Console2.
03:58:24 <SamB_XP> pozic: half the time I mess it up right before the "hit enter" bit
03:58:37 <HugoDaniel> hmm
03:58:44 <pozic> SamB_XP: it is rectangular selection, not line selection.
03:58:45 <SamB_XP> I wish the windows console was actually replacable
03:58:54 <pozic> SamB_XP: it is annoying, because it is different.
03:58:57 <SamB_XP> pozic: oh, that's another thing I hate ...
03:59:07 <HugoDaniel> i just did a cabal update, and when i do a cabal install haxml, it goes and builds haxml 1.13.3, but in hackage there is already version 1.19.7
03:59:10 <HugoDaniel> why is this ?
03:59:18 <pozic> SamB_XP: do you have any idea on my issue?
03:59:20 <HugoDaniel> 1.13.3 is from 2007 :P
03:59:33 <mmx166mhz> Ok, and how can I solve my problem?
03:59:35 <pozic> HugoDaniel: that is by design.
03:59:37 <dcoutts> HugoDaniel: the default recommended version is still 1.13.*
03:59:41 <HugoDaniel> ah ok
03:59:43 <SamB_XP> pozic: you have to rebuild the libraries with moar profiling info
03:59:44 <HugoDaniel> thanks
03:59:49 <SamB_XP> :-(
03:59:54 <pozic> SamB_XP: I already did that.
03:59:54 <dcoutts> HugoDaniel: the package author states that the 1.19 is still experimental
04:00:04 <HugoDaniel> ok ok
04:00:07 <pozic> SamB_XP: that is I have the profiling versions.
04:00:13 <SamB_XP> pozic: I said, with MOAR profiling info
04:00:22 <SamB_XP> I was pretty sure you still had to build them for profiling
04:00:42 <pozic> SamB_XP: MOAR, must have MOAR. I already have _p versions of the _library_.
04:00:56 <SamB_XP> pozic: yes, but you need more COST CENTERS
04:01:09 <mmx166mhz> SamB_XP: Can you explain how to solve my problem.?
04:01:09 <HugoDaniel> im going to install it by downloading haxml from hackage
04:01:11 <HugoDaniel> :P
04:01:27 <pozic> SamB_XP: Doesn't it just take all the top-level identifiers by default?
04:02:11 <SamB_XP> hmm, maybe dcoutts knows ?
04:02:32 <dcoutts> HugoDaniel: oh, no, just do: cabal install 'haxml >= 1.19'
04:02:48 <dcoutts> it's only by default that you get the default version :-)
04:02:54 <dcoutts> you can ask for any version you like
04:03:03 <mmx166mhz> dcoutts, can u provide me with some hints to fix it?
04:03:18 <SamB_XP> mmx166mhz: no, I meant for pozic's issue, sorry
04:03:30 <pozic> mmx166mhz: you didn't even ask a question.
04:03:50 <SamB_XP> pozic: he has a link error message saying...
04:03:51 <mmx166mhz> well: My question is: I wanna cabal install httpd-shed, but it gives an error
04:04:07 <pozic> SamB_XP: my bad.
04:04:08 <SamB_XP> ... "undefined reference to `getnameinfo'"
04:04:20 <dcoutts> right, something is wrong with the network lib it seems
04:04:36 <pozic> mmx166mhz: which platform?
04:04:43 <SamB_XP> pozic: windows
04:04:50 <SamB_XP> I can tell from the screenshot
04:05:26 <SamB_XP> so now I'm trying to find my mingw libs so I can grep them for that function ;-)
04:06:53 <SamB_XP> found my zMinGW ...
04:07:35 <HugoDaniel> thanks dcoutts
04:07:37 <HugoDaniel> :)
04:07:40 <SamB_XP> ... hmm, apparantly libapr.dll contains that string ... probably that doesn't help though ;-)
04:09:22 <pozic> SamB_XP: I think I found my issue already. There is a difference between profiling in Cabal terms and profiling in GHC terms.
04:09:30 <SamB_XP> pozic: hmm?
04:09:43 <SamB_XP> pozic: I still say you should ask dcoutts ;-)
04:09:51 <pozic> SamB_XP: the difference http://hackage.haskell.org/trac/hackage/ticket/200
04:10:09 <pozic> SamB_XP: he would probably just say look at this ticket ;)
04:10:18 <SamB_XP> pozic: well, okay, maybe
04:10:40 <SamB_XP> $ grep -r getnameinfo /cygdrive/c/zMinGW/MinGW/
04:10:40 <SamB_XP> Binary file /cygdrive/c/zMinGW/MinGW/bin/libapr.dll matches
04:10:40 <SamB_XP> sockaddr*,socklen_t,char*,DWORD,
04:10:40 <SamB_XP> Binary file /cygdrive/c/zMinGW/MinGW/lib/libws2_32.a matches
04:10:48 <SamB_XP> er ... what the heck ?
04:11:07 <SamB_XP> oh ... right ... dumb /
04:11:13 <mlesniak> Is there a way to set the number of threads (for semi-implicit parallelism with par and pseq) after the program is started, i.e. not only at the beginning with +RTS -N<threads>
04:13:12 <mmx166mhz> arrghhh, I hate it when I cant even start programming coz i cant get a package installed....:(
04:13:50 <SamB_XP> anyway ... I see that function in header "ws2tcpip.h" and import library "libws2_32.a"
04:14:55 <mmx166mhz> Pleaaase, someone help me!!
04:14:57 <SamB_XP> dcoutts: any tips to mmx166mhz about simple edits he could make to the .cabal file to get this to work, given that info ?
04:15:12 <pozic> SamB_XP: it works.
04:15:28 <Axman6> mmx166mhz: what's the problem?
04:15:40 <dcoutts> SamB_XP: so what is the fix?
04:16:03 <dcoutts> SamB_XP: and why don't all windows users get that?
04:16:12 <pozic> mmx166mhz: if you do stuff involving C libraries on Windows you are bound to have to learn platform specific knowledge. If you use Linux, it will probably work out of the box.
04:16:17 <SamB_XP> dcoutts: hmm, I don't know :-(
04:16:40 <pozic> mmx166mhz: which version of GHC do you use?
04:16:43 <SamB_XP> mmx166mhz: how did you install Haskell ?
04:16:49 <SamB_XP> did you install the Platform ?
04:17:27 <dcoutts> SamB_XP: network already links to libws2_32.a
04:17:36 <SamB_XP> dcoutts: oh :-(
04:17:51 <mmx166mhz> No, I am now installing the platform, it that wouldnt still matter Ill come back;)
04:18:04 <SamB_XP> mmx166mhz: well, what version is it ?
04:18:15 <SamB_XP> now you've got me curious
04:18:33 <mmx166mhz> HaskellPlatform-2009.2.0.2-setpuz.exe
04:18:40 <mmx166mhz> setup
04:18:51 <SamB_XP> I meant, what version did you get that error with ?
04:18:59 <SamB_XP> of GHC?
04:18:59 <mmx166mhz> version of what?
04:19:01 <mmx166mhz> oo
04:19:07 <mmx166mhz> 6.10.4
04:19:27 <dcoutts> mmx166mhz: where are you getting http-shed-0.4 from? it's not on hackage
04:19:38 <mmx166mhz> I guess it is
04:19:57 <dcoutts> it really isn't http://hackage.haskell.org/package/http-shed
04:20:16 <SamB_XP> mmx166mhz: did you download some kind of archive with source code for http-shed in it ?
04:21:28 <dcoutts> mmx166mhz: the version that is on hackage (version 0.1) builds fine for me on windows
04:21:37 <SamB_XP> dcoutts: now I'm wondering what was wrong with his 6.10.4 install -- perhaps the bundled MinGW? -- that it failed like that ...
04:21:47 <poe> what does shed stand for?
04:22:13 <SamB_XP> poe: the thing where you keep your gardening tools ?
04:22:31 <dcoutts> oh, wait http-shed vs httpd-shed
04:23:07 <dcoutts> mmx166mhz: I misread your screenshot, it's httpd-shed
04:23:27 <dcoutts> ok, now I get the same problem
04:23:34 <SamB_XP> dcoutts: I think maybe he's been misquoting the name
04:24:02 <pozic> Are there also stack profiling options?
04:24:08 <pozic> I.e. that show what is overflowing the stack?
04:24:26 <SamB_XP> dcolish: is there a flag to get the linker command line printed ?
04:24:29 <mmx166mhz> Well: Maybe I can make myself clearer if I just give you the actual exercise:
04:24:29 <mmx166mhz> http://www.cs.uu.nl/wiki/pub/FP/Practicum/Wiki.pdf
04:24:30 <SamB_XP> er. dcoutts
04:24:34 <SamB_XP> sorry again, dcolish !
04:24:39 * SamB_XP does that one a lot
04:29:48 <mmx166mhz> I've installed the haskell platform, but it hasnt changed the error message.
04:31:41 <HugoDaniel> allright, Data.Encoding solved all my encoding problems :D
04:31:44 <HugoDaniel> great pkg
04:36:29 <dcoutts> SamB_XP: so if it's supposed to be resolving to the getnameinfo in libws2_32.a then it's wrong
04:36:44 <dcoutts> SamB_XP: since the one in libws2_32.a uses stdcall but the ffi import is ccall
04:36:57 <SamB_XP> dcoutts: ah
04:37:22 <SamB_XP> that actually could cause linker errors with some compilers, not sure about mingw
04:39:20 <dcoutts> SamB_XP: of course, the linker names are wrong
04:39:45 <dcoutts> stdcall is _getnameinfo@28, ccall would be just _getnameinfo
04:44:47 <Beelsebob> anyone remember where that study that found haskell lots faster (even in terms of code speed) than C++ for HPC was?
04:45:36 <Axman6> reddit :\
04:45:56 <HugoDaniel> how do i convert a list of lists of fixed dimension, to a list of tuples ?
04:46:01 <HugoDaniel> is there a simple function to do it ?
04:46:06 <HugoDaniel> or do i have to map ?
04:46:13 <Beelsebob> Axman6: don't suppose you have a link do you?
04:47:31 <Axman6> HugoDaniel: if you know the dimension, then it should be easy enough with map
04:48:01 <quicksilver> map (\[a,b,c,d] -> (a,b,c,d))
04:48:03 <quicksilver> for example.
04:53:18 <mmx166mhz> By the way( for those interested:) I solved my problem by installing Haskell Platform and removing older GHC installation.
04:53:27 <mmx166mhz> Then cabal install worked
04:54:09 <Axman6> hoorah
04:57:32 <dcoutts> mmx166mhz: I bet you're using a different version of network now
04:57:44 <dcoutts> mmx166mhz: what does "ghc-pkg list network" report?
04:59:37 <mmx166mhz> C:/Program Files/Haskell Platform/2009.2.0.2\package.conf:
04:59:37 <mmx166mhz>     network-2.2.1.4
05:01:10 <dcoutts> mmx166mhz: right, previously you were using 2.2.1.2
05:01:53 <dcoutts> and they've fixed the bug
05:02:06 <dcoutts> though it's not obvious that it was fixed deliberately :-)
05:02:14 <dcoutts> @seen tibbe
05:02:14 <lambdabot> Unknown command, try @list
05:28:28 * hackagebot upload: simgi 0.2 - stochastic simulation engine (MarkusDittrich)
05:47:26 <sadache> I have a list a,b,c,d,e,f,g and I want to get it into a 2d 3 columns table like a,d,f | b,e,g | c,_,_
05:48:51 <ivanm> @type splitAt
05:48:52 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:49:05 <ivanm> > splitAt 3 [1..10]
05:49:07 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10])
05:49:30 <ivanm> sadache: ^^ do repeated splitAts
05:49:30 <ivanm> and then transpose it
05:50:46 <pozic> How can I increase the stack ghci can use to run evaluate the expressions?
05:51:04 <pozic> (in the same way as for any other program, I assume?)
05:51:20 <ivanm> *shrug* I'd guess so
05:53:01 <Zao> pozic: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html <- that?
05:53:46 <pozic> Zao: yes, I guess it is just the same for ghci as for any other program.
05:54:18 <pozic> That is, +RTS -K1G should be ok.
05:54:52 <gds> > let gds [] = [] ; gds xs = (take 3 xs) : (gds $ drop 3 xs)  in gds [1..9]
05:54:54 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9]]
05:55:40 <gds> sadache: If you want to split on an index rather than an item, you can do something like that.
05:55:57 <gds> (and then transpose it)
05:56:26 <ivanm> gds: splitAt is better than take and drop ;-)
05:56:54 * gds misreads the splitAt type :)
05:57:14 <Axman6> ivanm: splitAt IS take and drop though ;)
05:57:18 <Axman6> @src splitAt
05:57:18 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:57:24 <ivanm> Axman6: :/
05:57:37 <ivanm> I figured they'd be a bit more efficient than that...
05:57:37 <gds> Well, splitat's more idiomatic then.
05:57:41 <ivanm> s/they'd/it'd/
05:57:49 * gds shrugs
05:57:49 <Axman6> ivanm: laziness
05:57:54 <pozic> ivanm: it is more efficient, AFAIK.
05:57:57 <Axman6> you may only need one half
05:58:05 <pozic> ivanm: this is just the source from the report.
05:58:06 <ivanm> Axman6: true...
05:58:16 <ivanm> pozic: ahhh, yes
05:58:19 <pozic> ivanm: not from any particular implementation.
05:58:46 <pozic> ivanm: and the academic answer is that you cannot see the efficiency on a particular machine from its definition.
05:59:14 <ksf> how would a stack-based monad notation look like?
05:59:21 <ddarius> pozic: You shouldn't need to increase the stack for anything you are evaluating in GHCi.
06:02:32 <zygoloid> > let go = transpose . filter (not . null) . map (take 3 . snd) . filter fst . zip (cycle [True,False,False]) . tails in go [1..9]
06:02:34 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
06:04:51 <zygoloid> ^^ clearly any solution which builds a cyclic list is more idiomatic than one which doesn't ;-)
06:05:30 <zygoloid> i'd also note that none of the solutions so far actually gives the answer sadache wanted
06:06:33 <pozic> ddarius: why not? If for compiled code you need to increase the stack space, you also need it when you want to test the same thing in the interpreter.
06:06:39 <Jafet> @src transpose
06:06:40 <lambdabot> transpose []             = []
06:06:40 <lambdabot> transpose ([]   : xss)   = transpose xss
06:06:40 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:07:51 <sadache> aplitAt won't work
06:08:14 <sadache> when the list mod 3 >0
06:08:40 <zygoloid> sadache: it'll be tricky to do without finding the length of the list first
06:09:05 <Jafet> A list of symbols?
06:09:05 <Jafet> And what is _?
06:09:08 <sadache> my list is a,b,c,d,e,f,g and I want to get it into a 2d 3 columns table like a,d,f | b,e,g | c,_,_ not that second and third columns have only 2 elements
06:09:38 <sadache> _ for empty
06:09:56 <Jafet> What is "empty"?
06:09:56 <Jafet> And what is full?
06:11:01 <sadache>  a,d,f | b,e,g | c,_,_ is a table with 3 columns and 3 rows. The 2nd and 3d columns contain only 2 elements
06:11:44 <Jafet> Round and round.
06:11:44 <Jafet> What is the type signature of such a function?
06:14:02 <zygoloid> Jafet: you have n elements. build a 2D grid with 3 columns with as many complete rows as possible. then fill elements in those rows vertically, left to right
06:15:27 <sadache> zygoloid: exactly
06:16:27 <zygoloid> > let go xs = let l = length xs; (d,m) = (l+2) `divMod` 3; (as,bs') = splitAt d xs; (bs,cs) = splitAt (d - fromEnum (m == 0)) bs' in transpose [as,bs,cs]  in  go [1..7]
06:16:29 <lambdabot>   [[1,4,6],[2,5,7],[3]]
06:16:31 <zygoloid> ^^ something like that.
06:16:46 <zygoloid> i suspect there's a much much nicer approach though.
06:17:20 <MHD> What is the issue?
06:17:21 <ddarius> pozic: You shouldn't need to for compiled code either unless you are handling a massive amount of data at which point you probably shouldn't be using the interpreter, so my statement stands.
06:17:30 <Jafet> The problem itself sounds rather arbitrary, if you put it that way
06:18:37 <zygoloid> Jafet: suppose you're laying out files as the result of ls. you want complete rows. you want the files to read downwards in rows.
06:19:18 <zygoloid> of course 'ls' has a much harder problem since the number of rows depends on the column size which depends on the column contents which depends on how you lay out the elements...
06:20:14 <Jafet> Well, an easy solution to that is to try out all numbers of columns
06:20:37 <sadache> zygoloid: that is exactly my problem and I couldnt find a concise nice solution to this
06:21:52 <zygoloid> Jafet: iirc 'ls' starts with the first row having as many columns as possible (until the first row is full), and repeatedly reduces the column count by one if it finds that layout doesn't work
06:22:21 <Jafet> Typical C programming solution: brute force
06:23:50 <sadache> it really surprises me that there is no nicer solution to such a natural problem... :S
06:24:06 <Jafet> It doesn't strike me as a natural problem...
06:24:41 <MHD> Okay, there's something I dont understand here...
06:26:05 <MHD> How can "(\x -> Just x) >=> (\x -> fmap (+1) x)" have the type "(Num a) => Maybe a -> Maybe a"
06:27:07 <dschoepe> @type (>=>)
06:27:08 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
06:27:09 <fasta> MHD, Maybe is m in the type of >=>
06:27:22 <MHD> I know that
06:27:30 <dschoepe> @type (\x -> Just x) >=> (\x -> fmap (+1) x)
06:27:31 <lambdabot> forall a. (Num a) => Maybe a -> Maybe a
06:27:34 <fasta> MHD, so, it is just following the rules.
06:27:35 <MHD> but the result should be a -> Maybe a
06:27:46 <sadache> i guess if i dont get the answer here i won't get it elsewhere
06:27:47 <MHD> My intuition tells me so
06:27:54 <sadache> thank you anyway guys
06:28:30 <MHD> oh, damn.
06:28:33 <MHD> I got it.
06:29:12 <MHD> :type (\x -> Just x) >=> (\x -> return $ x + 1)
06:29:27 <MHD> @type (\x -> Just x) >=> (\x -> return $ x + 1)
06:29:29 <lambdabot> forall a. (Num a) => a -> Maybe a
06:30:12 <paolino> > let g n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in transpose $ map (g 3) $ transpose $ g 3 $ [1..99]
06:30:14 <lambdabot>   [[[1,4,7],[2,5,8],[3,6,9]],[[10,13,16],[11,14,17],[12,15,18]],[[19,22,25],[...
06:30:59 <paolino> > let g n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in concat $ transpose $ map (g 3) $ transpose $ g 3 $ [1..99]
06:31:01 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9],[10,13,16],[11,14,17],[12,15,18],[19,22,25],[20,23...
06:31:24 <Jafet> > let g n = unfoldr (\xs -> if null xs then Nothing else Just $ splitAt n xs) in concat $ transpose $ map (g 3) $ transpose $ g 3 $ [1..7]
06:31:25 <lambdabot>   [[1,4,7],[2,5],[3,6]]
06:33:02 <paolino> ok, it works only for infinite directories
06:33:19 <sadache> it needs to be  [[1,4,7],[2,5,6],[3]]
06:33:20 <ddarius> \x -> Just x === Just === return (in the Maybe monad)  return >=> m = m forall m.
06:33:21 <Jafet> Don't think so either
06:34:10 <paolino> right, it doesn't work.
06:34:50 <Axman6> ddarius: well, it's supposed to be anyway, right? (assuming you've implemented >>= etc in a sensible way)
06:35:06 <ddarius> Axman6: It is one of the monad laws.
06:35:24 <Axman6> there's nothing stopping you breaking the laws though :)
06:38:25 <MHD> I have two Maybe values and I need to take the one that is a Just, what is the best way to do that?
06:38:33 <Jafet> sadache
06:38:46 <MHD> currently i have "if isJust (x >> y) then y else x"
06:38:47 <sadache> Jafet: yep?
06:39:07 <Jafet> > let go n xs = let g _ [] = []; g n xs = let l = length xs; (d, m) = divMod (l+n-1) n in take d xs : g (n-1) (drop d xs) in transpose $ g n xs in go 3 [1..7]
06:39:09 <lambdabot>   [[1,4,6],[2,5,7],[3]]
06:39:15 <BONUS> > Just 3 `mplus` Just 5
06:39:16 <lambdabot>   Just 3
06:39:16 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
06:39:29 <BONUS> > Nothing`mplus`Just 3
06:39:30 <lambdabot>   Just 3
06:39:44 <MHD> what module is mplus in?
06:39:57 <Jafet> @hoogle mplus
06:39:58 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:40:21 <MHD> cool thx
06:41:04 <zenzike> I'd like to profile my code using ghc -prof -auto, and I get told this: Perhaps you haven't installed the profiling libraries for package `parsec-3.0.1'? What am I doing wrong? Do I really have to profile all the libraries I use too?
06:41:59 <Jafet> sadache, not pretty enough?
06:42:52 <sadache> Jafet: very close :) give me time to understand it :)
06:44:35 <poe> zenzike yes
06:45:26 <vy> How can I map putStrLn over elements of System.Environment.getEnvironment?
06:46:24 <ksf> getEnvironment >>= mapM_ putStrLn
06:46:36 <ksf> :t getEnvironment
06:46:37 <lambdabot> Not in scope: `getEnvironment'
06:46:50 <ksf> ...well, assuming it's IO [String]
06:46:51 <zenzike> poe: thanks. seems a little silly, since I don't care about the performance of external libraries. Is there a way to tell it to ignore external calls to a particular piece of code?
06:46:54 <MHD> this is weirding me out...
06:47:13 <Kim^Walkman> vy: mapM_ print =<< getEnvironment
06:47:27 <Kim^Walkman> ksf: It's a IO [(String, String)]
06:47:51 <ksf> well, but he wanted to map putStrLn over it.
06:47:57 <ksf> so it's not my type error.
06:48:01 <poe> zenzike I don't think so
06:48:45 <zenzike> poe: okay, thanks :)
06:48:51 <vy> ksf: Kim^Walkman: Thanks.
06:51:59 <MHD> It woooooooooooooooooorks!!!
06:58:48 <MHD> My stack base calculator now works.
06:58:52 <MHD> This is awesome
07:05:30 <roconnor> @quote stack-calculator
07:05:31 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:05:59 <roconnor> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
07:06:00 <lambdabot>   5
07:06:43 <zygoloid> that's pretty neat :)
07:07:12 <MHD> How do I convert a float to integer?
07:07:46 <roconnor> MHD: round, ceil, floor, decodeFloat ...
07:07:48 <zygoloid> @type (floor, round)
07:07:50 <lambdabot> forall a b a1 b1. (RealFrac a, Integral b, RealFrac a1, Integral b1) => (a -> b, a1 -> b1)
07:08:02 <zygoloid> roconnor: itym ceiling ;-)
07:08:07 <roconnor> thanks
07:08:15 <zygoloid> that one always trips me up :D
07:08:25 <zygoloid> like, both times i've used it ;-)
07:14:06 * hackagebot upload: chp 1.7.1 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
07:17:12 * MHD is away: autoaway [l(on) p(on)]
07:18:25 <MHD> > let showNum n = if n == round n then show $ round n else show n in showNum 10.0
07:18:27 <lambdabot>   Ambiguous type variable `t' in the constraints:
07:18:27 <lambdabot>    `GHC.Real.RealFrac t'
07:18:27 <lambdabot>   ...
07:18:47 <MHD> What am i doing wrong?
07:19:46 <jix> you should add a type signature to 10.0 because ghc can't figure out what type it is
07:19:54 <jix> it could be a float or a double or some other type
07:20:03 <Botje> MHD: the types of n and round n are not equal.
07:20:12 <jix> Botje: they could be
07:20:46 <jix> wait maybe they don't ...
07:20:51 <Botje> jix: with the standard numeric tower, those two sets are disjoint
07:20:59 <jix> yeah just realized
07:21:50 <jix> MHD: in that case you want to do n == fromIntegral (round n)
07:24:01 <jix> hmm is there something like fmod in haskell?
07:24:27 <jix> ah properFraction makes such things possible
07:24:52 <scree> hmm.  When did HaskellDB get a revamp?
07:24:59 <scree> (but all its backends still don't work)
07:25:22 <MHD> thanks it works now
07:30:11 * hackagebot upload: parallel 2.2.0.0 - Parallel programming library (SimonMarlow)
08:05:46 <birdiee_> If I have a datatype like this data Sudoku = Sudoku { rows :: [[Maybe Int]] } and want to do the same as if I have a [[Maybe Int]] like xs!!1 I know I can reach the [[Maybe Int]] of the sudoku through pattern matching but If I want to do it in the ghci for instance. is that archiveable?
08:06:52 <Jafet> You can express most Haskell code in ghci.
08:07:20 <birdiee_> Jafet how can I do it then?
08:07:20 <Zao> (rows some_sudoku) !! 1   ?
08:07:27 <birdiee_> let me check
08:07:29 <Zao> Or am I commpletely misunderstanding what you want to do?
08:07:51 <birdiee_> thanks! it worked
08:07:55 <Jafet> I have absolutely no idea what birdiee wants to do
08:09:10 <birdiee_> just want to check for an element when I am testing stuff in the ghci
08:09:19 <birdiee_> Zao was right
08:12:03 <nominolo> preflex: seen edwardk
08:12:03 <preflex>  edwardk was last seen on #haskell 7 days, 20 hours, 3 minutes and 38 seconds ago, saying: cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
08:12:41 <Zao> birdiee_: Each field of a constructor like that has a function of the same name to extract the field.
08:12:50 <nominolo> preflex: users
08:13:17 <Zao> birdiee_: In this case, the rows function has the type   Sudoku -> [[Maybe Int]]
08:18:12 <netinho2lol> hey guys
08:18:24 <netinho2lol> does anyone know if you can use the sleep function in Haskell?
08:18:33 <netinho2lol> sleep as in POSIX's sleep
08:19:22 <jix> netinho2lol: there is threadDelay which might be what you want
08:19:57 <netinho2lol> the guys next to me are using it
08:20:05 <netinho2lol> and it works in their version
08:20:06 <Jafet> You import the posix module
08:20:08 <netinho2lol> in mine doesn't
08:20:39 <jix> netinho2lol: have you checked that the time value is in the right unit?
08:21:01 <jix> threadDelay takes microseconds
08:21:43 <netinho2lol> Funk.hs:80:21-25: Not in scope: `sleep'
08:21:49 <netinho2lol> yeah, jix
08:21:57 <netinho2lol> just need it to wait for a second
08:22:53 <netinho2lol> "Suspends the current thread for a given number of microseconds (GHC only)."
08:23:05 <netinho2lol> what if I'm using Hugs?
08:23:11 <quicksilver> don't use Hugs.
08:23:12 <netinho2lol> (I'm not, just asking)
08:23:17 <netinho2lol> :P
08:23:38 <netinho2lol> quicksilver: teachers are teaching haskell with the craft book or the hutton book
08:23:43 <netinho2lol> they both use Hugs
08:25:20 <Jafet> Busy loop on hugs!
08:26:34 <chellomere> my course uses ghci but has the craft book
08:27:07 <chellomere> we don't follow the book very closely tho, the course is based mostly on assignments
08:27:38 <quicksilver> dunno. Maybe the posix sleep works in hugs.
08:31:00 <netinho2lol> quicksilver: sleep only works in ghc, apparently
08:31:12 <netinho2lol> nothing works in hugs
08:31:23 <quicksilver> I doubt that.
08:31:42 <quicksilver> I expect you don't have the library installed, or not correctly installed, or you're not running on a posix system.
08:31:46 <quicksilver> I'm sure hugs supports the FFI.
08:33:47 <netinho2lol> weird
08:33:58 <netinho2lol> quicksilver: both of use are using linux
08:34:05 <netinho2lol> sleep doesn't work in mine
08:34:25 <quicksilver> this conversion is pretty boring.
08:34:25 <PeakerWork> The new cabal-install is failing for me - trying to open random filenames (seems like arbitrary garbage data for a filename) - I had experienced the same problem before when I tried to run a GLUT program
08:34:28 <birdiee_> I have a function with two inputs and the last input I want to check are in a list. so it's like "map (myFunc inputA) [inPutsB]" where I want to get a list of restuls from myFunct using myFunc inputA inputB where inputB is each of the elements from the list [inPutsB]. But it doesn't work, is it even possible?
08:34:33 <quicksilver> did anyone ever tell you NEVER to say "doesn't work?"
08:34:38 <quicksilver> it is a content-free phrase.
08:34:59 <quicksilver> you have to explain what you expected to happen, and exactly what happened.
08:35:18 <PeakerWork> I consistently get:   cabal: <garbage filename here>: openFile: does not exist (No such file or directory)
08:35:59 <dcoutts> PeakerWork: we've never been able to track that down, it seems to happen with the ubuntu ghc and cabal-install and disappears when cabal-install is recompiled from source.
08:36:08 <dcoutts> PeakerWork: let us know if you find any more info
08:36:13 <netinho2lol> fuu
08:36:14 <netinho2lol> okay
08:36:18 <netinho2lol> sleep works in hugs
08:36:20 <netinho2lol> not in ghc
08:36:22 <netinho2lol> >_<
08:36:36 <jmcarthur_work> @hoogle sleep
08:36:37 <lambdabot> No results found
08:36:44 <jmcarthur_work> threadDelay?
08:36:47 <quicksilver> birdiee_: of course it's possible
08:36:51 <netinho2lol> sleep
08:37:19 <PeakerWork> dcoutts: cabal-install was OK. I just reinstalled it with "cabal install cabal-install" because "cabal update" told me to, and then it started happening
08:37:20 <quicksilver> birdiee_: map (myFunc inputA) inPutsB
08:37:55 <PeakerWork> dcoutts: the only Ubuntu haskell packages I have installed are: alex, haskell-mode, hugs, libhugs-*
08:38:09 <dcoutts> PeakerWork: and ghc itself presumably
08:38:16 <PeakerWork> dcoutts: nope, I installed that myself from binaries
08:38:28 <birdiee_> quicksilver that I have done but it says error. inPutsB is a list of tuples and it says that it's a (Integer, Integer) I want where I have (Int, Int) but if I change my function to take (Integer, Integer) it says it wants (Int, Int)
08:38:42 <dcoutts> PeakerWork: well perhaps you'll have a better chance of tracking it down then
08:38:53 <quicksilver> birdiee_: ok but then your problem is nothing to do with lists.
08:39:00 <quicksilver> birdiee_: it's to do with the different between Int and Integer.
08:39:09 <quicksilver> birdiee_: paste the code at hpaste.org I'm sure it's trivial to solve
08:39:16 <PeakerWork> dcoutts: how does one go about debugging such a thing?  "gdb" is not much of an option right?
08:39:40 <dcoutts> PeakerWork: see if it still happens when you rebuild from source, if so start adding debug prints
08:42:43 <birdiee_> quicksilver http://privatepaste.com/1abfe97fce
08:43:00 <birdiee_> I understand that it's because of the !! that cant take an Integer
08:43:13 <birdiee_> so maybe I can do an Integer do and Int where I do !! ?
08:45:30 <quicksilver> birdiee_: why not just use Int everywhere?
08:46:04 <birdiee_> where do I not use Int ?
08:46:17 <quicksilver> in some of the code you didn't paste.
08:48:39 <birdiee_> hm very weird but it worked now when I tried with the real data. But not with the test data that seems to be the same
08:49:31 <quicksilver> you probably accidentally made the test data Integers.
08:49:55 <birdiee_> yeah probaly but works now tho =) thanks
08:50:05 <PeakerWork> dcoutts: recompiled from source - and now "Seg fault"
08:50:30 <dcoutts> PeakerWork: oh great, I'm glad it's reproducible
08:51:00 <dcoutts> PeakerWork: would you mind hpasting the output of ghc-pkg list
08:51:21 <PeakerWork> weird, gdb doesn't catch this properly (instead, issues "cabal: main thread exited (uncaught exception)")
08:51:38 <dcoutts> exciting
08:51:57 <PeakerWork> dcoutts: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5234#a5234
08:53:22 <HugoDaniel> hi
08:53:37 <HugoDaniel> is there a faster function to write strings in files, than "writeFile" ?
08:53:51 <HugoDaniel> my one is taking about 10 minutes do write some 7Mb of text
08:53:53 <PeakerWork> @type Data.ByteString.writeFile
08:54:04 <lambdabot> FilePath -> BSC.ByteString -> IO ()
08:54:14 <HugoDaniel> allright
08:54:22 <gwern> HugoDaniel: by now you should know that whenever you have a problem involving String, the solution is ByteString :)
08:54:35 <HugoDaniel> and wont it be slower to create a bytestring from my 7Mb of [Char] ?
08:54:54 <HugoDaniel> yes, i do know :D i just didn't know that there was a writeFile for ByteStrings
08:54:57 <PeakerWork> 7 million list cons handling taking 10 minutes is still more than 1 minute per 1 million cons, which is weird
08:55:00 <HugoDaniel> i like the stream fusion approarch
08:55:03 <gwern> HugoDaniel: well, presumably you get rid of whatever is producing [Char]. but it might still be faster to convert to ByteString and write
08:55:05 <HugoDaniel> yeh
08:55:11 <HugoDaniel> yes
08:55:17 <HugoDaniel> the bottleneck is in the dump
08:55:56 <kowey> when I run ghc --make Setup (trying to install the Haskell Platform), GHC appears to hang on "Linking ./Setup"
08:55:57 <HugoDaniel> ...hmm or maybe not... i dont know if lazyness has a role in all this
08:56:10 <kowey> but if I run it again, it completes; anybody experienced something like this?
08:56:14 <HugoDaniel> lazyness is great, but bad when i need to know where my code is getting slower
08:56:44 <zenzike> Does anyone know if there's a readFile for ByteString that fails gracefully, ie that has some type IO (Either Error ByteString), rather than bombing out my program if the file I'm reading from doesn't exist?
08:59:08 <zenzike> (I'm using Parsec, which has a parseFromFile :: Parser a -> String -> IO (Either ParseError a), but if the file doesn't exist, it's not a parse error that happens, it's a missing file error, and the whole thing blows up)
08:59:57 <Lemmih> zenzike: How about catching the exception?
09:00:23 <zenzike> exceptions from IO can be caught?
09:00:35 <zenzike> I thought I always had to handle them using an Either?
09:01:00 <Lemmih> zenzike: See Control.Exception.try
09:01:24 <zenzike> thanks Lemmmih
09:01:34 <Lemmih> @type Control.Exception.try
09:01:36 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
09:05:28 <zygoloid> zenzike: parseFromFile is pretty simple iirc; you could probably copy it and change the error handling pretty easily
09:07:47 <zenzike> zygoloid: I think that's what I'll do; it's odd that the Parsec version is so breakable
09:08:24 <zenzike> I would have expected it to put a "File not found" exception in with the rest of its errors
09:08:27 <quicksilver> parseFromFile is just intended as an example wrapper
09:08:30 <quicksilver> AIUI
09:08:53 <quicksilver> it follows the haskell tradition of "let's pretend IO errors can never happen"
09:09:03 <quicksilver> if you want to be sensible, you're expected to avoid it :)
09:09:25 <zenzike> heh, so we all avoid it, and all create our own versions that look pretty much the same?
09:09:37 <zenzike> I wonder if there's something sub-optimal about that  ;)
09:09:59 <quicksilver> it does mean the parsec guys dont' have to release a new version every time the exception handling mechanism changes
09:10:05 <quicksilver> which was twice in the last 18 months :)
09:10:19 <zenzike> eeps. point taken.
09:22:13 <saml> > ["bread", "ham", "egg", "bacon", "lettus", "tomato", "bread"]  -- remove "lettus" and "tomato" without repeating the list
09:22:16 <lambdabot>   ["bread","ham","egg","bacon","lettus","tomato","bread"]
09:24:03 <saml> > filter (\x -> x /= "lettus" && x /= "tomato") ["bread", "ham", "egg", "bacon", "lettus", "tomato", "bread"]
09:24:05 <lambdabot>   ["bread","ham","egg","bacon","bread"]
09:24:24 <quicksilver> > ["bread", "ham", "egg", "bacon", "lettus", "tomato", "bread"] \\ ["lettus","tomato"]
09:24:27 <lambdabot>   ["bread","ham","egg","bacon","bread"]
09:24:28 <ksf> a spealchecker would have done half the word
09:24:29 <quicksilver> ?
09:24:32 <ksf> *work
09:25:11 <jedc> Hi, can someone explain to me why this code fails? http://pastebin.com/d1c7a8714
09:25:18 <birdiee_> I am doing a quickcheck prop where I want an input to never be negative so I put abs before it but it does it anyway. does anyone know why?
09:25:40 <ksf>  jedc, the layout is borked.
09:25:59 <quicksilver> birdiee_: Yes.
09:26:02 <quicksilver> birdiee_: you did it wrong.
09:26:15 <jedc> ksf, what do you mean?
09:26:19 <ksf> all lines belonging to a do have to line up, and where exactly is specified by the first non-whitespace character after the do.
09:26:23 <quicksilver> jedc: "put" should line up with "x"
09:26:28 <quicksilver> (and ditto "return")
09:26:49 <jmcarthur__work> birdiee_, i don't know about earlier versions, but quickcheck 2.1 has a NonNegative newtype just for that
09:26:53 <ksf> http://pastebin.com/m3cde9366
09:27:22 <jedc> ah, thanks a lot ksf and quicksilver
09:27:28 <birdiee_> jmcarthur hm what is the name of that ?
09:27:34 <ksf> and don't use tabs
09:27:35 <jmcarthur__work> NonNegative
09:27:38 <ksf> (just checking)
09:27:58 <jmcarthur__work> so you would have types like NonNegative Int and so on
09:28:43 <ksf> alternatively, you can roll your own generator.
09:29:08 <quicksilver> but it should be possible to use abs
09:29:20 <quicksilver> and it might be interesting for birdiee_ to understand what went wrong with his attempt.
09:29:24 <ksf> ...like always testing things around byte boundaries, and big numbers in general
09:29:29 <quicksilver> there is also the builtin ==> combinator
09:29:29 <birdiee_> jmcarthur It didn't work so I don't probaly have the newest version.
09:29:54 <birdiee_> quicksilver my test prop is like I have prop_abc xs (i, r) = length xs == length (xs !!= (i, r)) where I have tested to insert abs both in the pattern matching and in the expression
09:29:56 <jmcarthur__work> quicksilver, agreed
09:30:26 <jmcarthur__work> birdiee_, show us what it looked like with the abs in the expression
09:30:29 <quicksilver> birdiee_: well you certainly can't put an "abs" in a pattern match
09:30:35 <quicksilver> that sounds like nonsense :)
09:30:45 <quicksilver> functions don't go in pattern matches.
09:30:45 <ksf> you can, with a view pattern.
09:31:10 <birdiee_> ((abs i), r)
09:31:19 <jmcarthur__work> ksf, that's actually an interesting idea for quickcheck properties
09:31:53 <jmcarthur__work> birdiee_, what was the error?
09:32:10 <birdiee_> no error it works but I don't want to check for negative
09:32:14 <ksf> birdiee_, the number must also be smaller than length xs, musn't it?
09:32:36 <birdiee_> ksf I gonna test a bunch of stuff but this is just the first
09:32:40 <roconnor> > @check 0 <= x ==> 0 <= x
09:32:42 <lambdabot>   <no location info>: parse error on input `@'
09:32:46 <roconnor> @check 0 <= x ==> 0 <= x
09:32:47 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:32:48 <lambdabot>                     Test.QuickChe...
09:32:52 <Zao> Use a guard maybe?
09:32:55 <roconnor> @check \x -> 0 <= x ==> 0 <= x
09:32:57 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:32:57 <lambdabot>                     (Test.QuickCh...
09:33:09 <birdiee_> but why don't abs work or how should I put it?
09:33:17 <jmcarthur__work> birdiee_, you just said it worked...
09:33:49 <birdiee_> well no I mean quickcheck inserts nergative numbers
09:33:50 <Zao> omg wtf xs | wtf >= 0 && wtf < length xs = ...
09:34:02 <birdiee_> but my function itself works with negative numbers for the moment :)
09:34:28 <jmcarthur__work> birdiee_, using abs doesn't work?
09:34:28 <roconnor> birdiee_: do \x -> (0 <= n) && (n < length l) ==> <insert your property here>
09:34:46 <jmcarthur__work> in the quickcheck property, i mean
09:34:53 <roconnor> (though using NonNegative would be better thatn (0 <= n))
09:35:09 <birdiee_> jmcarthur no it doesn't when I have it get cases like [-5,8,9,0,4,8,-12,10,-11,-14,-16,12]
09:35:09 <birdiee_> (-5,-7)
09:35:12 <roconnor> birdiee_: in particular learn about ==>
09:35:16 <birdiee_> where -5 should be just 5
09:35:52 <birdiee_> roconnor what does that have to do with abs?
09:36:38 <roconnor> <birdiee_> I am doing a quickcheck prop where I want an input to never be negative so I put abs before it but it does it anyway. does anyone know why?
09:36:45 <roconnor> your question is about nonnegative
09:36:47 <roconnor> not about abs
09:36:57 <roconnor> and (0 <= n) has everything to do with being nonnegative
09:37:08 <birdiee_> hm yeah that is true
09:37:11 <birdiee_> sorry
09:37:12 <birdiee_> thanks
09:37:17 <roconnor> if you really insisit
09:37:18 <birdiee_> been a long day =)
09:37:29 <birdiee_> but it's kinda weird abs doesn't work right?
09:37:41 <jmcarthur__work> what is it actually doing when you use abs?
09:37:43 <roconnor> and (0 <= n) has everything to do with being nonnegative
09:37:48 <roconnor> er
09:38:00 <jmcarthur__work> the parameters will still be negative, but they are converted to positive in the test
09:38:04 <roconnor> you can use \x -> let x' = abs x in <your property using x'?
09:38:16 <birdiee_> it's a function to replace r with the index of i in the xs list
09:38:38 <birdiee_> so I don't want to use a negative index
09:38:43 <jmcarthur__work> birdiee_, if you are looking at the failing test cases, that is because quickcheck is still generating negative numbers, but those are actually converted to positive in the test if you use abs
09:38:49 <birdiee_> therefor I want all index to be positive so I can test it properly
09:39:06 <birdiee_> jmcarthur hm ok I see
09:40:09 <jmcarthur__work> roconnor's suggestion to use preconditions would mean that quickcheck will only run the test when it generates positive numbers, but it would mean have the generated parameters are thrown out
09:40:12 <jmcarthur__work> *half
09:40:18 <roconnor> I suppose \(abs -> x) = <your property>  will also work if you enable view patterns.
09:40:31 <jmcarthur__work> would do the same thing though
09:40:40 <jmcarthur__work> although it's kind of cool
09:40:50 <Cale> hello
09:40:51 <lambdabot> Cale: You have 6 new messages. '/msg lambdabot @messages' to read them.
09:40:57 <jmcarthur__work> 6?!
09:41:13 <roconnor> @tell Cale You have 6 new messages
09:41:14 <lambdabot> Consider it noted.
09:41:19 <Cale> lol
09:41:19 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
09:41:57 <birdiee_> you guys where right abs work
09:42:26 <roconnor> NonNegative is still the best solution
09:42:31 <birdiee_> of course it generates negative numbers but when used the abs function works and make them positive
09:42:32 <roconnor> that requires QuickCheck 2?
09:42:41 <birdiee_> roconnor I didn't have NonNegative
09:42:42 <jmcarthur__work> roconnor, apparently
09:42:50 <birdiee_> so must have an old quickcheck version
09:43:40 <Cale> @undefine
09:43:48 <Cale> :t asTypeIn
09:43:49 <lambdabot> forall a b. a -> (a -> b) -> a
09:44:14 <Cale> :t (***) `asTypeIn` \(***) -> id (***) id
09:44:16 <lambdabot> forall c b' c'. (c -> c) -> (b' -> c') -> (c, b') -> (c, c')
09:45:02 <Cale> :t (.) `asTypeIn` \(.) -> group . sort
09:45:03 <lambdabot> forall a. (Ord a) => ([a] -> [[a]]) -> ([a] -> [a]) -> [a] -> [[a]]
09:45:33 <dancor> nice!
09:46:04 <dancor> :t undefined `asTypeIn` \(.) -> group . sort
09:46:05 <jmcarthur__work> wait, asTypeIn unifies the type of the first parameter with the type of the first parameter of the second parameter?
09:46:06 <lambdabot> forall a a1 b. (Eq a, Ord a1) => ([a] -> [[a]]) -> ([a1] -> [a1]) -> b
09:46:19 <jmcarthur__work> wow, that was probably more confusing than just the type signature...
09:46:38 <Cale> @src asTypeIn
09:46:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:46:40 <Cale> hmm
09:46:43 <dancor> it's useful for arrow stuff
09:46:45 <jmcarthur__work> const?
09:46:54 <dancor> :t first
09:46:55 <HugoDaniel> BS.writeFile "santuniv.txt" $ BS.pack $ show santuniv
09:46:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
09:47:07 <Cale> a `asTypeIn` f = a where _ = f a
09:47:17 <HugoDaniel> that line is taking me 10 minutes do run :/
09:47:21 <saml> > let join s = foldr (\a b ->  a++s++b) ""  in join "," (map (const "butt") (words "a b c"))
09:47:23 <lambdabot>   "butt,butt,butt,"
09:47:32 <saml> how can I elimiate the last "," ?
09:47:50 <jmcarthur__work> :t init
09:47:52 <lambdabot> forall a. [a] -> [a]
09:47:56 <jmcarthur__work> quick and dirty way
09:47:58 <Cale> saml: use intercalate
09:48:03 <Cale> init?
09:48:07 <Cale> oh
09:48:09 <Cale> heh
09:48:10 <saml> > init "adsf"
09:48:12 <lambdabot>   "ads"
09:48:19 <saml> > init "adsf123"
09:48:20 <lambdabot>   "adsf12"
09:48:26 <Cale> > intercalate "," ["here","are","words"]
09:48:27 <lambdabot>   "here,are,words"
09:48:38 <jmcarthur__work> intercalate = mo betta
09:49:11 <dancor> :t first `asTypeIn` \ f -> f id
09:49:12 <jmcarthur__work> saml, btw, join is already an identifier defined in Control.Monad
09:49:12 <lambdabot> forall c d. (c -> c) -> (c, d) -> (c, d)
09:49:33 <saml> jmcarthur__work, ah i see.  thanks Cale
09:50:45 <saml> given a [String], how can I apply f :: String -> String  to only some of elements?
09:50:50 <saml> random elements
09:51:08 <cizra> Randomness is kinda tricky in Haskell.
09:51:41 <saml> i want to replace random words in a string with "butt"
09:51:54 <poe> once you've got hold of a source of randomness it's easy, anso, you can pretend you have one and write your stuff, and then go and get one :)
09:52:02 <ksf> clbuttical?
09:52:05 <saml> and still the sentence makes sense and creates laughter
09:52:15 <saml> and it should rhyme too
09:52:28 <nominolo> I have about 10 Google Wave invites I don't need.  Anyone want one?
09:53:01 <jkff> Me too
09:53:02 <saml> i don't know what is google wave. i log in.. and it's like AOL email
09:53:17 <jmcarthur__work> best description of wave ever
09:53:19 <ksf> you _do_ know that limited access is just a marketing technique to get viral effects going, don't you?
09:54:15 <nominolo> saml: It feels incredibly restricted, because you cannot interoperate with people using email.
09:54:44 <nominolo> It's a completely closed system, and it only works if absolutely everone is on it.
09:54:45 <Cale> > let randomApply gen f = zipWith (\b -> if b < 0.2 then f else id) (randomRs (0,1) gen) in randomApply (mkStdGen 42) (const "butt") (words "here are some words")
09:54:47 <lambdabot>   ["butt","are","some","words"]
09:55:51 <Twey> I'm greatly unsatisfied with this function: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13505#a13505
09:55:58 <Twey> Anyone willing to help me improve it?
09:56:20 <saml> > let randomApply gen f = zipWith (\b -> if b < 0.2 then f else id) (randomRs (0,1) gen);  butt l = intercalate " "  (map (const "butt") (words l)) in butt "hello world"
09:56:21 <lambdabot>   "butt butt"
09:56:30 <nominolo> @unpl (reverse *** reverse) . foldr g ([], []) . reverse
09:56:31 <lambdabot> (\ c -> (reverse *** reverse) (foldr g ([], []) (reverse c)))
09:56:36 <saml> > let randomApply gen f = zipWith (\b -> if b < 0.2 then f else id) (randomRs (0,1) gen);  butt l = intercalate " "  (map (const "butt") (words l)) in butt "hello world i don't like wave"
09:56:38 <nominolo> meh
09:56:38 <lambdabot>   "butt butt butt butt butt butt"
09:56:38 <Cale> intercalate " "  == unwords
09:56:41 <Twey> breakWhere :: (a -> a -> Bool) -> [a] -> ([a], [a]), by the way
09:57:17 <Cale> Twey: What is the function meant to do?
09:57:31 <jmcarthur__work> Twey, so, i assume, break whenever the elements immediately to either side fit the condition?
09:57:34 <Cale> :t break
09:57:36 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:57:39 <Cale> hmm
09:57:42 <daedra> !book
09:57:46 <Twey> Cale: Break the list in two between the first two elements for which f returns False
09:57:55 <saml> > let randomApply gen f = zipWith (\b -> if b < 0.2 then f else id) (randomRs (0,1) gen);  butt l = unwords (randomApply (mkStdGen 42) (const "butt") (words l)) in butt "hello world i don't like wave"
09:57:57 <lambdabot>   "butt world i don't like wave"
09:58:00 <Twey> Er, or True, perhaps, based on the name
09:58:02 <saml> yay
09:58:04 <daedra> hrm, is there a haskell bot I can poke about books & resources?
09:58:05 <Twey> Doesn't really matter
09:58:22 <daedra> ah nevermind I have found the wiki
09:58:32 <Cale> daedra: you don't need a bot, just ask :)
09:58:34 <Twey> (first two adjacent elements, that is)
09:59:17 <Cale> > zip <*> (tail . cycle) $ [1,2,3,4,5]
09:59:19 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,1)]
09:59:27 <jmcarthur__work> Twey, something like: for some definition of withPrev :: a -> [a] -> [(a, a)], map fst . break (uncurry cond) . liftA2 withPrev head xs
09:59:48 <jmcarthur__work> s/map fst/(map.map) fst/ i think
09:59:54 <Twey> Mm, could be
10:00:32 <jmcarthur__work> s/liftA2 withPrev head xs/liftA2 withPrev head tail/
10:00:32 <Cale> > (\f xs -> break (uncurry f) (zip <*> (tail . cycle)) (\x y -> even x && odd y) [1,2,3,4,5]
10:00:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:00:37 <Cale> er
10:01:43 <jmcarthur__work> :t \x xs -> zip (x:xs) xs
10:01:45 <lambdabot> forall a. a -> [a] -> [(a, a)]
10:01:50 <Cale> > (\f xs -> break (uncurry f) . (zip <*> (tail . cycle)) $ xs) (\x y -> even x && odd y) [1,2,3,4,5]
10:01:52 <lambdabot>   ([(1,2)],[(2,3),(3,4),(4,5),(5,1)])
10:02:16 <Cale> > (\f -> (map fst *** map fst) . break (uncurry f) . (zip <*> (tail . cycle))) (\x y -> even x && odd y) [1,2,3,4,5]
10:02:17 <lambdabot>   ([1],[2,3,4,5])
10:02:42 <Cale> ah, hmm
10:02:53 <Twey> Hm, that's pretty nice
10:03:13 <Cale> But not quite right
10:04:15 <Cale> (It breaks one position too soon)
10:06:13 <Twey> Hm
10:07:39 <jmcarthur__work> > (\f -> (uncurry (:) . (head *** id) . unzip *** init . snd . unzip) . break (uncurry f) . (zip <*> (tail . cycle))) (\x y -> even x && odd y) [1,2,3,4,5]
10:07:41 <lambdabot>   ([1,2],[3,4,5])
10:07:45 <jmcarthur__work> not so pretty
10:08:23 <jmcarthur__work> > (\f -> (uncurry (:) . (head *** id) . unzip *** tail . fst . unzip) . break (uncurry f) . (zip <*> (tail . cycle))) (\x y -> even x && odd y) [1,2,3,4,5]
10:08:25 <lambdabot>   ([1,2],[3,4,5])
10:08:29 <jmcarthur__work> slightly better
10:09:40 <Twey> More generally, is there a function designed for this sort of situation?  It's sort of like a fold, but with access to the rest of the list and the option of breaking from it
10:10:17 <jmcarthur__work> @pl \cond xs -> (\f -> (uncurry (:) . (head *** id) . unzip *** tail . fst . unzip) . break (uncurry f) . (zip <*> (tail . cycle))) cond xs
10:10:18 <lambdabot> ((uncurry (:) . (head *** id) . unzip *** tail . fst . unzip) .) . (. (zip <*> (tail . cycle))) . break . uncurry
10:10:34 <Cale> Could it be? A zygohistomorphism?!
10:11:12 * jmcarthur__work is aware of that word's popularity but doesn't know its meaning
10:11:14 <Cale> (probably not, but I think it's one of those)
10:11:23 <Twey> Haha!
10:11:38 <Cale> histo- means that you get access to the *previous* elements in the list
10:11:39 <jmcarthur__work> some sort of *morphism, surely
10:11:41 <zygoloid> > let splitAfter f = second tail . head . snd . break (f . snd) . init . (zip <$> (drop 1 . inits) <*> tails) in splitAfter (\(a:b:_) -> even a && odd b) [1..5]
10:11:43 <lambdabot>   ([1,2],[3,4,5])
10:12:19 <jmcarthur__work> that's nice too
10:13:02 <jmcarthur__work> > tails [1..5]
10:13:03 <Twey> I quite like that
10:13:11 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
10:14:02 <Twey> This function seems to be a tradeoff between tersity and performance.
10:14:17 <jmcarthur__work> i doubt that
10:14:30 <Cale> It's possible that a direct recursive version is actually clearest.
10:14:49 <copumpkin> NEVER!
10:14:50 <zygoloid> i wonder whether a zipper-style function might be clearer
10:14:54 <Cale> But somehow that seems wrong :)
10:15:17 <Twey> jmcarthur__work: first f = f *** id, surely?
10:15:30 <copumpkin> Twey: *** is actually defined in terms of first
10:15:39 <jmcarthur__work> Twey, sounds about right
10:15:51 <Twey> copumpkin: Well, yes, but :√æ
10:16:07 <jmcarthur__work> that was an artifact of previous attempts
10:16:15 <Twey> Aha
10:18:19 <Twey> My direct-recursive, with only one reverse: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13505#a13506
10:19:05 <zygoloid> > let splitAfter f (a:b:xs) | f a b = ([a],b:xs); splitAfter f (x:xs) = first (x:) (splitAfter f xs); splitAfter _ [] = ([],[]) in splitAfter (\a b -> even a && odd b) [1..5]
10:19:07 <lambdabot>   ([1,2],[3,4,5])
10:19:16 <zygoloid> ^^ this has the advantage that i was able to type it out and get it right first time
10:19:30 <Twey> :-D
10:19:30 <Twey> Nice.
10:19:36 * zygoloid waits for someone to foldr it
10:19:48 <Twey> It doesn't foldr nicely
10:19:53 <Twey> That was what I started with :√æ
10:20:02 <copumpkin> you need a paramorphism!
10:21:06 <Twey> Strangely hard to find information on
10:21:14 <Twey> Does look right, though‚Ä¶
10:21:57 <Cale> hmm, maybe we just need one more aztec god
10:22:02 <cizra> Twey: Some tutorial thought that _everything_ foldrs nicely..?
10:22:41 <Twey> cizra: For a liberal definition of ‚Äòeverything‚Äô ;)
10:22:45 <Twey> Well, that said
10:23:01 <Twey> What I had to start with wasn't horrible from a stylistic perspective
10:23:07 <Twey> Just from a performance one :√æ
10:24:31 <Cale> Twey: zygoloid's version is probably efficient enough :)
10:24:50 <Twey> True that
10:25:13 <Cale> @let aztec = zip`ap`tail
10:25:15 <lambdabot>  Defined.
10:25:18 <Twey> Haha
10:25:26 <copumpkin> I was just playing with that
10:25:35 <copumpkin> but the best I could do is still ugly
10:25:36 <PeakerWork> is there an IO debugger that can step through IO's actions?
10:25:54 * Twey used Debug.Trace today!
10:25:58 * Twey feels proud.
10:26:15 <ksf> zip`ap`tail is painfully elegant. even if zipWith f `ap` tail doesn't look as good.
10:26:16 <Cale> copumpkin: yeah, I have something where all the elements end up in the right place, but squishing them out of the pairs in the right way is really awkward
10:27:05 <Cale> oh, hmm
10:27:31 <copumpkin> the other issue is that most of the time you just want the fst of the pair
10:27:31 <jmcarthur__work> i almost have it, but i have a situation where i need to turn [[1,2],[2,3]] into [1,2,3] and can't find an elegant way
10:27:34 <copumpkin> except for the last pair
10:27:39 * ksf thinks it should be a standard Data.List function: zipaptail :: (a -> a -> b) -> [a] -> [b] 
10:27:43 <jmcarthur__work> exactly
10:27:53 <Cale> @let aztec' = zip <*> (tail . cycle)
10:27:54 <lambdabot>  Defined.
10:28:08 <Cale> > aztec' . aztec' $ [1..5]
10:28:10 <lambdabot>   [((1,2),(2,3)),((2,3),(3,4)),((3,4),(4,5)),((4,5),(5,1)),((5,1),(1,2))]
10:28:40 <Cale> > break (\((x,y),_) -> even x && odd y) . aztec' . aztec' $ [1..5]
10:28:42 <lambdabot>   ([((1,2),(2,3))],[((2,3),(3,4)),((3,4),(4,5)),((4,5),(5,1)),((5,1),(1,2))])
10:28:52 <Cale> > second tail . break (\((x,y),_) -> even x && odd y) . aztec' . aztec' $ [1..5]
10:28:54 <lambdabot>   ([((1,2),(2,3))],[((3,4),(4,5)),((4,5),(5,1)),((5,1),(1,2))])
10:29:32 <Cale> now we just need a way to flatten pairs of pairs ;)
10:29:45 <Cale> perhaps I should be using the aztec god of transposition instead ;)
10:29:50 <ksf> we should have sane language-level support for heterogenous lists
10:30:03 <ksf> ...and get rid of modules and use records instead.
10:30:34 <Cale> erm, hmm
10:30:35 <ksf> a bit of well-designed OO won't hurt haskell
10:30:46 <copumpkin> really?
10:30:49 <Cale> nah, this isn't so uniform as I thought
10:30:49 <tommd> owch
10:31:12 <PeakerWork> Can IO exceptions carry some traceback?
10:31:22 <PeakerWork> I really miss Python's "post mortem" here... :(
10:31:23 <Cale> PeakerWork: What do you mean?
10:31:39 * ksf really likes explicit self references and constructing objects via fixpoints
10:31:47 <PeakerWork> Cale: I installed a new cabal-install and now I get an IO exception from somewhere deep inside it, and I don't know where. Not sure how to debug this effectively
10:31:49 <chellomere> give context about where they occurred
10:32:23 <PeakerWork> Cale: It would be nice to have a line-traceback of the IO exception -- where the IO came from, in source code context
10:32:30 <Cale> PeakerWork: hmm... Well, if you build it with profiling *sometimes* +RTS -xc is useful
10:32:34 <jmcarthur__work> :t liftA2 (++) fst (pure . head . snd) &&& tail . snd
10:32:36 <lambdabot> forall (f :: * -> *) a. (Monoid (f a), Applicative f) => (f a, [a]) -> (f a, [a])
10:32:58 <jmcarthur__work> not elegant, but works...
10:32:59 <Cale> PeakerWork: That'll give you a terse sort of "cost centre trace"
10:33:19 <jmcarthur__work> > liftA2 (++) fst (pure . head . snd) &&& tail . snd $ ([1,2,3],[4,5,6])
10:33:21 <lambdabot>   ([1,2,3,4],[5,6])
10:33:39 <jmcarthur__work> would rather avoid having to do that at all though
10:34:13 <PeakerWork> Cale: can't find -x in the RTS manpage
10:34:15 <Cale> PeakerWork: It's true that for IO exceptions we could probably have something a lot saner, but for exceptions thrown from pure code, usually you'd end up with information about the place which caused the value containing the exception to be evaluated, rather than where the exception was constructes.
10:34:19 <Cale> constructed*
10:34:24 <Cale> -xc
10:34:39 <PeakerWork> Cale: can't find -x<anything>
10:34:39 <Cale> PeakerWork: That's a runtime system option to be passed to your program
10:34:43 <Cale> not to ghc
10:34:50 <PeakerWork> Cale: Yeah, I'm looking at ghc +RTS -help
10:35:01 <mun> hi
10:35:13 <zygoloid> > let splitAfter f = fst . foldr (\b (init,(search,done)) -> (first (b:) (search b), (\a -> if f a b then ([], b:done) else first (b:) (search b), b:done))) (([],[]),(const ([],[]),[])) in splitAfter (\a b -> even a && odd b) [1..5]
10:35:15 <lambdabot>   ([1,2],[3,4,5])
10:35:18 <zygoloid> hooray, it's a foldr
10:35:19 <PeakerWork> Cale: In IO it could be just as sane as Python tracebacks, yeah
10:36:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-profiling
10:36:15 <Cale> It's documented there
10:36:27 <Cale>  -xc
10:36:27 <Cale>     (Only available when the program is compiled for profiling.) When an exception is raised in the program, this option causes the current cost-centre-stack to be dumped to stderr.
10:36:43 <lrmf> Hi #haskell, is there any way to serialize functions (e.g. Int -> Int)? I can serialize a type like Int or Double, but can one serialize a function?
10:36:55 <Cale> lrmf: Not really.
10:37:06 <Botje> lrmf: there are approaches (mobile haskell) but generally it's not advised.
10:37:29 <Botje> any reason why you need to do this?
10:37:37 <camio> lrmf: Do you want a serialize method for all functions or for a particular subset?
10:37:43 <Cale> lrmf: It would be awfully nice, and it's theoretically doable, but technically difficult to build a system where programs run efficiently and yet it's still possible to serialise arbitrary functions in a portable way.
10:37:44 <PeakerWork> Cale: Ah, cool, I don't have it in ghc +RTS -help   maybe because my ghc is not compiled with profiling support
10:37:45 <jmcarthur__work> lrmf, the only way i know of is to create an interpreted language as a DSL which you can serialize
10:37:48 <lrmf> just Int -> Int would be fine
10:38:15 <lrmf> yeah, i thought of DSL's but that would be a lot of work
10:38:16 <Cale> PeakerWork: right
10:38:29 <Cale> PeakerWork: +RTS -help only shows the options available for that program
10:38:34 <jmcarthur__work> lrmf, and for certain kinds of functions like (small enough) maps you could use IntMap or something
10:38:37 <PeakerWork> Cale: where's a complete manpage?
10:38:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-profiling
10:38:59 <PeakerWork> how do I compile a package without cabal-install with profiling support?
10:39:18 <jmcarthur__work> -prof
10:39:25 <Cale> -prof -auto-all
10:39:40 <dancor> http://book.realworldhaskell.org/read/profiling-and-optimization.html
10:39:45 <PeakerWork> thanks
10:39:56 <Cale> (If you do it without the -auto-all, you'd have to put in your own cost-centres by hand)
10:40:04 <camio> lrmf: I wonder what the use case is. By writing a function in haskell, you've written a serialization of the function.
10:40:22 <Cale> camio: Not once the function has been partially applied
10:40:26 <lrmf> I would really like to have a function which dynamically evolves, for example for AI in a game. I can easilly store a game state composed of simple types , but not of functions :-(
10:41:01 <Cale> camio: It would be nice to be able to partially apply a function, and serialise the resulting function, which would remember all the parameters it had been applied to.
10:41:09 <dancor> you could store a list of tokens and use hint
10:41:18 <dancor> you could use a simpler lang
10:41:35 <Cale> Also, if the function had been evaluated somewhat and contained a memo table, to save that memo table.
10:41:58 <camio> Cale: Are you thinking of a case where IO changes the function you wish to store?
10:41:58 <zygoloid> > let splitAfter (!) =   fst.foldr(\b(_,(s,d))->let r=first(b:)(s b);q=b:d in(r,(\a->[r,([],q)]!!fromEnum(a!b),q)))(e,(\a->e,[]));e=([],[])   in splitAfter (\a b -> even a && odd b) [1..5]
10:42:00 <lambdabot>   ([1,2],[3,4,5])
10:42:10 <zygoloid> there we go, readable *and* efficient
10:42:17 <zygoloid> fusible, even
10:42:20 <Cale> camio: Sure, or you wish to suspend the execution of a long computation and resume it later.
10:42:23 <dancor> lrmf: it's not that hard to make a DSL for a small turing complete lang..
10:42:43 <dancor> wouldn't want to reinvent compiler optimizations tho!
10:42:43 <chrisdone> sup
10:42:47 <Cale> camio: Or pass a partially-worked-on value across the network to another machine to potentially continue evaluation
10:43:20 <birdiee_> maybe you answered this before but If so I didn't quite get it. how can I most easily tell quickcheck that for example some of the input can't be bigger then something, non negative etc. For the negative thing I did abs which works but If I don't want quickcheck to produce negative numbers from the start or that the biggest number should be like the length of the list. Someone wrote some lambdas but where should I put them?
10:43:33 <zygoloid> @pl \b(_,(s,d))->let r=first(b:)(s b);q=b:d in(r,(\a->[r,([],q)]!!fromEnum(a!b),q))
10:43:36 <Cale> Like, let's say you have an infinite list, wouldn't it be nice to be able to serialise it in its current state of evaluation without forcing any more elements?
10:43:36 <jmcarthur__work> birdiee_, ==>
10:43:37 <lambdabot> (. snd) . flip ap snd . (. fst) . ap ((.) . flip . ap ((.) . flip . liftM2 (.) (,) . flip flip id . ((ap . ((,) .)) .) . flip (flip . (((.) . (!!)) .) . (. (return . (,) [])) . (:)) . (fromEnum .) .
10:43:37 <lambdabot> flip (!)) (:)) (ap ((.) . first . (:)) (flip id))
10:43:37 <lambdabot> optimization suspended, use @pl-resume to continue.
10:43:49 <jmcarthur__work> birdiee_, cond ==> test
10:43:52 <camio> Cale: Hrm, it seems like a partially-worked-on/suspend feature would be orthogonal to function serialization.
10:44:02 <dancor> Cale: but you might need more network io in the future to eval the elements later?
10:44:05 <Cale> camio: Well, the same things make both hard.
10:44:19 <lrmf> there is a scheme implementation with a serializable continuations, I hoped that there is something similar in haskell
10:45:03 <Cale> You could walk along through the code graph, slurping up all the nodes until you get to library-defined functions.
10:45:19 <camio> Cale: You probably know more about implementing them than I. I agree that suspended computations would be nifty. Especially in a distributed computing context.
10:45:49 <birdiee_> jmcarthur Oh now WI get it! modifies the inputs before the expression is evaluate cool :)
10:45:51 <dancor> Cale: what does library-defined mean exactly
10:45:58 <Cale> But portability becomes an issue. In the ideal case, you could even pass functions/suspensions between two different programs.
10:46:06 <Cale> dancor: exactly.
10:46:09 * camio is reminded of NES emulators.
10:46:10 <jmcarthur__work> i don't remember why, but i remember i once wished i could serialize functions with Happstack
10:46:21 <dancor> some whitelist of things-both-environments-have i guess
10:46:29 <voidpointer> do you know some free ebook to download and introduce a newbie to the haskell language ?
10:46:50 <Cale> voidpointer: There's RWH
10:46:59 <zygoloid> voidpointer: there's LYAH
10:46:59 <Cale> voidpointer: and LYAH, a good tutorial
10:47:01 <Cale> @where rwh
10:47:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:47:04 <Cale> @where lyah
10:47:05 <lambdabot> http://www.learnyouahaskell.com/
10:47:13 <Cale> @where wikibook
10:47:14 <lambdabot> http://en.wikibooks.org/wiki/Haskell
10:47:16 <PeakerWork> compiling something with profiling support is a dependency hell
10:47:16 <voidpointer> thank's a lot =]
10:47:18 <Cale> @where yaht
10:47:19 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:47:28 <dancor> PeakerWork: yep
10:47:38 <ezyang> I finally got around to rereading semantic editor combinators, and it makes a good deal of sense except my intuition wants the combinators to be composed backwards >.>
10:48:01 <jmcarthur__work> ezyang, my intuition never can decide on the order
10:48:17 <Cale> You're talking about conal's thing?
10:48:35 <ezyang> Cale: ya
10:48:52 <ezyang> http://conal.net/blog/posts/semantic-editor-combinators/
10:49:39 <lrmf> Thanks for your ideas. Is there a searchable online archive of #haskell logs ?
10:49:43 <Cale> hmm... the order makes sense to me. It's the order in which the fmaps would be applied to lift the function
10:49:46 <zygoloid> ezyang: i find the combinator is almost always fmap anyway, so it doesn't matter :-)
10:49:57 <zygoloid> lrmf: see topic. http://tunes.org/~nef/logs/haskell/
10:50:18 <conal> ezyang: may help if you read the SEC list as a path through the overall type to the component type being edited
10:50:45 <eldragon> the initial purpose of Haskell was unifying the lazy functional programming, the final purpose lies.
10:50:48 <lrmf> zygloid: is there a working searchable archive?
10:51:12 <ezyang> conal: Yeah, I understand the "new intuition" you introduce. I'm just trying to combine it with my classical understanding of (.)
10:51:40 <conal> ezyang: yeah.  it's a funny switcheroo.
10:53:26 <c0n5pir4cy> HEy
10:53:56 <c0n5pir4cy> can anybody tell me how to define quality bi custom datatypes
10:54:06 <ezyang> I think what I want is to do the type composition together with a consistent set of type variables
10:54:45 <c0n5pir4cy> like Circle a == Circle b
10:55:04 <c0n5pir4cy> where both have a value that has to be compared
10:55:38 <ezyang> whoaaa, that's kind of magical
10:55:57 <c0n5pir4cy> whats kind of magical?
10:56:06 <dancor> lrmf: how would you dynamically evolve your functions anyway
10:56:15 <dancor> haskell's syntax is pretty non-trivial
10:56:29 <c0n5pir4cy> yep =/
10:56:50 <ezyang> c0n5pir4cy: was referring to conal's semantic editor combinators
10:56:51 <camio> c0n5pir4cy: Can you elaborate on your bi custom datatypes? I don't follow your example.
10:57:28 <lrmf> dancor: you can do this with 'if' for example
10:57:42 <conal> any sufficiently advanced programming technique is indistinguishable from magic.
10:58:09 <c0n5pir4cy> well, i want to compare 2 circles
10:58:24 <c0n5pir4cy> each type has one value, a radius
10:58:27 <MoALTz> conal: i don't know about that. there is some pretty hacky stuff out there that somehow works as if by magic...
10:58:27 <jmcarthur__work> conal, i don't think i like that quote
10:58:41 <c0n5pir4cy> i have to compare the radius
10:59:00 <c0n5pir4cy> I can use Circle == Circle = True
10:59:01 <jmcarthur__work> why can't the most advanced techniques be the simplest to understand?
10:59:17 <c0n5pir4cy> to test the circle without the variable
10:59:50 <shambler> jmcarthur__work, cuz more advanced means more abstract
10:59:55 <jmcarthur__work> c0n5pir4cy, something like Circle a == Circle b = a == b ?
10:59:56 <c0n5pir4cy> but i can't find any reference on how to do that and keep the values
10:59:57 <monochrom> jmcarthur__work that is not a refutation. some magics are the simplest to understand.
10:59:59 <ezyang> c0n5pir4cy: If the type is really simple, you might be able to derive it
11:00:08 <ezyang> Otherwise define an Eq instance or something
11:00:33 <c0n5pir4cy> instance Eq Circle Where?
11:00:41 <c0n5pir4cy> *where
11:00:44 <ezyang> @hoogle Eq
11:00:44 <lambdabot> module Data.Eq
11:00:45 <lambdabot> Prelude class Eq a
11:00:45 <lambdabot> Data.Eq class Eq a
11:00:48 <dancor> c0n5pir4cy: like this? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5236#a5236
11:01:10 <ezyang> uh, lambdabot, you were not very helpful :-(
11:01:12 <conal> jmcarthur__work: perhaps then they're simplicity magic.  and the magic-ness dissolves as enlightenment arrives.
11:01:23 <jmcarthur__work> shambler, i thought "more advanced" meant something closer to "more evolved"
11:01:28 <birdiee_> jmcarthur so if my input " i " in my prop most be greater then 0 and that it should not be greater or equal to the length of a list which is another input. I tried i ==> 0 < i && i <= length xs but that didn't go so well =) do I must use lambdas?
11:01:36 <c0n5pir4cy> Ahh, that should work
11:01:38 <conal> (the magic-ness is in the perceiver more than the perceived)
11:01:40 <c0n5pir4cy> thanks
11:02:16 <jmcarthur__work> birdiee_, prop_propertyName x y = cond x y ==> property x y
11:02:20 <chrisf> conal: truth.
11:02:33 <c0n5pir4cy> actually, that didn't work
11:03:00 <c0n5pir4cy> its telling me its ambiguous
11:03:13 <c0n5pir4cy> two secs, I'll hpaste my code
11:03:22 <birdiee_> jmcarthur__work where property x y is my expression to check if it's true or false?
11:03:40 <conal> jmcarthur__work: i just put that hijacked quote out there as joke.  no deep thought behind it.
11:04:13 <ezyang> conal: agghh, I can't decide if I want my fmap intuition or my (.) intuition more
11:04:16 <jmcarthur__work> property is the property you are testing, cond is the precondition which must be true for quickcheck to even bother checking the property
11:04:26 <jmcarthur__work> conal, understood
11:04:47 <conal> ezyang: :)
11:05:09 <c0n5pir4cy> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=5237#a5237
11:05:14 <birdiee_> ok gonna test it out
11:06:41 <camio> c0n5pir4cy: are circles equivelant when a==b _or_ when (a<0)&&(b<0)?
11:06:50 <zygoloid> lrmf: try googling for "<something> haskell site:tunes.org"
11:07:08 <camio> c0n5pir4cy: oh wait...
11:07:09 <birdiee_> jmcarthur I got Arguments exhausted after 82 tests. is that because quickcheck couldn't genreate more cases that fitted my condition?
11:07:10 <c0n5pir4cy> both :)
11:07:18 <c0n5pir4cy> well not really
11:07:20 <conal> ezyang: btw, first & second may be a good starting point. the "tangible functional programming" paper shows where this SEC stuff goes when applied in an arrow setting.
11:07:23 <camio> c0n5pir4cy: You need instance Eq Shape.
11:07:42 <ezyang> conal: Oh right. I should look at the first . second case
11:08:15 <c0n5pir4cy> I'm getting an ambiguity error still
11:08:19 <lrmf> zygloid: thanks, that does the trick
11:08:26 <OscarZ> i finally think i understand a little about monads... what would be a good exercise to program that would force me to write a monadic type ?
11:08:28 <c0n5pir4cy> do i need to indent it any
11:08:37 <OscarZ> as simple as possible ;)
11:08:55 <ezyang> OscarZ: Write a simple command line app with the prompt monad
11:09:33 <jmcarthur__work> birdiee_, quickcheck gives up after a while if it cannot generate enough valid parameters for the test, yes
11:09:46 <ezyang> OscarZ: You could also, like, make sure you can derive all of the usual monad instances from scratch.
11:09:49 <jmcarthur__work> birdiee_, this is why newtypes are nice, so you can define your own Arbitrary instances for them
11:09:55 <c0n5pir4cy> ahh, got it working
11:10:07 <jmcarthur__work> birdiee_, one example being that NonNegative type i alluded to
11:10:10 <OscarZ> ezyang: you mean like Maybe etc.. ?
11:10:18 <c0n5pir4cy> stupid mistake :) no indents
11:11:01 <birdiee_> jmcarthur I see. cool thanks alot
11:11:05 <ezyang> OscarZ: Maybe, Writer, Reader, State
11:11:38 <ezyang> OscarZ: RWS, ErrorT, Cont if you're feeling particularly masochistic
11:11:50 <PeakerWork> dcoutts: when I recompiled Cabal from source -- and then rebuilt cabal-install - the program disappeared
11:12:05 <conal> jmcarthur__work: perhaps simplicity could be called "deep magic", and complexity "shallow magic".  in that getting to simplicity requires struggling to a deeper understanding, while complexity gets by with hacking around at the surface.
11:12:30 <ezyang> conal: Good one. It's something that comes up in obfuscated code contests
11:14:26 <ksf> simplicity requires brain-dead stubbornness, while complexity requires megalomaniac genius.
11:14:39 <ksf> or, actually, masochism.
11:15:21 <Twey> Simplicity lies on the other side of complexity
11:15:23 <conal> "Simplicity is the most difficult thing to secure in this world; it is the last limit of experience and the last effort of genius." -George Sand
11:15:29 <conal> Twey: yeah!
11:15:57 <ksf> have I been claiming anything different?
11:16:02 <Twey> This discussion reminds me of Pascal
11:16:16 <Twey> ‚ÄòI didn't have time to write a short letter, so I wrote you a long one instead‚Äô
11:16:39 <jmcarthur__work> yes i like that one
11:16:46 <ezyang> conal: Aha! The editor combinators specialize the type of the function they're composed with, which is why combinators on the right go deeper
11:16:50 <ezyang> Twey: +1
11:16:59 <ezyang> Twey: although I thought that was Twain?
11:17:09 <ksf> oh, I just today decided that if I ever wrote a mail to knuth, it'd be a long and involved question.
11:17:27 <ksf> I know he hates to be interrupted, so if I interrupt him, it should be for at least a day or so.
11:17:30 <conal> ezyang: attributed to twain, pascal, and voltaire, iirc
11:17:39 * ezyang nods 
11:17:46 <zygoloid> ezyang: the leftmost function in a composition chain happens first, and defines the result. the result in this case is a combinator. so the outermost one is leftmost.
11:17:55 <monochrom> any sufficiently misguided opinion is indistinguishable from deep insight
11:18:08 <conal> monochrom: hah!
11:18:13 <MoALTz> that one is actually quite good
11:18:13 * ksf excommunicates monochrom
11:18:29 <ezyang> "the principle of idiot savant"
11:18:36 <Nafai> It's interesting I used to be in the "dynamic typing only" crowd and now I'm trying to elaborate the advantages of a static typing system like Haskell's
11:18:51 <ezyang> zygoloid: wait really?
11:19:07 <zygoloid> @remember monochrom,ezyang The Principle Of Idiot Savant: any sufficiently misguided opinion is indistinguishable from deep insight
11:19:08 <lambdabot> Okay.
11:19:27 <ksf> "never attribute to genious what can equally well be explained by stupidity"?
11:19:41 <ezyang> zygoloid: With f.g, I've always thought of g operating first, then f operating on the result
11:19:46 <ksf> ...and never spell if you cna speal.
11:19:51 <conal> urg.  i don't think idiot savant has much to do with opions.
11:20:01 <conal> opinions*
11:20:04 <zygoloid> ezyang: in strict languages, sure. in lazy languages, not so much :)
11:20:06 <jmcarthur__work> ezyang, actually, (.) operates first
11:20:22 <ezyang> jmcarthur: well, sure ^^"
11:20:31 <Cale> and then f
11:20:32 <Twey> conal, ezyang: Now that you mention it, it does sound like more of a Twain-y thing to say.
11:20:40 <jmcarthur__work> ezyang, with the exception of infix operators, all functions are evaluated left to right
11:20:57 <ezyang> Nafai: It's what happens when the static typing system suuucks
11:21:06 <jmcarthur__work> ezyang, in f (g x), f is applied to (g x) before g is applied to x
11:21:06 <Nafai> ezyang: I know, I realize that.
11:21:10 <conal> in other words, outside-in.
11:21:16 <ezyang> waaaagh
11:21:26 <Nafai> ezyang: But I'm seeing things like this: http://twitter.com/lazycoder/status/6277606019 and http://twitter.com/blowmage/status/6277563567
11:21:28 * ezyang brain 'splodes 
11:22:28 <ezyang> Nafai: blowmage seems slightly misguided
11:22:48 <Nafai> ezyang: ruby-lover
11:22:50 <Nafai> :)
11:22:56 <ezyang> since "runtime, not compile time" is not the reason I like dynamic typing
11:23:13 <ezyang> All other things equal, anything that I can move to compile time is a plus
11:23:22 <ezyang> just, usually, all other things are not equal
11:23:24 <Twey> They both seem slighly misguided
11:23:29 <birdiee_> does anyone know how to make quickCheck run more tests? It gets exhausted easily when running my props
11:23:30 <conal> static/strong typing being "necessary for safety" sounds hard to to demonstrate.
11:23:46 <ezyang> hup, class is over. Time to run
11:23:58 <conal> ezrakilty: later!
11:23:59 <jmcarthur__work> so many ways to interpret that criteria
11:24:03 <conal> oops
11:24:17 <jmcarthur__work> birdiee_, look up quickCheckWith
11:24:18 <Nafai> I hate runtime vs compile time (especially in the case of something like Python) where you don't discover errors, like typos in variable names, until runtime
11:24:28 <jmcarthur__work> actually, that might be only QC 2.1
11:24:36 <Nafai> And if you have a lot of code, your code could be running a long time before you encounter the error
11:24:57 <lament> thankfully, haskell fixes those issues once and for all. No more run-time errors!
11:25:05 <dancor> of any kind
11:25:08 <jmcarthur__work> Nafai, of course, the dynamic evangelist would promote unit tests as catching all such things
11:25:24 <jmcarthur__work> which if you think about it is a very very weak argument
11:25:31 <Nafai> jmcarthur__work: Of course, and that is what blowmage would tell me
11:25:41 <Nafai> (he's a former coworker)
11:25:59 <Nafai> But I've actually been convinced lately that TDD-type stuff actually works better in Haskell
11:26:06 <birdiee_> jmcarthur ok thanks. but if it gets exhausted after like 3 tests thoose 3 test are enough right? since they forfill my condition and runs okey with my funtion? or should I expand the numbers so that it generates a 100 tests you think?
11:26:09 <Philonous> I've hacked together a little something to serialize functions (Num a => a-> ... -> a) :
11:26:09 <Philonous> serialize (\x y -> (x*y+3)^2 )
11:26:09 <Philonous> ((Var 0 :* Var 1) :+ Lit 3) :* ((Var 0 :* Var 1) :+ Lit 3)
11:26:09 <Philonous> Dunno if this helps at all
11:26:23 <jmcarthur__work> birdiee_, i would not feel comfortable with only 3 tests
11:26:26 <Nafai> If you have the combination of the type system and QuickCheck you are able to do so much more
11:26:28 <Twey> conal: Sounds axiomatically true, to me.  If ‚Äòsafety‚Äô means that no error can occur within the code whilst running, then that means that the code must a) be guaranteed to terminate and b) be 100% type-safe
11:26:39 <jmcarthur__work> birdiee_, i would use some newtypes to make better Arbitrary instances
11:27:01 <jmcarthur__work> Twey, you could construct that proof by hand though. the language needn't be statically typed itself
11:27:24 <jmcarthur__work> sure, it would suck...
11:27:26 <conal> Twey: questionable def of 'safety', though.  the kind that type-nuts like us would use
11:27:35 <birdiee_> jmcarthur ok thnaks
11:27:47 <Twey> Well, he seems to want an absolute definition.
11:27:54 <monochrom> I construct proofs by mechanisms, not exclusively hand.
11:28:07 <dpratt71> I'm using projecteuler.net to get experience with Haskell...
11:28:07 <dancor> what are some forms of safety that exist in other languages but not haskell
11:28:19 <jmcarthur__work> a dynamic language enthusiast might only require recoverablility, not really absence of errors
11:28:23 <dpratt71> ...this is my implementation of problem 1: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5238#a5238
11:28:29 <jmcarthur__work> or some other kind of safety
11:28:41 <dpratt71> how would you change it? syntax, layout, method, etc?
11:29:26 <dpratt71> (I made the implementation somewhat more general than Q1 specifies)
11:29:30 <conal> i like safety through pure functional programming.  since you can't do anything, you can't do anything wrong/harmful.
11:29:56 <copumpkin> unsafePrint
11:30:30 <monochrom> "does not clobber disk" is a safety in xhtml but not haskell
11:30:52 <conal> monochrom: safe in haskell, not in IO
11:31:06 <dancor> is IO not a part of haskell
11:31:10 <monochrom> haskell includes IO. I read the haskell98 report.
11:31:32 <Nafai> Someone here (can't remember who) wrote a page about "what to know before debating type systems"
11:31:34 <conal> monochrom: being IO is haskell.  doing IO isn't.
11:31:37 <jmcarthur__work> does the language definition mandate that putStrLn actually does anything?
11:31:46 <Nafai> Does anyone have a link for that?
11:32:25 <Veinor> oh hey, someone else from my college was in here
11:32:40 <conal> when i say FP, i don't include *execution* of IO.
11:33:04 <jmcarthur__work> i guess the spec does say that IO actions should "do" things
11:33:05 <monochrom> I disagree with that distinction. Ruby programs are typesafe if you don't execute them.
11:33:14 <Twey> @pl \x -> g (f x y) (f x z)
11:33:14 <lambdabot> ap (g . flip f y) (flip f z)
11:33:29 <conal> monochrom: note i said functional programming, not haskell.
11:33:39 <monochrom> But I said haskell.
11:33:56 <monochrom> And I was answering <dancor> what are some forms of safety that exist in other languages but not haskell
11:33:58 <conal> monochrom: so yeah.  we're safe if we don't execute programs, whether ruby or IO.
11:35:17 <monochrom> I answered a question that specifically asked for haskell. I don't understand why you pick on me, except for the possibility that you hate it when I don't prepend my sentences with other people's nicks.
11:35:40 <jmcarthur__work> if you map a ruby program to the abstract actions it performs without executing them you can probably tell whether it's correct or not. that's the same thing that pure haskell is: a mapping from code to actions. the execution of those actions is just something on the side
11:35:52 <camio> What definition are we using for safe? A subjective experience where everything goes as planned?
11:36:18 <conal> monochrom: i don't hate it when you don't nick-prepend.  i'm just more likely to misunderstand you.
11:36:58 <copumpkin> Veinor: you should hook up and engage in passionate haskell sex
11:37:00 <conal> monochrom: oops.  i might have done it again.  assumed your "I answered a question ...." remark was directed at me.
11:37:03 <Veinor> Haha
11:37:12 <conal> monochrom: s/at me/to me/
11:37:21 <Veinor> unsafePerformSex
11:37:40 <conal> Veinor: yeah -- don't do that either.
11:37:50 <Veinor> needs a wrapper?
11:38:21 <jmcarthur__work> safeSex = Protection unsafePerformSex
11:38:51 <camio> I might call that saferSex.
11:39:10 <jmcarthur__work> okay fine
11:39:15 <jmcarthur__work> safeSex = Gay unsafePerformSex
11:39:25 <jmcarthur__work> err
11:39:28 <jmcarthur__work> stds
11:39:31 <jmcarthur__work> i was thinking pregnancy
11:39:41 <Veinor> it still throws an error 1% of the time :/
11:43:43 <birdiee_> jmcarthur if I created a newtype such as this http://privatepaste.com/ac6342a6a7 how can I refer to my condition that I previously had as condition since now I don't have like 0 < i etc..
11:44:09 <conal> monochrom: i re-read and saw your answer to dancor, which i'd thought was to me.  sorry about the static! :(
11:45:04 <jmcarthur__work> birdiee_, you generate an Int with arbitrary, take the absolute value of it, wrap it in MyInt, and return that
11:45:23 <jmcarthur__work> birdiee_, see the implementation of NonNegative
11:45:53 <jmcarthur__work> birdiee_, you can find it in the quickcheck documentation on hackage
11:46:10 <birdiee_> jmcarthur searching for it there
11:46:11 <birdiee_> thanks
11:46:14 <jmcarthur__work> np
11:49:21 <conal> oh, hey.  my irc client says 666 members.
11:49:29 <conal> oops.  now 665
11:49:49 <conal> funny. and i mis-read as "christ left the chat room"
11:50:18 <Nafai> heh
11:51:24 <conal> hm.  there's a lot of whirling confusion/ambiguity around this notion of whether haskell is a purely functional language.
11:51:26 <dpratt71> Twey: I didn't notice your response till just now, thanks; is it possible that my na√Øve implementation is close to perfect, or is it the (more likely) case that you folks are unmotivated or unwilling to be critical? :)
11:54:02 <dpratt71> I'm suddenly reminded of my favorite bumper sticker: Spell checkers aren't worth a shirt!
11:54:08 <conal> so i've come to prefer the term "denotational programming" for what i'm interested in.  and something that haskell is fairly good at when IO is not involved.
11:54:14 <conal> dpratt71: :)
11:54:22 <jmcarthur__work> conal, in absolute time semantics, the mappend of two futures is the later of the two. in your ideas for relative time semantics, do you keep it that way?
11:54:51 <jmcarthur__work> i realize Future is not even really a part of what you wish to expose as actual semantics
11:55:50 <jmcarthur__work> conal, i ask because i find where to use max, min, (+), etc. a bit ambiguous in places
11:56:23 <Twey> dpratt71: It's not half bad
11:56:42 <dpratt71> Twey: thanks; what about the other half? :)
11:57:17 <Kyssan> just learning here.. but what would keep Haskell from being pure?
11:57:32 <Twey> ‚ÄòunsafePerformIO‚Äô?
11:57:38 <Twey> We don't really consider that part of the language, though.
11:58:00 <conal> jmcarthur__work: hm.  applicative & monad use the Sum time monoid.  thinking about mappend.
11:58:28 <conal> jmcarthur__work: (for relative time futures.  btw, absolute time uses min, not max.)
11:58:29 <Saizan_> Kyssan: the fact that it actually executes programs in the end
11:58:42 <jmcarthur__work> conal, oh right, the earlier, not the later. my bad
11:58:57 <Twey> You have to distinguish between the Haskell language (and what the user does in it) and the Haskell implementation/runtime
11:58:58 <conal> jmcarthur__work: (while applicative uses max)
11:59:03 <jmcarthur__work> right
11:59:07 <Twey> The latter is necessarily impure
11:59:13 <Kyssan> :-) well.. the environment can always kill your program
11:59:21 <Twey> Aye
11:59:28 <conal> jmcarthur__work: i guess mappend still uses min.
11:59:36 <Twey> That's not making the program impure, though
11:59:43 <conal> jmcarthur__work: min on relative times, that is.
11:59:49 <jmcarthur__work> conal, the intuition being that two futures are considered both relative to "now"?
11:59:50 <Twey> Someone can call you away for your tea whilst you're working on a maths problem
12:00:08 <Twey> Yet being called away for tea isn't part of the mathematics :√æ
12:00:12 <Kyssan> I'm still trying to wrap my head around how the behaviour of "tail []" is pure
12:00:31 <Twey> Kyssan: It has no side-effects
12:00:52 <Saizan_> Kyssan: you can observe the exception only from IO
12:00:57 <Twey> It just halts execution (of a pure program)
12:01:09 <labreuer> I want to take [(Maybe a, Maybe a)] -> [(Maybe a, a)]; but I'm not sure how to do (Maybe a) -> bool and return true if it's Just a and false if it's Nothing
12:01:16 <labreuer> (haven't done Haskell in a bit)
12:01:31 <PeakerWork> labreuer: You mean   Maybe (a, a)   or (Maybe a, a) ?
12:01:42 <Twey> If you encounter a ‚Äòsolution‚Äô whilst working through your maths problem that can't possibly be right (or no solution at all), you backtrack (impurely) and try again
12:01:42 <labreuer> (I'd like to do this instead of pattern matching -- one line if possible)
12:01:47 <Twey> Or maybe just give up
12:01:53 <Twey> The maths is still pure
12:01:54 <Saizan_> Kyssan: and, anyhow, any type in haskell is also inhabitated by a "bottom" value which represents non-termination, "undefined" is isomorphic to that
12:01:59 <labreuer> PeakerWork: nope, I wrote a self_join function that includes the fringes
12:02:06 <PeakerWork> labreuer: I am not sure exactly what you want to do if you mean what you wrote -- do you want to filter entries whose snd is a Nothing?
12:02:13 <labreuer> yes
12:02:19 <monochrom> I take "haskell is pure functional" the same way I take "c is imperative", "smalltalk is oo". I take them as statements of designed-for-those-paradigms, not as prohibition. "smalltalk is oo" because it's very easy to do oo and much harder (or needs encoding) to do pure functional, but not forbidden.
12:02:25 <labreuer> without doing a separate function with pattern matching if possible
12:02:35 <PeakerWork> labreuer: and leave the (fst) as is?
12:02:39 <labreuer> yes
12:02:40 <Philonous> @type case x of {Just _ -> True; _ -> False } -- labreuer
12:02:41 <lambdabot>     Couldn't match expected type `Expr' against inferred type `Maybe a'
12:02:42 <lambdabot>     In the pattern: Just _
12:02:42 <lambdabot>     In a case alternative: Just _ -> True
12:02:51 <PeakerWork> labreuer: shouldn't that be a:  [(a, Maybe b)] -> [(a, b)] ?
12:02:54 <Philonous> @type \x -> case x of {Just _ -> True; _ -> False }
12:02:55 <lambdabot> forall t. Maybe t -> Bool
12:03:14 <Saizan_> Kyssan: http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
12:03:20 <labreuer> ahh, I think it's "case of" that I wanted
12:03:43 <jmcarthur__work> <jmcarthur__work> conal, the intuition being that two futures are considered both relative to "now"?
12:03:55 * conal has flaky internet. 
12:03:55 <PeakerWork> @djinn (a, Maybe b) -> Maybe (a, b)
12:03:56 <lambdabot> f (a, b) =
12:03:56 <lambdabot>     case b of
12:03:56 <lambdabot>     Nothing -> Nothing
12:03:56 <lambdabot>     Just c -> Just (a, c)
12:04:08 <PeakerWork> labreuer: Basically, you can use that, plus catMaybes
12:04:10 <PeakerWork> @type catMaybes
12:04:12 <lambdabot> forall a. [Maybe a] -> [a]
12:04:53 <Twey> > catMaybes [Just 1, Nothing, J
12:04:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:04:55 <Twey> Ack
12:05:03 <conal> jmcarthur__work: i prefer to think of relative time as being independent of any particular 'now'.
12:05:11 <Twey> > catMaybes [Just a, Nothing, Just b, Nothing, Just c, Nothing]
12:05:11 <lambdabot>   [a,b,c]
12:05:15 <Twey> Ah
12:05:23 <jmcarthur__work> conal, well, relative to the same time, then?
12:05:54 <Kyssan> Saizan_: thanks for the link
12:06:05 <conal> jmcarthur__work: i guess some sort of compatibility is what you have in mind.
12:06:16 <labreuer> I wrote a generalized self_join method since I couldn't easily find one and wanted to have fun anyhow: http://haskell.pastebin.com/m1b16ecc4
12:06:22 <conal> jmcarthur_work: maybe something's missing in the types.
12:06:28 <labreuer> and then I needed to filter out the right "fringe", which the above does, so thanks
12:06:39 <labreuer> (and if you're feeling ambitious, you can tear apart my horrible self_join, heh)
12:06:43 <conal> jmcarthur_work: similarly for spatial coordinates.
12:07:15 <PeakerWork> catMaybes = concat . maybeToList
12:07:20 <PeakerWork> @src catMaybes
12:07:21 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:07:29 <PeakerWork> @src maybeToList
12:07:30 <lambdabot> maybeToList  Nothing   = []
12:07:30 <lambdabot> maybeToList  (Just x)  = [x]
12:07:40 <PeakerWork> my definition is nicer :)
12:08:42 <burp> @src maybeToList
12:08:44 <lambdabot> maybeToList  Nothing   = []
12:08:44 <lambdabot> maybeToList  (Just x)  = [x]
12:08:49 <burp> oops
12:09:09 <jmcarthur_work> conal, i still find your methods mysterious. what kind of information could possibly go in the types that would ensure this kind of compatibility short of a dependent type (or is that within the scope that you are implying)?
12:09:28 <mmorrow> conal: how is your dsl-to-opengl-shader-language-compiler coming?
12:10:07 <conal> jmcarthur_work: yes, i'm thinking of dependent types.  maybe something else would do.
12:11:04 <conal> mmorrow: going well, thanks.  i have generated shaders running on the iphone.  struggling with CSE, though.  i'm stubbornly attached to a pure GADT representation for syntax, which is making some things very tricky.
12:12:11 <conal> mmorrow: i have lousy CSE now, which makes the shaders bigger than need be.  they run fantastically fast on my macbook pro at 1920x1200, including per-pixel lighting & exact normal generation.  not so fast on the iphone.
12:12:32 <mmorrow> conal: cool. ah yeah, i can see how a GADT rep could be tough. have you decided against any of andyjgill's data-reify stuff for CSE?
12:13:16 <conal> mmorrow: i like andy's data-reify.  it's not directly applicable, since it's monomorphic.
12:13:23 <conal> mmorrow: so i've made a polymorphic version, as described on my blog.
12:13:25 <mmorrow> ah, right.
12:13:35 <mmorrow> conal: oh? cool
12:13:40 * mmorrow looks for that
12:13:43 <conal> mmorrow: still, it's not full memoization, just point-based.
12:13:52 <conal> mmorrow: pointer*-based
12:14:59 <conal> mmorrow: i have a new approach to memoizing over GADTs.  not sure if it's for real or bogus.  will write up another blog post.
12:15:21 <mmorrow> conal: neat, i'd like to hear about it
12:15:54 <conal> i'd love to get a really solid technique together for  CSE on GADTs for deep DSELs.
12:16:18 <conal> CSE seems to be the bane of deep language embeddings
12:16:35 <mmorrow> conal: i'm slightly confused, what is the exact thing you're looking to do CSE on? are you trying to have everything be CSE'ed by construction/a-priori, or are you taking a piece of data after the fact, then CSE'ing it? and if the latter, does it contain functions?
12:18:00 <conal> mmorrow: i was doing CSE by construction for a while.  my term-rewriting got more & more cumbersome (needing to see through let expressions, etc).
12:18:17 <conal> mmorrow: so i switched back to CSE at the end, as in pan, vertigo & pajama.
12:18:45 <mmorrow> in the restricted case of the latter of those two where the data does NOT contain functions, it seems to me that there should be a way using something similar to vacuum, but i'm not sure exactly how
12:18:59 <mmorrow> conal: ah, i see
12:19:12 <mmorrow> conal: are you using HOAS?
12:19:34 <conal> mmorrow: about vacuum, i think so also.  and it's not enough, since i want equality-based sharing, not just pointer-based.
12:19:42 <conal> mmorrow: right now i'm not using HOAS.
12:19:53 <conal> mmorrow: i was using de Bruijn as nested type.
12:20:10 <mmorrow> conal: right, there'd definitely need to be additional stuff going on re: vacuum for CSE
12:21:01 <conal> i'd like to find folks interested in this fully GADT-based approach to deep DSELs.
12:21:17 <conal> other folks keep abandoning it.
12:21:23 <labreuer> thanks PeakerWork
12:21:41 <conal> and going back to something like phantom types or multiple reps.
12:22:28 <conal> i want to keep the pure GADT style unless i know whether it can work out.  so nice for statically typed optimization/compilation.
12:22:49 <conal> s/unless/so i can/
12:23:09 <mmorrow> conal: i'm interested in it definitely, but yeah i'd be hesitant to actually use it for something serious unless i could get a good picture in my head of what trouble could come up and ways to fix that
12:24:20 <conal> mmorrow: glad to hear.  i guess that concern is why we still don't know if pure GADTs work out.  fortunately, i'm pigheadedly stubborn.
12:24:22 <jfoutz> there is a fairly elaborate gatd dsel here: http://augustss.blogspot.com/2009/06/more-llvm-recently-someone-asked-me-on.html
12:24:23 <mmorrow> being able to re-use haskell's type checker is such a convenience
12:24:35 <mmorrow> conal: heh
12:24:47 <conal> jfoutz: yeah. uses two reps iirc :(
12:24:47 <jfoutz> not sure if you're going much farther than what that makes available.
12:24:55 <jfoutz> several
12:26:16 <conal> jfoutz: in that post, lennart operates on untyped terms.  i want typed.
12:26:29 <conal> jfoutz: ie typed at compiler compile-time
12:27:13 <conal> jfoutz: where the compiler is the code in that post.
12:27:34 <dunno> hi http://pastebin.com/d1b1206cc why this error is produced? (Srry newbie ...)
12:28:07 <conal> urk.  lennart's blog got spammed :(
12:29:11 <conal> just emailed lennart about the spam
12:30:02 <Cale> dunno: Because ausgeglichen wants a GTree, and you're passing it a list of them
12:30:19 <Botje> dunno: line 10 is at fault.
12:30:30 <tommd> Yep, this line "ausgeglichen2 s = ausgeglichen s"
12:30:58 <tommd> perhaps you ment something like "ausgeglichen2 [s] = ausgeglichen s"
12:30:59 <Botje> dunno: also, you can just remove that line. the next one will presumable do the right thing.
12:31:18 <Botje> tommd: that won't ever match with line 9 around :)
12:31:31 <tommd> Yeah, I just looked back at the code and saw.
12:31:45 <dunno> oh yes I see, I thought he had a problem with the above line
12:31:48 <dunno> ill try
12:31:58 <Botje> don't try; do :)
12:32:18 <tommd> > Botje == Yoda
12:32:20 <lambdabot>   Not in scope: data constructor `Botje'Not in scope: data constructor `Yoda'
12:32:56 <dunno> but arw if s:sr wont be chosen that means that it is only one Element left
12:33:10 <dunno> so the next line s actually ISNT a list or?
12:33:16 <Botje> :)
12:33:27 <tommd> dunno: If (s:sr) doesn't match the it's the empty list [].
12:33:33 <Botje> dunno: no, [s] is the same as s:[]
12:33:43 <Botje> dunno: so that line can only match if s gets bound to []
12:33:54 <Botje> which means you call ausgeglichen with a [], which is wrong
12:34:29 <dunno> mhm ok so I only need an additional Line ausgeglichen2 [] = ..
12:34:29 <dunno> ?
12:34:52 <tommd> dunno: Typically all you need are two cases:
12:34:52 <tommd> func [] = ...
12:34:52 <tommd> func (x:xs) = ...
12:35:08 <Botje> yes.
12:35:21 <Botje> dunno: but your ausgeglichen2 _ = True line already catches that.
12:35:26 <Botje> perhaps that's what you want
12:35:32 <dunno> omg srry have 2 restart my gnome hangs gui hangs again =/
12:35:39 <dunno> *-hangs
12:41:56 <Botje> o .. kay then
12:45:50 <mmorrow> Botje: looks like a case of epic-kernel-panic-w/-the-female-"self-destruct in .."-voice-countdown-launch-all-escape-pods-all-bets-are-off
12:48:22 <Botje> hey, i had my laptop kernel panic during a presentation :)
12:50:30 <mmorrow> Botje: ooh, fun
12:52:00 <Botje> it was on the next to last slide, luckily, so i got off relatively well
12:54:02 <mmorrow> the graphics (or maybe just opengl) driver for whatever hardware i've got in my Thinkpad X301 is totally bug-ridden, if i enable compiz opengl desktop (which imo is *such* a productivity booster, due to translucent windows and being able to have you workspaces on the inside of a cube and look at them in 3D) the 20-minutes-until-X-locks-up-requiring-a-hard-reboot timer starts
12:54:21 <mmorrow> (where "hard-reboot" := physically holding down the power button)
12:55:04 <mmorrow> such a pita
12:55:04 <koeien37> compiz is vaporware IME
12:55:05 <koeien37> but maybe it just exposes lots of driver issues, dunno
12:55:06 <elly> what? it already exists
12:55:16 <PeakerWork> I disabled compiz due to stability issues too
12:55:32 * koeien37 is a happy user of xmonad now
12:55:52 <mmorrow> koeien37: (did you mean "vapor" in the usual sense?) yeah, i think it's just that because it essentially uses opengl for *everything*, it exposes a lot of bugs that are usually unnoticed
12:56:08 * jmcarthur_work uses xmonad with xcompmgr
12:56:45 * mmorrow misses compiz :(((
12:57:13 <jmcarthur_work> does compiz do anything *useful*?
12:57:25 <copumpkin> nope
12:57:57 <Student> compiz is beautiful
12:57:58 <mmorrow> jmcarthur_work: you can have your editor full-screened, and 60% translucent, and be able to simulataneosly see five windows underneath as you type
12:57:58 <Student> It looks nice
12:58:05 <Student> 3-D windows, etc.
12:58:10 <Student> it's really cool, but not worth hating on
12:58:16 <jmcarthur_work> mmorrow, but i can do that with xmonad and xcompmgr already
12:58:26 <Student> Compiz is free for you to use, and you don't pay for its development
12:58:43 <jmcarthur_work> Student, i'm not hating on it
12:59:01 <mmorrow> jmcarthur: by compiz all i mean is being able to make windows translucent and workspaces on a 3D object, independent of whatever window manager you choose to use
12:59:03 <Student> nvm, sorry
12:59:09 <Student> Quick question on Haskell Cases however
12:59:11 <mmorrow> so s/compiz/whatever that's called/
12:59:31 <jmcarthur_work> mmorrow, well, the 3d object thing is not supported by xcompmgr
12:59:34 <Student> In a case block, what does the keyword "just" mean
12:59:44 <ezyang> Student: It's not a keyword, it's a pattern match
12:59:50 <jmcarthur_work> mmorrow, i make my unfocused windows slightly translucent in xmonad though :)
12:59:51 <ezyang> Check the "Maybe monad"
13:00:09 <jmcarthur_work> which really just means "show some of the background" unless i happen to be stacking some windows
13:00:16 <mmorrow> jmcarthur_work: can you dynamically change translucency of any given window with key-combos?
13:00:26 <jmcarthur_work> mmorrow, could be rigged up to do that
13:00:41 <mmorrow> jmcarthur_work: that's the killer feature that "does it" for me
13:01:02 <jmcarthur_work> mmorrow, it's just a matter of changing a window property
13:01:27 <mmorrow> jmcarthur_work: whatever it may be
13:01:41 <mmorrow> i like being able to have 10 windows open and overlapping, and being able to see *them all*
13:02:01 <jmcarthur_work> _NET_WM_WINDOW_OPACITY
13:02:42 <mmorrow> i wire it to alt-shift-o == increase opacity, alt-shift-p := decrease opacity
13:02:56 <jmcarthur_work> could be done
13:03:17 <mmorrow> jmcarthur_work: wait, are we arguing about something here?
13:03:24 <jmcarthur_work> nah
13:03:24 <mmorrow> jmcarthur_work: :)
13:07:13 * mmorrow nostalgically types alt-shift-o repeatedly and pretends something is happening
13:08:11 <mmorrow> whatever driver it is worked flawlessly on my X60 thinkpad
13:08:34 * mmorrow googles for the difference with the X301
13:08:45 <Student> cool
13:09:02 <ezyang> oh man another thinkpad user
13:09:05 <Student> is it possible to evaluate multiple statements for a branch of a case, without using a helper function?
13:09:06 * ezyang high-fives mmorrow 
13:09:13 <mmorrow> ezyang: :)
13:09:57 <koeien37> Student: yes.
13:10:03 <Student> how do you go about doing this?
13:10:16 <koeien37> but "evaluate multiple statements" is a bit ambiguous. are you working in the IO monad ?
13:10:17 <ezyang> koeien37: wait, really?
13:10:31 <ezyang> koeien37: There's no "fall-through", if that's what Student means...
13:11:27 <koeien37> ezyang: no. depends on themeaning of the equation. but this is possible though:
13:11:54 <koeien37> > case 1 of { 1 -> do { print 37; print 42} ; 2 -> return () }
13:11:56 <lambdabot>   <IO ()>
13:12:11 <koeien37> s/equation/question
13:12:42 <ezyang> huh, why didn't print 37; print 42 execute...
13:12:52 <jorendorff> I just grabbed the GHC source out of darcs, and it isn't building.
13:13:09 <jorendorff> rts/LdvProfile.c:245:0: error: `g0s0' undeclared (first use in this function)
13:18:12 <koeien37> ezyang: lambdabot doesn't execute IO actions
13:18:17 <koeien37> that would be a security risk
13:18:25 <ezyang> Hmph!
13:18:35 <ezyang> codepad totally does limited IO :-P
13:19:47 <koeien37> it's not very useful in lambdabot
13:20:16 <mmorrow> ooh, this looks like exactly the bug https://bugs.launchpad.net/ubuntu/+source/xserver-xorg-video-intel/+bug/363900
13:20:42 <mmorrow> although i'm not using ubuntu, hopefully fedora also has a packaged fix..
13:21:15 <mmorrow> "[i945GM] hard lock with intel driver, no apparent trigger"
13:21:30 <mmorrow> yay, a heisenbug!
13:21:43 <absentia> eureka!
13:25:29 <mmorrow> so i guess this has nothing to do with opengl or compiz, but excessive use of opengl triggers the hard lock heisenbug
13:27:21 <mmorrow> (bugzilla search is tediously slow and useless btw)
13:30:56 <mmorrow> anyways, onto other topics.. this is pretty cool: http://www.complang.org/ragel/
13:32:22 <mmorrow> neat diagrams in the user manual
13:34:50 <birdspider> hi, anyone here familiar with leksah haskell ide ?
13:34:51 <bob0> birdspider: no
13:35:15 <ezyang> ask your question
13:36:32 <birdspider> i can't compile a helloWorld example due to missing Prelude dep; though I have it(base) in the package dependency list, how come ?
13:37:08 <skorpan> what's the error?
13:37:53 <birdspider> the terminal gives: "failed !!!can't locate Prelude", the IDE gives: "Setup: can't find source for Prelude in ., src, dist/build/autogen"
13:38:37 <birdspider> if configured a path for the deps in the IDE to "/usr/lib/ghc-6.10.4", but I am not sure if it is right
13:40:21 <sw17ch> silly question, is there some catagorical term for a function which maps a thing-in-a-box to another-box?
13:40:40 <sw17ch> rebox unbox rebox box = rebox (unbox box)
13:42:00 <jorendorff> (or similarly, rebox = toEnum . fromEnum)
13:42:28 <sw17ch> jorendorff: quite
13:42:43 <Philippa> sw17ch: if the 'boxes' are functors, it's a natural transformation
13:42:48 <ben> What is the rebox parameter for? :3
13:42:59 <sw17ch> ben: my usecase is reducing an expression tree
13:43:14 <sw17ch> eval (Add x y) = rebox unAdd (+) x y
13:43:21 <sw17ch> erm...
13:43:23 <sw17ch> something like that
13:43:25 <sw17ch> sorry
13:43:26 <sw17ch> that's wrong
13:43:34 <sw17ch> eval (Add x y) = rebox unAdd eval x y
13:43:37 <sw17ch> bah, still wrong
13:43:38 <sw17ch> frck
13:43:38 <monochrom> yeah natural transformation
13:43:45 <sw17ch> eval (Add x y) = rebox eval (+) x y
13:43:54 * sw17ch googles "natural transformation"
13:44:22 <sw17ch> now, more importantly, are there already defined constructs in hasekll for dealing with Natural Transformations?
13:46:08 <conal> sw17ch: you'll find related examples & discussion in http://conal.net/papers/type-class-morphisms
13:46:16 <wheeljack> Hello, I would likt to know if i can take the time fron the system
13:46:27 <wheeljack> and what kind of function I would use
13:46:39 <Botje> wheeljack: have you looked at the time package?
13:46:42 <wheeljack> and what kind of function I should use
13:46:51 <Botje> or the Data.Time module?
13:47:03 <wheeljack> I don't know
13:47:27 <wheeljack> I put import Data.Time
13:48:00 <Botje> it has a getCurrentTime function
13:48:04 <wheeljack> but I would like to know if I can use a time funtion
13:48:14 <Botje> what do you mean by a time function?
13:49:34 <wheeljack> How I ca n use getCurrentTime
13:49:35 <wheeljack> ?
13:49:44 <wheeljack> example x=time
13:49:48 <wheeljack> x=2012
13:49:55 <wheeljack> y don't know
13:50:06 <wheeljack> but How I ca n use getCurrentTime?
13:50:07 <koeien37> it doesn't work like that
13:50:17 <koeien37> try
13:50:17 <koeien37> main = do { x <- getCurrentTime; print x}
13:50:48 <koeien37> i suggest you look up a book or tutorial on Haskell, in particular on how to do I/O
13:50:50 <koeien37> e.g. RWH
13:50:53 <koeien37> @where RWH
13:50:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:51:22 <Cale> wheeljack: You have to execute the action getCurrentTime, as koeien37 showed, if you want an actual time from it. If you write x = getCurrentTime, that means you're defining x as the same action as getCurrentTime, without running it.
13:51:53 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:52:06 <Cale> ^^ that's a quick intro I wrote to how IO works in Haskell
13:52:15 <koeien37> > (+1) . Just 37
13:52:17 <lambdabot>   Just 38
13:52:25 <koeien37> Cale: ah, you didn't give in i see :)
13:52:56 <wheeljack> ok, I have this 2009-12-02 21:58:00.601352 UTC, i want only the secs
13:53:57 * monochrom contemplates adding his recent analogy to Introduction_to_IO :)
13:53:58 <mmorrow> sw17ch: this seems possibly relevant, but i'm not sure. it's interesting nonetheless though: http://workerwrapper.com/
13:54:47 <sw17ch> mmorrow: that looks like a monad to me...
13:54:59 <sw17ch> x <- (return >>= foo)
13:55:08 <sw17ch> where <- is work
13:55:13 <sw17ch> and the return is wrap
13:55:46 * monochrom 's recent analogy is actually broken. But he has secretly come up with an impeccable one. :)
13:56:00 <mmorrow> sw17ch: you might use that technique to make version of functions that operate only on Int#/etc, then wrap them with wrappers that unbox Int and jump to the worker, e.g.
13:56:12 <mmorrow> err, ... in a compiler...
13:57:04 <mmorrow> sw17ch: ghc has a worker/wrapper transform stage, but i'm not positive the exact details of ghc's version wrt the version in those papers
13:57:07 <sw17ch> mmorrow: and i'm going expression tree reduction
13:57:16 <sw17ch> going -> doing
13:57:21 <Botje> wheeljack: utctDayTime t % 60
13:57:23 <Botje> err
13:57:28 <Botje> wheeljack: utctDayTime t `mod` 60
13:57:49 <sw17ch> mmorrow: i was getting sick of the restatement of my "eval" function
13:57:49 <Botje> unless difftime is not a number >_<
13:57:57 <mmorrow> eval (Add x y) = rebox eval (+) x y
13:58:07 <wheeljack> thanks
13:58:07 <sw17ch> ^_^
13:58:09 <mmorrow> I# x + I# y = I# (x +# y)
13:58:16 <mmorrow> seems similar maybe
13:58:34 <mmorrow> just one level up
13:58:34 <sw17ch> mmorrow: yes, quite
13:58:38 <sw17ch> right
13:58:52 <wheeljack> but I need do a mod between the secs and a x value
13:59:07 <sw17ch> rebox unI# (+) x y
13:59:33 <sw17ch> seems to play better as a macro than an expression....
14:00:25 <sw17ch> and, since all operations on the I# will share the same unwrap function...
14:00:37 <sw17ch> we can use something like
14:00:40 <Botje> wheeljack: what do you _REALLY_ want to do ?
14:00:46 <sw17ch> reboxI# = rebox unI#
14:00:56 <sw17ch> neat...
14:01:13 <wheeljack> I want to creat a random function
14:01:30 <wheeljack> but I need to use the system clock
14:01:32 <wheeljack> to do it
14:01:40 <Botje> isn't getStdRandom not enough?
14:01:40 <poe> you mean a function that uses a source of randomness?
14:01:42 <wheeljack> I so sorry for my english
14:01:47 <wheeljack> i speak in spanish
14:01:48 <Botje> s/not//
14:02:07 <skorpan> @hoogle Char -> Bool
14:02:08 <lambdabot> Network.URI isAllowedInURI :: Char -> Bool
14:02:08 <lambdabot> Data.Char isAlpha :: Char -> Bool
14:02:08 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
14:02:14 <wheeljack> I cannot use any random function
14:02:21 <Botje> oh, it's homework.
14:02:25 <monochrom> You have a male cat that returns sperm, and a female cat that takes sperm to become pregnant. You are to get the female cat pregnant. At this point an imperative programmer thinks in terms of "so I need to get the sperm in my own hands first". But why would you get your own hands dirty? Just put the couple in a room alone and they'll figure it out. That's what >>= does, put them into a room. Why would you need to "convert mal
14:02:25 <monochrom> e cat to sperm first"? You're only supposed to bind male cat with female cat.
14:02:26 <wheeljack> yeah
14:02:31 <wheeljack> some thing else
14:02:40 <wheeljack> I will be a haskell teacher
14:02:49 <conal> sw17ch: i use the style "inI", "inI2" etc.  and define as "unI ~> I", "unI ~> inI", etc.  where "g ~> f = (f .) . (. g)".  See TypeCompose and Reactive for examples.
14:02:51 <wheeljack> and i need learn
14:02:57 <wheeljack> haskell quick
14:03:09 <Botje> why settle for quick?
14:03:13 <Botje> why not learn it thoroughly?
14:03:37 <monochrom> Because he/she will be a haskell teacher. :)
14:03:42 <wheeljack> because I start on march
14:03:45 <wheeljack> teaching
14:04:00 <Botje> three months looks like plenty of time to become a pro
14:04:02 <wheeljack> I'm male
14:04:04 <conal> sw17ch: e.g. (+) = inI#2 (+#)
14:04:12 <monochrom> You know, a teacher's job description just says "teach", doesn't say "learn".
14:04:30 <wheeljack> yeah...
14:04:45 <inimino> wheeljack: read the report, then read a lot of code, that's how I learned
14:05:00 <wheeljack> But I'm the only that have the risk to teach a new language
14:05:01 <Botje> if you teach haskell the way you do imperative language #2353434, it's no fun :)
14:05:01 <benmachine> writing code helps too
14:05:09 <monochrom> inimino: you... really used the report to learn? even from scratch?
14:05:41 <inimino> monochrom: yes
14:05:43 <monochrom> Yeah, if you use haskell imperatively, you will get your hands full of sperm.
14:05:49 <Botje> wheeljack: anyway, it looks like getPOSIXTime does what you want
14:06:00 <inimino> monochrom: I actually had to read it three times, over a few weeks, but it took very few total hours to get up to speed
14:06:03 <Botje> returns a number like time() does
14:06:08 <Botje> it's in Data.Time.Clock.POSIX
14:06:19 <monochrom> inimino you are a hero :)
14:07:28 <wheeljack> thanks Botje
14:07:40 <inimino> monochrom: I think for someone who is going to be teaching it (and presumably has a lot of existing experience with other languages) and doesn't have a lot of time, it's a good shortcut
14:07:43 <inimino> monochrom: it's not the method I would recommend to everyone :-)
14:07:50 <PeakerWork> monochrom: how is doing Haskell imperatively similar to masturbation?
14:07:51 <wheeljack> and I can add it to a variable
14:08:12 <monochrom> Not masturbation. See my cat fornication analogy above.
14:08:23 <Botje> what do you mean "add"?
14:08:29 <benmachine> it was a good analogy and I approve of it
14:08:32 <Botje> it's just a number, once you get it out of getPOSIXTime
14:08:35 <monochrom> haha
14:09:01 <monochrom> My analogies are indistinguishable from deep insights. :)
14:09:02 <Botje> Prelude Data.Time.Clock.POSIX> time <- getPOSIXTime
14:09:04 <Botje> 1259792168.35056s
14:09:11 <Botje> time + 5 works as well
14:09:33 <Botje> if you want a modulus operator you'll have to use ceil,floor or round first
14:10:29 <mmx166mhz> I am somewhat confused about"return" and related IO things
14:10:40 <mmx166mhz> what does it actually do?
14:10:43 <koeien37> return is not really about IO, but you can use it there
14:10:48 <wheeljack> example
14:10:48 <koeien37> it wraps a pure value into a monadic one
14:10:59 <koeien37> :t return :: a -> IO a
14:10:59 <mmx166mhz> Yeah, and I have problems grasping that idea.
14:11:00 <lambdabot> forall a. a -> IO a
14:11:18 <koeien37> it can be very useful, for example:
14:11:21 <Philippa> it puts the value in a big box marked "IO"
14:11:26 <wheeljack> when i use do {x<-getPOSIXTime;print x} i have
14:11:27 <wheeljack> 1259792057.7713s
14:11:30 <koeien37> :t getLine >>= (\x -> return (x ++ "!!!"))
14:11:32 <lambdabot> IO String
14:11:51 <wheeljack> wheel I need the mod 1259792057.7713s 2
14:11:55 <Philippa> only things in IO boxes can do IO, and boxes can be built by stringing other boxes together
14:12:02 <Philippa> (which is what do does)
14:12:19 <Botje> wheeljack: so round it first.
14:12:40 <mmx166mhz> so, if we have somewhere in a do block " return "hello" ", what does it mean?
14:12:47 <mmx166mhz> My book says: Nothing happens
14:12:59 <Philippa> nothing happens, with the result "hello"
14:12:59 <Botje> correct
14:13:01 <wheeljack> yeah, but how I can pass a IO data to INT data
14:13:03 <Botje> return is not the return you know
14:13:26 <Botje> wheeljack: oh. that's what you're stuck in. I'm afraid you're going to have to (re)read your haskell book.
14:13:31 <mmx166mhz> what actually happens when I type that in?
14:13:33 <monochrom> return is best understood by "return x >>= fc" = "fc x".  I am not kidding. All return does is to offer a value to be passed on to the next stage, whatever the next stage is.
14:13:34 <koeien37> it's completely different from the C/java/Python return
14:13:43 <wheeljack> ok I will
14:14:06 <Botje> mmx166mhz: return is a function that lifts ordinary values into monads. if you put it in the middle of a do block it won't do a thing
14:14:25 <mmx166mhz> So: return in midst of a do block is ALWAYS useless?
14:14:30 <koeien37> do { x <- return 3; ... x ... } is the same as do { let x = 3; ... x ... }
14:14:38 <Botje> at the end it presents the value to be "returned" from a do block
14:14:46 <Botje> mmx166mhz: almost always.
14:15:04 <Botje> mmx166mhz: Just x <- return $ lookup ....
14:15:14 <Botje> will cause the do block to fail if the lookup returns Nothing
14:15:15 <Cale> koeien37: nearly
14:15:28 <Botje> whereas let Just x = lookup $ ... will throw a nasty pattern match error
14:15:30 <Cale> (there's a difference in polymorphism)
14:15:41 <Cale> (which seems like it will probably go away in 6.12?)
14:15:46 <koeien37> Cale: hmm?
14:15:58 <Cale> koeien37: let-bound definitions are generalised
14:16:18 <koeien37> so the x in the first example is monomorphic?
14:16:22 <Cale> Whereas x <- return y is technically a lambda binding, so x gets a monomorphic type
14:16:23 <Cale> yeah
14:16:33 <koeien37> i see
14:17:26 <Cale> But they seem to be considering removing the generalisation step for non-top-level let bindings without explicit type signatures.
14:17:36 <Cale> I'm not 100% sure why that is.
14:18:10 <koeien37> ok, thanks for the clarification :)
14:18:17 <Cale> It seems pretty ugly to me, at first glance, but apparently it makes other things complicated?
14:18:26 <Botje> Cale: I read a paper called "let should not be generalized" by (i think) simonpj
14:18:37 <monochrom> My description makes return look like unnecessary, but once you take modular programming into account, it is necessary. You don't get to write "fc x" yourself. The whole program is "ab >>= fc", where ab is "do stuff; stuff; return x". ab and fc are two separate functions. When you write ab, you don't even know that its next stage is fc, you have to write "return x", it is a way to say "to whom it may concern".
14:18:41 <Cale> Botje: yeah, that's what I'm talking about. I should probably read that.
14:18:52 <Botje> that's probably why :)
14:21:06 <BONUS> hmm, reading the abstract, the motivation for removing let generalization is simplification of the specification and implementation of the type system
14:21:10 <BONUS> bleh
14:21:52 <dqd> It's a poem, isn't it?
14:22:30 <BONUS> hey dqd!
14:22:47 <dqd> Hey BONUS.
14:23:25 <Cale> I can see that it might be worthwhile trying to simplify things when it comes to the newfangled fancy type systems they're working with, but I'm not really sure this is the right thing.
14:23:38 <Cale> I'll read the paper carefully and see if it changes my opinion :)
14:23:49 <BONUS> yeah me too
14:24:13 <BONUS> but imo they shoudl have thought about this *before* introducing the fancier type-system features, useful as they might be
14:24:59 <monochrom> Imperative programming has probably taught people to look for meanings in individual elements. So they ask "what does return mean", "what does comma mean". That doesn't work nicely with Haskell. In Haskell, the context, the whole construct, not individual tokens, gives you meaning.
14:25:17 <sw17ch> conal: thanks. good stuff
14:25:18 <ben> In other words, Haskell is less modular
14:25:20 <koeien37> BONUS: well, that is hard to always predict
14:25:29 <conal> sw17ch: :)
14:25:43 <BONUS> monochrom: i'd say that in haskell, values (data) are more important than token
14:25:52 <BONUS> you can always ask yourself: what value does this expression have now
14:26:03 <BONUS> which is why it's more modular :)
14:26:50 <PeakerWork> monochrom: I'd say its exactly the opposite
14:26:59 <benmachine> haskell is brain-meltingly modular
14:27:28 <poe> monochrom on the other hand locality is praised, referential transparency limits dependency of code-at-distance!
14:27:34 <PeakerWork> monochrom: In Haskell, a set of syntactic tokens *do* have a meaning, dependent only on the values they use, and regardless of the rest of the program -- whereas in an imperative program, a bit of syntax only has meaning in the larger context of the program
14:27:37 <poe> s/of/from/
14:27:52 <PeakerWork> monochrom: well, not in Haskell, but in denotational programming, which Haskell encourages
14:29:00 <BONUS> what i'm worried about with monomorphic local let bindings is that, well, ghci is one big do construct
14:29:01 <PeakerWork> monochrom: y = x.sideEffectAndRead() in an imperative program doesn't only depend on how x was defined -- it depends on pretty much what everyone in the program does to x too..
14:29:22 <BONUS> so all functions you define in ghci with let are suddenly monomorphic. that would be terribly annoying
14:29:27 <PeakerWork> whereas   foldr (++) []   -- depends only on the meanings of foldr, (++) and [].  Nothing else can affect its meaning
14:29:39 <Person> Hmm
14:29:46 <Person> Getting "Bus error" on trying to compile w. GHC
14:30:15 <Person> has anyone seen this before?
14:30:21 <conal> poe: although "A variable is to data flow what GOTO is to control flow.  Just as GOTO allows control to go anywhere, a variable allows data to go anywhere." Arch D Robinson  http://neoparaiso.com/logo/variables-considered-harmful.html
14:30:30 <ben> Try increasing the bus factor
14:30:36 <ben> i heard ghc was having problems with that for a while
14:30:50 <conal> i first thought Robinson means mutable variables, but now i think he meant immutable variables as well.
14:31:21 <PeakerWork> conal: what are "immutable variables"? Just name bindings?
14:31:29 <conal> PeakerWork: yeah.
14:31:31 <monochrom> http://does.not.exist/programming-considered-harmful.html :)
14:31:35 <poe> conal indeed! bindings may let you depend on code on other files. nicely phrased.
14:31:48 <PeakerWork> conal: Ah, I only agree with the first meaning :)
14:31:59 <Person> so....
14:32:02 <Person> What to do about a Bus error?
14:32:14 <nvoorhies> take the train!
14:32:30 <ddarius> BONUS, Cale: I think the paper makes a good argument for what it's striving for.
14:32:34 <PeakerWork> conal: At least up-to recursive uses of names -- liberal use of general recursion does remind of unstructured programming
14:32:36 <mmx166mhz> am I right by saying that in all cases , "return ..." doesn't print anything?
14:32:41 <sproingie> it's not like GOTO is bad at every level
14:32:51 <sproingie> a machine without a jump instruction is kinda limited
14:32:51 <Person> LOL
14:33:09 <PeakerWork> sproingie: yeah, mutable variables are a useful implementation tool as well
14:33:09 <eldragon> is not monad harmful?
14:33:14 <benmachine> Person: bus error during compile?
14:33:16 <darrint> Anyone aware of a javascript port of quickcheck?
14:33:20 <PeakerWork> eldragon: how is babby formed?
14:33:21 <Person> yes, bus error during compile
14:33:33 <poe> mmx166mhz if there is nothing else outside the return, and only referentially transparent things in "..." then yes
14:33:33 <chellomere> sproingie, you could do everything with conditional jumps if you wanted :p
14:33:41 <sproingie> chellomere: still a jump
14:33:51 <benmachine> Person: sounds like a bug, what's your OS/setup?
14:33:52 <chellomere> yeah
14:33:54 <ben> Person: Basically that means something is really broken, possibly due to use of template haskell :3
14:34:09 <ben> If not, and if it reproduces on other systems, you might have found a ghc bug~
14:34:15 <ben> or at least a defect in your memory
14:34:24 <PeakerWork> conal: What alternative to name bindings do you think Robinson means?
14:34:33 <BONUS> ddarius: yeah, i'm reserving judgment until reading the paper. like i said, i just hope this doesn't apply to ghci
14:34:37 <poe> mmx166mhz but two ways in which that code could print are 1. f (return (putStrLn "hello")) where f is some deepseq-like strategy evaluator, and 2. return (trace "hello\n" ...) where trace is Debug.Trace.trace
14:34:43 <Person> Sun Blade, running Ubuntu
14:34:54 <Person> W/ AMD Opteron
14:34:55 <BONUS> because defining polymorphic functions with let in ghci is very useful
14:35:02 <darrint> If no js port, is there a more windows accessible version of http://www.md.chalmers.se/~koen/Papers/quick.ps
14:35:16 <conal> PeakerWork: function-level programming
14:35:35 <conal> PeakerWork: as in Backus's FP
14:35:48 <sproingie> what the heck causes a bus error on x86?
14:36:11 <benmachine> Person: what are you compiling?
14:36:38 <PeakerWork> conal: it does have a more declarative feel when that's done -- there's also something more general about avoiding lambda notation (combinators may often be generalized to more general types than functions) -- though I'm not sure how one uses all these function combinators without names..
14:36:39 <monochrom> bus error means word misalignment, for example a 32-bit word at an odd address.
14:37:01 <ddarius> BONUS: I think it would, technically, apply to the GHCi definitions.  It's very unlikely that it would apply during a transition period between the current behavior and the suggested behavior.  On the other hand, it would probably be easy to put in a hack for GHCi, or maybe they'd finally allow GHCi to accept the full language.
14:37:29 <conal> PeakerWork: yeah.  i'm puzzled as well.  FP was not as flexibly higher-order as the lambda calculus.
14:38:02 <Person> ben: threaded code
14:38:04 <BONUS> hmm yeah. i'm sure the GHCi issue will be given consideration
14:38:23 <Person> ghc --make -threaded -O2
14:38:34 <benmachine> Person: any extensions?
14:39:21 <PeakerWork> conal: Someone in #haskell talked about a language that only had points-free notation, a while back.. And it seemed to have nicer points-free combinators/syntax, I remember they were less mind boggling to the uninitiated. I don't recall what language it was, though..
14:39:27 <Person> no
14:39:34 <Person> Control.Concurrent is all I use outside of standard
14:39:38 <benmachine> hmm
14:39:44 <sproingie> forth?
14:40:17 <benmachine> the most likely explanantion is a bug in GHC, I think
14:40:30 <benmachine> if the code is freely available that would help
14:40:35 <darrint> PeakerWork, factor?
14:40:50 <conal> PeakerWork: i guess there's a tension between approachable familiarity and mind-expandingly strange.
14:41:15 <Person> benmachine: It's for an assignment, TA's wouldn't approve
14:41:26 <Person> I just installed GHC locally
14:41:31 <Person> And it compiles.... same code
14:41:34 <Person> No bus error
14:41:36 <benmachine> hmm
14:41:40 <PeakerWork> darrint: perhaps
14:41:44 <benmachine> that makes a bug in GHC less likely
14:42:06 <benmachine> possibly you should try testing the hardware on the machine that goes wrong
14:42:18 <benmachine> possibly.
14:42:26 <Badger> potentially
14:42:29 <BONUS> interesting though, with local let monomorphism, what would be the type of f if we did: let f = id
14:42:38 <benmachine> but I know less about how to help you if it's not reproducible
14:42:39 <BONUS> () -> ()? i forgot the defaulting precedence
14:42:47 <ddarius> BONUS: It would depend on the usage.
14:42:57 <BONUS> yeah but if you did let f = id and then :t f
14:43:11 <ddarius> BONUS: If it was not used at all then it would be ambiguous.  With the generalized defaulting it would be ().
14:43:24 <BONUS> hmm interesting.
14:43:42 <ddarius> BONUS: In that case, I believe GHC will still say a -> a.
14:44:04 <ezyang> Some comments here earlier about the order of application of function composition in a lazy language got me wondering: when all's said and done, can you get any "results" purely by higher order function manipulation?
14:44:04 <ddarius> But that a would be more like a logic variable than a universally quantified variable.
14:44:21 <RayNbow> hmm, what exactly is an algebraic field als mentioned @ http://www.haskell.org/haskellwiki/Power_function ?
14:44:36 <Cale> heh, new quantifier time!
14:44:37 <PeakerWork> @type let f = id in f
14:44:38 <lambdabot> forall a. a -> a
14:44:40 <Cale> logic a. a -> a
14:45:08 <BONUS> Cale: what is this new strange quantifier
14:45:21 <tromp__> ['a'..]!!12
14:45:32 <tromp__> > ['a'..]!!12
14:45:33 <lambdabot>   'm'
14:45:37 <ddarius> RayNbow: Presumably an algebraically closed field.
14:45:57 <monochrom> I think it means "rigid type variable" as in what ghc error messages sometimes say.
14:46:08 <ddarius> Yes, a rigid type variable.
14:46:09 <Cale> BONUS: I guess it would mean that any unification with a would cause that type to actually be updated to reflect the first monomorphic type to come along.
14:46:48 <RayNbow> ddarius: ah thanks, that gives a useful hit in Google :)
14:47:29 * hackagebot upload: chalkboard 1.9.0.16 - Combinators for building and processing 2D images. (AndyGill)
14:47:35 <BONUS> it would be interesting if you defined a lot of let functions in ghci, their types intertwining, and then you fixed the type of one of them
14:48:00 <monochrom> (quantum something collapse thingy)
14:48:02 <BONUS> and the types would then propagate back
14:48:06 <Cale> I wonder how hackage would deal with a package having unicode characters in its name.
14:48:12 <BONUS> yeah i was just about to say, reminds me of quantum collapse
14:48:30 <monochrom> (type entanglement! typecheck at a distance!)
14:49:03 <monochrom> (faster-than-light typechecking)
14:49:27 <poe> (Spool the FTL! Check the types!)
14:49:51 * maltem feels like people a talking LISP)
14:50:06 <monochrom> (haha!)
14:52:25 <phr> someone was on a while back discussing some generic sandbox environment that could wrap things like lambdabot
14:52:25 <phr> anyone remember what/where it was?
14:56:17 <h20xt> phr: jails? vservers?
14:56:25 <phr> yeah, something like htat
14:59:01 <dancor> forget entangled types, what are the implications of general relativity on time/space optimization
14:59:16 <SoleSoul> Is there a short way to write an infinite fibonacci list?
14:59:46 <dancor> http://en.wikipedia.org/wiki/Haskell_%28programming_language%29#More_complex_examples
14:59:48 <ddarius> dancor: There are actually quite a few though some depend on the actual structure of spacetime.
15:00:27 <dancor> ddarius: there are any?  i didn't know
15:00:42 <ddarius> dancor: How could there not be?
15:01:02 <SoleSoul> Thanks
15:01:13 <dancor> if "time" for programs has nothing to do with physical time
15:01:32 <ddarius> dancor: How is that the case?
15:02:08 <dancor> algorithmic "time" is like turing machine steps
15:02:11 <ddarius> dancor: Some abstract notions of time used in computing are divorced in physical time (and thus can lead to unrealizable assumptions), but the general notion matters.
15:03:17 <monochrom> Yeah, too much detached from physical time leads to pure math curiosity.
15:04:03 <dancor> i feel like everyone but me already knows about these connections.  i'm armed only with my ignorance, but it's proved a powerful tool so far
15:04:13 <monochrom> "imagine a computer that finishes the nth operation in 1/2^n seconds" is funny but not very useful.
15:05:16 <dancor> the turingularity
15:05:40 <phr> http://jdh.hamkins.org/Publications/2000e
15:05:59 <phr>   Infinite time Turing machines
15:06:37 <dancor> awesome
15:06:42 <phr> heh
15:07:54 <dancor> phr: "ordinal time" -- are they not countably-infinite time?
15:08:02 <phr> yes
15:08:36 <phr> that paper is really cool, completely useless but lots of fun
15:09:13 <phr> it has a "Lost Melody Theorem" :)
15:10:34 <dancor> sorry, i still don't understand.  is it wrong for me to say that the number of steps these turning machines can execute is countably infinite?
15:10:44 <phr> yes, countable
15:10:52 <dancor> ok
15:11:04 <phr> but it can get up to some pretty high ordinals iirc
15:11:09 <phr> i.e. way past epsilon-0
15:11:13 * dancor cardinal vs ordinal noob
15:11:43 <phr> you might like http://en.wikipedia.org/wiki/Large_countable_ordinal
15:12:31 <cnwdup> What's your favourite math joke?
15:13:20 <clarkb> 789
15:15:06 <dancor> the one about the mathematician seeing a black cow from a train in england and concluding that there is at least one cow in england with at least one black side
15:15:38 <ddarius> dancor: That's a bit presumptuous, don't you think.
15:15:59 <dancor> indeed, that's why i'm a nihilist and not a mathematician
15:16:04 <monochrom> My favourite math joke: a PhD student came up with a special kind of monad (take the monad laws and add his extra laws) and proved very nice properties. At the defense a prof asked, "do you have examples of this special kind of monads?" The student didn't. The prof then stepped up to prove that only the identity monad satisfied the extra laws.
15:16:40 <BONUS> lol
15:16:55 <BONUS> i guess he owned you
15:17:06 <dancor> that's the problem with working on one thing for eight years
15:17:23 <ddarius> The student was clearly incompetent if he couldn't even have come up with the Identity monad.
15:17:28 <conal> cnwdup: what's purple and commutes
15:17:32 <monochrom> No, it has to be a joke because the advisor should have noticed very early.
15:17:55 <cnwdup> conal, I have no idea.
15:17:55 <BONUS> conal: what
15:18:03 <ddarius> Oh god
15:18:03 <conal> cnwdup: an abelian grape
15:18:09 <BONUS> lol
15:18:10 <dancor> i knew this would happen
15:18:15 <ddarius> dancor: Me too
15:18:22 <conal> cnwdup: or "Q: are these triangles similar?  A: this one is."
15:18:24 <BONUS> (the Oh god before the punchline made it awesome)
15:18:29 <monochrom> abelian grape is very stale.
15:18:46 <dancor> cownal
15:19:33 <dancor> there are good dirty math jokes
15:19:50 <dancor> are there any haskell expressions that are themselves jokes
15:20:10 <BONUS> dancor: fix error
15:20:12 <BONUS> try it in ghci
15:20:31 <monochrom> How about this: a grape natural transformation.
15:21:25 <ddarius> ortmage needs to fix his crap or be temporarily redirect-banned.
15:21:41 <dancor> conal: actually i didn't get the second one, is it about being self-similar?  i thought that was something a sequence could be, not a triangle..
15:22:15 <conal> dancor: the joke is that "similar" is a relation between two things.
15:22:22 <phr> you know why the singers at the sydney opera house are so good at calculus?
15:22:30 <dancor> i get that part
15:22:39 <phr> all that practice at arias under the curve.
15:22:41 <monochrom> wordplay on natural language where "x is adjective" is ambiguous.
15:22:43 <dancor> is there no second part
15:22:47 <BONUS> phr: hahaha
15:22:54 --- mode: ChanServ set +o Lemmih
15:23:18 <conal> dancor: and the answerer heard it as a property of each triangle, independently.
15:23:23 <dancor> right ok
15:23:36 <monochrom> or shall I say "x's are adjective" is ambiguous.
15:23:39 <jmcarthur_work> ortmage, everything okay buddy?
15:23:41 <dancor> i thought there was another mathematical meaning of similar that would give it that extra connection
15:23:43 <BONUS> lol, this is even better than the jokes themselves. i like the one about triangles :)
15:23:54 <conal> BONUS: :)
15:25:02 <monochrom> It happens in real. Just some time last month in efnet #math someone really asked "what is a disjoint set?"
15:25:03 <dancor> ddarius: be patient, i'm sure ortmage will have the goodness to stop once he expires the space of 16-letter alpha strings
15:25:04 --- mode: Lemmih set +b *!*=williasr@nat/google/x-iynulzekdadxoaud
15:25:04 --- kick: ortmage was kicked by Lemmih (Take a break.)
15:25:15 <medfly> hehehe
15:25:31 <monochrom> But Lemmih has the greater goodness.
15:25:31 <ddarius> Lemmih: Just ban the nick, since this is probably just some error.
15:25:34 <conal> monochrom: nice. :)
15:25:36 <medfly> nono
15:25:43 <medfly> the nat/google/x-.... last bit changes
15:25:46 <jmcarthur_work> haha
15:26:42 <mmorrow> haha
15:26:42 <conal> it's funny, and yet people make this mistake all the time when describing their preferences (a relation) as if they properties things.
15:27:00 <jmcarthur_work> wow it got worse
15:27:13 <ddarius> conal: For many people, the "in my opinion" is implied.
15:27:21 <mmorrow> ortmage: you keep joining and quitting at one-second intervals!
15:27:22 <dancor> i wish he would at least crack a letter at a time like in the movies
15:27:36 --- mode: Lemmih set +b *!*williasr@*
15:27:46 <dancor> now that's a luser you can set a watch to
15:28:09 <conal> ddarius: perhaps, although they still argue.  as if their opinions/preferences were in disagreement with other people's preferences.
15:28:29 <dancor> softener phrases have saved many lives
15:30:10 --- mode: Lemmih set -b *!*=williasr@nat/google/x-iynulzekdadxoaud
15:31:31 <jmcarthur_work> conal, i've got it! for relative time, don't have futures at all. simply have values which have duration. that's what relative time is at its core, and it doesn't conceptually tie it to a reference time
15:31:46 <ddarius> conal: Some (many) people do, but I would say when most people say that "sushi is bad" (and may go on arguing as if that were an inherent property jokingly) that they do understand that that is only their opinion.  That is, "sushi is bad" is just another way of saying "I dislike sushi."
15:32:11 <jmcarthur_work> so a Reactive would be a list of values which have duration
15:32:15 <monochrom> haskell is good for your health
15:32:21 <copumpkin> sushi is inherently good
15:32:27 <dancor> > runInterpreter (setImportsQ [("Prelude", Nothing)] >> eval "length \"test\"" >>= liftIO . print
15:32:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:32:29 <jmcarthur_work> and Event would be something defined in terms of that, i think, but i haven't thought that far
15:32:36 <dancor> what
15:32:40 --- mode: Lemmih set -b *!*williasr@*
15:33:10 <conal> for a while i've been thinking of starting a group for people interested in getting past opinions in their thinking & discussion.
15:33:31 <dancor> conal: how exactly do you dispatch with opinions
15:33:49 <copumpkin> is the superiority of the absence of opinion an opinion itself?
15:34:03 <dancor> i'm sure i could construe it as one
15:34:32 <jmcarthur_work> dancor, personally i think the trick is simply to recognize the difference between opinion and fact. i believe it's sometimes harder than it sounds
15:34:50 <dancor> what happens if i said "maybe opinions are all we have" in the group
15:34:58 <conal> copumpkin: sure.  and may be difficult even to define.  not so difficult as a preference.
15:35:01 <conal> dancor: i have a few techniques.
15:35:03 <monochrom> which definitions of words you use is already an opinion.
15:35:07 <ddarius> dancor: That's actually not too far from what I think.
15:35:07 <jmcarthur_work> dancor, you would get some opinions on that ;)
15:35:12 <copumpkin> :)
15:35:23 <mmorrow> i had a teacher in high school that used to say "be wrong with authority!", and i remember that quote to this day (obviously)
15:35:27 * copumpkin has no stance
15:35:38 <ddarius> mmorrow: I disbelieve that you remember it.
15:35:52 <mmorrow> ddarius: you're wrong! with authority!
15:35:54 <jmcarthur_work> so sad that definitions are like that. it would be so much useful to be able to simply declare definitions for the scope of a discussion and then forget it when it goes out of scope
15:35:55 <copumpkin> lol
15:36:11 <jmcarthur_work> but nobody ever seems to be able to handle that
15:36:14 <monochrom> This is why I went into math and cs.
15:36:58 <copumpkin> so you can debate the merits of ZFC?
15:37:00 <mmorrow> ddarius: well, actually i guess not quite with authority. the "wrong with authority" version of that would be "no, you don't remeber that."
15:37:07 <monochrom> I know a very good philosopher who does that. Most reasonable person ever.
15:37:07 <conal> anyway -- if anyone is interested in participating in the opinion-free zone (practice group), let me know.
15:37:34 <dancor> this question has some relevance to proof systems
15:37:38 <dancor> choosing axioms
15:38:09 <dancor> the only scientific part of math
15:38:09 <mmorrow> conal: i don't understand how you mean. what is an example sentence one might read/hear in such a group?
15:38:16 <poe> monochrom self-referencing?
15:38:19 <copumpkin> I'm going to start a new system that asserts that P=NP as an axiom
15:38:27 <copumpkin> because it'd be awfully handy
15:38:30 <monochrom> "ZFC does not imply CH" is a sentence one might hear in such a group. :)
15:38:45 <monochrom> poe: No.
15:38:54 <dancor> i'm still holding out on satire and this-is-all-a-dream options for this practice group
15:39:07 <ddarius> monochrom: But then you'd have opinions on the definitions of "ZFC" and "CH" as you yourself pointed out.
15:39:11 <mmorrow> conal: (or if that is a silly question, why?)
15:39:41 <ddarius> monochrom: That 2+2 = 4 depends on my choice of + and 2 and 4 and =.
15:39:52 <monochrom> No, I had "definitions of freedom, crime, social justice, fairness" in mind.
15:40:10 <conal> mmorrow: i think you just mean you don't have much of an idea what i'm talking about.  i'll clarify at some point.  right now, working on a blog post.
15:40:27 <conal> about tries for GADTs
15:40:27 <mmorrow> conal: right, that's exactly what i mean.
15:40:42 <copumpkin> mmm
15:40:44 <conal> mmorrow: thx.
15:40:45 <mmorrow> conal: ooh, cool
15:40:47 <dancor> > runInterpreter (setImportsQ [("Prelude", Nothing)] >> eval "length \"test\"" >>= liftIO . print)
15:40:49 <lambdabot>   Not in scope: `runInterpreter'Not in scope: `setImportsQ'Not in scope: `eval'
15:40:56 <dancor> that makes more sense
15:44:34 <monochrom> Oh, definitions of "intuitive" "readable" are most elusive in programming language debates.
15:47:25 <Runar> monochrom: They're both isomorphic to "familiar"
15:47:30 <darrint> Anyone know if when porting quickcheck to other languages it was important to preserve the determinism of the random number generators?
15:49:51 <mmorrow> darrint: i'm imagine so, to retain repeatable tests
15:49:55 <mmorrow> s/i'm/i'd/
15:50:17 <mmorrow> darrint: you might want to check out the erlang version
15:51:33 <conal> jmcarthur (& dancor): (belated) yes -- cultivating more clarity about opinion vs fact.  similarly observation vs interpretation.
15:52:21 <darrint> mmorrow, The quviq people don't make their software easy to find.
15:52:30 <Runar> darrint: We've a Java implementation that uses java.util.Random. I don't think that's deterministic.
15:53:15 <mmorrow> darrint: i've never tried myself, good luck
15:53:36 <mmorrow> darrint: (i have a slight suspicion that it's proprietary?)
15:53:39 <Runar> darrint: Hook up with dibblego. He's implemented it several times.
16:05:21 <conal> anyway, if anyone is interested in the "beyond opinions" ("unpinions") thing, let me know, and i'll tell you when i start something.
16:06:37 <copumpkin> I'm interested :)
16:09:26 * hackagebot upload: pure-priority-queue 0.13 - A pure priority queue. (BradLarsen)
16:13:10 <conal> copumpkin: :)
16:15:20 <vovik> how do i print something of the type IO Int
16:15:40 <copumpkin> fmap print
16:15:51 <Peaker> (>>=print) you meant?
16:15:58 <Peaker> vovik: you probably want to print the Int, not the (IO Int), right?
16:16:06 <copumpkin> oh yeah :)
16:16:08 <vovik> Peaker: right
16:16:19 <copumpkin> join (fmap print x)
16:16:20 <copumpkin> hah
16:16:27 <copumpkin> Peaker: I wasn't done! ;)
16:16:32 <Peaker> copumpkin: aha :)
16:16:42 <copumpkin> pff
16:16:53 <Peaker> vovik: That's what (>>=) is for
16:16:55 <Peaker> @type (>>=)
16:16:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:17:05 <vovik> ya i'm still trying to get the hang of bind
16:17:18 <Peaker> vovik: (>>=) composes an action yielding an a, a pure function from a to an action yielding a b, and that final action, into one big action that does these 3 things
16:17:21 <vovik> so how would i do that in do notation
16:17:36 <Peaker> vovik: do { x <- yourAction ; print x }
16:18:58 <Peaker> vovik: A) an action yielding an a   (m a)      B)  A function from a to a new action  (a -> ...)   C) An action yielding a b  (m b)   resulting in  D) A big action composed from A,B,C that yield's C's result (m b)    Do you see all 4 in the type of (>>=) ?
16:19:43 <Peaker> vovik: by taking,  (action,computation,action)  and fusing them together into an opaque   action,  we can compose actions and computations together into larger actions -- and interlace computations between our actions
16:19:47 <vovik> isn't the action yielding an mb
16:19:48 <vovik> m b
16:20:11 <Peaker> C and D do
16:20:17 <vovik> oh right
16:20:31 <vovik> i was just looking at the @type
16:20:35 <periodic> Hrm... how does one convert an Integer/Digest into Base64 encoding?  Hackage only seems to have a base64-string package with a [String]->[String] function.  Any ideas?
16:20:55 <Peaker> vovik: The essence of monads-for-IO is about the interlacing of actions and computations -- such that computations are free to compute which next actions to use
16:21:01 <Peaker> vovik: based on the results of previous actions
16:21:29 <Draconx> periodic, same way you encode an integer into any other base: by division.
16:21:43 <periodic> Draconx: I was hoping someone else had done it already. :P
16:22:01 <vovik> what you're saying makes sense but it's hard for me to internalize the coding style
16:22:05 <periodic> and in such a way as to allow me to print a pretty sting of it.
16:22:51 <periodic> Specifically I'm trying to write out the SHA512 hash of a string to a file in Base64 encoding.
16:23:13 <vovik> i'm still learning to think in terms of monads for io
16:23:33 <vovik> i'm sure there are tutorials for this
16:23:51 <Peaker> vovik: If you use "do" notation, you get to program imperatively almost exactly like in other imperative languages
16:23:57 <watermind> what is the simplest way to do just a bit of generic programming, to do things like recursion over a tree like structure counting the nodes with Value Constructor X
16:24:37 <watermind> or... do the same for all value constructors (which is recursive call) except for a certain one
16:25:06 <watermind> my tree like structure has 10 kinds of nodes
16:25:37 <watermind> and sometimes only one of the kinds of node matters
16:26:19 <periodic> watermind: you could write a function which will operate on nodes generically by writing a function which has specific behavior based on the type of node.
16:26:42 <Peaker> watermind: Maybe you can convert your tree to a standard tree, fmap it into Bool or 0/1 using any constructor checker predicate, and then just use a sum fold over the tree?
16:27:12 <Peaker> watermind: can the tree have 10 possible constructors in the payload of a normal Tree node, or must the tree have different node types?
16:28:16 <watermind> Peaker: not amazingly pretty
16:28:29 <watermind> Peaker: but could work
16:29:34 <watermind> Peaker: that said, I might as well just opt to change my representation to a tree then
16:30:09 <watermind> Peaker: but that would lose me the type constructors and would just have some label indicating the kind of node that it is supposed to be
16:30:23 <watermind> Peaker: and that loses me some type checking
16:30:58 <Peaker> watermind: Then don't do it :-)
16:37:10 <Student> hmm
16:37:27 <Student> Has anyone ever had a problem with: cannot construct the infinite type: a = Maybe a?
16:38:01 <monochrom> Yes and no. I have encountered it, but not a problem with me. I knew what I did wrong.
16:38:03 <c_wraith> Student:  there's a good chance you're using return when you shouldn't.
16:38:10 <copumpkin> > let a = Just a in a
16:38:11 <lambdabot>   Occurs check: cannot construct the infinite type:
16:38:11 <lambdabot>    a = Data.Maybe.Maybe a
16:38:25 <Student> I'm not returning anything, but
16:38:30 <Student> It's off of a Just branch in a case
16:38:39 <Student> rather, a nothing branch
16:38:46 <lament> are your brackets wrong somewhere?
16:39:03 <c_wraith> Ah.  Then that branch is somehow getting an extra Just applied to it, I bet
16:39:27 <c_wraith> (note that return = Just, for Maybe)
16:39:30 <monochrom> #haskell-paranormal for unexplained, irreproducible phenomenon and mystery error messages! :)
16:39:32 <lunabot>  luna: parse error on input `:'
16:39:53 <c_wraith> ...  Has anyone figured out what that lunabot command is yet?
16:39:57 <Student> hmm
16:40:04 <Student> I've got case X of
16:40:08 <copumpkin> #ty 5
16:40:10 <lament> #haskell-paranormal test
16:40:11 <lunabot>  luna: parse error on input `|]'
16:40:11 <lunabot>  forall t . Num t => t
16:40:18 <copumpkin> :)
16:40:21 <Student> Nothing -> writeTVar tv x
16:40:30 <Student> Just value -> retry
16:40:39 <Student> it's the line Nothing -> writeTvar tv x
16:40:43 <Student> that's causing the error
16:41:02 <c_wraith> then it's related to x, probably.
16:41:10 <c_wraith> what is the type of tv, and what is the type of x?
16:41:19 <c_wraith> (tv is clearly TVar something)
16:43:12 <Student> tv is of type
16:43:24 <copumpkin> Moo
16:43:37 <Student> Maybe x
16:44:07 <c_wraith> huh?  That doesn't look like a concrete type.
16:46:03 <Student> the error also states
16:46:06 <Student> "When generalizing the type"
16:46:12 <Student> for the function its in
16:46:45 <benmachine> if you pastebin the whole function we can probably tell you where it's gone wrong
16:47:28 <copumpkin> Stanford has a haskell course?
16:47:51 <copumpkin> oh that's where michiexile's CT + haskell course is isn't it?
16:48:19 <copumpkin> I guess this isn't it :)
16:48:46 <Student> it's not a haskell course per se
16:48:52 <Student> It's a survey of programming languages
16:56:25 <muri_one> is it possible to pattern match against a variable?
16:56:43 <pastah_rhymez> muri_one: yes, numbers is ok
16:56:44 <c_wraith> muri_one: no
16:56:57 <c_wraith> pastah_rhymez:  you can't match against a variable, though
16:56:58 <pastah_rhymez> f n = case n of 0 -> x; 1 -> y ...
16:57:12 <monochrom> Oh haha I see the ambiguity.
16:57:17 <Saizan_> i think he meas using a parameter as a pattern.
16:57:29 <Saizan_> s/parameter/variable/
16:57:45 <c_wraith> pastah_rhymez: that's binding the function's input to a name.  That's not the same as matching against a variable
16:57:53 <Saizan_> muri_one: if you mean foo x x = .. where you mean the second parameter to be equal to the first, then no
16:58:04 <Saizan_> muri_one: you've to use something like foo x y | x == y = ..
16:58:07 <muri_one> Saizan_: yeah, that's what I meant
16:58:22 <muri_one> got it. thanks.
17:26:01 <Student> So I figured the problem out......
17:26:07 <Student> Got some help from a classmate
17:26:14 <Student> it turns out that I wasn't enforcing strictly with Just
17:26:47 <Axman6> Student: eh?
17:27:09 <copumpkin> :)
17:28:47 <monochrom> He means he was not using the Maybe type consistently.
17:29:57 <Axman6> ah
17:31:05 <monochrom> "not enforcing strictly" in natural language means "I set up a convention but I don't follow it myself"
17:31:27 <medfly> are you his classmate?
17:31:35 <monochrom> I mean, not to be mistaken with "force a thunk" and "strict" in haskell parlance.
17:31:46 <monochrom> No.
17:31:53 <copumpkin> wrong country
17:32:45 <Student> :)
17:33:06 <Student> Bus Error
17:33:12 <Student> >.<
17:33:24 <monochrom> use a bike
17:34:13 <monochrom> I heard you installed ghc yourself and that had no problem. It was a bus error for school-installed ghc only.
17:34:30 <Student> monochrom: That's the case
17:34:42 <Student> monochrom: Uploaded it to the school server, to compile & test there
17:35:43 <monochrom> I would impeach the school sysadmin choosing an unsuitable binary package to install. or an old buggy version. or built from source but some wrong options chosen.
17:37:21 <monochrom> or ghc on sun blade doesn't work yet.
17:40:52 <Student> monochrom: LOL
17:41:04 <Student> monochrom: It worked fine, until a couple hours ago
17:41:14 <Student> monochrom: All of a sudden, everyone got "bus error"
17:42:19 <monochrom> oh what fun.
17:44:10 <monochrom> In this case, there is a non-negligible chance of downright hardware failure.
17:44:26 <Student> monochrom: Not blaming ghc :), it works on my desktop so...
17:44:30 <Student> monochrom: No worries
17:44:41 <jfoutz> is there a function that walks down a list like fold, but calls it's function with the rest of the list. x :: ([a] -> b) -> [b]?
17:44:49 <jfoutz> x (take 2) somelist
17:44:54 <monochrom> Yeah, school computer problem is not something we can help with.
17:45:17 * jfoutz sighs
17:45:29 <Student> Instead, I'll kick the sysadmin right in his Monads
17:45:38 <jfoutz> @hoogle (m a -> b) -> [b]
17:45:39 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
17:45:39 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
17:45:39 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
17:46:36 <jfoutz> @hoogle ([a] -> b) -> m b
17:46:37 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
17:46:37 <lambdabot> System.Console.GetOpt ReturnInOrder :: (String -> a) -> ArgOrder a
17:46:37 <lambdabot> System.Console.GetOpt ReqArg :: (String -> a) -> String -> ArgDescr a
17:47:33 <jmillikin> bos: you around? I'm hitting a performance issue in Data.Text.concat , but maybe I'm doing something wrong. http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=5244
17:48:03 <jmillikin> bos: (T.pack . concat . map T.unpack) is orders of magnitude faster than (Data.Text.concat), in my benchmarks.
17:50:18 <copumpkin> :O
17:50:30 <copumpkin> oh well he was saying just recently that concat had pathological behavior
17:51:02 <jfoutz> ah. the answer is yes. it's in data.list, but i got the type wrong.
17:54:36 <periodic> Wow, laziness is awesome.  I wrote basically the same thing in ruby and haskell.  The haskell version is using about 1.6k, whilethe ruby version is using 72m.
17:54:42 <periodic> memory that is.
17:54:53 <copumpkin> not sure that's just laziness
17:55:03 <periodic> Granted, if I wanted to be memory efficient I wouldn't have used map in ruby
17:55:17 <periodic> I'm using map/fold on some large data structures.
17:55:30 <periodic> I mean, ruby has a lot of overhead, I know.
17:55:51 <periodic> I guess I'm just impressed that I can safely generate data structures with 10k+ elements and still use < 2k mem.
17:56:00 <copumpkin> :)
17:56:11 <Cale> periodic: Yeah, it's awesome. You can program things the right way and they work efficiently.
17:56:23 <Cale> (at least most of the time :)
17:56:33 <periodic> Indeed, I've run into that sometimes before.
17:56:59 <periodic> I was actually checking that I was leaking memory due to some FFI calls and was pleasantly surprised to see how little memory I was using.
17:57:05 <periodic> checking that I wasn't, I mean.
17:57:17 <periodic> It's so nice to be able to think in terms of real mathematical functions on sets.
17:57:42 <periodic> I don't think I can ever go back to OO programming now.
17:58:25 <copumpkin> yeah :(
17:58:33 <copumpkin> haskell has ruined real-world programming for me
17:58:38 <copumpkin> lucky for me I don't work in the real world
17:58:48 <ivanm> real world? what's that?
17:59:13 <jmillikin> It's an implementation detail of IO, pay it no mind
17:59:30 <ivanm> ahhh, good-o
17:59:50 <ivanm> @remember jmillikin [the real world is] an implementation detail of IO, pay it no mind
17:59:51 <lambdabot> Good to know.
18:00:20 <periodic> lambdabot does quotes now?
18:00:31 <copumpkin> it has for decades!
18:00:44 <periodic> decades!  I didn't realize I was that behind on joining the community.
18:01:49 <periodic> Hrm, I've got my two programs (ruby and haskell) racing now.  I wrote the ruby one quickly because it was easy, then went and figured out the FFI to do the haskell one.  So ruby has a lead.
18:01:59 <periodic> I wonder if the haskell program can catch up.
18:02:06 <ivanm> why did you use FFI rather than doing it internally?
18:02:24 <periodic> crypt.
18:02:28 <periodic> It was just easier than rewriting it.
18:02:29 <ddarius> lambdabot is several decades old (in dog years...)
18:02:34 <ivanm> heh
18:02:42 <medfly> that's still pretty old
18:02:50 <ivanm> periodic: there's also blackdog's work on ruby <==> haskell ...
18:02:58 <ivanm> hubris, that's the one
18:03:34 <periodic> I started writing stuff to do the SHA512 and write it out in base 512, but then I realized I could just use the FFI and the whole program would be <40 LoC
18:03:43 <periodic> er, base64
18:03:51 <ivanm> there's probably a lib for that on hackage...
18:03:55 <periodic> I checked. :(
18:04:06 <periodic> the base64 stuff wasn't quite right.
18:04:08 <ivanm> for SHA?
18:04:13 <periodic> oh yeah, the SHA stuff is there.
18:04:17 <ivanm> ahhhh
18:04:20 <periodic> it was just getting it to read in and write out the right types.
18:04:37 <jmillikin> Doesn't <http://hackage.haskell.org/package/Crypto> have a base64 module?
18:04:46 <periodic> like the base64 system is [String]->[String]
18:04:48 <ivanm> that's what I thought
18:04:55 <jmillikin> <http://www.haskell.org/crypto/doc/html/Codec-Binary-Base64.html>
18:05:14 <periodic> the only one I could find on hackage was Codec.Binary.Base64.String
18:05:18 * hackagebot upload: starling 0.1.0 - A memcached client (AntoineLatter)
18:05:25 <periodic> base64-string via cabal.
18:05:33 <periodic> well, I just used cabal, not straight from hackage.
18:05:46 <jmillikin> What kind did you want, ByteString -> ByteString?
18:06:00 <periodic> SHA is ByteString -> ByteString
18:06:10 <periodic> er, ByteString -> Digest
18:06:32 <periodic> and there are Digest -> String (as hex characters) and Digest -> Int and Digest -> ByteString functions.
18:06:50 <periodic> Then I'd like to get that into a base64 String
18:07:36 <periodic> I guess I can read in a base64 string from a file to compare to.
18:07:42 <periodic> so meeting anywhere in the middle would have worked.
18:08:49 <ivanm> why not use bytestring directly?
18:09:32 <periodic> well, I can get the Digest into a Bytestring which is the byte-encoded version.  But I'm not sure how to get that into the same type as my base64 string of printable characters.
18:09:44 <periodic> without writing my own conversion functions.
18:10:09 * ivanm still isn't sure what a "base64 string" is...
18:10:13 <periodic> hrm... would the Codec.Binary.Base64.String.decode function have gotten me there? perhaps...
18:10:32 <periodic> base64 is basically a number encoded in 64-bit blocks which get printed as a-zA-Z0-9./
18:10:53 <bos> jmillikin: i found that bug myself a couple of days ago, and fixed it.
18:11:02 <periodic> it's used to make a number compact but in printable characters for human viewing and to prevent stuff like email processors from munging it.
18:11:18 <jmillikin> bos: ah, thanks!
18:11:27 <bos> jmillikin: i've been going heavy on benchmarking and performance tuning. there should be a new release within a few days.
18:11:58 <periodic> Besides, I hadn't used the FFI before, so I thought it would be good practice. :)
18:12:01 <bos> you're right, the performance of concat was awful. actually, it was slightly worse than quadratic in the number of fragments to be concatted.
18:12:05 <periodic> and thankfully it was rather simple.
18:12:08 <jmillikin> bos: Out of curiosity, any plans for decoding functions with custom error handling?
18:12:15 <bos> jmillikin: that's already done.
18:12:24 <jmillikin> Cool, thanks
18:12:31 <bos> jmillikin: http://hackage.haskell.org/packages/archive/text/0.5/doc/html/Data-Text-Encoding-Error.html
18:12:53 <jmillikin> ah, well, I meant a way to catch invalid input without exceptions.
18:13:02 <bos> jmillikin: yes, read the docs :-)
18:13:05 <ivanm> periodic: OK...
18:13:25 <ivanm> bos: documentation? what's that? :p
18:13:47 <jmillikin> bos: I'm looking at the docs, but don't see a function to do what I'm talking about. It can ignore bad input, replace it, or throw an exception.
18:14:07 <jmillikin> Is there any way to have something like ByteString -> [Either String Char]  ?
18:15:51 <bos> jmillikin: ah. not without going through unsafePerformIO to catch the exception.
18:16:08 <stefstefstef> is this a computer science general chanel?
18:16:44 <c_wraith> stefstefstef: not in the widest sense, but not all discussion is strictly haskell
18:16:45 <bos> jmillikin: it would probably make sense to add that, i agree.
18:16:51 <Axman6> stefstefstef: not really, but we do talk about CS type things. feel free to learn haskell to fit in though :)
18:17:16 <stefstefstef> i am watching a course on haskell now actually
18:17:49 <stefstefstef> make search on google guys, cool course video lectures by Meijer on functional programming with haskell
18:18:56 <Axman6> oh yes, those are really quite good
18:20:39 <Axman6> i really liked the parser combinator video (chapter 8)
18:20:54 <Axman6> awaiting more chapters :)
18:21:29 * ivanm hasn't watched any of them, because the site scares him off
18:21:38 <stefstefstef> http://channel9.msdn.com/tags/C9+Lectures/
18:21:48 <stefstefstef> u guys know other cool sites on functional?
18:22:26 <ivanm> ltu is usually a good site to find articles, etc.
18:22:26 <Axman6> well, if you're interrested in learning haskell, we know quite a few nice tutorials
18:22:29 <Axman6> @where lyah
18:22:32 <lambdabot> http://www.learnyouahaskell.com/
18:22:35 <copumpkin> we're also super helpful guys
18:22:37 <copumpkin> and friendly too!
18:22:40 <ivanm> since when was LYAH _nice_? :p
18:22:50 <Axman6> since always
18:23:19 <medfly> #haskell is the best
18:23:20 <lunabot>  luna: Not in scope: `haskell'
18:23:32 <ivanm> heh
18:26:40 <stefstefstef> wow great to be here then guys :)
18:27:46 <c_wraith> wow.  the channel's well over 600 again.  Is it just because of final season?
18:28:23 <stroan> what's the normal number?
18:28:43 <c_wraith> It was around 590 on average a month or so ago
18:28:55 <copumpkin> we hit 699 once
18:29:26 <c_wraith> how many of them were math + food combos? :)
18:29:30 <ivanm> we could prove it if @users still worked...
18:29:31 <stroan> I lurk most of the time, but I'd say the active members comes to ~50 tops?
18:29:33 <Axman6> @users
18:29:34 <lambdabot> Unknown command, try @list
18:29:38 <Axman6> RAGE
18:29:41 <ivanm> heh
18:29:42 <ivanm> preflex: users
18:29:50 <copumpkin> ivanm: @users was turned off precisely because we wouldn't be able to prove it
18:29:55 <copumpkin> because it forgot every few days
18:29:55 <ivanm> obviously preflex doesn't know what that means...
18:30:10 <ivanm> copumpkin: well, it forgot every few days because of a space leak that caused lambdabot to crash...
18:30:22 <ivanm> and unless gwern was around no-one did @flush... ;-)
18:30:51 <Axman6> we should have a bot in here to specifically do an @flush every hour
18:30:57 <medfly> lol
18:31:00 <ivanm> heh
18:31:07 * Axman6 is only half kidding
18:31:12 <medfly> I think someone should try to fix lambdabot...
18:31:19 <Axman6> or... lambdabot should do it every hour
18:31:20 * medfly is intimidated by it, and is also somewhat busy. :(
18:31:38 <ivanm> @uptime
18:31:39 <lambdabot> uptime: 12d 9h 50m 38s, longest uptime: 1m 10d 23h 44m 29s
18:31:47 <ivanm> Axman6: yes, but then we'd never have an uptime this high ^^
18:32:05 <Axman6> @flush doesn't cause it to restart does it?
18:32:05 <lambdabot> Not enough privileges
18:32:12 <ivanm> nope
18:32:18 <ivanm> but flush doesn't help with the space leak
18:32:21 <Axman6> i thought it just wrote all its info to disk
18:32:22 <ivanm> which was the actual problem
18:32:43 <Axman6> breakfast time!
18:32:52 <ivanm> wtf?
18:32:55 <ivanm> it's almost 2PM for you!
18:40:51 <kmc> does lambdabot still have a space leak?
18:40:55 <kmc> @vixen do you have a space leak?
18:40:58 <lambdabot> i do occassionally, i guess
18:45:45 <monochrom> haha
18:46:22 <Saizan> sounds kynky
18:47:18 <osaunders> I was just reading about cancer on Wikipedia. I think I'll go back to Haskell now, thanks.
18:47:28 * osaunders shudders
18:47:45 <Niccus> which kind of cancer
18:47:50 <osaunders> Lung.
18:49:03 <osaunders> Is there any library that can do implicit conversions between a to [a] and [a] to a?
18:49:28 <kmc> how would the conversion work?
18:49:28 <byorgey> osaunders: no
18:49:37 <kmc> there are functions to go between those types
18:49:42 <kmc> > return 3 :: [Int]
18:49:44 <lambdabot>   [3]
18:49:47 <kmc> > head [3] :: Int
18:49:49 <lambdabot>   3
18:49:51 <byorgey> osaunders: there is (:[])  (the robot monkey operator) for going from a to [a]
18:49:56 <kmc> there are no implicit conversions in Haskell
18:50:10 <byorgey> and there is  listToMaybe :: [a] -> Maybe a
18:50:14 <byorgey> you should never use head
18:50:19 <kmc> yeah
18:50:25 <c_wraith> there are polymorphic constants...  Sometimes that can act sort of like an implicit conversion
18:50:26 <osaunders> byorgey: Why not?
18:50:32 <kmc> > head []
18:50:33 <byorgey> osaunders: because of this:
18:50:34 <lambdabot>   * Exception: Prelude.head: empty list
18:50:35 <byorgey> > head []
18:50:35 <lambdabot>   * Exception: Prelude.head: empty list
18:50:43 <byorgey> your program goes CRASH
18:50:45 <kmc> it's a runtime error
18:50:50 <kmc> you should always pattern match instead
18:50:56 <byorgey> if you accidentally call head on an empty list
18:51:06 * mmorrow prefers (maybe (unsafePerformIO (peek nullPtr)) id . listToMaybe)
18:51:06 <byorgey> and don't try to say "I'll be careful"
18:51:07 <kmc> so that, if you want it to crash on empty, at least *you* say so explicitly, and give a good error message
18:51:08 <byorgey> it doesn't work
18:51:25 <kmc> > let myHead [] = error "You fucked up"; myHead (x:_) = x in myHead []
18:51:27 <lambdabot>   * Exception: You fucked up
18:51:57 <byorgey> that... is only marginally more useful =)
18:52:10 <kmc> hopefully one would choose a better message than i did
18:52:18 <kmc> the point is, it's clear in your code that an error can result
18:52:37 <byorgey> true
18:52:47 <mmorrow> the error message is irrelevant though, since it doesn't help you know who called the head that crashed
18:52:53 * byorgey tends to avoid using 'error' anyway
18:53:03 <kmc> osaunders, if you survey the languages where implicit conversions play a big role, they are universally trainwrecks
18:53:05 <kmc> e.g. Perl, C++
18:53:06 <osaunders> You guys think that head should use Maybe?
18:53:14 <kmc> yeah, head should be listToMaybe
18:53:15 <byorgey> osaunders: yep
18:53:24 <kmc> and we should rename the current head to unsafeHead
18:53:25 <osaunders> kmc: Oh yeah, I hate loose typing.
18:53:39 <osaunders> kmc: In general.
18:53:59 <mmorrow> osaunders: rather, head is useless because you'd never call it unless you knew the list was non-empty, and 99.99% of the time you know that because you just did the pattern match yourself
18:54:18 <kmc> yeah, this is a big difference between Perl and Python.  Python is dynamically typed, but Perl is nearly untyped
18:54:33 <kmc> some people here will try to convince you that "dynamically typed" and "untyped" are synonyms but you should not listen to them ;)
18:54:44 <mmorrow> the other 0.01% if the time an enclosing function you also wrote knows it, and you don't want to use a pattern match to extract the head in this scope
18:54:56 <osaunders> kmc: I already know better.
18:55:00 <mmorrow> s/enclosing/peer-in-a-let/
18:55:33 <osaunders> Seeing as everyone agrees about head why don't we get it changed? Mahaha!
18:56:02 <mmorrow> you mean remove the function from the prelude?
18:56:32 <osaunders> mmorrow: Change the implement to use Maybe. I thought that was the consensus.
18:56:34 <kmc> because it's in the standard
18:56:37 <copumpkin> change is hard
18:56:48 <copumpkin> head = listToMaybe
18:56:52 <kmc> also unlike Perl, Haskell implementations don't just change major semantics of the language on a whim
18:56:58 <kmc> you can of course enable extensions that do
18:57:02 <mmorrow> there's no point in making it return Maybe a, because that doesn't change anything since you just then have to check for Nothing
18:57:13 <kmc> such as NoImplicitPrelude, and import your own Prelude instead
18:57:18 <copumpkin> fromJust . head ;)
18:57:28 <mmorrow> yeah, and there's also listToMaybe already
18:57:43 <copumpkin> I'd support just killing the function altogether
18:57:44 <kmc> :t fromJust . listToMaybe
18:57:46 <lambdabot> forall a. [a] -> a
18:57:56 <kmc> @djinn [a] -> a
18:57:58 <lambdabot> Error: Undefined type []
18:58:02 <kmc> grr
18:58:03 <copumpkin> :t asTypeIn
18:58:04 <lambdabot> forall a b. a -> (a -> b) -> a
18:58:57 <kmc> what do you call those functions which are completely determined by their types?
18:59:10 <kmc> (ignoring sources of unsoundness such as error and fix)
18:59:41 <mmorrow> @check \xs -> reverse xs == id xs
18:59:42 <lambdabot>   "OK, passed 500 tests."
18:59:44 <mmorrow> i knew it!
18:59:59 <kmc> :D
18:59:59 <copumpkin> @check (==) <*> reverse
19:00:00 <lambdabot>   "OK, passed 500 tests."
19:00:00 <copumpkin> duh
19:00:07 <mmorrow> kmc: hmm, not sure but i know what you mean
19:00:34 <kmc> @check (==) <*> (reverse :: [Int] -> [Int])
19:00:36 <lambdabot>   "Falsifiable, after 0 tests:\n[-2,-3]\n"
19:02:01 <mmorrow> kmc: yeah, sure if you cheat
19:02:51 <stefstefstef> i need recomendations on cool webblogs for programming languages in general thanks :)
19:03:14 <kmc> lambda the ultimate
19:03:22 * Axman6 hasn't seen the word weblog for a long time
19:03:33 <kmc> @quote blog
19:03:34 <lambdabot> DerekElkins says: What people need to do is stop reading two page blog posts by someone who's "just got" monads and read the well-written peer-reviewed papers by the people who clearly know what
19:03:34 <lambdabot> they are talking about.
19:03:55 <copumpkin> wow, when did he use that username?
19:04:04 <kmc> stefstefstef, if you read the programming and haskell reddits you will get lots of links
19:04:17 <kmc> programming reddit can be full of crap though
19:04:23 <Axman6> copumpkin: possibly never, there are non irc quotes in there
19:04:25 <idnar> copumpkin: maybe the quote is from the mailing list or something
19:04:28 <copumpkin> ah
19:04:34 <idnar> Axman6: OH SNAP
19:04:45 <Axman6> pwnt!
19:05:01 <stefstefstef> kmc: what is  programming and haskell reddits?
19:05:02 <copumpkin> ddarius needs a blog
19:05:20 <kmc> stefstefstef, there's this website reddit.com
19:05:22 <kmc> a link aggregator
19:05:28 <stefstefstef> aha ok
19:05:47 <Axman6> stefstefstef: http://reddit.com/r/haskell and /r/programming
19:06:05 <ivanm> some-one mention planet yet?
19:06:06 <stefstefstef> thanks :)
19:06:12 <copumpkin> some-two did
19:06:24 * ezyang has a bad idea. He wants to write an article for the Monad Reader. 
19:06:28 <copumpkin> :O
19:06:40 <ivanm> byorgey: I might get something for TMR about sourcegraph by then, no promises though
19:06:46 <byorgey> ezyang: that is a fantastic idea. =)
19:06:54 <ezyang> byorgey: :-)
19:07:01 * ivanm has to work out what he's talk is going to be about, and try and get a new release of sourcegraph out first before PEPM in january
19:07:08 * copumpkin will write a monad tutorial for TMR!!! ;)
19:07:10 <byorgey> ivanm: cool, that would be great.  I'll hold my breath ;)
19:07:16 <ivanm> heh
19:07:18 <ivanm> @slap copumpkin
19:07:19 * lambdabot karate-chops copumpkin into two equally sized halves
19:07:21 <savanni> Oooo,, another monad tutorial???
19:07:24 <ezyang> I'm working on a two-hour lecture I'll be giving this January, but I'll be cribbing a lot of material from Typeclassopedia
19:07:25 <osaunders> stefstefstef: infoq, hacker news. although you also get other stuff on those too.
19:07:41 * ivanm wonders how else you can have a half that isn't equally sized...
19:07:49 <byorgey> ezyang: nice
19:08:13 <ezyang> so, not /quite/ translatable into a TMR article :-)
19:08:23 <byorgey> hehe =)
19:08:33 <stefstefstef> on second thought i might be better off just with books
19:08:56 <osaunders> stefstefstef: What do you want to know?
19:08:59 <byorgey> stefstefstef: what are you trying to learn?
19:09:02 <Axman6> stefstefstef: you could always try a tutorial
19:09:21 <copumpkin> hmm, maybe I should write a comonad tutorial
19:09:22 <stefstefstef> i am in design stage for my language so doing research on lot of languages for the next year
19:09:30 <ezyang> copumpkin: ooh, that sounds lovely
19:09:33 <copumpkin> or wait
19:09:42 <copumpkin> maybe I'll do a cofree comonad tutorial!
19:09:52 <byorgey> copumpkin: sounds like fun to me!
19:09:52 <osaunders> stefstefstef: What kind of language is this?
19:09:54 <copumpkin> :P
19:10:01 <byorgey> or how about a cocomonad tutorial
19:10:12 <copumpkin> would that be cocoburritos
19:10:14 <monochrom> @quote monochrom dualize
19:10:16 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
19:10:19 <osaunders> Are they like cocopops? Cause I like them.
19:10:23 <osaunders> :-P
19:10:28 <copumpkin> lol
19:10:31 <ezyang> cocomonad or cocoamonad? :-)
19:10:31 <byorgey> copumpkin: some mexican food uses lots of coco, in fact
19:10:35 <copumpkin> nice
19:10:37 <kmc> stefstefstef, what languages do you know?
19:10:44 <monochrom> You people make me hungry.
19:10:52 * monochrom goes look for newbies.
19:11:17 <stefstefstef> i am going language by language alphabeticaly on the wiki
19:11:34 <copumpkin> maybe  we should change our name to aardvarkell
19:11:35 <ezyang> Anyway, I think I'd be pretty useless at writing a theoretical article for TMR.  Maybe I could write about adventures in the Logic and Prompt monads
19:11:38 <ivanm> monochrom: what, and catch Mad Human Disease? :p
19:11:40 <stefstefstef> so far i know the usual c,c++,java,scheme,prolog,and what not...
19:11:51 <stefstefstef> python
19:11:53 <stefstefstef> ...
19:12:30 <stefstefstef> scala
19:12:30 <c_wraith> prolog and scheme are usual?
19:12:30 <byorgey> ezyang: writing about adventures often works better for a TMR article than something theoretical anyway.
19:12:31 <osaunders> prolog certainly isn't usual.
19:12:31 <copumpkin> stefstefstef: beware of depth-first search
19:12:37 <stefstefstef> today for a computer scientist they are
19:12:40 <byorgey> ezyang: adventures in Logic and Prompt sounds great, I'd love to learn more about those
19:12:40 <copumpkin> stefstefstef: if you start haskell you'll never move past it
19:13:09 <ezyang> cool!  I'll start whipping up a draft over Christmas break and submit if I get anything decent
19:13:10 <stefstefstef> copumkin: what do you mean? depth first search for ?,,,
19:13:11 <osaunders> copumpkin: I know someone how has.
19:13:15 <osaunders> *who has
19:13:28 <copumpkin> osaunders: something's wrong with them then
19:13:28 <kmc> stefstefstef, as for mainstream languages, if you want a good survey of different features: c++, java or c#, python, haskell, scheme, prolog, forth
19:13:30 <stefstefstef> never past it? it is that cool? i am studying it now
19:13:31 <copumpkin> lack of curiosity?
19:13:38 <osaunders> copumpkin: Well, you would say that. :-)
19:13:38 <copumpkin> stefstefstef: it is bottomless
19:13:42 <kmc> you should also know c and some assembly language, for implementation purposes
19:13:51 <kmc> and also learn about compiler backend languages like LLVM and C--
19:14:02 <kmc> oh i forgot erlang on the above list
19:14:03 <stefstefstef> copumkin: yeah but i am compiler engineer wanabe so my hole life will go there
19:14:14 <stefstefstef> yep i know assembly
19:14:18 <osaunders> I'd recommend you look at J or APL.
19:14:24 <stefstefstef> learning llvm now, i know C
19:14:25 <kmc> learning c++ well will take forever, and it will ruin your mind
19:14:32 <stefstefstef> i am learning A+, dialect of APL
19:14:35 <osaunders> Yeah don't learn C++.
19:14:35 <kmc> but it's good to know all the ways in which C++ sucks, to avoid them
19:14:40 <stefstefstef> c++ is easy
19:14:42 <kmc> http://yosefk.com/c++fqa/
19:14:44 <kmc> stefstefstef, that's false
19:14:48 <copumpkin> no it isn't
19:14:50 <osaunders> C++ is stupid.
19:14:50 <kmc> people who say that know C and they know this "class" keyword
19:14:53 <copumpkin> it's just not interesting
19:14:53 <kmc> and they think that's all there is to C++
19:14:59 <kmc> when actually C++ is about 20 times bigger than C
19:15:09 <kmc> and being a good C++ programmer is harder than being a good Haskell programmer
19:15:15 <kmc> but it's all stupidly wasted intellectual energy
19:15:28 <jfoutz> i know what virtual inheritance means, and wish i didn't.
19:15:30 <Axman6> stefstefstef: haskell is actually a fantastic language for writing compilers in btw
19:15:42 <stefstefstef> really? :)
19:15:44 <Axman6> yep
19:15:51 <copumpkin> if you can't write programs in templates you don't know c++ :P
19:15:54 <stefstefstef> cool cant wait to pass the tutorials now
19:15:54 <Axman6> GHC, the leading haskell compiler is written in Haskell
19:16:02 <medfly> lol
19:16:21 <Axman6> we've got fantasric parsing tools, and plenty of other things to help you write compilers
19:16:22 <Nafai> most compilers are just a series of transformations
19:16:23 <stefstefstef> yeah i have read paper on ghc
19:16:26 <kmc> Haskell is probably one of the best languages for implementing other languages
19:16:32 <kmc> most industrial uses of Haskell fall into this category
19:16:37 <Nafai> Which seem to be a great thing for Haskell
19:16:49 <kmc> so e.g. it's used in embedded systems design, even though you'd never run Haskell code directly on a tiny embedded system
19:16:52 <Axman6> stefstefstef: also, Pugs, what used to be leading perl6 interpreter was written in haskell
19:16:56 <jfoutz> compile time fact with partial template specialization? no. it just dosn't flow off my fingers the way it used to.
19:17:02 <kmc> it's used to concisely express algorithms that translate to thousands of lines of C
19:17:17 <stefstefstef> scala is not better then haskell?
19:17:22 <Axman6> pfft
19:17:26 <Axman6> no, it's not :P
19:17:28 * monochrom is back. nomnomnom
19:17:29 <ezyang> stefstefstef: scala has different use cases
19:17:31 <dibblego> no
19:17:41 <ezyang> monochrom: oh no how many newbies did you eat?
19:17:47 <kmc> scala has crap syntax, imo
19:17:51 <Axman6> haskell is useful for when you want to be able to do everything well >_>
19:17:57 <ezyang> "much better than Java's"
19:18:02 <kmc> the syntax is enough different from Java that you gain nothing from the similarity
19:18:04 <stefstefstef> scala is made in EPFL, scala rocks dudes
19:18:04 <monochrom> white chocolate with green tea flavour :)
19:18:11 <kmc> yet enough similar that they didn't clean it up any
19:18:15 <kmc> anyway syntax is not so important
19:18:21 <dibblego> kmc, that's false
19:18:30 <ezyang> (disagree, but continue).
19:18:40 <stefstefstef> u dont know scala then
19:18:40 <Niccus> that can almost work but my experience with green-tea flavored sweets is that you can't realy taste the green tea
19:18:47 <kmc> dibblego, which part
19:18:58 <dibblego> kmc, that Scala gains nothing on Java
19:19:05 <stefstefstef> exactly
19:19:07 <kmc> dibblego, generally or in terms of syntax?
19:19:07 <monochrom> This one is well-balanced. I tasted both.
19:19:11 <kmc> because i was speaking about syntax
19:19:11 <stefstefstef> i agree with dibblego
19:19:18 <Axman6> stefstefstef: haskell's a much more mature language, and gains from the fact that it's a compiled language, imo
19:19:20 <dibblego> kmc, both
19:19:27 <monochrom> I must add that it is from Japan. Serious people there.
19:19:28 <osaunders> You know to have any serious debate on the merits of programming languages you have to dig into them a bit just saying "I think this is better than that" isn't really doing anything justice. Obviously being on #haskell means that everybody here thinks Haskell is great, go to ##java and you'll get the same zealotry there. You have to work out for yourself what's actually good and what isn't.
19:19:28 <kmc> "compiled language" <--- no such thing
19:19:35 <stefstefstef> scala is not just syntax sugar of java
19:19:42 <monochrom> Or at least picky.
19:19:49 <kmc> stefstefstef, no kidding.  didn't say it was
19:20:02 <dibblego> osaunders, I am on both #haskell and #scala and Haskell poops all over Scala
19:20:09 <ivanm> monochrom: you can get flavoured newbies in japan?
19:20:14 <ezyang> hahahaha
19:20:23 <monochrom> yeah they're serious people there!
19:20:25 <osaunders> lol
19:20:39 <osaunders> monochrom: In scala?
19:20:48 <ivanm> osaunders: in Japan
19:21:13 <monochrom> manufacturers of flavoured newbies^H^H^H^H^H^H^H chocolate
19:21:15 <ivanm> monochrom: so are these kidnapped newbies? or do they volunteer (with one of their gazillion random fetishes)?
19:21:22 <ivanm> oh, chocolate...
19:22:10 <pastah_rhymez> I'm looking for an old (1 year+?) article/blog post about Continuation Passing Style with a shallow implementation of Maybe as an example
19:22:19 <pastah_rhymez> google gives me Nothing :(
19:23:40 <stefstefstef> is presedence in functional languages solved with currying?
19:23:49 <pikhq> stefstefstef: No.
19:23:51 <kmc> stefstefstef, what do you mean?
19:23:51 <Axman6> not really
19:24:03 <kmc> many functional languages don't use currying pervasively
19:24:33 <osaunders> stefstefstef: Precedence is a syntax-level feature.
19:24:40 <stefstefstef> i see
19:24:49 <pastah_rhymez> whoo!!!
19:24:54 <byorgey> pastah_rhymez: found it?
19:24:55 <stefstefstef> i guess it is handled in the AST and code generation phase
19:24:57 <pastah_rhymez> <3 <3 <3 reddit <3 <3 <3: http://panicsonic.blogspot.com/2009/02/maybet-cps-version.html
19:25:07 <ezyang> cool
19:25:22 <kmc> for example in scheme it is more common to have multi-argument functions than to use currying
19:25:26 <copumpkin> stefstefstef: definitely not codegen
19:25:27 <pastah_rhymez> though that's not the one (i think)
19:25:42 <pastah_rhymez> i don't remember the one i read using Rank2Types
19:25:46 <ivanm> pastah_rhymez: how did you get it?
19:25:47 <kmc> stefstefstef, the implementation of precedence should have nothing to do with how it's specified in the language
19:25:52 <kmc> a language is not a compiler
19:25:58 <pastah_rhymez> ivanm: http://www.reddit.com/search?q=haskell+maybe+cps
19:26:02 <kmc> (that's also why i say there's no such thing as a "compiled language")
19:26:10 <ivanm> heh, fair enough
19:26:27 <copumpkin> this feels very platonic
19:26:33 <ivanm> kmc: but practically speaking, most languages are split into those that are compiled and those that are interpreted
19:26:41 <kmc> ivanm, not really
19:26:43 <pastah_rhymez> i should change reddit to my default haskell article search engine
19:26:47 <ivanm> only a few have main-stream implementations of both
19:26:48 <pikhq> ivanm: Not really.
19:26:51 <pastah_rhymez> *to reddit as*
19:27:10 <pastah_rhymez> everything worth reading is eventually posted there :)
19:27:25 <ezyang> pastah_rhymez: you get it faster if you're subbed to Planet Haskell though ;-)
19:27:26 <ivanm> kmc, pikhq: oh? I know there's an interpreter for C, but its usually compiled, etc.
19:27:29 <osaunders> WikiP describes a compiled language as one where there's a preference for compiler implementation.
19:27:31 <kmc> ivanm, Common Lisp?
19:27:41 <stefstefstef> that was my point, it has nothing to do with how it's specified in the language, at the codegen stage the compiler sees the AST tree and sees * and + and says ok * guy you have precedence come here, and then he kicks him and... haha... nah...
19:27:42 <kmc> Python (psyco, IronPython, Unladen Swallow)
19:27:47 <pikhq> Well, if you include "main-stream", sure. That's because some languages are bloody hard to compile. And others that just don't serve much *point* being interpreted.
19:27:56 <ivanm> exactly
19:28:08 <pastah_rhymez> ezyang: what's that?
19:28:12 <monochrom> I split programming languages into English and not-English.
19:28:28 <ezyang> http://planet.haskell.org/
19:28:28 <kmc> Java has interpreters, bytecode compilers with interpreted VM or JIT compilation, and native-code compilers
19:28:39 <Draconx> osaunders, an obvious problem with that definition is: what about languages where the most common implementation is a compiler which outputs code that is then interpreted?
19:28:44 <ezyang> It's a little scary; by the time stuff shows up on the HWR or reddit, I've already seen it
19:28:45 <kmc> what if you run C on a JVM?
19:28:56 <ivanm> monochrom: ummm, last I checked no programming language == English
19:29:02 <kmc> what if you compile C  to JVM via MIPS machine code
19:29:04 <osaunders> Draconx: That's a compiled intermediary language.
19:29:06 <kmc> (that's a real project, actually several)
19:29:12 <ivanm> since we haven't yet developed proper natural language programming languages...
19:29:19 <sproingie> never will
19:29:29 <sproingie> natural language is imprecise, and we like it that way
19:29:30 <kmc> ivanm, and never will.  natural languages are terrible for specifying precise instructions
19:29:31 <monochrom> Yeah, I mean using "foldr plus" vs using "+/"
19:29:33 <ivanm> kmc: I know there's a Java interpreter (jbeans or something?), but IMHO it isn't a real interpreter
19:29:37 <ivanm> kmc: yup
19:29:53 <savanni> Okay, I gotta ask a Monad question here.
19:29:56 <ivanm> monochrom: oh, so overly verbose languages?
19:29:58 <monochrom> IOW I mean English as an adjective.
19:29:59 <kmc> ivanm, but earlier you said Scala was not "compiled" because it runs on JVM -- so what about gcj?
19:30:09 <ivanm> kmc: no I didn't
19:30:10 <Axman6> malcolmw: where's haskell come then? it does both somewhat
19:30:11 <kmc> someone did
19:30:15 <ezyang> savanni: You've come to the right place
19:30:17 <ivanm> kmc: I said no such thing?
19:30:24 <ivanm> Axman6: why are you asking malcolmw? :p
19:30:28 <monochrom> No, I have seen a Chinese version of BASIC too. I call that not-English too.
19:30:28 <ivanm> do you mean monochrom?
19:30:33 <kmc> sorry Axman6 did
19:30:35 <savanni> I'm using the Test.HUnit system to write some code where I acquire a DB handle, run some tests, and then close the handle.
19:30:38 <Draconx> osaunders, but it's a "compiled language" by the definition you quoted, unless that uses an unusual definition of "compiler".
19:30:38 <Axman6> uhm monochrom, not malcolmw
19:30:48 <kmc> the point is it's not a term worth defining
19:30:53 <pastah_rhymez> ezyang: planet haskell seems like a bit mich, i think i'll stick to reddit :)
19:30:56 <savanni> Problem is... I'm having trouble capturing the results of the tests long enough that I can close the DB handle and then return the test.
19:31:02 <ivanm> kmc: I usually categorise those that are compiled to byte-code to run on a VM as "compiled" (so all the JVM languages, etc.)
19:31:03 <monochrom> Haskell is like "data" "type" "where" so it's English.
19:31:12 <kmc> what about APL then
19:31:16 <kmc> is that Martian?
19:31:17 <ezyang> Haskell is the language of Math.
19:31:26 <ivanm> monochrom: but it uses foldr + rather than foldr plus! :p
19:31:28 <osaunders> Draconx: Yeah, I don't see the contradiction.
19:31:28 <kmc> German is the language of Math.
19:31:40 <kmc> Beweis: Klar.
19:31:42 <savanni> I figured out how to do this with the Either monad, but it required that I match the result of the test against the Left and Right constructors and then do appropriate operations, but I have no idea how to do the same sort of thing in the IO monad.
19:31:48 <monochrom> Perhaps I should mention that it is sarcasm. Splitting programming languages by the silliest criteria.
19:32:06 <Draconx> osaunders, my point is that the term is too vague to be meaningful.
19:32:08 <kmc> savanni, you can't "run" an IO monad action the way you can pattern match Either
19:32:10 <ivanm> monochrom: surely you can think of sillier criteria!
19:32:25 <ezyang> savanni: Wild guess you might want ErrorT
19:32:28 <ivanm> monochrom: let us categorise languages based upon the initial of the surname of the main language designer!
19:32:33 <kmc> savanni, do { h <- getDBHandle;  r <- doMyTest h; closeDBHandle h; return r }
19:32:44 <kmc> that's pseudocode ofc, i don't know HUnit or DB stuff
19:32:57 <savanni> Hmm... thought I'd tried that before, but I'll do it again.
19:33:19 <monochrom> Oh yeah I can think of sillier ones. I split programming languages by whether they use [0,1,2] or [0;1;2] for lists.
19:33:37 <kmc> ivanm, i enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
19:33:37 <ezyang> "Haskell should allow hanging commas"
19:34:05 <pikhq> kmc: Haskell/Lisp/Smalltalk. :P
19:34:07 <Draconx> kmc, One of these days I'm going to invent a language called "C/C++" and then become an expert in it.
19:34:12 <ivanm> kmc: heh
19:34:14 <kmc> Draconx, haha
19:34:24 <ezyang> you will call it /++, since the Cs cancel out.
19:34:27 <monochrom> C/C++ = 1/++
19:34:30 <kmc> although "C/C++" has some merit, as it's easier to interoperate C with C++ than it is to interoperate C++ with C++
19:34:31 <sproingie> [0;1;2] is SML, Ocaml, and what?
19:34:33 <ezyang> jynx
19:34:36 <ivanm> @remember kmc I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
19:34:37 <lambdabot> Done.
19:34:46 <ivanm> ezyang: heh
19:35:17 <sproingie> i see Perl/Python/Ruby thrown around a lot but as a sort of language genre
19:35:36 <monochrom> I know J/Java/Javascript
19:36:03 <Axman6> duh, javascript IS java
19:36:22 <ivanm> can we categorise Haskell and Pascal together since they sound similar? :p
19:36:25 <ivanm> Axman6: :o
19:36:28 <osaunders> monochrom: You know J?
19:36:28 <monochrom> (I lied. I don't know J. But don't you love the truely monotonic increasing sequence. It's so least fixed point...)
19:36:43 <osaunders> J is awesome.
19:36:47 <ivanm> osaunders: monochrom is obviously a habitual liar... :p
19:36:53 <monochrom> _|_, J_|_, Java_|_, Javascript_|_, ...
19:37:08 <ezyang> Javascriptaculous_|_
19:37:46 <monochrom> It is a true parallel to "C/C++". I mean the string extension.
19:37:53 <sproingie> osaunders: he knows J/J++
19:37:54 <osaunders> Once I'm done with Haskell (5+ years) I'll move on to J.
19:38:16 <osaunders> sproingie: Oooh that one.
19:38:20 <osaunders> :-P
19:38:31 <centrinia> Is there a J--?
19:38:36 <aavogt> is C++ a larger language than ghc haskell?
19:38:39 <inimino> centrinia: APL
19:38:44 <sproingie> the grammar is certainly larger
19:38:55 <kmc> aavogt, hard to quantify
19:38:59 <kmc> it's certainly less orthogonal
19:39:10 <aavogt> which one?
19:39:11 <kmc> C++
19:39:17 <kmc> features interact in more surprising ways
19:39:19 <sproingie> ghc does have a lot of nooks and crannies
19:39:22 <osaunders> aavogt: When someone says C++ I think of this really fat Swedish man waddling around and calling everyone names.
19:39:36 <sproingie> danish
19:39:49 <osaunders> Oh, Danish, sorry.
19:39:58 <osaunders> Whatever Stoustrup is.
19:40:30 <osaunders> Perl is a conman.
19:40:31 <EvanCarroll> ...
19:40:32 <sproingie> stroustrup's not so bad
19:40:33 <ivanm> osaunders: but you're _never_ done with Haskell!
19:40:43 <sohum> dun dun DUN!
19:40:43 <aavogt> kmc: so stuff like the type family (~) and generalized newtypederiving happens all over the place in C++?
19:40:51 <Axman6> Hi Alex
19:40:52 <Axman6> Congratulations on your COMP2310 result. THere were just 12 HDs in the
19:40:52 <Axman6> course. To be one of these is very good. Well done.
19:40:52 <Axman6> alistair
19:40:54 <Axman6> >_>
19:40:55 <sohum> (welcome to the hotel haskellia...)
19:41:00 <kmc> aavogt, no, C++ doesn't have those concepts...
19:41:00 * Axman6 is awesome, and his lecturer knows it
19:41:09 <ivanm> Axman6: heh
19:41:13 <sohum> Axman6: I got one of those emails too!
19:41:16 <ivanm> what was the course about?
19:41:18 <aavogt> I mean in terms of the craziness / potential to be quite broken
19:41:22 <sproingie> yeah C++ doesn't have concepts now either
19:41:22 <Axman6> hmm, that was slightly longer than i thought it would be
19:41:31 <Axman6> sohum: nice work :D
19:41:41 <osaunders> Axman6: HD?
19:41:44 <Axman6> seems to be people who know me who got HD's
19:41:48 <Axman6> osaunders: high distinction
19:41:48 <sproingie> granted it probably was the right thing to withdraw concepts rather than have them done half-assed
19:41:49 <sohum> Axman6: except he added "Obviously you didn't need me to give you extra marks on your midsemester!"
19:41:58 <sproingie> problem is there may never be any other implementation
19:42:11 <sohum> Axman6: :P
19:42:15 <Axman6> sohum: i got an HD with only 61% on the midsem :P
19:42:28 <osaunders> ivanm: We'll see about that.
19:42:29 <sohum> pfff, I got /60%/ on the midsem :P
19:42:56 <ivanm> osaunders: well, people keep adding extra weirdness, so how will you ever be finished?
19:42:59 <Axman6> sohum: what was your final score?
19:43:09 <monochrom> I thought it was "you are 1 of 12 harddisks"
19:43:10 <osaunders> ivanm: I'll truncate it.
19:43:12 <ivanm> Axman6: I thought HD was High Definitions... >_>
19:43:18 <ivanm> osaunders: heh
19:43:24 <osaunders> I could stop now if I wanted.
19:43:32 <centrinia> I thought HD was High Densities.... >_>
19:43:42 <ivanm> Axman6, sohum: so what was this course about?
19:43:55 <osaunders> I thought it was hard dick.
19:43:59 <Axman6> ivanm: distributed and concurrent systems
19:44:06 <ivanm> *nod*
19:44:29 <Axman6> ivanm: which was a pretty hard course really, so i'm pretty damn proud i got an HD
19:44:37 <sohum> it wasn't... hard, per se
19:44:37 <ivanm> \o/
19:44:49 <ivanm> sohum: Axman6 just didn't turn up to classes, etc.? :p
19:44:55 <Axman6> sohum: well, it wasn't taught particularly well, which didn't help
19:44:59 <sohum> the lecturer is just a bit ... too keen in having fun with us
19:45:05 <savanni> So, that formula doesn't seem to be working for me.  As far as I can tell, as soon as I call assertFailure in the IO monad, all of the code after that falls through.
19:45:06 <Axman6> yeah
19:45:10 <sohum> ivanm: I wouldn't know, I didn't turn up to classes :P
19:45:12 <savanni> i'm trying to isolate a small example that I can post...
19:45:15 <ivanm> sohum: heh
19:45:20 <Axman6> ivanm: i went to all the classes
19:45:31 <ivanm> Axman6: so _that_ was your problem! ;-)
19:45:39 <Axman6> ivanm: probably :)
19:45:45 <ivanm> Axman6: oh, and I got my official offer and scholarship stuff the other day
19:45:58 <Axman6> i don't like reading, and learn a lot more from lectures (being dyslexic 'n all)
19:46:05 <ivanm> I start off with $26.5k a year, and get an extra 2k a year \o/
19:46:06 <Axman6> ivanm: hooray :)
19:46:13 <Axman6> very nice :D
19:46:22 <Axman6> so, you'll be taking me out for beer etc? :P
19:46:44 <ivanm> heh
19:46:59 <sohum> Axman6: it was a lot faster to a) not go to the lectures, and b) listen to the recorded lectures later at 1.77x :P
19:47:01 <ivanm> I'm going to have to pay my folks rent, assuming we ever get a place... >_>
19:47:24 <sohum> Axman6: given that each lecture is about 50 minutes, that's 2 lectures/hour :D
19:48:29 <Axman6> sohum: lol, nice work
19:48:53 <Axman6> i think i'd find alistair very confusing with just audio
19:49:00 <sohum> he wasn't!
19:49:00 <Axman6> sohum: so what was your final mark?
19:49:07 <sohum> also, he speaks /really/ slowly
19:49:11 <Axman6> yah
19:49:23 <sohum> either 83 or 85, I forget
19:49:28 <Axman6> nice
19:49:40 <Axman6> well, you either beat me or i beat you by one mark :P
19:49:45 <sohum> :P
19:50:04 * sohum can live in that heisenoneuppanship
19:50:18 <sohum> *heisenoneupmanship
19:50:49 <Axman6> this was surprisingly my best semester so far, considering how much i disliked a lot of it
19:51:27 <osaunders> Is there a maximum length of list?
19:51:40 <Axman6> nope
19:51:44 <sohum> osaunders: infinity
19:51:48 <sohum> e.g.:
19:51:48 <Axman6> they can be infinite
19:51:51 <sohum> > [1..]
19:51:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:52:00 <Axman6> > [(),()..]
19:52:01 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
19:52:32 <Axman6> osaunders: not only can they be infinite, they can take up constant, small amounts of space
19:53:04 <sohum> osaunders: more realistically, because those aren't really lists, just lazily evaluated thunks - there's no defined max, so it's only limited by your memory
19:53:21 <Manyfold> > [(),(()),((()))..]
19:53:23 <lambdabot>   <no location info>: parse error on input `..'
19:53:43 <Niccus> > (())
19:53:44 <lambdabot>   ()
19:53:46 <Manyfold> :(
19:53:53 <savanni> OKay, is there a pastebin for the channel?
19:54:02 <Axman6> @hpaste
19:54:02 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
19:54:06 <Axman6> uh
19:54:09 <Axman6> @where hpaste
19:54:10 <lambdabot> http://hpaste.org http://moonpatio.com/fastcgi/hpaste.fcgi/
19:54:12 <Axman6> preferred
19:54:17 <Axman6> sort of... meh
19:54:25 <savanni> Wait... there's two URLs on that line.
19:54:26 <sohum> oh. huh. I've been using haskell.pastebin...
19:54:38 <Axman6> i think hpaste.org/fastcgi/hpaste.fcgi/ works
19:54:51 <osaunders> i like codepad
19:54:57 <osaunders> I'll execute the code.
19:55:01 <osaunders> *It'll
19:55:17 <Axman6> sohum: dunno if you will, but you might find this an interesting reddit to subscribe to: http://www.reddit.com/r/Compilers
19:55:29 <Axman6> osaunders: which means you need complete programs
19:55:32 <sohum> spiffy
19:55:33 <ivanm> @ask mmorrow so is your moonpatio pastebin the new official hpaste site?
19:55:34 <lambdabot> Consider it noted.
19:56:00 <osaunders> Then it just fallbacks  just the same as the others.
19:56:02 <ivanm> osaunders: why would you want random code pasted up somewhere executed?
19:56:08 <ivanm> can someone say "fork-bombs"? ;-)
19:56:11 <sohum> Axman6: I got a really high mark on my principles of programming languages/compilers course :P
19:56:51 <Axman6> sohum: nice work, i'm looking forward to that one. seems that knowing haskell would be somewhat of an advantage there
19:57:12 <ivanm> Axman6: knowing haskell should be an advantage _everywhere_!
19:57:22 <ivanm> it gives you a mark of class and distinction!
19:57:34 <Axman6> indeed
19:57:41 <kmc> except for enjoying your day job
19:57:47 <Axman6> heh
19:57:59 <ivanm> kmc: heh
19:58:03 * Axman6 is a uni student, so haskell is pretty close to being his dayjob :P
19:58:15 <savanni> Okay, if anyone is willing to look: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5245#a5245
19:58:45 <ivanm> savanni: what are we looking at?
19:58:59 * ivanm has no idea how to use hunit or db stuff in haskell
19:59:00 <savanni> So, it's some code in which I'm trying to figure out one aspect of a monad.
19:59:19 <sohum> Axman6: it is! Ben describes type systems pretty much referencing haskell's, and it's a course that rewards exposure to different programming paradigms
19:59:46 <savanni> It's more about the IO monad.  I want to be able to run "my_run_test fail_case" and see the string "Disconnecting" followed by the exception that the test was forced to fail.
20:00:07 <savanni> But all I'm seeing is the exception with no indication that my db handle got disconnected successfully.  And I'm having trouble figuring out why.
20:00:15 <EvanCarroll> is ther eever a case it is ok to have typeclasses on custom datatypes.
20:00:37 <Axman6> EvanCarroll: that's sort of what they're there for :)
20:00:38 <ivanm> savanni: use the exception stuff to catch the exception?
20:00:47 <Axman6> if i understand the question correctly
20:00:58 <blackdog> Axman6: he means instead of having the constraint on the function, i think.
20:00:59 <kmc> EvanCarroll, what do you mean?
20:01:25 <savanni> ivanm: I can try that.  I guess it makes sense that it is an exception being thrown given that my output is, actually, an exception string.
20:01:45 <ivanm> heh
20:01:46 <EvanCarroll> However, it's a very strong convention in Haskell to never add typeclass constraints in data declarations.
20:01:59 <EvanCarroll> per LYAH
20:02:04 <EvanCarroll> the reason cited is function signatures
20:02:18 <EvanCarroll> it adds complexity required to each one, where as only a few might require the constraint
20:02:20 <Axman6> ah, yeah, don't do that
20:02:29 <EvanCarroll> that wasn't the question
20:02:34 <EvanCarroll> is it *ever* ok to do that?
20:02:34 <Axman6> it just makes your life harder
20:02:36 <ivanm> EvanCarroll: it's bad
20:02:38 <EvanCarroll> always?
20:02:41 <ivanm> it adds in unknown cosntraints
20:02:43 <ivanm> EvanCarroll: yes
20:02:52 <ivanm> which is why it's a right royal PITA that Data.Complex does it
20:02:55 <Axman6> EvanCarroll: no, if you have a good reason for it, go for it
20:03:05 <Axman6> @src Complex
20:03:05 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
20:03:06 <EvanCarroll> is it like raping a baby bad, or like not driving 15miles back to the gass station when you forget to pay for a pack of gum bad?
20:03:10 <kmc> EvanCarroll, you should probably put a constraint on a GADT-style data constructor, rather than on the type
20:03:13 <blackdog> Axman6: an example where it's a good idea might be interesting.
20:03:29 <ivanm> Axman6: what would you call a "good reason"?
20:03:30 <EvanCarroll> blackdog++ # yep!
20:03:35 <monochrom> I haven't seen a convincing example.
20:03:37 <Axman6> i think the Complex example is a fairly good example
20:03:44 <ivanm> Axman6: it's a stupid example
20:03:53 <ivanm> Axman6: since the constraint has to be on the functions still anyway
20:03:59 <Axman6> since, it's there to be used as a number, and all its number functions somewhat rely on the fact its a RealFloat
20:04:06 * ivanm is reading through the Complex source atm
20:04:17 <ivanm> Axman6: it stops you from using Data.Complex for gaussian integers and the like
20:04:40 <Axman6> make your own library then! :P
20:04:45 <ivanm> heh
20:04:56 <monochrom> I speculate why there may be no convincing example. Two cases. If you hide your data type details, you don't need constraints. If you expose your data type details, your constraints contrain other people's right of reusing it for purposes you don't foresee.
20:05:33 <Axman6> monochrom: sounds like the GPL almost :P
20:05:39 <monochrom> IOW it's shortsighted.
20:05:41 <savanni> ixanm: HAH!  That did it!
20:05:51 <sohum> what about "newtype Monad m ‚áí Parser m a b = Parser (a ‚Üí  m (b, a))"?
20:05:55 <savanni> The finally function does excatly what I needed it to.
20:06:36 <monochrom> Parsec shows that they don't have the Monad constraint.
20:07:57 <sohum> I guess I see it as a form of documentation
20:08:12 <monochrom> Yes.
20:08:28 <sohum> if most/all of your utility functions using that type require m to be a Monad, then it just makes sense to document that in the actual type
20:08:29 <monochrom> The problem is that this documentation is overly enforcing.
20:09:12 <monochrom> If the language or compiler says it is ignored by the computer, I wouldn't mind.
20:11:42 <monochrom> The lambdabot package is given. The comment says it's for IRC. Suppose the compiler reads that comment and generates code that forces you to use lambdabot on IRC only, you must connect it to some IRC server in order to use it. Wouldn't that suck?
20:12:36 <roconnor_> @seen conal
20:12:37 <lambdabot> Unknown command, try @list
20:12:43 <roconnor_> preflix: seen conal
20:12:49 <roconnor_> preflex: seen conal
20:12:50 <preflex>  conal was last seen on #haskell 3 hours, 59 minutes and 46 seconds ago, saying: copumpkin: :)
20:12:59 <roconnor_> http://www.haskell.org/haskellwiki/Talk:IO_Semantics
20:13:18 <roconnor_> ^^ Do you think this answer conal's question?
20:14:08 <osaunders> A function that takes two parameters is a binary function?
20:14:17 <monochrom> Yes.
20:14:23 <roconnor_> that's usually what we say
20:14:30 <roconnor_> though it is a bit of a lie
20:14:31 <osaunders> So a unary function takes one.
20:14:43 <Axman6> osaunders: (though technically, all functions only take one parameter)
20:14:50 <Axman6> in haskell at least
20:14:50 <osaunders> Axman6: Yes.
20:14:52 <ivanm> savanni: \o/
20:14:56 <kmc> osaunders, it's a correct definition.  there are no binary functions in haskell.
20:15:09 <monochrom> I am a habitual liar, as some of you pointed out. :)
20:15:19 <savanni> I'll want to dig into teh documentaiton to figure out how Control.Exception is implemented.
20:15:36 <Axman6> magic >_>
20:15:48 <osaunders> But it's OK so say that a -> a -> a is a binary function, right?
20:16:04 <Axman6> not technically
20:16:06 <savanni> AAAAAA!
20:16:17 <monochrom> A few of them are primitive (magic) but a large number are derived.
20:16:24 <ivanm> savanni: yeah, it basically is low-level magic stuff
20:16:35 <savanni> Well, it seems that error is primitive, finally and whatnot is not.
20:16:39 <kmc> osaunders, colloquially it is
20:16:44 <savanni> At least, I assume it is, and isn't, respectively.
20:16:47 <kmc> osaunders, technically, it's a unary function that returns another unary functions
20:16:49 <kmc> function*
20:16:52 <kmc> a -> (a -> a)
20:17:03 <kmc> every function is unary, because the left side of any "->" is a single type
20:17:08 <monochrom> Yeah, I wouldn't say the whole module is magic.
20:17:13 <osaunders> Yes yes I'm aware of that.
20:17:33 <osaunders> But we don't say that every time, it would be boring.
20:17:49 <sproingie> @hoogle a -> a -> a
20:17:50 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:17:50 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
20:17:50 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
20:17:55 <monochrom> This is haskell. You just need one or two magic primitives and you can easily build the rest in haskell-land. This is not Java where adding a new control-flow construct requires rewriting the compiler.
20:18:21 <Axman6> heh
20:18:21 <EvanCarroll> isn't that bad terminology: the function isn't unary. the implimentation that permits currying can be?
20:18:48 <Axman6> EvanCarroll: if it's a haskell function, it's fine
20:18:50 <sproingie> the implementation is always that way
20:19:33 <EvanCarroll> It just seems really silly to call `f a b = a + b` unary, that is clearly not unary, because the function is defined as a + b, which can't be completed with one argument.
20:19:43 <monochrom> I don't understand what EvanCarroll means by "function". Perhaps he refers to some platonic being.
20:19:52 <sohum> EvanCarroll: oh yes it can
20:19:53 <kmc> EvanCarroll, it can be really useful to use f as if it were unary
20:20:00 <sohum> f a = \b -> a + b
20:20:03 <kmc> > let f a b = a + b in map (f 3) [4,5,6]
20:20:04 <lambdabot>   [7,8,9]
20:20:08 <kmc> EvanCarroll, ^^^^
20:20:11 <ddarius> I suspect, but even then, the real question is "what does 'binary' mean?"
20:20:12 <kmc> see how (f 3) is useful there
20:20:19 <monochrom> The function is defined as f = \a -> \b -> a+b.
20:20:25 <ddarius> Typically, in mathematics, it means a function, in Haskell notation, (A,B) -> C
20:20:41 <EvanCarroll> I'm not downplaying the currying effect, I just don't think it is too useful to refer to all function unary because of curying..
20:20:42 <sproingie> the binary-ness of "f a b" is a convenience of syntax
20:20:59 <roconnor_> @src putStr
20:21:00 <lambdabot> putStr s  = hPutStr stdout s
20:21:03 <Axman6> EvanCarroll: in maths, they generally are
20:21:04 <roconnor_> @src hPutStr
20:21:05 <lambdabot> Source not found. You type like i drive.
20:21:08 <sproingie> the fact that underneath it's always unary has lots of nice consequences
20:21:08 <kmc> EvanCarroll, it simplifies all discussion of the type system
20:21:16 <kmc> :t let f a b = a + b in (f 3)
20:21:18 <lambdabot> forall t. (Num t) => t -> t
20:21:50 <sproingie> it's probably over-persnickety to correct someone talking about a binary function tho unless they're implying it can't be any other way
20:22:15 <EvanCarroll> exactly!
20:22:18 <osaunders> Yeah.
20:22:21 <monochrom> You talking of currying as something we do with extra work. But there is no extra work. It's pervasive.
20:22:29 <EvanCarroll> no I'm not.
20:22:57 <osaunders> I'm with EvanCarroll I don't see liking currying and referring to functions are binary as mutually exclusive.
20:23:03 <monochrom> Also "a+b" is not a function.
20:23:17 <kmc> osaunders, it's not a matter of "liking"
20:23:22 <sproingie> sure it is
20:23:25 <kmc> it's not a matter of your personal feelings about currying
20:23:32 <sproingie> (+) a b is after all
20:23:33 <kmc> it's a matter of simplifying the presentation
20:23:39 <sproingie> just extra pointy
20:23:43 <kmc> "(+) a b" is not a function
20:23:43 <Axman6> sproingie: no its not
20:23:56 <sproingie> part of a definition anyway
20:23:59 <EvanCarroll> I'm just saying a function in my mind means given this argument I'll get this output, when you define a function with two arguments, to get the output you want you require set input. the fact that haskell is totally awesome and does currying is great, but I wouldn't think calling `f a b = a + b`, as a binary function f is more proper than calling all functions unary.
20:24:00 <kmc> "\a b -> (+) a b" is
20:24:11 <monochrom> I'll just conclude that saying that you speak like those sloppy mathematicians "the function f(x)"
20:24:24 <sproingie> yet those sloppy mathematicians still manage
20:24:48 <Axman6> but they smell bad
20:24:53 <sproingie> that they do
20:24:57 <osaunders> What's wrong with "the function f(x)"?
20:24:59 <sohum> it's arguably more correct to determine the arity of functions by how many arguments need to be applied to obtain a non-function result
20:25:08 * osaunders isn't a mathematician. :-(
20:25:16 <EvanCarroll> sohum++
20:25:27 <sohum> but that doesn't quite match with function-munging functions, like (a -> b) -> a -> b
20:25:30 <EvanCarroll> and, if language is determinned by use then unary croud is way of way their kilter.
20:25:36 <Axman6> osaunders: a function is something that can be applied to something
20:25:44 <kmc> why do we care so much
20:25:46 <sohum> we want to refer to those as unary, but with that definition it's binary.
20:25:53 <kmc> why use words like "unary" and "binary" when you can just give the type
20:26:05 <ddarius> sohum: That doesn't work for many polymorphic functions arguably.
20:26:08 <kmc> (.) :: (b -> c) -> (a -> b) -> (a -> c)
20:26:13 <kmc> Does that take 2 arguments, or 3?
20:26:18 <osaunders> kmc: Ease of speech.
20:26:19 <sproingie> it takes one
20:26:21 <sohum> my point exactly
20:26:33 <monochrom> because people "learn" by reducing new concepts into old concepts
20:26:39 <sohum> so you have to conclude that arity is again, simply documentation
20:26:44 <osaunders> How do you even speak "a -> a"?
20:26:52 <osaunders> a arrow a?
20:26:56 <kmc> "a to a"
20:26:56 <Axman6> "a to a"
20:26:58 <sproingie> "a to a"
20:27:00 <Axman6> ha
20:27:02 <kmc> but it's not so important on IRC ;P
20:27:02 <ddarius> osaunders: I would say: "forall a, a to a"
20:27:03 * Axman6 wins
20:27:05 <osaunders> Oh, OK.
20:27:14 <osaunders> lol
20:27:31 <sohum> in a language like haskell, it's convenient to refer to both (+) and (.) as binary functions
20:27:38 <osaunders> How about we define binary as a to b to c.
20:27:41 <sohum> because that's how we normally use tem
20:27:46 <ddarius> Arity is extremely fuzzy in Haskell.
20:27:57 <kmc> osaunders, but what if c = d -> e?
20:28:00 <sproingie> not really.  it's either arity-1 or a CAF
20:28:01 <Cale> binary is at least 2
20:28:01 <kmc> as it does for (.)
20:28:09 <kmc> ah, so (.) is both binary and ternary
20:28:11 <kmc> and probably unary as well
20:28:26 <kmc> can't we talk about something less superficial ;P
20:28:29 <Axman6> rarg! anyone know how to upgrade network on windows?
20:28:31 <Cale> yeah, that's the way I'd look at it :)
20:28:35 <kmc> haha Axman6
20:28:36 <sproingie> britney spears is getting married again
20:28:39 <sproingie> discuss
20:28:42 <Axman6> possibly HTTP
20:28:58 <ddarius> sproingie: Perhaps I should have specified, any non-trivial notion of arity is extremely fuzzy in Haskell, at least if we try to stick to numbers.
20:29:01 <kmc> @vixen britney spears is getting married again.  discuss.
20:29:02 <lambdabot> People think I'm weird...   do you?
20:29:06 <Axman6> seems i'm missing runGenProcess
20:29:34 <kmc> Axman6, ah, you mean the cabal package? i thought just, like, how do you upgrade networks on windows
20:29:45 <Axman6> no
20:29:55 <Axman6> trying to upgrade cabal-install
20:30:03 <ddarius> People who need a language like Haskell with a concrete and more traditional notion of arity should use Clean.
20:30:18 <Cale> actually, anything with a completely polymorphic result can be instantiated at a type where it takes as many parameters as you want :)
20:30:22 <kmc> ddarius, why on earth would you choose a language based on its treatment of arity?
20:30:29 <monochrom> haha
20:30:30 <Cale> So (.) is k-ary for every k
20:30:34 <kmc> id is 19-ary!
20:30:46 <Saizan> Axman6: "cabal install cabal-install" doesn't work?
20:31:00 <Axman6> no
20:31:10 <kmc> "undefined" is also 19-ary
20:31:19 <Axman6> huh, apparently it does Saizan
20:31:20 <Cale> I often like to make use of the fact that foldr can take lots of parameters :)
20:31:20 <Niccus> what would fix be
20:31:21 <ddarius> kmc: Why did we just spend a bunch of time arguing about arity?
20:31:26 <Axman6> well, HTTP is building at least
20:31:28 <kmc> i have no idea
20:31:32 <Cale> Niccus: fix is another one like that
20:31:34 <monochrom> I am 17-ary, going on 18-ary, I can take curry of you
20:32:18 <Cale> Perhaps we should say that such functions are omega-ary
20:32:34 <kmc> :t fix
20:32:36 <lambdabot> forall a. (a -> a) -> a
20:32:48 <ddarius> id has arity 1 +-œâ
20:32:58 <monochrom> fix's type length is exponential to its arity
20:33:29 <Saizan> don't say that, or haskell2011 will come with all functions uncurried to avoid the need to explain ordinals to newbies
20:33:46 <Cale> ahaha
20:33:56 <ddarius> Saizan: Do you dislike DoIfThenElse?
20:33:56 <sproingie> @remember monochrom I am 17-ary, going on 18-ary, I can take curry of you
20:33:57 <lambdabot> Nice!
20:34:18 <kmc> why don't we get rid of "if then else" entirely?
20:34:24 <Cale> Recursion is hard and confusing for beginners. I move that we remove it from Haskell 2011 altogether.
20:34:25 <osaunders> I don't get that.
20:34:26 <sproingie> been proposed
20:34:36 <Cale> Also, polymorphism.
20:34:38 <sohum> sproingie: wait, what?
20:34:40 <monochrom> I like DoIfThenElse and I like DoCase too. God but those names are so hard to type.
20:34:45 <ddarius> Cale: Many people would follow you on the former.
20:34:46 <sproingie> sohum: removing if/then/else
20:34:48 <sproingie> not recursion
20:34:53 <sohum> sproingie: oh, thank gods
20:35:04 <Saizan> ddarius: i was making fun of haskell98 rather than 2010, i don't have much of an opinion on DoIfThenElse
20:35:12 <sproingie> i suspect if/then/else will have about as much staying power as recursion tho
20:35:25 <monochrom> Variables are the goto of data-flow. Let's remove them from Haskell 2012.
20:35:26 <ddarius> "The Halting Problem is hard.  Let's remove recursion."
20:35:27 <sproingie> it's not like monad comprehensions, it's pretty deeply embedded into common usage
20:35:35 <kmc> wouldn't it be good to point out that laziness makes special built-in crap like if/then/else unnecessary?
20:36:00 <Cale> if/then/else is a nice bit of syntax sugar though.
20:36:05 <sohum> if/then/else is convenient, but I'd be happy with if'
20:36:09 <ddarius> kmc: The if-then-else syntax is nice, but there certainly should be an equivalent function in the libraries and it would be nice if if-then-else desugared to it.
20:36:14 <Saizan> ddarius: just _general_ recursion! :)
20:36:16 <sohum> or, rather, if == if'
20:36:16 <kmc> wouldn't it be good to forbid beginners from writing "if length(xs) > 0 then head(xs) else 3"
20:36:19 <sproingie> ddarius: now you're talking
20:36:20 <monochrom> Programming languages are the goto of programming. Let's remove...
20:36:32 <kmc> ddarius, wouldn't it be nicer if you could define mixfix operators?
20:36:38 <kmc> anyone want to back-port that feature from Agda?
20:36:44 <sproingie> kmc: sounds hellish to parse
20:36:56 <sproingie> huh agda has mixfix?
20:36:56 <kmc> yeah i don't know how Agda does it, but it seems to work
20:36:56 <Axman6> heh
20:37:01 <Axman6> nice idea though
20:37:04 <Axman6> sproingie: yep
20:37:05 <roconnor_> >ord '\n'
20:37:06 <kmc> if_then_else_ True x y = x
20:37:07 <Cale> Beginners are confusing to beginners. I move that we remove them from the language altogether.
20:37:07 <roconnor_> > ord '\n'
20:37:09 <lambdabot>   10
20:37:18 * ddarius wonders if which of OBJ3's or Agda's fixity definition abilities are more advanced.
20:37:43 * ddarius seconds Cale's proposal.
20:37:44 <ivanm> ddarius: the one that's hardest to understand
20:37:50 <ivanm> Cale: heh
20:38:12 <ddarius> ivanm: You can declare: _ _ : A x List A -> List A in OBJ3
20:38:12 <ivanm> @remember Cale Beginners are confusing to beginners. I move that we remove them from the language altogether.
20:38:14 <lambdabot> It is stored.
20:38:28 <ivanm> ddarius: and wtf does that mean?
20:38:40 <Axman6> kmc: i do like how they have basically eliminated _ in tames in agda that way. i hate underscores in names -_- (this to me doesn't count)
20:39:05 <kmc> (_|_)
20:39:07 <ddarius> ivanm: That you could write, 1 2 3 4 5 [] for [1,2,3,4,5]
20:39:20 <ivanm> OK...
20:40:15 <monochrom> So it seems "_ _ : A x List A -> List A" is defining space.
20:40:16 <osaunders> foldr = folder, foldR = fold right
20:40:22 <Saizan> can you differentiate between _  _ and _ _ ?
20:40:23 <kmc> template<typename T> std::vector<T> operator , (const std::vector<T>& a, const T& b)
20:40:28 <ddarius> monochrom: Juxtaposition, yes.
20:40:35 <ddarius> Saizan: I doubt it.
20:40:42 <kmc> Saizan, in Agda you can use like seventeen different flavors of unicode space
20:41:07 <Axman6> osaunders: there is only foldr, which is fold right
20:41:08 <monochrom> strawberry unicode space
20:41:18 <sohum> oh gods
20:41:18 <kmc> i'm not sure if the lex the same
20:41:19 <osaunders> Axman6: But it should be foldR.
20:41:21 <Axman6> @hoogle foldR
20:41:21 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
20:41:22 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
20:41:22 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
20:41:25 <Niccus> can one define unicode function names yet?
20:41:26 <ddarius> monochrom: Mint chocolate chip unicode space
20:41:28 <sohum> you've just given me an awful, horrible idea
20:41:29 <Axman6> osaunders: why should it be?
20:41:39 <Saizan> Niccus: in haskell? yes
20:41:43 <osaunders> Because right is a separate word.
20:41:51 <Axman6> so?
20:41:59 <Axman6> if it was foldRight, then sure
20:42:02 <osaunders> That's how camel case works.
20:42:04 <monochrom> foldR is a royal pain to type.
20:42:13 <sproingie> amd sohum got an idea.  an awful idea.  sohum got a most horrible awful idea
20:42:19 <Cale> @hoogle foldArrrrMatey
20:42:19 <lambdabot> No results found
20:42:23 <kmc> @yarr
20:42:24 <lambdabot> I heard andersca is a pirate
20:42:30 <sohum> @let ¬† = (+)
20:42:31 <lambdabot>   Parse error: Equals
20:42:48 <monochrom> And let's not start foldLPrime
20:42:49 <Saizan> nice error
20:42:50 <sohum> @let ‚ÄÄ = (+)
20:42:51 <ddarius> sohum: Unicode space is a space character.
20:42:51 <lambdabot>   Parse error: Equals
20:43:01 <sohum> all of them?
20:43:14 <ddarius> Hopefully.
20:43:18 <sproingie> anything with the whitespace character property
20:43:20 <sohum> @let ·†é = (+)
20:43:20 <Axman6> osaunders: we have our own naming conventions. there's no soecific rules, just convention
20:43:21 <lambdabot>   Parse error: Equals
20:43:37 <kmc> we need an AbstractNamedSingletonFoldFactoryManager
20:43:44 <Niccus> @let ‚öô = 0
20:43:45 <lambdabot>   Parse error: VarSym "\9881"
20:43:45 <Saizan> > filter isSpace [minBound .. ]
20:43:46 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
20:43:48 <kmc> otherwise there is no way haskell can compete in the enterprise
20:43:52 <Axman6> specific*
20:43:55 <sohum> @let „ÄÄ = (+)
20:43:57 <lambdabot>   Parse error: Equals
20:44:04 <sohum> ok, fair enough
20:44:17 <sproingie> kmc: sure, just get the AbstractNamedSingletonFoldFactoryManagerFactory from AbstractNamedSingletonFoldFactoryManagerFactoryContextManager
20:44:20 <sohum> @let ·öÄ = (+)
20:44:21 <lambdabot>   Parse error: Equals
20:44:24 <monochrom> and MutualFundManager
20:44:33 <sohum> heh, that also means that counts as space
20:44:41 <ddarius> Operator characters need to be in parentheses as all others.
20:44:55 <sohum> oh, right, duh
20:44:57 <ddarius> @let = True
20:44:58 <kmc> > let _ ‚ò≠ _ = "communism!" in () ‚ò≠ ()
20:44:58 <lambdabot>   Parse error: Equals
20:45:00 <lambdabot>   "communism!"
20:45:02 <sproingie> yay enterprise haskell
20:45:03 <sohum> I completely forgot
20:45:21 <Axman6> kmc: ha
20:45:25 <sohum> @let (‚ÄÄ) = (+)
20:45:27 <lambdabot>  <local>:5:6:
20:45:27 <lambdabot>      Couldn't match expected type `()'
20:45:27 <lambdabot>             against infe...
20:45:35 <sohum> ...
20:45:47 <ddarius> It parsed that as: let () = (+)
20:45:52 <sproingie> i am so going to use a hammer and sickle operator in my next program
20:45:53 <sohum> oooh
20:46:03 <ivanm> @slap sproingie
20:46:04 * lambdabot slaps sproingie
20:46:07 <ivanm> commie bastard!
20:46:08 <ivanm> :p
20:46:26 <sohum> :t (·öÄ)
20:46:28 <lambdabot> Not in scope: `???'
20:46:30 <Axman6> http://www.ittc.ku.edu/csdl/fpg/ChalkBoard <- looks quite nice (though the docs are sort of lacking)
20:46:36 <ivanm> yeah
20:46:58 <medfly> lol
20:46:59 <kmc> let (‚ò†) = unsafePerformIO
20:47:06 <medfly> that's better kmc
20:47:40 <sohum> @let (Ôªø) = (+)
20:47:41 <lambdabot>   Illegal character ''\65279''
20:47:46 <sohum> dammit.
20:47:51 <monochrom> > let (&*^) = negate in 5
20:47:53 <lambdabot>   5
20:47:59 <mmorrow> ivanm: no, hpaste.org is.
20:47:59 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
20:48:02 <monochrom> Interesting, it parses.
20:48:11 <ivanm> mmorrow: OK, because lambdabot only seems to know about yours... >_>
20:48:11 <sproingie> why wouldn't it?
20:48:12 <monochrom> > let (&*^) = not in 5
20:48:14 <lambdabot>   5
20:48:19 <idnar> oh dear
20:48:23 <idnar> my terminal went blank
20:48:23 <ddarius> monochrom: Why wouldn't it parse?
20:48:25 <mmorrow> actually, could an admin change the link in the /topic from moonpatio.com to hpaste.org?
20:48:28 <monochrom> I am not complaining.
20:48:34 <idnar> I guess somebody was playing with unicode
20:48:36 <sproingie> pretty much any string of punctuation can be used infix
20:48:42 <ivanm> @where ops
20:48:43 <mmorrow> ivanm: ah yeah, that too
20:48:44 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:48:51 <sproingie> i kind of wish i could use word characters in infix
20:48:59 <monochrom> except not cannot be used infix
20:49:17 <sproingie> but that would mean mandatory whitespace token separation.  which is fine by me, but not how haskell rolls i guess
20:49:23 <Axman6> ivanm: ?
20:49:27 <monochrom> So this is ghc not caring about arity!
20:49:30 <ivanm> Axman6: ?
20:49:31 <ddarius> monochrom: Parsing wouldn't be the problem there.
20:49:37 <mmorrow> Axman6: could you change moonpatio.com to hpaste.org in the /topic?
20:49:37 <monochrom> > let (&*^) = True in 5
20:49:39 <lambdabot>   5
20:49:49 <monochrom> It is so not caring about arity :)
20:50:03 <ddarius> Operators don't have a defined arity.
20:50:04 <sproingie> sure because you're not using it
20:50:10 <sohum> @let () = (+)
20:50:11 <lambdabot>  <local>:5:5:
20:50:12 <lambdabot>      Couldn't match expected type `()'
20:50:12 <lambdabot>             against infe...
20:50:16 <sohum> grrr.
20:50:18 <sohum> ok, fine
20:50:22 <monochrom> > let (&*^) = True in (&*^)
20:50:24 <lambdabot>   True
20:50:34 <sproingie> () is probably making it a pattern match
20:50:35 <sohum> I can't have my dream of going 5 4 = 9
20:50:45 <ddarius> monochrom: The only issue is whether (1 +) desugars to (+) 1 or \x -> 1+x
20:50:45 <kmc> > let 2 + 2 = 5 in 2 + 2
20:50:47 <lambdabot>   5
20:50:47 <medfly> why not 20, sohum
20:50:51 <sproingie> > let () = () in 5
20:50:52 <monochrom> Of course 5 4 = 54.
20:50:53 <lambdabot>   5
20:51:02 <kmc> > let (+) = (++) in "2" + "2"
20:51:05 <lambdabot>   "22"
20:51:12 <sproingie> kmc: yay, it's almost like javascript
20:51:20 <medfly> :))
20:51:23 <sproingie> except javascript makes that work with 2 + "2"
20:51:28 <ddarius> sproingie: It would take quite some effort to get it like javascript.
20:51:30 <mmorrow> instance Num [a] where (+) = (++); ...
20:51:30 <medfly> heh
20:51:32 <ivanm> @slap kmc
20:51:33 * lambdabot hits kmc with an assortment of kitchen utensils
20:52:02 <mmorrow> .. fromInteger = flip replicate undefined; ...
20:52:04 <ddarius> mmorrow: Unary numbers.
20:52:08 <mmorrow> .. fromInteger = flip replicate undefined . fromInteger; ...
20:52:11 <monochrom> "you didn't put 2 and 2 together to get... 22"
20:52:16 <sohum> > let 5 = \b -> read ("5" ++ b) in 5 4
20:52:18 <lambdabot>   No instance for (GHC.Num.Num ([GHC.Types.Char] -> a))
20:52:18 <lambdabot>    arising from the l...
20:52:19 <kmc> > let (+) :: (Read a, Num a) => a -> a -> a; a + b = read ((show a) ++ (show b)) in 2 + 3
20:52:21 <lambdabot>   23
20:52:21 <ddarius> mmorrow: genericReplicate
20:52:30 <mmorrow> heh
20:52:35 <mmorrow> oh wait
20:52:39 <mmorrow> that exists
20:52:49 * mmorrow clearly doesn't use generic*
20:52:56 <mmorrow> @type genericReplicate
20:52:58 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
20:53:45 <medfly> :)
20:53:51 <monochrom> We can tell them we have generic programming in a library. genericLength...
20:53:52 --- mode: ChanServ set +o Saizan
20:54:11 <mmorrow> Saizan: thanks
20:54:39 --- topic: set to '["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Saizan
20:55:10 <ddarius> monochrom: We do have generic programming in a library.  It is just slow, complicated, and ugly and probably buggy.
20:55:11 <copumpkin> omg
20:55:14 * mmorrow wonders if the topic is valid haskell code on purpose
20:55:21 <ddarius> mmorrow: It is.
20:55:23 <copumpkin> there's a @topic-cons
20:55:24 <mmorrow> :)
20:55:27 <ddarius> @help topic
20:55:28 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
20:55:34 <mmorrow> nice
20:55:42 <medfly> it is a bit annoying, because it's hard to click links like that.
20:55:42 <copumpkin> @topic-tell
20:55:42 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:55:49 <monochrom> Is there a topic-foldr
20:55:53 --- mode: Saizan set -o Saizan
20:56:03 <monochrom> and topic-genericLength <duck>
20:56:08 <medfly> @topic-tail
20:56:09 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:56:40 <sohum> instance Num a => Num (a -> a) where fromInteger k = \x -> fromInteger . read (show x ++ show k)
20:56:43 <Saizan> medfly: improve your client
20:56:47 <copumpkin> looks like @topic-fail to me
20:56:47 <sohum> I /think/ that'll work
20:56:55 <mmorrow> haha
20:56:58 <mmorrow> @topic-fail
20:56:58 <lambdabot> Plugin `topic' failed with: Prelude.last: empty list
20:57:08 <Axman6> mmorrow: i'm not an op here, so no, i can't :(
20:57:10 <davidL> @topic-tell #haskell
20:57:11 <lambdabot> ["Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "#haskell-in-depth launched!", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "
20:57:11 <lambdabot> http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
20:57:17 <sproingie> a TH equivalent of perl's qw() perhaps?
20:57:29 <mmorrow> Axman6: ah, i thought i remembered you opping once
20:57:55 <mmorrow> , [$here|"""""""""""""""""""""""""""""""""""""""""|]
20:57:57 <lunabot>  "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"...
20:58:03 <mmorrow> s/here/qw/
20:58:12 <copumpkin> mmorrow: I think someone opped him once
20:58:19 <mmorrow> ahh
20:58:19 <copumpkin> but it wasn't a chanserv thing
20:58:21 <Axman6> not that i remember...
20:58:28 <c_wraith> > fix show
20:58:28 <sproingie> , [$here|foo bar baz]
20:58:29 <lunabot>  luna: lexical error in string/character literal at end of input
20:58:30 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
20:58:36 <sproingie> , [$here|"foo bar baz"]
20:58:37 <lunabot>  luna: lexical error in string/character literal at end of input
20:58:37 <mmorrow> |]
20:58:43 <copumpkin> Axman6: you realize you're going to force me to browse all the logs to find evidence of my statement now :(
20:58:46 <sproingie> doesn't look much like qw to me
20:58:46 <mmorrow> , [$here|"foo bar baz"|]
20:58:47 <copumpkin> don't make me do it
20:58:48 <lunabot>  "\"foo bar baz\""
20:58:59 <mmorrow> you need to end it in |]
20:59:05 <sproingie> qw creates a list
20:59:13 <Axman6> i'd like to be an op, since i'm often here when there are trolls/spammers, and most of the other ops are asleep
20:59:23 <sproingie> i've seen $here, it's for multiline strings
20:59:24 <mmorrow> sproingie: oh
20:59:26 <ddarius> sproingie: A String is a list...
20:59:30 <Axman6> but dobblego is often here too
20:59:36 <monochrom> Axman6 is troll magnet? <duck>
20:59:39 <mmorrow> sproingie: refresh my memory on qw
20:59:44 <sproingie> ddarius: in that case qw would create a list of lists
20:59:52 <mmorrow> qw|a s d fr| = ?????
20:59:59 <ddarius> sproingie: What that $here stuff does is generalizable to arbitrary munging of text.
21:00:05 <sproingie> ["a", "s", "d", "fr"]
21:00:20 <mmorrow> oh, it'd be trivial to have the QQ do that
21:00:20 <Axman6> copumpkin: yes, i am aware, and i demand you go forth and prove me wrong!
21:00:24 <ddarius> mmorrow: $here + words
21:00:25 <sproingie> er for perl, using () instead of []
21:00:29 <copumpkin> Axman6: :(
21:00:46 * mmorrow has an idea
21:00:54 * medfly too
21:01:09 <Axman6> , words [$here|"foo bar baz"|]
21:01:11 <lunabot>  ["\"foo","bar","baz\""]
21:01:12 <kmc> , words [$here|foo bar baz |]
21:01:14 <lunabot>  ["foo","bar","baz"]
21:01:16 <sproingie> yah i guess that'd do it
21:01:21 <ddarius> , [$(here . words)|foo bar baz|]
21:01:22 <lunabot>  luna: parse error on input `|]'
21:01:26 <copumpkin> bah, too much work
21:01:37 <mmorrow> , let test = (fromJust.fromDynamic.eval) "QuasiQuoter (litE . stringL) (litP . stringL)" in [$test|42|]
21:01:38 <lunabot>  luna: GHC stage restriction: test
21:01:43 <mmorrow> grr
21:01:47 <mmorrow> oh right
21:01:50 <sproingie> whee
21:01:52 <kmc> haha
21:01:57 <kmc> , eval "2+3"
21:02:00 <lunabot>  <<Integer>>
21:02:04 <kmc> :O
21:02:08 <kmc> , fromDynamic $ eval "2+3"
21:02:10 <mmorrow> aww crap, you can't persist bindings across eval
21:02:11 <lunabot>  Nothing
21:02:15 <kmc> , fromDynamic $ eval "2+3" :: Int
21:02:16 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
21:02:17 <mmorrow> as eval currently is..
21:02:18 <mmorrow> :(
21:02:19 <kmc> , fromDynamic $ eval "2+3" :: Integer
21:02:20 <lunabot>  luna: Couldn't match expected type `GHC.Integer.Internals.Integer'
21:02:23 <kmc> , fromDynamic $ eval "2+3" :: Maybe Integer
21:02:26 <lunabot>  Just 5
21:02:28 <sproingie> yay
21:02:30 <copumpkin> fancy
21:02:42 <sproingie> what is that using?
21:02:48 <kmc> most likely, hint
21:02:50 <mmorrow> , (fromJust.fromDynamic.fromJust.fromDynamic) (eval "eval \"42\"")) :: Integer
21:02:51 <lunabot>  luna: parse error on input `)'
21:02:54 <Saizan> itself.
21:02:57 <copumpkin> luna!
21:03:01 <mmorrow> luna ftw!
21:03:07 <mmorrow> , (fromJust.fromDynamic.fromJust.fromDynamic) (eval "eval \"42\"") :: Integer
21:03:09 * copumpkin howls
21:03:10 <lunabot>  42
21:03:12 <kmc> is source to luna available somewhere?
21:03:20 <kmc> , fix eval
21:03:20 <sproingie> how's it compare to mueval?
21:03:21 <lunabot>  luna: Couldn't match expected type `[GHC.Types.Char]'
21:03:26 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Eval/GHC.hs
21:03:35 <mmorrow> http://moonpatio.com/repos/lunabot/Luna/Bot/Eval.hs
21:04:54 <kmc> mmorrow, cool
21:05:04 <mmorrow> sproingie: mueval uses hint
21:05:16 <sproingie> ah
21:05:38 <kmc> mmorrow, what's the advantage of using GHC api directly instead of hint?
21:06:51 <mmorrow> kmc: lunabot started out as me trying to grok the bytecode compile/link/eval machinery to try to be able to define datatypes in ghci, then ended up figuring out how it worked, pulling out the parts of the ghc-api i needed (and changing them minorly), and making a hackish bot program that used this evaluator
21:07:49 <kmc> cool
21:07:53 <mmorrow> kmc: i guess which one is advantageous or not depends on what you're trying to achieve/do/learn
21:08:12 <mmorrow> kmc: clearly i failed with my original objective :)
21:09:26 <mmorrow> but i've got a rough idea of what it would take to do it (it would involve adding a bunch of stuff, and being able to write that stuff would require intimate knowledge of how a whole lot of ghc interacts and works together)
21:09:54 <mmorrow> which once i realized, i immediately ran screaming in horror :)
21:11:56 <Axman6> > sum . take 10 . map (1/) $ [1..]
21:11:57 <lambdabot>   2.9289682539682538
21:12:17 <Axman6> > sum . take 10 . map ((1/) . (2^)) $ [1..]
21:12:18 <lambdabot>   0.9990234375
21:12:24 <Axman6> > sum . take 100 . map ((1/) . (2^)) $ [1..]
21:12:25 <lambdabot>   1.0
21:12:30 <Axman6> > sum . take 100 . map ((1/) . (2^)) $ [1..] :: CReal
21:12:31 <lambdabot>   0.9999999999999999999999999999992111390948
21:12:52 <copumpkin> > showCReal 100 . sum . take 100 . map ((1/) . (2^)) $ [1..]
21:12:53 <lambdabot>   "0.999999999999999999999999999999211139094778988194588271434717213770326793...
21:13:03 <kmc> > pi :: CReal
21:13:04 <lambdabot>   3.1415926535897932384626433832795028841972
21:13:10 <kmc> i demand more pi
21:13:17 <kmc> > exp 1 :: CReal
21:13:18 <copumpkin> > showCReal 100 pi
21:13:19 <lambdabot>   2.7182818284590452353602874713526624977572
21:13:19 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
21:13:32 <kmc> ah, the show instance is finite?
21:13:32 <Axman6> > exp x
21:13:33 <lambdabot>   exp x
21:13:37 <Axman6> yes
21:13:37 <copumpkin> yeah
21:13:44 <Axman6> showCReal 20 or something
21:13:44 <Gracenotes> 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104
21:13:51 <kmc> @quote pi
21:13:53 <lambdabot> monochrom says: That does not explain why people struggle with Haskell, a language that is a clean break from other computer languages. However, I can also offer a way out: people preconceive
21:13:53 <lambdabot> Haskell to be "just another computer language", and so they are tricked. If you sold it as "the mother tongue of Martians", perhaps they'll actually pick it up comfortably. :)
21:13:55 <copumpkin> Gracenotes: NEED MOAR
21:13:55 <Axman6> Gracenotes: NOT ENOUGH PI!
21:14:04 <Gracenotes> 3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160
21:14:06 <Gracenotes> 943305727036575959195309218611738193261179310
21:14:08 <copumpkin> MOAR!
21:14:12 <mmorrow> lol
21:14:17 <Gracenotes> I shall not give into the temptation
21:14:46 <Gracenotes> practice your hedonism elsewhere. http://www.exploratorium.edu/pi/Pi10-6.html
21:15:37 <copumpkin> NEED MOAR
21:15:54 * medfly injects copumpkin some antipsychotics.
21:16:01 <copumpkin> ahh
21:16:02 <copumpkin> thanks
21:16:16 <Gracenotes> anti-pi-chotics, you mean
21:16:17 <jmcarthur> > last $ showCReal 1000001 pi
21:16:22 <lambdabot>   mueval-core: Time limit exceeded
21:16:24 <medfly> hehehe
21:16:32 <copumpkin> > last $ showCReal 100001 pi
21:16:33 <jmcarthur> well, that would have been moar pi
21:16:36 <lambdabot>   mueval-core: Time limit exceeded
21:16:38 <Gracenotes> kmc: CReal is arbitrary precision. but even an arbitrarily high number is an exact number.
21:16:41 <copumpkin> CReal is slow!
21:17:00 <roconnor_> @type getChar
21:17:02 <lambdabot> IO Char
21:17:03 <Niccus> sin $ 2017 * (2 ** 0.2)
21:17:07 <Niccus> > sin $ 2017 * (2 ** 0.2)
21:17:08 <lambdabot>   -1.0
21:17:11 <copumpkin> it'd be funny if the default show instance gave infinite digits
21:17:28 <roconnor_> > sin $ 2017 * (2 ** 0.2) :: CReal
21:17:29 <lambdabot>   -0.9999999999999999785677712610609832590685
21:17:39 <copumpkin> Niccus: omg, that's 2012 + 5, thus proving that the end of the world is in 2012!!!!!11 run !!!!
21:17:51 <medfly> lol
21:17:57 <Gracenotes> :.
21:18:07 <Axman6> copumpkin: FFFFFFFFFFUUUUUUUUUUUUUUUUUUUU :O
21:18:17 <jmcarthur> actually it would be nice if the default show instance gave an expression which would generate the value when evaluated
21:18:27 <mmorrow> MPFR is arbitrary precision, but i don't know how to get it to actually show all the digits it has squirreled away
21:18:35 <mmorrow> , pi / (10^1000000000) :: MPFR
21:18:36 <lunabot>  0
21:18:39 <mmorrow> hah
21:18:43 <jmcarthur> show (pi :: CReal) == "pi"
21:18:46 <mmorrow> ok, maybe *almost* arb prec
21:18:51 <mmorrow> , pi / (10^1000000) :: MPFR
21:18:52 <lunabot>  3.141587888106523e-1000000
21:19:00 <copumpkin> MPFR?
21:19:04 <Axman6> :o
21:19:08 <copumpkin> multiprecision floating real? :o
21:19:09 <copumpkin> :P
21:19:12 <mmorrow> it's a binding to the C lib from hackage
21:19:24 <Gracenotes> for some libraries, you do need to specify a precision before calculation. compared to CReal, where you only need to specify one when showing. which, I suppose, determines the calculation amount
21:19:26 * jmcarthur pronounces it "em piffer" in his head
21:19:35 <mmorrow> someone in here suggested it once when we were trying to compute this formula Cale had
21:20:20 <manju>  I
21:20:24 <manju> heh
21:20:33 <Axman6> how profound!
21:20:35 <Axman6> :P
21:20:45 <manju>  no colors allowed
21:21:07 <manju> I was testing the trueness of the statement
21:21:12 <Gracenotes> that is the job of +c
21:21:25 <mtnviewmark> it would be so nice if cabal told you about all the missing packages that caused a package to not link and install all at once instead of one by one
21:21:29 <Gracenotes> #haskell-blah is a liberated place
21:21:30 <lunabot>  luna: parse error on input `|]'
21:21:54 <Niccus> > (**2) . (/ pi) . log $ 640320 ^ 3 + 744 :: MPFR
21:21:55 <lambdabot>   Not in scope: type constructor or class `MPFR'
21:21:59 <mmorrow> i love how i failed to think of the fact that we're on irc when choosing the char '#'
21:22:13 <Niccus> , (**2) . (/ pi) . log $ 640320 ^ 3 + 744 :: MPFR
21:22:14 <lunabot>  162.999999989367
21:22:27 <mmorrow> , (**2) . (/ pi) . log $ 640320 ^ 3 + 744 :: Double
21:22:29 <lunabot>  162.99999999999997
21:22:36 <Gracenotes> / this seems like a good character to use
21:22:43 <mmorrow> yay, a legitimate use of MPFR!
21:22:52 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. floor . sqrt . fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 10000 $ exp 1
21:22:54 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
21:22:54 <lambdabot>         agains...
21:23:23 <Saizan> mh, showCReal is not as lazy as i expected
21:23:50 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. floor . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 10000 $ exp 1
21:23:55 <lambdabot>   mueval-core: Time limit exceeded
21:23:59 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. floor . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 1000 $ exp 1
21:24:02 <lambdabot>   [3490763233,1573834187,4841984443,7683964243,4563549061* Exception: Prelude...
21:24:14 <jmcarthur> o_O
21:24:17 <mmorrow> wut
21:24:25 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. ceil . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 1000 $ exp 1
21:24:27 <lambdabot>   Not in scope: `ceil'
21:24:32 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. ceiling . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 1000 $ exp 1
21:24:32 <mmorrow> > drop 4 (let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. floor . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . iterate (drop 10) . drop 2 . showCReal 1000 $ exp 1)
21:24:35 <lambdabot>   [4563549061* Exception: Prelude.read: no parse
21:24:35 <lambdabot>   [3490763233,1573834187,4841984443,7683964243,4563549061* Exception: Prelude...
21:24:45 <kmc> none of those are the right answer :/
21:24:54 <kmc> @google first 10-digit prime found in consecutive digits of e dot com
21:24:56 <lambdabot> No Result Found.
21:25:11 <kmc> ironically, google is the easiest way to solve this puzzle
21:25:23 <mtnviewmark> is it really true that if you want to profile something, you're going to need to  have profiling versions of EVERY package it depends on installed?
21:25:26 <kmc> yes
21:25:45 <mtnviewmark> oy
21:25:48 <Gracenotes> mtnviewmark: not as painful as it sounds, since Haskell compiling doesn't tend to take forever. but, yeah :/
21:26:02 <mtnviewmark> actually very painful for two reasons:
21:26:34 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. ceiling . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . tails . drop 2 . showCReal 1000 $ exp 1
21:26:36 <mtnviewmark> 1) cabal install --reinstall doesn't chase dependencies for you
21:26:39 <mtnviewmark> 2) I don't HAVE the profliing libs for cairo and gtk2hs --- and they don't install with cabal
21:26:41 <lambdabot>   mueval-core: Time limit exceeded
21:26:44 <Axman6> mtnviewmark: this is why you change cabal-install's config to always use profiling
21:26:53 <kmc> > let ip :: Integer -> Bool; ip n = not $ any ((==0) . (n `mod`)) [2 .. ceiling . sqrt $ fromIntegral n] in filter ip . map read . map (take 10) . tails . drop 2 . showCReal 500 $ exp 1
21:26:57 <lambdabot>   [7427466391,7413596629,6059563073,3490763233,2988075319,1573834187,70215408...
21:27:09 <Gracenotes> mtnviewmark: debian ghc libraries all have profiling binaries
21:27:15 <kmc> that's the one
21:27:17 <Saizan> @google gtk2hs
21:27:19 <lambdabot> http://www.haskell.org/gtk2hs/
21:27:19 <lambdabot> Title: Gtk2Hs
21:27:19 <mtnviewmark> well... I'm on a mak
21:27:25 <mtnviewmark> er mac
21:27:28 <Niccus> , ((-)262537412640768256) . exp . (pi *) $ sqrt 163 :: MPFR
21:27:30 <lunabot>  -718043488
21:27:34 <Saizan> download and build!
21:27:40 <Axman6> ght2hs is broken on OS X anyway
21:28:00 <mtnviewmark> what Ax said
21:28:04 <mtnviewmark> I can't get it to build
21:28:15 <Niccus> , ((-) 262,537,412,640,768,743) . exp . (pi *) $ sqrt 163 :: MPFR
21:28:16 <lunabot>  luna: Couldn't match expected type `b -> c'
21:28:24 <Niccus> oh dammit stop doing stupid thingsme
21:28:27 <Axman6> in fact, a hell of a lot of the haskell world is broken on OS X sadly.
21:28:38 <Niccus> , ((-) 262537412640768743) . exp . (pi *) $ sqrt 163 :: MPFR
21:28:39 <lunabot>  -718043001
21:28:53 <mtnviewmark> actually - I've found most things I've poked at just work fine
21:28:54 <Axman6> the #1 trac ticket by number of people CC'd is my 64 bit OS X ticket
21:28:56 <scutigera> Axman6: I know I gave up.  amd64 for me... too bad, I really like the PPC.
21:29:10 <mtnviewmark> (though we should standardize on locations for things:  /Libaray/Haskell)
21:29:25 <Axman6> scutigera: huh?
21:29:53 <scutigera> Axman6: had too much trouble with ghc under PPC, so I swapped computers :-)
21:30:01 <Axman6> good plan
21:30:03 <mtnviewmark> which ticket is that, Axman6?
21:30:19 <scutigera> Axman6: I guess you could be running intel os x...
21:30:21 <Axman6> mtnviewmark: the ticket trying to get a 64 bit version of GHC for OS X
21:30:26 <kmc> x86 is such a crap architecture
21:30:31 <Axman6> scutigera: yes
21:30:33 <kmc> at least they fixed some of the worst bits when going to 64-bit
21:30:50 <Axman6> i won't be getting my MBP back until moday at the earliest :(
21:31:01 <scutigera> Axman6: ok, well it's WORSE under PPC, much worse...  as in assembler errors
21:31:02 <inertial> 600 users! haskell has become popular in the last few years...
21:31:03 <Axman6> (almost wrote 'until monad' there)
21:31:11 <mtnviewmark> ah - I'm merrily working with the 32bit version even on my 64-bit snow leopard machine
21:31:11 <Axman6> scutigera: i know, i've got a G5 too :)
21:31:18 <ddarius> @quote monady
21:31:19 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
21:31:28 <ddarius> @quote Monady
21:31:28 <kmc> @quote gonad
21:31:29 <lambdabot> No quotes match. You untyped fool!
21:31:30 <lambdabot> No quotes match. I am sorry.
21:31:33 <manju> bbiab..rebooting to install video driver
21:31:43 <Axman6> gross
21:31:51 <scutigera> Axman6: works good under amd64 and debian, but I'm confused about all of the libghc6's and how that's supposed to work with cabal...
21:32:30 <cads> man, do you guys remember the cyberpunk movement where we thought that by now we'd all be writing programs in 3d virtual space, putting together abstract crystalline blocks representing program components?
21:32:40 <medfly> inertial, totally, man! I mean, just look at ##c - it's smaller! Haskell is more popular than C!
21:32:45 <scutigera> cads: yeah, I do that, don't you ?
21:32:58 <mmorrow> kmc: yeah, compared to x86, x86_64 is heaven
21:33:01 <cads> nah, I program in 2d base-code
21:33:04 <scutigera> got a flying car in the garage too.
21:33:07 <Saizan> well, it's simple, both the libs you get from apt-get and cabal get registered with ghc-pkg
21:33:08 * ddarius wouldn't want to do that and also doubts that was the history of "cyberpunk"
21:33:32 <mmorrow> the C calling convention puts the first *6* args in registers, no more stack fondling in the common case
21:33:38 <cads> ddarius, they had some interesting idea about how programming languages were going to evolve
21:33:43 <cads> ideas*
21:34:11 <drhodes> they've evolved my ideas :3
21:34:15 <scutigera> Saizan: so there is no conflict ? For example unix wouldn't work under cabal, but deb pkg was good.  so could I upgrade it via cabal ??
21:34:28 <mmorrow> also on x86_64 there's at least a couple registers available that aren't tied to something or other
21:34:28 <inertial> are there any haskell cross compilers for ARM processors?
21:34:34 <medfly> cads, if only people would know that in 2009 we'd still be using vi
21:34:47 * ddarius uses vim.
21:34:55 <medfly> okay vim
21:35:07 <cads> what happened, yo?
21:35:21 <mmorrow> ooh, and pc-relative addressing on x86_64!
21:35:35 <cads> :P
21:35:52 <mmorrow> yay! now you don't have to resort to hackery to get the value of pc!
21:35:58 <mmorrow> what a concept!
21:36:04 <Saizan> scutigera: there are two package dbs, a global and and user one, by default cabal installs in the second, so it will see but won't mess with the ones installed from debian repos since they go in the global one
21:36:19 <cads> yeah we were supposed to have aintelligent data hounds to sniff from database to database and such
21:36:25 <cads> ... we have google...
21:36:25 <scutigera> Saizan: got it.
21:36:26 <ddarius> call $; pop eax
21:36:35 <mmorrow> and you can address relative to it! another ground-breaking idea!
21:36:38 <Axman6> ha, "arduino shield for arduino". awesome
21:36:40 <scutigera> cads: we have the nsa
21:36:46 <mmorrow> ddarius: hax!
21:36:50 <Saizan> scutigera: as for upgrading unix, it probably didn't go through because cabal was trying to install the latest version on hackage which is not compatible with your ghc
21:37:08 <ddarius> mmorrow: I know I used IP relative addressing all the time...
21:37:14 <copumpkin> zomg
21:37:14 <Saizan> scutigera: that happens when the information in .cabal files is partial or wrong
21:37:20 <medfly> it's funny. it's like some programmer from the past would show up now and be disappointed going like, "I expected more of you guys"
21:37:34 <ddarius> Saizan: The package doesn't compile (usually)
21:37:38 <mmorrow> ddarius: were you writing PIC code?
21:37:53 <ddarius> mmorrow: No, I was being sarcastic.
21:37:55 <cads> medfly, then you'd introduce him to his future self
21:37:58 <copumpkin> position independent code code?
21:38:00 <mmorrow> ddarius: ah
21:38:03 <medfly> cads, "oh god."
21:38:03 <mmorrow> copumpkin: yesh!
21:38:16 <copumpkin> :)
21:38:18 <scutigera> Saizan: that is pretty much what happened, it failed on the link (I think), something or other missing.  Thanks for the explanation.
21:38:35 <Saizan> ddarius: it didn't compile because the wrong version was chosen :)
21:38:47 <ddarius> Saizan: I misread "that" as "what"
21:38:49 <cads> I think we've lost all sense of historical progress
21:39:07 <mmorrow> ddarius: so were you saying that you don't see pc-relative addressing as very useful? or?
21:39:14 <medfly> well, things did improve. I mean, those 1980s guys didn't even have mobile phones!
21:39:16 <mmorrow> ddarius: because that's how i took that
21:39:29 <inertial> cads: there is no more progress, go read some baudrillard
21:39:30 <ddarius> mmorrow: I'm saying, in my experience, I rarely, if ever, used it.
21:39:30 <mmorrow> ddarius: if not, i'm interested in how you meant
21:40:09 <mmorrow> ddarius: ah, ok. so you rarely if ever wrote PIC (s/code//(for copumpkin)) then
21:40:17 <cads> inertial, that sounds like some dead fuck :D
21:40:18 <copumpkin> :)
21:40:25 * copumpkin loves RAS syndrome
21:40:34 <medfly> what's RAS syndrome
21:40:42 <copumpkin> redundant acronym syndrome syndrome
21:40:47 <scutigera> I hate to ask the following for what is sure to be the umpteenth time: getCurrentTime :: IO UTCTime .  So once I have the value, why can't it ever lose the IO without being in a monad ?
21:40:47 <scutigera>  
21:40:54 <medfly> well that's one syndrome too many!
21:41:01 <cads> oh shoot
21:41:05 <Twey> Haha
21:41:20 <mmorrow> i don't even know how you could write PIC without it, well other than grabbing the PC with  "call foo; foo: pop eax", then addressing off of eax and computing offsets by hand
21:41:29 <ivanm> scutigera: because it can change
21:41:35 <Twey> scutigera: By asking that, you're misunderstanding the point of IO
21:41:35 <ivanm> so it isn't pure code, and thus must be within IO
21:41:42 * mmorrow shudders at the idea of that
21:41:59 <ivanm> scutigera: if you have a function that you want to use on that value, extract the value within IO and then run the function on the extracted value
21:41:59 <Twey> scutigera: Basically, you don't really ‚Äòhave‚Äô the value at all.
21:42:13 <Twey> We talk about ‚Äòextracting‚Äô values from IO, but that's a misnomer.
21:42:20 <scutigera> I know the mechanics but I lack some sort of insight...
21:42:25 <cads> intertial, post modernists are all closet nihilists anyways
21:42:29 * ddarius definitely does NOT talk about "extracting values from IO"
21:42:32 <Twey> Really, you're pushing another transformation into the IO
21:42:41 <kmc> mmorrow, "common case"... unfortunately my coworkers like functions with dozens of arguments
21:42:42 <copumpkin> mmorrow: isn't it wonderful
21:42:51 <Twey> So you never need to ‚Äòlose the IO‚Äô
21:42:57 <Twey> (and doing so would severely limit your program)
21:43:02 <mmorrow> kmc: sounds delightful
21:43:14 <Saizan> scutigera: the point of IO is encapsulating the code with I/O side-effects so that it's separate from pure code
21:43:28 <Twey> That said, you can use pure functions inside your IO transformation, which doesn't need to know that the value it's being supplied originally came via IO.
21:43:33 <copumpkin> there is a backdoor from IO, but it will not do what you expect it to do, even though it has the type signature you want
21:43:36 <Twey> s/doesn't/don't/
21:43:54 <mmorrow> copumpkin: printf(%rip) ?
21:43:56 <kmc> scutigera, You don't have a UTCTime.  You have a *recipe* for how to get a UTCTime.
21:44:08 <mmorrow> copumpkin: (:= what is wonderful?)
21:44:24 <copumpkin> mmorrow: that at which you were shuddering :)
21:44:26 <kmc> scutigera, so all you can do is add steps onto that recipe
21:44:31 <mmorrow> copumpkin: yay!
21:44:51 <kmc> scutigera, For example, "getCurrentTime >>= print" is a recipe that means "After you get the current time, print it"
21:45:30 <copumpkin> omnom
21:45:34 <copumpkin> i can haz recipe kthx?
21:45:39 <kmc> @quote recipe
21:45:40 <lambdabot> No quotes match. That's something I cannot allow to happen.
21:45:42 <scutigera> kmc: I have something which is IO Int.  In the do block I invoke it and now I have an int.  Why can't I return the int ?? grrrr...  Lazyness ?
21:45:52 <kmc> no it's not laziness
21:45:55 <kmc> you can return the int
21:46:02 <copumpkin> nothing can escape from the box
21:46:03 <kmc> but the type of your do block will be IO Int
21:46:04 <copumpkin> EVER!
21:46:04 <ddarius> scutigera: What makes you think you have an Int?
21:46:28 <kmc> scutigera, your do block is describing a recipe
21:46:38 <scutigera> do x <- function. function is IO Int, so isn't x an int ?
21:46:39 <kmc> it would be really astonishing if one of the steps in a recipe turned the recipe itself into a cake.
21:46:44 <copumpkin> scutigera: http://arcanux.org/lambdacats/io-monad.jpg
21:46:56 <ddarius> scutigera: What makes you think you ever get to the x <- part?
21:47:07 <scutigera> copumpkin: LOL. Seriously.
21:47:09 <kmc> scutigera, "function" is not a function
21:47:16 <kmc> scutigera, a value of type "IO Int" is not a function
21:47:27 <copumpkin> :)
21:47:42 <kmc> scutigera, but you're right that x :: Int there.  it's just that there's no way to get that Int *outside* the scope of the do-block
21:47:43 <cads> inertial; " Conclusion: if there are no more dustbins of history, this is because History itself has become a dustbin. It has become its own dustbin, just as the planet itself is becoming its own dustbin."
21:47:55 <cads> man, the guy is almost certainly happier off dead now
21:47:58 <copumpkin> the ordering of effects in the liftA/M functions bothers me for some reason
21:48:00 <scutigera> kmc: what !! function is _not_ a function...
21:48:07 <cads> 2007 was before all this 2012 bullshit
21:48:10 <scutigera> ???
21:48:17 <kmc> scutigera, getLine is not a function
21:48:18 <kmc> :t getLine
21:48:20 <lambdabot> IO String
21:48:23 <kmc> scutigera, see, it doesn't have "->" in its type
21:48:31 <ddarius> Earth isn't -becoming- its own dustbin.  It has always been that way.  Heck, it is called "earth."
21:48:43 <copumpkin> scutigera: we make a distinction between "running" something and "evaluating" something
21:48:47 <scutigera> kmc : my bad do x <- function ()
21:48:58 <kmc> scutigera, remember, in other languages functions do at least three things: argument dependence, side effects, and delayed evaluation.  in Haskell we have separate concepts for these
21:49:05 <kmc> scutigera, okay.  that makes no difference
21:49:14 <scutigera> kmc: what !!?
21:49:18 <kmc> what !!!!
21:49:19 <copumpkin> :)
21:49:21 <kmc> there's almost never a reason to apply () as an argument
21:49:22 <EvanCarroll> you think "earth" was in reference to dust before it was to everything accessable on foot?
21:49:35 * copumpkin moos vigorously
21:49:37 <kmc> scutigera, anyway, "function ()" is not a function, because you've applied it
21:49:49 <copumpkin> it might be!!
21:49:50 <copumpkin> :P
21:49:57 <kmc> copumpkin, not if you're binding it in the IO monad ;p
21:50:03 <copumpkin> hrrmpf
21:50:04 <scutigera> kmc: applied == evaluated
21:50:06 <EvanCarroll> O.E. eyr√æling "plowman" (see earth); the sense of "inhabitant of the earth" is from 1590s. Earthman was originally (1860) "a demon who lives in the earth;" science fiction sense of "inhabitant of the planet Earth" first attested 1949 in writing of Robert Heinlein.
21:50:06 <ddarius> > (do (1+); pred) 3
21:50:07 <scutigera> ?
21:50:07 <lambdabot>   2
21:50:11 <kmc> scutigera, i'm not trying to quibble terminology here; i'm trying to drive home the idea that "function" and "recipe for side effects" are two different things
21:50:19 <kmc> scutigera, evaluating "getLine" does not get any lines
21:50:28 <kmc> :t let x = getLine in x
21:50:30 <lambdabot> IO String
21:50:41 <copumpkin> _running it_ is different
21:50:45 <kmc> x is not a line from the terminal.  it's just another name for the recipe which gets a line
21:51:09 <kmc> applying arguments to a function, and evaluating it, is a completely different sort of thing than running an IO-recipe
21:51:11 <cads> ddarius, I think humans are just a little depressed now they're realizing humanity might not be this wonderful supernatural ideal we're manifesting, but just another species of life-scum
21:51:26 <copumpkin> cads: maybe this is better for #haskell-blah?
21:51:28 <copumpkin> (unlike my mooing)
21:51:37 <cads> I still hope we get to infest other planets and the galaxy tho
21:51:46 <cads> copumpkin, heh, sure
21:52:06 <ddarius> cads: All life-scum is impressive.
21:52:06 <scutigera> kmc: but at SOME point in time I make the recipe and get an int...
21:52:32 <kmc> scutigera, the only way that a recipe is executed is that it's named "main" and in your program's main module
21:52:39 <kmc> or, that you type it at the GHCi prompt
21:52:56 <cads> ddarius, agree
21:53:01 <kmc> scutigera, so you can do this:   do { y <- getLine; return y }.  inside the do block, y :: String.  but the do block *itself* has type IO String
21:53:04 * mtnviewmark hates yak shaving
21:53:05 <Twey> scutigera: You never do.  Your job is just to build up a big recipe to hand off to the runtime.
21:53:26 <scutigera> Twey: and this is not laziness related ?
21:53:37 <Twey> Mildly interrelated, but they're not the same thing
21:53:46 <ddarius> It has nothing to do with laziness.
21:53:48 <kmc> scutigera, it's only related to laziness, in that laziness is what forced the Haskell designers to take a more principled approach to side effects
21:53:55 <kmc> that is, it's only related in a historical sense
21:53:58 <Twey> (if Haskell weren't lazy then you could never construct such a huge value to pass to the runtime)
21:54:05 <kmc> the principled approach turns out to be extremely valuable, regardless of laziness
21:54:15 <scutigera> Twey: yes - that makes sense
21:54:27 <kmc> and in fact i think the principled approach to IO is one of Haskell's main assets, even though laziness remains at times a liability
21:54:29 <ddarius> kmc has it right here
21:54:37 <Twey> Aye
21:54:45 * BMeph <3's him so yak-fur blankets - so WARM! ;p
21:54:50 <Twey> Hehe
21:55:28 <Axman6> http://i.imgur.com/Y0T2W.jpg :O
21:56:04 <copumpkin> OMG
21:56:06 <copumpkin> I WANT
21:56:12 <copumpkin> (BUT I WANT IN #haskell-blah!)
21:56:14 <kmc> scutigera, in some sense you have *two* languages:  one named Haskell, with primitives like functions and applications, and one named IO, with primitives like getChar, putStr, etc.  the purpose of a Haskell program is to *build* a program in the IO language
21:56:16 * copumpkin shuffles away
21:56:25 <cads> hey is it possible to view lazy evaluation as a set of rules that match and replace subgraphs in an expression graph?
21:56:29 <BMeph> ddarius: Oh, it has something to do with laziness, just not on the *computer's* part... ;)
21:57:12 <scutigera> kmc: I keep thinking that IO's are sort of like promises from scheme, is this reasonable ?
21:57:43 <aeron> Axman6: I was honestly thinking about running out and getting one lol
21:58:10 <Axman6> aeron: send me one too please :(
21:58:24 * BMeph maintains that IO is like a jet plane filled with tiny chocolate robots! :)
21:58:28 <kmc> scutigera, no
21:58:38 <kmc> *every* value in Haskell is like a promise from Scheme
21:58:38 <Twey> scutigera: Don't think so, no
21:58:40 <scutigera> kmc: yeah, I knew you were going to say that.
21:58:42 <Twey> Yeah
21:58:43 <shachaf> BMeph: A *warm fuzzy* jet plane.
21:58:44 <Twey> That's just laziness.
21:58:53 <Berengal> Having a recepie for a cake is not the same as a promise you'll get a cake :(
21:59:01 <copumpkin> scutigera: one way to think about IOs is as a string that you build up, say in a dynamic language like ruby or python, containing statements and regular stuff. Your main eventually gets passed to ruby/python's eval function. Except it's not a string, but an opaque type called IO x
21:59:12 <kmc> an abstract datatype in fact :)
21:59:16 <BMeph> shachaf: Well, not too warm...don't want to melt the robots, y'know. ;)
21:59:17 <kmc> just like one you might define in your own module
21:59:21 <kmc> just with magic powers
21:59:28 <ddarius> copumpkin: Now you must make such an implementation of IO.
21:59:31 <shachaf> BMeph: That would be unsafe.
21:59:42 <copumpkin> ddarius: using mmorrow's luna!
21:59:50 <kmc> scutigera, the big conceptual idea here is disentangling the totally different concepts of 1) evaluation and 2) doing IO
21:59:52 <copumpkin> but then I'd be stuck with haskell again
21:59:54 <Hugglesworth> Can I ask a short typing question?
21:59:55 <kmc> because most other languages muddle them together
21:59:56 <copumpkin> guess that wouldn't help much :)
21:59:59 <kmc> Hugglesworth, sure
22:00:03 <copumpkin> Hugglesworth: is it worth the huggles?
22:00:04 <ezyang> Hugglesworth: ask away
22:00:08 <kmc> scutigera, promises and laziness have to do with (1)
22:00:08 <ezyang> "don't ask to ask"
22:00:36 <kmc> scutigera, you might *use* promises in Scheme like you'd use IO values in Haskell, but that's only because in Scheme (1) and (2) are the same
22:00:40 <scutigera> kmc: ok (1) I'm sort of clear on.
22:00:46 * BMeph pounds on GHCi: unsafePerformGetMeABigFuzzyJetPlaneFilledWithTinyChocolateRobots
22:01:02 <Hugglesworth> I'm getting a expected IO String and inferred [String] from the first line in http://pastebin.com/d61b5e4a2
22:01:09 <copumpkin> hah
22:01:11 * ddarius goes to sleep.
22:01:11 <copumpkin> another one!
22:01:15 <kmc> Hugglesworth, your "do" block is in the IO monad
22:01:20 <kmc> your return type should be IO String
22:01:47 <kmc> Hugglesworth, your function returns, not a String, but an IO-recipe which results in a String
22:01:51 <Cale> Hugglesworth: do-notation is used to glue a chain of IO actions together into a single IO action.
22:02:18 <Cale> So the whole do-expression is all one value of whatever type its last line has.
22:02:35 * Hugglesworth huggles everyone
22:02:43 <Cale> (and it must be IO t for some t, since hGetLine was in IO)
22:02:49 <Hugglesworth> well, it compiles now. Thanks
22:03:09 <Cale> You should be careful though. It never finishes.
22:03:17 <Axman6> :o
22:03:21 <Berengal> Indeed, that's an infinite loop
22:03:33 <Hugglesworth> shouldn't it hit the catch on EoF?
22:03:36 <Cale> yes
22:03:41 <kmc> Hugglesworth, but it will keep calling itself
22:03:42 <Cale> at which point line = s
22:03:45 <ezyang> return doesn't short circuit
22:03:57 <scutigera> copumpkin: how does that opaque type get evaluated, the entire program tree gets evaluated ?
22:04:00 * ezyang still hates monads for calling it return and not pure. 
22:04:01 <Hugglesworth> grr, what should I do then?
22:04:06 <kmc> Hugglesworth, yes.  "return" is poorly named -- it won't jump you out of the entire block
22:04:15 <mtnviewmark> when I have two versions of a library, is there a way for cabal to tell me if any registered library depends on the older version?
22:04:17 <copumpkin> scutigera: yeah, main has type IO a, and the runtime takes care of running "eval" on that
22:04:18 <Cale> Hugglesworth: you should determine when to stop and not call getComics again
22:04:29 <copumpkin> scutigera: so regardless of what you do, you're going to pass through IO eventually
22:04:33 <kmc> scutigera, conceptually, the haskell runtime system "interprets" your top-level value "main :: IO ()"
22:04:45 <kmc> of course in a good implementation like GHC, it all just compiles to imperative-looking assembly code
22:04:51 <Hugglesworth> setup the EoF in a if-else then?
22:04:54 <kmc> but with a much cleaner semantics on top
22:04:58 <kmc> Hugglesworth, you might want to pattern match instead
22:05:00 <Twey> ezyang: c.f. #alt-stdlib ;)
22:05:04 <kmc> i.e. several cases for getComics
22:05:06 <Cale> Hugglesworth: Yeah
22:05:06 <Hugglesworth> explain
22:05:09 <copumpkin> scutigera: but until it gets evaluated like that, you can pass IO a values around and muck with them just like you'd pass strings containing code around in a dynamic language
22:05:14 * ezyang is trying to remember what the idiomatic way of reading lines out of a file was 
22:05:14 <kmc> Hugglesworth, do you know how pattern matching works?
22:05:16 <Hugglesworth> oh, coi Twey
22:05:17 <mtnviewmark> sighs huge relief: FINALLY has Criterion installed w/profiling
22:05:28 <ezyang> Twey: is that... an irc chan?
22:05:32 <Twey> coi do
22:05:36 <Twey> ezyang: Why yes, yes it is
22:05:36 <Axman6> mtnviewmark: on OS X? :O
22:05:38 <copumpkin> yep
22:05:40 <mtnviewmark> yup!
22:05:50 <Cale> Hugglesworth: Another way is just to  fmap lines (hGetContents file)
22:05:55 <copumpkin> bos added a flag to it ages ago to disable graph dependency
22:05:56 <Axman6> leopard though right?
22:06:04 <mtnviewmark> now if I could only get Leksah to build from the source....
22:06:06 <Twey> ezyang: (hGetLine, for your other question)
22:06:35 <Cale> Hugglesworth: Or if 'file' is a Handle to an actual file, you might as well use readFile rather than openFile
22:06:37 <idnar> whoa, getComics?
22:06:46 <Hugglesworth> oh right, /that/ pattern matching
22:07:04 <mtnviewmark> (but for that, I'll have to shave the yak of rebuilding GTK+ myself on MacOSX to get the gtksourceview2 component)
22:07:10 <sohum> :t return
22:07:12 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:07:12 <sohum> :t pure
22:07:14 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
22:07:21 <mtnviewmark> Axman6 - nope - Snow Leopard
22:07:33 <sohum> > pure 1 :: [Integer]
22:07:35 <lambdabot>   [1]
22:07:40 <Berengal> There's also hIsEOF
22:07:44 <Cale> sohum: It's the same thing only more general
22:07:55 <sohum> Cale: all monads are applicative?
22:07:59 <Cale> sohum: yes
22:08:02 <Hugglesworth> I was using hIsEOF before
22:08:07 <sohum> Cale: cools
22:08:15 <Axman6> sohum: but monads also have join
22:08:27 <sohum> :t join
22:08:28 <copumpkin> what do applicatives correspond to in CT terminology?
22:08:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:08:35 <Cale> Hugglesworth: How'd you open the file in the first place?
22:08:39 <sohum> @hoogle f (f a) -> f a
22:08:41 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
22:08:41 <lambdabot> Prelude concat :: [[a]] -> [a]
22:08:41 <lambdabot> Data.List concat :: [[a]] -> [a]
22:08:48 <Hugglesworth> openFile
22:08:55 <Twey> @src join
22:08:56 <lambdabot> join x =  x >>= id
22:09:00 <Cale> Hugglesworth: Are you opening thousands of files at a time?
22:09:08 <Twey> Ahh
22:09:11 <Hugglesworth> Cale: readFile opens the entire thing right?
22:09:11 <Cale> Hugglesworth: If not, then using lazy IO is probably simpler :)
22:09:15 <mtnviewmark> Axman6 - what don't you have running on Snow Leopard?
22:09:24 <Cale> Hugglesworth: gets the contents of the file as a string, lazily
22:09:26 <Twey> Shouldn't we be recommending Iteratee or something?  :√æ
22:09:30 <Hugglesworth> I'm opening one file, and need to arrange the output per line
22:09:58 <copumpkin> iteratee is nice but it isn't exactly beginner-friendly
22:10:12 <Axman6> mtnviewmark: well, right now, nothing, it's being repaired :P but i don't think gtk2hs works, and ghc is difficult enough atm
22:10:14 <Cale> Hugglesworth: You have to be a little careful with it -- writing back into a file opened with readFile is not a great idea (because it's only read as needed)
22:10:21 <Cale> Hugglesworth: But otherwise, it's much simpler.
22:10:37 <mtnviewmark> ? I just - 10 min. ago - built gtk2hs w/ghc
22:10:54 <copumpkin> Cale: if you've adopted bloggage, might you consider twitter too? :D
22:10:57 <Cale> Twey: Hell, *I* can't understand how Iteratee is supposed to work ;)
22:11:11 <Axman6> mtnviewmark: on SL?
22:11:18 <mtnviewmark> yes
22:11:22 <Cale> copumpkin: Now why would I do that? :)
22:11:26 <Hugglesworth> I think I'll just go with what works for now and come back if I have optimization issues
22:11:27 <Axman6> well, i haven't tried for a while :)
22:11:38 <Cale> copumpkin: My blog posts are hardly blog posts :)
22:12:01 * Cale almost considers only publishing things in PDF form.
22:12:04 <mtnviewmark> Axman6 - once you do the trick to tell ghc to tell gcc "hey, I'm only 32-bit, dude" -- it all works
22:12:22 <copumpkin> Cale: because there's so much effort required to put thoughts into nice works of writing! in twitter there's no such pressure! just throw out half-assed ideas as soon as you get them and get feedback from your followers :)
22:12:23 <Axman6> mtnviewmark: i'll have to give it a go when i get my machine back
22:12:25 <mtnviewmark> that trick is documented here: http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29
22:12:40 <Cale> copumpkin: I don't understand how that's different from IRC.
22:12:52 <Cale> Everyone who I care about talking to is on IRC.
22:13:16 <copumpkin> Cale: it's also a handy way of announcing your new blog posts :P it's different from IRC in that it's persistent and you don't feel guilty for talking about whatever you feel like. It's your own space and others choose to follow you, unlike a channel
22:13:24 <copumpkin> but fair enough :)
22:13:37 <Twey> Cale: Haha
22:13:40 <Cale> I already don't feel guilty about talking about whatever I feel like here ;)
22:13:47 <copumpkin> lol ok
22:14:00 <copumpkin> sigfpe is on twitter! ;)
22:14:02 <ezyang> Cale: don't be
22:14:03 <copumpkin> and almost never on IRC!
22:14:21 <Twey> Don't be not guilty?
22:14:27 <ezyang> ya
22:14:33 <copumpkin> innocent as charged
22:14:35 <Twey> Heh
22:15:07 * Cale deletes the Data.Sequence implementation of nextPermutation as it turns out to be slower than the plain list version.
22:15:17 <ivanm> Cale: :o
22:15:23 <copumpkin> Cale: you going to refute that "C++ does it right" post?
22:15:28 <ivanm> what's nextPermutation meant to be?
22:15:39 <Cale> copumpkin: Nah, just felt like implementing the algorithm from it
22:15:52 <Cale> Twey: I got to use your splitWhen
22:15:59 <copumpkin> that post annoyed me but I was too lazy to respond
22:16:57 * ezyang never figured out how to attract blog readers 
22:17:11 <ezyang> (probably because that's the wrong mindset to approach it by)
22:17:16 <Cale> I should probably get back to writing articles...
22:17:28 <inimino> ezyang: calling other bloggers names is a popular strategy
22:17:33 <Twey> Cale: Oh really?
22:17:33 <ezyang> haha
22:17:37 <copumpkin> ezyang: you on planet?
22:17:44 <dibblego> a "C++ does it right" post?
22:17:45 <copumpkin> ezyang: advertise on twitter!
22:17:46 <copumpkin> ;)
22:17:53 <copumpkin> dibblego: yeah, almost an oxymoron, right?
22:17:57 <ezyang> getting on a planet would be a smart move
22:18:00 <Twey> Hehe
22:18:02 <dibblego> copumpkin, link?
22:18:12 <copumpkin> dibblego: http://wordaligned.org/articles/next-permutation?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+wordaligned+%28Word+Aligned%29
22:18:13 <Berengal> Huh, googling for "C++ does it right" gives only one result...
22:18:18 <Cale> Twey: yeah,  splitWhen (>) (reverse xs)  is part of my implementation of nextPermutation
22:18:22 <copumpkin> http://www.reddit.com/r/programming/comments/aahso/next_permutation_when_c_gets_it_right/
22:18:24 <ezyang> Once I disassociate myself from my revulsion at wordpress I'll try again.
22:19:07 <adu> Berengal: I got 2 results
22:19:24 <adu> and one of them is "I'm not saying that C++ does it right"
22:19:34 <osaunders> ezyang: You don't have to use Wordpress anymore.
22:19:34 <Twey> Cale: Wouldn't join (***) reverse $ splitWhen (<) be better?
22:19:46 <ezyang> osaunders: oh really?
22:20:08 <ezyang> If there's one thing that is detrimental to blogging, it's being overly fussy about your blogging software
22:20:33 <osaunders> ezyang: Yeah there are plenty of alternatives.
22:20:40 <Cale> Twey: You need to split from the other end
22:20:43 <mtnviewmark> am I right in thinking that ghc-pkg is only a registry of where various packages are --- and it doesn't understand dependency information?
22:20:46 * ezyang would totally use a Haskell blog 
22:20:50 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13533#a13533
22:21:13 <Cale> That code could probably use some golfing :)
22:21:41 <Twey> mtnviewmark: I believe so, yes
22:21:41 <Twey> Cabal takes care of dependencies and all that complicated stuff
22:21:41 <copumpkin> Cale: pity tiger woods is in trouble :(
22:21:42 <osaunders> ezyang: I quite like posterous.
22:21:42 <Twey> Arrgh
22:21:42 <Twey> Haha.
22:21:57 <mtnviewmark> so - would cabal be able to tell me if I can safely remove a package because no other installed package requires it?
22:22:05 <Cale> But it's actually not so bad performance-wise. Only a constant factor of about 5 slower than the implementation of permutations in Data.List
22:22:18 <Twey> Not bad, not bad
22:22:22 <Cale> (which was chosen from a fairly large sample of implementations for speed)
22:22:33 <adu> hi Cale
22:22:36 <Cale> hello
22:22:44 <adu> nice Thanksgiving?
22:22:49 <ezyang> osaunders: "it's not open source"
22:22:54 <Cale> Thanksgiving was months ago
22:23:07 <ezyang> Cale: ha
22:23:21 <Twey> What's Thanksgiving?  ;)
22:23:25 <adu> Cale: my TG was a week ago, and I think I have finally recovered from all the indigestion
22:23:53 * copumpkin will still accept belated thanks from adu
22:24:09 <adu> copumpkin: happy TG
22:25:00 <copumpkin> thanks!
22:25:20 <Cale> Twey: I also discovered something a little unfortunate about splitWhen is that it almost but can't *quite* replace break/span
22:25:22 <adu> btw, I think the reason why everyone is confused about Tiger Woods, is that he was abducted by aliens
22:25:45 <Cale> Twey: The reason is that it has a bias in the list of length 1 case which seems non-removable.
22:26:27 <Cale> Aside from that,  break p xs = splitWhen (\x y -> p y) xs
22:27:13 <Cale> I made the mistake of thinking that equation was universally true, but quickCheck found my mistake :)
22:27:52 <Cale> In a similar line, why are span and break missing for Data.Sequence?
22:28:08 <copumpkin> Cale: this is what you're missing out on: http://snapplr.com/y4bp
22:28:36 <BMeph> copumpkin: Have you tweeted qsort yet? :)
22:28:48 <ezyang> ...
22:28:53 <copumpkin> nope, should I? I'll probably get the pedants telling me it's not a true qsort
22:29:00 <copumpkin> RLE was fun though
22:29:19 <BMeph> copumpkin: Pedants...on Twitter? Man, that IS funny! ;)
22:29:20 <copumpkin> also, my school's broken authentication system led to a fun little golfed snippet
22:29:37 <Cale> I will try Twitter just as soon as it supports LaTeX with TikZ diagrams ;)
22:29:41 <copumpkin> lol
22:29:46 <copumpkin> Cale: in 140 characters or less ;)
22:30:53 <Cale> Each diagram should count as a character :(
22:31:49 <Cale> hehe
22:32:17 <copumpkin> I know someone who works at twitter, I'll pass on your suggestion ;)
22:32:42 <Cale> The 140 character limit is stupid anyway
22:32:55 <copumpkin> I think it's neat actually
22:33:25 <m0nkfish> why 140 anyway?
22:33:36 <osaunders_> 10 * 14
22:33:39 <Cale> I would probably just ignore it and end up writing a program to break my long messages into many smaller ones.
22:33:49 <copumpkin> it's actually 160
22:33:50 <Twey> Haha
22:33:54 <copumpkin> it's the length of an SMS
22:34:07 <copumpkin> Cale: but that would defeat the purpose! it isn't a blog replacement! :P
22:34:24 <idnar> minus 20 chars for the name, or something?
22:34:54 <Cale> Also, it seems like people try to use it to communicate, but the messages are not meaningfully threaded or interleaved, so it's impossible to read anyone's conversation.
22:35:06 <copumpkin> yeah, probably if you want to tweet from an SMS you need to include other info
22:35:22 <m0nkfish> Cale: that's what bothers me most about it
22:35:27 <idnar> Cale: yeah, it's basically impossible to consume Twitter if you don't do it in realtime
22:35:55 <copumpkin> http://twitter.com/mdreid/status/6291070045 (note the "in reply to" at the bottom)
22:36:04 <copumpkin> it's not ideal, but a decent client will show you the entire thread
22:37:18 <Cale> http://twitter.com/sigfpe/status/6287255837 -- what is this one in reply to?
22:37:44 <copumpkin> he probably just wrote it out by hand :P
22:37:56 <copumpkin> but luckily I follow both of them so I know! ;)
22:38:30 <Cale> Well, at least it's better than YouTube comments.
22:38:54 <copumpkin> and there's a fairly decent haskell community on it :)
22:38:59 <Twey> Cale: I heard you arguing that qsort lesser ++ [pivot] ++ qsort greater was a real qsort a while back
22:39:07 <Cale> Twey: indeed.
22:39:09 <Twey> What was the idea behind that, again?
22:39:31 <copumpkin> qsort lesser ++ qsort greater ;)
22:39:33 <Cale> That the quicksort algorithm is independent of the underlying implementation of sequences.
22:39:38 <copumpkin> [a] -> [b]
22:39:48 <Twey> Ah, I see
22:41:51 <Cale> and "in place" isn't really something you can talk about at the level of abstraction I consider quicksort to be defined.
22:42:25 <Twey> Aye
22:50:32 <Cale> But if you want to argue against using that quicksort, a better argument is that mergesort is better anyway, and not much harder to write.
22:52:54 <dolio> Speaking of sorting, I don't recall if I mentioned, but I gave a quick go at implementing most of the timsort operations that make sense on a list-based sort.
22:53:07 <dolio> And most of them don't seem to be worth it.
22:54:00 <dolio> Although, it's possible my test data wasn't great.
22:54:13 <copumpkin> as in, timsort is overhyped? or it just doesn't work in a list context?
22:54:32 <dolio> The latter.
22:56:05 <dolio> There are a couple parts that you can't implement for lists period.
22:56:40 <dolio> Like, toggling between a more efficient insertion point search during merging.
22:56:49 <dolio> Binary search on lists just doesn't work.
22:56:54 <copumpkin> ah, yeah
22:56:54 <Twey> Hm, I'm not sure I'd agree with that, Cale
22:57:20 <Twey> All the implementations I can come up with for mergesort are much more complex (in code terms, not performance)
22:57:50 <Cale> Well, maybe by a few lines
22:58:04 <Cale> You need to write merge, which is probably the hardest bit.
22:58:08 <Twey> Yeah.
22:58:21 <Twey> It ends up being about ten lines to quicksort's two.
23:00:43 <dolio> Anyhow, I got the best performance using just a function to find non-decreasing/non-increasing sublists.
23:00:55 <copumpkin> if we had merge in the standard library, then we could do one-liner mergesorts too
23:00:58 <copumpkin> nudge nudge wink wink
23:01:19 <Twey> We can already do one-liner mergesorts
23:01:23 <Twey> mergesort = Data.List.sort
23:01:25 <Twey> :√æ
23:01:27 <copumpkin> lol
23:03:37 <Cale> It would also be good to have a few more devices than that, like either something which separates a list into two lists whose interleave is the original, or some kind of binary fold
23:04:19 <Twey> Aye.
23:04:38 <copumpkin> > interleave [1..5] [6..10]
23:04:39 <lambdabot>   [1,6,2,7,3,8,4,9,5,10]
23:05:07 <copumpkin> what other instances of MonadLogic are there?
23:05:09 <dolio> The other things I tried were... having a minimum sublist size. Timsort calculates that from the size of the input array, but that'd be a lot of extra work for a list. No size I tried seemed to have a good speedup...
23:05:20 <Cale> transpose . map take 2 . takeWhile (not . null) . iterate drop 2 $ [1,6,2,7,3,8,4,9,5,10]
23:05:26 <Cale> > transpose . map take 2 . takeWhile (not . null) . iterate drop 2 $ [1,6,2,7,3,8,4,9,5,10]
23:05:28 <lambdabot>   Couldn't match expected type `a1 -> [[a]]'
23:05:28 <lambdabot>         against inferred type `[...
23:05:33 <copumpkin> lol
23:05:37 <Cale> > transpose . map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1,6,2,7,3,8,4,9,5,10]
23:05:39 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10]]
23:05:48 <copumpkin> you think you're so special
23:05:48 <Cale> blah :)
23:05:51 <copumpkin> hrrmpf
23:06:05 <toast-opt_> um, wait, what?
23:06:20 <toast-opt_> did that just split a list in alternating fashion?
23:06:25 <Cale> yes
23:06:27 <toast-opt_> like, a reverse interleave
23:06:28 <Cale> But that eats up most of a line
23:06:34 <toast-opt_> heh, most of
23:06:47 <toast-opt_> um, dang, why did i not get my normal nick
23:06:48 <Cale> especially once you use a pattern match to extract the two parts
23:07:06 <dolio> Keeping a stack of sized sublists, and attempting to merge similarly sized lists, while maintaining a factor-of-2 size difference between stack elements. That's all a lot more extra bookkeeping on lists, though, and I doubt it gets you the cache locality it's supposed to with arrays.
23:07:17 <toast-opt> fixed/
23:07:36 <Cale> dolio: haha, yeah
23:07:38 <dolio> copumpkin: [] is a MonadLogic.
23:07:47 <copumpkin> I figured that :)
23:07:49 <Cale> dolio: cache locality with lists is a lost cause
23:07:51 <ezyang> "but MonadLogic is more efficient!"
23:07:56 <dolio> Cale: Yeah, I figured.
23:08:19 <ezyang> it's too late. night night #haskell
23:08:20 <copumpkin> wow, lots of schools have their own FML sites now
23:08:37 <ivanm> FML?
23:09:18 <copumpkin> **** my life, a new internet phenomenon!
23:09:32 <medfly> schools?
23:09:46 <vy> I installed libghc6-regex-posix-dev deb package but -- despite RWH exercises -- "sad" =~ "(.ad)" :: [String] complains that No instance for (RegexContext Regex [Char] [String]). What might be the cause of the problem?
23:09:52 <copumpkin> universities
23:09:59 <copumpkin> mitfml.com
23:10:07 <copumpkin> lots of others
23:11:05 <medfly> wow...
23:11:48 <copumpkin> > go **** yourself
23:11:49 <lambdabot>   don't be rude
23:12:01 <medfly> lambdabot is great
23:12:35 <osaunders> defube should be a word
23:12:57 <Saizan> vy: i think i've heard that's changed to ([String],[String]) or something, look at the haddock documentation, it should list the instances
23:13:14 * Saizan helping by rumors since 1996
23:13:33 <osaunders> What does FML stand for?
23:13:42 <copumpkin> something my life
23:13:46 <copumpkin> can't remember the first word ;)
23:13:52 <osaunders> Oh.
23:13:59 <osaunders> I think I know what it is.
23:14:01 <idnar> heh
23:14:14 <copumpkin> similar to what I told lambdabot a minute ago
23:16:22 <vy> Saizan: Isn't it possible to browse that using the interpreter? (Something similar to Python's dir() command?)
23:16:39 <copumpkin> Saizan: what happened in 1996?
23:16:53 <c_wraith> vy: :browse actually
23:17:05 <idnar> copumpkin: nobody is really sure, but there are a lot of rumours about it
23:17:11 <copumpkin> lol
23:18:19 <toast-opt> :browse fix
23:19:43 <Saizan> vy: :i RegexContext lists the instances in scope, most of the time
23:20:32 <Saizan> copumpkin: mh, many things but nothing relevant
23:21:58 <copumpkin> :)
23:23:48 <Gracenotes> > fix error
23:23:50 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
23:24:01 <idnar> :fix browse
23:24:59 <vy> Saizan: c_wraith: In displayed list of instances, how can I learn the type of MatchText?
23:27:05 <Saizan> vy: the definition you mean? still :i i'd say, it stands for :info and works on many things
23:27:41 <vy> Oops! I found it: type MatchText source = Array Int (source, (MatchOffset, MatchLength))
23:28:18 <toast-opt> > fix fix
23:28:19 <vy> I wish I could understand what that mean in the context of a regexp compilation.
23:28:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
23:29:56 <copumpkin> newtype WTF a b = WTF (WTF a b -> b)
23:30:06 <osaunders> Oh this is sexual!
23:30:10 * osaunders is learning about types.
23:31:06 <copumpkin> newtype WTF a b = WTF (a -> WTF a b -> b)
23:31:07 <Saizan> vy: maybe this will shed some light http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
23:32:20 <vy> Saizan: Excellent! Thanks.
23:32:53 <osaunders> How to declare types in GCHi?
23:32:57 <osaunders> *do you
23:33:01 <copumpkin> you can't
23:33:04 <copumpkin> you load a file with the types in them
23:33:06 <vy> Saizan: Some if its examples not working too: "foo foo foo" =~ "foo" :: [String]
23:33:23 <osaunders> OK.
23:35:58 <Cale> hmm, I wonder if it would be worth inventing a syntax for a form of let where all constraints are generalised over, since that's what the behaviour is going to be at the top-level anyway
23:37:01 <Saizan> if we make let monomorphic, you mean?
23:37:08 <Cale> yeah
23:37:19 <Cale> and maybe you get insanely large types with lots of equality constraints in general, but it would sure make fixing Haskell 98 code easy to do
23:37:40 <Cale> (or at least I suspect it ought to?)
23:38:14 <Saizan> at this point one could leave the current let alone and add a monomorphic one
23:40:01 <Saizan> or "where all constraints are generalised over" meant something different from the current behaviour?
23:41:00 <Cale> It's different from the current behaviour
23:44:16 <Cale> In the "Let Should Not Be Generalised" paper, there's an example
23:44:26 <Cale> of a GADT with two cases:
23:44:35 <Cale> data R a where
23:44:55 <Cale>   RBool :: (a ~ Bool) => R a
23:45:02 <Cale>   RInt  :: (a ~ Int) => R a
23:45:19 <Cale> and then a function fr:
23:45:19 <Cale> fr :: a -> R a -> Bool
23:45:19 <Cale> fr x y = let g z = not x -- not :: Bool -> Bool
23:45:19 <Cale>          in case y of
23:45:19 <Cale>             RBool -> g ()
23:45:19 <Cale>             RInt -> True
23:45:41 <Cale> The matter of g's type is a bit funny
23:46:05 <Cale> g assumes that  a ~ Bool
23:46:43 <Cale> So GenAll would mean that g gets the inferred type  forall b. (a ~ Bool) => b -> Bool
23:46:53 <Cale> But it would just be a type error presently.
23:47:34 <Cale> and so this  fr  function would actually work with GenAll, though it's a¬†little strange :)
23:48:08 <Saizan> weird indeed :)
23:48:13 <Cale> The disadvantages of GenAll mainly have to do that in many cases it infers very complicated types
23:49:55 <Cale> But it does have the nice property that let x = e in f typechecks if and only if f will typecheck when you substitute e for x in it.
23:49:58 <Saizan> and if you don't generalize at all that's still a type error, right?
23:50:03 <Cale> right
23:50:51 <BMeph> I just Tweeted qsort. Tell me what you think! (Or NOT, if you're Cale... ;)
23:51:16 <copumpkin> nice!
23:51:52 <Cale> funny people :)
23:53:04 <osaunders> Why is not exporting value constructors advantageous?
23:53:24 <Saizan> if you want to guarantee some invariant
23:53:32 <Saizan> like in Data.Map , for example
23:53:37 * osaunders doesn't know what an invariant is.
23:53:54 <BMeph> osaunders: Oh, you export value constructors, just...make sure they're "smart" constructors. ;)
23:54:22 <Saizan> a property of your values that's not enforced simply by the datatype definition
23:54:24 <osaunders> BMeph: But they aren't exported by default.
23:54:24 <Cale> It lets you restrict the scope inside which values of that type are constructed to one module. So you only have to check a finite amount of code to ensure that, say, your trees always stay balanced.
23:54:39 <Cale> Or that some datastructure remains sorted always
23:54:52 <Cale> Or that fractions are kept in lowest terms :)
23:55:06 <Cale> Things like that
23:55:10 <osaunders> OK.
23:55:21 <osaunders> It's useful for proofs then?
23:55:43 <Cale> Well, and keeping your sanity while writing larger programs.
23:56:12 <Cale> Anything which makes it easier to prove things about code also makes it easier to maintain that code from a practical standpoint.
23:56:58 <osaunders> Is this superior to data hiding in OOP?
23:57:06 <Cale> Because even if you don't write down the proofs, you'll have to think about the way in which the code behaves, which is the same thing you'd be doing a little more rigourously in a proof.
23:57:08 <osaunders> Because I found that kind of lame tbh.
23:57:28 <Cale> It is approximately the same thing as encapsulation in OOP.
23:57:30 <maltem> osaunders, "data hiding" is usually just another word for abstract data types
23:57:51 <maltem> which is not special to OOP
23:57:52 <osaunders> maltem: Data hiding refers to protected and private visibility
23:58:02 <maltem> mm ok
23:58:31 <maltem> I never really got to like those ;)
23:58:45 <osaunders> Cale: I would have said types approximate encapsulation.
23:59:01 <Cale> osaunders: not on their own
23:59:27 <Cale> osaunders: Well... you can sort of do encapsulation using (tuples/records of) function types
23:59:37 <Cale> But you can also do it with modules.
23:59:53 <maltem> (because I don't see the reason, most of the time, why this particular method *must* be public/protected/private)
